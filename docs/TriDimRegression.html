<!DOCTYPE html><html><head><title>Help for package TriDimRegression</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {TriDimRegression}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CarbonExample1Data'><p>Carbon, C. C. (2013), data set #1</p></a></li>
<li><a href='#CarbonExample2Data'><p>Carbon, C. C. (2013), data set #2</p></a></li>
<li><a href='#CarbonExample3Data'><p>Carbon, C. C. (2013), data set #3</p></a></li>
<li><a href='#check_exponential_prior'><p>Checks for validity of values for use as exponential distribution parameters.</p></a></li>
<li><a href='#check_normal_prior'><p>Checks for validity of values for use as normal distribution parameters.</p></a></li>
<li><a href='#check_variables'><p>Checks validity of variables' matrix</p></a></li>
<li><a href='#coef_summary'><p>Computes mean and optional quantiles for a coefficient.</p></a></li>
<li><a href='#coef.tridim_transformation'><p>Posterior distributions for transformation coefficients</p>
in full or summarized form.</a></li>
<li><a href='#EyegazeData'><p>Eye gaze calibration data</p></a></li>
<li><a href='#Face3D_M010'><p>Face landmarks, male, #010</p></a></li>
<li><a href='#Face3D_M101'><p>Face landmarks, male, #101</p></a></li>
<li><a href='#Face3D_M244'><p>Face landmarks, male, #244</p></a></li>
<li><a href='#Face3D_M92'><p>Face landmarks, male, #092</p></a></li>
<li><a href='#Face3D_W070'><p>Face landmarks, female, #070</p></a></li>
<li><a href='#Face3D_W097'><p>Face landmarks, female, #097</p></a></li>
<li><a href='#Face3D_W182'><p>Face landmarks, female, #182</p></a></li>
<li><a href='#Face3D_W243'><p>Face landmarks, female, #243</p></a></li>
<li><a href='#fit_transformation'><p>Fitting Bidimensional or Tridimensional Regression / Geometric Transformation Models via Formula.</p></a></li>
<li><a href='#fit_transformation_df'><p>Fitting Bidimensional or Tridimensional Regression / Geometric Transformation Models via Two Tables.</p></a></li>
<li><a href='#FriedmanKohlerData1'><p>Friedman &amp; Kohler (2003), data set #1</p></a></li>
<li><a href='#FriedmanKohlerData2'><p>Friedman &amp; Kohler (2003), data set #2</p></a></li>
<li><a href='#get_beta_n'><p>Returns number of free matrix parameters in addition to translation</p></a></li>
<li><a href='#is.tridim_transformation'><p>Checks if argument is a <code>tridim_transformation</code> object</p></a></li>
<li><a href='#loo.tridim_transformation'><p>Computes an efficient approximate leave-one-out</p>
cross-validation via loo library. It can be used
for a model comparison via loo::loo_compare() function.</a></li>
<li><a href='#m2_affine'><p>2D Affine</p></a></li>
<li><a href='#m2_euclidean'><p>2D Euclidean</p></a></li>
<li><a href='#m2_projective'><p>2D Projective</p></a></li>
<li><a href='#m2_translation'><p>2D Translation Matrix</p></a></li>
<li><a href='#m3_affine'><p>3D Affine</p></a></li>
<li><a href='#m3_euclidean_x'><p>3D Euclidean, rotation about x</p></a></li>
<li><a href='#m3_euclidean_y'><p>3D Euclidean, rotation about y</p></a></li>
<li><a href='#m3_euclidean_z'><p>3D Euclidean, rotation about z</p></a></li>
<li><a href='#m3_projective'><p>3D Projective</p></a></li>
<li><a href='#m3_translation'><p>3D Translation Matrix</p></a></li>
<li><a href='#NakayaData'><p>Nakaya (1997)</p></a></li>
<li><a href='#plot.tridim_transformation'><p>Posterior interval plots for key parameters. Uses bayesplot::mcmc_intervals.</p></a></li>
<li><a href='#predict.tridim_transformation'><p>Computes posterior samples for the posterior predictive distribution.</p></a></li>
<li><a href='#print.tridim_transformation'><p>Prints out tridim_transformation object</p></a></li>
<li><a href='#R2'><p>Computes R-squared using Bayesian R-squared approach.</p>
For detail refer to:
Andrew Gelman, Ben Goodrich, Jonah Gabry, and Aki Vehtari (2018).
R-squared for Bayesian regression models. The American Statistician,
doi:10.1080/00031305.2018.1549100.</a></li>
<li><a href='#summary.tridim_transformation'><p>Summary for a tridim_transformation object</p></a></li>
<li><a href='#transformation_matrix'><p>Transformation matrix, 2D or 3D depending on data and transformation type</p></a></li>
<li><a href='#tridim_transformation-class'><p>Class <code>tridim_transformation</code>.</p></a></li>
<li><a href='#TriDimRegression-package'><p>The 'TriDimRegression' package.</p></a></li>
<li><a href='#variable_summary'><p>Computes mean and optional probabilities for a given</p>
variable.</a></li>
<li><a href='#waic.tridim_transformation'><p>Computes widely applicable information criterion</p>
(WAIC).</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Bayesian Statistics for 2D/3D Transformations</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Fits 2D and 3D geometric transformations via 'Stan' probabilistic programming engine ( 
    Stan Development Team (2021) <a href="https://mc-stan.org">https://mc-stan.org</a>). Returns posterior distribution for individual
    parameters of the fitted distribution. Allows for computation of LOO and WAIC information criteria 
    (Vehtari A, Gelman A, Gabry J (2017) &lt;<a href="https://doi.org/10.1007%2Fs11222-016-9696-4">doi:10.1007/s11222-016-9696-4</a>&gt;) as well as Bayesian R-squared
    (Gelman A, Goodrich B, Gabry J, and Vehtari A (2018) &lt;<a href="https://doi.org/10.1080%2F00031305.2018.1549100">doi:10.1080/00031305.2018.1549100</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/alexander-pastukhov/tridim-regression">https://github.com/alexander-pastukhov/tridim-regression</a>,
<a href="https://alexander-pastukhov.github.io/tridim-regression/">https://alexander-pastukhov.github.io/tridim-regression/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/alexander-pastukhov/tridim-regression/issues">https://github.com/alexander-pastukhov/tridim-regression/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.3.0), loo</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, Rcpp (&ge; 0.12.0), rstan (&ge; 2.26.0), dplyr, future,
glue, purrr, tidyr, Formula, bayesplot</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>BH (&ge; 1.66.0), Rcpp (&ge; 0.12.0), RcppEigen (&ge; 0.3.3.3.0),
RcppParallel (&ge; 5.0.1), rstan (&ge; 2.26.0), StanHeaders (&ge;
2.26.0)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, ggplot2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-13 08:57:45 UTC; ba7dr4</td>
</tr>
<tr>
<td>Author:</td>
<td>Alexander (Sasha) Pastukhov
    <a href="https://orcid.org/0000-0002-8738-8591"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Claus-Christian Carbon
    <a href="https://orcid.org/0000-0002-3446-9347"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alexander (Sasha) Pastukhov &lt;pastukhov.alexander@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-13 14:10:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='CarbonExample1Data'>Carbon, C. C. (2013), data set #1</h2><span id='topic+CarbonExample1Data'></span>

<h3>Description</h3>

<p>Example 1 from the domain of aesthetics to show how the method can be utilized
for assessing the similarity of two portrayed persons, actually the Mona Lisa in the world
famous Louvre version and the only recently re-discovered Prado version.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CarbonExample1Data
</code></pre>


<h3>Format</h3>

<p>A data frame with 36 observations on the following 4 variables:
</p>

<dl>
<dt>depV1, depV2</dt><dd><p>numeric vectors, dependent variables</p>
</dd>
<dt>indepV1, indepV2</dt><dd><p>numeric vectors, independent variables</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://doi.org/10.18637/jss.v052.c01">doi:10.18637/jss.v052.c01</a>
</p>

<hr>
<h2 id='CarbonExample2Data'>Carbon, C. C. (2013), data set #2</h2><span id='topic+CarbonExample2Data'></span>

<h3>Description</h3>

<p>Example 2 originates from the area of geography and inspects the accuracy of
different maps of the city of Paris which were created over the last 350 years as compared
to a recent map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CarbonExample2Data
</code></pre>


<h3>Format</h3>

<p>A data frame with 13 observations on the following 4 variables:
</p>

<dl>
<dt>depV1, depV2</dt><dd><p>numeric vectors, dependent variables</p>
</dd>
<dt>indepV1, indepV2</dt><dd><p>numeric vectors, independent variables</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://doi.org/10.18637/jss.v052.c01">doi:10.18637/jss.v052.c01</a>
</p>

<hr>
<h2 id='CarbonExample3Data'>Carbon, C. C. (2013), data set #3</h2><span id='topic+CarbonExample3Data'></span>

<h3>Description</h3>

<p>Example 3 focuses on demonstrating how good a cognitive map recalculated from
averaged cognitive distance data fits with a related real map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CarbonExample3Data
</code></pre>


<h3>Format</h3>

<p>A data frame with 10 observations on the following 4 variables:
</p>

<dl>
<dt>depV1, depV2</dt><dd><p>numeric vectors, dependent variables</p>
</dd>
<dt>indepV1, indepV2</dt><dd><p>numeric vectors, independent variables</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://doi.org/10.18637/jss.v052.c01">doi:10.18637/jss.v052.c01</a>
</p>

<hr>
<h2 id='check_exponential_prior'>Checks for validity of values for use as exponential distribution parameters.</h2><span id='topic+check_exponential_prior'></span>

<h3>Description</h3>

<p>Should a single non-negative numeric value.
Stops execution with an error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_exponential_prior(values, parameter)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_exponential_prior_+3A_values">values</code></td>
<td>
<p>Parameter for exponential distribution.</p>
</td></tr>
<tr><td><code id="check_exponential_prior_+3A_parameter">parameter</code></td>
<td>
<p>Name of the parameter for which the prior is defined.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical TRUE, if none of the tests fail
</p>


<h3>Examples</h3>

<pre><code class='language-R'>check_exponential_prior(1, "sigma")
</code></pre>

<hr>
<h2 id='check_normal_prior'>Checks for validity of values for use as normal distribution parameters.</h2><span id='topic+check_normal_prior'></span>

<h3>Description</h3>

<p>Should a pair of numeric values, second value should be non-zero.
Stops execution with an error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_normal_prior(values, parameter)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_normal_prior_+3A_values">values</code></td>
<td>
<p>Parameters for normal distribution.</p>
</td></tr>
<tr><td><code id="check_normal_prior_+3A_parameter">parameter</code></td>
<td>
<p>Name of the parameter for which the prior is defined.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical TRUE, if none of the tests fail
</p>


<h3>Examples</h3>

<pre><code class='language-R'>check_normal_prior(c(0, 1), "scale")
</code></pre>

<hr>
<h2 id='check_variables'>Checks validity of variables' matrix</h2><span id='topic+check_variables'></span>

<h3>Description</h3>

<p>Checks whether the matrix is numeric,
has expected number of columns (<code>ncol</code>),
and has no missing/infinite data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_variables(var, var_label)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_variables_+3A_var">var</code></td>
<td>
<p>Matrix N x ncol</p>
</td></tr>
<tr><td><code id="check_variables_+3A_var_label">var_label</code></td>
<td>
<p>Variable label for error messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical TRUE, if none of the tests fail
</p>


<h3>Examples</h3>

<pre><code class='language-R'>check_variables(matrix(c(1, 2, 3, 4), ncol=2), "test matrix")
</code></pre>

<hr>
<h2 id='coef_summary'>Computes mean and optional quantiles for a coefficient.</h2><span id='topic+coef_summary'></span>

<h3>Description</h3>

<p>Computes mean and optional quantiles for a coefficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coef_summary(coef_name, coef_matrix, probs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef_summary_+3A_coef_name">coef_name</code></td>
<td>
<p>String, name of the coefficient.</p>
</td></tr>
<tr><td><code id="coef_summary_+3A_coef_matrix">coef_matrix</code></td>
<td>
<p>Numeric matrix <code>samplesN x 2</code> or a
numeric vector with length <code>samplesN</code>.</p>
</td></tr>
<tr><td><code id="coef_summary_+3A_probs">probs</code></td>
<td>
<p>A numeric vector of quantiles to compute.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with columns &quot;Coef&quot;, &quot;Mean&quot;, and a column
for each quantile.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>coef_summary("test", c(1, 2, 3), NULL)
</code></pre>

<hr>
<h2 id='coef.tridim_transformation'>Posterior distributions for transformation coefficients
in full or summarized form.</h2><span id='topic+coef.tridim_transformation'></span>

<h3>Description</h3>

<p>Posterior distributions for transformation coefficients
in full or summarized form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tridim_transformation'
coef(
  object,
  summary = TRUE,
  probs = c(0.055, 0.945),
  convert_euclidean = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.tridim_transformation_+3A_object">object</code></td>
<td>
<p>An object of class <a href="#topic+tridim_transformation-class">tridim_transformation</a>.</p>
</td></tr>
<tr><td><code id="coef.tridim_transformation_+3A_summary">summary</code></td>
<td>
<p>Whether summary statistics should be returned instead of
raw sample values. Defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="coef.tridim_transformation_+3A_probs">probs</code></td>
<td>
<p>The percentiles used to compute summary, defaults to 89% credible interval.</p>
</td></tr>
<tr><td><code id="coef.tridim_transformation_+3A_convert_euclidean">convert_euclidean</code></td>
<td>
<p>Whether to convert matrix coefficients to scale(phi) and rotation(theta). Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="coef.tridim_transformation_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If summary=FALSE, a list with matrix iterationsN x dimensionsN for
each variable.
If summary=TRUE, a data.frame with columns &quot;dvindex&quot; with mean for each dependent
variable plus optional quantiles columns with names &quot;dvindex_quantile&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>euc2 &lt;- fit_transformation(depV1+depV2~indepV1+indepV2,
                           data = NakayaData,
                           transformation = 'euclidean')

# full posterior distribution
transform_posterior &lt;- coef(euc2, summary=FALSE)

# coefficients' summary with 89% CI
coef(euc2)

# scale and rotation coefficients
coef(euc2, convert_euclidean=TRUE)
</code></pre>

<hr>
<h2 id='EyegazeData'>Eye gaze calibration data</h2><span id='topic+EyegazeData'></span>

<h3>Description</h3>

<p>A dataset containing a monocular eye gaze recording with calibration sequence.
Courtesy of <a href="https://www.uni-bamberg.de/entwicklungspsychologie/transfer/babyforschung-bambi/">Bamberger Baby Institut: BamBI</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EyegazeData
</code></pre>


<h3>Format</h3>

<p>A data frame with 365 rows and 6 variables:
</p>

<dl>
<dt>time</dt><dd><p>sample timestamp, in milliseconds</p>
</dd>
<dt>x, y</dt><dd><p>recorded gaze, in internal eye tracker units</p>
</dd>
<dt>target_x, target_y</dt><dd><p>location of the calibration target on the screen, in pixels</p>
</dd>
<dt>target</dt><dd><p>index of the target within the sequence</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.uni-bamberg.de/entwicklungspsychologie/transfer/babyforschung-bambi/">https://www.uni-bamberg.de/entwicklungspsychologie/transfer/babyforschung-bambi/</a>.
</p>

<hr>
<h2 id='Face3D_M010'>Face landmarks, male, #010</h2><span id='topic+Face3D_M010'></span>

<h3>Description</h3>

<p>Face landmarks, male, #010
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Face3D_M010
</code></pre>


<h3>Format</h3>

<p>A data frame with 64 landmarks on the following 3 variables:
</p>

<dl>
<dt>x, y, z</dt><dd><p>numeric vectors, coordinates of face landmarks</p>
</dd>
</dl>



<h3>Source</h3>

<p>Carbon, C. C. (2012). The Bamberg DADA Face Database (BaDADA). A standardized high quality Face Database with faces of Different Affective states from Different Angles. Unpublished databank. University of Bamberg, Bamberg.
</p>

<hr>
<h2 id='Face3D_M101'>Face landmarks, male, #101</h2><span id='topic+Face3D_M101'></span>

<h3>Description</h3>

<p>Face landmarks, male, #101
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Face3D_M101
</code></pre>


<h3>Format</h3>

<p>A data frame with 64 landmarks on the following 3 variables:
</p>

<dl>
<dt>x, y, z</dt><dd><p>numeric vectors, coordinates of face landmarks</p>
</dd>
</dl>



<h3>Source</h3>

<p>Carbon, C. C. (2012). The Bamberg DADA Face Database (BaDADA). A standardized high quality Face Database with faces of Different Affective states from Different Angles. Unpublished databank. University of Bamberg, Bamberg.
</p>

<hr>
<h2 id='Face3D_M244'>Face landmarks, male, #244</h2><span id='topic+Face3D_M244'></span>

<h3>Description</h3>

<p>Face landmarks, male, #244
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Face3D_M244
</code></pre>


<h3>Format</h3>

<p>A data frame with 64 landmarks on the following 3 variables:
</p>

<dl>
<dt>x, y, z</dt><dd><p>numeric vectors, coordinates of face landmarks</p>
</dd>
</dl>



<h3>Source</h3>

<p>Carbon, C. C. (2012). The Bamberg DADA Face Database (BaDADA). A standardized high quality Face Database with faces of Different Affective states from Different Angles. Unpublished databank. University of Bamberg, Bamberg.
</p>

<hr>
<h2 id='Face3D_M92'>Face landmarks, male, #092</h2><span id='topic+Face3D_M92'></span>

<h3>Description</h3>

<p>Face landmarks, male, #092
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Face3D_M92
</code></pre>


<h3>Format</h3>

<p>A data frame with 64 landmarks on the following 3 variables:
</p>

<dl>
<dt>x, y, z</dt><dd><p>numeric vectors, coordinates of face landmarks</p>
</dd>
</dl>



<h3>Source</h3>

<p>Carbon, C. C. (2012). The Bamberg DADA Face Database (BaDADA). A standardized high quality Face Database with faces of Different Affective states from Different Angles. Unpublished databank. University of Bamberg, Bamberg.
</p>

<hr>
<h2 id='Face3D_W070'>Face landmarks, female, #070</h2><span id='topic+Face3D_W070'></span>

<h3>Description</h3>

<p>Face landmarks, female, #070
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Face3D_W070
</code></pre>


<h3>Format</h3>

<p>A data frame with 64 landmarks on the following 3 variables:
</p>

<dl>
<dt>x, y, z</dt><dd><p>numeric vectors, coordinates of face landmarks</p>
</dd>
</dl>



<h3>Source</h3>

<p>Carbon, C. C. (2012). The Bamberg DADA Face Database (BaDADA). A standardized high quality Face Database with faces of Different Affective states from Different Angles. Unpublished databank. University of Bamberg, Bamberg.
</p>

<hr>
<h2 id='Face3D_W097'>Face landmarks, female, #097</h2><span id='topic+Face3D_W097'></span>

<h3>Description</h3>

<p>Face landmarks, female, #097
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Face3D_W097
</code></pre>


<h3>Format</h3>

<p>A data frame with 64 landmarks on the following 3 variables:
</p>

<dl>
<dt>x, y, z</dt><dd><p>numeric vectors, coordinates of face landmarks</p>
</dd>
</dl>



<h3>Source</h3>

<p>Carbon, C. C. (2012). The Bamberg DADA Face Database (BaDADA). A standardized high quality Face Database with faces of Different Affective states from Different Angles. Unpublished databank. University of Bamberg, Bamberg.
</p>

<hr>
<h2 id='Face3D_W182'>Face landmarks, female, #182</h2><span id='topic+Face3D_W182'></span>

<h3>Description</h3>

<p>Face landmarks, female, #182
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Face3D_W182
</code></pre>


<h3>Format</h3>

<p>A data frame with 64 landmarks on the following 3 variables:
</p>

<dl>
<dt>x, y, z</dt><dd><p>numeric vectors, coordinates of face landmarks</p>
</dd>
</dl>



<h3>Source</h3>

<p>Carbon, C. C. (2012). The Bamberg DADA Face Database (BaDADA). A standardized high quality Face Database with faces of Different Affective states from Different Angles. Unpublished databank. University of Bamberg, Bamberg.
</p>

<hr>
<h2 id='Face3D_W243'>Face landmarks, female, #243</h2><span id='topic+Face3D_W243'></span>

<h3>Description</h3>

<p>Face landmarks, female, #243
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Face3D_W243
</code></pre>


<h3>Format</h3>

<p>A data frame with 64 landmarks on the following 3 variables:
</p>

<dl>
<dt>x, y, z</dt><dd><p>numeric vectors, coordinates of face landmarks</p>
</dd>
</dl>



<h3>Source</h3>

<p>Carbon, C. C. (2012). The Bamberg DADA Face Database (BaDADA). A standardized high quality Face Database with faces of Different Affective states from Different Angles. Unpublished databank. University of Bamberg, Bamberg.
</p>

<hr>
<h2 id='fit_transformation'>Fitting Bidimensional or Tridimensional Regression / Geometric Transformation Models via Formula.</h2><span id='topic+fit_transformation'></span><span id='topic+fit_transformation.formula'></span>

<h3>Description</h3>

<p>Fits Bidimensional or Tridimensional regression / geometric transformation models using
Stan engine. The <code>formula</code> described dependent and independent numeric variables in the
<code>data</code>. See also <code><a href="#topic+fit_transformation_df">fit_transformation_df</a></code>.
</p>
<p>For the 2D data, you can fit <code>"translation"</code> (2 parameters for translation only), <code>"euclidean"</code>
(4 parameters: 2 for translation, 1 for scaling, and 1 for rotation),
<code>"affine"</code> (6 parameters: 2 for translation and 4 that jointly describe scaling, rotation and sheer),
or <code>"projective"</code> (8 parameters: affine plus 2 additional parameters to account for projection).
</p>
<p>For 3D data, you can fit <code>"translation"</code> (3 for translation only), <code>"euclidean_x"</code>, <code>"euclidean_y"</code>,
<code>"euclidean_z"</code> (5 parameters: 3 for translation scale, 1 for rotation, and 1 for scaling),
<code>"affine"</code> (12 parameters: 3 for translation and 9 to account for scaling, rotation, and sheer),
and <code>"projective"</code> (15 parameters: affine plus 3 additional parameters to account for projection).
transformations.
</p>
<p>For details on transformation matrices and computation of scale and rotation parameters please
see <code>vignette("transformation_matrices", package = "TriDimRegression")</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'formula'
fit_transformation(
  formula,
  data,
  transformation,
  priors = NULL,
  chains = 1,
  cores = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_transformation_+3A_formula">formula</code></td>
<td>
<p>a symbolic description of the model to be fitted in the format <code>Xdep + Ydep ~ Xind + Yind</code>, where
<code>Xdep</code> and <code>Ydep</code> are dependent and <code>Xind</code> and <code>Yind</code> are independent variables</p>
</td></tr>
<tr><td><code id="fit_transformation_+3A_data">data</code></td>
<td>
<p>a data frame containing variables for the model.</p>
</td></tr>
<tr><td><code id="fit_transformation_+3A_transformation">transformation</code></td>
<td>
<p>the transformation to be used: <code>"translation"</code> (both 2D and 3D), <code>"euclidean"</code> (2D),
<code>"euclidean_x"</code>, <code>"euclidean_y"</code>, <code>"euclidean_z"</code> (3D, rotation about, respectively, x, y, and z axis),
<code>"affine"</code> (2D and 3D), or <code>"projective"</code> (2D and 3D).</p>
</td></tr>
<tr><td><code id="fit_transformation_+3A_priors">priors</code></td>
<td>
<p>named list of parameters for prior distributions of parameters <code>a</code>
(translation, normal distribution), <code>b</code> (all other parameters, normal distribution),
and <code>sigma</code> (residual variance, exponential). E.g., <code>list("a" = c(0, 10), "b"= c(0, 1), "sigma"=1)</code>.
Default priors are <code>"a" = c(0, max_absolute_difference_in_means(d, iv)) / 2)</code>,
<code>"b" = c(0, max_absolute_difference_in_means(d, iv)) / 2)</code>, <code>"sigma" = 1 * sd(dv)</code>.</p>
</td></tr>
<tr><td><code id="fit_transformation_+3A_chains">chains</code></td>
<td>
<p>Number of chains for sampling.</p>
</td></tr>
<tr><td><code id="fit_transformation_+3A_cores">cores</code></td>
<td>
<p>Number of CPU cores to use for sampling. If omitted, all available cores are used.</p>
</td></tr>
<tr><td><code id="fit_transformation_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="rstan.html#topic+sampling">sampling</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+tridim_transformation-class">tridim_transformation</a> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_transformation_df">fit_transformation_df</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Geometric transformations of 2D data
euc2 &lt;- fit_transformation(depV1 + depV2 ~ indepV1 + indepV2,
                                     NakayaData, 'euclidean')
aff2 &lt;- fit_transformation(depV1 + depV2 ~ indepV1 + indepV2,
                                     NakayaData, 'affine')
prj2 &lt;- fit_transformation(depV1 + depV2 ~ indepV1 + indepV2,
                                     NakayaData, 'projective')

# summary of transformation coefficients
coef(euc2)

# statistical comparison via WAIC criterion
loo::loo_compare(waic(euc2), waic(aff2), waic(prj2))
</code></pre>

<hr>
<h2 id='fit_transformation_df'>Fitting Bidimensional or Tridimensional Regression / Geometric Transformation Models via Two Tables.</h2><span id='topic+fit_transformation_df'></span>

<h3>Description</h3>

<p>Fits Bidimensional or Tridimensional regression / geometric transformation models using
Stan engine. Two sets of coordinates are supplied via <code>iv</code> (for an independent variable)
and <code>dv</code> (for the dependent one). The two tables must have the same dimensions
(both N×2 or N×3).
</p>
<p>For the 2D data, you can fit <code>"translation"</code> (2 for translation only), <code>"euclidean"</code>
(4 parameters: 2 for translation, 1 for scaling, and 1 for rotation),
<code>"affine"</code> (6 parameters: 2 for translation and 4 that jointly describe scaling, rotation and sheer),
or <code>"projective"</code> (8 parameters: affine plus 2 additional parameters to account for projection).
</p>
<p>For 3D data, you can fit <code>"translation"</code> (3 for translation only), <code>"euclidean_x"</code>, <code>"euclidean_y"</code>,
<code>"euclidean_z"</code> (5 parameters: 3 for translation scale, 1 for rotation, and 1 for scaling),
<code>"affine"</code> (12 parameters: 3 for translation and 9 to account for scaling, rotation, and sheer),
and <code>"projective"</code> (15 parameters: affine plus 3 additional parameters to account for projection).
transformations.
</p>
<p>For details on transformation matrices and computation of scale and rotation parameters please
see <code>vignette("transformation_matrices", package = "TriDimRegression")</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_transformation_df(
  iv,
  dv,
  transformation,
  priors = NULL,
  chains = 1,
  cores = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_transformation_df_+3A_iv">iv</code></td>
<td>
<p>a data frame containing independent variable, must by numeric only, N×2 or N×3.</p>
</td></tr>
<tr><td><code id="fit_transformation_df_+3A_dv">dv</code></td>
<td>
<p>a data frame containing dependent variable, must by numeric only, N×2 or N×3.</p>
</td></tr>
<tr><td><code id="fit_transformation_df_+3A_transformation">transformation</code></td>
<td>
<p>the transformation to be used: <code>"translation"</code> (both 2D and 3D), <code>"euclidean"</code> (2D),
<code>"euclidean_x"</code>, <code>"euclidean_y"</code>, <code>"euclidean_z"</code> (3D, rotation about, respectively, x, y, and z axis),
<code>"affine"</code> (2D and 3D), or <code>"projective"</code> (2D and 3D).</p>
</td></tr>
<tr><td><code id="fit_transformation_df_+3A_priors">priors</code></td>
<td>
<p>named list of parameters for prior distributions of parameters <code>a</code>
(translation, normal distribution), <code>b</code> (all other parameters, normal distribution),
and <code>sigma</code> (residual variance, exponential). E.g., <code>list("a" = c(0, 10), "b"= c(0, 1), "sigma"=1)</code>.
Default priors are <code>"a" = c(0, max_absolute_difference_in_means(d, iv)) / 2)</code>,
<code>"b" = c(0, max_absolute_difference_in_means(d, iv)) / 2)</code>, <code>"sigma" = 1 * sd(dv)</code>.</p>
</td></tr>
<tr><td><code id="fit_transformation_df_+3A_chains">chains</code></td>
<td>
<p>Number of chains for sampling.</p>
</td></tr>
<tr><td><code id="fit_transformation_df_+3A_cores">cores</code></td>
<td>
<p>Number of CPU cores to use for sampling. If omitted, all available cores are used.</p>
</td></tr>
<tr><td><code id="fit_transformation_df_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="rstan.html#topic+sampling">sampling</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+tridim_transformation-class">tridim_transformation</a> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_transformation">fit_transformation</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Geometric transformations of 2D data
euc2 &lt;- fit_transformation_df(NakayaData[, 1:2], NakayaData[, 3:4], 'euclidean')
tr3 &lt;- fit_transformation_df(Face3D_W070, Face3D_W097, transformation ='translation')
</code></pre>

<hr>
<h2 id='FriedmanKohlerData1'>Friedman &amp; Kohler (2003), data set #1</h2><span id='topic+FriedmanKohlerData1'></span>

<h3>Description</h3>

<p>Data from Friedman, A., &amp; Kohler, B. (2003). Bidimensional regression: Assessing
the configural similarity and accuracy of cognitive maps and other two-dimensional data sets.
Psychological Methods, 8(4), 468-491. DOI: 10.1037/1082-989X.8.4.468
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FriedmanKohlerData1
</code></pre>


<h3>Format</h3>

<p>A data frame with 4 observations on the following 4 variables:
</p>

<dl>
<dt>depV1, depV2</dt><dd><p>numeric vectors, dependent variables</p>
</dd>
<dt>indepV1, indepV2</dt><dd><p>numeric vectors, independent variables</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://doi.org/10.1037/1082-989X.8.4.468">doi:10.1037/1082-989X.8.4.468</a>
</p>

<hr>
<h2 id='FriedmanKohlerData2'>Friedman &amp; Kohler (2003), data set #2</h2><span id='topic+FriedmanKohlerData2'></span>

<h3>Description</h3>

<p>Data from Friedman, A., &amp; Kohler, B. (2003). Bidimensional regression: Assessing
the configural similarity and accuracy of cognitive maps and other two-dimensional data sets.
Psychological Methods, 8(4), 468-491. DOI: 10.1037/1082-989X.8.4.468
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FriedmanKohlerData2
</code></pre>


<h3>Format</h3>

<p>A data frame with 4 observations on the following 4 variables:
</p>

<dl>
<dt>depV1, depV2</dt><dd><p>numeric vectors, dependent variables</p>
</dd>
<dt>indepV1, indepV2</dt><dd><p>numeric vectors, independent variables</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://doi.org/10.1037/1082-989X.8.4.468">doi:10.1037/1082-989X.8.4.468</a>
</p>

<hr>
<h2 id='get_beta_n'>Returns number of free matrix parameters in addition to translation</h2><span id='topic+get_beta_n'></span>

<h3>Description</h3>

<p>Returns number of free matrix parameters in addition to translation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_beta_n(dimN, transformation)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_beta_n_+3A_dimn">dimN</code></td>
<td>
<p>integer, either 2 or 3</p>
</td></tr>
<tr><td><code id="get_beta_n_+3A_transformation">transformation</code></td>
<td>
<p>string, for 2D <code>"translation"</code>, <code>"euclidean"</code>, <code>"affine"</code>, <code>"projective"</code>. for 3D <code>"translation"</code>, <code>"euclidean_x"</code>, <code>"euclidean_y"</code>, <code>"euclidean_z"</code>, <code>"affine"</code>, <code>"projective"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer, number of free matrix parameters in addition to translation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_beta_n(2, "euclidean") # should return 2
get_beta_n(3, "affine") # should return 9
</code></pre>

<hr>
<h2 id='is.tridim_transformation'>Checks if argument is a <code>tridim_transformation</code> object</h2><span id='topic+is.tridim_transformation'></span>

<h3>Description</h3>

<p>Checks if argument is a <code>tridim_transformation</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.tridim_transformation(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.tridim_transformation_+3A_x">x</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical
</p>

<hr>
<h2 id='loo.tridim_transformation'>Computes an efficient approximate leave-one-out
cross-validation via loo library. It can be used
for a model comparison via loo::loo_compare() function.</h2><span id='topic+loo.tridim_transformation'></span>

<h3>Description</h3>

<p>Computes an efficient approximate leave-one-out
cross-validation via loo library. It can be used
for a model comparison via loo::loo_compare() function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tridim_transformation'
loo(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loo.tridim_transformation_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+tridim_transformation-class">tridim_transformation</a> object</p>
</td></tr>
<tr><td><code id="loo.tridim_transformation_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list, see <code><a href="loo.html#topic+loo">loo::loo()</a></code> for details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>euc2 &lt;- fit_transformation(depV1+depV2~indepV1+indepV2,
  NakayaData, transformation = 'euclidean')
aff2 &lt;- fit_transformation(depV1+depV2~indepV1+indepV2,
  NakayaData, transformation = 'affine')
loo::loo_compare(loo(euc2), loo(aff2))
</code></pre>

<hr>
<h2 id='m2_affine'>2D Affine</h2><span id='topic+m2_affine'></span>

<h3>Description</h3>

<p>2D Affine
</p>


<h3>Usage</h3>

<pre><code class='language-R'>m2_affine(a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="m2_affine_+3A_a">a</code></td>
<td>
<p>numeric, 2: translation</p>
</td></tr>
<tr><td><code id="m2_affine_+3A_b">b</code></td>
<td>
<p>numeric, 4: all other coefficients</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix 3x3
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m2_affine(c(2, 3), c(1, 0.5, 1, 5))
</code></pre>

<hr>
<h2 id='m2_euclidean'>2D Euclidean</h2><span id='topic+m2_euclidean'></span>

<h3>Description</h3>

<p>2D Euclidean
</p>


<h3>Usage</h3>

<pre><code class='language-R'>m2_euclidean(a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="m2_euclidean_+3A_a">a</code></td>
<td>
<p>numeric, 2: translation</p>
</td></tr>
<tr><td><code id="m2_euclidean_+3A_b">b</code></td>
<td>
<p>numeric, 2: all other coefficients</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix 3x3
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m2_euclidean(c(2, 3), c(1, 0.5))
</code></pre>

<hr>
<h2 id='m2_projective'>2D Projective</h2><span id='topic+m2_projective'></span>

<h3>Description</h3>

<p>2D Projective
</p>


<h3>Usage</h3>

<pre><code class='language-R'>m2_projective(a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="m2_projective_+3A_a">a</code></td>
<td>
<p>numeric, 2: translation</p>
</td></tr>
<tr><td><code id="m2_projective_+3A_b">b</code></td>
<td>
<p>numeric, 6: all other coefficients</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix 3x3
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m2_projective(c(2, 3), c(1, 0.5, 1, 5, 2, 4))
</code></pre>

<hr>
<h2 id='m2_translation'>2D Translation Matrix</h2><span id='topic+m2_translation'></span>

<h3>Description</h3>

<p>2D Translation Matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>m2_translation(a, b = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="m2_translation_+3A_a">a</code></td>
<td>
<p>numeric, 2: translation</p>
</td></tr>
<tr><td><code id="m2_translation_+3A_b">b</code></td>
<td>
<p>numeric, ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix 3x3
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m2_translation(c(2, 3))
</code></pre>

<hr>
<h2 id='m3_affine'>3D Affine</h2><span id='topic+m3_affine'></span>

<h3>Description</h3>

<p>3D Affine
</p>


<h3>Usage</h3>

<pre><code class='language-R'>m3_affine(a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="m3_affine_+3A_a">a</code></td>
<td>
<p>numeric, 3: translation</p>
</td></tr>
<tr><td><code id="m3_affine_+3A_b">b</code></td>
<td>
<p>numeric, 9: all other coefficients</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix 4x4
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m3_affine(c(2, 3, 1), c(0.5, 0.2, 4, 2, 6, 3, 2, 5, 1))
</code></pre>

<hr>
<h2 id='m3_euclidean_x'>3D Euclidean, rotation about x</h2><span id='topic+m3_euclidean_x'></span>

<h3>Description</h3>

<p>3D Euclidean, rotation about x
</p>


<h3>Usage</h3>

<pre><code class='language-R'>m3_euclidean_x(a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="m3_euclidean_x_+3A_a">a</code></td>
<td>
<p>numeric, 3: translation</p>
</td></tr>
<tr><td><code id="m3_euclidean_x_+3A_b">b</code></td>
<td>
<p>numeric, 2: scaling and rotation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix 4x4
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m3_euclidean_x(c(2, 3, 1), c(0.5, 0.2))
</code></pre>

<hr>
<h2 id='m3_euclidean_y'>3D Euclidean, rotation about y</h2><span id='topic+m3_euclidean_y'></span>

<h3>Description</h3>

<p>3D Euclidean, rotation about y
</p>


<h3>Usage</h3>

<pre><code class='language-R'>m3_euclidean_y(a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="m3_euclidean_y_+3A_a">a</code></td>
<td>
<p>numeric, 3: translation</p>
</td></tr>
<tr><td><code id="m3_euclidean_y_+3A_b">b</code></td>
<td>
<p>numeric, 2: scaling and rotation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix 4x4
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m3_euclidean_y(c(2, 3, 1), c(0.5, 0.2))
</code></pre>

<hr>
<h2 id='m3_euclidean_z'>3D Euclidean, rotation about z</h2><span id='topic+m3_euclidean_z'></span>

<h3>Description</h3>

<p>3D Euclidean, rotation about z
</p>


<h3>Usage</h3>

<pre><code class='language-R'>m3_euclidean_z(a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="m3_euclidean_z_+3A_a">a</code></td>
<td>
<p>numeric, 3: translation</p>
</td></tr>
<tr><td><code id="m3_euclidean_z_+3A_b">b</code></td>
<td>
<p>numeric, 2: scaling and rotation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix 4x4
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m3_euclidean_z(c(2, 3, 1), c(0.5, 0.2))
</code></pre>

<hr>
<h2 id='m3_projective'>3D Projective</h2><span id='topic+m3_projective'></span>

<h3>Description</h3>

<p>3D Projective
</p>


<h3>Usage</h3>

<pre><code class='language-R'>m3_projective(a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="m3_projective_+3A_a">a</code></td>
<td>
<p>numeric, 3: translation</p>
</td></tr>
<tr><td><code id="m3_projective_+3A_b">b</code></td>
<td>
<p>numeric, 12: all other coefficients</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix 4x4
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m3_projective(c(2, 3, 1), c(0.5, 0.2, 4, 2, 6, 3, 2, 5, 1, 6, 8, 9))
</code></pre>

<hr>
<h2 id='m3_translation'>3D Translation Matrix</h2><span id='topic+m3_translation'></span>

<h3>Description</h3>

<p>3D Translation Matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>m3_translation(a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="m3_translation_+3A_a">a</code></td>
<td>
<p>numeric, 3: translation</p>
</td></tr>
<tr><td><code id="m3_translation_+3A_b">b</code></td>
<td>
<p>numeric, ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix 4x4
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m3_translation(c(2, 3, 1))
</code></pre>

<hr>
<h2 id='NakayaData'>Nakaya (1997)</h2><span id='topic+NakayaData'></span>

<h3>Description</h3>

<p>Nakaya, T. (1997) Statistical inferences in bidimensional regression models. Geographical Analysis, 29(2), 169-186.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NakayaData
</code></pre>


<h3>Format</h3>

<p>A data frame with 19 observations on the following 4 variables:
</p>

<dl>
<dt>depV1, depV2</dt><dd><p>numeric vectors, dependent variables</p>
</dd>
<dt>indepV1, indepV2</dt><dd><p>numeric vectors, independent variables</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://doi.org/10.1111/j.1538-4632.1997.tb00954.x">doi:10.1111/j.1538-4632.1997.tb00954.x</a>
</p>

<hr>
<h2 id='plot.tridim_transformation'>Posterior interval plots for key parameters. Uses bayesplot::mcmc_intervals.</h2><span id='topic+plot.tridim_transformation'></span>

<h3>Description</h3>

<p>Posterior interval plots for key parameters. Uses bayesplot::mcmc_intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tridim_transformation'
plot(x, convert_euclidean = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.tridim_transformation_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+tridim_transformation-class">tridim_transformation</a> object</p>
</td></tr>
<tr><td><code id="plot.tridim_transformation_+3A_convert_euclidean">convert_euclidean</code></td>
<td>
<p>Whether to convert matrix coefficients to scale(phi) and rotation(theta). Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.tridim_transformation_+3A_...">...</code></td>
<td>
<p>Extra parameters to be passed to <code><a href="bayesplot.html#topic+MCMC-intervals">bayesplot::mcmc_intervals()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object produced by <code><a href="bayesplot.html#topic+MCMC-intervals">bayesplot::mcmc_intervals()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>euc2 &lt;- fit_transformation(depV1+depV2~indepV1+indepV2,
                           data = NakayaData,
                           transformation = 'euclidean')
plot(euc2)

# same but for converted coefficients
plot(euc2, convert_euclidean=TRUE)
</code></pre>

<hr>
<h2 id='predict.tridim_transformation'>Computes posterior samples for the posterior predictive distribution.</h2><span id='topic+predict.tridim_transformation'></span>

<h3>Description</h3>

<p>Predicted values based on the bi/tridimensional regression model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tridim_transformation'
predict(object, newdata = NULL, summary = TRUE, probs = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.tridim_transformation_+3A_object">object</code></td>
<td>
<p>An object of class <a href="#topic+tridim_transformation-class">tridim_transformation</a></p>
</td></tr>
<tr><td><code id="predict.tridim_transformation_+3A_newdata">newdata</code></td>
<td>
<p>An optional two column data frame with independent variables.
If omitted, the fitted values are used.</p>
</td></tr>
<tr><td><code id="predict.tridim_transformation_+3A_summary">summary</code></td>
<td>
<p>Whether summary statistics should be returned instead of
raw sample values. Defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="predict.tridim_transformation_+3A_probs">probs</code></td>
<td>
<p>The percentiles used to compute summary, defaults to NULL (no CI).</p>
</td></tr>
<tr><td><code id="predict.tridim_transformation_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If summary=FALSE, a numeric matrix iterationsN x observationsN x variablesN.
If summary=TRUE, a data.frame with columns &quot;dvindex&quot; with mean for each dependent
variable plus optional quantiles columns with names &quot;dvindex_quantile&quot;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_transformation">fit_transformation</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>euc2 &lt;- fit_transformation(depV1+depV2~indepV1+indepV2,
  NakayaData, transformation = 'euclidean')

# prediction summary
predictions &lt;- predict(euc2)

# full posterior prediction samples
predictions &lt;- predict(euc2, summary=FALSE)
</code></pre>

<hr>
<h2 id='print.tridim_transformation'>Prints out tridim_transformation object</h2><span id='topic+print.tridim_transformation'></span>

<h3>Description</h3>

<p>Prints out tridim_transformation object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tridim_transformation'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.tridim_transformation_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+tridim_transformation-class">tridim_transformation</a> object</p>
</td></tr>
<tr><td><code id="print.tridim_transformation_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing, console output only.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>euc2 &lt;- fit_transformation(depV1+depV2~indepV1+indepV2,
                           data = NakayaData,
                           transformation = 'euclidean')
euc2
</code></pre>

<hr>
<h2 id='R2'>Computes R-squared using Bayesian R-squared approach.
For detail refer to:
Andrew Gelman, Ben Goodrich, Jonah Gabry, and Aki Vehtari (2018).
R-squared for Bayesian regression models. The American Statistician,
doi:10.1080/00031305.2018.1549100.</h2><span id='topic+R2'></span><span id='topic+R2.tridim_transformation'></span>

<h3>Description</h3>

<p>Computes R-squared using Bayesian R-squared approach.
For detail refer to:
Andrew Gelman, Ben Goodrich, Jonah Gabry, and Aki Vehtari (2018).
R-squared for Bayesian regression models. The American Statistician,
doi:10.1080/00031305.2018.1549100.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tridim_transformation'
R2(object, summary = TRUE, probs = c(0.055, 0.945), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="R2_+3A_object">object</code></td>
<td>
<p>An object of class <a href="#topic+tridim_transformation-class">tridim_transformation</a></p>
</td></tr>
<tr><td><code id="R2_+3A_summary">summary</code></td>
<td>
<p>Whether summary statistics should be returned instead of
raw sample values. Defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="R2_+3A_probs">probs</code></td>
<td>
<p>The percentiles used to compute summary, defaults to 89% credible interval.</p>
</td></tr>
<tr><td><code id="R2_+3A_...">...</code></td>
<td>
<p>Unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of values or a data.frame with summary
</p>


<h3>Examples</h3>

<pre><code class='language-R'>euc2 &lt;- fit_transformation(depV1+depV2~indepV1+indepV2,
  NakayaData, transformation = 'euclidean')
R2(euc2)
</code></pre>

<hr>
<h2 id='summary.tridim_transformation'>Summary for a tridim_transformation object</h2><span id='topic+summary.tridim_transformation'></span>

<h3>Description</h3>

<p>Summary for a tridim_transformation object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tridim_transformation'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.tridim_transformation_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+tridim_transformation-class">tridim_transformation</a> object</p>
</td></tr>
<tr><td><code id="summary.tridim_transformation_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing, console output only.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>euc2 &lt;- fit_transformation(depV1+depV2~indepV1+indepV2,
                           data = NakayaData,
                           transformation = 'euclidean')
summary(euc2)
</code></pre>

<hr>
<h2 id='transformation_matrix'>Transformation matrix, 2D or 3D depending on data and transformation type</h2><span id='topic+transformation_matrix'></span>

<h3>Description</h3>

<p>Transformation matrix, 2D or 3D depending on data and transformation type
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="transformation_matrix_+3A_object">object</code></td>
<td>
<p><a href="#topic+tridim_transformation-class">tridim_transformation</a> object</p>
</td></tr>
<tr><td><code id="transformation_matrix_+3A_summary">summary</code></td>
<td>
<p>Whether summary statistics should be returned instead of
raw sample values. Defaults to <code>TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix 3x3  for 2D transformation or matrix 4x4 for 3D transformation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>euc2 &lt;- fit_transformation(depV1+depV2~indepV1+indepV2,
                           data = NakayaData,
                           transformation = 'euclidean')
transformation_matrix(euc2)
</code></pre>

<hr>
<h2 id='tridim_transformation-class'>Class <code>tridim_transformation</code>.</h2><span id='topic+tridim_transformation-class'></span><span id='topic+tridim_transformation'></span>

<h3>Description</h3>

<p>Geometric transformations fitted with the
<code><a href="#topic+fit_transformation">fit_transformation</a></code> function
represented as a <code>tridim_transformation</code> object with information about transformation, data dimension,
call formula, and fitted <code><a href="rstan.html#topic+stanfit-class">stanfit</a></code> object,
</p>


<h3>Details</h3>

<p>See <code>methods(class = "tridim_transformation")</code> for an overview of available methods.
</p>


<h3>Slots</h3>


<dl>
<dt><code>transformation</code></dt><dd><p>A <code>string</code> with the transformation name.</p>
</dd>
<dt><code>formula</code></dt><dd><p>A <code><a href="Formula.html#topic+Formula">formula</a></code> object.</p>
</dd>
<dt><code>Ndim</code></dt><dd><p>An <code>integer</code> with data dimension, either <code>2</code> or <code>3</code>.</p>
</dd>
<dt><code>data</code></dt><dd><p>A <code>list</code> containing variables used for the <code><a href="rstan.html#topic+sampling">sampling</a></code>.</p>
</dd>
<dt><code>stanmodel</code></dt><dd><p>A <code><a href="rstan.html#topic+stanmodel-class">stanmodel</a></code> used for sampling.</p>
</dd>
<dt><code>stanfit</code></dt><dd><p>a <code><a href="rstan.html#topic+stanfit-class">stanfit</a></code> object.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+fit_transformation">fit_transformation</a></code>
</p>

<hr>
<h2 id='TriDimRegression-package'>The 'TriDimRegression' package.</h2><span id='topic+TriDimRegression-package'></span><span id='topic+_PACKAGE'></span><span id='topic+TriDimRegression'></span>

<h3>Description</h3>

<p>Fits 2D and 3D geometric transformations. Provides posterior via Stan.
Includes computation of LOO and WAIC information criteria, R-squared.
</p>
<p>To fit transformation, call the main function either via a formula that specifies
dependent and independent variables with the <code>data</code> table or by supplying two tables
one containing all independent variables and one containing all dependent variables.
</p>
<p>For the 2D data, you can fit <code>"translation"</code> (2 parameters for translation only), <code>"euclidean"</code>
(4 parameters: 2 for translation, 1 for scaling, and 1 for rotation),
<code>"affine"</code> (6 parameters: 2 for translation and 4 that jointly describe scaling, rotation and sheer),
or <code>"projective"</code> (8 parameters: affine plus 2 additional parameters to account for projection).
For 3D data, you can fit <code>"translation"</code> (3 for translation only), <code>"euclidean_x"</code>, <code>"euclidean_y"</code>,
<code>"euclidean_z"</code> (5 parameters: 3 for translation scale, 1 for rotation, and 1 for scaling),
<code>"affine"</code> (12 parameters: 3 for translation and 9 to account for scaling, rotation, and sheer),
and <code>"projective"</code> (15 parameters: affine plus 3 additional parameters to account for projection).
transformations. For details on transformation matrices and computation of scale and rotation parameters please
see <code>vignette("transformation_matrices", package = "TriDimRegression")</code>
</p>
<p>Once the data is fitted, you can extract the transformation coefficients via <code><a href="stats.html#topic+coef">coef</a></code> function and the matrix
itself via  <code><a href="#topic+transformation_matrix">transformation_matrix</a></code>. Predicted data, either based on the original data or on the new data,
can be generated via  <code><a href="stats.html#topic+predict">predict</a></code>. Bayesian R-squared can be computed with or without adjustment via
<code><a href="#topic+R2">R2</a></code> function. In all three cases, you have choice between summary (mean + specified quantiles) or full
posterior samples.  <code>loo</code> and  <code>waic</code> provide corresponding measures that can be used for comparison
via <code><a href="loo.html#topic+loo_compare">loo::loo_compare()</a></code> function.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Alexander (Sasha) Pastukhov <a href="mailto:pastukhov.alexander@gmail.com">pastukhov.alexander@gmail.com</a> (<a href="https://orcid.org/0000-0002-8738-8591">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Claus-Christian Carbon <a href="mailto:ccc@experimental-psychology.com">ccc@experimental-psychology.com</a> (<a href="https://orcid.org/0000-0002-3446-9347">ORCID</a>)
</p>
</li></ul>



<h3>References</h3>

<p>Stan Development Team (2020). RStan: the R interface to Stan. R package version 2.19.3. https://mc-stan.org
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_transformation">fit_transformation</a></code>
<code><a href="#topic+fit_transformation_df">fit_transformation_df</a></code>
<code><a href="#topic+tridim_transformation-class">tridim_transformation</a></code>
<code>vignette("transformation_matrices", package = "TriDimRegression")</code>
<code>vignette("calibration", package = "TriDimRegression")</code>
<code>vignette("comparing_faces", package = "TriDimRegression")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Fitting via formula
euc2 &lt;- fit_transformation(depV1 + depV2 ~ indepV1 + indepV2,
                           NakayaData, 'euclidean')
aff2 &lt;- fit_transformation(depV1 + depV2 ~ indepV1 + indepV2,
                           NakayaData, 'affine')
prj2 &lt;- fit_transformation(depV1 + depV2 ~ indepV1 + indepV2,
                           NakayaData, 'projective')

# summary of transformation coefficients
coef(euc2)

# statistical comparison via WAIC criterion
loo::loo_compare(waic(euc2), waic(aff2), waic(prj2))

# Fitting via two tables
euc2 &lt;- fit_transformation_df(NakayaData[, 1:2], NakayaData[, 3:4],
  'euclidean')
tr3 &lt;- fit_transformation_df(Face3D_W070, Face3D_W097, transformation ='translation')
</code></pre>

<hr>
<h2 id='variable_summary'>Computes mean and optional probabilities for a given
variable.</h2><span id='topic+variable_summary'></span>

<h3>Description</h3>

<p>Computes mean and optional probabilities for a given
variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variable_summary(var_name, var_matrix, probs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="variable_summary_+3A_var_name">var_name</code></td>
<td>
<p>String, name of the dependent variable</p>
</td></tr>
<tr><td><code id="variable_summary_+3A_var_matrix">var_matrix</code></td>
<td>
<p>Numeric matrix samplesN x observationsN.</p>
</td></tr>
<tr><td><code id="variable_summary_+3A_probs">probs</code></td>
<td>
<p>A numeric vector of quantiles to compute.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with &quot;var_name&quot; column for the mean and
&quot;var_name_prob&quot; columns for each probability.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>variable_summary("test", matrix(1:1000, ncol = 1), c(0.05, 0.95))
</code></pre>

<hr>
<h2 id='waic.tridim_transformation'>Computes widely applicable information criterion
(WAIC).</h2><span id='topic+waic.tridim_transformation'></span>

<h3>Description</h3>

<p>Computes widely applicable information criterion
via loo library. It can be used for a model comparison via
<a href="loo.html#topic+loo_compare">loo::loo_compare()</a> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tridim_transformation'
waic(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="waic.tridim_transformation_+3A_x">x</code></td>
<td>
<p>A [tridim_transformation[<code><a href="#topic+tridim_transformation-class">tridim_transformation-class()</a></code> object</p>
</td></tr>
<tr><td><code id="waic.tridim_transformation_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list, see <code><a href="loo.html#topic+waic">loo::waic()</a></code> for details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>euc2 &lt;- fit_transformation(depV1+depV2~indepV1+indepV2,
  NakayaData, transformation = 'euclidean')
aff2 &lt;- fit_transformation(depV1+depV2~indepV1+indepV2,
  NakayaData, transformation = 'affine')
loo::loo_compare(waic(euc2), waic(aff2))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
