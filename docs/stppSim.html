<!DOCTYPE html><html><head><title>Help for package stppSim</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {stppSim}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#artif_spo'><p>Artificial spatial origins</p></a></li>
<li><a href='#camden_crimes'><p>Records of crimes of Camden Borough of London,</p>
UK, 2021 (Source: https://data.police.uk/data/)</a></li>
<li><a href='#chull_poly'><p>Boundary surrounding a set of points</p></a></li>
<li><a href='#compare_areas'><p>Compare two areas</p></a></li>
<li><a href='#date_checker'><p>Date (Format) Checker</p></a></li>
<li><a href='#extract_coords'><p>Coordinates extraction</p></a></li>
<li><a href='#gtp'><p>Global temporal pattern (GTP)</p></a></li>
<li><a href='#make_grids'><p>Make square grids</p></a></li>
<li><a href='#NRepeat'><p>Near Repeat calculator using the Knox test</p></a></li>
<li><a href='#p_prob'><p>Proportional (probability) distribution</p></a></li>
<li><a href='#poly'><p>Boundary coordinates</p></a></li>
<li><a href='#poly_tester'><p>Geometry and Coordinate</p>
Reference System test of a polygon</a></li>
<li><a href='#psim_artif'><p>Stpp from synthetic origins</p></a></li>
<li><a href='#psim_real'><p>Stpp from real (sample) origins</p></a></li>
<li><a href='#snap_points_to_lines'><p>Snapping point to network</p></a></li>
<li><a href='#space_restriction'><p>Space restriction raster map</p></a></li>
<li><a href='#stm'><p>Spatial and temporal model</p></a></li>
<li><a href='#stp_learner'><p>Learning the spatiotemporal properties of</p>
a sample data</a></li>
<li><a href='#walker'><p>A landscape walker</p></a></li>
<li><a href='#xyt_data'><p>Spatiotemporal point data</p></a></li>
<li><a href='#xyz'><p>xyz data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Spatiotemporal Point Patterns Simulation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.2</td>
</tr>
<tr>
<td>Author:</td>
<td>Monsuru Adepeju [cre, aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Monsuru Adepeju &lt;monsuur2010@yahoo.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Generates artificial spatiotemporal (ST) point patterns
  and/or interactions through the integration of microsimulation 
  (Holm, E., (2017)&lt;<a href="https://doi.org/10.1002%2F9781118786352.wbieg0320">doi:10.1002/9781118786352.wbieg0320</a>&gt;) 
  and agent-based models 
  (Bonabeau, E., (2002)&lt;<a href="https://doi.org/10.1073%2Fpnas.082080899">doi:10.1073/pnas.082080899</a>&gt;). 
  The tool enables users to configure the actions of a group of 
  'walkers', which can be agents, objects, individuals, and more. 
  Their engagements with both spatial landscapes (Quaglietta, L. and Porto, M., 
  (2019)&lt;<a href="https://doi.org/10.1186%2Fs40462-019-0154-8">doi:10.1186/s40462-019-0154-8</a>&gt;) 
  and time domains result in specific spatiotemporal point patterns 
  and/or interactions. These emerging spatiotemporal patterns can be 
  visualized, analyzed, and then employed for both spatial and 
  temporal model assessments. Given the growing scarcity of detailed 
  spatiotemporal data, this package offers an alternative dataset 
  for a broad spectrum of studies in both the social and life sciences.</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/MAnalytics/stppSim">https://github.com/MAnalytics/stppSim</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Manalytics/stppSim/issues/new/choose">https://github.com/Manalytics/stppSim/issues/new/choose</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>splancs, dplyr, tidyr, magrittr, sf, sp, ks, terra, raster,
SiMRiv, data.table, tibble, stringr, lubridate, spatstat.geom,
sparr, chron, ggplot2, geosphere, leaflet, methods, cowplot,
gstat, otuSummary, progressr, future.apply</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, graphics, grDevices, utils</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Collate:</td>
<td>'NRepeat.R' 'artif_spo.R' 'chull_poly.R' 'compare_areas.R'
'data.R' 'date_checker.R' 'extract_coords.R' 'gtp.R'
'make_grids.R' 'p_prob.R' 'poly_tester.R' 'walker.R'
'psim_artif.R' 'psim_real.R' 'snap_points_to_lines.R'
'space_restriction.R' 'stm.R' 'stp_learner.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-29 20:25:12 UTC; 55131065</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-29 21:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='artif_spo'>Artificial spatial origins</h2><span id='topic+artif_spo'></span>

<h3>Description</h3>

<p>Simulates spatial locations to serve
as origins of walkers. If provided, spaces covered
by restriction features are avoided. Final
origins are assigned probability values
indicating the strengths of the origins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>artif_spo(poly, n_origin=50, restriction_feat = NULL,
n_foci=5, foci_separation = 10, mfocal = NULL,
conc_type = "nucleated", p_ratio)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="artif_spo_+3A_poly">poly</code></td>
<td>
<p>(An sf or S4 object)
a polygon shapefile defining the extent
of the landscape</p>
</td></tr>
<tr><td><code id="artif_spo_+3A_n_origin">n_origin</code></td>
<td>
<p>number of locations to serve as
origins for walkers. Default:<code>50</code>.</p>
</td></tr>
<tr><td><code id="artif_spo_+3A_restriction_feat">restriction_feat</code></td>
<td>
<p>(An S4 object) optional
shapefile containing features
in which walkers cannot walk through.
Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="artif_spo_+3A_n_foci">n_foci</code></td>
<td>
<p>number of focal points amongst the origin
locations. The origins to serve as focal
points are based on random selection. <code>n_foci</code> must be
smaller than <code>n_origins</code>.</p>
</td></tr>
<tr><td><code id="artif_spo_+3A_foci_separation">foci_separation</code></td>
<td>
<p>a value from <code>1</code> to <code>100</code>
indicating the nearness of focal points to one another.
A <code>0</code> separation indicates that focal points are in
close proximity
of one another, while a <code>100</code> indicates focal points being
evenly distributed across space.</p>
</td></tr>
<tr><td><code id="artif_spo_+3A_mfocal">mfocal</code></td>
<td>
<p>the c(x, y) coordinates of a single point,
representing a pre-defined <code>main</code> focal point (origin)
in the area. The default is <code>NULL</code> in which a random
coordinate is chosen within the <code>polygon</code> area.</p>
</td></tr>
<tr><td><code id="artif_spo_+3A_conc_type">conc_type</code></td>
<td>
<p>concentration of the rest of the
origins (non-focal origins) around the focal ones. The options
are <code>"nucleated"</code> and <code>"dispersed"</code>.</p>
</td></tr>
<tr><td><code id="artif_spo_+3A_p_ratio">p_ratio</code></td>
<td>
<p>the smaller of the
two terms of proportional ratios.
For example, a value of <code>20</code>
implies <code>20:80</code> proportional ratios.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The focal origins (<code>n_foci</code>) serve as the central locations
(such as, city centres). The <code>foci_separation</code> indicates
the nearness of focal origins from one another.
The <code>conc_type</code> argument allows a user to specify
the type of spatial concentration exhibited by the non-focal
origin around the focal ones.
If <code>restriction_feat</code> is provided, its features help
to prevent the occurrence of any events in the areas
occupied by the features.
</p>


<h3>Value</h3>

<p>Returns a list detailing the
properties of the generated spatial origins
with associated
strength (probability) values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#load boundary of Camden
load(file = system.file("extdata", "camden.rda",
package="stppSim"))
boundary = camden$boundary # get boundary
landuse &lt;- camden$landuse
spo &lt;- artif_spo(poly = boundary, n_origin = 50,
restriction_feat = landuse, n_foci=5, foci_separation = 0,
mfocal = NULL, conc_type = "dispersed", p_ratio=20)
</code></pre>

<hr>
<h2 id='camden_crimes'>Records of crimes of Camden Borough of London,
UK, 2021 (Source: https://data.police.uk/data/)</h2><span id='topic+camden_crimes'></span>

<h3>Description</h3>

<p>Data comprising 'Theft' and 'Criminal Damage'
records of Camden Borough of London, UK
for the year 2021 (Source: <code style="white-space: pre;">&#8288;https://data.police.uk/&#8288;</code>).
Note: Police.uk data is aggregated at monthly
scale (<code>yyyy-mm</code>). But, the data provided here has been
disaggregated to daily scale by adding fake
'daily' stamps (to give <code>yyyy-mm-dd</code>). So, caution should
be taken when interpreting the results based on
full date.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>camden_crimes
</code></pre>


<h3>Format</h3>

<p>A matrix containing four variables
</p>

<ul>
<li><p> x: x coordinate
</p>
</li>
<li><p> y: y coordinate
</p>
</li>
<li><p> date: date of occurence
</p>
</li>
<li><p> type: types of crime
</p>
</li></ul>


<hr>
<h2 id='chull_poly'>Boundary surrounding a set of points</h2><span id='topic+chull_poly'></span>

<h3>Description</h3>

<p>Generates a boundary (polygon) around
a set of points, using Convex Hull technique
(Eddy, W. F, 1977).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chull_poly(xycoords,
crsys = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chull_poly_+3A_xycoords">xycoords</code></td>
<td>
<p>(matrix) A 2-column
coordinate vectors of points: <code>x</code> - the eastings,
and <code>y</code> - the northing.</p>
</td></tr>
<tr><td><code id="chull_poly_+3A_crsys">crsys</code></td>
<td>
<p>Optional string specifying the coordinate
reference system (crs) of the resulting boundary, e.g.,
the crs string &quot;+proj=longlat +datum=WGS84&quot; transform
the resulting boundary to wgs84 system.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Draws an arbitrary boundary around
spatial points by joining the outer-most
points by lines.
</p>


<h3>Value</h3>

<p>Returns a &quot;SpatialPolygonsDataFrame&quot;
object representing the boundary
surround the spatial points
</p>


<h3>References</h3>

<p>Eddy, W. F. (1977).
A new convex hull algorithm for planar sets.
ACM Transactions on Mathematical Software,
3, 398&ndash;403.10.1145/355759.355766.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(xyt_data)
#extract xy coordinates only
xy &lt;- matrix(as.numeric(xyt_data[,1:2]),,2)
bry &lt;- chull_poly(xy, crsys = NULL)
#visualise result
#plot(bry) #to plot
#points(xy[,1], xy[,2], add=TRUE)
</code></pre>

<hr>
<h2 id='compare_areas'>Compare two areas</h2><span id='topic+compare_areas'></span>

<h3>Description</h3>

<p>To compare the sizes of two
areas (boundary shapefiles).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_areas(area1, area2,
display_output = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_areas_+3A_area1">area1</code></td>
<td>
<p>(as <code>spatialPolygons</code>,
<code>spatialPolygonDataFrames</code>, or
<code style="white-space: pre;">&#8288;simple features&#8288;</code>). the polygon object of the
first area.</p>
</td></tr>
<tr><td><code id="compare_areas_+3A_area2">area2</code></td>
<td>
<p>(as <code>spatialPolygons</code>,
<code>spatialPolygonDataFrames</code>, or
<code style="white-space: pre;">&#8288;simple features&#8288;</code>). the polygon object of the
second area.</p>
</td></tr>
<tr><td><code id="compare_areas_+3A_display_output">display_output</code></td>
<td>
<p>(logical) Whether to print output
in the console.
Default: <code>FALSE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compares the sizes of two areas (polygon shapefiles).
The two shapefiles can be in any <code>crs</code>,
and any spatial object formats. If enabled, the output (a value)
comparing the area of the two polygons is printed. This value can
be used to scale some specific spatial parameters, including
<code>n_origin</code>, <code>s_threshold</code>, and <code>step_length</code>.
</p>


<h3>Value</h3>

<p>Returns a plot and a text (string) comparing
the sizes of two areas.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#load 'area1' object - boundary of Camden, UK
load(file = system.file("extdata", "camden.rda",
package="stppSim"))
camden_boundary = camden$boundary

#load 'area2' - boundary of Birmingham, UK
load(file = system.file("extdata", "birmingham_boundary.rda",
package="stppSim"))

#run
compare_areas(area1 = camden_boundary,
area2 = birmingham_boundary, display_output = FALSE)
</code></pre>

<hr>
<h2 id='date_checker'>Date (Format) Checker</h2><span id='topic+date_checker'></span>

<h3>Description</h3>

<p>Checks if date is in a
specified format (i.e. <code>'yyyy-mm-dd'</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_checker(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="date_checker_+3A_x">x</code></td>
<td>
<p>A date or a vector of date values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns <code>"TRUE"</code> if all
date entries are in the specified format
(<code style="white-space: pre;">&#8288;"yyyy-mm-dd&#8288;</code>),
and <code>FALSE</code> if at least one date is not
in the format.
</p>


<h3>Value</h3>

<p>Returns TRUE or FALSE
</p>


<h3>Examples</h3>

<pre><code class='language-R'>date_list_1 &lt;- c("2021-09-12", "2016-xx-02",
"09/08/2012")
date_checker(date_list_1)
#&gt; FALSE (Entries 2 and 3
#are incorrect date inputs)
date_list_2 &lt;- c("2021-09-12", "1998-03-09")
date_checker(date_list_2)
#&gt; TRUE
</code></pre>

<hr>
<h2 id='extract_coords'>Coordinates extraction</h2><span id='topic+extract_coords'></span>

<h3>Description</h3>

<p>Extracts the bounding (edges) coordinates
of a polygon object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_coords(poly)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_coords_+3A_poly">poly</code></td>
<td>
<p>(An sf or S4 object)
A polygon shapefile.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a spatial polygon object,
the function extracts its bounding coordinates.
</p>


<h3>Value</h3>

<p>Returns 2-column xy coordinates
representing points of directional
change along the boundary.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#load boundary of Camden
load(file = system.file("extdata", "camden.rda",
package="stppSim"))
boundary = camden$boundary # get boundary
extract_coords(poly=boundary)
</code></pre>

<hr>
<h2 id='gtp'>Global temporal pattern (GTP)</h2><span id='topic+gtp'></span>

<h3>Description</h3>

<p>Models the global temporal pattern,
as combining the long-term trend and seasonality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gtp(start_date, trend = "stable",
slope = NULL, shortTerm = "cyclical",
fPeak = 90, show.plot =FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gtp_+3A_start_date">start_date</code></td>
<td>
<p>the start date of the temporal pattern.
The date should be in the format <code>"yyyy-mm-dd"</code>.
The GTP will normally cover a 1-year period.</p>
</td></tr>
<tr><td><code id="gtp_+3A_trend">trend</code></td>
<td>
<p>specifies the direction of the
long-term trend. Options are:
<code>"falling"</code>, <code>"stable"</code>,
and <code>"rising"</code>. Default value is: <code>"stable"</code>.</p>
</td></tr>
<tr><td><code id="gtp_+3A_slope">slope</code></td>
<td>
<p>slope of the long-term trend when
an <code>"rising"</code> or <code>"falling"</code> trend is specified.
Options: <code>"gentle"</code> or <code>"steep"</code>. The default value is
set as <code>NULL</code> for the <code>stable</code> trend.</p>
</td></tr>
<tr><td><code id="gtp_+3A_shortterm">shortTerm</code></td>
<td>
<p>type of short- to medium-term
fluctuations (patterns) of the time series.
Options are: <code>`"cyclical"` and `"acyclical"`</code>.
Default is: <code>`"cyclical"`</code>.</p>
</td></tr>
<tr><td><code id="gtp_+3A_fpeak">fPeak</code></td>
<td>
<p>first seasonal
peak of cyclical short term. Default value is <code>90</code>.
Set as <code>NULL</code> for <code>"acyclical"</code> short term pattern.</p>
</td></tr>
<tr><td><code id="gtp_+3A_show.plot">show.plot</code></td>
<td>
<p>(logical) Shows 'gtp'.
Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Models the GTP for anchoring the temporal
trends and patterns of the point patterns to be simulated.
</p>


<h3>Value</h3>

<p>Returns a time series (list) of 365
data points representing
1-year global temporal pattern.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gtp(start_date = "2020-01-01", trend = "stable",
slope = NULL, shortTerm = "cyclical",
fPeak = 90, show.plot = FALSE)
</code></pre>

<hr>
<h2 id='make_grids'>Make square grids</h2><span id='topic+make_grids'></span>

<h3>Description</h3>

<p>Generates a system of square grids
over an area (boundary shapefile).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_grids(poly, size = 250,
show_output = FALSE, interactive = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_grids_+3A_poly">poly</code></td>
<td>
<p>(as <code>spatialPolygons</code>,
<code>spatialPolygonDataFrames</code>, or
<code style="white-space: pre;">&#8288;simple features&#8288;</code>). A polygon object over
which square grids are to be created.</p>
</td></tr>
<tr><td><code id="make_grids_+3A_size">size</code></td>
<td>
<p>Size of square grids to be
created. For example, the input <code>size</code>
for a 250 by 250 square grids is <code>250</code>.</p>
</td></tr>
<tr><td><code id="make_grids_+3A_show_output">show_output</code></td>
<td>
<p>(logical) Display the output.
Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="make_grids_+3A_interactive">interactive</code></td>
<td>
<p>(logical) to show
interactive map of the grids generated.
Default: <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generates a square grid system in a shapefile
format (in the same <code>crs</code> as the input <code>poly</code>).
If <code>interactive</code> argument is <code>TRUE</code>, an interactive
map is shown from which the centroid coordinates
of any grid can be displayed by hovering the mouse
over the grid. If internet connection is
available on the PC, a basemap (OpenStreetmap) is
added to help identify places.
</p>


<h3>Value</h3>

<p>Returns a &quot;SpatialPolygonsDataFrames&quot; object
representing a system of square grids covering
the polygon area.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#load boundary of Camden
load(file = system.file("extdata", "camden.rda",
package="stppSim"))
boundary = camden$boundary
make_grids(poly=boundary, size = 250,
show_output = FALSE, interactive = FALSE)
</code></pre>

<hr>
<h2 id='NRepeat'>Near Repeat calculator using the Knox test</h2><span id='topic+NRepeat'></span>

<h3>Description</h3>

<p>This function uses the Knox test for space-time
clustering to quantify the spatio-temporal
association between events (Credit: Wouter Steenbeek).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NRepeat(x, y, time, sds, tds, s_include.lowest = FALSE,
s_right = FALSE, t_include.lowest = FALSE, t_right = FALSE,
method = "manhattan", nrep = 999, saveSimulations = FALSE,
future.seed = TRUE,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NRepeat_+3A_x">x</code></td>
<td>
<p>a vector of x coordinates</p>
</td></tr>
<tr><td><code id="NRepeat_+3A_y">y</code></td>
<td>
<p>a vector of y coordinates</p>
</td></tr>
<tr><td><code id="NRepeat_+3A_time">time</code></td>
<td>
<p>a vector of time. This can be of type integer,
numeric, or date</p>
</td></tr>
<tr><td><code id="NRepeat_+3A_sds">sds</code></td>
<td>
<p>A vector of break points of the spatial intervals.
For example c(0,50,120,300) to specify spatial intervals from 0-50,
50-120, 120-300 meters. Or c(0,50,100,Inf) to specify spatial
intervals from 0-50, 50-100, and 100-Inf meters. (More accurately,
on the scale of the provided x and y coordinates. For example,
data may be projected in feet and thus the distances refer to
feet instead of meters).</p>
</td></tr>
<tr><td><code id="NRepeat_+3A_tds">tds</code></td>
<td>
<p>A vector of break points of the temporal intervals.
For example c(0,2,4,Inf) to specify temporal intervals from
0-2, 2-4, 4-Inf days.</p>
</td></tr>
<tr><td><code id="NRepeat_+3A_s_include.lowest">s_include.lowest</code></td>
<td>
<p>the descriptions above are ambiguous on
how exactly the spatial break points are handled. For example,
does c(0,100,200) refer to 0-100, 101-200? Or to 0-99 and
100-199? s_include.lowest follows the arguments of cut (see ?cut).
Logical, indicating if a spatial distance equal to the lowest
(or highest, for right = FALSE) 'breaks' value should be included.
Default = FALSE. See vignette(&quot;NearRepeat_breaks&quot;) for details.</p>
</td></tr>
<tr><td><code id="NRepeat_+3A_s_right">s_right</code></td>
<td>
<p>logical, indicating if the spatial intervals should
be closed on the right (and open on the left) or vice versa.
Default = FALSE. See vignette(&quot;NearRepeat_breaks&quot;) for details.</p>
</td></tr>
<tr><td><code id="NRepeat_+3A_t_include.lowest">t_include.lowest</code></td>
<td>
<p>t_include.lowest follows the arguments of
cut (see ?cut). Logical, indicating if a temporal distance equal
to the lowest (or highest, for right = FALSE) 'breaks' value
should be included. Default = FALSE.</p>
</td></tr>
<tr><td><code id="NRepeat_+3A_t_right">t_right</code></td>
<td>
<p>logical, indicating if the temporal intervals should
be closed on the right (and open on the left) or vice versa.
Default = FALSE. See vignette(&quot;NearRepeat_breaks&quot;) for details.</p>
</td></tr>
<tr><td><code id="NRepeat_+3A_method">method</code></td>
<td>
<p>The method to calculate the spatial distances between
crime events. Methods possible as in the 'dist' function (see ?dist).
Default is 'manhattan', which seems to be a fair approximation of
the distance travelled by a road network. Alternatively, the user
can specify 'euclidean' to get the 'as the crow flies' distance.</p>
</td></tr>
<tr><td><code id="NRepeat_+3A_nrep">nrep</code></td>
<td>
<p>The number of replications of the Monte
Carlo simulation (default = 999).</p>
</td></tr>
<tr><td><code id="NRepeat_+3A_savesimulations">saveSimulations</code></td>
<td>
<p>Should all simulated contingency tables be
saved as a 3-dimensional array?
Default = FALSE</p>
</td></tr>
<tr><td><code id="NRepeat_+3A_future.seed">future.seed</code></td>
<td>
<p>A logical or an integer (of length one or seven),
or a list of length(X) with pre-generated random seeds. Default = TRUE.
See R package future.apply for details.</p>
</td></tr>
<tr><td><code id="NRepeat_+3A_...">...</code></td>
<td>
<p>(optional) Additional arguments passed to future_lapply()</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Further details available at:
https://github.com/wsteenbeek/NearRepeat.
</p>


<h3>Value</h3>

<p>An object of type &quot;knox&quot;, i.e. a list with four tables.
For each spatial and temporal distance combination,(1) The counts
of observed crime pairs, (2) The Knox ratios based on the mean of the
simulations, (3) The Knox ratios based on the median of the
simulations, (4) p-values.
</p>


<h3>References</h3>

<p>Steenbeek W. Near Repeat. R package version 0.1.1. 2018.
URL: https://github.com/wsteenbeek/NearRepeat
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Generate example data. Suppose x and y refer to meters distance.
set.seed(10)
(mydata &lt;- data.frame(x = sample(x = 20, size = 20, replace = TRUE) * 20,
                     y = sample(x = 20, size = 20, replace = TRUE) * 20,
                     date = as.Date(sort(sample(20, size = 20, replace = TRUE)),
                     origin = "2018-01-01")
                     ))

# Near Repeat calculation using 0-100 meters and 100-Inf meters, and three
# temporal intervals of 2 days
set.seed(38673)
NRepeat(x = mydata$x, y = mydata$y, time = mydata$date,
           sds = c(0,100,Inf), tds = c(0,2,4))

# Add a 'same repeat' spatial interval of 0.001 meters, and use Euclidean
# distance
set.seed(38673)
NRepeat(x = mydata$x, y = mydata$y, time = mydata$date,
           sds = c(0,0.001,100,Inf), tds = c(0,2,4),
           method = "euclidean")

# Only do 99 replications
set.seed(38673)
NRepeat(x = mydata$x, y = mydata$y, time = mydata$date,
           sds = c(0,0.001,100,Inf), tds = c(0,2,4),
           method = "euclidean", nrep = 99)


# The plot() function can be used to plot a Heat Map of Near Repeat results
# based on p-values
set.seed(4622)
myoutput &lt;- NRepeat(x = mydata$x, y = mydata$y, time = mydata$date,
                       sds = c(0,100,200,300,400), td = c(0,1,2,3,4,5))

# The default range of p-values that will be highlighted (0-.05) can be
# adjusted using the 'pvalue_range' parameter. By default the Knox ratios
# are printed in the cells, but this can be adjusted using the 'text'
# parameter. The default is "knox_ratio". Possible values are "observed",
# "knox_ratio", "knox_ratio_median", "pvalues", or NA.

## End(Not run)
</code></pre>

<hr>
<h2 id='p_prob'>Proportional (probability) distribution</h2><span id='topic+p_prob'></span>

<h3>Description</h3>

<p>Generates an <code>n</code> probability
values in accordance with a specified
proportional ratios.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_prob(n,  p_ratio = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p_prob_+3A_n">n</code></td>
<td>
<p>a number of data points.</p>
</td></tr>
<tr><td><code id="p_prob_+3A_p_ratio">p_ratio</code></td>
<td>
<p>the smaller of the
terms of specified proportional ratios. For instance, for a
<code>30:70</code> ratio, <code>p_ratio</code> is equal to <code>30</code>.
Default value is set as
<code>20</code>. Valid <code>p_ratio</code> values
are: (<code>5, 10, 20, 30, 40</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Proportional ratios are used to divide the
area under curve (auc) of an exponential function
such that for any given percentage ratios <code>a:b</code>, the
auc is divided into <code>b:a</code>.
</p>


<h3>Value</h3>

<p>Returns a dataframe with
a probability field.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p_prob(n = 15,  p_ratio = 20)
</code></pre>

<hr>
<h2 id='poly'>Boundary coordinates</h2><span id='topic+poly'></span>

<h3>Description</h3>

<p>Boundary coordinates of Camden
Borough of London
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poly
</code></pre>


<h3>Format</h3>

<p>A dataframe containing one variable:
</p>

<ul>
<li><p> x: x coordinate
</p>
</li>
<li><p> y: y coordinate
</p>
</li></ul>


<hr>
<h2 id='poly_tester'>Geometry and Coordinate
Reference System test of a polygon</h2><span id='topic+poly_tester'></span>

<h3>Description</h3>

<p>Tests whether a polygon
has the correct geometry,
namely; <code>S4</code> or <code>sf</code>. Also, tests
that there is a valid projection attached to
the polygon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poly_tester(poly)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="poly_tester_+3A_poly">poly</code></td>
<td>
<p>(as <code>spatialPolygons</code>, <code>spatialPolygonDataFrames</code>, or
<code style="white-space: pre;">&#8288;simple features&#8288;</code>). A spatial polygon object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns an error message if
the polygon is not in the
correct geometry or CRS.
</p>


<h3>Value</h3>

<p>Returns error messages, or mute
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#load boundary of Camden
load(file = system.file("extdata", "camden.rda",
package="stppSim"))
boundary = camden$boundary # get boundary
poly_tester(poly=boundary)
</code></pre>

<hr>
<h2 id='psim_artif'>Stpp from synthetic origins</h2><span id='topic+psim_artif'></span>

<h3>Description</h3>

<p>Generates spatiotemporal
point patterns based on a set of
synthesized origins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psim_artif(n_events=1000, start_date = "2021-01-01",
poly, netw = NULL, n_origin, restriction_feat=NULL, field,
n_foci, foci_separation, mfocal = NULL, conc_type = "dispersed",
p_ratio=20, s_threshold = 50, step_length = 20,
trend = "stable", shortTerm = "cyclical", fPeak=90,
s_band = c(0, 200),
t_band = c(1, 5, 10),
slope = NULL, interactive = FALSE, show.plot=FALSE, show.data=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psim_artif_+3A_n_events">n_events</code></td>
<td>
<p>number of points
(events) to simulate. Default: <code>1000</code>.
A vector of integer values can be supplied, such as,
c(<code>a</code>1, <code>a</code>2, ....)<code style="white-space: pre;">&#8288;, where &#8288;</code>a<code style="white-space: pre;">&#8288;1, &#8288;</code>a'2, ...
represent different integer values.</p>
</td></tr>
<tr><td><code id="psim_artif_+3A_start_date">start_date</code></td>
<td>
<p>the start date of the temporal pattern.
The date should be in the format <code>"yyyy-mm-dd"</code>.
The 'gtp' will normally cover a 1-year period.</p>
</td></tr>
<tr><td><code id="psim_artif_+3A_poly">poly</code></td>
<td>
<p>(An sf or S4 object)
a polygon shapefile defining the extent of the landscape.</p>
</td></tr>
<tr><td><code id="psim_artif_+3A_netw">netw</code></td>
<td>
<p>(An sf or S4 object)
The network path of the landscape
(e.g. road and/or street). Default: <code>NULL</code>.
If provided each event is snapped to the closest
network path/segment.</p>
</td></tr>
<tr><td><code id="psim_artif_+3A_n_origin">n_origin</code></td>
<td>
<p>number of locations to serve as
origins for walkers. Default:<code>50</code>.</p>
</td></tr>
<tr><td><code id="psim_artif_+3A_restriction_feat">restriction_feat</code></td>
<td>
<p>(An S4 object) optional
shapefile containing features
in which walkers cannot walk through.
Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="psim_artif_+3A_field">field</code></td>
<td>
<p>a number in the range of <code>[0-1]</code>
(i.e. restriction values) assigned
to all features; or
the name of a numeric field to extract such
restriction values for different classes of
feature.
Restriction value <code>0</code> and <code>1</code> indicate the
lowest and the highest obstructions, respectively.
Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="psim_artif_+3A_n_foci">n_foci</code></td>
<td>
<p>number of focal points amongst the origin
locations. The origins to serve as focal
points are based on random selection. <code>n_foci</code> must be
smaller than <code>n_origins</code>.</p>
</td></tr>
<tr><td><code id="psim_artif_+3A_foci_separation">foci_separation</code></td>
<td>
<p>a value from <code>1</code> to <code>100</code>
indicating the nearness of focal points to one another.
A <code>0</code> separation indicates that focal points are in
close proximity
of one another, while a <code>100</code> indicates focal points being
evenly distributed across space.</p>
</td></tr>
<tr><td><code id="psim_artif_+3A_mfocal">mfocal</code></td>
<td>
<p>the c(x, y) coordinates of a single point,
representing a pre-defined <code>main</code> focal point (origin)
in the area. The default is <code>NULL</code> in which a random
coordinate is chosen within the <code>polygon</code> area.</p>
</td></tr>
<tr><td><code id="psim_artif_+3A_conc_type">conc_type</code></td>
<td>
<p>concentration of the rest of the
origins (non-focal origins) around the focal ones. The options
are <code>"nucleated"</code> and <code>"dispersed"</code>.</p>
</td></tr>
<tr><td><code id="psim_artif_+3A_p_ratio">p_ratio</code></td>
<td>
<p>the smaller of the
two terms of proportional ratios.
For example, a value of <code>20</code>
implies <code>20:80</code> proportional ratios.</p>
</td></tr>
<tr><td><code id="psim_artif_+3A_s_threshold">s_threshold</code></td>
<td>
<p>defines the spatial
perception range of a walker at a given
location. Default: <code>250</code> (in the same
linear unit
as the <code>poly</code> - polygon shapefile).</p>
</td></tr>
<tr><td><code id="psim_artif_+3A_step_length">step_length</code></td>
<td>
<p>the maximum step taken
by a walker from one point to the next.</p>
</td></tr>
<tr><td><code id="psim_artif_+3A_trend">trend</code></td>
<td>
<p>specifies the direction of the
long-term trend. Options are:
<code>"falling"</code>, <code>"stable"</code>,
and <code>"rising"</code>. Default value is: <code>"stable"</code>.</p>
</td></tr>
<tr><td><code id="psim_artif_+3A_shortterm">shortTerm</code></td>
<td>
<p>type of short- to medium-term
fluctuations (patterns) of the time series.
Options are: <code>`"cyclical"` and `"acyclical"`</code>.
Default is: <code>`"cyclical"`</code>.</p>
</td></tr>
<tr><td><code id="psim_artif_+3A_fpeak">fPeak</code></td>
<td>
<p>first seasonal
peak of cyclical short term. Default value is <code>90</code>.
Only used for <code>"cyclical"</code> short term pattern.</p>
</td></tr>
<tr><td><code id="psim_artif_+3A_s_band">s_band</code></td>
<td>
<p>distance bandwidth within which
the event re-occurences are maximized (i.e.,
interactions are maximum). Specified as a vector of
two distance values. Default: <code>c(0, 200)</code>.</p>
</td></tr>
<tr><td><code id="psim_artif_+3A_t_band">t_band</code></td>
<td>
<p>temporal bandwidth within which
event re-occurences are maximized (i.e., interactions
are maximum). Specified as a vector of values (in days)
<code>c(1, 5, 7, 14)</code>.</p>
</td></tr>
<tr><td><code id="psim_artif_+3A_slope">slope</code></td>
<td>
<p>slope of the long-term trend when
an <code>"rising"</code> or <code>"falling"</code> trend is specified.
Options: <code>"gentle"</code> or <code>"steep"</code>. The default value is
set as <code>NULL</code> for the <code>stable</code> trend.</p>
</td></tr>
<tr><td><code id="psim_artif_+3A_interactive">interactive</code></td>
<td>
<p>Whether to run the process in
interactive mode. Default is <code>FALSE</code>. If <code>TRUE</code>,
a user is able to preview the spatial and temporal models
of the expected distribution of the final simulated
events (points).</p>
</td></tr>
<tr><td><code id="psim_artif_+3A_show.plot">show.plot</code></td>
<td>
<p>(logical) Shows GTP.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="psim_artif_+3A_show.data">show.data</code></td>
<td>
<p>(TRUE or FALSE) To show the output
data. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="psim_artif_+3A_...">...</code></td>
<td>
<p>additional arguments to pass from
<code>gtp</code>, <code>walker</code> and <code>artif_spo</code>
functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simulate artificial spatiotemporal patterns
and interactions based user specifications.
</p>


<h3>Value</h3>

<p>Returns a list of artificial spatiotemporal
point patterns based on user-defined parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

#load boundary and land use of Camden
#load(file = system.file("extdata", "camden.rda",
#package="stppSim"))
#boundary = camden$boundary # get boundary
#landuse = camden$landuse # get landuse
boundary &lt;- stppSim:::boundary
landuse &lt;- stppSim:::landuse
#In this example, we will use a minimal number of
#'n_origin' (i.e. `20`) for faster computation:

#simulate data
simulated_stpp &lt;- psim_artif(n_events=200, start_date = "2021-01-01",
poly=boundary, netw = NULL, n_origin=20, restriction_feat = NULL,
field = NULL,
n_foci=1, foci_separation = 10, mfocal = NULL,
conc_type = "dispersed",
p_ratio = 20, s_threshold = 50,
step_length = 20,
trend = "stable", shortTerm = "cyclical",
fPeak=90, s_band = c(0, 200),
t_band = c(1, 5, 10),
slope = NULL, interactive = FALSE, show.plot=FALSE, show.data=FALSE)

#If `n_events` is a vector of values,
#retrieve the simulated data for the
#corresponding vector element by using
#`simulated_stpp[[enter-element-index-here]]`, e.g.,
#to retrieve the first dataframe, use
#simulated_stpp[[1]].

#The above example simulates point patterns on
#an unrestricted landscape. If set ,
#`restriction_feat = landuse` and
#`field = "restrVal"`, then the simulation
#is performed on a restricted landscape.

## End(Not run)

</code></pre>

<hr>
<h2 id='psim_real'>Stpp from real (sample) origins</h2><span id='topic+psim_real'></span>

<h3>Description</h3>

<p>Generates spatiotemporal point pattern
from origins sampled based on real sample dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psim_real(n_events, ppt, start_date = NULL, poly = NULL,
netw = NULL, s_threshold = NULL, step_length = 20, n_origin=50,
restriction_feat=NULL, field=NA,
p_ratio=20, interactive = FALSE, s_range = 150,
s_interaction = "medium", tolerance = 0.07,
crsys = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psim_real_+3A_n_events">n_events</code></td>
<td>
<p>number of points
(events) to simulate. Default: <code>1000</code>.
A vector of integer values can be supplied, such as,
c(<code>a</code>1, <code>a</code>2, ....)<code style="white-space: pre;">&#8288;, where &#8288;</code>a<code style="white-space: pre;">&#8288;1, &#8288;</code>a'2, ...
represent different integer values.</p>
</td></tr>
<tr><td><code id="psim_real_+3A_ppt">ppt</code></td>
<td>
<p>A 3-column matrix or list containing
<code>x</code> - eastings, <code>y</code> - northing, and <code>t</code> - time of occurrence
(in the format: &lsquo;yyyy-mm-dd&rsquo;)</p>
</td></tr>
<tr><td><code id="psim_real_+3A_start_date">start_date</code></td>
<td>
<p>the start date of the temporal pattern.
The date should be in the format <code>"yyyy-mm-dd"</code>.
The temporal pattern will normally cover
1-year period.</p>
</td></tr>
<tr><td><code id="psim_real_+3A_poly">poly</code></td>
<td>
<p>(An sf or S4 object)
a polygon shapefile defining the extent of the landscape</p>
</td></tr>
<tr><td><code id="psim_real_+3A_netw">netw</code></td>
<td>
<p>(An sf or S4 object)
The network path of the landscape
(e.g. road and/or street). Default: <code>NULL</code>.
If provided each event is snapped to the closest
network path/segment.</p>
</td></tr>
<tr><td><code id="psim_real_+3A_s_threshold">s_threshold</code></td>
<td>
<p>defines the spatial
perception range of a walker at a given
location. Default: <code>250</code> (in the same
linear unit
as the <code>poly</code> - polygon shapefile).</p>
</td></tr>
<tr><td><code id="psim_real_+3A_step_length">step_length</code></td>
<td>
<p>the maximum step taken
by a walker from one point to the next.</p>
</td></tr>
<tr><td><code id="psim_real_+3A_n_origin">n_origin</code></td>
<td>
<p>number of locations to serve as
origins for walkers. Default:<code>50</code>.</p>
</td></tr>
<tr><td><code id="psim_real_+3A_restriction_feat">restriction_feat</code></td>
<td>
<p>(An S4 object) optional
shapefile containing features
in which walkers cannot walk through.
Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="psim_real_+3A_field">field</code></td>
<td>
<p>a number in the range of <code>[0-1]</code>
(i.e. restriction values) assigned
to all features; or
the name of a numeric field to extract such
restriction values for different classes of
feature.
Restriction value <code>0</code> and <code>1</code> indicate the
lowest and the highest obstructions, respectively.
Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="psim_real_+3A_p_ratio">p_ratio</code></td>
<td>
<p>the smaller of the
two terms of proportional ratios.
For example, a value of <code>20</code>
implies <code>20:80</code> proportional ratios.</p>
</td></tr>
<tr><td><code id="psim_real_+3A_interactive">interactive</code></td>
<td>
<p>Whether to run the process in
interactive mode. Default is <code>FALSE</code>. If <code>TRUE</code>,
a user is able to preview the spatial and temporal models
of the expected distribution of the final simulated
events (points).</p>
</td></tr>
<tr><td><code id="psim_real_+3A_s_range">s_range</code></td>
<td>
<p>A value (in metres), not less than 150,
specifying the maximum range of spatial
interaction across the space. For example, for 150m,
the intervals of spatial interactions are created as
<code>(0, 50]</code>, <code>(50 - 100]</code>, and <code>(100-150]</code>,
representing the &quot;small&quot;, &quot;medium&quot;, and &quot;large&quot;,
spatial interaction ranges, respectively. If
<code>s_range</code> is set as <code>NULL</code>, simulation
focusses only on generating point pattern with
similar spatiotemporal patterns as the sample
dataset.</p>
</td></tr>
<tr><td><code id="psim_real_+3A_s_interaction">s_interaction</code></td>
<td>
<p>(string) indicating the
type of spatial interaction to detect.
Default: <code>"medium"</code> (See parameter <code>'s_range'</code>)</p>
</td></tr>
<tr><td><code id="psim_real_+3A_tolerance">tolerance</code></td>
<td>
<p>Pvalue to use for the extraction of
space-time interaction in the sample data. Default
value: <code>0.05</code>.</p>
</td></tr>
<tr><td><code id="psim_real_+3A_crsys">crsys</code></td>
<td>
<p>(string) the EPSG code of the projection
system of the <code>ppt</code> coordinates. This is only used if
<code>poly</code> argument is <code>NULL</code>.
See &quot;http://spatialreference.org/&quot; for the list of
EPSG codes for different regions of the world.
As an example, the EPSG code for the British National Grid
projection system is: <code>"EPSG:27700"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The spatial and temporal patterns and
interactions detected in sample datasets
are extrapolated to synthetise larger
data size. Details of the spatiotemporal
interactions detected in the sample
dataset are provided. If the street network
of the area is provided, each point is
snapped to its nearest street segment.
</p>


<h3>Value</h3>

<p>A list of artificial spatiotemporal
point patterns and interaction generated based on a sample
(real) data.
</p>


<h3>References</h3>

<p>Davies, T.M. and Hazelton, M.L. (2010), Adaptive
kernel estimation of spatial relative risk,
Statistics in Medicine, 29(23) 2423-2437.
Terrell, G.R. (1990), The maximal smoothing principle
in density estimation, Journal of the
American Statistical Association, 85, 470-477.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(camden_crimes)
#subset 'theft' crime
theft &lt;- camden_crimes[which(camden_crimes$type == "Theft"),]
#specify the proportion of full data to use
sample_size &lt;- 0.3
set.seed(1000)
dat_sample &lt;- theft[sample(1:nrow(theft),
round((sample_size * nrow(theft)), digits=0),
replace=FALSE),1:3]
#plot(dat_sample$x, dat_sample$y) #preview

#load boundary and land use of Camden
#load(file = system.file("extdata", "camden.rda",
#package="stppSim"))
#landuse = camden$landuse # get landuse
landuse &lt;- stppSim:::landuse
#simulate data
simulated_stpp &lt;- psim_real(n_events=2000, ppt=dat_sample,
start_date = NULL, poly = NULL, netw = NULL, s_threshold = NULL,
step_length = 20, n_origin=20,
restriction_feat = NULL, field=NULL,
p_ratio=20, interactive = FALSE, s_range = 150,
s_interaction = "medium", tolerance = 0.07,
crsys = "EPSG:27700")
#If `n_events` is a vector of values,
#retrieve the simulated data for the
#corresponding vector element by using
#`simulated_stpp[[enter-element-index-here]]`, e.g.,
#to retrieve the first dataframe, use
#simulated_stpp[[1]].

#The above example simulates point patterns on
#an unrestricted landscape. If \code{restriction_feat = landuse} and \code{field = "restrVal"},
then the simulation
#is run with the landuse features as restrictions
#on the landscape.

## End(Not run)
</code></pre>

<hr>
<h2 id='snap_points_to_lines'>Snapping point to network</h2><span id='topic+snap_points_to_lines'></span>

<h3>Description</h3>

<p>Snaps points to the nearest segment
of a network data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snap_points_to_lines(points, lines,
verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="snap_points_to_lines_+3A_points">points</code></td>
<td>
<p>point data (sf object)</p>
</td></tr>
<tr><td><code id="snap_points_to_lines_+3A_lines">lines</code></td>
<td>
<p>line/street/road network (sf object)</p>
</td></tr>
<tr><td><code id="snap_points_to_lines_+3A_verbose">verbose</code></td>
<td>
<p>Whether to output processing
messages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function snaps points (within 300m)
to the nearest segment on a network. The remaining
points outside 300m buffer are returned in
their original locations (Credit: Michal Kvasnicka)
</p>


<h3>Value</h3>

<p>Point (sf object) with adjusted coordinates
to fit on the network data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#get line and point data
#load(file = system.file("extdata", "camden.rda",
#package="stppSim"))
lines &lt;- stppSim:::lines
pts &lt;- stppSim:::pts
my_points &lt;- snap_points_to_lines(points=pts,
lines=lines,
verbose = FALSE)

#preview result
#ggplot()+
#geom_sf(data = lines, col = 'red')+
#geom_sf(data = pts, shape = 1)
</code></pre>

<hr>
<h2 id='space_restriction'>Space restriction raster map</h2><span id='topic+space_restriction'></span>

<h3>Description</h3>

<p>Builds a space restriction map
from one or more shapefiles. A space restriction
raster map showing the restriction levels
of various features across the landscape.
The function builds
on raster- and SimRIv-packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>space_restriction(shp, baseMap, res, binary = is.na(field),
field = NA, background = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="space_restriction_+3A_shp">shp</code></td>
<td>
<p>shapefile object containing
features to serve as obstructions to the movement
of walkers.</p>
</td></tr>
<tr><td><code id="space_restriction_+3A_basemap">baseMap</code></td>
<td>
<p>if provided, a raster onto which
to stack the restriction features (<code>shp</code>).</p>
</td></tr>
<tr><td><code id="space_restriction_+3A_res">res</code></td>
<td>
<p>the desired pixel resolution of the
raster to be created, when baseMap is not provided.</p>
</td></tr>
<tr><td><code id="space_restriction_+3A_binary">binary</code></td>
<td>
<p>if TRUE, the shapefile will be rasterized
so that all features are assigned a value of <code>0</code> (minimum
restriction level),
and the background is assigned <code>1</code>
(maximum restriction level).</p>
</td></tr>
<tr><td><code id="space_restriction_+3A_field">field</code></td>
<td>
<p>a number in the range of <code>[0-1]</code>
(i.e. restriction values) assigned
to all features; or
the name of a numeric field to extract such
restriction values (<code>[0 &lt;= value &lt; 1]</code>
for different classes of feature.
Restriction value <code>0</code> and <code>1</code> indicate the
lowest and the highest obstructions, respectively.
Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="space_restriction_+3A_background">background</code></td>
<td>
<p>the value in the range 0 and 1
to assign to all pixels that are not covered
by any shapefile object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Helps to create a complete space restriction map
with cell values ranging from 0
(<code style="white-space: pre;">&#8288;minimum restriction level&#8288;</code>) and 1(<code style="white-space: pre;">&#8288;maximum restriction level&#8288;</code>). All
other areas not covered by any features are assigned the value
of <code>background</code>. When stacking additional features to existing
<code>baseMap</code>, only the areas covered by features are updated, while
the remaining areas retain the original values of <code>baseMap</code>.
</p>


<h3>Value</h3>

<p>Returns a raster map showing the restriction
levels across the landscape.
</p>


<h3>References</h3>


<ol>
<li><p> Paul Murrell (2019). rasterize: Rasterize Graphical
Output. R package version 0.1.
https://CRAN.R-project.org/package=rasterize
</p>
</li>
<li><p> Quaglietta L, Porto M (2019). SiMRiv: Individual-Based,
Spatially-Explicit Simulation and Analysis of Multi-State
Movements in River Networks and Heterogeneous Landscapes.
R package version 1.0.4, &lt;URL:
https://CRAN.R-project.org/package=SiMRiv&gt;.
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>#load boundary of Camden and land use data
load(file = system.file("extdata", "camden.rda",
package="stppSim"))
boundary = camden$boundary # get boundary
restrct_map &lt;- space_restriction(shp = boundary,
res = 20, binary = TRUE)
#plot the result
#plot(restrct_space)
#Setting 'restrct_space' raster as basemap, the landuse
#map can now be stacked onto the basemap as follows:
landuse = camden$landuse # get landuse
restrct_Landuse &lt;- space_restriction(shp = landuse,
baseMap = restrct_map,
res = 20, field = "restrVal", background = 1)
#plot(restrct_Landuse)
</code></pre>

<hr>
<h2 id='stm'>Spatial and temporal model</h2><span id='topic+stm'></span>

<h3>Description</h3>

<p>To generate graphics depicting the spatial
and temporal models of the final simulation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stm(pt, poly, df, crsys = NULL,
display_output = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stm_+3A_pt">pt</code></td>
<td>
<p>a data frame with the first three
fields being 'x', 'y', and 'z' information.</p>
</td></tr>
<tr><td><code id="stm_+3A_poly">poly</code></td>
<td>
<p>(An sf or S4 object)
a polygon shapefile defining the extent of a landscape.
Default: <code>NULL</code>, in which the spatial extent
of <code>pt</code> is utilized.</p>
</td></tr>
<tr><td><code id="stm_+3A_df">df</code></td>
<td>
<p>a vector or 1-column data frame containing
values for the time series.</p>
</td></tr>
<tr><td><code id="stm_+3A_crsys">crsys</code></td>
<td>
<p>(string) the EPSG code of the projection
system of the <code>ppt</code> coordinates. This only used if
<code>poly</code> argument is <code>NULL</code>.
See &quot;http://spatialreference.org/&quot; for the list of
EPSG codes for different regions of the world.
As an example, the EPSG code for the British National Grid
projection system is: <code>"EPSG:27700"</code>.</p>
</td></tr>
<tr><td><code id="stm_+3A_display_output">display_output</code></td>
<td>
<p>(logical) display the output.
Default: <code>FALSE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Incorporated into <code>psim_artif</code> and
<code>psim_real</code> functions to allow the preview of
the spatial and the temporal model of the simulation.
The spatial model is the strength distribution of
origin which is the likeness of the spatial patterns
to be simulated. The temporal model is the preview
of the trend and seasonal patterns to be expected
from the simulation.
</p>


<h3>Value</h3>

<p>A graphics showing the spatial and
temporal model of the simulation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#load polygon shapefile
load(file = system.file("extdata", "camden.rda",
package="stppSim"))
camden_boundary = camden$boundary
#read xyz data
data(xyz)
#create a time series
t &lt;- seq(0,5,0.5)
df &lt;- data.frame(data = abs(min(sin(t))) + sin(t))
#run function
stm(pt = xyz, poly=camden_boundary, df=df,
crsys = NULL, display_output = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='stp_learner'>Learning the spatiotemporal properties of
a sample data</h2><span id='topic+stp_learner'></span>

<h3>Description</h3>

<p>Learns both the spatial and the temporal
properties of a real sample dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stp_learner(ppt, start_date = NULL, poly = NULL,
n_origin=50, p_ratio, gridSize = 150, s_range =  150,
tolerance = 0.07,
crsys = NULL, show.plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stp_learner_+3A_ppt">ppt</code></td>
<td>
<p>A 3-column matrix or list containing
<code>x</code> - eastings, <code>y</code> - northing, and <code>t</code> - time of occurrence
(in the format: &lsquo;yyyy-mm-dd&rsquo;).</p>
</td></tr>
<tr><td><code id="stp_learner_+3A_start_date">start_date</code></td>
<td>
<p>the start date of the temporal pattern.
The date should be in the format <code>"yyyy-mm-dd"</code>.
The temporal pattern will normally
cover 1-year period.</p>
</td></tr>
<tr><td><code id="stp_learner_+3A_poly">poly</code></td>
<td>
<p>(An sf or S4 object)
a polygon shapefile defining the extent of the landscape</p>
</td></tr>
<tr><td><code id="stp_learner_+3A_n_origin">n_origin</code></td>
<td>
<p>number of locations to serve as
origins for walkers. Default:<code>50</code>.</p>
</td></tr>
<tr><td><code id="stp_learner_+3A_p_ratio">p_ratio</code></td>
<td>
<p>(an integer) The smaller of the
two terms of a Pareto ratio.
For example, a value of <code>20</code>
implies a <code>20:80</code> Pareto ratio.</p>
</td></tr>
<tr><td><code id="stp_learner_+3A_gridsize">gridSize</code></td>
<td>
<p>the size of square grid
to use for discretizing the space.
Default is: <code>150</code>.</p>
</td></tr>
<tr><td><code id="stp_learner_+3A_s_range">s_range</code></td>
<td>
<p>A value (in metres), not less than 150,
specifying the maximum range of spatial
interaction across the space. For example, for 150m,
the intervals of spatial interactions are created as
<code>(0, 50]</code>, <code>(50 - 100]</code>, and <code>(100-150]</code>,
representing the &quot;small&quot;, &quot;medium&quot;, and &quot;large&quot;,
spatial interaction ranges, respectively. If
<code>s_range</code> is set as <code>NULL</code>, simulation
focusses only on generating point pattern with
similar spatiotemporal patterns as the sample
dataset.</p>
</td></tr>
<tr><td><code id="stp_learner_+3A_tolerance">tolerance</code></td>
<td>
<p>Pvalue to use for the extraction of
space-time interaction in the sample data. Default
value: <code>0.07</code>.</p>
</td></tr>
<tr><td><code id="stp_learner_+3A_crsys">crsys</code></td>
<td>
<p>(string) the EPSG code of the projection
system of the <code>ppt</code> coordinates. This only used if
<code>poly</code> argument is <code>NULL</code>.
See &quot;http://spatialreference.org/&quot; for the list of
EPSG codes for different regions of the world.
As an example, the EPSG code for the British National Grid
projection system is: <code>"EPSG:27700"</code>.</p>
</td></tr>
<tr><td><code id="stp_learner_+3A_show.plot">show.plot</code></td>
<td>
<p>(TRUE or FALSE) Whether to show
some displays.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns an object of the class <code>real_spo</code>,
storing details of the spatiotemporal
properties of the sample data learnt.
</p>


<h3>Value</h3>

<p>an object (list) containing specific spatial
and temporal properties of a sample dataset.
</p>


<h3>References</h3>

<p>Silverman, B.W., 2018. Density estimation
for statistics and data analysis. Routledge.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Goal: To learn the ST properties
#of a sample data, for the purpose of
#simulating the full dataset (see `psim_real`).
data(camden_crimes)
#subset 'theft' crime
theft &lt;- camden_crimes[which(camden_crimes$type ==
"Theft"),1:3]
#specify the proportion of full data to use
sample_size &lt;- 0.3
set.seed(1000)
dat_sample &lt;- theft[sample(1:nrow(theft),
round((sample_size * nrow(theft)), digits=0),
replace=FALSE),]
#plot(dat_sample$x, dat_sample$y) #preview

stp_learner(dat_sample,
start_date = NULL, poly = NULL, n_origin=50,
p_ratio=20, gridSize = 150,
s_range =  150, tolerance = 0.07,
crsys = "EPSG:27700",
show.plot = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='walker'>A landscape walker</h2><span id='topic+walker'></span>

<h3>Description</h3>

<p>A dynamic object capable of moving
and avoiding obstacles on a landscape.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>walker(n = 5, s_threshold = 250, step_length = 20,
poly = NULL, restriction_feat=NULL, field = NA, coords=c(0,0),
pt_itx = TRUE, show.plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="walker_+3A_n">n</code></td>
<td>
<p>number of events
to be generated by a walker within a
temporal bin.</p>
</td></tr>
<tr><td><code id="walker_+3A_s_threshold">s_threshold</code></td>
<td>
<p>defines the spatial
perception range of a walker at a given
location. Default: <code>250</code> (in the same
linear unit
as the <code>poly</code> - polygon shapefile).</p>
</td></tr>
<tr><td><code id="walker_+3A_step_length">step_length</code></td>
<td>
<p>the maximum step taken
by a walker from one point to the next.</p>
</td></tr>
<tr><td><code id="walker_+3A_poly">poly</code></td>
<td>
<p>(An sf or S4 object)
a polygon shapefile defining the
extent of the landscape</p>
</td></tr>
<tr><td><code id="walker_+3A_restriction_feat">restriction_feat</code></td>
<td>
<p>(An S4 object) optional
shapefile containing features
in which walkers cannot walk through.
Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="walker_+3A_field">field</code></td>
<td>
<p>a number in the range of <code>[0-1]</code>
(i.e. restriction values) assigned
to all features; or
the name of a numeric field to extract such
restriction values for different classes of
feature.
Restriction value <code>0</code> and <code>1</code> indicate the
lowest and the highest obstructions, respectively.
Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="walker_+3A_coords">coords</code></td>
<td>
<p>a vector of the form c(x, y) giving the
initial coordinates of a walker (i.e., coordinates
of origins).
Default value is <code>c(0,0)</code> for an
arbitrary square space.</p>
</td></tr>
<tr><td><code id="walker_+3A_pt_itx">pt_itx</code></td>
<td>
<p>To check whether any of the
specified initial origin coordinates
falls outside the boundary.
Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="walker_+3A_show.plot">show.plot</code></td>
<td>
<p>(TRUE or False) To show the time series
plot. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A walker is propelled by an in-built stochastic
transition matrix
and a specified set of spatial and temporal
parameters. The transition
matrix defines two states, namely; the <code>exploratory</code>
and a <code>performative</code> states. A walker is capable
of avoiding obstructions (i.e., <code>restriction_feat</code>)
if included. The resulting number of events may be
slightly different from the value <code>n</code> because of the
stochastic process involved.
</p>


<h3>Value</h3>

<p>Returns a trace of walker's path, and the
resulting events.
</p>


<h3>References</h3>

<p>Quaglietta L, Porto M (2019). SiMRiv: Individual-Based,
Spatially-Explicit Simulation and Analysis of Multi-State
Movements in River Networks and Heterogeneous Landscapes_.
R package version 1.0.4, &lt;URL:
https://CRAN.R-project.org/package=SiMRiv&gt;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#load boundary of Camden
load(file = system.file("extdata", "camden.rda",
package="stppSim"))
boundary = camden$boundary # get boundary
walkerpath &lt;- walker(n = 5, s_threshold = 250, step_length = 20,
poly = boundary, restriction_feat=NULL, field = NULL,
coords = c(0,0), pt_itx = TRUE, show.plot = FALSE)
#plot(walkerpath)
</code></pre>

<hr>
<h2 id='xyt_data'>Spatiotemporal point data</h2><span id='topic+xyt_data'></span>

<h3>Description</h3>

<p>Example spatiotemporal point data
of a part of San Francisco City,
California, US
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xyt_data
</code></pre>


<h3>Format</h3>

<p>A matrix containing three variables
</p>

<ul>
<li><p> x: x coordinate
</p>
</li>
<li><p> y: y coordinate
</p>
</li>
<li><p> t: t time
</p>
</li></ul>


<hr>
<h2 id='xyz'>xyz data</h2><span id='topic+xyz'></span>

<h3>Description</h3>

<p>Example data with 'x', 'y',
and a 'z' information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xyz
</code></pre>


<h3>Format</h3>

<p>A matrix containing three variables
</p>

<ul>
<li><p> x: x coordinate
</p>
</li>
<li><p> y: y coordinate
</p>
</li>
<li><p> z: z height/probability/etc
</p>
</li></ul>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
