<!DOCTYPE html><html lang="en"><head><title>Help for package respR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {respR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+25+26gt+3B+25'><p>Pipe graphics direct from tidyverse-related package</p></a></li>
<li><a href='#adjust_rate'><p>Adjust rates to account for background respiration or oxygen flux.</p></a></li>
<li><a href='#adjust_rate.ft'><p>Adjust rates in flowthrough respirometry to account for background</p>
respiration or oxygen flux.</a></li>
<li><a href='#adjust_scale'><p>Convert between multipliers of the same unit, e.g. mg to kg</p></a></li>
<li><a href='#adjust_scale_area'><p>Convert between multipliers of the same AREA unit, e.g. mm2 to km2</p></a></li>
<li><a href='#algae.rd'><p>Oxygen production respirometry data</p></a></li>
<li><a href='#auto_rate'><p>Automatically determine most linear, highest, lowest and rolling oxygen</p>
uptake or production rates</a></li>
<li><a href='#auto_rate_highest'><p>Perform rolling regression and rank from ABSOLUTE highest to lowest</p></a></li>
<li><a href='#auto_rate_interval'><p>Obtain rate values at non-overlapping intervals of a dataset</p></a></li>
<li><a href='#auto_rate_linear'><p>Linear detection method</p></a></li>
<li><a href='#auto_rate_lowest'><p>Perform rolling regression and rank from ABSOLUTE lowest to highest</p></a></li>
<li><a href='#auto_rate_max'><p>Perform rolling regression and rank from NUMERICAL maximum to minimum</p>
i.e. includes sign - most positive rates are highest</a></li>
<li><a href='#auto_rate_min'><p>Perform rolling regression and rank from NUMERICAL minimum to maximum</p>
i.e. includes sign - most negative rates are highest</a></li>
<li><a href='#auto_rate_rolling'><p>Perform rolling regression of fixed width and do not reorder results</p></a></li>
<li><a href='#auto_rate.int'><p>Run auto_rate on multiple replicates in intermittent-flow respirometry data</p></a></li>
<li><a href='#auto_rate.rep'><p>Function for auto_rate with replicate number in summary plus limit to n</p>
results</a></li>
<li><a href='#background_con.rd'><p>Background respirometry data (constant)</p></a></li>
<li><a href='#background_exp.rd'><p>Background respirometry data (exponential)</p></a></li>
<li><a href='#background_lin.rd'><p>Background respirometry data (linear)</p></a></li>
<li><a href='#broken_stick'><p>Perform broken-stick regressions</p></a></li>
<li><a href='#calc_rate'><p>Calculate rate of change in oxygen over time</p></a></li>
<li><a href='#calc_rate.bg'><p>Calculate background oxygen uptake or input rates</p></a></li>
<li><a href='#calc_rate.ft'><p>Calculate rate of change in oxygen from flowthrough respirometry data</p></a></li>
<li><a href='#calc_rate.int'><p>Extract rates from multiple replicates in intermittent-flow respirometry data</p></a></li>
<li><a href='#calc_rate.rep'><p>Function for calc_rate with replicate number in summary</p></a></li>
<li><a href='#calc_win'><p>Automatically calculate rolling window</p></a></li>
<li><a href='#class.val'><p>Validates acceptable classes of inputs</p>
Set single or multiple inputs to TRUE. This is what the fn accepts.
If x is <em>any</em> one of these a single TRUE will be returned</a></li>
<li><a href='#convert_DO'><p>Convert between units of dissolved oxygen</p></a></li>
<li><a href='#convert_MR'><p>Convert between units of absolute, mass-specific, or area-specific metabolic</p>
rates</a></li>
<li><a href='#convert_MR_print'><p>Print results of convert_MR</p></a></li>
<li><a href='#convert_rate'><p>Convert a unitless oxygen rate value to absolute, mass-specific or</p>
area-specific rate</a></li>
<li><a href='#convert_rate.ft'><p>Convert a unitless oxygen rate value from flowthrough respirometry to</p>
absolute, mass-specific or area-specific rates</a></li>
<li><a href='#convert_val'><p>Convert values of temperature, volume, mass, area, and atmospheric pressure</p>
to different units</a></li>
<li><a href='#extract_indices'><p>Extract row, time and DO indices from a subset dataframe</p></a></li>
<li><a href='#flow_unit_parse'><p>Extracts time and volume units from flowrate unit already parsed by units.val</p></a></li>
<li><a href='#flowthrough_mult.rd'><p>Multi-column flowthrough respirometry data</p></a></li>
<li><a href='#flowthrough_sim.rd'><p>Flowthrough respirometry data with increasing background rate</p></a></li>
<li><a href='#flowthrough.rd'><p>Flowthrough respirometry data on the chiton, <em>Mopalia lignosa</em></p></a></li>
<li><a href='#format_time'><p>Parse date-time data to numeric time for use in respR functions</p></a></li>
<li><a href='#generate_mrdf'><p>Generate a DO ~ PO2 data table from a DO timeseries</p></a></li>
<li><a href='#get_dec'><p>Identify decimal character</p>
For European formatted files with commas as decimal separator</a></li>
<li><a href='#import_file'><p>Import respirometry system raw data files (DEPRECATED)</p></a></li>
<li><a href='#inspect'><p>Explore and visualise respirometry data and check for common errors</p></a></li>
<li><a href='#inspect.ft'><p>Explore and visualise flowthrough respirometry data and check for errors</p></a></li>
<li><a href='#intermittent.rd'><p>Respirometry data of the sea urchin, <em>Heliocidaris Erythrogramma</em></p></a></li>
<li><a href='#kernel_method'><p>Kernel density function</p></a></li>
<li><a href='#linear_fit'><p>Perform a linear regression on a data frame</p></a></li>
<li><a href='#mean.adjust_rate'><p>Average adjust_rate object rates</p></a></li>
<li><a href='#mean.adjust_rate.ft'><p>Average adjust_rate.ft rates</p></a></li>
<li><a href='#mean.auto_rate'><p>Average auto_rate object rates</p></a></li>
<li><a href='#mean.auto_rate.int'><p>Average auto_rate.int object rates</p></a></li>
<li><a href='#mean.calc_rate'><p>Average calc_rate object rates</p></a></li>
<li><a href='#mean.calc_rate.bg'><p>Average calc_rate.bg object rates</p></a></li>
<li><a href='#mean.calc_rate.ft'><p>Average calc_rate.ft object rates</p></a></li>
<li><a href='#mean.calc_rate.int'><p>Average calc_rate.int object rates</p></a></li>
<li><a href='#mean.convert_DO'><p>Average convert_DO object values</p></a></li>
<li><a href='#mean.convert_rate'><p>Average convert_rate object rates</p></a></li>
<li><a href='#mean.convert_rate.ft'><p>Average convert_rate.ft object rates</p></a></li>
<li><a href='#mean.inspect'><p>Average inspect object rates</p></a></li>
<li><a href='#mean.inspect.ft'><p>Average inspect.ft object rates</p></a></li>
<li><a href='#mean.oxy_crit'><p>Average oxy_crit object rates</p></a></li>
<li><a href='#method.val'><p>Validate adjust_rate or auto_rate or oxy_crit method input</p></a></li>
<li><a href='#midpt'><p>Get midpoint between two values or within a vector</p>
For getting midpoint timestamps from Time data</a></li>
<li><a href='#nainf.omit'><p>Omit NA, NaN, Inf and -Inf from a vector or dataframe columns</p></a></li>
<li><a href='#overlap.ft.p'><p>Plot convert_rate.ft summary tables</p></a></li>
<li><a href='#overlap.p'><p>Plot convert_rate and auto_rate summary tables</p></a></li>
<li><a href='#oxy_crit'><p>Calculate critical oxygen values, such as PCrit</p></a></li>
<li><a href='#plot.adjust_rate'><p>Plot adjust_rate objects</p></a></li>
<li><a href='#plot.adjust_rate.ft'><p>Plot adjust_rate.ft objects</p></a></li>
<li><a href='#plot.auto_rate'><p>Plot auto_rate objects</p></a></li>
<li><a href='#plot.auto_rate.int'><p>Plot auto_rate.int objects</p></a></li>
<li><a href='#plot.calc_rate'><p>Plot calc_rate objects</p></a></li>
<li><a href='#plot.calc_rate.bg'><p>Plot calc_rate.bg objects</p></a></li>
<li><a href='#plot.calc_rate.ft'><p>Plot calc_rate.ft objects</p></a></li>
<li><a href='#plot.calc_rate.int'><p>Plot calc_rate.int objects</p></a></li>
<li><a href='#plot.convert_DO'><p>Plot convert_DO objects</p></a></li>
<li><a href='#plot.convert_rate'><p>Plot convert_rate objects</p></a></li>
<li><a href='#plot.convert_rate.ft'><p>Plot convert_rate.ft objects</p></a></li>
<li><a href='#plot.inspect'><p>Plot inspect objects</p></a></li>
<li><a href='#plot.inspect.ft'><p>Plot inspect.ft objects</p></a></li>
<li><a href='#plot.oxy_crit'><p>Plot oxy_crit objects</p></a></li>
<li><a href='#plot.test_lin'><p>Plot output of test_lin</p></a></li>
<li><a href='#print_dens'><p>Prints the density object for summary.auto_rate S3</p>
Basically copied from stats:::print.density and edited to make
it more compact</a></li>
<li><a href='#print.adjust_rate'><p>Print adjust_rate objects</p></a></li>
<li><a href='#print.adjust_rate.ft'><p>Print adjust_rate.ft objects</p></a></li>
<li><a href='#print.auto_rate'><p>Print auto_rate objects</p></a></li>
<li><a href='#print.auto_rate.int'><p>Print auto_rate.int objects</p></a></li>
<li><a href='#print.calc_rate'><p>Print calc_rate objects</p></a></li>
<li><a href='#print.calc_rate.bg'><p>Print calc_rate.bg objects</p></a></li>
<li><a href='#print.calc_rate.ft'><p>Print calc_rate.ft objects</p></a></li>
<li><a href='#print.calc_rate.int'><p>Print calc_rate.int objects</p></a></li>
<li><a href='#print.convert_DO'><p>Print convert_DO objects</p></a></li>
<li><a href='#print.convert_rate'><p>Print convert_rate objects</p></a></li>
<li><a href='#print.convert_rate.ft'><p>Print convert_rate.ft objects</p></a></li>
<li><a href='#print.inspect'><p>Print inspect objects</p></a></li>
<li><a href='#print.inspect.ft'><p>Print inspect.ft objects</p></a></li>
<li><a href='#print.oxy_crit'><p>Print oxy_crit objects</p></a></li>
<li><a href='#rolling_reg_row'><p>Perform regular rolling regression</p></a></li>
<li><a href='#rolling_reg_time'><p>Perform rolling regression based on time units.</p></a></li>
<li><a href='#sardine.rd'><p>Respirometry data of the sardine, <em>Sardinops sagax</em></p></a></li>
<li><a href='#select'><p>Select columns</p></a></li>
<li><a href='#select_rate'><p>Select rate results based on a range of criteria</p></a></li>
<li><a href='#sim_data'><p>Randomly generate data for internal testing of <code>auto_rate()</code>'s linear method.</p></a></li>
<li><a href='#squid.rd'><p>Respirometry data of the squid, <em>Doryteuthis opalescens</em></p></a></li>
<li><a href='#static_roll'><p>Normal rolling regression</p></a></li>
<li><a href='#StP.check'><p>Checks if an oxygen concentration/pressure unit or metabolic rate unit</p>
requires temperature, salinity, and pressure to convert to another unit.</a></li>
<li><a href='#StP.val'><p>Returns an error message if an oxygen concentration/pressure unit or</p>
metabolic rate unit requires S or t and either is NULL, or a message if it
requires P and it is NULL.</a></li>
<li><a href='#subsample'><p>Subsample a data frame object</p></a></li>
<li><a href='#subset_data'><p>Subset a <code>data.frame</code>, <code>inspect</code>, or <code>inspect.ft</code> object</p></a></li>
<li><a href='#summary.adjust_rate'><p>Summarise adjust_rate objects</p></a></li>
<li><a href='#summary.adjust_rate.ft'><p>Summarise adjust_rate.ft objects</p></a></li>
<li><a href='#summary.auto_rate'><p>Summarise auto_rate objects</p></a></li>
<li><a href='#summary.auto_rate.int'><p>Summarise auto_rate.int objects</p></a></li>
<li><a href='#summary.calc_rate'><p>Summarise calc_rate objects</p></a></li>
<li><a href='#summary.calc_rate.bg'><p>Summarise calc_rate.bg objects</p></a></li>
<li><a href='#summary.calc_rate.ft'><p>Summarise calc_rate.ft objects</p></a></li>
<li><a href='#summary.calc_rate.int'><p>Summarise calc_rate.int objects</p></a></li>
<li><a href='#summary.convert_DO'><p>Summarise convert_DO objects</p></a></li>
<li><a href='#summary.convert_rate'><p>Summarise convert_rate objects</p></a></li>
<li><a href='#summary.convert_rate.ft'><p>Summarise convert_rate.ft objects</p></a></li>
<li><a href='#summary.inspect'><p>Summarise inspect objects</p></a></li>
<li><a href='#summary.inspect.ft'><p>Summarise inspect.ft objects</p></a></li>
<li><a href='#summary.oxy_crit'><p>Summarise oxy_crit objects</p></a></li>
<li><a href='#test_lin'><p>Perform <code>auto_rate()</code> iteratively and extract performance metrics</p></a></li>
<li><a href='#time_lm'><p>Subset data by time and perform a linear regression.</p></a></li>
<li><a href='#time_roll'><p>Perform time-width rolling regression</p></a></li>
<li><a href='#unit_args'><p>Print examples of unit inputs</p></a></li>
<li><a href='#unit_type'><p>Search for and classify units</p></a></li>
<li><a href='#unit_type_o1'><p>Search for and classify oxygen units as used in concentration or rates</p></a></li>
<li><a href='#units.clean'><p>Cleans units from units.val to remove the suffix (.o2, .flow, etc)</p></a></li>
<li><a href='#units.val'><p>Check unit string against allowed values. See util_fns.R file for regex</p>
patterns</a></li>
<li><a href='#urchins.rd'><p>Multi-column respirometry data of the sea urchin, <em>Heliocidaris</p>
Erythrogramma</em>, including background respiration</a></li>
<li><a href='#validate_auto_rate'><p>Validation function for auto_rate</p></a></li>
<li><a href='#zeb_intermittent.rd'><p>Respirometry data of a zebrafish, <em>Danio rerio</em></p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Import, Process, Analyse, and Calculate Rates from Respirometry
Data</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-05-01</td>
</tr>
<tr>
<td>Version:</td>
<td>2.3.3</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nicholas Carey &lt;nicholascarey@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a structural, reproducible workflow for the
    processing and analysis of respirometry data. It contains analytical
    functions and utilities for working with oxygen time-series to determine
    respiration or oxygen production rates, and to make it easier to report and
    share analyses. See Harianto et al. 2019 &lt;<a href="https://doi.org/10.1111%2F2041-210X.13162">doi:10.1111/2041-210X.13162</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/januarharianto/respr">https://github.com/januarharianto/respr</a>,
<a href="https://januarharianto.github.io/respR/">https://januarharianto.github.io/respR/</a>,
<a href="https://doi.org/10.1111/2041-210X.13162">https://doi.org/10.1111/2041-210X.13162</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table, dplyr, glue, graphics, grDevices, lubridate,
magrittr, marelac, purrr, roll, segmented, stats, stringr,
utils, xml2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, rMR, FishResp, respirometry, testthat, covr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-03 11:58:19 UTC; nicholascarey</td>
</tr>
<tr>
<td>Author:</td>
<td>Nicholas Carey [aut, cre],
  Januar Harianto [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-10 09:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe graphics direct from tidyverse-related package</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>Pipe graphics direct from tidyverse-related package
</p>


<h3>Value</h3>

<p>No value returned
</p>

<hr>
<h2 id='adjust_rate'>Adjust rates to account for background respiration or oxygen flux.</h2><span id='topic+adjust_rate'></span>

<h3>Description</h3>

<p>The <code>adjust_rate</code> function adjusts oxygen uptake or production rates (for
example, as determined in <code><a href="#topic+calc_rate">calc_rate()</a></code> or <code><a href="#topic+auto_rate">auto_rate()</a></code>) for background
oxygen use by microbial organisms, or for other removal or input of oxygen
during a respirometry experiment. The function accepts numeric values, as
well as regular <code>respR</code> objects, and data frames. See <code><a href="#topic+calc_rate.bg">calc_rate.bg()</a></code> for
determining background rates, which is the recommended way of passing
background rates to <code>adjust_rate</code>. Rates determined in <code>calc_rate</code> are also
accepted as background rates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjust_rate(
  x,
  by,
  method = NULL,
  by2 = NULL,
  time_x = NULL,
  time_by = NULL,
  time_by2 = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adjust_rate_+3A_x">x</code></td>
<td>
<p>numeric. A single numeric value, numeric vector, or object of class
<code>calc_rate</code>, <code>calc_rate.int</code>, <code>auto_rate</code>, or <code>auto_rate.int</code>. This
contains the experimental rate value(s) to be adjusted.</p>
</td></tr>
<tr><td><code id="adjust_rate_+3A_by">by</code></td>
<td>
<p>numeric. A single numeric value, numeric vector, or object of class
<code>calc_rate.bg</code> or <code>calc_rate</code>. This is the background rate(s) used to
perform the adjustment to <code>x</code>. Can also be a <code>data.frame</code> or <code>inspect</code>
object for <code>"concurrent"</code>, <code>"linear"</code> or <code>"exponential"</code> adjustments. See
Details.</p>
</td></tr>
<tr><td><code id="adjust_rate_+3A_method">method</code></td>
<td>
<p>string. Method of background adjustment. Defaults to <code>"mean"</code>.
Other inputs are: <code>"value"</code>, <code>"paired"</code>, <code>"concurrent"</code>, <code>"linear"</code>,
<code>"exponential"</code>. See Details.</p>
</td></tr>
<tr><td><code id="adjust_rate_+3A_by2">by2</code></td>
<td>
<p>numeric. Either a single numeric value, a <code>calc_rate.bg</code> or
<code>calc_rate</code> object, a <code>data.frame</code>, or <code>inspect</code> object. This is the source
of the second background adjustment rate, and used only for dynamic
adjustments (<code>"linear"</code> or <code>"exponential"</code>). See Details.</p>
</td></tr>
<tr><td><code id="adjust_rate_+3A_time_x">time_x</code></td>
<td>
<p>numeric. The timestamp(s) for the rate(s) in <code>x</code>, if it was
entered as a numeric (otherwise it is extracted from the <code>x</code> input object).
Generally this is the midpoint of the time range over which each <code>x</code> rate
was calculated. Used only in dynamic adjustments (<code>"linear"</code> or
<code>"exponential"</code>). See Details.</p>
</td></tr>
<tr><td><code id="adjust_rate_+3A_time_by">time_by</code></td>
<td>
<p>numeric. The timestamp of the background correction rate in
<code>by</code>, if it was entered as a numeric (otherwise it is extracted from the
<code>by</code> input object). Generally the midpoint of the time range over which it
was calculated. Used only in dynamic adjustments (<code>"linear"</code> or
<code>"exponential"</code>). See Details.</p>
</td></tr>
<tr><td><code id="adjust_rate_+3A_time_by2">time_by2</code></td>
<td>
<p>numeric. The timestamp of the background correction rate in
<code>by2</code>, if it was entered as a numeric (otherwise it is extracted from the
<code>by2</code> input object). Generally the midpoint of the time range over which it
was calculated. Used only in dynamic adjustments (<code>"linear"</code> or
<code>"exponential"</code>). See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>adjust_rate</code> allows the rate, or multiple rates, in <code>x</code> to be adjusted in a
number of ways, as detailed below. Note that for those methods which accept
them, <code>by</code> and <code>by2</code> inputs of class <code>calc_rate</code>, <code>calc_rate.bg</code>,
<code>data.frame</code> or <code>inspect</code> can contain multiple columns of background oxygen
data, as long as they share the same numeric time data in column 1. In this
case, the mean of all rates calculated for all oxygen columns is used to
perform adjustments (see <code><a href="#topic+inspect">inspect()</a></code> and <code><a href="#topic+calc_rate.bg">calc_rate.bg()</a></code> to coerce data
to this form). The exception to this is the <code>"paired"</code> method, where each
rate in <code>by</code> (i.e. rate in each oxygen column) is paired with the rate at the
same position in <code>x</code> and used to adjust it.
</p>
<p><em><strong>Note:</strong></em> take special care with the <em>sign</em> of the rate used for
adjustments. In <code>respR</code> oxygen uptake rates are negative, as they represent a
negative slope of oxygen against time. Background rates will normally also be
a negative value, while any input of oxygen would be positive. See Examples.
</p>
<p><em><strong>Methods</strong></em>
</p>
<p>There are six methods of adjustment, briefly summarised here, with more
detail below:
</p>
<p><code>"value"</code> - All experimental rates in <code>x</code> are adjusted by a single background
rate value in <code>by</code>.
</p>
<p><code>"mean"</code> - This is the default method. All experimental rates in <code>x</code> are
adjusted by the mean of all background rate values in <code>by</code>.
</p>
<p><code>"paired"</code> - Experimental rates in <code>x</code> are adjusted by the background rate
value at the same position in <code>by</code>. Therefore requires <code>x</code> and <code>by</code> to have
the same number of rates.
</p>
<p><code>"concurrent"</code> - Experimental rates in <code>x</code> are adjusted by a background rate
calculated over the same time window in the data in <code>by</code>. Therefore requires
<code>x</code> and <code>by</code> to share the same time data and length (broadly speaking).
</p>
<p><code>"linear"</code> - The time values for experimental rates in <code>x</code> are used to
calculate an adjustment value based on a background rate that changes
<em>linearly</em> with respect to time over the course of an experiment. Requires
two background recordings or values (<code>by</code>, <code>by2</code>), and that all data share
the same time data or scale.
</p>
<p><code>"exponential"</code> - The time values for experimental rates in <code>x</code> are used to
calculate an adjustment value based on a background rate that changes
<em>exponentially</em> with respect to time over the course of an experiment.
Requires two background recordings or values (<code>by</code>, <code>by2</code>), and that all data
share the same time data or scale.
</p>
<p><em><strong>More Detail</strong></em>
</p>
<p><code>"value"</code> - For experiments in which the rate from a single background
experiment (or any single background value) is being used to adjust one or
more specimen rates. Each rate in <code>x</code> is adjusted by the subtracting the
single value in <code>by</code>. <code>x</code> can be a numeric value, numeric vector,
<code>calc_rate</code>, <code>calc_rate.int</code>, <code>auto_rate</code>, or <code>auto_rate.int</code> object. <code>by</code>
can be a single numeric value, a <code>calc_rate.bg</code> object containing a single
<code style="white-space: pre;">&#8288;$rate.bg&#8288;</code> (i.e. calculated from a 2-column data frame of time~oxygen), or a
<code>calc_rate</code> object containing a single <code style="white-space: pre;">&#8288;$rate&#8288;</code>. All other inputs should be
<code>NULL</code>.
</p>
<p><code>"mean"</code> - For experiments in which the mean rate from multiple background
experiments is being used to adjust one or more specimen rates. Each rate in
<code>x</code> is adjusted by subtracting the <em>mean</em> of all background rates in <code>by</code>.
<code>x</code> can be a numeric value, numeric vector, <code>calc_rate</code>, <code>calc_rate.int</code>,
<code>auto_rate</code>, or <code>auto_rate.int</code> object. <code>by</code> can be a numeric value, numeric
vector, <code>calc_rate.bg</code> object containing multiple <code style="white-space: pre;">&#8288;$rate.bg&#8288;</code>, or a
<code>calc_rate</code> object containing multiple <code style="white-space: pre;">&#8288;$rate&#8288;</code>. All other inputs should be
<code>NULL</code>. If <code>by</code> is a single value, this will obviously have the same output
as the <code>"value"</code> method.
</p>
<p><code>"paired"</code> - For experiments where multiple specimen experiments are being
adjusted by multiple different background rates. This is a vectorised
adjustment operation: rates in <code>x</code> are adjusted by the background rates at
the same position in <code>by</code>. That is, the first <code>x</code> adjusted by the first <code>by</code>,
second <code>x</code> by second <code>by</code>, etc. <code>x</code> can be a numeric value, numeric vector,
<code>calc_rate</code>, <code>calc_rate.int</code>, <code>auto_rate</code>, or <code>auto_rate.int</code> object. <code>by</code>
can be a numeric vector <em>of the same length</em>, a <code>calc_rate.bg</code> or <code>calc_rate</code>
object where the <code style="white-space: pre;">&#8288;$rate.bg&#8288;</code> or <code style="white-space: pre;">&#8288;$rate&#8288;</code> element is the <em>same length</em> as the
rates in <code>x</code> to be adjusted. All other inputs should be <code>NULL</code>.
</p>
<p><code>"concurrent"</code> - For experiments in which one or more concurrent &quot;blanks&quot; or
background experiments are run alongside specimen experiments. Rates in <code>x</code>
are adjusted by a background rate calculated over the same time window in the
data in <code>by</code>. That is, the start and end time of each <code>x</code> rate is used to fit
a linear regression and calculate a background rate in the <code style="white-space: pre;">&#8288;$dataframe&#8288;</code> in
<code>by</code>. <code>x</code> must be an <code>calc_rate</code>, <code>calc_rate.int</code>, <code>auto_rate</code>, or
<code>auto_rate.int</code> object. <code>by</code> must be a <code>data.frame</code>, <code>inspect</code>,
<code>calc_rate.bg</code>, or <code>calc_rate</code> object containing time~oxygen data. If there
are multiple columns of background oxygen the mean rate across the same time
window in all columns is used. In <code>calc_rate.bg</code> and <code>calc_rate</code> objects the
<code style="white-space: pre;">&#8288;$rate.bg&#8288;</code> or <code style="white-space: pre;">&#8288;$rate&#8288;</code> element is not used, only the <code style="white-space: pre;">&#8288;$dataframe&#8288;</code>. The <code>x</code> and
<code>by</code> data must share (broadly) the <em>same time data or scale in the same
units</em>. If the <code>x</code> and <code>by</code> data differ in length by more than 5% or some
time values are not shared between the two datasets, a warning is given, but
the adjustment is nevertheless performed using the available data, by using
the closest matching time window in the background data.
</p>
<p><code>"linear"</code> - This is a dynamic adjustment, intended for experiments in which
the background oxygen rate <em>changes</em> over the course of the experiment
<em>linearly</em> with respect to time. This is typical of long duration
respirometry experiments in high temperatures, where a &quot;blank&quot; is conducted
at the start of the experiment before the specimen is put in, and again at
the end after it is taken out. It requires therefore two background
recordings sharing the same numeric <em>time data</em> or <em>time scale</em>, in the same
units as the experiment to be adjusted. These can also be entered as two rate
<em>values</em> with associated <em>timestamps</em>, which again must share the same time
scale and units as the rate to be adjusted. This method can also be used in
experiments in which a concurrent blank experiment is conducted alongside
specimen experiments (as described in the <code>concurrent</code> method above), but in
which the background data is deemed too noisy to fit reliable regressions
over the short timescales specimen rates are determined. In this case, <em>any</em>
two reliable segments of the background data of any duration can be used to
determine how the background rate changes over the course of the experiment,
and then this used to adjust specimen rates using the appropriate rate
timestamps. The <em>time~background rate</em> linear relationship is calculated
using the midpoint of the time range of the <code>by</code> and <code>by2</code> rate regressions
(or values plus timestamps). The adjustments to <code>x</code> rates are calculated by
taking the midpoint of the time range over which it was determined and
applying it to the <code>by~by2</code> linear relationship. The <code>x</code> input can be a
numeric value, numeric vector, or a <code>calc_rate</code>, <code>calc_rate.int</code>,
<code>auto_rate</code>, or <code>auto_rate.int</code> object containing single or multiple rates.
The <code>by</code> input is the first background recording or rate value, and <code>by2</code> the
second background recording or rate value.
</p>
<p>While it is typical, the <code>x</code> rates do not necessarily need to be at
intermediate timepoints to the <code>by/by2</code> times. these are used only to
establish a <em>time~background rate</em> linear relationship, which can be
extrapolated before or after the time values used to calculate it. The <code>by</code>
and <code>by2</code> inputs can be a <code>data.frame</code>, <code>inspect</code> or <code>calc_rate.bg</code> object
containing background time~oxygen data. Alternatively, the rate <code>x</code>, and
background rates <code>by</code> and <code>by2</code> can be entered as values, in which case the
associated timepoints at which these were determined (generally the midpoint
of the time range over which the linear regression was fit) must be entered
as <code>time_x</code>, <code>time_by</code>, and <code>time_by2</code> (these timepoints are otherwise
automatically extracted from the input objects). Multiple <code>x</code> rates with
multiple <code>time_x</code> timepoints can be entered and adjusted, but only one linear
background rate relationship applied, that is <code>by</code>, <code>by2</code>, <code>time_by</code>, and
<code>time_by2</code> must be single numeric values in the correct units.
</p>
<p><code>"exponential"</code> - This is a dynamic adjustment, intended for experiments in
which the background oxygen rate <em>changes</em> over the course of the experiment
<em>exponentially</em> with respect to time. This is typical of long duration
respirometry experiments in high temperatures, where a &quot;blank&quot; is conducted
at the start of the experiment before the specimen is put in, and again at
the end after it is taken out, and the background rate is found to increase
exponentially. This is identical to the <code>"linear"</code> method (see above for
requirements), except the adjustment is calculated as an exponential
relationship of the form - <code>lm(log(c(by, by2)) ~ c(time_by, time_by2))</code>.
</p>


<h4>S3 Generic Functions</h4>

<p>Saved output objects can be used in the generic S3 functions <code>print()</code>,
<code>summary()</code>, and <code>mean()</code>.
</p>

<ul>
<li> <p><code>print()</code>: prints a single result, by default the first adjusted rate.
Others can be printed by passing the <code>pos</code> input. e.g. <code>print(x, pos = 2)</code>
</p>
</li>
<li> <p><code>summary()</code>: prints summary table of all results and metadata, or those
specified by the <code>pos</code> input. e.g. <code>summary(x, pos = 1:5)</code>. The summary can
be exported as a separate dataframe by passing <code>export = TRUE</code>.
</p>
</li>
<li> <p><code>mean()</code>: calculates the mean of all adjusted rates, or those specified by
the <code>pos</code> input. e.g. <code>mean(x, pos = 1:5)</code> The mean can be exported as a
separate value by passing <code>export = TRUE</code>.
</p>
</li></ul>




<h4>More</h4>

<p>For additional help, documentation, vignettes, and more visit the <code>respR</code>
website at <a href="https://januarharianto.github.io/respR/">https://januarharianto.github.io/respR/</a>
</p>



<h3>Value</h3>

<p>Output is a list object of class <code>adjust_rate</code> containing all inputs,
input rates, adjustment values, adjustment method and model (if relevant),
and the primary output of interest <code style="white-space: pre;">&#8288;$rate.adjusted&#8288;</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Note that oxygen uptake rates are negative in respR since they represent a
# decrease in dissolved oxygen and negative slope. Typically both
# specimen rate and background rate values are negative.

# Simple background adjustment to a single rate
# This is (-7.44) - (-0.04) = -7.40
adjust_rate(x = -7.44, by = -0.04, method = "value")

# Oxygen input adjustment
# This is (-7.44) - (0.1) = -7.54
adjust_rate(x = -7.44, by = 0.1, method = "value")

# Mean background respiration correction to a single rate.
adjust_rate(x = -7.44, by = c(-0.04, -0.05, -0.06),
            method = "mean")

# Mean background respiration correction to multiple rates.
out &lt;- adjust_rate(x = c(-7.44, -7.20, -7.67),
                   by = c(-0.04, -0.05, -0.06),
                   method = "mean")
summary(out)

# Paired background respiration correction to multiple rates.
out &lt;- adjust_rate(x = c(-7.44, -7.20, -7.67),
                   by = c(-0.04, -0.05, -0.06),
                   method = "paired")
summary(out)

# Dynamic linear adjustment
# With a linear relationship between the 'by' and 'by2' rates,
# at the midpoint time value the adjustment to 'x' should be -0.5
adjust_rate(x = -10,
            time_x = 500,
            by = 0, by2 = -1,
            time_by = 0, time_by2 = 1000,
            method = "linear")

# Same operation to multiple rates
out &lt;- adjust_rate(x = c(-10, -11, -12),
                   time_x = c(500, 600, 700),
                   by = 0, by2 = -1,
                   time_by = 0, time_by2 = 1000,
                   method = "linear")
summary(out)

# A complete workflow using objects instead of values.

# Extract a single replicate from the middle of the zebrafish data
# and calculate rates
zeb_rate &lt;- subset_data(zeb_intermittent.rd,
                        from = 38300,
                        to = 38720,
                        by = "time") %&gt;%
  inspect() %&gt;%
  auto_rate()

# Calculate background rate at start of experiment
bg_start &lt;- subset_data(zeb_intermittent.rd, 1, 4999, "time") %&gt;%
  inspect() %&gt;%
  calc_rate.bg() %&gt;%
  print()

# Calculate background rate at end of experiment
bg_end &lt;- subset_data(zeb_intermittent.rd, 75140, 79251, "time") %&gt;%
  inspect() %&gt;%
  calc_rate.bg() %&gt;%
  print()

# Perform a dynamic linear adjustment
adjust_rate(zeb_rate, by = bg_start, by2 = bg_end,
            method = "linear") %&gt;%
  summary()

# Note the adjustment values applied are somewhere between the
# start and end background rate values

</code></pre>

<hr>
<h2 id='adjust_rate.ft'>Adjust rates in flowthrough respirometry to account for background
respiration or oxygen flux.</h2><span id='topic+adjust_rate.ft'></span>

<h3>Description</h3>

<p>The <code>adjust_rate.ft</code> function adjusts an oxygen uptake or production rate
(for example, as determined in <code><a href="#topic+calc_rate.ft">calc_rate.ft()</a></code>) for background oxygen use
by microbial organisms, or other removal or input of oxygen during
<em>flowthrough</em> respirometry experiments. The function accepts numeric values,
as well as <code>calc_rate.ft</code> objects. Numeric <code>x</code> and <code>by</code> inputs should be
rates calculated as the <strong>oxygen delta * flowrate</strong>. Units will be specified
in <code><a href="#topic+convert_rate.ft">convert_rate.ft()</a></code> when rates are converted to specific output units.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjust_rate.ft(x, by)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adjust_rate.ft_+3A_x">x</code></td>
<td>
<p>numeric. A single numeric value, numeric vector, or object of class
<code>calc_rate.ft</code>. This is the experimental rate value(s) to be adjusted.</p>
</td></tr>
<tr><td><code id="adjust_rate.ft_+3A_by">by</code></td>
<td>
<p>numeric. A numeric value, numeric vector, or object of class
<code>calc_rate.ft</code>. This contains the background rate used to perform the
adjustment to <code>x</code>. If the vector or <code>calc_rate.ft</code> object contains multiple
rates, they will be averaged to produce a single adjustment value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>adjust_rate.ft</code> allows the rate, or multiple rates, in <code>x</code> to be adjusted by
the background rate in <code>by</code>. There are several ways of determining the
background rate, or performing background corrections depending on the setup
of the experiment.
</p>
<p>For experiments in which an empty &quot;blank&quot; experiment has been run, and the
background rate generally does not change over the course of the experiment
(that is, the oxygen delta between inflow and outflow concentrations remains
consistent), it is recommended the rate be determined and saved via the
<code><a href="#topic+inspect.ft">inspect.ft()</a></code> and <code><a href="#topic+calc_rate.ft">calc_rate.ft()</a></code> functions and then entered as the
<code>by</code> input as either a value or the saved <code>calc_rate.ft</code> object. In this
case, the <code style="white-space: pre;">&#8288;$rate&#8288;</code> element of the <code>calc_rate.ft</code> object is used to adjust all
rates in <code>x</code>. If there are multiple background rates in <code style="white-space: pre;">&#8288;$rate&#8288;</code>, the mean
value is used. In this way, a single blank experiment can be applied to
several specimen experiments. Alternatively, the rate from several blank
experiments can be averaged to provide a single adjustment value, and this
entered via <code>by</code> as a numeric value.
</p>
<p>For experiments in which an empty &quot;blank&quot; experiment has been run alongside
actual experiments in parallel, and background rate may increase or decrease
over time (or there may be other variations for example in the inflow oxygen
concentrations), it is recommended you <em>NOT</em> use this function. Instead, the
paired blank oxygen concentration data should be used in <code><a href="#topic+inspect.ft">inspect.ft</a></code> as
the <code>in.oxy</code> input. In this way, the calculated specimen delta oxygen values
take account of whatever background or other variation in oxygen is occurring
in the blank chamber with respect to time. See examples in the vignettes on
the website.
</p>
<p>For adjustments, all rates in <code>x</code>, whether entered as values or as a
<code>calc_rate.ft</code> object, are adjusted by subtracting the mean of all background
rates in <code>by</code>.
</p>
<p><strong>Note:</strong> take special care with the <em>sign</em> of the rate used for adjustments.
In <code>respR</code> oxygen uptake rates are negative, as they represent a negative
slope of oxygen against time. Background rates will normally also be a
negative value (though not always). See Examples.
</p>


<h4>S3 Generic Functions</h4>

<p>Saved output objects can be used in the generic S3 functions <code>print()</code>,
<code>summary()</code>, and <code>mean()</code>.
</p>

<ul>
<li> <p><code>print()</code>: prints a single result, by default the first adjusted rate.
Others can be printed by passing the <code>pos</code> input. e.g. <code>print(x, pos = 2)</code>.
See <code>help("print.adjust_rate.ft")</code>.
</p>
</li>
<li> <p><code>summary()</code>: prints summary table of all results and metadata, or those
specified by the <code>pos</code> input. e.g. <code>summary(x, pos = 1:5)</code>. The summary can
be exported as a separate dataframe by passing <code>export = TRUE</code>. See
<code>help("summary.adjust_rate.ft")</code>.
</p>
</li>
<li> <p><code>mean()</code>: calculates the mean of all adjusted rates, or those specified by
the <code>pos</code> input. e.g. <code>mean(x, pos = 1:5)</code> The mean can be exported as a
separate value by passing <code>export = TRUE</code>. See <code>help("mean.adjust_rate.ft")</code>.
</p>
</li></ul>




<h4>More</h4>

<p>For additional help, documentation, vignettes, and more visit the <code>respR</code>
website at <a href="https://januarharianto.github.io/respR/">https://januarharianto.github.io/respR/</a>
</p>



<h3>Value</h3>

<p><strong>Output</strong>: If the <code>x</code> input is a <code>calc_rate.ft</code> object, the output
will be identical in structure, but of class <code>adjust_rate.ft</code> and
containing the additional elements <code style="white-space: pre;">&#8288;$adjustment&#8288;</code> and <code style="white-space: pre;">&#8288;$rate.adjusted&#8288;</code>, with
these also added to <code style="white-space: pre;">&#8288;$summary&#8288;</code> metadata.
</p>
<p>If <code>x</code> is a numeric value or vector, the output is a <code>list</code> object of class
<code>adjust_rate.ft</code> containing four elements: a <code style="white-space: pre;">&#8288;$summary&#8288;</code> table, <code style="white-space: pre;">&#8288;$rate&#8288;</code>,
<code style="white-space: pre;">&#8288;$adjustment&#8288;</code>, and <code style="white-space: pre;">&#8288;$rate.adjusted&#8288;</code>.
</p>
<p>For all outputs, the <code style="white-space: pre;">&#8288;$rate.adjusted&#8288;</code> element will be the one converted
when the object is passed to <code>convert_rate.ft</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Note that oxygen uptake rates are negative in respR
# since they represent a decrease in dissolved oxygen
# and negative slope. Typically both specimen rate and
# background rate values are negative.

# ----------------------------------------------------
# Simple background respiration correction to a single
# rate.

# Note, 'x' and 'by' should both be rates calculated as
# the delta oxygen value, the difference between inflow
# and outflow oxygen, multiplied by the flowrate.

# This is (-0.98) - (-0.04) = -0.94
adjust_rate.ft(x = -0.98, by = -0.04)

# ----------------------------------------------------
# Mean background adjustment to a single rate.
adjust_rate.ft(x = -0.98, by = c(-0.04, -0.05, -0.06))

# ----------------------------------------------------
# Mean background adjustment to multiple rates.
out &lt;- adjust_rate.ft(x = c(-0.98, -0.87, -0.91),
                      by = c(-0.04, -0.05, -0.06))
summary(out)

# ----------------------------------------------------
# Adjustment using calc_rate.ft objects
# Specimen rate
sp_rate &lt;- flowthrough_mult.rd %&gt;%
  inspect.ft(time = 1, out.oxy = 2, in.oxy = 6) %&gt;%
  calc_rate.ft(from = 30, flowrate = 0.1)

# Background rate
bg_rate &lt;- flowthrough_mult.rd %&gt;%
  inspect.ft(time = 1, out.oxy = 5, in.oxy = 9) %&gt;%
  calc_rate.ft(flowrate = 0.1)

# Perform adjustment
adj_rate &lt;- adjust_rate.ft(sp_rate, by = bg_rate)
print(adj_rate)
summary(adj_rate)
# ----------------------------------------------------
</code></pre>

<hr>
<h2 id='adjust_scale'>Convert between multipliers of the same unit, e.g. mg to kg</h2><span id='topic+adjust_scale'></span>

<h3>Description</h3>

<p>Converts units of the same scale, e.g. mg to kg, or mL to L.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjust_scale(x, input, output)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adjust_scale_+3A_x">x</code></td>
<td>
<p>numeric.</p>
</td></tr>
<tr><td><code id="adjust_scale_+3A_input">input</code></td>
<td>
<p>string.</p>
</td></tr>
<tr><td><code id="adjust_scale_+3A_output">output</code></td>
<td>
<p>string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric.
</p>

<hr>
<h2 id='adjust_scale_area'>Convert between multipliers of the same AREA unit, e.g. mm2 to km2</h2><span id='topic+adjust_scale_area'></span>

<h3>Description</h3>

<p>This is an internal function. Converts units of area. Could be combined with
adjust_scale, but didn't know how....
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjust_scale_area(x, input, output)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adjust_scale_area_+3A_x">x</code></td>
<td>
<p>numeric.</p>
</td></tr>
<tr><td><code id="adjust_scale_area_+3A_input">input</code></td>
<td>
<p>string.</p>
</td></tr>
<tr><td><code id="adjust_scale_area_+3A_output">output</code></td>
<td>
<p>string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric.
</p>

<hr>
<h2 id='algae.rd'>Oxygen production respirometry data</h2><span id='topic+algae.rd'></span>

<h3>Description</h3>

<p>Data from a respirometry experiment on algae which shows oxygen production
over time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>algae.rd
</code></pre>


<h3>Format</h3>

<p>A data frame object consisting of 1200 rows (20 h of data),and
2 columns: <code style="white-space: pre;">&#8288;$Time&#8288;</code> in hours, <code style="white-space: pre;">&#8288;$Oxygen&#8288;</code> in % air saturation.
</p>


<h3>Details</h3>


<ul>
<li><p> Dissolved oxygen units: <code style="white-space: pre;">&#8288;% Air Saturation&#8288;</code>
</p>
</li>
<li><p> Time units: <code>hours</code>
</p>
</li>
<li><p> Respirometer volume (L): <code>0.1</code>
</p>
</li>
<li><p> Temperature (°C): <code>12</code>
</p>
</li>
<li><p> Salinity: <code>30</code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Nicholas Carey
</p>

<hr>
<h2 id='auto_rate'>Automatically determine most linear, highest, lowest and rolling oxygen
uptake or production rates</h2><span id='topic+auto_rate'></span>

<h3>Description</h3>

<p><code>auto_rate</code> performs rolling regressions on a dataset to determine the <em>most
linear, highest, lowest, maximum, minimum, rolling</em>, and <em>interval</em> rates of
change in oxygen against time. A rolling regression of the specified <code>width</code>
is performed on the entire dataset, then based on the &quot;<code>method</code>&quot; input, the
resulting regressions are ranked or ordered, and the output summarised.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auto_rate(x, method = "linear", width = NULL, by = "row", plot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="auto_rate_+3A_x">x</code></td>
<td>
<p>data frame, or object of class <code>inspect</code> containing oxygen~time
data.</p>
</td></tr>
<tr><td><code id="auto_rate_+3A_method">method</code></td>
<td>
<p>string. <code>"linear"</code>, <code>"highest"</code>, <code>"lowest"</code>, <code>"maximum"</code>,
<code>"minimum"</code>, <code>"rolling"</code> or <code>"interval"</code>. Defaults to <code>"linear"</code>. See
Details.</p>
</td></tr>
<tr><td><code id="auto_rate_+3A_width">width</code></td>
<td>
<p>numeric. Width of the rolling regression. For <code>by = "row"</code>,
either a value between 0 and 1 representing a proportion of the data
length, or an integer of 2 or greater representing an exact number of rows.
If <code>by = "time"</code> it represents a time window in the units of the time data.
If <code>NULL</code>, it defaults to 0.2 or a window of 20% of the data length. See
Details.</p>
</td></tr>
<tr><td><code id="auto_rate_+3A_by">by</code></td>
<td>
<p>string. <code>"row"</code> or <code>"time"</code>. Defaults to <code>"row"</code>. Metric by which
to apply the <code>width</code> input if it is above 1.</p>
</td></tr>
<tr><td><code id="auto_rate_+3A_plot">plot</code></td>
<td>
<p>logical. Defaults to TRUE. Plot the results.</p>
</td></tr>
<tr><td><code id="auto_rate_+3A_...">...</code></td>
<td>
<p>Allows additional plotting controls to be passed, such as <code>pos</code>,
<code>panel</code>, and <code>quiet = TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Ranking and ordering algorithms</h4>

<p>Currently, <code>auto_rate</code> contains seven ranking and ordering algorithms that
can be applied using the <code>method</code> input:
</p>

<ul>
<li> <p><code>linear</code>: Uses kernel density estimation (KDE) to learn the shape of the
entire dataset and <em>automatically identify</em> the most linear regions of the
timeseries. This is achieved by using the smoothing bandwidth of the KDE to
re-sample the &quot;peaks&quot; in the KDE to determine linear regions of the data. The
summary output will contain only the regressions identified as coming from
linear regions of the data, ranked by order of the KDE density analysis. This
is present in the <code style="white-space: pre;">&#8288;$summary&#8288;</code> component of the output as <code style="white-space: pre;">&#8288;$density&#8288;</code>. Under
this method, the <code>width</code> input is used as a starting seed value, but the
resulting regressions may be of any width. See
<a href="https://januarharianto.github.io/respR/articles/auto_rate">here</a> for full
details.
</p>
</li>
<li> <p><code>highest</code>: Every regression of the specified <code>width</code> across the entire
timeseries is calculated, then ordered using <em><strong>absolute</strong></em> rate values from
highest to lowest. Essentially, this option ignores the sign of the rate, and
can only be used when rates all have the same sign. Rates will be ordered
from highest to lowest in the <code style="white-space: pre;">&#8288;$summary&#8288;</code> table regardless of if they are
oxygen uptake or oxygen production rates.
</p>
</li>
<li> <p><code>lowest</code>: Every regression of the specified <code>width</code> across the entire
timeseries is calculated, then ordered using <em><strong>absolute</strong></em> rate values from
lowest to highest. Essentially, this option ignores the sign of the rate, and
can only be used when rates all have the same sign. Rates will be ordered
from lowest to highest in the <code style="white-space: pre;">&#8288;$summary&#8288;</code> table regardless of if they are
oxygen uptake or oxygen production rates.
</p>
</li>
<li> <p><code>maximum</code>: Every regression of the specified <code>width</code> across the entire
timeseries is calculated, then ordered using <em><strong>numerical</strong></em> rate values from
maximum to minimum. Takes <em><strong>full account of the sign of the rate</strong></em>.
Therefore, oxygen uptake rates, which in <code>respR</code> are negative, would be
ordered from lowest (least negative), to highest (most negative) in the
summary table in numerical order. Therefore, generally this method should
only be used when rates are a mix of oxygen consumption and production rates,
such as when positive rates may result from regressions fit over flush
periods in intermittent-flow respirometry. Generally, for most analyses where
maximum or minimum rates are of interest the <code>"highest"</code> or <code>"lowest"</code>
methods should be used.
</p>
</li>
<li> <p><code>minimum</code>: Every regression of the specified <code>width</code> across the entire
timeseries is calculated, then ordered using <em><strong>numerical</strong></em> rate values from
minimum to maximum. Takes <em><strong>full account of the sign of the rate</strong></em>.
Therefore, oxygen uptake rates, which in <code>respR</code> are negative, would be
ordered from highest (most negative) to lowest (least negative) in the
summary table in numerical order. Therefore, generally this method should
only be used when rates are a mix of oxygen consumption and production rates,
such as when positive rates may result from regressions fit over flush
periods in intermittent-flow respirometry. Generally, for most analyses where
maximum or minimum rates are of interest the <code>"highest"</code> or <code>"lowest"</code>
methods should be used.
</p>
</li>
<li> <p><code>rolling</code>: A rolling regression of the specified <code>width</code> is performed
across the entire timeseries. No reordering of results is performed.
</p>
</li>
<li> <p><code>interval</code>: multiple, successive, non-overlapping regressions of the
specified <code>width</code> are extracted from the rolling regressions, ordered by
time.
</p>
</li></ul>




<h4>Further selection and filtering of results</h4>

<p>For further selection or subsetting of <code>auto_rate</code> results, see the dedicated
<code><a href="#topic+select_rate">select_rate()</a></code> function, which allows subsetting of rates by various
criteria, including r-squared, data region, percentiles, and more.
</p>



<h4>Units</h4>

<p>There are no units involved in <code>auto_rate</code>. This is a deliberate decision.
The units of oxygen concentration and time will be specified later in
<code><a href="#topic+convert_rate">convert_rate()</a></code> when rates are converted to specific output units.
</p>



<h4>The <code>width</code> and <code>by</code> inputs</h4>

<p>If <code>by = "time"</code>, the <code>width</code> input represents a time window in the units of
the time data in <code>x</code>.
</p>
<p>If <code>by = "row"</code> and <code>width</code> is between 0 and 1 it represents a proportion of
the total data length, as in the equation <code style="white-space: pre;">&#8288;floor(width * number of data rows)&#8288;</code>. For example, 0.2 represents a rolling window of 20% of the data
width. Otherwise, if entered as an integer of 2 or greater, the <code>width</code>
represents the number of rows.
</p>
<p>For both <code>by</code> inputs, if left as <code>width = NULL</code> it defaults to 0.2 or a
window of 20% of the data length.
</p>
<p>In most cases, <code>by</code> should be left as the default <code>"row"</code>, and the <code>width</code>
chosen with this in mind, as it is considerably more computationally
efficient. Changing to <code>"time"</code> causes the function to perform checks for
irregular time intervals at every iteration of the rolling regression, which
adds to computation time. This is to ensure the specified <code>width</code> input is
honoured in the time units and rates correctly calculated, even if the data
is unevenly spaced or has gaps.
</p>



<h4>Plot</h4>

<p>A plot is produced (provided <code>plot = TRUE</code>) showing the original data
timeseries of oxygen against time (bottom blue axis) and row index (top red
axis), with the rate result region highlighted. Second panel is a close-up of
the rate region with linear model coefficients. Third panel is a rolling rate
plot (note the reversed y-axis so that higher oxygen uptake rates are plotted
higher), of a rolling rate of the input <code>width</code> across the whole dataset.
Each rate is plotted against the middle of the time and row range used to
calculate it. The dashed line indicates the value of the current rate result
plotted in panels 1 and 2. The fourth and fifth panels are summary plots of
fit and residuals, and for the <code>linear</code> method the sisth panel the results of
the kernel density analysis, with the dashed line again indicating the value
of the current rate result plotted in panels 1 and 2.
</p>



<h4>Additional plotting options</h4>

<p>If multiple rates have been calculated, by default the first (<code>pos = 1</code>) is
plotted. Others can be plotted by changing the <code>pos</code> input either in the main
function call, or by plotting the output, e.g. <code>plot(object, pos = 2)</code>. In
addition, each sub-panel can be examined individually by using the <code>panel</code>
input, e.g. <code>plot(object, panel = 2)</code>.
</p>
<p>Console output messages can be suppressed using <code>quiet = TRUE</code>. If axis
labels or other text boxes obscure parts of the plot they can be suppressed
using <code>legend = FALSE</code>. The rate in the rolling rate plot can be plotted
<em>not</em> reversed by passing <code>rate.rev = FALSE</code>, for instance when examining
oxygen production rates so that higher production rates appear higher. If
axis labels (particularly y-axis) are difficult to read, <code>las = 2</code> can be
passed to make axis labels horizontal, and <code>oma</code> (outer margins, default <code>oma = c(0.4, 1, 1.5, 0.4)</code>), and <code>mai</code> (inner margins, default <code>mai = c(0.3, 0.15, 0.35, 0.15)</code>) used to adjust plot margins.
</p>



<h4>S3 Generic Functions</h4>

<p>Saved output objects can be used in the generic S3 functions <code>print()</code>,
<code>summary()</code>, and <code>mean()</code>.
</p>

<ul>
<li> <p><code>print()</code>: prints a single result, by default the first rate. Others can be
printed by passing the <code>pos</code> input. e.g. <code>print(x, pos = 2)</code>
</p>
</li>
<li> <p><code>summary()</code>: prints summary table of all results and metadata, or those
specified by the <code>pos</code> input. e.g. <code>summary(x, pos = 1:5)</code>. The summary can
be exported as a separate data frame by passing <code>export = TRUE</code>.
</p>
</li>
<li> <p><code>mean()</code>: calculates the mean of all rates, or those specified by the <code>pos</code>
input. e.g. <code>mean(x, pos = 1:5)</code> The mean can be exported as a separate value
by passing <code>export = TRUE</code>.
</p>
</li></ul>




<h4>More</h4>

<p>For additional help, documentation, vignettes, and more visit the <code>respR</code>
website at <a href="https://januarharianto.github.io/respR/">https://januarharianto.github.io/respR/</a>
</p>



<h3>Value</h3>

<p>Output is a <code>list</code> object of class <code>auto_rate</code> containing input
parameters and data, various summary data, metadata, linear models, and the
primary output of interest <code style="white-space: pre;">&#8288;$rate&#8288;</code>, which can be background adjusted in
<code><a href="#topic+adjust_rate">adjust_rate</a></code> or converted to units in <code><a href="#topic+convert_rate">convert_rate</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Most linear section of an entire dataset
inspect(sardine.rd, time = 1, oxygen =2) %&gt;%
  auto_rate()

# What is the lowest oxygen consumption rate over a 10 minute (600s) period?
inspect(sardine.rd, time = 1, oxygen =2) %&gt;%
  auto_rate(method = "lowest", width = 600, by = "time") %&gt;%
  summary()

# What is the highest oxygen consumption rate over a 10 minute (600s) period?
inspect(sardine.rd, time = 1, oxygen =2) %&gt;%
  auto_rate(method = "highest", width = 600, by = "time") %&gt;%
  summary()

# What is the NUMERICAL minimum oxygen consumption rate over a 5 minute (300s)
# period in intermittent-flow respirometry data?
# NOTE: because uptake rates are negative, this would actually be
# the HIGHEST uptake rate.
auto_rate(intermittent.rd, method = "minimum", width = 300, by = "time") %&gt;%
  summary()

# What is the NUMERICAL maximum oxygen consumption rate over a 20 minute
# (1200 rows) period in respirometry data in which oxygen is declining?
# NOTE: because uptake rates are negative, this would actually be
# the LOWEST uptake rate.
sardine.rd %&gt;%
  inspect() %&gt;%
  auto_rate(method = "maximum", width = 1200, by = "row") %&gt;%
  summary()

# Perform a rolling regression of 10 minutes width across the entire dataset.
# Results are not ordered under this method.
sardine.rd %&gt;%
  inspect() %&gt;%
  auto_rate(method = "rolling", width = 600, by = "time") %&gt;%
  summary()
 
</code></pre>

<hr>
<h2 id='auto_rate_highest'>Perform rolling regression and rank from ABSOLUTE highest to lowest</h2><span id='topic+auto_rate_highest'></span>

<h3>Description</h3>

<p>i.e. ignores sign. should only be used when rates are all negative or all
positive
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auto_rate_highest(dt, width, by = "row")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="auto_rate_highest_+3A_dt">dt</code></td>
<td>
<p>data.frame object.</p>
</td></tr>
<tr><td><code id="auto_rate_highest_+3A_width">width</code></td>
<td>
<p>numeric.</p>
</td></tr>
<tr><td><code id="auto_rate_highest_+3A_by">by</code></td>
<td>
<p>string.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an internal function for <code>auto_rate()</code>
</p>


<h3>Value</h3>

<p>a list object with appended class <code>auto_rate_highest</code>
</p>

<hr>
<h2 id='auto_rate_interval'>Obtain rate values at non-overlapping intervals of a dataset</h2><span id='topic+auto_rate_interval'></span>

<h3>Description</h3>

<p>This is an internal function for <code>auto_rate()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auto_rate_interval(dt, width, by)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="auto_rate_interval_+3A_dt">dt</code></td>
<td>
<p>data.frame object.</p>
</td></tr>
<tr><td><code id="auto_rate_interval_+3A_width">width</code></td>
<td>
<p>numeric.</p>
</td></tr>
<tr><td><code id="auto_rate_interval_+3A_by">by</code></td>
<td>
<p>string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list object with appended class <code>auto_rate_interval</code>
</p>

<hr>
<h2 id='auto_rate_linear'>Linear detection method</h2><span id='topic+auto_rate_linear'></span>

<h3>Description</h3>

<p>This is an internal function for <code>auto_rate()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auto_rate_linear(dt, width, by, verify = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="auto_rate_linear_+3A_dt">dt</code></td>
<td>
<p>data.frame object.</p>
</td></tr>
<tr><td><code id="auto_rate_linear_+3A_width">width</code></td>
<td>
<p>numeric.</p>
</td></tr>
<tr><td><code id="auto_rate_linear_+3A_verify">verify</code></td>
<td>
<p>logical. Should KDE be performed again to verify the detection?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list object
</p>

<hr>
<h2 id='auto_rate_lowest'>Perform rolling regression and rank from ABSOLUTE lowest to highest</h2><span id='topic+auto_rate_lowest'></span>

<h3>Description</h3>

<p>i.e. ignores sign. should only be used when rates are all negative or all
positive
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auto_rate_lowest(dt, width, by = "row")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="auto_rate_lowest_+3A_dt">dt</code></td>
<td>
<p>data.frame object.</p>
</td></tr>
<tr><td><code id="auto_rate_lowest_+3A_width">width</code></td>
<td>
<p>numeric.</p>
</td></tr>
<tr><td><code id="auto_rate_lowest_+3A_by">by</code></td>
<td>
<p>string.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an internal function for <code>auto_rate()</code>
</p>


<h3>Value</h3>

<p>a list object with appended class <code>auto_rate_lowest</code>
</p>

<hr>
<h2 id='auto_rate_max'>Perform rolling regression and rank from NUMERICAL maximum to minimum
i.e. includes sign - most positive rates are highest</h2><span id='topic+auto_rate_max'></span>

<h3>Description</h3>

<p>This is an internal function for <code>auto_rate()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auto_rate_max(dt, width, by = "row")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="auto_rate_max_+3A_dt">dt</code></td>
<td>
<p>data.frame object.</p>
</td></tr>
<tr><td><code id="auto_rate_max_+3A_width">width</code></td>
<td>
<p>numeric.</p>
</td></tr>
<tr><td><code id="auto_rate_max_+3A_by">by</code></td>
<td>
<p>string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list object with appended class <code>auto_rate_max</code>
</p>

<hr>
<h2 id='auto_rate_min'>Perform rolling regression and rank from NUMERICAL minimum to maximum
i.e. includes sign - most negative rates are highest</h2><span id='topic+auto_rate_min'></span>

<h3>Description</h3>

<p>This is an internal function for <code>auto_rate()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auto_rate_min(dt, width, by = "row")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="auto_rate_min_+3A_dt">dt</code></td>
<td>
<p>data.frame object.</p>
</td></tr>
<tr><td><code id="auto_rate_min_+3A_width">width</code></td>
<td>
<p>numeric.</p>
</td></tr>
<tr><td><code id="auto_rate_min_+3A_by">by</code></td>
<td>
<p>string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list object with appended class <code>auto_rate_min</code>
</p>

<hr>
<h2 id='auto_rate_rolling'>Perform rolling regression of fixed width and do not reorder results</h2><span id='topic+auto_rate_rolling'></span>

<h3>Description</h3>

<p>This is an internal function for <code>auto_rate()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auto_rate_rolling(dt, width, by = "row")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="auto_rate_rolling_+3A_dt">dt</code></td>
<td>
<p>data.frame object.</p>
</td></tr>
<tr><td><code id="auto_rate_rolling_+3A_width">width</code></td>
<td>
<p>numeric.</p>
</td></tr>
<tr><td><code id="auto_rate_rolling_+3A_by">by</code></td>
<td>
<p>string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list object with appended class <code>auto_rate_rolling</code>
</p>

<hr>
<h2 id='auto_rate.int'>Run auto_rate on multiple replicates in intermittent-flow respirometry data</h2><span id='topic+auto_rate.int'></span>

<h3>Description</h3>

<p><code>auto_rate.int</code> allows you to run the <code>auto_rate()</code> function on multiple
replicates in intermittent-flow respirometry. A <code>wait</code> and <code>measure</code> phase
can be specified for each replicate, and the <code>auto_rate</code> analysis is
performed within the <code>measure</code> region.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auto_rate.int(
  x,
  starts = NULL,
  wait = NULL,
  measure = NULL,
  by = "row",
  method = "linear",
  width = NULL,
  n = 1,
  plot = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="auto_rate.int_+3A_x">x</code></td>
<td>
<p>object of class <code>inspect</code> or <code>data.frame</code>. This is the timeseries of
paired values of oxygen against time containing multiple replicates from
which to calculate rates.</p>
</td></tr>
<tr><td><code id="auto_rate.int_+3A_starts">starts</code></td>
<td>
<p>Numeric. Row locations or times (in the units of the data in
<code>x</code>) of the start of each replicate. If a single value it indicates a
regular interval in rows or time starting from row 1. If a vector, each
entry is the start row or time of an individual replicate. Use of rows or
time is controlled via <code>by</code>.</p>
</td></tr>
<tr><td><code id="auto_rate.int_+3A_wait">wait</code></td>
<td>
<p>Numeric. A row length or time duration to be applied at the start
of each replicate to <em>exclude</em> these data from any rate calculations. Can
be a single value to apply the same wait phase to each replicate, or a
vector of the same length as <code>starts</code> of different wait phases for each
replicate. Optional.</p>
</td></tr>
<tr><td><code id="auto_rate.int_+3A_measure">measure</code></td>
<td>
<p>Numeric. A row length or time duration to be applied at the
end of the <code>wait</code> phase (if used), and used to exclude the flush period.
This is the region within which the <code>auto_rate</code> analysis is conducted for
each replicate. Can be a single value to apply the same measure phase to
each replicate, or a vector of the same length as <code>starts</code> of different
measure phases for each replicate. Default is <code>NULL</code> in which case the
entire replicate is used (which is rarely what is wanted).</p>
</td></tr>
<tr><td><code id="auto_rate.int_+3A_by">by</code></td>
<td>
<p>String. <code>"row"</code> or <code>"time"</code>. Controls how <code>starts</code>, <code>wait</code> and
<code>measure</code> are applied. It also controls how the <code>width</code> is applied in the
<code>auto_rate</code> analysis - see <code>help("auto_rate")</code>. Default is <code>"row"</code>.</p>
</td></tr>
<tr><td><code id="auto_rate.int_+3A_method">method</code></td>
<td>
<p>string. The <code>auto_rate</code> <code>method</code> to use. Default is <code>"linear"</code>.
Others include <code>"lowest"</code> and <code>"highest"</code>. See <code>help("auto_rate")</code> for
descriptions and other methods.</p>
</td></tr>
<tr><td><code id="auto_rate.int_+3A_width">width</code></td>
<td>
<p>numeric. The <code>width</code> to use in the <code>auto_rate</code> analysis.
Mandatory and should be entered in the correct units of the <code>by</code> input. See
<code>help("auto_rate")</code> and vignettes on website for how width affects
analyses.</p>
</td></tr>
<tr><td><code id="auto_rate.int_+3A_n">n</code></td>
<td>
<p>integer. How many <code>auto_rate</code> results to return for each replicate.
Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="auto_rate.int_+3A_plot">plot</code></td>
<td>
<p>logical. Default is <code>TRUE</code>. Plots the results. See 'Plotting'
section for details.</p>
</td></tr>
<tr><td><code id="auto_rate.int_+3A_...">...</code></td>
<td>
<p>Allows additional plotting controls to be passed, such as <code>type</code>,
<code>pos</code>, <code>legend</code>, and <code>quiet</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>auto_rate.int</code> uses the <code>starts</code> input to subset each replicate. The <code>wait</code>
and <code>measure</code> inputs control which parts of each replicate data are excluded
and included from the rate calculation. It runs <code>auto_rate</code> on the <code>measure</code>
phase in each replicate saving the top <code>n</code> ranked results and extracting the
rate and other data to a summary table.
</p>
<p>The <code>x</code> input should be an<code>inspect</code> object. Alternatively, it can be a
two-column data frame containing paired values of time and oxygen from an
intermittent-flow experiment in columns 1 and 2 respectively (though we
always recommend processing such data in <code>inspect()</code> first). If a multiple
column dataset is entered as <code>x</code> the first two columns are selected by
default. If these are not the intended data use <code>inspect</code> to select the
correct time and oxygen columns.
</p>


<h4><code>auto_rate</code> inputs</h4>

<p>You should be familiar with how <code>auto_rate</code> works before using this function.
See <code>help("auto_rate")</code> and vignettes on the website for full details.
</p>
<p>The <code>auto_rate</code> inputs can be changed by entering different <code>method</code> and
<code>width</code> inputs. The <code>by</code> input controls how the <code>width</code> is applied. Note if
using a proportional <code>width</code> input (i.e. between 0 and 1 representing a
proportion of the data length) this applies to the length of the <code>measure</code>
phase of each particular replicate.
</p>
<p>The <code>n</code> input controls how many <code>auto_rate</code> results from each replicate to
return in the output. By default this is only the top ranked result for the
particular <code>method</code>, i.e. <code>n = 1</code>. This can be changed to return more,
however consider carefully if this is necessary as the output will
necessarily contain many more rate results which may make it difficult to
explore and select results (although see <code>select_rate()</code>).
</p>



<h4>Specifying replicate structure</h4>

<p>The <code>starts</code> input specifies the locations of the start of each replicate in
the data in <code>x</code>. This can be in one of two ways:
</p>

<ul>
<li><p> A single numeric value specifying the number of rows in each replicate
starting from the data in the first row. This option should only be used when
replicates cycle at regular intervals. This can be a regular row or time
interval, as specified via the <code>by</code> input. If the first replicate does not
start at row 1, the data should be subset so that it does (see
<code>subset_data()</code>) and example
<a href="https://januarharianto.github.io/respR/articles/intermittent_long.html">here</a>.
For example, <code style="white-space: pre;">&#8288;starts = 600, by = "row"&#8288;</code> means the first replicate starts at
row 1 and ends at row 600, the second starts at row 601 ends at 1200, and so
on.
</p>
</li>
<li><p> A numeric vector of row locations or times, as specified via the <code>by</code>
input, of the start of each individual replicate. The first replicate does
not have to start at the first row of the data, and all data after the last
entry is assumed to be part of the final replicate. Regular <code>R</code> syntax such
as <code>seq()</code>, <code>1:10</code>, etc. is also accepted, so can be used to specify both
regular and irregular replicate spacing.
</p>
</li></ul>

<p>For both methods it is assumed each replicate ends at the row preceding the
start of the next replicate, or in the case of the last replicate the final
row of the dataset. Also for both methods, <code>by = "time"</code> inputs do not need
to be exact; the closest matching values in the time data are used.
</p>
<p>Results are presented in the <code>summary</code> table with <code>rep</code> and <code>rank</code> columns to
distinguish those from different replicates and their ranking within
replicates (if multiple results per replicate have been returned by
increasing the <code>n</code> input).
</p>



<h4>Specifying rate region</h4>

<p>The <code>wait</code> and <code>measure</code> inputs are used to specify the region from which to
extract a rate and exclude flush periods. They can be entered as row
intervals or time values in the units of the input data. The <code>wait</code> phase
controls the amount of data at the start of each replicate to be ignored,
that is excluded from any rate calculations. The <code>measure</code> phase determines
the region after this from which a rate is calculated. Unlike
<code>calc_rate.int()</code>, <code>auto_rate.int</code> will not necessarily use all of the data
in the <code>measure</code> phase, but will run the <code>auto_rate</code> analysis <em>within</em> it
using the <code>method</code>, <code>width</code> and <code>by</code> inputs. This may result in rates of
various widths depending on the inputs. See <code>auto_rate()</code> for defaults and
full details of how selection inputs are applied.
</p>
<p>There is no <code>flush</code> phase input since this is assumed to be from the end of
the <code>measure</code> phase to the end of the replicate.
</p>
<p>Both <code>wait</code> and <code>measure</code> can be entered in one of two ways:
</p>

<ul>
<li><p> Single numeric values specifying a row width or a time period, as specified
via the <code>by</code> input. Use this if you want to use the <em>same</em> <code>wait</code> and
<code>measure</code> phases in every replicate.
</p>
</li>
<li><p> If <code>starts</code> is a vector of locations of the start of each replicate, these
inputs can also be vectors of equal length of row lengths or time periods as
specified via the <code>by</code> input. This is only useful if you want to use
<em>different</em> <code>wait</code> and/or <code>measure</code> phases in different replicates.
</p>
</li></ul>

<p>If <code>wait = NULL</code> no wait phase is applied. If <code>measure = NULL</code> the data used
for analysis is from the start of the replicate or end of the <code>wait</code> phase to
the last row of the replicate. This will typically include the flush period,
so is rarely what you would want.
</p>



<h4>Example</h4>

<p>See examples below for actual code, but here is a simple example. An
experiment comprises replicates which cycle at ten minute intervals with data
recorded every second. Therefore each replicate will be 600 rows long.
Flushes of the respirometer take 3 minutes at the end of each replicate. We
want to exclude the first 2 minutes (120 rows) of data in each, and run an
<code>auto_rate</code> analysis to get an oxygen uptake rate within the following five
minute period (300 rows), leaving the three minutes of flushing (180 rows)
excluded. The inputs for this would be:
</p>
<p><code style="white-space: pre;">&#8288;starts = 600, wait = 120, measure = 300, by = "row"&#8288;</code>
</p>



<h4>Plot</h4>

<p>If <code>plot = TRUE</code> (the default), the result for each rate is plotted on a grid
up to a maximum of 20. There are three ways of plotting the results, which
can be selected using the <code>type</code> input:
</p>

<ul>
<li> <p><code>type = "rep"</code>: The default. Each individual replicate is plotted with the
rate region highlighted in yellow. The <code>wait</code> and <code>measure</code> phases are also
highlighted as shaded red and green regions respectively. These are also
labelled if <code>legend = TRUE</code>.
</p>
</li>
<li> <p><code>type = "full"</code>: Each replicate rate is highlighted in the context of the
whole dataset. May be quite difficult to interpret if dataset is large.
</p>
</li>
<li> <p><code>type = "ar"</code>: Plots individual replicate results as <code>auto_rate</code> objects.
Note, these will only show the <code>measure</code> phase of the data.
</p>
</li></ul>

<p>For all plot types <code>pos</code> can be used to select which rate(s) to plot (default
is 1:20), where <code>pos</code> indicates rows of the <code style="white-space: pre;">&#8288;$summary&#8288;</code> table (and hence which
<code style="white-space: pre;">&#8288;$rep&#8288;</code> and <code style="white-space: pre;">&#8288;$rank&#8288;</code>). This can be passed either in the main function call or
when calling <code>plot()</code> on output objects. Note for all plot types if <code>n</code> has
been changed to return more than one rate per replicate these will also be
plotted.
</p>



<h4>S3 Generic Functions</h4>

<p>Saved output objects can be used in the generic S3 functions <code>plot()</code>,
<code>print()</code>, <code>summary()</code>, and <code>mean()</code>. For all of these <code>pos</code> selects rows of
the <code style="white-space: pre;">&#8288;$summary&#8288;</code> table.
</p>

<ul>
<li> <p><code>plot()</code>: plots the result. See Plot section above.
</p>
</li>
<li> <p><code>print()</code>: prints the result of a single rate, by default the first. Others
can be printed by passing the <code>pos</code> input. e.g. <code>print(x, pos = 2)</code>
</p>
</li>
<li> <p><code>summary()</code>: prints summary table of all results and metadata, or the rows
specified by the <code>pos</code> input. e.g. <code>summary(x, pos = 1:5)</code>. The <code style="white-space: pre;">&#8288;$rep&#8288;</code> column
indicates the replicate number, and <code style="white-space: pre;">&#8288;$rank&#8288;</code> column the ranking of each rate
<em>within</em> each replicate (only used if a different <code>n</code> has been passed,
otherwise they are all <code>1</code>). The summary table (or <code>pos</code> rows) can be
exported as a separate data frame by passing <code>export = TRUE</code>.
</p>
</li>
<li> <p><code>mean()</code>: calculates the mean of the rates from every row or those
specified by the <code>pos</code> input. e.g. <code>mean(x, pos = 1:5)</code> Note if a different
<code>n</code> has been passed this may include multiple rates from each replicate. The
mean can be exported as a numeric value by passing <code>export = TRUE</code>.
</p>
</li></ul>




<h4>More</h4>

<p>For additional help, documentation, vignettes, and more visit the <code>respR</code>
website at <a href="https://januarharianto.github.io/respR/">https://januarharianto.github.io/respR/</a>
</p>



<h3>Value</h3>

<p>Output is a <code>list</code> object of class <code>auto_rate.int</code> containing a
<code>auto_rate</code> object for each replicate in <code style="white-space: pre;">&#8288;$results&#8288;</code>. The output also
contains a <code style="white-space: pre;">&#8288;$summary&#8288;</code> table which includes the full rate regression results
from each replicate with replicate number indicated by the <code style="white-space: pre;">&#8288;$rep&#8288;</code> column.
Output also contains a <code style="white-space: pre;">&#8288;$rate&#8288;</code> element which contains the rate values from
each replicate in order. The function call, inputs, and other metadata are
also included. Note, that if you have many replicates this object can be
rather large (several MB).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Irregular replicate structure ------------------------------------------

# Prepare the data to use in examples
# Note in this dataset each replicate is a different length!
data &lt;- intermittent.rd
# Convert time to minutes (to show different options below)
data[[1]] &lt;- round(data[[1]]/60, 2)
# Inspect
urch_insp &lt;- inspect(data)

# Calculate the most linear rate within each replicate
auto_rate.int(urch_insp,
              starts = c(1, 2101, 3901),
              by = "row",
              method = "linear",
              width = 400) %&gt;%
  summary()

# Calculate the lowest rate within each replicate across
# 5 minutes (300 rows). For this we need to specify a 'measure' phase
# so that the flush is excluded.
auto_rate.int(urch_insp,
              starts = c(1, 2101, 3901),
              measure = 1000,
              by = "row",
              method = "lowest",
              width = 300) %&gt;%
  summary()

# You can even specify different 'measure' phases in each rep
auto_rate.int(urch_insp,
              starts = c(1, 2101, 3901),
              measure = c(1000, 800, 600),
              by = "row",
              method = "lowest",
              width = 300) %&gt;%
  summary()

# We usually don't want to use the start of a replicate just after the flush,
# so we can specify a 'wait' phase. We can also specify 'starts', 'wait',
# 'measure', and 'width' in units of time instead of rows.
#
# By time
# (this time we save the result)
urch_res &lt;- auto_rate.int(urch_insp,
                          starts = c(0, 35, 65), # start locations in minutes
                          wait = 2,              # wait for 2 mins
                          measure = 10,          # measure phase of 10 mins
                          by = "time",           # apply inputs by time values
                          method = "lowest",     # get the 'lowest' rate...
                          width = 5) %&gt;%          #  ... of 5 minutes width
  summary()

# Regular replicate structure --------------------------------------------

# If replicates cycle at regular intervals, 'starts' can be used to specify
# the spacing in rows or time, starting at row 1. Therefore data must be
# subset first so that the first replicate starts at row 1.
#
# Subset and inspect data
zeb_insp &lt;- zeb_intermittent.rd %&gt;%
  subset_data(from = 5840,
              to = 75139,
              by = "row",
              quiet = TRUE) %&gt;%
  inspect()

# Calculate the most linear rate from the same 6-minute region in every
# replicate. Replicates cycle at every 660 rows.
zeb_res &lt;- auto_rate.int(zeb_insp,
                         starts = 660,
                         wait = 120, # exclude first 2 mins
                         measure = 360, # measure period of 6 mins after 'wait'
                         method = "linear",
                         width = 200, # starting value for linear analysis
                         plot = TRUE) %&gt;%
  summary()

# S3 functions ------------------------------------------------------------

# Outputs can be used in print(), summary(), and mean().
# 'pos' can be used to select replicate ranges
summary(zeb_res)
mean(zeb_res, pos = 1:5)

# There are three ways by which the results can be plotted.
# 'pos' can be used to select replicates to be plotted.
#
# type = "rep" - the default. Each replicate plotted on a grid with rate
# region highlighted (up to a maximum of 20).
plot(urch_res)

# type = "full" - each replicate rate region plotted on entire data series.
plot(urch_res, pos = 1:2, type = "full")
# Of limited utility when datset is large
plot(zeb_res, pos = 10, type = "full")

# type = "ar" - the 'auto_rate' object for selected replicates in 'pos' is plotted
# Note this shows the 'measure' phase only
plot(urch_res, pos = 2, type = "ar")

# See vignettes on website for how to adjust and convert rates from auto_rate.int

</code></pre>

<hr>
<h2 id='auto_rate.rep'>Function for auto_rate with replicate number in summary plus limit to n
results</h2><span id='topic+auto_rate.rep'></span>

<h3>Description</h3>

<p>This is an internal function for <code>auto_rate.int()</code>. Runs <code>auto_rate</code> and
replaces the <code style="white-space: pre;">&#8288;$rep&#8288;</code> column in <code style="white-space: pre;">&#8288;$summary&#8288;</code> with the <code>rep</code> input. Also limits
number of results returned using <code>n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auto_rate.rep(
  x,
  method = "linear",
  width = NULL,
  by = "row",
  plot = TRUE,
  rep = 1,
  n = 1,
  rep_row = NULL,
  meas_row = NULL,
  meas_endrow = NULL,
  rep_data = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="auto_rate.rep_+3A_x">x</code></td>
<td>
<p>df or inspect obj</p>
</td></tr>
<tr><td><code id="auto_rate.rep_+3A_method">method</code></td>
<td>
<p>auto_rate method</p>
</td></tr>
<tr><td><code id="auto_rate.rep_+3A_width">width</code></td>
<td>
<p>auto_rate width</p>
</td></tr>
<tr><td><code id="auto_rate.rep_+3A_by">by</code></td>
<td>
<p>auto_rate by</p>
</td></tr>
<tr><td><code id="auto_rate.rep_+3A_plot">plot</code></td>
<td>
<p>auto_rate plot</p>
</td></tr>
<tr><td><code id="auto_rate.rep_+3A_rep">rep</code></td>
<td>
<p>The replicate</p>
</td></tr>
<tr><td><code id="auto_rate.rep_+3A_n">n</code></td>
<td>
<p>number of results to return</p>
</td></tr>
<tr><td><code id="auto_rate.rep_+3A_rep_row">rep_row</code></td>
<td>
<p>start row of this rep in the larger dataset</p>
</td></tr>
<tr><td><code id="auto_rate.rep_+3A_meas_row">meas_row</code></td>
<td>
<p>start row of the measure phase in <em>this</em> rep</p>
</td></tr>
<tr><td><code id="auto_rate.rep_+3A_meas_endrow">meas_endrow</code></td>
<td>
<p>end row of the measure phase in <em>this</em> rep</p>
</td></tr>
<tr><td><code id="auto_rate.rep_+3A_rep_data">rep_data</code></td>
<td>
<p>df of the entire replicate. Used in plotting.</p>
</td></tr>
<tr><td><code id="auto_rate.rep_+3A_...">...</code></td>
<td>
<p>pass plot stuff</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>auto_rate</code> object with <code>summary$rep</code> filled in with appropriate
replicate number
</p>

<hr>
<h2 id='background_con.rd'>Background respirometry data (constant)</h2><span id='topic+background_con.rd'></span>

<h3>Description</h3>

<p>Background oxygen consumption data. After the initial 30 minutes, data shows
a generally constant background rate. Taken from a Loligo swim tunnel
background recording. Oxygen recorded via a Witrox sensor in % air saturation
over nearly 6 hours at 1 second intervals. Data is from a real experiment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>background_con.rd
</code></pre>


<h3>Format</h3>

<p>A data frame object consisting of 20664 rows (approx 6 h of data),and
2 columns: <code style="white-space: pre;">&#8288;$Time&#8288;</code> in seconds, <code style="white-space: pre;">&#8288;$Oxygen&#8288;</code> in % air saturation.
</p>


<h3>Details</h3>


<ul>
<li><p> Dissolved oxygen units: <code style="white-space: pre;">&#8288;% Air Saturation&#8288;</code>
</p>
</li>
<li><p> Time units: <code>seconds</code>
</p>
</li>
<li><p> Swim tunnel volume (L): <code>12.3</code>
</p>
</li>
<li><p> Temperature (°C): <code>14.5</code>
</p>
</li>
<li><p> Salinity: <code>34</code>
</p>
</li>
<li><p> Atm. Pressure (bar): <code>1.013253</code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Nicholas Carey
</p>

<hr>
<h2 id='background_exp.rd'>Background respirometry data (exponential)</h2><span id='topic+background_exp.rd'></span>

<h3>Description</h3>

<p>Background oxygen consumption data. Data shows a background rate which
increases exponentially with respect to time. Taken from a Loligo swim tunnel
background recording. Oxygen recorded via a Witrox sensor in % air saturation
over nearly 6 hours at 1 second intervals. Data is from a real experiment,
but oxygen decrease curve has been exaggerated to impose an exponential
increase in background consumption for testing purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>background_exp.rd
</code></pre>


<h3>Format</h3>

<p>A data frame object consisting of 20664 rows (approx 6 h of data),and
2 columns: <code style="white-space: pre;">&#8288;$Time&#8288;</code> in seconds, <code style="white-space: pre;">&#8288;$Oxygen&#8288;</code> in % air saturation.
</p>


<h3>Details</h3>


<ul>
<li><p> Dissolved oxygen units: <code style="white-space: pre;">&#8288;% Air Saturation&#8288;</code>
</p>
</li>
<li><p> Time units: <code>seconds</code>
</p>
</li>
<li><p> Swim tunnel volume (L): <code>12.3</code>
</p>
</li>
<li><p> Temperature (°C): <code>14.5</code>
</p>
</li>
<li><p> Salinity: <code>34</code>
</p>
</li>
<li><p> Atm. Pressure (bar): <code>1.013253</code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Nicholas Carey
</p>

<hr>
<h2 id='background_lin.rd'>Background respirometry data (linear)</h2><span id='topic+background_lin.rd'></span>

<h3>Description</h3>

<p>Background oxygen consumption data. After initial 30 minutes, data shows a
background rate which increases linearly with respect to time. Taken from a
Loligo swim tunnel background recording. Oxygen recorded via a Witrox sensor
in % air saturation over nearly 6 hours at 1 second intervals. Data is from a
real experiment, but has been manipulated to show a linear increase in
background rate for testing purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>background_lin.rd
</code></pre>


<h3>Format</h3>

<p>A data frame object consisting of 20664 rows (approx 6 h of data),and
2 columns: <code style="white-space: pre;">&#8288;$Time&#8288;</code> in seconds, <code style="white-space: pre;">&#8288;$Oxygen&#8288;</code> in % air saturation.
</p>


<h3>Details</h3>


<ul>
<li><p> Dissolved oxygen units: <code style="white-space: pre;">&#8288;% Air Saturation&#8288;</code>
</p>
</li>
<li><p> Time units: <code>seconds</code>
</p>
</li>
<li><p> Swim tunnel volume (L): <code>12.3</code>
</p>
</li>
<li><p> Temperature (°C): <code>14.5</code>
</p>
</li>
<li><p> Salinity: <code>34</code>
</p>
</li>
<li><p> Atm. Pressure (bar): <code>1.013253</code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Nicholas Carey
</p>

<hr>
<h2 id='broken_stick'>Perform broken-stick regressions</h2><span id='topic+broken_stick'></span>

<h3>Description</h3>

<p>Perform broken-stick regressions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>broken_stick(dt, n)
</code></pre>


<h3>Value</h3>

<p>a data.table object
</p>

<hr>
<h2 id='calc_rate'>Calculate rate of change in oxygen over time</h2><span id='topic+calc_rate'></span>

<h3>Description</h3>

<p>Calculates rate of oxygen uptake or production from respirometry data. A rate
can be determined over the whole dataset, or on subsets of the data using the
<code>from</code> and <code>to</code> inputs to specify data regions in terms of <code>oxygen</code> or <code>time</code>
units or <code>row</code> numbers of the input data. Multiple rates can be extracted
from the same dataset by using these inputs to enter vectors of paired values
in the appropriate metric. See Examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_rate(x, from = NULL, to = NULL, by = "time", plot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_rate_+3A_x">x</code></td>
<td>
<p>object of class <code>inspect</code> or <code>data.frame</code>. This is the timeseries of
paired values of oxygen against time from which to calculate rates.</p>
</td></tr>
<tr><td><code id="calc_rate_+3A_from">from</code></td>
<td>
<p>numeric value or vector. Defaults to <code>NULL</code>. The start of the
region(s) over which you want to calculate the rate in the units specified
in <code>by</code>. If a vector, each value must have a paired value in <code>to</code>.</p>
</td></tr>
<tr><td><code id="calc_rate_+3A_to">to</code></td>
<td>
<p>numeric value or vector. Defaults to <code>NULL</code>. The end of the
region(s) over which you want to calculate the rate in the units specified
in <code>by</code>. If a vector, each value must have a paired value in <code>from</code>.</p>
</td></tr>
<tr><td><code id="calc_rate_+3A_by">by</code></td>
<td>
<p>string. <code>"time"</code>, <code>"row"</code>, or <code>"oxygen"</code>. Defaults to <code>"time"</code>.
This is the method used to subset the data region between <code>from</code> and <code>to</code>.</p>
</td></tr>
<tr><td><code id="calc_rate_+3A_plot">plot</code></td>
<td>
<p>logical. Defaults to <code>TRUE</code>. Plot the results.</p>
</td></tr>
<tr><td><code id="calc_rate_+3A_...">...</code></td>
<td>
<p>Allows additional plotting controls to be passed, such as <code>pos</code>,
<code>panel</code>, and <code>quiet = TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function calculates rates by fitting a linear model of oxygen against
time, with the slope of this regression being the rate. There are no units
involved in <code>calc_rate</code>. This is a deliberate decision. The units of oxygen
concentration and time will be specified later in <code><a href="#topic+convert_rate">convert_rate()</a></code> when
rates are converted to specific output units.
</p>
<p>For continuous data recordings, it is recommended a <code>data.frame</code> containing
the data be prepared via <code><a href="#topic+inspect">inspect()</a></code>, and entered as the <code>x</code> input. For
data not prepared like this, <code>x</code> can be a 2-column <code>data.frame</code> containing
numeric values of time (col 1) and oxygen (col 2). If multiple columns are
found in either an <code>inspect</code> or data frame input, only the first two columns
are used.
</p>


<h4>Specifying regions</h4>

<p>For calculating rates over specific regions of the data, the <code>from</code> and <code>to</code>
inputs in the <code>by</code> units of <code>"time"</code> (the default), &quot;<code>oxygen</code>&quot;, or <code>"row"</code>.
The <code>from</code> and <code>to</code> inputs do not need to be precise; the function will use
the closest values found.
</p>
<p>Multiple regions can be examined within the same dataset by entering <code>from</code>
and <code>to</code> as vectors of paired values to specify different regions. In this
case, <code style="white-space: pre;">&#8288;$rate&#8288;</code> in the output will be a vector of multiple rates with each
result corresponding to the position of the paired <code>from</code> and <code>to</code> inputs. If
<code>from</code> and <code>to</code> are <code>NULL</code> (the default), the rate is determined over the
entire dataset.
</p>



<h4>Plot</h4>

<p>A plot is produced (provided <code>plot = TRUE</code>) showing the original data
timeseries of oxygen against time (bottom blue axis) and row index (top red
axis), with the region specified via the <code>from</code> and <code>to</code> inputs highlighted.
Second panel is a close-up of the rate region with linear model coefficients.
Third and fourth panels are summary plots of fit and residuals.
</p>



<h4>Additional plotting options</h4>

<p>If multiple rates have been calculated, by default the first (<code>pos = 1</code>) is
plotted. Others can be plotted by changing the <code>pos</code> input either in the main
function call, or by plotting the output, e.g. <code>plot(object, pos = 2)</code>. In
addition, each sub-panel can be examined individually by using the <code>panel</code>
input, e.g. <code>plot(object, panel = 2)</code>.
</p>
<p>Console output messages can be suppressed using <code>quiet = TRUE</code>. If axis
labels (particularly y-axis) are difficult to read, <code>las = 2</code> can be passed
to make axis labels horizontal, and <code>oma</code> (outer margins, default <code>oma = c(0.4, 1, 1.5, 0.4)</code>), and <code>mai</code> (inner margins, default <code>mai = c(0.3, 0.15, 0.35, 0.15)</code>) used to adjust plot margins.
</p>



<h4>S3 Generic Functions</h4>

<p>Saved output objects can be used in the generic S3 functions <code>print()</code>,
<code>summary()</code>, and <code>mean()</code>.
</p>

<ul>
<li> <p><code>print()</code>: prints a single result, by default the first rate. Others can be
printed by passing the <code>pos</code> input. e.g. <code>print(x, pos = 2)</code>
</p>
</li>
<li> <p><code>summary()</code>: prints summary table of all results and metadata, or those
specified by the <code>pos</code> input. e.g. <code>summary(x, pos = 1:5)</code>. The summary can
be exported as a separate dataframe by passing <code>export = TRUE</code>.
</p>
</li>
<li> <p><code>mean()</code>: calculates the mean of all rates, or those specified by the <code>pos</code>
input. e.g. <code>mean(x, pos = 1:5)</code> The mean can be exported as a separate value
by passing <code>export = TRUE</code>.
</p>
</li></ul>




<h4>More</h4>

<p>For additional help, documentation, vignettes, and more visit the <code>respR</code>
website at <a href="https://januarharianto.github.io/respR/">https://januarharianto.github.io/respR/</a>
</p>



<h3>Value</h3>

<p>Output is a <code>list</code> object of class <code>calc_rate</code> containing input
parameters and data, various summary data, metadata, linear models, and the
primary output of interest <code style="white-space: pre;">&#8288;$rate&#8288;</code>, which can be background adjusted in
<code><a href="#topic+adjust_rate">adjust_rate</a></code> or converted to units in <code><a href="#topic+convert_rate">convert_rate</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Subset by 'time' (the default)
inspect(sardine.rd, time = 1, oxygen = 2, plot = FALSE) %&gt;%
  calc_rate(from = 200, to = 1800)

# Subset by oxygen
inspect(sardine.rd, time = 1, oxygen = 2, plot = FALSE) %&gt;%
  calc_rate(94, 91, by = "oxygen")

# Subset by row
inspect(sardine.rd, time = 1, oxygen = 2, plot = FALSE) %&gt;%
  calc_rate(1000, 2000, by = "row")

# Use a data frame input, and calculate rate from multiple regions by
# using a vector in the 'from' and 'to' inputs
x &lt;- calc_rate(intermittent.rd,
               from = c(200,2300,4100),
               to = c(1800,3200,4600),
               by = 'time',
               plot = FALSE)
# Print and summary of results
print(x)
summary(x)
# Plot the third of these results
plot(x, pos = 3)
# Plot only the timeseries plot and hide the legend
plot(x, pos = 3, panel = 1, legend = FALSE)
</code></pre>

<hr>
<h2 id='calc_rate.bg'>Calculate background oxygen uptake or input rates</h2><span id='topic+calc_rate.bg'></span>

<h3>Description</h3>

<p>This function calculates the rate of change of oxygen over time from &quot;blank&quot;
or control respirometry experiments, to allow for background adjustments of
experimental data. It accepts background oxygen~time data as data frames and
<code>inspect</code> objects. The data must be in the same time and oxygen units as the
data from which the rate which will be adjusted was extracted. Multiple
columns of background oxygen measurements can be entered as long as they
share the same time data. In this case the function returns rates for all
columns, and also calculates a mean rate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_rate.bg(x, time = NULL, oxygen = NULL, plot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_rate.bg_+3A_x">x</code></td>
<td>
<p><code>data.frame</code> or <code>inspect</code> object. This is the data to extract
background rate(s) from.</p>
</td></tr>
<tr><td><code id="calc_rate.bg_+3A_time">time</code></td>
<td>
<p>integer. Defaults to 1. This specifies the column number of the
time data.</p>
</td></tr>
<tr><td><code id="calc_rate.bg_+3A_oxygen">oxygen</code></td>
<td>
<p>integer value or vector. This specifies the column number(s) of
the oxygen data. Multiple columns of oxygen can be specified. If NULL,
function assumes oxygen data are in <em>all</em> columns of the data frame except
the <code>time</code> column.</p>
</td></tr>
<tr><td><code id="calc_rate.bg_+3A_plot">plot</code></td>
<td>
<p>logical. Defaults to TRUE. Plots the data. See Details.</p>
</td></tr>
<tr><td><code id="calc_rate.bg_+3A_...">...</code></td>
<td>
<p>Allows additional plotting controls to be passed, such as <code>pos</code>,
<code>legend = FALSE</code>, and <code>quiet = TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main difference between <code>calc_rate.bg</code> and <code>calc_rate</code>, is that this
function allows a rate to be determined from the same region of multiple
oxygen data columns, whereas <code>calc_rate</code> allows multiple rates to be
determined from different regions of a single dataset.
</p>


<h4>Units</h4>

<p>There are no units involved in <code>calc_rate.bg</code>. This is a deliberate decision.
The units of oxygen concentration and time will be specified later in
<code><a href="#topic+convert_rate">convert_rate()</a></code> when rates are converted to specific output units. It is
important however, the background time~oxygen data is in the same time and
oxygen units as the data used to determine the rate which will be adjusted.
</p>



<h4>Subsetting data regions</h4>

<p><code>calc_rate.bg</code> does not have internal subsetting of data regions. If you need
to subset the data to specific regions you don't want to use, see
<code><a href="#topic+subset_data">subset_data()</a></code>, which allows for easy passing (or piping) of subsets to
<code>calc_rate.bg</code>.
</p>



<h4>Background respiration vs background input of oxygen</h4>

<p>Most users will be using this function to account for background oxygen
consumption rates from microbial activity that need to be quantified and
their effects removed from experimental specimen rates. However, there are
some experiments where oxygen <em>input</em> rates may be of interest, for example
in open tank or open arena respirometry where the input of oxygen from the
water surface has been calculated or quantified. There are also cases in
closed respirometry where there may be an input of oxygen via leaks or oxygen
production from photosynthesis which need to be quantified. <code>calc_rate.bg</code> is
readily capable of quantifying production rates as well as consumption, and
these can also be used for adjustments in <code><a href="#topic+adjust_rate">adjust_rate()</a></code>.
</p>



<h4>Plot</h4>

<p>A plot is produced (provided <code>plot = TRUE</code>) showing all examined columns of
oxygen against time (bottom blue axis) and row index (top red axis), with the
rate and linear model coefficients. Single rates can be plotted by changing
the <code>pos</code> input either in the main function call, or by plotting the output,
e.g. <code>plot(object, pos = 2)</code>. Console output messages can be suppressed using
<code>quiet = TRUE</code>. If equations obscure the plot they can be suppressed using
<code>legend = FALSE</code>.
</p>



<h4>S3 Generic Functions</h4>

<p>Saved output objects can be used in the generic S3 functions <code>print()</code>,
<code>summary()</code>, and <code>mean()</code>.
</p>

<ul>
<li> <p><code>print()</code>: prints all background rates, plus the mean background rate.
</p>
</li>
<li> <p><code>summary()</code>: prints summary table of all results and metadata, or those
specified by the <code>pos</code> input. e.g. <code>summary(x, pos = 1:5)</code>. The summary can
be exported as a separate dataframe by passing <code>export = TRUE</code>.
</p>
</li>
<li> <p><code>mean()</code>: calculates the mean of all rates, or those specified by the <code>pos</code>
input. e.g. <code>mean(x, pos = 1:5)</code> The mean can be exported as a separate value
by passing <code>export = TRUE</code>.
</p>
</li></ul>




<h4>More</h4>

<p>For additional help, documentation, vignettes, and more visit the <code>respR</code>
website at <a href="https://januarharianto.github.io/respR/">https://januarharianto.github.io/respR/</a>
</p>



<h3>Value</h3>

<p>Output is a <code>list</code> object of class <code>calc_rate.bg</code> containing original
data, linear models, summary information, and the primary output of
interest <code style="white-space: pre;">&#8288;$rate.bg&#8288;</code>, which contains a rate for each oxygen column present
in the input data. There is also <code style="white-space: pre;">&#8288;$rate.bg.mean&#8288;</code> containing the mean of all
background rates. Note, this is not used in <code>adjust_rate</code>, where the
<code>method</code> input there determines how <code style="white-space: pre;">&#8288;$rate.bg&#8288;</code> is applied, but can easily
be extracted and applied as an adjustment value if desired.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Inspect and calculate background rate from two columns
inspect(urchins.rd, time = 1, oxygen = 18:19) %&gt;%
  calc_rate.bg()

# Same example but enter as a data frame, save as an object and use
# in adjust_rate
bg_rate &lt;- calc_rate.bg(urchins.rd,
                        time = 1,
                        oxygen = 18:19,
                        plot = FALSE)

inspect(urchins.rd, 1, 2, plot = FALSE) %&gt;%
  calc_rate(from = 10, to = 30, by = "time", plot = FALSE) %&gt;%
  adjust_rate(by = bg_rate)

# Subset single column data first before calculating background rate
subset_data(background_con.rd, from = 5000, to = 20000, by = "time") %&gt;%
  calc_rate.bg()
  
</code></pre>

<hr>
<h2 id='calc_rate.ft'>Calculate rate of change in oxygen from flowthrough respirometry data</h2><span id='topic+calc_rate.ft'></span>

<h3>Description</h3>

<p>Calculates rate of oxygen uptake or production in flowthrough respirometry
data given a <code>flowrate</code> and delta oxygen values, which can either be directly
entered, or be calculated from inflow and outflow oxygen. The function
returns a single rate value from the whole dataset or a subset of it, by
averaging delta oxygen values. Alternatively, multiple rate values can be
returned from different regions of continuous data, or a rolling rate of a
specific window size performed across the whole dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_rate.ft(
  x = NULL,
  flowrate = NULL,
  from = NULL,
  to = NULL,
  by = NULL,
  width = NULL,
  plot = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_rate.ft_+3A_x">x</code></td>
<td>
<p>numeric value or vector of delta oxygen values, a 2-column
<code>data.frame</code> of outflow (col 1) and inflow (col 2) oxygen values, or an
object of class <code>inspect.ft</code>.</p>
</td></tr>
<tr><td><code id="calc_rate.ft_+3A_flowrate">flowrate</code></td>
<td>
<p>numeric value. The flow rate through the respirometer in
volume (ul,ml,L) per unit time (s,m,h,d). The units are not necessary here,
but will be specified in <code><a href="#topic+convert_rate.ft">convert_rate.ft</a></code>.</p>
</td></tr>
<tr><td><code id="calc_rate.ft_+3A_from">from</code></td>
<td>
<p>numeric value or vector. Defaults to <code>NULL</code>. The start of the
region(s) over which you want to calculate the rate in either time or row
units. If a vector, each value must have a paired value in <code>to</code>. For use
with <code>inspect.ft</code> inputs only.</p>
</td></tr>
<tr><td><code id="calc_rate.ft_+3A_to">to</code></td>
<td>
<p>numeric value or vector. Defaults to <code>NULL</code>. The end of the
region(s) over which you want to calculate the rate in either time or row
units. If a vector, each value must have a paired value in <code>from</code>. For use
with <code>inspect.ft</code> inputs only.</p>
</td></tr>
<tr><td><code id="calc_rate.ft_+3A_by">by</code></td>
<td>
<p><code>"time"</code> or <code>"row"</code>. Defaults to <code>"time"</code>. Specifies the units of
the <code>from</code> and <code>by</code>, or <code>width</code> value. For use with <code>inspect.ft</code> inputs
only.</p>
</td></tr>
<tr><td><code id="calc_rate.ft_+3A_width">width</code></td>
<td>
<p>numeric. Calculates a rolling rate across the whole dataset of
the specified width in the units specified in <code>by</code>. For use with
<code>inspect.ft</code> inputs only.</p>
</td></tr>
<tr><td><code id="calc_rate.ft_+3A_plot">plot</code></td>
<td>
<p>logical. Defaults to TRUE. Plots the data.</p>
</td></tr>
<tr><td><code id="calc_rate.ft_+3A_...">...</code></td>
<td>
<p>Allows additional plotting controls to be passed such as <code>pos</code>,
<code>quiet = TRUE</code>, <code>legend = FALSE</code>, and <code>rate.rev = FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>calc_rate.ft</code> calculates rates by averaging delta oxygen values across the
whole dataset, or from specified subsets of the data. The <code>flowrate</code> is then
used to convert these average delta values to rates. There are no units
involved in <code>calc_rate.ft</code>. This is a deliberate decision. The units of
oxygen concentration and flowrate will be specified later in
<code><a href="#topic+convert_rate.ft">convert_rate.ft()</a></code> when rates are converted to specific output units.
</p>
<p>For continuous data recordings, it is recommended a <code>data.frame</code> containing
the data be prepared via <code><a href="#topic+inspect.ft">inspect.ft()</a></code>, and entered as the <code>x</code> input.
</p>
<p>For data not prepared like this, <code>x</code> can be a 2-column <code>data.frame</code>
containing numeric values of outflow (col 1) and inflow (col 2) oxygen
concentrations in that order. Alternatively, if <code>x</code> is a numeric value or
vector it is treated as delta oxygen values (outflow oxygen concentration
minus inflow oxygen concentration in the same units). In both these cases,
the <code>from</code>, <code>to</code>, and <code>by</code> inputs are are ignored, and all delta oxygen
values whether as entered or calculated from the inflow and outflow oxygen
columns are converted to rates.
</p>


<h4>Specifying regions</h4>

<p>For calculating rates over specific regions of the data, the <code>from</code> and <code>to</code>
inputs in the <code>by</code> units of <code>"time"</code> (the default) or <code>"row"</code> can be used for
<code><a href="#topic+inspect.ft">inspect.ft()</a></code> inputs. All delta oxygen values within this region are
converted to rates, and averaged to produce a overall rate for the region
(<code style="white-space: pre;">&#8288;$rate&#8288;</code> in the output). Multiple regions can be examined within the same
dataset by entering <code>from</code> and <code>to</code> as vectors of paired values to specify
different regions. In this case, <code style="white-space: pre;">&#8288;$rate&#8288;</code> in the output will be a vector of
multiple rates with each result corresponding to the position of the paired
<code>from</code> and <code>to</code> inputs. If <code>from</code> and <code>to</code> are <code>NULL</code> (the default), the rate
is determined over the entire dataset.
</p>
<p>Alternatively a <code>width</code> input can be specified, in which case a rolling rate
is calculated using this window size (in the relevant <code>by</code> units) across the
entire dataset, and returned as a vector of rate values in <code style="white-space: pre;">&#8288;$rate&#8288;</code>. See
<a href="https://januarharianto.github.io/respR/articles/flowthrough.html#case-8-rolling-rate">here</a>
for how this might be used.
</p>



<h4>Flowrate</h4>

<p>In order to convert delta oxygen values to a oxygen uptake or production
rate, the <code>flowrate</code> input is required. This must be in a volume (L, ml, or
ul) per unit time (s,m,h,d), for example in <code>L/s</code>. The units are not required
to be entered here; they will be specified in <code style="white-space: pre;">&#8288;[convert_rate.ft()&#8288;</code>] to
convert rates to specific units of oxygen uptake or production.
</p>



<h4>Plot</h4>

<p>For rates calculated from <code>inspect.ft</code> inputs, a plot is produced (provided
<code>plot = TRUE</code>) showing the original data timeseries of inflow and outflow
oxygen (if present, top plot), oxygen delta values (middle or top plot) with
the region specified via the <code>from</code> and <code>to</code> inputs highlighted in orange,
and a close-up of this region with calculated rate value (bottom plot). If
multiple rates have been calculated, by default the first is plotted. Others
can be plotted by changing the <code>pos</code> input, e.g. <code>plot(object, pos = 2)</code>.
</p>
<p><em><strong>Important:</strong></em> Since <code>respR</code> is primarily used to examine oxygen
consumption, the delta oxygen and rate plots are by default plotted on a
reverse y-axis. In <code>respR</code> oxygen uptake rates are negative since they
represent a negative slope of oxygen against time. In these plots the axis is
reversed so that higher uptake rates (i.e. more negative rates) will be
higher on these plots. If you are interested instead in oxygen production
rates, which are positive, the <code>rate.rev = FALSE</code> input can be passed in
either the <code>inspect.ft</code> call, or when using <code>plot()</code> on the output object. In
this case, the delta and rate values will be plotted numerically, with higher
oxygen <em>production</em> rates higher on the plot.
</p>



<h4>Additional plotting options</h4>

<p>If the legend or labels obscure part of the plot, they can be suppressed via
<code>legend = FALSE</code> in either the <code>inspect.ft</code> call, or when using <code>plot()</code> on
the output object. Console output messages can be suppressed using <code>quiet = TRUE</code>. Console output messages can be suppressed using <code>quiet = TRUE</code>. If
axis labels or other text boxes obscure parts of the plot they can be
suppressed using <code>legend = FALSE</code>. If axis labels (particularly y-axis) are
difficult to read, <code>las = 2</code> can be passed to make axis labels horizontal,
and<code>oma</code> (outer margins, default <code>oma = c(0.4, 1, 1.5, 0.4)</code>), and <code>mai</code>
(inner margins, default <code>mai = c(0.3, 0.15, 0.35, 0.15)</code>) used to adjust plot
margins.
</p>



<h4>Background control or &quot;blank&quot; experiments</h4>

<p><code>calc_rate.ft</code> can also be used to determine background rates from empty
control experiments in the same way specimen rates are determined. The saved
objects can be used as the <code>by</code> input in <code><a href="#topic+adjust_rate.ft">adjust_rate.ft()</a></code>. For
experiments in which the specimen data is to be corrected by a
concurrently-run control experiment, best option is to use this as the
<code>in.oxy</code> input in <code><a href="#topic+inspect.ft">inspect.ft()</a></code>. See help file for that function, or the
vignettes on the website for examples.
</p>



<h4>S3 Generic Functions</h4>

<p>Saved output objects can be used in the generic S3 functions <code>print()</code>,
<code>summary()</code>, and <code>mean()</code>.
</p>

<ul>
<li> <p><code>print()</code>: prints a single result, by default the first rate. Others can be
printed by passing the <code>pos</code> input. e.g. <code>print(x, pos = 2)</code>
</p>
</li>
<li> <p><code>summary()</code>: prints summary table of all results and metadata, or those
specified by the <code>pos</code> input. e.g. <code>summary(x, pos = 1:5)</code>. The summary can
be exported as a separate data frame by passing <code>export = TRUE</code>.
</p>
</li>
<li> <p><code>mean()</code>: calculates the mean of all rates, or those specified by the <code>pos</code>
input. e.g. <code>mean(x, pos = 1:5)</code> The mean can be exported as a separate value
by passing <code>export = TRUE</code>.
</p>
</li></ul>




<h4>More</h4>

<p>For additional help, documentation, vignettes, and more visit the <code>respR</code>
website at <a href="https://januarharianto.github.io/respR/">https://januarharianto.github.io/respR/</a>
</p>



<h3>Value</h3>

<p>Output is a <code>list</code> object of class <code>calc_rate.ft</code> containing input
parameters and data, various summary data, metadata, and the primary output
of interest <code style="white-space: pre;">&#8288;$rate&#8288;</code>, which can be background adjusted in <code><a href="#topic+adjust_rate.ft">adjust_rate.ft</a></code>
or converted to units in <code><a href="#topic+convert_rate.ft">convert_rate.ft</a></code>. Note the <code style="white-space: pre;">&#8288;$summary&#8288;</code> table
contains linear regression coefficients alongside other metadata. These
<em>should not be confused</em> with those in other functions such as <code>calc_rate</code>
where slopes represent rates and coefficients such as a high r-squared are
important. Here, they represent the stability of the data region, in that
the closer the slope is to zero the less the delta oxygen values, and
therefore rates, in that region vary. These are included to enable possible
future functionality where stable regions may be automatically identified.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Single numeric delta oxygen value. The delta oxygen is the difference
# between inflow and outflow oxygen.
calc_rate.ft(-0.8, flowrate = 1.6)

# Numeric vector of multiple delta oxygen values
ft_rates &lt;- calc_rate.ft(c(-0.8, -0.88, -0.9, -0.76), flowrate = 1.6)
print(ft_rates)
summary(ft_rates)

# Calculate rate from entire dataset
inspect.ft(flowthrough.rd, time = 1, out.oxy = 2, in.oxy = 3, ) %&gt;%
  calc_rate.ft(flowrate = 2.34)

# Calculate rate from a region based on time
inspect.ft(flowthrough.rd, time = 1, out.oxy = 2, in.oxy = 3, ) %&gt;%
  calc_rate.ft(flowrate = 2.34, from = 200, to = 400, by = "time")

# Calculate rate from multiple regions
inspect.ft(flowthrough.rd, time = 1, out.oxy = 2, in.oxy = 3, ) %&gt;%
  calc_rate.ft(flowrate = 2.34,
               from = c(200, 400, 600),
               to = c(300, 500, 700),
               by = "row") %&gt;%
  summary()

# Calculate rate from existing delta oxygen values
inspect.ft(flowthrough.rd, time = 1, delta.oxy = 4) %&gt;%
  calc_rate.ft(flowrate = 2.34, from = 200, to = 400, by = "time")

# Calculate rate from a background recording
inspect.ft(flowthrough_mult.rd,
           time = 1,
           out.oxy = 5,
           in.oxy = 9) %&gt;%
  calc_rate.ft(flowrate = 0.1, from = 20, to = 40, by = "time") %&gt;%
  summary()

# Calculate a rolling rate
inspect.ft(flowthrough_mult.rd,
           time = 1,
           out.oxy = 2,
           in.oxy = 6) %&gt;%
  calc_rate.ft(flowrate = 0.1, width = 500, by = "row") %&gt;%
  summary()
</code></pre>

<hr>
<h2 id='calc_rate.int'>Extract rates from multiple replicates in intermittent-flow respirometry data</h2><span id='topic+calc_rate.int'></span>

<h3>Description</h3>

<p><code>calc_rate.int</code> allows you to extract an oxygen uptake or production rate
from multiple replicates in intermittent-flow respirometry. It allows you to
easily use consistent selection parameters to extract a single rate from each
replicate, for example a specific time range or row range.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_rate.int(
  x,
  starts = NULL,
  wait = NULL,
  measure = NULL,
  by = "row",
  plot = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_rate.int_+3A_x">x</code></td>
<td>
<p>Object of class <code>inspect</code> or <code>data.frame</code>. This is the timeseries of
paired values of oxygen against time containing multiple replicates from
which to calculate rates.</p>
</td></tr>
<tr><td><code id="calc_rate.int_+3A_starts">starts</code></td>
<td>
<p>Integer(s). Row locations or times of the start of each
replicate. A single value input indicates a regular interval in rows or
time units starting at the first row of the data in <code>x</code>. If replicates do
not cycle at a regular interval, a vector of the row or time of each
replicate can be entered. The function assumes each replicate ends at the
row preceding the start of the next replicate, or for the final replicate
the final row of the dataset.</p>
</td></tr>
<tr><td><code id="calc_rate.int_+3A_wait">wait</code></td>
<td>
<p>Numeric. Rows or time period to exclude at the start of each
replicate. Default is <code>NULL</code> in which case no wait phase is applied. See
Details.</p>
</td></tr>
<tr><td><code id="calc_rate.int_+3A_measure">measure</code></td>
<td>
<p>Numeric. Rows or time period over which to calculate rate in
each replicate. Applied directly after <code>wait</code> phase. Default is <code>NULL</code> in
which case the entire replicate is used. See Details.</p>
</td></tr>
<tr><td><code id="calc_rate.int_+3A_by">by</code></td>
<td>
<p>String. <code>"row"</code> or <code>"time"</code>. Defaults to <code>"row"</code>. Method by which
<code>starts</code>, <code>wait</code> and <code>measure</code> are applied.</p>
</td></tr>
<tr><td><code id="calc_rate.int_+3A_plot">plot</code></td>
<td>
<p>Logical. Default is <code>TRUE</code>. Plots the results. See 'Plotting'
section for details.</p>
</td></tr>
<tr><td><code id="calc_rate.int_+3A_...">...</code></td>
<td>
<p>Allows additional plotting controls to be passed, such as <code>type</code>,
<code>pos</code>, <code>legend</code>, and <code>quiet</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>calc_rate.int</code> uses the <code>starts</code> input to subset each replicate. The <code>wait</code>
and <code>measure</code> inputs control which parts of each replicate data are excluded
and included from the rate calculation. It extracts a rate from each
replicate using these, and saves it and other data to a summary table.
</p>
<p>The <code>x</code> input should be an<code>inspect</code> object. Alternatively, it can be a
two-column data frame containing paired values of time and oxygen from an
intermittent-flow experiment in columns 1 and 2 respectively (though we
always recommend processing such data in <code>inspect()</code> first). If a multiple
column dataset is entered as <code>x</code> the first two columns are selected by
default. If these are not the intended data use <code>inspect</code> to select the
correct time and oxygen columns.
</p>


<h4>Specifying replicate structure</h4>

<p>The <code>starts</code> input specifies the locations of the start of each replicate in
the data in <code>x</code>. This can be in one of two ways:
</p>

<ul>
<li><p> A single numeric value specifying how replicates are spaced starting from
the data in the first row. This option should only be used when replicates
cycle at regular intervals. This can be a regular row or time interval, as
specified via the <code>by</code> input. If the first replicate does not start at row 1,
the data should be subset so that it does (see <code>subset_data()</code>) and example
<a href="https://januarharianto.github.io/respR/articles/intermittent_long.html">here</a>.
</p>
</li>
<li><p> A numeric vector of row locations or times, as specified via the <code>by</code>
input, of the start of each individual replicate. The first replicate does
not have to start at the first row of the data, and all data after the last
entry is assumed to be part of the final replicate. Regular <code>R</code> syntax such
as <code>seq()</code>, <code>1:10</code>, etc. is also accepted, so can be used to specify both
regular and irregular replicate spacing.
</p>
</li></ul>

<p>For both methods it is assumed each replicate ends at the row preceding the
start of the next replicate, or in the case of the last replicate the final
row of the dataset.
</p>



<h4>Specifying rate region</h4>

<p>The <code>wait</code> and <code>measure</code> inputs are used to specify the region from which to
extract a rate and exclude flush periods. They can be entered as row
intervals or time values in the units of the input data. The <code>wait</code> phase
controls the amount of data at the start of each replicate to be ignored,
that is not used in rate calculations. The <code>measure</code> phase determines the
region after this over which a rate is calculated. There is no <code>flush</code> phase
input since this is assumed to be from the end of the <code>measure</code> phase to the
end of the replicate.
</p>
<p>Both <code>wait</code> and <code>measure</code> can be entered in one of two ways:
</p>

<ul>
<li><p> Single numeric values specifying a row width or a time period, as specified
via the <code>by</code> input. Use this if you want to use the <em>same</em> <code>wait</code> and
<code>measure</code> phases in every replicate, that is extract a rate from the same
region of each.
</p>
</li>
<li><p> If <code>starts</code> is a vector of locations of the start of each replicate, these
inputs can also be vectors of equal length of row lengths or time periods as
specified via the <code>by</code> input. This is only useful if you want to use
<em>different</em> <code>wait</code> and/or <code>measure</code> phases in different replicates.
</p>
</li></ul>

<p>If <code>wait = NULL</code> no wait phase is applied. If <code>measure = NULL</code> the rate is
extracted from the start of the replicate or end of the <code>wait</code> phase to the
last row of the replicate. This will typically include the flush period, so
is rarely what you would want. Similarly if any <code>measure</code> input is beyond the
available values in the replicate the closest value (row or time) is used
instead, which again would typically be the last row of the replicate.
</p>



<h4>Example</h4>

<p>See examples below for actual code, but here is a simple example. An
experiment comprises replicates which cycle at ten minute intervals with data
recorded every second. Therefore each replicate will be 600 rows long.
Flushes of the respirometer take 3 minutes at the end of each replicate. We
want to exclude the first 2 minutes (120 rows) of data in each, and measure
an oxygen uptake rate for five minutes (300 rows), leaving the three minutes
of flushing (180 rows) excluded. The inputs for this would be:
</p>
<p><code style="white-space: pre;">&#8288;starts = 600, wait = 120, measure = 300, by = "row"&#8288;</code>
</p>



<h4>More details</h4>

<p>Only a single rate can be extracted from each replicate. If for some reason
you need to extract multiple rates from single replicates use <code>subset_data()</code>
and <code>calc_rate()</code> which accepts multiple <code>from</code> and <code>to</code> inputs. Similarly,
the <code>calc_rate</code> method of <code>by = "oxygen"</code> is not supported in
<code>calc_rate.int</code>. See vignettes on the website for examples of alternative
ways of iterating <code>calc_rate</code> across multiple replicates if you need to get
around these constraints.
</p>



<h4>Plot</h4>

<p>If <code>plot = TRUE</code> (the default), the result for each replicate is plotted on a
grid up to a maximum of 20. Which replicates are plotted can be selected
using the <code>pos</code> input (default is 1:20), either in the main function call or
when calling <code>plot()</code> on output objects.
</p>
<p>There are three ways of plotting the results, which can be selected using the
<code>type</code> input:
</p>

<ul>
<li> <p><code>type = "rep"</code>: The default. Each individual replicate is plotted with the
rate region (i.e. <code>measure</code> phase) highlighted in yellow. The <code>wait</code> and
<code>measure</code> phases are also highlighted with red and green backgrounds
respectively. These are also labelled if <code>legend = TRUE</code>.
</p>
</li>
<li> <p><code>type = "full"</code>: Each replicate rate (i.e. <code>measure</code> phase) is highlighted
in the context of the whole dataset. May be quite difficult to interpret if
dataset is large.
</p>
</li>
<li> <p><code>type = "cr"</code>: Plots individual replicate results as <code>calc_rate</code> objects.
</p>
</li></ul>

<p>For all types <code>pos</code> can be used to select which replicate(s) to plot.
</p>



<h4>S3 Generic Functions</h4>

<p>Saved output objects can be used in the generic S3 functions <code>plot()</code>,
<code>print()</code>, <code>summary()</code>, and <code>mean()</code>.
</p>

<ul>
<li> <p><code>plot()</code>: plots the result. See Plot section above.
</p>
</li>
<li> <p><code>print()</code>: prints the result of a single replicate, by default the first.
Others can be printed by passing the <code>pos</code> input. e.g. <code>print(x, pos = 2)</code>
</p>
</li>
<li> <p><code>summary()</code>: prints summary table of all results and metadata, or the rows
specified by the <code>pos</code> input. e.g. <code>summary(x, pos = 1:5)</code>. The <code style="white-space: pre;">&#8288;$rep&#8288;</code> column
indicates the replicate number. The summary table can be exported as a
separate data frame by passing <code>export = TRUE</code>.
</p>
</li>
<li> <p><code>mean()</code>: calculates the mean of the rates from every replicate, or the
rows specified by the <code>pos</code> input. e.g. <code>mean(x, pos = 1:5)</code> The mean can be
exported as a numeric value by passing <code>export = TRUE</code>.
</p>
</li></ul>




<h4>More</h4>

<p>For additional help, documentation, vignettes, and more visit the <code>respR</code>
website at <a href="https://januarharianto.github.io/respR/">https://januarharianto.github.io/respR/</a>
</p>



<h3>Value</h3>

<p>Output is a <code>list</code> object of class <code>calc_rate.int</code> containing a
<code>calc_rate</code> object for each replicate in <code style="white-space: pre;">&#8288;$results&#8288;</code>. The output also
contains a <code style="white-space: pre;">&#8288;$summary&#8288;</code> table which includes the full rate regression results
from each replicate with replicate number indicated by the <code style="white-space: pre;">&#8288;$rep&#8288;</code> column.
Output also contains a <code style="white-space: pre;">&#8288;$rate&#8288;</code> element which contains the rate values from
each replicate in order. The function call, inputs, and other metadata are
also included. Note, that if you have many replicates this object can be
rather large (several MB).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Irregular replicate structure ------------------------------------------

# Prepare the data to use in examples
# Note in this dataset each replicate is a different length!
data &lt;- intermittent.rd
# Convert time to minutes (to show different options below)
data[[1]] &lt;- round(data[[1]]/60, 2)
# Inspect
urch_insp &lt;- inspect(data)

# Calculate rate across each entire replicate
# This leads to erroneous rates because the flush is included
calc_rate.int(urch_insp,
              starts = c(1, 2101, 3901))

# So instead we also specify a 'measure' phase
calc_rate.int(urch_insp,
              starts = c(1, 2101, 3901),
              measure = 1000)

# You can even specify different 'measure' phases in each rep
calc_rate.int(urch_insp,
              starts = c(1, 2101, 3901),
              measure = c(1500, 1200, 200))

# We usually don't want to use the start of a replicate just after the flush,
# so we specify a 'wait' phase. We can also specify 'starts', 'wait' and
# 'measure' in units of time instead of rows.
#
# By time
# (this time we save the result)
urch_res &lt;- calc_rate.int(urch_insp,
                          starts = c(0, 35, 65), # start locations in minutes
                          wait = 2,              # wait for 2 mins
                          measure = 10,          # measure for 10 mins
                          by = "time")

# Regular replicate structure --------------------------------------------

# If replicates cycle at regular intervals, 'starts' can be used to specify
# the spacing in rows or time, starting at row 1. Therefore data must be
# subset first so that the first replicate starts at row 1.
#
# Subset and inspect data
zeb_insp &lt;- zeb_intermittent.rd %&gt;%
  subset_data(from = 5840,
              to = 75139,
              by = "row",
              quiet = TRUE) %&gt;%
  inspect()

# Calculate a rate from same 6-minute region in every replicate.
# Replicates cycle at every 660 rows.
zeb_res &lt;- calc_rate.int(zeb_insp,
                         starts = 660,
                         wait = 120, # exclude first 2 mins
                         measure = 360, # rate from 6 mins after 'wait'
                         plot = TRUE)

# S3 functions ------------------------------------------------------------

# Outputs can be used in print(), summary(), and mean().
# 'pos' can be used to select replicate ranges
summary(zeb_res)
mean(zeb_res, pos = 1:5)

# There are three ways by which the results can be plotted.
# 'pos' can be used to select replicates to be plotted.
#
# type = "rep" - the default. Each replicate plotted on a grid with rate
# region highlighted (up to a maximum of 20).
plot(urch_res)

# type = "full" - each replicate rate region plotted on entire data series.
plot(urch_res, pos = 1:2, type = "full")
# Of limited utility when datset is large
plot(zeb_res, pos = 10, type = "full")

# type = "cr" - the 'calc_rate' object for selected replicates in 'pos' is plotted
plot(urch_res, pos = 2, type = "cr")

# See vignettes on website for how to adjust and convert rates from calc_rate.int

</code></pre>

<hr>
<h2 id='calc_rate.rep'>Function for calc_rate with replicate number in summary</h2><span id='topic+calc_rate.rep'></span>

<h3>Description</h3>

<p>This is an internal function for <code>calc_rate.int()</code>. Runs <code>calc_rate</code>
and replaces the <code style="white-space: pre;">&#8288;$rep&#8288;</code> column in <code style="white-space: pre;">&#8288;$summary&#8288;</code> with the <code>rep</code>
input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_rate.rep(
  x,
  from = NULL,
  to = NULL,
  by = "time",
  plot = TRUE,
  rep = 1,
  supp.mess = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_rate.rep_+3A_x">x</code></td>
<td>
<p>df or inspect obj</p>
</td></tr>
<tr><td><code id="calc_rate.rep_+3A_from">from</code></td>
<td>
<p>calc_rate from</p>
</td></tr>
<tr><td><code id="calc_rate.rep_+3A_to">to</code></td>
<td>
<p>calc_rate to</p>
</td></tr>
<tr><td><code id="calc_rate.rep_+3A_by">by</code></td>
<td>
<p>calc_rate by</p>
</td></tr>
<tr><td><code id="calc_rate.rep_+3A_plot">plot</code></td>
<td>
<p>calc_rate plot</p>
</td></tr>
<tr><td><code id="calc_rate.rep_+3A_rep">rep</code></td>
<td>
<p>The replicate</p>
</td></tr>
<tr><td><code id="calc_rate.rep_+3A_supp.mess">supp.mess</code></td>
<td>
<p>Suppress messages?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>calc_rate</code> object with <code>summary$rep</code> filled in with appropriate
replicate number
</p>

<hr>
<h2 id='calc_win'>Automatically calculate rolling window</h2><span id='topic+calc_win'></span>

<h3>Description</h3>

<p>The calculated value is used to determine the rolling window for rolling
regressions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_win(dt, width, by, msg)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_win_+3A_dt">dt</code></td>
<td>
<p>data.frame object.</p>
</td></tr>
<tr><td><code id="calc_win_+3A_width">width</code></td>
<td>
<p>numeric.</p>
</td></tr>
<tr><td><code id="calc_win_+3A_by">by</code></td>
<td>
<p>string.</p>
</td></tr>
<tr><td><code id="calc_win_+3A_msg">msg</code></td>
<td>
<p>string. Attach function name for message (usually auto_rate)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric
</p>

<hr>
<h2 id='class.val'>Validates acceptable classes of inputs
Set single or multiple inputs to TRUE. This is what the fn accepts.
If x is <em>any</em> one of these a single TRUE will be returned</h2><span id='topic+class.val'></span>

<h3>Description</h3>

<p>Validates acceptable classes of inputs
Set single or multiple inputs to TRUE. This is what the fn accepts.
If x is <em>any</em> one of these a single TRUE will be returned
</p>


<h3>Usage</h3>

<pre><code class='language-R'>class.val(
  x,
  int = FALSE,
  int.sing = FALSE,
  int.mult = FALSE,
  num = FALSE,
  num.sing = FALSE,
  num.mult = FALSE,
  df = FALSE,
  cr = FALSE,
  cr.sing = FALSE,
  cr.mult = FALSE,
  cr.int = FALSE,
  cr.int.sing = FALSE,
  cr.int.mult = FALSE,
  ar = FALSE,
  ar.sing = FALSE,
  ar.mult = FALSE,
  ar.int = FALSE,
  ar.int.sing = FALSE,
  ar.int.mult = FALSE,
  crbg = FALSE,
  crbg.sing = FALSE,
  crbg.mult = FALSE,
  cnvr = FALSE,
  cnvr.sing = FALSE,
  cnvr.mult = FALSE,
  cnvr.ft = FALSE,
  cnvr.ft.sing = FALSE,
  cnvr.ft.mult = FALSE,
  insp = FALSE
)
</code></pre>

<hr>
<h2 id='convert_DO'>Convert between units of dissolved oxygen</h2><span id='topic+convert_DO'></span>

<h3>Description</h3>

<p>This is a conversion function that performs conversions between concentration
and pressure units of dissolved oxygen (DO).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_DO(
  x,
  from = NULL,
  to = NULL,
  S = NULL,
  t = NULL,
  P = NULL,
  simplify = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert_DO_+3A_x">x</code></td>
<td>
<p>numeric. The dissolved oxygen (DO) value(s) to be converted.</p>
</td></tr>
<tr><td><code id="convert_DO_+3A_from">from</code></td>
<td>
<p>string. The DO unit to convert <em>from</em>. See <code><a href="#topic+unit_args">unit_args()</a></code> for
details.</p>
</td></tr>
<tr><td><code id="convert_DO_+3A_to">to</code></td>
<td>
<p>string. The DO unit to convert <em>to</em>. See <code><a href="#topic+unit_args">unit_args()</a></code> for details.</p>
</td></tr>
<tr><td><code id="convert_DO_+3A_s">S</code></td>
<td>
<p>numeric. Salinity (ppt). Defaults to NULL. Required for conversion
of some units. See <code><a href="#topic+unit_args">unit_args()</a></code> for details.</p>
</td></tr>
<tr><td><code id="convert_DO_+3A_t">t</code></td>
<td>
<p>numeric. Temperature(°C). Defaults to NULL. Required for conversion
of some units. See <code><a href="#topic+unit_args">unit_args()</a></code> for details.</p>
</td></tr>
<tr><td><code id="convert_DO_+3A_p">P</code></td>
<td>
<p>numeric. Pressure (bar). Defaults to 1.013253. Required for
conversion of some units. See <code><a href="#topic+unit_args">unit_args()</a></code> for details.</p>
</td></tr>
<tr><td><code id="convert_DO_+3A_simplify">simplify</code></td>
<td>
<p>logical. Defaults to <code>TRUE</code> in which case the converted
values are returned as a numeric vector. if <code>FALSE</code> a list object of class
<code>convert_DO</code> is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses a fuzzy string matching algorithm to accept various unit
formatting styles. For example, <code>"mg/l"</code>, <code>"mg/L"</code>, <code>"mgL-1"</code>, <code>"mg l-1"</code>,
<code>"mg.l-1"</code> are all parsed the same. See <code style="white-space: pre;">&#8288;[unit_args()]&#8288;</code> for details of
accepted units.
</p>
<p>Oxygen concentration units should use SI units (<code>L</code> or <code>kg</code>) for the
denominator.
</p>
<p>Some DO units require temperature (<code>t</code>), salinity (<code>S</code>), and atmospheric
pressure (<code>P</code>) to be specified; if this is the case the function will stop
and prompt for them. For the atmospheric pressure input (P), a default value
of 1.013 bar (standard pressure at sea level) is applied if not otherwise
entered. For freshwater experiments, salinity should be set to zero (i.e. <code>S = 0</code>).
</p>


<h4>S3 Generic Functions</h4>

<p>Saved output objects (if <code>simplify = FALSE</code> is used) can be entered in the
generic S3 functions <code>print()</code> and <code>summary()</code>.
</p>

<ul>
<li> <p><code>print()</code>: prints input and converted values (up to first 20), plus input
and output units.
</p>
</li>
<li> <p><code>summary()</code>: simple wrapper for <code>print()</code> function. See above.
</p>
</li></ul>




<h3>Value</h3>

<p>By default (<code>simplify = TRUE</code>) the output is a numeric vector of
converted values. If <code>simplify = FALSE</code> output is a <code>list</code> object of class
<code>convert_DO</code> containing five elements: <code style="white-space: pre;">&#8288;$call&#8288;</code> the function call, <code style="white-space: pre;">&#8288;$input&#8288;</code>
values, <code style="white-space: pre;">&#8288;$output&#8288;</code> converted values, <code style="white-space: pre;">&#8288;$input.unit&#8288;</code> and <code style="white-space: pre;">&#8288;$output.unit&#8288;</code>.
</p>


<h4>More</h4>

<p>For additional help, documentation, vignettes, and more visit the <code>respR</code>
website at <a href="https://januarharianto.github.io/respR/">https://januarharianto.github.io/respR/</a>
</p>



<h3>Examples</h3>

<pre><code class='language-R'># Convert a numeric value to units which do not require t, S and P
convert_DO(8.21, from = "mg/L", to = "umol/L")

# Convert a numeric value to units which require t, S and P
convert_DO(100, from = "%Air", to = "mg L-1", S = 33, t = 18)
convert_DO(214, from = "hPa", to = "mL/kg", S = 33, t = 18)

# Convert a vector of values
convert_DO(urchins.rd[[5]], from = "mg/L", to = "umol/L")
convert_DO(c(8.01, 8.03, 8.05), from = "mg per litre", to = "%Air",
  t = 15, S = 35)
convert_DO(sardine.rd[[2]], from = "%Air", to = "torr",
  t = 15, S = 35)
</code></pre>

<hr>
<h2 id='convert_MR'>Convert between units of absolute, mass-specific, or area-specific metabolic
rates</h2><span id='topic+convert_MR'></span>

<h3>Description</h3>

<p>Converts metabolic rates to a different unit. These can be absolute rates
(i.e. whole chamber or whole specimen e.g. <code>mg/h</code>), mass-specific rates (i.e.
normalised by specimen mass  e.g. <code>mg/h/kg</code>), or area-specific rates (i.e.
normalised by specimen surface area e.g. <code>mg/h/cm2</code>). Input rates can be a
numeric value or vector, in which case the converted rates are output as a
numeric of the same length in the new units. Alternatively, input can be an
object of class <code>convert_rate()</code> or <code>convert_rate.ft()</code>, in which case a new
<code>convert_rate</code> or <code>convert_rate.ft</code> object is returned with all rates in the
<code style="white-space: pre;">&#8288;$summary&#8288;</code> and other elements converted to the new units. This allows you to
convert results of analyses to a different unit without having to repeat the
entire analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_MR(
  x,
  from = NULL,
  to = NULL,
  S = NULL,
  t = NULL,
  P = NULL,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert_MR_+3A_x">x</code></td>
<td>
<p>numeric value or vector, or object of class <code>convert_rate</code> or
<code>convert_rate.ft</code>. Contains the rate(s) to be converted.</p>
</td></tr>
<tr><td><code id="convert_MR_+3A_from">from</code></td>
<td>
<p>string. The unit of the input metabolic rate(s). Should be in the
correct order: Oxygen/Time, Oxygen/Time/Mass or Oxygen/Time/Area. If <code>x</code> is
a <code>convert_rate</code> or <code>convert_rate.ft</code> object this is extracted
automatically and any input specified via <code>from</code> is ignored.</p>
</td></tr>
<tr><td><code id="convert_MR_+3A_to">to</code></td>
<td>
<p>string. The unit to convert the metabolic rate(s) to. Should be in
the correct order: Oxygen/Time, Oxygen/Time/Mass or Oxygen/Time/Area. See
<code>unit_args()</code>.</p>
</td></tr>
<tr><td><code id="convert_MR_+3A_s">S</code></td>
<td>
<p>numeric. Salinity (ppt). Defaults to NULL. Used in conversion of
some oxygen units. Freshwater should be entered as <code>S = 0</code>. If <code>x</code> is a
<code>convert_rate</code> or <code>convert_rate.ft</code> object this is extracted automatically
if present and any other input ignored.</p>
</td></tr>
<tr><td><code id="convert_MR_+3A_t">t</code></td>
<td>
<p>numeric. Temperature(°C). Defaults to NULL. Used in conversion of
some oxygen units. If <code>x</code> is a <code>convert_rate</code> or <code>convert_rate.ft</code> object
this is extracted automatically if present and any other input ignored.</p>
</td></tr>
<tr><td><code id="convert_MR_+3A_p">P</code></td>
<td>
<p>numeric. Pressure (bar). Used in conversion of some oxygen units.
Defaults to a standard value of 1.013253 bar. If <code>x</code> is a <code>convert_rate</code> or
<code>convert_rate.ft</code> object this is extracted automatically if present and any
other input ignored.</p>
</td></tr>
<tr><td><code id="convert_MR_+3A_quiet">quiet</code></td>
<td>
<p>logical. Suppresses the summary of the converted rates printed
to the console. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Units</h4>

<p>Units are specified using <code>from</code> and <code>to</code>. These should be in the sequence
<em>Oxygen-Time</em> (e.g. <code>"mg/h"</code>) for absolute rates, <em>Oxygen-Time-Mass</em> (e.g.
<code>"mg/h/kg"</code>) for mass-specific rates, and <em>Oxygen-Time-Area</em> (e.g.
<code>"mg/h/cm2"</code>) for surface area-specific rates. If <code>x</code> is a <code>convert_rate</code> or
<code>convert_rate.ft</code> object the <code>from</code> unit is extracted automatically.
</p>
<p>A fuzzy string matching algorithm is used to accept various unit formatting
styles. For example, <code>"mg/h"</code>, <code>"mg/H"</code>, <code>"mg hr-1"</code>, <code>"milligram per hour"</code>
are all parsed the same. See <code>unit_args()</code> for details of accepted units and
their formatting.
</p>
<p>Note some units require salinity (<code>S</code>) and temperature (<code>t</code>) to perform the
conversion. For freshwater experiments, salinity should be entered as zero
(i.e. <code>S = 0</code>). These conversions also require the atmospheric pressure
(<code>P</code>). If not entered the default value of 1.013253 bar (standard pressure at
sea level) is used. If <code>x</code> is a <code>convert_rate</code> or <code>convert_rate.ft</code> object,
<code>S</code>, <code>t</code>, and <code>P</code> are extracted automatically if they are present (they may
not be if the original rate conversion did not require them). They are also
saved to the <code style="white-space: pre;">&#8288;$inputs&#8288;</code> element of the output object.
</p>



<h4>More details</h4>

<p>For <code>convert_rate</code> or <code>convert_rate.ft</code> inputs the primary <code style="white-space: pre;">&#8288;$rate.output&#8288;</code>
element is converted to the new unit and the <code style="white-space: pre;">&#8288;$output.unit&#8288;</code> also updated to
this new unit. These columns are also updated in the <code style="white-space: pre;">&#8288;$summary&#8288;</code> table, and in
addition the <code>rate.abs</code> column and, if relevant, the <code>rate.m.spec</code> or
<code>rate.a.spec</code> column. Note, the <code style="white-space: pre;">&#8288;$call&#8288;</code> element is updated to the
<code>convert_MR</code> call and the original call to <code>convert_rate</code> or
<code>convert_rate.ft</code> replaced. The <code style="white-space: pre;">&#8288;$inputs&#8288;</code> element will still contain the
original inputs, with the <code>output.unit</code> updated to the new <code>to</code> unit. In
addition <code>S</code>, <code>t</code>, and <code>P</code> are added if they weren't already present.
</p>



<h4>More</h4>

<p>For additional help, documentation, vignettes, and more visit the <code>respR</code>
website at <a href="https://januarharianto.github.io/respR/">https://januarharianto.github.io/respR/</a>
</p>



<h3>Value</h3>

<p>If the <code>x</code> input rates are a numeric value or vector, output is a
numeric value or vector of the same length. If <code>x</code> is a <code>convert_rate</code> or
<code>convert_rate.ft</code> object, output is a new <code>convert_rate</code> or
<code>convert_rate.ft</code> object with all rates in the <code style="white-space: pre;">&#8288;$summary&#8288;</code> table,
<code style="white-space: pre;">&#8288;$rate.output&#8288;</code> and <code style="white-space: pre;">&#8288;$output.unit&#8288;</code> elements converted to the new units. This
allows you to convert results of analyses to a different unit without
having to repeat the entire analysis.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Convert a numeric absolute rate to a different unit
convert_MR(-0.09, from = 'mg/min', to = 'umol/hr')

# Convert a vector of absolute rates to a different unit
convert_MR(c(-0.090, -0.081, -0.098),
           from = 'mg/min', to = 'umol/hr')

# Convert to a unit which requires S, t, &amp; P
convert_MR(-0.09, from = 'mg/min', to = 'ml/hour',
           S = 0, t = 20, P = 1.01)

# Convert mass-specific rates
convert_MR(-0.09, from = 'mg/min/g', to = 'ml/hour/kg',
           S = 0, t = 20, P = 1.01)

# Convert area-specific rates
convert_MR(-0.09, from = 'mg/min/mm2', to = 'ml/hour/cm2',
           S = 0, t = 20, P = 1.01)

# Convert from units largely only used in older papers.
# E.g. cubic cm (e.g. Tang 1933, Head 1962)
convert_MR(0.1, from = 'cc/hr/gm', to = 'mg/hr/g',
           S = 30, t = 20, P = 1.01)
convert_MR(0.6, from = 'cm3/hr', to = 'mg/hr',
           S = 28, t = 12, P = 1.01)
# uL (e.g. Zeuthen 1953, Newell &amp; Northcroft 1967)
convert_MR(400, from = 'ul/hr', to = 'mg/hr',
           S = 30, t = 15, P = 1.01)
convert_MR(0.5, from = 'ul/hr/mg', to = 'mg/hr/g',
           S = 0, t = 20, P = 1.01)
# mm3 (e.g. Newell &amp; Roy 1973)
convert_MR(1.5, from = 'mm3/hr', to = 'mg/hr',
           S = 30, t = 15, P = 1.01)

# Convert rates in a 'convert_rate' object. This avoids having to repeat
# an entire analysis to see the output in different units.

# Make a convert_rate object
cnv_rt.obj &lt;- urchins.rd %&gt;%
  auto_rate() %&gt;%
  convert_rate(oxy.unit = "mg/L",
               time.unit = "min",
               output.unit = "mg/hr/kg",
               volume = 1,
               mass = 0.05)

# Now convert all results to "umol/min/g".
# The 'from' units are identified automatically from the object.
cnv_rt.obj.new &lt;- convert_MR(cnv_rt.obj,
                             to = "umol/min/g")

# Compare the two:
summary(cnv_rt.obj)
summary(cnv_rt.obj.new)
</code></pre>

<hr>
<h2 id='convert_MR_print'>Print results of convert_MR</h2><span id='topic+convert_MR_print'></span>

<h3>Description</h3>

<p>Print results of convert_MR
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_MR_print(oldrates, newrates, from, to, input_class)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert_MR_print_+3A_oldrates">oldrates</code></td>
<td>
<p>The original rates</p>
</td></tr>
<tr><td><code id="convert_MR_print_+3A_newrates">newrates</code></td>
<td>
<p>The converted rates</p>
</td></tr>
<tr><td><code id="convert_MR_print_+3A_from">from</code></td>
<td>
<p>The original unit</p>
</td></tr>
<tr><td><code id="convert_MR_print_+3A_to">to</code></td>
<td>
<p>The converted unit</p>
</td></tr>
<tr><td><code id="convert_MR_print_+3A_input_class">input_class</code></td>
<td>
<p>Class of the input (numeric, convert_rate, convert_rate.ft)</p>
</td></tr>
</table>

<hr>
<h2 id='convert_rate'>Convert a unitless oxygen rate value to absolute, mass-specific or
area-specific rate</h2><span id='topic+convert_rate'></span>

<h3>Description</h3>

<p>Converts a unitless rate derived from <code><a href="#topic+calc_rate">calc_rate()</a></code>, <code><a href="#topic+calc_rate.int">calc_rate.int()</a></code>,
<code><a href="#topic+auto_rate">auto_rate()</a></code>, <code><a href="#topic+auto_rate.int">auto_rate.int()</a></code>, <code><a href="#topic+adjust_rate">adjust_rate()</a></code>, or
<code><a href="#topic+calc_rate.bg">calc_rate.bg()</a></code> into an absolute rate (i.e. whole chamber or whole
specimen), or mass-specific rate (i.e. normalised by specimen mass), or
area-specific rate (i.e. normalised by specimen surface area) in any common
unit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_rate(
  x,
  oxy.unit = NULL,
  time.unit = NULL,
  output.unit = NULL,
  volume = NULL,
  mass = NULL,
  area = NULL,
  S = NULL,
  t = NULL,
  P = NULL,
  plot = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert_rate_+3A_x">x</code></td>
<td>
<p>numeric value or vector, or object of class <code>calc_rate</code>,
<code>calc_rate.int</code>, <code>auto_rate</code>, <code>auto_rate.int</code>, <code>adjust_rate</code>, or
<code>calc_rate.bg.</code> Contains the rate(s) to be converted.</p>
</td></tr>
<tr><td><code id="convert_rate_+3A_oxy.unit">oxy.unit</code></td>
<td>
<p>string. The dissolved oxygen unit of the original raw data
used to determine the rates in <code>x</code>.</p>
</td></tr>
<tr><td><code id="convert_rate_+3A_time.unit">time.unit</code></td>
<td>
<p>string. The time unit of the original raw data used to
determine the rates in <code>x</code>.</p>
</td></tr>
<tr><td><code id="convert_rate_+3A_output.unit">output.unit</code></td>
<td>
<p>string. The output units to convert the input rates to.
Should be in the correct order: &quot;Oxygen/Time&quot; or &quot;Oxygen/Time/Mass&quot; or
&quot;Oxygen/Time/Area&quot;.</p>
</td></tr>
<tr><td><code id="convert_rate_+3A_volume">volume</code></td>
<td>
<p>numeric. Volume of water in <em><strong>litres</strong></em> in the respirometer or
respirometer loop.</p>
</td></tr>
<tr><td><code id="convert_rate_+3A_mass">mass</code></td>
<td>
<p>numeric. Mass/weight in <em><strong>kg</strong></em>. This is the mass of the
specimen if you wish to calculate mass-specific rates.</p>
</td></tr>
<tr><td><code id="convert_rate_+3A_area">area</code></td>
<td>
<p>numeric. Surface area in <em><strong>m^2</strong></em>. This is the surface area of
the specimen if you wish to calculate surface area-specific rates.</p>
</td></tr>
<tr><td><code id="convert_rate_+3A_s">S</code></td>
<td>
<p>numeric. Salinity (ppt). Defaults to NULL. Used in conversion of
some oxygen units. Freshwater should be entered as <code>S = 0</code>.</p>
</td></tr>
<tr><td><code id="convert_rate_+3A_t">t</code></td>
<td>
<p>numeric. Temperature(°C). Defaults to NULL. Used in conversion of
some oxygen units.</p>
</td></tr>
<tr><td><code id="convert_rate_+3A_p">P</code></td>
<td>
<p>numeric. Pressure (bar). Used in conversion of some oxygen units.
Defaults to a standard value of 1.013253 bar.</p>
</td></tr>
<tr><td><code id="convert_rate_+3A_plot">plot</code></td>
<td>
<p>logical. Default is <code>FALSE</code>. Controls if a plot is produced. See
Plot section.</p>
</td></tr>
<tr><td><code id="convert_rate_+3A_...">...</code></td>
<td>
<p>Allows additional plotting controls to be passed. See Plot
section.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, <code>convert_rate</code> converts the primary <code style="white-space: pre;">&#8288;$rate&#8288;</code> element from
<code>calc_rate</code>, <code>calc_rate.int</code>, <code>auto_rate</code> and , <code>auto_rate.int</code> objects, the
<code style="white-space: pre;">&#8288;$rate.adjusted&#8288;</code> from <code>adjust_rate</code> objects, and the <code style="white-space: pre;">&#8288;$rate.bg&#8288;</code> from
<code>calc_rate.bg</code> objects. Additionally, any numeric value or vector of rates
can be input as <code>x</code>.
</p>


<h4>Respirometer volume</h4>

<p>The <code>volume</code> of the respirometer is required and should be in litres (<code>L</code>).
Note, the <code>volume</code> represents the <em>effective volume</em> of the respirometer,
that is <em>volume of water</em> in the respirometry chamber. This is not
necessarily the same as the volume of the respirometer. Typically, it is the
volume of the respirometer <em>minus</em> the volume of the specimen.
<a href="https://github.com/nicholascarey/respfun#eff_vol">See here</a> for help
with calculating effective volumes. It also does not refer to the specimen
volume.
</p>



<h4>Units</h4>

<p>The <code>oxy.unit</code> of the original raw data used to calculate the rate is
required. Concentration units should use only SI units (<code>L</code> or <code>kg</code>) for the
denominator, e.g. <code>"mg/L"</code>, <code>"mmol/kg"</code>. Percentage saturation of air
(<code style="white-space: pre;">&#8288;%Air&#8288;</code>) or oxygen (<code style="white-space: pre;">&#8288;%Oxy&#8288;</code>) is supported, as are oxygen pressure units. See
<code><a href="#topic+unit_args">unit_args()</a></code> for details.
</p>
<p>The <code>time.unit</code> of the original raw data used to calculate the rate is also
required (seconds, minutes, hours, or days).
</p>
<p>An <code>output.unit</code> is also required and must be in the sequence <em>Oxygen-Time</em>
(e.g. <code>"mg/h"</code>) for absolute rates, <em>Oxygen-Time-Mass</em> (e.g. <code>"mg/h/kg"</code>) for
mass-specific rates, and <em>Oxygen-Time-Area</em> (e.g. <code>"mg/h/cm2"</code>) for surface
area-specific rates. If left <code>NULL</code>, the default of <code>"mgO2/h"</code> is used, or
<code>"mgO2/h/kg"</code> or <code>"mgO2/h/m2"</code> if a <code>mass</code> or <code>area</code> respectively has been
entered.
</p>
<p>Note, some oxygen input or output units require temperature (<code>t</code>) and
salinity (<code>S</code>) to perform conversions. For freshwater experiments, salinity
should be entered as zero (i.e. <code>S = 0</code>).
</p>
<p>Strictly speaking, the atmospheric pressure (<code>P</code>) should also be entered. If
not, the default value of 1.013253 bar (standard pressure at sea level) is
used. In most locations which have a normal range of around 20 millibars
(outside of extreme weather events), any variability in pressure will have a
relatively minor effect on dissolved oxygen, and even less on calculated
rates. However, we would encourage users to enter the actual value if they
know it, or use historical weather data to find out what it was on the day.
See <code><a href="#topic+unit_args">unit_args()</a></code> for details.
</p>
<p>The function uses an internal database and a fuzzy string matching algorithm
to accept various unit formatting styles. For example, <code>"mg/l"</code>, <code>"mg/L"</code>,
<code>"mgL-1"</code>, <code>"mg l-1"</code>, <code>"mg.l-1"</code> are all parsed the same. See
<code><a href="#topic+unit_args">unit_args()</a></code> for details of accepted units and their formatting. See also
<code><a href="#topic+convert_val">convert_val()</a></code> for simple conversion between non-oxygen units.
</p>



<h4>Plot</h4>

<p>Plotting provides three ways of visualising the rates (or a selection of them
using <code>pos</code>), chosen using <code>type</code>. The default is <code>plot = FALSE</code> to prevent
plots being produced for every single conversion.
</p>
<p><code>type = "full"</code> (the default) plots a grid of up to 20 plots with each rate
highlighted on the full dataset, with the rate value in the title. Values on
the axes - time (bottom), row (top), and oxygen (left) - are in the units of
the original raw data. Rates are plotted in order of how they appear in the
summary table up to the first 20 rows, unless different rows have been
specified via <code>pos</code>.
</p>
<p><code>type = "rate"</code> plots the entire data timeseries on the upper plot, and on
the lower plot the output rate values in the chosen output units. Each rate
is plotted against the middle of the region used to determine it. <code>pos</code> can
be used to select a range of rates (i.e. summary table rows) to show in the
lower plot (default is all).
</p>
<p><code>type = "overlap"</code> visualises where regression results in the summary table
occur in relation to the original dataset to help understand how they are
distributed or may overlap, and is particularly useful for results from the
<code>auto_rate</code> <code>linear</code> method. The top plot is the entire data timeseries, the
bottom plot the region of the data each rate regression has been fit over.
The y-axis represents the position (i.e. row) of each in the summary table
descending from top to bottom. If no reordering or selection has been
performed, this will usually be equivalent to the <code style="white-space: pre;">&#8288;$rank&#8288;</code> column, but note as
reordering or selection is performed rank and summary table position will not
necessarily be equivalent. One result (summary table row) can be highlighted,
the default being <code>highlight = 1</code>. <code>pos</code> can be used to select a range of
summary rows to plot in the lower overlap plot.
</p>
<p>Other options:
</p>
<p><code>legend = FALSE</code> will suppress plot labels, <code>pos</code> selects summary rates to
plot, <code>quiet</code> suppresses console messages.
</p>



<h4>S3 Generic Functions</h4>

<p>Saved output objects can be used in the generic S3 functions <code>print()</code>,
<code>summary()</code>, and <code>mean()</code>.
</p>

<ul>
<li> <p><code>print()</code>: prints a single result, by default the first converted rate.
Others can be printed by passing the <code>pos</code> input. e.g. <code>print(x, pos = 2)</code>
</p>
</li>
<li> <p><code>summary()</code>: prints the output <code style="white-space: pre;">&#8288;$summary&#8288;</code> table of converted rates and
metadata. Specific rows can be specified with the <code>pos</code> input. e.g.
<code>summary(x, pos = 1:5)</code>. This can be exported as a separate data frame by
passing <code>export = TRUE</code> and includes all rate regression parameters, and data
locations, adjustments if applied, units, and more. The <code style="white-space: pre;">&#8288;$rep&#8288;</code> and <code style="white-space: pre;">&#8288;$rank&#8288;</code>
columns requires special notice depending on the type of experiment you have
analysed or the function you used to determine the rates. For the <code style="white-space: pre;">&#8288;$rank&#8288;</code>
column if <code>calc_rate</code> was used, it is the order of rates as entered using
<code>from</code> and <code>to</code> (if multiple rates were determined). For <code>auto_rate</code> it
relates to the <code>method</code> input, for example it indicates kernel density
ranking if the <code>linear</code> method was used, or ordering by rate value if
<code>lowest</code> or <code>highest</code> were used. For intermittent-flow experiments analysed
via <code>calc_rate.int</code> or <code>auto_rate.int</code> it indicates the ranking <em>within</em> each
replicate as seen in the <code style="white-space: pre;">&#8288;$rep&#8288;</code> column. Note that if <code>select_rate</code> has been
used the rows in the summary table may have been reordered, including the
<code style="white-space: pre;">&#8288;$rep&#8288;</code> and <code style="white-space: pre;">&#8288;$rank&#8288;</code> columns. The <em>original</em> rep and rank for each row is
retained if reordering occurred.
</p>
</li>
<li> <p><code>mean()</code>: calculates the mean of all converted rates, or those specified by
the <code>pos</code> input. e.g. <code>mean(x, pos = 1:5)</code> The mean can be exported as a
separate value by passing <code>export = TRUE</code>.
</p>
</li></ul>




<h4>More</h4>

<p>For additional help, documentation, vignettes, and more visit the <code>respR</code>
website at <a href="https://januarharianto.github.io/respR/">https://januarharianto.github.io/respR/</a>
</p>



<h3>Value</h3>

<p>Output is a <code>list</code> object of class <code>convert_rate</code> containing the
<code style="white-space: pre;">&#8288;$rate.input&#8288;</code>, and converted rate(s) in <code style="white-space: pre;">&#8288;$rate.output&#8288;</code> in the
<code style="white-space: pre;">&#8288;$output.unit&#8288;</code>, as well as inputs and summary elements. Note, <code style="white-space: pre;">&#8288;$rate.abs&#8288;</code>
is the <em>absolute</em> rate in the output unit minus the mass- or area-specific
component. The <code style="white-space: pre;">&#8288;$summary&#8288;</code> table element contains all rate regression
parameters and data locations (depending on what class of object was
entered), adjustments (if applied), units, and more. The <code style="white-space: pre;">&#8288;$rep&#8288;</code> and <code style="white-space: pre;">&#8288;$rank&#8288;</code>
columns require special notice depending on the type of experiment you have
analysed or the function you used to determine the rates. See the summary
table description in <strong>S3 Generic Functions</strong> section above.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Convert a single numeric rate to an absolute rate
convert_rate(0.09, oxy.unit = 'mg/l', time.unit = 's',
  output.unit = 'mg/min', volume = 1.2)

# Convert a single numeric rate to a mass-specific rate
convert_rate(0.09, oxy.unit = 'mg/l', time.unit = 's',
  output.unit = 'mg/min/kg', volume = 1.2, mass = 0.5)

# Convert a single numeric rate to an area-specific rate
convert_rate(0.09, oxy.unit = 'mg/l', time.unit = 's',
  output.unit = 'mg/min/cm2', volume = 1.2, area = 0.0002)

# Convert a single rate derived via calc_rate to mass-specific
x &lt;- calc_rate(sardine.rd, from = 200, to = 1800, by = "time")
convert_rate(x, oxy.unit = '%Air', time.unit = 's',
  output.unit = 'mg/h/g', volume = 12.3, mass = 0.05,
  S =35, t = 15, P = 1.013)

# Convert multiple rates derived via auto_rate to area-specific
x &lt;- auto_rate(sardine.rd)
rates &lt;- convert_rate(x, oxy.unit = '%Air', time.unit = 's',
  output.unit = 'mg/h/cm2', volume = 12.3, area = 0.00005,
  S =35, t = 15, P = 1.013)
summary(rates)

</code></pre>

<hr>
<h2 id='convert_rate.ft'>Convert a unitless oxygen rate value from flowthrough respirometry to
absolute, mass-specific or area-specific rates</h2><span id='topic+convert_rate.ft'></span>

<h3>Description</h3>

<p><code>convert_rate.ft</code> converts a unitless rate derived from <code><a href="#topic+calc_rate.ft">calc_rate.ft()</a></code> or
<code><a href="#topic+adjust_rate.ft">adjust_rate.ft()</a></code> into an absolute rate (i.e. whole specimen or whole
chamber), mass-specific rate (i.e. normalised by specimen mass), or
area-specific rate (i.e. normalised by specimen surface area) in any common
unit. These should be rates calculated as an oxygen delta (inflow minus
outflow oxygen) multiplied by the flowrate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_rate.ft(
  x,
  oxy.unit = NULL,
  flowrate.unit = NULL,
  output.unit = NULL,
  mass = NULL,
  area = NULL,
  S = NULL,
  t = NULL,
  P = 1.013253,
  plot = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert_rate.ft_+3A_x">x</code></td>
<td>
<p>numeric value or vector, or object of class <code><a href="#topic+calc_rate.ft">calc_rate.ft()</a></code> or
<code><a href="#topic+adjust_rate.ft">adjust_rate.ft()</a></code>. Contains the rate(s) to be converted.</p>
</td></tr>
<tr><td><code id="convert_rate.ft_+3A_oxy.unit">oxy.unit</code></td>
<td>
<p>string. The dissolved oxygen units of the original raw data
used to determine the rate in <code>x</code>.</p>
</td></tr>
<tr><td><code id="convert_rate.ft_+3A_flowrate.unit">flowrate.unit</code></td>
<td>
<p>string. The units of the flowrate through the
respirometer. See Details.</p>
</td></tr>
<tr><td><code id="convert_rate.ft_+3A_output.unit">output.unit</code></td>
<td>
<p>string. The output unit to convert the input rate to.
Should be in the correct order: &quot;Oxygen/Time&quot; or &quot;Oxygen/Time/Mass&quot; or
&quot;Oxygen/Time/Area&quot;.</p>
</td></tr>
<tr><td><code id="convert_rate.ft_+3A_mass">mass</code></td>
<td>
<p>numeric. Mass/weight in <strong>kg</strong>. This is the mass of the specimen
if you wish to calculate mass-specific rates.</p>
</td></tr>
<tr><td><code id="convert_rate.ft_+3A_area">area</code></td>
<td>
<p>numeric. Surface area in <strong>m^2</strong>. This is the surface area of the
specimen if you wish to calculate surface area-specific rates.</p>
</td></tr>
<tr><td><code id="convert_rate.ft_+3A_s">S</code></td>
<td>
<p>numeric. Salinity (ppt). Defaults to NULL. Used in conversion of
some oxygen units. Fresh water should be entered as <code>S = 0</code>.</p>
</td></tr>
<tr><td><code id="convert_rate.ft_+3A_t">t</code></td>
<td>
<p>numeric. Temperature(°C). Defaults to NULL. Used in conversion of
some oxygen units.</p>
</td></tr>
<tr><td><code id="convert_rate.ft_+3A_p">P</code></td>
<td>
<p>numeric. Pressure (bar). Used in conversion of some oxygen units.
Defaults to a standard value of 1.013253 bar.</p>
</td></tr>
<tr><td><code id="convert_rate.ft_+3A_plot">plot</code></td>
<td>
<p>logical. Default is <code>FALSE</code>. Controls if a plot is produced. See
Plot section.</p>
</td></tr>
<tr><td><code id="convert_rate.ft_+3A_...">...</code></td>
<td>
<p>Allows additional plotting controls to be passed. See Plot
section.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, <code>convert_rate.ft</code> converts the <code style="white-space: pre;">&#8288;$rate&#8288;</code> element from
<code>calc_rate.ft</code> objects, or the <code style="white-space: pre;">&#8288;$rate.adjusted&#8288;</code> element from <code>adjust_rate.ft</code>
objects if these are entered as the <code>x</code> input. Alternatively, a numeric value
or vector of rates can be input as <code>x</code>.
</p>


<h4>Units</h4>

<p>The <code>oxy.unit</code> of the original raw data used to calculated the rate is
required. Concentration units should use only SI units (<code>L</code> or <code>kg</code>) for the
denominator, e.g. <code>"mg/L"</code>, <code>"mmol/kg"</code>. Percentage saturation of air or
oxygen is accepted, as are oxygen pressure units. See <code><a href="#topic+unit_args">unit_args()</a></code> for
details.
</p>
<p>An <code>output.unit</code> is also required. If left <code>NULL</code>, The default of <code>"mgO2/h"</code>
is used, or <code>"mgO2/h/kg"</code> or <code>"mgO2/h/m2"</code> if a <code>mass</code> or <code>area</code> respectively
has been entered. The <code>output.unit</code> must be in the sequence <em>Oxygen-Time</em>
(e.g. <code>"mg/h"</code>) for absolute rates, <em>Oxygen-Time-Mass</em> (e.g. <code>"mg/h/kg"</code>) for
mass-specific rates, and <em>Oxygen-Time-Area</em> (e.g. <code>"mg/h/cm2"</code>) for surface
area-specific rates.
</p>
<p>Note, some oxygen input or output units require temperature (<code>t</code>) and
salinity (<code>S</code>) to perform conversions. For freshwater experiments, salinity
should be entered as zero (i.e. <code>S = 0</code>).
</p>
<p>Strictly speaking the atmospheric pressure (<code>P</code>) should also be supplied. If
not, the default value of 1.013253 bar (standard pressure at sea level) is
used. In most locations which have a normal range (outside extreme weather
events) of around 20 millibars, any variability in pressure will have a
relatively minor effect on dissolved oxygen, and even less on calculated
rates. However, we would encourage users to enter the actual value if they
know it, or use historical weather data to find out what it was on the day.
See <code><a href="#topic+unit_args">unit_args()</a></code> for details.
</p>
<p>The <code>flowrate.unit</code> is required and should be the units of the <code>flowrate</code>
used in <code>calc_rate.ft</code> to calculate the rate, and should be in the form of
volume (L, ml, or ul) per unit time (s,m,h,d), for example in <code>"L/s"</code>. Note,
the volume component does <em>NOT</em> represent the volume of the respirometer, and
the time component does <em>NOT</em> represent the units or recording interval of
the original raw data.
</p>
<p>The function uses a fuzzy string matching algorithm to accept various unit
formatting styles. For example, <code>"mg/l"</code>, <code>"mg/L"</code>, <code>"mgL-1"</code>, <code>"mg l-1"</code>,
<code>"mg.l-1"</code> are all parsed the same. See <code><a href="#topic+unit_args">unit_args()</a></code> for details of
accepted units and their formatting. See also <code><a href="#topic+convert_val">convert_val()</a></code> for simple
conversion between non-oxygen units.
</p>



<h4>Plot</h4>

<p>Plotting provides three ways of visualising converted rates (or a selection
of them using <code>pos</code>), chosen using <code>type</code>. This is mostly useful only if you
have extracted multiple rates (see <code>calc_rate.ft()</code>). The default is <code>plot = FALSE</code> to prevent plots being produced for every single conversion.
<code>convert_rate.ft</code> objects can only be plotted if and <code>inspect.ft</code> object was
used as the input in <code>calc_rate.ft</code>. In other words, converted rates from
numeric inputs cannot be plotted.
</p>
<p><code>type = "full"</code> (the default) plots a grid of up to 20 plots with each rate
(i.e. region of averaged delta values) highlighted on a plot of delta oxygen
values, with the converted rate value in the title. Values on the axes - time
(bottom), row (top), and oxygen delta (left) - are in the units of the
original raw data. Rates are plotted in order of how they appear in the
summary table up to the first 20 rows, unless different rows have been
specified via <code>pos</code>.
</p>
<p><code>type = "rate"</code> plots the entire data timeseries, that is the outflow and
inflow oxygen (if used) on the upper plot, with delta oxygen on the middle
plot or as the upper plot if delta oxygen values have been entered in
<code>inspect.ft</code>. The lower plot is the output rate values in the chosen output
units. Each rate is plotted against the middle of the region used to
determine it (i.e. region of averaged delta values). <code>pos</code> can be used to
select a range of rates (i.e. summary table rows) to show in the lower plot
(default is all).
</p>
<p><code>type = "overlap"</code> visualises where regression results in the summary table
occur in relation to the original dataset to help understand how they are
distributed or may overlap. The top plot is the entire data timeseries, that
is the outflow and inflow oxygen (if used) on the upper plot, with delta
oxygen on the middle plot or as the upper plot if delta oxygen values have
been entered in <code>inspect.ft</code>. The bottom plot is the region of the data each
rate has been calculated over (i.e. region of averaged delta values). The
y-axis represents the position (i.e. row) of each in the summary table
descending from top to bottom. If no reordering or selection has been
performed, this will usually be equivalent to the <code style="white-space: pre;">&#8288;$rank&#8288;</code> column, but note as
reordering or selection is performed rank and summary table position will not
necessarily be equivalent. One result (summary table row) can be highlighted,
the default being <code>highlight = 1</code>. <code>pos</code> can be used to select a range of
summary rows to plot in the lower overlap plot.
</p>
<p>Other options:
</p>
<p><code>legend = FALSE</code> will suppress plot labels, <code>pos</code> selects summary rates to
plot, <code>quiet</code> suppresses console messages.
</p>



<h4>S3 Generic Functions</h4>

<p>Saved output objects can be used in the generic S3 functions <code>print()</code>,
<code>summary()</code>, and <code>mean()</code>.
</p>

<ul>
<li> <p><code>print()</code>: prints a single result, by default the first converted rate.
Others can be printed by passing the <code>pos</code> input. e.g. <code>print(x, pos = 2)</code>
</p>
</li>
<li> <p><code>summary()</code>: prints the output <code style="white-space: pre;">&#8288;$summary&#8288;</code> table of converted rates and
metadata. Specific rows can be specified with the <code>pos</code> input. e.g.
<code>summary(x, pos = 1:5)</code>. This can be exported as a separate data frame by
passing <code>export = TRUE</code>, and includes all rate parameters, data locations,
adjustments if applied, units, and more. Note, the summary table contains
linear regression coefficients alongside other metadata. These should not be
confused with those in other functions such as <code>calc_rate</code> where slopes
represent rates and coefficients such as a high r-squared are important.
Here, slope represents the stability of the data region, in that the closer
the slope is to zero, the less the delta oxygen values in that region vary,
which is an indication of a region of stable rates. They are included to
enable possible future functionality where stable regions may be
automatically identified, and should generally be ignored. However, advanced
users can use regular R syntax to explore and subset the results using these
if they wish.
</p>
</li>
<li> <p><code>mean()</code>: calculates the mean of all converted rates, or those specified by
the <code>pos</code> input. e.g. <code>mean(x, pos = 1:5)</code> The mean can be exported as a
separate value by passing <code>export = TRUE</code>.
</p>
</li></ul>




<h4>More</h4>

<p>For additional help, documentation, vignettes, and more visit the <code>respR</code>
website at <a href="https://januarharianto.github.io/respR/">https://januarharianto.github.io/respR/</a>
</p>



<h3>Value</h3>

<p>Output is a <code>list</code> object containing the <code style="white-space: pre;">&#8288;$rate.input&#8288;</code>, and converted
rate(s) in <code style="white-space: pre;">&#8288;$rate.output&#8288;</code> in the <code style="white-space: pre;">&#8288;$output.unit&#8288;</code>, as well as inputs and
summary elements. Note, <code style="white-space: pre;">&#8288;$rate.abs&#8288;</code> is the <em>absolute</em> rate in the output
unit minus the mass- or area-specific component. The <code style="white-space: pre;">&#8288;$summary&#8288;</code> table
element contains all rate parameters and data locations (depending on what
class of object was entered), adjustments (if applied), units, and more.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Convert a single numeric rate to an absolute rate
convert_rate.ft(-0.09, oxy.unit = 'mg/l', flowrate.unit = 'L/s',
                output.unit = 'mg/min')

# Convert a single numeric rate to a mass-specific rate
convert_rate.ft(-0.09, oxy.unit = 'mg/l', flowrate.unit = 'L/s',
                output.unit = 'mg/min/kg', mass = 0.5)

# Convert a single numeric rate to an area-specific rate
convert_rate.ft(-0.09, oxy.unit = 'mg/l', flowrate.unit = 'L/s',
                output.unit = 'mg/min/cm2', area = 0.0002)

# Full object-oriented workflow
# Inspect, calculate rate, adjust rate, and convert
# to a final mass-specific rate
inspect.ft(flowthrough_mult.rd,
           time = 1,
           out.oxy = 2,
           in.oxy = 6) %&gt;%
  calc_rate.ft(flowrate = 0.1,
               from = 30,
               to = 60,
               by = "time") %&gt;%
  adjust_rate.ft(by = -0.032) %&gt;%
  convert_rate.ft(oxy.unit = '%Air',
                  flowrate.unit = 'L/min',
                  output.unit = 'mg/h/g',
                  mass = 0.05,
                  S =35, t = 15, P = 1.013)
</code></pre>

<hr>
<h2 id='convert_val'>Convert values of temperature, volume, mass, area, and atmospheric pressure
to different units</h2><span id='topic+convert_val'></span>

<h3>Description</h3>

<p>This is a basic function that converts values of temperature, volume, mass,
area, and atmospheric pressure to different units. This can be useful in
<code><a href="#topic+convert_DO">convert_DO()</a></code>, <code><a href="#topic+convert_rate">convert_rate()</a></code>, and <code><a href="#topic+convert_rate.ft">convert_rate.ft()</a></code> where some inputs
must be in specific units (e.g. temperature in °C, atmospheric pressure in
bar, area in m2). See Examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_val(x, from = NULL, to = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert_val_+3A_x">x</code></td>
<td>
<p>numeric value or vector. Values to be converted to a different unit.</p>
</td></tr>
<tr><td><code id="convert_val_+3A_from">from</code></td>
<td>
<p>string. Unit of the original values.</p>
</td></tr>
<tr><td><code id="convert_val_+3A_to">to</code></td>
<td>
<p>string. Unit to be converted to. These defaults are applied if left
<code>NULL</code>: volume <code>"L"</code>, temperature <code>"C"</code>, mass <code>"kg"</code>, area <code>"m2"</code>, pressure
<code>"bar"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note the type of unit does not need to be specified. The function will
automatically recognise it using the <code>from</code> unit.
</p>
<p>If the <code>'to'</code> input is left <code>NULL</code>, the following defaults are applied
depending on the unit type of the <code>from</code> input:
</p>

<ul>
<li><p> volume:        <code>"L"</code>
</p>
</li>
<li><p> temperature:   <code>"C"</code>
</p>
</li>
<li><p> mass:          <code>"kg"</code>
</p>
</li>
<li><p> area:          <code>"m2"</code>
</p>
</li>
<li><p> pressure:      <code>"bar"</code>
</p>
</li></ul>

<p>A fuzzy string matching algorithm is used to accept different unit formatting
styles. For example, <code>"msq"</code> <code>"m2"</code>, <code>"M2"</code>, <code>"sqm"</code> are all parsed as metres
squared of area.
</p>


<h4>Accepted Units</h4>

<p><em>Temperature:</em>
</p>

<ul>
<li> <p><code>"C"</code>, <code>"K"</code>, <code>"F"</code>
</p>
</li></ul>

<p><em>Pressure:</em>
</p>

<ul>
<li> <p><code>"kPa"</code>, <code>"hPa"</code>, <code>"Pa"</code>, <code>"ubar"</code>, <code>"mbar"</code>, <code>"bar"</code>, <code>"Torr"</code>, <code>"atm"</code>
(note, this is standard atmospheres).
</p>
</li></ul>

<p><em>Volume:</em>
</p>

<ul>
<li> <p><code>"uL"</code>, <code>"mL"</code>, <code>"L"</code>
</p>
</li></ul>

<p><em>Mass:</em>
</p>

<ul>
<li> <p><code>"ug"</code>, <code>"mg"</code>, <code>"g"</code>, <code>"kg"</code>
</p>
</li></ul>

<p><em>Area:</em>
</p>

<ul>
<li> <p><code>"mm2"</code>, <code>"cm2"</code>, <code>"m2"</code>, <code>"km2"</code>
</p>
</li></ul>




<h4>More</h4>

<p>For additional help, documentation, vignettes, and more visit the <code>respR</code>
website at <a href="https://januarharianto.github.io/respR/">https://januarharianto.github.io/respR/</a>
</p>



<h3>Value</h3>

<p>Output is a numeric vector of converted values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Convert volume
convert_val(10, "ml", "L")
convert_val(10:15, "ml", "L")

# Convert temperature
convert_val(-273.15, "C", "K")
convert_val(-40, "C", "F")
convert_val(c(2,4,6,8), "C", "F")

# Convert pressure
convert_val(1, "atm", "bar")
convert_val(1010, "hpa", "bar")
convert_val(735, "torr", "kpa")

# Convert area
convert_val(100, "cm2", "m2")
convert_val(10000, "mm2", "cm2")

# Convert mass
convert_val(200, "g", "kg")
convert_val(10000, "ug", "mg")

# Use directly in a respR function which requires inputs to be
# in a specific unit. For example, in convert_rate() pressure
# must be in 'bar' and respirometer volume in 'L'.
# Here, we know chamber volume is 200 ml, and pressure measured in mbar.
x &lt;- suppressWarnings(inspect(urchins.rd, 1, 2))

rate &lt;- calc_rate(x, from = 20, to = 30)

convert_rate(rate,
             oxy.unit = "ml/l",
             time.unit = "min",
             output.unit = "mg/h",
             volume = convert_val(200, "ml", "L"),
             S = 35,
             t = 15,
             P = convert_val(1010, "mbar", "bar"))

# Note, the default 'to' units are set to those respR requires in
# these functions ('L' and 'bar' here), so do not necessarily need
# to be specified:
convert_rate(rate,
             oxy.unit = "ml/l",
             time.unit = "min",
             output.unit = "mg/h",
             volume = convert_val(200, "ml"),
             S = 35,
             t = 15,
             P = convert_val(1010, "mbar"))
</code></pre>

<hr>
<h2 id='extract_indices'>Extract row, time and DO indices from a subset dataframe</h2><span id='topic+extract_indices'></span>

<h3>Description</h3>

<p>This is an internal function. Extracts row, time and DO values from a data
subset in a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_indices(x, subsets, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_indices_+3A_x">x</code></td>
<td>
<p>data frame.</p>
</td></tr>
<tr><td><code id="extract_indices_+3A_subsets">subsets</code></td>
<td>
<p>list of data frames.</p>
</td></tr>
<tr><td><code id="extract_indices_+3A_n">n</code></td>
<td>
<p>numeric. Choose which subset in the list to extract data from.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'data.table&ldquo; object.
</p>

<hr>
<h2 id='flow_unit_parse'>Extracts time and volume units from flowrate unit already parsed by units.val</h2><span id='topic+flow_unit_parse'></span>

<h3>Description</h3>

<p>Extracts time and volume units from flowrate unit already parsed by units.val
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flow_unit_parse(unit, which)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flow_unit_parse_+3A_unit">unit</code></td>
<td>
<p>flowrate unit input to be parsed</p>
</td></tr>
<tr><td><code id="flow_unit_parse_+3A_which">which</code></td>
<td>
<p>parse which component of unit? &quot;time&quot; or &quot;vol&quot;</p>
</td></tr>
</table>

<hr>
<h2 id='flowthrough_mult.rd'>Multi-column flowthrough respirometry data</h2><span id='topic+flowthrough_mult.rd'></span>

<h3>Description</h3>

<p>A semi-simulated dataset for testing and demonstrating flowthrough
respirometry analyses. Contains one column of numeric time data (col 1 in
mins), four columns of outflow oxygen concentrations (cols 2:5), four columns
of inflow oxygen concentrations (cols 6:9), and four columns of delta oxygen
concentrations (cols 10:13, which is simply the numeric difference between
paired columns of outflow and inflow). There is also a column of inflow
oxygen concentrations as recorded from a shared header tank (col 14,
<code style="white-space: pre;">&#8288;$oxy.header&#8288;</code>) supplying all chambers, to use as an alternative to the
individual inflow oxygen recordings. Lastly, there is a column of temperature
data (col 15, <code style="white-space: pre;">&#8288;$temperature&#8288;</code> in °C).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flowthrough_mult.rd
</code></pre>


<h3>Format</h3>

<p>A data frame object consisting of 3740 rows (approx 62 mins of
data),and 15 columns: time (col 1), oxygen outflow concentrations (cols
2,3,4,5), inflow concentrations (cols 6,7,8,9 each paired with the
respective outflow column, the fourth being a control), delta oxygen values
(cols 10,11,12,13 or difference between outflow and inflow concentrations),
inflow concentrations recorded in a shared header tank (col 14), and
temperature (col 15).
</p>


<h3>Details</h3>

<p>Outflow (2:5) and inflow (6:9) columns are paired, with the first three
containing specimens, and the fourth an empty control respirometer, or
&quot;blank&quot; experiment (oxy.out.blank, oxy.in.blank) to determine background
respiration.
</p>
<p>The third paired dataset (col 4 and col 8 pair) has a period of higher rates
at around the 40 minute timepoint, where the specimen increases its activity
then slowly recovers to routine respiration levels.
</p>

<ul>
<li><p> Dissolved oxygen units: <code style="white-space: pre;">&#8288;%Air&#8288;</code>
</p>
</li>
<li><p> Time units: <code>mins</code>
</p>
</li>
<li><p> Flow rate (<code>L/min</code>): <code>0.1</code>
</p>
</li>
<li><p> Specimen masses: (<code>kg</code>): <code style="white-space: pre;">&#8288;0.013, 0.015, 0.020&#8288;</code>
</p>
</li>
<li><p> Mean temperature (°C): <code>t = 18</code>
</p>
</li>
<li><p> Salinity: <code>S = 0</code>, i.e. freshwater
</p>
</li>
<li><p> Atmospheric pressure (bar): <code>P = 1.013</code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Nicholas Carey
</p>

<hr>
<h2 id='flowthrough_sim.rd'>Flowthrough respirometry data with increasing background rate</h2><span id='topic+flowthrough_sim.rd'></span>

<h3>Description</h3>

<p>A simulated dataset for testing and demonstrating flowthrough respirometry
analyses and background adjustment when the background respiration rate
increases over the course of the experiment. Contains one column of numeric
time data (<code style="white-space: pre;">&#8288;$num.time&#8288;</code>), one column of specimen outflow oxygen concentrations
(<code style="white-space: pre;">&#8288;$oxy.out.spec&#8288;</code>), one column of control or &quot;blank&quot; chamber outflow oxygen
concentrations (<code style="white-space: pre;">&#8288;$oxy.out.blank&#8288;</code>), and one column of inflow oxygen
concentrations as recorded from a shared header tank (<code style="white-space: pre;">&#8288;$oxy.header&#8288;</code>)
supplying both chambers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flowthrough_sim.rd
</code></pre>


<h3>Format</h3>

<p>A data frame object consisting of 3740 rows (approx 62 mins of
data),and 4 columns: time (col 1), specimen oxygen outflow concentrations
(col 2), control/blank chamber oxygen outflow concentrations (col 3), and
inflow concentrations recorded from a shared header tank (col 4).
</p>


<h3>Details</h3>


<ul>
<li><p> Dissolved oxygen units: <code>mg/L</code>
</p>
</li>
<li><p> Time units: <code>seconds</code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Nicholas Carey
</p>

<hr>
<h2 id='flowthrough.rd'>Flowthrough respirometry data on the chiton, <em>Mopalia lignosa</em></h2><span id='topic+flowthrough.rd'></span>

<h3>Description</h3>

<p>A single experiment on the chiton species <em>Mopalia lignosa</em> in a custom-built
flowthrough respirometry system. Conducted at University of British Columbia,
Vancouver, BC, Canada.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flowthrough.rd
</code></pre>


<h3>Format</h3>

<p>A data frame object consisting of 935 rows (approx 16 mins of
data),and 4 columns: time, oxygen inflow and outflow concentrations, and
oxygen delta (the outflow minus inflow concentrations).
</p>


<h3>Details</h3>


<ul>
<li><p> Dissolved oxygen units: <code>mg/L</code>
</p>
</li>
<li><p> Time units: <code>seconds</code>
</p>
</li>
<li><p> Flow rate (<code>mL/min</code>): <code>2.34</code>
</p>
</li>
<li><p> Inflow oxygen concentration (calculated assuming 100% air saturated, <code>mg/L</code>): <code>8.919</code>
</p>
</li>
<li><p> Specimen ash-free dry mass (<code>kg</code>): <code>0.000070</code>
</p>
</li>
<li><p> Temperature (°C): <code>t = 12</code>
</p>
</li>
<li><p> Salinity: <code>S = 30</code>
</p>
</li>
<li><p> Atm. Pressure (bar): <code>P = 1.013</code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Nicholas Carey
</p>

<hr>
<h2 id='format_time'>Parse date-time data to numeric time for use in respR functions</h2><span id='topic+format_time'></span>

<h3>Description</h3>

<p>A function to parse class POSIX.ct or text strings of date-time data to
numeric time for use in <code>respR</code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_time(x, time = 1, format = "ymdHMS", start = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="format_time_+3A_x">x</code></td>
<td>
<p>vector or data frame containing strings or class POSIX.ct date-time
data to be converted to numeric.</p>
</td></tr>
<tr><td><code id="format_time_+3A_time">time</code></td>
<td>
<p>numeric value or vector. Specifies column(s) containing date-time
data. Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="format_time_+3A_format">format</code></td>
<td>
<p>string. Code describing structure of date-time data. See
Details.</p>
</td></tr>
<tr><td><code id="format_time_+3A_start">start</code></td>
<td>
<p>numeric. At what time (in seconds) should the formatted time
data start? Default is <code>1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Regardless of input, all data are parsed to numeric time data in seconds
duration from the first entry starting at 1. If you want the times to start
at a different time, a <code>start</code> value can be specified, in which case the
series starts at that number (in seconds) and all subsequent times are
shifted forward by the same amount.
</p>


<h4>Input</h4>

<p>Input can be a vector, or data frame. If a data frame, the column(s) of the
date-time data are specified using the <code>time</code> input. By default the first
column is assumed to contain the date-time data (i.e. <code>time = 1</code>).
</p>
<p>If the date-time data is split over several columns (e.g. date in one column,
time in another), multiple columns can be specified (e.g. <code>time = c(1,2)</code>).
In this case, the <code>format</code> setting should reflect the correct order as
entered in <code>time</code>.
</p>



<h4>Time only data</h4>

<p>Time-only data, that is times which lack an associated date, can also be
parsed. Normally, parsing time-only data will cause problems when the times
cross midnight (i.e. <code>00:00:00</code>). However, the function attempts to identify
when this occurs and parse the data correctly.
</p>



<h4>Formatting</h4>

<p>See the <code><a href="lubridate.html#topic+lubridate">lubridate</a></code> package for more detail on acceptable
formatting.
</p>
<p>Date-time data can be unspaced or separated by any combination of spaces,
forward slashes, hyphens, dots, commas, colons, semicolons, or underscores.
E.g. all these are parsed as the same date-time: <code style="white-space: pre;">&#8288;"2010-02-28 13:10:23", "20100228131023", "2010,02/28 13.10;23", "2010 02 28 13_10-23"&#8288;</code>.
</p>

<ul>
<li><p> Times can be in 24H or 12H with AM/PM <br /> E.g. &quot;2010-02-28 13:10:23&quot; or
&quot;2010-02-28 1:10:23 PM&quot;
</p>
</li>
<li><p> Times without initial zero are parsed as 24H time <br /> E.g. &quot;1:10:23&quot; is
same as &quot;1:10:23 AM&quot; or &quot;01:10:23&quot;
</p>
</li>
<li><p> AM/PM take precedence over 24H formatting for 01-12h <br /> E.g. &quot;1:10:23 PM&quot;
and &quot;01:10:23 PM&quot; are both same as &quot;13:10:23&quot;
</p>
</li>
<li><p> However, 24H formatting for 13-24h takes precedence over AM/PM <br /> E.g.
&quot;13:10:23 AM&quot; is identified as &quot;1:10:23 PM&quot; or &quot;13:10:23&quot;
</p>
</li></ul>




<h4>Syntax of 'format' input</h4>

<p>Specify the order of year, month, day, and time in your date-time input.
</p>
<p><code>d</code> - Day of the month as decimal number (01&ndash;31 or 1&ndash;31).
</p>
<p><code>m</code> - Month of the year as decimal number (01&ndash;12 or 1&ndash;12).
</p>
<p><code>y</code> - Year (2010, 2001, 1989).
</p>
<p><code>H</code> - Hour as decimal number (00&ndash;24 or 0&ndash;24 or 00-12 (see <code>p</code>)).
</p>
<p><code>M</code> - Minute as decimal number (00&ndash;59 or 0&ndash;59).
</p>
<p><code>S</code> - Second as decimal number (00&ndash;59 or 0&ndash;59).
</p>
<p><code>p</code> - AM/PM indicator for 12-h date-time format (e.g. &quot;01/12/2020 1:30:44 PM
&quot; would be <code>"dmyHMSp"</code>).
</p>
<p>Specify the order using the <code>format</code> input, using separators or not
(optional): <code>"dmyHMS"</code>; <code>"dmy_HMS"</code> and <code>"d m y H M S"</code> are all the same. See
Examples.
</p>
<p>Single experimental datasets should never span different time zones, so if a
time zone is present it is ignored for the purposes of calculating numeric
times.
</p>



<h4>More</h4>

<p>For additional help, documentation, vignettes, and more visit the <code>respR</code>
website at <a href="https://januarharianto.github.io/respR/">https://januarharianto.github.io/respR/</a>
</p>



<h3>Value</h3>

<p><strong>Output</strong>: If the input is a vector, output is a vector of equal
length containing the numeric time data. For data frame inputs, an
identical data frame is returned, with a new column named <code>time_num</code> added
as the <strong>final</strong> column.
</p>


<h3>See Also</h3>

<p><code><a href="lubridate.html#topic+lubridate">lubridate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Convert year-month-day hour-min-sec
x &lt;- c("09-02-03 01:11:11", "09-02-03 02:11:11","09-02-03 02:25:11")
format_time(x)

# Convert day-month-year hour-min, and use a separator in the format
x &lt;- c("03-02-09 01:11", "03-02-09 02:11","03-02-09 02:25")
format_time(x, format = "dmy_HM")

# Convert when AM/PM is present
x &lt;- c("09-02-03 11:11:11 AM", "09-02-03 12:11:11 PM","09-02-03 01:25:11 PM")
# This is WRONG - the AM/PM indicator is missing
format_time(x, format = "dmyHMS")
# This is correct
format_time(x, format = "dmyHMSp")

# Convert dataframe with year-month-day hour-min-sec (ymdHMS default)
x &lt;- data.frame(
  x = c("09-02-03 01:11:11", "09-02-03 02:11:11","09-02-03 02:25:11"),
  y = c(23, 34, 45))
format_time(x, time = 1)

# Convert dataframe with time in a different column and non-default format
x &lt;- data.frame(
  x = c(23, 34, 45),
  y = c("09-02-2018 11:11:11 AM", "09-02-2018 12:11:11 PM","09-02-2018 01:25:11 PM"),
  z = c(56, 67, 78))
format_time(x, time = 2, format = "dmyHMSp")

# Convert dataframe with separate date and time columns, and times crossing midnight
x &lt;- data.frame(
  w = c("09-02-18", "09-02-18","10-02-18"),
  x = c("22:11:11", "23:11:11","00:25:11"),
  y = c(23, 34, 45),
  z = c(56, 67, 78))
# Crosses midnight, but parses correctly even without dates
format_time(x, time = 2, format = "HMS")
# Include dates to double check
format_time(x, time = 1:2, format = "dmyHMS")
# Input same as different column order &amp; appropriate format order
format_time(x, time = 2:1, format = "HMSdmy")

# Convert a data frame with date and time split over multiple columns
x &lt;- data.frame(
  u = c("09", "09","10"),
  v = c("02", "02","02"),
  w = c("2018", "2018","2018"),
  x = c("22:11:11", "23:11:11","00:25:11"),
  y = c(23, 34, 45),
  z = c(56, 67, 78))
format_time(x, time = 1:4, format = "dmyHMS")
</code></pre>

<hr>
<h2 id='generate_mrdf'>Generate a DO ~ PO2 data table from a DO timeseries</h2><span id='topic+generate_mrdf'></span>

<h3>Description</h3>

<p>Generate a DO ~ PO2 data table from a DO timeseries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_mrdf(dt, width)
</code></pre>


<h3>Value</h3>

<p>a data.table object
</p>

<hr>
<h2 id='get_dec'>Identify decimal character
For European formatted files with commas as decimal separator</h2><span id='topic+get_dec'></span>

<h3>Description</h3>

<p>Identify decimal character
For European formatted files with commas as decimal separator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_dec(path)
</code></pre>

<hr>
<h2 id='import_file'>Import respirometry system raw data files (DEPRECATED)</h2><span id='topic+import_file'></span>

<h3>Description</h3>

<p>Automatically import data from different respirometry hardware and software
systems. <em>WARNING</em>: This function is now deprecated and will not be updated.
See below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import_file(path, export = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="import_file_+3A_path">path</code></td>
<td>
<p>string. Path to file.</p>
</td></tr>
<tr><td><code id="import_file_+3A_export">export</code></td>
<td>
<p>logical. If TRUE, exports the data as a <code>csv</code> to the same
directory, as determined by the <code>path</code> parameter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function has been deprecated, will not be updated, and will be removed
entirely in the next major version of <code>respR</code> (i.e. <code>v3.0</code>, which is not
planned for any time soon, so may still be years away).
</p>
<p>Note that use of this function to import data is <em>OPTIONAL</em> and in fact <em>NOT
RECOMMENDED</em>. <code>respR</code> has an extremely simple input data structure
requirement: paired numeric values of time and oxygen amount in any common
units in a <code>data.frame</code>. To our knowledge, every oxygen sensor system allows
you to export data in a format (e.g. <code>.csv</code>, <code>.txt</code>, <code>.xlsx</code>) which are easy
to import into <code>R</code>, and this is a basic skill anyone using <code>R</code> should be
comfortable with. <code>import_file</code> was only ever a convenience function intended
for those completely new to <code>R</code>. It is <em>ALWAYS</em> better to import files
yourself using generic functions such as <code>read.csv()</code>, <code>read.table()</code> or
<code>fread()</code> as it gives you much more control and the ability to troubleshoot
issues.
</p>
<p>For files currently supported, the function extracts data columns, removes
redundant rows of metadata, and generally cleans up column names (e.g.
removes whitespace and characters which cause text encoding issues) to make
the data easier to work with. Files should be sensor system raw output files
where possible; files opened and re-saved in a different format will likely
fail to import.
</p>
<p>Currently tested and working for these files:
</p>

<ul>
<li><p> Pyro Firesting
</p>
</li>
<li><p> Pyro Workbench (very experimental - likely to fail and will not be updated further)
</p>
</li>
<li><p> PreSens OXY10
</p>
</li>
<li><p> PreSens OXY4
</p>
</li>
<li><p> PreSens (OxyView generic, including multiplate systems)
</p>
</li>
<li><p> PreSens/Loligo 24-Well Multiplate System (output Excel files)
</p>
</li>
<li><p> MiniDOT
</p>
</li>
<li><p> Loligo AutoResp ('_raw' files output, <em>not</em> metadata files)
</p>
</li>
<li><p> Loligo Witrox (same as AutoResp, without metadata)
</p>
</li>
<li><p> Vernier (raw qmbl, csv, or txt)
</p>
</li>
<li><p> NeoFox
</p>
</li>
<li><p> Qbox Aqua
</p>
</li></ul>

<p>Files with European numeric formatting (i.e. commas instead of points to
denote decimals) are supported, and will be converted to point decimals on
import. This is experimental functionality, so please provide feedback for
any files for which this might fail.
</p>
<p>While the devices listed above are supported, the import functionality is
experimental due to limited access to sample files. Users should be aware
we have not been able to test every variation of file formats, and should
carefully check the imported data, and be prepared to import data using
other functions such as <code>read.csv()</code>.
</p>


<h4>More</h4>

<p>For additional help, documentation, vignettes, and more visit the <code>respR</code>
website at <a href="https://januarharianto.github.io/respR/">https://januarharianto.github.io/respR/</a>
</p>



<h3>Value</h3>

<p>A <code>data.frame</code> object of all columned data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Import a file
import_file("path/to/file")

# Import a file and export it to same directory as a csv
import_file("path/to/file", export = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='inspect'>Explore and visualise respirometry data and check for common errors</h2><span id='topic+inspect'></span>

<h3>Description</h3>

<p><code>inspect()</code> is a data exploration and preparation function that visualises
respirometry data and checks it for errors that may affect the use of further
functions in <code>respR</code>. It also subsets specified columns into a new <code>list</code>
object that can be used in subsequent functions, reducing the need for
additional inputs. Note, use of <code>inspect</code> to prepare data for the subsequent
functions is optional. Functions in <code>respR</code> can accept regular <code>R</code> data
objects including data frames, data tables, tibbles, vectors, etc. It is a
quality control and exploratory step to help users view and prepare their
data prior to analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inspect(
  x,
  time = NULL,
  oxygen = NULL,
  width = 0.1,
  plot = TRUE,
  add.data = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inspect_+3A_x">x</code></td>
<td>
<p>data.frame. Any object of class <code>data.frame</code> (incl. <code>data.table</code>,
<code>tibble</code>, etc.). Should contain paired numeric values of time and oxygen.</p>
</td></tr>
<tr><td><code id="inspect_+3A_time">time</code></td>
<td>
<p>integer or string. Defaults to <code>1</code>. Specifies the column of the
Time data as either a column number or the name.</p>
</td></tr>
<tr><td><code id="inspect_+3A_oxygen">oxygen</code></td>
<td>
<p>integer or string, or vector of either. Defaults to <code>2</code>.
Specifies the column(s) of the Oxygen data as either a vector of column
numbers or names.</p>
</td></tr>
<tr><td><code id="inspect_+3A_width">width</code></td>
<td>
<p>numeric, 0.01 to 1. Defaults to <code>0.1</code>. Width used in the rolling
regression plot as proportion of total length of data.</p>
</td></tr>
<tr><td><code id="inspect_+3A_plot">plot</code></td>
<td>
<p>logical. Defaults to <code>TRUE</code>. Plots the data. If <code>time</code> and single
<code>oxygen</code> columns selected, plots timeseries data, plus plot of rolling
rate. If multiple <code>oxygen</code> columns, plots all timeseries data only.</p>
</td></tr>
<tr><td><code id="inspect_+3A_add.data">add.data</code></td>
<td>
<p>integer or string. Defaults to <code>NULL</code>. Specifies the column
number or name of an optional additional data source that will be plotted
in blue alongside the full oxygen timeseries.</p>
</td></tr>
<tr><td><code id="inspect_+3A_...">...</code></td>
<td>
<p>Allows additional plotting controls to be passed, such as <code>legend = FALSE</code>, <code>quiet = TRUE</code>, <code>rate.rev = FALSE</code> and <code>pos</code>. A different <code>width</code>
can also be passed in <code>plot()</code> commands on output objects.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given an input data frame, <code>x</code>, the function scans the specified <code>time</code> and
<code>oxygen</code> columns for the following issues. Columns are specified by using the
column number (e.g. <code>time = 1</code>), or by name (e.g. <code>time = "Time.Hrs"</code>). If
<code>time</code> and <code>oxygen</code> are left <code>NULL</code> the default of <code style="white-space: pre;">&#8288;time = 1, oxygen = 2&#8288;</code> is
applied.
</p>


<h4>Check for numeric data</h4>

<p><code>respR</code> requires data be in the form of paired values of numeric time and
oxygen. All columns are checked that they contain numeric data before any
other checks are performed. If any of the inspected columns do not contain
numeric data the remaining checks for that column are skipped, and the
function exits returning <code>NULL</code>, printing the summary of the checks. No plot
is produced. Only when all inspected columns pass this numeric check can the
resulting output object be saved and passed to other <code>respR</code> functions.
</p>



<h4>Other checks</h4>

<p>The <code>time</code> column is checked for missing (<code>NA/NaN</code>) values, positive and
negative infinite values (<code>Inf/-Inf</code>), that values are sequential, that there
are no duplicate times, and that it is numerically evenly-spaced. Oxygen
columns are checked for missing (<code>NA/NaN</code>) and infinite values (<code>Inf/-Inf</code>).
See <strong>Failed Checks</strong> section for what it means for analyses if these checks
result in warnings. If the output is assigned, the specified <code>time</code> and
<code>oxygen</code> columns are extracted and saved to a <code>list</code> object for use in later
functions such as <code><a href="#topic+calc_rate">calc_rate()</a></code> and <code><a href="#topic+auto_rate">auto_rate()</a></code>. A plot is also
produced.
</p>



<h4>Plot</h4>

<p>If <code>plot = TRUE</code> (the default), a plot of the oxygen timeseries is produced
in the upper panel. In addition, a rolling regression plot in the lower panel
shows the rate of change in oxygen across a rolling window specified using
the <code>width</code> operator (default is <code>width = 0.1</code>, or 10% of the entire
dataset). This plot provides a quick visual inspection of how the rate varies
over the course of the experiment. Regions of stable and consistent rates can
be identified on this plot as flat or level areas. This plot is for
exploratory purposes only; later functions allow rate to be calculated over
specific regions. Each individual rate value is plotted against the centre of
the time window used to calculate it.
</p>
<p><em><strong>Note:</strong></em> Since <code>respR</code> is primarily used to examine oxygen consumption,
the oxygen rate plot is by default plotted on a reverse y-axis. In <code>respR</code>
oxygen uptake rates are negative since they represent a negative slope of
oxygen against time. In these plots the axis is reversed so that higher
uptake rates (i.e. more negative) will be higher on these plots. If you are
interested instead in oxygen production rates, which are positive, the
<code>rate.rev = FALSE</code> input can be passed in either the <code>inspect</code> call, or when
using <code>plot()</code> on the output object. In this case, the rate values will be
plotted numerically, and higher oxygen <em>production</em> rates will be higher on
the plot.
</p>



<h4>Plot an additional data source</h4>

<p>Using the <code>add.data</code> input an additional data source, for example
temperature, can be plotted alongside the oxygen timeseries. This should be
either a column number (e.g. <code>add.data = 3</code>) or name (e.g. <code>add.data = "Temperature"</code>) indicating a column in the input <code>x</code> data frame sharing the
same time data. None of the data checks are performed on this column; it is
simply to give a basic visual aid in the plot to, for example, help decide if
regions of the data should be used or not used because this parameter was
variable. Values are saved in the output as a vector under <code style="white-space: pre;">&#8288;$add.data&#8288;</code>. It is
plotted in blue on a separate y-axis on the main timeseries plot. It is <em>not</em>
plotted if multiple oxygen columns are inspected. See examples.
</p>



<h4>Additional plotting options</h4>

<p>A different <code>width</code> value can be passed to see how it affects estimation of
the rolling rate. If axis labels obscure parts of the plot they can be
suppressed using <code>legend = FALSE</code>. Suppress console output messages with
<code>quiet = TRUE</code>. If multiple columns have been inspected, the <code>pos</code> input can
be used to examine each time~oxygen dataset. If axis labels (particularly
y-axis) are difficult to read, <code>las = 2</code> can be passed to make axis labels
horizontal, and  <code>oma</code> (outer margins, default <code>oma = c(0.4, 1, 1.5, 0.4)</code>)
or <code>mai</code> (inner margins, default <code>mai = c(0.3, 0.15, 0.35, 0.15)</code>) can be
used to adjust plot margins. See examples.
</p>



<h4>Multiple Columns of Oxygen Data</h4>

<p>For a quick overview of larger datasets, multiple oxygen columns can be
inspected for errors and plotted by using the <code>oxygen</code> input to select
multiple columns. These must share the same <code>time</code> column. In this case, data
checks are performed, with a plot of each oxygen time series, but no rolling
rate plot is produced. All data are plotted on the same axis range of both
time and oxygen (total range of data). This is chiefly exploratory
functionality to allow for a quick overview of a dataset, and it should be
noted that while the output <code>inspect</code> object will contain all columns in its
<code style="white-space: pre;">&#8288;$dataframe&#8288;</code> element, subsequent functions in <code>respR</code> (<code>calc_rate</code>,
<code>auto_rate</code>, etc.) will by default only use the first two columns (<code>time</code>,
and the first specified <code>oxygen</code> column). To analyse multiple columns and
determine rates, best practice is to inspect and assign each time-oxygen
column pair as separate <code>inspect</code> objects. See Examples.
</p>



<h4>Flowthrough Respirometry Data</h4>

<p>For flowthrough respirometry data, see the specialised <code><a href="#topic+inspect.ft">inspect.ft()</a></code>
function.
</p>



<h4>Failed Checks</h4>

<p>The most important data check in <code>inspect</code> is that all data columns are
numeric. If any column fails this check, the function skips the remaining
checks for that column, the function exits returning <code>NULL</code>, and no output
object or plot is produced.
</p>
<p>The other failed check that requires action is the check for infinite values
(<code>Inf/-Inf</code>). Some oxygen sensing systems add these in error when
interference or data dropouts occur. Infinite values will cause problems when
it comes to calculating rates, so need to be removed. If found, locations of
these are printed and can be found in the output object under <code style="white-space: pre;">&#8288;$locs&#8288;</code>. Note,
these values are not plotted, so special note should be taken of the warnings
and console printout.
</p>
<p>The remaining data checks in <code>inspect</code> are mainly exploratory and help
diagnose and flag potential issues with the data that might affect rate
calculations. For instance, long experiments may have had sensor dropouts the
user is unaware of. Some might not be major issues. For instance, an uneven
time warning can result from using decimalised minutes, which is a completely
valid time metric, but happens to be numerically unevenly spaced. As an
additional check, if uneven time is found, the minimum and maximum intervals
in the time data are in the console output, so a user can see immediately if
there are large gaps in the data.
</p>
<p>If some of these checks produce warnings, it should <em>generally</em> not hinder
analysis of the data. <code>respR</code> has been coded to rely on linear regressions on
exact data values, and not make assumptions about data spacing or order.
Therefore issues such as missing or NA/NaN values, duplicate or
non-sequential time values, or uneven time spacing should not cause any
erroneous rate results, as long as they do not occur over large regions of
the data. <code>inspect</code> however outputs locations (row numbers) of where these
issues occur (located in the <code style="white-space: pre;">&#8288;$locs&#8288;</code> element of the output), allowing users
to amend them before analysis. We would strongly recommend that to be
completely confident in any results from analysis of such data, and avoid
obscure errors, these issues be addressed before proceeding.
</p>



<h4>S3 Generic Functions</h4>

<p>Saved output objects can be used in the generic S3 functions <code>plot()</code>,
<code>print()</code> and <code>summary()</code>.
</p>

<ul>
<li> <p><code>plot()</code>: plots the result.
</p>
</li>
<li> <p><code>print()</code>: prints a summary of the checks performed on the data. If issues
are found, locations (row numbers) are printed (up to first 20 occurrences).
</p>
</li>
<li> <p><code>summary()</code>: simple wrapper for <code>print()</code> function. See above.
</p>
</li></ul>




<h4>More</h4>

<p>For additional help, documentation, vignettes, and more visit the <code>respR</code>
website at <a href="https://januarharianto.github.io/respR/">https://januarharianto.github.io/respR/</a>
</p>



<h3>Value</h3>

<p>Output is a <code>list</code> object of class <code>inspect</code>, with a <code style="white-space: pre;">&#8288;$dataframe&#8288;</code>
containing the specified <code>time</code> and <code>oxygen</code> columns, inputs, and metadata
which can be passed to <code><a href="#topic+calc_rate">calc_rate()</a></code> or <code><a href="#topic+auto_rate">auto_rate()</a></code> to determine
rates. If there are failed checks or warnings, the row locations of the
potentially problematic data can be found in <code style="white-space: pre;">&#8288;$locs&#8288;</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## By default, assumes time is col 1 and oxygen col2:
inspect(sardine.rd)

## Instead, specify time and oxygen columns as either number or name
inspect(sardine.rd, time = 1, oxygen = 2)
inspect(urchins.rd, time = "time.min", oxygen = "a")

## Use add.data input to plot an additional data type
## (this column is not checked)
inspect(sardine.rd, time = 1, oxygen = 2, add.data = 3)

## Adjust the width of the rolling rate plot:
inspect(sardine.rd, 1, 2, width = 0.2)

## Inspect specific columns in multicolumn datasets:
inspect(urchins.rd, time = 1, oxygen = 4)

## Inspect multiple columns for a quick overview
## of a large dataset:
inspect(urchins.rd, time = 1, oxygen = c(11:19))

## Inspect oxygen production data, use a width that gives
## a better rolling rate, and use extra plotting options to
## suppress legend, and ensure rates are plotted not reversed:
inspect(algae.rd, time = 1, oxygen = 2, width = 0.4,
        legend = FALSE, rate.rev = FALSE)

## Pass additional plotting inputs to override defaults and
## allow better y-axis label visibility
inspect(sardine.rd, time = 1, oxygen = 2,
        las = 1, mai = c(0.3, 0.35, 0.35, 0.15))

</code></pre>

<hr>
<h2 id='inspect.ft'>Explore and visualise flowthrough respirometry data and check for errors</h2><span id='topic+inspect.ft'></span>

<h3>Description</h3>

<p><code>inspect.ft</code> is a data exploration and preparation function that visualises
flowthrough respirometry data, checks it for common issues, and prepares it
for use in later functions in <code>respR</code>, such as <code><a href="#topic+calc_rate.ft">calc_rate.ft()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inspect.ft(
  x,
  time = NULL,
  out.oxy = NULL,
  in.oxy = NULL,
  in.oxy.value = NULL,
  delta.oxy = NULL,
  plot = TRUE,
  add.data = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inspect.ft_+3A_x">x</code></td>
<td>
<p><code>data.frame</code> containing columns of <code>time</code> and <code>out.oxy</code> or
<code>delta.oxy</code> concentrations, and optionally <code>in.oxy</code>.</p>
</td></tr>
<tr><td><code id="inspect.ft_+3A_time">time</code></td>
<td>
<p>integer or string. Defaults to <code>1</code>. Specifies the column of the
Time data as either a column number or the name.</p>
</td></tr>
<tr><td><code id="inspect.ft_+3A_out.oxy">out.oxy</code></td>
<td>
<p>integer(s) or string(s). Defaults to <code>NULL</code>. Specifies the
column(s) of the outflow oxygen data as either column numbers or names.</p>
</td></tr>
<tr><td><code id="inspect.ft_+3A_in.oxy">in.oxy</code></td>
<td>
<p>integer(s) or string(s). Defaults to <code>NULL</code>. Specifies the
column(s) of the inflow oxygen data as either column numbers or names.</p>
</td></tr>
<tr><td><code id="inspect.ft_+3A_in.oxy.value">in.oxy.value</code></td>
<td>
<p>numeric value. Defaults to <code>NULL</code>. If there is no
continuous <code>in.oxy</code> data, this specifies a fixed value of oxygen
concentration for inflowing water in same units as <code>out.oxy</code>, and is used
with <code>out.oxy</code> to calculate a <code>delta.oxy</code>.</p>
</td></tr>
<tr><td><code id="inspect.ft_+3A_delta.oxy">delta.oxy</code></td>
<td>
<p>integer(s) or string(s). Defaults to all non-time columns if
no other inputs given. Specifies the column number(s) or name(s) of delta
oxygen data, for when the user has already calculated the difference
between outflow and inflow oxygen (should be negative values for oxygen
uptake). If this is used, <code>out.oxy</code> and <code>in.oxy</code> should be NULL.</p>
</td></tr>
<tr><td><code id="inspect.ft_+3A_plot">plot</code></td>
<td>
<p>logical. Defaults to TRUE. Plots the data. See Details.</p>
</td></tr>
<tr><td><code id="inspect.ft_+3A_add.data">add.data</code></td>
<td>
<p>integer or string. Defaults to <code>NULL</code>. Specifies the column
number or name of an optional additional data source that will be plotted
in blue alongside the full oxygen timeseries.</p>
</td></tr>
<tr><td><code id="inspect.ft_+3A_...">...</code></td>
<td>
<p>Allows additional plotting controls to be passed, such as <code>legend = FALSE</code>, <code>quiet = TRUE</code>, <code>rate.rev = FALSE</code> and <code>pos</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>inspect.ft</code> is intended to be specific to <em>flowthrough</em> respirometry data.
In flowthrough respirometry (also known as 'open flow' or 'continuous flow'
respirometry) rather than calculating a rate from a changing oxygen
concentration recording in a sealed chamber, instead the difference (i.e.
'oxygen delta') between the inflowing and outflowing oxygen concentrations of
a respirometer receiving water at a constant flow rate is used to calculate
an oxygen consumption or production rate, typically after it has reached a
steady state. Therefore, in general, regions of stable oxygen delta values
(difference between outflow and inflow oxygen) are of interest. <code>inspect.ft</code>
visualises and prepares the data for use in <code><a href="#topic+calc_rate.ft">calc_rate.ft()</a></code>. By specifying
data types in this function and saving the output, they do not need to be
specified in later functions.
</p>


<h4>Inputs</h4>

<p>Given an input data frame <code>x</code>, the function scans the columns specified via
the <code>time</code>, <code>out.oxy</code>, <code>in.oxy</code> or <code>delta.oxy</code> inputs. Columns are specified
by using the column number (e.g. <code>time = 1</code>), or by name (e.g. <code>time = "Time.Hrs"</code>). If no columns are specified, by default the function assumes
the first column is <code>time</code>, and all others are <code>delta.oxy</code> oxygen data.
However, best practice is to use the inputs to specify particular columns.
</p>
<p>The <code>x</code> input must contain at least two data types; a single column of
numeric <code>time</code> data, with <em>either</em> a column of paired <code>out.oxy</code>
concentrations (i.e. the exhalent or 'downstream' concentrations), <em>or</em> a
column of already calculated <code>delta.oxy</code> values, that is the difference
between outflow and inflow concentrations, or the outflow concentration
corrected by a background recording from a 'blank' or empty chamber.
</p>
<p><strong>out.oxy input option</strong>: If an <code>out.oxy</code> column has been specified, in order
to calculate the oxygen delta (and therefore a rate in <code><a href="#topic+calc_rate.ft">calc_rate.ft()</a></code>)
there must also be an inflow oxygen concentration input (i.e. the inhalent or
'upstream' concentration). This will generally be a column of paired <code>in.oxy</code>
concentrations, in which case the paired values of <code>out.oxy</code> and <code>in.oxy</code> are
used to calculate the oxygen <code>delta.oxy</code>, which is saved in the output and
used to determine a rate in <code><a href="#topic+calc_rate.ft">calc_rate.ft()</a></code>. Alternatively, if the inflow
oxygen concentration is a known, generally unvarying value (such as fully
air-saturated water from a header tank) this can be entered as a single value
via <code>in.oxy.value</code> and this is used to calculate the <code>delta.oxy</code>.
</p>
<p><strong>delta.oxy input option</strong>: If delta oxygen values have already been
calculated, these can be entered via the <code>delta.oxy</code> input, and these are
prepared and saved for rate calculations in <code>calc_rate.ft</code>.
</p>



<h4>Check for numeric data</h4>

<p><code>respR</code> requires data be in the form of paired values of numeric time and
oxygen. All columns are checked that they contain numeric data before any
other checks are performed. If any of the inspected columns do not contain
numeric data the remaining checks for that column are skipped, and the
function exits returning <code>NULL</code>, printing the summary of the checks. No plot
is produced. Only when all inspected columns pass this numeric check can the
resulting output object be saved and passed to other <code>respR</code> functions.
</p>



<h4>Other checks</h4>

<p>The <code>time</code> column is checked for missing (<code>NA/NaN</code>) values, infinite values
both positive and negative (<code>Inf/-Inf</code>), that values are sequential, that
there are no duplicate times, and that it is numerically evenly-spaced.
Oxygen columns are checked for missing (<code>NA/NaN</code>) and infinite values
(<code>Inf/-Inf</code>). See <strong>Failed Checks</strong> section for what it means for analyses if
these checks result in warnings. If the output is assigned, the specified
columns are saved to a <code>list</code> object for use in later functions such as
<code><a href="#topic+calc_rate.ft">calc_rate.ft()</a></code>. A plot is also produced.
</p>



<h4>Plot</h4>

<p>If <code>plot = TRUE</code>, entered data is plotted against both time (bottom, blue
axis) and row index (top, red axis), depending on the inputs:
</p>

<ul>
<li><p> a single <code>out.oxy</code> column with either a paired <code>in.oxy</code> column or
<code>in.oxy.value</code>: a two panel plot. The top plot is both outflow (green points)
and inflow (turquoise points) oxygen. The bottom plot is the oxygen delta
(black points) between outflow and inflow oxygen, essentially a unitless
oxygen uptake or production rate.
</p>
</li>
<li><p> a single <code>delta.oxy</code> column: a one panel plot of oxygen delta values.
</p>
</li>
<li><p> multiple <code>out.oxy</code> or <code>delta.oxy</code> columns: a grid plot of all <code>delta.oxy</code>
data (either as entered or calculated from <code>out.oxy</code> and <code>in.oxy</code>). Specific
delta plots can be examined individually by using the <code>pos</code> input (e.g.
<code>plot(x, pos = 2)</code>). Y-axes are not equal.
</p>
</li>
<li><p> unspecified columns: all columns are plotted assuming <code>time</code> is in column
1, and all others are oxygen <code>delta.oxy</code> data. Y-axes are not equal.
</p>
</li></ul>

<p>In delta plots, that is those plotting <code>delta.oxy</code> values, either directly
entered or calculated, consistent oxygen uptake or production rates will be
represented by flat or level regions. The <code>width</code> input may help with
selecting regions from which to extract rates, and can be passed in the main
function call or using <code>plot()</code> on the output object. This smooths delta
oxygen values by calculating a rolling mean across the data. See <strong>Additional
plotting options</strong> below.
</p>
<p><em><strong>Note:</strong></em> Since <code>respR</code> is primarily used to examine oxygen consumption,
the delta oxygen and rate plots are by default plotted on a reverse y-axis.
In <code>respR</code> oxygen uptake rates are negative since they represent a negative
slope of oxygen against time. In these plots the axis is reversed so that
higher uptake rates (i.e. more negative) will be higher on these plots. If
you are interested instead in oxygen production rates, which are positive,
the <code>rate.rev = FALSE</code> input can be passed in either the <code>inspect.ft</code> call,
or when using <code>plot()</code> on the output object. In this case, the delta and rate
values will be plotted numerically, and higher oxygen <em>production</em> rates will
be higher on the plot.
</p>



<h4>Plot an additional data source</h4>

<p>Using the <code>add.data</code> input an additional data source, for example
temperature, can be plotted alongside the oxygen timeseries. This should be
either a column number (e.g. <code>add.data = 3</code>) or name (e.g. <code>add.data = "Temperature"</code>) indicating a column in the input <code>x</code> data frame sharing the
same time data. None of the data checks are performed on this column; it is
simply to give a basic visual aid in the plot to, for example, help decide if
regions of the data should be used or not used because this parameter was
variable. Values are saved in the output as a vector under <code style="white-space: pre;">&#8288;$add.data&#8288;</code>. It is
plotted in blue on a separate y-axis on the main timeseries plot. It is <em>not</em>
plotted if multiple oxygen columns are inspected. See examples.
</p>



<h4>Additional plotting options</h4>

<p>The <code>width</code> input may help with selecting regions from which to extract
rates. This smooths delta oxygen values by calculating a rolling mean across
the data, and should be a value between 0 and 1 representing a proportion of
the total data width. If left as the default <code>NULL</code> no smoothing is
performed. This is a visual aid which only affects plotted values and does
not alter output delta oxygen values.
</p>
<p>If the legend or labels obscure part of the plot, they can be suppressed via
<code>legend = FALSE</code> in either the <code>inspect.ft</code> call, or when using <code>plot()</code> on
the output object. Suppress console output messages with <code>quiet = TRUE</code>. If
multiple columns have been inspected, the <code>pos</code> input can be used to examine
each <code>out.oxy</code>~<code>in.oxy</code>~<code>del.oxy</code> dataset. If axis labels (particularly
y-axis) are difficult to read, <code>las = 2</code> can be passed to make axis labels
horizontal. In addition, <code>oma</code> (outer margins, default <code>oma = c(0.4, 1, 1.5, 0.4)</code>), and <code>mai</code> (inner margins, default <code>mai = c(0.3, 0.15, 0.35, 0.15)</code>)
can be used to adjust plot margins.
</p>



<h4>Multiple data columns</h4>

<p>For a quick overview of larger experiments, multiple columns of <code>out.oxy</code>,
<code>in.oxy</code> and <code>delta.oxy</code> can be inspected, but must share the same numeric
time data column specified by the <code>time</code> input. Note, multiple column
inspection is chiefly intended to be exploratory functionality to provide a
quick overview of larger datasets. While the output will contain all data
columns in <code style="white-space: pre;">&#8288;$dataframe&#8288;</code> and <code style="white-space: pre;">&#8288;$data&#8288;</code>, subsequent functions such as
<code><a href="#topic+calc_rate.ft">calc_rate.ft()</a></code> will use only the first <code>delta.oxy</code> column for calculating
rates. Best practice is to inspect and assign each individual experiment or
column pair as separate <code>inspect.ft</code> objects. See Examples.
</p>
<p>If multiple <code>out.oxy</code> columns are specified, <code>in.oxy</code> can be a single column
(if for example all chambers are supplied from the same header tank), in
which case it is used to calculate an oxygen delta for all <code>out.oxy</code> columns.
A single <code>in.oxy.value</code> in the same units as <code>out.oxy</code> can also be specified.
There can also be multiple <code>in.oxy</code> columns, in which case it is assumed each
<code>out.oxy</code> column is paired with each <code>in.oxy</code> at the same position, and used
to calculate the oxygen <code>delta.oxy</code>. In this case, <code>out.oxy</code> and <code>in.oxy</code>
must have equal numbers of columns.
</p>



<h4>Failed Checks</h4>

<p>The most important data check in <code>inspect.ft</code> is that all data columns are
numeric. If any column fails this check, the function skips the remaining
checks for that column, the function exits returning <code>NULL</code>, and no output
object or plot is produced.
</p>
<p>The other failed check that requires action is the check for infinite values
(<code>Inf/-Inf</code>). Some oxygen sensing systems add these in error when
interference or data dropouts occur. Infinite values will cause problems when
it comes to calculating rates, so need to be removed. If found, locations of
these are printed and can be found in the output object under <code style="white-space: pre;">&#8288;$locs&#8288;</code>. Note,
these values are not plotted, so special note should be taken of the warnings
and console printout.
</p>
<p>The remaining data checks in <code>inspect.ft</code> are mainly exploratory and help
diagnose and flag potential issues with the data that might affect rate
calculations. For instance, long experiments may have had sensor dropouts the
user is unaware of. Some might not be major issues. For instance, an uneven
time warning can result from using decimalised minutes, which is a completely
valid time metric, but happens to be numerically unevenly spaced. As an
additional check, if uneven time is found, the minimum and maximum intervals
in the time data are in the console output, so a user can see immediately if
there are large gaps in the data.
</p>
<p>If some of these checks produce warnings, it should <em>generally</em> not hinder
analysis of the data. <code>respR</code> has been coded to rely on linear regressions on
exact data values, and not make assumptions about data spacing or order.
Therefore issues such as missing or NA/NaN values, duplicate or
non-sequential time values, or uneven time spacing should not cause any
erroneous results, as long as they do not occur over large regions of the
data. <code>inspect.ft</code> however outputs locations (row numbers) of where these
issues occur (located in the <code style="white-space: pre;">&#8288;$locs&#8288;</code> element of the output), allowing users
to amend them before analysis. We would recommend that to be completely
confident in any results from analysis of such data, and avoid obscure
errors, these issues be addressed before proceeding.
</p>



<h4>Background control or &quot;blank&quot; experiments</h4>

<p>For experiments in which the specimen data is to be background corrected by a
concurrently-run control experiment, <code>inspect.ft</code> can be used by specifying
the specimen experiment as <code>out.oxy</code>, and the &quot;blank&quot; as the <code>in.oxy</code> input.
In this way, any variations in oxygen in the specimen data due to background
microbial activity, or for any other reason such as fluctuations in inflow
oxygen, are accounted for in the delta oxygen calculations, and therefore in
the rate calculated in <code><a href="#topic+calc_rate.ft">calc_rate.ft()</a></code>. See the vignettes on the website
for examples.
</p>
<p>If the background recordings are experiments with their own outflow and
inflow recordings, which show a generally consistent oxygen delta due to
microbial activity, this can be saved as a separate <code>inspect.ft</code> object, a
background rate calculated in <code><a href="#topic+calc_rate.ft">calc_rate.ft()</a></code>, and this used in
<code><a href="#topic+adjust_rate.ft">adjust_rate.ft()</a></code> as the <code>by</code> input to perform background adjustments to
specimen rates.
</p>
<p><strong>Note</strong>: All background calculations should be from experiments done at the
<em>same flow rate</em> as the specimen experiments to be corrected.
</p>



<h4>S3 Generic Functions</h4>

<p>Saved output objects can be used in the generic S3 functions <code>plot()</code>,
<code>print()</code> and <code>summary()</code>.
</p>

<ul>
<li> <p><code>plot()</code>: plots the result.
</p>
</li>
<li> <p><code>print()</code>: prints a summary of the checks performed on the data. If issues
are found, locations (row numbers) are printed (up to first 20 occurrences).
</p>
</li>
<li> <p><code>summary()</code>: simple wrapper for <code>print()</code> function. See above.
</p>
</li></ul>




<h4>More</h4>

<p>For additional help, documentation, vignettes, and more visit the <code>respR</code>
website at <a href="https://januarharianto.github.io/respR/">https://januarharianto.github.io/respR/</a>
</p>



<h3>Value</h3>

<p>Output is a <code>list</code> object of class <code>inspect.ft</code> containing input
parameters and data, data check summaries, and metadata, which can be
passed to <code><a href="#topic+calc_rate.ft">calc_rate.ft()</a></code> to determine rates. If there are failed checks
or warnings, the row locations of the potentially problematic data can be
found in <code style="white-space: pre;">&#8288;$locs&#8288;</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Inspect outflow and inflow oxygen data
x &lt;- inspect.ft(flowthrough.rd, time = 1, out.oxy = 2,
                in.oxy = 3)
print(x)
plot(x)

# Inspect outflow oxygen data with inflow oxygen as a known value in
# the same units
x &lt;- inspect.ft(flowthrough.rd, time = 1, out.oxy = 2,
                in.oxy.value = 8.90)

# Inspect already calculated delta oxygen data
inspect.ft(flowthrough.rd, time = 1, delta.oxy = 4)

# inspect multiple columns for a quick overview
inspect.ft(flowthrough_mult.rd, time = 1, delta.oxy = 10:12)

# Inspect outflow and use a blank control chamber as background
# correction
#
# This experiment has increasing background respiration over time.
# Inspecting outflow oxygen with inflow header tank concentrations
# suggests specimen rates (bottom delta.oxy plot) are increasing.
inspect.ft(flowthrough_sim.rd, time = 1,
           out.oxy = 2, in.oxy = 4)

# However, inspecting with recordings from a concurrent blank
# control accounts for this and shows specimen rates are level
# when background is taken into account.
inspect.ft(flowthrough_sim.rd, time = 1,
           out.oxy = 2, in.oxy = 3)
</code></pre>

<hr>
<h2 id='intermittent.rd'>Respirometry data of the sea urchin, <em>Heliocidaris Erythrogramma</em></h2><span id='topic+intermittent.rd'></span>

<h3>Description</h3>

<p>Multiple measurements of oxygen consumption in a single sea urchin,
<em>Heliocidaris erythrogramma</em>, obtained using intermittent flow respirometry.
The experiment was conducted at the Sydney Institute of Marine Science in
Sydney, Australia. There are a total of 3 replicates showing declining oxygen,
separated by flushes where new water was added showing increasing oxygen.
Data was collected using a Vernier Optical DO probe (ODO-BTA).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intermittent.rd
</code></pre>


<h3>Format</h3>

<p>A data frame object consisting of 2 columns (time and dissolved
oxygen) and 4831 rows (approx 80 min of data).
</p>


<h3>Details</h3>


<ul>
<li><p> Dissolved oxygen units: <code>mg/L</code>
</p>
</li>
<li><p> Time units: <code>seconds</code>
</p>
</li>
<li><p> Chamber volume (L): <code>2.379</code>
</p>
</li>
<li><p> Specimen ash-free dry mass (kg): <code>0.006955</code>
</p>
</li></ul>

<p>Replicate structure (Rows - Experiment section):
</p>

<ul>
<li> <p><code>1:1900</code>      - Replicate 1
</p>
</li>
<li> <p><code>1901:2100</code>   - Flush 1
</p>
</li>
<li> <p><code>2101:3550</code>   - Replicate 2
</p>
</li>
<li> <p><code>3551:3900</code>   - Flush 2
</p>
</li>
<li> <p><code>3901:4831</code>   - Replicate 3
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Nicholas Carey
</p>

<hr>
<h2 id='kernel_method'>Kernel density function</h2><span id='topic+kernel_method'></span>

<h3>Description</h3>

<p>This is an internal function for <code>auto_rate()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernel_method(dt, width, top_only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kernel_method_+3A_dt">dt</code></td>
<td>
<p>data.frame object.</p>
</td></tr>
<tr><td><code id="kernel_method_+3A_width">width</code></td>
<td>
<p>numeric.</p>
</td></tr>
<tr><td><code id="kernel_method_+3A_top_only">top_only</code></td>
<td>
<p>logical. Should only top ranked result be returned?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object
</p>

<hr>
<h2 id='linear_fit'>Perform a linear regression on a data frame</h2><span id='topic+linear_fit'></span>

<h3>Description</h3>

<p>This is an internal function. Performs <code>lm</code> on a data frame object and returns
its coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linear_fit(dt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="linear_fit_+3A_dt">dt</code></td>
<td>
<p>data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame object of <code>lm()</code> coefficients.
</p>

<hr>
<h2 id='mean.adjust_rate'>Average adjust_rate object rates</h2><span id='topic+mean.adjust_rate'></span>

<h3>Description</h3>

<p>Average adjust_rate object rates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'adjust_rate'
mean(x, pos = NULL, export = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mean.adjust_rate_+3A_x">x</code></td>
<td>
<p>adjust_rate object</p>
</td></tr>
<tr><td><code id="mean.adjust_rate_+3A_pos">pos</code></td>
<td>
<p>integer(s). Which result(s) to average.</p>
</td></tr>
<tr><td><code id="mean.adjust_rate_+3A_export">export</code></td>
<td>
<p>logical. Export averaged values as single value.</p>
</td></tr>
<tr><td><code id="mean.adjust_rate_+3A_...">...</code></td>
<td>
<p>Pass additional inputs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print to console. No returned value.
</p>

<hr>
<h2 id='mean.adjust_rate.ft'>Average adjust_rate.ft rates</h2><span id='topic+mean.adjust_rate.ft'></span>

<h3>Description</h3>

<p>Average adjust_rate.ft rates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'adjust_rate.ft'
mean(x, pos = NULL, export = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mean.adjust_rate.ft_+3A_x">x</code></td>
<td>
<p>adjust_rate.ft object</p>
</td></tr>
<tr><td><code id="mean.adjust_rate.ft_+3A_pos">pos</code></td>
<td>
<p>integer(s). Which result(s) to average.</p>
</td></tr>
<tr><td><code id="mean.adjust_rate.ft_+3A_export">export</code></td>
<td>
<p>logical. Export averaged values as single value.</p>
</td></tr>
<tr><td><code id="mean.adjust_rate.ft_+3A_...">...</code></td>
<td>
<p>Pass additional inputs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print to console. No returned value.
</p>

<hr>
<h2 id='mean.auto_rate'>Average auto_rate object rates</h2><span id='topic+mean.auto_rate'></span>

<h3>Description</h3>

<p>Average auto_rate object rates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'auto_rate'
mean(x, pos = NULL, export = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mean.auto_rate_+3A_x">x</code></td>
<td>
<p>auto_rate object</p>
</td></tr>
<tr><td><code id="mean.auto_rate_+3A_pos">pos</code></td>
<td>
<p>integer(s). Which result(s) to average.</p>
</td></tr>
<tr><td><code id="mean.auto_rate_+3A_export">export</code></td>
<td>
<p>logical. Export averaged values as single value.</p>
</td></tr>
<tr><td><code id="mean.auto_rate_+3A_...">...</code></td>
<td>
<p>Pass additional inputs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print to console. No returned value.
</p>

<hr>
<h2 id='mean.auto_rate.int'>Average auto_rate.int object rates</h2><span id='topic+mean.auto_rate.int'></span>

<h3>Description</h3>

<p>Average auto_rate.int object rates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'auto_rate.int'
mean(x, pos = NULL, export = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mean.auto_rate.int_+3A_x">x</code></td>
<td>
<p>auto_rate.int object</p>
</td></tr>
<tr><td><code id="mean.auto_rate.int_+3A_pos">pos</code></td>
<td>
<p>integer(s). Which replicate rates to average.</p>
</td></tr>
<tr><td><code id="mean.auto_rate.int_+3A_export">export</code></td>
<td>
<p>logical. Export averaged rate as single value.</p>
</td></tr>
<tr><td><code id="mean.auto_rate.int_+3A_...">...</code></td>
<td>
<p>Pass additional inputs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print to console. No returned value.
</p>

<hr>
<h2 id='mean.calc_rate'>Average calc_rate object rates</h2><span id='topic+mean.calc_rate'></span>

<h3>Description</h3>

<p>Average calc_rate object rates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'calc_rate'
mean(x, pos = NULL, export = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mean.calc_rate_+3A_x">x</code></td>
<td>
<p>calc_rate object</p>
</td></tr>
<tr><td><code id="mean.calc_rate_+3A_pos">pos</code></td>
<td>
<p>integer(s). Which result(s) to average.</p>
</td></tr>
<tr><td><code id="mean.calc_rate_+3A_export">export</code></td>
<td>
<p>logical. Export averaged values as single value.</p>
</td></tr>
<tr><td><code id="mean.calc_rate_+3A_...">...</code></td>
<td>
<p>Pass additional inputs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print to console. No returned value.
</p>

<hr>
<h2 id='mean.calc_rate.bg'>Average calc_rate.bg object rates</h2><span id='topic+mean.calc_rate.bg'></span>

<h3>Description</h3>

<p>Average calc_rate.bg object rates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'calc_rate.bg'
mean(x, pos = NULL, export = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mean.calc_rate.bg_+3A_x">x</code></td>
<td>
<p>calc_rate.bg object</p>
</td></tr>
<tr><td><code id="mean.calc_rate.bg_+3A_pos">pos</code></td>
<td>
<p>integer(s). Which result(s) to average.</p>
</td></tr>
<tr><td><code id="mean.calc_rate.bg_+3A_export">export</code></td>
<td>
<p>logical. Export averaged values as single value.</p>
</td></tr>
<tr><td><code id="mean.calc_rate.bg_+3A_...">...</code></td>
<td>
<p>Pass additional inputs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print to console. No returned value.
</p>

<hr>
<h2 id='mean.calc_rate.ft'>Average calc_rate.ft object rates</h2><span id='topic+mean.calc_rate.ft'></span>

<h3>Description</h3>

<p>Average calc_rate.ft object rates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'calc_rate.ft'
mean(x, pos = NULL, export = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mean.calc_rate.ft_+3A_x">x</code></td>
<td>
<p>calc_rate.ft object</p>
</td></tr>
<tr><td><code id="mean.calc_rate.ft_+3A_pos">pos</code></td>
<td>
<p>integer(s). Which result(s) to average.</p>
</td></tr>
<tr><td><code id="mean.calc_rate.ft_+3A_export">export</code></td>
<td>
<p>logical. Export averaged values as single value.</p>
</td></tr>
<tr><td><code id="mean.calc_rate.ft_+3A_...">...</code></td>
<td>
<p>Pass additional inputs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print to console. No returned value.
</p>

<hr>
<h2 id='mean.calc_rate.int'>Average calc_rate.int object rates</h2><span id='topic+mean.calc_rate.int'></span>

<h3>Description</h3>

<p>Average calc_rate.int object rates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'calc_rate.int'
mean(x, pos = NULL, export = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mean.calc_rate.int_+3A_x">x</code></td>
<td>
<p>calc_rate.int object</p>
</td></tr>
<tr><td><code id="mean.calc_rate.int_+3A_pos">pos</code></td>
<td>
<p>integer(s). Which replicate rates to average.</p>
</td></tr>
<tr><td><code id="mean.calc_rate.int_+3A_export">export</code></td>
<td>
<p>logical. Export averaged rate as single value.</p>
</td></tr>
<tr><td><code id="mean.calc_rate.int_+3A_...">...</code></td>
<td>
<p>Pass additional inputs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print to console. No returned value.
</p>

<hr>
<h2 id='mean.convert_DO'>Average convert_DO object values</h2><span id='topic+mean.convert_DO'></span>

<h3>Description</h3>

<p>Average convert_DO object values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'convert_DO'
mean(x, pos = NULL, export = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mean.convert_DO_+3A_x">x</code></td>
<td>
<p>convert_DO object</p>
</td></tr>
<tr><td><code id="mean.convert_DO_+3A_pos">pos</code></td>
<td>
<p>integer(s). Which result(s) to average.</p>
</td></tr>
<tr><td><code id="mean.convert_DO_+3A_export">export</code></td>
<td>
<p>logical. Export averaged values as single value.</p>
</td></tr>
<tr><td><code id="mean.convert_DO_+3A_...">...</code></td>
<td>
<p>Pass additional inputs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print to console. No returned value.
</p>

<hr>
<h2 id='mean.convert_rate'>Average convert_rate object rates</h2><span id='topic+mean.convert_rate'></span>

<h3>Description</h3>

<p>Average convert_rate object rates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'convert_rate'
mean(x, pos = NULL, export = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mean.convert_rate_+3A_x">x</code></td>
<td>
<p>convert_rate object</p>
</td></tr>
<tr><td><code id="mean.convert_rate_+3A_pos">pos</code></td>
<td>
<p>integer(s). Which result(s) to average.</p>
</td></tr>
<tr><td><code id="mean.convert_rate_+3A_export">export</code></td>
<td>
<p>logical. Export averaged values as single value.</p>
</td></tr>
<tr><td><code id="mean.convert_rate_+3A_...">...</code></td>
<td>
<p>Pass additional inputs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print to console. No returned value.
</p>

<hr>
<h2 id='mean.convert_rate.ft'>Average convert_rate.ft object rates</h2><span id='topic+mean.convert_rate.ft'></span>

<h3>Description</h3>

<p>Average convert_rate.ft object rates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'convert_rate.ft'
mean(x, pos = NULL, export = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mean.convert_rate.ft_+3A_x">x</code></td>
<td>
<p>convert_rate.ft object</p>
</td></tr>
<tr><td><code id="mean.convert_rate.ft_+3A_pos">pos</code></td>
<td>
<p>integer(s). Which result(s) to average.</p>
</td></tr>
<tr><td><code id="mean.convert_rate.ft_+3A_export">export</code></td>
<td>
<p>logical. Export averaged values as single value.</p>
</td></tr>
<tr><td><code id="mean.convert_rate.ft_+3A_...">...</code></td>
<td>
<p>Pass additional inputs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print to console. No returned value.
</p>

<hr>
<h2 id='mean.inspect'>Average inspect object rates</h2><span id='topic+mean.inspect'></span>

<h3>Description</h3>

<p>Average inspect object rates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'inspect'
mean(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mean.inspect_+3A_x">x</code></td>
<td>
<p>inspect object</p>
</td></tr>
<tr><td><code id="mean.inspect_+3A_...">...</code></td>
<td>
<p>Pass additional inputs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print to console. No returned value.
</p>

<hr>
<h2 id='mean.inspect.ft'>Average inspect.ft object rates</h2><span id='topic+mean.inspect.ft'></span>

<h3>Description</h3>

<p>Average inspect.ft object rates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'inspect.ft'
mean(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mean.inspect.ft_+3A_x">x</code></td>
<td>
<p>calc_rate.bg object</p>
</td></tr>
<tr><td><code id="mean.inspect.ft_+3A_...">...</code></td>
<td>
<p>Pass additional inputs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print to console. No returned value.
</p>

<hr>
<h2 id='mean.oxy_crit'>Average oxy_crit object rates</h2><span id='topic+mean.oxy_crit'></span>

<h3>Description</h3>

<p>Average oxy_crit object rates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'oxy_crit'
mean(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mean.oxy_crit_+3A_x">x</code></td>
<td>
<p>oxy_crit object</p>
</td></tr>
<tr><td><code id="mean.oxy_crit_+3A_...">...</code></td>
<td>
<p>Pass additional inputs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print to console. No returned value.
</p>

<hr>
<h2 id='method.val'>Validate adjust_rate or auto_rate or oxy_crit method input</h2><span id='topic+method.val'></span>

<h3>Description</h3>

<p>Validate adjust_rate or auto_rate or oxy_crit method input
</p>


<h3>Usage</h3>

<pre><code class='language-R'>method.val(method, source = "adjust_rate")
</code></pre>

<hr>
<h2 id='midpt'>Get midpoint between two values or within a vector
For getting midpoint timestamps from Time data</h2><span id='topic+midpt'></span>

<h3>Description</h3>

<p>Get midpoint between two values or within a vector
For getting midpoint timestamps from Time data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>midpt(p)
</code></pre>

<hr>
<h2 id='nainf.omit'>Omit NA, NaN, Inf and -Inf from a vector or dataframe columns</h2><span id='topic+nainf.omit'></span>

<h3>Description</h3>

<p>For using with, for example, range to get axis range values in 'inspect'.
Previously, na.omit was used, then discovered data files with Inf values.
This causes axis limit range to be Inf, and xlim/ylim don't accept infinite
axes!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nainf.omit(x)
</code></pre>


<h3>Details</h3>

<p>If x is dataframe, it returns a vector of all columns appended together.
Only useful for getting range in this case, don't use for anything else.
</p>


<h3>Value</h3>

<p>original vector without NA or Inf values or df all cols appended without these
</p>

<hr>
<h2 id='overlap.ft.p'>Plot convert_rate.ft summary tables</h2><span id='topic+overlap.ft.p'></span>

<h3>Description</h3>

<p>Plots <code>convert_rate.ft</code> summary table regressions in a way that
visualises how they are positioned within the data timeseries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overlap.ft.p(
  x,
  highlight = NULL,
  pos = NULL,
  legend = TRUE,
  quiet = FALSE,
  rate.rev = TRUE,
  msg = "overlap.ft.p",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="overlap.ft.p_+3A_x">x</code></td>
<td>
<p><code>convert_rate.ft</code>, <code>convert_rate.ft_select</code> object</p>
</td></tr>
<tr><td><code id="overlap.ft.p_+3A_highlight">highlight</code></td>
<td>
<p>integer. Which result in the summary table to highlight on
the plots. Defaults to 1. If it is outside the range of the summary rows it
will default to 1.</p>
</td></tr>
<tr><td><code id="overlap.ft.p_+3A_pos">pos</code></td>
<td>
<p>integer(s). Choose which summary table rows to plot.</p>
</td></tr>
<tr><td><code id="overlap.ft.p_+3A_legend">legend</code></td>
<td>
<p>logical. Suppress plot legends.</p>
</td></tr>
<tr><td><code id="overlap.ft.p_+3A_quiet">quiet</code></td>
<td>
<p>logical. Suppress console output.</p>
</td></tr>
<tr><td><code id="overlap.ft.p_+3A_msg">msg</code></td>
<td>
<p>string. For adding custom text to start of messages.</p>
</td></tr>
<tr><td><code id="overlap.ft.p_+3A_...">...</code></td>
<td>
<p>Allows additional plotting controls to be passed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the auto_rate object results
</p>

<hr>
<h2 id='overlap.p'>Plot convert_rate and auto_rate summary tables</h2><span id='topic+overlap.p'></span>

<h3>Description</h3>

<p>Plots <code>convert_rate</code> and <code>auto_rate</code> summary table regressions in a way that
visualises how they are positioned within the data timeseries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overlap.p(
  x,
  highlight = NULL,
  pos = NULL,
  legend = TRUE,
  quiet = FALSE,
  msg = "overlap.p",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="overlap.p_+3A_x">x</code></td>
<td>
<p><code>convert_rate</code>, <code>convert_rate_select</code>, or <code>auto_rate</code> object</p>
</td></tr>
<tr><td><code id="overlap.p_+3A_highlight">highlight</code></td>
<td>
<p>integer. Which result in the summary table to highlight on
the plots. Defaults to 1. If it is outside the range of the summary rows it
will default to 1.</p>
</td></tr>
<tr><td><code id="overlap.p_+3A_pos">pos</code></td>
<td>
<p>integer(s). Choose which summary table rows to plot.</p>
</td></tr>
<tr><td><code id="overlap.p_+3A_legend">legend</code></td>
<td>
<p>logical. Suppress plot legends.</p>
</td></tr>
<tr><td><code id="overlap.p_+3A_quiet">quiet</code></td>
<td>
<p>logical. Suppress console output.</p>
</td></tr>
<tr><td><code id="overlap.p_+3A_msg">msg</code></td>
<td>
<p>string. For adding custom text to start of messages.</p>
</td></tr>
<tr><td><code id="overlap.p_+3A_...">...</code></td>
<td>
<p>Allows additional plotting controls to be passed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the auto_rate object results
</p>

<hr>
<h2 id='oxy_crit'>Calculate critical oxygen values, such as PCrit</h2><span id='topic+oxy_crit'></span>

<h3>Description</h3>

<p>Identifies critical oxygen values, the oxygen tension or concentration below
which an uptake rate transitions from independent to dependent on the oxygen
supply, typically known as <em>PCrit</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oxy_crit(
  x,
  method = "bsr",
  time = NULL,
  oxygen = NULL,
  rate = NULL,
  width = 0.1,
  parallel = FALSE,
  thin = 5000,
  plot = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="oxy_crit_+3A_x">x</code></td>
<td>
<p>object of class <code>inspect</code> or a <code>data.frame</code> containing either paired
oxygen~time values, or paired rate~oxygen values. See Details.</p>
</td></tr>
<tr><td><code id="oxy_crit_+3A_method">method</code></td>
<td>
<p>string. Defaults to <code>"bsr"</code>. Critical oxygen value analysis
method. Either <code>"bsr"</code> or <code>"segmented"</code>. See Details.</p>
</td></tr>
<tr><td><code id="oxy_crit_+3A_time">time</code></td>
<td>
<p>integer or string. Defaults to 1. Specifies column number or
column name of the time data.</p>
</td></tr>
<tr><td><code id="oxy_crit_+3A_oxygen">oxygen</code></td>
<td>
<p>integer or string. Defaults to 2. Specifies column number or
column name of the oxygen data.</p>
</td></tr>
<tr><td><code id="oxy_crit_+3A_rate">rate</code></td>
<td>
<p>integer or string. Defaults to NULL. Specifies column number or
column name of the rate data.</p>
</td></tr>
<tr><td><code id="oxy_crit_+3A_width">width</code></td>
<td>
<p>numeric value between 0 and 1 representing proportion of the
total data length. Determines the width of the rolling regression used to
determine the rolling rate and the rolling mean of oxygen values the rate
is paired with. Defaults to 0.1, representing 10% of total rows.</p>
</td></tr>
<tr><td><code id="oxy_crit_+3A_parallel">parallel</code></td>
<td>
<p>logical. Defaults to FALSE. Enables parallel processing for
computationally intensive analyses of large datasets.</p>
</td></tr>
<tr><td><code id="oxy_crit_+3A_thin">thin</code></td>
<td>
<p>integer. Defaults to 5000. Number of rows to subsample <code>x</code> data
to before running <code>"bsr"</code> analysis. No effect on datasets smaller than this
value or with <code>"segmented"</code> method. To perform no subsampling enter as
<code>NULL</code>. See Details.</p>
</td></tr>
<tr><td><code id="oxy_crit_+3A_plot">plot</code></td>
<td>
<p>logical. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="oxy_crit_+3A_...">...</code></td>
<td>
<p>Allows additional plotting controls to be passed, such as <code>legend = FALSE</code>, <code>quiet = TRUE</code>, <code>rate.rev = FALSE</code>, and <code>panel</code>. See Plotting
section.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In earlier versions of <code>respR</code>, this function was known as <code>pcrit</code> or
<code>calc_pcrit</code>. It was renamed to avoid conflicts with functions of the same
name in another package, and also because technically the <em>P</em> in  <em>PCrit</em>
stands for the partial <em>pressure</em> of oxygen. Since the function returns the
value in the units of the data as entered, whether they are concentration or
pressure units, this terminology can be technically in error. Instead, for
the purposes of the documentation we refer to this as the <em>Critical Oxygen
Value</em>, or &quot;<em>COV</em>&quot;. If the units of oxygen are partial pressure units (e.g.
kPa), this is equivalent to PCrit, otherwise they should be reported with
this in mind.
</p>


<h4>Methods</h4>

<p>The <code>oxy_crit()</code> function provides two methods (one of which outputs two
results) to calculate the <em>COV</em>. These are selected using the <code>method</code> input.
</p>


<h5>Broken Stick Regression:    <code>method = "bsr"</code></h5>

<p>This is the default method, adapted from the “Broken-Stick” regression
(<em>BSR</em>) approach, of Yeager &amp; Ultsch (1989), in which two segments of the
data are iteratively fitted and the intersection with the smallest sum of the
residual sum of squares between the two linear models is the estimated <em>COV</em>.
Two slightly different ways of reporting this breakpoint are detailed by
Yeager &amp; Ultsch (1989); the <em>intercept</em> and <em>midpoint</em>. These are usually
very close in value, and the function returns both.
</p>
<p>The <code>thin</code> input influences the <em>BSR</em> analysis. The method is very
computationally intensive, so to speed up analyses the <code>thin</code> input will
subsample datasets longer than this input to this number or rows before
analysis. The default value of 5000 has in testing provided a good balance
between speed and results accuracy and repeatability. However, results may
vary with different datasets, so users should experiment with varying the
value. To perform no subsampling and use the entire dataset enter <code>thin = NULL</code>. It has no effect on datasets shorter than the <code>thin</code> input.
</p>



<h5>Segmented Regression:    <code>method = "segmented"</code></h5>

<p>The second method is a wrapper for the &quot;Segmented&quot; regression approach,
available as part of the <code>segmented</code> R package (Muggeo 2008), which estimates
the <em>COV</em> by iteratively fitting two intersecting models and selecting the
value that minimises the “gap” between the fitted lines.
</p>




<h4>Inputs</h4>

<p>The data input <code>x</code> should be an <code>inspect</code> object or <code>data.frame</code> containing
oxygen~time data, or a <code>data.frame</code> containing rate~oxygen data.
</p>


<h5>Oxygen ~ Time data</h5>

<p>This is the typical input, where a timeseries of oxygen concentrations or
partial pressures against time has been recorded, generally down to a very
low value of oxygen. A column of <code>time</code> and a column of <code>oxygen</code> should be
specified. The function defaults to <code>time = 1</code> and <code>oxygen = 2</code> if no other
inputs are entered. These can also be specified using the column names.
</p>
<p>If an <code>inspect</code> object is entered as the <code>x</code> input, the data frame is
extracted automatically and column identifiers are not required since these
were already entered in <code>inspect</code>. Note, if multiple <code>oxygen</code> columns were
entered in <code>inspect</code> only the first entered one will be used in <code>oxy_crit</code>.
</p>
<p>To calculate the <em>COV</em>, the function requires data in the form of oxygen
uptake rate against oxygen value. Therefore, the function performs a rolling
regression on the oxygen~time data to determine rates, and pairs these
against a rolling mean of the oxygen data. The function then performs the
selected analysis <code>method</code> on these data. The width of the rolling regression
and rolling mean is determined by the <code>width</code> input. The default is 0.1,
representing 10% of the length of the data. This performs well in testing,
however performance may vary with data that has abrupt changes in rate, or is
particularly noisy. Users should experiment with different <code>width</code> values to
see how it affects results, and report this with their results and analysis
parameters.
</p>



<h5>Rate ~ Oxygen data</h5>

<p>Alternatively, if existing rolling oxygen uptake rates have been calculated,
and have appropriate paired oxygen concentration or partial pressure values,
these can be entered with the <code>rate</code> and <code>oxygen</code> inputs specifying the
respective columns as either numbers or the column names. In this case the
function performs the selected analysis <code>method</code> on these data directly
without any processing. The <code>width</code> input in this case is not relevant and is
ignored.
</p>
<p>This option can only be used with data frame <code>x</code> inputs. Note, other columns
such as time data may be present in the input, but are not required so need
not be specified.
</p>




<h4>Plot</h4>

<p>A plot is produced (provided <code>plot = TRUE</code>) of the input data and results.
The top panel is the input data, either the oxygen~time timeseries, or the
rate~oxygen series, depending on what was entered in <code>x</code>. If the former, the
critical oxygen value is indicated by a horizontal line, or two lines in the
case of the Broken-Stick analysis. Note, since the two <em>BSR</em> results are
usually close in value these may overlay each other.
</p>
<p>The bottom plot is the rate~oxygen series upon which the analysis was
conducted, either as input or as calculated. Critical oxygen values are
indicated by vertical lines, and regression fits upon which the analysis was
based by black dashed lines.
</p>
<p>Note, that in <code>respR</code> oxygen uptake rates are negative since they represent a
negative slope of oxygen against time, therefore by default rates are plotted
on a reverse y-axis so higher rates appear higher on the plot. If analysing
already calculated rates which are positive values this behaviour can be
reversed by passing <code>rate.rev = FALSE</code> in either the main function call or
when calling <code>plot()</code> on the output object. There is no issue with using
positive rate values; they will give identical critical value results in the
analysis.
</p>


<h5>Additional plotting options</h5>

<p>If the legend obscures parts of the plot they can be suppressed using <code>legend = FALSE</code>. Suppress console output messages with <code>quiet = TRUE</code>. Each panel
can be plotted on its own using <code>panel = 1</code> or <code>panel = 2</code>. If using
already-calculated, positive rate values to identify critical oxygen values,
the y-axis of the rolling rate plot can be plotted <em>not</em> reversed by passing
<code>rate.rev = FALSE</code> These inputs can be passed in either the main <code>oxy_crit</code>
call or when calling <code>plot()</code> on the output object. If axis labels
(particularly y-axis) are difficult to read, <code>las = 2</code> can be passed to make
axis labels horizontal, and <code>oma</code> (outer margins, default <code>oma = c(0.4, 1, 1.5, 0.4)</code>), and <code>mai</code> (inner margins, default <code>mai = c(0.3, 0.15, 0.35, 0.15)</code>) used to adjust plot margins.
</p>




<h4>S3 Generic Functions</h4>

<p>Saved output objects can be used in the generic S3 functions <code>print()</code> and
<code>summary()</code>.
</p>

<ul>
<li> <p><code>print()</code>: prints the critical oxygen value for the particular <code>method</code>
used.
</p>
</li>
<li> <p><code>summary()</code>: prints critical oxygen value, plus additional coefficients and
metadata for the particular <code>method</code> used. See Yeager &amp; Ultsch (1989) and
Muggeo (2008) for what these represent. The summary can be exported as a
separate data frame by passing <code>export = TRUE</code>.
</p>
</li></ul>




<h4>More</h4>

<p>For additional help, documentation, vignettes, and more visit the <code>respR</code>
website at <a href="https://januarharianto.github.io/respR/">https://januarharianto.github.io/respR/</a>
</p>



<h3>Value</h3>

<p>Output is a <code>list</code> object of class <code>oxy_crit</code> containing input
parameters and data, various summary data, metadata, and the primary output
of interest <code style="white-space: pre;">&#8288;$crit&#8288;</code>, which is the critical oxygen value in the units of the
oxygen data as entered. This can be converted to additional units using
<code><a href="#topic+convert_DO">convert_DO()</a></code>. Note, if the Broken-Stick analysis (<code>method == "bsr"</code>)
has been used, <code style="white-space: pre;">&#8288;$crit&#8288;</code> will contain two results; <code style="white-space: pre;">&#8288;$crit.intercept&#8288;</code> and
<code style="white-space: pre;">&#8288;$crit.midpoint&#8288;</code>. For full explanation of the difference between these see
Yeager &amp; Ultsch (1989), however they are generally very close in value.
</p>


<h3>References</h3>

<p>Yeager DP, Ultsch GR (1989) Physiological regulation and
conformation: A BASIC program for the determination of critical points.
Physiological Zoology 62:888–907. doi: 10.1086/physzool.62.4.30157935
</p>
<p>Muggeo V (2008) Segmented: an R package to fit regression models with
broken-line relationships. R News 8:20–25.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Run on oxygen~time data.frame with default inputs
oxy_crit(squid.rd)

## Try a lower 'thin' input to speed up analysis
oxy_crit(squid.rd, thin = 1000)

## Use the Segmented method instead
oxy_crit(squid.rd, method = "segmented")

## Experiment with different 'width' input
# Higher widths tend to oversmooth data
oxy_crit(squid.rd, method = "segmented", width = 0.2)
# Lower width in this case gives very similar result to default 0.1
oxy_crit(squid.rd, method = "segmented", width = 0.05)

## Run on oxygen~time data in 'inspect' object
insp &lt;- inspect(squid.rd, time = 1, oxygen = 2)
oxy_crit(insp)

## Run on already calculated rate~oxygen data
# Calculate a rolling rate
rate &lt;- auto_rate(squid.rd,
                  method = "rolling",
                  width = 0.1,
                  plot = FALSE)$rate

## Calculate a rolling mean oxygen
oxy &lt;- na.omit(roll::roll_mean(squid.rd[[2]],
                               width = 0.1 * nrow(squid.rd)))
## Combine to data.frame
squid_rate_oxy &lt;- data.frame(oxy, rate)
## Perform COV analysis
oxy_crit(squid_rate_oxy, oxygen = 1, rate = 2)

</code></pre>

<hr>
<h2 id='plot.adjust_rate'>Plot adjust_rate objects</h2><span id='topic+plot.adjust_rate'></span>

<h3>Description</h3>

<p>Plot adjust_rate objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'adjust_rate'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.adjust_rate_+3A_x">x</code></td>
<td>
<p>calc_rate.bg object</p>
</td></tr>
<tr><td><code id="plot.adjust_rate_+3A_...">...</code></td>
<td>
<p>Pass additional plotting parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot. No returned value.
</p>

<hr>
<h2 id='plot.adjust_rate.ft'>Plot adjust_rate.ft objects</h2><span id='topic+plot.adjust_rate.ft'></span>

<h3>Description</h3>

<p>Plot adjust_rate.ft objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'adjust_rate.ft'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.adjust_rate.ft_+3A_x">x</code></td>
<td>
<p>adjust_rate.ft object</p>
</td></tr>
<tr><td><code id="plot.adjust_rate.ft_+3A_...">...</code></td>
<td>
<p>Pass additional plotting parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot. No returned value.
</p>

<hr>
<h2 id='plot.auto_rate'>Plot auto_rate objects</h2><span id='topic+plot.auto_rate'></span>

<h3>Description</h3>

<p>Plot auto_rate objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'auto_rate'
plot(
  x,
  pos = 1,
  panel = FALSE,
  quiet = FALSE,
  legend = TRUE,
  rate.rev = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.auto_rate_+3A_x">x</code></td>
<td>
<p>auto_rate object</p>
</td></tr>
<tr><td><code id="plot.auto_rate_+3A_pos">pos</code></td>
<td>
<p>integer. Which result to plot.</p>
</td></tr>
<tr><td><code id="plot.auto_rate_+3A_panel">panel</code></td>
<td>
<p>integer. Which panel to plot individually.</p>
</td></tr>
<tr><td><code id="plot.auto_rate_+3A_quiet">quiet</code></td>
<td>
<p>logical. Suppress console output.</p>
</td></tr>
<tr><td><code id="plot.auto_rate_+3A_legend">legend</code></td>
<td>
<p>logical. Suppress labels and legends.</p>
</td></tr>
<tr><td><code id="plot.auto_rate_+3A_rate.rev">rate.rev</code></td>
<td>
<p>logical. Control direction of y-axis in rolling rate plot.</p>
</td></tr>
<tr><td><code id="plot.auto_rate_+3A_...">...</code></td>
<td>
<p>Pass additional plotting parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot. No returned value.
</p>

<hr>
<h2 id='plot.auto_rate.int'>Plot auto_rate.int objects</h2><span id='topic+plot.auto_rate.int'></span>

<h3>Description</h3>

<p>Plot auto_rate.int objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'auto_rate.int'
plot(x, pos = NULL, quiet = FALSE, legend = FALSE, type = "rep", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.auto_rate.int_+3A_x">x</code></td>
<td>
<p>auto_rate.int object</p>
</td></tr>
<tr><td><code id="plot.auto_rate.int_+3A_pos">pos</code></td>
<td>
<p>integer. Which replicate(s) to plot up to a maximum of 20.
Defaults to 1:20.</p>
</td></tr>
<tr><td><code id="plot.auto_rate.int_+3A_quiet">quiet</code></td>
<td>
<p>logical. Suppress console output.</p>
</td></tr>
<tr><td><code id="plot.auto_rate.int_+3A_legend">legend</code></td>
<td>
<p>logical. Suppress labels and legends.</p>
</td></tr>
<tr><td><code id="plot.auto_rate.int_+3A_type">type</code></td>
<td>
<p>logical. Type of plot to produce. <code>"rep"</code>, <code>"full"</code>, or
<code>"ar"</code>. Defaults to <code>"rep"</code>. See Details.</p>
</td></tr>
<tr><td><code id="plot.auto_rate.int_+3A_...">...</code></td>
<td>
<p>Pass additional plotting parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot. No returned value.
</p>

<hr>
<h2 id='plot.calc_rate'>Plot calc_rate objects</h2><span id='topic+plot.calc_rate'></span>

<h3>Description</h3>

<p>Plot calc_rate objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'calc_rate'
plot(x, pos = 1, quiet = FALSE, panel = NULL, legend = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.calc_rate_+3A_x">x</code></td>
<td>
<p>calc_rate object</p>
</td></tr>
<tr><td><code id="plot.calc_rate_+3A_pos">pos</code></td>
<td>
<p>integer. Which result to plot.</p>
</td></tr>
<tr><td><code id="plot.calc_rate_+3A_quiet">quiet</code></td>
<td>
<p>logical. Suppress console output.</p>
</td></tr>
<tr><td><code id="plot.calc_rate_+3A_panel">panel</code></td>
<td>
<p>integer. Which panel to plot individually.</p>
</td></tr>
<tr><td><code id="plot.calc_rate_+3A_legend">legend</code></td>
<td>
<p>logical. Suppress labels and legends.</p>
</td></tr>
<tr><td><code id="plot.calc_rate_+3A_...">...</code></td>
<td>
<p>Pass additional plotting parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot. No returned value.
</p>

<hr>
<h2 id='plot.calc_rate.bg'>Plot calc_rate.bg objects</h2><span id='topic+plot.calc_rate.bg'></span>

<h3>Description</h3>

<p>Plot calc_rate.bg objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'calc_rate.bg'
plot(x, pos = NULL, quiet = FALSE, legend = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.calc_rate.bg_+3A_x">x</code></td>
<td>
<p>calc_rate.bg object</p>
</td></tr>
<tr><td><code id="plot.calc_rate.bg_+3A_pos">pos</code></td>
<td>
<p>integer. Which result to plot.</p>
</td></tr>
<tr><td><code id="plot.calc_rate.bg_+3A_quiet">quiet</code></td>
<td>
<p>logical. Suppress console output.</p>
</td></tr>
<tr><td><code id="plot.calc_rate.bg_+3A_legend">legend</code></td>
<td>
<p>logical. Suppress labels and legends.</p>
</td></tr>
<tr><td><code id="plot.calc_rate.bg_+3A_...">...</code></td>
<td>
<p>Pass additional plotting parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot. No returned value.
</p>

<hr>
<h2 id='plot.calc_rate.ft'>Plot calc_rate.ft objects</h2><span id='topic+plot.calc_rate.ft'></span>

<h3>Description</h3>

<p>Plot calc_rate.ft objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'calc_rate.ft'
plot(x, pos = NULL, quiet = FALSE, legend = TRUE, rate.rev = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.calc_rate.ft_+3A_x">x</code></td>
<td>
<p>calc_rate.bg object</p>
</td></tr>
<tr><td><code id="plot.calc_rate.ft_+3A_pos">pos</code></td>
<td>
<p>integer. Which result to plot.</p>
</td></tr>
<tr><td><code id="plot.calc_rate.ft_+3A_quiet">quiet</code></td>
<td>
<p>logical. Suppress console output.</p>
</td></tr>
<tr><td><code id="plot.calc_rate.ft_+3A_legend">legend</code></td>
<td>
<p>logical. Suppress labels and legends.</p>
</td></tr>
<tr><td><code id="plot.calc_rate.ft_+3A_rate.rev">rate.rev</code></td>
<td>
<p>logical. Control direction of y-axis in rolling rate plot.</p>
</td></tr>
<tr><td><code id="plot.calc_rate.ft_+3A_...">...</code></td>
<td>
<p>Pass additional plotting parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot. No returned value.
</p>

<hr>
<h2 id='plot.calc_rate.int'>Plot calc_rate.int objects</h2><span id='topic+plot.calc_rate.int'></span>

<h3>Description</h3>

<p>Plot calc_rate.int objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'calc_rate.int'
plot(x, pos = NULL, quiet = FALSE, legend = FALSE, type = "rep", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.calc_rate.int_+3A_x">x</code></td>
<td>
<p>calc_rate.int object</p>
</td></tr>
<tr><td><code id="plot.calc_rate.int_+3A_pos">pos</code></td>
<td>
<p>integer. Which replicate(s) to plot up to a maximum of 20.
Defaults to 1:20.</p>
</td></tr>
<tr><td><code id="plot.calc_rate.int_+3A_quiet">quiet</code></td>
<td>
<p>logical. Suppress console output.</p>
</td></tr>
<tr><td><code id="plot.calc_rate.int_+3A_legend">legend</code></td>
<td>
<p>logical. Suppress labels and legends.</p>
</td></tr>
<tr><td><code id="plot.calc_rate.int_+3A_type">type</code></td>
<td>
<p>logical. Type of plot to produce. <code>"rep"</code>, <code>"full"</code>, or
<code>"cr"</code>. Defaults to <code>"rep"</code>. See Details.</p>
</td></tr>
<tr><td><code id="plot.calc_rate.int_+3A_...">...</code></td>
<td>
<p>Pass additional plotting parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot. No returned value.
</p>

<hr>
<h2 id='plot.convert_DO'>Plot convert_DO objects</h2><span id='topic+plot.convert_DO'></span>

<h3>Description</h3>

<p>Plot convert_DO objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'convert_DO'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.convert_DO_+3A_x">x</code></td>
<td>
<p>convert_DO object</p>
</td></tr>
<tr><td><code id="plot.convert_DO_+3A_...">...</code></td>
<td>
<p>Pass additional plotting parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot. No returned value.
</p>

<hr>
<h2 id='plot.convert_rate'>Plot convert_rate objects</h2><span id='topic+plot.convert_rate'></span>

<h3>Description</h3>

<p>Plot convert_rate objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'convert_rate'
plot(
  x,
  type = "full",
  pos = NULL,
  quiet = FALSE,
  highlight = NULL,
  legend = TRUE,
  rate.rev = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.convert_rate_+3A_x">x</code></td>
<td>
<p>convert_rate object</p>
</td></tr>
<tr><td><code id="plot.convert_rate_+3A_type">type</code></td>
<td>
<p>&quot;full&quot;, &quot;rate&quot;, &quot;overlap&quot;</p>
</td></tr>
<tr><td><code id="plot.convert_rate_+3A_pos">pos</code></td>
<td>
<p>Which summary rows to plot?</p>
</td></tr>
<tr><td><code id="plot.convert_rate_+3A_quiet">quiet</code></td>
<td>
<p>logical. Suppress console output.</p>
</td></tr>
<tr><td><code id="plot.convert_rate_+3A_highlight">highlight</code></td>
<td>
<p>Which to highlight in overlap plots.</p>
</td></tr>
<tr><td><code id="plot.convert_rate_+3A_legend">legend</code></td>
<td>
<p>logical. Suppress labels and legends.</p>
</td></tr>
<tr><td><code id="plot.convert_rate_+3A_rate.rev">rate.rev</code></td>
<td>
<p>logical. Control direction of y-axis in rate plot.</p>
</td></tr>
<tr><td><code id="plot.convert_rate_+3A_...">...</code></td>
<td>
<p>Pass additional plotting parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot. No returned value.
</p>

<hr>
<h2 id='plot.convert_rate.ft'>Plot convert_rate.ft objects</h2><span id='topic+plot.convert_rate.ft'></span>

<h3>Description</h3>

<p>Plot convert_rate.ft objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'convert_rate.ft'
plot(
  x,
  type = "full",
  pos = NULL,
  quiet = FALSE,
  highlight = NULL,
  legend = TRUE,
  rate.rev = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.convert_rate.ft_+3A_x">x</code></td>
<td>
<p>convert_rate.ft object</p>
</td></tr>
<tr><td><code id="plot.convert_rate.ft_+3A_type">type</code></td>
<td>
<p>&quot;full&quot;, &quot;rate&quot;, or &quot;overlap&quot;</p>
</td></tr>
<tr><td><code id="plot.convert_rate.ft_+3A_pos">pos</code></td>
<td>
<p>Which summary rows to plot?</p>
</td></tr>
<tr><td><code id="plot.convert_rate.ft_+3A_quiet">quiet</code></td>
<td>
<p>logical. Suppress console output.</p>
</td></tr>
<tr><td><code id="plot.convert_rate.ft_+3A_highlight">highlight</code></td>
<td>
<p>Which summary row result to highlight in overlap plots.</p>
</td></tr>
<tr><td><code id="plot.convert_rate.ft_+3A_legend">legend</code></td>
<td>
<p>logical. Suppress labels and legends.</p>
</td></tr>
<tr><td><code id="plot.convert_rate.ft_+3A_rate.rev">rate.rev</code></td>
<td>
<p>logical. Control direction of y-axis in rate plot.</p>
</td></tr>
<tr><td><code id="plot.convert_rate.ft_+3A_...">...</code></td>
<td>
<p>Pass additional plotting parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot. No returned value.
</p>

<hr>
<h2 id='plot.inspect'>Plot inspect objects</h2><span id='topic+plot.inspect'></span>

<h3>Description</h3>

<p>Plot inspect objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'inspect'
plot(
  x,
  width = NULL,
  pos = NULL,
  quiet = FALSE,
  legend = TRUE,
  rate.rev = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.inspect_+3A_x">x</code></td>
<td>
<p>inspect object</p>
</td></tr>
<tr><td><code id="plot.inspect_+3A_width">width</code></td>
<td>
<p>numeric. Width of rolling regression to determine rates in
rolling rate plot as proportion of total data length (0 to 1)</p>
</td></tr>
<tr><td><code id="plot.inspect_+3A_pos">pos</code></td>
<td>
<p>integer. Which result to plot.</p>
</td></tr>
<tr><td><code id="plot.inspect_+3A_quiet">quiet</code></td>
<td>
<p>logical. Suppress console output.</p>
</td></tr>
<tr><td><code id="plot.inspect_+3A_legend">legend</code></td>
<td>
<p>logical. Suppress labels and legends.</p>
</td></tr>
<tr><td><code id="plot.inspect_+3A_rate.rev">rate.rev</code></td>
<td>
<p>logical. Control direction of y-axis in rolling rate plot.</p>
</td></tr>
<tr><td><code id="plot.inspect_+3A_...">...</code></td>
<td>
<p>Pass additional plotting parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot. No returned value.
</p>

<hr>
<h2 id='plot.inspect.ft'>Plot inspect.ft objects</h2><span id='topic+plot.inspect.ft'></span>

<h3>Description</h3>

<p>Plot inspect.ft objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'inspect.ft'
plot(
  x,
  width = NULL,
  pos = NULL,
  quiet = FALSE,
  legend = TRUE,
  rate.rev = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.inspect.ft_+3A_x">x</code></td>
<td>
<p>inspect.ft object</p>
</td></tr>
<tr><td><code id="plot.inspect.ft_+3A_width">width</code></td>
<td>
<p>numeric. Smoothing factor (rolling mean) for delta oxygen values
as proportion of total data length (0 to 1)</p>
</td></tr>
<tr><td><code id="plot.inspect.ft_+3A_pos">pos</code></td>
<td>
<p>integer. Which result to plot.</p>
</td></tr>
<tr><td><code id="plot.inspect.ft_+3A_quiet">quiet</code></td>
<td>
<p>logical. Suppress console output.</p>
</td></tr>
<tr><td><code id="plot.inspect.ft_+3A_legend">legend</code></td>
<td>
<p>logical. Suppress labels and legends.</p>
</td></tr>
<tr><td><code id="plot.inspect.ft_+3A_rate.rev">rate.rev</code></td>
<td>
<p>logical. Control direction of y-axis in delta oxygen plot.</p>
</td></tr>
<tr><td><code id="plot.inspect.ft_+3A_...">...</code></td>
<td>
<p>Pass additional plotting parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot. No returned value.
</p>

<hr>
<h2 id='plot.oxy_crit'>Plot oxy_crit objects</h2><span id='topic+plot.oxy_crit'></span>

<h3>Description</h3>

<p>Plot oxy_crit objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'oxy_crit'
plot(x, legend = TRUE, quiet = FALSE, panel = NULL, rate.rev = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.oxy_crit_+3A_x">x</code></td>
<td>
<p>oxy_crit object</p>
</td></tr>
<tr><td><code id="plot.oxy_crit_+3A_legend">legend</code></td>
<td>
<p>logical. Suppress labels and legends.</p>
</td></tr>
<tr><td><code id="plot.oxy_crit_+3A_quiet">quiet</code></td>
<td>
<p>logical. Suppress console output.</p>
</td></tr>
<tr><td><code id="plot.oxy_crit_+3A_panel">panel</code></td>
<td>
<p>integer. Which panel to plot individually.</p>
</td></tr>
<tr><td><code id="plot.oxy_crit_+3A_rate.rev">rate.rev</code></td>
<td>
<p>logical. Control direction of y-axis in rolling rate plot.</p>
</td></tr>
<tr><td><code id="plot.oxy_crit_+3A_...">...</code></td>
<td>
<p>Pass additional plotting parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot. No returned value.
</p>

<hr>
<h2 id='plot.test_lin'>Plot output of test_lin</h2><span id='topic+plot.test_lin'></span>

<h3>Description</h3>

<p>This is an internal generic. Produces 4 plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'test_lin'
plot(x, show = c("all", "a", "b", "c", "d"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.test_lin_+3A_x">x</code></td>
<td>
<p>test_lin object</p>
</td></tr>
<tr><td><code id="plot.test_lin_+3A_show">show</code></td>
<td>
<p>string. Which result to show.</p>
</td></tr>
<tr><td><code id="plot.test_lin_+3A_...">...</code></td>
<td>
<p>Pass additional plotting parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot. No returned value.
</p>

<hr>
<h2 id='print_dens'>Prints the density object for summary.auto_rate S3
Basically copied from stats:::print.density and edited to make
it more compact</h2><span id='topic+print_dens'></span>

<h3>Description</h3>

<p>Prints the density object for summary.auto_rate S3
Basically copied from stats:::print.density and edited to make
it more compact
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_dens(x, digits = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print_dens_+3A_x">x</code></td>
<td>
<p>auto_rate object.</p>
</td></tr>
<tr><td><code id="print_dens_+3A_digits">digits</code></td>
<td>
<p>numeric.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Console output
</p>

<hr>
<h2 id='print.adjust_rate'>Print adjust_rate objects</h2><span id='topic+print.adjust_rate'></span>

<h3>Description</h3>

<p>Print adjust_rate objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'adjust_rate'
print(x, pos = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.adjust_rate_+3A_x">x</code></td>
<td>
<p>adjust_rate object</p>
</td></tr>
<tr><td><code id="print.adjust_rate_+3A_pos">pos</code></td>
<td>
<p>integer. Which result to print.</p>
</td></tr>
<tr><td><code id="print.adjust_rate_+3A_...">...</code></td>
<td>
<p>Pass additional inputs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print to console. No returned value.
</p>

<hr>
<h2 id='print.adjust_rate.ft'>Print adjust_rate.ft objects</h2><span id='topic+print.adjust_rate.ft'></span>

<h3>Description</h3>

<p>Print adjust_rate.ft objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'adjust_rate.ft'
print(x, pos = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.adjust_rate.ft_+3A_x">x</code></td>
<td>
<p>adjust_rate.ft object</p>
</td></tr>
<tr><td><code id="print.adjust_rate.ft_+3A_pos">pos</code></td>
<td>
<p>integer. Which result to print.</p>
</td></tr>
<tr><td><code id="print.adjust_rate.ft_+3A_...">...</code></td>
<td>
<p>Pass additional inputs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print to console. No returned value.
</p>

<hr>
<h2 id='print.auto_rate'>Print auto_rate objects</h2><span id='topic+print.auto_rate'></span>

<h3>Description</h3>

<p>Print auto_rate objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'auto_rate'
print(x, pos = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.auto_rate_+3A_x">x</code></td>
<td>
<p>auto_rate object</p>
</td></tr>
<tr><td><code id="print.auto_rate_+3A_pos">pos</code></td>
<td>
<p>integer. Which result to print.</p>
</td></tr>
<tr><td><code id="print.auto_rate_+3A_...">...</code></td>
<td>
<p>Pass additional inputs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print to console. No returned value.
</p>

<hr>
<h2 id='print.auto_rate.int'>Print auto_rate.int objects</h2><span id='topic+print.auto_rate.int'></span>

<h3>Description</h3>

<p>Print auto_rate.int objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'auto_rate.int'
print(x, pos = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.auto_rate.int_+3A_x">x</code></td>
<td>
<p>auto_rate.int object</p>
</td></tr>
<tr><td><code id="print.auto_rate.int_+3A_pos">pos</code></td>
<td>
<p>integer. Which replicate to print.</p>
</td></tr>
<tr><td><code id="print.auto_rate.int_+3A_...">...</code></td>
<td>
<p>Pass additional inputs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print to console. No returned value.
</p>

<hr>
<h2 id='print.calc_rate'>Print calc_rate objects</h2><span id='topic+print.calc_rate'></span>

<h3>Description</h3>

<p>Print calc_rate objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'calc_rate'
print(x, pos = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.calc_rate_+3A_x">x</code></td>
<td>
<p>calc_rate object</p>
</td></tr>
<tr><td><code id="print.calc_rate_+3A_pos">pos</code></td>
<td>
<p>integer. Which result to print.</p>
</td></tr>
<tr><td><code id="print.calc_rate_+3A_...">...</code></td>
<td>
<p>Pass additional inputs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print to console. No returned value.
</p>

<hr>
<h2 id='print.calc_rate.bg'>Print calc_rate.bg objects</h2><span id='topic+print.calc_rate.bg'></span>

<h3>Description</h3>

<p>Print calc_rate.bg objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'calc_rate.bg'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.calc_rate.bg_+3A_x">x</code></td>
<td>
<p>calc_rate.bg object</p>
</td></tr>
<tr><td><code id="print.calc_rate.bg_+3A_...">...</code></td>
<td>
<p>Pass additional inputs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print to console. No returned value.
</p>

<hr>
<h2 id='print.calc_rate.ft'>Print calc_rate.ft objects</h2><span id='topic+print.calc_rate.ft'></span>

<h3>Description</h3>

<p>Print calc_rate.ft objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'calc_rate.ft'
print(x, pos = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.calc_rate.ft_+3A_x">x</code></td>
<td>
<p>calc_rate.ft object</p>
</td></tr>
<tr><td><code id="print.calc_rate.ft_+3A_pos">pos</code></td>
<td>
<p>integer. Which result to print.</p>
</td></tr>
<tr><td><code id="print.calc_rate.ft_+3A_...">...</code></td>
<td>
<p>Pass additional inputs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print to console. No returned value.
</p>

<hr>
<h2 id='print.calc_rate.int'>Print calc_rate.int objects</h2><span id='topic+print.calc_rate.int'></span>

<h3>Description</h3>

<p>Print calc_rate.int objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'calc_rate.int'
print(x, pos = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.calc_rate.int_+3A_x">x</code></td>
<td>
<p>calc_rate.int object</p>
</td></tr>
<tr><td><code id="print.calc_rate.int_+3A_pos">pos</code></td>
<td>
<p>integer. Which replicate to print.</p>
</td></tr>
<tr><td><code id="print.calc_rate.int_+3A_...">...</code></td>
<td>
<p>Pass additional inputs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print to console. No returned value.
</p>

<hr>
<h2 id='print.convert_DO'>Print convert_DO objects</h2><span id='topic+print.convert_DO'></span>

<h3>Description</h3>

<p>Print convert_DO objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'convert_DO'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.convert_DO_+3A_x">x</code></td>
<td>
<p>convert_DO object</p>
</td></tr>
<tr><td><code id="print.convert_DO_+3A_...">...</code></td>
<td>
<p>Pass additional inputs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print to console. No returned value.
</p>

<hr>
<h2 id='print.convert_rate'>Print convert_rate objects</h2><span id='topic+print.convert_rate'></span>

<h3>Description</h3>

<p>Print convert_rate objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'convert_rate'
print(x, pos = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.convert_rate_+3A_x">x</code></td>
<td>
<p>convert_rate object</p>
</td></tr>
<tr><td><code id="print.convert_rate_+3A_pos">pos</code></td>
<td>
<p>integer. Which result to print.</p>
</td></tr>
<tr><td><code id="print.convert_rate_+3A_...">...</code></td>
<td>
<p>Pass additional inputs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print to console. No returned value.
</p>

<hr>
<h2 id='print.convert_rate.ft'>Print convert_rate.ft objects</h2><span id='topic+print.convert_rate.ft'></span>

<h3>Description</h3>

<p>Print convert_rate.ft objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'convert_rate.ft'
print(x, pos = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.convert_rate.ft_+3A_x">x</code></td>
<td>
<p>convert_rate.ft object</p>
</td></tr>
<tr><td><code id="print.convert_rate.ft_+3A_pos">pos</code></td>
<td>
<p>integer. Which result to print.</p>
</td></tr>
<tr><td><code id="print.convert_rate.ft_+3A_...">...</code></td>
<td>
<p>Pass additional inputs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print to console. No returned value.
</p>

<hr>
<h2 id='print.inspect'>Print inspect objects</h2><span id='topic+print.inspect'></span>

<h3>Description</h3>

<p>Print inspect objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'inspect'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.inspect_+3A_x">x</code></td>
<td>
<p>inspect object</p>
</td></tr>
<tr><td><code id="print.inspect_+3A_...">...</code></td>
<td>
<p>Pass additional inputs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print to console. No returned value.
</p>

<hr>
<h2 id='print.inspect.ft'>Print inspect.ft objects</h2><span id='topic+print.inspect.ft'></span>

<h3>Description</h3>

<p>Print inspect.ft objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'inspect.ft'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.inspect.ft_+3A_x">x</code></td>
<td>
<p>inspect.ft object</p>
</td></tr>
<tr><td><code id="print.inspect.ft_+3A_...">...</code></td>
<td>
<p>Pass additional inputs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print to console. No returned value.
</p>

<hr>
<h2 id='print.oxy_crit'>Print oxy_crit objects</h2><span id='topic+print.oxy_crit'></span>

<h3>Description</h3>

<p>Print oxy_crit objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'oxy_crit'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.oxy_crit_+3A_x">x</code></td>
<td>
<p>oxy_crit object</p>
</td></tr>
<tr><td><code id="print.oxy_crit_+3A_...">...</code></td>
<td>
<p>Pass additional inputs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print to console. No returned value.
</p>

<hr>
<h2 id='rolling_reg_row'>Perform regular rolling regression</h2><span id='topic+rolling_reg_row'></span>

<h3>Description</h3>

<p>Perform regular rolling regression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rolling_reg_row(df, width)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rolling_reg_row_+3A_df">df</code></td>
<td>
<p>data.frame object.</p>
</td></tr>
<tr><td><code id="rolling_reg_row_+3A_width">width</code></td>
<td>
<p>numeric.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.table object
</p>

<hr>
<h2 id='rolling_reg_time'>Perform rolling regression based on time units.</h2><span id='topic+rolling_reg_time'></span>

<h3>Description</h3>

<p>Perform rolling regression based on time units.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rolling_reg_time(df, width)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rolling_reg_time_+3A_df">df</code></td>
<td>
<p>data.frame object.</p>
</td></tr>
<tr><td><code id="rolling_reg_time_+3A_width">width</code></td>
<td>
<p>numeric.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.table object
</p>

<hr>
<h2 id='sardine.rd'>Respirometry data of the sardine, <em>Sardinops sagax</em></h2><span id='topic+sardine.rd'></span>

<h3>Description</h3>

<p>A single experiment on the sardine species <em>Sardinops sagax</em> in a Loligo
Systems swim tunnel and Witrox oxygen probe system. There are three columns:
<code style="white-space: pre;">&#8288;$Time&#8288;</code> in seconds, <code style="white-space: pre;">&#8288;$Oxygen&#8288;</code> content recorded in percent air saturation, and
<code style="white-space: pre;">&#8288;$Temperature&#8288;</code> in °C. Mean temperature, salinity and atmospheric pressure are
supplied below to allow for conversion to oxygen concentration units.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sardine.rd
</code></pre>


<h3>Format</h3>

<p>A data frame object consisting of 3 columns (time, % air saturation
and temperature) and 7513 rows (approx 2.1h of data).
</p>


<h3>Details</h3>

<p>Experiment conducted at Hopkins Marine Station, Stanford University, Pacific
Grove, California.
</p>

<ul>
<li><p> Dissolved oxygen units: <code style="white-space: pre;">&#8288;% air saturation&#8288;</code>
</p>
</li>
<li><p> Time units: <code>seconds</code>
</p>
</li>
<li><p> Chamber volume (L): <code>12.3</code>
</p>
</li>
<li><p> Specimen wet mass (kg): <code>0.0477</code>
</p>
</li>
<li><p> Temperature (°C): <code>14.8</code>
</p>
</li>
<li><p> Salinity: <code>35</code>
</p>
</li>
<li><p> Atm. Pressure (bar): <code>1.013253</code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Nicholas Carey
</p>

<hr>
<h2 id='select'>Select columns</h2><span id='topic+select'></span>

<h3>Description</h3>

<p>Select columns
</p>


<h3>Value</h3>

<p>No value returned
</p>

<hr>
<h2 id='select_rate'>Select rate results based on a range of criteria</h2><span id='topic+select_rate'></span><span id='topic+select_rate.ft'></span>

<h3>Description</h3>

<p>The functions in <code>respR</code> are powerful, but outputs can be large
and difficult to explore, especially when there are hundreds to thousands
of results, for example the output of <code>auto_rate</code> on large datasets, or the
outputs of <code>calc_rate.int</code> from long intermittent-flow experiments.
</p>
<p>The <code>select_rate</code> and <code>select_rate.ft</code> functions help explore, reorder, and
filter <code>convert_rate</code> and <code>convert_rate.ft</code> results according to various
criteria. For example, extracting only positive or negative rates, only the
highest or lowest rates, only those from certain data regions, and numerous
other methods that allow advanced filtering of results so the final
selection of rates is well-defined towards the research question of
interest. This also allows for highly consistent reporting of results and
rate selection criteria.
</p>
<p>Multiple selection criteria can be applied by saving the output and
processing it through the function multiple times using different methods,
or alternatively via piping (<code style="white-space: pre;">&#8288;%&gt;%&#8288;</code> or <code style="white-space: pre;">&#8288;%&gt;%&#8288;</code>). See Examples.
</p>
<p><em>Note:</em> when choosing a <code>method</code>, keep in mind that to remain
mathematically consistent, <code>respR</code> outputs oxygen consumption (i.e.
respiration) rates as negative values. This is particularly important in
the difference between <code>highest/lowest</code> and <code>minimum/maximum</code> methods. See
Details.
</p>
<p>When a rate result is omitted by the selection criteria, it is removed from
the <code style="white-space: pre;">&#8288;$rate.output&#8288;</code> element of the <code>convert_rate</code> object, and the associated
data in <code style="white-space: pre;">&#8288;$summary&#8288;</code> (i.e. that row) is removed. Some methods can also be
used with an <code>n = NULL</code> input to reorder the <code style="white-space: pre;">&#8288;$rate&#8288;</code> and <code style="white-space: pre;">&#8288;$summary&#8288;</code>
elements in various ways.
</p>


<h4>Replicate and Rank columns</h4>

<p>The summary table <code style="white-space: pre;">&#8288;$rank&#8288;</code> column is context-specific, and what it
represents depends on the type of experiment analysed or the function used
to determine the rates. If numeric values were converted, it is the order
in which they were entered. Similarly, if <code>calc_rate</code> was used, it is the
order of rates as entered using <code>from</code> and <code>to</code> (if multiple rates were
determined). For <code>auto_rate</code> it relates to the <code>method</code> input. For example
it indicates the kernel density ranking if the <code>linear</code> method was used,
the ascending or descending ordering by absolute rate value if <code>lowest</code> or
<code>highest</code> were used, or the numerical order if <code>minimum</code> or <code>maximum</code> were
used. For intermittent-flow experiments analysed via <code>calc_rate.int</code> and
<code>auto_rate.int</code> these will be ranked <em>within</em> each replicate as indicated
in the <code style="white-space: pre;">&#8288;$rep&#8288;</code> column. The <code style="white-space: pre;">&#8288;$rep&#8288;</code> and <code style="white-space: pre;">&#8288;$rank&#8288;</code> columns can be used to keep
track of selection or reordering because the original values will be
retained unchanged through selection or reordering operations. The original
order can always be restored by using <code>method = "rep"</code> or <code>method = "rank"</code>
with <code>n = NULL</code>. In both these cases the <code style="white-space: pre;">&#8288;$summary&#8288;</code> table and
<code style="white-space: pre;">&#8288;$rate.output&#8288;</code> will be reordered by <code style="white-space: pre;">&#8288;$rep&#8288;</code> (if used) then <code style="white-space: pre;">&#8288;$rank&#8288;</code> to
restore the original ordering.
</p>
<p>Note that if you are analysing intermittent-flow data and used
<code>auto_rate.int</code> but changed the <code>n</code> input to output more than one rate
result per replicate, the selection or reordering operations will not take
any account of this. You should carefully consider if or why you need to
output multiple rates per replicate in the first place. If you have, you
can perform selection on individual replicates by using <code>method = "rep"</code> to
select individual replicates then apply additional selection criteria.
</p>



<h3>Usage</h3>

<pre><code class='language-R'>select_rate(x, method = NULL, n = NULL)

select_rate.ft(x, method = NULL, n = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="select_rate_+3A_x">x</code></td>
<td>
<p>list. An object of class <code>convert_rate</code> or <code>convert_rate_select</code>.</p>
</td></tr>
<tr><td><code id="select_rate_+3A_method">method</code></td>
<td>
<p>string. Method by which to select or reorder rate results. For
most methods matching results are <em>retained</em> in the output. See Details.</p>
</td></tr>
<tr><td><code id="select_rate_+3A_n">n</code></td>
<td>
<p>numeric. Number, percentile, or range of results to retain or omit
depending on <code>method</code>. Default is <code>NULL</code>, in which case some methods will
instead reorder the results. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are the current methods by which rates in <code>convert_rate</code>
objects can be selected. Matching results are <em>retained</em> in the output.
Some methods can also be used to reorder the results. Note that the methods
selecting by rate value operate on the <code style="white-space: pre;">&#8288;$rate.output&#8288;</code> element, that is the
final converted rate value.
</p>


<h4><code>positive</code>, <code>negative</code></h4>

<p>Selects all <code>positive</code> (&gt;0) or <code>negative</code> (&lt;0) rates. <code>n</code> is ignored.
Useful, for example, in respirometry on algae where both oxygen consumption
and production rates are recorded. Note, <code>respR</code> outputs oxygen consumption
(i.e. respiration) rates as <em>negative</em> values, production rates as
<em>positive</em>.
</p>



<h4><code>nonzero</code>, <code>zero</code></h4>

<p>Retains all <code>nonzero</code> rates (i.e. removes any zero rates), or retains
<em>only</em> <code>zero</code> rates (i.e. removes all rates with any value). <code>n</code> is
ignored.
</p>



<h4><code>lowest</code>, <code>highest</code></h4>

<p>These methods can only be used when rates all have the same sign, that is
are all negative or all positive. These select the lowest and highest
<em><strong>absolute</strong></em> rate values. For example, if rates are all negative, <code>method = 'highest'</code> will retain the highest magnitude rates regardless of the
sign. <code>n</code> should be an integer indicating the number of lowest/highest
rates to retain. If <code>n = NULL</code> the results will instead be reordered by
lowest or highest rate without any removed. See <code>minimum</code> and <code>maximum</code>
options for extracting <em>numerically</em> lowest and highest rates.
</p>



<h4><code>lowest_percentile</code>, <code>highest_percentile</code></h4>

<p>These methods can also only be used when rates all have the same sign.
These retain the <code>n</code>'th lowest or highest percentile of <em><strong>absolute</strong></em> rate
values. For example, if rates are all negative <code>method = 'highest_percentile'</code> will retain the highest magnitude <code>n</code>'th percentile
regardless of the sign. <code>n</code> should be a percentile value between 0 and 1.
For example, to extract the lowest 10th percentile of absolute rate values,
you would enter <code style="white-space: pre;">&#8288;method = 'lowest_percentile', n = 0.1&#8288;</code>.
</p>



<h4><code>minimum</code>, <code>maximum</code></h4>

<p>In contrast to <code>lowest</code> and <code>highest</code>, these are <em>strictly numerical</em>
options which take full account of the sign of the rate, and can be used
where rates are a mix of positive and negative. For example, <code>method = 'minimum'</code> will retain the minimum numerical value rates, which would
actually be the highest oxygen uptake rates. <code>n</code> is an integer indicating
how many of the min/max rates to retain. If <code>n = NULL</code> the results will
instead be reordered by minimum or maximum rate without any removed.
</p>



<h4><code>minimum_percentile</code>, <code>maximum_percentile</code></h4>

<p>Like <code>min</code> and <code>max</code> these are <em>strictly numerical</em> inputs which retain the
<code>n</code>'th minimum or maximum percentile of the rates and take full account of
the sign. Here <code>n</code> should be a percentile value between 0 and 1. For
example, if rates are all negative (i.e. typical uptake rates), to extract
the lowest 10th percentile of rates, you would enter <code style="white-space: pre;">&#8288;method = 'maximum_percentile', n = 0.1&#8288;</code>. This is because the <em>lowest</em> negative rates
are numerically the <em>maximum</em> rates (<code>highest/lowest</code> percentile methods
would be a better option in this case however).
</p>



<h4><code>rate</code></h4>

<p>Allows you to enter a value range of output rates to be retained. Matching
regressions in which the rate value falls within the <code>n</code> range (inclusive)
are retained. <code>n</code> should be a vector of two values. For example, to retain
only rates where the <code>rate</code> value is between 0.05 and 0.08: <code style="white-space: pre;">&#8288;method = 'rate', n = c(0.05, 0.08)&#8288;</code>. Note this operates on the <code style="white-space: pre;">&#8288;$rate.output&#8288;</code>
element, that is converted rate values.
</p>



<h4><code>rep</code>, <code>rank</code></h4>

<p>These refer to the respective columns of the <code style="white-space: pre;">&#8288;$summary&#8288;</code> table. For these,
<code>n</code> should be a numeric vector of integers of <code>rep</code> or <code>rank</code> values to
retain. To retain a range use regular R syntax, e.g. <code>n = 1:10</code>. If <code>n = NULL</code> no results will be removed, instead the results will be reordered
ascending by <code>rep</code> (if it contains values) then <code>rank</code>. Essentially this
restores the original ordering if other reordering operations have been
performed.
</p>
<p>The values in these columns depend on the functions used to calculate
rates. If <code>calc_rate</code> was used, <code>rep</code> is <code>NA</code> and <code>rank</code> is the order of
rates as entered using <code>from</code> and <code>to</code> (if multiple rates were determined).
For <code>auto_rate</code>, <code>rep</code> is <code>NA</code> and <code>rank</code> relates to the <code>method</code> input.
For example it indicates the kernel density ranking if the <code>linear</code> method
was used, the ascending or descending ordering by absolute rate value if
<code>lowest</code> or <code>highest</code> were used, or by numerical order if <code>minimum</code> or
<code>maximum</code> were used. If <code>calc_rate.int</code> or <code>auto_rate.int</code> were used, <code>rep</code>
indicates the replicate number and the <code>rank</code> column represents rank
<em>within</em> the relevant replicate, and will generally be filled with the
value <code>1</code>. Therefore you need to adapt your selection criteria
appropriately towards which of these columns is relevant.
</p>



<h4><code>rep_omit</code>, <code>rank_omit</code></h4>

<p>These refer to the <code>rep</code> and <code>rank</code> columns of the <code style="white-space: pre;">&#8288;$summary&#8288;</code> table and
allow you to exclude rates from particular replicate or rank values. For
these, <code>n</code> should be a numeric vector of integers of <code>rep</code> or <code>rank</code> values
to OMIT. To omit a range use regular R syntax, e.g. <code>n = 1:10</code>.
</p>



<h4><code>rsq</code>, <code>row</code>, <code>time</code>, <code>density</code></h4>

<p>These methods refer to the respective columns of the <code style="white-space: pre;">&#8288;$summary&#8288;</code> data frame.
For these, <code>n</code> should be a vector of two values. Matching regressions in
which the respective parameter falls within the <code>n</code> range (inclusive) are
retained. To retain all rates with a R-Squared 0.90 or above: <code style="white-space: pre;">&#8288;method = 'rsq', n = c(0.9, 1)&#8288;</code>. The <code>row</code> and <code>time</code> ranges refer to the
<code style="white-space: pre;">&#8288;$row&#8288;</code>-<code style="white-space: pre;">&#8288;$endrow&#8288;</code> or <code style="white-space: pre;">&#8288;$time&#8288;</code>-<code style="white-space: pre;">&#8288;$endtime&#8288;</code> columns and the original raw data
(<code style="white-space: pre;">&#8288;$dataframe&#8288;</code> element of the <code>convert_rate</code> object), and can be used to
constrain results to rates from particular regions of the data (although
usually a better option is to <code>subset_data()</code> prior to analysis). Note
<code>time</code> is not the same as <code>duration</code> - see later section - and <code>row</code> refers
to rows of the raw data, <strong>not</strong> rows of the summary table - see <code>manual</code>
method for this. For all of these methods, if <code>n = NULL</code> no results will be
removed, instead the results will be reordered by that respective column
(descending for <code>rsq</code> and <code>density</code>, ascending for <code>row</code>, and <code>time</code>).
</p>



<h4><code>intercept</code>, <code>slope</code></h4>

<p>These methods are similar to the above and refer to the <code>intercept_b0</code> and
<code>slope_b1</code> summary table columns. Note these linear model coefficients
represent different things in flowthrough vs. other analyses. In
non-flowthrough analyses slopes represent rates and coefficients such as a
high r-squared are important. In flowthrough, slopes represent the
stability of the data region, in that the closer the slope is to zero, the
less the delta oxygen values in that region vary, which is an indication of
a region of stable rates. In addition, intercept values close to the
calculated mean delta of the region also indicate a region of stable rates.
Therefore these methods are chiefly useful in selection of flowthrough
results, for example slopes close to zero. If <code>n = NULL</code> no results will be
removed, instead the results will be reordered by ascending value by that
column.
</p>



<h4><code>time_omit</code>, <code>row_omit</code></h4>

<p>These methods refer to the original data, and are intended to <em>exclude</em>
rates determined over particular data regions. This is useful in the case
of, for example, a data anomaly such as a spike or sensor dropout. For
these inputs, <code>n</code> are values (a single value, multiple values, or a range)
indicating data timepoints or rows of the original data to exclude. Only
rates (i.e. regressions) which <em>do not</em> utilise those particular values are
retained in the output. For example, if an anomaly occurs precisely at
timepoint 3000, <code>time_omit = 3000</code> means only rates determined solely over
regions before or after this will be retained. If it occurs over a range
this can be entered as, <code>time_omit = c(3000,3200)</code>. If you want to exclude
a regular occurrence, for example the flushes in intermittent-flow
respirometry, or any other non-continuous values they can be entered as a
vector, e.g. <code>row_omit = c(1000, 2000, 3000)</code>. Note this last option can be
extremely computationally intensive when the vector or dataset is large, so
should only be used when a range cannot be entered as two values, which is
much faster. For both methods, input values must match exactly to values
present in the dataset.
</p>



<h4><code>oxygen</code></h4>

<p>This can be used to constrain rate results to regions of the data based on
oxygen values. <code>n</code> should be a vector of two values in the units of oxygen
in the raw data. Only rate regressions in which all datapoints occur within
this range (inclusive) are retained. Any which use even a single value
outside of this range are excluded. Note the summary table columns <code>oxy</code>
and <code>endoxy</code> refer to the first and last oxygen values in the rate
regression, which should broadly indicate which results will be removed or
retained, but this method examines <em>every</em> oxygen value in the regression,
not just first and last.
</p>



<h4><code>oxygen_omit</code></h4>

<p>Similar to <code>time_omit</code> and <code>row_omit</code> above, this can be used to <em>omit</em>
rate regressions which use particular oxygen values. For this <code>n</code> are
values (single or multiple) indicating oxygen values in the original raw
data to exclude. Every oxygen value used by each regression is checked, and
to be excluded an <code>n</code> value must match <em>exactly</em> to one in the data.
Therefore, note that if a regression is fit across the data region where
that value would occur, it is not necessarily excluded unless that <em>exact
value</em> occurs. You need to consider the precision of the data values
recorded. For example, if you wanted to exclude any rate using an oxygen
value of <code>7</code>, but your data are recorded to two decimals, a rate fit across
these data would <em>not</em> be excluded: <code>c(7.03, 7.02, 7.01, 6.99, 6.98, ...)</code>.
To get around this you can use regular R syntax to input vectors at the
correct precision, such as seq, e.g. <code>seq(from = 7.05, to = 6.96, by = -0.01)</code>. This can be used to input ranges of oxygen values to exclude.
</p>



<h4><code>duration</code></h4>

<p>This method allows selection of rates which have a specific duration range.
Here, <code>n</code> should be a numeric vector of two values. Use this to set minimum
and maximum durations in the time units of the original data. For example,
<code>n = c(0,500)</code> will retain only rates determined over a maximum of 500 time
units. To retain rates over a minimum duration, set this using the minimum
value plus the maximum duration or simply infinity. For example, for rates
determined over a minimum of 500 time units <code>n = c(500,Inf)</code>)
</p>



<h4><code>manual</code></h4>

<p>This method simply allows particular rows of the <code style="white-space: pre;">&#8288;$summary&#8288;</code> data frame to
be manually selected to be retained. For example, to keep only the top row
<code style="white-space: pre;">&#8288;method = 'manual', n = 1&#8288;</code>. To keep multiple rows use regular <code>R</code> selection
syntax: <code>n = 1:3</code>, <code>n = c(1,2,3)</code>, <code>n = c(5,8,10)</code>, etc. No value of <code>n</code>
should exceed the number of rows in the <code style="white-space: pre;">&#8288;$summary&#8288;</code> data frame. Note this is
not necessarily the same as selecting by the <code>rep</code> or <code>rank</code> methods, as
the table could already have undergone selection or reordering.
</p>



<h4><code>manual_omit</code></h4>

<p>As above, but this allows particular rows of the <code style="white-space: pre;">&#8288;$summary&#8288;</code> data frame to
be manually selected to be <em>omitted</em>.
</p>



<h4><code>overlap</code></h4>

<p>This method removes rates which overlap, that is regressions which are
partly or completely fit over the same rows of the original data. This is
useful in particular with <code>auto_rate</code> results. The <code>auto_rate</code> <code>linear</code>
method may identify multiple linear regions, some of which may
substantially overlap, or even be completely contained within others. In
such cases summary operations such as taking an average of the rate values
may be questionable, as certain values will be weighted higher due to these
multiple, overlapping results. This method removes overlapping rates, using
<code>n</code> as a threshold to determine degree of permitted overlap. It is
recommended this method be used after all other selection criteria have
been applied, as it is quite aggressive about removing rates, and can be
<em>very</em> computationally intensive when there are many results.
</p>
<p>While it can be used with <code>auto_rate</code> results determined via the <code>rolling</code>,
<code>lowest</code>, or <code>highest</code> methods, by their nature these methods produce <em>all
possible</em> overlapping regressions, ordered in various ways, so other
selection methods are more appropriate. The <code>overlap</code> method is generally
intended to be used in combination with the <code>auto_rate</code> <code>linear</code> results,
but may prove useful in other analyses.
</p>
<p>Permitted overlap is determined by <code>n</code>, which indicates the proportion of
each particular regression which must overlap with another for it to be
regarded as overlapping. For example, <code>n = 0.2</code> means a regression would
have to overlap with at least one other by at least 20% of its total length
to be regarded as overlapping.
</p>
<p>The <code>"overlap"</code> method performs two operations:
</p>
<p>First, regardless of the <code>n</code> value, any rate regressions which are
completely contained within another are removed. This is also the only
operation if <code>n = 1</code>.
</p>
<p>Secondly, for each regression in <code style="white-space: pre;">&#8288;$summary&#8288;</code> starting from the bottom of the
summary table (usually the lowest ranked result, but this depends on the
analysis used and if any reordering has been already occurred), the
function checks if it overlaps with any others (accounting for <code>n</code>). If
not, the next lowest is checked, and the function progresses up the summary
table until it finds one that does. The first to be found overlapping is
then removed, and the process repeats starting again from the bottom of the
summary table. If no reordering to the results has occurred, this means
lower ranked results are removed first. This is repeated iteratively until
only non-overlapping rates (accounting for <code>n</code>) remain.
</p>
<p>If <code>n = 0</code>, only rates which do not overlap at all, that is share <em>no</em>
data, are retained. If <code>n = 1</code>, only rates which are 100% contained within
at least one other are removed.
</p>



<h4>Reordering results</h4>

<p>Several methods can be used to reorder results rather than select them, by
not entering an <code>n</code> input (that is, letting the <code>n = NULL</code> default be
applied). Several of these methods are named the same as those in
<code>auto_rate</code> for consistency and have equivalent outcomes, so this allows
results to be reordered to the equivalent of that method's results without
re-running the <code>auto_rate</code> analysis.
</p>
<p>The <code>"row"</code> and <code>"rolling"</code> methods reorder sequentially by the starting
row of each regression (<code style="white-space: pre;">&#8288;$row&#8288;</code> column).
</p>
<p>The <code>"time"</code> method reorders sequentially by the starting time of each
regression (<code style="white-space: pre;">&#8288;$time&#8288;</code> column).
</p>
<p><code>"linear"</code> and <code>"density"</code> are essentially identical, reordering by the
<code style="white-space: pre;">&#8288;$density&#8288;</code> column. This metric is only produced by the <code>auto_rate</code> <code>linear</code>
method, so will not work with any other results.
</p>
<p><code>"rep"</code> or <code>"rank"</code> both reorder by the <code style="white-space: pre;">&#8288;$rep&#8288;</code> then <code style="white-space: pre;">&#8288;$rank&#8288;</code> columns. What
these represents is context dependent - see <strong>Replicate and Rank columns</strong>
section above. Each summary row <code>rep</code> and <code>rank</code> value is retained
unchanged regardless of how the results are subsequently selected or
reordered, so this will restore the original ordering after other methods
have been applied.
</p>
<p><code>"rsq"</code> reorders by <code style="white-space: pre;">&#8288;$rsq&#8288;</code> from highest value to lowest.
</p>
<p><code>"intercept"</code> and <code>"slope"</code> reorder by the <code style="white-space: pre;">&#8288;$intercept_b0&#8288;</code> and <code style="white-space: pre;">&#8288;$slope_b1&#8288;</code>
columns from lowest value to highest.
</p>
<p><code>"highest"</code> and <code>"lowest"</code> reorder by absolute values of the <code style="white-space: pre;">&#8288;$rate.output&#8288;</code>
column, that is highest or lowest in magnitude regardless of the sign. They
can only be used when rates all have the same sign.
</p>
<p><code>"maximum"</code> and <code>"minimum"</code> reorder by numerical values of the
<code style="white-space: pre;">&#8288;$rate.output&#8288;</code> column, that is maximum or minimum in numerical value taking
account of the sign, and can be used when rates are a mix of negative and
positive.
</p>



<h4>Numeric input conversions</h4>

<p>For <code>convert_rate</code> objects which contain rates which have been converted
from numeric values, the summary table will contain a limited amount of
information, so many of the selection or reordering methods will not work.
In this case a warning is given and the original input is returned.
</p>



<h4>Plot</h4>

<p>There is no plotting functionality in <code>select_rate</code>. However since the
output is a <code>convert_rate</code> object it can be plotted. See the <strong>Plot</strong>
section in <code>help("convert_rate")</code>. To plot straight after a selection
operation, pipe or enter the output in <code>plot()</code>. See Examples.
</p>



<h4>More</h4>

<p>This help file can be found online
<a href="https://januarharianto.github.io/respR/reference/select_rate.html">here</a>,
where it is much easier to read.
</p>
<p>For additional help, documentation, vignettes, and more visit the <code>respR</code>
website at <a href="https://januarharianto.github.io/respR/">https://januarharianto.github.io/respR/</a>
</p>



<h3>Value</h3>

<p>The output of <code>select_rate</code> is a <code>list</code> object which retains the
<code>convert_rate</code> class, with an additional <code>convert_rate_select</code> class
applied.
</p>
<p>It contains two additional elements: <code style="white-space: pre;">&#8288;$original&#8288;</code> contains the original,
unaltered <code>convert_rate</code> object, which will be retained unaltered through
multiple selection operations, that is even after processing through the
function multiple times. <code style="white-space: pre;">&#8288;$select_calls&#8288;</code> contains the calls for every
selection operation that has been applied to the <code style="white-space: pre;">&#8288;$original&#8288;</code> object, from
the first to the most recent. These additional elements ensure the output
contains the complete, reproducible history of the <code>convert_rate</code> object
having been processed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Object to filter
 ar_obj &lt;- inspect(intermittent.rd, plot = FALSE) %&gt;%
   auto_rate(plot = FALSE) %&gt;%
   convert_rate(oxy.unit = "mg/L",
                time.unit = "s",
                output.unit = "mg/h",
                volume = 2.379) %&gt;%
   summary()

 ## Select only negative rates
 ar_subs_neg &lt;- select_rate(ar_obj, method = "negative") %&gt;%
   summary()

 ## Select only rates over 1000 seconds duration
 ar_subs_dur &lt;- select_rate(ar_obj, method = "duration", n = c(1000, Inf)) %&gt;%
   summary()

 ## Reorder rates sequentially (i.e. by starting row)
 ar_subs_dur &lt;- select_rate(ar_obj, method = "row") %&gt;%
   summary()

 ## Select rates with r-squared higher than 0.99,
 ## then select the lowest 10th percentile of the remaining rates,
 ## then take the mean of those
 inspect(squid.rd, plot = FALSE) %&gt;%
   auto_rate(method = "linear",
             plot = FALSE) %&gt;%
   convert_rate(oxy.unit = "mg/L",
                time.unit = "s",
                output.unit = "mg/h",
                volume = 2.379) %&gt;%
   summary() %&gt;%
   select_rate(method = "rsq", n = c(0.99, 1)) %&gt;%
   select_rate(method = "lowest_percentile", n = 0.1) %&gt;%
   mean()
   
</code></pre>

<hr>
<h2 id='sim_data'>Randomly generate data for internal testing of <code>auto_rate()</code>'s linear method.</h2><span id='topic+sim_data'></span>

<h3>Description</h3>

<p>Generate data of size <code>len</code> that is coerced to mimic common respirometry
data. This is an internal function not intending for public use, though may
prove of interest or utility. We may modify this function at any time, which
may irreversibly change the outputs. This function was first created to test
<code>auto_rate()</code> using the other internal function, <code>test_lin()</code>, but we decided
to publish the code as it is an effective (and visually-appealing) tool for
teaching, testing and visualising purposes. This function is by no means
comprehensive and we encourage users to generate data that suit their own
unique situations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_data(len = 300, type = "default", sd = 0.05, preview = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_data_+3A_len">len</code></td>
<td>
<p>numeric. Defaults at 300. Number of observations in the dataset.</p>
</td></tr>
<tr><td><code id="sim_data_+3A_type">type</code></td>
<td>
<p>character. What kind of data should the function generate?
Available for use: &quot;default&quot;, &quot;corrupted&quot; and &quot;segmented&quot;.</p>
</td></tr>
<tr><td><code id="sim_data_+3A_sd">sd</code></td>
<td>
<p>numeric. Defaults at 0.05. This is the amount of noise to add to
the system, randomly generated as a standard deviation based on the entire
data set.</p>
</td></tr>
<tr><td><code id="sim_data_+3A_preview">preview</code></td>
<td>
<p>logical. Defaults to TRUE. Plots the generated data as an xy.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sim_data()</code> creates 3 types of data that we think are common in respirometry
or oxygen flux data. The data types can be selected using the <code>type</code>
input:
</p>

<ul>
<li> <p><code>"default"</code>: data is made up of a linear segment of known length and slope,
with a non-linear segment, generated by a sine or cosine function depending
on whether the slope is positive or negative, appended to the beginning of
the data. The shape of the dataset is designed to mimic many similar data
whereby the initial sections of the data are often non-linear. Here the slope
is randomly generated using <code>rnorm(1, 0, 0.025)</code>, the length of the inital
segment randomly generated using <code>floor(abs(rnorm(1, .25*len, .05*len)))</code>
where <code>len</code> is the total number of observations in the data, and the
amplitude of the segment also randomly generated using <code>rnorm(1, .8, .05)</code>.
</p>
</li>
<li> <p><code>"corrupted"</code>: same as <code>"default"</code>, but &quot;corrupted&quot; data is inserted
randomly at any point in the linear segment. The data corruption is chosen as
a sudden dip in the reading, which recovers. This event mimics equipment
interference that sometimes happens, but does not necessarily invalidate the
dataset if the corrupted section is omitted from analysis, The dip is
generated by a cosine function of fixed amplitude of 1, and the length is
randomly generated.
</p>
</li>
<li> <p><code>"segmented"</code>: same as <code>"default"</code>, but the data is modified to contain two
linear segments. The slope of the second linear segment is randomly picked at
between 0.5 and 0.6 of the first linear segment. Its length is also randomly
generated but always smaller than the first segment.
</p>
</li></ul>

<p>Normally-distributed noise is added to the dataset to add variation, which
can be modified using the <code>"sd"</code> input.
</p>


<h3>Value</h3>

<p>A list containing the dataframe, the slope and the length of the
linear section of the data, to be used for analysis in the function
<code>test_lin()</code>.
</p>


<h3>See Also</h3>

<p><code>test_lin()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate data of length 200
sim_data(len = 200)

# Generate data that contains a "corruption"
sim_data(type = "corrupted")

# Generate noisy data
sim_data(type = "segmented", sd = .2)

# Generate "perfect" non-noisy data
sim_data(sd = 0)
</code></pre>

<hr>
<h2 id='squid.rd'>Respirometry data of the squid, <em>Doryteuthis opalescens</em></h2><span id='topic+squid.rd'></span>

<h3>Description</h3>

<p>A single experiment on the squid species <em>Doryteuthis opalescens</em> in a Loligo
Systems swim tunnel and Witrox oxygen probe system. Oxygen was recorded to
very low concentrations, making this dataset suitable for determining PCrit.
Experiment conducted at Hopkins Marine Station, Stanford University, Pacific
Grove, California. Mean temperature, salinity and atmospheric pressure are
supplied below to allow for conversion to oxygen concentration units.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>squid.rd
</code></pre>


<h3>Format</h3>

<p>A data frame object consisting of 2 columns (<code style="white-space: pre;">&#8288;$Time&#8288;</code> and <code style="white-space: pre;">&#8288;$Oxygen&#8288;</code>)
and 34120 rows (approx 9.5h of data).
</p>


<h3>Details</h3>


<ul>
<li><p> Dissolved oxygen units: <code>mg/L</code>
</p>
</li>
<li><p> Time units: <code>seconds</code>
</p>
</li>
<li><p> Chamber volume (L): <code>12.3</code>
</p>
</li>
<li><p> Specimen wet mass (kg): <code>0.02141</code>
</p>
</li>
<li><p> Temperature (°C): <code>14</code>
</p>
</li>
<li><p> Salinity: <code>35</code>
</p>
</li>
<li><p> Atm. Pressure (bar): <code>1.013253</code>
</p>
</li></ul>

<p>Data kindly supplied by Ben Burford, Hopkins Marine Station, Stanford
University.
</p>


<h3>Author(s)</h3>

<p>Ben Burford
</p>

<hr>
<h2 id='static_roll'>Normal rolling regression</h2><span id='topic+static_roll'></span>

<h3>Description</h3>

<p>This is an internal function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>static_roll(df, win)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="static_roll_+3A_df">df</code></td>
<td>
<p>data.frame object.</p>
</td></tr>
<tr><td><code id="static_roll_+3A_win">win</code></td>
<td>
<p>numeric. width in number of rows</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.table object
</p>

<hr>
<h2 id='StP.check'>Checks if an oxygen concentration/pressure unit or metabolic rate unit
requires temperature, salinity, and pressure to convert to another unit.</h2><span id='topic+StP.check'></span>

<h3>Description</h3>

<p><code>type</code> should be <code>"oxy"</code> or <code>"mr"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StP.check(unit, type)
</code></pre>


<h3>Details</h3>

<p>Returns <code>TRUE</code> if it requires t,S,P or <code>FALSE</code> if not.
</p>

<hr>
<h2 id='StP.val'>Returns an error message if an oxygen concentration/pressure unit or
metabolic rate unit requires S or t and either is NULL, or a message if it
requires P and it is NULL.</h2><span id='topic+StP.val'></span>

<h3>Description</h3>

<p><code>type</code> should be <code>"oxy"</code> or <code>"mr"</code>.
<code>P.chk</code> - perform P out of normal range check. Only want to do this once per function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StP.val(unit, type, S, t, P, P.chk = TRUE, msg)
</code></pre>


<h3>Details</h3>

<p>Also returns default value of P = 1.013253 if it is NULL.
</p>

<hr>
<h2 id='subsample'>Subsample a data frame object</h2><span id='topic+subsample'></span>

<h3>Description</h3>

<p>A simple function that subsamples a data frame or numeric vector in order to
&quot;thin&quot; large datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subsample(x, n = NULL, length.out = NULL, random_start = FALSE, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subsample_+3A_x">x</code></td>
<td>
<p>data frame or vector. The data to subsample.</p>
</td></tr>
<tr><td><code id="subsample_+3A_n">n</code></td>
<td>
<p>numeric. Subsample every <code>n</code> elements or rows.</p>
</td></tr>
<tr><td><code id="subsample_+3A_length.out">length.out</code></td>
<td>
<p>numeric. Subsample to a specific length or number of rows.</p>
</td></tr>
<tr><td><code id="subsample_+3A_random_start">random_start</code></td>
<td>
<p>logical. Defaults to FALSE. If TRUE, randomises the start
position from which to start the subsample (applies to <code>n</code> input only).</p>
</td></tr>
<tr><td><code id="subsample_+3A_plot">plot</code></td>
<td>
<p>logical. Defaults to TRUE. Plots the data. If there are multiple
columns in the data frame, only the first two are plotted. Vectors are
plotted against a position index.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two subsampling methods are provided. The <code>n</code> input selects every n'th
element or row, or alternatively the <code>length.out</code> input uniformly subsamples
the data to the desired length.
</p>


<h4>More</h4>

<p>For additional help, documentation, vignettes, and more visit the <code>respR</code>
website at <a href="https://januarharianto.github.io/respR/">https://januarharianto.github.io/respR/</a>
</p>



<h3>Value</h3>

<p>Returns a subsampled data frame or vector object depending on input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Subsample by every 200th row:
subsample(squid.rd, n = 200)

# Subsample to 100 rows:
subsample(sardine.rd, length.out = 100)

# Subsample with random starting position:
subsample(sardine.rd, n = 20, random_start = TRUE)

# Subsample a vector
subsample(sardine.rd[[2]], n = 20)
</code></pre>

<hr>
<h2 id='subset_data'>Subset a <code>data.frame</code>, <code>inspect</code>, or <code>inspect.ft</code> object</h2><span id='topic+subset_data'></span>

<h3>Description</h3>

<p><code>subset_data</code> subsets a <code>data.frame</code>, <code>inspect</code>, or <code>inspect.ft</code> object based
on a given set of criteria. The function is ideal for passing only selected
regions of data to other functions such as <code><a href="#topic+calc_rate">calc_rate()</a></code> and
<code><a href="#topic+auto_rate">auto_rate()</a></code>, either by saving the output as a new object or via the use
of pipes (<code style="white-space: pre;">&#8288;%&gt;%&#8288;</code> or <code style="white-space: pre;">&#8288;%&gt;%&#8288;</code>). It is also very useful in analysis of
intermittent-flow data, where in a loop each replicate can be extracted and
passed to an analytical function such as <code>calc_rate</code> or <code>auto_rate</code>. See
examples and vignettes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subset_data(x, from = NULL, to = NULL, by = "time", quiet = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subset_data_+3A_x">x</code></td>
<td>
<p><code>data.frame</code>, <code>inspect</code>, or <code>inspect.ft</code> object. The data from which
to produce a subset.</p>
</td></tr>
<tr><td><code id="subset_data_+3A_from">from</code></td>
<td>
<p>numeric. The lower bounds of the subset based on the <code>by</code> input.</p>
</td></tr>
<tr><td><code id="subset_data_+3A_to">to</code></td>
<td>
<p>numeric. The upper bounds of the subset based on the <code>by</code> input.</p>
</td></tr>
<tr><td><code id="subset_data_+3A_by">by</code></td>
<td>
<p>string. <code>"time"</code>, <code>"row"</code>, or <code>"oxygen"</code>. Method by which to apply
the <code>from</code> and <code>to</code> inputs.</p>
</td></tr>
<tr><td><code id="subset_data_+3A_quiet">quiet</code></td>
<td>
<p>logical. Controls if a summary of the output is printed to the
console. Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function can subset data based on ranges of <code>"time"</code>, <code>"oxygen"</code>, or
<code>"row"</code>. For data frames, to subset by <code>"time"</code> or <code>"oxygen"</code> the time data
is assumed to be in the first column, and oxygen data in the second column.
For <code><a href="#topic+inspect">inspect()</a></code> and <code><a href="#topic+inspect.ft">inspect.ft()</a></code> objects, the data will have been
coerced to this structure already. In these cases the <code style="white-space: pre;">&#8288;$dataframe&#8288;</code> element in
the output is replaced by the subset, and in <code>inspect.ft</code> the <code style="white-space: pre;">&#8288;$data&#8288;</code> element
is also subset and replaced. Note for <code>inspect.ft</code> objects, the oxygen data
in column 2 will be either <code>out.oxy</code> data or <code>delta.oxy</code> data depending on
what was inspected. The function can subset <em>any</em> data frame by <code>row</code>.
</p>
<p>When multiple columns are present, for example time in column 1, and multiple
columns of oxygen data, the subset object will include <em>all</em> columns. In the
case of subsetting <code>by = "oxygen"</code>, subsetting is based on the <em>first</em> column
of oxygen data only (i.e. column 2), and all subsequent columns are subset
between the same rows regardless of oxygen values.
</p>
<p>For all methods, if exact matching values of <code>from</code> and <code>to</code> are not present
in the data, the closest values are used. For <code>"time"</code> and <code>"row"</code>
subsetting, <code>from</code> and <code>to</code> should be in the correct order. No warning or
messages are given if the input values are outside those in the data frame.
For instance, if <code>to = 100</code> and there are only 50 rows in the data, the last
row (50) will be used instead. The same for <code>from</code> and <code>to</code> time values
outside those in the data frame.
</p>
<p>For <code>"oxygen"</code> subsetting, <code>from</code> and <code>to</code> are generally interchangeable, and
the function will subset data <em>between</em> the first and last occurrences (or
closest occurrences) of these values. It works best with generally increasing
or decreasing oxygen data, and results may vary with other data such as
intermittent flow data or those in <code>inspect.ft</code> objects.
</p>
<p><strong>Note for <code>inspect</code> and <code>inspect.ft</code> object inputs:</strong> after subsetting the
locations of any data issues highlighted when the object was originally
inspected will no longer be accurate. If these are important, best practice
is to subset the original dataframe, and then process the subset through
<code>inspect</code> or <code>inspect.ft</code>.
</p>
<p>A summary of the subset can be printed to the console if the default <code>quiet = FALSE</code> is changed to <code>TRUE</code>.
</p>


<h4>More</h4>

<p>For additional help, documentation, vignettes, and more visit the <code>respR</code>
website at <a href="https://januarharianto.github.io/respR/">https://januarharianto.github.io/respR/</a>
</p>



<h3>Value</h3>

<p><strong>Output</strong>: If the input is an <code>inspect</code>, or <code>inspect.ft</code> object, the
output is an object of the same class containing the subset data. For
<code>data.frame</code> inputs the output is a <code>data.table</code> of the subset.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Subset by time:
x &lt;- subset_data(squid.rd, from = 2000, to = 4000, by = "time")

# Subset by oxygen:
subset_data(sardine.rd, from = 94, to = 91, by = "oxygen")

# Subset by row:
subset_data(flowthrough.rd, from = 10, to = 750, by = "row")

# Subset multiple columns:
# In this case subsetting is based on the first two columns
subset_data(flowthrough.rd, from = 50, to = 600, by = "time")

# Pass (via piping) only a subset of a dataset to inspect() and auto_rate()
subset_data(sardine.rd, from = 94, to = 91, by = "oxygen") %&gt;%
   inspect(time = 1, oxygen = 2) %&gt;%
   auto_rate()
   
</code></pre>

<hr>
<h2 id='summary.adjust_rate'>Summarise adjust_rate objects</h2><span id='topic+summary.adjust_rate'></span>

<h3>Description</h3>

<p>Summarise adjust_rate objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'adjust_rate'
summary(object, pos = NULL, export = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.adjust_rate_+3A_object">object</code></td>
<td>
<p>adjust_rate object</p>
</td></tr>
<tr><td><code id="summary.adjust_rate_+3A_pos">pos</code></td>
<td>
<p>integer(s). Which summary row(s) to print.</p>
</td></tr>
<tr><td><code id="summary.adjust_rate_+3A_export">export</code></td>
<td>
<p>logical. Export summary table as data frame.</p>
</td></tr>
<tr><td><code id="summary.adjust_rate_+3A_...">...</code></td>
<td>
<p>Pass additional inputs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print to console. No returned value.
</p>

<hr>
<h2 id='summary.adjust_rate.ft'>Summarise adjust_rate.ft objects</h2><span id='topic+summary.adjust_rate.ft'></span>

<h3>Description</h3>

<p>Summarise adjust_rate.ft objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'adjust_rate.ft'
summary(object, pos = NULL, export = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.adjust_rate.ft_+3A_object">object</code></td>
<td>
<p>adjust_rate.ft object</p>
</td></tr>
<tr><td><code id="summary.adjust_rate.ft_+3A_pos">pos</code></td>
<td>
<p>integer(s). Which summary row(s) to print.</p>
</td></tr>
<tr><td><code id="summary.adjust_rate.ft_+3A_export">export</code></td>
<td>
<p>logical. Export summary table as data frame.</p>
</td></tr>
<tr><td><code id="summary.adjust_rate.ft_+3A_...">...</code></td>
<td>
<p>Pass additional inputs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print to console. No returned value.
</p>

<hr>
<h2 id='summary.auto_rate'>Summarise auto_rate objects</h2><span id='topic+summary.auto_rate'></span>

<h3>Description</h3>

<p>Summarise auto_rate objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'auto_rate'
summary(object, pos = NULL, export = FALSE, print.kds = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.auto_rate_+3A_object">object</code></td>
<td>
<p>auto_rate object</p>
</td></tr>
<tr><td><code id="summary.auto_rate_+3A_pos">pos</code></td>
<td>
<p>integer(s). Which summary row(s) to print.</p>
</td></tr>
<tr><td><code id="summary.auto_rate_+3A_export">export</code></td>
<td>
<p>logical. Export summary table as data frame.</p>
</td></tr>
<tr><td><code id="summary.auto_rate_+3A_print.kds">print.kds</code></td>
<td>
<p>logical. Print summary of the kernel density analysis for
'linear' method.</p>
</td></tr>
<tr><td><code id="summary.auto_rate_+3A_...">...</code></td>
<td>
<p>Pass additional inputs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print to console. No returned value.
</p>

<hr>
<h2 id='summary.auto_rate.int'>Summarise auto_rate.int objects</h2><span id='topic+summary.auto_rate.int'></span>

<h3>Description</h3>

<p>Summarise auto_rate.int objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'auto_rate.int'
summary(object, pos = NULL, export = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.auto_rate.int_+3A_object">object</code></td>
<td>
<p>auto_rate.int object</p>
</td></tr>
<tr><td><code id="summary.auto_rate.int_+3A_pos">pos</code></td>
<td>
<p>integer(s). Which replicate(s) to print.</p>
</td></tr>
<tr><td><code id="summary.auto_rate.int_+3A_export">export</code></td>
<td>
<p>logical. Export summary table as data frame.</p>
</td></tr>
<tr><td><code id="summary.auto_rate.int_+3A_...">...</code></td>
<td>
<p>Pass additional inputs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print to console. No returned value.
</p>

<hr>
<h2 id='summary.calc_rate'>Summarise calc_rate objects</h2><span id='topic+summary.calc_rate'></span>

<h3>Description</h3>

<p>Summarise calc_rate objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'calc_rate'
summary(object, pos = NULL, export = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.calc_rate_+3A_object">object</code></td>
<td>
<p>calc_rate object</p>
</td></tr>
<tr><td><code id="summary.calc_rate_+3A_pos">pos</code></td>
<td>
<p>integer(s). Which summary row(s) to print.</p>
</td></tr>
<tr><td><code id="summary.calc_rate_+3A_export">export</code></td>
<td>
<p>logical. Export summary table as data frame.</p>
</td></tr>
<tr><td><code id="summary.calc_rate_+3A_...">...</code></td>
<td>
<p>Pass additional inputs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print to console. No returned value.
</p>

<hr>
<h2 id='summary.calc_rate.bg'>Summarise calc_rate.bg objects</h2><span id='topic+summary.calc_rate.bg'></span>

<h3>Description</h3>

<p>Summarise calc_rate.bg objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'calc_rate.bg'
summary(object, pos = NULL, export = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.calc_rate.bg_+3A_object">object</code></td>
<td>
<p>calc_rate.bg object</p>
</td></tr>
<tr><td><code id="summary.calc_rate.bg_+3A_pos">pos</code></td>
<td>
<p>integer(s). Which summary row(s) to print.</p>
</td></tr>
<tr><td><code id="summary.calc_rate.bg_+3A_export">export</code></td>
<td>
<p>logical. Export summary table as data frame.</p>
</td></tr>
<tr><td><code id="summary.calc_rate.bg_+3A_...">...</code></td>
<td>
<p>Pass additional inputs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print to console. No returned value.
</p>

<hr>
<h2 id='summary.calc_rate.ft'>Summarise calc_rate.ft objects</h2><span id='topic+summary.calc_rate.ft'></span>

<h3>Description</h3>

<p>Summarise calc_rate.ft objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'calc_rate.ft'
summary(object, pos = NULL, export = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.calc_rate.ft_+3A_object">object</code></td>
<td>
<p>calc_rate.ft object</p>
</td></tr>
<tr><td><code id="summary.calc_rate.ft_+3A_pos">pos</code></td>
<td>
<p>integer(s). Which summary row(s) to print.</p>
</td></tr>
<tr><td><code id="summary.calc_rate.ft_+3A_export">export</code></td>
<td>
<p>logical. Export summary table as data frame.</p>
</td></tr>
<tr><td><code id="summary.calc_rate.ft_+3A_...">...</code></td>
<td>
<p>Pass additional inputs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print to console. No returned value.
</p>

<hr>
<h2 id='summary.calc_rate.int'>Summarise calc_rate.int objects</h2><span id='topic+summary.calc_rate.int'></span>

<h3>Description</h3>

<p>Summarise calc_rate.int objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'calc_rate.int'
summary(object, pos = NULL, export = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.calc_rate.int_+3A_object">object</code></td>
<td>
<p>calc_rate.int object</p>
</td></tr>
<tr><td><code id="summary.calc_rate.int_+3A_pos">pos</code></td>
<td>
<p>integer(s). Which replicate(s) to print.</p>
</td></tr>
<tr><td><code id="summary.calc_rate.int_+3A_export">export</code></td>
<td>
<p>logical. Export summary table as data frame.</p>
</td></tr>
<tr><td><code id="summary.calc_rate.int_+3A_...">...</code></td>
<td>
<p>Pass additional inputs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print to console. No returned value.
</p>

<hr>
<h2 id='summary.convert_DO'>Summarise convert_DO objects</h2><span id='topic+summary.convert_DO'></span>

<h3>Description</h3>

<p>Summarise convert_DO objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'convert_DO'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.convert_DO_+3A_object">object</code></td>
<td>
<p>convert_DO object</p>
</td></tr>
<tr><td><code id="summary.convert_DO_+3A_...">...</code></td>
<td>
<p>Pass additional inputs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print to console. No returned value.
</p>

<hr>
<h2 id='summary.convert_rate'>Summarise convert_rate objects</h2><span id='topic+summary.convert_rate'></span>

<h3>Description</h3>

<p>Summarise convert_rate objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'convert_rate'
summary(object, pos = NULL, export = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.convert_rate_+3A_object">object</code></td>
<td>
<p>convert_rate object</p>
</td></tr>
<tr><td><code id="summary.convert_rate_+3A_pos">pos</code></td>
<td>
<p>integer(s). Which summary row(s) to print.</p>
</td></tr>
<tr><td><code id="summary.convert_rate_+3A_export">export</code></td>
<td>
<p>logical. Export summary table as data frame.</p>
</td></tr>
<tr><td><code id="summary.convert_rate_+3A_...">...</code></td>
<td>
<p>Pass additional inputs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print to console. No returned value.
</p>

<hr>
<h2 id='summary.convert_rate.ft'>Summarise convert_rate.ft objects</h2><span id='topic+summary.convert_rate.ft'></span>

<h3>Description</h3>

<p>Summarise convert_rate.ft objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'convert_rate.ft'
summary(object, pos = NULL, export = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.convert_rate.ft_+3A_object">object</code></td>
<td>
<p>convert_rate.ft object</p>
</td></tr>
<tr><td><code id="summary.convert_rate.ft_+3A_pos">pos</code></td>
<td>
<p>integer(s). Which summary row(s) to print.</p>
</td></tr>
<tr><td><code id="summary.convert_rate.ft_+3A_export">export</code></td>
<td>
<p>logical. Export summary table as data frame.</p>
</td></tr>
<tr><td><code id="summary.convert_rate.ft_+3A_...">...</code></td>
<td>
<p>Pass additional inputs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print to console. No returned value.
</p>

<hr>
<h2 id='summary.inspect'>Summarise inspect objects</h2><span id='topic+summary.inspect'></span>

<h3>Description</h3>

<p>Summarise inspect objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'inspect'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.inspect_+3A_object">object</code></td>
<td>
<p>inspect object</p>
</td></tr>
<tr><td><code id="summary.inspect_+3A_...">...</code></td>
<td>
<p>Pass additional inputs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print to console. No returned value.
</p>

<hr>
<h2 id='summary.inspect.ft'>Summarise inspect.ft objects</h2><span id='topic+summary.inspect.ft'></span>

<h3>Description</h3>

<p>Summarise inspect.ft objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'inspect.ft'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.inspect.ft_+3A_object">object</code></td>
<td>
<p>inspect.ft object</p>
</td></tr>
<tr><td><code id="summary.inspect.ft_+3A_...">...</code></td>
<td>
<p>Pass additional inputs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print to console. No returned value.
</p>

<hr>
<h2 id='summary.oxy_crit'>Summarise oxy_crit objects</h2><span id='topic+summary.oxy_crit'></span>

<h3>Description</h3>

<p>Summarise oxy_crit objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'oxy_crit'
summary(object, export = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.oxy_crit_+3A_object">object</code></td>
<td>
<p>oxy_crit object</p>
</td></tr>
<tr><td><code id="summary.oxy_crit_+3A_export">export</code></td>
<td>
<p>logical. Export result as data frame.</p>
</td></tr>
<tr><td><code id="summary.oxy_crit_+3A_...">...</code></td>
<td>
<p>Pass additional inputs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print to console. No returned value.
</p>

<hr>
<h2 id='test_lin'>Perform <code>auto_rate()</code> iteratively and extract performance metrics</h2><span id='topic+test_lin'></span>

<h3>Description</h3>

<p>Randomly generate a dataset and runs <code>auto_rate()</code> on the data to detect
linear regions (with <code>method = "linear"</code>). The function plots 4 exploratory
graphs and outputs the results of a linear regression between detected rate
and true (known) rate, which can demonstrate how much the function is able to
predict true rate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_lin(
  reps = 1,
  len = 300,
  sd = 0.05,
  type = "default",
  preview = FALSE,
  plot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test_lin_+3A_reps">reps</code></td>
<td>
<p>numeric. Number of times to iterate <code>auto_rate()</code> on a randomly
generated dataset. Defaults to 1.</p>
</td></tr>
<tr><td><code id="test_lin_+3A_len">len</code></td>
<td>
<p>numeric. Length (number of observations) of the dataset to test
<code>auto_rate()</code> on. Defaults to 300.</p>
</td></tr>
<tr><td><code id="test_lin_+3A_sd">sd</code></td>
<td>
<p>numeric. Noise to add to the data. Defaults to .05 standard
difference.</p>
</td></tr>
<tr><td><code id="test_lin_+3A_type">type</code></td>
<td>
<p>character. Use &quot;default&quot;, &quot;corrupted&quot; or &quot;segmented&quot; to pick one
of the three different kinds of data to generate.</p>
</td></tr>
<tr><td><code id="test_lin_+3A_preview">preview</code></td>
<td>
<p>logical. This will show the randomly-generated data in your
plot window at every iteration. <strong>Note: will slow the function down.</strong>
Useful to see the shape of the data. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="test_lin_+3A_plot">plot</code></td>
<td>
<p>logical. This will show the diagnostic plots of <code>auto_rate()</code> at
every iteration. <strong>Note: will severely slow the function down.</strong> Useful to
visualise what's being detected at every step. Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>test_lin</code>. Contains linear regression results, and
data required to plot diagnostics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># run 3 iterations (please run at least 1000 times for more reliable visuals)
x &lt;- test_lin(reps = 3)
# plot(x)
# plot(x, "a")  # view only plot "A"
# plot(x, "d")  # view only plot "D". You know what to do (for other plots).
</code></pre>

<hr>
<h2 id='time_lm'>Subset data by time and perform a linear regression.</h2><span id='topic+time_lm'></span>

<h3>Description</h3>

<p>This is an internal function. Used with <code><a href="#topic+time_roll">time_roll()</a></code> and <code><a href="#topic+auto_rate">auto_rate()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_lm(df, start, end)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="time_lm_+3A_df">df</code></td>
<td>
<p>data.frame object.</p>
</td></tr>
<tr><td><code id="time_lm_+3A_start">start</code></td>
<td>
<p>numeric. start time</p>
</td></tr>
<tr><td><code id="time_lm_+3A_end">end</code></td>
<td>
<p>numeric. end time</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.table object
</p>

<hr>
<h2 id='time_roll'>Perform time-width rolling regression</h2><span id='topic+time_roll'></span>

<h3>Description</h3>

<p>This is an internal function. Used by <code><a href="#topic+auto_rate">auto_rate()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_roll(df, width, parallel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="time_roll_+3A_df">df</code></td>
<td>
<p>data.frame object.</p>
</td></tr>
<tr><td><code id="time_roll_+3A_width">width</code></td>
<td>
<p>numeric. width in time</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.table object
</p>

<hr>
<h2 id='unit_args'>Print examples of unit inputs</h2><span id='topic+unit_args'></span>

<h3>Description</h3>

<p>This is a basic function with no inputs. It prints to the console the units
that can be used in the functions <code><a href="#topic+convert_DO">convert_DO()</a></code>, <code><a href="#topic+convert_MR">convert_MR()</a></code>,
<code><a href="#topic+convert_rate">convert_rate()</a></code>, and <code><a href="#topic+convert_rate.ft">convert_rate.ft()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unit_args()
</code></pre>


<h3>Details</h3>

<p>Note that some oxygen unit conversions require temperature (<code>t</code>), salinity
(<code>S</code>), and atmospheric pressure (<code>P</code>) to be specified.
</p>
<p>Note the difference between percent air saturation (<code style="white-space: pre;">&#8288;%Air&#8288;</code>), where air
saturated water is ~100%, and percent oxygen saturation (<code style="white-space: pre;">&#8288;%Oxy&#8288;</code>), where air
saturated water is ~20.946% <em>oxygen</em> saturated. In other words, <code style="white-space: pre;">&#8288;%Oxy = %Air x 0.20946&#8288;</code>.
</p>
<p>For most units a fuzzy string matching algorithm is used to accept different
formatting styles. For example, <code>"mg/l"</code>, <code>"mg/L"</code>, <code>"mgL-1"</code>, <code>"mg l-1"</code>,
<code>"mg.l-1"</code> are all parsed the same.
</p>


<h4><code><a href="#topic+convert_DO">convert_DO()</a></code></h4>



<h5>Oxygen concentration or pressure units for <code>from</code> and <code>to</code>:</h5>

<p>Oxygen concentration units. Should use SI units (<code>L</code> or <code>kg</code>) for the
denominator.
</p>
<p>Do <em>NOT</em> require <code>t</code>, <code>S</code> and <code>P</code> for conversions:
</p>

<ul>
<li> <p><code>"mg/L"</code>, <code>"ug/L"</code>, <code>"mol/L"</code>, <code>"mmol/L"</code>, <code>"umol/L"</code>, <code>"nmol/L"</code>, <code>"pmol/L"</code>
</p>
</li></ul>

<p>Require <code>t</code>, <code>S</code> and <code>P</code> for conversions:
</p>

<ul>
<li> <p><code>"uL/L"</code>, <code>"mL/L"</code>, <code>"mm3/L"</code>, <code>"cm3/L"</code>, <code>"mg/kg"</code>, <code>"ug/kg"</code>, <code>"mol/kg"</code>, <code>"mmol/kg"</code>, <code>"umol/kg"</code>,
<code>"nmol/kg"</code>, <code>"pmol/kg"</code>, <code>"uL/kg"</code>, <code>"mL/kg"</code>, <code>"ppm"</code> (i.e. parts per
million, equivalent to <code>mg/kg</code>).
</p>
</li></ul>

<p>Percentage saturations (require <code>t</code>, <code>S</code> and <code>P</code>):
</p>
<p><code>"%Air"</code> (i.e. % Air Saturation), <code>"%Oxy"</code> (i.e. % Oxygen Saturation)
</p>
<p>Pressure units (require <code>t</code>, <code>S</code> and <code>P</code>):
</p>
<p><code>"Torr"</code>, <code>"hPa"</code>, <code>"kPa"</code>, <code>"mmHg"</code>, <code>"inHg"</code>
</p>




<h4><code><a href="#topic+convert_rate">convert_rate()</a></code> and <code><a href="#topic+convert_rate.ft">convert_rate.ft()</a></code></h4>



<h5>Oxygen concentration or pressure units for <code>oxy.unit</code>:</h5>

<p>See above.
</p>



<h5>Time units for <code>time.unit</code> or as part of <code>flowrate.unit</code>:</h5>


<ul>
<li> <p><code style="white-space: pre;">&#8288;"sec", "min", "hour", "day"&#8288;</code>
</p>
</li></ul>




<h5>Volume units for use as part of <code>flowrate.unit</code> (<code>convert_rate.ft</code> only):</h5>

<p>For example, in <code>'ml/min'</code>, <code>'L/s'</code>, etc.
</p>

<ul>
<li> <p><code>"uL"</code>, <code>"mL"</code>, <code>"L"</code>
</p>
</li></ul>





<h4>Metabolic rate units</h4>

<p>Combining units for <code>output.unit</code> in <code><a href="#topic+convert_rate">convert_rate()</a></code> and
<code><a href="#topic+convert_rate.ft">convert_rate.ft()</a></code>, or for use in <code><a href="#topic+convert_MR">convert_MR()</a></code>, must follow these
orders:
</p>

<ul>
<li><p> Absolute rates: <code>Oxygen/Time</code> e.g. <code>"mg/s"</code>, <code>"umol/min"</code>, <code>"mL/h"</code>
</p>
</li>
<li><p> Mass-specific rates: <code>Oxygen/Time/Mass</code> e.g. <code>"mg/s/ug"</code>, <code>"umol/min/g"</code>,
<code>"mL/h/kg"</code>
</p>
</li>
<li><p> Area-specific rates: <code>Oxygen/Time/Area</code> e.g. <code>"mg/s/mm2"</code>,
<code>"umol/min/cm2"</code>, <code>"mL/h/m2"</code>
</p>
</li></ul>

<p><strong>Oxygen amount units:</strong>
</p>

<ul>
<li> <p><code>"ug"</code>, <code>"mg"</code>, <code>"pmol"</code>, <code>"nmol"</code>, <code>"umol"</code>, <code>"mmol"</code>, <code>"mol"</code>, <code>"uL"</code>, <code>"mL"</code>, <code>"mm3"</code>, <code>"cm3"</code>
</p>
</li></ul>

<p>Note <code>"mm3"</code> and <code>"cm3"</code> (i.e. <code>cc</code>) are used in some older publications.
These are equivalent to <code>"uL"</code> and <code>"mL"</code> respectively.
</p>
<p><strong>Time units:</strong>
</p>

<ul>
<li> <p><code>"sec"</code>, <code>"min"</code>, <code>"hour"</code>, <code>"day"</code>
</p>
</li></ul>

<p><strong>Mass units for mass-specific rates:</strong>
</p>

<ul>
<li> <p><code>"ug"</code>, <code>"mg"</code>, <code>"g"</code>, <code>"kg"</code>
</p>
</li></ul>

<p><strong>Area units for area-specific rates:</strong>
</p>

<ul>
<li> <p><code>"mm2"</code>, <code>"cm2"</code>, <code>"m2"</code>, <code>"km2"</code>
</p>
</li></ul>




<h3>Value</h3>

<p>A print out to the console of accepted units
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Run the function:
unit_args()
</code></pre>

<hr>
<h2 id='unit_type'>Search for and classify units</h2><span id='topic+unit_type'></span>

<h3>Description</h3>

<p>Search for and classify units
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unit_type(unit, msg = "")
</code></pre>

<hr>
<h2 id='unit_type_o1'>Search for and classify oxygen units as used in concentration or rates</h2><span id='topic+unit_type_o1'></span>

<h3>Description</h3>

<p>Search for and classify oxygen units as used in concentration or rates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unit_type_o1(unit, msg = "")
</code></pre>

<hr>
<h2 id='units.clean'>Cleans units from units.val to remove the suffix (.o2, .flow, etc)</h2><span id='topic+units.clean'></span>

<h3>Description</h3>

<p>These are the 'clean' or parsed names we want to use in outputs. All input
units get parsed to these.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'clean'
units(unit, is)
</code></pre>


<h3>Details</h3>

<p>Could make code much simpler with a regex for everything after the &quot;.&quot; but i
like the specificity of this.
</p>

<hr>
<h2 id='units.val'>Check unit string against allowed values. See util_fns.R file for regex
patterns</h2><span id='topic+units.val'></span>

<h3>Description</h3>

<p>These names (before the .o2, .vol, etc.) are the 'clean' or parsed names we
want to use in outputs. All inputs units get parsed to these in units.clean
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'val'
units(unit, is, msg = "units.val")
</code></pre>

<hr>
<h2 id='urchins.rd'>Multi-column respirometry data of the sea urchin, <em>Heliocidaris
Erythrogramma</em>, including background respiration</h2><span id='topic+urchins.rd'></span>

<h3>Description</h3>

<p>Oxygen consumption data of 16 individual <em>Heliocidaris erythrogramma</em>
specimens. In addition, there are two columns of background respiration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>urchins.rd
</code></pre>


<h3>Format</h3>

<p>A data frame object consisting of one column of time, 16 columns of
urchin oxygen consumption (<code>a</code> to <code>p</code>) and 2 columns of background oxygen
consumption (<code>b1</code> &amp; <code>b2</code>). There are 271 rows of data spanning 45 minutes.
</p>


<h3>Details</h3>


<ul>
<li><p> Dissolved oxygen units: <code>mg/L</code>
</p>
</li>
<li><p> Time units: <code>minutes</code>
</p>
</li>
<li><p> Volume (L): <code>1.09</code>
</p>
</li>
<li><p> Temperature (°C): <code>20</code>
</p>
</li>
<li><p> Salinity: <code>30</code>
</p>
</li>
<li><p> Atm. Pressure (bar): <code>1.01</code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Januar Harianto
</p>

<hr>
<h2 id='validate_auto_rate'>Validation function for auto_rate</h2><span id='topic+validate_auto_rate'></span>

<h3>Description</h3>

<p>This is an internal function for <code>auto_rate()</code>. Used to validate inputs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_auto_rate(x, by, method)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_auto_rate_+3A_x">x</code></td>
<td>
<p>data.frame object.</p>
</td></tr>
<tr><td><code id="validate_auto_rate_+3A_by">by</code></td>
<td>
<p>string.</p>
</td></tr>
<tr><td><code id="validate_auto_rate_+3A_method">method</code></td>
<td>
<p>string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame object of the original data
</p>

<hr>
<h2 id='zeb_intermittent.rd'>Respirometry data of a zebrafish, <em>Danio rerio</em></h2><span id='topic+zeb_intermittent.rd'></span>

<h3>Description</h3>

<p>Multiple measurements (106 replicates, plus initial and end background
measurements) of oxygen consumption in a zebrafish, <em>Danio rerio</em>, obtained
using intermittent flow respirometry. Data kindly provided by Davide
Thambithurai (University of Glasgow). Note, the data has been injected with
random noise, and volume and mass below are not the actual values from the
experiment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zeb_intermittent.rd
</code></pre>


<h3>Format</h3>

<p>A data frame object consisting of 2 columns (time and dissolved
oxygen) and 79251 rows (approx 22h of data).
</p>


<h3>Details</h3>


<ul>
<li><p> Dissolved oxygen units: <code>mg/L</code>
</p>
</li>
<li><p> Time units: <code>seconds</code>
</p>
</li>
<li><p> Chamber volume (L): <code>0.12</code>
</p>
</li>
<li><p> Specimen wet mass (kg): '0.0009
</p>
</li>
<li><p> Temperature (°C): <code>25</code>
</p>
</li>
<li><p> Salinity: <code>0</code>
</p>
</li>
<li><p> Atm. Pressure (bar): <code>1.013253</code>
</p>
</li></ul>

<p>Replicate structure (Rows - Experiment section):
</p>

<ul>
<li> <p><code>1:4999</code>      - Start background recording
</p>
</li>
<li> <p><code>5000:5839</code>   - First replicate for MMR (14 mins duration)
</p>
</li>
<li> <p><code>5840:75139</code>  - 105 further replicates of 11 minutes duration each (660 rows)
</p>
</li>
<li> <p><code>75140:79251</code> - End background recording
</p>
</li></ul>

<p>Each replicate comprises a measurement period (12 minutes for replicate 1, 9
minutes for all others) plus 2 minutes flush.
</p>


<h3>Author(s)</h3>

<p>Davide Thambithurai, University of Glasgow
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
