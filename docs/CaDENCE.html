<!DOCTYPE html><html><head><title>Help for package CaDENCE</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CaDENCE}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CaDENCE-package'><p>Conditional Density Estimation Network Construction and Evaluation (CaDENCE)</p></a></li>
<li><a href='#bgamma'>
<p>Bernoulli-gamma distribution</p></a></li>
<li><a href='#blnorm'>
<p>Bernoulli-lognormal distribution</p></a></li>
<li><a href='#bweibull'>
<p>Bernoulli-Weibull distribution</p></a></li>
<li><a href='#cadence.cost'>
<p>Cost function for CDEN model fitting</p></a></li>
<li><a href='#cadence.fit'>
<p>Fit a CDEN model</p></a></li>
<li><a href='#cadence.initialize'>
<p>Initialize a CDEN weight vector</p></a></li>
<li><a href='#cadence.predict'>
<p>Predict conditional distribution parameters from a fitted CDEN model</p></a></li>
<li><a href='#dummy.code'>
<p>Convert a factor to a matrix of dummy codes</p></a></li>
<li><a href='#FraserSediment'>
<p>Sediment and stream discharge data for Fraser River at Hope</p></a></li>
<li><a href='#gam.style'>
<p>GAM-style effects plots for interpreting CDEN models</p></a></li>
<li><a href='#logistic'>
<p>Logistic sigmoid function</p></a></li>
<li><a href='#pareto2'>
<p>Pareto 2 (Lomax) and Bernoulli-Pareto 2 distributions</p></a></li>
<li><a href='#rbf'>
<p>Radial basis function kernel</p></a></li>
<li><a href='#rprop'>
<p>Resilient backpropagation (Rprop) optimization algorithm</p></a></li>
<li><a href='#xval.buffer'>
<p>Cross-validation indices with a buffer between training/validation datasets</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Conditional Density Estimation Network Construction and
Evaluation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.5</td>
</tr>
<tr>
<td>Author:</td>
<td>Alex J. Cannon</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alex J. Cannon &lt;alex.cannon@canada.ca&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Parameters of a user-specified probability distribution are modelled by a multi-layer perceptron artificial neural network. This framework can be used to implement probabilistic nonlinear models including mixture density networks, heteroscedastic regression models, zero-inflated models, etc. following Cannon (2012) &lt;<a href="https://doi.org/10.1016%2Fj.cageo.2011.08.023">doi:10.1016/j.cageo.2011.08.023</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>boot</td>
</tr>
<tr>
<td>Depends:</td>
<td>pso</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-12-04 22:54:00 UTC; ECPACIFIC+cannona</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-12-05 04:05:17 UTC</td>
</tr>
</table>
<hr>
<h2 id='CaDENCE-package'>Conditional Density Estimation Network Construction and Evaluation (CaDENCE)</h2><span id='topic+CaDENCE-package'></span><span id='topic+CaDENCE'></span>

<h3>Description</h3>

<p>A conditional density estimation network (CDEN) is a probabilistic extension
of the standard multi-layer perceptron neural network (MLP) (Neuneier et
al., 1994). A CDEN model allows users to estimate parameters of a specified
probability distribution conditioned upon values of a set of predictors
using the MLP architecture. The result is a flexible nonlinear model that can
be used to calculate the conditional mean, variance, prediction intervals, etc.
based on the specified distribution. Because the CDEN is based on the MLP,
nonlinear relationships, including those involving complicated interactions
between predictors, can be described by the modelling framework. The CaDENCE
(Conditional Density Estimation Network Creation &amp; Evaluation) package
provides routines for creating and evaluating CDEN models in the R
programming language.
</p>


<h3>Details</h3>

<p>Procedures for fitting CaDENCE models are
provided by <code><a href="#topic+cadence.fit">cadence.fit</a></code>, which relies on the
standard <code><a href="stats.html#topic+optim">optim</a></code> function, the CaDENCE <code><a href="#topic+rprop">rprop</a></code>
function, or, optionally, the <code><a href="pso.html#topic+psoptim">psoptim</a></code> function from the
<code>pso</code> package. Once a model has been developed,
<code><a href="#topic+cadence.predict">cadence.predict</a></code> is used to evaluate the
distribution parameters as a function of predictors.
</p>
<p>The package also provides a variety of zero-inflated distributions, including
the Bernoulli-gamma (<code><a href="#topic+bgamma">bgamma</a></code>),
Bernoulli-Weibull (<code><a href="#topic+bweibull">bweibull</a></code>),
Bernoulli-Pareto 2 (<code><a href="#topic+bpareto2">bpareto2</a></code>), and
Bernoulli-lognormal (<code><a href="#topic+blnorm">blnorm</a></code>), for use in the CaDENCE models.
</p>
<p><code><a href="#topic+gam.style">gam.style</a></code>, <code><a href="#topic+dummy.code">dummy.code</a></code>, <code><a href="#topic+xval.buffer">xval.buffer</a></code>,
and <code><a href="#topic+rbf">rbf</a></code> are helper functions that may be useful for
data preprocessing, model evaluation, and interpretation of
fitted relationships.
</p>
<p>Most other functions are used internally and should not normally need to be
called directly by the user.
</p>


<h3>References</h3>

<p>Cannon, A.J., 2012. Neural networks for probabilistic environmental
prediction: Conditional Density Estimation Network Creation &amp; Evaluation
(CaDENCE) in R. Computers &amp; Geosciences 41: 126-135.
doi:10.1016/j.cageo.2011.08.023
</p>
<p>Neuneier, R., F. Hergert, W. Finnoff, and D. Ormoneit, 1994., Estimation of
conditional densities: a comparison of neural network approaches. In:
M. Marinaro and P. Morasso (eds.), Proceedings of ICANN 94, Berlin, Springer,
p. 689-692.
</p>

<hr>
<h2 id='bgamma'>
Bernoulli-gamma distribution
</h2><span id='topic+bgamma'></span><span id='topic+dbgamma'></span><span id='topic+pbgamma'></span><span id='topic+qbgamma'></span><span id='topic+rbgamma'></span>

<h3>Description</h3>

<p>Functions implementing the Bernoulli-gamma distribution, in which zero values
occur with probability <code>1-prob</code> and non-zero values follow a gamma
distribution with <code>scale</code> and <code>shape</code> parameters.
<code>dbgamma</code> gives a probability density function (pdf),
<code>pbgamma</code> gives the cumulative distribution
function (cdf), <code>qbgamma</code> gives the quantile function (inverse cdf),
and <code>rbgamma</code> is used for generating random variates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbgamma(x, prob, scale, shape)
pbgamma(q, prob, scale, shape)
qbgamma(p, prob, scale, shape)
rbgamma(n, prob, scale, shape)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bgamma_+3A_x">x</code>, <code id="bgamma_+3A_q">q</code></td>
<td>

<p>vector of quantiles.
</p>
</td></tr>
<tr><td><code id="bgamma_+3A_p">p</code></td>
<td>

<p>vector of cumulative probabilities.
</p>
</td></tr>
<tr><td><code id="bgamma_+3A_n">n</code></td>
<td>

<p>number of random samples.
</p>
</td></tr>
<tr><td><code id="bgamma_+3A_prob">prob</code></td>
<td>

<p>probability of a non-zero value.
</p>
</td></tr>
<tr><td><code id="bgamma_+3A_scale">scale</code></td>
<td>

<p>scale parameter of the gamma distribution.
</p>
</td></tr>
<tr><td><code id="bgamma_+3A_shape">shape</code></td>
<td>

<p>shape parameter of the gamma distribution.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dbgamma</code> gives the pdf, <code>pbgamma</code> gives the cdf,
<code>qbgamma</code> gives the inverse cdf (or quantile function), and
<code>rbgamma</code> generates random deviates.
</p>


<h3>References</h3>

<p>Cannon, A.J., 2008. Probabilistic multi-site precipitation downscaling
by an expanded Bernoulli-gamma density network. Journal of
Hydrometeorology, 9(6): 1284-1300.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dgamma">dgamma</a></code>, <code><a href="#topic+bweibull">bweibull</a></code>, <code><a href="#topic+bpareto2">bpareto2</a></code>,
<code><a href="#topic+blnorm">blnorm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  plot(rbgamma(365, prob = 0.2, scale = 1, shape = 1), type = "h")
</code></pre>

<hr>
<h2 id='blnorm'>
Bernoulli-lognormal distribution
</h2><span id='topic+blnorm'></span><span id='topic+dblnorm'></span><span id='topic+pblnorm'></span><span id='topic+qblnorm'></span><span id='topic+rblnorm'></span>

<h3>Description</h3>

<p>Functions implementing the Bernoulli-lognormal distribution, in which zero values
occur with probability <code>1-prob</code> and non-zero values follow a lognormal
distribution with <code>meanlog</code> and <code>sdlog</code> parameters.
<code>dblnorm</code> gives a probability density function (pdf),
<code>pblnorm</code> gives the cumulative distribution
function (cdf), <code>qblnorm</code> gives the quantile function (inverse cdf),
and <code>rblnorm</code> is used for generating random variates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dblnorm(x, prob, meanlog, sdlog)
pblnorm(q, prob, meanlog, sdlog)
qblnorm(p, prob, meanlog, sdlog)
rblnorm(n, prob, meanlog, sdlog)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blnorm_+3A_x">x</code>, <code id="blnorm_+3A_q">q</code></td>
<td>

<p>vector of quantiles.
</p>
</td></tr>
<tr><td><code id="blnorm_+3A_p">p</code></td>
<td>

<p>vector of cumulative probabilities.
</p>
</td></tr>
<tr><td><code id="blnorm_+3A_n">n</code></td>
<td>

<p>number of random samples.
</p>
</td></tr>
<tr><td><code id="blnorm_+3A_prob">prob</code></td>
<td>

<p>probability of a non-zero value.
</p>
</td></tr>
<tr><td><code id="blnorm_+3A_meanlog">meanlog</code></td>
<td>

<p>meanlog parameter of the lognormal distribution.
</p>
</td></tr>
<tr><td><code id="blnorm_+3A_sdlog">sdlog</code></td>
<td>

<p>sdlog parameter of the lognormal distribution.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dblnorm</code> gives the pdf, <code>pblnorm</code> gives the cdf,
<code>qblnorm</code> gives the inverse cdf (or quantile function), and
<code>rblnorm</code> generates random variates.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dlnorm">dlnorm</a></code>, <code><a href="#topic+bweibull">bweibull</a></code>, <code><a href="#topic+bpareto2">bpareto2</a></code>,
<code><a href="#topic+bgamma">bgamma</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  plot(rblnorm(365, prob = 0.2, meanlog = 1, sdlog = 1), type = "h")
</code></pre>

<hr>
<h2 id='bweibull'>
Bernoulli-Weibull distribution
</h2><span id='topic+bweibull'></span><span id='topic+dbweibull'></span><span id='topic+pbweibull'></span><span id='topic+qbweibull'></span><span id='topic+rbweibull'></span>

<h3>Description</h3>

<p>Functions implementing the Bernoulli-Weibull distribution, in which zero values
occur with probability <code>1-prob</code> and non-zero values follow a Weibull
distribution with <code>scale</code> and <code>shape</code> parameters.
<code>dbweibull</code> gives a probability density function (pdf),
<code>pbweibull</code> gives the cumulative distribution
function (cdf), <code>qbweibull</code> gives the quantile function (inverse cdf),
and <code>rbweibull</code> is used for generating random variates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbweibull(x, prob, scale, shape)
pbweibull(q, prob, scale, shape)
qbweibull(p, prob, scale, shape)
rbweibull(n, prob, scale, shape)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bweibull_+3A_x">x</code>, <code id="bweibull_+3A_q">q</code></td>
<td>

<p>vector of quantiles.
</p>
</td></tr>
<tr><td><code id="bweibull_+3A_p">p</code></td>
<td>

<p>vector of cumulative probabilities.
</p>
</td></tr>
<tr><td><code id="bweibull_+3A_n">n</code></td>
<td>

<p>number of random samples.
</p>
</td></tr>
<tr><td><code id="bweibull_+3A_prob">prob</code></td>
<td>

<p>probability of a non-zero value.
</p>
</td></tr>
<tr><td><code id="bweibull_+3A_scale">scale</code></td>
<td>

<p>scale parameter of the weibull distribution.
</p>
</td></tr>
<tr><td><code id="bweibull_+3A_shape">shape</code></td>
<td>

<p>shape parameter of the weibull distribution.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dbweibull</code> gives the pdf, <code>pbweibull</code> gives the cdf,
<code>qbweibull</code> gives the inverse cdf (or quantile function), and
<code>rbweibull</code> generates random variates.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dweibull">dweibull</a></code>, <code><a href="#topic+bgamma">bgamma</a></code>, <code><a href="#topic+bpareto2">bpareto2</a></code>,
<code><a href="#topic+blnorm">blnorm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  plot(rbweibull(365, prob = 0.2, scale = 1, shape = 1), type = "h")
</code></pre>

<hr>
<h2 id='cadence.cost'>
Cost function for CDEN model fitting
</h2><span id='topic+cadence.cost'></span>

<h3>Description</h3>

<p>The maximum likelihood cost function used for CDEN model fitting. 
Calculates the negative of the logarithm of the likelihood. A normal 
distribution prior can be set for the magnitude of the input-hidden 
layer weights, thus leading to weight penalty regularization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cadence.cost(weights, x, y, n.hidden, hidden.fcn, distribution, sd.norm,
             valid)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cadence.cost_+3A_weights">weights</code></td>
<td>

<p>weight vector of length returned by <code><a href="#topic+cadence.initialize">cadence.initialize</a></code>.
</p>
</td></tr>
<tr><td><code id="cadence.cost_+3A_x">x</code></td>
<td>

<p>matrix with number of rows equal to the number of samples and number of columns equal to the number of predictor variables.
</p>
</td></tr>
<tr><td><code id="cadence.cost_+3A_y">y</code></td>
<td>

<p>column matrix of predictand values with number of rows equal to the number of samples.
</p>
</td></tr>
<tr><td><code id="cadence.cost_+3A_n.hidden">n.hidden</code></td>
<td>

<p>number of hidden nodes in the CDEN model.
</p>
</td></tr>
<tr><td><code id="cadence.cost_+3A_hidden.fcn">hidden.fcn</code></td>
<td>

<p>hidden layer transfer function.
</p>
</td></tr>
<tr><td><code id="cadence.cost_+3A_distribution">distribution</code></td>
<td>

<p>a list that describes the probability density function associated with the predictand.
</p>
</td></tr>
<tr><td><code id="cadence.cost_+3A_sd.norm">sd.norm</code></td>
<td>

<p><code>sd</code> parameter for normal distribution prior for the magnitude of input-hidden layer weights; equivalent to weight penalty regularization.
</p>
</td></tr>
<tr><td><code id="cadence.cost_+3A_valid">valid</code></td>
<td>

<p><code>valid</code> logical vector indicating which weights are non-zero or fixed at zero, i.e., due to use of <code>parameters.fixed</code> in <code>distribution</code>.
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+cadence.fit">cadence.fit</a></code>, <code><a href="stats.html#topic+optim">optim</a></code>, <code><a href="#topic+rprop">rprop</a></code>
</p>

<hr>
<h2 id='cadence.fit'>
Fit a CDEN model
</h2><span id='topic+cadence.fit'></span>

<h3>Description</h3>

<p>Fit a CDEN model via nonlinear optimization of the maximum likelihood cost
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cadence.fit(x, y, iter.max = 500, n.hidden = 2, hidden.fcn = tanh,
            distribution = NULL, sd.norm = Inf, init.range = c(-0.5, 0.5),
            method = c("optim", "psoptim", "Rprop"), n.trials = 1,
            trace = 0, maxit.Nelder = 2000, trace.Nelder = 0,
            swarm.size = NULL, vectorize = TRUE,
            delta.0 = 0.1, delta.min = 1e-06, delta.max = 50, epsilon = 1e-08,
            range.mult = 2, step.tol = 1e-08, f.target = -Inf,
            f.cost = cadence.cost, max.exceptions = 500)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cadence.fit_+3A_x">x</code></td>
<td>

<p>matrix with number of rows equal to the number of samples and number of columns equal to the number of predictor variables.
</p>
</td></tr>
<tr><td><code id="cadence.fit_+3A_y">y</code></td>
<td>

<p>column matrix of predictand values with number of rows equal to the number of samples.
</p>
</td></tr>
<tr><td><code id="cadence.fit_+3A_iter.max">iter.max</code></td>
<td>

<p>maximum number of iterations of the optimization function.
</p>
</td></tr>
<tr><td><code id="cadence.fit_+3A_n.hidden">n.hidden</code></td>
<td>

<p>number of hidden nodes in the CDEN model; can be a vector indicating a range of values to fit.
</p>
</td></tr>
<tr><td><code id="cadence.fit_+3A_hidden.fcn">hidden.fcn</code></td>
<td>

<p>hidden layer transfer function.
</p>
</td></tr>
<tr><td><code id="cadence.fit_+3A_distribution">distribution</code></td>
<td>

<p>a list that describes the probability density function associated with the predictand.
</p>
</td></tr>
<tr><td><code id="cadence.fit_+3A_sd.norm">sd.norm</code></td>
<td>

<p><code>sd</code> parameter for normal distribution prior for the magnitude of input-hidden layer weights; equivalent to weight penalty regularization.
</p>
</td></tr>
<tr><td><code id="cadence.fit_+3A_init.range">init.range</code></td>
<td>

<p>range for random weights on [<code>min(init.range)</code>, <code>max(init.range)</code>]
</p>
</td></tr>
<tr><td><code id="cadence.fit_+3A_method">method</code></td>
<td>

<p>specifies the optimization method used to minimize <code><a href="#topic+cadence.cost">cadence.cost</a></code>; must be chosen from <code>c("optim", "psoptim", "Rprop")</code>.
</p>
</td></tr>
<tr><td><code id="cadence.fit_+3A_n.trials">n.trials</code></td>
<td>

<p>number of repeated trials used to avoid shallow local minima during optimization.
</p>
</td></tr>
<tr><td><code id="cadence.fit_+3A_trace">trace</code></td>
<td>

<p>the level of printing which is done during optimization. A value of <code>0</code> suppresses
any progress reporting.
</p>
</td></tr>
<tr><td><code id="cadence.fit_+3A_maxit.nelder">maxit.Nelder</code></td>
<td>

<p>maximum number of iterations of the Nelder-Mead optimization function prior to main calling <code>method</code>.
</p>
</td></tr>
<tr><td><code id="cadence.fit_+3A_trace.nelder">trace.Nelder</code></td>
<td>

<p>the level of printing which is done during Nelder-Mead optimization. A value of <code>0</code> suppresses
any progress reporting.
</p>
</td></tr>
<tr><td><code id="cadence.fit_+3A_swarm.size">swarm.size</code></td>
<td>

<p><code>swarm.size</code> if <code><a href="pso.html#topic+psoptim">psoptim</a></code> is used for optimization.
</p>
</td></tr>
<tr><td><code id="cadence.fit_+3A_vectorize">vectorize</code></td>
<td>

<p><code>vectorize</code> if <code><a href="pso.html#topic+psoptim">psoptim</a></code> is used for optimization.
</p>
</td></tr>
<tr><td><code id="cadence.fit_+3A_delta.0">delta.0</code></td>
<td>

<p>size of the initial update-value if <code><a href="#topic+rprop">rprop</a></code> is used for optimization.
</p>
</td></tr>
<tr><td><code id="cadence.fit_+3A_delta.min">delta.min</code></td>
<td>

<p>minimum value for the adaptive update-value if <code><a href="#topic+rprop">rprop</a></code> is used for optimization.
</p>
</td></tr>
<tr><td><code id="cadence.fit_+3A_delta.max">delta.max</code></td>
<td>

<p>maximum value for the adaptive update-value if <code><a href="#topic+rprop">rprop</a></code> is used for optimization.
</p>
</td></tr>
<tr><td><code id="cadence.fit_+3A_epsilon">epsilon</code></td>
<td>

<p>step-size used in the finite difference calculation of the gradient if <code><a href="#topic+rprop">rprop</a></code> is used for optimization.
</p>
</td></tr>
<tr><td><code id="cadence.fit_+3A_range.mult">range.mult</code></td>
<td>

<p>if <code><a href="pso.html#topic+psoptim">psoptim</a></code> is used for optimization, sets the search space boundaries to <code>range.mult</code> times the range of weights found by the Nelder-Mead algorithm.
</p>
</td></tr>
<tr><td><code id="cadence.fit_+3A_step.tol">step.tol</code></td>
<td>

<p>convergence criterion if <code><a href="#topic+rprop">rprop</a></code> is used for optimization. Optimization will stop if the change in <code>f</code> over the previous three iterations falls below this value.
</p>
</td></tr>
<tr><td><code id="cadence.fit_+3A_f.target">f.target</code></td>
<td>

<p>target value of <code>f</code> if <code><a href="#topic+rprop">rprop</a></code> is used for optimization. Optimization will stop if <code>f</code> falls below this value.
</p>
</td></tr>
<tr><td><code id="cadence.fit_+3A_f.cost">f.cost</code></td>
<td>

<p>cost function to be optimized.
</p>
</td></tr>
<tr><td><code id="cadence.fit_+3A_max.exceptions">max.exceptions</code></td>
<td>

<p>maximum number of repeated exceptions allowed during optimization.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fit a CDEN model by optimizing the maximum likelihood cost function
<code>f.cost</code>, which is set by default to <code><a href="#topic+cadence.cost">cadence.cost</a></code>.
Optimization relies on the standard <code><a href="stats.html#topic+optim">optim</a></code> function, the
built-in <code><a href="#topic+rprop">rprop</a></code> function, or, optionally,
the <code><a href="pso.html#topic+psoptim">psoptim</a></code> function from the <code>pso</code> package.
</p>
<p>The hidden layer transfer function <code>hidden.fcn</code> should be set to
<code><a href="base.html#topic+tanh">tanh</a></code> for a nonlinear model and to <code><a href="base.html#topic+identity">identity</a></code> for a
linear model. In the nonlinear case, the number of hidden nodes <code>n.hidden</code>
controls the overall complexity of the model. The predictand distribution
is set by the <code>distribution</code> argument. Parameters of the specified
distribution can be held constant via the <code>parameters.fixed</code> element
<code>distribution</code>. Weight penalty regularization for the magnitude of the
input-hidden layer weights can be applied by setting <code>sd.norm</code> to a value
less than <code>Inf</code>.
</p>
<p>The <code>distribution</code> argument in <code>cadence.fit</code> is the most important
part of the <code>CaDENCE</code> modelling framework and has been designed to be
as flexible as possible. To this end, <code>distribution</code> is a list with three
mandatory elements: <code>density.fcn</code>, which specifies the R density function
for the predictand distribution; <code>parameters</code>, which specifies the names
of the parameters used as arguments in <code>density.fcn</code>; and
<code>output.fcns</code>, which specifies the functions used to constrain the density
function parameters to their allowable ranges (i.e., inverse link
functions). If not specified, <code>distribution</code> defaults to a normal
distribution. Note: the order of <code>parameters</code> and <code>output.fcns</code> must
match the order of arguments in the specified <code>density.fcn</code>.
</p>
<p>A fourth element of <code>distribution</code>, <code>parameters.fixed</code>, is optional.
Setting <code>parameters.fixed</code><code>="sd"</code> for the normal distribution would, for
example, force the <code>sd</code> parameter to take a constant value.
</p>
<p>Samples of <code>distribution</code> lists for a variety of probability distributions
are given below for reference:
</p>
<pre>
# normal distribution
norm.distribution &lt;- list(density.fcn = dnorm,
                          parameters = c("mean", "sd"),
                          parameters.fixed = NULL,
                          output.fcns = c(identity, exp))

# lognormal distribution
lnorm.distribution &lt;- list(density.fcn = dlnorm,
                           parameters = c("meanlog", "sdlog"),
                           parameters.fixed = NULL,
                           output.fcns = c(identity, exp))

# exponential distribution
exp.distribution &lt;- list(density.fcn = dexp,
                         parameters = c("rate"),
                         parameters.fixed = NULL,
                         output.fcns = c(exp))

# Poisson distribution
poisson.distribution &lt;- list(density.fcn = dpois,
                             parameters = c("lambda"),
                             parameters.fixed = NULL,
                             output.fcns = c(exp))

# Bernoulli-gamma distribution
bgamma.distribution &lt;- list(density.fcn = dbgamma,
                            parameters = c("prob", "scale", "shape"),
                            parameters.fixed = NULL,
                            output.fcns = c(logistic, exp, exp))

# Bernoulli-Weibull distribution
bweibull.distribution &lt;- list(density.fcn = dbweibull,
                              parameters = c("prob", "scale", "shape"),
                              parameters.fixed = NULL,
                              output.fcns = c(logistic, exp, exp))

# Bernoulli-lognormal distribution
blnorm.distribution &lt;- list(density.fcn = dblnorm,
                            parameters = c("prob", "meanlog", "sdlog"),
                            parameters.fixed = NULL,
                            output.fcns = c(logistic, identity, exp))

# Bernoulli-Pareto 2 distribution
bpareto2.distribution &lt;- list(density.fcn = dbpareto2,
                          parameters = c("prob", "scale", "shape"),
                          parameters.fixed = NULL,
                          output.fcns = c(logistic, exp, exp))

# beta distribution
beta.distribution &lt;- list(density.fcn=dbeta,
                          parameters=c("shape1", "shape2"),
                          parameters.fixed=NULL,
                          output.fcns=c(exp, exp))

# truncated normal distribution with lower = 0
library(msm)
dtnormal &lt;- function(x, mean, sd) dtnorm(x, mean, sd, lower = 0)
dtnorm.distribution &lt;- list(density.fcn = dtnormal,
                            parameters = c("mean", "sd"),
                            parameters.fixed = NULL,
                            output.fcns = c(identity, exp))

# mixture of two normal distributions (mixture density network)
library(nor1mix)
dnormix &lt;- function(x, mu1, mu2, sig1, sig2, w1){
    if(length(x) &gt; 1){
        dens &lt;- mapply(dnormix, x, mu1 = mu1, mu2 = mu2,
                       sig1 = sig1, sig2 = sig2, w1 = w1)
    } else{
        mix &lt;- norMix(mu = c(mu1, mu2), sigma = c(sig1, sig2),
                      w = c(w1, 1-w1))
        dens &lt;- dnorMix(x, mix)
    }
        dens
}
normix.distribution &lt;- list(density.fcn = dnormix,
                            parameters = c("mu1", "mu2", "sig1",
                                           "sig2", "w1"),
                            parameters.fixed = NULL,
                            output.fcns = c(identity, identity,
                                            exp, exp, logistic))
</pre>
<p>Values of the Akaike information criterion with small sample size correction
(AICc), and Bayesian information criterion (BIC) are calculated to assist in
model selection. It is possible for such criteria to fail in the face of
overfitting, for example with a nonlinear model and <code>n.hidden</code> set too
high, as the distribution may converge on one or more samples. This can usually
be diagnosed by inspecting the scale parameter of the distribution for near
zero values. In this case, one can apply a weight penalty (via <code>sd.norm</code>),
although this rules out the straightforward use of AICc/BIC for model
selection as the effective number of model parameters will no longer equal the
number of weights in the CDEN model.
</p>
<p>Note: values of <code>x</code> need not be standardized or rescaled by the user.
Predictors are automatically scaled to zero mean and unit standard deviation
and are rescaled by <code><a href="#topic+cadence.predict">cadence.predict</a></code>.
</p>


<h3>Value</h3>

<p>a list of with number of elements equal to the length of <code>n.hidden</code>; each list consists of:
</p>
<table>
<tr><td><code>W1</code></td>
<td>
<p>input-hidden layer weights</p>
</td></tr>
<tr><td><code>W2</code></td>
<td>
<p>hidden-output layer weights. Attributes indicating the
mean and standard deviation of columns of <code>x</code>; the value
of <code>hidden.fcn</code>; the valud of <code>hidden.fcn</code>; the negative
log-likelihood <code>NLL</code>; the number of model parameters <code>k</code>;
the value of the weight penalty <code>penalty</code> (if <code>sd.norm</code> is
less than infinity); the value of the <code>BIC</code>, <code>AIC</code>, and
<code>AICc</code> cost-complexity criteria; and the predictand
<code>distribution</code> list are also returned.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Cannon, A.J., 2012. Neural networks for probabilistic environmental
prediction: Conditional Density Estimation Network Creation &amp; Evaluation
(CaDENCE) in R. Computers &amp; Geosciences 41: 126-135.
doi:10.1016/j.cageo.2011.08.023
</p>
<p>Neuneier, R., F. Hergert, W. Finnoff, and D. Ormoneit, 1994., Estimation of
conditional densities: a comparison of neural network approaches. In:
M. Marinaro and P. Morasso (eds.), Proceedings of ICANN 94, Berlin, Springer,
p. 689-692.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cadence.predict">cadence.predict</a></code>, <code><a href="stats.html#topic+optim">optim</a></code>, <code><a href="#topic+rprop">rprop</a></code>,
<code><a href="#topic+xval.buffer">xval.buffer</a></code>, <code><a href="#topic+logistic">logistic</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    data(FraserSediment)
    set.seed(1)
    lnorm.distribution &lt;- list(density.fcn = dlnorm,
                               parameters = c("meanlog", "sdlog"),
                               parameters.fixed = NULL,
                               output.fcns = c(identity, exp))
    fit &lt;- cadence.fit(x = FraserSediment$x.1970.1976[c(TRUE, rep(FALSE, 19)),],
                       y = FraserSediment$y.1970.1976[c(TRUE, rep(FALSE, 19)),,
                       drop=FALSE], n.hidden = 3, n.trials = 1,
                       maxit.Nelder = 100, trace.Nelder = 1, hidden.fcn = tanh,
                       distribution = lnorm.distribution, trace = 1)
    pred &lt;- cadence.predict(x = FraserSediment$x.1977.1979, fit = fit)
    matplot(pred, type = "l")
</code></pre>

<hr>
<h2 id='cadence.initialize'>
Initialize a CDEN weight vector
</h2><span id='topic+cadence.initialize'></span><span id='topic+cadence.reshape'></span>

<h3>Description</h3>

<p>Random initialization of the weight vector used during fitting of the CDEN model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cadence.initialize(x, n.hidden, init.range, distribution)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cadence.initialize_+3A_x">x</code></td>
<td>

<p>matrix with number of rows equal to the number of samples and number of columns equal to the number of predictors.
</p>
</td></tr>
<tr><td><code id="cadence.initialize_+3A_n.hidden">n.hidden</code></td>
<td>

<p>number of hidden nodes in the CDEN model.
</p>
</td></tr>
<tr><td><code id="cadence.initialize_+3A_init.range">init.range</code></td>
<td>

<p>range for random weights on [<code>min(init.range)</code>, <code>max(init.range)</code>]
</p>
</td></tr>
<tr><td><code id="cadence.initialize_+3A_distribution">distribution</code></td>
<td>

<p>list used to specify the predictand distribution
</p>
</td></tr>
</table>

<hr>
<h2 id='cadence.predict'>
Predict conditional distribution parameters from a fitted CDEN model
</h2><span id='topic+cadence.predict'></span><span id='topic+cadence.evaluate'></span>

<h3>Description</h3>

<p>Predict conditional distribution parameters from a fitted CDEN model.
The returned value is a matrix with columns corresponding to the parameters
of the probability distribution specified in the <code>distribution</code>
argument passed to <code><a href="#topic+cadence.fit">cadence.fit</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cadence.predict(x, fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cadence.predict_+3A_x">x</code></td>
<td>

<p>matrix with number of rows equal to the number of samples and number of columns equal to the number of predictor variables.
</p>
</td></tr>
<tr><td><code id="cadence.predict_+3A_fit">fit</code></td>
<td>

<p>list returned by <code><a href="#topic+cadence.fit">cadence.fit</a></code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with number of rows equal to that of <code>x</code> and columns
corresponding to the parameters of the <code>distribution</code>
argument passed to <code><a href="#topic+cadence.fit">cadence.fit</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cadence.fit">cadence.fit</a></code>, <code><a href="stats.html#topic+optim">optim</a></code>, <code><a href="#topic+rprop">rprop</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    data(FraserSediment)
    lnorm.distribution.fixed &lt;- list(density.fcn = dlnorm,
                                     parameters = c("meanlog", "sdlog"),
                                     parameters.fixed = "sdlog",
                                     output.fcns = c(identity, exp))
    fit &lt;- cadence.fit(x = FraserSediment$x.1970.1976,
                       y = FraserSediment$y.1970.1976,
                       hidden.fcn = identity, maxit.Nelder = 100,
                       trace.Nelder = 1, trace = 1,
                       distribution = lnorm.distribution.fixed)
    pred &lt;- cadence.predict(x = FraserSediment$x.1977.1979, fit = fit)
    matplot(pred, type = "l")
</code></pre>

<hr>
<h2 id='dummy.code'>
Convert a factor to a matrix of dummy codes
</h2><span id='topic+dummy.code'></span>

<h3>Description</h3>

<p>Converts a factor (categorical) variable to a matrix of dummy codes
using a 1 of C-1 binary coding scheme.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dummy.code(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dummy.code_+3A_x">x</code></td>
<td>

<p>a factor variable.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with the number of rows equal to the number of cases in <code>x</code>
and the number of columns equal to one minus the number of factors in
<code>x</code>. The last factor serves as the reference group.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  print(dummy.code(iris$Species))
</code></pre>

<hr>
<h2 id='FraserSediment'>
Sediment and stream discharge data for Fraser River at Hope
</h2><span id='topic+FraserSediment'></span>

<h3>Description</h3>

<p>A dataset consisting of daily observations of suspended sediment concentration
(SSC) (mg/L) and stream discharge (Q) (cu. m/s) for the years 1970-1979 at the
Fraser River at Hope station in British Columbia, Canada (Water Survey of
Canada station 08MF005). Samples are split into a seven year training period
(1970-1976) and a three year testing period (1977-1979).
</p>
<p>In terms of structure, <code>FraserSediment</code> is a list with four elements:
<code>x.1970.1976</code>, <code>y.1970.1976</code>, <code>x.1977.1979</code>,
and <code>y.1977.1979</code>. <code>x.1970.1976</code> and <code>x.1977.1979</code> are
matrices with predictor variables: <code>logQ</code>, log-transformed Q; and
<code>dQ5</code>, <code>dQ30</code>, and <code>dQ90</code>, 5-, 30-, and 90-day moving averages
of daily changes in Q. <code>y.1970.1976</code> and <code>y.1977.1979</code> are matrices
with the predictand variable <code>SSC</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(FraserSediment)
pairs(cbind(FraserSediment$x.1970.1976, FraserSediment$y.1970.1976))
</code></pre>

<hr>
<h2 id='gam.style'>
GAM-style effects plots for interpreting CDEN models
</h2><span id='topic+gam.style'></span>

<h3>Description</h3>

<p>GAM-style effects plots provide a graphical means of interpreting
relationships between predictors and conditional pdf parameter values
predicted by a CDEN. From Plate et al. (2000): The effect of the
<code>i</code>th input variable at a particular input point <code>Delta.i.x</code>
is the change in <code>f</code> resulting from changing <code>X1</code> to <code>x1</code>
from <code>b1</code> (the baseline value [...]) while keeping the other
inputs constant. The effects are plotted as short line segments, centered
at (<code>x.i</code>, <code>Delta.i.x</code>), where the slope of the segment
is given by the partial derivative. Variables that strongly influence
the function value have a large total vertical range of effects.
Functions without interactions appear as possibly broken straight lines
(linear functions) or curves (nonlinear functions). Interactions show up as
vertical spread at a particular horizontal location, that is, a vertical
scattering of segments. Interactions are present when the effect of
a variable depends on the values of other variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gam.style(x, fit, column, baseline = mean(x[,column]),
         additive.scale = FALSE, epsilon = 1e-5,
         seg.len = 0.02, seg.cols = "black", plot = TRUE,
         return.results = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gam.style_+3A_x">x</code></td>
<td>

<p>matrix with number of rows equal to the number of samples and number of columns equal to the number of predictor variables.
</p>
</td></tr>
<tr><td><code id="gam.style_+3A_fit">fit</code></td>
<td>

<p>element from list returned by <code><a href="#topic+cadence.fit">cadence.fit</a></code>.
</p>
</td></tr>
<tr><td><code id="gam.style_+3A_column">column</code></td>
<td>

<p>column of <code>x</code> for which effects plots should be returned.
</p>
</td></tr>
<tr><td><code id="gam.style_+3A_baseline">baseline</code></td>
<td>

<p>value of <code>x[,column]</code> to be used as the baseline for calculation of predictor effects; defaults to <code>mean(x[,column])</code>.
</p>
</td></tr>
<tr><td><code id="gam.style_+3A_additive.scale">additive.scale</code></td>
<td>

<p>if <code>TRUE</code> then predictor effects and partial derivatives are calculated before the inverse link functions for the distribution parameters are applied; if <code>FALSE</code> (the default) then values are calculated after the inverse link functions are applied.
</p>
</td></tr>
<tr><td><code id="gam.style_+3A_epsilon">epsilon</code></td>
<td>

<p>step-size used in the finite difference calculation of the partial derivatives.
</p>
</td></tr>
<tr><td><code id="gam.style_+3A_seg.len">seg.len</code></td>
<td>

<p>length of effects line segments expressed as a fraction of the range of <code>x[,column]</code>.
</p>
</td></tr>
<tr><td><code id="gam.style_+3A_seg.cols">seg.cols</code></td>
<td>

<p>colors of effects line segments.
</p>
</td></tr>
<tr><td><code id="gam.style_+3A_plot">plot</code></td>
<td>

<p>if <code>TRUE</code> (the default) then an effects plots for each distribution parameter is produced.
</p>
</td></tr>
<tr><td><code id="gam.style_+3A_return.results">return.results</code></td>
<td>

<p>if <code>TRUE</code> then values of effects and partial derivatives for each distribution parameter are returned.
</p>
</td></tr>
<tr><td><code id="gam.style_+3A_...">...</code></td>
<td>

<p>further arguments to be passed to <code>plot</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements:
</p>
<table>
<tr><td><code>effects</code></td>
<td>
<p>a matrix of predictor effects.</p>
</td></tr>
<tr><td><code>partials</code></td>
<td>
<p>a matrix of predictor partial derivatives.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Cannon, A.J. and I.G. McKendry, 2002. A graphical sensitivity analysis
for interpreting statistical climate models: Application to Indian
monsoon rainfall prediction by artificial neural networks and
multiple linear regression models. International Journal of
Climatology, 22:1687-1708.
</p>
<p>Plate, T., J. Bert, J. Grace, and P. Band, 2000. Visualizing the function
computed by a feedforward neural network. Neural Computation,
12(6): 1337-1354.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cadence.fit">cadence.fit</a></code>, <code><a href="#topic+cadence.predict">cadence.predict</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    data(FraserSediment)
    set.seed(1)
    lnorm.distribution &lt;- list(density.fcn = dlnorm,
                               parameters = c("meanlog", "sdlog"),
                               parameters.fixed = NULL,
                               output.fcns = c(identity, exp))
    x &lt;- FraserSediment$x.1970.1976[c(TRUE, rep(FALSE, 24)),]
    y &lt;- FraserSediment$y.1970.1976[c(TRUE, rep(FALSE, 24)),,drop=FALSE]
    fit.nlin &lt;- cadence.fit(x, y, n.hidden = 2, n.trials = 1,
                            hidden.fcn = tanh, distribution =
                            lnorm.distribution, maxit.Nelder = 100,
                            trace.Nelder = 1, trace = 1)
    fit.lin &lt;- cadence.fit(x, y, hidden.fcn = identity, n.trials = 1,
                           distribution = lnorm.distribution,
                           maxit.Nelder = 100, trace.Nelder = 1,
                           trace = 1)
    gam.style(x, fit = fit.nlin[[1]], column = 1,
              main = "Nonlinear")
    gam.style(x, fit = fit.lin[[1]], column = 1,
              additive.scale = TRUE,
              main = "Linear (additive.scale = TRUE)")
</code></pre>

<hr>
<h2 id='logistic'>
Logistic sigmoid function
</h2><span id='topic+logistic'></span>

<h3>Description</h3>

<p><code>logistic</code> computes a logistic sigmoid (S-shaped) function bounded between 0 and 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logistic(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logistic_+3A_x">x</code></td>
<td>

<p>a numeric vector
</p>
</td></tr>
</table>

<hr>
<h2 id='pareto2'>
Pareto 2 (Lomax) and Bernoulli-Pareto 2 distributions
</h2><span id='topic+pareto2'></span><span id='topic+bpareto2'></span><span id='topic+dbpareto2'></span><span id='topic+pbpareto2'></span><span id='topic+qbpareto2'></span><span id='topic+rbpareto2'></span><span id='topic+dpareto2'></span><span id='topic+ppareto2'></span><span id='topic+qpareto2'></span><span id='topic+rpareto2'></span>

<h3>Description</h3>

<p>Functions implementing the Pareto 2 (Lomax) and Bernoulli-Pareto 2 distributions. 
In the latter case, zero values occur with probability <code>1-prob</code> and
non-zero values follow the Pareto 2 distribution with <code>scale</code> and
<code>shape</code> parameters. <code>dpareto2</code> and <code>dbpareto2</code> give the probability density
functions (pdf); <code>ppareto2</code> and <code>pbpareto2</code> give the cumulative distribution
functions (cdf); <code>qpareto2</code> and <code>qbpareto2</code> give the quantile functions (inverse cdfs),
and <code>rpareto2</code> and <code>rbpareto2</code> are used for generating random variates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dpareto2(x, scale, shape)
ppareto2(q, scale, shape)
qpareto2(p, scale, shape)
rpareto2(n, scale, shape)
dbpareto2(x, prob, scale, shape)
pbpareto2(q, prob, scale, shape)
qbpareto2(p, prob, scale, shape)
rbpareto2(n, prob, scale, shape)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pareto2_+3A_x">x</code>, <code id="pareto2_+3A_q">q</code></td>
<td>

<p>vector of quantiles.
</p>
</td></tr>
<tr><td><code id="pareto2_+3A_p">p</code></td>
<td>

<p>vector of cumulative probabilities.
</p>
</td></tr>
<tr><td><code id="pareto2_+3A_n">n</code></td>
<td>

<p>number of random samples.
</p>
</td></tr>
<tr><td><code id="pareto2_+3A_prob">prob</code></td>
<td>

<p>probability of a non-zero value.
</p>
</td></tr>
<tr><td><code id="pareto2_+3A_scale">scale</code></td>
<td>

<p>scale parameter of the pareto2 distribution.
</p>
</td></tr>
<tr><td><code id="pareto2_+3A_shape">shape</code></td>
<td>

<p>shape parameter of the pareto2 distribution.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dpareto2</code> and <code>dbpareto2</code> gives the pdfs;
<code>ppareto2</code> and <code>pbpareto2</code> gives the cdfs;
<code>qpareto2</code> and <code>qbpareto2</code> gives the inverse cdfs
(or quantile functions); and <code>rpareto2</code> and
<code>rbpareto2</code> generate random variates.
</p>


<h3>References</h3>

<p>Arnold, B.C., 1983. The Pareto Distributions, International Co-operative
Publishing House, Fairland, MD.
</p>
<p>Lomax, K.S., 1954. Business failures: another example of the analysis of failure
data. Journal of the American Statistical Association, 49(268): 847-852.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bgamma">bgamma</a></code>, <code><a href="#topic+bweibull">bweibull</a></code>, <code><a href="#topic+blnorm">blnorm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  plot(rbpareto2(365, prob = 0.2, scale = 1, shape = 1), type = "h")
</code></pre>

<hr>
<h2 id='rbf'>
Radial basis function kernel
</h2><span id='topic+rbf'></span>

<h3>Description</h3>

<p>Evaluate a kernel matrix based on the radial basis function kernel. Can be 
used in conjunction with <code><a href="#topic+cadence.fit">cadence.fit</a></code> with <code>hidden.fcn</code> 
set to <code><a href="base.html#topic+identity">identity</a></code> and <code>sd.norm</code> set to a value less than 
infinity to implement a kernel CDEN model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rbf(x, x.basis, sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbf_+3A_x">x</code></td>
<td>

<p>matrix with number of rows equal to the number of samples and number of columns equal to the number of predictors.
</p>
</td></tr>
<tr><td><code id="rbf_+3A_x.basis">x.basis</code></td>
<td>

<p>matrix with number of rows equal to the number of basis functions and number of columns equal to the number of predictors.
</p>
</td></tr>
<tr><td><code id="rbf_+3A_sigma">sigma</code></td>
<td>

<p>kernel width
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>kernel matrix with number of rows equal to the number of samples and number of columns equal to the number of basis functions.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cadence.fit">cadence.fit</a></code>
</p>

<hr>
<h2 id='rprop'>
Resilient backpropagation (Rprop) optimization algorithm
</h2><span id='topic+rprop'></span>

<h3>Description</h3>

<p>From Riedmiller (1994): Rprop stands for 'Resilient backpropagation' and is a
local adaptive learning scheme. The basic principle of Rprop is to eliminate the
harmful influence of the size of the partial derivative on the weight step. As a
consequence, only the sign of the derivative is considered to indicate the
direction of the weight update. The size of the weight change is exclusively
determined by a weight-specific, so called 'update-value'.
</p>
<p>This function implements the iRprop+ algorithm from Igel and Huesken (2003).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rprop(w, f, iterlim = 100, print.level = 1, delta.0 = 0.1,
      delta.min = 1e-06, delta.max = 50, epsilon = 1e-08,
      step.tol = 1e-06, f.target = -Inf, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rprop_+3A_w">w</code></td>
<td>

<p>the starting parameters for the minimization.
</p>
</td></tr>
<tr><td><code id="rprop_+3A_f">f</code></td>
<td>

<p>the function to be minimized. If the function value has an attribute called <code>gradient</code>,
this will be used in the calculation of updated parameter values. Otherwise, numerical
derivatives will be used.
</p>
</td></tr>
<tr><td><code id="rprop_+3A_iterlim">iterlim</code></td>
<td>

<p>the maximum number of iterations before the optimization is stopped.
</p>
</td></tr>
<tr><td><code id="rprop_+3A_print.level">print.level</code></td>
<td>

<p>the level of printing which is done during optimization. A value of <code>0</code> suppresses
any progress reporting, whereas positive values report the value of <code>f</code> and the
mean change in <code>f</code> over the previous three iterations.
</p>
</td></tr>
<tr><td><code id="rprop_+3A_delta.0">delta.0</code></td>
<td>

<p>size of the initial Rprop update-value.
</p>
</td></tr>
<tr><td><code id="rprop_+3A_delta.min">delta.min</code></td>
<td>

<p>minimum value for the adaptive Rprop update-value.
</p>
</td></tr>
<tr><td><code id="rprop_+3A_delta.max">delta.max</code></td>
<td>

<p>maximum value for the adaptive Rprop update-value.
</p>
</td></tr>
<tr><td><code id="rprop_+3A_epsilon">epsilon</code></td>
<td>

<p>step-size used in the finite difference calculation of the gradient.
</p>
</td></tr>
<tr><td><code id="rprop_+3A_step.tol">step.tol</code></td>
<td>

<p>convergence criterion. Optimization will stop if the change in <code>f</code> over the previous three iterations falls below this value.
</p>
</td></tr>
<tr><td><code id="rprop_+3A_f.target">f.target</code></td>
<td>

<p>target value of <code>f</code>. Optimization will stop if <code>f</code> falls below this value.
</p>
</td></tr>
<tr><td><code id="rprop_+3A_...">...</code></td>
<td>

<p>further arguments to be passed to <code>f</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements:
</p>
<table>
<tr><td><code>par</code></td>
<td>
<p>The best set of parameters found.</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>The value of <code>f</code> corresponding to <code>par</code>.</p>
</td></tr>
<tr><td><code>gradient</code></td>
<td>
<p>An estimate of the gradient at the solution found.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Igel, C. and M. Huesken, 2003. Empirical evaluation of the improved Rprop
learning algorithms. Neurocomputing 50: 105-123.
</p>
<p>Riedmiller, M., 1994. Advanced supervised learning in multilayer perceptrons -
from backpropagation to adaptive learning techniques. Computer Standards and
Interfaces 16(3): 265-278.
</p>

<hr>
<h2 id='xval.buffer'>
Cross-validation indices with a buffer between training/validation datasets
</h2><span id='topic+xval.buffer'></span>

<h3>Description</h3>

<p>Caculates training/validation indices for N-fold cross-validation of a dataset.
Cross-validation folds are taken as contiguous blocks of cases with an optional
buffer to prevent leakage of information between training/validation subsets
due to the presence of autocorrelation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xval.buffer(n.cases, n.xval=5, buffer.length=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xval.buffer_+3A_n.cases">n.cases</code></td>
<td>

<p>an integer specifying the length of the dataset.
</p>
</td></tr>
<tr><td><code id="xval.buffer_+3A_n.xval">n.xval</code></td>
<td>

<p>an integer specifying the desired number of cross-validation folds.
</p>
</td></tr>
<tr><td><code id="xval.buffer_+3A_buffer.length">buffer.length</code></td>
<td>

<p>an integer specifying the number of cases to be left out as a buffer
between the training/validation subsets.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with <code>n.xval</code> elements, each containing:
</p>
<table>
<tr><td><code>train</code></td>
<td>
<p>indices of training cases</p>
</td></tr>
<tr><td><code>valid</code></td>
<td>
<p>indices of validation cases</p>
</td></tr>
</table>


<h3>References</h3>

<p>Shabbar, A. and V. Kharin. 2007. An assessment of cross-validation
for estimating skill of empirical seasonal forecasts using a
global coupled model simulation. CLIVAR Exchanges. 12(4): 10-12.
</p>
<p>Zeng, Z., W.W. Hsieh, A. Shabbar, and W.W. Burrows, 2011. Seasonal
prediction of winter extreme precipitation over Canada by
support vector regression, Hydrology and Earth System Sciences, 15: 65-74.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  print(xval.buffer(100, n.xval = 3, buffer.length = 10))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
