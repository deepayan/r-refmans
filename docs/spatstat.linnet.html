<!DOCTYPE html><html><head><title>Help for package spatstat.linnet</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spatstat.linnet}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#addVertices'>
<p>Add New Vertices to a Linear Network</p></a></li>
<li><a href='#affine.linnet'><p>Apply Geometrical Transformations to a Linear Network</p></a></li>
<li><a href='#affine.lpp'><p>Apply Geometrical Transformations to Point Pattern on a Linear Network</p></a></li>
<li><a href='#anova.lppm'><p>ANOVA for Fitted Point Process Models on Linear Network</p></a></li>
<li><a href='#as.data.frame.lintess'><p>Convert Network Tessellation to Data Frame</p></a></li>
<li><a href='#as.linfun'>
<p>Convert Data to a Function on a Linear Network</p></a></li>
<li><a href='#as.linim'><p>Convert to Pixel Image on Linear Network</p></a></li>
<li><a href='#as.linnet.linim'>
<p>Extract Linear Network from Data on a Linear Network</p></a></li>
<li><a href='#as.linnet.psp'>
<p>Convert Line Segment Pattern to Linear Network</p></a></li>
<li><a href='#as.lpp'>
<p>Convert Data to a Point Pattern on a Linear Network</p></a></li>
<li><a href='#as.owin.lpp'><p>Convert Data on a Network to class owin</p></a></li>
<li><a href='#auc.lpp'>
<p>Area Under ROC Curve for Data on a Network</p></a></li>
<li><a href='#begins'>
<p>Check Start of Character String</p></a></li>
<li><a href='#berman.test.lpp'><p>Berman's Tests for Point Process Model on a Network</p></a></li>
<li><a href='#branchlabelfun'>
<p>Tree Branch Membership Labelling Function</p></a></li>
<li><a href='#bw.lppl'>
<p>Likelihood Cross Validation Bandwidth Selection for Kernel Density on</p>
a Linear Network</a></li>
<li><a href='#bw.relrisk.lpp'>
<p>Cross Validated Bandwidth Selection for Relative Risk Estimation</p>
on a Network</a></li>
<li><a href='#bw.voronoi'>
<p>Cross Validated Bandwidth Selection for Voronoi Estimator of Intensity</p>
on a Network</a></li>
<li><a href='#cdf.test.lpp'><p>Spatial Distribution Test for Points on a Linear Network</p></a></li>
<li><a href='#chop.linnet'>
<p>Divide a Linear Network into Tiles Using Infinite Lines</p></a></li>
<li><a href='#clickjoin'>
<p>Interactively join vertices on a plot</p></a></li>
<li><a href='#clicklpp'><p>Interactively Add Points on a Linear Network</p></a></li>
<li><a href='#connected.linnet'>
<p>Connected Components of a Linear Network</p></a></li>
<li><a href='#connected.lpp'>
<p>Connected Components of a Point Pattern on a Linear Network</p></a></li>
<li><a href='#crossdist.lpp'><p>Pairwise distances between two point patterns on a linear network</p></a></li>
<li><a href='#crossing.linnet'>
<p>Crossing Points between Linear Network and Other Lines</p></a></li>
<li><a href='#cut.lpp'><p>Classify Points in a Point Pattern on a Network</p></a></li>
<li><a href='#data.lppm'><p>Extract Original Data from a Fitted Point Process Model on a Network</p></a></li>
<li><a href='#delaunayNetwork'>
<p>Linear Network of Delaunay Triangulation or Dirichlet Tessellation</p></a></li>
<li><a href='#deletebranch'>
<p>Delete or Extract a Branch of a Tree</p></a></li>
<li><a href='#density.linnet'><p>Kernel Smoothing of Linear Network</p></a></li>
<li><a href='#density.lpp'>
<p>Kernel Estimate of Intensity on a Linear Network</p></a></li>
<li><a href='#densityEqualSplit'>
<p>Equal-Split Algorithm for Kernel Density on a Network</p></a></li>
<li><a href='#densityfun.lpp'>
<p>Kernel Estimate of Intensity on a Linear Network as a Spatial Function</p></a></li>
<li><a href='#densityHeat.lpp'>
<p>Kernel Density on a Network using Heat Equation</p></a></li>
<li><a href='#densityQuick.lpp'>
<p>Kernel Estimation of Intensity on a Network using a 2D Kernel</p></a></li>
<li><a href='#densityVoronoi.lpp'><p>Intensity Estimate of Point Pattern on Linear Network Using Voronoi-Dirichlet Tessellation</p></a></li>
<li><a href='#diameter.linnet'>
<p>Diameter and Bounding Radius of a Linear Network</p></a></li>
<li><a href='#distfun.lpp'>
<p>Distance Map on Linear Network</p></a></li>
<li><a href='#distmap.lpp'>
<p>Distance Map of Point Pattern on Linear Network</p></a></li>
<li><a href='#divide.linnet'>
<p>Divide Linear Network at Cut Points</p></a></li>
<li><a href='#domain.lpp'>
<p>Extract the Linear Network on which Spatial Data are Defined</p></a></li>
<li><a href='#envelope.lpp'>
<p>Envelope for Point Patterns on Linear Network</p></a></li>
<li><a href='#eval.linim'><p>Evaluate Expression Involving Pixel Images on Linear Network</p></a></li>
<li><a href='#Extract.linim'><p>Extract Subset of Pixel Image on Linear Network</p></a></li>
<li><a href='#Extract.linnet'><p>Extract Subset of Linear Network</p></a></li>
<li><a href='#Extract.lpp'><p>Extract Subset of Point Pattern on Linear Network</p></a></li>
<li><a href='#fitted.lppm'>
<p>Fitted Intensity for Point Process on Linear Network</p></a></li>
<li><a href='#heatkernelapprox'>
<p>Approximation to Heat Kernel on Linear Network at Source Point</p></a></li>
<li><a href='#identify.lpp'><p>Identify Points in a Point Pattern on a Linear Network</p></a></li>
<li><a href='#insertVertices'>
<p>Insert New Vertices in a Linear Network</p></a></li>
<li><a href='#integral.linim'>
<p>Integral on a Linear Network</p></a></li>
<li><a href='#intensity.lpp'>
<p>Empirical Intensity of Point Pattern on Linear Network</p></a></li>
<li><a href='#intersect.lintess'>
<p>Intersection of Tessellations on a Linear Network</p></a></li>
<li><a href='#is.connected.linnet'>
<p>Determine Whether a Linear Network is Connected</p></a></li>
<li><a href='#is.marked.lppm'><p>Test Whether A Point Process Model is Marked</p></a></li>
<li><a href='#is.multitype.lpp'><p>Test Whether A Point Pattern on a Network is Multitype</p></a></li>
<li><a href='#is.multitype.lppm'><p>Test Whether A Point Process Model is Multitype</p></a></li>
<li><a href='#is.stationary.lppm'>
<p>Recognise Stationary and Poisson Point Process Models on a Network</p></a></li>
<li><a href='#joinVertices'>
<p>Join Vertices in a Network</p></a></li>
<li><a href='#lineardirichlet'>
<p>Dirichlet Tessellation on a Linear Network</p></a></li>
<li><a href='#lineardisc'>
<p>Compute Disc of Given Radius in Linear Network</p></a></li>
<li><a href='#linearJinhom'>
<p>Inhomogeneous Linear J-function for Point Processes on Linear Networks</p></a></li>
<li><a href='#linearK'>
<p>Linear K Function</p></a></li>
<li><a href='#linearKcross'>
<p>Multitype K Function (Cross-type) for Linear Point Pattern</p></a></li>
<li><a href='#linearKcross.inhom'>
<p>Inhomogeneous multitype K Function (Cross-type) for Linear Point Pattern</p></a></li>
<li><a href='#linearKdot'>
<p>Multitype K Function (Dot-type) for Linear Point Pattern</p></a></li>
<li><a href='#linearKdot.inhom'>
<p>Inhomogeneous multitype K Function (Dot-type) for Linear Point Pattern</p></a></li>
<li><a href='#linearKEuclid'>
<p>Linear K Function Using Euclidean Distance</p></a></li>
<li><a href='#linearKEuclidInhom'>
<p>Inhomogeneous Linear K Function Based on Euclidean Distances</p></a></li>
<li><a href='#linearKinhom'>
<p>Inhomogeneous Linear K Function</p></a></li>
<li><a href='#linearmarkconnect'>
<p>Mark Connection Function for Multitype Point Pattern on Linear Network</p></a></li>
<li><a href='#linearmarkequal'>
<p>Mark Connection Function for Multitype Point Pattern on Linear Network</p></a></li>
<li><a href='#linearpcf'>
<p>Linear Pair Correlation Function</p></a></li>
<li><a href='#linearpcfcross'>
<p>Multitype Pair Correlation Function (Cross-type) for Linear Point Pattern</p></a></li>
<li><a href='#linearpcfcross.inhom'>
<p>Inhomogeneous Multitype Pair Correlation Function</p>
(Cross-type) for Linear Point Pattern</a></li>
<li><a href='#linearpcfdot'>
<p>Multitype Pair Correlation Function (Dot-type) for Linear Point Pattern</p></a></li>
<li><a href='#linearpcfdot.inhom'>
<p>Inhomogeneous Multitype</p>
Pair Correlation Function (Dot-type) for Linear Point Pattern</a></li>
<li><a href='#linearpcfEuclid'>
<p>Linear Pair Correlation Function Using Euclidean Distance</p></a></li>
<li><a href='#linearpcfEuclidInhom'>
<p>Inhomogeneous Linear Pair Correlation Function Based on Euclidean Distances</p></a></li>
<li><a href='#linearpcfinhom'>
<p>Inhomogeneous Linear Pair Correlation Function</p></a></li>
<li><a href='#lineartileindex'>
<p>Determine Which Tile Contains Each Given Point on a Linear Network</p></a></li>
<li><a href='#linequad'>
<p>Quadrature Scheme on a Linear Network</p></a></li>
<li><a href='#linfun'>
<p>Function on a Linear Network</p></a></li>
<li><a href='#linim'>
<p>Create Pixel Image on Linear Network</p></a></li>
<li><a href='#linnet'>
<p>Create a Linear Network</p></a></li>
<li><a href='#lintess'>
<p>Tessellation on a Linear Network</p></a></li>
<li><a href='#lixellate'>
<p>Subdivide Segments of a Network</p></a></li>
<li><a href='#lpp'>
<p>Create Point Pattern on Linear Network</p></a></li>
<li><a href='#lppm'>
<p>Fit Point Process Model to Point Pattern on Linear Network</p></a></li>
<li><a href='#marks.linnet'><p>Marks of a Network</p></a></li>
<li><a href='#marks.lintess'><p>Marks of a Tessellation on a Network</p></a></li>
<li><a href='#Math.linim'><p>S3 Group Generic Methods for Images on a Linear Network</p></a></li>
<li><a href='#mean.linim'><p>Mean, Median, Quantiles of Pixel Values on a Linear Network</p></a></li>
<li><a href='#methods.linfun'>
<p>Methods for Functions on Linear Network</p></a></li>
<li><a href='#methods.linim'>
<p>Methods for Images on a Linear Network</p></a></li>
<li><a href='#methods.linnet'>
<p>Methods for Linear Networks</p></a></li>
<li><a href='#methods.lpp'>
<p>Methods for Point Patterns on a Linear Network</p></a></li>
<li><a href='#methods.lppm'>
<p>Methods for Fitted Point Process Models on a Linear Network</p></a></li>
<li><a href='#model.frame.lppm'>
<p>Extract the Variables in a Point Process Model on a Network</p></a></li>
<li><a href='#model.images.lppm'><p>Compute Images of Constructed Covariates</p></a></li>
<li><a href='#model.matrix.lppm'><p>Extract Design Matrix from Point Process Model on a Network</p></a></li>
<li><a href='#nncross.lpp'><p>Nearest Neighbours on a Linear Network</p></a></li>
<li><a href='#nndist.lpp'>
<p>Nearest neighbour distances on a linear network</p></a></li>
<li><a href='#nnfromvertex'>
<p>Nearest Data Point From Each Vertex in a Network</p></a></li>
<li><a href='#nnfun.lpp'>
<p>Nearest Neighbour Map on Linear Network</p></a></li>
<li><a href='#nnwhich.lpp'>
<p>Identify Nearest Neighbours on a Linear Network</p></a></li>
<li><a href='#pairdist.lpp'>
<p>Pairwise shortest-path distances between points on</p>
a linear network</a></li>
<li><a href='#pairs.linim'>
<p>Scatterplot Matrix for Pixel Images on a Linear Network</p></a></li>
<li><a href='#persp.linfun'>
<p>Perspective View of Function on a Linear Network</p></a></li>
<li><a href='#persp.linim'>
<p>Perspective View of Pixel Image on a Linear Network</p></a></li>
<li><a href='#plot.linim'>
<p>Plot Pixel Image on Linear Network</p></a></li>
<li><a href='#plot.linnet'>
<p>Plot a linear network</p></a></li>
<li><a href='#plot.lintess'>
<p>Plot a Tessellation on a Linear Network</p></a></li>
<li><a href='#plot.lpp'>
<p>Plot Point Pattern on Linear Network</p></a></li>
<li><a href='#plot.lppm'>
<p>Plot a Fitted Point Process Model on a Linear Network</p></a></li>
<li><a href='#points.lpp'>
<p>Draw Points on Existing Plot</p></a></li>
<li><a href='#predict.lppm'>
<p>Predict Point Process Model on Linear Network</p></a></li>
<li><a href='#pseudoR2.lppm'>
<p>Calculate Pseudo-R-Squared for Point Process Model on Linear Network</p></a></li>
<li><a href='#rcelllpp'>
<p>Simulate Cell Process on Linear Network</p></a></li>
<li><a href='#relrisk.lpp'>
<p>Nonparametric Estimate of Spatially-Varying Relative Risk on a Network</p></a></li>
<li><a href='#repairNetwork'>
<p>Repair Internal Data in a Linear Network</p></a></li>
<li><a href='#Replace.linim'><p>Reset Values in Subset of Image on Linear Network</p></a></li>
<li><a href='#rhohat.lpp'>
<p>Nonparametric Estimate of Intensity as Function of a Covariate</p></a></li>
<li><a href='#rjitter.lpp'><p>Random Perturbation of a Point Pattern on a Network</p></a></li>
<li><a href='#rlpp'>
<p>Random Points on a Linear Network</p></a></li>
<li><a href='#roc.lpp'>
<p>Receiver Operating Characteristic for Data on a Network</p></a></li>
<li><a href='#rpoislpp'>
<p>Poisson Point Process on a Linear Network</p></a></li>
<li><a href='#rSwitzerlpp'>
<p>Switzer-type Point Process on Linear Network</p></a></li>
<li><a href='#rThomaslpp'>
<p>Simulate Thomas Process on Linear Network</p></a></li>
<li><a href='#runiflpp'>
<p>Uniform Random Points on a Linear Network</p></a></li>
<li><a href='#sdr.lpp'>
<p>Sufficient Dimension Reduction for a Point Pattern on a Linear Network</p></a></li>
<li><a href='#simulate.lppm'><p>Simulate a Fitted Point Process Model on a Linear Network</p></a></li>
<li><a href='#Smooth.lpp'><p>Spatial Smoothing of Observations on a Network</p></a></li>
<li><a href='#spatstat.linnet-deprecated'><p>Deprecated spatstat.linnet functions</p></a></li>
<li><a href='#spatstat.linnet-internal'><p>Internal spatstat.linnet functions</p></a></li>
<li><a href='#spatstat.linnet-package'><p>The spatstat.linnet Package</p></a></li>
<li><a href='#subset.lpp'>
<p>Subset of Point Pattern Satisfying A Condition</p></a></li>
<li><a href='#superimpose.lpp'><p>Superimpose Several Point Patterns on Linear Network</p></a></li>
<li><a href='#terminalvertices'><p>Terminal Vertices of a Linear Network</p></a></li>
<li><a href='#text.lpp'>
<p>Add Text Labels to Point Pattern on a Network</p></a></li>
<li><a href='#thinNetwork'>
<p>Remove Vertices or Segments from a Linear Network</p></a></li>
<li><a href='#tile.lengths'><p>Compute Lengths of Tiles in a Tessellation on a Network</p></a></li>
<li><a href='#tilenames.lintess'><p>Names of Tiles in a Tessellation on a Network</p></a></li>
<li><a href='#treebranchlabels'>
<p>Label Vertices of a Tree by Branch Membership</p></a></li>
<li><a href='#treeprune'>
<p>Prune Tree to Given Level</p></a></li>
<li><a href='#unstack.lpp'>
<p>Separate Multiple Columns of Marks</p></a></li>
<li><a href='#Window.lpp'><p>Extract Window of Spatial Object on a Network</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>3.1-5</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-24</td>
</tr>
<tr>
<td>Title:</td>
<td>Linear Networks Functionality of the 'spatstat' Family</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Adrian Baddeley &lt;Adrian.Baddeley@curtin.edu.au&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), spatstat.data (&ge; 3.0-4), spatstat.geom (&ge;
3.2-9), spatstat.random (&ge; 3.2-3), spatstat.explore (&ge;
3.2-7), spatstat.model (&ge; 3.2-11), stats, graphics, grDevices,
methods, utils</td>
</tr>
<tr>
<td>Imports:</td>
<td>spatstat.utils (&ge; 3.0-4), Matrix, spatstat.sparse (&ge; 3.0-3)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>goftest, locfit, spatstat (&ge; 3.0)</td>
</tr>
<tr>
<td>Description:</td>
<td>Defines types of spatial data on a linear network
	     and provides functionality for geometrical operations,
	     data analysis and modelling of data on a linear network,
	     in the 'spatstat' family of packages.
	     Contains definitions and support for linear networks, including creation of networks, geometrical measurements, topological connectivity, geometrical operations such as inserting and deleting vertices, intersecting a network with another object, and interactive editing of networks.
	     Data types defined on a network include point patterns, pixel images, functions, and tessellations.
	     Exploratory methods include kernel estimation of intensity on a network, K-functions and pair correlation functions on a network, simulation envelopes, nearest neighbour distance and empty space distance, relative risk estimation with cross-validated bandwidth selection. Formal hypothesis tests of random pattern (chi-squared, Kolmogorov-Smirnov, Monte Carlo, Diggle-Cressie-Loosmore-Ford, Dao-Genton, two-stage Monte Carlo) and tests for covariate effects (Cox-Berman-Waller-Lawson, Kolmogorov-Smirnov, ANOVA) are also supported.
	Parametric models can be fitted to point pattern data using the function lppm() similar to glm(). Only Poisson models are implemented so far. Models may involve dependence on covariates and dependence on marks. Models are fitted by maximum likelihood.
	Fitted point process models can be simulated, automatically. Formal hypothesis tests of a fitted model are supported (likelihood ratio test, analysis of deviance, Monte Carlo tests) along with basic tools for model selection (stepwise(), AIC()) and variable selection (sdr). Tools for validating the fitted model include simulation envelopes, residuals, residual plots and Q-Q plots, leverage and influence diagnostics, partial residuals, and added variable plots.
	Random point patterns on a network can be generated using a variety of models.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://spatstat.org/">http://spatstat.org/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/spatstat/spatstat.linnet/issues">https://github.com/spatstat/spatstat.linnet/issues</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-24 00:58:11 UTC; adrian</td>
</tr>
<tr>
<td>Author:</td>
<td>Adrian Baddeley <a href="https://orcid.org/0000-0001-9499-8382"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Rolf Turner <a href="https://orcid.org/0000-0001-5521-5218"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cph],
  Ege Rubak <a href="https://orcid.org/0000-0002-6675-533X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cph],
  Greg McSwiggan [aut, cph],
  Tilman Davies [ctb, cph],
  Mehdi Moradi [ctb, cph],
  Suman Rakshit [ctb, cph],
  Ottmar Cronie [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-25 06:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='addVertices'>
Add New Vertices to a Linear Network
</h2><span id='topic+addVertices'></span>

<h3>Description</h3>

<p>Adds new vertices to a linear network
at specified locations outside the network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addVertices(L, X, join=NULL, joinmarks=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addVertices_+3A_l">L</code></td>
<td>

<p>Existing linear network (object of class <code>"linnet"</code>)
or point pattern on a linear network (object of class <code>"lpp"</code>).
</p>
</td></tr>
<tr><td><code id="addVertices_+3A_x">X</code></td>
<td>

<p>Point pattern (object of class <code>"ppp"</code>)
specifying the new vertices.
</p>
</td></tr>
<tr><td><code id="addVertices_+3A_join">join</code></td>
<td>

<p>Optional information specifying how to join the new vertices
<code>X</code> to the existing network. See Details.
If <code>join=NULL</code> (the default),
the new vertices are simply added to the list of network vertices
without being joined to the rest of the network.
</p>
</td></tr>
<tr><td><code id="addVertices_+3A_joinmarks">joinmarks</code></td>
<td>

<p>Optional vector or data frame of marks associated with the
new edges specified by <code>join</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function adds new vertices to an existing
linear network <code>L</code>, at specified locations <code>X</code> outside the network.
</p>
<p>The argument <code>L</code> can be either a linear network (class
<code>"linnet"</code>) or some other object that includes a linear network.
</p>
<p>The new vertex locations are points outside the network,
specified as a point pattern <code>X</code> (object of class <code>"ppp"</code>).
</p>
<p>The argument <code>join</code> specifies how to join the new vertices
to the existing network. 
</p>

<ul>
<li>
<p>If <code>join=NULL</code> (the default),
the new vertices are simply added to the list of network vertices
without being joined to the rest of the network.
</p>
</li>
<li>
<p>If <code>join</code> is a vector of integers, then these are taken to be
indices of existing vertices of <code>L</code> in the order given
in <code>V = vertices(L)</code>. Then each new vertex <code>X[i]</code> will be
joined to an existing vertex <code>V[j]</code> where <code>j = join[i]</code>.
Each new vertex is joined to exactly one existing vertex.
</p>
</li>
<li>
<p>If <code>join="vertices"</code> then each new vertex <code>X[i]</code> is joined
to the nearest existing vertex <code>V[j]</code>.
Each new vertex is joined to exactly one existing vertex.
</p>
</li>
<li>
<p>If <code>join="nearest"</code> then each new vertex is projected to the
nearest location along on the network; these locations are inserted
as new vertices of <code>L</code>; and then each vertex <code>X[i]</code>
is joined to the corresponding projected point.
Each new vertex is joined to exactly one newly-inserted vertex.
</p>
</li>
<li>
<p>If <code>join</code> is a point pattern on a network (class <code>"lpp"</code>),
it must be defined on the same network as <code>L</code> and it must
consist of the same number of points as <code>X</code>. The points of
<code>join</code> will be inserted as new vertices of <code>L</code>,
and then each vertex <code>X[i]</code> is joined to the corresponding
point <code>join[i]</code>.
Each new vertex is joined to exactly one newly-inserted vertex.
</p>
</li></ul>

<p>The result is the modified object, with an attribute <code>"id"</code> such that
the <code>i</code>th added vertex has become the
<code>id[i]</code>th vertex of the new network.
</p>


<h3>Value</h3>

<p>An object of the same class as <code>L</code> representing the result of
adding the new vertices.
The result also has an attribute <code>"id"</code> as described in Details.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley
</p>


<h3>See Also</h3>

<p><code><a href="#topic+insertVertices">insertVertices</a></code> to insert vertices along an existing network.
</p>
<p><code><a href="#topic+as.lpp">as.lpp</a></code>,
<code><a href="#topic+linnet">linnet</a></code>,
<code><a href="#topic+methods.linnet">methods.linnet</a></code>,
<code><a href="#topic+joinVertices">joinVertices</a></code>,
<code><a href="#topic+thinNetwork">thinNetwork</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   opa &lt;- par(mfrow=c(1,3))
   L &lt;- simplenet
   X &lt;- runifpoint(20, Window(simplenet))
   plot(L)
   plot(X, add=TRUE, cols="green", pch=16, cex=2)
   plot(addVertices(L, X, "nearest"), col="red")
   plot(L, add=TRUE, col="grey", lwd=3)
   plot(X, add=TRUE, cols="green", pch=16, cex=2)
   plot(addVertices(L, X, "vertices"), col="red")
   plot(L, add=TRUE, col="grey", lwd=3)
   plot(X, add=TRUE, cols="green", pch=16, cex=2)
   par(opa)
</code></pre>

<hr>
<h2 id='affine.linnet'>Apply Geometrical Transformations to a Linear Network</h2><span id='topic+affine.linnet'></span><span id='topic+shift.linnet'></span><span id='topic+rotate.linnet'></span><span id='topic+rescale.linnet'></span><span id='topic+scalardilate.linnet'></span>

<h3>Description</h3>

<p>Apply geometrical transformations
to a linear network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'linnet'
affine(X, mat=diag(c(1,1)), vec=c(0,0), ...)

  ## S3 method for class 'linnet'
shift(X, vec=c(0,0), ..., origin=NULL)

  ## S3 method for class 'linnet'
rotate(X, angle=pi/2, ..., centre=NULL)

  ## S3 method for class 'linnet'
scalardilate(X, f, ...)

  ## S3 method for class 'linnet'
rescale(X, s, unitname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="affine.linnet_+3A_x">X</code></td>
<td>
<p>Linear network (object of class <code>"linnet"</code>).</p>
</td></tr>
<tr><td><code id="affine.linnet_+3A_mat">mat</code></td>
<td>
<p>Matrix representing a linear transformation.</p>
</td></tr>
<tr><td><code id="affine.linnet_+3A_vec">vec</code></td>
<td>
<p>Vector of length 2 representing a translation.</p>
</td></tr>
<tr><td><code id="affine.linnet_+3A_angle">angle</code></td>
<td>
<p>Rotation angle in radians.</p>
</td></tr>
<tr><td><code id="affine.linnet_+3A_f">f</code></td>
<td>
<p>Scalar dilation factor.</p>
</td></tr>
<tr><td><code id="affine.linnet_+3A_s">s</code></td>
<td>

<p>Unit conversion factor: the new units are <code>s</code> times the old units.
</p>
</td></tr>
<tr><td><code id="affine.linnet_+3A_...">...</code></td>
<td>

<p>Arguments passed to other methods.
</p>
</td></tr>
<tr><td><code id="affine.linnet_+3A_origin">origin</code></td>
<td>

<p>Character string determining a location
that will be shifted to the origin. Options are
<code>"centroid"</code>, <code>"midpoint"</code> and <code>"bottomleft"</code>.
Partially matched. 
</p>
</td></tr>
<tr><td><code id="affine.linnet_+3A_centre">centre</code></td>
<td>

<p>Centre of rotation.
Either a vector of length 2, or a character string
(partially matched to <code>"centroid"</code>, <code>"midpoint"</code>
or <code>"bottomleft"</code>).
The default is the coordinate origin <code>c(0,0)</code>.
</p>
</td></tr>
<tr><td><code id="affine.linnet_+3A_unitname">unitname</code></td>
<td>

<p>Optional. New name for the unit of length.
A value acceptable to the function <code><a href="spatstat.geom.html#topic+unitname+3C-">unitname&lt;-</a></code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are methods for the generic functions
<code><a href="spatstat.geom.html#topic+affine">affine</a></code>,
<code><a href="spatstat.geom.html#topic+shift">shift</a></code>,
<code><a href="spatstat.geom.html#topic+rotate">rotate</a></code>,
<code><a href="spatstat.geom.html#topic+rescale">rescale</a></code> and
<code><a href="spatstat.geom.html#topic+scalardilate">scalardilate</a></code>
applicable to objects of class <code>"linnet"</code>.
</p>
<p>All of these functions
perform geometrical transformations on the object <code>X</code>,
except for <code>rescale</code>, which simply rescales the units of length.
</p>


<h3>Value</h3>

<p>Another linear network (of class <code>"linnet"</code>) representing the
result of applying the geometrical transformation.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linnet">linnet</a></code> and <code><a href="#topic+as.linnet">as.linnet</a></code>.
</p>
<p>Generic functions
<code><a href="spatstat.geom.html#topic+affine">affine</a></code>,
<code><a href="spatstat.geom.html#topic+shift">shift</a></code>,
<code><a href="spatstat.geom.html#topic+rotate">rotate</a></code>,
<code><a href="spatstat.geom.html#topic+scalardilate">scalardilate</a></code>,
<code><a href="spatstat.geom.html#topic+rescale">rescale</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  U &lt;- rotate(simplenet, pi)
  stretch &lt;- diag(c(2,3))
  Y &lt;- affine(simplenet, mat=stretch)
  shear &lt;- matrix(c(1,0,0.6,1),ncol=2, nrow=2)
  Z &lt;- affine(simplenet, mat=shear, vec=c(0, 1))
</code></pre>

<hr>
<h2 id='affine.lpp'>Apply Geometrical Transformations to Point Pattern on a Linear Network</h2><span id='topic+affine.lpp'></span><span id='topic+shift.lpp'></span><span id='topic+rotate.lpp'></span><span id='topic+rescale.lpp'></span><span id='topic+scalardilate.lpp'></span>

<h3>Description</h3>

<p>Apply geometrical transformations to a point pattern on a linear network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'lpp'
affine(X, mat=diag(c(1,1)), vec=c(0,0), ...)

  ## S3 method for class 'lpp'
shift(X, vec=c(0,0), ..., origin=NULL)

  ## S3 method for class 'lpp'
rotate(X, angle=pi/2, ..., centre=NULL)

  ## S3 method for class 'lpp'
scalardilate(X, f, ...)

  ## S3 method for class 'lpp'
rescale(X, s, unitname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="affine.lpp_+3A_x">X</code></td>
<td>
<p>Point pattern on a linear network (object of class <code>"lpp"</code>).</p>
</td></tr>
<tr><td><code id="affine.lpp_+3A_mat">mat</code></td>
<td>
<p>Matrix representing a linear transformation.</p>
</td></tr>
<tr><td><code id="affine.lpp_+3A_vec">vec</code></td>
<td>
<p>Vector of length 2 representing a translation.</p>
</td></tr>
<tr><td><code id="affine.lpp_+3A_angle">angle</code></td>
<td>
<p>Rotation angle in radians.</p>
</td></tr>
<tr><td><code id="affine.lpp_+3A_f">f</code></td>
<td>
<p>Scalar dilation factor.</p>
</td></tr>
<tr><td><code id="affine.lpp_+3A_s">s</code></td>
<td>

<p>Unit conversion factor: the new units are <code>s</code> times the old units.
</p>
</td></tr>
<tr><td><code id="affine.lpp_+3A_...">...</code></td>
<td>

<p>Arguments passed to other methods.
</p>
</td></tr>
<tr><td><code id="affine.lpp_+3A_origin">origin</code></td>
<td>

<p>Character string determining a location
that will be shifted to the origin. Options are
<code>"centroid"</code>, <code>"midpoint"</code> and <code>"bottomleft"</code>.
Partially matched. 
</p>
</td></tr>
<tr><td><code id="affine.lpp_+3A_centre">centre</code></td>
<td>

<p>Centre of rotation.
Either a vector of length 2, or a character string
(partially matched to <code>"centroid"</code>, <code>"midpoint"</code>
or <code>"bottomleft"</code>).
The default is the coordinate origin <code>c(0,0)</code>.
</p>
</td></tr>
<tr><td><code id="affine.lpp_+3A_unitname">unitname</code></td>
<td>

<p>Optional. New name for the unit of length.
A value acceptable to the function <code><a href="spatstat.geom.html#topic+unitname+3C-">unitname&lt;-</a></code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are methods for the generic functions
<code><a href="spatstat.geom.html#topic+affine">affine</a></code>,
<code><a href="spatstat.geom.html#topic+shift">shift</a></code>,
<code><a href="spatstat.geom.html#topic+rotate">rotate</a></code>,
<code><a href="spatstat.geom.html#topic+rescale">rescale</a></code> and
<code><a href="spatstat.geom.html#topic+scalardilate">scalardilate</a></code>
applicable to objects of class <code>"lpp"</code>.
</p>
<p>All of these functions
perform geometrical transformations on the object <code>X</code>,
except for <code>rescale</code>, which simply rescales the units of length.
</p>


<h3>Value</h3>

<p>Another point pattern on a linear network (object of class
<code>"lpp"</code>) 
representing the
result of applying the geometrical transformation.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lpp">lpp</a></code>.
</p>
<p>Generic functions
<code><a href="spatstat.geom.html#topic+affine">affine</a></code>,
<code><a href="spatstat.geom.html#topic+shift">shift</a></code>,
<code><a href="spatstat.geom.html#topic+rotate">rotate</a></code>,
<code><a href="spatstat.geom.html#topic+scalardilate">scalardilate</a></code>,
<code><a href="spatstat.geom.html#topic+rescale">rescale</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- rpoislpp(2, simplenet)
  U &lt;- rotate(X, pi)
  V &lt;- shift(X, c(0.1, 0.2))
  stretch &lt;- diag(c(2,3))
  Y &lt;- affine(X, mat=stretch)
  shear &lt;- matrix(c(1,0,0.6,1),ncol=2, nrow=2)
  Z &lt;- affine(X, mat=shear, vec=c(0, 1))
</code></pre>

<hr>
<h2 id='anova.lppm'>ANOVA for Fitted Point Process Models on Linear Network</h2><span id='topic+anova.lppm'></span>

<h3>Description</h3>

<p>Performs analysis of deviance for two or more fitted point process
models on a linear network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'lppm'
anova(object, ..., test=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anova.lppm_+3A_object">object</code></td>
<td>
<p>A fitted point process model on a linear network
(object of class <code>"lppm"</code>).
</p>
</td></tr>
<tr><td><code id="anova.lppm_+3A_...">...</code></td>
<td>

<p>One or more fitted point process models on the same
linear network.
</p>
</td></tr>
<tr><td><code id="anova.lppm_+3A_test">test</code></td>
<td>

<p>Character string, partially matching one of
<code>"Chisq"</code>, <code>"F"</code> or <code>"Cp"</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for <code><a href="stats.html#topic+anova">anova</a></code> for 
fitted point process models on a linear network
(objects of class <code>"lppm"</code>,
usually generated by the model-fitting function <code><a href="#topic+lppm">lppm</a></code>).
</p>
<p>If the fitted models are all Poisson point processes,
then this function performs an Analysis of Deviance of
the fitted models. The output shows the deviance differences
(i.e. 2 times log likelihood ratio),
the difference in degrees of freedom, and (if <code>test="Chi"</code>)
the two-sided p-values for the chi-squared tests. Their interpretation
is very similar to that in <code><a href="stats.html#topic+anova.glm">anova.glm</a></code>.
</p>
<p>If some of the fitted models are <em>not</em> Poisson point processes,
then the deviance difference is replaced by the
adjusted composite likelihood ratio (Pace et al, 2011;
Baddeley et al, 2014). 
</p>


<h3>Value</h3>

<p>An object of class <code>"anova"</code>, or <code>NULL</code>.
</p>


<h3>Errors and warnings</h3>


<dl>
<dt>models not nested:</dt><dd>
<p>There may be an error message that the models are not &ldquo;nested&rdquo;.
For an Analysis of Deviance the models must be nested, i.e. one model
must be a special case of the other. For example the point process
model with formula <code>~x</code> is a special case of the model with
formula <code>~x+y</code>, so these models are nested. However
the two point process
models with formulae <code>~x</code> and <code>~y</code> are not nested.
</p>
<p>If you get this error message and you believe that the models should
be nested, the problem may be the inability of <span class="rlang"><b>R</b></span> to recognise that
the two formulae are nested. Try modifying the formulae to make
their relationship more obvious.
</p>
</dd>
<dt>different sizes of dataset:</dt><dd>
<p>There may be an error message from <code>anova.glmlist</code> that
&ldquo;models were not all fitted to the same size of dataset&rdquo;.
This generally occurs when the point process models
are fitted on different linear networks.
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>References</h3>

<p>Ang, Q.W. (2010)
<em>Statistical methodology for events on a network</em>.
Master's thesis, School of Mathematics and Statistics, University of
Western Australia.
</p>
<p>Ang, Q.W., Baddeley, A. and Nair, G. (2012)
Geometrically corrected second-order analysis of 
events on a linear network, with applications to
ecology and criminology.
<em>Scandinavian Journal of Statistics</em> <b>39</b>, 591&ndash;617.
</p>
<p>Baddeley, A., Turner, R. and Rubak, E. (2015)
Adjusted composite likelihood ratio test for Gibbs point processes.
<em>Journal of Statistical Computation and Simulation</em>
<b>86</b> (5) 922&ndash;941.
DOI: 10.1080/00949655.2015.1044530.
</p>
<p>McSwiggan, G., Nair, M.G. and Baddeley, A. (2012)
Fitting Poisson point process models to events 
on a linear network. Manuscript in preparation.
</p>
<p>Pace, L., Salvan, A. and Sartori, N. (2011)
Adjusting composite likelihood ratio statistics.
<em>Statistica Sinica</em> <b>21</b>, 129&ndash;148.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lppm">lppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> X &lt;- runiflpp(10, simplenet)
 mod0 &lt;- lppm(X ~1)
 modx &lt;- lppm(X ~x)
 anova(mod0, modx, test="Chi")
</code></pre>

<hr>
<h2 id='as.data.frame.lintess'>Convert Network Tessellation to Data Frame</h2><span id='topic+as.data.frame.lintess'></span>

<h3>Description</h3>

<p>Converts a tessellation on a linear network into a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lintess'
as.data.frame(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.lintess_+3A_x">x</code></td>
<td>

<p>Tessellation on a linear network (object of class <code>"lintess"</code>).
</p>
</td></tr>
<tr><td><code id="as.data.frame.lintess_+3A_...">...</code></td>
<td>
<p>Further arguments passed to
<code><a href="base.html#topic+as.data.frame">as.data.frame.default</a></code>
to determine the row names and other features.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tessellation on a linear network is a partition of the
network into non-overlapping pieces (tiles). Each tile consists of one
or more line segments which are subsets of the line segments making up
the network. A tile can consist of several disjoint pieces.
</p>
<p>This function converts the tessellation <code>x</code> to a data frame.
Each row of the data frame specifies one sub-segment of the network,
and allocates it to a particular tile. The data frame has the
following columns:
</p>

<ul>
<li><p> The <code>seg</code> column specifies which line segment of the network
contains the sub-segment. Values of <code>seg</code> are integer indices
for the network segments in <code>as.psp(as.linnet(x))</code>.
</p>
</li>
<li><p> The <code>t0</code> and <code>t1</code> columns specify the start and end points
of the sub-segment. They are numeric values between 0 and 1
inclusive, where the values 0 and 1 representing the network vertices
that are joined by this network segment.
</p>
</li>
<li><p> The <code>tile</code> column specifies which tile of the tessellation
includes this sub-segment. It is a factor whose 
levels are the names of the tiles.
</p>
</li></ul>

<p>The tessellation may have marks, which are attached to the <em>tiles</em>
of the tessellation. If marks are present, the resulting data frame
includes columns containing, for each sub-segment,
the mark value of the corresponding tile.
</p>


<h3>Value</h3>

<p>A data frame with columns named <code>seg</code>, <code>t0</code>, <code>t1</code>,
<code>tile</code>, and possibly other columns.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lintess">lintess</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- lineardirichlet(runiflpp(3, simplenet))
  marks(X) &lt;- letters[1:3]
  as.data.frame(X)
</code></pre>

<hr>
<h2 id='as.linfun'>
Convert Data to a Function on a Linear Network
</h2><span id='topic+as.linfun'></span><span id='topic+as.linfun.linim'></span><span id='topic+as.linfun.lintess'></span>

<h3>Description</h3>

<p>Convert some kind of data to an object of class <code>"linfun"</code>
representing a function on a linear network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  as.linfun(X, ...)

  ## S3 method for class 'linim'
as.linfun(X, ...)

  ## S3 method for class 'lintess'
as.linfun(X, ..., values=marks(X), navalue=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.linfun_+3A_x">X</code></td>
<td>

<p>Some kind of data to be converted.
</p>
</td></tr>
<tr><td><code id="as.linfun_+3A_...">...</code></td>
<td>

<p>Other arguments passed to methods.
</p>
</td></tr>
<tr><td><code id="as.linfun_+3A_values">values</code></td>
<td>

<p>Optional. Vector of function values,
one entry associated with each tile of the tessellation.
</p>
</td></tr>
<tr><td><code id="as.linfun_+3A_navalue">navalue</code></td>
<td>

<p>Optional. Function value associated with locations that
do not belong to a tile of the tessellation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object of class <code>"linfun"</code> represents
a function defined on a linear network.
</p>
<p>The function <code>as.linfun</code> is generic. The method <code>as.linfun.linim</code>
converts objects of class <code>"linim"</code> (pixel images on a linear
network) to functions on the network.
</p>
<p>The method <code>as.linfun.lintess</code> converts a tessellation
on a linear network into a function with a different value
on each tile of the tessellation.
The function values are specified by the argument <code>values</code>.
It should be a vector with one entry for each tile of the tessellation;
any point lying in tile number <code>i</code> will return the value <code>v[i]</code>.
If <code>values</code> is missing, the marks of the tessellation
are taken as the function values. 
If <code>values</code> is missing and the tessellation has no marks,
or if <code>values</code> is given as <code>NULL</code>,
then the function returns factor values identifying which tile
contains each given point.
</p>


<h3>Value</h3>

<p>Object of class <code>"linfun"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linfun">linfun</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   X &lt;- runiflpp(2, simplenet)
   Y &lt;- runiflpp(5, simplenet)

   # image on network
   D &lt;- density(Y, 0.1)

   f &lt;- as.linfun(D)
   f
   f(X)

   # tessellation on network
   Z &lt;- lineardirichlet(Y)
   g &lt;- as.linfun(Z)
   g(X)
   h &lt;- as.linfun(Z, values = runif(5))
   h(X)
</code></pre>

<hr>
<h2 id='as.linim'>Convert to Pixel Image on Linear Network</h2><span id='topic+as.linim'></span><span id='topic+as.linim.linim'></span><span id='topic+as.linim.linfun'></span><span id='topic+as.linim.default'></span>

<h3>Description</h3>

<p>Converts various kinds of data to a pixel image on a linear network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  as.linim(X, ...)

  ## S3 method for class 'linim'
as.linim(X, ...)

  ## Default S3 method:
as.linim(X, L, ...,
                             eps = NULL, dimyx = NULL, xy = NULL,
                             rule.eps=c("adjust.eps",
                                        "grow.frame", "shrink.frame"),
                             delta=NULL, nd=NULL)

  ## S3 method for class 'linfun'
as.linim(X, L=domain(X), ...,
                            eps = NULL, dimyx = NULL, xy = NULL,
                            rule.eps=c("adjust.eps",
                                        "grow.frame", "shrink.frame"),
                            delta=NULL, nd=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.linim_+3A_x">X</code></td>
<td>

<p>Data to be converted to a pixel image on a linear network.
</p>
</td></tr>
<tr><td><code id="as.linim_+3A_l">L</code></td>
<td>

<p>Linear network (object of class <code>"linnet"</code>).
</p>
</td></tr>
<tr><td><code id="as.linim_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>X</code> when <code>X</code>
is a function.
</p>
</td></tr>
<tr><td><code id="as.linim_+3A_eps">eps</code>, <code id="as.linim_+3A_dimyx">dimyx</code>, <code id="as.linim_+3A_xy">xy</code>, <code id="as.linim_+3A_rule.eps">rule.eps</code></td>
<td>

<p>Optional arguments passed to <code><a href="grid.html#topic+as.mask">as.mask</a></code> to control
the pixel resolution.
</p>
</td></tr>
<tr><td><code id="as.linim_+3A_delta">delta</code></td>
<td>

<p>Optional. Numeric value giving the approximate distance
(in coordinate units) between successive
sample points along each segment of the network.
</p>
</td></tr>
<tr><td><code id="as.linim_+3A_nd">nd</code></td>
<td>

<p>Optional. Integer giving the (approximate) number of 
sample points on the network. Ignored if <code>delta</code> is given.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts the data <code>X</code> into a pixel image
on a linear network, an object of class <code>"linim"</code>
(see <code><a href="#topic+linim">linim</a></code>). 
</p>
<p>The argument <code>X</code> may be any of the following:
</p>

<ul>
<li>
<p>a function on a linear network, an object of class <code>"linfun"</code>.
</p>
</li>
<li>
<p>a pixel image on a linear network, an object of class
<code>"linim"</code>.
</p>
</li>
<li>
<p>a pixel image, an object of class <code>"im"</code>.
</p>
</li>
<li>
<p>any type of data acceptable to <code><a href="spatstat.geom.html#topic+as.im">as.im</a></code>,
such as a function, numeric value, or window.
</p>
</li></ul>

<p>First <code>X</code> is converted to a pixel image object <code>Y</code>
(object of class <code>"im"</code>).
The conversion is performed by <code><a href="spatstat.geom.html#topic+as.im">as.im</a></code>.
The arguments <code>eps</code>, <code>dimyx</code>, <code>xy</code> and <code>rule.eps</code>
determine the pixel resolution.
</p>
<p>Next <code>Y</code> is converted to a pixel image on a linear network
using <code><a href="#topic+linim">linim</a></code>. The argument <code>L</code> determines the
linear network. If <code>L</code> is missing or <code>NULL</code>,
then <code>X</code> should be an object of class <code>"linim"</code>,
and <code>L</code> defaults to the linear network on which <code>X</code> is defined.
</p>
<p>In addition to converting the
function to a pixel image, the algorithm also generates a fine grid of
sample points evenly spaced along each segment of the network
(with spacing at most <code>delta</code> coordinate units). The function values
at these sample points are stored in the resulting object as a data frame
(the argument <code>df</code> of <code><a href="#topic+linim">linim</a></code>). This mechanism allows
greater accuracy for some calculations (such as
<code><a href="#topic+integral.linim">integral.linim</a></code>).
</p>


<h3>Value</h3>

<p>An image object on a linear network; an object of class <code>"linim"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.geom.html#topic+as.im">as.im</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  f &lt;- function(x,y){ x + y }
  plot(as.linim(f, simplenet))
</code></pre>

<hr>
<h2 id='as.linnet.linim'>
Extract Linear Network from Data on a Linear Network
</h2><span id='topic+as.linnet.lpp'></span><span id='topic+as.linnet.linim'></span><span id='topic+as.linnet.linfun'></span><span id='topic+as.linnet.lintess'></span>

<h3>Description</h3>

<p>Given some kind of data on a linear network,
the command <code>as.linnet</code> extracts the linear network itself.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'linim'
as.linnet(X, ...)

 ## S3 method for class 'linfun'
as.linnet(X, ...)

 ## S3 method for class 'lintess'
as.linnet(X, ...)

 ## S3 method for class 'lpp'
as.linnet(X, ..., fatal=TRUE, sparse)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.linnet.linim_+3A_x">X</code></td>
<td>

<p>Data on a linear network.
A point pattern (class <code>"lpp"</code>),
pixel image (class <code>"linim"</code>), function (class
<code>"linfun"</code>) or tessellation (class <code>"lintess"</code>)
on a linear network.
</p>
</td></tr>
<tr><td><code id="as.linnet.linim_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="as.linnet.linim_+3A_fatal">fatal</code></td>
<td>

<p>Logical value indicating whether data in the wrong format
should lead to an error (<code>fatal=TRUE</code>) or a warning
(<code>fatal=FALSE</code>).
</p>
</td></tr>
<tr><td><code id="as.linnet.linim_+3A_sparse">sparse</code></td>
<td>

<p>Logical value indicating whether to use a sparse matrix
representation, as explained in <code><a href="#topic+linnet">linnet</a></code>.
Default is to keep the same representation as in <code>X</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are methods for the generic <code><a href="#topic+as.linnet">as.linnet</a></code>
for various classes.
</p>
<p>The network on which the data are defined is extracted.
</p>


<h3>Value</h3>

<p>A linear network (object of class <code>"linnet"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linnet">linnet</a></code>, 
<code><a href="#topic+methods.linnet">methods.linnet</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # make some data
  xcoord &lt;- linfun(function(x,y,seg,tp) { x }, simplenet)
  as.linnet(xcoord)
  X &lt;- as.linim(xcoord)
  as.linnet(X)
</code></pre>

<hr>
<h2 id='as.linnet.psp'>
Convert Line Segment Pattern to Linear Network
</h2><span id='topic+as.linnet.psp'></span>

<h3>Description</h3>

<p>Converts a line segment pattern to a linear network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'psp'
as.linnet(X, ..., eps, sparse=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.linnet.psp_+3A_x">X</code></td>
<td>

<p>Line segment pattern (object of class <code>"psp"</code>).
</p>
</td></tr>
<tr><td><code id="as.linnet.psp_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="as.linnet.psp_+3A_eps">eps</code></td>
<td>

<p>Optional. Distance threshold. If two segment endpoints
are closer than <code>eps</code> units apart, they will be treated
as the same point, and will become a single vertex in the
linear network.
</p>
</td></tr>
<tr><td><code id="as.linnet.psp_+3A_sparse">sparse</code></td>
<td>

<p>Logical value indicating whether to use a sparse matrix
representation, as explained in <code><a href="#topic+linnet">linnet</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command converts any collection of line segments into a linear
network by guessing the connectivity of the network,
using the distance threshold <code>eps</code>.
</p>
<p>If any segments in <code>X</code> cross over each other, they are first
cut into pieces using <code><a href="spatstat.geom.html#topic+selfcut.psp">selfcut.psp</a></code>.
</p>
<p>Then any pair of segment endpoints lying closer than <code>eps</code>
units apart, is treated as a single vertex. The linear network
is then constructed using <code><a href="#topic+linnet">linnet</a></code>.
</p>
<p>It would be wise to check the result by plotting the degree
of each vertex, as shown in the Examples.
</p>
<p>If <code>X</code> has marks, then these are stored in
the resulting linear network <code>Y &lt;- as.linnet(X)</code>,
and can be extracted as <code>marks(as.psp(Y))</code> or <code>marks(Y$lines)</code>.
</p>


<h3>Value</h3>

<p>A linear network (object of class <code>"linnet"</code>).
</p>
<p>The result also has an attribute <code>"camefrom"</code> indicating
the provenance of each line in the resulting network.
For example <code>camefrom[3]=2</code> means that the third line segment
in the result is a piece of the second segment of <code>X</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linnet">linnet</a></code>, <code><a href="spatstat.geom.html#topic+selfcut.psp">selfcut.psp</a></code>,
<code><a href="#topic+methods.linnet">methods.linnet</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # make some data
  A &lt;- psp(0.09, 0.55, 0.79, 0.80, window=owin())
  B &lt;- superimpose(A, as.psp(simplenet))

  # convert to a linear network
  L &lt;- as.linnet(B)

  # check validity
  L
  plot(L)
  text(vertices(L), labels=vertexdegree(L))

  # show the pieces that came from original segment number 1
  S &lt;- as.psp(L)
  (camefrom &lt;- attr(L, "camefrom"))
  parts &lt;- which(camefrom == 1)
  plot(S[parts], add=TRUE, col="green", lwd=2)
</code></pre>

<hr>
<h2 id='as.lpp'>
Convert Data to a Point Pattern on a Linear Network
</h2><span id='topic+as.lpp'></span>

<h3>Description</h3>

<p>Convert various kinds of data to a point pattern on a linear network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  as.lpp(x=NULL, y=NULL, seg=NULL, tp=NULL, ...,
         marks=NULL, L=NULL, check=FALSE, sparse)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.lpp_+3A_x">x</code>, <code id="as.lpp_+3A_y">y</code></td>
<td>

<p>Vectors of cartesian coordinates, or any data
acceptable to <code><a href="grDevices.html#topic+xy.coords">xy.coords</a></code>.
Alternatively <code>x</code> can be a point pattern
on a linear network (object of class <code>"lpp"</code>)
or a planar point pattern (object of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="as.lpp_+3A_seg">seg</code>, <code id="as.lpp_+3A_tp">tp</code></td>
<td>

<p>Optional local coordinates. Vectors of the same length
as <code>x,y</code>. See Details.
</p>
</td></tr>
<tr><td><code id="as.lpp_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="as.lpp_+3A_marks">marks</code></td>
<td>

<p>Optional marks for the point pattern.
A vector or factor with one entry for each point,
or a data frame or hyperframe with one row for each point.
</p>
</td></tr>
<tr><td><code id="as.lpp_+3A_l">L</code></td>
<td>

<p>Linear network (object of class <code>"linnet"</code>)
on which the points lie.
</p>
</td></tr>
<tr><td><code id="as.lpp_+3A_check">check</code></td>
<td>

<p>Logical. Whether to check the validity of the spatial coordinates.
</p>
</td></tr>
<tr><td><code id="as.lpp_+3A_sparse">sparse</code></td>
<td>

<p>Optional logical value indicating whether to store the
linear network data in a sparse matrix representation or not.
See <code><a href="#topic+linnet">linnet</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts data in various formats into a point pattern
on a linear network  (object of class <code>"lpp"</code>).
</p>
<p>The possible formats are:
</p>

<ul>
<li>
<p><code>x</code> is already a point pattern on a linear network
(object of class <code>"lpp"</code>).
Then <code>x</code> is returned unchanged.
</p>
</li>
<li>
<p><code>x</code> is a planar point pattern (object of class <code>"ppp"</code>).
Then <code>x</code> is converted to a point pattern on the linear network
<code>L</code> using <code><a href="#topic+lpp">lpp</a></code>.
</p>
</li>
<li>
<p><code>x,y,seg,tp</code> are vectors of equal length.
These specify that the <code>i</code>th point has Cartesian coordinates
<code>(x[i],y[i])</code>, and lies on segment number <code>seg[i]</code> of the
network <code>L</code>, at a fractional position <code>tp[i]</code> along that
segment (with <code>tp=0</code> representing one endpoint and
<code>tp=1</code> the other endpoint of the segment).
</p>
</li>
<li>
<p><code>x,y</code> are missing and <code>seg,tp</code> are vectors of equal length
as described above.
</p>
</li>
<li>
<p><code>seg,tp</code> are <code>NULL</code>, and <code>x,y</code> are data in a format
acceptable to <code><a href="grDevices.html#topic+xy.coords">xy.coords</a></code> specifying the
Cartesian coordinates.
</p>
</li>
<li>
<p>Only the arguments <code>x</code> and <code>L</code> are given,
and <code>x</code> is a data frame with one of the following types:
</p>

<ul>
<li><p> two columns labelled <code>seg,tp</code> interpreted as local
coordinates on the network.
</p>
</li>
<li><p> two columns labelled <code>x,y</code> interpreted as Cartesian
coordinates.
</p>
</li>
<li><p> four columns labelled <code>x,y,seg,tp</code>
interpreted as Cartesian coordinates and local coordinates.
</p>
</li></ul>

</li></ul>



<h3>Value</h3>

<p>A point pattern
on a linear network (object of class <code>"lpp"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lpp">lpp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   A &lt;- as.psp(simplenet)
   X &lt;- runifpointOnLines(10, A)
   is.ppp(X)
   Y &lt;- as.lpp(X, L=simplenet)
</code></pre>

<hr>
<h2 id='as.owin.lpp'>Convert Data on a Network to class owin</h2><span id='topic+as.owin.lpp'></span><span id='topic+as.owin.lppm'></span>

<h3>Description</h3>

<p>Converts data on a linear network
into an object of class <code>"owin"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'lpp'
as.owin(W, ..., fatal=TRUE)

 ## S3 method for class 'lppm'
as.owin(W, ..., fatal=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.owin.lpp_+3A_w">W</code></td>
<td>

<p>Data specifying an observation window, in any of several formats
described under <em>Details</em> below.
</p>
</td></tr>
<tr><td><code id="as.owin.lpp_+3A_fatal">fatal</code></td>
<td>

<p>Logical value determining what to do
if the data cannot be converted to an observation window.
See Details.
</p>
</td></tr>
<tr><td><code id="as.owin.lpp_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The class <code>"owin"</code> is a way of specifying the observation window
for a point pattern. See <code><a href="spatstat.geom.html#topic+owin.object">owin.object</a></code>
for an overview.
</p>
<p>The function <code><a href="spatstat.geom.html#topic+as.owin">as.owin</a></code>
converts data in any of several formats 
into an object of class <code>"owin"</code> for use by the <span class="pkg">spatstat</span>
package. The function <code><a href="spatstat.geom.html#topic+as.owin">as.owin</a></code>
is generic, with methods
for different classes of objects, and a default method.
</p>
<p>A long list of methods for
<code><a href="spatstat.geom.html#topic+as.owin">as.owin</a></code>
is documented in the help file for <code><a href="spatstat.geom.html#topic+as.owin">as.owin</a></code>
in the <span class="pkg">spatstat.geom</span> package.
</p>
<p>This help file documents additional methods applicable when <code>W</code> is
</p>

<ul>
<li>
<p>an object of class <code>"lpp"</code>
representing a point pattern on a linear network.
In this case, <code>as.owin</code> extracts the linear network
and returns a window containing this network. 
</p>
</li>
<li>
<p>an object of class <code>"lppm"</code>
representing a fitted point process model on a linear network.
In this case, <code>as.owin</code> extracts the linear network
and returns a window containing this network. 
</p>
</li></ul>

<p>If the argument <code>W</code> 
cannot be converted to a window, then an error will
be generated (if <code>fatal=TRUE</code>) or a value of <code>NULL</code>
will be returned (if <code>fatal=FALSE</code>).
</p>


<h3>Value</h3>

<p>An object of class <code>"owin"</code>
(see <code><a href="spatstat.geom.html#topic+owin.object">owin.object</a></code>)
specifying an observation window.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.geom.html#topic+as.owin">as.owin</a></code>,
<code><a href="spatstat.geom.html#topic+owin.object">owin.object</a></code>,
<code><a href="spatstat.geom.html#topic+owin">owin</a></code>.
</p>
<p>Additional methods for <code>as.owin</code> may be provided
by other packages outside the <span class="pkg">spatstat</span> family.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  as.owin(simplenet)
</code></pre>

<hr>
<h2 id='auc.lpp'>
Area Under ROC Curve for Data on a Network
</h2><span id='topic+auc.lpp'></span><span id='topic+auc.lppm'></span>

<h3>Description</h3>

<p>Compute the AUC (area under the Receiver Operating Characteristic
curve) for a fitted point process model on a linear network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpp'
auc(X, covariate, ..., high = TRUE)

## S3 method for class 'lppm'
auc(X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="auc.lpp_+3A_x">X</code></td>
<td>

<p>Point pattern (object of class <code>"ppp"</code> or <code>"lpp"</code>)
or fitted point process model (object of class <code>"ppm"</code>
or <code>"kppm"</code> or <code>"lppm"</code>).
</p>
</td></tr>
<tr><td><code id="auc.lpp_+3A_covariate">covariate</code></td>
<td>

<p>Spatial covariate. Either a <code>function(x,y)</code>,
a pixel image (object of class <code>"im"</code> or <code>"linim"</code>), or
one of the strings <code>"x"</code> or <code>"y"</code> indicating the
Cartesian coordinates.    
</p>
</td></tr>
<tr><td><code id="auc.lpp_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="grid.html#topic+as.mask">as.mask</a></code> controlling the
pixel resolution for calculations.
</p>
</td></tr>
<tr><td><code id="auc.lpp_+3A_high">high</code></td>
<td>

<p>Logical value indicating whether the threshold operation
should favour high or low values of the covariate.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command computes the AUC, the area under the Receiver Operating
Characteristic curve. The ROC itself is computed by <code><a href="spatstat.explore.html#topic+roc">roc</a></code>.
</p>
<p>The function <code><a href="spatstat.explore.html#topic+auc">auc</a></code> is generic,
with methods for <code>"ppp"</code> and <code>"ppm"</code> described in the help file
for <code><a href="spatstat.explore.html#topic+auc">auc</a></code>.
</p>
<p>This help file describes the methods for classes <code>"lpp"</code> and
<code>"lppm"</code>.
</p>
<p>For a point pattern <code>X</code> and a covariate <code>Z</code>, the
AUC is a numerical index that measures the ability of the 
covariate to separate the spatial domain
into areas of high and low density of points.
Let <code class="reqn">x_i</code> be a randomly-chosen data point from <code>X</code>
and <code class="reqn">U</code> a randomly-selected location in the study region.
The AUC is the probability that
<code class="reqn">Z(x_i) &gt; Z(U)</code>
assuming <code>high=TRUE</code>.
That is, AUC is the probability that a randomly-selected data point
has a higher value of the covariate <code>Z</code> than does a
randomly-selected spatial location. The AUC is a number between 0 and 1. 
A value of 0.5 indicates a complete lack of discriminatory power.
</p>
<p>For a fitted point process model <code>X</code>,
the AUC measures the ability of the
fitted model intensity to separate the spatial domain
into areas of high and low density of points.
Suppose <code class="reqn">\lambda(u)</code> is the intensity function of the model.
The AUC is the probability that
<code class="reqn">\lambda(x_i) &gt; \lambda(U)</code>.
That is, AUC is the probability that a randomly-selected data point
has higher predicted intensity than does a randomly-selected spatial
location.
The AUC is <b>not</b> a measure of the goodness-of-fit of the model
(Lobo et al, 2007).
</p>


<h3>Value</h3>

<p>Numeric.
For <code>auc.lpp</code>, the result is a single number
giving the AUC value.
For <code>auc.lppm</code>, the result is a 
numeric vector of length 2 giving the AUC value 
and the theoretically expected AUC value for this model.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Lobo, J.M.,
Jimenez-Valverde, A.
and Real, R. (2007)
AUC: a misleading measure of the performance of predictive
distribution models.
<em>Global Ecology and Biogeography</em> <b>17</b>(2) 145&ndash;151.
</p>
<p>Nam, B.-H. and D'Agostino, R. (2002)
Discrimination index, the area under the ROC curve.
Pages 267&ndash;279 in 
Huber-Carol, C., Balakrishnan, N., Nikulin, M.S. 
and Mesbah, M., <em>Goodness-of-fit tests and model validity</em>,
Birkhauser, Basel.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.explore.html#topic+auc">auc</a></code>,
<code><a href="spatstat.explore.html#topic+roc">roc</a></code>,
<code><a href="#topic+roc.lpp">roc.lpp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  auc(spiders, "x")
  fit &lt;- lppm(spiders ~ x + y)
  auc(fit)
</code></pre>

<hr>
<h2 id='begins'>
Check Start of Character String 
</h2><span id='topic+begins'></span>

<h3>Description</h3>

<p>Checks whether a character string begins with a particular prefix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>begins(x, firstbit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="begins_+3A_x">x</code></td>
<td>

<p>Character string, or vector of character strings, to be tested.
</p>
</td></tr>
<tr><td><code id="begins_+3A_firstbit">firstbit</code></td>
<td>

<p>A single character string.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This simple wrapper function checks whether (each entry in) <code>x</code>
begins with the string <code>firstbit</code>, and returns a logical value
or logical vector with one entry for each entry of <code>x</code>.
This function is useful mainly for reducing complexity in model formulae.
</p>


<h3>Value</h3>

<p>Logical vector of the same length as <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  begins(c("Hello", "Goodbye"), "Hell")
  begins("anything", "")
</code></pre>

<hr>
<h2 id='berman.test.lpp'>Berman's Tests for Point Process Model on a Network</h2><span id='topic+berman.test.lppm'></span><span id='topic+berman.test.lpp'></span>

<h3>Description</h3>

<p>Tests the goodness-of-fit of a Poisson point process model
on a linear network, using the approach of Berman (1986).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpp'
berman.test(X, covariate,
                         which = c("Z1", "Z2"),
        alternative = c("two.sided", "less", "greater"), ...)

## S3 method for class 'lppm'
berman.test(model, covariate,
                         which = c("Z1", "Z2"),
               alternative = c("two.sided", "less", "greater"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="berman.test.lpp_+3A_x">X</code></td>
<td>

<p>A point pattern (object of class <code>"lpp"</code>).
</p>
</td></tr>
<tr><td><code id="berman.test.lpp_+3A_model">model</code></td>
<td>

<p>A fitted point process model (object of class <code>"lppm"</code>).
</p>
</td></tr>
<tr><td><code id="berman.test.lpp_+3A_covariate">covariate</code></td>
<td>

<p>The spatial covariate on which the test will be based.
An image (object of class <code>"im"</code> or <code>"linim"</code>)
or a function.
</p>
</td></tr>
<tr><td><code id="berman.test.lpp_+3A_which">which</code></td>
<td>

<p>Character string specifying the choice of test.
</p>
</td></tr>
<tr><td><code id="berman.test.lpp_+3A_alternative">alternative</code></td>
<td>

<p>Character string specifying the alternative hypothesis.
</p>
</td></tr>
<tr><td><code id="berman.test.lpp_+3A_...">...</code></td>
<td>

<p>Additional arguments controlling the pixel resolution
(arguments <code>dimyx</code> and <code>eps</code> passed to
<code><a href="grid.html#topic+as.mask">as.mask</a></code>)
or other undocumented features.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions perform a goodness-of-fit test of a Poisson point
process model fitted to point pattern data. The observed distribution
of the values of a spatial covariate at the data points,
and the predicted distribution of the same values under the model,
are compared using either of two test statistics
<code class="reqn">Z_1</code> and <code class="reqn">Z_2</code> proposed by Berman (1986).
The <code class="reqn">Z_1</code> test is also known as the
Lawson-Waller test.
</p>
<p>The function <code><a href="spatstat.explore.html#topic+berman.test">berman.test</a></code>
is generic, with methods for
point patterns (<code>"ppp"</code> or <code>"lpp"</code>)
and point process models (<code>"ppm"</code> or <code>"lppm"</code>).
</p>
<p>See the help file for <code><a href="spatstat.explore.html#topic+berman.test">berman.test</a></code>
for information on the generic function and the methods for data in
two-dimensional space, classes <code>"ppp"</code> and <code>"ppm"</code>.
</p>
<p>This help file describes the methods for data on a linear network,
classes <code>"lpp"</code> and <code>"lppm"</code>.
</p>

<ul>
<li> 
<p>If <code>X</code> is a point pattern dataset (object of class
<code>"ppp"</code> or <code>"lpp"</code>), then
<code>berman.test(X, ...)</code> performs a goodness-of-fit test of the
uniform Poisson point process (Complete Spatial Randomness, CSR)
for this dataset.
</p>
</li>
<li>
<p>If <code>model</code> is a fitted point process model
(object of class <code>"ppm"</code> or <code>"lppm"</code>)
then <code>berman.test(model, ...)</code> performs
a test of goodness-of-fit for this fitted model. In this case,
<code>model</code> should be a Poisson point process.
</p>
</li></ul>

<p>The test is performed by comparing the observed distribution
of the values of a spatial covariate at the data points,
and the predicted distribution of the same covariate under the model.
Thus, you must nominate a spatial covariate for this test.
</p>
<p>The argument <code>covariate</code> should be either a <code>function(x,y)</code>
or a pixel image (object of class <code>"im"</code> containing the values
of a spatial function.
If <code>covariate</code> is an image, it should have numeric values,
and its domain should cover the observation window of the
<code>model</code>. If <code>covariate</code> is a function, it should expect
two arguments <code>x</code> and <code>y</code> which are vectors of coordinates,
and it should return a numeric vector of the same length
as <code>x</code> and <code>y</code>.  
</p>
<p>First the original data point pattern is extracted from <code>model</code>.
The values of the <code>covariate</code> at these data points are
collected.
</p>
<p>Next the values of the <code>covariate</code> at all locations in the
observation window are evaluated. The point process intensity
of the fitted model is also evaluated at all locations in the window.
</p>

<ul>
<li><p> If <code>which="Z1"</code>,
the test statistic <code class="reqn">Z_1</code> is computed as follows.
The sum <code class="reqn">S</code> of the covariate values at all data
points is evaluated. The predicted mean <code class="reqn">\mu</code> and variance
<code class="reqn">\sigma^2</code> of <code class="reqn">S</code> are computed
from the values of the covariate at all locations in the window.
Then we compute <code class="reqn">Z_1 = (S-\mu)/\sigma</code>.
Closely-related tests were proposed independently 
by Waller et al (1993) and Lawson (1993)
so this test is often termed the 
Lawson-Waller test in epidemiological literature.
</p>
</li>
<li><p> If <code>which="Z2"</code>,
the test statistic <code class="reqn">Z_2</code> is computed as follows.
The values of the <code>covariate</code> at all locations in the
observation window, weighted by the point process intensity,
are compiled into a cumulative distribution function <code class="reqn">F</code>.
The probability integral transformation is then applied:
the values of the <code>covariate</code> at the original data points
are transformed by the predicted cumulative distribution function
<code class="reqn">F</code> into numbers between 0 and 1. If the model is correct,
these numbers are i.i.d. uniform random numbers.
The standardised sample mean of these numbers is the
statistic <code class="reqn">Z_2</code>. 
</p>
</li></ul>

<p>In both cases the null distribution of the test statistic
is the standard normal distribution, approximately.
</p>
<p>The return value is an object of class <code>"htest"</code> containing the
results of the hypothesis test. The print method for this class
gives an informative summary of the test outcome.
</p>


<h3>Value</h3>

<p>An object of class <code>"htest"</code> (hypothesis test)
and also of class <code>"bermantest"</code>,
containing the results of the test. The return value can be
plotted (by <code><a href="spatstat.explore.html#topic+plot.bermantest">plot.bermantest</a></code>) or printed
to give an informative summary of the test.
</p>


<h3>Warning</h3>

<p>The meaning of a one-sided test must be carefully scrutinised: see
the printed output.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Berman, M. (1986)
Testing for spatial association between a point process
and another stochastic process.
<em>Applied Statistics</em> <b>35</b>, 54&ndash;62.
</p>
<p>Lawson, A.B. (1993)
On the analysis of mortality events around a
prespecified fixed point.
<em>Journal of the Royal Statistical Society, Series A</em>
<b>156</b> (3) 363&ndash;377.
</p>
<p>Waller, L., Turnbull, B., Clark, L.C. and Nasca, P. (1992)
Chronic Disease Surveillance and testing of
clustering of disease and exposure: Application to
leukaemia incidence and TCE-contaminated dumpsites
in upstate New York.
<em>Environmetrics</em> <b>3</b>, 281&ndash;300.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.explore.html#topic+cdf.test">cdf.test</a></code>,
<code><a href="spatstat.explore.html#topic+quadrat.test">quadrat.test</a></code>,
<code><a href="spatstat.model.html#topic+ppm">ppm</a></code>
<code><a href="#topic+lppm">lppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   #' test of complete randomness
   berman.test(spiders, "x")
   #' test of fitted model
   fit &lt;- lppm(spiders ~ x)
   berman.test(fit, "y", "Z2")
</code></pre>

<hr>
<h2 id='branchlabelfun'>
Tree Branch Membership Labelling Function
</h2><span id='topic+branchlabelfun'></span>

<h3>Description</h3>

<p>Creates a function which returns the tree branch membership label
for any location on a linear network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  branchlabelfun(L, root = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="branchlabelfun_+3A_l">L</code></td>
<td>

<p>Linear network (object of class <code>"linnet"</code>).
The network must have no loops.
</p>
</td></tr>
<tr><td><code id="branchlabelfun_+3A_root">root</code></td>
<td>

<p>Root of the tree. An integer index identifying
which point in <code>vertices(L)</code> is the root of the tree.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The linear network <code>L</code>
must be an acyclic graph (i.e. must not contain any loops) so that it
can be interpreted as a tree. 
</p>
<p>The result of <code>f &lt;- branchlabelfun(L, root)</code> is
a function <code>f</code> which gives,
for each location on the linear network <code>L</code>,
the tree branch label at that location.
</p>
<p>Tree branch labels are explained in <code><a href="#topic+treebranchlabels">treebranchlabels</a></code>.
</p>
<p>The result <code>f</code> also belongs to the class <code>"linfun"</code>.
It can be called using several different kinds of data,
as explained in the help for <code><a href="#topic+linfun">linfun</a></code>.
The values of the function are character strings.
</p>


<h3>Value</h3>

<p>A function (of class <code>"linfun"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+treebranchlabels">treebranchlabels</a></code>,
<code><a href="#topic+linfun">linfun</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # make a simple tree
  m &lt;- simplenet$m
  m[8,10] &lt;- m[10,8] &lt;- FALSE
  L &lt;- linnet(vertices(simplenet), m)
  # make function
  f &lt;- branchlabelfun(L, 1)
  plot(f)
  X &lt;- runiflpp(5, L)
  f(X)
</code></pre>

<hr>
<h2 id='bw.lppl'>
Likelihood Cross Validation Bandwidth Selection for Kernel Density on
a Linear Network
</h2><span id='topic+bw.lppl'></span>

<h3>Description</h3>

<p>Uses likelihood cross-validation to select a smoothing bandwidth
for the kernel estimation of point process intensity on a linear network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   bw.lppl(X, ..., srange=NULL, ns=16, sigma=NULL, weights=NULL,
           distance=c("euclidean", "path"), shortcut=TRUE, warn=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bw.lppl_+3A_x">X</code></td>
<td>

<p>A point pattern on a linear network (object of class <code>"lpp"</code>).
</p>
</td></tr>
<tr><td><code id="bw.lppl_+3A_srange">srange</code></td>
<td>

<p>Optional numeric vector of length 2 giving the
range of values of bandwidth to be searched.
</p>
</td></tr>
<tr><td><code id="bw.lppl_+3A_ns">ns</code></td>
<td>

<p>Optional integer giving the number of values of
bandwidth to search.
</p>
</td></tr>
<tr><td><code id="bw.lppl_+3A_sigma">sigma</code></td>
<td>

<p>Optional. Vector of values of the bandwidth to be searched.
Overrides the values of <code>ns</code> and <code>srange</code>.
</p>
</td></tr>
<tr><td><code id="bw.lppl_+3A_weights">weights</code></td>
<td>

<p>Optional. Numeric vector of weights for the points of <code>X</code>.
Argument passed to <code><a href="#topic+density.lpp">density.lpp</a></code>.
</p>
</td></tr>
<tr><td><code id="bw.lppl_+3A_distance">distance</code></td>
<td>

<p>Argument passed to <code><a href="#topic+density.lpp">density.lpp</a></code> controlling the
type of kernel estimator. 
</p>
</td></tr>
<tr><td><code id="bw.lppl_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to <code><a href="#topic+density.lpp">density.lpp</a></code>.
</p>
</td></tr>
<tr><td><code id="bw.lppl_+3A_shortcut">shortcut</code></td>
<td>

<p>Logical value indicating whether to speed up the calculation
by omitting the integral term in the cross-validation criterion.
</p>
</td></tr>
<tr><td><code id="bw.lppl_+3A_warn">warn</code></td>
<td>

<p>Logical. If <code>TRUE</code>, issue a warning if the maximum of
the cross-validation criterion occurs at one of the ends of the
search interval.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function selects an appropriate bandwidth <code>sigma</code>
for the kernel estimator of point process intensity
computed by <code><a href="#topic+density.lpp">density.lpp</a></code>.
</p>
<p>The argument <code>X</code> should be a point pattern on a linear network
(class <code>"lpp"</code>).
</p>
<p>The bandwidth <code class="reqn">\sigma</code> is chosen to 
maximise the point process likelihood cross-validation criterion
</p>
<p style="text-align: center;"><code class="reqn">
    \mbox{LCV}(\sigma) =
    \sum_i \log\hat\lambda_{-i}(x_i) - \int_L \hat\lambda(u) \, {\rm d}u
  </code>
</p>

<p>where the sum is taken over all the data points <code class="reqn">x_i</code>,
where <code class="reqn">\hat\lambda_{-i}(x_i)</code> is the
leave-one-out kernel-smoothing estimate of the intensity at
<code class="reqn">x_i</code> with smoothing bandwidth <code class="reqn">\sigma</code>,
and <code class="reqn">\hat\lambda(u)</code> is the kernel-smoothing estimate
of the intensity at a spatial location <code class="reqn">u</code> with smoothing
bandwidth <code class="reqn">\sigma</code>.
See Loader(1999, Section 5.3).
</p>
<p>The value of <code class="reqn">\mbox{LCV}(\sigma)</code> is computed
directly, using <code><a href="#topic+density.lpp">density.lpp</a></code>, 
for <code>ns</code> different values of <code class="reqn">\sigma</code>
between <code>srange[1]</code> and <code>srange[2]</code>.
</p>
<p>The result is a numerical value giving the selected bandwidth.
The result also belongs to the class <code>"bw.optim"</code>
which can be plotted to show the (rescaled) mean-square error
as a function of <code>sigma</code>.
</p>
<p>If <code>shortcut=TRUE</code>, the computation is accelerated by
omitting the integral term in the equation above. This is valid
because the integral is approximately constant.
</p>


<h3>Value</h3>

<p>A single numerical value giving the selected bandwidth.
The result also belongs to the class <code>"bw.optim"</code>
(see <code><a href="spatstat.explore.html#topic+bw.optim.object">bw.optim.object</a></code>)
which can be plotted to show the bandwidth selection criterion
as a function of <code>sigma</code>.
</p>


<h3>Author(s)</h3>

<p>Greg McSwiggan, Suman Rakshit and Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Loader, C. (1999)
<em>Local Regression and Likelihood</em>.
Springer, New York.
</p>
<p>McSwiggan, G., Baddeley, A. and Nair, G. (2019)
Estimation of relative risk for events on a linear network.
<em>Statistics and Computing</em> <b>30</b> (2) 469&ndash;484.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+density.lpp">density.lpp</a></code>,
<code><a href="spatstat.explore.html#topic+bw.scott">bw.scott</a></code>.
</p>
<p><code><a href="spatstat.explore.html#topic+bw.optim.object">bw.optim.object</a></code>.
</p>
<p>For point patterns in two-dimensional space, use <code><a href="spatstat.explore.html#topic+bw.ppl">bw.ppl</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  if(interactive()) {
    b &lt;- bw.lppl(spiders)
    plot(b, main="Likelihood cross validation for spiders")
    plot(density(spiders, b, distance="e"))
  } else {
    b1 &lt;- bw.lppl(spiders, ns=2)
    b2 &lt;- bw.lppl(spiders, ns=2, shortcut=TRUE)
  }
</code></pre>

<hr>
<h2 id='bw.relrisk.lpp'>
Cross Validated Bandwidth Selection for Relative Risk Estimation
on a Network
</h2><span id='topic+bw.relrisk.lpp'></span>

<h3>Description</h3>

<p>Uses cross-validation to select a smoothing bandwidth
for the estimation of relative risk on a linear network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'lpp'
bw.relrisk(X, ...,
    method = c("likelihood", "leastsquares", "KelsallDiggle", "McSwiggan"),
    distance=c("path", "euclidean"),
    hmin = NULL, hmax = NULL, nh = NULL,
    fast = TRUE, fastmethod = "onestep",
    floored = TRUE, reference = c("thumb", "uniform", "sigma"),
    allow.infinite = TRUE, epsilon = 1e-20, fudge = 0,
    verbose = FALSE, warn = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bw.relrisk.lpp_+3A_x">X</code></td>
<td>

<p>A multitype point pattern on a linear network (object of class
<code>"lpp"</code> which has factor-valued marks).
</p>
</td></tr>
<tr><td><code id="bw.relrisk.lpp_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+density.lpp">density.lpp</a></code> to control the
resolution of the algorithm.
</p>
</td></tr>
<tr><td><code id="bw.relrisk.lpp_+3A_method">method</code></td>
<td>

<p>Character string (partially matched)
determining the cross-validation method.
See Details.
</p>
</td></tr>
<tr><td><code id="bw.relrisk.lpp_+3A_distance">distance</code></td>
<td>

<p>Character string (partially matched)
specifying the type of smoothing kernel.
See <code><a href="#topic+density.lpp">density.lpp</a></code>.
</p>
</td></tr>
<tr><td><code id="bw.relrisk.lpp_+3A_hmin">hmin</code>, <code id="bw.relrisk.lpp_+3A_hmax">hmax</code></td>
<td>

<p>Optional. Numeric values.
Range of trial values of smoothing bandwith <code>sigma</code>
to consider. There is a sensible default.
</p>
</td></tr>
<tr><td><code id="bw.relrisk.lpp_+3A_nh">nh</code></td>
<td>

<p>Number of trial values of smoothing bandwidth <code>sigma</code>
to consider.
</p>
</td></tr>
<tr><td><code id="bw.relrisk.lpp_+3A_fast">fast</code></td>
<td>

<p>Logical value specifying whether the leave-one-out density estimates
should be computed using a fast approximation (<code>fast=TRUE</code>, the
default) or exactly (<code>fast=FALSE</code>).
</p>
</td></tr>
<tr><td><code id="bw.relrisk.lpp_+3A_fastmethod">fastmethod</code>, <code id="bw.relrisk.lpp_+3A_floored">floored</code></td>
<td>

<p>Developer use only.
</p>
</td></tr>
<tr><td><code id="bw.relrisk.lpp_+3A_reference">reference</code></td>
<td>

<p>Character string (partially matched) specifying the
bandwidth for calculating the
reference intensities used in the McSwiggan method
(modified Kelsall-Diggle method).
<code>reference="sigma"</code> means the maximum bandwidth considered,
which is given by the argument <code>sigma</code>.
<code>reference="thumb"</code> means the bandwidths selected by
Scott's rule of thumb <code><a href="spatstat.explore.html#topic+bw.scott.iso">bw.scott.iso</a></code>.
<code>reference="uniform"</code> means infinite bandwidth corresponding to
uniform intensity.
</p>
</td></tr>
<tr><td><code id="bw.relrisk.lpp_+3A_allow.infinite">allow.infinite</code></td>
<td>

<p>Logical value indicating whether an infinite bandwidth
(corresponding to a constant relative risk) should be permitted
as a possible choice of bandwidth.
</p>
</td></tr>
<tr><td><code id="bw.relrisk.lpp_+3A_epsilon">epsilon</code></td>
<td>

<p>A small constant value added to the reference density in some
of the cross-validation calculations, to improve performance.
</p>
</td></tr>
<tr><td><code id="bw.relrisk.lpp_+3A_fudge">fudge</code></td>
<td>

<p>Fudge factor to prevent very small density estimates in the
leave-one-out calculation. If <code>fudge &gt; 0</code>,
then the lowest permitted value
for a leave-one-out estimate of intensity is
<code>fudge/L</code>, where <code>L</code> is the total length of the
network. 
</p>
</td></tr>
<tr><td><code id="bw.relrisk.lpp_+3A_verbose">verbose</code></td>
<td>

<p>Logical value indicating whether to print progress reports,
</p>
</td></tr>
<tr><td><code id="bw.relrisk.lpp_+3A_warn">warn</code></td>
<td>

<p>Logical. If <code>TRUE</code>, issue a warning if the minimum of
the cross-validation criterion occurs at one of the ends of the
search interval.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a method for the generic <code><a href="spatstat.explore.html#topic+bw.relrisk">bw.relrisk</a></code>.
It computes an optimal value of smoothing bandwidth
for the nonparametric estimation of relative risk on a linear network
using <code><a href="#topic+relrisk.lpp">relrisk.lpp</a></code>.
The optimal value is found by minimising a cross-validation criterion.
</p>
<p>The cross-validation criterion is selected by the argument <code>method</code>:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>method="likelihood"</code> </td><td style="text-align: left;"> (negative) likelihood cross-validation </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>method="leastsquares"</code> </td><td style="text-align: left;"> least squares cross-validation </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>method="KelsallDiggle"</code> </td><td style="text-align: left;"> Kelsall and Diggle (1995) density
  ratio cross-validation </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>method="McSwiggan"</code> </td><td style="text-align: left;"> McSwiggan et al (2019) modified
  density ratio cross-validation </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p>See McSwiggan et al (2019) for details.
</p>
<p>The result is a numerical value giving the selected bandwidth <code>sigma</code>.
The result also belongs to the class <code>"bw.optim"</code>
allowing it to be printed and plotted. The plot shows the cross-validation
criterion as a function of bandwidth.
The &lsquo;optimal&rsquo; bandwidth is the value of bandwidth
which minimises the cross-validation criterion. 
</p>
<p>The range of values for the smoothing bandwidth <code>sigma</code>
is set by the arguments <code>hmin, hmax</code>. There is a sensible default,
based on the linear network version of Scott's rule
<code><a href="spatstat.explore.html#topic+bw.scott.iso">bw.scott.iso</a></code>.
</p>
<p>If the optimal bandwidth is achieved at an endpoint of the
interval <code>[hmin, hmax]</code>, the algorithm will issue a warning
(unless <code>warn=FALSE</code>). If this occurs, then it is probably advisable
to expand the interval by changing the arguments <code>hmin, hmax</code>.
</p>
<p>The cross-validation procedure is based on kernel estimates
of intensity, which are computed by <code><a href="#topic+density.lpp">density.lpp</a></code>.
Any arguments <code>...</code> are passed to <code><a href="#topic+density.lpp">density.lpp</a></code>
to control the kernel estimation procedure. This includes the
argument <code>distance</code> which specifies the type of kernel.
The default is <code>distance="path"</code>;
the fastest option is <code>distance="euclidean"</code>.
</p>


<h3>Value</h3>

<p>A single numerical value giving the selected bandwidth.
The result also belongs to the class <code>"bw.optim"</code>
(see <code><a href="spatstat.explore.html#topic+bw.optim.object">bw.optim.object</a></code>)
which can be plotted to show the bandwidth selection criterion
as a function of <code>sigma</code>.
</p>


<h3>Author(s)</h3>

<p>Greg McSwiggan and Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Kelsall, J.E. and Diggle, P.J. (1995)
Kernel estimation of relative risk.
<em>Bernoulli</em> <b>1</b>, 3&ndash;16.
</p>
<p>McSwiggan, G., Baddeley, A. and Nair, G. (2019)
Estimation of relative risk for events on a linear network.
<em>Statistics and Computing</em> <b>30</b> (2) 469&ndash;484.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+relrisk.lpp">relrisk.lpp</a></code>, <code><a href="spatstat.explore.html#topic+bw.relrisk">bw.relrisk</a></code>,
<code><a href="spatstat.explore.html#topic+bw.optim.object">bw.optim.object</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   set.seed(2020)
   X &lt;- superimpose(A=runiflpp(20, simplenet),
                    B=runifpointOnLines(20, as.psp(simplenet)[1]))
   plot(bw.relrisk(X, hmin=0.13, hmax=0.22, method="McSwiggan"))
   plot(bw.relrisk(X, hmin=0.1, hmax=0.2, nh=8, distance="euclidean"))
</code></pre>

<hr>
<h2 id='bw.voronoi'>
Cross Validated Bandwidth Selection for Voronoi Estimator of Intensity
on a Network
</h2><span id='topic+bw.voronoi'></span>

<h3>Description</h3>

<p>Uses cross-validation to select a smoothing bandwidth
for the Voronoi estimate of point process intensity
on a linear network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bw.voronoi(X, ..., probrange = c(0.2, 0.8), nprob = 10,
           prob = NULL, nrep = 100, verbose = TRUE, warn=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bw.voronoi_+3A_x">X</code></td>
<td>

<p>Point pattern on a linear network (object of class <code>"lpp"</code>).
</p>
</td></tr>
<tr><td><code id="bw.voronoi_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="bw.voronoi_+3A_probrange">probrange</code></td>
<td>

<p>Numeric vector of length 2 giving the range of bandwidths
(retention probabilities)
to be assessed.
</p>
</td></tr>
<tr><td><code id="bw.voronoi_+3A_nprob">nprob</code></td>
<td>

<p>Integer. Number of bandwidths to be assessed.
</p>
</td></tr>
<tr><td><code id="bw.voronoi_+3A_prob">prob</code></td>
<td>

<p>Optional. A numeric vector of bandwidths (retention probabilities)
to be assessed. Entries must be probabilities between 0 and 1.
Overrides <code>nprob</code> and <code>probrange</code>.
</p>
</td></tr>
<tr><td><code id="bw.voronoi_+3A_nrep">nrep</code></td>
<td>

<p>Number of simulated realisations to be used for the computation.
</p>
</td></tr>
<tr><td><code id="bw.voronoi_+3A_verbose">verbose</code></td>
<td>

<p>Logical value indicating whether to print progress reports.
</p>
</td></tr>
<tr><td><code id="bw.voronoi_+3A_warn">warn</code></td>
<td>

<p>Logical. If <code>TRUE</code>, issue a warning if the maximum of
the cross-validation criterion occurs at one of the ends of the
search interval.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses likelihood cross-validation to choose the optimal value of the
thinning fraction <code>f</code> (the retention probability)
to be used in the smoothed Voronoi estimator of point process
intensity <code><a href="#topic+densityVoronoi.lpp">densityVoronoi.lpp</a></code>.
</p>


<h3>Value</h3>

<p>A single numerical value giving the selected bandwidth.
The result also belongs to the class <code>"bw.optim"</code>
(see <code><a href="spatstat.explore.html#topic+bw.optim.object">bw.optim.object</a></code>)
which can be plotted to show the bandwidth selection criterion
as a function of <code>sigma</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a> and Mehdi Moradi <a href="mailto:m2.moradi@yahoo.com">m2.moradi@yahoo.com</a>.
</p>


<h3>References</h3>

<p>Moradi, M., Cronie, 0., Rubak, E., Lachieze-Rey, R.,
Mateu, J. and Baddeley, A. (2019)
Resample-smoothing of Voronoi intensity estimators.
<em>Statistics and Computing</em> <b>29</b> (5) 995&ndash;1010.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+densityVoronoi.lpp">densityVoronoi.lpp</a></code>, <code><a href="spatstat.explore.html#topic+bw.optim.object">bw.optim.object</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   np &lt;- if(interactive()) 10 else 3
   nr &lt;- if(interactive()) 100 else 2
   b &lt;- bw.voronoi(spiders, nprob=np, nrep=nr)
   b
   plot(b)
</code></pre>

<hr>
<h2 id='cdf.test.lpp'>Spatial Distribution Test for Points on a Linear Network</h2><span id='topic+cdf.test.lppm'></span><span id='topic+cdf.test.lpp'></span>

<h3>Description</h3>

<p>Performs a test of goodness-of-fit of a point process model
on a linear network.
The observed and predicted distributions
of the values of a spatial covariate are compared using either the
Kolmogorov-Smirnov test,
Cramer-von Mises test
or Anderson-Darling test.
For non-Poisson models, a Monte Carlo test is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpp'
cdf.test(X, covariate,  test=c("ks", "cvm", "ad"), ...,
        interpolate=TRUE, jitter=TRUE)

## S3 method for class 'lppm'
cdf.test(model, covariate,  test=c("ks", "cvm", "ad"), ...,
          interpolate=TRUE, jitter=TRUE, nsim=99, verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdf.test.lpp_+3A_x">X</code></td>
<td>

<p>A point pattern on a linear network (object of class <code>"lpp"</code>).
</p>
</td></tr>
<tr><td><code id="cdf.test.lpp_+3A_model">model</code></td>
<td>

<p>A fitted point process model on a linear network
(object of class <code>"lppm"</code>)
</p>
</td></tr>
<tr><td><code id="cdf.test.lpp_+3A_covariate">covariate</code></td>
<td>

<p>The spatial covariate on which the test will be based.
A function, a pixel image (object of class <code>"im"</code> or <code>"linim"</code>),
a list of pixel images, or one of the characters
<code>"x"</code> or <code>"y"</code> indicating the Cartesian coordinates.
</p>
</td></tr>
<tr><td><code id="cdf.test.lpp_+3A_test">test</code></td>
<td>

<p>Character string identifying the test to be performed:
<code>"ks"</code> for Kolmogorov-Smirnov test,
<code>"cvm"</code> for Cramer-von Mises test
or <code>"ad"</code> for Anderson-Darling test.
</p>
</td></tr>
<tr><td><code id="cdf.test.lpp_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="stats.html#topic+ks.test">ks.test</a></code>
(from the <span class="pkg">stats</span> package) or 
<code><a href="goftest.html#topic+cvm.test">cvm.test</a></code> or
<code><a href="goftest.html#topic+ad.test">ad.test</a></code> (from the <span class="pkg">goftest</span> package)
to control the test.
</p>
</td></tr>
<tr><td><code id="cdf.test.lpp_+3A_interpolate">interpolate</code></td>
<td>

<p>Logical flag indicating whether to interpolate pixel images.
If <code>interpolate=TRUE</code>, the value of the covariate
at each point of <code>X</code> will be approximated by interpolating
the nearby pixel values.
If <code>interpolate=FALSE</code>, the nearest pixel value will be used.
</p>
</td></tr>
<tr><td><code id="cdf.test.lpp_+3A_jitter">jitter</code></td>
<td>

<p>Logical flag. If <code>jitter=TRUE</code>, values of the covariate
will be slightly perturbed at random, to avoid tied values in the test.
</p>
</td></tr>
<tr><td><code id="cdf.test.lpp_+3A_nsim">nsim</code></td>
<td>

<p>Number of simulated realisations from the <code>model</code> to be used
for the Monte Carlo test, when <code>model</code> is not a Poisson process.
</p>
</td></tr>
<tr><td><code id="cdf.test.lpp_+3A_verbose">verbose</code></td>
<td>

<p>Logical value indicating whether to print progress reports when
performing a Monte Carlo test.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions perform a goodness-of-fit test of a Poisson point
process model fitted to point pattern data on a linear network.
The observed distribution
of the values of a spatial covariate at the data points,
and the predicted distribution of the same values under the model,
are compared using the Kolmogorov-Smirnov test,
the Cramer-von Mises test
or the Anderson-Darling test. For Gibbs models, a Monte Carlo test is
performed using these test statistics.
</p>
<p>The function <code><a href="spatstat.explore.html#topic+cdf.test">cdf.test</a></code>
is generic, with methods for
point patterns (<code>"ppp"</code> or <code>"lpp"</code>),
point process models (<code>"ppm"</code> or <code>"lppm"</code>)
and spatial logistic regression models (<code>"slrm"</code>).
</p>
<p>See the help file for <code><a href="spatstat.explore.html#topic+cdf.test">cdf.test</a></code>
for information on the generic function and the methods
for data in two-dimensional space, classes <code>"ppp"</code>, <code>"ppm"</code>
and <code>"slrm"</code>.
</p>
<p>This help file describes the methods for data on a linear network,
classes <code>"lpp"</code> and <code>"lppm"</code>.
</p>

<ul>
<li> 
<p>If <code>X</code> is a point pattern on a linear network (object of class
<code>"lpp"</code>), then <code>cdf.test(X, ...)</code>
performs a goodness-of-fit test of the
uniform Poisson point process (Complete Spatial Randomness, CSR)
for this dataset.
For a multitype point pattern, the uniform intensity
is assumed to depend on the type of point (sometimes called
Complete Spatial Randomness and Independence, CSRI).
</p>
</li>
<li>
<p>If <code>model</code> is a fitted point process model on a network
(object of class <code>"lppm"</code>)
then <code>cdf.test(model, ...)</code> performs
a test of goodness-of-fit for this fitted model. 
</p>
</li></ul>

<p>The test is performed by comparing the observed distribution
of the values of a spatial covariate at the data points,
and the predicted distribution of the same covariate under the model,
using a classical goodness-of-fit test.
Thus, you must nominate
a spatial covariate for this test.
</p>
<p>If <code>X</code> is a point pattern that does not have marks,
the argument <code>covariate</code> should be either a <code>function(x,y)</code>
or a pixel image (object of class <code>"im"</code> or <code>"linim"</code>)
containing the values
of a spatial function, or one of the characters <code>"x"</code> or
<code>"y"</code> indicating the Cartesian coordinates.
If <code>covariate</code> is an image, it should have numeric values,
and its domain should cover the observation window of the
<code>model</code>. If <code>covariate</code> is a function, it should expect
two arguments <code>x</code> and <code>y</code> which are vectors of coordinates,
and it should return a numeric vector of the same length
as <code>x</code> and <code>y</code>.
</p>
<p>If <code>X</code> is a multitype point pattern, the argument <code>covariate</code>
can be either a <code>function(x,y,marks)</code>,
or a pixel image, or a list of pixel images corresponding to
each possible mark value, or one of the characters <code>"x"</code> or
<code>"y"</code> indicating the Cartesian coordinates. 
</p>
<p>First the original data point pattern is extracted from <code>model</code>.
The values of the <code>covariate</code> at these data points are
collected. 
</p>
<p>The predicted distribution of the values of the <code>covariate</code>
under the fitted <code>model</code> is computed as follows.
The values of the <code>covariate</code> at all locations in the
observation window are evaluated,
weighted according to the point process intensity of the fitted model,
and compiled into a cumulative distribution function <code class="reqn">F</code> using
<code><a href="spatstat.geom.html#topic+ewcdf">ewcdf</a></code>.
</p>
<p>The probability integral transformation is then applied:
the values of the <code>covariate</code> at the original data points
are transformed by the predicted cumulative distribution function
<code class="reqn">F</code> into numbers between 0 and 1. If the model is correct,
these numbers are i.i.d. uniform random numbers. The
A goodness-of-fit test of the uniform distribution is applied
to these numbers using <code>stats::<a href="stats.html#topic+ks.test">ks.test</a></code>,
<code>goftest::<a href="goftest.html#topic+cvm.test">cvm.test</a></code> or
<code>goftest::<a href="goftest.html#topic+ad.test">ad.test</a></code>.
</p>
<p>This test was apparently first described (in the context of
two-dimensional spatial data, and using Kolmogorov-Smirnov) by Berman (1986).
See also Baddeley et al (2005).
</p>
<p>If <code>model</code> is not a Poisson process, then
a Monte Carlo test is performed, by generating <code>nsim</code>
point patterns which are simulated realisations of the <code>model</code>,
re-fitting the model to each simulated point pattern, 
and calculating the test statistic for each fitted model.
The Monte Carlo <code class="reqn">p</code> value is determined by comparing
the simulated values of the test statistic 
with the value for the original data.
</p>
<p>The return value is an object of class <code>"htest"</code> containing the
results of the hypothesis test. The print method for this class
gives an informative summary of the test outcome.
</p>
<p>The return value also belongs to the class <code>"cdftest"</code>
for which there is a plot method <code><a href="spatstat.explore.html#topic+plot.cdftest">plot.cdftest</a></code>.
The plot method displays the empirical cumulative distribution
function of the covariate at the data points, and the predicted
cumulative distribution function of the covariate under the model,
plotted against the value of the covariate.
</p>
<p>The argument <code>jitter</code> controls whether covariate values are
randomly perturbed, in order to avoid ties.
If the original data contains any ties in the covariate (i.e. points
with equal values of the covariate), and if <code>jitter=FALSE</code>, then 
the Kolmogorov-Smirnov test implemented in <code><a href="stats.html#topic+ks.test">ks.test</a></code>
will issue a warning that it cannot calculate the exact <code class="reqn">p</code>-value.
To avoid this, if <code>jitter=TRUE</code> each value of the covariate will
be perturbed by adding a small random value. The perturbations are
normally distributed with standard deviation equal to one hundredth of
the range of values of the covariate. This prevents ties, 
and the <code class="reqn">p</code>-value is still correct. There is
a very slight loss of power.
</p>


<h3>Value</h3>

<p>An object of class <code>"htest"</code> containing the results of the
test. See <code><a href="stats.html#topic+ks.test">ks.test</a></code> for details. The return value can be
printed to give an informative summary of the test.
</p>
<p>The value also belongs to the class <code>"cdftest"</code> for which there is
a plot method.
</p>


<h3>Warning</h3>

<p>The outcome of the test involves a small amount of random variability,
because (by default) the coordinates are randomly perturbed to
avoid tied values. Hence, if <code>cdf.test</code> is executed twice, the
<code class="reqn">p</code>-values will not be exactly the same. To avoid this behaviour,
set <code>jitter=FALSE</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>References</h3>

<p>Baddeley, A., Turner, R.,
Moller, J. and Hazelton, M. (2005)
Residual analysis for spatial point processes.
<em>Journal of the Royal Statistical Society, Series B</em>
<b>67</b>, 617&ndash;666.
</p>
<p>Berman, M. (1986)
Testing for spatial association between a point process
and another stochastic process.
<em>Applied Statistics</em> <b>35</b>, 54&ndash;62.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.explore.html#topic+plot.cdftest">plot.cdftest</a></code>,
<code><a href="spatstat.explore.html#topic+quadrat.test">quadrat.test</a></code>,
<code><a href="spatstat.explore.html#topic+berman.test">berman.test</a></code>,
<code><a href="stats.html#topic+ks.test">ks.test</a></code>,
<code>goftest::<a href="goftest.html#topic+cvm.test">cvm.test</a></code>,
<code>goftest::<a href="goftest.html#topic+ad.test">ad.test</a></code>,
<code><a href="#topic+lppm">lppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   op &lt;- options(useFancyQuotes=FALSE)

   # test of CSR using x coordinate
   cdf.test(spiders, "x")

   # fit inhomogeneous Poisson model and test
   model &lt;- lppm(spiders ~x)
   cdf.test(model, "y")

   # test of CSR using a function of x and y
   fun &lt;- function(x,y){2* x + y}
   cdf.test(spiders, fun)

   # test of CSR using an image covariate
   fim &lt;- as.linim(fun, domain(spiders))
   cdf.test(spiders, fim)

   options(op)
</code></pre>

<hr>
<h2 id='chop.linnet'>
Divide a Linear Network into Tiles Using Infinite Lines
</h2><span id='topic+chop.linnet'></span>

<h3>Description</h3>

<p>Given a linear network and a set of infinite lines,
divide the network into tiles demarcated by the lines.
The result is a tessellation of the network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chop.linnet(X, L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chop.linnet_+3A_x">X</code></td>
<td>

<p>Linear network (object of class <code>"linnet"</code>)
or data acceptable to <code><a href="#topic+as.linnet">as.linnet</a></code>.
</p>
</td></tr>
<tr><td><code id="chop.linnet_+3A_l">L</code></td>
<td>

<p>Infinite line or lines (object of class <code>"infline"</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first line of <code>L</code> divides <code>X</code> into two tiles.
Subsequent lines divide each of these tiles. The result is a
tessellation of <code>X</code>. Tiles are not necessarily connected sets.
</p>


<h3>Value</h3>

<p>Tessellation on a linear network
(object of class <code>"lintess"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crossing.linnet">crossing.linnet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   L &lt;- infline(p=runif(3), theta=runif(3, max=pi/2))
   Y &lt;- chop.linnet(simplenet, L)
   plot(Y, main="")
   plot(L, col="red")
</code></pre>

<hr>
<h2 id='clickjoin'>
Interactively join vertices on a plot
</h2><span id='topic+clickjoin'></span>

<h3>Description</h3>

<p>Given a point pattern representing a set of vertices,
this command gives a point-and-click interface
allowing the user to join pairs of selected vertices by edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  clickjoin(X, ..., add = TRUE, m = NULL, join = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clickjoin_+3A_x">X</code></td>
<td>

<p>Point pattern of vertices. An object of class <code>"ppp"</code>.
</p>
</td></tr>
<tr><td><code id="clickjoin_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="graphics.html#topic+segments">segments</a></code> to control
the plotting of the new edges.
</p>
</td></tr>
<tr><td><code id="clickjoin_+3A_add">add</code></td>
<td>

<p>Logical. Whether the point pattern <code>X</code> should be added to the
existing plot (<code>add=TRUE</code>) or a new plot should be created
(<code>add=FALSE</code>).
</p>
</td></tr>
<tr><td><code id="clickjoin_+3A_m">m</code></td>
<td>

<p>Optional. Logical matrix specifying an initial
set of edges. There is an edge between vertices <code>i</code> and
<code>j</code> if <code>m[i,j] = TRUE</code>.
</p>
</td></tr>
<tr><td><code id="clickjoin_+3A_join">join</code></td>
<td>

<p>Optional. If <code>TRUE</code>, then each user click will join a pair of
vertices. If <code>FALSE</code>, then each user click will delete an
existing edge. This is only relevant if <code>m</code> is supplied.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function makes it easier for the user to create a
linear network or a planar graph, given a set of vertices.
</p>
<p>The function first displays the point pattern <code>X</code>,
then repeatedly prompts the user to click on a pair of points in <code>X</code>.
Each selected pair of points will be joined
by an edge. The function returns a
logical matrix which has entries equal to <code>TRUE</code> for each
pair of vertices joined by an edge.
</p>
<p>The selection of points is performed
using <code><a href="spatstat.geom.html#topic+identify.ppp">identify.ppp</a></code> which typically expects the user to
click the left mouse button.  This point-and-click interaction
continues until the user terminates it, 
by pressing the middle mouse button,
or pressing the right mouse button and selecting <code>stop</code>.
</p>
<p>The return value can be used in <code><a href="#topic+linnet">linnet</a></code>
to create a linear network.
</p>


<h3>Value</h3>

<p>Logical matrix <code>m</code> with value <code>m[i,j] = TRUE</code> for every
pair of vertices <code>X[i]</code> and <code>X[j]</code> that should be joined by
an edge.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linnet">linnet</a></code>,
<code><a href="spatstat.geom.html#topic+clickppp">clickppp</a></code>
</p>

<hr>
<h2 id='clicklpp'>Interactively Add Points on a Linear Network</h2><span id='topic+clicklpp'></span>

<h3>Description</h3>

<p>Allows the user to create a point pattern on a linear network by
point-and-click in the display.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  clicklpp(L, n=NULL, types=NULL, ...,
           add=FALSE, main=NULL, hook=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clicklpp_+3A_l">L</code></td>
<td>

<p>Linear network on which the points will be placed.
An object of class <code>"linnet"</code>.
</p>
</td></tr>
<tr><td><code id="clicklpp_+3A_n">n</code></td>
<td>

<p>Number of points to be added (if this is predetermined).
</p>
</td></tr>
<tr><td><code id="clicklpp_+3A_types">types</code></td>
<td>

<p>Vector of types, when creating a multitype point pattern.
</p>
</td></tr>
<tr><td><code id="clicklpp_+3A_...">...</code></td>
<td>

<p>Optional extra arguments to be passed to <code><a href="graphics.html#topic+locator">locator</a></code>
to control the display.
</p>
</td></tr>
<tr><td><code id="clicklpp_+3A_add">add</code></td>
<td>

<p>Logical value indicating whether to create a new plot
(<code>add=FALSE</code>) or draw over the existing plot (<code>add=TRUE</code>).
</p>
</td></tr>
<tr><td><code id="clicklpp_+3A_main">main</code></td>
<td>

<p>Main heading for plot.
</p>
</td></tr>
<tr><td><code id="clicklpp_+3A_hook">hook</code></td>
<td>
<p>For internal use only. Do not use this argument.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows the user to create a point pattern
on a linear network
by interactively clicking on the screen display.
</p>
<p>First the linear network <code>L</code> is plotted on the current screen device.
Then the user is prompted to point the mouse at any desired locations
and click the left mouse button to add each point.
Interactive input stops after <code>n</code> clicks (if <code>n</code> was given)
or when the middle mouse button is pressed.
</p>
<p>The return value is a point pattern on the network <code>L</code>,
containing the locations of all the clicked points,
after they have been projected onto the network <code>L</code>.
Any points that were clicked outside the bounding window of the network
will be ignored.
</p>
<p>If the argument <code>types</code> is given, then a multitype point pattern
will be created. The user is
prompted to input the locations of points of type <code>type[i]</code>,
for each successive index <code>i</code>. (If the argument <code>n</code> was
given, there will be <code>n</code> points of <em>each</em> type.)
The return value is a multitype point pattern on a linear network.
</p>
<p>This function uses the <span class="rlang"><b>R</b></span> command <code><a href="graphics.html#topic+locator">locator</a></code> to
input the mouse clicks. It only works on screen devices such as
&lsquo;X11&rsquo;, &lsquo;windows&rsquo; and &lsquo;quartz&rsquo;. Arguments that can be
passed to <code><a href="graphics.html#topic+locator">locator</a></code> through <code>...</code> include
<code>pch</code> (plotting character), <code>cex</code> (character expansion
factor) and <code>col</code> (colour). See <code><a href="graphics.html#topic+locator">locator</a></code>
and <code><a href="graphics.html#topic+par">par</a></code>.
</p>


<h3>Value</h3>

<p>A point pattern (object of class <code>"lpp"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>, based on an idea by Dominic Schuhmacher.  
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.geom.html#topic+clickppp">clickppp</a></code>,
<code><a href="#topic+identify.lpp">identify.lpp</a></code>,
<code><a href="graphics.html#topic+locator">locator</a></code>,
<code><a href="spatstat.geom.html#topic+clickpoly">clickpoly</a></code>,
<code><a href="spatstat.geom.html#topic+clickbox">clickbox</a></code>,
<code><a href="spatstat.geom.html#topic+clickdist">clickdist</a></code>
</p>

<hr>
<h2 id='connected.linnet'>
Connected Components of a Linear Network
</h2><span id='topic+connected.linnet'></span>

<h3>Description</h3>

<p>Find the topologically-connected components of a linear network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'linnet'
connected(X, ..., what = c("labels", "components"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="connected.linnet_+3A_x">X</code></td>
<td>

<p>A linear network (object of class <code>"linnet"</code>).
</p>
</td></tr>
<tr><td><code id="connected.linnet_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="connected.linnet_+3A_what">what</code></td>
<td>

<p>Character string specifying the kind of result.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>connected</code> is generic. This is the method for
linear networks (objects of class <code>"linnet"</code>).
</p>
<p>Two vertices of the network are connected if they are joined by a path
in the network. This function divides the network into subsets, such
that all points in a subset are connected to each other.
</p>
<p>If <code>what="labels"</code> the return value is a factor with one entry
for each vertex of <code>X</code>, identifying which connected component the
vertex belongs to. 
</p>
<p>If <code>what="components"</code> the return value is a list of linear
networks, which are the connected components of <code>X</code>.
</p>


<h3>Value</h3>

<p>If <code>what="labels"</code>, a factor.
If <code>what="components"</code>, a list of linear networks.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Suman Rakshit.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+thinNetwork">thinNetwork</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # remove some edges from a network to make it disconnected
   plot(simplenet, col="grey", main="", lty=2)
   A &lt;- thinNetwork(simplenet, retainedges=-c(3,5))
   plot(A, add=TRUE, lwd=2)
   # find the connected components
   connected(A)
   cA &lt;- connected(A, what="components")
   plot(cA[[1]], add=TRUE, col="green", lwd=2)
   plot(cA[[2]], add=TRUE, col="blue", lwd=2)
</code></pre>

<hr>
<h2 id='connected.lpp'>
Connected Components of a Point Pattern on a Linear Network
</h2><span id='topic+connected.lpp'></span>

<h3>Description</h3>

<p>Finds the topologically-connected components of a point pattern on a
linear network, when all pairs of points closer than a threshold distance
are joined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpp'
connected(X, R=Inf, ..., dismantle=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="connected.lpp_+3A_x">X</code></td>
<td>

<p>A linear network (object of class <code>"lpp"</code>).
</p>
</td></tr>
<tr><td><code id="connected.lpp_+3A_r">R</code></td>
<td>

<p>Threshold distance. Pairs of points will be joined together
if they are closer than <code>R</code> units apart, measured
by the shortest path in the network.
The default <code>R=Inf</code> implies that points
will be joined together if they are mutually connected by any
path in the network.
</p>
</td></tr>
<tr><td><code id="connected.lpp_+3A_dismantle">dismantle</code></td>
<td>

<p>Logical. If <code>TRUE</code> (the default), the network itself will be
divided into its path-connected components using
<code><a href="#topic+connected.linnet">connected.linnet</a></code>.
</p>
</td></tr>
<tr><td><code id="connected.lpp_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>connected</code> is generic. This is the method for
point patterns on a linear network (objects of class <code>"lpp"</code>).
It divides the point pattern <code>X</code> into one or more groups of points.
</p>
<p>If <code>R=Inf</code> (the default), then <code>X</code> is divided into groups
such that any pair of points in the same group
can be joined by a path in the network.
</p>
<p>If <code>R</code> is a finite number, then two points of <code>X</code> are
declared to be <em>R-close</em> if they lie closer than
<code>R</code> units apart, measured by the length of the shortest path in the
network. Two points are <em>R-connected</em> if they 
can be reached by a series of steps between R-close pairs of
points of <code>X</code>. Then <code>X</code> is divided into groups such that
any pair of points in the same group is R-connected.
</p>
<p>If <code>dismantle=TRUE</code> (the default) the algorithm first checks
whether the network is connected (i.e. whether any pair of vertices
can be joined by a path in the network), and if not, the network is
decomposed into its connected components.
</p>


<h3>Value</h3>

<p>A point pattern (of class <code>"lpp"</code>) with marks indicating the
grouping, or a list of such point patterns.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+thinNetwork">thinNetwork</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   ## behaviour like connected.ppp
   U &lt;- runiflpp(20, simplenet)
   plot(connected(U, 0.15, dismantle=FALSE))

   ## behaviour like connected.owin
   ## remove some edges from a network to make it disconnected
   plot(simplenet, col="grey", main="", lty=2)
   A &lt;- thinNetwork(simplenet, retainedges=-c(3,5))
   plot(A, add=TRUE, lwd=2)
   X &lt;- runiflpp(10, A)
   ## find the connected components
   cX &lt;- connected(X)
   plot(cX[[1]], add=TRUE, col="blue", lwd=2)
</code></pre>

<hr>
<h2 id='crossdist.lpp'>Pairwise distances between two point patterns on a linear network</h2><span id='topic+crossdist.lpp'></span>

<h3>Description</h3>

<p>Computes the distances between pairs of points
taken from two different point patterns on
the same linear network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'lpp'
crossdist(X, Y, ..., method="C", check=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crossdist.lpp_+3A_x">X</code>, <code id="crossdist.lpp_+3A_y">Y</code></td>
<td>

<p>Point patterns on a linear network (objects of class <code>"lpp"</code>).
They must lie on the <em>same</em> network.
</p>
</td></tr>
<tr><td><code id="crossdist.lpp_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="crossdist.lpp_+3A_method">method</code></td>
<td>

<p>String specifying which method of calculation to use
when the network data use the non-sparse representation.
Values are <code>"C"</code> and <code>"interpreted"</code>.
</p>
</td></tr>
<tr><td><code id="crossdist.lpp_+3A_check">check</code></td>
<td>

<p>Logical value specifying whether to check that <code>X</code> and <code>Y</code>
are defined on the same network. Default is <code>check=TRUE</code>.
Setting <code>check=FALSE</code> will save time,
but should only be used if it is certain that the
two networks are identical.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given two point patterns on a linear network,
this function computes the distance from each point
in the first pattern to each point in the second pattern,
measuring distance by the shortest path along the network.
</p>
<p>This is a method for the generic function <code><a href="spatstat.geom.html#topic+crossdist">crossdist</a></code>
for the class of point patterns on a linear network
(objects of class <code>"lpp"</code>).
</p>
<p>This function expects two point pattern objects <code>X</code> and <code>Y</code>
on the <em>same</em> linear network,
and returns the matrix whose <code>[i,j]</code> entry is the
shortest-path distance from <code>X[i]</code> to <code>Y[j]</code>.
</p>
<p>If two points cannot be joined by a path,
the distance between them is infinite (<code>Inf</code>).
</p>
<p>The argument <code>method</code> is not normally used. It is
retained only for developers to check the validity of the software.
</p>


<h3>Value</h3>

<p>A matrix whose <code>[i,j]</code> entry is the distance
from the <code>i</code>-th point in <code>X</code>
to the <code>j</code>-th point in <code>Y</code>.
Matrix entries are nonnegative numbers or infinity (<code>Inf</code>).
</p>


<h3>Algorithms and accuracy</h3>

<p>Distances are accurate within the numerical tolerance of the
network, <code>summary(X)$toler</code>.
</p>
<p>For network data stored in the non-sparse
representation described in <code><a href="#topic+linnet">linnet</a></code>,
then pairwise distances are computed using the matrix of path distances
between vertices of the network, using <span class="rlang"><b>R</b></span> code if
<code>method = "interpreted"</code>, or using C code if 
<code>method="C"</code> (the default).
</p>
<p>For networks stored in the sparse representation,
the argument <code>method</code> has no effect, and the distances are
computed using an efficient C algorithm.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.geom.html#topic+crossdist">crossdist</a></code>,
<code><a href="spatstat.geom.html#topic+crossdist.ppp">crossdist.ppp</a></code>,
<code><a href="spatstat.geom.html#topic+pairdist">pairdist</a></code>,
<code><a href="spatstat.geom.html#topic+nndist">nndist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   v &lt;- split(chicago)
   X &lt;- v$cartheft
   Y &lt;- v$burglary
   d &lt;- crossdist(X, Y)
   d[1:3,1:4]
</code></pre>

<hr>
<h2 id='crossing.linnet'>
Crossing Points between Linear Network and Other Lines
</h2><span id='topic+crossing.linnet'></span>

<h3>Description</h3>

<p>Find all the crossing-points between
a linear network and another pattern of lines or line segments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crossing.linnet(X, Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crossing.linnet_+3A_x">X</code></td>
<td>

<p>Linear network (object of class <code>"linnet"</code>).
</p>
</td></tr>
<tr><td><code id="crossing.linnet_+3A_y">Y</code></td>
<td>

<p>A linear network, or a spatial pattern of line segments (class <code>"psp"</code>)
or infinite lines (class <code>"infline"</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All crossing-points between <code>X</code> and <code>Y</code>
are determined. The result is a point pattern on the network <code>X</code>.
</p>


<h3>Value</h3>

<p>Point pattern on a linear network (object of class <code>"lpp"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.geom.html#topic+crossing.psp">crossing.psp</a></code>

</p>


<h3>Examples</h3>

<pre><code class='language-R'>   plot(simplenet, main="")
   L &lt;- infline(p=runif(3), theta=runif(3, max=pi/2))
   plot(L, col="red")
   Y &lt;- crossing.linnet(simplenet, L)
   plot(Y, add=TRUE, cols="blue")
</code></pre>

<hr>
<h2 id='cut.lpp'>Classify Points in a Point Pattern on a Network</h2><span id='topic+cut.lpp'></span>

<h3>Description</h3>

<p>For a point pattern on a linear network, 
classify the points into distinct types
according to the numerical marks in the pattern, or according to
another variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'lpp'
cut(x, z=marks(x), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cut.lpp_+3A_x">x</code></td>
<td>

<p>A point pattern on a linear network
(object of class <code>"lpp"</code>).
</p>
</td></tr>
<tr><td><code id="cut.lpp_+3A_z">z</code></td>
<td>

<p>Data determining the classification. A numeric vector,
a factor, a pixel image on a linear network (class <code>"linim"</code>),
a function on a linear network (class <code>"linfun"</code>),
a tessellation on a linear network (class <code>"lintess"</code>), a string
giving the name of a column of marks, or one of the coordinate
names <code>"x"</code>, <code>"y"</code>, <code>"seg"</code> or <code>"tp"</code>.
</p>
</td></tr>
<tr><td><code id="cut.lpp_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="base.html#topic+cut.default">cut.default</a></code>.
They determine the breakpoints for the mapping from numerical values
in <code>z</code> to factor values in the output.
See <code><a href="base.html#topic+cut.default">cut.default</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function has the effect of classifying each point in the point
pattern <code>x</code> into one of several possible types. The
classification is based on the dataset <code>z</code>, which may be either
</p>

<ul>
<li>
<p>a factor (of length equal to the number of points in <code>z</code>)
determining the classification of each point in <code>x</code>.
Levels of the factor determine the classification.
</p>
</li>
<li>
<p>a numeric vector (of length equal to the number of points in
<code>z</code>). The range of values of <code>z</code> will be divided into
bands (the number of bands is determined by <code>...</code>)
and <code>z</code> will be converted to a factor using
<code><a href="base.html#topic+cut.default">cut.default</a></code>.
</p>
</li>
<li>
<p>a pixel image on a network (object of class <code>"linim"</code>).
The value of <code>z</code> at each point of <code>x</code> will be
used as the classifying variable.
</p>
</li>
<li>
<p>a function on a network (object of class <code>"linfun"</code>, see
<code><a href="#topic+linfun">linfun</a></code>). 
The value of <code>z</code> at each point of <code>x</code> will be
used as the classifying variable.
</p>
</li>
<li>
<p>a tessellation on a network (object of class <code>"lintess"</code>, see
<code><a href="#topic+lintess">lintess</a></code>). Each point of <code>x</code> will be classified
according to the tile of the tessellation into which it falls.
</p>
</li>
<li>
<p>a character string, giving the name of one of the columns
of <code>marks(x)</code>, if this is a data frame.
</p>
</li>
<li>
<p>a character string identifying one of the coordinates:
the spatial coordinates
<code>"x"</code>, <code>"y"</code> or the segment identifier <code>"seg"</code>
or the fractional coordinate along the segment, <code>"tp"</code>.
</p>
</li></ul>

<p>The default is to take <code>z</code> to be the vector of marks in
<code>x</code> (or the first column in the data frame of marks of <code>x</code>,
if it is a data frame). If the marks are numeric, then the range of values
of the numerical marks is divided into several intervals, and each
interval is associated with a level of a factor. 
The result is a
marked point pattern, on the same linear network,
with the same point locations as
<code>x</code>, but with the numeric mark of each point discretised
by replacing it by the factor level.
This is a convenient way to transform a marked point pattern
which has numeric marks into a multitype point pattern,
for example to plot it or analyse it. See the examples.
</p>
<p>To select some points from <code>x</code>, use the subset operators
<code><a href="#topic++5B.lpp">[.lpp</a></code> or <code><a href="#topic+subset.lpp">subset.lpp</a></code> instead.
</p>


<h3>Value</h3>

<p>A multitype point pattern on the same linear network,
that is, a point pattern object
(of class <code>"lpp"</code>) with a <code>marks</code> vector that is a factor.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+cut">cut</a></code>,
<code><a href="#topic+lpp">lpp</a></code>,
<code><a href="#topic+lintess">lintess</a></code>,
<code><a href="#topic+linfun">linfun</a></code>,
<code><a href="#topic+linim">linim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- runiflpp(20, simplenet)
  f &lt;- linfun(function(x,y,seg,tp) { x }, simplenet)
  plot(cut(X, f, breaks=4))
  plot(cut(X, "x", breaks=4))
  plot(cut(X, "seg"))
</code></pre>

<hr>
<h2 id='data.lppm'>Extract Original Data from a Fitted Point Process Model on a Network</h2><span id='topic+data.lppm'></span>

<h3>Description</h3>

<p>Given a fitted point process model on a linear network,
this function extracts the original point pattern dataset 
to which the model was fitted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  data.lppm(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data.lppm_+3A_object">object</code></td>
<td>

<p>fitted point process model
on a linear network (an object of class <code>"lppm"</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object of class <code>"lppm"</code> represents a point process model
that has been fitted to a point pattern dataset on a linear network.
It is typically produced by
the model-fitting algorithm <code><a href="#topic+lppm">lppm</a></code>.
The object contains complete information about the original data
point pattern to which the model was fitted.
This function extracts the original data pattern.
</p>


<h3>Value</h3>

<p>A point pattern on a linear network (object of class <code>"lpp"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lppm">lppm</a></code>,
<code><a href="spatstat.model.html#topic+data.ppm">data.ppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> fit &lt;- lppm(spiders ~ x)
 X &lt;- data.lppm(fit)
 # 'X' is identical to 'spiders'
</code></pre>

<hr>
<h2 id='delaunayNetwork'>
Linear Network of Delaunay Triangulation or Dirichlet Tessellation
</h2><span id='topic+delaunayNetwork'></span><span id='topic+dirichletNetwork'></span>

<h3>Description</h3>

<p>Computes the edges of the Delaunay triangulation
or Dirichlet tessellation of a point pattern,
and returns the result as a linear network object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delaunayNetwork(X)

dirichletNetwork(X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delaunayNetwork_+3A_x">X</code></td>
<td>
<p>A point pattern (object of class <code>"ppp"</code>).</p>
</td></tr>
<tr><td><code id="delaunayNetwork_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+as.linnet.psp">as.linnet.psp</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>delaunayNetwork</code>, points of <code>X</code> which are neighbours
in the Delaunay triangulation
(see <code><a href="spatstat.geom.html#topic+delaunay">delaunay</a></code>) will be joined by a straight line.
The result will be returned as a linear network (object of class
<code>"linnet"</code>).
</p>
<p>For <code>dirichletNetwork</code>, the Dirichlet tessellation is computed
(see <code><a href="spatstat.geom.html#topic+dirichlet">dirichlet</a></code>) and the edges of the
tiles of the tessellation are extracted. This is converted to a linear
network using <code><a href="#topic+as.linnet.psp">as.linnet.psp</a></code>.
</p>


<h3>Value</h3>

<p>Linear network (object of class <code>"linnet"</code>)
or <code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.geom.html#topic+delaunay">delaunay</a></code>,
<code><a href="spatstat.geom.html#topic+dirichlet">dirichlet</a></code>,
<code><a href="spatstat.geom.html#topic+delaunayDistance">delaunayDistance</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  LE &lt;- delaunayNetwork(cells)
  LI &lt;- dirichletNetwork(cells)
</code></pre>

<hr>
<h2 id='deletebranch'>
Delete or Extract a Branch of a Tree
</h2><span id='topic+deletebranch'></span><span id='topic+deletebranch.linnet'></span><span id='topic+deletebranch.lpp'></span><span id='topic+extractbranch'></span><span id='topic+extractbranch.linnet'></span><span id='topic+extractbranch.lpp'></span>

<h3>Description</h3>

<p>Deletes or extracts a given branch of a tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deletebranch(X, ...)

## S3 method for class 'linnet'
deletebranch(X, code, labels, ...)

## S3 method for class 'lpp'
deletebranch(X, code, labels, ...)

extractbranch(X, ...)

## S3 method for class 'linnet'
extractbranch(X, code, labels, ..., which=NULL)

## S3 method for class 'lpp'
extractbranch(X, code, labels, ..., which=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deletebranch_+3A_x">X</code></td>
<td>

<p>Linear network (object of class <code>"linnet"</code>)
or point pattern on a linear network (object of class <code>"lpp"</code>).
</p>
</td></tr>
<tr><td><code id="deletebranch_+3A_code">code</code></td>
<td>

<p>Character string. Label of the branch to be deleted or extracted.
</p>
</td></tr>
<tr><td><code id="deletebranch_+3A_labels">labels</code></td>
<td>

<p>Vector of character strings. Branch labels for the
vertices of the network, usually obtained from
<code><a href="#topic+treebranchlabels">treebranchlabels</a></code>.
</p>
</td></tr>
<tr><td><code id="deletebranch_+3A_...">...</code></td>
<td>
<p>Arguments passed to methods.</p>
</td></tr>
<tr><td><code id="deletebranch_+3A_which">which</code></td>
<td>

<p>Logical vector indicating which vertices of the network
should be extracted. Overrides <code>code</code> and <code>labels</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The linear network <code>L &lt;- X</code> or <code>L &lt;- as.linnet(X)</code>
must be a tree, that is, it has no loops.
</p>
<p>The argument <code>labels</code> should be a character vector
giving tree branch labels for each vertex of the network.
It is usually obtained by calling <code><a href="#topic+treebranchlabels">treebranchlabels</a></code>.
</p>
<p>The branch designated by the string <code>code</code> will be deleted
or extracted.
</p>
<p>The return value is the result of deleting or extracting
this branch from <code>X</code>
along with any data associated with this branch (such as points or marks).
</p>


<h3>Value</h3>

<p>Another object of the same type as <code>X</code>
obtained by deleting or extracting the specified branch.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+treebranchlabels">treebranchlabels</a></code>,
<code><a href="#topic+branchlabelfun">branchlabelfun</a></code>,
<code><a href="#topic+linnet">linnet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # make a simple tree
  m &lt;- simplenet$m
  m[8,10] &lt;- m[10,8] &lt;- FALSE
  L &lt;- linnet(vertices(simplenet), m)
  plot(L, main="")
  # compute branch labels 
  tb &lt;- treebranchlabels(L, 1)
  tbc &lt;- paste0("[", tb, "]")
  text(vertices(L), labels=tbc, cex=2)

  # delete branch B
  LminusB &lt;- deletebranch(L, "b", tb)
  plot(LminusB, add=TRUE, col="green")

  # extract branch B
  LB &lt;- extractbranch(L, "b", tb)
  plot(LB, add=TRUE, col="red")
</code></pre>

<hr>
<h2 id='density.linnet'>Kernel Smoothing of Linear Network</h2><span id='topic+density.linnet'></span>

<h3>Description</h3>

<p>Compute a kernel smoothed intensity function for
the line segments of a linear network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'linnet'
density(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="density.linnet_+3A_x">x</code></td>
<td>

<p>Linear network (object of class <code>"linnet"</code>)
</p>
</td></tr>
<tr><td><code id="density.linnet_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="spatstat.explore.html#topic+density.psp">density.psp</a></code>
to control the amount of smoothing and the spatial resolution
of the result.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the method for the generic function <code><a href="stats.html#topic+density">density</a></code>
for the class <code>"linnet"</code> (linear networks).
</p>
<p>The network <code>x</code> is first converted to a line segment pattern
(object of class <code>"psp"</code>). Then the method
<code><a href="spatstat.explore.html#topic+density.psp">density.psp</a></code> is applied to the
segment pattern.
</p>
<p>A kernel estimate of the intensity of the line segment pattern
is computed. The result is 
the convolution of the isotropic Gaussian kernel, of
standard deviation <code>sigma</code>, with the line segments.
</p>
<p>The intensity of a line segment pattern
is the (spatially-varying) amount of segment length per unit area,
expressed in the same units as the coordinates of <code>x</code>.
If the units of <code>x</code> are in metres, then an intensity value of 3
means that there are 3 metres of segment length per square metre of
spatial domain.
</p>
<p>See <code><a href="spatstat.explore.html#topic+density.psp">density.psp</a></code>
for more details.
</p>


<h3>Value</h3>

<p>A pixel image in two dimensions (object of class <code>"im"</code>)
or a numeric vector.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.explore.html#topic+density.psp">density.psp</a></code>,
<code><a href="spatstat.geom.html#topic+im.object">im.object</a></code>,
<code><a href="stats.html#topic+density">density</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  D &lt;- density(simplenet, 0.1)
  plot(D)
  plot(simplenet, add=TRUE, col="white")
  ## compare with average intensity
  volume(simplenet)/area(Window(simplenet))
</code></pre>

<hr>
<h2 id='density.lpp'>
Kernel Estimate of Intensity on a Linear Network
</h2><span id='topic+density.lpp'></span><span id='topic+density.splitppx'></span>

<h3>Description</h3>

<p>Estimates the intensity of a point process on a linear network
by applying kernel smoothing to the point pattern data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpp'
density(x, sigma=NULL, ...,
        weights=NULL,
        distance=c("path", "euclidean"),
        continuous=TRUE,
        kernel="gaussian")

## S3 method for class 'splitppx'
density(x, sigma=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="density.lpp_+3A_x">x</code></td>
<td>

<p>Point pattern on a linear network (object of class <code>"lpp"</code>)
to be smoothed.
</p>
</td></tr>
<tr><td><code id="density.lpp_+3A_sigma">sigma</code></td>
<td>

<p>Smoothing bandwidth (standard deviation of the kernel).
A single numerical value
in the same units as the spatial coordinates of <code>x</code>.
Alternatively <code>sigma</code> may be a function which selects a
bandwidth when applied to <code>X</code>,
for example, <code><a href="spatstat.explore.html#topic+bw.scott.iso">bw.scott.iso</a></code> or <code><a href="#topic+bw.lppl">bw.lppl</a></code>.
There is a sensible default.
</p>
</td></tr>
<tr><td><code id="density.lpp_+3A_...">...</code></td>
<td>

<p>Additional arguments controlling the algorithm
and the spatial resolution of the result.
These arguments are passed either to
<code><a href="#topic+densityQuick.lpp">densityQuick.lpp</a></code>, <code><a href="#topic+densityHeat.lpp">densityHeat.lpp</a></code>
or <code><a href="#topic+densityEqualSplit">densityEqualSplit</a></code> depending on the algorithm chosen.
</p>
</td></tr>
<tr><td><code id="density.lpp_+3A_weights">weights</code></td>
<td>

<p>Optional. Numeric vector of weights associated with the
points of <code>x</code>. Weights may be positive, negative or zero.
</p>
</td></tr>
<tr><td><code id="density.lpp_+3A_distance">distance</code></td>
<td>

<p>Character string (partially matched) specifying whether to use
a kernel based on paths in the network (<code>distance="path"</code>, the default)
or a two-dimensional kernel (<code>distance="euclidean"</code>). 
</p>
</td></tr>
<tr><td><code id="density.lpp_+3A_kernel">kernel</code></td>
<td>

<p>Character string specifying the smoothing kernel.
See <code><a href="spatstat.explore.html#topic+dkernel">dkernel</a></code> for possible options.
</p>
</td></tr>
<tr><td><code id="density.lpp_+3A_continuous">continuous</code></td>
<td>

<p>Logical value indicating whether to compute the
&ldquo;equal-split continuous&rdquo; smoother (<code>continuous=TRUE</code>, the
default) or the &ldquo;equal-split discontinuous&rdquo; smoother
(<code>continuous=FALSE</code>). Applies only when <code>distance="path"</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Kernel smoothing is applied to the points of <code>x</code>
using either a kernel based on path distances in the network,
or a two-dimensional kernel.
The result is a pixel image on the linear network (class
<code>"linim"</code>) which can be plotted.
</p>

<ul>
<li><p> If <code>distance="path"</code> (the default)
then the smoothing is performed
using a kernel based on path distances in the network, as described in
described in Okabe and Sugihara (2012) and McSwiggan et al (2016).
</p>

<ul>
<li>
<p>If <code>continuous=TRUE</code> (the default), smoothing is performed
using the &ldquo;equal-split continuous&rdquo; rule described in
Section 9.2.3 of Okabe and Sugihara (2012).
The resulting function is continuous on the linear network.
</p>
</li>
<li>
<p>If <code>continuous=FALSE</code>, smoothing is performed
using the &ldquo;equal-split discontinuous&rdquo; rule described in
Section 9.2.2 of Okabe and Sugihara (2012). The
resulting function is continuous except at the network vertices.
</p>
</li>
<li>
<p>In the default case
(where <code>distance="path"</code> and
<code>continuous=TRUE</code> and <code>kernel="gaussian"</code>,
computation is performed rapidly by solving the classical heat equation
on the network, as described in McSwiggan et al (2016).
The arguments are passed to <code><a href="#topic+densityHeat.lpp">densityHeat.lpp</a></code> which performs
the computation.
Computational time is short, but increases quadratically
with <code>sigma</code>.
</p>
</li>
<li>
<p>In all other cases, computation is performed by path-tracing
as described in Okabe and Sugihara (2012);
the arguments are passed to <code><a href="#topic+densityEqualSplit">densityEqualSplit</a></code>
which performs the computation.
Computation time can be extremely long, and
increases exponentially with <code>sigma</code>.
</p>
</li></ul>

</li>
<li><p> If <code>distance="euclidean"</code>, the smoothing is performed
using a two-dimensional kernel. The arguments are passed to
<code><a href="#topic+densityQuick.lpp">densityQuick.lpp</a></code> to perform the computation.
Computation time is very short.
See the help for <code><a href="#topic+densityQuick.lpp">densityQuick.lpp</a></code> for further details.
</p>
</li></ul>

<p>There is also a method for split point patterns on a linear network
(class <code>"splitppx"</code>) which will return a list of pixel images.
</p>
<p>The argument <code>sigma</code> specifies the smoothing bandwidth.
If <code>sigma</code> is missing or <code>NULL</code>,
the default is one-eighth of the length of the shortest side
of the bounding box of <code>x</code>.
If <code>sigma</code> is a function in the <span class="rlang"><b>R</b></span> language, it is assumed
to be a bandwidth selection rule, and it will be applied to <code>x</code>
to compute the bandwidth value.
</p>


<h3>Value</h3>

<p>A pixel image on the linear network (object of class <code>"linim"</code>),
or in some cases, a numeric vector of length equal to <code>npoints(x)</code>.
</p>


<h3>Infinite bandwidth</h3>

<p>If <code>sigma=Inf</code>, the resulting density estimate is 
constant over all locations,
and is equal to the average density of points per unit length.
(If the network is not connected, then this rule
is applied separately to each connected component of the network).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a> and Greg McSwiggan.
</p>


<h3>References</h3>

<p>McSwiggan, G., Baddeley, A. and Nair, G. (2016)
Kernel density estimation on a linear network.
<em>Scandinavian Journal of Statistics</em> <b>44</b>, 324&ndash;345.
</p>
<p>Okabe, A. and Sugihara, K. (2012)
<em>Spatial analysis along networks</em>.
Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lpp">lpp</a></code>,
<code><a href="#topic+linim">linim</a></code>,
<code><a href="#topic+densityQuick.lpp">densityQuick.lpp</a></code>,
<code><a href="#topic+densityHeat.lpp">densityHeat.lpp</a></code>,
<code><a href="#topic+densityVoronoi.lpp">densityVoronoi.lpp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- runiflpp(3, simplenet)
  D &lt;- density(X, 0.2, verbose=FALSE)
  plot(D, style="w", main="", adjust=2)
  Dq &lt;- density(X, 0.2, distance="euclidean")
  plot(Dq, style="w", main="", adjust=2)
  Dw &lt;- density(X, 0.2, weights=c(1,2,-1), verbose=FALSE)
  De &lt;- density(X, 0.2, kernel="epanechnikov", verbose=FALSE)
  Ded &lt;- density(X, 0.2, kernel="epanechnikov", continuous=FALSE, verbose=FALSE)
</code></pre>

<hr>
<h2 id='densityEqualSplit'>
Equal-Split Algorithm for Kernel Density on a Network
</h2><span id='topic+densityEqualSplit'></span>

<h3>Description</h3>

<p>Computes a kernel density estimate on a linear network
using the Okabe-Sugihara equal-split algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> densityEqualSplit(x, sigma = NULL, ...,
                   at = c("pixels", "points"),
                   leaveoneout=TRUE,
                   weights = NULL,
                   kernel = "epanechnikov", continuous = TRUE,
                   epsilon = 1e-06, verbose = TRUE, debug = FALSE, savehistory = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="densityEqualSplit_+3A_x">x</code></td>
<td>

<p>Point pattern on a linear network (object of class <code>"lpp"</code>)
to be smoothed.
</p>
</td></tr>
<tr><td><code id="densityEqualSplit_+3A_sigma">sigma</code></td>
<td>

<p>Smoothing bandwidth (standard deviation of the kernel).
A numeric value in the same units as the spatial coordinates of <code>x</code>.
Alternatively <code>sigma</code> may be a function which selects a
bandwidth when applied to <code>X</code>,
for example, <code><a href="spatstat.explore.html#topic+bw.scott.iso">bw.scott.iso</a></code> or <code><a href="#topic+bw.lppl">bw.lppl</a></code>.
There is a sensible default.
</p>
</td></tr>
<tr><td><code id="densityEqualSplit_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="grid.html#topic+as.mask">as.mask</a></code> determining the
resolution of the result.
</p>
</td></tr>
<tr><td><code id="densityEqualSplit_+3A_at">at</code></td>
<td>

<p>String (partially matched)
specifying whether to compute the intensity values
at a fine grid of locations on the network
(<code>at="pixels"</code>, the default) or
only at the points of <code>x</code> (<code>at="points"</code>).
</p>
</td></tr>
<tr><td><code id="densityEqualSplit_+3A_leaveoneout">leaveoneout</code></td>
<td>

<p>Logical value indicating whether to compute a leave-one-out
estimator. Applicable only when <code>at="points"</code>.
</p>
</td></tr>
<tr><td><code id="densityEqualSplit_+3A_weights">weights</code></td>
<td>

<p>Optional. Numeric vector of weights associated with the
points of <code>x</code>. Weights may be positive, negative or zero.
</p>
</td></tr>
<tr><td><code id="densityEqualSplit_+3A_kernel">kernel</code></td>
<td>

<p>Character string specifying the smoothing kernel.
See <code><a href="spatstat.explore.html#topic+dkernel">dkernel</a></code> for possible options.
</p>
</td></tr>
<tr><td><code id="densityEqualSplit_+3A_continuous">continuous</code></td>
<td>

<p>Logical value indicating whether to compute the
&ldquo;equal-split continuous&rdquo; smoother (<code>continuous=TRUE</code>, the
default) or the &ldquo;equal-split discontinuous&rdquo; smoother
(<code>continuous=FALSE</code>). 
</p>
</td></tr>
<tr><td><code id="densityEqualSplit_+3A_epsilon">epsilon</code></td>
<td>

<p>Tolerance value. A tail of the kernel with total mass
less than <code>epsilon</code> may be deleted.
</p>
</td></tr>
<tr><td><code id="densityEqualSplit_+3A_verbose">verbose</code></td>
<td>

<p>Logical value indicating whether to print progress reports.
</p>
</td></tr>
<tr><td><code id="densityEqualSplit_+3A_debug">debug</code></td>
<td>

<p>Logical value indicating whether to print debugging information.
</p>
</td></tr>
<tr><td><code id="densityEqualSplit_+3A_savehistory">savehistory</code></td>
<td>

<p>Logical value indicating whether to save the entire history of the
algorithm, for the purposes of evaluating performance.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Kernel smoothing is applied to the points of <code>x</code>
using a kernel based on path distances in the network.
The result is a pixel image on the linear network (class
<code>"linim"</code>) which can be plotted.
</p>
<p>Smoothing is performed using one of the &ldquo;equal-split&rdquo; rules described in
Okabe and Sugihara (2012).
</p>

<ul>
<li>
<p>If <code>continuous=TRUE</code> (the default), smoothing is performed
using the &ldquo;equal-split continuous&rdquo; rule described in
Section 9.2.3 of Okabe and Sugihara (2012).
The resulting function is continuous on the linear network.
</p>
</li>
<li>
<p>If <code>continuous=FALSE</code>, smoothing is performed
using the &ldquo;equal-split discontinuous&rdquo; rule described in
Section 9.2.2 of Okabe and Sugihara (2012). The
resulting function is not continuous.
</p>
</li></ul>

<p>Computation is performed by path-tracing
as described in Okabe and Sugihara (2012).
</p>
<p>It is advisable to choose a kernel with bounded support
such as <code>kernel="epanechnikov"</code>.
With a Gaussian kernel, computation time can be long, and
increases exponentially with <code>sigma</code>.
</p>
<p>Faster algorithms are available through <code><a href="#topic+density.lpp">density.lpp</a></code>.
</p>
<p>The argument <code>sigma</code> specifies the smoothing bandwidth.
If <code>sigma</code> is missing or <code>NULL</code>,
the default is one-eighth of the length of the shortest side
of the bounding box of <code>x</code>.
If <code>sigma</code> is a function in the <span class="rlang"><b>R</b></span> language, it is assumed
to be a bandwidth selection rule, and it will be applied to <code>x</code>
to compute the bandwidth value.
</p>


<h3>Value</h3>

<p>If <code>at="pixels"</code> (the default),
a pixel image on the linear network (object of class <code>"linim"</code>).
</p>
<p>If <code>at="points"</code>, a numeric vector with one entry for each point
of <code>x</code>.
</p>


<h3>Infinite bandwidth</h3>

<p>If <code>sigma=Inf</code>, the resulting density estimate is 
constant over all locations,
and is equal to the average density of points per unit length.
(If the network is not connected, then this rule
is applied separately to each connected component of the network).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a> and Greg McSwiggan.
</p>


<h3>References</h3>

<p>Okabe, A. and Sugihara, K. (2012)
<em>Spatial analysis along networks</em>.
Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+density.lpp">density.lpp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- runiflpp(3, simplenet)
  De &lt;- density(X, 0.2, kernel="epanechnikov", verbose=FALSE)
  Ded &lt;- density(X, 0.2, kernel="epanechnikov", continuous=FALSE, verbose=FALSE)
</code></pre>

<hr>
<h2 id='densityfun.lpp'>
Kernel Estimate of Intensity on a Linear Network as a Spatial Function
</h2><span id='topic+densityfun.lpp'></span>

<h3>Description</h3>

<p>Computes a kernel estimate of the intensity of a point process on a linear
network, and returns the intensity estimate as a function of spatial location.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpp'
densityfun(X, sigma, ..., weights=NULL, nsigma=1, verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="densityfun.lpp_+3A_x">X</code></td>
<td>

<p>Point pattern on a linear network
(object of class <code>"lpp"</code>).
</p>
</td></tr>
<tr><td><code id="densityfun.lpp_+3A_sigma">sigma</code></td>
<td>

<p>Bandwidth of kernel (standard deviation of Gaussian kernel),
in the same units of length as <code>X</code>.
</p>
</td></tr>
<tr><td><code id="densityfun.lpp_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+density.lpp">density.lpp</a></code> to control
the discretisation.
</p>
</td></tr>
<tr><td><code id="densityfun.lpp_+3A_weights">weights</code></td>
<td>

<p>Optional numeric vector of weights associated
with the points of <code>X</code>.
</p>
</td></tr>
<tr><td><code id="densityfun.lpp_+3A_nsigma">nsigma</code></td>
<td>

<p>Integer. The number of different bandwidths for which a result
should be returned.
If <code>nsigma=1</code> (the default), the result is a function giving
kernel estimate with bandwidth <code>sigma</code>. If <code>nsigma &gt; 1</code>,
the result is a function with an additional argument <code>k</code>
containing the kernel estimates for the <code>nsigma+1</code>
equally-spaced time steps from <code>0</code> to <code>sigma^2</code>.
</p>
</td></tr>
<tr><td><code id="densityfun.lpp_+3A_verbose">verbose</code></td>
<td>

<p>Logical value indicating whether to print progress reports.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Kernel smoothing is applied to the points of <code>X</code>
using the diffusion algorithm of McSwiggan et al (2016).
The result is a function on the linear network
(object of class <code>"linfun"</code>) that can be printed, plotted
and evaluated at any location. 
</p>
<p>This is a method for the generic function
<code><a href="spatstat.explore.html#topic+densityfun">densityfun</a></code> for the class
<code>"lpp"</code> of point patterns on a linear network.
</p>


<h3>Value</h3>

<p>Function on a linear network (object of class <code>"linfun"</code>).
</p>
<p>If <code>nsigma=1</code> (the default), the result is a function giving
kernel estimate with bandwidth <code>sigma</code>.
</p>
<p>If <code>nsigma &gt; 1</code>, the result is a function
with an additional argument <code>k</code>. If <code>k</code> is specified,
the function returns the kernel estimate for
bandwidth <code>tau = sigma * sqrt(k/nsigma)</code>.
If <code>k</code> is not specified, results are returned
for all <code>k = 1, 2, ..., nsigma</code>.
</p>
<p>The result also has attributes
</p>

<ul>
<li> <p><code>attr(result, "dt")</code> giving the
time step <code class="reqn">\Delta t</code>;
</p>
</li>
<li> <p><code>attr(result, "dx")</code> giving the spacing <code class="reqn">\Delta x</code>
between sample points in the numerical algorithm;
</p>
</li>
<li> <p><code>attr(result, "sigma")</code>
giving the smoothing bandwidth <code class="reqn">\sigma</code> used
(or the successive bandwidths used at each sampled time step,
if <code>nsigma &gt; 1</code>).
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Greg McSwiggan, with tweaks by Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>McSwiggan, G., Baddeley, A. and Nair, G. (2016)
Kernel Density Estimation on a Linear Network.
<em>Scandinavian Journal of Statistics</em> <b>44</b>, 324&ndash;345.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+density.lpp">density.lpp</a></code> which returns a pixel image
on the linear network.
</p>
<p><code><a href="#topic+methods.linfun">methods.linfun</a></code> for methods applicable to
<code>"linfun"</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- unmark(chicago)
  # single bandwidth
  g &lt;- densityfun(X, 30)
  plot(g)
  Y &lt;- X[1:5]
  g(Y)
  # weighted
  gw &lt;- densityfun(X, 30, weights=runif(npoints(X)))
  # sequence of bandwidths 
  g10 &lt;- densityfun(X, 30, nsigma=10)
  g10(Y, k=10)
  g10(Y)
  plot(as.linim(g10, k=5))
</code></pre>

<hr>
<h2 id='densityHeat.lpp'>
Kernel Density on a Network using Heat Equation
</h2><span id='topic+densityHeat.lpp'></span>

<h3>Description</h3>

<p>Given a point pattern on a linear network,
compute a kernel estimate of intensity,
by solving the heat equation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'lpp'
densityHeat(x, sigma=NULL, ...,
              at=c("pixels", "points"), leaveoneout=TRUE,
              weights = NULL,
              dx = NULL, dt = NULL, iterMax = 1e+06,
              finespacing = TRUE, verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="densityHeat.lpp_+3A_x">x</code></td>
<td>

<p>Point pattern on a linear network (object of class <code>"lpp"</code>)
to be smoothed.
</p>
</td></tr>
<tr><td><code id="densityHeat.lpp_+3A_sigma">sigma</code></td>
<td>

<p>Smoothing bandwidth (standard deviation of the kernel).
A numeric value in the same units as the spatial coordinates of <code>x</code>.
Alternatively <code>sigma</code> may be a function which selects a
bandwidth when applied to <code>X</code>,
for example, <code><a href="spatstat.explore.html#topic+bw.scott.iso">bw.scott.iso</a></code> or <code><a href="#topic+bw.lppl">bw.lppl</a></code>.
There is a sensible default.
</p>
</td></tr>
<tr><td><code id="densityHeat.lpp_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="grid.html#topic+as.mask">as.mask</a></code> determining the
resolution of the result. (Any other arguments are ignored.)
</p>
</td></tr>
<tr><td><code id="densityHeat.lpp_+3A_at">at</code></td>
<td>

<p>String specifying whether to compute the intensity values
at a fine grid of pixel locations on the network
(<code>at="pixels"</code>, the default) or
only at the data points of <code>x</code> (<code>at="points"</code>).
</p>
</td></tr>
<tr><td><code id="densityHeat.lpp_+3A_leaveoneout">leaveoneout</code></td>
<td>

<p>Logical value indicating whether to compute a leave-one-out
estimator. Applicable only when <code>at="points"</code>.
</p>
</td></tr>
<tr><td><code id="densityHeat.lpp_+3A_weights">weights</code></td>
<td>

<p>Optional. Numeric vector of weights associated with the
points of <code>x</code>. Weights may be positive, negative or zero.
</p>
</td></tr>
<tr><td><code id="densityHeat.lpp_+3A_dx">dx</code></td>
<td>

<p>Optional. Spacing of the sampling points along the network.
A single number giving a distance value in the same units as <code>x</code>.
</p>
</td></tr>
<tr><td><code id="densityHeat.lpp_+3A_dt">dt</code></td>
<td>

<p>Optional. Time step in the heat equation solver.
A single number. 
</p>
</td></tr>
<tr><td><code id="densityHeat.lpp_+3A_itermax">iterMax</code></td>
<td>

<p>Maximum number of iterations.
</p>
</td></tr>
<tr><td><code id="densityHeat.lpp_+3A_finespacing">finespacing</code></td>
<td>

<p>Logical value specifying whether the discrete approximation is
required to be accurate along every segment of the network,
no matter how short the segment is. See the section on Discretisation.
</p>
</td></tr>
<tr><td><code id="densityHeat.lpp_+3A_verbose">verbose</code></td>
<td>

<p>Logical value specifying whether to print progress reports.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="spatstat.explore.html#topic+densityHeat">densityHeat</a></code> is generic.
This is the method for the class <code>"lpp"</code> of points on a linear
network.
</p>
<p>Kernel smoothing is applied to the points of <code>x</code>
using a kernel based on path distances in the network.
If <code>at="pixels"</code> (the default),
the result is a pixel image on the linear network (class
<code>"linim"</code>) which can be plotted.
If <code>at="points"</code> the result is a numeric vector giving the
density estimates at the data points of <code>x</code>. 
</p>
<p>The smoothing operation is equivalent to the
&ldquo;equal-split continuous&rdquo; rule described in
Section 9.2.3 of Okabe and Sugihara (2012).
However, the actual computation is performed rapidly, by solving the classical
time-dependent heat equation on the network,
as described in McSwiggan et al (2016).
Computational time is short, but increases quadratically with
<code>sigma</code>.
</p>
<p>If <code>at="points"</code> and <code>leaveoneout=TRUE</code>, 
a leave-one-out estimate is computed at each data point
(that is, the estimate at each data point <code>x[i]</code> is based
on all of the points except <code>x[i]</code>)
using the truncated series approximation
of McSwiggan et al (2019).
</p>
<p>The argument <code>sigma</code> specifies the smoothing bandwidth.
If <code>sigma</code> is missing or <code>NULL</code>,
the default is one-eighth of the length of the shortest side
of the bounding box of <code>x</code>.
If <code>sigma</code> is a function in the <span class="rlang"><b>R</b></span> language, it is assumed
to be a bandwidth selection rule, and it will be applied to <code>x</code>
to compute the bandwidth value.
</p>


<h3>Value</h3>

<p>If <code>at="pixels"</code> (the default),
a pixel image on the linear network (object of class <code>"linim"</code>).
</p>
<p>If <code>at="points"</code>, a numeric vector with one entry for each point
of <code>x</code>.
</p>


<h3>Infinite bandwidth</h3>

<p>If <code>sigma=Inf</code>, the resulting density estimate is 
constant over all locations,
and is equal to the average density of points per unit length.
(If the network is not connected, then this rule
is applied separately to each connected component of the network).
</p>


<h3>Discretisation and Error Messages</h3>

<p>The arguments <code>dx</code>, <code>dt</code> and <code>iterMax</code>
determine the discretisation of the network, according to
a set of rules. The argument <code>finespacing</code> determines
which rule will be applied. 
</p>
<p>The arguments <code>dx</code>, <code>dt</code>, <code>iterMax</code>
are connected by several constraints; specifying one of these
arguments will affect the default values of the other two arguments.
</p>
<p>The argument <code>finespacing</code> specifies whether
a very fine spacing of sample points is required, in order to attain
hihg accuracy.
</p>

<ul>
<li>
<p>If <code>finespacing=TRUE</code> (the default), then the
sample point spacing <code>dx</code> must not exceed
one-third of the length of the shortest
segment of the network. This ensures that the discrete approximation
is accurate along every segment, no matter how short the segment
is. However, this may not be feasible
if it implies a very large number of sample points, or a large number
of iterations: in such cases, the code may terminate with an error
about illegal values of <code>dx</code>, <code>dt</code> or <code>iterMax</code>.
</p>
</li>
<li>
<p>If <code>finespacing=FALSE</code>, then
the sample point spacing <code>dx</code> will be about one-half the width
of a pixel in the default pixellation of the window of <code>x</code>.
This is usually a much coarser resolution than the one
selected by <code>finespacing=TRUE</code>. If it is too coarse,
the pixel resolution can be refined using
the arguments <code>dimyx</code>, <code>eps</code> or <code>xy</code>
passed to <code><a href="grid.html#topic+as.mask">as.mask</a></code>. For example,
<code>dimyx=512</code> would specify a 512 x 512 pixel grid.
The default pixel resolution can be changed for the remainder of
the <span class="rlang"><b>R</b></span> session by <code><a href="spatstat.geom.html#topic+spatstat.options">spatstat.options</a>('npixel')</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a> and Greg McSwiggan.
</p>


<h3>References</h3>

<p>McSwiggan, G., Baddeley, A. and Nair, G. (2016)
Kernel density estimation on a linear network.
<em>Scandinavian Journal of Statistics</em> <b>44</b>, 324&ndash;345.
</p>
<p>McSwiggan, G., Baddeley, A. and Nair, G. (2019)
Estimation of relative risk for events on a linear network.
<em>Statistics and Computing</em> <b>30</b>, 469&ndash;484.
</p>
<p>Okabe, A. and Sugihara, K. (2012)
<em>Spatial analysis along networks</em>.
Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+density.lpp">density.lpp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- runiflpp(3, simplenet)
  D &lt;- densityHeat(X, 0.2)
  plot(D, style="w", main="", adjust=2)
  densityHeat.lpp(X, 0.2, at="points")
  Dw &lt;- densityHeat(X, 0.2, weights=c(1,2,-1))
</code></pre>

<hr>
<h2 id='densityQuick.lpp'>
Kernel Estimation of Intensity on a Network using a 2D Kernel
</h2><span id='topic+densityQuick.lpp'></span>

<h3>Description</h3>

<p>Estimates the intensity of a point process on a linear network
using a two-dimensional smoothing kernel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>densityQuick.lpp(x, sigma=NULL, ...,
         kernel="gaussian",
         at = c("pixels", "points"),
         what = c("estimate", "se", "var"),
         leaveoneout = TRUE,
         diggle = FALSE,
         edge2D = FALSE,
         weights = NULL,
         positive = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="densityQuick.lpp_+3A_x">x</code></td>
<td>

<p>Point pattern on a linear network (object of class <code>"lpp"</code>).
</p>
</td></tr>
<tr><td><code id="densityQuick.lpp_+3A_sigma">sigma</code></td>
<td>

<p>Smoothing bandwidth. A single numeric value,
in the same units as the coordinates of <code>x</code>.
Alternatively <code>sigma</code> may be a function which selects a
bandwidth when applied to <code>x</code>,
for example, <code><a href="spatstat.explore.html#topic+bw.scott.iso">bw.scott.iso</a></code> or <code><a href="#topic+bw.lppl">bw.lppl</a></code>.
There is a sensible default.
</p>
</td></tr>
<tr><td><code id="densityQuick.lpp_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to <code><a href="grid.html#topic+as.mask">as.mask</a></code>
to determine the pixel resolution, or arguments passed to
<code>sigma</code> if it is a function.
</p>
</td></tr>
<tr><td><code id="densityQuick.lpp_+3A_kernel">kernel</code></td>
<td>

<p>String (partially matched) specifying the smoothing kernel.
Current options are <code>"gaussian"</code>, <code>"epanechnikov"</code>,
<code>"quartic"</code> or <code>"disc"</code>.
</p>
</td></tr>
<tr><td><code id="densityQuick.lpp_+3A_at">at</code></td>
<td>

<p>String (partially matched)
specifying whether to compute the intensity values
at a fine grid of locations on the network
(<code>at="pixels"</code>, the default) or
only at the points of <code>x</code> (<code>at="points"</code>).
</p>
</td></tr>
<tr><td><code id="densityQuick.lpp_+3A_what">what</code></td>
<td>

<p>String (partially matched)
specifying whether to calculate the intensity estimate,
or its estimated standard error, or its estimated variance.
</p>
</td></tr>
<tr><td><code id="densityQuick.lpp_+3A_leaveoneout">leaveoneout</code></td>
<td>

<p>Logical value indicating whether to compute a leave-one-out
estimator. Applicable only when <code>at="points"</code>.
</p>
</td></tr>
<tr><td><code id="densityQuick.lpp_+3A_diggle">diggle</code></td>
<td>

<p>Logical value specifying whether to use the &lsquo;Diggle&rsquo;
correction. 
</p>
</td></tr>
<tr><td><code id="densityQuick.lpp_+3A_edge2d">edge2D</code></td>
<td>

<p>Logical value specifying whether to apply the usual
two-dimensional edge correction procedure to the numerator and
denominator of the estimate.
</p>
</td></tr>
<tr><td><code id="densityQuick.lpp_+3A_weights">weights</code></td>
<td>

<p>Optional weights to be attached to the points.
A numeric vector, an <code>expression</code>, or a pixel image.
</p>
</td></tr>
<tr><td><code id="densityQuick.lpp_+3A_positive">positive</code></td>
<td>

<p>Logical value indicating whether to force the resulting values to be
positive. Default is <code>FALSE</code> for the sake of speed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Kernel smoothing is applied to the points of <code>x</code>
using a two-dimensional Gaussian kernel, as described in Rakshit et al (2019).
The result is a pixel image on the linear network (class
<code>"linim"</code>) which can be plotted.
</p>
<p>Other techniques for kernel smoothing on a network are implemented in
<code><a href="#topic+density.lpp">density.lpp</a></code>. The main advantages of using a
two-dimensional kernel are very fast computation and
insensitivity to changes in the network geometry. The main
disadvantage is that it ignores the connectivity of the network.
See Rakshit et al (2019) for further explanation.
</p>
<p>The argument <code>sigma</code> specifies the smoothing bandwidth.
If <code>sigma</code> is missing or <code>NULL</code>,
the default is one-eighth of the length of the shortest side
of the bounding box of <code>x</code>.
If <code>sigma</code> is a function in the <span class="rlang"><b>R</b></span> language, it is assumed
to be a bandwidth selection rule, and it will be applied to <code>x</code>
to compute the bandwidth value.
</p>


<h3>Value</h3>

<p>If <code>at="pixels"</code> (the default),
a pixel image on the linear network (object of class <code>"linim"</code>).
</p>
<p>If <code>at="points"</code>, a numeric vector with one entry for each point
of <code>x</code>.
</p>


<h3>Infinite bandwidth</h3>

<p>If <code>sigma=Inf</code>, the resulting density estimate is 
constant over all locations,
and is equal to the average density of points per unit length.
(If the network is not connected, then this rule
is applied separately to each connected component of the network).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley, Suman Rakshit and Tilman Davies
</p>


<h3>References</h3>

<p>Rakshit, S., Davies, T., Moradi, M., 
McSwiggan, G., Nair, G., Mateu, J. and Baddeley, A. (2019)
Fast kernel smoothing of point patterns on a large
network using 2D convolution.
<em>International Statistical Review</em> <b>87</b> (3) 531&ndash;556.
DOI: 10.1111/insr.12327.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+density.lpp">density.lpp</a></code>, the main function for density estimation
on a network.
</p>
<p><code><a href="spatstat.explore.html#topic+bw.scott">bw.scott</a></code>, <code><a href="spatstat.explore.html#topic+bw.scott.iso">bw.scott.iso</a></code>,
<code><a href="#topic+bw.lppl">bw.lppl</a></code>for bandwidth selection.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   X &lt;- unmark(chicago)
   plot(densityQuick.lpp(X, 500))
   plot(densityQuick.lpp(X, 500, diggle=TRUE))
   plot(densityQuick.lpp(X, bw.scott.iso))
   plot(densityQuick.lpp(X, 500, what="se"))
</code></pre>

<hr>
<h2 id='densityVoronoi.lpp'>Intensity Estimate of Point Pattern on Linear Network Using Voronoi-Dirichlet Tessellation</h2><span id='topic+densityVoronoi.lpp'></span>

<h3>Description</h3>

<p>Computes an adaptive estimate of the intensity function of a point
pattern on a linear network, using the Dirichlet-Voronoi tessellation
on the network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpp'
densityVoronoi(X, f = 1, ..., nrep = 1, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="densityVoronoi.lpp_+3A_x">X</code></td>
<td>

<p>Point pattern on a linear network (object of class <code>"lpp"</code>).
</p>
</td></tr>
<tr><td><code id="densityVoronoi.lpp_+3A_f">f</code></td>
<td>

<p>Fraction (between 0 and 1 inclusive) of the data points that will be
used to build a tessellation for the intensity estimate.
</p>
</td></tr>
<tr><td><code id="densityVoronoi.lpp_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+linim">linim</a></code> determining the
pixel resolution of the result.
</p>
</td></tr>
<tr><td><code id="densityVoronoi.lpp_+3A_nrep">nrep</code></td>
<td>

<p>Number of independent repetitions of the randomised
procedure.
</p>
</td></tr>
<tr><td><code id="densityVoronoi.lpp_+3A_verbose">verbose</code></td>
<td>

<p>Logical value indicating whether to print
progress reports.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is an alternative to <code><a href="#topic+density.lpp">density.lpp</a></code>. It
computes an estimate of the intensity function of a point pattern
dataset on a linear network.
The result is a pixel image on the network, giving the estimated intensity.
</p>
<p>This function is a method for the generic <code><a href="spatstat.explore.html#topic+densityVoronoi">densityVoronoi</a></code>
for the class <code>"lpp"</code> of point patterns on a linear network.
</p>
<p>If <code>f=1</code> (the default), the Voronoi estimate (Barr and Schoenberg, 2010)
is computed: the point pattern <code>X</code> is used to construct
a Voronoi/Dirichlet tessellation on the network
(see <code><a href="#topic+lineardirichlet">lineardirichlet</a></code>);
the lengths of the Dirichlet tiles are computed; the estimated intensity
in each tile is the reciprocal of the tile length.
The result is a pixel image
of intensity estimates which are constant on each tile of the tessellation.
</p>
<p>If <code>f=0</code>, the intensity estimate at every location is
equal to the average intensity (number of points divided by
network length). The result is a pixel image
of intensity estimates which are constant.
</p>
<p>If <code>f</code> is strictly between 0 and 1,
the smoothed Voronoi estimate (Moradi et al, 2019) is computed.
The dataset <code>X</code> is randomly
thinned by deleting or retaining each point independently, with
probability <code>f</code> of retaining a point.
The thinned pattern
is used to construct a Dirichlet tessellation and form the
Voronoi estimate, which is then
adjusted by a factor <code>1/f</code>.
This procedure is repeated <code>nrep</code> times and the results are
averaged to obtain the smoothed Voronoi estimate.
</p>
<p>The value <code>f</code> can be chosen automatically by bandwidth
selection using <code><a href="#topic+bw.voronoi">bw.voronoi</a></code>.
</p>


<h3>Value</h3>

<p>Pixel image on a linear network (object of class <code>"linim"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a> and Mehdi Moradi <a href="mailto:m2.moradi@yahoo.com">m2.moradi@yahoo.com</a>.
</p>


<h3>References</h3>

<p>Moradi, M., Cronie, 0., Rubak, E., Lachieze-Rey, R.,
Mateu, J. and Baddeley, A. (2019)
Resample-smoothing of Voronoi intensity estimators.
<em>Statistics and Computing</em> <b>29</b> (5) 995&ndash;1010.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.explore.html#topic+densityVoronoi">densityVoronoi</a></code> is the generic, with a method for
class <code>"ppp"</code>.
</p>
<p><code><a href="#topic+lineardirichlet">lineardirichlet</a></code> computes the Dirichlet-Voronoi
tessellation on a network.
</p>
<p><code><a href="#topic+bw.voronoi">bw.voronoi</a></code> performs bandwidth selection of the fraction <code>f</code>.
</p>
<p>See also <code><a href="#topic+density.lpp">density.lpp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   nr &lt;- if(interactive()) 100 else 3
   plot(densityVoronoi(spiders, 0.1, nrep=nr))
</code></pre>

<hr>
<h2 id='diameter.linnet'>
Diameter and Bounding Radius of a Linear Network
</h2><span id='topic+boundingradius.linnet'></span><span id='topic+diameter.linnet'></span>

<h3>Description</h3>

<p>Compute the diameter or bounding radius of a linear network
measured using the shortest path distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'linnet'
diameter(x)

## S3 method for class 'linnet'
boundingradius(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diameter.linnet_+3A_x">x</code></td>
<td>

<p>Linear network (object of class <code>"linnet"</code>).
</p>
</td></tr>
<tr><td><code id="diameter.linnet_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The diameter of a linear network (in the shortest path distance)
is the maximum value of the shortest-path distance between any
two points <code class="reqn">u</code> and <code class="reqn">v</code> on the network.
</p>
<p>The bounding radius of a linear network (in the shortest path distance)
is the minimum value, over all points <code class="reqn">u</code> on the network,
of the maximum shortest-path distance from <code class="reqn">u</code> to another point
<code class="reqn">v</code> on the network.
</p>
<p>The functions <code><a href="spatstat.geom.html#topic+boundingradius">boundingradius</a></code> and
<code><a href="spatstat.geom.html#topic+diameter">diameter</a></code> are generic;
the functions <code>boundingradius.linnet</code> and <code>diameter.linnet</code>
are the methods for objects of class <code>linnet</code>.
</p>


<h3>Value</h3>

<p>A single numeric value.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.geom.html#topic+boundingradius">boundingradius</a></code>, <code><a href="spatstat.geom.html#topic+diameter">diameter</a></code>, 
<code><a href="#topic+linnet">linnet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   diameter(simplenet)
   boundingradius(simplenet)
</code></pre>

<hr>
<h2 id='distfun.lpp'>
Distance Map on Linear Network
</h2><span id='topic+distfun.lpp'></span>

<h3>Description</h3>

<p>Compute the distance function of a point pattern on a linear network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'lpp'
distfun(X, ..., k=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distfun.lpp_+3A_x">X</code></td>
<td>

<p>A point pattern on a linear network
(object of class <code>"lpp"</code>).
</p>
</td></tr>
<tr><td><code id="distfun.lpp_+3A_k">k</code></td>
<td>

<p>An integer. The distance to the <code>k</code>th nearest point
will be computed.
</p>
</td></tr>
<tr><td><code id="distfun.lpp_+3A_...">...</code></td>
<td>

<p>Extra arguments are ignored. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>On a linear network <code class="reqn">L</code>, the &ldquo;geodesic distance function&rdquo;
of a set of points <code class="reqn">A</code> in <code class="reqn">L</code> is the
mathematical function <code class="reqn">f</code> such that, for any 
location <code class="reqn">s</code> on <code class="reqn">L</code>,
the function value <code>f(s)</code>
is the shortest-path distance from <code class="reqn">s</code> to <code class="reqn">A</code>.
</p>
<p>The command <code>distfun.lpp</code> is a method for the generic command
<code><a href="spatstat.geom.html#topic+distfun">distfun</a></code>
for the class <code>"lpp"</code> of point patterns on a linear network.
</p>
<p>If <code>X</code> is a point pattern on a linear network,
<code>f &lt;- distfun(X)</code> returns a <em>function</em>
in the <span class="rlang"><b>R</b></span> language that represents the
distance function of <code>X</code>. Evaluating the function <code>f</code>
in the form <code>v &lt;- f(x,y)</code>, where <code>x</code> and <code>y</code>
are any numeric vectors of equal length containing coordinates of
spatial locations, yields the values of the distance function at these
locations. More efficiently <code>f</code> can be called in the form
<code>v &lt;- f(x, y, seg, tp)</code> where <code>seg</code> and <code>tp</code> are the local
coordinates on the network. It can also be called as
<code>v &lt;- f(x)</code> where <code>x</code> is a point pattern on the same linear
network.
</p>
<p>The function <code>f</code> obtained from <code>f &lt;- distfun(X)</code>
also belongs to the class <code>"linfun"</code>. 
It can be printed and plotted immediately as shown in the Examples.
It can be 
converted to a pixel image using <code><a href="#topic+as.linim">as.linim</a></code>. 
</p>


<h3>Value</h3>

<p>A <code>function</code> with arguments <code>x,y</code> and optional
arguments <code>seg,tp</code>.
It also belongs to the class <code>"linfun"</code> which has methods
for <code>plot</code>, <code>print</code> etc.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linfun">linfun</a></code>,
<code><a href="#topic+methods.linfun">methods.linfun</a></code>.
</p>
<p>To identify <em>which</em> point is the nearest neighbour, see
<code><a href="#topic+nnfun.lpp">nnfun.lpp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   X &lt;- runiflpp(3, simplenet)
   f &lt;- distfun(X)
   f
   plot(f)

   # using a distfun as a covariate in a point process model:
   Y &lt;- runiflpp(4, simplenet)
   fit &lt;- lppm(Y ~D, covariates=list(D=f))

   f(Y)
</code></pre>

<hr>
<h2 id='distmap.lpp'>
Distance Map of Point Pattern on Linear Network
</h2><span id='topic+distmap.lpp'></span>

<h3>Description</h3>

<p>Computes the distance from each pixel to the nearest
point in the given point pattern on a linear network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'lpp'
distmap(X, ..., k=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distmap.lpp_+3A_x">X</code></td>
<td>
<p>A point pattern on a linear network (object of class <code>"lpp"</code>).
</p>
</td></tr>
<tr><td><code id="distmap.lpp_+3A_k">k</code></td>
<td>

<p>Integer. The distance to the <code>k</code>-th nearest data point
will be computed.
</p>
</td></tr>
<tr><td><code id="distmap.lpp_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+as.linim.linfun">as.linim.linfun</a></code>
to control pixel resolution.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function <code><a href="spatstat.geom.html#topic+distmap">distmap</a></code>.
It computes the distance map of the point pattern <code>X</code>
as a pixel image on the network.
</p>
<p>At a pixel <code class="reqn">u</code>, the greyscale value
equals the distance from <code class="reqn">u</code> to the
nearest point of the pattern <code>X</code> (or the <code class="reqn">k</code>-th nearest point
of <code>X</code>).
</p>


<h3>Value</h3>

<p>A pixel image on the network (object of class <code>"linim"</code>)
whose greyscale values are the values of the distance map.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p>Generic function <code><a href="spatstat.geom.html#topic+distmap">distmap</a></code> and methods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  plot(distmap(spiders))
</code></pre>

<hr>
<h2 id='divide.linnet'>
Divide Linear Network at Cut Points
</h2><span id='topic+divide.linnet'></span>

<h3>Description</h3>

<p>Make a tessellation of a linear network by dividing it into
pieces demarcated by the points of a point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> divide.linnet(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="divide.linnet_+3A_x">X</code></td>
<td>

<p>Point pattern on a linear network (object of class <code>"lpp"</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The points <code>X</code> are interpreted as dividing the linear network
<code>L=as.linnet(X)</code> into separate pieces.
</p>
<p>Two locations on <code>L</code>
belong to the same piece if and only if they can be joined by a path
in <code>L</code> that does not cross any of the points of <code>X</code>.
</p>
<p>The result is a
tessellation of the network (object of class <code>"lintess"</code>)
representing the division of <code>L</code> into pieces. 
</p>


<h3>Value</h3>

<p>A tessellation on a linear network (object of class <code>"lintess"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
and Greg McSwiggan.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linnet">linnet</a></code>, <code><a href="#topic+lintess">lintess</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- runiflpp(5, simplenet)
  plot(divide.linnet(X))
  plot(X, add=TRUE, pch=16, show.network=FALSE)
</code></pre>

<hr>
<h2 id='domain.lpp'>
Extract the Linear Network on which Spatial Data are Defined
</h2><span id='topic+domain.lpp'></span><span id='topic+domain.lppm'></span><span id='topic+domain.linfun'></span><span id='topic+domain.lintess'></span>

<h3>Description</h3>

<p>Given a spatial object representing data on a linear network,
extract the network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'lpp'
domain(X, ...)

 ## S3 method for class 'lppm'
domain(X, ...)

 ## S3 method for class 'linfun'
domain(X, ...)

 ## S3 method for class 'lintess'
domain(X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="domain.lpp_+3A_x">X</code></td>
<td>

<p>A spatial object representing data on a linear network.
An object of class <code>"lpp"</code>, <code>"lppm"</code>, <code>"linfun"</code>
or <code>"lintess"</code>.
</p>
</td></tr>
<tr><td><code id="domain.lpp_+3A_...">...</code></td>
<td>

<p>Extra arguments. They are ignored by all the methods listed here.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="spatstat.geom.html#topic+domain">domain</a></code> is generic,
with methods for many classes.
</p>
<p>For a spatial object <code>X</code> 
<code>domain(X)</code> extracts the spatial domain in which <code>X</code> is
defined.
</p>
<p>For a two-dimensional object <code>X</code>, typically <code>domain(X)</code>
is the same as <code>Window(X)</code>.
</p>
<p>The exception is that, if <code>X</code> is a point pattern on a linear network
(class <code>"lpp"</code>) or a point process model on a linear network
(class <code>"lppm"</code>), then <code>domain(X)</code> is the linear network
on which the points lie, while <code>Window(X)</code> is the two-dimensional
window containing the linear network.
</p>


<h3>Value</h3>

<p>A linear network (object of class <code>"linnet"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.geom.html#topic+domain">domain</a></code>,
<code><a href="spatstat.random.html#topic+domain.rmhmodel">domain.rmhmodel</a></code>,
<code><a href="spatstat.model.html#topic+domain.ppm">domain.ppm</a></code>.
</p>
<p><code><a href="spatstat.geom.html#topic+Window">Window</a></code>,
<code><a href="spatstat.geom.html#topic+Frame">Frame</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  domain(chicago)
</code></pre>

<hr>
<h2 id='envelope.lpp'>
Envelope for Point Patterns on Linear Network
</h2><span id='topic+envelope.lpp'></span><span id='topic+envelope.lppm'></span>

<h3>Description</h3>

<p>Enables envelopes to be computed for point patterns on a linear network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'lpp'
envelope(Y, fun=linearK, nsim=99, nrank=1, ..., 
  funargs=list(), funYargs=funargs,
  simulate=NULL, fix.n=FALSE, fix.marks=FALSE, verbose=TRUE, 
  transform=NULL,global=FALSE,ginterval=NULL,use.theory=NULL,
  alternative=c("two.sided", "less", "greater"),
  scale=NULL, clamp=FALSE,
  savefuns=FALSE, savepatterns=FALSE,
  nsim2=nsim, VARIANCE=FALSE, nSD=2, Yname=NULL,
  maxnerr=nsim, rejectNA=FALSE, silent=FALSE,
  do.pwrong=FALSE, envir.simul=NULL)


  ## S3 method for class 'lppm'
envelope(Y, fun=linearK, nsim=99, nrank=1, ..., 
  funargs=list(), funYargs=funargs,
  simulate=NULL, fix.n=FALSE, fix.marks=FALSE, verbose=TRUE, 
  transform=NULL,global=FALSE,ginterval=NULL,use.theory=NULL,
  alternative=c("two.sided", "less", "greater"), 
  scale=NULL, clamp=FALSE,
  savefuns=FALSE, savepatterns=FALSE,
  nsim2=nsim, VARIANCE=FALSE, nSD=2, Yname=NULL,
  maxnerr=nsim, rejectNA=FALSE, silent=FALSE,
  do.pwrong=FALSE, envir.simul=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="envelope.lpp_+3A_y">Y</code></td>
<td>

<p>A point pattern on a linear network
(object of class <code>"lpp"</code>)
or a fitted point process model on a linear network
(object of class <code>"lppm"</code>).
</p>
</td></tr>
<tr><td><code id="envelope.lpp_+3A_fun">fun</code></td>
<td>

<p>Function that is to be computed for each simulated pattern.
</p>
</td></tr>
<tr><td><code id="envelope.lpp_+3A_nsim">nsim</code></td>
<td>

<p>Number of simulations to perform.
</p>
</td></tr>
<tr><td><code id="envelope.lpp_+3A_nrank">nrank</code></td>
<td>

<p>Integer. Rank of the envelope value amongst the <code>nsim</code> simulated
values. A rank of 1 means that the minimum and maximum
simulated values will be used.
</p>
</td></tr>
<tr><td><code id="envelope.lpp_+3A_...">...</code></td>
<td>

<p>Extra arguments passed to <code>fun</code>.
</p>
</td></tr>
<tr><td><code id="envelope.lpp_+3A_funargs">funargs</code></td>
<td>

<p>A list, containing extra arguments to be passed to <code>fun</code>.
</p>
</td></tr>
<tr><td><code id="envelope.lpp_+3A_funyargs">funYargs</code></td>
<td>

<p>Optional. A list, containing extra arguments to be passed to
<code>fun</code> when applied to the original data <code>Y</code> only.
</p>
</td></tr>
<tr><td><code id="envelope.lpp_+3A_simulate">simulate</code></td>
<td>

<p>Optional. Specifies how to generate the simulated point patterns.
If <code>simulate</code> is an expression in the R language, then this
expression will be evaluated <code>nsim</code> times,
to obtain <code>nsim</code> point patterns which are taken as the
simulated patterns from which the envelopes are computed.
If <code>simulate</code> is a function, then this function will be
repeatedly applied to the data pattern <code>Y</code> to obtain
<code>nsim</code> simulated patterns.
If <code>simulate</code> is a list of point patterns, then the entries
in this list will be treated as the simulated patterns from which
the envelopes are computed.
Alternatively <code>simulate</code> may be an object produced by the
<code>envelope</code> command: see Details.
</p>
</td></tr>
<tr><td><code id="envelope.lpp_+3A_fix.n">fix.n</code></td>
<td>

<p>Logical. If <code>TRUE</code>, simulated patterns will have the
same number of points as the original data pattern.
</p>
</td></tr>
<tr><td><code id="envelope.lpp_+3A_fix.marks">fix.marks</code></td>
<td>

<p>Logical. If <code>TRUE</code>, simulated patterns will have the
same number of points <em>and</em> the same marks as the
original data pattern. In a multitype point pattern this means that
the simulated patterns will have the same number of points
<em>of each type</em> as the original data.
</p>
</td></tr>
<tr><td><code id="envelope.lpp_+3A_verbose">verbose</code></td>
<td>

<p>Logical flag indicating whether to print progress reports
during the simulations.
</p>
</td></tr>
<tr><td><code id="envelope.lpp_+3A_transform">transform</code></td>
<td>

<p>Optional. A transformation to be applied to the
function values, before the envelopes are computed.
An expression object (see Details).
</p>
</td></tr>
<tr><td><code id="envelope.lpp_+3A_global">global</code></td>
<td>

<p>Logical flag indicating whether envelopes should be pointwise
(<code>global=FALSE</code>) or simultaneous (<code>global=TRUE</code>).
</p>
</td></tr>
<tr><td><code id="envelope.lpp_+3A_ginterval">ginterval</code></td>
<td>

<p>Optional.
A vector of length 2 specifying
the interval of <code class="reqn">r</code> values for the simultaneous critical
envelopes. Only relevant if <code>global=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="envelope.lpp_+3A_use.theory">use.theory</code></td>
<td>

<p>Logical value indicating whether to use the theoretical value,
computed by <code>fun</code>, as the reference value for simultaneous
envelopes. Applicable only when <code>global=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="envelope.lpp_+3A_alternative">alternative</code></td>
<td>

<p>Character string determining whether the envelope corresponds
to a two-sided test (<code>side="two.sided"</code>, the default)
or a one-sided test with a lower critical boundary
(<code>side="less"</code>) or a one-sided test
with an upper critical boundary (<code>side="greater"</code>).
</p>
</td></tr>
<tr><td><code id="envelope.lpp_+3A_scale">scale</code></td>
<td>

<p>Optional. Scaling function for global envelopes.
A function in the <span class="rlang"><b>R</b></span> language which determines the
relative scale of deviations, as a function of
distance <code class="reqn">r</code>, when computing the global envelopes.
Applicable only when <code>global=TRUE</code>.
Summary function values for distance <code>r</code>
will be <em>divided</em> by <code>scale(r)</code> before the
maximum deviation is computed. The resulting global envelopes
will have width proportional to <code>scale(r)</code>. 
</p>
</td></tr>
<tr><td><code id="envelope.lpp_+3A_clamp">clamp</code></td>
<td>

<p>Logical value indicating how to compute envelopes when
<code>alternative="less"</code> or <code>alternative="greater"</code>.
Deviations of the observed
summary function from the theoretical summary function are initially
evaluated as signed real numbers, with large positive values indicating
consistency with the alternative hypothesis.
If <code>clamp=FALSE</code> (the default), these values are not changed.
If <code>clamp=TRUE</code>, any negative values are replaced by zero.
</p>
</td></tr>
<tr><td><code id="envelope.lpp_+3A_savefuns">savefuns</code></td>
<td>

<p>Logical flag indicating whether to save all the simulated
function values.
</p>
</td></tr>
<tr><td><code id="envelope.lpp_+3A_savepatterns">savepatterns</code></td>
<td>

<p>Logical flag indicating whether to save all the simulated
point patterns.
</p>
</td></tr>
<tr><td><code id="envelope.lpp_+3A_nsim2">nsim2</code></td>
<td>

<p>Number of extra simulated point patterns to be generated
if it is necessary to use simulation to estimate the theoretical
mean of the summary function. Only relevant when <code>global=TRUE</code>
and the simulations are not based on CSR.
</p>
</td></tr>
<tr><td><code id="envelope.lpp_+3A_variance">VARIANCE</code></td>
<td>

<p>Logical. If <code>TRUE</code>, critical envelopes will be calculated
as sample mean plus or minus <code>nSD</code> times sample standard
deviation.
</p>
</td></tr>
<tr><td><code id="envelope.lpp_+3A_nsd">nSD</code></td>
<td>

<p>Number of estimated standard deviations used to determine
the critical envelopes, if <code>VARIANCE=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="envelope.lpp_+3A_yname">Yname</code></td>
<td>

<p>Character string that should be used as the name of the 
data point pattern <code>Y</code> when printing or plotting the results.
</p>
</td></tr>
<tr><td><code id="envelope.lpp_+3A_maxnerr">maxnerr</code></td>
<td>

<p>Maximum number of rejected patterns.
If <code>fun</code> yields a fatal error when applied to a simulated point
pattern (for example, because the pattern is empty and <code>fun</code>
requires at least one point), the pattern will be rejected
and a new random point pattern will be generated. If this happens
more than <code>maxnerr</code> times, the algorithm will give up.
</p>
</td></tr>
<tr><td><code id="envelope.lpp_+3A_rejectna">rejectNA</code></td>
<td>

<p>Logical value specifying whether to reject a simulated pattern
if the resulting values of <code>fun</code> are all equal to <code>NA</code>,
<code>NaN</code> or infinite. If <code>FALSE</code> (the default), then
simulated patterns are rejected only when <code>fun</code> gives a
fatal error. 
</p>
</td></tr>
<tr><td><code id="envelope.lpp_+3A_silent">silent</code></td>
<td>

<p>Logical value specifying whether to print a report each time
a simulated pattern is rejected.
</p>
</td></tr>
<tr><td><code id="envelope.lpp_+3A_do.pwrong">do.pwrong</code></td>
<td>

<p>Logical. If <code>TRUE</code>, the algorithm will also estimate
the true significance level of the &ldquo;wrong&rdquo; test (the test that
declares the summary function for the data to be significant
if it lies outside the <em>pointwise</em> critical boundary at any
point). This estimate is printed when the result is printed.
</p>
</td></tr>
<tr><td><code id="envelope.lpp_+3A_envir.simul">envir.simul</code></td>
<td>

<p>Environment in which to evaluate the expression <code>simulate</code>,
if not the current environment.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic
function <code><a href="boot.html#topic+envelope">envelope</a></code> 
applicable to point patterns on a linear network.
</p>
<p>The argument <code>Y</code> can be either a point pattern on a linear
network, or a fitted point process model on a linear network. 
The function <code>fun</code> will be evaluated for the data
and also for <code>nsim</code> simulated point
patterns on the same linear network.
The upper and lower
envelopes of these evaluated functions will be computed
as described in <code><a href="boot.html#topic+envelope">envelope</a></code>.
</p>
<p>The type of simulation is determined as follows.
</p>

<ul>
<li> 
<p>if <code>Y</code> is a point pattern (object of class <code>"lpp"</code>)
and <code>simulate</code> is missing or <code>NULL</code>,
then random point patterns will be generated according to
a Poisson point process on the linear network on which <code>Y</code>
is defined, with intensity estimated from <code>Y</code>.
</p>
</li>
<li>
<p>if <code>Y</code> is a fitted point process model (object of class
<code>"lppm"</code>) and <code>simulate</code> is missing or <code>NULL</code>,
then random point patterns will be generated by simulating
from the fitted model.
</p>
</li>
<li>
<p>If <code>simulate</code> is present, it specifies the
type of simulation as explained below.
</p>
</li>
<li>
<p>If <code>simulate</code> is an expression (typically including a call
to a random generator), then the expression will be repeatedly
evaluated, and should yield random point patterns on the same
linear network as <code>Y</code>.
</p>
</li>
<li>
<p>If <code>simulate</code> is a function (typically including a call
to a random generator), then the function will be repeatedly
applied to the original point pattern <code>Y</code>, and
should yield random point patterns on the same
linear network as <code>Y</code>.
</p>
</li>
<li>
<p>If <code>simulate</code> is a list of point patterns,
then these will be taken as the simulated point patterns.
They should be on the same linear network as <code>Y</code>.
</p>
</li></ul>

<p>The function <code>fun</code> should accept as its first argument
a point pattern on a linear network (object of class <code>"lpp"</code>)
and should have another argument called <code>r</code> or a <code>...</code>
argument. 
</p>


<h3>Value</h3>

<p>Function value table (object of class <code>"fv"</code>)
with additional information,
as described in <code><a href="boot.html#topic+envelope">envelope</a></code>.
</p>


<h3>Author(s)</h3>

<p>Ang Qi Wei <a href="mailto:aqw07398@hotmail.com">aqw07398@hotmail.com</a> and Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>References</h3>

<p>Ang, Q.W. (2010)
<em>Statistical methodology for events on a network</em>.
Master's thesis, School of Mathematics and Statistics, University of
Western Australia.
</p>
<p>Ang, Q.W., Baddeley, A. and Nair, G. (2012)
Geometrically corrected second-order analysis of 
events on a linear network, with applications to
ecology and criminology.
<em>Scandinavian Journal of Statistics</em> <b>39</b>, 591&ndash;617.
</p>
<p>Okabe, A. and Yamada, I. (2001) The K-function method on a network and
its computational implementation. <em>Geographical Analysis</em>
<b>33</b>, 271-290.
</p>


<h3>See Also</h3>

<p><code><a href="boot.html#topic+envelope">envelope</a></code>,
<code><a href="#topic+linearK">linearK</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   if(interactive()) {
     ns &lt;- 39
     np &lt;- 40
   } else { ns &lt;- np &lt;- 3 }
   X &lt;- runiflpp(np, simplenet)

   # uniform Poisson: random numbers of points
   envelope(X, nsim=ns)

   # uniform Poisson: conditional on observed number of points
   envelope(X, fix.n=TRUE, nsim=ns)

   # nonuniform Poisson
   fit &lt;- lppm(X ~x)
   envelope(fit, nsim=ns)

   #multitype
   marks(X) &lt;- sample(letters[1:2], np, replace=TRUE)
   envelope(X, nsim=ns)
</code></pre>

<hr>
<h2 id='eval.linim'>Evaluate Expression Involving Pixel Images on Linear Network</h2><span id='topic+eval.linim'></span>

<h3>Description</h3>

<p>Evaluates any expression involving one or more pixel images
on a linear network, and returns a pixel image on the same linear network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  eval.linim(expr, envir, harmonize=TRUE, warn=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval.linim_+3A_expr">expr</code></td>
<td>
<p>An expression in the <span class="rlang"><b>R</b></span> language,
involving the names of objects of class <code>"linim"</code>.</p>
</td></tr>
<tr><td><code id="eval.linim_+3A_envir">envir</code></td>
<td>
<p>Optional. The environment in which to evaluate the
expression.</p>
</td></tr>
<tr><td><code id="eval.linim_+3A_harmonize">harmonize</code></td>
<td>

<p>Logical. Whether to resolve inconsistencies between
the pixel grids.
</p>
</td></tr>
<tr><td><code id="eval.linim_+3A_warn">warn</code></td>
<td>

<p>Logical. Whether to issue a warning if the pixel grids were
inconsistent.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function a wrapper to make it easier to perform
pixel-by-pixel calculations. It is one of several functions
whose names begin with <code>eval</code> which work on objects of
different types. This particular function is designed to work with
objects of class <code>"linim"</code> which represent
pixel images on a linear network. 
</p>
<p>Suppose <code>X</code> is a pixel image on a linear network (object of
class <code>"linim"</code>. Then <code>eval.linim(X+3)</code>
will add 3 to the value of every pixel in <code>X</code>, and return
the resulting pixel image on the same linear network.
</p>
<p>Suppose <code>X</code> and <code>Y</code> are two pixel images on the same
linear network, with compatible pixel dimensions. Then
<code>eval.linim(X + Y)</code> will add the corresponding pixel values in
<code>X</code> and <code>Y</code>, and return the resulting pixel image
on the same linear network.
</p>
<p>In general, <code>expr</code> can be any expression in the R language involving
(a) the <em>names</em> of pixel images, (b) scalar
constants, and (c) functions which are vectorised.
See the Examples.
</p>
<p>First <code>eval.linim</code> determines which of the <em>variable names</em>
in the expression <code>expr</code> refer to pixel images. Each such name
is replaced by a matrix containing the pixel values. The expression is
then evaluated. The result should be a matrix; it is taken as
the matrix of pixel values.
</p>
<p>The expression <code>expr</code> must be vectorised.
There must be at least one linear pixel image in the expression.
</p>
<p>All images must have compatible dimensions.
If <code>harmonize=FALSE</code>, images that are incompatible will cause an error.
If <code>harmonize=TRUE</code>, images that have incompatible dimensions
will be resampled so that they are compatible; if <code>warn=TRUE</code>,
a warning will be issued.
</p>


<h3>Value</h3>

<p>An image object of class <code>"linim"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.geom.html#topic+eval.im">eval.im</a></code>,
<code><a href="#topic+linim">linim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  M &lt;- psp2mask(as.psp(simplenet))
  Z &lt;- as.im(function(x,y) {x-y}, W=M)
  X &lt;- linim(simplenet, Z)
  X

  Y &lt;- linfun(function(x,y,seg,tp){y^2+x}, simplenet)
  Y &lt;- as.linim(Y)
  
  eval.linim(X + 3)
  eval.linim(X - Y)
  eval.linim(abs(X - Y))
  Z &lt;- eval.linim(sin(X * pi) + Y)
</code></pre>

<hr>
<h2 id='Extract.linim'>Extract Subset of Pixel Image on Linear Network</h2><span id='topic++5B.linim'></span>

<h3>Description</h3>

<p>Extract a subset of a pixel image on a linear network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'linim'
x[i, ..., drop=TRUE]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Extract.linim_+3A_x">x</code></td>
<td>

<p>A pixel image on a linear network (object of class <code>"linim"</code>).
</p>
</td></tr>
<tr><td><code id="Extract.linim_+3A_i">i</code></td>
<td>

<p>Spatial window defining the subregion.
Either a spatial window (an object of class <code>"owin"</code>), or a
logical-valued pixel image, 
or any type of index that applies to a matrix,
or a point pattern (an object of class <code>"lpp"</code> or <code>"ppp"</code>),
or something that can be converted to a point pattern
by <code><a href="#topic+as.lpp">as.lpp</a></code> (using the network on which <code>x</code> is defined).
</p>
</td></tr>
<tr><td><code id="Extract.linim_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>[.im</code>.</p>
</td></tr>
<tr><td><code id="Extract.linim_+3A_drop">drop</code></td>
<td>
<p>Logical value indicating whether <code>NA</code> values should
be omitted from the result.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a method for the subset operator <code>"["</code> for
pixel images on linear networks (objects of class <code>"linim"</code>). 
</p>
<p>The pixel image <code>x</code> will be restricted to the 
domain specified by <code>i</code>.
</p>
<p>Pixels outside the domain of <code>x</code> are assigned the value <code>NA</code>;
if <code>drop=TRUE</code> (the default) such <code>NA</code> values are deleted
from the result; if <code>drop=FALSE</code>, then <code>NA</code> values are retained.
</p>
<p>If <code>i</code> is a window (or a logical-valued pixel image)
then <code>x[i]</code> is another pixel image of class <code>"linim"</code>,
representing the restriction of <code>x</code> to the spatial domain
specified by <code>i</code>.
</p>
<p>If <code>i</code> is a point pattern, then <code>x[i]</code> is the vector of
pixel values of <code>x</code> at the locations specified by <code>i</code>.
</p>


<h3>Value</h3>

<p>Another pixel image on a linear network (object of class <code>"linim"</code>)
or a vector of pixel values.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  M &lt;- psp2mask(as.psp(simplenet))
  Z &lt;- as.im(function(x,y){x}, W=M)
  Y &lt;- linim(simplenet, Z)
  X &lt;- runiflpp(4, simplenet)
  Y[X]
  Y[square(c(0.3, 0.6))]
</code></pre>

<hr>
<h2 id='Extract.linnet'>Extract Subset of Linear Network</h2><span id='topic++5B.linnet'></span>

<h3>Description</h3>

<p>Extract a subset of a linear network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'linnet'
x[i, ..., snip=TRUE]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Extract.linnet_+3A_x">x</code></td>
<td>

<p>A linear network (object of class <code>"linnet"</code>).
</p>
</td></tr>
<tr><td><code id="Extract.linnet_+3A_i">i</code></td>
<td>

<p>Spatial window defining the subregion.
An object of class <code>"owin"</code>.
</p>
</td></tr>
<tr><td><code id="Extract.linnet_+3A_snip">snip</code></td>
<td>

<p>Logical. If <code>TRUE</code> (the default), segments of <code>x</code>
which cross the boundary of <code>i</code> will be cut by the boundary.
If <code>FALSE</code>, these segments will be deleted.
</p>
</td></tr>
<tr><td><code id="Extract.linnet_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the intersection
between the linear network <code>x</code> and the domain specified by <code>i</code>.
</p>
<p>This function is a method for the subset operator <code>"["</code> for
linear networks (objects of class <code>"linnet"</code>). It is provided
mainly for completeness.
</p>
<p>The index <code>i</code> should be a window.
</p>
<p>The argument <code>snip</code> specifies what to do with segments of <code>x</code>
which cross the boundary of <code>i</code>. 
If <code>snip=FALSE</code>, such segments are simply deleted.  
If <code>snip=TRUE</code> (the default), such segments are cut into pieces by the
boundary of <code>i</code>, and those pieces which lie inside the window
<code>i</code> are included in the resulting network. 
</p>


<h3>Value</h3>

<p>Another linear network (object of class <code>"linnet"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>,
Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>,
Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
and Suman Rakshit.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  p &lt;- par(mfrow=c(1,2), mar=0.2+c(0,0,1,0))
  B &lt;- owin(c(0.1,0.7),c(0.19,0.6))

  plot(simplenet, main="x[w, snip=TRUE]")
  plot(simplenet[B], add=TRUE, col="green", lwd=3)
  plot(B, add=TRUE, border="red", lty=3)

  plot(simplenet, main="x[w, snip=FALSE]")
  plot(simplenet[B, snip=FALSE], add=TRUE, col="green", lwd=3)
  plot(B, add=TRUE, border="red", lty=3)

  par(p)
</code></pre>

<hr>
<h2 id='Extract.lpp'>Extract Subset of Point Pattern on Linear Network</h2><span id='topic++5B.lpp'></span>

<h3>Description</h3>

<p>Extract a subset of a point pattern on a linear network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'lpp'
x[i, j, drop=FALSE, ..., snip=TRUE]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Extract.lpp_+3A_x">x</code></td>
<td>

<p>A point pattern on a linear network (object of class <code>"lpp"</code>).
</p>
</td></tr>
<tr><td><code id="Extract.lpp_+3A_i">i</code></td>
<td>

<p>Subset index. A valid subset index in the usual <span class="rlang"><b>R</b></span> sense,
indicating which points should be retained.
</p>
</td></tr>
<tr><td><code id="Extract.lpp_+3A_j">j</code></td>
<td>

<p>Spatial window
(object of class <code>"owin"</code>) delineating the region that should
be retained.
</p>
</td></tr>
<tr><td><code id="Extract.lpp_+3A_drop">drop</code></td>
<td>

<p>Logical value indicating whether to remove unused levels
of the marks, if the marks are a factor.
</p>
</td></tr>
<tr><td><code id="Extract.lpp_+3A_snip">snip</code></td>
<td>

<p>Logical. If <code>TRUE</code> (the default), segments of the network
which cross the boundary of the window <code>j</code> will be cut by the boundary.
If <code>FALSE</code>, these segments will be deleted.
</p>
</td></tr>
<tr><td><code id="Extract.lpp_+3A_...">...</code></td>
<td>

<p>Ignored. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function extracts a designated subset of a point pattern
on a linear network.
</p>
<p>The function <code>[.lpp</code> is a method for <code><a href="Matrix.html#topic++5B">[</a></code> for the
class <code>"lpp"</code>. It extracts a designated subset of a point pattern.
The argument <code>i</code> should be a subset index in the usual <span class="rlang"><b>R</b></span> sense:
either a numeric vector
of positive indices (identifying the points to be retained),
a numeric vector of negative indices (identifying the points
to be deleted) or a logical vector of length equal to the number of
points in the point pattern <code>x</code>. In the latter case, 
the points <code>(x$x[i], x$y[i])</code> for which 
<code>subset[i]=TRUE</code> will be retained, and the others
will be deleted.
</p>
<p>The argument <code>j</code>, if present, should be a spatial window.
The pattern inside the region will be retained.
<em>Line segments that cross the boundary of the window
are deleted</em> in the current implementation.
</p>
<p>The argument <code>drop</code> determines whether to remove
unused levels of a factor, if the point pattern is multitype
(i.e. the marks are a factor) or if the marks are a data frame or hyperframe
in which some of the columns are factors.
</p>
<p>The argument <code>snip</code> specifies what to do with segments of
the network which cross the boundary of the window <code>j</code>. 
If <code>snip=FALSE</code>, such segments are simply deleted.  
If <code>snip=TRUE</code> (the default), such segments are cut into pieces by the
boundary of <code>j</code>, and those pieces which lie inside the window
<code>ji</code> are included in the resulting network. 
</p>
<p>Use <code><a href="spatstat.geom.html#topic+unmark">unmark</a></code> to remove all the marks in a marked point
pattern, and <code><a href="#topic+subset.lpp">subset.lpp</a></code> to remove only some columns of marks. 
</p>


<h3>Value</h3>

<p>A point pattern on a linear network (of class <code>"lpp"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and
Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lpp">lpp</a></code>,
<code><a href="#topic+subset.lpp">subset.lpp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Chicago crimes data - remove cases of assault
  chicago[marks(chicago) != "assault"]
  # equivalent to subset(chicago, select=-assault)

  # spatial window subset
  B &lt;- owin(c(350, 700), c(600, 1000))
  plot(chicago)
  plot(B, add=TRUE, lty=2, border="red", lwd=3)
  op &lt;- par(mfrow=c(1,2), mar=0.6+c(0,0,1,0))
  plot(B, main="chicago[B, snip=FALSE]", lty=3, border="red")
  plot(chicago[, B, snip=FALSE], add=TRUE)
  plot(B, main="chicago[B, snip=TRUE]", lty=3, border="red")
  plot(chicago[, B, snip=TRUE], add=TRUE)
  par(op)
</code></pre>

<hr>
<h2 id='fitted.lppm'>
Fitted Intensity for Point Process on Linear Network
</h2><span id='topic+fitted.lppm'></span>

<h3>Description</h3>

<p>Given a point process model fitted to a point pattern on a linear network,
compute the fitted intensity of the model
at the points of the pattern,
or at the points of the quadrature scheme used to fit the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lppm'
fitted(object, ...,
                      dataonly = FALSE, new.coef = NULL,
		      leaveoneout = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.lppm_+3A_object">object</code></td>
<td>

<p>Fitted point process model on a linear network
(object of class <code>"lppm"</code>).
</p>
</td></tr>
<tr><td><code id="fitted.lppm_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="fitted.lppm_+3A_dataonly">dataonly</code></td>
<td>

<p>Logical value indicating whether to computed fitted intensities
at the points of the original point pattern dataset
(<code>dataonly=TRUE</code>)
or at all the quadrature points of the quadrature scheme
used to fit the model (<code>dataonly=FALSE</code>, the default).
</p>
</td></tr>
<tr><td><code id="fitted.lppm_+3A_new.coef">new.coef</code></td>
<td>

<p>Numeric vector of parameter values to replace the 
fitted model parameters <code>coef(object)</code>.
</p>
</td></tr>
<tr><td><code id="fitted.lppm_+3A_leaveoneout">leaveoneout</code></td>
<td>

<p>Logical. If <code>TRUE</code> the fitted value at each data
point will be computed using a leave-one-out method. See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function <code><a href="stats.html#topic+fitted">fitted</a></code>
for the class <code>"lppm"</code> of fitted point process models on a linear
network.
</p>
<p>The locations <code class="reqn">u</code> at which the fitted conditional intensity/trend
is evaluated, are the points of the
quadrature scheme used to fit the model in <code><a href="spatstat.model.html#topic+ppm">ppm</a></code>.
They include the data points (the points of the original point pattern
dataset <code>x</code>) and other &ldquo;dummy&rdquo; points 
in the window of observation.
</p>
<p>If <code>leaveoneout=TRUE</code>, fitted values will be computed
for the data points only, using a &lsquo;leave-one-out&rsquo; rule: 
the fitted value at <code>X[i]</code> is effectively computed by
deleting this point from the data and re-fitting the model to the
reduced pattern <code>X[-i]</code>, then predicting the value at
<code>X[i]</code>. (Instead of literally performing this calculation,
we apply a Taylor approximation using the influence function
computed in <code><a href="spatstat.model.html#topic+dfbetas.ppm">dfbetas.ppm</a></code>. 
</p>


<h3>Value</h3>

<p>A vector containing the values of the fitted spatial trend.
</p>
<p>Entries in this vector correspond to the quadrature points (data or
dummy points) used to fit the model. 
The quadrature points can be extracted from <code>object</code>
by <code>union.quad(quad.ppm(object))</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lppm">lppm</a></code>,
<code><a href="#topic+predict.lppm">predict.lppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   fit &lt;- lppm(spiders~x+y)
   a &lt;- fitted(fit)
   b &lt;- fitted(fit, dataonly=TRUE)
</code></pre>

<hr>
<h2 id='heatkernelapprox'>
Approximation to Heat Kernel on Linear Network at Source Point
</h2><span id='topic+heatkernelapprox'></span>

<h3>Description</h3>

<p>Computes an approximation to the value of the heat kernel on a network
evaluated at its source location.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heatkernelapprox(X, sigma, nmax = 20, floored=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="heatkernelapprox_+3A_x">X</code></td>
<td>

<p>Point pattern on a linear network (object of class <code>"lpp"</code>).
</p>
</td></tr>
<tr><td><code id="heatkernelapprox_+3A_sigma">sigma</code></td>
<td>

<p>Numeric. Bandwidth for kernel.
</p>
</td></tr>
<tr><td><code id="heatkernelapprox_+3A_nmax">nmax</code></td>
<td>

<p>Number of terms to be used in the sum.
</p>
</td></tr>
<tr><td><code id="heatkernelapprox_+3A_floored">floored</code></td>
<td>

<p>Logical. If <code>TRUE</code>, all values are constrained to be
greater than or equal to <code class="reqn">1/L</code> where <code class="reqn">L</code> is the total
length of the network. This the exact value of the heat kernel
when the bandwidth is infinite.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each point <code>X[i]</code> in the pattern <code>X</code>, this algorithm computes an
approximation to the value of the heat kernel with source point
<code>X[i]</code> evaluated at the same location.
</p>
<p>The heat kernel <code class="reqn">\kappa(u,v)</code> for a source location <code class="reqn">u</code>
evaluated at location <code class="reqn">v</code>
can be expressed as an infinite sum of contributions
from all possible paths from <code class="reqn">u</code> to <code class="reqn">v</code>.
This algorithm applies to the special case <code class="reqn">u=v</code> where the source
point and the query point are the same.
</p>
<p>The algorithm computes an approximation to <code class="reqn">\kappa(u,u)</code>
by taking only the contributions from paths 
which (a) remain in the line segment containing the point <code class="reqn">u</code> and
(b) visit a vertex at most <code>nmax</code> times. 
</p>


<h3>Value</h3>

<p>Numeric vector with one entry for each point in <code>X</code>.
</p>


<h3>Author(s)</h3>

<p>Greg McSwiggan and Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.geom.html#topic+hotrod">hotrod</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- runiflpp(3,simplenet)
  heatkernelapprox(X, 0.5)
</code></pre>

<hr>
<h2 id='identify.lpp'>Identify Points in a Point Pattern on a Linear Network</h2><span id='topic+identify.lpp'></span>

<h3>Description</h3>

<p>If a point pattern on a network is plotted in the graphics window,
this function will find the point of the pattern which is nearest to
the mouse position, and print its mark value (or its serial number
if there is no mark).
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'lpp'
identify(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="identify.lpp_+3A_x">x</code></td>
<td>

<p>A point pattern
on a linear network
(object of class <code>"lpp"</code>).
</p>
</td></tr>
<tr><td><code id="identify.lpp_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="graphics.html#topic+identify.default">identify.default</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function <code><a href="graphics.html#topic+identify">identify</a></code>
for point patterns on a linear network (objects of class <code>"lpp"</code>).
</p>
<p>The point pattern <code>x</code> should first be plotted
using <code><a href="#topic+plot.lpp">plot.lpp</a></code>.
Then <code>identify(x)</code>
reads the position of the graphics pointer each time the
left mouse button is pressed.  It then finds 
the point of the pattern <code>x</code> closest to the mouse position.
If this closest point is sufficiently close to the mouse pointer,
its index (and its mark if any) 
will be returned as part of the value of the call.
</p>
<p>Each time a point of the pattern is identified,
text will be displayed next to the point,
showing its serial number (if <code>x</code> is unmarked)
or its mark value (if <code>x</code> is marked).
</p>


<h3>Value</h3>

<p>If <code>x</code> is unmarked, the result is 
a vector containing the serial numbers of the points in the pattern
<code>x</code> that were identified.
If <code>x</code> is marked, the result is a 
2-column matrix, the first column containing the serial numbers
and the second containing the marks for these points.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.geom.html#topic+identify.ppp">identify.ppp</a></code>,
<code><a href="graphics.html#topic+identify">identify</a></code>,
<code><a href="#topic+clicklpp">clicklpp</a></code>
</p>

<hr>
<h2 id='insertVertices'>
Insert New Vertices in a Linear Network
</h2><span id='topic+insertVertices'></span>

<h3>Description</h3>

<p>Adds new vertices to a linear network
at specified locations along the network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>insertVertices(L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="insertVertices_+3A_l">L</code></td>
<td>

<p>Linear network (object of class <code>"linnet"</code>)
or point pattern on a linear network (object of class <code>"lpp"</code>).
</p>
</td></tr>
<tr><td><code id="insertVertices_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to <code><a href="#topic+as.lpp">as.lpp</a></code>
specifying the positions of the new vertices along the network.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function adds new vertices at locations along an existing
linear network.
</p>
<p>The argument <code>L</code> can be either a linear network (class
<code>"linnet"</code>) or some other object that includes a linear network.
</p>
<p>The new vertex locations can be specified either as a
point pattern (class <code>"lpp"</code> or <code>"ppp"</code>)
or using coordinate vectors <code>x,y</code> or <code>seg,tp</code>
or <code>x,y,seg,tp</code> as explained in the help for <code><a href="#topic+as.lpp">as.lpp</a></code>.
</p>
<p>This function breaks the existing line segments
of <code>L</code> into pieces at the locations specified by
the coordinates <code>seg,tp</code> and creates new vertices at these
locations.
</p>
<p>The result is the modified object, with an attribute <code>"id"</code> such that
the <code>i</code>th added vertex has become the
<code>id[i]</code>th vertex of the new network.
</p>


<h3>Value</h3>

<p>An object of the same class as <code>L</code> representing the result of
adding the new vertices.
The result also has an attribute <code>"id"</code> as described in Details.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley
</p>


<h3>See Also</h3>

<p><code><a href="#topic+addVertices">addVertices</a></code> to create new vertices at locations which
are not yet on the network.
</p>
<p><code><a href="#topic+as.lpp">as.lpp</a></code>,
<code><a href="#topic+linnet">linnet</a></code>,
<code><a href="#topic+methods.linnet">methods.linnet</a></code>,
<code><a href="#topic+joinVertices">joinVertices</a></code>,
<code><a href="#topic+thinNetwork">thinNetwork</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   opa &lt;- par(mfrow=c(1,3), mar=rep(0,4))
   simplenet

   plot(simplenet, main="")
   plot(vertices(simplenet), add=TRUE)

   # add two new vertices at specified local coordinates
   L &lt;- insertVertices(simplenet, seg=c(3,7), tp=c(0.2, 0.5))
   L
   plot(L, main="")
   plot(vertices(L), add=TRUE)
   id &lt;- attr(L, "id")
   id
   plot(vertices(L)[id], add=TRUE, pch=16)

   # add new vertices at three randomly-generated points
   X &lt;- runiflpp(3, simplenet)
   LL &lt;- insertVertices(simplenet, X)
   plot(LL, main="")
   plot(vertices(LL), add=TRUE)
   ii &lt;- attr(LL, "id")
   plot(vertices(LL)[ii], add=TRUE, pch=16)
   par(opa)
</code></pre>

<hr>
<h2 id='integral.linim'>
Integral on a Linear Network
</h2><span id='topic+integral.linim'></span><span id='topic+integral.linfun'></span>

<h3>Description</h3>

<p>Computes the integral (total value) of a function or pixel image
over a linear network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'linim'
integral(f, domain=NULL, weight=NULL, ...)

## S3 method for class 'linfun'
integral(f, domain=NULL, weight=NULL, ..., delta, nd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="integral.linim_+3A_f">f</code></td>
<td>

<p>A pixel image on a linear network (class <code>"linim"</code>)
or a function on a linear network (class <code>"linfun"</code>).
</p>
</td></tr>
<tr><td><code id="integral.linim_+3A_domain">domain</code></td>
<td>

<p>Optional window specifying the domain of integration.
Alternatively a tessellation.
</p>
</td></tr>
<tr><td><code id="integral.linim_+3A_weight">weight</code></td>
<td>

<p>Optional numerical weight function for the integration.
A pixel image (object of class <code>"linim"</code> or <code>"im"</code>),
a function (object of class <code>"linfun"</code>, <code>"funxy"</code> or a
a <code>function(x,y)</code>) or anything acceptable to <code><a href="#topic+as.linim">as.linim</a></code>.
</p>
</td></tr>
<tr><td><code id="integral.linim_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="integral.linim_+3A_delta">delta</code></td>
<td>

<p>Optional. 
The step length (in coordinate units)
for computing the approximate integral.
A single positive number.
</p>
</td></tr>
<tr><td><code id="integral.linim_+3A_nd">nd</code></td>
<td>

<p>Optional. 
Integer giving the approximate number of sample points on the network.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The integral (total value of the function over the network) is calculated.
</p>
<p>If <code>domain</code> is a window (class <code>"owin"</code>) then the integration
will be restricted to this window. If <code>domain</code> is a tessellation
(class <code>"tess"</code>) then the integral of <code>f</code> in each
tile of <code>domain</code> will be computed.
</p>
<p>If <code>weight</code> is given, effectively the integral of <code>weight * f</code>
is computed.
</p>


<h3>Value</h3>

<p>A single numeric or complex value
(or a vector of such values if <code>domain</code> is a tessellation).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linim">linim</a></code>,
<code><a href="spatstat.geom.html#topic+integral.im">integral.im</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # make some data
  xcoord &lt;- linfun(function(x,y,seg,tp) { x }, simplenet)
  integral(xcoord)
  X &lt;- as.linim(xcoord)
  integral(X)

  # integrals inside each tile of a tessellation
  A &lt;- quadrats(Frame(simplenet), 3)
  integral(X, A)
</code></pre>

<hr>
<h2 id='intensity.lpp'>
Empirical Intensity of Point Pattern on Linear Network
</h2><span id='topic+intensity.lpp'></span>

<h3>Description</h3>

<p>Computes the average number of points per unit length
in a point pattern on a linear network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpp'
intensity(X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intensity.lpp_+3A_x">X</code></td>
<td>

<p>A point pattern on a linear network (object of class <code>"lpp"</code>).
</p>
</td></tr>
<tr><td><code id="intensity.lpp_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function <code><a href="spatstat.geom.html#topic+intensity">intensity</a></code>
It computes the empirical intensity of a point pattern
on a linear network (object of class <code>"lpp"</code>),
i.e. the average density of points per unit length.
</p>
<p>If the point pattern is multitype, the intensities of the
different types are computed separately.
</p>


<h3>Value</h3>

<p>A numeric value (giving the intensity) or numeric vector
(giving the intensity for each possible type).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.geom.html#topic+intensity">intensity</a></code>, 
<code><a href="spatstat.geom.html#topic+intensity.ppp">intensity.ppp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  intensity(chicago)
</code></pre>

<hr>
<h2 id='intersect.lintess'>
Intersection of Tessellations on a Linear Network
</h2><span id='topic+intersect.lintess'></span>

<h3>Description</h3>

<p>Yields the intersection (common refinement) of two tessellations
on a linear network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intersect.lintess(X, Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intersect.lintess_+3A_x">X</code>, <code id="intersect.lintess_+3A_y">Y</code></td>
<td>

<p>Tessellations (objects of class <code>"lintess"</code>)
on the same linear network, or data that define such tessellations.
See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>X</code> and <code>Y</code> should be tessellations on a linear network
(objects of class <code>"lintess"</code>) and should be defined on the
same network. The algorithm finds the common refinement of the
two tessellations. Each tile in the resulting tessellation
is the intersection of a tile of <code>X</code> with a tile of <code>Y</code>.
</p>
<p>Alternatively, one of the arguments <code>X</code> or <code>Y</code> 
can be a two-dimensional tessellation (object of class
<code>"tess"</code>) while the other argument is a network or a tessellation
on a network. The two-dimensional tessellation will be intersected
with the network to produce a tessellation on the network, then
intersected with the other tessellation on the network.
</p>


<h3>Value</h3>

<p>Another tessellation (object of class <code>"lintess"</code>)
on the same linear network as <code>X</code> and <code>Y</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lintess">lintess</a></code>,
<code><a href="#topic+divide.linnet">divide.linnet</a></code>,
<code><a href="#topic+chop.linnet">chop.linnet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- divide.linnet(runiflpp(4, simplenet))
  Y &lt;- divide.linnet(runiflpp(3, simplenet))
  opa &lt;- par(mfrow=c(1,3))
  plot(X)
  plot(Y)
  plot(intersect.lintess(X,Y))
  par(opa)
</code></pre>

<hr>
<h2 id='is.connected.linnet'>
Determine Whether a Linear Network is Connected
</h2><span id='topic+is.connected.linnet'></span>

<h3>Description</h3>

<p>Determine whether a linear network is 
topologically connected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'linnet'
is.connected(X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.connected.linnet_+3A_x">X</code></td>
<td>

<p>A linear network (object of class <code>"linnet"</code>).
</p>
</td></tr>
<tr><td><code id="is.connected.linnet_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+connected.linnet">connected.linnet</a></code> to determine the
connected components.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The command <code>is.connected(X)</code> returns <code>TRUE</code> if the network
<code>X</code> consists of a single, topologically-connected piece,
and returns <code>FALSE</code> if <code>X</code> consists of several pieces
which are not joined together.
</p>
<p>The function <code><a href="spatstat.geom.html#topic+is.connected">is.connected</a></code> is generic,
with methods for several classes.
This help file documents the 
method for linear networks, <code>is.connected.linnet</code>.
</p>


<h3>Value</h3>

<p>A logical value.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.geom.html#topic+is.connected">is.connected</a></code>,
<code><a href="spatstat.geom.html#topic+connected">connected</a></code>,
<code><a href="#topic+connected.lpp">connected.lpp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  is.connected(simplenet)
</code></pre>

<hr>
<h2 id='is.marked.lppm'>Test Whether A Point Process Model is Marked</h2><span id='topic+is.marked.lppm'></span>

<h3>Description</h3>

<p>Tests whether a fitted point process model on a network involves &ldquo;marks&rdquo;
attached to the points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'lppm'
is.marked(X, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.marked.lppm_+3A_x">X</code></td>
<td>

<p>Fitted point process model on a linear networ
(object of class <code>"lppm"</code>)
usually obtained from <code><a href="#topic+lppm">lppm</a></code>.
</p>
</td></tr>
<tr><td><code id="is.marked.lppm_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&ldquo;Marks&rdquo; are observations attached to each point of a point pattern.
For example the <code><a href="spatstat.data.html#topic+chicago">chicago</a></code> dataset contains
the locations of crimes, each crime location
being marked by the type of crime.
</p>
<p>The argument <code>X</code> is a fitted point process model on a network
(an object of class <code>"lppm"</code>) typically obtained
by fitting a model to point pattern data using <code><a href="#topic+lppm">lppm</a></code>.
</p>
<p>This function returns <code>TRUE</code> if the <em>original data</em>
(to which the model <code>X</code> was fitted) were a marked point pattern.
</p>
<p>Note that this is not the same as testing whether the
model involves terms that depend on the marks (i.e. whether the
fitted model ignores the marks in the data).
See the Examples for a trick to do this.
</p>
<p>If this function returns <code>TRUE</code>, the implications are
(for example) that
any simulation of this model will require simulation of random marks
as well as random point locations.
</p>


<h3>Value</h3>

<p>Logical value, equal to <code>TRUE</code> if
<code>X</code> is a model that was fitted to a marked point pattern dataset.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.geom.html#topic+is.marked">is.marked</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  fit &lt;- lppm(chicago ~ x)
  is.marked(fit)
  ## result is TRUE, i.e. the data are marked

  ## To check whether the model involves marks:
  "marks" %in% spatstat.utils::variablesinformula(formula(fit))
</code></pre>

<hr>
<h2 id='is.multitype.lpp'>Test Whether A Point Pattern on a Network is Multitype</h2><span id='topic+is.multitype.lpp'></span>

<h3>Description</h3>

<p>Tests whether a point pattern on a network has &ldquo;marks&rdquo;
attached to the points which classify the points into several types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'lpp'
is.multitype(X, na.action="warn", ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.multitype.lpp_+3A_x">X</code></td>
<td>

<p>Point pattern on a linear networl
(object of class <code>"lpp"</code>).
</p>
</td></tr>
<tr><td><code id="is.multitype.lpp_+3A_na.action">na.action</code></td>
<td>

<p>String indicating what to do if <code>NA</code> values are
encountered amongst the marks.
Options are <code>"warn"</code>, <code>"fatal"</code> and <code>"ignore"</code>.
</p>
</td></tr>
<tr><td><code id="is.multitype.lpp_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&ldquo;Marks&rdquo; are observations attached to each point of a point pattern.
For example the <code><a href="spatstat.data.html#topic+chicago">chicago</a></code> dataset contains
the locations of crimes, each crime location
being marked by the type of crime.
</p>
<p>This function tests whether the point pattern <code>X</code>
contains or involves marked points, <b>and</b> that the
marks are a factor.
It is a method for the generic function
<code><a href="spatstat.geom.html#topic+is.multitype">is.multitype</a></code>.
</p>
<p>The argument <code>na.action</code> determines what action will be taken
if the point pattern has a vector of marks but some or all of the
marks are <code>NA</code>. Options are   <code>"fatal"</code> to cause a fatal
error; <code>"warn"</code> to issue a warning and then return <code>TRUE</code>;
and <code>"ignore"</code> to take no action except returning <code>TRUE</code>.
</p>


<h3>Value</h3>

<p>Logical value, equal to <code>TRUE</code> if <code>X</code> is a multitype point pattern.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.geom.html#topic+is.multitype">is.multitype</a></code>,
<code><a href="#topic+is.multitype.lppm">is.multitype.lppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   is.multitype(chicago)
</code></pre>

<hr>
<h2 id='is.multitype.lppm'>Test Whether A Point Process Model is Multitype</h2><span id='topic+is.multitype.lppm'></span>

<h3>Description</h3>

<p>Tests whether a fitted point process model on a network involves &ldquo;marks&rdquo;
attached to the points that classify the points into several types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'lppm'
is.multitype(X, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.multitype.lppm_+3A_x">X</code></td>
<td>

<p>Fitted point process model on a linear network
(object of class <code>"lppm"</code>)
usually obtained from <code><a href="#topic+lppm">lppm</a></code>.
</p>
</td></tr>
<tr><td><code id="is.multitype.lppm_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&ldquo;Marks&rdquo; are observations attached to each point of a point pattern.
For example the <code><a href="spatstat.data.html#topic+chicago">chicago</a></code> dataset contains
the locations of crimes, each crime location
being marked by the type of crime.
</p>
<p>The argument <code>X</code> is a fitted point process model
on a network (an object of class <code>"lppm"</code>) typically obtained
by fitting a model to point pattern data on a network
using <code><a href="#topic+lppm">lppm</a></code>.
</p>
<p>This function returns <code>TRUE</code> if the <em>original data</em>
(to which the model <code>X</code> was fitted) were a multitype point pattern.
</p>
<p>Note that this is not the same as testing whether the
model involves terms that depend on the marks (i.e. whether the
fitted model ignores the marks in the data).
See the Examples for a trick for doing this.
</p>
<p>If this function returns <code>TRUE</code>, the implications are
(for example) that
any simulation of this model will require simulation of random marks
as well as random point locations.
</p>


<h3>Value</h3>

<p>Logical value, equal to <code>TRUE</code> if
<code>X</code> is a model that was fitted to a multitype point pattern dataset.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.geom.html#topic+is.multitype">is.multitype</a></code>,
<code><a href="#topic+is.multitype.lpp">is.multitype.lpp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  fit &lt;- lppm(chicago ~ x)
  is.multitype(fit)
  # TRUE because chicago data are multitype

  ## To check whether the model involves marks:
  "marks" %in% spatstat.utils::variablesinformula(formula(fit))
</code></pre>

<hr>
<h2 id='is.stationary.lppm'>
Recognise Stationary and Poisson Point Process Models on a Network
</h2><span id='topic+is.stationary.lppm'></span><span id='topic+is.poisson.lppm'></span>

<h3>Description</h3>

<p>Given a point process model that has been fitted to data on a network,
determine whether the model is a stationary point process,
and whether it is a Poisson point process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lppm'
is.stationary(x)

## S3 method for class 'lppm'
is.poisson(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.stationary.lppm_+3A_x">x</code></td>
<td>

<p>A fitted spatial point process model on a linear network
(object of class <code>"lppm"</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>x</code> represents a fitted spatial point process model
on a linear network.
</p>
<p><code>is.stationary(x)</code> returns <code>TRUE</code> if <code>x</code> represents
a stationary point process, and <code>FALSE</code> if not.
</p>
<p><code>is.poisson(x)</code> returns <code>TRUE</code> if <code>x</code> represents
a Poisson point process, and <code>FALSE</code> if not.
</p>
<p>The functions <code><a href="spatstat.random.html#topic+is.stationary">is.stationary</a></code>
and <code><a href="spatstat.random.html#topic+is.poisson">is.poisson</a></code> are generic,
with methods for many classes of models.
</p>


<h3>Value</h3>

<p>A logical value.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.geom.html#topic+is.marked">is.marked</a></code>
to determine whether a model is a marked
point process. 
</p>
<p><code><a href="spatstat.random.html#topic+is.stationary">is.stationary</a></code>, 
<code><a href="spatstat.random.html#topic+is.poisson">is.poisson</a></code> for generics.
</p>
<p><code><a href="#topic+summary.lppm">summary.lppm</a></code> for detailed information.
</p>
<p>Model-fitting function
<code><a href="#topic+lppm">lppm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  fit &lt;- lppm(spiders ~ x)
  is.stationary(fit)
  is.poisson(fit)
</code></pre>

<hr>
<h2 id='joinVertices'>
Join Vertices in a Network
</h2><span id='topic+joinVertices'></span>

<h3>Description</h3>

<p>Join the specified vertices in a linear network, creating a new network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>joinVertices(L, from, to, marks=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="joinVertices_+3A_l">L</code></td>
<td>

<p>A linear network (object of class <code>"linnet"</code>)
or point pattern on a linear network (object of class <code>"lpp"</code>).
</p>
</td></tr>
<tr><td><code id="joinVertices_+3A_from">from</code>, <code id="joinVertices_+3A_to">to</code></td>
<td>

<p>Integers, or integer vectors of equal length,
specifying the vertices which should be joined.
Alternatively <code>from</code> can be a 2-column matrix of integers
and <code>to</code> is missing or <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="joinVertices_+3A_marks">marks</code></td>
<td>

<p>Optional vector or data frame of values associated with the new edges.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Vertices of the network are numbered by their order of appearance
in the point pattern <code>vertices(L)</code>.
</p>
<p>If <code>from</code> and <code>to</code> are single integers, then the
pair of vertices numbered <code>from</code> and <code>to</code> will be
joined to make a new segment of the network.
If <code>from</code> and <code>to</code> are vectors of integers, then
vertex <code>from[i]</code> will be joined to vertex <code>to[i]</code> for
each <code>i = 1,2,..</code>.
</p>
<p>If <code>L</code> is a network (class <code>"linnet"</code>), the result is
another network, created by adding new segments.
If <code>L</code> is a point pattern on a network (class <code>"lpp"</code>), the
result is another point pattern object, created by adding new segments to
the underlying network, and retaining the points.
</p>
<p>In the resulting object, the new line segments are appended to the
existing list of line segments.
</p>


<h3>Value</h3>

<p>A linear network (object of class <code>"linnet"</code>)
or point pattern on a linear network (object of class <code>"lpp"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linnet">linnet</a></code>, <code><a href="#topic+methods.linnet">methods.linnet</a></code>,
<code><a href="#topic+thinNetwork">thinNetwork</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  snet &lt;- joinVertices(simplenet, 4, 8)
  plot(solist(simplenet, snet), main="")
  X &lt;- runiflpp(3, simplenet)
  Y &lt;- joinVertices(X, 4, 8)
</code></pre>

<hr>
<h2 id='lineardirichlet'>
Dirichlet Tessellation on a Linear Network
</h2><span id='topic+lineardirichlet'></span>

<h3>Description</h3>

<p>Given a point pattern on a linear network, compute the Dirichlet
(or Voronoi or Thiessen) tessellation induced by the points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lineardirichlet(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lineardirichlet_+3A_x">X</code></td>
<td>

<p>Point pattern on a linear network (object of class <code>"lpp"</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Dirichlet tessellation induced by a point pattern <code>X</code>
on a linear network <code>L</code>
is a partition of <code>L</code> into subsets. The subset <code>L[i]</code>
associated with the data point <code>X[i]</code> is the part of <code>L</code>
lying closer to <code>X[i]</code> than to any other data point <code>X[j]</code>,
where distance is measured by the shortest path.
</p>


<h3>Value</h3>

<p>A tessellation on a linear network
(object of class <code>"lintess"</code>).
</p>


<h3>Missing tiles</h3>

<p>If the linear network is not connected, and if one of the connected
components contains no data points, then the Dirichlet tessellation
is mathematically undefined inside this component.
The resulting tessellation object includes
a tile with label <code>NA</code>, which contains this component of the network.
A plot of the tessellation will not show this tile. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lintess">lintess</a></code>.
</p>
<p>For the Dirichlet tessellation in two-dimensional space,
see <code><a href="spatstat.geom.html#topic+dirichlet">dirichlet</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- runiflpp(5, simplenet)
  plot(lineardirichlet(X), lwd=3)
  points(X)
</code></pre>

<hr>
<h2 id='lineardisc'>
Compute Disc of Given Radius in Linear Network
</h2><span id='topic+lineardisc'></span><span id='topic+lineardisclength'></span><span id='topic+countends'></span>

<h3>Description</h3>

<p>Computes the &lsquo;disc&rsquo; of given radius and centre
in a linear network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  lineardisc(L, x = locator(1), r, plotit = TRUE,
             cols=c("blue", "red","green"), add=TRUE)

  lineardisclength(L, x = locator(1), r)

  countends(L, x = locator(1), r, toler=NULL, internal=list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lineardisc_+3A_l">L</code></td>
<td>

<p>Linear network (object of class <code>"linnet"</code>).
</p>
</td></tr>
<tr><td><code id="lineardisc_+3A_x">x</code></td>
<td>

<p>Location of centre of disc.
Either a point pattern (object of class <code>"ppp"</code>)
containing exactly 1 point, or a numeric vector of length 2.
</p>
</td></tr>
<tr><td><code id="lineardisc_+3A_r">r</code></td>
<td>

<p>Radius of disc.
</p>
</td></tr>
<tr><td><code id="lineardisc_+3A_plotit">plotit</code></td>
<td>

<p>Logical. Whether to plot the disc.
</p>
</td></tr>
<tr><td><code id="lineardisc_+3A_add">add</code></td>
<td>

<p>Logical. If <code>add=TRUE</code> (the default),
the disc will be plotted on the current plot frame.
If <code>add=FALSE</code>, a new plot frame will be started,
the entire network will be displayed, and then
the disc will be plotted over this.
</p>
</td></tr>
<tr><td><code id="lineardisc_+3A_cols">cols</code></td>
<td>

<p>Colours for plotting the disc. A numeric or character vector of
length 3 specifying the colours of the disc centre, disc lines and
disc endpoints respectively.
</p>
</td></tr>
<tr><td><code id="lineardisc_+3A_toler">toler</code></td>
<td>

<p>Optional. Distance threshold for <code>countends</code>. See Details.
There is a sensible default.
</p>
</td></tr>
<tr><td><code id="lineardisc_+3A_internal">internal</code></td>
<td>
<p>Argument for internal use by the package.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &lsquo;disc&rsquo; <code class="reqn">B(u,r)</code> of centre <code class="reqn">x</code> and radius <code class="reqn">r</code>
in a linear network <code class="reqn">L</code> is the set of all points
<code class="reqn">u</code> in <code class="reqn">L</code> such that the shortest path distance from <code class="reqn">x</code>
to <code class="reqn">u</code> is less than or equal to <code class="reqn">r</code>. This is a union of line
segments contained in <code class="reqn">L</code>.
</p>
<p>The <em>relative boundary</em> of the disc <code class="reqn">B(u,r)</code>
is the set of points <code class="reqn">v</code> such that the shortest path distance from
<code class="reqn">x</code> to <code class="reqn">u</code> is <em>equal</em> to <code class="reqn">r</code>.
</p>
<p>The function <code>lineardisc</code> computes the
disc of radius <code class="reqn">r</code> and its relative boundary,
optionally plots them, and returns them.
The faster function <code>lineardisclength</code> computes only the total
length of the disc, and <code>countends</code> computes only the number of
endpoints of the disc.
</p>
<p>Note that <code>countends</code> requires the linear network <code>L</code>
to be given in the non-sparse matrix format (see the argument
<code>sparse</code> in <code><a href="#topic+linnet">linnet</a></code> or <code><a href="#topic+as.linnet">as.linnet</a></code>)
while <code>lineardisc</code> and <code>lineardisclength</code> accept
both sparse and non-sparse formats.
</p>
<p>The optional threshold <code>toler</code> is used to suppress numerical
errors in <code>countends</code>.
If the distance from <code class="reqn">u</code> to a network vertex <code class="reqn">v</code>
is between <code>r-toler</code> and <code>r+toler</code>, the vertex
will be treated as lying on the relative boundary.    
</p>


<h3>Value</h3>

<p>The value of <code>lineardisc</code> is a list with two entries:
</p>
<table>
<tr><td><code>lines</code></td>
<td>
<p>Line segment pattern (object of class <code>"psp"</code>)
representing the interior disc</p>
</td></tr>
<tr><td><code>endpoints</code></td>
<td>
<p>Point pattern (object of class <code>"ppp"</code>)
representing the relative boundary of the disc.
</p>
</td></tr>
</table>
<p>The value of <code>lineardisclength</code> is a single number
giving the total length of the disc.
</p>
<p>The value of <code>countends</code> is an integer giving the number of
points in the relative boundary.
</p>


<h3>Author(s)</h3>

<p>Ang Qi Wei <a href="mailto:aqw07398@hotmail.com">aqw07398@hotmail.com</a> and
Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>References</h3>

<p>Ang, Q.W. (2010)
<em>Statistical methodology for events on a network</em>.
Master's thesis, School of Mathematics and Statistics, University of
Western Australia.
</p>
<p>Ang, Q.W., Baddeley, A. and Nair, G. (2012)
Geometrically corrected second-order analysis of 
events on a linear network, with applications to
ecology and criminology.
<em>Scandinavian Journal of Statistics</em> <b>39</b>, 591&ndash;617.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linnet">linnet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    # letter 'A' 
    v &lt;- ppp(x=(-2):2, y=3*c(0,1,2,1,0), c(-3,3), c(-1,7))
    edg &lt;- cbind(1:4, 2:5)
    edg &lt;- rbind(edg, c(2,4))
    letterA &lt;- linnet(v, edges=edg)
    plot(letterA)

   di &lt;- lineardisc(letterA, c(0,3), 1.6)
   di

   # count the endpoints more efficiently
   countends(letterA, c(0,3), 1.6)
   # cross-check 
   npoints(di$endpoints)

   # measure the length more efficiently
   lineardisclength(letterA, c(0,3), 1.6)
   # cross-check
   sum(lengths_psp(di$lines))
</code></pre>

<hr>
<h2 id='linearJinhom'>
Inhomogeneous Linear J-function for Point Processes on Linear Networks</h2><span id='topic+linearJinhom'></span>

<h3>Description</h3>

<p>Computes an estimate of the inhomogeneous linear <code class="reqn">J</code>-function
for a point pattern on a linear network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linearJinhom(X, lambda = NULL, lmin=NULL,
             ...,
             r=NULL, rmax=NULL,
             distance=c("path","euclidean"),
             densitymethod=c("kernel", "Voronoi"),
             sigma=bw.scott.iso,
             f=0.2, nrep=200, ngrid=256) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linearJinhom_+3A_x">X</code></td>
<td>

<p>Point pattern on linear network (object of class <code>"lpp"</code>).
</p>
</td></tr>
<tr><td><code id="linearJinhom_+3A_lambda">lambda</code></td>
<td>

<p>Intensity values for the point pattern. Either a numeric vector,
a <code>function</code>, a pixel image
(object of class <code>"im"</code> or <code>"linim"</code>) or
a fitted point process model (object of class <code>"ppm"</code>
or <code>"lppm"</code>).
</p>
</td></tr>
<tr><td><code id="linearJinhom_+3A_lmin">lmin</code></td>
<td>

<p>Optional. The minimum possible value of the intensity
over the network. A positive numerical value.
</p>
</td></tr>
<tr><td><code id="linearJinhom_+3A_r">r</code></td>
<td>

<p>Optional. Numeric vector of values of the function argument <code class="reqn">r</code>.
There is a sensible default.
</p>
</td></tr>
<tr><td><code id="linearJinhom_+3A_rmax">rmax</code></td>
<td>

<p>Optional. Numeric value specifying the largest desired value of <code class="reqn">r</code>.
There is a sensible default.
</p>
</td></tr>
<tr><td><code id="linearJinhom_+3A_distance">distance</code></td>
<td>

<p>A string (partially matched) specifying the
metric that will be used to measure distances between
points on the network: <code>distance="path"</code> is the shortest-path
distance, and <code>distance="euclidean"</code> is the Euclidean distance.
</p>
</td></tr>
<tr><td><code id="linearJinhom_+3A_densitymethod">densitymethod</code></td>
<td>

<p>String (partially matched) specifying the method that will be used to
estimate the intensity <code>lambda</code>, if <code>lambda</code> is not given:
<code>densitymethod="kernel"</code> specifies kernel smoothing
and <code>densitymethod="Voronoi"</code> specifies Voronoi estimation.
See Details.
</p>
</td></tr>
<tr><td><code id="linearJinhom_+3A_sigma">sigma</code></td>
<td>

<p>Smoothing bandwidth used to estimate <code>lambda</code> by kernel smoothing,
if <code>lambda</code> is not given and <code>densitymethod="kernel"</code>.
Either a numeric value, or a function that can be applied to
<code>X</code> to compute the bandwidth.
</p>
</td></tr>
<tr><td><code id="linearJinhom_+3A_f">f</code>, <code id="linearJinhom_+3A_nrep">nrep</code></td>
<td>

<p>Arguments passed to the algorithm for estimating the intensity
by Voronoi estimation, if <code>lambda</code> is not given
and <code>densitymethod="Voronoi"</code>. 
</p>
</td></tr>
<tr><td><code id="linearJinhom_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to the algorithms that estimate
the intensity, if <code>lambda</code> is not given.
</p>
</td></tr>
<tr><td><code id="linearJinhom_+3A_ngrid">ngrid</code></td>
<td>

<p>Integer specifying the number of sample points on the network that
will be used to estimate the inhomogeneous empty space function
<code class="reqn">F</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the geometrically corrected inhomogeneous
linear <code class="reqn">J</code>-function for point processes on linear networks
defined by Cronie et al (2020).
</p>
<p>The argument <code>lambda</code> is the (estimated) intensity of the
underlying point process. It should be either a numeric vector
(giving intensity values at the points of <code>X</code>), 
a <code>function</code>, a pixel image
(object of class <code>"im"</code> or <code>"linim"</code>) or
a fitted point process model (object of class <code>"ppm"</code>
or <code>"lppm"</code>).
</p>
<p>If <code>lambda</code> is not given, it will be estimated from the observed
point pattern <code>X</code> as follows:
</p>

<ul>
<li><p> If <code>densitymethod="kernel"</code>, the intensity will be
estimated by kernel smoothing, using the fast estimator
<code><a href="#topic+densityQuick.lpp">densityQuick.lpp</a></code>
introduced by Rakshit et al (2019). The smoothing bandwidth
<code>sigma</code> is required. It may be specified as a numeric value,
or as a function that can be applied to <code>X</code> to obtain a
bandwidth value. Examples of the latter include
<code><a href="spatstat.explore.html#topic+bw.scott.iso">bw.scott.iso</a></code>
and 
<code><a href="#topic+bw.lppl">bw.lppl</a></code>.
Additional arguments <code>...</code> will be passed to <code>sigma</code>
and to <code><a href="#topic+densityQuick.lpp">densityQuick.lpp</a></code>.
</p>
</li>
<li><p> If <code>densitymethod = "Voronoi"</code>, the intensity will be
estimated using the resample-smoothed Voronoi estimator
<code><a href="#topic+densityVoronoi.lpp">densityVoronoi.lpp</a></code>
introduced by Moradi et al (2019). The arguments <code>f</code> and <code>nrep</code> 
are passed to <code><a href="#topic+densityVoronoi.lpp">densityVoronoi.lpp</a></code>
and determine the retention probability and the number of
replicates, respectively. Additional arguments <code>...</code> will be
passed to <code><a href="#topic+densityVoronoi.lpp">densityVoronoi.lpp</a></code>.
</p>
</li></ul>



<h3>Value</h3>

<p>Function value table (object of class <code>"fv"</code>).
</p>


<h3>Author(s)</h3>

<p>Mehdi Moradi <a href="mailto:m2.moradi@yahoo.com">m2.moradi@yahoo.com</a> and Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Cronie, O., Moradi, M., and Mateu, J. (2020) Inhomogeneous higher-order
summary statistics for point processes on linear
networks. <em>Statistics and Computing</em> <b>30</b> (6) 1221&ndash;1239.
</p>
<p>Moradi, M., Cronie, 0., Rubak, E., Lachieze-Rey, R.,
Mateu, J. and Baddeley, A. (2019)
Resample-smoothing of Voronoi intensity estimators.
<em>Statistics and Computing</em> <b>29</b> (5) 995&ndash;1010.
</p>
<p>Rakshit, S., Davies, T., Moradi, M., 
McSwiggan, G., Nair, G., Mateu, J. and Baddeley, A. (2019)
Fast kernel smoothing of point patterns on a large
network using 2D convolution.
<em>International Statistical Review</em> <b>87</b> (3) 531&ndash;556.
DOI: 10.1111/insr.12327.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.explore.html#topic+bw.scott.iso">bw.scott.iso</a></code>,
<code><a href="#topic+bw.lppl">bw.lppl</a></code>,
<code><a href="#topic+densityVoronoi.lpp">densityVoronoi.lpp</a></code>,
<code><a href="#topic+densityQuick.lpp">densityQuick.lpp</a></code>
</p>
<p><code><a href="#topic+linearKinhom">linearKinhom</a></code>
</p>
<p><code><a href="spatstat.explore.html#topic+Jinhom">Jinhom</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  if(interactive()) {
    plot(linearJinhom(spiders))
  } else {
    bottomhalf &lt;- owin(c(0, 1125), c(0, 500))
    plot(linearJinhom(spiders[bottomhalf]))
  }
</code></pre>

<hr>
<h2 id='linearK'>
Linear K Function
</h2><span id='topic+linearK'></span>

<h3>Description</h3>

<p>Computes an estimate of the linear <code class="reqn">K</code> function
for a point pattern on a linear network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linearK(X, r=NULL, ..., correction="Ang", ratio=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linearK_+3A_x">X</code></td>
<td>

<p>Point pattern on linear network (object of class <code>"lpp"</code>).
</p>
</td></tr>
<tr><td><code id="linearK_+3A_r">r</code></td>
<td>

<p>Optional. Numeric vector of values of the function argument <code class="reqn">r</code>.
There is a sensible default.
</p>
</td></tr>
<tr><td><code id="linearK_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="linearK_+3A_correction">correction</code></td>
<td>

<p>Geometry correction.
Either <code>"none"</code> or <code>"Ang"</code>. See Details.
</p>
</td></tr>
<tr><td><code id="linearK_+3A_ratio">ratio</code></td>
<td>

<p>Logical. 
If <code>TRUE</code>, the numerator and denominator of
the estimate will also be saved,
for use in analysing replicated point patterns.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command computes the
linear <code class="reqn">K</code> function from point pattern data on a linear network.
</p>
<p>If <code>correction="none"</code>, the calculations do not include
any correction for the geometry of the linear network. The result is the
network <code class="reqn">K</code> function as defined by Okabe and Yamada (2001).
</p>
<p>If <code>correction="Ang"</code>, the pair counts are weighted using
Ang's correction (Ang, 2010; Ang et al, 2012). 
</p>


<h3>Value</h3>

<p>Function value table (object of class <code>"fv"</code>).
</p>


<h3>Author(s)</h3>

<p>Ang Qi Wei <a href="mailto:aqw07398@hotmail.com">aqw07398@hotmail.com</a> and Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Ang, Q.W. (2010) Statistical methodology for spatial point patterns
on a linear network. MSc thesis, University of Western Australia.
</p>
<p>Ang, Q.W., Baddeley, A. and Nair, G. (2012)
Geometrically corrected second-order analysis of 
events on a linear network, with applications to
ecology and criminology.
<em>Scandinavian Journal of Statistics</em> <b>39</b>, 591&ndash;617.
</p>
<p>Okabe, A. and Yamada, I. (2001) The K-function method on a network and
its computational implementation. <em>Geographical Analysis</em>
<b>33</b>, 271-290.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.explore.html#topic+compileK">compileK</a></code>,
<code><a href="#topic+lpp">lpp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- rpoislpp(5, simplenet)
  linearK(X)
  linearK(X, correction="none")
</code></pre>

<hr>
<h2 id='linearKcross'>
Multitype K Function (Cross-type) for Linear Point Pattern
</h2><span id='topic+linearKcross'></span>

<h3>Description</h3>

<p>For a multitype point pattern on a linear network,
estimate the multitype <code class="reqn">K</code> function
which counts the expected number of points of type <code class="reqn">j</code>
within a given distance of a point of type <code class="reqn">i</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linearKcross(X, i, j, r=NULL, ..., correction="Ang")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linearKcross_+3A_x">X</code></td>
<td>
<p>The observed point pattern, 
from which an estimate of the cross type <code class="reqn">K</code> function
<code class="reqn">K_{ij}(r)</code> will be computed.
An object of class <code>"lpp"</code> which 
must be a multitype point pattern (a marked point pattern
whose marks are a factor).
</p>
</td></tr>
<tr><td><code id="linearKcross_+3A_i">i</code></td>
<td>
<p>Number or character string identifying the type (mark value)
of the points in <code>X</code> from which distances are measured.
Defaults to the first level of <code>marks(X)</code>.
</p>
</td></tr>
<tr><td><code id="linearKcross_+3A_j">j</code></td>
<td>
<p>Number or character string identifying the type (mark value)
of the points in <code>X</code> to which distances are measured.
Defaults to the second level of <code>marks(X)</code>.
</p>
</td></tr>
<tr><td><code id="linearKcross_+3A_r">r</code></td>
<td>
<p>numeric vector. The values of the argument <code class="reqn">r</code>
at which the <code class="reqn">K</code>-function
<code class="reqn">K_{ij}(r)</code> should be evaluated.
There is a sensible default.
First-time users are strongly advised not to specify this argument.
See below for important conditions on <code class="reqn">r</code>.
</p>
</td></tr>
<tr><td><code id="linearKcross_+3A_correction">correction</code></td>
<td>

<p>Geometry correction.
Either <code>"none"</code> or <code>"Ang"</code>. See Details.
</p>
</td></tr>
<tr><td><code id="linearKcross_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a counterpart of the function <code><a href="spatstat.explore.html#topic+Kcross">Kcross</a></code> 
for a point pattern on a linear network (object of class <code>"lpp"</code>).
</p>
<p>The arguments <code>i</code> and <code>j</code> will be interpreted as
levels of the factor <code>marks(X)</code>. 
If <code>i</code> and <code>j</code> are missing, they default to the first
and second level of the marks factor, respectively.
</p>
<p>The argument <code>r</code> is the vector of values for the
distance <code class="reqn">r</code> at which <code class="reqn">K_{ij}(r)</code> should be evaluated. 
The values of <code class="reqn">r</code> must be increasing nonnegative numbers
and the maximum <code class="reqn">r</code> value must not exceed the radius of the
largest disc contained in the window.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code> (see <code><a href="spatstat.explore.html#topic+fv.object">fv.object</a></code>).
</p>


<h3>Warnings</h3>

<p>The arguments <code>i</code> and <code>j</code> are interpreted as
levels of the factor <code>marks(X)</code>. Beware of the usual
trap with factors: numerical values are not
interpreted in the same way as character values. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>References</h3>

<p>Baddeley, A, Jammalamadaka, A. and Nair, G. (2014)
Multitype point process analysis of spines on the
dendrite network of a neuron.
<em>Applied Statistics</em> (Journal of the Royal Statistical
Society, Series C), <b>63</b>, 673&ndash;694.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linearKdot">linearKdot</a></code>,
<code><a href="#topic+linearK">linearK</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   K &lt;- linearKcross(chicago, "assault", "robbery")
</code></pre>

<hr>
<h2 id='linearKcross.inhom'>
Inhomogeneous multitype K Function (Cross-type) for Linear Point Pattern
</h2><span id='topic+linearKcross.inhom'></span>

<h3>Description</h3>

<p>For a multitype point pattern on a linear network,
estimate the inhomogeneous multitype <code class="reqn">K</code> function
which counts the expected number of points of type <code class="reqn">j</code>
within a given distance of a point of type <code class="reqn">i</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linearKcross.inhom(X, i, j, lambdaI=NULL, lambdaJ=NULL,
                   r=NULL, ..., correction="Ang", normalise=TRUE,
                   sigma=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linearKcross.inhom_+3A_x">X</code></td>
<td>
<p>The observed point pattern, 
from which an estimate of the cross type <code class="reqn">K</code> function
<code class="reqn">K_{ij}(r)</code> will be computed.
An object of class <code>"lpp"</code> which 
must be a multitype point pattern (a marked point pattern
whose marks are a factor).
</p>
</td></tr>
<tr><td><code id="linearKcross.inhom_+3A_i">i</code></td>
<td>
<p>Number or character string identifying the type (mark value)
of the points in <code>X</code> from which distances are measured.
Defaults to the first level of <code>marks(X)</code>.
</p>
</td></tr>
<tr><td><code id="linearKcross.inhom_+3A_j">j</code></td>
<td>
<p>Number or character string identifying the type (mark value)
of the points in <code>X</code> to which distances are measured.
Defaults to the second level of <code>marks(X)</code>.
</p>
</td></tr>
<tr><td><code id="linearKcross.inhom_+3A_lambdai">lambdaI</code></td>
<td>

<p>Intensity values for the points of type <code>i</code>. Either a numeric vector,
a <code>function</code>, a pixel image
(object of class <code>"im"</code> or <code>"linim"</code>) or
a fitted point process model (object of class <code>"ppm"</code>
or <code>"lppm"</code>) or <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="linearKcross.inhom_+3A_lambdaj">lambdaJ</code></td>
<td>

<p>Intensity values for the points of type <code>j</code>. Either a numeric vector,
a <code>function</code>, a pixel image
(object of class <code>"im"</code> or <code>"linim"</code>) or
a fitted point process model (object of class <code>"ppm"</code>
or <code>"lppm"</code>) or <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="linearKcross.inhom_+3A_r">r</code></td>
<td>
<p>numeric vector. The values of the argument <code class="reqn">r</code>
at which the <code class="reqn">K</code>-function
<code class="reqn">K_{ij}(r)</code> should be evaluated.
There is a sensible default.
First-time users are strongly advised not to specify this argument.
See below for important conditions on <code class="reqn">r</code>.
</p>
</td></tr>
<tr><td><code id="linearKcross.inhom_+3A_correction">correction</code></td>
<td>

<p>Geometry correction.
Either <code>"none"</code> or <code>"Ang"</code>. See Details.
</p>
</td></tr>
<tr><td><code id="linearKcross.inhom_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code>lambdaI</code> and <code>lambdaJ</code> if
they are functions.
</p>
</td></tr>
<tr><td><code id="linearKcross.inhom_+3A_normalise">normalise</code></td>
<td>

<p>Logical. If <code>TRUE</code> (the default), the denominator of the estimator is 
data-dependent (equal to the sum of the reciprocal intensities at
the points of type <code>i</code>), which reduces the sampling variability.
If <code>FALSE</code>, the denominator is the length of the network.
</p>
</td></tr>
<tr><td><code id="linearKcross.inhom_+3A_sigma">sigma</code></td>
<td>

<p>Smoothing bandwidth passed to <code><a href="#topic+density.lpp">density.lpp</a></code>
for estimation of intensities when either <code>lambdaI</code> or
<code>lambdaJ</code> is <code>NULL</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a counterpart of the function <code><a href="spatstat.explore.html#topic+Kcross.inhom">Kcross.inhom</a></code> 
for a point pattern on a linear network (object of class <code>"lpp"</code>).
</p>
<p>The arguments <code>i</code> and <code>j</code> will be interpreted as
levels of the factor <code>marks(X)</code>. 
If <code>i</code> and <code>j</code> are missing, they default to the first
and second level of the marks factor, respectively.
</p>
<p>The argument <code>r</code> is the vector of values for the
distance <code class="reqn">r</code> at which <code class="reqn">K_{ij}(r)</code> should be evaluated. 
The values of <code class="reqn">r</code> must be increasing nonnegative numbers
and the maximum <code class="reqn">r</code> value must not exceed the radius of the
largest disc contained in the window.
</p>
<p>If <code>lambdaI</code> or <code>lambdaJ</code> is missing or <code>NULL</code>, it will
be estimated by kernel smoothing using <code><a href="#topic+density.lpp">density.lpp</a></code>.
</p>
<p>If <code>lambdaI</code> or <code>lambdaJ</code> is a fitted point process model,
the default behaviour is to update the model by re-fitting it to
the data, before computing the fitted intensity.
This can be disabled by setting <code>update=FALSE</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code> (see <code><a href="spatstat.explore.html#topic+fv.object">fv.object</a></code>).
</p>


<h3>Warnings</h3>

<p>The arguments <code>i</code> and <code>j</code> are interpreted as
levels of the factor <code>marks(X)</code>. Beware of the usual
trap with factors: numerical values are not
interpreted in the same way as character values. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Baddeley, A, Jammalamadaka, A. and Nair, G. (2014)
Multitype point process analysis of spines on the
dendrite network of a neuron.
<em>Applied Statistics</em> (Journal of the Royal Statistical
Society, Series C), <b>63</b>, 673&ndash;694.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linearKdot">linearKdot</a></code>,
<code><a href="#topic+linearK">linearK</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   lam &lt;- table(marks(chicago))/(summary(chicago)$totlength)
   lamI &lt;- function(x,y,const=lam[["assault"]]){ rep(const, length(x)) }
   lamJ &lt;- function(x,y,const=lam[["robbery"]]){ rep(const, length(x)) }

   K &lt;- linearKcross.inhom(chicago, "assault", "robbery", lamI, lamJ)

   # using fitted models for the intensity
   # fit &lt;- lppm(chicago ~marks + x)
   # K &lt;- linearKcross.inhom(chicago, "assault", "robbery", fit, fit)
</code></pre>

<hr>
<h2 id='linearKdot'>
Multitype K Function (Dot-type) for Linear Point Pattern
</h2><span id='topic+linearKdot'></span>

<h3>Description</h3>

<p>For a multitype point pattern on a linear network,
estimate the multitype <code class="reqn">K</code> function
which counts the expected number of points (of any type)
within a given distance of a point of type <code class="reqn">i</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linearKdot(X, i, r=NULL, ..., correction="Ang")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linearKdot_+3A_x">X</code></td>
<td>
<p>The observed point pattern, 
from which an estimate of the dot type <code class="reqn">K</code> function
<code class="reqn">K_{i\bullet}(r)</code> will be computed.
An object of class <code>"lpp"</code> which 
must be a multitype point pattern (a marked point pattern
whose marks are a factor).
</p>
</td></tr>
<tr><td><code id="linearKdot_+3A_i">i</code></td>
<td>
<p>Number or character string identifying the type (mark value)
of the points in <code>X</code> from which distances are measured.
Defaults to the first level of <code>marks(X)</code>.
</p>
</td></tr>
<tr><td><code id="linearKdot_+3A_r">r</code></td>
<td>
<p>numeric vector. The values of the argument <code class="reqn">r</code>
at which the <code class="reqn">K</code>-function
<code class="reqn">K_{i\bullet}(r)</code> should be evaluated.
There is a sensible default.
First-time users are strongly advised not to specify this argument.
See below for important conditions on <code class="reqn">r</code>.
</p>
</td></tr>
<tr><td><code id="linearKdot_+3A_correction">correction</code></td>
<td>

<p>Geometry correction.
Either <code>"none"</code> or <code>"Ang"</code>. See Details.
</p>
</td></tr>
<tr><td><code id="linearKdot_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a counterpart of the function <code><a href="spatstat.explore.html#topic+Kdot">Kdot</a></code> 
for a point pattern on a linear network (object of class <code>"lpp"</code>).
</p>
<p>The argument <code>i</code> will be interpreted as
levels of the factor <code>marks(X)</code>. 
If <code>i</code> is missing, it defaults to the first
level of the marks factor.
</p>
<p>The argument <code>r</code> is the vector of values for the
distance <code class="reqn">r</code> at which <code class="reqn">K_{i\bullet}(r)</code> should be evaluated. 
The values of <code class="reqn">r</code> must be increasing nonnegative numbers
and the maximum <code class="reqn">r</code> value must not exceed the radius of the
largest disc contained in the window.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code> (see <code><a href="spatstat.explore.html#topic+fv.object">fv.object</a></code>).
</p>


<h3>Warnings</h3>

<p>The argument <code>i</code> is interpreted as a
level of the factor <code>marks(X)</code>. Beware of the usual
trap with factors: numerical values are not
interpreted in the same way as character values. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>References</h3>

<p>Baddeley, A, Jammalamadaka, A. and Nair, G. (2014)
Multitype point process analysis of spines on the
dendrite network of a neuron.
<em>Applied Statistics</em> (Journal of the Royal Statistical
Society, Series C), <b>63</b>, 673&ndash;694.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.explore.html#topic+Kdot">Kdot</a></code>,
<code><a href="#topic+linearKcross">linearKcross</a></code>,
<code><a href="#topic+linearK">linearK</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   K &lt;- linearKdot(chicago, "assault")
</code></pre>

<hr>
<h2 id='linearKdot.inhom'>
Inhomogeneous multitype K Function (Dot-type) for Linear Point Pattern
</h2><span id='topic+linearKdot.inhom'></span>

<h3>Description</h3>

<p>For a multitype point pattern on a linear network,
estimate the inhomogeneous multitype <code class="reqn">K</code> function
which counts the expected number of points (of any type)
within a given distance of a point of type <code class="reqn">i</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linearKdot.inhom(X, i, lambdaI=NULL, lambdadot=NULL, r=NULL, ...,
                 correction="Ang", normalise=TRUE, sigma=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linearKdot.inhom_+3A_x">X</code></td>
<td>
<p>The observed point pattern, 
from which an estimate of the dot type <code class="reqn">K</code> function
<code class="reqn">K_{i\bullet}(r)</code> will be computed.
An object of class <code>"lpp"</code> which 
must be a multitype point pattern (a marked point pattern
whose marks are a factor).
</p>
</td></tr>
<tr><td><code id="linearKdot.inhom_+3A_i">i</code></td>
<td>
<p>Number or character string identifying the type (mark value)
of the points in <code>X</code> from which distances are measured.
Defaults to the first level of <code>marks(X)</code>.
</p>
</td></tr>
<tr><td><code id="linearKdot.inhom_+3A_lambdai">lambdaI</code></td>
<td>

<p>Intensity values for the points of type <code>i</code>. Either a numeric vector,
a <code>function</code>, a pixel image
(object of class <code>"im"</code> or <code>"linim"</code>) or
a fitted point process model (object of class <code>"ppm"</code>
or <code>"lppm"</code>) or <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="linearKdot.inhom_+3A_lambdadot">lambdadot</code></td>
<td>

<p>Intensity values for all points of <code>X</code>. Either a numeric vector,
a <code>function</code>, a pixel image
(object of class <code>"im"</code> or <code>"linim"</code>) or
a fitted point process model (object of class <code>"ppm"</code>
or <code>"lppm"</code>) or <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="linearKdot.inhom_+3A_r">r</code></td>
<td>
<p>numeric vector. The values of the argument <code class="reqn">r</code>
at which the <code class="reqn">K</code>-function
<code class="reqn">K_{i\bullet}(r)</code> should be evaluated.
There is a sensible default.
First-time users are strongly advised not to specify this argument.
See below for important conditions on <code class="reqn">r</code>.
</p>
</td></tr>
<tr><td><code id="linearKdot.inhom_+3A_correction">correction</code></td>
<td>

<p>Geometry correction.
Either <code>"none"</code> or <code>"Ang"</code>. See Details.
</p>
</td></tr>
<tr><td><code id="linearKdot.inhom_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code>lambdaI</code> and <code>lambdadot</code> if
they are functions.
</p>
</td></tr>
<tr><td><code id="linearKdot.inhom_+3A_normalise">normalise</code></td>
<td>

<p>Logical. If <code>TRUE</code> (the default), the denominator of the estimator is 
data-dependent (equal to the sum of the reciprocal intensities at
the points of type <code>i</code>), which reduces the sampling variability.
If <code>FALSE</code>, the denominator is the length of the network.
</p>
</td></tr>
<tr><td><code id="linearKdot.inhom_+3A_sigma">sigma</code></td>
<td>

<p>Smoothing bandwidth passed to <code><a href="#topic+density.lpp">density.lpp</a></code>
for estimation of intensities when either <code>lambdaI</code> or
<code>lambdadot</code> is <code>NULL</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a counterpart of the function <code><a href="spatstat.explore.html#topic+Kdot.inhom">Kdot.inhom</a></code> 
for a point pattern on a linear network (object of class <code>"lpp"</code>).
</p>
<p>The argument <code>i</code> will be interpreted as
levels of the factor <code>marks(X)</code>. 
If <code>i</code> is missing, it defaults to the first
level of the marks factor.
</p>
<p>The argument <code>r</code> is the vector of values for the
distance <code class="reqn">r</code> at which <code class="reqn">K_{i\bullet}(r)</code> should be evaluated. 
The values of <code class="reqn">r</code> must be increasing nonnegative numbers
and the maximum <code class="reqn">r</code> value must not exceed the radius of the
largest disc contained in the window.
</p>
<p>If <code>lambdaI</code> or <code>lambdadot</code> is missing, it will be estimated
by kernel smoothing using <code><a href="#topic+density.lpp">density.lpp</a></code>.
</p>
<p>If <code>lambdaI</code> or <code>lambdadot</code> is a fitted point process model,
the default behaviour is to update the model by re-fitting it to
the data, before computing the fitted intensity.
This can be disabled by setting <code>update=FALSE</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code> (see <code><a href="spatstat.explore.html#topic+fv.object">fv.object</a></code>).
</p>


<h3>Warnings</h3>

<p>The argument <code>i</code> is interpreted as a
level of the factor <code>marks(X)</code>. Beware of the usual
trap with factors: numerical values are not
interpreted in the same way as character values. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>References</h3>

<p>Baddeley, A, Jammalamadaka, A. and Nair, G. (2014)
Multitype point process analysis of spines on the
dendrite network of a neuron.
<em>Applied Statistics</em> (Journal of the Royal Statistical
Society, Series C), <b>63</b>, 673&ndash;694.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linearKdot">linearKdot</a></code>,
<code><a href="#topic+linearK">linearK</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   lam &lt;- table(marks(chicago))/(summary(chicago)$totlength)
   lamI &lt;- function(x,y,const=lam[["assault"]]){ rep(const, length(x)) }
   lam. &lt;- function(x,y,const=sum(lam)){ rep(const, length(x)) }

   K &lt;- linearKdot.inhom(chicago, "assault", lamI, lam.)

   # using fitted models for the intensity
   # fit &lt;- lppm(chicago ~marks + x)
   # linearKdot.inhom(chicago, "assault", fit, fit)
</code></pre>

<hr>
<h2 id='linearKEuclid'>
Linear K Function Using Euclidean Distance
</h2><span id='topic+linearKEuclid'></span>

<h3>Description</h3>

<p>Computes an estimate of the linear <code class="reqn">K</code> function
based on Euclidean distances,
for a point pattern on a linear network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linearKEuclid(X, r = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linearKEuclid_+3A_x">X</code></td>
<td>

<p>Point pattern on linear network (object of class <code>"lpp"</code>).
</p>
</td></tr>
<tr><td><code id="linearKEuclid_+3A_r">r</code></td>
<td>

<p>Optional. Numeric vector of values of the function argument <code class="reqn">r</code>.
There is a sensible default.
</p>
</td></tr>
<tr><td><code id="linearKEuclid_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command computes an estimate of the 
linear <code class="reqn">K</code> function based on Euclidean distances
between the points, as described by
Rakshit, Nair and Baddeley (2017).
</p>
<p>This is different from the linear <code>K</code> function
based on shortest-path distances, which is computed by
<code><a href="#topic+linearK">linearK</a></code>.
</p>
<p>The linear <code class="reqn">K</code> function based on Euclidean distances
is defined in equation (20) of Rakshit, Nair and Baddeley (2017).
The estimate is computed from the point pattern as described in equation (25).
</p>


<h3>Value</h3>

<p>Function value table (object of class <code>"fv"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Rakshit. S., Nair, G. and Baddeley, A. (2017)
Second-order analysis of point patterns on a network
using any distance metric. <em>Spatial Statistics</em> <b>22</b> (1) 129&ndash;154.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linearpcfEuclid">linearpcfEuclid</a></code>, <code><a href="#topic+linearKEuclidInhom">linearKEuclidInhom</a></code>.
</p>
<p>See <code><a href="#topic+linearK">linearK</a></code> for the corresponding function
based on shortest-path distances.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- rpoislpp(5, simplenet)
  K &lt;- linearKEuclid(X)
</code></pre>

<hr>
<h2 id='linearKEuclidInhom'>
Inhomogeneous Linear K Function Based on Euclidean Distances
</h2><span id='topic+linearKEuclidInhom'></span>

<h3>Description</h3>

<p>Computes an estimate of the inhomogeneous linear <code class="reqn">K</code> function
based on Euclidean distances, for a point pattern on a linear network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   linearKEuclidInhom(X, lambda = NULL, r = NULL, ...,
      normalise = TRUE, normpower = 2, update = TRUE,
      leaveoneout = TRUE, sigma=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linearKEuclidInhom_+3A_x">X</code></td>
<td>

<p>Point pattern on linear network (object of class <code>"lpp"</code>).
</p>
</td></tr>
<tr><td><code id="linearKEuclidInhom_+3A_lambda">lambda</code></td>
<td>

<p>Intensity values for the point pattern. Either a numeric vector,
a <code>function</code>, a pixel image
(object of class <code>"im"</code> or <code>"linim"</code>) or
a fitted point process model (object of class <code>"ppm"</code>
or <code>"lppm"</code>) or <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="linearKEuclidInhom_+3A_r">r</code></td>
<td>

<p>Optional. Numeric vector of values of the function argument <code class="reqn">r</code>.
There is a sensible default.
</p>
</td></tr>
<tr><td><code id="linearKEuclidInhom_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="linearKEuclidInhom_+3A_normalise">normalise</code></td>
<td>

<p>Logical. If <code>TRUE</code> (the default), the denominator of the estimator is 
data-dependent (equal to the sum of the reciprocal intensities at the data
points, raised to <code>normpower</code>), which reduces the sampling variability.
If <code>FALSE</code>, the denominator is the length of the network.
</p>
</td></tr>
<tr><td><code id="linearKEuclidInhom_+3A_normpower">normpower</code></td>
<td>

<p>Integer (usually either 1 or 2).
Normalisation power. See Details.
</p>
</td></tr>
<tr><td><code id="linearKEuclidInhom_+3A_update">update</code></td>
<td>

<p>Logical value indicating what to do when <code>lambda</code> is a fitted model
(class <code>"lppm"</code> or <code>"ppm"</code>).
If <code>update=TRUE</code> (the default),
the model will first be refitted to the data <code>X</code>
(using <code><a href="#topic+update.lppm">update.lppm</a></code> or <code><a href="spatstat.model.html#topic+update.ppm">update.ppm</a></code>)
before the fitted intensity is computed.
If <code>update=FALSE</code>, the fitted intensity of the
model will be computed without re-fitting it to <code>X</code>.
</p>
</td></tr>
<tr><td><code id="linearKEuclidInhom_+3A_leaveoneout">leaveoneout</code></td>
<td>

<p>Logical value specifying whether to use a
leave-one-out rule when calculating the intensity.
See Details.
</p>
</td></tr>
<tr><td><code id="linearKEuclidInhom_+3A_sigma">sigma</code></td>
<td>

<p>Smoothing bandwidth (passed to <code><a href="#topic+density.lpp">density.lpp</a></code>)
for kernel density estimation of the intensity when
<code>lambda=NULL</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command computes the inhomogeneous version of the 
linear <code class="reqn">K</code> function based on <em>Euclidean</em> distances,
for a point pattern on a linear network.
</p>
<p>This is different from the inhomogeneous <code class="reqn">K</code> function based on
<em>shortest-path</em> distances,
which is computed by <code><a href="#topic+linearKinhom">linearKinhom</a></code>.
</p>
<p>The inhomogeneous <code class="reqn">K</code> function based on <em>Euclidean</em> distances
is defined in equation (23) of Rakshit, Nair and Baddeley (2017).
Estimation is performed as described in equation (28).
</p>
<p>The argument <code>lambda</code> should provide estimated values
of the intensity of the point process at each point of <code>X</code>.
</p>
<p>If <code>lambda=NULL</code>, the intensity will be estimated by kernel
smoothing by calling <code><a href="#topic+density.lpp">density.lpp</a></code> with the smoothing
bandwidth <code>sigma</code>, and with any other relevant arguments
that might be present in <code>...</code>. A leave-one-out kernel estimate
will be computed if <code>leaveoneout=TRUE</code>.
</p>
<p>If <code>lambda</code> is given, then it is expected to provide estimated values
of the intensity of the point process at each point of <code>X</code>. 
The argument <code>lambda</code> may be a numeric vector (of length equal to
the number of points in <code>X</code>), or a <code>function(x,y)</code> that will be
evaluated at the points of <code>X</code> to yield numeric values, 
or a pixel image (object of class <code>"im"</code>) or a fitted point 
process model (object of class <code>"ppm"</code> or <code>"lppm"</code>).
</p>
<p>If <code>lambda</code> is a fitted point process model,
the default behaviour is to update the model by re-fitting it to
the data, before computing the fitted intensity.
This can be disabled by setting <code>update=FALSE</code>.
The intensity at data points will be computed
by <code><a href="#topic+fitted.lppm">fitted.lppm</a></code> or <code><a href="spatstat.model.html#topic+fitted.ppm">fitted.ppm</a></code>.
A leave-one-out estimate will be computed if <code>leaveoneout=TRUE</code>
and <code>update=TRUE</code>.
</p>
<p>If <code>normalise=TRUE</code> (the default), then the estimate
is multiplied by <code class="reqn">c^{\mbox{normpower}}</code> where 
<code class="reqn">
    c = \mbox{length}(L)/\sum (1/\lambda(x_i)).
  </code>
This rescaling reduces the variability and bias of the estimate
in small samples and in cases of very strong inhomogeneity.
The default value of <code>normpower</code> is 1 (for consistency with
previous versions of <span class="pkg">spatstat</span>)
but the most sensible value is 2, which would correspond to rescaling
the <code>lambda</code> values so that
<code class="reqn">
    \sum (1/\lambda(x_i)) = \mbox{area}(W).
  </code>
</p>


<h3>Value</h3>

<p>Function value table (object of class <code>"fv"</code>).
</p>


<h3>Warning</h3>

<p>Older versions of <code><a href="#topic+linearKEuclidInhom">linearKEuclidInhom</a></code> interpreted
<code>lambda=NULL</code> to mean that the homogeneous function
<code><a href="#topic+linearKEuclid">linearKEuclid</a></code> should be computed. This was changed to the
current behaviour in version <code>3.1-0</code> of <span class="pkg">spatstat.linnet</span>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Rakshit. S., Nair, G. and Baddeley, A. (2017)
Second-order analysis of point patterns on a network
using any distance metric. <em>Spatial Statistics</em> <b>22</b> (1) 129&ndash;154.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linearpcfEuclidInhom">linearpcfEuclidInhom</a></code>, <code><a href="#topic+linearKEuclid">linearKEuclid</a></code>.
</p>
<p>See <code><a href="#topic+linearKinhom">linearKinhom</a></code> for the corresponding function
based on shortest-path distances.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- rpoislpp(5, simplenet)
  fit &lt;- lppm(X ~x)
  K &lt;- linearKEuclidInhom(X, lambda=fit)
  plot(K)
</code></pre>

<hr>
<h2 id='linearKinhom'>
Inhomogeneous Linear K Function
</h2><span id='topic+linearKinhom'></span>

<h3>Description</h3>

<p>Computes an estimate of the inhomogeneous linear <code class="reqn">K</code> function
for a point pattern on a linear network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linearKinhom(X, lambda=NULL, r=NULL, ..., correction="Ang",
             normalise=TRUE, normpower=1,
	     update=TRUE, leaveoneout=TRUE, sigma=NULL, ratio=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linearKinhom_+3A_x">X</code></td>
<td>

<p>Point pattern on linear network (object of class <code>"lpp"</code>).
</p>
</td></tr>
<tr><td><code id="linearKinhom_+3A_lambda">lambda</code></td>
<td>

<p>Intensity values for the point pattern. Either a numeric vector,
a <code>function</code>, a pixel image
(object of class <code>"im"</code> or <code>"linim"</code>) or
a fitted point process model (object of class <code>"ppm"</code>
or <code>"lppm"</code>) or <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="linearKinhom_+3A_r">r</code></td>
<td>

<p>Optional. Numeric vector of values of the function argument <code class="reqn">r</code>.
There is a sensible default. Users are advised not to specify
<code>r</code> in normal usage.
</p>
</td></tr>
<tr><td><code id="linearKinhom_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="linearKinhom_+3A_correction">correction</code></td>
<td>

<p>Geometry correction.
Either <code>"none"</code> or <code>"Ang"</code>. See Details.
</p>
</td></tr>
<tr><td><code id="linearKinhom_+3A_normalise">normalise</code></td>
<td>

<p>Logical. If <code>TRUE</code> (the default), the denominator of the estimator is 
data-dependent (equal to the sum of the reciprocal intensities at the data
points, raised to <code>normpower</code>), which reduces the sampling variability.
If <code>FALSE</code>, the denominator is the length of the network.
</p>
</td></tr>
<tr><td><code id="linearKinhom_+3A_normpower">normpower</code></td>
<td>

<p>Integer (usually either 1 or 2).
Normalisation power. See Details.
</p>
</td></tr>
<tr><td><code id="linearKinhom_+3A_update">update</code></td>
<td>

<p>Logical value indicating what to do when <code>lambda</code> is a fitted model
(class <code>"lppm"</code> or <code>"ppm"</code>).
If <code>update=TRUE</code> (the default),
the model will first be refitted to the data <code>X</code>
(using <code><a href="#topic+update.lppm">update.lppm</a></code> or <code><a href="spatstat.model.html#topic+update.ppm">update.ppm</a></code>)
before the fitted intensity is computed.
If <code>update=FALSE</code>, the fitted intensity of the
model will be computed without re-fitting it to <code>X</code>.
</p>
</td></tr>
<tr><td><code id="linearKinhom_+3A_leaveoneout">leaveoneout</code></td>
<td>

<p>Logical value specifying whether to use a
leave-one-out rule when calculating the intensity.
See Details.
</p>
</td></tr>
<tr><td><code id="linearKinhom_+3A_sigma">sigma</code></td>
<td>

<p>Smoothing bandwidth (passed to <code><a href="#topic+density.lpp">density.lpp</a></code>)
for kernel density estimation of the intensity when
<code>lambda=NULL</code>.
</p>
</td></tr>
<tr><td><code id="linearKinhom_+3A_ratio">ratio</code></td>
<td>

<p>Logical. 
If <code>TRUE</code>, the numerator and denominator of
the estimate will also be saved,
for use in analysing replicated point patterns.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command computes the inhomogeneous version of the 
linear <code class="reqn">K</code> function from point pattern data on a linear network.
</p>
<p>The argument <code>lambda</code> should provide estimated values
of the intensity of the point process at each point of <code>X</code>.
</p>
<p>If <code>lambda=NULL</code>, the intensity will be estimated by kernel
smoothing by calling <code><a href="#topic+density.lpp">density.lpp</a></code> with the smoothing
bandwidth <code>sigma</code>, and with any other relevant arguments
that might be present in <code>...</code>. A leave-one-out kernel estimate
will be computed if <code>leaveoneout=TRUE</code>.
</p>
<p>If <code>lambda</code> is given, it may be a numeric vector (of length equal to
the number of points in <code>X</code>), or a <code>function(x,y)</code> that will be
evaluated at the points of <code>X</code> to yield numeric values, 
or a pixel image (object of class <code>"im"</code>) or a fitted point 
process model (object of class <code>"ppm"</code> or <code>"lppm"</code>).
</p>
<p>If <code>lambda</code> is a fitted point process model,
the default behaviour is to update the model by re-fitting it to
the data, before computing the fitted intensity.
This can be disabled by setting <code>update=FALSE</code>.
The intensity at data points will be computed
by <code><a href="#topic+fitted.lppm">fitted.lppm</a></code> or <code><a href="spatstat.model.html#topic+fitted.ppm">fitted.ppm</a></code>.
A leave-one-out estimate will be computed if <code>leaveoneout=TRUE</code>
and <code>update=TRUE</code>.
</p>
<p>If <code>correction="none"</code>, the calculations do not include
any correction for the geometry of the linear network.
If <code>correction="Ang"</code>, the pair counts are weighted using
Ang's correction (Ang, 2010).
</p>
<p>Each estimate is initially computed as 
</p>
<p style="text-align: center;"><code class="reqn">
    \widehat K_{\rm inhom}(r) = \frac{1}{\mbox{length}(L)}
    \sum_i \sum_j \frac{1\{d_{ij} \le r\}
      e(x_i,x_j)}{\lambda(x_i)\lambda(x_j)}
  </code>
</p>

<p>where <code>L</code> is the linear network,
<code class="reqn">d_{ij}</code> is the distance between points
<code class="reqn">x_i</code> and <code class="reqn">x_j</code>, and
<code class="reqn">e(x_i,x_j)</code> is a weight.
If <code>correction="none"</code> then this weight is equal to 1,
while if  <code>correction="Ang"</code> the weight is
<code class="reqn">e(x_i,x_j,r) = 1/m(x_i, d_{ij})</code>
where <code class="reqn">m(u,t)</code> is the number of locations on the network that lie
exactly <code class="reqn">t</code> units distant from location <code class="reqn">u</code> by the shortest
path.
</p>
<p>If <code>normalise=TRUE</code> (the default), then the estimates
described above
are multiplied by <code class="reqn">c^{\mbox{normpower}}</code> where 
<code class="reqn">
    c = \mbox{length}(L)/\sum (1/\lambda(x_i)).
  </code>
This rescaling reduces the variability and bias of the estimate
in small samples and in cases of very strong inhomogeneity.
The default value of <code>normpower</code> is 1 (for consistency with
previous versions of <span class="pkg">spatstat</span>)
but the most sensible value is 2, which would correspond to rescaling
the <code>lambda</code> values so that
<code class="reqn">
    \sum (1/\lambda(x_i)) = \mbox{area}(W).
  </code>
</p>


<h3>Value</h3>

<p>Function value table (object of class <code>"fv"</code>).
</p>


<h3>Warning</h3>

<p>Older versions of <code><a href="#topic+linearKinhom">linearKinhom</a></code> interpreted
<code>lambda=NULL</code> to mean that the homogeneous function
<code><a href="#topic+linearK">linearK</a></code> should be computed. This was changed to the
current behaviour in version <code>3.1-0</code> of <span class="pkg">spatstat.linnet</span>.
</p>


<h3>Author(s)</h3>

<p>Ang Qi Wei <a href="mailto:aqw07398@hotmail.com">aqw07398@hotmail.com</a> and
Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>References</h3>

<p>Ang, Q.W. (2010) Statistical methodology for spatial point patterns
on a linear network. MSc thesis, University of Western Australia.
</p>
<p>Ang, Q.W., Baddeley, A. and Nair, G. (2012)
Geometrically corrected second-order analysis of 
events on a linear network, with applications to
ecology and criminology.
<em>Scandinavian Journal of Statistics</em> <b>39</b>, 591&ndash;617.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lpp">lpp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- rpoislpp(5, simplenet)
  fit &lt;- lppm(X ~x)
  K &lt;- linearKinhom(X, lambda=fit)
  plot(K)
  Ke &lt;- linearKinhom(X, sigma=bw.lppl)
  plot(Ke)
</code></pre>

<hr>
<h2 id='linearmarkconnect'>
Mark Connection Function for Multitype Point Pattern on Linear Network
</h2><span id='topic+linearmarkconnect'></span>

<h3>Description</h3>

<p>For a multitype point pattern on a linear network,
estimate the mark connection function
from points of type <code class="reqn">i</code> to points of type <code class="reqn">j</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linearmarkconnect(X, i, j, r=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linearmarkconnect_+3A_x">X</code></td>
<td>
<p>The observed point pattern, 
from which an estimate of the mark connection function
<code class="reqn">p_{ij}(r)</code> will be computed.
An object of class <code>"lpp"</code> which 
must be a multitype point pattern (a marked point pattern
whose marks are a factor).
</p>
</td></tr>
<tr><td><code id="linearmarkconnect_+3A_i">i</code></td>
<td>
<p>Number or character string identifying the type (mark value)
of the points in <code>X</code> from which distances are measured.
Defaults to the first level of <code>marks(X)</code>.
</p>
</td></tr>
<tr><td><code id="linearmarkconnect_+3A_j">j</code></td>
<td>
<p>Number or character string identifying the type (mark value)
of the points in <code>X</code> to which distances are measured.
Defaults to the second level of <code>marks(X)</code>.
</p>
</td></tr>
<tr><td><code id="linearmarkconnect_+3A_r">r</code></td>
<td>
<p>numeric vector. The values of the argument <code class="reqn">r</code>
at which the function
<code class="reqn">p_{ij}(r)</code> should be evaluated.
There is a sensible default.
First-time users are strongly advised not to specify this argument.
See below for important conditions on <code class="reqn">r</code>.
</p>
</td></tr>
<tr><td><code id="linearmarkconnect_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+linearpcfcross">linearpcfcross</a></code>
and <code><a href="#topic+linearpcf">linearpcf</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a counterpart of the function <code><a href="spatstat.explore.html#topic+markconnect">markconnect</a></code> 
for a point pattern on a linear network (object of class <code>"lpp"</code>).
</p>
<p>The argument <code>i</code> will be interpreted as
levels of the factor <code>marks(X)</code>. 
If <code>i</code> is missing, it defaults to the first
level of the marks factor.
</p>
<p>The argument <code>r</code> is the vector of values for the
distance <code class="reqn">r</code> at which <code class="reqn">p_{ij}(r)</code>
should be evaluated. 
The values of <code class="reqn">r</code> must be increasing nonnegative numbers
and the maximum <code class="reqn">r</code> value must not exceed the radius of the
largest disc contained in the window.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code> (see <code><a href="spatstat.explore.html#topic+fv.object">fv.object</a></code>).
</p>


<h3>Warnings</h3>

<p>The argument <code>i</code> is interpreted as a
level of the factor <code>marks(X)</code>. Beware of the usual
trap with factors: numerical values are not
interpreted in the same way as character values. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>References</h3>

<p>Baddeley, A, Jammalamadaka, A. and Nair, G. (2014)
Multitype point process analysis of spines on the
dendrite network of a neuron.
<em>Applied Statistics</em> (Journal of the Royal Statistical
Society, Series C), <b>63</b>, 673&ndash;694. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linearpcfcross">linearpcfcross</a></code>,
<code><a href="#topic+linearpcf">linearpcf</a></code>,
<code><a href="#topic+linearmarkequal">linearmarkequal</a></code>,
<code><a href="spatstat.explore.html#topic+markconnect">markconnect</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   pab &lt;- linearmarkconnect(chicago, "assault", "burglary")
   
   # plot(alltypes(chicago, linearmarkconnect))
</code></pre>

<hr>
<h2 id='linearmarkequal'>
Mark Connection Function for Multitype Point Pattern on Linear Network
</h2><span id='topic+linearmarkequal'></span>

<h3>Description</h3>

<p>For a multitype point pattern on a linear network,
estimate the mark connection function
from points of type <code class="reqn">i</code> to points of type <code class="reqn">j</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linearmarkequal(X, r=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linearmarkequal_+3A_x">X</code></td>
<td>
<p>The observed point pattern, 
from which an estimate of the mark connection function
<code class="reqn">p_{ij}(r)</code> will be computed.
An object of class <code>"lpp"</code> which 
must be a multitype point pattern (a marked point pattern
whose marks are a factor).
</p>
</td></tr>
<tr><td><code id="linearmarkequal_+3A_r">r</code></td>
<td>
<p>numeric vector. The values of the argument <code class="reqn">r</code>
at which the function
<code class="reqn">p_{ij}(r)</code> should be evaluated.
There is a sensible default.
First-time users are strongly advised not to specify this argument.
See below for important conditions on <code class="reqn">r</code>.
</p>
</td></tr>
<tr><td><code id="linearmarkequal_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+linearpcfcross">linearpcfcross</a></code>
and <code><a href="#topic+linearpcf">linearpcf</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the mark equality function
for a point pattern on a linear network (object of class <code>"lpp"</code>).
</p>
<p>The argument <code>r</code> is the vector of values for the
distance <code class="reqn">r</code> at which <code class="reqn">p_{ij}(r)</code>
should be evaluated. 
The values of <code class="reqn">r</code> must be increasing nonnegative numbers
and the maximum <code class="reqn">r</code> value must not exceed the radius of the
largest disc contained in the window.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code> (see <code><a href="spatstat.explore.html#topic+fv.object">fv.object</a></code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a></p>


<h3>References</h3>

<p>Baddeley, A, Jammalamadaka, A. and Nair, G. (2014)
Multitype point process analysis of spines on the
dendrite network of a neuron.
<em>Applied Statistics</em> (Journal of the Royal Statistical
Society, Series C), <b>63</b>, 673&ndash;694. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linearpcfcross">linearpcfcross</a></code>,
<code><a href="#topic+linearpcf">linearpcf</a></code>,
<code><a href="#topic+linearmarkconnect">linearmarkconnect</a></code>,
<code><a href="spatstat.explore.html#topic+markconnect">markconnect</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   if(interactive()) {
     X &lt;- chicago
   } else {
     m &lt;- sample(factor(c("A","B")), 20, replace=TRUE)
     X &lt;- runiflpp(20, simplenet) %mark% m
   }
   p &lt;- linearmarkequal(X)
</code></pre>

<hr>
<h2 id='linearpcf'>
Linear Pair Correlation Function
</h2><span id='topic+linearpcf'></span>

<h3>Description</h3>

<p>Computes an estimate of the linear pair correlation function
for a point pattern on a linear network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linearpcf(X, r=NULL, ..., correction="Ang", ratio=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linearpcf_+3A_x">X</code></td>
<td>

<p>Point pattern on linear network (object of class <code>"lpp"</code>).
</p>
</td></tr>
<tr><td><code id="linearpcf_+3A_r">r</code></td>
<td>

<p>Optional. Numeric vector of values of the function argument <code class="reqn">r</code>.
There is a sensible default.
</p>
</td></tr>
<tr><td><code id="linearpcf_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="stats.html#topic+density.default">density.default</a></code>
to control the smoothing.
</p>
</td></tr>
<tr><td><code id="linearpcf_+3A_correction">correction</code></td>
<td>

<p>Geometry correction.
Either <code>"none"</code> or <code>"Ang"</code>. See Details.
</p>
</td></tr>
<tr><td><code id="linearpcf_+3A_ratio">ratio</code></td>
<td>

<p>Logical. 
If <code>TRUE</code>, the numerator and denominator of
each estimate will also be saved,
for use in analysing replicated point patterns.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command computes the linear pair correlation function
from point pattern data on a linear network.
</p>
<p>The pair correlation function is estimated from the
shortest-path distances between each pair of data points,
using the fixed-bandwidth kernel smoother
<code><a href="stats.html#topic+density.default">density.default</a></code>, 
with a bias correction at each end of the interval of <code class="reqn">r</code> values.
To switch off the bias correction, set <code>endcorrect=FALSE</code>.
</p>
<p>The bandwidth for smoothing the pairwise distances
is determined by arguments <code>...</code>
passed to <code><a href="stats.html#topic+density.default">density.default</a></code>, mainly the arguments
<code>bw</code> and <code>adjust</code>. The default is
to choose the bandwidth by Silverman's rule of thumb 
<code>bw="nrd0"</code> explained in <code><a href="stats.html#topic+density.default">density.default</a></code>.
</p>
<p>If <code>correction="none"</code>, the calculations do not include
any correction for the geometry of the linear network. The result is
an estimate of the first derivative of the 
network <code class="reqn">K</code> function defined by Okabe and Yamada (2001).
</p>
<p>If <code>correction="Ang"</code>, the pair counts are weighted using
Ang's correction (Ang, 2010). The result is an estimate of the
pair correlation function in the linear network.
</p>


<h3>Value</h3>

<p>Function value table (object of class <code>"fv"</code>).
</p>
<p>If <code>ratio=TRUE</code> then the return value also has two
attributes called <code>"numerator"</code> and <code>"denominator"</code>
which are <code>"fv"</code> objects
containing the numerators and denominators of each
estimate of <code class="reqn">g(r)</code>. 
</p>


<h3>Author(s)</h3>

<p>Ang Qi Wei <a href="mailto:aqw07398@hotmail.com">aqw07398@hotmail.com</a> and
Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Ang, Q.W. (2010) Statistical methodology for spatial point patterns
on a linear network. MSc thesis, University of Western Australia.
</p>
<p>Ang, Q.W., Baddeley, A. and Nair, G. (2012)
Geometrically corrected second-order analysis of 
events on a linear network, with applications to
ecology and criminology.
<em>Scandinavian Journal of Statistics</em> <b>39</b>, 591&ndash;617.
</p>
<p>Okabe, A. and Yamada, I. (2001) The K-function method on a network and
its computational implementation. <em>Geographical Analysis</em>
<b>33</b>, 271-290.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linearK">linearK</a></code>,
<code><a href="#topic+linearpcfinhom">linearpcfinhom</a></code>,
<code><a href="#topic+lpp">lpp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- rpoislpp(5, simplenet)
  linearpcf(X)
  linearpcf(X, correction="none")
</code></pre>

<hr>
<h2 id='linearpcfcross'>
Multitype Pair Correlation Function (Cross-type) for Linear Point Pattern
</h2><span id='topic+linearpcfcross'></span>

<h3>Description</h3>

<p>For a multitype point pattern on a linear network,
estimate the multitype pair correlation function
from points of type <code class="reqn">i</code> to points of type <code class="reqn">j</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linearpcfcross(X, i, j, r=NULL, ..., correction="Ang")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linearpcfcross_+3A_x">X</code></td>
<td>
<p>The observed point pattern, 
from which an estimate of the <code class="reqn">i</code>-to-any pair correlation function
<code class="reqn">g_{ij}(r)</code> will be computed.
An object of class <code>"lpp"</code> which 
must be a multitype point pattern (a marked point pattern
whose marks are a factor).
</p>
</td></tr>
<tr><td><code id="linearpcfcross_+3A_i">i</code></td>
<td>
<p>Number or character string identifying the type (mark value)
of the points in <code>X</code> from which distances are measured.
Defaults to the first level of <code>marks(X)</code>.
</p>
</td></tr>
<tr><td><code id="linearpcfcross_+3A_j">j</code></td>
<td>
<p>Number or character string identifying the type (mark value)
of the points in <code>X</code> to which distances are measured.
Defaults to the second level of <code>marks(X)</code>.
</p>
</td></tr>
<tr><td><code id="linearpcfcross_+3A_r">r</code></td>
<td>
<p>numeric vector. The values of the argument <code class="reqn">r</code>
at which the function
<code class="reqn">g_{ij}(r)</code> should be evaluated.
There is a sensible default.
First-time users are strongly advised not to specify this argument.
See below for important conditions on <code class="reqn">r</code>.
</p>
</td></tr>
<tr><td><code id="linearpcfcross_+3A_correction">correction</code></td>
<td>

<p>Geometry correction.
Either <code>"none"</code> or <code>"Ang"</code>. See Details.
</p>
</td></tr>
<tr><td><code id="linearpcfcross_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="stats.html#topic+density.default">density.default</a></code>
to control the kernel smoothing.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a counterpart of the function <code><a href="spatstat.explore.html#topic+pcfcross">pcfcross</a></code> 
for a point pattern on a linear network (object of class <code>"lpp"</code>).
</p>
<p>The argument <code>i</code> will be interpreted as
levels of the factor <code>marks(X)</code>. 
If <code>i</code> is missing, it defaults to the first
level of the marks factor.
</p>
<p>The argument <code>r</code> is the vector of values for the
distance <code class="reqn">r</code> at which <code class="reqn">g_{ij}(r)</code>
should be evaluated. 
The values of <code class="reqn">r</code> must be increasing nonnegative numbers
and the maximum <code class="reqn">r</code> value must not exceed the radius of the
largest disc contained in the window.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code> (see <code><a href="spatstat.explore.html#topic+fv.object">fv.object</a></code>).
</p>


<h3>Warnings</h3>

<p>The argument <code>i</code> is interpreted as a
level of the factor <code>marks(X)</code>. Beware of the usual
trap with factors: numerical values are not
interpreted in the same way as character values. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>References</h3>

<p>Baddeley, A, Jammalamadaka, A. and Nair, G. (2014)
Multitype point process analysis of spines on the
dendrite network of a neuron.
<em>Applied Statistics</em> (Journal of the Royal Statistical
Society, Series C), <b>63</b>, 673&ndash;694.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linearpcfdot">linearpcfdot</a></code>,
<code><a href="#topic+linearpcf">linearpcf</a></code>,
<code><a href="spatstat.explore.html#topic+pcfcross">pcfcross</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   g &lt;- linearpcfcross(chicago, "assault")
</code></pre>

<hr>
<h2 id='linearpcfcross.inhom'>
Inhomogeneous Multitype Pair Correlation Function
(Cross-type) for Linear Point Pattern
</h2><span id='topic+linearpcfcross.inhom'></span>

<h3>Description</h3>

<p>For a multitype point pattern on a linear network,
estimate the inhomogeneous multitype pair correlation function
from points of type <code class="reqn">i</code> to points of type <code class="reqn">j</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linearpcfcross.inhom(X, i, j, lambdaI, lambdaJ, r=NULL, ...,
                     correction="Ang", normalise=TRUE,
                     sigma=NULL, adjust.sigma=1,
                     bw="nrd0", adjust.bw=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linearpcfcross.inhom_+3A_x">X</code></td>
<td>
<p>The observed point pattern, 
from which an estimate of the <code class="reqn">i</code>-to-any pair correlation function
<code class="reqn">g_{ij}(r)</code> will be computed.
An object of class <code>"lpp"</code> which 
must be a multitype point pattern (a marked point pattern
whose marks are a factor).
</p>
</td></tr>
<tr><td><code id="linearpcfcross.inhom_+3A_i">i</code></td>
<td>
<p>Number or character string identifying the type (mark value)
of the points in <code>X</code> from which distances are measured.
Defaults to the first level of <code>marks(X)</code>.
</p>
</td></tr>
<tr><td><code id="linearpcfcross.inhom_+3A_j">j</code></td>
<td>
<p>Number or character string identifying the type (mark value)
of the points in <code>X</code> to which distances are measured.
Defaults to the second level of <code>marks(X)</code>.
</p>
</td></tr>
<tr><td><code id="linearpcfcross.inhom_+3A_lambdai">lambdaI</code></td>
<td>

<p>Intensity values for the points of type <code>i</code>. Either a numeric vector,
a <code>function</code>, a pixel image
(object of class <code>"im"</code> or <code>"linim"</code>) or
a fitted point process model (object of class <code>"ppm"</code>
or <code>"lppm"</code>).
</p>
</td></tr>
<tr><td><code id="linearpcfcross.inhom_+3A_lambdaj">lambdaJ</code></td>
<td>

<p>Intensity values for the points of type <code>j</code>. Either a numeric vector,
a <code>function</code>, a pixel image
(object of class <code>"im"</code> or <code>"linim"</code>) or
a fitted point process model (object of class <code>"ppm"</code>
or <code>"lppm"</code>).
</p>
</td></tr>
<tr><td><code id="linearpcfcross.inhom_+3A_r">r</code></td>
<td>
<p>numeric vector. The values of the argument <code class="reqn">r</code>
at which the function
<code class="reqn">g_{ij}(r)</code> should be evaluated.
There is a sensible default.
First-time users are strongly advised not to specify this argument.
See below for important conditions on <code class="reqn">r</code>.
</p>
</td></tr>
<tr><td><code id="linearpcfcross.inhom_+3A_correction">correction</code></td>
<td>

<p>Geometry correction.
Either <code>"none"</code> or <code>"Ang"</code>. See Details.
</p>
</td></tr>
<tr><td><code id="linearpcfcross.inhom_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="stats.html#topic+density.default">density.default</a></code>
to control the kernel smoothing.
</p>
</td></tr>
<tr><td><code id="linearpcfcross.inhom_+3A_normalise">normalise</code></td>
<td>

<p>Logical. If <code>TRUE</code> (the default), the denominator of the estimator is 
data-dependent (equal to the sum of the reciprocal intensities at
the points of type <code>i</code>), which reduces the sampling variability.
If <code>FALSE</code>, the denominator is the length of the network.
</p>
</td></tr>
<tr><td><code id="linearpcfcross.inhom_+3A_sigma">sigma</code></td>
<td>

<p>Smoothing bandwidth passed to <code><a href="#topic+density.lpp">density.lpp</a></code>
for estimation of intensities when either <code>lambdaI</code> or
<code>lambdaJ</code> is <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="linearpcfcross.inhom_+3A_adjust.sigma">adjust.sigma</code></td>
<td>

<p>Numeric value. <code>sigma</code> will be multiplied by this value.
</p>
</td></tr>
<tr><td><code id="linearpcfcross.inhom_+3A_bw">bw</code></td>
<td>

<p>Smoothing bandwidth (passed to <code><a href="stats.html#topic+density.default">density.default</a></code>)
for one-dimensional kernel smoothing of the pair correlation function.
Either a numeric value, or a character string recognised
by <code><a href="stats.html#topic+density.default">density.default</a></code>.
</p>
</td></tr>
<tr><td><code id="linearpcfcross.inhom_+3A_adjust.bw">adjust.bw</code></td>
<td>

<p>Numeric value. <code>bw</code> will be multiplied by this value.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a counterpart of the function <code><a href="spatstat.explore.html#topic+pcfcross.inhom">pcfcross.inhom</a></code> 
for a point pattern on a linear network (object of class <code>"lpp"</code>).
</p>
<p>The argument <code>i</code> will be interpreted as
levels of the factor <code>marks(X)</code>. 
If <code>i</code> is missing, it defaults to the first
level of the marks factor.
</p>
<p>The argument <code>r</code> is the vector of values for the
distance <code class="reqn">r</code> at which <code class="reqn">g_{ij}(r)</code>
should be evaluated. 
The values of <code class="reqn">r</code> must be increasing nonnegative numbers
and the maximum <code class="reqn">r</code> value must not exceed the radius of the
largest disc contained in the window.
</p>
<p>If <code>lambdaI</code> or <code>lambdaJ</code> is missing or <code>NULL</code>, it will
be estimated by kernel smoothing using <code><a href="#topic+density.lpp">density.lpp</a></code>.
</p>
<p>If <code>lambdaI</code> or <code>lambdaJ</code> is a fitted point process model,
the default behaviour is to update the model by re-fitting it to
the data, before computing the fitted intensity.
This can be disabled by setting <code>update=FALSE</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code> (see <code><a href="spatstat.explore.html#topic+fv.object">fv.object</a></code>).
</p>


<h3>Warnings</h3>

<p>The argument <code>i</code> is interpreted as a
level of the factor <code>marks(X)</code>. Beware of the usual
trap with factors: numerical values are not
interpreted in the same way as character values. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a></p>


<h3>References</h3>

<p>Baddeley, A, Jammalamadaka, A. and Nair, G. (2014)
Multitype point process analysis of spines on the
dendrite network of a neuron.
<em>Applied Statistics</em> (Journal of the Royal Statistical
Society, Series C), <b>63</b>, 673&ndash;694.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linearpcfdot">linearpcfdot</a></code>,
<code><a href="#topic+linearpcf">linearpcf</a></code>,
<code><a href="spatstat.explore.html#topic+pcfcross.inhom">pcfcross.inhom</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   lam &lt;- table(marks(chicago))/(summary(chicago)$totlength)
   lamI &lt;- function(x,y,const=lam[["assault"]]){ rep(const, length(x)) }
   lamJ &lt;- function(x,y,const=lam[["robbery"]]){ rep(const, length(x)) }

   g &lt;- linearpcfcross.inhom(chicago, "assault", "robbery", lamI, lamJ)

   # using fitted models for intensity
   # fit &lt;- lppm(chicago ~marks + x)
   # linearpcfcross.inhom(chicago, "assault", "robbery", fit, fit)
</code></pre>

<hr>
<h2 id='linearpcfdot'>
Multitype Pair Correlation Function (Dot-type) for Linear Point Pattern
</h2><span id='topic+linearpcfdot'></span>

<h3>Description</h3>

<p>For a multitype point pattern on a linear network,
estimate the multitype pair correlation function
from points of type <code class="reqn">i</code> to points of any type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linearpcfdot(X, i, r=NULL, ..., correction="Ang")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linearpcfdot_+3A_x">X</code></td>
<td>
<p>The observed point pattern, 
from which an estimate of the <code class="reqn">i</code>-to-any pair correlation function
<code class="reqn">g_{i\bullet}(r)</code> will be computed.
An object of class <code>"lpp"</code> which 
must be a multitype point pattern (a marked point pattern
whose marks are a factor).
</p>
</td></tr>
<tr><td><code id="linearpcfdot_+3A_i">i</code></td>
<td>
<p>Number or character string identifying the type (mark value)
of the points in <code>X</code> from which distances are measured.
Defaults to the first level of <code>marks(X)</code>.
</p>
</td></tr>
<tr><td><code id="linearpcfdot_+3A_r">r</code></td>
<td>
<p>numeric vector. The values of the argument <code class="reqn">r</code>
at which the function
<code class="reqn">g_{i\bullet}(r)</code> should be evaluated.
There is a sensible default.
First-time users are strongly advised not to specify this argument.
See below for important conditions on <code class="reqn">r</code>.
</p>
</td></tr>
<tr><td><code id="linearpcfdot_+3A_correction">correction</code></td>
<td>

<p>Geometry correction.
Either <code>"none"</code> or <code>"Ang"</code>. See Details.
</p>
</td></tr>
<tr><td><code id="linearpcfdot_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="stats.html#topic+density.default">density.default</a></code>
to control the kernel smoothing.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a counterpart of the function <code><a href="spatstat.explore.html#topic+pcfdot">pcfdot</a></code> 
for a point pattern on a linear network (object of class <code>"lpp"</code>).
</p>
<p>The argument <code>i</code> will be interpreted as
levels of the factor <code>marks(X)</code>. 
If <code>i</code> is missing, it defaults to the first
level of the marks factor.
</p>
<p>The argument <code>r</code> is the vector of values for the
distance <code class="reqn">r</code> at which <code class="reqn">g_{i\bullet}(r)</code>
should be evaluated. 
The values of <code class="reqn">r</code> must be increasing nonnegative numbers
and the maximum <code class="reqn">r</code> value must not exceed the radius of the
largest disc contained in the window.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code> (see <code><a href="spatstat.explore.html#topic+fv.object">fv.object</a></code>).
</p>


<h3>Warnings</h3>

<p>The argument <code>i</code> is interpreted as a
level of the factor <code>marks(X)</code>. Beware of the usual
trap with factors: numerical values are not
interpreted in the same way as character values. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>References</h3>

<p>Baddeley, A, Jammalamadaka, A. and Nair, G. (2014)
Multitype point process analysis of spines on the
dendrite network of a neuron.
<em>Applied Statistics</em> (Journal of the Royal Statistical
Society, Series C), <b>63</b>, 673&ndash;694.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linearpcfcross">linearpcfcross</a></code>,
<code><a href="#topic+linearpcf">linearpcf</a></code>.
<code><a href="spatstat.explore.html#topic+pcfcross">pcfcross</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   g &lt;- linearpcfdot(chicago, "assault")
</code></pre>

<hr>
<h2 id='linearpcfdot.inhom'>
Inhomogeneous Multitype
Pair Correlation Function (Dot-type) for Linear Point Pattern
</h2><span id='topic+linearpcfdot.inhom'></span>

<h3>Description</h3>

<p>For a multitype point pattern on a linear network,
estimate the inhomogeneous multitype pair correlation function
from points of type <code class="reqn">i</code> to points of any type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linearpcfdot.inhom(X, i, lambdaI, lambdadot, r=NULL, ...,
                   correction="Ang", normalise=TRUE,
                   sigma=NULL, adjust.sigma=1,
                   bw="nrd0", adjust.bw=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linearpcfdot.inhom_+3A_x">X</code></td>
<td>
<p>The observed point pattern, 
from which an estimate of the <code class="reqn">i</code>-to-any pair correlation function
<code class="reqn">g_{i\bullet}(r)</code> will be computed.
An object of class <code>"lpp"</code> which 
must be a multitype point pattern (a marked point pattern
whose marks are a factor).
</p>
</td></tr>
<tr><td><code id="linearpcfdot.inhom_+3A_i">i</code></td>
<td>
<p>Number or character string identifying the type (mark value)
of the points in <code>X</code> from which distances are measured.
Defaults to the first level of <code>marks(X)</code>.
</p>
</td></tr>
<tr><td><code id="linearpcfdot.inhom_+3A_lambdai">lambdaI</code></td>
<td>

<p>Intensity values for the points of type <code>i</code>. Either a numeric vector,
a <code>function</code>, a pixel image
(object of class <code>"im"</code> or <code>"linim"</code>) or
a fitted point process model (object of class <code>"ppm"</code>
or <code>"lppm"</code>) or <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="linearpcfdot.inhom_+3A_lambdadot">lambdadot</code></td>
<td>

<p>Intensity values for all points of <code>X</code>. Either a numeric vector,
a <code>function</code>, a pixel image
(object of class <code>"im"</code> or <code>"linim"</code>) or
a fitted point process model (object of class <code>"ppm"</code>
or <code>"lppm"</code>) or <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="linearpcfdot.inhom_+3A_r">r</code></td>
<td>
<p>numeric vector. The values of the argument <code class="reqn">r</code>
at which the function
<code class="reqn">g_{i\bullet}(r)</code> should be evaluated.
There is a sensible default.
First-time users are strongly advised not to specify this argument.
See below for important conditions on <code class="reqn">r</code>.
</p>
</td></tr>
<tr><td><code id="linearpcfdot.inhom_+3A_correction">correction</code></td>
<td>

<p>Geometry correction.
Either <code>"none"</code> or <code>"Ang"</code>. See Details.
</p>
</td></tr>
<tr><td><code id="linearpcfdot.inhom_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="stats.html#topic+density.default">density.default</a></code>
to control the kernel smoothing.
</p>
</td></tr>
<tr><td><code id="linearpcfdot.inhom_+3A_normalise">normalise</code></td>
<td>

<p>Logical. If <code>TRUE</code> (the default), the denominator of the estimator is 
data-dependent (equal to the sum of the reciprocal intensities at
the points of type <code>i</code>), which reduces the sampling variability.
If <code>FALSE</code>, the denominator is the length of the network.
</p>
</td></tr>
<tr><td><code id="linearpcfdot.inhom_+3A_sigma">sigma</code></td>
<td>

<p>Smoothing bandwidth passed to <code><a href="#topic+density.lpp">density.lpp</a></code>
for estimation of intensities when either <code>lambdaI</code> or
<code>lambdadot</code> is <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="linearpcfdot.inhom_+3A_adjust.sigma">adjust.sigma</code></td>
<td>

<p>Numeric value. <code>sigma</code> will be multiplied by this value.
</p>
</td></tr>
<tr><td><code id="linearpcfdot.inhom_+3A_bw">bw</code></td>
<td>

<p>Smoothing bandwidth (passed to <code><a href="stats.html#topic+density.default">density.default</a></code>)
for one-dimensional kernel smoothing of the pair correlation function.
Either a numeric value, or a character string recognised
by <code><a href="stats.html#topic+density.default">density.default</a></code>.
</p>
</td></tr>
<tr><td><code id="linearpcfdot.inhom_+3A_adjust.bw">adjust.bw</code></td>
<td>

<p>Numeric value. <code>bw</code> will be multiplied by this value.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a counterpart of the function <code><a href="spatstat.explore.html#topic+pcfdot.inhom">pcfdot.inhom</a></code> 
for a point pattern on a linear network (object of class <code>"lpp"</code>).
</p>
<p>The argument <code>i</code> will be interpreted as
levels of the factor <code>marks(X)</code>. 
If <code>i</code> is missing, it defaults to the first
level of the marks factor.
</p>
<p>The argument <code>r</code> is the vector of values for the
distance <code class="reqn">r</code> at which <code class="reqn">g_{i\bullet}(r)</code>
should be evaluated. 
The values of <code class="reqn">r</code> must be increasing nonnegative numbers
and the maximum <code class="reqn">r</code> value must not exceed the radius of the
largest disc contained in the window.
</p>
<p>If <code>lambdaI</code> or <code>lambdadot</code> is missing or <code>NULL</code>, it will
be estimated by kernel smoothing using <code><a href="#topic+density.lpp">density.lpp</a></code>.
</p>
<p>If <code>lambdaI</code> or <code>lambdadot</code> is a fitted point process model,
the default behaviour is to update the model by re-fitting it to
the data, before computing the fitted intensity.
This can be disabled by setting <code>update=FALSE</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"fv"</code> (see <code><a href="spatstat.explore.html#topic+fv.object">fv.object</a></code>).
</p>


<h3>Warnings</h3>

<p>The argument <code>i</code> is interpreted as a
level of the factor <code>marks(X)</code>. Beware of the usual
trap with factors: numerical values are not
interpreted in the same way as character values. 
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a></p>


<h3>References</h3>

<p>Baddeley, A, Jammalamadaka, A. and Nair, G. (2014)
Multitype point process analysis of spines on the
dendrite network of a neuron.
<em>Applied Statistics</em> (Journal of the Royal Statistical
Society, Series C), <b>63</b>, 673&ndash;694.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linearpcfcross.inhom">linearpcfcross.inhom</a></code>,
<code><a href="#topic+linearpcfcross">linearpcfcross</a></code>,
<code><a href="spatstat.explore.html#topic+pcfcross.inhom">pcfcross.inhom</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   lam &lt;- table(marks(chicago))/(summary(chicago)$totlength)
   lamI &lt;- function(x,y,const=lam[["assault"]]){ rep(const, length(x)) }
   lam. &lt;- function(x,y,const=sum(lam)){ rep(const, length(x)) }

   g &lt;- linearpcfdot.inhom(chicago, "assault", lamI, lam.)

   # using fitted models for the intensity
   # fit &lt;- lppm(chicago, ~marks + x)
   # linearpcfdot.inhom(chicago, "assault", fit, fit)
</code></pre>

<hr>
<h2 id='linearpcfEuclid'>
Linear Pair Correlation Function Using Euclidean Distance
</h2><span id='topic+linearpcfEuclid'></span>

<h3>Description</h3>

<p>Computes an estimate of the pair correlation function
based on Euclidean distances,
for a point pattern on a linear network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linearpcfEuclid(X, r = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linearpcfEuclid_+3A_x">X</code></td>
<td>

<p>Point pattern on linear network (object of class <code>"lpp"</code>).
</p>
</td></tr>
<tr><td><code id="linearpcfEuclid_+3A_r">r</code></td>
<td>

<p>Optional. Numeric vector of values of the function argument <code class="reqn">r</code>.
There is a sensible default.
</p>
</td></tr>
<tr><td><code id="linearpcfEuclid_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command computes an estimate of the pair correlation function
based on Euclidean distances between the points, as described by
Rakshit, Nair and Baddeley (2017).
</p>
<p>This is different from the linear pair correlation function
based on shortest-path distances, which is computed by <code><a href="#topic+linearpcf">linearpcf</a></code>.
</p>
<p>The linear pair correlation function based on Euclidean distances
is defined in equation (15) of Rakshit, Nair and Baddeley (2017).
The estimate is computed from the point pattern as described in equation (31).
</p>


<h3>Value</h3>

<p>Function value table (object of class <code>"fv"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Rakshit. S., Nair, G. and Baddeley, A. (2017)
Second-order analysis of point patterns on a network
using any distance metric. <em>Spatial Statistics</em> <b>22</b> (1) 129&ndash;154.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linearKEuclid">linearKEuclid</a></code>, <code><a href="#topic+linearpcfEuclidInhom">linearpcfEuclidInhom</a></code>.
</p>
<p>See <code><a href="#topic+linearpcf">linearpcf</a></code> for the corresponding function
based on shortest-path distances.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- rpoislpp(5, simplenet)
  g &lt;- linearpcfEuclid(X)
</code></pre>

<hr>
<h2 id='linearpcfEuclidInhom'>
Inhomogeneous Linear Pair Correlation Function Based on Euclidean Distances
</h2><span id='topic+linearpcfEuclidInhom'></span>

<h3>Description</h3>

<p>Computes an estimate of the inhomogeneous pair correlation function
based on Euclidean distances, for a point pattern on a linear network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   linearpcfEuclidInhom(X, lambda = NULL, r = NULL, ...,
      normalise = TRUE, normpower = 2,
      update = TRUE, leaveoneout = TRUE,
      sigma=NULL, adjust.sigma=1, bw="nrd0", adjust.bw=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linearpcfEuclidInhom_+3A_x">X</code></td>
<td>

<p>Point pattern on linear network (object of class <code>"lpp"</code>).
</p>
</td></tr>
<tr><td><code id="linearpcfEuclidInhom_+3A_lambda">lambda</code></td>
<td>

<p>Intensity values for the point pattern. Either a numeric vector,
a <code>function</code>, a pixel image
(object of class <code>"im"</code> or <code>"linim"</code>) or
a fitted point process model (object of class <code>"ppm"</code>
or <code>"lppm"</code>) or <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="linearpcfEuclidInhom_+3A_r">r</code></td>
<td>

<p>Optional. Numeric vector of values of the function argument <code class="reqn">r</code>.
There is a sensible default.
</p>
</td></tr>
<tr><td><code id="linearpcfEuclidInhom_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="linearpcfEuclidInhom_+3A_normalise">normalise</code></td>
<td>

<p>Logical. If <code>TRUE</code> (the default), the denominator of the estimator is 
data-dependent (equal to the sum of the reciprocal intensities at the data
points, raised to <code>normpower</code>), which reduces the sampling variability.
If <code>FALSE</code>, the denominator is the length of the network.
</p>
</td></tr>
<tr><td><code id="linearpcfEuclidInhom_+3A_normpower">normpower</code></td>
<td>

<p>Integer (usually either 1 or 2).
Normalisation power. See Details.
</p>
</td></tr>
<tr><td><code id="linearpcfEuclidInhom_+3A_update">update</code></td>
<td>

<p>Logical value indicating what to do when <code>lambda</code> is a fitted model
(class <code>"lppm"</code> or <code>"ppm"</code>).
If <code>update=TRUE</code> (the default),
the model will first be refitted to the data <code>X</code>
(using <code><a href="#topic+update.lppm">update.lppm</a></code> or <code><a href="spatstat.model.html#topic+update.ppm">update.ppm</a></code>)
before the fitted intensity is computed.
If <code>update=FALSE</code>, the fitted intensity of the
model will be computed without re-fitting it to <code>X</code>.
</p>
</td></tr>
<tr><td><code id="linearpcfEuclidInhom_+3A_leaveoneout">leaveoneout</code></td>
<td>

<p>Logical value specifying whether to use a
leave-one-out rule when calculating the intensity.
See Details.
</p>
</td></tr>
<tr><td><code id="linearpcfEuclidInhom_+3A_sigma">sigma</code></td>
<td>

<p>Smoothing bandwidth (passed to <code><a href="#topic+density.lpp">density.lpp</a></code>)
for kernel density estimation of the intensity when
<code>lambda=NULL</code>.
</p>
</td></tr>
<tr><td><code id="linearpcfEuclidInhom_+3A_adjust.sigma">adjust.sigma</code></td>
<td>

<p>Numeric value. <code>sigma</code> will be multiplied by this value.
</p>
</td></tr>
<tr><td><code id="linearpcfEuclidInhom_+3A_bw">bw</code></td>
<td>

<p>Smoothing bandwidth (passed to <code><a href="stats.html#topic+density.default">density.default</a></code>)
for one-dimensional kernel smoothing of the pair correlation function.
Either a numeric value, or a character string recognised
by <code><a href="stats.html#topic+density.default">density.default</a></code>.
</p>
</td></tr>
<tr><td><code id="linearpcfEuclidInhom_+3A_adjust.bw">adjust.bw</code></td>
<td>

<p>Numeric value. <code>bw</code> will be multiplied by this value.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command computes the inhomogeneous version of the 
pair correlation function based on <em>Euclidean</em> distances,
for a point pattern on a linear network.
</p>
<p>This is different from the inhomogeneous pair correlation function based on
<em>shortest-path</em> distances,
which is computed by <code><a href="#topic+linearpcfinhom">linearpcfinhom</a></code>.
</p>
<p>The inhomogeneous pair correlation function
based on <em>Euclidean</em> distances
is defined in equation (30) of Rakshit, Nair and Baddeley (2017).
Estimation is performed as described in equation (34) of 
Rakshit, Nair and Baddeley (2017).
</p>
<p>The argument <code>lambda</code> should provide estimated values
of the intensity of the point process at each point of <code>X</code>.
</p>
<p>If <code>lambda=NULL</code>, the intensity will be estimated by kernel
smoothing by calling <code><a href="#topic+density.lpp">density.lpp</a></code> with the smoothing
bandwidth <code>sigma</code>, and with any other relevant arguments
that might be present in <code>...</code>. A leave-one-out kernel estimate
will be computed if <code>leaveoneout=TRUE</code>.
</p>
<p>If <code>lambda</code> is given, then it
may be a numeric vector (of length equal to
the number of points in <code>X</code>), or a <code>function(x,y)</code> that will be
evaluated at the points of <code>X</code> to yield numeric values, 
or a pixel image (object of class <code>"im"</code>) or a fitted point 
process model (object of class <code>"ppm"</code> or <code>"lppm"</code>).
</p>
<p>If <code>lambda</code> is a fitted point process model,
the default behaviour is to update the model by re-fitting it to
the data, before computing the fitted intensity.
This can be disabled by setting <code>update=FALSE</code>.
The intensity at data points will be computed
by <code><a href="#topic+fitted.lppm">fitted.lppm</a></code> or <code><a href="spatstat.model.html#topic+fitted.ppm">fitted.ppm</a></code>.
A leave-one-out estimate will be computed if <code>leaveoneout=TRUE</code>
and <code>update=TRUE</code>.
</p>
<p>If <code>normalise=TRUE</code> (the default), then the estimate
is multiplied by <code class="reqn">c^{\mbox{normpower}}</code> where 
<code class="reqn">
    c = \mbox{length}(L)/\sum (1/\lambda(x_i)).
  </code>
This rescaling reduces the variability and bias of the estimate
in small samples and in cases of very strong inhomogeneity.
The default value of <code>normpower</code> is 1 (for consistency with
previous versions of <span class="pkg">spatstat</span>)
but the most sensible value is 2, which would correspond to rescaling
the <code>lambda</code> values so that
<code class="reqn">
    \sum (1/\lambda(x_i)) = \mbox{area}(W).
  </code>
</p>


<h3>Value</h3>

<p>Function value table (object of class <code>"fv"</code>).
</p>


<h3>Warning</h3>

<p>Older versions of <code><a href="#topic+linearpcfEuclidInhom">linearpcfEuclidInhom</a></code> interpreted
<code>lambda=NULL</code> to mean that the homogeneous function
<code><a href="#topic+linearpcfEuclid">linearpcfEuclid</a></code> should be computed. This was changed to the
current behaviour in version <code>3.1-0</code> of <span class="pkg">spatstat.linnet</span>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Rakshit. S., Nair, G. and Baddeley, A. (2017)
Second-order analysis of point patterns on a network
using any distance metric. <em>Spatial Statistics</em> <b>22</b> (1) 129&ndash;154.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linearKEuclidInhom">linearKEuclidInhom</a></code>, <code><a href="#topic+linearpcfEuclid">linearpcfEuclid</a></code>.
</p>
<p>See <code><a href="#topic+linearpcfinhom">linearpcfinhom</a></code> for the corresponding function
based on shortest-path distances.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- rpoislpp(5, simplenet)
  fit &lt;- lppm(X ~x)
  g &lt;- linearpcfEuclidInhom(X, lambda=fit)
  plot(g)
</code></pre>

<hr>
<h2 id='linearpcfinhom'>
Inhomogeneous Linear Pair Correlation Function
</h2><span id='topic+linearpcfinhom'></span>

<h3>Description</h3>

<p>Computes an estimate of the inhomogeneous linear pair correlation function
for a point pattern on a linear network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linearpcfinhom(X, lambda=NULL, r=NULL, ..., correction="Ang",
               normalise=TRUE, normpower=1,
	       update = TRUE, leaveoneout = TRUE,
               sigma=NULL, adjust.sigma=1,
               bw="nrd0", adjust.bw=1,
	       ratio = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linearpcfinhom_+3A_x">X</code></td>
<td>

<p>Point pattern on linear network (object of class <code>"lpp"</code>).
</p>
</td></tr>
<tr><td><code id="linearpcfinhom_+3A_lambda">lambda</code></td>
<td>

<p>Intensity values for the point pattern. Either a numeric vector,
a <code>function</code>, a pixel image (object of class <code>"im"</code>) or
a fitted point process model (object of class <code>"ppm"</code>
or <code>"lppm"</code>).
</p>
</td></tr>
<tr><td><code id="linearpcfinhom_+3A_r">r</code></td>
<td>

<p>Optional. Numeric vector of values of the function argument <code class="reqn">r</code>.
There is a sensible default.
</p>
</td></tr>
<tr><td><code id="linearpcfinhom_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="stats.html#topic+density.default">density.default</a></code>
to control the smoothing of the estimates of pair correlation.
</p>
</td></tr>
<tr><td><code id="linearpcfinhom_+3A_correction">correction</code></td>
<td>

<p>Geometry correction.
Either <code>"none"</code> or <code>"Ang"</code>. See Details.
</p>
</td></tr>
<tr><td><code id="linearpcfinhom_+3A_normalise">normalise</code></td>
<td>

<p>Logical. If <code>TRUE</code> (the default), the denominator of the estimator is 
data-dependent (equal to the sum of the reciprocal intensities at the data
points, raised to <code>normpower</code>), which reduces the sampling variability.
If <code>FALSE</code>, the denominator is the length of the network.
</p>
</td></tr>
<tr><td><code id="linearpcfinhom_+3A_normpower">normpower</code></td>
<td>

<p>Integer (usually either 1 or 2).
Normalisation power. See explanation in <code><a href="#topic+linearKinhom">linearKinhom</a></code>.
</p>
</td></tr>
<tr><td><code id="linearpcfinhom_+3A_update">update</code></td>
<td>

<p>Logical value indicating what to do when <code>lambda</code> is a fitted model
(class <code>"lppm"</code> or <code>"ppm"</code>).
If <code>update=TRUE</code> (the default),
the model will first be refitted to the data <code>X</code>
(using <code><a href="#topic+update.lppm">update.lppm</a></code> or <code><a href="spatstat.model.html#topic+update.ppm">update.ppm</a></code>)
before the fitted intensity is computed.
If <code>update=FALSE</code>, the fitted intensity of the
model will be computed without re-fitting it to <code>X</code>.
</p>
</td></tr>
<tr><td><code id="linearpcfinhom_+3A_leaveoneout">leaveoneout</code></td>
<td>

<p>Logical value specifying whether to use a
leave-one-out rule when calculating the intensity.
See Details.
</p>
</td></tr>
<tr><td><code id="linearpcfinhom_+3A_sigma">sigma</code></td>
<td>

<p>Smoothing bandwidth (passed to <code><a href="#topic+density.lpp">density.lpp</a></code>)
for kernel density estimation of the intensity when
<code>lambda=NULL</code>.
</p>
</td></tr>
<tr><td><code id="linearpcfinhom_+3A_adjust.sigma">adjust.sigma</code></td>
<td>

<p>Numeric value. <code>sigma</code> will be multiplied by this value.
</p>
</td></tr>
<tr><td><code id="linearpcfinhom_+3A_bw">bw</code></td>
<td>

<p>Smoothing bandwidth (passed to <code><a href="stats.html#topic+density.default">density.default</a></code>)
for one-dimensional kernel smoothing of the pair correlation function.
Either a numeric value, or a character string recognised
by <code><a href="stats.html#topic+density.default">density.default</a></code>.
</p>
</td></tr>
<tr><td><code id="linearpcfinhom_+3A_adjust.bw">adjust.bw</code></td>
<td>

<p>Numeric value. <code>bw</code> will be multiplied by this value.
</p>
</td></tr>
<tr><td><code id="linearpcfinhom_+3A_ratio">ratio</code></td>
<td>

<p>Logical. 
If <code>TRUE</code>, the numerator and denominator of
each estimate will also be saved,
for use in analysing replicated point patterns.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command computes the inhomogeneous version of the 
linear pair correlation function from point pattern data on a linear network.
</p>
<p>The argument <code>lambda</code> should provide estimated values
of the intensity of the point process at each point of <code>X</code>.
</p>
<p>If <code>lambda=NULL</code>, the intensity will be estimated by kernel
smoothing by calling <code><a href="#topic+density.lpp">density.lpp</a></code> with the smoothing
bandwidth <code>sigma</code>, and with any other relevant arguments
that might be present in <code>...</code>.  A leave-one-out kernel estimate
will be computed if <code>leaveoneout=TRUE</code>.
</p>
<p>If <code>lambda</code> is given, 
it may be a numeric vector (of length equal to
the number of points in <code>X</code>), or a <code>function(x,y)</code> that will be
evaluated at the points of <code>X</code> to yield numeric values, 
or a pixel image (object of class <code>"im"</code>) or a fitted point 
process model (object of class <code>"ppm"</code> or <code>"lppm"</code>).
</p>
<p>If <code>lambda</code> is a fitted point process model,
the default behaviour is to update the model by re-fitting it to
the data, before computing the fitted intensity.
This can be disabled by setting <code>update=FALSE</code>.
The intensity at data points will be computed
by <code><a href="#topic+fitted.lppm">fitted.lppm</a></code> or <code><a href="spatstat.model.html#topic+fitted.ppm">fitted.ppm</a></code>.
A leave-one-out estimate will be computed if <code>leaveoneout=TRUE</code>
and <code>update=TRUE</code>.
</p>
<p>If <code>correction="none"</code>, the calculations do not include
any correction for the geometry of the linear network.
If <code>correction="Ang"</code>, the pair counts are weighted using
Ang's correction (Ang, 2010). 
</p>
<p>The bandwidth for smoothing the pairwise distances
is determined by arguments <code>...</code>
passed to <code><a href="stats.html#topic+density.default">density.default</a></code>, mainly the arguments
<code>bw</code> and <code>adjust</code>. The default is
to choose the bandwidth by Silverman's rule of thumb 
<code>bw="nrd0"</code> explained in <code><a href="stats.html#topic+density.default">density.default</a></code>.
</p>


<h3>Value</h3>

<p>Function value table (object of class <code>"fv"</code>).
</p>
<p>If <code>ratio=TRUE</code> then the return value also has two
attributes called <code>"numerator"</code> and <code>"denominator"</code>
which are <code>"fv"</code> objects
containing the numerators and denominators of each
estimate of <code class="reqn">g(r)</code>. 
</p>


<h3>Warning</h3>

<p>Older versions of <code><a href="#topic+linearpcfinhom">linearpcfinhom</a></code> interpreted
<code>lambda=NULL</code> to mean that the homogeneous function
<code><a href="#topic+linearpcf">linearpcf</a></code> should be computed. This was changed to the
current behaviour in version <code>3.1-0</code> of <span class="pkg">spatstat.linnet</span>.
</p>


<h3>Author(s)</h3>

<p>Ang Qi Wei <a href="mailto:aqw07398@hotmail.com">aqw07398@hotmail.com</a> and
Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Ang, Q.W. (2010) Statistical methodology for spatial point patterns
on a linear network. MSc thesis, University of Western Australia.
</p>
<p>Ang, Q.W., Baddeley, A. and Nair, G. (2012)
Geometrically corrected second-order analysis of 
events on a linear network, with applications to
ecology and criminology.
<em>Scandinavian Journal of Statistics</em> <b>39</b>, 591&ndash;617.
</p>
<p>Okabe, A. and Yamada, I. (2001) The K-function method on a network and
its computational implementation. <em>Geographical Analysis</em>
<b>33</b>, 271-290.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linearpcf">linearpcf</a></code>,
<code><a href="#topic+linearKinhom">linearKinhom</a></code>,
<code><a href="#topic+lpp">lpp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- rpoislpp(5, simplenet)
  fit &lt;- lppm(X ~x)
  g &lt;- linearpcfinhom(X, lambda=fit, update=FALSE)
  plot(g)
  ge &lt;- linearpcfinhom(X, sigma=bw.lppl)
</code></pre>

<hr>
<h2 id='lineartileindex'>
Determine Which Tile Contains Each Given Point on a Linear Network
</h2><span id='topic+lineartileindex'></span>

<h3>Description</h3>

<p>Given a tessellation on a linear network,
and a list of points on the network,
determine which tile of the tessellation contains each of the given points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lineartileindex(seg, tp, Z, method = c("encode", "C", "interpreted"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lineartileindex_+3A_seg">seg</code>, <code id="lineartileindex_+3A_tp">tp</code></td>
<td>

<p>Vectors of local coordinates of the query points.
See Details.
</p>
</td></tr>
<tr><td><code id="lineartileindex_+3A_z">Z</code></td>
<td>

<p>A tessellation on a linear network (object of class
<code>"lintess"</code>).
</p>
</td></tr>
<tr><td><code id="lineartileindex_+3A_method">method</code></td>
<td>

<p>Internal use only.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This low-level function is 
the analogue of <code><a href="spatstat.geom.html#topic+tileindex">tileindex</a></code> for linear networks.
For a tessellation <code>Z</code> on a linear network,
and a list of query points on the same network,
the function determines which tile of the tessellation 
contains each query point.
</p>
<p>Argument <code>Z</code> should be a tessellation on a linear network
(object of class <code>"lintess"</code>).
</p>
<p>The vectors <code>seg</code> and <code>tp</code> specify the locations
of the query points, on the same network, using local coordinates:
<code>seg</code> contains integer values specifying which
segment of the network contains each query point;
<code>tp</code> contains numeric values between 0 and 1 specifying the
fractional position along that segment.
</p>
<p>The result is a factor, of the same length as <code>seg</code> and <code>tp</code>,
indicating which tile contains each point. The levels of the factor
are the names of the tiles of <code>Z</code>.
</p>


<h3>Value</h3>

<p>A factor, of the same length as <code>seg</code> and <code>tp</code>,
whose levels are the names of the tiles of <code>Z</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lintess">lintess</a></code>.
</p>
<p><code><a href="#topic+as.linfun.lintess">as.linfun.lintess</a></code> to create a function whose
value is the tile index.
</p>
<p><code><a href="#topic+cut.lpp">cut.lpp</a></code> for a neater way to classify
the points of a point pattern on a linear network
according to a tessellation on the network.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   Z &lt;- lineardirichlet(runiflpp(15, simplenet))
   X &lt;- runiflpp(10, simplenet)
   coX &lt;- coords(X)
   ii &lt;- lineartileindex(coX$seg, coX$tp, Z)
</code></pre>

<hr>
<h2 id='linequad'>
Quadrature Scheme on a Linear Network
</h2><span id='topic+linequad'></span>

<h3>Description</h3>

<p>Generates a quadrature scheme (an object of class <code>"quad"</code>)
on a linear network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linequad(X, Y, ..., eps = NULL, nd = 1000, random = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linequad_+3A_x">X</code></td>
<td>

<p>Data points. An object of class <code>"lpp"</code> or <code>"ppp"</code>.
</p>
</td></tr>
<tr><td><code id="linequad_+3A_y">Y</code></td>
<td>

<p>Line segments on which the points of <code>X</code> lie.
An object of class <code>"psp"</code>.
Required only when <code>X</code> is a <code>"ppp"</code> object.
</p>
</td></tr>
<tr><td><code id="linequad_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="linequad_+3A_eps">eps</code></td>
<td>

<p>Optional. Spacing between successive dummy points along each
segment. (This is the maximum spacing; some spacings will be shorter.)
</p>
</td></tr>
<tr><td><code id="linequad_+3A_nd">nd</code></td>
<td>

<p>Optional. Total number of dummy points to be generated.
(Actual number may be larger.)
</p>
</td></tr>
<tr><td><code id="linequad_+3A_random">random</code></td>
<td>

<p>Logical value indicating whether the sequence of dummy points
should start at a randomly-chosen position along each segment.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command generates a quadrature scheme (object of class
<code>"quad"</code>) from a pattern of points on a linear network.
</p>
<p>Normally the user does not need to call <code>linequad</code> explicitly.
It is invoked by <span class="pkg">spatstat</span> functions when needed.
A quadrature scheme is required by <code><a href="#topic+lppm">lppm</a></code>
in order to fit point process models to point pattern data on a linear
network. A quadrature scheme is also used by <code><a href="#topic+rhohat.lpp">rhohat.lpp</a></code>
and other functions.
</p>
<p>In order to create the quadrature scheme, dummy points are placed
along each line segment of the network. The dummy points are 
evenly-spaced with spacing <code>eps</code>. The default is
<code>eps = totlen/nd</code> where <code>totlen</code> is the total length of
all line segments in the network.
</p>
<p>Every line segment of the network will contain at least one dummy
point. Consequently the actual number of dummy points generated
will typically be greater than <code>nd</code>,
especially when <code>nd</code> is small.
If <code>eps</code> is specified, the
number of dummy points will be greater than <code>totlen/eps</code>,
especially when <code>eps</code> is large.
</p>


<h3>Value</h3>

<p>A quadrature scheme (object of class <code>"quad"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>,
Greg McSwiggan and Suman Rakshit.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lppm">lppm</a></code>
</p>

<hr>
<h2 id='linfun'>
Function on a Linear Network
</h2><span id='topic+linfun'></span>

<h3>Description</h3>

<p>Create a function on a linear network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  linfun(f, L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linfun_+3A_f">f</code></td>
<td>

<p>A <code>function</code> in the <span class="rlang"><b>R</b></span> language.
</p>
</td></tr>
<tr><td><code id="linfun_+3A_l">L</code></td>
<td>

<p>A linear network (object of class <code>"linnet"</code>)
on which <code>f</code> is defined.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This creates an object of class <code>"linfun"</code>.
This is a simple mechanism for handling a function
defined on a linear network, to make it easier to display
and manipulate.
</p>
<p><code>f</code> should be a <code>function</code> in the <span class="rlang"><b>R</b></span> language,
with formal arguments <code>x,y,seg,tp</code> (and optional additional
arguments) where <code>x,y</code> are
Cartesian coordinates of locations on the linear network,
<code>seg, tp</code> are the local coordinates. 
</p>
<p>The function <code>f</code> should be vectorised: that is,
if <code>x,y,seg,tp</code> are numeric vectors of the same length
<code>n</code>, then <code>v &lt;- f(x,y,seg,tp)</code>
should be a vector of length <code>n</code>.
</p>
<p><code>L</code> should be a linear network (object of class <code>"linnet"</code>)
on which the function <code>f</code> is well-defined.
</p>
<p>The result is a function <code>g</code> in the <span class="rlang"><b>R</b></span> language which belongs to
the special class <code>"linfun"</code>. There are several methods
for this class including <code>print</code>, <code>plot</code>
and <code><a href="#topic+as.linim">as.linim</a></code>.
</p>
<p>This function can be called as <code>g(X)</code>
where <code>X</code> is an <code>"lpp"</code> object,
or called as <code>g(x,y)</code> or <code>g(x,y,seg,tp)</code> where
<code>x,y,seg,tp</code> are coordinates. If the original function <code>f</code>
had additional arguments, then these may be included in the call
to <code>g</code>, and will be passed to <code>f</code>.
</p>


<h3>Value</h3>

<p>A function in the <span class="rlang"><b>R</b></span>\ language.
It also belongs to the class <code>"linfun"</code> which has methods
for <code>plot</code>, <code>print</code> etc.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+methods.linfun">methods.linfun</a></code> for methods applicable to
<code>"linfun"</code> objects.
</p>
<p><code><a href="#topic+distfun.lpp">distfun.lpp</a></code>,
<code><a href="#topic+nnfun.lpp">nnfun.lpp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  f &lt;- function(x,y,seg,tp) { x+y }
  g &lt;- linfun(f, simplenet)
  plot(g)
  X &lt;- runiflpp(3, simplenet)
  g(X)
  Z &lt;- as.linim(g)

  f &lt;- function(x,y,seg,tp, mul=1) { mul*(x+y) }
  g &lt;- linfun(f, simplenet)
  plot(g)
  plot(g, mul=10)
  g(X, mul=10)
  Z &lt;- as.linim(g, mul=10)
</code></pre>

<hr>
<h2 id='linim'>
Create Pixel Image on Linear Network
</h2><span id='topic+linim'></span>

<h3>Description</h3>

<p>Creates an object of class <code>"linim"</code> that represents
a pixel image on a linear network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  linim(L, Z, ..., restrict=TRUE, df=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linim_+3A_l">L</code></td>
<td>

<p>Linear network (object of class <code>"linnet"</code>).
</p>
</td></tr>
<tr><td><code id="linim_+3A_z">Z</code></td>
<td>

<p>Pixel image (object of class <code>"im"</code>).
</p>
</td></tr>
<tr><td><code id="linim_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="linim_+3A_restrict">restrict</code></td>
<td>

<p>Advanced use only.
Logical value indicating whether to ensure that all pixels in <code>Z</code>
which do not lie on the network <code>L</code> have pixel value <code>NA</code>.
This condition must be satisfied, but if you set
<code>restrict=FALSE</code> it will not be checked, and the code will
run faster.
</p>
</td></tr>
<tr><td><code id="linim_+3A_df">df</code></td>
<td>

<p>Advanced use only. Data frame giving full details of the mapping between
the pixels of <code>Z</code> and the lines of <code>L</code>.
See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command creates an object of class <code>"linim"</code> that represents
a pixel image defined on a linear network.
Typically such objects are
used to represent the result of smoothing or model-fitting on the
network. Most users will not need to call <code>linim</code> directly.
</p>
<p>The argument <code>L</code> is a linear network (object of class <code>"linnet"</code>).
It gives the exact spatial locations
of the line segments of the network, and their connectivity.
</p>
<p>The argument <code>Z</code> is a pixel image object of class <code>"im"</code>
that gives a pixellated approximation of the function values.
</p>
<p>For increased efficiency, advanced users may specify the 
optional argument <code>df</code>. This is a data frame giving the
precomputed mapping between the pixels of <code>Z</code>
and the line segments of <code>L</code>.
It should have columns named <code>xc, yc</code> containing the coordinates of
the pixel centres, <code>x,y</code> containing the projections of these
pixel centres onto the linear network, <code>mapXY</code> identifying the
line segment on which each projected point lies, and <code>tp</code> giving
the parametric position of <code>(x,y)</code> along the segment.
</p>


<h3>Value</h3>

<p>Object of class <code>"linim"</code> that also inherits the class
<code>"im"</code>.
There is a special method for plotting this class.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>References</h3>

<p>Ang, Q.W. (2010)
<em>Statistical methodology for events on a network</em>.
Master's thesis, School of Mathematics and Statistics, University of
Western Australia.
</p>
<p>Ang, Q.W., Baddeley, A. and Nair, G. (2012)
Geometrically corrected second-order analysis of 
events on a linear network, with applications to
ecology and criminology.
<em>Scandinavian Journal of Statistics</em> <b>39</b>, 591&ndash;617.
</p>
<p>McSwiggan, G., Nair, M.G. and Baddeley, A. (2012)
Fitting Poisson point process models to events 
on a linear network. Manuscript in preparation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.linim">plot.linim</a></code>,
<code><a href="#topic+linnet">linnet</a></code>,
<code><a href="#topic+eval.linim">eval.linim</a></code>,
<code><a href="#topic+Math.linim">Math.linim</a></code>,
<code><a href="spatstat.geom.html#topic+im">im</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  Z &lt;- as.im(function(x,y) {x-y}, Frame(simplenet))
  X &lt;- linim(simplenet, Z)
  X
</code></pre>

<hr>
<h2 id='linnet'>
Create a Linear Network
</h2><span id='topic+linnet'></span>

<h3>Description</h3>

<p>Creates an object of class <code>"linnet"</code> representing
a network of line segments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linnet(vertices, m, edges, sparse=FALSE, warn=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linnet_+3A_vertices">vertices</code></td>
<td>

<p>Point pattern (object of class <code>"ppp"</code>)
specifying the vertices of the network.
</p>
</td></tr>
<tr><td><code id="linnet_+3A_m">m</code></td>
<td>

<p>Adjacency matrix. A matrix or sparse matrix
of logical values equal to <code>TRUE</code>
when the corresponding vertices are joined by a line.
(Specify either <code>m</code> or <code>edges</code>.)
</p>
</td></tr>
<tr><td><code id="linnet_+3A_edges">edges</code></td>
<td>

<p>Edge list. A two-column matrix of integers,
specifying all pairs of vertices
that should be joined by an edge. 
(Specify either <code>m</code> or <code>edges</code>.)
</p>
</td></tr>
<tr><td><code id="linnet_+3A_sparse">sparse</code></td>
<td>

<p>Optional. Logical value indicating whether to use a
sparse matrix representation of the network. See Details.
</p>
</td></tr>
<tr><td><code id="linnet_+3A_warn">warn</code></td>
<td>

<p>Logical value indicating whether to issue a warning if the resulting
network is not connected.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object of class <code>"linnet"</code> represents a network of
straight line segments in two dimensions. The function <code>linnet</code> creates
such an object from the minimal information: the spatial location
of each vertex (endpoint, crossing point or meeting point of lines)
and information about which vertices are joined by an edge.
</p>
<p>If <code>sparse=FALSE</code> (the default), the algorithm will compute
and store various properties of the network, including
the adjacency matrix <code>m</code> and a matrix giving the
shortest-path distances between each pair of vertices in the network.
This is more efficient for small datasets. However it can require
large amounts of memory and can take a long time to execute.
</p>
<p>If <code>sparse=TRUE</code>, then the shortest-path distances will not be computed,
and the network adjacency matrix <code>m</code> will be stored as a
sparse matrix. This saves a lot of time and memory when creating the
linear network.
</p>
<p>If the argument <code>edges</code> is given, then it will also determine
the <em>ordering</em> of the line segments when they are stored or extracted.
For example, <code>edges[i,]</code> corresponds to <code>as.psp(L)[i]</code>.
</p>


<h3>Value</h3>

<p>Object of class <code>"linnet"</code> representing the linear network.
</p>


<h3>Author(s)</h3>

<p>Ang Qi Wei <a href="mailto:aqw07398@hotmail.com">aqw07398@hotmail.com</a> and
Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a> 
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.data.html#topic+simplenet">simplenet</a></code> for an example of a linear network.
</p>
<p><code><a href="#topic+methods.linnet">methods.linnet</a></code> for
methods applicable to <code>linnet</code> objects.
</p>
<p>Special tools: <code><a href="#topic+thinNetwork">thinNetwork</a></code>,
<code><a href="#topic+insertVertices">insertVertices</a></code>,
<code><a href="#topic+joinVertices">joinVertices</a></code>, 
<code><a href="#topic+connected.linnet">connected.linnet</a></code>, <code><a href="#topic+lixellate">lixellate</a></code>.
</p>
<p><code><a href="#topic+delaunayNetwork">delaunayNetwork</a></code> for the Delaunay triangulation
as a network.
</p>
<p><code><a href="spatstat.geom.html#topic+ppp">ppp</a></code>,
<code><a href="spatstat.geom.html#topic+psp">psp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # letter 'A' specified by adjacency matrix
  v &lt;- ppp(x=(-2):2, y=3*c(0,1,2,1,0), c(-3,3), c(-1,7))
  m &lt;- matrix(FALSE, 5,5)
  for(i in 1:4) m[i,i+1] &lt;- TRUE
  m[2,4] &lt;- TRUE
  m &lt;- m | t(m)
  letterA &lt;- linnet(v, m)
  plot(letterA)

  # letter 'A' specified by edge list
  edg &lt;- cbind(1:4, 2:5)
  edg &lt;- rbind(edg, c(2,4))
  letterA &lt;- linnet(v, edges=edg)
</code></pre>

<hr>
<h2 id='lintess'>
Tessellation on a Linear Network
</h2><span id='topic+lintess'></span>

<h3>Description</h3>

<p>Create a tessellation on a linear network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lintess(L, df, marks=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lintess_+3A_l">L</code></td>
<td>

<p>Linear network (object of class <code>"linnet"</code>).
</p>
</td></tr>
<tr><td><code id="lintess_+3A_df">df</code></td>
<td>

<p>Data frame of local coordinates for the pieces that make up the 
tiles of the tessellation. See Details.
</p>
</td></tr>
<tr><td><code id="lintess_+3A_marks">marks</code></td>
<td>

<p>Vector or data frame of 
marks associated with the tiles of the tessellation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tessellation on a linear network <code>L</code> is a partition of the
network into non-overlapping pieces (tiles). Each tile consists of one
or more line segments which are subsets of the line segments making up
the network. A tile can consist of several disjoint pieces.
</p>
<p>The data frame <code>df</code> should have columns named
<code>seg</code>, <code>t0</code>, <code>t1</code> and <code>tile</code>.
Any additional columns will be ignored.
</p>
<p>Each row of the data frame specifies one sub-segment of the network
and allocates it to a particular tile.
</p>
<p>The <code>seg</code> column specifies which line segment of the network
contains the sub-segment. Values of <code>seg</code> are integer indices
for the segments in <code>as.psp(L)</code>.
</p>
<p>The <code>t0</code> and <code>t1</code> columns specify the start and end points
of the sub-segment. They should be numeric values between 0 and 1
inclusive, where the values 0 and 1 representing the network vertices
that are joined by this network segment.
</p>
<p>The <code>tile</code> column specifies which tile of the tessellation
includes this sub-segment. It will be coerced to a factor and its
levels will be the names of the tiles.
</p>
<p>If <code>df</code> is missing or <code>NULL</code>, the result is a tessellation
with only one tile, consisting of the entire network <code>L</code>.
</p>
<p>Additional data called <em>marks</em> may be associated with
each tile of the tessellation. The argument <code>marks</code> should be
a vector with one entry for each tile (that is, one entry for each
level of <code>df$tile</code>) or a data frame with one row for each tile.
In general <code>df</code> and <code>marks</code> will have different numbers of rows.
</p>


<h3>Value</h3>

<p>An object of class <code>"lintess"</code>.
There are methods for <code>print</code>, <code>plot</code> and
<code>summary</code> for this object.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a> and Greg McSwiggan.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linnet">linnet</a></code> for linear networks.
</p>
<p><code><a href="#topic+plot.lintess">plot.lintess</a></code> for plotting.
</p>
<p><code><a href="#topic+divide.linnet">divide.linnet</a></code> to make a tessellation demarcated by
given points.
</p>
<p><code><a href="#topic+chop.linnet">chop.linnet</a></code> to make a tessellation demarcated by
infinite lines.
</p>
<p><code><a href="#topic+lineardirichlet">lineardirichlet</a></code> to create the Dirichlet-Voronoi
tessellation from a point pattern on a linear network.
</p>
<p><code><a href="#topic+as.linfun.lintess">as.linfun.lintess</a></code>, <code><a href="#topic+as.linnet.lintess">as.linnet.lintess</a></code> and
<code><a href="#topic+as.linim">as.linim</a></code> to convert to other classes.
</p>
<p><code><a href="#topic+tile.lengths">tile.lengths</a></code> to compute the length of each tile
in the tessellation.
</p>
<p>The undocumented methods <code>Window.lintess</code> and
<code>as.owin.lintess</code> extract the spatial window.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # tessellation consisting of one tile for each existing segment
   ns &lt;- nsegments(simplenet)
   df &lt;- data.frame(seg=1:ns, t0=0, t1=1, tile=letters[1:ns])
   u &lt;- lintess(simplenet, df)
   u
   plot(u)
   S &lt;- as.psp(simplenet)
   marks(u) &lt;- data.frame(len=lengths_psp(S), ang=angles.psp(S))
   u
   plot(u)
</code></pre>

<hr>
<h2 id='lixellate'>
Subdivide Segments of a Network
</h2><span id='topic+lixellate'></span>

<h3>Description</h3>

<p>Each line segment of a linear network
will be divided into several shorter segments
(line elements or lixels).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lixellate(X, ..., nsplit, eps, sparse = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lixellate_+3A_x">X</code></td>
<td>

<p>A linear network (object of class <code>"linnet"</code>)
or a point pattern on a linear network (object of class <code>"lpp"</code>).
</p>
</td></tr>
<tr><td><code id="lixellate_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="lixellate_+3A_nsplit">nsplit</code></td>
<td>

<p>Number of pieces into which <em>each</em> line segment of <code>X</code>
should be divided. Either a single integer, or an integer vector
with one entry for each line segment in <code>X</code>.
Incompatible with <code>eps</code>.
</p>
</td></tr>
<tr><td><code id="lixellate_+3A_eps">eps</code></td>
<td>

<p>Maximum length of the resulting pieces of line segment.
A single numeric value.
Incompatible with <code>nsplit</code>.
</p>
</td></tr>
<tr><td><code id="lixellate_+3A_sparse">sparse</code></td>
<td>

<p>Optional. Logical value specifying whether the resulting
linear network should be represented using a sparse matrix.
If <code>sparse=NULL</code>, then the representation will be the
same as in <code>X</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each line segment in <code>X</code> will be subdivided into equal pieces.
The result is an object of the same kind as <code>X</code>, representing the
same data as <code>X</code> except that the segments have been subdivided.
</p>
<p>Splitting is controlled by the arguments <code>nsplit</code> and <code>eps</code>,
exactly one of which should be given.
</p>
<p>If <code>nsplit</code> is given, it specifies the 
number of pieces into which <em>each</em> line segment of <code>X</code>
should be divided. It should be either a single integer, or an integer vector
of length equal to the number of line segments in <code>X</code>.
</p>
<p>If <code>eps</code> is given, it specifies the maximum length of
any resulting piece of line segment. 
</p>
<p>It is strongly advisable to use <code>sparse=TRUE</code> (the default)
to limit the computation time.
</p>
<p>If <code>X</code> is a point pattern (class <code>"lpp"</code>) then the
spatial coordinates and marks of each data point are unchanged, but the
local coordinates will change, because they are
adjusted to map them to the new subdivided network.
</p>


<h3>Value</h3>

<p>Object of the same kind as <code>X</code>.
</p>


<h3>Author(s)</h3>

<p>Greg McSwiggan, 
Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linnet">linnet</a></code>, <code><a href="#topic+lpp">lpp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   A &lt;- lixellate(simplenet, nsplit=4)
   plot(A, main="lixellate(simplenet, nsplit=4)")
   points(vertices(A), pch=16)

   spiders
   lixellate(spiders, nsplit=3)
</code></pre>

<hr>
<h2 id='lpp'>
Create Point Pattern on Linear Network
</h2><span id='topic+lpp'></span>

<h3>Description</h3>

<p>Creates an object of class <code>"lpp"</code> that represents
a point pattern on a linear network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lpp(X, L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lpp_+3A_x">X</code></td>
<td>

<p>Locations of the points. A matrix or data frame of coordinates,
or a point pattern object (of class
<code>"ppp"</code>) or other data acceptable to <code><a href="spatstat.geom.html#topic+as.ppp">as.ppp</a></code>.
</p>
</td></tr>
<tr><td><code id="lpp_+3A_l">L</code></td>
<td>

<p>Linear network (object of class <code>"linnet"</code>).
</p>
</td></tr>
<tr><td><code id="lpp_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command creates an object of class <code>"lpp"</code> that represents
a point pattern on a linear network.
</p>
<p>Normally <code>X</code> is a point pattern. The points of <code>X</code> should lie
on the lines of <code>L</code>.
</p>
<p>Alternatively <code>X</code> may be a matrix or data frame containing at
least two columns.
</p>

<ul>
<li><p> Usually
the first two columns of <code>X</code> will be interpreted
as spatial coordinates, and any remaining columns as marks.
</p>
</li>
<li> 
<p>An exception occurs if <code>X</code> is a data frame with columns named
<code>x</code>, <code>y</code>, <code>seg</code> and <code>tp</code>. Then
<code>x</code> and <code>y</code> will be interpreted as spatial
coordinates, and <code>seg</code> and <code>tp</code> as local
coordinates, with <code>seg</code> indicating which line segment of
<code>L</code> the point lies on, and <code>tp</code> indicating how far along
the segment the point lies (normalised to 1). Any remaining columns
will be interpreted as marks.
</p>
</li>
<li> 
<p>Another exception occurs if <code>X</code> is a data frame with columns named
<code>seg</code> and <code>tp</code>. Then
<code>seg</code> and <code>tp</code> will be interpreted as local
coordinates, as above, and the spatial coordinates
<code>x,y</code> will be computed from them.
Any remaining columns will be interpreted as marks.
</p>
</li></ul>

<p>If <code>X</code> is missing or <code>NULL</code>, the result is an empty
point pattern (i.e. containing no points).
</p>


<h3>Value</h3>

<p>An object of class <code>"lpp"</code>. 
Also inherits the class <code>"ppx"</code>.
</p>


<h3>Note on changed format</h3>

<p>The internal format of <code>"lpp"</code> objects was changed in
<span class="pkg">spatstat</span> version <code>1.28-0</code>.
Objects in the old format are still handled correctly,
but computations are faster in the new format.
To convert an object <code>X</code> from the old format to the new format,
use <code>X &lt;- lpp(as.ppp(X), as.linnet(X))</code>.
</p>


<h3>Author(s)</h3>

<p>Ang Qi Wei <a href="mailto:aqw07398@hotmail.com">aqw07398@hotmail.com</a> and
Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a> 
</p>


<h3>See Also</h3>

<p>Installed datasets which are <code>"lpp"</code> objects:
<code><a href="spatstat.data.html#topic+chicago">chicago</a></code>,
<code><a href="spatstat.data.html#topic+dendrite">dendrite</a></code>,
<code><a href="spatstat.data.html#topic+spiders">spiders</a></code>.
</p>
<p>See <code><a href="#topic+as.lpp">as.lpp</a></code> for converting data to an <code>lpp</code> object.
</p>
<p>See <code><a href="#topic+methods.lpp">methods.lpp</a></code> and
<code><a href="spatstat.geom.html#topic+methods.ppx">methods.ppx</a></code> for other methods applicable
to <code>lpp</code> objects.
</p>
<p>Calculations on an <code>lpp</code> object:
<code><a href="#topic+intensity.lpp">intensity.lpp</a></code>,
<code><a href="#topic+distfun.lpp">distfun.lpp</a></code>,
<code><a href="#topic+nndist.lpp">nndist.lpp</a></code>,
<code><a href="#topic+nnwhich.lpp">nnwhich.lpp</a></code>,
<code><a href="#topic+nncross.lpp">nncross.lpp</a></code>,
<code><a href="#topic+nnfun.lpp">nnfun.lpp</a></code>.
</p>
<p>Summary functions: 
<code><a href="#topic+linearK">linearK</a></code>,
<code><a href="#topic+linearKinhom">linearKinhom</a></code>,
<code><a href="#topic+linearpcf">linearpcf</a></code>,
<code><a href="#topic+linearKdot">linearKdot</a></code>,
<code><a href="#topic+linearKcross">linearKcross</a></code>,
<code><a href="#topic+linearmarkconnect">linearmarkconnect</a></code>, etc.
</p>
<p>Random point patterns on a linear network can be generated by
<code><a href="#topic+rpoislpp">rpoislpp</a></code> or <code><a href="#topic+runiflpp">runiflpp</a></code>.
</p>
<p>See <code><a href="#topic+linnet">linnet</a></code> for linear networks.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # letter 'A' 
  v &lt;- ppp(x=(-2):2, y=3*c(0,1,2,1,0), c(-3,3), c(-1,7))
  edg &lt;- cbind(1:4, 2:5)
  edg &lt;- rbind(edg, c(2,4))
  letterA &lt;- linnet(v, edges=edg)

  # points on letter A
  xx &lt;- list(x=c(-1.5,0,0.5,1.5), y=c(1.5,3,4.5,1.5))
  X &lt;- lpp(xx, letterA)

  plot(X)
  X
  summary(X)

  # empty pattern
  lpp(L=letterA)
</code></pre>

<hr>
<h2 id='lppm'>
Fit Point Process Model to Point Pattern on Linear Network
</h2><span id='topic+lppm'></span><span id='topic+lppm.formula'></span><span id='topic+lppm.lpp'></span>

<h3>Description</h3>

<p>Fit a point process model to a point pattern dataset on a linear network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lppm(X, ...)

## S3 method for class 'formula'
lppm(X, interaction=NULL, ..., data=NULL)

## S3 method for class 'lpp'
lppm(X, ..., eps=NULL, nd=1000, random=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lppm_+3A_x">X</code></td>
<td>

<p>Either an object of class <code>"lpp"</code> specifying a point pattern
on a linear network, or a <code>formula</code> specifying the
point process model.
</p>
</td></tr>
<tr><td><code id="lppm_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="spatstat.model.html#topic+ppm">ppm</a></code>.
</p>
</td></tr>
<tr><td><code id="lppm_+3A_interaction">interaction</code></td>
<td>

<p>An object of class <code>"interact"</code>
describing the point process interaction
structure, or <code>NULL</code> indicating that a Poisson process (stationary
or nonstationary) should be fitted.
</p>
</td></tr>
<tr><td><code id="lppm_+3A_data">data</code></td>
<td>

<p>Optional. The values of spatial covariates (other than the Cartesian
coordinates) required by the model.
A list whose entries are images,
functions, windows, tessellations or single numbers. 
</p>
</td></tr>
<tr><td><code id="lppm_+3A_eps">eps</code></td>
<td>

<p>Optional. Spacing between dummy points along each segment of the
network. 
</p>
</td></tr>
<tr><td><code id="lppm_+3A_nd">nd</code></td>
<td>

<p>Optional. Total number of dummy points placed on 
the network. Ignored if <code>eps</code> is given.
</p>
</td></tr>
<tr><td><code id="lppm_+3A_random">random</code></td>
<td>

<p>Logical value indicating whether the grid of dummy points should be
placed at a randomised starting position.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits a point process model to data that specify
a point pattern on a linear network. It is a counterpart of
the model-fitting function <code><a href="spatstat.model.html#topic+ppm">ppm</a></code> designed
to work with objects of class <code>"lpp"</code> instead of <code>"ppp"</code>.
</p>
<p>The function <code>lppm</code> is generic, with methods for
the classes <code>formula</code> and <code>lppp</code>.
</p>
<p>In <code>lppm.lpp</code>
the first argument <code>X</code> should be an object of class <code>"lpp"</code>
(created by the command <code><a href="#topic+lpp">lpp</a></code>) specifying a point pattern
on a linear network.
</p>
<p>In <code>lppm.formula</code>,
the first argument is a <code>formula</code> in the <span class="rlang"><b>R</b></span> language
describing the spatial trend model to be fitted. It has the general form
<code>pattern ~ trend</code> where the left hand side <code>pattern</code> is usually
the name of a point pattern on a linear network
(object of class <code>"lpp"</code>)
to which the model should be fitted, or an expression which evaluates
to such a point pattern;
and the right hand side <code>trend</code> is an expression specifying the
spatial trend of the model.
</p>
<p>Other arguments <code>...</code> are passed from <code>lppm.formula</code>
to <code>lppm.lpp</code> and from <code>lppm.lpp</code> to <code><a href="spatstat.model.html#topic+ppm">ppm</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"lppm"</code> representing the fitted model.
There are methods for <code>print</code>, <code>predict</code>,
<code>coef</code> and similar functions.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Greg McSwiggan.
</p>


<h3>References</h3>

<p>Ang, Q.W. (2010)
<em>Statistical methodology for events on a network</em>.
Master's thesis, School of Mathematics and Statistics, University of
Western Australia.
</p>
<p>Ang, Q.W., Baddeley, A. and Nair, G. (2012)
Geometrically corrected second-order analysis of 
events on a linear network, with applications to
ecology and criminology.
<em>Scandinavian Journal of Statistics</em> <b>39</b>, 591&ndash;617.
</p>
<p>McSwiggan, G., Nair, M.G. and Baddeley, A. (2012)
Fitting Poisson point process models to events 
on a linear network. Manuscript in preparation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+methods.lppm">methods.lppm</a></code>,
<code><a href="#topic+predict.lppm">predict.lppm</a></code>,
<code><a href="spatstat.model.html#topic+ppm">ppm</a></code>,
<code><a href="#topic+lpp">lpp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- runiflpp(15, simplenet)
  lppm(X ~1)
  lppm(X ~x)
  marks(X) &lt;- factor(rep(letters[1:3], 5))
  lppm(X ~ marks)
  lppm(X ~ marks * x)
</code></pre>

<hr>
<h2 id='marks.linnet'>Marks of a Network</h2><span id='topic+marks.linnet'></span><span id='topic+marks+3C-.linnet'></span>

<h3>Description</h3>

<p>Extract or change the marks attached to
vertices or segments of a linear network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'linnet'
marks(x, of=c("segments", "vertices"), ...)           

## S3 replacement method for class 'linnet'
marks(x, of=c("segments", "vertices"), ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marks.linnet_+3A_x">x</code></td>
<td>

<p>Linear network (object of class <code>"linnet"</code>).
</p>
</td></tr>
<tr><td><code id="marks.linnet_+3A_of">of</code></td>
<td>

<p>Character string (partially matched)
specifying whether the marks are attached
to the vertices of the network (<code>of="vertices"</code>)
or to the line segments of the network (<code>of="segments"</code>, the default).
</p>
</td></tr>
<tr><td><code id="marks.linnet_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="marks.linnet_+3A_value">value</code></td>
<td>

<p>Vector or data frame of mark values,
or <code>NULL</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions extract or change the marks
attached to the network <code>x</code>.
They are methods for the generic functions
<code><a href="spatstat.geom.html#topic+marks">marks</a></code> and 
<code><a href="spatstat.geom.html#topic+marks+3C-">marks&lt;-</a></code>
for the class <code>"linnet"</code> of linear networks.
</p>
<p>A linear network may include a set of marks attached to the line segments,
and a separate set of marks attached to the vertices.
Each set of marks can be a vector, a factor, or a data frame.
</p>
<p>The expression <code>marks(x, of)</code> extracts the marks from <code>x</code>.
The assignment <code>marks(x, of) &lt;- value</code> assigns new marks to the
dataset <code>x</code>, and updates the dataset <code>x</code> in the current
environment. 
The argument <code>of</code> specifies whether we are referring to
the segments or the vertices.
</p>
<p>For the assignment <code>marks(x, "segments") &lt;- value</code>, the <code>value</code>
should be a vector or factor of length equal to the number of
segments in <code>x</code>, or a data frame with as many rows
as there are segments in <code>x</code>. 
If <code>value</code> is a single value,
or a data frame with one row, then it will be replicated
so that the same marks will be attached to each segment.
Similarly for <code>marks(x, "vertices") &lt;- value</code> the number of
marks must match the number of vertices.
</p>
<p>To remove marks, use <code>marks(x, of) &lt;- NULL</code>.
</p>
<p>To extract the vertices (including their marks) as a point pattern,
use <code>vertices(x)</code>. To extract the segments (including their
marks) as a line segment pattern, use <code>as.psp(x)</code>.
</p>


<h3>Value</h3>

<p>For <code>marks(x)</code>, the result is a vector, factor or data frame,
containing the mark values attached to the vertices or the
segments of <code>x</code>.
If there are no marks, the result is <code>NULL</code>.
</p>
<p>For <code>marks(x) &lt;- value</code>, the result is the updated network
<code>x</code> (with the side-effect that the dataset <code>x</code> is updated in
the current environment).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linnet">linnet</a></code>,
<code><a href="spatstat.geom.html#topic+marks">marks</a></code>,
<code><a href="spatstat.geom.html#topic+marks+3C-">marks&lt;-</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  L &lt;- simplenet
  marks(L, "vertices") &lt;- letters[1:nvertices(L)]
  marks(L, "segments") &lt;- runif(nsegments(L))
  L
  marks(L, "v")
  marks(L, "s")
</code></pre>

<hr>
<h2 id='marks.lintess'>Marks of a Tessellation on a Network</h2><span id='topic+marks.lintess'></span><span id='topic+marks+3C-.lintess'></span><span id='topic+unmark.lintess'></span>

<h3>Description</h3>

<p>Extract or change the marks attached to
the tiles of a tessellation on a linear network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lintess'
marks(x, ...)           

## S3 replacement method for class 'lintess'
marks(x, ...) &lt;- value

## S3 method for class 'lintess'
unmark(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marks.lintess_+3A_x">x</code>, <code id="marks.lintess_+3A_x">X</code></td>
<td>

<p>Tessellation on a linear network (object of class <code>"lintess"</code>).
</p>
</td></tr>
<tr><td><code id="marks.lintess_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="marks.lintess_+3A_value">value</code></td>
<td>

<p>Vector or data frame of mark values,
or <code>NULL</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions extract or change the marks
attached to each of the tiles in the tessellation <code>x</code>.
They are methods for the generic functions
<code><a href="spatstat.geom.html#topic+marks">marks</a></code>,
<code><a href="spatstat.geom.html#topic+marks+3C-">marks&lt;-</a></code> and <code><a href="spatstat.geom.html#topic+unmark">unmark</a></code>
for the class <code>"lintess"</code> of tessellations on a network.
</p>
<p>The expression <code>marks(x)</code> extracts the marks of <code>x</code>.
The assignment <code>marks(x) &lt;- value</code> assigns new marks to the
dataset <code>x</code>, and updates the dataset <code>x</code> in the current
environment. 
</p>
<p>The marks can be a vector, a factor, or a data frame.
</p>
<p>For the assignment <code>marks(x) &lt;- value</code>, the <code>value</code>
should be a vector or factor of length equal to the number of
tiles in <code>x</code>, or a data frame with as many rows
as there are tiles in <code>x</code>. If <code>value</code> is a single value,
or a data frame with one row, then it will be replicated
so that the same marks will be attached to each tile.
</p>
<p>To remove marks, use <code>marks(x) &lt;- NULL</code> or <code>unmark(x)</code>.
</p>


<h3>Value</h3>

<p>For <code>marks(x)</code>, the result is a vector, factor or data frame,
containing the mark values attached to the tiles of <code>x</code>.
If there are no marks, the result is <code>NULL</code>.
</p>
<p>For <code>unmark(x)</code>, the result is the tessellation without marks.
</p>
<p>For <code>marks(x) &lt;- value</code>, the result is the updated tessellation
<code>x</code> (with the side-effect that the dataset <code>x</code> is updated in
the current environment).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lintess">lintess</a></code>,
<code><a href="spatstat.geom.html#topic+marks">marks</a></code>,
<code><a href="spatstat.geom.html#topic+marks+3C-">marks&lt;-</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  B &lt;- lineardirichlet(runiflpp(5, simplenet))
  marks(B) &lt;- letters[1:5]
</code></pre>

<hr>
<h2 id='Math.linim'>S3 Group Generic Methods for Images on a Linear Network</h2><span id='topic+Math.linim'></span><span id='topic+Ops.linim'></span><span id='topic+Summary.linim'></span><span id='topic+Complex.linim'></span>

<h3>Description</h3>

<p>These are group generic methods for images of class <code>"linim"</code>, which
allows for usual mathematical functions and operators to be applied
directly to pixel images on a linear network.
See Details for a list of implemented functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 methods for group generics have prototypes:
Math(x, ...)
Ops(e1, e2)
Complex(z)
Summary(..., na.rm = FALSE)




</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Math.linim_+3A_x">x</code>, <code id="Math.linim_+3A_z">z</code>, <code id="Math.linim_+3A_e1">e1</code>, <code id="Math.linim_+3A_e2">e2</code></td>
<td>
<p>objects of class <code>"linim"</code>.</p>
</td></tr>
<tr><td><code id="Math.linim_+3A_...">...</code></td>
<td>
<p>further arguments passed to methods.</p>
</td></tr>
<tr><td><code id="Math.linim_+3A_na.rm">na.rm</code></td>
<td>
<p>logical: should missing values be removed?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object of class <code>"linim"</code> represents a pixel image on
a linear network. See <code><a href="#topic+linim">linim</a></code>.
</p>
<p>Below is a list of mathematical functions and operators which are
defined for these images. Not all functions will make sense for all
types of images. For example, none of the functions in the <code>"Math"</code> group
make sense for character-valued images. Note that the <code>"Ops"</code>
group methods are implemented using <code><a href="#topic+eval.linim">eval.linim</a></code>.
</p>

<ol>
<li><p> Group <code>"Math"</code>:
</p>

<ul>
<li>
<p><code>abs</code>, <code>sign</code>, <code>sqrt</code>,<br />
<code>floor</code>, <code>ceiling</code>, <code>trunc</code>,<br />
<code>round</code>, <code>signif</code>
</p>
</li>
<li>
<p><code>exp</code>, <code>log</code>,  <code>expm1</code>, <code>log1p</code>,<br />
<code>cos</code>, <code>sin</code>, <code>tan</code>,<br />
<code>cospi</code>, <code>sinpi</code>, <code>tanpi</code>,<br />
<code>acos</code>, <code>asin</code>, <code>atan</code>
</p>
<p><code>cosh</code>, <code>sinh</code>, <code>tanh</code>,<br />
<code>acosh</code>, <code>asinh</code>, <code>atanh</code>
</p>
</li>
<li>
<p><code>lgamma</code>, <code>gamma</code>, <code>digamma</code>, <code>trigamma</code>
</p>
</li>
<li> <p><code>cumsum</code>, <code>cumprod</code>, <code>cummax</code>, <code>cummin</code>
</p>
</li></ul>

</li>
<li><p> Group <code>"Ops"</code>:
</p>

<ul>
<li>
<p><code>"+"</code>, <code>"-"</code>, <code>"*"</code>, <code>"/"</code>,
<code>"^"</code>, <code>"%%"</code>, <code>"%/%"</code>
</p>
</li>
<li> <p><code>"&amp;"</code>, <code>"|"</code>, <code>"!"</code>
</p>
</li>
<li> <p><code>"=="</code>, <code>"!="</code>,
<code>"&lt;"</code>, <code>"&lt;="</code>, <code>"&gt;="</code>, <code>"&gt;"</code>
</p>
</li></ul>

</li>
<li><p> Group <code>"Summary"</code>:
</p>

<ul>
<li> <p><code>all</code>, <code>any</code>
</p>
</li>
<li> <p><code>sum</code>, <code>prod</code>
</p>
</li>
<li> <p><code>min</code>, <code>max</code>
</p>
</li>
<li> <p><code>range</code>
</p>
</li></ul>

</li>
<li><p> Group <code>"Complex"</code>:
</p>

<ul>
<li> <p><code>Arg</code>, <code>Conj</code>, <code>Im</code>, <code>Mod</code>, <code>Re</code>
</p>
</li></ul>

</li></ol>



<h3>Value</h3>

<p>The return value is another object of class <code>"linim"</code>,
except in the following cases:
<code>all</code> and <code>any</code> return a single
logical value; <code>sum</code>, <code>prod</code>, <code>min</code> and <code>max</code>
return a single numerical value; <code>range</code> returns a vector of two
numerical values.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eval.linim">eval.linim</a></code> for evaluating expressions involving images.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  fx &lt;- function(x,y,seg,tp) { (x - y)^2 }
  fL &lt;- linfun(fx, simplenet)
  Z &lt;- as.linim(fL)
  A &lt;- Z+2
  A &lt;- -Z
  A &lt;- sqrt(Z)
  A &lt;- !(Z &gt; 0.1)
</code></pre>

<hr>
<h2 id='mean.linim'>Mean, Median, Quantiles of Pixel Values on a Linear Network</h2><span id='topic+mean.linim'></span><span id='topic+median.linim'></span><span id='topic+quantile.linim'></span><span id='topic+quantilefun.linim'></span>

<h3>Description</h3>

<p>Calculates the mean, median, or quantiles
of the pixel values in a pixel image on a linear network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'linim'
mean(x, ...)

  ## S3 method for class 'linim'
median(x, ...)

  ## S3 method for class 'linim'
quantile(x, probs=seq(0,1,0.25), ...)

  ## S3 method for class 'linim'
quantilefun(x, ..., type=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean.linim_+3A_x">x</code></td>
<td>

<p>A pixel image on a linear network (object of class
<code>"linim"</code>).
</p>
</td></tr>
<tr><td><code id="mean.linim_+3A_probs">probs</code></td>
<td>

<p>Vector of probabilities for which quantiles should be
calculated.
</p>
</td></tr> 
<tr><td><code id="mean.linim_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods.</p>
</td></tr>
<tr><td><code id="mean.linim_+3A_type">type</code></td>
<td>

<p>Integer specifying the type of quantiles,
as explained in <code><a href="stats.html#topic+quantile.default">quantile.default</a></code>.
Only types 1 and 2 are currently implemented.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions calculate the mean, median and quantiles
of the pixel values in the image
<code>x</code> on a linear network.
</p>
<p>An object of class <code>"linim"</code>
describes a pixel image on a linear network. See <code><a href="#topic+linim">linim</a></code>.
</p>
<p>The functions described here are methods for the 
generic <code><a href="base.html#topic+mean">mean</a></code>, <code><a href="stats.html#topic+median">median</a></code>
and <code><a href="stats.html#topic+quantile">quantile</a></code> for the class <code>"linim"</code>.
</p>


<h3>Value</h3>

<p>For <code>mean</code> and <code>median</code>, a single number.
For <code>quantile</code>, a numeric vector of the same length as <code>probs</code>.
For <code>quantilefun</code>, a function.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+mean">mean</a></code>,
<code><a href="stats.html#topic+median">median</a></code>,
<code><a href="stats.html#topic+quantile">quantile</a></code>,
</p>
<p><code><a href="spatstat.geom.html#topic+mean.im">mean.im</a></code>,
<code><a href="spatstat.geom.html#topic+quantile.im">quantile.im</a></code>,
<code><a href="spatstat.geom.html#topic+quantilefun">quantilefun</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  M &lt;- psp2mask(as.psp(simplenet))
  Z &lt;- as.im(function(x,y) {x-y}, W=M)
  X &lt;- linim(simplenet, Z)
  X
  mean(X)
  median(X)
  quantile(X)
  f &lt;- quantilefun(X)
</code></pre>

<hr>
<h2 id='methods.linfun'>
Methods for Functions on Linear Network
</h2><span id='topic+methods.linfun'></span><span id='topic+print.linfun'></span><span id='topic+summary.linfun'></span><span id='topic+plot.linfun'></span><span id='topic+as.data.frame.linfun'></span><span id='topic+as.owin.linfun'></span><span id='topic+as.function.linfun'></span>

<h3>Description</h3>

<p>Methods for the class <code>"linfun"</code> of functions on a linear network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'linfun'
print(x, ...)

  ## S3 method for class 'linfun'
summary(object, ...)

  ## S3 method for class 'linfun'
plot(x, ..., L=NULL, main) 

  ## S3 method for class 'linfun'
as.data.frame(x, ...)

  ## S3 method for class 'linfun'
as.owin(W, ...)

  ## S3 method for class 'linfun'
as.function(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="methods.linfun_+3A_x">x</code>, <code id="methods.linfun_+3A_object">object</code>, <code id="methods.linfun_+3A_w">W</code></td>
<td>

<p>A function on a linear network
(object of class <code>"linfun"</code>).
</p>
</td></tr>
<tr><td><code id="methods.linfun_+3A_l">L</code></td>
<td>
<p>A linear network</p>
</td></tr>
<tr><td><code id="methods.linfun_+3A_...">...</code></td>
<td>

<p>Extra arguments passed to <code><a href="#topic+as.linim">as.linim</a></code>, 
<code><a href="#topic+plot.linim">plot.linim</a></code>, <code><a href="spatstat.geom.html#topic+plot.im">plot.im</a></code>
or <code><a href="base.html#topic+print.default">print.default</a></code>, or arguments passed to
<code>x</code> if it is a function.
</p>
</td></tr>
<tr><td><code id="methods.linfun_+3A_main">main</code></td>
<td>
<p>Main title for plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are methods for the generic functions
<code><a href="graphics.html#topic+plot">plot</a></code>, <code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+summary">summary</a></code>
<code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> and <code><a href="base.html#topic+as.function">as.function</a></code>,
and for the <span class="pkg">spatstat</span> generic function
<code><a href="spatstat.geom.html#topic+as.owin">as.owin</a></code>.
</p>
<p>An object of class <code>"linfun"</code> represents a
mathematical function that could be evaluated at any location
on a linear network. It is essentially an <span class="rlang"><b>R</b></span> <code>function</code> with some
extra attributes.
</p>
<p>The method <code>as.owin.linfun</code> extracts the two-dimensional spatial
window containing the linear network.
</p>
<p>The method <code>plot.linfun</code> first converts the function to a
pixel image using <code><a href="#topic+as.linim.linfun">as.linim.linfun</a></code>, then plots the image using
<code><a href="#topic+plot.linim">plot.linim</a></code>.
</p>
<p>Note that a <code>linfun</code> function may have additional arguments,
other than those which specify the location on the network
(see <code><a href="#topic+linfun">linfun</a></code>). These additional arguments may be passed
to <code>plot.linfun</code>. 
</p>


<h3>Value</h3>

<p>For <code>print.linfun</code> and <code>summary.linfun</code> the result is <code>NULL</code>.
</p>
<p>For <code>plot.linfun</code> the result is the same as
for <code><a href="#topic+plot.linim">plot.linim</a></code>.
</p>
<p>For the conversion methods, the result is an object of the
required type: <code>as.owin.linfun</code> returns an object of
class <code>"owin"</code>, and so on.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   X &lt;- runiflpp(3, simplenet)
   f &lt;- nnfun(X)
   f
   plot(f)
   as.function(f)
   as.owin(f)
   head(as.data.frame(f))
</code></pre>

<hr>
<h2 id='methods.linim'>
Methods for Images on a Linear Network
</h2><span id='topic+methods.linim'></span><span id='topic+as.im.linim'></span><span id='topic+as.data.frame.linim'></span><span id='topic+print.linim'></span><span id='topic+summary.linim'></span><span id='topic+affine.linim'></span><span id='topic+scalardilate.linim'></span><span id='topic+shift.linim'></span>

<h3>Description</h3>

<p>Methods for the class <code>"linim"</code> of functions on a linear network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'linim'
print(x, ...)

  ## S3 method for class 'linim'
summary(object, ...)

  ## S3 method for class 'linim'
as.im(X, ...)

  ## S3 method for class 'linim'
as.data.frame(x, ...)

  ## S3 method for class 'linim'
shift(X, ...)

  ## S3 method for class 'linim'
scalardilate(X, f, ..., origin=NULL)

  ## S3 method for class 'linim'
affine(X, mat=diag(c(1,1)), vec=c(0,0), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="methods.linim_+3A_x">X</code>, <code id="methods.linim_+3A_x">x</code>, <code id="methods.linim_+3A_object">object</code></td>
<td>

<p>A pixel image on a linear network
(object of class <code>"linim"</code>).
</p>
</td></tr>
<tr><td><code id="methods.linim_+3A_...">...</code></td>
<td>

<p>Extra arguments passed to other methods.
</p>
</td></tr>
<tr><td><code id="methods.linim_+3A_f">f</code></td>
<td>
<p>Numeric. Scalar dilation factor.</p>
</td></tr>
<tr><td><code id="methods.linim_+3A_mat">mat</code></td>
<td>
<p>Numeric matrix representing the linear transformation.</p>
</td></tr>
<tr><td><code id="methods.linim_+3A_vec">vec</code></td>
<td>
<p>Numeric vector of length 2 specifying the shift vector.</p>
</td></tr>
<tr><td><code id="methods.linim_+3A_origin">origin</code></td>
<td>
<p>Character string determining a location
that will be shifted to the origin. Options are
<code>"centroid"</code>, <code>"midpoint"</code> and <code>"bottomleft"</code>.
Partially matched. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are methods for the generic functions
<code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+summary">summary</a></code>
and <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code>,
and the <span class="pkg">spatstat</span> generic functions
<code><a href="spatstat.geom.html#topic+as.im">as.im</a></code>,
<code><a href="spatstat.geom.html#topic+shift">shift</a></code>, 
<code><a href="spatstat.geom.html#topic+scalardilate">scalardilate</a></code> and 
<code><a href="spatstat.geom.html#topic+affine">affine</a></code>.
</p>
<p>An object of class <code>"linfun"</code> represents a
pixel image defined on a linear network. 
</p>
<p>The method <code>as.im.linim</code> extracts the pixel values
and returns a pixel image of class <code>"im"</code>.
</p>
<p>The method <code>as.data.frame.linim</code> returns a data frame
giving spatial locations (in cartesian and network coordinates)
and corresponding function values.
</p>
<p>The methods <code>shift.linim</code>,
<code>scalardilate.linim</code> and <code>affine.linim</code>
apply geometric transformations to the pixels and the underlying
linear network, without changing the pixel values.
</p>


<h3>Value</h3>

<p>For <code>print.linim</code> the result is <code>NULL</code>.
</p>
<p>The function <code>summary.linim</code> returns an object of class
<code>"summary.linim"</code>. In normal usage this summary is
automatically printed by <code><a href="#topic+print.summary.linim">print.summary.linim</a></code>.
</p>
<p>For <code>as.im.linim</code> the result is an object of class <code>"im"</code>.
</p>
<p>For the geometric transformations <code>shift.linim</code>,
<code>scalardilate.linim</code> and <code>affine.linim</code>, the result is
another object of class <code>"linim"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   M &lt;- psp2mask(as.psp(simplenet))
   Z &lt;- as.im(function(x,y) {x-y}, W=M)
   X &lt;- linim(simplenet, Z)
   ## ............  print basic details .........................
   X
   ## ............  print gory details  .........................
   summary(X)
   ## ...........................................................
   shift(X, c(1,1))
   scalardilate(X, 2)
   head(as.data.frame(X))
</code></pre>

<hr>
<h2 id='methods.linnet'>
Methods for Linear Networks
</h2><span id='topic+methods.linnet'></span><span id='topic+as.linnet'></span><span id='topic+as.linnet.linnet'></span><span id='topic+as.owin.linnet'></span><span id='topic+as.psp.linnet'></span><span id='topic+nsegments.linnet'></span><span id='topic+nvertices.linnet'></span><span id='topic+pixellate.linnet'></span><span id='topic+print.linnet'></span><span id='topic+summary.linnet'></span><span id='topic+unitname.linnet'></span><span id='topic+unitname+3C-.linnet'></span><span id='topic+vertexdegree'></span><span id='topic+vertices.linnet'></span><span id='topic+volume.linnet'></span><span id='topic+Window.linnet'></span>

<h3>Description</h3>

<p>These are methods for the class <code>"linnet"</code> of linear networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.linnet(X, ...)

## S3 method for class 'linnet'
as.linnet(X, ..., sparse, maxsize=30000)

## S3 method for class 'linnet'
as.owin(W, ...)

## S3 method for class 'linnet'
as.psp(x, ..., fatal=TRUE)

## S3 method for class 'linnet'
nsegments(x)

## S3 method for class 'linnet'
nvertices(x, ...)

## S3 method for class 'linnet'
pixellate(x, ...)

## S3 method for class 'linnet'
print(x, ...)

## S3 method for class 'linnet'
summary(object, ...)

## S3 method for class 'linnet'
unitname(x)

## S3 replacement method for class 'linnet'
unitname(x) &lt;- value

vertexdegree(x)

## S3 method for class 'linnet'
vertices(w)

## S3 method for class 'linnet'
volume(x)

## S3 method for class 'linnet'
Window(X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="methods.linnet_+3A_x">x</code>, <code id="methods.linnet_+3A_x">X</code>, <code id="methods.linnet_+3A_object">object</code>, <code id="methods.linnet_+3A_w">w</code>, <code id="methods.linnet_+3A_w">W</code></td>
<td>

<p>An object of class <code>"linnet"</code> representing 
a linear network.
</p>
</td></tr>
<tr><td><code id="methods.linnet_+3A_...">...</code></td>
<td>

<p>Arguments passed to other methods.
</p>
</td></tr>
<tr><td><code id="methods.linnet_+3A_value">value</code></td>
<td>

<p>A valid name for the unit of length for <code>x</code>.
See <code><a href="spatstat.geom.html#topic+unitname">unitname</a></code>.
</p>
</td></tr>
<tr><td><code id="methods.linnet_+3A_fatal">fatal</code></td>
<td>

<p>Logical value indicating whether data in the wrong format
should lead to an error (<code>fatal=TRUE</code>) or a warning
(<code>fatal=FALSE</code>).
</p>
</td></tr>
<tr><td><code id="methods.linnet_+3A_sparse">sparse</code></td>
<td>

<p>Logical value indicating whether to use a sparse matrix
representation, as explained in <code><a href="#topic+linnet">linnet</a></code>.
Default is to keep the same representation as in <code>X</code>.
</p>
</td></tr>
<tr><td><code id="methods.linnet_+3A_maxsize">maxsize</code></td>
<td>

<p>Maximum permitted number of network vertices
(to prevent a system crash due to lack of memory)
when creating a network with <code>sparse=FALSE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>as.linnet</code> is generic.
It converts data from some other format
into an object of class <code>"linnet"</code>.
The method <code>as.linnet.lpp</code> extracts the linear network
information from an <code>lpp</code> object.
The method <code>as.linnet.linnet</code> converts a linear network
into another linear network with the required format.
</p>
<p>The other functions are methods for the generic commands
<code><a href="spatstat.geom.html#topic+as.owin">as.owin</a></code>,
<code><a href="spatstat.geom.html#topic+as.psp">as.psp</a></code>,
<code><a href="spatstat.geom.html#topic+nsegments">nsegments</a></code>,
<code><a href="spatstat.geom.html#topic+nvertices">nvertices</a></code>,
<code><a href="spatstat.geom.html#topic+pixellate">pixellate</a></code>,
<code><a href="base.html#topic+print">print</a></code>,
<code><a href="base.html#topic+summary">summary</a></code>,
<code><a href="spatstat.geom.html#topic+unitname">unitname</a></code>,
<code><a href="spatstat.geom.html#topic+unitname+3C-">unitname&lt;-</a></code>,
<code><a href="spatstat.geom.html#topic+vertices">vertices</a></code>,
<code><a href="cluster.html#topic+volume">volume</a></code>
and <code><a href="spatstat.geom.html#topic+Window">Window</a></code>
for the class <code>"linnet"</code>.
</p>
<p>The methods <code>as.owin.linnet</code> and <code>Window.linnet</code>
extract the window containing
the linear network, and return it as an object of class <code>"owin"</code>.
</p>
<p>The method <code>as.psp.linnet</code> extracts the
lines of the linear network as a line segment pattern (object of class
<code>"psp"</code>) while <code>nsegments.linnet</code> simply counts the number
of line segments.
</p>
<p>The method <code>vertices.linnet</code> extracts the vertices (nodes)
of the linear network and <code>nvertices.linnet</code> simply counts the
vertices. The function <code>vertexdegree</code> calculates 
the topological degree of each vertex (the number of lines
emanating from that vertex) and returns these values as an integer
vector.
</p>
<p>The method <code>pixellate.linnet</code> applies <code><a href="#topic+as.psp.linnet">as.psp.linnet</a></code>
to convert the network to a collection of line segments,
then invokes <code><a href="spatstat.geom.html#topic+pixellate.psp">pixellate.psp</a></code>.
</p>


<h3>Value</h3>

<p>For <code>as.linnet</code> the value is an object of class <code>"linnet"</code>.
For other functions, see the help file for the corresponding
generic function.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linnet">linnet</a></code>.
</p>
<p>Generic functions:
<code><a href="spatstat.geom.html#topic+as.owin">as.owin</a></code>,
<code><a href="spatstat.geom.html#topic+as.psp">as.psp</a></code>,
<code><a href="spatstat.geom.html#topic+nsegments">nsegments</a></code>,
<code><a href="spatstat.geom.html#topic+nvertices">nvertices</a></code>,
<code><a href="spatstat.geom.html#topic+pixellate">pixellate</a></code>,
<code><a href="base.html#topic+print">print</a></code>,
<code><a href="base.html#topic+summary">summary</a></code>,
<code><a href="spatstat.geom.html#topic+unitname">unitname</a></code>,
<code><a href="spatstat.geom.html#topic+unitname+3C-">unitname&lt;-</a></code>,
<code><a href="spatstat.geom.html#topic+vertices">vertices</a></code>,
<code><a href="cluster.html#topic+volume">volume</a></code>
and <code><a href="spatstat.geom.html#topic+Window">Window</a></code>.
</p>
<p>Special tools: <code><a href="#topic+thinNetwork">thinNetwork</a></code>,
<code><a href="#topic+insertVertices">insertVertices</a></code>,
<code><a href="#topic+joinVertices">joinVertices</a></code>,
<code><a href="#topic+connected.linnet">connected.linnet</a></code>.
</p>
<p><code><a href="#topic+lixellate">lixellate</a></code> for dividing segments into shorter segments.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  simplenet
  summary(simplenet)
  nsegments(simplenet)
  nvertices(simplenet)
  pixellate(simplenet)
  volume(simplenet)
  unitname(simplenet) &lt;- c("cubit", "cubits")
  Window(simplenet)
</code></pre>

<hr>
<h2 id='methods.lpp'>
Methods for Point Patterns on a Linear Network
</h2><span id='topic+methods.lpp'></span><span id='topic+as.ppp.lpp'></span><span id='topic+as.psp.lpp'></span><span id='topic+marks+3C-.lpp'></span><span id='topic+nsegments.lpp'></span><span id='topic+print.lpp'></span><span id='topic+print.summary.lpp'></span><span id='topic+summary.lpp'></span><span id='topic+unitname.lpp'></span><span id='topic+unitname+3C-.lpp'></span><span id='topic+unmark.lpp'></span>

<h3>Description</h3>

<p>These are methods specifically for the class <code>"lpp"</code> of point patterns on
linear networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpp'
as.ppp(X, ..., fatal=TRUE)

## S3 method for class 'lpp'
as.psp(x, ..., fatal=TRUE)

## S3 replacement method for class 'lpp'
marks(x, ...) &lt;- value

## S3 method for class 'lpp'
nsegments(x)

## S3 method for class 'lpp'
print(x, ...)

## S3 method for class 'summary.lpp'
print(x, ...)

## S3 method for class 'lpp'
summary(object, ...)

## S3 method for class 'lpp'
unitname(x)

## S3 replacement method for class 'lpp'
unitname(x) &lt;- value

## S3 method for class 'lpp'
unmark(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="methods.lpp_+3A_x">x</code>, <code id="methods.lpp_+3A_x">X</code>, <code id="methods.lpp_+3A_object">object</code></td>
<td>

<p>An object of class <code>"lpp"</code> representing a point pattern
on a linear network.
</p>
</td></tr>
<tr><td><code id="methods.lpp_+3A_...">...</code></td>
<td>

<p>Arguments passed to other methods.
</p>
</td></tr>
<tr><td><code id="methods.lpp_+3A_value">value</code></td>
<td>

<p>Replacement value for the <code>marks</code> or <code>unitname</code>
of <code>x</code>. See Details.
</p>
</td></tr>
<tr><td><code id="methods.lpp_+3A_fatal">fatal</code></td>
<td>

<p>Logical value indicating whether data in the wrong format
should lead to an error (<code>fatal=TRUE</code>) or a warning
(<code>fatal=FALSE</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are methods for the generic functions
<code><a href="spatstat.geom.html#topic+as.ppp">as.ppp</a></code>,
<code><a href="spatstat.geom.html#topic+as.psp">as.psp</a></code>,
<code><a href="spatstat.geom.html#topic+marks+3C-">marks&lt;-</a></code>,
<code><a href="spatstat.geom.html#topic+nsegments">nsegments</a></code>,
<code><a href="base.html#topic+print">print</a></code>,
<code><a href="base.html#topic+summary">summary</a></code>,
<code><a href="spatstat.geom.html#topic+unitname">unitname</a></code>, 
<code><a href="spatstat.geom.html#topic+unitname+3C-">unitname&lt;-</a></code> and
<code><a href="spatstat.geom.html#topic+unmark">unmark</a></code>
for objects of the class <code>"lpp"</code>.
</p>
<p>For <code>"marks&lt;-.lpp"</code> the replacement <code>value</code>
should be either <code>NULL</code>, or a vector of length equal
to the number of points in <code>x</code>,
or a data frame with one row for each point in <code>x</code>.
</p>
<p>For <code>"unitname&lt;-.lpp"</code> the replacement <code>value</code>
should be a valid name for the unit of length, as
described in <code><a href="spatstat.geom.html#topic+unitname">unitname</a></code>.
</p>


<h3>Value</h3>

<p>See the documentation on the corresponding generic function.
</p>


<h3>Other methods</h3>

<p>An object of class <code>"lpp"</code> also inherits the class
<code>"ppx"</code> for which many other methods are available.
See <code><a href="spatstat.geom.html#topic+methods.ppx">methods.ppx</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lpp">lpp</a></code>,
<code><a href="#topic+intensity.lpp">intensity.lpp</a></code>,
<code><a href="spatstat.geom.html#topic+methods.ppx">methods.ppx</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- runiflpp(10, simplenet)
  unitname(X) &lt;- c("furlong", "furlongs")
  X
  summary(X)
  summary(chicago)
  nsegments(X)
  Y &lt;- as.ppp(X)
</code></pre>

<hr>
<h2 id='methods.lppm'>
Methods for Fitted Point Process Models on a Linear Network
</h2><span id='topic+methods.lppm'></span><span id='topic+coef.lppm'></span><span id='topic+emend.lppm'></span><span id='topic+extractAIC.lppm'></span><span id='topic+formula.lppm'></span><span id='topic+logLik.lppm'></span><span id='topic+deviance.lppm'></span><span id='topic+nobs.lppm'></span><span id='topic+print.lppm'></span><span id='topic+summary.lppm'></span><span id='topic+terms.lppm'></span><span id='topic+update.lppm'></span><span id='topic+valid.lppm'></span><span id='topic+vcov.lppm'></span><span id='topic+as.linnet.lppm'></span><span id='topic+response.lppm'></span>

<h3>Description</h3>

<p>These are methods for the class <code>"lppm"</code> of fitted point process
models on a linear network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'lppm'
coef(object, ...)

  ## S3 method for class 'lppm'
emend(object, ...)

  ## S3 method for class 'lppm'
extractAIC(fit, ...)

  ## S3 method for class 'lppm'
formula(x, ...)

  ## S3 method for class 'lppm'
logLik(object, ...)

  ## S3 method for class 'lppm'
deviance(object, ...)

  ## S3 method for class 'lppm'
nobs(object, ...)

  ## S3 method for class 'lppm'
print(x, ...)

  ## S3 method for class 'lppm'
summary(object, ...)

  ## S3 method for class 'lppm'
terms(x, ...)

  ## S3 method for class 'lppm'
update(object, ...)

  ## S3 method for class 'lppm'
valid(object, ...)

  ## S3 method for class 'lppm'
vcov(object, ...)

  ## S3 method for class 'lppm'
as.linnet(X, ...)

  ## S3 method for class 'lppm'
response(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="methods.lppm_+3A_object">object</code>, <code id="methods.lppm_+3A_fit">fit</code>, <code id="methods.lppm_+3A_x">x</code>, <code id="methods.lppm_+3A_x">X</code></td>
<td>

<p>An object of class <code>"lppm"</code> representing a fitted point process
model on a linear network.
</p>
</td></tr>
<tr><td><code id="methods.lppm_+3A_...">...</code></td>
<td>

<p>Arguments passed to other methods, usually the
method for the class <code>"ppm"</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are methods for the <span class="rlang"><b>R</b></span> generic commands
<code><a href="stats.html#topic+coef">coef</a></code>,
<code><a href="stats.html#topic+extractAIC">extractAIC</a></code>,
<code><a href="stats.html#topic+formula">formula</a></code>,
<code><a href="stats.html#topic+logLik">logLik</a></code>,
<code><a href="stats.html#topic+deviance">deviance</a></code>,
<code><a href="stats.html#topic+nobs">nobs</a></code>,
<code><a href="base.html#topic+print">print</a></code>, 
<code><a href="base.html#topic+summary">summary</a></code>, 
<code><a href="stats.html#topic+terms">terms</a></code>,
<code><a href="stats.html#topic+update">update</a></code> and
<code><a href="stats.html#topic+vcov">vcov</a></code>,
and the <span class="pkg">spatstat</span> generic commands
<code><a href="#topic+as.linnet">as.linnet</a></code>,
<code><a href="spatstat.model.html#topic+emend">emend</a></code>,
<code><a href="spatstat.model.html#topic+response">response</a></code> and 
<code><a href="spatstat.model.html#topic+valid">valid</a></code>,
for the class <code>"lppm"</code>. 
</p>


<h3>Value</h3>

<p>For <code>as.linnet.lppm</code> a linear network (object of class <code>"linnet"</code>).
For <code>emend.lppm</code> another fitted model of the same class <code>"lppm"</code>.
For <code>response.lppm</code> a spatial point pattern on a linear network
(object of class <code>"lpp"</code>).
For <code>valid.lppm</code> a logical value.
</p>
<p>For the other methods, see the help for the default methods.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lppm">lppm</a></code>,
<code><a href="#topic+plot.lppm">plot.lppm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- runiflpp(15, simplenet)
  fit &lt;- lppm(X ~ x)
  print(fit)
  coef(fit)
  formula(fit)
  terms(fit)
  logLik(fit)
  deviance(fit)
  nobs(fit)
  extractAIC(fit)
  update(fit, ~1)
  valid(fit)
  vcov(fit)
  response(fit)
</code></pre>

<hr>
<h2 id='model.frame.lppm'>
Extract the Variables in a Point Process Model on a Network
</h2><span id='topic+model.frame.lppm'></span>

<h3>Description</h3>

<p>Given a fitted point process model on a network, this function
returns a data frame containing all the variables needed to
fit the model using the Berman-Turner device.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'lppm'
model.frame(formula, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.frame.lppm_+3A_formula">formula</code></td>
<td>

<p>A fitted point process model on a linear network.
An object of class <code>"lppm"</code>.
</p>
</td></tr>
<tr><td><code id="model.frame.lppm_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to <code><a href="stats.html#topic+model.frame.glm">model.frame.glm</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="stats.html#topic+model.frame">model.frame</a></code> is generic.
This function is a method for <code><a href="stats.html#topic+model.frame">model.frame</a></code>
for fitted point process models
on a linear network (objects of class <code>"lppm"</code>).
</p>
<p>The first argument should be a fitted point process model;
it has to be named <code>formula</code> for consistency with the generic
function.
</p>
<p>The result is a data frame containing all the variables used in
fitting the model. The data frame has one row for each quadrature point
used in fitting the model. The quadrature scheme can be extracted using
<code><a href="spatstat.model.html#topic+quad.ppm">quad.ppm</a></code>.  
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> containing all the variables used in the
fitted model, plus additional variables specified in <code>...</code>.
It has an additional attribute <code>"terms"</code> containing information
about the model formula. For details see <code><a href="stats.html#topic+model.frame.glm">model.frame.glm</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Baddeley, A. and Turner, R. (2000)
Practical maximum pseudolikelihood for spatial point patterns.
<em>Australian and New Zealand Journal of Statistics</em>
<b>42</b>, 283&ndash;322.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lppm">lppm</a></code>,
<code><a href="stats.html#topic+model.frame">model.frame</a></code>,
<code><a href="spatstat.model.html#topic+model.matrix.ppm">model.matrix.ppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  fit &lt;- lppm(spiders ~ x)
  mf &lt;- model.frame(fit)
</code></pre>

<hr>
<h2 id='model.images.lppm'>Compute Images of Constructed Covariates</h2><span id='topic+model.images.lppm'></span>

<h3>Description</h3>

<p>For a point process model fitted to spatial point pattern data
on a linear network,
this function computes pixel images of the covariates
in the design matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'lppm'
model.images(object, L = as.linnet(object), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.images.lppm_+3A_object">object</code></td>
<td>

<p>Fitted point process model on a linear network.
An object of class <code>"lppm"</code>.
</p>
</td></tr>
<tr><td><code id="model.images.lppm_+3A_l">L</code></td>
<td>

<p>A linear network (object of class <code>"linnet"</code>) in which the
images should be computed. Defaults to the network
in which the model was fitted.
</p>
</td></tr>
<tr><td><code id="model.images.lppm_+3A_...">...</code></td>
<td>

<p>Other arguments (such as <code>na.action</code>) passed to
<code><a href="stats.html#topic+model.matrix">model.matrix.lm</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command is similar to <code><a href="#topic+model.matrix.lppm">model.matrix.lppm</a></code> except
that it computes pixel images of the covariates,
instead of computing the covariate values at certain points only.
</p>
<p>The <code>object</code> must be a fitted spatial point process model
on a linear network (object of class <code>"lppm"</code>
produced by the model-fitting
function <code><a href="#topic+lppm">lppm</a></code>).
</p>
<p>The spatial covariates required by the model-fitting procedure
are computed at every location on the network <code>L</code>.
</p>
<p>Note that the spatial covariates computed here
are not necessarily the original covariates
that were supplied when fitting the
model. Rather, they are the canonical covariates,
the covariates that appear in the
loglinear representation of the (conditional) intensity
and in the columns of the design matrix. For example, they might include
dummy or indicator variables for different levels of a factor,
depending on the contrasts that are in force.
</p>
<p>The format of the result depends on whether the original point pattern
data were marked or unmarked.
</p>

<ul>
<li>
<p>If the original dataset was unmarked,
the result is a named list of pixel images on the network (objects of class
<code>"linim"</code>) containing the values of the spatial covariates.
The names of the list elements are the names of the covariates
determined by <code><a href="stats.html#topic+model.matrix">model.matrix.lm</a></code>.
The result is also of class <code>"solist"</code> so that it can
be plotted immediately.
</p>
</li>
<li> 
<p>If the original dataset was a multitype point pattern,
the result is a <code><a href="spatstat.geom.html#topic+hyperframe">hyperframe</a></code>
with one column for each possible type of points.
Each column is a named list of pixel images on the network (objects of class
<code>"linim"</code>) containing the values of the spatial covariates.
The row names of the hyperframe are the names of the covariates
determined by <code><a href="stats.html#topic+model.matrix">model.matrix.lm</a></code>.
</p>
</li></ul>

<p>The pixel resolution is determined by the arguments <code>...</code>
and <code><a href="spatstat.geom.html#topic+spatstat.options">spatstat.options</a></code>.
</p>


<h3>Value</h3>

<p>A list (of class <code>"solist"</code>) or
array (of class <code>"hyperframe"</code>) containing
pixel images on the network (objects of class <code>"linim"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.model.html#topic+model.matrix.ppm">model.matrix.ppm</a></code>,
<code><a href="stats.html#topic+model.matrix">model.matrix</a></code>,
<code><a href="#topic+lppm">lppm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   fit &lt;- lppm(spiders ~ x + polynom(y, 2))
   model.images(fit)
</code></pre>

<hr>
<h2 id='model.matrix.lppm'>Extract Design Matrix from Point Process Model on a Network</h2><span id='topic+model.matrix.lppm'></span>

<h3>Description</h3>

<p>Given a point process model that has been
fitted to spatial point pattern data on a linear network,
this function extracts the design matrix of the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   ## S3 method for class 'lppm'
model.matrix(object,
                              data=model.frame(object, na.action=NULL),
                              ..., 
                              keepNA=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.matrix.lppm_+3A_object">object</code></td>
<td>

<p>The fitted point process model. An object of class <code>"lppm"</code>.
</p>
</td></tr>
<tr><td><code id="model.matrix.lppm_+3A_data">data</code></td>
<td>

<p>A model frame, containing the data required for the Berman-Turner device.
</p>
</td></tr>
<tr><td><code id="model.matrix.lppm_+3A_keepna">keepNA</code></td>
<td>

<p>Logical. Determines whether rows containing NA values will be
deleted or retained.
</p>
</td></tr>
<tr><td><code id="model.matrix.lppm_+3A_...">...</code></td>
<td>

<p>Other arguments (such as <code>na.action</code>) passed to
<code><a href="stats.html#topic+model.matrix">model.matrix.lm</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function
<code><a href="stats.html#topic+model.matrix">model.matrix</a></code>.
It extracts the design matrix of a spatial point process model
on a linear network (object of class <code>"lppm"</code>).
</p>
<p>More precisely, this command extracts
the design matrix of the generalised linear model associated with
a spatial point process model. 
</p>
<p>The <code>object</code> must be a fitted point process model
on a network (object of class <code>"lppm"</code>)
produced by the model-fitting function <code><a href="#topic+lppm">lppm</a></code>.
The method <code>model.matrix.lppm</code>
extracts the model matrix for the GLM.
</p>
<p>The result is a matrix, with one row for every quadrature point
in the fitting procedure, and one column for every canonical
covariate in the design matrix.
</p>
<p>If there are <code>NA</code> values in the covariates,
the argument <code>keepNA</code> determines whether to retain or delete
the corresponding rows of the model matrix. The default
<code>keepNA=TRUE</code> is to retain them. Note that this differs from
the default behaviour of many other methods for <code>model.matrix</code>,
which typically delete rows containing <code>NA</code>.
</p>


<h3>Value</h3>

<p>A matrix. Columns of the matrix are canonical covariates in the model.
Rows of the matrix correspond to quadrature points
in the fitting procedure (provided <code>keepNA=TRUE</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+model.matrix">model.matrix</a></code>,
<code><a href="#topic+model.images.lppm">model.images.lppm</a></code>,
<code><a href="#topic+lppm">lppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   fit &lt;- lppm(spiders ~ x + y)
   head(model.matrix(fit))
</code></pre>

<hr>
<h2 id='nncross.lpp'>Nearest Neighbours on a Linear Network</h2><span id='topic+nncross.lpp'></span>

<h3>Description</h3>

<p>Given two point patterns <code>X</code> and <code>Y</code> on a linear network,
finds the nearest neighbour in <code>Y</code> of each point of <code>X</code>
using the shortest path in the network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'lpp'
nncross(X, Y,
          iX=NULL, iY=NULL,
          what = c("dist", "which"),
          ...,
          k = 1,
          method="C")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nncross.lpp_+3A_x">X</code>, <code id="nncross.lpp_+3A_y">Y</code></td>
<td>

<p>Point patterns on a linear network (objects of class <code>"lpp"</code>).
They must lie on the <em>same</em> linear network.
</p>
</td></tr>
<tr><td><code id="nncross.lpp_+3A_ix">iX</code>, <code id="nncross.lpp_+3A_iy">iY</code></td>
<td>

<p>Optional identifiers, used to determine whether a point in
<code>X</code> is identical to a point in <code>Y</code>. See Details.
</p>
</td></tr>
<tr><td><code id="nncross.lpp_+3A_what">what</code></td>
<td>

<p>Character string specifying what information should be returned.
Either the nearest neighbour distance (<code>"dist"</code>),
the identifier of the nearest neighbour (<code>"which"</code>),
or both.
</p>
</td></tr>
<tr><td><code id="nncross.lpp_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="nncross.lpp_+3A_k">k</code></td>
<td>

<p>Integer, or integer vector. The algorithm will compute the distance to the
<code>k</code>th nearest neighbour, for each value of <code>k</code>.
</p>
</td></tr>
<tr><td><code id="nncross.lpp_+3A_method">method</code></td>
<td>

<p>Internal use only.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given two point patterns <code>X</code> and <code>Y</code> on the same linear
network, this function finds, for each point of <code>X</code>, 
the nearest point of <code>Y</code>, measuring distance by the shortest path
in the network. The distance between these points
is also computed.
</p>
<p>The return value is a data frame, with rows corresponding to
the points of <code>X</code>.  The first column gives the nearest neighbour
distances (i.e. the <code>i</code>th entry is the distance 
from the <code>i</code>th point of <code>X</code> to the nearest element of
<code>Y</code>). The second column gives the indices of the nearest
neighbours (i.e.\ the <code>i</code>th entry is the index of
the nearest element in <code>Y</code>.)
If <code>what="dist"</code> then only the vector of distances is returned.
If <code>what="which"</code> then only the vector of indices is returned.
</p>
<p>Note that this function is not symmetric in <code>X</code> and <code>Y</code>.
To find the nearest neighbour in <code>X</code> of each point in <code>Y</code>,
use <code>nncross(Y,X)</code>.
</p>
<p>The arguments <code>iX</code> and <code>iY</code> are used when
the two point patterns <code>X</code> and <code>Y</code> have some points in
common.  In this situation <code>nncross(X, Y)</code> would return some zero
distances. To avoid this, attach a unique integer identifier to
each point, such that two points are identical if their
identifying numbers are equal. Let <code>iX</code> be the vector of
identifier values for the points in <code>X</code>, and <code>iY</code>
the vector of identifiers for points in <code>Y</code>. Then the code
will only compare two points if they have different values of the
identifier. See the Examples.
</p>
<p>The <code>k</code>th nearest neighbour may be undefined, for example
if there are fewer than <code>k+1</code> points in the dataset, or if
the linear network is not connected.
In this case, the <code>k</code>th nearest neighbour distance is infinite.
</p>


<h3>Value</h3>

<p>By default (if <code>what=c("dist", "which")</code> and <code>k=1</code>)
a data frame with two columns:
</p>
<table>
<tr><td><code>dist</code></td>
<td>
<p>Nearest neighbour distance</p>
</td></tr>
<tr><td><code>which</code></td>
<td>
<p>Nearest neighbour index in <code>Y</code></p>
</td></tr>
</table>
<p>If <code>what="dist"</code>, a vector of nearest neighbour distances.
</p>
<p>If <code>what="which"</code>, a vector of nearest neighbour indices.
</p>
<p>If <code>k</code> is a vector of integers, the result is a matrix
with one row for each point in <code>X</code>,
giving the distances and/or indices of the <code>k</code>th nearest
neighbours in <code>Y</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nndist.lpp">nndist.lpp</a></code> for nearest neighbour
distances in a single point pattern.
</p>
<p><code><a href="#topic+nnwhich.lpp">nnwhich.lpp</a></code> to identify which points are nearest
neighbours in a single point pattern.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # two different point patterns
  X &lt;- runiflpp(3, simplenet)
  Y &lt;- runiflpp(5, simplenet)
  nn &lt;- nncross(X,Y)
  nn
  plot(simplenet, main="nncross")
  plot(X, add=TRUE, cols="red")
  plot(Y, add=TRUE, cols="blue", pch=16)
  XX &lt;- as.ppp(X)
  YY &lt;- as.ppp(Y)
  i &lt;- nn$which
  arrows(XX$x, XX$y, YY[i]$x, YY[i]$y, length=0.15)

  # nearest and second-nearest neighbours
  nncross(X, Y, k=1:2)

  # two patterns with some points in common
  X &lt;- Y[1:2]
  iX &lt;- 1:2
  iY &lt;- 1:5
  nncross(X,Y, iX, iY)
</code></pre>

<hr>
<h2 id='nndist.lpp'>
Nearest neighbour distances on a linear network
</h2><span id='topic+nndist.lpp'></span>

<h3>Description</h3>

<p>Given a pattern of points on a linear network, compute the
nearest-neighbour distances, measured
by the shortest path in the network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpp'
nndist(X, ..., k=1, by=NULL, method="C")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nndist.lpp_+3A_x">X</code></td>
<td>

<p>Point pattern on linear network (object of class <code>"lpp"</code>).
</p>
</td></tr>
<tr><td><code id="nndist.lpp_+3A_k">k</code></td>
<td>

<p>Integer, or integer vector. The algorithm will compute the distance to the
<code>k</code>th nearest neighbour. 
</p>
</td></tr>
<tr><td><code id="nndist.lpp_+3A_by">by</code></td>
<td>

<p>Optional. A factor, which separates <code>X</code> into groups.
The algorithm will compute the distance to
the nearest point in each group. 
</p>
</td></tr>
<tr><td><code id="nndist.lpp_+3A_method">method</code></td>
<td>

<p>Optional string determining the method of calculation.
Either <code>"interpreted"</code> or <code>"C"</code>.
</p>
</td></tr>
<tr><td><code id="nndist.lpp_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a pattern of points on a linear network, this function computes the
nearest neighbour distance for each point (i.e. the distance
from each point to the nearest other point), measuring
distance by the shortest path in the network.
</p>
<p>If <code>method="C"</code> the distances are computed using
code in the C language. If <code>method="interpreted"</code> then the
computation is performed using interpreted <span class="rlang"><b>R</b></span> code. The <span class="rlang"><b>R</b></span> code is
much slower, but is provided for checking purposes.
</p>
<p>The <code>k</code>th nearest neighbour distance is infinite
if the <code>k</code>th nearest neighbour does not exist. This can occur
if there are fewer than <code>k+1</code> points in the dataset, or if
the linear network is not connected.
</p>
<p>If the argument <code>by</code> is given, it should be a <code>factor</code>,
of length equal to the number of points in <code>X</code>.
This factor effectively partitions <code>X</code> into subsets,
each subset associated with one of the levels of <code>X</code>.
The algorithm will then compute, for each point of <code>X</code>,
the distance to the nearest neighbour <em>in each subset</em>.
</p>


<h3>Value</h3>

<p>A numeric vector, of length equal to the number of points in <code>X</code>,
or a matrix, with one row for each point in <code>X</code> and one column
for each entry of <code>k</code>. Entries are nonnegative numbers or
infinity (<code>Inf</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lpp">lpp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   X &lt;- runiflpp(12, simplenet)
   nndist(X)
   nndist(X, k=2)

   marks(X) &lt;- factor(rep(letters[1:3], 4))
   nndist(X, by=marks(X))
</code></pre>

<hr>
<h2 id='nnfromvertex'>
Nearest Data Point From Each Vertex in a Network
</h2><span id='topic+nnfromvertex'></span>

<h3>Description</h3>

<p>Given a point pattern on a linear network, 
for each vertex of the network find the nearest data point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nnfromvertex(X, what = c("dist", "which"), k = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nnfromvertex_+3A_x">X</code></td>
<td>

<p>Point pattern on a linear network (object of class <code>"lpp"</code>).
</p>
</td></tr>
<tr><td><code id="nnfromvertex_+3A_what">what</code></td>
<td>

<p>Character string specifying whether to return
the nearest-neighbour distances, nearest-neighbour identifiers,
or both.
</p>
</td></tr>
<tr><td><code id="nnfromvertex_+3A_k">k</code></td>
<td>

<p>Integer, or integer vector, specifying
that the <code>k</code>th nearest neighbour should be returned.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each vertex (node) of the linear network,
this algorithm finds the nearest data point to the vertex,
and returns either the distance from the vertex to its nearest
neighbour in <code>X</code>, or the serial number of the nearest neighbour
in <code>X</code>, or both.
</p>
<p>If <code>k</code> is an integer, then the <code>k</code>-th nearest neighbour
is found instead.
</p>
<p>If <code>k</code> is an integer vector, this is repeated for each
integer in <code>k</code>.
</p>


<h3>Value</h3>

<p>A numeric vector, matrix, or data frame.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nndist.lpp">nndist.lpp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- runiflpp(5, simplenet)
  nnfromvertex(X)
  nnfromvertex(X, k=1:3)
</code></pre>

<hr>
<h2 id='nnfun.lpp'>
Nearest Neighbour Map on Linear Network
</h2><span id='topic+nnfun.lpp'></span>

<h3>Description</h3>

<p>Compute the nearest neighbour function of a point pattern on a linear network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'lpp'
nnfun(X, ..., k=1, value=c("index", "mark"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nnfun.lpp_+3A_x">X</code></td>
<td>

<p>A point pattern on a linear network
(object of class <code>"lpp"</code>).
</p>
</td></tr>
<tr><td><code id="nnfun.lpp_+3A_k">k</code></td>
<td>

<p>Integer. The algorithm finds the <code>k</code>th nearest neighbour in
<code>X</code> from any spatial location.    
</p>
</td></tr>
<tr><td><code id="nnfun.lpp_+3A_value">value</code></td>
<td>

<p>String (partially matched) specifying whether to return the
index of the neighbour (<code>value="index"</code>, the default)
or the mark value of the neighbour (<code>value="mark"</code>).
</p>
</td></tr>
<tr><td><code id="nnfun.lpp_+3A_...">...</code></td>
<td>

<p>Other arguments are ignored. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The (geodesic) <em>nearest neighbour function</em> of a
point pattern <code>X</code> on a linear network <code>L</code>
tells us which point of <code>X</code> is closest to
any given location.
</p>
<p>If <code>X</code> is a point pattern on a linear network <code>L</code>,
the <em>nearest neighbour function</em> of <code>X</code>
is the mathematical function <code class="reqn">f</code> defined for any 
location <code class="reqn">s</code> on the network by <code>f(s) = i</code>, where
<code>X[i]</code> is the closest point of <code>X</code> to the location <code>s</code>
measured by the shortest path. In other words the value of <code>f(s)</code>
is the identifier or serial number of the closest point of <code>X</code>.
</p>
<p>The command <code>nnfun.lpp</code> is a method for the generic command
<code><a href="spatstat.geom.html#topic+nnfun">nnfun</a></code>
for the class <code>"lpp"</code> of point patterns on a linear network.
</p>
<p>If <code>X</code> is a point pattern on a linear network,
<code>f &lt;- nnfun(X)</code> returns a <em>function</em>
in the <span class="rlang"><b>R</b></span> language, with arguments <code>x,y, ...</code>, that represents the
nearest neighbour function of <code>X</code>. Evaluating the function <code>f</code>
in the form <code>v &lt;- f(x,y)</code>, where <code>x</code> and <code>y</code>
are any numeric vectors of equal length containing coordinates of
spatial locations, yields a vector of identifiers or serial numbers of
the data points closest to these spatial locations.
More efficiently <code>f</code> can take the arguments
<code>x, y, seg, tp</code> where <code>seg</code> and <code>tp</code> are the local
coordinates on the network.
</p>
<p>The result of <code>f &lt;- nnfun(X)</code> also belongs to the class
<code>"linfun"</code>.
It can be printed and plotted immediately as shown in the Examples.
It can be converted to a pixel image
using <code><a href="#topic+as.linim">as.linim</a></code>.
</p>


<h3>Value</h3>

<p>A <code>function</code> in the <span class="rlang"><b>R</b></span> language, with arguments <code>x,y</code> and optional
arguments <code>seg,tp</code>.
It also belongs to the class <code>"linfun"</code> which has methods
for <code>plot</code>, <code>print</code> etc.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linfun">linfun</a></code>,
<code><a href="#topic+methods.linfun">methods.linfun</a></code>.
</p>
<p>To compute the <em>distance</em> to the nearest neighbour, see
<code><a href="#topic+distfun.lpp">distfun.lpp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   X &lt;- runiflpp(3, simplenet)
   f &lt;- nnfun(X)
   f
   plot(f)
   plot(nnfun(chicago, value="m"))
</code></pre>

<hr>
<h2 id='nnwhich.lpp'>
Identify Nearest Neighbours on a Linear Network
</h2><span id='topic+nnwhich.lpp'></span>

<h3>Description</h3>

<p>Given a pattern of points on a linear network, identify the
nearest neighbour for each point, measured
by the shortest path in the network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpp'
nnwhich(X, ..., k=1, method="C")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nnwhich.lpp_+3A_x">X</code></td>
<td>

<p>Point pattern on linear network (object of class <code>"lpp"</code>).
</p>
</td></tr>
<tr><td><code id="nnwhich.lpp_+3A_method">method</code></td>
<td>

<p>Optional string determining the method of calculation.
Either <code>"interpreted"</code> or <code>"C"</code>.
</p>
</td></tr>
<tr><td><code id="nnwhich.lpp_+3A_k">k</code></td>
<td>

<p>Integer, or integer vector. The algorithm will find the
<code>k</code>th nearest neighbour. 
</p>
</td></tr>
<tr><td><code id="nnwhich.lpp_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a pattern of points on a linear network,
this function finds the nearest neighbour of each point
(i.e. for each point it identifies the nearest other point)
measuring distance by the shortest path in the network.
</p>
<p>If <code>method="C"</code> the task is performed using
code in the C language. If <code>method="interpreted"</code> then the
computation is performed using interpreted <span class="rlang"><b>R</b></span> code. The <span class="rlang"><b>R</b></span> code is
much slower, but is provided for checking purposes.
</p>
<p>The result is <code>NA</code> if the <code>k</code>th nearest neighbour
does not exist. This can occur
if there are fewer than <code>k+1</code> points in the dataset, or if
the linear network is not connected.
</p>


<h3>Value</h3>

<p>An integer vector, of length equal to the number of points in
<code>X</code>, identifying the nearest neighbour of each point.
If <code>nnwhich(X)[2] = 4</code> then the nearest neighbour of
point 2 is point 4.
</p>
<p>Alternatively a matrix with one row for each point in <code>X</code>
and one column for each entry of <code>k</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lpp">lpp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   X &lt;- runiflpp(10, simplenet)
   nnwhich(X)
   nnwhich(X, k=2)
</code></pre>

<hr>
<h2 id='pairdist.lpp'>
Pairwise shortest-path distances between points on
a linear network
</h2><span id='topic+pairdist.lpp'></span>

<h3>Description</h3>

<p>Given a pattern of points on a linear network, compute the
matrix of distances between all pairs of points, measuring
distance by the shortest path in the network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpp'
pairdist(X, ..., method="C")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairdist.lpp_+3A_x">X</code></td>
<td>

<p>Point pattern on linear network (object of class <code>"lpp"</code>).
</p>
</td></tr>
<tr><td><code id="pairdist.lpp_+3A_method">method</code></td>
<td>

<p>Optional string determining the method of calculation.
Either <code>"interpreted"</code> or <code>"C"</code>.
</p>
</td></tr>
<tr><td><code id="pairdist.lpp_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a pattern of points on a linear network, this function computes the
matrix of distances between all pairs of points, measuring
distance by the shortest path in the network. 
</p>
<p>If two points cannot be joined by a path,
the distance between them is infinite (<code>Inf</code>).
</p>
<p>The argument <code>method</code> is not normally used. It is
retained only for developers to check the validity of the software.
</p>


<h3>Value</h3>

<p>A symmetric matrix, whose values are nonnegative numbers or infinity
(<code>Inf</code>).
</p>


<h3>Algorithms and accuracy</h3>

<p>Distances are accurate within the numerical tolerance of the
network, <code>summary(X)$toler</code>.
</p>
<p>For network data stored in the non-sparse
representation described in <code><a href="#topic+linnet">linnet</a></code>,
then pairwise distances are computed using the matrix of path distances
between vertices of the network, using <span class="rlang"><b>R</b></span> code if
<code>method = "interpreted"</code>, or using C code if 
<code>method="C"</code> (the default).
</p>
<p>For networks stored in the sparse representation,
the argument <code>method</code> has no effect, and the distances are
computed using an efficient C algorithm.
</p>


<h3>Author(s)</h3>

<p>Ang Qi Wei <a href="mailto:aqw07398@hotmail.com">aqw07398@hotmail.com</a> and
Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lpp">lpp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   X &lt;- runiflpp(12, simplenet)
   d &lt;- pairdist(X)
   d[1:3, 1:3]
</code></pre>

<hr>
<h2 id='pairs.linim'>
Scatterplot Matrix for Pixel Images on a Linear Network
</h2><span id='topic+pairs.linim'></span>

<h3>Description</h3>

<p>Produces a scatterplot matrix of the pixel values
in two or more pixel images on a linear network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'linim'
pairs(..., plot=TRUE, eps=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairs.linim_+3A_...">...</code></td>
<td>

<p>Any number of arguments, each of which is either
a pixel image on a linear network (object of class <code>"linim"</code>),
a pixel image (object of class <code>"im"</code>),
or a named argument to be passed to <code><a href="graphics.html#topic+pairs.default">pairs.default</a></code>.
</p>
</td></tr>
<tr><td><code id="pairs.linim_+3A_plot">plot</code></td>
<td>

<p>Logical. If <code>TRUE</code>, the scatterplot matrix is plotted.
</p>
</td></tr>
<tr><td><code id="pairs.linim_+3A_eps">eps</code></td>
<td>

<p>Optional. Spacing between sample points on the network.
A positive number.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function <code><a href="graphics.html#topic+pairs">pairs</a></code>
for the class of pixel images on a linear network.
</p>
<p>It produces a square array of plot panels, in which each panel shows
a scatterplot of the pixel values of one image against the
corresponding pixel values of another image.
</p>
<p>At least two of the arguments <code>...</code> should be a pixel image
on a linear network (object of class <code>"linim"</code>).
They should be defined on the <b>same</b> linear network,
but may have different pixel resolutions.
</p>
<p>First the pixel values of each image are extracted at a
set of sample points equally-spaced across the network.
Then <code><a href="graphics.html#topic+pairs.default">pairs.default</a></code> is called to 
plot the scatterplot matrix.
</p>
<p>Any arguments in <code>...</code> which are not pixel images will be
passed to <code><a href="graphics.html#topic+pairs.default">pairs.default</a></code> to control the plot.
</p>


<h3>Value</h3>

<p>Invisible. A <code>data.frame</code> containing the
corresponding pixel values for each image.
The return value also belongs to the class <code>plotpairsim</code> which has
a plot method, so that it can be re-plotted.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+pairs.default">pairs.default</a></code>,
<code><a href="spatstat.explore.html#topic+pairs.im">pairs.im</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  fit &lt;- lppm(chicago ~ marks * (x+y))
  lam &lt;- predict(fit)
  do.call(pairs, lam)
</code></pre>

<hr>
<h2 id='persp.linfun'>
Perspective View of Function on a Linear Network
</h2><span id='topic+persp.linfun'></span>

<h3>Description</h3>

<p>Given a function on a linear network, generate a
perspective view.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'linfun'
persp(x, ..., main, eps = NULL, dimyx = NULL, xy = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="persp.linfun_+3A_x">x</code></td>
<td>

<p>The function to be plotted. An object of class <code>"linfun"</code>.
</p>
</td></tr>
<tr><td><code id="persp.linfun_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+persp.linim">persp.linim</a></code>
controlling the appearance of the plot.
</p>
</td></tr>
<tr><td><code id="persp.linfun_+3A_main">main</code></td>
<td>

<p>Main title for the plot.
</p>
</td></tr>
<tr><td><code id="persp.linfun_+3A_eps">eps</code>, <code id="persp.linfun_+3A_dimyx">dimyx</code>, <code id="persp.linfun_+3A_xy">xy</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+as.linim">as.linim</a></code> determining the
spatial resolution when the function is converted to an image.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>x</code> is converted to a pixel image on the linear
network using <code><a href="#topic+as.linim">as.linim</a></code>. Then
<code><a href="#topic+persp.linim">persp.linim</a></code> is invoked to generate the perspective plot.
</p>
<p>This style of plot is often attributed to Okabe and Sugihara (2012).
</p>


<h3>Value</h3>

<p>(Invisibly) the perspective transformation matrix,
as described in the help for <code><a href="graphics.html#topic+persp.default">persp.default</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a> and Greg McSwiggan.
</p>


<h3>References</h3>

<p>Okabe, A. and Sugihara, K. (2012)
<em>Spatial Analysis Along Networks</em>. John Wiley and Sons, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+persp.linim">persp.linim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- linfun(function(x,y,seg,tp) { abs(sin(25*x)) + abs(sin(15*y)) }, simplenet)
persp(f, phi=20)
</code></pre>

<hr>
<h2 id='persp.linim'>
Perspective View of Pixel Image on a Linear Network
</h2><span id='topic+persp.linim'></span>

<h3>Description</h3>

<p>Given a pixel image on a linear network, generate a perspective view.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'linim'
persp(x, ..., main,
                       grid = TRUE, ngrid = 10,
                       col.grid = "grey", col.base = "white",
                       neg.args=list(), warncross=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="persp.linim_+3A_x">x</code></td>
<td>

<p>Pixel image on a linear network (object of class <code>"linim"</code>).
</p>
</td></tr>
<tr><td><code id="persp.linim_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="graphics.html#topic+persp.default">persp.default</a></code>
to control the perspective view, or passed to 
<code><a href="graphics.html#topic+segments">segments</a></code> or <code><a href="graphics.html#topic+polygon">polygon</a></code>
to control the appearance of the vertical panes.
</p>
</td></tr>
<tr><td><code id="persp.linim_+3A_main">main</code></td>
<td>

<p>Main title for the plot.
</p>
</td></tr>
<tr><td><code id="persp.linim_+3A_grid">grid</code></td>
<td>

<p>Logical value indicating whether to draw a rectangular grid
at height zero, to assist the perception of perspective.
</p>
</td></tr>
<tr><td><code id="persp.linim_+3A_ngrid">ngrid</code></td>
<td>

<p>Number of grid lines to draw, if <code>grid=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="persp.linim_+3A_col.grid">col.grid</code></td>
<td>

<p>Colour of grid lines, if <code>grid=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="persp.linim_+3A_col.base">col.base</code></td>
<td>

<p>Colour of base plane, if <code>grid=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="persp.linim_+3A_neg.args">neg.args</code></td>
<td>

<p>Optional list of arguments passed to <code><a href="graphics.html#topic+polygon">polygon</a></code>
when displaying negative values of the function.
</p>
</td></tr>
<tr><td><code id="persp.linim_+3A_warncross">warncross</code></td>
<td>

<p>Logical value indicating whether to issue a warning if
two segments of the network cross each other (which causes
difficulty for the algorithm).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The pixel values are interpreted as the spatially-varying height of a
vertical surface erected on each segment of the linear network. These
surfaces are drawn in perspective view.
</p>
<p>This style of plot is often attributed to Okabe and Sugihara (2012).
</p>


<h3>Value</h3>

<p>(Invisibly) the perspective transformation matrix,
as described in the help for <code><a href="graphics.html#topic+persp.default">persp.default</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a> and Greg McSwiggan.
</p>


<h3>References</h3>

<p>Okabe, A. and Sugihara, K. (2012)
<em>Spatial Analysis Along Networks</em>. John Wiley and Sons, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+persp.linfun">persp.linfun</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  if(interactive()) {
    Z &lt;- density(chicago, 100)
  } else {
    X &lt;- runiflpp(10, simplenet)
    Z &lt;- density(X, 0.1)
  }
  persp(Z, theta=30, phi=20)
</code></pre>

<hr>
<h2 id='plot.linim'>
Plot Pixel Image on Linear Network
</h2><span id='topic+plot.linim'></span>

<h3>Description</h3>

<p>Given a pixel image on a linear network,
the pixel values are displayed
either as colours or as line widths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'linim'
plot(x, ..., style = c("colour", "width"),
             scale, adjust = 1, fatten = 0, 
             negative.args = list(col=2),
             legend=TRUE,
             leg.side=c("right", "left", "bottom", "top"),
             leg.sep=0.1,
             leg.wid=0.1,
             leg.args=list(),
             leg.scale=1,
             zlim,
             box=FALSE,
             do.plot=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.linim_+3A_x">x</code></td>
<td>

<p>The pixel image to be plotted. An object of class <code>"linim"</code>.
</p>
</td></tr>
<tr><td><code id="plot.linim_+3A_...">...</code></td>
<td>

<p>Extra graphical parameters, passed to <code><a href="spatstat.geom.html#topic+plot.im">plot.im</a></code>
if <code>style="colour"</code>, or to <code><a href="graphics.html#topic+polygon">polygon</a></code>
if <code>style="width"</code>.
</p>
</td></tr>
<tr><td><code id="plot.linim_+3A_style">style</code></td>
<td>

<p>Character string (partially matched)
specifying the type of plot. See Details.
</p>
</td></tr>
<tr><td><code id="plot.linim_+3A_scale">scale</code></td>
<td>

<p>Physical scale factor for representing the pixel values as
line widths. 
</p>
</td></tr>
<tr><td><code id="plot.linim_+3A_adjust">adjust</code></td>
<td>

<p>Adjustment factor for the conversion of 
pixel value to line width, when <code>style="width"</code>.
</p>
</td></tr>
<tr><td><code id="plot.linim_+3A_fatten">fatten</code></td>
<td>

<p>Distance by which the line segments should be thickened,
when <code>style="colour"</code>. 
</p>
</td></tr>
<tr><td><code id="plot.linim_+3A_negative.args">negative.args</code></td>
<td>

<p>A list of arguments to be passed to <code><a href="graphics.html#topic+polygon">polygon</a></code>
specifying how to plot negative values of <code>x</code>
when <code>style="width"</code>.
</p>
</td></tr>
<tr><td><code id="plot.linim_+3A_legend">legend</code></td>
<td>

<p>Logical value indicating whether to plot a legend
(colour ribbon or scale bar).
</p>
</td></tr>
<tr><td><code id="plot.linim_+3A_leg.side">leg.side</code></td>
<td>

<p>Character string (partially matched) indicating where to display the legend
relative to the main image.
</p>
</td></tr>
<tr><td><code id="plot.linim_+3A_leg.sep">leg.sep</code></td>
<td>

<p>Factor controlling the space between the legend and the image.
</p>
</td></tr>
<tr><td><code id="plot.linim_+3A_leg.wid">leg.wid</code></td>
<td>

<p>Factor controlling the width of the legend.
</p>
</td></tr>
<tr><td><code id="plot.linim_+3A_leg.scale">leg.scale</code></td>
<td>

<p>Rescaling factor for annotations on the legend.
The values on the numerical scale
printed beside the legend will be multiplied by this rescaling factor.
</p>
</td></tr>
<tr><td><code id="plot.linim_+3A_leg.args">leg.args</code></td>
<td>

<p>List of additional arguments passed to
<code><a href="graphics.html#topic+image.default">image.default</a></code>,
<code><a href="graphics.html#topic+axis">axis</a></code>
or <code><a href="graphics.html#topic+text.default">text.default</a></code> 
to control the display of the legend.
These may override the <code>...</code> arguments. 
</p>
</td></tr>
<tr><td><code id="plot.linim_+3A_zlim">zlim</code></td>
<td>

<p>The range of numerical values that should be mapped.
A numeric vector of length 2.
Defaults to the range of values of <code>x</code>.
</p>
</td></tr>
<tr><td><code id="plot.linim_+3A_box">box</code></td>
<td>

<p>Logical value indicating whether to draw a bounding box.
</p>
</td></tr>
<tr><td><code id="plot.linim_+3A_do.plot">do.plot</code></td>
<td>

<p>Logical value indicating whether to actually perform the plot.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the <code>plot</code> method for objects 
of class <code>"linim"</code>. Such an object represents
a pixel image defined on a linear network.
</p>
<p>If <code>style="colour"</code> (the default) then
the pixel values of <code>x</code> are plotted as colours,
using <code><a href="spatstat.geom.html#topic+plot.im">plot.im</a></code>.
The mapping from pixel values to colours is determined by any
additional arguments <code>...</code> which are passed to <code><a href="spatstat.geom.html#topic+plot.im">plot.im</a></code>.
</p>
<p>If <code>style="width"</code> then
the pixel values of <code>x</code> are used to determine the widths of
thick lines centred on the line segments of the linear network.
This style of plot is often attributed to Xie and Yan (2008).
The mapping from pixel values to line widths is determined by
the arguments <code>scale</code> and <code>adjust</code>.
The plotting of colours and borders of the lines is controlled by
the additional arguments <code>...</code> which are passed to
<code><a href="graphics.html#topic+polygon">polygon</a></code>. A different set of colours and borders can be
assigned to negative pixel values by passing a list of arguments in
<code>negative.args</code> as shown in the Examples.
</p>
<p>A legend is displayed alongside the plot
if <code>legend=TRUE</code> (the default). The legend
displays the relationship between pixel values and colours
(if <code>style="colour"</code>) or between pixel values and
line widths (if <code>style="width"</code>).
</p>
<p>The plotting of the legend itself is controlled by the arguments
<code>leg.side</code>, <code>leg.sep</code>, <code>leg.wid</code>, <code>leg.scale</code>
and the list of arguments <code>leg.args</code>, which are described above.
If <code>style="colour"</code>, these arguments are mapped to
the arguments <code>ribside</code>, <code>ribsep</code>, <code>ribwid</code>,
<code>ribscale</code> and <code>ribargs</code> respectively, which are passed
to <code><a href="spatstat.geom.html#topic+plot.im">plot.im</a></code>.
</p>


<h3>Value</h3>

<p>If <code>style="colour"</code>, the result is
an object of class <code>"colourmap"</code> specifying the colour map used.
If <code>style="width"</code>, the result is 
a numeric value <code>v</code> giving the physical scale:
one unit of pixel value is represented as <code>v</code> physical units on the plot.
</p>
<p>The result also has an attribute <code>"bbox"</code> giving a bounding box
for the plot. The bounding box includes the ribbon or scale bar, if present,
but not the main title.
</p>


<h3>Thin lines</h3>

<p>When <code>style="colour"</code> it often appears that the lines are
drawn too thin. This occurs because <code>x</code> is a pixel image,
in which the only pixels that have a defined value are those which lie
directly over the network. To make the lines appear thicker in the
plot, use the argument <code>fatten</code>. The domain of the image will be
expanded by a distance equal to <code>fatten/2</code> in every direction
using <code><a href="spatstat.geom.html#topic+dilation.owin">dilation.owin</a></code>; the pixel values will
be extrapolated to this expanded domain using
<code><a href="spatstat.geom.html#topic+nearestValue">nearestValue</a></code>. This may improve the visual appearance
of the plot.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>References</h3>

<p>Ang, Q.W., Baddeley, A. and Nair, G. (2012)
Geometrically corrected second-order analysis of 
events on a linear network, with applications to
ecology and criminology.
<em>Scandinavian Journal of Statistics</em> <b>39</b>, 591&ndash;617.
</p>
<p>Xie, Z. and Yan, J. (2008) 
Kernel Density Estimation of traffic accidents in a network space.
<em>Computers, Environment and Urban Systems</em> <b>32</b>, 396&ndash;406.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linim">linim</a></code>,
<code><a href="spatstat.geom.html#topic+plot.im">plot.im</a></code>,
<code><a href="graphics.html#topic+polygon">polygon</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- linfun(function(x,y,seg,tp){y^2+x}, simplenet)
  X &lt;- as.linim(X)
  
  plot(X, main="Colour represents function value")
  plot(X, fatten=0.02, main="fattened")

  plot(X, style="width", main="Width proportional to function value")

  # signed values
  f &lt;- linfun(function(x,y,seg,tp){y-x}, simplenet)
  plot(f, style="w", main="Negative values in red")

  plot(f, style="w", negative.args=list(density=10),
       main="Negative values are hatched")

</code></pre>

<hr>
<h2 id='plot.linnet'>
Plot a linear network
</h2><span id='topic+plot.linnet'></span>

<h3>Description</h3>

<p>Plots a linear network
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'linnet'
plot(x, ..., main=NULL, add=FALSE, 
                               do.plot=TRUE,
                               show.vertices=FALSE, show.window=FALSE,
                               args.vertices=list(), args.segments=list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.linnet_+3A_x">x</code></td>
<td>

<p>Linear network (object of class <code>"linnet"</code>).
</p>
</td></tr>
<tr><td><code id="plot.linnet_+3A_...">...</code></td>
<td>

<p>Graphics arguments passed to <code><a href="spatstat.geom.html#topic+plot.psp">plot.psp</a></code>
and <code><a href="spatstat.geom.html#topic+plot.ppp">plot.ppp</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.linnet_+3A_main">main</code></td>
<td>

<p>Main title for plot. Use <code>main=""</code> to suppress it.
</p>
</td></tr>
<tr><td><code id="plot.linnet_+3A_add">add</code></td>
<td>

<p>Logical. If <code>TRUE</code>, superimpose the graphics
over the current plot. If <code>FALSE</code>, generate a new plot.
</p>
</td></tr>
<tr><td><code id="plot.linnet_+3A_do.plot">do.plot</code></td>
<td>

<p>Logical value specifying whether to actually perform the plot.
</p>
</td></tr>
<tr><td><code id="plot.linnet_+3A_show.vertices">show.vertices</code></td>
<td>

<p>Logical value specifying whether to plot the vertices as well.
</p>
</td></tr>
<tr><td><code id="plot.linnet_+3A_show.window">show.window</code></td>
<td>

<p>Logical value specifying whether to plot the window containing the
linear network. 
</p>
</td></tr>
<tr><td><code id="plot.linnet_+3A_args.segments">args.segments</code></td>
<td>

<p>Optional list of arguments passed to <code><a href="spatstat.geom.html#topic+plot.psp">plot.psp</a></code>
when plotting the line segments of the network.
These arguments override any arguments in <code>...</code>.
</p>
</td></tr>
<tr><td><code id="plot.linnet_+3A_args.vertices">args.vertices</code></td>
<td>

<p>Optional list of arguments passed to <code><a href="spatstat.geom.html#topic+plot.ppp">plot.ppp</a></code>
when plotting the vertices of the network (only when <code>vertices=TRUE</code>).
These arguments override any arguments in <code>...</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the plot method for class <code>"linnet"</code>.
</p>
<p>The line segments of the network <code>x</code> are plotted
using <code><a href="spatstat.geom.html#topic+plot.psp">plot.psp</a></code>. 
If <code>show.vertices=TRUE</code>, the vertices of the network will also be
plotted, using <code><a href="spatstat.geom.html#topic+plot.ppp">plot.ppp</a></code>.
If <code>show.window=TRUE</code>, the window surrounding the network will also
be plotted.
</p>
<p>If the vertices or line segments of <code>x</code> are marked,
the marks are not displayed by default. To plot the marks,
set <code>use.marks=TRUE</code>. To plot the marks and plot the associated legends,
set <code>use.marks=TRUE, legend=TRUE</code>. To plot only the marks of the
segments and not the marks of the vertices, set
<code>args.segments=list(use.marks=TRUE)</code> and so on.
</p>


<h3>Value</h3>

<p>An (invisible) list with two elements, <code>segments</code> and
<code>vertices</code> describing the representation of the marks.
The element <code>segments</code> contains
the result of <code><a href="spatstat.geom.html#topic+plot.psp">plot.psp</a></code>
(either a <code>colourmap</code>, a numeric value or an <code>owin</code>).
The element <code>vertices</code> contains the result
of <code><a href="spatstat.geom.html#topic+plot.ppp">plot.ppp</a></code> (a <code>symbolmap</code>)
or <code>NULL</code>.
</p>
<p>The result also has attribute <code>"bbox"</code>
giving the bounding box for the plot.
</p>


<h3>Author(s)</h3>

<p>Ang Qi Wei <a href="mailto:aqw07398@hotmail.com">aqw07398@hotmail.com</a> and
Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a> 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linnet">linnet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   plot(simplenet)

   L &lt;- simplenet
   marks(L, "vertices") &lt;- letters[1:nvertices(L)]
   marks(L, "segments") &lt;- runif(nsegments(L))
   plot(L, show.vertices=TRUE, use.marks=TRUE, legend=TRUE)
</code></pre>

<hr>
<h2 id='plot.lintess'>
Plot a Tessellation on a Linear Network
</h2><span id='topic+plot.lintess'></span>

<h3>Description</h3>

<p>Plot a tessellation or division of a linear network into tiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lintess'
plot(x, ...,
        main, add = FALSE,
        style = c("colour", "width", "image"),
        col = NULL, values=marks(x),
        ribbon=TRUE, ribargs=list(), multiplot=TRUE, do.plot=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.lintess_+3A_x">x</code></td>
<td>

<p>Tessellation on a linear network
(object of class <code>"lintess"</code>).
</p>
</td></tr>
<tr><td><code id="plot.lintess_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="graphics.html#topic+segments">segments</a></code> (if
<code>style="segments"</code>)
or to <code><a href="spatstat.geom.html#topic+plot.im">plot.im</a></code> (if <code>style="image"</code>)
to control the plot.
</p>
</td></tr>
<tr><td><code id="plot.lintess_+3A_main">main</code></td>
<td>

<p>Optional main title for the plot.
</p>
</td></tr>
<tr><td><code id="plot.lintess_+3A_add">add</code></td>
<td>

<p>Logical value indicating whether the plot is to be added to an
existing plot.
</p>
</td></tr>
<tr><td><code id="plot.lintess_+3A_style">style</code></td>
<td>

<p>Character string (partially matched) specifying the type of plot.
If <code>style="colour"</code> (the default), tiles are plotted
using <code><a href="graphics.html#topic+segments">segments</a></code> using colours to distinguish
the different tiles or values. If <code>style="width"</code>,
tiles are plotted using <code><a href="graphics.html#topic+segments">segments</a></code>
using different segment widths to distinguish
the different tiles or values. If <code>style="image"</code>, the
tessellation is converted to a pixel image and plotted by
<code><a href="spatstat.geom.html#topic+plot.im">plot.im</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.lintess_+3A_col">col</code></td>
<td>

<p>Vector of colours, or colour map, determining the colours used
to plot the different tiles of the tessellation.
</p>
</td></tr>
<tr><td><code id="plot.lintess_+3A_values">values</code></td>
<td>

<p>Values associated with each tile of the tessellation,
used to determine the colours or widths.
A vector with one entry for each tile, or a data frame
with one row for each tile.
The default is <code>marks(x)</code>, or if that is null, then
<code>tilenames(x)</code>.
</p>
</td></tr>
<tr><td><code id="plot.lintess_+3A_ribbon">ribbon</code></td>
<td>

<p>Logical value specifying whether to print an explanatory legend
for the colour map or width map.
</p>
</td></tr>
<tr><td><code id="plot.lintess_+3A_ribargs">ribargs</code></td>
<td>

<p>Arguments passed to <code><a href="spatstat.geom.html#topic+plot.colourmap">plot.colourmap</a></code> controlling the
display of the colour map legend.
</p>
</td></tr>
<tr><td><code id="plot.lintess_+3A_multiplot">multiplot</code></td>
<td>

<p>Logical value determining what should happen if <code>marks(x)</code>
has more than one column. If <code>multiplot=TRUE</code> (the default),
several plot panels will be generated, one panel for each column
of marks. If <code>multiplot=FALSE</code>, the first column of marks will
be selected.
</p>
</td></tr>
<tr><td><code id="plot.lintess_+3A_do.plot">do.plot</code></td>
<td>

<p>Logical value specifying whether to actually generate the plot
(<code>do.plot=TRUE</code>, the default) or just to compute the colour map
and return it (<code>do.plot=FALSE</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tessellation on a linear network <code>L</code> is a partition of the
network into non-overlapping pieces (tiles). Each tile consists of one
or more line segments which are subsets of the line segments making up
the network. A tile can consist of several disjoint pieces.
</p>
<p>This function plots the tessellation on the current device.
It is a method for the generic <code>plot</code>.
</p>
<p>If <code>style="colour"</code>, each tile is plotted using
<code><a href="graphics.html#topic+segments">segments</a></code>, drawing segments of different colours. 
</p>
<p>If <code>style="width"</code>, each tile is plotted using
<code><a href="graphics.html#topic+segments">segments</a></code>, drawing segments of different widths.
</p>
<p>If <code>style="image"</code>, the tessellation is converted to a pixel
image, and plotted as a colour image using <code><a href="spatstat.geom.html#topic+plot.im">plot.im</a></code>.
</p>
<p>The colours or widths are determined by the <code>values</code>
associated with each tile of the tessellation. If <code>values</code> is
missing, the default is to use the marks of the tessellation, or if
there are no marks, the names of the tiles.
</p>


<h3>Value</h3>

<p>(Invisible) colour map.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lintess">lintess</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   X &lt;- runiflpp(7, simplenet)
   Z &lt;- divide.linnet(X)
   plot(Z, main="tessellation on network")
   points(as.ppp(X))
   plot(Z, main="tessellation on network",
           values=1:nobjects(Z), style="w")
</code></pre>

<hr>
<h2 id='plot.lpp'>
Plot Point Pattern on Linear Network
</h2><span id='topic+plot.lpp'></span>

<h3>Description</h3>

<p>Plots a point pattern on a linear network.
Plot method for the class <code>"lpp"</code> of point patterns on a linear network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpp'
plot(x, ..., main, add = FALSE,
     type = c("p", "n"),
     use.marks=TRUE, which.marks=NULL,
     legend=TRUE,
     leg.side=c("left", "bottom", "top", "right"),
     leg.args=list(),
     show.all = !add, show.window=FALSE, show.network=TRUE, 
     do.plot = TRUE, multiplot=TRUE) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.lpp_+3A_x">x</code></td>
<td>

<p>Point pattern on a linear network (object of class <code>"lpp"</code>).
</p>
</td></tr>
<tr><td><code id="plot.lpp_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to <code><a href="#topic+plot.linnet">plot.linnet</a></code>
or <code><a href="spatstat.geom.html#topic+plot.ppp">plot.ppp</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.lpp_+3A_main">main</code></td>
<td>

<p>Main title for plot.
</p>
</td></tr>
<tr><td><code id="plot.lpp_+3A_add">add</code></td>
<td>

<p>Logical value indicating whether the plot is to be added to the
existing plot (<code>add=TRUE</code>) or whether a new plot should be
initialised (<code>add=FALSE</code>, the default).
</p>
</td></tr>
<tr><td><code id="plot.lpp_+3A_type">type</code></td>
<td>

<p>Type of plot: either <code>"p"</code> or <code>"n"</code>.
If <code>type="p"</code> (the default), both the points and the observation window
are plotted. If <code>type="n"</code>, only the window is plotted.
</p>
</td></tr>
<tr><td><code id="plot.lpp_+3A_use.marks">use.marks</code></td>
<td>

<p>logical flag; if <code>TRUE</code>, plot points using a different
plotting symbol for each mark;
if <code>FALSE</code>, only the locations of the points will be plotted,
using <code><a href="graphics.html#topic+points">points</a>()</code>.
</p>
</td></tr>
<tr><td><code id="plot.lpp_+3A_which.marks">which.marks</code></td>
<td>

<p>Index determining which column of marks to use,
if the marks of <code>x</code> are a data frame.
A character or integer vector identifying one or more
columns of marks. 
If <code>add=FALSE</code> then
the default is to plot all columns of marks, in a series of separate
plots.
If <code>add=TRUE</code> then only one column of marks can be plotted,
and the default is <code>which.marks=1</code>
indicating the first column of marks.
</p>
</td></tr>
<tr><td><code id="plot.lpp_+3A_legend">legend</code></td>
<td>

<p>Logical value indicating whether to add a legend showing the mapping
between mark values and graphical symbols (for a marked point pattern).
</p>
</td></tr>
<tr><td><code id="plot.lpp_+3A_leg.side">leg.side</code></td>
<td>

<p>Position of legend relative to main plot.
</p>
</td></tr>
<tr><td><code id="plot.lpp_+3A_leg.args">leg.args</code></td>
<td>

<p>List of additional arguments passed to <code><a href="spatstat.geom.html#topic+plot.symbolmap">plot.symbolmap</a></code>
or <code><a href="spatstat.geom.html#topic+symbolmap">symbolmap</a></code> to control the legend.
In addition to arguments documented under
<code><a href="spatstat.geom.html#topic+plot.symbolmap">plot.symbolmap</a></code>, and graphical arguments recognised
by <code><a href="spatstat.geom.html#topic+symbolmap">symbolmap</a></code>, the list may also include the argument
<code>sep</code> giving the separation between the main plot and the
legend, or <code>sep.frac</code> giving the separation as a fraction
of the relevant dimension (width or height) of the main plot.
</p>
</td></tr>
<tr><td><code id="plot.lpp_+3A_show.all">show.all</code></td>
<td>

<p>Logical value indicating whether to plot everything
including the main title and the window containing the network.
</p>
</td></tr>
<tr><td><code id="plot.lpp_+3A_show.window">show.window</code></td>
<td>

<p>Logical value indicating whether to plot the
window containing the network. Overrides <code>show.all</code>.
</p>
</td></tr>
<tr><td><code id="plot.lpp_+3A_show.network">show.network</code></td>
<td>

<p>Logical value indicating whether to plot the network.
</p>
</td></tr>
<tr><td><code id="plot.lpp_+3A_do.plot">do.plot</code></td>
<td>

<p>Logical value determining whether to actually perform the plotting.
</p>
</td></tr>
<tr><td><code id="plot.lpp_+3A_multiplot">multiplot</code></td>
<td>

<p>Logical value giving permission to display multiple plots.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The linear network is plotted by <code><a href="#topic+plot.linnet">plot.linnet</a></code>,
then the points are plotted using code equivalent to <code><a href="spatstat.geom.html#topic+plot.ppp">plot.ppp</a></code>.
</p>
<p>Commonly-used arguments include:
</p>

<ul>
<li> <p><code>col</code> and <code>lwd</code> for the colour and width of lines
in the linear network
</p>
</li>
<li> <p><code>cols</code> for the colour or colours of the points
</p>
</li>
<li> <p><code>chars</code> for the plot characters representing different
types of points
</p>
</li>
<li> <p><code>shape</code> to control the shape of the symbol
(this argument takes precedence over <code>chars</code>).
</p>
</li></ul>

<p>These are documented in the help file for
<code><a href="spatstat.geom.html#topic+plot.ppp">plot.ppp</a></code>.
</p>
<p>If <code>shape="crossticks"</code>, the points are
drawn as short line segments perpendicular to the network.
</p>
<p>Note that the linear network will be plotted
even when <code>add=TRUE</code>, unless <code>show.network=FALSE</code>.
</p>


<h3>Value</h3>

<p>(Invisible) object of class <code>"symbolmap"</code>
giving the correspondence between 
mark values and plotting characters.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lpp">lpp</a></code>.
</p>
<p>See <code><a href="spatstat.geom.html#topic+plot.ppp">plot.ppp</a></code> for options for representing the points.
</p>
<p>See also <code><a href="#topic+points.lpp">points.lpp</a></code>, <code><a href="#topic+text.lpp">text.lpp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  plot(chicago, cols=1:7)
  plot(dendrite, shape="crossticks", cols=2:4, size=8,
                 leg.side="bottom", leg.args=list(lwd=3))
</code></pre>

<hr>
<h2 id='plot.lppm'>
Plot a Fitted Point Process Model on a Linear Network
</h2><span id='topic+plot.lppm'></span>

<h3>Description</h3>

<p>Plots the fitted intensity of a point process model
on a linear network. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'lppm'
plot(x, ..., type="trend")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.lppm_+3A_x">x</code></td>
<td>

<p>An object of class <code>"lppm"</code> representing a fitted point process
model on a linear network.
</p>
</td></tr>
<tr><td><code id="plot.lppm_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+plot.linim">plot.linim</a></code> to control the
plot.
</p>
</td></tr>
<tr><td><code id="plot.lppm_+3A_type">type</code></td>
<td>

<p>Character string (either <code>"trend"</code> or <code>"cif"</code>)
determining whether to plot the fitted first order trend
or the conditional intensity.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is the plot method for the class 
<code>"lppm"</code>. It computes the fitted intensity of the
point process model, and displays it using <code><a href="#topic+plot.linim">plot.linim</a></code>.
</p>
<p>The default is to display intensity values as colours. Alternatively
if the argument <code>style="width"</code> is given, intensity values are
displayed as the widths of thick lines drawn over the network.
</p>


<h3>Value</h3>

<p>Null.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lppm">lppm</a></code>,
<code><a href="#topic+plot.linim">plot.linim</a></code>,
<code><a href="#topic+methods.lppm">methods.lppm</a></code>,
<code><a href="#topic+predict.lppm">predict.lppm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- runiflpp(10, simplenet)  
  fit &lt;- lppm(X ~x)
  plot(fit)
  plot(fit, style="width")
</code></pre>

<hr>
<h2 id='points.lpp'>
Draw Points on Existing Plot
</h2><span id='topic+points.lpp'></span>

<h3>Description</h3>

<p>For a point pattern on a linear network, this function draws the
coordinates of the points only, on the existing plot display.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpp'
points(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="points.lpp_+3A_x">x</code></td>
<td>

<p>A point pattern on a linear network (object of class <code>"lpp"</code>).
</p>
</td></tr>
<tr><td><code id="points.lpp_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to <code><a href="graphics.html#topic+points.default">points.default</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function
<code><a href="graphics.html#topic+points">points</a></code>
for the class <code>"lpp"</code> of point patterns on a linear network.
</p>
<p>If <code>x</code> is a point pattern on a linear network, then
<code>points(x)</code> plots the spatial coordinates of the points only,
on the existing plot display, 
without plotting the underlying network.
It is an error to call this function if a plot has not yet been
initialised.
</p>
<p>The spatial coordinates are extracted and passed to
<code><a href="graphics.html#topic+points.default">points.default</a></code> along with any extra arguments.
Arguments controlling the colours and the plot symbols are interpreted
by <code><a href="graphics.html#topic+points.default">points.default</a></code>. For example, if the
argument <code>col</code> is a vector, then the <code>i</code>th point is drawn
in the colour <code>col[i]</code>.
</p>


<h3>Value</h3>

<p>Null.
</p>


<h3>Difference from plot method</h3>

<p>The more usual way to plot the points is using <code><a href="#topic+plot.lpp">plot.lpp</a></code>.
For example <code>plot(x)</code> would plot both the points and the
underlying network, while <code>plot(x, add=TRUE)</code> would plot only the
points. The interpretation of arguments controlling the colours and
plot symbols is different here: they determine a symbol map, as explained
in the help for <code><a href="spatstat.geom.html#topic+plot.ppp">plot.ppp</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.lpp">plot.lpp</a></code>, <code><a href="graphics.html#topic+points.default">points.default</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> plot(Frame(spiders), main="Spiders on a Brick Wall")
 points(spiders)
</code></pre>

<hr>
<h2 id='predict.lppm'>
Predict Point Process Model on Linear Network
</h2><span id='topic+predict.lppm'></span>

<h3>Description</h3>

<p>Given a fitted point process model on a linear network,
compute the fitted intensity or conditional intensity of the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lppm'
predict(object, ..., type = "trend",
                       locations = NULL, covariates = NULL,
                       se = FALSE,
                       new.coef=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.lppm_+3A_object">object</code></td>
<td>

<p>The fitted model. An object of class <code>"lppm"</code>,
see <code><a href="#topic+lppm">lppm</a></code>.
</p>
</td></tr>
<tr><td><code id="predict.lppm_+3A_type">type</code></td>
<td>

<p>Type of values to be computed. Either <code>"trend"</code> or
<code>"cif"</code>. Currently ignored.
</p>
</td></tr>
<tr><td><code id="predict.lppm_+3A_locations">locations</code></td>
<td>

<p>Optional. Locations at which predictions should be computed.
Either a data frame with two columns of coordinates,
or a binary image mask.
</p>
</td></tr>
<tr><td><code id="predict.lppm_+3A_covariates">covariates</code></td>
<td>

<p>Values of external covariates required by the model.
Either a data frame, or a list of images and/or functions.
</p>
</td></tr>
<tr><td><code id="predict.lppm_+3A_se">se</code></td>
<td>

<p>Logical value indicating whether to calculate standard errors as well.
</p>
</td></tr>
<tr><td><code id="predict.lppm_+3A_new.coef">new.coef</code></td>
<td>

<p>Optional. Numeric vector of model coefficients,
to be used instead of the fitted coefficients
<code>coef(object)</code> when calculating
the prediction.
</p>
</td></tr>
<tr><td><code id="predict.lppm_+3A_...">...</code></td>
<td>

<p>Optional arguments passed to <code><a href="grid.html#topic+as.mask">as.mask</a></code>
to determine the
pixel resolution (if <code>locations</code> is missing).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the fitted point process intensity,
optionally with standard errors,
for a point process model on a linear network. 
It is a method for the generic <code><a href="stats.html#topic+predict">predict</a></code>
for the class <code>"lppm"</code>.
</p>
<p>The argument <code>object</code> should be an object of class <code>"lppm"</code>
(produced by <code><a href="#topic+lppm">lppm</a></code>) representing a point process model
on a linear network.
</p>
<p>Currently the argument <code>type</code> has no effect.
The fitted intensity is computed in all cases.
This occurs because currently all fitted models of class <code>"lppm"</code>
are Poisson point processes, where the trend, intensity, and
conditional intensity are the same.
</p>
<p>Predicted values are computed at the locations given by the
argument <code>locations</code>. If this argument is missing,
then predicted values are computed at a fine grid of points
on the linear network.
</p>

<ul>
<li> 
<p>If <code>locations</code> is missing or <code>NULL</code> (the default),
the return value is a pixel image (object of class <code>"linim"</code>
and <code>"im"</code>) corresponding to a discretisation
of the linear network, with numeric pixel values giving the
predicted values at each location on the linear network.
(If the model is multitype, the result is a list of such pixel
images, one for each possible type of point.)
</p>
</li>
<li>
<p>If <code>locations</code> is a data frame, the result is a 
numeric vector of predicted values at the locations specified by
the data frame.
</p>
</li>
<li>
<p>If <code>locations</code> is a binary mask, the result is a pixel image
with predicted values computed at the pixels of the mask.
(If the model is multitype, the result is a list of such pixel
images, one for each possible type of point.)
</p>
</li></ul>

<p>If <code>se=TRUE</code>, standard errors are also computed.
The result is a list of two elements, each following the format
described above; the first element contains the fitted estimates,
and the second element contains the standard errors.
</p>


<h3>Value</h3>

<p>If <code>se=FALSE</code> (the default), the result is 
a pixel image (object of class <code>"linim"</code> and <code>"im"</code>) or
a list of pixel images,
or a numeric vector, depending on the argument <code>locations</code>.
See Details.
</p>
<p>If <code>se=TRUE</code>, the result is a list of two elements,
each with the format described above.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>


<h3>References</h3>

<p>Ang, Q.W. (2010)
<em>Statistical methodology for events on a network</em>.
Master's thesis, School of Mathematics and Statistics, University of
Western Australia.
</p>
<p>Ang, Q.W., Baddeley, A. and Nair, G. (2012)
Geometrically corrected second-order analysis of 
events on a linear network, with applications to
ecology and criminology.
<em>Scandinavian Journal of Statistics</em> <b>39</b>, 591&ndash;617.
</p>
<p>Rakshit, S., McSwiggan, G., Nair, G. and Baddeley, A. (2021)
Variable selection using penalised likelihoods for
point patterns on a linear network.
<em>Australian and New Zealand Journal of Statistics</em>
<b>63</b>. DOI 10.1111/anzs.12341.
</p>
<p>Baddeley, A., Nair, G., Rakshit, S., McSwiggan, G. and Davies, T.M. (2021)
Analysing point patterns on networks &mdash; a review.
<em>Spatial Statistics</em> <b>42</b>, 100435.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lpp">lpp</a></code>,
<code><a href="#topic+linim">linim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- runiflpp(12, simplenet)
  fit &lt;- lppm(X ~ x)
  v &lt;- predict(fit, type="trend")
  plot(v)
</code></pre>

<hr>
<h2 id='pseudoR2.lppm'>
Calculate Pseudo-R-Squared for Point Process Model on Linear Network
</h2><span id='topic+pseudoR2.lppm'></span>

<h3>Description</h3>

<p>Given a fitted point process model on a linear network, calculate 
the pseudo-R-squared value, which measures the 
fraction of variation in the data that is explained
by the model.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'lppm'
pseudoR2(object, ..., keepoffset=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pseudoR2.lppm_+3A_object">object</code></td>
<td>

<p>Fitted point process model on a linear network.
An object of class <code>"lppm"</code>.
</p>
</td></tr>
<tr><td><code id="pseudoR2.lppm_+3A_keepoffset">keepoffset</code></td>
<td>

<p>Logical value indicating whether to retain offset terms in the model
when computing the deviance difference. See Details.
</p>
</td></tr>
<tr><td><code id="pseudoR2.lppm_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to <code><a href="#topic+deviance.lppm">deviance.lppm</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="spatstat.model.html#topic+pseudoR2">pseudoR2</a></code> is generic, with methods
for fitted point process models
of class <code>"ppm"</code> and <code>"lppm"</code>.
</p>
<p>This function computes McFadden's pseudo-Rsquared
</p>
<p style="text-align: center;"><code class="reqn">
    R^2 = 1 - \frac{D}{D_0}
  </code>
</p>

<p>where <code class="reqn">D</code> is the deviance of the fitted model <code>object</code>,
and <code class="reqn">D_0</code> is the deviance of the null model.
Deviance is defined as twice the negative log-likelihood
or log-pseudolikelihood.
</p>
<p>The null model is usually obtained by re-fitting the model
using the trend formula <code>~1</code>.
However if the original model formula included <code>offset</code> terms,
and if <code>keepoffset=TRUE</code> (the default),
then the null model formula consists of these offset terms. This
ensures that the <code>pseudoR2</code> value is non-negative.
</p>


<h3>Value</h3>

<p>A single numeric value.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.model.html#topic+pseudoR2">pseudoR2</a></code>,
<code><a href="#topic+deviance.lppm">deviance.lppm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- rpoislpp(10, simplenet)
  fit &lt;- lppm(X ~ y)
  pseudoR2(fit)
</code></pre>

<hr>
<h2 id='rcelllpp'>
Simulate Cell Process on Linear Network
</h2><span id='topic+rcelllpp'></span>

<h3>Description</h3>

<p>Generate a realisation of the cell process on a linear network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcelllpp(L, lambda, rnumgen = NULL, ..., saveid=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcelllpp_+3A_l">L</code></td>
<td>

<p>Either a linear network (object of class <code>"linnet"</code>)
or a tessellation on a linear network (object of class <code>"lintess"</code>).
</p>
</td></tr>
<tr><td><code id="rcelllpp_+3A_lambda">lambda</code></td>
<td>

<p>Intensity of the process (expected number of points per unit length),
</p>
</td></tr>
<tr><td><code id="rcelllpp_+3A_rnumgen">rnumgen</code></td>
<td>

<p>Optional. Random number generator for the number of points
in each cell.
</p>
</td></tr>
<tr><td><code id="rcelllpp_+3A_...">...</code></td>
<td>

<p>Additional arguments to <code>rnumgen</code>.
</p>
</td></tr>
<tr><td><code id="rcelllpp_+3A_saveid">saveid</code></td>
<td>

<p>Logical value indicating whether to save information
about cell membership.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates simulated realisations of a
cell point process on a network, as described in Baddeley et al (2017).
This is the analogue on a linear network of the two-dimensional
cell point process of Baddeley and Silverman (1988).
</p>
<p>The argument <code>L</code> should be a tessellation on a linear network.
Alternatively if <code>L</code> is a linear network, it is converted to a
tessellation by treating each network segment as a tile in the tessellation.
</p>
<p>The cell process generates a point process by generating independent
point processes inside each tile of the tessellation. Within each tile,
given the number of random points in the tile, 
the points are independent and uniformly distributed within the tile.
</p>
<p>By default (when <code>rnumgen</code> is not given), the number of points in
a tile of length <code>t</code> is a random variable with
mean and variance equal to <code>lambda * t</code>, generated by calling
<code><a href="spatstat.random.html#topic+rcellnumber">rcellnumber</a></code>.
</p>
<p>If <code>rnumgen</code> is given, it should be a function with
arguments <code>rnumgen(n, mu, ...)</code> where <code>n</code> is the number of
random integers to be generated, <code>mu</code> is the mean value of the
distribution, and <code>...</code> are additional arguments, if needed.
It will be called in the form <code>rnumgen(1, lambda * t, ...)</code>
to determine the number of random points falling in each tile of
length <code>t</code>.
</p>


<h3>Value</h3>

<p>Point pattern on a linear network (object of class <code>"lpp"</code>).
If <code>saveid=TRUE</code>, the result has an attribute <code>"cellid"</code>
which is a factor specifying the cell that contains each point.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Baddeley, A.J. and Silverman, B.W. (1984)
A cautionary example on the use of second-order methods for analyzing
point patterns. <em>Biometrics</em> <b>40</b>, 1089-1094.
</p>
<p>Baddeley, A., Nair, G., Rakshit, S. and McSwiggan, G. (2017)
&lsquo;Stationary&rsquo; point processes are uncommon on
linear networks. <em>STAT</em> <b>6</b>, 68&ndash;78.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rSwitzerlpp">rSwitzerlpp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   X &lt;- rcelllpp(domain(spiders), 0.01)
   plot(X)
   plot(linearK(X))
</code></pre>

<hr>
<h2 id='relrisk.lpp'>
Nonparametric Estimate of Spatially-Varying Relative Risk on a Network
</h2><span id='topic+relrisk.lpp'></span>

<h3>Description</h3>

<p>Given a multitype point pattern on a linear network,
this function estimates the
spatially-varying probability of each type of point, or the ratios of
such probabilities, using kernel smoothing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpp'
relrisk(X, sigma, ..., 
           at = c("pixels", "points"),
           relative=FALSE,
           adjust=1, 
           casecontrol=TRUE, control=1, case,
           finespacing=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relrisk.lpp_+3A_x">X</code></td>
<td>

<p>A multitype point pattern (object of class <code>"lpp"</code>
which has factor valued marks).
</p>
</td></tr>
<tr><td><code id="relrisk.lpp_+3A_sigma">sigma</code></td>
<td>

<p>The numeric value of the smoothing bandwidth
(the standard deviation of Gaussian smoothing kernel)
passed to <code><a href="#topic+density.lpp">density.lpp</a></code>.
Alternatively <code>sigma</code> may be a function which can be used
to select the bandwidth. See Details.
</p>
</td></tr>
<tr><td><code id="relrisk.lpp_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+density.lpp">density.lpp</a></code> to control the
pixel resolution.
</p>
</td></tr>
<tr><td><code id="relrisk.lpp_+3A_at">at</code></td>
<td>

<p>Character string specifying whether to compute the probability values
at a grid of pixel locations (<code>at="pixels"</code>) or
only at the points of <code>X</code> (<code>at="points"</code>).
</p>
</td></tr>
<tr><td><code id="relrisk.lpp_+3A_relative">relative</code></td>
<td>

<p>Logical.
If <code>FALSE</code> (the default) the algorithm
computes the probabilities of each type of point.
If <code>TRUE</code>, it computes the    
<em>relative risk</em>, the ratio of probabilities
of each type relative to the probability of a control.
</p>
</td></tr>
<tr><td><code id="relrisk.lpp_+3A_adjust">adjust</code></td>
<td>

<p>Optional. Adjustment factor for the bandwidth <code>sigma</code>.
</p>
</td></tr>
<tr><td><code id="relrisk.lpp_+3A_casecontrol">casecontrol</code></td>
<td>

<p>Logical. Whether to treat a bivariate point pattern
as consisting of cases and controls, and return only the
probability or relative risk of a case.
Ignored if there are more than 2 types of points.
See Details.
</p>
</td></tr>
<tr><td><code id="relrisk.lpp_+3A_control">control</code></td>
<td>

<p>Integer, or character string, identifying which mark value
corresponds to a control. 
</p>
</td></tr>
<tr><td><code id="relrisk.lpp_+3A_case">case</code></td>
<td>

<p>Integer, or character string, identifying which mark value
corresponds to a case (rather than a control)
in a bivariate point pattern.
This is an alternative to the argument <code>control</code>
in a bivariate point pattern. 
Ignored if there are more than 2 types of points.
</p>
</td></tr>
<tr><td><code id="relrisk.lpp_+3A_finespacing">finespacing</code></td>
<td>

<p>Logical value specifying whether to use a finer spatial
resolution (with longer computation time but higher accuracy).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The command <code><a href="spatstat.explore.html#topic+relrisk">relrisk</a></code> is generic and can be used to
estimate relative risk in different ways.
</p>
<p>This function <code>relrisk.lpp</code> is the method for point patterns
on a linear network (objects of class <code>"lpp"</code>).
It computes <em>nonparametric</em> estimates of relative risk
by kernel smoothing.
</p>
<p>If <code>X</code>  is a bivariate point pattern
(a multitype point pattern consisting of two types of points)
then by default,
the points of the first type (the first level of <code>marks(X)</code>)
are treated as controls or non-events, and points of the second type
are treated as cases or events. Then by default this command computes
the spatially-varying <em>probability</em> of a case,
i.e. the probability <code class="reqn">p(u)</code>
that a point at location <code class="reqn">u</code> on the network
will be a case. If <code>relative=TRUE</code>, it computes the
spatially-varying <em>relative risk</em> of a case relative to a
control, <code class="reqn">r(u) = p(u)/(1- p(u))</code>.
</p>
<p>If <code>X</code> is a multitype point pattern with <code class="reqn">m &gt; 2</code> types,
or if <code>X</code> is a bivariate point pattern
and <code>casecontrol=FALSE</code>,
then by default this command computes, for each type <code class="reqn">j</code>,
a nonparametric estimate of
the spatially-varying <em>probability</em> of an event of type <code class="reqn">j</code>.
This is the probability <code class="reqn">p_j(u)</code>
that a point at location <code class="reqn">u</code> on the network
will belong to type <code class="reqn">j</code>.
If <code>relative=TRUE</code>, the command computes the
<em>relative risk</em> of an event of type <code class="reqn">j</code>
relative to a control,
<code class="reqn">r_j(u) = p_j(u)/p_k(u)</code>,
where events of type <code class="reqn">k</code> are treated as controls.
The argument <code>control</code> determines which type <code class="reqn">k</code>
is treated as a control.
</p>
<p>If <code>at = "pixels"</code> the calculation is performed for
every location <code class="reqn">u</code> on a fine pixel grid over the network, and the result
is a pixel image on the network representing the function <code class="reqn">p(u)</code>,
or a list of pixel images representing the functions 
<code class="reqn">p_j(u)</code> or <code class="reqn">r_j(u)</code>
for <code class="reqn">j = 1,\ldots,m</code>.
An infinite value of relative risk (arising because the
probability of a control is zero) will be returned as <code>NA</code>.
</p>
<p>If <code>at = "points"</code> the calculation is performed
only at the data points <code class="reqn">x_i</code>. By default
the result is a vector of values
<code class="reqn">p(x_i)</code> giving the estimated probability of a case
at each data point, or a matrix of values 
<code class="reqn">p_j(x_i)</code> giving the estimated probability of
each possible type <code class="reqn">j</code> at each data point.
If <code>relative=TRUE</code> then the relative risks
<code class="reqn">r(x_i)</code> or <code class="reqn">r_j(x_i)</code> are
returned.
An infinite value of relative risk (arising because the
probability of a control is zero) will be returned as <code>Inf</code>.
</p>
<p>Estimation is performed by a Nadaraja-Watson type kernel
smoother (McSwiggan et al., 2019).
</p>
<p>The smoothing bandwidth <code>sigma</code>
should be a single numeric value, giving the standard
deviation of the isotropic Gaussian kernel.
If <code>adjust</code> is given, the smoothing bandwidth will be
<code>adjust * sigma</code> before the computation of relative risk.
</p>
<p>Alternatively, <code>sigma</code> may be a function that can be applied
to the point pattern <code>X</code> to select a bandwidth; the function
must return a single numerical value; examples include the
functions <code><a href="#topic+bw.relrisk.lpp">bw.relrisk.lpp</a></code> and <code><a href="spatstat.explore.html#topic+bw.scott.iso">bw.scott.iso</a></code>.
</p>
<p>Accuracy depends on the spatial resolution of the density
computations. If the arguments <code>dx</code> and <code>dt</code> are present,
they are passed to <code><a href="#topic+density.lpp">density.lpp</a></code> to determine the
spatial resolution. Otherwise, the spatial resolution is determined
by a default rule that depends on <code>finespacing</code> and <code>sigma</code>.
If <code>finespacing=FALSE</code> (the default), the spatial resolution is
equal to the default resolution for pixel images.
If <code>finespacing=TRUE</code>, the spatial resolution is much finer
and is determined by a rule which guarantees higher accuracy,
but takes a longer time.
</p>


<h3>Value</h3>

<p>If <code>X</code> consists of only two types of points,
and if <code>casecontrol=TRUE</code>,
the result is a pixel image on the network (if <code>at="pixels"</code>)
or a vector (if <code>at="points"</code>).
The pixel values or vector values
are the probabilities of a case if <code>relative=FALSE</code>,
or the relative risk of a case (probability of a case divided by the
probability of a control) if <code>relative=TRUE</code>.
</p>
<p>If <code>X</code> consists of more than two types of points,
or if <code>casecontrol=FALSE</code>, the result is:
</p>

<ul>
<li><p> (if <code>at="pixels"</code>)
a list of pixel images on the network,
with one image for each possible type of point.
The result also belongs to the class <code>"solist"</code> so that it can
be printed and plotted.
</p>
</li>
<li>
<p>(if <code>at="points"</code>)
a matrix of probabilities, with rows corresponding to
data points <code class="reqn">x_i</code>, and columns corresponding
to types <code class="reqn">j</code>.
</p>
</li></ul>

<p>The pixel values or matrix entries
are the probabilities of each type of point if <code>relative=FALSE</code>,
or the relative risk of each type (probability of each type divided by the
probability of a control) if <code>relative=TRUE</code>.
</p>
<p>If <code>relative=FALSE</code>, the resulting values always lie between 0
and 1. If <code>relative=TRUE</code>, the results are either non-negative
numbers, or the values <code>Inf</code> or <code>NA</code>. 
</p>


<h3>Author(s)</h3>

<p>Greg McSwiggan and Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>McSwiggan, G., Baddeley, A. and Nair, G. (2019)
Estimation of relative risk for events on a linear network.
<em>Statistics and Computing</em> <b>30</b> (2) 469&ndash;484.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.explore.html#topic+relrisk">relrisk</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   ## case-control data: 2 types of points
   set.seed(2020)
   X &lt;- superimpose(A=runiflpp(20, simplenet),
                    B=runifpointOnLines(20, as.psp(simplenet)[5]))
   plot(X)
   plot(relrisk(X, 0.15))
   plot(relrisk(X, 0.15, case="B"))
   head(relrisk(X, 0.15, at="points"))
   ## cross-validated bandwidth selection
   plot(relrisk(X, bw.relrisk.lpp, hmax=0.3, allow.infinite=FALSE))

   ## more than 2 types
   if(interactive()) {
     U &lt;- chicago
     sig &lt;- 170
   } else {
     U &lt;- do.call(superimpose,
                  split(chicago)[c("theft", "cartheft", "burglary")])
     sig &lt;- 40
   }
   plot(relrisk(U, sig))
   head(relrisk(U, sig, at="points"))
   plot(relrisk(U, sig, relative=TRUE, control="theft"))
</code></pre>

<hr>
<h2 id='repairNetwork'>
Repair Internal Data in a Linear Network
</h2><span id='topic+repairNetwork'></span>

<h3>Description</h3>

<p>Detect and repair inconsistencies or duplication in the internal data
of a network object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repairNetwork(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="repairNetwork_+3A_x">X</code></td>
<td>

<p>A linear network (object of class <code>"linnet"</code>)
or a point pattern
on a linear network (object of class <code>"lpp"</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function detects and repairs inconsistencies
in the internal data of <code>X</code>. Currently it does the following:
</p>

<ul>
<li><p> checks that different ways of calculating the number of
edges give the same answer
</p>
</li>
<li><p> removes any duplicated edges of the network
</p>
</li>
<li><p> ensures that each edge is recorded as a pair of vertex indices
<code>(from, to)</code> with <code>from &lt; to</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of the same kind as <code>X</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+thinNetwork">thinNetwork</a></code>
</p>

<hr>
<h2 id='Replace.linim'>Reset Values in Subset of Image on Linear Network</h2><span id='topic++5B+3C-.linim'></span>

<h3>Description</h3>

<p>Reset the values in a subset of a pixel image on a linear network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 replacement method for class 'linim'
x[i, j] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Replace.linim_+3A_x">x</code></td>
<td>

<p>A pixel image on a linear network.
An object of class <code>"linim"</code>.
</p>
</td></tr>
<tr><td><code id="Replace.linim_+3A_i">i</code></td>
<td>

<p>Object defining the subregion or subset to be replaced.
Either a spatial window (an object of class <code>"owin"</code>), or a
pixel image with logical values, or a point pattern (an object
of class <code>"ppp"</code>), or any type of index that applies to a
matrix, or something that can be converted to a point pattern
by <code><a href="spatstat.geom.html#topic+as.ppp">as.ppp</a></code> (using the window of <code>x</code>).
</p>
</td></tr>
<tr><td><code id="Replace.linim_+3A_j">j</code></td>
<td>

<p>An integer or logical vector serving as the column index
if matrix indexing is being used.  Ignored if <code>i</code> is
appropriate to some sort of replacement <em>other than</em>
matrix indexing.
</p>
</td></tr>
<tr><td><code id="Replace.linim_+3A_value">value</code></td>
<td>

<p>Vector, matrix, factor or pixel image
containing the replacement values.
Short vectors will be recycled.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function changes some of the pixel values in a
pixel image. The image <code>x</code> must be an object of class
<code>"linim"</code> representing a pixel image on a linear network.
</p>
<p>The pixel values are replaced according to the rules
described in the help for <code><a href="spatstat.geom.html#topic++5B+3C-.im">[&lt;-.im</a></code>.
Then the auxiliary data are updated.
</p>


<h3>Value</h3>

<p>The image <code>x</code> with the values replaced.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.geom.html#topic++5B+3C-.im">[&lt;-.im</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # make a function
  Y &lt;- as.linim(distfun(runiflpp(5, simplenet)))
  # replace some values
  B &lt;- square(c(0.25, 0.55))
  Y[B] &lt;- 2
  plot(Y, main="")
  plot(B, add=TRUE, lty=3)
  X &lt;- runiflpp(4, simplenet)
  Y[X] &lt;- 5
</code></pre>

<hr>
<h2 id='rhohat.lpp'>
Nonparametric Estimate of Intensity as Function of a Covariate
</h2><span id='topic+rhohat.lpp'></span><span id='topic+rhohat.lppm'></span>

<h3>Description</h3>

<p>Computes a nonparametric estimate of the intensity of a point process
on a linear network, 
as a function of a (continuous) spatial covariate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpp'
rhohat(object, covariate, ...,
       weights=NULL,
       method=c("ratio", "reweight", "transform"),
       horvitz=FALSE,
       smoother=c("kernel", "local", "decreasing", "increasing",
                   "mountain", "valley", "piecewise"),
       subset=NULL,
       do.CI=TRUE, 
       jitter=TRUE, jitterfactor=1, interpolate=TRUE,    
       nd=1000, eps=NULL, random=TRUE, 
       n = 512, bw = "nrd0", adjust=1, from = NULL, to = NULL,
       bwref=bw,
       covname, confidence=0.95, positiveCI, breaks=NULL)

## S3 method for class 'lppm'
rhohat(object, covariate, ...,
       weights=NULL,
       method=c("ratio", "reweight", "transform"),
       horvitz=FALSE,
       smoother=c("kernel", "local", "decreasing", "increasing",
                  "mountain", "valley", "piecewise"),
       subset=NULL, 
       do.CI=TRUE, 
       jitter=TRUE, jitterfactor=1, interpolate=TRUE,    
       nd=1000, eps=NULL, random=TRUE, 
       n = 512, bw = "nrd0", adjust=1, from = NULL, to = NULL,
       bwref=bw,
       covname, confidence=0.95, positiveCI, breaks=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rhohat.lpp_+3A_object">object</code></td>
<td>

<p>A point pattern on a linear network (object of class <code>"lpp"</code>),
or a fitted point process model on a linear network
(object of class <code>"lppm"</code>).
</p>
</td></tr>
<tr><td><code id="rhohat.lpp_+3A_covariate">covariate</code></td>
<td>

<p>Either a <code>function(x,y)</code> or a pixel image (object of
class <code>"im"</code> or <code>"linim"</code>)
providing the values of the covariate at any location.
Alternatively one of the strings <code>"x"</code> or <code>"y"</code>
signifying the Cartesian coordinates.
</p>
</td></tr>
<tr><td><code id="rhohat.lpp_+3A_weights">weights</code></td>
<td>

<p>Optional weights attached to the data points.
Either a numeric vector of weights for each data point,
or a pixel image (object of class <code>"im"</code>) or
a <code>function(x,y)</code> providing the weights.
</p>
</td></tr>
<tr><td><code id="rhohat.lpp_+3A_method">method</code></td>
<td>

<p>Character string determining the estimation method. See Details.
</p>
</td></tr>
<tr><td><code id="rhohat.lpp_+3A_horvitz">horvitz</code></td>
<td>

<p>Logical value indicating whether to use Horvitz-Thompson weights.
See Details.
</p>
</td></tr>
<tr><td><code id="rhohat.lpp_+3A_smoother">smoother</code></td>
<td>

<p>Character string determining the smoothing algorithm
and the type of curve that will be estimated. See Details.
</p>
</td></tr>
<tr><td><code id="rhohat.lpp_+3A_subset">subset</code></td>
<td>

<p>Optional. A spatial window (object of class <code>"owin"</code>)
specifying a subset of the data, from which the estimate should
be calculated.
</p>
</td></tr>
<tr><td><code id="rhohat.lpp_+3A_do.ci">do.CI</code></td>
<td>

<p>Logical value specifying whether to calculate standard errors
and confidence bands.
</p>
</td></tr>
<tr><td><code id="rhohat.lpp_+3A_jitter">jitter</code></td>
<td>

<p>Logical value. If <code>jitter=TRUE</code> (the default),
the values of the covariate at the
data points will be jittered (randomly perturbed by adding a small
amount of noise) using the function <code><a href="base.html#topic+jitter">jitter</a></code>.
If <code>jitter=FALSE</code>, the covariate values at the data points will
not be altered. See the section on <em>Randomisation and discretisation</em>.
</p>
</td></tr>
<tr><td><code id="rhohat.lpp_+3A_jitterfactor">jitterfactor</code></td>
<td>

<p>Numeric value controlling the scale of jittering.
Passed to <code><a href="base.html#topic+jitter">jitter</a></code> as the argument <code>factor</code>.
</p>
</td></tr>
<tr><td><code id="rhohat.lpp_+3A_interpolate">interpolate</code></td>
<td>

<p>Logical value specifying whether to use spatial interpolation
to obtain the values of the covariate at the data points,
when the covariate is a pixel image
(object of class <code>"im"</code> or <code>"linim"</code>).
If <code>interpolate=FALSE</code>, the covariate value for each data point
is simply the value of the covariate image at the pixel centre that
is nearest to the data point. If <code>interpolate=TRUE</code>, the
covariate value for each data point is obtained by interpolating the
nearest pixel values using <code><a href="spatstat.geom.html#topic+interp.im">interp.im</a></code>.
</p>
</td></tr>
<tr><td><code id="rhohat.lpp_+3A_eps">eps</code>, <code id="rhohat.lpp_+3A_nd">nd</code>, <code id="rhohat.lpp_+3A_random">random</code></td>
<td>

<p>Arguments controlling the pixel
resolution at which the covariate will be evaluated.
See Details.
</p>
</td></tr>
<tr><td><code id="rhohat.lpp_+3A_bw">bw</code></td>
<td>

<p>Smoothing bandwidth or bandwidth rule
(passed to <code><a href="stats.html#topic+density.default">density.default</a></code>).
</p>
</td></tr>
<tr><td><code id="rhohat.lpp_+3A_adjust">adjust</code></td>
<td>

<p>Smoothing bandwidth adjustment factor
(passed to <code><a href="stats.html#topic+density.default">density.default</a></code>).
</p>
</td></tr>
<tr><td><code id="rhohat.lpp_+3A_n">n</code>, <code id="rhohat.lpp_+3A_from">from</code>, <code id="rhohat.lpp_+3A_to">to</code></td>
<td>

<p>Arguments passed to <code><a href="stats.html#topic+density.default">density.default</a></code> to
control the number and range of values at which the function
will be estimated.
</p>
</td></tr>
<tr><td><code id="rhohat.lpp_+3A_bwref">bwref</code></td>
<td>

<p>Optional. An alternative value of <code>bw</code> to use when smoothing
the reference density (the density of the covariate values
observed at all locations in the window).
</p>
</td></tr>
<tr><td><code id="rhohat.lpp_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to <code><a href="stats.html#topic+density.default">density.default</a></code>
or <code>locfit::<a href="locfit.html#topic+locfit">locfit</a></code>.
</p>
</td></tr>
<tr><td><code id="rhohat.lpp_+3A_covname">covname</code></td>
<td>

<p>Optional. Character string to use as the name of the covariate.
</p>
</td></tr>
<tr><td><code id="rhohat.lpp_+3A_confidence">confidence</code></td>
<td>

<p>Confidence level for confidence intervals.
A number between 0 and 1.
</p>
</td></tr>
<tr><td><code id="rhohat.lpp_+3A_positiveci">positiveCI</code></td>
<td>

<p>Logical value.
If <code>TRUE</code>, confidence limits are always positive numbers;
if <code>FALSE</code>, the lower limit of the
confidence interval may sometimes be negative.
Default is <code>FALSE</code> if <code>smoother="kernel"</code>
and <code>TRUE</code> if <code>smoother="local"</code>.
See Details.
</p>
</td></tr>
<tr><td><code id="rhohat.lpp_+3A_breaks">breaks</code></td>
<td>

<p>Breakpoints for the piecewise-constant function
computed when <code>smoother='piecewise'</code>.
Either a vector of numeric values specifying the breakpoints,
or a single integer specifying the number of equally-spaced
breakpoints. There is a sensible default.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command estimates the relationship between
point process intensity and a given spatial covariate.
Such a relationship is sometimes called a
<em>resource selection function</em> (if the points are organisms
and the covariate is a descriptor of habitat) or
a <em>prospectivity index</em> (if the points are mineral deposits
and the covariate is a geological variable). 
This command uses nonparametric methods which do not assume a
particular form for the relationship.  
</p>
<p>If <code>object</code> is a point pattern, and <code>baseline</code> is missing or
null, this command assumes that <code>object</code> is a realisation of a
point process with intensity function
<code class="reqn">\lambda(u)</code> of the form
</p>
<p style="text-align: center;"><code class="reqn">\lambda(u) = \rho(Z(u))</code>
</p>

<p>where <code class="reqn">Z</code> is the spatial
covariate function given by <code>covariate</code>, and
<code class="reqn">\rho(z)</code> is the resource selection function
or prospectivity index.
A nonparametric estimator of the function <code class="reqn">\rho(z)</code> is computed.
</p>
<p>If <code>object</code> is a point pattern, and <code>baseline</code> is given,
then the intensity function is assumed to be
</p>
<p style="text-align: center;"><code class="reqn">\lambda(u) = \rho(Z(u)) B(u)</code>
</p>

<p>where <code class="reqn">B(u)</code> is the baseline intensity at location <code class="reqn">u</code>.
A nonparametric estimator of the relative intensity  <code class="reqn">\rho(z)</code>
is computed.
</p>
<p>If <code>object</code> is a fitted point process model, suppose <code>X</code> is
the original data point pattern to which the model was fitted. Then
this command assumes <code>X</code> is a realisation of a Poisson point
process with intensity function of the form
</p>
<p style="text-align: center;"><code class="reqn">
    \lambda(u) = \rho(Z(u)) \kappa(u)
  </code>
</p>

<p>where <code class="reqn">\kappa(u)</code> is the intensity of the fitted model
<code>object</code>. A nonparametric estimator of
the relative intensity <code class="reqn">\rho(z)</code> is computed.
</p>
<p>The nonparametric estimation procedure is controlled by the
arguments <code>smoother</code>, <code>method</code> and <code>horvitz</code>.
</p>
<p>The argument <code>smoother</code> selects the type of estimation technique.
</p>

<ul>
<li>
<p>If <code>smoother="kernel"</code> (the default),
the nonparametric estimator is a <em>kernel smoothing estimator</em>
of <code class="reqn">\rho(z)</code> (Guan, 2008; Baddeley et al, 2012).
The estimated function <code class="reqn">\rho(z)</code> will be
a smooth function of <code class="reqn">z</code> which takes nonnegative values.
If <code>do.CI=TRUE</code> (the default),
confidence bands are also computed, assuming a Poisson point process.
See the section on <em>Smooth estimates</em>.
</p>
</li>
<li>
<p>If <code>smoother="local"</code>, 
the nonparametric estimator is a <em>local regression estimator</em>
of <code class="reqn">\rho(z)</code> (Baddeley et al, 2012) obtained using
local likelihood.
The estimated function <code class="reqn">\rho(z)</code> will be
a smooth function of <code class="reqn">z</code>.
If <code>do.CI=TRUE</code> (the default),
confidence bands are also computed, assuming a Poisson point process.
See the section on <em>Smooth estimates</em>.
</p>
</li>
<li>
<p>If <code>smoother="increasing"</code>, we assume that
<code class="reqn">\rho(z)</code> is an increasing function of <code class="reqn">z</code>,
and use the <em>nonparametric maximum likelihood estimator</em>
of <code class="reqn">\rho(z)</code> described by Sager (1982).
The estimated function will be a step function, that is increasing
as a function of <code class="reqn">z</code>. Confidence bands are not computed.
See the section on <em>Monotone estimates</em>.
</p>
</li>
<li>
<p>If <code>smoother="decreasing"</code>, we assume that
<code class="reqn">\rho(z)</code> is a decreasing function of <code class="reqn">z</code>,
and use the <em>nonparametric maximum likelihood estimator</em>
of <code class="reqn">\rho(z)</code> described by Sager (1982).
The estimated function will be a step function, that is decreasing
as a function of <code class="reqn">z</code>. Confidence bands are not computed.
See the section on <em>Monotone estimates</em>.
</p>
</li>
<li>
<p>If <code>smoother="mountain"</code>, we assume that
<code class="reqn">\rho(z)</code> is a function with an inverted U shape,
with a single peak at a value <code class="reqn">z_0</code>, so that
<code class="reqn">\rho(z)</code> is an increasing function of <code class="reqn">z</code> 
for <code class="reqn">z &lt; z_0</code> and a decreasing function of <code class="reqn">z</code>
for <code class="reqn">z &gt; z_0</code>.
We compute the <em>nonparametric maximum likelihood estimator</em>.
The estimated function will be a step function, which is 
increasing and then decreasing as a function of <code class="reqn">z</code>.
Confidence bands are not computed.
See the section on <em>Unimodal estimates</em>.
</p>
</li>
<li>
<p>If <code>smoother="valley"</code>, we assume that
<code class="reqn">\rho(z)</code> is a function with a U shape,
with a single minimum at a value <code class="reqn">z_0</code>, so that
<code class="reqn">\rho(z)</code> is a decreasing function of <code class="reqn">z</code> 
for <code class="reqn">z &lt; z_0</code> and an increasing function of <code class="reqn">z</code>
for <code class="reqn">z &gt; z_0</code>.
We compute the <em>nonparametric maximum likelihood estimator</em>.
The estimated function will be a step function, which is 
decreasing and then increasing as a function of <code class="reqn">z</code>.
Confidence bands are not computed.
See the section on <em>Unimodal estimates</em>.
</p>
</li>
<li>
<p>If <code>smoother="piecewise"</code>, the estimate of
<code class="reqn">\rho(z)</code> is piecewise constant.
The range of covariate values is divided into several intervals
(ranges or bands). The endpoints of these intervals are the
breakpoints, which may be specified by the argument <code>breaks</code>;
there is a sensible default. The estimate of 
<code class="reqn">\rho(z)</code> takes a constant value on each interval.
The estimate of <code class="reqn">\rho(z)</code> in each interval of covariate
values is simply the average intensity
(number of points per unit length) in the relevant sub-region
of the network.
If <code>do.CI=TRUE</code> (the default),
confidence bands are also computed, assuming a Poisson point process.
</p>
</li></ul>

<p>See Baddeley (2018) for a comparison of these estimation techniques
for two-dimensional point patterns.
</p>
<p>If the argument <code>weights</code> is present, then the contribution
from each data point <code>X[i]</code> to the estimate of <code class="reqn">\rho</code> is
multiplied by <code>weights[i]</code>.
</p>
<p>If the argument <code>subset</code> is present, then the calculations are
performed using only the data inside this spatial region.
</p>
<p>This technique assumes that <code>covariate</code> has continuous values.
It is not applicable to covariates with categorical (factor) values
or discrete values such as small integers.



</p>
<p>The argument <code>covariate</code> should be a pixel image, or a function,
or one of the strings <code>"x"</code> or <code>"y"</code> signifying the
cartesian coordinates. It will be evaluated on a fine grid of locations,
with spatial resolution controlled by the arguments
<code>eps,nd,random</code>. 
The argument <code>nd</code> specifies the
total number of test locations on the linear
network, <code>eps</code> specifies the linear separation between test
locations, 
and <code>random</code> specifies whether the test locations
have a randomised starting position.
</p>


<h3>Value</h3>

<p>A function value table (object of class <code>"fv"</code>)
containing the estimated values of <code class="reqn">\rho</code>
(and confidence limits) for a sequence of values of <code class="reqn">Z</code>.
Also belongs to the class <code>"rhohat"</code>
which has special methods for <code>print</code>, <code>plot</code>
and <code>predict</code>.
</p>


<h3>Smooth estimates</h3>

<p>Smooth estimators of <code class="reqn">\rho(z)</code>
were proposed by Baddeley and Turner (2005) and Baddeley et al (2012).
Similar estimators were proposed by Guan (2008) and in the literature
on relative distributions (Handcock and Morris, 1999).
</p>
<p>The estimated function <code class="reqn">\rho(z)</code> will be a smooth function
of <code class="reqn">z</code>.
</p>
<p>The smooth estimation procedure involves computing several density estimates
and combining them. The algorithm used to compute density estimates is 
determined by <code>smoother</code>:
</p>

<ul>
<li>
<p>If <code>smoother="kernel"</code>,
the smoothing procedure is based on
fixed-bandwidth kernel density estimation,
performed by <code><a href="stats.html#topic+density.default">density.default</a></code>.
</p>
</li>
<li>
<p>If <code>smoother="local"</code>, the smoothing procedure
is based on local likelihood density estimation, performed by
<code>locfit::<a href="locfit.html#topic+locfit">locfit</a></code>.
</p>
</li></ul>

<p>The argument <code>method</code> determines how the density estimates will be
combined to obtain an estimate of <code class="reqn">\rho(z)</code>:
</p>

<ul>
<li>
<p>If <code>method="ratio"</code>, then <code class="reqn">\rho(z)</code> is
estimated by the ratio of two density estimates,
The numerator is a (rescaled) density estimate obtained by
smoothing the values <code class="reqn">Z(y_i)</code> of the covariate
<code class="reqn">Z</code> observed at the data points <code class="reqn">y_i</code>. The denominator
is a density estimate of the reference distribution of <code class="reqn">Z</code>.
See Baddeley et al (2012), equation (8). This is similar but not
identical to an estimator proposed by Guan (2008).
</p>
</li>
<li>
<p>If <code>method="reweight"</code>, then <code class="reqn">\rho(z)</code> is
estimated by applying density estimation to the 
values <code class="reqn">Z(y_i)</code> of the covariate
<code class="reqn">Z</code> observed at the data points <code class="reqn">y_i</code>,
with weights inversely proportional to the reference density of
<code class="reqn">Z</code>.
See Baddeley et al (2012), equation (9).
</p>
</li>
<li> 
<p>If <code>method="transform"</code>,
the smoothing method is variable-bandwidth kernel
smoothing, implemented by applying the Probability Integral Transform
to the covariate values, yielding values in the range 0 to 1,
then applying edge-corrected density estimation on the interval
<code class="reqn">[0,1]</code>, and back-transforming.
See Baddeley et al (2012), equation (10).
</p>
</li></ul>

<p>If <code>horvitz=TRUE</code>, then the calculations described above
are modified by using Horvitz-Thompson weighting.
The contribution to the numerator from 
each data point is weighted by the reciprocal of the
baseline value or fitted intensity value at that data point;
and a corresponding adjustment is made to the denominator.
</p>
<p>If <code>do.CI=TRUE</code> (the default),
pointwise confidence intervals for the true value of <code class="reqn">\rho(z)</code>
are also calculated for each <code class="reqn">z</code>,
and will be plotted as grey shading.
The confidence intervals are derived using the central limit theorem,
based on variance calculations which assume a Poisson point process. 
If <code>positiveCI=FALSE</code>, the lower limit of the confidence
interval may sometimes be negative, because the confidence intervals
are based on a normal approximation to the estimate of <code class="reqn">\rho(z)</code>.
If <code>positiveCI=TRUE</code>, the confidence limits are always
positive, because the confidence interval is based on a normal
approximation to the estimate of <code class="reqn">\log(\rho(z))</code>.
For consistency with earlier versions, the default is
<code>positiveCI=FALSE</code> for <code>smoother="kernel"</code>
and <code>positiveCI=TRUE</code> for <code>smoother="local"</code>.
</p>


<h3>Monotone estimates</h3>

<p>The nonparametric maximum likelihood estimator
of a monotone function <code class="reqn">\rho(z)</code> was described by Sager (1982).
This method assumes that
<code class="reqn">\rho(z)</code> is either an increasing
function of <code class="reqn">z</code>, or a decreasing function of <code class="reqn">z</code>.
The estimated function will be a step function,
increasing or decreasing as a function of <code class="reqn">z</code>.
</p>
<p>This estimator is chosen by specifying
<code>smoother="increasing"</code> or <code>smoother="decreasing"</code>.
The argument <code>method</code> is ignored this case.
</p>
<p>To compute the estimate of <code class="reqn">\rho(z)</code>, the algorithm first
computes several primitive step-function estimates, and then takes
the maximum of these primitive functions.
</p>
<p>If <code>smoother="decreasing"</code>, each primitive step function
takes the form <code class="reqn">\rho(z) = \lambda</code> when <code class="reqn">z \le t</code>,
and <code class="reqn">\rho(z) = 0</code> when <code class="reqn">z &gt; t</code>, where
and <code class="reqn">\lambda</code> is a primitive estimate of intensity
based on the data for <code class="reqn">Z \le t</code>. The jump location <code class="reqn">t</code>
will be the value of the covariate <code class="reqn">Z</code> at one of the
data points. The primitive estimate <code class="reqn">\lambda</code>
is the average intensity (number of points divided by area)
for the region of space where the covariate value is less than
or equal to <code class="reqn">t</code>.
</p>
<p>If <code>horvitz=TRUE</code>, then the calculations described above
are modified by using Horvitz-Thompson weighting.
The contribution to the numerator from 
each data point is weighted by the reciprocal of the
baseline value or fitted intensity value at that data point;
and a corresponding adjustment is made to the denominator.
</p>
<p>Confidence intervals are not available
for the monotone estimators.
</p>


<h3>Unimodal estimators</h3>

<p>If <code>smoother="valley"</code> then we estimate a U-shaped function.
A function <code class="reqn">\rho(z)</code> is U-shaped if it is
decreasing when <code class="reqn">z &lt; z_0</code> and
increasing when <code class="reqn">z &gt; z_0</code>, where <code class="reqn">z_0</code> is
called the critical value. The nonparametric maximum likelihood
estimate of such a function can be computed by profiling over <code class="reqn">z_0</code>. 
The algorithm considers all possible candidate values of the critical value 
<code class="reqn">z_0</code>, and estimates the function <code class="reqn">\rho(z)</code>
separately on the left and right of <code class="reqn">z_0</code> using the monotone
estimators described above. These function estimates are combined into
a single function, and the Poisson point process likelihood is
computed. The optimal value of <code class="reqn">z_0</code>
is the one which maximises the Poisson point process likelihood.
</p>
<p>If <code>smoother="mountain"</code>  then we estimate a function which has
an inverted U shape. A function <code class="reqn">\rho(z)</code> is
inverted-U-shaped if it is
increasing when <code class="reqn">z &lt; z_0</code> and
decreasing when <code class="reqn">z &gt; z_0</code>. The nonparametric maximum likelihood
estimate of such a function can be computed by profiling over
<code class="reqn">z_0</code> using the same technique <em>mutatis mutandis</em>.
</p>
<p>Confidence intervals are not available for the unimodal estimators.
</p>


<h3>Randomisation</h3>

<p>By default, <code>rhohat</code> adds a small amount of random noise to the
data. This is designed to suppress the effects of
discretisation in pixel images.
</p>
<p>This strategy means that <code>rhohat</code>
does not produce exactly the same result when the computation is
repeated. If you need the results to be exactly reproducible, set
<code>jitter=FALSE</code> and <code>random=FALSE</code>.
</p>
<p>The values of the covariate <em>at the data points</em>
are randomly perturbed by adding a small amount
of noise using the function <code><a href="base.html#topic+jitter">jitter</a></code>. To reduce this
effect, set <code>jitterfactor</code> to a number smaller than 1. To
suppress this effect entirely, set <code>jitter=FALSE</code>.
</p>
<p>The values of the covariate <em>along the network</em>
are sampled at a regularly-spaced grid on the network.
The grid starts from a random position on each segment of
the network. To suppress this behaviour, set <code>random=FALSE</code>.
</p>


<h3>Author(s)</h3>

<p>Smoothing algorithm by
Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, 
Ya-Mei Chang, Yong Song, 
and Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>.
</p>
<p>Nonparametric maximum likelihood algorithm by Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Baddeley, A., Chang, Y.-M., Song, Y. and Turner, R. (2012)
Nonparametric estimation of the dependence of a point
process on spatial covariates.
<em>Statistics and Its Interface</em> <b>5</b> (2), 221&ndash;236.
</p>
<p>Baddeley, A. and Turner, R. (2005)
Modelling spatial point patterns in R.
In: A. Baddeley, P. Gregori, J. Mateu, R. Stoica, and D. Stoyan,
editors, <em>Case Studies in Spatial Point Pattern Modelling</em>,
Lecture Notes in Statistics number 185. Pages 23&ndash;74.
Springer-Verlag, New York, 2006. 
ISBN: 0-387-28311-0.  
</p>
<p>Baddeley, A. (2018)
A statistical commentary on mineral prospectivity analysis.
Chapter 2, pages 25&ndash;65
in <em>Handbook of Mathematical Geosciences: Fifty Years of IAMG</em>,
edited by B.S. Daya Sagar, Q. Cheng and F.P. Agterberg.
Springer, Berlin.
</p>
<p>Guan, Y. (2008) On consistent nonparametric intensity estimation
for inhomogeneous spatial point processes.
<em>Journal of the American Statistical Association</em>
<b>103</b>, 1238&ndash;1247.
</p>
<p>Handcock, M.S. and Morris, M. (1999)
<em>Relative Distribution Methods in the Social Sciences</em>.
Springer, New York.
</p>
<p>Sager, T.W. (1982) 
Nonparametric maximum likelihood estimation of
spatial patterns. <em>Annals of Statistics</em> <b>10</b>, 1125&ndash;1136.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.explore.html#topic+rho2hat">rho2hat</a></code>,
<code><a href="spatstat.explore.html#topic+methods.rhohat">methods.rhohat</a></code>,
<code><a href="spatstat.model.html#topic+parres">parres</a></code>.
</p>
<p>See <code><a href="#topic+lppm">lppm</a></code> for a parametric method for the same problem.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  Y &lt;- runiflpp(30, simplenet)
  rhoY &lt;- rhohat(Y, "y")

  ## do spiders prefer to be in the middle of a segment?
  teepee &lt;- linfun(function(x,y,seg,tp){ tp }, domain(spiders))
  rhotee &lt;- rhohat(spiders, teepee)
  rhoteeM &lt;- rhohat(spiders, teepee, smoother="mountain")
  if(interactive()) {
    plot(rhotee, main="Spider preference for mid-segment")
    plot(rhoteeM, add=TRUE, .y ~ .x, lwd=3)
  }
</code></pre>

<hr>
<h2 id='rjitter.lpp'>Random Perturbation of a Point Pattern on a Network</h2><span id='topic+rjitter.lpp'></span>

<h3>Description</h3>

<p>Applies independent random displacements to each point
in a point pattern on a network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpp'
rjitter(X, radius, ..., nsim = 1, drop = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rjitter.lpp_+3A_x">X</code></td>
<td>

<p>A point pattern on a linear network
(object of class <code>"lpp"</code>).
</p>
</td></tr>
<tr><td><code id="rjitter.lpp_+3A_radius">radius</code></td>
<td>

<p>Scale of perturbations. A positive numerical value.
Each point will be displaced by a random distance,
with maximum displacement equal to this value.
</p>
</td></tr>
<tr><td><code id="rjitter.lpp_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="rjitter.lpp_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulated realisations to be generated.</p>
</td></tr>
<tr><td><code id="rjitter.lpp_+3A_drop">drop</code></td>
<td>

<p>Logical. If <code>nsim=1</code> and <code>drop=TRUE</code> (the default), the
result will be a point pattern, rather than a list 
containing a point pattern.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="spatstat.geom.html#topic+rjitter">rjitter</a></code> is generic. This function is
the method for the class <code>"lpp"</code> of point patterns on a linear network.
</p>
<p>Each of the points in <code>X</code> will be displaced along the network
by a random amount, independently of other points.
The maximum displacement distance is specified by <code>radius</code>.
Each point remains on the same line segment of the network
as it originally was.
</p>


<h3>Value</h3>

<p>A point pattern on a linear network
(object of class <code>"lpp"</code>)
or a list of such point patterns.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.geom.html#topic+rjitter">rjitter</a></code> for point patterns in two dimensions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   X &lt;- runiflpp(3, simplenet)
   plot(X, pch=16)
   Y &lt;- rjitter(X, 0.1)
   plot(Y, add=TRUE, cols=3)
</code></pre>

<hr>
<h2 id='rlpp'>
Random Points on a Linear Network
</h2><span id='topic+rlpp'></span>

<h3>Description</h3>

<p>Generates <code class="reqn">n</code> independent random points
on a linear network with a specified probability density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  rlpp(n, f, ..., nsim=1, drop=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rlpp_+3A_n">n</code></td>
<td>

<p>Number of random points to generate.
A nonnegative integer giving the number of points,
or an integer vector giving the numbers of points of each type.
</p>
</td></tr>
<tr><td><code id="rlpp_+3A_f">f</code></td>
<td>

<p>Probability density (not necessarily normalised).
A pixel image on a linear network (object of class <code>"linim"</code>)
or a function on a linear network (object of class <code>"linfun"</code>).
Alternatively, <code>f</code> can be a list of functions or pixel images,
giving the densities of points of each type.
</p>
</td></tr>
<tr><td><code id="rlpp_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to <code>f</code> if it is a function
or a list of functions.
</p>
</td></tr>
<tr><td><code id="rlpp_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulated realisations to generate.</p>
</td></tr>
<tr><td><code id="rlpp_+3A_drop">drop</code></td>
<td>

<p>Logical value indicating what to do when <code>nsim=1</code>.
If <code>drop=TRUE</code> (the default), the result is a point pattern.
If <code>drop=FALSE</code>, the result is a list with one entry which is a
point pattern.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The linear network <code>L</code>, on which the points will be generated,
is determined by the argument <code>f</code>.
</p>
<p>If <code>f</code> is a function, it is converted to a pixel image
on the linear network, using any additional function arguments
<code>...</code>.
</p>
<p>If <code>n</code> is a single integer and <code>f</code> is a function or pixel image,
then independent random points are generated on <code>L</code> with
probability density proportional to <code>f</code>.
</p>
<p>If <code>n</code> is an integer vector and <code>f</code> is a list of functions
or pixel images, where <code>n</code> and <code>f</code> have the same length,
then independent random points of several types are generated on
<code>L</code>, with <code>n[i]</code> points of type <code>i</code> having probability
density proportional to <code>f[[i]]</code>.
</p>


<h3>Value</h3>

<p>If <code>nsim = 1</code> and <code>drop=TRUE</code>,
a point pattern on the linear network,
i.e.\ an object of class <code>"lpp"</code>.
Otherwise, a list of such point patterns.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a> 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+runiflpp">runiflpp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  g &lt;- function(x, y, seg, tp) { exp(x + 3*y) }
  f &lt;- linfun(g, simplenet)

  rlpp(20, f)

  plot(rlpp(20, f, nsim=3))
</code></pre>

<hr>
<h2 id='roc.lpp'>
Receiver Operating Characteristic for Data on a Network
</h2><span id='topic+roc.lpp'></span><span id='topic+roc.lppm'></span>

<h3>Description</h3>

<p>Computes the Receiver Operating Characteristic curve
for a point pattern or a fitted point process model
on a linear network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpp'
roc(X, covariate, ..., high = TRUE)

## S3 method for class 'lppm'
roc(X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roc.lpp_+3A_x">X</code></td>
<td>

<p>Point pattern on a network (object of class <code>"lpp"</code>)
or fitted point process model on a network
(object of class <code>"lppm"</code>).
</p>
</td></tr>
<tr><td><code id="roc.lpp_+3A_covariate">covariate</code></td>
<td>

<p>Spatial covariate. Either a <code>function(x,y)</code>,
a pixel image (object of class <code>"im"</code> or <code>"linim"</code>), or
one of the strings <code>"x"</code> or <code>"y"</code> indicating the
Cartesian coordinates.    
</p>
</td></tr>
<tr><td><code id="roc.lpp_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="grid.html#topic+as.mask">as.mask</a></code> controlling the
pixel resolution for calculations.
</p>
</td></tr>
<tr><td><code id="roc.lpp_+3A_high">high</code></td>
<td>

<p>Logical value indicating whether the threshold operation
should favour high or low values of the covariate.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The command <code>roc</code>
computes the Receiver Operating
Characteristic curve.
The area under the ROC is computed by <code><a href="spatstat.explore.html#topic+auc">auc</a></code>.
</p>
<p>The function <code><a href="spatstat.explore.html#topic+roc">roc</a></code> is generic,
with methods for <code>"ppp"</code> and <code>"ppm"</code> described in the help file
for <code><a href="spatstat.explore.html#topic+roc">roc</a></code>.
</p>
<p>This help file describes the methods for classes <code>"lpp"</code> and
<code>"lppm"</code>.
</p>
<p>For a point pattern <code>X</code> and a covariate <code>Z</code>, the
ROC is a plot showing the ability of the 
covariate to separate the spatial domain
into areas of high and low density of points.
For each possible threshold <code class="reqn">z</code>, the algorithm calculates
the fraction <code class="reqn">a(z)</code> of area in the study region where the
covariate takes a value greater than <code class="reqn">z</code>, and the
fraction <code class="reqn">b(z)</code> of data points for which the covariate value
is greater than <code class="reqn">z</code>. The ROC is a plot of <code class="reqn">b(z)</code> against
<code class="reqn">a(z)</code> for all thresholds <code class="reqn">z</code>. 
</p>
<p>For a fitted point process model, 
the ROC shows the ability of the
fitted model intensity to separate the spatial domain
into areas of high and low density of points.
The ROC is <b>not</b> a diagnostic for the goodness-of-fit of the model
(Lobo et al, 2007).
</p>


<h3>Value</h3>

<p>Function value table (object of class <code>"fv"</code>)
which can be plotted to show the ROC curve.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Lobo, J.M.,
Jimenez-Valverde, A.
and Real, R. (2007)
AUC: a misleading measure of the performance of predictive
distribution models.
<em>Global Ecology and Biogeography</em> <b>17</b>(2) 145&ndash;151.
</p>
<p>Nam, B.-H. and D'Agostino, R. (2002)
Discrimination index, the area under the ROC curve.
Pages 267&ndash;279 in 
Huber-Carol, C., Balakrishnan, N., Nikulin, M.S. 
and Mesbah, M., <em>Goodness-of-fit tests and model validity</em>,
Birkhauser, Basel.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+auc.lpp">auc.lpp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  plot(roc(spiders, "x"))
  fit &lt;- lppm(spiders ~ x)
  plot(roc(fit))
</code></pre>

<hr>
<h2 id='rpoislpp'>
Poisson Point Process on a Linear Network
</h2><span id='topic+rpoislpp'></span>

<h3>Description</h3>

<p>Generates a realisation of the Poisson point process
with specified intensity on the given linear network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rpoislpp(lambda, L, ..., nsim=1, drop=TRUE, ex=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rpoislpp_+3A_lambda">lambda</code></td>
<td>

<p>Intensity of the Poisson process. 
A single number, a <code>function(x,y)</code>, a pixel image
(object of class <code>"im"</code>), or a vector of numbers,
a list of functions, or a list of images.
</p>
</td></tr>
<tr><td><code id="rpoislpp_+3A_l">L</code></td>
<td>

<p>A linear network (object of class <code>"linnet"</code>,
see <code><a href="#topic+linnet">linnet</a></code>).
Can be omitted in some cases: see Details.
</p>
</td></tr>
<tr><td><code id="rpoislpp_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="spatstat.random.html#topic+rpoisppOnLines">rpoisppOnLines</a></code>.
</p>
</td></tr>
<tr><td><code id="rpoislpp_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulated realisations to generate.</p>
</td></tr>
<tr><td><code id="rpoislpp_+3A_drop">drop</code></td>
<td>

<p>Logical value indicating what to do when <code>nsim=1</code>.
If <code>drop=TRUE</code> (the default), the result is a point pattern.
If <code>drop=FALSE</code>, the result is a list with one entry which is a
point pattern.
</p>
</td></tr>
<tr><td><code id="rpoislpp_+3A_ex">ex</code></td>
<td>

<p>Optional. A point pattern on a network
(object of class <code>"lpp"</code>) which serves as an example
to determine the default values of <code>lambda</code> and <code>L</code>.
See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A random number of random points is generated on the network <code>L</code>,
according to a Poisson point process
with intensity <code>lambda</code> points per unit length.
The random points are generated by <code><a href="spatstat.random.html#topic+rpoisppOnLines">rpoisppOnLines</a></code>.
See the help file for <code><a href="spatstat.random.html#topic+rpoisppOnLines">rpoisppOnLines</a></code> for information.
</p>
<p>Argument <code>L</code> can be omitted, and defaults to <code>as.linnet(lambda)</code>,
when <code>lambda</code> is a function on a linear network (class
<code>"linfun"</code>) or a pixel image on a linear network
(<code>"linim"</code>).
</p>
<p>If <code>ex</code> is given, then it serves as an example for determining
<code>lambda</code> and <code>L</code>. The default value of <code>lambda</code>
will be the average intensity (number per unit length) of points in
<code>ex</code> (or the average intensity of the points of each type
if <code>ex</code> is multitype). The default value of <code>L</code> will be 
the network on which <code>ex</code> is defined. 
</p>


<h3>Value</h3>

<p>If <code>nsim = 1</code> and <code>drop=TRUE</code>,
a point pattern on the linear network,
i.e.\ an object of class <code>"lpp"</code>.
Otherwise, a list of such point patterns.
</p>


<h3>Author(s)</h3>

<p>Ang Qi Wei <a href="mailto:aqw07398@hotmail.com">aqw07398@hotmail.com</a> and 
Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a> 
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.random.html#topic+rpoisppOnLines">rpoisppOnLines</a></code>,
<code><a href="#topic+runiflpp">runiflpp</a></code>,
<code><a href="#topic+rlpp">rlpp</a></code>,
<code><a href="#topic+lpp">lpp</a></code>,
<code><a href="#topic+linnet">linnet</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   X &lt;- rpoislpp(5, simplenet)
   plot(X)
   # multitype
   Y &lt;- rpoislpp(c(a=5, b=5), simplenet)
   # using argument 'ex' to make a pattern like 'X'
   Z &lt;- rpoislpp(ex=X)
</code></pre>

<hr>
<h2 id='rSwitzerlpp'>
Switzer-type Point Process on Linear Network
</h2><span id='topic+rSwitzerlpp'></span>

<h3>Description</h3>

<p>Generate a realisation of the Switzer-type point process
on a linear network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rSwitzerlpp(L, lambdacut, rintens = rexp, ...,
         cuts=c("points", "lines"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rSwitzerlpp_+3A_l">L</code></td>
<td>

<p>Linear network (object of class <code>"linnet"</code>).
</p>
</td></tr>
<tr><td><code id="rSwitzerlpp_+3A_lambdacut">lambdacut</code></td>
<td>

<p>Intensity of Poisson process of breakpoints.
</p>
</td></tr>
<tr><td><code id="rSwitzerlpp_+3A_rintens">rintens</code></td>
<td>

<p>Optional. Random variable generator
used to generate the random intensity in each component.
</p>
</td></tr>
<tr><td><code id="rSwitzerlpp_+3A_...">...</code></td>
<td>

<p>Additional arguments to <code>rintens</code>.
</p>
</td></tr>
<tr><td><code id="rSwitzerlpp_+3A_cuts">cuts</code></td>
<td>

<p>String (partially matched) specifying the type of random cuts to be
generated. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates simulated realisations of
the Switzer-type point process on a network,
as described in Baddeley et al (2017).
</p>
<p>The linear network is first divided into pieces by a random
mechanism:
</p>

<ul>
<li><p> if <code>cuts="points"</code>, 
a Poisson process of breakpoints with intensity <code>lambdacut</code>
is generated on the network, and these breakpoints separate the
network into connected pieces. 
</p>
</li>
<li><p> if <code>cuts="lines"</code>, a Poisson line process in the plane
with intensity <code>lambdacut</code> is generated; these lines divide
space into tiles; the network is divided into subsets associated
with the tiles. Each subset may not be a connected sub-network.
</p>
</li></ul>

<p>In each piece of the network, a random intensity is generated
using the random variable generator <code>rintens</code> (the default is
a negative exponential random variable with rate 1). Given the
intensity value, a Poisson process is generated with the specified
intensity.
</p>
<p>The intensity of the final process is determined by the mean
of the values generated by <code>rintens</code>. If <code>rintens=rexp</code> (the
default), then the parameter <code>rate</code> specifies the inverse of the
intensity. 
</p>


<h3>Value</h3>

<p>Point pattern on a linear network (object of class <code>"lpp"</code>)
with an attribute <code>"breaks"</code> containing the breakpoints (if
<code>cuts="points"</code>) or the random lines (if <code>cuts="lines"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Baddeley, A., Nair, G., Rakshit, S. and McSwiggan, G. (2017)
&lsquo;Stationary&rsquo; point processes are uncommon on
linear networks. <em>STAT</em> <b>6</b>, 68&ndash;78.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rcelllpp">rcelllpp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   plot(rSwitzerlpp(domain(spiders), 0.01, rate=100))

   plot(rSwitzerlpp(domain(spiders), 0.0005, rate=100, cuts="l"))
</code></pre>

<hr>
<h2 id='rThomaslpp'>
Simulate Thomas Process on Linear Network
</h2><span id='topic+rThomaslpp'></span>

<h3>Description</h3>

<p>Generate a random point pattern, a realisation of the
Thomas cluster process, on a linear network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  rThomaslpp(kappa, scale, mu, L, ..., nsim=1, drop=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rThomaslpp_+3A_kappa">kappa</code></td>
<td>

<p>Intensity of the Poisson process of cluster centres.
A single positive number, a <code>function(x,y)</code>, or a pixel image
(object of class <code>"im"</code> or <code>"linim"</code>).
</p>
</td></tr>
<tr><td><code id="rThomaslpp_+3A_scale">scale</code></td>
<td>

<p>Standard deviation of random displacement (along the network)
of a point from its cluster centre.
</p>
</td></tr>
<tr><td><code id="rThomaslpp_+3A_mu">mu</code></td>
<td>

<p>Mean number of points per cluster (a single positive number)
or reference intensity for the cluster points (a function or
a pixel image).
</p>
</td></tr>
<tr><td><code id="rThomaslpp_+3A_l">L</code></td>
<td>

<p>Linear network (object of class <code>"linnet"</code>)
on which the point pattern should be generated.
</p>
</td></tr>
<tr><td><code id="rThomaslpp_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="spatstat.random.html#topic+rpoisppOnLines">rpoisppOnLines</a></code>.
</p>
</td></tr>
<tr><td><code id="rThomaslpp_+3A_nsim">nsim</code></td>
<td>

<p>Number of simulated realisations to generate.
</p>
</td></tr>
<tr><td><code id="rThomaslpp_+3A_drop">drop</code></td>
<td>

<p>Logical value indicating what to do when <code>nsim=1</code>.
If <code>drop=TRUE</code> (the default), the result is a point pattern.
If <code>drop=FALSE</code>, the result is a list with one entry which is a
point pattern.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates realisations of the Thomas cluster process
on a linear network, described by Baddeley et al (2017).
</p>
<p>Argument <code>L</code> can be omitted, and defaults to <code>as.linnet(kappa)</code>,
when <code>kappa</code> is a function on a linear network (class
<code>"linfun"</code>) or a pixel image on a linear network (<code>"linim"</code>).
</p>


<h3>Value</h3>

<p>A point pattern on a network (object of class <code>"lpp"</code>)
or a list of point patterns on the network.
</p>


<h3>Author(s)</h3>

<p>Greg McSwiggan and Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Baddeley, A., Nair, G., Rakshit, S. and McSwiggan, G. (2017)
&lsquo;Stationary&rsquo; point processes are uncommon on linear networks.
<em>STAT</em> <b>6</b> (1) 68&ndash;78.
</p>
<p>Baddeley, A., Nair, G., Rakshit, S., McSwiggan, G. and Davies, T.M. (2021)
Analysing point patterns on networks &mdash; a review.
<em>Spatial Statistics</em> <b>42</b>, 100435,
DOI 10.1016/j.spasta.2020.100435.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rpoislpp">rpoislpp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  plot(rThomaslpp(4, 0.07, 5, simplenet))
</code></pre>

<hr>
<h2 id='runiflpp'>
Uniform Random Points on a Linear Network
</h2><span id='topic+runiflpp'></span>

<h3>Description</h3>

<p>Generates <code class="reqn">n</code> random points, independently and
uniformly distributed, on a linear network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runiflpp(n, L, nsim=1, drop=TRUE, ex=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runiflpp_+3A_n">n</code></td>
<td>

<p>Number of random points to generate.
A nonnegative integer, or a vector of integers
specifying the number of points of each type.
</p>
</td></tr>
<tr><td><code id="runiflpp_+3A_l">L</code></td>
<td>

<p>A linear network (object of class <code>"linnet"</code>,
see <code><a href="#topic+linnet">linnet</a></code>).
</p>
</td></tr>
<tr><td><code id="runiflpp_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulated realisations to generate.</p>
</td></tr>
<tr><td><code id="runiflpp_+3A_drop">drop</code></td>
<td>

<p>Logical value indicating what to do when <code>nsim=1</code>.
If <code>drop=TRUE</code> (the default), the result is a point pattern.
If <code>drop=FALSE</code>, the result is a list with one entry which is a
point pattern.
</p>
</td></tr>
<tr><td><code id="runiflpp_+3A_ex">ex</code></td>
<td>

<p>Optional. A point pattern on a network
(object of class <code>"lpp"</code>) which serves as an example
to determine the default values of <code>n</code> and <code>L</code>.
See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The specified number <code>n</code> of random points is
generated with uniform distribution on the network <code>L</code>.
The random points are generated using <code><a href="spatstat.random.html#topic+runifpointOnLines">runifpointOnLines</a></code>.
</p>
<p>If <code>n</code> is an integer vector, then a multitype point pattern is
generated, with <code>n[i]</code> random points of type <code>i</code>.
</p>
<p>If <code>ex</code> is given, then it serves as an example for determining
<code>n</code> and <code>L</code>. The default value of <code>n</code>
will be the number of points in <code>ex</code>
(or the number of points of each type in <code>ex</code> if it is
multitype).
The default value of <code>L</code> will be 
the network on which <code>ex</code> is defined. 
</p>


<h3>Value</h3>

<p>If <code>nsim = 1</code> and <code>drop=TRUE</code>,
a point pattern on a linear network
(object of class <code>"lpp"</code>).
Otherwise, a list of such point patterns.
</p>


<h3>Author(s)</h3>

<p>Ang Qi Wei <a href="mailto:aqw07398@hotmail.com">aqw07398@hotmail.com</a> and 
Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a> 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rlpp">rlpp</a></code> for non-uniform random points;
<code><a href="#topic+rpoislpp">rpoislpp</a></code> for Poisson point process;
</p>
<p><code><a href="#topic+lpp">lpp</a></code>,
<code><a href="#topic+linnet">linnet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   X &lt;- runiflpp(10, simplenet)
   plot(X)
  # marked
   Z &lt;- runiflpp(c(a=10, b=3), simplenet)
  # using 'ex' 
   U &lt;- runiflpp(ex=Z)
</code></pre>

<hr>
<h2 id='sdr.lpp'>
Sufficient Dimension Reduction for a Point Pattern on a Linear Network
</h2><span id='topic+sdr.lpp'></span>

<h3>Description</h3>

<p>Given a point pattern on a linear network, and a set of predictors,
find a minimal set of new predictors, each constructed as
a linear combination of the original predictors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpp'
sdr(X, covariates,
            method = c("DR", "NNIR", "SAVE", "SIR", "TSE"),
            Dim1 = 1, Dim2 = 1, predict=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sdr.lpp_+3A_x">X</code></td>
<td>

<p>A point pattern on a linear network
(object of class <code>"lpp"</code>).
</p>
</td></tr>
<tr><td><code id="sdr.lpp_+3A_covariates">covariates</code></td>
<td>

<p>A list of pixel images (objects of class <code>"im"</code> or <code>"linim"</code>)
to serve as predictor variables.
</p>
</td></tr>
<tr><td><code id="sdr.lpp_+3A_method">method</code></td>
<td>

<p>Character string indicating which method to use. See Details.
</p>
</td></tr>
<tr><td><code id="sdr.lpp_+3A_dim1">Dim1</code></td>
<td>

<p>Dimension of the first order Central Intensity Subspace
(applicable when <code>method</code> is <code>"DR"</code>, <code>"NNIR"</code>,
<code>"SAVE"</code> or <code>"TSE"</code>). 
</p>
</td></tr>
<tr><td><code id="sdr.lpp_+3A_dim2">Dim2</code></td>
<td>

<p>Dimension of the second order Central Intensity Subspace
(applicable when <code>method="TSE"</code>).
</p>
</td></tr>
<tr><td><code id="sdr.lpp_+3A_predict">predict</code></td>
<td>

<p>Logical value indicating whether to compute the new predictors
as well.
</p>
</td></tr>
<tr><td><code id="sdr.lpp_+3A_...">...</code></td>
<td>
<p>Extra arguments are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the method for <code><a href="spatstat.explore.html#topic+sdr">sdr</a></code>
for the class <code>"lpp"</code> of point patterns on a linear network.
</p>
<p>Given a point pattern <code class="reqn">X</code> and predictor variables
<code class="reqn">Z_1, \dots, Z_p</code>,
Sufficient Dimension Reduction methods
(Guan and Wang, 2010) attempt to find a minimal set
of new predictor variables, each constructed by taking a linear combination
of the original predictors, which explain the dependence of
<code class="reqn">X</code> on   <code class="reqn">Z_1, \dots, Z_p</code>.
The methods do not assume any particular form of dependence
of the point pattern on the predictors.
The predictors are assumed to
be Gaussian random fields.
</p>
<p>Available methods are:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>method="DR"</code> </td><td style="text-align: left;"> directional regression </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>method="NNIR"</code> </td><td style="text-align: left;"> nearest neighbour inverse regression </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>method="SAVE"</code> &amp; sliced average variance estimation </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>method="SIR"</code> &amp; sliced inverse regression </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>method="TSE"</code> &amp; two-step estimation </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p>The result includes a matrix <code>B</code> whose columns are estimates
of the basis vectors of the space of new predictors. That is,
the <code>j</code>th column of <code>B</code> expresses the <code>j</code>th new
predictor as a linear combination of the original predictors.
</p>
<p>If <code>predict=TRUE</code>, the new predictors are also evaluated.
They can also be evaluated using <code><a href="spatstat.explore.html#topic+sdrPredict">sdrPredict</a></code>.
</p>


<h3>Value</h3>

<p>A list with components <code>B, M</code>
or <code>B, M1, M2</code> where
<code>B</code> is a matrix whose columns are estimates of the basis vectors
for the space, and <code>M</code> or <code>M1,M2</code> are matrices containing
estimates of the kernel.
</p>
<p>If <code>predict=TRUE</code>, the result also includes a component
<code>Y</code> which is a list of pixel images giving the values of the
new predictors.
</p>


<h3>Author(s)</h3>

<p>Based on a Matlab original, for two-dimensional point patterns,
by Yongtao Guan.
Adapted to <span class="rlang"><b>R</b></span>, and to linear networks, by Suman Rakshit.
</p>


<h3>References</h3>

<p>Guan, Y. and Wang, H. (2010)
Sufficient dimension reduction for spatial point
processes directed by Gaussian random fields.
<em>Journal of the Royal Statistical Society, Series B</em>,
<b>72</b>, 367&ndash;387.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.explore.html#topic+sdrPredict">sdrPredict</a></code> to compute the new predictors from the
coefficient matrix.
</p>
<p><code><a href="spatstat.explore.html#topic+dimhat">dimhat</a></code> to estimate the subspace dimension.
</p>
<p><code><a href="spatstat.explore.html#topic+subspaceDistance">subspaceDistance</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#   sdr(bei, bei.extra)

   xim &lt;- as.linim(function(x,y) { x }, simplenet)
   yim &lt;- as.linim(function(x,y) { y }, simplenet)
   X &lt;- runiflpp(30, simplenet)
   sdr(X, list(x=xim, y=yim))
</code></pre>

<hr>
<h2 id='simulate.lppm'>Simulate a Fitted Point Process Model on a Linear Network</h2><span id='topic+simulate.lppm'></span>

<h3>Description</h3>

<p>Generates simulated realisations from a fitted Poisson
point process model on a linear network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'lppm'
simulate(object, nsim=1, ...,
                         new.coef=NULL,
                         progress=(nsim &gt; 1),
                         drop=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.lppm_+3A_object">object</code></td>
<td>

<p>Fitted point process model on a linear network.
An object of class <code>"lppm"</code>.
</p>
</td></tr>
<tr><td><code id="simulate.lppm_+3A_nsim">nsim</code></td>
<td>

<p>Number of simulated realisations.
</p>
</td></tr>
<tr><td><code id="simulate.lppm_+3A_progress">progress</code></td>
<td>

<p>Logical flag indicating whether to print progress reports
for the sequence of simulations.
</p>
</td></tr>
<tr><td><code id="simulate.lppm_+3A_new.coef">new.coef</code></td>
<td>

<p>New values for the canonical parameters of the model.
A numeric vector of the same length as <code>coef(object)</code>.
</p>
</td></tr>
<tr><td><code id="simulate.lppm_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+predict.lppm">predict.lppm</a></code>
to determine the spatial resolution of the image of the fitted intensity
used in the simulation.
</p>
</td></tr>
<tr><td><code id="simulate.lppm_+3A_drop">drop</code></td>
<td>

<p>Logical. If <code>nsim=1</code> and <code>drop=TRUE</code>, the
result will be a point pattern, rather than a list 
containing a point pattern.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a method for the generic function
<code><a href="stats.html#topic+simulate">simulate</a></code> for the class <code>"lppm"</code> of fitted
point process models on a linear network.
</p>
<p>Only Poisson process models are supported so far.
</p>
<p>Simulations are performed by <code><a href="#topic+rpoislpp">rpoislpp</a></code>.
</p>


<h3>Value</h3>

<p>A list of length <code>nsim</code> containing simulated point patterns
(objects of class <code>"lpp"</code>) on the same linear network as the
original data used to fit the model.
The result also belongs to the class <code>"solist"</code>, so that it can be
plotted, and the class <code>"timed"</code>, so that the total computation
time is recorded.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>,
Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lppm">lppm</a></code>,
<code><a href="#topic+rpoislpp">rpoislpp</a></code>,
<code><a href="stats.html#topic+simulate">simulate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  fit &lt;- lppm(unmark(chicago) ~ y)
  simulate(fit)[[1]]
</code></pre>

<hr>
<h2 id='Smooth.lpp'>Spatial Smoothing of Observations on a Network</h2><span id='topic+Smooth.lpp'></span>

<h3>Description</h3>

<p>Performs spatial smoothing of numeric values observed
at a set of locations on a network. Uses kernel smoothing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpp'
Smooth(X, sigma,
                     ...,
                     at=c("pixels", "points"),
                     weights=rep(1, npoints(X)),
                     leaveoneout=TRUE) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Smooth.lpp_+3A_x">X</code></td>
<td>

<p>A marked point pattern on a linear network
(object of class <code>"lpp"</code>).
</p>
</td></tr>
<tr><td><code id="Smooth.lpp_+3A_sigma">sigma</code></td>
<td>

<p>Smoothing bandwidth.
A single positive number.
See <code><a href="#topic+density.lpp">density.lpp</a></code>.
</p>
</td></tr>
<tr><td><code id="Smooth.lpp_+3A_...">...</code></td>
<td>

<p>Further arguments passed to
<code><a href="#topic+density.lpp">density.lpp</a></code>
to control the kernel smoothing and
the pixel resolution of the result.
</p>
</td></tr>
<tr><td><code id="Smooth.lpp_+3A_at">at</code></td>
<td>

<p>String specifying whether to compute the smoothed values
at a grid of pixel locations (<code>at="pixels"</code>) or
only at the points of <code>X</code> (<code>at="points"</code>).
</p>
</td></tr>
<tr><td><code id="Smooth.lpp_+3A_weights">weights</code></td>
<td>

<p>Optional numeric vector of weights attached to the observations.
</p>
</td></tr>
<tr><td><code id="Smooth.lpp_+3A_leaveoneout">leaveoneout</code></td>
<td>

<p>Logical value indicating whether to compute a leave-one-out
estimator. Applicable only when <code>at="points"</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>Smooth.lpp</code>
performs spatial smoothing of numeric values
observed at a set of irregular locations on a linear network.
</p>
<p><code>Smooth.lpp</code> is a method for the generic function
<code><a href="spatstat.explore.html#topic+Smooth">Smooth</a></code> for the class <code>"lpp"</code> of point patterns.
Thus you can type simply <code>Smooth(X)</code>.
</p>
<p>Smoothing is performed by kernel weighting, using the Gaussian kernel
by default. If the observed values are <code class="reqn">v_1,\ldots,v_n</code>
at locations <code class="reqn">x_1,\ldots,x_n</code> respectively,
then the smoothed value at a location <code class="reqn">u</code> is
</p>
<p style="text-align: center;"><code class="reqn">
    g(u) = \frac{\sum_i k(u, x_i) v_i}{\sum_i k(u, x_i)}
  </code>
</p>

<p>where <code class="reqn">k</code> is the kernel.
This is known as the Nadaraya-Watson smoother
(Nadaraya, 1964, 1989; Watson, 1964).
The type of kernel is determined by further arguments <code>...</code>
which are passed to <code><a href="#topic+density.lpp">density.lpp</a></code>
</p>
<p>The argument <code>X</code> must be a marked point pattern on a linear
network (object of class <code>"lpp"</code>).
The points of the pattern are taken to be the
observation locations <code class="reqn">x_i</code>, and the marks of the pattern
are taken to be the numeric values <code class="reqn">v_i</code> observed at these
locations.
</p>
<p>The marks are allowed to be a data frame.
Then the smoothing procedure is applied to each column of marks. 
</p>
<p>The numerator and denominator are computed by <code><a href="#topic+density.lpp">density.lpp</a></code>.
The arguments <code>...</code> control the smoothing kernel parameters.
</p>
<p>The optional argument <code>weights</code> allows numerical weights to
be applied to the data. If a weight <code class="reqn">w_i</code>
is associated with location <code class="reqn">x_i</code>, then the smoothed
function is 
(ignoring edge corrections)
</p>
<p style="text-align: center;"><code class="reqn">
    g(u) = \frac{\sum_i k(u, x_i) v_i w_i}{\sum_i k(u, x_i) w_i}
  </code>
</p>



<h3>Value</h3>

<p><em>If <code>X</code> has a single column of marks:</em>
</p>

<ul>
<li> 
<p>If <code>at="pixels"</code> (the default), the result is
a pixel image on the network (object of class <code>"linim"</code>). 
Pixel values are values of the interpolated function.
</p>
</li>
<li>
<p>If <code>at="points"</code>, the result is a numeric vector
of length equal to the number of points in <code>X</code>.
Entries are values of the interpolated function at the points of <code>X</code>.
</p>
</li></ul>

<p><em>If <code>X</code> has a data frame of marks:</em>
</p>

<ul>
<li> 
<p>If <code>at="pixels"</code> (the default), the result is a named list of 
pixel images on the network (objects of class <code>"linim"</code>). There is one
image for each column of marks. This list also belongs to
the class <code>"solist"</code>, for which there is a plot method.
</p>
</li>
<li>
<p>If <code>at="points"</code>, the result is a data frame
with one row for each point of <code>X</code>,
and one column for each column of marks. 
Entries are values of the interpolated function at the points of <code>X</code>.
</p>
</li></ul>

<p>The return value has attribute
<code>"sigma"</code> which reports the smoothing
bandwidth that was used.
</p>


<h3>Very small bandwidth</h3>

<p>If the chosen bandwidth <code>sigma</code> is very small,
kernel smoothing is mathematically equivalent
to nearest-neighbour interpolation.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>References</h3>

<p>Nadaraya, E.A. (1964) On estimating regression.
<em>Theory of Probability and its Applications</em>
<b>9</b>, 141&ndash;142.
</p>
<p>Nadaraya, E.A. (1989) 
<em>Nonparametric estimation of probability densities
and regression curves</em>.
Kluwer, Dordrecht.
</p>
<p>Watson, G.S. (1964)
Smooth regression analysis.
<em>Sankhya A</em> <b>26</b>, 359&ndash;372.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.explore.html#topic+Smooth">Smooth</a></code>,
<code><a href="#topic+density.lpp">density.lpp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- spiders
  if(!interactive()) X &lt;- X[owin(c(0,1100), c(0, 500))]
  marks(X) &lt;- coords(X)$x
  plot(Smooth(X, 50))
  Smooth(X, 50, at="points")
</code></pre>

<hr>
<h2 id='spatstat.linnet-deprecated'>Deprecated spatstat.linnet functions</h2><span id='topic+circumradius.linnet'></span><span id='topic+rjitterlpp'></span><span id='topic+bw.relrisklpp'></span>

<h3>Description</h3>

<p>Deprecated spatstat.linnet functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'linnet'
circumradius(x, ...)
rjitterlpp(X, ...)
bw.relrisklpp(X, ...)
</code></pre>


<h3>Details</h3>

<p>These functions are deprecated, and will eventually be deleted from
the <span class="pkg">spatstat.linnet</span> package.
</p>
<p><code>rjitterlpp</code> is replaced by <code>rjitter.lpp</code>, a method for the
generic <code>rjitter</code>.
</p>
<p><code>circumradius.linnet</code> is replaced by the more appropriately named
<code>boundingradius.linnet</code>.
</p>
<p><code>bw.relrisklpp</code> is replaced by the method <code>bw.relrisk.lpp</code>
for the generic <code>bw.relrisk</code>.
</p>


<h3>Value</h3>

<p><code>circumradius.linnet</code> returns a numeric value.
</p>
<p><code>rjitterlpp</code> returns a point pattern on a linear network (object of
class <code>"lpp"</code>).
</p>
<p><code>bw.relrisklpp</code> returns an object of class <code>"bw.optim"</code> which
is a numeric value with additional attributes.
</p>

<hr>
<h2 id='spatstat.linnet-internal'>Internal spatstat.linnet functions</h2><span id='topic+ApplyConnected'></span><span id='topic+DoCountCrossEnds'></span><span id='topic+DoCountEnds'></span><span id='topic+FDMKERNEL'></span><span id='topic+as.linfun.linfun'></span><span id='topic+as.owin.lintess'></span><span id='topic+default.linnet.tolerance'></span><span id='topic+getglmdata.lppm'></span><span id='topic+getglmfit.lppm'></span><span id='topic+getglmsubset.lppm'></span><span id='topic+hasglmfit.lppm'></span><span id='topic+makeLinnetTolerance'></span><span id='topic+print.lintess'></span><span id='topic+print.summary.linim'></span><span id='topic+print.summary.linnet'></span><span id='topic+print.summary.lintess'></span><span id='topic+resolve.heat.steps'></span><span id='topic+rmaxEuclidean'></span><span id='topic+summary.lintess'></span><span id='topic+nobjects.lintess'></span><span id='topic+Window.lintess'></span><span id='topic+Window+3C-.linnet'></span><span id='topic+Window+3C-.lpp'></span><span id='topic+densitypointsLPP'></span><span id='topic+flatdensityfunlpp'></span><span id='topic+flatdensityatpointslpp'></span><span id='topic+local2lpp'></span><span id='topic+looHeatLPP'></span><span id='topic+looVoronoiLPP'></span><span id='topic+validate.lpp.coords'></span><span id='topic+as.ppm.lppm'></span><span id='topic+pointsAlongNetwork'></span><span id='topic+lineardiscEngine'></span><span id='topic+linearEuclidEngine'></span><span id='topic+linearKengine'></span><span id='topic+linearKmulti'></span><span id='topic+linearKmulti.inhom'></span><span id='topic+linearKmultiEngine'></span><span id='topic+linearpcfengine'></span><span id='topic+linearpcfmulti'></span><span id='topic+linearpcfmulti.inhom'></span><span id='topic+linearPCFmultiEngine'></span><span id='topic+resampleNetworkDataFrame'></span><span id='topic+resolve.lambda.lpp'></span><span id='topic+sortalongsegment'></span><span id='topic+spatialCovariateEvidence.lppm'></span><span id='topic+vnnFind'></span><span id='topic+ldtEngine'></span><span id='topic+qkdeEngine'></span><span id='topic+updateData.lppm'></span><span id='topic+Math.linimlist'></span><span id='topic+Ops.linimlist'></span><span id='topic+Summary.linimlist'></span><span id='topic+Complex.linimlist'></span><span id='topic+LinimOp'></span><span id='topic+LinimListOp'></span><span id='topic+traceTessLinnet'></span>

<h3>Description</h3>

<p>Internal spatstat.linnet functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>




ApplyConnected(X, Engine, r, ..., rule, auxdata)
DoCountEnds(X, D, toler)
DoCountCrossEnds(X, I, J, DIJ, toler)
FDMKERNEL(lppobj, dtt, dtx, M, nsave, weights,
          stepnames, setuponly, verbose)
## S3 method for class 'linfun'
as.linfun(X, ...)
## S3 method for class 'lintess'
as.owin(W, ...)
## S3 method for class 'lppm'
getglmdata(object, ...)
## S3 method for class 'lppm'
getglmfit(object, ...)
## S3 method for class 'lppm'
getglmsubset(object, ...)
## S3 method for class 'lppm'
hasglmfit(object)
default.linnet.tolerance(L)
makeLinnetTolerance(toler)
## S3 method for class 'lintess'
print(x, ...)
## S3 method for class 'summary.linim'
print(x, ...)
## S3 method for class 'summary.linnet'
print(x, ...)
## S3 method for class 'summary.lintess'
print(x, ...)
## S3 method for class 'lintess'
summary(object, ...)
## S3 method for class 'lintess'
nobjects(x)
## S3 method for class 'lintess'
Window(X, ...)
## S3 replacement method for class 'linnet'
Window(X, ..., check=TRUE) &lt;- value
## S3 replacement method for class 'lpp'
Window(X, ..., check=TRUE) &lt;- value
densitypointsLPP(x, sigma, ...,
                 weights, nsigma, leaveoneout, fast,
                 fastmethod, floored,
                 dx, dt, iterMax, verbose, debug)
flatdensityfunlpp(X, ..., disconnect, weights, what)
flatdensityatpointslpp(X, ..., leaveoneout, disconnect, weights, what)
local2lpp(L, seg, tp, X, df.only)
looHeatLPP(U0, Amatrix, npts, niter, nsave,
           lixelweight, lixelmap, verbose) 
looVoronoiLPP(X)
validate.lpp.coords(X, fatal, context)
## S3 method for class 'lppm'
as.ppm(object)
pointsAlongNetwork(L, delta)
lineardiscEngine(L, x, r, want)
linearEuclidEngine(X, fun, ..., r, reweight, denom,
                   samplesize, showworking, correction)
linearKengine(X, ..., r, reweight, denom, samplesize,
              correction, ratio, showworking)
linearKmulti(X, I, J, r, ..., correction)
linearKmulti.inhom(X, I, J, lambdaI, lambdaJ, r, ..., correction,
             normalise, sigma)
linearpcfengine(X, ..., r, reweight, denom, samplesize, correction, ratio)
linearpcfmulti(X, I, J, r, ..., correction)
linearpcfmulti.inhom(X, I, J, lambdaI, lambdaJ, r, ...,
                     correction, normalise,
                     sigma, adjust.sigma, bw, adjust.bw)
linearKmultiEngine(X, I, J, ...,
                   r, reweight, denom, samplesize, correction, showworking)
linearPCFmultiEngine(X, I, J, ...,
                   r, reweight, denom, samplesize, correction, showworking)
resampleNetworkDataFrame(df, template)
## S3 method for class 'lpp'
resolve.lambda(X, lambda, subset, ...,
       update, leaveoneout, everywhere, loo.given, sigma, lambdaname)
sortalongsegment(df)
## S3 method for class 'lppm'
spatialCovariateEvidence(model, covariate, ..., lambdatype, 
          eps, dimyx, xy, rule.eps,
          delta, nd, interpolate, jitter, jitterfactor,
          modelname, covname, dataname, subset, clip.predict)
vnnFind(seg, tp, ns, nv, from, to, seglen, huge, tol, kmax)
ldtEngine(nv, ns, from, to, seglen, huge,
          coUXord, vnndist, vnnwhich, vnnlab)
resolve.heat.steps(sigma, ..., dx, dt,
                   niter, iterMax, nsave,
                   seglengths, maxdegree, AMbound, L,
                   finespacing, fineNsplit, fineNlixels,
                   W, eps, dimyx, xy, 
                   allow.adjust, warn.adjust,
                   verbose, stepnames)
rmaxEuclidean(L, verbose, show)
qkdeEngine(x, sigma, ..., at, what,
           leaveoneout, diggle, raw, edge2D, edge,
           weights, varcov, positive, shortcut,
           precomputed, savecomputed)
## S3 method for class 'lppm'
updateData(model, X, ...)
Math(x, ...)
Ops(e1, e2)
Complex(z)
Summary(..., na.rm = FALSE)




LinimOp(e1, e2, op)
LinimListOp(e1, e2, op)
traceTessLinnet(A, L)

</code></pre>


<h3>Details</h3>

<p>These internal <span class="pkg">spatstat.linnet</span> functions should not be called
directly by the user. Their names and capabilities may change
without warning from one version of <span class="pkg">spatstat.linnet</span> to the next.
</p>


<h3>Value</h3>

<p>The return values of these functions are not documented,
and may change without warning.
</p>

<hr>
<h2 id='spatstat.linnet-package'>The spatstat.linnet Package</h2><span id='topic+spatstat.linnet-package'></span><span id='topic+spatstat.linnet'></span>

<h3>Description</h3>

<p>The <span class="pkg">spatstat.linnet</span> package
belongs to the <span class="pkg">spatstat</span> family of packages.
It contains the functionality
for analysing spatial data on a linear network.
</p>


<h3>Details</h3>

<p><span class="pkg">spatstat</span> is
a family of <span class="rlang"><b>R</b></span> packages
for the statistical analysis of spatial data.
Its main focus is the analysis of
spatial patterns of points in two-dimensional space.
</p>
<p>The original <span class="pkg">spatstat</span> package
has now been split into several
sub-packages.
</p>
<p>This sub-package <span class="pkg">spatstat.linnet</span> contains the
user-level functions from <span class="pkg">spatstat</span> 
that are concerned with spatial data on a linear network.
</p>


<h3>Structure of the spatstat family</h3>

  
<p>The orginal <span class="pkg">spatstat</span> package grew to be very large.
It has now been divided into several <b>sub-packages</b>:
</p>

<ul>
<li> <p><span class="pkg">spatstat.utils</span> containing basic utilities
</p>
</li>
<li> <p><span class="pkg">spatstat.sparse</span> containing linear algebra utilities
</p>
</li>
<li> <p><span class="pkg">spatstat.data</span> containing datasets
</p>
</li>
<li> <p><span class="pkg">spatstat.geom</span> containing geometrical objects
and geometrical operations
</p>
</li>
<li> <p><span class="pkg">spatstat.explore</span> containing the main functionality
for exploratory and non-parametric analysis of spatial data
</p>
</li>
<li> <p><span class="pkg">spatstat.model</span> containing the main functionality
for statistical modelling and inference for spatial data
</p>
</li>
<li> <p><span class="pkg">spatstat.linnet</span> containing functions for
spatial data on a linear network
</p>
</li>
<li> <p><span class="pkg">spatstat</span>, which simply loads the other sub-packages
listed above, and provides documentation.
</p>
</li></ul>

<p>When you install <span class="pkg">spatstat</span>, these sub-packages are also
installed. Then if you load the <span class="pkg">spatstat</span> package by typing
<code>library(spatstat)</code>, the other sub-packages listed above will
automatically be loaded or imported.
For an overview of all the functions available in these sub-packages,
see the help file for <span class="pkg">spatstat</span> in the <span class="pkg">spatstat</span> package,
</p>
<p>Additionally there are several <b>extension packages:</b>
</p>

<ul>
<li> <p><span class="pkg">spatstat.gui</span> for interactive graphics
</p>
</li>
<li> <p><span class="pkg">spatstat.local</span> for local likelihood
(including geographically weighted regression)
</p>
</li>
<li> <p><span class="pkg">spatstat.Knet</span> for additional, computationally efficient code
for linear networks
</p>
</li>
<li> <p><span class="pkg">spatstat.sphere</span> (under development) for spatial data
on a sphere, including spatial data on the earth's surface
</p>
</li></ul>

<p>The extension packages must be installed separately
and loaded explicitly if needed. They also have separate documentation.
</p>


<h3>Overview of <span class="pkg">spatstat.linnet</span></h3>

<p>A linear network is a subset of the two-dimensional plane
composed of straight line segments. It could represent a road network, for
example. Our code requires that, if two segments intersect each other,
then the intersection is a single point, and the intersection point is
treated as a vertex of the network.
</p>
<p>The <span class="pkg">spatstat.linnet</span> package supports spatial data analysis on
a linear network. The primary aim is to analyse spatial patterns of
points on a network. The points could represent road accidents on a
road network, for example.
</p>
<p>The <span class="pkg">spatstat.linnet</span> package provides code for handling
</p>

<ul>
<li> <p><code>linear networks</code>
</p>
</li>
<li> <p><code>point patterns on a linear network</code>
</p>
</li>
<li> <p><code>pixel images on a linear network</code> (where the network is
divided into small segments and a numerical value is assigned to each segment)
</p>
</li>
<li> <p><code>functions on a linear network</code> (i.e. functions that are
defined at every location along the network)
</p>
</li>
<li> <p><code>tessellations of a linear network</code> (where the network is
subdivided into disjoint subsets with different labels)
</p>
</li>
<li> <p><code>point process models on a linear network</code>
</p>
</li></ul>

<p>Here is a list of the main functionality
provided in <span class="pkg">spatstat.linnet</span>.
</p>
<p><b>Linear networks</b>
</p>
<p>An object of class <code>"linnet"</code> represents a linear network.
Examples of such objects include the dataset
<code><a href="spatstat.data.html#topic+simplenet">simplenet</a></code> provided in the package.
</p>
<p>Linear network objects can be created by the following functions:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+linnet">linnet</a></code> </td><td style="text-align: left;"> create a linear network </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+as.linnet">as.linnet</a></code> </td><td style="text-align: left;"> convert other data to a network </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+delaunayNetwork">delaunayNetwork</a></code> </td><td style="text-align: left;"> network of Delaunay triangulation </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+dirichletNetwork">dirichletNetwork</a></code> </td><td style="text-align: left;"> network of Dirichlet edges </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p>Utilities for manipulating networks include:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic++5B.linnet">[.linnet</a></code></td><td style="text-align: left;">  extract subset of linear network </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+clickjoin">clickjoin</a></code> </td><td style="text-align: left;"> interactively join vertices in network </td>
</tr>
<tr>
 <td style="text-align: left;">         <code><a href="#topic+joinVertices">joinVertices</a></code> </td><td style="text-align: left;"> join existing vertices in a network </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+insertVertices">insertVertices</a></code> </td><td style="text-align: left;"> insert new vertices at positions
    along network </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+addVertices">addVertices</a></code> </td><td style="text-align: left;"> add new vertices, extending a network </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+thinNetwork">thinNetwork</a></code> </td><td style="text-align: left;"> remove vertices or lines from a network </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+repairNetwork">repairNetwork</a></code> </td><td style="text-align: left;"> repair internal format </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+vertices.linnet">vertices.linnet</a></code> </td><td style="text-align: left;"> extract the vertices of network </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+terminalvertices">terminalvertices</a></code> </td><td style="text-align: left;"> find terminal vertices of
    network </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+affine.linnet">affine.linnet</a></code> </td><td style="text-align: left;"> apply affine transformation </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+shift.linnet">shift.linnet</a></code> </td><td style="text-align: left;"> apply vector translation </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rotate.linnet">rotate.linnet</a></code> </td><td style="text-align: left;"> apply rotation </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rescale.linnet">rescale.linnet</a></code> </td><td style="text-align: left;"> rescale the unit of length </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+scalardilate.linnet">scalardilate.linnet</a></code> </td><td style="text-align: left;"> physically rescale the
    network </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+diameter.linnet">diameter.linnet</a></code> </td><td style="text-align: left;"> diameter of linear  network </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+is.connected.linnet">is.connected.linnet</a></code> </td><td style="text-align: left;">  determine whether network
    is connected </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+lineardisc">lineardisc</a></code> </td><td style="text-align: left;"> compute disc of given radius in
    network </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+marks.linnet">marks.linnet</a></code> </td><td style="text-align: left;"> extract marks of a network </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+marks+3C-.linnet">marks&lt;-.linnet</a></code> </td><td style="text-align: left;"> assign marks to a network </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+plot.linnet">plot.linnet</a></code> </td><td style="text-align: left;"> plot a network </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+as.owin.linnet">as.owin.linnet</a></code> </td><td style="text-align: left;"> extract window containing network </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+as.psp.linnet">as.psp.linnet</a></code> </td><td style="text-align: left;"> extract line segments comprising
    network </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+nsegments.linnet">nsegments.linnet</a></code> </td><td style="text-align: left;"> number of segments in network</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+nvertices.linnet">nvertices.linnet</a></code> </td><td style="text-align: left;"> number of vertices in network</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+pixellate.linnet">pixellate.linnet</a></code> </td><td style="text-align: left;"> convert network to 2D pixel
    image </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+print.linnet">print.linnet</a></code> </td><td style="text-align: left;"> print basic information </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+summary.linnet">summary.linnet</a></code> </td><td style="text-align: left;"> print summary information </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+unitname.linnet">unitname.linnet</a></code> </td><td style="text-align: left;"> extract name of unit of length </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+unitname+3C-.linnet">unitname&lt;-.linnet</a></code> </td><td style="text-align: left;"> assign name of unit of length </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+vertexdegree">vertexdegree</a></code> </td><td style="text-align: left;"> number of segments meeting
    each vertex </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+volume.linnet">volume.linnet</a></code> </td><td style="text-align: left;"> total length of network </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Window.linnet">Window.linnet</a></code> </td><td style="text-align: left;"> extract window containing network </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+density.linnet">density.linnet</a></code> </td><td style="text-align: left;"> smoothed 2D spatial density of lines </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p>A network is called a tree if it has no closed loops.
The following functions support the creation and manipulation of
trees:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+begins">begins</a></code></td><td style="text-align: left;"> check start of character string</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+branchlabelfun">branchlabelfun</a></code></td><td style="text-align: left;"> tree branch membership labelling
    function </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+deletebranch">deletebranch</a></code></td><td style="text-align: left;"> delete a branch of a tree </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+extractbranch">extractbranch</a></code></td><td style="text-align: left;"> extract a branch of a tree </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+treebranchlabels">treebranchlabels</a></code></td><td style="text-align: left;"> label vertices of a tree by
    branch membership </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+treeprune">treeprune</a></code></td><td style="text-align: left;"> prune tree to given level</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p><b>Point patterns on a linear network</b>
</p>
<p>An object of class <code>"lpp"</code> represents a 
point pattern on a linear network (for example,
road accidents on a road network). 
</p>
<p>Examples of such objects include the following datasets
provided with the package:
</p>

<table>
<tr>
 <td style="text-align: left;">
      <code><a href="spatstat.data.html#topic+chicago">chicago</a></code> </td><td style="text-align: left;"> Chicago crime data </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="spatstat.data.html#topic+dendrite">dendrite</a></code> </td><td style="text-align: left;"> Dendritic spines data </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="spatstat.data.html#topic+spiders">spiders</a></code> </td><td style="text-align: left;"> Spider webs on mortar lines of brick wall 
    </td>
</tr>

</table>

<p>Point patterns on a network can be created by the following
functions:
</p>

<table>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+lpp">lpp</a></code> </td><td style="text-align: left;"> create a point pattern on a linear network </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+as.lpp">as.lpp</a></code> </td><td style="text-align: left;"> convert other data to point pattern on network </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+clicklpp">clicklpp</a></code></td><td style="text-align: left;"> interactively add points on a linear
      Network </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+crossing.linnet">crossing.linnet</a></code></td><td style="text-align: left;"> crossing points between network and other lines
    </td>
</tr>

</table>

<p>Point patterns on a network can be generated randomly
using the following functions:
</p>

<table>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+rpoislpp">rpoislpp</a></code> </td><td style="text-align: left;"> Poisson points on linear network </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+runiflpp">runiflpp</a></code> </td><td style="text-align: left;"> uniform random points on a linear network </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+rlpp">rlpp</a></code></td><td style="text-align: left;"> random points on a linear network</td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+rSwitzerlpp">rSwitzerlpp</a></code></td><td style="text-align: left;"> simulate Switzer-type point process on linear
      network </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+rThomaslpp">rThomaslpp</a></code></td><td style="text-align: left;"> simulate Thomas process on linear network </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+rcelllpp">rcelllpp</a></code></td><td style="text-align: left;">  simulate cell process on linear
      network </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+rjitter.lpp">rjitter.lpp</a></code></td><td style="text-align: left;"> randomly perturb a point pattern on
      a network </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td>
</tr>

</table>

<p>Functions for manipulating a point pattern on a network include
the following. An object of class <code>"lpp"</code> also belongs to the
class <code>"ppx"</code>, for which additional support is available.
</p>

<table>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+as.ppp.lpp">as.ppp.lpp</a></code> </td><td style="text-align: left;"> convert to 2D point pattern </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+as.psp.lpp">as.psp.lpp</a></code> </td><td style="text-align: left;"> extract line segments </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="spatstat.geom.html#topic+marks.ppx">marks.ppx</a></code> </td><td style="text-align: left;"> extract marks associated with points </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="spatstat.geom.html#topic+marks+3C-.ppx">marks&lt;-.ppx</a></code> </td><td style="text-align: left;"> assign marks to points on network </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+nsegments.lpp">nsegments.lpp</a></code> </td><td style="text-align: left;"> count number of segments </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+print.lpp">print.lpp</a></code> </td><td style="text-align: left;"> print basic information </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+summary.lpp">summary.lpp</a></code> </td><td style="text-align: left;"> print summary information </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+unitname.lpp">unitname.lpp</a></code> </td><td style="text-align: left;"> extract name of unit of length </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+unitname+3C-.lpp">unitname&lt;-.lpp</a></code> </td><td style="text-align: left;"> assign name of unit of length </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+unmark.lpp">unmark.lpp</a></code> </td><td style="text-align: left;"> remove marks </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+subset.lpp">subset.lpp</a></code> </td><td style="text-align: left;"> subset of points satisfying a
      condition </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic++5B.lpp">[.lpp</a></code> </td><td style="text-align: left;"> extract subset of point pattern</td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+Window.lpp">Window.lpp</a></code> </td><td style="text-align: left;"> extract window containing network </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+as.owin.lpp">as.owin.lpp</a></code> </td><td style="text-align: left;"> extract window containing network </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+affine.lpp">affine.lpp</a></code> </td><td style="text-align: left;"> apply affine transformation </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+shift.lpp">shift.lpp</a></code> </td><td style="text-align: left;"> apply vector translation </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+rotate.lpp">rotate.lpp</a></code> </td><td style="text-align: left;"> apply rotation </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+rescale.lpp">rescale.lpp</a></code> </td><td style="text-align: left;"> rescale the unit of length </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+scalardilate.lpp">scalardilate.lpp</a></code> </td><td style="text-align: left;"> physically rescale the
      network and points </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+connected.lpp">connected.lpp</a></code></td><td style="text-align: left;"> find connected components of point
      pattern on network </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+cut.lpp">cut.lpp</a></code></td><td style="text-align: left;"> classify points in a Point Pattern on a
      Network </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+distfun.lpp">distfun.lpp</a></code></td><td style="text-align: left;"> distance map (function) </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+distmap.lpp">distmap.lpp</a></code></td><td style="text-align: left;"> distance map (image) </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+domain.lpp">domain.lpp</a></code></td><td style="text-align: left;">  extract the linear network </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+identify.lpp">identify.lpp</a></code></td><td style="text-align: left;"> interactively identify points </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+is.multitype.lpp">is.multitype.lpp</a></code></td><td style="text-align: left;"> recognize whether point pattern is
      multitype</td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+nncross.lpp">nncross.lpp</a></code></td><td style="text-align: left;"> nearest neighbours</td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+nndist.lpp">nndist.lpp</a></code></td><td style="text-align: left;">  nearest neighbour distances </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+nnfromvertex">nnfromvertex</a></code></td><td style="text-align: left;"> nearest data point from each vertex</td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+nnfun.lpp">nnfun.lpp</a></code></td><td style="text-align: left;">  nearest neighbour map </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+nnwhich.lpp">nnwhich.lpp</a></code></td><td style="text-align: left;">  identify nearest neighbours </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+pairdist.lpp">pairdist.lpp</a></code></td><td style="text-align: left;"> pairwise shortest-path distances </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+plot.lpp">plot.lpp</a></code></td><td style="text-align: left;"> plot point pattern on linear Network </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+points.lpp">points.lpp</a></code></td><td style="text-align: left;"> draw points on existing plot </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+superimpose.lpp">superimpose.lpp</a></code></td><td style="text-align: left;">  superimpose several point
      patterns </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+text.lpp">text.lpp</a></code> </td><td style="text-align: left;"> add text labels  </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+unstack.lpp">unstack.lpp</a></code></td><td style="text-align: left;"> separate multiple columns of marks </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td>
</tr>

</table>

<p><b>Pixel images on a network</b>
</p>
<p>An object of class <code>"linim"</code> represents a pixel image
on a linear network. Effectively, the network is divided into small
segments (lixels) and each small segment is assigned a value,
which could be numeric, factor, logical or complex values.
</p>
<p>Pixel images on a network can be created using the following
functions:
</p>

<table>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+linim">linim</a></code></td><td style="text-align: left;"> create pixel image on linear network</td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+as.linim">as.linim</a></code></td><td style="text-align: left;"> convert other data to pixel image on network</td>
</tr>
<tr>
 <td style="text-align: left;">
    </td>
</tr>

</table>

<p>Functions for manipulating a pixel image on a network include:
</p>

<table>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic++5B.linim">[.linim</a></code> </td><td style="text-align: left;"> extract subset of pixel image on linear network</td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic++5B+3C-.linim">[&lt;-.linim</a></code> </td><td style="text-align: left;"> reset values in subset of image on linear network</td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+Math.linim">Math.linim</a></code></td><td style="text-align: left;"> S3 group generic methods for images on a linear network</td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+eval.linim">eval.linim</a></code></td><td style="text-align: left;"> evaluate expression involving pixel images on
      linear network</td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+as.linnet.linim">as.linnet.linim</a></code> </td><td style="text-align: left;"> extract linear network </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+integral.linim">integral.linim</a></code></td><td style="text-align: left;"> integral of pixel image on a linear network</td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+mean.linim">mean.linim</a></code> </td><td style="text-align: left;"> mean of pixel values </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+median.linim">median.linim</a></code> </td><td style="text-align: left;"> median of pixel values </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+quantile.linim">quantile.linim</a></code> </td><td style="text-align: left;"> quantiles of pixel values </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+as.data.frame.linim">as.data.frame.linim</a></code> </td><td style="text-align: left;"> convert to data frame </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+print.linim">print.linim</a></code> </td><td style="text-align: left;"> print basic information </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+summary.linim">summary.linim</a></code> </td><td style="text-align: left;"> print summary information </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+affine.linim">affine.linim</a></code> </td><td style="text-align: left;"> apply affine transformation </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+scalardilate.linim">scalardilate.linim</a></code> </td><td style="text-align: left;"> apply scalar dilation </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+shift.linim">shift.linim</a></code> </td><td style="text-align: left;"> apply vector translation </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+pairs.linim">pairs.linim</a></code> </td><td style="text-align: left;"> scatterplot matrix for images </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+persp.linim">persp.linim</a></code></td><td style="text-align: left;"> perspective view of pixel image on network</td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+plot.linim">plot.linim</a></code></td><td style="text-align: left;"> plot pixel image on linear network</td>
</tr>
<tr>
 <td style="text-align: left;">
    </td>
</tr>

</table>

<p><b>Functions on a linear network</b>
</p>
<p>An object of class <code>"linfun"</code> represents a function defined
at any location along the network. Objects of this class are created
by the following functions:
</p>

<table>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+linfun">linfun</a></code></td><td style="text-align: left;"> create function on a linear network </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+as.linfun">as.linfun</a></code></td><td style="text-align: left;"> convert other data to function on network </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td>
</tr>

</table>

<p>The following supporting code is available:
</p>

<table>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+print.linfun">print.linfun</a></code> </td><td style="text-align: left;"> print basic information </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+summary.linfun">summary.linfun</a></code> </td><td style="text-align: left;"> print summary information </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+plot.linfun">plot.linfun</a></code> </td><td style="text-align: left;"> plot function on network </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+persp.linfun">persp.linfun</a></code></td><td style="text-align: left;"> perspective view of function on network</td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+as.data.frame.linfun">as.data.frame.linfun</a></code> </td><td style="text-align: left;"> convert to data frame </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+as.owin.linfun">as.owin.linfun</a></code> </td><td style="text-align: left;"> extract window containing
      network </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+as.function.linfun">as.function.linfun</a></code> </td><td style="text-align: left;"> convert to ordinary <span class="rlang"><b>R</b></span>
      function </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td>
</tr>

</table>

<p><b>Tessellations of a linear network</b>
</p>
<p>An object of class <code>"lintess"</code> represents a tessellation of the
network, that is, a subdivision of the network into disjoint subsets
called &lsquo;tiles&rsquo;. Objects of this class are created
by the following functions:
</p>

<table>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+lintess">lintess</a></code></td><td style="text-align: left;"> create tessellation of network </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+chop.linnet">chop.linnet</a></code> </td><td style="text-align: left;"> divide a linear network into tiles using
      infinite lines </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+divide.linnet">divide.linnet</a></code></td><td style="text-align: left;">  divide linear network at cut
      points </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+lineardirichlet">lineardirichlet</a></code></td><td style="text-align: left;"> Dirichlet tessellation on a linear network</td>
</tr>
<tr>
 <td style="text-align: left;">
    </td>
</tr>

</table>

<p>The following functions are provided for manipulating a tessellation
on a network:
</p>

<table>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+as.data.frame.lintess">as.data.frame.lintess</a></code></td><td style="text-align: left;"> convert to data frame </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+intersect.lintess">intersect.lintess</a></code></td><td style="text-align: left;"> intersection of two
      tessellations on network </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+lineartileindex">lineartileindex</a></code></td><td style="text-align: left;"> determine which tile contains each
      given point on network </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+marks.lintess">marks.lintess</a></code></td><td style="text-align: left;"> extract marks of each tile </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+marks+3C-.lintess">marks&lt;-.lintess</a></code></td><td style="text-align: left;"> assign marks to each tile </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+plot.lintess">plot.lintess</a></code></td><td style="text-align: left;"> plot tessellation on network </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+tile.lengths">tile.lengths</a></code></td><td style="text-align: left;"> compute lengths of tiles </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+tilenames.lintess">tilenames.lintess</a></code></td><td style="text-align: left;">  names of tiles </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code><a href="#topic+as.linfun.lintess">as.linfun.lintess</a></code></td><td style="text-align: left;"> convert tessellation to a
      function </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td>
</tr>

</table>

<p><b>Smoothing a point pattern on a linear network:</b>
</p>
<p>Given a point pattern dataset on a linear network, it is often
desired to estimate the spatially-varying density or intensity
of points along the network. For example if the points represent
road accidents, then we may wish to estimate the spatially-varying
density of accidents per unit length (over a given period of time).
</p>
<p>Related tasks include estimation of relative risk, and smoothing of
of values observed at the data points.
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+density.lpp">density.lpp</a></code></td><td style="text-align: left;"> kernel estimate of intensity</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+densityEqualSplit">densityEqualSplit</a></code></td><td style="text-align: left;"> kernel estimate of intensity
    using equal-split algorithm </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+densityHeat.lpp">densityHeat.lpp</a></code></td><td style="text-align: left;"> kernel estimate of intensity using heat equation</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+densityQuick.lpp">densityQuick.lpp</a></code></td><td style="text-align: left;"> kernel estimate of intensity using a 2D kernel</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+densityVoronoi.lpp">densityVoronoi.lpp</a></code></td><td style="text-align: left;"> intensity estimate using
    Voronoi-Dirichlet Tessellation</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+densityfun.lpp">densityfun.lpp</a></code></td><td style="text-align: left;"> kernel estimate of intensity as a
    function </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+bw.lppl">bw.lppl</a></code></td><td style="text-align: left;"> Bandwidth selection for kernel estimate of
    intensity </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+bw.voronoi">bw.voronoi</a></code></td><td style="text-align: left;"> bandwidth selection for Voronoi estimator </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+relrisk.lpp">relrisk.lpp</a></code></td><td style="text-align: left;"> kernel estimate of relative risk</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+bw.relrisk.lpp">bw.relrisk.lpp</a></code></td><td style="text-align: left;">  Bandwidth selection for relative
    risk </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Smooth.lpp">Smooth.lpp</a></code></td><td style="text-align: left;"> spatial smoothing of observations at
    points </td>
</tr>
<tr>
 <td style="text-align: left;">

  </td>
</tr>

</table>

<p><b>Exploration of dependence on a covariate:</b>
</p>
<p>Another task is to investigate how the spatially-varying intensity
of points depends on an explanatory variable (covariate). The
covariate may be given as a pixel image on the network
(class <code>"linim"</code>) or
as a function on the network (class <code>"linfun"</code>).
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rhohat.lpp">rhohat.lpp</a></code></td><td style="text-align: left;"> nonparametric estimate of intensity as function
    of a covariate</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+roc.lpp">roc.lpp</a></code></td><td style="text-align: left;"> Receiver Operating Characteristic for data on a
    network</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+auc.lpp">auc.lpp</a></code></td><td style="text-align: left;">  Area Under ROC Curve for data on a network</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+cdf.test.lpp">cdf.test.lpp</a></code></td><td style="text-align: left;"> spatial distribution test for points on a
    linear network</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+berman.test.lpp">berman.test.lpp</a></code></td><td style="text-align: left;"> Berman's tests for point pattern
    on a network </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+sdr.lpp">sdr.lpp</a></code></td><td style="text-align: left;"> Sufficient Dimension Reduction for a point
    pattern on a linear network</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p><b>Summary statistics for a point pattern on a linear network:</b>
</p>
<p>These are for point patterns on a linear network (class <code>lpp</code>).
For unmarked patterns:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+linearK">linearK</a></code> </td><td style="text-align: left;">
    <code class="reqn">K</code> function on linear network </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+linearKinhom">linearKinhom</a></code> </td><td style="text-align: left;">
    inhomogeneous <code class="reqn">K</code> function on linear network </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+linearpcf">linearpcf</a></code> </td><td style="text-align: left;">
    pair correlation function on linear network </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+linearpcfinhom">linearpcfinhom</a></code> </td><td style="text-align: left;">
    inhomogeneous pair correlation on linear network</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+linearJinhom">linearJinhom</a></code> </td><td style="text-align: left;">
    inhomogeneous <code class="reqn">J</code> function on linear network </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+linearKEuclid">linearKEuclid</a></code> </td><td style="text-align: left;">
    <code class="reqn">K</code> function on linear network using Euclidean distance </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+linearKEuclidInhom">linearKEuclidInhom</a></code> </td><td style="text-align: left;">
    inhomogeneous <code class="reqn">K</code> function on linear network using Euclidean distance</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+linearpcfEuclid">linearpcfEuclid</a></code> </td><td style="text-align: left;">
    pair correlation function on linear network using Euclidean distance </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+linearpcfEuclidInhom">linearpcfEuclidInhom</a></code> </td><td style="text-align: left;">
    inhomogeneous pair correlation on linear network using Euclidean
    distance </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p>For multitype patterns:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+linearKcross">linearKcross</a></code> </td><td style="text-align: left;">
    <code class="reqn">K</code> function between two types of points </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+linearKdot">linearKdot</a></code> </td><td style="text-align: left;">
    <code class="reqn">K</code> function from one type to any type </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+linearKcross.inhom">linearKcross.inhom</a></code> </td><td style="text-align: left;">
    Inhomogeneous version of <code><a href="#topic+linearKcross">linearKcross</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+linearKdot.inhom">linearKdot.inhom</a></code> </td><td style="text-align: left;">
    Inhomogeneous version of <code><a href="#topic+linearKdot">linearKdot</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+linearmarkconnect">linearmarkconnect</a></code> </td><td style="text-align: left;">
    Mark connection function  on linear network </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+linearmarkequal">linearmarkequal</a></code> </td><td style="text-align: left;">
    Mark equality function on linear network </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+linearpcfcross">linearpcfcross</a></code> </td><td style="text-align: left;">
    Pair correlation between two types of points </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+linearpcfdot">linearpcfdot</a></code> </td><td style="text-align: left;">
    Pair correlation from one type to any type </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+linearpcfcross.inhom">linearpcfcross.inhom</a></code> </td><td style="text-align: left;">
    Inhomogeneous version of <code><a href="#topic+linearpcfcross">linearpcfcross</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+linearpcfdot.inhom">linearpcfdot.inhom</a></code> </td><td style="text-align: left;">
    Inhomogeneous version of <code><a href="#topic+linearpcfdot">linearpcfdot</a></code> 
  </td>
</tr>

</table>

<p>Related facilities:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+pairdist.lpp">pairdist.lpp</a></code> </td><td style="text-align: left;"> distances between pairs  </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+crossdist.lpp">crossdist.lpp</a></code> </td><td style="text-align: left;"> distances between pairs </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+nndist.lpp">nndist.lpp</a></code> </td><td style="text-align: left;"> nearest neighbour distances  </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+nncross.lpp">nncross.lpp</a></code> </td><td style="text-align: left;"> nearest neighbour distances  </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+nnwhich.lpp">nnwhich.lpp</a></code> </td><td style="text-align: left;"> find nearest neighbours  </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+nnfun.lpp">nnfun.lpp</a></code> </td><td style="text-align: left;"> find nearest data point  </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+density.lpp">density.lpp</a></code> </td><td style="text-align: left;"> kernel smoothing estimator of intensity  </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+distfun.lpp">distfun.lpp</a></code> </td><td style="text-align: left;"> distance transform  </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+envelope.lpp">envelope.lpp</a></code> </td><td style="text-align: left;"> simulation envelopes  </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rpoislpp">rpoislpp</a></code> </td><td style="text-align: left;"> simulate Poisson points on linear network </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+runiflpp">runiflpp</a></code> </td><td style="text-align: left;"> simulate random points on a linear network 
  </td>
</tr>

</table>

<p>It is also possible to fit point process models to <code>lpp</code> objects.
</p>
<p><b>Point process models on a linear network:</b>
</p>
<p>An object of class <code>"lpp"</code> represents a pattern of points on
a linear network. Point process models can also be fitted to these
objects. Currently only Poisson models can be fitted.
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+lppm">lppm</a></code> </td><td style="text-align: left;"> point process model on linear network </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+anova.lppm">anova.lppm</a></code> </td><td style="text-align: left;"> analysis of deviance for </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> point process model on linear network </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+envelope.lppm">envelope.lppm</a></code> </td><td style="text-align: left;"> simulation envelopes for </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> point process model on linear network </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+fitted.lppm">fitted.lppm</a></code> </td><td style="text-align: left;"> fitted intensity values </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+predict.lppm">predict.lppm</a></code> </td><td style="text-align: left;"> model prediction on linear network </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+data.lppm">data.lppm</a></code> </td><td style="text-align: left;"> extract original data </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+berman.test.lppm">berman.test.lppm</a></code> </td><td style="text-align: left;"> Berman's tests of
    goodness-of-fit </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+is.marked.lppm">is.marked.lppm</a></code></td><td style="text-align: left;"> Recognise whether model is marked</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+is.multitype.lppm">is.multitype.lppm</a></code></td><td style="text-align: left;"> Recognise whether model is multitype</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+is.stationary.lppm">is.stationary.lppm</a></code></td><td style="text-align: left;"> Recognise whether model is
    stationary </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+model.frame.lppm">model.frame.lppm</a></code></td><td style="text-align: left;"> Extract the variables in model </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+model.images.lppm">model.images.lppm</a></code></td><td style="text-align: left;"> Compute images of constructed covariates </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+model.matrix.lppm">model.matrix.lppm</a></code></td><td style="text-align: left;"> Extract design matrix </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+plot.lppm">plot.lppm</a></code></td><td style="text-align: left;"> Plot fitted point process model</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+pseudoR2.lppm">pseudoR2.lppm</a></code></td><td style="text-align: left;"> Calculate Pseudo-R-Squared for model </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+simulate.lppm">simulate.lppm</a></code></td><td style="text-align: left;"> simulate fitted point process model </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>Licence</h3>

<p>This library and its documentation are usable under the terms of the &quot;GNU 
General Public License&quot;, a copy of which is distributed with the package.
</p>


<h3>Acknowledgements</h3>

<p>Ottmar Cronie,
Tilman Davies,
Greg McSwiggan and
Suman Rakshit
made substantial contributions of code.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>

<hr>
<h2 id='subset.lpp'>
Subset of Point Pattern Satisfying A Condition
</h2><span id='topic+subset.lpp'></span>

<h3>Description</h3>

<p>Given a point pattern on a linear network,
return the subset of points which satisfy
a specified condition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpp'
subset(x, subset, select, drop=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset.lpp_+3A_x">x</code></td>
<td>

<p>A point pattern on a linear network
(object of class <code>"lpp"</code>).
</p>
</td></tr>
<tr><td><code id="subset.lpp_+3A_subset">subset</code></td>
<td>

<p>Logical expression indicating which points are to be kept.
The expression may involve the names of spatial coordinates
(<code>x</code>, <code>y</code>), network coordinates (<code>seg</code>, <code>tp</code>),
the <code>marks</code>, and
(if there is more than one column of marks)
the names of individual columns of marks.
Missing values are taken as false. See Details.
</p>
</td></tr>
<tr><td><code id="subset.lpp_+3A_select">select</code></td>
<td>

<p>Expression indicating which columns of marks should be kept.
The <em>names</em> of columns of marks can be used in this expression,
and will be treated as if they were column indices.
See Details.
</p>
</td></tr>
<tr><td><code id="subset.lpp_+3A_drop">drop</code></td>
<td>

<p>Logical value indicating whether to remove unused levels
of the marks, if the marks are a factor.
</p>
</td></tr>
<tr><td><code id="subset.lpp_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function <code><a href="base.html#topic+subset">subset</a></code>.
It extracts the subset of points of <code>x</code>
that satisfy the logical expression
<code>subset</code>, and retains only the columns of marks that are
specified by the expression <code>select</code>. The result is always a point
pattern, with the same window as <code>x</code>.
</p>
<p>The argument <code>subset</code> determines the subset of points that
will be extracted. It should be a logical expression.
It may involve the variable names
<code>x</code> and <code>y</code> representing the Cartesian coordinates;
the names of other spatial coordinates or local coordinates;
the name <code>marks</code> representing the marks;
and (if there is more than one column of marks)
the names of individual columns of marks.
The default is to keep all points.
</p>
<p>The argument <code>select</code> determines which columns of marks
will be retained (if there are several columns of marks).
It should be an expression involving the names of columns of marks
(which will be interpreted as integers representing the positions of
these columns). For example if there are columns of marks named
<code>A</code> to <code>Z</code>, then <code>select=D:F</code> is a valid expression
and means that columns <code>D</code>, <code>E</code> and <code>F</code> will be
retained. Similarly <code>select=-(A:C)</code> is valid and means that columns
<code>A</code> to <code>C</code> will be deleted.  
The default is to retain all columns.
</p>
<p>Setting <code>subset=FALSE</code> will produce an empty point pattern
(i.e. containing zero points) in the same window as <code>x</code>.
Setting <code>select=FALSE</code> or <code>select= -marks</code> will
remove all the marks from <code>x</code>.
</p>
<p>The argument <code>drop</code> determines whether to remove
unused levels of a factor, if the resulting point pattern is multitype
(i.e. the marks are a factor) or if the marks are a data frame
in which some of the columns are factors.
</p>
<p>The result is always a point pattern, of the same class as <code>x</code>.
Spatial coordinates (and local
coordinates) are always retained. To extract only some
columns of marks or coordinates as a data frame,
use <code>subset(as.data.frame(x), ...)</code>
</p>


<h3>Value</h3>

<p>A point pattern of the same class as <code>x</code>, in the same
spatial window as <code>x</code>. The result is a subset of <code>x</code>,
possibly with some columns of marks removed.
</p>


<h3>Other kinds of subset arguments</h3>

<p>Alternatively the argument <code>subset</code> can be any kind of subset index
acceptable to <code><a href="#topic++5B.lpp">[.lpp</a></code>.
This argument selects which points of <code>x</code>
will be retained.
</p>
<p><b>Warning:</b> if the argument <code>subset</code> is
a window, this is interpreted as specifying the subset of points that fall
inside that window, but the resulting point pattern has the same window
as the original pattern <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.geom.html#topic+subset.ppp">subset.ppp</a></code>,
<code><a href="#topic++5B.lpp">[.lpp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> v &lt;- subset(chicago, x + y &gt; 1100 &amp; marks == "assault")

 vv &lt;- subset(chicago, x + y &gt; 1100 &amp; marks == "assault", drop=TRUE)
</code></pre>

<hr>
<h2 id='superimpose.lpp'>Superimpose Several Point Patterns on Linear Network</h2><span id='topic+superimpose.lpp'></span>

<h3>Description</h3>

<p>Superimpose any number of point patterns on the same linear network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'lpp'
superimpose(..., L=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="superimpose.lpp_+3A_...">...</code></td>
<td>

<p>Any number of arguments, each of which represents a point
pattern on the same linear network.
Each argument can be either an object of class <code>"lpp"</code>,
giving both the spatial coordinates of the points and the
linear network, or a <code>list(x,y)</code> or <code>list(x,y,seg,tp)</code>
giving just the spatial coordinates of the points.
</p>
</td></tr>
<tr><td><code id="superimpose.lpp_+3A_l">L</code></td>
<td>

<p>Optional. The linear network.
An object of class <code>"linnet"</code>.
This argument is required if none of the other arguments
is of class <code>"lpp"</code>. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to superimpose several point patterns
on the same linear network. It is a method for the generic
function <code><a href="spatstat.geom.html#topic+superimpose">superimpose</a></code>.
</p>
<p>Each of the arguments <code>...</code>
can be either a point pattern on a linear network
(object of class <code>"lpp"</code> 
giving both the spatial coordinates of the points and the
linear network), or a <code>list(x,y)</code> or <code>list(x,y,seg,tp)</code>
giving just the spatial coordinates of the points.
These arguments must represent point patterns on the <em>same</em>
linear network.
</p>
<p>The argument <code>L</code> is an alternative way to specify the linear
network, and is required if none of the arguments <code>...</code> is an
object of class <code>"lpp"</code>.
</p>
<p>The arguments <code>...</code> may be <em>marked</em> patterns.
The marks of each component pattern must have the same format.
Numeric and character marks may be &ldquo;mixed&rdquo;.  If there is such
mixing then the numeric marks are coerced to character in the
combining process. If the mark structures are all data frames,
then these data frames must have the same number of columns and
identical column names.
</p>
<p>If the arguments <code>...</code> are given in the form <code>name=value</code>,
then the <code>name</code>s will be used as an extra column of marks
attached to the elements of the corresponding patterns.
</p>


<h3>Value</h3>

<p>An object of class <code>"lpp"</code> representing the combined point
pattern on the linear network.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
</p>
<p>Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a>
</p>
<p>Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>
<p>and Greg McSwiggan.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.geom.html#topic+superimpose">superimpose</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- rpoislpp(5, simplenet)
  Y &lt;- rpoislpp(10, simplenet)
  superimpose(X,Y) # not marked
  superimpose(A=X, B=Y) # multitype with types A and B
</code></pre>

<hr>
<h2 id='terminalvertices'>Terminal Vertices of a Linear Network</h2><span id='topic+terminalvertices'></span>

<h3>Description</h3>

<p>Finds the terminal vertices of a linear network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> terminalvertices(L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="terminalvertices_+3A_l">L</code></td>
<td>
<p>A linear network (object of class <code>"linnet"</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given the linear network <code>L</code>, this function
examines the vertices (segment endpoints) of the network
and determines which of them are &lsquo;terminal&rsquo; vertices
(i.e. the endpoint of only one segment). These terminal vertices
are returned as a point pattern on the network.
</p>


<h3>Value</h3>

<p>A point pattern on the same linear network
(object of class <code>"lpp"</code>).
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a> and Mehdi Moradi <a href="mailto:m2.moradi@yahoo.com">m2.moradi@yahoo.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vertices.linnet">vertices.linnet</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  B &lt;- terminalvertices(simplenet)
  plot(simplenet, main="")
  plot(B, add=TRUE, pch=16, cex=2)
</code></pre>

<hr>
<h2 id='text.lpp'>
Add Text Labels to Point Pattern on a Network
</h2><span id='topic+text.lpp'></span>

<h3>Description</h3>

<p>Plots a text label at the location of each point,
for a point pattern on a linear network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpp'
text(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text.lpp_+3A_x">x</code></td>
<td>

<p>A point pattern on a linear network (class <code>"lpp"</code>).
</p>
</td></tr>
<tr><td><code id="text.lpp_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to <code><a href="graphics.html#topic+text.default">text.default</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a method for the generic <code><a href="graphics.html#topic+text">text</a></code>.
A text label is added to the existing plot,
at the location of each point in the point pattern <code>x</code>,
or near the location of the midpoint of each segment
in the segment pattern <code>x</code>.
</p>
<p>Additional arguments <code>...</code> are passed to
<code><a href="graphics.html#topic+text.default">text.default</a></code> and may be used to control the
placement of the labels relative to the point locations, and
the size and colour of the labels.
</p>
<p>By default, the labels are the serial numbers 1 to <code>n</code>, where
<code>n</code> is the number of points or segments in <code>x</code>. This can
be changed by specifying the argument <code>labels</code>, which should be
a vector of length <code>n</code>.
</p>


<h3>Value</h3>

<p>Null.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+text.default">text.default</a></code>,
<code><a href="spatstat.geom.html#topic+text.ppp">text.ppp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- runiflpp(5, simplenet)
  plot(X)
  text(X, pos=2, col="blue")
</code></pre>

<hr>
<h2 id='thinNetwork'>
Remove Vertices or Segments from a Linear Network
</h2><span id='topic+thinNetwork'></span>

<h3>Description</h3>

<p>Delete some vertices and/or segments from a linear network
or related object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thinNetwork(X, retainvertices, retainedges)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thinNetwork_+3A_x">X</code></td>
<td>

<p>A linear network (object of class <code>"linnet"</code>),
or a point pattern on a linear network (object of class
<code>"lpp"</code>).
</p>
</td></tr>
<tr><td><code id="thinNetwork_+3A_retainvertices">retainvertices</code></td>
<td>

<p>Optional. Subset index specifying which vertices should be retained
(not deleted). 
</p>
</td></tr>
<tr><td><code id="thinNetwork_+3A_retainedges">retainedges</code></td>
<td>

<p>Optional. Subset index specifying which edges (segments) should be retained
(not deleted). 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function deletes some of the vertices and edges (segments) in the
linear network.
</p>
<p>The arguments <code>retainvertices</code> and <code>retainedges</code> can be
any kind of subset index: a vector of positive integers specifying which
vertices/edges should be retained; a vector of negative integers
specifying which vertices/edges should be deleted; or a logical vector
specifying whether each vertex/edge should be retained (<code>TRUE</code>)
or deleted (<code>FALSE</code>).
</p>
<p>Vertices are indexed in the same sequence as in
<code>vertices(as.linnet(X))</code>.
Segments are indexed in the same sequence as in
<code>as.psp(as.linnet(X))</code>.
</p>
<p>The argument <code>retainedges</code> has higher precedence than
<code>retainvertices</code> in the sense that:
</p>

<ul>
<li><p> If <code>retainedges</code> is given, then
any vertex which is an endpoint of a retained edge will also be
retained.
</p>
</li>
<li>
<p>If <code>retainvertices</code> is given and <code>retainedges</code> is <b>missing</b>,
then any segment joining two retained vertices will also be retained.
</p>
</li>
<li>
<p>Thus, when both <code>retainvertices</code> and <code>retainedges</code> are
given, it is possible that more vertices will be retained than those
specified by <code>retainvertices</code>.
</p>
</li></ul>

<p>After the network has been altered, other consequential changes will
occur, including renumbering of the segments and vertices.
If <code>X</code> is a point pattern on a linear network, then data points
will be deleted if they lie on a deleted edge.
</p>


<h3>Value</h3>

<p>An object of the same kind as <code>X</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>
and Suman Rakshit.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linnet">linnet</a></code> to make a network;
</p>
<p><code><a href="#topic+connected.linnet">connected.linnet</a></code> to extract connected components.
</p>
<p><code><a href="#topic+repairNetwork">repairNetwork</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   L &lt;- simplenet
   plot(L, main="thinNetwork(L, retainedges=c(-3, -5))")
   text(midpoints.psp(as.psp(L)), labels=1:nsegments(L), pos=3)
   Lsub &lt;- thinNetwork(L, retainedges=c(-3, -5))
   plot(Lsub, add=TRUE, col="blue", lwd=2)
</code></pre>

<hr>
<h2 id='tile.lengths'>Compute Lengths of Tiles in a Tessellation on a Network</h2><span id='topic+tile.lengths'></span>

<h3>Description</h3>

<p>Computes the length of each tile in a tessellation on a linear network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tile.lengths(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tile.lengths_+3A_x">x</code></td>
<td>
<p>A tessellation on a linear network
(object of class <code>"lintess"</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tessellation on a linear network <code>L</code> is a partition of the
network into non-overlapping pieces (tiles). Each tile consists of one
or more line segments which are subsets of the line segments making up
the network. A tile can consist of several disjoint pieces.
</p>
<p>This command computes the length of each of the tiles 
that make up the tessellation <code>x</code>.
The result is a numeric vector.
</p>


<h3>Value</h3>

<p>A numeric vector.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lintess">lintess</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- runiflpp(5, simplenet)
  A &lt;- lineardirichlet(X)
  plot(A)
  tile.lengths(A)
</code></pre>

<hr>
<h2 id='tilenames.lintess'>Names of Tiles in a Tessellation on a Network</h2><span id='topic+tilenames.lintess'></span><span id='topic+tilenames+3C-.lintess'></span>

<h3>Description</h3>

<p>Extract or Change the Names of the Tiles in a Tessellation on a Network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lintess'
tilenames(x)

## S3 replacement method for class 'lintess'
tilenames(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tilenames.lintess_+3A_x">x</code></td>
<td>

<p>A tessellation 
on a linear network (object of class <code>"lintess"</code>).
</p>
</td></tr>
<tr><td><code id="tilenames.lintess_+3A_value">value</code></td>
<td>
<p>Character vector giving new names for the tiles.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions extract or change the names of the 
tiles that make up the tessellation <code>x</code>.
</p>
<p>If the tessellation is a regular grid, the tile names
cannot be changed.
</p>


<h3>Value</h3>

<p><code>tilenames</code> returns a character vector.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lintess">lintess</a></code>,
<code><a href="spatstat.geom.html#topic+tiles">tiles</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  B &lt;- lineardirichlet(runiflpp(5, simplenet))
  tilenames(B)
  tilenames(B) &lt;- letters[1:5]
</code></pre>

<hr>
<h2 id='treebranchlabels'>
Label Vertices of a Tree by Branch Membership
</h2><span id='topic+treebranchlabels'></span>

<h3>Description</h3>

<p>Given a linear network which is a tree (acyclic graph),
this function assigns a label to each vertex, indicating
its position in the tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  treebranchlabels(L, root = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="treebranchlabels_+3A_l">L</code></td>
<td>

<p>Linear network (object of class <code>"linnet"</code>).
The network must have no loops.
</p>
</td></tr>
<tr><td><code id="treebranchlabels_+3A_root">root</code></td>
<td>

<p>Root of the tree. An integer index identifying
which point in <code>vertices(L)</code> is the root of the tree.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The network <code>L</code> should be a tree, that is, it must have no loops.
</p>
<p>This function computes a character string label for each vertex
of the network <code>L</code>. The vertex identified by <code>root</code>
(that is, <code>vertices(L)[root]</code>) is taken as the root of the tree
and is given the empty label <code>""</code>.
</p>

<ul>
<li><p> If there are several line
segments which meet at the root vertex, each of these segments is the
start of a new branch of the tree; the other endpoints of these
segments are assigned the labels 
<code>"a"</code>, <code>"b"</code>, <code>"c"</code> and so on.
</p>
</li>
<li><p> If only one segment issues from the root vertex,
the other endpoint of this segment is assigned the empty label
<code>""</code>.
</p>
</li></ul>

<p>A similar rule is then applied to each of the newly-labelled vertices.
If the vertex labelled <code>"a"</code> is joined to two other unlabelled
vertices, these will be labelled <code>"aa"</code> and <code>"ab"</code>.
The rule is applied recursively until all vertices have been labelled.
</p>
<p>If <code>L</code> is not a tree, the algorithm will terminate, but the
results will be nonsense.
</p>


<h3>Value</h3>

<p>A vector of character strings, with one entry for each point in
<code>vertices(L)</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+deletebranch">deletebranch</a></code>, <code><a href="#topic+extractbranch">extractbranch</a></code>,
<code><a href="#topic+treeprune">treeprune</a></code> for manipulating a network using the
branch labels.
</p>
<p><code><a href="#topic+linnet">linnet</a></code> for creating a network.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # make a simple tree
  m &lt;- simplenet$m
  m[8,10] &lt;- m[10,8] &lt;- FALSE
  L &lt;- linnet(vertices(simplenet), m)
  plot(L, main="")
  # compute branch labels 
  tb &lt;- treebranchlabels(L, 1)
  tbc &lt;- paste0("[", tb, "]")
  text(vertices(L), labels=tbc, cex=2)
</code></pre>

<hr>
<h2 id='treeprune'>
Prune Tree to Given Level
</h2><span id='topic+treeprune'></span>

<h3>Description</h3>

<p>Prune a tree by removing all the branches above a given level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>treeprune(X, root = 1, level = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="treeprune_+3A_x">X</code></td>
<td>

<p>Object of class <code>"linnet"</code> or <code>"lpp"</code>.
</p>
</td></tr>
<tr><td><code id="treeprune_+3A_root">root</code></td>
<td>

<p>Index of the root vertex amongst the vertices of <code>as.linnet(X)</code>.
</p>
</td></tr>
<tr><td><code id="treeprune_+3A_level">level</code></td>
<td>

<p>Integer specifying the level above which the tree should be pruned.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The object <code>X</code> must be either a linear network, or a derived
object such as a point pattern on a linear network. The linear network
must be an acyclic graph (i.e. must not contain any loops) so that it
can be interpreted as a tree. 
</p>
<p>This function removes all vertices
for which <code><a href="#topic+treebranchlabels">treebranchlabels</a></code> gives a
string more than <code>level</code> characters long.
</p>


<h3>Value</h3>

<p>Object of the same kind as <code>X</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+treebranchlabels">treebranchlabels</a></code> for calculating the branch labels.
</p>
<p><code><a href="#topic+deletebranch">deletebranch</a></code> for removing entire branches.
<code><a href="#topic+extractbranch">extractbranch</a></code> for extracting entire branches.
</p>
<p><code><a href="#topic+linnet">linnet</a></code> for creating networks.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # make a simple tree
  m &lt;- simplenet$m
  m[8,10] &lt;- m[10,8] &lt;- FALSE
  L &lt;- linnet(vertices(simplenet), m)
  plot(L, main="")
  # compute branch labels 
  tb &lt;- treebranchlabels(L, 1)
  tbc &lt;- paste0("[", tb, "]")
  text(vertices(L), labels=tbc, cex=2)
  # prune tree 
  tp &lt;- treeprune(L, root=1, 1)
  plot(tp, add=TRUE, col="blue", lwd=3)
</code></pre>

<hr>
<h2 id='unstack.lpp'>
Separate Multiple Columns of Marks 
</h2><span id='topic+unstack.lpp'></span><span id='topic+unstack.lintess'></span>

<h3>Description</h3>

<p>Given a spatial pattern on a network, with several columns of marks,
take one column at a time, and return a list of spatial patterns
each having only one column of marks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpp'
unstack(x, ...)

## S3 method for class 'lintess'
unstack(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unstack.lpp_+3A_x">x</code></td>
<td>

<p>A spatial point pattern
(object of class <code>"lpp"</code>)
or a tessellation on a linear network (object of class <code>"lintess"</code>).
</p>
</td></tr>
<tr><td><code id="unstack.lpp_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions defined here are methods for the generic
<code><a href="utils.html#topic+unstack">unstack</a></code>. The functions expect a spatial object
<code>x</code> which has several columns of marks; they separate the columns,
and return a list of spatial objects, each having only one column of marks.
</p>
<p>If <code>x</code> has several columns of marks (i.e. <code>marks(x)</code> is a
matrix, data frame or hyperframe with several columns),
then <code>y &lt;- unstack(x)</code> is a list of spatial objects, each of the same
kind as <code>x</code>. The <code>j</code>th entry <code>y[[j]]</code> is equivalent to
<code>x</code> except that it only includes
the <code>j</code>th column of <code>marks(x)</code>.
</p>
<p>If <code>x</code> has no marks, or has only a single column of marks,
the result is a list consisting of one entry, which is <code>x</code>.
</p>


<h3>Value</h3>

<p>A list, of class <code>"solist"</code>, whose entries are objects of the
same type as <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+unstack">unstack</a></code>
</p>
<p><code><a href="spatstat.geom.html#topic+unstack.ppp">unstack.ppp</a></code>,
<code><a href="spatstat.model.html#topic+unstack.msr">unstack.msr</a></code>.
</p>
<p>See also methods for the generic <code><a href="base.html#topic+split">split</a></code> such as
<code><a href="spatstat.geom.html#topic+split.ppx">split.ppx</a></code> which applies to <code>"lpp"</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   X &lt;- runiflpp(5, simplenet)
   marks(X) &lt;- data.frame(id=1:5, code=factor(letters[1:5]))
   unstack(X)
</code></pre>

<hr>
<h2 id='Window.lpp'>Extract Window of Spatial Object on a Network</h2><span id='topic+Window.lpp'></span><span id='topic+Window.lppm'></span>

<h3>Description</h3>

<p>Given a spatial object on a network,
these functions extract the window
in which the network is defined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'lpp'
Window(X, ...)

 ## S3 method for class 'lppm'
Window(X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Window.lpp_+3A_x">X</code></td>
<td>
<p>A spatial object.</p>
</td></tr>
<tr><td><code id="Window.lpp_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are methods for the generic function <code><a href="spatstat.geom.html#topic+Window">Window</a></code>
which extract the spatial window in which the object <code>X</code>
is defined. 
</p>
<p>For the methods defined here, <code>X</code> should be a spatial object
on a linear network (object of class <code>"lpp"</code> or <code>"lppm"</code>).
</p>


<h3>Value</h3>

<p>An object of class <code>"owin"</code>
(see <code><a href="spatstat.geom.html#topic+owin.object">owin.object</a></code>)
specifying an observation window.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>, Rolf Turner <a href="mailto:rolfturner@posteo.net">rolfturner@posteo.net</a> and Ege Rubak <a href="mailto:rubak@math.aau.dk">rubak@math.aau.dk</a>.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.geom.html#topic+Window">Window</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   Window(spiders)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
