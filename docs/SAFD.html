<!DOCTYPE html><html><head><title>Help for package SAFD</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SAFD}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bertoluzza'>
<p>Bertoluzza distance</p></a></li>
<li><a href='#btest1.mean'>
<p>One-sample bootstrap test for the mean of a FRV</p></a></li>
<li><a href='#btest2.mean'>
<p>Two-sample bootstrap test on the equality of mean of two FRVs</p></a></li>
<li><a href='#btestk.mean'>
<p>Multi-sample bootstrap test for the equality of the mean of FRVs</p></a></li>
<li><a href='#Bvar'>
<p>(Sample) Variance</p></a></li>
<li><a href='#checking'>
<p>Checking correct data format</p></a></li>
<li><a href='#checking2'>
<p>Checking correct data format  (weak version)</p></a></li>
<li><a href='#decomposer'>
<p>Decomposer</p></a></li>
<li><a href='#defuzzify'>
<p>Defuzzification</p></a></li>
<li><a href='#Fmedian'>
<p>Median of a fuzzy sample</p></a></li>
<li><a href='#generator'>
<p>Simulation of fuzzy random variables (FRV)</p></a></li>
<li><a href='#hukuhara'>
<p>Hukuhara Difference</p></a></li>
<li><a href='#Mmean'>
<p>Minkowski mean</p></a></li>
<li><a href='#Msum'>
<p>Minkowski sum</p></a></li>
<li><a href='#SAFD-package'>
<p>Statistical Analysis of Fuzzy Data</p></a></li>
<li><a href='#sc_mult'>
<p>Minkowski scalar multiplication</p></a></li>
<li><a href='#translator'>
<p>Translator</p></a></li>
<li><a href='#Trees'>
<p>Tree dataset</p></a></li>
<li><a href='#XX'>
<p>Example data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Statistical Analysis of Fuzzy Data</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-07-03</td>
</tr>
<tr>
<td>Author:</td>
<td>Wolfgang Trutschnig &lt;wolfgang@trutschnig.net&gt;, Asun Lubiano
 &lt;lubiano@uniovi.es&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Asun Lubiano
&lt;lubiano@uniovi.es&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The aim of the package is to provide some basic functions
        for doing statistics with one dimensional Fuzzy Data (in the
        form of polygonal fuzzy numbers). In particular, the package
        contains functions for the basic operations on the class of
        fuzzy numbers (sum, scalar product, mean, median, Hukuhara difference) 
        as well as for calculating (Bertoluzza) distance and sample variance. 
        Moreover a function to simulate fuzzy random variables and bootstrap tests 
        for the equality of means is included. Version 2.1 fixes some bugs
        of previous versions.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-07-03 09:57:35 UTC; Asun</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-07-03 12:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bertoluzza'>
Bertoluzza distance
</h2><span id='topic+bertoluzza'></span>

<h3>Description</h3>

<p>Given two polygonal fuzzy numbers <code>X</code>, <code>Y</code> in the correct format (testing by <code>checking</code>) the function calculates the Bertoluzza distance of <code>X</code>, <code>Y</code>. The parameter <code>theta</code> (being the weight of the spread) has to fulfill <code>theta</code>&gt;0, by default <code>theta</code>=1/3 (which corresponds to the Lebesgue measure as weighting measure on [0,1]). For detailed explanation see the papers [1] and [2] below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bertoluzza(X, Y, theta = 1/3, pic = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bertoluzza_+3A_x">X</code></td>
<td>

<p>...dataframe (polygonal fuzzy number)
</p>
</td></tr>
<tr><td><code id="bertoluzza_+3A_y">Y</code></td>
<td>

<p>...dataframe (polygonal fuzzy number)
</p>
</td></tr>
<tr><td><code id="bertoluzza_+3A_theta">theta</code></td>
<td>

<p>...numeric and &gt;0
</p>
</td></tr>
<tr><td><code id="bertoluzza_+3A_pic">pic</code></td>
<td>

<p>...numeric, if <code>pic</code>==1 <code>X</code> and <code>Y</code> are plotted, by default no plot is produced. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See examples
</p>


<h3>Value</h3>

<p>...in case <code>X</code> and <code>Y</code> are in the correct form the code returns the Bertoluzza distance, otherwise NA is returned.
</p>


<h3>Note</h3>

<p>In case you find (almost surely existing) bugs or have recommendations for improving the functions comments are welcome to the above mentioned mail addresses.
</p>


<h3>Author(s)</h3>

<p>Wolfgang Trutschnig &lt;wolfgang@trutschnig.net&gt;, Asun Lubiano &lt;lubiano@uniovi.es&gt;
</p>


<h3>References</h3>

<p>[1] Trutschnig, W., Gonzalez-Rodriguez, G., Colubi, A., Gil, M.A.: <em>A new family of metrics for compact, convex (fuzzy) sets based on a generalized concept of mid and spread</em>,  Information Sciences, 179(23), pp. 3964-3972 (2009) 
</p>
<p>[2] Bertoluzza, C., Corral, N., Salas, A.: <em>On a new class of distances between fuzzy numbers</em>, Mathware Soft Comput., 2, pp:71-84 (1995)
</p>


<h3>See Also</h3>

<p>See Also as <code><a href="#topic+checking">checking</a></code>, <code><a href="#topic+Mmean">Mmean</a></code>, <code><a href="#topic+Bvar">Bvar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Example 1:
data(XX)
X&lt;-translator(XX[[1]],50)
Y&lt;-translator(XX[[2]],50)
Z&lt;-translator(XX[[3]],50)
ZZ&lt;-list(X,Y,Z)
b&lt;-bertoluzza(X,Y,1/3,1)
b

#Example 2: example (SLLN for the FRV)
V&lt;-translator(XX[[3]],100)
YY&lt;-vector("list",length=50)
  for(i in 1:50){
   YY[[i]]&lt;-generator(V,,,)
   }
M&lt;-Mmean(YY)
head(M)
b&lt;-bertoluzza(M,V,1/3,1) 
b

#Example 3:
V&lt;-translator(XX[[3]],100)
YY&lt;-vector("list",length=1000)
  for(i in 1:1000){
   YY[[i]]&lt;-generator(V,,,)
   }
M&lt;-Mmean(YY)
head(M)
b&lt;-bertoluzza(M,V,1/3,1)  
b

#Example 4:
X&lt;-data.frame(x=c(0,1,1,2),alpha=c(0,1,1,0))
Y&lt;-data.frame(x=c(0,1,2),alpha=c(0,1,0))
b&lt;-bertoluzza(X,Y,1/3,1)
b

#Example 5:
data(Trees)
X&lt;-Mmean(Trees[[1]])
Y&lt;-Mmean(Trees[[2]])
Z&lt;-Mmean(Trees[[3]])
b1&lt;-bertoluzza(X,Y,1)
b1
b2&lt;-bertoluzza(X,Z,1)
b2
b3&lt;-bertoluzza(Y,Z,1)
b3
</code></pre>

<hr>
<h2 id='btest1.mean'>
One-sample bootstrap test for the mean of a FRV
</h2><span id='topic+btest1.mean'></span>

<h3>Description</h3>

<p>Given a sample <code>XX</code> of polygonal fuzzy numbers and a polygonal fuzzy number <code>V</code> the function first checks if each element of <code>XX</code> and <code>V</code> has the correct format and if the alpha-levels of all input fuzzy numbers coincide. In case yes, the function computes the standardized mean squared Bertoluzza-distance from the sample mean to <code>V</code> as test-statistic. Afterwards for <code>B</code> bootstrap samples the (bootstrap) statistic is calculated. The returned p-value is calculated as the portion of the obtained values of the bootstrap statistic that are greater than the value of the test-statistic. Furthermore, if <code>pic</code>=1 sample mean and <code>V</code> are plotted. For detailed explanation see papers [1] and [2] below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>btest1.mean(XX, V, theta = 1/3, B = 100, pic = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="btest1.mean_+3A_xx">XX</code></td>
<td>

<p>...list of polygonal fuzzy numbers (the functions implicitly checks the conditions). 
</p>
</td></tr>
<tr><td><code id="btest1.mean_+3A_v">V</code></td>
<td>

<p>...polygonal fuzzy number that is tested to be the mean of the FRV.
</p>
</td></tr>
<tr><td><code id="btest1.mean_+3A_theta">theta</code></td>
<td>

<p>...numeric and &gt;0, see <code>bertoluzza</code>
</p>
</td></tr>
<tr><td><code id="btest1.mean_+3A_b">B</code></td>
<td>

<p>...integer, by default <code>B</code>=1000.
</p>
</td></tr>
<tr><td><code id="btest1.mean_+3A_pic">pic</code></td>
<td>

<p>...numeric, if <code>pic</code>=1 sample mean and <code>V</code> are plotted. By default <code>pic</code>=1.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See examples
</p>


<h3>Value</h3>

<p>Given input <code>XX</code> and <code>V</code> in the correct format, the function returns the p-value of the two-sided bootstrap test that the expectation is <code>V</code>.
</p>


<h3>Note</h3>

<p>The function is quite slow.<br />
In case you find (almost surely existing) bugs or have recommendations for improving the functions comments are welcome to the above mentioned mail addresses.
</p>


<h3>Author(s)</h3>

<p>Wolfgang Trutschnig &lt;wolfgang@trutschnig.net&gt;, Asun Lubiano &lt;lubiano@uniovi.es&gt;
</p>


<h3>References</h3>

<p>[1] Colubi, A.: <em>Statistical inference about the means of fuzzy random variables: Applications to the analysis of fuzzy- and real-valued data</em>, Fuzzy Sets and Systems, 160(3), pp. 344-356 (2009)<br />
[2] Montenegro, M., Colubi, A., Casals, M.R., Gil, M.A.: <em>Asymptotic and bootstrap techniques for testing the expected value of a fuzzy random variable</em>, Metrika, 59, pp. 31-49  (2004)
</p>


<h3>See Also</h3>

<p>See Also as <code><a href="#topic+Mmean">Mmean</a></code>, <code><a href="#topic+Bvar">Bvar</a></code>, <code><a href="#topic+bertoluzza">bertoluzza</a></code>,  <code><a href="#topic+btest2.mean">btest2.mean</a></code>, <code><a href="#topic+btestk.mean">btestk.mean</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Example 1: run for bigger sample sizes:
data(XX)
V&lt;-translator(XX[[3]],50)
V2&lt;-V
SS&lt;-vector("list",length=50)
for (j in 1:50){
 SS[[j]]&lt;-generator(V2,)
 }
b&lt;-btest1.mean(SS,V2,B=10)
b

#Example 2: takes some time to run:
#data(Trees)
#V&lt;-Trees[[1]][[47]]
#b&lt;-btest1.mean(Trees[[1]],V,100)
#b
</code></pre>

<hr>
<h2 id='btest2.mean'>
Two-sample bootstrap test on the equality of mean of two FRVs
</h2><span id='topic+btest2.mean'></span>

<h3>Description</h3>

<p>Given two samples <code>XX</code> and <code>YY</code> of polygonal fuzzy numbers the function first checks if each element of <code>XX</code> and <code>YY</code> has the correct format and if the alpha-levels of all input fuzzy numbers coincide. In case yes, the function compute the test statistic described in [1] below. Before doing the resampling <code>Mmean(YY)</code> is added to each element of <code>XX</code> and vice versa. Based on these two new samples <code>B</code> values of the test statistic are calculate. The returned p-value is calculated as the portion of the obtained values of the bootstrap statistic that are greater than the value of the test-statistic. If <code>pic</code>=1 then the sample means of <code>XX</code> and <code>YY</code> are plotted, otherwise no plot is produced. For detailed explanation see the papers [1] and [2] below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>btest2.mean(XX, YY, theta = 1/3, B = 100, pic = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="btest2.mean_+3A_xx">XX</code></td>
<td>

<p>...should be a list of polygonal fuzzy numbers (the functions implicitly checks the conditions) 
</p>
</td></tr>
<tr><td><code id="btest2.mean_+3A_yy">YY</code></td>
<td>

<p>...should be a list of polygonal fuzzy numbers (the functions implicitly checks the conditions) 
</p>
</td></tr>
<tr><td><code id="btest2.mean_+3A_theta">theta</code></td>
<td>

<p>...numeric and &gt;0
</p>
</td></tr>
<tr><td><code id="btest2.mean_+3A_b">B</code></td>
<td>

<p>...integer, by default <code>B</code>=1000.
</p>
</td></tr>
<tr><td><code id="btest2.mean_+3A_pic">pic</code></td>
<td>

<p>...numeric, if <code>pic</code>=1 then the sample means of <code>XX</code> and <code>YY</code> are plotted. By default <code>pic</code>=1.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See examples
</p>


<h3>Value</h3>

<p>Given input <code>XX</code> and <code>YY</code> in the correct format, the function returns the p-value of the two-sided bootstrap test.
</p>


<h3>Note</h3>

<p>The function is quite slow.<br />
In case you find (almost surely existing) bugs or have recommendations for improving the functions comments are welcome to the above mentioned mail addresses.
</p>


<h3>Author(s)</h3>

<p>Wolfgang Trutschnig &lt;wolfgang@trutschnig.net&gt;, Asun Lubiano &lt;lubiano@uniovi.es&gt;
</p>


<h3>References</h3>

<p>[1] Colubi, A.: <em>Statistical inference about the means of fuzzy random variables: Applications to the analysis of fuzzy- and real-valued data</em>, Fuzzy Sets and Systems, 160(3), pp. 344-356 (2009) 
</p>
<p>[2] Montenegro, M., Casals, M.R., Lubiano, M.A., Gil, M.A.: <em>Two-sample hypothesis tests of means of a fuzzy random variable</em>, Information Sciences, Vol. 133(1-2), pp. 89-100 (2001)
</p>


<h3>See Also</h3>

<p>See Also as <code><a href="#topic+Mmean">Mmean</a></code>, <code><a href="#topic+Bvar">Bvar</a></code>, <code><a href="#topic+bertoluzza">bertoluzza</a></code>, <code><a href="#topic+btest1.mean">btest1.mean</a></code>, <code><a href="#topic+btestk.mean">btestk.mean</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Example 1: run for bigger B
data(XX)
X&lt;-translator(XX[[1]],20)
Y&lt;-translator(XX[[2]],20)
XX&lt;-vector("list",length=30)
for (j in 1:30){
 XX[[j]]&lt;-generator(X,)
 }
YY&lt;-vector("list",length=20)
for (j in 1:20){
 YY[[j]]&lt;-generator(Y,)
 }
b&lt;-btest2.mean(XX,YY,B=10)
b

#Example 2: takes some time in the current version:
#data(Trees)
#b&lt;-btest2.mean(Trees[[1]],Trees[[2]],50)
#b
#b&lt;-btest2.mean(Trees[[1]],Trees[[3]],50)
#b
</code></pre>

<hr>
<h2 id='btestk.mean'>
Multi-sample bootstrap test for the equality of the mean of FRVs
</h2><span id='topic+btestk.mean'></span>

<h3>Description</h3>

<p>Given a list <code>XXX</code> of length <code>k</code> sublists of polygonal fuzzy numbers the function first checks if each element of the sublists has the correct format and if the alpha-levels of all input fuzzy numbers coincide. The vector <code>sel</code> contains the numbers of the sublists the user wants to filter to. After filtering the relevant part of <code>XXX</code> the function computes the test-statistic, which compares the sum of the distances of the groups means and the overall mean with the sum of the group variances. Before doing the resampling <code>length(sel)</code> new samples are calculated by adding to each element of every fixed group the sum of all means of the other groups. Based on these <code>length(sel)</code> new samples <code>B</code> values of the (bootstrap) test statistic are calculate. The returned p-value is calculated as the portion of the obtained values of the bootstrap statistic that are greater than the value of the test-statistic. If <code>pic</code>=1 then the sample means of the via <code>sel</code> selected samples from <code>XXX</code> and the total mean are plotted, otherwise no plot is produced. For a more detailed explanation see the papers [1] and [2] below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>btestk.mean(XXX, sel, theta = 1/3, B = 100, pic = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="btestk.mean_+3A_xxx">XXX</code></td>
<td>

<p>...  A list of sublists, each of which contains polygonal fuzzy numbers
</p>
</td></tr>
<tr><td><code id="btestk.mean_+3A_sel">sel</code></td>
<td>

<p>...vector, selection of number of the samples (sublists) to be considered
</p>
</td></tr>
<tr><td><code id="btestk.mean_+3A_theta">theta</code></td>
<td>

<p>...numeric and &gt;0
</p>
</td></tr>
<tr><td><code id="btestk.mean_+3A_b">B</code></td>
<td>

<p>...integer, by default <code>B</code>=100.
</p>
</td></tr>
<tr><td><code id="btestk.mean_+3A_pic">pic</code></td>
<td>

<p>...numeric, if <code>pic</code>=1 then the sample means of the via <code>sel</code> selected samples from <code>XXX</code> and the total mean are plotted. By default <code>pic</code>=1.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See examples
</p>


<h3>Value</h3>

<p>Given input <code>XXX</code> in the correct format, the function returns the p-value of the two-sided test.
</p>


<h3>Note</h3>

<p>The function is quite slow.<br />
In case you find (almost surely existing) bugs or have recommendations for improving the functions comments are welcome to the above mentioned mail addresses.
</p>


<h3>Author(s)</h3>

<p>Wolfgang Trutschnig &lt;wolfgang@trutschnig.net&gt;, Asun Lubiano &lt;lubiano@uniovi.es&gt;
</p>


<h3>References</h3>

<p>[1] Colubi, A.: <em>Statistical inference about the means of fuzzy random variables: Applications to the analysis of fuzzy- and real-valued data</em>, Fuzzy Sets and Systems, 160(3), pp. 344-356 (2009)
</p>
<p>[2] Gil, M.A.; Montenegro, M.; Gonzalez-Rodriguez, G.; Colubi, A.; Casals, R.: <em>Bootstrap approach to the multi-sample test of means with imprecise data</em>, Computational Statistics and Data Analysis, 51(1), pp. 148-162  (2006)
</p>


<h3>See Also</h3>

<p>See Also as <code><a href="#topic+Mmean">Mmean</a></code>, <code><a href="#topic+Bvar">Bvar</a></code>, <code><a href="#topic+bertoluzza">bertoluzza</a></code>,  <code><a href="#topic+btest1.mean">btest1.mean</a></code>, <code><a href="#topic+btest2.mean">btest2.mean</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Example 1: very small B only for testing purpose
data(Trees)
sel&lt;-c(1,2,3)
b&lt;-btestk.mean(Trees,sel,B=5)
b

#Example 2: run for bigger B
#b&lt;-btestk.mean(Trees,sel,100)
#b
</code></pre>

<hr>
<h2 id='Bvar'>
(Sample) Variance
</h2><span id='topic+Bvar'></span>

<h3>Description</h3>

<p>The sample variance of a sample of polygonal fuzzy numbers with respect to the Bertoluzza distance is calculated. Given a list <code>XX</code> of polygonal fuzzy numbers the function first checks if each element of the list has the correct form and if the alpha-levels of all elements in the list coincide. If these conditions are fulfilled the Bertoluzza sample variance will be returned (i.e. the average Bertoluzza distance of the elements of <code>XX</code> to its mean). If not the <code>translator</code> function can be used to transform the elements of the list in the correct format. For details see [1] from below, and replace the kernel K with the expression induced by the Bertoluzza metric. The parameter <code>theta</code> has to fulfill <code>theta</code>&gt;0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Bvar(XX, theta = 1/3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Bvar_+3A_xx">XX</code></td>
<td>

<p>...should be a list of polygonal fuzzy numbers (the functions implicitly checks the conditions) verifying the above mentioned conditions 
</p>
</td></tr>
<tr><td><code id="Bvar_+3A_theta">theta</code></td>
<td>

<p>...numeric and &gt;0, see <code>bertoluzza</code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See examples
</p>


<h3>Value</h3>

<p>Given input <code>XX</code> in the correct format the function returns the Bertoluzza variance of the sample <code>XX</code>.
</p>


<h3>Note</h3>

<p>In case you find (almost surely existing) bugs or have recommendations for improving the functions comments are welcome to the above mentioned mail addresses.
</p>


<h3>Author(s)</h3>

<p>Wolfgang Trutschnig &lt;wolfgang@trutschnig.net&gt;, Asun Lubiano &lt;lubiano@uniovi.es&gt;
</p>


<h3>References</h3>

<p>[1] Gonzalez-Rodriguez, G.; Blanco, A.; Colubi, A.; Lubiano, M.A.: <em>Estimation of a simple linear regression model for fuzzy random variables</em>, Fuzzy Sets and Systems, 160(3), pp. 357-370 (2009)
</p>


<h3>See Also</h3>

<p>See Also as <code><a href="#topic+bertoluzza">bertoluzza</a></code>, <code><a href="#topic+Mmean">Mmean</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Example 1:
data(XX)
X&lt;-translator(XX[[1]],50)
Y&lt;-translator(XX[[2]],50)
Z&lt;-translator(XX[[3]],50)
YY&lt;-list(X,Y,Z)
A&lt;-Bvar(YY,1)
A

#Example 2:
data(XX)
v&lt;-Bvar(list(XX[[1]],XX[[1]]),1/3)
v

#Example 3:
data(Trees)
Species1_Var&lt;-Bvar(Trees$species1,1/3)
Species1_Var
Species2_Var&lt;-Bvar(Trees$species2,1/3)
Species2_Var
Species3_Var&lt;-Bvar(Trees$species3,1/3)
Species3_Var
</code></pre>

<hr>
<h2 id='checking'>
Checking correct data format 
</h2><span id='topic+checking'></span>

<h3>Description</h3>

<p>The function checks if the input data is of the correct form of a polygonal fuzzy number, i.e. a dataframe with the columns &quot;x&quot; and &quot;alpha&quot; fulfilling the following conditions: (1) alpha-values have to be in [0,1] with the minimum alpha-level being 0 and maximum being 1, (2) the x-values have to be non-missing and non-decreasing, (3) the alpha-levels have to increase from 0 to 1 and afterwards decrease from 1 to 0 in the same way (i.e. the alpha-column consists of an increasing vector from 0 to 1 plus the same vector in decreasing order). As a consequence the dataframe always has an even number of rows, see examples. The function is used internally in almost all the other functions to do a preliminary checking if the input data is of the correct form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checking(X, com = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checking_+3A_x">X</code></td>
<td>

<p>...can be any data frame.
</p>
</td></tr>
<tr><td><code id="checking_+3A_com">com</code></td>
<td>

<p>...numeric, if <code>com</code>=1 then, in case of an error, a comment is printed. By default <code>com</code>=1.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See examples
</p>


<h3>Value</h3>

<p>The function returns the value 1 if the input fulfills all conditions, if not, 0 is returned. 
</p>


<h3>Note</h3>

<p>In case you find (almost surely existing) bugs or have recommendations for improving the functions comments are welcome to the above mentioned mail addresses.
</p>


<h3>Author(s)</h3>

<p>Wolfgang Trutschnig &lt;wolfgang@trutschnig.net&gt;, Asun Lubiano &lt;lubiano@uniovi.es&gt;
</p>


<h3>See Also</h3>

<p>See Also as <code><a href="#topic+checking2">checking2</a></code>, <code><a href="#topic+translator">translator</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Example 1:
data(XX)
a&lt;-checking(XX[[1]],1)
a

#Example 2:
X&lt;-data.frame(y=c(-2,-0.75,-0.25,0.5,1),alpha=c(0,0.6,0.9,0.9,0))
a&lt;-checking(X)
a

#Example 3:
X&lt;-data.frame(x=c(-2,-0.75,-0.25,0.5,1),alpha=c(0,0.6,0.9,0.9,0))
a&lt;-checking(X)
a

#Example 4:
X&lt;-data.frame(x=c(-2,-0.75,-0.25,-0.5,1),alpha=c(0,0.6,1,1,0))
a&lt;-checking(X)
a

#Example 5:
X&lt;-data.frame(x=c(-2,-0.75,-0.25,0.5,1),alpha=c(0.3,0,1,0,0.3))
a&lt;-checking(X)
a

#Example 6:
Y&lt;-data.frame(x=c(-2,-0.75,-0.25,0.5,1),alpha=c(0,0.3,1,0,0.3))
a&lt;-checking(Y)
a

#Example 7:
Z&lt;-data.frame(x=c(-2,-0.75,-0.25,0.5,1),alpha=c(0,0.6,1,1,0))
a&lt;-checking(Z)
a

#Example 8:
U&lt;-data.frame(x=c(-1,0,1),alpha=c(0,1,0))
a&lt;-checking(U,)
a
</code></pre>

<hr>
<h2 id='checking2'>
Checking correct data format  (weak version)
</h2><span id='topic+checking2'></span>

<h3>Description</h3>

<p>The function checks if the input data defines a polygonal fuzzy number, i.e. a dataframe with the columns &quot;x&quot; and &quot;alpha&quot; fulfilling the following conditions: (1) alpha-values have to be in [0,1] with the minimum alpha-level being 0 and maximum being 1, (2) the x-values have to be non-missing and non-decreasing, (3) the alpha-levels have to increase from 0 to 1 and afterwards decrease from 1 to 0 (not necessarily in the same way). The function is only used for the <code>translator</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checking2(X, com = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checking2_+3A_x">X</code></td>
<td>

<p>...can be any data frame.
</p>
</td></tr>
<tr><td><code id="checking2_+3A_com">com</code></td>
<td>

<p>...numeric, if <code>com</code>=1 then, in case of an error, a comment is printed. By default <code>com</code>=1.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See examples
</p>


<h3>Value</h3>

<p>The function returns the value 1 if the input fulfills all conditions, if not, 0 is returned. 
</p>


<h3>Note</h3>

<p>In case you find (almost surely existing) bugs or have recommendations for improving the functions comments are welcome to the above mentioned mail addresses.
</p>


<h3>Author(s)</h3>

<p>Wolfgang Trutschnig &lt;wolfgang@trutschnig.net&gt;, Asun Lubiano &lt;lubiano@uniovi.es&gt;
</p>


<h3>See Also</h3>

<p>See Also as <code><a href="#topic+checking">checking</a></code>, <code><a href="#topic+translator">translator</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Example:
 U&lt;-data.frame(x=c(-1,0,1),alpha=c(0,1,0))
 #a&lt;-checking(U,)
 a&lt;-checking2(U,)
a
</code></pre>

<hr>
<h2 id='decomposer'>
Decomposer
</h2><span id='topic+decomposer'></span>

<h3>Description</h3>

<p>Given a dataframe <code>X</code> the function first calls <code>checking</code> in order to test if <code>X</code> is in the desired format. If yes, the dataframe <code>X</code> (polygonal fuzzy number) is expressed as a dataframe with (nrow(X)+1) rows as described in the paper [1] below, if no, NULL is returned. The main aim of <code>decomposer</code> is to provide the simulator-function called <code>generator</code> with the correct input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decomposer(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decomposer_+3A_x">X</code></td>
<td>

<p>...dataframe, if checking(X)=1 the decomposed version of <code>X</code> is returned.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See examples
</p>


<h3>Value</h3>

<p>In case checking(X)=1 <code>decomposer</code> returns a dataframe with (nrow(X+1))-rows (see [1]), otherwise NA is returned.
</p>


<h3>Note</h3>

<p>In case you find (almost surely existing) bugs or have recommendations for improving the functions comments are welcome to the above mentioned mail addresses.
</p>


<h3>Author(s)</h3>

<p>Wolfgang Trutschnig &lt;wolfgang@trutschnig.net&gt;, Asun Lubiano &lt;lubiano@uniovi.es&gt;
</p>


<h3>References</h3>

<p>[1] Gonzalez-Rodriguez, G., Colubi, A., Trutschnig, W.: 
<em>Simulation of fuzzy random variables</em>,  Inf.Sci., 179(5), pp. 642-653 (2009)
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+checking">checking</a></code>, <code><a href="#topic+generator">generator</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Example:
 data(XX)
 A&lt;-decomposer(XX[[2]])
 A&lt;-decomposer(XX[[1]])
head(A)
</code></pre>

<hr>
<h2 id='defuzzify'>
Defuzzification
</h2><span id='topic+defuzzify'></span>

<h3>Description</h3>

<p>Given a list <code>XX</code> of polygonal fuzzy numbers the function defuzzifies all elements of the list and returns the vector of Steiner points (as weighting measure the Lebesgue measure on [0,1] is used).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>defuzzify(XX)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="defuzzify_+3A_xx">XX</code></td>
<td>

<p>...should be a list of polygonal fuzzy numbers (the function implicitly checks the conditions) 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See examples
</p>


<h3>Value</h3>

<p>Given input <code>XX</code> in the correct format the function returns vector of Steiner points.
</p>


<h3>Note</h3>

<p>In case you find (almost surely existing) bugs or have recommendations for improving the functions comments are welcome to the above mentioned mail addresses.
</p>


<h3>Author(s)</h3>

<p>Wolfgang Trutschnig &lt;wolfgang@trutschnig.net&gt;, Asun Lubiano &lt;lubiano@uniovi.es&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Example:
data(XX)
V&lt;-translator(XX[[3]],50)
V2&lt;-V
V2$x&lt;-V$x/20
SS&lt;-vector("list",length=150)
for (j in 1:150){
 SS[[j]]&lt;-generator(V2,)
 }
a&lt;-defuzzify(SS)
a
</code></pre>

<hr>
<h2 id='Fmedian'>
Median of a fuzzy sample 
</h2><span id='topic+Fmedian'></span>

<h3>Description</h3>

<p>Given a list <code>XX</code> of polygonal fuzzy numbers the functions first checks (1) if each element of the lists is in the correct form (tested by <code>checking</code>) and (2) if the alpha-levels of all elements coincide. If all conditions are fulfilled the function calculates the (levelwise) median (which, by definition, is a fuzzy number too) using a large number of levels, by default <code>nl</code>=101.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Fmedian(XX, nl = 101, pic = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Fmedian_+3A_xx">XX</code></td>
<td>

<p>...list of polygonal fuzzy numbers with the same alpha levels (the functions implicitly checks the conditions)
</p>
</td></tr>
<tr><td><code id="Fmedian_+3A_nl">nl</code></td>
<td>

<p>...number of equidistant alpha-level, by default <code>nl</code>=101
</p>
</td></tr>
<tr><td><code id="Fmedian_+3A_pic">pic</code></td>
<td>

<p>...numeric, if <code>pic</code>=1 the sample, its mean and its median are plotted.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See examples.
</p>


<h3>Value</h3>

<p>Given correct input <code>XX</code> the function returns the median of the sample.
</p>


<h3>Note</h3>

<p>In case you find (almost surely existing) bugs or have recommendations for improving the functions comments are welcome to the above mentioned mail addresses.
</p>


<h3>Author(s)</h3>

<p>Wolfgang Trutschnig &lt;wolfgang@trutschnig.net&gt;, Asun Lubiano &lt;lubiano@uniovi.es&gt;
</p>


<h3>References</h3>

<p>[1] Sinova, B., Gil, M.A., Colubi, A., Van Aelst, S.: <em>The median of a random fuzzy number. The 1-norm distance approach</em>, Fuzzy Sets and Systems, 200, pp. 99-115 (2012)
</p>


<h3>See Also</h3>

<p>See Also as <code><a href="#topic+Mmean">Mmean</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Example 1:
data(XX)
V&lt;-translator(XX[[3]],100)
YY&lt;-vector("list",length=50)
  for(i in 1:50){
   YY[[i]]&lt;-generator(V,,,)
   }
Me&lt;-Fmedian(YY)

#Example 2:
data(Trees)
Species1_Median&lt;-Fmedian(Trees[[1]],nl=11)
Species1_Median
Species2_Median&lt;-Fmedian(Trees[[2]])
Species3_Median&lt;-Fmedian(Trees[[3]])
</code></pre>

<hr>
<h2 id='generator'>
Simulation of fuzzy random variables (FRV)
</h2><span id='topic+generator'></span>

<h3>Description</h3>

<p>The second procedure described in [1] is implemented. Given an input dataframe <code>V</code> in the correct format (tested by <code>checking</code>), which will be the expectation of the simulated FRV first <code>decomposer(V)</code> is called. Loosely speaking, the dataframe <code>Y</code> returned by <code>decomposer</code>, which contains the &quot;coordinates&quot; of <code>V</code> with respect to a certain &quot;basis&quot; (see [1]), is perturbated stochastically in order to generate a new polygonal fuzzy number. The distributions used for these perturbations can be selected in the call of the function, however, in this version only a few choices are possible: (1) The perturbation of the centre of the 1-cut <code>pertV</code> has to be of the form <code>norm(0,sigma)</code> or <code>unif(-a,a)</code>, sigma,a&gt;0. (2) The perturbation of the left part of the fuzzy set <code>pertL</code> has to be of the form <code>chisq(1)</code>, <code>exp(1)</code> or <code>lnorm(a,b)</code> with expectation=1. (3) The perturbation of the right part of the fuzzy set <code>pertR</code> has to be of the same form as that for the left part.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generator(V, pertV = list(dist = "norm", par = c(0, 1)), 
             pertL = list(dist = "chisq", par = c(1)), 
             pertR = list(dist = "chisq", par = c(1)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generator_+3A_v">V</code></td>
<td>

<p>...polygonal fuzzy set in the correct format (tested by <code>checking</code>)
</p>
</td></tr>
<tr><td><code id="generator_+3A_pertv">pertV</code></td>
<td>

<p>...list containing elements &quot;dist&quot; and &quot;par&quot;. &quot;dist&quot; denotes the chosen distribution family (normal or uniform) and &quot;par&quot; the corresponding parameters.
</p>
</td></tr>
<tr><td><code id="generator_+3A_pertl">pertL</code></td>
<td>

<p>...list containing elements &quot;dist&quot; and &quot;par&quot;. &quot;dist&quot; denotes the chosen distribution family (chisq or lnorm) and &quot;par&quot; the corresponding parameters.
</p>
</td></tr>
<tr><td><code id="generator_+3A_pertr">pertR</code></td>
<td>

<p>...list containing elements &quot;dist&quot; and &quot;par&quot;. &quot;dist&quot; denotes the chosen distribution family (chisq or lnorm) and &quot;par&quot; the corresponding parameters.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See examples
</p>


<h3>Value</h3>

<p>Given correct input data, the function returns a polygonal fuzzy number that can be seen as a realisation of a FRV with expectation <code>V</code> (see [1]).
</p>


<h3>Note</h3>

<p>In case you find (almost surely existing) bugs or have recommendations for improving the functions comments are welcome to the above mentioned mail addresses.
</p>


<h3>Author(s)</h3>

<p>Wolfgang Trutschnig &lt;wolfgang@trutschnig.net&gt;, Asun Lubiano &lt;lubiano@uniovi.es&gt;
</p>


<h3>References</h3>

<p>[1] Gonzalez-Rodriguez, G., Colubi, A., Trutschnig, W.: <em>Simulation of fuzzy random variables</em>,  Information Sciences, 179(5), pp. 642-653 (2009)
</p>


<h3>See Also</h3>

<p>See Also as <code><a href="#topic+decomposer">decomposer</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Example:
data(XX)
V&lt;-translator(XX[[3]],100)
YY&lt;-vector("list",length=100)
  for(i in 1:100){
   YY[[i]]&lt;-generator(V,,,)
   }
M&lt;-Mmean(YY) 
plot(M,type="l",xlim=c(-3,4))
lines(V,type="l",col="red",lwd=2)
</code></pre>

<hr>
<h2 id='hukuhara'>
Hukuhara Difference
</h2><span id='topic+hukuhara'></span>

<h3>Description</h3>

<p>Given two polygonal fuzzy numbers the functions calculates the Hukuhara difference <code>Y-X</code> if it exists. First the input data is tested for having the correct format using the function <code>checking</code>. If the Hukuhara difference exists and <code>pic</code>=1 then the input and the Hukuhara difference is plotted, otherwise no plot is produced.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hukuhara(X, Y, pic = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hukuhara_+3A_x">X</code></td>
<td>

<p>...polygonal fuzzy number (tested by <code>checking</code>)
</p>
</td></tr>
<tr><td><code id="hukuhara_+3A_y">Y</code></td>
<td>

<p>...polygonal fuzzy number (tested by <code>checking</code>)
</p>
</td></tr>
<tr><td><code id="hukuhara_+3A_pic">pic</code></td>
<td>

<p>...numeric, if <code>pic</code>=1 then <code>X</code>, <code>Y</code> and <code>Y-X</code> (if existing) is plotted
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See examples
</p>


<h3>Value</h3>

<p>In case the input data is in the correct form and the Hukuhara difference exists, the Hukuhara difference is returned, in case not, NULL is returned.
</p>


<h3>Note</h3>

<p>In case you find (almost surely existing) bugs or have recommendations for improving the functions comments are welcome to the above mentioned mail addresses.
</p>


<h3>Author(s)</h3>

<p>Wolfgang Trutschnig &lt;wolfgang@trutschnig.net&gt;, Asun Lubiano &lt;lubiano@uniovi.es&gt;
</p>


<h3>See Also</h3>

<p>See Also as <code><a href="#topic+checking">checking</a></code>, <code><a href="#topic+Msum">Msum</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Example 1:
Y&lt;-data.frame(x=c(0,0,0,1,2,2),alpha=c(0,0.5,1,1,0.5,0))
X&lt;-data.frame(x=c(0,0,0,0,1.5,2),alpha=c(0,0.5,1,1,0.5,0))
Z&lt;-data.frame(x=c(0,0,0,0.75,1.5,1.5),alpha=c(0,0.5,1,1,0.5,0))
h1&lt;-hukuhara(X,Y,1)
h1
h2&lt;-hukuhara(Z,Y,1)
h2

#Example 2: in this case the hukuhara diff has to exist by construction
data(XX)
X&lt;-translator(XX[[1]],50)
shift&lt;-seq(-1,1,length=100)
Y&lt;-X
Y$x&lt;-X$x+shift
h&lt;-hukuhara(X,Y,1)
</code></pre>

<hr>
<h2 id='Mmean'>
Minkowski mean
</h2><span id='topic+Mmean'></span>

<h3>Description</h3>

<p>Given a sample <code>XX</code> of polygonal fuzzy numbers the Minkowski-mean of the sample is calculated. The function fist calls <code>Msum</code> to check if <code>XX</code> has the correct format and, in case yes, <code>sc_mult</code> is used to calculate the Minkowski-mean of the fuzzy sample <code>XX</code>. If <code>pic</code>=1 then the sample and its mean are plotted, otherwise no plot is produced.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mmean(XX, pic = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mmean_+3A_xx">XX</code></td>
<td>

<p>...should be a list of polygonal fuzzy numbers (the functions implicitly checks the conditions) 
</p>
</td></tr>
<tr><td><code id="Mmean_+3A_pic">pic</code></td>
<td>

<p>...numeric, if <code>pic</code>=1 then the sample mean of <code>XX</code> is printed. By default <code>pic</code>=0.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See examples
</p>


<h3>Value</h3>

<p>Given input <code>XX</code> in the correct format the function returns the Minkowski mean of the polygonal fuzzy numbers contained in the list <code>XX</code>. 
</p>


<h3>Note</h3>

<p>In case you find (almost surely existing) bugs or have recommendations for improving the functions comments are welcome to the above mentioned mail addresses.
</p>


<h3>Author(s)</h3>

<p>Wolfgang Trutschnig &lt;wolfgang@trutschnig.net&gt;, Asun Lubiano &lt;lubiano@uniovi.es&gt;
</p>


<h3>See Also</h3>

<p>See Also as <code><a href="#topic+checking">checking</a></code>, <code><a href="#topic+translator">translator</a></code>, <code><a href="#topic+Msum">Msum</a></code>, <code><a href="#topic+sc_mult">sc_mult</a></code>, <code><a href="#topic+Bvar">Bvar</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Example 1:
data(XX)
A&lt;-Mmean(XX,1)

X&lt;-translator(XX[[1]],50)
Y&lt;-translator(XX[[2]],50)
Z&lt;-translator(XX[[3]],50)
YY&lt;-list(X,Y,Z)
A&lt;-Mmean(YY,pic=1)


#Example 2:
data(Trees)
Species1_Mean&lt;-Mmean(Trees[[1]],1)
Species1_Mean
Species2_Mean&lt;-Mmean(Trees[[2]],1)
Species2_Mean
Species3_Mean&lt;-Mmean(Trees[[3]],1)
Species3_Mean
</code></pre>

<hr>
<h2 id='Msum'>
Minkowski sum
</h2><span id='topic+Msum'></span>

<h3>Description</h3>

<p>Given a list <code>XX</code> of polygonal fuzzy numbers the function first checks (1) if each element of the list is in the correct form (tested by <code>checking</code>) and (2) if the alpha-levels of all elements in the list coincide. If these two conditions are fulfilled the levelwise Minkowski-sum of all elements in the sample <code>XX</code> will be returned. If not the <code>translator</code> function can be used to transform the elements of the list in the correct format. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Msum(XX, pic = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Msum_+3A_xx">XX</code></td>
<td>

<p>...list of polygonal fuzzy numbers (the function implicitly checks the conditions)
</p>
</td></tr>
<tr><td><code id="Msum_+3A_pic">pic</code></td>
<td>

<p>...numeric, if <code>pic</code>=1 then the Minkowski-sum of <code>XX</code> is printed. By default <code>pic</code>=0.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See examples
</p>


<h3>Value</h3>

<p>Given input <code>XX</code> in the correct format the function returns the Minkowski sum of the polygonal fuzzy numbers contained in the list.
</p>


<h3>Note</h3>

<p>In case you find (almost surely existing) bugs or have recommendations for improving the functions comments are welcome to the above mentioned mail addresses.
</p>


<h3>Author(s)</h3>

<p>Wolfgang Trutschnig &lt;wolfgang@trutschnig.net&gt;, Asun Lubiano &lt;lubiano@uniovi.es&gt;
</p>


<h3>See Also</h3>

<p>See Also <code><a href="#topic+checking">checking</a></code>, <code><a href="#topic+translator">translator</a></code>, <code><a href="#topic+Mmean">Mmean</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Example 1:
X&lt;-data.frame(x=c(0,1,1.5,3),alpha=c(0,1,1,0))
Y&lt;-data.frame(x=c(1.25,2.75,2.75,5),alpha=c(0,1,1,0))
sum&lt;-Msum(list(X,Y))
sum

#Example 2:
data(XX)
X&lt;-translator(XX[[1]],50)
Y&lt;-translator(XX[[2]],50)
Z&lt;-translator(XX[[3]],50)
YY&lt;-list(X,Y,Z)
M&lt;-Msum(YY)
</code></pre>

<hr>
<h2 id='SAFD-package'>
Statistical Analysis of Fuzzy Data
</h2><span id='topic+SAFD-package'></span><span id='topic+SAFD'></span>

<h3>Description</h3>

<p>The aim of the package is to provide some basic functions for doing statistics with 
one-dimensional Fuzzy Data (in the form of polygonal fuzzy numbers).
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> SAFD</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 2.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2019-07-03</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;=2)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The aim of the package is to provide some basic functions for doing statistics with one dimensional Fuzzy Data (in the form of polygonal fuzzy numbers). In particular, the package contains functions for the basic operations on the class of fuzzy numbers (sum, scalar product, mean, median, Hukuhara difference) as well as for calculating (Bertoluzza) distance and sample variance. Moreover a function to simulate fuzzy random variables and bootstrap tests for the equality of means is included.<br />
Version 2.1 fixes some bugs of previous versions.
</p>


<h3>Author(s)</h3>

<p>Wolfgang Trutschnig &lt;wolfgang@trutschnig.net&gt;, Asun Lubiano
&lt;lubiano@uniovi.es&gt;
</p>
<p>Maintainer: Asun Lubiano
&lt;lubiano@uniovi.es&gt;
</p>


<h3>References</h3>

<p>[1] Bertoluzza, C., Corral, N., Salas, A.: <em>On a new class of distances between fuzzy numbers</em>, Mathware Soft Comput., 2, pp. 71-84 (1995)<br />
[2] Colubi, A.: <em>Statistical inference about the means of fuzzy random variables: Applications to the analysis of fuzzy- and real-valued data</em>, Fuzzy Sets and Systems, 160(3), pp. 344-356 (2009)<br />
[3] Gil, M.A., Lopez, M.T., Lubiano, M.A., Montenegro, M.: <em>Regression and correlation analyses of a linear relation between random intervals</em>, Test, 10(1), pp. 183-201 (2001)<br />
[4] Gil, M.A.; Montenegro, M.; Gonzalez-Rodriguez, G.; Colubi, A.; Casals, R.: <em>Bootstrap approach to the multi-sample test of means with imprecise data</em>, Computational Statistics and Data Analysis, 51(1), pp. 148-162  (2006)<br />
[5] Gonzalez-Rodriguez, G.; Blanco, A.; Colubi, A.; Lubiano, M.A.: <em>Estimation of a simple linear regression model for fuzzy random variables</em>, Fuzzy Sets and Systems, 160(3), pp. 357-370 (2009)<br />
[6] Gonzalez-Rodriguez, G., Colubi, A., Trutschnig, W.: <em>Simulation of fuzzy random variables</em>,  Information Sciences, 179(5), pp. 642-653 (2009)<br />
[7] Montenegro, M., Colubi, A., Casals, M.R., Gil, M.A.: <em>Asymptotic and bootstrap techniques for testing the expected value of a fuzzy random variable</em>, Metrika, 59, pp. 31-49  (2004)<br />
[8] Montenegro, M., Casals, M.R., Lubiano, M.A., Gil, M.A.: <em>Two-sample hypothesis tests of means of a fuzzy random variable</em>, Information Sciences, 133(1-2), pp. 89-100 (2001)<br />
[9] Sinova, B., Gil, M.A., Colubi, A., Van Aelst, S.: <em>The median of a random fuzzy number. The 1-norm distance approach</em>, Fuzzy Sets and Systems, 200, pp. 99-115 (2012)<br />
[10] Trutschnig, W., <em>A strong consistency result for fuzzy relative frequencies interpreted as estimator for the fuzzy-valued probability</em>, Fuzzy Sets and Systems, 159(3), pp. 259-269 (2008)<br />
[11] Trutschnig, W., Gonzalez-Rodriguez, G., Colubi, A.; Gil, M.A.: <em>A new family of metrics for compact, convex (fuzzy) sets based on a generalized concept of mid and spread</em>,  Information Sciences, 179(23), pp. 3964-3972 (2009)<br />
[12] Viertl, R., Hareter, D.: <em>Beschreibung und Analyse unscharfer Information: Statistische Methoden fuer unscharfe Daten</em>, Springer Wien New York, 2006 
</p>


<h3>See Also</h3>

<p><a href="http://bellman.ciencias.uniovi.es/smire+codire/">http://bellman.ciencias.uniovi.es/smire+codire/</a>
</p>

<hr>
<h2 id='sc_mult'>
Minkowski scalar multiplication
</h2><span id='topic+sc_mult'></span>

<h3>Description</h3>

<p>Given an input dataframe (polygonal fuzzy number) <code>X</code> in the correct format (tested by <code>checking</code>), and a scalar <code>b</code> the fuzzy number <code>bX</code> is calculated using level-wise Minkowski scalar multiplication.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sc_mult(X, b, pic = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sc_mult_+3A_x">X</code></td>
<td>

<p>...dataframe, if checking(X)=1 the product <code>b</code><code>X</code> is returned, if not, NA is returned.
</p>
</td></tr>
<tr><td><code id="sc_mult_+3A_b">b</code></td>
<td>

<p>...numeric
</p>
</td></tr>
<tr><td><code id="sc_mult_+3A_pic">pic</code></td>
<td>

<p>...numeric, if <code>pic</code>=1 then the product of <code>X</code> by the scalar <code>b</code> is printed. By default <code>pic</code>=0.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See examples
</p>


<h3>Value</h3>

<p>Given correct input data, the function returns the polygonal fuzzy number <code>b</code><code>X</code>.
</p>


<h3>Note</h3>

<p>In case you find (almost surely existing) bugs or have recommendations for improving the functions comments are welcome to the above mentioned mail addresses.
</p>


<h3>Author(s)</h3>

<p>Wolfgang Trutschnig &lt;wolfgang@trutschnig.net&gt;, Asun Lubiano &lt;lubiano@uniovi.es&gt;
</p>


<h3>See Also</h3>

<p>See Also <code><a href="#topic+checking">checking</a></code>, <code><a href="#topic+translator">translator</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Example 1:
U&lt;-data.frame(x=c(-1,0,1),alpha=c(0,1,0))
E&lt;-sc_mult(U,2)
E

#Example 2:
X&lt;-data.frame(x=c(0,1,1,5),alpha=c(0,1,1,0))
sc_prod&lt;-sc_mult(X,1.5)
sc_prod



#Example 3:
data(XX)
X&lt;-translator(XX[[1]],10)
E&lt;-sc_mult(X,-2,pic=1)
E
</code></pre>

<hr>
<h2 id='translator'>
Translator
</h2><span id='topic+translator'></span>

<h3>Description</h3>

<p>The function first calls <code>checking2</code> in order to check if the input data <code>X</code> defines a polygonal fuzzy number. If all conditions are satisfied the function transforms the input <code>X</code> into a dataframe with the chosen number <code>nl</code> of levels (default is <code>nl</code>=101) by doing linear interpolation, and returns this dataframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>translator(X, nl = 101, pic = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="translator_+3A_x">X</code></td>
<td>

<p>...dataframe for which <code>checking2</code> yields 1
</p>
</td></tr>
<tr><td><code id="translator_+3A_nl">nl</code></td>
<td>

<p>...number of levels of the output dataframe (fuzzy number), by default 101, must be at least 2.
</p>
</td></tr>
<tr><td><code id="translator_+3A_pic">pic</code></td>
<td>

<p>...numeric, if <code>pic</code>=1 then the poligonal fuzzy number <code>X</code> with <code>nl</code> alpha-levels is printed. By default <code>pic</code>=0.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See examples
</p>


<h3>Value</h3>

<p>In case checking2(X)=1 <code>translator</code> returns a dataframe (fuzzy number) with <code>nl</code> number of alpha-levels, otherwise the input is returned unchanged.
</p>


<h3>Note</h3>

<p>In case you find (almost surely existing) bugs or have recommendations for improving the functions comments are welcome to the above mentioned mail addresses.
</p>


<h3>Author(s)</h3>

<p>Wolfgang Trutschnig &lt;wolfgang@trutschnig.net&gt;, Asun Lubiano &lt;lubiano@uniovi.es&gt;
</p>


<h3>See Also</h3>

<p>See Also as <code><a href="#topic+checking2">checking2</a></code>, <code><a href="#topic+checking">checking</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Example 1:
X&lt;-data.frame(x=c(-2,-0.75,-0.25,0.5,1),alpha=c(0,0.6,1,1,0))
E&lt;-translator(X,3)
E


#Example 2:
data(XX)
E&lt;-translator(XX[[3]],11, pic=1)
E
</code></pre>

<hr>
<h2 id='Trees'>
Tree dataset
</h2><span id='topic+Trees'></span>

<h3>Description</h3>

<p><code>Trees</code> is a list containing three sublists, each of which consists of a sample of trapezoidal fuzzy numbers. The data corresponds to the <em>quality</em> of the three main species of trees in Asturias, namely birch (<em>Betula celtiberica</em>), sessile oak (<em>Quercus petraea</em>) and rowan (<em>Sorbus aucuparia</em>) within a study about the progress of reforestation in a given area of Asturias (Spain). INDUROT institute (University of Oviedo) has collected a sample of n1=133 birches, n2=109 sessile oaks and
n3=37 rowans. Each tree was assigned a trapezoidal fuzzy number that models the experts subjective judgements/perceptions of the tree quality on a scale from 0 to 5 (0 meaning very bad quality to 5 meaning very good quality). Thereby the 1-cut is the interval in which the expert thinks the quality is contained and the support (0-cut) is the interval in which the expert is absolutely sure the quality is contained.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Trees")</code></pre>


<h3>Format</h3>

<p>A list with three sublist, each of which contains trapezoidal fuzzy numbers.
</p>


<h3>Details</h3>

<p>See Reference
</p>


<h3>References</h3>

<p>[1] Colubi, A.: <em>Statistical inference about the means of fuzzy random variables:
Applications to the analysis of fuzzy- and real-valued data</em>, Fuzzy Sets and Systems,
160(3), pp. 344-356 (2009)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Trees)
M&lt;-Mmean(Trees[[1]],1)
M
sd&lt;-sqrt(Bvar(Trees[[1]],1))
sd
</code></pre>

<hr>
<h2 id='XX'>
Example data
</h2><span id='topic+XX'></span>

<h3>Description</h3>

<p><code>XX</code> is a list of three polygonal fuzzy numbers that is used in the given examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("XX")</code></pre>


<h3>Format</h3>

<p>List of three polygonal fuzzy numbers.
</p>


<h3>Details</h3>

<p>See examples
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(XX)
V&lt;-translator(XX[[1]],50)
SS1&lt;-vector("list",length=100)
for (j in 1:100){
 SS1[[j]]&lt;-generator(V,)
 }
M&lt;-Mmean(SS1,1)
head(M)
b&lt;-bertoluzza(M,V,1/3,1) 
b 
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
