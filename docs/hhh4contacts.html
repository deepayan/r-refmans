<!DOCTYPE html><html><head><title>Help for package hhh4contacts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {hhh4contacts}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adaptP'><p>Adapt a Transition Matrix to a Specific Stationary Distribution</p></a></li>
<li><a href='#addGroups2WFUN'><p>Group-Dependent Parametric Weights</p></a></li>
<li><a href='#aggregateC'><p>Aggregate a Contact Matrix</p></a></li>
<li><a href='#aggregateCountsArray'><p>Aggregate an Array of Counts wrt One Dimension (Stratum)</p></a></li>
<li><a href='#C2pop'><p>Adapt a Contact Matrix to Population Fractions</p></a></li>
<li><a href='#contactmatrix'><p>POLYMOD Contact Matrices for Germany</p></a></li>
<li><a href='#dssAggregate'><p>Compute the DSS on Aggregated Predictions and Observations</p></a></li>
<li><a href='#expandC'><p>Expand the Contact Matrix over Regions</p></a></li>
<li><a href='#fitC'><p>Estimate the Power of the Contact Matrix in a <code>"hhh4"</code> Model</p></a></li>
<li><a href='#noroBE'><p>Create <code>"sts"</code> Objects from the Berlin Norovirus Data</p></a></li>
<li><a href='#plotC'><p>Generate an Image of a Contact Matrix</p></a></li>
<li><a href='#plotHHH4_fitted_groups'><p>Plot Mean Components of a <code>hhh4</code> Fit by Group</p></a></li>
<li><a href='#plotHHH4_maps_groups'><p>Plot Mean Components of a <code>hhh4</code> Fit by District Averaged Over Time</p></a></li>
<li><a href='#plotHHH4_season_groups'><p>Plot Seasonality of a <code>hhh4</code> Fit by Group</p></a></li>
<li><a href='#pop2011'><p>Berlin and German Population by Age Group, 2011</p></a></li>
<li><a href='#powerC'><p>Exponentiate a Matrix via Eigendecomposition</p></a></li>
<li><a href='#stationary'><p>Stationary Distribution of a Transition Matrix</p></a></li>
<li><a href='#stratum'><p>Extract Strata</p></a></li>
<li><a href='#stsplothook'><p>Hook functions for <code>stsplot_time1</code></p></a></li>
<li><a href='#subset.array'><p>Subset an Array in one Dimension</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.13.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-06</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Title:</td>
<td>Age-Structured Spatio-Temporal Models for Infectious Disease
Counts</td>
</tr>
<tr>
<td>Description:</td>
<td>Meyer and Held (2017) &lt;<a href="https://doi.org/10.1093%2Fbiostatistics%2Fkxw051">doi:10.1093/biostatistics/kxw051</a>&gt; present an
    age-structured spatio-temporal model for infectious disease counts. The
    approach is illustrated in a case study on norovirus gastroenteritis in
    Berlin, 2011-2015, by age group, city district and week, using additional
    contact data from the POLYMOD survey. This package contains the data and
    code to reproduce the results from the paper, see 'demo("hhh4contacts")'.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0), grDevices, graphics, methods, stats, utils,
surveillance (&ge; 1.14.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>sp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS, lattice, gridExtra</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-06 10:29:49 UTC; smeyer</td>
</tr>
<tr>
<td>Author:</td>
<td>Sebastian Meyer <a href="https://orcid.org/0000-0002-1791-9449"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Leonhard Held [ctb, ths]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sebastian Meyer &lt;seb.meyer@fau.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-06 11:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='adaptP'>Adapt a Transition Matrix to a Specific Stationary Distribution</h2><span id='topic+adaptP'></span>

<h3>Description</h3>

<p><strong>Experimental</strong> Metropolis-Hastings algorithm, which tries
to adjust a transition matrix such that its stationary distribution
becomes approximately equal to a prespecified probability vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adaptP(P, target, niter = 1e+06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adaptP_+3A_p">P</code></td>
<td>
<p>a transition matrix, i.e., a square matrix where all rows sum to 1.</p>
</td></tr>
<tr><td><code id="adaptP_+3A_target">target</code></td>
<td>
<p>the stationary probability vector to approximate.</p>
</td></tr>
<tr><td><code id="adaptP_+3A_niter">niter</code></td>
<td>
<p>the number of iterations of the MCMC algorithm</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the adjusted transition matrix.
</p>


<h3>Author(s)</h3>

<p>Leonhard Held
</p>


<h3>See Also</h3>

<p><code><a href="#topic+C2pop">C2pop</a></code> for an alternative method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a row-normalized contact matrix
C &lt;- matrix(c(0.8, 0.1, 0.1,
              0.2, 0.6, 0.2,
              0.1, 0.2, 0.7), byrow=TRUE, ncol=3, nrow=3)
stationary(C)
## population fractions define the target distribution
popfracs &lt;- c(0.4, 0.3, 0.3)
## adapt 'C' to the given population fractions
Cpop &lt;- adaptP(C, popfracs, niter = 50000)
stationary(Cpop)
## this method increases the diagonal values of 'C'
round(C, 3)
round(Cpop, 3)
round(Cpop/C, 3)
</code></pre>

<hr>
<h2 id='addGroups2WFUN'>Group-Dependent Parametric Weights</h2><span id='topic+addGroups2WFUN'></span>

<h3>Description</h3>

<p>This function takes a specification of parametric weights and returns
a modified version with group-dependent parameters.
Only single-parameter functions are currently supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addGroups2WFUN(WFUN, groups, initial = rep.int(WFUN$initial, nlevels(groups)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addGroups2WFUN_+3A_wfun">WFUN</code></td>
<td>
<p>a list specification of parametric weights, e.g.,
as returned by the constructor functions <code><a href="surveillance.html#topic+W_powerlaw">W_powerlaw</a></code> and
<code><a href="surveillance.html#topic+W_np">W_np</a></code>.</p>
</td></tr>
<tr><td><code id="addGroups2WFUN_+3A_groups">groups</code></td>
<td>
<p>a vector of length <code>nUnits</code> determining to which
group each unit belongs to. The supplied vector is converted to a
factor using <code><a href="base.html#topic+as.factor">as.factor</a></code>.</p>
</td></tr>
<tr><td><code id="addGroups2WFUN_+3A_initial">initial</code></td>
<td>
<p>(named) vector of initial parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list specifying group-dependent parametric weights for <code>hhh4</code>.
</p>


<h3>Author(s)</h3>

<p>Sebastian Meyer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("measlesWeserEms")
WPLgroups &lt;- addGroups2WFUN(
  W_powerlaw(maxlag = 5, normalize = FALSE, log = FALSE),
  groups = factor(sample(2, ncol(measlesWeserEms), replace = TRUE)))
</code></pre>

<hr>
<h2 id='aggregateC'>Aggregate a Contact Matrix</h2><span id='topic+aggregateC'></span>

<h3>Description</h3>

<p>The (age) groups of a contact matrix can be joined together by the
<code>grouping</code> argument, which first sums over contact groups (columns) and
then averages over the corresponding participant groups (rows), optionally
using weights such as the age distribution of the study participants.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggregateC(C, grouping, ..., weights = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggregateC_+3A_c">C</code></td>
<td>
<p>a square numeric contact matrix such as
<code><a href="#topic+contactmatrix_POLYMOD">contactmatrix_POLYMOD</a></code>.</p>
</td></tr>
<tr><td><code id="aggregateC_+3A_grouping">grouping</code>, <code id="aggregateC_+3A_...">...</code></td>
<td>
<p>specification of how to aggregate groups.
<code>grouping</code> can be a named list of vectors of group labels,
or an integer vector of sequential group sizes.
Alternatively, if <code>grouping</code> is missing, the elements of the list
representation can be passed directly as further arguments (<code>...</code>).</p>
</td></tr>
<tr><td><code id="aggregateC_+3A_weights">weights</code></td>
<td>
<p>a named numeric vector containing the weights for the rows of
<code>C</code>, typically the age distribution of the participants. The names
are matched against <code>rownames(C)</code>. A value of <code>NULL</code> is
interpreted as uniform weights.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sebastian Meyer
</p>

<hr>
<h2 id='aggregateCountsArray'>Aggregate an Array of Counts wrt One Dimension (Stratum)</h2><span id='topic+aggregateCountsArray'></span>

<h3>Description</h3>

<p>Aggregate an Array of Counts wrt One Dimension (Stratum)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggregateCountsArray(counts, dim, grouping, ..., sort = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggregateCountsArray_+3A_counts">counts</code></td>
<td>
<p>an (integer) array of counts with <code>dimnames</code>,
e.g., <code><a href="#topic+counts">counts</a></code> or <code><a href="#topic+pop2011">pop2011</a></code>.</p>
</td></tr>
<tr><td><code id="aggregateCountsArray_+3A_dim">dim</code></td>
<td>
<p>the dimension index of the stratum defining groups.</p>
</td></tr>
<tr><td><code id="aggregateCountsArray_+3A_grouping">grouping</code>, <code id="aggregateCountsArray_+3A_...">...</code></td>
<td>
<p>how the groups should be built.</p>
</td></tr>
<tr><td><code id="aggregateCountsArray_+3A_sort">sort</code></td>
<td>
<p>logical indicating if the resulting array should be ordered
by the grouping levels in the <code>dim</code> dimension.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an array with similar dimensions as the input <code>counts</code>
except for the <code>dim</code> dimension, which will be smaller due to the
aggregation as specified by the <code>grouping</code> argument.
</p>


<h3>Author(s)</h3>

<p>Sebastian Meyer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## works for matrices
aggregateCountsArray(pop2011, dim = 2, grouping = c(2,1,3,2,4))
aggregateCountsArray(pop2011, dim = 1, grouping = list(
    "a" = c("chwi","span","zehl"),
    "b" = c("neuk","scho")
))
## and of course for arrays
str(aggregateCountsArray(counts, dim = 3, grouping = c(1, 3, 4)))
</code></pre>

<hr>
<h2 id='C2pop'>Adapt a Contact Matrix to Population Fractions</h2><span id='topic+C2pop'></span>

<h3>Description</h3>

<p><strong>Experimental</strong> function, which tries to adjust a given contact matrix
such that the stationary distribution of its row-normalized version (i.e.,
the transition matrix) becomes approximately equal to a prespecified
probability vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>C2pop(C, target, eps = 0.001, iter.max = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="C2pop_+3A_c">C</code></td>
<td>
<p>a square numeric (contact) matrix.</p>
</td></tr>
<tr><td><code id="C2pop_+3A_target">target</code></td>
<td>
<p>the stationary probability vector to approximate.</p>
</td></tr>
<tr><td><code id="C2pop_+3A_eps">eps</code></td>
<td>
<p>the tolerated mean absolute difference between the target
probabilities and the stationary distribution of the adapted, normalized
contact matrix.</p>
</td></tr>
<tr><td><code id="C2pop_+3A_iter.max">iter.max</code></td>
<td>
<p>maximum number of iterations (guard against infinite loop).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the adapted, normalized contact matrix.
</p>


<h3>Author(s)</h3>

<p>Leonhard Held (original) and Sebastian Meyer (this implementation)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+adaptP">adaptP</a></code> for an alternative method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GROUPING &lt;- c(1, 2, 2, 4, 4, 2)
C &lt;- contactmatrix(grouping = GROUPING)
popBErbyg &lt;- aggregateCountsArray(pop2011, dim = 2, grouping = GROUPING)
popfracs &lt;- prop.table(colSums(popBErbyg))
## adapt 'C' to the given population fractions
Cpop &lt;- C2pop(C, popfracs)
## compare the stationary distributions
compstat &lt;- cbind(before = stationary(C/rowSums(C)), popBE = popfracs,
                  after = stationary(Cpop))
matplot(compstat, type="b", lty=1, ylim=c(0, max(compstat)),
        xlab="age group", ylab="population fraction")
## compare the normalized contact matrices
print(plotC(C/rowSums(C), main="original", at=seq(0,0.6,length.out=17)),
      split=c(1,1,2,1), more=TRUE)
print(plotC(Cpop, main="adapted", at=seq(0,0.6,length.out=17)),
      split=c(2,1,2,1), more=FALSE)
</code></pre>

<hr>
<h2 id='contactmatrix'>POLYMOD Contact Matrices for Germany</h2><span id='topic+contactmatrix'></span><span id='topic+contactmatrix_mossong'></span><span id='topic+contactmatrix_mossong_physical'></span><span id='topic+contactmatrix_POLYMOD'></span><span id='topic+contactmatrix_POLYMOD_physical'></span><span id='topic+contactmatrix_wallinga'></span><span id='topic+contactmatrix_wallinga_physical'></span>

<h3>Description</h3>

<p>The function <code>contactmatrix</code> retrieves various social contact matrices
for Germany from the POLYMOD survey (Mossong et al., 2008). Such a matrix
contains the average numbers of reported contacts by participant age group.
The original age groups (5-year intervals) can be joined together by the
<code>grouping</code> argument, which first sums over contact groups (columns) and
then averages over the corresponding participant groups (rows) using the
corresponding age distribution as weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contactmatrix(
  which = c("corrected", "mossong", "reciprocal"),
  type = c("all", "physical"),
  grouping = c(1, 2, 2, 4, 4, 2),
  normalize = FALSE
)

contactmatrix_mossong

contactmatrix_mossong_physical

contactmatrix_POLYMOD

contactmatrix_POLYMOD_physical

contactmatrix_wallinga

contactmatrix_wallinga_physical
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contactmatrix_+3A_which">which</code></td>
<td>
<p>character string indicating which contact matrix to return.
<code>"mossong"</code> uses the average numbers of reported contacts as published
in Table S5 of Mossong et al. (2008), available as
<code>contactmatrix_mossong</code> or <code>contactmatrix_mossong_physical</code>.
<code>"corrected"</code> (from <code>contactmatrix_POLYMOD</code> or
<code>contactmatrix_POLYMOD_physical</code>) fixes an error in these numbers
related to the age group 70+ (see the Examples) and is the default.
If <code>which="reciprocal"</code> (corresponding to <code>contactmatrix_wallinga</code>
or <code>contactmatrix_wallinga_physical</code> as used by Meyer and Held, 2017),
the returned social contact matrix fulfils reciprocity of contacts with
respect to the age distribution of Berlin, <code><a href="#topic+pop2011">pop2011</a></code>,
via the method of Wallinga et al. (2006).</p>
</td></tr>
<tr><td><code id="contactmatrix_+3A_type">type</code></td>
<td>
<p>a character string to select the type of contacts to use:
either <code>"all"</code> contacts, i.e., count both physical and pure
conversational contacts, or only <code>"physical"</code> contacts.</p>
</td></tr>
<tr><td><code id="contactmatrix_+3A_grouping">grouping</code></td>
<td>
<p>specification of how to aggregate groups using
<code><a href="#topic+aggregateC">aggregateC</a></code>, i.e., a named list of vectors of group labels,
or an integer vector of sequential group sizes. The <code>"agedistri"</code>
attribute of the contact matrix is used as <code>weights</code>.
If <code>grouping=NULL</code>, aggregation is skipped and the original (5-year)
age groups are returned.
The default setting produces the six age groups of Meyer and Held (2017).</p>
</td></tr>
<tr><td><code id="contactmatrix_+3A_normalize">normalize</code></td>
<td>
<p>a logical indicating whether to normalize the matrix
such that each row sums to 1.</p>
</td></tr>
</table>


<h3>Format</h3>

<p>The dataset <code>contactmatrix_POLYMOD</code> and its variants are all
square numeric matrices with 15 rows (participants) and 15 columns
(contacts), labelled with the corresponding age groups. There is an attribute
<code>"agedistri"</code>, a named numeric vector of length 15, which for the
&ldquo;_mossong_&rdquo; and &ldquo;_POLYMOD_&rdquo; variants gives the
age distribution of the German POLYMOD sample, and for the <code>_wallinga_</code>
variants gives the age distribution of Berlin, i.e.,
<code>prop.table(colSums(<a href="#topic+pop2011">pop2011</a>))</code>.
</p>


<h3>Value</h3>

<p>a square numeric matrix containing the average numbers of contact
persons recorded per day per survey participant in Germany,
potentially averaged over multiple <em>row</em> (participant) age groups
and aggregated over the corresponding <em>column</em> (contact) age groups.
</p>


<h3>Author(s)</h3>

<p>Sebastian Meyer
</p>


<h3>Source</h3>

<p><code>contactmatrix_mossong</code> and <code>contactmatrix_mossong_physical</code>
are taken from the Supporting Information in Mossong et al. (2008):
the matrices from Table S5 (8.2), and the attached age distribution
from Table S2 (3.2).
</p>
<p>The corrected versions <code>contactmatrix_POLYMOD</code> and
<code>contactmatrix_POLYMOD_physical</code> were constructed
from the <em>raw</em> POLYMOD data initially made available at
<a href="https://www.researchgate.net/publication/232701632_POLYMOD_contact_survey_for_researchers">https://www.researchgate.net/publication/232701632_POLYMOD_contact_survey_for_researchers</a>
(a reformatted and better documented version is
nowadays available at <a href="https://doi.org/10.5281/zenodo.1043437">doi:10.5281/zenodo.1043437</a>).
The reciprocal contact matrices <code>contactmatrix_wallinga</code> and
<code>contactmatrix_wallinga_physical</code> were estimated from these raw data
via the method of Wallinga et al. (2006).
</p>


<h3>References</h3>

<p>Meyer S and Held L (2017): Incorporating social contact data in
spatio-temporal models for infectious disease spread.
<em>Biostatistics</em>, <b>18</b> (2), 338-351.
<a href="https://doi.org/10.1093/biostatistics/kxw051">doi:10.1093/biostatistics/kxw051</a>
</p>
<p>Mossong et al. (2008):
Social contacts and mixing patterns relevant to the
spread of infectious diseases.
<em>PLoS Medicine</em>, <b>5</b> (3), e74.
<a href="https://doi.org/10.1371/journal.pmed.0050074">doi:10.1371/journal.pmed.0050074</a>
</p>
<p>Wallinga J, Teunis P and Kretzschmar M (2006):
Using data on social contacts to estimate age-specific transmission
parameters for respiratory-spread infectious agents.
<em>American Journal of Epidemiology</em>, <b>164</b> (10), 936-944.
<a href="https://doi.org/10.1093/aje/kwj317">doi:10.1093/aje/kwj317</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## contact matrix reported in Mossong et al (2008, Table S5)
(C_original &lt;- contactmatrix(which = "mossong", grouping = NULL))
## this simply returns the dataset 'contactmatrix_mossong'
stopifnot(identical(C_original, contactmatrix_mossong))

## with corrected numbers for the 70+ age group (the default)
C_corrected &lt;- contactmatrix(which = "corrected", grouping = NULL)
## this simply returns the dataset 'contactmatrix_POLYMOD'
stopifnot(identical(C_corrected, contactmatrix_POLYMOD))

## check for differences
C_original == round(C_corrected, 2)
## compare entries of last row and last column
round(rbind(original = C_original[15,], corrected = C_corrected[15,]), 2)
round(cbind(original = C_original[,15], corrected = C_corrected[,15]), 2)

## contact matrix estimated to be reciprocal on the population level
C_reciprocal &lt;- contactmatrix(which = "reciprocal", grouping = NULL)
## this simply returns the dataset 'contactmatrix_wallinga'
## (without its "overdisp" attribute)
stopifnot(all.equal(C_reciprocal, contactmatrix_wallinga, check.attributes=FALSE))

## check reciprocity
agedistriBE &lt;- attr(C_reciprocal, "agedistri")
stopifnot(identical(agedistriBE, prop.table(colSums(pop2011))))
stopifnot(isSymmetric(C_reciprocal * agedistriBE, check.attributes=FALSE))

## visually compare raw to reciprocal contact matrix
if (require("gridExtra"))
    grid.arrange(plotC(C_corrected, main = "raw"),
                 plotC(C_reciprocal, main = "reciprocal"),
                 nrow = 1)

## select physical contacts and aggregate into 5 age groups
contactmatrix(type = "physical", grouping = c(1, 2, 7, 3, 2))

## the default 6 age groups, normalized to a transition matrix
contactmatrix(normalize = TRUE)

## reciprocity also holds for this grouping
(C6 &lt;- contactmatrix(which = "reciprocal"))
stopifnot(isSymmetric(C6 * attr(C6, "agedistri"), check.attributes=FALSE))

</code></pre>

<hr>
<h2 id='dssAggregate'>Compute the DSS on Aggregated Predictions and Observations</h2><span id='topic+dssAggregate'></span>

<h3>Description</h3>

<p>The expectation and variance of aggregated predictions is just a sum if the
predictions are (conditionally) independent. This function computes the DSS
for a matrix of observations and a matrix of predictions
where the columns are to be summed according to a given factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dssAggregate(observed, pred, psi, groups)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dssAggregate_+3A_observed">observed</code></td>
<td>
<p>a numeric matrix of observed counts.</p>
</td></tr>
<tr><td><code id="dssAggregate_+3A_pred">pred</code></td>
<td>
<p>a numeric matrix of predicted counts.</p>
</td></tr>
<tr><td><code id="dssAggregate_+3A_psi">psi</code></td>
<td>
<p>a numeric vector or matrix of overdispersion parameters such that
<code>pred * (1 + pred/exp(psi))</code> is the prediction's variance.
Alternatively, <code>psi = NULL</code> indicated Poisson predictions.</p>
</td></tr>
<tr><td><code id="dssAggregate_+3A_groups">groups</code></td>
<td>
<p>a factor variable of length <code>ncol(observed)</code> indicating
which columns should be aggregated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of DSS values
</p>

<hr>
<h2 id='expandC'>Expand the Contact Matrix over Regions</h2><span id='topic+expandC'></span>

<h3>Description</h3>

<p>This is simply the Kronecker product of the contact matrix <code>C</code>
with a matrix of ones of dimension <code>n</code> x <code>n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expandC(C, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expandC_+3A_c">C</code></td>
<td>
<p>a <code><a href="#topic+contactmatrix">contactmatrix</a></code>.</p>
</td></tr>
<tr><td><code id="expandC_+3A_n">n</code></td>
<td>
<p>the size of the secondary dimension to expand to.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a square matrix with <code>n*ncol(C)</code> rows and columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>expandC(contactmatrix(), 2)
</code></pre>

<hr>
<h2 id='fitC'>Estimate the Power of the Contact Matrix in a <code>"hhh4"</code> Model</h2><span id='topic+fitC'></span>

<h3>Description</h3>

<p>The profile log-likelihood of the log(power) parameter of the contact matrix
(see <code><a href="#topic+powerC">powerC</a></code>) is maximized using <code><a href="stats.html#topic+optim">optim</a></code>.
The <code><a href="surveillance.html#topic+hhh4">hhh4</a></code> fit for the optimal power value is returned with an
additional element <code>logpower</code> which holds information on the result of
the optimization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitC(object, C, normalize = TRUE, truncate = TRUE, optim.args = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitC_+3A_object">object</code></td>
<td>
<p>a model fit of class <code>"<a href="surveillance.html#topic+hhh4">hhh4</a>"</code>.</p>
</td></tr>
<tr><td><code id="fitC_+3A_c">C</code></td>
<td>
<p>the contact matrix to use.</p>
</td></tr>
<tr><td><code id="fitC_+3A_normalize">normalize</code>, <code id="fitC_+3A_truncate">truncate</code></td>
<td>
<p>see <code><a href="#topic+powerC">powerC</a></code>.</p>
</td></tr>
<tr><td><code id="fitC_+3A_optim.args">optim.args</code></td>
<td>
<p>a list to modify the default optimization parameters.</p>
</td></tr>
<tr><td><code id="fitC_+3A_...">...</code></td>
<td>
<p>additional arguments for each run of <code><a href="surveillance.html#topic+update.hhh4">update.hhh4</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>"fitC"</code>, which is an <code>"<a href="surveillance.html#topic+hhh4">hhh4</a>"</code>
object with an additional element <code>logpower</code>.
</p>


<h3>Author(s)</h3>

<p>Sebastian Meyer
</p>

<hr>
<h2 id='noroBE'>Create <code>"sts"</code> Objects from the Berlin Norovirus Data</h2><span id='topic+noroBE'></span><span id='topic+counts'></span><span id='topic+map'></span>

<h3>Description</h3>

<p>The function <code>noroBE()</code> creates an <code>"<a href="surveillance.html#topic+sts-class">sts</a>"</code> object
based on the array of norovirus surveillance <code>counts</code>, the <code>map</code>
of Berlin's city district, and the <code><a href="#topic+pop2011">pop2011</a></code> data stored in the
package. This is the data analysed by Meyer and Held (2017).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>noroBE(
  by = c("districts", "agegroups", "all", "none"),
  agegroups = c(1, 2, 2, 4, 4, 2),
  timeRange = c("2011-w27", "2015-w26"),
  flatten = FALSE
)

counts

map
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="noroBE_+3A_by">by</code></td>
<td>
<p>character string determining the stratification, i.e., which units
the resulting <code>"sts"</code> object should represent: </p>

<dl>
<dt>&quot;districts&quot;:</dt><dd><p>aggregates <code>counts</code> and <code>pop2011</code> over the
age groups and stores the matrix of adjacency orders from the <code>map</code>
in the <code>neighbourhood</code> slot. The latter is obtained via
<code><a href="surveillance.html#topic+nbOrder">nbOrder</a>(<a href="surveillance.html#topic+poly2adjmat">poly2adjmat</a>(map), maxlag = 5)</code>.</p>
</dd>
<dt>&quot;agegroups&quot;:</dt><dd><p>aggregates <code>counts</code> and <code>pop2011</code> over the
districts and stores the <code><a href="#topic+contactmatrix">contactmatrix</a>()</code> in the
<code>neighbourhood</code> slot, potentially also combining some age groups
via the <code>agegroups</code> argument.</p>
</dd>
<dt>&quot;all&quot;:</dt><dd><p>retains both dimensions, either as a list of spatial
<code>"sts"</code> objects per age group, or in a single <code>"sts"</code> object
(see <code>flatten</code> below).</p>
</dd>
<dt>&quot;none&quot;:</dt><dd><p>creates the overall (univariate) time series of
<code>rowSums(counts)</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="noroBE_+3A_agegroups">agegroups</code></td>
<td>
<p>how the age groups in <code>counts</code> (and <code>pop2011</code>)
should be aggregated. Will be used as the <code>grouping</code> argument in
<code><a href="#topic+aggregateCountsArray">aggregateCountsArray</a></code> and <code><a href="#topic+contactmatrix">contactmatrix</a></code>.
The default setting uses the six age groups of Meyer and Held (2017).</p>
</td></tr>
<tr><td><code id="noroBE_+3A_timerange">timeRange</code></td>
<td>
<p>character vector of length two determining the time range
of the <code>"sts"</code> object to generate. The two strings are matched
against <code>dimnames(counts)[[1]]</code>, which ranges from
<code>"2011-w01"</code> until <code>"2016-w30"</code>. The default value extracts
four seasons (years) starting at <code>"2011-w27"</code>.</p>
</td></tr>
<tr><td><code id="noroBE_+3A_flatten">flatten</code></td>
<td>
<p>logical indicating whether for <code>by = "all"</code> a single
<code>"sts"</code> object should be returned where the observation unit is the
interaction of district and age group (&ldquo;flattened&rdquo; <code>counts</code>
array, see <code><a href="base.html#topic+as.data.frame.array">as.data.frame.array</a></code>). By default (<code>flatten
= FALSE</code>), a list of district-based <code>"sts"</code> objects is returned,
one for each age group.</p>
</td></tr>
</table>


<h3>Format</h3>


<dl>
<dt>counts:</dt><dd><p>an integer-valued array of norovirus surveillance counts
with labelled dimensions of size
290 (<code>"week"</code>) x 12 (<code>"district"</code>) x 15 (<code>"agegroup"</code>).</p>
</dd>
<dt>map:</dt><dd><p>a <code>"<a href="sp.html#topic+SpatialPolygonsDataFrame-class">SpatialPolygonsDataFrame</a>"</code>
of length 12 with <code>row.names(map)</code> matching <code>colnames(counts)</code>,
representing Berlin's city districts in longlat coordinates (WGS84).
The data slot contains the full <code>"NAME"</code>s of the city districts
as well as their <code>"POPULATION"</code>, i.e., <code>rowSums(pop2011)</code>.</p>
</dd>
</dl>

<p>The function <code>noroBE()</code> returns an <code>"<a href="surveillance.html#topic+sts-class">sts</a>"</code> object
generated from these data (and <code><a href="#topic+pop2011">pop2011</a></code>).
</p>


<h3>Author(s)</h3>

<p>Sebastian Meyer
</p>


<h3>Source</h3>


<dl>
<dt>counts:</dt><dd><p>based on norovirus surveillance counts retrieved from
the SurvStat@RKI 2.0 online service (<a href="https://survstat.rki.de">https://survstat.rki.de</a>)
of Germany's public health institute, the Robert Koch Institute,
as of 2016-09-08.</p>
</dd>
<dt>map:</dt><dd><p>based on a KML file of Berlin's 97 local centres
(&ldquo;Ortsteile&rdquo;) downloaded from the Berlin Open Data repository at
<a href="https://daten.berlin.de/datensaetze/geometrien-der-ortsteile-von-berlin-juli-2012">https://daten.berlin.de/datensaetze/geometrien-der-ortsteile-von-berlin-juli-2012</a>
as of 2014-11-12, published by
<em>Amt fuer Statistik Berlin-Brandenburg</em>
(Statistical Office of Berlin-Brandenburg)
under the &lsquo;CC BY 3.0 DE&rsquo; license
(<a href="https://creativecommons.org/licenses/by/3.0/de/">https://creativecommons.org/licenses/by/3.0/de/</a>).
The <code>map</code> included here aggregates
these local centres by city district.</p>
</dd>
</dl>



<h3>References</h3>

<p>Meyer S and Held L (2017): Incorporating social contact data in
spatio-temporal models for infectious disease spread.
<em>Biostatistics</em>, <b>18</b> (2), 338-351.
<a href="https://doi.org/10.1093/biostatistics/kxw051">doi:10.1093/biostatistics/kxw051</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## the raw data
str(counts)
summary(map)

## district-specific time series
noroBEr &lt;- noroBE(by = "districts")
plot(noroBEr)

## age group-specific time series
noroBEg &lt;- noroBE(by = "agegroups")
plot(noroBEg)

## list of spatio-temporal surveillance counts, one for each age group
noroBErbyg &lt;- noroBE(by = "all", flatten = FALSE)
plot(noroBErbyg[[1L]], par.list = list(oma=c(0,0,2,0)))
title(main = names(noroBErbyg)[1], outer = TRUE, line = -1)

## flattened "sts" object (the 'neighbourhood' only reflects spatial info)
noroBEall &lt;- noroBE(by = "all", flatten = TRUE)
dev.new(width = 16, height = 7)
plot(noroBEall, par.list = list(
    xaxt = "n", mar = c(1,4,1,1), mfrow = c(ncol(noroBEg), ncol(noroBEr))
))
</code></pre>

<hr>
<h2 id='plotC'>Generate an Image of a Contact Matrix</h2><span id='topic+plotC'></span>

<h3>Description</h3>

<p>Generate an Image of a Contact Matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotC(
  C,
  grouping = NULL,
  xlab = "age group of contact",
  ylab = "age group of participant",
  at = 15,
  col.regions = rev(heat.colors(length(at) - 1)),
  ...,
  contour = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotC_+3A_c">C</code></td>
<td>
<p>a square numeric matrix.</p>
</td></tr>
<tr><td><code id="plotC_+3A_grouping">grouping</code></td>
<td>
<p>numeric vector of sizes of aggregated groups, e.g.,
<code>grouping = c(1,3)</code>, to draw separation lines after the first and
the forth subgroup. This is ignored if <code>contour = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotC_+3A_xlab">xlab</code>, <code id="plotC_+3A_ylab">ylab</code></td>
<td>
<p>axis labels.</p>
</td></tr>
<tr><td><code id="plotC_+3A_at">at</code></td>
<td>
<p>numeric vector of break points of the color levels, or a single
integer specifying the number of <code>cuts</code> (which defaults to 15 as in
<code><a href="lattice.html#topic+levelplot">levelplot</a></code>).</p>
</td></tr>
<tr><td><code id="plotC_+3A_col.regions">col.regions</code></td>
<td>
<p>vector of color levels.</p>
</td></tr>
<tr><td><code id="plotC_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="lattice.html#topic+levelplot">levelplot</a></code> or
<code><a href="graphics.html#topic+filled.contour">filled.contour</a></code> (if <code>contour = TRUE</code>).</p>
</td></tr>
<tr><td><code id="plotC_+3A_contour">contour</code></td>
<td>
<p>logical indicating if a <code><a href="graphics.html#topic+filled.contour">filled.contour</a></code> should
be drawn instead of a <code><a href="lattice.html#topic+levelplot">levelplot</a></code> (the default).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## contour plot
plotC(contactmatrix_POLYMOD, contour = TRUE)

## level plots illustrating aggregation of age groups
if (require("gridExtra")) {
    grid.arrange(plotC(contactmatrix_POLYMOD, grouping = c(1,2,2,4,4,2)),
                 plotC(contactmatrix(grouping = c(1,2,2,4,4,2))),
                 nrow = 1)
}

</code></pre>

<hr>
<h2 id='plotHHH4_fitted_groups'>Plot Mean Components of a <code>hhh4</code> Fit by Group</h2><span id='topic+plotHHH4_fitted_groups'></span>

<h3>Description</h3>

<p>Fitted mean components for age-structured, areal time series
<code><a href="surveillance.html#topic+hhh4">hhh4</a></code> models can be aggregated over districts or age groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotHHH4_fitted_groups(x, groups, total = FALSE, decompose = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotHHH4_fitted_groups_+3A_x">x</code></td>
<td>
<p>an object of class <code>"hhh4"</code>.</p>
</td></tr>
<tr><td><code id="plotHHH4_fitted_groups_+3A_groups">groups</code></td>
<td>
<p>a factor of grouping the units in the model, i.e., it must be
of length <code>x$nUnit</code>. There will be one plot for each factor level.</p>
</td></tr>
<tr><td><code id="plotHHH4_fitted_groups_+3A_total">total</code></td>
<td>
<p>a logical indicating if the group-wise mean components should
be subsequently summed up over all <code>groups</code> for an overall plot.</p>
</td></tr>
<tr><td><code id="plotHHH4_fitted_groups_+3A_decompose">decompose</code>, <code id="plotHHH4_fitted_groups_+3A_...">...</code></td>
<td>
<p>see <code><a href="surveillance.html#topic+plotHHH4_fitted">plotHHH4_fitted</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>see <code><a href="surveillance.html#topic+plotHHH4_fitted">plotHHH4_fitted</a></code>.
</p>

<hr>
<h2 id='plotHHH4_maps_groups'>Plot Mean Components of a <code>hhh4</code> Fit by District Averaged Over Time</h2><span id='topic+plotHHH4_maps_groups'></span>

<h3>Description</h3>

<p>This is a wrapper for <code><a href="surveillance.html#topic+plotHHH4_maps">plotHHH4_maps</a></code> with prior aggregation
over different (age) groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotHHH4_maps_groups(x, map, districts, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotHHH4_maps_groups_+3A_x">x</code></td>
<td>
<p>an object of class <code>"hhh4"</code>.</p>
</td></tr>
<tr><td><code id="plotHHH4_maps_groups_+3A_map">map</code></td>
<td>
<p>an object inheriting from <code>"SpatialPolygons"</code>.</p>
</td></tr>
<tr><td><code id="plotHHH4_maps_groups_+3A_districts">districts</code></td>
<td>
<p>a factor of length <code>x$nUnit</code> with as many levels as
there are districts and names according to <code>row.names(map)</code>.</p>
</td></tr>
<tr><td><code id="plotHHH4_maps_groups_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="surveillance.html#topic+plotHHH4_maps">plotHHH4_maps</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>see <code><a href="surveillance.html#topic+plotHHH4_maps">plotHHH4_maps</a></code>
</p>

<hr>
<h2 id='plotHHH4_season_groups'>Plot Seasonality of a <code>hhh4</code> Fit by Group</h2><span id='topic+plotHHH4_season_groups'></span>

<h3>Description</h3>

<p>A plot method for models with group-specific seasonality terms that are not
handled correctly by <code><a href="surveillance.html#topic+plotHHH4_season">plotHHH4_season</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotHHH4_season_groups(
  x,
  component = "end",
  seasonStart = 1,
  conf.level = 0.95,
  conf.B = 999,
  col = 1:6,
  xlab = "time",
  ylab = "multiplicative effect",
  ...,
  refline.args = list(),
  yearline.args = list(),
  legend.args = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotHHH4_season_groups_+3A_x">x</code></td>
<td>
<p>an object of class <code>"hhh4"</code>.</p>
</td></tr>
<tr><td><code id="plotHHH4_season_groups_+3A_component">component</code></td>
<td>
<p>character string indicating from which component
seasonality terms should be extracted.</p>
</td></tr>
<tr><td><code id="plotHHH4_season_groups_+3A_seasonstart">seasonStart</code></td>
<td>
<p>an integer defining the <code><a href="surveillance.html#topic+epochInYear">epochInYear</a></code> that
starts a new season (by default the first).</p>
</td></tr>
<tr><td><code id="plotHHH4_season_groups_+3A_conf.level">conf.level</code>, <code id="plotHHH4_season_groups_+3A_conf.b">conf.B</code></td>
<td>
<p>a confidence level for the pointwise confidence
intervals around the group-specific seasonal effects. The confidence
intervals are based on quantiles of <code>conf.B</code> samples from the
asymptotic multivariate normal distribution of the maximum likelihood
estimate. Alternatively, if <code>conf.level = NA</code>, the individual
samples are drawn instead of the confidence lines.
Set <code>conf.level = NULL</code> to disable confidence intervals.</p>
</td></tr>
<tr><td><code id="plotHHH4_season_groups_+3A_col">col</code></td>
<td>
<p>a vector of group-specific colors, recycled as necessary and
passed to <code><a href="graphics.html#topic+matplot">matplot</a></code>.</p>
</td></tr>
<tr><td><code id="plotHHH4_season_groups_+3A_xlab">xlab</code>, <code id="plotHHH4_season_groups_+3A_ylab">ylab</code>, <code id="plotHHH4_season_groups_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="graphics.html#topic+matplot">matplot</a></code>.</p>
</td></tr>
<tr><td><code id="plotHHH4_season_groups_+3A_refline.args">refline.args</code></td>
<td>
<p>a list of arguments for <code><a href="graphics.html#topic+abline">abline</a></code> to change
the style of the horizontal reference line at 1.
This line is omitted if <code>refline.args</code> is not a list.</p>
</td></tr>
<tr><td><code id="plotHHH4_season_groups_+3A_yearline.args">yearline.args</code></td>
<td>
<p>a list of arguments for <code><a href="graphics.html#topic+abline">abline</a></code> to change
the style of the line marking the end of the year at
<code>x$stsObj@freq</code> if <code>seasonStart</code> is not 1.
This line is omitted if <code>yearline.args</code> is not a list.</p>
</td></tr>
<tr><td><code id="plotHHH4_season_groups_+3A_legend.args">legend.args</code></td>
<td>
<p>a list of arguments for <code><a href="graphics.html#topic+legend">legend</a></code> modifying
the internal defaults. If <code>legend.args</code> is not a list, the legend
is omitted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of the plotted point estimates of the multiplicative
seasonal effect by group.
</p>

<hr>
<h2 id='pop2011'>Berlin and German Population by Age Group, 2011</h2><span id='topic+pop2011'></span><span id='topic+popDE'></span>

<h3>Description</h3>

<p>Population numbers from Berlin are available in the
city district x age group (5-year intervals) matrix <code>pop2011</code>.
The corresponding age distribution for whole Germany is stored in the
vector <code>popDE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Berlin population by city district and age group, 2011
pop2011

## German population by age group, 2011
popDE
</code></pre>


<h3>Format</h3>


<dl>
<dt>pop2011:</dt><dd><p>a named, integer-valued
12 (city districts) x 15 (age groups) matrix.</p>
</dd>
<dt>popDE:</dt><dd><p>a named integer vector of length 15 (age groups).</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Sebastian Meyer</p>


<h3>Source</h3>


<dl>
<dt>pop2011:</dt><dd><p>numbers extracted from
<a href="https://www.statistik-berlin-brandenburg.de/">https://www.statistik-berlin-brandenburg.de/</a>
(originally: &lsquo;<span class="file">webapi/opendatabase?id=BevBBBE</span>&rsquo;)
as of 2011-12-31 (before census), published by
<em>Amt fuer Statistik Berlin-Brandenburg</em>
(Statistical Office of Berlin-Brandenburg)
under the &lsquo;CC BY 3.0 DE&rsquo; license
(<a href="https://creativecommons.org/licenses/by/3.0/de/">https://creativecommons.org/licenses/by/3.0/de/</a>).</p>
</dd>
<dt>popDE:</dt><dd><p>numbers extracted from
<a href="https://www-genesis.destatis.de/genesis/online/link/tabellen/12411-0005">https://www-genesis.destatis.de/genesis/online/link/tabellen/12411-0005</a>
as of 2010-12-31, published by
<em>Statistisches Bundesamt</em>
(Destatis, Federal Statistical Office of Germany)
under the &lsquo;Data licence Germany - attribution - Version 2.0&rsquo;
(<a href="https://www.govdata.de/dl-de/by-2-0">https://www.govdata.de/dl-de/by-2-0</a>).</p>
</dd>
</dl>


<hr>
<h2 id='powerC'>Exponentiate a Matrix via Eigendecomposition</h2><span id='topic+powerC'></span><span id='topic+make_powerC'></span>

<h3>Description</h3>

<p>Based on a (contact) matrix <code>C</code>, the function <code>make_powerC</code>
generates a function with a single argument <code>power</code> that returns
the input matrix raised to that power. Matrix exponentiation is thereby
defined via the eigendecomposition of <code>C</code> as
<code class="reqn">C^{power} := E \Lambda^{power} E^{-1}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_powerC(C, normalize = FALSE, truncate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="powerC_+3A_c">C</code></td>
<td>
<p>a square numeric matrix.</p>
</td></tr>
<tr><td><code id="powerC_+3A_normalize">normalize</code></td>
<td>
<p>a logical indicating if <code>C</code> should be normalized
in advance such that all rows sum to 1 (becomes a transition matrix).</p>
</td></tr>
<tr><td><code id="powerC_+3A_truncate">truncate</code></td>
<td>
<p>a logical indicating whether to force entries in the
resulting matrix to be non-negative (by truncation at 0).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function of the <code>power</code>
that returns the exponentiated matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Cnorm &lt;- contactmatrix(normalize = TRUE)
powerC &lt;- make_powerC(Cnorm)
powerC(1)
zapsmall(powerC(0))
powers &lt;- c(0, 0.5, 1, 2)
Cp &lt;- lapply(powers, powerC)
if (require("gridExtra"))
    grid.arrange(
        grobs = mapply(plotC, C = Cp, main = paste("power =", powers),
                       SIMPLIFY = FALSE),
        nrow = 2, ncol = 2)

## truncation to enforce non-negative entries
powerC(0.2)  # some entries become negative for small powers
powerC0 &lt;- make_powerC(Cnorm, truncate = TRUE)
powerC0(0.2)
</code></pre>

<hr>
<h2 id='stationary'>Stationary Distribution of a Transition Matrix</h2><span id='topic+stationary'></span>

<h3>Description</h3>

<p>This auxiliary function determines the stationary distribution
from a transition matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stationary(P)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stationary_+3A_p">P</code></td>
<td>
<p>a transition matrix, i.e., a square matrix where all rows sum to 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the stationary probability vector.
</p>


<h3>Author(s)</h3>

<p>Leonhard Held
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Cgrouped_norm &lt;- contactmatrix(normalize = TRUE)
Cgrouped_norm
(p &lt;- stationary(Cgrouped_norm))
(Cpowered &lt;- make_powerC(Cgrouped_norm)(1e6))
stopifnot(all.equal(Cpowered[1,], p))
</code></pre>

<hr>
<h2 id='stratum'>Extract Strata</h2><span id='topic+stratum'></span><span id='topic+stratum+2Csts-method'></span>

<h3>Description</h3>

<p>Methods to extract strata information from an object.
Here we only define a method for class <code>"sts"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stratum(x, ...)

## S4 method for signature 'sts'
stratum(x, which = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stratum_+3A_x">x</code></td>
<td>
<p>an object of class <code>"sts"</code>.</p>
</td></tr>
<tr><td><code id="stratum_+3A_...">...</code></td>
<td>
<p>further arguments passed to methods.</p>
</td></tr>
<tr><td><code id="stratum_+3A_which">which</code></td>
<td>
<p>an integer (strata dimension) or <code>NULL</code> (to get the plain
<code>colnames</code>, the default).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character vector of strata names of length <code>ncol(x)</code>.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>stratum(sts)</code>: Extract the names of the units, i.e., the <code>colnames</code>,
from a multivariate <code>"sts"</code> object.
If the units result from the interaction of multiple strata
separated by dots, e.g., <code>"region.group"</code>,
the function can also extract the names corresponding to a specific
strata dimension, e.g., <code>which = 2</code> to get the group names.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>noroBEall &lt;- noroBE(by = "all", flatten = TRUE)
stratum(noroBEall)  # just colnames(noroBEall)
stratum(noroBEall, which = 2)  # the age groups
</code></pre>

<hr>
<h2 id='stsplothook'>Hook functions for <code>stsplot_time1</code></h2><span id='topic+stsplothook'></span><span id='topic+stsplothook_highlight'></span>

<h3>Description</h3>

<p>Hook functions can be passed to <code><a href="surveillance.html#topic+stsplot_time1">stsplot_time1</a></code>,
which are evaluated after all the plotting has been done,
and with the hook function environment set to the evaluation environment
of <code>stsplot_time1</code> such that local variables can be accessed.
They are not intended to be called directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stsplothook_highlight(christmas = FALSE, epochInYear = NULL, col = 2, lwd = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stsplothook_+3A_christmas">christmas</code></td>
<td>
<p>logical indicating if Christmas should be highlighted.</p>
</td></tr>
<tr><td><code id="stsplothook_+3A_epochinyear">epochInYear</code></td>
<td>
<p>integer vector of epochs to highlight.</p>
</td></tr>
<tr><td><code id="stsplothook_+3A_col">col</code>, <code id="stsplothook_+3A_lwd">lwd</code></td>
<td>
<p>graphical parameters for the highlighting lines.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sebastian Meyer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(noroBE("agegroups"), hookFunc = stsplothook_highlight(epochInYear=51))
</code></pre>

<hr>
<h2 id='subset.array'>Subset an Array in one Dimension</h2><span id='topic+subset.array'></span>

<h3>Description</h3>

<p>Subset an Array in one Dimension
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'array'
subset(x, dim, i, drop = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset.array_+3A_x">x</code></td>
<td>
<p>an array.</p>
</td></tr>
<tr><td><code id="subset.array_+3A_dim">dim</code></td>
<td>
<p>an integer specifying the dimension to subset.</p>
</td></tr>
<tr><td><code id="subset.array_+3A_i">i</code></td>
<td>
<p>subset index, see <code><a href="base.html#topic++5B">[</a></code>.</p>
</td></tr>
<tr><td><code id="subset.array_+3A_drop">drop</code></td>
<td>
<p>logical indicating if singular dimensions should be dropped,
see <code><a href="base.html#topic++5B">[</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>the more general function <code>extract.array</code> in package
<span class="pkg">R.utils</span>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hhh4contacts:::subset.array(counts, 1, 4:7)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
