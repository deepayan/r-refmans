<!DOCTYPE html><html lang="en"><head><title>Help for package microsynth</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {microsynth}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#microsynth'><p>Synthetic control methods for disaggregated, micro-level data.</p></a></li>
<li><a href='#plot_microsynth'><p>Plotting for microsynth objects.</p></a></li>
<li><a href='#print.microsynth'><p>Displaying microsynth Fits and Results</p></a></li>
<li><a href='#seattledmi'><p>Data for a crime intervention in Seattle, Washington</p></a></li>
<li><a href='#summary.microsynth'><p>Summarizing microsynth Fits and Results</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Synthetic Control Methods with Micro- And Meso-Level Data</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.44</td>
</tr>
<tr>
<td>Description:</td>
<td>A generalization of the 'Synth' package that is designed for
    data at a more granular level (e.g., micro-level). Provides functions
    to construct weights (including propensity score-type weights) and run
    analyses for synthetic control methods with micro- and meso-level
    data; see Robbins, Saunders, and Kilmer (2017)
    &lt;<a href="https://doi.org/10.1080%2F01621459.2016.1213634">doi:10.1080/01621459.2016.1213634</a>&gt; and Robbins and Davenport (2021)
    &lt;<a href="https://doi.org/10.18637%2Fjss.v097.i02">doi:10.18637/jss.v097.i02</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://ssdavenport.github.io/drat">https://ssdavenport.github.io/drat</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, LowRankQP, MASS, rmarkdown, xlsx</td>
</tr>
<tr>
<td>Imports:</td>
<td>kernlab, methods, parallel, pracma, stats, survey, utils</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-29 19:39:38 UTC; macbookpro</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Robbins [aut, cre],
  Steven Davenport [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Robbins &lt;mrobbins@rand.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-30 08:30:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='microsynth'>Synthetic control methods for disaggregated, micro-level data.</h2><span id='topic+microsynth'></span>

<h3>Description</h3>

<p>Implements the synthetic control method for micro-level data as outlined in
Robbins, Saunders, and Kilmer (2017).  <code>microsynth</code> is designed for use
in assessment of the effect of an intervention using longitudinal data.
However, it may also be used to calculate propensity score-type weights in
cross-sectional data. <code>microsynth</code> is a generalization
of <code>Synth</code> (see Abadie and Gardeazabal (2003) and Abadie, Diamond,
Hainmueller (2010, 2011, 2014)) that is designed for data at a more granular
level (e.g., micro-level). For more details see the help vignette:
<code>vignette('microsynth', package = 'microsynth')</code>.
</p>
<p><code>microsynth</code> develops a synthetic control group by searching for weights
that exactly match a treatment group to a synthetic control group across
a number of variables while also minimizing the discrepancy between the
synthetic control group and the treatment group across a set second set of
variables.  <code>microsynth</code> works in two primary steps: 1) calculation of
weights and 2) calculation of results.  Time series plots of treatment
vs. synthetic control for pertinent outcomes may be performed using the
function <code>plot.microsynth()</code>.
</p>
<p>The time range over which data are observed is segmented into pre- and
post-intervention periods.  Treatment is matched to synthetic control
across the pre-intervention period, and the effect of the intervention
is assessed across the post-intervention (or evaluation) period.  The input
<code>end.pre</code> (which gives the last pre-intervention time period) is used to
delineate between pre- and post-intervention.  Note that if the intervention
is not believed to have an instantaneous effect, <code>end.pre</code> should indicate
the time of the intervention.
</p>
<p>Variables are categorized as outcomes (which are time-variant) and covariates
(which are time-invariant).  Using the respective inputs <code>match.covar</code>
and <code>match.out</code>, the user specifies across which covariates and outcomes
(and which pre-intervention time points of the outcomes) treatment is to be
exactly matched to synthetic control.  The inputs <code>match.covar.min</code> and
<code>match.out.min</code> are similar but instead specify variables across which
treatment is to be matched to synthetic control as closely as possible.  If
there are no variables specified in <code>match.covar.min</code> and
<code>match.out.min</code>, the function <code>calibrate()</code> from the <code>survey</code>
package is used to calculate weights.  Otherwise, the function
<code>LowRankQP()</code> from the package of the same name is used, if it is
available on the user's machine (it is now in the CRAN archive, so would need
to be installed by other means). If the <code>LowRankQP</code> package is unavailable,
it will use <code>ipop()</code> from the <code>kernlab</code> package.  In the event
that the model specified by <code>match.covar</code> and <code>match.out</code> is not
feasible (i.e., weights do not exist that exactly match treatment and
synthetic control subject to the given constraints), a less restrictive
backup model is used.
</p>
<p><code>microsynth</code> has the capability to perform
statistical inference using Taylor series linearization, a jackknife and
permutation methods.  Several sets of weights are calculated.  A set of main
weights is calculated that is used to determine a point estimate of the
intervention effect.  The main weights can also be used to perform inferences
on the point estimator via Taylor series linearization.  If a jackknife is to
be used, one set of weights is calculated for each jackknife replication
group, and if permutation methods are to be used, one set of weights is
calculated for each permutation group.  If treatment and synthetic control
are not easily matched based upon the model outlined in <code>match.covar</code>
and <code>match.out</code> (i.e., an exact solution is infeasible or nearly
infeasible), it is recommended that the jackknife not be used for inference.
</p>
<p>The software provides the user the option to output overall findings in an Excel
file.  For each outcome variable, the results list the estimated treatment
effect, as well as confidence intervals of the effect and p-values of a
hypothesis test that assesses whether the effect is zero.   Such results are
produced as needed for each of the three methods of statistical inference
noted above.  <code>microsynth</code> can also apply an omnibus test that examines
the presence of a treatment effect jointly across several outcomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>microsynth(
  data,
  idvar,
  intvar,
  timevar = NULL,
  start.pre = NULL,
  end.pre = NULL,
  end.post = NULL,
  match.out = TRUE,
  match.covar = TRUE,
  match.out.min = NULL,
  match.covar.min = NULL,
  result.var = TRUE,
  omnibus.var = result.var,
  period = 1,
  scale.var = "Intercept",
  confidence = 0.9,
  test = "twosided",
  perm = 0,
  jack = 0,
  use.survey = TRUE,
  cut.mse = Inf,
  check.feas = FALSE,
  use.backup = FALSE,
  w = NULL,
  max.mse = 0.01,
  maxit = 250,
  cal.epsilon = 1e-04,
  calfun = "linear",
  bounds = c(0, Inf),
  result.file = NULL,
  printFlag = TRUE,
  n.cores = TRUE,
  ret.stats = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="microsynth_+3A_data">data</code></td>
<td>
<p>A data frame.  If longitudinal, the data must be entered in tall
format (e.g., at the case/time-level with one row for each time period for
each case).  Missingness is not allowed.  All individuals must have non-NA
values of all variables at all time points.</p>
</td></tr>
<tr><td><code id="microsynth_+3A_idvar">idvar</code></td>
<td>
<p>A character string that gives the variable in <code>data</code> that
identifies multiple records from the same case.</p>
</td></tr>
<tr><td><code id="microsynth_+3A_intvar">intvar</code></td>
<td>
<p>A character string that gives the variable in <code>data</code> that
corresponds to the intervention variable.  The intervention variable
indicates which cases (and times) have received the intervention.  The
variable should be binary, with a 1 indicating treated and 0 indicating
untreated.  If <code>end.pre</code>
is specified, a case is considered treated if there is 1 or more non-zero
entries in the column indicated by <code>intvar</code> for that case (at any time
point).  If <code>end.pre</code> is not specified, an attempt will be made to
use <code>intvar</code> to determine which time periods will be considered
post-intervention (i.e., the times contained in the evaluation period).
In this case, the evaluation period is considered to begin at the time of
the first non-zero entry in <code>intvar</code>).</p>
</td></tr>
<tr><td><code id="microsynth_+3A_timevar">timevar</code></td>
<td>
<p>A character string that gives the variable in
<code>data</code> that differentiates multiple records from the same case.  Can be
set to <code>NULL</code> only when used with cross-sectional data (i.e., with one
observation per entry in <code>idvar</code>).</p>
</td></tr>
<tr><td><code id="microsynth_+3A_start.pre">start.pre</code></td>
<td>
<p>An integer indicating the time point that corresponds to the
beginning of the pre-intervention period used for
matching.  When <code>start.pre = NULL</code> (default), it is reset to the
minimum time appearing in the column given by <code>timevar</code>.  If
<code>match.out</code> (and <code>match.out.min</code>) are given in list format,
<code>start.pre</code> is ignored except for plotting.</p>
</td></tr>
<tr><td><code id="microsynth_+3A_end.pre">end.pre</code></td>
<td>
<p>An integer that gives the final time point of the
pre-intervention period.  That is, <code>end.pre</code> is the last time at
which treatment and synthetic control will be matched to one another.
All time points
following <code>end.pre</code> are considered to be post-intervention and the
behavior of outcomes will be compared between the treatment and synthetic
control groups across those time periods.
Setting <code>end.pre = NULL</code> will begin the post-intervention period
at the time
that corresponds to the first non-zero entry in the column indicated by
<code>intvar</code>.</p>
</td></tr>
<tr><td><code id="microsynth_+3A_end.post">end.post</code></td>
<td>
<p>An integer that gives the maximum post-intervention time that
is taken into when compiling results.  That is, the treatment and synthetic
control groups are compared across the outcomes listed in <code>result.var</code>
from the first time following the intervention up to <code>end.post</code>.  Can
be a vector (ordered, increasing) giving multiple values of
<code>end.post</code>.  In this case, the results will be compiled for each entry
in <code>end.post</code>.  When <code>end.post = NULL</code> (the default), it is reset
to the maximum time that appears in the column given by <code>timevar</code>.</p>
</td></tr>
<tr><td><code id="microsynth_+3A_match.out">match.out</code></td>
<td>
<p>Either A) logical, B) a vector of variable names that
indicates across which time-varying variables treatment is to be exactly matched
to synthetic control pre-intervention, or C) a
list consisting of variable names and timespans over which variables should
be aggregated before matching.  Note that outcome variables and time-varying
covariates should be included in <code>match.out</code>.
</p>
<p>If <code>match.out = TRUE</code> (the default), it is set equal to
<code>result.var</code>; if <code>match.out = NULL</code> or <code>match.out = FALSE</code>,
no outcome variables are factored into the calculation of weights. If
<code>match.out</code> is passed a vector of variable
names, then weights are calculated to match treatment and synthetic control
for the value of each variable that appears in <code>match.out</code> at each
time point from <code>start.pre</code> to <code>end.pre</code>. Otherwise, to allow
more flexibility, <code>match.out</code> may also be a list that gives
an outcome-based model outlining more specific constraints that are to be
exactly satisfied within calibration weighting.  In this case, each entry
of <code>match.out</code> is a vector of integers, and the names of entries of
<code>match.out</code> are the outcome variables to which the vectors correspond.
Each element of the vectors gives a number of time points that are to be
aggregated for the respective outcome, with the first element indicating
time points immediately prior the beginning of the post-intervention
period.  The sum of
the elements in each vector should not exceed the number of
pre-intervention time periods in the data.
</p>
<p>The following examples show the proper formatting of <code>match.out</code> as a
list.  Assume that there are two outcomes, Y1 and Y2 (across which
treatment is to be matched to synthetic control), and <code>end.pre = 10</code>
(i.e., the post-intervention period begins at time 11).
Let <code>match.out = list('Y1' = c(1, 3, 3), 'Y2'=
  c(2,5,1))</code>.  According to this specification, treatment is to be matched to
synthetic control across: a) The value of Y1 at time 10; b) the sum of Y1
across times 7, 8 and 9; c) the sum of Y1 across times 4, 5 and 6; e) The
sum of Y2 across times time 9 and 10; e) the sum of Y2 across times 4, 5,
6, 7, and 8; f) the value of Y2 at time 3.  Likewise, if <code>match.out =
  list('Y1' = 10, 'Y2'= rep(1,10))</code>, Y1 is matched to synthetic control
the entire aggregated pre-intervention time range, and Y2 is matched
at each pre-intervention time point individually.</p>
</td></tr>
<tr><td><code id="microsynth_+3A_match.covar">match.covar</code></td>
<td>
<p>Either a logical or a vector of variable names that
indicates which time invariant covariates
are to be used for weighting.  Weights are
calculated so that treatment and synthetic control exactly match across
these variables.  If <code>match.covar = TRUE</code>, it is set equal to a vector
of variable names corresponding to the time invariant variables that
appear in <code>data</code>.  If <code>match.covar = FALSE</code>, it is set to
<code>NULL</code> (in which case no time-invariant variables are used for matching
when calculating weights).</p>
</td></tr>
<tr><td><code id="microsynth_+3A_match.out.min">match.out.min</code></td>
<td>
<p>A vector or list of the same format as <code>match.out</code>
that is used to specify additional time-varying variables to match
on, but which need not be matched exactly. Weights are calculated so the
distance is minimized between treatment and synthetic control across these
variables. If <code>match.out.min = NULL</code>, no outcome-based constraints
beyond those indicated by <code>match.out</code> are imposed (i.e., all outcome
variables will be matched on exactly).</p>
</td></tr>
<tr><td><code id="microsynth_+3A_match.covar.min">match.covar.min</code></td>
<td>
<p>A vector of variable names that indicates supplemental
time invariant variables that are to be used for weighting, for which exact
matches are not required. Weights are calculated so the distance is
minimized between treatment and synthetic control across these variables.</p>
</td></tr>
<tr><td><code id="microsynth_+3A_result.var">result.var</code></td>
<td>
<p>A vector of variable names giving the outcome
variables for which results will be reported.  Time-varying covariates
should be excluded from <code>result.var</code>.  If <code>result.var = TRUE</code>
(the default), <code>result.var</code> is set as being equal to all time-varying
variables that appear in <code>data</code>.  If <code>result.var = NULL</code> or
<code>result.var = FALSE</code>, results are not tabulated.</p>
</td></tr>
<tr><td><code id="microsynth_+3A_omnibus.var">omnibus.var</code></td>
<td>
<p>A vector of variable names that indicates the outcome
variables that are to be used within the calculation of the omnibus
statistic.  Can also be a logical indicator.  When <code>omnibus.var =
  TRUE</code>, it is reset as being equal to <code>result.var</code>.  When
<code>omnibus.var = NULL</code> or <code>omnibus = FALSE</code>, no omnibus statistic
is calculated.  <code>omnibus.var</code> should not contain elements not in
<code>result.var</code>.</p>
</td></tr>
<tr><td><code id="microsynth_+3A_period">period</code></td>
<td>
<p>An integer that gives the granularity of the data that will be
used for plotting and compiling results.  If <code>match.out</code> and
<code>match.out.min</code> are provided a vector of variable names, it will also
affect the calculation of weights used for matching. In this case, matching
of treatment and synthetic control is performed at a temporal granularity
defined by <code>period</code>. For instance, if monthly data are provided and
<code>period = 3</code>, data are aggregated to quarters for plots and results
(and weighting unless otherwise specified). If <code>match.out</code> and
<code>match.out.min</code> are provided a list, <code>period</code> only affects plots
and how results are displayed.
</p>
<p>Note that plotting is performed with
<code>plot.microsynth()</code>; however, a <code>microsynth</code> object is required as
input for that function and <code>period</code> should be specified in the creation
of that object.</p>
</td></tr>
<tr><td><code id="microsynth_+3A_scale.var">scale.var</code></td>
<td>
<p>A variable name.  When comparing the treatment group to all
cases, the latter is scaled to the size of the former with respect to the
variable indicated by <code>scale.var</code>.  Defaults to the number of units
receiving treatment (i.e., the intercept).</p>
</td></tr>
<tr><td><code id="microsynth_+3A_confidence">confidence</code></td>
<td>
<p>The level of confidence for confidence intervals.</p>
</td></tr>
<tr><td><code id="microsynth_+3A_test">test</code></td>
<td>
<p>The type of hypothesis test (one-sided lower, one-sided upper, or
two-sided) that is used when calculating p-values.  Entries of
<code>'lower'</code>, <code>'upper'</code>, and <code>'twosided'</code> are recognized.</p>
</td></tr>
<tr><td><code id="microsynth_+3A_perm">perm</code></td>
<td>
<p>An integer giving the number of permutation groups that are used.
If <code>perm = 0</code>, no permutation groups are generated, permutation
weights are not calculated, and permutations do not factor into the
reported results.  <code>perm</code> is set to the number of possible permutation
groups if the former exceeds the latter.</p>
</td></tr>
<tr><td><code id="microsynth_+3A_jack">jack</code></td>
<td>
<p>An integer giving the number of replication groups that are used
for the jackknife.  <code>jack</code> can also be a logical indicator.  If
<code>jack = 0</code> or <code>jack = FALSE</code>, no jackknife replication groups are
generated, jackknife weights are not calculated, and the jackknife is not
considered when reporting results.  If <code>jack = TRUE</code>, it is reset to
being equal to the minimum between the number of total cases in the
treatment group and the total number of cases in the control group.
<code>jack</code> is also reset to that minimum if it, as entered, exceeds that
minimum.</p>
</td></tr>
<tr><td><code id="microsynth_+3A_use.survey">use.survey</code></td>
<td>
<p>If <code>use.survey = TRUE</code>, Taylor series linearization is
applied to the estimated treatment effect within each permutation group.
Setting <code>use.survey = TRUE</code> makes for better inference but increases
computation time substantially.  Confidence intervals for permutation
groups are calculated only when <code>use.survey = TRUE</code>.</p>
</td></tr>
<tr><td><code id="microsynth_+3A_cut.mse">cut.mse</code></td>
<td>
<p>The maximum error (given as mean-squared error) permissible
for permutation groups.  Permutation groups with a larger than permissible
error are dropped when calculating results.  The mean-squared error is only
calculated over constraints that are to be exactly satisfied.</p>
</td></tr>
<tr><td><code id="microsynth_+3A_check.feas">check.feas</code></td>
<td>
<p>A logical indicator of whether or not the feasibility of
the model specified by <code>match.out</code> is evaluated prior to calculation
of weights.  If <code>check.feas = TRUE</code>, feasibility is assessed. If
<code>match.out</code> is found to not specify a feasible model, a less
restrictive feasible backup model will be applied to calculate the main
weights and for jackknife and permutation methods.</p>
</td></tr>
<tr><td><code id="microsynth_+3A_use.backup">use.backup</code></td>
<td>
<p>A logical variable that, when true, indicates whether a
backup model should be used whenever the model specified by
<code>match.out</code> yields unsatisfactory weights.  Weights are deemed to be
unsatisfactory if they do not sufficiently satisfy the constraints imposed
by <code>match.out</code> and <code>match.covar</code>.  Different backup models may be
used for each of the main, jackknife or permutation weights as needed.</p>
</td></tr>
<tr><td><code id="microsynth_+3A_w">w</code></td>
<td>
<p>A <code>microsynth</code> object or a list of the form as returned
by a prior application of <code>microsynth</code>.
If <code>w = NULL</code>, weights are calculated from scratch.
Entering a <code>non-NULL</code> value affords the user the ability to
use previously calculated  weights.</p>
</td></tr>
<tr><td><code id="microsynth_+3A_max.mse">max.mse</code></td>
<td>
<p>The maximum error (given as mean-squared error) permissible
for constraints that are to be exactly satisfied.  If <code>max.mse</code> is not
satisfied by these constraints, and either <code>check.feas = TRUE</code> or
<code>use.backup = TRUE</code>, then back-up models are used.</p>
</td></tr>
<tr><td><code id="microsynth_+3A_maxit">maxit</code></td>
<td>
<p>The maximum number of iterations used within the calibration
routine (<code>calibrate()</code> from the <code>survey</code> package) for
calculating weights.</p>
</td></tr>
<tr><td><code id="microsynth_+3A_cal.epsilon">cal.epsilon</code></td>
<td>
<p>The tolerance used within the calibration routine
(<code>calibrate()</code> from the <code>survey</code> package) for calculating
weights.</p>
</td></tr>
<tr><td><code id="microsynth_+3A_calfun">calfun</code></td>
<td>
<p>The calibration function used within the calibration routine
(<code>calibrate()</code> from the <code>survey</code> package) for calculating
weights.</p>
</td></tr>
<tr><td><code id="microsynth_+3A_bounds">bounds</code></td>
<td>
<p>Bounds for calibration weighting (fed into the
<code>calibrate()</code> from the <code>survey</code> package).</p>
</td></tr>
<tr><td><code id="microsynth_+3A_result.file">result.file</code></td>
<td>
<p>A character string giving the name of a file that will be
created in the home directory containing results.  If <code>result.file =
  NULL</code> (the default), no file is created.  If <code>end.post</code> has length 1,
a <code>.csv</code> file is created.  If <code>end.post</code> has length greater than
one, a formatted <code>.xlsx</code> file is created with one tab for each element
of <code>end.post</code>.  If <code>result.file</code> has a <code>.xlsx</code> (or
<code>.xls</code>) extension (e.g., the last five characters of result.file are
'.xlsx'), an <code>.xlsx</code> file is created regardless of the length of
<code>end.post</code>.</p>
</td></tr>
<tr><td><code id="microsynth_+3A_printflag">printFlag</code></td>
<td>
<p>If TRUE, <code>microsynth</code> will print history on console. Use
<code>printFlag = FALSE</code> for silent computation.</p>
</td></tr>
<tr><td><code id="microsynth_+3A_n.cores">n.cores</code></td>
<td>
<p>The number of CPU cores to use for parallelization. If
<code>n.cores</code> is not specified by the user, it is guessed using the
<code>detectCores</code> function in the parallel package.  If <code>TRUE</code>
(the default), it is set as <code>detectCores()</code>.  If <code>NULL</code>, it is set as
<code>detectCores() - 1</code>.  If <code>FALSE</code>, it is set as <code>1</code>, in which case
parallelization is not invoked.  Note that the
documentation for <code>detectCores</code> makes clear that it is not failsafe and
could return a spurious number of available cores.</p>
</td></tr>
<tr><td><code id="microsynth_+3A_ret.stats">ret.stats</code></td>
<td>
<p>if set to <code>TRUE</code>, returns four additional elements:
<code>stats</code>, <code>stats1</code>, <code>stats2</code> and <code>delta.out</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>microsynth</code> requires specification of the following inputs:
<code>data</code>, <code>idvar</code>, <code>intvar</code>.  <code>data</code> is a longitudinal data
frame; <code>idvar</code> and <code>intvar</code> are character strings that specific
pertinent columns of <code>data</code>.  In longitudinal data, <code>timevar</code>
should be specified.  Furthermore, specification of <code>match.out</code> and
<code>match.covar</code> is recommended.
</p>
<p><code>microsynth</code> can also be used to calculate propensity score-type weights
in cross sectional data (in which case <code>timevar</code> does not need to be
specified) as proposed by Hainmueller (2012).
</p>
<p><code>microsynth</code> calculates weights using
<code>survey::calibrate()</code> from the <code>survey</code> package in circumstances
where a feasible solution exists for all constraints, whereas
<code>LowRankQP::LowRankQP()</code> is used to assess feasibility and to
calculate weights in the event that a feasible solution to all constraints
does not exist.  The <code>LowRankQP</code> routine is memory-intensive and can
run quite slowly in data that have a large number of cases.  To prevent
<code>LowRankQP</code> from being used, set <code>match.out.min = NULL</code>,
<code>match.covar.min= NULL</code>, <code>check.feas = FALSE</code>, and
<code>use.backup = FALSE</code>.
</p>


<h3>Value</h3>

<p><code>microsynth</code> returns a list with up to five elements: a)
<code>w</code>, b) <code>Results</code>, c) <code>svyglm.stats</code>, and
d) <code>Plot.Stats</code>, and e) <code>info</code>.
</p>
<p><code>w</code> is a list with six elements: a) <code>Weights</code>, b) <code>Intervention</code>,
c) <code>MSE</code>, d) <code>Model</code>, e) <code>Summary</code>, and f) <code>keep.groups</code>.
Assume there are
C total sets of weights calculated, where C = <code>1 + jack + perm</code>, and
there are N total cases across the treatment and control groups.
<code>w$Weights</code> is an N x C matrix, where each column provides a set of
weights.  <code>w$Intervention</code> is an N x C matrix made of logical
indicators that indicate whether or not the case in the respective row is
considered treated (at any point in time) for the respective column.
Entries of <code>NA</code> are to be dropped for the respective jackknife
replication group (<code>NA</code>s only appear in jackknife weights).
<code>w$MSE</code> is a 6 x C matrix that give the MSEs for each set of weights.
MSEs are listed for the primary and secondary constraints for the first,
second, and third models.  Note that the primary constraints differ for each
model (see Robbins and Davenport, 2021). <code>w$Model</code> is a length-C vector that
indicates whether backup models were used in the calculation of each set of
weights.  <code>w$keep.groups</code> is a logical vector indicating which groups
are to be used in analysis (groups that are not used have pre-intervention
MSE greater than <code>cut.mse</code>.  <code>w$Summary</code> is a three-column matrix
that (for treatment,
synthetic control, and the full dataset), shows aggregate values
of the variables across which treatment and synthetic control are matched.
The summary, which is tabulated only for the primary weights, is also
printed by <code>microsynth</code> while weights are being calculated.
</p>
<p>Further, <code>Results</code> is a list where each element gives the final
results for each value of <code>end.post</code>.  Each element of <code>Results</code>
is itself a matrix with each row corresponding to an outcome variable (and
a row for the omnibus test, if used) and each column denotes estimates of
the intervention effects and p-values, upper, and lower bounds of
confidence intervals as found using Taylor series linearization (Linear),
jackknife (jack), and permutation (perm) methods where needed.
</p>
<p>In addition, <code>svyglm.stats</code> is a list where each element is a
matrix that includes the output from the regression models run using the
<code>svyglm()</code> function to estimate the treatment effect.  The list has one
element for each value of <code>end.post</code>, and the matrices each have
one row per variable in <code>result.var</code>.
</p>
<p>Next, <code>Plot.Stats</code> contains the data that are displayed in the
plots which may be generated using <code>plot.microsynth()</code>.
<code>Plot.Stats</code> is a list with four elements (Treatment, Control,
All, Difference).  The first three elements are matrices with one row per
outcome variable and one column per time point.  The last element (which
gives the treatment minus control values) is an array that contains data
for each permutation group in addition to the true treatment area.
Specifically, <code>Plot.Stats$Difference[,,1]</code> contains the time series of
treatment minus control for the true intervention group;
<code>Plot.Stats$Difference[,,i+1]</code> contains the time series of treatment
minus control for the i^th permutation group.
</p>
<p>Next, <code>info</code> documents some input parameters for display by
<code>print()</code>. A summary of weighted matching variables and of results
can be viewed using <code><a href="base.html#topic+summary">summary</a></code>
</p>
<p>Lastly, if <code>ret.stats</code> is set to <code>TRUE</code>, four additional elements
are returned: <code>stats</code>, <code>stats1</code>, <code>stats2</code> and <code>delta.out</code>.
<code>stats</code> contains elements with the basic statistics that are the same as
the main microsynth output: outcomes in treatment, control and percentage change.
<code>stats1</code> are the estimates of <code>svyglm()</code> adjusted by their standard
errors. <code>stats2</code> is the percent change in the observed value from each
outcome from the hypothetical outcome absent intervention. <code>delta.out</code> is
a Taylor series linearization used to approximate the variance of the estimator.
</p>


<h3>References</h3>

<p>Abadie A, Diamond A, Hainmueller J (2010). Synthetic control
methods for comparative case studies: Estimating the effect of California's
tobacco control program.? <em>Journal of the American Statistical
Association</em>, 105(490), 493-505.
</p>
<p>Abadie A, Diamond A, Hainmueller J (2011). Synth: An R Package for
Synthetic Control Methods in Comparative Case Studies.? <em>Journal
of Statistical Software</em>, 42(13), 1-17.
</p>
<p>Abadie A, Diamond A, Hainmueller J (2015). Comparative politics and the
synthetic control method. <em>American Journal of Political Science</em>,
59(2), 495-510.
</p>
<p>Abadie A, Gardeazabal J (2003). The economic costs of conflict: A case
study of the Basque Country.? <em>American Economic Review</em>, pp. 113-132.
</p>
<p>Hainmueller, J. (2012), Entropy Balancing for Causal Effects: A
Multivariate Reweighting Method to Produce Balanced Samples in
Observational Studies,? <em>Political Analysis</em>, 20, 25-46.
</p>
<p>Robbins MW, Saunders J, Kilmer B (2017). A framework for synthetic control
methods with high-dimensional, micro-level data: Evaluating a neighborhood-
specific crime intervention,? <em>Journal of the American Statistical
Association</em>, 112(517), 109-126.
</p>
<p>Robbins MW, Davenport S (2021). microsynth: Synthetic Control Methods for
Disaggregated and Micro-Level Data in R,? <em>Journal of Statistical
Software</em>, 97(2), doi:10.18637/jss.v097.i02.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Use seattledmi, block-level panel data, to evaluate a crime intervention.

# Declare time-variant (outcome) and time-invariant variables for matching
cov.var &lt;- c('TotalPop', 'BLACK', 'HISPANIC', 'Males_1521',
       'HOUSEHOLDS', 'FAMILYHOUS', 'FEMALE_HOU', 'RENTER_HOU', 'VACANT_HOU')

match.out &lt;- c('i_felony', 'i_misdemea', 'i_drugs', 'any_crime')
set.seed(99199) # for reproducibility



# Perform matching and estimation, without permutations or jackknife
# runtime: &lt; 1 min


sea1 &lt;- microsynth(seattledmi,
                  idvar='ID', timevar='time', intvar='Intervention',
                  start.pre=1, end.pre=12, end.post=16,
                  match.out=match.out, match.covar=cov.var,
                  result.var=match.out, omnibus.var=match.out,
                  test='lower',
                  n.cores = min(parallel::detectCores(), 2))

# View results
summary(sea1)
plot_microsynth(sea1)


## Not run: 
# Repeat matching and estimation, with permutations and jackknife
# Set permutations and jack-knife to very few groups (2) for
# quick demonstration only.
# runtime: ~30 min
sea2 &lt;- microsynth(seattledmi,
                     idvar='ID', timevar='time', intvar='Intervention',
                     start.pre=1, end.pre=12, end.post=c(14, 16),
                     match.out=match.out, match.covar=cov.var,
                     result.var=match.out, omnibus.var=match.out,
                     test='lower',
                     perm=250, jack=TRUE,
                     result.file=file.path(tempdir(), 'ExResults2.xlsx'),
                     n.cores = min(parallel::detectCores(), 2))

# View results
summary(sea2)
plot_microsynth(sea2)

# Specify additional outcome variables for matching, which makes
# matching harder.
match.out &lt;- c('i_robbery','i_aggassau','i_burglary','i_larceny',
       'i_felony','i_misdemea','i_drugsale','i_drugposs','any_crime')

# Perform matching, setting check.feas = T and use.backup = T
# to ensure model feasibility
# runtime: ~40 minutes
sea3 &lt;- microsynth(seattledmi,
                   idvar='ID', timevar='time', intvar='Intervention',
                   end.pre=12,
                   match.out=match.out, match.covar=cov.var,
                   result.var=match.out, perm=250, jack=0,
                   test='lower', check.feas=TRUE, use.backup = TRUE,
                   result.file=file.path(tempdir(), 'ExResults3.xlsx'),
                   n.cores = min(parallel::detectCores(), 2))


# Aggregate outcome variables before matching, to boost model feasibility
match.out &lt;- list( 'i_robbery'=rep(2, 6), 'i_aggassau'=rep(2, 6),
         'i_burglary'=rep(1, 12), 'i_larceny'=rep(1, 12),
         'i_felony'=rep(2, 6), 'i_misdemea'=rep(2, 6),
         'i_drugsale'=rep(4, 3), 'i_drugposs'=rep(4, 3),
         'any_crime'=rep(1, 12))

# After aggregation, use.backup and cheack.feas no longer needed
# runtime: ~40 minutes
sea4 &lt;- microsynth(seattledmi, idvar='ID', timevar='time',
         intvar='Intervention', match.out=match.out, match.covar=cov.var,
         start.pre=1, end.pre=12, end.post=16,
         result.var=names(match.out), omnibus.var=names(match.out),
         perm=250, jack = TRUE, test='lower',
         result.file=file.path(tempdir(), 'ExResults4.xlsx'),
         n.cores = min(parallel::detectCores(), 2))

# View results
summary(sea4)
plot_microsynth(sea4)


# Generate weights only (for four variables)
match.out &lt;- c('i_felony', 'i_misdemea', 'i_drugs', 'any_crime')

# runtime: ~ 20 minutes
sea5 &lt;- microsynth(seattledmi,  idvar='ID', timevar='time',
         intvar='Intervention', match.out=match.out, match.covar=cov.var,
         start.pre=1, end.pre=12, end.post=16,
         result.var=FALSE, perm=250, jack=TRUE,
         n.cores = min(parallel::detectCores(), 2))

# View weights
summary(sea5)

# Generate results only
sea6 &lt;- microsynth(seattledmi, idvar='ID', timevar='time',
          intvar='Intervention',
          start.pre=1, end.pre=12, end.post=c(14, 16),
          result.var=match.out, test='lower',
          w=sea5, result.file=file.path(tempdir(), 'ExResults6.xlsx'),
          n.cores = min(parallel::detectCores(), 2))

# View results (including previously-found weights)
summary(sea6)

# Generate plots only
plot_microsynth(sea6, plot.var=match.out[1:2])

# Apply microsynth in the traditional setting of Synth
# Create macro-level (small n) data, with 1 treatment unit
set.seed(86879)
ids.t &lt;- names(table(seattledmi$ID[seattledmi$Intervention==1]))
ids.c &lt;- setdiff(names(table(seattledmi$ID)), ids.t)
ids.synth &lt;- c(base::sample(ids.t, 1), base::sample(ids.c, 100))
seattledmi.one &lt;- seattledmi[is.element(seattledmi$ID,
           as.numeric(ids.synth)), ]

# Apply microsynth to the new macro-level data
# runtime: &lt; 5 minutes
sea8 &lt;- microsynth(seattledmi.one, idvar='ID', timevar='time',
           intvar='Intervention',
           start.pre=1, end.pre=12, end.post=16,
           match.out=match.out[4],
           match.covar=cov.var, result.var=match.out[4],
           test='lower', perm=250, jack=FALSE,
           check.feas=TRUE, use.backup=TRUE,
           n.cores = min(parallel::detectCores(), 2))

# View results
summary(sea8)
plot_microsynth(sea8)

# Use microsynth to calculate propensity score-type weights
# Prepare cross-sectional data at time of intervention
seattledmi.cross &lt;- seattledmi[seattledmi$time==16, colnames(seattledmi)!='time']

# Apply microsynth to find propensity score-type weights
# runtime: ~5 minutes
sea9 &lt;- microsynth(seattledmi.cross, idvar='ID', intvar='Intervention',
             match.out=FALSE, match.covar=cov.var, result.var=match.out,
             test='lower', perm=250, jack=TRUE,
             n.cores = min(parallel::detectCores(), 2))

# View results
summary(sea9)

## End(Not run)

</code></pre>

<hr>
<h2 id='plot_microsynth'>Plotting for microsynth objects.</h2><span id='topic+plot_microsynth'></span>

<h3>Description</h3>

<p>Using a <code>microsynth</code> object as an input, this function gives time
series plots of selected outcomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_microsynth(
  ms,
  plot.var = NULL,
  start.pre = NULL,
  end.pre = NULL,
  end.post = NULL,
  file = NULL,
  sep = TRUE,
  plot.first = NULL,
  legend.spot = "bottomleft",
  height = NULL,
  width = NULL,
  at = NULL,
  labels = NULL,
  all = "cases",
  main.tc = NULL,
  main.diff = NULL,
  xlab.tc = NULL,
  xlab.diff = NULL,
  ylab.tc = NULL,
  ylab.diff = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_microsynth_+3A_ms">ms</code></td>
<td>
<p>A microsynth object</p>
</td></tr>
<tr><td><code id="plot_microsynth_+3A_plot.var">plot.var</code></td>
<td>
<p>A vector of variable names giving the outcome variables that
are shown in plots.  If <code>plot.var = NULL</code>, all outcome variables that
are included in <code>ms</code> are plotted.  Only variables contained in
the input <code>result.var</code> as used in the creation of <code>ms</code> can
be plotted using <code>plot()</code>.</p>
</td></tr>
<tr><td><code id="plot_microsynth_+3A_start.pre">start.pre</code></td>
<td>
<p>An integer indicating the time point that corresponds to the
earliest time period that will be plotted.
When <code>start.pre = NULL</code>, it is reset to the
minimum time appearing in <code>ms</code>.</p>
</td></tr>
<tr><td><code id="plot_microsynth_+3A_end.pre">end.pre</code></td>
<td>
<p>An integer that gives the final time point of the
pre-intervention period.  That is, <code>end.pre</code> is the last time at
which treatment and synthetic control will were matched to one another.
All time points
following <code>end.pre</code> are considered to be post-intervention and the
behavior of outcomes will be compared between the treatment and synthetic
control groups across those time periods.
If <code>end.pre = NULL</code> the end of the pre-intervention period will be
determined from the object <code>ms</code>.</p>
</td></tr>
<tr><td><code id="plot_microsynth_+3A_end.post">end.post</code></td>
<td>
<p>An integer that gives final time point that will be plotted.
When <code>end.post = NULL</code> (the default), it is reset
to the maximum time that appears in <code>ms</code>.</p>
</td></tr>
<tr><td><code id="plot_microsynth_+3A_file">file</code></td>
<td>
<p>A character string giving the name of file that will be
created in the home directory containing plots.
The name should have a <code>.pdf</code> extension.</p>
</td></tr>
<tr><td><code id="plot_microsynth_+3A_sep">sep</code></td>
<td>
<p>If <code>sep = TRUE</code>, separate plots will be generated for each
outcome.  Applicable only if plots are saved to file (
<code>plot.file</code> is <code>non-NULL</code>). To change display of plots produced
as output, use <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot_microsynth_+3A_plot.first">plot.first</code></td>
<td>
<p>The number of permutation groups to plot.</p>
</td></tr>
<tr><td><code id="plot_microsynth_+3A_legend.spot">legend.spot</code></td>
<td>
<p>The location of the legend in the plots.</p>
</td></tr>
<tr><td><code id="plot_microsynth_+3A_height">height</code></td>
<td>
<p>The height of the graphics region (in inches)
when a pdf is created.</p>
</td></tr>
<tr><td><code id="plot_microsynth_+3A_width">width</code></td>
<td>
<p>The width of the graphics region (in inches)
when a pdf is created.</p>
</td></tr>
<tr><td><code id="plot_microsynth_+3A_at">at</code></td>
<td>
<p>A vector that gives the location of user-specified x-axis labels.
<code>at</code> should be a (numeric) subset of the named time points contained
in <code>ms</code> (e.g., <code>colnames(ms$Plot.Stats$Treatment)</code>).</p>
</td></tr>
<tr><td><code id="plot_microsynth_+3A_labels">labels</code></td>
<td>
<p>A vector of the same length as <code>at</code> that gives the names
of the labels that will be marked at the times indicated by <code>at</code> in
the plots.</p>
</td></tr>
<tr><td><code id="plot_microsynth_+3A_all">all</code></td>
<td>
<p>A scalar character string giving the unit name for cases.
If <code>NULL</code>, a third curve showing the overall outcome levels is
not plotted.</p>
</td></tr>
<tr><td><code id="plot_microsynth_+3A_main.tc">main.tc</code></td>
<td>
<p>A scalar (or a vector of the same length as <code>plot.var</code>)
character string giving the title to be used for the first plots
(that show treatment and control).  Defaults to <code>plot.var</code>.</p>
</td></tr>
<tr><td><code id="plot_microsynth_+3A_main.diff">main.diff</code></td>
<td>
<p>A scalar (or a vector of the same length as <code>plot.var</code>)
character string giving the title to be used for the second plots
(that show differences between treatment and control).
Defaults to <code>plot.var</code>.</p>
</td></tr>
<tr><td><code id="plot_microsynth_+3A_xlab.tc">xlab.tc</code></td>
<td>
<p>A scalar (or a vector of the same length as <code>plot.var</code>)
character string giving the x-axis labels to be used for the first plots
(that show treatment and control).  Defaults to <code>''</code>.</p>
</td></tr>
<tr><td><code id="plot_microsynth_+3A_xlab.diff">xlab.diff</code></td>
<td>
<p>A scalar (or a vector of the same length as <code>plot.var</code>)
character string giving the x-axis labels to be used for the second plots
(that show differences between treatment and control).
Defaults to <code>''</code>.</p>
</td></tr>
<tr><td><code id="plot_microsynth_+3A_ylab.tc">ylab.tc</code></td>
<td>
<p>A scalar (or a vector of the same length as <code>plot.var</code>)
character string giving the y-axis labels to be used for the first plots
(that show treatment and control).  Defaults to <code>plot.var</code>.</p>
</td></tr>
<tr><td><code id="plot_microsynth_+3A_ylab.diff">ylab.diff</code></td>
<td>
<p>A scalar (or a vector of the same length as <code>plot.var</code>)
character string giving the y-axis labels to be used for the second plots
(that show differences between treatment and control).
Defaults to <code>'Treatment - Control'</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots are given over both pre- and
intervention time periods and shown in terms of raw outcome values or
treatment/control differences.  Time series of permutation groups may be
overlaid to help illustrate statistical uncertainty.
</p>
<p>Only required input is a parameter <code>ms</code> which is a microsynth object.
</p>


<h3>Value</h3>

<p>No return value, called for side effects (i.e., to produce plots
of outcome values and treatment/control differences, with the option to
write to file).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Declare time-variant (outcome) and time-invariant variables for matching
cov.var &lt;- c('TotalPop', 'BLACK', 'HISPANIC', 'Males_1521',
       'HOUSEHOLDS', 'FAMILYHOUS', 'FEMALE_HOU', 'RENTER_HOU', 'VACANT_HOU')

match.out &lt;- c('i_felony', 'i_misdemea', 'i_drugs', 'any_crime')

set.seed(99199) # for reproducibility



# Perform matching and estimation, without permutations or jackknife
# runtime: &lt;1 min
sea1 &lt;- microsynth(seattledmi,
                  idvar='ID', timevar='time', intvar='Intervention',
                  start.pre=1, end.pre=12, end.post=16,
                  match.out=match.out, match.covar=cov.var,
                  result.var=match.out, omnibus.var=match.out,
                  test='lower',
                  n.cores = min(parallel::detectCores(), 2))

# Plot with default settings in the GUI.
plot_microsynth(sea1)

# Make plots, display, and save to a single file (plots.pdf).
plot_microsynth(sea1, file = file.path(tempdir(), 'plots.pdf'), sep = FALSE)

# Make plots for only one outcome, display, and save to a single file.
plot_microsynth(sea1, plot.var = 'any_crime',
     file = file.path(tempdir(), 'plots.pdf'), sep = FALSE)


</code></pre>

<hr>
<h2 id='print.microsynth'>Displaying microsynth Fits and Results</h2><span id='topic+print.microsynth'></span>

<h3>Description</h3>

<p>Print method for class 'microsynth'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'microsynth'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.microsynth_+3A_x">x</code></td>
<td>
<p>A <code>microsynth</code> object produced by <code>microsynth()</code></p>
</td></tr>
<tr><td><code id="print.microsynth_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The functions <code>print.microsynth</code> and
<code>summary.microsynth</code> display information about the microsynth
fit and estimation results, if available.
</p>
<p>The output includes two parts: 1) a display of key input parameters;
and 2) estimated results, in a similar format as they
appear when saved to .csv or .xlsx., once for each specified
post-intervention evaluation time.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Use seattledmi, block-level panel data, to evaluate a crime intervention.

# Declare time-variant (outcome) and time-invariant variables for matching
cov.var &lt;- c('TotalPop', 'BLACK', 'HISPANIC', 'Males_1521',
       'HOUSEHOLDS', 'FAMILYHOUS', 'FEMALE_HOU', 'RENTER_HOU', 'VACANT_HOU')

match.out &lt;- c('i_felony', 'i_misdemea', 'i_drugs', 'any_crime')
set.seed(99199) # for reproducibility

# Perform matching and estimation, without permutations or jackknife
# runtime: &lt; 1 min


sea1 &lt;- microsynth(seattledmi,
                  idvar='ID', timevar='time', intvar='Intervention',
                  start.pre=1, end.pre=12, end.post=16,
                  match.out=match.out, match.covar=cov.var,
                  result.var=match.out, omnibus.var=match.out,
                  test='lower',
                  n.cores = min(parallel::detectCores(), 2))

# View results
print(sea1)


</code></pre>

<hr>
<h2 id='seattledmi'>Data for a crime intervention in Seattle, Washington</h2><span id='topic+seattledmi'></span>

<h3>Description</h3>

<p>The dataset contains information used to evaluate a Drug Market Intervention
(DMI) occurring in parts of Seattle, Washington in 2013. The data include
2010 block-level Census data and counts of crime reported by the Seattle
Police, by crime type. Crime data are available for one year prior to the
intervention and two years after. DMIs are an intervention intended to
disrupt drug markets by targeting enforcement priorities at specific market
participants. The intervention was applied to 39 blocks in Seattle's
International District.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seattledmi
</code></pre>


<h3>Format</h3>

<p>A data frame with 154,272 rows and 22 columns, consisting of 9,642
unique blocks with 16 (quarterly) observations each. It contains the
following variables:
</p>

<dl>
<dt>ID</dt><dd><p>unique Census block ID</p>
</dd>
<dt>time</dt><dd><p>time unit (in quarters)</p>
</dd>
<dt>Intervention</dt><dd><p>time-variant binary indicator; all treated units
receive 0 pre-intervention and 1 from the start of the intervention onward,
while untreated cases receive 0s throughout</p>
</dd>
<dt>i_robbery</dt><dd><p>number of robberies reported in that block-quarter
(time-variant)</p>
</dd>
<dt>i_aggassau</dt><dd><p>number of aggravated assaults reported</p>
</dd>
<dt>i_burglary</dt><dd><p>number of burglaries reported</p>
</dd>
<dt>i_larceny</dt><dd><p>number of larcenies reported</p>
</dd>
<dt>i_felony</dt><dd><p>number of felony crimes reported</p>
</dd>
<dt>i_misdemea</dt><dd><p>number of misdemeanor crimes reported</p>
</dd>
<dt>i_drugsale</dt><dd><p>number of drug sales reported</p>
</dd>
<dt>i_drugposs</dt><dd><p>number of drug possession incidents reported</p>
</dd>
<dt>i_drugs</dt><dd><p>number of drug sale or possession incidents reported</p>
</dd>
<dt>any_crime</dt><dd><p>number of all crimes reported</p>
</dd>
<dt>TotalPop</dt><dd><p>number of residents</p>
</dd>
<dt>BLACK</dt><dd><p>number of African American residents</p>
</dd>
<dt>HISPANIC</dt><dd><p>number of Hispanic residents</p>
</dd>
<dt>Males_1521</dt><dd><p>number of male residents aged 15-21</p>
</dd>
<dt>HOUSEHOLDS</dt><dd><p>number of households</p>
</dd>
<dt>FAMILYHOUS</dt><dd><p>number of family households</p>
</dd>
<dt>FEMALE_HOU</dt><dd><p>number of female-headed households</p>
</dd>
<dt>RENTER_HOU</dt><dd><p>number of households occupied by renters</p>
</dd>
<dt>VACANT_HOU</dt><dd><p>number of vacant housing units</p>
</dd>
</dl>



<h3>Source</h3>

<p>Demographic data obtained from the 2010 Census, and administrative
crime data from the Seattle Police Department.
</p>

<hr>
<h2 id='summary.microsynth'>Summarizing microsynth Fits and Results</h2><span id='topic+summary.microsynth'></span>

<h3>Description</h3>

<p>Summary method for class 'microsynth'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'microsynth'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.microsynth_+3A_object">object</code></td>
<td>
<p>A <code>microsynth</code> object produced by <code>microsynth()</code></p>
</td></tr>
<tr><td><code id="summary.microsynth_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The functions <code>print.microsynth</code> and
<code>summary.microsynth</code> displays information about the microsynth
fit and estimation results, if available.
</p>
<p>The output includes two parts: 1) a matching summary that compares
characteristics of the treatment to the synthetic control and the
population; and 2) estimated results, in a similar format as they
appear when saved to .csv or .xlsx., once for each specified
post-intervention evaluation time.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Use seattledmi, block-level panel data, to evaluate a crime intervention.

# Declare time-variant (outcome) and time-invariant variables for matching
cov.var &lt;- c('TotalPop', 'BLACK', 'HISPANIC', 'Males_1521',
       'HOUSEHOLDS', 'FAMILYHOUS', 'FEMALE_HOU', 'RENTER_HOU', 'VACANT_HOU')

match.out &lt;- c('i_felony', 'i_misdemea', 'i_drugs', 'any_crime')
set.seed(99199) # for reproducibility

# Perform matching and estimation, without permutations or jackknife
# runtime: &lt; 1 min


sea1 &lt;- microsynth(seattledmi,
                  idvar='ID', timevar='time', intvar='Intervention',
                  start.pre=1, end.pre=12, end.post=16,
                  match.out=match.out, match.covar=cov.var,
                  result.var=match.out, omnibus.var=match.out,
                  test='lower',
                  n.cores = min(parallel::detectCores(), 2))

# View results
summary(sea1)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
