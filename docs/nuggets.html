<!DOCTYPE html><html lang="en-US"><head><title>Help for package nuggets</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {nuggets}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#nuggets-package'><p>nuggets: Extensible Data Pattern Searching Framework</p></a></li>
<li><a href='#dichotomize'><p>Create dummy columns from logicals or factors in a data frame</p></a></li>
<li><a href='#dig'><p>Search for patterns of custom type</p></a></li>
<li><a href='#dig_associations'><p>Search for association rules</p></a></li>
<li><a href='#dig_baseline_contrasts'><p>Search for conditions that yield in statistically significant one-sample</p>
test in selected variables.</a></li>
<li><a href='#dig_complement_contrasts'><p>Search for conditions that provide significant differences in selected</p>
variables to the rest of the data table</a></li>
<li><a href='#dig_contrasts'><p>Search for paired contrast patterns</p></a></li>
<li><a href='#dig_correlations'><p>Search for conditional correlations</p></a></li>
<li><a href='#dig_grid'><p>Search for grid-based rules</p></a></li>
<li><a href='#dig_implications'><p>Search for association rules</p></a></li>
<li><a href='#dig_paired_baseline_contrasts'><p>Search for conditions that provide significant differences between paired</p>
variables</a></li>
<li><a href='#format_condition'><p>Format a vector of predicates into a string with a condition</p></a></li>
<li><a href='#is_degree'><p>Tests whether the given argument is a numeric value from the interval</p>
<code class="reqn">[0,1]</code></a></li>
<li><a href='#is_subset'><p>Determine whether the first vector is a subset of the second vector</p></a></li>
<li><a href='#partition'><p>Convert columns of data frame to Boolean or fuzzy sets</p></a></li>
<li><a href='#var_grid'><p>Create a tibble of combinations of selected column names</p></a></li>
<li><a href='#var_names'><p>Extract variable names from predicates</p></a></li>
<li><a href='#which_antichain'><p>Return indices of first elements of the list, which are incomparable with preceding</p>
elements.</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Extensible Data Pattern Searching Framework</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-01-08</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michal Burda &lt;michal.burda@osu.cz&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Extensible framework for
    subgroup discovery (Atzmueller (2015) &lt;<a href="https://doi.org/10.1002%2Fwidm.1144">doi:10.1002/widm.1144</a>&gt;),
    contrast patterns (Chen (2022) &lt;<a href="https://doi.org/10.48550%2FarXiv.2209.13556">doi:10.48550/arXiv.2209.13556</a>&gt;),
    emerging patterns (Dong (1999) &lt;<a href="https://doi.org/10.1145%2F312129.312191">doi:10.1145/312129.312191</a>&gt;),
    association rules (Agrawal (1994) <a href="https://www.vldb.org/conf/1994/P487.PDF">https://www.vldb.org/conf/1994/P487.PDF</a>) and
    conditional correlations (Hájek (1978) &lt;<a href="https://doi.org/10.1007%2F978-3-642-66943-9">doi:10.1007/978-3-642-66943-9</a>&gt;).
    Both crisp (Boolean, binary) and fuzzy data are supported.
    It generates conditions in the form of elementary conjunctions, evaluates
    them on a dataset and checks the induced sub-data for interesting statistical
    properties. A user-defined function may be defined to evaluate on each generated
    condition to search for custom patterns.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://beerda.github.io/nuggets/">https://beerda.github.io/nuggets/</a>,
<a href="https://github.com/beerda/nuggets">https://github.com/beerda/nuggets</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/beerda/nuggets/issues">https://github.com/beerda/nuggets/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, lifecycle, methods, purrr, Rcpp, rlang, stats, stringr,
tibble, tidyr, tidyselect</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, testthat</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++17</td>
</tr>
<tr>
<td>Suggests:</td>
<td>arules, dplyr, testthat (&ge; 3.0.0), xml2, withr, knitr,
rmarkdown</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-08 09:38:26 UTC; michal</td>
</tr>
<tr>
<td>Author:</td>
<td>Michal Burda <a href="https://orcid.org/0000-0002-4182-4407"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-08 10:20:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='nuggets-package'>nuggets: Extensible Data Pattern Searching Framework</h2><span id='topic+nuggets'></span><span id='topic+nuggets-package'></span>

<h3>Description</h3>

<p>Extensible framework for subgroup discovery (Atzmueller (2015) <a href="https://doi.org/10.1002/widm.1144">doi:10.1002/widm.1144</a>), contrast patterns (Chen (2022) <a href="https://doi.org/10.48550/arXiv.2209.13556">doi:10.48550/arXiv.2209.13556</a>), emerging patterns (Dong (1999) <a href="https://doi.org/10.1145/312129.312191">doi:10.1145/312129.312191</a>), association rules (Agrawal (1994) <a href="https://www.vldb.org/conf/1994/P487.PDF">https://www.vldb.org/conf/1994/P487.PDF</a>) and conditional correlations (Hájek (1978) <a href="https://doi.org/10.1007/978-3-642-66943-9">doi:10.1007/978-3-642-66943-9</a>). Both crisp (Boolean, binary) and fuzzy data are supported. It generates conditions in the form of elementary conjunctions, evaluates them on a dataset and checks the induced sub-data for interesting statistical properties. A user-defined function may be defined to evaluate on each generated condition to search for custom patterns.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Michal Burda <a href="mailto:michal.burda@osu.cz">michal.burda@osu.cz</a> (<a href="https://orcid.org/0000-0002-4182-4407">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://beerda.github.io/nuggets/">https://beerda.github.io/nuggets/</a>
</p>
</li>
<li> <p><a href="https://github.com/beerda/nuggets">https://github.com/beerda/nuggets</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/beerda/nuggets/issues">https://github.com/beerda/nuggets/issues</a>
</p>
</li></ul>


<hr>
<h2 id='dichotomize'>Create dummy columns from logicals or factors in a data frame</h2><span id='topic+dichotomize'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>This function is deprecated because <code><a href="#topic+partition">partition()</a></code> is more general and
can be used to create dummy columns as well.
</p>
<p>Create dummy logical columns from selected columns of the data frame.
Dummy columns may be created for logical or factor columns as follows:
</p>

<ul>
<li><p> for logical column <code>col</code>, a pair of columns is created named <code>col=T</code>
and <code>col=F</code> where the former (resp. latter) is equal to the original
(resp. negation of the original);
</p>
</li>
<li><p> for factor column <code>col</code>, a new logical column is created for each
level <code>l</code> of the factor <code>col</code> and named as <code>col=l</code> with a value set
to TRUE wherever the original column is equal to <code>l</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>dichotomize(.data, what = everything(), ..., .keep = FALSE, .other = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dichotomize_+3A_.data">.data</code></td>
<td>
<p>a data frame to be processed</p>
</td></tr>
<tr><td><code id="dichotomize_+3A_what">what</code></td>
<td>
<p>a tidyselect expression (see
<a href="https://tidyselect.r-lib.org/articles/syntax.html">tidyselect syntax</a>)
selecting the columns to be processed</p>
</td></tr>
<tr><td><code id="dichotomize_+3A_...">...</code></td>
<td>
<p>further tidyselect expressions for selecting the columns to
be processed</p>
</td></tr>
<tr><td><code id="dichotomize_+3A_.keep">.keep</code></td>
<td>
<p>whether to keep the original columns. If FALSE, the original
columns are removed from the result.</p>
</td></tr>
<tr><td><code id="dichotomize_+3A_.other">.other</code></td>
<td>
<p>whether to put into result the rest of columns that were not
specified for dichotomization in <code>what</code> argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with selected columns replaced with dummy columns.
</p>


<h3>Author(s)</h3>

<p>Michal Burda
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dichotomize(CO2, Plant:Treatment, .other = TRUE)
# -&gt;
partition(CO2, Plant:Treatment)
</code></pre>

<hr>
<h2 id='dig'>Search for patterns of custom type</h2><span id='topic+dig'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>A general function for searching for patterns of custom type. The function
allows for the selection of columns of <code>x</code> to be used as condition
predicates. The function enumerates all possible conditions in the form of
elementary conjunctions of selected predicates, and for each condition,
a user-defined callback function <code>f</code> is executed. The callback function is
intended to perform some analysis and return an object representing a pattern
or patterns related to the condition. <code><a href="#topic+dig">dig()</a></code> returns a list of these
returned objects.
</p>
<p>The callback function <code>f</code> may have some arguments that are listed in the
<code>f</code> argument description. The algorithm provides information about the
generated condition based on the present arguments.
</p>
<p>Additionally to <code>condition</code>, the function allows for the selection of
the so-called <em>focus</em> predicates. The focus predicates, a.k.a. <em>foci</em>, are
predicates that are evaluated within each condition and some additional
information is provided to the callback function about them.
</p>
<p><code>dig()</code> allows to specify some restrictions on the generated conditions,
such as:
</p>

<ul>
<li><p> the minimum and maximum length of the condition (<code>min_length</code> and
<code>max_length</code> arguments).
</p>
</li>
<li><p> the minimum support of the condition (<code>min_support</code> argument). Support
of the condition is the relative frequency of the condition in the dataset
<code>x</code>.
</p>
</li>
<li><p> the minimum support of the focus (<code>min_focus_support</code> argument). Support
of the focus is the relative frequency of rows such that all condition
predicates AND the focus are TRUE on it. Foci with support lower than
<code>min_focus_support</code> are filtered out.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>dig(
  x,
  f,
  condition = everything(),
  focus = NULL,
  disjoint = var_names(colnames(x)),
  min_length = 0,
  max_length = Inf,
  min_support = 0,
  min_focus_support = min_support,
  min_conditional_focus_support = 0,
  max_support = 1,
  filter_empty_foci = FALSE,
  t_norm = "goguen",
  max_results = Inf,
  verbose = FALSE,
  threads = 1L,
  error_context = list(arg_x = "x", arg_f = "f", arg_condition = "condition", arg_focus =
    "focus", arg_disjoint = "disjoint", arg_min_length = "min_length", arg_max_length =
    "max_length", arg_min_support = "min_support", arg_min_focus_support =
    "min_focus_support", arg_min_conditional_focus_support =
    "min_conditional_focus_support", arg_max_support = "max_support",
    arg_filter_empty_foci = "filter_empty_foci", arg_t_norm = "t_norm", arg_max_results =
    "max_results", arg_verbose = "verbose", arg_threads = "threads", 
     call =
    current_env())
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dig_+3A_x">x</code></td>
<td>
<p>a matrix or data frame. The matrix must be numeric (double) or logical.
If <code>x</code> is a data frame then each column must be either numeric (double) or
logical.</p>
</td></tr>
<tr><td><code id="dig_+3A_f">f</code></td>
<td>
<p>the callback function executed for each generated condition. This
function may have some of the following arguments. Based on the present
arguments, the algorithm would provide information about the generated
condition:
</p>

<ul>
<li> <p><code>condition</code> - a named integer vector of column indices that represent
the predicates of the condition. Names of the vector correspond to
column names;
</p>
</li>
<li> <p><code>support</code> - a numeric scalar value of the current condition's support;
</p>
</li>
<li> <p><code>indices</code> - a logical vector indicating the rows satisfying the condition;
</p>
</li>
<li> <p><code>weights</code> - (similar to indices) weights of rows to which they satisfy
the current condition;
</p>
</li>
<li> <p><code>pp</code> - a value of a contingency table, <code>condition &amp; focus</code>.
<code>pp</code> is a named numeric vector where each value is a support of conjunction
of the condition with a foci column (see the <code>focus</code> argument to specify,
which columns). Names of the vector are foci column names.
</p>
</li>
<li> <p><code>pn</code> - a value of a contingency table, <code style="white-space: pre;">&#8288;condition &amp; neg focus&#8288;</code>.
<code>pn</code> is a named numeric vector where each value is a support of conjunction
of the condition with a negated foci column (see the <code>focus</code> argument to
specify, which columns are foci) - names of the vector are foci column names.
</p>
</li>
<li> <p><code>np</code> - a value of a contingency table, <code style="white-space: pre;">&#8288;neg condition &amp; focus&#8288;</code>.
<code>np</code> is a named numeric vector where each value is a support of conjunction
of the negated condition with a foci column (see the <code>focus</code> argument to
specify, which columns are foci) - names of the vector are foci column names.
</p>
</li>
<li> <p><code>nn</code> - a value of a contingency table, <code style="white-space: pre;">&#8288;neg condition &amp; neg focus&#8288;</code>.
<code>nn</code> is a named numeric vector where each value is a support of conjunction
of the negated condition with a negated foci column (see the <code>focus</code>
argument to specify, which columns are foci) - names of the vector are foci
column names.
</p>
</li>
<li> <p><code>foci_supports</code> - (deprecated, use <code>pp</code> instead)
a named numeric vector of supports of foci columns
(see <code>focus</code> argument to specify, which columns are foci) - names of the
vector are foci column names.
</p>
</li></ul>
</td></tr>
<tr><td><code id="dig_+3A_condition">condition</code></td>
<td>
<p>a tidyselect expression (see
<a href="https://tidyselect.r-lib.org/articles/syntax.html">tidyselect syntax</a>)
specifying the columns to use as condition predicates</p>
</td></tr>
<tr><td><code id="dig_+3A_focus">focus</code></td>
<td>
<p>a tidyselect expression (see
<a href="https://tidyselect.r-lib.org/articles/syntax.html">tidyselect syntax</a>)
specifying the columns to use as focus predicates</p>
</td></tr>
<tr><td><code id="dig_+3A_disjoint">disjoint</code></td>
<td>
<p>an atomic vector of size equal to the number of columns of <code>x</code>
that specifies the groups of predicates: if some elements of the <code>disjoint</code>
vector are equal, then the corresponding columns of <code>x</code> will NOT be
present together in a single condition. If <code>x</code> is prepared with
<code><a href="#topic+partition">partition()</a></code>, using the <code><a href="#topic+var_names">var_names()</a></code> function on <code>x</code>'s column names
is a convenient way to create the <code>disjoint</code> vector.</p>
</td></tr>
<tr><td><code id="dig_+3A_min_length">min_length</code></td>
<td>
<p>the minimum size (the minimum number of predicates) of the
condition to be generated (must be greater or equal to 0). If 0, the empty
condition is generated in the first place.</p>
</td></tr>
<tr><td><code id="dig_+3A_max_length">max_length</code></td>
<td>
<p>The maximum size (the maximum number of predicates) of the
condition to be generated. If equal to Inf, the maximum length of conditions
is limited only by the number of available predicates.</p>
</td></tr>
<tr><td><code id="dig_+3A_min_support">min_support</code></td>
<td>
<p>the minimum support of a condition to trigger the callback
function for it. The support of the condition is the relative frequency
of the condition in the dataset <code>x</code>. For logical data, it equals to the
relative frequency of rows such that all condition predicates are TRUE on it.
For numerical (double) input, the support is computed as the mean (over all
rows) of multiplications of predicate values.</p>
</td></tr>
<tr><td><code id="dig_+3A_min_focus_support">min_focus_support</code></td>
<td>
<p>the minimum support of a focus, for the focus to be passed
to the callback function. The support of the focus is the relative frequency
of rows such that all condition predicates AND the focus are TRUE on it.
For numerical (double) input, the support is computed as the mean (over all
rows) of multiplications of predicate values.</p>
</td></tr>
<tr><td><code id="dig_+3A_min_conditional_focus_support">min_conditional_focus_support</code></td>
<td>
<p>the minimum relative support of a focus
within a condition. The conditional support of the focus is the relative
frequency of rows with focus being TRUE within rows where the condition is
TRUE.</p>
</td></tr>
<tr><td><code id="dig_+3A_max_support">max_support</code></td>
<td>
<p>the maximum support of a condition to trigger the callback</p>
</td></tr>
<tr><td><code id="dig_+3A_filter_empty_foci">filter_empty_foci</code></td>
<td>
<p>a logical scalar indicating whether to skip conditions,
for which no focus remains available after filtering by <code>min_focus_support</code>.
If <code>TRUE</code>, the condition is passed to the callback function only if at least
one focus remains after filtering. If <code>FALSE</code>, the condition is passed to the
callback function regardless of the number of remaining foci.</p>
</td></tr>
<tr><td><code id="dig_+3A_t_norm">t_norm</code></td>
<td>
<p>a t-norm used to compute conjunction of weights. It must be one of
<code>"goedel"</code> (minimum t-norm), <code>"goguen"</code> (product t-norm), or <code>"lukas"</code>
(Lukasiewicz t-norm).</p>
</td></tr>
<tr><td><code id="dig_+3A_max_results">max_results</code></td>
<td>
<p>the maximum number of generated conditions to execute the
callback function on. If the number of found conditions exceeds
<code>max_results</code>, the function stops generating new conditions and returns
the results. To avoid long computations during the search, it is recommended
to set <code>max_results</code> to a reasonable positive value. Setting <code>max_results</code>
to <code>Inf</code> will generate all possible conditions.</p>
</td></tr>
<tr><td><code id="dig_+3A_verbose">verbose</code></td>
<td>
<p>a logical scalar indicating whether to print progress messages.</p>
</td></tr>
<tr><td><code id="dig_+3A_threads">threads</code></td>
<td>
<p>the number of threads to use for parallel computation.</p>
</td></tr>
<tr><td><code id="dig_+3A_error_context">error_context</code></td>
<td>
<p>a list of details to be used in error messages.
This argument is useful when <code>dig()</code> is called from another
function to provide error messages, which refer to arguments of the
calling function. The list must contain the following elements:
</p>

<ul>
<li> <p><code>arg_x</code> - the name of the argument <code>x</code> as a character string
</p>
</li>
<li> <p><code>arg_f</code> - the name of the argument <code>f</code> as a character string
</p>
</li>
<li> <p><code>arg_condition</code> - the name of the argument <code>condition</code> as a character
string
</p>
</li>
<li> <p><code>arg_focus</code> - the name of the argument <code>focus</code> as a character string
</p>
</li>
<li> <p><code>arg_disjoint</code> - the name of the argument <code>disjoint</code> as a character
string
</p>
</li>
<li> <p><code>arg_min_length</code> - the name of the argument <code>min_length</code> as a character
string
</p>
</li>
<li> <p><code>arg_max_length</code> - the name of the argument <code>max_length</code> as a character
string
</p>
</li>
<li> <p><code>arg_min_support</code> - the name of the argument <code>min_support</code> as a character
string
</p>
</li>
<li> <p><code>arg_min_focus_support</code> - the name of the argument <code>min_focus_support</code>
as a character string
</p>
</li>
<li> <p><code>arg_max_support</code> - the name of the argument <code>max_support</code> as a character
</p>
</li>
<li> <p><code>arg_filter_empty_foci</code> - the name of the argument <code>filter_empty_foci</code>
as a character string
</p>
</li>
<li> <p><code>arg_t_norm</code> - the name of the argument <code>t_norm</code> as a character string
</p>
</li>
<li> <p><code>arg_threads</code> - the name of the argument <code>threads</code> as a character string
</p>
</li>
<li> <p><code>call</code> - an environment in which to evaluate the error messages.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of results provided by the callback function <code>f</code>.
</p>


<h3>Author(s)</h3>

<p>Michal Burda
</p>


<h3>See Also</h3>

<p><code><a href="#topic+partition">partition()</a></code>, <code><a href="#topic+var_names">var_names()</a></code>, <code><a href="#topic+dig_grid">dig_grid()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)

# Prepare iris data for use with dig()
d &lt;- partition(iris, .breaks = 2)

# Call f() for each condition with support &gt;= 0.5. The result is a list
# of strings representing the conditions.
dig(x = d,
    f = function(condition) {
        format_condition(names(condition))
    },
    min_support = 0.5)

# Create a more complex pattern object - a list with some statistics
res &lt;- dig(x = d,
           f = function(condition, support) {
               list(condition = format_condition(names(condition)),
                    support = support)
           },
           min_support = 0.5)
print(res)

# Format the result as a data frame
do.call(rbind, lapply(res, as_tibble))

# Within each condition, evaluate also supports of columns starting with
# "Species"
res &lt;- dig(x = d,
           f = function(condition, support, pp) {
               c(list(condition = format_condition(names(condition))),
                 list(condition_support = support),
                 as.list(pp / nrow(d)))
           },
           condition = !starts_with("Species"),
           focus = starts_with("Species"),
           min_support = 0.5,
           min_focus_support = 0)

# Format the result as a tibble
do.call(rbind, lapply(res, as_tibble))

# For each condition, create multiple patterns based on the focus columns
res &lt;- dig(x = d,
           f = function(condition, support, pp) {
               lapply(seq_along(pp), function(i) {
                   list(condition = format_condition(names(condition)),
                        condition_support = support,
                        focus = names(pp)[i],
                        focus_support = pp[[i]] / nrow(d))
               })
           },
           condition = !starts_with("Species"),
           focus = starts_with("Species"),
           min_support = 0.5,
           min_focus_support = 0)

# As res is now a list of lists, we need to flatten it before converting to
# a tibble
res &lt;- unlist(res, recursive = FALSE)

# Format the result as a tibble
do.call(rbind, lapply(res, as_tibble))
</code></pre>

<hr>
<h2 id='dig_associations'>Search for association rules</h2><span id='topic+dig_associations'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Association rules identify conditions (<em>antecedents</em>) under which
a specific feature (<em>consequent</em>) is present very often.
</p>

<dl>
<dt>Scheme:</dt><dd><p><code style="white-space: pre;">&#8288;A =&gt; C&#8288;</code><br /><br />
If condition <code>A</code> is satisfied, then the feature <code>C</code> is present very often.</p>
</dd>
<dt>Example:</dt><dd><p><code style="white-space: pre;">&#8288;university_edu &amp; middle_age &amp; IT_industry =&gt; high_income&#8288;</code><br /><br />
People in <em>middle age</em> with <em>university education</em> working in IT industry
have very likely a <em>high income</em>.</p>
</dd>
</dl>

<p>Antecedent <code>A</code> is usually a set of predicates, and consequent <code>C</code> is a single
predicate.
</p>
<p>For the following explanations we need a mathematical function <code class="reqn">supp(I)</code>, which
is defined for a set <code class="reqn">I</code> of predicates as a relative frequency of rows satisfying
all predicates from <code class="reqn">I</code>. For logical data, <code class="reqn">supp(I)</code> equals to the relative
frequency of rows, for which all predicates <code class="reqn">i_1, i_2, \ldots, i_n</code> from <code class="reqn">I</code> are TRUE.
For numerical (double) input, <code class="reqn">supp(I)</code> is computed as the mean (over all rows)
of truth degrees of the formula <code style="white-space: pre;">&#8288;i_1 AND i_2 AND ... AND i_n&#8288;</code>, where
<code>AND</code> is a triangular norm selected by the <code>t_norm</code> argument.
</p>
<p>Association rules are characterized with the following quality measures.
</p>
<p><em>Length</em> of a rule is the number of elements in the antecedent.
</p>
<p><em>Coverage</em> of a rule is equal to <code class="reqn">supp(A)</code>.
</p>
<p><em>Consequent support</em> of a rule is equal to <code class="reqn">supp(\{c\})</code>.
</p>
<p><em>Support</em> of a rule is equal to <code class="reqn">supp(A \cup \{c\})</code>.
</p>
<p><em>Confidence</em> of a rule is the fraction <code class="reqn">supp(A) / supp(A \cup \{c\})</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dig_associations(
  x,
  antecedent = everything(),
  consequent = everything(),
  disjoint = var_names(colnames(x)),
  min_length = 0L,
  max_length = Inf,
  min_coverage = 0,
  min_support = 0,
  min_confidence = 0,
  contingency_table = FALSE,
  measures = NULL,
  t_norm = "goguen",
  max_results = Inf,
  verbose = FALSE,
  threads = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dig_associations_+3A_x">x</code></td>
<td>
<p>a matrix or data frame with data to search in. The matrix must be
numeric (double) or logical. If <code>x</code> is a data frame then each column
must be either numeric (double) or logical.</p>
</td></tr>
<tr><td><code id="dig_associations_+3A_antecedent">antecedent</code></td>
<td>
<p>a tidyselect expression (see
<a href="https://tidyselect.r-lib.org/articles/syntax.html">tidyselect syntax</a>)
specifying the columns to use in the antecedent (left) part of the rules</p>
</td></tr>
<tr><td><code id="dig_associations_+3A_consequent">consequent</code></td>
<td>
<p>a tidyselect expression (see
<a href="https://tidyselect.r-lib.org/articles/syntax.html">tidyselect syntax</a>)
specifying the columns to use in the consequent (right) part of the rules</p>
</td></tr>
<tr><td><code id="dig_associations_+3A_disjoint">disjoint</code></td>
<td>
<p>an atomic vector of size equal to the number of columns of <code>x</code>
that specifies the groups of predicates: if some elements of the <code>disjoint</code>
vector are equal, then the corresponding columns of <code>x</code> will NOT be
present together in a single condition. If <code>x</code> is prepared with
<code><a href="#topic+partition">partition()</a></code>, using the <code><a href="#topic+var_names">var_names()</a></code> function on <code>x</code>'s column names
is a convenient way to create the <code>disjoint</code> vector.</p>
</td></tr>
<tr><td><code id="dig_associations_+3A_min_length">min_length</code></td>
<td>
<p>the minimum length, i.e., the minimum number of predicates in the
antecedent, of a rule to be generated. Value must be greater or equal to 0.
If 0, rules with empty antecedent are generated in the first place.</p>
</td></tr>
<tr><td><code id="dig_associations_+3A_max_length">max_length</code></td>
<td>
<p>The maximum length, i.e., the maximum number of predicates in the
antecedent, of a rule to be generated. If equal to Inf, the maximum length
is limited only by the number of available predicates.</p>
</td></tr>
<tr><td><code id="dig_associations_+3A_min_coverage">min_coverage</code></td>
<td>
<p>the minimum coverage of a rule in the dataset <code>x</code>.
(See Description for the definition of <em>coverage</em>.)</p>
</td></tr>
<tr><td><code id="dig_associations_+3A_min_support">min_support</code></td>
<td>
<p>the minimum support of a rule in the dataset <code>x</code>.
(See Description for the definition of <em>support</em>.)</p>
</td></tr>
<tr><td><code id="dig_associations_+3A_min_confidence">min_confidence</code></td>
<td>
<p>the minimum confidence of a rule in the dataset <code>x</code>.
(See Description for the definition of <em>confidence</em>.)</p>
</td></tr>
<tr><td><code id="dig_associations_+3A_contingency_table">contingency_table</code></td>
<td>
<p>a logical value indicating whether to provide a contingency
table for each rule. If <code>TRUE</code>, the columns <code>pp</code>, <code>pn</code>, <code>np</code>, and <code>nn</code> are
added to the output table. These columns contain the number of rows satisfying
the antecedent and the consequent, the antecedent but not the consequent,
the consequent but not the antecedent, and neither the antecedent nor the
consequent, respectively.</p>
</td></tr>
<tr><td><code id="dig_associations_+3A_measures">measures</code></td>
<td>
<p>a character vector specifying the additional quality measures to compute.
If <code>NULL</code>, no additional measures are computed. Possible values are <code>"lift"</code>,
<code>"conviction"</code>, <code>"added_value"</code>.
See <a href="https://mhahsler.github.io/arules/docs/measures">https://mhahsler.github.io/arules/docs/measures</a>
for a description of the measures.</p>
</td></tr>
<tr><td><code id="dig_associations_+3A_t_norm">t_norm</code></td>
<td>
<p>a t-norm used to compute conjunction of weights. It must be one of
<code>"goedel"</code> (minimum t-norm), <code>"goguen"</code> (product t-norm), or <code>"lukas"</code>
(Lukasiewicz t-norm).</p>
</td></tr>
<tr><td><code id="dig_associations_+3A_max_results">max_results</code></td>
<td>
<p>the maximum number of generated conditions to execute the
callback function on. If the number of found conditions exceeds
<code>max_results</code>, the function stops generating new conditions and returns
the results. To avoid long computations during the search, it is recommended
to set <code>max_results</code> to a reasonable positive value. Setting <code>max_results</code>
to <code>Inf</code> will generate all possible conditions.</p>
</td></tr>
<tr><td><code id="dig_associations_+3A_verbose">verbose</code></td>
<td>
<p>a logical value indicating whether to print progress messages.</p>
</td></tr>
<tr><td><code id="dig_associations_+3A_threads">threads</code></td>
<td>
<p>the number of threads to use for parallel computation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with found patterns and computed quality measures.
</p>


<h3>Author(s)</h3>

<p>Michal Burda
</p>


<h3>See Also</h3>

<p><code><a href="#topic+partition">partition()</a></code>, <code><a href="#topic+var_names">var_names()</a></code>, <code><a href="#topic+dig">dig()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- partition(mtcars, .breaks = 2)
dig_associations(d,
                 antecedent = !starts_with("mpg"),
                 consequent = starts_with("mpg"),
                 min_support = 0.3,
                 min_confidence = 0.8,
                 measures = c("lift", "conviction"))
</code></pre>

<hr>
<h2 id='dig_baseline_contrasts'>Search for conditions that yield in statistically significant one-sample
test in selected variables.</h2><span id='topic+dig_baseline_contrasts'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Baseline contrast patterns identify conditions under which a specific feature
is significantly different from a given value by performing a one-sample
statistical test.
</p>

<dl>
<dt>Scheme:</dt><dd><p><code>var != 0 | C</code><br /><br />
Variable <code>var</code> is (in average) significantly different from 0 under the
condition <code>C</code>.</p>
</dd>
<dt>Example:</dt><dd><p><code style="white-space: pre;">&#8288;(measure_error != 0 | measure_tool_A &#8288;</code><br /><br />
If measuring with measure tool <em>A</em>, the average measure error is
significantly different from 0.</p>
</dd>
</dl>

<p>The baseline contrast is computed using a one-sample statistical test, which
is specified by the <code>method</code> argument. The function computes the contrast
between all variables specified by the <code>vars</code> argument. Baseline contrasts
are computed in sub-data corresponding to conditions generated from the
<code>condition</code> columns. Function <code>dig_baseline_contrasts()</code> supports crisp
conditions only, i.e., the condition columns in <code>x</code> must be logical.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dig_baseline_contrasts(
  x,
  condition = where(is.logical),
  vars = where(is.numeric),
  disjoint = var_names(colnames(x)),
  min_length = 0L,
  max_length = Inf,
  min_support = 0,
  max_support = 1,
  method = "t",
  alternative = "two.sided",
  h0 = 0,
  conf_level = 0.95,
  max_p_value = 0.05,
  wilcox_exact = FALSE,
  wilcox_correct = TRUE,
  wilcox_tol_root = 1e-04,
  wilcox_digits_rank = Inf,
  max_results = Inf,
  verbose = FALSE,
  threads = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dig_baseline_contrasts_+3A_x">x</code></td>
<td>
<p>a matrix or data frame with data to search the patterns in.</p>
</td></tr>
<tr><td><code id="dig_baseline_contrasts_+3A_condition">condition</code></td>
<td>
<p>a tidyselect expression (see
<a href="https://tidyselect.r-lib.org/articles/syntax.html">tidyselect syntax</a>)
specifying the columns to use as condition predicates</p>
</td></tr>
<tr><td><code id="dig_baseline_contrasts_+3A_vars">vars</code></td>
<td>
<p>a tidyselect expression (see
<a href="https://tidyselect.r-lib.org/articles/syntax.html">tidyselect syntax</a>)
specifying the columns to use for computation of contrasts</p>
</td></tr>
<tr><td><code id="dig_baseline_contrasts_+3A_disjoint">disjoint</code></td>
<td>
<p>an atomic vector of size equal to the number of columns of <code>x</code>
that specifies the groups of predicates: if some elements of the <code>disjoint</code>
vector are equal, then the corresponding columns of <code>x</code> will NOT be
present together in a single condition. If <code>x</code> is prepared with
<code><a href="#topic+partition">partition()</a></code>, using the <code><a href="#topic+var_names">var_names()</a></code> function on <code>x</code>'s column names
is a convenient way to create the <code>disjoint</code> vector.</p>
</td></tr>
<tr><td><code id="dig_baseline_contrasts_+3A_min_length">min_length</code></td>
<td>
<p>the minimum size (the minimum number of predicates) of the
condition to be generated (must be greater or equal to 0). If 0, the
empty condition is generated in the first place.</p>
</td></tr>
<tr><td><code id="dig_baseline_contrasts_+3A_max_length">max_length</code></td>
<td>
<p>The maximum size (the maximum number of predicates) of the
condition to be generated. If equal to Inf, the maximum length of
conditions is limited only by the number of available predicates.</p>
</td></tr>
<tr><td><code id="dig_baseline_contrasts_+3A_min_support">min_support</code></td>
<td>
<p>the minimum support of a condition to trigger the callback
function for it. The support of the condition is the relative frequency
of the condition in the dataset <code>x</code>. For logical data, it equals to the
relative frequency of rows such that all condition predicates are TRUE on it.
For numerical (double) input, the support is computed as the mean (over all
rows) of multiplications of predicate values.</p>
</td></tr>
<tr><td><code id="dig_baseline_contrasts_+3A_max_support">max_support</code></td>
<td>
<p>the maximum support of a condition to trigger the callback
function for it. See argument <code>min_support</code> for details of what is the
support of a condition.</p>
</td></tr>
<tr><td><code id="dig_baseline_contrasts_+3A_method">method</code></td>
<td>
<p>a character string indicating which contrast to compute.
One of <code>"t"</code>, for parametric, or <code>"wilcox"</code>, for non-parametric test on
equality in position.</p>
</td></tr>
<tr><td><code id="dig_baseline_contrasts_+3A_alternative">alternative</code></td>
<td>
<p>indicates the alternative hypothesis and must be one of
<code>"two.sided"</code>, <code>"greater"</code> or <code>"less"</code>. <code>"greater"</code> corresponds to
positive association, <code>"less"</code> to negative association.</p>
</td></tr>
<tr><td><code id="dig_baseline_contrasts_+3A_h0">h0</code></td>
<td>
<p>a numeric value specifying the null hypothesis for the test. For
the <code>"t"</code> method, it is the value of the mean. For the <code>"wilcox"</code> method,
it is the value of the median. The default value is 0.</p>
</td></tr>
<tr><td><code id="dig_baseline_contrasts_+3A_conf_level">conf_level</code></td>
<td>
<p>a numeric value specifying the level of the confidence
interval. The default value is 0.95.</p>
</td></tr>
<tr><td><code id="dig_baseline_contrasts_+3A_max_p_value">max_p_value</code></td>
<td>
<p>the maximum p-value of a test for the pattern to be considered
significant. If the p-value of the test is greater than <code>max_p_value</code>, the
pattern is not included in the result.</p>
</td></tr>
<tr><td><code id="dig_baseline_contrasts_+3A_wilcox_exact">wilcox_exact</code></td>
<td>
<p>(used for the <code>"wilcox"</code> method only) a logical value
indicating whether the exact p-value should be computed. If <code>NULL</code>, the
exact p-value is computed for sample sizes less than 50. See <code><a href="stats.html#topic+wilcox.test">wilcox.test()</a></code>
and its <code>exact</code> argument for more information. Contrary to the behavior
of <code><a href="stats.html#topic+wilcox.test">wilcox.test()</a></code>, the default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="dig_baseline_contrasts_+3A_wilcox_correct">wilcox_correct</code></td>
<td>
<p>(used for the <code>"wilcox"</code> method only) a logical value
indicating whether the continuity correction should be applied in the
normal approximation for the p-value, if <code>wilcox_exact</code> is <code>FALSE</code>. See
<code><a href="stats.html#topic+wilcox.test">wilcox.test()</a></code> and its <code>correct</code> argument for more information.</p>
</td></tr>
<tr><td><code id="dig_baseline_contrasts_+3A_wilcox_tol_root">wilcox_tol_root</code></td>
<td>
<p>(used for the <code>"wilcox"</code> method only) a numeric value
specifying the tolerance for the root-finding algorithm used to compute
the exact p-value. See <code><a href="stats.html#topic+wilcox.test">wilcox.test()</a></code> and its <code>tol.root</code> argument for
more information.</p>
</td></tr>
<tr><td><code id="dig_baseline_contrasts_+3A_wilcox_digits_rank">wilcox_digits_rank</code></td>
<td>
<p>(used for the <code>"wilcox"</code> method only) a numeric value
specifying the number of digits to round the ranks to. See <code><a href="stats.html#topic+wilcox.test">wilcox.test()</a></code>
and its <code>digits.rank</code> argument for more information.</p>
</td></tr>
<tr><td><code id="dig_baseline_contrasts_+3A_max_results">max_results</code></td>
<td>
<p>the maximum number of generated conditions to execute the
callback function on. If the number of found conditions exceeds
<code>max_results</code>, the function stops generating new conditions and returns
the results. To avoid long computations during the search, it is recommended
to set <code>max_results</code> to a reasonable positive value. Setting <code>max_results</code>
to <code>Inf</code> will generate all possible conditions.</p>
</td></tr>
<tr><td><code id="dig_baseline_contrasts_+3A_verbose">verbose</code></td>
<td>
<p>a logical scalar indicating whether to print progress messages.</p>
</td></tr>
<tr><td><code id="dig_baseline_contrasts_+3A_threads">threads</code></td>
<td>
<p>the number of threads to use for parallel computation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with found patterns in rows. The following columns are always
present:
</p>
<table role = "presentation">
<tr><td><code>condition</code></td>
<td>
<p>the condition of the pattern as a character string
in the form <code>{p1 &amp; p2 &amp; ... &amp; pn}</code> where <code>p1</code>, <code>p2</code>, ..., <code>pn</code> are
<code>x</code>'s column names.</p>
</td></tr>
<tr><td><code>support</code></td>
<td>
<p>the support of the condition, i.e., the relative
frequency of the condition in the dataset <code>x</code>.</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>the name of the contrast variable.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>the estimated mean or median of variable <code>var</code>.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>the statistic of the selected test.</p>
</td></tr>
<tr><td><code>p_value</code></td>
<td>
<p>the p-value of the underlying test.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>the number of rows in the sub-data corresponding to
the condition.</p>
</td></tr>
<tr><td><code>conf_int_lo</code></td>
<td>
<p>the lower bound of the confidence interval of the estimate.</p>
</td></tr>
<tr><td><code>conf_int_hi</code></td>
<td>
<p>the upper bound of the confidence interval of the estimate.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string indicating the alternative
hypothesis. The value must be one of <code>"two.sided"</code>, <code>"greater"</code>, or
<code>"less"</code>.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating the method used for the
test.</p>
</td></tr>
<tr><td><code>comment</code></td>
<td>
<p>a character string with additional information about the
test (mainly error messages on failure).</p>
</td></tr>
</table>
<p>For the <code>"t"</code> method, the following additional columns are also
present (see also <code><a href="stats.html#topic+t.test">t.test()</a></code>):
</p>
<table role = "presentation">
<tr><td><code>df</code></td>
<td>
<p>the degrees of freedom of the t test.</p>
</td></tr>
<tr><td><code>stderr</code></td>
<td>
<p>the standard error of the mean.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michal Burda
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dig_paired_baseline_contrasts">dig_paired_baseline_contrasts()</a></code>, <code><a href="#topic+dig_complement_contrasts">dig_complement_contrasts()</a></code>,
<code><a href="#topic+dig">dig()</a></code>, <code><a href="#topic+dig_grid">dig_grid()</a></code>,
<code><a href="stats.html#topic+t.test">stats::t.test()</a></code>, <code><a href="stats.html#topic+wilcox.test">stats::wilcox.test()</a></code>
</p>

<hr>
<h2 id='dig_complement_contrasts'>Search for conditions that provide significant differences in selected
variables to the rest of the data table</h2><span id='topic+dig_complement_contrasts'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Complement contrast patterns identify conditions under which there is
a significant difference in some numerical variable between elements
that satisfy the identified condition and the rest of the data table.
</p>

<dl>
<dt>Scheme:</dt><dd><p><code style="white-space: pre;">&#8288;(var | C) != (var | not C)&#8288;</code><br /><br />
There is a statistically significant difference in variable <code>var</code> between
group of elements that satisfy condition <code>C</code> and a group of elements that
do not satisfy condition <code>C</code>.</p>
</dd>
<dt>Example:</dt><dd><p><code>(life_expectancy | smoker) &lt; (life_expectancy | non-smoker)</code><br /><br />
The life expectancy in people that smoke cigarettes is in average
significantly lower than in people that do not smoke.</p>
</dd>
</dl>

<p>The complement contrast is computed using a two-sample statistical test,
which is specified by the <code>method</code> argument. The function computes the
complement contrast in all variables specified by the <code>vars</code> argument.
Complement contrasts are computed based on sub-data corresponding
to conditions generated from the <code>condition</code> columns and the rest of the
data table. Function #' <code>dig_complement_contrasts()</code> supports crisp
conditions only, i.e., the condition columns in <code>x</code> must be logical.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dig_complement_contrasts(
  x,
  condition = where(is.logical),
  vars = where(is.numeric),
  disjoint = var_names(colnames(x)),
  min_length = 0L,
  max_length = Inf,
  min_support = 0,
  max_support = 1 - min_support,
  method = "t",
  alternative = "two.sided",
  h0 = if (method == "var") 1 else 0,
  conf_level = 0.95,
  max_p_value = 0.05,
  t_var_equal = FALSE,
  wilcox_exact = FALSE,
  wilcox_correct = TRUE,
  wilcox_tol_root = 1e-04,
  wilcox_digits_rank = Inf,
  max_results = Inf,
  verbose = FALSE,
  threads = 1L
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dig_complement_contrasts_+3A_x">x</code></td>
<td>
<p>a matrix or data frame with data to search the patterns in.</p>
</td></tr>
<tr><td><code id="dig_complement_contrasts_+3A_condition">condition</code></td>
<td>
<p>a tidyselect expression (see
<a href="https://tidyselect.r-lib.org/articles/syntax.html">tidyselect syntax</a>)
specifying the columns to use as condition predicates</p>
</td></tr>
<tr><td><code id="dig_complement_contrasts_+3A_vars">vars</code></td>
<td>
<p>a tidyselect expression (see
<a href="https://tidyselect.r-lib.org/articles/syntax.html">tidyselect syntax</a>)
specifying the columns to use for computation of contrasts</p>
</td></tr>
<tr><td><code id="dig_complement_contrasts_+3A_disjoint">disjoint</code></td>
<td>
<p>an atomic vector of size equal to the number of columns of <code>x</code>
that specifies the groups of predicates: if some elements of the <code>disjoint</code>
vector are equal, then the corresponding columns of <code>x</code> will NOT be
present together in a single condition. If <code>x</code> is prepared with
<code><a href="#topic+partition">partition()</a></code>, using the <code><a href="#topic+var_names">var_names()</a></code> function on <code>x</code>'s column names
is a convenient way to create the <code>disjoint</code> vector.</p>
</td></tr>
<tr><td><code id="dig_complement_contrasts_+3A_min_length">min_length</code></td>
<td>
<p>the minimum size (the minimum number of predicates) of the
condition to be generated (must be greater or equal to 0). If 0, the
empty condition is generated in the first place.</p>
</td></tr>
<tr><td><code id="dig_complement_contrasts_+3A_max_length">max_length</code></td>
<td>
<p>The maximum size (the maximum number of predicates) of the
condition to be generated. If equal to Inf, the maximum length of
conditions is limited only by the number of available predicates.</p>
</td></tr>
<tr><td><code id="dig_complement_contrasts_+3A_min_support">min_support</code></td>
<td>
<p>the minimum support of a condition to trigger the callback
function for it. The support of the condition is the relative frequency
of the condition in the dataset <code>x</code>. For logical data, it equals to the
relative frequency of rows such that all condition predicates are TRUE on it.
For numerical (double) input, the support is computed as the mean (over all
rows) of multiplications of predicate values.</p>
</td></tr>
<tr><td><code id="dig_complement_contrasts_+3A_max_support">max_support</code></td>
<td>
<p>the maximum support of a condition to trigger the callback
function for it. See argument <code>min_support</code> for details of what is the
support of a condition.</p>
</td></tr>
<tr><td><code id="dig_complement_contrasts_+3A_method">method</code></td>
<td>
<p>a character string indicating which contrast to compute.
One of <code>"t"</code>, for parametric, or <code>"wilcox"</code>, for non-parametric test on
equality in position, and <code>"var"</code> for F-test on comparison of variances
of two populations.</p>
</td></tr>
<tr><td><code id="dig_complement_contrasts_+3A_alternative">alternative</code></td>
<td>
<p>indicates the alternative hypothesis and must be one of
<code>"two.sided"</code>, <code>"greater"</code> or <code>"less"</code>. <code>"greater"</code> corresponds to
positive association, <code>"less"</code> to negative association.</p>
</td></tr>
<tr><td><code id="dig_complement_contrasts_+3A_h0">h0</code></td>
<td>
<p>a numeric value specifying the null hypothesis for the test. For
the <code>"t"</code> method, it is the difference in means. For the <code>"wilcox"</code> method,
it is the difference in medians. For the <code>"var"</code> method, it is the
hypothesized ratio of the population variances. The default value is 1
for <code>"var"</code> method, and 0 otherwise.</p>
</td></tr>
<tr><td><code id="dig_complement_contrasts_+3A_conf_level">conf_level</code></td>
<td>
<p>a numeric value specifying the level of the confidence
interval. The default value is 0.95.</p>
</td></tr>
<tr><td><code id="dig_complement_contrasts_+3A_max_p_value">max_p_value</code></td>
<td>
<p>the maximum p-value of a test for the pattern to be considered
significant. If the p-value of the test is greater than <code>max_p_value</code>, the
pattern is not included in the result.</p>
</td></tr>
<tr><td><code id="dig_complement_contrasts_+3A_t_var_equal">t_var_equal</code></td>
<td>
<p>(used for the <code>"t"</code> method only) a logical value indicating
whether the variances of the two samples are assumed to be equal. If
<code>TRUE</code>, the pooled variance is used to estimate the variance in the t-test.
If <code>FALSE</code>, the Welch (or Satterthwaite) approximation to the degrees of
freedom is used. See <code><a href="stats.html#topic+t.test">t.test()</a></code> and its <code>var.equal</code> argument for more
information.</p>
</td></tr>
<tr><td><code id="dig_complement_contrasts_+3A_wilcox_exact">wilcox_exact</code></td>
<td>
<p>(used for the <code>"wilcox"</code> method only) a logical value
indicating whether the exact p-value should be computed. If <code>NULL</code>, the
exact p-value is computed for sample sizes less than 50. See <code><a href="stats.html#topic+wilcox.test">wilcox.test()</a></code>
and its <code>exact</code> argument for more information. Contrary to the behavior
of <code><a href="stats.html#topic+wilcox.test">wilcox.test()</a></code>, the default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="dig_complement_contrasts_+3A_wilcox_correct">wilcox_correct</code></td>
<td>
<p>(used for the <code>"wilcox"</code> method only) a logical value
indicating whether the continuity correction should be applied in the
normal approximation for the p-value, if <code>wilcox_exact</code> is <code>FALSE</code>. See
<code><a href="stats.html#topic+wilcox.test">wilcox.test()</a></code> and its <code>correct</code> argument for more information.</p>
</td></tr>
<tr><td><code id="dig_complement_contrasts_+3A_wilcox_tol_root">wilcox_tol_root</code></td>
<td>
<p>(used for the <code>"wilcox"</code> method only) a numeric value
specifying the tolerance for the root-finding algorithm used to compute
the exact p-value. See <code><a href="stats.html#topic+wilcox.test">wilcox.test()</a></code> and its <code>tol.root</code> argument for
more information.</p>
</td></tr>
<tr><td><code id="dig_complement_contrasts_+3A_wilcox_digits_rank">wilcox_digits_rank</code></td>
<td>
<p>(used for the <code>"wilcox"</code> method only) a numeric value
specifying the number of digits to round the ranks to. See <code><a href="stats.html#topic+wilcox.test">wilcox.test()</a></code>
and its <code>digits.rank</code> argument for more information.</p>
</td></tr>
<tr><td><code id="dig_complement_contrasts_+3A_max_results">max_results</code></td>
<td>
<p>the maximum number of generated conditions to execute the
callback function on. If the number of found conditions exceeds
<code>max_results</code>, the function stops generating new conditions and returns
the results. To avoid long computations during the search, it is recommended
to set <code>max_results</code> to a reasonable positive value. Setting <code>max_results</code>
to <code>Inf</code> will generate all possible conditions.</p>
</td></tr>
<tr><td><code id="dig_complement_contrasts_+3A_verbose">verbose</code></td>
<td>
<p>a logical scalar indicating whether to print progress messages.</p>
</td></tr>
<tr><td><code id="dig_complement_contrasts_+3A_threads">threads</code></td>
<td>
<p>the number of threads to use for parallel computation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with found patterns in rows. The following columns are always
present:
</p>
<table role = "presentation">
<tr><td><code>condition</code></td>
<td>
<p>the condition of the pattern as a character string
in the form <code>{p1 &amp; p2 &amp; ... &amp; pn}</code> where <code>p1</code>, <code>p2</code>, ..., <code>pn</code> are
<code>x</code>'s column names.</p>
</td></tr>
<tr><td><code>support</code></td>
<td>
<p>the support of the condition, i.e., the relative
frequency of the condition in the dataset <code>x</code>.</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>the name of the contrast variable.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>the estimate value (see the underlying test.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>the statistic of the selected test.</p>
</td></tr>
<tr><td><code>p_value</code></td>
<td>
<p>the p-value of the underlying test.</p>
</td></tr>
<tr><td><code>n_x</code></td>
<td>
<p>the number of rows in the sub-data corresponding to
the condition.</p>
</td></tr>
<tr><td><code>n_y</code></td>
<td>
<p>the number of rows in the sub-data corresponding to
the negation of the condition.</p>
</td></tr>
<tr><td><code>conf_int_lo</code></td>
<td>
<p>the lower bound of the confidence interval of the estimate.</p>
</td></tr>
<tr><td><code>conf_int_hi</code></td>
<td>
<p>the upper bound of the confidence interval of the estimate.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string indicating the alternative
hypothesis. The value must be one of <code>"two.sided"</code>, <code>"greater"</code>, or
<code>"less"</code>.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating the method used for the
test.</p>
</td></tr>
<tr><td><code>comment</code></td>
<td>
<p>a character string with additional information about the
test (mainly error messages on failure).</p>
</td></tr>
</table>
<p>For the <code>"t"</code> method, the following additional columns are also
present (see also <code><a href="stats.html#topic+t.test">t.test()</a></code>):
</p>
<table role = "presentation">
<tr><td><code>df</code></td>
<td>
<p>the degrees of freedom of the t test.</p>
</td></tr>
<tr><td><code>stderr</code></td>
<td>
<p>the standard error of the mean difference.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michal Burda
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dig_baseline_contrasts">dig_baseline_contrasts()</a></code>, <code><a href="#topic+dig_paired_baseline_contrasts">dig_paired_baseline_contrasts()</a></code>,
<code><a href="#topic+dig">dig()</a></code>, <code><a href="#topic+dig_grid">dig_grid()</a></code>,
<code><a href="stats.html#topic+t.test">stats::t.test()</a></code>, <code><a href="stats.html#topic+wilcox.test">stats::wilcox.test()</a></code>, <code><a href="stats.html#topic+var.test">stats::var.test()</a></code>
</p>

<hr>
<h2 id='dig_contrasts'>Search for paired contrast patterns</h2><span id='topic+dig_contrasts'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>Contrast patterns are a generalization of association rules that allow
for the specification of a condition under which there is a significant
difference in some statistical feature between two numeric variables.
</p>

<dl>
<dt>Scheme:</dt><dd><p><code style="white-space: pre;">&#8288;theta(xvar) &gt;&gt; theta(yvar) | C&#8288;</code><br /><br />
The feature <code>theta</code> of the first variable <code>xvar</code> is significantly higher
than the feature <code>theta</code> of the second variable <code>yvar</code> under the
condition <code>C</code>.</p>
</dd>
<dt>Example:</dt><dd><p><code style="white-space: pre;">&#8288;mean(daily_ice_cream_income) &gt;&gt; mean(daily_tea_income) | sunny&#8288;</code><br /><br />
The <em>mean</em> of <em>daily ice-cream income</em> is significantly higher than
the <em>mean</em> of <em>daily tea income</em> under the condition of <em>sunny weather</em>.</p>
</dd>
</dl>

<p>The contrast is computed using
a statistical test, which is specified by the <code>method</code> argument. The
function computes the contrast between all pairs of variables, where the
first variable is specified by the <code>xvars</code> argument and the second variable
is specified by the <code>yvars</code> argument. The contrast is computed in sub-data
corresponding to conditions generated from the <code>condition</code> columns. The
<code>dig_contrasts()</code> function supports crisp conditions only, i.e., the
condition columns must be logical.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dig_contrasts(
  x,
  condition = where(is.logical),
  xvars = where(is.numeric),
  yvars = where(is.numeric),
  method = "t",
  alternative = "two.sided",
  min_length = 0L,
  max_length = Inf,
  min_support = 0,
  max_p_value = 0.05,
  threads = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dig_contrasts_+3A_x">x</code></td>
<td>
<p>a matrix or data frame with data to search in.</p>
</td></tr>
<tr><td><code id="dig_contrasts_+3A_condition">condition</code></td>
<td>
<p>a tidyselect expression (see
<a href="https://tidyselect.r-lib.org/articles/syntax.html">tidyselect syntax</a>)
specifying the columns to use as condition predicates</p>
</td></tr>
<tr><td><code id="dig_contrasts_+3A_xvars">xvars</code></td>
<td>
<p>a tidyselect expression (see
<a href="https://tidyselect.r-lib.org/articles/syntax.html">tidyselect syntax</a>)
specifying the columns to use for computation of contrasts</p>
</td></tr>
<tr><td><code id="dig_contrasts_+3A_yvars">yvars</code></td>
<td>
<p>a tidyselect expression (see
<a href="https://tidyselect.r-lib.org/articles/syntax.html">tidyselect syntax</a>)
specifying the columns to use for computation of contrasts</p>
</td></tr>
<tr><td><code id="dig_contrasts_+3A_method">method</code></td>
<td>
<p>a character string indicating which contrast to compute.
One of <code>"t"</code>, <code>"wilcox"</code>, or <code>"var"</code>. <code>"t"</code> (resp. <code>"wilcos"</code>) compute
a parametric (resp. non-parametric) test on equality in position, and
<code>"var"</code> performs the F-test on equality of variance.</p>
</td></tr>
<tr><td><code id="dig_contrasts_+3A_alternative">alternative</code></td>
<td>
<p>indicates the alternative hypothesis and must be one of
<code>"two.sided"</code>, <code>"greater"</code> or <code>"less"</code>. <code>"greater"</code> corresponds to
positive association, <code>"less"</code> to negative association.</p>
</td></tr>
<tr><td><code id="dig_contrasts_+3A_min_length">min_length</code></td>
<td>
<p>the minimum size (the minimum number of predicates) of the
condition to be generated (must be greater or equal to 0). If 0, the empty
condition is generated in the first place.</p>
</td></tr>
<tr><td><code id="dig_contrasts_+3A_max_length">max_length</code></td>
<td>
<p>The maximum size (the maximum number of predicates) of the
condition to be generated. If equal to Inf, the maximum length of conditions
is limited only by the number of available predicates.</p>
</td></tr>
<tr><td><code id="dig_contrasts_+3A_min_support">min_support</code></td>
<td>
<p>the minimum support of a condition to trigger the callback
function for it. The support of the condition is the relative frequency
of the condition in the dataset <code>x</code>. For logical data, it equals to the
relative frequency of rows such that all condition predicates are TRUE on it.
For numerical (double) input, the support is computed as the mean (over all
rows) of multiplications of predicate values.</p>
</td></tr>
<tr><td><code id="dig_contrasts_+3A_max_p_value">max_p_value</code></td>
<td>
<p>the maximum p-value of a test for the pattern to be considered
significant. If the p-value of the test is greater than <code>max_p_value</code>, the
pattern is not included in the result.</p>
</td></tr>
<tr><td><code id="dig_contrasts_+3A_threads">threads</code></td>
<td>
<p>the number of threads to use for parallel computation.</p>
</td></tr>
<tr><td><code id="dig_contrasts_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the underlying test function
(<code><a href="stats.html#topic+t.test">t.test()</a></code>, <code><a href="stats.html#topic+wilcox.test">wilcox.test()</a></code>, or <code><a href="stats.html#topic+var.test">var.test()</a></code> accordingly to the
selected method).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with found patterns in rows. The following columns are always
present:
</p>
<table role = "presentation">
<tr><td><code>condition</code></td>
<td>
<p>the condition of the pattern as a character string
in the form <code>{p1 &amp; p2 &amp; ... &amp; pn}</code> where <code>p1</code>, <code>p2</code>, ..., <code>pn</code> are
<code>x</code>'s column names.</p>
</td></tr>
<tr><td><code>support</code></td>
<td>
<p>the support of the condition, i.e., the relative
frequency of the condition in the dataset <code>x</code>.</p>
</td></tr>
<tr><td><code>xvar</code></td>
<td>
<p>the name of the first variable in the contrast.</p>
</td></tr>
<tr><td><code>yvar</code></td>
<td>
<p>the name of the second variable in the contrast.</p>
</td></tr>
<tr><td><code>p_value</code></td>
<td>
<p>the p-value of the underlying test.</p>
</td></tr>
<tr><td><code>rows</code></td>
<td>
<p>the number of rows in the sub-data corresponding to
the condition.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string indicating the alternative
hypothesis.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating the method used for the
test.</p>
</td></tr>
</table>
<p>For the <code>"t"</code> method, the following additional columns are also
present (see also <code><a href="stats.html#topic+t.test">t.test()</a></code>):
</p>
<table role = "presentation">
<tr><td><code>estimate_x</code></td>
<td>
<p>the estimated mean of variable <code>xvar</code>.</p>
</td></tr>
<tr><td><code>estimate_y</code></td>
<td>
<p>the estimated mean of variable <code>yvar</code>.</p>
</td></tr>
<tr><td><code>t_statistic</code></td>
<td>
<p>the t-statistic of the t test.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>the degrees of freedom of the t test.</p>
</td></tr>
<tr><td><code>conf_int_lo</code></td>
<td>
<p>the lower bound of the confidence interval.</p>
</td></tr>
<tr><td><code>conf_int_hi</code></td>
<td>
<p>the upper bound of the confidence interval.</p>
</td></tr>
<tr><td><code>stderr</code></td>
<td>
<p>the standard error of the mean difference.</p>
</td></tr>
</table>
<p>For the <code>"wilcox"</code> method, the following additional columns are also
present (see also <code><a href="stats.html#topic+wilcox.test">wilcox.test()</a></code>):
</p>
<table role = "presentation">
<tr><td><code>estimate</code></td>
<td>
<p>the estimate of the location parameter.</p>
</td></tr>
<tr><td><code>W_statistic</code></td>
<td>
<p>the Wilcoxon rank sum statistic.</p>
</td></tr>
<tr><td><code>conf_int_lo</code></td>
<td>
<p>the lower bound of the confidence interval.</p>
</td></tr>
<tr><td><code>conf_int_hi</code></td>
<td>
<p>the upper bound of the confidence interval.</p>
</td></tr>
</table>
<p>For the <code>"var"</code> method, the following additional columns are also
present (see also <code><a href="stats.html#topic+var.test">var.test()</a></code>):
</p>
<table role = "presentation">
<tr><td><code>estimate</code></td>
<td>
<p>the ratio of the sample variances of variables
<code>xvar</code> and <code>yvar</code>.</p>
</td></tr>
<tr><td><code>F_statistic</code></td>
<td>
<p>the value of the F test statistic.</p>
</td></tr>
<tr><td><code>df1</code></td>
<td>
<p>the numerator degrees of freedom.</p>
</td></tr>
<tr><td><code>df2</code></td>
<td>
<p>the denominator degrees of freedom.</p>
</td></tr>
<tr><td><code>conf_int_lo</code></td>
<td>
<p>the lower bound of the confidence interval for the
ratio of the population variances.</p>
</td></tr>
<tr><td><code>conf_int_hi</code></td>
<td>
<p>the upper bound of the confidence interval for the
ratio of the population variances.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michal Burda
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dig">dig()</a></code>, <code><a href="#topic+dig_grid">dig_grid()</a></code>, <code><a href="stats.html#topic+t.test">stats::t.test()</a></code>, <code><a href="stats.html#topic+wilcox.test">stats::wilcox.test()</a></code>, <code><a href="stats.html#topic+var.test">stats::var.test()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>crispCO2 &lt;- partition(CO2, Plant:Treatment)
dig_contrasts(crispCO2,
             condition = where(is.logical),
             xvars = conc,
             yvars = uptake,
             method = "t",
             min_support = 0.1)
</code></pre>

<hr>
<h2 id='dig_correlations'>Search for conditional correlations</h2><span id='topic+dig_correlations'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Conditional correlations are patterns that identify strong relationships
between pairs of numeric variables under specific conditions.
</p>

<dl>
<dt>Scheme:</dt><dd><p><code>xvar ~ yvar | C</code><br /><br />
<code>xvar</code> and <code>yvar</code> highly correlates in data that satisfy the condition
<code>C</code>.</p>
</dd>
<dt>Example:</dt><dd><p><code>study_time ~ test_score | hard_exam</code><br /><br />
For <em>hard exams</em>, the amount of <em>study time</em> is highly correlated with
the obtained exam's <em>test score</em>.</p>
</dd>
</dl>

<p>The function computes correlations between all combinations of <code>xvars</code> and
<code>yvars</code> columns of <code>x</code> in multiple sub-data corresponding to conditions
generated from <code>condition</code> columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dig_correlations(
  x,
  condition = where(is.logical),
  xvars = where(is.numeric),
  yvars = where(is.numeric),
  disjoint = var_names(colnames(x)),
  method = "pearson",
  alternative = "two.sided",
  exact = NULL,
  min_length = 0L,
  max_length = Inf,
  min_support = 0,
  max_support = 1,
  max_results = Inf,
  verbose = FALSE,
  threads = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dig_correlations_+3A_x">x</code></td>
<td>
<p>a matrix or data frame with data to search in.</p>
</td></tr>
<tr><td><code id="dig_correlations_+3A_condition">condition</code></td>
<td>
<p>a tidyselect expression (see
<a href="https://tidyselect.r-lib.org/articles/syntax.html">tidyselect syntax</a>)
specifying the columns to use as condition predicates</p>
</td></tr>
<tr><td><code id="dig_correlations_+3A_xvars">xvars</code></td>
<td>
<p>a tidyselect expression (see
<a href="https://tidyselect.r-lib.org/articles/syntax.html">tidyselect syntax</a>)
specifying the columns to use for computation of correlations</p>
</td></tr>
<tr><td><code id="dig_correlations_+3A_yvars">yvars</code></td>
<td>
<p>a tidyselect expression (see
<a href="https://tidyselect.r-lib.org/articles/syntax.html">tidyselect syntax</a>)
specifying the columns to use for computation of correlations</p>
</td></tr>
<tr><td><code id="dig_correlations_+3A_disjoint">disjoint</code></td>
<td>
<p>an atomic vector of size equal to the number of columns of <code>x</code>
that specifies the groups of predicates: if some elements of the <code>disjoint</code>
vector are equal, then the corresponding columns of <code>x</code> will NOT be
present together in a single condition. If <code>x</code> is prepared with
<code><a href="#topic+partition">partition()</a></code>, using the <code><a href="#topic+var_names">var_names()</a></code> function on <code>x</code>'s column names
is a convenient way to create the <code>disjoint</code> vector.</p>
</td></tr>
<tr><td><code id="dig_correlations_+3A_method">method</code></td>
<td>
<p>a character string indicating which correlation coefficient is
to be used for the test. One of <code>"pearson"</code>, <code>"kendall"</code>, or <code>"spearman"</code></p>
</td></tr>
<tr><td><code id="dig_correlations_+3A_alternative">alternative</code></td>
<td>
<p>indicates the alternative hypothesis and must be one of
<code>"two.sided"</code>, <code>"greater"</code> or <code>"less"</code>. <code>"greater"</code> corresponds to
positive association, <code>"less"</code> to negative association.</p>
</td></tr>
<tr><td><code id="dig_correlations_+3A_exact">exact</code></td>
<td>
<p>a logical indicating whether an exact p-value should be computed.
Used for Kendall's <em>tau</em> and Spearman's <em>rho</em>. See <code><a href="stats.html#topic+cor.test">stats::cor.test()</a></code> for
more information.</p>
</td></tr>
<tr><td><code id="dig_correlations_+3A_min_length">min_length</code></td>
<td>
<p>the minimum size (the minimum number of predicates) of the
condition to be generated (must be greater or equal to 0). If 0, the empty
condition is generated in the first place.</p>
</td></tr>
<tr><td><code id="dig_correlations_+3A_max_length">max_length</code></td>
<td>
<p>The maximum size (the maximum number of predicates) of the
condition to be generated. If equal to Inf, the maximum length of conditions
is limited only by the number of available predicates.</p>
</td></tr>
<tr><td><code id="dig_correlations_+3A_min_support">min_support</code></td>
<td>
<p>the minimum support of a condition to trigger the callback
function for it. The support of the condition is the relative frequency
of the condition in the dataset <code>x</code>. For logical data, it equals to the
relative frequency of rows such that all condition predicates are TRUE on it.
For numerical (double) input, the support is computed as the mean (over all
rows) of multiplications of predicate values.</p>
</td></tr>
<tr><td><code id="dig_correlations_+3A_max_support">max_support</code></td>
<td>
<p>the maximum support of a condition to trigger the callback
function for it. See argument <code>min_support</code> for details of what is the
support of a condition.</p>
</td></tr>
<tr><td><code id="dig_correlations_+3A_max_results">max_results</code></td>
<td>
<p>the maximum number of generated conditions to execute the
callback function on. If the number of found conditions exceeds
<code>max_results</code>, the function stops generating new conditions and returns
the results. To avoid long computations during the search, it is recommended
to set <code>max_results</code> to a reasonable positive value. Setting <code>max_results</code>
to <code>Inf</code> will generate all possible conditions.</p>
</td></tr>
<tr><td><code id="dig_correlations_+3A_verbose">verbose</code></td>
<td>
<p>a logical scalar indicating whether to print progress messages.</p>
</td></tr>
<tr><td><code id="dig_correlations_+3A_threads">threads</code></td>
<td>
<p>the number of threads to use for parallel computation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with found patterns.
</p>


<h3>Author(s)</h3>

<p>Michal Burda
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dig">dig()</a></code>, <code><a href="stats.html#topic+cor.test">stats::cor.test()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># convert iris$Species into dummy logical variables
d &lt;- partition(iris, Species)

# find conditional correlations between all pairs of numeric variables
dig_correlations(d,
                 condition = where(is.logical),
                 xvars = Sepal.Length:Petal.Width,
                 yvars = Sepal.Length:Petal.Width)

# With `condition = NULL`, dig_correlations() computes correlations between
# all pairs of numeric variables on the whole dataset only, which is an
# alternative way of computing the correlation matrix
dig_correlations(iris,
                 condition = NULL,
                 xvars = Sepal.Length:Petal.Width,
                 yvars = Sepal.Length:Petal.Width)
</code></pre>

<hr>
<h2 id='dig_grid'>Search for grid-based rules</h2><span id='topic+dig_grid'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>This function creates a grid column names specified
by <code>xvars</code> and <code>yvars</code> (see <code><a href="#topic+var_grid">var_grid()</a></code>). After that, it enumerates all
conditions created from data in <code>x</code> (by calling <code><a href="#topic+dig">dig()</a></code>) and for each such
condition and for each row of the grid of combinations, a user-defined
function <code>f</code> is executed on each sub-data created from <code>x</code> by selecting all
rows of <code>x</code> that satisfy the generated condition and by selecting the
columns in the grid's row.
</p>
<p>Function is useful for searching for patterns that are based on the
relationships between pairs of columns, such as in <code><a href="#topic+dig_correlations">dig_correlations()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dig_grid(
  x,
  f,
  condition = where(is.logical),
  xvars = where(is.numeric),
  yvars = where(is.numeric),
  disjoint = var_names(colnames(x)),
  allow = "all",
  na_rm = FALSE,
  type = "crisp",
  min_length = 0L,
  max_length = Inf,
  min_support = 0,
  max_support = 1,
  max_results = Inf,
  verbose = FALSE,
  threads = 1L,
  error_context = list(arg_x = "x", arg_f = "f", arg_condition = "condition", arg_xvars =
    "xvars", arg_yvars = "yvars", arg_disjoint = "disjoint", arg_allow = "allow",
    arg_na_rm = "na_rm", arg_type = "type", arg_min_length = "min_length", arg_max_length
    = "max_length", arg_min_support = "min_support", arg_max_support = "max_support",
    arg_max_results = "max_results", arg_verbose = "verbose", arg_threads = "threads",
    call = current_env())
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dig_grid_+3A_x">x</code></td>
<td>
<p>a matrix or data frame with data to search in.</p>
</td></tr>
<tr><td><code id="dig_grid_+3A_f">f</code></td>
<td>
<p>the callback function to be executed for each generated condition.
The arguments of the callback function differ based on the value of the
<code>type</code> argument (see below):
</p>

<ul>
<li><p> If <code>type = "crisp"</code> (that is, boolean),
the callback function <code>f</code> must accept a single argument <code>pd</code> of type
<code>data.frame</code> with single (if <code>yvars == NULL</code>) or two (if <code>yvars != NULL</code>)
columns, accessible as <code>pd[[1]]</code> and <code>pd[[2]]</code>. Data frame <code>pd</code> is
a subset of the original
data frame <code>x</code> with all rows that satisfy the generated condition.
Optionally, the callback function may accept an argument <code>nd</code> that
is a subset of the original data frame <code>x</code> with all rows that do not
satisfy the generated condition.
</p>
</li>
<li><p> If <code>type = "fuzzy"</code>, the callback function <code>f</code> must accept an argument
<code>d</code> of type <code>data.frame</code> with single (if <code>yvars == NULL</code>) or two (if
<code>yvars != NULL</code>) columns, accessible as <code>d[[1]]</code> and <code>d[[2]]</code>, and
a numeric argument <code>weights</code> with the same length as the number of rows
in <code>d</code>. The <code>weights</code> argument contains the truth degree
of the generated condition for each row of <code>d</code>. The truth degree is
a number in the interval <code class="reqn">[0, 1]</code> that represents the degree of
satisfaction of the condition in the original data row.
</p>
</li></ul>

<p>In all cases, the function must return a list of scalar values, which
will be converted into a single row of result of final tibble.</p>
</td></tr>
<tr><td><code id="dig_grid_+3A_condition">condition</code></td>
<td>
<p>a tidyselect expression (see
<a href="https://tidyselect.r-lib.org/articles/syntax.html">tidyselect syntax</a>)
specifying the columns to use as condition predicates. The selected
columns must be logical or numeric. If numeric, fuzzy conditions are
considered.</p>
</td></tr>
<tr><td><code id="dig_grid_+3A_xvars">xvars</code></td>
<td>
<p>a tidyselect expression (see
<a href="https://tidyselect.r-lib.org/articles/syntax.html">tidyselect syntax</a>)
specifying the columns of <code>x</code>, whose names will be used as a domain for
combinations use at the first place (xvar)</p>
</td></tr>
<tr><td><code id="dig_grid_+3A_yvars">yvars</code></td>
<td>
<p><code>NULL</code> or a tidyselect expression (see
<a href="https://tidyselect.r-lib.org/articles/syntax.html">tidyselect syntax</a>)
specifying the columns of <code>x</code>, whose names will be used as a domain for
combinations use at the second place (yvar)</p>
</td></tr>
<tr><td><code id="dig_grid_+3A_disjoint">disjoint</code></td>
<td>
<p>an atomic vector of size equal to the number of columns of <code>x</code>
that specifies the groups of predicates: if some elements of the <code>disjoint</code>
vector are equal, then the corresponding columns of <code>x</code> will NOT be
present together in a single condition. If <code>x</code> is prepared with
<code><a href="#topic+partition">partition()</a></code>, using the <code><a href="#topic+var_names">var_names()</a></code> function on <code>x</code>'s column names
is a convenient way to create the <code>disjoint</code> vector.</p>
</td></tr>
<tr><td><code id="dig_grid_+3A_allow">allow</code></td>
<td>
<p>a character string specifying which columns are allowed to be
selected by <code>xvars</code> and <code>yvars</code> arguments. Possible values are:
</p>

<ul>
<li> <p><code>"all"</code> - all columns are allowed to be selected
</p>
</li>
<li> <p><code>"numeric"</code> - only numeric columns are allowed to be selected
</p>
</li></ul>
</td></tr>
<tr><td><code id="dig_grid_+3A_na_rm">na_rm</code></td>
<td>
<p>a logical value indicating whether to remove rows with missing
values from sub-data before the callback function <code>f</code> is called</p>
</td></tr>
<tr><td><code id="dig_grid_+3A_type">type</code></td>
<td>
<p>a character string specifying the type of conditions to be processed.
The <code>"crisp"</code> type accepts only logical columns as condition predicates.
The <code>"fuzzy"</code> type accepts both logical and numeric columns as condition
predicates where numeric data are in the interval <code class="reqn">[0, 1]</code>. The
callback function <code>f</code> differs based on the value of the <code>type</code> argument
(see the description of <code>f</code> above).</p>
</td></tr>
<tr><td><code id="dig_grid_+3A_min_length">min_length</code></td>
<td>
<p>the minimum size (the minimum number of predicates) of the
condition to be generated (must be greater or equal to 0). If 0, the empty
condition is generated in the first place.</p>
</td></tr>
<tr><td><code id="dig_grid_+3A_max_length">max_length</code></td>
<td>
<p>the maximum size (the maximum number of predicates) of the
condition to be generated. If equal to Inf, the maximum length of conditions
is limited only by the number of available predicates.</p>
</td></tr>
<tr><td><code id="dig_grid_+3A_min_support">min_support</code></td>
<td>
<p>the minimum support of a condition to trigger the callback
function for it. The support of the condition is the relative frequency
of the condition in the dataset <code>x</code>. For logical data, it equals to the
relative frequency of rows such that all condition predicates are TRUE on it.
For numerical (double) input, the support is computed as the mean (over all
rows) of multiplications of predicate values.</p>
</td></tr>
<tr><td><code id="dig_grid_+3A_max_support">max_support</code></td>
<td>
<p>the maximum support of a condition to trigger the callback
function for it. See argument <code>min_support</code> for details of what is the
support of a condition.</p>
</td></tr>
<tr><td><code id="dig_grid_+3A_max_results">max_results</code></td>
<td>
<p>the maximum number of generated conditions to execute the
callback function on. If the number of found conditions exceeds
<code>max_results</code>, the function stops generating new conditions and returns
the results. To avoid long computations during the search, it is recommended
to set <code>max_results</code> to a reasonable positive value. Setting <code>max_results</code>
to <code>Inf</code> will generate all possible conditions.</p>
</td></tr>
<tr><td><code id="dig_grid_+3A_verbose">verbose</code></td>
<td>
<p>a logical scalar indicating whether to print progress messages.</p>
</td></tr>
<tr><td><code id="dig_grid_+3A_threads">threads</code></td>
<td>
<p>the number of threads to use for parallel computation.</p>
</td></tr>
<tr><td><code id="dig_grid_+3A_error_context">error_context</code></td>
<td>
<p>a list of details to be used in error messages.
This argument is useful when <code>dig_grid()</code> is called from another
function to provide error messages, which refer to arguments of the
calling function. The list must contain the following elements:
</p>

<ul>
<li> <p><code>arg_x</code> - the name of the argument <code>x</code> as a character string
</p>
</li>
<li> <p><code>arg_condition</code> - the name of the argument <code>condition</code> as a character
string
</p>
</li>
<li> <p><code>arg_xvars</code> - the name of the argument <code>xvars</code> as a character string
</p>
</li>
<li> <p><code>arg_yvars</code> - the name of the argument <code>yvars</code> as a character string
</p>
</li>
<li> <p><code>call</code> - an environment in which to evaluate the error messages.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with found patterns. Each row represents a single call of
the callback function <code>f</code>.
</p>


<h3>Author(s)</h3>

<p>Michal Burda
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dig">dig()</a></code>, <code><a href="#topic+var_grid">var_grid()</a></code>; see also <code><a href="#topic+dig_correlations">dig_correlations()</a></code> and
<code><a href="#topic+dig_paired_baseline_contrasts">dig_paired_baseline_contrasts()</a></code>, as they are using this function internally.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># *** Example of crisp (boolean) patterns:
# dichotomize iris$Species
crispIris &lt;- partition(iris, Species)

# a simple callback function that computes mean difference of `xvar` and `yvar`
f &lt;- function(pd) {
    list(m = mean(pd[[1]] - pd[[2]]),
         n = nrow(pd))
    }

# call f() for each condition created from column `Species`
dig_grid(crispIris,
         f,
         condition = starts_with("Species"),
         xvars = starts_with("Sepal"),
         yvars = starts_with("Petal"),
         type = "crisp")

# *** Example of fuzzy patterns:
# create fuzzy sets from Sepal columns
fuzzyIris &lt;- partition(iris,
                       starts_with("Sepal"),
                       .method = "triangle",
                       .breaks = 3)

# a simple callback function that computes a weighted mean of a difference of
# `xvar` and `yvar`
f &lt;- function(d, weights) {
    list(m = weighted.mean(d[[1]] - d[[2]], w = weights),
         w = sum(weights))
}

# call f() for each fuzzy condition created from column fuzzy sets whose
# names start with "Sepal"
dig_grid(fuzzyIris,
         f,
         condition = starts_with("Sepal"),
         xvars = Petal.Length,
         yvars = Petal.Width,
         type = "fuzzy")
</code></pre>

<hr>
<h2 id='dig_implications'>Search for association rules</h2><span id='topic+dig_implications'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>Association rules identify conditions (<em>antecedents</em>) under which
a specific feature (<em>consequent</em>) is present very often.
</p>

<dl>
<dt>Scheme:</dt><dd><p><code style="white-space: pre;">&#8288;A =&gt; C&#8288;</code><br /><br />
If condition <code>A</code> is satisfied, then the feature <code>C</code> is present very often.</p>
</dd>
<dt>Example:</dt><dd><p><code style="white-space: pre;">&#8288;university_edu &amp; middle_age &amp; IT_industry =&gt; high_income&#8288;</code><br /><br />
People in <em>middle age</em> with <em>university education</em> working in IT industry
have very likely a <em>high income</em>.</p>
</dd>
</dl>

<p>Antecedent <code>A</code> is usually a set of predicates, and consequent <code>C</code> is a single
predicate.
</p>
<p>For the following explanations we need a mathematical function <code class="reqn">supp(I)</code>, which
is defined for a set <code class="reqn">I</code> of predicates as a relative frequency of rows satisfying
all predicates from <code class="reqn">I</code>. For logical data, <code class="reqn">supp(I)</code> equals to the relative
frequency of rows, for which all predicates <code class="reqn">i_1, i_2, \ldots, i_n</code> from <code class="reqn">I</code> are TRUE.
For numerical (double) input, <code class="reqn">supp(I)</code> is computed as the mean (over all rows)
of truth degrees of the formula <code style="white-space: pre;">&#8288;i_1 AND i_2 AND ... AND i_n&#8288;</code>, where
<code>AND</code> is a triangular norm selected by the <code>t_norm</code> argument.
</p>
<p>Association rules are characterized with the following quality measures.
</p>
<p><em>Length</em> of a rule is the number of elements in the antecedent.
</p>
<p><em>Coverage</em> of a rule is equal to <code class="reqn">supp(A)</code>.
</p>
<p><em>Consequent support</em> of a rule is equal to <code class="reqn">supp(\{c\})</code>.
</p>
<p><em>Support</em> of a rule is equal to <code class="reqn">supp(A \cup \{c\})</code>.
</p>
<p><em>Confidence</em> of a rule is the fraction <code class="reqn">supp(A) / supp(A \cup \{c\})</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dig_implications(
  x,
  antecedent = everything(),
  consequent = everything(),
  disjoint = var_names(colnames(x)),
  min_length = 0L,
  max_length = Inf,
  min_coverage = 0,
  min_support = 0,
  min_confidence = 0,
  contingency_table = FALSE,
  measures = NULL,
  t_norm = "goguen",
  threads = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dig_implications_+3A_x">x</code></td>
<td>
<p>a matrix or data frame with data to search in. The matrix must be
numeric (double) or logical. If <code>x</code> is a data frame then each column
must be either numeric (double) or logical.</p>
</td></tr>
<tr><td><code id="dig_implications_+3A_antecedent">antecedent</code></td>
<td>
<p>a tidyselect expression (see
<a href="https://tidyselect.r-lib.org/articles/syntax.html">tidyselect syntax</a>)
specifying the columns to use in the antecedent (left) part of the rules</p>
</td></tr>
<tr><td><code id="dig_implications_+3A_consequent">consequent</code></td>
<td>
<p>a tidyselect expression (see
<a href="https://tidyselect.r-lib.org/articles/syntax.html">tidyselect syntax</a>)
specifying the columns to use in the consequent (right) part of the rules</p>
</td></tr>
<tr><td><code id="dig_implications_+3A_disjoint">disjoint</code></td>
<td>
<p>an atomic vector of size equal to the number of columns of <code>x</code>
that specifies the groups of predicates: if some elements of the <code>disjoint</code>
vector are equal, then the corresponding columns of <code>x</code> will NOT be
present together in a single condition. If <code>x</code> is prepared with
<code><a href="#topic+partition">partition()</a></code>, using the <code><a href="#topic+var_names">var_names()</a></code> function on <code>x</code>'s column names
is a convenient way to create the <code>disjoint</code> vector.</p>
</td></tr>
<tr><td><code id="dig_implications_+3A_min_length">min_length</code></td>
<td>
<p>the minimum length, i.e., the minimum number of predicates in the
antecedent, of a rule to be generated. Value must be greater or equal to 0.
If 0, rules with empty antecedent are generated in the first place.</p>
</td></tr>
<tr><td><code id="dig_implications_+3A_max_length">max_length</code></td>
<td>
<p>The maximum length, i.e., the maximum number of predicates in the
antecedent, of a rule to be generated. If equal to Inf, the maximum length
is limited only by the number of available predicates.</p>
</td></tr>
<tr><td><code id="dig_implications_+3A_min_coverage">min_coverage</code></td>
<td>
<p>the minimum coverage of a rule in the dataset <code>x</code>.
(See Description for the definition of <em>coverage</em>.)</p>
</td></tr>
<tr><td><code id="dig_implications_+3A_min_support">min_support</code></td>
<td>
<p>the minimum support of a rule in the dataset <code>x</code>.
(See Description for the definition of <em>support</em>.)</p>
</td></tr>
<tr><td><code id="dig_implications_+3A_min_confidence">min_confidence</code></td>
<td>
<p>the minimum confidence of a rule in the dataset <code>x</code>.
(See Description for the definition of <em>confidence</em>.)</p>
</td></tr>
<tr><td><code id="dig_implications_+3A_contingency_table">contingency_table</code></td>
<td>
<p>a logical value indicating whether to provide a contingency
table for each rule. If <code>TRUE</code>, the columns <code>pp</code>, <code>pn</code>, <code>np</code>, and <code>nn</code> are
added to the output table. These columns contain the number of rows satisfying
the antecedent and the consequent, the antecedent but not the consequent,
the consequent but not the antecedent, and neither the antecedent nor the
consequent, respectively.</p>
</td></tr>
<tr><td><code id="dig_implications_+3A_measures">measures</code></td>
<td>
<p>a character vector specifying the additional quality measures to compute.
If <code>NULL</code>, no additional measures are computed. Possible values are <code>"lift"</code>,
<code>"conviction"</code>, <code>"added_value"</code>.
See <a href="https://mhahsler.github.io/arules/docs/measures">https://mhahsler.github.io/arules/docs/measures</a>
for a description of the measures.</p>
</td></tr>
<tr><td><code id="dig_implications_+3A_t_norm">t_norm</code></td>
<td>
<p>a t-norm used to compute conjunction of weights. It must be one of
<code>"goedel"</code> (minimum t-norm), <code>"goguen"</code> (product t-norm), or <code>"lukas"</code>
(Lukasiewicz t-norm).</p>
</td></tr>
<tr><td><code id="dig_implications_+3A_threads">threads</code></td>
<td>
<p>the number of threads to use for parallel computation.</p>
</td></tr>
<tr><td><code id="dig_implications_+3A_...">...</code></td>
<td>
<p>Further arguments, currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with found patterns and computed quality measures.
</p>


<h3>Author(s)</h3>

<p>Michal Burda
</p>


<h3>See Also</h3>

<p><code><a href="#topic+partition">partition()</a></code>, <code><a href="#topic+var_names">var_names()</a></code>, <code><a href="#topic+dig">dig()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- partition(mtcars, .breaks = 2)
dig_associations(d,
                 antecedent = !starts_with("mpg"),
                 consequent = starts_with("mpg"),
                 min_support = 0.3,
                 min_confidence = 0.8,
                 measures = c("lift", "conviction"))
</code></pre>

<hr>
<h2 id='dig_paired_baseline_contrasts'>Search for conditions that provide significant differences between paired
variables</h2><span id='topic+dig_paired_baseline_contrasts'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Paired baseline contrast patterns identify conditions under which there is
a significant difference in some statistical feature between two paired
numeric variables.
</p>

<dl>
<dt>Scheme:</dt><dd><p><code>(xvar - yvar) != 0 | C</code><br /><br />
There is a statistically significant difference between paired variables
<code>xvar</code> and <code>yvar</code> under the condition <code>C</code>.</p>
</dd>
<dt>Example:</dt><dd><p><code>(daily_ice_cream_income - daily_tea_income) &gt; 0 | sunny</code><br /><br />
Under the condition of <em>sunny weather</em>, the paired test shows that
<em>daily ice-cream income</em> is significantly higher than the
<em>daily tea income</em>.</p>
</dd>
</dl>

<p>The paired baseline contrast  is computed using a paired version of a statistical test,
which is specified by the <code>method</code> argument. The function computes the paired
contrast between all pairs of variables, where the first variable is
specified by the <code>xvars</code> argument and the second variable is specified by the
<code>yvars</code> argument. Paired baseline contrasts are computed in sub-data corresponding
to conditions generated from the <code>condition</code> columns. Function
<code>dig_paired_baseline_contrasts()</code> supports crisp conditions only, i.e.,
the condition columns in <code>x</code> must be logical.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dig_paired_baseline_contrasts(
  x,
  condition = where(is.logical),
  xvars = where(is.numeric),
  yvars = where(is.numeric),
  disjoint = var_names(colnames(x)),
  min_length = 0L,
  max_length = Inf,
  min_support = 0,
  max_support = 1,
  method = "t",
  alternative = "two.sided",
  h0 = 0,
  conf_level = 0.95,
  max_p_value = 1,
  t_var_equal = FALSE,
  wilcox_exact = FALSE,
  wilcox_correct = TRUE,
  wilcox_tol_root = 1e-04,
  wilcox_digits_rank = Inf,
  max_results = Inf,
  verbose = FALSE,
  threads = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dig_paired_baseline_contrasts_+3A_x">x</code></td>
<td>
<p>a matrix or data frame with data to search the patterns in.</p>
</td></tr>
<tr><td><code id="dig_paired_baseline_contrasts_+3A_condition">condition</code></td>
<td>
<p>a tidyselect expression (see
<a href="https://tidyselect.r-lib.org/articles/syntax.html">tidyselect syntax</a>)
specifying the columns to use as condition predicates</p>
</td></tr>
<tr><td><code id="dig_paired_baseline_contrasts_+3A_xvars">xvars</code></td>
<td>
<p>a tidyselect expression (see
<a href="https://tidyselect.r-lib.org/articles/syntax.html">tidyselect syntax</a>)
specifying the columns to use for computation of contrasts</p>
</td></tr>
<tr><td><code id="dig_paired_baseline_contrasts_+3A_yvars">yvars</code></td>
<td>
<p>a tidyselect expression (see
<a href="https://tidyselect.r-lib.org/articles/syntax.html">tidyselect syntax</a>)
specifying the columns to use for computation of contrasts</p>
</td></tr>
<tr><td><code id="dig_paired_baseline_contrasts_+3A_disjoint">disjoint</code></td>
<td>
<p>an atomic vector of size equal to the number of columns of <code>x</code>
that specifies the groups of predicates: if some elements of the <code>disjoint</code>
vector are equal, then the corresponding columns of <code>x</code> will NOT be
present together in a single condition. If <code>x</code> is prepared with
<code><a href="#topic+partition">partition()</a></code>, using the <code><a href="#topic+var_names">var_names()</a></code> function on <code>x</code>'s column names
is a convenient way to create the <code>disjoint</code> vector.</p>
</td></tr>
<tr><td><code id="dig_paired_baseline_contrasts_+3A_min_length">min_length</code></td>
<td>
<p>the minimum size (the minimum number of predicates) of the
condition to be generated (must be greater or equal to 0). If 0, the
empty condition is generated in the first place.</p>
</td></tr>
<tr><td><code id="dig_paired_baseline_contrasts_+3A_max_length">max_length</code></td>
<td>
<p>The maximum size (the maximum number of predicates) of the
condition to be generated. If equal to Inf, the maximum length of
conditions is limited only by the number of available predicates.</p>
</td></tr>
<tr><td><code id="dig_paired_baseline_contrasts_+3A_min_support">min_support</code></td>
<td>
<p>the minimum support of a condition to trigger the callback
function for it. The support of the condition is the relative frequency
of the condition in the dataset <code>x</code>. For logical data, it equals to the
relative frequency of rows such that all condition predicates are TRUE on it.
For numerical (double) input, the support is computed as the mean (over all
rows) of multiplications of predicate values.</p>
</td></tr>
<tr><td><code id="dig_paired_baseline_contrasts_+3A_max_support">max_support</code></td>
<td>
<p>the maximum support of a condition to trigger the callback
function for it. See argument <code>min_support</code> for details of what is the
support of a condition.</p>
</td></tr>
<tr><td><code id="dig_paired_baseline_contrasts_+3A_method">method</code></td>
<td>
<p>a character string indicating which contrast to compute.
One of <code>"t"</code>, for parametric, or <code>"wilcox"</code>, for non-parametric test on
equality in position.</p>
</td></tr>
<tr><td><code id="dig_paired_baseline_contrasts_+3A_alternative">alternative</code></td>
<td>
<p>indicates the alternative hypothesis and must be one of
<code>"two.sided"</code>, <code>"greater"</code> or <code>"less"</code>. <code>"greater"</code> corresponds to
positive association, <code>"less"</code> to negative association.</p>
</td></tr>
<tr><td><code id="dig_paired_baseline_contrasts_+3A_h0">h0</code></td>
<td>
<p>a numeric value specifying the null hypothesis for the test. For
the <code>"t"</code> method, it is the difference in means. For the <code>"wilcox"</code> method,
it is the difference in medians. The default value is 0.</p>
</td></tr>
<tr><td><code id="dig_paired_baseline_contrasts_+3A_conf_level">conf_level</code></td>
<td>
<p>a numeric value specifying the level of the confidence
interval. The default value is 0.95.</p>
</td></tr>
<tr><td><code id="dig_paired_baseline_contrasts_+3A_max_p_value">max_p_value</code></td>
<td>
<p>the maximum p-value of a test for the pattern to be considered
significant. If the p-value of the test is greater than <code>max_p_value</code>, the
pattern is not included in the result.</p>
</td></tr>
<tr><td><code id="dig_paired_baseline_contrasts_+3A_t_var_equal">t_var_equal</code></td>
<td>
<p>(used for the <code>"t"</code> method only) a logical value indicating
whether the variances of the two samples are assumed to be equal. If
<code>TRUE</code>, the pooled variance is used to estimate the variance in the t-test.
If <code>FALSE</code>, the Welch (or Satterthwaite) approximation to the degrees of
freedom is used. See <code><a href="stats.html#topic+t.test">t.test()</a></code> and its <code>var.equal</code> argument for more
information.</p>
</td></tr>
<tr><td><code id="dig_paired_baseline_contrasts_+3A_wilcox_exact">wilcox_exact</code></td>
<td>
<p>(used for the <code>"wilcox"</code> method only) a logical value
indicating whether the exact p-value should be computed. If <code>NULL</code>, the
exact p-value is computed for sample sizes less than 50. See <code><a href="stats.html#topic+wilcox.test">wilcox.test()</a></code>
and its <code>exact</code> argument for more information. Contrary to the behavior
of <code><a href="stats.html#topic+wilcox.test">wilcox.test()</a></code>, the default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="dig_paired_baseline_contrasts_+3A_wilcox_correct">wilcox_correct</code></td>
<td>
<p>(used for the <code>"wilcox"</code> method only) a logical value
indicating whether the continuity correction should be applied in the
normal approximation for the p-value, if <code>wilcox_exact</code> is <code>FALSE</code>. See
<code><a href="stats.html#topic+wilcox.test">wilcox.test()</a></code> and its <code>correct</code> argument for more information.</p>
</td></tr>
<tr><td><code id="dig_paired_baseline_contrasts_+3A_wilcox_tol_root">wilcox_tol_root</code></td>
<td>
<p>(used for the <code>"wilcox"</code> method only) a numeric value
specifying the tolerance for the root-finding algorithm used to compute
the exact p-value. See <code><a href="stats.html#topic+wilcox.test">wilcox.test()</a></code> and its <code>tol.root</code> argument for
more information.</p>
</td></tr>
<tr><td><code id="dig_paired_baseline_contrasts_+3A_wilcox_digits_rank">wilcox_digits_rank</code></td>
<td>
<p>(used for the <code>"wilcox"</code> method only) a numeric value
specifying the number of digits to round the ranks to. See <code><a href="stats.html#topic+wilcox.test">wilcox.test()</a></code>
and its <code>digits.rank</code> argument for more information.</p>
</td></tr>
<tr><td><code id="dig_paired_baseline_contrasts_+3A_max_results">max_results</code></td>
<td>
<p>the maximum number of generated conditions to execute the
callback function on. If the number of found conditions exceeds
<code>max_results</code>, the function stops generating new conditions and returns
the results. To avoid long computations during the search, it is recommended
to set <code>max_results</code> to a reasonable positive value. Setting <code>max_results</code>
to <code>Inf</code> will generate all possible conditions.</p>
</td></tr>
<tr><td><code id="dig_paired_baseline_contrasts_+3A_verbose">verbose</code></td>
<td>
<p>a logical scalar indicating whether to print progress messages.</p>
</td></tr>
<tr><td><code id="dig_paired_baseline_contrasts_+3A_threads">threads</code></td>
<td>
<p>the number of threads to use for parallel computation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with found patterns in rows. The following columns are always
present:
</p>
<table role = "presentation">
<tr><td><code>condition</code></td>
<td>
<p>the condition of the pattern as a character string
in the form <code>{p1 &amp; p2 &amp; ... &amp; pn}</code> where <code>p1</code>, <code>p2</code>, ..., <code>pn</code> are
<code>x</code>'s column names.</p>
</td></tr>
<tr><td><code>support</code></td>
<td>
<p>the support of the condition, i.e., the relative
frequency of the condition in the dataset <code>x</code>.</p>
</td></tr>
<tr><td><code>xvar</code></td>
<td>
<p>the name of the first variable in the contrast.</p>
</td></tr>
<tr><td><code>yvar</code></td>
<td>
<p>the name of the second variable in the contrast.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>the estimated difference of variable <code>var</code>.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>the statistic of the selected test.</p>
</td></tr>
<tr><td><code>p_value</code></td>
<td>
<p>the p-value of the underlying test.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>the number of rows in the sub-data corresponding to
the condition.</p>
</td></tr>
<tr><td><code>conf_int_lo</code></td>
<td>
<p>the lower bound of the confidence interval of the estimate.</p>
</td></tr>
<tr><td><code>conf_int_hi</code></td>
<td>
<p>the upper bound of the confidence interval of the estimate.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string indicating the alternative
hypothesis. The value must be one of <code>"two.sided"</code>, <code>"greater"</code>, or
<code>"less"</code>.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating the method used for the
test.</p>
</td></tr>
<tr><td><code>comment</code></td>
<td>
<p>a character string with additional information about the
test (mainly error messages on failure).</p>
</td></tr>
</table>
<p>For the <code>"t"</code> method, the following additional columns are also
present (see also <code><a href="stats.html#topic+t.test">t.test()</a></code>):
</p>
<table role = "presentation">
<tr><td><code>df</code></td>
<td>
<p>the degrees of freedom of the t test.</p>
</td></tr>
<tr><td><code>stderr</code></td>
<td>
<p>the standard error of the mean difference.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michal Burda
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dig_baseline_contrasts">dig_baseline_contrasts()</a></code>, <code><a href="#topic+dig_complement_contrasts">dig_complement_contrasts()</a></code>,
<code><a href="#topic+dig">dig()</a></code>, <code><a href="#topic+dig_grid">dig_grid()</a></code>,
<code><a href="stats.html#topic+t.test">stats::t.test()</a></code>, <code><a href="stats.html#topic+wilcox.test">stats::wilcox.test()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute ratio of sepal and petal length and width for iris dataset
crispIris &lt;- iris
crispIris$Sepal.Ratio &lt;- iris$Sepal.Length / iris$Sepal.Width
crispIris$Petal.Ratio &lt;- iris$Petal.Length / iris$Petal.Width

# Create predicates from the Species column
crispIris &lt;- partition(crispIris, Species)

# Compute paired contrasts for ratios of sepal and petal length and width
dig_paired_baseline_contrasts(crispIris,
                              condition = where(is.logical),
                              xvars = Sepal.Ratio,
                              yvars = Petal.Ratio,
                              method = "t",
                              min_support = 0.1)
</code></pre>

<hr>
<h2 id='format_condition'>Format a vector of predicates into a string with a condition</h2><span id='topic+format_condition'></span>

<h3>Description</h3>

<p>Function takes a character vector of predicates and returns a formatted
condition. The format of the condition is a string with predicates
separated by commas and enclosed in curly braces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_condition(condition)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="format_condition_+3A_condition">condition</code></td>
<td>
<p>a character vector of predicates to be formatted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character scalar with a formatted condition
</p>


<h3>Author(s)</h3>

<p>Michal Burda
</p>


<h3>Examples</h3>

<pre><code class='language-R'>format_condition(NULL)              # returns {}
format_condition(c("a", "b", "c"))  # returns {a,b,c}
</code></pre>

<hr>
<h2 id='is_degree'>Tests whether the given argument is a numeric value from the interval
<code class="reqn">[0,1]</code></h2><span id='topic+is_degree'></span>

<h3>Description</h3>

<p>Tests whether the given argument is a numeric value from the interval
<code class="reqn">[0,1]</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_degree(x, na_rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_degree_+3A_x">x</code></td>
<td>
<p>the value to be tested</p>
</td></tr>
<tr><td><code id="is_degree_+3A_na_rm">na_rm</code></td>
<td>
<p>whether to ignore <code>NA</code> values</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if <code>x</code> is a numeric vector, matrix or array with values
between 0 and 1, otherwise, <code>FALSE</code> is returned. If <code>na_rm</code> is <code>TRUE</code>,
<code>NA</code> values are treated as valid values. If <code>na_rm</code> is <code>FALSE</code> and <code>x</code>
contains <code>NA</code> values, <code>FALSE</code> is returned.
</p>


<h3>Author(s)</h3>

<p>Michal Burda
</p>

<hr>
<h2 id='is_subset'>Determine whether the first vector is a subset of the second vector</h2><span id='topic+is_subset'></span>

<h3>Description</h3>

<p>Determine whether the first vector is a subset of the second vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_subset(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_subset_+3A_x">x</code></td>
<td>
<p>the first vector</p>
</td></tr>
<tr><td><code id="is_subset_+3A_y">y</code></td>
<td>
<p>the second vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if <code>x</code> is a subset of <code>y</code>, or <code>FALSE</code> otherwise. <code>x</code> is
considered a subset of <code>y</code> if all elements of <code>x</code> are also in <code>y</code>,
i.e., if <code>setdiff(x, y)</code> is a vector of length 0.
</p>


<h3>Author(s)</h3>

<p>Michal Burda
</p>

<hr>
<h2 id='partition'>Convert columns of data frame to Boolean or fuzzy sets</h2><span id='topic+partition'></span>

<h3>Description</h3>

<p>Convert the selected columns of the data frame into either dummy
logical columns, or into membership degrees of fuzzy sets, while leaving
the remaining columns untouched. Each column selected for transformation
typically yields in multiple columns in the output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partition(
  .data,
  .what = everything(),
  ...,
  .breaks = NULL,
  .labels = NULL,
  .na = TRUE,
  .keep = FALSE,
  .method = "crisp",
  .right = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="partition_+3A_.data">.data</code></td>
<td>
<p>the data frame to be processed</p>
</td></tr>
<tr><td><code id="partition_+3A_.what">.what</code></td>
<td>
<p>a tidyselect expression (see
<a href="https://tidyselect.r-lib.org/articles/syntax.html">tidyselect syntax</a>)
specifying the columns to be transformed</p>
</td></tr>
<tr><td><code id="partition_+3A_...">...</code></td>
<td>
<p>optional other tidyselect expressions selecting additional
columns to be processed</p>
</td></tr>
<tr><td><code id="partition_+3A_.breaks">.breaks</code></td>
<td>
<p>for numeric columns, this has to be either an integer scalar
or a numeric vector. If <code>.breaks</code> is an integer scalar, it specifies
the number of resulting intervals to break the numeric column to
(for <code>.method="crisp"</code>) or the number of target fuzzy sets (for
<code>.method="triangle"</code> or <code style="white-space: pre;">&#8288;.method="raisedcos&#8288;</code>). If <code>.breaks</code> is a vector,
the values specify the borders of intervals (for <code>.method="crisp"</code>)
or the breaking points of fuzzy sets.</p>
</td></tr>
<tr><td><code id="partition_+3A_.labels">.labels</code></td>
<td>
<p>character vector specifying the names used to construct
the newly created column names. If <code>NULL</code>, the labels are generated
automatically.</p>
</td></tr>
<tr><td><code id="partition_+3A_.na">.na</code></td>
<td>
<p>if <code>TRUE</code>, an additional logical column is created for each
source column that contains <code>NA</code> values. For column named <code>x</code>, the
newly created column's name will be <code>x=NA</code>.</p>
</td></tr>
<tr><td><code id="partition_+3A_.keep">.keep</code></td>
<td>
<p>if <code>TRUE</code>, the original columns being transformed remain
present in the resulting data frame.</p>
</td></tr>
<tr><td><code id="partition_+3A_.method">.method</code></td>
<td>
<p>The method of transformation for numeric columns. Either
<code>"crisp"</code>, <code>"triangle"</code>, or <code>"raisedcos"</code> is required.</p>
</td></tr>
<tr><td><code id="partition_+3A_.right">.right</code></td>
<td>
<p>If <code>.method="crisp"</code>, this argument specifies if the
intervals should be closed on the right (and open on the left) or
vice versa.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Transformations performed by this function are typically useful as a
preprocessing step before using the <code><a href="#topic+dig">dig()</a></code> function or some of its
derivatives (<code><a href="#topic+dig_correlations">dig_correlations()</a></code>, <code><a href="#topic+dig_paired_baseline_contrasts">dig_paired_baseline_contrasts()</a></code>,
<code><a href="#topic+dig_associations">dig_associations()</a></code>).
</p>
<p>The transformation of selected columns differ based on the type. Concretely:
</p>

<ul>
<li> <p><strong>logical</strong> column <code>x</code> is transformed into pair of logical columns,
<code>x=TRUE</code> and<code>x=FALSE</code>;
</p>
</li>
<li> <p><strong>factor</strong> column <code>x</code>, which has levels <code>l1</code>, <code>l2</code>, and <code>l3</code>, is transformed
into three logical columns named <code>x=l1</code>, <code>x=l2</code>, and <code>x=l3</code>;
</p>
</li>
<li> <p><strong>numeric</strong> column<code>x</code> is transformed accordingly to <code>.method</code> argument:
</p>

<ul>
<li><p> if <code>.method="crisp"</code>, the column is first transformed into a factor
with intervals as factor levels and then it is processed as a factor
(see above);
</p>
</li>
<li><p> for other <code>.method</code> (<code>triangle</code> or <code>raisedcos</code>), several new columns
are created, where each column has numeric values from the interval
<code class="reqn">[0,1]</code> and represents a certain fuzzy set (either triangular or
raised-cosinal).
Details of transformation of numeric columns can be specified with
additional arguments (<code>.breaks</code>, <code>.labels</code>, <code>.right</code>).
</p>
</li></ul>

</li></ul>



<h3>Value</h3>

<p>A tibble created by transforming <code>.data</code>.
</p>


<h3>Author(s)</h3>

<p>Michal Burda
</p>


<h3>Examples</h3>

<pre><code class='language-R'># transform logical columns and factors
d &lt;- data.frame(a = c(TRUE, TRUE, FALSE),
                b = factor(c("A", "B", "A")),
                c = c(1, 2, 3))
partition(d, a, b)

# transform numeric columns to logical columns (crisp transformation)
partition(CO2, conc:uptake, .method = "crisp", .breaks = 3)

# transform numeric columns to fuzzy sets (triangle transformation)
partition(CO2, conc:uptake, .method = "triangle", .breaks = 3)

# complex transformation with different settings for each column
CO2 |&gt;
    partition(Plant:Treatment) |&gt;
    partition(conc,
              .method = "raisedcos",
              .breaks = c(-Inf, 95, 175, 350, 675, 1000, Inf)) |&gt;
    partition(uptake,
              .method = "triangle",
              .breaks = c(-Inf, 7.7, 28.3, 45.5, Inf),
              .labels = c("low", "medium", "high"))
</code></pre>

<hr>
<h2 id='var_grid'>Create a tibble of combinations of selected column names</h2><span id='topic+var_grid'></span>

<h3>Description</h3>

<p><code>xvars</code> and <code>yvars</code> arguments are tidyselect expressions (see
<a href="https://tidyselect.r-lib.org/articles/syntax.html">tidyselect syntax</a>) that
specify the columns of <code>x</code> whose names will be used as a domain for
combinations.
</p>
<p>If <code>yvars</code> is <code>NULL</code>, the function creates a tibble with one column <code>var</code>
enumerating all column names specified by the <code>xvars</code> argument.
</p>
<p>If <code>yvars</code> is not <code>NULL</code>, the function creates a tibble with two columns,
<code>xvar</code> and <code>yvar</code>, whose rows enumerate all combinations of column names
specified by the <code>xvars</code> and <code>yvars</code> argument.
</p>
<p>It is allowed to specify the same column in both <code>xvars</code> and <code>yvars</code>
arguments. In such a case, the combinations of the same column with itself
are removed from the result.
</p>
<p>In other words, the function creates a grid of all possible pairs
<code class="reqn">(xx, yy)</code> where <code class="reqn">xx \in xvars</code>, <code class="reqn">yy \in yvars</code>,
and <code class="reqn">xx \neq yy</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var_grid(
  x,
  xvars = everything(),
  yvars = everything(),
  allow = "all",
  xvar_name = if (quo_is_null(enquo(yvars))) "var" else "xvar",
  yvar_name = "yvar",
  error_context = list(arg_x = "x", arg_xvars = "xvars", arg_yvars = "yvars", arg_allow =
    "allow", arg_xvar_name = "xvar_name", arg_yvar_name = "yvar_name", call =
    current_env())
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="var_grid_+3A_x">x</code></td>
<td>
<p>either a data frame or a matrix</p>
</td></tr>
<tr><td><code id="var_grid_+3A_xvars">xvars</code></td>
<td>
<p>a tidyselect expression (see
<a href="https://tidyselect.r-lib.org/articles/syntax.html">tidyselect syntax</a>)
specifying the columns of <code>x</code>, whose names will be used as a domain for
combinations use at the first place (xvar)</p>
</td></tr>
<tr><td><code id="var_grid_+3A_yvars">yvars</code></td>
<td>
<p><code>NULL</code> or a tidyselect expression (see
<a href="https://tidyselect.r-lib.org/articles/syntax.html">tidyselect syntax</a>)
specifying the columns of <code>x</code>, whose names will be used as a domain for
combinations use at the second place (yvar)</p>
</td></tr>
<tr><td><code id="var_grid_+3A_allow">allow</code></td>
<td>
<p>a character string specifying which columns are allowed to be
selected by <code>xvars</code> and <code>yvars</code> arguments. Possible values are:
</p>

<ul>
<li> <p><code>"all"</code> - all columns are allowed to be selected
</p>
</li>
<li> <p><code>"numeric"</code> - only numeric columns are allowed to be selected
</p>
</li></ul>
</td></tr>
<tr><td><code id="var_grid_+3A_xvar_name">xvar_name</code></td>
<td>
<p>the name of the first column in the resulting tibble.</p>
</td></tr>
<tr><td><code id="var_grid_+3A_yvar_name">yvar_name</code></td>
<td>
<p>the name of the second column in the resulting tibble.
The column does not exist if <code>yvars</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="var_grid_+3A_error_context">error_context</code></td>
<td>
<p>A list of details to be used in error messages.
This argument is useful when <code>var_grid()</code> is called from another
function to provide error messages, which refer to arguments of the
calling function. The list must contain the following elements:
</p>

<ul>
<li> <p><code>arg_x</code> - the name of the argument <code>x</code> as a character string
</p>
</li>
<li> <p><code>arg_xvars</code> - the name of the argument <code>xvars</code> as a character string
</p>
</li>
<li> <p><code>arg_yvars</code> - the name of the argument <code>yvars</code> as a character string
</p>
</li>
<li> <p><code>arg_allow</code> - the name of the argument <code>allow</code> as a character string
</p>
</li>
<li> <p><code>arg_xvar_name</code> - the name of the <code>xvar</code> column in the output tibble
</p>
</li>
<li> <p><code>arg_yvar_name</code> - the name of the <code>yvar</code> column in the output tibble
</p>
</li>
<li> <p><code>call</code> - an environment in which to evaluate the error messages.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>if <code>yvars</code> is <code>NULL</code>, the function returns a tibble with a single
column (<code>var</code>). If <code>yvars</code> is a non-<code>NULL</code> expression, the function
returns two columns (<code>xvar</code> and <code>yvar</code>) with rows enumerating
all combinations of column names specified by tidyselect expressions
in <code>xvars</code> and <code>yvars</code> arguments.
</p>


<h3>Author(s)</h3>

<p>Michal Burda
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a grid of combinations of all pairs of columns in the CO2 dataset:
var_grid(CO2)

# Create a grid of combinations of all pairs of columns in the CO2 dataset
# such that the first, i.e., `xvar` column is `Plant`, `Type`, or
# `Treatment`, and the second, i.e., `yvar` column is `conc` or `uptake`:
var_grid(CO2, xvars = Plant:Treatment, yvars = conc:uptake)
</code></pre>

<hr>
<h2 id='var_names'>Extract variable names from predicates</h2><span id='topic+var_names'></span>

<h3>Description</h3>

<p>The function assumes that <code>x</code> is a vector of predicate names, i.e., a character
vector with elements compatible with pattern <code style="white-space: pre;">&#8288;&lt;varname&gt;=&lt;value&gt;&#8288;</code>. The function
returns the <code style="white-space: pre;">&#8288;&lt;varname&gt;&#8288;</code> part of these elements. If the string does not
correspond to the pattern <code style="white-space: pre;">&#8288;&lt;varname&gt;=&lt;value&gt;&#8288;</code>, i.e., if the equal sign (<code>=</code>)
is missing in the string, the whole string is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var_names(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="var_names_+3A_x">x</code></td>
<td>
<p>A character vector of predicate names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code style="white-space: pre;">&#8288;&lt;varname&gt;&#8288;</code> part of predicate names in <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Michal Burda
</p>


<h3>Examples</h3>

<pre><code class='language-R'>var_names(c("a=1", "a=2", "b=x", "b=y")) # returns c("a", "a", "b", "b")
</code></pre>

<hr>
<h2 id='which_antichain'>Return indices of first elements of the list, which are incomparable with preceding
elements.</h2><span id='topic+which_antichain'></span>

<h3>Description</h3>

<p>The function returns indices of elements from the given list <code>x</code>, which are incomparable
(i.e., it is neither subset nor superset) with any preceding element. The first element
is always selected. The next element is selected only if it is incomparable with all
previously selected elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>which_antichain(x, distance = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="which_antichain_+3A_x">x</code></td>
<td>
<p>a list of integerish vectors</p>
</td></tr>
<tr><td><code id="which_antichain_+3A_distance">distance</code></td>
<td>
<p>a non-negative integer, which specifies the allowed discrepancy between compared sets</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer vector of indices of selected (incomparable) elements.
</p>


<h3>Author(s)</h3>

<p>Michal Burda
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
