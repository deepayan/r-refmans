<!DOCTYPE html><html><head><title>Help for package nuggets</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {nuggets}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dichotomize'><p>Create dummy columns from logicals or factors in a data frame</p></a></li>
<li><a href='#dig'><p>Search for rules</p></a></li>
<li><a href='#dig_correlations'><p>Search for conditional correlations</p></a></li>
<li><a href='#dig_implications'><p>Search for implicative rules</p></a></li>
<li><a href='#format_condition'><p>Format condition - convert a character vector to character scalar</p></a></li>
<li><a href='#is_subset'><p>Determine whether the first vector is a subset of the second vector</p></a></li>
<li><a href='#nuggets-package'><p>nuggets: Extensible Data Pattern Searching Framework</p></a></li>
<li><a href='#which_antichain'><p>Return indices of first elements of the list, which are incomparable with preceding</p>
elements.</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Extensible Data Pattern Searching Framework</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-08</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michal Burda &lt;michal.burda@osu.cz&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Extensible framework for
    subgroup discovery (Atzmueller (2015) &lt;<a href="https://doi.org/10.1002%2Fwidm.1144">doi:10.1002/widm.1144</a>&gt;),
    contrast patterns (Chen (2022) &lt;<a href="https://doi.org/10.48550%2FarXiv.2209.13556">doi:10.48550/arXiv.2209.13556</a>&gt;),
    emerging patterns (Dong (1999) &lt;<a href="https://doi.org/10.1145%2F312129.312191">doi:10.1145/312129.312191</a>&gt;) and
    association rules (Agrawal (1994) <a href="https://www.vldb.org/conf/1994/P487.PDF">https://www.vldb.org/conf/1994/P487.PDF</a>).
    Both crisp (binary) and fuzzy data are supported.
    It generates conditions in the form of elementary conjunctions, evaluates
    them on a dataset and checks the induced sub-data for interesting statistical
    properties. Currently, the package searches for implicative association rules
    and conditional correlations (HÃ¡jek (1978) &lt;<a href="https://doi.org/10.1007%2F978-3-642-66943-9">doi:10.1007/978-3-642-66943-9</a>&gt;).
    A user-defined function may be defined to evaluate on each generated
    condition to search for custom patterns.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, methods, Rcpp, rlang, stats, tibble, tidyr, tidyselect</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, testthat</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++17</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), xml2</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-08 09:56:12 UTC; michal</td>
</tr>
<tr>
<td>Author:</td>
<td>Michal Burda <a href="https://orcid.org/0000-0002-4182-4407"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-09 15:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='dichotomize'>Create dummy columns from logicals or factors in a data frame</h2><span id='topic+dichotomize'></span>

<h3>Description</h3>

<p>Create dummy logical columns from selected columns of the data frame.
Dummy columns may be created for logical or factor columns as follows:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dichotomize(.data, what = everything(), ..., .keep = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dichotomize_+3A_.data">.data</code></td>
<td>
<p>a data frame to be processed</p>
</td></tr>
<tr><td><code id="dichotomize_+3A_what">what</code></td>
<td>
<p>a tidyselect expression (see
<a href="https://tidyselect.r-lib.org/articles/syntax.html">tidyselect syntax</a>)
selecting the columns to be processed</p>
</td></tr>
<tr><td><code id="dichotomize_+3A_...">...</code></td>
<td>
<p>further tidyselect expressions for selecting the columns to
be processed</p>
</td></tr>
<tr><td><code id="dichotomize_+3A_.keep">.keep</code></td>
<td>
<p>whether to keep the original columns. If FALSE, the original
columns are removed from the result.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> for logical column <code>col</code>, a pair of columns is created named <code>col=T</code>
and <code>col=F</code> where the former (resp. latter) is equal to the original
(resp. negation of the original);
</p>
</li>
<li><p> for factor column <code>col</code>, a new logical column is created for each
level <code>l</code> of the factor <code>col</code> and named as <code>col=l</code> with a value set
to TRUE wherever the original column is equal to <code>l</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>A tibble with selected columns replaced with dummy columns.
</p>


<h3>Author(s)</h3>

<p>Michal Burda
</p>

<hr>
<h2 id='dig'>Search for rules</h2><span id='topic+dig'></span><span id='topic+dig.default'></span><span id='topic+dig.matrix'></span><span id='topic+dig.data.frame'></span>

<h3>Description</h3>

<p>This is a general function that enumerates all conditions created from
data in <code>x</code> and calls the callback function <code>f</code> on each.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dig(x, f, ...)

## Default S3 method:
dig(x, f, ...)

## S3 method for class 'matrix'
dig(
  x,
  f,
  condition = everything(),
  focus = NULL,
  disjoint = NULL,
  min_length = 0,
  max_length = Inf,
  min_support = 0,
  t_norm = "goguen",
  ...
)

## S3 method for class 'data.frame'
dig(
  x,
  f,
  condition = everything(),
  focus = NULL,
  disjoint = NULL,
  min_length = 0,
  max_length = Inf,
  min_support = 0,
  t_norm = "goguen",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dig_+3A_x">x</code></td>
<td>
<p>a matrix or data frame. The matrix must be numeric (double) or logical.
If <code>x</code> is a data frame then each column must be either numeric (double) or
logical.</p>
</td></tr>
<tr><td><code id="dig_+3A_f">f</code></td>
<td>
<p>the callback function executed for each generated condition. This
function may have some of the following arguments. Based on the present
arguments, the algorithm would provide information about the generated
condition:
- condition - a numeric vector of column indices that represent the predicates
of the condition. Names of the vector correspond to column names;
- foci_supports - a list of support of foci columns (see <code>focus</code> argument
to specify, which columns are foci);
- support - a numeric scalar value of the current condition's support;
- indices - a logical vector indicating the rows satisfying the condition;
- weights - (similar to indices) weights of rows to which they satisfy
the current condition.</p>
</td></tr>
<tr><td><code id="dig_+3A_...">...</code></td>
<td>
<p>Further arguments, currently unused.</p>
</td></tr>
<tr><td><code id="dig_+3A_condition">condition</code></td>
<td>
<p>a tidyselect expression (see
<a href="https://tidyselect.r-lib.org/articles/syntax.html">tidyselect syntax</a>)
specifying the columns to use as condition predicates</p>
</td></tr>
<tr><td><code id="dig_+3A_focus">focus</code></td>
<td>
<p>a tidyselect expression (see
<a href="https://tidyselect.r-lib.org/articles/syntax.html">tidyselect syntax</a>)
specifying the columns to use as focus predicates</p>
</td></tr>
<tr><td><code id="dig_+3A_disjoint">disjoint</code></td>
<td>
<p>an atomic vector of size equal to the number of columns of <code>x</code>
that specifies the groups of predicates: if some elements of the <code>disjoint</code>
vector are equal, then the corresponding columns of <code>x</code> will NOT be
present together in a single condition.</p>
</td></tr>
<tr><td><code id="dig_+3A_min_length">min_length</code></td>
<td>
<p>the minimum size (the minimum number of predicates) of the
condition to be generated (must be greater or equal to 0). If 0, the empty
condition is generated in the first place.</p>
</td></tr>
<tr><td><code id="dig_+3A_max_length">max_length</code></td>
<td>
<p>The maximum size (the maximum number of predicates) of the
condition to be generated. If equal to Inf, the maximum length of conditions
is limited only by the number of available predicates.</p>
</td></tr>
<tr><td><code id="dig_+3A_min_support">min_support</code></td>
<td>
<p>the minimum support of a condition to trigger the callback
function for it. The support of the condition is the relative frequency
of the condition in the dataset <code>x</code>. For logical data, it equals to the
relative frequency of rows such that all condition predicates are TRUE on it.
For numerical (double) input, the support is computed as the mean (over all
rows) of multiplications of predicate values.</p>
</td></tr>
<tr><td><code id="dig_+3A_t_norm">t_norm</code></td>
<td>
<p>a t-norm used to compute conjunction of weights. It must be one of
<code>"goedel"</code> (minimum t-norm), <code>"goguen"</code> (product t-norm), or <code>"lukas"</code>
(Lukasiewicz t-norm).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of results provided by the callback function <code>f</code>.
</p>


<h3>Author(s)</h3>

<p>Michal Burda
</p>

<hr>
<h2 id='dig_correlations'>Search for conditional correlations</h2><span id='topic+dig_correlations'></span>

<h3>Description</h3>

<p>Compute correlation between all combinations of <code>xvars</code> and <code>yvars</code> columns
of <code>x</code> in subdata corresponding to conditions generated from <code>condition</code>
columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dig_correlations(
  x,
  condition = where(is.logical),
  xvars = where(is.numeric),
  yvars = where(is.numeric),
  method = "pearson",
  alternative = "two.sided",
  exact = NULL,
  min_length = 0L,
  max_length = Inf,
  min_support = 0.02,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dig_correlations_+3A_x">x</code></td>
<td>
<p>a matrix or data frame with data to search in. The matrix must be
numeric (double) or logical. If <code>x</code> is a data frame then each column
must be either numeric (double) or logical.</p>
</td></tr>
<tr><td><code id="dig_correlations_+3A_condition">condition</code></td>
<td>
<p>a tidyselect expression (see
<a href="https://tidyselect.r-lib.org/articles/syntax.html">tidyselect syntax</a>)
specifying the columns to use as condition predicates</p>
</td></tr>
<tr><td><code id="dig_correlations_+3A_xvars">xvars</code></td>
<td>
<p>a tidyselect expression (see
<a href="https://tidyselect.r-lib.org/articles/syntax.html">tidyselect syntax</a>)
specifying the columns to use for computation of correlations</p>
</td></tr>
<tr><td><code id="dig_correlations_+3A_yvars">yvars</code></td>
<td>
<p>a tidyselect expression (see
<a href="https://tidyselect.r-lib.org/articles/syntax.html">tidyselect syntax</a>)
specifying the columns to use for computation of correlations</p>
</td></tr>
<tr><td><code id="dig_correlations_+3A_method">method</code></td>
<td>
<p>a character string indicating which correlation coefficient is
to be used for the test. One of <code>"pearson"</code>, <code>"kendall"</code>, or <code>"spearman"</code></p>
</td></tr>
<tr><td><code id="dig_correlations_+3A_alternative">alternative</code></td>
<td>
<p>indicates the alternative hypothesis and must be one of
<code>"two.sided"</code>, <code>"greater"</code> or <code>"less"</code>. <code>"greater"</code> corresponds to
positive association, <code>"less"</code> to negative association.</p>
</td></tr>
<tr><td><code id="dig_correlations_+3A_exact">exact</code></td>
<td>
<p>a logical indicating whether an exact p-value should be computed.
Used for Kendall's <em>tau</em> and Spearman's <em>rho</em>. See <code><a href="stats.html#topic+cor.test">stats::cor.test()</a></code> for
more information.</p>
</td></tr>
<tr><td><code id="dig_correlations_+3A_min_length">min_length</code></td>
<td>
<p>the minimum size (the minimum number of predicates) of the
condition to be generated (must be greater or equal to 0). If 0, the empty
condition is generated in the first place.</p>
</td></tr>
<tr><td><code id="dig_correlations_+3A_max_length">max_length</code></td>
<td>
<p>The maximum size (the maximum number of predicates) of the
condition to be generated. If equal to Inf, the maximum length of conditions
is limited only by the number of available predicates.</p>
</td></tr>
<tr><td><code id="dig_correlations_+3A_min_support">min_support</code></td>
<td>
<p>the minimum support of a condition to trigger the callback
function for it. The support of the condition is the relative frequency
of the condition in the dataset <code>x</code>. For logical data, it equals to the
relative frequency of rows such that all condition predicates are TRUE on it.
For numerical (double) input, the support is computed as the mean (over all
rows) of multiplications of predicate values.</p>
</td></tr>
<tr><td><code id="dig_correlations_+3A_...">...</code></td>
<td>
<p>Further arguments, currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with found rules.
</p>


<h3>Author(s)</h3>

<p>Michal Burda
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dig">dig()</a></code>, <code><a href="stats.html#topic+cor.test">stats::cor.test()</a></code>
</p>

<hr>
<h2 id='dig_implications'>Search for implicative rules</h2><span id='topic+dig_implications'></span>

<h3>Description</h3>

<p>Implicative rule is a rule of the form <code class="reqn">A \Rightarrow c</code>,
where <code class="reqn">A</code> (<em>antecedent</em>) is a set of predicates and <code class="reqn">c</code> (<em>consequent</em>) is a predicate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dig_implications(
  x,
  antecedent = everything(),
  consequent = everything(),
  disjoint = NULL,
  min_length = 0L,
  max_length = Inf,
  min_coverage = 0,
  min_support = 0,
  min_confidence = 0,
  t_norm = "goguen",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dig_implications_+3A_x">x</code></td>
<td>
<p>a matrix or data frame with data to search in. The matrix must be
numeric (double) or logical. If <code>x</code> is a data frame then each column
must be either numeric (double) or logical.</p>
</td></tr>
<tr><td><code id="dig_implications_+3A_antecedent">antecedent</code></td>
<td>
<p>a tidyselect expression (see
<a href="https://tidyselect.r-lib.org/articles/syntax.html">tidyselect syntax</a>)
specifying the columns to use in the antecedent (left) part of the rules</p>
</td></tr>
<tr><td><code id="dig_implications_+3A_consequent">consequent</code></td>
<td>
<p>a tidyselect expression (see
<a href="https://tidyselect.r-lib.org/articles/syntax.html">tidyselect syntax</a>)
specifying the columns to use in the consequent (right) part of the rules</p>
</td></tr>
<tr><td><code id="dig_implications_+3A_disjoint">disjoint</code></td>
<td>
<p>an atomic vector of size equal to the number of columns of <code>x</code>
that specifies the groups of predicates: if some elements of the <code>disjoint</code>
vector are equal, then the corresponding columns of <code>x</code> will NOT be
present together in a single condition.</p>
</td></tr>
<tr><td><code id="dig_implications_+3A_min_length">min_length</code></td>
<td>
<p>the minimum length, i.e., the minimum number of predicates in the
antecedent, of a rule to be generated. Value must be greater or equal to 0.
If 0, rules with empty antecedent are generated in the first place.</p>
</td></tr>
<tr><td><code id="dig_implications_+3A_max_length">max_length</code></td>
<td>
<p>The maximum length, i.e., the maximum number of predicates in the
antecedent, of a rule to be generated. If equal to Inf, the maximum length
is limited only by the number of available predicates.</p>
</td></tr>
<tr><td><code id="dig_implications_+3A_min_coverage">min_coverage</code></td>
<td>
<p>the minimum coverage of a rule in the dataset <code>x</code>.
(See Description for the definition of <em>coverage</em>.)</p>
</td></tr>
<tr><td><code id="dig_implications_+3A_min_support">min_support</code></td>
<td>
<p>the minimum support of a rule in the dataset <code>x</code>.
(See Description for the definition of <em>support</em>.)</p>
</td></tr>
<tr><td><code id="dig_implications_+3A_min_confidence">min_confidence</code></td>
<td>
<p>the minimum confidence of a rule in the dataset <code>x</code>.
(See Description for the definition of <em>confidence</em>.)</p>
</td></tr>
<tr><td><code id="dig_implications_+3A_t_norm">t_norm</code></td>
<td>
<p>a t-norm used to compute conjunction of weights. It must be one of
<code>"goedel"</code> (minimum t-norm), <code>"goguen"</code> (product t-norm), or <code>"lukas"</code>
(Lukasiewicz t-norm).</p>
</td></tr>
<tr><td><code id="dig_implications_+3A_...">...</code></td>
<td>
<p>Further arguments, currently unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the following explanations we need a mathematical function <code class="reqn">supp(I)</code>, which
is defined for a set <code class="reqn">I</code> of predicates as a relative frequency of rows satisfying
all predicates from <code class="reqn">I</code>. For logical data, <code class="reqn">supp(I)</code> equals to the relative
frequency of rows, for which all predicates <code class="reqn">i_1, i_2, \ldots, i_n</code> from <code class="reqn">I</code> are TRUE.
For numerical (double) input, <code class="reqn">supp(I)</code> is computed as the mean (over all rows)
of truth degrees of the formula <code style="white-space: pre;">&#8288;i_1 AND i_2 AND ... AND i_n&#8288;</code>, where
<code>AND</code> is a triangular norm selected by the <code>t_norm</code> argument.
</p>
<p>Implicative rules are characterized with the following quality measures.
</p>
<p><em>Length</em> of a rule is the number of elements in the antecedent.
</p>
<p><em>Coverage</em> of a rule is equal to <code class="reqn">supp(A)</code>.
</p>
<p><em>Support</em> of a rule is equal to <code class="reqn">supp(A \cup \{c\}</code>.
</p>
<p><em>Confidence</em> of a rule is the fraction <code class="reqn">supp(A) / supp(A \cup \{c\})</code>.
</p>


<h3>Value</h3>

<p>A tibble with found rules and computed quality measures.
</p>


<h3>Author(s)</h3>

<p>Michal Burda
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dig">dig()</a></code>
</p>

<hr>
<h2 id='format_condition'>Format condition - convert a character vector to character scalar</h2><span id='topic+format_condition'></span>

<h3>Description</h3>

<p>Function takes a character vector of predicates and returns a formatted condition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_condition(condition)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_condition_+3A_condition">condition</code></td>
<td>
<p>a character vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character scalar
</p>


<h3>Author(s)</h3>

<p>Michal Burda
</p>


<h3>Examples</h3>

<pre><code class='language-R'>format_condition(NULL)              # returns {}
format_condition(c("a", "b", "c"))  # returns {a,b,c}
</code></pre>

<hr>
<h2 id='is_subset'>Determine whether the first vector is a subset of the second vector</h2><span id='topic+is_subset'></span>

<h3>Description</h3>

<p>Determine whether the first vector is a subset of the second vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_subset(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_subset_+3A_x">x</code></td>
<td>
<p>the first vector</p>
</td></tr>
<tr><td><code id="is_subset_+3A_y">y</code></td>
<td>
<p>the second vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if <code>x</code> is a subset of <code>y</code> or FALSE otherwise.
</p>


<h3>Author(s)</h3>

<p>Michal Burda
</p>

<hr>
<h2 id='nuggets-package'>nuggets: Extensible Data Pattern Searching Framework</h2><span id='topic+nuggets'></span><span id='topic+nuggets-package'></span>

<h3>Description</h3>

<p>Extensible framework for subgroup discovery (Atzmueller (2015) <a href="https://doi.org/10.1002/widm.1144">doi:10.1002/widm.1144</a>), contrast patterns (Chen (2022) <a href="https://doi.org/10.48550/arXiv.2209.13556">doi:10.48550/arXiv.2209.13556</a>), emerging patterns (Dong (1999) <a href="https://doi.org/10.1145/312129.312191">doi:10.1145/312129.312191</a>) and association rules (Agrawal (1994) <a href="https://www.vldb.org/conf/1994/P487.PDF">https://www.vldb.org/conf/1994/P487.PDF</a>). Both crisp (binary) and fuzzy data are supported. It generates conditions in the form of elementary conjunctions, evaluates them on a dataset and checks the induced sub-data for interesting statistical properties. Currently, the package searches for implicative association rules and conditional correlations (HÃ¡jek (1978) <a href="https://doi.org/10.1007/978-3-642-66943-9">doi:10.1007/978-3-642-66943-9</a>). A user-defined function may be defined to evaluate on each generated condition to search for custom patterns.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Michal Burda <a href="mailto:michal.burda@osu.cz">michal.burda@osu.cz</a> (<a href="https://orcid.org/0000-0002-4182-4407">ORCID</a>)
</p>

<hr>
<h2 id='which_antichain'>Return indices of first elements of the list, which are incomparable with preceding
elements.</h2><span id='topic+which_antichain'></span>

<h3>Description</h3>

<p>The function returns indices of elements from the given list <code>x</code>, which are incomparable
(i.e., it is neither subset nor superset) with any preceding element. The first element
is always selected. The next element is selected only if it is incomparable with all
previously selected elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>which_antichain(x, distance = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="which_antichain_+3A_x">x</code></td>
<td>
<p>a list of integerish vectors</p>
</td></tr>
<tr><td><code id="which_antichain_+3A_distance">distance</code></td>
<td>
<p>a non-negative integer, which specifies the allowed discrepancy between compared sets</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer vector of indices of selected (incomparable) elements.
</p>


<h3>Author(s)</h3>

<p>Michal Burda
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
