<!DOCTYPE html><html lang="en"><head><title>Help for package cdata</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cdata}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cdata-package'><p><code>cdata</code>: Fluid Data Transformations.</p></a></li>
<li><a href='#+25+2A+2A+25'><p>Multiply/join row records into block records.</p></a></li>
<li><a href='#+25+2F+2F+25'><p>Factor-out (aggregate/project) block records into row records.</p></a></li>
<li><a href='#blocks_to_rowrecs'><p>Map data records from block records to row records.</p></a></li>
<li><a href='#blocks_to_rowrecs_q'><p>Map sets rows to columns (query based, take name of table).</p></a></li>
<li><a href='#blocks_to_rowrecs_spec'><p>Create a block records to row records transform specification.</p></a></li>
<li><a href='#build_pivot_control'><p>Build a blocks_to_rowrecs()/rowrecs_to_blocks() control table that specifies a pivot from a <code>data.frame</code>.</p></a></li>
<li><a href='#build_pivot_control_q'><p>Build a blocks_to_rowrecs_q() control table that specifies a pivot (query based, takes name of table).</p></a></li>
<li><a href='#build_unpivot_control'><p>Build a rowrecs_to_blocks() control table that specifies a un-pivot (or &quot;shred&quot;).</p></a></li>
<li><a href='#check_cols_form_unique_keys'><p>Check columns form unique keys</p></a></li>
<li><a href='#convert_cdata_spec_to_yaml'><p>Convert a layout_specification, blocks_to_rowrecs_spec, or rowrecs_to_blocks_spec to a simple object.</p></a></li>
<li><a href='#convert_records'><p>General transform from arbitrary record shape to arbitrary record shape.</p></a></li>
<li><a href='#convert_yaml_to_cdata_spec'><p>Read a cdata record transform from a simple object (such as is imported from YAML).</p></a></li>
<li><a href='#get_transform_details'><p>Upack details of a cdata record transform.</p></a></li>
<li><a href='#layout_by'><p>Use transform spec to layout data.</p></a></li>
<li><a href='#layout_by.blocks_to_rowrecs_spec'><p>Use transform spec to layout data.</p></a></li>
<li><a href='#layout_by.cdata_general_transform_spec'><p>Use transform spec to layout data.</p></a></li>
<li><a href='#layout_by.rowrecs_to_blocks_spec'><p>Use transform spec to layout data.</p></a></li>
<li><a href='#layout_specification'><p>Create a record to record spec.</p></a></li>
<li><a href='#map_fields'><p>Map field values from one column into new derived columns (takes a <code>data.frame</code>).</p></a></li>
<li><a href='#map_fields_q'><p>Map field values from one column into new derived columns (query based, takes name of table).</p></a></li>
<li><a href='#pivot_to_rowrecs'><p>Map data records from block records that have one row per measurement value to row records.</p></a></li>
<li><a href='#qlook'><p>Quick look at remote data</p></a></li>
<li><a href='#rowrecs_to_blocks'><p>Map a data records from row records to block records.</p></a></li>
<li><a href='#rowrecs_to_blocks_q'><p>Map a set of columns to rows (query based, take name of table).</p></a></li>
<li><a href='#rowrecs_to_blocks_spec'><p>Create a row records to block records transform specification.</p></a></li>
<li><a href='#rows_are_uniquely_keyed'><p>Check if table rows are uniquely keyed by keyset.</p></a></li>
<li><a href='#unpivot_to_blocks'><p>Map a data records from row records to block records with one record row per columnsToTakeFrom value.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fluid Data Transformations</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-19</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/WinVector/cdata/">https://github.com/WinVector/cdata/</a>,
<a href="https://winvector.github.io/cdata/">https://winvector.github.io/cdata/</a></td>
</tr>
<tr>
<td>Maintainer:</td>
<td>John Mount &lt;jmount@win-vector.com&gt;</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/WinVector/cdata/issues">https://github.com/WinVector/cdata/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Supplies higher-order coordinatized data specification and fluid transform operators that include pivot and anti-pivot as special cases. 
    The methodology is describe in 'Zumel', 2018, "Fluid data reshaping with 'cdata'", <a href="https://winvector.github.io/FluidData/FluidDataReshapingWithCdata.html">https://winvector.github.io/FluidData/FluidDataReshapingWithCdata.html</a> , &lt;<a href="https://doi.org/10.5281%2Fzenodo.1173299">doi:10.5281/zenodo.1173299</a>&gt; .
    This package introduces the idea of explicit control table specification of data transforms.
    Works on in-memory data or on remote data using 'rquery' and 'SQL' database interfaces.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0), wrapr (&ge; 2.0.9)</td>
</tr>
<tr>
<td>Imports:</td>
<td>rquery (&ge; 1.4.9), rqdatatable (&ge; 1.3.2), methods, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>DBI, RSQLite, knitr, rmarkdown, yaml, tinytest</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-19 23:37:26 UTC; johnmount</td>
</tr>
<tr>
<td>Author:</td>
<td>John Mount [aut, cre],
  Nina Zumel [aut],
  Win-Vector LLC [cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-20 00:02:32 UTC</td>
</tr>
</table>
<hr>
<h2 id='cdata-package'><code>cdata</code>: Fluid Data Transformations.</h2><span id='topic+cdata'></span><span id='topic+cdata-package'></span>

<h3>Description</h3>

<p>Supplies implementations of higher order &quot;fluid data&quot; transforms.  These
transforms move data between rows and columns, are controlled by a graphical
transformation specification, and have pivot and un-pivot as special cases.
Large scale implementation is based on 'rquery', so should be usable on
'SQL' compliant data sources (include large systems such as 'PostgreSQL' and
'Spark').
This package introduces the idea of  control table specification of data transforms (later aslo adapted from 'cdata' by 'tidyr').
A theory of fluid data transforms can be found in the following articles:
<a href="https://winvector.github.io/FluidData/FluidDataReshapingWithCdata.html">https://winvector.github.io/FluidData/FluidDataReshapingWithCdata.html</a>,
<a href="https://github.com/WinVector/cdata">https://github.com/WinVector/cdata</a> and <a href="https://winvector.github.io/FluidData/FluidData.html">https://winvector.github.io/FluidData/FluidData.html</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: John Mount <a href="mailto:jmount@win-vector.com">jmount@win-vector.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Nina Zumel <a href="mailto:nzumel@win-vector.com">nzumel@win-vector.com</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p>  Win-Vector LLC [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/WinVector/cdata/">https://github.com/WinVector/cdata/</a>
</p>
</li>
<li> <p><a href="https://winvector.github.io/cdata/">https://winvector.github.io/cdata/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/WinVector/cdata/issues">https://github.com/WinVector/cdata/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+25+2A+2A+25'>Multiply/join row records into block records.</h2><span id='topic++25+2A+2A+25'></span>

<h3>Description</h3>

<p>Call <code>rowrecs_to_blocks()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table %**% transform
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25+2B2A+2B2A+2B25_+3A_table">table</code></td>
<td>
<p>data (data.frame or relop).</p>
</td></tr>
<tr><td><code id="+2B25+2B2A+2B2A+2B25_+3A_transform">transform</code></td>
<td>
<p>a rowrecs_to_blocks_spec.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>rowrecs_to_blocks() result.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
d &lt;- wrapr::build_frame(
  "id", "AUC", "R2" |
  1   , 0.7  , 0.4  |
  2   , 0.8  , 0.5  )

transform &lt;- rowrecs_to_blocks_spec(
  wrapr::qchar_frame(
    "measure", "value" |
    "AUC"    , AUC     |
    "R2"     , R2      ),
  recordKeys = "id")

d %**% transform

# identity (in structure)
d %**% transform %//% t(transform)

</code></pre>

<hr>
<h2 id='+25+2F+2F+25'>Factor-out (aggregate/project) block records into row records.</h2><span id='topic++25+2F+2F+25'></span>

<h3>Description</h3>

<p>Call <code>blocks_to_rowrecs()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table %//% transform
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25+2B2F+2B2F+2B25_+3A_table">table</code></td>
<td>
<p>data (data.frame or relop).</p>
</td></tr>
<tr><td><code id="+2B25+2B2F+2B2F+2B25_+3A_transform">transform</code></td>
<td>
<p>a rowrecs_to_blocks_spec.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>blocks_to_rowrecs() result.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
d &lt;- wrapr::build_frame(
  "id", "measure", "value" |
  1   , "AUC"    , 0.7     |
  1   , "R2"     , 0.4     |
  2   , "AUC"    , 0.8     |
  2   , "R2"     , 0.5     )

transform &lt;- blocks_to_rowrecs_spec(
  wrapr::qchar_frame(
    "measure", "value" |
    "AUC"    , AUC     |
    "R2"     , R2      ),
  recordKeys = "id")

d %//% transform

# identity (in structure)
d %//% transform %**% t(transform)

</code></pre>

<hr>
<h2 id='blocks_to_rowrecs'>Map data records from block records to row records.</h2><span id='topic+blocks_to_rowrecs'></span><span id='topic+blocks_to_rowrecs.default'></span><span id='topic+blocks_to_rowrecs.relop'></span>

<h3>Description</h3>

<p>Map data records from block records (which each record may be more than one row) to
row records (where each record is a single row).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blocks_to_rowrecs(
  tallTable,
  keyColumns,
  controlTable,
  ...,
  columnsToCopy = NULL,
  checkNames = TRUE,
  checkKeys = TRUE,
  strict = FALSE,
  controlTableKeys = colnames(controlTable)[[1]],
  tmp_name_source = wrapr::mk_tmp_name_source("bltrr"),
  temporary = TRUE,
  allow_rqdatatable = FALSE
)

## Default S3 method:
blocks_to_rowrecs(
  tallTable,
  keyColumns,
  controlTable,
  ...,
  columnsToCopy = NULL,
  checkNames = TRUE,
  checkKeys = FALSE,
  strict = FALSE,
  controlTableKeys = colnames(controlTable)[[1]],
  tmp_name_source = wrapr::mk_tmp_name_source("btrd"),
  temporary = TRUE,
  allow_rqdatatable = FALSE
)

## S3 method for class 'relop'
blocks_to_rowrecs(
  tallTable,
  keyColumns,
  controlTable,
  ...,
  columnsToCopy = NULL,
  checkNames = TRUE,
  checkKeys = FALSE,
  strict = FALSE,
  controlTableKeys = colnames(controlTable)[[1]],
  tmp_name_source = wrapr::mk_tmp_name_source("bltrr"),
  temporary = TRUE,
  allow_rqdatatable = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blocks_to_rowrecs_+3A_talltable">tallTable</code></td>
<td>
<p>data.frame containing data to be mapped (in-memory data.frame).</p>
</td></tr>
<tr><td><code id="blocks_to_rowrecs_+3A_keycolumns">keyColumns</code></td>
<td>
<p>character vector of column defining row groups</p>
</td></tr>
<tr><td><code id="blocks_to_rowrecs_+3A_controltable">controlTable</code></td>
<td>
<p>table specifying mapping (local data frame)</p>
</td></tr>
<tr><td><code id="blocks_to_rowrecs_+3A_...">...</code></td>
<td>
<p>force later arguments to be by name.</p>
</td></tr>
<tr><td><code id="blocks_to_rowrecs_+3A_columnstocopy">columnsToCopy</code></td>
<td>
<p>character, extra columns to copy.</p>
</td></tr>
<tr><td><code id="blocks_to_rowrecs_+3A_checknames">checkNames</code></td>
<td>
<p>logical, if TRUE check names.</p>
</td></tr>
<tr><td><code id="blocks_to_rowrecs_+3A_checkkeys">checkKeys</code></td>
<td>
<p>logical, if TRUE check keyColumns uniquely identify blocks (required).</p>
</td></tr>
<tr><td><code id="blocks_to_rowrecs_+3A_strict">strict</code></td>
<td>
<p>logical, if TRUE check control table name forms</p>
</td></tr>
<tr><td><code id="blocks_to_rowrecs_+3A_controltablekeys">controlTableKeys</code></td>
<td>
<p>character, which column names of the control table are considered to be keys.</p>
</td></tr>
<tr><td><code id="blocks_to_rowrecs_+3A_tmp_name_source">tmp_name_source</code></td>
<td>
<p>a tempNameGenerator from cdata::mk_tmp_name_source()</p>
</td></tr>
<tr><td><code id="blocks_to_rowrecs_+3A_temporary">temporary</code></td>
<td>
<p>logical, if TRUE use temporary tables</p>
</td></tr>
<tr><td><code id="blocks_to_rowrecs_+3A_allow_rqdatatable">allow_rqdatatable</code></td>
<td>
<p>logical, if TRUE allow rqdatatable shortcutting on simple conversions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The controlTable defines the names of each data element in the two notations:
the notation of the tall table (which is row oriented)
and the notation of the wide table (which is column oriented).
controlTable[ , 1] (the group label) cross colnames(controlTable)
(the column labels) are names of data cells in the long form.
controlTable[ , 2:ncol(controlTable)] (column labels)
are names of data cells in the wide form.
To get behavior similar to tidyr::gather/spread one builds the control table
by running an appropriate query over the data.
</p>
<p>Some discussion and examples can be found here:
<a href="https://winvector.github.io/FluidData/FluidData.html">https://winvector.github.io/FluidData/FluidData.html</a> and
here <a href="https://github.com/WinVector/cdata">https://github.com/WinVector/cdata</a>.
</p>


<h3>Value</h3>

<p>wide table built by mapping key-grouped tallTable rows to one row per group
</p>


<h3>See Also</h3>

<p><code><a href="#topic+build_pivot_control">build_pivot_control</a></code>, <code><a href="#topic+rowrecs_to_blocks">rowrecs_to_blocks</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # pivot example
  d &lt;- data.frame(meas = c('AUC', 'R2'),
                  val = c(0.6, 0.2))

  cT &lt;- build_pivot_control(d,
                            columnToTakeKeysFrom= 'meas',
                            columnToTakeValuesFrom= 'val')
  blocks_to_rowrecs(d,
                    keyColumns = NULL,
                    controlTable = cT)


d &lt;- data.frame(meas = c('AUC', 'R2'),
                val = c(0.6, 0.2))
cT &lt;- build_pivot_control(
  d,
  columnToTakeKeysFrom= 'meas',
  columnToTakeValuesFrom= 'val')

ops &lt;- rquery::local_td(d) %.&gt;%
  blocks_to_rowrecs(.,
                    keyColumns = NULL,
                    controlTable = cT)
cat(format(ops))

if(requireNamespace("rqdatatable", quietly = TRUE)) {
  library("rqdatatable")
  d %.&gt;%
    ops %.&gt;%
    print(.)
}

if(requireNamespace("RSQLite", quietly = TRUE)) {
  db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
  DBI::dbWriteTable(db,
                    'd',
                    d,
                    overwrite = TRUE,
                    temporary = TRUE)
  db %.&gt;%
    ops %.&gt;%
    print(.)
  DBI::dbDisconnect(db)
}

</code></pre>

<hr>
<h2 id='blocks_to_rowrecs_q'>Map sets rows to columns (query based, take name of table).</h2><span id='topic+blocks_to_rowrecs_q'></span>

<h3>Description</h3>

<p>Transform data facts from rows into additional columns using SQL
and controlTable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blocks_to_rowrecs_q(
  tallTable,
  keyColumns,
  controlTable,
  my_db,
  ...,
  columnsToCopy = NULL,
  tempNameGenerator = mk_tmp_name_source("mvtcq"),
  strict = FALSE,
  controlTableKeys = colnames(controlTable)[[1]],
  checkNames = TRUE,
  checkKeys = FALSE,
  showQuery = FALSE,
  defaultValue = NULL,
  dropDups = TRUE,
  temporary = FALSE,
  resultName = NULL,
  incoming_qualifiers = NULL,
  outgoing_qualifiers = NULL,
  executeQuery = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blocks_to_rowrecs_q_+3A_talltable">tallTable</code></td>
<td>
<p>name of table containing data to be mapped (db/Spark data)</p>
</td></tr>
<tr><td><code id="blocks_to_rowrecs_q_+3A_keycolumns">keyColumns</code></td>
<td>
<p>character list of column defining row groups</p>
</td></tr>
<tr><td><code id="blocks_to_rowrecs_q_+3A_controltable">controlTable</code></td>
<td>
<p>table specifying mapping (local data frame)</p>
</td></tr>
<tr><td><code id="blocks_to_rowrecs_q_+3A_my_db">my_db</code></td>
<td>
<p>db handle</p>
</td></tr>
<tr><td><code id="blocks_to_rowrecs_q_+3A_...">...</code></td>
<td>
<p>force later arguments to be by name.</p>
</td></tr>
<tr><td><code id="blocks_to_rowrecs_q_+3A_columnstocopy">columnsToCopy</code></td>
<td>
<p>character list of column names to copy</p>
</td></tr>
<tr><td><code id="blocks_to_rowrecs_q_+3A_tempnamegenerator">tempNameGenerator</code></td>
<td>
<p>a tempNameGenerator from cdata::mk_tmp_name_source()</p>
</td></tr>
<tr><td><code id="blocks_to_rowrecs_q_+3A_strict">strict</code></td>
<td>
<p>logical, if TRUE check control table name forms</p>
</td></tr>
<tr><td><code id="blocks_to_rowrecs_q_+3A_controltablekeys">controlTableKeys</code></td>
<td>
<p>character, which column names of the control table are considered to be keys.</p>
</td></tr>
<tr><td><code id="blocks_to_rowrecs_q_+3A_checknames">checkNames</code></td>
<td>
<p>logical, if TRUE check names</p>
</td></tr>
<tr><td><code id="blocks_to_rowrecs_q_+3A_checkkeys">checkKeys</code></td>
<td>
<p>logical, if TRUE check keying of tallTable</p>
</td></tr>
<tr><td><code id="blocks_to_rowrecs_q_+3A_showquery">showQuery</code></td>
<td>
<p>if TRUE print query</p>
</td></tr>
<tr><td><code id="blocks_to_rowrecs_q_+3A_defaultvalue">defaultValue</code></td>
<td>
<p>if not NULL literal to use for non-match values.</p>
</td></tr>
<tr><td><code id="blocks_to_rowrecs_q_+3A_dropdups">dropDups</code></td>
<td>
<p>logical if TRUE suppress duplicate columns (duplicate determined by name, not content).</p>
</td></tr>
<tr><td><code id="blocks_to_rowrecs_q_+3A_temporary">temporary</code></td>
<td>
<p>logical, if TRUE make result temporary.</p>
</td></tr>
<tr><td><code id="blocks_to_rowrecs_q_+3A_resultname">resultName</code></td>
<td>
<p>character, name for result table.</p>
</td></tr>
<tr><td><code id="blocks_to_rowrecs_q_+3A_incoming_qualifiers">incoming_qualifiers</code></td>
<td>
<p>optional named ordered vector of strings carrying additional db hierarchy terms, such as schema.</p>
</td></tr>
<tr><td><code id="blocks_to_rowrecs_q_+3A_outgoing_qualifiers">outgoing_qualifiers</code></td>
<td>
<p>optional named ordered vector of strings carrying additional db hierarchy terms, such as schema.</p>
</td></tr>
<tr><td><code id="blocks_to_rowrecs_q_+3A_executequery">executeQuery</code></td>
<td>
<p>logical, if TRUE execute the query and return result.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is using the theory of &quot;fluid data&quot;n
(<a href="https://github.com/WinVector/cdata">https://github.com/WinVector/cdata</a>), which includes the
principle that each data cell has coordinates independent of the
storage details and storage detail dependent coordinates (usually
row-id, column-id, and group-id) can be re-derived at will (the
other principle is that there may not be &quot;one true preferred data
shape&quot; and many re-shapings of data may be needed to match data to
different algorithms and methods).
</p>
<p>The controlTable defines the names of each data element in the two notations:
the notation of the tall table (which is row oriented)
and the notation of the wide table (which is column oriented).
controlTable[ , 1] (the group label) cross colnames(controlTable)
(the column labels) are names of data cells in the long form.
controlTable[ , 2:ncol(controlTable)] (column labels)
are names of data cells in the wide form.
To get behavior similar to tidyr::gather/spread one builds the control table
by running an appropriate query over the data.
</p>
<p>Some discussion and examples can be found here:
<a href="https://winvector.github.io/FluidData/FluidData.html">https://winvector.github.io/FluidData/FluidData.html</a> and
here <a href="https://github.com/WinVector/cdata">https://github.com/WinVector/cdata</a>.
</p>


<h3>Value</h3>

<p>wide table built by mapping key-grouped tallTable rows to one row per group
</p>


<h3>See Also</h3>

<p><code><a href="#topic+build_pivot_control_q">build_pivot_control_q</a></code>, <code><a href="#topic+blocks_to_rowrecs">blocks_to_rowrecs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("DBI", quietly = TRUE) &amp;&amp;
  requireNamespace("RSQLite", quietly = TRUE)) {
  my_db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
  # pivot example
  d &lt;- data.frame(meas = c('AUC', 'R2'), val = c(0.6, 0.2))
  rquery::rq_copy_to(my_db,
                    'd',
                    d,
                    temporary = TRUE)
  cT &lt;- build_pivot_control_q('d',
                              columnToTakeKeysFrom= 'meas',
                              columnToTakeValuesFrom= 'val',
                              my_db = my_db)
  tab &lt;- blocks_to_rowrecs_q('d',
                             keyColumns = NULL,
                             controlTable = cT,
                             my_db = my_db)
  qlook(my_db, tab)
  DBI::dbDisconnect(my_db)
}

</code></pre>

<hr>
<h2 id='blocks_to_rowrecs_spec'>Create a block records to row records transform specification.</h2><span id='topic+blocks_to_rowrecs_spec'></span>

<h3>Description</h3>

<p>Create a block records to row records transform specification object that holds the pivot control table, specification of
extra row keys, and control table keys.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blocks_to_rowrecs_spec(
  controlTable,
  ...,
  recordKeys = character(0),
  controlTableKeys = colnames(controlTable)[[1]],
  checkNames = TRUE,
  checkKeys = TRUE,
  strict = FALSE,
  allow_rqdatatable = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blocks_to_rowrecs_spec_+3A_controltable">controlTable</code></td>
<td>
<p>an all character data frame or cdata pivot control.</p>
</td></tr>
<tr><td><code id="blocks_to_rowrecs_spec_+3A_...">...</code></td>
<td>
<p>not used, force later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="blocks_to_rowrecs_spec_+3A_recordkeys">recordKeys</code></td>
<td>
<p>vector of columns identifying records.</p>
</td></tr>
<tr><td><code id="blocks_to_rowrecs_spec_+3A_controltablekeys">controlTableKeys</code></td>
<td>
<p>vector of keying columns of the controlTable.</p>
</td></tr>
<tr><td><code id="blocks_to_rowrecs_spec_+3A_checknames">checkNames</code></td>
<td>
<p>passed to blocks_to_rowrecs.</p>
</td></tr>
<tr><td><code id="blocks_to_rowrecs_spec_+3A_checkkeys">checkKeys</code></td>
<td>
<p>passed to blocks_to_rowrecs.</p>
</td></tr>
<tr><td><code id="blocks_to_rowrecs_spec_+3A_strict">strict</code></td>
<td>
<p>passed to blocks_to_rowrecs.</p>
</td></tr>
<tr><td><code id="blocks_to_rowrecs_spec_+3A_allow_rqdatatable">allow_rqdatatable</code></td>
<td>
<p>logical, if TRUE allow rqdatatable shortcutting on simple conversions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a record specification object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
d &lt;- wrapr::build_frame(
  "id", "measure", "value" |
  1   , "AUC"    , 0.7     |
  1   , "R2"     , 0.4     |
  2   , "AUC"    , 0.8     |
  2   , "R2"     , 0.5     )

transform &lt;- blocks_to_rowrecs_spec(
  wrapr::qchar_frame(
    "measure", "value" |
    "AUC"    , AUC     |
    "R2"     , R2      ),
  recordKeys = "id")

print(transform)

d %.&gt;% transform

inv_transform &lt;- t(transform)
print(inv_transform)

# identity (in structure)
d %.&gt;% transform %.&gt;% inv_transform

# identity again (using .() "immediate" notation)
d %.&gt;% transform %.&gt;% .(t(transform))


</code></pre>

<hr>
<h2 id='build_pivot_control'>Build a blocks_to_rowrecs()/rowrecs_to_blocks() control table that specifies a pivot from a <code>data.frame</code>.</h2><span id='topic+build_pivot_control'></span><span id='topic+build_pivot_control.default'></span><span id='topic+build_pivot_control.relop'></span>

<h3>Description</h3>

<p>Some discussion and examples can be found here: <a href="https://winvector.github.io/FluidData/FluidData.html">https://winvector.github.io/FluidData/FluidData.html</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_pivot_control(
  table,
  columnToTakeKeysFrom,
  columnToTakeValuesFrom,
  ...,
  prefix = columnToTakeKeysFrom,
  sep = NULL,
  tmp_name_source = wrapr::mk_tmp_name_source("bpc"),
  temporary = FALSE
)

## Default S3 method:
build_pivot_control(
  table,
  columnToTakeKeysFrom,
  columnToTakeValuesFrom,
  ...,
  prefix = columnToTakeKeysFrom,
  sep = NULL,
  tmp_name_source = wrapr::mk_tmp_name_source("bpcd"),
  temporary = TRUE
)

## S3 method for class 'relop'
build_pivot_control(
  table,
  columnToTakeKeysFrom,
  columnToTakeValuesFrom,
  ...,
  prefix = columnToTakeKeysFrom,
  sep = NULL,
  tmp_name_source = wrapr::mk_tmp_name_source("bpc"),
  temporary = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="build_pivot_control_+3A_table">table</code></td>
<td>
<p>data.frame to scan for new column names (in-memory data.frame).</p>
</td></tr>
<tr><td><code id="build_pivot_control_+3A_columntotakekeysfrom">columnToTakeKeysFrom</code></td>
<td>
<p>character name of column build new column names from.</p>
</td></tr>
<tr><td><code id="build_pivot_control_+3A_columntotakevaluesfrom">columnToTakeValuesFrom</code></td>
<td>
<p>character name of column to get values from.</p>
</td></tr>
<tr><td><code id="build_pivot_control_+3A_...">...</code></td>
<td>
<p>not used, force later args to be by name</p>
</td></tr>
<tr><td><code id="build_pivot_control_+3A_prefix">prefix</code></td>
<td>
<p>column name prefix (only used when sep is not NULL)</p>
</td></tr>
<tr><td><code id="build_pivot_control_+3A_sep">sep</code></td>
<td>
<p>separator to build complex column names.</p>
</td></tr>
<tr><td><code id="build_pivot_control_+3A_tmp_name_source">tmp_name_source</code></td>
<td>
<p>a tempNameGenerator from cdata::mk_tmp_name_source()</p>
</td></tr>
<tr><td><code id="build_pivot_control_+3A_temporary">temporary</code></td>
<td>
<p>logical, if TRUE use temporary tables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>control table
</p>


<h3>See Also</h3>

<p><code><a href="#topic+blocks_to_rowrecs">blocks_to_rowrecs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  d &lt;- data.frame(measType = c("wt", "ht"),
                  measValue = c(150, 6),
                  stringsAsFactors = FALSE)
  build_pivot_control(d,
                      'measType', 'measValue',
                      sep = '_')


d &lt;- data.frame(measType = c("wt", "ht"),
                measValue = c(150, 6),
                stringsAsFactors = FALSE)

ops &lt;- rquery::local_td(d) %.&gt;%
  build_pivot_control(.,
                      'measType', 'measValue',
                      sep = '_')
cat(format(ops))

if(requireNamespace("rqdatatable", quietly = TRUE)) {
  library("rqdatatable")
  d %.&gt;%
    ops %.&gt;%
    print(.)
}

if(requireNamespace("RSQLite", quietly = TRUE)) {
  db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
  DBI::dbWriteTable(db,
                    'd',
                    d,
                    overwrite = TRUE,
                    temporary = TRUE)
  db %.&gt;%
    ops %.&gt;%
    print(.)
  DBI::dbDisconnect(db)
}

</code></pre>

<hr>
<h2 id='build_pivot_control_q'>Build a blocks_to_rowrecs_q() control table that specifies a pivot (query based, takes name of table).</h2><span id='topic+build_pivot_control_q'></span>

<h3>Description</h3>

<p>Some discussion and examples can be found here: <a href="https://winvector.github.io/FluidData/FluidData.html">https://winvector.github.io/FluidData/FluidData.html</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_pivot_control_q(
  tableName,
  columnToTakeKeysFrom,
  columnToTakeValuesFrom,
  my_db,
  ...,
  prefix = columnToTakeKeysFrom,
  sep = NULL,
  qualifiers = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="build_pivot_control_q_+3A_tablename">tableName</code></td>
<td>
<p>Name of table to scan for new column names.</p>
</td></tr>
<tr><td><code id="build_pivot_control_q_+3A_columntotakekeysfrom">columnToTakeKeysFrom</code></td>
<td>
<p>character name of column build new column names from.</p>
</td></tr>
<tr><td><code id="build_pivot_control_q_+3A_columntotakevaluesfrom">columnToTakeValuesFrom</code></td>
<td>
<p>character name of column to get values from.</p>
</td></tr>
<tr><td><code id="build_pivot_control_q_+3A_my_db">my_db</code></td>
<td>
<p>db handle</p>
</td></tr>
<tr><td><code id="build_pivot_control_q_+3A_...">...</code></td>
<td>
<p>not used, force later args to be by name</p>
</td></tr>
<tr><td><code id="build_pivot_control_q_+3A_prefix">prefix</code></td>
<td>
<p>column name prefix (only used when sep is not NULL)</p>
</td></tr>
<tr><td><code id="build_pivot_control_q_+3A_sep">sep</code></td>
<td>
<p>separator to build complex column names.</p>
</td></tr>
<tr><td><code id="build_pivot_control_q_+3A_qualifiers">qualifiers</code></td>
<td>
<p>optional named ordered vector of strings carrying additional db hierarchy terms, such as schema.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>control table
</p>


<h3>See Also</h3>

<p><code><a href="#topic+blocks_to_rowrecs_q">blocks_to_rowrecs_q</a></code>, <code><a href="#topic+build_pivot_control">build_pivot_control</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("DBI", quietly = TRUE) &amp;&amp;
  requireNamespace("RSQLite", quietly = TRUE)) {
  my_db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
  d &lt;- data.frame(measType = c("wt", "ht"),
                  measValue = c(150, 6),
                  stringsAsFactors = FALSE)
  rquery::rq_copy_to(my_db,
                    'd',
                    d,
                    overwrite = TRUE,
                    temporary = TRUE)
  build_pivot_control_q('d', 'measType', 'measValue',
                        my_db = my_db,
                        sep = '_') %.&gt;%
     print(.)
  DBI::dbDisconnect(my_db)
}

</code></pre>

<hr>
<h2 id='build_unpivot_control'>Build a rowrecs_to_blocks() control table that specifies a un-pivot (or &quot;shred&quot;).</h2><span id='topic+build_unpivot_control'></span>

<h3>Description</h3>

<p>Some discussion and examples can be found here:
<a href="https://winvector.github.io/FluidData/FluidData.html">https://winvector.github.io/FluidData/FluidData.html</a> and
here <a href="https://github.com/WinVector/cdata">https://github.com/WinVector/cdata</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_unpivot_control(
  nameForNewKeyColumn,
  nameForNewValueColumn,
  columnsToTakeFrom,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="build_unpivot_control_+3A_namefornewkeycolumn">nameForNewKeyColumn</code></td>
<td>
<p>character name of column to write new keys in.</p>
</td></tr>
<tr><td><code id="build_unpivot_control_+3A_namefornewvaluecolumn">nameForNewValueColumn</code></td>
<td>
<p>character name of column to write new values in.</p>
</td></tr>
<tr><td><code id="build_unpivot_control_+3A_columnstotakefrom">columnsToTakeFrom</code></td>
<td>
<p>character array names of columns to take values from.</p>
</td></tr>
<tr><td><code id="build_unpivot_control_+3A_...">...</code></td>
<td>
<p>not used, force later args to be by name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>control table
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rowrecs_to_blocks">rowrecs_to_blocks</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
build_unpivot_control("measurmentType", "measurmentValue", c("c1", "c2"))

</code></pre>

<hr>
<h2 id='check_cols_form_unique_keys'>Check columns form unique keys</h2><span id='topic+check_cols_form_unique_keys'></span>

<h3>Description</h3>

<p>Check columns form unique keys
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_cols_form_unique_keys(data, keyColNames)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_cols_form_unique_keys_+3A_data">data</code></td>
<td>
<p>data.frame to check</p>
</td></tr>
<tr><td><code id="check_cols_form_unique_keys_+3A_keycolnames">keyColNames</code></td>
<td>
<p>character, names of columns to consider as keys</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical TRUE if rows are uniquely keyed by named columns
</p>

<hr>
<h2 id='convert_cdata_spec_to_yaml'>Convert a layout_specification, blocks_to_rowrecs_spec, or rowrecs_to_blocks_spec to a simple object.</h2><span id='topic+convert_cdata_spec_to_yaml'></span>

<h3>Description</h3>

<p>Convert a layout_specification, blocks_to_rowrecs_spec, or rowrecs_to_blocks_spec to a simple object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_cdata_spec_to_yaml(spec)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert_cdata_spec_to_yaml_+3A_spec">spec</code></td>
<td>
<p>a layout_specification, blocks_to_rowrecs_spec, or rowrecs_to_blocks_spec</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a simple object suitable for YAML serialization
</p>

<hr>
<h2 id='convert_records'>General transform from arbitrary record shape to arbitrary record shape.</h2><span id='topic+convert_records'></span>

<h3>Description</h3>

<p>General transform from arbitrary record shape to arbitrary record shape.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_records(
  table,
  incoming_shape = NULL,
  outgoing_shape = NULL,
  ...,
  keyColumns = NULL,
  columnsToCopy_in = NULL,
  checkNames = TRUE,
  checkKeys = FALSE,
  strict = FALSE,
  incoming_controlTableKeys = colnames(incoming_shape)[[1]],
  outgoing_controlTableKeys = colnames(outgoing_shape)[[1]],
  tmp_name_source = wrapr::mk_tmp_name_source("crec"),
  temporary = TRUE,
  allow_rqdatatable_in = FALSE,
  allow_rqdatatable_out = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert_records_+3A_table">table</code></td>
<td>
<p>data.frame or relop.</p>
</td></tr>
<tr><td><code id="convert_records_+3A_incoming_shape">incoming_shape</code></td>
<td>
<p>data.frame, definition of incoming record shape.</p>
</td></tr>
<tr><td><code id="convert_records_+3A_outgoing_shape">outgoing_shape</code></td>
<td>
<p>data.frame, defintion of outgoing record shape.</p>
</td></tr>
<tr><td><code id="convert_records_+3A_...">...</code></td>
<td>
<p>force later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="convert_records_+3A_keycolumns">keyColumns</code></td>
<td>
<p>character vector of column defining incoming row groups</p>
</td></tr>
<tr><td><code id="convert_records_+3A_columnstocopy_in">columnsToCopy_in</code></td>
<td>
<p>character array of incoming column names to copy.</p>
</td></tr>
<tr><td><code id="convert_records_+3A_checknames">checkNames</code></td>
<td>
<p>logical, if TRUE check names.</p>
</td></tr>
<tr><td><code id="convert_records_+3A_checkkeys">checkKeys</code></td>
<td>
<p>logical, if TRUE check columnsToCopy form row keys (not a requirement, unless you want to be able to invert the operation).</p>
</td></tr>
<tr><td><code id="convert_records_+3A_strict">strict</code></td>
<td>
<p>logical, if TRUE check control table name forms.</p>
</td></tr>
<tr><td><code id="convert_records_+3A_incoming_controltablekeys">incoming_controlTableKeys</code></td>
<td>
<p>character, which column names of the incoming control table are considered to be keys.</p>
</td></tr>
<tr><td><code id="convert_records_+3A_outgoing_controltablekeys">outgoing_controlTableKeys</code></td>
<td>
<p>character, which column names of the outgoing control table are considered to be keys.</p>
</td></tr>
<tr><td><code id="convert_records_+3A_tmp_name_source">tmp_name_source</code></td>
<td>
<p>a tempNameGenerator from cdata::mk_tmp_name_source()</p>
</td></tr>
<tr><td><code id="convert_records_+3A_temporary">temporary</code></td>
<td>
<p>logical, if TRUE use temporary tables</p>
</td></tr>
<tr><td><code id="convert_records_+3A_allow_rqdatatable_in">allow_rqdatatable_in</code></td>
<td>
<p>logical, if TRUE allow rqdatatable shortcutting on simple conversions.</p>
</td></tr>
<tr><td><code id="convert_records_+3A_allow_rqdatatable_out">allow_rqdatatable_out</code></td>
<td>
<p>logical, if TRUE allow rqdatatable shortcutting on simple conversions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>processing pipeline or transformed table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

incoming_shape &lt;- qchar_frame(
  "row",  "col1", "col2", "col3" |
  "row1",   v11,     v12,  v13   |
  "row2",   v21,     v22,  v23   |
  "row3",   v31,     v32,  v33   )


outgoing_shape &lt;- qchar_frame(
  "column", "row1", "row2", "row3" |
  "col1",      v11,  v21  ,  v31   |
  "col2",      v12,  v22  ,  v32   |
  "col3",      v13,  v23  ,  v33   )

data &lt;- build_frame(
  'record_id', 'row',  'col1', 'col2', 'col3'  |
  1,           'row1',  1,      2,      3      |
  1,           'row2',  4,      5,      6      |
  1,           'row3',  7,      8,      9      |
  2,           'row1',  11,     12,     13     |
  2,           'row2',  14,     15,     16     |
  2,           'row3',  17,     18,     19     )

print(data)

convert_records(
  data,
  keyColumns = 'record_id',
  incoming_shape = incoming_shape,
  outgoing_shape = outgoing_shape)

td &lt;- rquery::local_td(data)

ops &lt;- convert_records(
  td,
  keyColumns = 'record_id',
  incoming_shape = incoming_shape,
  outgoing_shape = outgoing_shape)

cat(format(ops))



</code></pre>

<hr>
<h2 id='convert_yaml_to_cdata_spec'>Read a cdata record transform from a simple object (such as is imported from YAML).</h2><span id='topic+convert_yaml_to_cdata_spec'></span>

<h3>Description</h3>

<p>Read a cdata record transform from a simple object (such as is imported from YAML).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_yaml_to_cdata_spec(obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert_yaml_to_cdata_spec_+3A_obj">obj</code></td>
<td>
<p>object to convert</p>
</td></tr>
</table>


<h3>Value</h3>

<p>cdata transform specification
</p>

<hr>
<h2 id='get_transform_details'>Upack details of a cdata record transform.</h2><span id='topic+get_transform_details'></span>

<h3>Description</h3>

<p>Unpack details, especially: generate data frames representing both sides of a transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_transform_details(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_transform_details_+3A_x">x</code></td>
<td>
<p>blocks_to_rowrecs_spec or rowrecs_to_blocks_spec</p>
</td></tr>
</table>


<h3>Value</h3>

<p>detailed fields
</p>

<hr>
<h2 id='layout_by'>Use transform spec to layout data.</h2><span id='topic+layout_by'></span>

<h3>Description</h3>

<p>Use transform spec to layout data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_by(transform, table)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="layout_by_+3A_transform">transform</code></td>
<td>
<p>object of class rowrecs_to_blocks_spec</p>
</td></tr>
<tr><td><code id="layout_by_+3A_table">table</code></td>
<td>
<p>data.frame or relop.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>re-arranged data or data reference (relop).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
d &lt;- wrapr::build_frame(
  "id"  , "AUC", "R2" |
    1   , 0.7  , 0.4  |
    2   , 0.8  , 0.5  )
transform &lt;- rowrecs_to_blocks_spec(
  wrapr::qchar_frame(
    "measure", "value" |
    "AUC"    , AUC     |
    "R2"     , R2      ),
  recordKeys = "id")
print(transform)
layout_by(transform, d)

d &lt;- wrapr::build_frame(
  "id", "measure", "value" |
  1   , "AUC"    , 0.7     |
  1   , "R2"     , 0.4     |
  2   , "AUC"    , 0.8     |
  2   , "R2"     , 0.5     )
transform &lt;- blocks_to_rowrecs_spec(
  wrapr::qchar_frame(
    "measure", "value" |
    "AUC"    , AUC     |
    "R2"     , R2      ),
  recordKeys = "id")
print(transform)
layout_by(transform, d)

</code></pre>

<hr>
<h2 id='layout_by.blocks_to_rowrecs_spec'>Use transform spec to layout data.</h2><span id='topic+layout_by.blocks_to_rowrecs_spec'></span>

<h3>Description</h3>

<p>Use transform spec to layout data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'blocks_to_rowrecs_spec'
layout_by(transform, table)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="layout_by.blocks_to_rowrecs_spec_+3A_transform">transform</code></td>
<td>
<p>object of class blocks_to_rowrecs_spec.</p>
</td></tr>
<tr><td><code id="layout_by.blocks_to_rowrecs_spec_+3A_table">table</code></td>
<td>
<p>data.frame or relop.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>re-arranged data or data reference (relop).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
d &lt;- wrapr::build_frame(
  "id", "measure", "value" |
  1   , "AUC"    , 0.7     |
  1   , "R2"     , 0.4     |
  2   , "AUC"    , 0.8     |
  2   , "R2"     , 0.5     )

transform &lt;- blocks_to_rowrecs_spec(
  wrapr::qchar_frame(
    "measure", "value" |
    "AUC"    , AUC     |
    "R2"     , R2      ),
  recordKeys = "id")

print(transform)

layout_by(transform, d)

</code></pre>

<hr>
<h2 id='layout_by.cdata_general_transform_spec'>Use transform spec to layout data.</h2><span id='topic+layout_by.cdata_general_transform_spec'></span>

<h3>Description</h3>

<p>Use transform spec to layout data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cdata_general_transform_spec'
layout_by(transform, table)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="layout_by.cdata_general_transform_spec_+3A_transform">transform</code></td>
<td>
<p>object of class blocks_to_rowrecs_spec.</p>
</td></tr>
<tr><td><code id="layout_by.cdata_general_transform_spec_+3A_table">table</code></td>
<td>
<p>data.frame or relop.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>re-arranged data or data reference (relop).
</p>

<hr>
<h2 id='layout_by.rowrecs_to_blocks_spec'>Use transform spec to layout data.</h2><span id='topic+layout_by.rowrecs_to_blocks_spec'></span>

<h3>Description</h3>

<p>Use transform spec to layout data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rowrecs_to_blocks_spec'
layout_by(transform, table)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="layout_by.rowrecs_to_blocks_spec_+3A_transform">transform</code></td>
<td>
<p>object of class rowrecs_to_blocks_spec</p>
</td></tr>
<tr><td><code id="layout_by.rowrecs_to_blocks_spec_+3A_table">table</code></td>
<td>
<p>data.frame or relop.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>re-arranged data or data reference (relop).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
d &lt;- wrapr::build_frame(
  "id"  , "AUC", "R2" |
    1   , 0.7  , 0.4  |
    2   , 0.8  , 0.5  )

transform &lt;- rowrecs_to_blocks_spec(
  wrapr::qchar_frame(
    "measure", "value" |
    "AUC"    , AUC     |
    "R2"     , R2      ),
  recordKeys = "id")

print(transform)
layout_by(transform, d)

</code></pre>

<hr>
<h2 id='layout_specification'>Create a record to record spec.</h2><span id='topic+layout_specification'></span>

<h3>Description</h3>

<p>Create a general record to record transform specification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_specification(
  incoming_shape = NULL,
  outgoing_shape = NULL,
  ...,
  recordKeys = character(0),
  incoming_controlTableKeys = colnames(incoming_shape)[[1]],
  outgoing_controlTableKeys = colnames(outgoing_shape)[[1]],
  checkNames = TRUE,
  checkKeys = TRUE,
  strict = FALSE,
  allow_rqdatatable_in = FALSE,
  allow_rqdatatable_out = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="layout_specification_+3A_incoming_shape">incoming_shape</code></td>
<td>
<p>data.frame, definition of incoming record shape.</p>
</td></tr>
<tr><td><code id="layout_specification_+3A_outgoing_shape">outgoing_shape</code></td>
<td>
<p>data.frame, defintion of outgoing record shape.</p>
</td></tr>
<tr><td><code id="layout_specification_+3A_...">...</code></td>
<td>
<p>not used, force later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="layout_specification_+3A_recordkeys">recordKeys</code></td>
<td>
<p>vector of columns identifying records.</p>
</td></tr>
<tr><td><code id="layout_specification_+3A_incoming_controltablekeys">incoming_controlTableKeys</code></td>
<td>
<p>character, which column names of the incoming control table are considered to be keys.</p>
</td></tr>
<tr><td><code id="layout_specification_+3A_outgoing_controltablekeys">outgoing_controlTableKeys</code></td>
<td>
<p>character, which column names of the outgoing control table are considered to be keys.</p>
</td></tr>
<tr><td><code id="layout_specification_+3A_checknames">checkNames</code></td>
<td>
<p>passed to rowrecs_to_blocks.</p>
</td></tr>
<tr><td><code id="layout_specification_+3A_checkkeys">checkKeys</code></td>
<td>
<p>passed to rowrecs_to_blocks.</p>
</td></tr>
<tr><td><code id="layout_specification_+3A_strict">strict</code></td>
<td>
<p>passed to rowrecs_to_blocks.</p>
</td></tr>
<tr><td><code id="layout_specification_+3A_allow_rqdatatable_in">allow_rqdatatable_in</code></td>
<td>
<p>logical, if TRUE allow rqdatatable shortcutting on simple conversions.</p>
</td></tr>
<tr><td><code id="layout_specification_+3A_allow_rqdatatable_out">allow_rqdatatable_out</code></td>
<td>
<p>logical, if TRUE allow rqdatatable shortcutting on simple conversions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a record specification object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

incoming_shape &lt;- qchar_frame(
  "row",  "col1", "col2", "col3" |
  "row1",   v11,     v12,  v13   |
  "row2",   v21,     v22,  v23   |
  "row3",   v31,     v32,  v33   )


outgoing_shape &lt;- qchar_frame(
  "column", "row1", "row2", "row3" |
  "col1",      v11,  v21  ,  v31   |
  "col2",      v12,  v22  ,  v32   |
  "col3",      v13,  v23  ,  v33   )

data &lt;- build_frame(
  'record_id', 'row',  'col1', 'col2', 'col3'  |
  1,           'row1',  1,      2,      3      |
  1,           'row2',  4,      5,      6      |
  1,           'row3',  7,      8,      9      |
  2,           'row1',  11,     12,     13     |
  2,           'row2',  14,     15,     16     |
  2,           'row3',  17,     18,     19     )

print(data)

layout &lt;- layout_specification(
  incoming_shape = incoming_shape,
  outgoing_shape = outgoing_shape,
  recordKeys = 'record_id')

print(layout)

data %.&gt;% layout

data %.&gt;% layout %.&gt;% .(t(layout))

</code></pre>

<hr>
<h2 id='map_fields'>Map field values from one column into new derived columns (takes a <code>data.frame</code>).</h2><span id='topic+map_fields'></span>

<h3>Description</h3>

<p>Map field values from one column into new derived columns (takes a <code>data.frame</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map_fields(d, cname, m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="map_fields_+3A_d">d</code></td>
<td>
<p>name of table to re-map.</p>
</td></tr>
<tr><td><code id="map_fields_+3A_cname">cname</code></td>
<td>
<p>name of column to re-map.</p>
</td></tr>
<tr><td><code id="map_fields_+3A_m">m</code></td>
<td>
<p>name of table of data describing the mapping (cname column is source, derived columns are destinations).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>re-mapped table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
d &lt;- data.frame(what = c("acc", "loss",
                         "val_acc", "val_loss"),
                score = c(0.8, 1.2,
                       0.7, 1.7),
                stringsAsFactors = FALSE)
m &lt;- data.frame(what = c("acc", "loss",
                         "val_acc", "val_loss"),
                measure = c("accuracy", "log-loss",
                            "accuracy", "log-loss"),
                dataset = c("train", "train", "validation", "validation"),
                stringsAsFactors = FALSE)
map_fields(d, 'what', m)

</code></pre>

<hr>
<h2 id='map_fields_q'>Map field values from one column into new derived columns (query based, takes name of table).</h2><span id='topic+map_fields_q'></span>

<h3>Description</h3>

<p>Map field values from one column into new derived columns (query based, takes name of table).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map_fields_q(
  dname,
  cname,
  mname,
  my_db,
  rname,
  ...,
  d_qualifiers = NULL,
  m_qualifiers = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="map_fields_q_+3A_dname">dname</code></td>
<td>
<p>name of table to re-map.</p>
</td></tr>
<tr><td><code id="map_fields_q_+3A_cname">cname</code></td>
<td>
<p>name of column to re-map.</p>
</td></tr>
<tr><td><code id="map_fields_q_+3A_mname">mname</code></td>
<td>
<p>name of table of data describing the mapping (cname column is source, derived columns are destinations).</p>
</td></tr>
<tr><td><code id="map_fields_q_+3A_my_db">my_db</code></td>
<td>
<p>database handle.</p>
</td></tr>
<tr><td><code id="map_fields_q_+3A_rname">rname</code></td>
<td>
<p>name of result table.</p>
</td></tr>
<tr><td><code id="map_fields_q_+3A_...">...</code></td>
<td>
<p>force later arguments to be by name.</p>
</td></tr>
<tr><td><code id="map_fields_q_+3A_d_qualifiers">d_qualifiers</code></td>
<td>
<p>optional named ordered vector of strings carrying additional db hierarchy terms, such as schema.</p>
</td></tr>
<tr><td><code id="map_fields_q_+3A_m_qualifiers">m_qualifiers</code></td>
<td>
<p>optional named ordered vector of strings carrying additional db hierarchy terms, such as schema.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>re-mapped table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("DBI", quietly = TRUE) &amp;&amp;
  requireNamespace("RSQLite", quietly = TRUE)) {
  my_db &lt;- DBI::dbConnect(RSQLite::SQLite(),
                          ":memory:")
  DBI::dbWriteTable(
    my_db,
    'd',
    data.frame(what = c("acc", "loss",
                        "val_acc", "val_loss"),
               score = c(0.8, 1.2,
                         0.7, 1.7),
               stringsAsFactors = FALSE),
    overwrite = TRUE,
    temporary = TRUE)
  DBI::dbWriteTable(
    my_db,
    'm',
    data.frame(what = c("acc", "loss",
                        "val_acc", "val_loss"),
               measure = c("accuracy", "log-loss",
                           "accuracy", "log-loss"),
               dataset = c("train", "train", "validation", "validation"),
               stringsAsFactors = FALSE),
    overwrite = TRUE,
    temporary = TRUE)

  map_fields_q('d', 'what', 'm', my_db, "dm")
  cdata::qlook(my_db, 'dm')
  DBI::dbDisconnect(my_db)
}

</code></pre>

<hr>
<h2 id='pivot_to_rowrecs'>Map data records from block records that have one row per measurement value to row records.</h2><span id='topic+pivot_to_rowrecs'></span><span id='topic+layout_to_rowrecs'></span>

<h3>Description</h3>

<p>Map data records from block records (where each record may be more than one row) to
row records (where each record is a single row).  Values specified in rowKeyColumns
determine which sets of rows build up records and are copied into the result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pivot_to_rowrecs(
  data,
  columnToTakeKeysFrom,
  columnToTakeValuesFrom,
  rowKeyColumns,
  ...,
  sep = NULL,
  checkNames = TRUE,
  checkKeys = TRUE,
  strict = FALSE,
  allow_rqdatatable = FALSE
)

layout_to_rowrecs(
  data,
  columnToTakeKeysFrom,
  columnToTakeValuesFrom,
  rowKeyColumns,
  ...,
  sep = NULL,
  checkNames = TRUE,
  checkKeys = TRUE,
  strict = FALSE,
  allow_rqdatatable = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pivot_to_rowrecs_+3A_data">data</code></td>
<td>
<p>data.frame to work with (must be local, for remote please try <code>moveValuesToColumns*</code>).</p>
</td></tr>
<tr><td><code id="pivot_to_rowrecs_+3A_columntotakekeysfrom">columnToTakeKeysFrom</code></td>
<td>
<p>character name of column build new column names from.</p>
</td></tr>
<tr><td><code id="pivot_to_rowrecs_+3A_columntotakevaluesfrom">columnToTakeValuesFrom</code></td>
<td>
<p>character name of column to get values from.</p>
</td></tr>
<tr><td><code id="pivot_to_rowrecs_+3A_rowkeycolumns">rowKeyColumns</code></td>
<td>
<p>character array names columns that should be table keys.</p>
</td></tr>
<tr><td><code id="pivot_to_rowrecs_+3A_...">...</code></td>
<td>
<p>force later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="pivot_to_rowrecs_+3A_sep">sep</code></td>
<td>
<p>character if not null build more detailed column names.</p>
</td></tr>
<tr><td><code id="pivot_to_rowrecs_+3A_checknames">checkNames</code></td>
<td>
<p>logical, if TRUE check names.</p>
</td></tr>
<tr><td><code id="pivot_to_rowrecs_+3A_checkkeys">checkKeys</code></td>
<td>
<p>logical, if TRUE check keyColumns uniquely identify blocks (required).</p>
</td></tr>
<tr><td><code id="pivot_to_rowrecs_+3A_strict">strict</code></td>
<td>
<p>logical, if TRUE check control table name forms</p>
</td></tr>
<tr><td><code id="pivot_to_rowrecs_+3A_allow_rqdatatable">allow_rqdatatable</code></td>
<td>
<p>logical, if TRUE allow rqdatatable shortcutting on simple conversions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>new data.frame with values moved to columns.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+unpivot_to_blocks">unpivot_to_blocks</a></code>, <code><a href="#topic+blocks_to_rowrecs">blocks_to_rowrecs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  d &lt;- data.frame(model_id = c("m1", "m1"), meas = c('AUC', 'R2'), val= c(0.6, 0.2))
  pivot_to_rowrecs(d,
                   columnToTakeKeysFrom= 'meas',
                   columnToTakeValuesFrom= 'val',
                   rowKeyColumns= "model_id") %.&gt;%
     print(.)

</code></pre>

<hr>
<h2 id='qlook'>Quick look at remote data</h2><span id='topic+qlook'></span>

<h3>Description</h3>

<p>Quick look at remote data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qlook(
  my_db,
  tableName,
  ...,
  displayRows = 10,
  countRows = TRUE,
  qualifiers = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qlook_+3A_my_db">my_db</code></td>
<td>
<p>database handle</p>
</td></tr>
<tr><td><code id="qlook_+3A_tablename">tableName</code></td>
<td>
<p>name of table to look at</p>
</td></tr>
<tr><td><code id="qlook_+3A_...">...</code></td>
<td>
<p>force later arguments to be by name.</p>
</td></tr>
<tr><td><code id="qlook_+3A_displayrows">displayRows</code></td>
<td>
<p>number of rows to sample</p>
</td></tr>
<tr><td><code id="qlook_+3A_countrows">countRows</code></td>
<td>
<p>logical, if TRUE return row count.</p>
</td></tr>
<tr><td><code id="qlook_+3A_qualifiers">qualifiers</code></td>
<td>
<p>optional named ordered vector of strings carrying additional db hierarchy terms, such as schema.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>str view of data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if ( requireNamespace("DBI", quietly = TRUE) &amp;&amp;
  requireNamespace("RSQLite", quietly = TRUE)) {
  my_db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
  rquery::rq_copy_to(my_db,
                    'd',
                    data.frame(AUC = 0.6, R2 = 0.2),
                    overwrite = TRUE,
                    temporary = TRUE)
  qlook(my_db, 'd')
  DBI::dbDisconnect(my_db)
}

</code></pre>

<hr>
<h2 id='rowrecs_to_blocks'>Map a data records from row records to block records.</h2><span id='topic+rowrecs_to_blocks'></span><span id='topic+rowrecs_to_blocks.default'></span><span id='topic+rowrecs_to_blocks.relop'></span>

<h3>Description</h3>

<p>Map a data records from row records (records that are exactly single rows) to block records
(records that may be more than one row).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowrecs_to_blocks(
  wideTable,
  controlTable,
  ...,
  checkNames = TRUE,
  checkKeys = FALSE,
  strict = FALSE,
  controlTableKeys = colnames(controlTable)[[1]],
  columnsToCopy = NULL,
  tmp_name_source = wrapr::mk_tmp_name_source("rrtbl"),
  temporary = TRUE,
  allow_rqdatatable = FALSE
)

## Default S3 method:
rowrecs_to_blocks(
  wideTable,
  controlTable,
  ...,
  checkNames = TRUE,
  checkKeys = FALSE,
  strict = FALSE,
  controlTableKeys = colnames(controlTable)[[1]],
  columnsToCopy = NULL,
  tmp_name_source = wrapr::mk_tmp_name_source("rrtobd"),
  temporary = TRUE,
  allow_rqdatatable = FALSE
)

## S3 method for class 'relop'
rowrecs_to_blocks(
  wideTable,
  controlTable,
  ...,
  checkNames = TRUE,
  checkKeys = FALSE,
  strict = FALSE,
  controlTableKeys = colnames(controlTable)[[1]],
  columnsToCopy = NULL,
  tmp_name_source = wrapr::mk_tmp_name_source("rrtbl"),
  temporary = TRUE,
  allow_rqdatatable = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rowrecs_to_blocks_+3A_widetable">wideTable</code></td>
<td>
<p>data.frame containing data to be mapped (in-memory data.frame).</p>
</td></tr>
<tr><td><code id="rowrecs_to_blocks_+3A_controltable">controlTable</code></td>
<td>
<p>table specifying mapping (local data frame).</p>
</td></tr>
<tr><td><code id="rowrecs_to_blocks_+3A_...">...</code></td>
<td>
<p>force later arguments to be by name.</p>
</td></tr>
<tr><td><code id="rowrecs_to_blocks_+3A_checknames">checkNames</code></td>
<td>
<p>logical, if TRUE check names.</p>
</td></tr>
<tr><td><code id="rowrecs_to_blocks_+3A_checkkeys">checkKeys</code></td>
<td>
<p>logical, if TRUE check columnsToCopy form row keys (not a requirement, unless you want to be able to invert the operation).</p>
</td></tr>
<tr><td><code id="rowrecs_to_blocks_+3A_strict">strict</code></td>
<td>
<p>logical, if TRUE check control table name forms.</p>
</td></tr>
<tr><td><code id="rowrecs_to_blocks_+3A_controltablekeys">controlTableKeys</code></td>
<td>
<p>character, which column names of the control table are considered to be keys.</p>
</td></tr>
<tr><td><code id="rowrecs_to_blocks_+3A_columnstocopy">columnsToCopy</code></td>
<td>
<p>character array of column names to copy.</p>
</td></tr>
<tr><td><code id="rowrecs_to_blocks_+3A_tmp_name_source">tmp_name_source</code></td>
<td>
<p>a tempNameGenerator from cdata::mk_tmp_name_source()</p>
</td></tr>
<tr><td><code id="rowrecs_to_blocks_+3A_temporary">temporary</code></td>
<td>
<p>logical, if TRUE use temporary tables</p>
</td></tr>
<tr><td><code id="rowrecs_to_blocks_+3A_allow_rqdatatable">allow_rqdatatable</code></td>
<td>
<p>logical, if TRUE allow rqdatatable shortcutting on simple conversions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The controlTable defines the names of each data element in the two notations:
the notation of the tall table (which is row oriented)
and the notation of the wide table (which is column oriented).
controlTable[ , 1] (the group label) cross colnames(controlTable)
(the column labels) are names of data cells in the long form.
controlTable[ , 2:ncol(controlTable)] (column labels)
are names of data cells in the wide form.
To get behavior similar to tidyr::gather/spread one builds the control table
by running an appropriate query over the data.
</p>
<p>Some discussion and examples can be found here:
<a href="https://winvector.github.io/FluidData/FluidData.html">https://winvector.github.io/FluidData/FluidData.html</a> and
here <a href="https://github.com/WinVector/cdata">https://github.com/WinVector/cdata</a>.
</p>
<p><code>rowrecs_to_blocks.default</code> will change some factor columns to character, and there
are issues with time columns with different time zones.
</p>


<h3>Value</h3>

<p>long table built by mapping wideTable to one row per group
</p>


<h3>See Also</h3>

<p><code><a href="#topic+build_unpivot_control">build_unpivot_control</a></code>, <code><a href="#topic+blocks_to_rowrecs">blocks_to_rowrecs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # un-pivot example
  d &lt;- data.frame(AUC = 0.6, R2 = 0.2)
  cT &lt;- build_unpivot_control(nameForNewKeyColumn= 'meas',
                              nameForNewValueColumn= 'val',
                              columnsToTakeFrom= c('AUC', 'R2'))
  rowrecs_to_blocks(d, cT)



d &lt;- data.frame(AUC = 0.6, R2 = 0.2)
cT &lt;- build_unpivot_control(
  nameForNewKeyColumn= 'meas',
  nameForNewValueColumn= 'val',
  columnsToTakeFrom= c('AUC', 'R2'))

ops &lt;- rquery::local_td(d) %.&gt;%
  rowrecs_to_blocks(., cT)
cat(format(ops))

if(requireNamespace("rqdatatable", quietly = TRUE)) {
  library("rqdatatable")
  d %.&gt;%
    ops %.&gt;%
    print(.)
}

if(requireNamespace("RSQLite", quietly = TRUE)) {
  db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
  DBI::dbWriteTable(db,
                    'd',
                    d,
                    overwrite = TRUE,
                    temporary = TRUE)
  db %.&gt;%
    ops %.&gt;%
    print(.)
  DBI::dbDisconnect(db)
}

</code></pre>

<hr>
<h2 id='rowrecs_to_blocks_q'>Map a set of columns to rows (query based, take name of table).</h2><span id='topic+rowrecs_to_blocks_q'></span>

<h3>Description</h3>

<p>Transform data facts from columns into additional rows using SQL
and controlTable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowrecs_to_blocks_q(
  wideTable,
  controlTable,
  my_db,
  ...,
  columnsToCopy = NULL,
  tempNameGenerator = mk_tmp_name_source("mvtrq"),
  strict = FALSE,
  controlTableKeys = colnames(controlTable)[[1]],
  checkNames = TRUE,
  checkKeys = FALSE,
  showQuery = FALSE,
  defaultValue = NULL,
  temporary = FALSE,
  resultName = NULL,
  incoming_qualifiers = NULL,
  outgoing_qualifiers = NULL,
  temp_qualifiers = NULL,
  executeQuery = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rowrecs_to_blocks_q_+3A_widetable">wideTable</code></td>
<td>
<p>name of table containing data to be mapped (db/Spark data)</p>
</td></tr>
<tr><td><code id="rowrecs_to_blocks_q_+3A_controltable">controlTable</code></td>
<td>
<p>table specifying mapping (local data frame)</p>
</td></tr>
<tr><td><code id="rowrecs_to_blocks_q_+3A_my_db">my_db</code></td>
<td>
<p>db handle</p>
</td></tr>
<tr><td><code id="rowrecs_to_blocks_q_+3A_...">...</code></td>
<td>
<p>force later arguments to be by name.</p>
</td></tr>
<tr><td><code id="rowrecs_to_blocks_q_+3A_columnstocopy">columnsToCopy</code></td>
<td>
<p>character array of column names to copy</p>
</td></tr>
<tr><td><code id="rowrecs_to_blocks_q_+3A_tempnamegenerator">tempNameGenerator</code></td>
<td>
<p>a tempNameGenerator from cdata::mk_tmp_name_source()</p>
</td></tr>
<tr><td><code id="rowrecs_to_blocks_q_+3A_strict">strict</code></td>
<td>
<p>logical, if TRUE check control table name forms</p>
</td></tr>
<tr><td><code id="rowrecs_to_blocks_q_+3A_controltablekeys">controlTableKeys</code></td>
<td>
<p>character, which column names of the control table are considered to be keys.</p>
</td></tr>
<tr><td><code id="rowrecs_to_blocks_q_+3A_checknames">checkNames</code></td>
<td>
<p>logical, if TRUE check names</p>
</td></tr>
<tr><td><code id="rowrecs_to_blocks_q_+3A_checkkeys">checkKeys</code></td>
<td>
<p>logical, if TRUE check wideTable keys</p>
</td></tr>
<tr><td><code id="rowrecs_to_blocks_q_+3A_showquery">showQuery</code></td>
<td>
<p>if TRUE print query</p>
</td></tr>
<tr><td><code id="rowrecs_to_blocks_q_+3A_defaultvalue">defaultValue</code></td>
<td>
<p>if not NULL literal to use for non-match values.</p>
</td></tr>
<tr><td><code id="rowrecs_to_blocks_q_+3A_temporary">temporary</code></td>
<td>
<p>logical, if TRUE make result temporary.</p>
</td></tr>
<tr><td><code id="rowrecs_to_blocks_q_+3A_resultname">resultName</code></td>
<td>
<p>character, name for result table.</p>
</td></tr>
<tr><td><code id="rowrecs_to_blocks_q_+3A_incoming_qualifiers">incoming_qualifiers</code></td>
<td>
<p>optional named ordered vector of strings carrying additional db hierarchy terms, such as schema.</p>
</td></tr>
<tr><td><code id="rowrecs_to_blocks_q_+3A_outgoing_qualifiers">outgoing_qualifiers</code></td>
<td>
<p>optional named ordered vector of strings carrying additional db hierarchy terms, such as schema.</p>
</td></tr>
<tr><td><code id="rowrecs_to_blocks_q_+3A_temp_qualifiers">temp_qualifiers</code></td>
<td>
<p>optional named ordered vector of strings carrying additional db hierarchy terms, such as schema.</p>
</td></tr>
<tr><td><code id="rowrecs_to_blocks_q_+3A_executequery">executeQuery</code></td>
<td>
<p>logical, if TRUE execute the query and return result.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is using the theory of &quot;fluid data&quot;n
(<a href="https://github.com/WinVector/cdata">https://github.com/WinVector/cdata</a>), which includes the
principle that each data cell has coordinates independent of the
storage details and storage detail dependent coordinates (usually
row-id, column-id, and group-id) can be re-derived at will (the
other principle is that there may not be &quot;one true preferred data
shape&quot; and many re-shapings of data may be needed to match data to
different algorithms and methods).
</p>
<p>The controlTable defines the names of each data element in the two notations:
the notation of the tall table (which is row oriented)
and the notation of the wide table (which is column oriented).
controlTable[ , 1] (the group label) cross colnames(controlTable)
(the column labels) are names of data cells in the long form.
controlTable[ , 2:ncol(controlTable)] (column labels)
are names of data cells in the wide form.
To get behavior similar to tidyr::gather/spread one builds the control table
by running an appropriate query over the data.
</p>
<p>Some discussion and examples can be found here:
<a href="https://winvector.github.io/FluidData/FluidData.html">https://winvector.github.io/FluidData/FluidData.html</a> and
here <a href="https://github.com/WinVector/cdata">https://github.com/WinVector/cdata</a>.
</p>


<h3>Value</h3>

<p>long table built by mapping wideTable to one row per group (or query if executeQuery is FALSE)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+build_unpivot_control">build_unpivot_control</a></code>,  <code><a href="#topic+rowrecs_to_blocks">rowrecs_to_blocks</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("DBI", quietly = TRUE) &amp;&amp;
  requireNamespace("RSQLite", quietly = TRUE)) {
  my_db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")

  # un-pivot example
  d &lt;- data.frame(AUC = 0.6, R2 = 0.2)
  rquery::rq_copy_to(my_db,
                    'd',
                    d,
                    overwrite = TRUE,
                    temporary = TRUE)
  cT &lt;- build_unpivot_control(nameForNewKeyColumn= 'meas',
                              nameForNewValueColumn= 'val',
                              columnsToTakeFrom= c('AUC', 'R2'))
  tab &lt;- rowrecs_to_blocks_q('d', cT, my_db = my_db)
  qlook(my_db, tab)
  DBI::dbDisconnect(my_db)
}

</code></pre>

<hr>
<h2 id='rowrecs_to_blocks_spec'>Create a row records to block records transform specification.</h2><span id='topic+rowrecs_to_blocks_spec'></span>

<h3>Description</h3>

<p>Create a row records to block records transform specification object that holds the pivot control table, specification of
extra row keys, and control table keys.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowrecs_to_blocks_spec(
  controlTable,
  ...,
  recordKeys = character(0),
  controlTableKeys = colnames(controlTable)[[1]],
  checkNames = TRUE,
  checkKeys = FALSE,
  strict = FALSE,
  allow_rqdatatable = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rowrecs_to_blocks_spec_+3A_controltable">controlTable</code></td>
<td>
<p>an all character data frame or cdata pivot control.</p>
</td></tr>
<tr><td><code id="rowrecs_to_blocks_spec_+3A_...">...</code></td>
<td>
<p>not used, force later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="rowrecs_to_blocks_spec_+3A_recordkeys">recordKeys</code></td>
<td>
<p>vector of columns identifying records.</p>
</td></tr>
<tr><td><code id="rowrecs_to_blocks_spec_+3A_controltablekeys">controlTableKeys</code></td>
<td>
<p>vector of keying columns of the controlTable.</p>
</td></tr>
<tr><td><code id="rowrecs_to_blocks_spec_+3A_checknames">checkNames</code></td>
<td>
<p>passed to rowrecs_to_blocks.</p>
</td></tr>
<tr><td><code id="rowrecs_to_blocks_spec_+3A_checkkeys">checkKeys</code></td>
<td>
<p>passed to rowrecs_to_blocks.</p>
</td></tr>
<tr><td><code id="rowrecs_to_blocks_spec_+3A_strict">strict</code></td>
<td>
<p>passed to rowrecs_to_blocks.</p>
</td></tr>
<tr><td><code id="rowrecs_to_blocks_spec_+3A_allow_rqdatatable">allow_rqdatatable</code></td>
<td>
<p>logical, if TRUE allow rqdatatable shortcutting on simple conversions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a record specification object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
d &lt;- wrapr::build_frame(
  "id"  , "AUC", "R2" |
    1   , 0.7  , 0.4  |
    2   , 0.8  , 0.5  )

transform &lt;- rowrecs_to_blocks_spec(
  wrapr::qchar_frame(
    "measure", "value" |
    "AUC"    , AUC     |
    "R2"     , R2      ),
  recordKeys = "id")

print(transform)

d %.&gt;% transform

inv_transform &lt;- t(transform)
print(inv_transform)

# identity (in structure)
d %.&gt;% transform %.&gt;% inv_transform

# identity again (using .() "immediate" notation)
d %.&gt;% transform %.&gt;% .(t(transform))

</code></pre>

<hr>
<h2 id='rows_are_uniquely_keyed'>Check if table rows are uniquely keyed by keyset.</h2><span id='topic+rows_are_uniquely_keyed'></span>

<h3>Description</h3>

<p>Return TRUE if table rows are uniquely keyed by key_columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rows_are_uniquely_keyed(table_rep, key_columns, db)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rows_are_uniquely_keyed_+3A_table_rep">table_rep</code></td>
<td>
<p>rquery op_tree</p>
</td></tr>
<tr><td><code id="rows_are_uniquely_keyed_+3A_key_columns">key_columns</code></td>
<td>
<p>character vector names of key columns</p>
</td></tr>
<tr><td><code id="rows_are_uniquely_keyed_+3A_db">db</code></td>
<td>
<p>database handle</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if table rows are uniquely keyed by key columns
</p>

<hr>
<h2 id='unpivot_to_blocks'>Map a data records from row records to block records with one record row per columnsToTakeFrom value.</h2><span id='topic+unpivot_to_blocks'></span><span id='topic+layout_to_blocks'></span><span id='topic+pivot_to_blocks'></span><span id='topic+unpivot_to_blocks.default'></span><span id='topic+unpivot_to_blocks.relop'></span>

<h3>Description</h3>

<p>Map a data records from row records (records that are exactly single rows) to block records
(records that may be more than one row).  All columns not named in columnsToTakeFrom are copied to each
record row in the result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unpivot_to_blocks(
  data,
  nameForNewKeyColumn,
  nameForNewValueColumn,
  columnsToTakeFrom,
  ...,
  nameForNewClassColumn = NULL,
  checkNames = TRUE,
  checkKeys = FALSE,
  strict = FALSE,
  tmp_name_source = wrapr::mk_tmp_name_source("upb"),
  temporary = TRUE,
  allow_rqdatatable = FALSE
)

layout_to_blocks(
  data,
  nameForNewKeyColumn,
  nameForNewValueColumn,
  columnsToTakeFrom,
  ...,
  nameForNewClassColumn = NULL,
  checkNames = TRUE,
  checkKeys = FALSE,
  strict = FALSE,
  tmp_name_source = wrapr::mk_tmp_name_source("upb"),
  temporary = TRUE,
  allow_rqdatatable = FALSE
)

pivot_to_blocks(
  data,
  nameForNewKeyColumn,
  nameForNewValueColumn,
  columnsToTakeFrom,
  ...,
  nameForNewClassColumn = NULL,
  checkNames = TRUE,
  checkKeys = FALSE,
  strict = FALSE,
  tmp_name_source = wrapr::mk_tmp_name_source("upb"),
  temporary = TRUE,
  allow_rqdatatable = FALSE
)

## Default S3 method:
unpivot_to_blocks(
  data,
  nameForNewKeyColumn,
  nameForNewValueColumn,
  columnsToTakeFrom,
  ...,
  nameForNewClassColumn = NULL,
  checkNames = TRUE,
  checkKeys = FALSE,
  strict = FALSE,
  allow_rqdatatable = FALSE
)

## S3 method for class 'relop'
unpivot_to_blocks(
  data,
  nameForNewKeyColumn,
  nameForNewValueColumn,
  columnsToTakeFrom,
  ...,
  checkNames = TRUE,
  checkKeys = FALSE,
  strict = FALSE,
  nameForNewClassColumn = NULL,
  tmp_name_source = wrapr::mk_tmp_name_source("upb"),
  temporary = TRUE,
  allow_rqdatatable = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unpivot_to_blocks_+3A_data">data</code></td>
<td>
<p>data.frame to work with.</p>
</td></tr>
<tr><td><code id="unpivot_to_blocks_+3A_namefornewkeycolumn">nameForNewKeyColumn</code></td>
<td>
<p>character name of column to write new keys in.</p>
</td></tr>
<tr><td><code id="unpivot_to_blocks_+3A_namefornewvaluecolumn">nameForNewValueColumn</code></td>
<td>
<p>character name of column to write new values in.</p>
</td></tr>
<tr><td><code id="unpivot_to_blocks_+3A_columnstotakefrom">columnsToTakeFrom</code></td>
<td>
<p>character array names of columns to take values from.</p>
</td></tr>
<tr><td><code id="unpivot_to_blocks_+3A_...">...</code></td>
<td>
<p>force later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="unpivot_to_blocks_+3A_namefornewclasscolumn">nameForNewClassColumn</code></td>
<td>
<p>optional name to land original cell classes to.</p>
</td></tr>
<tr><td><code id="unpivot_to_blocks_+3A_checknames">checkNames</code></td>
<td>
<p>logical, if TRUE check names.</p>
</td></tr>
<tr><td><code id="unpivot_to_blocks_+3A_checkkeys">checkKeys</code></td>
<td>
<p>logical, if TRUE check columnsToCopy form row keys (not a requirement, unless you want to be able to invert the operation).</p>
</td></tr>
<tr><td><code id="unpivot_to_blocks_+3A_strict">strict</code></td>
<td>
<p>logical, if TRUE check control table name forms.</p>
</td></tr>
<tr><td><code id="unpivot_to_blocks_+3A_tmp_name_source">tmp_name_source</code></td>
<td>
<p>a tempNameGenerator from cdata::mk_tmp_name_source()</p>
</td></tr>
<tr><td><code id="unpivot_to_blocks_+3A_temporary">temporary</code></td>
<td>
<p>logical, if TRUE make result temporary.</p>
</td></tr>
<tr><td><code id="unpivot_to_blocks_+3A_allow_rqdatatable">allow_rqdatatable</code></td>
<td>
<p>logical, if TRUE allow rqdatatable shortcutting on simple conversions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>new data.frame with values moved to rows.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pivot_to_rowrecs">pivot_to_rowrecs</a></code>, <code><a href="#topic+rowrecs_to_blocks">rowrecs_to_blocks</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  d &lt;- data.frame(model_name = "m1", AUC = 0.6, R2 = 0.2)
  unpivot_to_blocks(d,
                    nameForNewKeyColumn= 'meas',
                    nameForNewValueColumn= 'val',
                    columnsToTakeFrom= c('AUC', 'R2')) %.&gt;%
     print(.)


d &lt;- data.frame(AUC= 0.6, R2= 0.2)
ops &lt;- rquery::local_td(d) %.&gt;%
  unpivot_to_blocks(
    .,
    nameForNewKeyColumn= 'meas',
    nameForNewValueColumn= 'val',
    columnsToTakeFrom= c('AUC', 'R2'))
cat(format(ops))

if(requireNamespace("rqdatatable", quietly = TRUE)) {
  library("rqdatatable")
  d %.&gt;%
    ops %.&gt;%
    print(.)
}

if(requireNamespace("RSQLite", quietly = TRUE)) {
  db &lt;- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
  DBI::dbWriteTable(db,
                    'd',
                    d,
                    overwrite = TRUE,
                    temporary = TRUE)
  db %.&gt;%
    ops %.&gt;%
    print(.)
  DBI::dbDisconnect(db)
}

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
