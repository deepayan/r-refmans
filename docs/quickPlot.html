<!DOCTYPE html><html lang="en-CA"><head><title>Help for package quickPlot</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {quickPlot}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#quickPlot-package'><p>The <code>quickPlot</code> package</p></a></li>
<li><a href='#.arrangement-class'><p>The <code>.arrangement</code> class</p></a></li>
<li><a href='#.arrangeViewports'><p>Determine optimal plotting arrangement of plot objects</p></a></li>
<li><a href='#.assignQuickPlot'><p>Assign to the internal <code>quickPlot</code> environment.</p></a></li>
<li><a href='#.existsQuickPlot'><p>Is an object defined in the <code>.quickPlotEnv</code> environment?</p></a></li>
<li><a href='#.getQuickPlot'><p>Get objects from the internal <code>quickPlot</code> environment</p></a></li>
<li><a href='#.hasBbox'><p>Test whether class has <code>bbox</code> method</p></a></li>
<li><a href='#.identifyGrobToPlot'><p>Identify where to get the grob from</p></a></li>
<li><a href='#.makeColorMatrix'><p>Convert Raster to colour matrix usable by raster function for plotting</p></a></li>
<li><a href='#.makeLayout'><p>Make an optimal layout of plots</p></a></li>
<li><a href='#.makeList'><p>Convert <code>plotArgs</code> to list of lists</p></a></li>
<li><a href='#.makeQuickPlot'><p>Make a <code>.quickPlot</code> class object</p></a></li>
<li><a href='#.makeViewports'><p>Make viewports</p></a></li>
<li><a href='#.objectNames'><p>Extracts the object names</p></a></li>
<li><a href='#.parOrig'><p>Default plotting parameters</p></a></li>
<li><a href='#.parseArgs'><p>Parse arguments and find environments</p></a></li>
<li><a href='#.parseElems'><p>Parsing of elements</p></a></li>
<li><a href='#.plotGrob'><p>Plot spatial grobs (using <span class="pkg">grid</span> package)</p></a></li>
<li><a href='#.preparePlotGrob'><p>Internal functions used by <code>Plot</code></p></a></li>
<li><a href='#.prepareRaster'><p>Prepare raster for plotting</p></a></li>
<li><a href='#.quickPlot-class'><p>The <code>.quickPlot</code> class</p></a></li>
<li><a href='#.quickPlotEnv'><p>The quickPlot environment</p></a></li>
<li><a href='#.quickPlotGrob-class'><p>The <code>.quickPlotGrob</code> class</p></a></li>
<li><a href='#.unittrim'><p>Convert <code>grid.locator</code> units</p></a></li>
<li><a href='#.updateQuickPlot'><p>Merge two quickPlot objects</p></a></li>
<li><a href='#clearPlot'><p>Clear plotting device</p></a></li>
<li><a href='#clickValues'><p>Mouse interactions with Plots</p></a></li>
<li><a href='#coordinates'><p>Extract coordinates from a variety of spatial objects</p></a></li>
<li><a href='#dev'><p>Specify where to plot</p></a></li>
<li><a href='#divergentColors'><p>Divergent colour palette</p></a></li>
<li><a href='#equalExtent'><p>Assess whether a list of extents are all equal</p></a></li>
<li><a href='#extent'><p>Get extent of a variety of spatial objects</p></a></li>
<li><a href='#fortify'><p>Fortify</p></a></li>
<li><a href='#getColors'><p>Get and set colours for plotting <code style="white-space: pre;">&#8288;Raster*&#8288;</code> objects</p></a></li>
<li><a href='#gpar'><p>Importing some grid functions</p></a></li>
<li><a href='#isRstudioServer'><p>Determine if current session is RStudio Server</p></a></li>
<li><a href='#layerNames'><p>Extract the layer names of Spatial Objects</p></a></li>
<li><a href='#makeLines'><p>Make <code>SpatialLines</code> object from two <code>SpatialPoints</code> objects</p></a></li>
<li><a href='#newPlot'><p>Open a new plotting window</p></a></li>
<li><a href='#numLayers'><p>Find the number of layers in an object</p></a></li>
<li><a href='#Plot'><p><code>Plot</code>: Fast, optimally arranged, multi-panel plotting</p></a></li>
<li><a href='#quickPlotClasses'><p><code>quickPlot</code> classes</p></a></li>
<li><a href='#sample-maps'><p>Dummy maps included with <code>quickPlot</code></p></a></li>
<li><a href='#sp2sl'><p>Convert pairs of coordinates to <code>SpatialLines</code></p></a></li>
<li><a href='#thin'><p>Thin a polygon using <code>fastshp::thin</code></p></a></li>
<li><a href='#whereInStack'><p>Find the environment in the call stack that contains an object by name</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A System of Plotting Optimized for Speed and Modularity</td>
</tr>
<tr>
<td>Description:</td>
<td>A high-level plotting system, compatible with &lsquo;ggplot2' objects, 
    maps from 'sf', 'terra', 'raster', 'sp'. It is built primarily on the 
    &rsquo;grid' package. The objective of the package is to provide a plotting system 
    that is built for speed and modularity. This is useful for quick visualizations 
    when testing code and for plotting multiple figures to the same device from 
    independent sources that may be independent of one another (i.e., different 
    function or modules the create the visualizations).  The suggested package 
    'fastshp' can be installed from the repository 
    (<a href="https://PredictiveEcology.r-universe.dev">https://PredictiveEcology.r-universe.dev</a>).</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://quickplot.predictiveecology.org">https://quickplot.predictiveecology.org</a>,
<a href="https://github.com/PredictiveEcology/quickPlot">https://github.com/PredictiveEcology/quickPlot</a></td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-07-01</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table (&ge; 1.10.4), fpCompare, grDevices, grid, methods,
stats, terra, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, fastshp, ggplot2, knitr, raster, RColorBrewer,
rmarkdown, sf, sp, testthat (&ge; 1.0.2), withr</td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://predictiveecology.r-universe.dev/">https://predictiveecology.r-universe.dev/</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-CA</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/PredictiveEcology/quickPlot/issues">https://github.com/PredictiveEcology/quickPlot/issues</a></td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Collate:</td>
<td>'environment.R' 'plotting-classes.R' 'plotting-colours.R'
'plotting-helpers.R' 'plotting-other.R' 'plotting.R'
'quickPlot-classes.R' 'quickPlot-package.R' 'testing-helpers.R'
'zzz.R'</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-07-01 22:42:50 UTC; emcintir</td>
</tr>
<tr>
<td>Author:</td>
<td>Eliot J B McIntire
    <a href="https://orcid.org/0000-0002-6914-8316"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Alex M Chubaty <a href="https://orcid.org/0000-0001-7146-8135"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  His Majesty the King in Right of Canada, as represented by the Minister
    of Natural Resources Canada [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Eliot J B McIntire &lt;eliot.mcintire@canada.ca&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-07-02 05:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='quickPlot-package'>The <code>quickPlot</code> package</h2><span id='topic+quickPlot'></span><span id='topic+quickPlot-package'></span>

<h3>Description</h3>

<p>A high-level plotting system, built using 'grid' graphics, that is optimized
for speed and modularity. This has great utility for quick visualizations
when testing code, with the key benefit that visualizations are updated
independently of one another.
</p>


<h3>Note</h3>

<p>The suggested package <span class="pkg">fastshp</span> can be installed with
<code>install.packages("fastshp", repos = "https://rforge.net", type = "source")</code>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Eliot J B McIntire <a href="mailto:eliot.mcintire@canada.ca">eliot.mcintire@canada.ca</a> (<a href="https://orcid.org/0000-0002-6914-8316">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Alex M Chubaty <a href="mailto:achubaty@for-cast.ca">achubaty@for-cast.ca</a> (<a href="https://orcid.org/0000-0001-7146-8135">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> His Majesty the King in Right of Canada, as represented by the Minister of Natural Resources Canada [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://quickplot.predictiveecology.org">https://quickplot.predictiveecology.org</a>
</p>
</li>
<li> <p><a href="https://github.com/PredictiveEcology/quickPlot">https://github.com/PredictiveEcology/quickPlot</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/PredictiveEcology/quickPlot/issues">https://github.com/PredictiveEcology/quickPlot/issues</a>
</p>
</li></ul>


<hr>
<h2 id='.arrangement-class'>The <code>.arrangement</code> class</h2><span id='topic+.arrangement-class'></span><span id='topic+.arrangement'></span>

<h3>Description</h3>

<p>This class contains the plotting arrangement information.
</p>


<h3>Details</h3>

<p>These <code style="white-space: pre;">&#8288;gp*&#8288;</code> parameters will specify plot parameters that are
available with <code>gpar()</code>. <code>gp</code> will adjust plot parameters,
<code>gpText</code> will adjust title and legend text, <code>gpAxis</code> will
adjust the axes. <code>size</code> adjusts point size in a <code>SpatialPoints</code> object.
These will persist with the original <code>Plot</code> call for each individual object.
Multiple entries can be used, but they must be named list elements
and they must match the <code>...</code> items to plot.
This is true for a <code>RasterStack</code> also, i.e., the list of named elements
must be the same length as the number of layers being plotted.
The naming convention used is: <code>RasterStackName$layerName</code>, i.e, <code>landscape$DEM</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>rows</code></dt><dd><p>numeric. Number of rows in the arrangement.</p>
</dd>
<dt><code>columns</code></dt><dd><p>numeric. Number of columns in the arrangement.</p>
</dd>
<dt><code>actual.ratio</code></dt><dd><p>numeric. Ratio of columns to rows</p>
</dd>
<dt><code>ds.dimensionRatio</code></dt><dd><p>numeric. Ratio of the device size to the ratio of the extents.</p>
</dd>
<dt><code>ds</code></dt><dd><p>numeric of length 2. The dimensions of the plotting window in inches.</p>
</dd>
<dt><code>objects</code></dt><dd><p>list of length number of spatial objects. Each list has a character vector
of the layer names in each of those.</p>
</dd>
<dt><code>isRaster</code></dt><dd><p>logical vector, indicating whether each object is a <code style="white-space: pre;">&#8288;Raster*&#8288;</code> object.</p>
</dd>
<dt><code>names</code></dt><dd><p>character vector, indicating the names of the layers in the plot.</p>
</dd>
<dt><code>extents</code></dt><dd><p>list of class <code>Extent</code> objects. These are needed to calculate the
<code>ds.dimensionRatio</code>, which is used to scale the <code style="white-space: pre;">&#8288;Spatial*&#8288;</code> objects correctly.</p>
</dd>
<dt><code>isSpatialObjects</code></dt><dd><p>logical indicating whether the object(s) are <code>spatialObjects</code> or not.</p>
</dd>
<dt><code>layout</code></dt><dd><p>list of length 2, with width and height measurements for layout.</p>
</dd>
<dt><code>gp</code></dt><dd><p>a <code>gpar</code> object or list of named <code>gpar</code> objects. These names must
match the names of the <code>...</code> objects. Default is <code>NULL.</code> See details.</p>
</dd>
<dt><code>gpText</code></dt><dd><p>a <code>gpar</code> object or a list of named <code>gpar</code> objects. These names must
match the names of the <code>...</code> objects. Default is <code>NULL.</code> See details.</p>
</dd>
<dt><code>gpAxis</code></dt><dd><p>a <code>gpar</code> object or a list of named <code>gpar</code> objects. These names must
match the names of the <code>...</code> objects. Default is <code>NULL.</code> See details.</p>
</dd>
<dt><code>size</code></dt><dd><p>a numeric or a named list of numerics, used for <code>SpatialPoints</code> plots.
Default is 5. See details.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Eliot McIntire
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quickPlotClasses">quickPlotClasses()</a></code>
</p>

<hr>
<h2 id='.arrangeViewports'>Determine optimal plotting arrangement of plot objects</h2><span id='topic+.arrangeViewports'></span><span id='topic+.arrangeViewports+2C.quickPlot-method'></span>

<h3>Description</h3>

<p>Internal function. Assesses the device geometry, the map geometry, and the
number of spatial objects to plot and builds an object that will be used by
the Plot functions to plot them efficiently.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.arrangeViewports(sPlot, arr = NULL)

## S4 method for signature '.quickPlot'
.arrangeViewports(sPlot, arr = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".arrangeViewports_+3A_splot">sPlot</code></td>
<td>
<p>A <code>.quickPlot</code> object.</p>
</td></tr>
<tr><td><code id=".arrangeViewports_+3A_arr">arr</code></td>
<td>
<p>A vector of length 2 indicating a desired arrangement of plot
areas indicating number of rows, number of columns.
Default NULL, meaning
let Plot function do it automatically.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eliot McIntire
</p>

<hr>
<h2 id='.assignQuickPlot'>Assign to the internal <code>quickPlot</code> environment.</h2><span id='topic+.assignQuickPlot'></span><span id='topic+.assignQuickPlot+2Ccharacter+2CANY-method'></span><span id='topic+.assignQuickPlot+2Ccharacter+2Cmissing-method'></span>

<h3>Description</h3>

<p>Internal function. Simple wrapper for <code><a href="base.html#topic+assign">assign()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.assignQuickPlot(x, value, ...)

## S4 method for signature 'character,ANY'
.assignQuickPlot(x, value, ...)

## S4 method for signature 'character,missing'
.assignQuickPlot(x, value, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".assignQuickPlot_+3A_x">x</code></td>
<td>
<p>a variable name, given as a character string.
No coercion is done, and the first element of a character vector
of length greater than one will be used, with a warning.</p>
</td></tr>
<tr><td><code id=".assignQuickPlot_+3A_value">value</code></td>
<td>
<p>The object to assign. If this is missing, values will be found
with <code>get(x)</code> in the same environment as the calling
environment.</p>
</td></tr>
<tr><td><code id=".assignQuickPlot_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code>assign</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Only used for its side effect, namely the object assigned to the <code>.quickPlotEnv</code>
</p>


<h3>Author(s)</h3>

<p>Alex Chubaty
</p>

<hr>
<h2 id='.existsQuickPlot'>Is an object defined in the <code>.quickPlotEnv</code> environment?</h2><span id='topic+.existsQuickPlot'></span><span id='topic+.existsQuickPlot+2CANY-method'></span>

<h3>Description</h3>

<p>Internal function. Simple wrapper for <code><a href="base.html#topic+exists">exists()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.existsQuickPlot(x, ...)

## S4 method for signature 'ANY'
.existsQuickPlot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".existsQuickPlot_+3A_x">x</code></td>
<td>
<p>An object name, given as a character string.
No coercion is done, and the first element of a character vector
of length greater than one will be used, with a warning.</p>
</td></tr>
<tr><td><code id=".existsQuickPlot_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="base.html#topic+exists">exists()</a></code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alex Chubaty
</p>

<hr>
<h2 id='.getQuickPlot'>Get objects from the internal <code>quickPlot</code> environment</h2><span id='topic+.getQuickPlot'></span><span id='topic+.getQuickPlot+2CANY-method'></span>

<h3>Description</h3>

<p>Internal function. Simple wrapper for <code><a href="base.html#topic+get">get()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.getQuickPlot(x, ...)

## S4 method for signature 'ANY'
.getQuickPlot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".getQuickPlot_+3A_x">x</code></td>
<td>
<p>an object name (given as a character string).</p>
</td></tr>
<tr><td><code id=".getQuickPlot_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code>get</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alex Chubaty
</p>

<hr>
<h2 id='.hasBbox'>Test whether class has <code>bbox</code> method</h2><span id='topic+.hasBbox'></span>

<h3>Description</h3>

<p>For internal use only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.hasBbox(z, objClass, objName, objEnv)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".hasBbox_+3A_z">z</code></td>
<td>
<p>Logical, whether this object is a <code>SpatialObject</code></p>
</td></tr>
<tr><td><code id=".hasBbox_+3A_objclass">objClass</code></td>
<td>
<p>The class of the object</p>
</td></tr>
<tr><td><code id=".hasBbox_+3A_objname">objName</code></td>
<td>
<p>The character string name of the object</p>
</td></tr>
<tr><td><code id=".hasBbox_+3A_objenv">objEnv</code></td>
<td>
<p>The environment where the object can be found</p>
</td></tr>
</table>

<hr>
<h2 id='.identifyGrobToPlot'>Identify where to get the grob from</h2><span id='topic+.identifyGrobToPlot'></span><span id='topic+.identifyGrobToPlot+2CANY+2C.quickPlotGrob-method'></span>

<h3>Description</h3>

<p>Internal function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.identifyGrobToPlot(toPlot, sGrob, takeFromPlotObj)

## S4 method for signature 'ANY,.quickPlotGrob'
.identifyGrobToPlot(toPlot, sGrob, takeFromPlotObj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".identifyGrobToPlot_+3A_toplot">toPlot</code></td>
<td>
<p>The object to plot. Should be a single layer if from a multi-layer
object such as a <code>RasterStack</code>.</p>
</td></tr>
<tr><td><code id=".identifyGrobToPlot_+3A_sgrob">sGrob</code></td>
<td>
<p><code>quickPlot</code> grob object</p>
</td></tr>
<tr><td><code id=".identifyGrobToPlot_+3A_takefromplotobj">takeFromPlotObj</code></td>
<td>
<p>Logical. Should the data come from the argument passed
into <code>Plot</code> (<code>TRUE</code>), or from the (<code>.quickPlotEnv</code>) (<code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Because the <code>Plot</code> function can use the global environment as a source of
objects to plot, not just the call itself, this function identifies where the
data for the grob should come from, the current call or the global environment.
</p>


<h3>Author(s)</h3>

<p>Eliot McIntire
</p>

<hr>
<h2 id='.makeColorMatrix'>Convert Raster to colour matrix usable by raster function for plotting</h2><span id='topic+.makeColorMatrix'></span><span id='topic+makeColourMatrix'></span>

<h3>Description</h3>

<p>Internal function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.makeColorMatrix(
  grobToPlot,
  zoomExtent,
  maxpixels,
  legendRange,
  cols = NULL,
  prevMinMax,
  na.color = "#FFFFFF00",
  zero.color = NULL,
  skipSample = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".makeColorMatrix_+3A_grobtoplot">grobToPlot</code></td>
<td>
<p>A <code>SpatialObject</code>.</p>
</td></tr>
<tr><td><code id=".makeColorMatrix_+3A_zoomextent">zoomExtent</code></td>
<td>
<p>An <code>Extent</code> object for zooming to.
Defaults to whole extent of <code>grobToPlot</code>.</p>
</td></tr>
<tr><td><code id=".makeColorMatrix_+3A_maxpixels">maxpixels</code></td>
<td>
<p>Numeric. Number of cells to subsample the complete
<code>grobToPlot</code>.</p>
</td></tr>
<tr><td><code id=".makeColorMatrix_+3A_legendrange">legendRange</code></td>
<td>
<p>Numeric vector giving values that, representing the lower
and upper bounds of a legend (i.e., <code>1:10</code> or
<code>c(1,10)</code> will give same result) that will override
the data bounds contained within the <code>grobToPlot</code>.</p>
</td></tr>
<tr><td><code id=".makeColorMatrix_+3A_cols">cols</code></td>
<td>
<p>Colours specified in a way that can be understood directly
or by <code><a href="grDevices.html#topic+colorRampPalette">colorRampPalette()</a></code>.</p>
</td></tr>
<tr><td><code id=".makeColorMatrix_+3A_na.color">na.color</code></td>
<td>
<p>Character string indicating the colour for <code>NA</code> values.
Default transparent.</p>
</td></tr>
<tr><td><code id=".makeColorMatrix_+3A_zero.color">zero.color</code></td>
<td>
<p>Character string indicating the colour for zero values,
when zero is the minimum value.
Otherwise, it is treated as any other colour.
Default transparent.
Use <code>NULL</code> if zero should be the value given to it
by the <code>colortable</code> associated with the raster.</p>
</td></tr>
<tr><td><code id=".makeColorMatrix_+3A_skipsample">skipSample</code></td>
<td>
<p>Logical. If no downsampling is necessary, skip.
Default <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eliot McIntire
</p>

<hr>
<h2 id='.makeLayout'>Make an optimal layout of plots</h2><span id='topic+.makeLayout'></span>

<h3>Description</h3>

<p>Internal function. Using the size of the current device, and number and
dimension ratios of the plots, place them optimally in the plotting region.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.makeLayout(arr, visualSqueeze, legend = TRUE, axes = TRUE, title = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".makeLayout_+3A_arr">arr</code></td>
<td>
<p>an object of class <code>.arrangement</code>.</p>
</td></tr>
<tr><td><code id=".makeLayout_+3A_visualsqueeze">visualSqueeze</code></td>
<td>
<p>Numeric. The proportion of the white space to be used
for plots. Default is 0.75.</p>
</td></tr>
<tr><td><code id=".makeLayout_+3A_legend">legend</code></td>
<td>
<p>Logical indicating whether legend should be included as part of
layout calculation. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id=".makeLayout_+3A_axes">axes</code></td>
<td>
<p>Logical indicating whether the axes should be included as part of
layout calculation. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id=".makeLayout_+3A_title">title</code></td>
<td>
<p>Logical indicating whether the names of each plot should be
written above plots and should be included as part of layout
calculation. Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eliot McIntire
</p>

<hr>
<h2 id='.makeList'>Convert <code>plotArgs</code> to list of lists</h2><span id='topic+.makeList'></span><span id='topic+.makeList+2Clist-method'></span>

<h3>Description</h3>

<p>Internal function. Take the inputs as <code>plotArgs</code> to the Plot function, and make
them a list of length <code>numQuickPlotObjects</code> entries of lists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.makeList(plotArgs, numQuickPlotObjects)

## S4 method for signature 'list'
.makeList(plotArgs, numQuickPlotObjects)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".makeList_+3A_plotargs">plotArgs</code></td>
<td>
<p>list. Any arguments that the the grid package can accept for
the specific grob types, e.g., <code>rasterGrob</code>, <code>polygonGrob</code>, etc.</p>
</td></tr>
<tr><td><code id=".makeList_+3A_numquickplotobjects">numQuickPlotObjects</code></td>
<td>
<p>Numeric. The number of <code>.quickPlotObjects</code>.
This can't easily be deduced from the <code>plotArgs</code> because
of the <code>RasterStack</code>s. So passed manually.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eliot McIntire
</p>

<hr>
<h2 id='.makeQuickPlot'>Make a <code>.quickPlot</code> class object</h2><span id='topic+.makeQuickPlot'></span><span id='topic+.makeQuickPlot+2Clist+2Clist-method'></span><span id='topic+.makeQuickPlot+2Clist+2Cmissing-method'></span><span id='topic+.makeQuickPlot+2Cmissing+2Cmissing-method'></span>

<h3>Description</h3>

<p>Builds a <code>.quickPlot</code> object from a list of objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.makeQuickPlot(plotObjects, plotArgs, whichQuickPlottables, ...)

## S4 method for signature 'list,list'
.makeQuickPlot(plotObjects, plotArgs, whichQuickPlottables, ...)

## S4 method for signature 'list,missing'
.makeQuickPlot(plotObjects, plotArgs, whichQuickPlottables, ...)

## S4 method for signature 'missing,missing'
.makeQuickPlot(plotObjects, plotArgs, whichQuickPlottables, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".makeQuickPlot_+3A_plotobjects">plotObjects</code></td>
<td>
<p>list. Any plot objects.</p>
</td></tr>
<tr><td><code id=".makeQuickPlot_+3A_plotargs">plotArgs</code></td>
<td>
<p>list. Any arguments that the the grid package can accept for
the specific grob types, e.g., <code>rasterGrob</code>, <code>polygonGrob</code>, etc.</p>
</td></tr>
<tr><td><code id=".makeQuickPlot_+3A_whichquickplottables">whichQuickPlottables</code></td>
<td>
<p>Logical indicating which objects in the
<code>Plot</code> call can be plotted by <code>Plot</code>.</p>
</td></tr>
<tr><td><code id=".makeQuickPlot_+3A_...">...</code></td>
<td>
<p>additional arguments. Currently nothing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+.quickPlot">.quickPlot()</a></code> object, which has 2 slots, one for the plot arrangement
(i.e., layout and dimensions) and one for all of the <code>quickPlotGrobs</code>
(stored as a <code>quickPlotGrobList</code> of lists <code>.quickPlotGrob</code> objects).
</p>


<h3>Author(s)</h3>

<p>Eliot McIntire
</p>

<hr>
<h2 id='.makeViewports'>Make viewports</h2><span id='topic+.makeViewports'></span>

<h3>Description</h3>

<p>Given a set of extents, and a layout for these extents, this function will
output a viewport tree to allow plotting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.makeViewports(sPlot, newArr = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".makeViewports_+3A_splot">sPlot</code></td>
<td>
<p>An object of class <code>.quickPlot</code>.</p>
</td></tr>
<tr><td><code id=".makeViewports_+3A_newarr">newArr</code></td>
<td>
<p>Logical indicating whether this function will create a
completely new viewport. Default <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will either create a totally new set of viewports, or simply
add some nested viewports to an existing arrangement, i.e., is there still
white space available to plot.
</p>


<h3>Author(s)</h3>

<p>Eliot McIntire
</p>

<hr>
<h2 id='.objectNames'>Extracts the object names</h2><span id='topic+.objectNames'></span>

<h3>Description</h3>

<p>Internal function primarily used from <code>Plot</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.objectNames(calledFrom = "Plot", argClass = ".quickPlotObjects", argName = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".objectNames_+3A_calledfrom">calledFrom</code></td>
<td>
<p>character vector of length 1, indicating which function
call is desired. Defaults to <code>Plot</code>.</p>
</td></tr>
<tr><td><code id=".objectNames_+3A_argclass">argClass</code></td>
<td>
<p>character vector of length 1, indicating which class is
being searched for among the arguments.
Defaults to <code>.quickPlotObjects</code>.</p>
</td></tr>
<tr><td><code id=".objectNames_+3A_argname">argName</code></td>
<td>
<p>character vector of length 1, or <code>NULL</code>, indicating
if the arguments to select have a name, no name (empty
string), or do not use name (<code>NULL</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>. This function is invoked for its side effects.
</p>


<h3>Author(s)</h3>

<p>Eliot McIntire
</p>

<hr>
<h2 id='.parOrig'>Default plotting parameters</h2><span id='topic+.parOrig'></span>

<h3>Description</h3>

<p>Default plotting parameters
</p>

<hr>
<h2 id='.parseArgs'>Parse arguments and find environments</h2><span id='topic+.parseArgs'></span>

<h3>Description</h3>

<p>Internal function used within <code>objectNames</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.parseArgs(y, e, eminus1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".parseArgs_+3A_y">y</code></td>
<td>
<p>A character representation of the arguments passed to a function, e.g., <code>Plot</code>.</p>
</td></tr>
<tr><td><code id=".parseArgs_+3A_e">e</code></td>
<td>
<p>Environment in which the function (e.g., <code>Plot</code>) was called.</p>
</td></tr>
<tr><td><code id=".parseArgs_+3A_eminus1">eminus1</code></td>
<td>
<p>The parent environment of <code>e</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of length 2, with names <code>objs</code> and <code>envs</code> giving the
standardized representation (i.e., replacing <code style="white-space: pre;">&#8288;[[]]&#8288;</code> with <code>$</code> notation for objects) of objects
and their layers (if <code>RasterStack</code>s).
</p>


<h3>Author(s)</h3>

<p>Eliot McIntire and Alex Chubaty
</p>

<hr>
<h2 id='.parseElems'>Parsing of elements</h2><span id='topic+.parseElems'></span><span id='topic+.parseElems+2CANY-method'></span>

<h3>Description</h3>

<p>This is a generic definition that can be extended according to class. Intended
only for development use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.parseElems(tmp, elems, envir)

## S4 method for signature 'ANY'
.parseElems(tmp, elems, envir)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".parseElems_+3A_tmp">tmp</code></td>
<td>
<p>A evaluated object</p>
</td></tr>
<tr><td><code id=".parseElems_+3A_elems">elems</code></td>
<td>
<p>A character string to be parsed</p>
</td></tr>
<tr><td><code id=".parseElems_+3A_envir">envir</code></td>
<td>
<p>An environment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object, parsed from a character string and and environment
</p>


<h3>Author(s)</h3>

<p>Eliot McIntire
</p>

<hr>
<h2 id='.plotGrob'>Plot spatial grobs (using <span class="pkg">grid</span> package)</h2><span id='topic+.plotGrob'></span>

<h3>Description</h3>

<p>Internal function. Plot a raster Grob, a points Grob, polygon Grob.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.plotGrob(
  grobToPlot,
  col = NULL,
  real = FALSE,
  size = unit(5, "points"),
  minv,
  maxv,
  legend = TRUE,
  legendText = NULL,
  length = NULL,
  gp = gpar(),
  gpText = gpar(),
  pch = 19,
  speedup = 1,
  name = character(),
  vp = list(),
  ...,
  verbose = getOption("quickPlot.verbose")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".plotGrob_+3A_grobtoplot">grobToPlot</code></td>
<td>
<p><code style="white-space: pre;">&#8288;Raster*&#8288;</code>, <code style="white-space: pre;">&#8288;SpatialLines*&#8288;</code>,
<code style="white-space: pre;">&#8288;SpatialPoints*&#8288;</code>, or <code style="white-space: pre;">&#8288;SpatialPolygons*&#8288;</code> object.</p>
</td></tr>
<tr><td><code id=".plotGrob_+3A_col">col</code></td>
<td>
<p>Currently only used for the legend of a <code style="white-space: pre;">&#8288;Raster*&#8288;</code> object.</p>
</td></tr>
<tr><td><code id=".plotGrob_+3A_real">real</code></td>
<td>
<p>Logical indicating whether the data are <code>real</code> numbers
(i.e., as opposed to <code>integer</code> or <code>factor</code>).</p>
</td></tr>
<tr><td><code id=".plotGrob_+3A_size">size</code></td>
<td>
<p>The size of the <code>SpatialPoints</code>.</p>
</td></tr>
<tr><td><code id=".plotGrob_+3A_minv">minv</code></td>
<td>
<p>The minimum value on a <code style="white-space: pre;">&#8288;Raster*&#8288;</code>. Required because not
all Rasters have this defined internally.</p>
</td></tr>
<tr><td><code id=".plotGrob_+3A_maxv">maxv</code></td>
<td>
<p>The maximum value on a <code style="white-space: pre;">&#8288;Raster*&#8288;</code>. Required because not
all Rasters have this defined internally.</p>
</td></tr>
<tr><td><code id=".plotGrob_+3A_legend">legend</code></td>
<td>
<p>Logical indicating whether a legend should be drawn.
Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id=".plotGrob_+3A_legendtext">legendText</code></td>
<td>
<p>Vector of values to use for legend value labels.
Defaults to <code>NULL</code> which results in a pretty numeric
representation. If <code style="white-space: pre;">&#8288;Raster*&#8288;</code> has a Raster Attribute
Table (rat; see <span class="pkg">raster</span> package), this will be used
by default. Currently, only a single vector is accepted.</p>
</td></tr>
<tr><td><code id=".plotGrob_+3A_length">length</code></td>
<td>
<p>Numeric.</p>
</td></tr>
<tr><td><code id=".plotGrob_+3A_gp">gp</code></td>
<td>
<p><code>grid</code> parameters, usually the output of a call to <code><a href="#topic+gpar">gpar()</a></code>.</p>
</td></tr>
<tr><td><code id=".plotGrob_+3A_gptext">gpText</code></td>
<td>
<p><code>gpar</code> object for legend label text.</p>
</td></tr>
<tr><td><code id=".plotGrob_+3A_pch">pch</code></td>
<td>
<p>Point character for <code>SpatialPoints</code>, as <code>par</code>.</p>
</td></tr>
<tr><td><code id=".plotGrob_+3A_speedup">speedup</code></td>
<td>
<p>Numeric. The factor by which the number of vertices in
<code>SpatialPolygons</code> and <code style="white-space: pre;">&#8288;SpatialLines*&#8288;</code> will be
subsampled. The vertices are already subsampled by default to
make plotting faster.</p>
</td></tr>
<tr><td><code id=".plotGrob_+3A_name">name</code></td>
<td>
<p>Character string of name of object being plotted.</p>
</td></tr>
<tr><td><code id=".plotGrob_+3A_vp">vp</code></td>
<td>
<p>whole viewport tree of <code>quickPlotGrob</code></p>
</td></tr>
<tr><td><code id=".plotGrob_+3A_...">...</code></td>
<td>
<p>Additional arguments. None currently implemented.</p>
</td></tr>
<tr><td><code id=".plotGrob_+3A_verbose">verbose</code></td>
<td>
<p>Numeric or logical. If <code>TRUE</code> or <code style="white-space: pre;">&#8288;&gt;0&#8288;</code>, then messages will be
shown. If <code>FALSE</code> or <code>0</code>, most messages will be suppressed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>speedup</code> is only used for <code>SpatialPolygons</code>, <code>SpatialPoints</code>,
and <code>SpatialLines</code> in this function.
Attempts have been made to subsample at a good level that optimizes speed of
plotting, without losing visible quality. Nevertheless, to force all points to
be plotted, use a speedup value less than 0.1.
From a speed perspective, there appears to be an optimal subsampling when
using <code>thin</code> from the <span class="pkg">fastshp</span> package.
Presumably, too much thinning requires large distance matrices to be
calculated, slowing plotting down.
Too little thinning causes an overabundance of points to be plotted, slowing
plotting down.
</p>
<p>The suggested package <code>fastshp</code> can be installed with:
<code>install.packages("fastshp", repos = "https://rforge.net", type = "source")</code> or
for binary <code>install.packages("fastshp", repos = "https://PredictiveEcology.r-universe.dev")</code>
</p>
<p>NOTE: you may get errors relating to not having installed the software tools
required for building R packages on your system.
For building on Windows, you'll need to install <code>Rtools</code> from
<a href="https://cran.r-project.org/bin/windows/Rtools/">https://cran.r-project.org/bin/windows/Rtools/</a>.
</p>


<h3>Author(s)</h3>

<p>Eliot McIntire
</p>

<hr>
<h2 id='.preparePlotGrob'>Internal functions used by <code>Plot</code></h2><span id='topic+.preparePlotGrob'></span><span id='topic+PlotHelpers'></span><span id='topic+.xyAxes'></span><span id='topic+.xyAxes+2C.quickPlotGrob+2C.arrangement-method'></span><span id='topic+.Plot'></span><span id='topic+.Plot+2C.quickPlotGrob-method'></span><span id='topic+.refreshGrob'></span><span id='topic+.refreshGrob+2C.quickPlotGrob-method'></span><span id='topic+.updateGrobGPTextAxis'></span><span id='topic+.updateGrobGPTextAxis+2C.quickPlotGrob-method'></span>

<h3>Description</h3>

<p>Extract colours, legends and other things from object, and convert to a <code>plotGrob</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.preparePlotGrob(
  grobToPlot,
  sGrob,
  takeFromPlotObj,
  arr,
  newArr,
  prevMinMax,
  quickPlotGrobCounter,
  subPlots,
  cols
)

.xyAxes(sGrob, arr, whPlotFrame)

## S4 method for signature '.quickPlotGrob,.arrangement'
.xyAxes(sGrob, arr, whPlotFrame)

.Plot(
  sGrob,
  grobToPlot,
  subPlots,
  quickSubPlots,
  quickPlotGrobCounter,
  isBaseSubPlot,
  isNewPlot,
  isReplot,
  zMat,
  wipe,
  xyAxes,
  legendText,
  vps,
  nonPlotArgs,
  arr
)

## S4 method for signature '.quickPlotGrob'
.Plot(
  sGrob,
  grobToPlot,
  subPlots,
  quickSubPlots,
  quickPlotGrobCounter,
  isBaseSubPlot,
  isNewPlot,
  isReplot,
  zMat,
  wipe,
  xyAxes,
  legendText,
  vps,
  nonPlotArgs,
  arr
)

.refreshGrob(
  sGrob,
  subPlots,
  legendRange,
  grobToPlot,
  plotArgs,
  nColumns,
  nRows,
  whPlotObj,
  whExistingObj
)

## S4 method for signature '.quickPlotGrob'
.refreshGrob(
  sGrob,
  subPlots,
  legendRange,
  grobToPlot,
  plotArgs,
  nColumns,
  nRows,
  whPlotObj,
  whExistingObj
)

.updateGrobGPTextAxis(sGrob, arr, newArr)

## S4 method for signature '.quickPlotGrob'
.updateGrobGPTextAxis(sGrob, arr, newArr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".preparePlotGrob_+3A_grobtoplot">grobToPlot</code></td>
<td>
<p>Graphical object to plot</p>
</td></tr>
<tr><td><code id=".preparePlotGrob_+3A_sgrob">sGrob</code></td>
<td>
<p><code>quickPlotGrob</code> object</p>
</td></tr>
<tr><td><code id=".preparePlotGrob_+3A_takefromplotobj">takeFromPlotObj</code></td>
<td>
<p>Logical indicating whether data for <code>grobToPlot</code> should be found in
current call to Plot or from disk</p>
</td></tr>
<tr><td><code id=".preparePlotGrob_+3A_arr">arr</code></td>
<td>
<p>An arragement object.</p>
</td></tr>
<tr><td><code id=".preparePlotGrob_+3A_newarr">newArr</code></td>
<td>
<p>Logical, whether there is a new arrangement happening</p>
</td></tr>
<tr><td><code id=".preparePlotGrob_+3A_quickplotgrobcounter">quickPlotGrobCounter</code></td>
<td>
<p>Numeric. A counter. No meaning outside <code>Plot</code> function.</p>
</td></tr>
<tr><td><code id=".preparePlotGrob_+3A_subplots">subPlots</code></td>
<td>
<p>Character. Name of plot area.</p>
</td></tr>
<tr><td><code id=".preparePlotGrob_+3A_cols">cols</code></td>
<td>
<p>Colour vector.</p>
</td></tr>
<tr><td><code id=".preparePlotGrob_+3A_whplotframe">whPlotFrame</code></td>
<td>
<p>Numeric. Which plot within the <code>quickPlotGrobPlots</code> object.</p>
</td></tr>
<tr><td><code id=".preparePlotGrob_+3A_quicksubplots">quickSubPlots</code></td>
<td>
<p>List of many <code>quickPlotGrobs</code></p>
</td></tr>
<tr><td><code id=".preparePlotGrob_+3A_isbasesubplot">isBaseSubPlot</code></td>
<td>
<p>Logical. Is the currently being plotted object a base layer</p>
</td></tr>
<tr><td><code id=".preparePlotGrob_+3A_isnewplot">isNewPlot</code></td>
<td>
<p>Logical. Is the currently being plotted object a new, additional plot</p>
</td></tr>
<tr><td><code id=".preparePlotGrob_+3A_isreplot">isReplot</code></td>
<td>
<p>Logical. Is the currently being plotted object a replot due to something
like a rearrangement</p>
</td></tr>
<tr><td><code id=".preparePlotGrob_+3A_zmat">zMat</code></td>
<td>
<p>List resulting from <code>.preparePlotGrob</code></p>
</td></tr>
<tr><td><code id=".preparePlotGrob_+3A_wipe">wipe</code></td>
<td>
<p>Logical. Is the currently being plotted object require a white rectangle to
be plotted first, and subsequent other changes.</p>
</td></tr>
<tr><td><code id=".preparePlotGrob_+3A_xyaxes">xyAxes</code></td>
<td>
<p>List of length 2, resulting from <code>.xyAxes</code></p>
</td></tr>
<tr><td><code id=".preparePlotGrob_+3A_legendtext">legendText</code></td>
<td>
<p>Character vector of legend value labels.
Defaults to <code>NULL</code>, which results in a pretty numeric
representation.
If <code style="white-space: pre;">&#8288;Raster*&#8288;</code> has a Raster Attribute Table (<code>rat</code>;
see <span class="pkg">raster</span> package), this will be used by default.
Currently, only a single vector is accepted.
The length of this must match the length of the legend, so
this is mostly useful for discrete-valued rasters.</p>
</td></tr>
<tr><td><code id=".preparePlotGrob_+3A_vps">vps</code></td>
<td>
<p>A viewport tree resulting from <code>.makeViewports</code></p>
</td></tr>
<tr><td><code id=".preparePlotGrob_+3A_nonplotargs">nonPlotArgs</code></td>
<td>
<p>Arguments passed to <code>Plot</code> that are not <code>.quickPlottables</code>,
but are passed along with <code>.quickPlottables</code>.</p>
</td></tr>
<tr><td><code id=".preparePlotGrob_+3A_legendrange">legendRange</code></td>
<td>
<p>Numeric vector giving values that, representing the lower
and upper bounds of a legend (i.e., <code>1:10</code> or
<code>c(1,10)</code> will give same result) that will override
the data bounds contained within the <code>grobToPlot</code>.</p>
</td></tr>
<tr><td><code id=".preparePlotGrob_+3A_plotargs">plotArgs</code></td>
<td>
<p>list. Any arguments that the the grid package can accept for
the specific grob types, e.g., <code>rasterGrob</code>, <code>polygonGrob</code>, etc.</p>
</td></tr>
<tr><td><code id=".preparePlotGrob_+3A_ncolumns">nColumns</code></td>
<td>
<p>Numeric, length 1, indicating how many columns are in the device arrangement</p>
</td></tr>
<tr><td><code id=".preparePlotGrob_+3A_nrows">nRows</code></td>
<td>
<p>Numeric, length 1, indicating how many rows are in the device arrangement</p>
</td></tr>
<tr><td><code id=".preparePlotGrob_+3A_whplotobj">whPlotObj</code></td>
<td>
<p>Numeric. Length 1, indicating which of the currently objects passed into
<code>Plot</code> is currently being plotted, i.e., a counter of sorts.</p>
</td></tr>
<tr><td><code id=".preparePlotGrob_+3A_whexistingobj">whExistingObj</code></td>
<td>
<p>Numeric. Like <code>whPlotObj</code>, but for whole existing plot, not just supplied in
current call.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eliot McIntire
</p>

<hr>
<h2 id='.prepareRaster'>Prepare raster for plotting</h2><span id='topic+.prepareRaster'></span>

<h3>Description</h3>

<p>Internal function. Takes a raster <code>.quickPlotGrob</code>, and converts <code>zoomExtent</code> into
a zoom, and <code>legendRange</code> into a legend.
Then calculates the <code>maxpixels</code> to plot for speed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.prepareRaster(
  grobToPlot,
  zoomExtent,
  legendRange,
  takeFromPlotObj,
  arr,
  speedup,
  newArr
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".prepareRaster_+3A_grobtoplot">grobToPlot</code></td>
<td>
<p>A <code>.quickPlotGrob</code> object.</p>
</td></tr>
<tr><td><code id=".prepareRaster_+3A_zoomextent">zoomExtent</code></td>
<td>
<p>an extent object</p>
</td></tr>
<tr><td><code id=".prepareRaster_+3A_legendrange">legendRange</code></td>
<td>
<p>a numeric vector of length &gt;=2 indicating the desired legend range.</p>
</td></tr>
<tr><td><code id=".prepareRaster_+3A_takefromplotobj">takeFromPlotObj</code></td>
<td>
<p>logical. Should the object be found in the <code>Plot</code> call or
<code>.GlobalEnv</code></p>
</td></tr>
<tr><td><code id=".prepareRaster_+3A_arr">arr</code></td>
<td>
<p>an <code>.arrangement</code> object</p>
</td></tr>
<tr><td><code id=".prepareRaster_+3A_speedup">speedup</code></td>
<td>
<p>numeric, greater than 1 will usually speed up plotting at the
expense of resolution</p>
</td></tr>
<tr><td><code id=".prepareRaster_+3A_newarr">newArr</code></td>
<td>
<p>logical, whether this is a new arrangement or just adding to a previous one</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eliot McIntire
</p>

<hr>
<h2 id='.quickPlot-class'>The <code>.quickPlot</code> class</h2><span id='topic+.quickPlot-class'></span><span id='topic+.quickPlot'></span>

<h3>Description</h3>

<p>This class contains all necessary information to build a Plot on a device,
except the actual data. Thus, this class differs notably from the grid package,
which keeps a copy of all data <em>and</em> information in a hidden location for further
access for rebuilding, erasing etc. This difference allows the Plot function to
be much faster than using the grid methodology directly. The cost to this speed
gain is that the objects <em>must</em> be available, by name, in the <code>.GlobalEnv</code>.
</p>


<h3>Details</h3>

<p>This class contains two slots, one for the overall arrangement of the plots within
the device window, and the second for all the <code><a href="#topic+.quickPlotGrob">.quickPlotGrob()</a></code> objects within
that device window. These <code><a href="#topic+.quickPlotGrob">.quickPlotGrob()</a></code> objects are the individual
&quot;smallest&quot; plot unit.
</p>
<p>These <code style="white-space: pre;">&#8288;gp*&#8288;</code> parameters will specify plot parameters that are
available with <code>gpar()</code>. <code>gp</code> will adjust plot parameters,
<code>gpText</code> will adjust title and legend text, <code>gpAxis</code> will
adjust the axes. <code>size</code> adjusts point size in a
<code>SpatialPoints</code> object. These will persist with the
original <code>Plot</code> call for each individual object. Multiple
entries can be used, but they must be named list elements
and they must match the <code>...</code> items to plot. This is true
for a <code>RasterStack</code> also, i.e., the list of named elements
must be the same length as the number of layers being
plotted. The naming convention used is: <code>RasterStackName$layerName</code>,
i.e, <code>landscape$DEM</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>arr</code></dt><dd><p>An .arrangement object</p>
</dd>
<dt><code>quickPlotGrobList</code></dt><dd><p>list. A list of lists of <code>.quickPlotGrob</code> objects</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Eliot McIntire
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quickPlotClasses">quickPlotClasses()</a></code>
</p>

<hr>
<h2 id='.quickPlotEnv'>The quickPlot environment</h2><span id='topic+.quickPlotEnv'></span>

<h3>Description</h3>

<p>Environment used internally to store internal package objects and methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.quickPlotEnv
</code></pre>


<h3>Format</h3>

<p>An object of class <code>environment</code> of length 1.
</p>

<hr>
<h2 id='.quickPlotGrob-class'>The <code>.quickPlotGrob</code> class</h2><span id='topic+.quickPlotGrob-class'></span><span id='topic+.quickPlotGrob'></span>

<h3>Description</h3>

<p>This class contains the plotting <code>.quickPlotGrob</code> information.
</p>


<h3>Details</h3>

<p>These <code style="white-space: pre;">&#8288;gp*&#8288;</code> parameters will specify plot parameters that are available
with <code>gpar()</code>. <code>gp</code> will adjust plot parameters, <code>gpText</code> will
adjust title and legend text, <code>gpAxis</code> will adjust the axes.
<code>size</code> adjusts point size in a <code>SpatialPoints</code> object.
These will persist with the original <code>Plot</code> call for each individual object.
Multiple entries can be used, but they must be named list elements
and they must match the <code>...</code> items to plot.
This is true for a <code>RasterStack</code> also, i.e., the list of named elements
must be the same length as the number of layers being plotted.
The naming convention used is: <code>RasterStackName$layerName</code>, i.e, <code>landscape$DEM</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>plotName</code></dt><dd><p>character. Name of the plot frame, which is by default a concatenation
of the <code>objName</code> and <code>layerName</code></p>
</dd>
<dt><code>objName</code></dt><dd><p>character. Name of object represented by this <code>.quickPlotGrob</code></p>
</dd>
<dt><code>envir</code></dt><dd><p>environment. The environment in which to find the <code>objName</code></p>
</dd>
<dt><code>layerName</code></dt><dd><p>character. Name of the layer represented by this <code>.quickPlotGrob</code>.
Primarily used for <code>RasterStack</code>s.</p>
</dd>
<dt><code>objClass</code></dt><dd><p>character. Class of the object represented by this <code>.quickPlotGrob</code>.</p>
</dd>
<dt><code>isSpatialObjects</code></dt><dd><p>logical. TRUE if the object is one of the SpaDES recognized
<code>spatialObject</code> classes.</p>
</dd>
<dt><code>plotArgs</code></dt><dd><p>list. Any parameters needed for plotting, set by <code>Plot</code> call.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Eliot McIntire
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quickPlotClasses">quickPlotClasses()</a></code>
</p>

<hr>
<h2 id='.unittrim'>Convert <code>grid.locator</code> units</h2><span id='topic+.unittrim'></span>

<h3>Description</h3>

<p>Internal function from example in <code>?grid.locator</code>.
Converts <code>grid.locator</code> units to meaningful units.
Used within <code>.clickCoord</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.unittrim(grid.locator)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".unittrim_+3A_grid.locator">grid.locator</code></td>
<td>
<p>an object that was output by a call to <code>grid.locator</code>
and mouse click(s).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paul Murrell
</p>

<hr>
<h2 id='.updateQuickPlot'>Merge two quickPlot objects</h2><span id='topic+.updateQuickPlot'></span><span id='topic+.updateQuickPlot+2C.quickPlot+2Clist-method'></span><span id='topic+.updateQuickPlot+2C.quickPlot+2Cmissing-method'></span>

<h3>Description</h3>

<p>Merges two <code>.quickPlot</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.updateQuickPlot(newSP, curr, ...)

## S4 method for signature '.quickPlot,list'
.updateQuickPlot(newSP, curr, ...)

## S4 method for signature '.quickPlot,missing'
.updateQuickPlot(newSP, curr, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".updateQuickPlot_+3A_newsp">newSP</code></td>
<td>
<p>The &quot;new&quot; <code>.quickPlot</code> object.
I.e., the new merges and overwrites into current.</p>
</td></tr>
<tr><td><code id=".updateQuickPlot_+3A_curr">curr</code></td>
<td>
<p>The &quot;current&quot; <code>.quickPlot</code> object.
I.e., the one to be merged into.</p>
</td></tr>
<tr><td><code id=".updateQuickPlot_+3A_...">...</code></td>
<td>
<p>Additional arguments. Currently none implemented.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eliot McIntire
</p>

<hr>
<h2 id='clearPlot'>Clear plotting device</h2><span id='topic+clearPlot'></span><span id='topic+clearPlot+2Cnumeric+2Clogical-method'></span><span id='topic+clearPlot+2Cnumeric+2Cmissing-method'></span><span id='topic+clearPlot+2Cmissing+2Clogical-method'></span><span id='topic+clearPlot+2Cmissing+2Cmissing-method'></span>

<h3>Description</h3>

<p>Under some conditions, a device and its metadata need to be cleared manually.
This can be done with either the <code>new = TRUE</code> argument within the call to <code>Plot</code>.
Sometimes, the metadata of a previous plot will prevent correct plotting of
a new <code>Plot</code> call.
Use <code>clearPlot</code> to clear the device and all the associated metadata manually.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clearPlot(
  dev = dev.cur(),
  removeData = TRUE,
  force = FALSE,
  verbose = getOption("quickPlot.verbose")
)

## S4 method for signature 'numeric,logical'
clearPlot(
  dev = dev.cur(),
  removeData = TRUE,
  force = FALSE,
  verbose = getOption("quickPlot.verbose")
)

## S4 method for signature 'numeric,missing'
clearPlot(dev, force)

## S4 method for signature 'missing,logical'
clearPlot(removeData, force)

## S4 method for signature 'missing,missing'
clearPlot(dev, removeData, force)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clearPlot_+3A_dev">dev</code></td>
<td>
<p>Numeric. Device number to clear.</p>
</td></tr>
<tr><td><code id="clearPlot_+3A_removedata">removeData</code></td>
<td>
<p>Logical indicating whether any data that was stored in the
<code>.quickPlotEnv</code> should also be removed; i.e., not just the plot window wiped.</p>
</td></tr>
<tr><td><code id="clearPlot_+3A_force">force</code></td>
<td>
<p>Logical or &quot;all&quot;. Sometimes the graphics state cannot be fixed by a simple
<code>clearPlot()</code>. If TRUE, this will close the device and reopen the same
device number. If &quot;all&quot;, then all <code>quickPlot</code> related data from all devices
will be cleared, in addition to device closing and reopening.</p>
</td></tr>
<tr><td><code id="clearPlot_+3A_verbose">verbose</code></td>
<td>
<p>Numeric or logical. If <code>TRUE</code> or <code style="white-space: pre;">&#8288;&gt;0&#8288;</code>, then messages will be
shown. If <code>FALSE</code> or <code>0</code>, most messages will be suppressed.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eliot McIntire
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Plot">Plot()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
  Plot(1:10)
  clearPlot() # clears
}

</code></pre>

<hr>
<h2 id='clickValues'>Mouse interactions with Plots</h2><span id='topic+clickValues'></span><span id='topic+clickExtent'></span><span id='topic+clickCoordinates'></span><span id='topic+.clickCoord'></span>

<h3>Description</h3>

<p>These functions use <code>grid.locator</code>. The primary two user-level functions are
<code>clickValues</code> and <code>clickExtent</code>. These functions automatically select
the correct viewport (i.e., map) where the mouse clicks occurred so the user
does not have to manually specify which map is being clicked on.
This works for <code style="white-space: pre;">&#8288;Raster*&#8288;</code>, <code style="white-space: pre;">&#8288;SpatialPoints*&#8288;</code>, and <code style="white-space: pre;">&#8288;SpatialPolygons*&#8288;</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clickValues(n = 1)

clickExtent(
  devNum = NULL,
  plot.it = TRUE,
  verbose = getOption("quickPlot.verbose")
)

clickCoordinates(n = 1)

.clickCoord(X, n = 1, gl = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clickValues_+3A_n">n</code></td>
<td>
<p>The number of mouse clicks to do.</p>
</td></tr>
<tr><td><code id="clickValues_+3A_devnum">devNum</code></td>
<td>
<p>The device number for the new plot to be plotted on.</p>
</td></tr>
<tr><td><code id="clickValues_+3A_plot.it">plot.it</code></td>
<td>
<p>Logical. If <code>TRUE</code> a new plotting window is made for the
new extent. Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="clickValues_+3A_verbose">verbose</code></td>
<td>
<p>Numeric or logical. If <code>TRUE</code> or <code style="white-space: pre;">&#8288;&gt;0&#8288;</code>, then messages will be
shown. If <code>FALSE</code> or <code>0</code>, most messages will be suppressed.</p>
</td></tr>
<tr><td><code id="clickValues_+3A_x">X</code></td>
<td>
<p>The raster object whose values will be returned where mouse clicks occur.</p>
</td></tr>
<tr><td><code id="clickValues_+3A_gl">gl</code></td>
<td>
<p>An object created by a call to <code>grid.locator</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>clickValues</code> is equivalent to running <code>X[SpatialPoints(locator(n))]</code>, where
X is the raster being clicked on, in base graphics. This function determines which place in the
grid.layout was clicked and makes all appropriate calculations to determine the value
on the raster(s) at that or those location(s). It should be noted that when zooming in
to rasters, plotting of rasters will only allow for complete pixels to be plotted, even
if the extent is not perfectly in line with pixel edges. As a result, when values
returned by this function may be slightly off (&lt;0.5 pixel width).
</p>
<p><code>clickExtent</code> is for drawing an extent with two mouse clicks on a given Plotted map.
</p>
<p><code>clickCoordinates</code> is the workhorse function that determines which plot has been
clicked on and passes this plot name and the clicked coordinates to <code>.clickCoord</code>.
</p>
<p><code>.clickCoord</code> is intended for internal use and is called by other functions here.
</p>
<p><code>clickExtent</code> will place the new, zoomed in plot over top of the existing
object. To recover original full object, double click anywhere during an
active <code>clickExtent</code>. Currently, subsequent <code>clickExtent</code> is a click on the
original map extent, not the &quot;zoomed in&quot; map extent. See example.
</p>


<h3>Value</h3>

<p><code>clickValues</code> returns the layer names and values at the clicked points.
<code>clickExtent</code> invisibly returns the extent object, and optionally plots
it in a new device window.
<code>clickCoordinates</code> returns the xy coordinates in the units of the plot clicked on.
</p>


<h3>Author(s)</h3>

<p>Eliot McIntire
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# clickValues and family are unreliable on Rstudio Server as the plotting device
#   does not report its dimensions correctly; this may change in future
#   updates to Rstudio
if (interactive() &amp;&amp; !isRstudioServer() ) {
  files &lt;- system.file("maps", package = "quickPlot")
  files &lt;- dir(files, full.names = TRUE, pattern = "tif")
  maps &lt;- lapply(files, function(x) terra::rast(x))
  names(maps) &lt;- sapply(basename(files), function(x) {
    strsplit(x, split = "\\.")[[1]][1]
  })
  landscape &lt;- c(maps$DEM, maps$forestCover, maps$habitatQuality)

  clearPlot()
  Plot(landscape)
  clickValues(3) # click at three locations on the Plot device

  clearPlot()
  Plot(landscape)
  e &lt;- clickExtent() # click at two locations on the Plot device
  print(e)

  # repeated zooming to try various places on the original device
  for(i in 1:4) clickExtent() # click at two locations on the Plot device
}


</code></pre>

<hr>
<h2 id='coordinates'>Extract coordinates from a variety of spatial objects</h2><span id='topic+coordinates'></span><span id='topic+coordinates+2CANY-method'></span>

<h3>Description</h3>

<p>This will extract using <code>terra::crds</code>, <code>sf::st_coordinates</code> and
<code>raster::coordinates</code>. Other packages can create methods, as this is
generic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ANY'
coordinates(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coordinates_+3A_obj">obj</code></td>
<td>
<p>An object from which to extract the coordinates (e.g., <code>sf</code>, <code>sp</code>)</p>
</td></tr>
<tr><td><code id="coordinates_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 2 column matrix of coordinates (x and y)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)
caribou &lt;- terra::vect(x = cbind(x = stats::runif(1e1, -50, 50),
                                        y = stats::runif(1e1, -50, 50)))
coordinates(caribou)

</code></pre>

<hr>
<h2 id='dev'>Specify where to plot</h2><span id='topic+dev'></span>

<h3>Description</h3>

<p>Switch to an existing plot device, or if not already open,
launch a new graphics device based on operating system used.
On Windows and macOS, if <code>x</code> is not provided, this will open or switch to the first
non-RStudio device, which is much faster than the &lsquo;<span class="file">png</span>&rsquo;-based RStudio plot device.
Currently, this will not open anything new.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dev(x, ..., verbose = getOption("quickPlot.verbose"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dev_+3A_x">x</code></td>
<td>
<p>The number of a plot device. If missing, will open a new
non-RStudio plotting device</p>
</td></tr>
<tr><td><code id="dev_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+newPlot">newPlot()</a></code>.</p>
</td></tr>
<tr><td><code id="dev_+3A_verbose">verbose</code></td>
<td>
<p>Numeric or logical. If <code>TRUE</code> or <code style="white-space: pre;">&#8288;&gt;0&#8288;</code>, then messages will be
shown. If <code>FALSE</code> or <code>0</code>, most messages will be suppressed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For example, <code>dev(6)</code> switches the active plot device to device 6.
If it does not exist, it opens it. If devices 1-5 don't exist they will be opened too.
</p>


<h3>Value</h3>

<p>Opens a new plot device on the screen.
Invisibly returns the device number selected.
</p>


<h3>Author(s)</h3>

<p>Eliot McIntire and Alex Chubaty
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  dev(4)

## End(Not run)

</code></pre>

<hr>
<h2 id='divergentColors'>Divergent colour palette</h2><span id='topic+divergentColors'></span><span id='topic+divergentColours'></span><span id='topic+divergentColors+2Ccharacter+2Ccharacter+2Cnumeric+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Creates a palette for the current session for a divergent-colour graphic with
a non-symmetric range.
Based on ideas from Maureen Kennedy, Nick Povak, and Alina Cansler.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>divergentColors(
  start.color,
  end.color,
  min.value,
  max.value,
  mid.value = 0,
  mid.color = "white"
)

## S4 method for signature 'character,character,numeric,numeric'
divergentColors(
  start.color,
  end.color,
  min.value,
  max.value,
  mid.value = 0,
  mid.color = "white"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="divergentColors_+3A_start.color">start.color</code></td>
<td>
<p>Start colour to be passed to <code>colorRampPalette</code>.</p>
</td></tr>
<tr><td><code id="divergentColors_+3A_end.color">end.color</code></td>
<td>
<p>End colour to be passed to <code>colorRampPalette</code>.</p>
</td></tr>
<tr><td><code id="divergentColors_+3A_min.value">min.value</code></td>
<td>
<p>Numeric minimum value corresponding to <code>start.colour</code>.
If attempting to change the colour of a <code>RasterLayer</code>,
this can be set to <code>minFn(RasterObject)</code>.</p>
</td></tr>
<tr><td><code id="divergentColors_+3A_max.value">max.value</code></td>
<td>
<p>Numeric maximum value corresponding to <code>end.colour</code>.
If attempting to change the colour of a <code>RasterLayer</code>,
this can be set to <code>maxFn(RasterObject)</code>.</p>
</td></tr>
<tr><td><code id="divergentColors_+3A_mid.value">mid.value</code></td>
<td>
<p>Numeric middle value corresponding to <code>mid.colour</code>.
Default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="divergentColors_+3A_mid.color">mid.color</code></td>
<td>
<p>Middle colour to be passed to <code>colorRampPalette</code>.
Defaults to <code>"white"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A diverging colour palette.
</p>


<h3>Author(s)</h3>

<p>Eliot McIntire and Alex Chubaty
</p>


<h3>See Also</h3>

<p><code><a href="grDevices.html#topic+colorRampPalette">colorRampPalette()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>divergentColors("darkred", "darkblue", -10, 10, 0, "white")

</code></pre>

<hr>
<h2 id='equalExtent'>Assess whether a list of extents are all equal</h2><span id='topic+equalExtent'></span><span id='topic+equalExtent+2Clist-method'></span>

<h3>Description</h3>

<p>Assess whether a list of extents are all equal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>equalExtent(extents)

## S4 method for signature 'list'
equalExtent(extents)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="equalExtent_+3A_extents">extents</code></td>
<td>
<p>list of extents objects</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eliot McIntire
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)

files &lt;- system.file("maps", package = "quickPlot")
files &lt;- dir(files, full.names = TRUE, pattern = "tif")
maps &lt;- lapply(files, function(x) terra::rast(x))
names(maps) &lt;- sapply(basename(files), function(x) {
  strsplit(x, split = "\\.")[[1]][1]
})
extnts &lt;- lapply(maps, terra::ext)
equalExtent(extnts) ## TRUE

</code></pre>

<hr>
<h2 id='extent'>Get extent of a variety of spatial objects</h2><span id='topic+extent'></span><span id='topic+extent+2CANY-method'></span>

<h3>Description</h3>

<p>This is a wrapper around <code>terra::ext</code>, <code>sf::st_bbox</code>, and
<code>raster::extent</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ANY'
extent(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extent_+3A_x">x</code></td>
<td>
<p>The spatial object from which to extract the extent.</p>
</td></tr>
<tr><td><code id="extent_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of length 4 with elements <code>xmin</code>, <code>xmax</code>, <code>ymin</code>, and <code>ymax</code>,
in that order.
</p>

<hr>
<h2 id='fortify'>Fortify</h2><span id='topic+fortify'></span><span id='topic+ffortify'></span>

<h3>Description</h3>

<p>Convert an arbitrary object to a <code>data.frame</code>-like object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ffortify(
  x,
  matchFortify = TRUE,
  simple = FALSE,
  maxNumPolygons = getOption("quickPlot.maxNumPolygons", 3000),
  verbose = getOption("quickPlot.verbose")
)
</code></pre>


<h3>Note</h3>

<p>This only deals with <code>SpatialPolygons</code> objects.
</p>

<hr>
<h2 id='getColors'>Get and set colours for plotting <code style="white-space: pre;">&#8288;Raster*&#8288;</code> objects</h2><span id='topic+getColors'></span><span id='topic+getColours'></span><span id='topic+setColors+3C-'></span><span id='topic+setColours'></span><span id='topic+setColors'></span>

<h3>Description</h3>

<p>Get and set colours for plotting <code style="white-space: pre;">&#8288;Raster*&#8288;</code> objects
</p>
<p><code>setColors</code> works as a replacement method or a normal function call.
This function can accept <code>RColorBrewer</code> colours by name. See examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getColors(object)

setColors(object, ..., n, verbose = getOption("quickPlot.verbose")) &lt;- value

setColors(object, value, n, verbose = getOption("quickPlot.verbose"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getColors_+3A_object">object</code></td>
<td>
<p>A <code style="white-space: pre;">&#8288;Raster*&#8288;</code> object.</p>
</td></tr>
<tr><td><code id="getColors_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>colorRampPalette</code>.</p>
</td></tr>
<tr><td><code id="getColors_+3A_n">n</code></td>
<td>
<p>An optional vector of values specifying the number
of levels from which to interpolate the colour palette.</p>
</td></tr>
<tr><td><code id="getColors_+3A_verbose">verbose</code></td>
<td>
<p>Numeric or logical. If <code>TRUE</code> or <code style="white-space: pre;">&#8288;&gt;0&#8288;</code>, then messages will be
shown. If <code>FALSE</code> or <code>0</code>, most messages will be suppressed.</p>
</td></tr>
<tr><td><code id="getColors_+3A_value">value</code></td>
<td>
<p>Named list of hex colour codes (e.g., from
<code>RColorBrewer::brewer.pal</code>), corresponding to the names
of <code>RasterLayer</code>s in <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a named list of colours.
</p>
<p>Returns a Raster with the <code>colortable</code> slot set to <code>values</code>.
</p>


<h3>Author(s)</h3>

<p>Alex Chubaty
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setColors+3C-">setColors&lt;-()</a></code>, <code>brewer.pal()</code>, RColorBrewer::ColorBrewer
</p>
<p><code>brewer.pal()</code>, <code>RColorBrewer::ColorBrewer</code>,
<code><a href="grDevices.html#topic+colorRamp">colorRampPalette()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)

ras &lt;- rast(matrix(c(0, 0, 1, 2), ncol = 2, nrow = 2))

getColors(ras) ## none

# Use replacement method
setColors(ras, n = 3) &lt;- c("red", "blue", "green")
getColors(ras)

clearPlot()
Plot(ras)

# Use function method
ras &lt;- setColors(ras, n = 3, c("red", "blue", "yellow"))
getColors(ras)

clearPlot()
Plot(ras)

# Using the wrong number of colors, e.g., here 2 provided,
# for a raster with 3 values... causes interpolation, which may be surprising
ras &lt;- setColors(ras, c("red", "blue"))
clearPlot()
Plot(ras)

# Real number rasters - interpolation is used
ras &lt;- rast(matrix(runif(9), ncol = 3, nrow = 3)) |&gt;
  setColors(c("red", "yellow")) # interpolates when real numbers, gives warning

clearPlot()
Plot(ras)

# Factor rasters, can be contiguous (numerically) or not, in this case not:
ras &lt;- rast(matrix(sample(c(1, 3, 6), size = 9, replace = TRUE), ncol = 3, nrow = 3))
levels(ras) &lt;- data.frame(ID = c(1, 3, 6), Names = c("red", "purple", "yellow"))
ras &lt;- setColors(ras, n = 3, c("red", "purple", "yellow"))
getColors(ras)

clearPlot()
Plot(ras)

# if a factor raster, and not enough labels are provided, then a warning
#   will be given, and colors will be interpolated
#   The level called purple is not purple, but interpolated betwen red and yellow
suppressWarnings({
  ras &lt;- setColors(ras, c("red", "yellow"))
  clearPlot()
  Plot(ras)
})

# use RColorBrewer colors
setColors(ras) &lt;- "Reds"
clearPlot()
Plot(ras)
</code></pre>

<hr>
<h2 id='gpar'>Importing some grid functions</h2><span id='topic+gpar'></span>

<h3>Description</h3>

<p>Currently only the <code>gpar</code> function is imported. This is a convenience so that users
can change <code>Plot</code> arguments without having to load the entire grid package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gpar(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gpar_+3A_...">...</code></td>
<td>
<p> Any number of named arguments. </p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="grid.html#topic+gpar">grid::gpar()</a></code>
</p>

<hr>
<h2 id='isRstudioServer'>Determine if current session is RStudio Server</h2><span id='topic+isRstudioServer'></span>

<h3>Description</h3>

<p>Determine if current session is RStudio Server
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isRstudioServer()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>isRstudioServer() # returns FALSE or TRUE
</code></pre>

<hr>
<h2 id='layerNames'>Extract the layer names of Spatial Objects</h2><span id='topic+layerNames'></span><span id='topic+layerNames+2CANY-method'></span>

<h3>Description</h3>

<p>There are already methods for <code style="white-space: pre;">&#8288;Raster*&#8288;</code> objects. This adds methods for
<code style="white-space: pre;">&#8288;SpatialPoints*&#8288;</code>, <code style="white-space: pre;">&#8288;SpatialLines*&#8288;</code>, and <code style="white-space: pre;">&#8288;SpatialPolygons*&#8288;</code>,
returning an empty character vector of length 1.
This function was created to give consistent, meaningful results for all
classes of objects plotted by <code>Plot</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layerNames(object)

## S4 method for signature 'ANY'
layerNames(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="layerNames_+3A_object">object</code></td>
<td>
<p>A <code style="white-space: pre;">&#8288;Raster*&#8288;</code>, <code style="white-space: pre;">&#8288;SpatialPoints*&#8288;</code>, <code style="white-space: pre;">&#8288;SpatialLines*&#8288;</code>,
or <code style="white-space: pre;">&#8288;SpatialPolygons*&#8288;</code> object; or list of these.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eliot McIntire
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)

## RasterLayer objects
files &lt;- system.file("maps", package = "quickPlot")
files &lt;- dir(files, full.names = TRUE, pattern = "tif")
maps &lt;- lapply(files, function(x) terra::rast(x))
names(maps) &lt;- sapply(basename(files), function(x) {
  strsplit(x, split = "\\.")[[1]][1]
})
layerNames(maps)

## SpatVector objects
caribou &lt;- terra::vect(cbind(x = stats::runif(1e2, -50, 50),
                             y = stats::runif(1e2, -50, 50)))
layerNames(caribou)

</code></pre>

<hr>
<h2 id='makeLines'>Make <code>SpatialLines</code> object from two <code>SpatialPoints</code> objects</h2><span id='topic+makeLines'></span>

<h3>Description</h3>

<p>The primary conceived usage of this is to draw arrows following the
trajectories of agents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeLines(from, to)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeLines_+3A_from">from</code></td>
<td>
<p>Starting spatial coordinates (<code>SpatialPointsDataFrame</code>).</p>
</td></tr>
<tr><td><code id="makeLines_+3A_to">to</code></td>
<td>
<p>Ending spatial coordinates (<code>SpatialPointsDataFrame</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>SpatialLines</code> object. When this object is used within a
<code>Plot</code> call and the <code>length</code> argument is specified, then
arrow heads will be drawn. See examples.
</p>


<h3>Author(s)</h3>

<p>Eliot McIntire
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)
# Make 2 objects
caribou1 &lt;- terra::vect(cbind(x = stats::runif(10, -50, 50),
                              y = stats::runif(10, -50, 50)))
caribou2 &lt;- terra::vect(cbind(x = stats::runif(10, -50, 50),
                              y = stats::runif(10, -50, 50)))

caribouTraj &lt;- makeLines(caribou1, caribou2)

if (interactive())
  Plot(caribouTraj, length = 0.1) # shows arrows

# or  to a previous Plot
files &lt;- dir(system.file("maps", package = "quickPlot"), full.names = TRUE, pattern = "tif")
maps &lt;- lapply(files, terra::rast)
names(maps) &lt;- lapply(maps, names)

caribouTraj &lt;- makeLines(caribou1, caribou2)

if (interactive()) {
  clearPlot()
  Plot(maps$DEM)
  Plot(caribouTraj, addTo = "maps$DEM", length = 0.1)
}

</code></pre>

<hr>
<h2 id='newPlot'>Open a new plotting window</h2><span id='topic+newPlot'></span><span id='topic+dev.useRSGD'></span>

<h3>Description</h3>

<p>Open a new plotting window
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newPlot(noRStudioGD = TRUE, ..., verbose = getOption("quickPlot.verbose"))

dev.useRSGD(useRSGD = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="newPlot_+3A_norstudiogd">noRStudioGD</code></td>
<td>
<p>Logical Passed to <code>dev.new</code>. Default is TRUE to avoid using
RStudio graphics device, which is slow.</p>
</td></tr>
<tr><td><code id="newPlot_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
<tr><td><code id="newPlot_+3A_verbose">verbose</code></td>
<td>
<p>Numeric or logical. If <code>TRUE</code> or <code style="white-space: pre;">&#8288;&gt;0&#8288;</code>, then messages will be
shown. If <code>FALSE</code> or <code>0</code>, most messages will be suppressed.</p>
</td></tr>
<tr><td><code id="newPlot_+3A_usersgd">useRSGD</code></td>
<td>
<p>Logical indicating whether the default device should be the
RStudio graphic device, or the platform default (<code>quartz</code>
on macOS; <code>windows</code> on Windows; <code>x11</code> on others, e.g., Linux).</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code><a href="grDevices.html#topic+dev.new">dev.new()</a></code> is supposed to be the correct way to open a new
window in a platform-generic way; however, does not work in RStudio
(<a href="https://github.com/PredictiveEcology/SpaDES/issues/116">SpaDES#116</a>).
Use <code>dev.useRSGD(FALSE)</code> to avoid RStudio for the remainder of this session,
and <code>dev.useRSGD(TRUE)</code> to use the RStudio graphics device.
(This sets the default device via the <code>device</code> option.)
</p>


<h3>Author(s)</h3>

<p>Eliot McIntire and Alex Chubaty
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dev">dev()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  ## set option to avoid using Rstudio graphics device
  dev.useRSGD(FALSE)

  ## open new plotting window
  newPlot()

## End(Not run)

</code></pre>

<hr>
<h2 id='numLayers'>Find the number of layers in an object</h2><span id='topic+numLayers'></span>

<h3>Description</h3>

<p>A unified function for <code>raster::nlayers</code>, <code>terra::nlyrs</code>, or lists of these.
Default function returns <code>1L</code> for all other classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>numLayers(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="numLayers_+3A_x">x</code></td>
<td>
<p>An object or list of objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of layers in the object.
</p>


<h3>Author(s)</h3>

<p>Eliot McIntire
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)

files &lt;- system.file("maps", package = "quickPlot")
files &lt;- dir(files, full.names = TRUE, pattern = "tif")
maps &lt;- lapply(files, function(x) rast(x))
names(maps) &lt;- sapply(basename(files), function(x) {
  strsplit(x, split = "\\.")[[1]][1]
})
stck &lt;- rast(maps)

numLayers(maps)
numLayers(stck)

</code></pre>

<hr>
<h2 id='Plot'><code>Plot</code>: Fast, optimally arranged, multi-panel plotting</h2><span id='topic+Plot'></span><span id='topic+Plot+2CANY-method'></span><span id='topic+rePlot'></span>

<h3>Description</h3>

<p>This can take objects of type <code style="white-space: pre;">&#8288;Raster*&#8288;</code>, <code style="white-space: pre;">&#8288;SpatialPoints*&#8288;</code>, <code style="white-space: pre;">&#8288;SpatialPolygons*&#8288;</code>,
and any combination of those.
These can be provided as individual objects, or a named list.
If a named list, the names either represent a different original object in the
calling environment and that will be used, or if the names don't exist in the
calling environment, then they will be copied to <code>.quickPlotEnv</code> for reuse later.
It can also handle <code>ggplot2</code> objects or <code>base::histogram</code> objects
created via call to <code>exHist &lt;- hist(1:10, plot = FALSE)</code>. It can also take
arguments as if it were a call to <code>plot</code>. In this latter
case, the user should be explicit about naming the plot area using <code>addTo</code>.
Customization of the <code>ggplot2</code> elements can be done as a normal
<code>ggplot2</code> plot, then added with <code>Plot(ggplotObject)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Plot(
  ...,
  new = FALSE,
  addTo = NULL,
  gp = gpar(),
  gpText = gpar(),
  gpAxis = gpar(),
  axes = FALSE,
  speedup = 1,
  size = 5,
  cols = NULL,
  col = NULL,
  zoomExtent = NULL,
  visualSqueeze = NULL,
  legend = TRUE,
  legendRange = NULL,
  legendText = NULL,
  pch = 19,
  title = NULL,
  na.color = "#FFFFFF00",
  zero.color = NULL,
  length = NULL,
  arr = NULL,
  plotFn = "plot",
  verbose = getOption("quickPlot.verbose")
)

## S4 method for signature 'ANY'
Plot(
  ...,
  new = FALSE,
  addTo = NULL,
  gp = gpar(),
  gpText = gpar(),
  gpAxis = gpar(),
  axes = FALSE,
  speedup = 1,
  size = 5,
  cols = NULL,
  col = NULL,
  zoomExtent = NULL,
  visualSqueeze = NULL,
  legend = TRUE,
  legendRange = NULL,
  legendText = NULL,
  pch = 19,
  title = NULL,
  na.color = "#FFFFFF00",
  zero.color = NULL,
  length = NULL,
  arr = NULL,
  plotFn = "plot",
  verbose = getOption("quickPlot.verbose")
)

rePlot(
  toDev = dev.cur(),
  fromDev = dev.cur(),
  clearFirst = TRUE,
  ...,
  verbose = getOption("quickPlot.verbose")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Plot_+3A_...">...</code></td>
<td>
<p>A combination of <code>spatialObjects</code> or non-spatial objects.
For many object classes, there are specific <code>Plot</code> methods. Where
there are no specific ones, the base plotting will be used internally.
This means that for objects with no specific <code>Plot</code> methods,
many arguments, such as <code>addTo</code>, will not work.
See details.</p>
</td></tr>
<tr><td><code id="Plot_+3A_new">new</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then the previous named plot area is wiped
and a new one made; if <code>FALSE</code>, then the <code>...</code> plots will be
added to the current device, adding or rearranging the plot layout
as necessary. Default is <code>FALSE</code>. This currently works best if
there is only one object being plotted in a given <code>Plot</code> call. However,
it is possible to pass a list of logicals to this, matching the
length of the <code>...</code> objects. Use <code>clearPlot</code> to clear the whole
plotting device. NOTE if <code>TRUE</code>: <em>Everything that was there,
including the legend and the end points of the colour palette, will
be removed and re-initiated</em>.</p>
</td></tr>
<tr><td><code id="Plot_+3A_addto">addTo</code></td>
<td>
<p>Character vector, with same length as <code>...</code>.
This is for overplotting, when the overplot is not to occur on
the plot with the same name, such as plotting a
<code style="white-space: pre;">&#8288;SpatialPoints*&#8288;</code> object on a <code>RasterLayer</code>.</p>
</td></tr>
<tr><td><code id="Plot_+3A_gp">gp</code></td>
<td>
<p>A <code>gpar</code> object, created by <code><a href="#topic+gpar">gpar()</a></code>,
to change plotting parameters (see <span class="pkg">grid</span> package).</p>
</td></tr>
<tr><td><code id="Plot_+3A_gptext">gpText</code></td>
<td>
<p>A <code>gpar</code> object for the title text.
Default <code>gpar(col = "black")</code>.</p>
</td></tr>
<tr><td><code id="Plot_+3A_gpaxis">gpAxis</code></td>
<td>
<p>A <code>gpar</code> object for the axes.
Default <code>gpar(col = "black")</code>.</p>
</td></tr>
<tr><td><code id="Plot_+3A_axes">axes</code></td>
<td>
<p>Logical or <code>"L"</code>, representing the left and bottom axes, over all plots.</p>
</td></tr>
<tr><td><code id="Plot_+3A_speedup">speedup</code></td>
<td>
<p>Numeric. The factor by which the number of pixels is divided
by to plot rasters. See Details.</p>
</td></tr>
<tr><td><code id="Plot_+3A_size">size</code></td>
<td>
<p>Numeric. The size, in points, for <code>SpatialPoints</code> symbols,
if using a scalable symbol.</p>
</td></tr>
<tr><td><code id="Plot_+3A_cols">cols</code></td>
<td>
<p>(also <code>col</code>) Character vector or list of character vectors of colours.
See details.</p>
</td></tr>
<tr><td><code id="Plot_+3A_col">col</code></td>
<td>
<p>(also <code>cols</code>) Alternative to <code>cols</code> to be consistent with <code>plot</code>.
<code>cols</code> takes precedence, if both are provided.</p>
</td></tr>
<tr><td><code id="Plot_+3A_zoomextent">zoomExtent</code></td>
<td>
<p>An <code>Extent</code> object. Supplying a single extent that is
smaller than the rasters will call a crop statement before
plotting. Defaults to <code>NULL</code>.
This occurs after any downsampling of rasters, so it may
produce very pixelated maps.</p>
</td></tr>
<tr><td><code id="Plot_+3A_visualsqueeze">visualSqueeze</code></td>
<td>
<p>Numeric. The proportion of the white space to be used
for plots. Default is 0.75.</p>
</td></tr>
<tr><td><code id="Plot_+3A_legend">legend</code></td>
<td>
<p>Logical indicating whether a legend should be drawn.
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="Plot_+3A_legendrange">legendRange</code></td>
<td>
<p>Numeric vector giving values that, representing the lower
and upper bounds of a legend (i.e., <code>1:10</code> or
<code>c(1,10)</code> will give same result) that will override
the data bounds contained within the <code>grobToPlot</code>.</p>
</td></tr>
<tr><td><code id="Plot_+3A_legendtext">legendText</code></td>
<td>
<p>Character vector of legend value labels.
Defaults to <code>NULL</code>, which results in a pretty numeric
representation.
If <code style="white-space: pre;">&#8288;Raster*&#8288;</code> has a Raster Attribute Table (<code>rat</code>;
see <span class="pkg">raster</span> package), this will be used by default.
Currently, only a single vector is accepted.
The length of this must match the length of the legend, so
this is mostly useful for discrete-valued rasters.</p>
</td></tr>
<tr><td><code id="Plot_+3A_pch">pch</code></td>
<td>
<p>see <code>?par</code>.</p>
</td></tr>
<tr><td><code id="Plot_+3A_title">title</code></td>
<td>
<p>Logical or character string. If logical, it
indicates whether to print the object name as the title
above the plot. If a character string, it will print this
above the plot. NOTE: the object name is used with <code>addTo</code>,
not the title. Default NULL, which means print the object
name as title, if no other already exists on the plot, in
which case, keep the previous title.</p>
</td></tr>
<tr><td><code id="Plot_+3A_na.color">na.color</code></td>
<td>
<p>Character string indicating the colour for <code>NA</code> values.
Default transparent.</p>
</td></tr>
<tr><td><code id="Plot_+3A_zero.color">zero.color</code></td>
<td>
<p>Character string indicating the colour for zero values,
when zero is the minimum value, otherwise, zero is
treated as any other colour. Default transparent.</p>
</td></tr>
<tr><td><code id="Plot_+3A_length">length</code></td>
<td>
<p>Numeric. Optional length, in inches, of the arrow head.</p>
</td></tr>
<tr><td><code id="Plot_+3A_arr">arr</code></td>
<td>
<p>A vector of length 2 indicating a desired arrangement of plot
areas indicating number of rows, number of columns.
Default NULL, meaning
let Plot function do it automatically.</p>
</td></tr>
<tr><td><code id="Plot_+3A_plotfn">plotFn</code></td>
<td>
<p>An optional function name to do the plotting internally, e.g.,
&quot;barplot&quot; to get a barplot() call. Default &quot;plot&quot;.</p>
</td></tr>
<tr><td><code id="Plot_+3A_verbose">verbose</code></td>
<td>
<p>Numeric or logical. If <code>TRUE</code> or <code style="white-space: pre;">&#8288;&gt;0&#8288;</code>, then messages will be
shown. If <code>FALSE</code> or <code>0</code>, most messages will be suppressed.</p>
</td></tr>
<tr><td><code id="Plot_+3A_todev">toDev</code></td>
<td>
<p>Numeric. Which device should the new replot be plotted to.
Default is current device.</p>
</td></tr>
<tr><td><code id="Plot_+3A_fromdev">fromDev</code></td>
<td>
<p>Numeric. Which device should the replot information be taken from.
Default is current device</p>
</td></tr>
<tr><td><code id="Plot_+3A_clearfirst">clearFirst</code></td>
<td>
<p>Logical. Should <code>clearPlot</code> be run before replotting. Default TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>NOTE:</strong> Plot uses the <span class="pkg">grid</span> package; therefore, it is NOT compatible
with base R graphics. Also, because it does not by default wipe the plotting device
before plotting, a call to <code><a href="#topic+clearPlot">clearPlot()</a></code> is helpful to resolve
many errors. Careful use of the other device tools, such as <code>dev.off()</code> and
<code>dev.list()</code> might also clear problems that may arise.
</p>
<p>If <code>new = TRUE</code>, a new plot will be generated, but only in the figure region that
has the same name as the object being plotted.
This is different than calling <code style="white-space: pre;">&#8288;clearPlot(); Plot(Object)&#8288;</code>,
i.e,. directly before creating a new Plot. <code>clearPlot()</code> will clear the entire
plotting device.
When <code>new = FALSE</code>, any plot that already exists will be overplotted,
while plots that have not already been plotted will be added.
This function rearranges the plotting device to maximize the size of all the
plots, minimizing white space.
If using the RStudio IDE, it is recommended to make and use a new device
with <code>dev()</code>, because the built in device is not made for rapid redrawing.
The function is based on the grid package.
</p>
<p>Each panel in the multipanel plot must have a name.
This name is used to overplot, rearrange the plots, or overlay using
<code>addTo</code> when necessary.
If the <code>...</code> are named <code>spatialObjects</code>, then <code>Plot</code> will use
these names. However, this name will not persist when there is a future call
to <code>Plot</code> that forces a rearrangement of the plots.
A more stable way is to use the object names directly, and any layer names
(in the case of <code>RasterLayer</code> or <code>RasterStack</code> objects).
If plotting a <code>RasterLayer</code> and the layer name is &quot;layer&quot; or the same as the
object name, then, for simplicity, only the object name will be used.
In other words, only enough information is used to uniquely identify the plot.
</p>
<p>For modularity, <code>Plot</code> must have access to the original objects that were plotted.
These objects will be used if a subsequent Plot event forces a rearrangement of the plot device.
Rather than saving all the plot information (including the data) at each <code>Plot</code> call
(this is generally too much data to constantly make copies),
the function saves a pointer to the original R object. If the plot needs
to be rearranged because of a future addition, then <code>Plot</code> will search for that
original object that created the first plots, and replot them.
This has several consequences.
First, that object must still exist and in the same environment.
Second, if that object has changed between the first time it is plot and any
subsequent time it is replotted (via a forced rearrangement), then it will take
the object <em>as it exists</em>, not as it existed. Third, if passing a named list
of objects, Plot will either create a link to objects with those names in the
calling environment (e.g., <code>.GlobalEnv</code>) or, if they do not exist, then <code>Plot</code>
will make a copy in the hidden <code>.quickPlotEnv</code> for later reuse.
</p>
<p><code>cols</code> is a vector of colours that can be understood directly, or by
<code><a href="grDevices.html#topic+colorRamp">colorRampPalette()</a></code>, such as <code>c("orange", "blue")</code>,
will give a colour range from orange to blue, interpolated.
If a list, it will be used, in order, for each item to be plotted.
It will be recycled if it is shorter than the objects to be plotted.
Note that when this approach to setting colours is used, any overplotting
will revert to the <code>colortable</code> slot of the object, or the default
for rasters, which is <code>terrain.color()</code>
</p>
<p><code>cols</code> can also accept <code>RColorBrewer</code> colours by keyword if it is
character vector of length 1. i.e., this cannot be used to set many objects by keyword in
the same Plot call. Default <code>terrain.color()</code>. See Details.
</p>
<p>Some colouring will be automatic. If the object being plotted is a Raster, then
this will take the <code>colorTable</code> slot (can be changed via <code>setColors()</code> or other ways).
If this is a <code>SpatialPointsDataFrame</code>, this function will use a column called <code>colors</code>
and apply these to the symbols.
</p>
<p>For <code>SpatialPolygons</code>, <code>cols</code> can accept <code>RColorBrewer</code> colours by keyword as a
character vector of length 1. For more control, pass a vector of colours to <code>cols</code> or
to <code>gp = gpar(fill = vectorOfColours)</code>.
In this second approach, the length of the <code>vectorOfColours</code> can be either less then or equal
to the number of polygons in the <code>SpatialPolygons</code> object &ndash; each polygon within
a <code>Polygons</code> object will share the same colour &ndash; or it can be greater than this number
to give a different colour to each <code>Polygon</code> (of which there can be MANY more than
<code>Polygons</code>. <code>Plot</code> will recycle these colours if there are not enough. The order
provided will be the order assigned to each <code>Polygons</code> or <code>Polygon</code> object.
</p>
<p>Silently, one hidden object is made, <code>.quickPlot</code> in the
<code>.quickPlotEnv</code> environment, which is used for arranging plots in the
device window, and identifying the objects to be replotted if rearranging
is required, subsequent to a <code>new = FALSE</code> additional plot.
</p>
<p>This function is optimized to allow modular Plotting.
This means that several behaviours will appear unusual.
For instance, if a first call to <code>Plot</code> is made, the legend will reflect
the current colour scheme. If a second or subsequent call to <code>Plot</code> is
made with the same object but with different colours (e.g., with <code>cols</code>),
the legend will not update. This behaviour is made with the decision that the
original layer takes precedence and all subsequent plots to that same frame
are over-plots only.
</p>
<p><code>speedup</code> is not a precise number because it is faster to plot an
non-resampled raster if the new resampling is close to the original number of
pixels.
At the moment, for rasters, this is set to 1/3 of the original pixels.
In other words, <code>speedup</code> will not do anything if the factor for
speeding up is not high enough (i.e., &gt;3). If no sub-sampling is desired,
use a speedup value less than 0.1.
</p>
<p>These <code style="white-space: pre;">&#8288;gp*&#8288;</code> parameters will specify plot parameters that are available
with <code>gpar()</code>. <code>gp</code> will adjust plot parameters, <code>gpText</code>
will adjust title and legend text, <code>gpAxis</code> will adjust the axes.
<code>size</code> adjusts point size in a <code>SpatialPoints</code> object.
These will persist with the original <code>Plot</code> call for each individual object.
Multiple entries can be used, but they must be named list elements and they
must match the <code>...</code> items to plot.
This is true for a <code>RasterStack</code> also, i.e., the list of named elements
must be the same length as the number of layers being plotted.
The naming convention used is: <code>RasterStackName$layerName</code>, i.e,
<code>landscape$DEM</code>.
</p>


<h3>Value</h3>

<p>Invisibly returns the <code>.quickPlot</code> class object.
If this is assigned to an object, say <code>obj</code>, then this can be plotted
again with <code>Plot(obj)</code>.
This object is also stored in the locked <code>.quickPlotEnv</code>, so can simply be
replotted with <code>rePlot()</code> or on a new device with <code>rePlot(n)</code>,
where <code>n</code> is the new device number.
</p>


<h3>Author(s)</h3>

<p>Eliot McIntire
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clearPlot">clearPlot()</a></code>, <code><a href="#topic+rePlot">rePlot()</a></code>, <code><a href="#topic+gpar">gpar()</a></code>, <code>raster::raster()</code>,
<code><a href="graphics.html#topic+par">par()</a></code>, <code>sp::SpatialPolygons()</code>, <code><a href="grid.html#topic+grid.polyline">grid.polyline()</a></code>,
<code>ggplot2::ggplot()</code>, <code><a href="#topic+dev">dev()</a></code>, <code>terra::vect()</code>, <code>terra::rast()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("RColorBrewer") &amp;&amp; interactive()) {
  library(terra)

  files &lt;- dir(system.file("maps", package = "quickPlot"), full.names = TRUE, pattern = "tif")
  maps &lt;- lapply(files, rast)
  names(maps) &lt;- lapply(maps, names)

  # put layers into a single stack for convenience
  landscape &lt;- rast(maps)

  # can change color palette
  setColors(landscape, n = 50) &lt;-
    list(DEM = topo.colors(50),
         forestCover = RColorBrewer::brewer.pal(9, "Set1"),
         forestAge = RColorBrewer::brewer.pal("Blues", n = 8),
         habitatQuality = RColorBrewer::brewer.pal(9, "Spectral"),
         percentPine = RColorBrewer::brewer.pal("GnBu", n = 8))

  # Make a new raster derived from a previous one; must give it a unique name
  habitatQuality2 &lt;- landscape$habitatQuality ^ 0.3
  names(habitatQuality2) &lt;- "habitatQuality2"

  # make a SpatialPoints object
  caribou &lt;- terra::vect(cbind(x = stats::runif(1e2, -50, 50),
                               y = stats::runif(1e2, -50, 50)))

  # use factor raster to give legends as character strings
  ras &lt;- rast(ext(0, 3, 0, 4), vals = sample(1:4, size = 12, replace = TRUE), res = 1)

  # needs to have a data.frame with ID as first column - see ?raster::ratify
  levels(ras) &lt;- data.frame(ID = 1:4, Name = paste0("Level", 1:4))
  Plot(ras, new = TRUE)

  # Arbitrary values for factors, including zero and not all levels represented in raster
  levs &lt;- c(0:5, 7:12)
  ras &lt;- rast(ext(0, 3, 0, 2), vals = c(1, 1, 3, 5, 8, 9), res = 1)
  levels(ras) &lt;- data.frame(ID = levs, Name = LETTERS[c(1:3, 8:16)])
  Plot(ras, new = TRUE)

  # Arbitrary values for factors, including zero and not all levels represented in raster
  levs &lt;- c(0:5, 7:23)
  ras &lt;- rast(ext(0, 3, 0, 2), vals = c(1, 1, 3, 5, 8, 9), res = 1)
  levels(ras) &lt;- data.frame(ID = levs, Name = LETTERS[1:23])
  Plot(ras, new = TRUE)

  # SpatialPolygons
  sr1 &lt;- cbind(object = 1, cbind(c(2, 4, 4, 1, 2), c(2, 3, 5, 4, 2)) * 20 - 50)
  sr2 &lt;- cbind(object = 2, cbind(c(5, 4, 2, 5), c(2, 3, 2, 2)) * 20 - 50)
  spP &lt;- vect(rbind(sr1, sr2))

  clearPlot()
  Plot(ras)

  clearPlot()
  Plot(landscape)

  # Can overplot, using addTo
  Plot(caribou, addTo = "landscape$forestAge", size = 4, axes = FALSE)

  # can add a plot to the plotting window
  Plot(caribou, new = FALSE)

  # Can add two maps with same name, if one is in a stack; they are given
  #  unique names based on object name
  Plot(landscape, caribou, maps$DEM)

  # can mix SpatRaster, SpatVector, RasterStack, RasterLayer, Spatial*
  Plot(landscape, habitatQuality2, caribou)

  # can mix stacks, rasters, SpatialPoint*, and SpatialPolygons*
  Plot(landscape, caribou)
  Plot(habitatQuality2, new = FALSE)
  Plot(spP)
  Plot(spP, addTo = "landscape$forestCover", gp = gpar(lwd = 2))

  # provide manual arrangement, NumRow, NumCol
  Plot(landscape, spP, arr = c(2, 5), new = TRUE)

  # example base plot
  clearPlot()
  Plot(1:10, 1:10, addTo = "test", new = TRUE) # if there is no "test" then it will make it
  Plot(4, 5, pch = 22, col = "blue", addTo = "test")
  obj1 &lt;- rnorm(1e2)
  Plot(obj1, axes = "L")

  # Can plot named lists of objects (but not base objects yet)
  ras1 &lt;- ras2 &lt;- ras
  a &lt;- list()
  for (i in 1:2) {
    a[[paste0("ras", i)]] &lt;- get(paste0("ras", i))
  }
  a$spP &lt;- spP
  clearPlot()
  Plot(a)

  # Now all together
  Plot(obj1, title = "scatterplot")
  Plot(landscape)

  # do with sf --&gt; these will add to previous plots
  if (requireNamespace("sf", quietly = TRUE)) {
    caribouSF &lt;- sf::st_as_sf(caribou)
    Plot(caribouSF, axes = "L")
    Plot(caribouSF, addTo = "landscape$percentPine") # overlay on a specific plot
  }

  # clean up
  clearPlot()

}
</code></pre>

<hr>
<h2 id='quickPlotClasses'><code>quickPlot</code> classes</h2><span id='topic+quickPlotClasses'></span>

<h3>Description</h3>

<p><code>quickPlot</code> uses S4 classes.
&quot;Dot&quot; classes are not exported and are therefore intended for internal use only.
</p>


<h3>Plotting classes - used within <code>Plot</code></h3>


<table>
<tr>
 <td style="text-align: left;">
<strong>New classes</strong></td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+.arrangement">.arrangement()</a></code> </td><td style="text-align: left;"> The layout or "arrangement" of plot objects</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+.quickPlot">.quickPlot()</a></code> </td><td style="text-align: left;"> Main class for <code>Plot</code> - contains <code>.quickGrob</code>
and <code>.arrangement</code> objects</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+.quickPlotGrob">.quickPlotGrob()</a></code> </td><td style="text-align: left;"> GRaphical OBject used by <code>quickPlot</code> - smallest unit</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<table>
<tr>
 <td style="text-align: left;">
<strong>Unions of existing classes:</strong></td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>.quickPlottables</code> </td><td style="text-align: left;"> The union of all object classes Plot can accept</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>.quickPlotObjects</code> </td><td style="text-align: left;"> The union of <code>spatialObjects</code> and several others</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Eliot McIntire and Alex Chubaty
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Plot">Plot()</a></code>
</p>

<hr>
<h2 id='sample-maps'>Dummy maps included with <code>quickPlot</code></h2><span id='topic+sample-maps'></span>

<h3>Description</h3>

<p>All maps included here are randomly generated maps created using
<code>SpaDES.tools::gaussMap()</code>.
These are located within the <code>maps</code> folder of the package, and are used
in the vignettes.
Use <code>system.file("maps", package = "quickPlot")</code> to locate the &lsquo;<span class="file">maps/</span>&rsquo;
directory on your system.
</p>


<h3>Format</h3>

<p>raster
</p>


<h3>Details</h3>


<ul>
<li> <p><code>DEM.tif</code>: converted to a a small number of discrete levels
(in 100m hypothetical units).
</p>
</li>
<li> <p><code>habitatQuality.tif</code>: made to look like a continuous habitat surface,
rescaled to 0 to 1.
</p>
</li>
<li> <p><code>forestAge.tif</code>: rescaled to possible forest ages in a boreal forest setting.
</p>
</li>
<li> <p><code>forestCover.tif</code>: rescaled to possible forest cover in a boreal forest setting.
</p>
</li>
<li> <p><code>percentPine.tif</code>: rescaled to percentages.
</p>
</li></ul>


<hr>
<h2 id='sp2sl'>Convert pairs of coordinates to <code>SpatialLines</code></h2><span id='topic+sp2sl'></span>

<h3>Description</h3>

<p>This will convert 2 objects whose coordinates can be extracted with <code>coordinates</code>
(e.g., <code style="white-space: pre;">&#8288;sp::SpatialPoints*&#8288;</code>) to a single <code>SpatialLines</code> object.
The first object is treated as the &quot;to&quot; (destination), and the second object the &quot;from&quot; (source).
This can be used to represent directional <code>SpatialLines</code>, especially with with arrow heads,
as in <code>Plot(sl, length = 0.1)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sp2sl(sp1, from)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sp2sl_+3A_sp1">sp1</code></td>
<td>
<p>a <code style="white-space: pre;">&#8288;SpatialPoints*&#8288;</code> object</p>
</td></tr>
<tr><td><code id="sp2sl_+3A_from">from</code></td>
<td>
<p>a <code style="white-space: pre;">&#8288;SpatialPoints*&#8288;</code> object. Optional. If not provided, then the function will
attempt to find the &quot;previous&quot; coordinates as columns (<code>prevX</code>, <code>prevY</code>)
in the <code>sp1</code> object.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>caribou &lt;- terra::vect(x = cbind(x = stats::runif(1e1, -50, 50),
                                        y = stats::runif(1e1, -50, 50)))
caribouFrom &lt;- terra::vect(x = cbind(x = stats::runif(1e1, -50, 50),
                                        y = stats::runif(1e1, -50, 50)))
caribouLines &lt;- sp2sl(caribou, caribouFrom)
if (interactive()) {
  clearPlot()
  Plot(caribouLines, length = 0.1)
}
</code></pre>

<hr>
<h2 id='thin'>Thin a polygon using <code>fastshp::thin</code></h2><span id='topic+thin'></span><span id='topic+thnSpatialPolygons'></span><span id='topic+thin.default'></span>

<h3>Description</h3>

<p>For visualizing, it is sometimes useful to remove points in <code style="white-space: pre;">&#8288;Spatial*&#8288;</code> objects.
This will change the geometry, so it is not recommended for computation.
This is similar to <code>sf::st_simplify</code>,
but faster (see examples) for large shapefiles, particularly if
<code>returnDataFrame</code> is <code>TRUE</code>.
<em><code>thin</code> will not attempt to preserve topology.</em>
It is strictly for making smaller polygons for the (likely) purpose of visualizing more quickly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thin(
  x,
  tolerance,
  returnDataFrame,
  minCoordsToThin,
  ...,
  verbose = getOption("quickPlot.verbose")
)

thnSpatialPolygons(
  x,
  tolerance = NULL,
  returnDataFrame = FALSE,
  minCoordsToThin = 1e+05,
  maxNumPolygons = getOption("quickPlot.maxNumPolygons", 3000),
  ...,
  verbose = getOption("quickPlot.verbose")
)

## Default S3 method:
thin(
  x,
  tolerance,
  returnDataFrame,
  minCoordsToThin,
  maxNumPolygons,
  ...,
  verbose = getOption("quickPlot.verbose")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="thin_+3A_x">x</code></td>
<td>
<p>A <code style="white-space: pre;">&#8288;Spatial*&#8288;</code> object</p>
</td></tr>
<tr><td><code id="thin_+3A_tolerance">tolerance</code></td>
<td>
<p>Maximum allowable distance for a point to be removed.</p>
</td></tr>
<tr><td><code id="thin_+3A_returndataframe">returnDataFrame</code></td>
<td>
<p>If <code>TRUE</code>, this will return a list of 3 elements,
<code>xyOrd</code>, <code>hole</code>, and <code>idLength</code>.
If <code>FALSE</code> (default), it will return a <code>SpatialPolygons</code> object.</p>
</td></tr>
<tr><td><code id="thin_+3A_mincoordstothin">minCoordsToThin</code></td>
<td>
<p>If the number of coordinates is smaller than this number,
then thin will just pass through, though it will take the time required to
calculate how many points there are (which is not <code>NROW(coordinates(x))</code> for
a <code>SpatialPolygon</code>)</p>
</td></tr>
<tr><td><code id="thin_+3A_...">...</code></td>
<td>
<p>Passed to methods (e.g., <code>maxNumPolygons</code>)</p>
</td></tr>
<tr><td><code id="thin_+3A_verbose">verbose</code></td>
<td>
<p>Numeric or logical. If <code>TRUE</code> or <code style="white-space: pre;">&#8288;&gt;0&#8288;</code>, then messages will be
shown. If <code>FALSE</code> or <code>0</code>, most messages will be suppressed.</p>
</td></tr>
<tr><td><code id="thin_+3A_maxnumpolygons">maxNumPolygons</code></td>
<td>
<p>For speed, <code>thin</code> can also simply remove some of the
polygons. This is likely only a reasonable thing to do if there are
a lot of polygons being plotted in a small space. Current default is
taken from <code>options('quickPlot.maxNumPolygons')</code>, with a message.</p>
</td></tr>
</table>

<hr>
<h2 id='whereInStack'>Find the environment in the call stack that contains an object by name</h2><span id='topic+whereInStack'></span>

<h3>Description</h3>

<p>This is similar to <code>pryr::where</code>, except instead of working up the search() path
of packages, it searches up the call stack for an object. Ostensibly similar
to <code>base::dynGet</code>, but it will only return the environment, not the object
itself and it will try to extract just the object name from <code>name</code>,
even if supplied with a more complicated name
(e.g., if <code>obj$firstElement@slot1$size</code> is
supplied, the function will only search for obj). The function is fairly fast.
This function is an important component to the <code>Plot</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>whereInStack(name, whFrame = -1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="whereInStack_+3A_name">name</code></td>
<td>
<p>An object name to find in the call stack</p>
</td></tr>
<tr><td><code id="whereInStack_+3A_whframe">whFrame</code></td>
<td>
<p>A numeric indicating which <code>sys.frame</code> (by negative number) to start searching in.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The difference between this and what <code>get</code> and <code>exists</code> do, is that these other
functions
search up the enclosing environments, i.e., it matters where the functions were defined.
<code>whereInStack</code> looks up the call stack environments. See the example for the difference.
</p>


<h3>Value</h3>

<p>The environment that is in the call stack where the object exists, that is closest to the
frame in which this function is called.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>b &lt;- 1
inner &lt;- function(y) {
  objEnv &lt;- whereInStack("b")
  get("b", envir = objEnv)
}
findB &lt;- function(x) {
  b &lt;- 2
  inner()
}
findB() # Finds 2 because it is looking up the call stack, i.e., the user's perspective

# defined outside of findB2, so its enclosing environment is the same as findB2
innerGet &lt;- function(y) {
   get("b")
}
findB2 &lt;- function(x) {
  b &lt;- 2
  innerGet()
}
findB2() # Finds 1 because b has a value of 1 in the enclosing environment of innerGet
b &lt;- 3
findB2() # Finds 3 because b has a value of 3 in the enclosing environment of innerGet,
         #  i.e., the environment in which innerGet was defined
findB() # Still finds 2 because the call stack hasn't changed

# compare base::dynGet
findB3 &lt;- function(x) {
  b &lt;- 2
  dynGet("b")
}
findB3() # same as findB(), but marginally faster, because it omits the stripping on
         #   sub elements that may be part of the name argument


b &lt;- list()
findB3 &lt;- function(x) {
  b$a &lt;- 2
  dynGet("b$a")
}
testthat::expect_error(findB3()) # fails because not an object name

findB &lt;- function(x) {
  b$a &lt;- 2
  env &lt;- whereInStack("b$a")
  env
}
findB() # finds it

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
