<!DOCTYPE html><html lang="en-US"><head><title>Help for package rlemon</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rlemon}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AllPairsMinCut'><p>Solver for All-Pairs MinCut</p></a></li>
<li><a href='#CountBiEdgeConnectedComponents'><p>Count Number of Bi-Edge-Connected Components</p></a></li>
<li><a href='#CountBiNodeConnectedComponents'><p>Count Number of Bi-Node-Connected Components</p></a></li>
<li><a href='#CountConnectedComponents'><p>Count the Number of Connected Components</p></a></li>
<li><a href='#CountStronglyConnectedComponents'><p>Count the Number of Strongly Connected Components</p></a></li>
<li><a href='#FindBiEdgeConnectedComponents'><p>Find Bi-Edge-Connected Components</p></a></li>
<li><a href='#FindBiEdgeConnectedCutEdges'><p>Find Bi-Edge-Connected Cut Edges</p></a></li>
<li><a href='#FindBiNodeConnectedComponents'><p>Find Bi-Node-Connected Components</p></a></li>
<li><a href='#FindBiNodeConnectedCutNodes'><p>Find Bi-Node-Connected Cut Nodes</p></a></li>
<li><a href='#FindConnectedComponents'><p>Find Connected Components</p></a></li>
<li><a href='#FindStronglyConnectedComponents'><p>Find Strongly Connected Components</p></a></li>
<li><a href='#FindStronglyConnectedCutArcs'><p>Find Strongly Connected Cut Arcs</p></a></li>
<li><a href='#GetAndCheckTopologicalSort'><p>Check if Graph is DAG, then Sorts Nodes into Topological Order</p></a></li>
<li><a href='#GetBipartitePartitions'><p>Obtains (if possible) Bipartite Split</p></a></li>
<li><a href='#GetTopologicalSort'><p>Sorts Nodes into Topological Order</p></a></li>
<li><a href='#GraphSearch'><p>Solver for Graph Search</p></a></li>
<li><a href='#GrossoLocatelliPullanMcRunner'><p>LEMON runners</p></a></li>
<li><a href='#IsAcyclic'><p>Check if Graph is Acyclic.</p></a></li>
<li><a href='#IsBiEdgeConnected'><p>Chcek if Graph is Bi-Edge-Connected</p></a></li>
<li><a href='#IsBiNodeConnected'><p>Checks if Graph is Bi-Node-Connected</p></a></li>
<li><a href='#IsBipartite'><p>Checks if Graph is Bipartite</p></a></li>
<li><a href='#IsConnected'><p>Check if Graph is Connected</p></a></li>
<li><a href='#IsDAG'><p>Check if Graph is a DAG.</p></a></li>
<li><a href='#IsEulerian'><p>Check if Graph is Eulerian</p></a></li>
<li><a href='#IsLoopFree'><p>Checks if Graph is Loop Free</p></a></li>
<li><a href='#IsParallelFree'><p>Check if Graph is Parallel Free</p></a></li>
<li><a href='#IsSimpleGraph'><p>Check if Graph is Simple</p></a></li>
<li><a href='#IsStronglyConnected'><p>Check if Graph is Strongly Connected</p></a></li>
<li><a href='#IsTree'><p>Check if Graph is a Tree</p></a></li>
<li><a href='#MaxCardinalityMatching'><p>Solve for Maximum Cardinality Matching</p></a></li>
<li><a href='#MaxCardinalitySearch'><p>Solver for Max Cardinality Search</p></a></li>
<li><a href='#MaxClique'><p>Solver for Largest Complete Subgroup (All Nodes Connected)</p></a></li>
<li><a href='#MaxFlow'><p>Solver for MaxFlow</p></a></li>
<li><a href='#MaxMatching'><p>Solver for Maximum Weighted Matching</p></a></li>
<li><a href='#MinCostArborescence'><p>Solver for Minimum Cost Arborescence</p></a></li>
<li><a href='#MinCostFlow'><p>Solver for MinCostFlow</p></a></li>
<li><a href='#MinCut'><p>Solver for MinCut</p></a></li>
<li><a href='#MinMeanCycle'><p>Solver for Minimum Mean Cycle</p></a></li>
<li><a href='#MinSpanningTree'><p>Solver for Minimum Spanning Tree</p></a></li>
<li><a href='#NetworkCirculation'><p>Solver for Network Circulation</p></a></li>
<li><a href='#PlanarChecking'><p>Check if Graph is Planar</p></a></li>
<li><a href='#PlanarColoring'><p>Solver for Planar Coloring</p></a></li>
<li><a href='#PlanarDrawing'><p>Solver for Planar Drawing</p></a></li>
<li><a href='#PlanarEmbedding'><p>Solver for Planar Embedding</p></a></li>
<li><a href='#ShortestPath'><p>Solver for Shortest Path Between Two Nodes</p></a></li>
<li><a href='#ShortestPathFromSource'><p>Solve for Shortest Path from Source Node to All Other Nodes</p></a></li>
<li><a href='#small_graph_example'><p>A small network graph example</p></a></li>
<li><a href='#TravelingSalesperson'><p>Solver for Traveling Salesperson Problem</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>R Access to LEMON Graph Algorithms</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Allows easy access to the LEMON Graph Library set of algorithms, written in C++.
             See the LEMON project page at <a href="https://lemon.cs.elte.hu/trac/lemon">https://lemon.cs.elte.hu/trac/lemon</a>.
             Current LEMON version is 1.3.1.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="http://www.boost.org/LICENSE_1_0.txt">BSL-1.0</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.5)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://errickson.net/rlemon/">https://errickson.net/rlemon/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/josherrickson/rlemon/issues/">https://github.com/josherrickson/rlemon/issues/</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, covr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-02-06 15:22:32 UTC; josh</td>
</tr>
<tr>
<td>Author:</td>
<td>Arav Agarwal [aut],
  Aditya Tewari [aut],
  Josh Errickson [cre, aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Josh Errickson &lt;jerrick@umich.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-02-06 21:42:31 UTC</td>
</tr>
</table>
<hr>
<h2 id='AllPairsMinCut'>Solver for All-Pairs MinCut</h2><span id='topic+AllPairsMinCut'></span>

<h3>Description</h3>

<p>Finds the all-pairs minimum cut tree, using the Gomory-Hu algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AllPairsMinCut(
  arcSources,
  arcTargets,
  arcWeights,
  numNodes,
  algorithm = "GomoryHu"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AllPairsMinCut_+3A_arcsources">arcSources</code></td>
<td>
<p>Vector corresponding to the source nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="AllPairsMinCut_+3A_arctargets">arcTargets</code></td>
<td>
<p>Vector corresponding to the destination nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="AllPairsMinCut_+3A_arcweights">arcWeights</code></td>
<td>
<p>Vector corresponding to the weights of a graph's arcs</p>
</td></tr>
<tr><td><code id="AllPairsMinCut_+3A_numnodes">numNodes</code></td>
<td>
<p>The number of nodes in the graph</p>
</td></tr>
<tr><td><code id="AllPairsMinCut_+3A_algorithm">algorithm</code></td>
<td>
<p>Choices of algorithm include &quot;GomoryHu&quot;. &quot;GomoryHu&quot; is the
default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details on LEMON's implementation, including differences between the
algorithms, see <a href="https://lemon.cs.elte.hu/pub/doc/1.3.1/a00182.html">https://lemon.cs.elte.hu/pub/doc/1.3.1/a00182.html</a>.
</p>


<h3>Value</h3>

<p>A namedlist containing three entries: 1) &quot;predecessors&quot;: a vector of
predecessor nodes of each node in the graph, and 2) &quot;weights&quot;: a vector of
weights of the predecessor edge of each node, and 3) &quot;distances&quot;: vector
of distances from the root node to each node.
</p>

<hr>
<h2 id='CountBiEdgeConnectedComponents'>Count Number of Bi-Edge-Connected Components</h2><span id='topic+CountBiEdgeConnectedComponents'></span>

<h3>Description</h3>

<p>Counts the number of bi-edge-connected components in an undirected graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CountBiEdgeConnectedComponents(arcSources, arcTargets, numNodes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CountBiEdgeConnectedComponents_+3A_arcsources">arcSources</code></td>
<td>
<p>Vector corresponding to the source nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="CountBiEdgeConnectedComponents_+3A_arctargets">arcTargets</code></td>
<td>
<p>Vector corresponding to the destination nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="CountBiEdgeConnectedComponents_+3A_numnodes">numNodes</code></td>
<td>
<p>The number of nodes in the graph</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <a href="https://lemon.cs.elte.hu/pub/doc/1.3.1/a00616.html#ga4d5db78dc21099d075c3967484990954">https://lemon.cs.elte.hu/pub/doc/1.3.1/a00616.html#ga4d5db78dc21099d075c3967484990954</a>
for more information.
</p>


<h3>Value</h3>

<p>An integer defining the number of bi-edge-connected components
</p>

<hr>
<h2 id='CountBiNodeConnectedComponents'>Count Number of Bi-Node-Connected Components</h2><span id='topic+CountBiNodeConnectedComponents'></span>

<h3>Description</h3>

<p>Counts the number of bi-node-connected components in an undirected graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CountBiNodeConnectedComponents(arcSources, arcTargets, numNodes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CountBiNodeConnectedComponents_+3A_arcsources">arcSources</code></td>
<td>
<p>Vector corresponding to the source nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="CountBiNodeConnectedComponents_+3A_arctargets">arcTargets</code></td>
<td>
<p>Vector corresponding to the destination nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="CountBiNodeConnectedComponents_+3A_numnodes">numNodes</code></td>
<td>
<p>The number of nodes in the graph</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <a href="https://lemon.cs.elte.hu/pub/doc/1.3.1/a00616.html#gaf7c5744b2175210b8ea67897aaa27885">https://lemon.cs.elte.hu/pub/doc/1.3.1/a00616.html#gaf7c5744b2175210b8ea67897aaa27885</a>
for more information.
</p>


<h3>Value</h3>

<p>An integer defining the number of bi-node-connected components
</p>

<hr>
<h2 id='CountConnectedComponents'>Count the Number of Connected Components</h2><span id='topic+CountConnectedComponents'></span>

<h3>Description</h3>

<p>The connected components are the classes of an equivalence relation on the
nodes of an undirected graph. Two nodes are in the same class if they are
connected with a path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CountConnectedComponents(arcSources, arcTargets, numNodes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CountConnectedComponents_+3A_arcsources">arcSources</code></td>
<td>
<p>Vector corresponding to the source nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="CountConnectedComponents_+3A_arctargets">arcTargets</code></td>
<td>
<p>Vector corresponding to the destination nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="CountConnectedComponents_+3A_numnodes">numNodes</code></td>
<td>
<p>The number of nodes in the graph</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <a href="https://lemon.cs.elte.hu/pub/doc/1.3.1/a00616.html#ga33a9d9d4803cb15e83568b2526e978a5">https://lemon.cs.elte.hu/pub/doc/1.3.1/a00616.html#ga33a9d9d4803cb15e83568b2526e978a5</a>
for more information.
</p>


<h3>Value</h3>

<p>An integer defining the number of connected components
</p>

<hr>
<h2 id='CountStronglyConnectedComponents'>Count the Number of Strongly Connected Components</h2><span id='topic+CountStronglyConnectedComponents'></span>

<h3>Description</h3>

<p>The strongly connected components are the classes of an equivalence relation
on the nodes of a directed graph. Two nodes are in the same class if they
are connected with directed paths in both direction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CountStronglyConnectedComponents(arcSources, arcTargets, numNodes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CountStronglyConnectedComponents_+3A_arcsources">arcSources</code></td>
<td>
<p>Vector corresponding to the source nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="CountStronglyConnectedComponents_+3A_arctargets">arcTargets</code></td>
<td>
<p>Vector corresponding to the destination nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="CountStronglyConnectedComponents_+3A_numnodes">numNodes</code></td>
<td>
<p>The number of nodes in the graph</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <a href="https://lemon.cs.elte.hu/pub/doc/1.3.1/a00616.html#gad30bc47dfffb78234eeee903cb3766f4">https://lemon.cs.elte.hu/pub/doc/1.3.1/a00616.html#gad30bc47dfffb78234eeee903cb3766f4</a>
for more information.
</p>


<h3>Value</h3>

<p>An integer defining the number of strongly connected components
</p>

<hr>
<h2 id='FindBiEdgeConnectedComponents'>Find Bi-Edge-Connected Components</h2><span id='topic+FindBiEdgeConnectedComponents'></span>

<h3>Description</h3>

<p>The bi-edge-connected components are the classes of an equivalence relation
on the nodes of an undirected graph. Two nodes are in the same class if they
are connected with at least two edge-disjoint paths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindBiEdgeConnectedComponents(arcSources, arcTargets, numNodes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FindBiEdgeConnectedComponents_+3A_arcsources">arcSources</code></td>
<td>
<p>Vector corresponding to the source nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="FindBiEdgeConnectedComponents_+3A_arctargets">arcTargets</code></td>
<td>
<p>Vector corresponding to the destination nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="FindBiEdgeConnectedComponents_+3A_numnodes">numNodes</code></td>
<td>
<p>The number of nodes in the graph</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <a href="https://lemon.cs.elte.hu/pub/doc/1.3.1/a00616.html#ga76c1fdd1881d21677507100b7e96c983">https://lemon.cs.elte.hu/pub/doc/1.3.1/a00616.html#ga76c1fdd1881d21677507100b7e96c983</a>
for more information.
</p>


<h3>Value</h3>

<p>A vector containing the node id of each bi-edge-connected component.
</p>

<hr>
<h2 id='FindBiEdgeConnectedCutEdges'>Find Bi-Edge-Connected Cut Edges</h2><span id='topic+FindBiEdgeConnectedCutEdges'></span>

<h3>Description</h3>

<p>The bi-edge-connected components are the classes of an equivalence relation
on the nodes of an undirected graph. Two nodes are in the same class if they
are connected with at least two edge-disjoint paths. The bi-edge-connected
components are separted by the cut edges of the components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindBiEdgeConnectedCutEdges(arcSources, arcTargets, numNodes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FindBiEdgeConnectedCutEdges_+3A_arcsources">arcSources</code></td>
<td>
<p>Vector corresponding to the source nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="FindBiEdgeConnectedCutEdges_+3A_arctargets">arcTargets</code></td>
<td>
<p>Vector corresponding to the destination nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="FindBiEdgeConnectedCutEdges_+3A_numnodes">numNodes</code></td>
<td>
<p>The number of nodes in the graph</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See
<a href="https://lemon.cs.elte.hu/pub/doc/1.3.1/a00616.html#ga58d444eba448c5f1a53539bd1b69636e">https://lemon.cs.elte.hu/pub/doc/1.3.1/a00616.html#ga58d444eba448c5f1a53539bd1b69636e</a>
for more information.
</p>


<h3>Value</h3>

<p>A named list containing 1) &quot;sources&quot;: a vector of cut edge sources,
and 2) &quot;destinations&quot;: a vector of cut edge destinations.
</p>

<hr>
<h2 id='FindBiNodeConnectedComponents'>Find Bi-Node-Connected Components</h2><span id='topic+FindBiNodeConnectedComponents'></span>

<h3>Description</h3>

<p>The bi-node-connected components are the classes of an equivalence relation
on the edges of a undirected graph. Two edges are in the same class if they
are on same circle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindBiNodeConnectedComponents(arcSources, arcTargets, numNodes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FindBiNodeConnectedComponents_+3A_arcsources">arcSources</code></td>
<td>
<p>Vector corresponding to the source nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="FindBiNodeConnectedComponents_+3A_arctargets">arcTargets</code></td>
<td>
<p>Vector corresponding to the destination nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="FindBiNodeConnectedComponents_+3A_numnodes">numNodes</code></td>
<td>
<p>The number of nodes in the graph</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <a href="https://lemon.cs.elte.hu/pub/doc/1.3.1/a00616.html#ga9d70526ab54e10b4b6fe3762af8675dd">https://lemon.cs.elte.hu/pub/doc/1.3.1/a00616.html#ga9d70526ab54e10b4b6fe3762af8675dd</a>
for more information.
</p>


<h3>Value</h3>

<p>A vector containing the arc id of each bi-node-connected component
</p>

<hr>
<h2 id='FindBiNodeConnectedCutNodes'>Find Bi-Node-Connected Cut Nodes</h2><span id='topic+FindBiNodeConnectedCutNodes'></span>

<h3>Description</h3>

<p>The bi-node-connected components are the classes of an equivalence relation
on the edges of a undirected graph. Two edges are in the same class if they
are on same circle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindBiNodeConnectedCutNodes(arcSources, arcTargets, numNodes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FindBiNodeConnectedCutNodes_+3A_arcsources">arcSources</code></td>
<td>
<p>Vector corresponding to the source nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="FindBiNodeConnectedCutNodes_+3A_arctargets">arcTargets</code></td>
<td>
<p>Vector corresponding to the destination nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="FindBiNodeConnectedCutNodes_+3A_numnodes">numNodes</code></td>
<td>
<p>The number of nodes in the graph</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <a href="https://lemon.cs.elte.hu/pub/doc/1.3.1/a00616.html#ga31461f33a748327ea3ef2a3199ffb6c7">https://lemon.cs.elte.hu/pub/doc/1.3.1/a00616.html#ga31461f33a748327ea3ef2a3199ffb6c7</a>
for more information.
</p>


<h3>Value</h3>

<p>A vector containing the cut nodes.
</p>

<hr>
<h2 id='FindConnectedComponents'>Find Connected Components</h2><span id='topic+FindConnectedComponents'></span>

<h3>Description</h3>

<p>The connected components are the classes of an equivalence relation on the
nodes of an undirected graph. Two nodes are in the same class if they are
connected with a path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindConnectedComponents(arcSources, arcTargets, numNodes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FindConnectedComponents_+3A_arcsources">arcSources</code></td>
<td>
<p>Vector corresponding to the source nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="FindConnectedComponents_+3A_arctargets">arcTargets</code></td>
<td>
<p>Vector corresponding to the destination nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="FindConnectedComponents_+3A_numnodes">numNodes</code></td>
<td>
<p>The number of nodes in the graph</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <a href="https://lemon.cs.elte.hu/pub/doc/1.3.1/a00616.html#gaa467a3e0a8c2e9e762650fd01fadff89">https://lemon.cs.elte.hu/pub/doc/1.3.1/a00616.html#gaa467a3e0a8c2e9e762650fd01fadff89</a>
for more information.
</p>


<h3>Value</h3>

<p>A vector containing the node id of each connected component.
</p>

<hr>
<h2 id='FindStronglyConnectedComponents'>Find Strongly Connected Components</h2><span id='topic+FindStronglyConnectedComponents'></span>

<h3>Description</h3>

<p>The strongly connected components are the classes of an equivalence relation
on the nodes of a directed graph. Two nodes are in the same class if they
are connected with directed paths in both direction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindStronglyConnectedComponents(arcSources, arcTargets, numNodes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FindStronglyConnectedComponents_+3A_arcsources">arcSources</code></td>
<td>
<p>Vector corresponding to the source nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="FindStronglyConnectedComponents_+3A_arctargets">arcTargets</code></td>
<td>
<p>Vector corresponding to the destination nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="FindStronglyConnectedComponents_+3A_numnodes">numNodes</code></td>
<td>
<p>The number of nodes in the graph</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <a href="https://lemon.cs.elte.hu/pub/doc/1.3.1/a00616.html#ga46f8c22f3e2989c4689faa4c46ec9436">https://lemon.cs.elte.hu/pub/doc/1.3.1/a00616.html#ga46f8c22f3e2989c4689faa4c46ec9436</a>
for more information.
</p>


<h3>Value</h3>

<p>A vector containing the node id of each strongly connected component.
</p>

<hr>
<h2 id='FindStronglyConnectedCutArcs'>Find Strongly Connected Cut Arcs</h2><span id='topic+FindStronglyConnectedCutArcs'></span>

<h3>Description</h3>

<p>The strongly connected components are the classes of an equivalence relation
on the nodes of a directed graph. Two nodes are in the same class if they
are connected with directed paths in both direction. The strongly connected
components are separated by the cut arcs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindStronglyConnectedCutArcs(arcSources, arcTargets, numNodes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FindStronglyConnectedCutArcs_+3A_arcsources">arcSources</code></td>
<td>
<p>Vector corresponding to the source nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="FindStronglyConnectedCutArcs_+3A_arctargets">arcTargets</code></td>
<td>
<p>Vector corresponding to the destination nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="FindStronglyConnectedCutArcs_+3A_numnodes">numNodes</code></td>
<td>
<p>The number of nodes in the graph</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See
<a href="https://lemon.cs.elte.hu/pub/doc/1.3.1/a00616.html#gad7af5c3a97453e37f251f0e86dbb83db">https://lemon.cs.elte.hu/pub/doc/1.3.1/a00616.html#gad7af5c3a97453e37f251f0e86dbb83db</a>
for more information.
</p>


<h3>Value</h3>

<p>A named list containing 1) &quot;sources&quot;: a vector of cut arc sources,
and 2) &quot;destinations&quot;: a vector of cut arc destinations.
</p>

<hr>
<h2 id='GetAndCheckTopologicalSort'>Check if Graph is DAG, then Sorts Nodes into Topological Order</h2><span id='topic+GetAndCheckTopologicalSort'></span>

<h3>Description</h3>

<p>Checks if a directed graph is a Direct Acyclic Graph (DAG) and returns the
topological order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetAndCheckTopologicalSort(arcSources, arcTargets, numNodes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GetAndCheckTopologicalSort_+3A_arcsources">arcSources</code></td>
<td>
<p>Vector corresponding to the source nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="GetAndCheckTopologicalSort_+3A_arctargets">arcTargets</code></td>
<td>
<p>Vector corresponding to the destination nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="GetAndCheckTopologicalSort_+3A_numnodes">numNodes</code></td>
<td>
<p>The number of nodes in the graph</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See
<a href="https://lemon.cs.elte.hu/pub/doc/1.3.1/a00616.html#gaf10c5e1630e5720c20d83cfb77dbf024">https://lemon.cs.elte.hu/pub/doc/1.3.1/a00616.html#gaf10c5e1630e5720c20d83cfb77dbf024</a>
for more information.
</p>


<h3>Value</h3>

<p>A named list containing 1) &quot;is_DAG&quot;: a <code>logical</code> stating if the
graph is a DAG, and 2) &quot;indices&quot;: a vector of length <code>numNodes</code>,
containing the index of vertex i in the ordering at location i
</p>

<hr>
<h2 id='GetBipartitePartitions'>Obtains (if possible) Bipartite Split</h2><span id='topic+GetBipartitePartitions'></span>

<h3>Description</h3>

<p>Checks if an undirected graph is bipartite and finds the bipartite
partitions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetBipartitePartitions(arcSources, arcTargets, numNodes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GetBipartitePartitions_+3A_arcsources">arcSources</code></td>
<td>
<p>Vector corresponding to the source nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="GetBipartitePartitions_+3A_arctargets">arcTargets</code></td>
<td>
<p>Vector corresponding to the destination nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="GetBipartitePartitions_+3A_numnodes">numNodes</code></td>
<td>
<p>The number of nodes in the graph</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See
<a href="https://lemon.cs.elte.hu/pub/doc/1.3.1/a00616.html#ga58ba1d00c569f0eb0deb42afca9f80bb">https://lemon.cs.elte.hu/pub/doc/1.3.1/a00616.html#ga58ba1d00c569f0eb0deb42afca9f80bb</a>
for more information.
</p>


<h3>Value</h3>

<p>A named list containing 1) &quot;is_bipartite&quot;: a <code>logical</code> stating
if the graph is bipartite, and 2) &quot;partitions&quot;: A vector of length
<code>numNodes</code>, containing the partition for each node
</p>

<hr>
<h2 id='GetTopologicalSort'>Sorts Nodes into Topological Order</h2><span id='topic+GetTopologicalSort'></span>

<h3>Description</h3>

<p>Gives back the topological order of a DAG.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetTopologicalSort(arcSources, arcTargets, numNodes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GetTopologicalSort_+3A_arcsources">arcSources</code></td>
<td>
<p>Vector corresponding to the source nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="GetTopologicalSort_+3A_arctargets">arcTargets</code></td>
<td>
<p>Vector corresponding to the destination nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="GetTopologicalSort_+3A_numnodes">numNodes</code></td>
<td>
<p>The number of nodes in the graph</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See
<a href="https://lemon.cs.elte.hu/pub/doc/1.3.1/a00616.html#gafc2cb20cf3859f157c0e12da7f310bb3">https://lemon.cs.elte.hu/pub/doc/1.3.1/a00616.html#gafc2cb20cf3859f157c0e12da7f310bb3</a>
for more information.
</p>


<h3>Value</h3>

<p>A vector of length <code>numNodes</code>, containing the index of vertex i
in the ordering at location i.
</p>

<hr>
<h2 id='GraphSearch'>Solver for Graph Search</h2><span id='topic+GraphSearch'></span>

<h3>Description</h3>

<p>Runs a common graph search algorithm to find the minimum cardinality
shortest path. Finds the shortest path from/to all vertices if a start/end
node are not given.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GraphSearch(
  arcSources,
  arcTargets,
  numNodes,
  startNode = -1,
  endNode = -1,
  algorithm = "Bfs"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GraphSearch_+3A_arcsources">arcSources</code></td>
<td>
<p>Vector corresponding to the source nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="GraphSearch_+3A_arctargets">arcTargets</code></td>
<td>
<p>Vector corresponding to the destination nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="GraphSearch_+3A_numnodes">numNodes</code></td>
<td>
<p>The number of nodes in the graph</p>
</td></tr>
<tr><td><code id="GraphSearch_+3A_startnode">startNode</code></td>
<td>
<p>Optional start node of the path</p>
</td></tr>
<tr><td><code id="GraphSearch_+3A_endnode">endNode</code></td>
<td>
<p>Optional end node of the path</p>
</td></tr>
<tr><td><code id="GraphSearch_+3A_algorithm">algorithm</code></td>
<td>
<p>Choices of algorithm include &quot;Bfs&quot; (Breadth First Search)
and &quot;Dfs&quot; (Depth First Search). Bfs is the default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details on LEMON's implementation, including differences between the
algorithms, see <a href="https://lemon.cs.elte.hu/pub/doc/1.3.1/a00608.html">https://lemon.cs.elte.hu/pub/doc/1.3.1/a00608.html</a>.
</p>


<h3>Value</h3>

<p>A named list containing three entries: 1) &quot;predecessors&quot;: the
predecessor of each vertex in its shortest path, 2) &quot;distances&quot;: the
distances from each node to the startNode, 3) &quot;node_reached&quot;: a vector of
logicals indicating whether a node was reached.
</p>

<hr>
<h2 id='GrossoLocatelliPullanMcRunner'>LEMON runners</h2><span id='topic+GrossoLocatelliPullanMcRunner'></span><span id='topic+getBipartitePartitionsRunner'></span><span id='topic+getAndCheckTopologicalSortRunner'></span><span id='topic+getTopologicalSortRunner'></span><span id='topic+IsConnectedRunner'></span><span id='topic+IsAcyclicRunner'></span><span id='topic+IsTreeRunner'></span><span id='topic+IsBipartiteRunner'></span><span id='topic+IsStronglyConnectedRunner'></span><span id='topic+IsDAGRunner'></span><span id='topic+IsBiNodeConnectedRunner'></span><span id='topic+IsBiEdgeConnectedRunner'></span><span id='topic+IsLoopFreeRunner'></span><span id='topic+IsParallelFreeRunner'></span><span id='topic+IsSimpleGraphRunner'></span><span id='topic+IsEulerianRunner'></span><span id='topic+CountBiEdgeConnectedComponentsRunner'></span><span id='topic+CountConnectedComponentsRunner'></span><span id='topic+CountBiNodeConnectedComponentsRunner'></span><span id='topic+CountStronglyConnectedComponentsRunner'></span><span id='topic+FindStronglyConnectedComponentsRunner'></span><span id='topic+FindStronglyConnectedCutArcsRunner'></span><span id='topic+FindBiEdgeConnectedCutEdgesRunner'></span><span id='topic+FindBiNodeConnectedComponentsRunner'></span><span id='topic+FindBiNodeConnectedCutNodesRunner'></span><span id='topic+FindConnectedComponentsRunner'></span><span id='topic+FindBiEdgeConnectedComponentsRunner'></span><span id='topic+GraphCompatabilityConverter'></span><span id='topic+BfsRunner'></span><span id='topic+DfsRunner'></span><span id='topic+MaxCardinalitySearchRunner'></span><span id='topic+CirculationRunner'></span><span id='topic+PreflowRunner'></span><span id='topic+EdmondsKarpRunner'></span><span id='topic+MaximumWeightPerfectMatchingRunner'></span><span id='topic+MaximumWeightFractionalPerfectMatchingRunner'></span><span id='topic+MaximumWeightFractionalMatchingRunner'></span><span id='topic+MaximumWeightMatchingRunner'></span><span id='topic+MaximumCardinalityMatchingRunner'></span><span id='topic+MaximumCardinalityFractionalMatchingRunner'></span><span id='topic+CycleCancellingRunner'></span><span id='topic+CapacityScalingRunner'></span><span id='topic+CostScalingRunner'></span><span id='topic+NetworkSimplexRunner'></span><span id='topic+NagamochiIbarakiRunner'></span><span id='topic+HaoOrlinRunner'></span><span id='topic+GomoryHuTreeRunner'></span><span id='topic+HowardMmcRunner'></span><span id='topic+KarpMmcRunner'></span><span id='topic+HartmannOrlinMmcRunner'></span><span id='topic+KruskalRunner'></span><span id='topic+MinCostArborescenceRunner'></span><span id='topic+PlanarCheckingRunner'></span><span id='topic+PlanarEmbeddingRunner'></span><span id='topic+PlanarColoringRunner'></span><span id='topic+PlanarDrawingRunner'></span><span id='topic+SuurballeRunner'></span><span id='topic+DijkstraRunner'></span><span id='topic+BellmanFordRunner'></span><span id='topic+ChristofidesRunner'></span><span id='topic+GreedyTSPRunner'></span><span id='topic+InsertionTSPRunner'></span><span id='topic+NearestNeighborTSPRunner'></span><span id='topic+Opt2TSPRunner'></span><span id='topic+lemon_runners'></span>

<h3>Description</h3>

<p>These &quot;runner&quot; functions provide a slightly lower-level access to LEMON. See
&quot;Details&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GrossoLocatelliPullanMcRunner(arcSources, arcTargets, numNodes)

getBipartitePartitionsRunner(arcSources, arcTargets, numNodes)

getAndCheckTopologicalSortRunner(arcSources, arcTargets, numNodes)

getTopologicalSortRunner(arcSources, arcTargets, numNodes)

IsConnectedRunner(arcSources, arcTargets, numNodes)

IsAcyclicRunner(arcSources, arcTargets, numNodes)

IsTreeRunner(arcSources, arcTargets, numNodes)

IsBipartiteRunner(arcSources, arcTargets, numNodes)

IsStronglyConnectedRunner(arcSources, arcTargets, numNodes)

IsDAGRunner(arcSources, arcTargets, numNodes)

IsBiNodeConnectedRunner(arcSources, arcTargets, numNodes)

IsBiEdgeConnectedRunner(arcSources, arcTargets, numNodes)

IsLoopFreeRunner(arcSources, arcTargets, numNodes)

IsParallelFreeRunner(arcSources, arcTargets, numNodes)

IsSimpleGraphRunner(arcSources, arcTargets, numNodes)

IsEulerianRunner(arcSources, arcTargets, numNodes)

CountBiEdgeConnectedComponentsRunner(arcSources, arcTargets, numNodes)

CountConnectedComponentsRunner(arcSources, arcTargets, numNodes)

CountBiNodeConnectedComponentsRunner(arcSources, arcTargets, numNodes)

CountStronglyConnectedComponentsRunner(arcSources, arcTargets, numNodes)

FindStronglyConnectedComponentsRunner(arcSources, arcTargets, numNodes)

FindStronglyConnectedCutArcsRunner(arcSources, arcTargets, numNodes)

FindBiEdgeConnectedCutEdgesRunner(arcSources, arcTargets, numNodes)

FindBiNodeConnectedComponentsRunner(arcSources, arcTargets, numNodes)

FindBiNodeConnectedCutNodesRunner(arcSources, arcTargets, numNodes)

FindConnectedComponentsRunner(arcSources, arcTargets, numNodes)

FindBiEdgeConnectedComponentsRunner(arcSources, arcTargets, numNodes)

GraphCompatabilityConverter(nodesList, arcSources, arcTargets)

BfsRunner(arcSources, arcTargets, numNodes, startNode = -1L, endNode = -1L)

DfsRunner(arcSources, arcTargets, numNodes, startNode = -1L, endNode = -1L)

MaxCardinalitySearchRunner(
  arcSources,
  arcTargets,
  arcCapacities,
  numNodes,
  startNode = -1L
)

CirculationRunner(
  arcSources,
  arcTargets,
  arcLowerBound,
  arcUpperBound,
  nodeSupplies,
  numNodes
)

PreflowRunner(
  arcSources,
  arcTargets,
  arcDistances,
  sourceNode,
  destinationNode,
  numNodes
)

EdmondsKarpRunner(
  arcSources,
  arcTargets,
  arcDistances,
  sourceNode,
  destinationNode,
  numNodes
)

MaximumWeightPerfectMatchingRunner(
  arcSources,
  arcTargets,
  arcWeights,
  numNodes
)

MaximumWeightFractionalPerfectMatchingRunner(
  arcSources,
  arcTargets,
  arcWeights,
  numNodes
)

MaximumWeightFractionalMatchingRunner(
  arcSources,
  arcTargets,
  arcWeights,
  numNodes
)

MaximumWeightMatchingRunner(arcSources, arcTargets, arcWeights, numNodes)

MaximumCardinalityMatchingRunner(arcSources, arcTargets, numNodes)

MaximumCardinalityFractionalMatchingRunner(arcSources, arcTargets, numNodes)

CycleCancellingRunner(
  arcSources,
  arcTargets,
  arcCapacities,
  arcCosts,
  nodeSupplies,
  numNodes
)

CapacityScalingRunner(
  arcSources,
  arcTargets,
  arcCapacities,
  arcCosts,
  nodeSupplies,
  numNodes
)

CostScalingRunner(
  arcSources,
  arcTargets,
  arcCapacities,
  arcCosts,
  nodeSupplies,
  numNodes
)

NetworkSimplexRunner(
  arcSources,
  arcTargets,
  arcCapacities,
  arcCosts,
  nodeSupplies,
  numNodes
)

NagamochiIbarakiRunner(arcSources, arcTargets, arcWeights, numNodes)

HaoOrlinRunner(arcSources, arcTargets, arcWeights, numNodes)

GomoryHuTreeRunner(arcSources, arcTargets, arcWeights, numNodes)

HowardMmcRunner(arcSources, arcTargets, arcDistances, numNodes)

KarpMmcRunner(arcSources, arcTargets, arcDistances, numNodes)

HartmannOrlinMmcRunner(arcSources, arcTargets, arcDistances, numNodes)

KruskalRunner(arcSources, arcTargets, arcDistances, numNodes)

MinCostArborescenceRunner(
  arcSources,
  arcTargets,
  arcDistances,
  sourceNode,
  numNodes
)

PlanarCheckingRunner(arcSources, arcTargets, numNodes)

PlanarEmbeddingRunner(arcSources, arcTargets, numNodes)

PlanarColoringRunner(arcSources, arcTargets, numNodes, useFiveAlg = TRUE)

PlanarDrawingRunner(arcSources, arcTargets, numNodes)

SuurballeRunner(
  arcSources,
  arcTargets,
  arcDistances,
  numNodes,
  startNode,
  endNode
)

DijkstraRunner(arcSources, arcTargets, arcDistances, numNodes, startNode)

BellmanFordRunner(arcSources, arcTargets, arcDistances, numNodes, startNode)

ChristofidesRunner(
  arcSources,
  arcTargets,
  arcDistances,
  numNodes,
  defaultEdgeWeight = 999999L
)

GreedyTSPRunner(
  arcSources,
  arcTargets,
  arcDistances,
  numNodes,
  defaultEdgeWeight = 999999L
)

InsertionTSPRunner(
  arcSources,
  arcTargets,
  arcDistances,
  numNodes,
  defaultEdgeWeight = 999999L
)

NearestNeighborTSPRunner(
  arcSources,
  arcTargets,
  arcDistances,
  numNodes,
  defaultEdgeWeight = 999999L
)

Opt2TSPRunner(
  arcSources,
  arcTargets,
  arcDistances,
  numNodes,
  defaultEdgeWeight = 999999L
)

lemon_runners()
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GrossoLocatelliPullanMcRunner_+3A_arcsources">arcSources</code></td>
<td>
<p>a vector corresponding to the source nodes of a graph’s
edges</p>
</td></tr>
<tr><td><code id="GrossoLocatelliPullanMcRunner_+3A_arctargets">arcTargets</code></td>
<td>
<p>a vector corresponding to the destination nodes of a
graph’s edges</p>
</td></tr>
<tr><td><code id="GrossoLocatelliPullanMcRunner_+3A_numnodes">numNodes</code></td>
<td>
<p>the number of nodes in the graph</p>
</td></tr>
<tr><td><code id="GrossoLocatelliPullanMcRunner_+3A_nodeslist">nodesList</code></td>
<td>
<p>a vector of all the nodes in the graph</p>
</td></tr>
<tr><td><code id="GrossoLocatelliPullanMcRunner_+3A_startnode">startNode</code></td>
<td>
<p>in path-based algorithms, the start node of the path</p>
</td></tr>
<tr><td><code id="GrossoLocatelliPullanMcRunner_+3A_endnode">endNode</code></td>
<td>
<p>in path-based algorithms, the end node of the path</p>
</td></tr>
<tr><td><code id="GrossoLocatelliPullanMcRunner_+3A_arccapacities">arcCapacities</code></td>
<td>
<p>vector corresponding to the capacities of nodes of a
graph’s edges</p>
</td></tr>
<tr><td><code id="GrossoLocatelliPullanMcRunner_+3A_arclowerbound">arcLowerBound</code></td>
<td>
<p>vector corresponding to the lower-bound capacities of
nodes of a graph’s edges</p>
</td></tr>
<tr><td><code id="GrossoLocatelliPullanMcRunner_+3A_arcupperbound">arcUpperBound</code></td>
<td>
<p>vector corresponding to the upper-bound capacities of
nodes of a graph’s edges</p>
</td></tr>
<tr><td><code id="GrossoLocatelliPullanMcRunner_+3A_nodesupplies">nodeSupplies</code></td>
<td>
<p>vector corresponding to the supplies of each node of the
graph</p>
</td></tr>
<tr><td><code id="GrossoLocatelliPullanMcRunner_+3A_arcdistances">arcDistances</code></td>
<td>
<p>vector corresponding to the distances of a graph’s edges</p>
</td></tr>
<tr><td><code id="GrossoLocatelliPullanMcRunner_+3A_sourcenode">sourceNode</code></td>
<td>
<p>in flow-based algorithms, the source node of the flow</p>
</td></tr>
<tr><td><code id="GrossoLocatelliPullanMcRunner_+3A_destinationnode">destinationNode</code></td>
<td>
<p>in flow-based algorithms, the destination node of the
flow</p>
</td></tr>
<tr><td><code id="GrossoLocatelliPullanMcRunner_+3A_arcweights">arcWeights</code></td>
<td>
<p>vector corresponding to the weights of a graph’s arcs</p>
</td></tr>
<tr><td><code id="GrossoLocatelliPullanMcRunner_+3A_arccosts">arcCosts</code></td>
<td>
<p>vector corresponding to the costs of nodes of a graph’s
edges</p>
</td></tr>
<tr><td><code id="GrossoLocatelliPullanMcRunner_+3A_usefivealg">useFiveAlg</code></td>
<td>
<p>if <code>TRUE</code> (default), run a 5-color algorithm. If
<code>FALSE</code>, runs a faster 6-coloring algorithm instead.</p>
</td></tr>
<tr><td><code id="GrossoLocatelliPullanMcRunner_+3A_defaultedgeweight">defaultEdgeWeight</code></td>
<td>
<p>The default edge weight if an edge is not-specified
(default value 999999)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internally, all exported rlemon functions call a &quot;runner&quot; function to
interface with the C++, for example, <code>MaxFlow(..., algorithm =
"PreFlow")</code> will call <code>PreFlowRunner(...)</code>.
</p>
<p>In almost all cases, users will want to stick with the exported functions.
</p>
<p>Runners differ from exported functions in a few ways:
</p>

<ol>
<li><p> Exported functions provide input checking.
</p>
</li>
<li><p> Exported functions provide slightly cleaner output, such as
converting 0/1 boolean into <code>logical</code>.
</p>
</li>
<li><p> Any <code>list</code> which is returned from an exported function will be
named.
</p>
</li>
<li><p> The <code>arcWeights</code> argument is optional to <code>MaxMatching()</code>,
automatically generating a constant weight if it is excluded.
<code>arcWeights</code> is not optional in <code>MaxMatchingRunner()</code>.
</p>
</li></ol>



<h3>Value</h3>

<p>Algorithm results
</p>

<hr>
<h2 id='IsAcyclic'>Check if Graph is Acyclic.</h2><span id='topic+IsAcyclic'></span>

<h3>Description</h3>

<p>A cycle is a path starting and ending in the same node and containing at
least one other node. A acyclic graph contains no cycles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IsAcyclic(arcSources, arcTargets, numNodes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IsAcyclic_+3A_arcsources">arcSources</code></td>
<td>
<p>Vector corresponding to the source nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="IsAcyclic_+3A_arctargets">arcTargets</code></td>
<td>
<p>Vector corresponding to the destination nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="IsAcyclic_+3A_numnodes">numNodes</code></td>
<td>
<p>The number of nodes in the graph</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <a href="https://lemon.cs.elte.hu/pub/doc/1.3.1/a00616.html#ga14c191b2133a1dd23e1527f074c821c0">https://lemon.cs.elte.hu/pub/doc/1.3.1/a00616.html#ga14c191b2133a1dd23e1527f074c821c0</a>
for more information.
</p>


<h3>Value</h3>

<p>A <code>logical</code> stating if the graph is acyclic
</p>

<hr>
<h2 id='IsBiEdgeConnected'>Chcek if Graph is Bi-Edge-Connected</h2><span id='topic+IsBiEdgeConnected'></span>

<h3>Description</h3>

<p>Checks if an undirected graph is bi-edge-connected, that is if there are no
edges that, if removed, would split the graph into two unconnected graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IsBiEdgeConnected(arcSources, arcTargets, numNodes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IsBiEdgeConnected_+3A_arcsources">arcSources</code></td>
<td>
<p>Vector corresponding to the source nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="IsBiEdgeConnected_+3A_arctargets">arcTargets</code></td>
<td>
<p>Vector corresponding to the destination nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="IsBiEdgeConnected_+3A_numnodes">numNodes</code></td>
<td>
<p>The number of nodes in the graph</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See
<a href="https://lemon.cs.elte.hu/pub/doc/1.3.1/a00616.html#ga37d22a2ddd5a064a9203720f2b93518e">https://lemon.cs.elte.hu/pub/doc/1.3.1/a00616.html#ga37d22a2ddd5a064a9203720f2b93518e</a>
for more information.
</p>


<h3>Value</h3>

<p>A <code>logical</code> stating if the graph is bi-edge connected
</p>

<hr>
<h2 id='IsBiNodeConnected'>Checks if Graph is Bi-Node-Connected</h2><span id='topic+IsBiNodeConnected'></span>

<h3>Description</h3>

<p>Checks if an undirected graph is bi-node-connected, that is if there is are no
nodes which, if removed, would split the graph into two unconnected graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IsBiNodeConnected(arcSources, arcTargets, numNodes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IsBiNodeConnected_+3A_arcsources">arcSources</code></td>
<td>
<p>Vector corresponding to the source nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="IsBiNodeConnected_+3A_arctargets">arcTargets</code></td>
<td>
<p>Vector corresponding to the destination nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="IsBiNodeConnected_+3A_numnodes">numNodes</code></td>
<td>
<p>The number of nodes in the graph</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <a href="https://lemon.cs.elte.hu/pub/doc/1.3.1/a00616.html#gac9257323ead7cbe64b7b4a628c4876b3">https://lemon.cs.elte.hu/pub/doc/1.3.1/a00616.html#gac9257323ead7cbe64b7b4a628c4876b3</a>
for more information.
</p>


<h3>Value</h3>

<p>A <code>logical</code> stating if the graph is bi-node connected
</p>

<hr>
<h2 id='IsBipartite'>Checks if Graph is Bipartite</h2><span id='topic+IsBipartite'></span>

<h3>Description</h3>

<p>A bipartite graph is one whose nodes can be divided into two disjoint and
independent sets such that edges only connecte between those two sets and
not within a set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IsBipartite(arcSources, arcTargets, numNodes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IsBipartite_+3A_arcsources">arcSources</code></td>
<td>
<p>Vector corresponding to the source nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="IsBipartite_+3A_arctargets">arcTargets</code></td>
<td>
<p>Vector corresponding to the destination nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="IsBipartite_+3A_numnodes">numNodes</code></td>
<td>
<p>The number of nodes in the graph</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <a href="https://lemon.cs.elte.hu/pub/doc/1.3.1/a00616.html#ga577db110d33bd487aaad5bfffb31c6f5">https://lemon.cs.elte.hu/pub/doc/1.3.1/a00616.html#ga577db110d33bd487aaad5bfffb31c6f5</a>
for more information.
</p>


<h3>Value</h3>

<p>A <code>logical</code> stating if the graph is bipartite
</p>

<hr>
<h2 id='IsConnected'>Check if Graph is Connected</h2><span id='topic+IsConnected'></span>

<h3>Description</h3>

<p>A connected graph has a path between any two nodes in the graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IsConnected(arcSources, arcTargets, numNodes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IsConnected_+3A_arcsources">arcSources</code></td>
<td>
<p>Vector corresponding to the source nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="IsConnected_+3A_arctargets">arcTargets</code></td>
<td>
<p>Vector corresponding to the destination nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="IsConnected_+3A_numnodes">numNodes</code></td>
<td>
<p>The number of nodes in the graph</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <a href="https://lemon.cs.elte.hu/pub/doc/1.3.1/a00616.html#gad5c8d1b650f6b614a852f8430d90e184">https://lemon.cs.elte.hu/pub/doc/1.3.1/a00616.html#gad5c8d1b650f6b614a852f8430d90e184</a>
for more information.
</p>


<h3>Value</h3>

<p>A <code>logical</code> stating if the graph is connected
</p>

<hr>
<h2 id='IsDAG'>Check if Graph is a DAG.</h2><span id='topic+IsDAG'></span>

<h3>Description</h3>

<p>A graph is a DAG if it is Directed and Acyclic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IsDAG(arcSources, arcTargets, numNodes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IsDAG_+3A_arcsources">arcSources</code></td>
<td>
<p>Vector corresponding to the source nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="IsDAG_+3A_arctargets">arcTargets</code></td>
<td>
<p>Vector corresponding to the destination nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="IsDAG_+3A_numnodes">numNodes</code></td>
<td>
<p>The number of nodes in the graph</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <a href="https://lemon.cs.elte.hu/pub/doc/1.3.1/a00616.html#gaef2b43c8cd1d74e15fa5c7607bc5e396">https://lemon.cs.elte.hu/pub/doc/1.3.1/a00616.html#gaef2b43c8cd1d74e15fa5c7607bc5e396</a>
for more information.
</p>


<h3>Value</h3>

<p>A <code>logical</code> stating if the graph is DAG
</p>

<hr>
<h2 id='IsEulerian'>Check if Graph is Eulerian</h2><span id='topic+IsEulerian'></span>

<h3>Description</h3>

<p>A directed graph is Eulerian if and only if it is connected and the number
of incoming and outgoing edges are the same for each node. An undirected
graph is Eulerian if and only if it is connected and the number of incident
edges is even for each node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IsEulerian(arcSources, arcTargets, numNodes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IsEulerian_+3A_arcsources">arcSources</code></td>
<td>
<p>Vector corresponding to the source nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="IsEulerian_+3A_arctargets">arcTargets</code></td>
<td>
<p>Vector corresponding to the destination nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="IsEulerian_+3A_numnodes">numNodes</code></td>
<td>
<p>The number of nodes in the graph</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <a href="https://lemon.cs.elte.hu/pub/doc/1.3.1/a00616.html#gafb5a4961cac4d877006869fc4cb6ea1d">https://lemon.cs.elte.hu/pub/doc/1.3.1/a00616.html#gafb5a4961cac4d877006869fc4cb6ea1d</a>
for more information.
</p>


<h3>Value</h3>

<p>TRUE if graph is Eulerian, FALSE otherwise
</p>

<hr>
<h2 id='IsLoopFree'>Checks if Graph is Loop Free</h2><span id='topic+IsLoopFree'></span>

<h3>Description</h3>

<p>A loop is an edge that starts and ends at the same node and passes through
no other nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IsLoopFree(arcSources, arcTargets, numNodes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IsLoopFree_+3A_arcsources">arcSources</code></td>
<td>
<p>Vector corresponding to the source nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="IsLoopFree_+3A_arctargets">arcTargets</code></td>
<td>
<p>Vector corresponding to the destination nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="IsLoopFree_+3A_numnodes">numNodes</code></td>
<td>
<p>The number of nodes in the graph</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <a href="https://lemon.cs.elte.hu/pub/doc/1.3.1/a00616.html#ga127f3963003cd532c79c226885fe1c8c">https://lemon.cs.elte.hu/pub/doc/1.3.1/a00616.html#ga127f3963003cd532c79c226885fe1c8c</a>
for more information.
</p>


<h3>Value</h3>

<p>TRUE if the graph is loop free, FALSE otherwise
</p>

<hr>
<h2 id='IsParallelFree'>Check if Graph is Parallel Free</h2><span id='topic+IsParallelFree'></span>

<h3>Description</h3>

<p>Parallel edges occur when there are two edges between a single pair of nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IsParallelFree(arcSources, arcTargets, numNodes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IsParallelFree_+3A_arcsources">arcSources</code></td>
<td>
<p>Vector corresponding to the source nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="IsParallelFree_+3A_arctargets">arcTargets</code></td>
<td>
<p>Vector corresponding to the destination nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="IsParallelFree_+3A_numnodes">numNodes</code></td>
<td>
<p>The number of nodes in the graph</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See
<a href="https://lemon.cs.elte.hu/pub/doc/1.3.1/a00616.html#gaa05e0683f90b69f31eb29fe7d09afde4">https://lemon.cs.elte.hu/pub/doc/1.3.1/a00616.html#gaa05e0683f90b69f31eb29fe7d09afde4</a>
for more information.
</p>


<h3>Value</h3>

<p>TRUE if the graph is parallel free, FALSE otherwise
</p>

<hr>
<h2 id='IsSimpleGraph'>Check if Graph is Simple</h2><span id='topic+IsSimpleGraph'></span>

<h3>Description</h3>

<p>A graph is simple if it is both loop free, and parallel free. See also
<code>IsLoopFree</code> and <code>IsParallelFree</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IsSimpleGraph(arcSources, arcTargets, numNodes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IsSimpleGraph_+3A_arcsources">arcSources</code></td>
<td>
<p>Vector corresponding to the source nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="IsSimpleGraph_+3A_arctargets">arcTargets</code></td>
<td>
<p>Vector corresponding to the destination nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="IsSimpleGraph_+3A_numnodes">numNodes</code></td>
<td>
<p>The number of nodes in the graph</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <a href="https://lemon.cs.elte.hu/pub/doc/1.3.1/a00616.html#gae4c7ae734e2509ab78dc747d602c9236">https://lemon.cs.elte.hu/pub/doc/1.3.1/a00616.html#gae4c7ae734e2509ab78dc747d602c9236</a>
for more information.
</p>


<h3>Value</h3>

<p>TRUE if graph is simple, FALSE otherwise.
</p>

<hr>
<h2 id='IsStronglyConnected'>Check if Graph is Strongly Connected</h2><span id='topic+IsStronglyConnected'></span>

<h3>Description</h3>

<p>A directed graph is strongly connected if any two nodes are connected via
paths in both directions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IsStronglyConnected(arcSources, arcTargets, numNodes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IsStronglyConnected_+3A_arcsources">arcSources</code></td>
<td>
<p>Vector corresponding to the source nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="IsStronglyConnected_+3A_arctargets">arcTargets</code></td>
<td>
<p>Vector corresponding to the destination nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="IsStronglyConnected_+3A_numnodes">numNodes</code></td>
<td>
<p>The number of nodes in the graph</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <a href="https://lemon.cs.elte.hu/pub/doc/1.3.1/a00616.html#gacd21b34d7b42b9835a204a57fcf15964">https://lemon.cs.elte.hu/pub/doc/1.3.1/a00616.html#gacd21b34d7b42b9835a204a57fcf15964</a>
for more information.
</p>


<h3>Value</h3>

<p>A <code>logical</code> stating if the graph is strongly connected
</p>

<hr>
<h2 id='IsTree'>Check if Graph is a Tree</h2><span id='topic+IsTree'></span>

<h3>Description</h3>

<p>A tree is an undirected graph in which any two nodes are connected by
exactly one path, or equivalently is both connected and acyclic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IsTree(arcSources, arcTargets, numNodes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IsTree_+3A_arcsources">arcSources</code></td>
<td>
<p>Vector corresponding to the source nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="IsTree_+3A_arctargets">arcTargets</code></td>
<td>
<p>Vector corresponding to the destination nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="IsTree_+3A_numnodes">numNodes</code></td>
<td>
<p>The number of nodes in the graph</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <a href="https://lemon.cs.elte.hu/pub/doc/1.3.1/a00616.html#gad1e4de234e926958647905478415bd54">https://lemon.cs.elte.hu/pub/doc/1.3.1/a00616.html#gad1e4de234e926958647905478415bd54</a>
for more information.
</p>


<h3>Value</h3>

<p>A <code>logical</code> stating if the graph is a tree
</p>

<hr>
<h2 id='MaxCardinalityMatching'>Solve for Maximum Cardinality Matching</h2><span id='topic+MaxCardinalityMatching'></span>

<h3>Description</h3>

<p>Finds the maximum cardinality matching in graphs and bipartite graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MaxCardinalityMatching(
  arcSources,
  arcTargets,
  numNodes,
  algorithm = "MaxMatching"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MaxCardinalityMatching_+3A_arcsources">arcSources</code></td>
<td>
<p>Vector corresponding to the source nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="MaxCardinalityMatching_+3A_arctargets">arcTargets</code></td>
<td>
<p>Vector corresponding to the destination nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="MaxCardinalityMatching_+3A_numnodes">numNodes</code></td>
<td>
<p>The number of nodes in the graph</p>
</td></tr>
<tr><td><code id="MaxCardinalityMatching_+3A_algorithm">algorithm</code></td>
<td>
<p>Choices of algorithm include &quot;MaxMatching&quot; and
&quot;MaxFractionalMatching&quot;. &quot;MaxMatching&quot; is the default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details on LEMON's implementation, including differences between the
algorithms, see <a href="https://lemon.cs.elte.hu/pub/doc/1.3.1/a00615.html">https://lemon.cs.elte.hu/pub/doc/1.3.1/a00615.html</a>.
</p>


<h3>Value</h3>

<p>A named list containing two entries: 1) &quot;value&quot;: the matching value,
2) &quot;edges&quot;: the edges of the final graph, in a List of (node, node) pairs
</p>

<hr>
<h2 id='MaxCardinalitySearch'>Solver for Max Cardinality Search</h2><span id='topic+MaxCardinalitySearch'></span>

<h3>Description</h3>

<p>Runs the maximum cardinality search algorithm on a directed graph. The
maximum cardinality search first chooses any node of the digraph. Then every
time it chooses one unprocessed node with maximum cardinality, i.e the sum
of capacities on out arcs to the nodes which were previously processed. If
there is a cut in the digraph the algorithm should choose again any
unprocessed node of the digraph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MaxCardinalitySearch(
  arcSources,
  arcTargets,
  arcCapacities,
  numNodes,
  startNode = -1,
  algorithm = "maxcardinalitysearch"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MaxCardinalitySearch_+3A_arcsources">arcSources</code></td>
<td>
<p>Vector corresponding to the source nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="MaxCardinalitySearch_+3A_arctargets">arcTargets</code></td>
<td>
<p>Vector corresponding to the destination nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="MaxCardinalitySearch_+3A_arccapacities">arcCapacities</code></td>
<td>
<p>Vector corresponding to the distances of a graph's
edges</p>
</td></tr>
<tr><td><code id="MaxCardinalitySearch_+3A_numnodes">numNodes</code></td>
<td>
<p>The number of nodes in the graph</p>
</td></tr>
<tr><td><code id="MaxCardinalitySearch_+3A_startnode">startNode</code></td>
<td>
<p>Optional start node of the path</p>
</td></tr>
<tr><td><code id="MaxCardinalitySearch_+3A_algorithm">algorithm</code></td>
<td>
<p>Choices of algorithm include &quot;maxcardinalitysearch&quot;.
maxcardinalitysearch is the default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details on LEMON's implementation, including differences between the
algorithms, see <a href="https://lemon.cs.elte.hu/pub/doc/1.3.1/a00255.html">https://lemon.cs.elte.hu/pub/doc/1.3.1/a00255.html</a>.
</p>


<h3>Value</h3>

<p>A named list containing two entries: 1) &quot;cardinalities&quot;: the
cardinality of each node , 2) &quot;node_reached&quot;: a logical vector indicating
whether a node was reached or not
</p>

<hr>
<h2 id='MaxClique'>Solver for Largest Complete Subgroup (All Nodes Connected)</h2><span id='topic+MaxClique'></span>

<h3>Description</h3>

<p>Finds the largest complete subgraph (clique) in an undirected graph
via approximation algorithms for the maximal clique problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MaxClique(
  arcSources,
  arcTargets,
  numNodes,
  algorithm = "GrossoLocatelliPullanMc"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MaxClique_+3A_arcsources">arcSources</code></td>
<td>
<p>Vector corresponding to the source nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="MaxClique_+3A_arctargets">arcTargets</code></td>
<td>
<p>Vector corresponding to the destination nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="MaxClique_+3A_numnodes">numNodes</code></td>
<td>
<p>The number of nodes in the graph</p>
</td></tr>
<tr><td><code id="MaxClique_+3A_algorithm">algorithm</code></td>
<td>
<p>Choices of algorithm include &quot;GrossoLocatelliPullanMc&quot;.
GrossoLocatelliPullanMc is the default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details on LEMON's implementation, including differences between the
algorithms, see <a href="https://lemon.cs.elte.hu/pub/doc/1.3.1/a00194.html">https://lemon.cs.elte.hu/pub/doc/1.3.1/a00194.html</a>.
</p>


<h3>Value</h3>

<p>A named list containing two entries: 1) &quot;size&quot;: the clique size, and
2) &quot;members&quot;: the members of the clique.
</p>

<hr>
<h2 id='MaxFlow'>Solver for MaxFlow</h2><span id='topic+MaxFlow'></span>

<h3>Description</h3>

<p>Finds the maximum flow of a directed graph, given a source and destination
node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MaxFlow(
  arcSources,
  arcTargets,
  arcCapacities,
  sourceNode,
  destNode,
  numNodes,
  algorithm = "Preflow"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MaxFlow_+3A_arcsources">arcSources</code></td>
<td>
<p>Vector corresponding to the source nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="MaxFlow_+3A_arctargets">arcTargets</code></td>
<td>
<p>Vector corresponding to the destination nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="MaxFlow_+3A_arccapacities">arcCapacities</code></td>
<td>
<p>Vector corresponding to the capacities of nodes of a
graph's edges</p>
</td></tr>
<tr><td><code id="MaxFlow_+3A_sourcenode">sourceNode</code></td>
<td>
<p>The source node</p>
</td></tr>
<tr><td><code id="MaxFlow_+3A_destnode">destNode</code></td>
<td>
<p>The destination node</p>
</td></tr>
<tr><td><code id="MaxFlow_+3A_numnodes">numNodes</code></td>
<td>
<p>The number of nodes in the graph</p>
</td></tr>
<tr><td><code id="MaxFlow_+3A_algorithm">algorithm</code></td>
<td>
<p>Choices of algorithm include &quot;Preflow&quot; and &quot;EdmondsKarp&quot;.
&quot;Preflow&quot; is the default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details on LEMON's implementation, including differences between the
algorithms, see <a href="https://lemon.cs.elte.hu/pub/doc/1.3.1/a00611.html">https://lemon.cs.elte.hu/pub/doc/1.3.1/a00611.html</a>.
</p>


<h3>Value</h3>

<p>A named list containing three entries: 1) &quot;flows&quot;: a vector
corresponding to the flows of arcs in the graph, 2) &quot;cut_values&quot;: a vector
of cut-values of the graph's nodes, and 3) &quot;cost&quot;: the total cost of the
flows in the graph, i.e. the maxflow value.
</p>

<hr>
<h2 id='MaxMatching'>Solver for Maximum Weighted Matching</h2><span id='topic+MaxMatching'></span>

<h3>Description</h3>

<p>Finds the maximum weighted matching in graphs and bipartite graphs. Each
algorithm in this set returns different outputs depending on different
situations, like PerfectMatching or PerfectFractionalMathing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MaxMatching(
  arcSources,
  arcTargets,
  arcWeights = NULL,
  numNodes,
  algorithm = "MaxWeightedMatching"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MaxMatching_+3A_arcsources">arcSources</code></td>
<td>
<p>Vector corresponding to the source nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="MaxMatching_+3A_arctargets">arcTargets</code></td>
<td>
<p>Vector corresponding to the destination nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="MaxMatching_+3A_arcweights">arcWeights</code></td>
<td>
<p>Vector corresponding to the weights of a graph's edges.
Default is <code>NULL</code> for unweight matching.</p>
</td></tr>
<tr><td><code id="MaxMatching_+3A_numnodes">numNodes</code></td>
<td>
<p>The number of nodes in the graph</p>
</td></tr>
<tr><td><code id="MaxMatching_+3A_algorithm">algorithm</code></td>
<td>
<p>Choices of algorithm include &quot;MaxWeightedMatching&quot;,
&quot;MaxWeightedPerfectMatching&quot;, &quot;MaxWeightedFractionalMatching&quot;, and
&quot;MaxWeightedPerfectFractionalMatching&quot;. &quot;MaxWeightedMatching&quot; is the
default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details on LEMON's implementation, including differences between the
algorithms, see <a href="https://lemon.cs.elte.hu/pub/doc/1.3.1/a00615.html">https://lemon.cs.elte.hu/pub/doc/1.3.1/a00615.html</a>.
</p>


<h3>Value</h3>

<p>A named list containing two entries: 1) &quot;value&quot;: the matching value,
2) &quot;edges&quot;: the edges of the final graph, in a list of (node, node) pairs
</p>

<hr>
<h2 id='MinCostArborescence'>Solver for Minimum Cost Arborescence</h2><span id='topic+MinCostArborescence'></span>

<h3>Description</h3>

<p>Finds the minimum cost arborescence of a graph, returning both the cost and
the pairs of nodes for the edges in the arborescence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MinCostArborescence(
  arcSources,
  arcTargets,
  arcDistances,
  sourceNode,
  numNodes,
  algorithm = "MinCostArborescence"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MinCostArborescence_+3A_arcsources">arcSources</code></td>
<td>
<p>Vector corresponding to the source nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="MinCostArborescence_+3A_arctargets">arcTargets</code></td>
<td>
<p>Vector corresponding to the destination nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="MinCostArborescence_+3A_arcdistances">arcDistances</code></td>
<td>
<p>Vector corresponding to the distances of nodes of a
graph's edges</p>
</td></tr>
<tr><td><code id="MinCostArborescence_+3A_sourcenode">sourceNode</code></td>
<td>
<p>The source node</p>
</td></tr>
<tr><td><code id="MinCostArborescence_+3A_numnodes">numNodes</code></td>
<td>
<p>The number of nodes in the graph</p>
</td></tr>
<tr><td><code id="MinCostArborescence_+3A_algorithm">algorithm</code></td>
<td>
<p>Choices of algorithm include &quot;MinCostArborescence&quot;.
&quot;MinCostArborescence&quot; is the default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details on LEMON's implementation, including differences between the
algorithms, see <a href="https://lemon.cs.elte.hu/pub/doc/1.3.1/a00264.html">https://lemon.cs.elte.hu/pub/doc/1.3.1/a00264.html</a>.
</p>


<h3>Value</h3>

<p>A named list containing three entries: 1) &quot;sources&quot;: a vector
corresponding the source nodes of the edges in the tree, 2) &quot;targets&quot;: a
vector corresponding the target nodes of the edges in the tree, and 3)
&quot;cost&quot;: the total cost of the arborescence.
</p>

<hr>
<h2 id='MinCostFlow'>Solver for MinCostFlow</h2><span id='topic+MinCostFlow'></span>

<h3>Description</h3>

<p>Finds the minimum cost flow of a directed graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MinCostFlow(
  arcSources,
  arcTargets,
  arcCapacities,
  arcCosts,
  nodeSupplies,
  numNodes,
  algorithm = "NetworkSimplex"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MinCostFlow_+3A_arcsources">arcSources</code></td>
<td>
<p>Vector corresponding to the source nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="MinCostFlow_+3A_arctargets">arcTargets</code></td>
<td>
<p>Vector corresponding to the destination nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="MinCostFlow_+3A_arccapacities">arcCapacities</code></td>
<td>
<p>Vector corresponding to the capacities of nodes of a
graph's edges</p>
</td></tr>
<tr><td><code id="MinCostFlow_+3A_arccosts">arcCosts</code></td>
<td>
<p>Vector corresponding to the capacities of nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="MinCostFlow_+3A_nodesupplies">nodeSupplies</code></td>
<td>
<p>Vector corresponding to the supplies of each node</p>
</td></tr>
<tr><td><code id="MinCostFlow_+3A_numnodes">numNodes</code></td>
<td>
<p>The number of nodes in the graph</p>
</td></tr>
<tr><td><code id="MinCostFlow_+3A_algorithm">algorithm</code></td>
<td>
<p>Choices of algorithm include &quot;NetworkSimplex&quot;,
&quot;CostScaling&quot;, &quot;CapacityScaling&quot;, and &quot;CycleCancelling&quot;. NetworkSimplex is
the default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details on LEMON's implementation, including differences between the
algorithms, see <a href="https://lemon.cs.elte.hu/pub/doc/1.3.1/a00612.html">https://lemon.cs.elte.hu/pub/doc/1.3.1/a00612.html</a>.
</p>


<h3>Value</h3>

<p>A named list containing four entries: 1) &quot;flows&quot;: A vector
corresponding to the flows of arcs in the graph, 2) &quot;potentials&quot;: A vector
of potentials of the graph's nodes, 3) &quot;cost&quot;: the total cost of the flows
in the graph, i.e. the mincostflow value, and 4) &quot;feasibility&quot;: LEMON's
feasibility type, demonstrating how feasible the graph problem is, one of
&quot;INFEASIBLE&quot;, &quot;OPTIMAL&quot;, and &quot;UNBOUNDED&quot;
</p>

<hr>
<h2 id='MinCut'>Solver for MinCut</h2><span id='topic+MinCut'></span>

<h3>Description</h3>

<p>Finds the minimum cut on graphs. NagamochiIbaraki calculates the min cut
value and edges in undirected graphs,while HaoOrlin calculates the min cut value
and edges in directed graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MinCut(
  arcSources,
  arcTargets,
  arcWeights,
  numNodes,
  algorithm = "NagamochiIbaraki"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MinCut_+3A_arcsources">arcSources</code></td>
<td>
<p>Vector corresponding to the source nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="MinCut_+3A_arctargets">arcTargets</code></td>
<td>
<p>Vector corresponding to the destination nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="MinCut_+3A_arcweights">arcWeights</code></td>
<td>
<p>Vector corresponding to the weights of a graph's arcs</p>
</td></tr>
<tr><td><code id="MinCut_+3A_numnodes">numNodes</code></td>
<td>
<p>The number of nodes in the graph</p>
</td></tr>
<tr><td><code id="MinCut_+3A_algorithm">algorithm</code></td>
<td>
<p>Choices of algorithm include &quot;NagamochiIbaraki&quot; and
&quot;HaoOrlin&quot;. &quot;NagamochiIbaraki&quot; is the default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details on LEMON's implementation, including differences between the
algorithms, see <a href="https://lemon.cs.elte.hu/pub/doc/1.3.1/a00613.html">https://lemon.cs.elte.hu/pub/doc/1.3.1/a00613.html</a>.
</p>


<h3>Value</h3>

<p>A named list containing three entries: 1) &quot;mincut&quot;: the value of the
minimum cut in the graph, 2) &quot;first_partition&quot;: a vector of nodes in the
first partition, and 3) &quot;second_partition&quot;: a vector of nodes in the
second partition. GomoryHu calculates a Gomory-Hu Tree and returns a list
containing three entries: 1) A vector of predecessor nodes of each node in
the graph, and 2) A vector of weights of the predecessor edge of each
node, and 3) A vector of distances from the root node to each node.
</p>

<hr>
<h2 id='MinMeanCycle'>Solver for Minimum Mean Cycle</h2><span id='topic+MinMeanCycle'></span>

<h3>Description</h3>

<p>Finds the Minimum Mean Cycle in directed graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MinMeanCycle(
  arcSources,
  arcTargets,
  arcDistances,
  numNodes,
  algorithm = "Howard"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MinMeanCycle_+3A_arcsources">arcSources</code></td>
<td>
<p>Vector corresponding to the source nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="MinMeanCycle_+3A_arctargets">arcTargets</code></td>
<td>
<p>Vector corresponding to the destination nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="MinMeanCycle_+3A_arcdistances">arcDistances</code></td>
<td>
<p>Vector corresponding to the distances of a graph's edges</p>
</td></tr>
<tr><td><code id="MinMeanCycle_+3A_numnodes">numNodes</code></td>
<td>
<p>The number of nodes in the graph</p>
</td></tr>
<tr><td><code id="MinMeanCycle_+3A_algorithm">algorithm</code></td>
<td>
<p>Choices of algorithm include &quot;Howard&quot;, &quot;Karp&quot;, and
&quot;HartmannOrlin&quot;. &quot;Howard&quot; is the default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details on LEMON's implementation, including differences between the
algorithms, see <a href="https://lemon.cs.elte.hu/pub/doc/1.3.1/a00614.html">https://lemon.cs.elte.hu/pub/doc/1.3.1/a00614.html</a>.
</p>


<h3>Value</h3>

<p>A named list containing two entries: 1) &quot;cost&quot;: a vector containing
the costs of each edge in the Minimum Mean Cyckle, and 2) &quot;nodes&quot;: the
nodes in the Minimum Mean Cycle.
</p>

<hr>
<h2 id='MinSpanningTree'>Solver for Minimum Spanning Tree</h2><span id='topic+MinSpanningTree'></span>

<h3>Description</h3>

<p>The minimum spanning tree is the minimal connected acyclic subgraph of a
graph, assuming the graph is undirected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MinSpanningTree(
  arcSources,
  arcTargets,
  arcDistances,
  numNodes,
  algorithm = "Kruskal"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MinSpanningTree_+3A_arcsources">arcSources</code></td>
<td>
<p>Vector corresponding to the source nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="MinSpanningTree_+3A_arctargets">arcTargets</code></td>
<td>
<p>Vector corresponding to the destination nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="MinSpanningTree_+3A_arcdistances">arcDistances</code></td>
<td>
<p>Vector corresponding to the distances of nodes of a
graph's edges</p>
</td></tr>
<tr><td><code id="MinSpanningTree_+3A_numnodes">numNodes</code></td>
<td>
<p>The number of nodes in the graph</p>
</td></tr>
<tr><td><code id="MinSpanningTree_+3A_algorithm">algorithm</code></td>
<td>
<p>Choices of algorithm include &quot;Kruskal&quot;. &quot;Kruskal&quot; is the
default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details on LEMON's implementation, including differences between the
algorithms, see
<a href="https://lemon.cs.elte.hu/pub/doc/1.3.1/a00610.html#ga233792b2c44a3581b85a775703e045af">https://lemon.cs.elte.hu/pub/doc/1.3.1/a00610.html#ga233792b2c44a3581b85a775703e045af</a>
</p>


<h3>Value</h3>

<p>A named list containing three entries: 1) &quot;sources&quot;: a vector
corresponding the source nodes of the edges in the tree, 2) &quot;targets&quot;: a
vector corresponding the target nodes of the edges in the tree, and 3)
&quot;value&quot;: the total minimum spanning tree value.
</p>

<hr>
<h2 id='NetworkCirculation'>Solver for Network Circulation</h2><span id='topic+NetworkCirculation'></span>

<h3>Description</h3>

<p>Finds the solution to the network circulation problem via the push-relabel
circulation algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NetworkCirculation(
  arcSources,
  arcTargets,
  arcLowerBound,
  arcUpperBound,
  nodeSupplies,
  numNodes,
  algorithm = "Circulation"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NetworkCirculation_+3A_arcsources">arcSources</code></td>
<td>
<p>Vector corresponding to the source nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="NetworkCirculation_+3A_arctargets">arcTargets</code></td>
<td>
<p>Vector corresponding to the destination nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="NetworkCirculation_+3A_arclowerbound">arcLowerBound</code></td>
<td>
<p>Vector corresponding to the lower-bound capacities of
nodes of a graph's edges</p>
</td></tr>
<tr><td><code id="NetworkCirculation_+3A_arcupperbound">arcUpperBound</code></td>
<td>
<p>Vector corresponding to the upper-bound capacities of
nodes of a graph's edges</p>
</td></tr>
<tr><td><code id="NetworkCirculation_+3A_nodesupplies">nodeSupplies</code></td>
<td>
<p>Vector corresponding to the supplies of each node of the
graph.</p>
</td></tr>
<tr><td><code id="NetworkCirculation_+3A_numnodes">numNodes</code></td>
<td>
<p>The number of nodes in the graph</p>
</td></tr>
<tr><td><code id="NetworkCirculation_+3A_algorithm">algorithm</code></td>
<td>
<p>Choices of algorithminclude &quot;Circulation&quot;. &quot;Circulation&quot; is
the default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details on LEMON's implementation, including differences between the
algorithms, see <a href="https://lemon.cs.elte.hu/pub/doc/1.3.1/a00078.html">https://lemon.cs.elte.hu/pub/doc/1.3.1/a00078.html</a>.
</p>


<h3>Value</h3>

<p>A named list containing two entries: 1) &quot;flows&quot;: a vector
corresponding to the flows of arcs in the graph, and 2) &quot;barriers&quot;: a
vector of the graph's barrier nodes.
</p>

<hr>
<h2 id='PlanarChecking'>Check if Graph is Planar</h2><span id='topic+PlanarChecking'></span>

<h3>Description</h3>

<p>Checks if an undirected graph is planar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlanarChecking(arcSources, arcTargets, numNodes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PlanarChecking_+3A_arcsources">arcSources</code></td>
<td>
<p>Vector corresponding to the source nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="PlanarChecking_+3A_arctargets">arcTargets</code></td>
<td>
<p>Vector corresponding to the destination nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="PlanarChecking_+3A_numnodes">numNodes</code></td>
<td>
<p>The number of nodes in the graph</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <a href="https://lemon.cs.elte.hu/pub/doc/1.3.1/a00617.html#ga230242aa2ee36f9b1b5a58f2c53016eb">https://lemon.cs.elte.hu/pub/doc/1.3.1/a00617.html#ga230242aa2ee36f9b1b5a58f2c53016eb</a>
for more information.
</p>


<h3>Value</h3>

<p>A <code>logical</code> stating if the graph is planar or not.
</p>

<hr>
<h2 id='PlanarColoring'>Solver for Planar Coloring</h2><span id='topic+PlanarColoring'></span>

<h3>Description</h3>

<p>Checks if a graph is planar and returns the coloring of the graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlanarColoring(arcSources, arcTargets, numNodes, algorithm = "fiveColoring")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PlanarColoring_+3A_arcsources">arcSources</code></td>
<td>
<p>Vector corresponding to the source nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="PlanarColoring_+3A_arctargets">arcTargets</code></td>
<td>
<p>Vector corresponding to the destination nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="PlanarColoring_+3A_numnodes">numNodes</code></td>
<td>
<p>The number of nodes in the graph</p>
</td></tr>
<tr><td><code id="PlanarColoring_+3A_algorithm">algorithm</code></td>
<td>
<p>the algorithm to use. &quot;sixColoring&quot; generates a 6-coloring
of the graph, while &quot;fiveColoring&quot; generates a 5-coloring. Default is
&quot;fiveColoring&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <a href="https://lemon.cs.elte.hu/pub/doc/1.3.1/a00306.html">https://lemon.cs.elte.hu/pub/doc/1.3.1/a00306.html</a>
for more information.
</p>


<h3>Value</h3>

<p>A named list containing 1) &quot;is_planar&quot;: a <code>logical</code> if the
graph is planar, 2) &quot;colors&quot;: the color of each vertex of the graph
</p>

<hr>
<h2 id='PlanarDrawing'>Solver for Planar Drawing</h2><span id='topic+PlanarDrawing'></span>

<h3>Description</h3>

<p>The planar drawing algorithm calculates positions for the nodes in the
plane. These coordinates satisfy that if the edges are represented with
straight lines, then they will not intersect each other.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlanarDrawing(arcSources, arcTargets, numNodes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PlanarDrawing_+3A_arcsources">arcSources</code></td>
<td>
<p>Vector corresponding to the source nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="PlanarDrawing_+3A_arctargets">arcTargets</code></td>
<td>
<p>Vector corresponding to the destination nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="PlanarDrawing_+3A_numnodes">numNodes</code></td>
<td>
<p>The number of nodes in the graph</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <a href="https://lemon.cs.elte.hu/pub/doc/1.3.1/a00307.html">https://lemon.cs.elte.hu/pub/doc/1.3.1/a00307.html</a>
for more information.
</p>


<h3>Value</h3>

<p>A named list of 1) &quot;is_planar&quot;: a <code>logical</code> of if the graph is
planar, 2) &quot;x_coords&quot;: the x-coordinate of the planar embedding, 3)
&quot;y_coords&quot;: the y-coordinate of the planar embedding
</p>

<hr>
<h2 id='PlanarEmbedding'>Solver for Planar Embedding</h2><span id='topic+PlanarEmbedding'></span>

<h3>Description</h3>

<p>Checks if an undirected graph is planar and returns a list of outputs
related to the planar embedding
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlanarEmbedding(arcSources, arcTargets, numNodes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PlanarEmbedding_+3A_arcsources">arcSources</code></td>
<td>
<p>Vector corresponding to the source nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="PlanarEmbedding_+3A_arctargets">arcTargets</code></td>
<td>
<p>Vector corresponding to the destination nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="PlanarEmbedding_+3A_numnodes">numNodes</code></td>
<td>
<p>The number of nodes in the graph</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <a href="https://lemon.cs.elte.hu/pub/doc/1.3.1/a00308.html">https://lemon.cs.elte.hu/pub/doc/1.3.1/a00308.html</a>
for more information.
</p>


<h3>Value</h3>

<p>A named list containing 1) &quot;is_planar&quot;: a logical indicating if the
graph is planar, 2) &quot;start_nodes_embedding&quot;: the start nodes of the arcs
of the embedding, 3) &quot;end_nodes_embedding&quot;: the end nodes of the arcs of
the planar embedding, 4) &quot;start_nodes_kuratowski&quot;: the start nodes of the
edges of the kuratowski subdivision, 5) &quot;end_nodes_kuratowski&quot;: the end
nodes of the edges of the kuratowski subdivision.
</p>

<hr>
<h2 id='ShortestPath'>Solver for Shortest Path Between Two Nodes</h2><span id='topic+ShortestPath'></span>

<h3>Description</h3>

<p>FINDS the shortest arc disjoint paths between two nodes in a directed graph.
This implementation runs a variation of the successive shortest path algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ShortestPath(
  arcSources,
  arcTargets,
  arcDistances,
  numNodes,
  sourceNode,
  destNode,
  algorithm = "Suurballe"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ShortestPath_+3A_arcsources">arcSources</code></td>
<td>
<p>Vector corresponding to the source nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="ShortestPath_+3A_arctargets">arcTargets</code></td>
<td>
<p>Vector corresponding to the destination nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="ShortestPath_+3A_arcdistances">arcDistances</code></td>
<td>
<p>Vector corresponding to the distances of a graph's edges</p>
</td></tr>
<tr><td><code id="ShortestPath_+3A_numnodes">numNodes</code></td>
<td>
<p>The number of nodes in the graph</p>
</td></tr>
<tr><td><code id="ShortestPath_+3A_sourcenode">sourceNode</code></td>
<td>
<p>The start node of the path</p>
</td></tr>
<tr><td><code id="ShortestPath_+3A_destnode">destNode</code></td>
<td>
<p>The end node of the path</p>
</td></tr>
<tr><td><code id="ShortestPath_+3A_algorithm">algorithm</code></td>
<td>
<p>Choices of algorithm include &quot;Suurballe&quot;. &quot;Suurballe&quot; is
the default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details on LEMON's implementation, including differences between the
algorithms, see <a href="https://lemon.cs.elte.hu/pub/doc/1.3.1/a00609.html">https://lemon.cs.elte.hu/pub/doc/1.3.1/a00609.html</a>.
</p>


<h3>Value</h3>

<p>A named list containing two entries: 1) &quot;num_paths&quot;: the number of
paths from the start node to the end node and 2) &quot;list_paths&quot;: a list of
paths found. If there are multiple paths, then the second entry will have
multiple paths.
</p>

<hr>
<h2 id='ShortestPathFromSource'>Solve for Shortest Path from Source Node to All Other Nodes</h2><span id='topic+ShortestPathFromSource'></span>

<h3>Description</h3>

<p>Finds the shortest path from a source node to the rest of the nodes in a
directed graph. These shortest path algorithms consider the distances present
in the graph, as well as the number of edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ShortestPathFromSource(
  arcSources,
  arcTargets,
  arcDistances,
  numNodes,
  sourceNode,
  algorithm = "Dijkstra"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ShortestPathFromSource_+3A_arcsources">arcSources</code></td>
<td>
<p>Vector corresponding to the source nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="ShortestPathFromSource_+3A_arctargets">arcTargets</code></td>
<td>
<p>Vector corresponding to the destination nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="ShortestPathFromSource_+3A_arcdistances">arcDistances</code></td>
<td>
<p>Vector corresponding to the distances of a graph's edges</p>
</td></tr>
<tr><td><code id="ShortestPathFromSource_+3A_numnodes">numNodes</code></td>
<td>
<p>The number of nodes in the graph</p>
</td></tr>
<tr><td><code id="ShortestPathFromSource_+3A_sourcenode">sourceNode</code></td>
<td>
<p>The source node</p>
</td></tr>
<tr><td><code id="ShortestPathFromSource_+3A_algorithm">algorithm</code></td>
<td>
<p>Choices of algorithm include &quot;Dijkstra&quot; and &quot;BellmanFord&quot;.
&quot;Dijkstra&quot; is the default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details on LEMON's implementation, including differences between the
algorithms, see <a href="https://lemon.cs.elte.hu/pub/doc/1.3.1/a00609.html">https://lemon.cs.elte.hu/pub/doc/1.3.1/a00609.html</a>.
</p>


<h3>Value</h3>

<p>A named list containing two entries: 1) &quot;distances&quot;: the distances
from each node to the startNode and 2) &quot;predecessors&quot;: the predecessor of
each vertex in its shortest path.
</p>

<hr>
<h2 id='small_graph_example'>A small network graph example</h2><span id='topic+small_graph_example'></span>

<h3>Description</h3>

<p>A small network graph example
</p>


<h3>Usage</h3>

<pre><code class='language-R'>small_graph_example
</code></pre>


<h3>Format</h3>

<p>A list of length 5.
</p>

<hr>
<h2 id='TravelingSalesperson'>Solver for Traveling Salesperson Problem</h2><span id='topic+TravelingSalesperson'></span><span id='topic+TravellingSalesperson'></span>

<h3>Description</h3>

<p>Finds approximations for the travelling salesperson problem using
approximation algorithms on graphs. NOTE: LEMON's TSP uses a
complete graph in its backend, so expect less performance on sparse graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TravelingSalesperson(
  arcSources,
  arcTargets,
  arcDistances,
  numNodes,
  defaultEdgeWeight = 999999,
  algorithm = "Christofides"
)

TravellingSalesperson(
  arcSources,
  arcTargets,
  arcDistances,
  numNodes,
  defaultEdgeWeight = 999999,
  algorithm = "Christofides"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TravelingSalesperson_+3A_arcsources">arcSources</code></td>
<td>
<p>Vector corresponding to the source nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="TravelingSalesperson_+3A_arctargets">arcTargets</code></td>
<td>
<p>Vector corresponding to the destination nodes of a graph's
edges</p>
</td></tr>
<tr><td><code id="TravelingSalesperson_+3A_arcdistances">arcDistances</code></td>
<td>
<p>Vector corresponding to the distances of a graph's edges</p>
</td></tr>
<tr><td><code id="TravelingSalesperson_+3A_numnodes">numNodes</code></td>
<td>
<p>The number of nodes in the graph</p>
</td></tr>
<tr><td><code id="TravelingSalesperson_+3A_defaultedgeweight">defaultEdgeWeight</code></td>
<td>
<p>The default edge weight if an edge is not-specified
(default value 999999)</p>
</td></tr>
<tr><td><code id="TravelingSalesperson_+3A_algorithm">algorithm</code></td>
<td>
<p>Choices of algorithm include &quot;Christofides&quot;, &quot;Greedy&quot;,
&quot;Insertion&quot;, &quot;NearestNeighbor&quot;, and &quot;Opt2&quot;. &quot;Christofides&quot; is the default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details on LEMON's implementation, including differences between the
algorithms, see <a href="https://lemon.cs.elte.hu/pub/doc/1.3.1/a00618.html">https://lemon.cs.elte.hu/pub/doc/1.3.1/a00618.html</a>.
</p>


<h3>Value</h3>

<p>A named list with 1) &quot;node_order&quot;: the vector of visited nodes in
order, and 2) &quot;cost&quot;: the total tour cost.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
