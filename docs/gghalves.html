<!DOCTYPE html><html><head><title>Help for package gghalves</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gghalves}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#geom_half_boxplot'><p>A half boxplot</p></a></li>
<li><a href='#geom_half_dotplot'><p>Half dot plot with sensible parameter settings.</p></a></li>
<li><a href='#geom_half_point'><p>Points with jitter for half geoms.</p></a></li>
<li><a href='#geom_half_point_panel'><p>Points with jitter for half geoms. Unlike 'geom_half_point', 'geom_half_point_panel' does not dodge different grouping aesthetics. This allows multiple groups in a single cloud of points (see examples).</p></a></li>
<li><a href='#geom_half_violin'><p>Half Violin plot</p></a></li>
<li><a href='#GeomHalfDotplot'><p>gghalves extensions to ggplot2</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Compose Half-Half Plots Using Your Favourite Geoms</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.4</td>
</tr>
<tr>
<td>Description:</td>
<td>A 'ggplot2' extension for easy plotting of half-half geom combinations. Think half boxplot and half jitterplot, or half violinplot and half dotplot.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/erocoar/gghalves">https://github.com/erocoar/gghalves</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>ggplot2 (&ge; 3.3.6), R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>grid, gtable, grDevices</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, dplyr</td>
</tr>
<tr>
<td>Collate:</td>
<td>'utilities.R' 'geom_half_dotplot.R' 'geom_half_boxplot.R'
'geom_half_point.R' 'geom_half_point_panel.R'
'geom_half_violin.R' 'stat-half-bindot.R' 'stat-half-point.R'
'stat-half-ydensity.R' 'ggproto-classes.R'</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-20 11:13:28 UTC; fjtie</td>
</tr>
<tr>
<td>Author:</td>
<td>Frederik Tiedemann [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Frederik Tiedemann &lt;fj.tiedemann@googlemail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-20 11:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='geom_half_boxplot'>A half boxplot</h2><span id='topic+geom_half_boxplot'></span>

<h3>Description</h3>

<p>A half boxplot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_half_boxplot(
  mapping = NULL,
  data = NULL,
  stat = "boxplot",
  position = "dodge2",
  ...,
  side = "l",
  center = FALSE,
  nudge = 0,
  outlier.colour = NULL,
  outlier.color = NULL,
  outlier.fill = NULL,
  outlier.shape = 19,
  outlier.size = 1.5,
  outlier.stroke = 0.5,
  outlier.alpha = NULL,
  notch = FALSE,
  notchwidth = 0.5,
  varwidth = FALSE,
  errorbar.draw = TRUE,
  errorbar.length = 0.5,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_half_boxplot_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code> or
<code><a href="ggplot2.html#topic+aes_">aes_()</a></code>. If specified and <code>inherit.aes = TRUE</code> (the
default), it is combined with the default mapping at the top level of the
plot. You must supply <code>mapping</code> if there is no plot mapping.</p>
</td></tr>
<tr><td><code id="geom_half_boxplot_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_half_boxplot_+3A_stat">stat</code></td>
<td>
<p>Use to override the default connection between
'geom_boxplot()' and 'stat_boxplot()'.</p>
</td></tr>
<tr><td><code id="geom_half_boxplot_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of
a call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="geom_half_boxplot_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_half_boxplot_+3A_side">side</code></td>
<td>
<p>The side of the half-geom, &quot;l&quot; for left and &quot;r&quot; for right, defaults to &quot;l&quot;.</p>
</td></tr>
<tr><td><code id="geom_half_boxplot_+3A_center">center</code></td>
<td>
<p>Boolean whether to center the half-boxplot instead of aligning it to its respective side.</p>
</td></tr>
<tr><td><code id="geom_half_boxplot_+3A_nudge">nudge</code></td>
<td>
<p>Add space between the boxplot and the middle of the space allotted to a given factor on the x-axis.</p>
</td></tr>
<tr><td><code id="geom_half_boxplot_+3A_outlier.colour">outlier.colour</code>, <code id="geom_half_boxplot_+3A_outlier.color">outlier.color</code>, <code id="geom_half_boxplot_+3A_outlier.fill">outlier.fill</code>, <code id="geom_half_boxplot_+3A_outlier.shape">outlier.shape</code>, <code id="geom_half_boxplot_+3A_outlier.size">outlier.size</code>, <code id="geom_half_boxplot_+3A_outlier.stroke">outlier.stroke</code>, <code id="geom_half_boxplot_+3A_outlier.alpha">outlier.alpha</code></td>
<td>
<p>Default aesthetics for outliers. Set to <code>NULL</code> to inherit from the
aesthetics used for the box.
</p>
<p>In the unlikely event you specify both US and UK spellings of colour, the
US spelling will take precedence.
</p>
<p>Sometimes it can be useful to hide the outliers, for example when overlaying
the raw data points on top of the boxplot. Hiding the outliers can be achieved
by setting <code>outlier.shape = NA</code>. Importantly, this does not remove the outliers,
it only hides them, so the range calculated for the y-axis will be the
same with outliers shown and outliers hidden.</p>
</td></tr>
<tr><td><code id="geom_half_boxplot_+3A_notch">notch</code></td>
<td>
<p>If <code>FALSE</code> (default) make a standard box plot. If
<code>TRUE</code>, make a notched box plot. Notches are used to compare groups;
if the notches of two boxes do not overlap, this suggests that the medians
are significantly different.</p>
</td></tr>
<tr><td><code id="geom_half_boxplot_+3A_notchwidth">notchwidth</code></td>
<td>
<p>For a notched box plot, width of the notch relative to
the body (defaults to <code>notchwidth = 0.5</code>).</p>
</td></tr>
<tr><td><code id="geom_half_boxplot_+3A_varwidth">varwidth</code></td>
<td>
<p>If <code>FALSE</code> (default) make a standard box plot. If
<code>TRUE</code>, boxes are drawn with widths proportional to the
square-roots of the number of observations in the groups (possibly
weighted, using the <code>weight</code> aesthetic).</p>
</td></tr>
<tr><td><code id="geom_half_boxplot_+3A_errorbar.draw">errorbar.draw</code></td>
<td>
<p>Draw horizontal whiskers at the top and bottom (the IQR). Defaults to 'TRUE'.</p>
</td></tr>
<tr><td><code id="geom_half_boxplot_+3A_errorbar.length">errorbar.length</code></td>
<td>
<p>Length of the horizontal whiskers (errorbar). Defaults to half the width of the half-boxplot</p>
</td></tr>
<tr><td><code id="geom_half_boxplot_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_half_boxplot_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_half_boxplot_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>ggplot(iris, aes(x = Species, y = Petal.Width, fill = Species)) + 
  geom_half_boxplot() 
  
ggplot(iris, aes(x = Species, y = Petal.Width, fill = Species)) + 
  geom_half_boxplot(side = "r") 
  
ggplot(iris, aes(x = Species, y = Petal.Width, fill = Species)) + 
  geom_half_boxplot(center = TRUE) 
</code></pre>

<hr>
<h2 id='geom_half_dotplot'>Half dot plot with sensible parameter settings.</h2><span id='topic+geom_half_dotplot'></span>

<h3>Description</h3>

<p>In a dot plot, the width of a dot corresponds to the bin width
(or maximum width, depending on the binning algorithm), and dots are
stacked, with each dot representing one observation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_half_dotplot(
  mapping = NULL,
  data = NULL,
  position = "dodge",
  ...,
  binwidth = NULL,
  binaxis = "y",
  method = "dotdensity",
  binpositions = "bygroup",
  stackdir = "up",
  stackratio = 1,
  dotsize = 1,
  stackgroups = FALSE,
  origin = NULL,
  right = TRUE,
  width = NULL,
  drop = FALSE,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_half_dotplot_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code> or
<code><a href="ggplot2.html#topic+aes_">aes_()</a></code>. If specified and <code>inherit.aes = TRUE</code> (the
default), it is combined with the default mapping at the top level of the
plot. You must supply <code>mapping</code> if there is no plot mapping.</p>
</td></tr>
<tr><td><code id="geom_half_dotplot_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_half_dotplot_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of
a call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="geom_half_dotplot_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_half_dotplot_+3A_binwidth">binwidth</code></td>
<td>
<p>When <code>method</code> is &quot;dotdensity&quot;, this specifies maximum bin
width. When <code>method</code> is &quot;histodot&quot;, this specifies bin width.
Defaults to 1/30 of the range of the data</p>
</td></tr>
<tr><td><code id="geom_half_dotplot_+3A_binaxis">binaxis</code></td>
<td>
<p>The axis to bin along, &quot;x&quot; (default) or &quot;y&quot;</p>
</td></tr>
<tr><td><code id="geom_half_dotplot_+3A_method">method</code></td>
<td>
<p>&quot;dotdensity&quot; (default) for dot-density binning, or
&quot;histodot&quot; for fixed bin widths (like stat_bin)</p>
</td></tr>
<tr><td><code id="geom_half_dotplot_+3A_binpositions">binpositions</code></td>
<td>
<p>When <code>method</code> is &quot;dotdensity&quot;, &quot;bygroup&quot; (default)
determines positions of the bins for each group separately. &quot;all&quot; determines
positions of the bins with all the data taken together; this is used for
aligning dot stacks across multiple groups.</p>
</td></tr>
<tr><td><code id="geom_half_dotplot_+3A_stackdir">stackdir</code></td>
<td>
<p>Which direction to stack the dots. &quot;up&quot; (default) places the half-dotplot on the right side. &quot;down&quot; on the left side.</p>
</td></tr>
<tr><td><code id="geom_half_dotplot_+3A_stackratio">stackratio</code></td>
<td>
<p>how close to stack the dots. Default is 1, where dots
just touch. Use smaller values for closer, overlapping dots.</p>
</td></tr>
<tr><td><code id="geom_half_dotplot_+3A_dotsize">dotsize</code></td>
<td>
<p>The diameter of the dots relative to <code>binwidth</code>, default 1.</p>
</td></tr>
<tr><td><code id="geom_half_dotplot_+3A_stackgroups">stackgroups</code></td>
<td>
<p>should dots be stacked across groups? This has the effect
that <code>position = "stack"</code> should have, but can't (because this geom has
some odd properties).</p>
</td></tr>
<tr><td><code id="geom_half_dotplot_+3A_origin">origin</code></td>
<td>
<p>When <code>method</code> is &quot;histodot&quot;, origin of first bin</p>
</td></tr>
<tr><td><code id="geom_half_dotplot_+3A_right">right</code></td>
<td>
<p>When <code>method</code> is &quot;histodot&quot;, should intervals be closed
on the right (a, b], or not [a, b)</p>
</td></tr>
<tr><td><code id="geom_half_dotplot_+3A_width">width</code></td>
<td>
<p>When <code>binaxis</code> is &quot;y&quot;, the spacing of the dot stacks
for dodging.</p>
</td></tr>
<tr><td><code id="geom_half_dotplot_+3A_drop">drop</code></td>
<td>
<p>If TRUE, remove all bins with zero counts</p>
</td></tr>
<tr><td><code id="geom_half_dotplot_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_half_dotplot_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_half_dotplot_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are two basic approaches: <em>dot-density</em> and <em>histodot</em>.
With dot-density binning, the bin positions are determined by the data and
'binwidth', which is the maximum width of each bin. See Wilkinson
(1999) for details on the dot-density binning algorithm. With histodot
binning, the bins have fixed positions and fixed widths, much like a
histogram.
</p>
<p>When binning along the x axis and stacking along the y axis, the numbers on
y axis are not meaningful, due to technical limitations of ggplot2. You can
hide the y axis, as in one of the examples, or manually scale it
to match the number of dots.
</p>


<h3>Computed variables</h3>


<dl>
<dt>x</dt><dd><p>center of each bin, if binaxis is &quot;x&quot;</p>
</dd>
<dt>y</dt><dd><p>center of each bin, if binaxis is &quot;x&quot;</p>
</dd>
<dt>binwidth</dt><dd><p>max width of each bin if method is &quot;dotdensity&quot;;
width of each bin if method is &quot;histodot&quot;</p>
</dd>
<dt>count</dt><dd><p>number of points in bin</p>
</dd>
<dt>ncount</dt><dd><p>count, scaled to maximum of 1</p>
</dd>
<dt>density</dt><dd><p>density of points in bin, scaled to integrate to 1,
if method is &quot;histodot&quot;</p>
</dd>
<dt>ndensity</dt><dd><p>density, scaled to maximum of 1, if method is &quot;histodot&quot;</p>
</dd>
</dl>



<h3>References</h3>

<p>Wilkinson, L. (1999) Dot plots. The American Statistician,
53(3), 276-281.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ggplot(iris, aes(x = Species, y = Petal.Width, fill = Species)) + 
  geom_half_dotplot(stackratio = .5, method = "histodot") 
</code></pre>

<hr>
<h2 id='geom_half_point'>Points with jitter for half geoms.</h2><span id='topic+geom_half_point'></span>

<h3>Description</h3>

<p>Points with jitter for half geoms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_half_point(
  mapping = NULL,
  data = NULL,
  stat = "HalfPoint",
  position = "dodge2",
  ...,
  side = "r",
  transformation = position_jitter(),
  range_scale = 0.75,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_half_point_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code> or
<code><a href="ggplot2.html#topic+aes_">aes_()</a></code>. If specified and <code>inherit.aes = TRUE</code> (the
default), it is combined with the default mapping at the top level of the
plot. You must supply <code>mapping</code> if there is no plot mapping.</p>
</td></tr>
<tr><td><code id="geom_half_point_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_half_point_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, as a string.</p>
</td></tr>
<tr><td><code id="geom_half_point_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of
a call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="geom_half_point_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_half_point_+3A_side">side</code></td>
<td>
<p>The side on which to draw the half violin plot. &quot;l&quot; for left, &quot;r&quot; for right, defaults to &quot;l&quot;.</p>
</td></tr>
<tr><td><code id="geom_half_point_+3A_transformation">transformation</code></td>
<td>
<p>An evaluated 'position_*()' function yielding a 'Position' object with specified parameters to calculate the transformation of the points. Defaults to 'ggplot2::position_jitter()'.</p>
</td></tr>
<tr><td><code id="geom_half_point_+3A_range_scale">range_scale</code></td>
<td>
<p>If no 'width' argument is specified in 'transformation', 'range_scale' is used to determine the width of the jitter. Defaults to '0.75', which is half of the allotted space for the jitter-points, whereas '1' would use all of the allotted space.</p>
</td></tr>
<tr><td><code id="geom_half_point_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_half_point_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_half_point_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>ggplot(iris, aes(x = Species, y = Petal.Width, fill = Species)) + 
  geom_half_point()
  
ggplot(iris, aes(x = Species, y = Petal.Width, fill = Species)) + 
  geom_half_point(side = "l")
</code></pre>

<hr>
<h2 id='geom_half_point_panel'>Points with jitter for half geoms. Unlike 'geom_half_point', 'geom_half_point_panel' does not dodge different grouping aesthetics. This allows multiple groups in a single cloud of points (see examples).</h2><span id='topic+geom_half_point_panel'></span>

<h3>Description</h3>

<p>Points with jitter for half geoms. Unlike 'geom_half_point', 'geom_half_point_panel' does not dodge different grouping aesthetics. This allows multiple groups in a single cloud of points (see examples).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_half_point_panel(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  side = "r",
  transformation = position_jitter(),
  range_scale = 0.75,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_half_point_panel_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code> or
<code><a href="ggplot2.html#topic+aes_">aes_()</a></code>. If specified and <code>inherit.aes = TRUE</code> (the
default), it is combined with the default mapping at the top level of the
plot. You must supply <code>mapping</code> if there is no plot mapping.</p>
</td></tr>
<tr><td><code id="geom_half_point_panel_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_half_point_panel_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, as a string.</p>
</td></tr>
<tr><td><code id="geom_half_point_panel_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of
a call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="geom_half_point_panel_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_half_point_panel_+3A_side">side</code></td>
<td>
<p>The side on which to draw the half violin plot. &quot;l&quot; for left, &quot;r&quot; for right, defaults to &quot;l&quot;.</p>
</td></tr>
<tr><td><code id="geom_half_point_panel_+3A_transformation">transformation</code></td>
<td>
<p>An evaluated 'position_*()' function yielding a 'Position' object with specified parameters to calculate the transformation of the points. Defaults to 'ggplot2::position_jitter()'.</p>
</td></tr>
<tr><td><code id="geom_half_point_panel_+3A_range_scale">range_scale</code></td>
<td>
<p>If no 'width' argument is specified in 'transformation', 'range_scale' is used to determine the width of the jitter. Defaults to '0.75', which is half of the allotted space for the jitter-points, whereas '1' would use all of the allotted space.</p>
</td></tr>
<tr><td><code id="geom_half_point_panel_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_half_point_panel_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_half_point_panel_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>ggplot(iris, aes(y = Sepal.Width)) +
  geom_half_boxplot() +
  geom_half_point_panel(aes(x = 0.5, color = Species), range_scale = .5) +
  theme_classic()
</code></pre>

<hr>
<h2 id='geom_half_violin'>Half Violin plot</h2><span id='topic+geom_half_violin'></span><span id='topic+stat_half_ydensity'></span>

<h3>Description</h3>

<p>A violin plot is a compact display of a continuous distribution. It is a
blend of [geom_boxplot()] and [geom_density()]: a
violin plot is a mirrored density plot displayed in the same way as a
boxplot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_half_violin(
  mapping = NULL,
  data = NULL,
  stat = "half_ydensity",
  position = "dodge",
  ...,
  side = "l",
  nudge = 0,
  draw_quantiles = NULL,
  trim = TRUE,
  scale = "area",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_half_ydensity(
  mapping = NULL,
  data = NULL,
  geom = "half_violin",
  position = "dodge",
  ...,
  bw = "nrd0",
  adjust = 1,
  kernel = "gaussian",
  trim = TRUE,
  scale = "area",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_half_violin_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code> or
<code><a href="ggplot2.html#topic+aes_">aes_()</a></code>. If specified and <code>inherit.aes = TRUE</code> (the
default), it is combined with the default mapping at the top level of the
plot. You must supply <code>mapping</code> if there is no plot mapping.</p>
</td></tr>
<tr><td><code id="geom_half_violin_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_half_violin_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of
a call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="geom_half_violin_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_half_violin_+3A_side">side</code></td>
<td>
<p>The side on which to draw the half violin plot. &quot;l&quot; for left, &quot;r&quot; for right, defaults to &quot;l&quot;.</p>
</td></tr>
<tr><td><code id="geom_half_violin_+3A_nudge">nudge</code></td>
<td>
<p>Add space between the violinplot and the middle of the space allotted to a given factor on the x-axis.</p>
</td></tr>
<tr><td><code id="geom_half_violin_+3A_draw_quantiles">draw_quantiles</code></td>
<td>
<p>If <code>not(NULL)</code> (default), draw horizontal lines
at the given quantiles of the density estimate.</p>
</td></tr>
<tr><td><code id="geom_half_violin_+3A_trim">trim</code></td>
<td>
<p>If <code>TRUE</code> (default), trim the tails of the violins
to the range of the data. If <code>FALSE</code>, don't trim the tails.</p>
</td></tr>
<tr><td><code id="geom_half_violin_+3A_scale">scale</code></td>
<td>
<p>if &quot;area&quot; (default), all violins have the same area (before trimming
the tails). If &quot;count&quot;, areas are scaled proportionally to the number of
observations. If &quot;width&quot;, all violins have the same maximum width.</p>
</td></tr>
<tr><td><code id="geom_half_violin_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_half_violin_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_half_violin_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_half_violin_+3A_geom">geom</code>, <code id="geom_half_violin_+3A_stat">stat</code></td>
<td>
<p>Use to override the default connection between
<code>geom_violin()</code> and <code>stat_ydensity()</code>.</p>
</td></tr>
<tr><td><code id="geom_half_violin_+3A_bw">bw</code></td>
<td>
<p>The smoothing bandwidth to be used.
If numeric, the standard deviation of the smoothing kernel.
If character, a rule to choose the bandwidth, as listed in
<code><a href="stats.html#topic+bandwidth">stats::bw.nrd()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_half_violin_+3A_adjust">adjust</code></td>
<td>
<p>A multiplicate bandwidth adjustment. This makes it possible
to adjust the bandwidth while still using the a bandwidth estimator.
For example, <code>adjust = 1/2</code> means use half of the default bandwidth.</p>
</td></tr>
<tr><td><code id="geom_half_violin_+3A_kernel">kernel</code></td>
<td>
<p>Kernel. See list of available kernels in <code><a href="stats.html#topic+density">density()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The half-violin plot accepts an optional 'split' aesthethic to compare 
data separated by a binary variable side-by-side.
</p>


<h3>References</h3>

<p>Hintze, J. L., Nelson, R. D. (1998) Violin Plots: A Box
Plot-Density Trace Synergism. The American Statistician 52, 181-184.
</p>


<h3>See Also</h3>

<p>[geom_half_violin()] for examples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ggplot(iris, aes(x = Species, y = Petal.Width, fill = Species)) +
  geom_half_violin()

ggplot(iris, aes(x = Species, y = Petal.Width, fill = Species)) +
  geom_half_violin(side = "r")
  
ggplot() +
  geom_half_violin(
    data = ToothGrowth, 
    aes(x = as.factor(dose), y = len, split = supp, fill = supp),
    position = "identity"
  ) + 
  theme_minimal()  
  
ggplot(ToothGrowth, aes(x = supp, y = len, color = supp)) + 
  geom_half_violin(side = c("l", "r"))

ggplot(data = ToothGrowth, aes(x = 1, y = len)) +
  geom_half_point(aes(y = len), side = "l") +
  geom_half_violin(aes(y = len), side = "r") +
  coord_flip()

</code></pre>

<hr>
<h2 id='GeomHalfDotplot'>gghalves extensions to ggplot2</h2><span id='topic+GeomHalfDotplot'></span><span id='topic+GeomHalfBoxplot'></span><span id='topic+GeomHalfPoint'></span><span id='topic+GeomHalfPointPanel'></span><span id='topic+GeomHalfViolin'></span><span id='topic+StatHalfBindot'></span><span id='topic+StatHalfPoint'></span><span id='topic+StatHalfYdensity'></span><span id='topic+gghalves-extensions'></span>

<h3>Description</h3>

<p>gghalves extensions to ggplot2
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
