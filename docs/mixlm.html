<!DOCTYPE html><html><head><title>Help for package mixlm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mixlm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#anova_reg'>
<p>Analysis of variance for regression.</p></a></li>
<li><a href='#anova.lmm'>
<p>Analysis of variance (sequential SS)</p></a></li>
<li><a href='#Anova.lmm'>
<p>Analysis of variance with SS type II or III (including mixed models).</p></a></li>
<li><a href='#AnovaMix'>
<p>Mixed model least squares analysis of variance (mixed ANOVA).</p></a></li>
<li><a href='#best.subsets'>
<p>F-test based best subset selection.</p></a></li>
<li><a href='#CIgrandMean'>
<p>Confidence interval for the grand mean of a linear model</p></a></li>
<li><a href='#confusion'>
<p>Confusion matrix.</p></a></li>
<li><a href='#contr.weighted'>
<p>Contrast matrix for weighted effect coding</p></a></li>
<li><a href='#effect.labels'>
<p>Create new effect labels for <code>lm</code></p></a></li>
<li><a href='#forward'>
<p>F-test based model effect selection for linear models.</p></a></li>
<li><a href='#fparse'>
<p>Effects of formulas.</p></a></li>
<li><a href='#glm'><p>Fitting Generalized Linear Models</p></a></li>
<li><a href='#is.balanced'>
<p>Balance cheking of models.</p></a></li>
<li><a href='#lm'><p>Fitting Linear Models</p></a></li>
<li><a href='#plotprops'>
<p>Property plots for relevant component analysis</p></a></li>
<li><a href='#PRESS'>
<p>Prediction fits</p></a></li>
<li><a href='#print.AnovaMix'>
<p>Print method for objects of class(AnovaMix)</p></a></li>
<li><a href='#print.summary.lmm'><p>Summarizing Linear Model Fits</p></a></li>
<li><a href='#prop.test.ordinary'><p>Test of Equal or Given Proportions in text-book version</p></a></li>
<li><a href='#rparse'>
<p>Removes function r() from formulas.</p></a></li>
<li><a href='#simple.glht'>
<p>Pairwise comparison with multiple testing compensation.</p></a></li>
<li><a href='#spearson'>
<p>Standardized Pearson residuals</p></a></li>
<li><a href='#t_test'>
<p>Text book versions of t-tests and z-tests.</p></a></li>
<li><a href='#tally'>
<p>Tally of discrete numbers</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Mixed Model ANOVA and Statistics for Education</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-08</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kristian Hovde Liland &lt;kristian.liland@nmbu.no&gt;</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Description:</td>
<td>The main functions perform mixed models analysis by least squares
    or REML by adding the function r() to formulas of lm() and glm(). A collection of
    text-book statistics for higher education is also included, e.g. modifications
    of the functions lm(), glm() and associated summaries from the package 'stats'.</td>
</tr>
<tr>
<td>Imports:</td>
<td>car, pls, multcomp, pracma, leaps</td>
</tr>
<tr>
<td>Suggests:</td>
<td>lme4</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/khliland/mixlm/">https://github.com/khliland/mixlm/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/khliland/mixlm/issues/">https://github.com/khliland/mixlm/issues/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-08 08:23:50 UTC; kristian</td>
</tr>
<tr>
<td>Author:</td>
<td>Kristian Hovde Liland [aut, cre],
  Solve Sæbø¸ [ctb],
  R-Core [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-08 14:00:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='anova_reg'>
Analysis of variance for regression.
</h2><span id='topic+anova_reg'></span>

<h3>Description</h3>

<p>Summarizes all effects in one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anova_reg(lm.object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anova_reg_+3A_lm.object">lm.object</code></td>
<td>

<p>an object of class <code>lm</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns data.frame containing analysis of variance
</p>


<h3>Author(s)</h3>

<p>Kristian Hovde Liland
</p>


<h3>Examples</h3>

<pre><code class='language-R'>anova_reg(lm(y~x, data=data.frame(y=1:4,x=rnorm(4))))
</code></pre>

<hr>
<h2 id='anova.lmm'>
Analysis of variance (sequential SS)
</h2><span id='topic+anova.lmm'></span><span id='topic+anova'></span>

<h3>Description</h3>

<p>Wrapper for <code>anova.lm</code> in package <code>stats</code> that halts execution
if unsupported input is detected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmm'
anova(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anova.lmm_+3A_object">object</code></td>
<td>
<p>object fitted by <code>lm</code>, <code>lmer</code> or similar.</p>
</td></tr>
<tr><td><code id="anova.lmm_+3A_...">...</code></td>
<td>
<p>possible additional argument to underlying functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns appropriate analysis of variance or halts if unsupported input is detected.
</p>


<h3>Author(s)</h3>

<p>Kristian Hovde Liland
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lm">lm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mixlm &lt;- lm(y~x*r(z),
			data = data.frame(y = rnorm(8),
							  x = factor(c(rep(1,4),rep(0,4))),
							  z = factor(rep(c(1,0),4))))
anova(mixlm)
</code></pre>

<hr>
<h2 id='Anova.lmm'>
Analysis of variance with SS type II or III (including mixed models).
</h2><span id='topic+Anova'></span><span id='topic+Anova.lmm'></span>

<h3>Description</h3>

<p>Replacement for <code>Anova.lm</code> in package <code>car</code>. This
version adds support for random effects when needed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmm'
Anova(mod, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Anova.lmm_+3A_mod">mod</code></td>
<td>
<p><code>lm</code>, <code>aov</code>, <code>glm</code>, <code>multinom</code>, <code>polr</code>
<code>mlm</code>, <code>coxph</code>, <code>lme</code>, <code>mer</code>, <code>svyglm</code> or other suitable model object.</p>
</td></tr>
<tr><td><code id="Anova.lmm_+3A_...">...</code></td>
<td>
<p>do not use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns appropriate analysis of variance or halts if unsupported input is detected.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a>.
Extended by Kristian Hovde Liland.
</p>


<h3>See Also</h3>

<p><code><a href="car.html#topic+Anova">Anova</a></code>, <code><a href="#topic+print.AnovaMix">print.AnovaMix</a></code>, <code><a href="#topic+AnovaMix">AnovaMix</a></code>, <code><a href="#topic+lm">lm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dataset &lt;- data.frame(y = rnorm(8),
  x = factor(c(rep(1,4),rep(0,4))),
  z = factor(rep(c(1,0),4)))
mixlm &lt;- lm(y~x*r(z),
  data = dataset)
Anova(mixlm, type="III")
</code></pre>

<hr>
<h2 id='AnovaMix'>
Mixed model least squares analysis of variance (mixed ANOVA).
</h2><span id='topic+AnovaMix'></span>

<h3>Description</h3>

<p>Uses output from lm() in mixlm package to compute ANOVA table,
variance components and errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AnovaMix(object, SStype)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AnovaMix_+3A_object">object</code></td>
<td>
<p> object fitted by lm (mixlm package) containing at least one random effect.</p>
</td></tr>
<tr><td><code id="AnovaMix_+3A_sstype">SStype</code></td>
<td>
<p> type of sums-of-squares (I/II/III) for Analysis of Variance.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>AnovaMix</code> can either be invoked directly or through the Anova() function (with type III error).
</p>


<h3>Value</h3>

<table>
<tr><td><code>lm</code></td>
<td>
<p>linear model fitted by lm in package mixlm.</p>
</td></tr>
<tr><td><code>anova</code></td>
<td>
<p>ANOVA table.</p>
</td></tr>
<tr><td><code>err.terms</code></td>
<td>
<p><code>list</code> of denominator information for F tests.</p>
</td></tr>
<tr><td><code>denom.df</code></td>
<td>
<p><code>numeric</code> of denominator degrees of freedom for F tests.</p>
</td></tr>
<tr><td><code>restricted</code></td>
<td>
<p><code>logical</code> indicating if ANOVA used restricted modelling.</p>
</td></tr>
<tr><td><code>exp.mean.sq</code></td>
<td>
<p><code>character</code> containing expected mean squares.</p>
</td></tr>
<tr><td><code>var.comps</code></td>
<td>
<p><code>numeric</code> containing variance components.</p>
</td></tr>
<tr><td><code>random.effects</code></td>
<td>
<p><code>character</code> containing the random effects.</p>
</td></tr>
<tr><td><code>ind.randoms</code></td>
<td>
<p><code>numeric</code> with indices of random effects in the model.</p>
</td></tr>
<tr><td><code>formula.text</code></td>
<td>
<p><code>character</code> containing all effects of the model.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Only balanced models are fully supported.
</p>


<h3>Author(s)</h3>

<p>Kristian Hovde Liland
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.AnovaMix">print.AnovaMix</a></code>, <code><a href="#topic+Anova">Anova</a></code>, <code><a href="#topic+lm">lm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mydata &lt;- data.frame(y = rnorm(12),
							  x = factor(c(rep(2,4),rep(1,4),rep(0,4))),
							  z = factor(rep(c(1,0),6)))
mixlm &lt;- lm(y~x*r(z),
			data = mydata)
Anova(mixlm,type="III")
</code></pre>

<hr>
<h2 id='best.subsets'>
F-test based best subset selection.
</h2><span id='topic+best.subsets'></span>

<h3>Description</h3>

<p>Adaptation of existing methods based on AIC/BIC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>best.subsets(model, nbest = 5, nvmax, digits, force.in = "NULL")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="best.subsets_+3A_model">model</code></td>
<td>

<p>object class <code>lm</code> to select effects from.
</p>
</td></tr>
<tr><td><code id="best.subsets_+3A_nbest">nbest</code></td>
<td>

<p><code>numeric</code> indicating number of models to report of each size.
</p>
</td></tr>
<tr><td><code id="best.subsets_+3A_nvmax">nvmax</code></td>
<td>

<p><code>numeric</code> maximum size of subsets to examine.
</p>
</td></tr>
<tr><td><code id="best.subsets_+3A_digits">digits</code></td>
<td>

<p><code>numeric</code> giving number of digits in format of output.
</p>
</td></tr>
<tr><td><code id="best.subsets_+3A_force.in">force.in</code></td>
<td>

<p><code>character</code> vector indicating effects to keep in all models.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>F-based versions of built in subset method.
</p>


<h3>Value</h3>

<p>No return, only print.
</p>


<h3>Author(s)</h3>

<p>Kristian Hovde Liland
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- data.frame(y = rnorm(8),
				   x = factor(c('a','a','a','a','b','b','b','b')),
				   z = factor(c('a','a','b','b','a','a','b','b')))
mod &lt;- lm(y ~ x + z, data=data)
best.subsets(mod)
</code></pre>

<hr>
<h2 id='CIgrandMean'>
Confidence interval for the grand mean of a linear model
</h2><span id='topic+CIgrandMean'></span><span id='topic+print.CIgm'></span>

<h3>Description</h3>

<p>This function estimates the confidence interval for 
the grand mean of a balanced linear (mixed) model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CIgrandMean(object, alpha = 0.05)
## S3 method for class 'CIgm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CIgrandMean_+3A_object">object</code></td>
<td>

<p>An <code>lm</code> object possibly containing random effects.
</p>
</td></tr>
<tr><td><code id="CIgrandMean_+3A_alpha">alpha</code></td>
<td>

<p>A scalar significance level for the confidence interval.
</p>
</td></tr>
<tr><td><code id="CIgrandMean_+3A_x">x</code></td>
<td>

<p>An object returned from <code>CIgrandMean</code>.
</p>
</td></tr>
<tr><td><code id="CIgrandMean_+3A_...">...</code></td>
<td>

<p>Additional arguments (not used).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This implementation is only valid for models containing no
continuous effects and only balanced data.
</p>


<h3>Value</h3>

<p><code>CIgrandMean</code> returns a vector of interval endpoints and center.
<code>print.CIgm</code> has no return.
</p>


<h3>Author(s)</h3>

<p>Kristian Hovde Liland
</p>


<h3>References</h3>

<p>Suggestions are welcome.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
dataset   &lt;- data.frame(y=rnorm(8), x=factor(c(rep(1,4),rep(0,4))), z=factor(rep(c(1,0),4)))
mixlm &lt;- lm(y~x*r(z), data = dataset)
CIgrandMean(mixlm)
</code></pre>

<hr>
<h2 id='confusion'>
Confusion matrix.
</h2><span id='topic+confusion'></span>

<h3>Description</h3>

<p>Computes the confusion matrix of a classification
result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>confusion(true, predicted)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confusion_+3A_true">true</code></td>
<td>

<p>true classes.
</p>
</td></tr>
<tr><td><code id="confusion_+3A_predicted">predicted</code></td>
<td>

<p>predicted classes.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a pure print function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>true &lt;- c('a','a','b','b','c','c')
predicted &lt;- c('a','c','b','b','a','c')
confusion(true, predicted)
</code></pre>

<hr>
<h2 id='contr.weighted'>
Contrast matrix for weighted effect coding
</h2><span id='topic+contr.weighted'></span>

<h3>Description</h3>

<p>Weighted contrast coding for linear models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contr.weighted(x, base)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contr.weighted_+3A_x">x</code></td>
<td>
 <p><code>factor</code> for which a contrast matrix should be made.</p>
</td></tr>
<tr><td><code id="contr.weighted_+3A_base">base</code></td>
<td>
 <p><code>factor</code> level used as basis for contrast coding.
Default is the (first) level with maximum frequency.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Different from the contrasts made throught the <code>stats</code> package functions
this contrast requires a full <code>factor</code> vector as input rather than its
respective <code>levels</code> as weights are computed from the frequencies of the
<code>factor</code> <code>levels</code>.
</p>


<h3>Value</h3>

<p>A <code>matrix</code> with <code>n</code> rows and <code>n-1</code> values.
</p>


<h3>Note</h3>

<p><code>contr.weighted</code> cannot be used directly as a replacement for other
contrasts by name, but must be used via contrasts matrix computations.
</p>


<h3>Author(s)</h3>

<p>Kristian Hovde Liland
</p>


<h3>References</h3>

<p>Nieuwenhuis, R.; Grotenhuis, M.; Pelzer, B. Weighted Effect Coding for Observational Data with wec. R. J. 2017, 9, 477–485.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lm">lm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>balanced   &lt;- factor(c(rep("A", 3), rep("B", 3), rep("C", 3)))
unbalanced &lt;- factor(c(rep("A", 3), rep("B", 3), rep("C", 2)))
# Weighted coding when applied to balanced data
contr.weighted(balanced)
# Weighted coding when applied to unbalanced data (default base level)
contr.weighted(unbalanced)
# Weighted coding when applied to unbalanced data (base level = "C")
contr.weighted(unbalanced, "C")
</code></pre>

<hr>
<h2 id='effect.labels'>
Create new effect labels for <code>lm</code>
</h2><span id='topic+effect.labels'></span>

<h3>Description</h3>

<p>Alternative notation of effect labels including levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>effect.labels(t, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="effect.labels_+3A_t">t</code></td>
<td>

<p>Terms object.
</p>
</td></tr>
<tr><td><code id="effect.labels_+3A_data">data</code></td>
<td>

<p>Corresponding model.matrix.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>names</code></td>
<td>
<p>Character vector of effect labels.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kristian Hovde Liland
</p>

<hr>
<h2 id='forward'>
F-test based model effect selection for linear models.
</h2><span id='topic+forward'></span><span id='topic+wideForward'></span><span id='topic+print.WF'></span><span id='topic+backward'></span><span id='topic+stepWise'></span><span id='topic+stepWiseBack'></span>

<h3>Description</h3>

<p>Adaptation of existing methods based on AIC/BIC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forward(model, alpha = 0.2, full = FALSE, force.in)
backward(model, alpha = 0.2, full = FALSE, hierarchy = TRUE, force.in)
stepWise(model, alpha.enter = 0.15, alpha.remove = 0.15, full = FALSE)
stepWiseBack(model, alpha.remove = 0.15, alpha.enter = 0.15, full = FALSE)
wideForward(formula, data, alpha = 0.2, force.in = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forward_+3A_model">model</code></td>
<td>

<p>object class <code>lm</code> to select effects from.
</p>
</td></tr>
<tr><td><code id="forward_+3A_formula">formula</code></td>
<td>

<p><code>formula</code> specifying all possible effects.
</p>
</td></tr>
<tr><td><code id="forward_+3A_data">data</code></td>
<td>

<p><code>data.frame</code> corresponding to formula.
</p>
</td></tr>
<tr><td><code id="forward_+3A_alpha">alpha</code></td>
<td>

<p><code>numeric</code> p-value cut-off for inclusion/exclusion.
</p>
</td></tr>
<tr><td><code id="forward_+3A_full">full</code></td>
<td>

<p><code>logical</code> indicating extended output of forward/backward selection.
</p>
</td></tr>
<tr><td><code id="forward_+3A_force.in">force.in</code></td>
<td>

<p><code>character</code> vector indicating effects to keep in all models.
</p>
</td></tr>
<tr><td><code id="forward_+3A_alpha.enter">alpha.enter</code></td>
<td>

<p><code>numeric</code> p-value cut-off for inclusion.
</p>
</td></tr>
<tr><td><code id="forward_+3A_alpha.remove">alpha.remove</code></td>
<td>

<p><code>numeric</code> p-value cut-off for exclusion.
</p>
</td></tr>
<tr><td><code id="forward_+3A_hierarchy">hierarchy</code></td>
<td>

<p><code>logical</code> indicating if hierarchy should be forced in backward selection.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>F-based versions of built in stepwise methods.
</p>


<h3>Value</h3>

<p>The final linear model after selection is returned.
</p>


<h3>Author(s)</h3>

<p>Kristian Hovde Liland
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(0)
data &lt;- data.frame(y = rnorm(8),
				   x = factor(c('a','a','a','a','b','b','b','b')),
				   z = factor(c('a','a','b','b','a','a','b','b')))
mod &lt;- lm(y ~ x + z, data=data)
forward(mod)
backward(mod)
stepWise(mod)
stepWiseBack(mod)

# Forward selection for wide matrices (large number of predictors)
set.seed(0)
mydata &lt;- data.frame(y = rnorm(6), X = matrix(rnorm(60),6,10))
fs &lt;- wideForward(y ~ ., mydata)
print(fs)

</code></pre>

<hr>
<h2 id='fparse'>
Effects of formulas.
</h2><span id='topic+fparse'></span>

<h3>Description</h3>

<p>Extracts all effects from a formula, even though inside functions or interactions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fparse(f)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fparse_+3A_f">f</code></td>
<td>
<p><code>formula</code> to be parsed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>character</code> vector containing all effects.
</p>


<h3>Author(s)</h3>

<p>Bjørn-Helge Mevik
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rparse">rparse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- formula(y~x*r(z))
fparse(f)
</code></pre>

<hr>
<h2 id='glm'>Fitting Generalized Linear Models</h2><span id='topic+glm'></span><span id='topic+print.glm'></span>

<h3>Description</h3>

<p><code>glm</code> is used to fit generalized linear models, specified by
giving a symbolic description of the linear predictor and a
description of the error distribution. 
The version of <code>glm</code> supplied by the package <code>mixlm</code>
parses to <code>glmer</code> for mixed modelling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glm(formula, family = gaussian, data, weights, subset,
    na.action, start = NULL, etastart, mustart, offset,
    control = list(...), model = TRUE, method = "glm.fit",
    x = FALSE, y = TRUE, contrasts = NULL, REML = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glm_+3A_formula">formula</code></td>
<td>
<p>an object of class <code>"<a href="stats.html#topic+formula">formula</a>"</code> (or one that
can be coerced to that class): a symbolic description of the
model to be fitted.  The details of model specification are given
under &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="glm_+3A_family">family</code></td>
<td>
<p>a description of the error distribution and link
function to be used in the model. This can be a character string
naming a family function, a family function or the result of a call
to a family function.  (See <code><a href="stats.html#topic+family">family</a></code> for details of
family functions.)</p>
</td></tr>
<tr><td><code id="glm_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object
coercible by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame) containing
the variables in the model.  If not found in <code>data</code>, the
variables are taken from <code>environment(formula)</code>,
typically the environment from which <code>glm</code> is called.</p>
</td></tr>
<tr><td><code id="glm_+3A_weights">weights</code></td>
<td>
<p>an optional vector of &lsquo;prior weights&rsquo; to be used
in the fitting process.  Should be <code>NULL</code> or a numeric vector.</p>
</td></tr>
<tr><td><code id="glm_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations
to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="glm_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen
when the data contain <code>NA</code>s.  The default is set by
the <code>na.action</code> setting of <code><a href="base.html#topic+options">options</a></code>, and is
<code><a href="stats.html#topic+na.fail">na.fail</a></code> if that is unset.  The &lsquo;factory-fresh&rsquo;
default is <code><a href="stats.html#topic+na.omit">na.omit</a></code>.  Another possible value is
<code>NULL</code>, no action.  Value <code><a href="stats.html#topic+na.exclude">na.exclude</a></code> can be useful.</p>
</td></tr>
<tr><td><code id="glm_+3A_start">start</code></td>
<td>
<p>starting values for the parameters in the linear predictor.</p>
</td></tr>
<tr><td><code id="glm_+3A_etastart">etastart</code></td>
<td>
<p>starting values for the linear predictor.</p>
</td></tr>
<tr><td><code id="glm_+3A_mustart">mustart</code></td>
<td>
<p>starting values for the vector of means.</p>
</td></tr>
<tr><td><code id="glm_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an <em>a priori</em> known
component to be included in the linear predictor during fitting.
This should be <code>NULL</code> or a numeric vector of length equal to
the number of cases.  One or more <code><a href="stats.html#topic+offset">offset</a></code> terms can be
included in the formula instead or as well, and if more than one is
specified their sum is used.  See <code><a href="stats.html#topic+model.offset">model.offset</a></code>.</p>
</td></tr>
<tr><td><code id="glm_+3A_control">control</code></td>
<td>
<p>a list of parameters for controlling the fitting
process.  For <code>glm.fit</code> this is passed to
<code><a href="stats.html#topic+glm.control">glm.control</a></code>.</p>
</td></tr>
<tr><td><code id="glm_+3A_model">model</code></td>
<td>
<p>a logical value indicating whether <em>model frame</em>
should be included as a component of the returned value.</p>
</td></tr>
<tr><td><code id="glm_+3A_method">method</code></td>
<td>
<p>the method to be used in fitting the model.  The default
method <code>"glm.fit"</code> uses iteratively reweighted least squares
(IWLS): the alternative <code>"model.frame"</code> returns the model frame
and does no fitting.
</p>
<p>User-supplied fitting functions can be supplied either as a function
or a character string naming a function, with a function which takes
the same arguments as <code>glm.fit</code>.  If specified as a character
string it is looked up from within the <span class="pkg">stats</span> namespace.
</p>
</td></tr>
<tr><td><code id="glm_+3A_x">x</code>, <code id="glm_+3A_y">y</code></td>
<td>
<p>For <code>glm</code>:
logical values indicating whether the response vector and model
matrix used in the fitting process should be returned as components
of the returned value.
</p>
<p>For <code>glm.fit</code>: <code>x</code> is a design matrix of dimension
<code>n * p</code>, and <code>y</code> is a vector of observations of length
<code>n</code>.
</p>
</td></tr>
<tr><td><code id="glm_+3A_contrasts">contrasts</code></td>
<td>
<p>an optional list. See the <code>contrasts.arg</code>
of <code>model.matrix.default</code>.</p>
</td></tr>
<tr><td><code id="glm_+3A_reml">REML</code></td>
<td>
<p> is used to invoke restricted maximum likelihood (TRUE)
or maximum likelihood (FALSE) estimation instead of least squares.</p>
</td></tr>
<tr><td><code id="glm_+3A_...">...</code></td>
<td>

<p>For <code>glm</code>: arguments to be used to form the default
<code>control</code> argument if it is not supplied directly.
</p>
<p>For <code>weights</code>: further arguments passed to or from other methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A typical predictor has the form <code>response ~ terms</code> where
<code>response</code> is the (numeric) response vector and <code>terms</code> is a
series of terms which specifies a linear predictor for
<code>response</code>.  For <code>binomial</code> and <code>quasibinomial</code>
families the response can also be specified as a <code><a href="base.html#topic+factor">factor</a></code>
(when the first level denotes failure and all others success) or as a
two-column matrix with the columns giving the numbers of successes and
failures.  A terms specification of the form <code>first + second</code>
indicates all the terms in <code>first</code> together with all the terms in
<code>second</code> with any duplicates removed.
</p>
<p>A specification of the form <code>first:second</code> indicates the the set
of terms obtained by taking the interactions of all terms in
<code>first</code> with all terms in <code>second</code>.  The specification
<code>first*second</code> indicates the <em>cross</em> of <code>first</code> and
<code>second</code>.  This is the same as <code>first + second +
  first:second</code>.
</p>
<p>The terms in the formula will be re-ordered so that main effects come
first, followed by the interactions, all second-order, all third-order
and so on: to avoid this pass a <code>terms</code> object as the formula.
</p>
<p>Non-<code>NULL</code> <code>weights</code> can be used to indicate that different
observations have different dispersions (with the values in
<code>weights</code> being inversely proportional to the dispersions); or
equivalently, when the elements of <code>weights</code> are positive
integers <code class="reqn">w_i</code>, that each response <code class="reqn">y_i</code> is the mean of
<code class="reqn">w_i</code> unit-weight observations.  For a binomial GLM prior weights
are used to give the number of trials when the response is the
proportion of successes: they would rarely be used for a Poisson GLM.
</p>
<p><code>glm.fit</code> is the workhorse function: it is not normally called
directly but can be more efficient where the response vector and
design matrix have already been calculated.
</p>
<p>If more than one of <code>etastart</code>, <code>start</code> and <code>mustart</code>
is specified, the first in the list will be used.  It is often
advisable to supply starting values for a <code><a href="stats.html#topic+quasi">quasi</a></code> family,
and also for families with unusual links such as <code>gaussian("log")</code>.
</p>
<p>All of <code>weights</code>, <code>subset</code>, <code>offset</code>, <code>etastart</code>
and <code>mustart</code> are evaluated in the same way as variables in
<code>formula</code>, that is first in <code>data</code> and then in the
environment of <code>formula</code>.
</p>
<p>For the background to warning messages about &lsquo;fitted probabilities
numerically 0 or 1 occurred&rsquo; for binomial GLMs, see Venables &amp;
Ripley (2002, pp. 197&ndash;8).
</p>


<h3>Value</h3>

<p><code>glm</code> returns an object of class inheriting from <code>"glm"</code>
which inherits from the class <code>"lm"</code>. See later in this section.
If a non-standard <code>method</code> is used, the object will also inherit
from the class (if any) returned by that function.
</p>
<p>The function <code><a href="base.html#topic+summary">summary</a></code> (i.e., <code><a href="stats.html#topic+summary.glm">summary.glm</a></code>) can
be used to obtain or print a summary of the results and the function
<code><a href="#topic+anova">anova</a></code> (i.e., <code><a href="stats.html#topic+anova.glm">anova.glm</a></code>)
to produce an analysis of variance table.
</p>
<p>The generic accessor functions <code><a href="stats.html#topic+coefficients">coefficients</a></code>,
<code>effects</code>, <code>fitted.values</code> and <code>residuals</code> can be used to
extract various useful features of the value returned by <code>glm</code>.
</p>
<p><code>weights</code> extracts a vector of weights, one for each case in the
fit (after subsetting and <code>na.action</code>).
</p>
<p>An object of class <code>"glm"</code> is a list containing at least the
following components:
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>a named vector of coefficients</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>the <em>working</em> residuals, that is the residuals
in the final iteration of the IWLS fit.  Since cases with zero
weights are omitted, their working residuals are <code>NA</code>.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>the fitted mean values, obtained by transforming
the linear predictors by the inverse of the link function.</p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p>the numeric rank of the fitted linear model.</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>the <code><a href="stats.html#topic+family">family</a></code> object used.</p>
</td></tr>
<tr><td><code>linear.predictors</code></td>
<td>
<p>the linear fit on link scale.</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>up to a constant, minus twice the maximized
log-likelihood.  Where sensible, the constant is chosen so that a
saturated model has deviance zero.</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>A version of Akaike's <em>An Information Criterion</em>,
minus twice the maximized log-likelihood plus twice the number of
parameters, computed by the <code>aic</code> component of the family.
For binomial and Poison families the dispersion is
fixed at one and the number of parameters is the number of
coefficients. For gaussian, Gamma and inverse gaussian families the
dispersion is estimated from the residual deviance, and the number
of parameters is the number of coefficients plus one.  For a
gaussian family the MLE of the dispersion is used so this is a valid
value of AIC, but for Gamma and inverse gaussian families it is not.
For families fitted by quasi-likelihood the value is <code>NA</code>.</p>
</td></tr>
<tr><td><code>null.deviance</code></td>
<td>
<p>The deviance for the null model, comparable with
<code>deviance</code>. The null model will include the offset, and an
intercept if there is one in the model.  Note that this will be
incorrect if the link function depends on the data other than
through the fitted mean: specify a zero offset to force a correct
calculation.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>the number of iterations of IWLS used.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>the <em>working</em> weights, that is the weights
in the final iteration of the IWLS fit.</p>
</td></tr>
<tr><td><code>prior.weights</code></td>
<td>
<p>the weights initially supplied, a vector of
<code>1</code>s if none were.</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>the residual degrees of freedom.</p>
</td></tr>
<tr><td><code>df.null</code></td>
<td>
<p>the residual degrees of freedom for the null model.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>if requested (the default) the <code>y</code> vector
used. (It is a vector even for a binomial model.)</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>if requested, the model matrix.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>if requested (the default), the model frame.</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>logical. Was the IWLS algorithm judged to have converged?</p>
</td></tr>
<tr><td><code>boundary</code></td>
<td>
<p>logical. Is the fitted value on the boundary of the
attainable values?</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>the formula supplied.</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>the <code><a href="stats.html#topic+terms">terms</a></code> object used.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>the <code>data argument</code>.</p>
</td></tr>
<tr><td><code>offset</code></td>
<td>
<p>the offset vector used.</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>the value of the <code>control</code> argument used.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>the name of the fitter function used, currently always
<code>"glm.fit"</code>.</p>
</td></tr>
<tr><td><code>contrasts</code></td>
<td>
<p>(where relevant) the contrasts used.</p>
</td></tr>
<tr><td><code>xlevels</code></td>
<td>
<p>(where relevant) a record of the levels of the factors
used in fitting.</p>
</td></tr>
<tr><td><code>na.action</code></td>
<td>
<p>(where relevant) information returned by
<code><a href="stats.html#topic+model.frame">model.frame</a></code> on the special handling of <code>NA</code>s.</p>
</td></tr>
</table>
<p>In addition, non-empty fits will have components <code>qr</code>, <code>R</code>
and <code>effects</code> relating to the final weighted linear fit.
</p>
<p>Objects of class <code>"glm"</code> are normally of class <code>c("glm",
    "lm")</code>, that is inherit from class <code>"lm"</code>, and well-designed
methods for class <code>"lm"</code> will be applied to the weighted linear
model at the final iteration of IWLS.  However, care is needed, as
extractor functions for class <code>"glm"</code> such as
<code><a href="stats.html#topic+residuals">residuals</a></code> and <code>weights</code> do <b>not</b> just pick out
the component of the fit with the same name.
</p>
<p>If a <code><a href="stats.html#topic+binomial">binomial</a></code> <code>glm</code> model was specified by giving a
two-column response, the weights returned by <code>prior.weights</code> are
the total numbers of cases (factored by the supplied case weights) and
the component <code>y</code> of the result is the proportion of successes.
</p>


<h3>Fitting functions</h3>

<p>The argument <code>method</code> serves two purposes.  One is to allow the
model frame to be recreated with no fitting.  The other is to allow
the default fitting function <code>glm.fit</code> to be replaced by a
function which takes the same arguments and uses a different fitting
algorithm.  If <code>glm.fit</code> is supplied as a character string it is
used to search for a function of that name, starting in the
<span class="pkg">stats</span> namespace.
</p>
<p>The class of the object return by the fitter (if any) will be
prepended to the class returned by <code>glm</code>.
</p>


<h3>Author(s)</h3>

<p>The original <span class="rlang"><b>R</b></span> implementation of <code>glm</code> was written by Simon
Davies working for Ross Ihaka at the University of Auckland, but has
since been extensively re-written by members of the R Core team.
</p>
<p>The design was inspired by the S function of the same name described
in Hastie &amp; Pregibon (1992).
</p>
<p>Mixed model additions by Kristian Hovde Liland.
</p>


<h3>References</h3>

<p>Dobson, A. J. (1990)
<em>An Introduction to Generalized Linear Models.</em>
London: Chapman and Hall.
</p>
<p>Hastie, T. J. and Pregibon, D. (1992)
<em>Generalized linear models.</em>
Chapter 6 of <em>Statistical Models in S</em>
eds J. M. Chambers and T. J. Hastie, Wadsworth &amp; Brooks/Cole.
</p>
<p>McCullagh P. and Nelder, J. A. (1989)
<em>Generalized Linear Models.</em>
London: Chapman and Hall.
</p>
<p>Venables, W. N. and Ripley, B. D. (2002)
<em>Modern Applied Statistics with S.</em>
New York: Springer.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+anova.glm">anova.glm</a></code>, <code><a href="stats.html#topic+summary.glm">summary.glm</a></code>, etc. for
<code>glm</code> methods,
and the generic functions <code><a href="#topic+anova">anova</a></code>, <code><a href="base.html#topic+summary">summary</a></code>,
<code><a href="stats.html#topic+effects">effects</a></code>, <code><a href="stats.html#topic+fitted.values">fitted.values</a></code>,
and <code><a href="stats.html#topic+residuals">residuals</a></code>.
</p>
<p><code><a href="#topic+lm">lm</a></code> for non-generalized <em>linear</em> models (which SAS
calls GLMs, for &lsquo;general&rsquo; linear models).
</p>
<p><code><a href="stats.html#topic+loglin">loglin</a></code> and <code><a href="MASS.html#topic+loglm">loglm</a></code> (package
MASS) for fitting log-linear models (which binomial and
Poisson GLMs are) to contingency tables.
</p>
<p><code>bigglm</code> in package biglm for an alternative
way to fit GLMs to large datasets (especially those with many cases).
</p>
<p><code><a href="datasets.html#topic+esoph">esoph</a></code>, <code><a href="datasets.html#topic+infert">infert</a></code> and
<code><a href="stats.html#topic+predict.glm">predict.glm</a></code> have examples of fitting binomial glms.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Dobson (1990) Page 93: Randomized Controlled Trial :
counts &lt;- c(18,17,15,20,10,20,25,13,12)
outcome &lt;- gl(3,1,9)
treatment &lt;- gl(3,3)
print(d.AD &lt;- data.frame(treatment, outcome, counts))
glm.D93 &lt;- glm(counts ~ outcome + treatment, family=poisson())
anova(glm.D93)

# A Gamma example, from McCullagh &amp; Nelder (1989, pp. 300-2)
clotting &lt;- data.frame(
    u = c(5,10,15,20,30,40,60,80,100),
    lot1 = c(118,58,42,35,27,25,21,19,18),
    lot2 = c(69,35,26,21,18,16,13,12,12))
summary(glm(lot1 ~ log(u), data=clotting, family=Gamma))
summary(glm(lot2 ~ log(u), data=clotting, family=Gamma))

# Mixed model example
dataset   &lt;- data.frame(y=rnorm(8), x=factor(c(rep(1,4),rep(0,4))), z=factor(rep(c(1,0),4)))
if(require(lme4)){
  GLM       &lt;- glm(y  ~ x+r(z), family=gaussian(identity), data=dataset)
  summary(GLM)
  logLik(GLM)
  Anova(GLM,type=3)
}

## Not run: 
## for an example of the use of a terms object as a formula
demo(glm.vr)

## End(Not run)</code></pre>

<hr>
<h2 id='is.balanced'>
Balance cheking of models.
</h2><span id='topic+is.balanced'></span>

<h3>Description</h3>

<p>Checks if models have balanced data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.balanced(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.balanced_+3A_object">object</code></td>
<td>
<p>fitted model that includes <code>variables</code> attribute and <code>model</code> slot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns TRUE if balanced, FALSE if not.
</p>


<h3>Author(s)</h3>

<p>Kristian Hovde Liland
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mixlm &lt;- lm(y~x*r(z),
		    data = data.frame(y = rnorm(8),
							  x = factor(c(rep(1,4),rep(0,4))),
							  z = factor(rep(c(1,0),4))))
is.balanced(mixlm)
</code></pre>

<hr>
<h2 id='lm'>Fitting Linear Models</h2><span id='topic+lm'></span><span id='topic+summary.lmm'></span><span id='topic+lmer'></span><span id='topic+qr.lmm'></span><span id='topic+mixlm'></span><span id='topic+print.lmm'></span><span id='topic+random.worker'></span>

<h3>Description</h3>

<p><code>lm</code> is used to fit linear models.
It can be used to carry out regression,
single stratum analysis of variance and
analysis of covariance (although <code><a href="stats.html#topic+aov">aov</a></code> may provide a more
convenient interface for these).
The version distributed through the package mixlm
extends the capabilities with balanced mixture
models and <code>lmer</code> interfacing. Random effects 
are indicated by wrapping their formula entries in <code>r()</code>.
Also, effect level names are kept in printing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lm(formula, data, subset, weights, na.action,
   method = "qr", model = TRUE, x = FALSE, y = FALSE, qr = TRUE,
   singular.ok = TRUE, contrasts = "contr.sum", offset, 
   unrestricted = TRUE, REML = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lm_+3A_formula">formula</code></td>
<td>
<p>an object of class <code>"<a href="stats.html#topic+formula">formula</a>"</code> (or one that
can be coerced to that class): a symbolic description of the
model to be fitted.  The details of model specification are given
under &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="lm_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object
coercible by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame) containing
the variables in the model.  If not found in <code>data</code>, the
variables are taken from <code>environment(formula)</code>,
typically the environment from which <code>lm</code> is called.</p>
</td></tr>
<tr><td><code id="lm_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations
to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="lm_+3A_weights">weights</code></td>
<td>
<p>an optional vector of weights to be used in the fitting
process.  Should be <code>NULL</code> or a numeric vector.
If non-NULL, weighted least squares is used with weights
<code>weights</code> (that is, minimizing <code>sum(w*e^2)</code>); otherwise
ordinary least squares is used.  See also &lsquo;Details&rsquo;,</p>
</td></tr>
<tr><td><code id="lm_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen
when the data contain <code>NA</code>s.  The default is set by
the <code>na.action</code> setting of <code><a href="base.html#topic+options">options</a></code>, and is
<code><a href="stats.html#topic+na.fail">na.fail</a></code> if that is unset.  The &lsquo;factory-fresh&rsquo;
default is <code><a href="stats.html#topic+na.omit">na.omit</a></code>.  Another possible value is
<code>NULL</code>, no action.  Value <code><a href="stats.html#topic+na.exclude">na.exclude</a></code> can be useful.</p>
</td></tr>
<tr><td><code id="lm_+3A_method">method</code></td>
<td>
<p>the method to be used; for fitting, currently only
<code>method = "qr"</code> is supported; <code>method = "model.frame"</code> returns
the model frame (the same as with <code>model = TRUE</code>, see below).</p>
</td></tr>
<tr><td><code id="lm_+3A_model">model</code>, <code id="lm_+3A_x">x</code>, <code id="lm_+3A_y">y</code>, <code id="lm_+3A_qr">qr</code></td>
<td>
<p>logicals.  If <code>TRUE</code> the corresponding
components of the fit (the model frame, the model matrix, the
response, the QR decomposition) are returned.
</p>
</td></tr>
<tr><td><code id="lm_+3A_singular.ok">singular.ok</code></td>
<td>
<p>logical. If <code>FALSE</code> (the default in S but
not in <span class="rlang"><b>R</b></span>) a singular fit is an error.</p>
</td></tr>
<tr><td><code id="lm_+3A_contrasts">contrasts</code></td>
<td>
<p>character indicating which coding should be applied
to all <code>factor</code>s or an optional list. See the <code>contrasts.arg</code>
of <code><a href="stats.html#topic+model.matrix.default">model.matrix.default</a></code>. Defaults to <code>"contr.sum"</code>. 
See Details for more information.</p>
</td></tr>
<tr><td><code id="lm_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an <em>a priori</em> known
component to be included in the linear predictor during fitting.
This should be <code>NULL</code> or a numeric vector of length equal to
the number of cases.  One or more <code><a href="stats.html#topic+offset">offset</a></code> terms can be
included in the formula instead or as well, and if more than one are
specified their sum is used.  See <code><a href="stats.html#topic+model.offset">model.offset</a></code>.</p>
</td></tr>
<tr><td><code id="lm_+3A_unrestricted">unrestricted</code></td>
<td>
<p>additional argument for switching between unrestricted and restricted models if including random variables.</p>
</td></tr>
<tr><td><code id="lm_+3A_reml">REML</code></td>
<td>
<p>is used to invoke restricted maximum likelihood (TRUE)
or maximum likelihood (FALSE) estimation instead of least squares.</p>
</td></tr>
<tr><td><code id="lm_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the low level
regression fitting functions (see below).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Models for <code>lm</code> are specified symbolically.  A typical model has
the form <code>response ~ terms</code> where <code>response</code> is the (numeric)
response vector and <code>terms</code> is a series of terms which specifies a
linear predictor for <code>response</code>.  A terms specification of the form
<code>first + second</code> indicates all the terms in <code>first</code> together
with all the terms in <code>second</code> with duplicates removed.  A
specification of the form <code>first:second</code> indicates the set of
terms obtained by taking the interactions of all terms in <code>first</code>
with all terms in <code>second</code>.  The specification <code>first*second</code>
indicates the <em>cross</em> of <code>first</code> and <code>second</code>.  This is
the same as <code>first + second + first:second</code>.
</p>
<p>If the formula includes an <code><a href="stats.html#topic+offset">offset</a></code>, this is evaluated and
subtracted from the response.
</p>
<p>If <code>response</code> is a matrix a linear model is fitted separately by
least-squares to each column of the matrix.
</p>
<p>See <code><a href="stats.html#topic+model.matrix">model.matrix</a></code> for some further details.  The terms in
the formula will be re-ordered so that main effects come first,
followed by the interactions, all second-order, all third-order and so
on: to avoid this pass a <code>terms</code> object as the formula (see
<code><a href="stats.html#topic+aov">aov</a></code> and <code>demo(glm.vr)</code> for an example).
</p>
<p>A formula has an implied intercept term.  To remove this use either
<code>y ~ x - 1</code> or <code>y ~ 0 + x</code>.  See <code><a href="stats.html#topic+formula">formula</a></code> for
more details of allowed formulae.
</p>
<p>Non-<code>NULL</code> <code>weights</code> can be used to indicate that different
observations have different variances (with the values in
<code>weights</code> being inversely proportional to the variances); or
equivalently, when the elements of <code>weights</code> are positive
integers <code class="reqn">w_i</code>, that each response <code class="reqn">y_i</code> is the mean of
<code class="reqn">w_i</code> unit-weight observations (including the case that there are
<code class="reqn">w_i</code> observations equal to <code class="reqn">y_i</code> and the data have been
summarized).
</p>
<p><code>lm</code> calls the lower level functions <code><a href="stats.html#topic+lm.fit">lm.fit</a></code>, etc,
see below, for the actual numerical computations.  For programming
only, you may consider doing likewise.
</p>
<p>All of <code>weights</code>, <code>subset</code> and <code>offset</code> are evaluated
in the same way as variables in <code>formula</code>, that is first in
<code>data</code> and then in the environment of <code>formula</code>.
</p>
<p>The <code>contrasts</code> argument is applied when the <code>lm</code> model is
fitted. In additional to the standard contrasts from the <code>stats</code>
package, one can choose weighted coding: <code>contr.weighted</code> which
balances unbalanced data through factor weighting. Different from the
original version of <code>lm</code>, a single contrast can be indicated
to automatically be applied to all <code>factor</code>s.
</p>


<h3>Value</h3>

<p><code>lm</code> returns an object of <code><a href="base.html#topic+class">class</a></code> <code>c("lmm","lm")</code> or for
multiple responses of class <code>c("mlm", "lm")</code>.
</p>
<p>The functions <code>summary</code> and <code><a href="#topic+anova">anova</a></code> are used to
obtain and print a summary and analysis of variance table of the
results.  The generic accessor functions <code>coefficients</code>,
<code>effects</code>, <code>fitted.values</code> and <code>residuals</code> extract
various useful features of the value returned by <code>lm</code>.
</p>
<p>An object of class <code>"lm"</code> is a list containing at least the
following components:
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>a named vector of coefficients</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>the residuals, that is response minus fitted values.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>the fitted mean values.</p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p>the numeric rank of the fitted linear model.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>(only for weighted fits) the specified weights.</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>the residual degrees of freedom.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>the <code><a href="stats.html#topic+terms">terms</a></code> object used.</p>
</td></tr>
<tr><td><code>contrasts</code></td>
<td>
<p>(only where relevant) the contrasts used.</p>
</td></tr>
<tr><td><code>xlevels</code></td>
<td>
<p>(only where relevant) a record of the levels of the
factors used in fitting.</p>
</td></tr>
<tr><td><code>offset</code></td>
<td>
<p>the offset used (missing if none were used).</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>if requested, the response used.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>if requested, the model matrix used.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>if requested (the default), the model frame used.</p>
</td></tr>
<tr><td><code>na.action</code></td>
<td>
<p>(where relevant) information returned by
<code><a href="stats.html#topic+model.frame">model.frame</a></code> on the special handling of <code>NA</code>s.</p>
</td></tr>
</table>
<p>In addition, non-null fits will have components <code>assign</code>,
<code>effects</code> and (unless not requested) <code>qr</code> relating to the linear
fit, for use by extractor functions such as <code>summary</code> and
<code><a href="stats.html#topic+effects">effects</a></code>.
</p>
<p>And models containing random effect will contain
<code>random</code> having additional information about
the model.
</p>


<h3>Using time series</h3>

<p>Considerable care is needed when using <code>lm</code> with time series.
</p>
<p>Unless <code>na.action = NULL</code>, the time series attributes are
stripped from the variables before the regression is done.  (This is
necessary as omitting <code>NA</code>s would invalidate the time series
attributes, and if <code>NA</code>s are omitted in the middle of the series
the result would no longer be a regular time series.)
</p>
<p>Even if the time series attributes are retained, they are not used to
line up series, so that the time shift of a lagged or differenced
regressor would be ignored.  It is good practice to prepare a
<code>data</code> argument by <code><a href="stats.html#topic+ts.intersect">ts.intersect</a>(..., dframe = TRUE)</code>,
then apply a suitable <code>na.action</code> to that data frame and call
<code>lm</code> with <code>na.action = NULL</code> so that residuals and fitted
values are time series.
</p>


<h3>Note</h3>

<p>Offsets specified by <code>offset</code> will not be included in predictions
by <code><a href="stats.html#topic+predict.lm">predict.lm</a></code>, whereas those specified by an offset term
in the formula will be.
</p>


<h3>Author(s)</h3>

<p>The design was inspired by the S function of the same name described
in Chambers (1992).  The implementation of model formula by Ross Ihaka
was based on Wilkinson &amp; Rogers (1973). Mixed model extensions
by Kristian Hovde Liland.
</p>


<h3>References</h3>

<p>Chambers, J. M. (1992)
<em>Linear models.</em>
Chapter 4 of <em>Statistical Models in S</em>
eds J. M. Chambers and T. J. Hastie, Wadsworth &amp; Brooks/Cole.
</p>
<p>Wilkinson, G. N. and Rogers, C. E. (1973)
Symbolic descriptions of factorial models for analysis of variance.
<em>Applied Statistics</em>, <b>22</b>, 392&ndash;9.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.lmm">summary.lmm</a></code> for summaries and <code><a href="#topic+anova.lmm">anova.lmm</a></code> for
the ANOVA table; <code><a href="stats.html#topic+aov">aov</a></code> for a different interface.
</p>
<p>The generic functions <code><a href="stats.html#topic+coef">coef</a></code>, <code><a href="stats.html#topic+effects">effects</a></code>,
<code><a href="stats.html#topic+residuals">residuals</a></code>, <code><a href="stats.html#topic+fitted">fitted</a></code>, <code><a href="stats.html#topic+vcov">vcov</a></code>.
</p>
<p><code><a href="stats.html#topic+predict.lm">predict.lm</a></code> (via <code><a href="stats.html#topic+predict">predict</a></code>) for prediction,
including confidence and prediction intervals;
<code><a href="stats.html#topic+confint">confint</a></code> for confidence intervals of <em>parameters</em>.
</p>
<p><code><a href="stats.html#topic+lm.influence">lm.influence</a></code> for regression diagnostics, and
<code><a href="#topic+glm">glm</a></code> for <b>generalized</b> linear models.
</p>
<p>The underlying low level functions,
<code><a href="stats.html#topic+lm.fit">lm.fit</a></code> for plain, and <code><a href="stats.html#topic+lm.wfit">lm.wfit</a></code> for weighted
regression fitting.
</p>
<p>More <code>lm()</code> examples are available e.g., in
<code><a href="datasets.html#topic+anscombe">anscombe</a></code>, <code><a href="datasets.html#topic+attitude">attitude</a></code>, <code><a href="datasets.html#topic+freeny">freeny</a></code>,
<code><a href="datasets.html#topic+LifeCycleSavings">LifeCycleSavings</a></code>, <code><a href="datasets.html#topic+longley">longley</a></code>,
<code><a href="datasets.html#topic+stackloss">stackloss</a></code>, <code><a href="datasets.html#topic+swiss">swiss</a></code>.
</p>
<p><code>biglm</code> in package <a href="https://CRAN.R-project.org/package=biglm"><span class="pkg">biglm</span></a> for an alternative
way to fit linear models to large datasets (especially those with many
cases).
</p>
<p><code><a href="#topic+print.AnovaMix">print.AnovaMix</a></code>, <code><a href="#topic+AnovaMix">AnovaMix</a></code>, <code><a href="#topic+Anova">Anova</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(graphics)

## Annette Dobson (1990) "An Introduction to Generalized Linear Models".
## Page 9: Plant Weight Data.
ctl &lt;- c(4.17,5.58,5.18,6.11,4.50,4.61,5.17,4.53,5.33,5.14)
trt &lt;- c(4.81,4.17,4.41,3.59,5.87,3.83,6.03,4.89,4.32,4.69)
group &lt;- gl(2,10,20, labels=c("Ctl","Trt"))
weight &lt;- c(ctl, trt)
lm.D9 &lt;- lm(weight ~ group)
lm.D90 &lt;- lm(weight ~ group - 1) # omitting intercept
anova(lm.D9)
summary(lm.D90)

opar &lt;- par(mfrow = c(2,2), oma = c(0, 0, 1.1, 0))
plot(lm.D9, las = 1)      # Residuals, Fitted, ...
par(opar)

# Linear mixed model
dataset   &lt;- data.frame(y=rnorm(8), x=factor(c(rep(1,4),rep(0,4))), z=factor(rep(c(1,0),4)))
mixlm &lt;- lm(y~x*r(z), data = dataset)
Anova(mixlm,type="III")

### less simple examples in "See Also" above
</code></pre>

<hr>
<h2 id='plotprops'>
Property plots for relevant component analysis
</h2><span id='topic+plotprops'></span>

<h3>Description</h3>

<p>Plot summary of relevant component analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotprops(Y, X, doscaleX = FALSE, docenterX = TRUE, ncomp, subset)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotprops_+3A_y">Y</code></td>
<td>

<p>Response matrix.
</p>
</td></tr>
<tr><td><code id="plotprops_+3A_x">X</code></td>
<td>

<p>Predictor matrix.
</p>
</td></tr>
<tr><td><code id="plotprops_+3A_doscalex">doscaleX</code></td>
<td>

<p>Standardize predictors.
</p>
</td></tr>
<tr><td><code id="plotprops_+3A_docenterx">docenterX</code></td>
<td>

<p>Center predictors.
</p>
</td></tr>
<tr><td><code id="plotprops_+3A_ncomp">ncomp</code></td>
<td>

<p>Number of singular values and eigenvalues to extract.
</p>
</td></tr>
<tr><td><code id="plotprops_+3A_subset">subset</code></td>
<td>

<p>Subset of predictor and response.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Only plotting.
</p>


<h3>Author(s)</h3>

<p>Solve Sæbø
</p>


<h3>References</h3>

<p>Helland, I.S. &amp; T. Almøy (1994) Comparison of prediction methods when only a few components are relevant. JASA 89, 583-591.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(rnorm(100),20,5)
Y &lt;- matrix(rnorm(20),20,1)
plotprops(Y, X, doscaleX = FALSE, docenterX = TRUE, 5)
</code></pre>

<hr>
<h2 id='PRESS'>
Prediction fits
</h2><span id='topic+PRESS'></span><span id='topic+PRESS.res'></span><span id='topic+PRESS.pred'></span><span id='topic+R2pred'></span><span id='topic+RMSEP'></span><span id='topic+rmsep'></span>

<h3>Description</h3>

<p>Various summaries of predictions and PRESS residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>R2pred(object = NULL)
RMSEP(object)
rmsep(object)
PRESS(object = NULL)
PRESS.res(object = NULL, ncomp = NULL)
PRESS.pred(object = NULL, ncomp = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PRESS_+3A_object">object</code></td>
<td>

<p>a fitted model of type <code>lm</code> or <code>mvr</code>.
</p>
</td></tr>
<tr><td><code id="PRESS_+3A_ncomp">ncomp</code></td>
<td>

<p>number of components to use with <code>mvr</code> (optional).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Predictions are extracted and summaries/residuals are computed.
</p>


<h3>Value</h3>

<p>Returns either an object of summaries or residuals.
</p>


<h3>Author(s)</h3>

<p>Kristian Hovde Liland
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- data.frame(y = rnorm(8),
				   x = factor(c('a','a','a','a','b','b','b','b')),
				   z = factor(c('a','a','b','b','a','a','b','b')))
mod &lt;- lm(y ~ x + z, data=data)
RMSEP(mod)
rmsep(mod) # Alias to distinguish it from pls::RMSEP
R2pred(mod)
PRESS(mod)
PRESS.res(mod)
PRESS.pred(mod)
</code></pre>

<hr>
<h2 id='print.AnovaMix'>
Print method for objects of class(AnovaMix)
</h2><span id='topic+print.AnovaMix'></span><span id='topic+print'></span>

<h3>Description</h3>

<p>Prints relevant information like the ANOVA table, variance components and errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'AnovaMix'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.AnovaMix_+3A_x">x</code></td>
<td>
<p><code>AnovaMix</code> object to be printed.</p>
</td></tr>
<tr><td><code id="print.AnovaMix_+3A_...">...</code></td>
<td>
<p>Additional arguments (not supported yet).</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Only balanced models are fully supported.
</p>


<h3>Author(s)</h3>

<p>Kristian Hovde Liland
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AnovaMix">AnovaMix</a></code>, <code><a href="#topic+lm">lm</a></code>, <code><a href="#topic+Anova">Anova</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mixlm &lt;- lm(y~x*r(z),
			data = data.frame(y = rnorm(8),
							  x = factor(c(rep(1,4),rep(0,4))),
							  z = factor(rep(c(1,0),4))))
Anova(mixlm,type="III")
</code></pre>

<hr>
<h2 id='print.summary.lmm'>Summarizing Linear Model Fits</h2><span id='topic+print.summary.lmm'></span>

<h3>Description</h3>

<p><code>summary</code> method for class <code>"lmm"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.lmm'
print(x, digits = max(3, getOption("digits") - 3),
      symbolic.cor = x$symbolic.cor,
      signif.stars = getOption("show.signif.stars"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.lmm_+3A_x">x</code></td>
<td>
<p>an object of class <code>"summary.lmm"</code>, usually, a result of a
call to <code>summary.lmm</code>.</p>
</td></tr>
<tr><td><code id="print.summary.lmm_+3A_digits">digits</code></td>
<td>
<p>the number of significant digits to use when printing.</p>
</td></tr>
<tr><td><code id="print.summary.lmm_+3A_symbolic.cor">symbolic.cor</code></td>
<td>
<p>logical. If <code>TRUE</code>, print the correlations in
a symbolic form (see <code><a href="stats.html#topic+symnum">symnum</a></code>) rather than as numbers.</p>
</td></tr>
<tr><td><code id="print.summary.lmm_+3A_signif.stars">signif.stars</code></td>
<td>
<p>logical. If <code>TRUE</code>, &lsquo;significance stars&rsquo;
are printed for each coefficient.</p>
</td></tr>
<tr><td><code id="print.summary.lmm_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This adaptation of <code>print.summary.lm</code> from package <code>stats</code>
slightly alters the output to better conform with text-book notation.
</p>
<p><code>print.summary.lm</code> tries to be smart about formatting the
coefficients, standard errors, etc. and additionally gives
&lsquo;significance stars&rsquo; if <code>signif.stars</code> is <code>TRUE</code>.
</p>
<p>Correlations are printed to two decimal places (or symbolically): to
see the actual correlations print <code>summary(object)$correlation</code>
directly.
</p>


<h3>Value</h3>

<p>The function <code>summary.lm</code> computes and returns a list of summary
statistics of the fitted linear model given in <code>object</code>, using
the components (list elements) <code>"call"</code> and <code>"terms"</code>
from its argument, plus
</p>
<table>
<tr><td><code>residuals</code></td>
<td>
<p>the <em>weighted</em> residuals, the usual residuals
rescaled by the square root of the weights specified in the call to
<code>lm</code>.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a <code class="reqn">p \times 4</code> matrix with columns for
the estimated coefficient, its standard error, t-statistic and
corresponding (two-sided) p-value.  Aliased coefficients are omitted.</p>
</td></tr>
<tr><td><code>aliased</code></td>
<td>
<p>named logical vector showing if the original
coefficients are aliased.</p>
</td></tr> 
<tr><td><code>sigma</code></td>
<td>
<p>the square root of the estimated variance of the random
error
</p>
<p style="text-align: center;"><code class="reqn">\hat\sigma^2 = \frac{1}{n-p}\sum_i{w_i R_i^2},</code>
</p>

<p>where <code class="reqn">R_i</code> is the <code class="reqn">i</code>-th residual, <code>residuals[i]</code>.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>degrees of freedom, a 3-vector <code class="reqn">(p, n-p, p*)</code>, the last
being the number of non-aliased coefficients.</p>
</td></tr>
<tr><td><code>fstatistic</code></td>
<td>
<p>(for models including non-intercept terms)
a 3-vector with the value of the F-statistic with
its numerator and denominator degrees of freedom.</p>
</td></tr>
<tr><td><code>r.squared</code></td>
<td>
<p><code class="reqn">R^2</code>, the &lsquo;fraction of variance explained by
the model&rsquo;,
</p>
<p style="text-align: center;"><code class="reqn">R^2 = 1 - \frac{\sum_i{R_i^2}}{\sum_i(y_i- y^*)^2},</code>
</p>

<p>where <code class="reqn">y^*</code> is the mean of <code class="reqn">y_i</code> if there is an
intercept and zero otherwise.</p>
</td></tr>
<tr><td><code>adj.r.squared</code></td>
<td>
<p>the above <code class="reqn">R^2</code> statistic
&lsquo;<em>adjusted</em>&rsquo;, penalizing for higher <code class="reqn">p</code>.</p>
</td></tr>
<tr><td><code>cov.unscaled</code></td>
<td>
<p>a <code class="reqn">p \times p</code> matrix of (unscaled)
covariances of the <code class="reqn">\hat\beta_j</code>, <code class="reqn">j=1, \dots, p</code>.</p>
</td></tr>
<tr><td><code>correlation</code></td>
<td>
<p>the correlation matrix corresponding to the above
<code>cov.unscaled</code>, if <code>correlation = TRUE</code> is specified.</p>
</td></tr>
<tr><td><code>symbolic.cor</code></td>
<td>
<p>(only if <code>correlation</code> is true.)  The value
of the argument <code>symbolic.cor</code>.</p>
</td></tr>
<tr><td><code>na.action</code></td>
<td>
<p>from <code>object</code>, if present there.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>The model fitting function <code><a href="#topic+lm">lm</a></code>, <code><a href="base.html#topic+summary">summary</a></code>.
</p>
<p>Function <code><a href="stats.html#topic+coef">coef</a></code> will extract the matrix of coefficients
with standard errors, t-statistics and p-values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ctl &lt;- c(4.17,5.58,5.18,6.11,4.50,4.61,5.17,4.53,5.33,5.14)
trt &lt;- c(4.81,4.17,4.41,3.59,5.87,3.83,6.03,4.89,4.32,4.69)
group &lt;- gl(2,10,20, labels=c("Ctl","Trt"))
weight &lt;- c(ctl, trt)
sld90 &lt;- summary(lm.D90 &lt;- lm(weight ~ group -1))# omitting intercept
sld90
</code></pre>

<hr>
<h2 id='prop.test.ordinary'>Test of Equal or Given Proportions in text-book version</h2><span id='topic+prop.test.ordinary'></span>

<h3>Description</h3>

<p>This adaptation of <code>prop.test</code> from package <code>stats</code>
strips the test down to a text-book version.
</p>
<p><code>prop.test</code> can be used for testing the null that the
proportions (probabilities of success) in several groups are the
same, or that they equal certain given values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prop.test.ordinary(x, n, p = NULL,
          alternative = c("two.sided", "less", "greater"),
          conf.level = 0.95, correct = TRUE, pooled = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prop.test.ordinary_+3A_x">x</code></td>
<td>
<p>a vector of counts of successes, a one-dimensional table with
two entries, or a two-dimensional table (or matrix) with 2 columns,
giving the counts of successes and failures, respectively.</p>
</td></tr>
<tr><td><code id="prop.test.ordinary_+3A_n">n</code></td>
<td>
<p>a vector of counts of trials; ignored if <code>x</code> is a
matrix or a table.</p>
</td></tr>
<tr><td><code id="prop.test.ordinary_+3A_p">p</code></td>
<td>
<p>a vector of probabilities of success.  The length of
<code>p</code> must be the same as the number of groups specified by
<code>x</code>, and its elements must be greater than 0 and less than 1.</p>
</td></tr>
<tr><td><code id="prop.test.ordinary_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative
hypothesis, must be one of <code>"two.sided"</code> (default),
<code>"greater"</code> or <code>"less"</code>.  You can specify just the initial
letter.  Only used for testing the null that a single proportion
equals a given value, or that two proportions are equal; ignored
otherwise.</p>
</td></tr>
<tr><td><code id="prop.test.ordinary_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level of the returned confidence
interval.  Must be a single number between 0 and 1.  Only used
when testing the null that a single proportion equals a given
value, or that two proportions are equal; ignored otherwise.</p>
</td></tr>
<tr><td><code id="prop.test.ordinary_+3A_correct">correct</code></td>
<td>
<p>a logical indicating whether Yates' continuity
correction should be applied where possible.</p>
</td></tr>
<tr><td><code id="prop.test.ordinary_+3A_pooled">pooled</code></td>
<td>
<p>a logical indicating wheter pooled standard
deviation should be used..</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only groups with finite numbers of successes and failures are used.
Counts of successes and failures must be nonnegative and hence not
greater than the corresponding numbers of trials which must be
positive.  All finite counts should be integers.
</p>
<p>If <code>p</code> is <code>NULL</code> and there is more than one group, the null
tested is that the proportions in each group are the same.  If there
are two groups, the alternatives are that the probability of success
in the first group is less than, not equal to, or greater than the
probability of success in the second group, as specified by
<code>alternative</code>.  A confidence interval for the difference of
proportions with confidence level as specified by <code>conf.level</code>
and clipped to <code class="reqn">[-1,1]</code> is returned.  Continuity correction is
used only if it does not exceed the difference of the sample
proportions in absolute value.  Otherwise, if there are more than 2
groups, the alternative is always <code>"two.sided"</code>, the returned
confidence interval is <code>NULL</code>, and continuity correction is never
used.
</p>
<p>If there is only one group, then the null tested is that the
underlying probability of success is <code>p</code>, or .5 if <code>p</code> is
not given.  The alternative is that the probability of success is less
than, not equal to, or greater than <code>p</code> or 0.5, respectively, as
specified by <code>alternative</code>.  A confidence interval for the
underlying proportion with confidence level as specified by
<code>conf.level</code> and clipped to <code class="reqn">[0,1]</code> is returned.  Continuity
correction is used only if it does not exceed the difference between
sample and null proportions in absolute value. The confidence interval
is computed by inverting the score test.
</p>
<p>Finally, if <code>p</code> is given and there are more than 2 groups, the
null tested is that the underlying probabilities of success are those
given by <code>p</code>.  The alternative is always <code>"two.sided"</code>, the
returned confidence interval is <code>NULL</code>, and continuity correction
is never used.
</p>


<h3>Value</h3>

<p>A list with class <code>"htest"</code> containing the following
components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of Pearson's chi-squared test statistic.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>the degrees of freedom of the approximate
chi-squared distribution of the test statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value of the test.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>a vector with the sample proportions <code>x/n</code>.</p>
</td></tr>
<tr><td><code>conf.int</code></td>
<td>
<p>a confidence interval for the true proportion if
there is one group, or for the difference in proportions if
there are 2 groups and <code>p</code> is not given, or <code>NULL</code>
otherwise.  In the cases where it is not <code>NULL</code>, the
returned confidence interval has an asymptotic confidence level
as specified by <code>conf.level</code>, and is appropriate to the
specified alternative hypothesis.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>the value of <code>p</code> if specified by the null, or
<code>NULL</code> otherwise.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string describing the alternative.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating the method used, and
whether Yates' continuity correction was applied.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the names of the data.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Wilson, E.B. (1927) Probable inference, the law of succession, and
statistical inference.
<em>J. Am. Stat. Assoc.</em>, <b>22</b>, 209&ndash;212.
</p>
<p>Newcombe R.G. (1998) Two-Sided Confidence Intervals for the Single
Proportion: Comparison of Seven Methods.
<em>Statistics in Medicine</em> <b>17</b>, 857&ndash;872.
</p>
<p>Newcombe R.G. (1998) Interval Estimation for the Difference Between
Independent Proportions: Comparison of Eleven Methods.
<em>Statistics in Medicine</em> <b>17</b>, 873&ndash;890.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+binom.test">binom.test</a></code> for an <em>exact</em> test of a binomial
hypothesis.</p>


<h3>Examples</h3>

<pre><code class='language-R'>heads &lt;- rbinom(1, size=100, prob = .5)
prop.test(heads, 100)          # continuity correction TRUE by default
prop.test(heads, 100, correct = FALSE)

## Data from Fleiss (1981), p. 139.
## H0: The null hypothesis is that the four populations from which
##     the patients were drawn have the same true proportion of smokers.
## A:  The alternative is that this proportion is different in at
##     least one of the populations.

smokers  &lt;- c( 83, 90, 129, 70 )
patients &lt;- c( 86, 93, 136, 82 )
prop.test.ordinary(smokers, patients)
</code></pre>

<hr>
<h2 id='rparse'>
Removes function r() from formulas.
</h2><span id='topic+rparse'></span>

<h3>Description</h3>

<p>Removes function r() from formulas. Can also convert to lmer formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rparse(f, REML = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rparse_+3A_f">f</code></td>
<td>
<p>formula to be stripped of r().</p>
</td></tr>
<tr><td><code id="rparse_+3A_reml">REML</code></td>
<td>
<p>logical indicating if lmer conversion should be done.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Formula without r(), possibly converted to lmer mixed model format.
</p>


<h3>Author(s)</h3>

<p>Kristian Hovde Liland
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fparse">fparse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- formula(y~x*r(z))
rparse(f)
</code></pre>

<hr>
<h2 id='simple.glht'>
Pairwise comparison with multiple testing compensation.
</h2><span id='topic+simple.glht'></span><span id='topic+print.simple.glht'></span><span id='topic+cld'></span>

<h3>Description</h3>

<p>Extension of glht from the multcomp package to handle
Fisher family-wise error and Bonferroni testing.
Create a set of confidence intervals on the differences between the
means of the levels of a factor with the specified family-wise
probability of coverage.  The intervals are based on the Studentized
range statistic, Tukey's &lsquo;Honest Significant Difference&rsquo;
method, Fisher's family-wise error, or Bonferroni testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simple.glht(mod, effect, corr = c("Tukey","Bonferroni","Fisher"),
	level = 0.95, df = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simple.glht_+3A_mod">mod</code></td>
<td>
<p>A fitted model object, usually an <code><a href="#topic+lm">lm</a></code> or <code><a href="#topic+glm">glm</a></code> fit.</p>
</td></tr>
<tr><td><code id="simple.glht_+3A_effect">effect</code></td>
<td>
<p>A character vector giving the term of the fitted model for
which the intervals should be calculated. This can also be an interaction.</p>
</td></tr>
<tr><td><code id="simple.glht_+3A_corr">corr</code></td>
<td>
<p>A character vector giving the multiple testing correction
method. Defaults to <code>Tukey</code>.</p>
</td></tr>
<tr><td><code id="simple.glht_+3A_level">level</code></td>
<td>
<p>A numeric value between zero and one giving the
family-wise confidence level to use.</p>
</td></tr>
<tr><td><code id="simple.glht_+3A_df">df</code></td>
<td>
<p>User supplied number of degrees of freedom. If not supplied or
NULL, the default is to extract these from the model.</p>
</td></tr>
<tr><td><code id="simple.glht_+3A_...">...</code></td>
<td>
<p>Optional additional arguments.  None are used at present.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When comparing the means for the levels of a factor in an analysis of
variance, a simple comparison using t-tests will inflate the
probability of declaring a significant difference when it is not in
fact present.  This because the intervals are calculated with a
given coverage probability for each interval but the interpretation of
the coverage is usually with respect to the entire family of
intervals.
</p>
<p>John Tukey introduced intervals based on the range of the
sample means rather than the individual differences.  The intervals
returned by this function are based on this Studentized range
statistics.
</p>
<p>The intervals constructed in this way would only apply exactly to
balanced designs where there are the same number of observations made
at each level of the factor.  This function incorporates an adjustment
for sample size that produces sensible intervals for mildly unbalanced
designs.
</p>
<p>If <code>which</code> specifies non-factor terms these will be dropped with
a warning: if no terms are left this is a an error.
</p>


<h3>Value</h3>

<p>An object of classes <code>"simple.glht"</code>, <code>"summary.glht"</code>
and <code>"glht"</code> containing information to produce confidence intervals,
tests and plotting.
</p>
<p>There are <code>print</code>, <code>plot</code> and <code>cld</code> methods for class
<code>"simple.glht"</code>.
The <code>plot</code> method does not accept
<code>xlab</code>, <code>ylab</code> or <code>main</code> arguments and creates its own
values for each plot.
</p>


<h3>Author(s)</h3>

<p>Douglas Bates, extended to mixed effect models by Kristian Hovde Liland.
</p>


<h3>References</h3>

<p>Miller, R. G. (1981)
<em>Simultaneous Statistical Inference</em>. Springer.
</p>
<p>Yandell, B. S. (1997)
<em>Practical Data Analysis for Designed Experiments</em>.
Chapman &amp; Hall.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+aov">aov</a></code>, <code><a href="stats.html#topic+qtukey">qtukey</a></code>, <code><a href="stats.html#topic+model.tables">model.tables</a></code>,
<code><a href="multcomp.html#topic+glht">glht</a></code> in package <a href="https://CRAN.R-project.org/package=multcomp"><span class="pkg">multcomp</span></a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(graphics)

summary(fm1 &lt;- lm(breaks ~ wool + tension, data = warpbreaks))
simple.glht(fm1, "tension")
plot(simple.glht(fm1, "tension"))
cld(simple.glht(fm1, "tension"))
</code></pre>

<hr>
<h2 id='spearson'>
Standardized Pearson residuals
</h2><span id='topic+spearson'></span>

<h3>Description</h3>

<p>Standardized Pearson residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spearson(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spearson_+3A_object">object</code></td>
<td>

<p>fitted model.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Takes ordinary Pearson residuals and standardizes them.
</p>


<h3>Value</h3>

<p>Returns the residuals.
</p>


<h3>Author(s)</h3>

<p>Kristian Hovde Liland
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- data.frame(y = rnorm(8),
				   x = factor(c('a','a','a','a','b','b','b','b')),
				   z = factor(c('a','a','b','b','a','a','b','b')))
mod &lt;- lm(y ~ x + z, data=data)
spearson(mod)
</code></pre>

<hr>
<h2 id='t_test'>
Text book versions of t-tests and z-tests.
</h2><span id='topic+t_test'></span><span id='topic+t_test.formula'></span><span id='topic+t_test.default'></span><span id='topic+t_test_sum'></span><span id='topic+z_test'></span><span id='topic+z_test.formula'></span><span id='topic+z_test.default'></span><span id='topic+z_test_sum'></span>

<h3>Description</h3>

<p>Adaptations of <code>base</code> t.test to better confrom to text book standards.
<code>t_test_sum</code> and <code>z_test_sum</code> takes summarized data as input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>t_test(x, ...)
z_test(x, ...)

## Default S3 method:
t_test(x, y = NULL, alternative = c("two.sided", "less", "greater"),
	mu = 0, paired = FALSE, var.equal = FALSE, conf.level = 0.95, ...)
## Default S3 method:
z_test(x, y = NULL, alternative = c("two.sided", "less", "greater"),
	mu = 0, paired = FALSE, var.equal = FALSE, conf.level = 0.95, sds = NULL, ...)

## S3 method for class 'formula'
t_test(formula, data, subset, na.action, ...)
## S3 method for class 'formula'
z_test(formula, data, subset, na.action, ...)

## Function for summarized data:
t_test_sum(means, sds, ns, alternative = c("two.sided", "less", "greater"),
	mu = 0, var.equal = FALSE, conf.level = 0.95, z.test = FALSE, ...)
z_test_sum(means, sds, ns, alternative = c("two.sided", "less", "greater"),
	mu = 0, var.equal = FALSE, conf.level = 0.95, z.test = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="t_test_+3A_x">x</code></td>
<td>
<p>a (non-empty) numeric vector of data values.</p>
</td></tr>
<tr><td><code id="t_test_+3A_y">y</code></td>
<td>
<p>an optional (non-empty) numeric vector of data values.</p>
</td></tr>
<tr><td><code id="t_test_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative
hypothesis, must be one of <code>"two.sided"</code> (default),
<code>"greater"</code> or <code>"less"</code>.  You can specify just the initial
letter.</p>
</td></tr>
<tr><td><code id="t_test_+3A_mu">mu</code></td>
<td>
<p>a number indicating the true value of the mean (or
difference in means if you are performing a two sample test).</p>
</td></tr>
<tr><td><code id="t_test_+3A_paired">paired</code></td>
<td>
<p>a logical indicating whether you want a paired
t-test.</p>
</td></tr>
<tr><td><code id="t_test_+3A_var.equal">var.equal</code></td>
<td>
<p>a logical variable indicating whether to treat the
two variances as being equal. If <code>TRUE</code> then the pooled
variance is used to estimate the variance otherwise the Welch
(or Satterthwaite) approximation to the degrees of freedom is used.</p>
</td></tr>
<tr><td><code id="t_test_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level of the interval.</p>
</td></tr>
<tr><td><code id="t_test_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>lhs ~ rhs</code> where <code>lhs</code>
is a numeric variable giving the data values and <code>rhs</code> a factor
with two levels giving the corresponding groups.</p>
</td></tr>
<tr><td><code id="t_test_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="t_test_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations
to be used.</p>
</td></tr>
<tr><td><code id="t_test_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when
the data contain <code>NA</code>s.  Defaults to
<code>getOption("na.action")</code>.</p>
</td></tr>
<tr><td><code id="t_test_+3A_means">means</code></td>
<td>
<p>	means of groups.</p>
</td></tr>
<tr><td><code id="t_test_+3A_sds">sds</code></td>
<td>
<p> standard deviations of groups.</p>
</td></tr>
<tr><td><code id="t_test_+3A_ns">ns</code></td>
<td>
<p> number of objects in groups.</p>
</td></tr>
<tr><td><code id="t_test_+3A_z.test">z.test</code></td>
<td>
<p> normal approximation.</p>
</td></tr>
<tr><td><code id="t_test_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The formula interface is only applicable for the 2-sample tests.
</p>
<p><code>alternative = "greater"</code> is the alternative that <code>x</code> has a
larger mean than <code>y</code>.
</p>
<p>If <code>paired</code> is <code>TRUE</code> then both <code>x</code> and <code>y</code> must
be specified and they must be the same length.  Missing values are
silently removed (in pairs if <code>paired</code> is <code>TRUE</code>).  If
<code>var.equal</code> is <code>TRUE</code> then the pooled estimate of the
variance is used.  By default, if <code>var.equal</code> is <code>FALSE</code>
then the variance is estimated separately for both groups and the
Welch modification to the degrees of freedom is used.
</p>
<p>If the input data are effectively constant (compared to the larger of the
two means) an error is generated.
</p>


<h3>Value</h3>

<p>A list with class <code>"htest"</code> containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the t-statistic.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>the degrees of freedom for the t-statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value for the test.</p>
</td></tr>
<tr><td><code>conf.int</code></td>
<td>
<p>a confidence interval for the mean appropriate to the
specified alternative hypothesis.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>the estimated mean or difference in means depending on
whether it was a one-sample test or a two-sample test.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>the specified hypothesized value of the mean or mean
difference depending on whether it was a one-sample test or a
two-sample test.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string describing the alternative
hypothesis.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what type of t-test was
performed.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name(s) of the data.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+prop.test">prop.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
t.test(1:10,y=c(7:20))      # P = .00001855
t.test(1:10,y=c(7:20, 200)) # P = .1245    -- NOT significant anymore

## Classical example: Student's sleep data
plot(extra ~ group, data = sleep)
## Traditional interface
with(sleep, t.test(extra[group == 1], extra[group == 2]))
## Formula interface
t_test(extra ~ group, data = sleep)
</code></pre>

<hr>
<h2 id='tally'>
Tally of discrete numbers
</h2><span id='topic+tally'></span>

<h3>Description</h3>

<p>Tally of discrete numbers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tally(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tally_+3A_x">x</code></td>
<td>

<p>Discrete number vector.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the tally.
</p>


<h3>Author(s)</h3>

<p>Kristian Hovde Liland
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tally(c(1,5,1,3,2,5,6,2,2,1,4,3,6))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
