<!DOCTYPE html><html><head><title>Help for package Morphoscape</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Morphoscape}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as_fnc_df'>
<p>Convert a data frame to a <code>fnc_df</code></p></a></li>
<li><a href='#calc_all_lscps'>
<p>Calculate adaptive landscapes for a matrix of weights</p></a></li>
<li><a href='#calc_lscp'>
<p>Calculate a single weighted adaptive landscape</p></a></li>
<li><a href='#calcGrpWprime'>
<p>Compute optimally weighted adaptive landscapes</p></a></li>
<li><a href='#calcPoly'>
<p>Calculate polynomial fits over a surface</p></a></li>
<li><a href='#calcWprimeBy'>
<p>Compute optimally weighted adaptive landscapes by subgroup</p></a></li>
<li><a href='#generate_weights'><p>Generate a matrix containing weight combinations</p></a></li>
<li><a href='#krige_surf'>
<p>Interpolate functional characteristics over a grid</p></a></li>
<li><a href='#lands.grp.test'>
<p>Significance tests between sets of weights</p></a></li>
<li><a href='#lscp_operations'>
<p>Simple Operations on Spatial Data</p></a></li>
<li><a href='#plot.kriged_surfaces'>
<p>Plots Kriged surfaces of functional characteristics</p></a></li>
<li><a href='#plot.wtd_lscp'>
<p>Plot Adaptive Landscapes</p></a></li>
<li><a href='#resample_grid'>
<p>Create a full grid from a set of coordinates</p></a></li>
<li><a href='#turtles'>
<p>Turtle Humeri</p></a></li>
<li><a href='#warps'>
<p>Simulated Shape Warps</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Computation and Visualization of Adaptive Landscapes</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements adaptive landscape methods first described by Polly et al. (2016) &lt;<a href="https://doi.org/10.1080%2F02724634.2016.1111225">doi:10.1080/02724634.2016.1111225</a>&gt; for the integration, analysis and visualization of biological trait data on a phenotypic morphospace - typically defined by shape metrics.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>concaveman, ggplot2, spatial, sp, automap, scales,
viridisLite, alphahull</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://blakedickson.github.io/Morphoscape/">https://blakedickson.github.io/Morphoscape/</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-05-12 01:24:39 UTC; z3291260</td>
</tr>
<tr>
<td>Author:</td>
<td>Blake Dickson <a href="https://orcid.org/0000-0001-6299-5224"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Stephanie Pierce <a href="https://orcid.org/0000-0003-0717-1841"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Noah Greifer <a href="https://orcid.org/0000-0003-3067-7154"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Blake Dickson &lt;b.dickson@unsw.edu.au&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-05-18 09:20:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='as_fnc_df'>
Convert a data frame to a <code>fnc_df</code>
</h2><span id='topic+as_fnc_df'></span><span id='topic+fnc_df'></span>

<h3>Description</h3>

<p><code>as_fnc_df()</code> converts a data frame containing coordinates and functional charactertics in a morphological space  to a <code>fnc_df</code> object for use in later funcitons, most importantly <code><a href="#topic+krige_surf">krige_surf</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_fnc_df(x, func.names = NULL, scale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_fnc_df_+3A_x">x</code></td>
<td>

<p>a data frame containing coordinates and functional characteristics (and possibly other variables, which are ignored). The first two columns must correspond to the x and y coordinates of the warps in morphological space.
</p>
</td></tr>
<tr><td><code id="as_fnc_df_+3A_func.names">func.names</code></td>
<td>

<p>the names of the variables in <code>x</code> the correspond to functional characteristics. These charcteristics must be numeric variables. If <code>NULL</code> (the default), all variables other than the first two will be taken to be the functional characteristics under study.
</p>
</td></tr>
<tr><td><code id="as_fnc_df_+3A_scale">scale</code></td>
<td>

<p>whether to scale the functional characteristics to have a minimum of 0 and a maximum of 1. This should generally be left at its default (<code>TRUE</code>) unless the variables have already been scaled.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Input data can be from a sampled grid of locations in morphospace, measured specimen data, species or group means, or a mix. 
</p>


<h3>Value</h3>

<p>A <code>fnc_df</code> object, which is a <code>data.frame</code> with the x and y coordinates in the first two columns and the functional characteristics in the other columns. The <code>"func.names"</code> <a href="base.html#topic+attributes">attribute</a> contains the names of the functional characteristics.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+as.data.frame">as.data.frame</a></code>
</p>
<p><code><a href="#topic+krige_surf">krige_surf</a></code> for using an <code>fnc_df</code> object to create a kriged surface.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("warps")

warps_fnc &lt;- as_fnc_df(warps, 
                       func.names = c("hydro", "curve",
                                       "mech", "fea"))
                                       
str(warps_fnc)
</code></pre>

<hr>
<h2 id='calc_all_lscps'>
Calculate adaptive landscapes for a matrix of weights
</h2><span id='topic+calc_all_lscps'></span>

<h3>Description</h3>

<p><code>calc_all_lscps()</code> calculates adaptive landscapes from a set of kriged surfaces of functional characteristics and sets of weights for those characteristics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_all_lscps(kr_data, grid_weights, file = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_all_lscps_+3A_kr_data">kr_data</code></td>
<td>

<p>a <code>kriged_surfaces</code> object; the output of a call to <code><a href="#topic+krige_surf">krige_surf</a></code>.
</p>
</td></tr>
<tr><td><code id="calc_all_lscps_+3A_grid_weights">grid_weights</code></td>
<td>

<p>a <code>grid_weights</code> object; the output of a call to <code><a href="#topic+generate_weights">generate_weights</a></code>.
</p>
</td></tr>
<tr><td><code id="calc_all_lscps_+3A_file">file</code></td>
<td>

<p>the path of a file to save the resulting output object, which may be quite large. The file path should contain an .rds or .rdata extension, which will be saved using <code><a href="base.html#topic+saveRDS">saveRDS</a></code> or <code><a href="base.html#topic+save">save</a></code>, respectively. See Details on how to load these files after saving them.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>calc_all_lscps()</code> computes a combined adaptive landscape for each of the supplied sets of weights. The optimal landscape overall or for certain subsets of the sample data can be found using <code><a href="#topic+calcGrpWprime">calcGrpWprime</a></code> or <code><a href="#topic+calcWprimeBy">calcWprimeBy</a></code>. <code><a href="#topic+calc_lscp">calc_lscp</a></code> can be used to extract the surface of the weighted functional characteristics for each set of weights (see Examples).
</p>
<p>Because the resulting objects are so large, it can be a good idea to save them after creation, which can be done automatically using the <code>file</code> argument. If the supplied file extension is <code>.rds</code>, <code><a href="base.html#topic+saveRDS">saveRDS</a></code> will be used to save the object to the supplied file path, and the file can be loaded using <code><a href="base.html#topic+readRDS">readRDS</a></code>. If the supplied file extension is <code>.RData</code>, <code><a href="base.html#topic+save">save</a></code> will be used to save the object to the supplied file path, and the file can be loaded using <code><a href="base.html#topic+load">load</a></code>.
</p>


<h3>Value</h3>

<p>An <code>all_lscps</code> object containing the following components:
</p>
<table>
<tr><td><code>dataframe</code></td>
<td>
<p>a list of the <code>grid</code> and <code>new_data</code> data frames stored in <code>kr_data</code>.</p>
</td></tr>
<tr><td><code>wtd_lscps</code></td>
<td>
<p>a list containing the weightred fitness values for each set of weights for the <code>grid</code> and <code>new_data</code> datasets. These are stored in matrices with a row for each data point in <code>grid</code> and <code>new_data</code> and a column for each set of weights.</p>
</td></tr>
<tr><td><code>grid_weights</code></td>
<td>
<p>the <code>grid_weights</code> object supplied to <code>grid_weights</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+calc_lscp">calc_lscp</a></code> for computing a single weighted landscape or extracting the weighted surface of functional characteristics for a single set of weights.
</p>
<p><code><a href="#topic+generate_weights">generate_weights</a></code> for generating the required matrix of weights.
</p>
<p><code><a href="#topic+calcGrpWprime">calcGrpWprime</a></code> and <code><a href="#topic+calcWprimeBy">calcWprimeBy</a></code> for finding optimal sets of weights and adaptive landscapes for subgroups.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("warps")
data("turtles")

warps_fnc &lt;- as_fnc_df(warps, 
                       func.names = c("hydro", "fea"))

kr_surf &lt;- krige_surf(warps_fnc, new_data = turtles)

grid_weights &lt;- generate_weights(n = 20, data = kr_surf)

all_lscps &lt;- calc_all_lscps(kr_surf,
                            grid_weights = grid_weights)
all_lscps

# Extract the weighted surface for a single set
# of weights (here, the 6th set of weights)

grid_weights[6,]

wtd_lscp_6 &lt;- calc_lscp(all_lscps, i = 6)
wtd_lscp_6

# This aligns with the weighted fitness value:
mean(all_lscps$wtd_lscps$new_data[,6])
</code></pre>

<hr>
<h2 id='calc_lscp'>
Calculate a single weighted adaptive landscape
</h2><span id='topic+calc_lscp'></span><span id='topic+calc_lscp.kriged_surfaces'></span><span id='topic+calc_lscp.all_lscps'></span><span id='topic+wtd_lscp'></span>

<h3>Description</h3>

<p><code>calc_lscp()</code> calculates a single weighted landscape from a set of kriged surfaces of functional characteristics and a set of weights for those characteristics. This landscape can then be plotted using <code><a href="#topic+plot.wtd_lscp">plot.wtd_lscp</a></code>. Additionally computes the fitness values for a sample of additional coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_lscp(data, weights, ...)

## S3 method for class 'kriged_surfaces'
calc_lscp(data, weights, ...)

## S3 method for class 'all_lscps'
calc_lscp(data, weights, i, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_lscp_+3A_data">data</code></td>
<td>

<p>a <code>kriged_surfaces</code> or <code>all_lscps</code> object; the output of a call to <code><a href="#topic+krige_surf">krige_surf</a></code> or <code><a href="#topic+calc_all_lscps">calc_all_lscps</a></code>, repsectively. If no <code>new_data</code> component is included in <code>data</code>, only the adaptive landscape will be produced.
</p>
</td></tr>
<tr><td><code id="calc_lscp_+3A_weights">weights</code></td>
<td>

<p>a vector of weights, one for each functional characteristic. These weights should be nonnegative and sum to 1.
</p>
</td></tr>
<tr><td><code id="calc_lscp_+3A_i">i</code></td>
<td>

<p>when <code>data</code> is an <code>all_lscps</code> object, the index of the set of weights in the <code>grid_weights</code> object supplied to <code>calc_all_lscps()</code> to use to create the weighted landscape.
</p>
</td></tr>
<tr><td><code id="calc_lscp_+3A_...">...</code></td>
<td>

<p>ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>calc_lscp()</code> operates on the kriged surfaces stored in <code>data</code> by multiplying the functional characteristic values of each point on the surface grid by the weights and computing the sum of those values to arrive at a &quot;fitness&quot; value that is represented by the maximum height of the combined adaptive landscape. When a <code>new_data</code> component is present in <code>data</code> (e.g., because a <code>new_data</code> argument was supplied to <code>krige_surf()</code> or <code>data</code> is the output of a call to <code>krige_new_data()</code>), the weighted fitness values will be computed for the coordinates in <code>new_data</code> as well.
</p>


<h3>Value</h3>

<p>A <code>wtd_lscp</code> object, which contains the following components:
</p>
<table>
<tr><td><code>W</code></td>
<td>
<p>a named vector of the supplied weights</p>
</td></tr>
<tr><td><code>Wprime</code></td>
<td>
<p>a list containing the weighted <code>grid</code> and <code>new_data</code> components of <code>data</code>, where the values of the functional characteristics for each location on the surface are weighted by the supplied weights and an additiona column, <code>Z</code>, has been added containing the height of the adaptive landscape at that point.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+plot.wtd_lscp">plot.wtd_lscp</a></code> for plotting the resulting weighted landscape.
</p>
<p><code><a href="#topic+generate_weights">generate_weights</a></code> for generating a matrix of weights.
</p>
<p><code><a href="#topic+calc_all_lscps">calc_all_lscps</a></code> for computing weighted landscapes for a matrix of weights (i.e., rather than the single set of weights that can be used with <code>calc_lscp</code>). For finding an optimal set of weights, <code>calc_all_lscps</code> should be used, though it only produces the weighted fitness values for each set of weightd and not the weighted functional characteristic surfaces.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("warps")

warps_fnc &lt;- as_fnc_df(warps, func.names = c("hydro", "fea"))

kr_surf &lt;- krige_surf(warps_fnc)

weights &lt;- c(hydro = .5, fea = .5)

w_lscp &lt;- calc_lscp(kr_surf, weights = weights)

plot(w_lscp)

# Adding new_data
data("turtles")
kr_surf &lt;- krige_new_data(kr_surf, new_data = turtles)

w_lscp &lt;- calc_lscp(kr_surf, weights = weights)
w_lscp
plot(w_lscp)

## See further use with calc_all_lscps() 
## at help("calc_all_lscps")
</code></pre>

<hr>
<h2 id='calcGrpWprime'>
Compute optimally weighted adaptive landscapes
</h2><span id='topic+calcGrpWprime'></span><span id='topic+print.grp_Wprime'></span>

<h3>Description</h3>

<p><code>calcGrpWprime()</code> computes the optimally weighted adaptive landscape by searching through the adaptive landscapes formed from sets of weights and performance surfaces, and finding the set of weights that yields the greatest overall (average) fitness value (Z) across a sample of data or a subset thereof.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcGrpWprime(x, index, method = "chi-squared",
              quantile = 0.05)
## S3 method for class 'grp_Wprime'
print(x, 
      digits = max(3L, getOption("digits") - 3L), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcGrpWprime_+3A_x">x</code></td>
<td>

<p>for <code>calcGrpWprime()</code>, an <code>all_lscps</code> object; the output of a call to <code><a href="#topic+calc_all_lscps">calc_all_lscps</a></code>.
</p>
<p>for <code>print()</code>, a <code>grp_Wprime</code> object; the output of a call to <code>calcGrpWprime()</code>
</p>
</td></tr>
<tr><td><code id="calcGrpWprime_+3A_index">index</code></td>
<td>

<p>an optional vector of indices indicating which subset of the <code>new_data</code> dataset originally supplied to <code><a href="#topic+krige_surf">krige_surf</a></code> should be calculated. Can be specified as a vector of numerical indicies, logical indices, or row names. If unspecified, the optimal weights will be computed using the full sample. Supplied to <code><a href="base.html#topic+subset">subset</a></code>, so the name of the dataset containing the subsetting variable does not need to be included if the subsetting variable is in <code>new_data</code>. See Examples.
</p>
</td></tr>
<tr><td><code id="calcGrpWprime_+3A_method">method</code></td>
<td>

<p>the method used to compute the optimal weights. Allowable options include <code>"chi-square"</code> (the default), <code>"quantile"</code>, or <code>"max"</code>. <code>"chi-square"</code> and <code>"quantile"</code> involve averaging across the best several sets of weights, whereas <code>"max"</code> uses the singular best set of weights. Abbreviations allowed. See Details.
</p>
</td></tr>
<tr><td><code id="calcGrpWprime_+3A_quantile">quantile</code></td>
<td>

<p>when <code>method</code> is <code>"chi-square"</code> or <code>"quantile"</code>, the top quantile used to determine the best sets of weights to be included in the average to compute the optimal set of weights. Should be a number between 0 and 1, with a low value indicating that only the few top sets of weights will be used. Ignored when <code>method = "max"</code>.
</p>
</td></tr>
<tr><td><code id="calcGrpWprime_+3A_digits">digits</code></td>
<td>

<p>the number of significant digits to print.
</p>
</td></tr>
<tr><td><code id="calcGrpWprime_+3A_...">...</code></td>
<td>

<p>passed to <code><a href="base.html#topic+print.default">print.default</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>calcGrpWprime()</code> calculates an overall fitness score for each set of weights based on the average weighted fitness values of the indexed subgroup. The set of weights that optimizes this score is then produced as the weights defining the optimal adaptive landscape for that subgroup. The way the final set of weights is computed depends on the argument to <code>method</code>. When <code>method = "max"</code>, the single best set of weights is used. However, often many of the upper sets of weights perform equally or nearly equally as well as the best set. It is instead recommended to use <code>"quantile"</code> or <code>"chi-squared"</code> methods. When <code>method = "quantile"</code>, the top <code class="reqn">X\%</code> of weights are averaged to compute the optimal weights, where <code class="reqn">X</code> corresponds to the value supplied to <code>quantile</code>. When <code>method = "chi-square"</code>,  the chi-squared value <code class="reqn">\chi^2_i</code> is computed for each set of weights <code class="reqn">i</code> as </p>
<p style="text-align: center;"><code class="reqn">\chi^2_i = -2 \log \frac{Z_{max}}{Z_i}</code>
</p>

<p>where <code class="reqn">Z_{max}</code> is the largest <code class="reqn">Z</code> among the weights, and a p-value is computed for each <code class="reqn">\chi^2_i</code> value using a <code class="reqn">\chi^2</code> distribution with 2 d.f.; any set of weights with a p-value less than <code>quantile</code> is included to be averaged to compute the optimal set of weights.
</p>


<h3>Value</h3>

<p>A <code>grp_Wprime</code> object, which contains the following components:
</p>
<table>
<tr><td><code>Zprime</code></td>
<td>

<p>a list containing the optimal weights and the Z value they yield (<code>wn</code>), and, if <code>method</code> is <code>"chi-square"</code> or <code>"quantile"</code>, summary statistics about the best sets of weights used to compute the optimal weights, including the standard error (<code>wn.se</code>), standard deviation (<code>wn.sd</code>), and range (<code>wn.range</code>).
</p>
</td></tr>
<tr><td><code>W</code></td>
<td>

<p>a matrix containing all sets of weights (i.e., those supplied to the <code>grid_weights</code> argument of <code>calc_all_lscps()</code>) along with the Z value each yields, ordered in descending order by the yielded Z value. When <code>index</code> is specified, the resulting Z values are computed only using the indexed subset.
</p>
</td></tr>
<tr><td><code>Wprime</code></td>
<td>

<p>a <code><a href="#topic+wtd_lscp">wtd_lscp</a></code> object containing the optimal weights (<code>W</code>) and the landscape grid and sample functional characteristcs weighted by the optimal weights.
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Dickson, B. V., Clack, J. A., Smithson, T. R., &amp; Pierce, S. E. (2021). Functional adaptive landscapes predict terrestrial capacity at the origin of limbs. Nature, 589(7841), 242-245.
</p>
<p>Jones, K. E., Dickson, B. V., Angielczyk, K. D., &amp; Pierce, S. E. (2021). Adaptive landscapes challenge the &quot;lateral-to-sagittal&quot;&quot; paradigm for mammalian vertebral evolution. Current Biology, 31(9), 1883-1892.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calc_all_lscps">calc_all_lscps</a></code> for computing the landscapes which are to be optimized.
</p>
<p><code><a href="#topic+calcWprimeBy">calcWprimeBy</a></code> for finding optimal sets of weights for multiple subgroups defined by a subgrouping variable.
</p>
<p><code><a href="#topic+plot.grp_Wprime">plot.grp_Wprime</a></code> for plotting the resulting adaptive landscape.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("warps")
data("turtles")

warps_fnc &lt;- as_fnc_df(warps, 
                       func.names = c("hydro", "fea"))

kr_surf &lt;- krige_surf(warps_fnc, new_data = turtles)

grid_weights &lt;- generate_weights(n = 3, data = kr_surf)

all_lscps &lt;- calc_all_lscps(kr_surf,
                            grid_weights = grid_weights)
                            
wprime_S &lt;- calcGrpWprime(all_lscps,
                          index = Ecology == "S")
wprime_S
plot(wprime_S)
</code></pre>

<hr>
<h2 id='calcPoly'>
Calculate polynomial fits over a surface
</h2><span id='topic+calcPoly'></span><span id='topic+multiPoly'></span>

<h3>Description</h3>

<p><code>calcPoly</code> calls on the <code>spatial</code> package to fit rectangular spatial polynomial surface models by least-squares, or GLS. These methods allow the user to test whether data have spatial trends in morphospace. Outputs are a polynomial trend surface, and ANOVA table for the model fit. <code>multiPoly</code> applies <code>calcPoly</code> to a <code>fnc_df</code> with outputs for each trait. For more extensive documentation for model fitting see the <code>spatial</code> package. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcPoly(fnc, npoly = 3, fnc.name = NULL, 
         gls.covmod = list(covmod = expcov, d = 0.7, alpha = 0, se = 1), 
         pad = 1.2, resample = 100, range = NULL, verbose = FALSE)
                     
multiPoly(fnc_df, npoly = 3, ...)                     
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcPoly_+3A_fnc">fnc</code></td>
<td>

<p>an XYZ dataframe or matrix of a spatially distributed trait.  
</p>
</td></tr>
<tr><td><code id="calcPoly_+3A_fnc_df">fnc_df</code></td>
<td>

<p>a functional dataframe from <code>as_fnc_df</code> with colnames corresponding to X,Y and trait names.
</p>
</td></tr>
<tr><td><code id="calcPoly_+3A_npoly">npoly</code></td>
<td>

<p>singular numeric. Degree of polynomial to fit ragning from 1-4. For <code>multiPoly</code> this can also be a vector with length equal to the numer of traits in order to specify the degree of polynomial to apply to each trait.
</p>
</td></tr>
<tr><td><code id="calcPoly_+3A_gls.covmod">gls.covmod</code></td>
<td>

<p>Optional list of arguments to pass to <code>surf.gls</code> if fitting by generalized least-squares is desired. Defaults to NULL, and fitting is performed by least-squares. See <code><a href="spatial.html#topic+surf.gls">surf.gls</a></code> and <code><a href="spatial.html#topic+expcov">expcov</a></code> documentation for a full list of arguments and usage.
</p>
</td></tr>
<tr><td><code id="calcPoly_+3A_fnc.name">fnc.name</code></td>
<td>

<p>Optional speficiation of the trait name. Defaults to <code>NULL</code>, and will use column names instead.
</p>
</td></tr>
<tr><td><code id="calcPoly_+3A_pad">pad</code></td>
<td>

<p>Degree by which to extrapolate input data. Defaults to 1.2.
</p>
</td></tr>
<tr><td><code id="calcPoly_+3A_resample">resample</code></td>
<td>

<p>Resampling density. Corresponds to the number of points calculated along both X and   Y axes. Defaults to 100. If no resampling is desired, set <code>reample = NULL</code>
</p>
</td></tr>
<tr><td><code id="calcPoly_+3A_range">range</code></td>
<td>

<p>Optional. Manually set X and Y ranges. Input is a 2x2 matrix with rows corresponding to X and Y    ranges respectively.
</p>
</td></tr>
<tr><td><code id="calcPoly_+3A_verbose">verbose</code></td>
<td>

<p>Optional. Logical. If <code>TRUE</code>, will print ANOVA tables.
</p>
</td></tr>
<tr><td><code id="calcPoly_+3A_...">...</code></td>
<td>

<p>Arguments to pass onto <code>calcPoly</code> when using <code>multiPoly</code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fits polynomial trend surfaces using the 'spatial' package. First, an <code>npoly</code> polynomial trend surface is fit by least squares using <code><a href="spatial.html#topic+surf.ls">surf.ls</a></code> or generalized least-squares by <code><a href="spatial.html#topic+surf.gls">surf.gls</a></code>. GLS is fit by one of three covariance functions, exponential (<code>expcov</code>), gaussian (<code>gaucov</code>) or spherical (<code>sphercov</code>) and requires additional parameters to be passed as a list through <code>gls.covmod</code> (see examples). For a full description of arguments and usage see <code><a href="spatial.html#topic+surf.gls">surf.gls</a></code> and <code><a href="spatial.html#topic+expcov">expcov</a></code> documentation.
</p>
<p>The surface is then evaluated using <code><a href="spatial.html#topic+trmat">trmat</a></code> within limits set by input data, or manually using <code>range</code>. 
</p>


<h3>Value</h3>

<p>An object of class <code>poly_surf</code>, or <code>multi_surf</code> with the following components:
</p>
<table>
<tr><td><code>fnc.name</code></td>
<td>

<p>name of trait
</p>
</td></tr>
<tr><td><code>poly</code></td>
<td>
<p>Polynomial trend fit output from <code><a href="spatial.html#topic+surf.ls">surf.ls</a></code></p>
</td></tr>
<tr><td><code>surface</code></td>
<td>
<p>Evaluated trend surface output from <code><a href="spatial.html#topic+trmat">trmat</a></code></p>
</td></tr>
<tr><td><code>grid</code></td>
<td>
<p>Expanded surface in long XZY dataframe format</p>
</td></tr>
<tr><td><code>peak</code></td>
<td>
<p>Coordinates and height of the peak of the surface</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Blake V. Dickson</p>


<h3>References</h3>

<p>Dickson, B.V. and Pierce, S.E. (2019), Functional performance of turtle humerus shape across an ecological adaptive landscape. Evolution, 73: 1265-1277. https://doi.org/10.1111/evo.13747
</p>


<h3>See Also</h3>

<p><code><a href="spatial.html#topic+surf.ls">surf.ls</a></code>, 
<code><a href="spatial.html#topic+surf.gls">surf.gls</a></code>, 
<code><a href="spatial.html#topic+expcov">expcov</a></code>,
<code><a href="spatial.html#topic+trmat">trmat</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(spatial)

data("warps")
warps_fnc &lt;- as_fnc_df(warps)

# Make single trait dataframe 
hydro_fnc &lt;- data.frame(warps_fnc[ ,1:2], warps_fnc[ ,"hydro"])

polysurf &lt;- calcPoly(hydro_fnc)
summary(polysurf)
plot(polysurf)

# Fit using gls

polysurf &lt;- calcPoly(hydro_fnc, gls.covmod = list(covmod = expcov, d = 0.7, alpha = 0, se = 1))
## Not run: 
summary(polysurf)

## End(Not run)
plot(polysurf)

# Calculate multiple polynomial surfaces

multi_poly &lt;- multiPoly(warps_fnc)
## Not run: 
summary(multi_poly)

## End(Not run)
plot(multi_poly)

# Set manual range

polysurf &lt;- calcPoly(hydro_fnc, range = rbind(range(warps_fnc$x) * 1.2,
                                              range(warps_fnc$y) * 1.4))
                                              
polysurf &lt;- calcPoly(hydro_fnc, range = rbind(c(-0.2, 0.12),
                                              c(-0.06, 0.1)) )
## Not run: 
summary(polysurf)

## End(Not run)                                              
# 
# Adjust polynomial degree

multiPoly(warps_fnc, npoly = 2)

# Specify multiple degrees

multi_poly &lt;- multiPoly(warps_fnc, npoly = c(2,3,4,3))

## Not run: 
summary(polysurf)

## End(Not run)
plot(polysurf)

</code></pre>

<hr>
<h2 id='calcWprimeBy'>
Compute optimally weighted adaptive landscapes by subgroup
</h2><span id='topic+calcWprimeBy'></span><span id='topic+print.by_Wprime'></span><span id='topic+summary.by_Wprime'></span><span id='topic+print.summary.by_Wprime'></span>

<h3>Description</h3>

<p><code>calcWprimeBy()</code> computes the optimally weighted adaptive landscape by searching through the adaptive landscapes formed from sets of weights and performance surfaces, and finding the set of weights that yields the greatest overall (average) fitness value (Z) across subsets of a sample dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcWprimeBy(x, by, method = "chi-squared", quantile = 0.05)

## S3 method for class 'by_Wprime'
print(x, 
      digits = max(3L, getOption("digits") - 3L), ...)

## S3 method for class 'by_Wprime'
summary(object, ...)

## S3 method for class 'summary.by_Wprime'
print(x, 
      digits = max(3L, getOption("digits") - 3L), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcWprimeBy_+3A_x">x</code></td>
<td>

<p>for <code>calcWprimeBy()</code>, an <code>all_lscps</code> object; the output of a call to <code><a href="#topic+calc_all_lscps">calc_all_lscps</a></code>.
</p>
<p>for <code>print.by_Wprime()</code>, a <code>by_Wprime</code> object; the output of a call to <code>calcWprimeBy()</code>.
</p>
<p>for <code>print.summary.by_Wprime()</code>, a <code>by_Wprime</code> object; the output of a call to <code>summary.by_Wprime()</code>.
</p>
</td></tr>
<tr><td><code id="calcWprimeBy_+3A_by">by</code></td>
<td>

<p>a one-sided formula containing the grouping variable on the right hand side (e.g., <code>~g</code>) or a vector containing the subgrouping variable. When supplied as a formula, the grouping variable must be present in the global environment or in the <code>new_data</code> component in the <code>kriged_surfaces</code> object originally supplied to <code>calc_all_lscps()</code>.
</p>
</td></tr>
<tr><td><code id="calcWprimeBy_+3A_method">method</code></td>
<td>

<p>the method used to compute the optimal weights. Allowable options include <code>"chi-square"</code> (the default), <code>"quantile"</code>, or <code>"max"</code>. <code>"chi-square"</code> and <code>"quantile"</code> involve averaging across the best several sets of weights, whereas <code>"max"</code> uses the singular best set of weights. Abbreviations allowed. See <code><a href="#topic+calcGrpWprime">calcGrpWprime</a></code> for details.
</p>
</td></tr>
<tr><td><code id="calcWprimeBy_+3A_quantile">quantile</code></td>
<td>

<p>when <code>method</code> is <code>"chi-square"</code> or <code>"quantile"</code>, the top quantile used to determine the best sets of weights to be included in the average to compute the optimal set of weights. Should be a number between 0 and 1, with a low value indicating that only the few top sets of weights will be used. Ignored when <code>method = "max"</code>. See <code><a href="#topic+calcGrpWprime">calcGrpWprime</a></code> for details.
</p>
</td></tr>
<tr><td><code id="calcWprimeBy_+3A_digits">digits</code></td>
<td>

<p>the number of significant digits to print.
</p>
</td></tr>
<tr><td><code id="calcWprimeBy_+3A_...">...</code></td>
<td>

<p>passed to <code><a href="base.html#topic+print.default">print.default</a></code> and <code><a href="base.html#topic+print.table">print.table</a></code>.
</p>
</td></tr>
<tr><td><code id="calcWprimeBy_+3A_object">object</code></td>
<td>

<p>a <code>by_Wprime</code> object; the output of a call to <code>calcWprimeBy()</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>calcWprimeBy()</code> splits the sample data based on the <code>by</code> variable and then calls <code><a href="#topic+calcGrpWprime">calcGrpWprime</a></code> on each subset. The main benefit of using <code>calcWprimeBy()</code> is that the subgrouping variable is part of the output object and therefore can be used in plotting using <code><a href="#topic+plot.by_Wprime">plot.by_Wprime</a></code>.
</p>


<h3>Value</h3>

<p>A <code>by_Wprime</code> object contaning the following components:
</p>
<table>
<tr><td><code>by</code></td>
<td>
<p>the subgrouping variable supplied to <code>by</code>, stored as a factor and with a <code>"by_name"</code> attribute containing the name of the variable.</p>
</td></tr>
<tr><td><code>grp_Wprimes</code></td>
<td>
<p>a list of <code>grp_Wprime</code> objects, one for each level of the subgrouping variable.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+calc_all_lscps">calc_all_lscps</a></code> for computing the landscapes which are to be optimized.
</p>
<p><code><a href="#topic+calcGrpWprime">calcGrpWprime</a></code> for finding optimal sets of weights for a single subgroup.
</p>
<p><code><a href="#topic+plot.by_Wprime">plot.by_Wprime</a></code> for plotting the resulting adaptive landscapes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("warps")
data("turtles")

warps_fnc &lt;- as_fnc_df(warps, 
                       func.names = c("hydro", "fea"))

kr_surf &lt;- krige_surf(warps_fnc, new_data = turtles)

grid_weights &lt;- generate_weights(n = 3, data = kr_surf)

all_lscps &lt;- calc_all_lscps(kr_surf,
                            grid_weights = grid_weights)
                            
wprime_Ecology &lt;- calcWprimeBy(all_lscps, by = ~Ecology)
wprime_Ecology
summary(wprime_Ecology)
plot(wprime_Ecology)
</code></pre>

<hr>
<h2 id='generate_weights'>Generate a matrix containing weight combinations</h2><span id='topic+generate_weights'></span>

<h3>Description</h3>

<p><code>generate_weights()</code> generates a matrix containing weight combinations for a set of variables such that each set of weights sums to 1. This can be supplied to <code><a href="#topic+calc_all_lscps">calc_all_lscps</a></code> to calculate fitness landscapes corresponding to a variety of possible sets of weights for weighting functional characteristics. The weights are generated by partitioning a weight of 1 across however many variables are requested in all possible ways.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_weights(step, n, data = NULL, nvar = NULL,
                 varnames = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_weights_+3A_step">step</code></td>
<td>

<p><code>numeric</code>. The step size between weight partitions. Only one of <code>step</code> and <code>n</code> can be specified.
</p>
</td></tr>
<tr><td><code id="generate_weights_+3A_n">n</code></td>
<td>

<p><code>numeric</code>. The number of weight partitions between 0-1. Only one of <code>step</code> and <code>n</code> can be specified.
</p>
</td></tr>
<tr><td><code id="generate_weights_+3A_data">data</code></td>
<td>

<p>an optional <code>fnc_df</code> (the output of <code><a href="#topic+as_fnc_df">as_fnc_df</a></code>) or <code>kriged_surfaces</code> (the output <code><a href="#topic+krige_surf">krige_surf</a></code>) object. The number of variabes and their names will be extracted from the data as the functional characteristics present in them.
</p>
</td></tr>
<tr><td><code id="generate_weights_+3A_nvar">nvar</code></td>
<td>

<p>the number of variables across which to allocate the weights. Ignored if <code>data</code> is not <code>NULL</code>. If <code>nvar = NULL</code> and <code>varnames</code> is supplied, the length of <code>varnames</code> will be used for <code>nvar</code>.
</p>
</td></tr>
<tr><td><code id="generate_weights_+3A_varnames">varnames</code></td>
<td>

<p>the names of the variables across which to allocate the weights. Ignored if <code>data</code> is not <code>NULL</code>. If <code>varnames = NULL</code> and <code>nvar</code> is supplied, the sequence from 1 to <code>nar</code> will be used for <code>varnames</code>.
</p>
</td></tr>
<tr><td><code id="generate_weights_+3A_verbose">verbose</code></td>
<td>

<p>whether to display a message noting the number of sets of weights created.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>generate_weights()</code> works by fining all possible allocations of <code>n</code> objects into <code>nvar</code> bins. When <code>step</code> is supplied, <code>n</code> is computed as <code>round(1/step)</code>, so the resulting weight partitions may not be exactly equal to <code>step</code> when its inverse is not an integer. The larger <code>n</code> is (or the smaller <code>step</code>) is, the more possible allocations will be produced (i.e., and the resulting object will have more rows). The output of <code>generate_weights()</code> can quickly become very large with increasing number of variables, and will make subsequent analyses slow. It is recommended to start with a large <code>step</code> size, or small <code>n</code>, and increment up.
</p>


<h3>Value</h3>

<p>A <code>grid_weights</code> object, which is a matrix with a row for each each set of weights and a column for each variable over which the weights are allocated. The weights in each row will sum to 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Allocating 10 partitions of .1 across 3 variables
wmat &lt;- generate_weights(n = 10, nvar = 3)
head(wmat)

# Allocating 5 partitions of .2 across the 4 functional
# characteristics in the warps dataset
data("warps")

warps_fnc &lt;- as_fnc_df(warps)
wmat &lt;- generate_weights(n = 5, data = warps_fnc)
head(wmat)

# Using 'step' for the same result:
wmat &lt;- generate_weights(step = .2, data = warps_fnc)
head(wmat)
</code></pre>

<hr>
<h2 id='krige_surf'>
Interpolate functional characteristics over a grid
</h2><span id='topic+krige_surf'></span><span id='topic+krige_new_data'></span><span id='topic+kriged_surfaces'></span>

<h3>Description</h3>

<p><code>krige_surf()</code> performs kriging (i.e., interpolation) of one or more functional characteristics that are spatially distributed over a morphospace to create a smoothly kriged surface. Interpolated values can also be produced for a new dataset given their coordinates in morphological space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>krige_surf(fnc_df, grid = NULL, resample = 100, padding = 1.2, hull = NULL, 
  alpha = 1, new_data = NULL)
           
krige_new_data(x, new_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="krige_surf_+3A_fnc_df">fnc_df</code></td>
<td>

<p>a <code>fnc_df</code> object; the output of a call to <code><a href="#topic+as_fnc_df">as_fnc_df</a></code>, which contains coordinates in morphological space and values of functional characteristics for the warps used to create the kriged surface.
</p>
</td></tr>
<tr><td><code id="krige_surf_+3A_grid">grid</code></td>
<td>

<p>a matrix or data frame containing the grid of points over which the surface is to be interpolated. Should be the output of a call to <code><a href="#topic+resample_grid">resample_grid</a></code>. If <code>NULL</code>, the grid will be formed by calling <code>resample_grid()</code> on the inputs.
</p>
</td></tr>
<tr><td><code id="krige_surf_+3A_resample">resample</code></td>
<td>

<p>the number of points (or pixels) in the x and y dimensions over which to create the grid. Default is 100 for a kriged surface of 100x100=10,000 pixels. Passed to <code><a href="#topic+resample_grid">resample_grid</a></code>. Ignored when <code>grid</code> is not <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="krige_surf_+3A_padding">padding</code></td>
<td>

<p>a number representing how much to expand the grid beyond the ranges of the x- and y-coordinates. For example, <code>padding = 1.2</code> (the default) expands the grid by 20% of the coordinates' ranges in each direction. Must be a number greater than or equal to 1. Large numbers imply greater extrapolation, and whatever padding is added will be negated if <code>hull = TRUE</code>. Passed to <code><a href="#topic+resample_grid">resample_grid</a></code>. Ignored when <code>grid</code> is not <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="krige_surf_+3A_hull">hull</code></td>
<td>

<p>method to to restrict kriging to an alpha hull to prevent extrapolation beyond the coordinates present in <code>fnc_df</code>. Passed to <code><a href="#topic+resample_grid">resample_grid</a></code>, which uses <code>alphahull</code> or <code>concaveman</code> packages. Default is <code><a href="alphahull.html#topic+ahull">alphahull::ahull</a></code>. If no hull is desired set <code>hull = NULL</code>. If <code>NULL</code>, kriging will take place over a rectangular grid that spans the boundaries of the coordinates in <code>fnc_df</code>. Ignored when <code>grid</code> is not <code>NULL</code>
</p>
</td></tr>
<tr><td><code id="krige_surf_+3A_alpha">alpha</code></td>
<td>

<p>the alpha value used to create the alpha hull. Passed to <code><a href="#topic+resample_grid">resample_grid</a></code> and eventually to <code><a href="alphahull.html#topic+ahull">alphahull::ahull</a></code>. Ignored when <code>grid</code> is not <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="krige_surf_+3A_new_data">new_data</code></td>
<td>

<p>a dataset of coordinates for a new sample; the values of the functional characteristics for this sample will be interpolated using the kriged surface.
</p>
</td></tr>
<tr><td><code id="krige_surf_+3A_x">x</code></td>
<td>

<p>a <code>"kriged_surfaces"</code> object; the output of a call to <code>krige_surf()</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>krige_surf()</code> implements the <code><a href="automap.html#topic+autoKrige">automap::autoKrige</a></code> function on one or more spatially distributed traits to produce an interpolated (or extrapolated) surface of evenly spaced gridpoints. This is done by automatiically finding the best variogram fit for each of the non-corrdinate variables in <code>fnc_df</code>. For details on automatic variogram fitting, see <code><a href="automap.html#topic+autoKrige">automap::autoKrige</a></code>.
</p>
<p>Input data in <code>fnc_df</code> can be unevenly distributed (direct from speciments), or gridded (determined from evenly distributed hypothetical shapes) in morphospace. Trait data inputted directly from specimen measurements will be subject to error based on the how unevenly points are distributed, with high resoultion gridded datapoints producing the least potential reconstruction error (see Smith et al 2021).
</p>
<p>By default <code>krige_surf</code> will create a <code>hull</code> to strictly prevent any extrapolation beyond the provided data. This will produce the most conservative landscapes. If <code>hull</code> is set to <code>FALSE</code>, then the function will reconstruct a rectangle determined by the XY coordinate ranges supplied in <code>fnc_df</code>. Padding will be applied by default (an extra 20%) as defined by <code>padding</code>, to expand the rectangle beyond the supplied points. Reconstructions without a <code>hull</code> would be most appropriate for trait data determined from evenely spaced hypothetical gridpoints. If <code>grid</code> is provided the function will strictly interpolate at these gridded points.  
</p>
<p><code>krige_new_data()</code> adds a new data set to the supplied <code>kriged_surfaces</code> object and interpolates the values of the functional characteristics on the suppllied sample. This should only be used to add a new dataset to a <code>kriged_surfaces</code> object produced without <code>new_data</code> supplied or to replace an existing <code>new_data</code> component.
</p>


<h3>Value</h3>

<p>An object of class <code>kriged_surfaces</code> containing the following components:
</p>
<table>
<tr><td><code>fnc_df</code></td>
<td>
<p>the original data frame of functional characteristics passed to <code>fnc_df</code>.</p>
</td></tr>
<tr><td><code>autoKrige</code></td>
<td>
<p>a named list of the kriged surfaces, one for each functional characteristic. Each surface is of class <code>autoKrige</code>, the output of the call to <code><a href="automap.html#topic+autoKrige">automap::autoKrige</a></code>.</p>
</td></tr>
<tr><td><code>dataframes</code></td>
<td>
<p>a list of two data frames, <code>grid</code> and <code>new_data</code>. <code>grid</code> contains the coordinates of the kriged surface grid (in the <code>x</code> and <code>y</code> columns) as well as the interpolated values of the functional characteristics. <code>new_data</code> contains the sample coordinates supplied to <code>new_data</code> as well as the interpolated values of the functional characteristics for each sample. This second component is absent if <code>new_data = NULL</code> in the call to <code>krige_surf()</code>.</p>
</td></tr>
</table>
<p>For <code>krige_new_data()</code>, the original <code>kriged_surfaces</code> object, with the <code>$dataframes$new_data</code> component containing the sample coordinates supplied to <code>new_data</code> as well as the interpolated values of the functional characteristics for each sample.
</p>


<h3>References</h3>

<p>Smith, S. M., Stayton, C. T., &amp; Angielczyk, K. D. (2021). How many trees to see the forest? Assessing the effects of morphospace coverage and sample size in performance surface analysis. Methods in Ecology and Evolution, 12(8), 1411-1424.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.kriged_surfaces">plot.kriged_surfaces</a></code> for plotting the kriged surfaces.
</p>
<p><code><a href="#topic+as_fnc_df">as_fnc_df</a></code> for creating the input dataset.
</p>
<p><code><a href="#topic+resample_grid">resample_grid</a></code> for creating the grid over which the kriging occurs prior to using <code>krige_surf</code>.
</p>
<p><code><a href="automap.html#topic+autoKrige">automap::autoKrige</a></code> for the function that does the kriging.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("warps")

warps_fnc &lt;- as_fnc_df(warps)

grid &lt;- resample_grid(warps, hull = "concaveman", plot = TRUE)

kr_surf &lt;- krige_surf(warps_fnc, grid = grid)
kr_surf

# Add new data
data("turtles")
kr_surf &lt;- krige_new_data(kr_surf, new_data = turtles)
kr_surf
plot(kr_surf)

# Doing it all in one step:
## Not run: 
kr_surf &lt;- krige_surf(warps_fnc, new_data = turtles, hull = "alphahull")
kr_surf

## End(Not run)

# No hull and padding
kr_surf &lt;- krige_surf(warps_fnc, new_data = turtles, hull = NULL, padding = 1.2)
plot(kr_surf)


</code></pre>

<hr>
<h2 id='lands.grp.test'>
Significance tests between sets of weights
</h2><span id='topic+lands.grp.test'></span><span id='topic+print.lands.grp.test'></span><span id='topic+multi.lands.grp.test'></span><span id='topic+print.multi.lands.grp.test'></span>

<h3>Description</h3>

<p><code>lands.grp.test()</code> performs a statistical test for whether the optimal adaptive landscape for two subgroups are significantly different from each other. The p-value of the test is the proportion of weight sets that are shared between the two subgroups among their respective top weight sets. <code>multi.lands.grp.test()</code> performs this test for all pairs of subgroups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lands.grp.test(grpa, grpb, method = "chi-squared",
               quantile = 0.05)

multi.lands.grp.test(x, method = "chi-squared",
                     quantile = 0.05)

## S3 method for class 'lands.grp.test'
print(x, digits = max(3L, getOption("digits") - 3L), ...)

## S3 method for class 'multi.lands.grp.test'
print(x, digits = max(3L, getOption("digits") - 3L), 
      style = "matrix", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lands.grp.test_+3A_grpa">grpa</code>, <code id="lands.grp.test_+3A_grpb">grpb</code></td>
<td>

<p>for <code>lands.grp.test()</code>, the two <code>grp_Wprime</code> objects containing the adaptive landscapes to be compared; these are the output of calls to <code><a href="#topic+calcGrpWprime">calcGrpWprime</a></code>.
</p>
</td></tr>
<tr><td><code id="lands.grp.test_+3A_x">x</code></td>
<td>

<p>for <code>multi.lands.grp.test()</code>, a <code>by_Wprime</code> object, the output of a call to <code><a href="#topic+calcWprimeBy">calcWprimeBy</a></code>.
</p>
<p>for <code>print()</code>, the output of a call to <code>lands.grp.test()</code> or <code>multi.lands.grp.test()</code>.
</p>
</td></tr>
<tr><td><code id="lands.grp.test_+3A_method">method</code></td>
<td>

<p>the method used to determine which sets of weights are in the &quot;best&quot; sets of weights that are to be comapred between the two groups. Allowable options include <code>"chi-squared"</code> and <code>"quantile"</code>. See <code><a href="#topic+calcGrpWprime">calcGrpWprime</a></code> for details.
</p>
</td></tr>
<tr><td><code id="lands.grp.test_+3A_quantile">quantile</code></td>
<td>

<p>the top quantile used to determine the best sets of weights to be included in the average to compute the optimal set of weights. Should be a number between 0 and 1, with a low value indicating that only the few top sets of weights will be used. See <code><a href="#topic+calcGrpWprime">calcGrpWprime</a></code> for details.
</p>
</td></tr>
<tr><td><code id="lands.grp.test_+3A_digits">digits</code></td>
<td>

<p>the number of significant digits to print.
</p>
</td></tr>
<tr><td><code id="lands.grp.test_+3A_style">style</code></td>
<td>

<p>how to display the results of the pairwise tests; allowable options include <code>"matrix"</code> and <code>"table"</code>. Abbreviations allowed.
</p>
</td></tr>
<tr><td><code id="lands.grp.test_+3A_...">...</code></td>
<td>

<p>passed to <code><a href="base.html#topic+print.default">print.default</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>lands.grp.test()</code> performs pairwise comparisons between two adaptive groups by comparing the number of shared landscapes <code class="reqn">n_{A+B}</code> in the top percentile of each group with the total number of landscapes in this top percentile <code class="reqn">n_{total}</code>. The probability <code class="reqn">P(A=B)</code> thus is calculated as:
</p>
<p style="text-align: center;"><code class="reqn">
P(A=B) = n_{A+B}/n_{total}
</code>
</p>

<p>If <code>method = "quantile"</code> is used, then the top percentile is defined by <code>quantile</code>. If <code>method = "chi-squared"</code> is used, then the top percentile is calculated from the chi-squared value <code class="reqn">\chi^2_i</code> as: </p>
<p style="text-align: center;"><code class="reqn">\chi^2_i = -2 \log \frac{Z_{max}}{Z_i}</code>
</p>
<p> where <code class="reqn">Z_{max}</code> is the largest <code class="reqn">Z</code> among the weights, and a p-value is computed for each <code class="reqn">\chi^2_i</code> value using a <code class="reqn">\chi^2</code> distribution with 2 d.f.; any set of weights with a p-value less than <code>quantile</code> is included in the optimal set of weights.
</p>
<p><code>multi.lands.grp.test()</code> is a wrapper for <code>lands.grp.test()</code>, applying the function pairwise to all combinations of groups calculated by <code><a href="#topic+calcWprimeBy">calcWprimeBy</a></code>.
</p>


<h3>Value</h3>

<p>For <code>lands.grp.test()</code>, a <code>lands.grp.test</code> object containing the following components:
</p>
<table>
<tr><td><code>n.match</code></td>
<td>
<p>the number of sets of weights that match between the two supplied subgroups</p>
</td></tr>
<tr><td><code>p.val</code></td>
<td>
<p>the p-value of the test, computed as the number of sets of weights that match divided by the number of sets of weights compared</p>
</td></tr>
<tr><td><code>matching</code></td>
<td>
<p>a matrix containing the sets of weights that match between the two subgroups</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>the argument supplied to <code>method</code></p>
</td></tr>
<tr><td><code>quantile</code></td>
<td>
<p>the argument supplied to <code>quantile</code></p>
</td></tr>
</table>
<p>For <code>multi.lands.grp.test()</code>, a <code>multi.lands.grp.test</code> object containing the following components:
</p>
<table>
<tr><td><code>res</code></td>
<td>
<p>a data frame containing the results of the tests, with the columns <code>Group A</code> and <code>Group B</code> indicating the groups involved in the comparison, the column <code>Matches</code> containing the number of matching sets of weights in the comparison, and the column <code>p value</code> containing the p-value of the test.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>the argument supplied to <code>method</code></p>
</td></tr>
<tr><td><code>quantile</code></td>
<td>
<p>the argument supplied to <code>quantile</code></p>
</td></tr>
</table>
<p>For <code>print.multi.lands.grp.test()</code>, setting <code>style = "table"</code> prints the <code>res</code> component as-is; setting <code>style = "matrix"</code> creates a matrix where the p-values of the test are below the diagonal and the number of matches of the test are above the diagonal.
</p>


<h3>References</h3>

<p>Jones, K. E., Dickson, B. V., Angielczyk, K. D., &amp; Pierce, S. E. (2021). Adaptive landscapes challenge the &quot;lateral-to-sagittal&quot;&quot; paradigm for mammalian vertebral evolution. Current Biology, 31(9), 1883-1892.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calcGrpWprime">calcGrpWprime</a></code> and <code><a href="#topic+calcWprimeBy">calcWprimeBy</a></code> for creatign the objects used as inputs to these functions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("warps")
data("turtles")

warps_fnc &lt;- as_fnc_df(warps, 
                       func.names = c("hydro", "fea"))

kr_surf &lt;- krige_surf(warps_fnc, new_data = turtles)

grid_weights &lt;- generate_weights(n = 3, data = kr_surf)

all_lscps &lt;- calc_all_lscps(kr_surf,
                            grid_weights = grid_weights)

# Comparing adaptive landscapes of Ecology groups S and M
wprime_S &lt;- calcGrpWprime(all_lscps,
                          index = Ecology == "S")
wprime_M &lt;- calcGrpWprime(all_lscps,
                          index = Ecology == "M")
lands.grp.test(wprime_S, wprime_M)

# Comparing adaptive landscapes of all Group subgroups
wprime_by_Group &lt;- calcWprimeBy(all_lscps, by = ~Group)
tests &lt;- multi.lands.grp.test(wprime_by_Group)
tests
print(tests, style = "table")
</code></pre>

<hr>
<h2 id='lscp_operations'>
Simple Operations on Spatial Data
</h2><span id='topic+sum_lscps'></span><span id='topic+sub_lscps'></span><span id='topic+div_lscps'></span><span id='topic+mult_lscps'></span>

<h3>Description</h3>

<p>Perform simple operations (sum, sub, mult, div) on one or multiple landscapes (see details for use cases)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sum_lscps(lscps, num = NULL, average = TRUE)
mult_lscps(lscps, num = NULL)
sub_lscps(lscps, binary = FALSE)
div_lscps(lscps, binary = FALSE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lscp_operations_+3A_lscps">lscps</code></td>
<td>

<p>A named list containing datasets of spatial data to apply operations (see details). </p>
</td></tr>
<tr><td><code id="lscp_operations_+3A_num">num</code></td>
<td>

<p>Optional. Defaults to NULL. A vector containing a single numeric scalar or numeric vector with length = lscps to scale by when using <code>sum_lscps</code> and <code>mult_lscps()</code>. If NULL, these functions will operate between lscps. If num is provided, these functions will operate between lscps and num.  
</p>
</td></tr>
<tr><td><code id="lscp_operations_+3A_binary">binary</code></td>
<td>

<p>If subracting or dividing landscapes, binarize result to obtain logical [0,1] result (see details for use case)
</p>
</td></tr>
<tr><td><code id="lscp_operations_+3A_average">average</code></td>
<td>

<p>if summation is performed, should the result be averaged for the number of landscapes 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simple operations are applied to one or more landscapes depending on use case. Spatial datasets can be supplied in an XYZ dataframe, or as any landscape output from Morphoscape. 
</p>
<p>sum - sum a single spatial dataset/landscape with a single scalar (<code>lscp1 + num1</code>); sum two or more spatial datasets/landscapes together (<code>lscp1 + lscp2 ... lscpN</code>); or sum multiple landscapes with multiple scalars (<code>(lscp1, lscp2 ... lscpN) + (num1, num2, ..., numN)</code>)
</p>
<p>mult - multiply a single spatial dataset/landscape with a single scalar (<code>lscp1 * num1</code>); multiply two or more spatial datasets/landscapes together (<code>lscp1 * lscp2 ... lscpN</code>); or multiply multiple landscapes with multiple scalars (<code>(lscp1, lscp2 ... lscpN) * (num1, num2, ..., numN)</code>)
</p>
<p>sub - substract one spatial dataset/landscape from another (<code>lscp1 - lscp2</code>). If numeric subtraction is desired, use sum_lscps with negative <code>num</code> values.
</p>
<p>div - divide one spatial dataset by another (<code>lscp1 / lscp2</code>).
</p>
<p><code>sub_lscps()</code> and <code>div_lscps</code> can be used to construct transition landscapes per (Dickson et al 2020) which can compare performance between two adaptive regimes. If binary = T is used, the result will be a spatial representation of which parent landscape dominates. However, it is recommended to use <code>trans_lscps</code> or <code>adpt_regions</code> to calculate transtional landscapes or adaptive regions (not yet implemented).
</p>


<h3>Value</h3>

<p>An object of class &quot;combined.surface&quot; containing XYZ spatial data.
</p>


<h3>Author(s)</h3>

<p>Blake V. Dickson</p>


<h3>See Also</h3>

<p><code><a href="#topic+krige_surf">krige_surf</a></code>, <code><a href="#topic+calcGrpWprime">calcGrpWprime</a></code>, <code><a href="#topic+calc_lscp">calc_lscp</a></code>, <code><a href="#topic+calcPoly">calcPoly</a></code>, <code>trans_lscps</code>, <code>adpt_regions</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require("Morphoscape")

data("turtles")
data("warps")

fnc_df &lt;- as_fnc_df(warps, 
                       func.names = c("hydro", "curve", "mech", "fea"))

kr_surf &lt;- krige_surf(fnc_df, new_data = turtles)

grid_weights &lt;- generate_weights(n = 10, data = kr_surf)

all_lscps &lt;- calc_all_lscps(kr_surf,
                            grid_weights = grid_weights)

wprime_S &lt;- calcGrpWprime(all_lscps,
                          index = Ecology == "S")

wprime_T &lt;- calcGrpWprime(all_lscps,
                          index = Ecology == "T")
                          
lscps &lt;- list(wprimeS = wprime_S, wprime_T = wprime_T)
                       
# summing multiple landscapes together

summed_surfs &lt;- sum_lscps(lscps, average = TRUE)

# summing landscapes by one or more numeric scalars

summed_surfs &lt;- sum_lscps(lscps, num = c(1.5, -1.15)) # multiple numeric, with subtraction

# multiplying mutliple landscapes together
mult_surfs &lt;- mult_lscps(lscps) # multiply landscapes together

# multiplying landscapes by one or more numeric scalars
mult_surfs &lt;- mult_lscps(lscps, num = 2) # apply numeric multiplier to all landscapes
mult_surfs &lt;- mult_lscps(lscps, num = c(1.2, 0.8)) # apply numeric elements to each landscape

# substract or divide two landscapes

sub_surf &lt;- sub_lscps(lscps)
div_surf &lt;- div_lscps(lscps)

# with binary result

sub_surf &lt;- sub_lscps(lscps, binary = TRUE)
div_surf &lt;- div_lscps(lscps, binary = TRUE)

</code></pre>

<hr>
<h2 id='plot.kriged_surfaces'>
Plots Kriged surfaces of functional characteristics
</h2><span id='topic+plot.kriged_surfaces'></span>

<h3>Description</h3>

<p><code>plot.kriged_surfaces()</code> produces spatial landscape plots of kriged surfaces produced by <code><a href="#topic+krige_surf">krige_surf</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'kriged_surfaces'
plot(x, alpha = 0.5, pt.col = "black",
     interpolate = TRUE, contour = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.kriged_surfaces_+3A_x">x</code></td>
<td>

<p>a <code>kriged_surfaces</code> object; the output of a call to <code><a href="#topic+krige_surf">krige_surf</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.kriged_surfaces_+3A_alpha">alpha</code>, <code id="plot.kriged_surfaces_+3A_pt.col">pt.col</code></td>
<td>

<p>when a <code>new_data</code> component is present in <code>x</code>, the transparency (<code>alpha</code>) and color (<code>pt.col</code>) of the points plotted for the new samples.
</p>
</td></tr>
<tr><td><code id="plot.kriged_surfaces_+3A_interpolate">interpolate</code></td>
<td>

<p><code>logical</code>; whether to smooth the plot by interpolating across pixels in the grid. Passed to <code><a href="ggplot2.html#topic+geom_raster">ggplot2::geom_raster</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.kriged_surfaces_+3A_contour">contour</code></td>
<td>

<p><code>logical</code>; whether to add contour lines to the plot to illustrate changes in the fitness landscape.
</p>
</td></tr>
<tr><td><code id="plot.kriged_surfaces_+3A_...">...</code></td>
<td>

<p>ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plot.kriged_surfaces()</code> is a wrapper for <span class="pkg">ggplot2</span> raster plotting functions. For more precise control of raster plotting see <code><a href="ggplot2.html#topic+geom_raster">ggplot2::geom_raster</a></code>.
</p>


<h3>Value</h3>

<p>A <code>ggplot</code> object, which can be further manipulated using <span class="pkg">ggplot2</span> functionality.
</p>


<h3>See Also</h3>

<p><code><a href="ggplot2.html#topic+ggplot">ggplot2::ggplot</a></code>, <code><a href="ggplot2.html#topic+geom_raster">ggplot2::geom_raster</a></code>, and <code><a href="ggplot2.html#topic+geom_contour">ggplot2::geom_contour</a></code> for the underlying plotting functions. See also <code><a href="sp.html#topic+spplot">sp::spplot</a></code> for alternative plotting functions.
</p>
<p><code><a href="#topic+krige_surf">krige_surf</a></code> for generating the kriged surfaces. <code><a href="#topic+krige_new_data">krige_new_data</a></code> for adding a <code>new_data</code> component to an existing kriged surface before plotting.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See examples at help("krige_surf")
</code></pre>

<hr>
<h2 id='plot.wtd_lscp'>
Plot Adaptive Landscapes
</h2><span id='topic+plot.wtd_lscp'></span><span id='topic+plot.grp_Wprime'></span><span id='topic+plot.by_Wprime'></span>

<h3>Description</h3>

<p>These <code>plot</code> plot methods plot an adaptive landscape, a weighted combination of functional surfaces. These landscape arise from calls to <code><a href="#topic+calc_lscp">calc_lscp</a></code>, <code><a href="#topic+calc_all_lscps">calc_all_lscps</a></code>, <code><a href="#topic+calcGrpWprime">calcGrpWprime</a></code>, and <code><a href="#topic+calcWprimeBy">calcWprimeBy</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wtd_lscp'
plot(x, alpha = 1, pt.col = "black", 
     interpolate = TRUE, contour = TRUE, ...)
## S3 method for class 'grp_Wprime'
plot(x, alpha = 1, pt.col = "black", 
     interpolate = TRUE, contour = TRUE, ...)
## S3 method for class 'by_Wprime'
plot(x, level, ncol = 1, alpha = 1,
     pt.col = "black", interpolate = TRUE, contour = TRUE, 
     ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.wtd_lscp_+3A_x">x</code></td>
<td>

<p>a <code>wtd_lscp</code>, <code>grp_Wprime</code>, or <code>by_Wprime</code> object, the output of a call to <code><a href="#topic+calc_lscp">calc_lscp</a></code>, <code><a href="#topic+calcGrpWprime">calcGrpWprime</a></code>, or <code><a href="#topic+calcWprimeBy">calcWprimeBy</a></code>, respectively.
</p>
</td></tr>
<tr><td><code id="plot.wtd_lscp_+3A_alpha">alpha</code></td>
<td>

<p>the transparency of the points for the data sample. A number between 0 (fully transparent) and 1 (fully opaque). Passed to <code><a href="ggplot2.html#topic+geom_point">ggplot2::geom_point</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.wtd_lscp_+3A_pt.col">pt.col</code></td>
<td>

<p>the color of the points for the data sample. Passed to <code><a href="ggplot2.html#topic+geom_point">ggplot2::geom_point</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.wtd_lscp_+3A_interpolate">interpolate</code></td>
<td>

<p>whether to interpolate across pixels in the grid. Passed to <code><a href="ggplot2.html#topic+geom_raster">ggplot2::geom_raster</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.wtd_lscp_+3A_contour">contour</code></td>
<td>

<p>whether to display contours in the grid.
</p>
</td></tr>
<tr><td><code id="plot.wtd_lscp_+3A_level">level</code></td>
<td>

<p>which level of the <code>by</code> (subgrouping) variable to be plotted. If missing, all will be plotted.
</p>
</td></tr>
<tr><td><code id="plot.wtd_lscp_+3A_ncol">ncol</code></td>
<td>

<p>when multiple subgroups are plotted, in how many columns should the plots be arranged.
</p>
</td></tr>
<tr><td><code id="plot.wtd_lscp_+3A_...">...</code></td>
<td>

<p>ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These plotting functions are wrappers for <code>ggplot2</code> raster plotting functions. For more precise control of raster plotting see <code><a href="ggplot2.html#topic+geom_raster">ggplot2::geom_raster</a></code>.
</p>


<h3>Value</h3>

<p>A <code>ggplot</code> object that can be further adjusted using functions from <span class="pkg">ggplot2</span>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calc_lscp">calc_lscp</a></code>, <code><a href="#topic+calc_all_lscps">calc_all_lscps</a></code>, <code><a href="#topic+calcGrpWprime">calcGrpWprime</a></code>, and <code><a href="#topic+calcWprimeBy">calcWprimeBy</a></code> for the functions used to create the objects that are plotted
</p>
<p><code><a href="#topic+plot.kriged_surfaces">plot.kriged_surfaces</a></code> for plotting functional surfaces prior to combining them into an adaptive landscape.
</p>
<p><code><a href="ggplot2.html#topic+geom_raster">ggplot2::geom_raster</a></code>, <code><a href="ggplot2.html#topic+geom_point">ggplot2::geom_point</a></code>, and <code><a href="ggplot2.html#topic+geom_contour">ggplot2::geom_contour</a></code> for the underlying plotting functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("warps")
data("turtles")

warps_fnc &lt;- as_fnc_df(warps, func.names = c("hydro", "fea"))

kr_surf &lt;- krige_surf(warps_fnc, new_data = turtles)

weights &lt;- c(hydro = .5, fea = .5)

w_lscp &lt;- calc_lscp(kr_surf, weights = weights)

plot(w_lscp)
plot(w_lscp, countour = FALSE, pt.col = "white")

# See help("calc_lscp"), help("calcGrpWprime"), and 
# help("calcWprimeBy") for examples when used with
# those functions
</code></pre>

<hr>
<h2 id='resample_grid'>
Create a full grid from a set of coordinates
</h2><span id='topic+resample_grid'></span>

<h3>Description</h3>

<p><code>resample_grid()</code> creates a rectangular grid around supplied coordinates by resampling evenly spaced points between the minimum and maximum values of each coordinate dimension. The grid can optionally be reduced to a convex or concave hull around the supplied coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resample_grid(coords2D, resample = 100, padding = 1.2, hull = NULL, alpha = 1, 
  plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resample_grid_+3A_coords2d">coords2D</code></td>
<td>

<p>a 2-column matrix data frame of coordinates with the x-coordinates in the first column and the y-coordinates in the second column. The ranges of each column will be used to create the resampled grid.
</p>
</td></tr>
<tr><td><code id="resample_grid_+3A_resample">resample</code></td>
<td>

<p>the number of points (or pixels) in the x and y dimensions over which to create the grid. Default is 100 for a kriged surface of 100x100=10,000 pixels.
</p>
</td></tr>
<tr><td><code id="resample_grid_+3A_padding">padding</code></td>
<td>

<p>a number representing how much to expand the grid beyond the ranges of the x- and y-coordinates. For example, <code>padding = 1.2</code> (the default) expands the grid by 20% of the coordinates' ranges in each direction. Must be a number greater than or equal to 1. Large numbers imply greater extrapolation, and whatever padding is added will be negated if <code>hull</code> is specified.
</p>
</td></tr>
<tr><td><code id="resample_grid_+3A_hull">hull</code></td>
<td>

<p>method to restrict the grid to an alpha hull using <code>alphahull]</code> or <code>concaveman</code> packages. Default is 'NULL' and no hull will be calculated.
</p>
</td></tr>
<tr><td><code id="resample_grid_+3A_alpha">alpha</code></td>
<td>

<p>when <code>hull != NULL</code>, the alpha value used to create the hull. Passed to <code>ahull</code> or <code>concaveman</code>.
</p>
</td></tr>
<tr><td><code id="resample_grid_+3A_plot">plot</code></td>
<td>

<p>Logical. When <code>hull</code> is specified, whether to plot the resulting hull overlayed over the original grid. Default is <code>TRUE</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with two columns, <code>x</code> and <code>y</code>, containing the resampled coordinate grid. When <code>hull</code> is specified, any points not in the hull will be absent.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+krige_surf">krige_surf</a></code>, which uses <code>resample_grid</code> for kriging.
</p>
<p><code>ahull</code> and <code>inahull</code>, or <code>concaveman</code> for creating the hull.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("warps")

warps_fnc &lt;- as_fnc_df(warps)

# hull with plot to see the hull
grid &lt;- resample_grid(warps_fnc[c("x", "y")],
                      hull = "concaveman", plot = TRUE)
str(grid)

## Not run: 
# Alpha hull with plot to see the hull
grid &lt;- resample_grid(warps_fnc[c("x", "y")],
                      hull = "alphahull", plot = TRUE)

## End(Not run)


</code></pre>

<hr>
<h2 id='turtles'>
Turtle Humeri
</h2><span id='topic+turtles'></span>

<h3>Description</h3>

<p>A dataset containing a sample of 40 turtle humeri used in Dickson and Pierce (2019).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("turtles")</code></pre>


<h3>Format</h3>

<p>A data frame with 40 observations on the following 4 variables.
</p>

<dl>
<dt><code>x</code></dt><dd><p>the first axis of shape variation as determiend by a between-groups principal components analysis</p>
</dd>
<dt><code>y</code></dt><dd><p>the second axis of shape variation as determiend by a between-groups principal components analysis</p>
</dd>
<dt><code>Group</code></dt><dd><p>the locomotor ecologies of the turtles</p>
</dd>
<dt><code>Ecology</code></dt><dd><p>the three ecological groups as determined by a Procrustes ANOVA; &quot;M&quot; (marine), &quot;S&quot; (semiaquatic), and &quot;T&quot; (terrestrial)</p>
</dd>
</dl>



<h3>Source</h3>

<p>Dickson, B.V. and Pierce, S.E. (2019), Functional performance of turtle humerus shape across an ecological adaptive landscape. Evolution, 73: 1265-1277. <a href="https://doi.org/10.1111/evo.13747">doi:10.1111/evo.13747</a>
</p>

<hr>
<h2 id='warps'>
Simulated Shape Warps
</h2><span id='topic+warps'></span>

<h3>Description</h3>

<p>Trait data for simulated shape warps of turtle humeri used to study the morphological evolution of turtles in Dickson and Pierce (2019). The morphospace was defined by a geometric morphometric analyises of 1028 psuedolandmarks on 40 turtle humeri. Hypothetical shape warps were then produced on a 4x6 grid accross morphospace. For each shape warp, four functional traits were measured, corresponding to a locomotory performance trait: stress under simulated load (strength), bone curvature (stride length), muscular mechanical advantage (mechanical advantage), and frontal area (hydrodynamics).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("warps")</code></pre>


<h3>Format</h3>

<p>A data frame with 24 observations on the following 6 variables.
</p>

<dl>
<dt><code>x</code></dt><dd><p>the first axis of shape variation as determiend by a between-groups principal components analysis of the <code><a href="#topic+turtles">turtles</a></code> dataset</p>
</dd>
<dt><code>y</code></dt><dd><p>the second axis of shape variation as determiend by a between-groups principal components analysis of the <code><a href="#topic+turtles">turtles</a></code> dataset</p>
</dd>
<dt><code>hydro</code></dt><dd><p>hydrodynamics</p>
</dd>
<dt><code>curve</code></dt><dd><p>stride length</p>
</dd>
<dt><code>mech</code></dt><dd><p>mechanical advantage</p>
</dd>
<dt><code>fea</code></dt><dd><p>strength (assessed using finite element analysis)</p>
</dd>
</dl>



<h3>Source</h3>

<p>Dickson, B.V. and Pierce, S.E. (2019), Functional performance of turtle humerus shape across an ecological adaptive landscape. Evolution, 73: 1265-1277. <a href="https://doi.org/10.1111/evo.13747">doi:10.1111/evo.13747</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
