<!DOCTYPE html><html lang="en"><head><title>Help for package arfima</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {arfima}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#arfima-package'><p>Simulates, fits, and predicts persistent and anti-persistent time series.</p>
arfima</a></li>
<li><a href='#AIC.arfima'><p>Information criteria for <code>arfima</code> objects</p></a></li>
<li><a href='#arfima'><p>Fit ARFIMA, ARIMA-FGN, and ARIMA-PLA (multi-start) models</p>
</p>
<p>Fits ARFIMA/ARIMA-FGN/ARIMA-PLA multi-start models to times series data.</p>
Options include fixing parameters, whether or not to fit fractional noise,
what type of fractional noise (fractional Gaussian noise (FGN), fractionally
differenced white noise (FDWN), or the newly introduced power-law
autocovariance noise (PLA)), etc.  This function can fit regressions with
ARFIMA/ARIMA-FGN/ARIMA-PLA errors via the xreg argument, including dynamic
regression (transfer functions).</a></li>
<li><a href='#arfima.sim'><p>Simulate an ARFIMA time series.</p></a></li>
<li><a href='#arfima0'><p>Exact MLE for ARFIMA</p>
</p>
<p>The time series is corrected for the sample mean and then exact MLE is used</p>
for the other parameters. This is a simplified version of the arfima()
function that may be useful in simulations and bootstrapping.</a></li>
<li><a href='#arfimachanges'><p>Prints changes to the package since the last update.  Started in 1.4-0</p></a></li>
<li><a href='#ARToPacf'><p>Converts AR/MA coefficients from operator space to the PACF space</p></a></li>
<li><a href='#bestModes'><p>Finds the best modes of an <code>arfima</code> fit.</p></a></li>
<li><a href='#coef.arfima'><p>Extract Model Coefficients</p></a></li>
<li><a href='#distance'><p>The distance between modes of an <code>arfima</code> fit.</p></a></li>
<li><a href='#fitted.arfima'><p>Extract Model Fitted Values</p></a></li>
<li><a href='#iARFIMA'><p>The Fisher information matrix of an ARFIMA process</p></a></li>
<li><a href='#IdentInvertQ'><p>Checks invertibility, stationarity, and identifiability of a given set of</p>
parameters</a></li>
<li><a href='#lARFIMA'><p>Exact log-likelihood of a long memory model</p></a></li>
<li><a href='#lARFIMAwTF'><p>Exact log-likelihood of a long memory model with a transfer function model</p>
and series included
</p>
<p>Computes the exact log-likelihood of a long memory model with respect to a</p>
given time series as well as a transfer fucntion model and series. This
function is not meant to be used directly.</a></li>
<li><a href='#logLik.arfima'><p>Extract Log-Likelihood Values</p></a></li>
<li><a href='#PacfToAR'><p>Converts AR/MA coefficients from the PACF space to operator space</p></a></li>
<li><a href='#plot.predarfima'><p>Plots the original time series, the predictions, and the prediction</p>
intervals for a <code>predarfima</code> object.</a></li>
<li><a href='#plot.tacvf'><p>Plots the output from a call to <code>tacvf</code></p></a></li>
<li><a href='#predict.arfima'><p>Predicts from a fitted object.</p></a></li>
<li><a href='#print.arfima'><p>Prints a Fitted Object</p></a></li>
<li><a href='#print.predarfima'><p>Prints predictions and prediction intervals</p></a></li>
<li><a href='#print.summary.arfima'><p>Prints the output of a call to <code>summary</code> on an <code>arfima</code> object</p></a></li>
<li><a href='#print.tacvf'><p>Prints a tacvf object.</p></a></li>
<li><a href='#removeMode'><p>Removes a mode from an <code>arfima</code> fit.</p></a></li>
<li><a href='#residuals.arfima'><p>Extract the Residuals of a Fitted Object</p></a></li>
<li><a href='#SeriesJ'><p>Series J, Gas Furnace Data</p></a></li>
<li><a href='#sim_from_fitted'><p>Simulate an ARFIMA time series from a fitted arfima object.</p></a></li>
<li><a href='#summary.arfima'><p>Extensive Summary of an Object</p></a></li>
<li><a href='#tacfplot'><p>Plots the theoretical autocorralation functions (tacfs) of one or more fits.</p></a></li>
<li><a href='#tacvf'><p>Extracts the tacvfs of a fitted object</p></a></li>
<li><a href='#tacvfARFIMA'><p>The theoretical autocovariance function of a long memory process.</p></a></li>
<li><a href='#tmpyr'><p>Temperature Data</p></a></li>
<li><a href='#vcov.arfima'><p>Extracts the Variance-Covariance Matrix</p></a></li>
<li><a href='#weed'><p>Weeds out fits from a call to arfima that are too close to each other.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Fractional ARIMA (and Other Long Memory) Time Series Modeling</td>
</tr>
<tr>
<td>Version:</td>
<td>1.8-1</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-08-18</td>
</tr>
<tr>
<td>Author:</td>
<td>JQ (Justin) Veenstra [aut, cre], A.I. McLeod [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>JQ Veenstra &lt;jqveenstra@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), ltsa</td>
</tr>
<tr>
<td>Imports:</td>
<td>parallel</td>
</tr>
<tr>
<td>Description:</td>
<td>Simulates, fits, and predicts long-memory and anti-persistent
	time series, possibly mixed with ARMA, regression, transfer-function
	components.
	Exact methods (MLE, forecasting, simulation) are used.
	Bug reports should be done via GitHub (at
	<a href="https://github.com/JQVeenstra/arfima">https://github.com/JQVeenstra/arfima</a>), where the development version
	of this package lives; it can be installed using devtools.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-18 14:13:21 UTC; jq</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-19 10:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='arfima-package'>Simulates, fits, and predicts persistent and anti-persistent time series.
arfima</h2><span id='topic+arfima-package'></span>

<h3>Description</h3>

<p>Simulates with arfima.sim, fits with arfima, and predicts with a method for
the generic function.  Plots predictions and the original time series. Has
the capability to fit regressions with ARFIMA/ARIMA-FGN/ARIMA-PLA errors, as
well as transfer functions/dynamic regression.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;"> Package: </td><td style="text-align: left;"> arfima</td>
</tr>
<tr>
 <td style="text-align: left;"> Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;"> Version: </td><td style="text-align: left;">
1.4-0</td>
</tr>
<tr>
 <td style="text-align: left;"> Date: </td><td style="text-align: left;"> 2017-06-20</td>
</tr>
<tr>
 <td style="text-align: left;"> License: </td><td style="text-align: left;"> MIT </td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>

<p>A list of functions:
</p>
<p><code><a href="#topic+arfima.sim">arfima.sim</a></code> - Simulates an ARFIMA, ARIMA-FGN, or ARIMA-PLA
(three classes of mixed ARIMA hyperbolic decay processes) process, with
possible seasonal components.
</p>
<p><code><a href="#topic+arfima">arfima</a></code> - Fits an ARIMA-HD (default single-start) model to a series,
with options for regression with ARIMA-HD errors and dynamic regression
(transfer functions).  Allows for fixed parameters as well as choices for
the optimizer to be used.
</p>
<p><code><a href="#topic+arfima0">arfima0</a></code> - Simplified version of <code>arfima</code>
</p>
<p><code><a href="#topic+weed">weed</a></code> - Weeds out modes too close to each other in the same
fit.  The modes with the highest log-likelihoods are kept
</p>
<p><code><a href="#topic+print.arfima">print.arfima</a></code> - Prints the relevant output of an <code>arfima</code>
fitted object, such as parameter estimates, standard errors, etc.
</p>
<p><code><a href="#topic+summary.arfima">summary.arfima</a></code> - A much more detailed version of
<code>print.arfima</code>
</p>
<p><code><a href="#topic+coef.arfima">coef.arfima</a></code> - Extracts the coefficients from a <code>arfima</code>
object
</p>
<p><code><a href="#topic+vcov.arfima">vcov.arfima</a></code> - Theoretical and observed covariance matrices of
the coefficients
</p>
<p><code><a href="#topic+residuals.arfima">residuals.arfima</a></code> - Extracts the residuals or regression
residuals from a <code>arfima</code> object
</p>
<p><code><a href="#topic+fitted.arfima">fitted.arfima</a></code> - Extracts the fitted values from a
<code>arfima</code> object
</p>
<p><code><a href="#topic+tacvfARFIMA">tacvfARFIMA</a></code> - Computes the theoretical autocovariance function
of a supplied model.  The model is checked for stationarity and
invertibility.
</p>
<p><code><a href="#topic+iARFIMA">iARFIMA</a></code> - Computes the Fisher information matrix of all
non-FGN components of the given model.  Can be computed (almost) exactly or
through a psi-weights approximation.  The approximation takes more time.
</p>
<p><code><a href="#topic+IdentInvertQ">IdentInvertQ</a></code> - Checks whether the model is identifiable,
stationary, and invertible.  Identifiability is checked through the
information matrix of all non-FGN components, as well as whether both types
of fractional noise are present, both seasonally and non-seasonally.
</p>
<p><code><a href="#topic+lARFIMA">lARFIMA</a></code> and <code><a href="#topic+lARFIMAwTF">lARFIMAwTF</a></code> - Computes the
log-likelihood of a given model with a given series.  The second admits
transfer function data.
</p>
<p><code><a href="#topic+predict.arfima">predict.arfima</a></code> - Predicts from an <code>arfima</code> object.
Capable of exact minimum mean squared error predictions even with integer d
&gt; 0 and/or integer dseas &gt; 0. Does not include transfer function/leading
indicators as of yet.  Returns a <code>predarfima</code> object, which is composed
of: predictions, and standard errors (exact and, if possible, limiting).
</p>
<p><code><a href="#topic+print.predarfima">print.predarfima</a></code> - Prints the relevant output from a
<code>predarfima</code> object: the predictions and their standard deviations.
</p>
<p><code><a href="#topic+plot.predarfima">plot.predarfima</a></code> - Plots a <code>predarfima</code> object.  This
includes the original time series, the forecasts and as default the
standard 95% prediction intervals (exact and, if available, limiting).
</p>
<p><code><a href="#topic+logLik.arfima">logLik.arfima</a></code>, <code><a href="#topic+AIC.arfima">AIC.arfima</a></code>,
<code><a href="#topic+BIC.arfima">BIC.arfima</a></code> - Extracts the requested values from an
<code><a href="#topic+arfima">arfima</a></code> object
</p>
<p><code><a href="#topic+distance">distance</a></code> - Calculates the distances between the modes
</p>
<p><code><a href="#topic+removeMode">removeMode</a></code> - Removes a mode from a fit
</p>
<p><code><a href="#topic+tacvf">tacvf</a></code> - Calculates the theoretical autocovariance functions
(tacvfs) from a fitted <code>arfima</code> object
</p>
<p><code><a href="#topic+plot.tacvf">plot.tacvf</a></code> - Plots the tacvfs
</p>
<p><code><a href="#topic+print.tacvf">print.tacvf</a></code> - Prints the tacvfs
</p>
<p><code><a href="#topic+tacfplot">tacfplot</a></code> - Plots the theoretical autocorrelation functions
(tacfs) of different models on the same data
</p>
<p><code><a href="#topic+SeriesJ">SeriesJ</a></code>, <code><a href="#topic+tmpyr">tmpyr</a></code> - Two datasets included with the
package
</p>


<h3>Author(s)</h3>

<p>JQ (Justin) Veenstra, A. I. McLeod
</p>
<p>Maintainer: JQ (Justin) Veenstra &lt;jqveenstra@gmail.com&gt;
</p>


<h3>References</h3>

<p>Veenstra, J.Q. Persistence and Antipersistence:  Theory and
Software (PhD Thesis)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(8564)
sim &lt;- arfima.sim(1000, model = list(phi = c(0.2, 0.1), dfrac = 0.4, theta = 0.9))
fit &lt;- arfima(sim, order = c(2, 0, 1), back=TRUE)

fit

data(tmpyr)

fit1 &lt;- arfima(tmpyr, order = c(1, 0, 1), numeach = c(3, 3), dmean = FALSE)
fit1

plot(tacvf(fit1), maxlag = 30, tacf = TRUE)

fit2 &lt;- arfima(tmpyr, order = c(1, 0, 0), numeach = c(3, 3), autoweed = FALSE,
dmean = FALSE)

fit2

fit2 &lt;- weed(fit2)

fit2

tacfplot(fits = list(fit1, fit2))

fit3 &lt;- removeMode(fit2, 2)

fit3

coef(fit2)
vcov(fit2)

fit1fgn &lt;- arfima(tmpyr, order = c(1, 0, 1), numeach = c(3, 3),
dmean = FALSE, lmodel = "g")
fit1fgn

fit1hd &lt;- arfima(tmpyr, order = c(1, 0, 1), numeach = c(3, 3),
dmean = FALSE, lmodel = "h")
fit1hd

data(SeriesJ)
attach(SeriesJ)

fitTF &lt;- arfima(YJ, order= c(2, 0, 0), xreg = XJ, reglist =
list(regpar = c(1, 2, 3)), lmodel = "n", dmean = FALSE)
fitTF

detach(SeriesJ)

set.seed(4567)

sim &lt;- arfima.sim(1000, model = list(phi = 0.3, dfrac = 0.4, dint = 1),
sigma2 = 9)

X &lt;- matrix(rnorm(2000), ncol = 2)

simreg &lt;- sim + crossprod(t(X), c(2, 3))

fitreg &lt;- arfima(simreg, order = c(1, 1, 0), xreg = X)

fitreg

plot(sim)

lines(residuals(fitreg, reg = TRUE)[[1]], col = "blue")
##pretty much a perfect match.

</code></pre>

<hr>
<h2 id='AIC.arfima'>Information criteria for <code>arfima</code> objects</h2><span id='topic+AIC.arfima'></span><span id='topic+BIC'></span><span id='topic+BIC.arfima'></span>

<h3>Description</h3>

<p>Computes information criteria for <code>arfima</code> objects.  See
<code><a href="stats.html#topic+AIC">AIC</a></code> for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'arfima'
AIC(object, ..., k = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AIC.arfima_+3A_object">object</code></td>
<td>
<p>An object of class &quot;arfima&quot;.  Note these functions can only be
called on one object at a time because of possible multimodality.</p>
</td></tr>
<tr><td><code id="AIC.arfima_+3A_...">...</code></td>
<td>
<p>Other models fit to data for which to extract the AIC/BIC.  Not
recommended, as an <code>arfima</code> object can be multimodal.</p>
</td></tr>
<tr><td><code id="AIC.arfima_+3A_k">k</code></td>
<td>
<p>The penalty term to be used.  See <code><a href="stats.html#topic+AIC">AIC</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The information criteria for each mode in a vector.
</p>


<h3>Author(s)</h3>

<p>JQ (Justin) Veenstra
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

set.seed(34577)
sim &lt;- arfima.sim(500, model = list(theta = 0.9, phi = 0.5, dfrac = 0.4))
fit1 &lt;- arfima(sim, order = c(1, 0, 1), cpus = 2, back=TRUE)
fit2 &lt;- arfima(sim, order = c(1, 0, 1), cpus = 2, lmodel = "g", back=TRUE)
fit3 &lt;- arfima(sim, order = c(1, 0, 1), cpus = 2, lmodel = "h", back=TRUE)

AIC(fit1)
AIC(fit2)
AIC(fit3)

</code></pre>

<hr>
<h2 id='arfima'>Fit ARFIMA, ARIMA-FGN, and ARIMA-PLA (multi-start) models
Fits ARFIMA/ARIMA-FGN/ARIMA-PLA multi-start models to times series data.
Options include fixing parameters, whether or not to fit fractional noise,
what type of fractional noise (fractional Gaussian noise (FGN), fractionally
differenced white noise (FDWN), or the newly introduced power-law
autocovariance noise (PLA)), etc.  This function can fit regressions with
ARFIMA/ARIMA-FGN/ARIMA-PLA errors via the xreg argument, including dynamic
regression (transfer functions).</h2><span id='topic+arfima'></span>

<h3>Description</h3>

<p>Fits by direct optimization using optim.  The optimizer choices are: 0 -
BFGS; 1 - Nealder-Mead; 2 - SANN; otherwise CG.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arfima(
  z,
  order = c(0, 0, 0),
  numeach = c(1, 1),
  dmean = TRUE,
  whichopt = 0,
  itmean = FALSE,
  fixed = list(phi = NA, theta = NA, frac = NA, seasonal = list(phi = NA, theta = NA,
    frac = NA), reg = NA),
  lmodel = c("d", "g", "h", "n"),
  seasonal = list(order = c(0, 0, 0), period = NA, lmodel = c("d", "g", "h", "n"),
    numeach = c(1, 1)),
  useC = 3,
  cpus = 1,
  rand = FALSE,
  numrand = NULL,
  seed = NA,
  eps3 = 0.01,
  xreg = NULL,
  reglist = list(regpar = NA, minn = -10, maxx = 10, numeach = 1),
  check = F,
  autoweed = TRUE,
  weedeps = 0.01,
  adapt = TRUE,
  weedtype = c("A", "P", "B"),
  weedp = 2,
  quiet = FALSE,
  startfit = NULL,
  back = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arfima_+3A_z">z</code></td>
<td>
<p>The data set (time series)</p>
</td></tr>
<tr><td><code id="arfima_+3A_order">order</code></td>
<td>
<p>The order of the ARIMA model to be fit: c(p, d, q).  We have
that p is the number of AR parameters (phi), d is the amount of integer
differencing, and q is the number of MA parameters (theta).  Note we use the
Box-Jenkins convention for the MA parameters, in that they are the negative
of <code><a href="stats.html#topic+arima">arima</a></code>: see &quot;Details&quot;.</p>
</td></tr>
<tr><td><code id="arfima_+3A_numeach">numeach</code></td>
<td>
<p>The number of starts to fit for each parameter.  The first
argument in the vector is the number of starts for each AR/MA parameter,
while the second is the number of starts for the fractional parameter.  When
this is set to 0, no fractional noise is fit.  Note that the number of
starts in total is multiplicative: if we are fitting an ARFIMA(2, d, 2), and
use the older number of starts (c(2, 2)), we will have 2^2 * 2 * 2^2 = 32
starting values for the fits.  <strong>Note that the default has changed
from c(2, 2) to c(1, 1) since package version 1.4-0</strong></p>
</td></tr>
<tr><td><code id="arfima_+3A_dmean">dmean</code></td>
<td>
<p>Whether the mean should be fit dynamically with the optimizer.
Note that the likelihood surface will change if this is TRUE, but this
is usually not worrisome.
See the referenced thesis for details.</p>
</td></tr>
<tr><td><code id="arfima_+3A_whichopt">whichopt</code></td>
<td>
<p>Which optimizer to use in the optimization: see &quot;Details&quot;.</p>
</td></tr>
<tr><td><code id="arfima_+3A_itmean">itmean</code></td>
<td>
<p>This option is under investigation, and will be set to FALSE
automatically until it has been decided what to do.
</p>
<p>Whether the mean should be fit iteratively using the function
<code><a href="ltsa.html#topic+TrenchMean">TrenchMean</a></code>.  Currently itmean, if set to TRUE, has higher
priority that dmean: if both are TRUE, dmean will be set to FALSE, with a
warning.</p>
</td></tr>
<tr><td><code id="arfima_+3A_fixed">fixed</code></td>
<td>
<p>A list of parameters to be fixed.  If we are to fix certain
elements of the AR process, for example, fixed$phi must have length equal to
p.  Any numeric value will fix the parameter at that value; for example, if
we are modelling an AR(2) process, and we wish to fix only the first
autoregressive parameter to 0, we would have fixed = list(phi = c(0, NA)).
NA corresponds to that parameter being allowed to change in the optimization
process.  We can fix the fractional parameters, and unlike
<code><a href="stats.html#topic+arima">arima</a></code>, can fix the seasonal parameters as well. Currently,
fixing regression/transfer function parameters is disabled.</p>
</td></tr>
<tr><td><code id="arfima_+3A_lmodel">lmodel</code></td>
<td>
<p>The long memory model (noise type) to be used: &quot;d&quot; for FDWN,
&quot;g&quot; for FGN, &quot;h&quot; for PLA, and &quot;n&quot; for none (i.e. ARMA short memory models).
Default is &quot;d&quot;.</p>
</td></tr>
<tr><td><code id="arfima_+3A_seasonal">seasonal</code></td>
<td>
<p>The seasonal components of the model we wish to fit, with
the same components as above.  The period must be supplied.</p>
</td></tr>
<tr><td><code id="arfima_+3A_usec">useC</code></td>
<td>
<p>How much interfaced C code to use: an integer between 0 and 3.
The value 3 is strongly recommended. See &quot;Details&quot;.</p>
</td></tr>
<tr><td><code id="arfima_+3A_cpus">cpus</code></td>
<td>
<p>The number of CPUs used to perform the multi-start fits.  A
small number of fits and a high number of cpus (say both equal 4) with n not
large can actually be slower than when cpus = 1.  The number of CPUs should
not exceed the number of threads available to R.</p>
</td></tr>
<tr><td><code id="arfima_+3A_rand">rand</code></td>
<td>
<p>Whether random starts are used in the multistart method.
Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="arfima_+3A_numrand">numrand</code></td>
<td>
<p>The number of random starts to use.</p>
</td></tr>
<tr><td><code id="arfima_+3A_seed">seed</code></td>
<td>
<p>The seed for the random starts.</p>
</td></tr>
<tr><td><code id="arfima_+3A_eps3">eps3</code></td>
<td>
<p>How far to start from the boundaries when using a grid for the
multi-starts (i.e. when rand is FALSE.)</p>
</td></tr>
<tr><td><code id="arfima_+3A_xreg">xreg</code></td>
<td>
<p>A matrix, data frame, or vector of regressors for regression or
transfer functions.</p>
</td></tr>
<tr><td><code id="arfima_+3A_reglist">reglist</code></td>
<td>
<p>A list with the following elements:
</p>

<ul>
<li><p> regpar -
either NA or a list, matrix, data frame, or vector with 3 columns.  If
regpar is a vector, the matrix xreg must have one row or column only.  In
order, the elements of regpar are: r, s, and b.  The values of r are the the
orders of the delta parameters as in Box, Jenkins and Reinsel, the values of
s are the orders of omega parameters, and the values of b are the
backshifting to be done.
</p>
</li>
<li><p> minn - the minimum value for the starting value of the search, if
reglist$numeach &gt; 1.
</p>
</li>
<li><p> maxx - the maximum value for the starting value
of the search, if reglist$numeach &gt; 1.
</p>
</li>
<li><p> numeach - the number of starts
to try for each regression parameter.
</p>
</li></ul>
</td></tr>
<tr><td><code id="arfima_+3A_check">check</code></td>
<td>
<p>If TRUE, checks at each optim iteration whether the model is
identifiable.  This makes the optimization much slower.</p>
</td></tr>
<tr><td><code id="arfima_+3A_autoweed">autoweed</code></td>
<td>
<p>Whether to automatically (before the fit is returned) weed
out modes found that are found that are close together (usually the same
point.)</p>
</td></tr>
<tr><td><code id="arfima_+3A_weedeps">weedeps</code></td>
<td>
<p>The maximum distance between modes that are close together
for the mode with the lower log-likelihood to be weeded out.  If adapt is
TRUE (default) this value changes.</p>
</td></tr>
<tr><td><code id="arfima_+3A_adapt">adapt</code></td>
<td>
<p>If TRUE, if dim is the dimensionality of the search, weedeps is
changed to <code class="reqn">(1 + weedeps)^{dim} - 1</code>.</p>
</td></tr>
<tr><td><code id="arfima_+3A_weedtype">weedtype</code></td>
<td>
<p>The type of weeding to be done.  See <code><a href="#topic+weed">weed</a></code>.</p>
</td></tr>
<tr><td><code id="arfima_+3A_weedp">weedp</code></td>
<td>
<p>The p in the p-norm to be used in the weeding.  p = 2 (default)
is Euclidean distance.</p>
</td></tr>
<tr><td><code id="arfima_+3A_quiet">quiet</code></td>
<td>
<p>If TRUE, no auxiliary output is generated. The default (FALSE)
has information of fits being proformed.</p>
</td></tr>
<tr><td><code id="arfima_+3A_startfit">startfit</code></td>
<td>
<p>Meant primarily for debugging (for now), allows starting places
for the fitting process.  Overrides <code>numeach</code>.</p>
</td></tr>
<tr><td><code id="arfima_+3A_back">back</code></td>
<td>
<p>Setting this to true will restore the defaults in numeach.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A word of warning: it is generally better to use the default, and only use
Nelder-Mead to check for spurious modes.  SANN takes a long time (and may
only find one mode), and CG may not be stable.
</p>
<p>If using Nelder-Mead, it must be stressed that Nelder-Mead can take out
non-spurious modes or add spurious modes: we have checked visually where we
could.  Therefore it is wise to use BFGS as the default and if there are
modes close to the boundaries, check using Nelder-Mead.
</p>
<p>The moving average parameters are in the Box-Jenkins convention: they are
the negative of the parameters given by <code><a href="stats.html#topic+arima">arima</a></code>.  That is, the
model to be fit is, in the case of a non-seasonal ARIMA model, phi(B)
(1-B)^d z[t] = theta(B) a[t], where phi(B) = 1 - phi(1) B - ... - phi(p) B^p
and theta(B) = 1 - theta(1) B - ... - theta(q) B^q.
</p>
<p>For the useC parameter, a &quot;0&quot; means no C is used; a &quot;1&quot; means C is only used
to compute the log-likelihood, but not the theoretical autocovariance
function (tacvf); a &quot;2&quot; means that C is used to compute the tacvf and not
the log-likelihood; and a &quot;3&quot; means C is used to compute everything.
</p>


<h3>Value</h3>

<p>An object of class &quot;arfima&quot;.  In it, full information on the fit is
given, though not printed under the print.arfima method.  The phis are the
AR parameters, and the thetas are the MA parameters.  Residuals, regression
residuals, etc., are all available, along with the parameter values and
standard errors.  Note that the muHat returned in the arfima object is
of the <strong>differenced</strong> series, if differencing is applied.
</p>
<p>Note that if multiple modes are found, they are listed in order of
log-likelihood value.
</p>


<h3>Author(s)</h3>

<p>JQ (Justin) Veenstra
</p>


<h3>References</h3>

<p>McLeod, A. I., Yu, H. and Krougly, Z. L. (2007) Algorithms for
Linear Time Series Analysis: With R Package Journal of Statistical Software,
Vol. 23, Issue 5
</p>
<p>Veenstra, J.Q. Persistence and Antipersistence:  Theory and
Software (PhD Thesis)
</p>
<p>P. Borwein (1995) An efficient algorithm for Riemann Zeta function Canadian
Math. Soc. Conf. Proc., 27, pp. 29-34.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+arfima.sim">arfima.sim</a></code>, <code><a href="#topic+SeriesJ">SeriesJ</a></code>,
<code><a href="#topic+arfima-package">arfima-package</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

set.seed(8564)
sim &lt;- arfima.sim(1000, model = list(phi = c(0.2, 0.1),
dfrac = 0.4, theta = 0.9))
fit &lt;- arfima(sim, order = c(2, 0, 1), back=TRUE)

fit

data(tmpyr)

fit &lt;- arfima(tmpyr, order = c(1, 0, 1), numeach = c(3, 3))
fit

plot(tacvf(fit), maxlag = 30, tacf = TRUE)

data(SeriesJ)
attach(SeriesJ)

fitTF &lt;- arfima(YJ, order= c(2, 0, 0), xreg = XJ, reglist =
list(regpar = c(2, 2, 3)), lmodel = "n")
fitTF

detach(SeriesJ)


</code></pre>

<hr>
<h2 id='arfima.sim'>Simulate an ARFIMA time series.</h2><span id='topic+arfima.sim'></span>

<h3>Description</h3>

<p>This function simulates an long memory ARIMA time series, with one of
fractionally differenced white noise (FDWN), fractional Gaussian noise
(FGN), power-law autocovariance (PLA) noise, or short memory noise and
possibly seasonal effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arfima.sim(
  n,
  model = list(phi = numeric(0), theta = numeric(0), dint = 0, dfrac = numeric(0), H =
    numeric(0), alpha = numeric(0), seasonal = list(phi = numeric(0), theta = numeric(0),
    dint = 0, period = numeric(0), dfrac = numeric(0), H = numeric(0), alpha =
    numeric(0))),
  useC = 3,
  sigma2 = 1,
  rand.gen = rnorm,
  muHat = 0,
  zinit = NULL,
  innov = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arfima.sim_+3A_n">n</code></td>
<td>
<p>The number of points to be generated.</p>
</td></tr>
<tr><td><code id="arfima.sim_+3A_model">model</code></td>
<td>
<p>The model to be simulated from.  The phi and theta arguments
should be vectors with the values of the AR and MA parameters. Note that
Box-Jenkins notation is used for the MA parameters: see the &quot;Details&quot;
section of <code><a href="#topic+arfima">arfima</a></code>.  The dint argument indicates how much
differencing should be required to make the process stationary.  The dfrac,
H, and alpha arguments are FDWN, FGN and PLA values respectively; note that
only one (or none) of these can have a value, or an error is returned. The
seasonal argument is a list, with the same parameters, and a period, as the
model argument. Note that with a seasonal model, we can have mixing of
FDWN/FGN/HD noise: one in the non-seasonal part, and the other in the
seasonal part.</p>
</td></tr>
<tr><td><code id="arfima.sim_+3A_usec">useC</code></td>
<td>
<p>How much interfaced C code to use: an integer between 0 and 3.
The value 3 is strongly recommended. See the &quot;Details&quot; section of
<code><a href="#topic+arfima">arfima</a></code>.</p>
</td></tr>
<tr><td><code id="arfima.sim_+3A_sigma2">sigma2</code></td>
<td>
<p>The desired variance for the innovations of the series.</p>
</td></tr>
<tr><td><code id="arfima.sim_+3A_rand.gen">rand.gen</code></td>
<td>
<p>The distribution of the innovations.  Any distribution
recognized by <code>R</code> is possible</p>
</td></tr>
<tr><td><code id="arfima.sim_+3A_muhat">muHat</code></td>
<td>
<p>The theoretical mean of the series before integration (if
integer integration is done)</p>
</td></tr>
<tr><td><code id="arfima.sim_+3A_zinit">zinit</code></td>
<td>
<p>Used for prediction; not meant to be used directly.  This
allows a start of a time series to be specified before inverse differencing
(integration) is applied.</p>
</td></tr>
<tr><td><code id="arfima.sim_+3A_innov">innov</code></td>
<td>
<p>Used for prediction; not meant to be used directly.  This
allows for the use of given innovations instead of ones provided by
<code>rand.gen</code>.</p>
</td></tr>
<tr><td><code id="arfima.sim_+3A_...">...</code></td>
<td>
<p>Other parameters passed to the random variate generator;
currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A suitably defined stationary series is generated, and if either of the
dints (non-seasonal or seasonal) are greater than zero, the series is
integrated (inverse-differenced) with zinit equalling a suitable amount of
0s if not supplied.  Then a suitable amount of points are taken out of the
beginning of the series (i.e. dint + period * seasonal dint = the length of
zinit) to obtain a series of length n.  The stationary series is generated
by calculating the theoretical autovariance function and using it, along
with the innovations to generate a series as in McLeod et. al. (2007).
<em>Note:</em> if you would like to fit a function from a fitted arfima model,
the function <code>sim_from_fitted</code> can be used.
</p>


<h3>Value</h3>

<p>A sample from a multivariate normal distribution that has a
covariance structure defined by the autocovariances generated for given
parameters.  The sample acts like a time series with the given parameters.
</p>


<h3>Author(s)</h3>

<p>JQ (Justin) Veenstra
</p>


<h3>References</h3>

<p>McLeod, A. I., Yu, H. and Krougly, Z. L. (2007) Algorithms for
Linear Time Series Analysis: With R Package Journal of Statistical Software,
Vol. 23, Issue 5
</p>
<p>Veenstra, J.Q. Persistence and Antipersistence:  Theory and
Software (PhD Thesis)
</p>
<p>P. Borwein (1995) An efficient algorithm for Riemann Zeta function Canadian
Math. Soc. Conf. Proc., 27, pp. 29-34.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+arfima">arfima</a></code>, <code><a href="#topic+sim_from_fitted">sim_from_fitted</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(6533)
sim &lt;- arfima.sim(1000, model = list(phi = .2, dfrac = .3, dint = 2))

fit &lt;- arfima(sim, order = c(1, 2, 0))
fit

</code></pre>

<hr>
<h2 id='arfima0'>Exact MLE for ARFIMA
The time series is corrected for the sample mean and then exact MLE is used
for the other parameters. This is a simplified version of the arfima()
function that may be useful in simulations and bootstrapping.</h2><span id='topic+arfima0'></span>

<h3>Description</h3>

<p>The sample mean is asymptotically efficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arfima0(z, order = c(0, 0, 0), lmodel = c("FD", "FGN", "PLA", "NONE"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arfima0_+3A_z">z</code></td>
<td>
<p>time series</p>
</td></tr>
<tr><td><code id="arfima0_+3A_order">order</code></td>
<td>
<p>(p,d,q) where p=order AR, d=regular difference, q=order MA</p>
</td></tr>
<tr><td><code id="arfima0_+3A_lmodel">lmodel</code></td>
<td>
<p>type of long-memory component: FD, FGN, PLA or NONE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with components: </p>
<table role = "presentation">
<tr><td><code>bHat</code></td>
<td>
<p>transformed optimal parameters</p>
</td></tr>
<tr><td><code>alphaHat</code></td>
<td>
<p>estimate of alpha</p>
</td></tr> <tr><td><code>HHat</code></td>
<td>
<p>estimate of H</p>
</td></tr>
<tr><td><code>dHat</code></td>
<td>
<p>estimate of d</p>
</td></tr> <tr><td><code>phiHat</code></td>
<td>
<p>estimate of phi</p>
</td></tr>
<tr><td><code>thetaHat</code></td>
<td>
<p>estimate of theta</p>
</td></tr> <tr><td><code>wLL</code></td>
<td>
<p>optimized value of Whittle
approximate log-likelihood</p>
</td></tr> <tr><td><code>LL</code></td>
<td>
<p>corresponding exact log-likelihood</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>convergence indicator</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>JQ (Justin) Veenstra and A. I. McLeod
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
z &lt;- rnorm(100)
arfima0(z, lmodel="FGN")

</code></pre>

<hr>
<h2 id='arfimachanges'>Prints changes to the package since the last update.  Started in 1.4-0</h2><span id='topic+arfimachanges'></span>

<h3>Description</h3>

<p>Prints changes to the package since the last update.  Started in 1.4-0
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arfimachanges()
</code></pre>

<hr>
<h2 id='ARToPacf'>Converts AR/MA coefficients from operator space to the PACF space</h2><span id='topic+ARToPacf'></span>

<h3>Description</h3>

<p>Converts AR/MA coefficients from operator space to the PACF box-space;
usually for internal use
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ARToPacf(phi)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ARToPacf_+3A_phi">phi</code></td>
<td>
<p>The AR/MA coefficients in operator space</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The AR/MA coefficients in the PACF space
</p>


<h3>Author(s)</h3>

<p>A. I. McLeod
</p>


<h3>References</h3>

<p>Barndorff-Nielsen O. E., Schou G. (1973). &quot;On the
parametrization of autoregressive models by partial autocorrelations.&quot;
Journal of Multivariate Analysis, 3, 408-419
</p>
<p>McLeod A. I., Zhang Y (2006).  &quot;Partial autocorrelation parameterization for
subset autore- gression.&quot; Journal of Time Series Analysis, 27(4), 599-612
</p>

<hr>
<h2 id='bestModes'>Finds the best modes of an <code>arfima</code> fit.</h2><span id='topic+bestModes'></span>

<h3>Description</h3>

<p>Finds the best modes of an <code>arfima</code> fit with respect to log-likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bestModes(object, bestn)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bestModes_+3A_object">object</code></td>
<td>
<p>An object of class &quot;arfima&quot;.</p>
</td></tr>
<tr><td><code id="bestModes_+3A_bestn">bestn</code></td>
<td>
<p>The top number of modes to keep with respect to the
log-likelihood.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the easiest way to remove modes with lower log-likelihoods.
</p>


<h3>Value</h3>

<p>The <code>bestn</code> &quot;best&quot; modes.
</p>


<h3>Author(s)</h3>

<p>JQ (Justin) Veenstra
</p>


<h3>See Also</h3>

<p><code><a href="#topic+arfima">arfima</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

set.seed(8765)
sim &lt;- arfima.sim(1000, model = list(phi = 0.4, theta = 0.9, dfrac = 0.4))
fit &lt;- arfima(sim, order = c(1, 0, 1), back=TRUE)
fit
fit &lt;- bestModes(fit, 2)
fit

</code></pre>

<hr>
<h2 id='coef.arfima'>Extract Model Coefficients</h2><span id='topic+coef.arfima'></span>

<h3>Description</h3>

<p>Extracts the coefficients from a <code>arfima</code> fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'arfima'
coef(object, tpacf = FALSE, digits = max(4, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.arfima_+3A_object">object</code></td>
<td>
<p>A fitted <code>arfima</code> object.</p>
</td></tr>
<tr><td><code id="coef.arfima_+3A_tpacf">tpacf</code></td>
<td>
<p>If <code>TRUE</code>, the (ARMA) coefficients are in the transformed
PACF space.</p>
</td></tr>
<tr><td><code id="coef.arfima_+3A_digits">digits</code></td>
<td>
<p>The number of digits to print</p>
</td></tr>
<tr><td><code id="coef.arfima_+3A_...">...</code></td>
<td>
<p>Other optional arguments.  Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of coefficients.  The rows are for the modes, and the
columns are for the model variables.
</p>


<h3>Author(s)</h3>

<p>JQ (Justin) Veenstra
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

set.seed(8564)
sim &lt;- arfima.sim(1000, model = list(phi = c(0.2, 0.1), dfrac = 0.4, theta = 0.9))
fit &lt;- arfima(sim, order = c(2, 0, 1), back=TRUE)

fit
coef(fit)

</code></pre>

<hr>
<h2 id='distance'>The distance between modes of an <code>arfima</code> fit.</h2><span id='topic+distance'></span>

<h3>Description</h3>

<p>The distance between modes of an <code>arfima</code> fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance(ans, p = 2, digits = 4)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distance_+3A_ans">ans</code></td>
<td>
<p>An object of class &quot;arfima&quot;.</p>
</td></tr>
<tr><td><code id="distance_+3A_p">p</code></td>
<td>
<p>The p in the p-norm to be used.</p>
</td></tr>
<tr><td><code id="distance_+3A_digits">digits</code></td>
<td>
<p>The number of digits to print.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two data frames: one with distances in operator space, the
second with distances in the transformed (PACF) space.
</p>


<h3>Author(s)</h3>

<p>JQ (Justin) Veensta
</p>


<h3>References</h3>

<p>Veenstra, J.Q. Persistence and Antipersistence:  Theory and
Software (PhD Thesis)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

set.seed(8564)
sim &lt;- arfima.sim(1000, model = list(phi = c(0.2, 0.1), dfrac = 0.4, theta = 0.9))
fit &lt;- arfima(sim, order = c(2, 0, 1), back=TRUE)

fit

distance(fit)

</code></pre>

<hr>
<h2 id='fitted.arfima'>Extract Model Fitted Values</h2><span id='topic+fitted.arfima'></span>

<h3>Description</h3>

<p>Extract fitted values from an <code>arfima</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'arfima'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitted.arfima_+3A_object">object</code></td>
<td>
<p>A <code>arfima</code> object.</p>
</td></tr>
<tr><td><code id="fitted.arfima_+3A_...">...</code></td>
<td>
<p>Optional parameters.  Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of vectors of fitted values, one for each mode.
</p>


<h3>Author(s)</h3>

<p>JQ (Justin) Veenstra
</p>


<h3>References</h3>

<p>Veenstra, J.Q. Persistence and Antipersistence:  Theory and
Software (PhD Thesis)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+arfima">arfima</a></code>, <code><a href="#topic+resid.arfima">resid.arfima</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

set.seed(8564)
sim &lt;- arfima.sim(1000, model = list(phi = c(0.2, 0.1), dfrac = 0.4, theta = 0.9))
fit &lt;- arfima(sim, order = c(2, 0, 1), back=TRUE)

fit

resid &lt;- resid(fit)
par(mfrow = c(1, 3))
fitted &lt;- fitted(fit)
plot(fitted[[1]], resid[[1]])
plot(fitted[[2]], resid[[2]])
plot(fitted[[3]], resid[[3]])
par(mfrow = c(1, 1))

</code></pre>

<hr>
<h2 id='iARFIMA'>The Fisher information matrix of an ARFIMA process</h2><span id='topic+iARFIMA'></span>

<h3>Description</h3>

<p>Computes the approximate or (almost) exact Fisher information matrix of an
ARFIMA process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iARFIMA(
  phi = numeric(0),
  theta = numeric(0),
  phiseas = numeric(0),
  thetaseas = numeric(0),
  period = 0,
  dfrac = TRUE,
  dfs = FALSE,
  exact = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iARFIMA_+3A_phi">phi</code></td>
<td>
<p>The autoregressive parameters in vector form.</p>
</td></tr>
<tr><td><code id="iARFIMA_+3A_theta">theta</code></td>
<td>
<p>The moving average parameters in vector form.  See Details for
differences from <code><a href="stats.html#topic+arima">arima</a></code>.</p>
</td></tr>
<tr><td><code id="iARFIMA_+3A_phiseas">phiseas</code></td>
<td>
<p>The seasonal autoregressive parameters in vector form.</p>
</td></tr>
<tr><td><code id="iARFIMA_+3A_thetaseas">thetaseas</code></td>
<td>
<p>The seasonal moving average parameters in vector form.  See
Details for differences from <code><a href="stats.html#topic+arima">arima</a></code>.</p>
</td></tr>
<tr><td><code id="iARFIMA_+3A_period">period</code></td>
<td>
<p>The periodicity of the seasonal components.  Must be &gt;= 2.</p>
</td></tr>
<tr><td><code id="iARFIMA_+3A_dfrac">dfrac</code></td>
<td>
<p>TRUE if we include the fractional d parameter, FALSE otherwise</p>
</td></tr>
<tr><td><code id="iARFIMA_+3A_dfs">dfs</code></td>
<td>
<p>TRUE if we include the seasonal fractional d parameter, FALSE
otherwise</p>
</td></tr>
<tr><td><code id="iARFIMA_+3A_exact">exact</code></td>
<td>
<p>If FALSE, calculate the approximate information matrix via
psi-weights.  Otherwise the (almost) exact information matrix will be
calculated.  See &quot;Details&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The matrices are calculated as outlined in Veenstra and McLeod (2012), which
draws on many references.  The psi-weights approximation has a fixed maximum
lag for the weights as 2048 (to be changed to be adaptable.)  The fractional
difference(s) by AR/MA components have a fixed maximum lag of 256, also to
be changed.  Thus the exact matrix has some approximation to it.  Also note
that the approximate method takes much longer than the &quot;exact&quot; one.
</p>
<p>The moving average parameters are in the Box-Jenkins convention: they are
the negative of the parameters given by <code><a href="stats.html#topic+arima">arima</a></code>.
</p>


<h3>Value</h3>

<p>The information matrix of the model.
</p>


<h3>Author(s)</h3>

<p>JQ (Justin) Veenstra
</p>


<h3>References</h3>

<p>Veenstra, J.Q. Persistence and Antipersistence:  Theory and
Software (PhD Thesis)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IdentInvertQ">IdentInvertQ</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tick &lt;- proc.time()
exactI &lt;- iARFIMA(phi = c(.4, -.2), theta = c(.7), phiseas = c(.8, -.4),
	d = TRUE, dfs = TRUE, period = 12)
proc.time() - tick
tick &lt;- proc.time()
approxI &lt;- iARFIMA(phi = c(.4, -.2), theta = c(.7), phiseas = c(.8, -.4), 
	d = TRUE, dfs = TRUE, period = 12, exact = FALSE)
proc.time() - tick
exactI
max(abs(exactI - approxI))

</code></pre>

<hr>
<h2 id='IdentInvertQ'>Checks invertibility, stationarity, and identifiability of a given set of
parameters</h2><span id='topic+IdentInvertQ'></span>

<h3>Description</h3>

<p>Computes whether a given long memory model is invertible, stationary, and
identifiable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IdentInvertQ(
  phi = numeric(0),
  theta = numeric(0),
  phiseas = numeric(0),
  thetaseas = numeric(0),
  dfrac = numeric(0),
  dfs = numeric(0),
  H = numeric(0),
  Hs = numeric(0),
  alpha = numeric(0),
  alphas = numeric(0),
  delta = numeric(0),
  period = 0,
  debug = FALSE,
  ident = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IdentInvertQ_+3A_phi">phi</code></td>
<td>
<p>The autoregressive parameters in vector form.</p>
</td></tr>
<tr><td><code id="IdentInvertQ_+3A_theta">theta</code></td>
<td>
<p>The moving average parameters in vector form.  See Details for
differences from <code><a href="stats.html#topic+arima">arima</a></code>.</p>
</td></tr>
<tr><td><code id="IdentInvertQ_+3A_phiseas">phiseas</code></td>
<td>
<p>The seasonal autoregressive parameters in vector form.</p>
</td></tr>
<tr><td><code id="IdentInvertQ_+3A_thetaseas">thetaseas</code></td>
<td>
<p>The seasonal moving average parameters in vector form.  See
Details for differences from <code><a href="stats.html#topic+arima">arima</a></code>.</p>
</td></tr>
<tr><td><code id="IdentInvertQ_+3A_dfrac">dfrac</code></td>
<td>
<p>The fractional differencing parameter.</p>
</td></tr>
<tr><td><code id="IdentInvertQ_+3A_dfs">dfs</code></td>
<td>
<p>The seasonal fractional differencing parameter.</p>
</td></tr>
<tr><td><code id="IdentInvertQ_+3A_h">H</code></td>
<td>
<p>The Hurst parameter for fractional Gaussian noise (FGN).  Should
not be mixed with <code>dfrac</code> or <code>alpha</code>: see &quot;Details&quot;.</p>
</td></tr>
<tr><td><code id="IdentInvertQ_+3A_hs">Hs</code></td>
<td>
<p>The Hurst parameter for seasonal fractional Gaussian noise (FGN).
Should not be mixed with <code>dfs</code> or <code>alphas</code>: see &quot;Details&quot;.</p>
</td></tr>
<tr><td><code id="IdentInvertQ_+3A_alpha">alpha</code></td>
<td>
<p>The decay parameter for power-law autocovariance (PLA) noise.
Should not be mixed with <code>dfrac</code> or <code>H</code>: see &quot;Details&quot;.</p>
</td></tr>
<tr><td><code id="IdentInvertQ_+3A_alphas">alphas</code></td>
<td>
<p>The decay parameter for seasonal power-law autocovariance
(PLA) noise.  Should not be mixed with <code>dfs</code> or <code>Hs</code>: see
&quot;Details&quot;.</p>
</td></tr>
<tr><td><code id="IdentInvertQ_+3A_delta">delta</code></td>
<td>
<p>The delta parameters for transfer functions.</p>
</td></tr>
<tr><td><code id="IdentInvertQ_+3A_period">period</code></td>
<td>
<p>The periodicity of the seasonal components.  Must be &gt;= 2.</p>
</td></tr>
<tr><td><code id="IdentInvertQ_+3A_debug">debug</code></td>
<td>
<p>When TRUE and model is not stationary/invertible or
identifiable, prints some helpful output.</p>
</td></tr>
<tr><td><code id="IdentInvertQ_+3A_ident">ident</code></td>
<td>
<p>Whether to test for identifiability.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function tests for identifiability via the information matrix of the
ARFIMA process.  Whether the process is stationary or invertible amounts to
checking whether all the variables fall in correct ranges.
</p>
<p>The moving average parameters are in the Box-Jenkins convention: they are
the negative of the parameters given by <code><a href="stats.html#topic+arima">arima</a></code>.
</p>
<p>If <code>dfrac</code>/<code>H</code>/<code>alpha</code> are mixed and/or
<code>dfs</code>/<code>Hs</code>/<code>alphas</code> are mixed, an error will not be thrown,
even though only one of these can drive the process at either level. Note
also that the FGN or PLA have no impact on the identifiability of the model,
as information matrices containing these parameters currently do not have
known closed form.  These two parameters must be within their correct ranges
(0&lt;H&lt;1 for FGN and 0 &lt; alpha &lt; 3 for PLA.)
</p>


<h3>Value</h3>

<p>TRUE if the model is stationary, invertible and identifiable.  FALSE
otherwise.
</p>


<h3>Author(s)</h3>

<p>Justin Veenstra
</p>


<h3>References</h3>

<p>McLeod, A.I. (1999) Necessary and sufficient condition for
nonsingular Fisher information matrix in ARMA and fractional ARMA models The
American Statistician 53, 71-72.
</p>
<p>Veenstra, J. and McLeod, A. I. (2012, Submitted) Improved Algorithms for
Fitting Long Memory Models: With R Package
</p>


<h3>See Also</h3>

<p><code><a href="#topic+iARFIMA">iARFIMA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
IdentInvertQ(phi = 0.3, theta = 0.3)
IdentInvertQ(phi = 1.2)

</code></pre>

<hr>
<h2 id='lARFIMA'>Exact log-likelihood of a long memory model</h2><span id='topic+lARFIMA'></span>

<h3>Description</h3>

<p>Computes the exact log-likelihood of a long memory model with respect to a
given time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lARFIMA(
  z,
  phi = numeric(0),
  theta = numeric(0),
  dfrac = numeric(0),
  phiseas = numeric(0),
  thetaseas = numeric(0),
  dfs = numeric(0),
  H = numeric(0),
  Hs = numeric(0),
  alpha = numeric(0),
  alphas = numeric(0),
  period = 0,
  useC = 3
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lARFIMA_+3A_z">z</code></td>
<td>
<p>A vector or (univariate) time series object, assumed to be (weakly)
stationary.</p>
</td></tr>
<tr><td><code id="lARFIMA_+3A_phi">phi</code></td>
<td>
<p>The autoregressive parameters in vector form.</p>
</td></tr>
<tr><td><code id="lARFIMA_+3A_theta">theta</code></td>
<td>
<p>The moving average parameters in vector form.  See Details for
differences from <code><a href="stats.html#topic+arima">arima</a></code>.</p>
</td></tr>
<tr><td><code id="lARFIMA_+3A_dfrac">dfrac</code></td>
<td>
<p>The fractional differencing parameter.</p>
</td></tr>
<tr><td><code id="lARFIMA_+3A_phiseas">phiseas</code></td>
<td>
<p>The seasonal autoregressive parameters in vector form.</p>
</td></tr>
<tr><td><code id="lARFIMA_+3A_thetaseas">thetaseas</code></td>
<td>
<p>The seasonal moving average parameters in vector form.  See
Details for differences from <code><a href="stats.html#topic+arima">arima</a></code>.</p>
</td></tr>
<tr><td><code id="lARFIMA_+3A_dfs">dfs</code></td>
<td>
<p>The seasonal fractional differencing parameter.</p>
</td></tr>
<tr><td><code id="lARFIMA_+3A_h">H</code></td>
<td>
<p>The Hurst parameter for fractional Gaussian noise (FGN).  Should
not be mixed with <code>dfrac</code> or <code>alpha</code>: see &quot;Details&quot;.</p>
</td></tr>
<tr><td><code id="lARFIMA_+3A_hs">Hs</code></td>
<td>
<p>The Hurst parameter for seasonal fractional Gaussian noise (FGN).
Should not be mixed with <code>dfs</code> or <code>alphas</code>: see &quot;Details&quot;.</p>
</td></tr>
<tr><td><code id="lARFIMA_+3A_alpha">alpha</code></td>
<td>
<p>The decay parameter for power-law autocovariance (PLA) noise.
Should not be mixed with <code>dfrac</code> or <code>H</code>: see &quot;Details&quot;.</p>
</td></tr>
<tr><td><code id="lARFIMA_+3A_alphas">alphas</code></td>
<td>
<p>The decay parameter for seasonal power-law autocovariance
(PLA) noise.  Should not be mixed with <code>dfs</code> or <code>Hs</code>: see
&quot;Details&quot;.</p>
</td></tr>
<tr><td><code id="lARFIMA_+3A_period">period</code></td>
<td>
<p>The periodicity of the seasonal components.  Must be &gt;= 2.</p>
</td></tr>
<tr><td><code id="lARFIMA_+3A_usec">useC</code></td>
<td>
<p>How much interfaced C code to use: an integer between 0 and 3.
The value 3 is strongly recommended. See &quot;Details&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The log-likelihood is computed for the given series z and the parameters.
If two or more of <code>dfrac</code>, <code>H</code> or <code>alpha</code> are present and/or
two or more of <code>dfs</code>, <code>Hs</code> or <code>alphas</code> are present, an error
will be thrown, as otherwise there is redundancy in the model.  Note that
non-seasonal and seasonal components can be of different types: for example,
there can be seasonal FGN with FDWN at the non-seasonal level.
</p>
<p>The moving average parameters are in the Box-Jenkins convention: they are
the negative of the parameters given by <code><a href="stats.html#topic+arima">arima</a></code>.
</p>
<p>For the useC parameter, a &quot;0&quot; means no C is used; a &quot;1&quot; means C is only used
to compute the log-likelihood, but not the theoretical autocovariance
function (tacvf); a &quot;2&quot; means that C is used to compute the tacvf and not
the log-likelihood; and a &quot;3&quot; means C is used to compute everything.
</p>
<p>Note that the time series is assumed to be stationary: this function does
not do any differencing.
</p>


<h3>Value</h3>

<p>The exact log-likelihood of the model given with respect to z, up to
an additive constant.
</p>


<h3>Author(s)</h3>

<p>Justin Veenstra
</p>


<h3>References</h3>

<p>Box, G. E. P., Jenkins, G. M., and Reinsel, G. C. (2008) Time
Series Analysis: Forecasting and Control.  4th Edition. John Wiley and Sons,
Inc., New Jersey.
</p>
<p>Veenstra, J.Q. Persistence and Antipersistence:  Theory and
Software (PhD Thesis)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+arfima">arfima</a></code>
</p>
<p><code><a href="#topic+lARFIMAwTF">lARFIMAwTF</a></code>
</p>
<p><code><a href="#topic+tacvfARFIMA">tacvfARFIMA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(3452)
sim &lt;- arfima.sim(1000, model = list(phi = c(0.3, -0.1)))
lARFIMA(sim, phi = c(0.3, -0.1))

</code></pre>

<hr>
<h2 id='lARFIMAwTF'>Exact log-likelihood of a long memory model with a transfer function model
and series included
Computes the exact log-likelihood of a long memory model with respect to a
given time series as well as a transfer fucntion model and series. This
function is not meant to be used directly.</h2><span id='topic+lARFIMAwTF'></span>

<h3>Description</h3>

<p>Once again, this function should not be used externally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lARFIMAwTF(
  z,
  phi = numeric(0),
  theta = numeric(0),
  dfrac = numeric(0),
  phiseas = numeric(0),
  thetaseas = numeric(0),
  dfs = numeric(0),
  H = numeric(0),
  Hs = numeric(0),
  alpha = numeric(0),
  alphas = numeric(0),
  xr = numeric(0),
  r = numeric(0),
  s = numeric(0),
  b = numeric(0),
  delta = numeric(0),
  omega = numeric(0),
  period = 0,
  useC = 3,
  meanval = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lARFIMAwTF_+3A_z">z</code></td>
<td>
<p>A vector or (univariate) time series object, assumed to be (weakly)
stationary.</p>
</td></tr>
<tr><td><code id="lARFIMAwTF_+3A_phi">phi</code></td>
<td>
<p>The autoregressive parameters in vector form.</p>
</td></tr>
<tr><td><code id="lARFIMAwTF_+3A_theta">theta</code></td>
<td>
<p>The moving average parameters in vector form.  See Details for
differences from <code><a href="stats.html#topic+arima">arima</a></code>.</p>
</td></tr>
<tr><td><code id="lARFIMAwTF_+3A_dfrac">dfrac</code></td>
<td>
<p>The fractional differencing parameter.</p>
</td></tr>
<tr><td><code id="lARFIMAwTF_+3A_phiseas">phiseas</code></td>
<td>
<p>The seasonal autoregressive parameters in vector form.</p>
</td></tr>
<tr><td><code id="lARFIMAwTF_+3A_thetaseas">thetaseas</code></td>
<td>
<p>The seasonal moving average parameters in vector form.  See
Details for differences from <code><a href="stats.html#topic+arima">arima</a></code>.</p>
</td></tr>
<tr><td><code id="lARFIMAwTF_+3A_dfs">dfs</code></td>
<td>
<p>The seasonal fractional differencing parameter.</p>
</td></tr>
<tr><td><code id="lARFIMAwTF_+3A_h">H</code></td>
<td>
<p>The Hurst parameter for fractional Gaussian noise (FGN).  Should
not be mixed with <code>dfrac</code> or <code>alpha</code>: see &quot;Details&quot;.</p>
</td></tr>
<tr><td><code id="lARFIMAwTF_+3A_hs">Hs</code></td>
<td>
<p>The Hurst parameter for seasonal fractional Gaussian noise (FGN).
Should not be mixed with <code>dfs</code> or <code>alphas</code>: see &quot;Details&quot;.</p>
</td></tr>
<tr><td><code id="lARFIMAwTF_+3A_alpha">alpha</code></td>
<td>
<p>The decay parameter for power-law autocovariance (PLA) noise.
Should not be mixed with <code>dfrac</code> or <code>H</code>: see &quot;Details&quot;.</p>
</td></tr>
<tr><td><code id="lARFIMAwTF_+3A_alphas">alphas</code></td>
<td>
<p>The decay parameter for seasonal power-law autocovariance
(PLA) noise.  Should not be mixed with <code>dfs</code> or <code>Hs</code>: see
&quot;Details&quot;.</p>
</td></tr>
<tr><td><code id="lARFIMAwTF_+3A_xr">xr</code></td>
<td>
<p>The regressors in vector form</p>
</td></tr>
<tr><td><code id="lARFIMAwTF_+3A_r">r</code></td>
<td>
<p>The order of the delta(s)</p>
</td></tr>
<tr><td><code id="lARFIMAwTF_+3A_s">s</code></td>
<td>
<p>The order of the omegas(s)</p>
</td></tr>
<tr><td><code id="lARFIMAwTF_+3A_b">b</code></td>
<td>
<p>The backshifting to be done</p>
</td></tr>
<tr><td><code id="lARFIMAwTF_+3A_delta">delta</code></td>
<td>
<p>Transfer function parameters as in Box, Jenkins, and Reinsel.
Corresponds to the &quot;autoregressive&quot; part of the dynamic regression.</p>
</td></tr>
<tr><td><code id="lARFIMAwTF_+3A_omega">omega</code></td>
<td>
<p>Transfer function parameters as in Box, Jenkins, and Reinsel.
Corresponds to the &quot;moving average&quot; part of the dynamic regression: note
that omega_0 is not restricted to 1.  See &quot;Details&quot; for issues.</p>
</td></tr>
<tr><td><code id="lARFIMAwTF_+3A_period">period</code></td>
<td>
<p>The periodicity of the seasonal components.  Must be &gt;= 2.</p>
</td></tr>
<tr><td><code id="lARFIMAwTF_+3A_usec">useC</code></td>
<td>
<p>How much interfaced C code to use: an integer between 0 and 3.
The value 3 is strongly recommended. See &quot;Details&quot;.</p>
</td></tr>
<tr><td><code id="lARFIMAwTF_+3A_meanval">meanval</code></td>
<td>
<p>If the mean is to be estimated dynamically, the mean.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A log-likelihood value
</p>


<h3>Author(s)</h3>

<p>Justin Veenstra
</p>


<h3>References</h3>

<p>Veenstra, J.Q. Persistence and Antipersistence:  Theory and
Software (PhD Thesis)
</p>

<hr>
<h2 id='logLik.arfima'>Extract Log-Likelihood Values</h2><span id='topic+logLik.arfima'></span>

<h3>Description</h3>

<p>Extracts log-likelihood values from a <code>arfima</code> fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'arfima'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLik.arfima_+3A_object">object</code></td>
<td>
<p>A fitted <code>arfima</code> object</p>
</td></tr>
<tr><td><code id="logLik.arfima_+3A_...">...</code></td>
<td>
<p>Optional arguments not currently used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses the function <code>DLLoglikelihood</code> from the package
<code><a href="ltsa.html#topic+ltsa">ltsa</a></code>.  The log-likelihoods returned are exact up to an
additive constant.
</p>


<h3>Value</h3>

<p>A vector of log-likelihoods, one for each mode, is returned, along
with the degrees of freedom.
</p>


<h3>Author(s)</h3>

<p>JQ (Justin) Veenstra
</p>


<h3>References</h3>

<p>Veenstra, J.Q. Persistence and Antipersistence:  Theory and
Software (PhD Thesis)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AIC.arfima">AIC.arfima</a></code>
</p>

<hr>
<h2 id='PacfToAR'>Converts AR/MA coefficients from the PACF space to operator space</h2><span id='topic+PacfToAR'></span>

<h3>Description</h3>

<p>Converts AR/MA coefficients from PACF box-space to operator space; usually
for internal use
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PacfToAR(pi)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PacfToAR_+3A_pi">pi</code></td>
<td>
<p>The AR/MA coefficients in PACF box-space</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The AR/MA coefficients in operator space.
</p>


<h3>Author(s)</h3>

<p>A. I. McLeod
</p>


<h3>References</h3>

<p>Barndorff-Nielsen O. E., Schou G. (1973). &quot;On the
parametrization of autoregressive models by partial autocorrelations.&quot;
Journal of Multivariate Analysis, 3, 408-419
</p>
<p>McLeod A. I. , Zhang Y (2006).  &quot;Partial autocorrelation parameterization
for subset autore- gression.&quot; Journal of Time Series Analysis, 27(4),
599-612
</p>

<hr>
<h2 id='plot.predarfima'>Plots the original time series, the predictions, and the prediction
intervals for a <code>predarfima</code> object.</h2><span id='topic+plot.predarfima'></span>

<h3>Description</h3>

<p>This function takes a <code>predarfima</code> object generated by
<code>predict.arfima</code> and plots all of the information contained in it.  The
colour code is as follows:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'predarfima'
plot(
  x,
  xlab = NULL,
  ylab = NULL,
  main = NULL,
  ylim = NULL,
  numback = 5,
  xlim = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.predarfima_+3A_x">x</code></td>
<td>
<p>A <code>predarfima</code> object</p>
</td></tr>
<tr><td><code id="plot.predarfima_+3A_xlab">xlab</code></td>
<td>
<p>Optional</p>
</td></tr>
<tr><td><code id="plot.predarfima_+3A_ylab">ylab</code></td>
<td>
<p>Optional</p>
</td></tr>
<tr><td><code id="plot.predarfima_+3A_main">main</code></td>
<td>
<p>Optional</p>
</td></tr>
<tr><td><code id="plot.predarfima_+3A_ylim">ylim</code></td>
<td>
<p>Optional</p>
</td></tr>
<tr><td><code id="plot.predarfima_+3A_numback">numback</code></td>
<td>
<p>The number of last values of the original series to plot
defined by the user. The default is five</p>
</td></tr>
<tr><td><code id="plot.predarfima_+3A_xlim">xlim</code></td>
<td>
<p>Optional</p>
</td></tr>
<tr><td><code id="plot.predarfima_+3A_...">...</code></td>
<td>
<p>Currently not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>grey: exact prediction
red: exact prediction intervals (PIs)
orange: limiting PIs
</p>
<p>See <code><a href="#topic+predict.arfima">predict.arfima</a></code>.
</p>


<h3>Value</h3>

<p>None. Generates a plot
</p>


<h3>Author(s)</h3>

<p>JQ (Justin) Veenstra
</p>


<h3>References</h3>

<p>Veenstra, J.Q. Persistence and Antipersistence:  Theory and
Software (PhD Thesis)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.arfima">predict.arfima</a></code>, <code><a href="#topic+print.predarfima">print.predarfima</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(82365)
sim &lt;- arfima.sim(1000, model = list(dfrac = 0.4, theta=0.9, dint = 1))
fit &lt;- arfima(sim, order = c(0, 1, 1), back=TRUE)
fit
pred &lt;- predict(fit, n.ahead = 5)
pred
plot(pred)
#Let's look at more context
plot(pred, numback = 50)

</code></pre>

<hr>
<h2 id='plot.tacvf'>Plots the output from a call to <code>tacvf</code></h2><span id='topic+plot.tacvf'></span>

<h3>Description</h3>

<p>Plots the theoretical autocovariance functions of the modes for a fitted
<code>arfima</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tacvf'
plot(
  x,
  type = "o",
  pch = 20,
  xlab = NULL,
  ylab = NULL,
  main = NULL,
  xlim = NULL,
  ylim = NULL,
  tacf = FALSE,
  maxlag = NULL,
  lag0 = !tacf,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.tacvf_+3A_x">x</code></td>
<td>
<p>A <code>tacvf</code> object from a call to said function</p>
</td></tr>
<tr><td><code id="plot.tacvf_+3A_type">type</code></td>
<td>
<p>See <code><a href="base.html#topic+plot">plot</a></code>. The default is recommended for short
<code>maxlag</code></p>
</td></tr>
<tr><td><code id="plot.tacvf_+3A_pch">pch</code></td>
<td>
<p>See <code><a href="base.html#topic+plot">plot</a></code></p>
</td></tr>
<tr><td><code id="plot.tacvf_+3A_xlab">xlab</code></td>
<td>
<p>See <code><a href="base.html#topic+plot">plot</a></code></p>
</td></tr>
<tr><td><code id="plot.tacvf_+3A_ylab">ylab</code></td>
<td>
<p>See <code><a href="base.html#topic+plot">plot</a></code></p>
</td></tr>
<tr><td><code id="plot.tacvf_+3A_main">main</code></td>
<td>
<p>See <code><a href="base.html#topic+plot">plot</a></code></p>
</td></tr>
<tr><td><code id="plot.tacvf_+3A_xlim">xlim</code></td>
<td>
<p>See <code><a href="base.html#topic+plot">plot</a></code></p>
</td></tr>
<tr><td><code id="plot.tacvf_+3A_ylim">ylim</code></td>
<td>
<p>See <code><a href="base.html#topic+plot">plot</a></code></p>
</td></tr>
<tr><td><code id="plot.tacvf_+3A_tacf">tacf</code></td>
<td>
<p>If <code>TRUE</code>, plots the theoretical autocorellations instead</p>
</td></tr>
<tr><td><code id="plot.tacvf_+3A_maxlag">maxlag</code></td>
<td>
<p>The maximum lag for the plot</p>
</td></tr>
<tr><td><code id="plot.tacvf_+3A_lag0">lag0</code></td>
<td>
<p>Whether or not to plot lag 0 of the tacvfs/tacfs.  Default
<code>!tacf</code>. Used by <code><a href="#topic+tacfplot">tacfplot</a></code>.</p>
</td></tr>
<tr><td><code id="plot.tacvf_+3A_...">...</code></td>
<td>
<p>Currently not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only plots up to nine tacvfs. It is highly recommended that the
<code>arfima</code> object be weeded before calling <code>tacvf</code>
</p>


<h3>Value</h3>

<p>None. There is a plot as output.
</p>


<h3>Author(s)</h3>

<p>JQ (Justin) Veenstra
</p>


<h3>References</h3>

<p>Veenstra, J.Q. Persistence and Antipersistence:  Theory and
Software (PhD Thesis)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tacvf">tacvf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1234)
sim &lt;- arfima.sim(1000, model = list(theta = 0.99, dfrac = 0.49))
fit &lt;- arfima(sim, order = c(0, 0, 1))
plot(tacvf(fit))
plot(tacvf(fit), tacf = TRUE)

</code></pre>

<hr>
<h2 id='predict.arfima'>Predicts from a fitted object.</h2><span id='topic+predict.arfima'></span>

<h3>Description</h3>

<p>Performs prediction of a fitted <code>arfima</code> object. Includes prediction
for each mode and exact and limiting prediction error standard deviations.
<strong>NOTE:  the standard errors in beta are currently not taken into
account in the prediction intervals shown.  This will be updated as soon
as possible.</strong>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'arfima'
predict(
  object,
  n.ahead = 1,
  prop.use = "default",
  newxreg = NULL,
  predint = 0.95,
  exact = c("default", T, F),
  setmuhat0 = FALSE,
  cpus = 1,
  trend = NULL,
  n.use = NULL,
  xreg = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.arfima_+3A_object">object</code></td>
<td>
<p>A fitted <code>arfima</code> object</p>
</td></tr>
<tr><td><code id="predict.arfima_+3A_n.ahead">n.ahead</code></td>
<td>
<p>The number of steps ahead to predict</p>
</td></tr>
<tr><td><code id="predict.arfima_+3A_prop.use">prop.use</code></td>
<td>
<p>The proportion (between 0 and 1) or percentage (between
&gt;1 and 100) of data points to use for prediction.  Defaults to the string
&quot;default&quot;, which sets the number of data points <code>n.use</code> to the minimum
of the series length and 1000.  Overriden by <code>n.use</code>.</p>
</td></tr>
<tr><td><code id="predict.arfima_+3A_newxreg">newxreg</code></td>
<td>
<p>If a regression fit, the new regressors</p>
</td></tr>
<tr><td><code id="predict.arfima_+3A_predint">predint</code></td>
<td>
<p>The percentile to use for prediction intervals assuming normal
deviations.</p>
</td></tr>
<tr><td><code id="predict.arfima_+3A_exact">exact</code></td>
<td>
<p>Controls whether exact (based on the theoretical autocovariance
matrix) prediction variances are calculated (which is recommended), as well
as whether the exact prediction formula is used when the process is
differenced (which can take a fair amount of time if the length of the series
used to predict is large).  Defaults to the string &quot;default&quot;, which is
<code>TRUE</code> for the first and <code>FALSE</code> for the second.  A Boolean value
(<code>TRUE</code> or <code>FALSE</code>) will set both to this value.</p>
</td></tr>
<tr><td><code id="predict.arfima_+3A_setmuhat0">setmuhat0</code></td>
<td>
<p>Experimental. Sets muhat equal to zero</p>
</td></tr>
<tr><td><code id="predict.arfima_+3A_cpus">cpus</code></td>
<td>
<p>The number of CPUs to use for prediction. Currently not
implemented</p>
</td></tr>
<tr><td><code id="predict.arfima_+3A_trend">trend</code></td>
<td>
<p>An optional vector the length of <code>n.ahead</code> or longer to
add to the predictions</p>
</td></tr>
<tr><td><code id="predict.arfima_+3A_n.use">n.use</code></td>
<td>
<p>Directly set the number mentioned in <code>prop.use</code>.</p>
</td></tr>
<tr><td><code id="predict.arfima_+3A_xreg">xreg</code></td>
<td>
<p>Alias for newxreg</p>
</td></tr>
<tr><td><code id="predict.arfima_+3A_...">...</code></td>
<td>
<p>Optional arguments. Currently not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of lists, ceiling(prop.use * n)one for each mode with relavent details about the
prediction
</p>


<h3>Author(s)</h3>

<p>JQ (Justin) Veenstra
</p>


<h3>References</h3>

<p>Veenstra, J.Q. Persistence and Antipersistence:  Theory and
Software (PhD Thesis)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+arfima">arfima</a></code>, <code><a href="#topic+plot.predarfima">plot.predarfima</a></code>,
<code><a href="#topic+print.predarfima">print.predarfima</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

set.seed(82365)
sim &lt;- arfima.sim(1000, model = list(dfrac = 0.4, theta=0.9, dint = 1))
fit &lt;- arfima(sim, order = c(0, 1, 1), back=TRUE)
fit
pred &lt;- predict(fit, n.ahead = 5)
pred
plot(pred, numback=50)
#Predictions aren't really different due to the
#series.  Let's see what happens when we regress!

set.seed(23524)
#Forecast 5 ahead as before
#Note that we need to integrate the regressors, since time series regression
#usually assumes that regressors are of the same order as the series.
n.fore &lt;- 5
X &lt;- matrix(rnorm(3000+3*n.fore), ncol = 3)
X &lt;- apply(X, 2, cumsum)
Xnew &lt;- X[1001:1005,]
X &lt;- X[1:1000,]
beta &lt;- matrix(c(2, -.4, 6), ncol = 1)
simX &lt;- sim + as.vector(X%*%beta)
fitX &lt;- arfima(simX, order = c(0, 1, 1), xreg = X, back=TRUE)
fitX
#Let's compare predictions.
predX &lt;- predict(fitX, n.ahead = n.fore, xreg = Xnew)
predX
plot(predX, numback = 50)
#With the mode we know is really there, it looks better.
fitX &lt;- removeMode(fitX, 2)
predXnew &lt;- predict(fitX, n.ahead = n.fore, xreg = Xnew)
predXnew
plot(predXnew, numback=50)


</code></pre>

<hr>
<h2 id='print.arfima'>Prints a Fitted Object</h2><span id='topic+print.arfima'></span>

<h3>Description</h3>

<p>Prints a fitted <code>arfima</code> object's relevant details
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'arfima'
print(x, digits = max(6, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.arfima_+3A_x">x</code></td>
<td>
<p>A fitted <code>arfima</code> object</p>
</td></tr>
<tr><td><code id="print.arfima_+3A_digits">digits</code></td>
<td>
<p>The number of digits to print</p>
</td></tr>
<tr><td><code id="print.arfima_+3A_...">...</code></td>
<td>
<p>Optional arguments.  See <code><a href="base.html#topic+print">print</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The object is returned invisibly
</p>


<h3>Author(s)</h3>

<p>JQ (Justin) Veenstra
</p>


<h3>References</h3>

<p>Veenstra, J.Q. Persistence and Antipersistence:  Theory and
Software (PhD Thesis)
</p>

<hr>
<h2 id='print.predarfima'>Prints predictions and prediction intervals</h2><span id='topic+print.predarfima'></span>

<h3>Description</h3>

<p>Prints the output of <code>predict</code> on an <code>arfima</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'predarfima'
print(x, digits = max(6, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.predarfima_+3A_x">x</code></td>
<td>
<p>An object of class &quot;predarfima&quot;</p>
</td></tr>
<tr><td><code id="print.predarfima_+3A_digits">digits</code></td>
<td>
<p>The number of digits to print</p>
</td></tr>
<tr><td><code id="print.predarfima_+3A_...">...</code></td>
<td>
<p>Currently not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints all the relavent output of the prediction function of the
<code>arfima</code> package
</p>


<h3>Value</h3>

<p><code>x</code> is returned invisibly
</p>


<h3>Author(s)</h3>

<p>JQ (Justin) Veenstra
</p>


<h3>See Also</h3>

<p><code><a href="#topic+arfima">arfima</a></code>, <code><a href="#topic+predict.arfima">predict.arfima</a></code>,
<code><a href="stats.html#topic+predict">predict</a></code>, <code><a href="#topic+plot.predarfima">plot.predarfima</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(82365)
sim &lt;- arfima.sim(1000, model = list(dfrac = 0.4, theta=0.9, dint = 1))
fit &lt;- arfima(sim, order = c(0, 1, 1), back=TRUE)
fit
pred &lt;- predict(fit, n.ahead = 5)
pred
plot(pred)

</code></pre>

<hr>
<h2 id='print.summary.arfima'>Prints the output of a call to <code>summary</code> on an <code>arfima</code> object</h2><span id='topic+print.summary.arfima'></span>

<h3>Description</h3>

<p>Prints the output of a call to <code>summary</code> on an <code>arfima</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.arfima'
print(
  x,
  digits = max(6, getOption("digits") - 3),
  signif.stars = getOption("show.signif.stars"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.summary.arfima_+3A_x">x</code></td>
<td>
<p>A <code>summary.arfima</code> object</p>
</td></tr>
<tr><td><code id="print.summary.arfima_+3A_digits">digits</code></td>
<td>
<p>The number of digits to print</p>
</td></tr>
<tr><td><code id="print.summary.arfima_+3A_signif.stars">signif.stars</code></td>
<td>
<p>Whether to print stars on significant output</p>
</td></tr>
<tr><td><code id="print.summary.arfima_+3A_...">...</code></td>
<td>
<p>Currently not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the object <code>x</code> invisibly
</p>


<h3>Author(s)</h3>

<p>JQ (Justin) Veenstra
</p>


<h3>References</h3>

<p>Veenstra, J.Q. Persistence and Antipersistence:  Theory and
Software (PhD Thesis)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+arfima">arfima</a></code>, <code><a href="#topic+print.arfima">print.arfima</a></code>,
<code><a href="#topic+summary.arfima">summary.arfima</a></code>, <code><a href="base.html#topic+print">print</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(54678)
sim &lt;- arfima.sim(1000, model = list(phi = 0.9, H = 0.3))
fit &lt;- arfima(sim, order = c(1, 0, 0), lmodel = "g", back=TRUE)
summary(fit)

</code></pre>

<hr>
<h2 id='print.tacvf'>Prints a tacvf object.</h2><span id='topic+print.tacvf'></span>

<h3>Description</h3>

<p>Prints the output of a call to <code>tacvf</code> on an <code>arfima</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tacvf'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.tacvf_+3A_x">x</code></td>
<td>
<p>The <code>tacvf</code> object.</p>
</td></tr>
<tr><td><code id="print.tacvf_+3A_...">...</code></td>
<td>
<p>Optional arguments.  See <code><a href="base.html#topic+print">print</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The object is returned invisibly
</p>


<h3>Author(s)</h3>

<p>JQ (Justin) Veenstra
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tacvf">tacvf</a></code>, <code><a href="#topic+plot.tacvf">plot.tacvf</a></code>
</p>

<hr>
<h2 id='removeMode'>Removes a mode from an <code>arfima</code> fit.</h2><span id='topic+removeMode'></span>

<h3>Description</h3>

<p>This function is useful if one suspects a mode is spurious and does not want
to call the weed function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>removeMode(object, num)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="removeMode_+3A_object">object</code></td>
<td>
<p>An object of class &quot;arfima&quot;.</p>
</td></tr>
<tr><td><code id="removeMode_+3A_num">num</code></td>
<td>
<p>The number of the mode as in the printed value of the object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The original object with the mode removed.
</p>


<h3>Author(s)</h3>

<p>JQ (Justin) Veenstra
</p>


<h3>See Also</h3>

<p><code><a href="#topic+arfima">arfima</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(8765)
sim &lt;- arfima.sim(1000, model = list(phi = 0.4, theta = 0.9, dfrac = 0.4))
fit &lt;- arfima(sim, order = c(1, 0, 1), back=TRUE)
fit
fit &lt;- removeMode(fit, 3)
fit

</code></pre>

<hr>
<h2 id='residuals.arfima'>Extract the Residuals of a Fitted Object</h2><span id='topic+residuals.arfima'></span><span id='topic+resid.arfima'></span>

<h3>Description</h3>

<p>Extracts the residuals or regression residuals from a fitted <code>arfima</code>
object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'arfima'
residuals(object, reg = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuals.arfima_+3A_object">object</code></td>
<td>
<p>A fitted <code>arfima</code> object</p>
</td></tr>
<tr><td><code id="residuals.arfima_+3A_reg">reg</code></td>
<td>
<p>Whether to extract the regression residuals instead.  If
<code>TRUE</code>, throws an error if no regression was done.</p>
</td></tr>
<tr><td><code id="residuals.arfima_+3A_...">...</code></td>
<td>
<p>Optional parameters.  Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of vectors of residuals, one for each mode.
</p>


<h3>Author(s)</h3>

<p>JQ (Justin) Veenstra
</p>


<h3>References</h3>

<p>Veenstra, J.Q. Persistence and Antipersistence:  Theory and
Software (PhD Thesis)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+arfima">arfima</a></code>, <code><a href="#topic+fitted.arfima">fitted.arfima</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

set.seed(8564)
sim &lt;- arfima.sim(1000, model = list(phi = c(0.2, 0.1), dfrac = 0.4, theta = 0.9))
fit &lt;- arfima(sim, order = c(2, 0, 1), back=TRUE)

fit

resid &lt;- resid(fit)
par(mfrow = c(1, 3))
plot(resid[[1]])
plot(resid[[2]])
plot(resid[[3]])
fitted &lt;- fitted(fit)
plot(fitted[[1]], resid[[1]])
plot(fitted[[2]], resid[[2]])
plot(fitted[[3]], resid[[3]])
par(mfrow = c(1, 1))


</code></pre>

<hr>
<h2 id='SeriesJ'>Series J, Gas Furnace Data</h2><span id='topic+SeriesJ'></span>

<h3>Description</h3>

<p>Gas furnace data, sampling interval 9 seconds; observations for 296 pairs of
data points.
</p>


<h3>Format</h3>

<p>List with ts objects XJ and YJ.
</p>


<h3>Details</h3>

<p>XJ is input gas rate in cubic feet per minute, YJ is percentage carbon
dioxide (CO2) in outlet gas.  X is the regressor.
</p>
<p>Box, Jenkins, and Reinsel (2008) fit an AR(2) to YJ, with transfer function
specifications r = 2, s = 2, and b = 3, regressing on XJ.  Our package
agrees with their results.
</p>


<h3>Source</h3>

<p>Box, Jenkins and Reinsel(2008).  Time Series Analysis: Forecasting
and Control.
</p>


<h3>References</h3>

<p>Box, G. E. P., Jenkins, G. M., and Reinsel, G. C. (2008) Time
Series Analysis: Forecasting and Control.  4th Edition. John Wiley and Sons,
Inc., New Jersey.
</p>
<p>Veenstra, J. and McLeod, A. I. (Working Paper). The arfima R package: Exact
Methods for Hyperbolic Decay Time Series
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(SeriesJ)
attach(SeriesJ)

fitTF &lt;- arfima(YJ, order= c(2, 0, 0), xreg = XJ, reglist =
list(regpar = c(2, 2, 3)), lmodel = "n")
fitTF ## agrees fairly closely with Box et. al.


detach(SeriesJ)

</code></pre>

<hr>
<h2 id='sim_from_fitted'>Simulate an ARFIMA time series from a fitted arfima object.</h2><span id='topic+sim_from_fitted'></span>

<h3>Description</h3>

<p>This function simulates an long memory ARIMA time series, with one of
fractionally differenced white noise (FDWN), fractional Gaussian noise
(FGN), power-law autocovariance (PLA) noise, or short memory noise and
possibly seasonal effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_from_fitted(n, model, X = NULL, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_from_fitted_+3A_n">n</code></td>
<td>
<p>The number of points to be generated.</p>
</td></tr>
<tr><td><code id="sim_from_fitted_+3A_model">model</code></td>
<td>
<p>The model to be simulated from.  The phi and theta arguments
should be vectors with the values of the AR and MA parameters. Note that
Box-Jenkins notation is used for the MA parameters: see the &quot;Details&quot;
section of <code><a href="#topic+arfima">arfima</a></code>.</p>
</td></tr>
<tr><td><code id="sim_from_fitted_+3A_x">X</code></td>
<td>
<p>The xreg matrix to add to the series, <em>required</em> if there is an xreg
argument in <code>model</code>.  An error will be thrown if there is a mismatch
between this argument and whether <code>model</code> was called with a external
regressor</p>
</td></tr>
<tr><td><code id="sim_from_fitted_+3A_seed">seed</code></td>
<td>
<p>An optional seed that will be set before the simulation.  If 
<code>model</code> is multimodal, a seed will be chosen randomly if not provided, 
and all modes will simulate a time series with said seed set.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A suitably defined stationary series is generated, and if either of the
dints (non-seasonal or seasonal) are greater than zero, the series is
integrated (inverse-differenced) with zinit equalling a suitable amount of
0s if not supplied.  Then a suitable amount of points are taken out of the
beginning of the series (i.e. dint + period * seasonal dint = the length of
zinit) to obtain a series of length n.  The stationary series is generated
by calculating the theoretical autovariance function and using it, along
with the innovations to generate a series as in McLeod et. al. (2007).
<em>Note:</em> if you would like to fit from parameters, use the funtion,
<code>arfima.sim</code>.
</p>


<h3>Value</h3>

<p>A sample (or list of samples) from a multivariate normal distribution that has a
covariance structure defined by the autocovariances generated for given
parameters.  The sample acts like a time series with the given parameters.
The returned value will be a list if the fit is multimodal.
</p>


<h3>Author(s)</h3>

<p>JQ (Justin) Veenstra
</p>


<h3>References</h3>

<p>McLeod, A. I., Yu, H. and Krougly, Z. L. (2007) Algorithms for
Linear Time Series Analysis: With R Package Journal of Statistical Software,
Vol. 23, Issue 5
</p>
<p>Veenstra, J.Q. Persistence and Antipersistence:  Theory and
Software (PhD Thesis)
</p>
<p>P. Borwein (1995) An efficient algorithm for Riemann Zeta function Canadian
Math. Soc. Conf. Proc., 27, pp. 29-34.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+arfima">arfima</a></code>, <code><a href="#topic+arfima.sim">arfima.sim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

set.seed(6533)
sim &lt;- arfima.sim(1000, model = list(phi = .2, dfrac = .3, dint = 2))

fit &lt;- arfima(sim, order = c(1, 2, 0))
fit

sim2 &lt;- sim_from_fitted(100, fit)

fit2 &lt;- arfima(sim2, order = c(1, 2, 0))
fit2

set.seed(2266)
#Fairly pathological series to fit for this package
series = arfima.sim(500, model=list(phi = 0.98, dfrac = 0.46))

X = matrix(rnorm(1000), ncol = 2)
colnames(X) &lt;- c('c1', 'c2')
series_added &lt;- series + X%*%c(2, 5)

fit &lt;- arfima(series, order = c(1, 0, 0), numeach = c(2, 2))
fit_X &lt;- arfima(series_added, order=c(1, 0, 0), xreg=X, numeach = c(2, 2))

from_series &lt;- sim_from_fitted(1000, fit)
 
fit1a &lt;- arfima(from_series[[1]], order = c(1, 0, 0), numeach = c(2, 2))
fit1a
fit1 &lt;- arfima(from_series[[1]], order = c(1, 0, 0))
fit1
fit2 &lt;- arfima(from_series[[1]], order = c(1, 0, 0))
fit2
fit3 &lt;- arfima(from_series[[1]], order = c(1, 0, 0))
fit3
fit4 &lt;- arfima(from_series[[1]], order = c(1, 0, 0))
fit4

Xnew = matrix(rnorm(2000), ncol = 2)
from_series_X &lt;- sim_from_fitted(1000, fit_X, X=Xnew)

fit_X1a &lt;- arfima(from_series_X[[1]], order=c(1, 0, 0), xreg=Xnew, numeach = c(2, 2))
fit_X1a
fit_X1 &lt;- arfima(from_series_X[[1]], order=c(1, 0, 0), xreg=Xnew)
fit_X1
fit_X2 &lt;- arfima(from_series_X[[2]], order=c(1, 0, 0), xreg=Xnew)
fit_X2
fit_X3 &lt;- arfima(from_series_X[[3]], order=c(1, 0, 0), xreg=Xnew)
fit_X3
fit_X4 &lt;- arfima(from_series_X[[4]], order=c(1, 0, 0), xreg=Xnew)
fit_X4


</code></pre>

<hr>
<h2 id='summary.arfima'>Extensive Summary of an Object</h2><span id='topic+summary.arfima'></span>

<h3>Description</h3>

<p>Provides a very comprehensive summary of a fitted <code>arfima</code> object.
Includes correlation and covariance matrices (observed and expected), the
Fisher Information matrix of those parameters for which it is defined, and
more, for each mode.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'arfima'
summary(object, digits = max(4, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.arfima_+3A_object">object</code></td>
<td>
<p>A fitted <code>arfima</code> object</p>
</td></tr>
<tr><td><code id="summary.arfima_+3A_digits">digits</code></td>
<td>
<p>The number of digits to print</p>
</td></tr>
<tr><td><code id="summary.arfima_+3A_...">...</code></td>
<td>
<p>Optional arguments, currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of lists (one for each mode) of all relevant information
about the fit that can be passed to <code>print.summary.arfima</code>.
</p>


<h3>Author(s)</h3>

<p>JQ (Justin) Veenstra
</p>


<h3>References</h3>

<p>Veenstra, J.Q. Persistence and Antipersistence:  Theory and
Software (PhD Thesis)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+arfima">arfima</a></code>, <code><a href="#topic+iARFIMA">iARFIMA</a></code>,
<code><a href="#topic+vcov.arfima">vcov.arfima</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(tmpyr)

fit &lt;- arfima(tmpyr, order = c(1, 0, 1), back=TRUE)
fit

summary(fit)

</code></pre>

<hr>
<h2 id='tacfplot'>Plots the theoretical autocorralation functions (tacfs) of one or more fits.</h2><span id='topic+tacfplot'></span>

<h3>Description</h3>

<p>Plots the theoretical autocorralation functions (tacfs) of one or more fits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tacfplot(
  fits = list(),
  modes = "all",
  xlab = NULL,
  ylab = NULL,
  main = NULL,
  xlim = NULL,
  ylim = NULL,
  maxlag = 20,
  lag0 = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tacfplot_+3A_fits">fits</code></td>
<td>
<p>A list of objects of class &quot;arfima&quot;.</p>
</td></tr>
<tr><td><code id="tacfplot_+3A_modes">modes</code></td>
<td>
<p>Either &quot;all&quot; or a vector of the same length as fits for which
the tacfs will be ploted.</p>
</td></tr>
<tr><td><code id="tacfplot_+3A_xlab">xlab</code></td>
<td>
<p>Optional.  Usually better to be generated by the function.</p>
</td></tr>
<tr><td><code id="tacfplot_+3A_ylab">ylab</code></td>
<td>
<p>Optional.  Usually better to be generated by the function.</p>
</td></tr>
<tr><td><code id="tacfplot_+3A_main">main</code></td>
<td>
<p>Optional.  Usually better to be generated by the function.</p>
</td></tr>
<tr><td><code id="tacfplot_+3A_xlim">xlim</code></td>
<td>
<p>Optional.  Usually better to be generated by the function.</p>
</td></tr>
<tr><td><code id="tacfplot_+3A_ylim">ylim</code></td>
<td>
<p>Optional.  Usually better to be generated by the function.</p>
</td></tr>
<tr><td><code id="tacfplot_+3A_maxlag">maxlag</code></td>
<td>
<p>Optional. Used to limit the length of tacfs.  Highly
recommended to be a value from 20 - 50.</p>
</td></tr>
<tr><td><code id="tacfplot_+3A_lag0">lag0</code></td>
<td>
<p>Whether or not the lag 0 tacf should be printed.  Since this is
always 1 for all tacfs, recommended to be <code>TRUE</code>.  It is easier to see
the shape of the tacfs.</p>
</td></tr>
<tr><td><code id="tacfplot_+3A_...">...</code></td>
<td>
<p>Optional. Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL. However, there is a plot output.
</p>


<h3>Author(s)</h3>

<p>JQ (Justin) Veenstra
</p>


<h3>References</h3>

<p>Veenstra, J.Q. Persistence and Antipersistence:  Theory and
Software (PhD Thesis)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tacvf">tacvf</a></code>, <code><a href="#topic+plot.tacvf">plot.tacvf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(34577)
sim &lt;- arfima.sim(500, model = list(theta = 0.9, phi = 0.5, dfrac = 0.4))
fit1 &lt;- arfima(sim, order = c(1, 0, 1), cpus = 2, back=TRUE)
fit2 &lt;- arfima(sim, order = c(1, 0, 1), cpus = 2, lmodel = "g", back=TRUE)
fit3 &lt;- arfima(sim, order = c(1, 0, 1), cpus = 2, lmodel = "h", back=TRUE)
fit1
fit2
fit3
tacfplot(fits = list(fit1, fit2, fit3), maxlag = 30)

</code></pre>

<hr>
<h2 id='tacvf'>Extracts the tacvfs of a fitted object</h2><span id='topic+tacvf'></span>

<h3>Description</h3>

<p>Extracts the theoretical autocovariance functions (tacvfs) from a fitted
<code>arfima</code> or one of its modes (an <code>ARFIMA</code>) object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tacvf(obj, xmaxlag = 0, forPred = FALSE, n.ahead = 0, nuse = -1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tacvf_+3A_obj">obj</code></td>
<td>
<p>An object of class &quot;arfima&quot; or &quot;ARFIMA&quot;.  The latter class is a
mode of the former.</p>
</td></tr>
<tr><td><code id="tacvf_+3A_xmaxlag">xmaxlag</code></td>
<td>
<p>The number of extra points to be added on to the end.  That
is, if the original series has length 300, and xmaxlag = 5, the tacvfs will
go from lag 0 to lag 304.</p>
</td></tr>
<tr><td><code id="tacvf_+3A_forpred">forPred</code></td>
<td>
<p>Should only be <code>TRUE</code> from a call to
<code>predict.arfima</code>.</p>
</td></tr>
<tr><td><code id="tacvf_+3A_n.ahead">n.ahead</code></td>
<td>
<p>Only used internally.</p>
</td></tr>
<tr><td><code id="tacvf_+3A_nuse">nuse</code></td>
<td>
<p>Only used internally.</p>
</td></tr>
<tr><td><code id="tacvf_+3A_...">...</code></td>
<td>
<p>Optional arguments, currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of tacvfs, one for each mode, the length of the time series.
</p>


<h3>Author(s)</h3>

<p>JQ (Justin) Veenstra
</p>


<h3>References</h3>

<p>Veenstra, J.Q. Persistence and Antipersistence:  Theory and
Software (PhD Thesis)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.tacvf">plot.tacvf</a></code>, <code><a href="#topic+print.tacvf">print.tacvf</a></code>,
<code><a href="#topic+tacfplot">tacfplot</a></code>, <code><a href="#topic+arfima">arfima</a></code>
</p>

<hr>
<h2 id='tacvfARFIMA'>The theoretical autocovariance function of a long memory process.</h2><span id='topic+tacvfARFIMA'></span>

<h3>Description</h3>

<p>Calculates the tacvf of a mixed long memory-ARMA (with posible seasonal
components).  Combines long memory and ARMA (and non-seasonal and seasonal)
parts via convolution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tacvfARFIMA(
  phi = numeric(0),
  theta = numeric(0),
  dfrac = numeric(0),
  phiseas = numeric(0),
  thetaseas = numeric(0),
  dfs = numeric(0),
  H = numeric(0),
  Hs = numeric(0),
  alpha = numeric(0),
  alphas = numeric(0),
  period = 0,
  maxlag,
  useCt = T,
  sigma2 = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tacvfARFIMA_+3A_phi">phi</code></td>
<td>
<p>The autoregressive parameters in vector form.</p>
</td></tr>
<tr><td><code id="tacvfARFIMA_+3A_theta">theta</code></td>
<td>
<p>The moving average parameters in vector form.  See Details for
differences from <code><a href="stats.html#topic+arima">arima</a></code>.</p>
</td></tr>
<tr><td><code id="tacvfARFIMA_+3A_dfrac">dfrac</code></td>
<td>
<p>The fractional differencing parameter.</p>
</td></tr>
<tr><td><code id="tacvfARFIMA_+3A_phiseas">phiseas</code></td>
<td>
<p>The seasonal autoregressive parameters in vector form.</p>
</td></tr>
<tr><td><code id="tacvfARFIMA_+3A_thetaseas">thetaseas</code></td>
<td>
<p>The seasonal moving average parameters in vector form.  See
Details for differences from <code><a href="stats.html#topic+arima">arima</a></code>.</p>
</td></tr>
<tr><td><code id="tacvfARFIMA_+3A_dfs">dfs</code></td>
<td>
<p>The seasonal fractional differencing parameter.</p>
</td></tr>
<tr><td><code id="tacvfARFIMA_+3A_h">H</code></td>
<td>
<p>The Hurst parameter for fractional Gaussian noise (FGN).  Should
not be mixed with <code>dfrac</code> or <code>alpha</code>: see &quot;Details&quot;.</p>
</td></tr>
<tr><td><code id="tacvfARFIMA_+3A_hs">Hs</code></td>
<td>
<p>The Hurst parameter for seasonal fractional Gaussian noise (FGN).
Should not be mixed with <code>dfs</code> or <code>alphas</code>: see &quot;Details&quot;.</p>
</td></tr>
<tr><td><code id="tacvfARFIMA_+3A_alpha">alpha</code></td>
<td>
<p>The decay parameter for power-law autocovariance (PLA) noise.
Should not be mixed with <code>dfrac</code> or <code>H</code>: see &quot;Details&quot;.</p>
</td></tr>
<tr><td><code id="tacvfARFIMA_+3A_alphas">alphas</code></td>
<td>
<p>The decay parameter for seasonal power-law autocovariance
(PLA) noise.  Should not be mixed with <code>dfs</code> or <code>Hs</code>: see
&quot;Details&quot;.</p>
</td></tr>
<tr><td><code id="tacvfARFIMA_+3A_period">period</code></td>
<td>
<p>The periodicity of the seasonal components.  Must be &gt;= 2.</p>
</td></tr>
<tr><td><code id="tacvfARFIMA_+3A_maxlag">maxlag</code></td>
<td>
<p>The number of terms to compute: technically the output
sequence is from lags 0 to maxlag, so there are maxlag + 1 terms.</p>
</td></tr>
<tr><td><code id="tacvfARFIMA_+3A_usect">useCt</code></td>
<td>
<p>Whether or not to use C to compute the (parts of the) tacvf.</p>
</td></tr>
<tr><td><code id="tacvfARFIMA_+3A_sigma2">sigma2</code></td>
<td>
<p>Used in <code><a href="#topic+arfima.sim">arfima.sim</a></code>: determines the value of the
innovation variance.  The tacvf sequence is multiplied by this value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The log-likelihood is computed for the given series z and the parameters.
If two or more of <code>dfrac</code>, <code>H</code> or <code>alpha</code> are present and/or
two or more of <code>dfs</code>, <code>Hs</code> or <code>alphas</code> are present, an error
will be thrown, as otherwise there is redundancy in the model.  Note that
non-seasonal and seasonal components can be of different types: for example,
there can be seasonal FGN with FDWN at the non-seasonal level.
</p>
<p>The moving average parameters are in the Box-Jenkins convention: they are
the negative of the parameters given by <code><a href="stats.html#topic+arima">arima</a></code>.
</p>


<h3>Value</h3>

<p>A sequence of length maxlag + 1 (lags 0 to maxlag) of the tacvf of
the given process.
</p>


<h3>Author(s)</h3>

<p>JQ (Justin) Veenstra and A. I. McLeod
</p>


<h3>References</h3>

<p>Veenstra, J.Q. Persistence and Antipersistence:  Theory and
Software (PhD Thesis)
</p>
<p>P. Borwein (1995) An efficient algorithm for Riemann Zeta function Canadian
Math. Soc. Conf. Proc., 27, pp. 29-34.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
t1 &lt;- tacvfARFIMA(phi = c(0.2, 0.1), theta = 0.4, dfrac = 0.3, maxlag = 30)
t2 &lt;- tacvfARFIMA(phi = c(0.2, 0.1), theta = 0.4, H = 0.8, maxlag = 30)
t3 &lt;- tacvfARFIMA(phi = c(0.2, 0.1), theta = 0.4, alpha = 0.4, maxlag = 30)
plot(t1, type = "o", col = "blue", pch = 20)
lines(t2, type = "o", col = "red", pch = 20)
lines(t3, type = "o", col = "purple", pch = 20)  #they decay at about the same rate


</code></pre>

<hr>
<h2 id='tmpyr'>Temperature Data</h2><span id='topic+tmpyr'></span>

<h3>Description</h3>

<p>Central England mean yearly temperatures from 1659 to 1976
</p>


<h3>Format</h3>

<p>A ts tmpyr
</p>


<h3>Details</h3>

<p>Hosking notes that while the ARFIMA(1, d, 1) has a lower AIC, it is not much
lower than the AIC of the ARFIMA(1, d, 0).
</p>
<p>Bhansali and Kobozka find: muHat = 9.14, d = 0.28, phi = -0.77, and theta =
-0.66 for the ARFIMA(1, d, 1), which is close to our result, although our
result reveals trimodality if <code>numeach</code> is large enough.  The third
mode is close to Hosking's fit of an ARMA(1, 1) to these data, while the
second is very antipersistent.
</p>
<p>Our package gives a very close result to Hosking for the ARFIMA(1, d, 0)
case, although there is also a second mode.  Given how close it is to the
boundary, it may or may not be spurious.  A check with <code>dmean = FALSE</code>
shows that it is not the optimized mean giving a spurious mode.
</p>
<p>If, however, we use <code>whichopt = 1</code>, we only have one mode.  Note that
Nelder-Mead sometimes does take out non-spurious modes, or add spurious
modes to the surface.
</p>


<h3>Source</h3>

<p><a href="https://hadleyserver.metoffice.gov.uk/hadobs/hadcet/">https://hadleyserver.metoffice.gov.uk/hadobs/hadcet/</a>
</p>


<h3>References</h3>

<p>Parker, D.E., Legg, T.P., and Folland, C.K. (1992).  A new daily
Central England Temperature Series, 1772-1991. Int. J. Clim., Vol 12, pp
317-342
</p>
<p>Manley,G. (1974).  Central England Temperatures: monthly means 1659 to 1973.
Q.J.R. Meteorol. Soc., Vol 100, pp 389-405.
</p>
<p>Hosking, J. R. M. (1984). Modeling persistence in hydrological time series
using fractional differencing, Water Resour. Res., 20(12)
</p>
<p>Bhansali, R. J. and Koboszka, P. S. (2003) Prediction of Long-Memory Time
Series In Doukhan, P., Oppenheim, G. and Taqqu, M. S. (Eds) Theory and
Applications of Long-Range Dependence (pp355-368) Birkhauser Boston Inc.
</p>
<p>Veenstra, J.Q. Persistence and Antipersistence:  Theory and
Software (PhD Thesis)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(tmpyr)

fit &lt;- arfima(tmpyr, order = c(1, 0, 1), numeach = c(3, 3), dmean = TRUE, back=TRUE)
fit
##suspect that fourth mode may be spurious, even though not close to a boundary
##may be an induced mode from the optimization of the mean

fit &lt;- arfima(tmpyr, order = c(1, 0, 1), numeach = c(3, 3), dmean = FALSE, back=TRUE)
fit

##perhaps so


plot(tacvf(fit), maxlag = 30, tacf = TRUE)

fit1 &lt;- arfima(tmpyr, order = c(1, 0, 0), dmean = TRUE, back=TRUE)
fit1

fit2 &lt;- arfima(tmpyr, order = c(1, 0, 0), dmean = FALSE, back=TRUE)
fit2  ##still bimodal.  Second mode may or may not be spurious.

fit3 &lt;- arfima(tmpyr, order = c(1, 0, 0), dmean = FALSE, whichopt = 1, numeach = c(3, 3))
fit3  ##Unimodal.  So the second mode was likely spurious.

plot(tacvf(fit2), maxlag = 30, tacf = TRUE)
##maybe not spurious.  Hard to tell without visualizing the surface.

##compare to plotted tacf of fit1:  looks alike
plot(tacvf(fit1), maxlag = 30, tacf = TRUE)

tacfplot(list(fit1, fit2))

</code></pre>

<hr>
<h2 id='vcov.arfima'>Extracts the Variance-Covariance Matrix</h2><span id='topic+vcov.arfima'></span>

<h3>Description</h3>

<p>Extracts the variance-covariance matrices (one or two for each mode) from a
fitted <code>arfima</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'arfima'
vcov(
  object,
  type = c("b", "o", "e"),
  cor = FALSE,
  digits = max(4, getOption("digits") - 3),
  tapprox = FALSE,
  summ = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcov.arfima_+3A_object">object</code></td>
<td>
<p>A fitted <code>arfima</code> object</p>
</td></tr>
<tr><td><code id="vcov.arfima_+3A_type">type</code></td>
<td>
<p>Which type of covariance matrix to return: &quot;o&quot; is the observed
matrix (from solving the Hessian), &quot;e&quot; is the expected matrix (from solving
the information matrix), and &quot;b&quot; is both.</p>
</td></tr>
<tr><td><code id="vcov.arfima_+3A_cor">cor</code></td>
<td>
<p>Whether or not the correlation matrix should be returned instead.</p>
</td></tr>
<tr><td><code id="vcov.arfima_+3A_digits">digits</code></td>
<td>
<p>The number of digits to print.</p>
</td></tr>
<tr><td><code id="vcov.arfima_+3A_tapprox">tapprox</code></td>
<td>
<p>Whether or not to use an approximation to find the expected
matrix.  Highly recommended to be FALSE, as it takes much longer, and is an
approximation.</p>
</td></tr>
<tr><td><code id="vcov.arfima_+3A_summ">summ</code></td>
<td>
<p>Whether the call is from the <code>summary.arfima</code> function.
Should not be used except internally.</p>
</td></tr>
<tr><td><code id="vcov.arfima_+3A_...">...</code></td>
<td>
<p>Optional arguments, currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of lists (one for each mode) with components <code>observed</code>
and/or <code>expected</code>.
</p>


<h3>Author(s)</h3>

<p>JQ (Justin) Veenstra
</p>


<h3>References</h3>

<p>Veenstra, J.Q. Persistence and Antipersistence:  Theory and
Software (PhD Thesis)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.arfima">summary.arfima</a></code>, <code><a href="#topic+arfima">arfima</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1234)
sim &lt;- arfima.sim(1000, model = list(dfrac = 0.4, phi = .8, theta = -0.5))
fit1 &lt;- arfima(sim, order = c(1, 0, 1), back=TRUE)
fit2 &lt;- arfima(sim, order = c(1, 0, 1), lmodel = "g", back=TRUE)
fit3 &lt;- arfima(sim, order = c(1, 0, 1), lmodel = "h", back=TRUE)
fit1
fit2
fit3
vcov(fit1)
vcov(fit2)
vcov(fit2)

</code></pre>

<hr>
<h2 id='weed'>Weeds out fits from a call to arfima that are too close to each other.</h2><span id='topic+weed'></span>

<h3>Description</h3>

<p>Weeds out fits from a call to arfima that are too close to each other.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weed(
  ans,
  type = c("A", "P", "B", "N"),
  walls = FALSE,
  eps2 = 0.025,
  eps3 = 0.01,
  adapt = TRUE,
  pn = 2
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weed_+3A_ans">ans</code></td>
<td>
<p>The result from a call to arfima.</p>
</td></tr>
<tr><td><code id="weed_+3A_type">type</code></td>
<td>
<p>The space to perform the weeding in. &quot;A&quot; is for operating
parameters. &quot;P&quot; is in the PACF space. &quot;B&quot; performs weeding in both. &quot;N&quot;
performs no weeding and is only used internally.</p>
</td></tr>
<tr><td><code id="weed_+3A_walls">walls</code></td>
<td>
<p>If more than one mode is on a wall in the PACF space, all modes
but the one with the highest log-likelihood on the same wall are deleted.</p>
</td></tr>
<tr><td><code id="weed_+3A_eps2">eps2</code></td>
<td>
<p>The maximum distance between modes that are close together for
the mode with the lower log-likelihood to be weeded out.  If adapt is TRUE
(default) this value changes.</p>
</td></tr>
<tr><td><code id="weed_+3A_eps3">eps3</code></td>
<td>
<p>The minimum distance from a wall for a secondary mode to be
weeded out, if walls are TRUE.</p>
</td></tr>
<tr><td><code id="weed_+3A_adapt">adapt</code></td>
<td>
<p>If TRUE, if dim is the dimensionality of the search, eps2 is
changed to <code class="reqn">(1 + eps2)^{dim} - 1</code>.</p>
</td></tr>
<tr><td><code id="weed_+3A_pn">pn</code></td>
<td>
<p>The p in the p-norm to be used in the weeding.  p = 2 (default) is
Euclidean distance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;arfima&quot; with modes possibly weeded out.
</p>


<h3>Author(s)</h3>

<p>JQ (Justin) Veenstra
</p>


<h3>See Also</h3>

<p><code><a href="#topic+arfima">arfima</a></code>, <code><a href="#topic+distance">distance</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

set.seed(1234)
sim &lt;- arfima.sim(1000, model = list(theta = 0.9, dfrac = 0.4))
fit &lt;- arfima(sim, order = c(0, 0, 1), autoweed = FALSE, back=TRUE)
fit
distance(fit)
fit1 &lt;- weed(fit)
fit1
distance(fit1)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
