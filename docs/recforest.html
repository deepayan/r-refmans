<!DOCTYPE html><html lang="en"><head><title>Help for package recforest</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {recforest}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#recforest-package'><p>recforest: Random Survival Forest for Recurrent Events</p></a></li>
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#bladder1_recforest'><p>bladder1_recforest : Bladder Cancer Recurrences</p></a></li>
<li><a href='#is_supported_variable'><p>Check if a Variable is Supported</p></a></li>
<li><a href='#make_decision'><p>Make a Decision Based on Input</p></a></li>
<li><a href='#plot.recforest'><p>Plot method for recforest objects</p></a></li>
<li><a href='#predict.recforest'><p>Predict using a recforest model</p></a></li>
<li><a href='#print.recforest'><p>Print method for recforest objects</p></a></li>
<li><a href='#summary.recforest'><p>Summary Method for recforest Objects</p></a></li>
<li><a href='#train_forest'><p>Train a Recforest Model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Random Survival Forest for Recurrent Events</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Analyze recurrent events with right-censored data and the potential presence of a terminal event (that prevents further occurrences, like death). 'recofest' extends the random survival forest algorithm, adapting splitting rules and node estimators to handle complexities of recurrent events. The methodology is fully described in Murris, J., Bouaziz, O., Jakubczak, M., Katsahian, S., &amp; Lavenu, A. (2024) (<a href="https://hal.science/hal-04612431v1/document">https://hal.science/hal-04612431v1/document</a>).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License (&ge; 2)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>frailtypack, knitr, rmarkdown, testthat (&ge; 3.0.0), withr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, dplyr, future, future.apply, magrittr, methods, mets,
purrr, reda, stats, survival, tibble, timereg</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-12-03 10:30:40 UTC; colinfay</td>
</tr>
<tr>
<td>Author:</td>
<td>Juliette Murris <a href="https://orcid.org/0000-0002-7017-9865"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Guillaume Desachy <a href="https://orcid.org/0000-0002-2000-1436"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Colin Fay <a href="https://orcid.org/0000-0001-7343-1846"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Yohann Mansiaux <a href="https://orcid.org/0000-0002-8905-6603"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Audrey Lavenu <a href="https://orcid.org/0000-0002-0049-2397"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Sandrine Katsahian
    <a href="https://orcid.org/0000-0002-7261-0671"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Juliette Murris &lt;murris.juliette@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-12-05 18:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='recforest-package'>recforest: Random Survival Forest for Recurrent Events</h2><span id='topic+recforest'></span><span id='topic+recforest-package'></span>

<h3>Description</h3>

<p>Analyze recurrent events with right-censored data and the potential presence of a terminal event (that prevents further occurrences, like death). 'recofest' extends the random survival forest algorithm, adapting splitting rules and node estimators to handle complexities of recurrent events. The methodology is fully described in Murris, J., Bouaziz, O., Jakubczak, M., Katsahian, S., &amp; Lavenu, A. (2024) (<a href="https://hal.science/hal-04612431v1/document">https://hal.science/hal-04612431v1/document</a>).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Juliette Murris <a href="mailto:murris.juliette@gmail.com">murris.juliette@gmail.com</a> (<a href="https://orcid.org/0000-0002-7017-9865">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Guillaume Desachy <a href="mailto:guillaume.desachy@pierre-fabre.com">guillaume.desachy@pierre-fabre.com</a> (<a href="https://orcid.org/0000-0002-2000-1436">ORCID</a>)
</p>
</li>
<li><p> Colin Fay <a href="mailto:colin@thinkr.fr">colin@thinkr.fr</a> (<a href="https://orcid.org/0000-0001-7343-1846">ORCID</a>)
</p>
</li>
<li><p> Yohann Mansiaux <a href="mailto:yohann@thinkr.fr">yohann@thinkr.fr</a> (<a href="https://orcid.org/0000-0002-8905-6603">ORCID</a>)
</p>
</li>
<li><p> Audrey Lavenu <a href="mailto:audrey.lavenu@univ-rennes.fr">audrey.lavenu@univ-rennes.fr</a> (<a href="https://orcid.org/0000-0002-0049-2397">ORCID</a>)
</p>
</li>
<li><p> Sandrine Katsahian <a href="mailto:sandrine.katsahian@aphp.fr">sandrine.katsahian@aphp.fr</a> (<a href="https://orcid.org/0000-0002-7261-0671">ORCID</a>)
</p>
</li></ul>


<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling <code>rhs(lhs)</code>.
</p>

<hr>
<h2 id='bladder1_recforest'>bladder1_recforest : Bladder Cancer Recurrences</h2><span id='topic+bladder1_recforest'></span>

<h3>Description</h3>

<p>Preparation of the survival::bladder1 dataset for the recforest package. Please run <code>?survival::bladder1</code> for more information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bladder1_recforest
</code></pre>


<h3>Format</h3>

<p>A data frame with 294 rows (118 individuals) and 8 variables:
</p>

<dl>
<dt> id </dt><dd><p>  Patient id </p>
</dd>
<dt> t.start </dt><dd><p>  Start time </p>
</dd>
<dt> t.stop </dt><dd><p>  Stop time </p>
</dd>
<dt> treatment </dt><dd><p>  Placebo, pyridoxine (vitamin B6), or thiotepa </p>
</dd>
<dt> number </dt><dd><p>  Initial number of tumors (8=8 or more) </p>
</dd>
<dt> size </dt><dd><p>  Size (cm) of largest initial tumor </p>
</dd>
<dt> death </dt><dd><p>  Death event </p>
</dd>
<dt> event </dt><dd><p>  Recurrence event </p>
</dd>
</dl>



<h3>Source</h3>

<p>Script to generate the data can be explored using <code>browseURL(system.file("generate_bladder1_recforest.R", package = "recforest"))</code>
</p>

<hr>
<h2 id='is_supported_variable'>Check if a Variable is Supported</h2><span id='topic+is_supported_variable'></span>

<h3>Description</h3>

<p>This function is a generic method that checks if a given variable is supported.
The actual implementation of the check is provided by specific methods for different classes of variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_supported_variable(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_supported_variable_+3A_x">x</code></td>
<td>
<p>The variable to be checked.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value indicating whether the variable is supported.
</p>

<hr>
<h2 id='make_decision'>Make a Decision Based on Input</h2><span id='topic+make_decision'></span>

<h3>Description</h3>

<p>This function serves as a generic method for making decisions based on the input <code>x</code> and <code>value</code>.
It dispatches to the appropriate method depending on the class of <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_decision(x, value)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_decision_+3A_x">x</code></td>
<td>
<p>An object for which a decision needs to be made.</p>
</td></tr>
<tr><td><code id="make_decision_+3A_value">value</code></td>
<td>
<p>A value that influences the decision-making process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of the decision-making process, which depends on the specific method implementation.
</p>

<hr>
<h2 id='plot.recforest'>Plot method for recforest objects</h2><span id='topic+plot.recforest'></span>

<h3>Description</h3>

<p>Plot method for recforest objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'recforest'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.recforest_+3A_x">x</code></td>
<td>
<p>An object of class <code>recforest</code>.</p>
</td></tr>
<tr><td><code id="plot.recforest_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the plot function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, used for side effect.
</p>

<hr>
<h2 id='predict.recforest'>Predict using a recforest model</h2><span id='topic+predict.recforest'></span>

<h3>Description</h3>

<p>This function generates predictions from a recforest model given a set of input features.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'recforest'
predict(
  object,
  newdata,
  id_var,
  covariates,
  time_vars = c("t.start", "t.stop"),
  death_var = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.recforest_+3A_object">object</code></td>
<td>
<p>A recforest model object.</p>
</td></tr>
<tr><td><code id="predict.recforest_+3A_newdata">newdata</code></td>
<td>
<p>A data frame containing the input features.</p>
</td></tr>
<tr><td><code id="predict.recforest_+3A_id_var">id_var</code></td>
<td>
<p>The name of the column containing the unique identifier for each subject.</p>
</td></tr>
<tr><td><code id="predict.recforest_+3A_covariates">covariates</code></td>
<td>
<p>A character vector containing the names of the columns to be used as predictors in the model.</p>
</td></tr>
<tr><td><code id="predict.recforest_+3A_time_vars">time_vars</code></td>
<td>
<p>A length-2 character vector containing the names of the columns representing the start and stop times (default &quot;t.start&quot; and &quot;t.stop&quot;).</p>
</td></tr>
<tr><td><code id="predict.recforest_+3A_death_var">death_var</code></td>
<td>
<p>The name of the column containing the death indicator or other any terminal event (optional).</p>
</td></tr>
<tr><td><code id="predict.recforest_+3A_...">...</code></td>
<td>
<p>Optional parameters to be passed to the low level function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>predict_recforest</code> function utilizes the ensemble of trees in the recforest model to generate predictions for new data. For each observation in <code>newdata</code>, the function aggregates the predictions from all trees in the recforest to provide a robust estimate.
</p>
<p>Depending on the <code>method</code> specified during the initial training of the recforest model, the algorithm employs different prediction strategies:
</p>

<ul>
<li><p> For standard recurrent event data, the function outputs the Nelson-Aalen estimates of the mean cumulative function.
</p>
</li>
<li><p> In the presence of terminal events, the function outputs the Ghosh-Lin estimates of the mean cumulative function.
</p>
</li></ul>

<p>The predictions represent the expected mean number of recurrent events for each individual at the end of the follow-up period.
</p>


<h3>Value</h3>

<p>A vector of expected mean cumulative number of recurrent events per individual at the end of follow-up.
</p>


<h3>References</h3>

<p>Cook, R. J., &amp; Lawless, J. F. (1997). Marginal analysis of recurrent events and a terminating event. Statistics in medicine, 16(8), 911-924.
</p>
<p>Ghosh, D., &amp; Lin, D. Y. (2002). Marginal regression models for recurrent and terminal events. Statistica Sinica, 663-688.
</p>
<p>Ishwaran, H., Kogalur, U. B., Blackstone, E. H., &amp; Lauer, M. S. (2008). Random survival forests.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("bladder1_recforest")
trained_forest &lt;- train_forest(
  data = bladder1_recforest,
  id_var = "id",
  covariates = c("treatment", "number", "size"),
  time_vars = c("t.start", "t.stop"),
  death_var = "death",
  event = "event",
  n_trees = 2,
  n_bootstrap = 70,
  mtry = 2,
  minsplit = 3,
  nodesize = 15,
  method = "NAa",
  min_score = 5,
  max_nodes = 20,
  seed = 111,
  parallel = FALSE,
  verbose = FALSE
)
predictions &lt;- predict(
 trained_forest,
 newdata = bladder1_recforest,
 id_var = "id",
 covariates = c("treatment", "number", "size"),
 time_vars = c("t.start", "t.stop"),
 death_var = "death"
)
</code></pre>

<hr>
<h2 id='print.recforest'>Print method for recforest objects</h2><span id='topic+print.recforest'></span>

<h3>Description</h3>

<p>Print method for recforest objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'recforest'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.recforest_+3A_x">x</code></td>
<td>
<p>An object of class <code>recforest</code>.</p>
</td></tr>
<tr><td><code id="print.recforest_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the plot print</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Used for side effect.
Will print to the console a description of each tree, with, for each:
</p>

<ul>
<li><p> The number of nodes in the tree
</p>
</li>
<li><p> The metrics of the tree (c_index, mse_imse and mse_iscore)
</p>
</li></ul>


<hr>
<h2 id='summary.recforest'>Summary Method for recforest Objects</h2><span id='topic+summary.recforest'></span>

<h3>Description</h3>

<p>This function provides a summary of a recforest object by printing its metrics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'recforest'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.recforest_+3A_object">object</code></td>
<td>
<p>An object of class <code>recforest</code>.</p>
</td></tr>
<tr><td><code id="summary.recforest_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the summary function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function prints the metrics of the <code>recforest</code> object.
</p>

<hr>
<h2 id='train_forest'>Train a Recforest Model</h2><span id='topic+train_forest'></span>

<h3>Description</h3>

<p>This function trains a recforest model using the provided data and parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>train_forest(
  data,
  id_var,
  covariates,
  event,
  time_vars = c("t.start", "t.stop"),
  death_var = NULL,
  n_trees,
  n_bootstrap = NULL,
  seed = NULL,
  mtry,
  minsplit,
  nodesize,
  method,
  min_score,
  max_nodes,
  parallel = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="train_forest_+3A_data">data</code></td>
<td>
<p>A data frame containing the dataset to be used for training the model.</p>
</td></tr>
<tr><td><code id="train_forest_+3A_id_var">id_var</code></td>
<td>
<p>The name of the column containing the unique identifier for each subject.</p>
</td></tr>
<tr><td><code id="train_forest_+3A_covariates">covariates</code></td>
<td>
<p>A character vector containing the names of the columns to be used as predictors in the model.</p>
</td></tr>
<tr><td><code id="train_forest_+3A_event">event</code></td>
<td>
<p>The name of the column containing the recurrent event indicator.</p>
</td></tr>
<tr><td><code id="train_forest_+3A_time_vars">time_vars</code></td>
<td>
<p>A length-2 character vector containing the names of the columns representing the start and stop times (default &quot;t.start&quot; and &quot;t.stop&quot;).</p>
</td></tr>
<tr><td><code id="train_forest_+3A_death_var">death_var</code></td>
<td>
<p>The name of the column containing the death indicator or other any terminal event (optional).</p>
</td></tr>
<tr><td><code id="train_forest_+3A_n_trees">n_trees</code></td>
<td>
<p>The number of trees to be trained in the recforest model.</p>
</td></tr>
<tr><td><code id="train_forest_+3A_n_bootstrap">n_bootstrap</code></td>
<td>
<p>The number of bootstrap samples to be used for training each tree (in-bag sample).
If not provided, it is set to 2/3 of the sample size (in term of number of unique <code>id_var</code>).</p>
</td></tr>
<tr><td><code id="train_forest_+3A_seed">seed</code></td>
<td>
<p>An optional seed value to be used for reproducibility purpose (NULL by default).</p>
</td></tr>
<tr><td><code id="train_forest_+3A_mtry">mtry</code></td>
<td>
<p>The number of candidate variables randomly drawn at each node of the trees.
This parameter should be tuned by minimizing the OOB error.</p>
</td></tr>
<tr><td><code id="train_forest_+3A_minsplit">minsplit</code></td>
<td>
<p>The minimal number of events required to split the node. Cannot be smaller than 2.</p>
</td></tr>
<tr><td><code id="train_forest_+3A_nodesize">nodesize</code></td>
<td>
<p>The minimal number of subjects required in both child nodes to split. Cannot be smaller than 1.</p>
</td></tr>
<tr><td><code id="train_forest_+3A_method">method</code></td>
<td>
<p>The method to be used for training the model. Currently, the following methods are supported : either &quot;NAa&quot; for Nelson-Aalen method, with no terminal event and no longitudinal time-dependent features; either &quot;GL&quot; for Ghosh-Lin modelization step with a terminal event and/or at least one longitudinal time-dependent feature.</p>
</td></tr>
<tr><td><code id="train_forest_+3A_min_score">min_score</code></td>
<td>
<p>The minimum score required to split a node. This parameter is used only when the method is set to &quot;NAa&quot;.</p>
</td></tr>
<tr><td><code id="train_forest_+3A_max_nodes">max_nodes</code></td>
<td>
<p>The maximum number of nodes per tree.</p>
</td></tr>
<tr><td><code id="train_forest_+3A_parallel">parallel</code></td>
<td>
<p>A logical value indicating whether to use parallel processing for training the trees.</p>
</td></tr>
<tr><td><code id="train_forest_+3A_verbose">verbose</code></td>
<td>
<p>A logical value indicating whether to print progress messages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The recforest model aggregates predictions over an ensemble of trees, each constructed using a set of decision nodes based on specific splitting rules.
At each node, a subset of predictors is randomly selected, and an optimal split is determined using an appropriate statistical test.
Depending on the specified <code>method</code>, the algorithm employs different statistical tests to find the best split:
</p>

<ul>
<li><p> For standard recurrent event data, the pseudo-score test statistic is used to compare two Nelson-Aalen estimates of the mean cumulative function.
</p>
</li>
<li><p> In the presence of terminal events and/or longitudinal variables, the Ghosh-Lin model is utilized to obtain the Wald test statistic, which provides a more accurate assessment of the split.
The trees grow until they meet the stopping criteria, which include a minimum number of events (<code>minsplit</code>) and a minimum number of individuals in terminal nodes (<code>nodesize</code>).
The final model is an ensemble of these trees, which helps to reduce overfitting and improve predictive performance by averaging the results on the out-of-bag sample.
</p>
</li></ul>



<h3>Value</h3>

<p>A list containing the following elements:
</p>
<table role = "presentation">
<tr><td><code>trees</code></td>
<td>
<p>A list of trained trees.</p>
</td></tr>
<tr><td><code>tree_metrics</code></td>
<td>
<p>A list of metrics for each tree.</p>
</td></tr>
<tr><td><code>metrics</code></td>
<td>
<p>A summary of the metrics for all trees.</p>
</td></tr>
<tr><td><code>columns</code></td>
<td>
<p>A list of column names used in the training.</p>
</td></tr>
<tr><td><code>params</code></td>
<td>
<p>A list of parameters used to set the model.</p>
</td></tr>
<tr><td><code>n_indiv</code></td>
<td>
<p>Number of individuals in the dataset.</p>
</td></tr>
<tr><td><code>n_predictors</code></td>
<td>
<p>Number of predictors used in the model.</p>
</td></tr>
<tr><td><code>n_trees</code></td>
<td>
<p>Number of trees trained.</p>
</td></tr>
<tr><td><code>n_bootstrap</code></td>
<td>
<p>Number of bootstrap samples used to grow each tree.</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>Computation time used to train the model.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Cook, R. J., &amp; Lawless, J. F. (1997). Marginal analysis of recurrent events and a terminating event. Statistics in medicine, 16(8), 911-924.
</p>
<p>Ghosh, D., &amp; Lin, D. Y. (2002). Marginal regression models for recurrent and terminal events. Statistica Sinica, 663-688.
</p>
<p>Ishwaran, H., Kogalur, U. B., Blackstone, E. H., &amp; Lauer, M. S. (2008). Random survival forests.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("bladder1_recforest")
trained_forest &lt;- train_forest(
  data = bladder1_recforest,
  id_var = "id",
  covariates = c("treatment", "number", "size"),
  time_vars = c("t.start", "t.stop"),
  death_var = "death",
  event = "event",
  n_trees = 2,
  n_bootstrap = 70,
  mtry = 2,
  minsplit = 3,
  nodesize = 15,
  method = "NAa",
  min_score = 5,
  max_nodes = 20,
  seed = 111,
  parallel = FALSE,
  verbose = FALSE
)
print(trained_forest)
summary(trained_forest)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
