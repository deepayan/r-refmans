<!DOCTYPE html><html><head><title>Help for package mvMonitoring</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mvMonitoring}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#mvMonitoring'><p>A Package for Multivariate Statistical Process Monitoring</p></a></li>
<li><a href='#dataStateSwitch'><p>Alternate Observations in a Data Frame over States</p></a></li>
<li><a href='#fault1A_xts'><p>Process Data under a System Shift Fault</p></a></li>
<li><a href='#fault2A_xts'><p>Process Data under a System Drift Fault</p></a></li>
<li><a href='#fault3A_xts'><p>Process Data under a System Signal Amplification</p></a></li>
<li><a href='#faultDetect'><p>Process Fault Detection</p></a></li>
<li><a href='#faultFilter'><p>Process Fault Filtering</p></a></li>
<li><a href='#faultSwitch'><p>Induce the Specified Fault on NOC Observations</p></a></li>
<li><a href='#mspContributionPlot'><p>Contribution Plots</p></a></li>
<li><a href='#mspMonitor'><p>Real-Time Process Monitoring Function</p></a></li>
<li><a href='#mspProcessData'><p>Simulate Normal or Fault Observations from a Single-State or Multi-State</p>
Process</a></li>
<li><a href='#mspSPEPlot'><p>Squared Prediction Error Contribution Plots</p></a></li>
<li><a href='#mspSubset'><p>Multi-State Subsetting</p></a></li>
<li><a href='#mspT2Plot'><p>T-Squared Contribution Plots</p></a></li>
<li><a href='#mspTrain'><p>Multi-State Adaptive-Dynamic Process Training</p></a></li>
<li><a href='#mspWarning'><p>Process Alarms</p></a></li>
<li><a href='#normal_switch_xts'><p>Process Data under Normal Conditions</p></a></li>
<li><a href='#oneDay_clean'><p>Real Process Data for Testing</p></a></li>
<li><a href='#pca'><p>PCA for Data Scatter Matrix</p></a></li>
<li><a href='#processMonitor'><p>Adaptive Process Training</p></a></li>
<li><a href='#processNOCdata'><p>Simulate NOC Observations from a Single-State or Multi-State Process</p></a></li>
<li><a href='#quantile.density'><p>Extract Quantiles from 'density' Objects</p></a></li>
<li><a href='#rotate3D'><p>Three-Dimensional Rotation Matrix</p></a></li>
<li><a href='#rotateScale3D'><p>Three-Dimensional Rotation and Scaling Matrix</p></a></li>
<li><a href='#tenDay_clean'><p>Real Process Data for Training</p></a></li>
<li><a href='#threshold'><p>Non-parametric Threshold Estimation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multi-State Adaptive Dynamic Principal Component Analysis for
Multivariate Process Monitoring</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-21</td>
</tr>
<tr>
<td>Description:</td>
<td>Use multi-state splitting to apply Adaptive-Dynamic PCA (ADPCA) to
    data generated from a continuous-time multivariate industrial or natural
    process. Employ PCA-based dimension reduction to extract linear combinations
    of relevant features, reducing computational burdens. For a description of 
    ADPCA, see &lt;<a href="https://doi.org/10.1007%2Fs00477-016-1246-2">doi:10.1007/s00477-016-1246-2</a>&gt;, the 2016 paper from Kazor et al.
    The multi-state application of ADPCA is from a manuscript under current
    revision entitled "Multi-State Multivariate Statistical Process Control" by
    Odom, Newhart, Cath, and Hering, and is  expected to appear in Q1 of 2018.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, lazyeval, plyr, rlang, utils, xts, zoo, robustbase,
graphics</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/gabrielodom/mvMonitoring">https://github.com/gabrielodom/mvMonitoring</a></td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-21 17:15:35 UTC; gabrielodom</td>
</tr>
<tr>
<td>Author:</td>
<td>Melissa Innerst [aut],
  Gabriel Odom [aut, cre],
  Ben Barnard [aut],
  Karen Kazor [aut],
  Amanda Hering [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gabriel Odom &lt;gabriel.odom@fiu.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-21 17:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='mvMonitoring'>A Package for Multivariate Statistical Process Monitoring</h2><span id='topic+mvMonitoring'></span><span id='topic+mvMonitoring-package'></span>

<h3>Description</h3>

<p>The <code>mvMonitoring</code> package has four main functions for
external use, all of which begin with the string &quot;msp&quot; (for &quot;multivariate
statistical process&quot;) followed by the function use. Functions without this
&quot;msp&quot; key are primarily internal functions. They are available to see and
use, but will largely be unnecessary to call in common workflows.
</p>


<h3><code>mvMonitoring</code> external functions</h3>


<dl>
<dt><code><a href="#topic+mspProcessData">mspProcessData</a></code> - </dt><dd><p>A function for synthetic process
data generation. Use this data to test new process monitoring methods.
</p>
</dd>
<dt><code><a href="#topic+mspTrain">mspTrain</a></code> - </dt><dd><p>A function to take in observations for
training under normal conditions, and to return the training summary
from these observations.
</p>
</dd>
<dt><code><a href="#topic+mspMonitor">mspMonitor</a></code> - </dt><dd><p>A function to take in real-time
process observations and detect system anomalies based on the training
summary returned by <code><a href="#topic+mspTrain">mspTrain</a></code>.
</p>
</dd>
<dt><code><a href="#topic+mspWarning">mspWarning</a></code> - </dt><dd><p>A function to take in observations
returned by <code><a href="#topic+mspMonitor">mspMonitor</a></code> and check for alarms by
measuring sequential anomalies. This function will also be equipped to
send SMS notifications to process technicians in future versions.
</p>
</dd>
</dl>


<hr>
<h2 id='dataStateSwitch'>Alternate Observations in a Data Frame over States</h2><span id='topic+dataStateSwitch'></span>

<h3>Description</h3>

<p>Split single-state process observations, apply multiple state
projections, and combine these observations into a single data frame,
arranged by process time or index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataStateSwitch(
  df,
  angles2 = list(yaw = 0, pitch = 90, roll = 30),
  scales2 = c(1, 0.5, 2),
  angles3 = list(yaw = 90, pitch = 0, roll = -30),
  scales3 = c(0.25, 0.1, 0.75)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dataStateSwitch_+3A_df">df</code></td>
<td>
<p>A data frame returned by processNOCdata() or faultSwitch().</p>
</td></tr>
<tr><td><code id="dataStateSwitch_+3A_angles2">angles2</code></td>
<td>
<p>Change the principal angles for State 2.</p>
</td></tr>
<tr><td><code id="dataStateSwitch_+3A_scales2">scales2</code></td>
<td>
<p>Change the principal scales for State 2.</p>
</td></tr>
<tr><td><code id="dataStateSwitch_+3A_angles3">angles3</code></td>
<td>
<p>Change the principal angles for State 3.</p>
</td></tr>
<tr><td><code id="dataStateSwitch_+3A_scales3">scales3</code></td>
<td>
<p>Change the principal scales for State 3.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function splits a process data frame by state, and rotates and
scales the observations from states 2 and 3 by the scales and angles
specified in the function arguments. After state-specific rotation and
scaling, this function combines the observations back together and orders
them by process time index. This function takes in data frame returned by
processNOCdata() or faultSwitch(). This function calls rotateScale3D() and
is called internally by mspProcessData().
</p>


<h3>Value</h3>

<p>A data frame containing the time index, state, and feature values
after state-specific rotation and scaling; this data frame also contains
the other columns of df that aren't the feature values. This data frame has
</p>

<dl>
<dt>dateTime - </dt><dd><p>a POSIX column of the time stamps for each
observation</p>
</dd>
<dt>state - </dt><dd><p>column of state membership (1, 2, or 3)</p>
</dd>
<dt>x - </dt><dd><p>the process values for the first feature, corresponding to
t + random error</p>
</dd>
<dt>y - </dt><dd><p>the process values for the second feature, corresponding to
t ^ 2 - 3 * t + random error</p>
</dd>
<dt>z - </dt><dd><p>the process values for the third feature, corresponding to
-t ^ 3 + 3 * t ^ 2 + random error</p>
</dd>
<dt>t - </dt><dd><p>the non-stationary and autocorrelated latent feature</p>
</dd>
<dt>err1 - </dt><dd><p>a Gaussian white noise vector</p>
</dd>
<dt>err2 - </dt><dd><p>a Gaussian white noise vector</p>
</dd>
<dt>err3 - </dt><dd><p>a Gaussian white noise vector</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Calls: <code><a href="#topic+processNOCdata">processNOCdata</a></code>, <code><a href="#topic+faultSwitch">faultSwitch</a></code>,
<code><a href="#topic+rotateScale3D">rotateScale3D</a></code>. Called by: <code><a href="#topic+mspProcessData">mspProcessData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nrml &lt;- processNOCdata()
dataStateSwitch(nrml)
</code></pre>

<hr>
<h2 id='fault1A_xts'>Process Data under a System Shift Fault</h2><span id='topic+fault1A_xts'></span>

<h3>Description</h3>

<p>Three-feature, three-state simulated process data including
observations under normal operating conditions and observations after a
positive shift for each feature in the system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fault1A_xts
</code></pre>


<h3>Format</h3>

<p>An xts data matrix with 10080 rows and four columns, corresponding to
one week worth of data recorded at a 1-minute interval. The columns under
normal conditions are defined in the help file for normal_switch_xts. The
fault is a system shock to each of the three features by 2. The fault
starts at row 8500, and the four columns under the fault state are defined
here:
</p>

<dl>
<dt>state : </dt><dd><p>the state indicator for the multivariate system, with three
levels</p>
</dd>
<dt>x : </dt><dd><p>x(t) = t + 2 + error</p>
</dd>
<dt>y : </dt><dd><p>y(t) = t ^ 2 - 3t + 2 + error</p>
</dd>
<dt>z : </dt><dd><p>z(t) = - t ^ 3 + 3t ^ 2 + 2 + error</p>
</dd>
</dl>

<p>where t is a 10080-entry vector of autocorrelated and non-stationary hidden
process realizations. The states alternate each hour and are defined as
follows:
</p>

<dl>
<dt>State1 &ndash; </dt><dd><p>As presented</p>
</dd>
<dt>State2 &ndash; </dt><dd><p>Rotated by (yaw = 0, pitch = 90, roll = 30) and scaled by
(1 * x, 0.5 * y , 2 * z).</p>
</dd>
<dt>State3 &ndash; </dt><dd><p>Rotated by (yaw = 90, pitch = 0, roll = -30) and scaled by
(0.25 * x, 0.1 * y , 0.75 * z).</p>
</dd>
</dl>

<p>See the vignette for more details.
</p>


<h3>Source</h3>

<p>Simulated in R.
</p>

<hr>
<h2 id='fault2A_xts'>Process Data under a System Drift Fault</h2><span id='topic+fault2A_xts'></span>

<h3>Description</h3>

<p>Three-feature, three-state simulated process data including
observations under normal operating conditions and observations after a
positive drift in values for each feature in the system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fault2A_xts
</code></pre>


<h3>Format</h3>

<p>An xts data matrix with 10080 rows and four columns, corresponding to
one week worth of data recorded at a 1-minute interval. The columns under
normal conditions are defined in the help file for normal_switch_xts. The
fault is a drift on each feature by s / 10 ^ 3, where s is the observation
index. The fault starts at row 8500, and the four columns under the fault
state are defined here:
</p>

<dl>
<dt>state : </dt><dd><p>the state indicator for the multivariate system, with three
levels</p>
</dd>
<dt>x : </dt><dd><p>x(t) = t + drift + error</p>
</dd>
<dt>y : </dt><dd><p>y(t) = t ^ 2 - 3t + drift + error</p>
</dd>
<dt>z : </dt><dd><p>z(t) = - t ^ 3 + 3t ^ 2 + drift + error</p>
</dd>
</dl>

<p>where t is a 10080-entry vector of autocorrelated and non-stationary hidden
process realizations. The states alternate each hour and are defined as
follows:
</p>

<dl>
<dt>State1 &ndash; </dt><dd><p>As presented</p>
</dd>
<dt>State2 &ndash; </dt><dd><p>Rotated by (yaw = 0, pitch = 90, roll = 30) and scaled by
(1 * x, 0.5 * y , 2 * z).</p>
</dd>
<dt>State3 &ndash; </dt><dd><p>Rotated by (yaw = 90, pitch = 0, roll = -30) and scaled by
(0.25 * x, 0.1 * y , 0.75 * z).</p>
</dd>
</dl>

<p>See the vignette for more details.
</p>


<h3>Source</h3>

<p>Simulated in R.
</p>

<hr>
<h2 id='fault3A_xts'>Process Data under a System Signal Amplification</h2><span id='topic+fault3A_xts'></span>

<h3>Description</h3>

<p>Three-feature, three-state simulated process data including
observations under normal operating conditions and observations after an
amplification of the underlying process for each feature in the system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fault3A_xts
</code></pre>


<h3>Format</h3>

<p>An xts data matrix with 10080 rows and four columns, corresponding to
one week worth of data recorded at a 1-minute interval. The columns under
normal conditions are defined in the help file for normal_switch_xts. The
fault is a signal amplification in the underlying determining t vector. The
fault starts at row 8500, and the four columns under the fault state are
defined here:
</p>

<dl>
<dt>state : </dt><dd><p>the state indicator for the multivariate system, with three
levels</p>
</dd>
<dt>x : </dt><dd><p>x(t_*) = t_* + error</p>
</dd>
<dt>y : </dt><dd><p>y(t_*) = (t_*) ^ 2 - 3t + error</p>
</dd>
<dt>z : </dt><dd><p>z(t_*) = - (t_*) ^ 3 + 3(t_*) ^ 2 + error</p>
</dd>
</dl>

<p>where t_* = 3 * t * (10080 - s) / (2 * 10080), where s is the observation
index, and t is a 10080-entry vector of autocorrelated and non-stationary
hidden process realizations. The states alternate each hour and are defined
as follows:
</p>

<dl>
<dt>State1 &ndash; </dt><dd><p>As presented</p>
</dd>
<dt>State2 &ndash; </dt><dd><p>Rotated by (yaw = 0, pitch = 90, roll = 30) and scaled by
(1 * x, 0.5 * y , 2 * z).</p>
</dd>
<dt>State3 &ndash; </dt><dd><p>Rotated by (yaw = 90, pitch = 0, roll = -30) and scaled by
(0.25 * x, 0.1 * y , 0.75 * z).</p>
</dd>
</dl>

<p>See the vignette for more details.
</p>


<h3>Source</h3>

<p>Simulated in R.
</p>

<hr>
<h2 id='faultDetect'>Process Fault Detection</h2><span id='topic+faultDetect'></span>

<h3>Description</h3>

<p>Detect if a single multivariate observation is beyond normal
operating conditions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>faultDetect(threshold_object, observation, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="faultDetect_+3A_threshold_object">threshold_object</code></td>
<td>
<p>An object of classes &quot;threshold&quot; and &quot;pca&quot; returned
by the internal threshold() function.</p>
</td></tr>
<tr><td><code id="faultDetect_+3A_observation">observation</code></td>
<td>
<p>A single row of an xts data matrix (a 1 x p matrix) to
compare against the thresholds</p>
</td></tr>
<tr><td><code id="faultDetect_+3A_...">...</code></td>
<td>
<p>Lazy dots for additional internal arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes in a threshold object returned by the
threshold() function and a single observation as a matrix or xts row.
Internally, the function multiplies the observation by the projection
matrix returned within the threshold object, calculates the SPE and T2
process monitoring statistics for that observation, and compares these
statistics against their corresponding threshold values to determine if the
observation lies outside the expected boundaries. The function then returns
a row vector of the SPE test statistic, a logical indicator marking if this
statistic is beyond the threshold, the Hotelling's T2 statistic, and an
indicator if this statistic is beyond the threshold. Observations with
monitoring statistics beyond the calculated threshold are marked with a 1,
while observations within normal operating conditions are marked with a 0.
These threshold values are passed from the threshold() function through
this function via a returned threshold object. This object will be used in
higher function calls.
</p>
<p>This internal function is called by faultFilter().
</p>


<h3>Value</h3>

<p>A named 1 x 4 matrix with the following entries for the single row
observation passed to this function:
</p>

<dl>
<dt>SPE &ndash; </dt><dd><p>the SPE statistic value</p>
</dd>
<dt>SPE_Flag &ndash; </dt><dd><p>the SPE fault indicator, where 1 represents a flag and
0 marks that the observation is within the normal operating conditions</p>
</dd>
<dt>T2 &ndash; </dt><dd><p>the T2 statistic value</p>
</dd>
<dt>T2_Flag &ndash; </dt><dd><p>the T2 fault indicator, defined the same as SPE_Flag</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Called by <code><a href="#topic+faultFilter">faultFilter</a></code> and <code><a href="#topic+mspMonitor">mspMonitor</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nrml &lt;- mspProcessData(faults = "NOC")
scaledData &lt;- scale(nrml[,-1])
pca_obj &lt;- pca(scaledData)
thresh_obj &lt;- threshold(pca_object = pca_obj)

faultDetect(threshold_object = thresh_obj,
            observation = scaledData[1,])

</code></pre>

<hr>
<h2 id='faultFilter'>Process Fault Filtering</h2><span id='topic+faultFilter'></span>

<h3>Description</h3>

<p>Flag and filter out observations beyond normal operating
conditions, then return the observations within normal operating
conditions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>faultFilter(trainData, testData, updateFreq, faultsToTriggerAlarm = 5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="faultFilter_+3A_traindata">trainData</code></td>
<td>
<p>An xts data matrix of initial training observations</p>
</td></tr>
<tr><td><code id="faultFilter_+3A_testdata">testData</code></td>
<td>
<p>The data not included in the training data set</p>
</td></tr>
<tr><td><code id="faultFilter_+3A_updatefreq">updateFreq</code></td>
<td>
<p>The number of observations from the test data matrix that
must be returned to update the training data matrix and move it forward.</p>
</td></tr>
<tr><td><code id="faultFilter_+3A_faultstotriggeralarm">faultsToTriggerAlarm</code></td>
<td>
<p>Specifies how many sequential faults will cause
an alarm to trigger. Defaults to 5.</p>
</td></tr>
<tr><td><code id="faultFilter_+3A_...">...</code></td>
<td>
<p>Lazy dots for additional internal arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is essentially a wrapper function to call and organize
the output from these other internal functions: faultDetect(), threshold(),
and pca(). It is applied over a rolling window, with observation width
equal to updateFreq, of the larger full data matrix via the
processMonitor() function, wherein the testing and training data sets move
forward in time across the entire data matrix.
</p>
<p>This internal function is called by processMonitor().
</p>


<h3>Value</h3>

<p>A list of class &quot;fault_ls&quot; with the following:
</p>

<dl>
<dt>faultObj &ndash; </dt><dd><p>An xts flagging matrix with the same number of rows as
&quot;testData&quot;. This flag matrix has the following five columns:
</p>

<dl>
<dt>SPE &ndash; </dt><dd><p>The SPE statistic value for each observation in
&quot;testData&quot;. This statistic is defined as
</p>
<p style="text-align: center;"><code class="reqn">
              SPE_i = (\textbf{X}_i - \textbf{Y}_i * \textbf{P}^T) *
               (\textbf{X}_i - \textbf{Y}_i * \textbf{P}^T)^T,
            </code>
</p>

<p>where <code class="reqn">\textbf{X}_i</code> is the <code class="reqn">i^{th}</code> observation vector,
<code class="reqn">\textbf{Y}_i</code> is the reduced-feature projection of the
observation <code class="reqn">\textbf{X}_i</code>, and <code class="reqn">\textbf{P}</code> is the
projection matrix such that <code class="reqn">\textbf{X}_i\textbf{P} =
            \textbf{Y}_i</code>.</p>
</dd>
<dt>SPE_Flag &ndash; </dt><dd><p>A vector of SPE indicators recording 0 if the
test statistic is less than or equal to the critical value
passed through from the threshold object.</p>
</dd>
<dt>T2 &ndash; </dt><dd><p>The T2 statistic value for each observation in
&quot;testData&quot;. This statistic is defined as
</p>
<p style="text-align: center;"><code class="reqn">
               T^2_i = \textbf{Y}_i * \textbf{D}^{-1} * \textbf{Y}_i^T,
            </code>
</p>

<p>where <code class="reqn">\textbf{Y}_i = \textbf{X}_i\textbf{P}</code> is the reduced-
feature projection of the observation <code class="reqn">\textbf{X}_i</code>, and
<code class="reqn">\textbf{D}</code> is the diagonal matrix of eigenvalues.</p>
</dd>
<dt>T2_Flag &ndash; </dt><dd><p>A vector of T2 fault indicators, defined like
SPE_Flag.</p>
</dd>
<dt>Alarm &ndash; </dt><dd><p>A column indicating if there have been five flags
in a row for either the SPE or T2 monitoring statistics or both.
Alarm states are as follows: 0 = no alarm, 1 = Hotelling's T2
alarm, 2 = Squared Prediction Error alarm, and 3 = both alarms.</p>
</dd>
</dl>

</dd>
<dt>nonAlarmedTestObs &ndash; </dt><dd><p>An xts matrix of the first updateFreq number
of rows of the training data which were not alarmed.</p>
</dd>
<dt>trainSpecs &ndash; </dt><dd><p>The threshold object returned by the internal
threshold() function. See the threshold() function's help file for more
details.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Calls: <code><a href="#topic+pca">pca</a></code>, <code><a href="#topic+threshold">threshold</a></code>,
<code><a href="#topic+faultDetect">faultDetect</a></code>. Called by: <code><a href="#topic+processMonitor">processMonitor</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nrml &lt;- mspProcessData(faults = "NOC")
# Select the data under state 1
data &lt;- nrml[nrml[,1] == 1]

faultFilter(trainData = data[1:672, -1],
            testData = data[673:3360, -1],
            updateFreq = 336)

</code></pre>

<hr>
<h2 id='faultSwitch'>Induce the Specified Fault on NOC Observations</h2><span id='topic+faultSwitch'></span>

<h3>Description</h3>

<p>Infect the input data frame with a specific fault, then return
the infected data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>faultSwitch(
  df,
  fault,
  period = 7 * 24 * 60,
  faultStartIndex = round(0.8433 * period),
  shift = 2,
  postStateSplit = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="faultSwitch_+3A_df">df</code></td>
<td>
<p>A data frame returned by the processNOCdata() function.</p>
</td></tr>
<tr><td><code id="faultSwitch_+3A_fault">fault</code></td>
<td>
<p>A character string. Options are &quot;NOC&quot;, &quot;A1&quot;, &quot;B1&quot;, &quot;C1&quot;, &quot;A2&quot;,
&quot;B2&quot;, &quot;C2&quot;, &quot;A3&quot;, &quot;B3&quot;, or &quot;C3&quot;. See &quot;details&quot; of mspProcessData() for more
information.</p>
</td></tr>
<tr><td><code id="faultSwitch_+3A_period">period</code></td>
<td>
<p>The observation cycle length. Defaults to one week's worth of
minute-level observations (10,080 observations).</p>
</td></tr>
<tr><td><code id="faultSwitch_+3A_faultstartindex">faultStartIndex</code></td>
<td>
<p>An integer specifying the index at which the faults
will start. Defaults to roughly 85 percent through the cycle.</p>
</td></tr>
<tr><td><code id="faultSwitch_+3A_shift">shift</code></td>
<td>
<p>The fault parameter for faults &quot;A1&quot; and &quot;B1&quot; corresponding to
the positive shock value added to features. Defaults to 2. See &quot;details&quot; of
mspProcessData() for more information.</p>
</td></tr>
<tr><td><code id="faultSwitch_+3A_poststatesplit">postStateSplit</code></td>
<td>
<p>Should we induce faults before or after state-splitting?
Defaults to FALSE. Make this argument TRUE for faults 1C, 2C, 3C.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The faults return data frames as follows: </p>

<dl>
<dt>A1 &ndash; </dt><dd><p>A data frame with 10080 rows and five columns, corresponding
by default to one week worth of data recorded at a 1-minute interval (as
defined by the &quot;period&quot; argument of this function and the &quot;increment&quot;
argument of the processNOCdata() function). The fault is a system shift
to each of the three features by 2 (the &quot;shift&quot; argument). The fault
starts at row 8500 (specified by the argument &quot;faultStartIndex&quot;), and the
five columns under the fault state are defined here: </p>

<dl>
<dt>dateTime : </dt><dd><p>a POSIXct column</p>
</dd>
<dt>state : </dt><dd><p>the state indicator for the multivariate system, with
three levels when the argument &quot;multiState&quot; is TRUE and one level
otherwise</p>
</dd>
<dt>x : </dt><dd><p>x(t) = t + shift + error</p>
</dd>
<dt>y : </dt><dd><p>y(t) = t ^ 2 - 3t + shift + error</p>
</dd>
<dt>z : </dt><dd><p>z(t) = -t ^ 3 + 3t ^ 2 + shift + error</p>
</dd>
</dl>

<p>where t is a 10080-entry vector of autocorrelated and non-stationary
hidden process realizations generated within the processNOCdata() function.
</p>
</dd>
<dt>B1 &ndash; </dt><dd><p>A matrix as defined in A1, but with x, y, and z feature
columns defined as follows: </p>

<dl>
<dt>x : </dt><dd><p>x(t) = t + shift + error</p>
</dd>
<dt>y : </dt><dd><p>y(t) = t ^ 2 - 3t + error</p>
</dd>
<dt>z : </dt><dd><p>z(t) = -t ^ 3 + 3t ^ 2 + error</p>
</dd>
</dl>

</dd>
<dt>C1 &ndash; </dt><dd><p>A matrix as defined in A1, but with x, y, and z feature
columns defined as follows: </p>

<dl>
<dt>x : </dt><dd><p>x(t) = t + shift / 4 + error</p>
</dd>
<dt>y : </dt><dd><p>y(t) = t ^ 2 - 3t + error</p>
</dd>
<dt>z : </dt><dd><p>z(t) = -t ^ 3 + 3t ^ 2 + shift / 4 + error</p>
</dd>
</dl>

<p>This shift is applied only in State 3.
</p>
</dd>
<dt>A2 &ndash; </dt><dd><p>The fault is a drift on each feature by
(s - faultStartIndex / 10 ^ 3, where s is the observation index. The
fault starts at &quot;faultStartIndex&quot;, and the x, y, and z feature columns
are defined as follows: </p>

<dl>
<dt>x : </dt><dd><p>x(t) = t + drift + error</p>
</dd>
<dt>y : </dt><dd><p>y(t) = t ^ 2 - 3t + drift + error</p>
</dd>
<dt>z : </dt><dd><p>z(t) = -t ^ 3 + 3t ^ 2 + drift + error</p>
</dd>
</dl>

</dd>
<dt>B2 &ndash; </dt><dd><p>The fault is a drift a drift on the &quot;y&quot; and &quot;z&quot; feature by
(s - faultStartIndex / 10 ^ 3, where s is the observation index. The
fault starts at &quot;faultStartIndex&quot;, and the x, y, and z feature columns
are defined as follows: </p>

<dl>
<dt>x : </dt><dd><p>x(t) = t + error</p>
</dd>
<dt>y : </dt><dd><p>y(t) = t ^ 2 - 3t + drift + error</p>
</dd>
<dt>z : </dt><dd><p>z(t) = -t ^ 3 + 3t ^ 2 + drift + error</p>
</dd>
</dl>

</dd>
<dt>C2 &ndash; </dt><dd><p>The fault is a negative drift on the &quot;y&quot; feature by 1.5 *
(s - faultStartIndex) / (period - faultStartIndex). Thus, </p>

<dl>
<dt>x : </dt><dd><p>x(t) = t + error</p>
</dd>
<dt>y : </dt><dd><p>y(t) = t ^ 2 - 3t - drift + error</p>
</dd>
<dt>z : </dt><dd><p>z(t) = -t ^ 3 + 3t ^ 2 + error</p>
</dd>
</dl>

<p>This drift is applied only in State 2.
</p>
</dd>
<dt>A3 &ndash; </dt><dd><p>The fault is a signal amplification in the determining latent
t vector. The fault starts at &quot;faultStartIndex&quot;, and the x, y, and z
features under the fault state are defined here: </p>

<dl>
<dt>x : </dt><dd><p>x(t_*) = t_* + error</p>
</dd>
<dt>y : </dt><dd><p>y(t_*) = (t_*) ^ 2 - 3t_* + error</p>
</dd>
<dt>z : </dt><dd><p>z(t_*) = -(t_*) ^ 3 + 3(t_*) ^ 2 + error</p>
</dd>
</dl>

<p>where t_* = 5 x t x (period - s) / (period - faultStartIndex) and s is
the observation index.
</p>
</dd>
<dt>B3 &ndash; </dt><dd><p>The fault is a signal amplification in the determining latent
t vector for the &quot;z&quot; feature only. The fault starts at &quot;faultStartIndex&quot;,
and the x, y, and z features under the fault state are defined here:
</p>

<dl>
<dt>x : </dt><dd><p>x(t) = t + error</p>
</dd>
<dt>y : </dt><dd><p>y(t) = (t) ^ 2 - 3t + error</p>
</dd>
<dt>z : </dt><dd><p>z(t_*) = -(t_*) ^ 3 + 3(t_*) ^ 2 + error</p>
</dd>
</dl>

<p>where t_* = 3 x t x (period - s) / (2 x period) and s is the observation
index.
</p>
</dd>
<dt>C3 &ndash; </dt><dd><p>This fault is a change in the error structure of feature &quot;y&quot;.
We let errorNew = 2 * error - 0.25, so that </p>

<dl>
<dt>x : </dt><dd><p>x(t) = t + error</p>
</dd>
<dt>y : </dt><dd><p>y(t) = t ^ 2 - 3t + errorNew</p>
</dd>
<dt>z : </dt><dd><p>z(t) = -t ^ 3 + 3t ^ 2 + error</p>
</dd>
</dl>

<p>This new error structure is applied only in State 2.
</p>
</dd>
</dl>



<h3>Value</h3>

<p>A data frame with the same structure as df, but with faults induced
across all observations. The mspProcessData() function then subsets the
observations necessary to corrupt the normal data frame, and binds them
together by row. This function is called by mspProcessData(). See
?mspProcessData for more details.
</p>


<h3>See Also</h3>

<p>Called by: <code><a href="#topic+mspProcessData">mspProcessData</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nrml &lt;- processNOCdata()
faultSwitch(nrml, fault = "NOC")
</code></pre>

<hr>
<h2 id='mspContributionPlot'>Contribution Plots</h2><span id='topic+mspContributionPlot'></span>

<h3>Description</h3>

<p>This function plots the contribution value for each
variable of a newly monitored observation and compares them to the
contribution values of the training data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mspContributionPlot(
  trainData,
  trainLabel,
  newData,
  newLabel,
  var.amnt,
  trainObs
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mspContributionPlot_+3A_traindata">trainData</code></td>
<td>
<p>an xts data matrix containing the training observations</p>
</td></tr>
<tr><td><code id="mspContributionPlot_+3A_trainlabel">trainLabel</code></td>
<td>
<p>Class labels for the training data as a logical (two states
only) or finite numeric (two or more states) vector or matrix column (not from
a data frame) with length equal to the number of rows in &ldquo;data.&quot; For data with
only one state, this will be a vector of 1s.</p>
</td></tr>
<tr><td><code id="mspContributionPlot_+3A_newdata">newData</code></td>
<td>
<p>an xts data matrix containing the new observation</p>
</td></tr>
<tr><td><code id="mspContributionPlot_+3A_newlabel">newLabel</code></td>
<td>
<p>the class label for the new observation</p>
</td></tr>
<tr><td><code id="mspContributionPlot_+3A_var.amnt">var.amnt</code></td>
<td>
<p>the energy proportion to preserve in the projection, which
dictates the number of principal components to keep</p>
</td></tr>
<tr><td><code id="mspContributionPlot_+3A_trainobs">trainObs</code></td>
<td>
<p>the number of observations upon which to train the algorithm.
This will be split based on class information by a priori class membership
proportions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A contribution plot and a list with the following items: </p>

<dl>
<dt>TrainCV &ndash; </dt><dd><p>A list vectors containing the contribution values
corresponding to each observation in the set of training observations.</p>
</dd>
<dt>NewCV &ndash; </dt><dd><p>The vector of contribution values associated with the
new observation</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Create some data
dataA1 &lt;- mspProcessData(faults = "B1")
traindataA1 &lt;- dataA1[1:8567,]

# Train on the data that should be in control
trainResults &lt;- mspTrain(traindataA1[,-1], traindataA1[,1], trainObs = 4320)

# Lag an out of control observation
testdataA1 &lt;- dataA1[8567:8568,-1]
testdataA1 &lt;- lag.xts(testdataA1,0:1)
testdataA1 &lt;- testdataA1[-1,]
testdataA1 &lt;- cbind(dataA1[8568,1],testdataA1)

tD &lt;- traindataA1[,-1]
tL &lt;- traindataA1[,1]
nD &lt;- testdataA1[,-1]
nL &lt;- testdataA1[,1]
tO &lt;- 4320
vA &lt;- 0.95

mspContributionPlot(tD, tL, nD, nL, vA, tO)
## End(Not run)

</code></pre>

<hr>
<h2 id='mspMonitor'>Real-Time Process Monitoring Function</h2><span id='topic+mspMonitor'></span>

<h3>Description</h3>

<p>Monitor and flag (if necessary) incoming multivariate process
observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mspMonitor(observations, labelVector, trainingSummary, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mspMonitor_+3A_observations">observations</code></td>
<td>
<p>an n x p xts matrix. For real-time monitoring via a
script within a batch file, n = 1, so this must be a 1 x p matrix. If lags
were included at the training step, then these observations will also have
lagged features.</p>
</td></tr>
<tr><td><code id="mspMonitor_+3A_labelvector">labelVector</code></td>
<td>
<p>an n x 1 integer vector of class memberships</p>
</td></tr>
<tr><td><code id="mspMonitor_+3A_trainingsummary">trainingSummary</code></td>
<td>
<p>the TrainingSpecs list returned by the mspTrain()
function. This list contains&mdash;for each class&mdash;the SPE and T2 thresholds,
as well the projection matrix.</p>
</td></tr>
<tr><td><code id="mspMonitor_+3A_...">...</code></td>
<td>
<p>Lazy dots for additional internal arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is designed to be run at specific time intervals
(e.g.every 10 seconds, 30 seconds, 1 minute, 5 minutes, 10 minutes) through
a scheduled operating script which calls this function and mspWarning(). We
expect this script to be set up in Windows &quot;Task Scheduler&quot; or Macintosh OX
&quot;launchd&quot; application suites. This function takes in the specific
observations to monitor and their class memberships (if any) and returns an
xts matrix of these observation columns concatenated with their monitoring
statistic values, flag statuses, and an empty alarm column. Users should
then append these rows onto a previously existing matrix of daily
observations. The mspWarning() function will then take in the daily
observation xts matrix with updated rows returned by this function and
check the monitoring statistic flag indicators to see if an alarm status
has been reached. For further details, see the mspWarning() function.
</p>
<p>This function calls the faultDetect() function, and requires the training
information returned by the mspTrain function. This function will return
the xts matrix necessary for the mspWarning() function.
</p>


<h3>Value</h3>

<p>An n x (p + 5) xts matrix, where the last five columns are:
</p>

<dl>
<dt>SPE &ndash; </dt><dd><p>the SPE statistic value for each observation
in &quot;observations&quot;</p>
</dd>
<dt>SPE_Flag &ndash; </dt><dd><p>a vector of SPE indicators recording 0 if the test
statistic is less than or equal to the critical value passed through
from the threshold object</p>
</dd>
<dt>T2 &ndash; </dt><dd><p>the T2 statistic value for each observation in
&quot;observations&quot;</p>
</dd>
<dt>T2_Flag &ndash; </dt><dd><p>a vector of T2 fault indicators, defined like
SPE_Flag</p>
</dd>
<dt>Alarm &ndash; </dt><dd><p>a column indicating if there have been five flags in a
row for either the SPE or T2 monitoring statistics or both. Alarm
states are as follows: 0 = no alarm, 1 = Hotelling's T2 alarm, 2 =
Squared Prediction Error alarm, and 3 = both alarms.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Calls: <code><a href="#topic+faultDetect">faultDetect</a></code>. Pipe flow: <code><a href="#topic+mspTrain">mspTrain</a></code>
into <code>mspMonitor</code> into <code><a href="#topic+mspWarning">mspWarning</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: # cut down on R CMD check time

  nrml &lt;- mspProcessData(faults = "NOC")
  n &lt;- nrow(nrml)

  # Calculate the training summary, but save five observations for monitoring.
  trainResults_ls &lt;- mspTrain(data = nrml[1:(n - 5), -1],
                              labelVector = nrml[1:(n - 5), 1],
                              trainObs = 4320)

  # While training, we included 1 lag (the default), so we will also lag the
  #   observations we will test.
  testObs &lt;- nrml[(n - 6):n, -1]
  testObs &lt;- xts:::lag.xts(testObs, 0:1)
  testObs &lt;- testObs[-1,]
  testObs &lt;- cbind(nrml[(n - 5):n, 1], testObs)

  mspMonitor(observations = testObs[, -1],
             labelVector = testObs[, 1],
             trainingSummary = trainResults_ls$TrainingSpecs)


## End(Not run)

</code></pre>

<hr>
<h2 id='mspProcessData'>Simulate Normal or Fault Observations from a Single-State or Multi-State
Process</h2><span id='topic+mspProcessData'></span>

<h3>Description</h3>

<p>Generate single- or multi-state observations under normal
operating conditions or under fault conditions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mspProcessData(
  faults,
  period = 7 * 24 * 60,
  faultStartIndex = round(0.8433 * period),
  startTime = "2015-05-16 10:00:00 CST",
  multiState = TRUE,
  angles2 = list(yaw = 0, pitch = 90, roll = 30),
  scales2 = c(1, 0.5, 2),
  angles3 = list(yaw = 90, pitch = 0, roll = -30),
  scales3 = c(0.25, 0.1, 0.75),
  adpcaTest = FALSE,
  msadpcaTest = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mspProcessData_+3A_faults">faults</code></td>
<td>
<p>A character vector of faults chosen. Options are &quot;NOC&quot;, &quot;A1&quot;,
&quot;B1&quot;, &quot;C1&quot;, &quot;A2&quot;, &quot;B2&quot;, &quot;C2&quot;, &quot;A3&quot;, &quot;B3&quot;, &quot;C3&quot;, or &quot;All&quot;. See details for
more information.</p>
</td></tr>
<tr><td><code id="mspProcessData_+3A_period">period</code></td>
<td>
<p>The observation cycle length. Defaults to one week's worth of
minute-level observations (10,080 observations).</p>
</td></tr>
<tr><td><code id="mspProcessData_+3A_faultstartindex">faultStartIndex</code></td>
<td>
<p>An integer specifying the index at which the faults
will start. Defaults to roughly 85 percent through the cycle.</p>
</td></tr>
<tr><td><code id="mspProcessData_+3A_starttime">startTime</code></td>
<td>
<p>a POSIXct object specifying the day and time for the
starting observation.</p>
</td></tr>
<tr><td><code id="mspProcessData_+3A_multistate">multiState</code></td>
<td>
<p>Should the observations be generated from a multi-state
process? Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="mspProcessData_+3A_angles2">angles2</code></td>
<td>
<p>Change the principal angles for State 2. Defaults to yaw = 0,
pitch = 90, and roll = 30.</p>
</td></tr>
<tr><td><code id="mspProcessData_+3A_scales2">scales2</code></td>
<td>
<p>Change the principal scales for State 2. Defaults to 1, 0.5,
and 2.</p>
</td></tr>
<tr><td><code id="mspProcessData_+3A_angles3">angles3</code></td>
<td>
<p>Change the principal angles for State 3. Defaults to yaw = 90,
pitch = 0, and roll = -30.</p>
</td></tr>
<tr><td><code id="mspProcessData_+3A_scales3">scales3</code></td>
<td>
<p>Change the principal scales for State 3. Defaults to 0.25,
0.1, and 0.75.</p>
</td></tr>
<tr><td><code id="mspProcessData_+3A_adpcatest">adpcaTest</code></td>
<td>
<p>If &quot;multiState&quot; is TRUE, incorrectly label all the states
the same. This should only be used to test AD-PCA performance under a true
multi-state model. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="mspProcessData_+3A_msadpcatest">msadpcaTest</code></td>
<td>
<p>If &quot;multiState&quot; is FALSE, incorrectly label all the states
at random. This should only be used to test MSAD-PCA performance under a
true single-state model. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="mspProcessData_+3A_...">...</code></td>
<td>
<p>Lazy dots for internal arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details on how the faults are induced, see the &quot;details&quot; of the
faultSwitch() function. This function also includes AD-PCA versus MSAD-PCA
treatment arm testing. There are four possibilities to test: </p>

<dl>
<dt>1. </dt><dd><p>The true process has one state, and we correctly assume the
true process has one state. In this case, AD-PCA and MSAD-PCA are exactly
the same. Draw observations from this state by setting the &quot;multiState&quot;
argument to FALSE. The &quot;state&quot; label will correctly mark each observation
as from the same state.</p>
</dd>
<dt>2. </dt><dd><p>The true process has one state, but we incorrectly assume the
true process has multiple states. In this case, AD-PCA should outperform
MSAD-PCA in false alarm rates and waiting time to the first alarm. Draw
observations from this state by setting the &quot;multiState&quot; argument to
FALSE and the &quot;msadpcaTest&quot; argument to TRUE. The &quot;state&quot; label will be
contain randomly generated state values (1, 2, and 3 are all equally
likely) for each observation.</p>
</dd>
<dt>3. </dt><dd><p>The true process has multiple states, but we incorrectly
assume the true process has one single states. In this case, MSAD-PCA
should outperform AD-PCA in false alarm rates and waiting time to the
first alarm. Draw observations from this state by setting the &quot;multiState&quot;
argument to TRUE and the &quot;adpcaTest&quot; argument to TRUE. The &quot;state&quot; label
will be identical for each observation.</p>
</dd>
<dt>4. </dt><dd><p>The true process has multiple states, and we correctly assume
the true process has multiple states. In this case, MSAD-PCA
should outperform AD-PCA in false alarm rates and waiting time to the
first alarm. Draw observations from this state by setting the &quot;multiState&quot;
argument to TRUE. The &quot;state&quot; label will correctly mark each observation
as from the same state.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A list of data frames named with the names of the given faults with
the following information: </p>

<dl>
<dt>dateTime &ndash; </dt><dd><p>A POSIXct column of times starting at the user-
defined 'startTime' argument, length given by the 'period' argument,
and spacing given by the 'increment' argument. For example, if the
starting value is &quot;2016-01-10&quot;, period is 10080, and the incrementation
is in minutes, then this sequence will be one week's worth of
observations recorded every minute from midnight on the tenth of
January.</p>
</dd>
<dt>state &ndash; </dt><dd><p>An integer column of all 1's (when the 'multiState'
argument is FALSE), or a column of the state values (1, 2 or 3).</p>
</dd>
<dt>altState &ndash; </dt><dd><p>If either adpcaTest or msadpcaTest are TRUE, this
column will contain incorrect state information used for testing the
different treatment arms against their respective controls.</p>
</dd>
<dt>x &ndash; </dt><dd><p>A double column of generated values for the first feature.</p>
</dd>
<dt>y &ndash; </dt><dd><p>A double column of generated values for the second feature.</p>
</dd>
<dt>z &ndash; </dt><dd><p>A double column of generated values for the third feature.</p>
</dd>
</dl>

<p>If the user only specifies one fault, then this function will return the
single xts matrix, instead of a list of one matrix. For details on how
these features are defined, see the &quot;details&quot; of the processNOCdata()
function.
</p>


<h3>See Also</h3>

<p>Calls: <code><a href="#topic+processNOCdata">processNOCdata</a></code>, <code><a href="#topic+faultSwitch">faultSwitch</a></code>,
<code><a href="#topic+dataStateSwitch">dataStateSwitch</a></code>. Simulation pipe flow: <code>mspProcessData</code>
into <code><a href="#topic+mspTrain">mspTrain</a></code> into <code><a href="#topic+mspMonitor">mspMonitor</a></code> into
<code><a href="#topic+mspWarning">mspWarning</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: # cut down on R CMD check time

   mspProcessData(faults = "All")


## End(Not run)
</code></pre>

<hr>
<h2 id='mspSPEPlot'>Squared Prediction Error Contribution Plots</h2><span id='topic+mspSPEPlot'></span>

<h3>Description</h3>

<p>Plots a variation of the squared prediction error (SPE)
statistic to visualize the contribution of each variable to a fault.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mspSPEPlot(
  trainData,
  trainLabel,
  trainSPE,
  newData,
  newLabel,
  newSPE,
  trainObs,
  var.amnt
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mspSPEPlot_+3A_traindata">trainData</code></td>
<td>
<p>an xts data matrix containing the training observations</p>
</td></tr>
<tr><td><code id="mspSPEPlot_+3A_trainlabel">trainLabel</code></td>
<td>
<p>Class labels for the training data as a logical (two states
only) or finite numeric (two or more states) vector or matrix column (not from
a data frame) with length equal to the number of rows in &ldquo;data.&quot; For data with
only one state, this will be a vector of 1s.</p>
</td></tr>
<tr><td><code id="mspSPEPlot_+3A_trainspe">trainSPE</code></td>
<td>
<p>the SPE values corresponding to the
newLabel state calculated by mspTrain using the full training data with
all variables included</p>
</td></tr>
<tr><td><code id="mspSPEPlot_+3A_newdata">newData</code></td>
<td>
<p>an xts data matrix containing the new observation</p>
</td></tr>
<tr><td><code id="mspSPEPlot_+3A_newlabel">newLabel</code></td>
<td>
<p>the class label for the new observation</p>
</td></tr>
<tr><td><code id="mspSPEPlot_+3A_newspe">newSPE</code></td>
<td>
<p>the SPE value returned by mspMonitor using
the full new observation with all variables included</p>
</td></tr>
<tr><td><code id="mspSPEPlot_+3A_trainobs">trainObs</code></td>
<td>
<p>the number of observations upon which to train the algorithm.
This will be split based on class information by a priori class membership
proportions.</p>
</td></tr>
<tr><td><code id="mspSPEPlot_+3A_var.amnt">var.amnt</code></td>
<td>
<p>the energy proportion to preserve in the projection, which
dictates the number of principal components to keep</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Create some data
dataA1 &lt;- mspProcessData(faults = "B1")
traindataA1 &lt;- dataA1[1:8567,]

# Train on the data that should be in control
trainResults &lt;- mspTrain(traindataA1[,-1], traindataA1[,1], trainObs = 4320)


# Lag an out of control observation
testdataA1 &lt;- dataA1[8567:8568,-1]
testdataA1 &lt;- lag.xts(testdataA1,0:1)
testdataA1 &lt;- testdataA1[-1,]
testdataA1 &lt;- cbind(dataA1[8568,1],testdataA1)

# Monitor this observation
monitorResults &lt;- mspMonitor(observations = testdataA1[,-1],
                             labelVector = testdataA1[,1],
                             trainingSummary = trainResults$TrainingSpecs)


tD &lt;- traindataA1[,-1]
tL &lt;- traindataA1[,1]
nD &lt;- testdataA1[,-1]
nL &lt;- testdataA1[,1]
tO &lt;- trainObs
vA &lt;- 0.95
nSPE &lt;- monitorResults$SPE
tSPE &lt;- trainResults$TrainingSpecs[[nL]]$SPE

mspSPEPlot(tD,tL,tSPE,nD,nL,nSPE,tO,vA)

## End(Not run)
</code></pre>

<hr>
<h2 id='mspSubset'>Multi-State Subsetting</h2><span id='topic+mspSubset'></span>

<h3>Description</h3>

<p>This function separates the data into k subsets, one for each
of the k states, containing the subset of the original variables that are of interest
for a given state.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mspSubset(
  data,
  labelVector = rep(1, nrow(data)),
  subsetMatrix = matrix(TRUE, nrow = length(unique(labelVector)), ncol = ncol(data))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mspSubset_+3A_data">data</code></td>
<td>
<p>An xts data matrix</p>
</td></tr>
<tr><td><code id="mspSubset_+3A_labelvector">labelVector</code></td>
<td>
<p>Class labels as a logical (two states only) or
finite numeric (two or more states) vector or matrix column (not
from a data frame) with length equal to the number of rows in &quot;data.&quot;
For data with only one state, this will be a vector of 1s.</p>
</td></tr>
<tr><td><code id="mspSubset_+3A_subsetmatrix">subsetMatrix</code></td>
<td>
<p>A matrix of logicals with number of rows equal to the number of
states and number of columns equal to the number of columns in data. The i,j entry in
the matrix indicates whether or not to monitor the jth variable in the
ith state.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is designed to be used in conjunction with <code><a href="#topic+mspTrain">mspTrain</a></code>
and to allow the user to monitor a different subset of the variables during each state.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>Class1Data --</code></td>
<td>
<p>an xts data matrix containing the subset of the state 1 data.</p>
</td></tr>
<tr><td><code>Class2Data --</code></td>
<td>
<p>an xts data matrix containing the subset of the state 2 data.</p>
</td></tr>
<tr><td><code>Class3Data --</code></td>
<td>
<p>an xts data matrix containing the subset of the state 3 data.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>nrml &lt;- mspProcessData(faults = "NOC")

sub1 &lt;- c(TRUE,TRUE,FALSE)
sub2 &lt;- c(TRUE,FALSE,TRUE)
sub3 &lt;- c(TRUE,FALSE,FALSE)
submatrix &lt;- t(matrix(c(sub1,sub2,sub3),nrow=3,ncol=3))

subsets &lt;- mspSubset(data = nrml[,-1],
labelVector = nrml[,1],
subsetMatrix = submatrix)
</code></pre>

<hr>
<h2 id='mspT2Plot'>T-Squared Contribution Plots</h2><span id='topic+mspT2Plot'></span>

<h3>Description</h3>

<p>Plots a variation of the Hotelling's T-squared statistic to
visualize the contribution of each variable to a fault.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mspT2Plot(
  trainData,
  trainLabel,
  trainT2,
  newData,
  newLabel,
  newT2,
  trainObs,
  var.amnt
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mspT2Plot_+3A_traindata">trainData</code></td>
<td>
<p>an xts data matrix containing the training observations</p>
</td></tr>
<tr><td><code id="mspT2Plot_+3A_trainlabel">trainLabel</code></td>
<td>
<p>Class labels for the training data as a logical (two states
only) or finite numeric (two or more states) vector or matrix column (not from
a data frame) with length equal to the number of rows in &ldquo;data.&quot; For data with
only one state, this will be a vector of 1s.</p>
</td></tr>
<tr><td><code id="mspT2Plot_+3A_traint2">trainT2</code></td>
<td>
<p>the Hotelling's T-squared values corresponding to the
newLabel state calculated by mspTrain using the full training data with
all variables included</p>
</td></tr>
<tr><td><code id="mspT2Plot_+3A_newdata">newData</code></td>
<td>
<p>an xts data matrix containing the new observation</p>
</td></tr>
<tr><td><code id="mspT2Plot_+3A_newlabel">newLabel</code></td>
<td>
<p>the class label for the new observation</p>
</td></tr>
<tr><td><code id="mspT2Plot_+3A_newt2">newT2</code></td>
<td>
<p>the Hotelling's T-squared value returned by mspMonitor using
the full new observation with all variables included</p>
</td></tr>
<tr><td><code id="mspT2Plot_+3A_trainobs">trainObs</code></td>
<td>
<p>the number of observations upon which to train the algorithm.
This will be split based on class information by a priori class membership
proportions.</p>
</td></tr>
<tr><td><code id="mspT2Plot_+3A_var.amnt">var.amnt</code></td>
<td>
<p>the energy proportion to preserve in the projection, which
dictates the number of principal components to keep</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Create some data
dataA1 &lt;- mspProcessData(faults = "B1")
traindataA1 &lt;- dataA1[1:8567,]

# Train on the data that should be in control
trainResults &lt;- mspTrain(traindataA1[,-1], traindataA1[,1], trainObs = 4320)


# Lag an out of control observation
testdataA1 &lt;- dataA1[8567:8568,-1]
testdataA1 &lt;- lag.xts(testdataA1,0:1)
testdataA1 &lt;- testdataA1[-1,]
testdataA1 &lt;- cbind(dataA1[8568,1],testdataA1)

# Monitor this observation
monitorResults &lt;- mspMonitor(observations = testdataA1[,-1],
                             labelVector = testdataA1[,1],
                             trainingSummary = trainResults$TrainingSpecs)


tD &lt;- traindataA1[,-1]
tL &lt;- traindataA1[,1]
nD &lt;- testdataA1[,-1]
nL &lt;- testdataA1[,1]
tO &lt;- 4320
vA &lt;- 0.95
nT2 &lt;- monitorResults$T2
tT2 &lt;- trainResults$TrainingSpecs[[nL]]$T2

mspT2Plot(tD,tL,tT2,nD,nL,nT2,tO,vA)

## End(Not run)
</code></pre>

<hr>
<h2 id='mspTrain'>Multi-State Adaptive-Dynamic Process Training</h2><span id='topic+mspTrain'></span>

<h3>Description</h3>

<p>This function performs Multi-State Adaptive-Dynamic PCA on a
data set with time-stamped observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mspTrain(
  data,
  labelVector,
  trainObs,
  updateFreq = ceiling(0.5 * trainObs),
  Dynamic = TRUE,
  lagsIncluded = c(0, 1),
  faultsToTriggerAlarm = 5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mspTrain_+3A_data">data</code></td>
<td>
<p>An xts data matrix</p>
</td></tr>
<tr><td><code id="mspTrain_+3A_labelvector">labelVector</code></td>
<td>
<p>Class labels as a logical (two states only) or finite
numeric (two or more states) vector or matrix column (not from data frame)
with length equal to the number of rows in &quot;data&quot;. For data with only one
state, this will be a vector of 1s.</p>
</td></tr>
<tr><td><code id="mspTrain_+3A_trainobs">trainObs</code></td>
<td>
<p>The number of observations upon which to train the algorithm.
This will be split based on class information by a priori class membership
proportion.</p>
</td></tr>
<tr><td><code id="mspTrain_+3A_updatefreq">updateFreq</code></td>
<td>
<p>The algorithm update frequency. Defaults to half as many
observations as the training frequency.</p>
</td></tr>
<tr><td><code id="mspTrain_+3A_dynamic">Dynamic</code></td>
<td>
<p>Specify if the PCA algorithm should include lagged variables.
Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="mspTrain_+3A_lagsincluded">lagsIncluded</code></td>
<td>
<p>A vector of lags to include. If Dynamic = TRUE, specify
which lags to include. Defaults to c(0, 1), signifying that the Dynamic
process observations will include current observations and observations
from one time step previous. See &quot;Details&quot; for more information.</p>
</td></tr>
<tr><td><code id="mspTrain_+3A_faultstotriggeralarm">faultsToTriggerAlarm</code></td>
<td>
<p>The number of sequential faults needed to trigger
an alarm. Defaults to 5.</p>
</td></tr>
<tr><td><code id="mspTrain_+3A_...">...</code></td>
<td>
<p>Lazy dots for additional internal arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is designed to identify and sort out sequences of
observations which fall outside normal operating conditions. We assume that
the process data are time-dependent in both seasonal and non-stationary
effects (which necessitate the Adaptive and Dynamic components,
respectively). We further assume that this data is drawn from a
multivariate process under multiple mutually exclusive states, implying
that the linear dimension reduction projection matrices may be different
for each state. Therefore, in summary, this function lags the features to
account for correlation between sequential observations, splits the data by
classes, and re-estimates projection matrices on a rolling window to
account for seasonality. Further, this function uses non-parametric density
estimation to calculate the 1 - alpha quantiles of the SPE and Hotelling's
T2 statistics from a set of training observations, then flags any
observation in the testing data set with process monitoring statistics
beyond these calculated critical values. Because of natural variability
inherent in all real data, we do not remove observations simply because
they are have been flagged as outside normal operating conditions. This
function records an alarm only for observations having five flags in a
row, as set by the default argument value of &quot;faultsToTriggerAlarm&quot;. These
alarm-positive observations are then removed from the data set and held in
a separate xts matrix for inspection.
</p>
<p>Concerning the lagsIncluded variable: the argument lagsIncluded = c(0,1)
will column concatenate the current data with the same data from one
discrete time step back. This will necessarily remove the first row of the
data matrix, as we will have NA values under the lagged features. The
argument lagsIncluded = 0:2 will column concatenate the current
observations with the observations from one step previous and the
observations from two steps previous, which will necessarily require the
removal of the first two rows of the data matrix. To include only certain
lags with the current data, specify lagsIncluded = c(0, lag_1, lag_2, ...,
lag_K). This induce NA values in the first max(lag_k) rows, for k = 1, ...,
K, and these rows will be removed from consideration. From the lag.xts()
function helpfile: &quot;The primary motivation for having methods specific to
xts was to make use of faster C-level code within xts. Additionally, it was
decided that lag's default behavior should match the common time-series
interpretation of that operator  specifically that a value at time t
should be the value at time t-1 for a positive lag. This is different
than lag.zoo() as well as lag.ts().&quot;
</p>
<p>Of note when considering performance: the example has 10080 rows on three
features alternating between three states, and trains on 20 percent of the
observations, while updating every 1008 (10 percent) observation. On a 2016
Macbook Pro with 16Gb of RAM, this example function call takes 15 second to
run. Increasing the update frequency will decrease computation time, but
may increase false alarm rates or decrease flagging accuracy. We recommend
that you set the update frequency based on the natural and physical designs
of your system. For example, if your system has a multi-state process which
switches across one of four states every two hours, then test the update
frequency at an eight or 12 hour level &mdash; enough observations to measure
two to three full cycles of the switching process. For observations
recorded every five minutes, try updateFreq = (60 / 5) * 8 = 96 or (60 / 5)
* 12 = 144.
</p>
<p>This user-facing function calls the processMonitor() function, and returns
the training arguments necessary to call the mspMonitor() and mspWarning()
functions.
</p>
<p>For more details, see Kazor et al (2016):
</p>
<p><a href="https://doi.org/10.1007/s00477-016-1246-2">doi:10.1007/s00477-016-1246-2</a>
</p>


<h3>Value</h3>

<p>A list with the following components: </p>

<dl>
<dt>FaultChecks &ndash; </dt><dd><p>an xts flagging matrix with the same number of rows
as &quot;data&quot;. This flag matrix has the following five columns: </p>

<dl>
<dt>SPE &ndash; </dt><dd><p>the SPE statistic value for each observation in &quot;data&quot;</p>
</dd>
<dt>SPE_Flag &ndash; </dt><dd><p>a vector of SPE indicators recording 0 if the test
statistic is less than or equal to the critical value passed through
from the threshold object</p>
</dd>
<dt>T2 &ndash; </dt><dd><p>the T2 statistic value for each observation in &quot;data&quot;</p>
</dd>
<dt>T2_Flag &ndash; </dt><dd><p>a vector of T2 fault indicators, defined like
SPE_Flag</p>
</dd>
<dt>Alarm &ndash; </dt><dd><p>a column indicating if there have been five flags in
a row for either the SPE or T2 monitoring statistics or both. Alarm
states are as follows: 0 = no alarm, 1 = Hotelling's T2 alarm,
2 = Squared Prediction Error alarm, and 3 = both alarms.</p>
</dd>
</dl>

</dd>
<dt>Non_Alarmed_Obs &ndash; </dt><dd><p>an xts data matrix of all the non-alarmed
observations</p>
</dd>
<dt>Alarms &ndash; </dt><dd><p>an xts data matrix of the features and specific alarms
for Alarmed observations with the alarm codes are listed above</p>
</dd>
<dt>TrainingSpecs &ndash; </dt><dd><p>a list of k lists, one for each class, with each
list containing the specific threshold object returned by the internal
threshold() function for that class. See the threshold() function's help
file for more details.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Calls: <code><a href="#topic+processMonitor">processMonitor</a></code>. Pipe flow: <code>mspTrain</code>
into <code><a href="#topic+mspMonitor">mspMonitor</a></code> into <code><a href="#topic+mspWarning">mspWarning</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: # cut down on R CMD check time

  nrml &lt;- mspProcessData(faults = "NOC")

  mspTrain(data = nrml[, -1],
         labelVector = nrml[, 1],
         trainObs = 4320)


## End(Not run)

</code></pre>

<hr>
<h2 id='mspWarning'>Process Alarms</h2><span id='topic+mspWarning'></span>

<h3>Description</h3>

<p>Trigger an alarm, if necessary, for incoming multivariate
process observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mspWarning(mspMonitor_object, faultsToTriggerAlarm = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mspWarning_+3A_mspmonitor_object">mspMonitor_object</code></td>
<td>
<p>An xts matrix returned by the mspMonitor() function</p>
</td></tr>
<tr><td><code id="mspWarning_+3A_faultstotriggeralarm">faultsToTriggerAlarm</code></td>
<td>
<p>Specifies how many sequential faults will cause
an alarm to trigger. Defaults to 5.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function and the mspMonitor() function are designed to be ran
via a scheduled task through Windows &quot;Task Scheduler&quot; or Macintosh OX
&quot;launchd&quot; application suites. The file flow is as follows: at each time
interval, run the mspMonitor() function on the matrix of daily observations
to add a flag status to the most recent incoming observation in the matrix,
and return this new xts matrix. Then, pass this updated daily observation
matrix to the mspWarning() function, which will check if the process has
recorded five or more sequential monitoring statistic flags in a row. Of
note, because these functions are expected to be repeatedly called in real
time, this function will only check for an alarm within the last row of the
xts matrix. To check multiple rows for an alarm state, please use the
mspTrain() function, which was designed to check multiple past
observations.
</p>
<p>This function requires an xts matrix returned by the mspMonitor() function.
</p>


<h3>Value</h3>

<p>An xts matrix of the same dimensions as mspMonitor_object, with a
recorded negative or positive and type-specific alarm status. Alarm codes
are: 0 = no alarm, 1 = Hotelling's T2 alarm, 2 = Squared Prediction Error
alarm, and 3 = both alarms.
</p>


<h3>See Also</h3>

<p>Pipe flow: <code><a href="#topic+mspTrain">mspTrain</a></code> into <code><a href="#topic+mspMonitor">mspMonitor</a></code>
into <code>mspWarning</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: # cut down on R CMD check time

  nrml &lt;- mspProcessData(faults = "NOC")
  n &lt;- nrow(nrml)

  # Calculate the training summary, but save five observations for monitoring.
  trainResults_ls &lt;- mspTrain(data = nrml[1:(n - 5), -1],
                              labelVector = nrml[1:(n - 5), 1],
                              trainObs = 4320)

  # While training, we included 1 lag (the default), so we will also lag the
  #   observations we will test.
  testObs &lt;- nrml[(n - 6):n, -1]
  testObs &lt;- xts:::lag.xts(testObs, 0:1)
  testObs &lt;- testObs[-1,]
  testObs &lt;- cbind(nrml[(n - 5):n, 1], testObs)

  # Run the monitoring function.
  dataAndFlags &lt;- mspMonitor(observations = testObs[, -1],
                             labelVector = testObs[, 1],
                             trainingSummary = trainResults_ls$TrainingSpecs)

  # Alarm check the last row of the matrix returned by the mspMonitor
  #   function
  mspWarning(dataAndFlags)


## End(Not run)

</code></pre>

<hr>
<h2 id='normal_switch_xts'>Process Data under Normal Conditions</h2><span id='topic+normal_switch_xts'></span>

<h3>Description</h3>

<p>Three-feature, three-state simulated process data under normal
operating conditions as example data for different included functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normal_switch_xts
</code></pre>


<h3>Format</h3>

<p>An xts data matrix with 10080 rows and four columns, corresponding to
one week worth of data recorded at a 1-minute interval, and four columns as
defined here:
</p>

<dl>
<dt>state &ndash; </dt><dd><p>the state indicator for the multivariate system, with three
levels</p>
</dd>
<dt>x : </dt><dd><p>x(t) = t + error</p>
</dd>
<dt>y : </dt><dd><p>y(t) = t ^ 2 - 3t + error</p>
</dd>
<dt>z : </dt><dd><p>z(t) = - t ^ 3 + 3t ^ 2 + error</p>
</dd>
</dl>

<p>where t is a 10080-entry vector of autocorrelated and non-stationary hidden
process realizations. The states alternate each hour and are defined as
follows:
</p>

<dl>
<dt>State1 &ndash; </dt><dd><p>As presented</p>
</dd>
<dt>State2 &ndash; </dt><dd><p>Rotated by (yaw = 0, pitch = 90, roll = 30) and scaled by
(1 * x, 0.5 * y , 2 * z).</p>
</dd>
<dt>State3 &ndash; </dt><dd><p>Rotated by (yaw = 90, pitch = 0, roll = -30) and scaled by
(0.25 * x, 0.1 * y , 0.75 * z).</p>
</dd>
</dl>

<p>See the vignette for more details.
</p>


<h3>Source</h3>

<p>Simulated in R.
</p>

<hr>
<h2 id='oneDay_clean'>Real Process Data for Testing</h2><span id='topic+oneDay_clean'></span>

<h3>Description</h3>

<p>Data from the SM-MBR Bioreactor system over 12 hours. This data
will be used for testing the mvMonitoring package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oneDay_clean
</code></pre>


<h3>Format</h3>

<p>An xts matrix of 75 rows and 35 features recorded over
2017-01-27 at 00:10 to 2017-01-27 at 12:30.
</p>


<h3>Source</h3>

<p>Kathryn Newhart
</p>

<hr>
<h2 id='pca'>PCA for Data Scatter Matrix</h2><span id='topic+pca'></span>

<h3>Description</h3>

<p>Calculate the principal component analysis for a data matrix,
and also find the squared prediction error (SPE) and Hotelling's T2 test
statistic values for each observation in this data matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pca(data, var.amnt = 0.9, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pca_+3A_data">data</code></td>
<td>
<p>A centred-and-scaled data matrix or xts matrix</p>
</td></tr>
<tr><td><code id="pca_+3A_var.amnt">var.amnt</code></td>
<td>
<p>The energy proportion to preserve in the projection, which
dictates the number of principal components to keep. Defaults to 0.90.</p>
</td></tr>
<tr><td><code id="pca_+3A_...">...</code></td>
<td>
<p>Lazy dots for additional internal arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes in a training data matrix, without the label
column, and the energy preservation proportion, which defaults to 95
percent per Kazor et al (2016). This proportion is the sum of the q largest
eigenvalues divided by the sum of all p eigenvalues, where q is the number
of columns of the p x q projection matrix P. This function then returns the
projection matrix P, a diagonal matrix of the reciprocal eigenvalues
(LambdaInv), a vector of the SPE test statistic values corresponding to the
rows of the data matrix, and a T2 test statistic vector similar to the SPE
vector.
</p>
<p>This internal function is called by faultFilter().
</p>


<h3>Value</h3>

<p>A list of class &quot;pca&quot; with the following:
</p>

<dl>
<dt>projectionMatrix &ndash; </dt><dd><p>the q eigenvectors corresponding to the q
largest eigenvalues as a p x q projection matrix</p>
</dd>
<dt>LambdaInv &ndash; </dt><dd><p>the diagonal matrix of inverse eigenvalues</p>
</dd>
<dt>SPE &ndash; </dt><dd><p>the vector of SPE test statistic values for each of the n
observations contained in &quot;data&quot;</p>
</dd>
<dt>T2 &ndash; </dt><dd><p>the vector of Hotelling's T2 test statistic for each of the
same n observations</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Called by: <code><a href="#topic+faultFilter">faultFilter</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nrml &lt;- mspProcessData(faults = "NOC")
scaledData &lt;- scale(nrml[,-1])
pca(scaledData)

</code></pre>

<hr>
<h2 id='processMonitor'>Adaptive Process Training</h2><span id='topic+processMonitor'></span>

<h3>Description</h3>

<p>Apply Adaptive-Dynamic PCA to state-specific data matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>processMonitor(
  data,
  trainObs,
  updateFreq = ceiling(0.5 * trainObs),
  faultsToTriggerAlarm = 5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="processMonitor_+3A_data">data</code></td>
<td>
<p>An xts data matrix</p>
</td></tr>
<tr><td><code id="processMonitor_+3A_trainobs">trainObs</code></td>
<td>
<p>The number of training observations to be used</p>
</td></tr>
<tr><td><code id="processMonitor_+3A_updatefreq">updateFreq</code></td>
<td>
<p>The number of non-flagged observations to collect before
the function updates. Defaults to half as many observations as the number
of training observations.</p>
</td></tr>
<tr><td><code id="processMonitor_+3A_faultstotriggeralarm">faultsToTriggerAlarm</code></td>
<td>
<p>The number of sequential faults needed to trigger
an alarm. Defaults to 5.</p>
</td></tr>
<tr><td><code id="processMonitor_+3A_...">...</code></td>
<td>
<p>Lazy dots for additional internal arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is the class-specific implementation of the Adaptive-
Dynamic PCA described in the details of the mspTrain() function. See
the mspTrain() function's help file for further details.
</p>
<p>This internal function is called by mspTrain(). This function calls the
faultFilter() function.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>

<dl>
<dt>FaultChecks &ndash; </dt><dd><p>a class-specific xts flagging matrix with the
same number of rows as &quot;data&quot;. This flag matrix has the following five
columns:
</p>

<dl>
<dt>SPE &ndash; </dt><dd><p>the SPE statistic value for each observation in
&quot;data&quot;</p>
</dd>
<dt>SPE_Flag &ndash; </dt><dd><p>a vector of SPE indicators recording 0 if the
test statistic is less than or equal to the critical value
passed through from the threshold object</p>
</dd>
<dt>T2 &ndash; </dt><dd><p>the T2 statistic value for each observation in
&quot;data&quot;</p>
</dd>
<dt>T2_Flag &ndash; </dt><dd><p>a vector of T2 fault indicators, defined like
SPE_Flag</p>
</dd>
<dt>Alarm &ndash; </dt><dd><p>a column indicating if there have been five flags
in a row for either the SPE or T2 monitoring statistics or both.
Alarm states are as follows: 0 = no alarm, 1 = Hotelling's T2
alarm, 2 = Squared Prediction Error alarm, and 3 = both alarms.</p>
</dd>
</dl>

</dd>
<dt>Non_Alarmed_Obs &ndash; </dt><dd><p>a class-specific xts data matrix of all the
non-alarmed observations (observations with alarm state equal to 0)</p>
</dd>
<dt>Alarms &ndash; </dt><dd><p>a class-specific xts data matrix of the features and
specific alarms of Alarmed observations, where the alarm codes are
listed above</p>
</dd>
<dt>trainSpecs &ndash; </dt><dd><p>a threshold object returned by the internal
threshold() function. See the threshold() function's help file for
more details.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Calls: <code><a href="#topic+faultFilter">faultFilter</a></code>. Called by: <code><a href="#topic+mspTrain">mspTrain</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nrml &lt;- mspProcessData(faults = "NOC")
data &lt;- nrml[nrml[,1] == 1]

processMonitor(data = data[,-1], trainObs = 672)

</code></pre>

<hr>
<h2 id='processNOCdata'>Simulate NOC Observations from a Single-State or Multi-State Process</h2><span id='topic+processNOCdata'></span>

<h3>Description</h3>

<p>This function generates data under normal operating conditions
from a single-state or multi-state process model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>processNOCdata(
  startTime = "2015-05-16 10:00:00 CST",
  period = 7 * 24 * 60,
  stateDuration = 60,
  increment = "min",
  multiState = TRUE,
  autocorellation = 0.75,
  tLower = 0.01,
  tUpper = 2,
  errVar = 0.01
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="processNOCdata_+3A_starttime">startTime</code></td>
<td>
<p>a POSIXct object specifying the day and time for the
starting observation.</p>
</td></tr>
<tr><td><code id="processNOCdata_+3A_period">period</code></td>
<td>
<p>The observation cycle length. Defaults to one week's worth of
minute-level observations (10,080 observations).</p>
</td></tr>
<tr><td><code id="processNOCdata_+3A_stateduration">stateDuration</code></td>
<td>
<p>The number of observations generated during a stay in
each state. Defaults to 60.</p>
</td></tr>
<tr><td><code id="processNOCdata_+3A_increment">increment</code></td>
<td>
<p>The time-sequence base increment. See &quot;Details&quot; of the
seq.POSIXt() function options. Defaults to &quot;min&quot; for minutes.</p>
</td></tr>
<tr><td><code id="processNOCdata_+3A_multistate">multiState</code></td>
<td>
<p>Should the observations be generated from a multi-state
process? Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="processNOCdata_+3A_autocorellation">autocorellation</code></td>
<td>
<p>The autocorrelation parameter. Must be less than 1 in
absolute value, or the process generated will be nonstationary. Defaults to
0.75 in accordance to Kazor et al (2016).</p>
</td></tr>
<tr><td><code id="processNOCdata_+3A_tlower">tLower</code></td>
<td>
<p>Lower bound of the latent $t$ variable. Defaults to 0.01.</p>
</td></tr>
<tr><td><code id="processNOCdata_+3A_tupper">tUpper</code></td>
<td>
<p>Upper bound of the latent $t$ variable. Defaults to 2.</p>
</td></tr>
<tr><td><code id="processNOCdata_+3A_errvar">errVar</code></td>
<td>
<p>Error variance of the normal white noise process on the feature
variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function randomly generates a non-stationary (sinusoidal) and
autocorrelated latent variable t with lower and upper bounds given by the
arguments &quot;tLower&quot; and &quot;tUpper&quot;, respectively, with autocorrelation
governed by the &quot;autocorrelation&quot; argument. Necessarily, this coefficient
must be less than 1 in absolute value, otherwise the latent variable will
be unbounded. Next, this function draws a realization of this random
variable t and calculates three functions of it, then jitters these
functions with a normal white noise variable (with variance set by
&quot;errVar&quot;). These three functions are: </p>

<dl>
<dt>x : </dt><dd><p>x(t) = t + error</p>
</dd>
<dt>y : </dt><dd><p>y(t) = t ^ 2 - 3t + error</p>
</dd>
<dt>z : </dt><dd><p>z(t) = -t ^ 3 + 3t ^ 2 + error</p>
</dd>
</dl>

<p>This function is called by the mspProcessData() function. See
?mspProcessData for more details.
</p>


<h3>Value</h3>

<p>An data frame with the following information: </p>

<dl>
<dt>dateTime &ndash; </dt><dd><p>A POSIXct column of times starting at the user-defined
'startTime' argument, length given by the 'period' argument, and spacing
given by the 'increment' argument. For example, if the starting value is
&quot;2016-01-10&quot;, period is 10080, and the incrementation is in minutes, then
this sequence will be one week's worth of observations recorded every
minute from midnight on the tenth of January.</p>
</dd>
<dt>state &ndash; </dt><dd><p>An integer column of all 1's (when the 'multiState'
argument is FALSE), or a column of the state values (1, 2 or 3).</p>
</dd>
<dt>x &ndash; </dt><dd><p>A double column of generated values for the first feature.</p>
</dd>
<dt>y &ndash; </dt><dd><p>A double column of generated values for the second feature.</p>
</dd>
<dt>z &ndash; </dt><dd><p>A double column of generated values for the third feature.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Called by: <code><a href="#topic+mspProcessData">mspProcessData</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>processNOCdata()
</code></pre>

<hr>
<h2 id='quantile.density'>Extract Quantiles from 'density' Objects</h2><span id='topic+quantile.density'></span>

<h3>Description</h3>

<p>Quantiles for objects of class <code>density</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'density'
quantile(x, probs = seq(0.25, 0.75, 0.25), names = TRUE, normalize = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile.density_+3A_x">x</code></td>
<td>
<p>a object of class <code>density</code> or a list of densities</p>
</td></tr>
<tr><td><code id="quantile.density_+3A_probs">probs</code></td>
<td>
<p>numeric vector of probabilities with values in [0,1]. Note that
elements very close to the boundaries return <code>Inf</code> or <code>-Inf</code></p>
</td></tr>
<tr><td><code id="quantile.density_+3A_names">names</code></td>
<td>
<p>logical; if <code>TRUE</code>, the result has a names attribute, resp.
a rownames and colnames attributes. Set to <code>FALSE</code> for speedup with
many probabilities</p>
</td></tr>
<tr><td><code id="quantile.density_+3A_normalize">normalize</code></td>
<td>
<p>logical; if <code>TRUE</code> then the values in <code>x$y</code> are
multiplied with a factor such that their integral is equal to one.</p>
</td></tr>
<tr><td><code id="quantile.density_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods (currently
unused)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a near-exact copy of the <code>quantile.density</code>
function from package BMS (<a href="https://CRAN.R-project.org/package=BMS">https://CRAN.R-project.org/package=BMS</a>).
In spring of 2022, CRAN informed us that the BMS has been orphaned, so we
copied the code (and corresponding documentation) we needed from it. See
<a href="https://doi.org/10.18637/jss.v068.i04">doi:10.18637/jss.v068.i04</a> for their paper.
</p>
<p>The function <code>quantile.density()</code> applies generically to the built-in
class <code>density</code> (as least for versions where there is no such method
in the pre-configured packages). Note that this function relies on
trapezoidal integration in order to compute the cumulative densities
necessary for the calculation of quantiles.
</p>


<h3>Value</h3>

<p>If x is of class <code>density</code> (or a list with exactly one element),
a vector with quantiles. If x is a list of densities, then the output is a
matrix of quantiles, with each matrix row corresponding to the respective
density.
</p>


<h3>Author(s)</h3>

<p>Stefan Zeugner, <a href="mailto:stefan.zeugner@ec.europa.eu">stefan.zeugner@ec.europa.eu</a>
</p>
<p>Martin Feldkircher, <a href="mailto:martin.feldkircher@da-vienna.ac.at">martin.feldkircher@da-vienna.ac.at</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  rNorm_dens &lt;- density(rnorm(100000))
  quantile(rNorm_dens)

</code></pre>

<hr>
<h2 id='rotate3D'>Three-Dimensional Rotation Matrix</h2><span id='topic+rotate3D'></span>

<h3>Description</h3>

<p>Render a 3-Dimensional projection matrix given positive or
negative degree changes in yaw, pitch, and / or roll.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotate3D(yaw, pitch, roll)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotate3D_+3A_yaw">yaw</code></td>
<td>
<p>z-axis change in degrees; look left (+) or right (-). Consider
this a rotation on the x-y plane.</p>
</td></tr>
<tr><td><code id="rotate3D_+3A_pitch">pitch</code></td>
<td>
<p>y-axis change in degrees; look up (-) or down (+). Consider this
a rotation on the x-z plane.</p>
</td></tr>
<tr><td><code id="rotate3D_+3A_roll">roll</code></td>
<td>
<p>x-axis change in degrees; this change appears as if you touch
head to shoulders: right roll (+) and left roll (-).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When plotting with the package scatterplot3d, the default
perspective is such that the pitch action appears as a roll while the roll
action appears as a pitch.
</p>
<p>This function is used only in data generation of the package vignette. This
function is called by rotateScale3D().
</p>


<h3>Value</h3>

<p>A 3 x 3 projection matrix corresponding to the degree changes entered.
</p>


<h3>See Also</h3>

<p>Called by: <code><a href="#topic+rotateScale3D">rotateScale3D</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rotate3D(yaw = -10, pitch = 0, roll = 15)

</code></pre>

<hr>
<h2 id='rotateScale3D'>Three-Dimensional Rotation and Scaling Matrix</h2><span id='topic+rotateScale3D'></span>

<h3>Description</h3>

<p>Render a 3-Dimensional projection matrix given positive or
negative degree changes in yaw, pitch, and / or roll and increment or
decrement feature scales.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotateScale3D(rot_angles = c(0, 0, 0), scale_factors = c(1, 1, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotateScale3D_+3A_rot_angles">rot_angles</code></td>
<td>
<p>a list or vector containing the rotation angles in the
order following: yaw, pitch, roll. Defaults to &lt;0,0,0&gt;.</p>
</td></tr>
<tr><td><code id="rotateScale3D_+3A_scale_factors">scale_factors</code></td>
<td>
<p>a list or vector containing the values by which to
multiply each dimension. Defaults to &lt;1,1,1&gt;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the help file of function rotate_3D() for a brief explanation of
how these angles behave in scatterplot3d functionality (from package
scatterplot3d).
</p>
<p>This function is used only in data generation in the package vignette
(version 1) and the dataStateSwitch() function within the mspProcessData()
function. This function calls rotate3D().
</p>


<h3>Value</h3>

<p>A 3 x 3 projection matrix corresponding to the degree and scale
changes entered.
</p>


<h3>See Also</h3>

<p>Calls: <code><a href="#topic+rotate3D">rotate3D</a></code>. Called by
<code><a href="#topic+dataStateSwitch">dataStateSwitch</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rotateScale3D(rot_angles = list(yaw = -10, pitch = 0, roll = 15),
              scale_factors = c(0.2, 1, 5))

</code></pre>

<hr>
<h2 id='tenDay_clean'>Real Process Data for Training</h2><span id='topic+tenDay_clean'></span>

<h3>Description</h3>

<p>Data from the SM-MBR Bioreactor system over ten days. This data
will be used for training the mvMonitoring package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tenDay_clean
</code></pre>


<h3>Format</h3>

<p>An xts matrix of 1,299 rows and 35 features recorded over
2017-01-17 at 00:10 to 2017-01-27 at 00:00.
</p>


<h3>Source</h3>

<p>Kathryn Newhart
</p>

<hr>
<h2 id='threshold'>Non-parametric Threshold Estimation</h2><span id='topic+threshold'></span>

<h3>Description</h3>

<p>Calculate the non-parametric critical value threshold estimates
for the SPE and T2 monitoring test statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>threshold(pca_object, alpha = 0.001, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="threshold_+3A_pca_object">pca_object</code></td>
<td>
<p>A list with class &quot;pca&quot; from the internal pca() function</p>
</td></tr>
<tr><td><code id="threshold_+3A_alpha">alpha</code></td>
<td>
<p>The upper 1 - alpha quantile of the SPE and T2 densities from
the training data passed to this function. Defaults to 0.001.</p>
</td></tr>
<tr><td><code id="threshold_+3A_...">...</code></td>
<td>
<p>Lazy dots for additional internal arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes in a pca object returned by the pca() function
and a threshold level defaulting to alpha = 0.1 percent of the
observations. This critical quantile is set this low to reduce false
alarms, as described in Kazor et al (2016). The function then returns a
calculated SPE threshold corresponding to the 1 - alpha critical value, a
similar T2 threshold, and the projection and Lambda Inverse (1 /
eigenvalues) matrices passed through from the pca() function call.
</p>
<p>This internal function is called by faultFilter().
</p>


<h3>Value</h3>

<p>A list with classes &quot;threshold&quot; and &quot;pca&quot; containing:
</p>

<dl>
<dt>SPE_threshold &ndash; </dt><dd><p>the 1 - alpha quantile of the estimated SPE
density</p>
</dd>
<dt>T2_threshold &ndash; </dt><dd><p>the 1 - alpha quantile of the estimated Hotelling's
T2 density</p>
</dd>
<dt>projectionMatrix &ndash; </dt><dd><p>a projection matrix from the data feature space
to the feature subspace which preserves some pre-specified proportion
of the energy of the data scatter matrix. This pre-specified energy
proportion is user supplied as the var.amnt argument in the pca()
function. See the pca() function's help file for more details.</p>
</dd>
<dt>LambdaInv &ndash; </dt><dd><p>a diagonal matrix of the reciprocal eigenvalues of the
data scatter matrix</p>
</dd>
<dt>T2 &ndash; </dt><dd><p>the vector of Hotelling's T2 test statistic values for each of the n
observations in &quot;data&quot;</p>
</dd>
<dt>SPE &ndash; </dt><dd><p>the vector of SPE test statistic values for each of the n
observations in &quot;data&quot;</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Called by: <code><a href="#topic+faultFilter">faultFilter</a></code>. This function uses a port of
the <code>quantile.density()</code> function from the now-orphaned BMS package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nrml &lt;- mspProcessData(faults = "NOC")
scaledData &lt;- scale(nrml[,-1])
pca_obj &lt;- pca(scaledData)
threshold(pca_object = pca_obj)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
