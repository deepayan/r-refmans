<!DOCTYPE html><html><head><title>Help for package lazyeval</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {lazyeval}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#all_dots'><p>Combine explicit and implicit dots.</p></a></li>
<li><a href='#as_name'><p>Coerce an object to a name or call.</p></a></li>
<li><a href='#as.lazy'><p>Convert an object to a lazy expression or lazy dots.</p></a></li>
<li><a href='#ast_'><p>Display a call (or expression) as a tree.</p></a></li>
<li><a href='#auto_name'><p>Automatically name all components of a lazy dots.</p></a></li>
<li><a href='#call_modify'><p>Modify the arguments of a call.</p></a></li>
<li><a href='#call_new'><p>Create a call by &quot;hand&quot;</p></a></li>
<li><a href='#common_env'><p>Find common environment in list of lazy objects.</p></a></li>
<li><a href='#expr_label'><p>Find the expression associated with an argument</p></a></li>
<li><a href='#f_capture'><p>Make a promise explicit by converting into a formula.</p></a></li>
<li><a href='#f_eval_rhs'><p>Evaluate a formula</p></a></li>
<li><a href='#f_interp'><p>Interpolate a formula</p></a></li>
<li><a href='#f_list'><p>Build a named list from the LHS of formulas</p></a></li>
<li><a href='#f_new'><p>Create a formula object by &quot;hand&quot;.</p></a></li>
<li><a href='#f_rhs'><p>Get/set formula components.</p></a></li>
<li><a href='#f_text'><p>Turn RHS of formula into a string/label.</p></a></li>
<li><a href='#f_unwrap'><p>Unwrap a formula</p></a></li>
<li><a href='#function_new'><p>Create a function by &quot;hand&quot;</p></a></li>
<li><a href='#interp'><p>Interpolate values into an expression.</p></a></li>
<li><a href='#is_formula'><p>Is object a formula?</p></a></li>
<li><a href='#is_lang'><p>Is an object a language object?</p></a></li>
<li><a href='#lazy_'><p>Capture expression for later lazy evaluation.</p></a></li>
<li><a href='#lazy_dots'><p>Capture ... (dots) for later lazy evaluation.</p></a></li>
<li><a href='#lazy_eval'><p>Evaluate a lazy expression.</p></a></li>
<li><a href='#make_call'><p>Make a call with <code>lazy_dots</code> as arguments.</p></a></li>
<li><a href='#missing_arg'><p>Generate a missing argument.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.2.2</td>
</tr>
<tr>
<td>Title:</td>
<td>Lazy (Non-Standard) Evaluation</td>
</tr>
<tr>
<td>Description:</td>
<td>An alternative approach to non-standard evaluation using
    formulas. Provides a full implementation of LISP style 'quasiquotation',
    making it easier to generate code with other code.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown (&ge; 0.2.65), testthat, covr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-03-15 14:18:01 UTC; lionel</td>
</tr>
<tr>
<td>Author:</td>
<td>Hadley Wickham [aut, cre],
  RStudio [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hadley Wickham &lt;hadley@rstudio.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-03-15 17:50:07 UTC</td>
</tr>
<tr>
<td>Built:</td>
<td>R 4.2.0; x86_64-pc-linux-gnu; 2021-10-13 11:59:53 UTC; unix</td>
</tr>
</table>
<hr>
<h2 id='all_dots'>Combine explicit and implicit dots.</h2><span id='topic+all_dots'></span>

<h3>Description</h3>

<p>Combine explicit and implicit dots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_dots(.dots, ..., all_named = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all_dots_+3A_.dots">.dots</code></td>
<td>
<p>A list of lazy objects</p>
</td></tr>
<tr><td><code id="all_dots_+3A_...">...</code></td>
<td>
<p>Individual lazy objects</p>
</td></tr>
<tr><td><code id="all_dots_+3A_all_named">all_named</code></td>
<td>
<p>If <code>TRUE</code>, uses <code><a href="lazyeval.html#topic+auto_name">auto_name</a></code> to ensure
every component has a name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="lazyeval.html#topic+lazy_dots">lazy_dots</a></code>
</p>

<hr>
<h2 id='as_name'>Coerce an object to a name or call.</h2><span id='topic+as_name'></span><span id='topic+as_call'></span>

<h3>Description</h3>

<p>These are a S3 generics with built-in methods for names, calls, formuals,
and strings. The distinction between a name and a call is particularly
important when coercing from a string. Coercing to a call will parse the
string, coercing to a name will create a (potentially) non-syntactic name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_name(x)

as_call(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_name_+3A_x">x</code></td>
<td>
<p>An object to coerce</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>as_name("x + y")
as_call("x + y")

as_call(~ f)
as_name(~ f())
</code></pre>

<hr>
<h2 id='as.lazy'>Convert an object to a lazy expression or lazy dots.</h2><span id='topic+as.lazy'></span><span id='topic+as.lazy_dots'></span>

<h3>Description</h3>

<p>Convert an object to a lazy expression or lazy dots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.lazy(x, env = baseenv())

as.lazy_dots(x, env)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.lazy_+3A_x">x</code></td>
<td>
<p>An R object. Current methods for <code>as.lazy()</code> convert formulas,
character vectors, calls and names. Methods for <code>as.lazy_dots()</code>
convert lists and character vectors (by calling <code><a href="base.html#topic+lapply">lapply</a>()</code>
with <code>as.lazy()</code>.)</p>
</td></tr>
<tr><td><code id="as.lazy_+3A_env">env</code></td>
<td>
<p>Environment to use for objects that don't already have
associated environment.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>as.lazy(~ x + 1)
as.lazy(quote(x + 1), globalenv())
as.lazy("x + 1", globalenv())

as.lazy_dots(list(~x, y = ~z + 1))
as.lazy_dots(c("a", "b", "c"), globalenv())
as.lazy_dots(~x)
as.lazy_dots(quote(x), globalenv())
as.lazy_dots(quote(f()), globalenv())
as.lazy_dots(lazy(x))
</code></pre>

<hr>
<h2 id='ast_'>Display a call (or expression) as a tree.</h2><span id='topic+ast_'></span><span id='topic+ast'></span>

<h3>Description</h3>

<p><code>ast_</code> takes a quoted expression; <code>ast</code> does the quoting
for you.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ast_(x, width = getOption("width"))

ast(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ast__+3A_x">x</code></td>
<td>
<p>Quoted call, list of calls, or expression to display.</p>
</td></tr>
<tr><td><code id="ast__+3A_width">width</code></td>
<td>
<p>Display width, defaults to current width as reported by
<code>getOption("width")</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>ast(f(x, 1, g(), h(i())))
ast(if (TRUE) 3 else 4)
ast(function(a = 1, b = 2) {a + b + 10})
ast(f(x)(y)(z))

ast_(quote(f(x, 1, g(), h(i()))))
ast_(quote(if (TRUE) 3 else 4))
ast_(expression(1, 2, 3))
</code></pre>

<hr>
<h2 id='auto_name'>Automatically name all components of a lazy dots.</h2><span id='topic+auto_name'></span>

<h3>Description</h3>

<p>Any components missing a name will automatically get a name added by
looking at the first <code>max_width</code> characters of the deparsed expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auto_name(x, max_width = 40)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="auto_name_+3A_x">x</code></td>
<td>
<p>A <code><a href="lazyeval.html#topic+lazy_dots">lazy_dots</a></code></p>
</td></tr>
<tr><td><code id="auto_name_+3A_max_width">max_width</code></td>
<td>
<p>Maximum number of characters to use</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- lazy_dots(1 + 2, mean(mpg))
auto_name(x)

auto_name(list(~f, quote(x)))
</code></pre>

<hr>
<h2 id='call_modify'>Modify the arguments of a call.</h2><span id='topic+call_modify'></span><span id='topic+call_standardise'></span>

<h3>Description</h3>

<p>Modify the arguments of a call.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>call_modify(call, new_args, env = parent.frame())

call_standardise(call, env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="call_modify_+3A_call">call</code></td>
<td>
<p>A call to modify. It is first standardised with
<code><a href="lazyeval.html#topic+call_standardise">call_standardise</a></code>.</p>
</td></tr>
<tr><td><code id="call_modify_+3A_new_args">new_args</code></td>
<td>
<p>A named list of expressions (constants, names or calls)
used to modify the call. Use <code>NULL</code> to remove arguments.</p>
</td></tr>
<tr><td><code id="call_modify_+3A_env">env</code></td>
<td>
<p>Environment in which to look up call value.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>call &lt;- quote(mean(x, na.rm = TRUE))
call_standardise(call)

# Modify an existing argument
call_modify(call, list(na.rm = FALSE))
call_modify(call, list(x = quote(y)))

# Remove an argument
call_modify(call, list(na.rm = NULL))

# Add a new argument
call_modify(call, list(trim = 0.1))

# Add an explicit missing argument
call_modify(call, list(na.rm = quote(expr = )))
</code></pre>

<hr>
<h2 id='call_new'>Create a call by &quot;hand&quot;</h2><span id='topic+call_new'></span>

<h3>Description</h3>

<p>Create a call by &quot;hand&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>call_new(f, ..., .args = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="call_new_+3A_f">f</code></td>
<td>
<p>Function to call. For <code>make_call</code>, either a string, a symbol
or a quoted call. For <code>do_call</code>, a bare function name or call.</p>
</td></tr>
<tr><td><code id="call_new_+3A_...">...</code>, <code id="call_new_+3A_.args">.args</code></td>
<td>
<p>Arguments to the call either in or out of a list</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># f can either be a string, a symbol or a call
call_new("f", a = 1)
call_new(quote(f), a = 1)
call_new(quote(f()), a = 1)

#' Can supply arguments individually or in a list
call_new(quote(f), a = 1, b = 2)
call_new(quote(f), .args = list(a = 1, b = 2))
</code></pre>

<hr>
<h2 id='common_env'>Find common environment in list of lazy objects.</h2><span id='topic+common_env'></span>

<h3>Description</h3>

<p>If no common environment is found, will return <code>baseenv()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>common_env(dots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="common_env_+3A_dots">dots</code></td>
<td>
<p>A list of lazy objects</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>common_env(lazy_dots(a, b, c))

f &lt;- function(x) ~x
common_env(list(f(1)))
common_env(list(f(1), f(2)))
</code></pre>

<hr>
<h2 id='expr_label'>Find the expression associated with an argument</h2><span id='topic+expr_label'></span><span id='topic+expr_text'></span><span id='topic+expr_find'></span><span id='topic+expr_env'></span>

<h3>Description</h3>

<p><code>expr_find()</code> finds the full expression; <code>expr_text()</code> turns the
expression into a single string; <code>expr_label()</code> formats it nicely for
use in messages. <code>expr_env()</code> finds the environment associated with
the expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expr_label(x)

expr_text(x, width = 60L, nlines = Inf)

expr_find(x)

expr_env(x, default_env)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expr_label_+3A_x">x</code></td>
<td>
<p>A promise (function argument)</p>
</td></tr>
<tr><td><code id="expr_label_+3A_width">width</code></td>
<td>
<p>Width of each line</p>
</td></tr>
<tr><td><code id="expr_label_+3A_nlines">nlines</code></td>
<td>
<p>Maximum number of lines to extract.</p>
</td></tr>
<tr><td><code id="expr_label_+3A_default_env">default_env</code></td>
<td>
<p>If supplied, <code>expr_env</code> will return this if the
promise has already been forced. Otherwise it will throw an error.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions never force promises, and will work even if a promise has
previously been forced.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Unlike substitute(), expr_find() finds the original expression
f &lt;- function(x) g(x)
g &lt;- function(y) h(y)
h &lt;- function(z) list(substitute(z), expr_find(z))

f(1 + 2 + 3)

expr_label(10)
# Names a quoted with ``
expr_label(x)
# Strings are encoded
expr_label("a\nb")
# Expressions are captured
expr_label(a + b + c)
# Long expressions are collapsed
expr_label(foo({
  1 + 2
  print(x)
}))
</code></pre>

<hr>
<h2 id='f_capture'>Make a promise explicit by converting into a formula.</h2><span id='topic+f_capture'></span><span id='topic+dots_capture'></span>

<h3>Description</h3>

<p>This should be used sparingly if you want to implement true non-standard
evaluation with 100% magic. I recommend avoiding this unless you have
strong reasons otherwise since requiring arguments to be formulas only
adds one extra character to the inputs, and otherwise makes life much much
simpler.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_capture(x)

dots_capture(..., .ignore_empty = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="f_capture_+3A_x">x</code>, <code id="f_capture_+3A_...">...</code></td>
<td>
<p>An unevaluated promises</p>
</td></tr>
<tr><td><code id="f_capture_+3A_.ignore_empty">.ignore_empty</code></td>
<td>
<p>If <code>TRUE</code>, empty arguments will be silently
dropped.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>f_capture</code> returns a formula; <code>dots_capture</code>
returns a list of formulas.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f_capture(a + b)
dots_capture(a + b, c + d, e + f)

# These functions will follow a chain of promises back to the
# original definition
f &lt;- function(x) g(x)
g &lt;- function(y) h(y)
h &lt;- function(z) f_capture(z)
f(a + b + c)
</code></pre>

<hr>
<h2 id='f_eval_rhs'>Evaluate a formula</h2><span id='topic+f_eval_rhs'></span><span id='topic+f_eval_lhs'></span><span id='topic+f_eval'></span><span id='topic+find_data'></span>

<h3>Description</h3>

<p><code>f_eval_rhs</code> evaluates the RHS of a formula and <code>f_eval_lhs</code>
evaluates the LHS. <code>f_eval</code> is a shortcut for <code>f_eval_rhs</code> since
that is what you most commonly need.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_eval_rhs(f, data = NULL)

f_eval_lhs(f, data = NULL)

f_eval(f, data = NULL)

find_data(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="f_eval_rhs_+3A_f">f</code></td>
<td>
<p>A formula. Any expressions wrapped in <code> uq() </code> will
will be &quot;unquoted&quot;, i.e. they will be evaluated, and the results inserted
back into the formula. See <code><a href="lazyeval.html#topic+f_interp">f_interp</a></code> for more details.</p>
</td></tr>
<tr><td><code id="f_eval_rhs_+3A_data">data</code></td>
<td>
<p>A list (or data frame). <code>find_data</code> is a generic used to
find the data associated with a given object. If you want to make
<code>f_eval</code> work for your own objects, you can define a method for this
generic.</p>
</td></tr>
<tr><td><code id="f_eval_rhs_+3A_x">x</code></td>
<td>
<p>An object for which you want to find associated data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>data</code> is specified, variables will be looked for first in this
object, and if not found in the environment of the formula.
</p>


<h3>Pronouns</h3>

<p>When used with <code>data</code>, <code>f_eval</code> provides two pronouns to make it
possible to be explicit about where you want values to come from:
<code>.env</code> and <code>.data</code>. These are thin wrappers around <code>.data</code>
and <code>.env</code> that throw errors if you try to access non-existent values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f_eval(~ 1 + 2 + 3)

# formulas automatically capture their enclosing environment
foo &lt;- function(x) {
  y &lt;- 10
  ~ x + y
}
f &lt;- foo(1)
f
f_eval(f)

# If you supply data, f_eval will look their first:
f_eval(~ cyl, mtcars)

# To avoid ambiguity, you can use .env and .data pronouns to be
# explicit:
cyl &lt;- 10
f_eval(~ .data$cyl, mtcars)
f_eval(~ .env$cyl, mtcars)

# Imagine you are computing the mean of a variable:
f_eval(~ mean(cyl), mtcars)
# How can you change the variable that's being computed?
# The easiest way is "unquote" with uq()
# See ?f_interp for more details
var &lt;- ~ cyl
f_eval(~ mean( uq(var) ), mtcars)
</code></pre>

<hr>
<h2 id='f_interp'>Interpolate a formula</h2><span id='topic+f_interp'></span><span id='topic+uq'></span><span id='topic+uqs'></span><span id='topic+uqf'></span>

<h3>Description</h3>

<p>Interpolation replaces sub-expressions of the form <code>uq(x)</code> with
the evaluated value of <code>x</code>, and inlines sub-expressions of
the form <code>uqs(x)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_interp(f, data = NULL)

uq(x, data = NULL)

uqf(x)

uqs(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="f_interp_+3A_f">f</code></td>
<td>
<p>A one-sided formula.</p>
</td></tr>
<tr><td><code id="f_interp_+3A_data">data</code></td>
<td>
<p>When called from inside <code>f_eval</code>, this is used to pass on
the data so that nested formulas are evaluated in the correct environment.</p>
</td></tr>
<tr><td><code id="f_interp_+3A_x">x</code></td>
<td>
<p>For <code>uq</code> and <code>uqf</code>, a formula. For <code>uqs</code>, a
a vector.</p>
</td></tr>
</table>


<h3>Theory</h3>

<p>Formally, <code>f_interp</code> is a quasiquote function, <code>uq()</code> is the
unquote operator, and <code>uqs()</code> is the unquote splice operator.
These terms have a rich history in LISP, and live on in modern languages
like <a href="Julia">http://docs.julialang.org/en/release-0.1/manual/metaprogramming/</a>
and <a href="Racket">https://docs.racket-lang.org/reference/quasiquote.html</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f_interp(x ~ 1 + uq(1 + 2 + 3) + 10)

# Use uqs() if you want to add multiple arguments to a function
# It must evaluate to a list
args &lt;- list(1:10, na.rm = TRUE)
f_interp(~ mean( uqs(args) ))

# You can combine the two
var &lt;- quote(xyz)
extra_args &lt;- list(trim = 0.9)
f_interp(~ mean( uq(var) , uqs(extra_args) ))

foo &lt;- function(n) {
  ~ 1 + uq(n)
}
f &lt;- foo(10)
f
f_interp(f)
</code></pre>

<hr>
<h2 id='f_list'>Build a named list from the LHS of formulas</h2><span id='topic+f_list'></span><span id='topic+as_f_list'></span>

<h3>Description</h3>

<p><code>f_list</code> makes a new list; <code>as_f_list</code> takes an existing list.
Both take the LHS of any two-sided formulas and evaluate it, replacing the
current name with the result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_list(...)

as_f_list(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="f_list_+3A_...">...</code></td>
<td>
<p>Named arguments.</p>
</td></tr>
<tr><td><code id="f_list_+3A_x">x</code></td>
<td>
<p>An existing list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f_list("y" ~ x)
f_list(a = "y" ~ a, ~ b, c = ~c)
</code></pre>

<hr>
<h2 id='f_new'>Create a formula object by &quot;hand&quot;.</h2><span id='topic+f_new'></span>

<h3>Description</h3>

<p>Create a formula object by &quot;hand&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_new(rhs, lhs = NULL, env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="f_new_+3A_lhs">lhs</code>, <code id="f_new_+3A_rhs">rhs</code></td>
<td>
<p>A call, name, or atomic vector.</p>
</td></tr>
<tr><td><code id="f_new_+3A_env">env</code></td>
<td>
<p>An environment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A formula object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f_new(quote(a))
f_new(quote(a), quote(b))
</code></pre>

<hr>
<h2 id='f_rhs'>Get/set formula components.</h2><span id='topic+f_rhs'></span><span id='topic+f_rhs+3C-'></span><span id='topic+f_lhs'></span><span id='topic+f_lhs+3C-'></span><span id='topic+f_env'></span><span id='topic+f_env+3C-'></span>

<h3>Description</h3>

<p><code>f_rhs</code> extracts the righthand side, <code>f_lhs</code> extracts the
lefthand side, and <code>f_env</code> extracts the environment. All functions
throw an error if <code>f</code> is not a formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_rhs(f)

f_rhs(x) &lt;- value

f_lhs(f)

f_lhs(x) &lt;- value

f_env(f)

f_env(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="f_rhs_+3A_f">f</code>, <code id="f_rhs_+3A_x">x</code></td>
<td>
<p>A formula</p>
</td></tr>
<tr><td><code id="f_rhs_+3A_value">value</code></td>
<td>
<p>The value to replace with.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>f_rhs</code> and <code>f_lhs</code> return language objects (i.e.
atomic vectors of length 1, a name, or a call). <code>f_env</code>
returns an environment.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f_rhs(~ 1 + 2 + 3)
f_rhs(~ x)
f_rhs(~ "A")
f_rhs(1 ~ 2)

f_lhs(~ y)
f_lhs(x ~ y)

f_env(~ x)
</code></pre>

<hr>
<h2 id='f_text'>Turn RHS of formula into a string/label.</h2><span id='topic+f_text'></span><span id='topic+f_label'></span>

<h3>Description</h3>

<p>Equivalent of <code><a href="lazyeval.html#topic+expr_text">expr_text</a>()</code> and <code><a href="lazyeval.html#topic+expr_label">expr_label</a>()</code> for
formulas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_text(x, width = 60L, nlines = Inf)

f_label(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="f_text_+3A_x">x</code></td>
<td>
<p>A formula.</p>
</td></tr>
<tr><td><code id="f_text_+3A_width">width</code></td>
<td>
<p>Width of each line</p>
</td></tr>
<tr><td><code id="f_text_+3A_nlines">nlines</code></td>
<td>
<p>Maximum number of lines to extract.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- ~ a + b + bc
f_text(f)
f_label(f)

# Names a quoted with ``
f_label(~ x)
# Strings are encoded
f_label(~ "a\nb")
# Long expressions are collapsed
f_label(~ foo({
  1 + 2
  print(x)
}))
</code></pre>

<hr>
<h2 id='f_unwrap'>Unwrap a formula</h2><span id='topic+f_unwrap'></span>

<h3>Description</h3>

<p>This interpolates values in the formula that are defined in its environment,
replacing the environment with its parent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_unwrap(f)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="f_unwrap_+3A_f">f</code></td>
<td>
<p>A formula to unwrap.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
f &lt;- ~ x + n
f_unwrap(f)
</code></pre>

<hr>
<h2 id='function_new'>Create a function by &quot;hand&quot;</h2><span id='topic+function_new'></span>

<h3>Description</h3>

<p>This constructs a new function given it's three components:
list of arguments, body code and parent environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>function_new(args, body, env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="function_new_+3A_args">args</code></td>
<td>
<p>A named list of default arguments.  Note that if you want
arguments that don't have defaults, you'll need to use the special function
<code><a href="base.html#topic+alist">alist</a></code>, e.g. <code>alist(a = , b = 1)</code></p>
</td></tr>
<tr><td><code id="function_new_+3A_body">body</code></td>
<td>
<p>A language object representing the code inside the function.
Usually this will be most easily generated with <code><a href="base.html#topic+quote">quote</a></code></p>
</td></tr>
<tr><td><code id="function_new_+3A_env">env</code></td>
<td>
<p>The parent environment of the function, defaults to the calling
environment of <code>make_function</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) x + 3
g &lt;- function_new(alist(x = ), quote(x + 3))

# The components of the functions are identical
identical(formals(f), formals(g))
identical(body(f), body(g))
identical(environment(f), environment(g))

# But the functions are not identical because f has src code reference
identical(f, g)

attr(f, "srcref") &lt;- NULL
# Now they are:
stopifnot(identical(f, g))
</code></pre>

<hr>
<h2 id='interp'>Interpolate values into an expression.</h2><span id='topic+interp'></span>

<h3>Description</h3>

<p>This is useful if you want to build an expression up from a mixture of
constants and variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interp(`_obj`, ..., .values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interp_+3A__obj">_obj</code></td>
<td>
<p>An object to modify: can be a call, name, formula,
<code><a href="lazyeval.html#topic+lazy">lazy</a></code>, or a string.</p>
</td></tr>
<tr><td><code id="interp_+3A_...">...</code>, <code id="interp_+3A_.values">.values</code></td>
<td>
<p>Either individual name-value pairs, or a list
(or environment) of values.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Interp works with formulas, lazy objects, quoted calls and strings
interp(~ x + y, x = 10)
interp(lazy(x + y), x = 10)
interp(quote(x + y), x = 10)
interp("x + y", x = 10)

# Use as.name if you have a character string that gives a
# variable name
interp(~ mean(var), var = as.name("mpg"))
# or supply the quoted name directly
interp(~ mean(var), var = quote(mpg))

# Or a function!
interp(~ f(a, b), f = as.name("+"))
# Remember every action in R is a function call:
# http://adv-r.had.co.nz/Functions.html#all-calls

# If you've built up a list of values through some other
# mechanism, use .values
interp(~ x + y, .values = list(x = 10))

# You can also interpolate variables defined in the current
# environment, but this is a little risky.
y &lt;- 10
interp(~ x + y, .values = environment())
</code></pre>

<hr>
<h2 id='is_formula'>Is object a formula?</h2><span id='topic+is_formula'></span>

<h3>Description</h3>

<p>Is object a formula?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_formula(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_formula_+3A_x">x</code></td>
<td>
<p>Object to test</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>is_formula(~ 10)
is_formula(10)
</code></pre>

<hr>
<h2 id='is_lang'>Is an object a language object?</h2><span id='topic+is_lang'></span><span id='topic+is_name'></span><span id='topic+is_call'></span><span id='topic+is_pairlist'></span><span id='topic+is_atomic'></span>

<h3>Description</h3>

<p>These helpers are consistent wrappers around their base R equivalents.
A language object is either an atomic vector (typically a scalar), a
name (aka a symbol), a call, or a pairlist (used for function arguments).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_lang(x)

is_name(x)

is_call(x)

is_pairlist(x)

is_atomic(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_lang_+3A_x">x</code></td>
<td>
<p>An object to test.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="lazyeval.html#topic+as_name">as_name</a>()</code> and <code><a href="lazyeval.html#topic+as_call">as_call</a>()</code> for coercion
functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>q1 &lt;- quote(1)
is_lang(q1)
is_atomic(q1)

q2 &lt;- quote(x)
is_lang(q2)
is_name(q2)

q3 &lt;- quote(x + 1)
is_lang(q3)
is_call(q3)
</code></pre>

<hr>
<h2 id='lazy_'>Capture expression for later lazy evaluation.</h2><span id='topic+lazy_'></span><span id='topic+lazy'></span>

<h3>Description</h3>

<p><code>lazy()</code> uses non-standard evaluation to turn promises into lazy
objects; <code>lazy_()</code> does standard evaluation and is suitable for
programming.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lazy_(expr, env)

lazy(expr, env = parent.frame(), .follow_symbols = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lazy__+3A_expr">expr</code></td>
<td>
<p>Expression to capture. For <code>lazy_</code> must be a name
or a call.</p>
</td></tr>
<tr><td><code id="lazy__+3A_env">env</code></td>
<td>
<p>Environment in which to evaluate expr.</p>
</td></tr>
<tr><td><code id="lazy__+3A_.follow_symbols">.follow_symbols</code></td>
<td>
<p>If <code>TRUE</code>, the default, follows promises across
function calls. See <code>vignette("chained-promises")</code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use <code>lazy()</code> like you'd use <code><a href="base.html#topic+substitute">substitute</a>()</code>
to capture an unevaluated promise. Compared to <code>substitute()</code> it
also captures the environment associated with the promise, so that you
can correctly replay it in the future.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lazy_(quote(a + x), globalenv())

# Lazy is designed to be used inside a function - you should
# give it the name of a function argument (a promise)
f &lt;- function(x = b - a) {
  lazy(x)
}
f()
f(a + b / c)

# Lazy also works when called from the global environment. This makes
# easy to play with interactively.
lazy(a + b / c)

# By default, lazy will climb all the way back to the initial promise
# This is handy if you have if you have nested functions:
g &lt;- function(y) f(y)
h &lt;- function(z) g(z)
f(a + b)
g(a + b)
h(a + b)

# To avoid this behavour, set .follow_symbols = FALSE
# See vignette("chained-promises") for details
</code></pre>

<hr>
<h2 id='lazy_dots'>Capture ... (dots) for later lazy evaluation.</h2><span id='topic+lazy_dots'></span>

<h3>Description</h3>

<p>Capture ... (dots) for later lazy evaluation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lazy_dots(..., .follow_symbols = FALSE, .ignore_empty = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lazy_dots_+3A_...">...</code></td>
<td>
<p>Dots from another function</p>
</td></tr>
<tr><td><code id="lazy_dots_+3A_.follow_symbols">.follow_symbols</code></td>
<td>
<p>If <code>TRUE</code>, the default, follows promises across
function calls. See <code>vignette("chained-promises")</code> for details.</p>
</td></tr>
<tr><td><code id="lazy_dots_+3A_.ignore_empty">.ignore_empty</code></td>
<td>
<p>If <code>TRUE</code>, empty arguments will be ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of <code><a href="lazyeval.html#topic+lazy">lazy</a></code> expressions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lazy_dots(x = 1)
lazy_dots(a, b, c * 4)

f &lt;- function(x = a + b, ...) {
  lazy_dots(x = x, y = a + b, ...)
}
f(z = a + b)
f(z = a + b, .follow_symbols = TRUE)

# .follow_symbols is off by default because it causes problems
# with lazy loaded objects
lazy_dots(letters)
lazy_dots(letters, .follow_symbols = TRUE)

# You can also modify a dots like a list. Anything on the RHS will
# be coerced to a lazy.
l &lt;- lazy_dots(x = 1)
l$y &lt;- quote(f)
l[c("y", "x")]
l["z"] &lt;- list(~g)

c(lazy_dots(x = 1), lazy_dots(f))
</code></pre>

<hr>
<h2 id='lazy_eval'>Evaluate a lazy expression.</h2><span id='topic+lazy_eval'></span>

<h3>Description</h3>

<p>Evaluate a lazy expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lazy_eval(x, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lazy_eval_+3A_x">x</code></td>
<td>
<p>A lazy object or a formula.</p>
</td></tr>
<tr><td><code id="lazy_eval_+3A_data">data</code></td>
<td>
<p>Option, a data frame or list in which to preferentially look
for variables before using the environment associated with the lazy
object.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) {
  z &lt;- 100
  ~ x + z
}
z &lt;- 10
lazy_eval(f(10))
lazy_eval(f(10), list(x = 100))
lazy_eval(f(10), list(x = 1, z = 1))

lazy_eval(lazy_dots(a = x, b = z), list(x = 10))
</code></pre>

<hr>
<h2 id='make_call'>Make a call with <code>lazy_dots</code> as arguments.</h2><span id='topic+make_call'></span>

<h3>Description</h3>

<p>In order to exactly replay the original call, the environment must be the
same for all of the dots. This function circumvents that a little,
falling back to the <code><a href="base.html#topic+baseenv">baseenv</a>()</code> if all environments aren't
the same.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_call(fun, args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_call_+3A_fun">fun</code></td>
<td>
<p>Function as symbol or quoted call.</p>
</td></tr>
<tr><td><code id="make_call_+3A_args">args</code></td>
<td>
<p>Arguments to function; must be a <code>lazy_dots</code> object,
or something <code><a href="lazyeval.html#topic+as.lazy_dots">as.lazy_dots</a>()</code> can coerce..</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list:
</p>
<table>
<tr><td><code>env</code></td>
<td>
<p>The common environment for all elements</p>
</td></tr>
<tr><td><code>expr</code></td>
<td>
<p>The expression</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>make_call(quote(f), lazy_dots(x = 1, 2))
make_call(quote(f), list(x = 1, y = ~x))
make_call(quote(f), ~x)

# If no known or no common environment, fails back to baseenv()
make_call(quote(f), quote(x))
</code></pre>

<hr>
<h2 id='missing_arg'>Generate a missing argument.</h2><span id='topic+missing_arg'></span>

<h3>Description</h3>

<p>Generate a missing argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>missing_arg()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>f_interp(~f(x = uq(missing_arg())))
f_interp(~f(x = uq(NULL)))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
