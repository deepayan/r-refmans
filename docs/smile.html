<!DOCTYPE html><html><head><title>Help for package smile</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {smile}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aggregate_aux'><p>Internal use only</p></a></li>
<li><a href='#AI'><p>Areal Interpolation</p></a></li>
<li><a href='#aux_cs'><p>Mean of a (Cubic spline) covariance function (Internal use)</p></a></li>
<li><a href='#aux_gauss'><p>Mean of a (Gaussian) covariance function (Internal use)</p></a></li>
<li><a href='#aux_gw'><p>Mean of a Generalized Wendland covariance function (Internal use)</p></a></li>
<li><a href='#aux_mat'><p>Internal use only</p></a></li>
<li><a href='#aux_matern'><p>Mean of a (Matern) covariance function (Internal use)</p></a></li>
<li><a href='#aux_pexp'><p>Mean of a (Powered Exponential) covariance function (Internal use)</p></a></li>
<li><a href='#aux_spher'><p>Mean of a (Spherical) covariance function (Internal use)</p></a></li>
<li><a href='#aux_tapmat'><p>Mean of a (Matern - Wendland-1 tapper) covariance function (Internal use)</p></a></li>
<li><a href='#comp_cs_cov'><p>Cubic spline covariance function for a polygons.</p></a></li>
<li><a href='#comp_gauss_cov'><p>Gaussian covariance function for a polygons.</p></a></li>
<li><a href='#comp_gw_cov'><p>Generalized Wendland covariance function for a polygons.</p></a></li>
<li><a href='#comp_mat_cov'><p>Matern covariance function for a polygons.</p></a></li>
<li><a href='#comp_pexp_cov'><p>Powered Exponential covariance function for a polygons.</p></a></li>
<li><a href='#comp_spher_cov'><p>Spherical covariance function for a polygons.</p></a></li>
<li><a href='#comp_tapmat_cov'><p>Wendland-1 covariance function for a polygons.</p></a></li>
<li><a href='#crossdist'><p>Pairwise distances between matrices</p></a></li>
<li><a href='#cs_cov'><p>Computing the Cubic spline covariance function for a single distance</p>
measure.</a></li>
<li><a href='#distmat'><p>Creatin a distance matrix</p></a></li>
<li><a href='#est_mle'><p>MLEs for fixed V.</p></a></li>
<li><a href='#find_phi'><p>Find phi parameter for the Exponential spatial auto-correlation</p>
function</a></li>
<li><a href='#fit_spm'><p>Fitting an underlying continuous process to areal data</p></a></li>
<li><a href='#gauss_cov'><p>Computing the Gaussian covariance function for a single distance</p>
measure.</a></li>
<li><a href='#goodness_of_fit'><p>Akaike's (and Bayesian) An Information Criterion for <code>spm_fit</code></p>
objects.</a></li>
<li><a href='#gw_cov'><p>Generalized Wendland covariance function for a given distance matrix.</p></a></li>
<li><a href='#liv_lsoa'><p>Liverpool Lower Super Output Area.</p></a></li>
<li><a href='#liv_msoa'><p>Liverpool Middle Super Output Area.</p></a></li>
<li><a href='#mat_cov'><p>Matern covariance function for a given distance matrix.</p></a></li>
<li><a href='#morans_i'><p>Calculates the (global) Moran's I</p></a></li>
<li><a href='#nyc_comd'><p>New York City community districts spatial geometries</p></a></li>
<li><a href='#nyc_surv'><p>New York City survey data.</p></a></li>
<li><a href='#pexp_cov'><p>Powered Exponential covariance function for a given distance matrix.</p></a></li>
<li><a href='#predict_spm'><p>Prediction over the same or a different set of regions (or points).</p></a></li>
<li><a href='#sf_to_spm'><p>single <code>sf</code> to <code>spm</code></p></a></li>
<li><a href='#singl_ll_nn_hess'><p>Evaluate log-lik</p></a></li>
<li><a href='#singl_log_lik'><p>Evaluate log-lik</p></a></li>
<li><a href='#singl_log_lik_nn'><p>Evaluate log-lik</p></a></li>
<li><a href='#singl_log_plik'><p>Evaluate log-lik</p></a></li>
<li><a href='#single_cs'><p>Cubic spline covariance function (scalar)</p></a></li>
<li><a href='#single_exp'><p>Exponential covariance function (scalar)</p></a></li>
<li><a href='#single_gauss'><p>Gaussian covariance function (scalar)</p></a></li>
<li><a href='#single_gw'><p>Matern Generalized Wendland (GW) covariance function with kappa = 0</p>
(scalar - generic)</a></li>
<li><a href='#single_gw0'><p>Matern Generalized Wendland (GW) covariance function with kappa = 0</p>
(scalar - generic)</a></li>
<li><a href='#single_gw1'><p>Matern Generalized Wendland (GW) covariance function with kappa = 1</p>
(scalar - generic)</a></li>
<li><a href='#single_gw2'><p>Matern Generalized Wendland (GW) covariance function with kappa = 2</p>
(scalar - generic)</a></li>
<li><a href='#single_gw3'><p>Matern Generalized Wendland (GW) covariance function with kappa = 3</p>
(scalar - generic)</a></li>
<li><a href='#single_matern'><p>Matern covariance function (scalar - generic)</p></a></li>
<li><a href='#single_matern3'><p>Matern covariance function (scalar - nu = 3/2)</p></a></li>
<li><a href='#single_matern5'><p>Matern covariance function (scalar - nu = 5/2)</p></a></li>
<li><a href='#single_pexp'><p>Powered Exponential covariance function (scalar)</p></a></li>
<li><a href='#single_spher'><p>Spherical covariance function (scalar)</p></a></li>
<li><a href='#single_tapmat'><p>Matern (tappered) covariance function (scalar - generic)</p></a></li>
<li><a href='#single_tapmat1'><p>Tappered Matern covariance function (scalar - nu = 1/2)</p></a></li>
<li><a href='#single_tapmat3'><p>Tappered Matern covariance function (scalar - nu = 3/2)</p></a></li>
<li><a href='#spher_cov'><p>Computing the Spherical covariance function for a single distance</p>
measure.</a></li>
<li><a href='#st_remove_holes'><p>Remove holes from a <code>sfc</code> POLYGON</p></a></li>
<li><a href='#summary_spm_fit'><p>Summarizing <code>spm_fit</code></p></a></li>
<li><a href='#tapmat_cov'><p>Tappered Matern covariance function for a given distance matrix.</p></a></li>
<li><a href='#transform.sf'><p>Transform method for <code>sf</code> objects</p></a></li>
<li><a href='#vdl'><p>Voronoi Data Linkage</p></a></li>
<li><a href='#vdl_var'><p>Voronoi Data Linkage - Single variable and variance</p></a></li>
<li><a href='#vor_build'><p>Voronoi Tesselation inside a polygon</p></a></li>
<li><a href='#weight_mat'><p>Building weight matrix <strong>W</strong> for Areal Interpolation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Spatial Misalignment: Interpolation, Linkage, and Estimation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.4.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-04-27</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions to estimate, predict and interpolate areal
        data. For estimation and prediction we assume areal data is an average
        of an underlying continuous spatial process as in Moraga et
        al. (2017) &lt;<a href="https://doi.org/10.1016%2Fj.spasta.2017.04.006">doi:10.1016/j.spasta.2017.04.006</a>&gt;, Johnson et al. (2020)
        &lt;<a href="https://doi.org/10.1186%2Fs12942-020-00200-w">doi:10.1186/s12942-020-00200-w</a>&gt;, and Wilson and Wakefield (2020)
        &lt;<a href="https://doi.org/10.1093%2Fbiostatistics%2Fkxy041">doi:10.1093/biostatistics/kxy041</a>&gt;. The interpolation methodology is
        (mostly) based on Goodchild and Lam (1980, ISSN:01652273).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++11, GDAL (&gt;= 2.0.1), GEOS (&gt;= 3.4.0), PROJ (&gt;=
4.8.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Imports:</td>
<td>numDeriv, Rcpp, sf, mvtnorm, stats, Matrix</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://lcgodoy.me/smile/">https://lcgodoy.me/smile/</a>, <a href="https://github.com/lcgodoy/smile/">https://github.com/lcgodoy/smile/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/lcgodoy/smile/issues/">https://github.com/lcgodoy/smile/issues/</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, ggplot2, graphics</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-04-27 22:19:50 UTC; lcgodoy</td>
</tr>
<tr>
<td>Author:</td>
<td>Lucas da Cunha Godoy
    <a href="https://orcid.org/0000-0003-4265-972X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Lucas da Cunha Godoy &lt;lucasdac.godoy@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-04-29 08:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='aggregate_aux'>Internal use only</h2><span id='topic+aggregate_aux'></span>

<h3>Description</h3>

<p>aggregate.sf taken from <code>sf</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggregate_aux(
  x,
  by,
  FUN,
  ...,
  do_union = TRUE,
  simplify = TRUE,
  join = st_intersects
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggregate_aux_+3A_x">x</code></td>
<td>
<p>internal use</p>
</td></tr>
<tr><td><code id="aggregate_aux_+3A_by">by</code></td>
<td>
<p>internal use</p>
</td></tr>
<tr><td><code id="aggregate_aux_+3A_fun">FUN</code></td>
<td>
<p>internal use</p>
</td></tr>
<tr><td><code id="aggregate_aux_+3A_...">...</code></td>
<td>
<p>internal use</p>
</td></tr>
<tr><td><code id="aggregate_aux_+3A_do_union">do_union</code></td>
<td>
<p>internal use</p>
</td></tr>
<tr><td><code id="aggregate_aux_+3A_simplify">simplify</code></td>
<td>
<p>internal use</p>
</td></tr>
<tr><td><code id="aggregate_aux_+3A_join">join</code></td>
<td>
<p>internal use</p>
</td></tr>
</table>

<hr>
<h2 id='AI'>Areal Interpolation</h2><span id='topic+AI'></span><span id='topic+ai'></span><span id='topic+ai_var'></span>

<h3>Description</h3>

<p>This function estimates variables observed at a &quot;source&quot; region
into a &quot;target&quot; region. &quot;Source&quot; and &quot;target&quot; regions represent two
different ways to divide a city, for example. For more details, see
<a href="https://lcgodoy.me/smile/articles/sai.html">https://lcgodoy.me/smile/articles/sai.html</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ai(source, target, vars)

ai_var(source, target, vars, vars_var, sc_vars = FALSE, var_method = "CS")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AI_+3A_source">source</code></td>
<td>
<p>a <code>sf</code> object - source spatial data.</p>
</td></tr>
<tr><td><code id="AI_+3A_target">target</code></td>
<td>
<p>a <code>sf</code> object - target spatial data.</p>
</td></tr>
<tr><td><code id="AI_+3A_vars">vars</code></td>
<td>
<p>a <code>character</code> representing the variables (observed at the
source) to be estimated at the target data.</p>
</td></tr>
<tr><td><code id="AI_+3A_vars_var">vars_var</code></td>
<td>
<p>a scalar of type <code>character</code> representing the name of
the variable in the source dataset that stores the variances of the
variable to be estimated at the target data.</p>
</td></tr>
<tr><td><code id="AI_+3A_sc_vars">sc_vars</code></td>
<td>
<p>boolean indicating whether <code>vars</code> should be scaled by its
observed variance (if available).</p>
</td></tr>
<tr><td><code id="AI_+3A_var_method">var_method</code></td>
<td>
<p>a <code>character</code> representing the method to approximate
the variance of the AI estimates. Possible values are &quot;CS&quot;
(Cauchy-Schwartz) or &quot;MI&quot; (Moran's I).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the target (of type <code>sf</code>) with estimates of the variables
observed at the source data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nyc_surv)
data(nyc_comd)

## creating variables that store the variance for each area
## this is done to exemplify the functionality of the package
nyc_surv &lt;- transform(nyc_surv,
                      my_var = moe / qnorm(p = .975))
nyc_surv &lt;- transform(nyc_surv, my_var = my_var * my_var)

## Not run: 
## areal interpolation
estimate_comd &lt;-
   ai(source = nyc_surv, target = nyc_comd,
      vars = "estimate")

## areal interpolation with uncertainty estimation
estimate_comd &lt;-
   ai_var(source = nyc_surv, target = nyc_comd,
          vars = "estimate", vars_var = "my_var",
          var_method = "MI")

## End(Not run)

</code></pre>

<hr>
<h2 id='aux_cs'>Mean of a (Cubic spline) covariance function (Internal use)</h2><span id='topic+aux_cs'></span>

<h3>Description</h3>

<p>This is an auxilliary function for internal use. It helps to
numerically integrate a covariance function evaluated at a grid of points
within a polyigon and speed-up the computations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aux_cs(dist, sigsq, phi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aux_cs_+3A_sigsq">sigsq</code></td>
<td>
<p>the <code class="reqn">\sigma^2</code> parameter from the Spherical covariance.
function.</p>
</td></tr>
<tr><td><code id="aux_cs_+3A_phi">phi</code></td>
<td>
<p>the <code class="reqn">\phi</code> parameter from the Spherical covariance function,
controls the range of the spatial dependence.</p>
</td></tr>
<tr><td><code id="aux_cs_+3A_dists">dists</code></td>
<td>
<p>a numeric matrix representing the distance between spatial
entities.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The mean of <code>spher_cov(dist, sigsq, phi)</code>.
</p>

<hr>
<h2 id='aux_gauss'>Mean of a (Gaussian) covariance function (Internal use)</h2><span id='topic+aux_gauss'></span>

<h3>Description</h3>

<p>This is an auxilliary function for internal use. It helps to
numerically integrate a covariance function evaluated at a grid of points
within a polyigon and speed-up the computations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aux_gauss(dist, sigsq, phi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aux_gauss_+3A_sigsq">sigsq</code></td>
<td>
<p>the <code class="reqn">\sigma^2</code> parameter from the Gaussian covariance
function.</p>
</td></tr>
<tr><td><code id="aux_gauss_+3A_phi">phi</code></td>
<td>
<p>the <code class="reqn">\phi</code> parameter from the Gaussian covariance function,
controls the range of the spatial dependence.</p>
</td></tr>
<tr><td><code id="aux_gauss_+3A_dists">dists</code></td>
<td>
<p>a numeric matrix representing the distance between spatial
entities.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The mean of <code>gauss_cov(dist, sigsq, phi)</code>.
</p>

<hr>
<h2 id='aux_gw'>Mean of a Generalized Wendland covariance function (Internal use)</h2><span id='topic+aux_gw'></span>

<h3>Description</h3>

<p>This is an auxilliary function for internal use. It helps to
numerically integrate a covariance function evaluated at a grid of points
within a polyigon and speed-up the computations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aux_gw(dist, sigsq, phi, kappa, mu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aux_gw_+3A_sigsq">sigsq</code></td>
<td>
<p>the <code class="reqn">\sigma^2</code> variance of the covariance function
function.</p>
</td></tr>
<tr><td><code id="aux_gw_+3A_phi">phi</code></td>
<td>
<p>the <code class="reqn">\phi</code> is the range parameter of the covariance function.</p>
</td></tr>
<tr><td><code id="aux_gw_+3A_kappa">kappa</code></td>
<td>
<p><code class="reqn">\kappa \in \{0, \ldots, 3 \}</code>.</p>
</td></tr>
<tr><td><code id="aux_gw_+3A_mu">mu</code></td>
<td>
<p><code class="reqn">\mu</code> controls the smoothness of the covariance function</p>
</td></tr>
<tr><td><code id="aux_gw_+3A_dists">dists</code></td>
<td>
<p>a numeric matrix representing the distance between spatial
entities.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The mean of <code>mat_cov(dist, sigsq, phi, kappa)</code>.
</p>

<hr>
<h2 id='aux_mat'>Internal use only</h2><span id='topic+aux_mat'></span><span id='topic+single_dists'></span><span id='topic+single_dists_tr'></span><span id='topic+pred_cdist'></span><span id='topic+get_grid_list'></span><span id='topic+dist_from_grids'></span><span id='topic+dist_from_grids_tr'></span><span id='topic+mult_dist_from_grids'></span>

<h3>Description</h3>

<p>Internal use only
</p>


<h3>Usage</h3>

<pre><code class='language-R'>single_dists(mat_list)

single_dists_tr(mat_list, tr_vec, tr_inp)

pred_cdist(mat_list, pred_mat)

get_grid_list(x_to_list, by)

dist_from_grids(y_grid, by)

dist_from_grids_tr(y_grid, by, tr_vec, tr_inp)

mult_dist_from_grids(y_grid, x_grid, by)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aux_mat_+3A_mat_list">mat_list</code></td>
<td>
<p>internal use</p>
</td></tr>
<tr><td><code id="aux_mat_+3A_tr_vec">tr_vec</code></td>
<td>
<p>index for distance truncation</p>
</td></tr>
<tr><td><code id="aux_mat_+3A_tr_inp">tr_inp</code></td>
<td>
<p>truncation input</p>
</td></tr>
<tr><td><code id="aux_mat_+3A_pred_mat">pred_mat</code></td>
<td>
<p>internal use</p>
</td></tr>
<tr><td><code id="aux_mat_+3A_x_to_list">x_to_list</code></td>
<td>
<p>internal use</p>
</td></tr>
<tr><td><code id="aux_mat_+3A_by">by</code></td>
<td>
<p>internal use</p>
</td></tr>
<tr><td><code id="aux_mat_+3A_y_grid">y_grid</code></td>
<td>
<p>internal use</p>
</td></tr>
<tr><td><code id="aux_mat_+3A_x_grid">x_grid</code></td>
<td>
<p>internal use</p>
</td></tr>
<tr><td><code id="aux_mat_+3A_mat_list1">mat_list1</code></td>
<td>
<p>internal use</p>
</td></tr>
<tr><td><code id="aux_mat_+3A_mat_list2">mat_list2</code></td>
<td>
<p>internal use</p>
</td></tr>
<tr><td><code id="aux_mat_+3A_x">x</code></td>
<td>
<p>internal use</p>
</td></tr>
<tr><td><code id="aux_mat_+3A_y">y</code></td>
<td>
<p>internal use</p>
</td></tr>
<tr><td><code id="aux_mat_+3A_return_single">return_single</code></td>
<td>
<p>internal use</p>
</td></tr>
</table>

<hr>
<h2 id='aux_matern'>Mean of a (Matern) covariance function (Internal use)</h2><span id='topic+aux_matern'></span>

<h3>Description</h3>

<p>This is an auxilliary function for internal use. It helps to
numerically integrate a covariance function evaluated at a grid of points
within a polyigon and speed-up the computations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aux_matern(dist, sigsq, phi, nu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aux_matern_+3A_sigsq">sigsq</code></td>
<td>
<p>the <code class="reqn">\sigma^2</code> parameter from the Matern covariance
function.</p>
</td></tr>
<tr><td><code id="aux_matern_+3A_phi">phi</code></td>
<td>
<p>the <code class="reqn">\phi</code> parameter from the Matern covariance function,
controls the range of the spatial dependence.</p>
</td></tr>
<tr><td><code id="aux_matern_+3A_nu">nu</code></td>
<td>
<p>the <code class="reqn">\nu</code> parameter from the Matern covariance function,
controls the differentiability of the process.</p>
</td></tr>
<tr><td><code id="aux_matern_+3A_dists">dists</code></td>
<td>
<p>a numeric matrix representing the distance between spatial
entities.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The mean of <code>mat_cov(dist, sigsq, phi, nu)</code>.
</p>

<hr>
<h2 id='aux_pexp'>Mean of a (Powered Exponential) covariance function (Internal use)</h2><span id='topic+aux_pexp'></span>

<h3>Description</h3>

<p>This is an auxilliary function for internal use. It helps to
numerically integrate a covariance function evaluated at a grid of points
within a polyigon and speed-up the computations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aux_pexp(dist, sigsq, phi, nu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aux_pexp_+3A_sigsq">sigsq</code></td>
<td>
<p>the <code class="reqn">\sigma^2</code> parameter from the Powered Exponential
covariance function.</p>
</td></tr>
<tr><td><code id="aux_pexp_+3A_phi">phi</code></td>
<td>
<p>the <code class="reqn">\phi</code> parameter from the Powered Exponential covariance
function, controls the range of the spatial dependence.</p>
</td></tr>
<tr><td><code id="aux_pexp_+3A_nu">nu</code></td>
<td>
<p>the <code class="reqn">\nu</code> parameter from the Powered Exponential
covariance function,
controls the differentiability of the process.</p>
</td></tr>
<tr><td><code id="aux_pexp_+3A_dists">dists</code></td>
<td>
<p>a numeric matrix representing the distance between spatial
entities.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The mean of <code>pexp_cov(dist, sigsq, phi, nu)</code>.
</p>

<hr>
<h2 id='aux_spher'>Mean of a (Spherical) covariance function (Internal use)</h2><span id='topic+aux_spher'></span>

<h3>Description</h3>

<p>This is an auxilliary function for internal use. It helps to
numerically integrate a covariance function evaluated at a grid of points
within a polyigon and speed-up the computations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aux_spher(dist, sigsq, phi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aux_spher_+3A_sigsq">sigsq</code></td>
<td>
<p>the <code class="reqn">\sigma^2</code> parameter from the Spherical covariance.
function.</p>
</td></tr>
<tr><td><code id="aux_spher_+3A_phi">phi</code></td>
<td>
<p>the <code class="reqn">\phi</code> parameter from the Spherical covariance function,
controls the range of the spatial dependence.</p>
</td></tr>
<tr><td><code id="aux_spher_+3A_dists">dists</code></td>
<td>
<p>a numeric matrix representing the distance between spatial
entities.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The mean of <code>spher_cov(dist, sigsq, phi)</code>.
</p>

<hr>
<h2 id='aux_tapmat'>Mean of a (Matern - Wendland-1 tapper) covariance function (Internal use)</h2><span id='topic+aux_tapmat'></span>

<h3>Description</h3>

<p>This is an auxilliary function for internal use. It helps to
numerically integrate a covariance function evaluated at a grid of points
within a polyigon and speed-up the computations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aux_tapmat(dist, sigsq, phi, nu, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aux_tapmat_+3A_sigsq">sigsq</code></td>
<td>
<p>the <code class="reqn">\sigma^2</code> parameter from the Matern covariance
function.</p>
</td></tr>
<tr><td><code id="aux_tapmat_+3A_phi">phi</code></td>
<td>
<p>the <code class="reqn">\phi</code> parameter from the Matern covariance function,</p>
</td></tr>
<tr><td><code id="aux_tapmat_+3A_dists">dists</code></td>
<td>
<p>a numeric matrix representing the distance between spatial
entities.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The mean of <code>mat_cov(dist, sigsq, phi, nu)</code>.
</p>

<hr>
<h2 id='comp_cs_cov'>Cubic spline covariance function for a polygons.</h2><span id='topic+comp_cs_cov'></span>

<h3>Description</h3>

<p>Computing the Spherical covariance function between polygons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comp_cs_cov(cross_dists, n, n2, sigsq, phi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comp_cs_cov_+3A_cross_dists">cross_dists</code></td>
<td>
<p>a <code>list</code> such that each position contains the cross
distances between points within different polygons.</p>
</td></tr>
<tr><td><code id="comp_cs_cov_+3A_n">n</code></td>
<td>
<p>an ingeger representing number of polygons (note that, this is
different than the size of the list <code>cross_dists</code></p>
</td></tr>
<tr><td><code id="comp_cs_cov_+3A_n2">n2</code></td>
<td>
<p>usually, equal to <code>n</code>, except when the function is being used
to calculate the &quot;cross&quot; covariance between two different partitions of
the same space.</p>
</td></tr>
<tr><td><code id="comp_cs_cov_+3A_sigsq">sigsq</code></td>
<td>
<p>the <code class="reqn">\sigma^2</code> parameter from the Spherical covariance
function.</p>
</td></tr>
<tr><td><code id="comp_cs_cov_+3A_phi">phi</code></td>
<td>
<p>the <code class="reqn">\phi</code> parameter from the Spherical covariance function,
controls the range of the spatial dependence.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The spherical covariance matrix associated with a set of
polygons.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+single_exp">single_exp</a></code>, <code><a href="#topic+single_matern">single_matern</a></code>,
<code><a href="#topic+mat_cov">mat_cov</a></code>
</p>

<hr>
<h2 id='comp_gauss_cov'>Gaussian covariance function for a polygons.</h2><span id='topic+comp_gauss_cov'></span>

<h3>Description</h3>

<p>Computing the Gaussian covariance function between polygons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comp_gauss_cov(cross_dists, n, n2, sigsq, phi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comp_gauss_cov_+3A_cross_dists">cross_dists</code></td>
<td>
<p>a <code>list</code> such that each position contains the cross
distances between points within different polygons.</p>
</td></tr>
<tr><td><code id="comp_gauss_cov_+3A_n">n</code></td>
<td>
<p>an ingeger representing number of polygons (note that, this is
different than the size of the list <code>cross_dists</code></p>
</td></tr>
<tr><td><code id="comp_gauss_cov_+3A_n2">n2</code></td>
<td>
<p>usually, equal to <code>n</code>, except when the function is being used
to calculate the &quot;cross&quot; covariance between two different partitions of
the same space.</p>
</td></tr>
<tr><td><code id="comp_gauss_cov_+3A_sigsq">sigsq</code></td>
<td>
<p>the <code class="reqn">\sigma^2</code> parameter from the Gaussian covariance
function.</p>
</td></tr>
<tr><td><code id="comp_gauss_cov_+3A_phi">phi</code></td>
<td>
<p>the <code class="reqn">\phi</code> parameter from the Gaussian covariance function,
controls the range of the spatial dependence.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The gaussian covariance matrix associated with a set of
polygons.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+single_exp">single_exp</a></code>, <code><a href="#topic+single_matern">single_matern</a></code>,
<code><a href="#topic+mat_cov">mat_cov</a></code>
</p>

<hr>
<h2 id='comp_gw_cov'>Generalized Wendland covariance function for a polygons.</h2><span id='topic+comp_gw_cov'></span>

<h3>Description</h3>

<p>Computing the Matern covariance function between polygons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comp_gw_cov(cross_dists, n, n2, sigsq, phi, kappa, mu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comp_gw_cov_+3A_cross_dists">cross_dists</code></td>
<td>
<p>a <code>list</code> such that each position contains the cross
distances between points within different polygons.</p>
</td></tr>
<tr><td><code id="comp_gw_cov_+3A_n">n</code></td>
<td>
<p>an ingeger representing number of polygons (note that, this is
different than the size of the list <code>cross_dists</code></p>
</td></tr>
<tr><td><code id="comp_gw_cov_+3A_n2">n2</code></td>
<td>
<p>usually, equal to <code>n</code>, except when the function is being used
to calculate the &quot;cross&quot; covariance between two different partitions of
the same space.</p>
</td></tr>
<tr><td><code id="comp_gw_cov_+3A_sigsq">sigsq</code></td>
<td>
<p>the <code class="reqn">\sigma^2</code> variance of the covariance function
function.</p>
</td></tr>
<tr><td><code id="comp_gw_cov_+3A_phi">phi</code></td>
<td>
<p>the <code class="reqn">\phi</code> is the range parameter of the covariance function.</p>
</td></tr>
<tr><td><code id="comp_gw_cov_+3A_kappa">kappa</code></td>
<td>
<p><code class="reqn">\kappa \in \{0, \ldots, 3 \}</code>.</p>
</td></tr>
<tr><td><code id="comp_gw_cov_+3A_mu">mu</code></td>
<td>
<p><code class="reqn">\mu</code> controls the smoothness of the covariance function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The wendland-1 covariance matrix associated with a set of polygons.
</p>

<hr>
<h2 id='comp_mat_cov'>Matern covariance function for a polygons.</h2><span id='topic+comp_mat_cov'></span>

<h3>Description</h3>

<p>Computing the Matern covariance function between polygons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comp_mat_cov(cross_dists, n, n2, sigsq, phi, nu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comp_mat_cov_+3A_cross_dists">cross_dists</code></td>
<td>
<p>a <code>list</code> such that each position contains the cross
distances between points within different polygons.</p>
</td></tr>
<tr><td><code id="comp_mat_cov_+3A_n">n</code></td>
<td>
<p>an ingeger representing number of polygons (note that, this is
different than the size of the list <code>cross_dists</code></p>
</td></tr>
<tr><td><code id="comp_mat_cov_+3A_n2">n2</code></td>
<td>
<p>usually, equal to <code>n</code>, except when the function is being used
to calculate the &quot;cross&quot; covariance between two different partitions of
the same space.</p>
</td></tr>
<tr><td><code id="comp_mat_cov_+3A_sigsq">sigsq</code></td>
<td>
<p>the <code class="reqn">\sigma^2</code> parameter from the Matern covariance
function.</p>
</td></tr>
<tr><td><code id="comp_mat_cov_+3A_phi">phi</code></td>
<td>
<p>the <code class="reqn">\phi</code> parameter from the Matern covariance function,
controls the range of the spatial dependence.</p>
</td></tr>
<tr><td><code id="comp_mat_cov_+3A_nu">nu</code></td>
<td>
<p>the <code class="reqn">\nu</code> parameter from the Matern covariance function,
controls the differentiability of the process. Note that, if we set
<code>nu = .5</code>, then the calculations are based on the exponential
covariance function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matern covariance matrix associated with a set of polygons.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+single_exp">single_exp</a></code>, <code><a href="#topic+single_matern">single_matern</a></code>,
<code><a href="#topic+mat_cov">mat_cov</a></code>
</p>

<hr>
<h2 id='comp_pexp_cov'>Powered Exponential covariance function for a polygons.</h2><span id='topic+comp_pexp_cov'></span>

<h3>Description</h3>

<p>Computing the Powered Exponential covariance function between
polygons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comp_pexp_cov(cross_dists, n, n2, sigsq, phi, nu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comp_pexp_cov_+3A_cross_dists">cross_dists</code></td>
<td>
<p>a <code>list</code> such that each position contains the cross
distances between points within different polygons.</p>
</td></tr>
<tr><td><code id="comp_pexp_cov_+3A_n">n</code></td>
<td>
<p>an ingeger representing number of polygons (note that, this is
different than the size of the list <code>cross_dists</code></p>
</td></tr>
<tr><td><code id="comp_pexp_cov_+3A_n2">n2</code></td>
<td>
<p>usually, equal to <code>n</code>, except when the function is being used
to calculate the &quot;cross&quot; covariance between two different partitions of
the same space.</p>
</td></tr>
<tr><td><code id="comp_pexp_cov_+3A_sigsq">sigsq</code></td>
<td>
<p>the <code class="reqn">\sigma^2</code> parameter from the Powered Exponential
covariance function.</p>
</td></tr>
<tr><td><code id="comp_pexp_cov_+3A_phi">phi</code></td>
<td>
<p>the <code class="reqn">\phi</code> parameter from the Powered Exponential covariance
function, controls the range of the spatial dependence.</p>
</td></tr>
<tr><td><code id="comp_pexp_cov_+3A_nu">nu</code></td>
<td>
<p>the <code class="reqn">\nu \in (0, 2]</code> parameter representing the &quot;power&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The powered exponential covariance matrix associated with a set of
polygons.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+single_exp">single_exp</a></code>, <code><a href="#topic+single_matern">single_matern</a></code>,
<code><a href="#topic+mat_cov">mat_cov</a></code>
</p>

<hr>
<h2 id='comp_spher_cov'>Spherical covariance function for a polygons.</h2><span id='topic+comp_spher_cov'></span>

<h3>Description</h3>

<p>Computing the Spherical covariance function between polygons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comp_spher_cov(cross_dists, n, n2, sigsq, phi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comp_spher_cov_+3A_cross_dists">cross_dists</code></td>
<td>
<p>a <code>list</code> such that each position contains the cross
distances between points within different polygons.</p>
</td></tr>
<tr><td><code id="comp_spher_cov_+3A_n">n</code></td>
<td>
<p>an ingeger representing number of polygons (note that, this is
different than the size of the list <code>cross_dists</code></p>
</td></tr>
<tr><td><code id="comp_spher_cov_+3A_n2">n2</code></td>
<td>
<p>usually, equal to <code>n</code>, except when the function is being used
to calculate the &quot;cross&quot; covariance between two different partitions of
the same space.</p>
</td></tr>
<tr><td><code id="comp_spher_cov_+3A_sigsq">sigsq</code></td>
<td>
<p>the <code class="reqn">\sigma^2</code> parameter from the Spherical covariance
function.</p>
</td></tr>
<tr><td><code id="comp_spher_cov_+3A_phi">phi</code></td>
<td>
<p>the <code class="reqn">\phi</code> parameter from the Spherical covariance function,
controls the range of the spatial dependence.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The spherical covariance matrix associated with a set of
polygons.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+single_exp">single_exp</a></code>, <code><a href="#topic+single_matern">single_matern</a></code>,
<code><a href="#topic+mat_cov">mat_cov</a></code>
</p>

<hr>
<h2 id='comp_tapmat_cov'>Wendland-1 covariance function for a polygons.</h2><span id='topic+comp_tapmat_cov'></span>

<h3>Description</h3>

<p>Computing the Matern covariance function between polygons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comp_tapmat_cov(cross_dists, n, n2, sigsq, phi, nu, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comp_tapmat_cov_+3A_cross_dists">cross_dists</code></td>
<td>
<p>a <code>list</code> such that each position contains the cross
distances between points within different polygons.</p>
</td></tr>
<tr><td><code id="comp_tapmat_cov_+3A_n">n</code></td>
<td>
<p>an ingeger representing number of polygons (note that, this is
different than the size of the list <code>cross_dists</code></p>
</td></tr>
<tr><td><code id="comp_tapmat_cov_+3A_n2">n2</code></td>
<td>
<p>usually, equal to <code>n</code>, except when the function is being used
to calculate the &quot;cross&quot; covariance between two different partitions of
the same space.</p>
</td></tr>
<tr><td><code id="comp_tapmat_cov_+3A_sigsq">sigsq</code></td>
<td>
<p>the <code class="reqn">\sigma^2</code> parameter from the Matern covariance
function.</p>
</td></tr>
<tr><td><code id="comp_tapmat_cov_+3A_phi">phi</code></td>
<td>
<p>the <code class="reqn">\phi</code> parameter from the Matern covariance function</p>
</td></tr>
<tr><td><code id="comp_tapmat_cov_+3A_nu">nu</code></td>
<td>
<p>the smoothness parameter <code class="reqn">\nu</code> parameter from the Matern
covariance function</p>
</td></tr>
<tr><td><code id="comp_tapmat_cov_+3A_theta">theta</code></td>
<td>
<p>the taper distance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The wendland-1 covariance matrix associated with a set of polygons.
</p>

<hr>
<h2 id='crossdist'>Pairwise distances between matrices</h2><span id='topic+crossdist'></span>

<h3>Description</h3>

<p>Internal use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crossdist(m1, m2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crossdist_+3A_m1">m1</code></td>
<td>
<p>a matrix representing a grid of points within a polygon.</p>
</td></tr>
<tr><td><code id="crossdist_+3A_m2">m2</code></td>
<td>
<p>a matrix representing a grid of points within a polygon.</p>
</td></tr>
</table>

<hr>
<h2 id='cs_cov'>Computing the Cubic spline covariance function for a single distance
measure.</h2><span id='topic+cs_cov'></span>

<h3>Description</h3>

<p>Computing the Cubic spline covariance function for a single distance
measure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cs_cov(dists, sigsq, phi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cs_cov_+3A_dists">dists</code></td>
<td>
<p>a numeric matrix representing the distance between spatial
entities.</p>
</td></tr>
<tr><td><code id="cs_cov_+3A_sigsq">sigsq</code></td>
<td>
<p>the <code class="reqn">\sigma^2</code> parameter from the Spherical covariance.
function.</p>
</td></tr>
<tr><td><code id="cs_cov_+3A_phi">phi</code></td>
<td>
<p>the <code class="reqn">\phi</code> parameter from the Spherical covariance function,
controls the range of the spatial dependence.
'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Spherical covariance function (for a stationary and
isotropic process) associated with the provided distances (<code>dists</code>)
and the given set of parameters.
</p>

<hr>
<h2 id='distmat'>Creatin a distance matrix</h2><span id='topic+distmat'></span>

<h3>Description</h3>

<p>Internal use. For now it only supports euclidean distance. (May
import parallelDist in the future).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distmat(my_mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distmat_+3A_my_mat">my_mat</code></td>
<td>
<p>a matrix representing a grid of points.</p>
</td></tr>
</table>

<hr>
<h2 id='est_mle'>MLEs for fixed V.</h2><span id='topic+est_mle'></span>

<h3>Description</h3>

<p>MLEs for fixed V.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est_mle(y, Vinv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="est_mle_+3A_y">y</code></td>
<td>
<p>response variable.</p>
</td></tr>
<tr><td><code id="est_mle_+3A_vinv">Vinv</code></td>
<td>
<p>inverse of <code class="reqn">V</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>internal use.
</p>

<hr>
<h2 id='find_phi'>Find phi parameter for the Exponential spatial auto-correlation
function</h2><span id='topic+find_phi'></span>

<h3>Description</h3>

<p>Function designed to find the phi paramter such that the
correlation between points wihtin a given distance <code>d</code> is at most a
given value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_phi(
  d,
  nu,
  kappa,
  mu2,
  family = "matern",
  range = c(1e-04, 1000),
  cut = 0.05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_phi_+3A_d">d</code></td>
<td>
<p>maximun distance for spatial dependence equal to <code>cut</code>.</p>
</td></tr>
<tr><td><code id="find_phi_+3A_nu">nu</code></td>
<td>
<p>smoothness parameter associated with the Matern cov. function.</p>
</td></tr>
<tr><td><code id="find_phi_+3A_kappa">kappa</code></td>
<td>
<p>one of the smoothness parameters associated with the Generalized
Wendland covariance function</p>
</td></tr>
<tr><td><code id="find_phi_+3A_mu2">mu2</code></td>
<td>
<p>one of the smoothness parameters associated with the Generalized
Wendland covariance function</p>
</td></tr>
<tr><td><code id="find_phi_+3A_family">family</code></td>
<td>
<p>covariance function family, the options are <code>c("matern",
"gw", "cs", "spher", "pexp", "gaussian")</code>.</p>
</td></tr>
<tr><td><code id="find_phi_+3A_range">range</code></td>
<td>
<p>Minimum and maximum distance to be considered. The default is
<code>range = c(1e-04, 1000)</code>.</p>
</td></tr>
<tr><td><code id="find_phi_+3A_cut">cut</code></td>
<td>
<p>desired spatial correlation at a distance <code>d</code>, the default is
<code>cut = .05</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>numeric</code> value indicating the range parameter such that the
spatial correlation between two points at distance <code>d</code> is
<code>cut</code>.
</p>

<hr>
<h2 id='fit_spm'>Fitting an underlying continuous process to areal data</h2><span id='topic+fit_spm'></span><span id='topic+fit_spm.spm'></span><span id='topic+fit_spm2'></span>

<h3>Description</h3>

<p>Fitting an underlying continuous process to areal data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_spm(x, ...)

## S3 method for class 'spm'
fit_spm(
  x,
  model,
  theta_st,
  nu = NULL,
  tr = NULL,
  kappa = 1,
  mu2 = 1.5,
  apply_exp = FALSE,
  opt_method = "Nelder-Mead",
  control_opt = list(),
  comp_hess = TRUE,
  ...
)

fit_spm2(
  x,
  model,
  nu,
  tr,
  kappa = 1,
  mu2 = 1.5,
  comp_hess = TRUE,
  phi_min,
  phi_max,
  nphi = 10
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_spm_+3A_x">x</code></td>
<td>
<p>an object of type <code>spm</code>. Note that, the dimension of
<code>theta_st</code> depends on the 2 factors. 1) the number of variables
being analyzed, and 2) if the input is a <code>spm</code> object.</p>
</td></tr>
<tr><td><code id="fit_spm_+3A_...">...</code></td>
<td>
<p>additionnal parameters, either passed to <code>optim</code>.</p>
</td></tr>
<tr><td><code id="fit_spm_+3A_model">model</code></td>
<td>
<p>a <code>character</code> scalar indicating the family of the
covariance function to be used. The options are <code>c("matern",
    "pexp", "gaussian", "spherical", "gw")</code>.</p>
</td></tr>
<tr><td><code id="fit_spm_+3A_theta_st">theta_st</code></td>
<td>
<p>a <code>numeric</code> (named) vector containing the initial
parameters.</p>
</td></tr>
<tr><td><code id="fit_spm_+3A_nu">nu</code></td>
<td>
<p>a <code>numeric</code> value indicating either the <code class="reqn">\nu</code>
paramater from the Matern covariance function (controlling the process
differentiability), or the &quot;pexp&quot; for the Powered Exponential family. If
the <code>model</code> chosen by the user is Matern and <code>nu</code> is not
informed, it is automatically set to .5. On the other hand, if the user
choses the Powered Exponential family and do not inform <code>nu</code>,
then it is set to 1. In both cases, the covariance function becomes the
so covalled exponential covariance function.</p>
</td></tr>
<tr><td><code id="fit_spm_+3A_tr">tr</code></td>
<td>
<p>tapper range</p>
</td></tr>
<tr><td><code id="fit_spm_+3A_kappa">kappa</code></td>
<td>
<p><code class="reqn">\kappa \in \{0, \ldots, 3 \}</code> parameter for the GW cov
function.</p>
</td></tr>
<tr><td><code id="fit_spm_+3A_mu2">mu2</code></td>
<td>
<p>the smoothness parameter <code class="reqn">\mu</code> for the GW function.</p>
</td></tr>
<tr><td><code id="fit_spm_+3A_apply_exp">apply_exp</code></td>
<td>
<p>a <code>logical</code> scalar indicating wheter the parameters
that cannot assume negative values should be exponentiate or not.</p>
</td></tr>
<tr><td><code id="fit_spm_+3A_opt_method">opt_method</code></td>
<td>
<p>a <code>character</code> scalar indicating the optimization
algorithm to be used. For details, see optim.</p>
</td></tr>
<tr><td><code id="fit_spm_+3A_control_opt">control_opt</code></td>
<td>
<p>a named <code>list</code> containing the control arguments for
the optimization algorithm to be used. For details, see optim.</p>
</td></tr>
<tr><td><code id="fit_spm_+3A_comp_hess">comp_hess</code></td>
<td>
<p>a <code>boolean</code> indicating whether the Hessian matrix
should be computed.</p>
</td></tr>
<tr><td><code id="fit_spm_+3A_phi_min">phi_min</code></td>
<td>
<p>a <code>numeric</code> scalar representing the minimum <code class="reqn">phi</code>
value to look for.</p>
</td></tr>
<tr><td><code id="fit_spm_+3A_phi_max">phi_max</code></td>
<td>
<p>a <code>numeric</code> scalar representing the maximum <code class="reqn">phi</code>
value to look for.</p>
</td></tr>
<tr><td><code id="fit_spm_+3A_nphi">nphi</code></td>
<td>
<p>a <code>numeric</code> scalar indicating the number of values to
compute a grid-search over <code class="reqn">phi</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the <code>optim</code> function optimization
algorithms to find the Maximum Likelihood estimators, and their standard
errors, from a model adapted from. The function allows the user to input
the control parameters from the optim function through the argument
<code>control_opt</code>, which is a named list. Additionally, the one can
input lower and upper boundaries for the optimization problem, as well
as the preferred optimization algorithm (as long as it is available for
<code>optim</code>). The preferred algorithm is selected by the argument
<code>opt_method</code>. In addition to the control of the optimization, the
user can select a covariance function among the following: Matern,
Exponential, Powered Exponential, Gaussian, and Spherical. The parameter
<code>apply_exp</code> is a <code>logical</code> scalar such that, if set to
<code>TRUE</code>, the <code class="reqn">\exp</code> function is applied to the nonnegative
parameters, allowing the optimization algorithm to search for all the
parameters over the real numbers.</p>
<pre>The model assumes \deqn{Y(\mathbf{s}) = \mu + S(\mathbf{s})} at the
point level.  Where \eqn{S ~ GP(0, \sigma^2 C(\lVert \mathbf{s} -
    \mathbf{s}_2 \rVert; \theta))}.  Further, the observed data is supposed
to be \eqn{Y(B) = \lvert B \rvert^{-1} \int_{B} Y(\mathbf{s}) \,
    \textrm{d} \mathbf{s}}.
</pre>


<h3>Value</h3>

<p>a <code>spm_fit</code> object containing the information about the
estimation of the model parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(liv_lsoa) ## loading the LSOA data

msoa_spm &lt;- sf_to_spm(sf_obj = liv_msoa, n_pts = 500,
                      type = "regular", by_polygon = FALSE,
                      poly_ids = "msoa11cd",
                      var_ids = "leb_est")
## fitting model
theta_st_msoa &lt;- c("phi" = 1) # initial value for the range parameter

fit_msoa &lt;-
   fit_spm(x = msoa_spm,
           theta_st = theta_st_msoa,
           model = "matern",
           nu = .5,
           apply_exp  = TRUE,
           opt_method = "L-BFGS-B",
           control    = list(maxit = 500))

AIC(fit_msoa)

summary_spm_fit(fit_msoa, sig = .05)

</code></pre>

<hr>
<h2 id='gauss_cov'>Computing the Gaussian covariance function for a single distance
measure.</h2><span id='topic+gauss_cov'></span>

<h3>Description</h3>

<p>Computing the Gaussian covariance function for a single distance
measure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gauss_cov(dists, sigsq, phi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gauss_cov_+3A_dists">dists</code></td>
<td>
<p>a numeric matrix representing the distance between spatial
entities.</p>
</td></tr>
<tr><td><code id="gauss_cov_+3A_sigsq">sigsq</code></td>
<td>
<p>the <code class="reqn">\sigma^2</code> parameter from the Gaussian covariance
function.</p>
</td></tr>
<tr><td><code id="gauss_cov_+3A_phi">phi</code></td>
<td>
<p>the <code class="reqn">\phi</code> parameter from the Gaussian covariance function,
controls the range of the spatial dependence.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Gaussian covariance function (for a stationary and
isotropic process) associated with the provided distances (<code>dists</code>)
and the given set of parameters.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+single_exp">single_exp</a></code>, <code><a href="#topic+single_matern">single_matern</a></code>
</p>

<hr>
<h2 id='goodness_of_fit'>Akaike's (and Bayesian) An Information Criterion for <code>spm_fit</code>
objects.</h2><span id='topic+goodness_of_fit'></span><span id='topic+AIC.spm_fit'></span><span id='topic+BIC.spm_fit'></span>

<h3>Description</h3>

<p>Akaike's (and Bayesian) An Information Criterion for <code>spm_fit</code>
objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spm_fit'
AIC(object, ..., k = 2)

## S3 method for class 'spm_fit'
BIC(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="goodness_of_fit_+3A_object">object</code></td>
<td>
<p>a <code>spm_fit</code> object.</p>
</td></tr>
<tr><td><code id="goodness_of_fit_+3A_...">...</code></td>
<td>
<p>optionally more fitted model objects.</p>
</td></tr>
<tr><td><code id="goodness_of_fit_+3A_k">k</code></td>
<td>
<p><code>numeric</code>, the <em>penalty</em> per parameter to be used; the default
'k = 2' is the classical AIC. (for compatibility with <code>stats::AIC</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>numeric</code> scalar corresponding to the goodness of fit
measure.
</p>

<hr>
<h2 id='gw_cov'>Generalized Wendland covariance function for a given distance matrix.</h2><span id='topic+gw_cov'></span>

<h3>Description</h3>

<p>Computing the Matern covariance function for a matrix of
distances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gw_cov(dists, sigsq, phi, kappa, mu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gw_cov_+3A_dists">dists</code></td>
<td>
<p>a numeric matrix representing the distance between spatial
entities.</p>
</td></tr>
<tr><td><code id="gw_cov_+3A_sigsq">sigsq</code></td>
<td>
<p>the <code class="reqn">\sigma^2</code> parameter from the Matern covariance
function.</p>
</td></tr>
<tr><td><code id="gw_cov_+3A_phi">phi</code></td>
<td>
<p><code class="reqn">\phi</code> is the range of the covariance function.</p>
</td></tr>
<tr><td><code id="gw_cov_+3A_kappa">kappa</code></td>
<td>
<p><code class="reqn">\kappa \in \{0, \ldots, 3 \}</code>.</p>
</td></tr>
<tr><td><code id="gw_cov_+3A_mu">mu</code></td>
<td>
<p><code class="reqn">\mu</code> controls the smoothness of the covariance function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The GW (isotropic) covariance function associated with the provided
distances (<code>dists</code>) and the given set of parameters.
</p>

<hr>
<h2 id='liv_lsoa'>Liverpool Lower Super Output Area.</h2><span id='topic+liv_lsoa'></span>

<h3>Description</h3>

<p>A dataset containing containing the LSOA's for Liverpool along
with estimates for Index of Multiple Deprivation. Data taken from
<a href="https://ij-healthgeographics.biomedcentral.com/articles/10.1186/s12942-020-00200-w">Johnson et al. 2020</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>liv_lsoa
</code></pre>


<h3>Format</h3>

<p>A <code>sf</code> data frame with 298 rows and 6 variables:
</p>

<dl>
<dt>lsoa11cd</dt><dd><p>LSOA code</p>
</dd>
<dt>lsoa11cd</dt><dd><p>LSOA name</p>
</dd> <dt>male</dt><dd><p>Male population</p>
</dd>
<dt>female</dt><dd><p>Female population</p>
</dd>
<dt>imdscore</dt><dd><p>Index of Multiple Deprivation</p>
</dd>
<dt>area</dt><dd><p>LMSOA area, in <code class="reqn">km^2</code></p>
</dd>
</dl>



<h3>Details</h3>

<p>The data was projected to EPSG 27700 and units changed to km
</p>


<h3>Source</h3>

<p><a href="https://ij-healthgeographics.biomedcentral.com/articles/10.1186/s12942-020-00200-w">https://ij-healthgeographics.biomedcentral.com/articles/10.1186/s12942-020-00200-w</a>
</p>

<hr>
<h2 id='liv_msoa'>Liverpool Middle Super Output Area.</h2><span id='topic+liv_msoa'></span>

<h3>Description</h3>

<p>A dataset containing containing the MSOA's for Liverpool along
with estimates for Life Expectancy at Birth. Data taken from
<a href="https://ij-healthgeographics.biomedcentral.com/articles/10.1186/s12942-020-00200-w">Johnson et al. 2020</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>liv_msoa
</code></pre>


<h3>Format</h3>

<p>A <code>sf</code> data frame with 61 rows and 4 variables:
</p>

<dl>
<dt>msoa11cd</dt><dd><p>MSOA code</p>
</dd> <dt>msoa11cd</dt><dd><p>MSOA name</p>
</dd>
<dt>lev_est</dt><dd><p>Estimated life expectancy at birth, in years</p>
</dd>
<dt>area</dt><dd><p>MSOA area, in <code class="reqn">km^2</code></p>
</dd>
</dl>



<h3>Details</h3>

<p>The data was projected to EPSG 27700 and units changed to km
</p>


<h3>Source</h3>

<p><a href="https://ij-healthgeographics.biomedcentral.com/articles/10.1186/s12942-020-00200-w">https://ij-healthgeographics.biomedcentral.com/articles/10.1186/s12942-020-00200-w</a>
</p>

<hr>
<h2 id='mat_cov'>Matern covariance function for a given distance matrix.</h2><span id='topic+mat_cov'></span>

<h3>Description</h3>

<p>Computing the Matern covariance function for a matrix of
distances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat_cov(dists, sigsq, phi, nu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mat_cov_+3A_dists">dists</code></td>
<td>
<p>a numeric matrix representing the distance between spatial
entities.</p>
</td></tr>
<tr><td><code id="mat_cov_+3A_sigsq">sigsq</code></td>
<td>
<p>the <code class="reqn">\sigma^2</code> parameter from the Matern covariance
function.</p>
</td></tr>
<tr><td><code id="mat_cov_+3A_phi">phi</code></td>
<td>
<p>the <code class="reqn">\phi</code> parameter from the Matern covariance function,
controls the range of the spatial dependence.</p>
</td></tr>
<tr><td><code id="mat_cov_+3A_nu">nu</code></td>
<td>
<p>the <code class="reqn">\nu</code> parameter from the Matern covariance function,
controls the differentiability of the process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matern covariance function (for a stationary and isotropic
process) associated with the provided distances (<code>dists</code>) and the
given set of parameters.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+single_exp">single_exp</a></code>, <code><a href="#topic+single_matern">single_matern</a></code>
</p>

<hr>
<h2 id='morans_i'>Calculates the (global) Moran's I</h2><span id='topic+morans_i'></span>

<h3>Description</h3>

<p>Calculates the (global) Moran's I
</p>


<h3>Usage</h3>

<pre><code class='language-R'>morans_i(sf_dt, variable)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="morans_i_+3A_sf_dt">sf_dt</code></td>
<td>
<p>a <code>sf</code> (with POLYGON <code>geometry</code>) dataset.</p>
</td></tr>
<tr><td><code id="morans_i_+3A_variable">variable</code></td>
<td>
<p>a <code>character</code> representing one of the variables from
<code>sf_dt</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>numeric</code> scalar.
</p>

<hr>
<h2 id='nyc_comd'>New York City community districts spatial geometries</h2><span id='topic+nyc_comd'></span>

<h3>Description</h3>

<p>A dataset containing containing the CD's for New York City.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nyc_comd
</code></pre>


<h3>Format</h3>

<p>A <code>sf</code> data frame with 71 rows and 3 variables:
</p>

<dl>
<dt>boro_cd</dt><dd><p>unique identifier</p>
</dd>
<dt>shape_area</dt><dd><p>Shape Area</p>
</dd>
<dt>shape_length</dt><dd><p>Shape Length</p>
</dd>
<dt>est</dt><dd><p>median income estimated using areal interpolation</p>
</dd>
<dt>se_est</dt><dd><p>standard error associated with the estimates</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data is project using EPSG 4326.
</p>

<hr>
<h2 id='nyc_surv'>New York City survey data.</h2><span id='topic+nyc_surv'></span>

<h3>Description</h3>

<p>A dataset containing containing the census tracts for New York
City along with estimates for median income and a margin of error for
this estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nyc_surv
</code></pre>


<h3>Format</h3>

<p>A <code>sf</code> data frame with 2128 rows and 5 variables:
</p>

<dl>
<dt>GEOID</dt><dd><p>unique identifier</p>
</dd>
<dt>NAME</dt><dd><p>census tract name</p>
</dd>
<dt>variable</dt><dd><p>variable estimated</p>
</dd>
<dt>estimate</dt><dd><p>median income estimate</p>
</dd>
<dt>moe</dt><dd><p>median income estimate margin of error</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data is project using EPSG 4326.
</p>

<hr>
<h2 id='pexp_cov'>Powered Exponential covariance function for a given distance matrix.</h2><span id='topic+pexp_cov'></span>

<h3>Description</h3>

<p>Computing the Matern covariance function for a matrix of
distances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pexp_cov(dists, sigsq, phi, nu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pexp_cov_+3A_dists">dists</code></td>
<td>
<p>a numeric matrix representing the distance between spatial
entities.</p>
</td></tr>
<tr><td><code id="pexp_cov_+3A_sigsq">sigsq</code></td>
<td>
<p>the <code class="reqn">\sigma^2</code> parameter from the Exponential covariance
function.</p>
</td></tr>
<tr><td><code id="pexp_cov_+3A_phi">phi</code></td>
<td>
<p>the <code class="reqn">\phi</code> parameter from the Exponential covariance function,
controls the range of the spatial dependence.</p>
</td></tr>
<tr><td><code id="pexp_cov_+3A_nu">nu</code></td>
<td>
<p>the <code class="reqn">\nu \in (0, 2]</code> parameter representing the &quot;power&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The powered exponential covariance function (for a stationary and
isotropic process) associated with the provided distances (<code>dists</code>)
and the given set of parameters.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+single_exp">single_exp</a></code>, <code><a href="#topic+single_matern">single_matern</a></code>
</p>

<hr>
<h2 id='predict_spm'>Prediction over the same or a different set of regions (or points).</h2><span id='topic+predict_spm'></span><span id='topic+predict_spm.spm_fit'></span><span id='topic+predict_spm.sf'></span>

<h3>Description</h3>

<p>Realizes predictions that can be useful when researchers are
interested in predict a variable observed in one political division of a
city (or state) on another division of the same region.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_spm(x, ...)

## S3 method for class 'spm_fit'
predict_spm(x, .aggregate = TRUE, ...)

## S3 method for class 'sf'
predict_spm(x, spm_obj, n_pts, type, outer_poly = NULL, id_var, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_spm_+3A_x">x</code></td>
<td>
<p>a <code>sf</code> object such that its geometris are either points or
polygons.</p>
</td></tr>
<tr><td><code id="predict_spm_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
<tr><td><code id="predict_spm_+3A_.aggregate">.aggregate</code></td>
<td>
<p><code>logical</code>. Should the predictions be aggregated? In
case the input is only a &quot;fit&quot; object, the aggregation is made over the
polygons on which the original data was observed. In case the input
<code>x</code> is composed by <code>sf POLYGONS</code>, the aggregation is made over
this new partition of the study region.</p>
</td></tr>
<tr><td><code id="predict_spm_+3A_spm_obj">spm_obj</code></td>
<td>
<p>an object of either class <code>spm_fit</code> or <code>mspm_fit</code></p>
</td></tr>
<tr><td><code id="predict_spm_+3A_n_pts">n_pts</code></td>
<td>
<p>a <code>numeric</code> scalar standing for number of points to form a
grid over the whole region to make the predictions</p>
</td></tr>
<tr><td><code id="predict_spm_+3A_type">type</code></td>
<td>
<p><code>character</code> type of grid to be generated. See
<code>st_sample</code> in the package <code>sf</code>.</p>
</td></tr>
<tr><td><code id="predict_spm_+3A_outer_poly">outer_poly</code></td>
<td>
<p>(object) <code>sf geometry</code> storing the &quot;outer map&quot; we
want to compute the predictions in.</p>
</td></tr>
<tr><td><code id="predict_spm_+3A_id_var">id_var</code></td>
<td>
<p>if <code>x</code> is a set of <code>POLYGONS</code> (areal data) instead
of a set of points, the <code>id_var</code> is the name (or index) of the
unique identifier associated to each polygon.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>list</code> of size 4 belonging to the class <code>spm_pred</code>. This
list contains the predicted values and the mean and covariance matrix
associated with the conditional distribution used to compute the
predictions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(liv_lsoa) ## loading the LSOA data
data(liv_msoa) ## loading the MSOA data

msoa_spm &lt;- sf_to_spm(sf_obj = liv_msoa, n_pts = 500,
                      type = "regular", by_polygon = FALSE,
                      poly_ids = "msoa11cd",
                      var_ids = "leb_est")
## fitting model
theta_st_msoa &lt;- c("phi" = 1) # initial value for the range parameter

fit_msoa &lt;-
   fit_spm(x = msoa_spm,
           theta_st = theta_st_msoa,
           model = "matern",
           nu = .5,
           apply_exp  = TRUE,
           opt_method = "L-BFGS-B",
           control    = list(maxit = 500))

pred_lsoa &lt;- predict_spm(x = liv_lsoa, spm_obj = fit_msoa, id_var = "lsoa11cd")

</code></pre>

<hr>
<h2 id='sf_to_spm'>single <code>sf</code> to <code>spm</code></h2><span id='topic+sf_to_spm'></span><span id='topic+single_sf_to_spm'></span>

<h3>Description</h3>

<p>Transforming a <code>sf</code> into a <code>spm</code> object (Internal use)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>single_sf_to_spm(
  sf_obj,
  n_pts,
  type = "regular",
  by_polygon = FALSE,
  poly_ids = NULL,
  var_ids = NULL,
  trunc_d = NULL
)

sf_to_spm(
  sf_obj,
  n_pts,
  type = "regular",
  by_polygon = FALSE,
  poly_ids = NULL,
  var_ids = NULL,
  trunc_d = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sf_to_spm_+3A_sf_obj">sf_obj</code></td>
<td>
<p>a <code>sf</code> object s.t. its geometries are polygons.</p>
</td></tr>
<tr><td><code id="sf_to_spm_+3A_n_pts">n_pts</code></td>
<td>
<p>a <code>numeric</code> scalar representing the number of points to
create a grid in the study region on which the polygons in <code>sf_obj</code>
is observed. Alternatively, it can be a vector of the same length as
<code>nrow(sf_obj)</code>. In this case, it generates the given number of
points for each polygon in <code>sf_obj</code>.</p>
</td></tr>
<tr><td><code id="sf_to_spm_+3A_type">type</code></td>
<td>
<p>a <code>character</code> indicating the type of grid to be
generated. The options are <code>c("random", "regular",
    "hexagonal")</code>. For more details, see <code>st_sample</code> in the <code>sf</code>
package.</p>
</td></tr>
<tr><td><code id="sf_to_spm_+3A_by_polygon">by_polygon</code></td>
<td>
<p>a <code>logical</code> indicating wheter we should generate
<code>n_pts</code> by polygon or for the <code>n_pts</code> for the whole study
region.</p>
</td></tr>
<tr><td><code id="sf_to_spm_+3A_poly_ids">poly_ids</code></td>
<td>
<p>a <code>character</code> vector informing the name of the variable
in <code>sf_obj</code> that represents the polygons unique identifiers. In
case this is not informed, we assume the id of the polygons are given by
their row numbers.</p>
</td></tr>
<tr><td><code id="sf_to_spm_+3A_var_ids">var_ids</code></td>
<td>
<p>a scalar or vector of type <code>character</code> indicating the
(numerical) variables that are going to be analyzed.</p>
</td></tr>
<tr><td><code id="sf_to_spm_+3A_trunc_d">trunc_d</code></td>
<td>
<p>truncation distance for grid points. Consider using half of
the maximum distance between polygons</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named <code>list</code> of size 6 belonging to the class
<code>spm</code>. This list stores all the objects necessary to fit models
using the <code><a href="#topic+fit_spm">fit_spm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(liv_lsoa) # loading the LSOA data

msoa_spm &lt;- sf_to_spm(sf_obj = liv_msoa, n_pts = 1000,
                      type = "regular", by_polygon = FALSE,
                      poly_ids = "msoa11cd",
                      var_ids = "leb_est")

</code></pre>

<hr>
<h2 id='singl_ll_nn_hess'>Evaluate log-lik</h2><span id='topic+singl_ll_nn_hess'></span>

<h3>Description</h3>

<p>Evaluate the log-likelihood for a given set of parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>singl_ll_nn_hess(
  theta,
  .dt,
  dists,
  npix,
  model,
  nu = NULL,
  tr = NULL,
  kappa = 1,
  mu2 = 1.5,
  apply_exp = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="singl_ll_nn_hess_+3A_theta">theta</code></td>
<td>
<p>a <code>numeric</code> vector of size <code class="reqn">3</code> containing the
parameters values associated with <code class="reqn">\mu</code>, <code class="reqn">\sigma^2</code>, and
<code class="reqn">\phi</code>, respectively.</p>
</td></tr>
<tr><td><code id="singl_ll_nn_hess_+3A_.dt">.dt</code></td>
<td>
<p>a <code>numeric</code> vector containing the variable <code class="reqn">Y</code>.</p>
</td></tr>
<tr><td><code id="singl_ll_nn_hess_+3A_dists">dists</code></td>
<td>
<p>a <code>list</code> of size three. The first containing the distance
matrices associated with the regions where <code class="reqn">Y</code> was measured, the
second for the distance matrices associated with <code class="reqn">X</code>, and the last
containing the cross-distance matrices.</p>
</td></tr>
<tr><td><code id="singl_ll_nn_hess_+3A_npix">npix</code></td>
<td>
<p>a <code>integer vector</code> containing the number of pixels within
each polygon. (Ordered by the id variables for the polygons).</p>
</td></tr>
<tr><td><code id="singl_ll_nn_hess_+3A_model">model</code></td>
<td>
<p>a <code>character</code> indicating which covariance function to
use. Possible values are <code>c("matern", "pexp", "gaussian",
    "spherical")</code>.</p>
</td></tr>
<tr><td><code id="singl_ll_nn_hess_+3A_nu">nu</code></td>
<td>
<p><code class="reqn">\nu</code> parameter. Not necessary if <code>mode</code> is
<code>"gaussian"</code> or <code>"spherical"</code></p>
</td></tr>
<tr><td><code id="singl_ll_nn_hess_+3A_tr">tr</code></td>
<td>
<p>taper range</p>
</td></tr>
<tr><td><code id="singl_ll_nn_hess_+3A_kappa">kappa</code></td>
<td>
<p><code class="reqn">\kappa \in \{0, \ldots, 3 \}</code> parameter for the GW cov
function.</p>
</td></tr>
<tr><td><code id="singl_ll_nn_hess_+3A_mu2">mu2</code></td>
<td>
<p>the smoothness parameter <code class="reqn">\mu</code> for the GW function.</p>
</td></tr>
<tr><td><code id="singl_ll_nn_hess_+3A_apply_exp">apply_exp</code></td>
<td>
<p>a <code>logical</code> indicater wheter the exponential
transformation should be applied to variance parameters. This
facilitates the optimization process.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internal use.
</p>


<h3>Value</h3>

<p>a scalar representing <code>-log.lik</code>.
</p>

<hr>
<h2 id='singl_log_lik'>Evaluate log-lik</h2><span id='topic+singl_log_lik'></span>

<h3>Description</h3>

<p>Evaluate the log-likelihood for a given set of parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>singl_log_lik(
  theta,
  .dt,
  dists,
  npix,
  model,
  nu = NULL,
  tr = NULL,
  kappa = 1,
  mu2 = 1.5,
  apply_exp = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="singl_log_lik_+3A_theta">theta</code></td>
<td>
<p>a <code>numeric</code> vector of size 4 (<code class="reqn">\mu, \sigma^2, \tau^2,
\phi</code>) containing the parameters associated with the model.</p>
</td></tr>
<tr><td><code id="singl_log_lik_+3A_.dt">.dt</code></td>
<td>
<p>a <code>numeric</code> vector containing the variable <code class="reqn">Y</code>.</p>
</td></tr>
<tr><td><code id="singl_log_lik_+3A_dists">dists</code></td>
<td>
<p>a <code>list</code> of size distance matrices at the point level.</p>
</td></tr>
<tr><td><code id="singl_log_lik_+3A_npix">npix</code></td>
<td>
<p>a <code>integer vector</code> containing the number of pixels within
each polygon. (Ordered by the id variables for the polygons).</p>
</td></tr>
<tr><td><code id="singl_log_lik_+3A_model">model</code></td>
<td>
<p>a <code>character</code> indicating which covariance function to
use. Possible values are <code>c("matern", "pexp", "gaussian",
    "spherical", "cs", "gw", "tapmat")</code>.</p>
</td></tr>
<tr><td><code id="singl_log_lik_+3A_nu">nu</code></td>
<td>
<p><code class="reqn">\nu</code> parameter. Not necessary if <code>model</code> is
<code>"gaussian"</code> or <code>"spherical"</code></p>
</td></tr>
<tr><td><code id="singl_log_lik_+3A_tr">tr</code></td>
<td>
<p><code class="reqn">\theta_r</code> taper range.</p>
</td></tr>
<tr><td><code id="singl_log_lik_+3A_kappa">kappa</code></td>
<td>
<p><code class="reqn">\kappa \in \{0, \ldots, 3 \}</code> parameter for the GW cov
function.</p>
</td></tr>
<tr><td><code id="singl_log_lik_+3A_mu2">mu2</code></td>
<td>
<p>the smoothness parameter <code class="reqn">\mu</code> for the GW function.</p>
</td></tr>
<tr><td><code id="singl_log_lik_+3A_apply_exp">apply_exp</code></td>
<td>
<p>a <code>logical</code> indicater wheter the exponential
transformation should be applied to variance parameters. This
facilitates the optimization process.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internal use.
</p>


<h3>Value</h3>

<p>a scalar representing <code>-log.lik</code>.
</p>

<hr>
<h2 id='singl_log_lik_nn'>Evaluate log-lik</h2><span id='topic+singl_log_lik_nn'></span>

<h3>Description</h3>

<p>Evaluate the log-likelihood for a given set of parameters - No nugget +
profile likelihood
</p>


<h3>Usage</h3>

<pre><code class='language-R'>singl_log_lik_nn(
  theta,
  .dt,
  dists,
  npix,
  model,
  nu = NULL,
  tr = NULL,
  kappa = 1,
  mu2 = 1.5,
  apply_exp = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="singl_log_lik_nn_+3A_theta">theta</code></td>
<td>
<p>a scalar for the <code class="reqn">\phi</code> parameter.</p>
</td></tr>
<tr><td><code id="singl_log_lik_nn_+3A_.dt">.dt</code></td>
<td>
<p>a <code>numeric</code> vector containing the variable <code class="reqn">Y</code>.</p>
</td></tr>
<tr><td><code id="singl_log_lik_nn_+3A_dists">dists</code></td>
<td>
<p>a <code>list</code> of size three. The first containing the distance
matrices associated with the regions where <code class="reqn">Y</code> was measured, the
second for the distance matrices associated with <code class="reqn">X</code>, and the last
containing the cross-distance matrices.</p>
</td></tr>
<tr><td><code id="singl_log_lik_nn_+3A_npix">npix</code></td>
<td>
<p>a <code>integer vector</code> containing the number of pixels within
each polygon. (Ordered by the id variables for the polygons).</p>
</td></tr>
<tr><td><code id="singl_log_lik_nn_+3A_model">model</code></td>
<td>
<p>a <code>character</code> indicating which covariance function to
use. Possible values are <code>c("matern", "pexp", "gaussian",
    "spherical", "cs", "gw", "tapmat")</code>.</p>
</td></tr>
<tr><td><code id="singl_log_lik_nn_+3A_nu">nu</code></td>
<td>
<p><code class="reqn">\nu</code> parameter. Not necessary if <code>mode</code> is
<code>"gaussian"</code> or <code>"spherical"</code></p>
</td></tr>
<tr><td><code id="singl_log_lik_nn_+3A_kappa">kappa</code></td>
<td>
<p><code class="reqn">\kappa \in \{0, \ldots, 3 \}</code> parameter for the GW cov
function.</p>
</td></tr>
<tr><td><code id="singl_log_lik_nn_+3A_mu2">mu2</code></td>
<td>
<p>the smoothness parameter <code class="reqn">\mu</code> for the GW function.</p>
</td></tr>
<tr><td><code id="singl_log_lik_nn_+3A_apply_exp">apply_exp</code></td>
<td>
<p>a <code>logical</code> indicater wheter the exponential
transformation should be applied to variance parameters. This
facilitates the optimization process.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internal use.
</p>


<h3>Value</h3>

<p>a scalar representing <code>-log.lik</code>.
</p>

<hr>
<h2 id='singl_log_plik'>Evaluate log-lik</h2><span id='topic+singl_log_plik'></span>

<h3>Description</h3>

<p>Evaluate the log-likelihood for a given set of parameters - New
parametrization + profile likelihood
</p>


<h3>Usage</h3>

<pre><code class='language-R'>singl_log_plik(
  theta,
  .dt,
  dists,
  npix,
  model,
  nu = NULL,
  tr = NULL,
  kappa = 1,
  mu2 = 1.5,
  apply_exp = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="singl_log_plik_+3A_theta">theta</code></td>
<td>
<p>a <code>vector</code> of size 2 containing the parameters associated
with the model. These parameters are <code class="reqn">\nu</code> and <code class="reqn">\phi</code>,
respectively.</p>
</td></tr>
<tr><td><code id="singl_log_plik_+3A_.dt">.dt</code></td>
<td>
<p>a <code>numeric</code> vector containing the variable <code class="reqn">Y</code>.</p>
</td></tr>
<tr><td><code id="singl_log_plik_+3A_dists">dists</code></td>
<td>
<p>a <code>list</code> of size three. The first containing the distance
matrices associated with the regions where <code class="reqn">Y</code> was measured, the
second for the distance matrices associated with <code class="reqn">X</code>, and the last
containing the cross-distance matrices.</p>
</td></tr>
<tr><td><code id="singl_log_plik_+3A_npix">npix</code></td>
<td>
<p>a <code>integer vector</code> containing the number of pixels within
each polygon. (Ordered by the id variables for the polygons).</p>
</td></tr>
<tr><td><code id="singl_log_plik_+3A_model">model</code></td>
<td>
<p>a <code>character</code> indicating which covariance function to
use. Possible values are <code>c("matern", "pexp", "gaussian",
    "spherical", "cs", "gw", "tapmat")</code>.</p>
</td></tr>
<tr><td><code id="singl_log_plik_+3A_nu">nu</code></td>
<td>
<p><code class="reqn">\nu</code> parameter. Not necessary if <code>mode</code> is
<code>"gaussian"</code> or <code>"spherical"</code></p>
</td></tr>
<tr><td><code id="singl_log_plik_+3A_tr">tr</code></td>
<td>
<p><code class="reqn">\theta_r</code> taper range.</p>
</td></tr>
<tr><td><code id="singl_log_plik_+3A_kappa">kappa</code></td>
<td>
<p><code class="reqn">\kappa \in \{0, \ldots, 3 \}</code> parameter for the GW cov
function.</p>
</td></tr>
<tr><td><code id="singl_log_plik_+3A_mu2">mu2</code></td>
<td>
<p>the smoothness parameter <code class="reqn">\mu</code> for the GW function.</p>
</td></tr>
<tr><td><code id="singl_log_plik_+3A_apply_exp">apply_exp</code></td>
<td>
<p>a <code>logical</code> indicater wheter the exponential
transformation should be applied to variance parameters. This
facilitates the optimization process.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internal use.
</p>


<h3>Value</h3>

<p>a scalar representing <code>-log.lik</code>.
</p>

<hr>
<h2 id='single_cs'>Cubic spline covariance function (scalar)</h2><span id='topic+single_cs'></span>

<h3>Description</h3>

<p>Computing the Spherical covariance function for a single
distance measure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>single_cs(d, sigsq, phi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="single_cs_+3A_d">d</code></td>
<td>
<p>a scalar representing the distance on which it is desired to
evaluate the covariance function.</p>
</td></tr>
<tr><td><code id="single_cs_+3A_sigsq">sigsq</code></td>
<td>
<p>the <code class="reqn">\sigma^2</code> parameter from the Spherical covariance.
function.</p>
</td></tr>
<tr><td><code id="single_cs_+3A_phi">phi</code></td>
<td>
<p>the <code class="reqn">\phi</code> parameter from the Spherical covariance function,
controls the range of the spatial dependence.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar representing the (gaussian) covariance between two
observations <code>d</code> apart of each other.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+single_exp">single_exp</a></code>, <code><a href="#topic+single_matern">single_matern</a></code>,
<code><a href="#topic+single_matern3">single_matern3</a></code>, <code><a href="#topic+single_matern5">single_matern5</a></code>,
<code><a href="#topic+mat_cov">mat_cov</a></code>
</p>

<hr>
<h2 id='single_exp'>Exponential covariance function (scalar)</h2><span id='topic+single_exp'></span>

<h3>Description</h3>

<p>Computing the Exponential covariance function for a single
distance measure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>single_exp(d, sigsq, phi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="single_exp_+3A_d">d</code></td>
<td>
<p>a scalar representing the distance on which it is desired to
evaluate the covariance function.</p>
</td></tr>
<tr><td><code id="single_exp_+3A_sigsq">sigsq</code></td>
<td>
<p>the <code class="reqn">\sigma^2</code> parameter from the Exponential covariance
function.</p>
</td></tr>
<tr><td><code id="single_exp_+3A_phi">phi</code></td>
<td>
<p>the <code class="reqn">\phi</code> parameter from the Exponential covariance function,
controls the range of the spatial dependence.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar representing the (exponential) covariance between two
observations <code>d</code> apart of each other.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+single_pexp">single_pexp</a></code>, <code><a href="#topic+single_matern">single_matern</a></code>,
<code><a href="#topic+single_matern3">single_matern3</a></code>, <code><a href="#topic+single_matern5">single_matern5</a></code>,
<code><a href="#topic+mat_cov">mat_cov</a></code>
</p>

<hr>
<h2 id='single_gauss'>Gaussian covariance function (scalar)</h2><span id='topic+single_gauss'></span>

<h3>Description</h3>

<p>Computing the Gaussian covariance function for a single
distance measure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>single_gauss(d, sigsq, phi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="single_gauss_+3A_d">d</code></td>
<td>
<p>a scalar representing the distance on which it is desired to
evaluate the covariance function.</p>
</td></tr>
<tr><td><code id="single_gauss_+3A_sigsq">sigsq</code></td>
<td>
<p>the <code class="reqn">\sigma^2</code> parameter from the Gaussian covariance
function.</p>
</td></tr>
<tr><td><code id="single_gauss_+3A_phi">phi</code></td>
<td>
<p>the <code class="reqn">\phi</code> parameter from the Gaussian covariance function,
controls the range of the spatial dependence.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar representing the (gaussian) covariance between two
observations <code>d</code> apart of each other.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+single_exp">single_exp</a></code>, <code><a href="#topic+single_matern">single_matern</a></code>,
<code><a href="#topic+single_matern3">single_matern3</a></code>, <code><a href="#topic+single_matern5">single_matern5</a></code>,
<code><a href="#topic+mat_cov">mat_cov</a></code>
</p>

<hr>
<h2 id='single_gw'>Matern Generalized Wendland (GW) covariance function with kappa = 0
(scalar - generic)</h2><span id='topic+single_gw'></span>

<h3>Description</h3>

<p>adapted from Bevilacqua et al. 2019.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>single_gw(d, sigsq, phi, kappa, mu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="single_gw_+3A_d">d</code></td>
<td>
<p>a scalar representing the distance on which it is desired to
evaluate the covariance function.</p>
</td></tr>
<tr><td><code id="single_gw_+3A_sigsq">sigsq</code></td>
<td>
<p>the <code class="reqn">\sigma^2</code> parameter from the Matern covariance
function.</p>
</td></tr>
<tr><td><code id="single_gw_+3A_phi">phi</code></td>
<td>
<p>the <code class="reqn">\phi</code> parameter from the Matern covariance function,
controls the range of the spatial dependence.</p>
</td></tr>
<tr><td><code id="single_gw_+3A_kappa">kappa</code></td>
<td>
<p><code class="reqn">\kappa \in \{0, \ldots, 3 \}</code>.</p>
</td></tr>
<tr><td><code id="single_gw_+3A_mu">mu</code></td>
<td>
<p>a parameter that controls the smoothness of the covariance
function. Note that, <code class="reqn">\mu \geq 1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar representing the GW covariance between two
observations <code>d</code> apart of each other.
</p>

<hr>
<h2 id='single_gw0'>Matern Generalized Wendland (GW) covariance function with kappa = 0
(scalar - generic)</h2><span id='topic+single_gw0'></span>

<h3>Description</h3>

<p>adapted from Bevilacqua et al. 2019.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>single_gw0(d, sigsq, phi, mu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="single_gw0_+3A_d">d</code></td>
<td>
<p>a scalar representing the distance on which it is desired to
evaluate the covariance function.</p>
</td></tr>
<tr><td><code id="single_gw0_+3A_sigsq">sigsq</code></td>
<td>
<p>the <code class="reqn">\sigma^2</code> parameter from the Matern covariance
function.</p>
</td></tr>
<tr><td><code id="single_gw0_+3A_phi">phi</code></td>
<td>
<p>the <code class="reqn">\phi</code> parameter from the Matern covariance function,
controls the range of the spatial dependence.</p>
</td></tr>
<tr><td><code id="single_gw0_+3A_mu">mu</code></td>
<td>
<p>a parameter that controls the smoothness of the covariance
function. Note that, <code class="reqn">\mu \geq 1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar representing the GW covariance between two
observations <code>d</code> apart of each other.
</p>

<hr>
<h2 id='single_gw1'>Matern Generalized Wendland (GW) covariance function with kappa = 1
(scalar - generic)</h2><span id='topic+single_gw1'></span>

<h3>Description</h3>

<p>adapted from Bevilacqua et al. 2019.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>single_gw1(d, sigsq, phi, mu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="single_gw1_+3A_d">d</code></td>
<td>
<p>a scalar representing the distance on which it is desired to
evaluate the covariance function.</p>
</td></tr>
<tr><td><code id="single_gw1_+3A_sigsq">sigsq</code></td>
<td>
<p>the <code class="reqn">\sigma^2</code> parameter from the Matern covariance
function.</p>
</td></tr>
<tr><td><code id="single_gw1_+3A_phi">phi</code></td>
<td>
<p>the <code class="reqn">\phi</code> parameter from the Matern covariance function,
controls the range of the spatial dependence.</p>
</td></tr>
<tr><td><code id="single_gw1_+3A_mu">mu</code></td>
<td>
<p>a parameter that controls the smoothness of the covariance
function. Note that, <code class="reqn">\mu \geq 1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar representing the GW covariance between two
observations <code>d</code> apart of each other.
</p>

<hr>
<h2 id='single_gw2'>Matern Generalized Wendland (GW) covariance function with kappa = 2
(scalar - generic)</h2><span id='topic+single_gw2'></span>

<h3>Description</h3>

<p>adapted from Bevilacqua et al. 2019.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>single_gw2(d, sigsq, phi, mu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="single_gw2_+3A_d">d</code></td>
<td>
<p>a scalar representing the distance on which it is desired to
evaluate the covariance function.</p>
</td></tr>
<tr><td><code id="single_gw2_+3A_sigsq">sigsq</code></td>
<td>
<p>the <code class="reqn">\sigma^2</code> parameter from the Matern covariance
function.</p>
</td></tr>
<tr><td><code id="single_gw2_+3A_phi">phi</code></td>
<td>
<p>the <code class="reqn">\phi</code> parameter from the Matern covariance function,
controls the range of the spatial dependence.</p>
</td></tr>
<tr><td><code id="single_gw2_+3A_mu">mu</code></td>
<td>
<p>a parameter that controls the smoothness of the covariance
function. Note that, <code class="reqn">\mu \geq 1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar representing the GW covariance between two
observations <code>d</code> apart of each other.
</p>

<hr>
<h2 id='single_gw3'>Matern Generalized Wendland (GW) covariance function with kappa = 3
(scalar - generic)</h2><span id='topic+single_gw3'></span>

<h3>Description</h3>

<p>adapted from Bevilacqua et al. 2019.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>single_gw3(d, sigsq, phi, mu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="single_gw3_+3A_d">d</code></td>
<td>
<p>a scalar representing the distance on which it is desired to
evaluate the covariance function.</p>
</td></tr>
<tr><td><code id="single_gw3_+3A_sigsq">sigsq</code></td>
<td>
<p>the <code class="reqn">\sigma^2</code> parameter from the Matern covariance
function.</p>
</td></tr>
<tr><td><code id="single_gw3_+3A_phi">phi</code></td>
<td>
<p>the <code class="reqn">\phi</code> parameter from the Matern covariance function,
controls the range of the spatial dependence.</p>
</td></tr>
<tr><td><code id="single_gw3_+3A_mu">mu</code></td>
<td>
<p>a parameter that controls the smoothness of the covariance
function. Note that, <code class="reqn">\mu \geq 1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar representing the GW covariance between two
observations <code>d</code> apart of each other.
</p>

<hr>
<h2 id='single_matern'>Matern covariance function (scalar - generic)</h2><span id='topic+single_matern'></span>

<h3>Description</h3>

<p>Computing the Matern covariance function for a single distance
measure, addapted from <code>geoR</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>single_matern(d, sigsq, phi, nu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="single_matern_+3A_d">d</code></td>
<td>
<p>a scalar representing the distance on which it is desired to
evaluate the covariance function.</p>
</td></tr>
<tr><td><code id="single_matern_+3A_sigsq">sigsq</code></td>
<td>
<p>the <code class="reqn">\sigma^2</code> parameter from the Matern covariance
function.</p>
</td></tr>
<tr><td><code id="single_matern_+3A_phi">phi</code></td>
<td>
<p>the <code class="reqn">\phi</code> parameter from the Matern covariance function,
controls the range of the spatial dependence.</p>
</td></tr>
<tr><td><code id="single_matern_+3A_nu">nu</code></td>
<td>
<p>the <code class="reqn">\nu</code> parameter from the Matern covariance function,
controls the differentiability of the process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar representing the (matern) covariance between two
observations <code>d</code> apart of each other.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+single_matern">single_matern</a></code>, <code><a href="#topic+single_matern5">single_matern5</a></code>
<code><a href="#topic+single_exp">single_exp</a></code>, <code><a href="#topic+mat_cov">mat_cov</a></code>
</p>

<hr>
<h2 id='single_matern3'>Matern covariance function (scalar - nu = 3/2)</h2><span id='topic+single_matern3'></span>

<h3>Description</h3>

<p>Computing the Matern covariance function for a single distance
measure, with <code class="reqn">\nu = 3/2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>single_matern3(d, sigsq, phi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="single_matern3_+3A_d">d</code></td>
<td>
<p>a scalar representing the distance on which it is desired to
evaluate the covariance function.</p>
</td></tr>
<tr><td><code id="single_matern3_+3A_sigsq">sigsq</code></td>
<td>
<p>the <code class="reqn">\sigma^2</code> parameter from the Matern covariance
function.</p>
</td></tr>
<tr><td><code id="single_matern3_+3A_phi">phi</code></td>
<td>
<p>the <code class="reqn">\phi</code> parameter from the Matern covariance function,
controls the range of the spatial dependence.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar representing the (matern) covariance between two
observations <code>d</code> apart of each other.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+single_matern">single_matern</a></code>, <code><a href="#topic+single_matern5">single_matern5</a></code>
<code><a href="#topic+single_exp">single_exp</a></code>, <code><a href="#topic+mat_cov">mat_cov</a></code>
</p>

<hr>
<h2 id='single_matern5'>Matern covariance function (scalar - nu = 5/2)</h2><span id='topic+single_matern5'></span>

<h3>Description</h3>

<p>Computing the Matern covariance function for a single distance
measure, with <code class="reqn">\nu = 5/2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>single_matern5(d, sigsq, phi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="single_matern5_+3A_d">d</code></td>
<td>
<p>a scalar representing the distance on which it is desired to
evaluate the covariance function.</p>
</td></tr>
<tr><td><code id="single_matern5_+3A_sigsq">sigsq</code></td>
<td>
<p>the <code class="reqn">\sigma^2</code> parameter from the Matern covariance
function.</p>
</td></tr>
<tr><td><code id="single_matern5_+3A_phi">phi</code></td>
<td>
<p>the <code class="reqn">\phi</code> parameter from the Matern covariance function,
controls the range of the spatial dependence.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar representing the (matern) covariance between two
observations <code>d</code> apart of each other.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+single_matern">single_matern</a></code>, <code><a href="#topic+single_matern3">single_matern3</a></code>
<code><a href="#topic+single_exp">single_exp</a></code>, <code><a href="#topic+mat_cov">mat_cov</a></code>
</p>

<hr>
<h2 id='single_pexp'>Powered Exponential covariance function (scalar)</h2><span id='topic+single_pexp'></span>

<h3>Description</h3>

<p>Computing the Powered Exponential covariance function for a
single distance measure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>single_pexp(d, sigsq, phi, nu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="single_pexp_+3A_d">d</code></td>
<td>
<p>a scalar representing the distance on which it is desired to
evaluate the covariance function.</p>
</td></tr>
<tr><td><code id="single_pexp_+3A_sigsq">sigsq</code></td>
<td>
<p>the <code class="reqn">\sigma^2</code> parameter from the Exponential covariance
function.</p>
</td></tr>
<tr><td><code id="single_pexp_+3A_phi">phi</code></td>
<td>
<p>the <code class="reqn">\phi</code> parameter from the Exponential covariance function,
controls the range of the spatial dependence.</p>
</td></tr>
<tr><td><code id="single_pexp_+3A_nu">nu</code></td>
<td>
<p>the <code class="reqn">\nu \in (0, 2]</code> parameter representing the &quot;power&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar representing the (exponential) covariance between two
observations <code>d</code> apart of each other.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+single_exp">single_exp</a></code>, <code><a href="#topic+single_matern">single_matern</a></code>,
<code><a href="#topic+single_matern3">single_matern3</a></code>, <code><a href="#topic+single_matern5">single_matern5</a></code>,
<code><a href="#topic+mat_cov">mat_cov</a></code>
</p>

<hr>
<h2 id='single_spher'>Spherical covariance function (scalar)</h2><span id='topic+single_spher'></span>

<h3>Description</h3>

<p>Computing the Spherical covariance function for a single
distance measure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>single_spher(d, sigsq, phi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="single_spher_+3A_d">d</code></td>
<td>
<p>a scalar representing the distance on which it is desired to
evaluate the covariance function.</p>
</td></tr>
<tr><td><code id="single_spher_+3A_sigsq">sigsq</code></td>
<td>
<p>the <code class="reqn">\sigma^2</code> parameter from the Spherical covariance.
function.</p>
</td></tr>
<tr><td><code id="single_spher_+3A_phi">phi</code></td>
<td>
<p>the <code class="reqn">\phi</code> parameter from the Spherical covariance function,
controls the range of the spatial dependence.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar representing the (gaussian) covariance between two
observations <code>d</code> apart of each other.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+single_exp">single_exp</a></code>, <code><a href="#topic+single_matern">single_matern</a></code>,
<code><a href="#topic+single_matern3">single_matern3</a></code>, <code><a href="#topic+single_matern5">single_matern5</a></code>,
<code><a href="#topic+mat_cov">mat_cov</a></code>
</p>

<hr>
<h2 id='single_tapmat'>Matern (tappered) covariance function (scalar - generic)</h2><span id='topic+single_tapmat'></span>

<h3>Description</h3>

<p>Computing the Matern covariance function for a single distance
measure, addapted from <code>geoR</code> using Wendland-1 as a tapper.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>single_tapmat(d, sigsq, phi, nu, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="single_tapmat_+3A_d">d</code></td>
<td>
<p>a scalar representing the distance on which it is desired to
evaluate the covariance function.</p>
</td></tr>
<tr><td><code id="single_tapmat_+3A_sigsq">sigsq</code></td>
<td>
<p>the <code class="reqn">\sigma^2</code> parameter from the Matern covariance
function.</p>
</td></tr>
<tr><td><code id="single_tapmat_+3A_phi">phi</code></td>
<td>
<p>the <code class="reqn">\phi</code> parameter from the Matern covariance function,
controls the range of the spatial dependence.</p>
</td></tr>
<tr><td><code id="single_tapmat_+3A_nu">nu</code></td>
<td>
<p>the smoothness parameter <code class="reqn">\nu</code> from the Matern covariance
function, controls the differentiability of the process.</p>
</td></tr>
<tr><td><code id="single_tapmat_+3A_theta">theta</code></td>
<td>
<p>the <code class="reqn">\theta</code> tapper range.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar representing the (tappered matern) covariance between two
observations <code>d</code> apart of each other.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+single_matern">single_matern</a></code>, <code><a href="#topic+single_matern5">single_matern5</a></code>
<code><a href="#topic+single_exp">single_exp</a></code>, <code><a href="#topic+mat_cov">mat_cov</a></code>
</p>

<hr>
<h2 id='single_tapmat1'>Tappered Matern covariance function (scalar - nu = 1/2)</h2><span id='topic+single_tapmat1'></span>

<h3>Description</h3>

<p>Computing the Matern covariance function for a single distance
measure, with <code class="reqn">\nu = 1/2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>single_tapmat1(d, sigsq, phi, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="single_tapmat1_+3A_d">d</code></td>
<td>
<p>a scalar representing the distance on which it is desired to
evaluate the covariance function.</p>
</td></tr>
<tr><td><code id="single_tapmat1_+3A_sigsq">sigsq</code></td>
<td>
<p>the <code class="reqn">\sigma^2</code> parameter from the Matern covariance
function.</p>
</td></tr>
<tr><td><code id="single_tapmat1_+3A_phi">phi</code></td>
<td>
<p>the <code class="reqn">\phi</code> parameter from the Matern covariance function,
controls the range of the spatial dependence.</p>
</td></tr>
<tr><td><code id="single_tapmat1_+3A_theta">theta</code></td>
<td>
<p><code class="reqn">\theta</code> taper range.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar representing the (tappered matern) covariance between two
observations <code>d</code> apart of each other.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+single_matern">single_matern</a></code>, <code><a href="#topic+single_matern5">single_matern5</a></code>
<code><a href="#topic+single_exp">single_exp</a></code>, <code><a href="#topic+mat_cov">mat_cov</a></code>
</p>

<hr>
<h2 id='single_tapmat3'>Tappered Matern covariance function (scalar - nu = 3/2)</h2><span id='topic+single_tapmat3'></span>

<h3>Description</h3>

<p>Computing the Matern covariance function for a single distance
measure, with <code class="reqn">\nu = 3/2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>single_tapmat3(d, sigsq, phi, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="single_tapmat3_+3A_d">d</code></td>
<td>
<p>a scalar representing the distance on which it is desired to
evaluate the covariance function.</p>
</td></tr>
<tr><td><code id="single_tapmat3_+3A_sigsq">sigsq</code></td>
<td>
<p>the <code class="reqn">\sigma^2</code> parameter from the Matern covariance
function.</p>
</td></tr>
<tr><td><code id="single_tapmat3_+3A_phi">phi</code></td>
<td>
<p>the <code class="reqn">\phi</code> parameter from the Matern covariance function,
controls the range of the spatial dependence.</p>
</td></tr>
<tr><td><code id="single_tapmat3_+3A_theta">theta</code></td>
<td>
<p><code class="reqn">\theta</code> taper range.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar representing the (tappered matern) covariance between two
observations <code>d</code> apart of each other.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+single_matern">single_matern</a></code>, <code><a href="#topic+single_matern5">single_matern5</a></code>
<code><a href="#topic+single_exp">single_exp</a></code>, <code><a href="#topic+mat_cov">mat_cov</a></code>
</p>

<hr>
<h2 id='spher_cov'>Computing the Spherical covariance function for a single distance
measure.</h2><span id='topic+spher_cov'></span>

<h3>Description</h3>

<p>Computing the Spherical covariance function for a single distance
measure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spher_cov(dists, sigsq, phi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spher_cov_+3A_dists">dists</code></td>
<td>
<p>a numeric matrix representing the distance between spatial
entities.</p>
</td></tr>
<tr><td><code id="spher_cov_+3A_sigsq">sigsq</code></td>
<td>
<p>the <code class="reqn">\sigma^2</code> parameter from the Spherical covariance.
function.</p>
</td></tr>
<tr><td><code id="spher_cov_+3A_phi">phi</code></td>
<td>
<p>the <code class="reqn">\phi</code> parameter from the Spherical covariance function,
controls the range of the spatial dependence.
'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Spherical covariance function (for a stationary and
isotropic process) associated with the provided distances (<code>dists</code>)
and the given set of parameters.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+single_exp">single_exp</a></code>, <code><a href="#topic+single_matern">single_matern</a></code>
</p>

<hr>
<h2 id='st_remove_holes'>Remove holes from a <code>sfc</code> POLYGON</h2><span id='topic+st_remove_holes'></span>

<h3>Description</h3>

<p>internal use. Taken from
<a href="https://github.com/michaeldorman/nngeo/">https://github.com/michaeldorman/nngeo/</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_remove_holes(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_remove_holes_+3A_x">x</code></td>
<td>
<p>a <code>sf</code> or <code>sfc</code> polygon.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>sf</code> or <code>sfc</code> polygon.
</p>

<hr>
<h2 id='summary_spm_fit'>Summarizing <code>spm_fit</code></h2><span id='topic+summary_spm_fit'></span>

<h3>Description</h3>

<p>Provides a <code>data.frame</code> with point estimates and
confidence intervals for the paramters of the model fitted using the
<code>spm_fit</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary_spm_fit(x, sig = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary_spm_fit_+3A_x">x</code></td>
<td>
<p>a <code>spm_fit</code> object.</p>
</td></tr>
<tr><td><code id="summary_spm_fit_+3A_sig">sig</code></td>
<td>
<p>a real number between 0 and 1 indicating significance level to be
used to compute the confidence intervals for the parameter estimates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code> summarising the parameters estimated by the
<code>fit_spm</code> function.
</p>

<hr>
<h2 id='tapmat_cov'>Tappered Matern covariance function for a given distance matrix.</h2><span id='topic+tapmat_cov'></span>

<h3>Description</h3>

<p>Computing the tappered Matern covariance function for a matrix
of
distances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tapmat_cov(dists, sigsq, phi, nu, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tapmat_cov_+3A_dists">dists</code></td>
<td>
<p>a numeric matrix representing the distance between spatial
entities.</p>
</td></tr>
<tr><td><code id="tapmat_cov_+3A_sigsq">sigsq</code></td>
<td>
<p>the <code class="reqn">\sigma^2</code> parameter from the Matern covariance
function.</p>
</td></tr>
<tr><td><code id="tapmat_cov_+3A_phi">phi</code></td>
<td>
<p>the <code class="reqn">\phi</code> parameter from the Matern covariance function,'</p>
</td></tr>
<tr><td><code id="tapmat_cov_+3A_nu">nu</code></td>
<td>
<p>smoothness parameter</p>
</td></tr>
<tr><td><code id="tapmat_cov_+3A_theta">theta</code></td>
<td>
<p><code class="reqn">\theta</code> taper range.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The tappered matern covariance function (for a stationary and isotropic
process) associated with the provided distances (<code>dists</code>) and the
given set of parameters.
</p>

<hr>
<h2 id='transform.sf'>Transform method for <code>sf</code> objects</h2><span id='topic+transform.sf'></span>

<h3>Description</h3>

<p>Internal usage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sf'
transform(`_data`, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transform.sf_+3A__data">_data</code></td>
<td>
<p>a <code>sf</code> object</p>
</td></tr>
<tr><td><code id="transform.sf_+3A_...">...</code></td>
<td>
<p>additional options</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code>sf</code> object.
</p>

<hr>
<h2 id='vdl'>Voronoi Data Linkage</h2><span id='topic+vdl'></span>

<h3>Description</h3>

<p>Reminder, have to create an example. This will be exported
after we submit the paper for publication.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vdl(coords_sf, areal_sf, vars, buff)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vdl_+3A_coords_sf">coords_sf</code></td>
<td>
<p><code>sf</code> POINT target dataset.</p>
</td></tr>
<tr><td><code id="vdl_+3A_areal_sf">areal_sf</code></td>
<td>
<p><code>sf</code> POLYGON source dataset.</p>
</td></tr>
<tr><td><code id="vdl_+3A_vars">vars</code></td>
<td>
<p>a <code>character</code> representing the variables (observed at the
source - polygon) to be estimated at the target data.</p>
</td></tr>
<tr><td><code id="vdl_+3A_buff">buff</code></td>
<td>
<p>scalar <code>numeric</code>. Mostly for internal use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>sf</code> object for the <code>coords_sf</code> spatial data set.
</p>

<hr>
<h2 id='vdl_var'>Voronoi Data Linkage - Single variable and variance</h2><span id='topic+vdl_var'></span>

<h3>Description</h3>

<p>Reminder, have to create an example. This will be exported
after we submit the paper for publication.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vdl_var(coords_sf, areal_sf, res_var, variance, var_method = "CS", buff)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vdl_var_+3A_coords_sf">coords_sf</code></td>
<td>
<p><code>sf</code> POINT target dataset.</p>
</td></tr>
<tr><td><code id="vdl_var_+3A_areal_sf">areal_sf</code></td>
<td>
<p><code>sf</code> POLYGON source dataset.</p>
</td></tr>
<tr><td><code id="vdl_var_+3A_res_var">res_var</code></td>
<td>
<p>a <code>character</code> - the name of the variable in the
<code>areal_sf</code> to be estimated in the <code>coords_sf</code>.</p>
</td></tr>
<tr><td><code id="vdl_var_+3A_variance">variance</code></td>
<td>
<p>a <code>character</code> - the name of the variable varinace in
the <code>areal_sf</code> to be estimated in the <code>coords_sf</code>.</p>
</td></tr>
<tr><td><code id="vdl_var_+3A_var_method">var_method</code></td>
<td>
<p>a <code>character</code> representing the method to approximate
the variance of the AI estimates. Possible values are &quot;CS&quot;
(Cauchy-Schwartz) or &quot;MI&quot; (Moran's I).</p>
</td></tr>
<tr><td><code id="vdl_var_+3A_buff">buff</code></td>
<td>
<p>scalar <code>numeric</code>. Mostly for internal use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>sf</code> object, contaning the <code>id_coords</code> variable and the
<code>list_vars</code> for the <code>coords_sf</code> spatial data set.
</p>

<hr>
<h2 id='vor_build'>Voronoi Tesselation inside a polygon</h2><span id='topic+vor_build'></span>

<h3>Description</h3>

<p>voronoi tesselation of a given a set of points inside a
polygon.  This is an internal use function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vor_build(points_sf, poly_sf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vor_build_+3A_points_sf">points_sf</code></td>
<td>
<p><code>sf data frame</code> containing the points' coordinates</p>
</td></tr>
<tr><td><code id="vor_build_+3A_poly_sf">poly_sf</code></td>
<td>
<p>a <code>sf</code> polygon</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>sf</code> object containing the polygons associated with the
voronoi tesselation of <code>points_sf</code> the polygon <code>poly_sf</code>
</p>

<hr>
<h2 id='weight_mat'>Building weight matrix <strong>W</strong> for Areal Interpolation</h2><span id='topic+weight_mat'></span><span id='topic+w_col'></span><span id='topic+build_w'></span><span id='topic+est_w'></span><span id='topic+var_w'></span>

<h3>Description</h3>

<p>internal use. <code class="reqn">W_{ij} = | A_i \, cap \, B_j |</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>w_col(source_unit, target)

build_w(source, target)

est_w(W, source_dt, target)

var_w(W, var_vec, target, method = "CS", rho_mi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weight_mat_+3A_source_unit">source_unit</code></td>
<td>
<p>a single <code>geometry</code> from the source dataset.</p>
</td></tr>
<tr><td><code id="weight_mat_+3A_target">target</code></td>
<td>
<p>a <code>sf</code> object - target spatial data.</p>
</td></tr>
<tr><td><code id="weight_mat_+3A_source">source</code></td>
<td>
<p>a <code>sf</code> object - source spatial data.</p>
</td></tr>
<tr><td><code id="weight_mat_+3A_w">W</code></td>
<td>
<p>the weight matrix.</p>
</td></tr>
<tr><td><code id="weight_mat_+3A_source_dt">source_dt</code></td>
<td>
<p>a <code>data.frame</code> object representing the source dataset
but excludying the <code>geometry</code>, i.e. the spatial information,
column.</p>
</td></tr>
<tr><td><code id="weight_mat_+3A_var_vec">var_vec</code></td>
<td>
<p>a <code>numeric</code> vector with variances observed at the source
data.</p>
</td></tr>
<tr><td><code id="weight_mat_+3A_method">method</code></td>
<td>
<p>a <code>character</code> representing the method to approximate the
variance of the AI estimates. Possible values are &quot;CS&quot;
(Cauchy-Schwartz) or &quot;MI&quot; (Moran's I).</p>
</td></tr>
<tr><td><code id="weight_mat_+3A_rho_mi">rho_mi</code></td>
<td>
<p><code>numeric</code> calcuated Moran's I.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code class="reqn">n \times m</code> <code>numeric</code> matrix. Where <code class="reqn">n</code> is the
number of objservations in the target and <code class="reqn">m</code> is the sample size in
the source dataset.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
