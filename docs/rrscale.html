<!DOCTYPE html><html lang="en"><head><title>Help for package rrscale</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rrscale}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#asinh'><p>Arc-hyperbolic-sine transformation</p></a></li>
<li><a href='#box_cox'><p>Traditional box-cox power transformation. Accepts one real parameter</p></a></li>
<li><a href='#box_cox_exp'><p>Exponential of the tranditional box-cox transformation</p></a></li>
<li><a href='#box_cox_negative'><p>A generalized box-cox transformation that can handle negative data</p></a></li>
<li><a href='#box_cox_plus1'><p>Box-cox transformation with a shift of 1 added to the data</p></a></li>
<li><a href='#box_cox_plusmin'><p>Box-cox transformation with the data shifted so that it is positive</p></a></li>
<li><a href='#box_cox_shift'><p>Box-cox transformation of shifted variable</p></a></li>
<li><a href='#center'><p>Centers the data column-wise</p></a></li>
<li><a href='#gm_mean'><p>Calculate the geometric mean</p></a></li>
<li><a href='#list_transformations'><p>List possible transformations</p></a></li>
<li><a href='#log_box_cox'><p>Log of the traditional box-cox transformation</p></a></li>
<li><a href='#power'><p>Simple power transformation</p></a></li>
<li><a href='#rrscale'><p>Re-scale a data matrix</p></a></li>
<li><a href='#svdc'><p>The completed SVD</p></a></li>
<li><a href='#winsor'><p>Winsorizes the data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Robust Re-Scaling to Better Recover Latent Effects in Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Non-linear transformations of data to better discover latent effects. Applies a sequence of three transformations (1) a Gaussianizing transformation, (2) a Z-score transformation, and (3) an outlier removal transformation. A publication describing the method has the following citation: Gregory J. Hunt, Mark A. Dane, James E. Korkola, Laura M. Heiser &amp; Johann A. Gagnon-Bartsch (2020) "Automatic Transformation and Integration to Improve Visualization and Discovery of Latent Effects in Imaging Data", Journal of Computational and Graphical Statistics, &lt;<a href="https://doi.org/10.1080%2F10618600.2020.1741379">doi:10.1080/10618600.2020.1741379</a>&gt;.</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-5-22</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.0.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>DEoptim, nloptr, abind</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat, ggplot2, reshape2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-05-25 23:56:10 UTC; greg</td>
</tr>
<tr>
<td>Author:</td>
<td>Gregory Hunt [aut, cre],
  Johann Gagnon-Bartsch [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gregory Hunt &lt;ghunt@wm.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-05-26 11:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='asinh'>Arc-hyperbolic-sine transformation</h2><span id='topic+asinh'></span>

<h3>Description</h3>


<ul>
<li><p>T the transformation with arguments Y, the data, lambda the parameter, and boolean inverse to calculate inverse transformation.
</p>
</li>
<li><p>T_deriv the transformation with arguments Y, the data, lambda the parameter.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>asinh
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 2.</p>

<hr>
<h2 id='box_cox'>Traditional box-cox power transformation. Accepts one real parameter</h2><span id='topic+box_cox'></span>

<h3>Description</h3>


<ul>
<li><p>T the transformation with arguments Y, the data, lambda the parameter, and boolean inverse to calculate inverse transformation
</p>
</li>
<li><p>T_deriv the transformation with arguments Y, the data, lambda the parameter.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>box_cox
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 2.</p>

<hr>
<h2 id='box_cox_exp'>Exponential of the tranditional box-cox transformation</h2><span id='topic+box_cox_exp'></span>

<h3>Description</h3>


<ul>
<li><p>T the transformation with arguments Y, the data, lambda the parameter, and boolean inverse to calculate inverse transformation.
</p>
</li>
<li><p>T_deriv the transformation with arguments Y, the data, lambda the parameter.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>box_cox_exp
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 2.</p>

<hr>
<h2 id='box_cox_negative'>A generalized box-cox transformation that can handle negative data</h2><span id='topic+box_cox_negative'></span>

<h3>Description</h3>


<ul>
<li><p>T the transformation with arguments Y, the data, lambda the parameter, and boolean inverse to calculate inverse transformation.
</p>
</li>
<li><p>T_deriv the transformation with arguments Y, the data, lambda the parameter.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>box_cox_negative
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 2.</p>

<hr>
<h2 id='box_cox_plus1'>Box-cox transformation with a shift of 1 added to the data</h2><span id='topic+box_cox_plus1'></span>

<h3>Description</h3>


<ul>
<li><p>T the transformation with arguments Y, the data, lambda the parameter, and boolean inverse to calculate inverse transformation.
</p>
</li>
<li><p>T_deriv the transformation with arguments Y, the data, lambda the parameter.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>box_cox_plus1
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 2.</p>

<hr>
<h2 id='box_cox_plusmin'>Box-cox transformation with the data shifted so that it is positive</h2><span id='topic+box_cox_plusmin'></span>

<h3>Description</h3>


<ul>
<li><p>T the transformation with arguments Y, the data, lambda the parameter, and boolean inverse to calculate inverse transformation.
</p>
</li>
<li><p>T_deriv the transformation with arguments Y, the data, lambda the parameter.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>box_cox_plusmin
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 2.</p>

<hr>
<h2 id='box_cox_shift'>Box-cox transformation of shifted variable</h2><span id='topic+box_cox_shift'></span>

<h3>Description</h3>


<ul>
<li><p>T the transformation with arguments Y, the data, lambda the parameter, and boolean inverse to calculate inverse transformation. The parameter lambda has two real elements (1) the power and (2) the additive shift to the data.  
</p>
</li>
<li><p>T_deriv the transformation with arguments Y, the data, lambda the parameter.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>box_cox_shift
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 2.</p>

<hr>
<h2 id='center'>Centers the data column-wise</h2><span id='topic+center'></span>

<h3>Description</h3>

<p>Centers the data column-wise
</p>


<h3>Usage</h3>

<pre><code class='language-R'>center(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="center_+3A_x">x</code></td>
<td>
<p>the data.</p>
</td></tr>
</table>

<hr>
<h2 id='gm_mean'>Calculate the geometric mean</h2><span id='topic+gm_mean'></span>

<h3>Description</h3>

<p>Calculate the geometric mean
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gm_mean(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gm_mean_+3A_x">x</code></td>
<td>
<p>the data.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>Y &lt;- rlnorm(10)
gm &lt;- gm_mean(Y)
</code></pre>

<hr>
<h2 id='list_transformations'>List possible transformations</h2><span id='topic+list_transformations'></span>

<h3>Description</h3>

<p>Returns list of transformations. Each transformation is a transformation function (&ldquo;T&rdquo;) accepting a parameter and the derivative of this transformation function (&ldquo;T_deriv&rdquo;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_transformations()
</code></pre>

<hr>
<h2 id='log_box_cox'>Log of the traditional box-cox transformation</h2><span id='topic+log_box_cox'></span>

<h3>Description</h3>


<ul>
<li><p>T the transformation with arguments Y, the data, lambda the parameter, and boolean inverse to calculate inverse transformation.
</p>
</li>
<li><p>T_deriv the transformation with arguments Y, the data, lambda the parameter.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>log_box_cox
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 2.</p>

<hr>
<h2 id='power'>Simple power transformation</h2><span id='topic+power'></span>

<h3>Description</h3>


<ul>
<li><p>T the transformation with arguments Y, the data, lambda the parameter, and boolean inverse to calculate inverse transformation.
</p>
</li>
<li><p>T_deriv the transformation with arguments Y, the data, lambda the parameter.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>power
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 2.</p>

<hr>
<h2 id='rrscale'>Re-scale a data matrix</h2><span id='topic+rrscale'></span>

<h3>Description</h3>

<p>This transformation is three steps (1) Gaussianize the data, (2) z-score Transform the data, and (3) remove extreme outliers from the data. The sequence of these transformations helps focus further analyses on consequential variance in the data rather than having it be focused on variation resulting from the feature's measurement scale or outliers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rrscale(
  Y,
  trans_list = list(box_cox_negative = box_cox_negative, asinh = asinh),
  lims_list = list(box_cox_negative = c(-100, 100), asinh = list(0, 100)),
  opt_control = NULL,
  opt_method = "DEoptim",
  z = 4,
  q = 0.001,
  verbose = FALSE,
  log_dir = ".rrscale/",
  zeros = FALSE,
  opts = FALSE,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rrscale_+3A_y">Y</code></td>
<td>
<p>Data matrix, data.frame, or list of vectors, to be transformed.</p>
</td></tr>
<tr><td><code id="rrscale_+3A_trans_list">trans_list</code></td>
<td>
<p>List of transformations to be considered. See function list_transformations. Each element of the list should be a list containing the transformation function as the first element and the derivative of the transformation function as the second argument. The first argument of each function should be the data, the second the transformation parameter.</p>
</td></tr>
<tr><td><code id="rrscale_+3A_lims_list">lims_list</code></td>
<td>
<p>List of optimization limits for each transformation from trans_list. This should be a list the same length as <code>trans_list</code>. Each element of the list is a two-element vector that sets the optimization limits for the parameter of each transformation family.</p>
</td></tr>
<tr><td><code id="rrscale_+3A_opt_control">opt_control</code></td>
<td>
<p>Optional optimization controlling parameters for DEoptim control argument. See the DEoptim package for details.</p>
</td></tr>
<tr><td><code id="rrscale_+3A_opt_method">opt_method</code></td>
<td>
<p>Which optimization method to use. Defaults to DEoptim. Other choice is nloptr.</p>
</td></tr>
<tr><td><code id="rrscale_+3A_z">z</code></td>
<td>
<p>The O-step cutoff value. Points are removed if their robust z-score is above z in magnitude.</p>
</td></tr>
<tr><td><code id="rrscale_+3A_q">q</code></td>
<td>
<p>The Z-step winsorizing quantile cutoff. The quantile at which to winsorize the data when calculating the robust z-scores.</p>
</td></tr>
<tr><td><code id="rrscale_+3A_verbose">verbose</code></td>
<td>
<p>a boolean, if TRUE then save optimization output in log_dir.</p>
</td></tr>
<tr><td><code id="rrscale_+3A_log_dir">log_dir</code></td>
<td>
<p>directory for verbose output. Defaults to &quot;.rrscale/&quot;</p>
</td></tr>
<tr><td><code id="rrscale_+3A_zeros">zeros</code></td>
<td>
<p>How to deal with zeros in the data set. If set to FALSE the algorithm will fail if it encounters a zero. If set to a number or 'NA' then the zeros are replaced by this number or 'NA'.</p>
</td></tr>
<tr><td><code id="rrscale_+3A_opts">opts</code></td>
<td>
<p>Boolean determining if optimization output is returned. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="rrscale_+3A_seed">seed</code></td>
<td>
<p>Sets the seed before running any other analyses.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of output:
</p>

<ul>
<li><p>opts: the optimization output for all transformation families and all columns
</p>
</li>
<li><p>pars: the optimal parameters for each column for the optimal family
</p>
</li>
<li><p>par_hat: the estimated optimal paramter
</p>
</li>
<li><p>NT: the original data
</p>
</li>
<li><p>RR: the robust-rescaled data
</p>
</li>
<li><p>G: gaussianized data
</p>
</li>
<li><p>Z: robust z-transformed data
</p>
</li>
<li><p>O: data with outliers removed
</p>
</li>
<li><p>rr_fn: a function to apply the estimated RR transformation to new data. Takes arguments
</p>

<ul>
<li> <p>Y: the data,
</p>
</li>
<li> <p>z: the z-score cutoff (defaults to 4),
</p>
</li>
<li> <p>q: the winsorizing quantile cutoff (defaults to 0.001),
</p>
</li>
<li> <p>lambda: the transformation parameter to use (defaults to the estimated one),
</p>
</li>
<li> <p>T: the transformation function family (defaults to the optimal estimated family),
</p>
</li>
<li> <p>mu: the mean to be used in the robust z-score step (re-estimates if NULL)
</p>
</li>
<li> <p>sigma: the s.d. to be used in the robust z-score step (re-estimates if NULL)
</p>
</li></ul>

</li>
<li><p>T: the optimal family
</p>
</li>
<li><p>T_deriv: the derivative of the optimal family
</p>
</li>
<li><p>T_name: name of the optimal family
</p>
</li>
<li><p>alg_control: the parameters passed to the algorithm
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>Y &lt;- rlnorm(10)%*%t(rlnorm(10))
rr.out &lt;- rrscale(Y)
Yt &lt;- rr.out$RR
</code></pre>

<hr>
<h2 id='svdc'>The completed SVD</h2><span id='topic+svdc'></span>

<h3>Description</h3>

<p>This calculates right and left singular vectors of a data matrix possibly containing missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svdc(X, nu = NULL, nv = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="svdc_+3A_x">X</code></td>
<td>
<p>the data matrix of which to calcluate the completed SVD.</p>
</td></tr>
<tr><td><code id="svdc_+3A_nu">nu</code></td>
<td>
<p>the number of left singular vectors to calculate</p>
</td></tr>
<tr><td><code id="svdc_+3A_nv">nv</code></td>
<td>
<p>the nubmer of right singular vectors to calculate</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>Y &lt;- rnorm(10)%*%t(rnorm(10))
Y[1,1] &lt;- NA
svdc.out &lt;- svdc(Y)
</code></pre>

<hr>
<h2 id='winsor'>Winsorizes the data</h2><span id='topic+winsor'></span>

<h3>Description</h3>

<p>Winsorizes the data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>winsor(x, fraction = 0.01)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="winsor_+3A_x">x</code></td>
<td>
<p>the data.</p>
</td></tr>
<tr><td><code id="winsor_+3A_fraction">fraction</code></td>
<td>
<p>the top and bottom quantiles to cap.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>Y &lt;- rlnorm(10)%*%t(rlnorm(10))
Yw &lt;- winsor(Y,1E-2)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
