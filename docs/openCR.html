<!DOCTYPE html><html lang="en"><head><title>Help for package openCR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {openCR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#openCR-package'><p>Open Population Capture&ndash;Recapture Models</p></a></li>
<li><a href='#age.matrix'><p>Session-specific Ages</p></a></li>
<li><a href='#AIC.openCR'><p> Compare openCR Models</p></a></li>
<li><a href='#classMembership'><p>Class Membership Probability for Mixture Models</p></a></li>
<li><a href='#cloned.fit'>
<p>Cloning to Evaluate Identifiability</p>
</p></a></li>
<li><a href='#collate'><p>Array of Parameter Estimates</p></a></li>
<li><a href='#cumMove'>
<p>Probability Distribution After Movement</p>
</p></a></li>
<li><a href='#derived'>
<p>Derived Parameters From openCR Models</p>
</p></a></li>
<li><a href='#dipperCH'><p>Dippers</p></a></li>
<li><a href='#expected.d'><p>Expected Distance Moved</p></a></li>
<li><a href='#Field+20vole'><p>Kielder Field Voles</p></a></li>
<li><a href='#gonodontisCH'><p>Gonodontis Moths</p></a></li>
<li><a href='#Internal'><p>Internal Functions</p></a></li>
<li><a href='#JS.counts'><p>Summarise Non-spatial Open-population Data</p></a></li>
<li><a href='#JS.direct'><p>Jolly&ndash;Seber Estimates</p></a></li>
<li><a href='#LLsurface'><p>Plot Likelihood Surface</p></a></li>
<li><a href='#make.kernel'><p>Discrete Movement Kernel</p></a></li>
<li><a href='#make.table'><p>Tabulate Estimates From Multiple Models</p></a></li>
<li><a href='#makeNewData'><p> Create Default Design Data</p></a></li>
<li><a href='#matchscale'><p>Match Kernel</p></a></li>
<li><a href='#Microtus'><p>Patuxent Meadow Voles</p></a></li>
<li><a href='#miscellaneous'><p>Data Manipulation</p></a></li>
<li><a href='#modelAverage'><p>Averaging of OpenCR Models Using Akaike's Information Criterion</p></a></li>
<li><a href='#Movement+20models'><p> List of Movement Models</p></a></li>
<li><a href='#moving.fit'><p>Moving Window Functions</p></a></li>
<li><a href='#openCR-defunct'><p>Defunct Functions in Package <span class="pkg">openCR</span></p></a></li>
<li><a href='#openCR-deprecated'><p>Deprecated Functions in Package <span class="pkg">openCR</span></p></a></li>
<li><a href='#openCR.design'><p>Design Data for Open population Models</p></a></li>
<li><a href='#openCR.fit'><p> Fit Open Population Capture&ndash;Recapture Model</p></a></li>
<li><a href='#openCRlist'><p>Bundle openCR Models</p></a></li>
<li><a href='#par.openCR.fit'><p>Fit Multiple openCR Models</p></a></li>
<li><a href='#pkernel'><p>Kernel Distribution Functions</p></a></li>
<li><a href='#plot.derivedopenCR'><p>Plot Derived Estimates</p></a></li>
<li><a href='#plot.openCR'><p>Plot Estimates</p></a></li>
<li><a href='#PPNpossums'>
<p>Orongorongo Valley Brushtail Possums</p>
</p></a></li>
<li><a href='#predict.openCR'><p> openCR Model Predictions</p></a></li>
<li><a href='#print.derivedopenCR'><p>Print Method for Derived Estimates</p></a></li>
<li><a href='#print.openCR'><p> Print or Summarise openCR Object</p></a></li>
<li><a href='#read.inp'><p> Import Data from RMark Input Format</p></a></li>
<li><a href='#rev.capthist'><p>Reverse Primary Sessions</p></a></li>
<li><a href='#simulation'><p>Simulate Capture Histories</p></a></li>
<li><a href='#squeeze'><p>Unique Capture Histories</p></a></li>
<li><a href='#strata'><p> Stratum names</p></a></li>
<li><a href='#stratify'><p>Stratify Capture-Recapture Data</p></a></li>
<li><a href='#ucare.cjs'><p>Goodness-of-fit tests for the Cormack-Jolly-Seber model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Open Population Capture-Recapture</td>
</tr>
<tr>
<td>Version:</td>
<td>2.2.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-10-23</td>
</tr>
<tr>
<td>Description:</td>
<td>Non-spatial and spatial open-population capture-recapture analysis.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), secr (&ge; 4.6.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>abind, MASS, methods, nlme, parallel, plyr, Rcpp (&ge; 0.12.14),
RcppParallel (&ge; 5.1.1), stats, stringr, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, RMark, rmarkdown, testthat, R2ucare, secrlinear</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>BH, Rcpp, RcppParallel</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyDataCompression:</td>
<td>xz</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.otago.ac.nz/density/">https://www.otago.ac.nz/density/</a>,
<a href="https://github.com/MurrayEfford/openCR/">https://github.com/MurrayEfford/openCR/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/MurrayEfford/openCR/issues/">https://github.com/MurrayEfford/openCR/issues/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-10-23 09:14:52 UTC; murra</td>
</tr>
<tr>
<td>Author:</td>
<td>Murray Efford <a href="https://orcid.org/0000-0001-5231-5184"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Murray Efford &lt;murray.efford@otago.ac.nz&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-10-23 12:10:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='openCR-package'>Open Population Capture&ndash;Recapture Models </h2><span id='topic+openCR-package'></span><span id='topic+openCR'></span>

<h3>Description</h3>

<p>Functions for non-spatial open population analysis by
Cormack-Jolly-Seber (CJS) and Jolly-Seber-Schwarz-Arnason (JSSA)
methods, and by spatially explicit extensions of these
methods. The methods build on Schwarz and Arnason (1996), Borchers and 
Efford (2008) and Pledger et al. (2010) (see <a href="../doc/openCR-vignette.pdf">vignette</a> 
for more comprehensive references and likelihood). The parameterisation of JSSA 
recruitment is flexible (options include population growth rate <code class="reqn">\lambda</code>, 
per capita recruitment <code class="reqn">f</code> and seniority <code class="reqn">\gamma</code>). Spatially explicit 
analyses may assume home-range centres are fixed or allow dispersal between
primary sessions according to various probability kernels, including bivariate 
normal (BVN) and bivariate <em>t</em> (BVT) (Efford and Schofield 2022).
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> openCR</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 2.2.7</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-10-23</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GNU General Public License Version 2 or later</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Data are observations of marked individuals from a &lsquo;robust&rsquo; sampling
design (Pollock 1982). Primary sessions may include one or more
secondary sessions. Detection histories are assumed to be stored in an object of class
&lsquo;capthist&rsquo; from the package <span class="pkg">secr</span>. Grouping of occasions into
primary and secondary sessions is coded by the &lsquo;intervals&rsquo; attribute
(zero for successive secondary sessions).
</p>
<p>A few test datasets are provided (<code>microtusCH</code>, <code>FebpossumCH</code>, <code>dipperCH</code>, 
<code>gonodontisCH</code>, <code>fieldvoleCH</code>) and some from <span class="pkg">secr</span> are also suitable 
e.g. <code>ovenCH</code> and <code>OVpossumCH</code>.
</p>
<p>Models are defined using symbolic formula notation. Possible predictors
include both pre-defined variables (b, session etc.), corresponding to
&lsquo;behaviour&rsquo; and other effects), and user-provided covariates.
</p>
<p>Models are fitted by numerically maximizing the likelihood. The function
<code><a href="#topic+openCR.fit">openCR.fit</a></code> creates an object of class
<code>openCR</code>. Generic methods (print, AIC, etc.) are provided
for each object class.
</p>
<p>A link at the bottom of each help page takes you to the help index. 
</p>
<p>See <a href="../doc/openCR-vignette.pdf">openCR-vignette.pdf</a> for more.
</p>


<h3>Author(s)</h3>

<p> Murray Efford <a href="mailto:murray.efford@otago.ac.nz">murray.efford@otago.ac.nz</a> </p>


<h3>References</h3>

<p>Borchers, D. L. and Efford, M. G. (2008) Spatially explicit maximum
likelihood methods for capture&ndash;recapture studies. <em>Biometrics</em>
<b>64</b>, 377&ndash;385.
</p>
<p>Efford, M. G. and Schofield, M. R. (2020) A spatial open-population capture&ndash;recapture model.
<em>Biometrics</em> <b>76</b>, 392&ndash;402.
</p>
<p>Efford, M. G. and Schofield, M. R. (2022) A review of movement models in open population capture&ndash;recapture. <em>Methods in Ecology and Evolution</em> <b>13</b>, 2106&ndash;2118. https://doi.org/10.1111/2041-210X.13947
</p>
<p>Glennie, R., Borchers, D. L., Murchie, M. Harmsen, B. J., and Foster, R. J. (2019) Open population maximum likelihood spatial capture&ndash;recapture. <em>Biometrics</em> <b>75</b>, 1345&ndash;1355
</p>
<p>Pledger, S., Pollock, K. H. and Norris, J. L. (2010) Open
capture&ndash;recapture models with heterogeneity: II. Jolly-Seber
model. <em>Biometrics</em> <b>66</b>, 883&ndash;890.
</p>
<p>Pollock, K. H. (1982) A capture&ndash;recapture design robust to unequal 
probability of capture. <em>Journal of Wildlife Management</em> <b>46</b>, 752&ndash;757.
</p>
<p>Schwarz, C. J. and Arnason, A. N. (1996) A general methodology for the
analysis of capture-recapture experiments in open
populations. <em>Biometrics</em> <b>52</b>, 860&ndash;873.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+openCR.fit">openCR.fit</a></code>, <code><a href="secr.html#topic+capthist">capthist</a></code>, <code><a href="secr.html#topic+ovenCH">ovenCH</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

## a CJS model is fitted by default
openCR.fit(ovenCH)


## End(Not run)

</code></pre>

<hr>
<h2 id='age.matrix'>Session-specific Ages</h2><span id='topic+age.matrix'></span>

<h3>Description</h3>

<p>A matrix showing the age of each animal at each secondary session (occasion).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
age.matrix(capthist, initialage = 0, minimumage = 0, maximumage = 1, 
    collapse = FALSE, unborn = minimumage)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="age.matrix_+3A_capthist">capthist</code></td>
<td>
<p>single-session capthist object</p>
</td></tr>
<tr><td><code id="age.matrix_+3A_initialage">initialage</code></td>
<td>
<p>numeric or character name of covariate with age at first detection (optional)</p>
</td></tr>
<tr><td><code id="age.matrix_+3A_minimumage">minimumage</code></td>
<td>
<p>integer minimum age</p>
</td></tr>
<tr><td><code id="age.matrix_+3A_maximumage">maximumage</code></td>
<td>
<p>integer maximum age</p>
</td></tr>
<tr><td><code id="age.matrix_+3A_collapse">collapse</code></td>
<td>
<p>logical; if TRUE then values for each individual are collapsed 
as a string with no spaces</p>
</td></tr>
<tr><td><code id="age.matrix_+3A_unborn">unborn</code></td>
<td>
<p>numeric code for age&lt;0 </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>age.matrix</code> is used by <code><a href="#topic+openCR.design">openCR.design</a></code> for the predictors &lsquo;age&rsquo; and &lsquo;Age&rsquo;.
</p>
<p>Computations use the intervals attribute of <code>capthist</code>, which may be non-integer.
</p>
<p>Ages are inferred for occasions before first detection, back to the minimum age.
</p>


<h3>Value</h3>

<p>Either a numeric matrix with dimensions (number of animals, number of secondary occasions)
or if <code>collapse = TRUE</code> a character matrix with one column.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+openCR.design">openCR.design</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
age.matrix(join(ovenCH), maximumage = 2, collapse = TRUE)

</code></pre>

<hr>
<h2 id='AIC.openCR'> Compare openCR Models </h2><span id='topic+AIC.openCR'></span><span id='topic+AIC.openCRlist'></span><span id='topic+logLik.openCR'></span>

<h3>Description</h3>

<p>Terse report on the fit of one or more spatially explicit
capture&ndash;recapture models. Models with smaller values of AIC (Akaike's
Information Criterion) are preferred.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'openCR'
AIC(object, ..., sort = TRUE, k = 2, dmax = 10,  use.rank = FALSE,
                        svtol = 1e-5, criterion = c('AIC','AICc'), n = NULL)

## S3 method for class 'openCRlist'
AIC(object, ..., sort = TRUE, k = 2, dmax = 10,  use.rank = FALSE,
                        svtol = 1e-5, criterion = c('AIC','AICc'), n = NULL)

## S3 method for class 'openCR'
logLik(object, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AIC.openCR_+3A_object">object</code></td>
<td>
 <p><code>openCR</code> object output from the function
<code><a href="#topic+openCR.fit">openCR.fit</a></code>, or <code>openCRlist</code></p>
</td></tr>
<tr><td><code id="AIC.openCR_+3A_...">...</code></td>
<td>
<p> other <code>openCR</code> objects </p>
</td></tr>
<tr><td><code id="AIC.openCR_+3A_sort">sort</code></td>
<td>
<p> logical for whether rows should be sorted by ascending AICc </p>
</td></tr>
<tr><td><code id="AIC.openCR_+3A_k">k</code></td>
<td>
<p> numeric, the penalty per parameter to be used; always k = 2 in this method</p>
</td></tr>
<tr><td><code id="AIC.openCR_+3A_dmax">dmax</code></td>
<td>
<p> numeric, the maximum AIC difference for inclusion in
confidence set</p>
</td></tr>
<tr><td><code id="AIC.openCR_+3A_use.rank">use.rank</code></td>
<td>
<p> logical; if TRUE the number of parameters is based on
the rank of the Hessian matrix</p>
</td></tr>
<tr><td><code id="AIC.openCR_+3A_svtol">svtol</code></td>
<td>
<p> minimum singular value (eigenvalue) of Hessian used when
counting non-redundant parameters </p>
</td></tr>
<tr><td><code id="AIC.openCR_+3A_criterion">criterion</code></td>
<td>
<p> character, criterion to use for model comparison and
weights</p>
</td></tr>
<tr><td><code id="AIC.openCR_+3A_n">n</code></td>
<td>
<p>integer effective sample size</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Models to be compared must have been fitted to the same data and use the
same likelihood method (full vs conditional).
</p>
<p>AIC with small sample adjustment is given by
</p>
<p style="text-align: center;"><code class="reqn"> \mbox{AIC}_c = -2\log(L(\hat{\theta})) + 2K +
\frac{2K(K+1)}{n-K-1} </code>
</p>

<p>where <code class="reqn">K</code> is the number of &ldquo;beta&quot; parameters estimated. By default, the effective sample size <code class="reqn">n</code> is the number of individuals observed at least once (i.e. the
number of rows in <code>capthist</code>). This differs from the default in MARK which for CJS models is the sum of the sizes of release cohorts (see <code><a href="#topic+m.array">m.array</a></code>).
</p>
<p>Model weights are calculated as </p>
<p style="text-align: center;"><code class="reqn">w_i = \frac{\exp(-\Delta_i / 2)}{
\sum{\exp(-\Delta_i / 2)}}</code>
</p>

<p>Models for which dAIC &gt; <code>dmax</code> are given a weight of zero and are
excluded from the summation. Model weights may be used to form
model-averaged estimates of real or beta parameters with
<code><a href="#topic+modelAverage">modelAverage</a></code> (see also Buckland et al. 1997, Burnham and
Anderson 2002).
</p>
<p>The argument <code>k</code> is included for consistency with the generic
method <code>AIC</code>.
</p>


<h3>Value</h3>

<p>A data frame with one row per model.  By default, rows are sorted by ascending AIC.
</p>
<table role = "presentation">
<tr><td><code>model</code></td>
<td>
<p>character string describing the fitted model</p>
</td></tr>
<tr><td><code>npar</code></td>
<td>
<p>number of parameters estimated</p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p>rank of Hessian</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>maximized log likelihood</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>Akaike's Information Criterion</p>
</td></tr>
<tr><td><code>AICc</code></td>
<td>
<p>AIC with small-sample adjustment of Hurvich &amp; Tsai (1989)</p>
</td></tr>
<tr><td><code>dAICc</code></td>
<td>
<p>difference between AICc of this model and the one with smallest AIC</p>
</td></tr>
<tr><td><code>AICwt</code></td>
<td>
<p>AICc model weight</p>
</td></tr>
</table>
<p><code>logLik.openCR</code> returns an object of class &lsquo;logLik&rsquo; that has
attribute <code>df</code> (degrees of freedom = number of estimated
parameters).
</p>


<h3>Note</h3>

<p>The default criterion is AIC, not AICc as in <span class="pkg">secr</span> 3.1.
</p>
<p>Computed values differ from MARK for various reasons. MARK uses the
number of observations, not the number of capture histories when
computing AICc. It is also likely that MARK will count parameters
differently.
</p>
<p>It is not be meaningful to compare models by AIC if they relate to
different data.
</p>
<p>The issue of goodness-of-fit and possible adjustment of AIC for
overdispersion has yet to be addressed (cf QAIC in MARK).
</p>


<h3>References</h3>

 
<p>Buckland S. T., Burnham K. P. and Augustin, N. H. (1997) Model selection: an integral part of inference. <em>Biometrics</em> <b>53</b>, 603&ndash;618.
</p>
<p>Burnham, K. P. and Anderson, D. R. (2002) <em>Model Selection and Multimodel Inference: A Practical Information-Theoretic Approach</em>. Second edition. New York: Springer-Verlag.
</p>
<p>Hurvich, C. M. and Tsai, C. L. (1989) Regression and time series model selection in small samples. <em>Biometrika</em> <b>76</b>, 297&ndash;307.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+AIC">AIC</a></code>, <code><a href="#topic+openCR.fit">openCR.fit</a></code>,
<code><a href="#topic+print.openCR">print.openCR</a></code>, <code><a href="secr.html#topic+LR.test">LR.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
m1 &lt;- openCR.fit(ovenCH, type = 'JSSAf')
m2 &lt;- openCR.fit(ovenCH, type = 'JSSAf', model = list(p~session))
AIC(m1, m2)

## End(Not run)

</code></pre>

<hr>
<h2 id='classMembership'>Class Membership Probability for Mixture Models</h2><span id='topic+classMembership'></span><span id='topic+classMembership.openCR'></span>

<h3>Description</h3>

<p>Finite mixture models treat class membership as a latent random variable. The probability of an individual's membership in each class may be inferred retrospectively from the relative likelihoods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'openCR'
classMembership(object, fullCH = NULL, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="classMembership_+3A_object">object</code></td>
<td>
<p>fitted model of class openCR</p>
</td></tr>
<tr><td><code id="classMembership_+3A_fullch">fullCH</code></td>
<td>
<p>capthist object (optional)</p>
</td></tr>
<tr><td><code id="classMembership_+3A_...">...</code></td>
<td>
<p>other arguments (not used)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is assumed that the input model includes finite mixture terms (h2 or h3).
</p>
<p>As the detection histories are saved in compressed (&ldquo;squeezed&rdquo;) form in openCR objects the original animal identifiers are lost and the order of animals may change. These may be restored by providing <code>fullCH</code>.
</p>
<p>No class can be assigned from a CJS model for animals detected only in the final session.
</p>


<h3>Value</h3>

<p>Matrix with one row per individual and columns for each class and the class number of the most likely class.
</p>


<h3>Note</h3>

<p>In earlier versions <code><a href="#topic+openCR.fit">openCR.fit</a></code> always computed class membership and saved it in component &lsquo;posterior&rsquo; of the fitted model. <code>classMembership</code> replaces that functionality.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+openCR.fit">openCR.fit</a></code>, 
<code><a href="#topic+squeeze">squeeze</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
jch &lt;- join(ovenCH)   
fit &lt;- openCR.fit(ovenCH, model=p~h2)
classMembership(fit, jch)

## End(Not run)

</code></pre>

<hr>
<h2 id='cloned.fit'>
Cloning to Evaluate Identifiability
</h2><span id='topic+cloned.fit'></span>

<h3>Description</h3>

<p>The identifiability of parameters may be examined by refitting a model with cloned data (each capture history replicated <code>nclone</code> times). For identifiable parameters the estimated variances are proportional to <code>1/nclone</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
cloned.fit(object, nclone = 100, newdata = NULL, linkscale = FALSE)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cloned.fit_+3A_object">object</code></td>
<td>
<p>previously fitted openCR object</p>
</td></tr>
<tr><td><code id="cloned.fit_+3A_nclone">nclone</code></td>
<td>
<p>integer number of times to replicate each capture history</p>
</td></tr>
<tr><td><code id="cloned.fit_+3A_newdata">newdata</code></td>
<td>
<p>optional dataframe of values at which to evaluate model </p>
</td></tr>
<tr><td><code id="cloned.fit_+3A_linkscale">linkscale</code></td>
<td>
<p>logical; if TRUE then comparison uses SE of linear predictors</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The key output is the ratio of SE for estimates from the uncloned and cloned datasets, adjusted for the level of cloning (<code>nclone</code>). For identifiable parameters the ratio is expected to be 1.0.
</p>
<p>Cloning is not implemented for spatial models.
</p>
<p>The comparison may be done either on the untransformed scale (using approximate SE) or on the link scale.
</p>


<h3>Value</h3>

<p>Dataframe with columns* &ndash;
</p>
<table role = "presentation">
<tr><td><code>estimate</code></td>
<td>
<p>original estimate </p>
</td></tr>
<tr><td><code>SE.estimate</code></td>
<td>
<p>original SE</p>
</td></tr>
<tr><td><code>estimate.xxx</code></td>
<td>
<p>cloned estimate (xxx = nclone)</p>
</td></tr>
<tr><td><code>SE.estimate.xxx</code></td>
<td>
<p>cloned SE</p>
</td></tr>
<tr><td><code>SE.ratio</code></td>
<td>
<p>SE.estimate / SE.estimate.xxx / sqrt(nclone)</p>
</td></tr>
</table>
<p>* &lsquo;estimate&rsquo; becomes &lsquo;beta&rsquo; when <code>linkscale = TRUE</code>.
</p>


<h3>References</h3>

<p>Lele, S.R., Nadeem, K. and Schmuland, B. (2010) Estimability and likelihood inference for generalized
linear mixed models using data cloning. <em>Journal of the American Statistical Association</em> <b>105</b>, 1617&ndash;1625.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+openCR.fit">openCR.fit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
fit &lt;- openCR.fit(dipperCH)
cloned.fit(fit)

## End(Not run)

</code></pre>

<hr>
<h2 id='collate'>Array of Parameter Estimates</h2><span id='topic+collate'></span><span id='topic+collate.openCR'></span><span id='topic+collate.openCRlist'></span>

<h3>Description</h3>

<p>Estimates from one or more openCR models are formed into an array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'openCR'
collate(object, ..., realnames = NULL, betanames = NULL, 
    newdata = NULL, alpha = 0.05, perm = 1:4, fields = 1:4)

## S3 method for class 'openCRlist'
collate(object, ..., realnames = NULL, betanames = NULL, 
    newdata = NULL, alpha = 0.05, perm = 1:4, fields = 1:4)
    
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="collate_+3A_object">object</code></td>
<td>
<p><code>openCR</code> or <code>openCRlist</code> objects</p>
</td></tr>
<tr><td><code id="collate_+3A_...">...</code></td>
<td>
<p> other <code>openCR</code> objects</p>
</td></tr>
<tr><td><code id="collate_+3A_realnames">realnames</code></td>
<td>
<p> character vector of real parameter names </p>
</td></tr>
<tr><td><code id="collate_+3A_betanames">betanames</code></td>
<td>
<p> character vector of beta parameter names </p>
</td></tr>
<tr><td><code id="collate_+3A_newdata">newdata</code></td>
<td>
<p> optional dataframe of values at which to evaluate models </p>
</td></tr>
<tr><td><code id="collate_+3A_alpha">alpha</code></td>
<td>
<p> alpha level for confidence intervals </p>
</td></tr>
<tr><td><code id="collate_+3A_perm">perm</code></td>
<td>
<p> permutation of dimensions in output </p>
</td></tr>
<tr><td><code id="collate_+3A_fields">fields</code></td>
<td>
<p>vector to restrict summary fields in output </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>collate</code> extracts parameter estimates from a set of fitted openCR
model objects. <code>fields</code> may be used to select a subset of summary
fields (&quot;estimate&quot;,&quot;SE.estimate&quot;,&quot;lcl&quot;,&quot;ucl&quot;) by name or number. 
</p>


<h3>Value</h3>

<p>A 4-dimensional array of model-specific parameter estimates. By default, 
the dimensions correspond respectively to 
</p>

<ul>
<li><p> rows in <code>newdata</code> (usually sessions),
</p>
</li>
<li><p> models,
</p>
</li>
<li><p> statistic fields (estimate, SE.estimate, lcl, ucl), and 
</p>
</li>
<li><p> parameters (&quot;phi&quot;, &quot;sigma&quot; etc.).
</p>
</li></ul>

<p>It often helps to reorder the dimensions with the <code>perm</code> argument.
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+modelAverage.openCR">modelAverage.openCR</a></code>, 
<code><a href="#topic+make.table">make.table</a></code>
</p>

<hr>
<h2 id='cumMove'>
Probability Distribution After Movement
</h2><span id='topic+cumMove'></span><span id='topic+proportionInPolygon'></span>

<h3>Description</h3>

<p>Compute the compounding effect of a random walk defined by a discrete kernel. The number of steps and the edge algorithm are specified by the user. The function was used to generate Fig. 3 of Efford (2022). The final distribution may be summed for points lying within an arbitrary polygon. This is a simple way to compute the expected proportion remaining within a particular region (i.e. not &ldquo;emigrating&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
cumMove(X, mask, kernel, edgemethod = c("truncate", "wrap", "none"), nstep = 1,
 mqarray = NULL, settlecov = NULL)

proportionInPolygon(mask, poly, cov = "pm")

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cumMove_+3A_x">X</code></td>
<td>
<p>initial location(s) (see Details)</p>
</td></tr>
<tr><td><code id="cumMove_+3A_mask">mask</code></td>
<td>
<p>habitat mask</p>
</td></tr>
<tr><td><code id="cumMove_+3A_kernel">kernel</code></td>
<td>
<p>kernel object</p>
</td></tr>
<tr><td><code id="cumMove_+3A_edgemethod">edgemethod</code></td>
<td>
<p>character</p>
</td></tr>
<tr><td><code id="cumMove_+3A_nstep">nstep</code></td>
<td>
<p>non-negative integer</p>
</td></tr>
<tr><td><code id="cumMove_+3A_mqarray">mqarray</code></td>
<td>
<p>integer array of lookup indices</p>
</td></tr>
<tr><td><code id="cumMove_+3A_settlecov">settlecov</code></td>
<td>
<p>character name of covariate of <code>mask</code></p>
</td></tr>
<tr><td><code id="cumMove_+3A_poly">poly</code></td>
<td>
<p>a polygon (see Details)</p>
</td></tr>
<tr><td><code id="cumMove_+3A_cov">cov</code></td>
<td>
<p>character name of covariate of <code>mask</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input <code>X</code> may be -
</p>

<ul>
<li><p> a vector of length 2 for the coordinates of a single point 
</p>
</li>
<li><p> a mask with covariate 'pm' representing the initial distribution
</p>
</li>
<li><p> a SpatialPolygons object from <span class="pkg">sp</span>. Animals are assumed initially to be distributed uniformly across mask points that lie within the polygon.
</p>
</li></ul>

<p>The default edgemethod truncates the kernel at the edge and re-normalizes the cell probabilities so that all destinations lie within the boundary of the mask.
</p>
<p><code>settlecov</code> may name a covariate of <code>mask</code> that has settlement weights in range 0&ndash;1.
</p>
<p>For <code>proportionInPolygon</code>, the input mask may be the output from <code>cumMove</code>. The polygon <code>poly</code> may be specified as for <code><a href="secr.html#topic+pointsInPolygon">pointsInPolygon</a></code> (e.g., SpatialPolygons object or 2-column matrix of coordinates) or as a list with components x and y. A list of polygon specifications is also accepted.
</p>
<p><code>mqarray</code> is computed automatically if not provided. Precomputing the array can save time but is undocumented.
</p>


<h3>Value</h3>

<p>For cumMove - a mask object with initial probability distribution in covariate 'pm0' and final distribution in covariate 'pm'.
</p>
<p>For proportionInPolygon - vector of the summed weights (probabilities) for cells centred in the polygon(s) as a proportion of all non-missing weights.
</p>


<h3>References</h3>

<p>Efford, M. G. (2022) . Efficient discretization of movement kernels for 
spatiotemporal capture&ndash;recapture. <em>Journal of Agricultural, Biological and 
Environmental Statistics</em>. In press. https://doi.org/10.1007/s13253-022-00503-4
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make.kernel">make.kernel</a></code>, 
<code><a href="secr.html#topic+pointsInPolygon">pointsInPolygon</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sp &lt;- 10
msk &lt;- make.mask(nx = 51, ny = 51, type = 'rect', spacing = sp, 
    buffer = 0)
k &lt;- make.kernel('BVN', 20, spacing = sp, move.a = 50, clip = TRUE, 
    sparse = TRUE)

# initial distribution a central point
X &lt;- apply(msk, 2, mean)   
par(mfrow = c(1,4), mar = c(1,1,2,1))
for (step in 0:2) {
    X &lt;- cumMove(X, msk, k, nstep = min(step,1))
    plot(X, cov = 'pm', dots = FALSE, legend = FALSE, breaks = 
        seq(0,0.006,0.0001))
        mtext(side = 3, line = 0, paste('Step', step), cex = 0.9)
    contour(
        x = unique(X$x), 
        y = unique(X$y), 
        z = matrix(covariates(X)$pm, nrow = length(unique(X$x))), 
        levels = c(0.0002), 
        drawlabels = FALSE,
        add = TRUE)
}

## Not run: 
# initial distribution across a polygon
X0 &lt;- matrix(c(200,200,300,300,200,200,300,300,200,200), ncol = 2)
X &lt;- X0
par(mfrow = c(1,4), mar = c(1,1,2,1))
for (step in 0:3) {
    X &lt;- cumMove(X, msk, k, nstep = min(step,1))
    plot(X, cov = 'pm', dots = FALSE, legend = FALSE, breaks = 
        seq(0,0.006,0.0001))
        mtext(side = 3, line = 0, paste('Step', step), cex = 0.9)
    contour(
        x = unique(X$x), 
        y = unique(X$y), 
        z = matrix(covariates(X)$pm, nrow = length(unique(X$x))), 
        levels = c(0.0002), 
        drawlabels = FALSE,
        add = TRUE)
}
polygon(X0)
proportionInPolygon(X, X0)

## End(Not run)

</code></pre>

<hr>
<h2 id='derived'>
Derived Parameters From openCR Models
</h2><span id='topic+derived.openCR'></span><span id='topic+derived.openCRlist'></span><span id='topic+openCR.esa'></span><span id='topic+openCR.pdot'></span>

<h3>Description</h3>

<p>For ..CL openCR models, compute the superpopulation size or density. 
For all openCR models, compute the
time-specific population size or density from the estimated
superpopulation size and the turnover parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'openCR'
derived(object, newdata = NULL, all.levels = FALSE, Dscale = 1, 
    HTbysession = FALSE, ...)
## S3 method for class 'openCRlist'
derived(object, newdata = NULL, all.levels = FALSE, Dscale = 1, 
    HTbysession = FALSE, ...)
openCR.esa(object, bysession = FALSE, stratum = 1)
openCR.pdot(object, bysession = FALSE, stratum = 1)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="derived_+3A_object">object</code></td>
<td>
<p>fitted openCR model</p>
</td></tr>
<tr><td><code id="derived_+3A_newdata">newdata</code></td>
<td>
<p>optional dataframe of values at which to evaluate model</p>
</td></tr>
<tr><td><code id="derived_+3A_all.levels">all.levels</code></td>
<td>
<p>logical; passed to <code><a href="#topic+makeNewData">makeNewData</a></code> if newdata not specified</p>
</td></tr>

<tr><td><code id="derived_+3A_dscale">Dscale</code></td>
<td>
<p>numeric to scale density</p>
</td></tr>
<tr><td><code id="derived_+3A_htbysession">HTbysession</code></td>
<td>
<p>logical; Horvitz-Thompson estimates by session (see Details)</p>
</td></tr>
<tr><td><code id="derived_+3A_...">...</code></td>
<td>
<p>other arguments (not used)</p>
</td></tr>
<tr><td><code id="derived_+3A_bysession">bysession</code></td>
<td>
<p>logical; if TRUE then esa or pdot is computed separately for each session</p>
</td></tr>
<tr><td><code id="derived_+3A_stratum">stratum</code></td>
<td>
<p>integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Derived estimates of density and superD are multiplied by <code>Dscale</code>. Use <code>Dscale = 1e4</code> for animals per 100 sq. km.
<code>openCR.esa</code> and <code>openCR.pdot</code> are used internally by <code>derived.openCR</code>.
</p>
<p>If <code>HTbysession</code> then a separate H-T estimate is derived for each primary session; otherwise a H-T estimate of the superpopulation is used in combination with turnover parameters (phi, beta) to obtain session-specific estimates. Results are often identical.
</p>
<p>The output is an object with its own print method (see <code><a href="#topic+print.derivedopenCR">print.derivedopenCR</a></code>).
</p>
<p>The code does not yet allow user-specified newdata.
</p>


<h3>Value</h3>

<p><code>derived</code> returns an object of class c(&ldquo;derivedopenCR&quot;,&ldquo;list&quot;), list with these components:
</p>
<table role = "presentation">
<tr><td><code>totalobserved</code></td>
<td>
<p>number of different individuals detected</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>character vector; names of parameters in model (excludes derived parameters)</p>
</td></tr>
<tr><td><code>superN</code></td>
<td>
<p>superpopulation size (non-spatial models only)</p>
</td></tr>
<tr><td><code>superD</code></td>
<td>
<p>superpopulation density (spatial models only)</p>
</td></tr>
<tr><td><code>estimates</code></td>
<td>
<p>data frame of counts and estimates</p>
</td></tr>
<tr><td><code>Dscale</code></td>
<td>
<p>numeric multiplier for printing densities</p>
</td></tr>
</table>
<p>If <code>newdata</code> has multiple levels then the value is a list of such objects, one for each level.
</p>
<p><code>openCR.pdot</code> returns a vector of experiment-wide detection
probabilities under the fitted model (one for each detected animal).
</p>
<p><code>openCR.esa</code> returns a vector of effective sampling areas under
the fitted model (one for each detected animal). If 'bysession = TRUE' the 
result is a list with one component per session.
</p>


<h3>Note</h3>

<p>Prior to 1.4.5, openCR.esa did not expand the result for squeezed capture 
histories (freq&gt;1) and did not return a list when bysession = TRUE.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+openCR.fit">openCR.fit</a></code>, <code><a href="#topic+print.derivedopenCR">print.derivedopenCR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

# override default method to get true ML for L1
L1CL &lt;- openCR.fit(ovenCH, type = 'JSSAlCL', method = 'Nelder-Mead')
predict(L1CL)
derived(L1CL)

## compare to above
L1 &lt;- openCR.fit(ovenCH, type = 'JSSAl', method = 'Nelder-Mead')
predict(L1)
derived(L1)


## End(Not run)

</code></pre>

<hr>
<h2 id='dipperCH'>Dippers</h2><span id='topic+dipperCH'></span>

<h3>Description</h3>

<p>Lebreton et al. (1992) demonstrated Cormack-Jolly-Seber methods with a dataset on European Dipper (*Cinclus cinclus*) collected by Marzolin (1988) and the data have been much used since then. Dippers were captured annually over 1981&ndash;1987. We use the version included in the RMark package (Laake 2013).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
dipperCH

</code></pre>


<h3>Format</h3>

<p>The format is a single-session secr capthist object. As these are
non-spatial data, the traps attribute is NULL.
</p>


<h3>Details</h3>

<p>Dippers were sampled in 1981&ndash;1987.
</p>


<h3>Source</h3>

<p>MARK example dataset &lsquo;ed.inp&rsquo;. Also RMark (Laake 2013). See Examples.
</p>


<h3>References</h3>

<p>Laake, J. L. (2013). <em>RMark: An R Interface for Analysis of Capture&ndash;Recapture Data with MARK</em>.
AFSC Processed Report 2013-01, 25p. Alaska Fisheries Science Center, NOAA, 
National Marine Fisheries Service, 7600 Sand Point Way NE, Seattle WA 98115.
</p>
<p>Lebreton, J.-D., Burnham, K. P., Clobert, J., and Anderson,
D. R. (1992) Modeling survival and testing biological hypotheses using
marked animals: a unified approach with case studies. <em>Ecological
Monographs</em> <b>62</b>, 67&ndash;118.
</p>
<p>Marzolin, G. (1988) Polygynie du Cincle plongeur (*Cinclus cinclus*) dans 
les c?tes de Lorraine. <em>L'Oiseau et la Revue Francaise
d'Ornithologie</em> <b>58</b>, 277&ndash;286.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.inp">read.inp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
m.array(dipperCH)

## Not run: 

# From file 'ed.inp' in MARK input format
datadir &lt;- system.file('extdata', package = 'openCR')
dipperCH &lt;- read.inp(paste0(datadir, '/ed.inp'), grouplabel='sex',
    grouplevels = c('Male','Female'))
intervals(dipperCH) &lt;- rep(1,6)    
sessionlabels(dipperCH) &lt;- 1981:1987   # labels only

# or extracted from the RMark package with this code
if (require(RMark)) {
    if (all (nchar(Sys.which(c('mark.exe','mark64.exe', 'mark32.exe'))) &lt; 2))
        stop ("MARK executable not found; set e.g. MarkPath &lt;- 'c:/Mark/'")
    data(dipper)                       # retrieve dataframe of dipper capture histories
    dipperCH2 &lt;- unRMarkInput(dipper)  # convert to secr capthist object
    intervals(dipperCH2) &lt;- rep(1,6)    
    sessionlabels(dipperCH2) &lt;- 1981:1987   # labels only
} else message ("RMark not found")

# The objects dipperCH and dipperCH2 differ in the order of factor levels for 'sex'

## End(Not run)

</code></pre>

<hr>
<h2 id='expected.d'>Expected Distance Moved</h2><span id='topic+expected.d'></span>

<h3>Description</h3>

<p>Movement models in <span class="pkg">openCR</span> differ in their parameterisation so direct 
comparison can be difficult. The expected distance moved is a convenient 
statistic common to all models. This function computes the expected distance 
from various inputs, including fitted models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
expected.d(movementmodel, move.a, move.b, truncate = Inf, mask = NULL, 
    min.d = 1e-4, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expected.d_+3A_movementmodel">movementmodel</code></td>
<td>
<p>character or function or kernel or openCR object</p>
</td></tr>
<tr><td><code id="expected.d_+3A_move.a">move.a</code></td>
<td>
<p>numeric parameter of kernel</p>
</td></tr>
<tr><td><code id="expected.d_+3A_move.b">move.b</code></td>
<td>
<p>numeric parameter of kernel</p>
</td></tr>
<tr><td><code id="expected.d_+3A_truncate">truncate</code></td>
<td>
<p>radius of truncation</p>
</td></tr>
<tr><td><code id="expected.d_+3A_mask">mask</code></td>
<td>
<p>habitat mask object</p>
</td></tr>
<tr><td><code id="expected.d_+3A_min.d">min.d</code></td>
<td>
<p>numeric lower bound of integration (see Details)</p>
</td></tr>
<tr><td><code id="expected.d_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code><a href="#topic+make.kernel">make.kernel</a></code> if input is a fitted model</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input <code>movementmodel</code> may be
</p>

<ul>
<li><p> fitted openCR model
</p>
</li>
<li><p> user kernel function g(r)
</p>
</li>
<li><p> kernel object
</p>
</li>
<li><p> character name of kernel model see <a href="#topic+Movement+20models">Movement models</a> 
</p>
</li></ul>

<p>If <code>truncate</code> (R) is finite or <code>movementmodel</code> is a function then the 
expected value is computed by numerical integration <code class="reqn">E(d) = \int_0^R r.f(r) dr</code>. 
In the event that f(0) is not finite, <code>min.d</code> is used as the lower bound. 
</p>
<p><code>mask</code> is used only for &lsquo;uncorrelated&rsquo; and &lsquo;uncorrelatedzi&rsquo; movement. 
For these models the expected movement is merely the average distance 
between points on the mask, weighted by (1-zi) if zero-inflated (uncorrelatedzi).
</p>
<p>The ... argument is useful for (i) selecting a session from a fitted model, or
(ii) specifying the upper or lower confidence limits from a single-parameter 
fitted model via the &lsquo;stat&rsquo; argument of <code><a href="#topic+make.kernel">make.kernel</a></code>.
</p>


<h3>Value</h3>

<p>A numeric value (zero for 'static' model, NA if model unrecognised).
</p>


<h3>References</h3>

<p>Efford, M. G. and Schofield, M. R. (2022) A review of movement models in open population capture&ndash;recapture. <em>Methods in Ecology and Evolution</em> <b>13</b>, 2106&ndash;2118. https://doi.org/10.1111/2041-210X.13947
</p>


<h3>See Also</h3>

<p><a href="#topic+Movement+20models">Movement models</a>, <code><a href="#topic+make.kernel">make.kernel</a></code>, <code><a href="#topic+pkernel">pkernel</a></code>, <code><a href="#topic+qkernel">qkernel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
expected.d('BVT', move.a = 20, move.b = 1)
expected.d('BVT', move.a = 20, move.b = 1, truncate = 300)

k &lt;- make.kernel(movementmodel = 'BVT', spacing = 10, move.a = 20, move.b = 1)
expected.d(k)

</code></pre>

<hr>
<h2 id='Field+20vole'>Kielder Field Voles</h2><span id='topic+fieldvoleCH'></span>

<h3>Description</h3>

<p>Captures of <em>Microtus agrestis</em> on a large grid in a clearcut within Kielder Forest, northern England, June&ndash;August 2000 (Ergon and Gardner 2014). Robust-design data from four primary sessions of 3&ndash;5 secondary sessions each.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
fieldvoleCH

</code></pre>


<h3>Format</h3>

<p>The format is a multi-session secr capthist object. Attribute &lsquo;ampm&rsquo; codes for type of secondary session (am, pm).
</p>


<h3>Details</h3>

<p>Ergon and Lambin (2013) provided a robust design dataset from a trapping study on field voles <em>Microtus agrestis</em> in a clearcut within Kielder Forest, northern England &ndash; see also Ergon et al. (2011), Ergon and Gardner (2014) and Reich and Gardner (2014). The study aimed to describe sex differences in space-use, survival and dispersal among adult voles. Data were from one trapping grid in summer 2000. 
</p>
<p>Trapping was on a rectangular grid of 192 multi-catch (Ugglan Special) traps at 7-metre spacing. Traps were baited with whole barley grains and carrots; voles were marked with individually numbered ear tags. 
</p>
<p>Four trapping sessions were conducted at intervals of 21 to 23 days between 10 June and 15 August. Traps were checked at about 12 hour intervals (6 am and 6 pm). 
</p>
<p>The attribute &lsquo;ampm&rsquo; is a data.frame with a vector of codes, one per secondary session, to separate am and pm trap checks (1 = evening, 2 = morning). The four primary sessions had respectively 3, 5, 4 and 5 trap checks.
</p>
<p>Ergon and Gardner (2014) restricted their analysis to adult voles (118 females and 40 males). Histories of five voles (ma193, ma239, ma371, ma143, ma348) were censored part way through the study because they died in traps (T. Ergon pers. comm.).
</p>


<h3>Source</h3>

<p>Data were retrieved from DRYAD (Ergon and Lambin (2013) for <span class="pkg">openCR</span>. Code for translating the DRYAD ASCII file into a capthist object is given in Examples.
</p>


<h3>References</h3>

<p>Efford, M. G. (2019) Multi-session models in secr 4.1. <a href="https://www.otago.ac.nz/density/pdfs/secr-multisession.pdf">https://www.otago.ac.nz/density/pdfs/secr-multisession.pdf</a>
</p>
<p>Ergon, T., Ergon, R., Begon, M., Telfer, S. and Lambin, X. (2011) Delayed density-
dependent onset of spring reproduction in a fluctuating population of field
voles. <em>Oikos</em> <b>120</b>, 934&ndash;940.
</p>
<p>Ergon, T. and Gardner, B. (2014) Separating mortality and emigration: modelling space
use, dispersal and survival with robust-design spatial capture&ndash;recapture data. 
<em>Methods in Ecology and Evolution</em> <b>5</b>, 1327&ndash;1336.
</p>
<p>Ergon, T. and Lambin, X. (2013) Data from: Separating mortality and emigration:
Modelling space use, dispersal and survival with robust-design spatial capture&ndash;recapture data.
Dryad Digital Repository. <a href="https://doi.org/10.5061/dryad.r17n5">doi:10.5061/dryad.r17n5</a>.
</p>
<p>Reich, B. J. and Gardner, B. (2014) A spatial capture&ndash;recapture model for
territorial species. <em>Environmetrics</em> <b>25</b>, 630&ndash;637.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
summary(fieldvoleCH, terse = TRUE)
m.array(fieldvoleCH)
JS.counts(fieldvoleCH)

attr(fieldvoleCH, 'ampm')

## Not run: 

maleCH &lt;- subset(fieldvoleCH, function(x) covariates(x) == 'M')
fit &lt;- openCR.fit(maleCH)
predict(fit)

# Read data object from DRYAD ASCII file

datadir &lt;- system.file('extdata', package = 'openCR')
EG &lt;- dget(paste0(datadir,'/ergonandgardner2013.rdat'))

# construct capthist object
onesession &lt;- function (sess) {
    mat &lt;- EG$H[,,sess]
    id &lt;- as.numeric(row(mat))
    occ &lt;- as.numeric(col(mat))
    occ[mat&lt;0] &lt;- -occ[mat&lt;0]
    trap &lt;- abs(as.numeric(mat)) 
    matrow &lt;- rownames(mat)
    df &lt;- data.frame(session = rep(sess, length(id)), 
                     ID = matrow[id], 
                     occ = occ, 
                     trapID = trap,
                     sex = c('F','M')[EG$gr],
                     row.names = 1:length(id))
    # retain captures (trap&gt;0)
    df[df$trapID&gt;0, , drop = FALSE]
}
tr &lt;- read.traps(data = data.frame(EG$X), detector = "multi")

# recode matrix as mixture of zeros and trap numbers
EG$H &lt;- EG$H-1

# code censored animals with negative trap number
# two ways to recognise censoring
censoredprimary &lt;- which(EG$K &lt; 4)
censoredsecondary &lt;- which(apply(EG$J,1,function(x) any(x-c(3,5,4,5) &lt; 0)))
censored &lt;- unique(c(censoredprimary, censoredsecondary))
rownames(EG$H)[censored]
# [1] "ma193" "ma239" "ma371" "ma143" "ma348"
censorocc &lt;- apply(EG$H[censored,,], 1, function(x) which.max(cumsum(x)))
censor3 &lt;- ((censorocc-1) %/% 5)+1       # session
censor2 &lt;- censorocc - (censor3-1) * 5   # occasion within session
censori &lt;- cbind(censored, censor2, censor3)
EG$H[censori] &lt;- -EG$H[censori] 

lch &lt;- lapply(1:4, onesession)
ch &lt;- make.capthist(do.call(rbind,lch), tr=tr, covnames='sex')

# apply intervals in months
intervals(ch) &lt;-  EG$dt

fieldvoleCH &lt;- ch

# extract time covariate - each secondary session was either am (2) or pm (1)
# EG$tod
# 1 2 3  4  5
# 1 2 1 2 NA NA
# 2 2 1 2  1  1
# 3 2 1 2  1 NA
# 4 2 1 2  1  2
# Note consecutive pm trap checks in session 2
ampm &lt;- split(EG$tod, 1:4)
ampm &lt;- lapply(ampm, na.omit)
attr(fieldvoleCH, 'ampm') &lt;- data.frame(ampm = unlist(ampm))


## End(Not run)

</code></pre>

<hr>
<h2 id='gonodontisCH'>Gonodontis Moths</h2><span id='topic+gonodontisCH'></span>

<h3>Description</h3>

<p>Non-spatial open-population capture&ndash;recapture data of Bishop et al. (1978) for nonmelanic male <em>Gonodontis bidentata</em> at Cressington Park, northwest England.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gonodontisCH</code></pre>


<h3>Format</h3>

<p>The format is a single-session secr capthist object. As these are
non-spatial data, the traps attribute is NULL.
</p>


<h3>Details</h3>

<p>The data are from a study of the relative fitness of melanic and
nonmelanic morphs of the moth <em>Gonodontis bidentata</em> at several
sites in England (Bishop et al. 1978). Crosbie (1979; see also Crosbie
and Manly 1985) selected a subset of the Bishop et al. data (nonmelanic
males from Cressington Park) to demonstrate innovations in Jolly-Seber
modelling, and the same data were used by Link and Barker (2005) and
Schofield and Barker (2008). The present data are those used by Crosbie
(1979) and Link and Barker (2005). 
</p>
<p>Male moths were attracted to traps which consisted of a cage containing phermone-producing females surrounded by an enclosure which the males could enter but not leave. New virgin females were usually added every 1 to 4 days. Moths were marked at each capture with a date-specific mark in enamel paint or felt-tip pen on the undersurface of the wing. Thus, although moths at Cressington Park were not marked individually, each moth was a flying bearer of its own capture history.
</p>
<p>The data comprise 689 individual capture histories for moths captured at 8 traps operated over 17 days (24 May&ndash;10 June 1970). The traps were in a square that appears have been about 40 m on a side. The location of captures is not included in the published data. All captured moths appear to have been marked and released (i.e. there were no removals recorded). All captures on Day 17 were recaptures; it is possible that unmarked moths were not recorded on that day.  
</p>
<p>Both Table 1 and Appendix 1 (microfiche) of Bishop et al. (1978) refer to 690 capture histories of nonmelanics at Cressington Park. In the present data there are only 689, and there are other minor discrepancies. Also, Crosbie and Manly (1985: Table 1) refer to 82 unique capture histories (&ldquo;distinct cmr patterns&rdquo;) when there are only 81 in the present dataset (note that two moths share 00000000000000011).
</p>


<h3>Source</h3>

<p>Richard Barker provided an electronic copy of the data used by Link and Barker (2005), copied from Crosbie (1979).
</p>


<h3>References</h3>

<p>Bishop, J. A., Cook, L. M., and Muggleton, J. (1978). The response of two species of moth to
industrialization in northwest England. II. Relative fitness of morphs
and population size. <em>Philosophical Transactions of the Royal Society of London</em>
<b>B281</b>, 517&ndash;540.
</p>
<p>Crosbie, S. F. (1979) <em>The mathematical modelling of capture&ndash;mark&ndash;recapture experiments on animal populations</em>. Ph.D. Thesis, University of Otago, Dunedin, New Zealand.
</p>
<p>Crosbie, S. F. and Manly, B. F. J. (1985) Parsimonious modelling of capture&ndash;mark&ndash;recapture studies.
<em>Biometrics</em> <b>41</b>, 385&ndash;398.
</p>
<p>Link, W. A. and Barker, R. J. (2005) Modeling association among demographic parameters
in analysis of open-population capture&ndash;recapture data. <em>Biometrics</em> <b>61</b>, 46&ndash;54.
</p>
<p>Schofield, M. R. and Barker, R. J. (2008) A unified capture&ndash;recapture framework. <em>Journal of Agricultural
Biological and Environmental Statistics</em> <b>13</b>, 458&ndash;477.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
summary(gonodontisCH)
m.array(gonodontisCH)

## Not run: 
# compare default (CJS) estimates from openCR, MARK

fit &lt;- openCR.fit(gonodontisCH)
predict(fit)

if (require(RMark)) {
    MarkPath &lt;- 'c:/Mark/'   # customize as needed
    if (!all (nchar(Sys.which(c('mark.exe','mark64.exe', 'mark32.exe'))) &lt; 2)) {
       mothdf &lt;- RMarkInput(gonodontisCH)
       mark(mothdf)
       cleanup(ask = FALSE)
    } else message ("mark.exe not found")
} else message ("RMark not found")


## End(Not run)

</code></pre>

<hr>
<h2 id='Internal'>Internal Functions</h2><span id='topic+prwi'></span><span id='topic+prwisecr'></span><span id='topic+PCH1'></span><span id='topic+PCH1secr'></span><span id='topic+pradelloglik'></span><span id='topic+cyclic.fit'></span>

<h3>Description</h3>

 
<p>Functions called by <code>openCR.fit</code> when <code>details$R == TRUE</code>, and some others 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
prwi (type, n, x, jj, cumss, nmix, w, fi, li, openval, PIA, PIAJ, intervals, CJSp1)

prwisecr (type, n, x, nc, jj, kk, mm, nmix, cumss, w, fi, li, gk, openval, 
    PIA, PIAJ, binomN, Tsk, intervals, h, hindex, CJSp1, moveargsi, 
    movementcode, sparsekernel, edgecode, usermodel, kernel = NULL, 
    mqarray = NULL, cellsize = NULL, r0)

PCH1 (type, x, nc, cumss, nmix, openval0, PIA0, PIAJ, intervals)

PCH1secr (type, individual, x, nc, jj, cumss, kk, mm, openval0, PIA0, PIAJ, gk0,
    binomN, Tsk, intervals,  moveargsi, movementcode, sparsekernel, edgecode, 
    usermodel, kernel, mqarray, cellsize, r0) 

pradelloglik (type, w, openval, PIAJ, intervals)

cyclic.fit (..., maxcycle = 10, tol = 1e-5, trace = FALSE) 

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Internal_+3A_type">type</code></td>
<td>
<p>character</p>
</td></tr>
<tr><td><code id="Internal_+3A_n">n</code></td>
<td>
<p>integer index of capture history</p>
</td></tr>
<tr><td><code id="Internal_+3A_x">x</code></td>
<td>
<p>integer index of latent class</p>
</td></tr>
<tr><td><code id="Internal_+3A_jj">jj</code></td>
<td>
<p>integer number of primary sessions</p>
</td></tr>
<tr><td><code id="Internal_+3A_cumss">cumss</code></td>
<td>
<p>integer vector cumulative number of secondary sessions at start of 
each primary session</p>
</td></tr>
<tr><td><code id="Internal_+3A_nmix">nmix</code></td>
<td>
<p>integer number of latent classes</p>
</td></tr>
<tr><td><code id="Internal_+3A_w">w</code></td>
<td>
<p>array of capture histories</p>
</td></tr>
<tr><td><code id="Internal_+3A_fi">fi</code></td>
<td>
<p>integer first primary session</p>
</td></tr>
<tr><td><code id="Internal_+3A_li">li</code></td>
<td>
<p>integer last primary session</p>
</td></tr>
<tr><td><code id="Internal_+3A_openval">openval</code></td>
<td>
<p>dataframe of real parameter values (one unique combination per row)</p>
</td></tr>
<tr><td><code id="Internal_+3A_pia">PIA</code></td>
<td>
<p>parameter index array (secondary sessions)</p>
</td></tr>
<tr><td><code id="Internal_+3A_piaj">PIAJ</code></td>
<td>
<p>parameter index array (primary sessions)</p>
</td></tr>
<tr><td><code id="Internal_+3A_intervals">intervals</code></td>
<td>
<p>integer vector</p>
</td></tr>
<tr><td><code id="Internal_+3A_h">h</code></td>
<td>
<p>numeric 3-D array of hazard (mixture, mask position, hindex)</p>
</td></tr>
<tr><td><code id="Internal_+3A_hindex">hindex</code></td>
<td>
<p>integer n x s matrix indexing h for each individual, secondary session</p>
</td></tr>
<tr><td><code id="Internal_+3A_cjsp1">CJSp1</code></td>
<td>
<p>logical; should CJS likelihood include first primary session?</p>
</td></tr>
<tr><td><code id="Internal_+3A_moveargsi">moveargsi</code></td>
<td>
<p>integer 2-vector for index of move.a, move.b (negative if unused)</p>
</td></tr>
<tr><td><code id="Internal_+3A_movementcode">movementcode</code></td>
<td>
<p>integer 0 static, 1 uncorrelated etc.</p>
</td></tr>
<tr><td><code id="Internal_+3A_sparsekernel">sparsekernel</code></td>
<td>
<p>logical; if TRUE then only cardinal and intercardinal axes are included</p>
</td></tr>
<tr><td><code id="Internal_+3A_edgecode">edgecode</code></td>
<td>
<p>integer 0 none, 1 wrap, 2 truncate</p>
</td></tr>
<tr><td><code id="Internal_+3A_usermodel">usermodel</code></td>
<td>
<p>function to fill kernel</p>
</td></tr>
<tr><td><code id="Internal_+3A_kernel">kernel</code></td>
<td>
<p>dataframe with columns x,y relative coordinates of kernel cell centres</p>
</td></tr>
<tr><td><code id="Internal_+3A_mqarray">mqarray</code></td>
<td>
<p>integer matrix</p>
</td></tr>
<tr><td><code id="Internal_+3A_cellsize">cellsize</code></td>
<td>
<p>numeric length of side of kernel cell</p>
</td></tr>
<tr><td><code id="Internal_+3A_r0">r0</code></td>
<td>
<p>numeric; effective radius of zero cell for movement models (usually 0.5)</p>
</td></tr>
<tr><td><code id="Internal_+3A_gk">gk</code></td>
<td>
<p>real array</p>
</td></tr>
<tr><td><code id="Internal_+3A_tsk">Tsk</code></td>
<td>
<p>array detector usage</p>
</td></tr>
<tr><td><code id="Internal_+3A_openval0">openval0</code></td>
<td>
<p>openval for naive animals</p>
</td></tr>
<tr><td><code id="Internal_+3A_pia0">PIA0</code></td>
<td>
<p>PIA for naive animals</p>
</td></tr>
<tr><td><code id="Internal_+3A_individual">individual</code></td>
<td>
<p>logical; TRUE if model uses individual covariates</p>
</td></tr>
<tr><td><code id="Internal_+3A_gk0">gk0</code></td>
<td>
<p>gk for naive animals</p>
</td></tr>
<tr><td><code id="Internal_+3A_nc">nc</code></td>
<td>
<p>number of capture histories</p>
</td></tr>
<tr><td><code id="Internal_+3A_kk">kk</code></td>
<td>
<p>number of detectors</p>
</td></tr>
<tr><td><code id="Internal_+3A_mm">mm</code></td>
<td>
<p>number of points on habitat mask</p>
</td></tr>
<tr><td><code id="Internal_+3A_binomn">binomN</code></td>
<td>
<p>code for distribution of counts (see <code><a href="secr.html#topic+secr.fit">secr.fit</a></code>)</p>
</td></tr>
<tr><td><code id="Internal_+3A_...">...</code></td>
<td>
<p>named arguments passed to <code><a href="#topic+openCR.fit">openCR.fit</a></code> or <code>predict</code> (see extractFocal)</p>
</td></tr>
<tr><td><code id="Internal_+3A_maxcycle">maxcycle</code></td>
<td>
<p>integer maximum number of cycles (maximizations of a given parameter)</p>
</td></tr>
<tr><td><code id="Internal_+3A_tol">tol</code></td>
<td>
<p>absolute tolerance for improvement in log likelihood</p>
</td></tr>
<tr><td><code id="Internal_+3A_trace">trace</code></td>
<td>
<p>logical; if TRUE a status message is given at each maximization</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>cyclic.fit</code> implements cyclic fixing more or less as described by
Schwarz and Arnason (1996) and used by Pledger et al. (2010). The
intention is to speed up maximization when there are many (beta)
parameters. However, fitting is slower than with a single call to
<code><a href="#topic+openCR.fit">openCR.fit</a></code>, and the function is here only as a curiosity
(it is not exported in 1.2.0).
</p>


<h3>Value</h3>

<p><code>cyclic.fit</code> returns a fitted model object of class &lsquo;openCR&rsquo;.
</p>
<p>Other functions return numeric components of the log likelihood.
</p>


<h3>References</h3>

<p>Pledger, S., Pollock, K. H. and Norris, J. L. (2010) Open
capture&ndash;recapture models with heterogeneity: II. Jolly-Seber
model. <em>Biometrics</em> <b>66</b>, 883&ndash;890.
</p>
<p>Schwarz, C. J. and Arnason, A. N. (1996) A general methodology for the
analysis of capture-recapture experiments in open
populations. <em>Biometrics</em> <b>52</b>, 860&ndash;873.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+openCR.fit">openCR.fit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

openCR:::cyclic.fit(capthist = dipperCH, model = list(p~t, phi~t), tol = 1e-5, trace = TRUE)


## End(Not run)

</code></pre>

<hr>
<h2 id='JS.counts'>Summarise Non-spatial Open-population Data</h2><span id='topic+JS.counts'></span><span id='topic+m.array'></span><span id='topic+bd.array'></span>

<h3>Description</h3>

<p>Simple conventional summaries of data held in secr &lsquo;capthist&rsquo; objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
JS.counts(object, primary.only = TRUE, stratified = FALSE)
m.array(object, primary.only = TRUE, never.recaptured = TRUE, 
    last.session = TRUE, stratified = FALSE)
bd.array(beta, phi)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="JS.counts_+3A_object">object</code></td>
<td>
<p>secr capthist object or similar</p>
</td></tr>
<tr><td><code id="JS.counts_+3A_primary.only">primary.only</code></td>
<td>
<p>logical; if TRUE then counts are tabuated for primary sessions </p>
</td></tr>
<tr><td><code id="JS.counts_+3A_stratified">stratified</code></td>
<td>
<p>logical; if TRUE then sessions of multisession object summarised separately </p>
</td></tr>
<tr><td><code id="JS.counts_+3A_never.recaptured">never.recaptured</code></td>
<td>
<p>logical; if TRUE then a column is added for animals never recaptured </p>
</td></tr>
<tr><td><code id="JS.counts_+3A_last.session">last.session</code></td>
<td>
<p>logical; if TRUE releases are reported for the last session</p>
</td></tr>
<tr><td><code id="JS.counts_+3A_beta">beta</code></td>
<td>
<p>numeric vector of entry probabilities, one per primary session</p>
</td></tr>
<tr><td><code id="JS.counts_+3A_phi">phi</code></td>
<td>
<p>numeric vector of survival probabilities, one per primary session</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input is a capthist object representing a multi-session capture&ndash;recapture study. This may be (i) a single-session capthist in which occasions are understood to represent primary sessions, or (ii) a multi-session capthist object that is automatically converted to a single session object with <code><a href="secr.html#topic+join">join</a></code> (any secondary sessions (occasions) are first collapsed with <code>reduce(object, by = 'all')</code>*, or (iii) a multi-session capthist object in which sessions are interpreted as strata.
</p>
<p>The argument <code>primary.only</code> applies for single-session input with a robust-design structure defined by the <code><a href="secr.html#topic+intervals">intervals</a></code>. <code>last.session</code> results in a final row with no recaptures.
</p>
<p>If the covariates attribute of <code>object</code> includes a column named &lsquo;freq&rsquo; then this is used to expand the capture histories.
</p>
<p>Conventional Jolly&ndash;Seber estimates may be computed with <code><a href="#topic+JS.direct">JS.direct</a></code>.
</p>
<p><code>bd.array</code> computes the probability of each possible combination of birth and death times (strictly, the primary session at which an animal was first and last available for detection), given the parameter vectors beta and phi. These cell probabilities are integral to JSSA models.
</p>
<p>* this may fail with nonspatial data.
</p>


<h3>Value</h3>

<p>For <code>JS.counts</code>, a data.frame where rows correspond to sessions and columns hold counts as follows &ndash;
</p>
<table role = "presentation">
<tr><td><code>n</code></td>
<td>
<p>number of individuals detected</p>
</td></tr>
<tr><td><code>R</code></td>
<td>
<p>number of individuals released</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>number of previously marked individuals</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p>number of released individuals detected in later sessions</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>number known to be alive (detected before and after) but not detected in current session</p>
</td></tr>
</table>
<p>For <code>m.array</code>, a table object with rows corresponding to release cohorts and columns  corresponding to first&ndash;recapture sessions. The size of the release cohort is shown in the first column. Cells in the lower triangle have value NA and print as blank by default.
</p>


<h3>See Also</h3>

<p><code><a href="secr.html#topic+join">join</a></code>, <code><a href="#topic+JS.direct">JS.direct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
JS.counts(ovenCH)
m.array(ovenCH)

## Not run: 

## probabilities of b,d pairs
fit &lt;- openCR.fit(ovenCH, type = 'JSSAbCL')
beta &lt;- predict(fit)$b$estimate
phi &lt;- predict(fit)$phi$estimate
bd.array(beta, phi)


## End(Not run)

</code></pre>

<hr>
<h2 id='JS.direct'>Jolly&ndash;Seber Estimates</h2><span id='topic+JS.direct'></span>

<h3>Description</h3>

<p>Non-spatial open-population estimates using the conventional closed-form Jolly&ndash;Seber estimators (Pollock et al. 1990).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
JS.direct(object)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="JS.direct_+3A_object">object</code></td>
<td>
<p>secr capthist object or similar</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimates are the session-specific Jolly-Seber estimates with no constraints.
</p>
<p>The reported SE of births (B) differ slightly from those in Pollock et al. (1990), and may be in error.
</p>


<h3>Value</h3>

<p>A dataframe in which the first 5 columns are summary statistics (counts from <code><a href="#topic+JS.counts">JS.counts</a></code>) and the remaining columns are estimates:  
</p>
<table role = "presentation">
<tr><td><code>p</code></td>
<td>
<p>capture probability</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>population size</p>
</td></tr>
<tr><td><code>phi</code></td>
<td>
<p>probability of survival to next sample time</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>number of recruits at next sample time</p>
</td></tr>
</table>
<p>Standard errors are in fields prefixed &lsquo;se&rsquo;; for N and B these include only sampling variation and omit population stochasticity. The covariance of successive phi-hat is in the field &lsquo;covphi&rsquo;.
</p>


<h3>References</h3>

<p>Pollock, K. H., Nichols, J. D., Brownie, C. and Hines, J. E. (1990) Statistical inference for capture&ndash;recapture experiments. <em>Wildlife Monographs</em> <b>107</b>. 97pp. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+JS.counts">JS.counts</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# cf Pollock et al. (1990) Table 4.8
JS.direct(microtusCH)

</code></pre>

<hr>
<h2 id='LLsurface'>Plot Likelihood Surface</h2><span id='topic+LLsurface'></span><span id='topic+LLsurface.openCR'></span>

<h3>Description</h3>

<p>Calculate log likelihood over a grid of values of two beta parameters
from a fitted openCR model and optionally make an approximate contour plot of the log
likelihood surface.
</p>
<p>This is a method for the generic function <code>LLsurface</code> defined in <span class="pkg">secr</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'openCR'
LLsurface(object, betapar = c("phi", "sigma"), xval = NULL, yval = NULL, 
   centre = NULL, realscale = TRUE, plot = TRUE, plotfitted = TRUE, ncores = NULL, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LLsurface_+3A_object">object</code></td>
<td>
<p><code>openCR</code> object output from <code>openCR.fit</code></p>
</td></tr>
<tr><td><code id="LLsurface_+3A_betapar">betapar</code></td>
<td>
<p>character vector giving the names of two beta parameters</p>
</td></tr>
<tr><td><code id="LLsurface_+3A_xval">xval</code></td>
<td>
<p>vector of numeric values for x-dimension of grid</p>
</td></tr>
<tr><td><code id="LLsurface_+3A_yval">yval</code></td>
<td>
<p>vector of numeric values for y-dimension of grid</p>
</td></tr>
<tr><td><code id="LLsurface_+3A_centre">centre</code></td>
<td>
<p>  vector of central values for all beta parameters</p>
</td></tr>
<tr><td><code id="LLsurface_+3A_realscale">realscale</code></td>
<td>
<p>logical. If TRUE input and output of x and y is on
the untransformed (inverse-link) scale.</p>
</td></tr>
<tr><td><code id="LLsurface_+3A_plot">plot</code></td>
<td>
<p>logical. If TRUE a contour plot is produced</p>
</td></tr>
<tr><td><code id="LLsurface_+3A_plotfitted">plotfitted</code></td>
<td>
<p>logical. If TRUE the MLE from <code>object</code> is shown on the plot (+)</p>
</td></tr>
<tr><td><code id="LLsurface_+3A_ncores">ncores</code></td>
<td>
<p>integer number of cores available for parallel processing</p>
</td></tr>
<tr><td><code id="LLsurface_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code><a href="graphics.html#topic+contour">contour</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>centre</code> is set by default to the fitted values of the beta
parameters in <code>object</code>. This has the effect of holding parameters
other than those in <code>betapar</code> at their fitted values.
</p>
<p>If <code>xval</code> or <code>yval</code> is not provided then 11 values are set at
equal spacing between 0.8 and 1.2 times the values in <code>centre</code> (on
the &lsquo;real&rsquo; scale if <code>realscale</code> = TRUE and on the &lsquo;beta&rsquo; scale
otherwise).
</p>
<p>Contour plots may be customized by passing graphical parameters through
the ... argument.
</p>
<p>The value of <code>ncores</code> is passed to <code>openCR.fit</code>.
</p>


<h3>Value</h3>

<p>Invisibly returns a matrix of the log likelihood evaluated at each
grid point
</p>


<h3>Note</h3>

<p><code>LLsurface.openCR</code> works for named &lsquo;beta&rsquo; parameters rather than
&lsquo;real&rsquo; parameters. The default <code>realscale = TRUE</code> only works for
beta parameters that share the name of the real parameter to which
they relate i.e. the beta parameter for the base level of the real
parameter. This is because link functions are defined for real
parameters not beta parameters.
</p>
<p>Handling of multiple threads was changed in version 1.5.0 to align 
with <code><a href="secr.html#topic+LLsurface.secr">LLsurface.secr</a></code>.
</p>
<p>The contours are approximate because they rely on interpolation. 
</p>


<h3>See Also</h3>

<p><code><a href="secr.html#topic+LLsurface.secr">LLsurface.secr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# not yet

</code></pre>

<hr>
<h2 id='make.kernel'>Discrete Movement Kernel</h2><span id='topic+make.kernel'></span><span id='topic+plot.kernel'></span><span id='topic+summary.kernel'></span>

<h3>Description</h3>

<p>Functions to create, plot and summarise a discrete representation of a movement kernel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
make.kernel(movementmodel = c("BVN", "BVE", "BVC", "BVT","RDE", "RDG", "RDL", "UNI"), 
    kernelradius = 10, spacing, move.a, move.b, 
    sparsekernel = FALSE, clip = FALSE, normalize = TRUE,     
    stat = c('estimate','lcl', 'ucl'), session = 1, r0 = 1/sqrt(pi), ...)

## S3 method for class 'kernel'
plot(x, type = "kernel", contour = FALSE, levels = NULL, text = FALSE,
    title = NULL, add = FALSE, xscale = 1, ...)

## S3 method for class 'kernel'
summary(object, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make.kernel_+3A_movementmodel">movementmodel</code></td>
<td>
<p>character or function or openCR object</p>
</td></tr>
<tr><td><code id="make.kernel_+3A_kernelradius">kernelradius</code></td>
<td>
<p>integer radius of kernel in grid cells</p>
</td></tr>
<tr><td><code id="make.kernel_+3A_spacing">spacing</code></td>
<td>
<p>numeric spacing between cell centres</p>
</td></tr>
<tr><td><code id="make.kernel_+3A_move.a">move.a</code></td>
<td>
<p>numeric parameter of kernel</p>
</td></tr>
<tr><td><code id="make.kernel_+3A_move.b">move.b</code></td>
<td>
<p>numeric parameter of kernel</p>
</td></tr>
<tr><td><code id="make.kernel_+3A_sparsekernel">sparsekernel</code></td>
<td>
<p>logical; if TRUE then only cardinal and intercardinal axes are included</p>
</td></tr>
<tr><td><code id="make.kernel_+3A_clip">clip</code></td>
<td>
<p>logical; if TRUE then corner cells are removed</p>
</td></tr>
<tr><td><code id="make.kernel_+3A_normalize">normalize</code></td>
<td>
<p>logical; if TRUE then cell values are divided by their sum</p>
</td></tr>
<tr><td><code id="make.kernel_+3A_stat">stat</code></td>
<td>
<p>character; predicted statistic to use for move.a (openCR object only) </p>
</td></tr>
<tr><td><code id="make.kernel_+3A_session">session</code></td>
<td>
<p>integer; session for move.a, move.b if input is fitted model</p>
</td></tr>
<tr><td><code id="make.kernel_+3A_r0">r0</code></td>
<td>
<p>numeric; effective radius of zero cell for movement models</p>
</td></tr>
<tr><td><code id="make.kernel_+3A_x">x</code></td>
<td>
<p>kernel object from <code>make.kernel</code></p>
</td></tr>
<tr><td><code id="make.kernel_+3A_type">type</code></td>
<td>
<p>character; plot style (see Details)</p>
</td></tr>
<tr><td><code id="make.kernel_+3A_contour">contour</code></td>
<td>
<p>logical; if TRUE then contour lines are overlaid on any plot</p>
</td></tr>
<tr><td><code id="make.kernel_+3A_levels">levels</code></td>
<td>
<p>numeric vector of contour levels</p>
</td></tr>
<tr><td><code id="make.kernel_+3A_text">text</code></td>
<td>
<p>logical; if TRUE then cell probabilities are overprinted, rounded to 3 d.p.</p>
</td></tr>
<tr><td><code id="make.kernel_+3A_title">title</code></td>
<td>
<p>character; if NULL a title is constructed automatically</p>
</td></tr>
<tr><td><code id="make.kernel_+3A_add">add</code></td>
<td>
<p>logical; if TRUE a line is added to an existing plot (types &quot;gr&quot;, &quot;fr&quot;, &quot;Fr&quot;)</p>
</td></tr>
<tr><td><code id="make.kernel_+3A_xscale">xscale</code></td>
<td>
<p>numeric multiplier for distance axis (0.001 for distances in km)</p>
</td></tr>
<tr><td><code id="make.kernel_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code><a href="#topic+predict.openCR">predict.openCR</a></code> (<code>make.kernel</code>) or
<code><a href="secr.html#topic+plot.mask">plot.mask</a></code> (plot type &quot;kernel&quot;) or <code><a href="graphics.html#topic+lines">lines</a></code> ( plot types &quot;gr&quot;, &quot;fr&quot;, &quot;Fr&quot;) (not used by summary method)</p>
</td></tr>
<tr><td><code id="make.kernel_+3A_object">object</code></td>
<td>
<p>kernel object from <code>make.kernel</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>A kernel object is a type of mask with cell probabilities stored in the covariate &lsquo;kernelp&rsquo;. All kernels are truncated at kernelradius x spacing.
</p>
<p>The <code>movementmodel</code> may also be a function or a previously fitted openCR model that includes movement. If a fitted openCR object, parameter values and kernel attributes are derived from that object and other arguments are ignored.
</p>
<p>The parameter &lsquo;move.a&rsquo; is a scale parameter in metres, except for the UNIzi and INDzi models for which it is the zero-inflation parameter (&lsquo;move.b&rsquo; is the zero-inflation parameter for BVNzi, BVEzi and RDEzi). 
</p>
<p>'Sparse' kernels include only those grid cells that lie on 4 axes (N-S, E-W, NW-SE, NE-SW); cell probabilities are adjusted to maintain nearly the same distance distribution as the non-sparse equivalents.
</p>
<p>Movement models are listed in <a href="#topic+Movement+20models">Movement models</a> and further described in the vignettes <a href="../doc/openCR-vignette.pdf">openCR-vignette.pdf</a>.
</p>
<p>Plot type may be one or more of &ndash;
</p>

<table>
<tr>
 <td style="text-align: left;">
`kernel' </td><td style="text-align: left;"> </td><td style="text-align: left;"> coloured 2-D depiction </td>
</tr>
<tr>
 <td style="text-align: left;">
`gr' </td><td style="text-align: left;"> </td><td style="text-align: left;"> cross-section through the origin of <code class="reqn">g(r)</code> (the 2-D kernel) </td>
</tr>
<tr>
 <td style="text-align: left;">
`fr' </td><td style="text-align: left;"> </td><td style="text-align: left;"> continuous probability density <code class="reqn">f(r)</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
`Fr' </td><td style="text-align: left;"> </td><td style="text-align: left;"> cumulative probability distribution <code class="reqn">F(r)</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Type &ldquo;kernel&quot; by default includes an informative title with font size from the graphical parameter &lsquo;cex.main&rsquo;. Set <code>title = ""</code> to suppress the title.
</p>
<p>Useful properties of theoretical (not discretized) kernels may be recovered with <code><a href="#topic+matchscale">matchscale</a></code>, <code><a href="#topic+pkernel">pkernel</a></code>, <code><a href="#topic+dkernel">dkernel</a></code> and <code><a href="#topic+qkernel">qkernel</a></code>.
</p>
<p>The obscure argument <code>r0</code> controls the value assigned to the central cell of a discretized kernel. For positive <code>r0</code> the value is F(r0*cellsize), where F is the cumulative probability distribution of distance moved. Otherwise the cell is assigned the value g(0)*cellarea, where g() is the 2-D kernel probability density (this fails where g(0) is undefined or infinite).
</p>


<h3>Value</h3>

<p><code>make.kernel</code> returns an object of class c('kernel','mask','data.frame').
</p>
<p>The kernel object has attributes: 
</p>

<table>
<tr>
 <td style="text-align: left;">
Attribute </td><td style="text-align: left;"> Description </td>
</tr>
<tr>
 <td style="text-align: left;">
movementmodel </td><td style="text-align: left;"> saved input </td>
</tr>
<tr>
 <td style="text-align: left;">
K2 </td><td style="text-align: left;"> saved kernelradius </td>
</tr>
<tr>
 <td style="text-align: left;">
move.a </td><td style="text-align: left;"> saved input </td>
</tr>
<tr>
 <td style="text-align: left;">
move.b </td><td style="text-align: left;"> saved input </td>
</tr>
<tr>
 <td style="text-align: left;">
distribution </td><td style="text-align: left;"> empirical cumulative distribution function </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The empirical cumulative distribution is a dataframe with columns for the sorted cell radii &lsquo;r&rsquo; and the 
associated cumulative probability &lsquo;cumprob&rsquo; (one row per cell).
</p>
<p><code>summary.kernel</code> returns an object with these components, displayed with the corresponding print method.
</p>

<table>
<tr>
 <td style="text-align: left;">
Component </td><td style="text-align: left;"> Description </td>
</tr>
<tr>
 <td style="text-align: left;">
k2        </td><td style="text-align: left;"> kernel radius in mask cells </td>
</tr>
<tr>
 <td style="text-align: left;">
spacing   </td><td style="text-align: left;"> cell width </td>
</tr>
<tr>
 <td style="text-align: left;">
ncells    </td><td style="text-align: left;"> number of cells in kernel </td>
</tr>
<tr>
 <td style="text-align: left;">
movementmodel </td><td style="text-align: left;"> movement model code </td>
</tr>
<tr>
 <td style="text-align: left;">
move.a    </td><td style="text-align: left;"> first (scale) parameter </td>
</tr>
<tr>
 <td style="text-align: left;">
move.b    </td><td style="text-align: left;"> second (shape) parameter </td>
</tr>
<tr>
 <td style="text-align: left;">
mu        </td><td style="text-align: left;"> mean of logs (RDL only; from move.a) </td>
</tr>
<tr>
 <td style="text-align: left;">
s         </td><td style="text-align: left;"> SD of logs (RDL only; from move.b) </td>
</tr>
<tr>
 <td style="text-align: left;">
expectedmove </td><td style="text-align: left;"> mean movement (untruncated) </td>
</tr>
<tr>
 <td style="text-align: left;">
expectedmovetr </td><td style="text-align: left;"> mean movement (trucated at kernel radius) </td>
</tr>
<tr>
 <td style="text-align: left;">
expectedmoveemp </td><td style="text-align: left;"> mean computed directly from kernel cell values as sum(r.p) </td>
</tr>
<tr>
 <td style="text-align: left;">
ptruncated    </td><td style="text-align: left;"> proportion of theoretical distribution truncated at radius </td>
</tr>
<tr>
 <td style="text-align: left;">
expectedq50   </td><td style="text-align: left;"> theoretical (untruncated) median </td>
</tr>
<tr>
 <td style="text-align: left;">
expectedq90   </td><td style="text-align: left;"> theoretical (untruncated) 90th percentile </td>
</tr>
<tr>
 <td style="text-align: left;">
expectedq50tr </td><td style="text-align: left;"> theoretical truncated median </td>
</tr>
<tr>
 <td style="text-align: left;">
expectedq90tr </td><td style="text-align: left;"> theoretical truncated 90th percentile</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The empirical mean in <code>expectedmoveemp</code> is usually the most pertinent property of a fitted kernel.
</p>


<h3>Note</h3>

<p>The plot method for kernels supercedes the function <code>plotKernel</code> that has been removed.
</p>


<h3>References</h3>

<p>Clark, J. S, Silman, M., Kern, R., Macklin, E. and HilleRisLambers, J. (1999) Seed dispersal near and far: patterns across temperate and tropical forests. <em>Ecology</em> <b>80</b>, 1475&ndash;1494.
</p>
<p>Efford, M. G. and Schofield, M. R. (2022) A review of movement models in open population capture&ndash;recapture. <em>Methods in Ecology and Evolution</em> <b>13</b>, 2106&ndash;2118. https://doi.org/10.1111/2041-210X.13947
</p>
<p>Ergon, T. and Gardner, B. (2014) Separating mortality and emigration: modelling space use, dispersal and survival with robust-design spatial capture&ndash;recapture data. <em>Methods in Ecology and Evolution</em> <b>5</b>, 1327&ndash;1336.
</p>
<p>Nathan, R., Klein, E., Robledo-Arnuncio, J. J. and Revilla, E. (2012) Dispersal kernels: review. In: J. Clobert et al. (eds) <em>Dispersal Ecology and Evolution</em>. Oxford University Press. Pp. 187&ndash;210.
</p>


<h3>See Also</h3>

<p><a href="#topic+Movement+20models">Movement models</a>, <code><a href="secr.html#topic+mask">mask</a></code>, <code><a href="#topic+matchscale">matchscale</a></code>, <code><a href="#topic+dkernel">dkernel</a></code>, <code><a href="#topic+pkernel">pkernel</a></code>, <code><a href="#topic+qkernel">qkernel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
k &lt;- make.kernel(movementmodel = 'BVT', spacing = 10, move.a = 20, move.b = 1)
summary(k)

# read a previously fitted movement model packaged with 'openCR'
fit &lt;- readRDS(system.file("exampledata", "spmOV.RDS", package = "openCR"))
k &lt;- make.kernel(fit)
plot(k)
if (interactive()) {
   spotHeight(k, dec = 3)  # click on points; Esc to exit
}
</code></pre>

<hr>
<h2 id='make.table'>Tabulate Estimates From Multiple Models</h2><span id='topic+make.table'></span>

<h3>Description</h3>

<p>Session-specific estimates of real parameters (p, phi, etc.) are arranged in a rectangular table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
make.table(fits, parm = "phi", fields = "estimate", strata = 1, 
    collapse = FALSE, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make.table_+3A_fits">fits</code></td>
<td>
<p>openCRlist object</p>
</td></tr>
<tr><td><code id="make.table_+3A_parm">parm</code></td>
<td>
<p>character name of real parameter estimate to tabulate</p>
</td></tr>
<tr><td><code id="make.table_+3A_fields">fields</code></td>
<td>
<p>character column from predict (estimate, SE.estimate, lcl, ucl)</p>
</td></tr>
<tr><td><code id="make.table_+3A_strata">strata</code></td>
<td>
<p>integer; indices of strata to report</p>
</td></tr>
<tr><td><code id="make.table_+3A_collapse">collapse</code></td>
<td>
<p>logical; if TRUE stratum-specific results are collapsed to single table</p>
</td></tr>
<tr><td><code id="make.table_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+predict.openCRlist">predict.openCRlist</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input will usually be from <code>par.openCR.fit</code>.
</p>
<p><code><a href="#topic+collate.openCR">collate.openCR</a></code> is a flexible alternative.
</p>


<h3>Value</h3>

<p>A table object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+collate.openCR">collate.openCR</a></code>,
<code><a href="#topic+par.openCR.fit">par.openCR.fit</a></code>, 
<code><a href="#topic+openCRlist">openCRlist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

arglist &lt;- list(
    constant = list(capthist = ovenCHp, model = phi~1), 
    session.specific = list(capthist = ovenCHp, model = phi~session)
)
fits &lt;- par.openCR.fit(arglist, trace = FALSE)
print(make.table(fits), na = ".")


## End(Not run)

</code></pre>

<hr>
<h2 id='makeNewData'> Create Default Design Data </h2><span id='topic+makeNewData'></span><span id='topic+makeNewData.openCR'></span>

<h3>Description</h3>

<p>Internal function used to generate a dataframe containing design data
for the base levels of all predictors in an openCR object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'openCR'
makeNewData(object, all.levels = FALSE, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeNewData_+3A_object">object</code></td>
<td>
<p>fitted openCR model object</p>
</td></tr>
<tr><td><code id="makeNewData_+3A_all.levels">all.levels</code></td>
<td>
<p>logical; if TRUE then all covariate factor levels appear in the output</p>
</td></tr>
<tr><td><code id="makeNewData_+3A_...">...</code></td>
<td>
<p>other arguments (not used)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>makeNewData</code> is used by <code>predict</code> in lieu of
user-specified &lsquo;newdata&rsquo;. There is seldom any need to call
<code>makeNewData</code> directly.
</p>
<p><code>makeNewData</code> uses saved agelevels for grouping ages 
(<span class="pkg">openCR</span> &gt;= 2.2.6).
</p>


<h3>Value</h3>

<p>A dataframe with one row for each session, and columns for the
predictors used by <code>object$model</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+openCR.fit">openCR.fit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

## null example (no covariates)
ovenCJS &lt;- openCR.fit(ovenCH)
makeNewData(ovenCJS)


## End(Not run)

</code></pre>

<hr>
<h2 id='matchscale'>Match Kernel</h2><span id='topic+matchscale'></span>

<h3>Description</h3>

<p>Finds scale parameter (move.a) of a movement model that corresponds to desired quantile, or expected distance moved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
matchscale(movementmodel, q = 40, expected = NULL, p = 0.5, lower = 1e-05, upper = 1e+05, 
   move.b = 1, truncate = Inf)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="matchscale_+3A_movementmodel">movementmodel</code></td>
<td>
<p>character (see <a href="#topic+Movement+20models">Movement models</a> and <a href="../doc/openCR-vignette.pdf">openCR-vignettes.pdf</a>)</p>
</td></tr>
<tr><td><code id="matchscale_+3A_q">q</code></td>
<td>
<p>desired quantile (distance moved)</p>
</td></tr>
<tr><td><code id="matchscale_+3A_expected">expected</code></td>
<td>
<p>numeric expected distance moved</p>
</td></tr>
<tr><td><code id="matchscale_+3A_p">p</code></td>
<td>
<p>cumulative probability</p>
</td></tr>
<tr><td><code id="matchscale_+3A_move.b">move.b</code></td>
<td>
<p>shape parameter of movement kernel</p>
</td></tr>
<tr><td><code id="matchscale_+3A_lower">lower</code></td>
<td>
<p>lower bound interval to search </p>
</td></tr>
<tr><td><code id="matchscale_+3A_upper">upper</code></td>
<td>
<p>upper bound interval to search </p>
</td></tr>
<tr><td><code id="matchscale_+3A_truncate">truncate</code></td>
<td>
<p>numeric q value at which distribution truncated</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default behaviour is to find the movement parameter for the given combination of q and p.
</p>
<p>The alternative, when a value is provided for &lsquo;expected&rsquo;, is to find the movement parameter 
corresponding to the given expected distance.
</p>
<p>The <code>truncate</code> argument must be specified for movementmodel &lsquo;UNIzi'. For movementmodel 'UNI&rsquo; there is no parameter and the radius of truncation is varied to achieve the requested quantile q corresponding to cumulative probability p, or the desired expected distance.
</p>


<h3>Value</h3>

<p>Numeric value for move.a (scale parameter or zero-inflation in the case of &lsquo;UNIzi&rsquo;) or truncation radius (&lsquo;UNI&rsquo;).
</p>


<h3>See Also</h3>

<p><a href="#topic+Movement+20models">Movement models</a>, <code><a href="#topic+pkernel">pkernel</a></code>, <code><a href="#topic+make.kernel">make.kernel</a></code>, <code><a href="#topic+expected.d">expected.d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
matchscale('BVN', 40, 0.5)
matchscale('BVT', 40, 0.5, move.b = 1)
matchscale('BVT', 40, 0.5, move.b = 5)
matchscale('BVT', move.b = 5, expected = 10)

</code></pre>

<hr>
<h2 id='Microtus'>Patuxent Meadow Voles</h2><span id='topic+microtusCH'></span><span id='topic+microtusFCH'></span><span id='topic+microtusMCH'></span><span id='topic+microtusFMCH'></span><span id='topic+microtusRDCH'></span>

<h3>Description</h3>

<p>Captures of <em>Microtus pennsylvanicus</em> at Patuxent Wildlife Research Center, Laurel, Maryland, June&ndash;December 1981. Collapsed (primary session only) data for adult males and adult females, and full robust-design data for adult males. Nichols et al. (1984) described the field methods and analysed a superset of the present data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
microtusCH
microtusFCH
microtusMCH
microtusFMCH
microtusRDCH

</code></pre>


<h3>Format</h3>

<p>The format is a single-session secr capthist object. As these are
non-spatial data, the traps attribute is NULL.
</p>


<h3>Details</h3>

<p>Voles were caught in live traps on a 10 x 10 grid with traps 7.6 m apart. Traps were baited with corn. Traps were set in the evening, checked the following morning, and locked open during the day. Voles were ear-tagged with individually numbered fingerling tags. The locations of captures were not included in the published data. 
</p>
<p>Data collection followed Pollock's robust design with five consecutive days of trapping each month for six months (27 June 1981&ndash;8 December 1981). The data are for &quot;adult&quot; animals only, defined as those weighing at least 22g. Low capture numbers on the last two days of the second primary session (occasions 9 and 10) are due to a raccoon interfering with traps (Nichols et al. 1984). Six adult female voles and ten adult male voles were not released; their final captures are coded as -1 in the respective capthist objects.
</p>
<p><code>microtusRDCH</code> is the full robust-design dataset for adult males ((Williams et al. 2002 Table 19.1). 
</p>
<p><code>microtusFCH</code> and <code>microtusMCH</code> are the collapsed datasets (binary at the level of primary session) for adult females and adult males from Williams et al. (2002 Table 17.5); <code>microtusFMCH</code> combines them and includes the covariate &lsquo;sex&rsquo;.
</p>
<p><code>microtusCH</code> is a combined-sex version of the data with different lineage (see below).
</p>
<p>The &lsquo;intervals&rsquo; attribute was assigned for <code>microtusRDCH</code> to distinguish primary sesssions (interval 1 between prmary sessions; interval 0 for consecutive secondary sessions within a primary session). True intervals (start of one primary session to start of next) were 35, 28, 35, 28 and 34 days. See Examples to add these manually.
</p>
<p>Williams, Nichols and Conroy (2002) presented several analyses of these data. 
</p>
<p>Program JOLLY (Hines 1988, Pollock et al. 1990) included a combined-sex version of the primary-session data that was used by Pollock et al. (1985) and Pollock et al. (1990)*. The numbers of voles released each month in the JOLLY dataset JLYEXMPL differ by 0&ndash;3 from the sum of the male and female data from Williams et al. (2002) (see Examples). Some discrepancies may have been due to voles for which sex was not recorded. The JOLLY version matches Table 1 of Nichols et al. (1984). The JOLLY version is distributed here as the object <code>microtusCH</code>.
</p>
<p>Differing selections of data from the Patuxent study were analysed by Nichols et al. (1992) and Bonner and Schwarz (2006).
</p>
<p>* There is a typographic error in Table 4.7 of Pollock et al. (1990): <code class="reqn">r_i</code> for the first period should be 89.
</p>


<h3>Source</h3>


<table>
<tr>
 <td style="text-align: left;">
Object </td><td style="text-align: left;">  </td><td style="text-align: left;"> Source </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>microtusCH</code> </td><td style="text-align: left;">  </td><td style="text-align: left;"> Text file JLYEXMPL distributed with Program JOLLY (Hines 1988; see also Examples) </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>microtusFCH</code> </td><td style="text-align: left;">  </td><td style="text-align: left;"> Table 17.5 in Williams, Nichols and Conroy (2002) </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>microtusMCH</code> </td><td style="text-align: left;">  </td><td style="text-align: left;"> Table 17.5 in Williams, Nichols and Conroy (2002) </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>microtusFMCH</code> </td><td style="text-align: left;">  </td><td style="text-align: left;"> Table 17.5 in Williams, Nichols and Conroy (2002) </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>microtusRDCH</code> </td><td style="text-align: left;">  </td><td style="text-align: left;"> Table 19.1 in Williams, Nichols and Conroy (2002) provided as text file by Jim Hines</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>References</h3>

<p>Bonner, S. J. and Schwarz, C. J. (2006) An extension of the Cormack&ndash;Jolly&ndash;Seber model for continuous
covariates with application to <em>Microtus pennsylvanicus</em>. <em>Biometrics</em> <b>62</b>, 142&ndash;149.
</p>
<p>Hines, J. E. (1988) Program &quot;JOLLY&quot;. Patuxent Wildlife Research Center. <a href="https://eesc.usgs.gov/mbr/software/jolly.shtml">https://eesc.usgs.gov/mbr/software/jolly.shtml</a>
</p>
<p>Nichols, J. D., Pollock, K. H., Hines, J. E. (1984) The use of a robust capture-recapture design in small mammal population studies: a field example with <em>Microtus pennsylvanicus</em>. <em>Acta Theriologica</em> <b>29</b>, 357&ndash;365.
</p>
<p>Nichols, J. D., Sauer, J. R., Pollock, K. H., and Hestbeck, J. B. (1992) Estimating transition probabilities for stage-based population projection matrices using capture&ndash;recapture
data. <em>Ecology</em> <b>73</b>, 306&ndash;312.
</p>
<p>Pollock, K. H., Hines, J. E. and Nichols, J. D. (1985) Goodness-of-fit tests for open capture&ndash;recapture models. 
<em>Biometrics</em> <b>41</b>, 399&ndash;410.
</p>
<p>Pollock, K. H., Nichols, J. D., Brownie, C. and Hines, J. E. (1990) Statistical inference for capture&ndash;recapture experiments. <em>Wildlife Monographs</em> <b>107</b>. 97pp. 
</p>
<p>Williams, B. K., Nichols, J. D. and Conroy, M. J. (2002) <em>Analysis and management of animal populations.</em> Academic Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# cf Williams, Nichols and Conroy Table 17.6
m.array(microtusFCH)
m.array(microtusMCH)

## Not run: 

# cf Williams, Nichols and Conroy Fig. 17.2
fitfm &lt;- openCR.fit(microtusFMCH, model = list(p~1, phi ~ session + sex))
maledat &lt;- expand.grid(sex = factor('M', levels = c('F','M')), session = factor(1:6))
plot(fitfm, ylim=c(0,1), type = 'o')
plot(fitfm, newdata = maledat, add = TRUE, xoffset = 0.1, pch = 16, type = 'o')

# adjusting for variable interval
intervals(microtusCH) &lt;-  c(35,28,35,28,34) / 30 
intervals(microtusRDCH)[intervals(microtusRDCH)&gt;0] &lt;- c(35,28,35,28,34) / 30

# The text file JLYEXMPL distributed with JOLLY is in the extdata folder of the R package
# The microtusCH object may be rebuilt as follows
datadir &lt;- system.file('extdata', package = 'openCR')
JLYdf &lt;- read.table(paste0(datadir,'/JLYEXMPL'), skip = 3, 
                    colClasses = c('character','numeric'))
names(JLYdf) &lt;- c('ch', 'freq')
JLYdf$freq[grepl('2', JLYdf$ch)] &lt;- -JLYdf$freq[grepl('2', JLYdf$ch)]
JLYdf$ch &lt;- gsub ('2','1', JLYdf$ch)
microtusCH &lt;- unRMarkInput(JLYdf)

# Compare to combined-sex data from Williams et al. Table 17.5
JS.counts(microtusCH) - JS.counts(microtusFMCH)

## End(Not run)

</code></pre>

<hr>
<h2 id='miscellaneous'>Data Manipulation</h2><span id='topic+primarysessions'></span><span id='topic+secondarysessions'></span>

<h3>Description</h3>

<p>Miscellaneous functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
primarysessions(intervals)
secondarysessions(intervals)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="miscellaneous_+3A_intervals">intervals</code></td>
<td>
<p>numeric vector of intervals for time between
secondary sessions a of robust design</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are used internally.
</p>


<h3>Value</h3>

<p>primarysessions &ndash;
</p>
<p>Integer vector with the number of the primary session to which each secondary session belongs.
</p>
<p>secondarysessions &ndash;
</p>
<p>Integer vector with secondary sessions numbered sequentially within primary sessions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
int &lt;- intervals(join(ovenCH))
primary &lt;- primarysessions(int)
primary

# number of secondary sessions per primary
table(primary) 

# secondary session numbers
secondarysessions(int)

</code></pre>

<hr>
<h2 id='modelAverage'>Averaging of OpenCR Models Using Akaike's Information Criterion</h2><span id='topic+modelAverage'></span><span id='topic+modelAverage.openCR'></span><span id='topic+modelAverage.openCRlist'></span>

<h3>Description</h3>

<p>AIC- or AICc-weighted average of estimated &lsquo;real&rsquo; or &lsquo;beta&rsquo; parameters
from multiple fitted openCR models. 
</p>
<p>The modelAverage generic is imported from secr (&gt;= 4.5.0).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'openCR'
modelAverage(object, ..., realnames = NULL, betanames = NULL, 
    newdata = NULL, alpha = 0.05, dmax = 10, covar = FALSE, average = c("link", 
    "real"), criterion = c("AIC","AICc"), CImethod = c("Wald", "MATA"))
    
## S3 method for class 'openCRlist'
modelAverage(object, ..., realnames = NULL, betanames = NULL, 
    newdata = NULL, alpha = 0.05, dmax = 10, covar = FALSE, average = c("link", 
    "real"), criterion = c("AIC","AICc"), CImethod = c("Wald", "MATA"))

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modelAverage_+3A_object">object</code></td>
<td>
<p><code>openCR</code> or <code>openCRlist</code> objects</p>
</td></tr>
<tr><td><code id="modelAverage_+3A_...">...</code></td>
<td>
<p> other <code>openCR</code> objects (modelAverage.openCR() only)</p>
</td></tr>
<tr><td><code id="modelAverage_+3A_realnames">realnames</code></td>
<td>
<p> character vector of real parameter names </p>
</td></tr>
<tr><td><code id="modelAverage_+3A_betanames">betanames</code></td>
<td>
<p> character vector of beta parameter names </p>
</td></tr>
<tr><td><code id="modelAverage_+3A_newdata">newdata</code></td>
<td>
<p> optional dataframe of values at which to evaluate models </p>
</td></tr>
<tr><td><code id="modelAverage_+3A_alpha">alpha</code></td>
<td>
<p> alpha level for confidence intervals </p>
</td></tr>
<tr><td><code id="modelAverage_+3A_dmax">dmax</code></td>
<td>
<p> numeric, the maximum AIC or AICc difference for inclusion in confidence set </p>
</td></tr>
<tr><td><code id="modelAverage_+3A_covar">covar</code></td>
<td>
<p> logical, if TRUE then return variance-covariance matrix </p>
</td></tr>
<tr><td><code id="modelAverage_+3A_average">average</code></td>
<td>
<p> character string for scale on which to average real
parameters </p>
</td></tr>
<tr><td><code id="modelAverage_+3A_criterion">criterion</code></td>
<td>
<p> character, information criterion to use for model weights</p>
</td></tr>  
<tr><td><code id="modelAverage_+3A_cimethod">CImethod</code></td>
<td>
<p> character, type of confidence interval (see Details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Models to be compared must have been fitted to the same data and use the
same likelihood method (full vs conditional). If <code>realnames</code> =
NULL and <code>betanames</code> = NULL then all real parameters will be
averaged; in this case all models must use the same real parameters. To
average beta parameters, specify <code>betanames</code> (this is ignored if a
value is provided for <code>realnames</code>). See <code><a href="#topic+predict.openCR">predict.openCR</a></code>
for an explanation of the optional argument <code>newdata</code>;
<code>newdata</code> is ignored when averaging beta parameters. 
</p>
<p>Model-averaged estimates for parameter <code class="reqn">\theta</code> are given by
</p>
<p style="text-align: center;"><code class="reqn">\hat{\theta} = \sum\limits _k w_k \hat{\theta}_k</code>
</p>
<p> where the subscript <code class="reqn">k</code> refers to a specific
model and the <code class="reqn">w_k</code> are AIC or AICc weights (see
<code><a href="#topic+AIC.openCR">AIC.openCR</a></code> for details). Averaging of real parameters may be
done on the link scale before back-transformation
(<code>average="link"</code>) or after back-transformation
(<code>average="real"</code>).
</p>
<p>Models for which dAIC &gt; <code>dmax</code> (or dAICc &gt; <code>dmax</code>) are given a
weight of zero and effectively are excluded from averaging.
</p>
<p>Also, </p>
<p style="text-align: center;"><code class="reqn">\mbox{var} (\hat{\theta}) = \sum\limits _{k} { w_{k}
( \mbox{var}(\hat{\theta}_{k} | \beta _k) + \beta _k ^2)}
</code>
</p>

<p>where <code class="reqn">\hat{\beta} _k = \hat{\theta}_k - \hat{\theta}</code> and the variances are asymptotic estimates
from fitting each model <code class="reqn">k</code>. This follows Burnham and Anderson
(2004) rather than Buckland et al. (1997).
</p>
<p>Two methods are offered for confidence intervals. The default &lsquo;Wald&rsquo;
uses the above estimate of variance. The alternative &lsquo;MATA&rsquo;
(model-averaged tail area) avoids estimating a weighted variance and
is thought to provide better coverage at little cost in increased
interval length (Turek and Fletcher 2012). Turek and Fletcher (2012)
also found averaging with AIC weights (here <code>criterion = 'AIC'</code>)
preferable to using AICc weights, even for small
samples. <code>CImethod</code> does not affect the reported standard errors.
</p>


<h3>Value</h3>

<p>A list (one component per parameter) of model-averaged estimates, their
standard errors, and a <code class="reqn">100(1-\alpha)</code>% confidence
interval. The interval for real parameters is backtransformed from the
link scale. If there is only one row in <code>newdata</code> or beta
parameters are averaged or averaging is requested for only one parameter
then the array is collapsed to a matrix. If <code>covar = TRUE</code> then a
list is returned with separate components for the estimates and the
variance-covariance matrices.
</p>


<h3>References</h3>

 
<p>Buckland S. T., Burnham K. P. and Augustin, N. H. (1997) Model
selection: an integral part of inference. <em>Biometrics</em> <b>53</b>,
603&ndash;618.
</p>
<p>Burnham, K. P. and Anderson, D. R. (2002) <em>Model Selection and
Multimodel Inference: A Practical Information-Theoretic Approach</em>.
Second edition. New York: Springer-Verlag.
</p>
<p>Burnham, K. P. and Anderson, D. R. (2004) Multimodel inference -
understanding AIC and BIC in model selection. <em>Sociological Methods
&amp; Research</em> <b>33</b>, 261&ndash;304.
</p>
<p>Turek, D. and Fletcher, D. (2012) Model-averaged Wald confidence
intervals. <em>Computational statistics and data analysis</em> <b>56</b>,
2809&ndash;2815.
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+AIC.openCR">AIC.openCR</a></code>, 
<code><a href="#topic+make.table">make.table</a></code>, 
<code><a href="#topic+openCR.fit">openCR.fit</a></code>, 
<code><a href="#topic+openCRlist">openCRlist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Compare two models fitted previously

cjs1 &lt;- openCR.fit(dipperCH, model=p~1)
cjs2 &lt;- openCR.fit(dipperCH, model=p~session)
AIC(cjs1, cjs2)
modelAverage(cjs1, cjs2)

## or
cjs12 &lt;- openCRlist(cjs1, cjs2)
modelAverage(cjs12)

</code></pre>

<hr>
<h2 id='Movement+20models'> List of Movement Models </h2><span id='topic+Movement+20models'></span>

<h3>Description</h3>

<p>Movement of activity centres between primary sessions is modelled in <span class="pkg">openCR</span> as a random walk with step length governed by a circular probability kernel. The argument &lsquo;movementmodel&rsquo; defines the kernel in several functions. More detail is provided in the vignettes <a href="../doc/openCR-vignette.pdf">openCR-vignette.pdf</a>.
</p>


<h3>Movement models in <span class="pkg">openCR</span> 2.2</h3>

<p>Kernel models:
</p>

<table>
<tr>
 <td style="text-align: left;">
 Kernel </td><td style="text-align: left;">  </td><td style="text-align: left;"> Description </td><td style="text-align: left;">  </td><td style="text-align: left;"> Parameters </td>
</tr>
<tr>
 <td style="text-align: left;">
 BVN    </td><td style="text-align: left;">  </td><td style="text-align: left;"> bivariate normal </td><td style="text-align: left;">  </td><td style="text-align: left;"> move.a</td>
</tr>
<tr>
 <td style="text-align: left;">
 BVE    </td><td style="text-align: left;">  </td><td style="text-align: left;"> bivariate Laplace </td><td style="text-align: left;">  </td><td style="text-align: left;"> move.a</td>
</tr>
<tr>
 <td style="text-align: left;">
 BVC    </td><td style="text-align: left;">  </td><td style="text-align: left;"> bivariate Cauchy distribution </td><td style="text-align: left;">  </td><td style="text-align: left;"> move.a </td>
</tr>
<tr>
 <td style="text-align: left;">
 BVT    </td><td style="text-align: left;">  </td><td style="text-align: left;"> bivariate t-distribution (2Dt of Clark et al. 1999) </td><td style="text-align: left;">  </td><td style="text-align: left;"> move.a, move.b </td>
</tr>
<tr>
 <td style="text-align: left;">
 RDE    </td><td style="text-align: left;">  </td><td style="text-align: left;"> exponential distribution of distance moved cf Ergon and Gardner (2014) </td><td style="text-align: left;">  </td><td style="text-align: left;"> move.a</td>
</tr>
<tr>
 <td style="text-align: left;">
 RDG    </td><td style="text-align: left;">  </td><td style="text-align: left;"> gamma distribution of distance moved cf Ergon and Gardner (2014) </td><td style="text-align: left;">  </td><td style="text-align: left;"> move.a, move,b</td>
</tr>
<tr>
 <td style="text-align: left;">
 RDL    </td><td style="text-align: left;">  </td><td style="text-align: left;"> log-normal distribution of distance moved cf Ergon and Gardner (2014) </td><td style="text-align: left;">  </td><td style="text-align: left;">  move.a, move.b</td>
</tr>
<tr>
 <td style="text-align: left;">
 RDLS*   </td><td style="text-align: left;"></td><td style="text-align: left;"> log-sech distribution of distance moved (Van Houtan et al. 2007) </td><td style="text-align: left;"></td><td style="text-align: left;"> move.a, move.b </td>
</tr>
<tr>
 <td style="text-align: left;">
 UNI    </td><td style="text-align: left;">  </td><td style="text-align: left;"> uniform within kernel radius, zero outside </td><td style="text-align: left;">  </td><td style="text-align: left;"> (none) </td>
</tr>
<tr>
 <td style="text-align: left;">
 BVNzi  </td><td style="text-align: left;">  </td><td style="text-align: left;"> zero-inflated BVN </td><td style="text-align: left;">  </td><td style="text-align: left;"> move.a, move.b</td>
</tr>
<tr>
 <td style="text-align: left;">
 BVEzi  </td><td style="text-align: left;">  </td><td style="text-align: left;"> zero-inflated BVE </td><td style="text-align: left;">  </td><td style="text-align: left;"> move.a, move.b</td>
</tr>
<tr>
 <td style="text-align: left;">
 RDEzi  </td><td style="text-align: left;">  </td><td style="text-align: left;"> zero-inflated RDE </td><td style="text-align: left;">  </td><td style="text-align: left;"> move.a, move.b</td>
</tr>
<tr>
 <td style="text-align: left;">
 UNIzi  </td><td style="text-align: left;">  </td><td style="text-align: left;"> zero-inflated UNI </td><td style="text-align: left;">  </td><td style="text-align: left;"> move.a </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td>
</tr>

</table>

<p>* incomplete implementation
</p>
<p>Kernel-free models (buffer dependent):
</p>

<table>
<tr>
 <td style="text-align: left;">
 Model </td><td style="text-align: left;">  </td><td style="text-align: left;"> Description </td><td style="text-align: left;">  </td><td style="text-align: left;"> Parameters </td>
</tr>
<tr>
 <td style="text-align: left;">
 IND </td><td style="text-align: left;">  </td><td style="text-align: left;"> independent relocation within habitat mask (Gardner et al. 2018) </td><td style="text-align: left;">  </td><td style="text-align: left;"> (none) </td>
</tr>
<tr>
 <td style="text-align: left;">
 INDzi </td><td style="text-align: left;">  </td><td style="text-align: left;"> zero-inflated IND </td><td style="text-align: left;">  </td><td style="text-align: left;"> move.a </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td>
</tr>

</table>



<h3>Relationships among models</h3>

<p>Some models may be derived as special cases of others, for example
</p>

<table>
<tr>
 <td style="text-align: left;">
 General           </td><td style="text-align: left;"></td><td style="text-align: left;"> Condition </td><td style="text-align: left;"></td><td style="text-align: left;"> Equivalent to </td>
</tr>
<tr>
 <td style="text-align: left;">
 BVT </td><td style="text-align: left;"></td><td style="text-align: left;"> large move.b (df <code class="reqn">\infty</code>) </td><td style="text-align: left;"></td><td style="text-align: left;"> BVN </td>
</tr>
<tr>
 <td style="text-align: left;">
 BVT </td><td style="text-align: left;"></td><td style="text-align: left;"> move.b = 0.5 (df 1)  </td><td style="text-align: left;"></td><td style="text-align: left;"> BVC </td>
</tr>
<tr>
 <td style="text-align: left;"> 
 RDG </td><td style="text-align: left;"></td><td style="text-align: left;"> move.b = 1    </td><td style="text-align: left;"></td><td style="text-align: left;"> RDE </td>
</tr>
<tr>
 <td style="text-align: left;"> 
 RDG </td><td style="text-align: left;"></td><td style="text-align: left;"> move.b = 2    </td><td style="text-align: left;"></td><td style="text-align: left;"> BVE </td>
</tr>
<tr>
 <td style="text-align: left;">
 BVNzi </td><td style="text-align: left;"></td><td style="text-align: left;"> large move.a </td><td style="text-align: left;"></td><td style="text-align: left;"> UNIzi </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>RDL and RDG are almost indistinguishable when move.b &gt; 2.
</p>


<h3>Deprecated names of movement models</h3>

<p>These old names appeared in earlier releases. They still work, but may be removed in future.
</p>

<table>
<tr>
 <td style="text-align: left;">
 Old </td><td style="text-align: left;"> </td><td style="text-align: left;"> New</td>
</tr>
<tr>
 <td style="text-align: left;">
 normal </td><td style="text-align: left;">  </td><td style="text-align: left;"> BVN</td>
</tr>
<tr>
 <td style="text-align: left;">
 exponential </td><td style="text-align: left;">  </td><td style="text-align: left;"> BVE</td>
</tr>
<tr>
 <td style="text-align: left;">
 t2D </td><td style="text-align: left;">  </td><td style="text-align: left;"> BVT </td>
</tr>
<tr>
 <td style="text-align: left;">
 frE </td><td style="text-align: left;">  </td><td style="text-align: left;"> RDE </td>
</tr>
<tr>
 <td style="text-align: left;">
 frG </td><td style="text-align: left;">  </td><td style="text-align: left;"> RDG </td>
</tr>
<tr>
 <td style="text-align: left;">
 frL </td><td style="text-align: left;">  </td><td style="text-align: left;"> RDL </td>
</tr>
<tr>
 <td style="text-align: left;">
 uniform </td><td style="text-align: left;">  </td><td style="text-align: left;"> UNI </td>
</tr>
<tr>
 <td style="text-align: left;">
 frEzi </td><td style="text-align: left;">  </td><td style="text-align: left;"> RDEzi</td>
</tr>
<tr>
 <td style="text-align: left;">
 uniformzi </td><td style="text-align: left;">  </td><td style="text-align: left;"> UNIzi </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td>
</tr>

</table>



<h3>Additional movement models that may be removed without notice</h3>


<table>
<tr>
 <td style="text-align: left;">
Kernel </td><td style="text-align: left;"> </td><td style="text-align: left;"> Description </td><td style="text-align: left;"> </td><td style="text-align: left;"> Parameters </td>
</tr>
<tr>
 <td style="text-align: left;">
annular </td><td style="text-align: left;"> </td><td style="text-align: left;"> non-zero only at centre and edge cells (after clipping at kernelradius) </td><td style="text-align: left;"> </td><td style="text-align: left;"> move.a </td>
</tr>
<tr>
 <td style="text-align: left;">
annularR </td><td style="text-align: left;"> </td><td style="text-align: left;"> non-zero only at centre and a ring of cells at radius R </td><td style="text-align: left;"> </td><td style="text-align: left;"> move.a, move.b </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>&ldquo;annularR&rdquo; uses a variable radius (R = move.b x kernelradius x spacing) and weights each cell according to the length of arc it intersects; &ldquo;annularR&rdquo; is not currently allowed in <code>openCR.fit</code>. For the &lsquo;annular&rsquo; models 'move.a' is the proportion at the centre (probability of not moving). 
</p>


<h3>References</h3>

<p>Clark, J. S, Silman, M., Kern, R., Macklin, E. and HilleRisLambers, J. (1999) Seed dispersal near and far: patterns across temperate and tropical forests. <em>Ecology</em> <b>80</b>, 1475&ndash;1494.
</p>
<p>Efford, M. G. and Schofield, M. R. (2022) A review of movement models in open population capture&ndash;recapture. <em>Methods in Ecology and Evolution</em> <b>13</b>, 2106&ndash;2118. https://doi.org/10.1111/2041-210X.13947
</p>
<p>Ergon, T. and Gardner, B. (2014) Separating mortality and emigration: modelling space use, dispersal and survival with robust-design spatial capture&ndash;recapture data. <em>Methods in Ecology and Evolution</em> <b>5</b>, 1327&ndash;1336.
</p>
<p>Gardner, B., Sollmann, R., Kumar, N. S., Jathanna, D. and Karanth, K. U. (2018) State space and movement specification in open population spatial capture&ndash;recapture models. <em>Ecology and Evolution</em> <b>8</b>, 10336&ndash;10344 <a href="https://doi.org/10.1002/ece3.4509">doi:10.1002/ece3.4509</a>.
</p>
<p>Nathan, R., Klein, E., Robledo-Arnuncio, J. J. and Revilla, E. (2012) Dispersal kernels: review. In: J. Clobert et al. (eds) <em>Dispersal Ecology and Evolution</em>. Oxford University Press. Pp. 187&ndash;210.
</p>
<p>Van Houtan, K. S., Pimm, S. L., Halley, J. M., Bierregaard, R. O. Jr and Lovejoy, T. E. (2007) Dispersal of Amazonian birds in continuous and fragmented forest. <em>Ecology Letters</em> <b>10,</b> 219&ndash;229.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make.kernel">make.kernel</a></code>, 
<code><a href="#topic+gkernel">gkernel</a></code>, 
<code><a href="#topic+dkernel">dkernel</a></code>, 
<code><a href="#topic+pkernel">pkernel</a></code>, 
<code><a href="#topic+qkernel">qkernel</a></code>,
<code><a href="#topic+openCR.fit">openCR.fit</a></code>
</p>

<hr>
<h2 id='moving.fit'>Moving Window Functions</h2><span id='topic+moving.fit'></span><span id='topic+extractFocal'></span>

<h3>Description</h3>

 
<p>Apply a function to successive multi-session windows from a capthist object. The default function is <code>openCR.fit</code>, but any function may be used whose first argument accepts a capthist object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
moving.fit (..., width = 3, centres = NULL, filestem = NULL, 
    trace = FALSE, FUN = openCR.fit)

extractFocal (ocrlist, ...) 

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="moving.fit_+3A_...">...</code></td>
<td>
<p>named arguments passed to <code><a href="#topic+openCR.fit">openCR.fit</a></code> (see Details) </p>
</td></tr>
<tr><td><code id="moving.fit_+3A_width">width</code></td>
<td>
<p>integer; moving window width (number of primary sessions)</p>
</td></tr>
<tr><td><code id="moving.fit_+3A_centres">centres</code></td>
<td>
<p>integer; central sessions of windows to consider</p>
</td></tr>
<tr><td><code id="moving.fit_+3A_filestem">filestem</code></td>
<td>
<p>character or NULL; stem used to form filenames for optional  intermediate output</p>
</td></tr>
<tr><td><code id="moving.fit_+3A_trace">trace</code></td>
<td>
<p>logical; if TRUE a status message is given at each call of FUN</p>
</td></tr>
<tr><td><code id="moving.fit_+3A_fun">FUN</code></td>
<td>
<p>function to be applied to successive capthist objects</p>
</td></tr>
<tr><td><code id="moving.fit_+3A_ocrlist">ocrlist</code></td>
<td>
<p>openCRlist object returned by <code>moving.fit</code> when FUN = openCR.fit</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>moving.fit</code> applies <code>FUN</code> to successive multi-session subsets
of the data in the <code>capthist</code> argument. <code>width</code> should be an odd integer. 
<code>centres</code> may be used to restrict the range of windows considered; 
the default is to use all complete windows (width%/%2 + 1)...).
</p>
<p>If a <code>filestem</code>
is specified then each result is output to a file that may be loaded with
<code>load</code>. This is useful if fitting takes a long time and analyses
may be terminated before completion. 
</p>
<p><code>extractFocal</code> returns the focal-session (central) estimates from a <code>moving.fit</code> 
with <code>FUN = openCR.fit</code>. The ... argument is passed to <code>predict.openCR</code>; 
it may be used, for example, to choose a different alpha level for confidence intervals.
</p>
<p><code>extractFocal</code> is untested for complex models (e.g. finite mixtures).
</p>


<h3>Value</h3>

<p>A list in which each component is the output from FUN applied to one subset. The window width is saved as attribute &lsquo;width&rsquo;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+openCR.fit">openCR.fit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## number of individuals detected
moving.fit(capthist = OVpossumCH, FUN = nrow)

## Not run: 

## if package R2ucare installed
if (requireNamespace("R2ucare"))
    moving.fit(capthist = OVpossumCH, FUN = ucare.cjs, width = 5, tests = "overall_CJS")

## using default FUN = openCR.fit

mf1 &lt;- moving.fit(capthist = OVpossumCH, type = 'JSSAfCL', 
     model = list(p~t, phi~t))
lapply(mf1, predict)
extractFocal(mf1)
     
msk &lt;- make.mask(traps(OVpossumCH[[1]]), nx = 32)
mf2 &lt;- moving.fit(capthist = OVpossumCH, mask = msk, type = 'JSSAsecrfCL')
extractFocal(mf2)


## End(Not run)

</code></pre>

<hr>
<h2 id='openCR-defunct'>Defunct Functions in Package <span class="pkg">openCR</span></h2><span id='topic+openCR-defunct'></span><span id='topic+openCR.make.newdata'></span><span id='topic+plotKernel'></span>

<h3>Description</h3>

<p>These functions are no longer available in <span class="pkg">openCR</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
# Defunct in 2.1.0

openCR.make.newdata()

# Defunct in 2.0.0

plotKernel()

</code></pre>


<h3>Details</h3>

<p>Internal function <code>openCR.make.newdata</code> was replaced with a method for 
the openCR class of the generic <code>makeNewData</code>.
</p>
<p><code>plotKernel</code> was replaced with a plot method for the kernel class.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+openCR-deprecated">openCR-deprecated</a></code>
</p>

<hr>
<h2 id='openCR-deprecated'>Deprecated Functions in Package <span class="pkg">openCR</span></h2><span id='topic+openCR-deprecated'></span>

<h3>Description</h3>

<p>These functions will be removed from future versions of <span class="pkg">openCR</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
# Deprecated in 2.2.6

# None

</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+openCR-defunct">openCR-defunct</a></code>
</p>

<hr>
<h2 id='openCR.design'>Design Data for Open population Models</h2><span id='topic+openCR.design'></span>

<h3>Description</h3>

<p>Internal function used by <code><a href="#topic+openCR.fit">openCR.fit</a></code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
openCR.design(capthist, models, type, naive = FALSE, stratumcov = NULL, 
    sessioncov = NULL, timecov = NULL, agecov = NULL, 
    dframe = NULL, contrasts = NULL, initialage = 0, 
    minimumage = 0, maximumage = 1, agebreaks = NULL, CJSp1 = FALSE, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="openCR.design_+3A_capthist">capthist</code></td>
<td>
<p> single-session <code>capthist</code> object </p>
</td></tr>
<tr><td><code id="openCR.design_+3A_models">models</code></td>
<td>
<p> list of formulae for parameters of detection </p>
</td></tr>
<tr><td><code id="openCR.design_+3A_type">type</code></td>
<td>
<p>character string for type of analysis &quot;CJS&quot;, &quot;JSSAfCL&quot; etc. (see <code><a href="#topic+openCR.fit">openCR.fit</a></code>)</p>
</td></tr>
<tr><td><code id="openCR.design_+3A_naive">naive</code></td>
<td>
<p> logical if TRUE then modelled parameter is for a naive
animal (not caught previously)</p>
</td></tr>
<tr><td><code id="openCR.design_+3A_timecov">timecov</code></td>
<td>
<p> optional vector or dataframe of values of occasion-specific covariate(s). </p>
</td></tr>
<tr><td><code id="openCR.design_+3A_stratumcov">stratumcov</code></td>
<td>
<p> optional dataframe of values of stratum-specific covariate(s) </p>
</td></tr>
<tr><td><code id="openCR.design_+3A_sessioncov">sessioncov</code></td>
<td>
<p> optional dataframe of values of session-specific covariate(s) </p>
</td></tr>
<tr><td><code id="openCR.design_+3A_agecov">agecov</code></td>
<td>
<p> optional dataframe of values of age-specific covariate(s) </p>
</td></tr>
<tr><td><code id="openCR.design_+3A_dframe">dframe</code></td>
<td>
<p> optional data frame of design data for detection parameters </p>
</td></tr>
<tr><td><code id="openCR.design_+3A_contrasts">contrasts</code></td>
<td>
<p>contrast specification as for <code><a href="stats.html#topic+model.matrix">model.matrix</a></code></p>
</td></tr>
<tr><td><code id="openCR.design_+3A_initialage">initialage</code></td>
<td>
<p>numeric or character (name of individual covariate containing initial ages)</p>
</td></tr>
<tr><td><code id="openCR.design_+3A_minimumage">minimumage</code></td>
<td>
<p>numeric; ages younger than minimum are truncated up</p>
</td></tr>
<tr><td><code id="openCR.design_+3A_maximumage">maximumage</code></td>
<td>
<p>numeric; ages older than maximum are truncated down</p>
</td></tr>
<tr><td><code id="openCR.design_+3A_agebreaks">agebreaks</code></td>
<td>
<p>numeric vector of age-class limits</p>
</td></tr>
<tr><td><code id="openCR.design_+3A_cjsp1">CJSp1</code></td>
<td>
<p>logical; if TRUE detection is modelled on first primary session in CJS models</p>
</td></tr>
<tr><td><code id="openCR.design_+3A_...">...</code></td>
<td>
<p> other arguments passed to the <span class="rlang"><b>R</b></span> function <code><a href="stats.html#topic+model.matrix">model.matrix</a></code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an internal <span class="pkg">openCR</span> function that you are unlikely ever
to use. ... may be used to pass <code>contrasts.arg</code> to
<code>model.matrix</code>.
</p>
<p>Each real parameter is notionally different for each unique combination
of individual, secondary session, detector and latent class, i.e., for <code class="reqn">n</code> individuals,
<code class="reqn">S</code> secondary sessions, <code class="reqn">K</code> detectors and <code class="reqn">m</code> latent classes there are
<em>potentially</em> <code class="reqn">n \times S \times K \times m </code> different
values. Actual models always predict a much reduced set of distinct
values, and the number of rows in the design matrix is reduced
correspondingly; a parameter index array allows these to retrieved for
any combination of individual, session and detector. 
</p>
<p><code>openCR.design</code> is less tolerant than <code>openCR.fit</code> regarding
the inputs &lsquo;capthist&rsquo; and &lsquo;models&rsquo;. Model formulae are processed by <code>openCR.fit</code>
to a standard form (a named list of formulae) before they are passed to
<code>openCR.design</code>, and multi-session capthist objects are
automatically &lsquo;reduced&rsquo; and &lsquo;joined&rsquo; for open-population analysis.
</p>
<p>If <code>timecov</code> is a single vector of values (one for each secondary session) 
then it is treated as a covariate named &lsquo;tcov&rsquo;.
If <code>sessioncov</code> is a single vector of values (one for each primary session) 
then it is treated as a covariate named &lsquo;scov&rsquo;.
</p>
<p>The <code>initialage</code> and <code>maximumage</code> arguments are usually passed via the
<code>openCR.fit</code> &lsquo;details&rsquo; argument.
</p>
<p><code>agecov</code> may be used to group ages. It should have length (or number of rows) 
equal to <code>maximumage</code> + 1. Alternatively, age classes may be defined with the argument <code>agebreaks</code>; this is preferred from openCR 2.2.6.
</p>


<h3>Value</h3>

<p>A list with the components
</p>
<table role = "presentation">
<tr><td><code>designMatrices</code></td>
<td>
<p> list of reduced design matrices, one for each
real parameter </p>
</td></tr>
<tr><td><code>parameterTable</code></td>
<td>
<p> index to row of the reduced design matrix for
each real parameter; dim(parameterTable) = c(uniquepar, np),
where uniquepar is the number of unique combinations of paramater
values (uniquepar &lt; <code class="reqn">nSKM</code>) and np is the number of parameters in
the detection model. </p>
</td></tr>
<tr><td><code>PIA</code></td>
<td>
<p> Parameter Index Array - index to row of parameterTable for
a given animal, occasion and latent class; dim(PIA) = c(n,S,K,M) </p>
</td></tr>
<tr><td><code>validlevels</code></td>
<td>
<p> for J primary sessions, a logical matrix of np rows and J columns, mostly
TRUE, but FALSE for impossible combinations e.g. CJS recapture
probability in session 1 (validlevels[&quot;p&quot;,1]) unless <code>CJSp1 = TRUE</code>, or CJS final survival
probability (validlevels[&quot;phi&quot;,J]). Also, validlevels[&quot;b&quot;,1] is
FALSE with type = &quot;JSSA...&quot; because of the constraint that entry
parameters sum to one. </p>
</td></tr>
<tr><td><code>individual</code></td>
<td>
<p> TRUE if uses individual variate(s)</p>
</td></tr>  
<tr><td><code>agelevels</code></td>
<td>
<p>levels for age factor (cut numeric ages) if &lsquo;age&rsquo; in model</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The component validlevels is TRUE in many cases for which a
parameter is redundant or confounded (e.g. validlevels[&quot;phi&quot;,J-1]);
these are sorted out &lsquo;post hoc&rsquo; by examining the fitted values,
their asymptotic variances and the eigenvalues of the Hessian
matrix.</p>


<h3>See Also</h3>

<p><code><a href="#topic+openCR.fit">openCR.fit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## this happens automatically in openCR.fit
ovenCH1 &lt;- join(reduce(ovenCH, by = "all", newtraps=list(1:44)))

openCR.design (ovenCH1, models = list(p = ~1, phi = ~session),
    interval = c(1,1,1,1), type = "CJS")

</code></pre>

<hr>
<h2 id='openCR.fit'> Fit Open Population Capture&ndash;Recapture Model </h2><span id='topic+openCR.fit'></span>

<h3>Description</h3>

<p>Nonspatial or spatial open-population analyses are performed on data
formatted for &lsquo;secr&rsquo;. Several parameterisations are provided for the
nonspatial Jolly-Seber Schwarz-Arnason model (&lsquo;JSSA&rsquo;, also known as
&lsquo;POPAN&rsquo;). Corresponding spatial models are designated
&lsquo;JSSAsecr&rsquo;. The prefix &lsquo;PLB&rsquo; (Pradel-Link-Barker) is used for versions of the 
JSSA models that are conditional on the number observed. Cormack-Jolly-Seber 
(CJS) models are also fitted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
openCR.fit (capthist, type = "CJS", model = list(p~1, phi~1, sigma~1), 
    distribution = c("poisson", "binomial"), mask = NULL, 
    detectfn = c("HHN", "HHR", "HEX", "HAN", "HCG", "HVP", "HPX"), binomN = 0, 
    movementmodel = c('static', 'BVN', 'BVE', 'BVT', 'RDE', 'RDG','RDL','IND', 'UNI',
      'BVNzi', 'BVEzi', 'RDEzi', 'INDzi', 'UNIzi'), edgemethod = 
    c("truncate", "wrap", "none"), kernelradius = 30, sparsekernel = TRUE, 
    start = NULL, link = list(), fixed = list(), stratumcov = NULL, 
    sessioncov = NULL, timecov = NULL, agecov = NULL, dframe = NULL, 
    dframe0 = NULL, details = list(), method = "Newton-Raphson", trace = NULL, 
    ncores = NULL, stratified = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="openCR.fit_+3A_capthist">capthist</code></td>
<td>
 <p><code>capthist</code> object from &lsquo;secr&rsquo;</p>
</td></tr>
<tr><td><code id="openCR.fit_+3A_type">type</code></td>
<td>
<p>character string for type of analysis (see Details)</p>
</td></tr>
<tr><td><code id="openCR.fit_+3A_model">model</code></td>
<td>
<p> list with optional components, each symbolically
defining a linear predictor for the relevant real parameter using
<code>formula</code> notation. See Details for names of real parameters. </p>
</td></tr>
<tr><td><code id="openCR.fit_+3A_distribution">distribution</code></td>
<td>
<p>character distribution of number of individuals detected</p>
</td></tr>
<tr><td><code id="openCR.fit_+3A_mask">mask</code></td>
<td>
<p> single-session <code><a href="secr.html#topic+mask">mask</a></code> object; required for spatial (secr) models </p>
</td></tr>
<tr><td><code id="openCR.fit_+3A_detectfn">detectfn</code></td>
<td>
<p>character code</p>
</td></tr>
<tr><td><code id="openCR.fit_+3A_binomn">binomN</code></td>
<td>
<p> integer code for distribution of counts (see <code><a href="secr.html#topic+secr.fit">secr.fit</a></code>) </p>
</td></tr>
<tr><td><code id="openCR.fit_+3A_movementmodel">movementmodel</code></td>
<td>
<p>character; model for movement between primary sessions (see Details) </p>
</td></tr>
<tr><td><code id="openCR.fit_+3A_edgemethod">edgemethod</code></td>
<td>
<p>character; method for movement at edge of mask (see Details)</p>
</td></tr>
<tr><td><code id="openCR.fit_+3A_kernelradius">kernelradius</code></td>
<td>
<p>integer; radius in mask cells of discretized kernel (movement models only)</p>
</td></tr>
<tr><td><code id="openCR.fit_+3A_sparsekernel">sparsekernel</code></td>
<td>
<p>logical; if TRUE then only cardinal and intercardinal axes are included</p>
</td></tr>
<tr><td><code id="openCR.fit_+3A_start">start</code></td>
<td>
<p> vector of initial values for beta parameters, or fitted
model(s) from which they may be derived </p>
</td></tr>
<tr><td><code id="openCR.fit_+3A_link">link</code></td>
<td>
<p> list with named components, each a character string in
{&quot;log&quot;, &quot;logit&quot;, &quot;loglog&quot;, &quot;identity&quot;, &quot;sin&quot;, &quot;mlogit&quot;} for the link function
of the relevant real parameter </p>
</td></tr>
<tr><td><code id="openCR.fit_+3A_fixed">fixed</code></td>
<td>
<p> list with optional components corresponding to each
&lsquo;real&rsquo; parameter, the scalar value to which parameter is to be fixed </p>
</td></tr>
<tr><td><code id="openCR.fit_+3A_stratumcov">stratumcov</code></td>
<td>
<p> optional dataframe of values of stratum-specific
covariate(s). </p>
</td></tr>
<tr><td><code id="openCR.fit_+3A_sessioncov">sessioncov</code></td>
<td>
<p> optional dataframe of values of session-specific
covariate(s). </p>
</td></tr>
<tr><td><code id="openCR.fit_+3A_timecov">timecov</code></td>
<td>
<p> optional dataframe of values of occasion-specific
covariate(s). </p>
</td></tr>
<tr><td><code id="openCR.fit_+3A_agecov">agecov</code></td>
<td>
<p> optional dataframe of values of age-specific covariate(s) </p>
</td></tr>
<tr><td><code id="openCR.fit_+3A_dframe">dframe</code></td>
<td>
<p> optional data frame of design data for detection
parameters (seldom used) </p>
</td></tr>
<tr><td><code id="openCR.fit_+3A_dframe0">dframe0</code></td>
<td>
<p> optional data frame of design data for detection
parameters of naive (undetected) animals (seldom used) </p>
</td></tr>
<tr><td><code id="openCR.fit_+3A_details">details</code></td>
<td>
<p> list of additional settings (see Details) </p>
</td></tr>
<tr><td><code id="openCR.fit_+3A_method">method</code></td>
<td>
<p> character string giving method for maximizing log
likelihood </p>
</td></tr>
<tr><td><code id="openCR.fit_+3A_trace">trace</code></td>
<td>
<p> logical or integer; output log likelihood at each evaluation, 
or at some lesser frequency as given</p>
</td></tr>
<tr><td><code id="openCR.fit_+3A_ncores">ncores</code></td>
<td>
<p>integer number of cores for parallel processing (see Details) </p>
</td></tr>
<tr><td><code id="openCR.fit_+3A_stratified">stratified</code></td>
<td>
<p>logical; if TRUE then sessions of capthist interpreted 
as indpendent strata</p>
</td></tr>
<tr><td><code id="openCR.fit_+3A_...">...</code></td>
<td>
<p> other arguments passed to join() </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The permitted nonspatial models are CJS, Pradel, Pradelg, JSSAbCL = PLBb, JSSAfCL = PLBf, JSSAgCL = PLBg, JSSAlCL = PLBl, JSSAb, JSSAf, JSSAg, JSSAl, JSSAB and JSSAN. 
</p>
<p>The permitted spatial models are CJSsecr, JSSAsecrbCL = PLBsecrb, JSSAsecrfCL = PLBsecrf, JSSAsecrgCL = PLBsecrg, JSSAsecrlCL = PLBsecrl, JSSAsecrb, JSSAsecrf, JSSAsecrg, JSSAsecrl, JSSAsecrB, JSSAsecrN, secrCL, and secrD. 
</p>
<p>See <a href="../doc/openCR-vignette.pdf">openCR-vignette.pdf</a> for a table of the &lsquo;real&rsquo; parameters associated with each model type.
</p>
<p>Parameterisations of the JSSA models differ in how they include
recruitment: the core parameterisations express recruitment either as a
per capita rate (&lsquo;f&rsquo;), as a finite rate of increase for the population
(&lsquo;l&rsquo; for lambda) or as per-occasion entry probability (&lsquo;b&rsquo; for the
classic JSSA beta parameter, aka PENT in MARK). Each of these models may
be fitted by maximising either the full likelihood, or the likelihood
conditional on capture in the Huggins (1989) sense, distinguished by the
suffix &lsquo;CL&rsquo;. Full-likelihood JSSA models may also be parameterized in
terms of the time-specific absolute recruitment (BN, BD) or the
time-specific population size(N) or density (D).
</p>
<p>&lsquo;secrCL&rsquo; and &lsquo;secrD&rsquo; are closed-population spatial models.
</p>
<p>Data are provided as <span class="pkg">secr</span> &lsquo;capthist&rsquo; objects, with some
restrictions. For nonspatial analyses, &lsquo;capthist&rsquo; may be
single-session or multi-session, with any of the main detector types. For
spatial analyses &lsquo;capthist&rsquo; should be a single-session dataset of a point 
<a href="secr.html#topic+detector">detector</a> type (&lsquo;multi&rsquo;, &lsquo;proximity&rsquo; or &lsquo;count&rsquo;) (see also
details$distribution below). In openCR the occasions of a single-session
dataset are treated as open-population temporal samples except that occasions 
separated by an interval of zero (0) are from the same primary session (multi-session
input is collapsed to single-session if necessary).
</p>
<p><code>model</code> formulae may include the pre-defined terms
&lsquo;session&rsquo;,&lsquo;Session&rsquo;, &lsquo;h2&rsquo;, and &lsquo;h3&rsquo; as in <span class="pkg">secr</span>. &lsquo;session&rsquo;
is the name given to primary sampling times in &lsquo;secr&rsquo;, so a fully
time-specific CJS model is <code>list(p ~ session, phi
~ session)</code>. &lsquo;t&rsquo; is a synonym of &lsquo;session&rsquo;. &lsquo;Session&rsquo; is for a
trend over sessions. &lsquo;h2&rsquo; and &lsquo;h3&rsquo; allow finite mixture models. 
</p>
<p>Learned (behavioural) responses (&lsquo;b&rsquo;, &lsquo;B&rsquo;, etc.) were redefined and extended in 
version 1.3.0. The <a href="../doc/openCR-vignette.pdf">vignette</a> should be consulted 
for current definitions.
</p>
<p>Formulae may also include named occasion-specific and session-specific 
covariates in the dataframe arguments &lsquo;timecov&rsquo; and &lsquo;sessioncov&rsquo; 
(occasion = secondary session of robust design). Named age-specific covariates 
in 'agecov' are treated similarly. Individual covariates present as an attribute of
the &lsquo;capthist&rsquo; input may be used in CJS and ..CL models. Groups are not
supported in this version, but may be implemented via a factor-level
covariate in ..CL models.
</p>
<p><code>distribution</code> specifies the distribution of the number of
individuals detected; this may be conditional on the population size (or number in the
masked area) (&quot;binomial&quot;) or unconditional (&quot;poisson&quot;).
<code>distribution</code> affects the sampling variance of the estimated
density. The default is &quot;poisson&quot; as in <span class="pkg">secr</span>.
</p>
<p>Movement models are list at <a href="#topic+Movement+20models">Movement models</a>. Their use is described in the <a href="../doc/openCR-vignette.pdf">vignette</a>. 
</p>
<p><code>edgemethod</code> controls movement probabilities at the mask edge in spatial models that include movement. &quot;none&quot; typically causes bias in estimates; &quot;wrap&quot; wraps kernel probabilities to the opposing edge of a rectangular mask; &quot;truncate&quot; scales the values of an edge-truncated kernel so that they always sum to 1.0 (safer and more general than &quot;wrap&quot;).
</p>
<p>The mlogit link function is used for the JSSA (POPAN) entry parameter 
&lsquo;b&rsquo; (PENT in MARK) and for mixture proportions, regardless of <code>link</code>.
</p>
<p>Spatial models use one of the hazard-based detection functions (see <code><a href="secr.html#topic+detectfn">detectfn</a></code>) and require data
from independent point detectors (<span class="pkg">secr</span> detector types &lsquo;multi&rsquo;, &lsquo;proximity&rsquo; or &lsquo;count&rsquo;).
</p>
<p>Code is executed in multiple threads unless the user specifies <code>ncores = 1</code> or there is only one core available or <code>details$R == TRUE</code>. Setting <code>ncores = NULL</code> uses the existing value from the environment variable RCPP_PARALLEL_NUM_THREADS (see <code><a href="secr.html#topic+setNumThreads">setNumThreads</a></code>) or 2 if that has not been set. 
</p>
<p>Optional stratification was introduced in <span class="pkg">openCR</span> 2.0.0. See <a href="../doc/openCR-vignette.pdf">openCR-vignette.pdf</a> for details.
</p>
<p>The ... argument may be used to pass a vector of unequal intervals to 
join (<code>interval</code>), or to vary the tolerance for merging detector sites (<code>tol</code>).
</p>
<p>The <code>start</code> argument may be 
</p>

<dl>
<dt>- a vector of beta parameter values, one for each of the NP beta parameters in the model</dt><dd></dd>
<dt>- a named vector of beta parameter values in any order</dt><dd></dd>
<dt>- a named list of one or more real parameter values</dt><dd></dd>
<dt>- a single fitted secr or openCR model whose real parameters overlap with the current model</dt><dd></dd>
<dt>- a list of two fitted models</dt><dd></dd>
</dl>

<p>In the case of two fitted models, the values are melded. This is handy for initialising an 
open spatial model from a closed spatial model and an open non-spatial model. If a beta 
parameter appears in both models then the first is used.
</p>
<p><code>details</code> is a list used for various specialized settings &ndash;
</p>

<table>
<tr>
 <td style="text-align: left;">
Component </td><td style="text-align: left;"> Default </td><td style="text-align: left;"> Description </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>agebreaks</code> </td><td style="text-align: left;"> minimumage:maximumage </td><td style="text-align: left;"> Limits of age classes (vector passed to <code><a href="base.html#topic+cut">cut</a></code>) </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>autoini</code> </td><td style="text-align: left;"> 1 </td><td style="text-align: left;"> Number of the session used to determine 
initial values of D, lambda0 and sigma (secr types only) </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>CJSp1</code> </td><td style="text-align: left;"> FALSE </td><td style="text-align: left;"> Modified CJS model including initial detection 
(estimable with robust design and many spatial models) </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>contrasts</code> </td><td style="text-align: left;"> NULL </td><td style="text-align: left;"> Value suitable for the `contrasts.arg' argument 
of <code><a href="stats.html#topic+model.matrix">model.matrix</a></code> used to specify the coding of factor predictors </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>control</code> </td><td style="text-align: left;"> list() </td><td style="text-align: left;"> Components may be named arguments of <code>nlm</code>, or passed intact as argument `control' of <code>optim</code> - useful for increasing maxit for <code>method = Nelder-Mead</code> (see vignette) </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>debug</code> </td><td style="text-align: left;"> 0 </td><td style="text-align: left;"> debug=1 prints various intermediate values; debug&gt;=2 interrupts execution by calling browser() (position variable) </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>fixedbeta</code> </td><td style="text-align: left;"> NULL </td><td style="text-align: left;"> Vector with one element for each coefficient (beta parameter) in the model. Only 'NA' coefficients will be estimated; others will be fixed at the value given (coefficients define a linear predictor on the link scale). The number and order of coefficients may be determined by calling <code>openCR.fit</code> with trace = TRUE and interrupting execution after the first likelihood evaluation. </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>grain</code> </td><td style="text-align: left;"> 1 </td><td style="text-align: left;"> Obscure setting for multithreading - see <span class="pkg">RcppParallel</span> package </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>hessian</code> </td><td style="text-align: left;"> "auto" </td><td style="text-align: left;"> Computation of the Hessian matrix from which 
variances and covariances are obtained. Options are "none" (no variances), 
"auto" or "fdhess" (use the function fdHess in <span class="pkg">nlme</span>).  If "auto" then 
the Hessian from the optimisation function is used. </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>ignoreusage</code> </td><td style="text-align: left;"> FALSE </td><td style="text-align: left;"> Overrides usage in traps object of capthist </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>initialage</code> </td><td style="text-align: left;"> 0 </td><td style="text-align: left;"> Numeric (uniform age at first capture) 
or character value naming an individual covariate; see <code><a href="#topic+age.matrix">age.matrix</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>initialstratum</code> </td><td style="text-align: left;"> 1 </td><td style="text-align: left;"> Number of stratum to use for finding default starting values (cf autoini in <span class="pkg">secr</span>) </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>LLonly</code> </td><td style="text-align: left;"> FALSE </td><td style="text-align: left;"> TRUE causes the function to return a single
evaluation of the log likelihood at the initial values, followed by the 
initial values </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>minimumage</code> </td><td style="text-align: left;"> 0 </td><td style="text-align: left;"> Sets a minimum age; see <code><a href="#topic+age.matrix">age.matrix</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>maximumage</code> </td><td style="text-align: left;"> 1 </td><td style="text-align: left;"> Sets a maximum age; older animals are recycled into 
this age class; see <code><a href="#topic+age.matrix">age.matrix</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>multinom</code> </td><td style="text-align: left;"> FALSE </td><td style="text-align: left;"> Include the multinomial constant in the 
reported log-likelihood. </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>r0</code> </td><td style="text-align: left;"> 0.5 </td><td style="text-align: left;"> effective radius of zero cell in movement kernel (multiple of cell width) </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>R</code> </td><td style="text-align: left;"> FALSE </td><td style="text-align: left;"> Switch from the default C++ code to 
slower functions in native R (useful for debugging; not all models) </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>squeeze</code> </td><td style="text-align: left;"> TRUE </td><td style="text-align: left;">  Apply <code><a href="#topic+squeeze">squeeze</a></code> to capthist before analysis. Non-spatial models fit faster, because histories often non-unique.</td>
</tr>
<tr>
 <td style="text-align: left;">

<code>userdist</code> </td><td style="text-align: left;"> NULL </td><td style="text-align: left;"> Function to compute distances (see <span class="pkg">secr</span>) </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>stepmax</code> </td><td style="text-align: left;"> NULL </td><td style="text-align: left;"> stepmax argument of <code><a href="stats.html#topic+nlm">nlm</a></code> (step on link scale) </td>
</tr>
<tr>
 <td style="text-align: left;">

</td>
</tr>

</table>

<p>If <code>method = "Newton-Raphson"</code> then <code><a href="stats.html#topic+nlm">nlm</a></code> is
used to maximize the log likelihood (minimize the negative log
likelihood); otherwise <code><a href="stats.html#topic+optim">optim</a></code> is used with the
chosen method (&quot;BFGS&quot;, &quot;Nelder-Mead&quot;, etc.).  If maximization fails a
warning is given appropriate to the method. <code>method = "none"</code> may 
be used to compute or re-compute the variance-covariance matrix at 
given starting values (i.e. providing a previously fitted model as 
the value of <code>start</code>).
</p>
<p>Parameter redundancies are common in open-population models. The output
from <code>openCR.fit</code> includes the singular values (eigenvalues) of the
Hessian - a useful post-hoc indicator of redundancy (e.g., Gimenez et
al. 2004). Eigenvalues are scaled so the largest is 1.0. Very small
scaled values represent redundant parameters - in my experience with
simple JSSA models a threshold of 0.00001 seems effective.
</p>
<p>[There is an undocumented option to fix specific &lsquo;beta&rsquo; parameters.]
</p>
<p>Numeric ages may be grouped into age classes by providing &lsquo;agebreaks&rsquo;. 
In models, ~age then refers to the age-class factor. See the 
<a href="../doc/openCR-vignette.pdf">vignette</a> for more detail.
</p>


<h3>Value</h3>

<p>If <code>details$LLonly == TRUE</code> then a numeric vector is returned with logLik in 
position 1, followed by the named coefficients.
</p>
<p>Otherwise, an object of class &lsquo;openCR&rsquo; with components
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>
<p>function call </p>
</td></tr>
<tr><td><code>capthist</code></td>
<td>
<p>saved input (unique histories; see covariates(capthist)$freq for frequencies)</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>saved input</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>saved input</p>
</td></tr>
<tr><td><code>distribution</code></td>
<td>
<p>saved input</p>
</td></tr>
<tr><td><code>mask</code></td>
<td>
<p>saved input</p>
</td></tr>
<tr><td><code>detectfn</code></td>
<td>
<p>saved input</p>
</td></tr>
<tr><td><code>binomN</code></td>
<td>
<p>saved input</p>
</td></tr>
<tr><td><code>movementmodel</code></td>
<td>
<p>saved input</p>
</td></tr>
<tr><td><code>edgemethod</code></td>
<td>
<p>saved input</p>
</td></tr>
<tr><td><code>usermodel</code></td>
<td>
<p>saved input</p>
</td></tr>
<tr><td><code>moveargsi</code></td>
<td>
<p>relative positions of move.a and move.b arguments</p>
</td></tr>
<tr><td><code>kernel</code></td>
<td>
<p>coordinates of kernel (movement models only)</p>
</td></tr>
<tr><td><code>start</code></td>
<td>
<p>vector of starting values for beta parameters</p>
</td></tr> 
<tr><td><code>link</code></td>
<td>
<p>saved input</p>
</td></tr>
<tr><td><code>fixed</code></td>
<td>
<p>saved input</p>
</td></tr>  
<tr><td><code>timecov</code></td>
<td>
<p>saved input</p>
</td></tr>
<tr><td><code>sessioncov</code></td>
<td>
<p>saved input</p>
</td></tr>
<tr><td><code>agecov</code></td>
<td>
<p>saved input</p>
</td></tr>
<tr><td><code>dframe</code></td>
<td>
<p>saved input</p>
</td></tr>
<tr><td><code>dframe0</code></td>
<td>
<p>saved input</p>
</td></tr>
<tr><td><code>details</code></td>
<td>
<p>saved input</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>saved input</p>
</td></tr>
<tr><td><code>ncores</code></td>
<td>
<p>saved input (NULL replaced with default)</p>
</td></tr>
<tr><td><code>design</code></td>
<td>
<p>reduced design matrices, parameter table and parameter
index array for actual animals (see <code><a href="#topic+openCR.design">openCR.design</a></code>)</p>
</td></tr>
<tr><td><code>design0</code></td>
<td>
<p>reduced design matrices, parameter table and parameter
index array for &lsquo;naive&rsquo; animal (see <code><a href="#topic+openCR.design">openCR.design</a></code>)</p>
</td></tr>
<tr><td><code>parindx</code></td>
<td>
<p>list with one component for each real parameter giving
the indices of the &lsquo;beta&rsquo; parameters associated with each real
parameter</p>
</td></tr>  
<tr><td><code>primaryintervals</code></td>
<td>
<p>intervals between primary sessions</p>
</td></tr>
<tr><td><code>vars</code></td>
<td>
<p>vector of unique variable names in <code>model</code> </p>
</td></tr>
<tr><td><code>betanames</code></td>
<td>
<p>names of beta parameters</p>
</td></tr>
<tr><td><code>realnames</code></td>
<td>
<p>names of fitted (real) parameters </p>
</td></tr>
<tr><td><code>sessionlabels</code></td>
<td>
<p>name of each primary session</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>list describing the fit (output from <code>nlm</code> or
<code>optim</code>) </p>
</td></tr>
<tr><td><code>beta.vcv</code></td>
<td>
<p>variance-covariance matrix of beta parameters </p>
</td></tr>  
<tr><td><code>eigH</code></td>
<td>
<p>vector of eigenvalue corresponding to each beta parameter </p>
</td></tr>
<tr><td><code>version</code></td>
<td>
<p>openCR version number </p>
</td></tr>
<tr><td><code>starttime</code></td>
<td>
<p>character string of date and time at start of fit </p>
</td></tr>
<tr><td><code>proctime</code></td>
<td>
<p>processor time for model fit, in seconds </p>
</td></tr>
</table>
<p>The environment variable RCPP_PARALLEL_NUM_THREADS is updated with the 
value of <code>ncores</code> if provided.
</p>


<h3>Note</h3>

<p>Different parameterisations lead to different model fits when used with
the default &lsquo;model&rsquo; argument in which each real parameter is constrained
to be constant over time.
</p>
<p>The JSSA implementation uses summation over feasible 'birth' and 'death'
times for each capture history, following Pledger et al. (2010). This
enables finite mixture models for individual capture probability (not
fully tested), flexible handling of additions and losses on capture (aka
removals) (not yet programmed), and ultimately the extension to 'unknown
age' as in Pledger et al. (2009).
</p>
<p>openCR uses the generalized matrix inverse &lsquo;ginv&rsquo; from the MASS
package rather than &lsquo;solve&rsquo; from base R, as this seems more robust to
singularities in the Hessian. Also, the default maximization method is &lsquo;BFGS&rsquo;
rather than &lsquo;Newton-Raphson&rsquo; as BFGS appears more robust in the presence
of redundant parameters.
</p>
<p>Earlier versions of <code><a href="#topic+openCR.fit">openCR.fit</a></code> computed latent class membership 
probabilities for each individual in finite mixture models and saved them in 
component &lsquo;posterior&rsquo;. Now see <code><a href="#topic+classMembership">classMembership</a></code> for that functionality.
</p>
<p>From 1.5.0 onwards the number of threads uses the environment variable 
RCPP_PARALLEL_NUM_THREADS, as in <code><a href="secr.html#topic+secr.fit">secr.fit</a></code>. This may be set once
in a session with <code>secr::setNumThreads</code>.
</p>
<p>The default movement arguments changed in <span class="pkg">openCR</span> 2.1.1. Now 
<code>kernelradius = 30, sparsekernel = TRUE</code>.
</p>


<h3>References</h3>

<p>Gimenez, O., Viallefont, A., Catchpole, E. A., Choquet, R. and Morgan,
B. J. T. (2004) Methods for investigating parameter redundancy. 
<em>Animal Biodiversity and Conservation</em> <b>27</b>, 561&ndash;572.
</p>
<p>Huggins, R. M. (1989) On the statistical analysis of capture
experiments. <em>Biometrika</em> <b>76</b>, 133&ndash;140.
</p>
<p>Pledger, S., Efford, M., Pollock. K., Collazo, J. and Lyons, J. (2009)
Stopover duration analysis with departure probability dependent on
unknown time since arrival. In: D. L. Thompson, E. G. Cooch and
M. J. Conroy (eds) <em>Modeling Demographic Processes in Marked
Populations</em>. Springer. Pp. 349&ndash;363.
</p>
<p>Pledger, S., Pollock, K. H. and Norris, J. L. (2010) Open
capture&ndash;recapture models with heterogeneity: II. Jolly-Seber
model. <em>Biometrics</em> <b>66</b>, 883&ndash;890.
</p>
<p>Pradel, R. (1996) Utilization of capture-mark-recapture for the study
of recruitment and population growth rate. <em>Biometrics</em>
<b>52</b>, 703&ndash;709.
</p>
<p>Schwarz, C. J. and Arnason, A. N. (1996) A general methodology for the
analysis of capture-recapture experiments in open
populations. <em>Biometrics</em> <b>52</b>, 860&ndash;873.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+classMembership.openCR">classMembership.openCR</a></code>, 
<code><a href="#topic+derived.openCR">derived.openCR</a></code>,  
<code><a href="#topic+openCR.design">openCR.design</a></code>, 
<code><a href="#topic+par.openCR.fit">par.openCR.fit</a></code>, 
<code><a href="#topic+predict.openCR">predict.openCR</a></code>, 
<code><a href="#topic+summary.openCR">summary.openCR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

## CJS default
openCR.fit(ovenCH)

## POPAN Jolly-Seber Schwarz-Arnason, lambda parameterisation
L1 &lt;- openCR.fit(ovenCH, type = 'JSSAl')
predict(L1)

JSSA1 &lt;- openCR.fit(ovenCH, type = 'JSSAf')
JSSA2 &lt;- openCR.fit(ovenCH, type = 'JSSAf', model = list(phi~t))
JSSA3 &lt;- openCR.fit(ovenCH, type = 'JSSAf', model = list(p~t,phi~t))
AIC (JSSA1, JSSA2, JSSA3)
predict(JSSA1)

RMdata &lt;- RMarkInput (join(reduce(ovenCH, by = "all")))
if (require(RMark)) {
    MarkPath &lt;- 'c:/Mark/'
    if (!all (nchar(Sys.which(c('mark.exe', 'mark64.exe', 'mark32.exe'))) &lt; 2)) {
        openCHtest &lt;- process.data(RMdata, model = 'POPAN')
        openCHPOPAN &lt;- mark(data = openCHtest, model = 'POPAN',
            model.parameters = list(p = list(formula = ~1),
            pent = list(formula = ~1),
            Phi = list(formula = ~1)))
        popan.derived(openCHtest, openCHPOPAN)
        cleanup(ask = FALSE)
    } else message ("mark.exe not found")
} else message ("RMark not found")


## End(Not run)

</code></pre>

<hr>
<h2 id='openCRlist'>Bundle openCR Models</h2><span id='topic+openCRlist'></span><span id='topic++5B.openCRlist'></span>

<h3>Description</h3>

<p>Fitted models are bundled together for convenience.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
openCRlist (...)
## S3 method for class 'openCRlist'
x[i]

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="openCRlist_+3A_...">...</code></td>
<td>
<p> openCR objects</p>
</td></tr>
<tr><td><code id="openCRlist_+3A_x">x</code></td>
<td>
<p>openCRlist</p>
</td></tr>
<tr><td><code id="openCRlist_+3A_i">i</code></td>
<td>
<p>indices</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>openCRlist</code> forms a special list (class &lsquo;openCRlist&rsquo;) of fitted model (openCR) objects.
This may be used as an argument of <code>AIC</code>, <code>predict</code>, <code>make.table</code> etc.
</p>
<p>Methods are provided for the generic function <code>c</code> and list extraction &lsquo;[&rsquo;.
</p>


<h3>Value</h3>

<p>openCRlist object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AIC.openCR">AIC.openCR</a></code>
<code><a href="#topic+predict.openCR">predict.openCR</a></code>
<code><a href="#topic+make.table">make.table</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
fit0 &lt;- openCR.fit (dipperCH)
fitt &lt;- openCR.fit (dipperCH, model=phi~t)
fits &lt;- openCRlist(fit0,fitt)
AIC(fits)
make.table(fits, 'phi')

## End(Not run)

</code></pre>

<hr>
<h2 id='par.openCR.fit'>Fit Multiple openCR Models</h2><span id='topic+par.openCR.fit'></span>

<h3>Description</h3>

<p>This function is a wrapper for <code><a href="#topic+openCR.fit">openCR.fit</a></code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
par.openCR.fit (arglist, ncores = 1, seed = 123, trace = FALSE, logfile = NULL, 
    prefix = "")

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="par.openCR.fit_+3A_arglist">arglist</code></td>
<td>
<p>list of argument lists for <code>secr.fit</code> or a character
vector naming such lists</p>
</td></tr>
<tr><td><code id="par.openCR.fit_+3A_ncores">ncores</code></td>
<td>
<p> integer number of cores used by parallel::makeClusters() </p>
</td></tr>
<tr><td><code id="par.openCR.fit_+3A_seed">seed</code></td>
<td>
<p>integer pseudorandom number seed</p>
</td></tr>
<tr><td><code id="par.openCR.fit_+3A_trace">trace</code></td>
<td>
<p>logical; if TRUE intermediate output may be logged</p>
</td></tr>
<tr><td><code id="par.openCR.fit_+3A_logfile">logfile</code></td>
<td>
<p>character name of file to log progress reports</p>
</td></tr>
<tr><td><code id="par.openCR.fit_+3A_prefix">prefix</code></td>
<td>
<p>character prefix for names of output</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In openCR &gt;= 1.5.0, setting ncores &gt; 1 is deprecated and triggers a warning: multithreading makes it faster to set ncores = 1 in par.openCR.fit.
</p>
<p><code>trace</code> overrides any settings in <code>arglist</code>.
</p>
<p>It is convenient to provide the names of the capthist and mask arguments
in each component of arglist as character values (i.e. in quotes); objects thus
named are exported from the workspace to each worker process (see Examples).
</p>
<p>Using <code>ncores</code>&gt;1 is obsolete under the multithreading regime in <span class="pkg">openCR</span> &gt;= 1.5.0. 
It is usually slower than <code>ncores</code> = 1. If used it has these effects:
</p>
<p>&ndash; worker processes are generated using the <span class="pkg">parallel</span> package,
</p>
<p>&ndash; one model is fitted on each worker, and
</p>
<p>&ndash; if no logfile name is provided then a temporary file name will be generated in tempdir().
</p>


<h3>Value</h3>

<p>For <code>par.openCR.fit</code> - openCRlist of model fits (see
<code><a href="#topic+openCR.fit">openCR.fit</a></code> and <code><a href="#topic+openCRlist">openCRlist</a></code>). Names are created by prefixing <code>prefix</code> to the
names of <code>argslist</code>. If <code>trace</code> is TRUE then the total
execution time and finish time are displayed.
</p>


<h3>Note</h3>

<p>Any attempt in <code>arglist</code> to set <code>ncores &gt; 1</code> for a particular 
openCR fit was ignored in <span class="pkg">openCR</span> &lt; 1.5.0. Now it is allowed.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+openCR.fit">openCR.fit</a></code>,
<a href="secr.html#topic+Parallel">Parallel</a>,
<code><a href="#topic+make.table">make.table</a></code>,
<code><a href="#topic+openCRlist">openCRlist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

m1 &lt;- list(capthist = ovenCH, model = list(p~1, phi~1)) 
m2 &lt;- list(capthist = ovenCH, model = list(p~session, phi~1))
m3 &lt;- list(capthist = ovenCH, model = list(p~session, phi~session) )
setNumThreads(7)  # on quadcore Windows PC
fits &lt;- par.openCR.fit (c('m1','m2','m3'), ncores = 1)
AIC(fits)


## End(Not run)
</code></pre>

<hr>
<h2 id='pkernel'>Kernel Distribution Functions</h2><span id='topic+gkernel'></span><span id='topic+pkernel'></span><span id='topic+dkernel'></span><span id='topic+qkernel'></span>

<h3>Description</h3>

<p>Distribution of distance moved for each of the main movement kernels. Theoretical probability density, cumulative distribution function, and quantile function (inverse of the cumulative distribution function). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
pkernel(q, movementmodel = c("BVN", "BVE", "BVC", "BVT", "RDE", "RDG", "RDL"), 
    move.a, move.b, truncate = Inf, lower.tail = TRUE)

dkernel(r, movementmodel = c("BVN", "BVE", "BVC", "BVT", "RDE", "RDG", "RDL"), 
    move.a, move.b, truncate = Inf)

qkernel(p, movementmodel = c("BVN", "BVE", "BVC", "BVT", "RDE", "RDG", "RDL"), 
    move.a, move.b, truncate = Inf, lower.tail = TRUE)

gkernel(r, movementmodel = c("BVN", "BVE", "BVC", "BVT", "RDE", "RDG", "RDL"),
    move.a, move.b, truncate = Inf)
    
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pkernel_+3A_p">p</code></td>
<td>
<p>numeric vector of cumulative probabilities (0.5 for median)</p>
</td></tr>
<tr><td><code id="pkernel_+3A_r">r</code></td>
<td>
<p>numeric vector of distance moved</p>
</td></tr>
<tr><td><code id="pkernel_+3A_q">q</code></td>
<td>
<p>numeric vector of quantiles (distance moved)</p>
</td></tr>
<tr><td><code id="pkernel_+3A_movementmodel">movementmodel</code></td>
<td>
<p>character (see <a href="#topic+Movement+20models">Movement models</a> and <a href="../doc/openCR-vignette.pdf">openCR-vignette.pdf</a>)</p>
</td></tr>
<tr><td><code id="pkernel_+3A_move.a">move.a</code></td>
<td>
<p>numeric parameter of movement kernel</p>
</td></tr>
<tr><td><code id="pkernel_+3A_move.b">move.b</code></td>
<td>
<p>numeric parameter of movement kernel</p>
</td></tr>
<tr><td><code id="pkernel_+3A_truncate">truncate</code></td>
<td>
<p>numeric q value at which distribution truncated</p>
</td></tr>
<tr><td><code id="pkernel_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are P[X &lt;= x] otherwise, P[X &gt; x].</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Some formulae are given in openCR-vignette.pdf. <code>gkernel</code> gives the 2-D probability density of the bivariate kernel <code class="reqn">g(r) = f(r) / (2\pi r)</code>; the remaining functions describe the distribution of distance moved <code class="reqn">f(r)</code>.
</p>
<p>Computation of <code>qkernel</code> for <code>movementmodel = 'BVE'</code> uses 
numerical root finding (function <code><a href="stats.html#topic+uniroot">uniroot</a></code>).
</p>
<p>Truncation (<code>truncate = limit</code> for finite <code>limit</code>) adjusts probabilities 
upwards by 1/pkernel(limit,..., truncate = Inf) so that 
pkernel(limit, ..., truncate = limit) equals 1.0.
By default the distribution is not truncated.
</p>


<h3>Value</h3>

<p>For <code>pkernel</code> &ndash;
</p>
<p>Vector of cumulative probabilities corresponding to q. The cumulative probability is 1.0 for q &gt; truncate.
</p>
<p>For <code>dkernel</code> &ndash;
</p>
<p>Vector of probability density at radial distance r (zero for r &gt; truncate).
</p>
<p>For <code>qkernel</code> &ndash;
</p>
<p>Vector of quantiles (distances moved) corresponding to cumulative probabilities p.
</p>
<p>For <code>gkernel</code> &ndash;
</p>
<p>Vector of 2-D probability density at radial distance r (zero for r &gt; truncate).
</p>


<h3>References</h3>

<p>Efford, M. G. and Schofield, M. R. (2022) A review of movement models in open population capture&ndash;recapture. <em>Methods in Ecology and Evolution</em> <b>13</b>, 2106&ndash;2118. https://doi.org/10.1111/2041-210X.13947
</p>


<h3>See Also</h3>

<p><a href="#topic+Movement+20models">Movement models</a>, <code><a href="#topic+make.kernel">make.kernel</a></code>, <code><a href="#topic+matchscale">matchscale</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># plot 3 distributions chosen with matchscale to intersect at p = 0.5
q &lt;- 0:100
plot(q, pkernel(q, 'BVN', 34), type = 'l', ylab = 'Cumulative probability')
lines(q, pkernel(q, 'BVT', move.a = 104, move.b = 5), col = 'darkgreen', lwd = 2)
lines(q, pkernel(q, 'BVT', move.a = 40, move.b = 1), col = 'orange', lwd = 2)
points(40, 0.5, pch = 16)
legend(62, 0.36, lty=1, lwd = 2, col = c('black','darkgreen','orange'), 
   legend = c('BVN sigma=34', 'BVT a=104, b=5', 'BVT a=40, b=1'))

# median
abline(v = qkernel(0.5, 'BVN', 34))
</code></pre>

<hr>
<h2 id='plot.derivedopenCR'>Plot Derived Estimates</h2><span id='topic+plot.derivedopenCR'></span>

<h3>Description</h3>

<p>Session-specific estimates of the chosen parameter are plotted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'derivedopenCR'
 plot(x, par = "phi", add = FALSE, xoffset = 0, ylim = NULL, 
    useintervals = TRUE, intermediate.x = TRUE, ...)
    
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.derivedopenCR_+3A_x">x</code></td>
<td>
<p>openCR object from openCR.fit</p>
</td></tr>
<tr><td><code id="plot.derivedopenCR_+3A_par">par</code></td>
<td>
<p>character names of parameter to plot</p>
</td></tr>
<tr><td><code id="plot.derivedopenCR_+3A_add">add</code></td>
<td>
<p>logical; if TRUE then points are added to an existing plot</p>
</td></tr>
<tr><td><code id="plot.derivedopenCR_+3A_xoffset">xoffset</code></td>
<td>
<p>numeric offset to be added to all x values</p>
</td></tr>
<tr><td><code id="plot.derivedopenCR_+3A_ylim">ylim</code></td>
<td>
<p>numeric vector of limits on y-axis</p>
</td></tr>
<tr><td><code id="plot.derivedopenCR_+3A_useintervals">useintervals</code></td>
<td>
<p>logical; if TRUE then x values are spaced according to 
the intervals attribute</p>
</td></tr>
<tr><td><code id="plot.derivedopenCR_+3A_intermediate.x">intermediate.x</code></td>
<td>
<p>logical; if TRUE then turnover parameters are plotted at 
the mid point on the x axis of the interval to which they relate</p>
</td></tr>
<tr><td><code id="plot.derivedopenCR_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code><a href="base.html#topic+plot">plot</a></code>, <code><a href="graphics.html#topic+points">points</a></code> and <code><a href="graphics.html#topic+segments">segments</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If ylim is not provided it is set automatically.
</p>
<p>Confidence intervals are not available in this version.
</p>


<h3>Value</h3>

<p>The x coordinates (including xoffset) are returned invisibly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.openCR">plot.openCR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

fit &lt;- openCR.fit(dipperCH, type='JSSAfCL', model = phi~session)
der &lt;- derived(fit)
plot(der,'N', pch = 16, cex = 1.3)


## End(Not run)

</code></pre>

<hr>
<h2 id='plot.openCR'>Plot Estimates</h2><span id='topic+plot.openCR'></span>

<h3>Description</h3>

<p>Session-specific estimates of the chosen parameter are plotted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'openCR'
 plot(x, par = "phi", newdata = NULL, add = FALSE, xoffset = 0, ylim = NULL, 
    useintervals = TRUE, CI = TRUE, intermediate.x = TRUE, alpha = 0.05, stratum = 1, ...)
    
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.openCR_+3A_x">x</code></td>
<td>
<p>openCR object from openCR.fit</p>
</td></tr>
<tr><td><code id="plot.openCR_+3A_par">par</code></td>
<td>
<p>character names of parameter to plot</p>
</td></tr>
<tr><td><code id="plot.openCR_+3A_newdata">newdata</code></td>
<td>
<p>dataframe of predictor values for <code><a href="stats.html#topic+predict">predict</a></code> (optional)</p>
</td></tr>
<tr><td><code id="plot.openCR_+3A_add">add</code></td>
<td>
<p>logical; if TRUE then points are added to an existing plot</p>
</td></tr>
<tr><td><code id="plot.openCR_+3A_xoffset">xoffset</code></td>
<td>
<p>numeric offset to be added to all x values</p>
</td></tr>
<tr><td><code id="plot.openCR_+3A_ylim">ylim</code></td>
<td>
<p>numeric vector of limits on y-axis</p>
</td></tr>
<tr><td><code id="plot.openCR_+3A_useintervals">useintervals</code></td>
<td>
<p>logical; if TRUE then x values are spaced according to 
the intervals attribute</p>
</td></tr>
<tr><td><code id="plot.openCR_+3A_ci">CI</code></td>
<td>
<p>logical; if TRUE then 1-alpha confidence intervals are plotted</p>
</td></tr>
<tr><td><code id="plot.openCR_+3A_intermediate.x">intermediate.x</code></td>
<td>
<p>logical; if TRUE then turnover parameters are plotted at 
the mid point on the x axis of the interval to which they relate</p>
</td></tr>
<tr><td><code id="plot.openCR_+3A_alpha">alpha</code></td>
<td>
<p>numeric confidence level default (alpha = 0.05) is 95% interval</p>
</td></tr>
<tr><td><code id="plot.openCR_+3A_stratum">stratum</code></td>
<td>
<p>numeric; stratum to plot if more than one</p>
</td></tr>
<tr><td><code id="plot.openCR_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code><a href="base.html#topic+plot">plot</a></code>, <code><a href="graphics.html#topic+points">points</a></code> and <code><a href="graphics.html#topic+segments">segments</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If ylim is not provided it is set automatically.
</p>
<p>For customization you may wish to prepare a base plot with <code>plot(... , type = 'n')</code> and use <code>add = TRUE</code>.
</p>


<h3>Value</h3>

<p>The x coordinates (including xoffset) are returned invisibly.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+predict">predict</a></code>, <code><a href="#topic+plot.derivedopenCR">plot.derivedopenCR</a></code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

fit &lt;- openCR.fit(join(ovenCH), type='CJS', model = phi~session)
plot(fit,'phi', pch = 16, cex=1.3, yl=c(0,1))


## End(Not run)

</code></pre>

<hr>
<h2 id='PPNpossums'>
Orongorongo Valley Brushtail Possums
</h2><span id='topic+FebpossumCH'></span>

<h3>Description</h3>

<p>A subset of brushtail possum (<em>Trichosurus vulpecula</em>) data from the Orongorongo Valley live-trapping study of Efford (1998) and Efford and Cowan (2005) that was used by Pledger, Pollock and Norris (2003, 2010). The <code>OVpossumCH</code> dataset in <span class="pkg">secr</span> is a different selection of data from the same study. Consult ?OVpossumCH for more detail.
</p>
<p>The data comprise captures in February of each year from 1980 to 1988. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
FebpossumCH

</code></pre>


<h3>Format</h3>

<p>The format is a 9-session <span class="pkg">secr</span> capthist object. Capture locations are not included.
</p>


<h3>Details</h3>

<p>The data are captures of 448 animals (175 females and 273 males) over 9 trapping sessions comprising 4&ndash;10 occasions each. All were independent of their mothers, but age was not otherwise distinguished. The individual covariate <code>sex</code> takes values &lsquo;F&rsquo; or &lsquo;M&rsquo;.
</p>
<p>Pledger, Pollock and Norris (2010) fitted 2-class finite mixture models for capture probability p and apparent survival phi, with or without allowance for temporal (between year) variation, using captures from only the first day of each trapping session. The first-day data relate to 270 individuals (115 females and 155 males). 
</p>


<h3>Source</h3>

<p>M. Efford unpubl. See Efford and Cowan (2004) for acknowledgements.
</p>


<h3>References</h3>

<p>Efford, M. G. (1998) Demographic consequences of sex-biased dispersal in
a population of brushtail possums. <em>Journal of Animal Ecology</em>
<b>67</b>, 503&ndash;517.
</p>
<p>Efford, M. G. and Cowan, P. E. (2004) Long-term population trend of
<em>Trichosurus vulpecula</em> in the Orongorongo Valley, New
Zealand. In: <em>The Biology of Australian Possums and
Gliders</em>. Edited by R. L. Goldingay and S. M. Jackson. Surrey
Beatty &amp; Sons, Chipping Norton. Pp. 471&ndash;483.
</p>
<p>Pledger, S., Pollock, K. H. and Norris, J. L. (2010) Open
capture&ndash;recapture models with heterogeneity: II. Jolly&ndash;Seber
model. <em>Biometrics</em> <b>66</b>, 883&ndash;890.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
summary(FebpossumCH) 
m.array(FebpossumCH)
JS.counts(FebpossumCH)

FebD1CH &lt;- subset(FebpossumCH, occasion = 1)

## Not run: 

# reading the text file 'poss8088.data'

datadir &lt;- system.file('extdata', package = 'openCR')
poss8088df &lt;- read.table (paste0(datadir,'/poss8088.data'), header = TRUE)
capt &lt;- poss8088df[,c('session','id','day','day','sex')]

# duplication of day is a trick to get a dummy trapID column in the right place
# this is needed because make.capthist does not have nonspatial option
capt$day.1[] &lt;- 1  

# keep only February samples
capt &lt;- capt[capt$session %% 3 == 1,]

# build nonspatial secr capthist object using dummy trapping grid
FebpossumCH &lt;- make.capthist(capt, make.grid(1,2,ID='numx'))
# discard dummy traps objects
for (i in 1:9) attr(FebpossumCH[[i]], 'traps') &lt;- NULL
names(FebpossumCH) &lt;- 1980:1988 
sessionlabels(FebpossumCH) &lt;- 1980:1988


## End(Not run)

</code></pre>

<hr>
<h2 id='predict.openCR'> openCR Model Predictions </h2><span id='topic+predict.openCR'></span><span id='topic+predict.openCRlist'></span>

<h3>Description</h3>

<p>Evaluate an openCR capture&ndash;recapture model. That is, compute the &lsquo;real&rsquo; parameters corresponding to the &lsquo;beta&rsquo; parameters of a fitted model for arbitrary levels of any variables in the linear predictor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'openCR'
 predict(object, newdata = NULL, se.fit = TRUE, alpha = 0.05, savenew = FALSE, ...) 
## S3 method for class 'openCRlist'
 predict(object, newdata = NULL, se.fit = TRUE, alpha = 0.05, savenew = FALSE, ...) 

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.openCR_+3A_object">object</code></td>
<td>
 <p><code>openCR</code> object output from <code>openCR.fit</code> </p>
</td></tr>
<tr><td><code id="predict.openCR_+3A_newdata">newdata</code></td>
<td>
<p> optional dataframe of values at which to evaluate model </p>
</td></tr>
<tr><td><code id="predict.openCR_+3A_se.fit">se.fit</code></td>
<td>
<p> logical for whether output should include SE and confidence intervals </p>
</td></tr>
<tr><td><code id="predict.openCR_+3A_alpha">alpha</code></td>
<td>
<p> alpha level </p>
</td></tr>
<tr><td><code id="predict.openCR_+3A_savenew">savenew</code></td>
<td>
<p> logical; if TRUE then newdata is saved as an attribute </p>
</td></tr>
<tr><td><code id="predict.openCR_+3A_...">...</code></td>
<td>
<p> other arguments passed to <code><a href="#topic+makeNewData">makeNewData</a></code> </p>
</td></tr>

</table>


<h3>Details</h3>

<p>Predictions are provided for each row in &lsquo;newdata&rsquo;. The default (constructed by 
<code><a href="#topic+makeNewData">makeNewData</a></code>) is to limit those rows to the first-used level of 
factor predictors; to include all levels pass <code>all.levels = TRUE</code> to 
<code>makeNewData</code> in the ... argument.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+AIC.openCR">AIC.openCR</a></code>, <code><a href="#topic+openCR.fit">openCR.fit</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

c1 &lt;- openCR.fit(ovenCH, type='CJS', model=phi~session)
predict(c1)


## End(Not run)

</code></pre>

<hr>
<h2 id='print.derivedopenCR'>Print Method for Derived Estimates</h2><span id='topic+print.derivedopenCR'></span>

<h3>Description</h3>

<p>Formats output from <code><a href="#topic+derived.openCR">derived.openCR</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'derivedopenCR'
print(x, Dscale = NULL, legend = FALSE, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.derivedopenCR_+3A_x">x</code></td>
<td>
<p>object from <code>derived.openCR</code></p>
</td></tr>
<tr><td><code id="print.derivedopenCR_+3A_dscale">Dscale</code></td>
<td>
<p>numeric optional multiplier for densities (overrides saved Dscale)</p>
</td></tr>
<tr><td><code id="print.derivedopenCR_+3A_legend">legend</code></td>
<td>
<p>logical. if TRUE then a legend is provided to column headings</p>
</td></tr>
<tr><td><code id="print.derivedopenCR_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code><a href="base.html#topic+print.data.frame">print.data.frame</a></code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default (i.e. when not not specified in the in the ... argument), 
<code>row.names = FALSE</code> and <code>digits = 4</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+derived.openCR">derived.openCR</a></code>
</p>

<hr>
<h2 id='print.openCR'> Print or Summarise openCR Object </h2><span id='topic+print.openCR'></span><span id='topic+summary.openCR'></span>

<h3>Description</h3>

<p>Print results from fitting a spatially explicit capture&ndash;recapture model, or generate a list of summary data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'openCR'
 print(x, newdata = NULL, alpha = 0.05, svtol = 1e-5,...)
## S3 method for class 'openCR'
 summary(object, newdata = NULL, alpha = 0.05, svtol = 1e-5, deriv = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.openCR_+3A_x">x</code></td>
<td>
 <p><code>openCR</code> object output from <code>openCR.fit</code> </p>
</td></tr>
<tr><td><code id="print.openCR_+3A_object">object</code></td>
<td>
 <p><code>openCR</code> object output from <code>openCR.fit</code> </p>
</td></tr>
<tr><td><code id="print.openCR_+3A_newdata">newdata</code></td>
<td>
<p> optional dataframe of values at which to evaluate model </p>
</td></tr>
<tr><td><code id="print.openCR_+3A_alpha">alpha</code></td>
<td>
<p> alpha level </p>
</td></tr>
<tr><td><code id="print.openCR_+3A_svtol">svtol</code></td>
<td>
<p> threshold for non-null eigenvalues when computing numerical rank </p>
</td></tr>
<tr><td><code id="print.openCR_+3A_deriv">deriv</code></td>
<td>
<p>logical; if TRUE then table of derived parameters is calculated</p>
</td></tr>
<tr><td><code id="print.openCR_+3A_...">...</code></td>
<td>
<p> other arguments passed to <code><a href="#topic+derived.openCR">derived.openCR</a></code> by <code>summary.openCR</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Results are potentially complex and depend upon the analysis (see below). Optional <code>newdata</code> should be a dataframe with a column for each of the variables in the model. If <code>newdata</code> is missing then a dataframe is constructed automatically.  Default <code>newdata</code> are for a naive animal on the first occasion; numeric covariates are set to zero and factor covariates to their base (first) level. Confidence intervals are 100 (1 &ndash; alpha) % intervals.
</p>

<table>
<tr>
 <td style="text-align: left;">
call           </td><td style="text-align: left;"> the function call </td>
</tr>
<tr>
 <td style="text-align: left;">
time           </td><td style="text-align: left;"> date and time fitting started </td>
</tr>
<tr>
 <td style="text-align: left;">
N animals      </td><td style="text-align: left;"> number of distinct animals detected </td>
</tr>
<tr>
 <td style="text-align: left;">
N captures     </td><td style="text-align: left;"> number of detections </td>
</tr>
<tr>
 <td style="text-align: left;">
N sessions     </td><td style="text-align: left;"> number of sampling occasions </td>
</tr>
<tr>
 <td style="text-align: left;">
Model          </td><td style="text-align: left;"> model formula for each `real' parameter </td>
</tr>
<tr>
 <td style="text-align: left;">
Fixed          </td><td style="text-align: left;"> fixed real parameters </td>
</tr>
<tr>
 <td style="text-align: left;">
N parameters   </td><td style="text-align: left;"> number of parameters estimated  </td>
</tr>
<tr>
 <td style="text-align: left;">
Log likelihood </td><td style="text-align: left;"> log likelihood </td>
</tr>
<tr>
 <td style="text-align: left;">
AIC            </td><td style="text-align: left;"> Akaike's information criterion </td>
</tr>
<tr>
 <td style="text-align: left;">
AICc           </td><td style="text-align: left;"> AIC with small sample adjustment (Burnham and Anderson 2002) </td>
</tr>
<tr>
 <td style="text-align: left;">
Beta parameters </td><td style="text-align: left;"> coef of the fitted model, SE and confidence
intervals </td>
</tr>
<tr>
 <td style="text-align: left;">
Eigenvalues     </td><td style="text-align: left;"> scaled eigenvalues of Hessian matrix (maximum 1.0) </td>
</tr>
<tr>
 <td style="text-align: left;">
Numerical rank  </td><td style="text-align: left;"> number of eigenvalues exceeding svtol </td>
</tr>
<tr>
 <td style="text-align: left;">
vcov            </td><td style="text-align: left;"> variance-covariance matrix of beta parameters  </td>
</tr>
<tr>
 <td style="text-align: left;">
Real parameters </td><td style="text-align: left;"> fitted (real) parameters evaluated at base levels of covariates </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>AICc is computed with the default sample size (number of individuals) and parameter count (use.rank = FALSE).
</p>


<h3>Value</h3>

<p>The <code>summary</code> method constructs a list of outputs similar to those printed by the <code>print</code> method, 
but somewhat more concise and re-usable:
</p>

<table>
<tr>
 <td style="text-align: left;">
versiontime     </td><td style="text-align: left;"> secr version, and date and time fitting started </td>
</tr>
<tr>
 <td style="text-align: left;">
traps*           </td><td style="text-align: left;"> detector summary </td>
</tr>
<tr>
 <td style="text-align: left;">
capthist        </td><td style="text-align: left;"> capthist summary (primary and secondary sessions, numbers of animals and detections)</td>
</tr>
<tr>
 <td style="text-align: left;">
intervals        </td><td style="text-align: left;"> intervals between primary sessions </td>
</tr>
<tr>
 <td style="text-align: left;">
mask*            </td><td style="text-align: left;"> mask summary </td>
</tr>
<tr>
 <td style="text-align: left;">
modeldetails    </td><td style="text-align: left;"> miscellaneous model characteristics (type etc.) </td>
</tr>
<tr>
 <td style="text-align: left;">
AICtable        </td><td style="text-align: left;"> single-line output of AIC.openCR </td>
</tr>
<tr>
 <td style="text-align: left;">
coef            </td><td style="text-align: left;"> table of fitted coefficients with CI </td>
</tr>
<tr>
 <td style="text-align: left;">
predicted       </td><td style="text-align: left;"> predicted values (`real' parameter estimates) </td>
</tr>
<tr>
 <td style="text-align: left;">
derived         </td><td style="text-align: left;"> output of derived.openCR (optional) </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>* spatial models only
</p>


<h3>References</h3>

 
<p>Burnham, K. P. and Anderson, D. R. (2002) <em>Model selection and multimodel inference: a practical information-theoretic approach</em>. Second edition. New York: Springer-Verlag.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+AIC.openCR">AIC.openCR</a></code>, <code><a href="#topic+openCR.fit">openCR.fit</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

c1 &lt;- openCR.fit(ovenCH, type='CJS', model=phi~session)
c1


## End(Not run)

</code></pre>

<hr>
<h2 id='read.inp'> Import Data from RMark Input Format </h2><span id='topic+read.inp'></span>

<h3>Description</h3>

<p><code>read.inp</code> forms a capthist object from a MARK input (.inp) file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
read.inp(filename, ngroups = 1, grouplabel = 'group', grouplevels = NULL, 
    covnames = NULL, skip = 0)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.inp_+3A_filename">filename</code></td>
<td>
<p>character file name including &lsquo;.inp&rsquo;.</p>
</td></tr>
<tr><td><code id="read.inp_+3A_ngroups">ngroups</code></td>
<td>
<p>integer number of group columns in input </p>
</td></tr>
<tr><td><code id="read.inp_+3A_grouplabel">grouplabel</code></td>
<td>
<p>character</p>
</td></tr>
<tr><td><code id="read.inp_+3A_grouplevels">grouplevels</code></td>
<td>
<p>vector with length equal to number of groups</p>
</td></tr>
<tr><td><code id="read.inp_+3A_covnames">covnames</code></td>
<td>
<p>character vector of additional covariates names, one per covariate column </p>
</td></tr>
<tr><td><code id="read.inp_+3A_skip">skip</code></td>
<td>
<p>integer number of lines to skip at start of file </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Comments bracketed with &lsquo;/*' and '*/&rsquo; will be removed automatically.
</p>
<p>If <code>grouplevels</code> is specified then <code>ngroups</code> is taken from the number of levels (<code>ngroups</code> is overridden). An individual covariate is output, named according to <code>grouplabel</code>. The order of levels in <code>grouplevels</code> should match the order of the group frequency columns in the input. This also determines the ordering of levels in the resulting covariate.
</p>


<h3>Value</h3>

<p>A single-session capthist object with no traps attribute.
</p>


<h3>See Also</h3>

<p><code><a href="secr.html#topic+RMarkInput">RMarkInput</a></code>, <code><a href="secr.html#topic+unRMarkInput">unRMarkInput</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
datadir &lt;- system.file('extdata', package = 'openCR')
dipperCH &lt;- read.inp(paste0(datadir, '/ed.inp'), ngroups = 2)
summary(dipperCH)

</code></pre>

<hr>
<h2 id='rev.capthist'>Reverse Primary Sessions</h2><span id='topic+rev.capthist'></span>

<h3>Description</h3>

<p>The <code>rev</code> method for capthist objects reverses the order of the primary sessions while retaining the order of secondary sessions within each primary session.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'capthist'
rev(x)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rev.capthist_+3A_x">x</code></td>
<td>
<p>multi-session capthist object from secr</p>
</td></tr>
</table>


<h3>Details</h3>

<p>rev() is used to demonstrate 'reversed time' analyses (Nichols 2016)
in which seniority (gamma) is estimated as reversed-time survival (phi)
The approach is numerically equivalent to direct modelling of seniority (see Examples). 
Direct modelling allows more control and is more intuitive.
</p>
<p>If <code>x</code> is not overtly multi-session and has no intervals attribute then each occasion is treated as a primary session.
</p>


<h3>Value</h3>

<p>Capthist object with same observations as input, but re-ordered. 
The order of attributes <code>sessionlabels</code> and <code>intervals</code> is also reversed.
A default intervals attribute is added if the input lacks one.
</p>


<h3>References</h3>

<p>Nichols, J. D. (2016) And the first one now will later be last:
time-reversal in Cormack&ndash;Jolly&ndash;Seber Models. <em>Statistical Science</em>
<b>31,</b> 175&ndash;190.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
summary(rev(ovenCH), terse = TRUE)

# These three models give the same result for gamma except for
# gamma(1982) which is confounded with p and not separately estimable:

## Not run: 

dipperPradel &lt;- openCR.fit(dipperCH, type = "Pradelg", model = list(p~t, phi~t, gamma~t))
revdipper &lt;- openCR.fit(rev(dipperCH), model=list(p~t, phi~t))
dipperJSSA &lt;- openCR.fit(dipperCH, type='JSSAgCL', model=list(p~t, phi~t, gamma~t))

predict(dipperPradel)$gamma
predict(revdipper)$phi
predict(dipperJSSA)$gamma


## End(Not run)

</code></pre>

<hr>
<h2 id='simulation'>Simulate Capture Histories</h2><span id='topic+sim.nonspatial'></span><span id='topic+runsim.nonspatial'></span><span id='topic+runsim.spatial'></span><span id='topic+runsim.RMark'></span><span id='topic+sumsims'></span>

<h3>Description</h3>

<p>Generate non-spatial or spatial open-population data and fit models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
sim.nonspatial (N, turnover = list(), p, nsessions, noccasions = 1, intervals = NULL, 
    recapfactor = 1, seed = NULL, savepopn = FALSE, ...)
    
runsim.nonspatial (nrepl = 100, seed = NULL, ncores = NULL, fitargs = list(), 
    extractfn = predict, ...)

runsim.spatial (nrepl = 100, seed = NULL, ncores = NULL, popargs = list(), 
    detargs = list(), fitargs = list(), extractfn = predict, intervals = NULL)

sumsims (sims, parm = 'phi', session = 1, dropifnoSE = TRUE, svtol = NULL, 
    maxcode = 3, true = NULL)

runsim.RMark (nrepl = 100, model = "CJS", model.parameters = NULL, extractfn,
    seed = NULL, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulation_+3A_n">N</code></td>
<td>
<p>integer population size</p>
</td></tr>
<tr><td><code id="simulation_+3A_turnover">turnover</code></td>
<td>
<p>list as described for <a href="secr.html#topic+turnover">turnover</a></p>
</td></tr>
<tr><td><code id="simulation_+3A_p">p</code></td>
<td>
<p>numeric detection probability</p>
</td></tr>
<tr><td><code id="simulation_+3A_nsessions">nsessions</code></td>
<td>
<p>number of primary sessions</p>
</td></tr>
<tr><td><code id="simulation_+3A_noccasions">noccasions</code></td>
<td>
<p>number of secondary sessions per primary session</p>
</td></tr>
<tr><td><code id="simulation_+3A_intervals">intervals</code></td>
<td>
<p>intervals between primary sessions (see Details)</p>
</td></tr>
<tr><td><code id="simulation_+3A_recapfactor">recapfactor</code></td>
<td>
<p>numeric multiplier for capture probability after
first capture</p>
</td></tr>
<tr><td><code id="simulation_+3A_seed">seed</code></td>
<td>
<p>random number seed see <a href="secr.html#topic+random+20numbers">random numbers</a></p>
</td></tr>
<tr><td><code id="simulation_+3A_savepopn">savepopn</code></td>
<td>
<p>logical; if TRUE the generated population is saved as an attribute of the capthist object</p>
</td></tr>
<tr><td><code id="simulation_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code><a href="secr.html#topic+sim.popn">sim.popn</a></code> (sim.nonspatial) or <code><a href="#topic+sim.nonspatial">sim.nonspatial</a></code> (runsims)</p>
</td></tr>
<tr><td><code id="simulation_+3A_nrepl">nrepl</code></td>
<td>
<p>number of replicates</p>
</td></tr>
<tr><td><code id="simulation_+3A_ncores">ncores</code></td>
<td>
<p> integer number of cores to be used for parallel processing (see Details)</p>
</td></tr>
<tr><td><code id="simulation_+3A_popargs">popargs</code></td>
<td>
<p>list of arguments for sim.popn</p>
</td></tr>
<tr><td><code id="simulation_+3A_detargs">detargs</code></td>
<td>
<p>list of arguments for sim.capthist</p>
</td></tr>
<tr><td><code id="simulation_+3A_fitargs">fitargs</code></td>
<td>
<p>list of arguments for openCR.fit</p>
</td></tr>
<tr><td><code id="simulation_+3A_extractfn">extractfn</code></td>
<td>
<p>function applied to each fitted openCR model</p>
</td></tr>
<tr><td><code id="simulation_+3A_sims">sims</code></td>
<td>
<p>list output from <code>runsim.nonspatial</code> or <code>runsim.spatial</code></p>
</td></tr>
<tr><td><code id="simulation_+3A_parm">parm</code></td>
<td>
<p>character name of parameter to summarise</p>
</td></tr>
<tr><td><code id="simulation_+3A_session">session</code></td>
<td>
<p>integer vector of session numbers to summarise</p>
</td></tr>
<tr><td><code id="simulation_+3A_dropifnose">dropifnoSE</code></td>
<td>
<p>logical; if TRUE then replicates are omitted when SE missing for parm</p>
</td></tr>
<tr><td><code id="simulation_+3A_svtol">svtol</code></td>
<td>
<p>numeric; minimum singular value (eigenvalue) considered non-zero</p>
</td></tr>
<tr><td><code id="simulation_+3A_maxcode">maxcode</code></td>
<td>
<p>integer; maximum accepted value of convergence code</p>
</td></tr>
<tr><td><code id="simulation_+3A_true">true</code></td>
<td>
<p>true value of requested parm in given session</p>
</td></tr>
<tr><td><code id="simulation_+3A_model">model</code></td>
<td>
<p>character; RMark model type </p>
</td></tr>
<tr><td><code id="simulation_+3A_model.parameters">model.parameters</code></td>
<td>
<p>list with RMark model specification (see <code>?mark</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>sim.nonspatial</code> &ndash; If <code>intervals</code> is specified then the number of primary and secondary sessions is inferred from <code>intervals</code> and <code>nsessions</code> and <code>noccasions</code> are ignored. If <code>N</code> and <code>p</code> are vectors of length 2 then subpopulations of the given initial size are sampled with the differing capture probabilities and the resulting capture histories are combined.
</p>
<p><code>runsim.spatial</code> is a relatively simple wrapper for <code><a href="secr.html#topic+sim.popn">sim.popn</a></code>, <code><a href="secr.html#topic+sim.capthist">sim.capthist</a></code>, and <code><a href="#topic+openCR.fit">openCR.fit</a></code>. Some arguments are set automatically: the <code>sim.capthist</code> argument 'renumber' is always FALSE; argument 'seed' is ignored within 'popargs' and 'detargs'; if no 'traps' argument is provided in 'detargs' then 'core' from 'popargs' will be used; detargs$popn and fitargs$capthist are derived from the preceding step. The 'type' specified in fitargs may refer to a non-spatial or spatial open-population model ('CJS', 'JSSAsecrfCL' etc.). If the <code>intervals</code> argument is specified it is used to set the intervals attribute of the simulated capthist object; turnover parameters in <code>sim.popn</code> are not scaled by <code>intervals</code>.
</p>
<p>Control of parallel processing changed in <span class="pkg">openCR</span> 1.5.0 to conform to <span class="pkg">secr</span>. In <code>runsim.nonspatial</code> and <code>runsim.spatial</code>, if <code>ncores</code> is NULL (the default) then the number of cores used for multithreading by <code>openCR.fit</code> is controlled by the environment variable RCPP_PARALLEL_NUM_THREADS. Use the secr function <code>setNumThreads</code> to set RCPP_PARALLEL_NUM_THREADS to a value greater than the default (2, from <span class="pkg">openCR</span> 1.5 onwards).
</p>
<p>Otherwise, (<code>ncores</code> specified in runsim.nonspatial or runsim.spatial) 'ncores' is set to 1 for each replicate and the replicates are split across the specified number of cores.
</p>
<p><code>sumsims</code> assumes output from <code>runsim.nonspatial</code> and <code>runsim.spatial</code> with &lsquo;extractfn = predict&rsquo; or &lsquo;extractfn = summary&rsquo;. Missing SE usually reflects non-identifiability of a parameter or failure of maximisation, so these replicates are dropped by default. If <code>svtol</code> is specified then the rank of the Hessian is determined by counting eigenvalues that exceed svtol, and replicates are dropped if the rank is less than the number of beta parameters. A value of 1e-5 is suggested for svtol in <code><a href="#topic+AIC.openCR">AIC.openCR</a></code>, but smaller values may be appropriate for larger models (MARK has its own algorithm for this threshold).
</p>
<p>Replicates are also dropped by <code>sumsims</code> if the convergence code exceeds 'maxcode'. The maximisation functions <code><a href="stats.html#topic+nlm">nlm</a></code> (used for method = 'Newton-Raphson', the default), and <code><a href="stats.html#topic+optim">optim</a></code> (all other methods) return different convergence codes; their help pages should be consulted. The default is to accept code = 3 from <code>nlm</code>, although the status of such maximisations is ambiguous.
</p>


<h3>Value</h3>

<p><code>sim.nonspatial</code> &ndash;
</p>
<p>A capthist object representing an open-population sample
</p>
<p><code>runsim.nonspatial</code> and <code>runsim.spatial</code> &ndash;
</p>
<p>List with one component (output from extractfn) for each replicate. Each component also has attributes 'eigH' and 'fit' taken from the output of <code>openCR.fit</code>. See Examples to extract convergence codes from 'fit' attribute.
</p>
<p><code>sumsims</code> &ndash;
</p>
<p>Data.frame with rows &lsquo;estimate&rsquo;, &lsquo;SE.estimate&rsquo;, &lsquo;lcl&rsquo;, &lsquo;ucl&rsquo;, &lsquo;RSE&rsquo;, &lsquo;CI.length&rsquo; and columns for median, mean, SD and n. If &lsquo;true&rsquo; is specified there are additional rows are &lsquo;Bias&rsquo; and &lsquo;RB&rsquo;, and columns for &lsquo;rRMSE&rsquo; and &lsquo;COV&rsquo;.
</p>


<h3>See Also</h3>

<p><code><a href="secr.html#topic+sim.popn">sim.popn</a></code>, <code><a href="secr.html#topic+sim.capthist">sim.capthist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

cores &lt;- 2   # for CRAN check; increase as available

ch &lt;- sim.nonspatial(100, list(phi = 0.7, lambda = 1.1), p = 0.3, nsessions = 8, noccasions=2)
openCR.fit(ch, type = 'CJS')

turnover &lt;- list(phi = 0.85, lambda = 1.0, recrmodel = 'constantN')
set.seed(123)

## using type = 'JSSAlCL' and extractfn = predict

fitarg &lt;- list(type = 'JSSAlCL', model = list(p~t, phi~t, lambda~t))
out &lt;- runsim.nonspatial(nrepl = 100, N = 100, ncores = cores, turnover = turnover, 
   p = 0.2, recapfactor = 4, nsessions = 10, noccasions = 1, fitargs = fitarg)
sumsims(out, 'lambda', 1:10)

## using type = 'Pradelg' and extractfn = derived
## homogeneous p
fitarg &lt;- list(type = 'Pradelg', model = list(p~t, phi~t, gamma~t))
outg &lt;- runsim.nonspatial(nrepl = 100, N = 100, ncores = cores, turnover = turnover, 
    p = 0.2, recapfactor = 4, nsessions = 10, noccasions = 1, 
    fitargs = fitarg, extractfn = derived)
apply(sapply(outg, function(x) x$estimates$lambda),1,mean)

turnover &lt;- list(phi = 0.85, lambda = 1.0, recrmodel = 'discrete')

## 2-class mixture for p
outg2 &lt;- runsim.nonspatial(nrepl = 100, N = c(50,50), ncores = cores, turnover = turnover, 
    p = c(0.3,0.9), recapfactor = 1, nsessions = 10, noccasions = 1, 
    fitargs = fitarg, extractfn = derived)
outg3 &lt;- runsim.nonspatial(nrepl = 100, N = c(50,50), ncores = cores, turnover = turnover, 
    p = c(0.3,0.3), recapfactor = 1, nsessions = 10, noccasions = 1, 
    fitargs = fitarg, extractfn = derived)
apply(sapply(outg2, function(x) x$estimates$lambda),1,mean)

plot(2:10, apply(sapply(outg2, function(x) x$estimates$lambda),1,mean)[-1],
    type='o', xlim = c(1,10), ylim = c(0.9,1.1))

## RMark

extfn &lt;- function(x) x$results$real$estimate[3:11]
MarkPath &lt;- 'c:/mark'  # customise as needed
turnover &lt;- list(phi = 0.85, lambda = 1.0, recrmodel = 'discrete')
outrm &lt;- runsim.RMark (nrepl = 100, model = 'Pradlambda', extractfn = extfn, 
                       model.parameters = list(Lambda=list(formula=~time)),
                       N = c(200,200), turnover = turnover, p = c(0.3,0.9),
                       recapfactor = 1, nsessions = 10, noccasions = 1)
extout &lt;- apply(do.call(rbind, outrm),1,mean)

## Spatial

grid &lt;- make.grid()
msk &lt;- make.mask(grid, type = 'trapbuffer', nx = 32)
turnover &lt;- list(phi = 0.8, lambda = 1)
poparg &lt;- list(D = 10, core = grid, buffer = 100, Ndist = 'fixed', nsessions = 6, 
    details = turnover)
detarg &lt;- list(noccasions = 5, detectfn = 'HHN', detectpar = list(lambda0 = 0.5, sigma = 20))
fitarg &lt;- list(type = 'JSSAsecrfCL', mask = msk, model = list(phi~1, f~1))
sims &lt;- runsim.spatial (nrepl = 7, ncores = cores, pop = poparg, det = detarg, fit = fitarg)
sumsims(sims)

## extract the convergence code from nlm for each replicate in preceding simulation
sapply(lapply(sims, attr, 'fit'), '[[', 'code')
## if method != 'Newton-Raphson then optim is used and the code is named 'convergence'
# sapply(lapply(sims, attr, 'fit'), '[[', 'convergence')


## End(Not run)

</code></pre>

<hr>
<h2 id='squeeze'>Unique Capture Histories</h2><span id='topic+squeeze'></span><span id='topic+unsqueeze'></span>

<h3>Description</h3>

<p>Compresses or expands capthist objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
squeeze(x)
unsqueeze(x)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="squeeze_+3A_x">x</code></td>
<td>
<p>secr capthist object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Although <code>squeeze</code> may be applied to spatial capthist objects, the
effect is often minimal as most spatial histories are unique.
</p>
<p>The &lsquo;freq&rsquo; covariate is used by <code>openCR.fit</code> to weight summaries and likelihoods. It is currently ignored by <code>secr.fit</code>.
</p>


<h3>Value</h3>

<p>Both functions return a capthist object with one row for each unique capture history (including covariates). The individual covariate &lsquo;freq&rsquo; records the number of instances of each unique history in the input.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+openCR.fit">openCR.fit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
squeeze(captdata)

</code></pre>

<hr>
<h2 id='strata'> Stratum names </h2><span id='topic+strata'></span><span id='topic+strata+3C-'></span>

<h3>Description</h3>

<p>Extract or replace the stratum names of a <code>capthist</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strata(object, ...)
strata(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="strata_+3A_object">object</code></td>
<td>
<p> object with &lsquo;stratum&rsquo; attribute e.g. <code>capthist</code> </p>
</td></tr>
<tr><td><code id="strata_+3A_value">value</code></td>
<td>
<p> character vector or vector that may be coerced to character, one value per stratum </p>
</td></tr>
<tr><td><code id="strata_+3A_...">...</code></td>
<td>
<p> other arguments (not used) </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Replacement values will be coerced to character.
</p>


<h3>Value</h3>

<p>a character vector with one value for each session in <code>capthist</code>.
</p>


<h3>Note</h3>

<p><span class="pkg">openCR</span> uses the term &lsquo;stratum&rsquo; for an independent set of samples, 
rather like a &lsquo;session&rsquo; in <span class="pkg">secr</span>. Strata offer flexibility in defining 
and evaluating between-stratum models. The log likelihood for a stratified
model is the sum of the separate stratum log likelihoods. Although this 
assumes independence of sampling, parameters may be shared across strata, 
or stratum-specific parameter values may be functions of stratum-level covariates. 
The detector array and mask can be specified separately for each stratum. 
</p>
<p>For open population analyses, each stratum comprises both primary and secondary 
sessions of Pollock's robust design &lsquo;joined&rsquo; in a single-session capthist object. 
</p>
<p>The function <code><a href="#topic+stratify">stratify</a></code> can be useful for manipulating data into 
multi-stratum form.
</p>
<p>Models are stratified only if the argument <code>stratified</code> of 
<code>openCR.fit()</code> is set to TRUE. Strata will otherwise be treated as 
primary sessions and concatenated as usual with <code>join()</code>.
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+openCR.fit">openCR.fit</a></code>, <code><a href="secr.html#topic+session">session</a></code>, <code><a href="#topic+stratify">stratify</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # artificial example, treating years as strata
  strata(ovenCH)
</code></pre>

<hr>
<h2 id='stratify'>Stratify Capture-Recapture Data</h2><span id='topic+stratify'></span>

<h3>Description</h3>

<p>Arrange existing capthist data in stratified form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stratify(..., intervals = NULL, MoreArgs = list(), covariate = NULL, bytraps = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stratify_+3A_...">...</code></td>
<td>
<p>one or more multi-session capthist objects, or a list of such objects</p>
</td></tr>
<tr><td><code id="stratify_+3A_intervals">intervals</code></td>
<td>
<p>list of intervals vectors, one for each multi-session capthist in ...</p>
</td></tr>
<tr><td><code id="stratify_+3A_moreargs">MoreArgs</code></td>
<td>
<p>list of other arguments passed to <code><a href="secr.html#topic+join">join</a></code></p>
</td></tr>
<tr><td><code id="stratify_+3A_covariate">covariate</code></td>
<td>
<p>character; name of individual or trap covariate to stratify by</p>
</td></tr>
<tr><td><code id="stratify_+3A_bytraps">bytraps</code></td>
<td>
<p>logical; if TRUE then covariate is interpreted as the name of a detector covariate</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument ... may be
</p>

<ol>
<li><p>a list of single-session capthist, one for each stratum (sessions already joined)
</p>
</li>
<li><p>a list of multi-session capthist, one for each stratum (sessions will be joined)
</p>
</li>
<li><p>one single-session capthist, to split by <code>covariate</code> (sessions already joined)
</p>
</li>
<li><p>one multi-session capthist, to be joined as one then split by <code>covariate</code>
</p>
</li></ol>

<p>Cases 1 and 2 result in one stratum for each component of the input list. 
Cases 3 and 4 result in one stratum for each level of <code>covariate</code>.
</p>
<p>The result in Case 1 is identical to <code>MS.capthist(...)</code>.
</p>
<p>The argument <code>intervals</code> refers to the intervals between primary sessions 
before joining (Cases 2,4 only) (see Examples).
</p>
<p>MoreArgs may include the arguments remove.dupl.sites, tol, sites.by.name or drop.sites of <code><a href="secr.html#topic+join">join</a></code>; these otherwise take their default values.
</p>


<h3>Value</h3>

<p>Multi-stratum (multi-session) capthist object for which each component has been &lsquo;join&rsquo;ed.
</p>


<h3>See Also</h3>

<p><code><a href="secr.html#topic+join">join</a></code>, 
<code><a href="secr.html#topic+MS.capthist">MS.capthist</a></code>, 
<code><a href="#topic+openCR.fit">openCR.fit</a></code>, 
<code><a href="#topic+strata">strata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# FebpossumCH comprises 9 annual February sessions.
# The individual covariate 'sex' takes values 'F' and 'M', resulting in two strata.
# 'intervals' can be omitted as the default does the same job.
ch &lt;- stratify(FebpossumCH, covariate = 'sex', intervals = rep(list(rep(1,8)),2))
summary(ch, terse = TRUE)

</code></pre>

<hr>
<h2 id='ucare.cjs'>Goodness-of-fit tests for the Cormack-Jolly-Seber model</h2><span id='topic+ucare.cjs'></span>

<h3>Description</h3>

<p>The package <span class="pkg">R2ucare</span> (Gimenez et al. 2018, 2022) provides the standard tests for CJS models from Burnham et al. (1987) along with tests for multi-state models as described by Pradel et al. (2005). This function is a wrapper for the tests relevant to <span class="pkg">openCR</span> (see Details). Original papers and the vignette for <span class="pkg">R2ucare</span> should be consulted for interpretation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
ucare.cjs(CH, tests = "all", by = NULL, verbose = TRUE, rounding = 3, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ucare.cjs_+3A_ch">CH</code></td>
<td>
<p>capthist object suitable for openCR</p>
</td></tr>
<tr><td><code id="ucare.cjs_+3A_tests">tests</code></td>
<td>
<p>character vector with the names of specific tests (see Details) or &lsquo;all&rsquo;</p>
</td></tr>
<tr><td><code id="ucare.cjs_+3A_by">by</code></td>
<td>
<p>character name of covariate in CH used to split rows of CH into separate groups </p>
</td></tr>
<tr><td><code id="ucare.cjs_+3A_verbose">verbose</code></td>
<td>
<p>logical; if TRUE then additional details are tabulated</p>
</td></tr>
<tr><td><code id="ucare.cjs_+3A_rounding">rounding</code></td>
<td>
<p>integer number of decimal places in output</p>
</td></tr>
<tr><td><code id="ucare.cjs_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code><a href="secr.html#topic+split.capthist">split.capthist</a></code> if needed </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The possible tests are &ldquo;test3sr&quot;, &ldquo;test3sm&quot;, &ldquo;test2ct&quot;, &ldquo;test2cl&quot;, and &ldquo;overall_CJS&quot;.
</p>
<p>If <code>CH</code> is a multi-session object then it will first be collapsed to a single-session object with <code>join</code> as usual in <span class="pkg">openCR</span>. If <code>CH</code> has an intervals attribute indicating that the data are from a robust design (some intervals zero) then it will first be collapsed to one secondary session per primary session, with a warning.
</p>
<p>If <code>by</code> is specified it should point to a categorical variable (factor or character) in the covariates attribute of <code>CH</code>. Separate tests will be conducted for each group.
</p>
<p><span class="pkg">R2ucare</span> was removed from CRAN in May 2022, but will return at some point. In the meantime, it may be necessary to install from GitHub with
</p>
<p><code>
if(!require(devtools)) install.packages("devtools")
devtools::install_github("oliviergimenez/R2ucare")
</code>
</p>


<h3>Value</h3>

<p>A list of results, possibly nested by the grouping variable <code>by</code>. The verbose form includes both the overall result of each test and its breakdown into components (&lsquo;details&rsquo;).
</p>


<h3>References</h3>

<p>Burnham, K. P., Anderson, D. R., White, G. C., Brownie, C. and Pollock, K. H. (1987) <em>Design and Analysis Methods for Fish Survival Experiments Based on Release-Recapture</em>. American Fisheries Society Monograph 5. Bethesda, Maryland, USA.
</p>
<p>Choquet, R., Lebreton, J.-D., Gimenez, O., Reboulet, A.-M. and Pradel, R. (2009) U-CARE: Utilities for performing goodness of fit tests and manipulating CApture-REcapture data. <em>Ecography</em> <b>32</b>, 1071&ndash;1074.
</p>
<p>Gimenez, O., Lebreton, J.-D., Choquet, R. and Pradel, R. (2018) R2ucare: An R package to perform 
goodness-of-fit tests for capture&ndash;recapture models. <em>Methods in Ecology and Evolution</em> <b>9</b>, 1749&ndash;1754.
</p>
<p>Gimenez, O., Lebreton, J.-D., Choquet, R. and Pradel, R. (2022) R2ucare: Goodness-of-Fit Tests
for Capture-Recapture Models. R package version 1.0.2. <a href="https://github.com/oliviergimenez/R2ucare/">https://github.com/oliviergimenez/R2ucare/</a>
</p>
<p>Lebreton, J.-D., Burnham, K. P., Clobert, J., and Anderson, D. R. (1992) Modeling survival and testing biological hypotheses using marked animals: a unified approach with case studies. <em>Ecological Monographs</em> <b>62</b>, 67&ndash;118.
</p>
<p>Pradel, R., Gimenez O. and Lebreton, J.-D. (2005) Principles and interest of GOF tests for multistate capture&ndash;recapture models. <em>Animal Biodiversity and Conservation</em> <b>28</b>, 189&ndash;204.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+m.array">m.array</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("R2ucare"))
    ucare.cjs(dipperCH, verbose = FALSE, by = 'sex')

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
