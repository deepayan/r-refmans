<!DOCTYPE html><html lang="en"><head><title>Help for package stR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {stR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AutoSTR'><p>Automatic STR decomposition for time series data</p></a></li>
<li><a href='#calls'><p>Number of phone calls dataset</p></a></li>
<li><a href='#components'><p>Extract STR components</p></a></li>
<li><a href='#confidence'><p>Common argument</p></a></li>
<li><a href='#control'><p>Common argument</p></a></li>
<li><a href='#data'><p>Common argument</p></a></li>
<li><a href='#electricity'><p>Electricity consumption dataset</p></a></li>
<li><a href='#gapCV'><p>Common argument</p></a></li>
<li><a href='#grocery'><p>Grocery and supermarkets turnover</p></a></li>
<li><a href='#heuristicSTR'><p>Automatic STR decomposition with heuristic search of the parameters</p></a></li>
<li><a href='#lambdas'><p>Common argument</p></a></li>
<li><a href='#nFold'><p>Common argument</p></a></li>
<li><a href='#nMCIter'><p>Common argument</p></a></li>
<li><a href='#pattern'><p>Common argument</p></a></li>
<li><a href='#plot.STR'><p>Plots the results of decomposition</p></a></li>
<li><a href='#plotBeta'><p>Plots the varying beta coefficients of decomposition</p></a></li>
<li><a href='#predictors'><p>Common argument</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#reltol'><p>Common argument</p></a></li>
<li><a href='#reportDimensionsOnly'><p>Common argument</p></a></li>
<li><a href='#robust'><p>Common argument</p></a></li>
<li><a href='#RSTRmodel'><p>Robust STR decomposition</p></a></li>
<li><a href='#seasadj.STR'><p>Seasonal adjustment based on STR</p></a></li>
<li><a href='#solver'><p>Common argument</p></a></li>
<li><a href='#STR'><p>Automatic STR decomposition</p></a></li>
<li><a href='#strDesign'><p>Common argument</p></a></li>
<li><a href='#STRmodel'><p>STR decomposition</p></a></li>
<li><a href='#trace'><p>Common argument</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Seasonal Trend Decomposition Using Regression</td>
</tr>
<tr>
<td>Version:</td>
<td>0.7</td>
</tr>
<tr>
<td>Description:</td>
<td>Methods for decomposing seasonal data: STR (a Seasonal-Trend 
  time series decomposition procedure based on Regression) and Robust STR. In 
  some ways, STR is similar to Ridge Regression and Robust STR can be related to 
  LASSO. They allow for multiple seasonal components, multiple linear covariates 
  with constant, flexible and seasonal influence. Seasonal patterns (for both 
  seasonal components and seasonal covariates) can be fractional and flexible 
  over time; moreover they can be either strictly periodic or have a more 
  complex topology. The methods provide confidence intervals for the estimated 
  components. The methods can also be used for forecasting.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>compiler, foreach, forecast, graphics, grDevices, Matrix,
methods, quantreg, SparseM, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>demography, doParallel, knitr, markdown, rgl, rmarkdown,
seasonal, testthat</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://pkg.robjhyndman.com/stR/">https://pkg.robjhyndman.com/stR/</a>,
<a href="https://github.com/robjhyndman/stR">https://github.com/robjhyndman/stR</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/robjhyndman/stR/issues">https://github.com/robjhyndman/stR/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-28 05:56:50 UTC; hyndman</td>
</tr>
<tr>
<td>Author:</td>
<td>Alexander Dokumentov
    <a href="https://orcid.org/0000-0003-0478-0983"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Rob Hyndman <a href="https://orcid.org/0000-0002-2140-5352"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Rob Hyndman &lt;Rob.Hyndman@monash.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-28 13:30:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='AutoSTR'>Automatic STR decomposition for time series data</h2><span id='topic+AutoSTR'></span>

<h3>Description</h3>

<p>Automatically selects parameters for an STR decomposition of time series data.
The time series should be of class <code>ts</code> or <code>msts</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AutoSTR(
  data,
  robust = FALSE,
  gapCV = NULL,
  lambdas = NULL,
  reltol = 0.001,
  confidence = NULL,
  nsKnots = NULL,
  trace = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AutoSTR_+3A_data">data</code></td>
<td>
<p>A time series of class <code>ts</code> or <code>msts</code>.</p>
</td></tr>
<tr><td><code id="AutoSTR_+3A_robust">robust</code></td>
<td>
<p>When <code>TRUE</code>, Robust STR decomposition is used. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="AutoSTR_+3A_gapcv">gapCV</code></td>
<td>
<p>An optional parameter defining the length of the sequence of
skipped values in the cross validation procedure.</p>
</td></tr>
<tr><td><code id="AutoSTR_+3A_lambdas">lambdas</code></td>
<td>
<p>An optional parameter.
A structure which replaces lambda parameters provided with predictors.
It is used as either a starting point for the optimisation of parameters or as the
exact model parameters.</p>
</td></tr>
<tr><td><code id="AutoSTR_+3A_reltol">reltol</code></td>
<td>
<p>An optional parameter which is passed directly to <code><a href="stats.html#topic+optim">optim</a>()</code>
when optimising the parameters of the model.</p>
</td></tr>
<tr><td><code id="AutoSTR_+3A_confidence">confidence</code></td>
<td>
<p>A vector of percentiles giving the coverage of confidence intervals.
It must be greater than 0 and less than 1.
If <code>NULL</code>, no confidence intervals are produced.</p>
</td></tr>
<tr><td><code id="AutoSTR_+3A_nsknots">nsKnots</code></td>
<td>
<p>An optional vector parameter, defining the number of seasonal knots (per period) for each sesonal component.</p>
</td></tr>
<tr><td><code id="AutoSTR_+3A_trace">trace</code></td>
<td>
<p>When <code>TRUE</code>, tracing is turned on.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A structure containing input and output data.
It is an <strong>S3</strong> class <code>STR</code>, which is a list with the following components:
</p>

<ul>
<li> <p><strong>output</strong> &ndash; contains decomposed data. It is a list of three components:
</p>

<ul>
<li> <p><strong>predictors</strong> &ndash; a list of components where each component
corresponds to the input predictor. Every such component is a list containing the following:
</p>

<ul>
<li> <p><strong>data</strong> &ndash; fit/forecast for the corresponding predictor (trend, seasonal component, flexible or seasonal predictor).
</p>
</li>
<li> <p><strong>beta</strong> &ndash; beta coefficients of the fit of the coresponding predictor.
</p>
</li>
<li> <p><strong>lower</strong> &ndash; optional (if requested) matrix of lower bounds of confidence intervals.
</p>
</li>
<li> <p><strong>upper</strong> &ndash; optional (if requested) matrix of upper bounds of confidence intervals.
</p>
</li></ul>

</li>
<li> <p><strong>random</strong> &ndash; a list with one component <strong>data</strong>, which contains residuals of the model fit.
</p>
</li>
<li> <p><strong>forecast</strong> &ndash; a list with two components:
</p>

<ul>
<li> <p><strong>data</strong> &ndash; fit/forecast for the model.
</p>
</li>
<li> <p><strong>beta</strong> &ndash; beta coefficients of the fit.
</p>
</li>
<li> <p><strong>lower</strong> &ndash; optional (if requested) matrix of lower bounds of confidence intervals.
</p>
</li>
<li> <p><strong>upper</strong> &ndash; optional (if requested) matrix of upper bounds of confidence intervals.
</p>
</li></ul>

</li></ul>

</li>
<li> <p><strong>input</strong> &ndash; input parameters and lambdas used for final calculations.
</p>

<ul>
<li> <p><strong>data</strong> &ndash; input data.
</p>
</li>
<li> <p><strong>predictors</strong> - input predictors.
</p>
</li>
<li> <p><strong>lambdas</strong> &ndash; smoothing parameters used for final calculations (same as input lambdas for STR method).
</p>
</li></ul>

</li>
<li> <p><strong>cvMSE</strong> &ndash; optional cross validated (leave one out) Mean Squared Error.
</p>
</li>
<li> <p><strong>optim.CV.MSE</strong> &ndash; best cross validated Mean Squared Error (n-fold) achieved during minimisation procedure.
</p>
</li>
<li> <p><strong>nFold</strong> &ndash; the input <code>nFold</code> parameter.
</p>
</li>
<li> <p><strong>gapCV</strong> &ndash; the input <code>gapCV</code> parameter.
</p>
</li>
<li> <p><strong>method</strong> &ndash; always contains string <code>"AutoSTR"</code> for this function.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Alexander Dokumentov
</p>


<h3>References</h3>

<p>Dokumentov, A., and Hyndman, R.J. (2022)
STR: Seasonal-Trend decomposition using Regression,
<em>INFORMS Journal on Data Science</em>, 1(1), 50-62.
<a href="https://robjhyndman.com/publications/str/">https://robjhyndman.com/publications/str/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+STR">STR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Decomposition of a multiple seasonal time series
decomp &lt;- AutoSTR(calls)
plot(decomp)

# Decomposition of a monthly time series
decomp &lt;- AutoSTR(log(grocery))
plot(decomp)

</code></pre>

<hr>
<h2 id='calls'>Number of phone calls dataset</h2><span id='topic+calls'></span>

<h3>Description</h3>

<p>Number of call arrivals per 5-minute interval handled on weekdays between 7:00 am and 9:05 pm
from March 3, 2003 in a large North American commercial bank.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calls
</code></pre>


<h3>Format</h3>

<p>A numerical time series of class <code>msts</code> and <code>ts</code>.
</p>


<h3>Source</h3>

<p><a href="https://robjhyndman.com/data/callcenter.txt">Data file</a>
</p>


<h3>References</h3>

<p>Forecasting time series with complex seasonal patterns using exponential smoothing
A.M. De Livera, R.J. Hyndman &amp; R.D. Snyder
J American Statistical Association, 106(496), 1513-1527.
<a href="https://robjhyndman.com/publications/complex-seasonality/">https://robjhyndman.com/publications/complex-seasonality/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(calls, ylab = "Calls handled")
</code></pre>

<hr>
<h2 id='components'>Extract STR components</h2><span id='topic+components'></span>

<h3>Description</h3>

<p><code>components</code> extracts components as time series from the result of an STR decomposition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>components(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="components_+3A_object">object</code></td>
<td>
<p>Result of STR decomposition.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alexander Dokumentov
</p>


<h3>See Also</h3>

<p><code><a href="#topic+STRmodel">STRmodel</a></code>, <code><a href="#topic+RSTRmodel">RSTRmodel</a></code>, <code><a href="#topic+STR">STR</a></code>, <code><a href="#topic+AutoSTR">AutoSTR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fit &lt;- AutoSTR(log(grocery))
comp &lt;- components(fit)
plot(comp)

</code></pre>

<hr>
<h2 id='confidence'>Common argument</h2><span id='topic+confidence'></span>

<h3>Description</h3>

<p>Common argument
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="confidence_+3A_confidence">confidence</code></td>
<td>
<p>A vector of percentiles giving the coverage of confidence intervals.
It must be greater than 0 and less than 1.
If <code>NULL</code>, no confidence intervals are produced.</p>
</td></tr>
</table>

<hr>
<h2 id='control'>Common argument</h2><span id='topic+control'></span>

<h3>Description</h3>

<p>Common argument
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="control_+3A_control">control</code></td>
<td>
<p>Passed directly to <code><a href="quantreg.html#topic+rq.fit.sfn">rq.fit.sfn</a>()</code> during Robust STR decomposition.</p>
</td></tr>
</table>

<hr>
<h2 id='data'>Common argument</h2><span id='topic+data'></span>

<h3>Description</h3>

<p>Common argument
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="data_+3A_data">data</code></td>
<td>
<p>Time series or a vector of length <em><strong>L</strong></em>.</p>
</td></tr>
</table>

<hr>
<h2 id='electricity'>Electricity consumption dataset</h2><span id='topic+electricity'></span>

<h3>Description</h3>

<p>The data set provides information about electricity consumption in Victoria, Australia
during the 115 days starting on 10th of January, 2000,
and comprises the maximum electricity demand in Victoria during 30-minute periods
(48 observations per day). For each 30-minute period, the dataset also provides
the air temperature in Melbourne.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>electricity
</code></pre>


<h3>Format</h3>

<p>An numerical matrix of class <code>msts</code> and <code>ts</code>.
</p>


<h3>Details</h3>


<ul>
<li> <p><code>Consumption</code> column contains maximum electricity consumption during 30 minute
periods
</p>
</li>
<li> <p><code>Temperature</code> column contains temperature in Melbourne during the corresponding
30 minute interval
</p>
</li>
<li> <p><code>Time</code> column contains number of 30 minute interval in the dataset
</p>
</li>
<li> <p><code>DailySeasonality</code> column contains positions of 30 minute interval inside days
</p>
</li>
<li> <p><code>WeeklySeasonality</code> column contains positions of 30 minute interval inside weeks
</p>
</li>
<li> <p><code>WorkingDaySeasonality</code> column contains positions of 30 minute intervals
inside working day/holiday transition diagram
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>plot(electricity[, 1:2],
  xlab = "Weeks",
  main = "Electricity demand and temperature in Melbourne, Australia"
)
</code></pre>

<hr>
<h2 id='gapCV'>Common argument</h2><span id='topic+gapCV'></span>

<h3>Description</h3>

<p>Common argument
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gapCV_+3A_gapcv">gapCV</code></td>
<td>
<p>An optional parameter defining the length of the sequence of
skipped values in the cross validation procedure.</p>
</td></tr>
</table>

<hr>
<h2 id='grocery'>Grocery and supermarkets turnover</h2><span id='topic+grocery'></span>

<h3>Description</h3>

<p>Turnover of supermarkets and grocery stores in New South Wales, Australia.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grocery
</code></pre>


<h3>Format</h3>

<p>An object of class <code>ts</code>.
</p>


<h3>References</h3>

<p>Australian Bureau of Statistics, CAT 8501.0.
(<a href="https://www.abs.gov.au/AUSSTATS/abs@.nsf/DetailsPage/8501.0Jun%202016?OpenDocument">TABLE 11. Retail Turnover, State by Industry Subgroup,
Original</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(grocery, ylab = "NSW Grocery, $ 10^6")
</code></pre>

<hr>
<h2 id='heuristicSTR'>Automatic STR decomposition with heuristic search of the parameters</h2><span id='topic+heuristicSTR'></span>

<h3>Description</h3>

<p>Automatically selects parameters (lambda coefficients) for an STR decomposition of time series data.
Heuristic approach can give a better estimate compare to a standard optmisaton methods used in <code><a href="#topic+STR">STR</a></code>.
</p>
<p>If a parallel backend is registered for use before <code>STR</code> call,
<code>heuristicSTR</code> will use it for n-fold cross validation computations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heuristicSTR(
  data,
  predictors,
  confidence = NULL,
  lambdas = NULL,
  pattern = extractPattern(predictors),
  nFold = 5,
  reltol = 0.005,
  gapCV = 1,
  solver = c("Matrix", "cholesky"),
  trace = FALSE,
  ratioGap = 1e+12,
  relCV = 0.01
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="heuristicSTR_+3A_data">data</code></td>
<td>
<p>Time series or a vector of length <em><strong>L</strong></em>.</p>
</td></tr>
<tr><td><code id="heuristicSTR_+3A_predictors">predictors</code></td>
<td>
<p>List of predictors.<br />
According to the paradigm of this implementation, the trend, the seasonal components,
the flexible predictors and the seasonal predictors are all presented in the same
form (as predictors) and must be described in this list.<br />
Every predictor is a list of the following structures:<br />
</p>

<ul>
<li> <p><strong>data</strong> &ndash; vector of length <em><strong>L</strong></em> (length of input data,
see above). For trend or for a seasonal component it is a vector of ones.
For a flexible or a seasonal predictor it is a vector of the predictor's data.
</p>
</li>
<li> <p><strong>times</strong> &ndash; vector of length <em><strong>L</strong></em> of times of observations.
</p>
</li>
<li> <p><strong>seasons</strong> &ndash; vector of length <em><strong>L</strong></em>. It is a vector of ones
for a trend or a flexible predictor. It is vector assigning seasons to every
observation (for a seasonal component or a seasonal predictor).
Seasons can be fractional for observations in between seasons.
</p>
</li>
<li> <p><strong>timeKnots</strong> &ndash; vector of times (time knots) where knots are positioned
(for a seasonal component or a seasonal predictor a few knots have the same time;
every knot is represented by time and season). Usually this vector coincides with
<strong>times</strong> vector described above, or <strong>timeKnots</strong> is a subset of
<strong>times</strong> vector.
</p>
</li>
<li> <p><strong>seasonalStructure</strong> &ndash; describes seasonal topology (which can have complex
structure) and seasonal knots.The seasonal topology is described by a list of
segments and seasonal knots, which are positioned inside the segments, on borders of
the segments or, when they are on on borders, they can connect two or more segments.<br />
<strong>seasonalStructure</strong> is a list of two elements:<br />
</p>

<ul>
<li> <p><strong>segments</strong> &ndash; a list of vectors representing segments.
Each vector must contain two ordered real values which represent left and right borders
of a segment. Segments should not intersect (inside same predictor).
</p>
</li>
<li> <p><strong>sKnots</strong> &ndash; a list of real values (vectors of length one) or vectors of
lengths two or greater (seasonal knots) defining seasons of the knots (every knot
is represented by time and season). All real values must belong (be inside or on
border of) segments listed in <strong>segments</strong>. If a few values represent a single
seasonal knot then all these values must be on borders of some segments (or a single
segment). In this case they represent a seasonal knot which connects a few segments
(or both sides of one segment).
</p>
</li></ul>

</li>
<li> <p><strong>lambdas</strong> &ndash; a vector with three values representing lambda (smoothing)
parameters (time-time, season-season, time-season flexibility parameters) for this
predictor.
</p>
</li></ul>
</td></tr>
<tr><td><code id="heuristicSTR_+3A_confidence">confidence</code></td>
<td>
<p>A vector of percentiles giving the coverage of confidence intervals.
It must be greater than 0 and less than 1.
If <code>NULL</code>, no confidence intervals are produced.</p>
</td></tr>
<tr><td><code id="heuristicSTR_+3A_lambdas">lambdas</code></td>
<td>
<p>An optional parameter.
A structure which replaces lambda parameters provided with predictors.
It is used as either a starting point for the optimisation of parameters or as the
exact model parameters.</p>
</td></tr>
<tr><td><code id="heuristicSTR_+3A_pattern">pattern</code></td>
<td>
<p>An optional parameter which has the same structure as <code>lambdas</code>
although with a different meaning. All zero values correspond to lambda
(smoothing) parameters which will not be estimated.</p>
</td></tr>
<tr><td><code id="heuristicSTR_+3A_nfold">nFold</code></td>
<td>
<p>An optional parameter setting the number of folds for cross validation.</p>
</td></tr>
<tr><td><code id="heuristicSTR_+3A_reltol">reltol</code></td>
<td>
<p>An optional parameter which is passed directly to <code><a href="stats.html#topic+optim">optim</a>()</code>
when optimising the parameters of the model.</p>
</td></tr>
<tr><td><code id="heuristicSTR_+3A_gapcv">gapCV</code></td>
<td>
<p>An optional parameter defining the length of the sequence of
skipped values in the cross validation procedure.</p>
</td></tr>
<tr><td><code id="heuristicSTR_+3A_solver">solver</code></td>
<td>
<p>A vector with two string values. The only supported combinations are:
c(&quot;Matrix&quot;, &quot;cholesky&quot;) (default), and c(&quot;Matrix&quot;, &quot;qr&quot;).
The parameter is used to specify a particular library
and method to solve the minimisation problem during STR decompositon.</p>
</td></tr>
<tr><td><code id="heuristicSTR_+3A_trace">trace</code></td>
<td>
<p>When <code>TRUE</code>, tracing is turned on.</p>
</td></tr>
<tr><td><code id="heuristicSTR_+3A_ratiogap">ratioGap</code></td>
<td>
<p>Ratio to define hyperparameter bounds for one-dimensional search.</p>
</td></tr>
<tr><td><code id="heuristicSTR_+3A_relcv">relCV</code></td>
<td>
<p>Minimum improvement required after all predictors tried. It is used to exit heuristic serach of lambda parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A structure containing input and output data.
It is an <strong>S3</strong> class <code>STR</code>, which is a list with the following components:
</p>

<ul>
<li> <p><strong>output</strong> &ndash; contains decomposed data. It is a list of three components:
</p>

<ul>
<li> <p><strong>predictors</strong> &ndash; a list of components where each component
corresponds to the input predictor. Every such component is a list containing the following:
</p>

<ul>
<li> <p><strong>data</strong> &ndash; fit/forecast for the corresponding predictor (trend, seasonal component, flexible or seasonal predictor).
</p>
</li>
<li> <p><strong>beta</strong> &ndash; beta coefficients of the fit of the coresponding predictor.
</p>
</li>
<li> <p><strong>lower</strong> &ndash; optional (if requested) matrix of lower bounds of confidence intervals.
</p>
</li>
<li> <p><strong>upper</strong> &ndash; optional (if requested) matrix of upper bounds of confidence intervals.
</p>
</li></ul>

</li>
<li> <p><strong>random</strong> &ndash; a list with one component <strong>data</strong>, which contains residuals of the model fit.
</p>
</li>
<li> <p><strong>forecast</strong> &ndash; a list with two components:
</p>

<ul>
<li> <p><strong>data</strong> &ndash; fit/forecast for the model.
</p>
</li>
<li> <p><strong>beta</strong> &ndash; beta coefficients of the fit.
</p>
</li>
<li> <p><strong>lower</strong> &ndash; optional (if requested) matrix of lower bounds of confidence intervals.
</p>
</li>
<li> <p><strong>upper</strong> &ndash; optional (if requested) matrix of upper bounds of confidence intervals.
</p>
</li></ul>

</li></ul>

</li>
<li> <p><strong>input</strong> &ndash; input parameters and lambdas used for final calculations.
</p>

<ul>
<li> <p><strong>data</strong> &ndash; input data.
</p>
</li>
<li> <p><strong>predictors</strong> - input predictors.
</p>
</li>
<li> <p><strong>lambdas</strong> &ndash; smoothing parameters used for final calculations (same as input lambdas for STR method).
</p>
</li></ul>

</li>
<li> <p><strong>cvMSE</strong> &ndash; optional cross validated (leave one out) Mean Squared Error.
</p>
</li>
<li> <p><strong>optim.CV.MSE</strong> or <strong>optim.CV.MAE</strong> &ndash; best cross validated Mean Squared Error or Mean Absolute Error (n-fold) achieved during minimisation procedure.
</p>
</li>
<li> <p><strong>nFold</strong> &ndash; the input <code>nFold</code> parameter.
</p>
</li>
<li> <p><strong>gapCV</strong> &ndash; the input <code>gapCV</code> parameter.
</p>
</li>
<li> <p><strong>method</strong> &ndash; contains strings <code>"STR"</code> or <code>"RSTR"</code> depending on used method.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Alexander Dokumentov
</p>


<h3>References</h3>

<p>Dokumentov, A., and Hyndman, R.J. (2022)
STR: Seasonal-Trend decomposition using Regression,
<em>INFORMS Journal on Data Science</em>, 1(1), 50-62.
<a href="https://robjhyndman.com/publications/str/">https://robjhyndman.com/publications/str/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+STR">STR</a></code> <code><a href="#topic+STRmodel">STRmodel</a></code> <code><a href="#topic+AutoSTR">AutoSTR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
TrendSeasonalStructure &lt;- list(
  segments = list(c(0, 1)),
  sKnots = list(c(1, 0))
)
WDSeasonalStructure &lt;- list(
  segments = list(c(0, 48), c(100, 148)),
  sKnots = c(as.list(c(1:47, 101:147)), list(c(0, 48, 100, 148)))
)

TrendSeasons &lt;- rep(1, nrow(electricity))
WDSeasons &lt;- as.vector(electricity[, "WorkingDaySeasonality"])

Data &lt;- as.vector(electricity[, "Consumption"])
Times &lt;- as.vector(electricity[, "Time"])
TempM &lt;- as.vector(electricity[, "Temperature"])
TempM2 &lt;- TempM^2

TrendTimeKnots &lt;- seq(from = head(Times, 1), to = tail(Times, 1), length.out = 116)
SeasonTimeKnots &lt;- seq(from = head(Times, 1), to = tail(Times, 1), length.out = 24)

TrendData &lt;- rep(1, length(Times))
SeasonData &lt;- rep(1, length(Times))

Trend &lt;- list(
  name = "Trend",
  data = TrendData,
  times = Times,
  seasons = TrendSeasons,
  timeKnots = TrendTimeKnots,
  seasonalStructure = TrendSeasonalStructure,
  lambdas = c(1500, 0, 0)
)
WDSeason &lt;- list(
  name = "Dayly seas",
  data = SeasonData,
  times = Times,
  seasons = WDSeasons,
  timeKnots = SeasonTimeKnots,
  seasonalStructure = WDSeasonalStructure,
  lambdas = c(0.003, 0, 240)
)
StaticTempM &lt;- list(
  name = "Temp Mel",
  data = TempM,
  times = Times,
  seasons = NULL,
  timeKnots = NULL,
  seasonalStructure = NULL,
  lambdas = c(0, 0, 0)
)
StaticTempM2 &lt;- list(
  name = "Temp Mel^2",
  data = TempM2,
  times = Times,
  seasons = NULL,
  timeKnots = NULL,
  seasonalStructure = NULL,
  lambdas = c(0, 0, 0)
)
Predictors &lt;- list(Trend, WDSeason, StaticTempM, StaticTempM2)

elec.fit &lt;- heuristicSTR(
  data = Data,
  predictors = Predictors,
  gapCV = 48 * 7
)

plot(elec.fit,
  xTime = as.Date("2000-01-11") + ((Times - 1) / 48 - 10),
  forecastPanels = NULL
)

########################################

TrendSeasonalStructure &lt;- list(
  segments = list(c(0, 1)),
  sKnots = list(c(1, 0))
)
DailySeasonalStructure &lt;- list(
  segments = list(c(0, 48)),
  sKnots = c(as.list(1:47), list(c(48, 0)))
)
WeeklySeasonalStructure &lt;- list(
  segments = list(c(0, 336)),
  sKnots = c(as.list(seq(4, 332, 4)), list(c(336, 0)))
)
WDSeasonalStructure &lt;- list(
  segments = list(c(0, 48), c(100, 148)),
  sKnots = c(as.list(c(1:47, 101:147)), list(c(0, 48, 100, 148)))
)

TrendSeasons &lt;- rep(1, nrow(electricity))
DailySeasons &lt;- as.vector(electricity[, "DailySeasonality"])
WeeklySeasons &lt;- as.vector(electricity[, "WeeklySeasonality"])
WDSeasons &lt;- as.vector(electricity[, "WorkingDaySeasonality"])

Data &lt;- as.vector(electricity[, "Consumption"])
Times &lt;- as.vector(electricity[, "Time"])
TempM &lt;- as.vector(electricity[, "Temperature"])
TempM2 &lt;- TempM^2

TrendTimeKnots &lt;- seq(from = head(Times, 1), to = tail(Times, 1), length.out = 116)
SeasonTimeKnots &lt;- seq(from = head(Times, 1), to = tail(Times, 1), length.out = 24)
SeasonTimeKnots2 &lt;- seq(from = head(Times, 1), to = tail(Times, 1), length.out = 12)

TrendData &lt;- rep(1, length(Times))
SeasonData &lt;- rep(1, length(Times))

Trend &lt;- list(
  name = "Trend",
  data = TrendData,
  times = Times,
  seasons = TrendSeasons,
  timeKnots = TrendTimeKnots,
  seasonalStructure = TrendSeasonalStructure,
  lambdas = c(1500, 0, 0)
)
WSeason &lt;- list(
  name = "Weekly seas",
  data = SeasonData,
  times = Times,
  seasons = WeeklySeasons,
  timeKnots = SeasonTimeKnots2,
  seasonalStructure = WeeklySeasonalStructure,
  lambdas = c(0.8, 0.6, 100)
)
WDSeason &lt;- list(
  name = "Dayly seas",
  data = SeasonData,
  times = Times,
  seasons = WDSeasons,
  timeKnots = SeasonTimeKnots,
  seasonalStructure = WDSeasonalStructure,
  lambdas = c(0.003, 0, 240)
)
TrendTempM &lt;- list(
  name = "Trend temp Mel",
  data = TempM,
  times = Times,
  seasons = TrendSeasons,
  timeKnots = TrendTimeKnots,
  seasonalStructure = TrendSeasonalStructure,
  lambdas = c(1e7, 0, 0)
)
TrendTempM2 &lt;- list(
  name = "Trend temp Mel^2",
  data = TempM2,
  times = Times,
  seasons = TrendSeasons,
  timeKnots = TrendTimeKnots,
  seasonalStructure = TrendSeasonalStructure,
  lambdas = c(0.01, 0, 0)
) # Starting parameter is too far from the optimal value
Predictors &lt;- list(Trend, WSeason, WDSeason, TrendTempM, TrendTempM2)

elec.fit &lt;- heuristicSTR(
  data = Data,
  predictors = Predictors,
  gapCV = 48 * 7
)

plot(elec.fit,
  xTime = as.Date("2000-01-11") + ((Times - 1) / 48 - 10),
  forecastPanels = NULL
)

plotBeta(elec.fit, predictorN = 4)
plotBeta(elec.fit, predictorN = 5)

</code></pre>

<hr>
<h2 id='lambdas'>Common argument</h2><span id='topic+lambdas'></span>

<h3>Description</h3>

<p>Common argument
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lambdas_+3A_lambdas">lambdas</code></td>
<td>
<p>An optional parameter.
A structure which replaces lambda parameters provided with predictors.
It is used as either a starting point for the optimisation of parameters or as the
exact model parameters.</p>
</td></tr>
</table>

<hr>
<h2 id='nFold'>Common argument</h2><span id='topic+nFold'></span>

<h3>Description</h3>

<p>Common argument
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nFold_+3A_nfold">nFold</code></td>
<td>
<p>An optional parameter setting the number of folds for cross validation.</p>
</td></tr>
</table>

<hr>
<h2 id='nMCIter'>Common argument</h2><span id='topic+nMCIter'></span>

<h3>Description</h3>

<p>Common argument
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nMCIter_+3A_nmciter">nMCIter</code></td>
<td>
<p>Number of Monte Carlo iterations used to estimate confidence intervals for Robust STR decomposition.</p>
</td></tr>
</table>

<hr>
<h2 id='pattern'>Common argument</h2><span id='topic+pattern'></span>

<h3>Description</h3>

<p>Common argument
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pattern_+3A_pattern">pattern</code></td>
<td>
<p>An optional parameter which has the same structure as <code>lambdas</code>
although with a different meaning. All zero values correspond to lambda
(smoothing) parameters which will not be estimated.</p>
</td></tr>
</table>

<hr>
<h2 id='plot.STR'>Plots the results of decomposition</h2><span id='topic+plot.STR'></span>

<h3>Description</h3>

<p><code>plot.STR</code> plots results of STR decomposition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'STR'
plot(
  x,
  xTime = NULL,
  dataPanels = 1,
  predictorPanels = as.list(seq_along(x$output$predictors)),
  randomPanels = length(x$output$predictors) + 1,
  forecastPanels = length(x$output$predictors) + 2,
  dataColor = "black",
  predictorColors = rep("red", length(x$output$predictors)),
  randomColor = "red",
  forecastColor = "blue",
  vLines = NULL,
  xlab = "Time",
  main = ifelse(x$method %in% c("STR", "STRmodel"), "STR decomposition",
    "Robust STR decomposition"),
  showLegend = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.STR_+3A_x">x</code></td>
<td>
<p>Result of STR decomposition.</p>
</td></tr>
<tr><td><code id="plot.STR_+3A_xtime">xTime</code></td>
<td>
<p>Times for data to plot.</p>
</td></tr>
<tr><td><code id="plot.STR_+3A_datapanels">dataPanels</code></td>
<td>
<p>Vector of panel numbers in which to plot the original data. Set to <code>NULL</code> to not show data.</p>
</td></tr>
<tr><td><code id="plot.STR_+3A_predictorpanels">predictorPanels</code></td>
<td>
<p>A list of vectors of numbers where every such vector describes which panels should be used for plotting the corresponding predictor.</p>
</td></tr>
<tr><td><code id="plot.STR_+3A_randompanels">randomPanels</code></td>
<td>
<p>Vector of panel numbers in which to plot the residuals.  Set to <code>NULL</code> to not show residuals.</p>
</td></tr>
<tr><td><code id="plot.STR_+3A_forecastpanels">forecastPanels</code></td>
<td>
<p>Vector of panel numbers in which to plot the fit/forecast.  Set to <code>NULL</code> to not show forecasts.</p>
</td></tr>
<tr><td><code id="plot.STR_+3A_datacolor">dataColor</code></td>
<td>
<p>Color to plot data.</p>
</td></tr>
<tr><td><code id="plot.STR_+3A_predictorcolors">predictorColors</code></td>
<td>
<p>Vector of colors to plot components corresponding to the predictors.</p>
</td></tr>
<tr><td><code id="plot.STR_+3A_randomcolor">randomColor</code></td>
<td>
<p>Color to plot the residuals.</p>
</td></tr>
<tr><td><code id="plot.STR_+3A_forecastcolor">forecastColor</code></td>
<td>
<p>Color to plot the fit/forecast.</p>
</td></tr>
<tr><td><code id="plot.STR_+3A_vlines">vLines</code></td>
<td>
<p>Vector of times where vertical lines will be plotted.</p>
</td></tr>
<tr><td><code id="plot.STR_+3A_xlab">xlab</code></td>
<td>
<p>Label for horizontal axis.</p>
</td></tr>
<tr><td><code id="plot.STR_+3A_main">main</code></td>
<td>
<p>Main heading for plot.</p>
</td></tr>
<tr><td><code id="plot.STR_+3A_showlegend">showLegend</code></td>
<td>
<p>When <code>TRUE</code> (default) legend is shown at top of plot.</p>
</td></tr>
<tr><td><code id="plot.STR_+3A_...">...</code></td>
<td>
<p>Other parameters to be passed directly to plot and lines functions in the implementation.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alexander Dokumentov
</p>


<h3>See Also</h3>

<p><code><a href="#topic+STRmodel">STRmodel</a></code>, <code><a href="#topic+RSTRmodel">RSTRmodel</a></code>, <code><a href="#topic+STR">STR</a></code>, <code><a href="#topic+AutoSTR">AutoSTR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fit &lt;- AutoSTR(log(grocery))
plot(fit, forecastPanels = 0, randomColor = "DarkGreen", vLines = 2000:2010, lwd = 2)

</code></pre>

<hr>
<h2 id='plotBeta'>Plots the varying beta coefficients of decomposition</h2><span id='topic+plotBeta'></span>

<h3>Description</h3>

<p><code>plotBeta</code> plots the varying beta coefficients of STR decomposition.
It plots coefficients only only for independent seasons (one less season than defined).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotBeta(
  x,
  xTime = NULL,
  predictorN = 1,
  dim = c(1, 2, 3),
  type = "o",
  pch = 20,
  palette = function(n) rainbow(n, start = 0, end = 0.7)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotBeta_+3A_x">x</code></td>
<td>
<p>Result of STR decomposition.</p>
</td></tr>
<tr><td><code id="plotBeta_+3A_xtime">xTime</code></td>
<td>
<p>Times for data to plot.</p>
</td></tr>
<tr><td><code id="plotBeta_+3A_predictorn">predictorN</code></td>
<td>
<p>Predictor number in the decomposition to plot the corresponding beta coefficiets.</p>
</td></tr>
<tr><td><code id="plotBeta_+3A_dim">dim</code></td>
<td>
<p>Dimensions to use to plot the beta coefficients.
When <code>1</code>, the standard charts are used.
When <code>2</code>, <code>graphics:::filled.contour</code> function is used.
When <code>3</code>, <code>rgl:::persp3d</code> is used. The default value is <code>1</code>.</p>
</td></tr>
<tr><td><code id="plotBeta_+3A_type">type</code></td>
<td>
<p>Type of the graph for one dimensional plots.</p>
</td></tr>
<tr><td><code id="plotBeta_+3A_pch">pch</code></td>
<td>
<p>Symbol code to plot points in 1-dimensional charts. Default value is <code>20</code>.</p>
</td></tr>
<tr><td><code id="plotBeta_+3A_palette">palette</code></td>
<td>
<p>Color palette for 2 - and 3 - dimentional plots.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alexander Dokumentov
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.STR">plot.STR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fit &lt;- AutoSTR(log(grocery))
for (i in 1:2) plotBeta(fit, predictorN = i, dim = 2)

########################################

TrendSeasonalStructure &lt;- list(
  segments = list(c(0, 1)),
  sKnots = list(c(1, 0))
)
DailySeasonalStructure &lt;- list(
  segments = list(c(0, 48)),
  sKnots = c(as.list(1:47), list(c(48, 0)))
)
WeeklySeasonalStructure &lt;- list(
  segments = list(c(0, 336)),
  sKnots = c(as.list(seq(4, 332, 4)), list(c(336, 0)))
)
WDSeasonalStructure &lt;- list(
  segments = list(c(0, 48), c(100, 148)),
  sKnots = c(as.list(c(1:47, 101:147)), list(c(0, 48, 100, 148)))
)

TrendSeasons &lt;- rep(1, nrow(electricity))
DailySeasons &lt;- as.vector(electricity[, "DailySeasonality"])
WeeklySeasons &lt;- as.vector(electricity[, "WeeklySeasonality"])
WDSeasons &lt;- as.vector(electricity[, "WorkingDaySeasonality"])

Data &lt;- as.vector(electricity[, "Consumption"])
Times &lt;- as.vector(electricity[, "Time"])
TempM &lt;- as.vector(electricity[, "Temperature"])
TempM2 &lt;- TempM^2

TrendTimeKnots &lt;- seq(from = head(Times, 1), to = tail(Times, 1), length.out = 116)
SeasonTimeKnots &lt;- seq(from = head(Times, 1), to = tail(Times, 1), length.out = 24)
SeasonTimeKnots2 &lt;- seq(from = head(Times, 1), to = tail(Times, 1), length.out = 12)

TrendData &lt;- rep(1, length(Times))
SeasonData &lt;- rep(1, length(Times))

Trend &lt;- list(
  name = "Trend",
  data = TrendData,
  times = Times,
  seasons = TrendSeasons,
  timeKnots = TrendTimeKnots,
  seasonalStructure = TrendSeasonalStructure,
  lambdas = c(1500, 0, 0)
)
WSeason &lt;- list(
  name = "Weekly seas",
  data = SeasonData,
  times = Times,
  seasons = WeeklySeasons,
  timeKnots = SeasonTimeKnots2,
  seasonalStructure = WeeklySeasonalStructure,
  lambdas = c(0.8, 0.6, 100)
)
WDSeason &lt;- list(
  name = "Dayly seas",
  data = SeasonData,
  times = Times,
  seasons = WDSeasons,
  timeKnots = SeasonTimeKnots,
  seasonalStructure = WDSeasonalStructure,
  lambdas = c(0.003, 0, 240)
)
TrendTempM &lt;- list(
  name = "Trend temp Mel",
  data = TempM,
  times = Times,
  seasons = TrendSeasons,
  timeKnots = TrendTimeKnots,
  seasonalStructure = TrendSeasonalStructure,
  lambdas = c(1e7, 0, 0)
)
TrendTempM2 &lt;- list(
  name = "Trend temp Mel^2",
  data = TempM2,
  times = Times,
  seasons = TrendSeasons,
  timeKnots = TrendTimeKnots,
  seasonalStructure = TrendSeasonalStructure,
  lambdas = c(0.01, 0, 0)
) # Starting parameter is too far from the optimal value
Predictors &lt;- list(Trend, WSeason, WDSeason, TrendTempM, TrendTempM2)

elec.fit &lt;- STR(
  data = Data,
  predictors = Predictors,
  gapCV = 48 * 7
)

plot(elec.fit,
  xTime = as.Date("2000-01-11") + ((Times - 1) / 48 - 10),
  forecastPanels = NULL
)

plotBeta(elec.fit, predictorN = 4)
plotBeta(elec.fit, predictorN = 5) # Beta coefficients are too "wiggly"

</code></pre>

<hr>
<h2 id='predictors'>Common argument</h2><span id='topic+predictors'></span>

<h3>Description</h3>

<p>Common argument
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predictors_+3A_predictors">predictors</code></td>
<td>
<p>List of predictors.<br />
According to the paradigm of this implementation, the trend, the seasonal components,
the flexible predictors and the seasonal predictors are all presented in the same
form (as predictors) and must be described in this list.<br />
Every predictor is a list of the following structures:<br />
</p>

<ul>
<li> <p><strong>data</strong> &ndash; vector of length <em><strong>L</strong></em> (length of input data,
see above). For trend or for a seasonal component it is a vector of ones.
For a flexible or a seasonal predictor it is a vector of the predictor's data.
</p>
</li>
<li> <p><strong>times</strong> &ndash; vector of length <em><strong>L</strong></em> of times of observations.
</p>
</li>
<li> <p><strong>seasons</strong> &ndash; vector of length <em><strong>L</strong></em>. It is a vector of ones
for a trend or a flexible predictor. It is vector assigning seasons to every
observation (for a seasonal component or a seasonal predictor).
Seasons can be fractional for observations in between seasons.
</p>
</li>
<li> <p><strong>timeKnots</strong> &ndash; vector of times (time knots) where knots are positioned
(for a seasonal component or a seasonal predictor a few knots have the same time;
every knot is represented by time and season). Usually this vector coincides with
<strong>times</strong> vector described above, or <strong>timeKnots</strong> is a subset of
<strong>times</strong> vector.
</p>
</li>
<li> <p><strong>seasonalStructure</strong> &ndash; describes seasonal topology (which can have complex
structure) and seasonal knots.The seasonal topology is described by a list of
segments and seasonal knots, which are positioned inside the segments, on borders of
the segments or, when they are on on borders, they can connect two or more segments.<br />
<strong>seasonalStructure</strong> is a list of two elements:<br />
</p>

<ul>
<li> <p><strong>segments</strong> &ndash; a list of vectors representing segments.
Each vector must contain two ordered real values which represent left and right borders
of a segment. Segments should not intersect (inside same predictor).
</p>
</li>
<li> <p><strong>sKnots</strong> &ndash; a list of real values (vectors of length one) or vectors of
lengths two or greater (seasonal knots) defining seasons of the knots (every knot
is represented by time and season). All real values must belong (be inside or on
border of) segments listed in <strong>segments</strong>. If a few values represent a single
seasonal knot then all these values must be on borders of some segments (or a single
segment). In this case they represent a seasonal knot which connects a few segments
(or both sides of one segment).
</p>
</li></ul>

</li>
<li> <p><strong>lambdas</strong> &ndash; a vector with three values representing lambda (smoothing)
parameters (time-time, season-season, time-season flexibility parameters) for this
predictor.
</p>
</li></ul>
</td></tr>
</table>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+seasadj'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>forecast</dt><dd><p><code><a href="forecast.html#topic+seasadj">seasadj</a></code></p>
</dd>
</dl>

<hr>
<h2 id='reltol'>Common argument</h2><span id='topic+reltol'></span>

<h3>Description</h3>

<p>Common argument
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reltol_+3A_reltol">reltol</code></td>
<td>
<p>An optional parameter which is passed directly to <code><a href="stats.html#topic+optim">optim</a>()</code>
when optimising the parameters of the model.</p>
</td></tr>
</table>

<hr>
<h2 id='reportDimensionsOnly'>Common argument</h2><span id='topic+reportDimensionsOnly'></span>

<h3>Description</h3>

<p>Common argument
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reportDimensionsOnly_+3A_reportdimensionsonly">reportDimensionsOnly</code></td>
<td>
<p>A boolean parameter. When TRUE the method constructs the
design matrix and reports its dimensions without proceeding further.
It is mostly used for debugging.</p>
</td></tr>
</table>

<hr>
<h2 id='robust'>Common argument</h2><span id='topic+robust'></span>

<h3>Description</h3>

<p>Common argument
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="robust_+3A_robust">robust</code></td>
<td>
<p>When <code>TRUE</code>, Robust STR decomposition is used. Default is <code>FALSE</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='RSTRmodel'>Robust STR decomposition</h2><span id='topic+RSTRmodel'></span>

<h3>Description</h3>

<p>Robust Seasonal-Trend decomposition of time series data using Regression (robust version of <code><a href="#topic+STRmodel">STRmodel</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RSTRmodel(
  data,
  predictors = NULL,
  strDesign = NULL,
  lambdas = NULL,
  confidence = NULL,
  nMCIter = 100,
  control = list(nnzlmax = 1e+06, nsubmax = 3e+05, tmpmax = 50000),
  reportDimensionsOnly = FALSE,
  trace = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RSTRmodel_+3A_data">data</code></td>
<td>
<p>Time series or a vector of length <em><strong>L</strong></em>.</p>
</td></tr>
<tr><td><code id="RSTRmodel_+3A_predictors">predictors</code></td>
<td>
<p>List of predictors.<br />
According to the paradigm of this implementation, the trend, the seasonal components,
the flexible predictors and the seasonal predictors are all presented in the same
form (as predictors) and must be described in this list.<br />
Every predictor is a list of the following structures:<br />
</p>

<ul>
<li> <p><strong>data</strong> &ndash; vector of length <em><strong>L</strong></em> (length of input data,
see above). For trend or for a seasonal component it is a vector of ones.
For a flexible or a seasonal predictor it is a vector of the predictor's data.
</p>
</li>
<li> <p><strong>times</strong> &ndash; vector of length <em><strong>L</strong></em> of times of observations.
</p>
</li>
<li> <p><strong>seasons</strong> &ndash; vector of length <em><strong>L</strong></em>. It is a vector of ones
for a trend or a flexible predictor. It is vector assigning seasons to every
observation (for a seasonal component or a seasonal predictor).
Seasons can be fractional for observations in between seasons.
</p>
</li>
<li> <p><strong>timeKnots</strong> &ndash; vector of times (time knots) where knots are positioned
(for a seasonal component or a seasonal predictor a few knots have the same time;
every knot is represented by time and season). Usually this vector coincides with
<strong>times</strong> vector described above, or <strong>timeKnots</strong> is a subset of
<strong>times</strong> vector.
</p>
</li>
<li> <p><strong>seasonalStructure</strong> &ndash; describes seasonal topology (which can have complex
structure) and seasonal knots.The seasonal topology is described by a list of
segments and seasonal knots, which are positioned inside the segments, on borders of
the segments or, when they are on on borders, they can connect two or more segments.<br />
<strong>seasonalStructure</strong> is a list of two elements:<br />
</p>

<ul>
<li> <p><strong>segments</strong> &ndash; a list of vectors representing segments.
Each vector must contain two ordered real values which represent left and right borders
of a segment. Segments should not intersect (inside same predictor).
</p>
</li>
<li> <p><strong>sKnots</strong> &ndash; a list of real values (vectors of length one) or vectors of
lengths two or greater (seasonal knots) defining seasons of the knots (every knot
is represented by time and season). All real values must belong (be inside or on
border of) segments listed in <strong>segments</strong>. If a few values represent a single
seasonal knot then all these values must be on borders of some segments (or a single
segment). In this case they represent a seasonal knot which connects a few segments
(or both sides of one segment).
</p>
</li></ul>

</li>
<li> <p><strong>lambdas</strong> &ndash; a vector with three values representing lambda (smoothing)
parameters (time-time, season-season, time-season flexibility parameters) for this
predictor.
</p>
</li></ul>
</td></tr>
<tr><td><code id="RSTRmodel_+3A_strdesign">strDesign</code></td>
<td>
<p>An optional parameter used to create the design
matrix. It is used internally in the library to improve performance when the design
matrix does not require full recalculation.</p>
</td></tr>
<tr><td><code id="RSTRmodel_+3A_lambdas">lambdas</code></td>
<td>
<p>An optional parameter.
A structure which replaces lambda parameters provided with predictors.
It is used as either a starting point for the optimisation of parameters or as the
exact model parameters.</p>
</td></tr>
<tr><td><code id="RSTRmodel_+3A_confidence">confidence</code></td>
<td>
<p>A vector of percentiles giving the coverage of confidence intervals.
It must be greater than 0 and less than 1.
If <code>NULL</code>, no confidence intervals are produced.</p>
</td></tr>
<tr><td><code id="RSTRmodel_+3A_nmciter">nMCIter</code></td>
<td>
<p>Number of Monte Carlo iterations used to estimate confidence intervals for Robust STR decomposition.</p>
</td></tr>
<tr><td><code id="RSTRmodel_+3A_control">control</code></td>
<td>
<p>Passed directly to <code><a href="quantreg.html#topic+rq.fit.sfn">rq.fit.sfn</a>()</code> during Robust STR decomposition.</p>
</td></tr>
<tr><td><code id="RSTRmodel_+3A_reportdimensionsonly">reportDimensionsOnly</code></td>
<td>
<p>A boolean parameter. When TRUE the method constructs the
design matrix and reports its dimensions without proceeding further.
It is mostly used for debugging.</p>
</td></tr>
<tr><td><code id="RSTRmodel_+3A_trace">trace</code></td>
<td>
<p>When <code>TRUE</code>, tracing is turned on.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A structure containing input and output data.
It is an <strong>S3</strong> class <code>STR</code>, which is a list with the following components:
</p>

<ul>
<li> <p><strong>output</strong> &ndash; contains decomposed data. It is a list of three components:
</p>

<ul>
<li> <p><strong>predictors</strong> &ndash; a list of components where each component
corresponds to the input predictor. Every such component is a list containing the following:
</p>

<ul>
<li> <p><strong>data</strong> &ndash; fit/forecast for the corresponding predictor (trend, seasonal component, flexible or seasonal predictor).
</p>
</li>
<li> <p><strong>beta</strong> &ndash; beta coefficients of the fit of the coresponding predictor.
</p>
</li>
<li> <p><strong>lower</strong> &ndash; optional (if requested) matrix of lower bounds of confidence intervals.
</p>
</li>
<li> <p><strong>upper</strong> &ndash; optional (if requested) matrix of upper bounds of confidence intervals.
</p>
</li></ul>

</li>
<li> <p><strong>random</strong> &ndash; a list with one component <strong>data</strong>, which contains residuals of the model fit.
</p>
</li>
<li> <p><strong>forecast</strong> &ndash; a list with two components:
</p>

<ul>
<li> <p><strong>data</strong> &ndash; fit/forecast for the model.
</p>
</li>
<li> <p><strong>beta</strong> &ndash; beta coefficients of the fit.
</p>
</li>
<li> <p><strong>lower</strong> &ndash; optional (if requested) matrix of lower bounds of confidence intervals.
</p>
</li>
<li> <p><strong>upper</strong> &ndash; optional (if requested) matrix of upper bounds of confidence intervals.
</p>
</li></ul>

</li></ul>

</li>
<li> <p><strong>input</strong> &ndash; input parameters and lambdas used for final calculations.
</p>

<ul>
<li> <p><strong>data</strong> &ndash; input data.
</p>
</li>
<li> <p><strong>predictors</strong> - input predictors.
</p>
</li>
<li> <p><strong>lambdas</strong> &ndash; smoothing parameters used for final calculations (same as input lambdas for STR method).
</p>
</li></ul>

</li>
<li> <p><strong>method</strong> &ndash; always contains string <code>"RSTRmodel"</code> for this function.




</p>
</li></ul>



<h3>Author(s)</h3>

<p>Alexander Dokumentov
</p>


<h3>References</h3>

<p>Dokumentov, A., and Hyndman, R.J. (2022)
STR: Seasonal-Trend decomposition using Regression,
<em>INFORMS Journal on Data Science</em>, 1(1), 50-62.
<a href="https://robjhyndman.com/publications/str/">https://robjhyndman.com/publications/str/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+STRmodel">STRmodel</a></code> <code><a href="#topic+STR">STR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n &lt;- 70
trendSeasonalStructure &lt;- list(segments = list(c(0, 1)), sKnots = list(c(1, 0)))
ns &lt;- 5
seasonalStructure &lt;- list(
  segments = list(c(0, ns)),
  sKnots = c(as.list(1:(ns - 1)), list(c(ns, 0)))
)
seasons &lt;- (0:(n - 1)) %% ns + 1
trendSeasons &lt;- rep(1, length(seasons))
times &lt;- seq_along(seasons)
data &lt;- seasons + times / 4
set.seed(1234567890)
data &lt;- data + rnorm(length(data), 0, 0.2)
data[20] &lt;- data[20] + 3
data[50] &lt;- data[50] - 5
plot(times, data, type = "l")
timeKnots &lt;- times
trendData &lt;- rep(1, n)
seasonData &lt;- rep(1, n)
trend &lt;- list(
  data = trendData, times = times, seasons = trendSeasons,
  timeKnots = timeKnots, seasonalStructure = trendSeasonalStructure, lambdas = c(1, 0, 0)
)
season &lt;- list(
  data = seasonData, times = times, seasons = seasons,
  timeKnots = timeKnots, seasonalStructure = seasonalStructure, lambdas = c(1, 0, 1)
)
predictors &lt;- list(trend, season)
rstr &lt;- RSTRmodel(data, predictors, confidence = 0.8)
plot(rstr)

</code></pre>

<hr>
<h2 id='seasadj.STR'>Seasonal adjustment based on STR</h2><span id='topic+seasadj.STR'></span>

<h3>Description</h3>

<p><code>seasadj.STR</code> extracts seasonally adjusted data by removing the seasonal components from the result of STR decomposition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'STR'
seasadj(object, include = c("Trend", "Random"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="seasadj.STR_+3A_object">object</code></td>
<td>
<p>Result of STR decomposition.</p>
</td></tr>
<tr><td><code id="seasadj.STR_+3A_include">include</code></td>
<td>
<p>Vector of component names to include in the result. The default is <code>c("Trend", "Random")</code>.</p>
</td></tr>
<tr><td><code id="seasadj.STR_+3A_...">...</code></td>
<td>
<p>Other arguments not currently used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alexander Dokumentov
</p>


<h3>See Also</h3>

<p><code><a href="#topic+STRmodel">STRmodel</a></code>, <code><a href="#topic+RSTRmodel">RSTRmodel</a></code>, <code><a href="#topic+STR">STR</a></code>, <code><a href="#topic+AutoSTR">AutoSTR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fit &lt;- AutoSTR(log(grocery))
plot(seasadj(fit))

</code></pre>

<hr>
<h2 id='solver'>Common argument</h2><span id='topic+solver'></span>

<h3>Description</h3>

<p>Common argument
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="solver_+3A_solver">solver</code></td>
<td>
<p>A vector with two string values. The only supported combinations are:
c(&quot;Matrix&quot;, &quot;cholesky&quot;) (default), and c(&quot;Matrix&quot;, &quot;qr&quot;).
The parameter is used to specify a particular library
and method to solve the minimisation problem during STR decompositon.</p>
</td></tr>
</table>

<hr>
<h2 id='STR'>Automatic STR decomposition</h2><span id='topic+STR'></span>

<h3>Description</h3>

<p>Automatically selects parameters for an STR decomposition of time series data.
</p>
<p>If a parallel backend is registered for use before <code>STR</code> call,
<code>STR</code> will use it for n-fold cross validation computations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>STR(
  data,
  predictors,
  confidence = NULL,
  robust = FALSE,
  lambdas = NULL,
  pattern = extractPattern(predictors),
  nFold = 5,
  reltol = 0.005,
  gapCV = 1,
  solver = c("Matrix", "cholesky"),
  nMCIter = 100,
  control = list(nnzlmax = 1e+06, nsubmax = 3e+05, tmpmax = 50000),
  trace = FALSE,
  iterControl = list(maxiter = 20, tol = 1e-06)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="STR_+3A_data">data</code></td>
<td>
<p>Time series or a vector of length <em><strong>L</strong></em>.</p>
</td></tr>
<tr><td><code id="STR_+3A_predictors">predictors</code></td>
<td>
<p>List of predictors.<br />
According to the paradigm of this implementation, the trend, the seasonal components,
the flexible predictors and the seasonal predictors are all presented in the same
form (as predictors) and must be described in this list.<br />
Every predictor is a list of the following structures:<br />
</p>

<ul>
<li> <p><strong>data</strong> &ndash; vector of length <em><strong>L</strong></em> (length of input data,
see above). For trend or for a seasonal component it is a vector of ones.
For a flexible or a seasonal predictor it is a vector of the predictor's data.
</p>
</li>
<li> <p><strong>times</strong> &ndash; vector of length <em><strong>L</strong></em> of times of observations.
</p>
</li>
<li> <p><strong>seasons</strong> &ndash; vector of length <em><strong>L</strong></em>. It is a vector of ones
for a trend or a flexible predictor. It is vector assigning seasons to every
observation (for a seasonal component or a seasonal predictor).
Seasons can be fractional for observations in between seasons.
</p>
</li>
<li> <p><strong>timeKnots</strong> &ndash; vector of times (time knots) where knots are positioned
(for a seasonal component or a seasonal predictor a few knots have the same time;
every knot is represented by time and season). Usually this vector coincides with
<strong>times</strong> vector described above, or <strong>timeKnots</strong> is a subset of
<strong>times</strong> vector.
</p>
</li>
<li> <p><strong>seasonalStructure</strong> &ndash; describes seasonal topology (which can have complex
structure) and seasonal knots.The seasonal topology is described by a list of
segments and seasonal knots, which are positioned inside the segments, on borders of
the segments or, when they are on on borders, they can connect two or more segments.<br />
<strong>seasonalStructure</strong> is a list of two elements:<br />
</p>

<ul>
<li> <p><strong>segments</strong> &ndash; a list of vectors representing segments.
Each vector must contain two ordered real values which represent left and right borders
of a segment. Segments should not intersect (inside same predictor).
</p>
</li>
<li> <p><strong>sKnots</strong> &ndash; a list of real values (vectors of length one) or vectors of
lengths two or greater (seasonal knots) defining seasons of the knots (every knot
is represented by time and season). All real values must belong (be inside or on
border of) segments listed in <strong>segments</strong>. If a few values represent a single
seasonal knot then all these values must be on borders of some segments (or a single
segment). In this case they represent a seasonal knot which connects a few segments
(or both sides of one segment).
</p>
</li></ul>

</li>
<li> <p><strong>lambdas</strong> &ndash; a vector with three values representing lambda (smoothing)
parameters (time-time, season-season, time-season flexibility parameters) for this
predictor.
</p>
</li></ul>
</td></tr>
<tr><td><code id="STR_+3A_confidence">confidence</code></td>
<td>
<p>A vector of percentiles giving the coverage of confidence intervals.
It must be greater than 0 and less than 1.
If <code>NULL</code>, no confidence intervals are produced.</p>
</td></tr>
<tr><td><code id="STR_+3A_robust">robust</code></td>
<td>
<p>When <code>TRUE</code>, Robust STR decomposition is used. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="STR_+3A_lambdas">lambdas</code></td>
<td>
<p>An optional parameter.
A structure which replaces lambda parameters provided with predictors.
It is used as either a starting point for the optimisation of parameters or as the
exact model parameters.</p>
</td></tr>
<tr><td><code id="STR_+3A_pattern">pattern</code></td>
<td>
<p>An optional parameter which has the same structure as <code>lambdas</code>
although with a different meaning. All zero values correspond to lambda
(smoothing) parameters which will not be estimated.</p>
</td></tr>
<tr><td><code id="STR_+3A_nfold">nFold</code></td>
<td>
<p>An optional parameter setting the number of folds for cross validation.</p>
</td></tr>
<tr><td><code id="STR_+3A_reltol">reltol</code></td>
<td>
<p>An optional parameter which is passed directly to <code><a href="stats.html#topic+optim">optim</a>()</code>
when optimising the parameters of the model.</p>
</td></tr>
<tr><td><code id="STR_+3A_gapcv">gapCV</code></td>
<td>
<p>An optional parameter defining the length of the sequence of
skipped values in the cross validation procedure.</p>
</td></tr>
<tr><td><code id="STR_+3A_solver">solver</code></td>
<td>
<p>A vector with two string values. The only supported combinations are:
c(&quot;Matrix&quot;, &quot;cholesky&quot;) (default), and c(&quot;Matrix&quot;, &quot;qr&quot;).
The parameter is used to specify a particular library
and method to solve the minimisation problem during STR decompositon.</p>
</td></tr>
<tr><td><code id="STR_+3A_nmciter">nMCIter</code></td>
<td>
<p>Number of Monte Carlo iterations used to estimate confidence intervals for Robust STR decomposition.</p>
</td></tr>
<tr><td><code id="STR_+3A_control">control</code></td>
<td>
<p>Passed directly to <code><a href="quantreg.html#topic+rq.fit.sfn">rq.fit.sfn</a>()</code> during Robust STR decomposition.</p>
</td></tr>
<tr><td><code id="STR_+3A_trace">trace</code></td>
<td>
<p>When <code>TRUE</code>, tracing is turned on.</p>
</td></tr>
<tr><td><code id="STR_+3A_itercontrol">iterControl</code></td>
<td>
<p>Control parameters for some experimental features.
This should not be used by an ordinary user.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A structure containing input and output data.
It is an <strong>S3</strong> class <code>STR</code>, which is a list with the following components:
</p>

<ul>
<li> <p><strong>output</strong> &ndash; contains decomposed data. It is a list of three components:
</p>

<ul>
<li> <p><strong>predictors</strong> &ndash; a list of components where each component
corresponds to the input predictor. Every such component is a list containing the following:
</p>

<ul>
<li> <p><strong>data</strong> &ndash; fit/forecast for the corresponding predictor (trend, seasonal component, flexible or seasonal predictor).
</p>
</li>
<li> <p><strong>beta</strong> &ndash; beta coefficients of the fit of the coresponding predictor.
</p>
</li>
<li> <p><strong>lower</strong> &ndash; optional (if requested) matrix of lower bounds of confidence intervals.
</p>
</li>
<li> <p><strong>upper</strong> &ndash; optional (if requested) matrix of upper bounds of confidence intervals.
</p>
</li></ul>

</li>
<li> <p><strong>random</strong> &ndash; a list with one component <strong>data</strong>, which contains residuals of the model fit.
</p>
</li>
<li> <p><strong>forecast</strong> &ndash; a list with two components:
</p>

<ul>
<li> <p><strong>data</strong> &ndash; fit/forecast for the model.
</p>
</li>
<li> <p><strong>beta</strong> &ndash; beta coefficients of the fit.
</p>
</li>
<li> <p><strong>lower</strong> &ndash; optional (if requested) matrix of lower bounds of confidence intervals.
</p>
</li>
<li> <p><strong>upper</strong> &ndash; optional (if requested) matrix of upper bounds of confidence intervals.
</p>
</li></ul>

</li></ul>

</li>
<li> <p><strong>input</strong> &ndash; input parameters and lambdas used for final calculations.
</p>

<ul>
<li> <p><strong>data</strong> &ndash; input data.
</p>
</li>
<li> <p><strong>predictors</strong> - input predictors.
</p>
</li>
<li> <p><strong>lambdas</strong> &ndash; smoothing parameters used for final calculations (same as input lambdas for STR method).
</p>
</li></ul>

</li>
<li> <p><strong>cvMSE</strong> &ndash; optional cross validated (leave one out) Mean Squared Error.
</p>
</li>
<li> <p><strong>optim.CV.MSE</strong> or <strong>optim.CV.MAE</strong> &ndash; best cross validated Mean Squared Error or Mean Absolute Error (n-fold) achieved during minimisation procedure.
</p>
</li>
<li> <p><strong>nFold</strong> &ndash; the input <code>nFold</code> parameter.
</p>
</li>
<li> <p><strong>gapCV</strong> &ndash; the input <code>gapCV</code> parameter.
</p>
</li>
<li> <p><strong>method</strong> &ndash; contains strings <code>"STR"</code> or <code>"RSTR"</code> depending on used method.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Alexander Dokumentov
</p>


<h3>References</h3>

<p>Dokumentov, A., and Hyndman, R.J. (2022)
STR: Seasonal-Trend decomposition using Regression,
<em>INFORMS Journal on Data Science</em>, 1(1), 50-62.
<a href="https://robjhyndman.com/publications/str/">https://robjhyndman.com/publications/str/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+STRmodel">STRmodel</a></code> <code><a href="#topic+RSTRmodel">RSTRmodel</a></code> <code><a href="#topic+AutoSTR">AutoSTR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
TrendSeasonalStructure &lt;- list(
  segments = list(c(0, 1)),
  sKnots = list(c(1, 0))
)
WDSeasonalStructure &lt;- list(
  segments = list(c(0, 48), c(100, 148)),
  sKnots = c(as.list(c(1:47, 101:147)), list(c(0, 48, 100, 148)))
)

TrendSeasons &lt;- rep(1, nrow(electricity))
WDSeasons &lt;- as.vector(electricity[, "WorkingDaySeasonality"])

Data &lt;- as.vector(electricity[, "Consumption"])
Times &lt;- as.vector(electricity[, "Time"])
TempM &lt;- as.vector(electricity[, "Temperature"])
TempM2 &lt;- TempM^2

TrendTimeKnots &lt;- seq(from = head(Times, 1), to = tail(Times, 1), length.out = 116)
SeasonTimeKnots &lt;- seq(from = head(Times, 1), to = tail(Times, 1), length.out = 24)

TrendData &lt;- rep(1, length(Times))
SeasonData &lt;- rep(1, length(Times))

Trend &lt;- list(
  name = "Trend",
  data = TrendData,
  times = Times,
  seasons = TrendSeasons,
  timeKnots = TrendTimeKnots,
  seasonalStructure = TrendSeasonalStructure,
  lambdas = c(1500, 0, 0)
)
WDSeason &lt;- list(
  name = "Dayly seas",
  data = SeasonData,
  times = Times,
  seasons = WDSeasons,
  timeKnots = SeasonTimeKnots,
  seasonalStructure = WDSeasonalStructure,
  lambdas = c(0.003, 0, 240)
)
StaticTempM &lt;- list(
  name = "Temp Mel",
  data = TempM,
  times = Times,
  seasons = NULL,
  timeKnots = NULL,
  seasonalStructure = NULL,
  lambdas = c(0, 0, 0)
)
StaticTempM2 &lt;- list(
  name = "Temp Mel^2",
  data = TempM2,
  times = Times,
  seasons = NULL,
  timeKnots = NULL,
  seasonalStructure = NULL,
  lambdas = c(0, 0, 0)
)
Predictors &lt;- list(Trend, WDSeason, StaticTempM, StaticTempM2)

elec.fit &lt;- STR(
  data = Data,
  predictors = Predictors,
  gapCV = 48 * 7
)

plot(elec.fit,
  xTime = as.Date("2000-01-11") + ((Times - 1) / 48 - 10),
  forecastPanels = NULL
)

#########################################################

n &lt;- 70
trendSeasonalStructure &lt;- list(segments = list(c(0, 1)), sKnots = list(c(1, 0)))
ns &lt;- 5
seasonalStructure &lt;- list(
  segments = list(c(0, ns)),
  sKnots = c(as.list(1:(ns - 1)), list(c(ns, 0)))
)
seasons &lt;- (0:(n - 1)) %% ns + 1
trendSeasons &lt;- rep(1, length(seasons))
times &lt;- seq_along(seasons)
data &lt;- seasons + times / 4
set.seed(1234567890)
data &lt;- data + rnorm(length(data), 0, 0.2)
data[20] &lt;- data[20] + 3
data[50] &lt;- data[50] - 5
plot(times, data, type = "l")
timeKnots &lt;- times
trendData &lt;- rep(1, n)
seasonData &lt;- rep(1, n)
trend &lt;- list(
  data = trendData, times = times, seasons = trendSeasons,
  timeKnots = timeKnots, seasonalStructure = trendSeasonalStructure, lambdas = c(1, 0, 0)
)
season &lt;- list(
  data = seasonData, times = times, seasons = seasons,
  timeKnots = timeKnots, seasonalStructure = seasonalStructure, lambdas = c(1, 0, 1)
)
predictors &lt;- list(trend, season)
rstr &lt;- STR(data, predictors,
  reltol = 0.0000001, gapCV = 10,
  confidence = 0.95, nMCIter = 400, robust = TRUE
)
plot(rstr)

</code></pre>

<hr>
<h2 id='strDesign'>Common argument</h2><span id='topic+strDesign'></span>

<h3>Description</h3>

<p>Common argument
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="strDesign_+3A_strdesign">strDesign</code></td>
<td>
<p>An optional parameter used to create the design
matrix. It is used internally in the library to improve performance when the design
matrix does not require full recalculation.</p>
</td></tr>
</table>

<hr>
<h2 id='STRmodel'>STR decomposition</h2><span id='topic+STRmodel'></span>

<h3>Description</h3>

<p>Seasonal-Trend decomposition of time series data using Regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>STRmodel(
  data,
  predictors = NULL,
  strDesign = NULL,
  lambdas = NULL,
  confidence = NULL,
  solver = c("Matrix", "cholesky"),
  reportDimensionsOnly = FALSE,
  trace = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="STRmodel_+3A_data">data</code></td>
<td>
<p>Time series or a vector of length <em><strong>L</strong></em>.</p>
</td></tr>
<tr><td><code id="STRmodel_+3A_predictors">predictors</code></td>
<td>
<p>List of predictors.<br />
According to the paradigm of this implementation, the trend, the seasonal components,
the flexible predictors and the seasonal predictors are all presented in the same
form (as predictors) and must be described in this list.<br />
Every predictor is a list of the following structures:<br />
</p>

<ul>
<li> <p><strong>data</strong> &ndash; vector of length <em><strong>L</strong></em> (length of input data,
see above). For trend or for a seasonal component it is a vector of ones.
For a flexible or a seasonal predictor it is a vector of the predictor's data.
</p>
</li>
<li> <p><strong>times</strong> &ndash; vector of length <em><strong>L</strong></em> of times of observations.
</p>
</li>
<li> <p><strong>seasons</strong> &ndash; vector of length <em><strong>L</strong></em>. It is a vector of ones
for a trend or a flexible predictor. It is vector assigning seasons to every
observation (for a seasonal component or a seasonal predictor).
Seasons can be fractional for observations in between seasons.
</p>
</li>
<li> <p><strong>timeKnots</strong> &ndash; vector of times (time knots) where knots are positioned
(for a seasonal component or a seasonal predictor a few knots have the same time;
every knot is represented by time and season). Usually this vector coincides with
<strong>times</strong> vector described above, or <strong>timeKnots</strong> is a subset of
<strong>times</strong> vector.
</p>
</li>
<li> <p><strong>seasonalStructure</strong> &ndash; describes seasonal topology (which can have complex
structure) and seasonal knots.The seasonal topology is described by a list of
segments and seasonal knots, which are positioned inside the segments, on borders of
the segments or, when they are on on borders, they can connect two or more segments.<br />
<strong>seasonalStructure</strong> is a list of two elements:<br />
</p>

<ul>
<li> <p><strong>segments</strong> &ndash; a list of vectors representing segments.
Each vector must contain two ordered real values which represent left and right borders
of a segment. Segments should not intersect (inside same predictor).
</p>
</li>
<li> <p><strong>sKnots</strong> &ndash; a list of real values (vectors of length one) or vectors of
lengths two or greater (seasonal knots) defining seasons of the knots (every knot
is represented by time and season). All real values must belong (be inside or on
border of) segments listed in <strong>segments</strong>. If a few values represent a single
seasonal knot then all these values must be on borders of some segments (or a single
segment). In this case they represent a seasonal knot which connects a few segments
(or both sides of one segment).
</p>
</li></ul>

</li>
<li> <p><strong>lambdas</strong> &ndash; a vector with three values representing lambda (smoothing)
parameters (time-time, season-season, time-season flexibility parameters) for this
predictor.
</p>
</li></ul>
</td></tr>
<tr><td><code id="STRmodel_+3A_strdesign">strDesign</code></td>
<td>
<p>An optional parameter used to create the design
matrix. It is used internally in the library to improve performance when the design
matrix does not require full recalculation.</p>
</td></tr>
<tr><td><code id="STRmodel_+3A_lambdas">lambdas</code></td>
<td>
<p>An optional parameter.
A structure which replaces lambda parameters provided with predictors.
It is used as either a starting point for the optimisation of parameters or as the
exact model parameters.</p>
</td></tr>
<tr><td><code id="STRmodel_+3A_confidence">confidence</code></td>
<td>
<p>A vector of percentiles giving the coverage of confidence intervals.
It must be greater than 0 and less than 1.
If <code>NULL</code>, no confidence intervals are produced.</p>
</td></tr>
<tr><td><code id="STRmodel_+3A_solver">solver</code></td>
<td>
<p>A vector with two string values. The only supported combinations are:
c(&quot;Matrix&quot;, &quot;cholesky&quot;) (default), and c(&quot;Matrix&quot;, &quot;qr&quot;).
The parameter is used to specify a particular library
and method to solve the minimisation problem during STR decompositon.</p>
</td></tr>
<tr><td><code id="STRmodel_+3A_reportdimensionsonly">reportDimensionsOnly</code></td>
<td>
<p>A boolean parameter. When TRUE the method constructs the
design matrix and reports its dimensions without proceeding further.
It is mostly used for debugging.</p>
</td></tr>
<tr><td><code id="STRmodel_+3A_trace">trace</code></td>
<td>
<p>When <code>TRUE</code>, tracing is turned on.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A structure containing input and output data.
It is an <strong>S3</strong> class <code>STR</code>, which is a list with the following components:
</p>

<ul>
<li> <p><strong>output</strong> &ndash; contains decomposed data. It is a list of three components:
</p>

<ul>
<li> <p><strong>predictors</strong> &ndash; a list of components where each component
corresponds to the input predictor. Every such component is a list containing the following:
</p>

<ul>
<li> <p><strong>data</strong> &ndash; fit/forecast for the corresponding predictor (trend, seasonal component, flexible or seasonal predictor).
</p>
</li>
<li> <p><strong>beta</strong> &ndash; beta coefficients of the fit of the coresponding predictor.
</p>
</li>
<li> <p><strong>lower</strong> &ndash; optional (if requested) matrix of lower bounds of confidence intervals.
</p>
</li>
<li> <p><strong>upper</strong> &ndash; optional (if requested) matrix of upper bounds of confidence intervals.
</p>
</li></ul>

</li>
<li> <p><strong>random</strong> &ndash; a list with one component <strong>data</strong>, which contains residuals of the model fit.
</p>
</li>
<li> <p><strong>forecast</strong> &ndash; a list with two components:
</p>

<ul>
<li> <p><strong>data</strong> &ndash; fit/forecast for the model.
</p>
</li>
<li> <p><strong>beta</strong> &ndash; beta coefficients of the fit.
</p>
</li>
<li> <p><strong>lower</strong> &ndash; optional (if requested) matrix of lower bounds of confidence intervals.
</p>
</li>
<li> <p><strong>upper</strong> &ndash; optional (if requested) matrix of upper bounds of confidence intervals.
</p>
</li></ul>

</li></ul>

</li>
<li> <p><strong>input</strong> &ndash; input parameters and lambdas used for final calculations.
</p>

<ul>
<li> <p><strong>data</strong> &ndash; input data.
</p>
</li>
<li> <p><strong>predictors</strong> - input predictors.
</p>
</li>
<li> <p><strong>lambdas</strong> &ndash; smoothing parameters used for final calculations (same as input lambdas for STR method).
</p>
</li></ul>

</li>
<li> <p><strong>cvMSE</strong> &ndash; optional cross validated (leave one out) Mean Squared Error.



</p>
</li>
<li> <p><strong>method</strong> &ndash; always contains string <code>"STRmodel"</code> for this function.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Alexander Dokumentov
</p>


<h3>References</h3>

<p>Dokumentov, A., and Hyndman, R.J. (2022)
STR: Seasonal-Trend decomposition using Regression,
<em>INFORMS Journal on Data Science</em>, 1(1), 50-62.
<a href="https://robjhyndman.com/publications/str/">https://robjhyndman.com/publications/str/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AutoSTR">AutoSTR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 50
trendSeasonalStructure &lt;- list(segments = list(c(0, 1)), sKnots = list(c(1, 0)))
ns &lt;- 5
seasonalStructure &lt;- list(
  segments = list(c(0, ns)),
  sKnots = c(as.list(1:(ns - 1)), list(c(ns, 0)))
)
seasons &lt;- (0:(n - 1)) %% ns + 1
trendSeasons &lt;- rep(1, length(seasons))
times &lt;- seq_along(seasons)
data &lt;- seasons + times / 4
plot(times, data, type = "l")
timeKnots &lt;- times
trendData &lt;- rep(1, n)
seasonData &lt;- rep(1, n)
trend &lt;- list(
  data = trendData, times = times, seasons = trendSeasons,
  timeKnots = timeKnots, seasonalStructure = trendSeasonalStructure, lambdas = c(1, 0, 0)
)
season &lt;- list(
  data = seasonData, times = times, seasons = seasons,
  timeKnots = timeKnots, seasonalStructure = seasonalStructure, lambdas = c(10, 0, 0)
)
predictors &lt;- list(trend, season)

str1 &lt;- STRmodel(data, predictors)
plot(str1)

data[c(3, 4, 7, 20, 24, 29, 35, 37, 45)] &lt;- NA
plot(times, data, type = "l")
str2 &lt;- STRmodel(data, predictors)
plot(str2)

</code></pre>

<hr>
<h2 id='trace'>Common argument</h2><span id='topic+trace'></span>

<h3>Description</h3>

<p>Common argument
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trace_+3A_trace">trace</code></td>
<td>
<p>When <code>TRUE</code>, tracing is turned on.</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
