<!DOCTYPE html><html lang="en"><head><title>Help for package sbim</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sbim}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#sbim-package'><p>sbim: Simulation-Based Inference using a Metamodel for Log-Likelihood Estimator</p></a></li>
<li><a href='#ci'><p>Confidence interval for scalar parameter constructed using simulated log likelihoods</p></a></li>
<li><a href='#ht'><p>Hypothesis tests based on simulation based log likelihood estimates</p></a></li>
<li><a href='#optDesign'><p>Find the next optimal design point for simulation-based inference</p></a></li>
<li><a href='#SCL'><p>The SCL distribution</p></a></li>
<li><a href='#simll'><p>Simulation Log Likelihood class</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Simulation-Based Inference using a Metamodel for Log-Likelihood
Estimator</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Parameter inference methods for models defined implicitly using a random simulator. Inference is carried out using simulation-based estimates of the log-likelihood of the data. The inference methods implemented in this package are explained in Park, J. (2025) &lt;<a href="https://doi.org/10.48550%2Farxiv.2311.09446">doi:10.48550/arxiv.2311.09446</a>&gt;. These methods are built on a simulation metamodel which assumes that the estimates of the log-likelihood are approximately normally distributed with the mean function that is locally quadratic around its maximum. Parameter estimation and uncertainty quantification can be carried out using the ht() function (for hypothesis testing) and the ci() function (for constructing a confidence interval for one-dimensional parameters).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>devtools, dplyr, ggplot2, knitr, magrittr, pomp, rmarkdown,
tidyr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-11 16:31:09 UTC; j139p002_a</td>
</tr>
<tr>
<td>Author:</td>
<td>Joonha Park <a href="https://orcid.org/0000-0002-4493-7730"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Joonha Park &lt;j.park@ku.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-13 12:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='sbim-package'>sbim: Simulation-Based Inference using a Metamodel for Log-Likelihood Estimator</h2><span id='topic+sbim'></span><span id='topic+sbim-package'></span>

<h3>Description</h3>

<p>Parameter inference methods for models defined implicitly using a random simulator. Inference is carried out using simulation-based estimates of the log-likelihood of the data. The inference methods implemented in this package are explained in Park, J. (2025) &quot;Scalable simulation-based inference for implicitly defined models using a metamodel for Monte Carlo log-likelihood estimator&quot; <a href="https://doi.org/10.48550/arxiv.2311.09446">doi:10.48550/arxiv.2311.09446</a>. These methods are built on a simulation metamodel which assumes that the estimates of the log-likelihood are approximately normally distributed with the mean function that is locally quadratic around its maximum. Parameter estimation and uncertainty quantification can be carried out using the &quot;ht&quot; function (for hypothesis testing) and the &quot;ci&quot; function (for constructing a confidence interval for one-dimensional parameters).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Joonha Park <a href="mailto:j.park@ku.edu">j.park@ku.edu</a> (<a href="https://orcid.org/0000-0002-4493-7730">ORCID</a>)
</p>


<h3>References</h3>

<p>Park, J. (2025) Scalable simulation-based inference for implicitly defined models using a metamodel for Monte Carlo log-likelihood estimator <a href="https://doi.org/10.48550/arxiv.2311.09446">doi:10.48550/arxiv.2311.09446</a>
</p>

<hr>
<h2 id='ci'>Confidence interval for scalar parameter constructed using simulated log likelihoods</h2><span id='topic+ci'></span><span id='topic+ci.simll'></span>

<h3>Description</h3>

<p><code>ci</code> constructs confidence intervals for a scalar (one-dimensional) parameter using simulated log likelihoods. See Park (2025) for more information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'simll'
ci(
  simll,
  level,
  ci = NULL,
  case = NULL,
  weights = NULL,
  autoAdjust = FALSE,
  K1_est_method = "batch",
  batch_size = NULL,
  max_lag = NULL,
  plot_acf = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ci_+3A_simll">simll</code></td>
<td>
<p>A class 'simll' object, containing simulated log likelihoods, the parameter values at which simulations are made, and the weights for those simulations for regression (optional). See help(simll).</p>
</td></tr>
<tr><td><code id="ci_+3A_level">level</code></td>
<td>
<p>A numeric vector of confidence levels.</p>
</td></tr>
<tr><td><code id="ci_+3A_ci">ci</code></td>
<td>
<p>A character string indicating the quantity for which a confidence interval is to be constructed. Either &quot;MESLE&quot; or &quot;parameter&quot;. See Details.</p>
</td></tr>
<tr><td><code id="ci_+3A_case">case</code></td>
<td>
<p>When <code>ci</code> is &quot;parameter&quot;, <code>case</code> is either &quot;iid&quot; or &quot;stationary&quot; (default). <code>case</code> = &quot;iid&quot; means that the observations are iid, and <code>case</code> = &quot;stationary&quot; means that the observations form a stationary sequence. The <code>case</code> argument affects how the variance of the slope of the mean function (=K_1 in Park (2025)) is estimated.</p>
</td></tr>
<tr><td><code id="ci_+3A_weights">weights</code></td>
<td>
<p>An optional argument. The un-normalized weights of the simulated log likelihoods for regression. A numeric vector of length equal to the 'params' attribute of the 'simll' object. See Details below.</p>
</td></tr>
<tr><td><code id="ci_+3A_autoadjust">autoAdjust</code></td>
<td>
<p>logical. If TRUE, simulation points at which the third order term is statistically significant in the cubic approximation to the simulated log-likelihooods have discounted weights for metamodel fitting. The weights of the points relatively far from the estimated MESLE are more heavily discounted. These weight discount factors are multiplied to the originally given weights for parameter estimation. If <code>autoAdjust</code> is FALSE, the weight discount step is skipped. Defaults to FALSE. See ?optDesign and Park (2025) for more details.</p>
</td></tr>
<tr><td><code id="ci_+3A_k1_est_method">K1_est_method</code></td>
<td>
<p>Either &quot;autocov&quot; or &quot;batch&quot;</p>
</td></tr>
<tr><td><code id="ci_+3A_batch_size">batch_size</code></td>
<td>
<p>Numeric</p>
</td></tr>
<tr><td><code id="ci_+3A_max_lag">max_lag</code></td>
<td>
<p>When <code>test</code> is &quot;parameter&quot; and <code>case</code> is &quot;stationary&quot;, the value of <code>max_lag</code> gives the truncation point for lagged autocovariance when estimating K1 as a sum of lagged autocovariances of estimates slopes. If not supplied, default is the maximum lag for which the lagged autocorrelation has absolute value greater than 4/sqrt(nobs), where the lagged autocorrelation is found up to lag <code>10*log10(nobs)</code>. Here <code>nobs</code> is the number of observations.</p>
</td></tr>
<tr><td><code id="ci_+3A_plot_acf">plot_acf</code></td>
<td>
<p>Logical.  When <code>test</code> is &quot;parameter&quot; and <code>case</code> is &quot;stationary&quot;, If <code>plot_acf</code> is TRUE, the autocorrelation plot of the estimated slopes of the quadratic fit to the simulated log likelihoods is shown.</p>
</td></tr>
<tr><td><code id="ci_+3A_...">...</code></td>
<td>
<p>Other optional arguments, not currently used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a generic function, taking a class 'simll' object as the first argument.
Confidence intervals are constructed under a normal, locally quadratic meta model where the simulated log likelihoods given in the 'simll' object are normally distributed.
</p>
<p>When 'level' has length greater than one, a confidence interval is constructed for each value in the vector.
</p>
<p>Quadratic regression for the simulated log likelihoods is carried out to construct confidence intervals, where the x-axis values are the 'params' values of the 'simll' object and the y-axis values are the corresponding simulated log likelihoods.
In the case where 'ci' = &quot;parameter&quot;, inference on the simulation based surrogate will be carried out under the local asymptotic normality for simulated log likelihoods (see Park (2025) for more information.)
The default value of 'ci' is &quot;parameter&quot;.
</p>
<p>If 'ci' = &quot;MESLE&quot;, confidence intervals are constructed for the maximum expected simulation likelihood estimate given the observed data.
</p>
<p>When quadratic regression is carried out, the weights for the simulation based likelihood estimates can be specified. The length of 'weights' should be equal to that of the 'params' attribute of the 'simll', which is equal to the number of rows in the simulated log likelihood matrix in the 'simll' object. It is important to note that the weights are not normalized (i.e., not sum to one). Multiplying all weights by the same constant changes the estimation outputs. If not supplied, the 'weights' attribute of the 'simll' object is used. If neither is supplied, 'weights' defaults to the vector of all ones.
</p>


<h3>Value</h3>

<p>A list consisting of the followings are returned.
</p>

<ul>
<li><p>regression_estimates: point estimates for the meta model parameters, a, b, c, and sigma^2.
</p>
</li>
<li><p>meta_model_MLE_for_*: point estimate for the quantity for which confidence intervals are constructed under a normal meta model
</p>
</li>
<li><p>confidence_interval: a data frame of the lower and upper bounds of the confidence intervals and the corresponding confidence levels. Note that in some unfortunate cases (especially if the quadratic coefficient of the estimated quadratic fit of the log likelihood estimates is close to zero or nonnegative), the confidence interval may be inverted, meaning that it is of the form (-infty, bound1) U (bound2, infty). This case can happen if the signal-to-noise ratio in simulated log likelihoods is too small. The inverted confidence interval will be indicated by the additional column &quot;inverted&quot; in the data frame taking values of 0 or 1.
</p>
</li>
<li><p>max_lag: if <code>test</code>=&quot;parameter&quot; and <code>case</code>=&quot;stationary&quot;, the maximum lag for computing the autocovariance in estimating K1 is shown.
</p>
</li>
<li><p>pval_cubic: The p-value of the test about whether the cubic term in the cubic polynomial regression is significant. If <code>pval_cubic</code> is small, the constructed confidence interval may be biased. When <code>autoAdjust</code> is TRUE, <code>pval_cubic</code> is computed with the adjusted weights.
</p>
</li>
<li><p>updated_weights: When <code>autoAdjust</code> is TRUE, the modified weights for the simulation points are returned.
</p>
</li></ul>



<h3>References</h3>

<p>Park, J. (2025). Scalable simulation based inference for implicitly defined models using a metamodel for Monte Carlo log-likelihood estimator <a href="https://doi.org/10.48550/arxiv.2311.09446">doi:10.48550/arxiv.2311.09446</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># State process: X_i ~ N(theta0, tau^2), Observation process: Y_i ~ N(X_i, 1)
theta0 &lt;- 0 # true parameter
n &lt;- 200 # number of observations
xhidden &lt;- rnorm(n, theta0, 30) # hidden x values
ydata &lt;- rnorm(n, xhidden, 1) # observed y values
theta_sim &lt;- runif(300, -10, 10) # simulation points
ll &lt;- sapply(theta_sim, function(t) { # simulation-based log-likelihood estimates (except constant)
x &lt;- rnorm(n, t, 30)
-(x-ydata)^2/2
})
plot(theta_sim, apply(ll, 2, sum)) # display the log-likelihood estimates
s &lt;- simll(ll, params=theta_sim) # create a `simll` object
ci(s, level=0.95, ci="parameter", case="iid")
</code></pre>

<hr>
<h2 id='ht'>Hypothesis tests based on simulation based log likelihood estimates</h2><span id='topic+ht'></span><span id='topic+ht.simll'></span>

<h3>Description</h3>

<p><code>ht</code> carries out hypothesis tests for models defined implicitly by a random simulator. It takes as input estimates of the log likelihood obtained via simulations of the model. Tests are carried out using a simulation meta model. See Park (2025) for more details on the method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'simll'
ht(
  simll,
  null.value,
  test = c("parameter", "MESLE", "moments"),
  case = NULL,
  type = NULL,
  weights = NULL,
  autoAdjust = FALSE,
  K1_est_method = "batch",
  batch_size = NULL,
  max_lag = NULL,
  plot_acf = FALSE,
  MCcorrection = "none",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ht_+3A_simll">simll</code></td>
<td>
<p>A class <code>simll</code> object, containing simulated log likelihoods, the parameter values at which simulations are made (may be omitted if all simulations are made at the same parameter value), and the weights for those simulations for regression (optional). See help(simll).</p>
</td></tr>
<tr><td><code id="ht_+3A_null.value">null.value</code></td>
<td>
<p>The null value(s) for the hypothesis test. The expected format depends on which teset will be carried out. See the Details section for more information.</p>
</td></tr>
<tr><td><code id="ht_+3A_test">test</code></td>
<td>
<p>A character string indicating which is to be tested about. One of &quot;moments&quot;, &quot;MESLE&quot;, or &quot;parameter&quot;. See Details.</p>
</td></tr>
<tr><td><code id="ht_+3A_case">case</code></td>
<td>
<p>When <code>test</code> is &quot;parameter&quot;, <code>case</code> needs to be either &quot;iid&quot; or &quot;stationary&quot;. <code>case</code> = &quot;iid&quot; means that the observations are iid, and <code>case</code> = &quot;stationary&quot; means that the observations form a stationary sequence. The <code>case</code> argument affects how the variance of the slope of the mean function (=K_1 in Park (2025)) is estimated. The default value is &quot;stationary&quot;.</p>
</td></tr>
<tr><td><code id="ht_+3A_type">type</code></td>
<td>
<p>When <code>test</code> is &quot;moments&quot;, the <code>type</code> argument needs to be specified. <code>type</code> = &quot;point&quot; means that the test about the mean and the variance of simulated log likelihoods at a given parameter point is considered. <code>type</code> = &quot;regression&quot; means that the test about the mean function and the variance of simulated log likelihoods at various parameter values is considered. See Details.</p>
</td></tr>
<tr><td><code id="ht_+3A_weights">weights</code></td>
<td>
<p>An optional argument. The un-normalized weights of the simulated log likelihoods for regression. A numeric vector of length equal to the <code>params</code> attribute of the <code>simll</code> object. See Details below.</p>
</td></tr>
<tr><td><code id="ht_+3A_autoadjust">autoAdjust</code></td>
<td>
<p>logical. If TRUE, simulation points at which the third order term is statistically significant in the cubic approximation to the simulated log-likelihooods have discounted weights for metamodel fitting. The weights of the points relatively far from the estimated MESLE are more heavily discounted. These weight discount factors are multiplied to the originally given weights for parameter estimation. If <code>autoAdjust</code> is FALSE, the weight discount step is skipped. Defaults to FALSE. See ?optDesign and Park (2025) for more details.</p>
</td></tr>
<tr><td><code id="ht_+3A_k1_est_method">K1_est_method</code></td>
<td>
<p>Either &quot;batch&quot; or &quot;autocov&quot;. Used when <code>test</code> is &quot;parameter&quot; and <code>case</code> is &quot;stationary&quot;. The default is &quot;batch&quot;. See Details for more information.</p>
</td></tr>
<tr><td><code id="ht_+3A_batch_size">batch_size</code></td>
<td>
<p>Numeric. The size of the batch when <code>K1_est_method</code> is &quot;batch&quot;. If not supplied, the default value is <code>round(n^0.4)</code> where <code>n</code> is the number of observations in the data.</p>
</td></tr>
<tr><td><code id="ht_+3A_max_lag">max_lag</code></td>
<td>
<p>When <code>test</code> is &quot;parameter&quot; and <code>case</code> is &quot;stationary&quot;, the value of <code>max_lag</code> gives the truncation point for lagged autocovariance when estimating K1 as a sum of lagged autocovariances of estimates slopes. If not supplied, default is the maximum lag for which at least one of the entries of the matrix of lagged autocorrelation has absolute value greater than 4/sqrt(nobs), where the lagged autocorrelation is found up to lag <code>10*log10(nobs/d)</code>. Here <code>nobs</code> is the number of observations and <code>d</code> is the dimension of the parameter space.</p>
</td></tr>
<tr><td><code id="ht_+3A_plot_acf">plot_acf</code></td>
<td>
<p>Logical. Should the autocorrelation plot be generated when estimating K1 for the case where <code>test</code> is &quot;parameter&quot; and <code>case</code> is &quot;stationary&quot;?</p>
</td></tr>
<tr><td><code id="ht_+3A_mccorrection">MCcorrection</code></td>
<td>
<p>For tests on the simulation based parameter surrogate (<code>test</code>=&quot;parameter&quot;), <code>MCcorrection</code> determines if and how the sampling distribution of the test statistic will be corrected by a Monte Carlo method to account for the variability in the estimate of K1. Possible values are &quot;none&quot; (default) and &quot;Wishart&quot;. See the Details section and Park (2025) for more details.</p>
</td></tr>
<tr><td><code id="ht_+3A_...">...</code></td>
<td>
<p>Other optional arguments, not currently used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a generic function, taking a class <code>simll</code> object as the first argument.
Hypothesis tests are carried out under a normal metamodel&ndash;that is, the simulated log likelihoods (whose values are given in the <code>simll</code> object) are normally distributed.
</p>
<p>If <code>test</code> = &quot;moments&quot;, the <code>type</code> argument needs to be either &quot;point&quot; or &quot;regression&quot;.
If <code>type</code> = &quot;point&quot;, a test about the mean and the variance of the simulated log likelihood at a single parameter value is conducted.
If <code>type</code> = &quot;regression&quot;, the <code>simll</code> object should contain simulated log likelihoods obtained at more than one parameter values, specified by the <code>params</code> attribute of the <code>simll</code> object. A (weighted) quadratic regression for the simulated log likelihoods will be used for hypothesis tests, where the x-axis values are given by the <code>params</code> values of the <code>simll</code> object and the y-axis values are the corresponding simulated log likelihoods.
The test is about the quadruple <code class="reqn">a, b, c, sigma^2</code> where <code class="reqn">a, b, c</code> are coefficients of the polynomial describing the mean of the simulated log likelihood (i.e., <code class="reqn">l(\theta) = a + b \theta + c \theta^2</code>) and <code class="reqn">\sigma^2</code> is the variance of the simulated log likelihood.
If <code>test</code> = &quot;moments&quot; and <code>type</code> is not specified, <code>type</code> defaults to &quot;point&quot; if the <code>params</code> attribute of the <code>simll</code> object is not supplied or has length one, and defaults to &quot;regression&quot; otherwise.
</p>
<p>When <code>test</code> = &quot;MESLE&quot; or &quot;parameter&quot;, the <code>simll</code> object should have the <code>params</code> attribute.
</p>
<p>If <code>test</code> = &quot;MESLE&quot;, the test is about the location of the maximum expected simulated log likelihood estimate.
</p>
<p>If <code>test</code> = &quot;parameter&quot;, inference on the simulation based surrogate will be carried out under the local asymptotic normality for simulated log likelihood (see Park (2025) for more information.)
</p>
<p>The default value for <code>test</code> is &quot;parameter&quot;.
</p>
<p>When quadratic regression is carried out, the weights for the simulation based likelihood estimates can be specified. The length of <code>weights</code> should be equal to that of the <code>params</code> attribute of the <code>simll</code>, which is equal to the number of rows in the simulated log likelihood matrix in the <code>simll</code> object. It is important to note that the weights are not supposed to be normalized (i.e., sum to one). Multiplying all weights by the same constant changes the estimation outputs. If not supplied, the <code>weights</code> attribute of the <code>simll</code> object is used. If neither is supplied, <code>weights</code> defaults to the vector of all ones.
</p>
<p>When <code>test</code> is &quot;moments&quot; and <code>type</code> is &quot;point&quot;, <code>null.value</code> is either a vector of length two (one entry for the mean and the other for the variance of the simulated log likelihoods), a matrix of two columns (one for the mean and the other for the variance), or a list of vectors of length two (each entry of the list gives a null value consisting of the mean and the variance.)
When <code>test</code> is &quot;moments&quot; and <code>type</code> is &quot;regression&quot;, <code>null.value</code> can be a list of length four, or a list of lists of length four. The first case corresponds to when a single null hypothesis is tested. The four components are a) the constant term in the quadratic mean function (scalar), b) the linear coefficient term in the mean function (vector of length <code class="reqn">d</code> where <code class="reqn">d</code> is the dimension of the parameter vector), c) the quadratic coefficient term in the mean function (symmetric matrix of dimension <code class="reqn">d \times d</code>), and d) the variance of the simulated log likelihood (scalar). The second case is when more than one null values are tested. In this case each component of the list is a list having four entries as described for the case of a single null value.
When <code>test</code> is &quot;MESLE&quot; or &quot;parameter&quot;, <code>null.value</code> is a vector of length <code class="reqn">d</code> (a single null value), a matrix having <code class="reqn">d</code> columns (each row giving a vector for a null value), or a list of vectors of length <code class="reqn">d</code> (more than one null values).
</p>


<h3>Value</h3>

<p>A list consisting of the following components are returned.
</p>

<ul>
<li><p>regression_estimates: point estimates for the meta model parameters, a, b, c, and sigma^2. Given only when test=&quot;MESLE&quot; or &quot;parameter&quot;.
</p>
</li>
<li><p>meta_model_MLE_for_*: point estimate for the tested quantity under a normal meta model
</p>
</li>
<li><p>Hypothesis_Tests: a data frame of the null values and the corresponding p-values. When <code>test</code>=&quot;moments&quot; and <code>type</code>=&quot;regression&quot;, each null value is given in the form of c(a,b,c,sigma^2) where a, b, c, sigma^2 are first, second, third, and fourth entries of the given null value.
</p>
</li>
<li><p>pvalue_numerical_error_size: When <code>test</code>=&quot;moments&quot;, approximate size of error in numerical evaluation of p-values (automatically set to approximately 0.01 or 0.001). For these case, p-values are found using the SCL distributions, whose cumulative distribution functions are numerically evaluated using random number generations. Thus p-values have some stochastic error. The size of the numerical error is automatically set to approximately 0.01, but if any of the p-values found is less than 0.01, more computations are carried out to reduce the numerical error size to approximately 0.001. Note that when <code>test</code>=&quot;MESLE&quot; or &quot;parameter&quot;, the (standard) F distribution is used, so this list component is omitted.
</p>
</li>
<li><p>max_lag: if <code>test</code>=&quot;parameter&quot; and <code>case</code>=&quot;stationary&quot;, the maximum lag for computing the autocovariance in estimating K1 is shown.
</p>
</li>
<li><p>pval_cubic: The p-value of the test about whether the cubic term in the cubic polynomial regression is significant. If <code>pval_cubic</code> is small, the result of the <code>ht</code> function may be biased. The test on the cubic term is carried out only when the number of simulated log likelihoods is greater than <code class="reqn">(d+1)*(d+2)*(d+3)/6</code> where <code class="reqn">d</code> is the dimension of the parameter vector. When <code>autoAdjust</code> is TRUE, <code>pval_cubic</code> is computed with the adjusted weights.
</p>
</li>
<li><p>updated_weights: When <code>autoAdjust</code> is TRUE, the modified weights for the simulation points are returned.
</p>
</li></ul>



<h3>References</h3>

<p>Park, J. (2025). Scalable simulation-based inference for implicitly defined models using a metamodel for Monte Carlo log-likelihood estimator <a href="https://doi.org/10.48550/arxiv.2311.09446">doi:10.48550/arxiv.2311.09446</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># State process: X_i ~ N(theta0, tau^2), Observation process: Y_i ~ N(X_i, 1)
theta0 &lt;- 0 # true parameter
n &lt;- 200 # number of observations
xhidden &lt;- rnorm(n, theta0, 30) # hidden x values
ydata &lt;- rnorm(n, xhidden, 1) # observed y values
theta_sim &lt;- runif(300, -10, 10) # simulation points
ll &lt;- sapply(theta_sim, function(t) { # simulation-based log-likelihood estimates (except constant)
x &lt;- rnorm(n, t, 30)
-(x-ydata)^2/2
})
plot(theta_sim, apply(ll, 2, sum)) # display the log-likelihood estimates
s &lt;- simll(ll, params=theta_sim) # create a `simll` object
ht(s, null.value=list(-1,0,1), test="parameter", case="iid")
</code></pre>

<hr>
<h2 id='optDesign'>Find the next optimal design point for simulation-based inference</h2><span id='topic+optDesign'></span><span id='topic+optDesign.simll'></span>

<h3>Description</h3>

<p><code>optDesign</code> finds the next design point at which simulation should be carried out for approximately best efficiency in a metamodel-based inference. See Park (2025) for more details on this method. It takes a class <code>simll</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'simll'
optDesign(
  simll,
  init = NULL,
  weight = 1,
  autoAdjust = TRUE,
  refgap = Inf,
  refgap_for_comp = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="optDesign_+3A_simll">simll</code></td>
<td>
<p>A class <code>simll</code> object, containing simulation log likelihoods, the parameter values at which simulations are made, and the weights for those simulations for regression (optional). See help(simll).</p>
</td></tr>
<tr><td><code id="optDesign_+3A_init">init</code></td>
<td>
<p>(optional) An initial parameter vector at which a search for optimal point starts.</p>
</td></tr>
<tr><td><code id="optDesign_+3A_weight">weight</code></td>
<td>
<p>(optional) A positive real number indicating the user-assigned weight for the new design point. The default value is 1. This value should be chosen relative to the weights in the provided simll object.</p>
</td></tr>
<tr><td><code id="optDesign_+3A_autoadjust">autoAdjust</code></td>
<td>
<p>logical. If TRUE, simulation points at which the third order term is statistically significant in the cubic approximation to the simulated log-likelihooods have discounted weights for metamodel fitting. The weights of the points relatively far from the estimated MESLE are more heavily discounted. These weight discount factors are multiplied to the originally given weights for parameter estimation. See Park (2025) for more details. If <code>autoAdjust</code> is FALSE, the weight discount step is skipped. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="optDesign_+3A_refgap">refgap</code></td>
<td>
<p>A positive real number that determines the weight discount factor for the significance of the third order term in Taylor approximation. The weight of a point <code>theta</code> is discounted by a factor of exp(-(qa(theta)-qa(MESLEhat))/refgap), where MESLEhat is the estimated MESLE and qa is the quadratic approximation to the simulated log-likelihoods. If <code>autoAdjust</code> is TRUE, <code>refgap</code> is interpreted as the initial value for the tuning algorithm. If <code>autoAdjust</code> is FALSE, <code>refgap</code> is used for weight adjustments without further tuning. The default value is Inf.</p>
</td></tr>
<tr><td><code id="optDesign_+3A_refgap_for_comp">refgap_for_comp</code></td>
<td>
<p>(optional) A value of refgap with which to compute the log(STV) to be reported at the end. A potential use for this argument is to compare log(STV) values across iterative applications of this function, as the reported logSTV value can vary significantly depending on the tuned value of refgap.</p>
</td></tr>
<tr><td><code id="optDesign_+3A_...">...</code></td>
<td>
<p>Other optional arguments, not currently used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a generic function, taking a class <code>simll</code> object as the first argument.
Parameter inference for implicitly defined simulation models can be carried out under a metamodel for the distribution of the log-likelihood estimator.
See function <code>ht</code> for hypothesis testing and <code>ci</code> for confidence interval construction for a one-dimensional parameter.
This function, <code>optDesign</code>, proposes the next point at which a simulation is to be carried out such that the variance of the parameter estimate is reduced approximately the most.
In order to balance efficiency and accuracy, the point is selected as far as possible from the current estimate of the parameter while ensuring that the quadratic approximation to the simulated log-likelihoods remain valid.
Specifically, the weights for the existing simulation points are adjusted such that the third order term in a cubic approximation is statistically insignificant.
The weight discount factor for point <code>theta</code> is given by exp(-(qa(theta)-qa(MESLEhat))/g), where qa is the quadratic approximation, MESLEhat is the estimated MLE, and g is a scaling parameter.
These discount factors are multipled to the original <code>weights</code> given to the simulation points specified in the <code>simll</code> object.
Moreover, in order to ensure that the cubic regression can be carried out without numerical issues, g is guaranteed not to fall below a value that makes the effective sample size (ESS) below (d+1)<em>(d+2)</em>(d+3)/6, which is the total number of parameter estimated in cubic regression, where d is the parameter dimension. Here ESS is calculated as (sum of adjusted weights)^2/(sum of squared adjusted weights).
</p>
<p>The next simulation point is selected by approximately minimizing the scaled total Monte Carlo variation of the parameter estimate.
The scaled total variation (STV) is defined as the trace of <code style="white-space: pre;">&#8288;c_hat^{-1} V&#8288;</code> where <code>c_hat</code> is the quadratic coefficient matrix of the fitted quadratic polynomial and <code>V</code> is an approximate Monte Carlo variance of the estimate of the MESLE given by <code style="white-space: pre;">&#8288;-(1/2) * c_hat^{-1} b_hat&#8288;</code> (here <code>b_hat</code> is the linear coefficient vector of the fitted quadratic polynomial.)
The optimization is carried out using the BFGS algorithm via the <code>optim</code> function.
See Park (2025) for more details.
</p>


<h3>Value</h3>

<p>A list containing the following entries.
</p>

<ul>
<li><p>par: a proposal for the next simulation point.
</p>
</li>
<li><p>logSTV: the logarithm of the approximate scaled total variation (STV) evaluated at the proposed simulation point.
</p>
</li>
<li><p>wadj_new: the adjusted weight for the newly proposed simulation point.
</p>
</li>
<li><p>Wadj: the vector of all adjusted weights for the existing simulation points.
</p>
</li>
<li><p>refgap: the tuned value of g for weight adjustments.
</p>
</li>
<li><p>logSTV_for_comp: when <code>refgap_for_comp</code> is not NULL, log(STV) is evaluated using the provided value of <code>refgap_for_comp</code> and reported as <code>logSTV_for_comp</code>.
</p>
</li></ul>



<h3>References</h3>

<p>Park, J. (2025). Scalable simulation-based inference for implicitly defined models using a metamodel for Monte Carlo log-likelihood estimator <a href="https://doi.org/10.48550/arxiv.2311.09446">doi:10.48550/arxiv.2311.09446</a>
</p>

<hr>
<h2 id='SCL'>The SCL distribution</h2><span id='topic+SCL'></span><span id='topic+qscl'></span><span id='topic+pscl'></span><span id='topic+rscl'></span>

<h3>Description</h3>

<p>Quantile function, distribution function, and random generation for the SCL distribution family. See Park (2025) for information about the SCL distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qscl(
  p,
  M,
  k,
  num_error_size = 0.01,
  lower = TRUE,
  log_p = FALSE,
  force = FALSE
)

pscl(
  q,
  M,
  k,
  num_error_size = 0.01,
  lower = TRUE,
  log_p = FALSE,
  force = FALSE
)

rscl(n, M, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SCL_+3A_p">p</code></td>
<td>
<p>vector of probabilities</p>
</td></tr>
<tr><td><code id="SCL_+3A_m">M</code></td>
<td>
<p>the first parameter for the SCL distributions</p>
</td></tr>
<tr><td><code id="SCL_+3A_k">k</code></td>
<td>
<p>the second parameter for the SCL distribution</p>
</td></tr>
<tr><td><code id="SCL_+3A_num_error_size">num_error_size</code></td>
<td>
<p>The requested size of numerical error for the outputs of qscl and pscl functions, in terms of the estimated standard deviation of the output. For example num_error_size of 0.01 will output values with the standard deviation of approximately equal to 0.01.</p>
</td></tr>
<tr><td><code id="SCL_+3A_lower">lower</code></td>
<td>
<p>logical; if TRUE, probabilities are P(X &lt;= x), otherwise, P(X &gt; x).</p>
</td></tr>
<tr><td><code id="SCL_+3A_log_p">log_p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="SCL_+3A_force">force</code></td>
<td>
<p>logical; if TRUE, the function will run regardless of how long it will take. If FALSE, the function will ask if you want to continue, stop, or give a new num_error_size value whenever the expected run time is longer than 15 seconds.</p>
</td></tr>
<tr><td><code id="SCL_+3A_q">q</code></td>
<td>
<p>vector of quantiles</p>
</td></tr>
<tr><td><code id="SCL_+3A_n">n</code></td>
<td>
<p>number of draws</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list consisting of the numeric vector of quantiles and the num_error_size (numeric) used.
</p>

<hr>
<h2 id='simll'>Simulation Log Likelihood class</h2><span id='topic+simll'></span>

<h3>Description</h3>

<p>Simulation Log Likelihood class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simll(ll, params = NULL, weights = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simll_+3A_ll">ll</code></td>
<td>
<p>A matrix of simulation log likelihoods. The (i,m)-th entry is given by the simulation log likelihood for y_i obtained by simulating X at theta_m (e.g., the log density of y_i given X).</p>
</td></tr>
<tr><td><code id="simll_+3A_params">params</code></td>
<td>
<p>A matrix or a vector of parameter values. If a matrix, the m-th row gives the parameter vector theta_m. If theta is one dimensional, 'params' is can be a numeric vector or a matrix with one column. 'params' can be omitted if simulation log likelihoods are obtained at a single one parameter value.</p>
</td></tr>
<tr><td><code id="simll_+3A_weights">weights</code></td>
<td>
<p>A numeric vector of weights, inversely proportional to the variance of simulation log likelihoods (optional)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A class 'sll' object
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
