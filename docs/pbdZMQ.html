<!DOCTYPE html><html lang="en"><head><title>Help for package pbdZMQ</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pbdZMQ}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#pbdZMQ-package'><p>Programming with Big Data &ndash; Interface to ZeroMQ</p></a></li>
<li><a href='#address'><p>Form an Address/Endpoint</p></a></li>
<li><a href='#C-like+20Wrapper+20Functions+20for+20ZeroMQ'><p>The C-like ZeroMQ Interface</p></a></li>
<li><a href='#Context+20Functions'><p>Context Functions</p></a></li>
<li><a href='#File+20Transfer+20Functions'><p>File Transfer Functions</p></a></li>
<li><a href='#Initial+20Control+20Functions'><p>Initial controls in pbdZMQ</p></a></li>
<li><a href='#ls'><p>A wrapper function for base::ls</p></a></li>
<li><a href='#Message+20Function'><p>Message Functions</p></a></li>
<li><a href='#Overwrite+20shpkg'><p>Overwrite rpath of linked shared library in osx</p></a></li>
<li><a href='#Poll+20Functions'><p>Poll Functions</p></a></li>
<li><a href='#random_port'><p>Random Port</p></a></li>
<li><a href='#Send+20Receive+20Functions'><p>Send Receive Functions</p></a></li>
<li><a href='#Send+20Receive+20Multiple+20Raw+20Buffers'><p>Send Receive Multiple Raw Buffers</p></a></li>
<li><a href='#Set+20Control+20Functions'><p>Set controls in pbdZMQ</p></a></li>
<li><a href='#shellexec.wcc'><p>Shell Execution via cmd windows</p></a></li>
<li><a href='#Socket+20Functions'><p>Socket Functions</p></a></li>
<li><a href='#Transfer+20Functions+20for+20Files+20or+20Directories'><p>Transfer Functions for Files or Directories</p></a></li>
<li><a href='#Utility+20Functions'><p>Utility Functions</p></a></li>
<li><a href='#Wrapper+20Functions+20for+20rzmq'><p>All Wrapper Functions for rzmq</p></a></li>
<li><a href='#ZMQ+20Control+20Environment'><p>Sets of controls in pbdZMQ.</p></a></li>
<li><a href='#ZMQ+20Control+20Functions'><p>Sets of controls in pbdZMQ.</p></a></li>
<li><a href='#ZMQ+20Flags'><p>ZMQ Flags</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.3-13</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-09-15</td>
</tr>
<tr>
<td>Title:</td>
<td>Programming with Big Data &ndash; Interface to 'ZeroMQ'</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Copyright:</td>
<td>See files AUTHORS, COPYING, and COPYING.LESSER in
'inst/zmq_copyright/' for the 'ZeroMQ' source files in
'src/zmq_src/' which are under GPL-3.</td>
</tr>
<tr>
<td>Description:</td>
<td>'ZeroMQ' is a well-known library for high-performance
    asynchronous messaging in scalable, distributed applications.  This
    package provides high level R wrapper functions to easily utilize
    'ZeroMQ'. We mainly focus on interactive client/server programming
    frameworks. For convenience, a minimal 'ZeroMQ' library (4.2.2)
    is shipped with 'pbdZMQ', which can be used if no system installation
    of 'ZeroMQ' is available.  A few wrapper functions compatible with
    'rzmq' are also provided.</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>Linux, Mac OSX, and Windows, or 'ZeroMQ' library &gt;=
4.0.4. Solaris 10 needs 'ZeroMQ' library 4.0.7 and 'OpenCSW'.</td>
</tr>
<tr>
<td>StagedInstall:</td>
<td>TRUE</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://pbdr.org/">https://pbdr.org/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/snoweye/pbdZMQ/issues">https://github.com/snoweye/pbdZMQ/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Wei-Chen Chen &lt;wccsnow@gmail.com&gt;</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-15 19:14:05 UTC; snoweye</td>
</tr>
<tr>
<td>Author:</td>
<td>Wei-Chen Chen [aut, cre],
  Drew Schmidt [aut],
  Christian Heckendorf [aut] (file transfer),
  George Ostrouchov [aut] (Mac OSX),
  Whit Armstrong [ctb] (some functions are modified from the rzmq package
    for backwards compatibility),
  Brian Ripley [ctb] (C code of shellexec, and Solaris),
  R Core team [ctb] (some functions and headers are copied or modified
    from the R source code),
  Philipp A. [ctb] (Fedora),
  Elliott Sales de Andrade [ctb] (sprintf),
  Spencer Aiello [ctb] (windows conf),
  Paul Andrey [ctb] (Mac OSX conf),
  Panagiotis Cheilaris [ctb] (add serialize version),
  Jeroen Ooms [ctb] (clang++ on MacOS ARM64),
  ZeroMQ authors [aut, cph] (source files in 'src/zmq_src/')</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-17 08:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='pbdZMQ-package'>Programming with Big Data &ndash; Interface to ZeroMQ</h2><span id='topic+pbdZMQ-package'></span><span id='topic+pbdZMQ'></span>

<h3>Description</h3>

<p>ZeroMQ is a well-known library for high-performance
asynchronous messaging in scalable, distributed applications.  This
package provides high level R wrapper functions to easily utilize
ZeroMQ. We mainly focus on interactive client/server programming 
frameworks. For convenience, a minimal ZeroMQ library (4.1.0 rc1)
is shipped with pbdZMQ, which can be used if no system installation
of ZeroMQ is available.  A few wrapper functions compatible with
rzmq are also provided.
</p>


<h3>Details</h3>

<p>The install command using default <span class="pkg">pbdZMQ</span>'s internal ZeroMQ library is
<br /> <br /> 
<code>&gt; R CMD INSTALL pbdZMQ_0.1-0.tar.gz</code> <br /> 
<code>--configure-args="--enable-internal-zmq"</code> 
<br /> <br /> 
Other available variables include 
</p>

<table>
<tr>
 <td style="text-align: left;">
  Variable </td><td style="text-align: left;"> Default </td>
</tr>
<tr>
 <td style="text-align: left;"> 
  <code>ZMQ_INCLUDE</code> </td><td style="text-align: left;"> <code>-I./zmqsrc/include</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> 
  <code>ZMQ_LDFLAGS</code> </td><td style="text-align: left;"> <code>-L./ -lzmq</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>ZMQ_POLLER</code> </td><td style="text-align: left;"> <code>select</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>
 
<p>See the package source file <code>pbdZMQ/configure.ac</code> for details.
</p>
<p>For installation using an external ZeroMQ library, see the package source
file <code>pbdZMQ/INSTALL</code> for details.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>.
</p>


<h3>References</h3>

<p>ZeroMQ/4.1.0 API Reference:
<a href="https://libzmq.readthedocs.io/en/zeromq4-1/">https://libzmq.readthedocs.io/en/zeromq4-1/</a>
</p>
<p>Programming with Big Data in R Website: <a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zmq.ctx.new">zmq.ctx.new</a>()</code>, <code><a href="#topic+zmq.socket">zmq.socket</a>()</code>.
</p>

<hr>
<h2 id='address'>Form an Address/Endpoint</h2><span id='topic+address'></span>

<h3>Description</h3>

<p>A notationally convenient function for forming addresses/endpoints.
It's a simple wrapper around the <code>paste0()</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>address(host, port, transport = "tcp")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="address_+3A_host">host</code></td>
<td>
<p>The host ip address or url.</p>
</td></tr>
<tr><td><code id="address_+3A_port">port</code></td>
<td>
<p>A port; necessary for all transports except ipc.</p>
</td></tr>
<tr><td><code id="address_+3A_transport">transport</code></td>
<td>
<p>The transport protocol.  Choices are &quot;inproc&quot;, &quot;ipc&quot;, &quot;tcp&quot;, and
&quot;pgm&quot;/&quot;epgm&quot; for local in-process (inter-thread), local 
inter-process, tcp, and pgm, respectively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An address, for use with pbdZMQ functions.
</p>


<h3>Author(s)</h3>

<p>Drew Schmidt
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zmq.bind">zmq.bind</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>address("localhost", 55555)

</code></pre>

<hr>
<h2 id='C-like+20Wrapper+20Functions+20for+20ZeroMQ'>The C-like ZeroMQ Interface</h2><span id='topic+C-like+20Wrapper+20Functions+20for+20ZeroMQ'></span>

<h3>Description</h3>

<p>The basic interface to ZeroMQ that somewhat models the C interface.
</p>


<h3>Details</h3>

<p>A list of all functions for this interface is as follows:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>zmq.bind()</code> </td><td style="text-align: left;"> <code>zmq.close()</code> </td><td style="text-align: left;"> <code>zmqconnect()</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>zmq.ctx.destroy()</code> </td><td style="text-align: left;"> <code>zmq.ctx.new()</code> </td><td style="text-align: left;"> <code>zmq.msg.recv()</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>zmq.msg.send()</code> </td><td style="text-align: left;"> <code>zmq.recv()</code> </td><td style="text-align: left;"> <code>zmq.send()</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>zmq.socket()</code> </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>.
</p>


<h3>References</h3>

<p>ZeroMQ/4.1.0 API Reference:
<a href="https://libzmq.readthedocs.io/en/zeromq4-1/">https://libzmq.readthedocs.io/en/zeromq4-1/</a>
</p>
<p>Programming with Big Data in R Website: <a href="https://pbdr.org/">https://pbdr.org/</a>
</p>

<hr>
<h2 id='Context+20Functions'>Context Functions</h2><span id='topic+Context+20Functions'></span><span id='topic+zmq.ctx.new'></span><span id='topic+zmq.ctx.destroy'></span>

<h3>Description</h3>

<p>Context functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zmq.ctx.new()

zmq.ctx.destroy(ctx)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Context+2B20Functions_+3A_ctx">ctx</code></td>
<td>
<p>a ZMQ context</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>zmq.ctx.new()</code> initializes a ZMQ context for starting communication.
</p>
<p><code>zmq.ctx.destroy()</code> terminates the context for stopping communication.
</p>


<h3>Value</h3>

<p><code>zmq.ctx.new()</code> returns an R external pointer (<code>ctx</code>)
generated by ZMQ C API pointing to a context if successful, otherwise
returns an R <code>NULL</code>.
</p>
<p><code>zmq.ctx.destroy()</code> returns 0 if successful, otherwise returns -1 and
sets <code>errno</code> to either <code>EFAULT</code> or <code>EINTR</code>.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>.
</p>


<h3>References</h3>

<p>ZeroMQ/4.1.0 API Reference:
<a href="https://libzmq.readthedocs.io/en/zeromq4-1/">https://libzmq.readthedocs.io/en/zeromq4-1/</a>
</p>
<p>Programming with Big Data in R Website: <a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zmq.socket">zmq.socket</a>()</code>, <code><a href="#topic+zmq.close">zmq.close</a>()</code>,
<code><a href="#topic+zmq.bind">zmq.bind</a>()</code>, <code><a href="#topic+zmq.connect">zmq.connect</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(pbdZMQ, quietly = TRUE)

context &lt;- zmq.ctx.new()
zmq.ctx.destroy(context)

## End(Not run)

</code></pre>

<hr>
<h2 id='File+20Transfer+20Functions'>File Transfer Functions</h2><span id='topic+File+20Transfer+20Functions'></span><span id='topic+zmq.sendfile'></span><span id='topic+zmq.recvfile'></span>

<h3>Description</h3>

<p>High level functions calling <code>zmq_send()</code> and <code>zmq_recv()</code>
to transfer a file in 200 KiB chunks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zmq.sendfile(
  port,
  filename,
  verbose = FALSE,
  flags = ZMQ.SR()$BLOCK,
  forcebin = FALSE,
  ctx = NULL,
  socket = NULL
)

zmq.recvfile(
  port,
  endpoint,
  filename,
  verbose = FALSE,
  flags = ZMQ.SR()$BLOCK,
  forcebin = FALSE,
  ctx = NULL,
  socket = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="File+2B20Transfer+2B20Functions_+3A_port">port</code></td>
<td>
<p>A valid tcp port.</p>
</td></tr>
<tr><td><code id="File+2B20Transfer+2B20Functions_+3A_filename">filename</code></td>
<td>
<p>The name (as a string) of the in/out files. The in and out file names
can be different.</p>
</td></tr>
<tr><td><code id="File+2B20Transfer+2B20Functions_+3A_verbose">verbose</code></td>
<td>
<p>Logical; determines if a progress bar should be shown.</p>
</td></tr>
<tr><td><code id="File+2B20Transfer+2B20Functions_+3A_flags">flags</code></td>
<td>
<p>A flag for the method used by <code>zmq_sendfile</code> and
<code>zmq_recvfile</code></p>
</td></tr>
<tr><td><code id="File+2B20Transfer+2B20Functions_+3A_forcebin">forcebin</code></td>
<td>
<p>Force to read/send/recv/write in binary form. Typically for a Windows
system, text (ASCII) and binary files are processed differently.
If <code>TRUE</code>, &quot;r+b&quot; and &quot;w+b&quot; will be enforced in the C code.
This option is mainly for Windows.</p>
</td></tr>
<tr><td><code id="File+2B20Transfer+2B20Functions_+3A_ctx">ctx</code></td>
<td>
<p>A ZMQ ctx. If <code>NULL</code> (default), the function will initial one at
the beginning and destroy it after finishing file transfer.</p>
</td></tr>
<tr><td><code id="File+2B20Transfer+2B20Functions_+3A_socket">socket</code></td>
<td>
<p>A ZMQ socket based on <code>ctx</code>.
If <code>NULL</code> (default), the function will create one at the beginning
and close it after finishing file transfer.</p>
</td></tr>
<tr><td><code id="File+2B20Transfer+2B20Functions_+3A_endpoint">endpoint</code></td>
<td>
<p>A ZMQ socket endpoint.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no socket is passed, then by default <code>zmq.sendfile()</code> binds a
<code>ZMQ_PUSH</code> socket, and <code>zmq.recvfile()</code> connects to this with a
<code>ZMQ_PULL</code> socket. On the other hand, a PUSH/PULL, REQ/REP, or REP/REQ
socket pairing may be passed. In that case, the socket should already be
connected to the desired endpoint. Be careful not to pass the wrong socket
combination (e.g., do not do REQ/REQ), as this can put the processes in an
un-recoverable state.
</p>


<h3>Value</h3>

<p><code>zmq.sendfile()</code> and <code>zmq.recvfile()</code> return
number of bytes (invisible) in the sent message if successful,
otherwise returns -1 (invisible) and sets <code>errno</code> to the error
value, see ZeroMQ manual for details.
</p>


<h3>Author(s)</h3>

<p>Drew Schmidt and Christian Heckendorf
</p>


<h3>References</h3>

<p>ZeroMQ/4.1.0 API Reference:
<a href="https://libzmq.readthedocs.io/en/zeromq4-1/">https://libzmq.readthedocs.io/en/zeromq4-1/</a>
</p>
<p>Programming with Big Data in R Website: <a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zmq.msg.send">zmq.msg.send</a>()</code>, <code><a href="#topic+zmq.msg.recv">zmq.msg.recv</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### Run the sender and receiver code in separate R sessions.

# Receiver
library(pbdZMQ, quietly = TRUE)
zmq.recvfile(55555, "localhost", "/tmp/outfile", verbose=TRUE)

# Sender
library(pbdZMQ, quietly = TRUE)
zmq.sendfile(55555, "/tmp/infile", verbose=TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='Initial+20Control+20Functions'>Initial controls in pbdZMQ</h2><span id='topic+Initial+20Control+20Functions'></span><span id='topic+.zmqopt_get'></span><span id='topic+.zmqopt_set'></span><span id='topic+.zmqopt_init'></span>

<h3>Description</h3>

<p>Initial control functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.zmqopt_get(main, sub = NULL, envir = .GlobalEnv)

.zmqopt_set(val, main, sub = NULL, envir = .GlobalEnv)

.zmqopt_init(envir = .GlobalEnv)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Initial+2B20Control+2B20Functions_+3A_main">main</code></td>
<td>
<p>a variable to be get from or set to</p>
</td></tr>
<tr><td><code id="Initial+2B20Control+2B20Functions_+3A_sub">sub</code></td>
<td>
<p>a subvariable to be get from or set to</p>
</td></tr>
<tr><td><code id="Initial+2B20Control+2B20Functions_+3A_envir">envir</code></td>
<td>
<p>an environment where ZMQ controls locate</p>
</td></tr>
<tr><td><code id="Initial+2B20Control+2B20Functions_+3A_val">val</code></td>
<td>
<p>a value to be set</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>.zmqopt_init()</code> initials default ZMQ controls.
<code>.zmqopt_get()</code> gets a ZMQ control.
<code>.zmqopt_set()</code> sets a ZMQ control.
</p>


<h3>Value</h3>

<p><code>.zmqopt_init()</code> initial the ZMQ control
at <code>envir</code>.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>.
</p>


<h3>References</h3>

<p>ZeroMQ/4.1.0 API Reference:
<a href="https://libzmq.readthedocs.io/en/zeromq4-1/">https://libzmq.readthedocs.io/en/zeromq4-1/</a>
</p>
<p>Programming with Big Data in R Website: <a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.pbd_env">.pbd_env</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(pbdZMQ, quietly = TRUE)

ls(.pbd_env)
rm(.pbd_env)
.zmqopt_init()
ls(.pbd_env)

.pbd_env$ZMQ.SR$BLOCK
pbd_opt(bytext = "ZMQ.SR$BLOCK = 0L")

## End(Not run)

</code></pre>

<hr>
<h2 id='ls'>A wrapper function for base::ls</h2><span id='topic+ls'></span>

<h3>Description</h3>

<p>The <code>ls()</code> function with modification to avoid listing hidden
pbd objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ls(
  name,
  pos = -1L,
  envir = as.environment(pos),
  all.names = FALSE,
  pattern,
  sorted = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ls_+3A_name">name</code>, <code id="ls_+3A_pos">pos</code>, <code id="ls_+3A_envir">envir</code>, <code id="ls_+3A_all.names">all.names</code>, <code id="ls_+3A_pattern">pattern</code>, <code id="ls_+3A_sorted">sorted</code></td>
<td>
<p>as the original <code>base::ls()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As the original <code>base::ls()</code>, it returns the names of the objects.
</p>


<h3>Value</h3>

<p>As the original <code>base::ls()</code> except when <code>all.names</code> is <code>TRUE</code>
and <code>envir</code> is <code>.GlobalEnv</code>, hidden pbd objects such as
<code>.pbd_env</code> and <code>.pbdenv</code> will not be returned.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(pbdRPC, quietly = TRUE)
ls(all.names = TRUE)
base::ls(all.names = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='Message+20Function'>Message Functions</h2><span id='topic+Message+20Function'></span><span id='topic+zmq.msg.send'></span><span id='topic+zmq.msg.recv'></span>

<h3>Description</h3>

<p>Message functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zmq.msg.send(
  rmsg,
  socket,
  flags = ZMQ.SR()$BLOCK,
  serialize = TRUE,
  serialversion = NULL
)

zmq.msg.recv(socket, flags = ZMQ.SR()$BLOCK, unserialize = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Message+2B20Function_+3A_rmsg">rmsg</code></td>
<td>
<p>an R message</p>
</td></tr>
<tr><td><code id="Message+2B20Function_+3A_socket">socket</code></td>
<td>
<p>a ZMQ socket</p>
</td></tr>
<tr><td><code id="Message+2B20Function_+3A_flags">flags</code></td>
<td>
<p>a flag for method of send and receive</p>
</td></tr>
<tr><td><code id="Message+2B20Function_+3A_serialize">serialize</code></td>
<td>
<p>if serialize the <code>rmsg</code></p>
</td></tr>
<tr><td><code id="Message+2B20Function_+3A_serialversion">serialversion</code></td>
<td>
<p>NULL or numeric; the workspace format version to use when serializing.
NULL specifies the current default version. The only other supported
values are 2 and 3</p>
</td></tr>
<tr><td><code id="Message+2B20Function_+3A_unserialize">unserialize</code></td>
<td>
<p>if unserialize the received R message</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>zmq.msg.send()</code> sends an R message.
</p>
<p><code>zmq.msg.recv()</code> receives an R message.
</p>


<h3>Value</h3>

<p><code>zmq.msg.send()</code> returns 0 if successful, otherwise returns -1
and sets <code>errno</code> to <code>EFAULT</code>.
</p>
<p><code>zmq.msg.recv()</code> returns the message if successful, otherwise returns
-1 and sets <code>errno</code> to <code>EFAULT</code>.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>.
</p>


<h3>References</h3>

<p>ZeroMQ/4.1.0 API Reference:
<a href="https://libzmq.readthedocs.io/en/zeromq4-1/">https://libzmq.readthedocs.io/en/zeromq4-1/</a>
</p>
<p>Programming with Big Data in R Website: <a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zmq.send">zmq.send</a>()</code>, <code><a href="#topic+zmq.recv">zmq.recv</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### Using request-reply pattern.

### At the server, run next in background or the other window.
library(pbdZMQ, quietly = TRUE)

context &lt;- zmq.ctx.new()
responder &lt;- zmq.socket(context, ZMQ.ST()$REP)
zmq.bind(responder, "tcp://*:5555")
buf &lt;- zmq.msg.recv(responder)
set.seed(1234)
ret &lt;- rnorm(5)
print(ret)
zmq.msg.send(ret, responder)
zmq.close(responder)
zmq.ctx.destroy(context)


### At a client, run next in foreground.
library(pbdZMQ, quietly = TRUE)

context &lt;- zmq.ctx.new()
requester &lt;- zmq.socket(context, ZMQ.ST()$REQ)
zmq.connect(requester, "tcp://localhost:5555")
zmq.msg.send(NULL, requester)
ret &lt;- zmq.msg.recv(requester)
print(ret)
zmq.close(requester)
zmq.ctx.destroy(context)

## End(Not run)

</code></pre>

<hr>
<h2 id='Overwrite+20shpkg'>Overwrite rpath of linked shared library in osx</h2><span id='topic+Overwrite+20shpkg'></span><span id='topic+overwrite.shpkg.rpath'></span>

<h3>Description</h3>

<p>Overwrite rpath of linked shared library
(e.g. <code>JuniperKernel/libs/JuniperKernel.so</code>
in osx only.
Typically, it is called by <code>.onLoad()</code> to update rpath if
<code>pbdZMQ</code> or <code>pbdZMQ/libs/libzmq.*.dylib</code> was moved to
a personal directory
(e.g. the binary package was installed to a none default path).
The commands <code>otool</code> and <code>install_name_tool</code> are required.
Permission may be needed (e.g. <code>sudo</code>) to overwrite the shared
library.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overwrite.shpkg.rpath(
  mylib = NULL,
  mypkg = "JuniperKernel",
  linkingto = "pbdZMQ",
  shlib = "zmq"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Overwrite+2B20shpkg_+3A_mylib">mylib</code></td>
<td>
<p>the path where <code>mypkg</code> was installed (default <code>NULL</code> that will
search from R's path)</p>
</td></tr>
<tr><td><code id="Overwrite+2B20shpkg_+3A_mypkg">mypkg</code></td>
<td>
<p>the package for where <code>mypkg.so</code> will be checked or updated</p>
</td></tr>
<tr><td><code id="Overwrite+2B20shpkg_+3A_linkingto">linkingto</code></td>
<td>
<p>the package for where <code>libshpkg*.dylib</code> is located</p>
</td></tr>
<tr><td><code id="Overwrite+2B20shpkg_+3A_shlib">shlib</code></td>
<td>
<p>name of shlib to be searched for</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>.
</p>
<p>Programming with Big Data in R Website: <a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### Called by .onLoad() within "JuniperKernel/R/zzz.R"
overwrite.shpkg.rpath(mypkg = "JuniperKernel",
                      linkingto = "pbdZMQ",
                      shlib = "zmq")

## End(Not run)

</code></pre>

<hr>
<h2 id='Poll+20Functions'>Poll Functions</h2><span id='topic+Poll+20Functions'></span><span id='topic+zmq.poll'></span><span id='topic+zmq.poll.free'></span><span id='topic+zmq.poll.length'></span><span id='topic+zmq.poll.get.revents'></span>

<h3>Description</h3>

<p>Poll functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zmq.poll(socket, type, timeout = -1L, MC = ZMQ.MC())

zmq.poll.free()

zmq.poll.length()

zmq.poll.get.revents(index = 1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Poll+2B20Functions_+3A_socket">socket</code></td>
<td>
<p>a vector of ZMQ sockets</p>
</td></tr>
<tr><td><code id="Poll+2B20Functions_+3A_type">type</code></td>
<td>
<p>a vector of socket types corresponding to <code>socket</code> argument</p>
</td></tr>
<tr><td><code id="Poll+2B20Functions_+3A_timeout">timeout</code></td>
<td>
<p>timeout for poll, see ZeroMQ manual for details</p>
</td></tr>
<tr><td><code id="Poll+2B20Functions_+3A_mc">MC</code></td>
<td>
<p>a message control, see <code><a href="#topic+ZMQ.MC">ZMQ.MC</a>()</code> for details</p>
</td></tr>
<tr><td><code id="Poll+2B20Functions_+3A_index">index</code></td>
<td>
<p>an index of ZMQ poll items to obtain revents</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>zmq.poll()</code> initials ZMQ poll items given  ZMQ <code>socket</code>'s
and ZMQ poll <code>type</code>'s. Both <code>socket</code> and <code>type</code> are
in vectors of the same length, while <code>socket</code> contains socket pointers
and <code>type</code> contains types of poll.
See <code><a href="#topic+ZMQ.PO">ZMQ.PO</a>()</code> for the possible values of
<code>type</code>. ZMQ defines several poll types and utilize
them to poll multiple sockets.
</p>
<p><code>zmq.poll.free()</code> frees ZMQ poll structure memory internally.
</p>
<p><code>zmq.poll.length()</code> obtains total numbers of ZMQ poll items.
</p>
<p><code>zmq.poll.get.revents()</code> obtains revent types from ZMQ poll item by
the input index.
</p>


<h3>Value</h3>

<p><code>zmq.poll()</code> returns a ZMQ code and an errno,
see ZeroMQ manual for details, no error/warning/interrupt in this
<code>R</code> function, but some error/warning/interrupt may catch by
the <code>C</code> function <code>zmq_poll()</code>.
</p>
<p><code>zmq.poll.length()</code> returns the total number of poll items
</p>
<p><code>zmq.poll.get.revents()</code> returns the revent type
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>.
</p>


<h3>References</h3>

<p>ZeroMQ/4.1.0 API Reference:
<a href="https://libzmq.readthedocs.io/en/zeromq4-1/">https://libzmq.readthedocs.io/en/zeromq4-1/</a>
</p>
<p>Programming with Big Data in R Website: <a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zmq.recv">zmq.recv</a>()</code>, <code><a href="#topic+zmq.send">zmq.send</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### Using poll pattern.
### See demo/mspoller.r for details.

### Run next in background or the other window.
SHELL&gt; Rscript wuserver.r &amp;
SHELL&gt; Rscript taskvent.r &amp;
SHELL&gt; Rscript mspoller.r

### The mspoller.r has next.
library(pbdZMQ, quietly = TRUE)

### Initial.
context &lt;- zmq.ctx.new()
receiver &lt;- zmq.socket(context, ZMQ.ST()$PULL)
zmq.connect(receiver, "tcp://localhost:5557")
subscriber &lt;- zmq.socket(context, ZMQ.ST()$SUB)
zmq.connect(subscriber, "tcp://localhost:5556")
zmq.setsockopt(subscriber, ZMQ.SO()$SUBSCRIBE, "20993")

### Process messages from both sockets.
cat("Press Ctrl+C or Esc to stop mspoller.\n")
i.rec &lt;- 0
i.sub &lt;- 0
while(TRUE){
  ### Set poller.
  zmq.poll(c(receiver, subscriber),
           c(ZMQ.PO()$POLLIN, ZMQ.PO()$POLLIN))

  ### Check receiver.
  if(bitwAnd(zmq.poll.get.revents(1), ZMQ.PO()$POLLIN)){
    ret &lt;- zmq.recv(receiver)
    if(ret$len != -1){
      cat("task ventilator:", ret$buf, "at", i.rec, "\n")
      i.rec &lt;- i.rec + 1
    }
  }

  ### Check subscriber.
  if(bitwAnd(zmq.poll.get.revents(2), ZMQ.PO()$POLLIN)){
    ret &lt;- zmq.recv(subscriber)
    if(ret$len != -1){
      cat("weather update:", ret$buf, "at", i.sub, "\n")
      i.sub &lt;- i.sub + 1
    }
  }

  if(i.rec &gt;= 5 &amp; i.sub &gt;= 5){
    break
  }

  Sys.sleep(runif(1, 0.5, 1))
}

### Finish.
zmq.poll.free()
zmq.close(receiver)
zmq.close(subscriber)
zmq.ctx.destroy(context)

## End(Not run)

</code></pre>

<hr>
<h2 id='random_port'>Random Port</h2><span id='topic+random_port'></span><span id='topic+random_open_port'></span>

<h3>Description</h3>

<p>Generate a valid, random TCP port.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_port(min_port = 49152, max_port = 65536)

random_open_port(min_port = 49152, max_port = 65536, max_tries = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="random_port_+3A_min_port">min_port</code>, <code id="random_port_+3A_max_port">max_port</code></td>
<td>
<p>The minimum/maximum value to be generated.  The minimum should not
be below 49152 and the maximum should not exceed 65536 (see
details).</p>
</td></tr>
<tr><td><code id="random_port_+3A_max_tries">max_tries</code></td>
<td>
<p>The maximum number of times a random port will be searched for.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By definition, a TCP port is an unsigned short, and so it can not
exceed 65535.  Additionally, ports in the range 1024 to 49151 are
(possibly) registered by ICANN for specific uses.
</p>
<p><code>random_port()</code> will simply generate a valid, non-registered
tcp port.  <code>random_unused_port()</code> will generate a port
that is available for socket connections.
</p>
<p><code>random_open_port()</code> finds a random port not already bound
to an endpoint.
</p>


<h3>Author(s)</h3>

<p>Drew Schmidt
</p>


<h3>References</h3>

<p>&quot;The Ephemeral Port Range&quot; by Mike Gleason.  
<a href="https://www.ncftp.com/ncftpd/doc/misc/ephemeral_ports.html">https://www.ncftp.com/ncftpd/doc/misc/ephemeral_ports.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>random_port()

</code></pre>

<hr>
<h2 id='Send+20Receive+20Functions'>Send Receive Functions</h2><span id='topic+Send+20Receive+20Functions'></span><span id='topic+zmq.send'></span><span id='topic+zmq.recv'></span>

<h3>Description</h3>

<p>Send and receive functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zmq.send(socket, buf, flags = ZMQ.SR()$BLOCK)

zmq.recv(
  socket,
  len = 1024L,
  flags = ZMQ.SR()$BLOCK,
  buf.type = c("char", "raw")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Send+2B20Receive+2B20Functions_+3A_socket">socket</code></td>
<td>
<p>a ZMQ socket</p>
</td></tr>
<tr><td><code id="Send+2B20Receive+2B20Functions_+3A_buf">buf</code></td>
<td>
<p>a buffer to be sent</p>
</td></tr>
<tr><td><code id="Send+2B20Receive+2B20Functions_+3A_flags">flags</code></td>
<td>
<p>a flag for the method using by <code>zmq_send</code> and
<code>zmq_recv</code></p>
</td></tr>
<tr><td><code id="Send+2B20Receive+2B20Functions_+3A_len">len</code></td>
<td>
<p>a length of buffer to be received, default 1024 bytes</p>
</td></tr>
<tr><td><code id="Send+2B20Receive+2B20Functions_+3A_buf.type">buf.type</code></td>
<td>
<p>buffer type to be received</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>zmq.send()</code> is a high level R function calling ZMQ C API
<code>zmq_send()</code> sending <code>buf</code> out.
</p>
<p><code>zmq.recv()</code> is a high level R function calling ZMQ C API
<code>zmq_recv()</code> receiving buffers of length <code>len</code> according to the
<code>buf.type</code>.
</p>
<p><code>flags</code> see <code><a href="#topic+ZMQ.SR">ZMQ.SR</a>()</code> for detail options of send and
receive functions.
</p>
<p><code>buf.type</code> currently supports <code>char</code> and <code>raw</code> which are both
in R object format.
</p>


<h3>Value</h3>

<p><code>zmq.send()</code> returns number of bytes (invisible) in the sent
message if successful, otherwise returns -1 (invisible) and sets
<code>errno</code> to the error value, see ZeroMQ manual for details.
</p>
<p><code>zmq.recv()</code> returns a list (<code>ret</code>) containing the received buffer
<code>ret$buf</code> and the length of received buffer (<code>ret$len</code> which is
less or equal to the input <code>len</code>) if successful, otherwise returns -1
and sets <code>errno</code> to the error value, see ZeroMQ manual for details.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>.
</p>


<h3>References</h3>

<p>ZeroMQ/4.1.0 API Reference:
<a href="https://libzmq.readthedocs.io/en/zeromq4-1/">https://libzmq.readthedocs.io/en/zeromq4-1/</a>
</p>
<p>Programming with Big Data in R Website: <a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zmq.msg.send">zmq.msg.send</a>()</code>, <code><a href="#topic+zmq.msg.recv">zmq.msg.recv</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### Using request-reply pattern.

### At the server, run next in background or the other window.
library(pbdZMQ, quietly = TRUE)

context &lt;- zmq.ctx.new()
responder &lt;- zmq.socket(context, ZMQ.ST()$REP)
zmq.bind(responder, "tcp://*:5555")
for(i.res in 1:5){
  buf &lt;- zmq.recv(responder, 10L)
  cat(buf$buf, "\n")
  Sys.sleep(0.5)
  zmq.send(responder, "World")
}
zmq.close(responder)
zmq.ctx.destroy(context)


### At a client, run next in foreground.
library(pbdZMQ, quietly = TRUE)

context &lt;- zmq.ctx.new()
requester &lt;- zmq.socket(context, ZMQ.ST()$REQ)
zmq.connect(requester, "tcp://localhost:5555")
for(i.req in 1:5){
  cat("Sending Hello ", i.req, "\n")
  zmq.send(requester, "Hello")
  buf &lt;- zmq.recv(requester, 10L)
  cat("Received World ", i.req, "\n")
}
zmq.close(requester)
zmq.ctx.destroy(context)

## End(Not run)

</code></pre>

<hr>
<h2 id='Send+20Receive+20Multiple+20Raw+20Buffers'>Send Receive Multiple Raw Buffers</h2><span id='topic+Send+20Receive+20Multiple+20Raw+20Buffers'></span><span id='topic+zmq.send.multipart'></span><span id='topic+zmq.recv.multipart'></span>

<h3>Description</h3>

<p>Send and receive functions for multiple raw buffers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zmq.send.multipart(socket, parts, serialize = TRUE)

zmq.recv.multipart(socket, unserialize = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Send+2B20Receive+2B20Multiple+2B20Raw+2B20Buffers_+3A_socket">socket</code></td>
<td>
<p>a ZMQ socket</p>
</td></tr>
<tr><td><code id="Send+2B20Receive+2B20Multiple+2B20Raw+2B20Buffers_+3A_parts">parts</code></td>
<td>
<p>a vector of multiple buffers to be sent</p>
</td></tr>
<tr><td><code id="Send+2B20Receive+2B20Multiple+2B20Raw+2B20Buffers_+3A_serialize">serialize</code>, <code id="Send+2B20Receive+2B20Multiple+2B20Raw+2B20Buffers_+3A_unserialize">unserialize</code></td>
<td>
<p>if serialize/unserialize the received multiple buffers</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>zmq.send.multipart()</code> is a high level R function to send multiple
raw messages <code>parts</code> at once.
</p>
<p><code>zmq.recv.multipart()</code> is a high level R function to receive multiple
raw messages at once.
</p>


<h3>Value</h3>

<p><code>zmq.send.multipart()</code> returns.
</p>
<p><code>zmq.recv.multipart()</code> returns.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>.
</p>


<h3>References</h3>

<p>ZeroMQ/4.1.0 API Reference:
<a href="https://libzmq.readthedocs.io/en/zeromq4-1/">https://libzmq.readthedocs.io/en/zeromq4-1/</a>
</p>
<p>Programming with Big Data in R Website: <a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zmq.msg.send">zmq.msg.send</a>()</code>, <code><a href="#topic+zmq.msg.recv">zmq.msg.recv</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### Using request-reply pattern.

### At the server, run next in background or the other window.
library(pbdZMQ, quietly = TRUE)

context &lt;- zmq.ctx.new()
responder &lt;- zmq.socket(context, ZMQ.ST()$REP)
zmq.bind(responder, "tcp://*:5555")

ret &lt;- zmq.recv.multipart(responder, unserialize = TRUE)
parts &lt;- as.list(rep("World", 5))
zmq.send.multipart(responder, parts)
for(i in 1:5) cat(ret[[i]])

zmq.close(responder)
zmq.ctx.destroy(context)

### At a client, run next in foreground.
library(pbdZMQ, quietly = TRUE)

context &lt;- zmq.ctx.new()
requester &lt;- zmq.socket(context, ZMQ.ST()$REQ)
zmq.connect(requester, "tcp://localhost:5555")

parts &lt;- lapply(1:5, function(i.req){ paste("Sending Hello ", i.req, "\n") })
zmq.send.multipart(requester, parts)
ret &lt;- zmq.recv.multipart(requester, unserialize = TRUE)
print(ret)

zmq.close(requester)
zmq.ctx.destroy(context)

## End(Not run)

</code></pre>

<hr>
<h2 id='Set+20Control+20Functions'>Set controls in pbdZMQ</h2><span id='topic+Set+20Control+20Functions'></span><span id='topic+pbd_opt'></span>

<h3>Description</h3>

<p>Set control functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pbd_opt(..., bytext = "", envir = .GlobalEnv)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Set+2B20Control+2B20Functions_+3A_...">...</code></td>
<td>
<p>in argument format <code>option = value</code> to set
<code>.pbd_env$option &lt;- value</code> inside the <code>envir</code></p>
</td></tr>
<tr><td><code id="Set+2B20Control+2B20Functions_+3A_bytext">bytext</code></td>
<td>
<p>in text format <code>"option = value"</code> to set
<code>.pbd_env$option &lt;- value</code> inside the <code>envir</code>.</p>
</td></tr>
<tr><td><code id="Set+2B20Control+2B20Functions_+3A_envir">envir</code></td>
<td>
<p>by default the global environment is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pbd_opt()</code> sets pbd options for ZMQ controls.
</p>
<p><code>...</code> allows multiple options in
<code>envir$.pbd_env</code>, but only in a simple way.
</p>
<p><code>bytext</code> allows to assign options by text in
<code>envir$.pbd_env</code>, but can assign advanced objects. For example,
<code>"option$suboption &lt;- value"</code> will set
<code>envir$.pbd_env$option$suboption &lt;- value</code>.
</p>


<h3>Value</h3>

<p>No value is returned.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a> and Drew Schmidt.
</p>


<h3>References</h3>

<p>ZeroMQ/4.1.0 API Reference:
<a href="https://libzmq.readthedocs.io/en/zeromq4-1/">https://libzmq.readthedocs.io/en/zeromq4-1/</a>
</p>
<p>Programming with Big Data in R Website: <a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.pbd_env">.pbd_env</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(pbdZMQ, quietly = TRUE)

ls(.pbd_env)
rm(.pbd_env)
.zmqopt_init()
ls(.pbd_env)

.pbd_env$ZMQ.SR$BLOCK
pbd_opt(bytext = "ZMQ.SR$BLOCK &lt;- 0L")

## End(Not run)

</code></pre>

<hr>
<h2 id='shellexec.wcc'>Shell Execution via cmd windows</h2><span id='topic+shellexec.wcc'></span>

<h3>Description</h3>

<p>This function is an extension to the <code>shell.exec</code>() which is a native
function of R
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shellexec.wcc(file, SW.cmd = 7L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shellexec.wcc_+3A_file">file</code></td>
<td>
<p>a file name as in <code>shell.exec</code>()</p>
</td></tr>
<tr><td><code id="shellexec.wcc_+3A_sw.cmd">SW.cmd</code></td>
<td>
<p>a SW_* command of showing windows</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>shell.exec("a.txt")</code> will open a windows (notepad) to edit the file
<code>a.txt</code> in windows system. However, the notepad will block the (parent)
active R windows, i.e. <code>SW.cmd = 5</code> as <code>SH_SHOW</code> by default.
</p>
<p>The <code>shellexec.wcc("a.txt", SW.cmd = 7L)</code> will open the notepad, but in
a minimized window. Therefore, there is no blocking to the active R windows.
See the website in the references section to see more options to control the
behavior of new windows. Possible choices are
</p>
<p><code>SW_SHOW (5)</code>: Activates the window and displays it in its current size
and position.
</p>
<p><code>SW_SHOWMINIMIZED (2)</code>: Activates the window and displays it as a
minimized window.
</p>
<p><code>SW_SHOWMINNOACTIVE (7)</code>: Displays the window as a minimized window.
The active window remains active.
</p>
<p><code>SW_SHOWNA (8)</code>: Displays the window in its current state.  The active
window remains active.
</p>


<h3>Value</h3>

<p>A new windows with certain applications depending on the association
of the input <code>file</code>.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>.
</p>


<h3>References</h3>

<p>Microsoft, Windows Dev Center: Windows desktop applications &gt;
Develop &gt; Desktop technologies &gt; Desktop Environment &gt; The Windows Shell &gt;
Shell Reference &gt; Shell Functions &gt; ShellExecute
</p>
<p><code>https://msdn.microsoft.com/en-us/library/windows/desktop/bb762153(v=vs.85).aspx</code>
</p>


<h3>See Also</h3>

<p><code>shell.exec()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(pbdZMQ, quietly = TRUE)

shellexec.wcc("a.txt", 5L)

## End(Not run)

</code></pre>

<hr>
<h2 id='Socket+20Functions'>Socket Functions</h2><span id='topic+Socket+20Functions'></span><span id='topic+zmq.socket'></span><span id='topic+zmq.close'></span><span id='topic+zmq.bind'></span><span id='topic+zmq.connect'></span><span id='topic+zmq.disconnect'></span><span id='topic+zmq.setsockopt'></span><span id='topic+zmq.getsockopt'></span>

<h3>Description</h3>

<p>Socket functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zmq.socket(ctx, type = ZMQ.ST()$REP)

zmq.close(socket)

zmq.bind(socket, endpoint, MC = ZMQ.MC())

zmq.connect(socket, endpoint, MC = ZMQ.MC())

zmq.disconnect(socket, endpoint, MC = ZMQ.MC())

zmq.setsockopt(socket, option.name, option.value, MC = ZMQ.MC())

zmq.getsockopt(socket, option.name, option.value, MC = ZMQ.MC())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Socket+2B20Functions_+3A_ctx">ctx</code></td>
<td>
<p>a ZMQ context</p>
</td></tr>
<tr><td><code id="Socket+2B20Functions_+3A_type">type</code></td>
<td>
<p>a socket type</p>
</td></tr>
<tr><td><code id="Socket+2B20Functions_+3A_socket">socket</code></td>
<td>
<p>a ZMQ socket</p>
</td></tr>
<tr><td><code id="Socket+2B20Functions_+3A_endpoint">endpoint</code></td>
<td>
<p>a ZMQ socket endpoint</p>
</td></tr>
<tr><td><code id="Socket+2B20Functions_+3A_mc">MC</code></td>
<td>
<p>a message control, see <code><a href="#topic+ZMQ.MC">ZMQ.MC</a>()</code> for details</p>
</td></tr>
<tr><td><code id="Socket+2B20Functions_+3A_option.name">option.name</code></td>
<td>
<p>an option name to the socket</p>
</td></tr>
<tr><td><code id="Socket+2B20Functions_+3A_option.value">option.value</code></td>
<td>
<p>an option value to the option name</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>zmq.socket()</code> initials a ZMQ socket given a ZMQ context <code>ctx</code> and
a socket <code>type</code>. See <code><a href="#topic+ZMQ.ST">ZMQ.ST</a>()</code> for the possible values of
<code>type</code>. ZMQ defines several patterns for the socket type and utilize
them to communicate in different ways including request-reply,
publish-subscribe, pipeline, exclusive pair, and naive patterns.
</p>
<p><code>zmq.close()</code> destroys the ZMQ socket.
</p>
<p><code>zmq.bind()</code> binds the socket to a local endpoint and then accepts
incoming connections on that endpoint. See <code>endpoint</code> next for details.
</p>
<p><code>zmq.connect()</code> connects the socket to a remote endpoint and then
accepts outgoing connections on that endpoint. See <code>endpoint</code> next for
details.
</p>
<p><code>endpoint</code> is a string consisting of a transport :// followed by an
address. The transport specifies the underlying protocol to use. The address
specifies the transport-specific address to bind to.  pbdZMQ/ZMQ provides
the following transports: </p>

<table>
<tr>
 <td style="text-align: left;"> Transport </td><td style="text-align: left;"> Usage </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>tcp</code>
</td><td style="text-align: left;"> unicast transport using TCP </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>ipc</code> </td><td style="text-align: left;"> local inter-process
communication transport </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>inproc</code> </td><td style="text-align: left;"> local in-process
(inter-thread) communication transport </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>pgm,epgm</code> </td><td style="text-align: left;"> reliable
multicast transport using PGM </td>
</tr>

</table>
<p> *** warning: <code>epgm</code> is not turned on by
default in the pbdZMQ's internal ZeroMQ library. <br /> *** warning: <code>ipc</code>
is not supported in Windows system.
</p>
<p><code>zmq.setsockopt()</code> is to set/change socket options.
</p>
<p><code>zmq.getsockopt()</code> is to get socket options and returns
<code>option.value</code>.
</p>


<h3>Value</h3>

<p><code>zmq.socket()</code> returns an R external pointer (<code>socket</code>)
generated by ZMQ C API pointing to a socket if successful, otherwise returns
an R <code>NULL</code> and sets <code>errno</code> to the error value, see ZeroMQ manual
for details.
</p>
<p><code>zmq.close()</code> destroys the socket reference/pointer (<code>socket</code>) and
returns 0 if successful, otherwise returns -1 and sets <code>errno</code> to the
error value, see ZeroMQ manual for details.
</p>
<p><code>zmq.bind()</code> binds the socket to specific <code>endpoint</code> and returns 0
if successful, otherwise returns -1 and sets <code>errno</code> to the error
value, see ZeroMQ manual for details.
</p>
<p><code>zmq.connect()</code> connects the socket to specific <code>endpoint</code> and
returns 0 if successful, otherwise returns -1 and sets <code>errno</code> to the
error value, see ZeroMQ manual for details.
</p>
<p><code>zmq.setsockopt()</code> sets/changes the socket option and returns 0 if
successful, otherwise returns -1 and sets <code>errno</code> to the error value,
see ZeroMQ manual for details.
</p>
<p><code>zmq.getsockopt()</code> returns the value of socket option,
see ZeroMQ manual for details.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>.
</p>


<h3>References</h3>

<p>ZeroMQ/4.1.0 API Reference:
<a href="https://libzmq.readthedocs.io/en/zeromq4-1/">https://libzmq.readthedocs.io/en/zeromq4-1/</a>
</p>
<p>Programming with Big Data in R Website: <a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zmq.ctx.new">zmq.ctx.new</a>()</code>, <code><a href="#topic+zmq.ctx.destroy">zmq.ctx.destroy</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### Using request-reply pattern.

### At the server, run next in background or the other windows.
library(pbdZMQ, quietly = TRUE)

context &lt;- zmq.ctx.new()
responder &lt;- zmq.socket(context, ZMQ.ST()$REP)
zmq.bind(responder, "tcp://*:5555")
zmq.close(responder)
zmq.ctx.destroy(context)


### At a client, run next in foreground.
library(pbdZMQ, quietly = TRUE)

context &lt;- zmq.ctx.new()
requester &lt;- zmq.socket(context, ZMQ.ST()$REQ)
zmq.connect(requester, "tcp://localhost:5555")
zmq.close(requester)
zmq.ctx.destroy(context)

## End(Not run)

</code></pre>

<hr>
<h2 id='Transfer+20Functions+20for+20Files+20or+20Directories'>Transfer Functions for Files or Directories</h2><span id='topic+Transfer+20Functions+20for+20Files+20or+20Directories'></span><span id='topic+zmq.senddir'></span><span id='topic+zmq.recvdir'></span>

<h3>Description</h3>

<p>High level functions calling <code>zmq.sendfile()</code> and <code>zmq.recvfile()</code>
to zip, transfer, and unzip small files or directories contains small files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zmq.senddir(
  port,
  infiles,
  verbose = FALSE,
  flags = ZMQ.SR()$BLOCK,
  ctx = NULL,
  socket = NULL
)

zmq.recvdir(
  port,
  endpoint,
  outfile = NULL,
  exdir = NULL,
  verbose = FALSE,
  flags = ZMQ.SR()$BLOCK,
  ctx = NULL,
  socket = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Transfer+2B20Functions+2B20for+2B20Files+2B20or+2B20Directories_+3A_port">port</code></td>
<td>
<p>A valid tcp port to be passed to <code>zmq.sendfile()</code> and
<code>zmq.recvfile()</code>.</p>
</td></tr>
<tr><td><code id="Transfer+2B20Functions+2B20for+2B20Files+2B20or+2B20Directories_+3A_infiles">infiles</code></td>
<td>
<p>The name (as a string) vector of the in files to be zipped and to be
sent away.</p>
</td></tr>
<tr><td><code id="Transfer+2B20Functions+2B20for+2B20Files+2B20or+2B20Directories_+3A_verbose">verbose</code></td>
<td>
<p>Logical; determines if a progress bar should be shown.</p>
</td></tr>
<tr><td><code id="Transfer+2B20Functions+2B20for+2B20Files+2B20or+2B20Directories_+3A_flags">flags</code></td>
<td>
<p>A flag for the method used by <code>zmq_sendfile</code> and
<code>zmq_recvfile</code></p>
</td></tr>
<tr><td><code id="Transfer+2B20Functions+2B20for+2B20Files+2B20or+2B20Directories_+3A_ctx">ctx</code></td>
<td>
<p>A ZMQ ctx. If <code>NULL</code> (default), the function will initial one at
the beginning and destroy it after finishing file transfer.</p>
</td></tr>
<tr><td><code id="Transfer+2B20Functions+2B20for+2B20Files+2B20or+2B20Directories_+3A_socket">socket</code></td>
<td>
<p>A ZMQ socket based on <code>ctx</code>.
If <code>NULL</code> (default), the function will create one at the beginning
and close it after finishing file transfer.</p>
</td></tr>
<tr><td><code id="Transfer+2B20Functions+2B20for+2B20Files+2B20or+2B20Directories_+3A_endpoint">endpoint</code></td>
<td>
<p>A ZMQ socket endpoint to be passed to <code>zmq.sendfile()</code> and
<code>zmq.recvfile()</code>.</p>
</td></tr>
<tr><td><code id="Transfer+2B20Functions+2B20for+2B20Files+2B20or+2B20Directories_+3A_outfile">outfile</code></td>
<td>
<p>The name (as a string) of the out file to be saved on the disk.
If <code>outfile = NULL</code> and <code>exdir = NULL</code>, a tempfile will be
used and the tempfile nanme will be returned.</p>
</td></tr>
<tr><td><code id="Transfer+2B20Functions+2B20for+2B20Files+2B20or+2B20Directories_+3A_exdir">exdir</code></td>
<td>
<p>The name (as a string) of the out directory to save the unzip files
unzipped from the received <code>outfile</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>zmq.senddir()</code> calls <code>zmq.senddir()</code>, and
<code>zmq.recvdir()</code> calls <code>zmq.recvdir()</code>.
</p>


<h3>Value</h3>

<p><code>zmq.senddir()</code> and <code>zmq.recvdir()</code> return
number of bytes (invisible) in the sent message if successful,
otherwise returns -1 (invisible) and sets <code>errno</code> to the error
value, see ZeroMQ manual for details.
In addition, <code>zmq.recvdir()</code> returns a zipped file name in a list.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen
</p>


<h3>References</h3>

<p>ZeroMQ/4.1.0 API Reference:
<a href="https://libzmq.readthedocs.io/en/zeromq4-1/">https://libzmq.readthedocs.io/en/zeromq4-1/</a>
</p>
<p>Programming with Big Data in R Website: <a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zmq.sendfile">zmq.sendfile</a>()</code>, <code><a href="#topic+zmq.recvfile">zmq.recvfile</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### Run the sender and receiver code in separate R sessions.

### Receiver
library(pbdZMQ, quietly = TRUE)
zmq.recvdir(55555, "localhost", outfile = "./backup_2019.zip",
            verbose = TRUE)
### or unzip to exdir
# zmq.recvdir(55555, "localhost", exdir = "./backup_2019", verbose = TRUE)

### Sender
library(pbdZMQ, quietly = TRUE)
zmq.senddir(55555, c("./pbdZMQ/R", "./pbdZMQ/src"), verbose = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='Utility+20Functions'>Utility Functions</h2><span id='topic+Utility+20Functions'></span><span id='topic+zmq.strerror'></span><span id='topic+zmq.version'></span>

<h3>Description</h3>

<p>Utility functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zmq.strerror(errno)

zmq.version()
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Utility+2B20Functions_+3A_errno">errno</code></td>
<td>
<p>an integer for the error number</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>zmq.strerror()</code> gets ZeroMQ error message string.
</p>
<p><code>zmq.version()</code> print current ZeroMQ version.
</p>


<h3>Value</h3>

<p><code>zmq.strerror()</code> returns an R string containing ZeroMQ error
message.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>.
</p>


<h3>References</h3>

<p>ZeroMQ/4.1.0 API Reference:
<a href="https://libzmq.readthedocs.io/en/zeromq4-1/">https://libzmq.readthedocs.io/en/zeromq4-1/</a>
</p>
<p>Programming with Big Data in R Website: <a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zmq.ctx.new">zmq.ctx.new</a>()</code>, <code><a href="#topic+zmq.ctx.destroy">zmq.ctx.destroy</a>()</code>,
<code><a href="#topic+zmq.socket">zmq.socket</a>()</code>, <code><a href="#topic+zmq.close">zmq.close</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(pbdZMQ, quietly = TRUE)

context &lt;- zmq.ctx.new()
zmq.ctx.destroy(context)
zmq.strerror(0)

zmq.ctx.destroy(context) # Error since context is free.
zmq.strerror(14)

## End(Not run)

</code></pre>

<hr>
<h2 id='Wrapper+20Functions+20for+20rzmq'>All Wrapper Functions for rzmq</h2><span id='topic+Wrapper+20Functions+20for+20rzmq'></span><span id='topic+send.socket'></span><span id='topic+receive.socket'></span><span id='topic+init.context'></span><span id='topic+init.socket'></span><span id='topic+bind.socket'></span><span id='topic+connect.socket'></span>

<h3>Description</h3>

<p>Wrapper functions for backwards compatibility with rzmq.  See vignette
for examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>send.socket(
  socket,
  data,
  send.more = FALSE,
  serialize = TRUE,
  serialversion = NULL
)

receive.socket(socket, unserialize = TRUE, dont.wait = FALSE)

init.context()

init.socket(context, socket.type)

bind.socket(socket, address)

connect.socket(socket, address)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Wrapper+2B20Functions+2B20for+2B20rzmq_+3A_socket">socket</code></td>
<td>
<p>A ZMQ socket.</p>
</td></tr>
<tr><td><code id="Wrapper+2B20Functions+2B20for+2B20rzmq_+3A_data">data</code></td>
<td>
<p>An R object.</p>
</td></tr>
<tr><td><code id="Wrapper+2B20Functions+2B20for+2B20rzmq_+3A_send.more">send.more</code></td>
<td>
<p>Logical; will more messages be sent?</p>
</td></tr>
<tr><td><code id="Wrapper+2B20Functions+2B20for+2B20rzmq_+3A_serialize">serialize</code>, <code id="Wrapper+2B20Functions+2B20for+2B20rzmq_+3A_unserialize">unserialize</code></td>
<td>
<p>Logical; determines if serialize/unserialize should be called
on the sent/received data.</p>
</td></tr>
<tr><td><code id="Wrapper+2B20Functions+2B20for+2B20rzmq_+3A_serialversion">serialversion</code></td>
<td>
<p>NULL or numeric; the workspace format version to use when serializing.
NULL specifies the current default version. The only other supported
values are 2 and 3.</p>
</td></tr>
<tr><td><code id="Wrapper+2B20Functions+2B20for+2B20rzmq_+3A_dont.wait">dont.wait</code></td>
<td>
<p>Logical; determines if reception is blocking.</p>
</td></tr>
<tr><td><code id="Wrapper+2B20Functions+2B20for+2B20rzmq_+3A_context">context</code></td>
<td>
<p>A ZMQ context.</p>
</td></tr>
<tr><td><code id="Wrapper+2B20Functions+2B20for+2B20rzmq_+3A_socket.type">socket.type</code></td>
<td>
<p>The type of ZMQ socket as a string, of the form &quot;ZMQ_type&quot;.  Valid 'type'
values are PAIR, PUB, SUB, REQ, REP, DEALER, PULL, PUSH, XPUB, XSUB, and
STERAM.</p>
</td></tr>
<tr><td><code id="Wrapper+2B20Functions+2B20for+2B20rzmq_+3A_address">address</code></td>
<td>
<p>A valid address.  See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>send.socket()</code>/<code>receive.socket()</code> send/receive messages over
a socket.  These are simple wrappers around <code>zmq.msg.send()</code> and
<code>zmq.msg.receive()</code>, respectively.
</p>
<p><code>init.context()</code> creates a new ZeroMQ context.  A useful wrapper
around <code>zmq.ctx.new()</code> which handles freeing memory for you, i.e.
<code>zmq.ctx.destroy()</code> will automatically be called for you.
</p>
<p><code>init.socket()</code> creates a ZeroMQ socket; serves as a high-level
binding for <code>zmq.socket()</code>, including handling freeing memory
automatically.  See also <code>ZMQ.ST()</code>.
</p>
<p><code>bind.socket()</code>:  see <code>zmq.bind()</code>.
</p>
<p><code>connect.socket()</code>:  see <code>zmq.connect()</code>
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>.
</p>


<h3>References</h3>

<p>ZeroMQ/4.1.0 API Reference:
<a href="https://libzmq.readthedocs.io/en/zeromq4-1/">https://libzmq.readthedocs.io/en/zeromq4-1/</a>
</p>
<p>Programming with Big Data in R Website: <a href="https://pbdr.org/">https://pbdr.org/</a>
</p>

<hr>
<h2 id='ZMQ+20Control+20Environment'>Sets of controls in pbdZMQ.</h2><span id='topic+ZMQ+20Control+20Environment'></span><span id='topic+.pbd_env'></span>

<h3>Description</h3>

<p>These sets of controls are used to provide default values in this package.
</p>


<h3>Format</h3>

<p>Objects contain several parameters for communicators and methods.
</p>


<h3>Details</h3>

<p>The elements of <code>.pbd_env$ZMQ.ST</code> are default values for socket types
as defined in &lsquo;zmq.h&rsquo; including </p>

<table>
<tr>
 <td style="text-align: left;"> Elements </td><td style="text-align: center;"> Value </td><td style="text-align: left;">
Usage </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>PAIR</code> </td><td style="text-align: center;"> 0L </td><td style="text-align: left;"> socket type PAIR </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>PUB</code> </td><td style="text-align: center;"> 1L
</td><td style="text-align: left;"> socket type PUB </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>SUB</code> </td><td style="text-align: center;"> 2L </td><td style="text-align: left;"> socket type SUB </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>REQ</code> </td><td style="text-align: center;"> 3L </td><td style="text-align: left;"> socket type REQ </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>REP</code> </td><td style="text-align: center;"> 4L </td><td style="text-align: left;"> socket
type REP </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>DEALER</code> </td><td style="text-align: center;"> 5L </td><td style="text-align: left;"> socket type DEALER </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>ROUTER</code>
</td><td style="text-align: center;"> 6L </td><td style="text-align: left;"> socket type ROUTER </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>PULL</code> </td><td style="text-align: center;"> 7L </td><td style="text-align: left;"> socket type
PULL </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>PUSH</code> </td><td style="text-align: center;"> 8L </td><td style="text-align: left;"> socket type PUSH </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>XPUB</code> </td><td style="text-align: center;"> 9L
</td><td style="text-align: left;"> socket type XPUB </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>XSUB</code> </td><td style="text-align: center;"> 10L </td><td style="text-align: left;"> socket type XSUB </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>STREAM</code> </td><td style="text-align: center;"> 11L </td><td style="text-align: left;"> socket type STREAM </td>
</tr>

</table>

<p>The elements of <code>.pbd_env$ZMQ.SO</code> are default values for socket
options as defined in &lsquo;zmq.h&rsquo; including 60 different values, see
<code>.pbd_env$ZMQ.SO</code> and &lsquo;zmq.h&rsquo; for details.
</p>
<p>The elements of <code>.pbd_env$ZMQ.SR</code> are default values for send/recv
options as defined in &lsquo;zmq.h&rsquo; including </p>

<table>
<tr>
 <td style="text-align: left;"> Elements </td><td style="text-align: center;"> Value
</td><td style="text-align: left;"> Usage </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>BLOCK</code> </td><td style="text-align: center;"> 0L </td><td style="text-align: left;"> send/recv option BLOCK </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>DONTWAIT</code> </td><td style="text-align: center;"> 1L </td><td style="text-align: left;"> send/recv option DONTWAIT </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>NOBLOCK</code>
</td><td style="text-align: center;"> 1L </td><td style="text-align: left;"> send/recv option NOBLOCK </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>SNDMORE</code> </td><td style="text-align: center;"> 2L </td><td style="text-align: left;">
send/recv option SNDMORE (not supported) </td>
</tr>

</table>

<p>The elements of <code>.pbd_env$ZMQ.MC</code> are default values for warning and
stop controls in R. These are not the ZeroMQ's internal default values. They
are defined as </p>

<table>
<tr>
 <td style="text-align: left;"> Elements </td><td style="text-align: center;"> Value </td><td style="text-align: left;"> Usage </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>warning.at.error</code> </td><td style="text-align: center;"> TRUE </td><td style="text-align: left;"> if warn at error </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>stop.at.error</code> </td><td style="text-align: center;"> TRUE </td><td style="text-align: left;"> if stop at error </td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>.
</p>


<h3>References</h3>

<p>ZeroMQ/4.1.0 API Reference:
<a href="https://libzmq.readthedocs.io/en/zeromq4-1/">https://libzmq.readthedocs.io/en/zeromq4-1/</a>
</p>
<p>Programming with Big Data in R Website: <a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.zmqopt_init">.zmqopt_init</a>()</code>.
</p>

<hr>
<h2 id='ZMQ+20Control+20Functions'>Sets of controls in pbdZMQ.</h2><span id='topic+ZMQ+20Control+20Functions'></span><span id='topic+ZMQ.MC'></span><span id='topic+ZMQ.PO'></span><span id='topic+ZMQ.SR'></span><span id='topic+ZMQ.SO'></span><span id='topic+ZMQ.ST'></span>

<h3>Description</h3>

<p>These sets of controls are used to provide default values in this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ZMQ.MC(warning.at.error = TRUE, stop.at.error = FALSE, check.eintr = FALSE)

ZMQ.PO(POLLIN = 1L, POLLOUT = 2L, POLLERR = 4L)

ZMQ.SR(BLOCK = 0L, DONTWAIT = 1L, NOBLOCK = 1L, SNDMORE = 2L)

ZMQ.SO(
  AFFINITY = 4L,
  IDENTITY = 5L,
  SUBSCRIBE = 6L,
  UNSUBSCRIBE = 7L,
  RATE = 8L,
  RECOVERY_IVL = 9L,
  SNDBUF = 11L,
  RCVBUF = 12L,
  RCVMORE = 13L,
  FD = 14L,
  EVENTS = 15L,
  TYPE = 16L,
  LINGER = 17L,
  RECONNECT_IVL = 18L,
  BACKLOG = 19L,
  RECONNECT_IVL_MAX = 21L,
  MAXMSGSIZE = 22L,
  SNDHWM = 23L,
  RCVHWM = 24L,
  MULTICAST_HOPS = 25L,
  RCVTIMEO = 27L,
  SNDTIMEO = 28L,
  LAST_ENDPOINT = 32L,
  ROUTER_MANDATORY = 33L,
  TCP_KEEPALIVE = 34L,
  TCP_KEEPALIVE_CNT = 35L,
  TCP_KEEPALIVE_IDLE = 36L,
  TCP_KEEPALIVE_INTVL = 37L,
  TCP_ACCEPT_FILTER = 38L,
  IMMEDIATE = 39L,
  XPUB_VERBOSE = 40L,
  ROUTER_RAW = 41L,
  IPV6 = 42L,
  MECHANISM = 43L,
  PLAIN_SERVER = 44L,
  PLAIN_USERNAME = 45L,
  PLAIN_PASSWORD = 46L,
  CURVE_SERVER = 47L,
  CURVE_PUBLICKEY = 48L,
  CURVE_SECRETKEY = 49L,
  CURVE_SERVERKEY = 50L,
  PROBE_ROUTER = 51L,
  REQ_CORRELATE = 52L,
  REQ_RELAXED = 53L,
  CONFLATE = 54L,
  ZAP_DOMAIN = 55L,
  ROUTER_HANDOVER = 56L,
  TOS = 57L,
  IPC_FILTER_PID = 58L,
  IPC_FILTER_UID = 59L,
  IPC_FILTER_GID = 60L,
  CONNECT_RID = 61L,
  GSSAPI_SERVER = 62L,
  GSSAPI_PRINCIPAL = 63L,
  GSSAPI_SERVICE_PRINCIPAL = 64L,
  GSSAPI_PLAINTEXT = 65L,
  HANDSHAKE_IVL = 66L,
  IDENTITY_FD = 67L,
  SOCKS_PROXY = 68L,
  XPUB_NODROP = 69L,
  BLOCKY = 70L,
  XPUB_MANUAL = 71L,
  XPUB_WELCOME_MSG = 72L,
  STREAM_NOTIFY = 73L,
  INVERT_MATCHING = 74L,
  HEARTBEAT_IVL = 75L,
  HEARTBEAT_TTL = 76L,
  HEARTBEAT_TIMEOUT = 77L,
  XPUB_VERBOSER = 78L,
  CONNECT_TIMEOUT = 79L,
  TCP_MAXRT = 80L,
  THREAD_SAFE = 81L,
  MULTICAST_MAXTPDU = 84L,
  VMCI_BUFFER_SIZE = 85L,
  VMCI_BUFFER_MIN_SIZE = 86L,
  VMCI_BUFFER_MAX_SIZE = 87L,
  VMCI_CONNECT_TIMEOUT = 88L,
  USE_FD = 89L,
  GSSAPI_PRINCIPAL_NAMETYPE = 90L,
  GSSAPI_SERVICE_PRINCIPAL_NAMETYPE = 91L,
  BINDTODEVICE = 92L,
  ZAP_ENFORCE_DOMAIN = 93L,
  LOOPBACK_FASTPATH = 94L,
  METADATA = 95L,
  MULTICAST_LOOP = 96L,
  ROUTER_NOTIFY = 97L,
  XPUB_MANUAL_LAST_VALUE = 98L,
  SOCKS_USERNAME = 99L,
  SOCKS_PASSWORD = 100L,
  IN_BATCH_SIZE = 101L,
  OUT_BATCH_SIZE = 102L,
  WSS_KEY_PEM = 103L,
  WSS_CERT_PEM = 104L,
  WSS_TRUST_PEM = 105L,
  WSS_HOSTNAME = 106L,
  WSS_TRUST_SYSTEM = 107L,
  ONLY_FIRST_SUBSCRIBE = 108L,
  RECONNECT_STOP = 109L,
  HELLO_MSG = 110L,
  DISCONNECT_MSG = 111L,
  PRIORITY = 112L
)

ZMQ.ST(
  PAIR = 0L,
  PUB = 1L,
  SUB = 2L,
  REQ = 3L,
  REP = 4L,
  DEALER = 5L,
  ROUTER = 6L,
  PULL = 7L,
  PUSH = 8L,
  XPUB = 9L,
  XSUB = 10L,
  STREAM = 11L
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ZMQ+2B20Control+2B20Functions_+3A_warning.at.error">warning.at.error</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_stop.at.error">stop.at.error</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_check.eintr">check.eintr</code></td>
<td>
<p>Logical; if there is a messaging error, should there be an
R warning/error, or check user interrupt events.</p>
</td></tr>
<tr><td><code id="ZMQ+2B20Control+2B20Functions_+3A_pollin">POLLIN</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_pollout">POLLOUT</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_pollerr">POLLERR</code></td>
<td>
<p>ZMQ poll options; see zmq.h for details.</p>
</td></tr>
<tr><td><code id="ZMQ+2B20Control+2B20Functions_+3A_block">BLOCK</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_dontwait">DONTWAIT</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_noblock">NOBLOCK</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_sndmore">SNDMORE</code></td>
<td>
<p>ZMQ socket options; see zmq.h for details.</p>
</td></tr>
<tr><td><code id="ZMQ+2B20Control+2B20Functions_+3A_affinity">AFFINITY</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_identity">IDENTITY</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_subscribe">SUBSCRIBE</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_unsubscribe">UNSUBSCRIBE</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_rate">RATE</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_recovery_ivl">RECOVERY_IVL</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_sndbuf">SNDBUF</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_rcvbuf">RCVBUF</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_rcvmore">RCVMORE</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_fd">FD</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_events">EVENTS</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_type">TYPE</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_linger">LINGER</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_reconnect_ivl">RECONNECT_IVL</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_backlog">BACKLOG</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_reconnect_ivl_max">RECONNECT_IVL_MAX</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_maxmsgsize">MAXMSGSIZE</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_sndhwm">SNDHWM</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_rcvhwm">RCVHWM</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_multicast_hops">MULTICAST_HOPS</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_rcvtimeo">RCVTIMEO</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_sndtimeo">SNDTIMEO</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_last_endpoint">LAST_ENDPOINT</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_router_mandatory">ROUTER_MANDATORY</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_tcp_keepalive">TCP_KEEPALIVE</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_tcp_keepalive_cnt">TCP_KEEPALIVE_CNT</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_tcp_keepalive_idle">TCP_KEEPALIVE_IDLE</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_tcp_keepalive_intvl">TCP_KEEPALIVE_INTVL</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_tcp_accept_filter">TCP_ACCEPT_FILTER</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_immediate">IMMEDIATE</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_xpub_verbose">XPUB_VERBOSE</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_router_raw">ROUTER_RAW</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_ipv6">IPV6</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_mechanism">MECHANISM</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_plain_server">PLAIN_SERVER</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_plain_username">PLAIN_USERNAME</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_plain_password">PLAIN_PASSWORD</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_curve_server">CURVE_SERVER</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_curve_publickey">CURVE_PUBLICKEY</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_curve_secretkey">CURVE_SECRETKEY</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_curve_serverkey">CURVE_SERVERKEY</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_probe_router">PROBE_ROUTER</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_req_correlate">REQ_CORRELATE</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_req_relaxed">REQ_RELAXED</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_conflate">CONFLATE</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_zap_domain">ZAP_DOMAIN</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_router_handover">ROUTER_HANDOVER</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_tos">TOS</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_ipc_filter_pid">IPC_FILTER_PID</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_ipc_filter_uid">IPC_FILTER_UID</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_ipc_filter_gid">IPC_FILTER_GID</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_connect_rid">CONNECT_RID</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_gssapi_server">GSSAPI_SERVER</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_gssapi_principal">GSSAPI_PRINCIPAL</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_gssapi_service_principal">GSSAPI_SERVICE_PRINCIPAL</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_gssapi_plaintext">GSSAPI_PLAINTEXT</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_handshake_ivl">HANDSHAKE_IVL</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_identity_fd">IDENTITY_FD</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_socks_proxy">SOCKS_PROXY</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_xpub_nodrop">XPUB_NODROP</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_blocky">BLOCKY</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_xpub_manual">XPUB_MANUAL</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_xpub_welcome_msg">XPUB_WELCOME_MSG</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_stream_notify">STREAM_NOTIFY</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_invert_matching">INVERT_MATCHING</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_heartbeat_ivl">HEARTBEAT_IVL</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_heartbeat_ttl">HEARTBEAT_TTL</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_heartbeat_timeout">HEARTBEAT_TIMEOUT</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_xpub_verboser">XPUB_VERBOSER</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_connect_timeout">CONNECT_TIMEOUT</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_tcp_maxrt">TCP_MAXRT</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_thread_safe">THREAD_SAFE</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_multicast_maxtpdu">MULTICAST_MAXTPDU</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_vmci_buffer_size">VMCI_BUFFER_SIZE</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_vmci_buffer_min_size">VMCI_BUFFER_MIN_SIZE</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_vmci_buffer_max_size">VMCI_BUFFER_MAX_SIZE</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_vmci_connect_timeout">VMCI_CONNECT_TIMEOUT</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_use_fd">USE_FD</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_gssapi_principal_nametype">GSSAPI_PRINCIPAL_NAMETYPE</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_gssapi_service_principal_nametype">GSSAPI_SERVICE_PRINCIPAL_NAMETYPE</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_bindtodevice">BINDTODEVICE</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_zap_enforce_domain">ZAP_ENFORCE_DOMAIN</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_loopback_fastpath">LOOPBACK_FASTPATH</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_metadata">METADATA</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_multicast_loop">MULTICAST_LOOP</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_router_notify">ROUTER_NOTIFY</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_xpub_manual_last_value">XPUB_MANUAL_LAST_VALUE</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_socks_username">SOCKS_USERNAME</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_socks_password">SOCKS_PASSWORD</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_in_batch_size">IN_BATCH_SIZE</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_out_batch_size">OUT_BATCH_SIZE</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_wss_key_pem">WSS_KEY_PEM</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_wss_cert_pem">WSS_CERT_PEM</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_wss_trust_pem">WSS_TRUST_PEM</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_wss_hostname">WSS_HOSTNAME</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_wss_trust_system">WSS_TRUST_SYSTEM</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_only_first_subscribe">ONLY_FIRST_SUBSCRIBE</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_reconnect_stop">RECONNECT_STOP</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_hello_msg">HELLO_MSG</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_disconnect_msg">DISCONNECT_MSG</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_priority">PRIORITY</code></td>
<td>
<p>ZMQ socket options; see zmq.h for details.</p>
</td></tr>
<tr><td><code id="ZMQ+2B20Control+2B20Functions_+3A_pair">PAIR</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_pub">PUB</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_sub">SUB</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_req">REQ</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_rep">REP</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_dealer">DEALER</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_router">ROUTER</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_pull">PULL</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_push">PUSH</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_xpub">XPUB</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_xsub">XSUB</code>, <code id="ZMQ+2B20Control+2B20Functions_+3A_stream">STREAM</code></td>
<td>
<p>ZMQ socket types; see zmq.h for details.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>.
</p>


<h3>References</h3>

<p>ZeroMQ/4.1.0 API Reference:
<a href="https://libzmq.readthedocs.io/en/zeromq4-1/">https://libzmq.readthedocs.io/en/zeromq4-1/</a>
</p>
<p>Programming with Big Data in R Website: <a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.pbd_env">.pbd_env</a></code>.
</p>

<hr>
<h2 id='ZMQ+20Flags'>ZMQ Flags</h2><span id='topic+ZMQ+20Flags'></span><span id='topic+get.zmq.ldflags'></span><span id='topic+get.zmq.cppflags'></span><span id='topic+test.load.zmq'></span><span id='topic+get.pbdZMQ.ldflags'></span>

<h3>Description</h3>

<p>ZMQ Flags
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.zmq.ldflags(arch = "", package = "pbdZMQ")

get.zmq.cppflags(arch = "", package = "pbdZMQ")

test.load.zmq(arch = "", package = "pbdZMQ")

get.pbdZMQ.ldflags(arch = "", package = "pbdZMQ")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ZMQ+2B20Flags_+3A_arch">arch</code></td>
<td>
<p>&rdquo; (default) for non-windows or '/i386' and '/ix64' for windows</p>
</td></tr>
<tr><td><code id="ZMQ+2B20Flags_+3A_package">package</code></td>
<td>
<p>the pbdZMQ package</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>get.zmq.cppflags()</code> gets CFLAGS or CPPFLAGS
</p>
<p><code>get.zmq.ldflags()</code> gets LDFLAGS for libzmq.so, libzmq.dll, or libzmq.*.dylib
</p>
<p><code>get.pbdZMQ.ldflags()</code> gets LDFLAGS for pbdZMQ.so or pbdZMQ.dll
</p>
<p><code>test.load.zmq()</code> tests load libzmq and pbdZMQ shared libraries
</p>


<h3>Value</h3>

<p>flags to compile and link with ZMQ.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen <a href="mailto:wccsnow@gmail.com">wccsnow@gmail.com</a>.
</p>


<h3>References</h3>

<p>ZeroMQ/4.1.0 API Reference:
<a href="https://libzmq.readthedocs.io/en/zeromq4-1/">https://libzmq.readthedocs.io/en/zeromq4-1/</a>
</p>
<p>Programming with Big Data in R Website: <a href="https://pbdr.org/">https://pbdr.org/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
get.zmq.cppflags(arch = '/i386')
get.zmq.ldflags(arch = '/x64')
get.pbdZMQ.ldflags(arch = '/x64')
test.load.zmq(arch = '/x64')

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
