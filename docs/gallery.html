<!DOCTYPE html><html lang="en"><head><title>Help for package gallery</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gallery}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#binomial_matrix'><p>Create binomial matrix</p></a></li>
<li><a href='#cauchy_matrix'><p>Create Cauchy matrix</p></a></li>
<li><a href='#chebspec'><p>Create Chebyshev spectral differentiation matrix</p></a></li>
<li><a href='#chebvand'><p>Creating Vandermonde-like matrix for the Chebyshev polynomials</p></a></li>
<li><a href='#chow'><p>Creating singular Toeplitz lower Hessenberg matrix</p></a></li>
<li><a href='#circul'><p>Create circulant matrix</p></a></li>
<li><a href='#clement'><p>Create Clement tridiagonal matrix with zero diagonal entries</p></a></li>
<li><a href='#compar'><p>Create comparison matrix <code>A</code></p></a></li>
<li><a href='#cycol'><p>Create matrix <code>A</code> whose columns repeat cyclically</p></a></li>
<li><a href='#dorr'><p>Create Dorr matrix</p></a></li>
<li><a href='#dramadah'><p>Create anti-Hadamard matrix <code>A</code></p></a></li>
<li><a href='#fiedler'><p>Create Fiedler matrix</p></a></li>
<li><a href='#forsythe'><p>Create Forsythe matrix or perturbed Jordan block</p></a></li>
<li><a href='#frank'><p>Frank matrix of order <code>N</code></p></a></li>
<li><a href='#grcar'><p>Create Toeplitz matrix with sensitive eigenvalues</p></a></li>
<li><a href='#hanowa'><p>Hanowa matrix</p></a></li>
<li><a href='#invol'><p>Involutory matrix (a matrix that is its own inverse)</p></a></li>
<li><a href='#jordbloc'><p>Create Jordan block matrix</p></a></li>
<li><a href='#lauchli'><p>Create Lauchli Matrix</p></a></li>
<li><a href='#lehmer'><p>Create Lehmer matrix</p></a></li>
<li><a href='#leslie'><p>Create Leslie population model matrix</p></a></li>
<li><a href='#minij'><p>Symmetric positive definite matrix <code>MIN(i,j)</code></p></a></li>
<li><a href='#spdiags'><p>Create sparse diagonal matrix</p></a></li>
<li><a href='#tridiag'><p>Create sparse tridiagonal matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Generate Test Matrices for Numerical Experiments</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Hsiao &lt;thomas.hsiao@emory.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Generates a variety of structured test matrices commonly used in numerical linear algebra and computational experiments. Includes well-known matrices for benchmarking and testing the performance, stability, and accuracy of linear algebra algorithms. Inspired by 'MATLAB' 'gallery' functions.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix, pracma (&ge; 2.2.5)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.1.0), knitr, rmarkdown</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-25 23:29:40 UTC; thsiao3</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Hsiao <a href="https://orcid.org/0009-0005-7848-7992"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-26 13:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='binomial_matrix'>Create binomial matrix</h2><span id='topic+binomial_matrix'></span>

<h3>Description</h3>

<p>Binomial matrix: an N-by-N multiple of an involutory matrix with
integer entries such that $A^2 = 2^(N-1)*I_N$
Thus B = A*2^((1-N)/2) is involutory, that is B^2 = EYE(N)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binomial_matrix(n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="binomial_matrix_+3A_n">n</code></td>
<td>
<p>row dimension</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a binomial matrix, which is a multiple of involutory matrix
</p>

<hr>
<h2 id='cauchy_matrix'>Create Cauchy matrix</h2><span id='topic+cauchy_matrix'></span>

<h3>Description</h3>

<p>Arguments <code>x</code> and <code>y</code> are vectors of length <code>n</code>.
<code>C[i,j] = 1 / (x[i] + y[j])</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cauchy_matrix(x, y = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cauchy_matrix_+3A_x">x</code></td>
<td>
<p>vector of length n</p>
</td></tr>
<tr><td><code id="cauchy_matrix_+3A_y">y</code></td>
<td>
<p>vector of length n</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a Cauchy matrix
</p>

<hr>
<h2 id='chebspec'>Create Chebyshev spectral differentiation matrix</h2><span id='topic+chebspec'></span>

<h3>Description</h3>

<p>Chebyshev spectral differentiation matrix of order <code>n</code>. <code>k</code> determines
the character of the output matrix. For either form, the eigenvector matrix is ill-conditioned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chebspec(n, k = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chebspec_+3A_n">n</code></td>
<td>
<p>order of the matrix.</p>
</td></tr>
<tr><td><code id="chebspec_+3A_k">k</code></td>
<td>
<p><code>k=0</code> is the default, no boundary conditions. The matrix is similar to a Jordan block
of size <code>n</code> with eigenvalue 0. If <code>k=1</code>, the matrix is nonsingular
and well-conditioned, and its eigenvalues have negative real parts.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Chebyshev spectral differentiation matrix
</p>

<hr>
<h2 id='chebvand'>Creating Vandermonde-like matrix for the Chebyshev polynomials</h2><span id='topic+chebvand'></span>

<h3>Description</h3>

<p>Produces the (primal) Chebyshev Vandermonde matrix based on
the points <code>p</code>. <code>C[i,j] = T_{i-1}p[j]</code>, where <code>T_{i-1}</code> is the Chebyshev
polynomial of degree <code>i-1</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chebvand(p, m = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chebvand_+3A_p">p</code></td>
<td>
<p>points to evaluate. If a scalar, then <code>p</code> equally spaced points
on <code>[0,1]</code> are used.</p>
</td></tr>
<tr><td><code id="chebvand_+3A_m">m</code></td>
<td>
<p>number of rows of the matrix. <code>chebvand(p, m)</code> is the rectangular version of
<code>chebvand(p)</code> with <code>m</code> rows.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vandermonde-like matrix for the Chebyshev polynomials
</p>

<hr>
<h2 id='chow'>Creating singular Toeplitz lower Hessenberg matrix</h2><span id='topic+chow'></span>

<h3>Description</h3>

<p>returns matrix <code>A = H(alpha) + delta * EYE</code>, such that
<code>H[i,j] = alpha^(i-j+1)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chow(n, alpha = 1, delta = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chow_+3A_n">n</code></td>
<td>
<p>order of the matrix</p>
</td></tr>
<tr><td><code id="chow_+3A_alpha">alpha</code></td>
<td>
<p>defaults to 1</p>
</td></tr>
<tr><td><code id="chow_+3A_delta">delta</code></td>
<td>
<p>defaults to 0</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Singular Toeplitz lower Hessenberg matrix
</p>

<hr>
<h2 id='circul'>Create circulant matrix</h2><span id='topic+circul'></span>

<h3>Description</h3>

<p>Each row is obtained from the previous by cyclically permuting the
entries one step forward. A special Toeplitz matrix in which diagonals &quot;wrap around&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circul(v)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="circul_+3A_v">v</code></td>
<td>
<p>first row of the matrix. If <code>v</code> is a scalar, then <code>C = circul(1:v)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a circulant matrix whose first row is the vector <code>v</code>
</p>

<hr>
<h2 id='clement'>Create Clement tridiagonal matrix with zero diagonal entries</h2><span id='topic+clement'></span>

<h3>Description</h3>

<p>Returns an <code>n</code>-by-<code>n</code> tridiagonal matrix with zeros on the
main diagonal. For <code>k=0</code>, <code>A</code> is nonsymmetric. For <code>k=1, A</code> is
symmetric
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clement(n, k = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clement_+3A_n">n</code></td>
<td>
<p>order of matrix</p>
</td></tr>
<tr><td><code id="clement_+3A_k">k</code></td>
<td>
<p>0 indicates symmetric matrix, 1 asymmetric</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Clement tridiagonal matrix with zero diagonal entries
</p>

<hr>
<h2 id='compar'>Create comparison matrix <code>A</code></h2><span id='topic+compar'></span>

<h3>Description</h3>

<p>For <code>k=0</code>, if <code>i==j</code>, $A[i,j]=abs(B[i,j])$ and
<code>A[i,j]=-abs(B[i,j])</code> otherwise. For <code>k=1</code>, <code>A</code> replaces each
diagonal element of <code>B</code> with its absolute value, and replaces each
off-diagonal with the negative of the largest absolute value off-diagonal
in the same row.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compar(B, k = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compar_+3A_b">B</code></td>
<td>
<p>input matrix</p>
</td></tr>
<tr><td><code id="compar_+3A_k">k</code></td>
<td>
<p>decides what matrix to return</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Comparison matrix
</p>

<hr>
<h2 id='cycol'>Create matrix <code>A</code> whose columns repeat cyclically</h2><span id='topic+cycol'></span>

<h3>Description</h3>

<p>Returns an <code>n</code>-by-<code>n</code> matrix with cyclically repeating columns
where one cycle consists of the columns defined by <code>randn(n,k)</code>. Thus, the
rank of matrix <code>A</code> cannot exceed <code>k</code>, and <code>k</code> must be scalar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cycol(n, k, m = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cycol_+3A_n">n</code></td>
<td>
<p>number of columns of matrix</p>
</td></tr>
<tr><td><code id="cycol_+3A_k">k</code></td>
<td>
<p>upper limit of rank</p>
</td></tr>
<tr><td><code id="cycol_+3A_m">m</code></td>
<td>
<p>number of rows of matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix whose columns repeat cyclically
</p>

<hr>
<h2 id='dorr'>Create Dorr matrix</h2><span id='topic+dorr'></span>

<h3>Description</h3>

<p>Returns a <code>n</code>-by-<code>n</code> row diagonally dominant,
tridiagonal matrix that is ill-conditioned for small nonnegative values
of <code>theta</code>. The default value of <code>theta</code> is 0.01.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dorr(n, theta = 0.01)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dorr_+3A_n">n</code></td>
<td>
<p>order of matrix</p>
</td></tr>
<tr><td><code id="dorr_+3A_theta">theta</code></td>
<td>
<p>determines conditionality. Ill-conditioned when theta is nonnegative.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dorr matrix of class 'dgcMatrix'.
</p>

<hr>
<h2 id='dramadah'>Create anti-Hadamard matrix <code>A</code></h2><span id='topic+dramadah'></span>

<h3>Description</h3>

<p>Returns a <code>n</code>-by-<code>n</code> nonsingular matrix of 0's and 1's.
With large determinant or inverse. If <code>k=1</code>, <code>A</code> is Toeplitz and <code>abs(det(A))=1</code>.
If <code>k=2</code>, <code>A</code> is upper triangular and Toeplitz. If <code>k=3</code>, <code>A</code> has maximal
determinant among (0,1) lower Hessenberg matrices. Also is Toeplitz.
</p>
<p>Also known as an anti-Hadamard matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dramadah(n, k = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dramadah_+3A_n">n</code></td>
<td>
<p>order of matrix</p>
</td></tr>
<tr><td><code id="dramadah_+3A_k">k</code></td>
<td>
<p>decides type of matrix returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of zeros and ones
</p>

<hr>
<h2 id='fiedler'>Create Fiedler matrix</h2><span id='topic+fiedler'></span>

<h3>Description</h3>

<p>Fiedler matrix that has a dominant positive eigenvalue and all others are negative
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fiedler(c)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fiedler_+3A_c">c</code></td>
<td>
<p>N-vector. If <code>c</code> is a scalar, then returns fiedler(1:c)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a symmetric dense matrix A with a dominant positive eigenvalue and all others are negative.
</p>

<hr>
<h2 id='forsythe'>Create Forsythe matrix or perturbed Jordan block</h2><span id='topic+forsythe'></span>

<h3>Description</h3>

<p>Returns a <code>n</code>-by-<code>n</code> matrix equal to the Jordan block with
eigenvalue <code>lambda</code>, except that <code>A[n,1]=alpha</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forsythe(n, alpha = .Machine$double.eps, lambda = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="forsythe_+3A_n">n</code></td>
<td>
<p>order of matrix</p>
</td></tr>
<tr><td><code id="forsythe_+3A_alpha">alpha</code></td>
<td>
<p>value of perturbation at <code>A[n,1]</code></p>
</td></tr>
<tr><td><code id="forsythe_+3A_lambda">lambda</code></td>
<td>
<p>eigenvalue of Jordan block</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Forsythe matrix or perturbed Jordan block
</p>

<hr>
<h2 id='frank'>Frank matrix of order <code>N</code></h2><span id='topic+frank'></span>

<h3>Description</h3>

<p>Frank matrix of order <code>N</code>. It is upper Hessenberg with
determinant 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frank(n, k = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="frank_+3A_n">n</code></td>
<td>
<p>order of the matrix</p>
</td></tr>
<tr><td><code id="frank_+3A_k">k</code></td>
<td>
<p>If k is 1, the elements are reflected about the anti-diagonal.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Frank matrix with ill-conditioned eigenvalues.
</p>

<hr>
<h2 id='grcar'>Create Toeplitz matrix with sensitive eigenvalues</h2><span id='topic+grcar'></span>

<h3>Description</h3>

<p>Eigenvalues are sensitive.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grcar(n, k = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grcar_+3A_n">n</code></td>
<td>
<p>dimension of the square matrix</p>
</td></tr>
<tr><td><code id="grcar_+3A_k">k</code></td>
<td>
<p>number of superdiagonals of ones</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>n</code>-by-<code>n</code> Toeplitz matrix with -1 on subdiagonal, 1 on diagonal, and <code>k</code> superdiagionals of 1s.
</p>

<hr>
<h2 id='hanowa'>Hanowa matrix</h2><span id='topic+hanowa'></span>

<h3>Description</h3>

<p>Matrix whose eigenvalues lie on vertical plane in complex plane.
Returns a 2-by-2 block matrix with four <code>n/2</code> by <code>n/2</code> blocks. <code>n</code>
must be an even integer.
</p>
<p><code>[d*eye(m) -diag(1:m),</code>
<code>diag(1:m) d*eye(m)]</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hanowa(n, d = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hanowa_+3A_n">n</code></td>
<td>
<p>order of matrix</p>
</td></tr>
<tr><td><code id="hanowa_+3A_d">d</code></td>
<td>
<p>value of main diagonal</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix whose eigenvalues lie on a vertical line in the complex plane.
</p>

<hr>
<h2 id='invol'>Involutory matrix (a matrix that is its own inverse)</h2><span id='topic+invol'></span>

<h3>Description</h3>

<p>a <code>n</code>-by<code>n</code> involutory matrix and ill-conditioned.
It is a diagonally scaled version of a Hilbert matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invol(n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="invol_+3A_n">n</code></td>
<td>
<p>order of matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Involutory matrix (a matrix that is its own inverse).
</p>

<hr>
<h2 id='jordbloc'>Create Jordan block matrix</h2><span id='topic+jordbloc'></span>

<h3>Description</h3>

<p>Returns a <code>n</code>-by-<code>n</code> Jordan block with eigenvalue
<code>lambda</code>. The default is 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jordbloc(n, lambda = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jordbloc_+3A_n">n</code></td>
<td>
<p>order of matrix</p>
</td></tr>
<tr><td><code id="jordbloc_+3A_lambda">lambda</code></td>
<td>
<p>eigenvalue of Jordan block</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Jordan block matrix
</p>

<hr>
<h2 id='lauchli'>Create Lauchli Matrix</h2><span id='topic+lauchli'></span>

<h3>Description</h3>

<p>the (N + 1) x (N) matrix [ones(1,n); mu*eye(n)]. Well-known example in least squares of the
danger of forming t(A) 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lauchli(n, mu = NULL, sparse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lauchli_+3A_n">n</code></td>
<td>
<p>number of columns</p>
</td></tr>
<tr><td><code id="lauchli_+3A_mu">mu</code></td>
<td>
<p>constant applied to identity</p>
</td></tr>
<tr><td><code id="lauchli_+3A_sparse">sparse</code></td>
<td>
<p>whether matrix should be sparse</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Lauchli rectangular matrix.
</p>

<hr>
<h2 id='lehmer'>Create Lehmer matrix</h2><span id='topic+lehmer'></span>

<h3>Description</h3>

<p>the symmetric positive-definite matrix such that A[i,j] = i/j, for j &gt;= i
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lehmer(n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lehmer_+3A_n">n</code></td>
<td>
<p>order of matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Lehmer symmetric positive definite matrix.
</p>

<hr>
<h2 id='leslie'>Create Leslie population model matrix</h2><span id='topic+leslie'></span>

<h3>Description</h3>

<p>N by N matrix from Leslie population model with average birth and survival rates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>leslie(a, b = NULL, sparse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="leslie_+3A_a">a</code></td>
<td>
<p>average birth numbers (first row)</p>
</td></tr>
<tr><td><code id="leslie_+3A_b">b</code></td>
<td>
<p>survival rates (subdiagonal)</p>
</td></tr>
<tr><td><code id="leslie_+3A_sparse">sparse</code></td>
<td>
<p>whether to return a sparse matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>N by N Leslie population model matrix
</p>

<hr>
<h2 id='minij'>Symmetric positive definite matrix <code>MIN(i,j)</code></h2><span id='topic+minij'></span>

<h3>Description</h3>

<p>The <code>N</code>-by-<code>N</code> SPD matrix with <code>A[i,j]=min(i,j)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minij(n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="minij_+3A_n">n</code></td>
<td>
<p>order of the matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Symmetric positive definite matrix with entries <code>A[i,j]=min(i,j)</code>
</p>

<hr>
<h2 id='spdiags'>Create sparse diagonal matrix</h2><span id='topic+spdiags'></span>

<h3>Description</h3>

<p>Creates a sparse representation of multiple diagonal matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spdiags(A, d, m, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spdiags_+3A_a">A</code></td>
<td>
<p>matrix where columns correspond to the desired diagonals</p>
</td></tr>
<tr><td><code id="spdiags_+3A_d">d</code></td>
<td>
<p>indices of the diagonals to be filled in. 0 is main diagonal. -1
is first subdiagonal and +1 is first superdiagonal.</p>
</td></tr>
<tr><td><code id="spdiags_+3A_m">m</code></td>
<td>
<p>row dim</p>
</td></tr>
<tr><td><code id="spdiags_+3A_n">n</code></td>
<td>
<p>col dim</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sparse diagonal matrix of class 'dgcMatrix'
</p>

<hr>
<h2 id='tridiag'>Create sparse tridiagonal matrix</h2><span id='topic+tridiag'></span>

<h3>Description</h3>

<p>Create a sparse tridiagonal matrix of dgcMatrix class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tridiag(n, x = NULL, y = NULL, z = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tridiag_+3A_n">n</code></td>
<td>
<p>dimension of the square matrix</p>
</td></tr>
<tr><td><code id="tridiag_+3A_x">x</code></td>
<td>
<p>subdiagonal (-1)</p>
</td></tr>
<tr><td><code id="tridiag_+3A_y">y</code></td>
<td>
<p>diagonal (0)</p>
</td></tr>
<tr><td><code id="tridiag_+3A_z">z</code></td>
<td>
<p>superdiagonal (+1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Sparse tridiagonal matrix of class 'dgcMatrix'
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
