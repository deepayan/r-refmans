<!DOCTYPE html><html><head><title>Help for package EmbedSOM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {EmbedSOM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ClusterPalette'><p>An acceptable cluster color palette</p></a></li>
<li><a href='#EmbedSOM'><p>Process the cells with SOM into a nice embedding</p></a></li>
<li><a href='#ExprColors'><p>Generate colors for multi-color marker expression labeling in a single plot</p></a></li>
<li><a href='#ExpressionGradient'><p>The ggplot2 scale gradient from ExpressionPalette.</p></a></li>
<li><a href='#ExpressionPalette'><p>Marker expression palette generator based off ColorBrewer's RdYlBu,</p>
only better for plotting of half-transparent cells</a></li>
<li><a href='#GQTSOM'><p>Train a Growing Quadtree Self-Organizing Map</p></a></li>
<li><a href='#GraphCoords'><p>Add Kamada-Kawai-generated embedding coordinates to the map</p></a></li>
<li><a href='#Initialize_PCA'><p>Create a grid from first 2 PCA components</p></a></li>
<li><a href='#kMeansMap'><p>Create a map from k-Means clusters</p></a></li>
<li><a href='#kNNCoords'><p>Add KNN-topology-based embedding coordinates to the map</p></a></li>
<li><a href='#MapDataToCodes'><p>Assign nearest node to each datapoint</p></a></li>
<li><a href='#MSTCoords'><p>Add MST-style embedding coordinates to the map</p></a></li>
<li><a href='#NormalizeColor'><p>Helper for computing colors for embedding plots</p></a></li>
<li><a href='#PlotData'><p>Export a data frame for plotting with marker intensities and density.</p></a></li>
<li><a href='#PlotDefault'><p>Default plot</p></a></li>
<li><a href='#PlotEmbed'><p>Helper function for plotting the embedding</p></a></li>
<li><a href='#PlotGG'><p>Wrap PlotData result in ggplot object.</p></a></li>
<li><a href='#PlotId'><p>Identity on whatever</p></a></li>
<li><a href='#RandomMap'><p>Create a map by randomly selecting points</p></a></li>
<li><a href='#SOM'><p>Build a self-organizing map</p></a></li>
<li><a href='#tSNECoords'><p>Add tSNE-based coordinates to a map</p></a></li>
<li><a href='#UMAPCoords'><p>Add UMAP-based coordinates to a map</p></a></li>
<li><a href='#UMatrixCoords'><p>Add U-Matrix-optimized embedding coordinates to the map</p></a></li>
<li><a href='#uwotCoords'><p>Add UMAP-based coordinates to a map, using the 'uwot' package</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>2.1.2</td>
</tr>
<tr>
<td>Title:</td>
<td>Fast Embedding Guided by Self-Organizing Map</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>Imports:</td>
<td>FNN, ggplot2, igraph, Matrix, Rtsne, umap, uwot</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a smooth mapping of multidimensional points into
    low-dimensional space defined by a self-organizing map. Designed to work
    with 'FlowSOM' and flow-cytometry use-cases. See Kratochvil et al. (2019)
    &lt;<a href="https://doi.org/10.12688%2Ff1000research.21642.1">doi:10.12688/f1000research.21642.1</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/exaexa/EmbedSOM">https://github.com/exaexa/EmbedSOM</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-07-05 10:04:32 UTC; exa</td>
</tr>
<tr>
<td>Author:</td>
<td>Mirek Kratochvil [aut, cre],
  Sofie Van Gassen [cph],
  Britt Callebaut [cph],
  Yvan Saeys [cph],
  Ron Wehrens [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mirek Kratochvil &lt;exa.exa@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-07-05 10:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ClusterPalette'>An acceptable cluster color palette</h2><span id='topic+ClusterPalette'></span>

<h3>Description</h3>

<p>An acceptable cluster color palette
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ClusterPalette(n, vcycle = c(1, 0.7), scycle = c(0.7, 1), alpha = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ClusterPalette_+3A_n">n</code></td>
<td>
<p>How many colors to generate</p>
</td></tr>
<tr><td><code id="ClusterPalette_+3A_vcycle">vcycle</code>, <code id="ClusterPalette_+3A_scycle">scycle</code></td>
<td>
<p>Small vectors with cycles of saturation/value for hsv</p>
</td></tr>
<tr><td><code id="ClusterPalette_+3A_alpha">alpha</code></td>
<td>
<p>Opacity of the colors</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>EmbedSOM::ClusterPalette(10)
</code></pre>

<hr>
<h2 id='EmbedSOM'>Process the cells with SOM into a nice embedding</h2><span id='topic+EmbedSOM'></span>

<h3>Description</h3>

<p>Process the cells with SOM into a nice embedding
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EmbedSOM(
  data = NULL,
  map = NULL,
  fsom = NULL,
  smooth = NULL,
  k = NULL,
  adjust = NULL,
  importance = NULL,
  coordsFn = NULL,
  coords = NULL,
  emcoords = NULL,
  emcoords.pow = 1,
  parallel = F,
  threads = if (parallel) 0 else 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EmbedSOM_+3A_data">data</code></td>
<td>
<p>Data matrix with points that optionally overrides the one from <code>fsom$data</code></p>
</td></tr>
<tr><td><code id="EmbedSOM_+3A_map">map</code></td>
<td>
<p>Map object in FlowSOM format, to optionally override <code>fsom$map</code></p>
</td></tr>
<tr><td><code id="EmbedSOM_+3A_fsom">fsom</code></td>
<td>
<p>FlowSOM object with a built SOM (used if data or map are missing)</p>
</td></tr>
<tr><td><code id="EmbedSOM_+3A_smooth">smooth</code></td>
<td>
<p>Produce smoother (positive values) or more rough approximation (negative values).</p>
</td></tr>
<tr><td><code id="EmbedSOM_+3A_k">k</code></td>
<td>
<p>How many neighboring landmarks (e.g. SOM nodes) to take into the whole computation</p>
</td></tr>
<tr><td><code id="EmbedSOM_+3A_adjust">adjust</code></td>
<td>
<p>How much non-local information to remove from the approximation</p>
</td></tr>
<tr><td><code id="EmbedSOM_+3A_importance">importance</code></td>
<td>
<p>Scaling of the landmarks, will be used to scale the incoming data (should be same as used for training the SOM or to select the landmarks)</p>
</td></tr>
<tr><td><code id="EmbedSOM_+3A_coordsfn">coordsFn</code></td>
<td>
<p>A coordinates-generating function (e.g. <code><a href="#topic+tSNECoords">tSNECoords()</a></code>) that overrides the existing <code>map$grid</code>.</p>
</td></tr>
<tr><td><code id="EmbedSOM_+3A_coords">coords</code></td>
<td>
<p>A matrix of embedding-space coordinates that correspond to <code>map$codes</code> (i.e. the &quot;embedded landmarks&quot;). Overrides <code>map$grid</code> if not NULL.</p>
</td></tr>
<tr><td><code id="EmbedSOM_+3A_emcoords">emcoords</code></td>
<td>
<p>Provided for backwards compatibility, will be removed. Use <code>coords</code> and <code>coordsFn</code> instead.</p>
</td></tr>
<tr><td><code id="EmbedSOM_+3A_emcoords.pow">emcoords.pow</code></td>
<td>
<p>Provided for backwards compatibility, will be removed. Use a parametrized <code>coordsFn</code> instead.</p>
</td></tr>
<tr><td><code id="EmbedSOM_+3A_parallel">parallel</code></td>
<td>
<p>Boolean flag whether the computation should be parallelized (this flag is just a nice name for <code>threads</code> and does not do anything directly &ndash; default FALSE sets threads=1, TRUE sets threads=0)</p>
</td></tr>
<tr><td><code id="EmbedSOM_+3A_threads">threads</code></td>
<td>
<p>Number of threads used for computation, 0 chooses hardware concurrency, 1 (default) turns off parallelization.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with 2D or 3D coordinates of the embedded <code>data</code>, depending on the <code>map</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- cbind(rnorm(10000), 3*runif(10000), rexp(10000))
colnames(d) &lt;- paste0("col",1:3)
map &lt;- EmbedSOM::SOM(d, xdim=10, ydim=10)
e &lt;- EmbedSOM::EmbedSOM(data=d, map=map)
EmbedSOM::PlotEmbed(e, data=d, 'col1', pch=16)
</code></pre>

<hr>
<h2 id='ExprColors'>Generate colors for multi-color marker expression labeling in a single plot</h2><span id='topic+ExprColors'></span>

<h3>Description</h3>

<p>Generate colors for multi-color marker expression labeling in a single plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExprColors(
  exprs,
  base = exp(1),
  scale = 1,
  cutoff = 0,
  pow = NULL,
  col = ClusterPalette(dim(exprs)[2], alpha = alpha),
  nocolor = grDevices::rgb(0.75, 0.75, 0.75, alpha/2),
  alpha = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExprColors_+3A_exprs">exprs</code></td>
<td>
<p>Matrix-like object with marker expressions (extract it manually from your data)</p>
</td></tr>
<tr><td><code id="ExprColors_+3A_base">base</code>, <code id="ExprColors_+3A_scale">scale</code></td>
<td>
<p>Base(s) and scale(s) for softmax (convertible to numeric vectors of size <code>1+ncol(exprs)</code>)</p>
</td></tr>
<tr><td><code id="ExprColors_+3A_cutoff">cutoff</code></td>
<td>
<p>Gray level (expressed in sigmas of the sample distribution)</p>
</td></tr>
<tr><td><code id="ExprColors_+3A_pow">pow</code></td>
<td>
<p>Obsolete, now renamed to <code>scale</code>.</p>
</td></tr>
<tr><td><code id="ExprColors_+3A_col">col</code></td>
<td>
<p>Colors to use, defaults to colors taken from 'ClusterPalette'</p>
</td></tr>
<tr><td><code id="ExprColors_+3A_nocolor">nocolor</code></td>
<td>
<p>The color to use for sub-gray-level expression, default gray.</p>
</td></tr>
<tr><td><code id="ExprColors_+3A_alpha">alpha</code></td>
<td>
<p>Default alpha value.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- cbind(rnorm(1e5), rexp(1e5))
EmbedSOM::PlotEmbed(d, col=EmbedSOM::ExprColors(d, pow=2))
</code></pre>

<hr>
<h2 id='ExpressionGradient'>The ggplot2 scale gradient from ExpressionPalette.</h2><span id='topic+ExpressionGradient'></span>

<h3>Description</h3>

<p>The ggplot2 scale gradient from ExpressionPalette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExpressionGradient(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExpressionGradient_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="ggplot2.html#topic+scale_gradient">ggplot2::scale_color_gradientn()</a></code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(EmbedSOM)
library(ggplot2)

# simulate a simple dataset
e &lt;- cbind(rnorm(10000),rnorm(10000))

data &lt;- data.frame(Val=log(1+e[,1]^2+e[,2]^2))
PlotGG(e, data=data) +
  geom_point(aes_string(color="Val"), alpha=.5) +
  ExpressionGradient(guide=FALSE)
</code></pre>

<hr>
<h2 id='ExpressionPalette'>Marker expression palette generator based off ColorBrewer's RdYlBu,
only better for plotting of half-transparent cells</h2><span id='topic+ExpressionPalette'></span>

<h3>Description</h3>

<p>Marker expression palette generator based off ColorBrewer's RdYlBu,
only better for plotting of half-transparent cells
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExpressionPalette(n, alpha = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExpressionPalette_+3A_n">n</code></td>
<td>
<p>How many colors to generate</p>
</td></tr>
<tr><td><code id="ExpressionPalette_+3A_alpha">alpha</code></td>
<td>
<p>Opacity of the colors</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>EmbedSOM::ExpressionPalette(10)
</code></pre>

<hr>
<h2 id='GQTSOM'>Train a Growing Quadtree Self-Organizing Map</h2><span id='topic+GQTSOM'></span>

<h3>Description</h3>

<p>Train a Growing Quadtree Self-Organizing Map
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GQTSOM(
  data,
  init.dim = c(3, 3),
  target_codes = 100,
  rlen = 10,
  radius = c(sqrt(sum(init.dim^2)), 0.5),
  epochRadii = seq(radius[1], radius[2], length.out = rlen),
  coords = NULL,
  codes = NULL,
  coordsFn = NULL,
  importance = NULL,
  distf = 2,
  nhbr.distf = 2,
  noMapping = F,
  parallel = F,
  threads = if (parallel) 0 else 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GQTSOM_+3A_data">data</code></td>
<td>
<p>Input data matrix</p>
</td></tr>
<tr><td><code id="GQTSOM_+3A_init.dim">init.dim</code></td>
<td>
<p>Initial size of the SOM, default <code>c(3,3)</code></p>
</td></tr>
<tr><td><code id="GQTSOM_+3A_target_codes">target_codes</code></td>
<td>
<p>Make the SOM grow linearly to at most this amount of nodes (default <code>100</code>)</p>
</td></tr>
<tr><td><code id="GQTSOM_+3A_rlen">rlen</code></td>
<td>
<p>Number of training iterations</p>
</td></tr>
<tr><td><code id="GQTSOM_+3A_radius">radius</code></td>
<td>
<p>Start and end training radius, as in <code><a href="#topic+SOM">SOM()</a></code></p>
</td></tr>
<tr><td><code id="GQTSOM_+3A_epochradii">epochRadii</code></td>
<td>
<p>Precise radii for each epoch (must be of length <code>rlen</code>)</p>
</td></tr>
<tr><td><code id="GQTSOM_+3A_coords">coords</code></td>
<td>
<p>Quadtree coordinates of the initial SOM nodes.</p>
</td></tr>
<tr><td><code id="GQTSOM_+3A_codes">codes</code></td>
<td>
<p>Initial codebook</p>
</td></tr>
<tr><td><code id="GQTSOM_+3A_coordsfn">coordsFn</code></td>
<td>
<p>Function to generate/transform grid coordinates (e.g. <code><a href="#topic+tSNECoords">tSNECoords()</a></code>). If <code>NULL</code> (default), the grid is the grid is the 2D coordinates of GQTSOM map.</p>
</td></tr>
<tr><td><code id="GQTSOM_+3A_importance">importance</code></td>
<td>
<p>Weights of input data dimensions</p>
</td></tr>
<tr><td><code id="GQTSOM_+3A_distf">distf</code></td>
<td>
<p>Distance measure to use in input data space (1=manhattan, 2=euclidean, 3=chebyshev, 4=cosine)</p>
</td></tr>
<tr><td><code id="GQTSOM_+3A_nhbr.distf">nhbr.distf</code></td>
<td>
<p>Distance measure to use in output space (as in <code>distf</code>)</p>
</td></tr>
<tr><td><code id="GQTSOM_+3A_nomapping">noMapping</code></td>
<td>
<p>If <code>TRUE</code>, do not compute the assignment of input data to SOM nodes</p>
</td></tr>
<tr><td><code id="GQTSOM_+3A_parallel">parallel</code></td>
<td>
<p>Parallelize the training by setting appropriate <code>threads</code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="GQTSOM_+3A_threads">threads</code></td>
<td>
<p>Number of threads to use for training. Defaults to 0 (chooses maximum available hardware threads) if <code>parallel=TRUE</code> or 1 (single thread) if <code>parallel=FALSE</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='GraphCoords'>Add Kamada-Kawai-generated embedding coordinates to the map</h2><span id='topic+GraphCoords'></span>

<h3>Description</h3>

<p>This uses a complete graph on the map codebook, which brings overcrowding
problems. It is therefore useful to transform the distances for avoiding that
(e.g. by exponentiating them slightly).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GraphCoords(
  dim = NULL,
  dist.method = NULL,
  distFn = function(x) x,
  layoutFn = igraph::layout_with_kk
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GraphCoords_+3A_dim">dim</code></td>
<td>
<p>Dimension of the result (passed to <code>layoutFn</code>)</p>
</td></tr>
<tr><td><code id="GraphCoords_+3A_dist.method">dist.method</code></td>
<td>
<p>The method to compute distances, passed to <code><a href="stats.html#topic+dist">stats::dist()</a></code> as parameter <code>method</code></p>
</td></tr>
<tr><td><code id="GraphCoords_+3A_distfn">distFn</code></td>
<td>
<p>Custom transformation function of the distance matrix</p>
</td></tr>
<tr><td><code id="GraphCoords_+3A_layoutfn">layoutFn</code></td>
<td>
<p>iGraph-compatible graph layouting function (default <a href="igraph.html#topic+layout_with_kk">igraph::layout_with_kk</a>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function that transforms the map, usable as <code>coordsFn</code> parameter
</p>

<hr>
<h2 id='Initialize_PCA'>Create a grid from first 2 PCA components</h2><span id='topic+Initialize_PCA'></span>

<h3>Description</h3>

<p>Create a grid from first 2 PCA components
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Initialize_PCA(data, xdim, ydim, zdim = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Initialize_PCA_+3A_data">data</code></td>
<td>
<p>matrix in which each row represents a point</p>
</td></tr>
<tr><td><code id="Initialize_PCA_+3A_xdim">xdim</code>, <code id="Initialize_PCA_+3A_ydim">ydim</code>, <code id="Initialize_PCA_+3A_zdim">zdim</code></td>
<td>
<p>Dimensions of the SOM grid</p>
</td></tr>
</table>


<h3>Value</h3>

<p>array containing the selected selected rows
</p>

<hr>
<h2 id='kMeansMap'>Create a map from k-Means clusters</h2><span id='topic+kMeansMap'></span>

<h3>Description</h3>

<p>May give better results than 'RandomMap' on data where random sampling
is complicated.
This does not use actual kMeans clustering, but re-uses the batch version of
<code><a href="#topic+SOM">SOM()</a></code> with tiny radius (which makes it work the same as kMeans). In
consequence, the speedup of SOM function is applied here as well. Additionally,
because we don't need that amount of clustering precision, parameters &lsquo;batch=F, rlen=1&rsquo;
may give a satisfactory result very quickly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kMeansMap(data, k, coordsFn, batch = T, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kMeansMap_+3A_data">data</code></td>
<td>
<p>Input data matrix, with individual data points in rows</p>
</td></tr>
<tr><td><code id="kMeansMap_+3A_k">k</code></td>
<td>
<p>How many points to sample</p>
</td></tr>
<tr><td><code id="kMeansMap_+3A_coordsfn">coordsFn</code></td>
<td>
<p>a function to generate embedding coordinates (default none)</p>
</td></tr>
<tr><td><code id="kMeansMap_+3A_batch">batch</code></td>
<td>
<p>Use batch-SOM training (effectively kMeans, default TRUE)</p>
</td></tr>
<tr><td><code id="kMeansMap_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="#topic+SOM">SOM()</a></code>, useful e.g. for 'parallel=T' or 'rlen=5'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>map object (without the grid, if coordsFn was not specified)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- iris[,1:4]
EmbedSOM::PlotEmbed(
  EmbedSOM::EmbedSOM(
    data = d,
    map = EmbedSOM::kMeansMap(d, 10, EmbedSOM::GraphCoords())),
  pch=19, clust=iris[,5]
)
</code></pre>

<hr>
<h2 id='kNNCoords'>Add KNN-topology-based embedding coordinates to the map</h2><span id='topic+kNNCoords'></span>

<h3>Description</h3>

<p>Internally, this uses <code><a href="FNN.html#topic+get.knn">FNN::get.knn()</a></code> to compute the k-neighborhoods. That
function only supports Euclidean metric, therefore <code>kNNCoords</code> throws a warning whenever
a different metric is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kNNCoords(
  k = 4,
  dim = NULL,
  distFn = function(x) x,
  layoutFn = igraph::layout_with_kk
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kNNCoords_+3A_k">k</code></td>
<td>
<p>Size of the neighborhoods (default 4)</p>
</td></tr>
<tr><td><code id="kNNCoords_+3A_dim">dim</code></td>
<td>
<p>Dimension of the result (passed to <code>layoutFn</code>)</p>
</td></tr>
<tr><td><code id="kNNCoords_+3A_distfn">distFn</code></td>
<td>
<p>Custom transformation function of the distance matrix</p>
</td></tr>
<tr><td><code id="kNNCoords_+3A_layoutfn">layoutFn</code></td>
<td>
<p>iGraph-compatible graph layouting function (default <a href="igraph.html#topic+layout_with_kk">igraph::layout_with_kk</a>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function that transforms the map, usable as <code>coordsFn</code> parameter
</p>

<hr>
<h2 id='MapDataToCodes'>Assign nearest node to each datapoint</h2><span id='topic+MapDataToCodes'></span>

<h3>Description</h3>

<p>Assign nearest node to each datapoint
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MapDataToCodes(
  codes,
  data,
  distf = 2,
  parallel = F,
  threads = if (parallel) 0 else 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MapDataToCodes_+3A_codes">codes</code></td>
<td>
<p>matrix with nodes of the SOM</p>
</td></tr>
<tr><td><code id="MapDataToCodes_+3A_data">data</code></td>
<td>
<p>datapoints to assign</p>
</td></tr>
<tr><td><code id="MapDataToCodes_+3A_distf">distf</code></td>
<td>
<p>Distance function (1=manhattan, 2=euclidean, 3=chebyshev, 4=cosine)</p>
</td></tr>
<tr><td><code id="MapDataToCodes_+3A_threads">threads</code>, <code id="MapDataToCodes_+3A_parallel">parallel</code></td>
<td>
<p>Use parallel computation (see <code><a href="#topic+SOM">SOM()</a></code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>array with nearest node id for each datapoint
</p>

<hr>
<h2 id='MSTCoords'>Add MST-style embedding coordinates to the map</h2><span id='topic+MSTCoords'></span>

<h3>Description</h3>

<p>Add MST-style embedding coordinates to the map
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MSTCoords(
  dim = NULL,
  dist.method = NULL,
  distFn = function(x) x,
  layoutFn = igraph::layout_with_kk
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MSTCoords_+3A_dim">dim</code></td>
<td>
<p>Dimension of the result (passed to layoutFn)</p>
</td></tr>
<tr><td><code id="MSTCoords_+3A_dist.method">dist.method</code></td>
<td>
<p>The method to compute distances, passed to <code><a href="stats.html#topic+dist">stats::dist()</a></code> as parameter <code>method</code></p>
</td></tr>
<tr><td><code id="MSTCoords_+3A_distfn">distFn</code></td>
<td>
<p>Custom transformation function of the distance matrix</p>
</td></tr>
<tr><td><code id="MSTCoords_+3A_layoutfn">layoutFn</code></td>
<td>
<p>iGraph-compatible graph layouting function (default <code><a href="igraph.html#topic+layout_with_kk">igraph::layout_with_kk()</a></code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function that transforms the map, usable as <code>coordsFn</code> parameter
</p>

<hr>
<h2 id='NormalizeColor'>Helper for computing colors for embedding plots</h2><span id='topic+NormalizeColor'></span>

<h3>Description</h3>

<p>Helper for computing colors for embedding plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NormalizeColor(data, low = NULL, high = NULL, pow = 0, sds = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NormalizeColor_+3A_data">data</code></td>
<td>
<p>Vector of scalar values to normalize between 0 and 1</p>
</td></tr>
<tr><td><code id="NormalizeColor_+3A_low">low</code>, <code id="NormalizeColor_+3A_high">high</code></td>
<td>
<p>Originally quantiles for clamping the color.
Only kept for backwards compatibility, now ignored.</p>
</td></tr>
<tr><td><code id="NormalizeColor_+3A_pow">pow</code></td>
<td>
<p>The scaled data are transformed to data^(2^pow). If set to 0,
nothing happens. Positive values highlight differences in the
data closer to 1, negative values highlight differences closer to 0.</p>
</td></tr>
<tr><td><code id="NormalizeColor_+3A_sds">sds</code></td>
<td>
<p>Inverse scale factor for measured standard deviation
(greater value makes data look more extreme)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>EmbedSOM::NormalizeColor(c(1,100,500))
</code></pre>

<hr>
<h2 id='PlotData'>Export a data frame for plotting with marker intensities and density.</h2><span id='topic+PlotData'></span>

<h3>Description</h3>

<p>Export a data frame for plotting with marker intensities and density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotData(
  embed,
  fsom,
  data = fsom$data,
  cols,
  names,
  normalize = cols,
  pow = 0,
  sds = 1,
  vf = PlotId,
  density = "Density",
  densBins = 256,
  densLimit = NULL,
  fdens = sqrt
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotData_+3A_embed">embed</code>, <code id="PlotData_+3A_fsom">fsom</code>, <code id="PlotData_+3A_data">data</code>, <code id="PlotData_+3A_cols">cols</code></td>
<td>
<p>The embedding data, columns to select</p>
</td></tr>
<tr><td><code id="PlotData_+3A_names">names</code></td>
<td>
<p>Column names for output</p>
</td></tr>
<tr><td><code id="PlotData_+3A_normalize">normalize</code></td>
<td>
<p>List of columns to normalize using <code><a href="#topic+NormalizeColor">NormalizeColor()</a></code>, default all</p>
</td></tr>
<tr><td><code id="PlotData_+3A_pow">pow</code>, <code id="PlotData_+3A_sds">sds</code></td>
<td>
<p>Parameters for the normalization</p>
</td></tr>
<tr><td><code id="PlotData_+3A_vf">vf</code></td>
<td>
<p>Custom value-transforming function</p>
</td></tr>
<tr><td><code id="PlotData_+3A_density">density</code></td>
<td>
<p>Name of the density column</p>
</td></tr>
<tr><td><code id="PlotData_+3A_densbins">densBins</code></td>
<td>
<p>Number of bins for density calculation</p>
</td></tr>
<tr><td><code id="PlotData_+3A_denslimit">densLimit</code></td>
<td>
<p>Upper limit of density (prevents outliers)</p>
</td></tr>
<tr><td><code id="PlotData_+3A_fdens">fdens</code></td>
<td>
<p>Density-transforming function; default sqrt</p>
</td></tr>
</table>

<hr>
<h2 id='PlotDefault'>Default plot</h2><span id='topic+PlotDefault'></span>

<h3>Description</h3>

<p>Default plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotDefault(pch = ".", cex = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotDefault_+3A_pch">pch</code>, <code id="PlotDefault_+3A_cex">cex</code>, <code id="PlotDefault_+3A_...">...</code></td>
<td>
<p>correctly defaulted and passed to 'plot'</p>
</td></tr>
</table>

<hr>
<h2 id='PlotEmbed'>Helper function for plotting the embedding</h2><span id='topic+PlotEmbed'></span>

<h3>Description</h3>

<p>Convenience plotting function. Takes the <code>embed</code> matrix which is the output of
<code><a href="#topic+EmbedSOM">EmbedSOM()</a></code>, together with a multitude of arguments that set how the plotting
is done.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotEmbed(
  embed,
  value = 0,
  red = 0,
  green = 0,
  blue = 0,
  fr = PlotId,
  fg = PlotId,
  fb = PlotId,
  fv = PlotId,
  powr = 0,
  powg = 0,
  powb = 0,
  powv = 0,
  sdsr = 1,
  sdsg = 1,
  sdsb = 1,
  sdsv = 1,
  clust = NULL,
  nbin = 256,
  maxDens = NULL,
  fdens = sqrt,
  limit = NULL,
  alpha = NULL,
  fsom,
  data,
  col,
  cluster.colors = ClusterPalette,
  expression.colors = ExpressionPalette,
  na.color = grDevices::rgb(0.75, 0.75, 0.75, if (is.null(alpha)) 0.5 else alpha/2),
  plotf = PlotDefault,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotEmbed_+3A_embed">embed</code></td>
<td>
<p>The embedding from <code><a href="#topic+EmbedSOM">EmbedSOM()</a></code>, or generally any 2-column matrix of coordinates</p>
</td></tr>
<tr><td><code id="PlotEmbed_+3A_value">value</code></td>
<td>
<p>The column of <code>data</code> to use for coloring the plotted points</p>
</td></tr>
<tr><td><code id="PlotEmbed_+3A_red">red</code>, <code id="PlotEmbed_+3A_green">green</code>, <code id="PlotEmbed_+3A_blue">blue</code></td>
<td>
<p>The same, for individual RGB components</p>
</td></tr>
<tr><td><code id="PlotEmbed_+3A_fv">fv</code>, <code id="PlotEmbed_+3A_fr">fr</code>, <code id="PlotEmbed_+3A_fg">fg</code>, <code id="PlotEmbed_+3A_fb">fb</code></td>
<td>
<p>Functions to transform the values before they are normalized</p>
</td></tr>
<tr><td><code id="PlotEmbed_+3A_powv">powv</code>, <code id="PlotEmbed_+3A_powr">powr</code>, <code id="PlotEmbed_+3A_powg">powg</code>, <code id="PlotEmbed_+3A_powb">powb</code></td>
<td>
<p>Passed to corresponding <code><a href="#topic+NormalizeColor">NormalizeColor()</a></code> calls as <code>pow</code></p>
</td></tr>
<tr><td><code id="PlotEmbed_+3A_sdsv">sdsv</code>, <code id="PlotEmbed_+3A_sdsr">sdsr</code>, <code id="PlotEmbed_+3A_sdsg">sdsg</code>, <code id="PlotEmbed_+3A_sdsb">sdsb</code></td>
<td>
<p>Passed to <code><a href="#topic+NormalizeColor">NormalizeColor()</a></code> as <code>sds</code></p>
</td></tr>
<tr><td><code id="PlotEmbed_+3A_clust">clust</code></td>
<td>
<p>Cluster labels (used as a factor)</p>
</td></tr>
<tr><td><code id="PlotEmbed_+3A_nbin">nbin</code>, <code id="PlotEmbed_+3A_maxdens">maxDens</code>, <code id="PlotEmbed_+3A_fdens">fdens</code></td>
<td>
<p>Parameters of density calculation, see <code><a href="#topic+PlotData">PlotData()</a></code></p>
</td></tr>
<tr><td><code id="PlotEmbed_+3A_limit">limit</code></td>
<td>
<p>Low/high offset for <code><a href="#topic+NormalizeColor">NormalizeColor()</a></code> (obsolete&amp;ignored, will be removed)</p>
</td></tr>
<tr><td><code id="PlotEmbed_+3A_alpha">alpha</code></td>
<td>
<p>Default alpha value of points</p>
</td></tr>
<tr><td><code id="PlotEmbed_+3A_fsom">fsom</code></td>
<td>
<p>FlowSOM object</p>
</td></tr>
<tr><td><code id="PlotEmbed_+3A_data">data</code></td>
<td>
<p>Data matrix, taken from <code>fsom</code> parameter by default</p>
</td></tr>
<tr><td><code id="PlotEmbed_+3A_col">col</code></td>
<td>
<p>Overrides the computed point colors with exact supplied colors.</p>
</td></tr>
<tr><td><code id="PlotEmbed_+3A_cluster.colors">cluster.colors</code></td>
<td>
<p>Function to generate cluster colors, default <code><a href="#topic+ClusterPalette">ClusterPalette()</a></code></p>
</td></tr>
<tr><td><code id="PlotEmbed_+3A_expression.colors">expression.colors</code></td>
<td>
<p>Function to generate expression color scale, default <code><a href="#topic+ExpressionPalette">ExpressionPalette()</a></code></p>
</td></tr>
<tr><td><code id="PlotEmbed_+3A_na.color">na.color</code></td>
<td>
<p>Color to assign to <code>NA</code> values</p>
</td></tr>
<tr><td><code id="PlotEmbed_+3A_plotf">plotf</code></td>
<td>
<p>Plot function, defaults to <code><a href="graphics.html#topic+plot.default">graphics::plot()</a></code> slightly decorated with <code style="white-space: pre;">&#8288;pch='.', cex=1&#8288;</code></p>
</td></tr>
<tr><td><code id="PlotEmbed_+3A_...">...</code></td>
<td>
<p>Extra params passed to the plot function</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>EmbedSOM::PlotEmbed(cbind(rnorm(1e5),rnorm(1e5)))
</code></pre>

<hr>
<h2 id='PlotGG'>Wrap PlotData result in ggplot object.</h2><span id='topic+PlotGG'></span>

<h3>Description</h3>

<p>This creates a ggplot2 object for plotting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotGG(embed, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotGG_+3A_embed">embed</code></td>
<td>
<p>Embedding data</p>
</td></tr>
<tr><td><code id="PlotGG_+3A_...">...</code></td>
<td>
<p>Extra arguments passed to <code><a href="#topic+PlotData">PlotData()</a></code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(EmbedSOM)
library(ggplot2)

# simulate a simple dataset
e &lt;- cbind(rnorm(10000),rnorm(10000))

PlotGG(e, data=data.frame(Expr=runif(10000))) +
  geom_point(aes_string(color="Expr"))
</code></pre>

<hr>
<h2 id='PlotId'>Identity on whatever</h2><span id='topic+PlotId'></span>

<h3>Description</h3>

<p>Identity on whatever
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotId(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotId_+3A_x">x</code></td>
<td>
<p>Just the x.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The x.
</p>

<hr>
<h2 id='RandomMap'>Create a map by randomly selecting points</h2><span id='topic+RandomMap'></span>

<h3>Description</h3>

<p>Create a map by randomly selecting points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RandomMap(data, k, coordsFn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RandomMap_+3A_data">data</code></td>
<td>
<p>Input data matrix, with individual data points in rows</p>
</td></tr>
<tr><td><code id="RandomMap_+3A_k">k</code></td>
<td>
<p>How many points to sample</p>
</td></tr>
<tr><td><code id="RandomMap_+3A_coordsfn">coordsFn</code></td>
<td>
<p>a function to generate embedding coordinates (default none)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>map object (without the grid, if <code>coordsFn</code> was not specified)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- iris[,1:4]
EmbedSOM::PlotEmbed(
  EmbedSOM::EmbedSOM(
    data = d,
    map = EmbedSOM::RandomMap(d, 30, EmbedSOM::GraphCoords())),
  pch=19, clust=iris[,5]
)
</code></pre>

<hr>
<h2 id='SOM'>Build a self-organizing map</h2><span id='topic+SOM'></span>

<h3>Description</h3>

<p>Build a self-organizing map
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SOM(
  data,
  xdim = 10,
  ydim = 10,
  zdim = NULL,
  batch = F,
  rlen = 10,
  alphaA = c(0.05, 0.01),
  radiusA = stats::quantile(nhbrdist, 0.67) * c(1, 0),
  alphaB = alphaA * c(-negAlpha, -0.1 * negAlpha),
  radiusB = negRadius * radiusA,
  negRadius = 1.33,
  negAlpha = 0.1,
  epochRadii = seq(radiusA[1], radiusA[2], length.out = rlen),
  init = FALSE,
  initf = Initialize_PCA,
  distf = 2,
  codes = NULL,
  importance = NULL,
  coordsFn = NULL,
  nhbr.method = "maximum",
  noMapping = F,
  parallel = F,
  threads = if (parallel) 0 else 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SOM_+3A_data">data</code></td>
<td>
<p>Matrix containing the training data</p>
</td></tr>
<tr><td><code id="SOM_+3A_xdim">xdim</code></td>
<td>
<p>Width of the grid</p>
</td></tr>
<tr><td><code id="SOM_+3A_ydim">ydim</code></td>
<td>
<p>Hight of the grid</p>
</td></tr>
<tr><td><code id="SOM_+3A_zdim">zdim</code></td>
<td>
<p>Depth of the grid, causes the grid to be 3D if set</p>
</td></tr>
<tr><td><code id="SOM_+3A_batch">batch</code></td>
<td>
<p>Use batch training (default <code>FALSE</code> chooses online training, which is more like FlowSOM)</p>
</td></tr>
<tr><td><code id="SOM_+3A_rlen">rlen</code></td>
<td>
<p>Number of training epochs; or number of times to loop over the training data in online training</p>
</td></tr>
<tr><td><code id="SOM_+3A_alphaa">alphaA</code></td>
<td>
<p>Start and end learning rate for online learning (only for online training)</p>
</td></tr>
<tr><td><code id="SOM_+3A_radiusa">radiusA</code></td>
<td>
<p>Start and end radius</p>
</td></tr>
<tr><td><code id="SOM_+3A_alphab">alphaB</code></td>
<td>
<p>Start and end learning rate for the second radius (only for online training)</p>
</td></tr>
<tr><td><code id="SOM_+3A_radiusb">radiusB</code></td>
<td>
<p>Start and end radius (only for online training; make sure it is larger than radiusA)</p>
</td></tr>
<tr><td><code id="SOM_+3A_negradius">negRadius</code></td>
<td>
<p>easy way to set radiusB as a multiple of default radius
(use lower value for higher dimensions)</p>
</td></tr>
<tr><td><code id="SOM_+3A_negalpha">negAlpha</code></td>
<td>
<p>the same for alphaB</p>
</td></tr>
<tr><td><code id="SOM_+3A_epochradii">epochRadii</code></td>
<td>
<p>Vector of length <code>rlen</code> with precise epoch radii (only for batch training)</p>
</td></tr>
<tr><td><code id="SOM_+3A_init">init</code></td>
<td>
<p>Initialize cluster centers in a non-random way</p>
</td></tr>
<tr><td><code id="SOM_+3A_initf">initf</code></td>
<td>
<p>Use the given initialization function if init==T
(default: Initialize_PCA)</p>
</td></tr>
<tr><td><code id="SOM_+3A_distf">distf</code></td>
<td>
<p>Distance function (1=manhattan, 2=euclidean, 3=chebyshev, 4=cosine)</p>
</td></tr>
<tr><td><code id="SOM_+3A_codes">codes</code></td>
<td>
<p>Cluster centers to start with</p>
</td></tr>
<tr><td><code id="SOM_+3A_importance">importance</code></td>
<td>
<p>array with numeric values. Columns of <code>data</code> will be scaled according to importance.</p>
</td></tr>
<tr><td><code id="SOM_+3A_coordsfn">coordsFn</code></td>
<td>
<p>Function to generate/transform grid coordinates (e.g. <code><a href="#topic+tSNECoords">tSNECoords()</a></code>). If <code>NULL</code> (default), the grid is the canonical SOM grid.</p>
</td></tr>
<tr><td><code id="SOM_+3A_nhbr.method">nhbr.method</code></td>
<td>
<p>Way of computing grid distances, passed as <code style="white-space: pre;">&#8288;method=&#8288;</code> to <code><a href="stats.html#topic+dist">stats::dist()</a></code> function. Defaults to <code>maximum</code> (square neighborhoods); use <code>euclidean</code> for round neighborhoods.</p>
</td></tr>
<tr><td><code id="SOM_+3A_nomapping">noMapping</code></td>
<td>
<p>If TRUE, do not compute the mapping (default FALSE). Makes the process quicker by 1 <code>rlen</code>.</p>
</td></tr>
<tr><td><code id="SOM_+3A_parallel">parallel</code></td>
<td>
<p>Parallelize the batch training by setting appropriate <code>threads</code>. Defaults to FALSE. Always use <code>batch=TRUE</code> for fully parallelized version, online training is not parallelizable. Passed to <code><a href="#topic+MapDataToCodes">MapDataToCodes()</a></code>.</p>
</td></tr>
<tr><td><code id="SOM_+3A_threads">threads</code></td>
<td>
<p>Number of threads of the batch training (has no effect on online training). Defaults to 0 (chooses maximum available hardware threads) if <code>parallel==TRUE</code> or 1 (single thread) if <code>parallel==FALSE</code>. Passed to <code><a href="#topic+MapDataToCodes">MapDataToCodes()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A map useful for embedding (<code><a href="#topic+EmbedSOM">EmbedSOM()</a></code> function) or further analysis, e.g. clustering.
</p>


<h3>See Also</h3>

<p>FlowSOM::SOM
</p>

<hr>
<h2 id='tSNECoords'>Add tSNE-based coordinates to a map</h2><span id='topic+tSNECoords'></span>

<h3>Description</h3>

<p>Add tSNE-based coordinates to a map
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tSNECoords(dim = NULL, tSNEFn = Rtsne::Rtsne, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tSNECoords_+3A_dim">dim</code></td>
<td>
<p>Dimension of the result (passed to <code>tSNEFn</code> as <code>dims</code>)</p>
</td></tr>
<tr><td><code id="tSNECoords_+3A_tsnefn">tSNEFn</code></td>
<td>
<p>tSNE function to run (default <a href="Rtsne.html#topic+Rtsne">Rtsne::Rtsne</a>)</p>
</td></tr>
<tr><td><code id="tSNECoords_+3A_...">...</code></td>
<td>
<p>passed to <code>tSNEFn</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function that transforms the map, usable as <code>coordsFn</code> parameter
</p>

<hr>
<h2 id='UMAPCoords'>Add UMAP-based coordinates to a map</h2><span id='topic+UMAPCoords'></span>

<h3>Description</h3>

<p>Add UMAP-based coordinates to a map
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UMAPCoords(dim = NULL, UMAPFn = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UMAPCoords_+3A_dim">dim</code></td>
<td>
<p>Dimension of the result (passed to <code>UMAPFn</code> as <code>n_components</code>)</p>
</td></tr>
<tr><td><code id="UMAPCoords_+3A_umapfn">UMAPFn</code></td>
<td>
<p>UMAP function to run (default <a href="umap.html#topic+umap">umap::umap</a> configured by <a href="umap.html#topic+umap.defaults">umap::umap.defaults</a>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function that transforms the map, usable as <code>coordsFn</code> parameter
</p>

<hr>
<h2 id='UMatrixCoords'>Add U-Matrix-optimized embedding coordinates to the map</h2><span id='topic+UMatrixCoords'></span>

<h3>Description</h3>

<p>The map must already contain a SOM grid with corresponding <code>xdim</code>,<code>ydim</code> (possibly <code>zdim</code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UMatrixCoords(
  dim = NULL,
  dist.method = NULL,
  distFn = function(x) x,
  layoutFn = igraph::layout_with_kk
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UMatrixCoords_+3A_dim">dim</code></td>
<td>
<p>Dimension of the result (passed to <code>layoutFn</code>)</p>
</td></tr>
<tr><td><code id="UMatrixCoords_+3A_dist.method">dist.method</code></td>
<td>
<p>The method to compute distances, passed to <code><a href="stats.html#topic+dist">stats::dist()</a></code> as parameter <code>method</code></p>
</td></tr>
<tr><td><code id="UMatrixCoords_+3A_distfn">distFn</code></td>
<td>
<p>Custom transformation function of the distance matrix</p>
</td></tr>
<tr><td><code id="UMatrixCoords_+3A_layoutfn">layoutFn</code></td>
<td>
<p>iGraph-compatible graph layouting function (default <a href="igraph.html#topic+layout_with_kk">igraph::layout_with_kk</a>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function that transforms the map, usable as 'coordsFn' parameter
</p>

<hr>
<h2 id='uwotCoords'>Add UMAP-based coordinates to a map, using the 'uwot' package</h2><span id='topic+uwotCoords'></span>

<h3>Description</h3>

<p>Add UMAP-based coordinates to a map, using the 'uwot' package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uwotCoords(dim = NULL, uwotFn = uwot::umap, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uwotCoords_+3A_dim">dim</code></td>
<td>
<p>Dimension of the result (passed to <code>uwotFn</code> as <code>dims</code>)</p>
</td></tr>
<tr><td><code id="uwotCoords_+3A_uwotfn">uwotFn</code></td>
<td>
<p>UMAP function to run (default <a href="uwot.html#topic+umap">uwot::umap</a>)</p>
</td></tr>
<tr><td><code id="uwotCoords_+3A_...">...</code></td>
<td>
<p>passed to <code>uwotFn</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function that transforms the map, usable as <code>coordsFn</code> parameter
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
