<!DOCTYPE html><html><head><title>Help for package labelr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {labelr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_factor_info'><p>Add Factor-specific Attributes to a Data Frame</p></a></li>
<li><a href='#add_frame_lab'><p>Add or Modify a Data Frame &quot;Frame Label&quot;</p></a></li>
<li><a href='#add_lab_atts'><p>Add labelr Attributes from a list to a Data Frame</p></a></li>
<li><a href='#add_lab_col1'><p>Create a Value Labels Column for a Single Variable and Add to the Data Frame</p></a></li>
<li><a href='#add_lab_cols'><p>Add Variable Value Label Columns to a Data Frame</p></a></li>
<li><a href='#add_lab_dumm1'><p>Add A Dummy Variable for Each Value Label of a Single Variable</p></a></li>
<li><a href='#add_lab_dummies'><p>Add A Dummy Variable for Each Value Label</p></a></li>
<li><a href='#add_m1_lab'><p>Apply One Label to Multiple Values</p></a></li>
<li><a href='#add_name_labs'><p>Add or Modify Data Frame Variable Name Labels</p></a></li>
<li><a href='#add_quant_labs'><p>Associate Numerical Threshold-based Value Labels with Select Numerical Variables</p></a></li>
<li><a href='#add_quant1'><p>Associate Numerical Threshold-based Value Labels with a Single Numerical Variable</p></a></li>
<li><a href='#add_val_labs'><p>Add or Modify a Variable's Value Labels</p></a></li>
<li><a href='#add_val1'><p>Add or Modify a Single Variable's Value Labels</p></a></li>
<li><a href='#add1m1'><p>Apply One Label to Multiple Values for a Single Variable</p></a></li>
<li><a href='#all_quant_labs'><p>Add Quantile-based Value Labels to All Numeric Vars that Meet Specifications</p></a></li>
<li><a href='#all_uniquev'><p>Are All Values in a Free-standing Vector Unique?</p></a></li>
<li><a href='#as_base_data_frame'><p>Convert Augmented Data Frame to Base R Data Frame</p></a></li>
<li><a href='#as_base_data_frame2'><p>Convert Augmented Data Frame to Base R Data Frame with Alternate Defaults</p></a></li>
<li><a href='#as_num'><p>Convert all Suitable Character Variables to Numeric</p></a></li>
<li><a href='#as_numv'><p>Convert a Suitable Character Vector to Numeric</p></a></li>
<li><a href='#axis_lab'><p>Retrieve Variable's Name Label for Plot Labeling</p></a></li>
<li><a href='#check_any_lab_atts'><p>Check Whether Data Frame Has Any labelr Attributes</p></a></li>
<li><a href='#check_class'><p>Determine If Vector Belongs to Any of Specified Classes</p></a></li>
<li><a href='#check_irregular'><p>Check Vector for &quot;Irregular&quot; Values</p></a></li>
<li><a href='#check_labs_att'><p>Check Data Frame for Specified labelr Attribute</p></a></li>
<li><a href='#clean_data_atts'><p>&quot;Clean&quot; Data Frame Attributes</p></a></li>
<li><a href='#convert_labs'><p>Convert from Haven-style to labelr Variable Value Labels</p></a></li>
<li><a href='#copy_var'><p>Copy a Data Frame Variable and its Value labels to Another Variable</p></a></li>
<li><a href='#drop_frame_lab'><p>Remove Frame Label Attribute from a Data Frame</p></a></li>
<li><a href='#drop_name_labs'><p>Remove Name Label Attributes from a Data Frame</p></a></li>
<li><a href='#drop_val_labs'><p>Drop Value Labels from One or More Variables</p></a></li>
<li><a href='#drop_val1'><p>Drop a Single Variable's Value Labels</p></a></li>
<li><a href='#fact2char'><p>Convert All Factor Variables of a Data Frame to Column Variables</p></a></li>
<li><a href='#factor_to_lab_int'><p>Convert a Factor Variable Column to Value-labeled Integer Variable Column</p></a></li>
<li><a href='#flab'><p>Filter Data Frame Rows Using Variable Value Labels</p></a></li>
<li><a href='#get_all_factors'><p>Put Data Frame Factor Level Information into a List</p></a></li>
<li><a href='#get_all_lab_atts'><p>Put all Data Frame label attributes into a List</p></a></li>
<li><a href='#get_factor_atts'><p>Get Factor Attributes from a Labeled Data Frame</p></a></li>
<li><a href='#get_factor_info'><p>Return Factor Attributes as a Data Frame</p></a></li>
<li><a href='#get_frame_lab'><p>Return a Data Frame's Frame Label</p></a></li>
<li><a href='#get_labs_att'><p>Return Specified Label Attribute, if Present</p></a></li>
<li><a href='#get_name_labs'><p>Return Look-up Table of Variable Names and Name Labels</p></a></li>
<li><a href='#get_val_lab1'><p>Return Look-up Table of One Variable's Value Labels</p></a></li>
<li><a href='#get_val_labs'><p>Return Look-up Table of Variable Values and Value Labels</p></a></li>
<li><a href='#greml'><p>Determine Which Pattern Elements of One Character Vector Are Found in at</p>
Least One Element of A Second Character Vector</a></li>
<li><a href='#gremlr'><p>Determine Which Elements of a Character Vector Match at Least One Pattern</p>
Contained in Any of the Elements of Another Character Vector</a></li>
<li><a href='#has_avl_labs'><p>Is This a <code>add_val_labs()</code>-style Value-labeled Variable (Column)?</p></a></li>
<li><a href='#has_decv'><p>Determine if Vector Has Decimals</p></a></li>
<li><a href='#has_m1_labs'><p>Is This an <code>add_m1_lab()</code> Many-to-One-Style Value-labeled Variable (Column)?</p></a></li>
<li><a href='#has_quant_labs'><p>Is this an <code>add_quant_labs()</code>-style Value-labeled Variable (Column)?</p></a></li>
<li><a href='#has_val_labs'><p>Is This a Value-labeled Variable (Column)?</p></a></li>
<li><a href='#headl'><p>Return First Rows of a Data Frame with Value Labels Visible</p></a></li>
<li><a href='#init_labs'><p>Initialize labelr Attributes</p></a></li>
<li><a href='#irregular2'><p>Convert All &quot;Irregular&quot; Data Frame Values to NA or Other Specified Value</p></a></li>
<li><a href='#irregular2v'><p>Replace &quot;Irregular&quot; Values of a Vector with Some Other Value</p></a></li>
<li><a href='#is_numable'><p>Test Whether Character Vector Is &quot;Suitable&quot; for Numeric Conversion</p></a></li>
<li><a href='#lab_int_to_factor'><p>Convert a Value-labeled Integer Variable Column to a Factor Variable Column</p></a></li>
<li><a href='#make_demo_data'><p>Construct a Fake Demographic Data Frame</p></a></li>
<li><a href='#make_likert_data'><p>Construct a Fake Likert Survey Response Data Frame</p></a></li>
<li><a href='#recode_vals'><p>Recode Values of a Free-standing Vector</p></a></li>
<li><a href='#restore_factor_info'><p>Restore Factor Status, Levels to a Character Column of a Labeled Data Frame</p></a></li>
<li><a href='#sbrac'><p>Safely Extract Elements of a Labeled Data Frame</p></a></li>
<li><a href='#scbind'><p>Safely Combine Data Frames Column-wise</p></a></li>
<li><a href='#schange'><p>Safely Change or Add a Data Frame Variable (Column)</p></a></li>
<li><a href='#sdrop'><p>Safely Drop Specified Columns of a Labeled Data Frame</p></a></li>
<li><a href='#sfilter'><p>Safely Filter Rows of a Labeled Data Frame</p></a></li>
<li><a href='#sgen'><p>Safely Generate a Data Frame Variable (Column)</p></a></li>
<li><a href='#slab'><p>Subset a Data Frame Using Value Labels</p></a></li>
<li><a href='#smerge'><p>Safely Merge Two Data Frames</p></a></li>
<li><a href='#somel'><p>Return a Random Sample of Data Frame Rows with Value Labels Visible</p></a></li>
<li><a href='#sort_val_labs'><p>Sort Ascending Any Variable Value Labels</p></a></li>
<li><a href='#srbind'><p>Safely Combine Data Frames Row-wise</p></a></li>
<li><a href='#srename'><p>Safely Rename a Variable and Preserve Its Value Labels</p></a></li>
<li><a href='#sreplace'><p>Safely Replace a Data Frame Variable (Column)</p></a></li>
<li><a href='#sselect'><p>Safely Select Specified Columns of a Labeled Data Frame</p></a></li>
<li><a href='#ssort'><p>Safely Sort (Re-order) a Labeled Data Frame</p></a></li>
<li><a href='#ssubset'><p>Safely Subset a Labeled Data Frame</p></a></li>
<li><a href='#strip_labs'><p>Strip All labelr Meta-data from a Data Frame</p></a></li>
<li><a href='#tabl'><p>Construct Value Label-Friendly Frequency Tables</p></a></li>
<li><a href='#taill'><p>Return Last Rows of a Data Frame with Value Labels Visible</p></a></li>
<li><a href='#transfer_labs'><p>Transfer Labels from One Variable (Column) Name to Another</p></a></li>
<li><a href='#use_name_labs'><p>Swap Name Labels for Variable Names</p></a></li>
<li><a href='#use_val_lab1'><p>Replace a Single Data Frame Column's Values with Its Value Labels</p></a></li>
<li><a href='#use_val_labs'><p>Swap Variable Value Labels for Variable Values</p></a></li>
<li><a href='#use_var_names'><p>Swap (back) Original Variable Names for Name Labels</p></a></li>
<li><a href='#v'><p>Specify Column Names without Quoting Them</p></a></li>
<li><a href='#val_labs_vec'><p>Replace a Variable's Values with Its Value Labels and Return as a Vector</p></a></li>
<li><a href='#with_both_labs'><p>Overlay Variable Name and Value Labels Onto Arbitrary R Function Calls</p></a></li>
<li><a href='#with_name_labs'><p>Overlay Variable Name Labels Onto Arbitrary R Function Calls</p></a></li>
<li><a href='#with_val_labs'><p>Evaluate an Expression in a Value Labels-on Data Environment</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Label Data Frames, Variables, and Values</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.6</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Robert Hartman &lt;rohartman@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Create and use data frame labels for data frame objects (frame labels), their columns (name labels), and individual values of a column (value labels). Value labels include one-to-one and many-to-one labels for nominal and ordinal variables, as well as numerical range-based value labels for continuous variables. Convert value-labeled variables so each value is replaced by its corresponding value label. Add values-converted-to-labels columns to a value-labeled data frame while preserving parent columns. Filter and subset a value-labeled data frame using labels, while returning results in terms of values. Overlay labels in place of values in common R commands to increase interpretability. Generate tables of value frequencies, with categories expressed as raw values or as labels. Access data frames that show value-to-label mappings for easy reference.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/rhartmano/labelr">https://github.com/rhartmano/labelr</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.0</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, car, nycflights13, collapse, tibble, haven,
dplyr, modelr, ggplot2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-03 11:11:04 UTC; rohar</td>
</tr>
<tr>
<td>Author:</td>
<td>Robert Hartman [aut, cre],
  The MITRE Corporation [cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-04 09:47:29 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_factor_info'>Add Factor-specific Attributes to a Data Frame</h2><span id='topic+add_factor_info'></span>

<h3>Description</h3>

<p><code>add_factor_info</code> searches a data.frame for labelr-specific factor meta-data,
which it records and retains for future use. It is used by other labelr
functions and need not be used directly by labelr end users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_factor_info(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_factor_info_+3A_data">data</code></td>
<td>
<p>the data.frame to which you wish to add labelr-specific factor
variable meta-data attributes (if any factors are present).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># this function does not strictly require prior or other use of labelr
ir2 &lt;- add_factor_info(iris)
mt2 &lt;- add_factor_info(mtcars)
get_factor_info(mtcars) # none
get_factor_info(iris) # none
get_factor_info(mt2) # none
get_factor_info(ir2) # some!
</code></pre>

<hr>
<h2 id='add_frame_lab'>Add or Modify a Data Frame &quot;Frame Label&quot;</h2><span id='topic+add_frame_lab'></span><span id='topic+afl'></span>

<h3>Description</h3>

<p>Add a 500-or-fewer-characters high-level descriptive label for your data.frame
as whole (e.g., nature, originator, population / sample, year created, general
contents, article citation).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_frame_lab(data, frame.lab = NULL)

afl(data, frame.lab = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_frame_lab_+3A_data">data</code></td>
<td>
<p>a data.frame.</p>
</td></tr>
<tr><td><code id="add_frame_lab_+3A_frame.lab">frame.lab</code></td>
<td>
<p>quoted text of the descriptive data.frame label that you wish
to add to the data.frame.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>add_frame_lab</code> assigns an overall descriptive &quot;frame label&quot; for a data.frame,
which can be retrieved using <code>get_frame_lab.</code>
</p>
<p>Note: <code>afl</code> is a compact alias for <code>add_frame_lab</code>: they do the same thing,
and the former is easier to type
</p>


<h3>Value</h3>

<p>A data.frame, with a frame.lab attribute added to the attributes
meta-data
</p>


<h3>Examples</h3>

<pre><code class='language-R'># add frame.lab to mtcars and assign to new data.frame mt2
mt2 &lt;- add_frame_lab(mtcars, frame.lab = "Data extracted from the 1974 Motor
                    Trend US magazine, comprising fuel consumption and 10
                    aspects of automobile design and performance for 32
                    automobiles (1973–74 models). Source: Henderson and
                    Velleman (1981), Building multiple regression models
                    interactively. Biometrics, 37, 391–411.")

attr(mt2, "frame.lab") # check for attribute

get_frame_lab(mt2) # return frame.lab alongside data.frame name as a data.frame
</code></pre>

<hr>
<h2 id='add_lab_atts'>Add labelr Attributes from a list to a Data Frame</h2><span id='topic+add_lab_atts'></span>

<h3>Description</h3>

<p><code>add_lab_atts</code> allows one to apply a list of labelr label attribute meta-data
(created by <code>get_all_lab_atts</code>) to a data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_lab_atts(
  data,
  lab.atts.list,
  strip.first = FALSE,
  num.convert = FALSE,
  clean = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_lab_atts_+3A_data">data</code></td>
<td>
<p>a data.frame object.</p>
</td></tr>
<tr><td><code id="add_lab_atts_+3A_lab.atts.list">lab.atts.list</code></td>
<td>
<p>a list previously created using <code>get_all_lab_atts</code>.</p>
</td></tr>
<tr><td><code id="add_lab_atts_+3A_strip.first">strip.first</code></td>
<td>
<p>FALSE if you do not wish to strip the data.frame of all
label attribute information it may already have (this information may still
be overwritten, depending on what is in the lab.atts.list list).</p>
</td></tr>
<tr><td><code id="add_lab_atts_+3A_num.convert">num.convert</code></td>
<td>
<p>attempt to convert to numeric any data.frame variables
where this can be done without producing new NA values.</p>
</td></tr>
<tr><td><code id="add_lab_atts_+3A_clean">clean</code></td>
<td>
<p>after adding label attributes, put them into a neat, logical
order and drop any attributes that describe variables (columns) not present
in the data.frame to which they have been added.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code>get_all_lab_atts</code>.
</p>
<p><code>add_lab_atts</code> allows one to add or restore label attributes from a free-
standing list (created by <code>get_all_lab_atts</code>) to a data.frame. Certain
R operations will destroy attributes like labelr labels. Storing label
attributes in an appropriately formatted free-standing list (via
<code>get_all_lab_atts</code>) beforehand allows one to (re-) associate those attributes
with that data.frame (or associate the attributes with a new data.frame)
using <code>add_lab_atts</code>.
</p>


<h3>Value</h3>

<p>a data.frame object with label attribute information (re-) attached
(if it exists in the specified lab.atts.list).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># make toy demographic (gender, raceth, etc.) data set
set.seed(555)
df &lt;- make_demo_data(n = 1000) # another labelr:: function

# let's add variable VALUE labels for variable "raceth"
df &lt;- add_val_labs(df,
  vars = "raceth", vals = c(1:7),
  labs = c("White", "Black", "Hispanic", "Asian", "AIAN", "Multi", "Other"),
  max.unique.vals = 50
)

get_val_labs(df, "raceth") # it's here

zlab.df &lt;- get_all_lab_atts(df) # back up labelr attributes for df

df &lt;- strip_labs(df) # this removes labs from df

get_val_labs(df, "raceth") # it's gone

check_any_lab_atts(df) # FALSE (means "no labs here")

df &lt;- add_lab_atts(df, zlab.df) # restore them
</code></pre>

<hr>
<h2 id='add_lab_col1'>Create a Value Labels Column for a Single Variable and Add to the Data Frame</h2><span id='topic+add_lab_col1'></span><span id='topic+alc1'></span>

<h3>Description</h3>

<p>For a single value-labeled column of a data.frame, create a copy of that
column that replaces all of its values with the corresponding value labels
and added that copy to the supplied data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_lab_col1(data, var, suffix = "_lab")

alc1(data, var, suffix = "_lab")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_lab_col1_+3A_data">data</code></td>
<td>
<p>a data.frame.</p>
</td></tr>
<tr><td><code id="add_lab_col1_+3A_var">var</code></td>
<td>
<p>the unquoted name of the column (variable) whose values you wish
to replace with the corresponding value labels.</p>
</td></tr>
<tr><td><code id="add_lab_col1_+3A_suffix">suffix</code></td>
<td>
<p>a suffix that will be appended to the name of the labels-on
column that is added to the data.frame (e.g., if suffix = &quot;_lab,&quot; the
labels-on version of &quot;x1&quot; will be &quot;x1_lab&quot;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note 1: <code>add_lab_col1</code> is a variant of <code>add_lab_cols</code> that allows you to
specify only one variable at a time but that allows you to pass its name
without quoting it (compare add_lab_col1(mtcars, am) to
add_lab_cols(mtcars, &quot;am&quot;)).
</p>
<p>Note 2: <code>alc1</code> is a compact alias for <code>add_lab_col1</code>: they do the same thing,
and the former is easier to type.
</p>
<p>Note 3: This command is intended exclusively for interactive use. In
particular, the var argument must be the literal name of a single variable
(column) found in the supplied data.frame and may NOT be, e.g., the name of a
character vector that contains the variable (column name) of interest. If you
wish to supply a character vector with the names of variables (columns) of
interest, use <code>add_lab_cols()</code>.
</p>
<p><code>add_lab_col1</code> creates a &quot;labels-on&quot; version of a value-labeled column and
adds that new column to the supplied data.frame. Here, &quot;labels-on&quot; means that
the column's original values are replaced with the corresponding value
labels. Note that this column does not replace but is added to its
parent/source columns in the returned data.frame. The resulting &quot;labels-on&quot;
column is a simple, self-contained character column that cannot itself be
converted or reverted to the original (&quot;labels-off&quot;) values of its
parent/source column. See <code>add_lab_cols</code> for a list of other functions that
may be useful in working with value labels.
</p>


<h3>Value</h3>

<p>A data.frame consisting of the originally supplied data.frame, along
with the labels-on column added to it.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># add "labels-on" version of "am" to copy of mtcars
df &lt;- mtcars # copy of mtcars

# now, add value labels
df &lt;- add_val1(
  data = df,
  var = am,
  vals = c(0, 1),
  labs = c("automatic", "manual")
)

# add value labels-on version of "am" to df, assign to df_plus
df_plus &lt;- add_lab_col1(df, am)
head(df_plus[c("am", "am_lab")])
</code></pre>

<hr>
<h2 id='add_lab_cols'>Add Variable Value Label Columns to a Data Frame</h2><span id='topic+add_lab_cols'></span><span id='topic+alc'></span>

<h3>Description</h3>

<p>Add copies of value-labeled columns to a data.frame, where the new columns'
values are replaced with the corresponding value labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_lab_cols(data, vars = NULL, suffix = "_lab")

alc(data, vars = NULL, suffix = "_lab")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_lab_cols_+3A_data">data</code></td>
<td>
<p>a data.frame.</p>
</td></tr>
<tr><td><code id="add_lab_cols_+3A_vars">vars</code></td>
<td>
<p>the names of the columns (variables) for which &quot;labels-on&quot;
(values replaced with value labels) versions of the variable will be added to
the returned data.frame.</p>
</td></tr>
<tr><td><code id="add_lab_cols_+3A_suffix">suffix</code></td>
<td>
<p>a suffix that will be added to the names of all labels-on
variables added to the data.frame (the non-suffix portion of the variable
name will be identical to the original variable, e.g., the labels-on version
of &quot;x1&quot; will be &quot;x1_lab&quot; (or whatever alternative suffix you supply)).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: <code>alc</code> is a compact alias for <code>add_lab_cols</code>: they do the same thing,
and the former is easier to type.
</p>
<p><code>add_lab_cols</code> adds one or more &quot;labels-on&quot; columns to a data.frame, where
&quot;labels-on&quot; means that the column's original values are replaced with the
corresponding value labels. Note that these columns do not replace but are
added to their parent/source columns in the returned data.frame. The
resulting &quot;labels-on&quot; columns are simple, self-contained character columns
that cannot themselves be converted or reverted to the original
(&quot;labels-off&quot;) values of their parent/source columns.
</p>
<p>For other ways of accessing or leveraging value labels, see, e.g.,
<code>use_val_labs</code>, <code>val_labs_vec</code>, <code>add_lab_dummies</code>, <code>lab_int_to_factor</code>,
<code>flab</code>, <code>slab</code>, <code>get_val_labs</code>, <code>with_val_labs</code>, <code>headl</code>, <code>taill</code>, <code>somel</code>,
and <code>tabl</code>. In particular, see <code>use_val_labs</code> if, rather than adding a
&quot;labels-on&quot; column to a data.frame, you wish to replace a column's values
with the corresponding value labels. See <code>val_labs_vec</code> if you wish to
convert a single, value-labeled column's values to labels and return the
result as a stand-alone vector.
</p>


<h3>Value</h3>

<p>A data.frame consisting of the originally supplied data.frame, along
with (all or the select) labels-on variable versions added to it.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># one variable at a time, mtcars
df &lt;- mtcars
# now, add value labels
df &lt;- add_val_labs(
  data = df,
  vars = "am",
  vals = c(0, 1),
  labs = c("automatic", "manual")
)

df &lt;- add_val_labs(
  data = df,
  vars = "carb",
  vals = c(1, 2, 3, 4, 6, 8),
  labs = c(
    "1-carb", "2-carbs",
    "3-carbs", "4-carbs",
    "6-carbs", "8-carbs"
  )
)

# var arg can be unquoted if using add_val1()
# note that this is not add_val_labs(); add_val1() has "var" (not "vars) arg
df &lt;- add_val1(
  data = df,
  var = cyl, # note, "var," not "vars" arg
  vals = c(4, 6, 8),
  labs = c(
    "four-cyl",
    "six-cyl",
    "eight-cyl"
  )
)

df &lt;- add_val_labs(
  data = df,
  vars = "gear",
  vals = c(3, 4),
  labs = c(
    "3-speed",
    "4-speed"
  )
)

# Oops, we forgot 5-speeds; let's finish the job.
df &lt;- add_val_labs(
  data = df,
  vars = "gear",
  vals = 5,
  labs = "5-speed"
)

# add value labels-on versions of the foregoing to df and return as "df_plus"
df_plus &lt;- add_lab_cols(df)
head(df_plus)
head(df_plus[c("am", "am_lab")])
</code></pre>

<hr>
<h2 id='add_lab_dumm1'>Add A Dummy Variable for Each Value Label of a Single Variable</h2><span id='topic+add_lab_dumm1'></span><span id='topic+ald1'></span>

<h3>Description</h3>

<p>For a single value-labeled data.frame column, create a dummy (aka indicator)
variable for each of that column's unique value labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_lab_dumm1(
  data,
  var,
  simple.names = TRUE,
  sep = "_",
  prefix.length = 4,
  suffix.length = 7
)

ald1(
  data,
  var,
  simple.names = TRUE,
  sep = "_",
  prefix.length = 4,
  suffix.length = 7
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_lab_dumm1_+3A_data">data</code></td>
<td>
<p>a data.frame with at least one value-labeled variable (column).</p>
</td></tr>
<tr><td><code id="add_lab_dumm1_+3A_var">var</code></td>
<td>
<p>the unquoted name of the value-labeled variable (column) from
which dummy variable columns will be generated.</p>
</td></tr>
<tr><td><code id="add_lab_dumm1_+3A_simple.names">simple.names</code></td>
<td>
<p>if TRUE (the default), dummy variable names will be the
parent variable's name, followed by the sep separator (see above), followed
by an automatically generated numerical id suffix. For example two dummy
variable columns created from value-labeled column &quot;tacos&quot; using the sep
argument of &quot;.&quot; would be given the respective names &quot;tacos.1&quot; and &quot;tacos.2&quot;).</p>
</td></tr>
<tr><td><code id="add_lab_dumm1_+3A_sep">sep</code></td>
<td>
<p>the separator character to use in constructing dummy variable
column names (appears between the dummy variable name prefix and suffix).</p>
</td></tr>
<tr><td><code id="add_lab_dumm1_+3A_prefix.length">prefix.length</code></td>
<td>
<p>(NOTE: This argument is ignored if
simple.names = TRUE). A 1L integer indicating the number of leading
characters of the parent column's name to use in constructing dummy variable
column names. For example, if simple.names = FALSE, if prefix.length = 2, and
for a parent column named &quot;tacos&quot;, each derivative dummy variable column name
will begin with the prefix string &quot;ta,&quot; (corresponding to the first two
characters of &quot;tacos&quot;), followed by the sep separator character (see sep
param, above), followed by the suffix string (see suffix.length param, below).</p>
</td></tr>
<tr><td><code id="add_lab_dumm1_+3A_suffix.length">suffix.length</code></td>
<td>
<p>(NOTE: This argument is ignored if simple.names = TRUE).
A 1L integer indicating the number of leading characters of each variable
value label to use use in constructing dummy variable column names. For
example, consider the following setup: parent column name is &quot;tacos&quot;;
prefix.length = 3; sep = &quot;_&quot;, and suffix.length = 2. In this case, if
simple.names = FALSE, then a dummy variable column named &quot;tac_so&quot; would be
created to represent those values of the tacos&quot; column that have the value
label &quot;soft&quot; (because &quot;tac&quot; are the first three letters of the parent column
name, the separator is &quot;.&quot;, and &quot;so&quot; are the first two characters in &quot;soft&quot;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note 1: <code>add_lab_dumm1</code> is a variant of <code>add_lab_dummies</code> that allows you
to specify only one var to label at a time but that allows you to pass its
name without quoting.
</p>
<p>Note 2: <code>ald1</code> is a compact alias for <code>add_lab_dumm1</code>: they do the same thing,
and the former is easier to type
</p>
<p>Note 3: If the default of simple.names is used, dummy variable column names
will be the &quot;parent&quot; variable column name, followed by a separator character
(by default, &quot;_&quot;), followed by a number, to differentiate each dummy variable
from the others in the set. If one of the automatically generated dummy
column names is already &quot;taken&quot; by a pre-existing data.frame column, an error
to this effect will be thrown. If simple.names = FALSE, then prefix.length
and suffix.length arguments will be used to construct dummy variable column
names using the leading characters of the parent column name, followed by a
separator character, followed by the leading characters of the value label.
(white spaces in the value label will be replaced with the separator
character).
</p>
<p>Note 4: This command is intended exclusively for interactive use. In
particular, the var argument must be the literal name of a single variable
(column) found in the supplied data.frame and may NOT be, e.g., the name of a
character vector that contains the variable (column name) of interest. If you
wish to supply a character vector with the names of variables (columns) of
interest, use <code>add_lab_dummies()</code>.
</p>


<h3>Value</h3>

<p>A data.frame with dummy variables added for all value labels of the
value-labeled column supplied to the var argument.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># one variable at a time, mtcars
df &lt;- mtcars

# now, add 1-to-1 value labels
df &lt;- add_val_labs(
  data = df,
  vars = "am",
  vals = c(0, 1),
  labs = c("automatic", "manual")
)

df &lt;- add_val_labs(
  data = df,
  vars = "carb",
  vals = c(1, 2, 3, 4, 6, 8),
  labs = c(
    "1-carb", "2-carbs",
    "3-carbs", "4-carbs",
    "6-carbs", "8-carbs"
  )
)

# var arg can be unquoted if using add_val1()
# note that this is not add_val_labs(); add_val1() has "var" (not "vars) arg
df &lt;- add_val1(
  data = df,
  var = cyl, # note, "var," not "vars" arg
  vals = c(4, 6, 8),
  labs = c(
    "four-cyl",
    "six-cyl",
    "eight-cyl"
  )
)

# add many-to-1 value labels
df &lt;- add_m1_lab(
  data = df,
  vars = "gear",
  vals = 4:5,
  lab = "4+"
)

# add quartile-based numerical range value labels
df &lt;- add_quant_labs(
  data = df,
  vars = "disp",
  qtiles = 4
)

# add "pretty" cut-based numerical range value labels
(mpg_bins &lt;- pretty(range(df$mpg, na.rm = TRUE)))

df &lt;- add_quant_labs(data = df, vars = "mpg", vals = mpg_bins)

# add dummy variables for value labels of column "mpg"
df1 &lt;- add_lab_dumm1(df,
  var = mpg,
  simple.names = TRUE
) # simple.names = TRUE is default
df1

# add dummy variables for value labels of column "am"
df2 &lt;- add_lab_dumm1(df, am,
  sep = ".", simple.names = FALSE,
  prefix.length = 2, suffix.length = 6
)
df2

</code></pre>

<hr>
<h2 id='add_lab_dummies'>Add A Dummy Variable for Each Value Label</h2><span id='topic+add_lab_dummies'></span><span id='topic+ald'></span>

<h3>Description</h3>

<p>For one or more value-labeled data.frame columns, create a dummy (aka
indicator) variable for each unique value label.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_lab_dummies(
  data,
  vars,
  simple.names = TRUE,
  sep = "_",
  prefix.length = 4,
  suffix.length = 7
)

ald(
  data,
  vars,
  simple.names = TRUE,
  sep = "_",
  prefix.length = 4,
  suffix.length = 7
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_lab_dummies_+3A_data">data</code></td>
<td>
<p>a data.frame with at least one value-labeled variable (column).</p>
</td></tr>
<tr><td><code id="add_lab_dummies_+3A_vars">vars</code></td>
<td>
<p>the value-labeled variable or variables from which dummy
variable columns will be generated (variable names must be quoted).</p>
</td></tr>
<tr><td><code id="add_lab_dummies_+3A_simple.names">simple.names</code></td>
<td>
<p>if TRUE (the default), dummy variable names will be the
parent variable's name, followed by the sep separator (see above), followed
by an automatically generated numerical id suffix. For example two dummy
variable columns created from value-labeled column &quot;tacos&quot; using the sep
argument of &quot;.&quot; would be given the respective names &quot;tacos.1&quot; and &quot;tacos.2&quot;).</p>
</td></tr>
<tr><td><code id="add_lab_dummies_+3A_sep">sep</code></td>
<td>
<p>the separator character to use in constructing dummy variable
column names (appears between the dummy variable name prefix and suffix).</p>
</td></tr>
<tr><td><code id="add_lab_dummies_+3A_prefix.length">prefix.length</code></td>
<td>
<p>(NOTE: This argument is ignored if
simple.names = TRUE). A 1L integer indicating the number of leading
characters of the parent column's name to use in constructing dummy variable
column names. For example, if simple.names = FALSE, if prefix.length = 2, and
for a parent column named &quot;tacos&quot;, each derivative dummy variable column name
will begin with the prefix string &quot;ta,&quot; (corresponding to the first two
characters of &quot;tacos&quot;), followed by the sep separator character (see sep
param, above), followed by the suffix string (see suffix.length param, below).</p>
</td></tr>
<tr><td><code id="add_lab_dummies_+3A_suffix.length">suffix.length</code></td>
<td>
<p>(NOTE: This argument is ignored if simple.names = TRUE).
A 1L integer indicating the number of leading characters of each variable
value label to use in constructing dummy variable column names. For example,
consider the following setup: parent column name is &quot;tacos&quot;;
prefix.length = 3; sep = &quot;<em>&quot;, and suffix.length = 2. In this case, if
simple.names = FALSE, then a dummy variable column named &quot;tac_so&quot; would be
created to represent those values of the tacos&quot; column that have the value
label &quot;soft&quot; (because &quot;tac&quot; are the first three letters of the parent column
name, the separator is &quot;</em>&quot;, and &quot;so&quot; are the first two characters in &quot;soft&quot;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the default of simple.names is used, dummy variable column names will be
the &quot;parent&quot; variable column name, followed by a separator character (by
default, &quot;_&quot;), followed by a number, to differentiate each dummy variable
from the others in the set. If one of the automatically generated dummy
column names is already &quot;taken&quot; by a pre-existing data.frame column, an error
to this effect will be thrown. If simple.names = FALSE, then prefix.length
and suffix.length arguments will be used to construct dummy variable column
names using the leading characters of the parent column name, followed by a
separator character, followed by the leading characters of the value label.
(white spaces in the value label will be replaced with the separator
character).
</p>
<p>Note: <code>ald()</code> is an alias function that behaves identically to
<code>add_lab_dummies</code>.
</p>


<h3>Value</h3>

<p>A data.frame with dummy variables added for all value labels of the
value-labeled columns supplied to the vars argument.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># one variable at a time, mtcars
df &lt;- mtcars

# now, add 1-to-1 value labels
df &lt;- add_val_labs(
  data = df,
  vars = "am",
  vals = c(0, 1),
  labs = c("automatic", "manual")
)

df &lt;- add_val_labs(
  data = df,
  vars = "carb",
  vals = c(1, 2, 3, 4, 6, 8),
  labs = c(
    "1-carb", "2-carbs",
    "3-carbs", "4-carbs",
    "6-carbs", "8-carbs"
  )
)

# var arg can be unquoted if using add_val1()
# note that this is not add_val_labs(); add_val1() has "var" (not "vars) arg
df &lt;- add_val1(
  data = df,
  var = cyl, # note, "var," not "vars" arg
  vals = c(4, 6, 8),
  labs = c(
    "four-cyl",
    "six-cyl",
    "eight-cyl"
  )
)

# add many-to-1 value labels
df &lt;- add_m1_lab(
  data = df,
  vars = "gear",
  vals = 4:5,
  lab = "4+"
)

# add quartile-based numerical range value labels
df &lt;- add_quant_labs(
  data = df,
  vars = "disp",
  qtiles = 4
)

# add "pretty" cut-based numerical range value labels
(mpg_bins &lt;- pretty(range(df$mpg, na.rm = TRUE)))

df &lt;- add_quant_labs(data = df, vars = "mpg", vals = mpg_bins)

# add dummy variables for the labels of column "am"
df2 &lt;- add_lab_dummies(df, "am",
  sep = ".", simple.names = FALSE,
  prefix.length = 2, suffix.length = 6
)
df2

# add dummy variables for the labels of columns "mpg", "gear", and "cyl
df3 &lt;- add_lab_dummies(df, c("mpg", "gear", "cyl"), simple.names = TRUE) # default
df3
</code></pre>

<hr>
<h2 id='add_m1_lab'>Apply One Label to Multiple Values</h2><span id='topic+add_m1_lab'></span><span id='topic+am1l'></span>

<h3>Description</h3>

<p>Apply a single variable value label to multiple values of a variable
(&quot;m1&quot; is shorthand for &quot;many values get one label&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_m1_lab(
  data,
  vars,
  vals,
  lab,
  partial = FALSE,
  not.vars = NULL,
  max.unique.vals = 10,
  init = FALSE
)

am1l(
  data,
  vars,
  vals,
  lab,
  partial = FALSE,
  not.vars = NULL,
  max.unique.vals = 10,
  init = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_m1_lab_+3A_data">data</code></td>
<td>
<p>a data.frame.</p>
</td></tr>
<tr><td><code id="add_m1_lab_+3A_vars">vars</code></td>
<td>
<p>a character vector that corresponds to the name(s) of one or more
variables to which value labels will be added.</p>
</td></tr>
<tr><td><code id="add_m1_lab_+3A_vals">vals</code></td>
<td>
<p>a vector of distinct values of the actual variable, each of which
is to be associated with the single label supplied to the lab argument. Note:
NA and other &quot;irregular&quot; (e.g., NaN, Inf) values all are automatically
assigned the label &quot;NA&quot;, and this cannot be overridden.</p>
</td></tr>
<tr><td><code id="add_m1_lab_+3A_lab">lab</code></td>
<td>
<p>a single distinct label that will be associated with all values
specified in your vals argument. Note: NA and other &quot;irregular&quot; (e.g.,
NaN, Inf) values are automatically assigned the label &quot;NA&quot; and may not be
assigned another label.</p>
</td></tr>
<tr><td><code id="add_m1_lab_+3A_partial">partial</code></td>
<td>
<p>To apply the same value labeling scheme to many variables
at once, you can provide those variable names explicitly (e.g., vars =
c(&quot;x1&quot;,&quot;x2&quot;, &quot;x3&quot;) or vars = paste0(&quot;x&quot;, 1:3), or you can provide a substring
only and set partial = TRUE (default is FALSE). For example, to apply the
same labeling scheme to vars &quot;x1&quot;, &quot;x2&quot; ... sequentially through &quot;x10&quot;,
you could use vars = c(&quot;x&quot;), along with partial = TRUE. Be careful with
this, as it also will attempt to apply the scheme to &quot;sex&quot; or &quot;tax.bracket&quot;,
etc.</p>
</td></tr>
<tr><td><code id="add_m1_lab_+3A_not.vars">not.vars</code></td>
<td>
<p>use of the partial argument can result in situations where
you inadvertently attempt to value-label a variable. For example, if vars=&quot;x&quot;
and partial=TRUE, then <code>add_m1_lab</code> will attempt to label not only &quot;x1&quot;,
&quot;x2&quot;,&quot;x3&quot;, and &quot;x4&quot;, but also &quot;sex&quot;, &quot;tax.bracket.&quot;, and other &quot;x&quot;-containing
variable names. Use of not.vars allows you to indicate variables that match
your vars argument that you do not wish to attempt to value-label. Note that
not.vars gets priority: setting vars=&quot;x&quot;, partial=TRUE, and not.vars=&quot;x&quot; is
tantamount to telling add_m1_lab() that you actually do not wish to label
any of the variables that you specified in vars, resulting in no variables
receiving value labels.</p>
</td></tr>
<tr><td><code id="add_m1_lab_+3A_max.unique.vals">max.unique.vals</code></td>
<td>
<p><code>add_m1_lab</code>() will not assign value labels to non-
integer (i.e., decimal-having) numeric variables. The max.unique.vals
argument further constrains the variables that may receive value labels to
those whose total unique values do not exceed the integer value supplied to
this argument. Note that labelr sets a hard ceiling of 5000 on the total
number of unique value labels that any variable is permitted to have under
any circumstance, as labelr is primarily intended for interactive use with
moderately-sized (&lt;=~1M-row) data.frames.</p>
</td></tr>
<tr><td><code id="add_m1_lab_+3A_init">init</code></td>
<td>
<p>assign placeholder labels for variables that lack decimals
and meet the max.unique.vals threshold.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'
add_m1_lab<code style="white-space: pre;">&#8288;(and&#8288;</code>add1m1<code style="white-space: pre;">&#8288;) allows the user to assign the same value label to multiple distinct values of a variable ("m1" is short for "many-to-one"). This is in contrast to &#8288;</code>add_val_labs<code>and</code>add_val1', which require a strict
one-to-one mapping of distinct variable values and distinct value labels.
</p>
<p>Note 1: Each call to <code>add_m1_lab</code> accepts only one value label, which may be
applied to multiple distinct values of the specified column(s). Additional
labels can be applied to other values of the same column(s) by making
additional calls to <code>add_m1_lab</code> (see the example).
</p>
<p>Note 2: <code>am1l</code> is a compact alias for <code>add_m1_lab</code>: they do the same thing,
and the former is easier to type
</p>


<h3>Value</h3>

<p>A data.frame, with new variable value labels added (call
<code>get_val_labs</code> to see them), other provisional/default labelr label
information added, and previous user-added labelr label information
preserved.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- mtcars

df &lt;- add_m1_lab(df,
  vars = "carb",
  vals = 1:3,
  lab = "&lt;=3",
  max.unique.vals = 10
)

df &lt;- add_m1_lab(df,
  vars = "carb",
  vals = c(4, 6, 8),
  lab = "&gt;=4",
  max.unique.vals = 10
)

get_val_lab1(df, carb)

head(use_val_labs(df), 8) # they're there
</code></pre>

<hr>
<h2 id='add_name_labs'>Add or Modify Data Frame Variable Name Labels</h2><span id='topic+add_name_labs'></span><span id='topic+anl'></span>

<h3>Description</h3>

<p>Add descriptive variable name labels (up to one per column) to the columns of
a data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_name_labs(
  data,
  name.labs = NULL,
  vars = NULL,
  labs = NULL,
  init.max = NULL
)

anl(data, name.labs = NULL, vars = NULL, labs = NULL, init.max = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_name_labs_+3A_data">data</code></td>
<td>
<p>the data.frame you wish to begin labeling.</p>
</td></tr>
<tr><td><code id="add_name_labs_+3A_name.labs">name.labs</code></td>
<td>
<p>a named character vector, where names are current data.frame
column (variable) names, and where values are the proposed labels. If this is
NULL, vars and labs arguments may not be NULL. If latter are not NULL, this
(name.labs) argument must be NULL.</p>
</td></tr>
<tr><td><code id="add_name_labs_+3A_vars">vars</code></td>
<td>
<p>the names of the columns (variables) to which name labels will be
applied. If NULL, labs arg must also be NULL and name.labs cannot be NULL.</p>
</td></tr>
<tr><td><code id="add_name_labs_+3A_labs">labs</code></td>
<td>
<p>the proposed variable name labels to applied to the columns
(variables). If non-NULL, vars arg must also be non-NULL.</p>
</td></tr>
<tr><td><code id="add_name_labs_+3A_init.max">init.max</code></td>
<td>
<p>If non-NULL, this must be a 1L integer, indicating the maximum
number of unique values that a variable may have for it to receive placeholder
value labels, which will consist of the variable's actual values coerced to
character values. If NULL, or if the variable is numeric with decimal values,
the variable will not be given initialized variable value labels.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: <code>anl</code> is a compact alias for <code>add_name_labs</code>: they do the same thing,
and the former is easier to type.
</p>
<p><code>add_name_labs</code> works with <code>get_name_labs</code>, <code>use_name_labs</code>, and
<code>use_var_names</code> to facilitate the creation, accessing, and substitution of
variable name labels for variable names.
</p>
<p>Each variable (column) of a data.frame can receive one and only one &quot;name
label,&quot; which typically is a noun phrase that expounds the meaning of
contents of the variable's name (e.g., &quot;Weight in ounces at birth&quot; might be a
name label for a column called &quot;wgt&quot;). <code>add_name_labs </code>takes a data.frame and
either a named character vector (names are current variable names, values are
proposed name labels) supplied to the name.labs arg or two separate character
vectors (one each for current variable names and proposed variable name
labels, respectively) supplied to vars and labs args, respectively. If using
the second approach, the order of each entry matters (e.g., the first
variable name entry to the vars argument will be given the label of the first
name label entry to the labs argument, and so on).
</p>
<p>Note that any non-name-labeled columns will receive their own names as
default name labels (e.g., if var &quot;mpg&quot; of mtcars is not assigned a name
label, it will be given the default name label of &quot;mpg&quot;). Note also that
other labelr functions (e.g., <code>add_val_labs</code>) will initialize name labels
and other labelr attribute meta-data in this same fashion. Name labels can
be removed with <code>drop_name_labs</code>.
</p>


<h3>Value</h3>

<p>A data.frame, with new name labels added (call <code>get_name_labs</code> to
see them), other provisional/default labelr label information added, and
previous user-added labelr label information preserved.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a data set
df &lt;- mtcars

# variable names and their labels
names_labs_vec &lt;- c(
  "mpg" = "Miles/(US) gallon",
  "cyl" = "Number of cylinders",
  "disp" = "Displacement (cu.in.)",
  "hp" = "Gross horsepower",
  "drat" = "Rear axle ratio",
  "wt" = "Weight (1000 lbs)",
  "qsec" = "1/4 mile time",
  "vs" = "Engine (0 = V-shaped, 1 = straight)",
  "am" = "Transmission (0 = automatic, 1 = manual)",
  "gear" = "Number of forward gears",
  "carb" = "Number of carburetors"
)

# assign variable labels
df &lt;- add_name_labs(df,
  vars = names(names_labs_vec),
  labs = names_labs_vec
)

# see what we have
get_name_labs(df)

# use these
df_labs_as_names &lt;- use_name_labs(df)
head(df_labs_as_names)[1:3] # these are verbose, so, only show first three
head(df)[1:3]

# now revert back
df_names_as_before &lt;- use_var_names(df_labs_as_names)
head(df_names_as_before)[1:3] # indeed, they are as before
identical(head(df), head(df_names_as_before))

# strip name label meta-data information from df
# NOT same as use_var_names(), which preserves the info but "turns it off"
# this strips the name labels meta-data from df altogether
df &lt;- drop_name_labs(df)

# see what we have
get_name_labs(df) # they're gone

# alternative syntax (if you have a named vector like names_labs_vec)
# assign variable name labels
df &lt;- add_name_labs(df,
  name.labs = c(
    "mpg" = "Miles/(US) gallon",
    "cyl" = "Number of cylinders",
    "disp" = "Displacement (cu.in.)",
    "hp" = "Gross horsepower",
    "drat" = "Rear axle ratio",
    "wt" = "Weight (1000 lbs)",
    "qsec" = "1/4 mile time",
    "vs" = "Engine (0 = V-shaped, 1 = straight)",
    "am" = "Transmission (0 = automatic, 1 = manual)",
    "gear" = "Number of forward gears",
    "carb" = "Number of carburetors"
  )
)

# replace two variable name labels, keeping the others
df &lt;- add_name_labs(df,
  name.labs = c(
    "disp" = toupper("displacement"),
    "mpg" = toupper("miles per gallon")
  )
)

attributes(df) # show all attributes
get_name_labs(df) # show only the variable name labels
get_name_labs(df, var = c("disp", "mpg"))

# again, strip name label meta-data information from df
# NOT same as use_var_names(), which preserves the info but "turns it off"
df &lt;- drop_name_labs(df)

# see what we have
get_name_labs(df) # they're gone

# alternative syntax to add name labels
df &lt;- add_name_labs(df,
  vars = c("carb", "am"),
  labs = c("how many carburetors?", "automatic or stick?")
)

# see what we have
get_name_labs(df) # they're back! (and placeholders for others)

# add another
df &lt;- add_name_labs(df,
  vars = c("mpg"),
  labs = c("miles per gallon, of course")
)

# see what we have
get_name_labs(df) # it's been added, and others preserved

head(use_name_labs(df)[c(1, 9, 11)]) # verbose, but they're there
</code></pre>

<hr>
<h2 id='add_quant_labs'>Associate Numerical Threshold-based Value Labels with Select Numerical Variables</h2><span id='topic+add_quant_labs'></span><span id='topic+aql'></span>

<h3>Description</h3>

<p>Add variable-specific value labels based on threshold cuts of a numerical
variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_quant_labs(
  data,
  vars,
  qtiles = NULL,
  vals = NULL,
  labs = NULL,
  partial = FALSE,
  not.vars = NULL
)

aql(
  data,
  vars,
  qtiles = NULL,
  vals = NULL,
  labs = NULL,
  partial = FALSE,
  not.vars = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_quant_labs_+3A_data">data</code></td>
<td>
<p>a data.frame.</p>
</td></tr>
<tr><td><code id="add_quant_labs_+3A_vars">vars</code></td>
<td>
<p>a character vector that corresponds to the name(s) of one or more
variables to which value threshold-based labels will be added.</p>
</td></tr>
<tr><td><code id="add_quant_labs_+3A_qtiles">qtiles</code></td>
<td>
<p>the number of quantile categories to employ (e.g., 4 would
indicate quartiles, 5 would indicate quintiles, 10 for deciles, etc.). If
NULL, vals must be non-NULL.</p>
</td></tr>
<tr><td><code id="add_quant_labs_+3A_vals">vals</code></td>
<td>
<p>one more values of vars that will define range cutpoints, such
that all values at or below a given number and above the preceding val will
be treated as part of the same numerical range for labeling purposes. If
NULL, qtiles must be non-NULL.</p>
</td></tr>
<tr><td><code id="add_quant_labs_+3A_labs">labs</code></td>
<td>
<p>a character vector of distinct labels to identify the
quantiles. If left NULL, convention &quot;q&quot; + quantile (e.g., &quot;q10&quot;) will be used
for qtile-based labels (i.e., if qtiles arg is non-NULL), and convention
&quot;&lt;=&quot; + val will be used for vals argument-based labels (i.e., if vals arg is
non-NULL). Note that the labels &quot;NA&quot; and &quot;Other&quot; are (non-case-sensitively)
reserved and may not be user-supplied.</p>
</td></tr>
<tr><td><code id="add_quant_labs_+3A_partial">partial</code></td>
<td>
<p>To apply the same numerical value labeling scheme to many
variables at once, you can provide those variable names explicitly (e.g.,
vars = c(&quot;x1&quot;,&quot;x2&quot;, &quot;x3&quot;) or vars = paste0(&quot;x&quot;, 1:3), or you can provide a
substring only and set partial = TRUE (default is FALSE). For example, to
apply the same labeling scheme to vars &quot;x1&quot;, &quot;x2&quot; ... sequentially through
&quot;x10&quot;, you could use vars = c(&quot;x&quot;), along with partial = TRUE. Be careful with
this, as it also will attempt to apply the scheme to &quot;sex&quot; or &quot;tax.bracket&quot;,
etc. (See not.vars argument for a way to mitigate this.)</p>
</td></tr>
<tr><td><code id="add_quant_labs_+3A_not.vars">not.vars</code></td>
<td>
<p>use of the partial argument can result in situations where
you inadvertently attempt to value-label a variable. For example, if vars=&quot;x&quot;
and partial=TRUE, then <code>add_quant_labs</code> will attempt to label not only &quot;x1&quot;,
&quot;x2&quot;,&quot;x3&quot;, and &quot;x4&quot;, but also &quot;sex&quot;, &quot;tax.bracket.&quot;, and other &quot;x&quot;-containing
variable names. Use of not.vars allows you to indicate variables that match
your vars argument that you do not wish to attempt to value-label. Note that
not.vars gets priority: setting vars=&quot;x&quot;, partial=TRUE, and not.vars=&quot;x&quot; is
tantamount to telling add_val_labs() that you actually do not wish to label
any of the variables that you specified in vars, resulting in no variables
receiving value labels.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: <code>aql</code> is a compact alias for <code>add_quant_labs</code>: they do the same thing,
and the former is easier to type.
</p>
<p>Numerical variables that feature decimals or large numbers of distinct values
are not eligible to receive conventional value labels. <code>add_quant_labs</code> allows
one to label such variables according to user-supplied value thresholds
(i.e., cutpoints) OR quantile membership, Thus, unlike value labels added
with <code>add_val_labs</code> (and <code>add_val1</code>), <code>add_quant_labs</code> (and <code>add_quant1</code>)
will apply the same value label to all values that fall within the numerical
value range defined by each threshold (cutpoint). For still another
value-labeling approach, see <code>add_m1_lab</code> (and <code>add1m1</code>).
</p>
<p>Note: Quantity labels cannot be added incrementally through repeated calls
to <code>add_quant_labs</code>: each new call will overwrite all value labels applied to
the specified vars in any previous <code>add_quant_labs</code> calls. This is in
contrast to <code>add_val_labs</code> (which allows for incremental value-labeling) and
<code>add_m1_lab</code> (which requires incremental value-labeling).
</p>


<h3>Value</h3>

<p>A data.frame, with new variable value labels added (call
<code>get_val_labs</code> to see them), other provisional/default labelr label
information added, and previous user-added labelr label information
preserved.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># mtcars demo
df &lt;- mtcars
# now, add value labels
df &lt;- add_val_labs(
  data = df,
  vars = "am",
  vals = c(0, 1),
  labs = c("automatic", "manual")
)

# label variable "mpg" in terms of 5 quintiles
df &lt;- add_quant_labs(data = df, vars = "mpg", qtiles = 5)

# label variable "disp" in terms of "pretty" cutpoints
vals2use &lt;- pretty(c(min(df$disp), max(df$disp)))[-1] # establish cutpoints
df &lt;- add_quant_labs(data = df, vars = "disp", vals = vals2use)
df_labson &lt;- use_val_labs(df)
head(df_labson)
</code></pre>

<hr>
<h2 id='add_quant1'>Associate Numerical Threshold-based Value Labels with a Single Numerical Variable</h2><span id='topic+add_quant1'></span><span id='topic+aql1'></span>

<h3>Description</h3>

<p>Add variable-specific value labels based on threshold cuts of a single
numerical variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_quant1(data, var, qtiles = NULL, vals = NULL, labs = NULL)

aql1(data, var, qtiles = NULL, vals = NULL, labs = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_quant1_+3A_data">data</code></td>
<td>
<p>a data.frame.</p>
</td></tr>
<tr><td><code id="add_quant1_+3A_var">var</code></td>
<td>
<p>the unquoted name of the variable to which value labels will be
added.</p>
</td></tr>
<tr><td><code id="add_quant1_+3A_qtiles">qtiles</code></td>
<td>
<p>the number of quantile categories to employ (e.g., 4 would
indicate quartiles, 5 would indicate quintiles, 10 for deciles, etc.). If
NULL, vals must be non-NULL.</p>
</td></tr>
<tr><td><code id="add_quant1_+3A_vals">vals</code></td>
<td>
<p>one more values of var that will define range cutpoints, such
that all values at or below a given number and above the preceding val will
be treated as part of the same numerical range for labeling purposes. If
NULL, qtiles must be non-NULL.</p>
</td></tr>
<tr><td><code id="add_quant1_+3A_labs">labs</code></td>
<td>
<p>a character vector of distinct labels to identify the
quantiles. If left NULL, convention &quot;q&quot; + quantile (e.g., &quot;q10&quot;) will be used
for qtile-based labels (i.e., if qtiles arg is non-NULL), and convention
&quot;&lt;=&quot; + val will be used for vals argument-based labels (i.e., if vals arg is
non-NULL). Note that the labels &quot;NA&quot; and &quot;Other&quot; are (non-case-sensitively)
reserved and may not be user-supplied.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>add_quant1</code> is a variant of <code>add_quant_labs</code> that allows you to specify only
one var to label but allows you to pass its name without quoting it
(compare <code>add_quant1</code>(mtcars, mpg) to <code>add_quant_labs</code>(mtcars, &quot;mpg&quot;).
</p>
<p>Numerical variables that feature decimals or large numbers of distinct values
are not eligible to receive conventional value labels. <code>add_quant1</code> allows
one to label such variables according to user-supplied value thresholds
(i.e., cutpoints) OR quantile membership, Thus, unlike value labels added
with <code>add_val_labs</code> (and <code>add_val1</code>), <code>add_quant1</code> (and <code>add_quant_labs</code>)
will apply the same value label to all values that fall within the numerical
value range defined by each threshold (cutpoint). For still another
value-labeling approach, see <code>add_m1_lab</code> (and <code>add1m1</code>).
</p>
<p>Note 1: Quantity labels cannot be added incrementally through repeated calls
to <code>add_quant1</code>: each new call will overwrite all value labels applied to
the specified vars in any previous <code>add_quant1</code> calls. This is in contrast to
<code>add_val_labs</code> (which allows for incremental value-labeling) and <code>add_m1_lab</code>
(which requires incremental value-labeling).
</p>
<p>Note 2: <code>aql1</code> is a compact alias for <code>add_quant1</code>: they do the same thing, and
the former is easier to type
</p>
<p>Note 3: This command is intended exclusively for interactive use. In
particular, the var argument must be the literal name of a single variable
(column) found in the supplied data.frame and may NOT be, e.g., the name of a
character vector that contains the variable (column name) of interest. If you
wish to supply a character vector with the names of variables (columns) of
interest, use <code>add_quant_labs()</code>.
</p>


<h3>Value</h3>

<p>A data.frame, with new variable value labels added (call
<code>get_val_labs</code> to see them), other provisional/default labelr label
information added, and previous user-added labelr label information
preserved.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># mtcars demo
df &lt;- mtcars
# now, add value labels
df &lt;- add_val_labs(
  data = df,
  vars = "am",
  vals = c(0, 1),
  labs = c("automatic", "manual")
)

# label variable "mpg" in terms of 5 quintiles
df &lt;- add_quant1(data = df, mpg, qtiles = 5)

# label variable "disp" in terms of "pretty" cutpoints
vals2use &lt;- pretty(c(min(df$disp), max(df$disp)))[-1] # establish cutpoints
df &lt;- add_quant1(data = df, disp, vals = vals2use)
df_labson &lt;- use_val_labs(df)
head(df_labson)
</code></pre>

<hr>
<h2 id='add_val_labs'>Add or Modify a Variable's Value Labels</h2><span id='topic+add_val_labs'></span><span id='topic+avl'></span>

<h3>Description</h3>

<p>Add variable value-specific, descriptive value labels to a data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_val_labs(
  data,
  vars,
  vals,
  labs,
  partial = FALSE,
  not.vars = NULL,
  max.unique.vals = 10,
  init = FALSE
)

avl(
  data,
  vars,
  vals,
  labs,
  partial = FALSE,
  not.vars = NULL,
  max.unique.vals = 10,
  init = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_val_labs_+3A_data">data</code></td>
<td>
<p>a data.frame.</p>
</td></tr>
<tr><td><code id="add_val_labs_+3A_vars">vars</code></td>
<td>
<p>a character vector that corresponds to the name(s) of one or more
variables to which value labels will be added.</p>
</td></tr>
<tr><td><code id="add_val_labs_+3A_vals">vals</code></td>
<td>
<p>a vector of distinct values of the actual variable, each of which
is to be associated with a label supplied to the labs argument in the same
positional order (e.g., vals = c(1,0), labs = c(&quot;manual&quot;, &quot;automatic&quot;) will
associate lab &quot;manual&quot; with val 1 and lab &quot;automatic&quot; with val 0.). Note:
NA and other &quot;irregular&quot; (e.g., NaN, Inf) values all are automatically
assigned the label &quot;NA&quot;, and this cannot be overridden. Note that you do not
need to specify all unique vals of var, and you can supply value labels
incrementally, one (or a few, or all) unique vals of var at a time. Once
you've added the value label, it is bound to that value until you drop it
(see <code>drop_val_labs</code>) or some other action (intentional or otherwise) strips
or overwrites it.</p>
</td></tr>
<tr><td><code id="add_val_labs_+3A_labs">labs</code></td>
<td>
<p>a character vector of distinct label values, each of which
is to be associated with exactly one corresponding distinct value (vals
argument element) of the variable(s) identified in the vars argument. The
order of labs argument must match that of vals argument entries (e.g., if a
three-element vector of values is supplied to vals, then a three-element
vector of proposed labels must be supplied to labs, and the first value of
vals will get the first label of labs, the second value of vals will get the
second label of labs, etc.). Note: NA and other &quot;irregular&quot; (e.g., NaN, Inf)
values are automatically assigned the label &quot;NA&quot; and may not be assigned
another label.</p>
</td></tr>
<tr><td><code id="add_val_labs_+3A_partial">partial</code></td>
<td>
<p>To apply the same value labeling scheme to many variables
at once, you can provide those variable names explicitly (e.g., vars =
c(&quot;x1&quot;,&quot;x2&quot;, &quot;x3&quot;) or vars = paste0(&quot;x&quot;, 1:3), or you can provide a substring
only and set partial = TRUE (default is FALSE). For example, to apply the
same labeling scheme to vars &quot;x1&quot;, &quot;x2&quot; ... sequentially through &quot;x10&quot;,
you could use vars = c(&quot;x&quot;), along with partial = TRUE. Be careful with
this, as it also will attempt to apply the scheme to &quot;sex&quot; or &quot;tax.bracket&quot;,
etc.</p>
</td></tr>
<tr><td><code id="add_val_labs_+3A_not.vars">not.vars</code></td>
<td>
<p>use of the partial argument can result in situations where
you inadvertently attempt to value-label a variable. For example, if vars=&quot;x&quot;
and partial=TRUE, then <code>add_val_labs</code> will attempt to label not only &quot;x1&quot;,
&quot;x2&quot;,&quot;x3&quot;, and &quot;x4&quot;, but also &quot;sex&quot;, &quot;tax.bracket.&quot;, and other &quot;x&quot;-containing
variable names. Use of not.vars allows you to indicate variables that match
your vars argument that you do not wish to attempt to value-label. Note that
not.vars gets priority: setting vars=&quot;x&quot;, partial=TRUE, and not.vars=&quot;x&quot; is
tantamount to telling add_val_labs() that you actually do not wish to label
any of the variables that you specified in vars, resulting in no variables
receiving value labels.</p>
</td></tr>
<tr><td><code id="add_val_labs_+3A_max.unique.vals">max.unique.vals</code></td>
<td>
<p><code>add_val_labs</code>() will not assign value labels to non-
integer (i.e., decimal-having) numeric variables. The max.unique.vals
argument further constrains the variables that may receive value labels to
those whose total unique values do not exceed the integer value supplied to
this argument. Note that labelr sets a hard ceiling of 5000 on the total
number of unique value labels that any variable is permitted to have under
any circumstance, as labelr is primarily intended for interactive use with
moderately-sized (&lt;=~1M-row) data.frames.</p>
</td></tr>
<tr><td><code id="add_val_labs_+3A_init">init</code></td>
<td>
<p>assign placeholder labels for variables that lack decimals
and meet the max.unique.vals threshold.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: <code>avl</code> is a compact alias for <code>add_val_labs</code>: they do the same thing,
and the former is easier to type
</p>
<p><code>add_val_labs</code> is intended for associating value labels with binary,
nominal, or ordinal (e.g., integer) variables, where each of a limited number
of distinct values is to be associated one-to-one with a distinct value label.
To assign labels to ranges of numerical variables, see <code>add_quant_labs</code> (or
<code>add_quant1</code>). To apply the same label to multiple distinct values of a
variable, see <code>add_m1_lab</code> or <code>add1m1</code>.
</p>
<p><code>add_val_labs</code> works with other labelr functions (e.g., <code>add_val1</code>,
<code>drop_val_labs</code>, <code>get_val_labs</code>, <code>use_val_labs</code>, <code>add_lab_cols</code>) to
facilitate the creation, accessing, modification, use, or deletion of
variable value labels.
</p>
<p>When using <code>add_val_labs</code> or <code>add_val1</code>, each distinct variable value can
receive one and only one value label, and for any given variable, each unique
label can be assigned to only one unique value (e.g., mtcars$gear==3 and
mtcars$gear==4 cannot both share a single &quot;3 or 4 gears&quot; label: each of these
two distinct values must have its own label). This latter constraint may be
relaxed by using <code>add_m1_lab</code>.
</p>
<p>If partial = TRUE, <code>add_val_labs</code> will apply the specified labeling scheme to
all variables that contain a key variable name substring of interest
(supplied to the vars argument), which may be one or more variables found in
the data.frame (see Example #2).
</p>


<h3>Value</h3>

<p>A data.frame, with new variable value labels added (call
<code>get_val_labs</code> to see them), other provisional/default labelr label
information added, and previous user-added labelr label information
preserved.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example #1 - mtcars example, one variable at a time
# one variable at a time, mtcars
df &lt;- mtcars
# now, add value labels
df &lt;- add_val_labs(
  data = df,
  vars = "am",
  vals = c(0, 1),
  labs = c("automatic", "manual")
)

df &lt;- add_val_labs(
  data = df,
  vars = "carb",
  vals = c(1, 2, 3, 4, 6, 8),
  labs = c(
    "1-carb", "2-carbs",
    "3-carbs", "4-carbs",
    "6-carbs", "8-carbs"
  )
)

# var arg can be unquoted if using add_val1()
# note that this is not add_val_labs(); add_val1() has "var" (not "vars" arg)
df &lt;- add_val1(
  data = df,
  var = cyl, # note, "var," not "vars" arg
  vals = c(4, 6, 8),
  labs = c(
    "four-cyl",
    "six-cyl",
    "eight-cyl"
  )
)

df &lt;- add_val_labs(
  data = df,
  vars = "gear",
  vals = c(3, 4),
  labs = c(
    "3-speed",
    "4-speed"
  )
)

# Oops, we forgot 5-speeds; let's finish the job.
df &lt;- add_val_labs(
  data = df,
  vars = "gear",
  vals = 5,
  labs = "5-speed"
)

head(use_val_labs(df), 3) # they're there

# Example #2 - (Fake) Likert Data
# add val labs to multiple variables at once
# make a "Likert"-type fake data set to demo
# note, by default, add_val_labs() "vars" arg will do partial matching
# in this case, we catch all vars with "x" in their name
set.seed(272)
dflik &lt;- make_likert_data(scale = 1:7)
vals2label &lt;- 1:7
labs2use &lt;- c(
  "VSD",
  "SD",
  "D",
  "N",
  "A",
  "SA",
  "VSA"
)

dflik &lt;- add_val_labs(
  data = dflik, vars = c("x", "y3"), # note the vars args
  vals = vals2label,
  labs = labs2use,
  partial = TRUE
)

# note, all "x" vars get the labs, as does "y3"
# see vars = args above
lik1 &lt;- use_val_labs(dflik)
head(lik1)
# keep a copy
dflik_conv &lt;- use_val_labs(dflik)
head(dflik_conv, 3)
</code></pre>

<hr>
<h2 id='add_val1'>Add or Modify a Single Variable's Value Labels</h2><span id='topic+add_val1'></span><span id='topic+avl1'></span>

<h3>Description</h3>

<p>Add variable value-specific, descriptive value labels to a data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_val1(data, var, vals, labs, max.unique.vals = 10, init = FALSE)

avl1(data, var, vals, labs, max.unique.vals = 10, init = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_val1_+3A_data">data</code></td>
<td>
<p>a data.frame.</p>
</td></tr>
<tr><td><code id="add_val1_+3A_var">var</code></td>
<td>
<p>the unquoted name of the variable (column) to which value labels
will be added.</p>
</td></tr>
<tr><td><code id="add_val1_+3A_vals">vals</code></td>
<td>
<p>a vector of distinct values of the actual variable, each of which
is to be associated with a label supplied to the labs argument in the same
positional order (e.g., vals = c(1,0), labs = c(&quot;manual&quot;, &quot;automatic&quot;) will
associate lab &quot;manual&quot; with val 1 and lab &quot;automatic&quot; with val 0.). Note:
NA and other &quot;irregular&quot; (e.g., NaN, Inf) values all are automatically
assigned the label &quot;NA&quot;, and this cannot be overridden. Note that you do not
need to specify all unique vals of var, and you can supply value labels
incrementally, one (or a few, or all) unique vals of var at a time. Once
you've added the value label, it is bound to that value until you drop it
(see <code>drop_val_labs</code>) or some other action (intentional or otherwise) strips
or overwrites it.</p>
</td></tr>
<tr><td><code id="add_val1_+3A_labs">labs</code></td>
<td>
<p>a character vector of distinct label values, each of which
is to be associated with exactly one corresponding distinct value (vals
argument element) of the variable identified in the var argument. The
order of labs argument must match that of vals argument entries (e.g., if a
three-element vector of values is supplied to vals, then a three- element
vector of proposed labels must be supplied to labs, and the first value of
vals will get the first label of labs, the second value of vals will get the
second label of labs, etc.). Note: NA and other &quot;irregular&quot; (e.g., NaN, Inf)
values are automatically assigned the label &quot;NA&quot; and may not be assigned
another label.</p>
</td></tr>
<tr><td><code id="add_val1_+3A_max.unique.vals">max.unique.vals</code></td>
<td>
<p><code>add_val1</code>() will not assign value labels to non-
integer (i.e., decimal-having) numeric variables. The max.unique.vals
argument further constrains the variables that may receive value labels to
those whose total unique values do not exceed the integer value supplied to
this argument. Note that labelr sets a hard ceiling of 5000 on the total
number of unique value labels that any variable is permitted to have under
any circumstance, as labelr is primarily intended for interactive use with
moderately-sized (&lt;=~1M-row) data.frames.</p>
</td></tr>
<tr><td><code id="add_val1_+3A_init">init</code></td>
<td>
<p>assign placeholder labels for variables that lack decimals
and meet the max.unique.vals threshold.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>add_val1</code> is intended for associating value labels with binary, nominal, or
ordinal (e.g., integer) variables, where each of a limited number of distinct
values is to be associated one-to-one with a distinct value label. To assign
labels to ranges of numerical variables, see <code>add_quant_labs</code> (or
<code>add_quant1</code>). To apply the same label to multiple distinct values of a
variable, see <code>add_m1_lab</code> or <code>add1m1</code>.
</p>
<p><code>add_val1</code> works with other labelr functions (e.g., <code>add_val_labs</code>,
<code>drop_val_labs</code>, <code>get_val_labs</code>, <code>use_val_labs</code>, <code>add_lab_cols</code>) to
facilitate the creation, accessing, modification, use, or deletion of
variable value labels.
</p>
<p>Note 1: <code>add_val1</code> is a variant of <code>add_val_labs</code> that allows you to specify
only one var to label at a time but that allows you to pass its name without
quoting it (compare add_val1(mtcars, am) to add_val_labs(mtcars, &quot;am&quot;).
</p>
<p>Note 2: <code>avl1</code> is a compact alias for <code>add_val1</code>: they do the same thing,
and the former is easier to type
</p>
<p>Note 3: This command is intended exclusively for interactive use. In
particular, the var argument must be the literal name of a single variable
(column) found in the supplied data.frame and may NOT be, e.g., the name of a
character vector that contains the variable (column name) of interest. If you
wish to supply a character vector with the names of variables (columns) of
interest, use <code>add_val_labs()</code>.
</p>


<h3>Value</h3>

<p>A data.frame, with new name labels added (call <code>get_val_labs</code> to see
them), other provisional/default labelr label information added, and previous
user-added labelr label information preserved.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># one variable at a time, mtcars
df &lt;- mtcars
# add value labels
# first, using add_val_labs() -- add_val1() example is below
df &lt;- add_val_labs(
  data = df,
  vars = "carb", # note, vars arg; add_val1() takes var arg
  vals = c(1, 2, 3, 4, 6, 8),
  labs = c(
    "1-carb", "2-carbs",
    "3-carbs", "4-carbs",
    "6-carbs", "8-carbs"
  )
)

# now, using add_val1(), where single var arg can be unquoted (cyl, not "cyl")
# note that this is not add_val_labs();
df &lt;- add_val1(
  data = df,
  var = cyl, # note, var arg, not vars arg
  vals = c(4, 6, 8),
  labs = c(
    "four-cyl",
    "six-cyl",
    "eight-cyl"
  )
)

</code></pre>

<hr>
<h2 id='add1m1'>Apply One Label to Multiple Values for a Single Variable</h2><span id='topic+add1m1'></span>

<h3>Description</h3>

<p>Apply a single variable value label to multiple values of a variable
(&quot;m1&quot; is shorthand for &quot;many values get one label&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add1m1(data, var, vals, lab, max.unique.vals = 10, init = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add1m1_+3A_data">data</code></td>
<td>
<p>a data.frame.</p>
</td></tr>
<tr><td><code id="add1m1_+3A_var">var</code></td>
<td>
<p>the unquoted name of the variable (column) to which value labels
will be added.</p>
</td></tr>
<tr><td><code id="add1m1_+3A_vals">vals</code></td>
<td>
<p>a vector of distinct values of the actual variable, each of which
is to be associated with the label supplied to the lab argument. Note: NA and
other &quot;irregular&quot; (e.g., NaN, Inf) values all are automatically assigned the
label &quot;NA&quot;, and this cannot be overridden. Note that you do not need to
specify all unique vals of var, and you can supply value labels
incrementally, one (or a few, or all) unique vals of var at a time. However,
if you do this, do not re-use a value label or repeat a value-label
assignment you have already made: Once you've added the value label, it is
bound to those values until you drop the label (see <code>drop_val_labs</code>) or some
other action (intentional or otherwise) strips the value label attributes
from your data.frame (see, e.g. <code>strip_labs</code>).</p>
</td></tr>
<tr><td><code id="add1m1_+3A_lab">lab</code></td>
<td>
<p>a single distinct label that will be associated with all values
specified in your vals argument. Note: NA and other &quot;irregular&quot; (e.g.,
NaN, Inf) values are automatically assigned the label &quot;NA&quot; and may not be
assigned another label.</p>
</td></tr>
<tr><td><code id="add1m1_+3A_max.unique.vals">max.unique.vals</code></td>
<td>
<p><code>add1m1</code>() will not assign value labels to non-
integer (i.e., decimal-having) numeric variables. The max.unique.vals
argument further constrains the variables that may receive value labels to
those whose total unique values do not exceed the integer value supplied to
this argument.</p>
</td></tr>
<tr><td><code id="add1m1_+3A_init">init</code></td>
<td>
<p>assign placeholder labels for variables that lack decimals
and meet the max.unique.vals threshold.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note 1: <code>add1m1</code> is a variant of <code>add_m1_lab</code> that allows you to specify
only one var to label but allows you to pass its name without quoting it
(compare <code>add1m1</code>(mtcars, am, ...) to <code>add_m1_lab</code>(mtcars, &quot;carb&quot;, ...).
</p>
<p>Note 2: <code>add1m1</code> (and <code>add_m1_lab</code>) allows the user to assign the same value
label to multiple distinct values of a variable (&quot;m1&quot; is short for
&quot;many-to-one&quot;). This is in contrast to <code>add_val1</code> (and <code>add_val_labs</code>), which
requires a strict one-to-one mapping of distinct variable values and distinct
value labels.
</p>
<p>Note 3: This command is intended exclusively for interactive use. In
particular, the var argument must be the literal name of a single variable
(column) found in the supplied data.frame and may NOT be, e.g., the name of a
character vector that contains the variable (column name) of interest. If you
wish to supply a character vector with the names of variables (columns) of
interest, use <code>add_m1_lab()</code>.
</p>


<h3>Value</h3>

<p>A data.frame, with new variable value labels added (call
<code>get_val_labs</code> to see them), other provisional/default labelr label
information added, and previous user-added labelr label information
preserved.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- mtcars

df &lt;- add1m1(df,
  var = carb,
  vals = 1:3,
  lab = "&lt;=3",
  max.unique.vals = 10
)

df &lt;- add1m1(df,
  var = carb,
  vals = c(4, 6, 8),
  lab = "&gt;=4",
  max.unique.vals = 10
)

head(use_val_labs(df), 8) # they're there
</code></pre>

<hr>
<h2 id='all_quant_labs'>Add Quantile-based Value Labels to All Numeric Vars that Meet Specifications</h2><span id='topic+all_quant_labs'></span><span id='topic+allq'></span>

<h3>Description</h3>

<p>Add variable-specific quantile-based value labels to all numeric variables of
a data.frame that meet specified conditions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_quant_labs(data, qtiles = 5, not.vars = NULL, unique.vals.thresh = 10)

allq(data, qtiles = 5, not.vars = NULL, unique.vals.thresh = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all_quant_labs_+3A_data">data</code></td>
<td>
<p>a data.frame.</p>
</td></tr>
<tr><td><code id="all_quant_labs_+3A_qtiles">qtiles</code></td>
<td>
<p>the number of quantile categories to employ (e.g., 4 would
indicate quartiles, 5 would indicate quintiles, 10 for deciles, etc.).</p>
</td></tr>
<tr><td><code id="all_quant_labs_+3A_not.vars">not.vars</code></td>
<td>
<p>used to specify any numeric variables that should be exempted
from this operation.</p>
</td></tr>
<tr><td><code id="all_quant_labs_+3A_unique.vals.thresh">unique.vals.thresh</code></td>
<td>
<p>an integer. Numeric variables with fewer than this
many unique variables will be exempted from the operation (i.e., will NOT
receive quantile value labels).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: <code>allq</code> is a compact alias for <code>all_quant_labs</code>: they do the same thing,
and the former is easier to type.
</p>
<p>Numerical variables that feature decimals or large numbers of distinct values
are not eligible to receive conventional <code>add_val_labs()</code>-style value labels.
<code>all_quant_labs</code> allows one to label such variables based on quantile
thresholds.
</p>


<h3>Value</h3>

<p>A data.frame, with new variable value labels added.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># mtcars demo
df &lt;- mtcars
get_val_labs(df) # none
# add quintile val labs for all numeric vars with &gt;10 unique vals
df &lt;- all_quant_labs(data = df, qtiles = 5, unique.vals.thresh = 10)
get_val_labs(df) # here now
headl(df) # show them; note this is labelr::headl(), not utils::head()
</code></pre>

<hr>
<h2 id='all_uniquev'>Are All Values in a Free-standing Vector Unique?</h2><span id='topic+all_uniquev'></span><span id='topic+all_univ'></span>

<h3>Description</h3>

<p>For a given vector, does the length of (number of values in) the vector equal
the number of unique values in the vector?
</p>
<p>Note: <code>all_univ</code> is a compact alias for <code>all_uniquev</code>: they do the same
thing, and the former is easier to type
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_uniquev(x, na.rm = TRUE)

all_univ(x, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all_uniquev_+3A_x">x</code></td>
<td>
<p>a vector.</p>
</td></tr>
<tr><td><code id="all_uniquev_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical evaluating to TRUE or FALSE indicating whether NA
values should be stripped before the computation proceeds.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 1L logical.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>all_uniquev(mtcars$am) # FALSE

set.seed(35994)
z &lt;- runif(25)
all_univ(z) # TRUE; all_univ is an alias for all_uniquev()

z[c(1, 2)] &lt;- NA # two NA values added
all_univ(z, na.rm = FALSE) # FALSE, because the two NA values are not unique
</code></pre>

<hr>
<h2 id='as_base_data_frame'>Convert Augmented Data Frame to Base R Data Frame</h2><span id='topic+as_base_data_frame'></span><span id='topic+adf'></span>

<h3>Description</h3>

<p><code>as_base_data_frame</code> noisily converts an augmented data.frame to a Base R
data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_base_data_frame(data, fact.to.char = FALSE, irreg.to.na = FALSE)

adf(data, fact.to.char = FALSE, irreg.to.na = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_base_data_frame_+3A_data">data</code></td>
<td>
<p>a data.frame object.</p>
</td></tr>
<tr><td><code id="as_base_data_frame_+3A_fact.to.char">fact.to.char</code></td>
<td>
<p>coerce all factor variables to character variables.</p>
</td></tr>
<tr><td><code id="as_base_data_frame_+3A_irreg.to.na">irreg.to.na</code></td>
<td>
<p>convert all irregular values (see <code>irregular2v()</code>) to NA.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: <code>adf</code> is a compact alias for <code>as_base_data_frame</code>: they do the same
thing, and the former is easier to type
</p>
<p>To minimize dependencies and complexities, labelr label-assigning
functions are designed to work exclusively with Base R data.frames, not
alternative data structures like matrices or augmented data.frames, such as
data.tables or tibbles. The suggested labeling workflow is to first assign
and work with labels using a Base R data.frame and then convert the resulting
object to an augmented data.frame as desired and without any assumption that
labelr labels or functions will smoothly interoperate with the augmented
data.frame construct or functions that depend on it.
</p>
<p><code>as_base_data_frame</code> determines whether data argument is a conventional Base
R data.frame, some kind of augmented data.frame (e.g., data.table, tibble),
or not a data.frame at all (e.g., matrix). If the object has multiple
classes, one of which is a data.frame, the object is coerced to be a
conventional Base R data.frame, and a message to that effect is issued. If
the supplied object is not any kind of data.frame (i.e., a matrix is not any
kind of data.frame, while a data.table is a kind of data.frame), an error is
thrown. If the supplied object already is a Base R data.frame with no
additional classes (i.e., not an augmented data.frame), that supplied object
is returned with no changes made and no messages.
</p>


<h3>Value</h3>

<p>a data.frame object with any additional classes removed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- runif(10)
x2 &lt;- as.character(sample(c(1:20), 10, replace = TRUE))
x3 &lt;- sample(letters, size = 10, replace = TRUE)
df &lt;- data.frame(x1, x2, x3)
dft &lt;- tibble::as_tibble(df)
class(dft)
df_vanilla &lt;- as_base_data_frame(dft)
class(df_vanilla)
</code></pre>

<hr>
<h2 id='as_base_data_frame2'>Convert Augmented Data Frame to Base R Data Frame with Alternate Defaults</h2><span id='topic+as_base_data_frame2'></span><span id='topic+adf2'></span>

<h3>Description</h3>

<p><code>as_base_data_frame2</code> noisily converts an augmented data.frame to a Base R
data.frame, with any factors converted to character vectors, and any irregular
values (see <code>irregular2()</code>) converted to NA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_base_data_frame2(data, fact.to.char = TRUE, irreg.to.na = TRUE)

adf2(data, fact.to.char = TRUE, irreg.to.na = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_base_data_frame2_+3A_data">data</code></td>
<td>
<p>a data.frame object.</p>
</td></tr>
<tr><td><code id="as_base_data_frame2_+3A_fact.to.char">fact.to.char</code></td>
<td>
<p>coerce all factor variables to character variables.</p>
</td></tr>
<tr><td><code id="as_base_data_frame2_+3A_irreg.to.na">irreg.to.na</code></td>
<td>
<p>convert all irregular values (see <code>irregular2v()</code>) to NA.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: <code>adf2</code> is a compact alias for <code>as_base_data_frame</code>: they do the same
thing, and the former is easier to type
</p>
<p><code>as_base_data_frame2</code> is a variant of <code>as_base_data_frame</code> with different
default values for fact.to.char and irreg.to.na. Whereas both of these
default to FALSE in <code>as_base_data_frame</code>, they both default to TRUE in
<code>as_base_data_frame2</code>. This is the only difference between the two functions.
As such, <code>as_base_data_frame2</code> is intended as a simple shortcut to save
typing if one prefers to reverse these default logical argument values.
</p>


<h3>Value</h3>

<p>a data.frame object with any additional classes removed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iris_tib &lt;- tibble::as_tibble(iris)
class(iris_tib)
iris_tib$Sepal.Length[1] &lt;- Inf
head(iris_tib, 1)
iris_df &lt;- as_base_data_frame2(iris_tib)
class(iris_df)
sapply(iris_df, class)
head(iris_df, 1)
</code></pre>

<hr>
<h2 id='as_num'>Convert all Suitable Character Variables to Numeric</h2><span id='topic+as_num'></span>

<h3>Description</h3>

<p><code>as_num</code> identifies the character variables of a data.frame that can be
coerced to numeric without generating new NA values and, for those variables
where this can be done, it makes those conversions (similar to Stata's
destring command).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_num(data, nan2na = TRUE, inf2na = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_num_+3A_data">data</code></td>
<td>
<p>a data.frame object.</p>
</td></tr>
<tr><td><code id="as_num_+3A_nan2na">nan2na</code></td>
<td>
<p>a logical argument. TRUE if the non-case-sensitive string &quot;nan&quot;
should be converted to NA.</p>
</td></tr>
<tr><td><code id="as_num_+3A_inf2na">inf2na</code></td>
<td>
<p>a logical argument. TRUE if the non-case-sensitive strings
&quot;inf&quot; or &quot;-inf should be converted to NA.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Core labelr functions coerce integers to characters and back, which <code>as_num</code>
facilitates. Note that character values of &quot;NA&quot; (including &quot;na&quot;, &quot;Na&quot;,
and &quot;nA&quot;) will be converted to NA and, by default, so will other &quot;irregular&quot;
values (in the sense of <code>check_irregular</code>).
</p>


<h3>Value</h3>

<p>a data.frame object with all applicable character variables coerced
to numeric.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
x1 &lt;- runif(10)
x2 &lt;- as.character(sample(c(1:20), 10, replace = TRUE))
x3 &lt;- sample(letters, size = 10, replace = TRUE)
df &lt;- data.frame(x1, x2, x3)
head(df, 3)
sapply(df, class)
class(df$x2)

df &lt;- as_num(df)
head(df,3)
sapply(df, class)
class(df$x2)
</code></pre>

<hr>
<h2 id='as_numv'>Convert a Suitable Character Vector to Numeric</h2><span id='topic+as_numv'></span>

<h3>Description</h3>

<p><code>as_numv</code> determines whether a character vector can be coerced to numeric
without generating new NA values and, if so, it makes that conversion
(similar to Stata's destring command).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_numv(x, nan2na = TRUE, inf2na = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_numv_+3A_x">x</code></td>
<td>
<p>a character vector.</p>
</td></tr>
<tr><td><code id="as_numv_+3A_nan2na">nan2na</code></td>
<td>
<p>a logical argument. TRUE if the non-case-sensitive string &quot;nan&quot;
should be converted to NA.</p>
</td></tr>
<tr><td><code id="as_numv_+3A_inf2na">inf2na</code></td>
<td>
<p>a logical argument. TRUE if the non-case-sensitive strings
&quot;inf&quot; or &quot;-inf should be converted to NA.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Core labelr functions coerce integers to characters and back, which
<code>as_numv</code> facilitates. Note that character values of &quot;NA&quot; (including &quot;na&quot;,
&quot;Na&quot;, and &quot;nA&quot;) will be converted to NA and, by default, so will other
&quot;irregular&quot; values (in the sense of <code>check_irregular</code>).
</p>


<h3>Value</h3>

<p>a vector, converted to numeric if feasible (else, the same character
vector that was supplied).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
x1 &lt;- runif(10)
x2 &lt;- as.character(sample(c(1:20), 10, replace = TRUE))
x2_num &lt;- as_numv(x2)
class(x2)
class(x2_num)
head(x2)
</code></pre>

<hr>
<h2 id='axis_lab'>Retrieve Variable's Name Label for Plot Labeling</h2><span id='topic+axis_lab'></span><span id='topic+alb'></span>

<h3>Description</h3>

<p><code>axis_lab</code> accepts a data.frame and single unquoted variable name and returns
that variable's name label for use in axis labeling or plot labeling function
options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>axis_lab(data, var)

alb(data, var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="axis_lab_+3A_data">data</code></td>
<td>
<p>a data.frame.</p>
</td></tr>
<tr><td><code id="axis_lab_+3A_var">var</code></td>
<td>
<p>the unquoted name of a variable that exists in the data.frame and
is name-labeled (using <code>add_name_labs()</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note 1: <code>alb</code> is a compact alias for <code>axis_lab</code>: they do the same thing,
and the former is easier to type.
</p>
<p>Note 2: This command is intended exclusively for interactive use. In
particular, the var argument must be the literal name of a single variable
(column) found in the supplied data.frame and may NOT be, e.g., the name of a
character vector that contains the variable (column name) of interest.
</p>


<h3>Value</h3>

<p>a 1L character vector with var's name label.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># copy mtcars to df
# create a data set
df &lt;- mtcars

# variable names and their labels
names_labs_vec &lt;- c(
  "mpg" = "Miles/(US) gallon",
  "cyl" = "Number of cylinders",
  "wt" = "Weight (1000 lbs)"
)

df &lt;- add_name_labs(df, name.labs = names_labs_vec)

# ggplot example of axis_lab()
library(ggplot2)
p &lt;- ggplot(df, aes(mpg, wt, color = cyl)) +
  geom_point()
p &lt;- p +
  labs(color = axis_lab(df, cyl)) +
  xlab(axis_lab(df, mpg)) +
  ylab(axis_lab(df, wt))

# Base R plot example (using alb() alias)
with(df, plot(mpg, wt,
  xlab = alb(df, mpg),
  ylab = alb(df, wt)
))

</code></pre>

<hr>
<h2 id='check_any_lab_atts'>Check Whether Data Frame Has Any labelr Attributes</h2><span id='topic+check_any_lab_atts'></span>

<h3>Description</h3>

<p><code>check_any_lab_atts</code> returns FALSE if your data.frame has no labelr-generated
meta-data attributes (still) associated with it (at all or of a specific
sub-type), and TRUE if it does.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_any_lab_atts(data, labs = "any")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_any_lab_atts_+3A_data">data</code></td>
<td>
<p>the data.frame you are checking for the presence (or absence)
of labelr meta-data.</p>
</td></tr>
<tr><td><code id="check_any_lab_atts_+3A_labs">labs</code></td>
<td>
<p>which label meta-data you are looking for. Default of &quot;any&quot;
will look for types &quot;frame.lab&quot;, &quot;name.labs&quot;, &quot;val.labs&quot;, and &quot;factor.&quot;
(period is part of the substring), which are the core labelr meta-data.
To search more narrowly, you can try things like labs = &quot;val.labs&quot;,
labs=&quot;name.labs&quot;, etc.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default (labs = &quot;any&quot;), this function looks to see if your data.frame's
attributes includes any attribute with a name containing the substring
&quot;frame.lab&quot;, &quot;name.labs&quot;, &quot;val.labs&quot;, and/or &quot;factor.&quot; These are the core
substrings of the label meta-data attributes that labelr creates and
manipulates. If you wish to narrow your search for a specific labelr,
attribute, you may supply this as a character (sub)string (e.g.,
check_any_lab_atts(df, &quot;val.labs.cyl&quot;) to see if the variable &quot;cyl&quot;
has variable value label meta-data). But make sure that your second argument
is meaningful (e.g., check_any_lab_atts(iris, &quot;row.&quot;) will return TRUE
true based on the presence of a standard &quot;row.names&quot; attribute, which has
nothing to do with labels.
</p>


<h3>Value</h3>

<p>TRUE if any instance of the default or user-specified meta-data
attribute is found, FALSE if not.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># make toy demographic (gender, raceth, etc.) data set
set.seed(555)
df &lt;- make_demo_data(n = 1000) # another labelr:: function
# let's add variable VALUE labels for variable "raceth"
df &lt;- add_val_labs(df,
  vars = "raceth", vals = c(1:7),
  labs = c("White", "Black", "Hispanic", "Asian", "AIAN", "Multi", "Other"),
  max.unique.vals = 50
)

check_any_lab_atts(df)
</code></pre>

<hr>
<h2 id='check_class'>Determine If Vector Belongs to Any of Specified Classes</h2><span id='topic+check_class'></span>

<h3>Description</h3>

<p><code>check_class</code> determines whether a vector's class is among those specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_class(
  x,
  classes = c("numeric", "integer", "logical", "character", "factor", "ordered"),
  strict = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_class_+3A_x">x</code></td>
<td>
<p>the vector to check against specified classes.</p>
</td></tr>
<tr><td><code id="check_class_+3A_classes">classes</code></td>
<td>
<p>a character vector of classes against which x is checked.</p>
</td></tr>
<tr><td><code id="check_class_+3A_strict">strict</code></td>
<td>
<p>If TRUE, all of x's classes must be among those specified
in the classes argument. If FALSE, at least one but not necessarily all of
x's classes must be among those specified in the classes argument.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default (strict = TRUE), if a vector is of multiple classes, all of its
classes must be among those specified via the classes argument.
</p>


<h3>Value</h3>

<p>a 1L logical vector indicating whether x's class is found among those
passed to the classes argument.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>check_class(mtcars$mpg) # TRUE
check_class(mtcars$mpg, classes = c("numeric", "factor")) # TRUE
check_class(iris$Species) # TRUE
check_class(iris$Species, classes = c("logical", "numeric")) # FALSE
check_class(mtcars$mpg, classes = c("logical", "character", "factor")) # FALSE
</code></pre>

<hr>
<h2 id='check_irregular'>Check Vector for &quot;Irregular&quot; Values</h2><span id='topic+check_irregular'></span>

<h3>Description</h3>

<p>Check a vector for the presence of &quot;irregular&quot; values, defined as NA values,
other arbitrary values you specify, and (by default): NaN, Inf, -Inf, and
character variants of same (i.e., upper, lower, or mixed-case variants of
&quot;NA&quot;,&quot;NAN&quot;,&quot;INF&quot;,&quot;-INF&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_irregular(
  x,
  nan.include = TRUE,
  inf.include = TRUE,
  special = c("NA", "NAN", "INF", "-INF"),
  other = NULL,
  any = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_irregular_+3A_x">x</code></td>
<td>
<p>an atomic vector to checked for the presence of (any) NA values.</p>
</td></tr>
<tr><td><code id="check_irregular_+3A_nan.include">nan.include</code></td>
<td>
<p>treat NaN values as NA (i.e., return TRUE if present).</p>
</td></tr>
<tr><td><code id="check_irregular_+3A_inf.include">inf.include</code></td>
<td>
<p>treat Inf and -Inf values as NA (i.e., return TRUE if
present).</p>
</td></tr>
<tr><td><code id="check_irregular_+3A_special">special</code></td>
<td>
<p>a modifiable set of default character values that will be
treated as equivalent to NA values (i.e., will return TRUE if present).</p>
</td></tr>
<tr><td><code id="check_irregular_+3A_other">other</code></td>
<td>
<p>an argument for additional values of arbitrary but consistent
class (e.g., all numeric, all character) that will be treated as equivalent
to NA values (i.e., <code>check_irregular</code> will return TRUE where/if found).</p>
</td></tr>
<tr><td><code id="check_irregular_+3A_any">any</code></td>
<td>
<p>if TRUE, return a 1L vector that is TRUE if any irregular/NA-esque
value is found in the vector x, FALSE if no such value is found; if
any=FALSE, function will return a logical value for every element of x
(TRUE if that specific value meets the &quot;irregular&quot;-ity test).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>check_irregular</code> is used by core labelr functions (e.g., <code>add_val_labs</code>) to
ensure that NA and other irregular (e.g., Inf) values are handled in a simple
and consistent &ndash; and, hence, rigid &ndash; fashion. It is not intended as a user-
facing command as part of a labelr data-analytic workflow, though it may be
useful in other applications where one wishes to test a vector against a
focal and user-extensible class of NA-esque (or other) offending values.
</p>


<h3>Value</h3>

<p>A logical vector (1L if any==TRUE; length of x if any==FALSE).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># below is FALSE, because there is nothing NA-like in this vector
check_irregular(1:10)

# below is TRUE, because we're treating 99 as "NA-esque"
check_irregular(1:100, other = 99)

# below is TRUE, because of NA val
check_irregular(c(1:100, NA))

# below is TRUE, because nan.include is on (by default)
check_irregular(c(1:100, NaN), nan.include = TRUE)

# below is TRUE, because inf.include is on (by default)
check_irregular(c(1:100, Inf), inf.include = TRUE)

# below is TRUE, because inf.include is on (by default)
check_irregular(c(1:100, -Inf), inf.include = TRUE)

# below is FALSE, it's just letters
check_irregular(letters)

# below is TRUE - see default vals for arg special (function not case-sens)
check_irregular(c(letters, "NA"))

# below is TRUE - see default vals for arg special (function not case-sens)
check_irregular(c(letters, "NAN"))

# below is TRUE - see default vals for arg special (function not case-sens)
check_irregular(c(letters, "-iNf"))

# below is FALSE, search for irregular vals is not substring/regex-based
check_irregular(c(letters, "nan-iNf"))
</code></pre>

<hr>
<h2 id='check_labs_att'>Check Data Frame for Specified labelr Attribute</h2><span id='topic+check_labs_att'></span>

<h3>Description</h3>

<p><code>check_labs_att</code> returns TRUE if your data.frame has the specific attribute
indicated and FALSE if it does not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_labs_att(data, att = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_labs_att_+3A_data">data</code></td>
<td>
<p>the data.frame you are checking for the presence (or absence)
of labelr meta-data.</p>
</td></tr>
<tr><td><code id="check_labs_att_+3A_att">att</code></td>
<td>
<p>the specific label meta-data you are looking for. Default of NULL
will return TRUE if any valid labelr meta-data item of types &quot;frame.lab&quot;,
&quot;name.labs&quot;, &quot;val.labs&quot;, or &quot;factor.&quot; (period is part of the substring) is
present.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if any instance of the default or user-specified meta-data
attribute is found, FALSE if not.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># make toy demographic (gender, raceth, etc.) data set
set.seed(555)
df &lt;- make_demo_data(n = 1000) # another labelr:: function
# let's add variable VALUE labels for variable "race"
df &lt;- add_val_labs(df,
  vars = "raceth", vals = c(1:7),
  labs = c("White", "Black", "Hispanic", "Asian", "AIAN", "Multi", "Other"),
  max.unique.vals = 50
)

check_labs_att(df) # is any valid labelr lab(el) attribute present?
check_labs_att(df, "val.labs.race") # "race" lab specifically TRUE
</code></pre>

<hr>
<h2 id='clean_data_atts'>&quot;Clean&quot; Data Frame Attributes</h2><span id='topic+clean_data_atts'></span>

<h3>Description</h3>

<p>Drops name.lab and val.lab attributes associated with columns that are not
present in the data.frame (i.e., have been dropped) and re-arranges
data.frame attributes so that they appear in a clean, logical order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_data_atts(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clean_data_atts_+3A_data">data</code></td>
<td>
<p>a data.frame.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>labelr meta-data exist as data.frame attributes, added through interactive
use in a potentially haphazard order. This function, which is used inside
other labelr functions, drops labels for variables that are not (no longer)
present in the data.frame and re-arranges label and other data.frame
attributes to put them in a more, logical, user-readable order when accessed
via, e.g., <code>attributes()</code>.
</p>


<h3>Value</h3>

<p>A data.frame, with attributes re-arranged.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># make toy demographic (age, gender, raceth) data set
set.seed(555)
df &lt;- make_demo_data(n = 1000)

# let's add variable VALUE labels for variable "raceth"
df &lt;- add_val_labs(df,
  vars = "raceth", vals = c(1:7),
  labs = c("White", "Black", "Latino", "Asian", "AIAN", "Multi", "Other"),
  max.unique.vals = 50
)

# let's add variable VALUE labels for variable "gender"
df &lt;- add_val1(
  data = df, gender, vals = c(0, 1, 2),
  labs = c("M", "F", "O"), max.unique.vals = 50
)

# let's add variable NAME labels
df &lt;- add_name_labs(df, name.labs = c(
  "age" = "Age in years",
  "raceth" = "raceth category",
  "gender" = "gender assigned at birth"
))


# let's add a frame label
df &lt;- add_frame_lab(df, frame.lab = "This is a fictional data set that includes
                    demographic variables. It is generated by
                    labelr::make_demo_data")

# show attributes
attributes(df)

# re-arrange and show attributes
df2 &lt;- clean_data_atts(df)
attributes(df2)

# confirm that attributes from df are all present in df2
all(attributes(df) %in% attributes(df2)) # TRUE
</code></pre>

<hr>
<h2 id='convert_labs'>Convert from Haven-style to labelr Variable Value Labels</h2><span id='topic+convert_labs'></span>

<h3>Description</h3>

<p>Convert a data.frame with Haven package-style labels to a data.frame with
labelr name labels and <code>add_val_labs</code>-style one-to-one, value labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_labs(data, max.unique.vals = 50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_labs_+3A_data">data</code></td>
<td>
<p>the data.frame with Haven-style vector value label attributes.</p>
</td></tr>
<tr><td><code id="convert_labs_+3A_max.unique.vals">max.unique.vals</code></td>
<td>
<p>constrains the variables that may receive value labels
to those whose total unique values do not exceed the integer value supplied
to this argument. Note that labelr sets a hard ceiling of 5000 on the total
number of unique value labels that any variable is permitted to have under
any circumstance, as labelr is primarily intended for interactive use with
moderately-sized (&lt;=~1M-row) data.frames.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># convert haven vector labels to labelr value labels
library(haven)
library(tibble)
x1 &lt;- labelled(1:8, c(good = 1, bad = 5))
x2 &lt;- labelled(1:8, c(good = 1, mediocre = 4, bad = 5, horrible = 8))

# make this a tibble
hdf &lt;- tibble::tibble(x1, x2)
hdf # how it looks

# convert value labels to labelr label values
hdf1 &lt;- convert_labs(hdf)

# show select values of hdf1
head(hdf1)

# show that labelr labels are there for the using
head(use_val_labs(hdf1))

# filter hdf1 using x1's "bad" labelr value label (with flab())
head(flab(hdf1, x1 == "bad"), 3)

# filter hdf1 using x1's "good" value label (with flab())
head(flab(hdf1, x1 == "good"), 3)

# return select rows and columns with slab()
slab(hdf1, x2 %in% c("good", 2), x2)
slab(hdf1, x2 %in% c("good", 2), x1)

</code></pre>

<hr>
<h2 id='copy_var'>Copy a Data Frame Variable and its Value labels to Another Variable</h2><span id='topic+copy_var'></span>

<h3>Description</h3>

<p>Note: <code>copy_var</code> copies an existing variable and its value labels from a
data.frame to another new or (if force = TRUE) existing variable of the
data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>copy_var(data, from.var, to.var, force = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="copy_var_+3A_data">data</code></td>
<td>
<p>a data.frame to which variable value labels will be added.</p>
</td></tr>
<tr><td><code id="copy_var_+3A_from.var">from.var</code></td>
<td>
<p>the unquoted name of the variable whose values and labels will
be assigned to the to.var. This variable must presently exist in the data.frame.</p>
</td></tr>
<tr><td><code id="copy_var_+3A_to.var">to.var</code></td>
<td>
<p>the unquoted name of the variable to which the from.var's values
and labels will be assigned. If force = FALSE, this must be a new variable name
(one that does not refer to a variable that already exists in the data.frame).</p>
</td></tr>
<tr><td><code id="copy_var_+3A_force">force</code></td>
<td>
<p>if to.var already exists in the data.frame, allow it to be
overwritten. If FALSE, this will not be allowed, and an error will be issued.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Any non-labelr R operation that changes a variable's (column's) name or that
copies its contents to another variable (column) with a different name will
not associate the original variable's value labels with the new variable name.
To mitigate this, <code>copy_var</code> allows one to copy both a variable (column) and
its value labels and assign those to another variable.
</p>


<h3>Value</h3>

<p>A data.frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># make toy demographic (gender, raceth, etc.) data set
set.seed(555)
df &lt;- make_demo_data(n = 1000) # another labelr:: function
# let's add variable VALUE labels for variable "raceth"
df &lt;- add_val_labs(df,
  vars = "raceth", vals = c(1:7),
  labs = c("White", "Black", "Hispanic", "Asian", "AIAN", "Multi", "Other"),
  max.unique.vals = 50
)

head(df, 4)
df &lt;- copy_var(df, from.var = raceth, to.var = re_copy)
df &lt;- copy_var(df, from.var = x1, to.var = var1)
head(df, 4)
get_val_labs(df)
</code></pre>

<hr>
<h2 id='drop_frame_lab'>Remove Frame Label Attribute from a Data Frame</h2><span id='topic+drop_frame_lab'></span><span id='topic+dfl'></span>

<h3>Description</h3>

<p>Remove the frame label attribute (see <code>add_frame_lab</code>) from a data.frame, if
one is present.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop_frame_lab(data)

dfl(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drop_frame_lab_+3A_data">data</code></td>
<td>
<p>the data.frame with a frame label that you wish to drop (and which
was added using <code>add_frame_lab</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code>add_frame_lab</code> for more on this labeling construct.
</p>
<p>Note: <code>dfl</code> is a compact alias for <code>drop_frame_lab</code>: they do the same thing,
and the former is easier to type.
</p>


<h3>Value</h3>

<p>a data.frame (with any previously applied frame.lab attribute removed).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># add frame.lab to mtcars and assign to new data.frame mt2
mt2 &lt;- add_frame_lab(mtcars, frame.lab = "Data extracted from the 1974 Motor
                    Trend US magazine, comprising fuel consumption and 10
                    aspects of automobile design and performance for 32
                    automobiles (1973–74 models). Source: Henderson and
                    Velleman (1981), Building multiple regression models
                    interactively. Biometrics, 37, 391–411.")

get_frame_lab(mt2) # return frame.lab alongside data.frame name as a data.frame
drop_frame_lab(mt2) # remove this frame.lab
get_frame_lab(mt2) # the data.frame name now doubles as its frame label
is.null(attributes(data)[["frame.lab"]]) # the attribute is NULL
</code></pre>

<hr>
<h2 id='drop_name_labs'>Remove Name Label Attributes from a Data Frame</h2><span id='topic+drop_name_labs'></span><span id='topic+dnl'></span>

<h3>Description</h3>

<p>Remove one or more descriptive variable name label attributes previously
added to a data.frame using <code>add_name_labs</code>.
</p>
<p>Note: <code>dnl</code> is a compact alias for <code>drop_name_labs</code>: they do the same thing,
and the former is easier to type
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop_name_labs(data, vars = NULL)

dnl(data, vars = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drop_name_labs_+3A_data">data</code></td>
<td>
<p>the data.frame with name labels that you wish to drop (and which
were added using <code>add_name_labs</code>).</p>
</td></tr>
<tr><td><code id="drop_name_labs_+3A_vars">vars</code></td>
<td>
<p>the names of the columns/variables (not the name labels) whose
name labels you wish to drop. If NULL, all variables' name labels will be
dropped.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>drop_name_labs</code> works with <code>add_name_labs</code>, <code>get_name_labs</code> and
<code>use_name_labs</code> to facilitate creation, accessing, substitution, and removal
of variable name labels for variable names. Each variable (column) of a
data.frame can receive one and only one &quot;name label,&quot; which typically is a
noun phrase that expounds the meaning or contents of the variable's name
(e.g., &quot;Weight in ounces at birth&quot; might be a viable name label for a column
called &quot;wgt&quot;). <code>drop_name_labs</code> takes a data.frame and (optionally) a
character vector of variables whose name labels should be discarded: If only
a data.frame is provided, all variable name labels will be dropped. You can
assign new name labels using new calls to <code>add_name_labs</code> (If you wish to
change some or all name labels, you do not need to call <code>drop_name_labs</code>: you
can simply pass the new name labels to <code>add_name_labs</code>, and they will
overwrite the old ones (including any automatically generated provisional
ones), while leaving in place any previously added name labels that you do
not explicitly replace).
</p>


<h3>Value</h3>

<p>The same data.frame you submitted, except that the selected name
label attribute meta-data has been removed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a data set
df &lt;- mtcars

# variable names and their labels
names_labs_vec &lt;- c(
  "mpg" = "Miles/(US) gallon",
  "cyl" = "Number of cylinders",
  "disp" = "Displacement (cu.in.)",
  "hp" = "Gross horsepower",
  "drat" = "Rear axle ratio",
  "wt" = "Weight (1000 lbs)",
  "qsec" = "1/4 mile time",
  "vs" = "Engine (0 = V-shaped, 1 = straight)",
  "am" = "Transmission (0 = automatic, 1 = manual)",
  "gear" = "Number of forward gears",
  "carb" = "Number of carburetors"
)

# assign variable labels
df &lt;- add_name_labs(df,
  vars = names(names_labs_vec),
  labs = names_labs_vec
)

# see what we have
get_name_labs(df)

# drop the name label for var/col "am"
df &lt;- drop_name_labs(df, "am")

# see what this did to the name label for "am"
get_name_labs(df)

# now, drop all of the name labels
df &lt;- drop_name_labs(df)
get_name_labs(df) # they're gone
</code></pre>

<hr>
<h2 id='drop_val_labs'>Drop Value Labels from One or More Variables</h2><span id='topic+drop_val_labs'></span><span id='topic+dvl'></span>

<h3>Description</h3>

<p>Drop all value labels previously applied to one or more variables using
<code>add_val_labs</code>, <code>add_quant_labs</code>,<code>add_m1_lab</code>, and related functions (e.g.,
<code>add_val1</code>) or aliases (e.g., <code>avl</code>).
</p>
<p>Note: <code>dvl</code> is a compact alias for <code>drop_val_labs</code>: they do the same thing,
and the former is easier to type
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop_val_labs(data, vars = NULL, partial = FALSE, not.vars = NULL)

dvl(data, vars = NULL, partial = FALSE, not.vars = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drop_val_labs_+3A_data">data</code></td>
<td>
<p>a data.frame.</p>
</td></tr>
<tr><td><code id="drop_val_labs_+3A_vars">vars</code></td>
<td>
<p>a character vector that corresponds to the name(s) (or substring
within the name(s), if partial = TRUE) of one or more variables form which
value labels will be removed. If NULL, all value labels will be removed from
all value-labeled variables.</p>
</td></tr>
<tr><td><code id="drop_val_labs_+3A_partial">partial</code></td>
<td>
<p>To drop labels for many, similarly named variables (e.g., &quot;x1&quot;
through &quot;x20&quot;), you can provide a substring only and set partial = TRUE
(default is FALSE). For example, to drop value labels for colnames &quot;x1&quot;
through &quot;x20&quot;,  you could use vars = c(&quot;x&quot;), along with partial = TRUE. Be
careful with this, as it also will attempt to drop value labels for columns
with colnames &quot;sex&quot; or &quot;tax.bracket&quot; (etc.), because they, too, contain an &quot;x&quot;
in their names).</p>
</td></tr>
<tr><td><code id="drop_val_labs_+3A_not.vars">not.vars</code></td>
<td>
<p>use of the partial argument can result in situations where
you inadvertently attempt to drop value labels for a variable. For example,
if vars=&quot;x&quot;, and partial=TRUE, then <code>drop_val_labs</code> will attempt to drop
labels for not only &quot;x1&quot;, &quot;x2&quot;,&quot;x3&quot;, and &quot;x4&quot;, but also for &quot;sex&quot;,
&quot;tax.bracket&quot;, and other &quot;x&quot;-containing variable names. Use of not.vars
allows you to indicate variables that you wish to exempt from value label-
dropping, even if their names contain the string found in vars. Note that
not.vars gets priority: setting vars=&quot;x&quot;, partial=TRUE, and not.vars=&quot;x&quot; is
tantamount to telling <code>drop_val_labs</code> that you actually do not wish to drop
value labels for any of the variables that you specified in vars, resulting
in no value labels being dropped.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>drop_val_labs</code> works with other labelr functions (e.g., <code>add_val_labs</code>,
<code>get_val_labs</code>, <code>use_val_labs</code>, <code>add_lab_cols</code>) to facilitate the creation,
accessing, modification, use, or deletion of variable value labels.
</p>


<h3>Value</h3>

<p>A data.frame, with all value labels dropped from specified variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># make a "Likert"-type fake data set to demo
# note, by default, add_val_labs() "vars" arg will do partial matching
# in this case, we catch all vars with "x" in their name
set.seed(272)
dflik &lt;- make_likert_data(scale = 1:7)
vals2label &lt;- 1:7
labs2use &lt;- c(
  "VSD",
  "SD",
  "D",
  "N",
  "A",
  "SA",
  "VSA"
)

dflik &lt;- add_val_labs(
  data = dflik, vars = c("x", "y3"), # note the vars args
  vals = vals2label,
  labs = labs2use,
  partial = TRUE
)

dfdrop &lt;- drop_val_labs(dflik,
  vars = c("x2", "y3"),
  partial = FALSE
)

# var x2's value labels are gone, like we asked for
get_val_labs(dfdrop, "x2")

# var x1's value labels are intact, b/c we didn't ask to drop them
get_val_labs(dfdrop, "x1")

dfxgone &lt;- drop_val_labs(dflik,
  c("x"),
  partial = TRUE
)

# still a lot of value labels, but all are for "y" vars,
# ...none is left for "x" vars
get_val_labs(dfxgone)
</code></pre>

<hr>
<h2 id='drop_val1'>Drop a Single Variable's Value Labels</h2><span id='topic+drop_val1'></span><span id='topic+dvl1'></span>

<h3>Description</h3>

<p>Drop all value labels previously applied to one or more variables using
<code>add_val_labs</code>, <code>add_quant_labs</code>,<code>add_m1_lab</code>, and related functions (e.g.,
<code>add_val1</code>) or aliases (e.g., <code>avl</code>).
</p>
<p>Note: <code>dvl1</code> is a compact alias for <code>drop_val1</code>: they do the same thing,
and the former is easier to type
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop_val1(data, var)

dvl1(data, var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drop_val1_+3A_data">data</code></td>
<td>
<p>a data.frame.</p>
</td></tr>
<tr><td><code id="drop_val1_+3A_var">var</code></td>
<td>
<p>the unquoted name of the variable whose value labels will be
dropped.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: <code>drop_val1</code> is the <code>drop_val_labs</code> analogue to <code>add_val1</code>: just as
<code>add_val1</code> is a variant of <code>add_val_labs</code> that allows you to specify only one
variable at a time unquoted for value labeling, <code>drop_val1</code> allows you to
pass one unquoted variable name at a time for value dropping. See those
functions for further details regarding the conventions.
</p>


<h3>Value</h3>

<p>A data.frame, with all value labels dropped from specified variable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># make a "Likert"-type fake data set to demo
# note, by default, add_val_labs() "vars" arg will do partial matching
# in this case, we catch all vars with "x" in their name
set.seed(272)
dflik &lt;- make_likert_data(scale = 1:7)
vals2label &lt;- 1:7
labs2use &lt;- c(
  "VSD",
  "SD",
  "D",
  "N",
  "A",
  "SA",
  "VSA"
)

dflik &lt;- add_val1(
  data = dflik, var = x3,
  vals = vals2label,
  labs = labs2use
)

# see what this did
get_val_labs(dflik, "x3")

dfdrop &lt;- drop_val1(dflik,
  var = x3
) # odd choice, but ok

# var x3's value labels are gone, like we asked for
get_val_labs(dfdrop, "x3")
</code></pre>

<hr>
<h2 id='fact2char'>Convert All Factor Variables of a Data Frame to Column Variables</h2><span id='topic+fact2char'></span><span id='topic+f2c'></span>

<h3>Description</h3>

<p>Convenience function to convert all factor variables to character.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fact2char(data)

f2c(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fact2char_+3A_data">data</code></td>
<td>
<p>a data.frame object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame identical to data, with exception that any factors
have been converted to character variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sapply(iris, class)
head(iris)

iris_ch &lt;- fact2char(iris)

sapply(iris_ch, class)
head(iris_ch)
</code></pre>

<hr>
<h2 id='factor_to_lab_int'>Convert a Factor Variable Column to Value-labeled Integer Variable Column</h2><span id='topic+factor_to_lab_int'></span><span id='topic+f2int'></span>

<h3>Description</h3>

<p><code>factor_to_lab_int</code> converts a factor variable (column) of a data.frame to a
value-labeled integer variable and converts the factor level labels to labelr
value labels, returning the modified data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>factor_to_lab_int(data, var)

f2int(data, var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="factor_to_lab_int_+3A_data">data</code></td>
<td>
<p>a data.frame object.</p>
</td></tr>
<tr><td><code id="factor_to_lab_int_+3A_var">var</code></td>
<td>
<p>the (unquoted) name of a factor variable found in data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note 1: <code>f2int</code> is a compact alias for <code>factor_to_lab_int</code>: they do the same thing,
and the former is easier to type.
</p>
<p>Note 2: <code>factor_to_lab_int()</code> is NOT an &quot;undo&quot; for <code>lab_int_to_factor()</code>.
<code>factor_to_lab_int()</code> will assign sequential integer values from 1 to k (the
number of distinct factor levels) in factor level order, and this will not
necessarily match the integer values of a variable previously subjected to a
<code>lab_int_to_factor()</code> call. See extended second example below for demo.
</p>


<h3>Value</h3>

<p>a data.frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>class(iris[["Species"]])
iris_df &lt;- factor_to_lab_int(iris, Species)
class(iris_df[["Species"]])
get_val_labs(iris_df, "Species")

# copy data.frame mtcars to mt2
carb_orig_int &lt;- mtcars

# !NOTE! factor_to_lab_int() is NOT an "undo" for lab_int_to_factor()
# Integer values will be sequential integers in factor level order
# Demo this

# add value labels to mtcars$carb; and assign data.frame to carb_orig_int
carb_orig_int &lt;- add_val_labs(
  data = mtcars,
  vars = "carb",
  vals = c(1, 2, 3, 4, 6, 8),
  labs = c(
    "1c", "2c", # a tad silly, but these value labels will demo the principle
    "3c", "4c",
    "6c", "8c"
  )
)

# carb as labeled numeric
class(carb_orig_int$carb) # numeric
levels(carb_orig_int$carb) # none, not a factor
head(carb_orig_int$carb, 3) # compare to carb_to_int (below)
mean(carb_orig_int$carb) # compare to carb_to_int (below)
lm(mpg ~ carb, data = carb_orig_int) # compare to carb_to_int (below)
(adj_r2_int &lt;- summary(lm(mpg ~ carb, data = carb_orig_int))$adj.r.squared)
AIC(lm(mpg ~ carb, data = carb_orig_int)) # compare to carb_to_int (below)

# carb as factor
carb_fac &lt;- carb_orig_int # copy carb_orig_int to new data.frame carb_fac
carb_fac &lt;- lab_int_to_factor(carb_fac, carb) # alias int2f() also works
class(carb_fac$carb) # factor
levels(carb_fac$carb) # has levels
head(carb_fac$carb, 3)
lm(mpg ~ carb, data = carb_fac) # factor
(adj_r2_fac &lt;- summary(lm(mpg ~ carb, data = carb_fac))$adj.r.squared)
AIC(lm(mpg ~ carb, data = carb_fac)) # compare to R2, AIC for carb_to_int

# ??back?? to integer? Not quite. Compare carb_to_int to carb_orig_int
carb_to_int &lt;- carb_fac # copy carb_fac to carb_to_int
carb_to_int &lt;- factor_to_lab_int(carb_to_int, carb) # alias int2f() also works
class(carb_to_int$carb) # Is an integer
levels(carb_to_int$carb) # NOT a factor
mean(carb_to_int$carb) # NOT the same as carb_orig_int
lm(mpg ~ carb, data = carb_to_int) # NOT the same as carb_orig_int
(adj_r2_fac &lt;- summary(lm(mpg ~ carb, data = carb_to_int))$adj.r.squared)
AIC(lm(mpg ~ carb, data = carb_to_int)) # NOT the same as carb_orig_int
</code></pre>

<hr>
<h2 id='flab'>Filter Data Frame Rows Using Variable Value Labels</h2><span id='topic+flab'></span>

<h3>Description</h3>

<p><code>flab</code> (&quot;filter using labels&quot;) allows one to filter-subset a data.frame
based on variable-specific value label attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flab(data, condition)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flab_+3A_data">data</code></td>
<td>
<p>the data.frame from which columns will be selected.</p>
</td></tr>
<tr><td><code id="flab_+3A_condition">condition</code></td>
<td>
<p>row-filtering conditions along the lines of base::subset()
and/or dplyr::filter(), which may involve a combination of value labels
(for value-labeled variables only) and actual values (for non-value-labeled
variables only).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>flab</code> accepts a labelr value-labeled data.frame, followed by condition-
based row-filtering instructions (akin to <code>base::subset</code> or <code>dplyr::filter</code>),
expressed in terms of variable value labels that exist only as meta-data
(i.e., not visible using <code>View()</code>, <code>head()</code>, etc.), and returns the filtered
data.frame in terms of the values themselves. In other words, value labels
are supplied to the <code>flab()</code> call to direct the filtering process, but those
value labels are not displayed in the cells of the returned data.frame &ndash; the
raw values themselves are. This functionality may be useful for interactively
subsetting a data.frame, where character value labels may be more intuitive
and easily recalled than the underlying variable values themselves (e.g.,
raceth==&quot;White&quot; &amp; gender=&quot;F&quot; may be more intuitive or readily recalled than
raceth==3 &amp; gender==2).
</p>
<p>Note 1: When using <code>flab</code>, any conditional row-filtering syntax involving
value-labeled variables must be expressed in terms of those variables' value
labels, not the raw values themselves. Filtering on non-value-labeled
variables is also permitted, with those variables' filtering conditions being
expressed in terms of raw values. Further, <code>flab()</code> calls may reference both
types of columns (i.e., value-labeled variables and non-value-labeled
variables), provided filtering conditions for the former are expressed in
terms of value labels.
</p>
<p>Note 2: <code>flab</code> (and labelr more broadly) is intended for moderate-sized (or
smaller) data.frames, defined loosely as those with a few million or fewer
rows. With a conventional (c. 2024) laptop, labelr operations on modest-
sized (~100K rows) take seconds (or less); with larger (&gt; a few million rows)
data.frames, labelr may take several minutes (or run out of memory and fail
altogether!), depending on the complexity of the call and the number and type
of cells implicated in it.
</p>
<p>See also <code>slab</code>, <code>use_val_labs</code>, <code>add_val_labs</code>, <code>add_val1</code>, <code>add_quant_labs</code>, <code>add_quant1</code>, <br />
<code>get_val_labs</code>, <code>drop_val_labs</code>. For label-preserving subsetting tools that subset in
terms of raw values (not value labels), see <code>sfilter</code>, <code>sbrac</code>, <code>ssubset</code>, <code>sdrop</code>.
</p>


<h3>Value</h3>

<p>a labelr label attribute-preserving data.frame consisting of the
selected rows that meet the filtering condition(s).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># make toy demographic (gender, raceth, etc.) data set
set.seed(555)
df &lt;- make_demo_data(n = 1000) # another labelr:: function
# let's add variable VALUE labels for variable "raceth"
df &lt;- add_val_labs(df,
  vars = "raceth", vals = c(1:7),
  labs = c("White", "Black", "Hispanic", "Asian", "AIAN", "Multi", "Other"),
  max.unique.vals = 50
)

# let's add variable VALUE labels for variable "gender"
# note that, if we are labeling a single variable, we can use add_val1()
# distinction between add_val1() and add_val_labs() will become more meaningful
# when we get to our Likert example
df &lt;- add_val1(
  data = df, gender, vals = c(0, 1, 2, 3, 4),
  labs = c("M", "F", "TR", "NB", "Diff-Term"), max.unique.vals = 50
)

# see what we did
# get_val_labs(df)
get_val_labs(df, "gender")
get_val_labs(df, "raceth")

# use --labels-- to filter w/ flab() ("*F*ilter *lab*el")
dflab &lt;- flab(df, raceth == "Asian" &amp; gender == "F")
head(dflab, 4)

# equivalently, use --values--- to filter w/ sfilter() ("*S*afe filter")
dfsf &lt;- sfilter(df, raceth == 3 &amp; gender == 1)
head(dfsf, 4)
</code></pre>

<hr>
<h2 id='get_all_factors'>Put Data Frame Factor Level Information into a List</h2><span id='topic+get_all_factors'></span>

<h3>Description</h3>

<p><code>get_all_factors</code> returns a list of character vectors, where each character
vector is a given factor variable's unique levels, and where the vector
is given the same name as the factor variable itself. If the data.frame
contains no factors, an empty (length 0) list is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_all_factors(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_all_factors_+3A_data">data</code></td>
<td>
<p>the data.frame you are checking for factor variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 0, 1, or more character variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>class(get_all_factors(iris))
length(get_all_factors(iris))
zz &lt;- iris
zz$u &lt;- zz$Species # zz has two factor variables
class(get_all_factors(zz))
length(get_all_factors(zz))
get_all_factors(mtcars)
length(get_all_factors(mtcars))
</code></pre>

<hr>
<h2 id='get_all_lab_atts'>Put all Data Frame label attributes into a List</h2><span id='topic+get_all_lab_atts'></span>

<h3>Description</h3>

<p><code>get_all_lab_atts</code> returns a list of labelr-generated meta-data attributes
attached to a data.frame, all of which should have names beginning with one
of these character strings: &quot;frame.lab&quot;, &quot;name.labs&quot;, <br />
&quot;val.labs&quot;, &quot;factor.&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_all_lab_atts(data, atts = c("name.labs|val.labs|frame.lab|factor."))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_all_lab_atts_+3A_data">data</code></td>
<td>
<p>the data.frame you are checking for labelr meta-data attributes.</p>
</td></tr>
<tr><td><code id="get_all_lab_atts_+3A_atts">atts</code></td>
<td>
<p>default is to look for all/any, but you can specify a more
narrow subset (or some other, altogether-irrelevant attribute, but do not do
that).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A free-standing list of labelr attributes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># make toy demographic (gender, raceth, etc.) data set
set.seed(555)
df &lt;- make_demo_data(n = 1000) # another labelr:: function
# let's add variable VALUE labels for variable "raceth"
df &lt;- add_val_labs(df,
  vars = "raceth", vals = c(1:7),
  labs = c("White", "Black", "Hispanic", "Asian", "AIAN", "Multi", "Other"),
  max.unique.vals = 50
)

get_all_lab_atts(df) # returns all; is default
get_all_lab_atts(df, "val.labs") # returns only "val.labs" attributes
get_all_lab_atts(df, "class") # You can (but probably should not) use this way.
</code></pre>

<hr>
<h2 id='get_factor_atts'>Get Factor Attributes from a Labeled Data Frame</h2><span id='topic+get_factor_atts'></span>

<h3>Description</h3>

<p><code>get_factor_atts</code> searches a labelr labeled data.frame for factors. If any
are found, a list of character vectors of factor levels is returned, with
each character vector being the set of unique levels for a factor variable,
and with each character vector named according to the convention &quot;factor.&quot; +
variable name (e.g.,&quot;factor.Species&quot; for iris$Species). Used internally by
other labelr functions to get information about factors in labeled
data.frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_factor_atts(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_factor_atts_+3A_data">data</code></td>
<td>
<p>the labelr labeled data.frame you are checking for factor
variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of character vectors, each named according to the convention
&quot;factor.&quot; + variable name (e.g.,&quot;factor.Species&quot; for iris$Species). If the
data.frame lacks labelr attributes or lacks factors, an empty list will be
returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ir2 &lt;- iris
unique(ir2$Species)

ir2 &lt;- add_val_labs(ir2,
  vars = "Species", vals = c(
    "setosa",
    "versicolor",
    "virginica"
  ),
  labs = c("se", "ve", "vi")
)
get_val_labs(ir2)
head(use_val_labs(ir2))
get_factor_atts(iris) # no such info: iris is not labelr labeled
get_factor_atts(ir2) # this one has info: it's labelr labeled
</code></pre>

<hr>
<h2 id='get_factor_info'>Return Factor Attributes as a Data Frame</h2><span id='topic+get_factor_info'></span>

<h3>Description</h3>

<p><code>get_factor_info</code> searches a labelr labeled data.frame for factors. If any
are found, a data.frame is returned with the name and unique factor levels of
each, along with a logical indicator of whether the factor is ordered, with
one row per level per factor. If none are found, a one-row data.frame of NA
values is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_factor_info(data, var = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_factor_info_+3A_data">data</code></td>
<td>
<p>the labelr labeled data.frame you are checking for factor
variables.</p>
</td></tr>
<tr><td><code id="get_factor_info_+3A_var">var</code></td>
<td>
<p>a 1L character vector with the name of a specific variable (column)
of data, if you wish to restrict query to a single variable (else, keep NULL
and will get info for any relevant variables).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with three columns: &quot;factor.var&quot; (the name of the factor
variable in question), &quot;levels&quot; (the given level of that factor, expressed as
a character), and &quot;ordered&quot; (TRUE if so, FALSE if not). If no factors are
present in the supplied data.frame, a one-row data.frame of same structure
with all three cells set to NA.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ir2 &lt;- iris
unique(ir2$Species)

ir2 &lt;- add_val_labs(ir2,
  vars = "Species", vals = c(
    "setosa",
    "versicolor",
    "virginica"
  ),
  labs = c("se", "ve", "vi")
)
get_val_labs(ir2)
head(use_val_labs(ir2))
get_factor_info(iris) # no such info: iris is not labelr labeled
get_factor_info(ir2) # this one has info: it's labelr labeled
</code></pre>

<hr>
<h2 id='get_frame_lab'>Return a Data Frame's Frame Label</h2><span id='topic+get_frame_lab'></span><span id='topic+gfl'></span>

<h3>Description</h3>

<p>For a frame-labeled data.frame, <code>get_frame_lab</code> returns a derivative
1x2 data.frame that lists the data.frame name and its frame.lab attribute.
</p>
<p>Note: <code>gfl</code> is a compact alias for <code>get_frame_lab</code>: they do the same thing,
and the former is easier to type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_frame_lab(data)

gfl(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_frame_lab_+3A_data">data</code></td>
<td>
<p>a data.frame.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>get_frame_lab</code> returns the overall descriptive &quot;frame label&quot; that is assigned
to a data.frame using <code>add_frame_lab.</code>
</p>


<h3>Value</h3>

<p>A 1x2 data.frame, consisting of &quot;data.frame&quot; and &quot;frame.lab&quot; values
for the supplied data.frame. If the supplied data.frame does not have a frame
label, its name also will be used as its frame label (i.e., both entries of
the returned 1x2 data.frame will be the data.frame name).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># add frame.lab to mtcars and assign to new data.frame mt2
mt2 &lt;- add_frame_lab(mtcars, frame.lab = "Data extracted from the 1974 Motor
                      Trend US magazine, comprising fuel consumption and 10
                      aspects of automobile design and performance for 32
                      automobiles (1973–74 models). Source: Henderson and
                      Velleman (1981), Building multiple regression models
                      interactively. Biometrics, 37, 391–411.")

attr(mt2, "frame.lab") # check for attribute

# return frame.lab alongside data.frame name as a data.frame
get_frame_lab(mt2)
</code></pre>

<hr>
<h2 id='get_labs_att'>Return Specified Label Attribute, if Present</h2><span id='topic+get_labs_att'></span>

<h3>Description</h3>

<p><code>get_labs_att</code> returns the specified piece of labelr lab(el) attribute meta-
data information if it is present.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_labs_att(data, att)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_labs_att_+3A_data">data</code></td>
<td>
<p>the data.frame you are checking for the presence (or absence)
of labelr meta-data.</p>
</td></tr>
<tr><td><code id="get_labs_att_+3A_att">att</code></td>
<td>
<p>the specific label meta-data you are looking for. Default of NULL
will return any and all meta-data with name substring &quot;name.labs&quot;,
&quot;val.labs&quot;, or &quot;factor.&quot; (period is part of the substring).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># make toy demographic (gender, raceth, etc.) data set
set.seed(555)
df &lt;- make_demo_data(n = 1000) # another labelr:: function
# let's add variable VALUE labels for variable "raceth"
df &lt;- add_val_labs(df,
  vars = "raceth", vals = c(1:7),
  labs = c("White", "Black", "Hispanic", "Asian", "AIAN", "Multi", "Other"),
  max.unique.vals = 50
)

</code></pre>

<hr>
<h2 id='get_name_labs'>Return Look-up Table of Variable Names and Name Labels</h2><span id='topic+get_name_labs'></span><span id='topic+gnl'></span>

<h3>Description</h3>

<p>For a name-labeled data.frame, <code>get_name_labs</code> returns a derivative
data.frame that lists each variable and its variable name label.
</p>
<p>Note: <code>gnl</code> is a compact alias for <code>get_name_labs</code>: they do the same thing,
and the former is easier to type
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_name_labs(data, vars = NULL)

gnl(data, vars = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_name_labs_+3A_data">data</code></td>
<td>
<p>a data.frame.</p>
</td></tr>
<tr><td><code id="get_name_labs_+3A_vars">vars</code></td>
<td>
<p>a character vector with the name(s) of any specific variable(s)
(If NULL, returned data.frame will contain all variable name labels).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A two-column data.frame, consisting of &quot;var&quot; and &quot;lab&quot; columns,
where each row corresponds to a unique variable (column) from the user-
supplied data.frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a data set
df &lt;- mtcars

# variable names and their labels
names_labs_vec &lt;- c(
  "mpg" = "Miles/(US) gallon",
  "cyl" = "Number of cylinders",
  "disp" = "Displacement (cu.in.)",
  "hp" = "Gross horsepower",
  "drat" = "Rear axle ratio",
  "wt" = "Weight (1000 lbs)",
  "qsec" = "1/4 mile time",
  "vs" = "Engine (0 = V-shaped, 1 = straight)",
  "am" = "Transmission (0 = automatic, 1 = manual)",
  "gear" = "Number of forward gears",
  "carb" = "Number of carburetors"
)

# assign variable labels
df &lt;- add_name_labs(df,
  vars = names(names_labs_vec),
  labs = names_labs_vec
)

# see what we have
get_name_labs(df)
</code></pre>

<hr>
<h2 id='get_val_lab1'>Return Look-up Table of One Variable's Value Labels</h2><span id='topic+get_val_lab1'></span><span id='topic+gvl1'></span>

<h3>Description</h3>

<p>For a data.frame with value-labeled variables, <code>get_val_lab1</code> returns a
derivative data.frame or vector that shows the value-to-label mapping for
each unique value of that value-labeled variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_val_lab1(data, var, simplify = FALSE)

gvl1(data, var, simplify = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_val_lab1_+3A_data">data</code></td>
<td>
<p>a data.frame.</p>
</td></tr>
<tr><td><code id="get_val_lab1_+3A_var">var</code></td>
<td>
<p>the unquoted name of the variable (column) for which a value-to-label
look-up mapping is sought.</p>
</td></tr>
<tr><td><code id="get_val_lab1_+3A_simplify">simplify</code></td>
<td>
<p>return the mapping as a named vector, not a data.frame
(defaults to FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>get_val1</code> is a variant of <code>get_val_labs</code> that allows you to specify
only one var whose value-to-label mapping you wish to look up.
</p>
<p>Note 1: As with <code>get_val_labs()</code>, <code>get_val_lab1()</code> exists to provide a visual,
human-interpretable quick look at how value labels map to underlying values
and is NOT intended for use in automated querying, subsetting, or other
manipulation of those value labels. Further: Unlike <code>get_val_labs()</code>, which
may return value-to-label mappings for &ndash;several&ndash; variables of potentially
different atomic types, <code>get_val_lab1()</code> limits itself to returning the value
labels of a &ndash;single&ndash; variable (column) of the supplied data.frame.
</p>
<p>For this reason, and in contrast to the behavior of <code>get_val_labs()</code>, if
<code>get_val_lab1()</code>'s simplify argument is set to FALSE (the default), the
returned data.frame will express var values as numeric if this can be done
without creating new NA values (i.e., in the sense of <code>as_numv()</code>). In
contrast, if simplify is TRUE, the look-up table information will be returned
as a named character vector.
</p>
<p>Note 2: <code>gvl1</code> is a compact alias for <code>get_val_lab1</code>: they do the same thing,
and the former is easier to type
</p>


<h3>Value</h3>

<p>By default, a three-column data.frame, consisting of &quot;var&quot;, &quot;vals&quot;,
and &quot;labs&quot; columns, where each row corresponds to a unique value of var OR &ndash;
for variables labeled using <code>add_quant_labs</code> (or <code>add_quant1</code>) &ndash; the
approximate (i.e., possibly rounded) upper bound of numerical values that
fall within that label's range of coverage.  If simplify is FALSE, a character
vector will returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># add val labs to multiple variables at once
# make a "Likert"-type fake data set to demo
# note, by default, add_val_labs() "vars" arg will do partial matching
# in this case, we catch all vars with "x" in their name
set.seed(272)
dflik &lt;- make_likert_data(scale = 1:7)
vals2label &lt;- 1:7
labs2use &lt;- c(
  "VSD",
  "SD",
  "D",
  "N",
  "A",
  "SA",
  "VSA"
)

dflik &lt;- add_val_labs(
  data = dflik, vars = c("x", "y3"), # note the vars args
  vals = vals2label,
  labs = labs2use,
  partial = TRUE
)

# note, all "x" vars get the labs, as does "y3"
get_val_lab1(dflik, x1)

get_val_lab1(dflik, x1, simplify = TRUE)
</code></pre>

<hr>
<h2 id='get_val_labs'>Return Look-up Table of Variable Values and Value Labels</h2><span id='topic+get_val_labs'></span><span id='topic+gvl'></span>

<h3>Description</h3>

<p>For a data.frame with value-labeled variables, <code>get_val_labs</code> returns a
derivative data.frame that shows the value-to-label mapping for each unique
value of each value-labeled variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_val_labs(data, var = NULL)

gvl(data, var = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_val_labs_+3A_data">data</code></td>
<td>
<p>a data.frame.</p>
</td></tr>
<tr><td><code id="get_val_labs_+3A_var">var</code></td>
<td>
<p>a character vector with the name(s) of any specific variable(s)
(If NULL, returned data.frame will contain all variable value labels).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note 1: <code>get_val_labs</code> returns a data.frame that is intended strictly to
facilitate human-in-the-loop &ndash;visual&ndash; display and inspection of what (if
any) value label has been associated with each variable value. It is &ndash;not&ndash;
intended for use in automated querying or subsetting or as an indicator of
of the supplied data.frame's columns' underlying classes or atomic types. In
particular, all columns of the &ndash;returned&ndash; data.frame object are coerced to
character for display purposes, as a result of concatenating value
information from different variables of potentially different atomic types or
classes. For example, all elements of the &quot;vals&quot; column are expressed as
character even if the underlying values themselves are numeric.
</p>
<p>Note 2: <code>gvl</code> is a compact alias for <code>get_val_labs</code>: they do the same thing,
and the former is easier to type
</p>


<h3>Value</h3>

<p>A three-column data.frame, consisting of &quot;var&quot;, &quot;vals&quot;, and &quot;labs&quot;
columns, where each row corresponds to a unique value of a value-labeled
variable (column) from the user-supplied data.frame OR &ndash; for variables
labeled using <code>add_quant_labs</code> (or <code>add_quant1</code>) &ndash; the upper bound of
numerical values that fall within that label's range of coverage. Note that
all variables of the returned data.frame are coerced to character (see Note 1
of details).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># add val labs to multiple variables at once
# make a "Likert"-type fake data set to demo
# note, by default, add_val_labs() "vars" arg will do partial matching
# in this case, we catch all vars with "x" in their name
set.seed(272)
dflik &lt;- make_likert_data(scale = 1:7)
vals2label &lt;- 1:7
labs2use &lt;- c(
  "VSD",
  "SD",
  "D",
  "N",
  "A",
  "SA",
  "VSA"
)

dflik &lt;- add_val_labs(
  data = dflik, vars = c("x", "y3"), # note the vars args
  vals = vals2label,
  labs = labs2use,
  partial = TRUE
)

# note, all "x" vars get the labs, as does "y3"
get_val_labs(dflik)
get_val_labs(dflik, "x1")
</code></pre>

<hr>
<h2 id='greml'>Determine Which Pattern Elements of One Character Vector Are Found in at
Least One Element of A Second Character Vector</h2><span id='topic+greml'></span>

<h3>Description</h3>

<p><code>greml</code> takes two character vectors of strings and, for each pattern
represented by an element of the first vector, searches all elements of the
second vector to see if any of those elements of the second vector matches
that pattern element of the first vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>greml(patterns, x, ignore.case = TRUE, vals = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="greml_+3A_patterns">patterns</code></td>
<td>
<p>a character vector of comma-separated, quoted character
strings or regular expressions.</p>
</td></tr>
<tr><td><code id="greml_+3A_x">x</code></td>
<td>
<p>a character vector that will be tested for presence/absence of
the patterns passed via the patterns argument.</p>
</td></tr>
<tr><td><code id="greml_+3A_ignore.case">ignore.case</code></td>
<td>
<p>search in a non-case-sensitive fashion if TRUE.</p>
</td></tr>
<tr><td><code id="greml_+3A_vals">vals</code></td>
<td>
<p>by default, vals = FALSE and will return a named vector that
indicates, for each unique element of patterns, whether a match for that
pattern was found somewhere in the x vector (one named logical element
returned for each patterns argument vector element). If TRUE, vals returns the
unique values of patterns that were matched (one character element for each
matched patterns argument vector element).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function accepts a character vector of text substring patterns or
regular expressions (patterns argument), and searches a second character
vector (x argument) to determine which elements of the first vector
(patterns) match at least one element anywhere in the second vector (x). If
vals = TRUE (default is FALSE), each matched pattern element is returned; if
vals = FALSE, a vector of named logical values equal in length to the
object supplied to the patterns argument is returned, indicating for each
patterns element whether a match for it was found anywhere in x (TRUE if so,
FALSE if not), with the names corresponding to the elements of the patterns
vector. If ignore.case = TRUE (the default), neither vector is treated case-
sensitively (both are coerced to lower-case before other operations occur).
</p>
<p>Used internally by various labelr functions (e.g., <code>use_val_labs</code>). Note that
this is the same search and syntax that is performed by <code>gremlr()</code>
(<code>gremlr</code> means &quot;<code>greml</code> in reverse&quot;), except that, whereas <code>greml</code> returns
matches in terms of the patterns argument (i.e., which patterns elements
match at least one x element), <code>gremlr</code> returns matches in terms of the x
argument.
</p>


<h3>Value</h3>

<p>a vector, either character (if vals = TRUE) or logical (if vals =
FALSE).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># search for "AB" (case-sensitively) anywhere in subsequent vector
greml(c("AB"), c("ab", "ab", "abc", "z"), vals = TRUE, ignore.case = FALSE)
# character(0)

# search for "AB" (non-case-sensitively; the default) anywhere in next vector
greml(c("AB"), c("ab", "ab", "abc", "z"), vals = TRUE, ignore.case = TRUE)
# [1] "AB"

# other searches
greml(c("AB"), c("ab", "ab", "abc", "z"), vals = TRUE, ignore.case = FALSE)
greml(c("ab"), c("ab", "ab", "abc", "z"), vals = FALSE)
greml(c("ab", "Q"), c("ab", "ab", "abc", "z"), vals = FALSE)
greml(c("a|b", "Q"), c("a", "b", "abc", "z"), vals = FALSE)
greml(c("a|b", "Q"), c("a", "b", "z"), vals = FALSE)
greml(c("a|b", "Q"), c("bq", "z"), vals = FALSE)
greml(c("a|b", "Q"), c("bq", "z"), vals = TRUE)

# compare greml (above) to gremlr() (here)
gremlr(c("AB"), c("ab", "ab", "abc", "z"), vals = TRUE, ignore.case = FALSE)
gremlr(c("ab"), c("ab", "ab", "abc", "z"), vals = FALSE)
gremlr(c("ab", "Q"), c("ab", "ab", "abc", "z"), vals = FALSE)
gremlr(c("a|b", "Q"), c("a", "b", "abc", "z"), vals = FALSE)
gremlr(c("a|b", "Q"), c("a", "b", "z"), vals = FALSE)
gremlr(c("a|b", "Q"), c("bq", "z"), vals = FALSE)
</code></pre>

<hr>
<h2 id='gremlr'>Determine Which Elements of a Character Vector Match at Least One Pattern
Contained in Any of the Elements of Another Character Vector</h2><span id='topic+gremlr'></span>

<h3>Description</h3>

<p><code>gremlr</code> accepts two character vectors of strings and, for each element of
the second vector, determines whether that element matches any of the
patterns supplied via any of the elements of the first vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gremlr(patterns, x, ignore.case = TRUE, vals = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gremlr_+3A_patterns">patterns</code></td>
<td>
<p>a character vector of comma-separated, quoted character
strings or regular expressions.</p>
</td></tr>
<tr><td><code id="gremlr_+3A_x">x</code></td>
<td>
<p>a character vector that will be tested for presence/absence of
the patterns passed via the patterns argument.</p>
</td></tr>
<tr><td><code id="gremlr_+3A_ignore.case">ignore.case</code></td>
<td>
<p>search in a non-case-sensitive fashion if TRUE.</p>
</td></tr>
<tr><td><code id="gremlr_+3A_vals">vals</code></td>
<td>
<p>by default, vals = FALSE and will return a named vector that
indicates, for each unique element of x, whether that x element was a match
for any element of patterns (one named logical element returned for each x
vector element). If TRUE, vals returns the unique values of x that were
matched (one character element for each matched x argument vector
element).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function accepts a character vector of text substring patterns or
regular expressions (patterns argument), and searches another character
vector (x argument) to determine for each element of x, whether that element
is a match (in the sense of <code>base::grepl()</code>) for any pattern element of
of patterns. If vals = TRUE (default is FALSE), each matched x element is
returned; if vals = FALSE, a vector of named logical values equal in length
to x is returned, indicating for each x element whether it contains any text
substring or pattern found in any element of patterns (TRUE if so, FALSE if
not), with the names corresponding to the elements of the x vector. Used
internally by various labelr functions. If ignore.case = TRUE (the default),
neither vector is treated case-sensitively (both are coerced to lower-case
before other operations).
</p>
<p>Used internally by various labelr functions  Note that this is the same
search and syntax that is performed by <code>greml</code>(<code>gremlr</code> is &quot;<code>greml</code> in
reverse&quot;), except that, whereas <code>greml</code> returns matches in terms of the
patterns argument, <code>gremlr</code> returns matches in terms of x argument.
</p>


<h3>Value</h3>

<p>a vector, either character (if vals = TRUE) or logical (if vals =
FALSE).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># search for "AB" (case-sensitively) anywhere in subsequent vector
gremlr(c("AB"), c("ab", "ab", "abc", "z"), vals = TRUE, ignore.case = FALSE)
# character(0)

# search for "AB" (non-case-sensitively; the default) anywhere in next vector
gremlr(c("AB"), c("ab", "ab", "abc", "z"), vals = TRUE, ignore.case = TRUE)
# [1] "ab"  "ab"  "abc"

# other searches
gremlr(c("AB"), c("ab", "ab", "abc", "z"), vals = TRUE, ignore.case = FALSE)
gremlr(c("ab"), c("ab", "ab", "abc", "z"), vals = FALSE)
gremlr(c("ab", "Q"), c("ab", "ab", "abc", "z"), vals = FALSE)
gremlr(c("a|b", "Q"), c("a", "b", "abc", "z"), vals = FALSE)
gremlr(c("a|b", "Q"), c("a", "b", "z"), vals = FALSE)
gremlr(c("a|b", "Q"), c("bq", "z"), vals = FALSE)

# compare gremlr (above) to greml() (here)
greml(c("AB"), c("ab", "ab", "abc", "z"), vals = TRUE, ignore.case = FALSE)
greml(c("ab"), c("ab", "ab", "abc", "z"), vals = FALSE)
greml(c("ab", "Q"), c("ab", "ab", "abc", "z"), vals = FALSE)
greml(c("a|b", "Q"), c("a", "b", "abc", "z"), vals = FALSE)
greml(c("a|b", "Q"), c("a", "b", "z"), vals = FALSE)
greml(c("a|b", "Q"), c("bq", "z"), vals = FALSE)
</code></pre>

<hr>
<h2 id='has_avl_labs'>Is This a <code>add_val_labs()</code>-style Value-labeled Variable (Column)?</h2><span id='topic+has_avl_labs'></span><span id='topic+h11l'></span><span id='topic+hql'></span>

<h3>Description</h3>

<p>Determine whether a specific variable of a data.frame has value labels
associated with it that were added using <code>add_val_labs()</code> or <code>add_val1()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_avl_labs(data, var)

h11l(data, var)

hql(data, var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="has_avl_labs_+3A_data">data</code></td>
<td>
<p>a data.frame.</p>
</td></tr>
<tr><td><code id="has_avl_labs_+3A_var">var</code></td>
<td>
<p>the unquoted name of the variable (column) to check for the
presence of <code>add_val_labs()</code>-style (one-to-one) value labels.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>h11l</code> is a compact alias for <code>has_avl_labs</code>: they do the same thing, and the
former is easier to type
</p>


<h3>Value</h3>

<p>A 1L logical.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># add val labs to multiple variables at once
# make a "Likert"-type fake data set to demo
# note, by default, add_val_labs() "vars" arg will do partial matching
# in this case, we catch all vars with "y" in their name, except "y3"
set.seed(272)
dflik &lt;- make_likert_data(scale = 1:7)
vals2label &lt;- 1:7
labs2use &lt;- c(
  "VSD",
  "SD",
  "D",
  "N",
  "A",
  "SA",
  "VSA"
)

dflik &lt;- add_val_labs(
  data = dflik, vars = c("y"), # note the vars args
  not.vars = "y3",
  vals = vals2label,
  labs = labs2use,
  partial = TRUE
)

has_avl_labs(dflik, y1) # TRUE

has_avl_labs(dflik, y3) # FALSE, see not.vars arg above
</code></pre>

<hr>
<h2 id='has_decv'>Determine if Vector Has Decimals</h2><span id='topic+has_decv'></span>

<h3>Description</h3>

<p><code>has_decv</code> determines whether a vector has decimal values, using all values
for smaller vectors and using a non-random sample of observations for larger
vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_decv(x, sample.after = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="has_decv_+3A_x">x</code></td>
<td>
<p>the vector to check for presence of decimals.</p>
</td></tr>
<tr><td><code id="has_decv_+3A_sample.after">sample.after</code></td>
<td>
<p>for larger (length(x)&gt;1000) vectors,
test for decimals using a non-random sample of 1000 observations from the
vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used by core labelr functions to detect vectors that are
bad candidates for one-to-one value labeling (as implemented by, e.g.,
<code>add_val_labs</code>).
</p>


<h3>Value</h3>

<p>a 1L vector indicating whether x has decimal values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
x1 &lt;- runif(10)
x2 &lt;- as.character(sample(c(1:20), 10, replace = TRUE))
x3 &lt;- sample(letters, size = 10, replace = TRUE)
df &lt;- data.frame(x1, x2, x3)
head(df, 3)
sapply(df, class)
class(df$x2)

df &lt;- as_num(df)
head(df, 3)
sapply(df, class)

sapply(mtcars, is.double)
sapply(mtcars, is.numeric)
sapply(mtcars, is.integer)
sapply(mtcars, has_decv)
</code></pre>

<hr>
<h2 id='has_m1_labs'>Is This an <code>add_m1_lab()</code> Many-to-One-Style Value-labeled Variable (Column)?</h2><span id='topic+has_m1_labs'></span><span id='topic+hm1l'></span>

<h3>Description</h3>

<p>Determine whether a specific variable of a data.frame has many-to-one-style
value labels associated with it (i.e., via <code>add_m1_lab()</code> or <code>add1m1()</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_m1_labs(data, var)

hm1l(data, var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="has_m1_labs_+3A_data">data</code></td>
<td>
<p>a data.frame.</p>
</td></tr>
<tr><td><code id="has_m1_labs_+3A_var">var</code></td>
<td>
<p>the unquoted name of the variable (column) to check for the
presence of many-to-one-style value labels.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>hm1l</code> is a compact alias for <code>has_m1_labs</code>: they do the same thing, and the
former is easier to type
</p>


<h3>Value</h3>

<p>A 1L logical.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># add many-to-one style labels for "carb" and one-to-one style for "am"
df &lt;- mtcars

df &lt;- add_m1_lab(df,
  vars = "carb",
  vals = 1:3,
  lab = "&lt;=3",
  max.unique.vals = 10
)

df &lt;- add_m1_lab(df,
  vars = "carb",
  vals = c(4, 6, 8),
  lab = "&gt;=4",
  max.unique.vals = 10
)

df &lt;- add_val_labs(df,
  vars = "am",
  vals = c(0, 1),
  labs = c("autom", "manu"),
  max.unique.vals = 10
)

has_m1_labs(df, carb) # TRUE, carb has m1-style value labels

has_val_labs(df, am) # TRUE, am does have value labels

has_m1_labs(df, am) # FALSE, am's value labels are not not m1-style labels
</code></pre>

<hr>
<h2 id='has_quant_labs'>Is this an <code>add_quant_labs()</code>-style Value-labeled Variable (Column)?</h2><span id='topic+has_quant_labs'></span>

<h3>Description</h3>

<p>Determine whether a specific variable of a data.frame has value labels
associated with it that were added using <code>add_quant_labs()</code> or <code>add_quant1()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_quant_labs(data, var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="has_quant_labs_+3A_data">data</code></td>
<td>
<p>a data.frame.</p>
</td></tr>
<tr><td><code id="has_quant_labs_+3A_var">var</code></td>
<td>
<p>the unquoted name of the variable (column) to check for the
presence of <code>add_quant_labs()</code>-style numerical range-based value labels.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>hql</code> is a compact alias for <code>has_quant_labs</code>: they do the same thing, and
the former is easier to type
</p>


<h3>Value</h3>

<p>A 1L logical.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># copy mtcars to mt2 and assign various types of value labels
mt2 &lt;- mtcars

# add 1-to-1 value labels
mt2 &lt;- add_val_labs(
  data = mt2,
  vars = "am",
  vals = c(0, 1),
  labs = c("automatic", "manual")
)

has_val_labs(mt2, am) # TRUE, it does
has_m1_labs(mt2, am) # FALSE, they are NOT add_m1_lab()-style
has_quant_labs(mt2, am) # FALSE, they are NOT add_quant_labs() -style

# add many-to-1 value labels
mt2 &lt;- add_m1_lab(
  data = mt2,
  vars = "gear",
  vals = 4:5,
  lab = "4+"
)

has_val_labs(mt2, gear) # TRUE, it does
has_m1_labs(mt2, gear) # TRUE, they ARE add_m1_lab()-style
has_quant_labs(mt2, gear) # FALSE, they NOT not add_quant_labs() -style

# add quartile-based numerical range value labels
mt2 &lt;- add_quant_labs(
  data = mt2,
  vars = "disp",
  qtiles = 4
)

has_val_labs(mt2, disp) # TRUE, it does
has_m1_labs(mt2, disp) # FALSE, they are NOT add_m1_lab()-style
has_quant_labs(mt2, disp) # TRUE, they ARE add_quant_labs() -style
</code></pre>

<hr>
<h2 id='has_val_labs'>Is This a Value-labeled Variable (Column)?</h2><span id='topic+has_val_labs'></span><span id='topic+hvl'></span>

<h3>Description</h3>

<p>Determine whether a specific variable of a data.frame has value labels
associated with it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_val_labs(data, var, type = "any")

hvl(data, var, type = "any")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="has_val_labs_+3A_data">data</code></td>
<td>
<p>a data.frame.</p>
</td></tr>
<tr><td><code id="has_val_labs_+3A_var">var</code></td>
<td>
<p>the unquoted name of the variable (column) to check for the
presence of value labels.</p>
</td></tr>
<tr><td><code id="has_val_labs_+3A_type">type</code></td>
<td>
<p>the type of value label to check the variable for: &quot;any,&quot;
&quot;1to1,&quot; &quot;m1,&quot; or &quot;q.&quot; If &quot;1to1,&quot; check will be for value labels added via
<code>add_val_labs()</code> or <code>add_val1()</code>. If &quot;m1,&quot; check will be for value labels
added via <code>add_m1_lab()</code> or <code>add1m1()</code>. If &quot;q,&quot; check will be for value
labels added via <code>add_quant_labs()</code> or <code>add_quant1()</code>. If &quot;any,&quot; will return
TRUE if any of the foregoing value label types is found.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>hvl</code> is a compact alias for <code>has_val_labs</code>: they do the same thing, and the
former is easier to type
</p>


<h3>Value</h3>

<p>A 1L logical.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># add val labs to multiple variables at once
# make a "Likert"-type fake data set to demo
# note, by default, add_val_labs() "vars" arg will do partial matching
# in this case, we catch all vars with "y" in their name, except "y3"
set.seed(272)
dflik &lt;- make_likert_data(scale = 1:7)
vals2label &lt;- 1:7
labs2use &lt;- c(
  "VSD",
  "SD",
  "D",
  "N",
  "A",
  "SA",
  "VSA"
)

dflik &lt;- add_val_labs(
  data = dflik, vars = c("y"), # note the vars args
  not.vars = "y3",
  vals = vals2label,
  labs = labs2use,
  partial = TRUE
)

has_val_labs(dflik, y1) # TRUE

has_val_labs(dflik, y3) # FALSE, see not.vars arg above
</code></pre>

<hr>
<h2 id='headl'>Return First Rows of a Data Frame with Value Labels Visible</h2><span id='topic+headl'></span>

<h3>Description</h3>

<p><code>headl</code> accepts a labelr value-labeled data.frame and returns the first n
value-labeled rows of that data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>headl(data, n = 6L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="headl_+3A_data">data</code></td>
<td>
<p>a data.frame.</p>
</td></tr>
<tr><td><code id="headl_+3A_n">n</code></td>
<td>
<p>the last row to select (i.e., rows 1 through n will be returned).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Whereas <code>utils::head</code> returns the first n rows of a data.frame, <code>headl</code> does
the same thing, substituting value labels for values wherever the former exist.
See also <code>taill</code> and <code>somel</code>.
</p>


<h3>Value</h3>

<p>a data.frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># make toy demographic (gender, raceth, etc.) data set
set.seed(555)
df &lt;- make_demo_data(n = 1000) # another labelr:: function
# let's add variable VALUE labels for variable "raceth"
df &lt;- add_val_labs(df,
  vars = "raceth", vals = c(1:7),
  labs = c("White", "Black", "Hispanic", "Asian", "AIAN", "Multi", "Other"),
  max.unique.vals = 50
)

# let's add variable VALUE labels for variable "gender"
# note that, if we are labeling a single variable, we can use add_val1()
# distinction between add_val1() and add_val_labs() will become more meaningful
# when we get to our Likert example
df &lt;- add_val1(
  data = df, gender, vals = c(0, 1, 2, 3, 4),
  labs = c("M", "F", "TR", "NB", "Diff-Term"), max.unique.vals = 50
)

head(df) # utils::head
headl(df) # same, but with value labels in place of values
</code></pre>

<hr>
<h2 id='init_labs'>Initialize labelr Attributes</h2><span id='topic+init_labs'></span>

<h3>Description</h3>

<p><code>init_labs</code> pre-populates a data.frame with &quot;placeholder&quot; labelr label meta-
data, which will be overwritten if/when you explicitly assign your own
preferred label attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init_labs(data, max.unique.vals = 5000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init_labs_+3A_data">data</code></td>
<td>
<p>the data.frame that you will be labeling via functions like
<code>add_val_labs</code> and <code>add_name_labs</code>.</p>
</td></tr>
<tr><td><code id="init_labs_+3A_max.unique.vals">max.unique.vals</code></td>
<td>
<p>constrains the variables that may receive value labels
to those whose total unique values do not exceed the integer value supplied
to this argument. Note that labelr sets a hard ceiling of 5000 on the total
number of unique value labels that any variable is permitted to have under
any circumstance, as labelr is primarily intended for interactive use with
moderately-sized (&lt;=~1M-row) data.frames.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>init_labs</code> is used inside other labelr functions but is not intended for
interactive use at the console.
</p>


<h3>Value</h3>

<p>a data.frame with initial placeholder labelr meta-data added.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># make toy demographic (gender, race, etc.) data set
set.seed(555)
df &lt;- make_demo_data(n = 1000) # another labelr:: function
df2 &lt;- init_labs(df) # df2 is not df
get_all_lab_atts(df) # this is df; is not df2
get_all_lab_atts(df2) # this is df2
</code></pre>

<hr>
<h2 id='irregular2'>Convert All &quot;Irregular&quot; Data Frame Values to NA or Other Specified Value</h2><span id='topic+irregular2'></span>

<h3>Description</h3>

<p>Check all (or specified) columns of a data.frame for the presence of
&quot;irregular&quot; values (e.g., NA, Inf, NaN) and, if found, replace them with NA
(or some other specified value).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>irregular2(
  data,
  vars = NULL,
  to = NA,
  nan.include = TRUE,
  inf.include = TRUE,
  special = c("NA", "NAN", "INF", "-INF")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="irregular2_+3A_data">data</code></td>
<td>
<p>a data.frame object.</p>
</td></tr>
<tr><td><code id="irregular2_+3A_vars">vars</code></td>
<td>
<p>a character vector that corresponds to the name(s) of one or more
variables (columns) to which the operational will be applied. If NULL, will
be applied to all variables.</p>
</td></tr>
<tr><td><code id="irregular2_+3A_to">to</code></td>
<td>
<p>a single value (by default: NA) to which all irregular values will
be converted (Note: if arg is character, returned vector will be coerced to
character).</p>
</td></tr>
<tr><td><code id="irregular2_+3A_nan.include">nan.include</code></td>
<td>
<p>convert NaN values to NA.</p>
</td></tr>
<tr><td><code id="irregular2_+3A_inf.include">inf.include</code></td>
<td>
<p>convert Inf and -Inf values to NA.</p>
</td></tr>
<tr><td><code id="irregular2_+3A_special">special</code></td>
<td>
<p>additional specific character values that will be
converted to NA values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For purposes of <code>irregular2</code>, irregular values consist of: NA values, other
arbitrary values you specify, and (by default): NaN, Inf, -Inf, and character
variants of same (i.e., upper, lower, or mixed-case variants of &quot;NA&quot;,&quot;NAN&quot;,
&quot;INF&quot;,&quot;-INF&quot;). This function converts all such values to NA (or some other
specified value).
</p>


<h3>Value</h3>

<p>a data.frame identical to data, with exception that irregular values
have been converted to the value specified in &quot;to&quot; argument (NA, by default).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
x &lt;- c(NA, Inf, -Inf, NaN, runif(6))
y &lt;- c("a", "inf", "NaN", NA, sample(letters, 6, replace = TRUE))
df &lt;- data.frame(x, y)

head(df, 10)

df_1 &lt;- irregular2(df)

head(df_1, 10)

df_2 &lt;- irregular2(df, vars = "x", to = ";-)")

head(df_2)
</code></pre>

<hr>
<h2 id='irregular2v'>Replace &quot;Irregular&quot; Values of a Vector with Some Other Value</h2><span id='topic+irregular2v'></span>

<h3>Description</h3>

<p>Check a vector for the presence of &quot;irregular&quot; values (e.g., NA) and, if
found, replace with some other (single) user-specified value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>irregular2v(
  x,
  to = 99,
  nan.include = TRUE,
  inf.include = TRUE,
  special = c("NA", "NAN", "INF", "-INF"),
  other = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="irregular2v_+3A_x">x</code></td>
<td>
<p>a vector.</p>
</td></tr>
<tr><td><code id="irregular2v_+3A_to">to</code></td>
<td>
<p>a single value to which all NA (and other irregular) values should
be converted (Note: if arg is character, returned vector will be
coerced to character).</p>
</td></tr>
<tr><td><code id="irregular2v_+3A_nan.include">nan.include</code></td>
<td>
<p>treat NaN values as NA.</p>
</td></tr>
<tr><td><code id="irregular2v_+3A_inf.include">inf.include</code></td>
<td>
<p>treat Inf and -Inf values as NA.</p>
</td></tr>
<tr><td><code id="irregular2v_+3A_special">special</code></td>
<td>
<p>a modifiable set of default character values that will be
treated as equivalent to NA values.</p>
</td></tr>
<tr><td><code id="irregular2v_+3A_other">other</code></td>
<td>
<p>additional user-specified values (of consistent class) that will
be treated as equivalent to NA values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For purposes of <code>irregular2v</code>, irregular values consist of: NA values, other
arbitrary values you specify, and (by default): NaN, Inf, -Inf, and character
variants of same (i.e., upper, lower, or mixed-case variants of &quot;NA&quot;,&quot;NAN&quot;,
&quot;INF&quot;,&quot;-INF&quot;). This function is used insider core labelr functions to manage
such values, but the typical labelr user will have no explicit need to use it
as part of an interactive session.
</p>


<h3>Value</h3>

<p>a vector identical to x, with exception that NA (and other irregular)
values have been converted to the value specified in &quot;to&quot; argument.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
x &lt;- c(NA, Inf, -Inf, NaN, runif(6))
x
x1 &lt;- irregular2v(x, to = 33)
x1

set.seed(123)
x1 &lt;- c(NA, Inf, -Inf, NaN, runif(6))
x
x1 &lt;- irregular2v(x, to = 33, nan.include = TRUE, inf.include = FALSE)
x1

set.seed(123)
x &lt;- c(NA, "INF", "in", "nan", "NA", sample(letters, 5))
x
x1 &lt;- irregular2v(x, to = "&lt;-X-&gt;")
x1
</code></pre>

<hr>
<h2 id='is_numable'>Test Whether Character Vector Is &quot;Suitable&quot; for Numeric Conversion</h2><span id='topic+is_numable'></span>

<h3>Description</h3>

<p><code>is_numable</code> determines whether a character vector can be coerced to numeric
without generating new NA values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_numable(x, nan2na = TRUE, inf2na = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_numable_+3A_x">x</code></td>
<td>
<p>a character vector.</p>
</td></tr>
<tr><td><code id="is_numable_+3A_nan2na">nan2na</code></td>
<td>
<p>treat NaN (including, e.g., &quot;nan&quot;) values as NA values.</p>
</td></tr>
<tr><td><code id="is_numable_+3A_inf2na">inf2na</code></td>
<td>
<p>treat Inf, -Inf values (including, e.g., &quot;inf&quot;) as NA values.
treated as equivalent to NA values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Core labelr functions coerce integers to characters and back, which
<code>is_numable</code> facilitates.
</p>


<h3>Value</h3>

<p>a 1L (scalar) logical vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
x1 &lt;- runif(10)
x2 &lt;- as.character(sample(c(1:20), 10, replace = TRUE))
x2_num_test &lt;- is_numable(x2)
x2_num_test
x3 &lt;- sample(LETTERS, 10, replace = TRUE)
x3_num_test &lt;- is_numable(x3)
x3_num_test
</code></pre>

<hr>
<h2 id='lab_int_to_factor'>Convert a Value-labeled Integer Variable Column to a Factor Variable Column</h2><span id='topic+lab_int_to_factor'></span><span id='topic+int2f'></span>

<h3>Description</h3>

<p><code>lab_int_to_factor</code> converts a value-labeled integer variable to a factor,
using labelr value labels as factor level labels and returning the modified
data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lab_int_to_factor(data, var, ordered = FALSE)

int2f(data, var, ordered = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lab_int_to_factor_+3A_data">data</code></td>
<td>
<p>a data.frame object.</p>
</td></tr>
<tr><td><code id="lab_int_to_factor_+3A_var">var</code></td>
<td>
<p>the (unquoted) name of a value-labeled integer variable found in
data.</p>
</td></tr>
<tr><td><code id="lab_int_to_factor_+3A_ordered">ordered</code></td>
<td>
<p>logical flag to determine if resulting factor levels should be
regarded as ordered (in ascending order of the integer values of var).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note 1: <code>int2f</code> is a compact alias for <code>lab_int_to_factor</code>: they do the same
thing, and the former is easier to type.
</p>
<p>Note 2: This function can be used to produce ordered factors but will not do
so by default (see argument ordered).
</p>
<p>Note 3: This function's effects are NOT straightforwardly &quot;undone&quot; by
<code>factor_to_lab_int()</code> See the latter's documentation for more information and
an example demonstration.
</p>


<h3>Value</h3>

<p>a data.frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>class(iris[["Species"]])

iris_sp_int &lt;- factor_to_lab_int(iris, Species)
class(iris_sp_int[["Species"]])

get_val_labs(iris_sp_int, "Species")
iris_sp_fac &lt;- lab_int_to_factor(iris_sp_int, Species)

class(iris_sp_fac[["Species"]])

levels(iris_sp_fac[["Species"]])

# copy data.frame mtcars to mt2
mt2 &lt;- mtcars

# add value labels to mtcars$carb and assign data.frame to object mt2
mt2 &lt;- add_val_labs(
  data = mt2,
  vars = "carb",
  vals = c(1, 2, 3, 4, 6, 8),
  labs = c(
    "1c", "2c", # a tad silly, but these val labels will demo the principle
    "3c", "4c",
    "6c", "8c"
  )
)

# carb as labeled integer
class(mt2$carb)
levels(mt2$carb)
head(mt2$carb, 3)
lm(mpg ~ carb, data = mt2)
(adj_r2_int &lt;- summary(lm(mpg ~ carb, data = mt2))$adj.r.squared)
AIC(lm(mpg ~ carb, data = mt2))

# carb as factor
carb_fac &lt;- mt2 # copy mt2 to new data.frame carb_fac
carb_fac &lt;- lab_int_to_factor(carb_fac, carb) # alias int2f() also works
class(carb_fac$carb)
levels(carb_fac$carb)
head(carb_fac$carb, 3)
lm(mpg ~ carb, data = carb_fac)
(adj_r2_fac &lt;- summary(lm(mpg ~ carb, data = carb_fac))$adj.r.squared)
AIC(lm(mpg ~ carb, data = carb_fac))
</code></pre>

<hr>
<h2 id='make_demo_data'>Construct a Fake Demographic Data Frame</h2><span id='topic+make_demo_data'></span>

<h3>Description</h3>

<p><code>make_demo_data</code> generates a data.frame with select (entirely fictional)
&quot;demographic&quot; variables purely for the purposes of demonstrating or exploring
common labelr behaviors and uses and is not designed to accurately emulate or
represent the frequencies or relationships among demographic variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_demo_data(
  n = 1000,
  age.mean = 43,
  age.sd = 15,
  gend.prob = c(0.45, 0.45, 0.045, 0.045, 0.01),
  raceth.prob = c(1/7, 1/7, 1/7, 1/7, 1/7, 1/7, 1/7),
  edu.prob = c(0.03, 0.32, 0.29, 0.24, 0.12),
  rownames = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_demo_data_+3A_n">n</code></td>
<td>
<p>number of observations (rows) of hypothetical data set to create.</p>
</td></tr>
<tr><td><code id="make_demo_data_+3A_age.mean">age.mean</code></td>
<td>
<p>mean value of (fictional) age variable (assuming a normal
distribution) recorded in a hypothetical data set.</p>
</td></tr>
<tr><td><code id="make_demo_data_+3A_age.sd">age.sd</code></td>
<td>
<p>standard deviation of (fictional) age variable (assuming a normal
distribution) recorded in a hypothetical data set.</p>
</td></tr>
<tr><td><code id="make_demo_data_+3A_gend.prob">gend.prob</code></td>
<td>
<p>probabilities of four categories of a gender identity variable
recorded in a hypothetical data set.</p>
</td></tr>
<tr><td><code id="make_demo_data_+3A_raceth.prob">raceth.prob</code></td>
<td>
<p>probabilities of categories of a hypothetical race/ethnicity
variable recorded in a hypothetical data set.</p>
</td></tr>
<tr><td><code id="make_demo_data_+3A_edu.prob">edu.prob</code></td>
<td>
<p>probabilities of categories of a hypothetical &quot;highest level of
education&quot; variable recorded in a hypothetical data set.</p>
</td></tr>
<tr><td><code id="make_demo_data_+3A_rownames">rownames</code></td>
<td>
<p>create memorable but arbitrary rownames for inspection (if
TRUE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># make toy demographic (gender, race, etc.) data set
set.seed(555)
df &lt;- make_demo_data(n = 1000)
df &lt;- add_val_labs(df,
  vars = "raceth", vals = c(1:7),
  labs = c("White", "Black", "Hispanic", "Asian", "AIAN", "Multi", "Other"),
  max.unique.vals = 50
)
head(df)
summary(df)
</code></pre>

<hr>
<h2 id='make_likert_data'>Construct a Fake Likert Survey Response Data Frame</h2><span id='topic+make_likert_data'></span>

<h3>Description</h3>

<p><code>make_likert_data</code> generates a data.frame with select (entirely fictional)
numerically coded responses of fictional people to fictional survey items to
demonstrate and explore labelr functionalities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_likert_data(n = 1000, scale = 1:7, rownames = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_likert_data_+3A_n">n</code></td>
<td>
<p>number of observations (rows) of hypothetical data set to create.</p>
</td></tr>
<tr><td><code id="make_likert_data_+3A_scale">scale</code></td>
<td>
<p>the sequence of distinct integer values describing the raw /
naive numerical codings of Likert-type survey items.</p>
</td></tr>
<tr><td><code id="make_likert_data_+3A_rownames">rownames</code></td>
<td>
<p>create memorable but arbitrary rownames for inspection (if
TRUE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Data is entirely fictional and strictly for purposes of demonstrating labelr.
</p>


<h3>Value</h3>

<p>a data.frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># add_val_labs() "vars" arg will do partial matching if partial = TRUE
# in this case, we catch all vars with "x" in their name
set.seed(272)
dflik &lt;- make_likert_data(scale = 1:7)
vals2label &lt;- 1:7
labs2use &lt;- c(
  "VSD",
  "SD",
  "D",
  "N",
  "A",
  "SA",
  "VSA"
)

dflik &lt;- add_val_labs(
  data = dflik, vars = c("x", "y3"), # note the vars args
  vals = vals2label,
  labs = labs2use,
  partial = TRUE
)

# note, all "x" vars get the labs, as does "y3"
# see vars = args above
lik1 &lt;- use_val_labs(dflik)
head(lik1)
</code></pre>

<hr>
<h2 id='recode_vals'>Recode Values of a Free-standing Vector</h2><span id='topic+recode_vals'></span>

<h3>Description</h3>

<p>Takes a stand-alone vector (x), and recodes select values (bef) to
some other set of values (aft), returning the recoded vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recode_vals(x, bef, aft, default.lab = "bef", unique = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recode_vals_+3A_x">x</code></td>
<td>
<p>an integer, character, factor, or logical vector.</p>
</td></tr>
<tr><td><code id="recode_vals_+3A_bef">bef</code></td>
<td>
<p>the &quot;before&quot; (i.e., current) values of x to be recoded.</p>
</td></tr>
<tr><td><code id="recode_vals_+3A_aft">aft</code></td>
<td>
<p>the &quot;after&quot; (recoded) values to be substituted in the returned
vector in place of the positionally corresponding bef values of the x vector
(&quot;positionally corresponding&quot; means that the first element of aft is the
replacement (recode) for all x instances of the first element of bef, and so
on for the respective second bef and aft elements, etc.; see examples).
variables to which value labels will be added.</p>
</td></tr>
<tr><td><code id="recode_vals_+3A_default.lab">default.lab</code></td>
<td>
<p>the &quot;aft&quot; value to be used for values of x for which no
&quot;bef&quot; value is specified. default.lab = &quot;bef&quot; (the default) will use
(retain) the existing value of x as its own recode, coercing to character
as needed. For example, if the value x=4 is observed in x but is not included
in the &quot;bef&quot; argument, the returned vector will have values of 4 (integer)
or &quot;4&quot; (character), depending on whether the recodes that &ndash;are&ndash; supplied
are numeric (then 4) or character (then &quot;4&quot;).</p>
</td></tr>
<tr><td><code id="recode_vals_+3A_unique">unique</code></td>
<td>
<p>if TRUE, return only the mapping itself (bef argument values as
names, aft argument values as values), else if FALSE (default), return the
full recoded vector of x values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>While labelr users do not need to engage <code>recode_vals</code> directly, it is the
underlying function that powers certain core labelr functions, including
<code>add_val_labs</code> and <code>add_name_labs</code>. The bef argument identifies the values of
x to recode, and aft argument indicates what each bef value should be recoded
to (order matters: bef=c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), aft=c(1, 2, 3) means that &quot;a&quot; values
of x will be recoded to 1 values in returned vector, &quot;b&quot; values will be
recoded to 2, and &quot;c&quot; values will be recoded to 3).
</p>


<h3>Value</h3>

<p>A vector of length equal length of supplied vector, with x values
found in bef argument switched to the corresponding values found in the aft
argument.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z &lt;- mtcars$gear
z[1] &lt;- NA
z
recode_vals(z, c(5, 3, 4), c("five", "three", "four"))
irsp &lt;- iris$Species[c(1:3, 60:62, 148:150)]
irsp
recode_vals(irsp, c("setosa", "versicolor", "virginica"), c("SE", "VE", "VI"))
class(irsp) # factor
class(recode_vals(
  irsp, c("setosa", "versicolor", "virginica"),
  c("SE", "VE", "VI")
)) # coerced to character
set.seed(112)
x_logic &lt;- sample(c(TRUE, FALSE), 10, replace = TRUE)
x_logic
recode_vals(x_logic, bef = c(FALSE), c("Fake News!"))
</code></pre>

<hr>
<h2 id='restore_factor_info'>Restore Factor Status, Levels to a Character Column of a Labeled Data Frame</h2><span id='topic+restore_factor_info'></span>

<h3>Description</h3>

<p><code>restore_factor_info</code> searches a data.frame for labelr-specific factor
meta-data (added by <code>add_factor_info()</code>) and, if found, uses that information
to coerce a character vector that was formerly a factor back into a
factor, with former levels and (if applicable) &quot;ordered&quot; factor status,
as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>restore_factor_info(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="restore_factor_info_+3A_data">data</code></td>
<td>
<p>the data.frame to which labelr-specific factor attribute meta-
data may have been applied via <code>add_factor_info</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># this function does not strictly require prior or other use of labelr
zz &lt;- add_factor_info(iris) # we'll find out what this does
sapply(zz, class) # Species is a factor
zz$Species &lt;- as.character(zz) # now it's a character
sapply(zz, class) # yup, it's a character
zz &lt;- restore_factor_info(zz) # we'll find out what this does
sapply(zz, class) # now it's back to a factor
levels(zz$Species) # levels are back, too.
</code></pre>

<hr>
<h2 id='sbrac'>Safely Extract Elements of a Labeled Data Frame</h2><span id='topic+sbrac'></span>

<h3>Description</h3>

<p><code>sbrac</code> allows one to do &quot;bracket-like&quot; row and/or column selection
(without actual brackets) on a labelr-labeled data.frame in a manner that
preserves its labelr label attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sbrac(data, ri = NULL, ci = NULL, partial = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sbrac_+3A_data">data</code></td>
<td>
<p>the data.frame from which columns will be selected.</p>
</td></tr>
<tr><td><code id="sbrac_+3A_ri">ri</code></td>
<td>
<p>row indices (integer positional or logical) or row.names (or
partial row.names if partial = TRUE) to be selected.</p>
</td></tr>
<tr><td><code id="sbrac_+3A_ci">ci</code></td>
<td>
<p>column indices (integer positional or logical) or column / variable
names (or partial column names if partial = TRUE) to be selected.</p>
</td></tr>
<tr><td><code id="sbrac_+3A_partial">partial</code></td>
<td>
<p>if TRUE, any row or column that contains the relevant
character substring will be selected (e.g., sbrac(mtcars, c(&quot;Maz&quot;), c(&quot;di&quot;))
will return all &quot;Mazda&quot; car rows and the column &quot;disp&quot;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sbrac</code> allows one to select rows and columns of a data.frame in a bracket-
like fashion, using integers (positional indices), logicals, or (partial)
character names (row names and column/variable names). Whereas some forms of
Base R bracket subsetting will discard (destroy) labelr attributes, <code>sbrac</code>
preserves them. For example, sbrac(df, 1:5, 2:4) returns a data.frame
(with any labelr attribute meta-data intact), consisting of rows 1-5 and
columns 2-4 of data.frame df; while sbrac(mtcars, &quot;Maz&quot;, &quot;a&quot;, partial = TRUE)
returns all variables with substring &quot;a&quot; in their names for all rows with
substring &quot;Maz&quot; in their row names. Integer indices (only) can be enclosed in
-c() for negative index selection (i.e., &quot;select not these&quot;), (where
sbrac(df, -c(1,2), &quot;x&quot;, partial = TRUE) means select all rows of df other
than rows 1 and 2 and all columns that feature the letter &quot;x&quot; in their names.
See also <code>ssubset</code>, <code>sfilter</code>, <code>sselect</code>, <code>sdrop</code>, <code>ssort</code>, and <code>srename</code>, as
well as <code>slab</code> and <code>flab</code> for other labelr attribute-preserving subsetting
tools.
</p>


<h3>Value</h3>

<p>a labelr label attribute-preserving data.frame, consisting of the
selected rows and/or columns index-selected.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a copy of the mtcars data set
mtc2 &lt;- mtcars

# variable names and their labels
names_labs_vec &lt;- c(
  "mpg" = "Miles/(US) gallon",
  "cyl" = "Number of cylinders",
  "disp" = "Displacement (cu.in.)",
  "hp" = "Gross horsepower",
  "drat" = "Rear axle ratio",
  "wt" = "Weight (1000 lbs)",
  "qsec" = "1/4 mile time",
  "vs" = "Engine (0 = V-shaped, 1 = straight)",
  "am" = "Transmission (0 = automatic, 1 = manual)",
  "gear" = "Number of forward gears",
  "carb" = "Number of carburetors"
)

# assign variable labels
mtc2 &lt;- add_name_labs(mtc2,
  vars = names(names_labs_vec),
  labs = names_labs_vec
)

# examples of sbrac() functionality
sbrac(mtc2, 1:4, ) # commas used in a bracket-like way: row 1:4 and all cols
sbrac(mtc2, , 1:4) # commas used in a bracket-like way: all rows and cols 1:4
sbrac(mtc2, 1, 2) # 1 is row, 2 is col
sbrac(mtc2, -c(8:32), -c(1:8)) # select NOT-these rows and cols (-)
sbrac(mtc2, 1:5, 1:2) # rows 1-5, cols 1 and 2

# if partial = TRUE, partial matching to get all Mazda or Merc + all
# ...vars with "ar" in name
sbrac(mtc2, c("Mazda", "Merc"), c("ar"), partial = TRUE) # see what this does
mtc3 &lt;- sbrac(mtc2, c("45"), 1:2, partial = TRUE) # see what this does
get_labs_att(mtc3, "name.labs") # name.labs still there
</code></pre>

<hr>
<h2 id='scbind'>Safely Combine Data Frames Column-wise</h2><span id='topic+scbind'></span>

<h3>Description</h3>

<p><code>scbind</code> allows one to bind columns together into a data.frame, while
preserving any labelr labels of the inputted data.frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scbind(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scbind_+3A_...">...</code></td>
<td>
<p>data.frames to be column-bound</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Precedence is given to the labels of earlier-appearing arguments, such that,
if both an earlier and a later data.frame include a label attribute with the
same name, the attribute from the earlier data.frame will be preserved, and
the same-named attribute later data.frame(s) will be discarded.
</p>


<h3>Value</h3>

<p>a data.frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># assign mtcars to df
df &lt;- mtcars

# add value labels to "am"
df &lt;- add_val_labs(
  data = df,
  vars = "am",
  vals = c(0, 1),
  labs = c("automatic", "manual")
)

# add numerical range value labels to "mpg"
df &lt;- add_quant1(df, mpg, qtiles = 4)

df_a &lt;- sselect(df, "am")
df_b &lt;- sselect(df, "mpg")
df_c &lt;- sselect(mtcars, "cyl")
df_all &lt;- scbind(df_a, df_b, df_c)

head(df_all)

get_val_labs(df_all)
</code></pre>

<hr>
<h2 id='schange'>Safely Change or Add a Data Frame Variable (Column)</h2><span id='topic+schange'></span>

<h3>Description</h3>

<p><code>schange</code> allows one to modify or add a column to a data.frame while
preserving the labelr attributes attached to the inputted data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>schange(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="schange_+3A_data">data</code></td>
<td>
<p>a data.frame.</p>
</td></tr>
<tr><td><code id="schange_+3A_...">...</code></td>
<td>
<p>an expression that will create or update a column in data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that, while <code>schange</code> preserves label meta-data of the supplied
data.frame, it does not update or add any new labels. Therefore, if you are
altering the range of values for an extant variable or adding a new variable
to the data.frame, you will need to explicitly instantiate any new or
modified labels that you desire via follow-up calls to functions such as
<code>add_val_labs()</code>, <code>drop_val_labs()</code>, etc.
</p>


<h3>Value</h3>

<p>a data.frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- mtcars
# now, add value labels
df &lt;- add_val_labs(
  data = df,
  vars = "am",
  vals = c(0, 1),
  labs = c("automatic", "manual")
)

df &lt;- add_val_labs(
  data = df,
  vars = "carb",
  vals = c(1, 2, 3, 4, 6, 8),
  labs = c(
    "1-carb", "2-carbs",
    "3-carbs", "4-carbs",
    "6-carbs", "8-carbs"
  )
)

df &lt;- schange(df, mpg_sq = mpg^2) # create var "mpg_sq"
df &lt;- schange(df, am = ifelse(am == 0, 2, am)) # modify/replace var "am"

head(df, 4) # show that data.frame modifications have been made
get_all_lab_atts(df) # labels are intact; "val.labs.am" needs updating!
df &lt;- drop_val_labs(
  data = df,
  vars = "am"
)

df &lt;- add_val_labs(
  data = df,
  vars = "am",
  vals = c(1, 2),
  labs = c("manual", "automatic")
)
get_val_labs(df)
</code></pre>

<hr>
<h2 id='sdrop'>Safely Drop Specified Columns of a Labeled Data Frame</h2><span id='topic+sdrop'></span>

<h3>Description</h3>

<p><code>sdrop</code> allows one to remove columns from a data.frame, returning the
remaining columns as a data.frame that preserves the labelr attributes
attached to the inputted data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sdrop(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sdrop_+3A_data">data</code></td>
<td>
<p>the data.frame from which columns will be removed.</p>
</td></tr>
<tr><td><code id="sdrop_+3A_...">...</code></td>
<td>
<p>comma-separated, unquoted column/variable names to be discarded
(e.g., cyl, mpg, not c(&quot;cyl&quot;, &quot;mpg&quot;)), with no other special characters or
symbols, such as quotes, parentheses, colons, minus signs, exclamation
points, or other operators.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function accepts a data.frame, followed by a set of comma-separated,
non-quoted column names to be discarded and returns the remaining columns as
a data.frame that preserves labelr attribute information. NOTE: This command
does NOT allow for positive specification of columns to be retained; rather,
all variables not specified will be retained by default. Further, <code>sdrop</code>
does not supported quoted column names, dplyr-like helper functions or
other special selection syntax or idioms. See also <code>ssubset</code>, <code>sselect</code>, or
<code>sbrac</code>); see also <code>sfilter</code>, <code>ssort</code>, <code>srename</code>, <code>slab</code>, and <code>flab</code>.
</p>


<h3>Value</h3>

<p>a labelr label attribute-preserving data.frame consisting of the
remaining (i.e., non-specified, non-discarded) subset of columns of the
supplied data.frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># make toy demographic (gender, raceth, etc.) data set
set.seed(555)
df &lt;- make_demo_data(n = 1000) # another labelr:: function
# let's add variable VALUE labels for variable "raceth"
df &lt;- add_val_labs(df,
  vars = "raceth", vals = c(1:7),
  labs = c("White", "Black", "Hispanic", "Asian", "AIAN", "Multi", "Other"),
  max.unique.vals = 50
)

head(df, 3)
check_labs_att(df, "val.labs.raceth") # "raceth" lab specifically TRUE

dfless &lt;- sdrop(df, id, raceth) # drop the vars id and raceth
head(dfless, 3) # selection worked
check_labs_att(dfless, "val.labs.raceth") # "raceth" value labels are gone
</code></pre>

<hr>
<h2 id='sfilter'>Safely Filter Rows of a Labeled Data Frame</h2><span id='topic+sfilter'></span>

<h3>Description</h3>

<p><code>sfilter</code> allows one to filter-subset a data.frame, selecting only rows that
satisfy conditions (after the fashion of base::subset() or dplyr::filter()),
returning the selected rows as a data.frame that preserves the labelr
attributes attached to the inputted data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sfilter(data, condition)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sfilter_+3A_data">data</code></td>
<td>
<p>the data.frame from which columns will be selected.</p>
</td></tr>
<tr><td><code id="sfilter_+3A_condition">condition</code></td>
<td>
<p>row-filtering conditions along the lines of base::subset()
and/or dplyr::select().</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function accepts a data.frame, followed by conditional filtering
instructions and returns the selected rows (and all inputted data.frame
columns) as a data.frame that preserves the labelr attribute information of
the originally supplied data.frame. See <code>ssubset</code> for a variant that combines
<code>sfilter</code> row-filtering and <code>sselect</code> column selection in a single function.
See <code>sbrac</code> for a labelr attribute-preserving approach to row and/or column
indexing. See also <code>sdrop</code>, <code>ssort</code>, <code>srename</code>, <code>slab</code>, and <code>flab</code>.
</p>


<h3>Value</h3>

<p>a labelr label attribute-preserving data.frame consisting of the
selected rows that meet the filtering condition(s).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># make toy demographic (gender, raceth, etc.) data set
set.seed(555)
df &lt;- make_demo_data(n = 1000) # another labelr:: function
# let's add variable VALUE labels for variable "raceth"
df &lt;- add_val_labs(df,
  vars = "raceth", vals = c(1:7),
  labs = c("White", "Black", "Hispanic", "Asian", "AIAN", "Multi", "Other"),
  max.unique.vals = 50
)

head(df, 3)
check_labs_att(df, "val.labs.raceth") # "raceth" lab specifically TRUE

dffil1 &lt;- sfilter(df, raceth %in% c(1, 2, 3) &amp; id &lt; 50 &amp; gender == 1)
head(dffil1, 3)
check_labs_att(dffil1, "val.labs.raceth") # "raceth" lab specifically TRUE

dffil2 &lt;- sfilter(df, !raceth %in% 1:5 | (age == 60))
head(dffil2, 8)
check_labs_att(dffil2, "val.labs.raceth") # "raceth" lab specifically TRUE
</code></pre>

<hr>
<h2 id='sgen'>Safely Generate a Data Frame Variable (Column)</h2><span id='topic+sgen'></span>

<h3>Description</h3>

<p><code>sgen</code> allows one to add a column to a data.frame while preserving the labelr
attributes attached to the inputted data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sgen(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sgen_+3A_data">data</code></td>
<td>
<p>a data.frame.</p>
</td></tr>
<tr><td><code id="sgen_+3A_...">...</code></td>
<td>
<p>an expression that will create a new column in the data.frame.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that, while <code>sgen</code> preserves label meta-data of the supplied
data.frame, it does not update or add any new labels. Therefore, you will
need to explicitly instantiate any new or modified labels that you desire via
follow-up calls to functions such as <code>add_val_labs()</code>, <code>drop_val_labs()</code>, etc.
</p>
<p>You may not use <code>sgen</code> to replace a variable already present in a the supplied
data.frame. For that, see <code>sreplace</code> or <code>schange</code>.
</p>


<h3>Value</h3>

<p>a data.frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- mtcars
# now, add value labels
df &lt;- add_val_labs(
  data = df,
  vars = "am",
  vals = c(0, 1),
  labs = c("automatic", "manual")
)

df &lt;- add_val_labs(
  data = df,
  vars = "carb",
  vals = c(1, 2, 3, 4, 6, 8),
  labs = c(
    "1-carb", "2-carbs",
    "3-carbs", "4-carbs",
    "6-carbs", "8-carbs"
  )
)

df &lt;- sgen(df, mpg_sq = mpg^2) # create var "mpg_sq"
df &lt;- sgen(df, am2 = ifelse(am == 0, 2, am)) # create var "am2"

head(df, 4) # show that data.frame modifications have been made
get_all_lab_atts(df)

df &lt;- add_quant_labs(
  data = df,
  vars = "mpg_sq",
  vals = c(200, 400, 600, 1000, 1500),
  labs = NULL
)

df &lt;- add_val_labs(
  data = df,
  vars = "am2",
  vals = c(1, 2),
  labs = c("manual", "automatic")
)


get_val_labs(df)
</code></pre>

<hr>
<h2 id='slab'>Subset a Data Frame Using Value Labels</h2><span id='topic+slab'></span>

<h3>Description</h3>

<p><code>slab</code> (&quot;subset using labels&quot;) allows one to filter rows and select columns
from a data.frame based on variable-specific value label attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slab(data, condition, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slab_+3A_data">data</code></td>
<td>
<p>the data.frame from which columns rows will be filtered (and,
possibly, columns selected)</p>
</td></tr>
<tr><td><code id="slab_+3A_condition">condition</code></td>
<td>
<p>row-filtering conditions along the lines of base::subset()
and/or dplyr::filter(). Note: Row-filtering conditions (to include
condition==NULL) must be supplied. Conditions involving value-labeled
variables must be expressed in terms of the value labels (see examples),
else try <code>ssubset.</code></p>
</td></tr>
<tr><td><code id="slab_+3A_...">...</code></td>
<td>
<p>Optionally supply one or more unquoted, comma-separated
column names that identify columns to be retained (Note: If no columns are
listed, all columns will be retained). Note: While row-filtering conditions
may leverage standard operators (e.g., &amp;, |, ==, !=), the column-selection
portion of call may not incorporate special characters or symbols, such as
quotes, parentheses, colons, minus signs, exclamation points, or other
operators. Only positive selection of columns is permitted (negative
selection &ndash; i.e., &quot;select not / select-all-except&quot; specified columns is not
supported)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>slab</code> does base::subset-style data subsetting using variable value label
meta-data that are associated with variable values but are not themselves
values (i.e., will not appear in response to <code>View()</code>, <code>head()</code>, etc.).
In other words, value labels are supplied to the <code>slab()</code> call to direct the
filtering process, but those value labels are not displayed in the cells of
the returned data.frame &ndash; the raw values themselves are. This functionality
may be useful for interactively subsetting a data.frame, where character
value labels may be more intuitive and easily recalled than the underlying
variable values themselves (e.g., raceth==&quot;White&quot; &amp; gender=&quot;F&quot; may be more intuitive or
readily recalled than raceth==3 &amp; gender==2).
</p>
<p><code>slab</code>takes as its arguments a labelr value-labeled data.frame, followed by
condition-based row-filtering instructions (required) and a list of unquoted
names of variables to be retained (optional; all variables returned by
default).
</p>
<p>Note 1: When using <code>slab</code>, any conditional row-filtering syntax involving
value-labeled variables must be expressed in terms of those variables' value
labels, not the raw values themselves. Filtering on non-value-labeled
variables is also permitted, with those variables' filtering conditions being
expressed in terms of raw values. Further, <code>slab()</code> calls may reference both
types of columns (i.e., value-labeled variables and non-value-labeled
variables), provided filtering conditions for the former are expressed in
terms of value labels.
</p>
<p>Note 2: <code>slab</code> (and labelr more broadly) is intended for moderate-sized (or
smaller) data.frames, defined loosely as those with a few million or fewer
rows. With a conventional (c. 2024) laptop, labelr operations on modest-
sized (~100K rows) take seconds (or less); with larger (&gt; a few million rows)
data.frames, labelr may take several minutes (or run out of memory and fail
altogether!), depending on the complexity of the call and the number and type
of cells implicated in it.
</p>
<p>See also <code>flab</code>, <code>use_val_labs</code>, <code>add_val_labs</code>, <code>add_val1</code>,<code>add_quant_labs</code>,
<code>add_quant1</code>, <br /> <code>get_val_labs</code>, <code>drop_val_labs</code>. For label-preserving
subsetting tools that subset in terms of raw values (not value labels), see
<code>sfilter</code>, <code>sbrac</code>, <code>ssubset</code>, <code>sdrop</code>.
</p>


<h3>Value</h3>

<p>a labelr label attribute-preserving data.frame consisting of the
selected rows that meet the filtering condition(s) and the columns whose
(unquoted, comma-separated) names are passed to dots (...) (or all columns
if no column names are passed).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># make toy demographic (gender, raceth, etc.) data set
set.seed(555)
df &lt;- make_demo_data(n = 1000)

# let's add variable VALUE labels for variable "raceth"
df &lt;- add_val_labs(df,
  vars = "raceth", vals = c(1:7),
  labs = c("White", "Black", "Hispanic", "Asian", "AIAN", "Multi", "Other"),
  max.unique.vals = 50
)

# let's add variable VALUE labels for variable "gender"
# note that, if we are labeling a single variable, we can use add_val1()
# distinction between add_val1() and add_val_labs() will become more
# meaningful when we get to our Likert example
df &lt;- add_val1(
  data = df, gender, vals = c(0, 1, 2, 3, 4),
  labs = c("M", "F", "TR", "NB", "Diff-Term"), max.unique.vals = 50
)

# see what we did
# get_val_labs(df)
get_val_labs(df, "gender")
get_val_labs(df, "raceth")

# use --labels-- to subset w/ slab() ("*S*ubset using *lab*els")
dflab &lt;- slab(df, raceth == "Asian" &amp; gender == "F", id, gender)
head(dflab, 4)

# equivalently, use --values--- to filter w/ sfilter() ("*S*afe filter")
dfsf &lt;- ssubset(df, raceth == 3 &amp; gender == 1, gender, raceth)
head(dfsf, 4)
</code></pre>

<hr>
<h2 id='smerge'>Safely Merge Two Data Frames</h2><span id='topic+smerge'></span>

<h3>Description</h3>

<p><code>smerge</code> allows one to merge two data.frames, one or both of which may be
labeled, preserving the labelr attributes of the inputted data.frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smerge(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smerge_+3A_x">x</code></td>
<td>
<p>a data.frame to be merged with y.</p>
</td></tr>
<tr><td><code id="smerge_+3A_y">y</code></td>
<td>
<p>a data.frame to be merged with x.</p>
</td></tr>
<tr><td><code id="smerge_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>base::merge()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Precedence is given to the labels of the first data.frame (argument x), such
that, if both data.frames include a label attribute with the same name, the
attribute from data.frame x will be preserved, and the same-named attribute
from data.frame y will be discarded.
</p>


<h3>Value</h3>

<p>a data.frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># assign mtcars to df
df &lt;- mtcars

# assign the rownames to a column
id &lt;- rownames(df)

df &lt;- cbind(id, df)

# split the data.frame into two
df_a &lt;- df[c("id", "am")]
df_b &lt;- df[c("id", "mpg")]

# add value labels to df_a$am
df_a &lt;- add_val_labs(
  data = df_a,
  vars = "am",
  vals = c(0, 1),
  labs = c("automatic", "manual")
)

# add numerical range value labels to df_b$mpg
df_b &lt;- add_quant1(df_b, mpg, qtiles = 4)

# now, safely merge them
df_m &lt;- smerge(df_a, df_b)

head(df_m)

get_val_labs(df_m)
</code></pre>

<hr>
<h2 id='somel'>Return a Random Sample of Data Frame Rows with Value Labels Visible</h2><span id='topic+somel'></span>

<h3>Description</h3>

<p><code>somel</code> accepts a labelr value-labeled data.frame and returns a random sample
of n value-labeled rows of that data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>somel(data, n = 6L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="somel_+3A_data">data</code></td>
<td>
<p>a data.frame.</p>
</td></tr>
<tr><td><code id="somel_+3A_n">n</code></td>
<td>
<p>the number of random rows of the data.frame to return.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>somel</code> is inspired by the function <code>some</code> from the car package. See also
<code>headl</code> and <code>taill</code>.
</p>


<h3>Value</h3>

<p>a data.frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># make toy demographic (gender, raceth, etc.) data set
set.seed(555)
df &lt;- make_demo_data(n = 1000) # another labelr:: function
# let's add variable VALUE labels for variable "raceth"
df &lt;- add_val_labs(df,
  vars = "raceth", vals = c(1:7),
  labs = c("White", "Black", "Hispanic", "Asian", "AIAN", "Multi", "Other"),
  max.unique.vals = 50
)

# let's add variable VALUE labels for variable "gender"
# note that, if we are labeling a single variable, we can use add_val1()
# distinction between add_val1() and add_val_labs() will become more meaningful
# when we get to our Likert example
df &lt;- add_val1(
  data = df, gender, vals = c(0, 1, 2, 3, 4),
  labs = c("M", "F", "TR", "NB", "Diff-Term"), max.unique.vals = 50
)

somel(df) # six random rows with value labels visible
</code></pre>

<hr>
<h2 id='sort_val_labs'>Sort Ascending Any Variable Value Labels</h2><span id='topic+sort_val_labs'></span>

<h3>Description</h3>

<p><code>sort_val_labs</code> sorts the presentation order of variable value label meta-data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sort_val_labs(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sort_val_labs_+3A_data">data</code></td>
<td>
<p>a data.frame</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used in internally by other labelr functions to ensure that
value label meta-data is sorted in a logical, intuitive order. It is not
intended for interactive use.
</p>


<h3>Value</h3>

<p>a data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'># note that this example is trivial, as value labels already are in order
df &lt;- mtcars
df &lt;- add_val_labs(
  data = df,
  vars = "am",
  vals = c(0, 1),
  labs = c("automatic", "manual")
)

df &lt;- add_val_labs(
  data = df,
  vars = "carb",
  vals = c(1, 2, 3, 4, 6, 8),
  labs = c(
    "1-carb", "2-carbs",
    "3-carbs", "4-carbs",
    "6-carbs", "8-carbs"
  )
)

df &lt;- sort_val_labs(df)
</code></pre>

<hr>
<h2 id='srbind'>Safely Combine Data Frames Row-wise</h2><span id='topic+srbind'></span>

<h3>Description</h3>

<p><code>srbind</code> allows one to bind rows together into a data.frame, while preserving
any labelr labels of the inputted data.frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>srbind(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="srbind_+3A_...">...</code></td>
<td>
<p>data.frames to be row-bound</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Precedence is given to the labels of earlier-appearing arguments, such that,
if both an earlier and a later data.frame include a label attribute with the
same name, the attribute from the earlier data.frame will be preserved, and
the same-named attribute later data.frame(s) will be discarded.
</p>


<h3>Value</h3>

<p>a data.frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># assign mtcars to df
df &lt;- mtcars

# assign the rownames to a column
id &lt;- rownames(df)

df &lt;- cbind(id, df)

# now, add value labels
df &lt;- add_val_labs(
  data = df,
  vars = "am",
  vals = c(0, 1),
  labs = c("automatic", "manual")
)

df &lt;- add_val_labs(
  data = df,
  vars = "carb",
  vals = c(1, 2, 3, 4, 6, 8),
  labs = c(
    "1-carb", "2-carbs",
    "3-carbs", "4-carbs",
    "6-carbs", "8-carbs"
  )
)

# split the data.frame into three
aa &lt;- df[1:5, ]
bb &lt;- df[6:11, ]
cc &lt;- df[12:32, ]
# put them back together
df2 &lt;- srbind(aa, bb, cc, cc)

get_val_labs(df2)
</code></pre>

<hr>
<h2 id='srename'>Safely Rename a Variable and Preserve Its Value Labels</h2><span id='topic+srename'></span>

<h3>Description</h3>

<p>Note: <code>srename</code> renames and existing variable and preserves its value labels,
overwriting an existing variable only if option force = TRUE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>srename(data, old.name, new.name, force = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="srename_+3A_data">data</code></td>
<td>
<p>a data.frame.</p>
</td></tr>
<tr><td><code id="srename_+3A_old.name">old.name</code></td>
<td>
<p>the unquoted name of the existing variable being renamed (to
new.name).</p>
</td></tr>
<tr><td><code id="srename_+3A_new.name">new.name</code></td>
<td>
<p>the unquoted name that will be used to rename the variable
specified in the old.name argument.</p>
</td></tr>
<tr><td><code id="srename_+3A_force">force</code></td>
<td>
<p>if a variable with the same name as new.name already exists in
the data.frame, allow it to be overwritten. If FALSE, this will not be
allowed, and an error will be issued.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Any non-labelr R operation that changes a variable's (column's) name or that
copies its contents to another variable (column) with a different name will
not associate the original variable's value labels with the new variable name.
To mitigate this, <code>srename</code> allows one to rename a data.frame variable while
preserving its value labels &ndash; that is, by associating the old.name's value
labels with the new.name. If the old.name variable (column) has a name label
(in &quot;name.labs&quot; attribute), the column name associated with that name label
will be changed from old.name to new.name.
</p>


<h3>Value</h3>

<p>A data.frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># make toy demographic (gender, raceth, etc.) data set
set.seed(555)
df &lt;- make_demo_data(n = 1000) # another labelr:: function
# let's add variable VALUE labels for variable "raceth"
df &lt;- add_val_labs(df,
  vars = "raceth", vals = c(1:7),
  labs = c("White", "Black", "Hispanic", "Asian", "AIAN", "Multi", "Other"),
  max.unique.vals = 50
)

head(df, 4)
df &lt;- srename(df, old.name = gender, new.name = genid)
df &lt;- srename(df, old.name = raceth, new.name = racid)
df &lt;- srename(df, old.name = x1, new.name = var1)
head(df, 4)
</code></pre>

<hr>
<h2 id='sreplace'>Safely Replace a Data Frame Variable (Column)</h2><span id='topic+sreplace'></span>

<h3>Description</h3>

<p><code>sreplace</code> allows one to replace a data.frame column with new values, while
preserving the labelr attributes attached to the inputted data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sreplace(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sreplace_+3A_data">data</code></td>
<td>
<p>a data.frame.</p>
</td></tr>
<tr><td><code id="sreplace_+3A_...">...</code></td>
<td>
<p>an expression that replaces a column in the data.frame.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that, while <code>sreplace</code> preserves label meta-data of the supplied
data.frame, it does not update or add any new labels. Therefore, if you are
altering the range of values for an extant variable, you will need to
explicitly instantiate any new or modified labels that you desire via
follow-up calls to functions such as <code>add_val_labs()</code>, <code>drop_val_labs()</code>, etc.
</p>
<p>You may not use <code>sreplace</code> to generate a new variable (i.e., one not already
present in a the supplied data.frame). For that, see <code>sgen</code> or <code>schange</code>.
</p>


<h3>Value</h3>

<p>a data.frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- mtcars
# now, add value labels
df &lt;- add_val_labs(
  data = df,
  vars = "am",
  vals = c(0, 1),
  labs = c("automatic", "manual")
)

df &lt;- add_val_labs(
  data = df,
  vars = "carb",
  vals = c(1, 2, 3, 4, 6, 8),
  labs = c(
    "1-carb", "2-carbs",
    "3-carbs", "4-carbs",
    "6-carbs", "8-carbs"
  )
)

df &lt;- sreplace(df, mpg = mpg^2) # replace var "mpg"
df &lt;- sreplace(df, am = ifelse(am == 0, 2, am)) # replace var "am"

head(df, 4) # show that data.frame modifications have been made
get_all_lab_atts(df)

df &lt;- add_quant_labs(
  data = df,
  vars = "mpg",
  vals = c(200, 400, 600, 1000, 1500),
  labs = NULL
)

df &lt;- drop_val_labs(
  data = df,
  vars = "am"
)

df &lt;- add_val_labs(
  data = df,
  vars = "am",
  vals = c(1, 2),
  labs = c("manual", "automatic")
)

get_val_labs(df)
</code></pre>

<hr>
<h2 id='sselect'>Safely Select Specified Columns of a Labeled Data Frame</h2><span id='topic+sselect'></span>

<h3>Description</h3>

<p><code>sselect</code> allows one to subset (select) columns from a data.frame,
returning the selected columns as a data.frame that preserves the labelr
attributes attached to the inputted data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sselect(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sselect_+3A_data">data</code></td>
<td>
<p>the data.frame from which columns will be selected.</p>
</td></tr>
<tr><td><code id="sselect_+3A_...">...</code></td>
<td>
<p>comma-separated, unquoted column/variable names to be selected
(e.g., cyl, mpg, not c(&quot;cyl&quot;, &quot;mpg&quot;)), with no other special characters or
symbols, such as quotes, parentheses, colons, minus signs, exclamation
points, or other operators.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function accepts a data.frame, followed by a set of comma-separated,
non-quoted column names to be retained and returns the selected columns in a
data.frame that preserves labelr attribute information. NOTE: This command
does not allow for negative selection, quoted columns, or dplyr-like helper
functions or special selection idioms, but: see <code>sdrop</code> for negative selection
(&quot;return all columns except these&quot;); see <code>sbrac</code> for a more flexible
subsetting command; and see also <code>ssubset</code>, <code>sfilter</code>, <code>ssort</code>, and <code>srename</code>,
as well as <code>slab</code> and <code>flab</code>.
</p>


<h3>Value</h3>

<p>a labelr label attribute-preserving data.frame consisting of the
selected subset of columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># make toy demographic (gender, raceth, etc.) data set
set.seed(555)
df &lt;- make_demo_data(n = 1000) # another labelr:: function
# let's add variable VALUE labels for variable "raceth"
df &lt;- add_val_labs(df,
  vars = "raceth", vals = c(1:7),
  labs = c("White", "Black", "Hispanic", "Asian", "AIAN", "Multi", "Other"),
  max.unique.vals = 50
)

head(df, 3)
check_labs_att(df, "val.labs.raceth") # "raceth" lab specifically TRUE

dfless &lt;- sselect(df, id, raceth) # select only the vars id and raceth
head(dfless, 3) # selection worked
check_labs_att(dfless, "val.labs.raceth") # "raceth" value labels preserved
</code></pre>

<hr>
<h2 id='ssort'>Safely Sort (Re-order) a Labeled Data Frame</h2><span id='topic+ssort'></span>

<h3>Description</h3>

<p><code>ssort</code> allows one to sort (after the fashion of base::order or
dplyr::arrange) the rows of a data.frame based on column values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssort(data, vars, descending = FALSE, na.last = TRUE, fact.to.char = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ssort_+3A_data">data</code></td>
<td>
<p>the data.frame to be sorted.</p>
</td></tr>
<tr><td><code id="ssort_+3A_vars">vars</code></td>
<td>
<p>the variables to be sorted on, specified as a quoted character
vector of variable names or an integer vector of column position indices.</p>
</td></tr>
<tr><td><code id="ssort_+3A_descending">descending</code></td>
<td>
<p>whether to sort the given variable of vars in descending
or ascending order. Default is FALSE, which will be recycled to all vars
arguments.</p>
</td></tr>
<tr><td><code id="ssort_+3A_na.last">na.last</code></td>
<td>
<p>force NA values to appear last in a variable's sort order if
TRUE (default).</p>
</td></tr>
<tr><td><code id="ssort_+3A_fact.to.char">fact.to.char</code></td>
<td>
<p>coerce all factor variables to character variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function accepts a data.frame, followed by a quoted vector of column
names (or an integer vector of column position indices), followed by
an indication of which are to be sorted ascending (default) or descending.
If multiple columns are supplied to vars, sorting prioritizes the columns
that appear earlier, with values of subsequent columns being sorted within
distinct values of earlier columns. Note: <code>ssort</code> is fast enough on small
data.frames and very slow on &quot;larger&quot; (&gt;500K records) data.frames,
particularly for more complex or demanding sort requests. Other R packages
may provide faster sorting while preserving labelr attributes.
</p>


<h3>Value</h3>

<p>a labelr label attribute-preserving data.frame consisting of the
re-sorted data.frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># make toy demographic (gender, raceth, etc.) data set
set.seed(555)
df &lt;- make_demo_data(n = 1000) # another labelr:: function

# let's add variable VALUE labels for variable "raceth"
df &lt;- add_val_labs(df,
  vars = "raceth", vals = c(1:7),
  labs = c("White", "Black", "Hispanic", "Asian", "AIAN", "Multi", "Other"),
  max.unique.vals = 50
)

head(df, 3)
check_labs_att(df, "val.labs.raceth") # "raceth" lab specifically TRUE

dfsort1 &lt;- ssort(df, c("raceth", "gender", "age"), descending = c(TRUE, FALSE, FALSE))

head(dfsort1, 20)

check_labs_att(dfsort1, "val.labs.raceth") # "raceth" lab specifically TRUE

dfsort2 &lt;- ssort(df, c("age", "gender"))

head(dfsort2, 20)

check_labs_att(dfsort2, "val.labs.raceth") # "raceth" lab specifically TRUE

dfsort3 &lt;- ssort(df, c("raceth"))

head(dfsort3, 10)

check_labs_att(dfsort3, "val.labs.raceth") # "raceth" lab specifically TRUE

</code></pre>

<hr>
<h2 id='ssubset'>Safely Subset a Labeled Data Frame</h2><span id='topic+ssubset'></span>

<h3>Description</h3>

<p><code>ssubset</code> allows one to simultaneously filter-select rows that
satisfy conditions AND return only selected columns as a data.frame that
preserves the labelr attributes
attached to the inputted data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssubset(data, condition, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ssubset_+3A_data">data</code></td>
<td>
<p>the data.frame from which columns rows will be filtered (and,
possibly, columns selected).</p>
</td></tr>
<tr><td><code id="ssubset_+3A_condition">condition</code></td>
<td>
<p>row-filtering conditions along the lines of base::subset()
and/or dplyr::select(). Note: Row-filtering conditions (to include
condition==NULL) must be supplied.</p>
</td></tr>
<tr><td><code id="ssubset_+3A_...">...</code></td>
<td>
<p>Optionally supply one or more unquoted, comma-separated
column names that identify columns to be retained (Note: If no columns are
listed, all columns will be retained). Note: While row-filtering conditions
may leverage standard operators (e.g., &amp;, |, ==, !=), the column-selection
portion of call may not incorporate special characters or symbols, such as
quotes, parentheses, colons, minus signs, exclamation points, or other
operators.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Combining <code>sfilter</code> and <code>sselect</code> functionality (along the lines of
base::subset(), this function accepts a data.frame, followed by conditional
filtering instructions (required) and (optional) comma-separated unquoted
column names to be selected (see examples), returning  the selected rows and
columns as a data.frame that preserves the labelr  attribute information of
the originally supplied data.frame. See <code>ssubset</code> for a variant that combines
<code>sfilter</code> row-filtering and <code>sselect</code> column selection in a single function.
See also <code>sbrac</code> for a labelr attribute-preserving approach to row-and/or-
column indexing. See also <code>sdrop</code>, <code>ssort</code>, <code>srename</code>, <code>slab</code> and <code>flab</code>.
</p>


<h3>Value</h3>

<p>a labelr label attribute-preserving data.frame consisting of the
selected rows that meet the filtering condition(s).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># make toy demographic (gender, raceth, etc.) data set
set.seed(555)
df &lt;- make_demo_data(n = 1000) # another labelr:: function
# let's add variable VALUE labels for variable "raceth"
df &lt;- add_val_labs(df,
  vars = "raceth", vals = c(1:7),
  labs = c("White", "Black", "Hispanic", "Asian", "AIAN", "Multi", "Other"),
  max.unique.vals = 50
)

head(df, 3)
check_labs_att(df, "val.labs.raceth") # "raceth" lab specifically TRUE

dfsub1 &lt;- ssubset(df, raceth == 2 &amp; age &gt; 70, id, raceth, gender)
head(dfsub1, 3)
check_labs_att(dfsub1, "val.labs.raceth") # "raceth" lab specifically TRUE

dfsub2 &lt;- ssubset(df, raceth %in% c(2:4), age, raceth)
head(dfsub2, 3)
check_labs_att(dfsub2, "val.labs.raceth") # "raceth" lab specifically TRUE
# even if NULL, must supply explicit condition argument
head(ssubset(df, condition = NULL, age, raceth), 3) # better to just use sselect()
head(ssubset(df, age == 60), 3) # skip column selection (will return all cols)
</code></pre>

<hr>
<h2 id='strip_labs'>Strip All labelr Meta-data from a Data Frame</h2><span id='topic+strip_labs'></span>

<h3>Description</h3>

<p><code>strip_labs</code> removes all labelr meta-data attributes (&quot;name.labs&quot;, &quot;val.labs&quot;,
&quot;frame.lab&quot;, and &quot;factor.&quot;) from a data.frame, because you no longer want/need
it for some reason or another.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strip_labs(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strip_labs_+3A_data">data</code></td>
<td>
<p>a data.frame object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Some labelr functions automatically use <code>strip_labs</code>, but you should only
use it if you no longer want or need a given data.frame's labelr meta-data
(i.e., labels!). If you have saved your labelr attributes (using
<code>get_all_lab_atts</code>), you can restore them to the data.frame using
<code>add_lab_atts</code>).
</p>


<h3>Value</h3>

<p>a data.frame object with label attribute meta-data stripped from it.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># make toy demographic (gender, raceth, etc.) data set
set.seed(555)
df &lt;- make_demo_data(n = 1000) # another labelr:: function
# let's add variable VALUE labels for variable "raceth"
df &lt;- add_val_labs(df,
  vars = "raceth", vals = c(1:7),
  labs = c("White", "Black", "Hispanic", "Asian", "AIAN", "Multi", "Other"),
  max.unique.vals = 50
)

get_val_labs(df, "raceth") # it's here
df &lt;- strip_labs(df) # this removes labs from df
get_val_labs(df, "raceth") # it's gone
check_any_lab_atts(df) # FALSE (means "no labs here")
</code></pre>

<hr>
<h2 id='tabl'>Construct Value Label-Friendly Frequency Tables</h2><span id='topic+tabl'></span>

<h3>Description</h3>

<p><code>tabl</code> calculates raw or weighted frequency counts (or proportions) over
arbitrary categorical values (including integer values), which may be
expressed in terms of raw variable values or labelr label values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tabl(
  data,
  vars = NULL,
  labs.on = TRUE,
  qtiles = 4,
  prop.digits = NULL,
  wt = NULL,
  div.by = NULL,
  max.unique.vals = 10,
  sort.freq = TRUE,
  zero.rm = FALSE,
  irreg.rm = FALSE,
  wide.col = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tabl_+3A_data">data</code></td>
<td>
<p>a data.frame.</p>
</td></tr>
<tr><td><code id="tabl_+3A_vars">vars</code></td>
<td>
<p>a quoted character vector of variable names of variables you wish
to include in defining category groups to tabulate over in the table. If NULL
<code>tabl</code> will attempt to construct a table over all combinations of all
non-decimal-having variables in the data.frame that do not exceed the
max.unique.vals threshold. Additionally, note the effects of the qtiles
argument.</p>
</td></tr>
<tr><td><code id="tabl_+3A_labs.on">labs.on</code></td>
<td>
<p>if TRUE (the default), then value labels &ndash; rather than the
raw variable values &ndash; will be displayed in the returned table for any
value-labeled variables. Variables need not be value-labeled: This command
(with this option set to TRUE or FALSE) will work even when no variables are
value-labeled.</p>
</td></tr>
<tr><td><code id="tabl_+3A_qtiles">qtiles</code></td>
<td>
<p>if not NULL, must be a 1L integer between 2 and 100 indicating
the number of quantile categories to employ in temporarily (for purposes of
tabulation) auto-value-labeling numeric columns that exceed the max.unique.vals
threshold. If NULL, no such auto-value-labeling will take place. Note: When
labs.on = TRUE, any pre-existing variable value labels will be used in favor
of the quantile value labels generated by this argument. By default,
qtiles = 4, and the automatically generated quantile category levels will be
labeled as &quot;q025&quot; (i.e., first quartile), &quot;q050&quot;, &quot;q075&quot;, and &quot;q100&quot;.</p>
</td></tr>
<tr><td><code id="tabl_+3A_prop.digits">prop.digits</code></td>
<td>
<p>if non-NULL, cell percentages (proportions) will be
returned instead of frequency counts, and these will be rounded to the digit
specified (e.g., prop.digits = 3 means a value of 0.157 would be returned for
a cell that accounted for 8 observations if the total number of observations
were 51). If NULL (the default), frequency counts will be returned.</p>
</td></tr>
<tr><td><code id="tabl_+3A_wt">wt</code></td>
<td>
<p>an optional vector that includes cell counts or some other
idiosyncratic &quot;importance&quot; weight. If NULL, no weighting will be employed.</p>
</td></tr>
<tr><td><code id="tabl_+3A_div.by">div.by</code></td>
<td>
<p>Divide the returned counts by a constant for scaling purposes.
This may be a number (e.g., div.by = 10 to divide by 10) or a character that
follows the convention &quot;number followed by 'K', 'M', or 'B'&quot;, where, e.g.,
&quot;10K&quot; is translated as 10000, &quot;1B&quot; is translated as 1000000000, etc.</p>
</td></tr>
<tr><td><code id="tabl_+3A_max.unique.vals">max.unique.vals</code></td>
<td>
<p>Integer to specify the maximum number of unique values
of a variable that may be observed for that variable to be included in
tabulations. Note that labelr sets a hard ceiling of 5000 on the total number
of unique value labels that any variable is permitted to have under any
circumstance, as labelr is primarily intended for interactive use with
moderately-sized data.frames. See the qtiles argument for an approach to
incorporating many-valued numeric variables that exceed the max.unique.vals
threshold.</p>
</td></tr>
<tr><td><code id="tabl_+3A_sort.freq">sort.freq</code></td>
<td>
<p>By default, returned table rows are sorted in descending
order of cell frequency (most frequent categories/combinations first). If set
to FALSE, table rows will be sorted by the the distinct values of the vars
(in the order vars are specified).</p>
</td></tr>
<tr><td><code id="tabl_+3A_zero.rm">zero.rm</code></td>
<td>
<p>If TRUE, zero-frequency vars categories/combinations (i.e.,
those not observed in the data.frame) will be filtered from the table. For
tables that would produce more than 10000 rows, this is done automatically.</p>
</td></tr>
<tr><td><code id="tabl_+3A_irreg.rm">irreg.rm</code></td>
<td>
<p>If TRUE, tabulations exclude cases where any applicable
variable (see vars argument) features any of the following &quot;irregular&quot;
values: NA, NaN, Inf, -Inf, or any non-case-sensitive variation on &quot;NA&quot;,
&quot;NAN&quot;, &quot;INF&quot;, or &quot;-INF.&quot; If FALSE, all &quot;irregular&quot; values (as just defined)
are assigned to a &quot;catch-all&quot; category of NA that is featured in the
returned table (if/where present).</p>
</td></tr>
<tr><td><code id="tabl_+3A_wide.col">wide.col</code></td>
<td>
<p>If non-NULL, this is the quoted name of a single column / var
of supplied data.frame whose distinct values (category levels) you wish to be
columns of the returned table. For example, if you are interested in a
cross-tab of &quot;edu&quot; (highest level of education) and &quot;race&quot; (a race/ethnicity
variable), you could supply vars= c(&quot;edu&quot;) and wide.col = &quot;race&quot;, and the
different racial-ethnic group categories would appear as distinct columns,
with &quot;edu&quot; category levels appearing as distinct rows, and cell values
representing the cross-tabbed cell &quot;edu&quot; level frequencies for the respective
&quot;race&quot; groups (see examples). You may supply one wide.col at most.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a labelr-friendly data.frame representation of
multi-variable tabular data, where either value labels or values can be
displayed (use of value labels is the default), and where various convenience
options are provided, such as using frequency weights, using proportions
instead of counts, rounding those percentages, automatically expressing
many-valued, non-value-labeled numerical variables in terms of quantile
category groups, or pivoting / casting one of the categorical variables'
levels (labels) to serve as columns in a cross-tab-like table.
</p>


<h3>Value</h3>

<p>a data.frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># assign mtcars to new data.frame df
df &lt;- mtcars

# add na values to make things interesting
df[1, 1:11] &lt;- NA
rownames(df)[1] &lt;- "Missing Car"

# add value labels
df &lt;- add_val_labs(
  data = df,
  vars = "am",
  vals = c(0, 1),
  labs = c("automatic", "manual")
)

df &lt;- add_val_labs(
  data = df,
  vars = "carb",
  vals = c(1, 2, 3, 4, 6, 8),
  labs = c(
    "1-carb", "2-carbs",
    "3-carbs", "4-carbs",
    "6-carbs", "8-carbs"
  )
)

# var arg can be unquoted if using add_val1()
# note that this is not add_val_labs(); add_val1() has "var" arg instead of "vars
df &lt;- add_val1(
  data = df,
  var = cyl, # note, "var," not "vars" arg
  vals = c(4, 6, 8),
  labs = c(
    "four-cyl",
    "six-cyl",
    "eight-cyl"
  )
)

df &lt;- add_val_labs(
  data = df,
  vars = "gear",
  vals = 3:5,
  labs = c(
    "3-speed",
    "4-speed",
    "5-speed"
  )
)


# lookup mapping
get_val_labs(df)

# introduce other "irregular" values
df$am[1] &lt;- NA

df[2, "am"] &lt;- NaN
df[3, "am"] &lt;- -Inf
df[5, "cyl"] &lt;- "NAN"

# take a look
head(df)

# demonstrate tabl() frequency tabulation function

# this is the "first call" that will be referenced repeatedly below
# labels on, sort by variable values, suppress/exclude NA/irregular values
# ...return counts
tabl(df,
  vars = c("cyl", "am"),
  labs.on = TRUE, # use variable value labels
  sort.freq = FALSE, # sort by vars values (not frequencies)
  irreg.rm = TRUE, # NAs and the like are suppressed
  prop.digits = NULL
) # return counts, not proportions

# same as "first call", except now value labels are off
tabl(df,
  vars = c("cyl", "am"),
  labs.on = FALSE, # use variable values
  sort.freq = FALSE, # sort by vars values (not frequencies)
  irreg.rm = TRUE, # NAs and the like are suppressed
  prop.digits = NULL
) # return counts, not proportions

# same as "first call," except now proportions instead of counts
tabl(df,
  vars = c("cyl", "am"),
  labs.on = TRUE, # use variable value labels
  sort.freq = FALSE, # sort by vars values (not frequencies)
  irreg.rm = TRUE, # NAs and the like are suppressed
  prop.digits = 3
) # return proportions, rounded to 3rd decimal

# same as "first call," except now sort by frequency counts
tabl(df,
  vars = c("cyl", "am"),
  labs.on = TRUE, # use variable value labels
  sort.freq = TRUE, # sort in order of descending frequency
  irreg.rm = TRUE, # NAs and the like are suppressed
  prop.digits = NULL
) # return proportions, rounded to 3rd decimal

# same as "first call," except now use weights
set.seed(2944) # for reproducibility
df$freqwt &lt;- sample(10:50, nrow(df), replace = TRUE) # create (fake) freq wts
tabl(df,
  vars = c("cyl", "am"),
  wt = "freqwt", # use frequency weights
  labs.on = TRUE, # use variable value labels
  sort.freq = FALSE, # sort by vars values (not frequencies)
  irreg.rm = FALSE, # NAs and the like are included/shown
  prop.digits = NULL
) # return counts, not proportions

df$freqwt &lt;- NULL # we don't need this anymore

# now, with extremely large weights to illustrate div.by
set.seed(428441) # for reproducibility
df$freqwt &lt;- sample(1000000:10000000, nrow(df), replace = TRUE) # large freq wts
tabl(df,
  vars = c("cyl", "am"),
  wt = "freqwt", # use frequency weights
  labs.on = TRUE, # use variable value labels
  sort.freq = FALSE, # sort by vars values (not frequencies)
  irreg.rm = FALSE, # NAs and the like are included/shown
  prop.digits = NULL
) # return counts, not proportions

# show div by - Millions
tabl(df,
  vars = c("cyl", "am"),
  wt = "freqwt", # use frequency weights
  labs.on = TRUE, # use variable value labels
  sort.freq = FALSE, # sort by vars values (not frequencies)
  irreg.rm = FALSE, # NAs and the like are included/shown
  prop.digits = NULL, # return counts, not proportions
  div.by = "1M"
) # one million

# show div by - Tens of millions
tabl(df,
  vars = c("cyl", "am"),
  wt = "freqwt", # use frequency weights
  labs.on = TRUE, # use variable value labels
  sort.freq = FALSE, # sort by vars values (not frequencies)
  irreg.rm = FALSE, # NAs and the like are included/shown
  prop.digits = NULL, # return counts, not proportions
  div.by = "10M"
) # ten million

# show div by - 10000
tabl(df,
  vars = c("cyl", "am"),
  wt = "freqwt", # use frequency weights
  labs.on = TRUE, # use variable value labels
  sort.freq = FALSE, # sort by vars values (not frequencies)
  irreg.rm = FALSE, # NAs and the like are included/shown
  prop.digits = NULL, # return counts, not proportions
  div.by = 10000
) # ten thousand; could've used div.by = "10K"

# show div by - 10000, but different syntax
tabl(df,
  vars = c("cyl", "am"),
  wt = "freqwt", # use frequency weights
  labs.on = TRUE, # use variable value labels
  sort.freq = FALSE, # sort by vars values (not frequencies)
  irreg.rm = FALSE, # NAs and the like are included/shown
  prop.digits = NULL, # return counts, not proportions
  div.by = "10K"
) # ten thousand; could've used div.by = 10000

df$freqwt &lt;- NULL # we don't need this anymore

# turn labels off, to make this more compact
# do not show zero values (zero.rm)
# do not show NA values (irreg.rm)
# many-valued numeric variables will be converted to quantile categories by
# ...qtiles argument
tabl(df,
  vars = c("am", "gear", "carb", "mpg"),
  qtiles = 4, # many-valued numerics converted to quantile
  labs.on = FALSE, # use values, not variable value labels
  sort.freq = FALSE, # sort by vars values (not frequencies)
  irreg.rm = TRUE, # NAs and the like are suppressed
  zero.rm = TRUE, # variable combinations that never occur are suppressed
  prop.digits = NULL, # return counts, not proportions
  max.unique.vals = 10
) # drop from table any var with &gt;10 distinct values

# same as above, but include NA/irregular category values,
# zero.rm is TRUE; include unobserved (zero-count) category combinations
tabl(df,
  vars = c("am", "gear", "carb", "mpg"),
  qtiles = 4,
  labs.on = FALSE, # use values, not variable value labels
  sort.freq = TRUE, # sort by frequency
  irreg.rm = FALSE, # preserve/include NAs and irregular values
  zero.rm = FALSE, # include non-observed combinations
  prop.digits = NULL, # return counts, not proportions
  max.unique.vals = 10
) # drop from table any var with &gt;10 distinct values

# show cross-tab view with wide.col arg
tabl(df,
  vars = c("cyl", "am"),
  labs.on = TRUE, # use variable value labels
  sort.freq = TRUE, # sort by vars values (not frequencies)
  irreg.rm = TRUE, # NAs and the like are suppressed
  prop.digits = NULL, # return counts, not proportions
  wide.col = "am"
) # use "am" as a column variable in a cross-tab view

tabl(df,
  vars = c("cyl", "am"),
  labs.on = TRUE, # use variable value labels
  sort.freq = TRUE, # sort by vars values (not frequencies)
  irreg.rm = TRUE, # NAs and the like are suppressed
  prop.digits = NULL, # return counts, not proportions
  wide.col = "cyl"
) # use "cyl" as a column variable in a cross-tab view

# verify select counts using base::subset()
nrow(subset(df, am == 0 &amp; cyl == 4))
nrow(subset(df, am == 0 &amp; cyl == 8))
nrow(subset(df, am == 1 &amp; cyl == 8))
nrow(subset(df, am == 0 &amp; cyl == 6))
nrow(subset(df, am == 1 &amp; cyl == 6))

# will work on an un-labeled data.frame
tabl(mtcars, vars = c("am", "gear", "carb", "mpg"))
</code></pre>

<hr>
<h2 id='taill'>Return Last Rows of a Data Frame with Value Labels Visible</h2><span id='topic+taill'></span>

<h3>Description</h3>

<p><code>taill</code> accepts a labelr value-labeled data.frame and returns the last n
value-labeled rows of that data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>taill(data, n = 6L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="taill_+3A_data">data</code></td>
<td>
<p>a data.frame.</p>
</td></tr>
<tr><td><code id="taill_+3A_n">n</code></td>
<td>
<p>the number of consecutive rows at the end / bottom of the data.frame
to return.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Whereas <code>utils::tail</code> returns the last n rows of a data.frame, <code>taill</code> does
the same thing, substituting value labels for values wherever the former exist.
See also <code>headl</code> and <code>somel</code>.
</p>


<h3>Value</h3>

<p>a data.frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># make toy demographic (gender, raceth, etc.) data set
set.seed(555)
df &lt;- make_demo_data(n = 1000) # another labelr:: function
# let's add variable VALUE labels for variable "raceth"
df &lt;- add_val_labs(df,
  vars = "raceth", vals = c(1:7),
  labs = c("White", "Black", "Hispanic", "Asian", "AIAN", "Multi", "Other"),
  max.unique.vals = 50
)

# let's add variable VALUE labels for variable "gender"
# note that, if we are labeling a single variable, we can use add_val1()
# distinction between add_val1() and add_val_labs() will become more meaningful
# when we get to our Likert example
df &lt;- add_val1(
  data = df, gender, vals = c(0, 1, 2, 3, 4),
  labs = c("M", "F", "TR", "NB", "Diff-Term"), max.unique.vals = 50
)

tail(df) # utils::tail
taill(df) # same, but with value labels in place of values
</code></pre>

<hr>
<h2 id='transfer_labs'>Transfer Labels from One Variable (Column) Name to Another</h2><span id='topic+transfer_labs'></span>

<h3>Description</h3>

<p>Note: <code>transfer_labs</code> searches a data.frame's name.labs and val.labs
attributes and transfers the labels associated with one variable name to
another, so that the first variable no longer has name or value labels
associated with it, and so that whatever name or value labels previously were
associated with it are now associated with the second variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transfer_labs(data, from, to)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transfer_labs_+3A_data">data</code></td>
<td>
<p>a data.frame.</p>
</td></tr>
<tr><td><code id="transfer_labs_+3A_from">from</code></td>
<td>
<p>the unquoted variable name from which labels will be transferred.
Note, even if the variable itself has been dropped from the data.frame (to
include being renamed), its label attribute meta-data may still be present and
available for use by this function (use <code>get_all_lab_atts()</code> to see).</p>
</td></tr>
<tr><td><code id="transfer_labs_+3A_to">to</code></td>
<td>
<p>the unquoted name of the variable to which the labels will be
transferred.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Certain non-labelr data management functions will preserve the labelr labels
that are attached to the passed data.frame, but they will not update those
labels to reflect any changes the function makes to the variable(s). For
example, if one were to use dplyr::rename to change the name of a
value-labeled variable from old name &quot;x1&quot; to new name &quot;satisfaction&quot;, the
labelr attributes associated with &quot;x1&quot; would not be transferred to label
&quot;satisfaction.&quot; <code>transfer_labs</code> allows one to transfer those labels, dis-
associating them with the old name (here, &quot;x1&quot;) and associating them with new
name (here, &quot;satisfaction&quot;).
</p>


<h3>Value</h3>

<p>A data.frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># make toy demographic (gender, raceth, etc.) data set
set.seed(555)
df &lt;- make_demo_data(n = 1000) # another labelr:: function

# let's add variable VALUE labels for variable "raceth"
df &lt;- add_val_labs(df,
  vars = "raceth", vals = c(1:7),
  labs = c("White", "Black", "Hispanic", "Asian", "AIAN", "Multi", "Other"),
  max.unique.vals = 50
)

df &lt;- add_val1(
  data = df, gender, vals = c(0, 1, 2, 3, 4),
  labs = c("M", "F", "TR", "NB", "Diff-Term"), max.unique.vals = 50
)

# let's add variable NAME labels
df &lt;- add_name_labs(df, name.labs = c(
  "age" = "Age in years",
  "raceth" = "racial-ethnic group category",
  "gender" = "gender identity"
))
head(df, 4)
get_name_labs(df)
get_val_labs(df)

df &lt;- dplyr::rename(df, race = raceth) # new name is on left of = sign
df &lt;- dplyr::rename(df, gend = gender) # new name is on left of = sign

head(df, 4)
get_name_labs(df)
get_val_labs(df)

df &lt;- transfer_labs(df, from = raceth, to = race) # labs info transferred from raceth
df &lt;- transfer_labs(df, from = gender, to = gend) # labs info transferred to gend
df &lt;- transfer_labs(df, from = gend, to = nothere) # var nothere does not exist!

head(df, 4)
get_name_labs(df)
get_val_labs(df)
</code></pre>

<hr>
<h2 id='use_name_labs'>Swap Name Labels for Variable Names</h2><span id='topic+use_name_labs'></span><span id='topic+unl'></span>

<h3>Description</h3>

<p>Replace data.frame variable names with their corresponding name labels
(previously assigned using <code>add_name_labs</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>use_name_labs(data, vars = NULL)

unl(data, vars = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="use_name_labs_+3A_data">data</code></td>
<td>
<p>the data.frame whose name labels you wish to &quot;use&quot; (aka swap,
turn on, activate, etc.).</p>
</td></tr>
<tr><td><code id="use_name_labs_+3A_vars">vars</code></td>
<td>
<p>the names of the columns (variables) to which name labels will be
applied. If NULL, all available name labels will be swapped in for the
corresponding variable (column) names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: <code>unl</code> is a compact alias for <code>use_name_labs</code>: they do the same thing,
and the former is easier to type
</p>
<p><code>use_name_labs</code> works with <code>add_name_labs</code>, <code>get_name_labs</code>, <code>use_var_names</code>,
and <code>drop_name_labs</code>, to facilitate the creation, accessing, substitution
(swap out, swap back in), and  destruction of variable name labels for
variable names. Each variable (column) of a data.frame can receive one and
only one &quot;name label,&quot; which typically is a noun phrase that expounds the
meaning of contents of the variable's name (e.g., &quot;Weight in ounces at birth&quot;
might be a name label for a column called &quot;wgt&quot;). <code>add_name_labs</code> associates
these labels with variables in a data.frame, <code>use_name_labs</code> applies or
&quot;turns on&quot; those name labels, i.e., swaps out variable names for
corresponding labels, and you can assign the name-label-swapped data.frame
to an object, or you may use it strictly for display purposes (e.g.,
head(use_name_labs(df), 5)). Because they are intended to be more descriptive
than column names, they tend to be more verbose &ndash; possibly so verbose as to
undermine their value or convenience for anything other than an on-demand
&quot;What is this variable again?&quot; cheat sheet via get_name_labs(). That said,
this may have some uses (see examples).
</p>


<h3>Value</h3>

<p>A data.frame, with (all or the select) name labels swapped in for
the variable names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># variable names and their labels
names_labs_vec &lt;- c(
  "mpg" = "Miles/(US) gallon",
  "cyl" = "Number of cylinders",
  "disp" = "Displacement (cu.in.)",
  "hp" = "Gross horsepower",
  "drat" = "Rear axle ratio",
  "wt" = "Weight (1000 lbs)",
  "qsec" = "1/4 mile time",
  "vs" = "Engine (0 = V-shaped, 1 = straight)",
  "am" = "Transmission (0 = automatic, 1 = manual)",
  "gear" = "Number of forward gears",
  "carb" = "Number of carburetors"
)

# add the above name labeling scheme
mt2 &lt;- add_name_labs(mtcars, name.labs = names_labs_vec)

# use the name labeling scheme (i.e., swap out column/variable names for
# ...their name labels)
mt2 &lt;- use_name_labs(mt2)

# compare these two - concision vs. informativeness
as.data.frame(sapply(mtcars, mean))
as.data.frame(sapply(mt2, mean))

# compare the plot labeling we get with mtcars
with(mtcars, hist(mpg))

get_name_labs(mt2) # get the lab of interest, and paste it into `` below
with(mt2, hist(`Miles/(US) gallon`))

# regression - this is easier to type
lm(mpg ~ cyl, data = mtcars)

# regression with name labs - more painful to type/copy-paste, but may be
# ...the more informative labels are worth it (your mileage/mpg may vary)
# let's see the name labels, then copy paste mpg and cyl labs from console to
# ...where we need them in the lm() call
get_name_labs(mt2) # copy from this call's console output
lm(`Miles/(US) gallon` ~ `Number of cylinders`, data = mt2) # paste into `` here

# same results, more informative labels, more steps/hand-jamming pain
# can also turn them on (semi) permanently
# ...then you can use mt2$ syntax in RStudio, and RStudio will autocomplete,
# then you can backspace delete the "mt2$"
# if you like
mt2 &lt;- use_name_labs(mt2)
lm(`Miles/(US) gallon` ~ `Number of cylinders`, data = mt2)
lm(mpg ~ cyl, data = use_var_names(mt2))

# let's turn them back off
mt2 &lt;- use_var_names(mt2) # use_var_names() as "undo" of use_name_labs()

# back to our previous variable names
head(mt2)
# even with name labels "off," mt2 retains labelr attribute meta-data
# ...which we can strip away using strip_labs()
identical(strip_labs(mt2), mtcars) # and we're back
</code></pre>

<hr>
<h2 id='use_val_lab1'>Replace a Single Data Frame Column's Values with Its Value Labels</h2><span id='topic+use_val_lab1'></span><span id='topic+uvl1'></span>

<h3>Description</h3>

<p>For a single value-labeled column of a data.frame, replace
all of its values with the corresponding value labels and return the modified
data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>use_val_lab1(data, var)

uvl1(data, var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="use_val_lab1_+3A_data">data</code></td>
<td>
<p>the data.frame.</p>
</td></tr>
<tr><td><code id="use_val_lab1_+3A_var">var</code></td>
<td>
<p>the unquoted name of the column (variable) whose values you wish
to replace with the corresponding value labels.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note 1: <code>use_val_lab1</code> is a variant of <code>use_val_labs</code> that allows you to
specify only one variable at a time but that allows you to pass its name
without quoting it (compare use_val_lab1(mtcars, am) to
use_val_labs(mtcars, &quot;am&quot;)).
</p>
<p>Note 2: <code>uvl1</code> is a compact alias for <code>use_val_lab1</code>: they do the same thing,
and the former is easier to type.
</p>
<p>Note 3: This command is intended exclusively for interactive use. In
particular, the var argument must be the literal name of a single variable
(column) found in the supplied data.frame and may NOT be, e.g., the name of a
character vector that contains the variable (column name) of interest. If you
wish to supply a character vector with the names of variables (columns) of
interest, use <code>use_val_labs()</code>.
</p>
<p><code>use_val_lab1</code> replaces a single, value-labeled data.frame column with a
&quot;value labels-on&quot; version of that column. Here, &quot;labels-on&quot; means that the
column's original values are replaced with the corresponding value labels.
Note that the modified column is a simple, self-contained character variable
that cannot itself be converted or reverted back to the original (&quot;labels-off&quot;)
values of its parent/source column.
</p>


<h3>Value</h3>

<p>A data.frame consisting of the originally supplied data.frame, with
the var argument variable's values replaced with its value labels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># swap in "am" value labels for values in mtcars
df &lt;- mtcars # copy of mtcars

# now, add value labels
df &lt;- add_val1(
  data = df,
  var = am,
  vals = c(0, 1),
  labs = c("automatic", "manual")
)

# switch out "am" values for value labels, assign to df_plus
df_plus &lt;- use_val_lab1(df, am)
head(df_plus[c("am")])
</code></pre>

<hr>
<h2 id='use_val_labs'>Swap Variable Value Labels for Variable Values</h2><span id='topic+use_val_labs'></span><span id='topic+uvl'></span>

<h3>Description</h3>

<p>Replace the actual values of data.frame variables with the corresponding
value labels (previous assigned using <code>add_val_labs</code> or a related function).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>use_val_labs(data, vars = NULL)

uvl(data, vars = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="use_val_labs_+3A_data">data</code></td>
<td>
<p>a data.frame.</p>
</td></tr>
<tr><td><code id="use_val_labs_+3A_vars">vars</code></td>
<td>
<p>the names of the columns (variables) for which value labels will
will replace original values in the returned data.frame.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: <code>uvl</code> is a compact alias for <code>use_val_labs</code>: they do the same thing,
and the former is easier to type.
</p>
<p><code>use_val_labs</code> takes a variable value-labeled data.frame and substitutes each
(labeled) variable's value labels for its values, returning a data.frame whose
dimensions, names, and members are the same as the inputted data.frame. This
may be useful if one wishes to view data.frame information using the
(potentially) more intuitively meaningful value labels (e.g., gender=1 values
displayed as &quot;Male&quot; instead of 1).
</p>
<p>Warning: <code>use_val_labs</code> will replace existing variable values with value
labels and cannot be undone. If you wish to preserve variable values, be sure
to assign the result of <code>use_val_labs</code> to a new object. For other ways to
leverage value labels for common data management or inspection tasks, while
preserving raw data values in returned object, see <code>add_lab_cols</code>,
<code>add_lab_dummies</code>, <code>flab</code>, <code>slab</code>, <code>tabl</code>, <code>headl</code>, <code>taill</code>, and <code>somel</code>.
</p>


<h3>Value</h3>

<p>A data.frame, with (all or the select) variable value labels
substituted for original variable values and any affected variables coerced
to character if they were not already.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example #1 - mtcars example, one variable at a time
# one variable at a time, mtcars
df &lt;- mtcars
# now, add value labels
df &lt;- add_val_labs(
  data = df,
  vars = "am",
  vals = c(0, 1),
  labs = c("automatic", "manual")
)

df &lt;- add_val_labs(
  data = df,
  vars = "carb",
  vals = c(1, 2, 3, 4, 6, 8),
  labs = c(
    "1-carb", "2-carbs",
    "3-carbs", "4-carbs",
    "6-carbs", "8-carbs"
  )
)

# var arg can be unquoted if using add_val1()
# note that this is not add_val_labs(); add_val1() has "var" (not "vars) arg
df &lt;- add_val1(
  data = df,
  var = cyl, # note, "var," not "vars" arg
  vals = c(4, 6, 8),
  labs = c(
    "four-cyl",
    "six-cyl",
    "eight-cyl"
  )
)

df &lt;- add_val_labs(
  data = df,
  vars = "gear",
  vals = c(3, 4),
  labs = c(
    "3-speed",
    "4-speed"
  )
)

# Oops, we forgot 5-speeds; let's finish the job.
df &lt;- add_val_labs(
  data = df,
  vars = "gear",
  vals = 5,
  labs = "5-speed"
)

head(use_val_labs(df), 3) # they're there

# Example #2 - (Fake) Likert Data
# add val labs to multiple variables at once
# make a "Likert"-type fake data set to demo
# note, by default, add_val_labs() "vars" arg will do partial matching
# in this case, we catch all vars with "x" in their name
set.seed(272)
dflik &lt;- make_likert_data(scale = 1:7)
vals2label &lt;- 1:7
labs2use &lt;- c(
  "VSD",
  "SD",
  "D",
  "N",
  "A",
  "SA",
  "VSA"
)

dflik &lt;- add_val_labs(
  data = dflik, vars = c("x", "y3"), # note the vars args
  vals = vals2label,
  labs = labs2use,
  partial = TRUE
)

# note, all "x" vars get the labs, as does "y3"
# see vars = args above
lik1 &lt;- use_val_labs(dflik)
head(lik1)
# keep a copy
dflik_conv &lt;- use_val_labs(dflik)
head(dflik_conv, 3)
</code></pre>

<hr>
<h2 id='use_var_names'>Swap (back) Original Variable Names for Name Labels</h2><span id='topic+use_var_names'></span><span id='topic+uvn'></span>

<h3>Description</h3>

<p>&quot;Undo&quot; or reverse <code>use_name_labs</code> operation, restoring the data.frame's
original variable names (assuming they were previously swapped out for labels
using <code>use_name_labs</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>use_var_names(data, vars = NULL)

uvn(data, vars = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="use_var_names_+3A_data">data</code></td>
<td>
<p>a data.frame.</p>
</td></tr>
<tr><td><code id="use_var_names_+3A_vars">vars</code></td>
<td>
<p>the names of the columns (variables) to which the action will be
applied. If NULL, all current variable names (presumably, the labels you
turned on using <code>use_name_labs</code> will be swapped out for their original
variable names available names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: <code>uvn</code> is a compact alias for <code>use_var_names</code>: they do the same thing,
and the former is easier to type
</p>
<p><code>use_var_names</code> works with <code>add_name_labs</code>, <code>get_name_labs</code>, <code>use_name_labs</code>,
and <code>drop_name_labs</code>, to facilitate the creation, accessing, substitution
(swap out, swap back in), and  destruction of variable name labels for
variable names. Each variable (column) of a data.frame can receive one and
only one &quot;name label,&quot; which typically is a noun phrase that expounds the
meaning of contents of the variable's name (e.g., &quot;Weight in ounces at birth&quot;
might be a name label for a column called &quot;wgt&quot;). <code>add_name_labs</code> associates
these labels with variables in a data.frame, <code>use_var_names</code> &quot;turns off&quot; the
name labels are currently being used as variable names as a result of calling
<code>use_name_labs</code> &ndash; that is, <code>use_var_names</code> &quot;undoes&quot; or reverses
<code>use_name_labs</code> &ndash; assuming none of your intervening calls have altered or
dropped your data.frame's name label meta-data attributes.
</p>


<h3>Value</h3>

<p>A data.frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># variable names and their labels
names_labs_vec &lt;- c(
  "mpg" = "Miles/(US) gallon",
  "cyl" = "Number of cylinders",
  "disp" = "Displacement (cu.in.)",
  "hp" = "Gross horsepower",
  "drat" = "Rear axle ratio",
  "wt" = "Weight (1000 lbs)",
  "qsec" = "1/4 mile time",
  "vs" = "Engine (0 = V-shaped, 1 = straight)",
  "am" = "Transmission (0 = automatic, 1 = manual)",
  "gear" = "Number of forward gears",
  "carb" = "Number of carburetors"
)

# add the above name labeling scheme
mt2 &lt;- add_name_labs(mtcars, name.labs = names_labs_vec)

# use the name labeling scheme (i.e., swap out column/variable names for
# ...their name labels)
mt2 &lt;- use_name_labs(mt2)

# compare these two - concision vs. informativeness
as.data.frame(sapply(mtcars, mean))
as.data.frame(sapply(mt2, mean))

# compare the plot labeling we get with mtcars
with(mtcars, hist(mpg))

get_name_labs(mt2) # get the lab of interest, and paste it into `` below
with(mt2, hist(`Miles/(US) gallon`))

# regression - this is easier to type
lm(mpg ~ cyl, data = mtcars)

# regression with name labs - more painful to type/copy-paste, but maybe
# ...the more informative labels are worth it (your mileage may vary)
# let's see the name labels, then copy paste mpg and cyl labs from console to
# ...where we need them in the lm() call
get_name_labs(mt2) # copy from this call's console output
lm(`Miles/(US) gallon` ~ `Number of cylinders`, data = mt2) # paste into `` here

# same results, more informative labels, more steps/hand-jamming pain
# can also turn them on (semi) permanently
# ...then you can use mt2$ syntax in Rstudio, and Rstudio will autocomplete,
# then you can backspace delete the "mt2$"
# if you like
mt2 &lt;- use_name_labs(mt2)
lm(`Miles/(US) gallon` ~ `Number of cylinders`, data = mt2)
lm(mpg ~ cyl, data = use_var_names(mt2))

# let's turn them back off
mt2 &lt;- use_var_names(mt2) # use_var_names() as "undo" of use_name_labs()

# back to our previous variable names
head(mt2)
# even with name labels "off," mt2 retains labelr attribute meta-data
# ...which we can strip away using strip_labs()
identical(strip_labs(mt2), mtcars) # and we're back
</code></pre>

<hr>
<h2 id='v'>Specify Column Names without Quoting Them</h2><span id='topic+v'></span>

<h3>Description</h3>

<p>Alternative to the base <code>c()</code> combine operator that allows one to select
columns by passing unquoted comma-separated column names instead of quoted,
comma-separated column names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>v(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="v_+3A_...">...</code></td>
<td>
<p>a vector of unquoted, comma-separated column names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Does not support or combine with other subsetting operators, such as negative
indexing or colon: names must be full, individual column names, separated by
commas (see examples).
</p>


<h3>Value</h3>

<p>A character vector of quoted, comma-separated, column names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mt2a &lt;- mtcars[c("am", "cyl", "mpg")]
mt2b &lt;- mtcars[v(am, cyl, mpg)]
identical(mt2a, mt2b) # TRUE

# silly demo
mtlabs &lt;- mtcars
mtlabs &lt;- add_val_labs(
  data = mtlabs,
  vars = "am",
  vals = c(0, 1),
  labs = v(a, m) # equivalent to c("a", "m")
)

get_val_labs(mtlabs)
</code></pre>

<hr>
<h2 id='val_labs_vec'>Replace a Variable's Values with Its Value Labels and Return as a Vector</h2><span id='topic+val_labs_vec'></span><span id='topic+vlv'></span>

<h3>Description</h3>

<p>Select a single, value-labeled data.frame column (variable), replace each of
its values with the corresponding value labels, and return the result as a
vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>val_labs_vec(data, var)

vlv(data, var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="val_labs_vec_+3A_data">data</code></td>
<td>
<p>a data.frame.</p>
</td></tr>
<tr><td><code id="val_labs_vec_+3A_var">var</code></td>
<td>
<p>the unquoted name of the column (variable) whose values will be
converted to the associated value labels in the returned vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note 1: <code>vlv</code> is a compact alias for <code>val_labs_vec</code>: they do the same thing,
and the former is easier to type.
</p>
<p>Note 2: This command is intended exclusively for interactive use. In
particular, the var argument must be the literal name of a single variable
(column) found in the supplied data.frame and may NOT be, e.g., the name of a
character vector that contains the variable (column name) of interest.
</p>
<p><code>val_labs_vec</code> works with other labelr functions to facilitate creation,
modification, accessing, use, and destruction of variable-specific value
labels. This functionality is equivalent to calling <code>use_val_labs</code> with a
single variable passed to the vars argument, except that the latter returns
the entire data.frame with that variable modified, while <code>val_labs_vec</code>
returns only that single modified variable itself (as a vector)
</p>


<h3>Value</h3>

<p>A vector containing the original data.frame variable (var), after
its values have been converted to their corresponding value labels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- mtcars
# add value labels
df &lt;- add_val_labs(
  data = df,
  var = "am",
  vals = c(0, 1),
  labs = c("automatic", "manual")
)

am_labs &lt;- val_labs_vec(df, am)

length(df$am)

class(df$am)

df$am

length(am_labs)

class(am_labs)

am_labs

</code></pre>

<hr>
<h2 id='with_both_labs'>Overlay Variable Name and Value Labels Onto Arbitrary R Function Calls</h2><span id='topic+with_both_labs'></span><span id='topic+wbl'></span>

<h3>Description</h3>

<p><code>with_both_labs</code> instructs R function calls to swap in variable name labels
for column names AND variable value labels for variable values in the objects
they return or side effects they produce.
</p>
<p>Note: <code>wbl</code> is a compact alias for <code>with_both_labs</code>: they do the same thing,
and the former is easier to type
</p>


<h3>Usage</h3>

<pre><code class='language-R'>with_both_labs(data, ...)

wbl(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="with_both_labs_+3A_data">data</code></td>
<td>
<p>a data.frame with variable name labels and variable value labels.</p>
</td></tr>
<tr><td><code id="with_both_labs_+3A_...">...</code></td>
<td>
<p>an additional expression passed to dots (quotes and dollar signs
are not needed or permitted).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>with_both_labs</code> (see also alias <code>wbl</code>) is intended for interactive use. With
it, you pass a name-labeled data.frame followed, followed by a comma, followed
by an unquoted R expression (function call) to be evaluated within that
data.frame, and both name and value labels will be substituted for their
corresponding, respective column names and variable value in any returned
object or side effects. Your function call (expression) should refer to
columns of the data.frame passed via your data argument, NOT their name
labels, as the intent is to allow you to pass functions in terms of the
(typically much more concise and familiar) column names while having the
results displayed / presented in terms of the more informative (but more
verbose and typically non-standard) name labels. See examples.
</p>
<p>Caution 1: Typically, <code>with_name_labs</code> will be more appropriate than
<code>with_both_labs</code>, since conversion of variables' values to their corresponding
labels frequently entails conversion from numeric to character.
</p>
<p>Caution 2: <code>with_both_labs</code> is a rudimentary function that leverages basic
regular expressions and <code>eval(parse(text=))</code> to substitute name labels for
variable names behind the scenes. It appears to be robust to a range of the
most common commands and operators (e.g., formula or modeling operators, such
as ~ , * , +, :, =, and |). However, it is intended strictly as a convenience
for relatively simple, interactive, single-line-expression, data exploration,
description, or simple model-fitting use cases. It is expressly NOT intended
for: (1) multi-step workflows or pipes, (2) expressions that require or make
reference to objects existing outside the supplied data.frame, or (3) data
management operations aimed at modifying the supplied data.frame. Again, see
the examples for the types of expressions/use cases envisioned.
</p>


<h3>Value</h3>

<p>the value of the evaluated <code>expr</code>, with name and value labels
substituted for variable (column) names and values, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># assign mtcars to new data.frame mt2
mt2 &lt;- mtcars

# add name labs
mt2 &lt;- add_name_labs(mt2,
  name.labs = c(
    "mpg" = "Miles/(US) gallon",
    "cyl" = "Number of cylinders",
    "disp" = "Displacement (cu.in.)",
    "hp" = "Gross horsepower",
    "drat" = "Rear axle ratio",
    "wt" = "Weight (1000 lbs)",
    "qsec" = "1/4 mile time",
    "vs" = "Engine (0 = V-shaped, 1 = straight)",
    "am" = "Transmission (0 = automatic, 1 = manual)",
    "gear" = "Number of forward gears",
    "carb" = "Number of carburetors"
  )
)


# add many-to-1 value labels
mt2 &lt;- add_m1_lab(
  data = mt2,
  vars = "gear",
  vals = 4:5,
  lab = "4+"
)

# add many-to-1 value labels
mt2 &lt;- add_val_labs(
  data = mt2,
  vars = "am",
  vals = c(0, 1),
  lab = c("auto", "man")
)
with_both_labs(mt2, t.test(mpg ~ am))
with_both_labs(mt2, lm(mpg ~ am))
with_both_labs(mt2, xtabs(~gear))
xtabs(~ mt2$gear)
</code></pre>

<hr>
<h2 id='with_name_labs'>Overlay Variable Name Labels Onto Arbitrary R Function Calls</h2><span id='topic+with_name_labs'></span><span id='topic+wnl'></span>

<h3>Description</h3>

<p><code>with_name_labs</code> instructs R function calls to swap in variable name labels
for column names in the objects they return or side effects they produce.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>with_name_labs(data, ...)

wnl(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="with_name_labs_+3A_data">data</code></td>
<td>
<p>a data.frame with name labels.</p>
</td></tr>
<tr><td><code id="with_name_labs_+3A_...">...</code></td>
<td>
<p>an additional expression passed to dots (quotes and dollar signs
are not needed or permitted).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: <code>wnl</code> is a compact alias for <code>with_name_labs</code>: they do the same thing,
and the former is easier to type
</p>
<p><code>with_name_labs</code> is intended for interactive use. With it, you pass a
name-labeled data.frame, followed by a comma, followed by an unquoted R
expression (function call) to be evaluated within that data.frame, and name
labels will be substituted for column names in any returned object or side
effects. Your function call (expression) should refer to columns of the
data.frame, NOT their name labels, as the intent is to allow you to pass
functions in terms of the (typically much more concise and familiar) column
names while having the results displayed / presented in terms of the more
informative (but more verbose and typically non-standard) name labels.
See examples.
</p>
<p>Caution: <code>with_name_labs</code> is a rudimentary function that leverages basic,
fairly literal (and potentially brittle!) regular expressions and
<code>eval(parse(text=))</code> to substitute name labels for variable names behind the
scenes. It appears to be robust to a range of common commands and operators
(e.g., ~ , * , +, :, ::, =, and |). However, it is intended strictly as a
convenience for relatively simple, interactive, single-line-expression use
cases, involving data exploration, description, or simple model-fitting. It
is expressly NOT intended for: (1) multi-step workflows or pipes, (2)
expressions that require or make  reference to objects existing outside the
supplied data.frame, or (3) data management operations aimed at modifying
(e.g., subsetting, merging, renaming) &ndash; as opposed to merely describing or
analyzing &ndash; the supplied data.frame. Again, see the examples for the types
of expressions/use cases envisioned.
</p>


<h3>Value</h3>

<p>the value of the evaluated <code>expr</code>, with name labels substituted for
variable (column) names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># assign mtcars to new data.frame mt2
mt2 &lt;- mtcars

# add name labs
mt2 &lt;- add_name_labs(mt2,
  name.labs = c(
    "mpg" = "Miles/(US) gallon",
    "cyl" = "Number of cylinders",
    "disp" = "Displacement (cu.in.)",
    "hp" = "Gross horsepower",
    "drat" = "Rear axle ratio",
    "wt" = "Weight (1000 lbs)",
    "qsec" = "1/4 mile time",
    "vs" = "Engine (0 = V-shaped, 1 = straight)",
    "am" = "Transmission (0 = automatic, 1 = manual)",
    "gear" = "Number of forward gears",
    "carb" = "Number of carburetors"
  )
)


with_name_labs(mt2, t.test(mpg ~ am))
with_name_labs(mt2, lm(mpg ~ am))
with_name_labs(mt2, summary(mt2))
with_name_labs(mt2, cor(mt2, use = "pairwise.complete.obs"))
with_name_labs(mt2, xtabs(~gear))
xtabs(~ mt2$gear)
with_name_labs(mt2, cor(mpg, carb))
with_name_labs(mt2, hist(mpg))
with_name_labs(mt2, plot(mpg, carb))
with_name_labs(mt2, head(gear))
with_name_labs(mt2, summary(mt2))
</code></pre>

<hr>
<h2 id='with_val_labs'>Evaluate an Expression in a Value Labels-on Data Environment</h2><span id='topic+with_val_labs'></span><span id='topic+wvl'></span>

<h3>Description</h3>

<p><code>with_val_labs</code> wraps a data.frame in <code>use_val_labs</code> and wraps the resulting
data.frame in <code>base::with</code> in support of <code>base::with</code>-like non-standard
evaluation (see examples).
</p>
<p>Note: <code>wvl</code> is a compact alias for <code>with_val_labs</code>: they do the same thing,
and the former is easier to type
</p>


<h3>Usage</h3>

<pre><code class='language-R'>with_val_labs(data, ...)

wvl(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="with_val_labs_+3A_data">data</code></td>
<td>
<p>a data.frame with value-labeled columns.</p>
</td></tr>
<tr><td><code id="with_val_labs_+3A_...">...</code></td>
<td>
<p>additional arguments passed to dots, typically an expression
involving a function called on unquoted variable(s) (see examples).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>with_val_labs</code> (see also alias <code>wvl</code>) is useful for applying certain
nominal-variable-friendly functions (chiefly, <code>table</code> and the like) to
value-labeled data.frames. See also <code>base::with</code>. See also <code>tabl</code>,
<code>with_name_labs</code>, and <code>with_both_labs</code>.
</p>


<h3>Value</h3>

<p>the value of the evaluated <code>expr</code>, with value labels
substituted for variable values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># make toy demographic (gender, raceth, etc.) data set
set.seed(555)
df &lt;- make_demo_data(n = 1000) # another labelr:: function
# let's add variable VALUE labels for variable "raceth"
df &lt;- add_val_labs(df,
  vars = "raceth", vals = c(1:7),
  labs = c("White", "Black", "Hispanic", "Asian", "AIAN", "Multi", "Other"),
  max.unique.vals = 50
)

# let's add variable VALUE labels for variable "gender"
# note that, if we are labeling a single variable, we can use add_val1()
# distinction between add_val1() and add_val_labs() will become more meaningful
# when we get to our Likert example
df &lt;- add_val1(
  data = df, gender, vals = c(0, 1, 2, 3, 4),
  labs = c("M", "F", "TR", "NB", "Diff-Term"), max.unique.vals = 50
)

# "with_val_labs" - with()-like function that swaps value labels out for value values
# compare with(df, ...) to with_val_labs(df,...)
with(df, table(gender, raceth)) # without labels

# the same data (note that presentation order changes d/t alphabetical ordering)
with_val_labs(df, table(gender, raceth)) # with labels
with(use_val_labs(df), table(gender, raceth)) # above is shorthand for this

# just raceth
with(df, table(raceth)) # with
with_val_labs(df, table(raceth)) # with_val_labs

# another use case
with(df, unique(raceth)) # with
with_val_labs(df, unique(raceth)) # with_val_labs

# another
with(df, modelr::typical(raceth)) # numerical median!
with_val_labs(df, modelr::typical(raceth)) # modal label (not the median!)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
