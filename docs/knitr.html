<!DOCTYPE html><html><head><title>Help for package knitr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {knitr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#all_labels'><p>Get all chunk labels in a document</p></a></li>
<li><a href='#all_patterns'><p>All built-in patterns</p></a></li>
<li><a href='#asis_output'><p>Mark an R object with a special class</p></a></li>
<li><a href='#cache_engines'><p>Cache engines of other languages</p></a></li>
<li><a href='#clean_cache'><p>Clean cache files that are probably no longer needed</p></a></li>
<li><a href='#combine_words'><p>Combine multiple words into a single string</p></a></li>
<li><a href='#convert_chunk_header'><p>Convert the in-header chunk option syntax to the in-body syntax</p></a></li>
<li><a href='#current_input'><p>Query the current input filename</p></a></li>
<li><a href='#dep_auto'><p>Build automatic dependencies among chunks</p></a></li>
<li><a href='#dep_prev'><p>Make later chunks depend on previous chunks</p></a></li>
<li><a href='#download_image'><p>Download an image from the web and include it in a document</p></a></li>
<li><a href='#engine_output'><p>An output wrapper for language engine output</p></a></li>
<li><a href='#extract_raw_output'><p>Mark character strings as raw output that should not be converted</p></a></li>
<li><a href='#fig_chunk'><p>Obtain the figure filenames for a chunk</p></a></li>
<li><a href='#fig_path'><p>Path for figure files</p></a></li>
<li><a href='#hook_ffmpeg_html'><p>Hooks to create animations in HTML output</p></a></li>
<li><a href='#hook_movecode'><p>Some potentially useful document hooks</p></a></li>
<li><a href='#hook_pdfcrop'><p>Built-in chunk hooks to extend knitr</p></a></li>
<li><a href='#hook_plot_html'><p>Default plot hooks for different output formats</p></a></li>
<li><a href='#image_uri'><p>Encode an image file to a data URI</p></a></li>
<li><a href='#imgur_upload'><p>Upload an image to imgur.com</p></a></li>
<li><a href='#include_graphics'><p>Embed external images in <span class="pkg">knitr</span> documents</p></a></li>
<li><a href='#include_url'><p>Embed a URL as an HTML iframe or a screenshot in <span class="pkg">knitr</span> documents</p></a></li>
<li><a href='#inline_expr'><p>Wrap code using the inline R expression syntax</p></a></li>
<li><a href='#is_latex_output'><p>Check the current input and output type</p></a></li>
<li><a href='#is_low_change'><p>Compare two recorded plots</p></a></li>
<li><a href='#kable'><p>Create tables in LaTeX, HTML, Markdown and reStructuredText</p></a></li>
<li><a href='#knit'><p>Knit a document</p></a></li>
<li><a href='#knit_child'><p>Knit a child document</p></a></li>
<li><a href='#knit_code'><p>The code manager to manage code in all chunks</p></a></li>
<li><a href='#knit_engines'><p>Engines of other languages</p></a></li>
<li><a href='#knit_exit'><p>Exit knitting early</p></a></li>
<li><a href='#knit_expand'><p>A simple macro preprocessor for templating purposes</p></a></li>
<li><a href='#knit_filter'><p>Spell check filter for source documents</p></a></li>
<li><a href='#knit_global'><p>The global environment in which code chunks are evaluated</p></a></li>
<li><a href='#knit_hooks'><p>Hooks for R code chunks, inline R code and output</p></a></li>
<li><a href='#knit_meta'><p>Metadata about objects to be printed</p></a></li>
<li><a href='#knit_params'><p>Extract knit parameters from a document</p></a></li>
<li><a href='#knit_params_yaml'><p>Extract knit parameters from YAML text</p></a></li>
<li><a href='#knit_patterns'><p>Patterns to match and extract R code in a document</p></a></li>
<li><a href='#knit_print'><p>A custom printing function</p></a></li>
<li><a href='#knit_rd'><p>Knit package documentation</p></a></li>
<li><a href='#knit_theme'><p>Syntax highlighting themes</p></a></li>
<li><a href='#knit_watch'><p>Watch an input file continuously and knit it when it is updated</p></a></li>
<li><a href='#knit2html'><p>Convert markdown to HTML using knit() and mark_html()</p></a></li>
<li><a href='#knit2pandoc'><p>Convert various input files to various output files using <code>knit()</code> and</p>
Pandoc</a></li>
<li><a href='#knit2pdf'><p>Convert Rnw or Rrst files to PDF</p></a></li>
<li><a href='#knit2wp'><p>Knit an R Markdown document and post it to WordPress</p></a></li>
<li><a href='#knitr-package'><p>A general-purpose tool for dynamic report generation in R</p></a></li>
<li><a href='#load_cache'><p>Load the cache database of a code chunk</p></a></li>
<li><a href='#opts_chunk'><p>Default and current chunk options</p></a></li>
<li><a href='#opts_hooks'><p>Hooks for code chunk options</p></a></li>
<li><a href='#opts_knit'><p>Options for the knitr package</p></a></li>
<li><a href='#opts_template'><p>Template for creating reusable chunk options</p></a></li>
<li><a href='#pandoc'><p>A Pandoc wrapper to convert documents to other formats</p></a></li>
<li><a href='#partition_chunk'><p>Partition chunk options from the code chunk body</p></a></li>
<li><a href='#pat_rnw'><p>Set regular expressions to read input documents</p></a></li>
<li><a href='#plot_crop'><p>Crop a plot (remove the edges) using PDFCrop or ImageMagick</p></a></li>
<li><a href='#rand_seed'><p>An unevaluated expression to return .Random.seed if exists</p></a></li>
<li><a href='#raw_block'><p>Mark character strings as raw blocks in R Markdown</p></a></li>
<li><a href='#read_chunk'><p>Read chunks from an external script</p></a></li>
<li><a href='#read_rforge'><p>Read source code from R-Forge</p></a></li>
<li><a href='#render_html'><p>Set or get output hooks for different output formats</p></a></li>
<li><a href='#rnw2pdf'><p>Convert an &lsquo;<span class="file">Rnw</span>&rsquo; document to PDF</p></a></li>
<li><a href='#rocco'><p>Knit R Markdown using the classic Docco style</p></a></li>
<li><a href='#rst2pdf'><p>A wrapper for rst2pdf</p></a></li>
<li><a href='#set_alias'><p>Set aliases for chunk options</p></a></li>
<li><a href='#set_header'><p>Set the header information</p></a></li>
<li><a href='#set_parent'><p>Specify the parent document of child documents</p></a></li>
<li><a href='#sew'><p>Wrap evaluated results for output</p></a></li>
<li><a href='#spin'><p>Spin goat's hair into wool</p></a></li>
<li><a href='#spin_child'><p>Spin a child R script</p></a></li>
<li><a href='#stitch'><p>Automatically create a report based on an R script and a template</p></a></li>
<li><a href='#Sweave2knitr'><p>Convert Sweave to knitr documents</p></a></li>
<li><a href='#vignette_engines'><p>Package vignette engines</p></a></li>
<li><a href='#wrap_rmd'><p>Wrap long lines in Rmd files</p></a></li>
<li><a href='#write_bib'><p>Generate BibTeX bibliography databases for R packages</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A General-Purpose Package for Dynamic Report Generation in R</td>
</tr>
<tr>
<td>Version:</td>
<td>1.45</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a general-purpose tool for dynamic report generation in R
    using Literate Programming techniques.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>evaluate (&ge; 0.15), highr, methods, tools, xfun (&ge; 0.39),
yaml (&ge; 2.1.19)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bslib, codetools, DBI (&ge; 0.4-1), digest, formatR, gifski,
gridSVG, htmlwidgets (&ge; 0.7), curl, jpeg, JuliaCall (&ge;
0.11.1), magick, markdown (&ge; 1.3), png, ragg, reticulate (&ge;
1.4), rgl (&ge; 0.95.1201), rlang, rmarkdown, sass, showtext,
styler (&ge; 1.2.0), targets (&ge; 0.6.0), testit, tibble,
tikzDevice (&ge; 0.10), tinytex (&ge; 0.46), webshot, rstudioapi,
svglite, xml2 (&ge; 1.2.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://yihui.org/knitr/">https://yihui.org/knitr/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/yihui/knitr/issues">https://github.com/yihui/knitr/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>Package vignettes based on R Markdown v2 or
reStructuredText require Pandoc (http://pandoc.org). The
function rst2pdf() requires rst2pdf
(https://github.com/rst2pdf/rst2pdf).</td>
</tr>
<tr>
<td>Collate:</td>
<td>'block.R' 'cache.R' 'utils.R' 'citation.R' 'hooks-html.R'
'plot.R' 'defaults.R' 'concordance.R' 'engine.R' 'highlight.R'
'themes.R' 'header.R' 'hooks-asciidoc.R' 'hooks-chunk.R'
'hooks-extra.R' 'hooks-latex.R' 'hooks-md.R' 'hooks-rst.R'
'hooks-textile.R' 'hooks.R' 'output.R' 'package.R' 'pandoc.R'
'params.R' 'parser.R' 'pattern.R' 'rocco.R' 'spin.R' 'table.R'
'template.R' 'utils-conversion.R' 'utils-rd2html.R'
'utils-string.R' 'utils-sweave.R' 'utils-upload.R'
'utils-vignettes.R' 'zzz.R'</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-27 03:03:09 UTC; yihui</td>
</tr>
<tr>
<td>Author:</td>
<td>Yihui Xie <a href="https://orcid.org/0000-0003-0645-5666"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Abhraneel Sarma [ctb],
  Adam Vogt [ctb],
  Alastair Andrew [ctb],
  Alex Zvoleff [ctb],
  Amar Al-Zubaidi [ctb],
  Andre Simon [ctb] (the CSS files under inst/themes/ were derived from
    the Highlight package http://www.andre-simon.de),
  Aron Atkins [ctb],
  Aaron Wolen [ctb],
  Ashley Manton [ctb],
  Atsushi Yasumoto <a href="https://orcid.org/0000-0002-8335-495X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Ben Baumer [ctb],
  Brian Diggs [ctb],
  Brian Zhang [ctb],
  Bulat Yapparov [ctb],
  Cassio Pereira [ctb],
  Christophe Dervieux [ctb],
  David Hall [ctb],
  David Hugh-Jones [ctb],
  David Robinson [ctb],
  Doug Hemken [ctb],
  Duncan Murdoch [ctb],
  Elio Campitelli [ctb],
  Ellis Hughes [ctb],
  Emily Riederer [ctb],
  Fabian Hirschmann [ctb],
  Fitch Simeon [ctb],
  Forest Fang [ctb],
  Frank E Harrell Jr [ctb] (the Sweavel package at inst/misc/Sweavel.sty),
  Garrick Aden-Buie [ctb],
  Gregoire Detrez [ctb],
  Hadley Wickham [ctb],
  Hao Zhu [ctb],
  Heewon Jeon [ctb],
  Henrik Bengtsson [ctb],
  Hiroaki Yutani [ctb],
  Ian Lyttle [ctb],
  Hodges Daniel [ctb],
  Jacob Bien [ctb],
  Jake Burkhead [ctb],
  James Manton [ctb],
  Jared Lander [ctb],
  Jason Punyon [ctb],
  Javier Luraschi [ctb],
  Jeff Arnold [ctb],
  Jenny Bryan [ctb],
  Jeremy Ashkenas [ctb, cph] (the CSS file at
    inst/misc/docco-classic.css),
  Jeremy Stephens [ctb],
  Jim Hester [ctb],
  Joe Cheng [ctb],
  Johannes Ranke [ctb],
  John Honaker [ctb],
  John Muschelli [ctb],
  Jonathan Keane [ctb],
  JJ Allaire [ctb],
  Johan Toloe [ctb],
  Jonathan Sidi [ctb],
  Joseph Larmarange [ctb],
  Julien Barnier [ctb],
  Kaiyin Zhong [ctb],
  Kamil Slowikowski [ctb],
  Karl Forner [ctb],
  Kevin K. Smith [ctb],
  Kirill Mueller [ctb],
  Kohske Takahashi [ctb],
  Lorenz Walthert [ctb],
  Lucas Gallindo [ctb],
  Marius Hofert [ctb],
  Martin Modrák [ctb],
  Michael Chirico [ctb],
  Michael Friendly [ctb],
  Michal Bojanowski [ctb],
  Michel Kuhlmann [ctb],
  Miller Patrick [ctb],
  Nacho Caballero [ctb],
  Nick Salkowski [ctb],
  Niels Richard Hansen [ctb],
  Noam Ross [ctb],
  Obada Mahdi [ctb],
  Pavel N. Krivitsky
    <a href="https://orcid.org/0000-0002-9101-3362"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Pedro Faria [ctb],
  Qiang Li [ctb],
  Ramnath Vaidyanathan [ctb],
  Richard Cotton [ctb],
  Robert Krzyzanowski [ctb],
  Rodrigo Copetti [ctb],
  Romain Francois [ctb],
  Ruaridh Williamson [ctb],
  Sagiru Mati <a href="https://orcid.org/0000-0003-1413-3974"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Scott Kostyshak [ctb],
  Sebastian Meyer [ctb],
  Sietse Brouwer [ctb],
  Simon de Bernard [ctb],
  Sylvain Rousseau [ctb],
  Taiyun Wei [ctb],
  Thibaut Assus [ctb],
  Thibaut Lamadon [ctb],
  Thomas Leeper [ctb],
  Tim Mastny [ctb],
  Tom Torsney-Weir [ctb],
  Trevor Davis [ctb],
  Viktoras Veitas [ctb],
  Weicheng Zhu [ctb],
  Wush Wu [ctb],
  Zachary Foster [ctb],
  Zhian N. Kamvar <a href="https://orcid.org/0000-0003-1458-7108"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Posit Software, PBC [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yihui Xie &lt;xie@yihui.name&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-30 09:10:12 UTC</td>
</tr>
</table>
<hr>
<h2 id='all_labels'>Get all chunk labels in a document</h2><span id='topic+all_labels'></span><span id='topic+all_rcpp_labels'></span>

<h3>Description</h3>

<p>The function <code>all_labels()</code> returns all chunk labels as a character
vector. Optionally, you can specify a series of conditions to filter the
labels. The function 'all_rcpp_labels()' is a wrapper function for
<code>all_labels(engine == 'Rcpp')</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_labels(...)

all_rcpp_labels(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all_labels_+3A_...">...</code></td>
<td>
<p>A vector of R expressions, each of which should return <code>TRUE</code>
or <code>FALSE</code>. The expressions are evaluated using the <em>local</em> chunk
options of each code chunk as the environment, which means global chunk
options are not considered when evaluating these expressions. For example,
if you set the global chunk option <code>opts_chunk$set(purl = TRUE)</code>,
<code>all_labels(purl == TRUE)</code> will <em>not</em> return the labels of all
code chunks, but will only return the labels of those code chunks that have
local chunk options <code>purl = TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For example, suppose the condition expression is <code>engine == 'Rcpp'</code>, the
object <code>engine</code> is the local chunk option <code>engine</code>. If an
expression fails to be evaluated (e.g. when a certain object does not exist),
<code>FALSE</code> is returned and the label for this chunk will be filtered out.
</p>


<h3>Value</h3>

<p>A character vector.
</p>


<h3>Note</h3>

<p>Empty code chunks are always ignored, including those chunks that are
empty in the original document but filled with code using chunk options
such as <code>ref.label</code> or <code>code</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># the examples below are meaningless unless you put them in a knitr document
all_labels()
all_labels(engine == "Rcpp")
all_labels(echo == FALSE &amp;&amp; results != "hide")
# or separate the two conditions
all_labels(echo == FALSE, results != "hide")
</code></pre>

<hr>
<h2 id='all_patterns'>All built-in patterns</h2><span id='topic+all_patterns'></span>

<h3>Description</h3>

<p>This object is a named list of all built-in patterns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_patterns
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 8.
</p>


<h3>References</h3>

<p>Usage: <a href="https://yihui.org/knitr/patterns/">https://yihui.org/knitr/patterns/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+knit_patterns">knit_patterns</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>all_patterns$rnw
all_patterns$html

str(all_patterns)
</code></pre>

<hr>
<h2 id='asis_output'>Mark an R object with a special class</h2><span id='topic+asis_output'></span>

<h3>Description</h3>

<p>This is a convenience function that assigns the input object a class named
<code>knit_asis</code>, so that <span class="pkg">knitr</span> will treat it as is (the effect is the
same as the chunk option <code>results = 'asis'</code>) when it is written to the
output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asis_output(x, meta = NULL, cacheable = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asis_output_+3A_x">x</code></td>
<td>
<p>An R object. Typically a character string, or an object which can
be converted to a character string via <code><a href="base.html#topic+as.character">as.character</a>()</code>.</p>
</td></tr>
<tr><td><code id="asis_output_+3A_meta">meta</code></td>
<td>
<p>Additional metadata of the object to be printed. The metadata
will be collected when the object is printed, and accessible via
<code>knit_meta()</code>.</p>
</td></tr>
<tr><td><code id="asis_output_+3A_cacheable">cacheable</code></td>
<td>
<p>Boolean indicating whether this object is cacheable. If
<code>FALSE</code>, <span class="pkg">knitr</span> will stop when caching is enabled on code chunks
that contain <code>asis_output()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is normally used in a custom S3 method based on the printing
function <code><a href="#topic+knit_print">knit_print</a>()</code>.
</p>
<p>For the <code>cacheable</code> argument, you need to be careful when printing the
object involves non-trivial side effects, in which case it is strongly
recommended to use <code>cacheable = FALSE</code> to instruct <span class="pkg">knitr</span> that this
object should not be cached using the chunk option <code>cache = TRUE</code>,
otherwise the side effects will be lost the next time the chunk is knitted.
For example, printing a <span class="pkg">shiny</span> input element or an HTML widget in an R
Markdown document may involve registering metadata about some JavaScript
libraries or stylesheets, and the metadata may be lost if we cache the code
chunk, because the code evaluation will be skipped the next time. This
particular issue has been solved in <span class="pkg">knitr</span> after v1.13 (the metadata
will be saved and loaded automatically when caching is enabled), but not all
metadata can be saved and loaded next time and still works in the new R
session.
</p>


<h3>Note</h3>

<p>This function only works in top-level R expressions, and it will not
work when it is called inside another expression, such as a for-loop. See
<a href="https://github.com/yihui/knitr/issues/1137">https://github.com/yihui/knitr/issues/1137</a> for a discussion.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see ?knit_print
</code></pre>

<hr>
<h2 id='cache_engines'>Cache engines of other languages</h2><span id='topic+cache_engines'></span>

<h3>Description</h3>

<p>This object controls how to load cached environments from languages other
than R (when the chunk option <code>engine</code> is not <code>'R'</code>). Each
component in this object is a function that takes the current path to the
chunk cache and loads it into the language environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cache_engines
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 7.
</p>


<h3>Details</h3>

<p>The cache engine function has one argument <code>options</code>, a list containing
all chunk options. Note that <code>options$hash</code> is the path to the current
chunk cache with the chunk's hash, but without any file extension, and the
language engine may write a cache database to this path (with an extension).
</p>
<p>The cache engine function should load the cache environment and should know
the extension appropriate for the language.
</p>


<h3>References</h3>

<p>See <a href="https://github.com/rstudio/reticulate/pull/167">https://github.com/rstudio/reticulate/pull/167</a> for an
implementation of a cache engine for Python.
</p>

<hr>
<h2 id='clean_cache'>Clean cache files that are probably no longer needed</h2><span id='topic+clean_cache'></span>

<h3>Description</h3>

<p>If you remove or rename some cached code chunks, their original cache files
will not be automatically cleaned. You can use this function to identify
these possible files, and clean them if you are sure they are no longer
needed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_cache(clean = FALSE, path = opts_chunk$get("cache.path"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clean_cache_+3A_clean">clean</code></td>
<td>
<p>Boolean; whether to remove the files.</p>
</td></tr>
<tr><td><code id="clean_cache_+3A_path">path</code></td>
<td>
<p>Path to the cache.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The identification is not guaranteed to be correct, especially when
multiple documents share the same cache directory. You are recommended to
call <code>clean_cache(FALSE)</code> and carefully check the list of files (if
any) before you really delete them (<code>clean_cache(TRUE)</code>).
</p>
<p>This function must be called within a code chunk in a source document,
since it needs to know all chunk labels of the current document to
determine which labels are no longer present, and delete cache
corresponding to these labels.
</p>

<hr>
<h2 id='combine_words'>Combine multiple words into a single string</h2><span id='topic+combine_words'></span>

<h3>Description</h3>

<p>When a value from an inline R expression is a character vector of multiple
elements, we may want to combine them into a phrase like &lsquo;<span class="samp">&#8288;a and b&#8288;</span>&rsquo;, or
<code>a, b, and c</code>. That is what this a helper function does.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine_words(
  words,
  sep = ", ",
  and = " and ",
  before = "",
  after = before,
  oxford_comma = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine_words_+3A_words">words</code></td>
<td>
<p>A character vector.</p>
</td></tr>
<tr><td><code id="combine_words_+3A_sep">sep</code></td>
<td>
<p>Separator to be inserted between words.</p>
</td></tr>
<tr><td><code id="combine_words_+3A_and">and</code></td>
<td>
<p>Character string to be prepended to the last word.</p>
</td></tr>
<tr><td><code id="combine_words_+3A_before">before</code>, <code id="combine_words_+3A_after">after</code></td>
<td>
<p>A character string to be added before/after each word.</p>
</td></tr>
<tr><td><code id="combine_words_+3A_oxford_comma">oxford_comma</code></td>
<td>
<p>Whether to insert the separator between the last two
elements in the list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the length of the input <code>words</code> is smaller than or equal to 1,
<code>words</code> is returned. When <code>words</code> is of length 2, the first word
and second word are combined using the <code>and</code> string, or if blank,
<code>sep</code> if is used. When the length is greater than 2, <code>sep</code> is used
to separate all words, and the <code>and</code> string is prepended to the last
word.
</p>


<h3>Value</h3>

<p>A character string marked by <code>xfun::<a href="xfun.html#topic+raw_string">raw_string</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>combine_words("a")
combine_words(c("a", "b"))
combine_words(c("a", "b", "c"))
combine_words(c("a", "b", "c"), sep = " / ", and = "")
combine_words(c("a", "b", "c"), and = "")
combine_words(c("a", "b", "c"), before = "\"", after = "\"")
combine_words(c("a", "b", "c"), before = "\"", after = "\"", oxford_comma = FALSE)
</code></pre>

<hr>
<h2 id='convert_chunk_header'>Convert the in-header chunk option syntax to the in-body syntax</h2><span id='topic+convert_chunk_header'></span>

<h3>Description</h3>

<p>This is a helper function for moving chunk options from the chunk header to
the chunk body using the new syntax.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_chunk_header(
  input,
  output = NULL,
  type = c("multiline", "wrap", "yaml"),
  width = 0.9 * getOption("width")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_chunk_header_+3A_input">input</code></td>
<td>
<p>File path to the document with code chunks to convert.</p>
</td></tr>
<tr><td><code id="convert_chunk_header_+3A_output">output</code></td>
<td>
<p>The default <code>NULL</code> will output to console. Other values
can be a file path to write the converted content into or a function which
takes <code>input</code> as argument and returns a file path to write into (e.g.,
<code>output = identity</code> to overwrite the input file).</p>
</td></tr>
<tr><td><code id="convert_chunk_header_+3A_type">type</code></td>
<td>
<p>This determines how the in-body options will be formatted.
<code>"mutiline"</code> (the default, except for &lsquo;<span class="file">qmd</span>&rsquo; documents, for which
the default is <code>"yaml"</code>) will write each chunk option on a separate
line. Long chunk option values will be wrapped onto several lines, and you
can use <code>width = 0</code> to keep one line per option only. <code>"wrap"</code>
will wrap all chunk options together using
<code><a href="base.html#topic+strwrap">base::strwrap</a>()</code>. <code>"yaml"</code> will convert
chunk options to YAML.</p>
</td></tr>
<tr><td><code id="convert_chunk_header_+3A_width">width</code></td>
<td>
<p>An integer passed to <code>base::strwrap()</code> for <code>type =
"wrap"</code> and <code>type = "multiline"</code>. If set to <code>0</code>, deactivate the
wrapping (for <code>type = "multiline"</code> only).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of converted <code>input</code> when <code>output =
  NULL</code>. The output file path with converted content otherwise.
</p>


<h3>About <span class="pkg">knitr</span> option syntax</h3>

<p>Historical chunk option syntax have chunk option in the chunk header using
valid R syntax. This is an example for <code style="white-space: pre;">&#8288;.Rmd&#8288;</code> document
</p>
<pre>
```{r, echo = FALSE, fig.width: 10}
```
</pre>
<p>New syntax allows to pass option inside the chunk using several variants
</p>

<ul>
<li><p> Passing options one per line using valid R syntax. This corresponds to <code>convert_chunk_header(type = "multiline")</code>.
</p>
<pre>
```{r}
#| echo = FALSE,
#| fig.width = 10
```
</pre>
</li>
<li><p> Passing option part from header in-chunk with several line if wrapping is
needed. This corresponds to <code>convert_chunk_header(type = "wrap")</code>
</p>
<pre>
```{r}
#| echo = FALSE, fig.width = 10
```
</pre>
</li>
<li><p> Passing options key value pairs in-chunk using YAML syntax. Values are no
more R expression but valid YAML syntax. This corresponds to
<code>convert_chunk_header(type = "yaml")</code> (not implement yet).
</p>
<pre>```{r}
#| echo: false,
#| fig.width: 10
```
</pre>
</li></ul>



<h3>Note</h3>

<p>Learn more about the new chunk option syntax in
<a href="https://yihui.org/en/2022/01/knitr-news/">https://yihui.org/en/2022/01/knitr-news/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>knitr_example = function(...) system.file("examples", ..., package = "knitr")
# Convert a document for multiline type
convert_chunk_header(knitr_example("knitr-minimal.Rmd"))
# Convert a document for wrap type
convert_chunk_header(knitr_example("knitr-minimal.Rmd"), type = "wrap")
# Reduce default wrapping width
convert_chunk_header(knitr_example("knitr-minimal.Rmd"), type = "wrap", width = 0.6 *
    getOption("width"))
## Not run: 
# Explicitly name the output
convert_chunk_header("test.Rmd", output = "test2.Rmd")
# Overwrite the input
convert_chunk_header("test.Rmd", output = identity)
# Use a custom function to name the output
convert_chunk_header("test.Rmd", output = \(f) sprintf("%s-new.%s",
    xfun::sans_ext(f), xfun::file_ext(f)))

## End(Not run)
</code></pre>

<hr>
<h2 id='current_input'>Query the current input filename</h2><span id='topic+current_input'></span>

<h3>Description</h3>

<p>Returns the name of the input file passed to <code><a href="#topic+knit">knit</a>()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>current_input(dir = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="current_input_+3A_dir">dir</code></td>
<td>
<p>Boolean; whether to prepend the current working directory to the file path,
i.e. whether to return an absolute path or a relative path.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string, if this function is called inside an input
document. Otherwise <code>NULL</code>.
</p>

<hr>
<h2 id='dep_auto'>Build automatic dependencies among chunks</h2><span id='topic+dep_auto'></span>

<h3>Description</h3>

<p>When the chunk option <code>autodep = TRUE</code>, all names of objects created in
a chunk will be saved in a file named &lsquo;<span class="file">__objects</span>&rsquo; and all global objects
used in a chunk will be saved to &lsquo;<span class="file">__globals</span>&rsquo;. This function can analyze
object names in these files to automatically build cache dependencies, which
is similar to the effect of the <code>dependson</code> option. It is supposed to be
used in the first chunk of a document and this chunk must not be cached.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dep_auto(path = opts_chunk$get("cache.path"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dep_auto_+3A_path">path</code></td>
<td>
<p>Path to the dependency file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>. The dependencies are built as a side effect.
</p>


<h3>Note</h3>

<p>Be cautious about <code>path</code>: because this function is used in a
chunk, the working directory when the chunk is evaluated is the directory
of the input document in <code><a href="#topic+knit">knit</a></code>, and if that directory differs
from the working directory before calling <code>knit()</code>, you need to adjust
the <code>path</code> argument here to make sure this function can find the cache
files &lsquo;<span class="file">__objects</span>&rsquo; and &lsquo;<span class="file">__globals</span>&rsquo;.
</p>


<h3>References</h3>

<p><a href="https://yihui.org/knitr/demo/cache/">https://yihui.org/knitr/demo/cache/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dep_prev">dep_prev</a></code>
</p>

<hr>
<h2 id='dep_prev'>Make later chunks depend on previous chunks</h2><span id='topic+dep_prev'></span>

<h3>Description</h3>

<p>This function can be used to build dependencies among chunks so that all
later chunks depend on previous chunks, i.e. whenever the cache of a previous
chunk is updated, the cache of all its later chunks will be updated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dep_prev()
</code></pre>


<h3>Value</h3>

<p><code>NULL</code>; the internal dependency structure is updated as a side
effect.
</p>


<h3>References</h3>

<p><a href="https://yihui.org/knitr/demo/cache/">https://yihui.org/knitr/demo/cache/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dep_auto">dep_auto</a></code>
</p>

<hr>
<h2 id='download_image'>Download an image from the web and include it in a document</h2><span id='topic+download_image'></span>

<h3>Description</h3>

<p>When including images in non-HTML output formats such as LaTeX/PDF, URLs will
not work as image paths. In this case, we have to download the images. This
function is a wrapper of <code>xfun::<a href="xfun.html#topic+download_file">download_file</a>()</code> and
<code><a href="#topic+include_graphics">include_graphics</a>()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>download_image(
  url,
  path = xfun::url_filename(url),
  use_file = !pandoc_to("html"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="download_image_+3A_url">url</code></td>
<td>
<p>The URL of an image.</p>
</td></tr>
<tr><td><code id="download_image_+3A_path">path</code></td>
<td>
<p>The download path (inferred from the URL by default). If the file
exists, it will not be downloaded (downloading can take time and requires
Internet connection). If you are sure the file needs to be downloaded
again, delete it beforehand.</p>
</td></tr>
<tr><td><code id="download_image_+3A_use_file">use_file</code></td>
<td>
<p>Whether to use the URL or the download path to include the
image. By default, the URL is used for HTML output formats, and the file
path is used for other output formats.</p>
</td></tr>
<tr><td><code id="download_image_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to <code><a href="#topic+include_graphics">include_graphics</a>()</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
knitr::download_image("https://www.r-project.org/Rlogo.png")

</code></pre>

<hr>
<h2 id='engine_output'>An output wrapper for language engine output</h2><span id='topic+engine_output'></span>

<h3>Description</h3>

<p>If you have designed a language engine, you may call this function in the end
to format and return the text output from your engine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>engine_output(options, code, out, extra = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="engine_output_+3A_options">options</code></td>
<td>
<p>A list of chunk options. Usually this is just the object
<code>options</code> passed to the engine function; see
<code><a href="#topic+knit_engines">knit_engines</a></code>.</p>
</td></tr>
<tr><td><code id="engine_output_+3A_code">code</code></td>
<td>
<p>Source code of the chunk, to which the output hook <code>source</code>
is applied, unless the chunk option <code>echo</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="engine_output_+3A_out">out</code></td>
<td>
<p>Text output from the engine, to which the hook <code>output</code> is
applied, unless the chunk option <code>results</code> is <code>'hide'</code></p>
</td></tr>
<tr><td><code id="engine_output_+3A_extra">extra</code></td>
<td>
<p>Any additional text output that you want to include.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For expert users, an advanced usage of this function is
<code>engine_output(options, out = LIST)</code> where <code>LIST</code> is a list that
has the same structure as the output of <code>evaluate::evaluate()</code>. In this
case, the arguments <code>code</code> and <code>extra</code> are ignored, and the list is
passed to <code>knitr::sew()</code> to return a character vector of final output.
</p>


<h3>Value</h3>

<p>A character string generated from the source code and output using
the appropriate output hooks.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(knitr)
engine_output(opts_chunk$merge(list(engine = "Rscript")),
    code = "1 + 1", out = "[1] 2")
engine_output(opts_chunk$merge(list(echo = FALSE, engine = "Rscript")),
    code = "1 + 1", out = "[1] 2")

# expert use only
engine_output(opts_chunk$merge(list(engine = "python")),
    out = list(structure(list(src = "1 + 1"), class = "source"),
        "2"))
</code></pre>

<hr>
<h2 id='extract_raw_output'>Mark character strings as raw output that should not be converted</h2><span id='topic+extract_raw_output'></span><span id='topic+restore_raw_output'></span><span id='topic+raw_output'></span>

<h3>Description</h3>

<p>These functions provide a mechanism to protect the character output of R code
chunks. The output is annotated with special markers in <code>raw_output</code>;
<code>extract_raw_output()</code> will extract raw output wrapped in the markers,
and replace the raw output with its MD5 digest; <code>restore_raw_output()</code>
will restore the MD5 digest with the original raw output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_raw_output(text, markers = raw_markers)

restore_raw_output(text, chunks, markers = raw_markers)

raw_output(x, markers = raw_markers, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_raw_output_+3A_text">text</code></td>
<td>
<p>For <code>extract_raw_output()</code>, the content of the input file
(e.g. Markdown); for <code>restore_raw_output()</code>, the content of the output
file (e.g. HTML generated by Pandoc from Markdown).</p>
</td></tr>
<tr><td><code id="extract_raw_output_+3A_markers">markers</code></td>
<td>
<p>A length-2 character vector to be used to wrap <code>x</code>;
see <code>knitr:::raw_markers</code> for the default value.</p>
</td></tr>
<tr><td><code id="extract_raw_output_+3A_chunks">chunks</code></td>
<td>
<p>A named character vector returned from
<code>extract_raw_output()</code>.</p>
</td></tr>
<tr><td><code id="extract_raw_output_+3A_x">x</code></td>
<td>
<p>The character vector to be protected.</p>
</td></tr>
<tr><td><code id="extract_raw_output_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="#topic+asis_output">asis_output</a>()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This mechanism is designed primarily for R Markdown pre/post-processors. In
an R code chunk, you generate <code>raw_output()</code> to the Markdown output. In
the pre-processor, you can <code>extract_raw_output()</code> from the Markdown
file, store the raw output and MD5 digests, and remove the actual raw output
from Markdown so Pandoc will never see it. In the post-processor, you can
read the Pandoc output (e.g., an HTML or RTF file), and restore the raw
output.
</p>


<h3>Value</h3>

<p>For <code>extract_raw_output()</code>, a list of two components:
<code>value</code> (the <code>text</code> with raw output replaced by MD5 digests) and
<code>chunks</code> (a named character vector, of which the names are MD5 digests
and values are the raw output). For <code>restore_raw_output()</code>, the
restored <code>text</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(knitr)
out = c("*hello*", raw_output("&lt;special&gt;content&lt;/special&gt; *protect* me!"),
    "*world*")
pre = extract_raw_output(out)
str(pre)
pre$value = gsub("[*]([^*]+)[*]", "&lt;em&gt;\\1&lt;/em&gt;",
    pre$value)  # think this as Pandoc conversion
pre$value
# raw output was protected from the conversion
# (e.g. *protect* was not converted)
restore_raw_output(pre$value, pre$chunks)
</code></pre>

<hr>
<h2 id='fig_chunk'>Obtain the figure filenames for a chunk</h2><span id='topic+fig_chunk'></span>

<h3>Description</h3>

<p>Given a chunk label, the figure file extension, the figure number(s), and the
chunk option <code>fig.path</code>, return the filename(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fig_chunk(label, ext = "", number, fig.path = opts_chunk$get("fig.path"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fig_chunk_+3A_label">label</code></td>
<td>
<p>The chunk label.</p>
</td></tr>
<tr><td><code id="fig_chunk_+3A_ext">ext</code></td>
<td>
<p>The figure file extension, e.g. <code>png</code> or <code>pdf</code>.</p>
</td></tr>
<tr><td><code id="fig_chunk_+3A_number">number</code></td>
<td>
<p>The figure number (by default <code>1</code>).</p>
</td></tr>
<tr><td><code id="fig_chunk_+3A_fig.path">fig.path</code></td>
<td>
<p>Passed to <code><a href="#topic+fig_path">fig_path</a></code>. By default, the chunk
option <code>fig.path</code> is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used in an inline R expression to write out the figure
filenames without hard-coding them. For example, if you created a plot in a
code chunk with the label <code>foo</code> and figure path &lsquo;<span class="file">my-figure/</span>&rsquo;, you
are not recommended to use hard-coded figure paths like
&lsquo;<span class="samp">&#8288;\includegraphics{my-figure/foo-1.pdf}&#8288;</span>&rsquo; (in &lsquo;<span class="file">.Rnw</span>&rsquo; documents) or
&lsquo;<span class="samp">&#8288;![](my-figure/foo-1.png)&#8288;</span>&rsquo; (R Markdown) in your document. Instead, you
should use &lsquo;<span class="samp">&#8288;\Sexpr{fig_chunk('foo', 'pdf')}&#8288;</span>&rsquo; or &lsquo;<span class="samp">&#8288;![](`r
fig_chunk('foo', 'png')`)&#8288;</span>&rsquo;.
</p>
<p>You can generate plots in a code chunk but not show them inside the code
chunk by using the chunk option <code>fig.show = 'hide'</code>. Then you can use
this function if you want to show them elsewhere.
</p>


<h3>Value</h3>

<p>A character vector of filenames.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(knitr)
fig_chunk("foo", "png")
fig_chunk("foo", "pdf")
fig_chunk("foo", "svg", 2)  # the second plot of the chunk foo
fig_chunk("foo", "png", 1:5)  # if the chunk foo produced 5 plots
</code></pre>

<hr>
<h2 id='fig_path'>Path for figure files</h2><span id='topic+fig_path'></span>

<h3>Description</h3>

<p>The filename of figure files is the combination of options <code>fig.path</code>
and <code>label</code>. This function returns the path of figures for the current
chunk by default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fig_path(suffix = "", options = opts_current$get(), number)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fig_path_+3A_suffix">suffix</code></td>
<td>
<p>A filename suffix; if it is non-empty and does not
contain a dot <code>.</code>, it will be treated as the filename extension (e.g.
<code>png</code> will be used as <code>.png</code>)</p>
</td></tr>
<tr><td><code id="fig_path_+3A_options">options</code></td>
<td>
<p>A list of options; by default the options of the current chunk.</p>
</td></tr>
<tr><td><code id="fig_path_+3A_number">number</code></td>
<td>
<p>The current figure number. The default is the internal chunk option
<code>fig.cur</code>, if this is available.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of the form &lsquo;<span class="file">fig.path-label-i.suffix</span>&rsquo;.
</p>


<h3>Note</h3>

<p>When there are special characters (not alphanumeric or &lsquo;<span class="samp">&#8288;-&#8288;</span>&rsquo; or
&lsquo;<span class="samp">&#8288;_&#8288;</span>&rsquo;) in the path, they will be automatically replaced with &lsquo;<span class="samp">&#8288;_&#8288;</span>&rsquo;.
For example, &lsquo;<span class="file">a b/c.d-</span>&rsquo; will be sanitized to &lsquo;<span class="file">a_b/c_d-</span>&rsquo;. This
makes the filenames safe to LaTeX.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fig_path(".pdf", options = list(fig.path = "figure/abc-", label = "first-plot"))
fig_path(".png", list(fig.path = "foo-", label = "bar"), 1:10)
</code></pre>

<hr>
<h2 id='hook_ffmpeg_html'>Hooks to create animations in HTML output</h2><span id='topic+hook_ffmpeg_html'></span><span id='topic+hook_gifski'></span><span id='topic+hook_scianimator'></span><span id='topic+hook_r2swf'></span>

<h3>Description</h3>

<p><code>hook_ffmpeg_html()</code> uses FFmpeg to convert images to a video;
<code>hook_gifski()</code> uses the <span class="pkg">gifski</span> to convert images to a GIF
animation; <code>hook_scianimator()</code> uses the JavaScript library SciAnimator
to create animations; <code>hook_r2swf()</code> uses the <span class="pkg">R2SWF</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hook_ffmpeg_html(x, options)

hook_gifski(x, options)

hook_scianimator(x, options)

hook_r2swf(x, options)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hook_ffmpeg_html_+3A_x">x</code></td>
<td>
<p>Filename for the plot (a character string).</p>
</td></tr>
<tr><td><code id="hook_ffmpeg_html_+3A_options">options</code></td>
<td>
<p>A list of the current chunk options.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These hooks are mainly for the package option <code>animation.fun</code>, e.g. you
can set <code>opts_knit$set(animation.fun = hook_scianimator)</code>.
</p>

<hr>
<h2 id='hook_movecode'>Some potentially useful document hooks</h2><span id='topic+hook_movecode'></span>

<h3>Description</h3>

<p>A document hook is a function to post-process the output document.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hook_movecode(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hook_movecode_+3A_x">x</code></td>
<td>
<p>A character string (the whole output document).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>hook_movecode()</code> is a document hook to move code chunks out of LaTeX
floating environments like &lsquo;<span class="samp">&#8288;figure&#8288;</span>&rsquo; and &lsquo;<span class="samp">&#8288;table&#8288;</span>&rsquo; when the chunks
were actually written inside the floats. This function is primarily designed
for LyX: we often insert code chunks into floats to generate figures or
tables, but in the final output we do not want the code to float with the
environments, so we use regular expressions to find out the floating
environments, extract the code chunks and move them out. To disable this
behavior, use a comment <code>% knitr_do_not_move</code> in the floating
environment.
</p>


<h3>Value</h3>

<p>The post-processed document as a character string.
</p>


<h3>Note</h3>

<p>These functions are hackish. Also note <code>hook_movecode()</code> assumes
you to use the default output hooks for LaTeX (not Sweave or listings), and
every figure/table environment must have a label.
</p>


<h3>References</h3>

<p><a href="https://yihui.org/knitr/hooks/">https://yihui.org/knitr/hooks/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
knit_hooks$set(document = hook_movecode)

## End(Not run)
# see example 103 at https://github.com/yihui/knitr-examples
</code></pre>

<hr>
<h2 id='hook_pdfcrop'>Built-in chunk hooks to extend knitr</h2><span id='topic+hook_pdfcrop'></span><span id='topic+hook_optipng'></span><span id='topic+hook_pngquant'></span><span id='topic+hook_mogrify'></span><span id='topic+hook_plot_custom'></span><span id='topic+hook_purl'></span>

<h3>Description</h3>

<p>Hook functions are called when the corresponding chunk options are not
<code>NULL</code> to do additional jobs beside the R code in chunks. This package
provides a few useful hooks, which can also serve as examples of how to
define chunk hooks in <span class="pkg">knitr</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hook_pdfcrop(before, options, envir)

hook_optipng(before, options, envir)

hook_pngquant(before, options, envir)

hook_mogrify(before, options, envir)

hook_plot_custom(before, options, envir)

hook_purl(before, options, envir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hook_pdfcrop_+3A_before">before</code>, <code id="hook_pdfcrop_+3A_options">options</code>, <code id="hook_pdfcrop_+3A_envir">envir</code></td>
<td>
<p>See <em>References</em> below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>hook_pdfcrop()</code> calls <code><a href="#topic+plot_crop">plot_crop</a>()</code> to crop
the white margins of PDF plots.
</p>
<p>The function <code>hook_optipng()</code> calls the program <code>optipng</code> to
optimize PNG images. Note the chunk option <code>optipng</code> can be used to
provide additional parameters to the program <code>optipng</code>, e.g.
<code>optipng = '-o7'</code>.
</p>
<p>The function <code>hook_pngquant()</code> calls the program <code>pngquant</code> to
optimize PNG images. Note the chunk option <code>pngquant</code> can be used to
provide additional parameters to the program <code>pngquant</code>, e.g.
<code>pngquant = '--speed=1 --quality=0-50'</code>.
</p>
<p>The function <code>hook_mogrify()</code> calls the program <code>mogrify</code>.  Note
the chunk option <code>mogrify</code> can be used to provide additional parameters
to the program <code>mogrify</code> (with default <code>-trim</code> to trim PNG
files).
</p>
<p>When the plots are not recordable via <code>grDevices::<a href="grDevices.html#topic+recordPlot">recordPlot</a>()</code>
and we save the plots to files manually via other functions (e.g. <span class="pkg">rgl</span>
plots), we can use the chunk hook <code>hook_plot_custom</code> to help write code
for graphics output into the output document.
</p>
<p>The hook <code>hook_purl()</code> can be used to write the code chunks to an R
script. It is an alternative approach to <code><a href="#topic+purl">purl</a></code>, and can be more
reliable when the code chunks depend on the execution of them (e.g.
<code><a href="#topic+read_chunk">read_chunk</a>()</code>, or <code><a href="#topic+opts_chunk">opts_chunk</a>$set(eval = FALSE)</code>).
To enable this hook, it is recommended to associate it with the chunk option
<code>purl</code>, i.e. <code>knit_hooks$set(purl = hook_purl)</code>. When this hook is
enabled, an R script will be written while the input document is being
<code><a href="#topic+knit">knit</a></code>. Currently the code chunks that are not R code or have the
chunk option <code>purl=FALSE</code> are ignored. Please note when the cache is
turned on (the chunk option <code>cache = TRUE</code>), no chunk hooks will be
executed, hence <code>hook_purl()</code> will not work, either. To solve this
problem, we need <code>cache = 2</code> instead of <code>TRUE</code> (see
<a href="https://yihui.org/knitr/demo/cache/">https://yihui.org/knitr/demo/cache/</a> for the meaning of <code>cache =
2</code>).
</p>


<h3>Note</h3>

<p>The two hook functions <code>hook_rgl()</code> and <code>hook_webgl()</code> were
moved from <span class="pkg">knitr</span> to the <span class="pkg">rgl</span> package (&gt;= v0.95.1247) after
<span class="pkg">knitr</span> v1.10.5, and you can <code>library(rgl)</code> to get them.
</p>


<h3>References</h3>

<p><a href="https://yihui.org/knitr/hooks/#chunk_hooks">https://yihui.org/knitr/hooks/#chunk_hooks</a>
</p>


<h3>See Also</h3>

<p><code>rgl::<a href="rgl.html#topic+snapshot">rgl.snapshot</a></code>,
<code>rgl::<a href="rgl.html#topic+postscript">rgl.postscript</a></code>,
<code>rgl::<a href="rgl.html#topic+hook_rgl">hook_rgl</a></code>,
<code>rgl::<a href="rgl.html#topic+hook_rgl">hook_webgl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("rgl") &amp;&amp; exists("hook_rgl")) knit_hooks$set(rgl = hook_rgl)
# then in code chunks, use the option rgl=TRUE
</code></pre>

<hr>
<h2 id='hook_plot_html'>Default plot hooks for different output formats</h2><span id='topic+hook_plot_html'></span><span id='topic+hook_plot_asciidoc'></span><span id='topic+hook_plot_tex'></span><span id='topic+hook_plot_md'></span><span id='topic+hook_plot_rst'></span><span id='topic+hook_plot_textile'></span>

<h3>Description</h3>

<p>These hook functions define how to mark up graphics output in different
output formats.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hook_plot_html(x, options)

hook_plot_asciidoc(x, options)

hook_plot_tex(x, options)

hook_plot_md(x, options)

hook_plot_rst(x, options)

hook_plot_textile(x, options)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hook_plot_html_+3A_x">x</code></td>
<td>
<p>Filename for the plot (a character string).</p>
</td></tr>
<tr><td><code id="hook_plot_html_+3A_options">options</code></td>
<td>
<p>A list of the current chunk options.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on the options passed over, <code>hook_plot_tex</code> may return the
normal &lsquo;<span class="samp">&#8288;\includegraphics{}&#8288;</span>&rsquo; command, or &lsquo;<span class="samp">&#8288;\input{}&#8288;</span>&rsquo; (for tikz
files), or &lsquo;<span class="samp">&#8288;\animategraphics{}&#8288;</span>&rsquo; (for animations); it also takes many
other options into consideration to align plots and set figure sizes, etc.
Similarly, <code>hook_plot_html</code>, <code>hook_plot_md</code> and
<code>hook_plot_rst</code> return character strings which are HTML, Markdown, reST
code.
</p>
<p>In most cases we do not need to call these hooks explicitly, and they were
designed to be used internally. Sometimes we may not be able to record R
plots using <code>grDevices::<a href="grDevices.html#topic+recordPlot">recordPlot</a>()</code>, and we can make use of
these hooks to insert graphics output in the output document; see
<code><a href="#topic+hook_plot_custom">hook_plot_custom</a></code> for details.
</p>


<h3>Value</h3>

<p>A character string of code, with plot filenames wrapped.
</p>


<h3>References</h3>

<p><a href="https://yihui.org/knitr/hooks/">https://yihui.org/knitr/hooks/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hook_plot_custom">hook_plot_custom</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># this is what happens for a chunk like this

# &lt;&lt;foo-bar-plot, dev='pdf', fig.align='right'&gt;&gt;=
hook_plot_tex("foo-bar-plot.pdf", opts_chunk$merge(list(fig.align = "right")))

# &lt;&lt;bar, dev='tikz'&gt;&gt;=
hook_plot_tex("bar.tikz", opts_chunk$merge(list(dev = "tikz")))

# &lt;&lt;foo, dev='pdf', fig.show='animate', interval=.1&gt;&gt;=

# 5 plots are generated in this chunk
hook_plot_tex("foo5.pdf", opts_chunk$merge(list(fig.show = "animate", interval = 0.1,
    fig.cur = 5, fig.num = 5)))
</code></pre>

<hr>
<h2 id='image_uri'>Encode an image file to a data URI</h2><span id='topic+image_uri'></span>

<h3>Description</h3>

<p>This function is the same as <code>xfun::<a href="xfun.html#topic+base64_uri">base64_uri</a>()</code> (only with a
different function name). It can encode an image file as a base64 string,
which can be used in the <code>img</code> tag in HTML.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>image_uri(f)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="image_uri_+3A_f">f</code></td>
<td>
<p>Path to the image file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The data URI as a character string.
</p>


<h3>Author(s)</h3>

<p>Wush Wu and Yihui Xie
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Data_URI_scheme">https://en.wikipedia.org/wiki/Data_URI_scheme</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>uri = image_uri(file.path(R.home("doc"), "html", "logo.jpg"))
if (interactive()) {
    cat(sprintf("&lt;img src=\"%s\" /&gt;", uri), file = "logo.html")
    browseURL("logo.html")  # you can check its HTML source
}
</code></pre>

<hr>
<h2 id='imgur_upload'>Upload an image to imgur.com</h2><span id='topic+imgur_upload'></span>

<h3>Description</h3>

<p>This function uses the <span class="pkg">curl</span> package to upload a image to
<a href="https://imgur.com">https://imgur.com</a>, and parses the XML response to a list with
<span class="pkg">xml2</span>, which contains information about the image on Imgur.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imgur_upload(
  file,
  key = xfun::env_option("knitr.imgur.key", "9f3460e67f308f6")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imgur_upload_+3A_file">file</code></td>
<td>
<p>Path to the image file to be uploaded.</p>
</td></tr>
<tr><td><code id="imgur_upload_+3A_key">key</code></td>
<td>
<p>Client ID for Imgur. It can be set via either the global option
<code>knitr.imgur.key</code> or the environment variable <code>R_KNITR_IMGUR_KEY</code>
(see [xfun::env_option()]). If neither is set, this uses a client ID
registered by Yihui Xie.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the output format from <code><a href="#topic+knit">knit</a>()</code> is HTML or Markdown, this
function can be used to upload local image files to Imgur, e.g. set the
package option <code>opts_knit$set(upload.fun = imgur_upload)</code>, so the output
document is completely self-contained, i.e. it does not need external image
files any more, and it is ready to be published online.
</p>


<h3>Value</h3>

<p>A character string of the link to the image; this string carries an
attribute named <code>XML</code> which is a list converted from the response XML
file; see Imgur API in the references.
</p>


<h3>Note</h3>

<p>Please register your own Imgur application to get your client ID; you
can certainly use mine, but this ID is in the public domain so everyone has
access to all images associated to it.
</p>


<h3>Author(s)</h3>

<p>Yihui Xie, adapted from the <span class="pkg">imguR</span> package by Aaron Statham
</p>


<h3>References</h3>

<p>A demo: <a href="https://yihui.org/knitr/demo/upload/">https://yihui.org/knitr/demo/upload/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
f = tempfile(fileext = ".png")
png(f)
plot(rnorm(100), main = R.version.string)
dev.off()

res = imgur_upload(f)
res  # link to original URL of the image
attr(res, "XML")  # all information
if (interactive())
    browseURL(res)

# to use your own key
options(knitr.imgur.key = "your imgur key")

## End(Not run)
</code></pre>

<hr>
<h2 id='include_graphics'>Embed external images in <span class="pkg">knitr</span> documents</h2><span id='topic+include_graphics'></span>

<h3>Description</h3>

<p>When plots are not generated from R code, there is no way for <span class="pkg">knitr</span> to
capture plots automatically. In this case, you may generate the images
manually and pass their file paths to this function to include them in the
output. The major advantage of using this function is that it is portable in
the sense that it works for all document formats that <span class="pkg">knitr</span> supports,
so you do not need to think if you have to use, for example, LaTeX or
Markdown syntax, to embed an external image. Chunk options related to
graphics output that work for normal R plots also work for these images, such
as <code>out.width</code> and <code>out.height</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>include_graphics(
  path,
  auto_pdf = getOption("knitr.graphics.auto_pdf", FALSE),
  dpi = NULL,
  rel_path = getOption("knitr.graphics.rel_path", TRUE),
  error = getOption("knitr.graphics.error", TRUE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="include_graphics_+3A_path">path</code></td>
<td>
<p>A character vector of image paths. Both local file paths and web
paths are supported. Note that the <code>auto_pdf</code> and <code>dpi</code> arguments
are not supported for web paths.</p>
</td></tr>
<tr><td><code id="include_graphics_+3A_auto_pdf">auto_pdf</code></td>
<td>
<p>Whether to use PDF images automatically when the output
format is LaTeX. If <code>TRUE</code>, then e.g. &lsquo;<span class="file">foo/bar.png</span>&rsquo; will be
replaced by &lsquo;<span class="file">foo/bar.pdf</span>&rsquo; if the latter exists. This can be useful
since normally PDF images are of higher quality than raster images like
PNG, when the output is LaTeX/PDF.</p>
</td></tr>
<tr><td><code id="include_graphics_+3A_dpi">dpi</code></td>
<td>
<p>DPI (dots per inch) value. Used to calculate the output width (in
inches) of the images. This will be their actual width in pixels, divided
by <code>dpi</code>. If not provided, the chunk option <code>dpi</code> is used; if
<code>NA</code>, the output width will not be calculated.</p>
</td></tr>
<tr><td><code id="include_graphics_+3A_rel_path">rel_path</code></td>
<td>
<p>Whether to automatically convert absolute paths to relative
paths. If you know for sure that absolute paths work, you may set this
argument or the global option <code>knitr.graphics.rel_path</code> to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="include_graphics_+3A_error">error</code></td>
<td>
<p>Whether to signal an error if any files specified in the
<code>path</code> argument do not exist and are not web resources.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The same as the input character vector <code>path</code> but it is marked
with special internal S3 classes so that <span class="pkg">knitr</span> will convert the file
paths to proper output code according to the output format.
</p>


<h3>Note</h3>

<p>This function is supposed to be used in R code chunks or inline R code
expressions. For local images, you are recommended to use relative paths
with forward slashes instead of backslashes (e.g., &lsquo;<span class="file">images/fig1.png</span>&rsquo;
instead of &lsquo;<span class="file">/Users/me/code/images/fig1.png</span>&rsquo;).
</p>
<p>The automatic calculation of the output width requires the <span class="pkg">png</span>
package (for PNG images) or the <span class="pkg">jpeg</span> package (for JPEG images). The
width will not be calculated if the chunk option <code>out.width</code> is
already provided or <code>dpi = NA</code>.
</p>

<hr>
<h2 id='include_url'>Embed a URL as an HTML iframe or a screenshot in <span class="pkg">knitr</span> documents</h2><span id='topic+include_url'></span><span id='topic+include_app'></span>

<h3>Description</h3>

<p>When the output format is HTML, <code>include_url()</code> inserts an iframe in the
output; otherwise it takes a screenshot of the URL and insert the image in
the output. <code>include_app()</code> takes the URL of a Shiny app and adds
&lsquo;<span class="samp">&#8288;?showcase=0&#8288;</span>&rsquo; to it (to disable the showcase mode), then passes the URL
to <code>include_url()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>include_url(url, height = "400px")

include_app(url, height = "400px")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="include_url_+3A_url">url</code></td>
<td>
<p>A character vector of URLs.</p>
</td></tr>
<tr><td><code id="include_url_+3A_height">height</code></td>
<td>
<p>A character vector to specify the height of iframes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R object with a special class that <span class="pkg">knitr</span> recognizes
internally to generate the iframes or screenshots.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+include_graphics">include_graphics</a></code>
</p>

<hr>
<h2 id='inline_expr'>Wrap code using the inline R expression syntax</h2><span id='topic+inline_expr'></span>

<h3>Description</h3>

<p>This is a convenience function to write the &quot;source code&quot; of inline R
expressions. For example, if you want to write &lsquo;<span class="samp">&#8288;`r 1+1`&#8288;</span>&rsquo; literally in an
R Markdown document, you may write &lsquo;<span class="samp">&#8288;`` `r knitr::inline_expr('1+1')`
``&#8288;</span>&rsquo;; for Rnw documents, this may be
&lsquo;<span class="samp">&#8288;\verb|\Sexpr{knitr::inline_expr{'1+1'}}|&#8288;</span>&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inline_expr(code, syntax)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inline_expr_+3A_code">code</code></td>
<td>
<p>Character string of the inline R source code.</p>
</td></tr>
<tr><td><code id="inline_expr_+3A_syntax">syntax</code></td>
<td>
<p>A character string to specify the syntax, e.g. <code>rnw</code>,
<code>html</code>, or <code>md</code>. If not specified, this will be guessed from
the knitting context.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string marked up using the inline R code syntax.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(knitr)
inline_expr("1+1", "rnw")
inline_expr("1+1", "html")
inline_expr("1+1", "md")
</code></pre>

<hr>
<h2 id='is_latex_output'>Check the current input and output type</h2><span id='topic+is_latex_output'></span><span id='topic+is_html_output'></span><span id='topic+pandoc_to'></span><span id='topic+pandoc_from'></span>

<h3>Description</h3>

<p>The function <code>is_latex_output()</code> returns <code>TRUE</code> when the output
format is LaTeX; it works for both &lsquo;<span class="file">.Rnw</span>&rsquo; and R Markdown documents (for
the latter, the two Pandoc formats <code>latex</code> and <code>beamer</code> are
considered LaTeX output). The function <code>is_html_output()</code> only works for
R Markdown documents and will test for several Pandoc HTML based output
formats (by default, these formats are considered as HTML formats:
<code>c('markdown', 'epub', 'epub2', 'html', 'html4', 'html5', 'revealjs', 's5',
'slideous', 'slidy', 'gfm')</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_latex_output()

is_html_output(fmt = pandoc_to(), excludes = NULL)

pandoc_to(fmt, exact = FALSE)

pandoc_from(exact = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_latex_output_+3A_fmt">fmt</code></td>
<td>
<p>A character vector of output formats to be checked against. If not
provided, <code>is_html_output()</code> uses <code>pandoc_to()</code>, and
<code>pandoc_to()</code> returns the output format name.</p>
</td></tr>
<tr><td><code id="is_latex_output_+3A_excludes">excludes</code></td>
<td>
<p>A character vector of output formats that should not be
considered as HTML format. Options are: markdown, epub, epub2, html, html4, html5,
revealjs, s5, slideous, slidy, and gfm.</p>
</td></tr>
<tr><td><code id="is_latex_output_+3A_exact">exact</code></td>
<td>
<p>Whether to return or use the exact format name. If not, Pandoc
extensions will be removed from the format name, e.g., &lsquo;<span class="samp">&#8288;latex-smart&#8288;</span>&rsquo;
will be treated as &lsquo;<span class="samp">&#8288;latex&#8288;</span>&rsquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>pandoc_to()</code> returns the Pandoc output format, and
<code>pandoc_from()</code> returns Pandoc input format. <code>pandoc_to(fmt)</code>
allows to check the current output format against a set of format names. Both
are to be used with R Markdown documents.
</p>
<p>These functions may be useful for conditional output that depends on the
output format. For example, you may write out a LaTeX table in an R Markdown
document when the output format is LaTeX, and an HTML or Markdown table when
the output format is HTML. Use <code>pandoc_to(fmt)</code> to test a more specific
Pandoc format.
</p>
<p>Internally, the Pandoc output format of the current R Markdown document is
stored in <code>knitr::<a href="#topic+opts_knit">opts_knit</a>$get('rmarkdown.pandoc.to')</code>, and the
Pandoc input format in
<code>knitr::<a href="#topic+opts_knit">opts_knit</a>$get('rmarkdown.pandoc.from')</code>
</p>


<h3>Note</h3>

<p>See available Pandoc formats, in
<a href="https://pandoc.org/MANUAL.html">Pandoc's Manual</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># check for output formats type
knitr::is_latex_output()
knitr::is_html_output()
knitr::is_html_output(excludes = c("markdown", "epub"))
# Get current formats
knitr::pandoc_from()
knitr::pandoc_to()
# Test if current output format is 'docx'
knitr::pandoc_to("docx")
</code></pre>

<hr>
<h2 id='is_low_change'>Compare two recorded plots</h2><span id='topic+is_low_change'></span>

<h3>Description</h3>

<p>Check if one plot only contains a low-level update of another plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_low_change(p1, p2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_low_change_+3A_p1">p1</code>, <code id="is_low_change_+3A_p2">p2</code></td>
<td>
<p>Plot objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical value indicating whether <code>p2</code> is a low-level update of
<code>p1</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pdf(NULL)
dev.control("enable")  # enable plot recording
plot(1:10)
p1 = recordPlot()
abline(0, 1)  # add a line (a low-level change)
p2 = recordPlot()
plot(rnorm(100))
p3 = recordPlot()  # draw a completely new plot
dev.off()
knitr::is_low_change(p1, p2)  # true
knitr::is_low_change(p1, p3)  # false
</code></pre>

<hr>
<h2 id='kable'>Create tables in LaTeX, HTML, Markdown and reStructuredText</h2><span id='topic+kable'></span><span id='topic+kables'></span>

<h3>Description</h3>

<p>A very simple table generator, and it is simple by design. It is not intended
to replace any other R packages for making tables. The <code>kable()</code>
function returns a single table for a single data object, and returns a table
that contains multiple tables if the input object is a list of data objects.
The <code>kables()</code> function is similar to <code>kable(x)</code> when <code>x</code> is a
list of data objects, but <code>kables()</code> accepts a list of <code>kable()</code>
values directly instead of data objects (see examples below).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kable(
  x,
  format,
  digits = getOption("digits"),
  row.names = NA,
  col.names = NA,
  align,
  caption = NULL,
  label = NULL,
  format.args = list(),
  escape = TRUE,
  ...
)

kables(x, format, caption = NULL, label = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kable_+3A_x">x</code></td>
<td>
<p>For <code>kable()</code>, <code>x</code> is an R object, which is typically a
matrix or data frame. For <code>kables()</code>, a list with each element being a
returned value from <code>kable()</code>.</p>
</td></tr>
<tr><td><code id="kable_+3A_format">format</code></td>
<td>
<p>A character string. Possible values are <code>latex</code>,
<code>html</code>, <code>pipe</code> (Pandoc's pipe tables), <code>simple</code> (Pandoc's
simple tables), <code>rst</code>, <code>jira</code>, and <code>org</code> (Emacs Org-mode).
The value of this argument will be automatically determined if the function
is called within a <span class="pkg">knitr</span> document. The <code>format</code> value can also
be set in the global option <code>knitr.table.format</code>. If <code>format</code> is
a function, it must return a character string.</p>
</td></tr>
<tr><td><code id="kable_+3A_digits">digits</code></td>
<td>
<p>Maximum number of digits for numeric columns, passed to
<code>round()</code>. This can also be a vector of length <code>ncol(x)</code>, to set
the number of digits for individual columns.</p>
</td></tr>
<tr><td><code id="kable_+3A_row.names">row.names</code></td>
<td>
<p>Logical: whether to include row names. By default, row names
are included if <code>rownames(x)</code> is neither <code>NULL</code> nor identical to
<code>1:nrow(x)</code>.</p>
</td></tr>
<tr><td><code id="kable_+3A_col.names">col.names</code></td>
<td>
<p>A character vector of column names to be used in the table.</p>
</td></tr>
<tr><td><code id="kable_+3A_align">align</code></td>
<td>
<p>Column alignment: a character vector consisting of <code>'l'</code>
(left), <code>'c'</code> (center) and/or <code>'r'</code> (right). By default or if
<code>align = NULL</code>, numeric columns are right-aligned, and other columns
are left-aligned. If <code>length(align) == 1L</code>, the string will be
expanded to a vector of individual letters, e.g. <code>'clc'</code> becomes
<code>c('c', 'l', 'c')</code>, unless the output format is LaTeX.</p>
</td></tr>
<tr><td><code id="kable_+3A_caption">caption</code></td>
<td>
<p>The table caption.</p>
</td></tr>
<tr><td><code id="kable_+3A_label">label</code></td>
<td>
<p>The table reference label. By default, the label is obtained
from <code>knitr::<a href="#topic+opts_current">opts_current</a>$get('label')</code>. To disable the label,
use <code>label = NA</code>.</p>
</td></tr>
<tr><td><code id="kable_+3A_format.args">format.args</code></td>
<td>
<p>A list of arguments to be passed to <code><a href="base.html#topic+format">format</a>()</code>
to format table values, e.g. <code>list(big.mark = ',')</code>.</p>
</td></tr>
<tr><td><code id="kable_+3A_escape">escape</code></td>
<td>
<p>Boolean; whether to escape special characters when producing
HTML or LaTeX tables. When <code>escape = FALSE</code>, you have to make sure
that special characters will not trigger syntax errors in LaTeX or HTML.</p>
</td></tr>
<tr><td><code id="kable_+3A_...">...</code></td>
<td>
<p>Other arguments (see Examples and References).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Missing values (<code>NA</code>) in the table are displayed as <code>NA</code> by
default. If you want to display them with other characters, you can set the
option <code>knitr.kable.NA</code>, e.g. <code>options(knitr.kable.NA = '')</code> to
hide <code>NA</code> values.
</p>


<h3>Value</h3>

<p>A character vector of the table source code.
</p>


<h3>Note</h3>

<p>When using <code>kable()</code> as a <em>top-level</em> expression, you do not
need to explicitly <code>print()</code> it due to R's automatic implicit
printing. When it is wrapped inside other expressions (such as a
<code><a href="base.html#topic+for">for</a></code> loop), you must explicitly <code>print(kable(...))</code>.
</p>


<h3>References</h3>

<p>See
<a href="https://bookdown.org/yihui/rmarkdown-cookbook/kable.html">https://bookdown.org/yihui/rmarkdown-cookbook/kable.html</a> for some
examples about this function, including specific arguments according to the
<code>format</code> selected.
</p>


<h3>See Also</h3>

<p>Other R packages such as <span class="pkg">huxtable</span>, <span class="pkg">xtable</span>,
<span class="pkg">kableExtra</span>, <span class="pkg">gt</span> and <span class="pkg">tables</span> for HTML and LaTeX tables, and
<span class="pkg">ascii</span> and <span class="pkg">pander</span> for different flavors of markdown output and
some advanced features and table styles. For more on other packages for
creating tables, see
<a href="https://bookdown.org/yihui/rmarkdown-cookbook/table-other.html">https://bookdown.org/yihui/rmarkdown-cookbook/table-other.html</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d1 = head(iris)
d2 = head(mtcars)
# pipe tables by default
kable(d1)
kable(d2[, 1:5])
# no inner padding
kable(d2, format = "pipe", padding = 0)
# more padding
kable(d2, format = "pipe", padding = 2)
kable(d1, format = "latex")
kable(d1, format = "html")
kable(d1, format = "latex", caption = "Title of the table")
kable(d1, format = "html", caption = "Title of the table")
# use the booktabs package
kable(mtcars, format = "latex", booktabs = TRUE)
# use the longtable package
kable(matrix(1000, ncol = 5), format = "latex", digits = 2, longtable = TRUE)
# change LaTeX default table environment
kable(d1, format = "latex", caption = "My table", table.envir = "table*")
# add some table attributes
kable(d1, format = "html", table.attr = "id=\"mytable\"")
# reST output
kable(d2, format = "rst")
# no row names
kable(d2, format = "rst", row.names = FALSE)
# Pandoc simple tables
kable(d2, format = "simple", caption = "Title of the table")
# format numbers using , as decimal point, and ' as thousands separator
x = as.data.frame(matrix(rnorm(60, 1e+06, 10000), 10))
kable(x, format.args = list(decimal.mark = ",", big.mark = "'"))
# save the value
x = kable(d2, format = "html")
cat(x, sep = "\n")
# can also set options(knitr.table.format = 'html') so that the output is HTML

# multiple tables via either kable(list(x1, x2)) or kables(list(kable(x1),
# kable(x2)))
kable(list(d1, d2), caption = "A tale of two tables")
kables(list(kable(d1, align = "l"), kable(d2)), caption = "A tale of two tables")
</code></pre>

<hr>
<h2 id='knit'>Knit a document</h2><span id='topic+knit'></span><span id='topic+purl'></span>

<h3>Description</h3>

<p>This function takes an input file, extracts the R code in it according to a
list of patterns, evaluates the code and writes the output in another file.
It can also tangle R source code from the input document (<code>purl()</code> is a
wrapper to <code>knit(..., tangle = TRUE)</code>). The <code>knitr.purl.inline</code>
option can be used to also tangle the code of inline expressions (disabled by
default).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knit(
  input,
  output = NULL,
  tangle = FALSE,
  text = NULL,
  quiet = FALSE,
  envir = parent.frame(),
  encoding = "UTF-8"
)

purl(..., documentation = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knit_+3A_input">input</code></td>
<td>
<p>Path to the input file.</p>
</td></tr>
<tr><td><code id="knit_+3A_output">output</code></td>
<td>
<p>Path to the output file for <code>knit()</code>. If <code>NULL</code>, this
function will try to guess a default, which will be under the current
working directory.</p>
</td></tr>
<tr><td><code id="knit_+3A_tangle">tangle</code></td>
<td>
<p>Boolean; whether to tangle the R code from the input file (like
<code>utils::<a href="utils.html#topic+Stangle">Stangle</a></code>).</p>
</td></tr>
<tr><td><code id="knit_+3A_text">text</code></td>
<td>
<p>A character vector. This is an alternative way to provide the
input file.</p>
</td></tr>
<tr><td><code id="knit_+3A_quiet">quiet</code></td>
<td>
<p>Boolean; suppress the progress bar and messages?</p>
</td></tr>
<tr><td><code id="knit_+3A_envir">envir</code></td>
<td>
<p>Environment in which code chunks are to be evaluated, for
example, <code><a href="base.html#topic+parent.frame">parent.frame</a>()</code>, <code><a href="base.html#topic+new.env">new.env</a>()</code>, or
<code><a href="base.html#topic+globalenv">globalenv</a>()</code>).</p>
</td></tr>
<tr><td><code id="knit_+3A_encoding">encoding</code></td>
<td>
<p>Encoding of the input file; always assumed to be UTF-8 (i.e.,
this argument is effectively ignored).</p>
</td></tr>
<tr><td><code id="knit_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+knit">knit</a>()</code> from <code>purl()</code></p>
</td></tr>
<tr><td><code id="knit_+3A_documentation">documentation</code></td>
<td>
<p>An integer specifying the level of documentation to add to
the tangled script. <code>0</code> means to output pure code, discarding all text chunks);
<code>1</code> (the default) means to add the chunk headers to the code; <code>2</code> means to
add all text chunks to code as roxygen comments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For most of the time, it is not necessary to set any options outside the
input document; in other words, a single call like
<code>knit('my_input.Rnw')</code> is usually enough. This function will try to
determine many internal settings automatically. For the sake of
reproducibility, it is better practice to include the options inside the
input document (to be self-contained), instead of setting them before
knitting the document.
</p>
<p>First the filename of the output document is determined in this way:
&lsquo;<span class="file">foo.Rnw</span>&rsquo; generates &lsquo;<span class="file">foo.tex</span>&rsquo;, and other filename extensions like
&lsquo;<span class="file">.Rtex</span>&rsquo;, &lsquo;<span class="file">.Rhtml</span>&rsquo; (&lsquo;<span class="file">.Rhtm</span>&rsquo;) and &lsquo;<span class="file">.Rmd</span>&rsquo;
(&lsquo;<span class="file">.Rmarkdown</span>&rsquo;) will generate &lsquo;<span class="file">.tex</span>&rsquo;, &lsquo;<span class="file">.html</span>&rsquo; and &lsquo;<span class="file">.md</span>&rsquo;
respectively. For other types of files, if the filename contains
&lsquo;<span class="samp">&#8288;_knit_&#8288;</span>&rsquo;, this part will be removed in the output file, e.g.,
&lsquo;<span class="file">foo_knit_.html</span>&rsquo; creates the output &lsquo;<span class="file">foo.html</span>&rsquo;; if &lsquo;<span class="samp">&#8288;_knit_&#8288;</span>&rsquo; is
not found in the filename, &lsquo;<span class="file">foo.ext</span>&rsquo; will produce &lsquo;<span class="file">foo.txt</span>&rsquo; if
<code>ext</code> is not <code>txt</code>, otherwise the output is &lsquo;<span class="file">foo-out.txt</span>&rsquo;. If
<code>tangle = TRUE</code>, &lsquo;<span class="file">foo.ext</span>&rsquo; generates an R script &lsquo;<span class="file">foo.R</span>&rsquo;.
</p>
<p>We need a set of syntax to identify special markups for R code chunks and R
options, etc. The syntax is defined in a pattern list. All built-in pattern
lists can be found in <code>all_patterns</code> (call it <code>apat</code>). First
<span class="pkg">knitr</span> will try to decide the pattern list based on the filename
extension of the input document, e.g. &lsquo;<span class="samp">&#8288;Rnw&#8288;</span>&rsquo; files use the list
<code>apat$rnw</code>, &lsquo;<span class="samp">&#8288;tex&#8288;</span>&rsquo; uses the list <code>apat$tex</code>, &lsquo;<span class="samp">&#8288;brew&#8288;</span>&rsquo; uses
<code>apat$brew</code> and HTML files use <code>apat$html</code>; for unkown extensions,
the content of the input document is matched against all pattern lists to
automatically determine which pattern list is being used. You can also
manually set the pattern list using the <code><a href="#topic+knit_patterns">knit_patterns</a></code> object or
the <code><a href="#topic+pat_rnw">pat_rnw</a></code> series functions in advance and <span class="pkg">knitr</span> will
respect the setting.
</p>
<p>According to the output format (<code>opts_knit$get('out.format')</code>), a set of
output hooks will be set to mark up results from R (see
<code><a href="#topic+render_latex">render_latex</a></code>). The output format can be LaTeX, Sweave and HTML,
etc. The output hooks decide how to mark up the results (you can customize
the hooks).
</p>
<p>The name <code>knit</code> comes from its counterpart &lsquo;<span class="samp">&#8288;weave&#8288;</span>&rsquo; (as in Sweave),
and the name <code>purl</code> (as &lsquo;<span class="samp">&#8288;tangle&#8288;</span>&rsquo; in Stangle) comes from a knitting
method &lsquo;knit one, purl one&rsquo;.
</p>
<p>If the input document has child documents, they will also be compiled
recursively. See <code><a href="#topic+knit_child">knit_child</a></code>.
</p>
<p>See the package website and manuals in the references to know more about
<span class="pkg">knitr</span>, including the full documentation of chunk options and demos,
etc.
</p>


<h3>Value</h3>

<p>The compiled document is written into the output file, and the path
of the output file is returned. If the <code>text</code> argument is not
<code>NULL</code>, the compiled output is returned as a character vector. In
other words, if you provide a file input, you get an output filename; if
you provide a character vector input, you get a character vector output.
</p>


<h3>Note</h3>

<p>The working directory when evaluating R code chunks is the directory of
the input document by default, so if the R code involves external files
(like <code>read.table()</code>), it is better to put these files under the same
directory of the input document so that we can use relative paths. However,
it is possible to change this directory with the package option
<code><a href="#topic+opts_knit">opts_knit</a>$set(root.dir = ...)</code> so all paths in code chunks are
relative to this <code>root.dir</code>. It is not recommended to change the
working directory via <code><a href="base.html#topic+setwd">setwd</a>()</code> in a code chunk, because it may
lead to terrible consequences (e.g. figure and cache files may be written
to wrong places). If you do use <code>setwd()</code>, please note that
<span class="pkg">knitr</span> will always restore the working directory to the original one.
Whenever you feel confused, print <code>getwd()</code> in a code chunk to see
what the working directory really is.
</p>
<p>If the <code>output</code> argument is a file path, it is strongly recommended to
be in the current working directory (e.g. &lsquo;<span class="file">foo.tex</span>&rsquo; instead of
&lsquo;<span class="file">somewhere/foo.tex</span>&rsquo;), especially when the output has external
dependencies such as figure files. If you want to write the output to a
different directory, it is recommended to set the working directory to that
directory before you knit a document. For example, if the source document
is &lsquo;<span class="file">foo.Rmd</span>&rsquo; and the expected output is &lsquo;<span class="file">out/foo.md</span>&rsquo;, you can
write <code>setwd('out/'); knit('../foo.Rmd')</code> instead of
<code>knit('foo.Rmd', 'out/foo.md')</code>.
</p>
<p>N.B. There is no guarantee that the R script generated by <code>purl()</code> can
reproduce the computation done in <code>knit()</code>. The <code>knit()</code> process
can be fairly complicated (special values for chunk options, custom chunk
hooks, computing engines besides R, and the <code>envir</code> argument, etc). If
you want to reproduce the computation in a report generated by
<code>knit()</code>, be sure to use <code>knit()</code>, instead of merely executing
the R script generated by <code>purl()</code>. This seems to be obvious, but some
people
<a href="https://stat.ethz.ch/pipermail/r-devel/2014-May/069113.html">do not
get it</a>.
</p>


<h3>References</h3>

<p>Package homepage: <a href="https://yihui.org/knitr/">https://yihui.org/knitr/</a>. The <span class="pkg">knitr</span>
<a href="https://yihui.org/knitr/demo/manual/">main manual</a>: and
<a href="https://yihui.org/knitr/demo/graphics/">graphics manual</a>.
</p>
<p>See <code>citation('knitr')</code> for the citation information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(knitr)
(f = system.file("examples", "knitr-minimal.Rnw", package = "knitr"))
knit(f)  # compile to tex

purl(f)  # tangle R code
purl(f, documentation = 0)  # extract R code only
purl(f, documentation = 2)  # also include documentation

unlink(c("knitr-minimal.tex", "knitr-minimal.R", "figure"), recursive = TRUE)
</code></pre>

<hr>
<h2 id='knit_child'>Knit a child document</h2><span id='topic+knit_child'></span>

<h3>Description</h3>

<p>This function knits a child document and returns a character string to input
the result into the main document. It is designed to be used in the chunk
option <code>child</code> and serves as the alternative to the
<code>SweaveInput</code> command in Sweave.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knit_child(..., options = NULL, envir = knit_global())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knit_child_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+knit">knit</a></code>.</p>
</td></tr>
<tr><td><code id="knit_child_+3A_options">options</code></td>
<td>
<p>A list of chunk options to be used as global options inside
the child document. When one uses the <code>child</code>
option in a parent chunk, the chunk options of the parent chunk will be
passed to the <code>options</code> argument here.  Ignored if not a list.</p>
</td></tr>
<tr><td><code id="knit_child_+3A_envir">envir</code></td>
<td>
<p>Environment in which code chunks are to be evaluated, for
example, <code><a href="base.html#topic+parent.frame">parent.frame</a>()</code>, <code><a href="base.html#topic+new.env">new.env</a>()</code>, or
<code><a href="base.html#topic+globalenv">globalenv</a>()</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string of the content of the compiled child document is
returned as a character string so it can be written back to the parent
document directly.
</p>


<h3>Note</h3>

<p>This function is not supposed be called directly like
<code><a href="#topic+knit">knit</a>()</code>; instead it must be placed in a parent document to let
<code><a href="#topic+knit">knit</a>()</code> call it indirectly.
</p>
<p>The path of the child document is determined relative to the parent document.
</p>


<h3>References</h3>

<p><a href="https://yihui.org/knitr/demo/child/">https://yihui.org/knitr/demo/child/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># you can write \Sexpr{knit_child('child-doc.Rnw')} in an Rnw file 'main.Rnw'
# to input results from child-doc.Rnw in main.tex

# comment out the child doc by \Sexpr{knit_child('child-doc.Rnw', eval =
# FALSE)}
</code></pre>

<hr>
<h2 id='knit_code'>The code manager to manage code in all chunks</h2><span id='topic+knit_code'></span>

<h3>Description</h3>

<p>This object provides methods to manage code (as character vectors) in all
chunks in <span class="pkg">knitr</span> source documents. For example,
<code>knitr::knit_code$get()</code> returns a named list of all code chunks (the
names are chunk labels), and <code>knitr::knit_code$get('foo')</code> returns the
character vector of the code in the chunk with the label <code>foo</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knit_code
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 7.
</p>


<h3>Note</h3>

<p>The methods on this object include the <code>set()</code> method (i.e., you
could do something like <code>knitr::knit_code$set(foo = "'my precious new
  code'")</code>), but we recommend that you do not use this method to modify the
content of code chunks, unless you are
<a href="https://emitanaka.rbind.io/post/knitr-knitr-code/">as creative as Emi
Tanaka</a> and know what you are doing.
</p>

<hr>
<h2 id='knit_engines'>Engines of other languages</h2><span id='topic+knit_engines'></span>

<h3>Description</h3>

<p>This object controls how to execute the code from languages other than R
(when the chunk option <code>engine</code> is not <code>'R'</code>). Each component in
this object is a function that takes a list of current chunk options
(including the source code) and returns a character string to be written into
the output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knit_engines
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 7.
</p>


<h3>Details</h3>

<p>The engine function has one argument <code>options</code>: the source code of the
current chunk is in <code>options$code</code>. Usually we can call external
programs to run the code via <code><a href="base.html#topic+system2">system2</a></code>. Other chunk options are
also contained in this argument, e.g. <code>options$echo</code> and
<code>options$eval</code>, etc.
</p>
<p>In most cases, <code>options$engine</code> can be directly used in command line to
execute the code, e.g. <code>python</code> or <code>ruby</code>, but sometimes we may
want to specify the path of the engine program, in which case we can pass it
through the <code>engine.path</code> option. For example, <code>engine='ruby',
engine.path='/usr/bin/ruby1.9.1'</code>. Additional command line arguments can be
passed through <code>options$engine.opts</code>, e.g. <code>engine='ruby',
engine.opts='-v'</code>.
</p>
<p>See <code>str(knitr::knit_engines$get())</code> for a list of built-in language
engines.
</p>


<h3>Note</h3>

<p>The Leiningen engine <code>lein</code> requires lein-exec plugin; see
<a href="https://github.com/yihui/knitr/issues/1176">https://github.com/yihui/knitr/issues/1176</a> for details.
</p>


<h3>References</h3>

<p>Usage: <a href="https://yihui.org/knitr/objects/">https://yihui.org/knitr/objects/</a>; examples:
<a href="https://yihui.org/knitr/demo/engines/">https://yihui.org/knitr/demo/engines/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>knit_engines$get("python")
knit_engines$get("awk")
names(knit_engines$get())
</code></pre>

<hr>
<h2 id='knit_exit'>Exit knitting early</h2><span id='topic+knit_exit'></span>

<h3>Description</h3>

<p>Sometimes we may want to exit the knitting process early, and completely
ignore the rest of the document. This function provides a mechanism to
terminate <code><a href="#topic+knit">knit</a>()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knit_exit(append, fully = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knit_exit_+3A_append">append</code></td>
<td>
<p>A character vector to be appended to the results from
<code>knit()</code> so far. By default, this is &lsquo;<span class="samp">&#8288;\end{document}&#8288;</span>&rsquo; for LaTeX
output, and &lsquo;<span class="samp">&#8288;&lt;/body&gt;&lt;/html&gt;&#8288;</span>&rsquo; for HTML output, to make the output
document complete. For other types of output, it is an empty string.</p>
</td></tr>
<tr><td><code id="knit_exit_+3A_fully">fully</code></td>
<td>
<p>Whether to fully exit the knitting process if <code>knit_exit()</code>
is called from a child document. If <code>FALSE</code>, only exit the knitting
process of the child document.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisible <code>NULL</code>. An internal signal is set up (as a side
effect) to notify <code>knit()</code> to quit as if it had reached the end of the
document.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see https://github.com/yihui/knitr-examples/blob/master/096-knit-exit.Rmd
</code></pre>

<hr>
<h2 id='knit_expand'>A simple macro preprocessor for templating purposes</h2><span id='topic+knit_expand'></span>

<h3>Description</h3>

<p>This function expands a template based on the R expressions in <code>{{}}</code>
(this tag can be customized by the <code>delim</code> argument). These expressions
are extracted, evaluated and replaced by their values in the original
template.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knit_expand(file, ..., text = read_utf8(file), delim = c("{{", "}}"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knit_expand_+3A_file">file</code></td>
<td>
<p>The template file.</p>
</td></tr>
<tr><td><code id="knit_expand_+3A_...">...</code></td>
<td>
<p>A list of variables to be used for the code in the template; note that
the variables will be searched for in the parent frame as well.</p>
</td></tr>
<tr><td><code id="knit_expand_+3A_text">text</code></td>
<td>
<p>Character vector of lines of code. An alternative way to specify
the template code directly. If <code>text</code> is provided, <code>file</code> will be ignored.</p>
</td></tr>
<tr><td><code id="knit_expand_+3A_delim">delim</code></td>
<td>
<p>A pair of opening and closing delimiters for the templating tags.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector, with the tags evaluated and replaced by their
values.
</p>


<h3>References</h3>

<p>This function was inspired by the pyexpander and m4
(<a href="http://www.gnu.org/software/m4/">http://www.gnu.org/software/m4/</a>), thanks to Frank Harrell.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see the knit_expand vignette
if (interactive()) browseVignettes(package = "knitr")
</code></pre>

<hr>
<h2 id='knit_filter'>Spell check filter for source documents</h2><span id='topic+knit_filter'></span>

<h3>Description</h3>

<p>When performing spell checking on source documents, we may need to skip R
code chunks and inline R expressions, because many R functions and symbols
are likely to be identified as typos. This function is designed for the
<code>filter</code> argument of <code><a href="utils.html#topic+aspell">aspell</a>()</code> to filter out code chunks
and inline expressions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knit_filter(ifile, encoding = "UTF-8")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knit_filter_+3A_ifile">ifile</code></td>
<td>
<p>Filename of the source document.</p>
</td></tr>
<tr><td><code id="knit_filter_+3A_encoding">encoding</code></td>
<td>
<p>Ignored (the file <code>ifile</code> must be encoded in UTF-8).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of the file content, excluding code chunks and
inline expressions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(knitr)
knitr_example = function(...) system.file("examples", ..., package = "knitr")

if (Sys.which("aspell") != "") {
    # -t means the TeX mode
    utils::aspell(knitr_example("knitr-minimal.Rnw"), knit_filter, control = "-t")

    # -H is the HTML mode
    utils::aspell(knitr_example("knitr-minimal.Rmd"), knit_filter, control = "-H -t")
}

</code></pre>

<hr>
<h2 id='knit_global'>The global environment in which code chunks are evaluated</h2><span id='topic+knit_global'></span>

<h3>Description</h3>

<p>This function makes the environment of a code chunk accessible inside a
chunk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knit_global()
</code></pre>


<h3>Details</h3>

<p>It returns the <code>envir</code> argument of <code><a href="#topic+knit">knit</a></code>, e.g. if we call
<code><a href="#topic+knit">knit</a>()</code> in the global environment, <code>knit_global()</code> returns
R's global environment by default. You can call functions like
<code><a href="base.html#topic+ls">ls</a>()</code> on this environment.
</p>

<hr>
<h2 id='knit_hooks'>Hooks for R code chunks, inline R code and output</h2><span id='topic+knit_hooks'></span>

<h3>Description</h3>

<p>A hook is a function of a pre-defined form (arguments) that takes values of
arguments and returns desired output. The object <code>knit_hooks</code> is used to
access or set hooks in this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knit_hooks
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 7.
</p>


<h3>References</h3>

<p>Usage: <a href="https://yihui.org/knitr/objects/">https://yihui.org/knitr/objects/</a>
</p>
<p>Components in <code>knit_hooks</code>: <a href="https://yihui.org/knitr/hooks/">https://yihui.org/knitr/hooks/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>knit_hooks$get("source")
knit_hooks$get("inline")
</code></pre>

<hr>
<h2 id='knit_meta'>Metadata about objects to be printed</h2><span id='topic+knit_meta'></span><span id='topic+knit_meta_add'></span>

<h3>Description</h3>

<p>As an object is printed, <span class="pkg">knitr</span> will collect metadata about it (if
available). After knitting is done, all the metadata is accessible via this
function. You can manually add metadata to the <span class="pkg">knitr</span> session via
<code>knit_meta_add()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knit_meta(class = NULL, clean = TRUE)

knit_meta_add(meta, label = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knit_meta_+3A_class">class</code></td>
<td>
<p>Optionally return only metadata entries that inherit from the
specified class. The default, <code>NULL</code>, returns all entries.</p>
</td></tr>
<tr><td><code id="knit_meta_+3A_clean">clean</code></td>
<td>
<p>Whether to clean the collected metadata. By default, the
metadata stored in <span class="pkg">knitr</span> is cleaned up once retrieved, because we may
not want the metadata to be passed to the next <code>knit()</code> call; to be
defensive (i.e. not to have carryover metadata), you can call
<code>knit_meta()</code> before <code>knit()</code>.</p>
</td></tr>
<tr><td><code id="knit_meta_+3A_meta">meta</code></td>
<td>
<p>A metadata object to be added to the session.</p>
</td></tr>
<tr><td><code id="knit_meta_+3A_label">label</code></td>
<td>
<p>A chunk label to indicate which chunk the metadata belongs to.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>knit_meta()</code> returns the matched metadata specified by
<code>class</code>; <code>knit_meta_add()</code> returns all current metadata.
</p>

<hr>
<h2 id='knit_params'>Extract knit parameters from a document</h2><span id='topic+knit_params'></span>

<h3>Description</h3>

<p>This function reads the YAML front-matter section of a document and returns a
list of any parameters declared there. This function exists primarily to
support the parameterized reports feature of the <span class="pkg">rmarkdown</span> package,
however is also used by the knitr <code><a href="#topic+purl">purl</a></code> function to include
the default parameter values in the R code it emits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knit_params(text, evaluate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knit_params_+3A_text">text</code></td>
<td>
<p>Character vector containing the document text.</p>
</td></tr>
<tr><td><code id="knit_params_+3A_evaluate">evaluate</code></td>
<td>
<p>Boolean. If <code>TRUE</code> (the default), expression values embedded
within the YAML will be evaluated. If <code>FALSE</code>, parameters defined with an
expression will have the parsed but unevaluated expression in their <code>value</code>
field.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Parameters are included in YAML front matter using the <code>params</code> key.
This key can have any number of subkeys each of which represents a
parameter. For example:
</p>
<pre>
---
title: My Document
output: html_document
params:
  frequency: 10
  show_details: true
---
</pre>
<p>Parameter values can be provided inline as illustrated above or can be
included in a <code>value</code> sub-key. For example:
</p>
<pre>
---
title: My Document
output: html_document
params:
  frequency:
    value: 10
---
</pre>
<p>This second form is useful when you need to provide additional details
about the parameter (e.g. a <code>label</code> field as describe above).
</p>
<p>You can also use R code to yield the value of a parameter by prefacing the value
with <code>!r</code>, for example:
</p>
<pre>
---
title: My Document
output: html_document
params:
  start: !r Sys.Date()
---
</pre>


<h3>Value</h3>

<p>List of objects of class <code>knit_param</code> that correspond to the
parameters declared in the <code>params</code> section of the YAML front matter.
These objects have the following fields:
</p>

<dl>
<dt><code>name</code></dt><dd><p>The parameter name.</p>
</dd>
<dt><code>value</code></dt><dd><p>The default value for the parameter.</p>
</dd>
<dt><code>expr</code></dt><dd><p>The R expression (if any) that yielded the default value.</p>
</dd>
</dl>

<p>In addition, other fields included in the YAML may also be present
alongside the name, type, and value fields (e.g. a <code>label</code> field
that provides front-ends with a human readable name for the parameter).
</p>

<hr>
<h2 id='knit_params_yaml'>Extract knit parameters from YAML text</h2><span id='topic+knit_params_yaml'></span>

<h3>Description</h3>

<p>This function reads the YAML front-matter that has already been extracted
from a document and returns a list of any parameters declared there.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knit_params_yaml(yaml, evaluate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knit_params_yaml_+3A_yaml">yaml</code></td>
<td>
<p>Character vector containing the YAML text.</p>
</td></tr>
<tr><td><code id="knit_params_yaml_+3A_evaluate">evaluate</code></td>
<td>
<p>If <code>TRUE</code> (the default) expression values
embedded within the YAML will be evaluated. If <code>FALSE</code>, parameters
defined with an expression will have the parsed but unevaluated expression
in their <code>value</code> field.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of objects of class <code>knit_param</code> that correspond to the
parameters declared in the <code>params</code> section of the YAML. See
<code><a href="#topic+knit_params">knit_params</a></code> for a full description of these objects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+knit_params">knit_params</a></code>
</p>

<hr>
<h2 id='knit_patterns'>Patterns to match and extract R code in a document</h2><span id='topic+knit_patterns'></span>

<h3>Description</h3>

<p>Patterns are regular expressions and will be used in functions like
<code>base::<a href="base.html#topic+grep">grep</a>()</code> to extract R code and chunk options. The object
<code>knit_patterns</code> controls the patterns currently used; see the references
and examples for usage.  All built-in patterns are available in the list
<a href="#topic+all_patterns">all_patterns</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knit_patterns
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 7.
</p>


<h3>References</h3>

<p>Usage: <a href="https://yihui.org/knitr/objects/">https://yihui.org/knitr/objects/</a>
</p>
<p>Components in <code>knit_patterns</code>: <a href="https://yihui.org/knitr/patterns/">https://yihui.org/knitr/patterns/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+all_patterns">all_patterns</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(knitr)
opat = knit_patterns$get()  # old pattern list (to restore later)

apats = all_patterns  # a list of all built-in patterns
str(apats)
knit_patterns$set(apats[["rnw"]])  # set pattern list from apats

knit_patterns$get(c("chunk.begin", "chunk.end", "inline.code"))

# a customized pattern list; has to empty the original patterns first!
knit_patterns$restore()
# we may want to use this in an HTML document
knit_patterns$set(list(chunk.begin = "&lt;!--helloR\\s+(.*)", chunk.end = "^byeR--&gt;"))
str(knit_patterns$get())

knit_patterns$set(opat)  # put the old patterns back
</code></pre>

<hr>
<h2 id='knit_print'>A custom printing function</h2><span id='topic+knit_print'></span><span id='topic+normal_print'></span>

<h3>Description</h3>

<p>The S3 generic function <code>knit_print</code> is the default printing function in
<span class="pkg">knitr</span>. The chunk option <code>render</code> uses this function by default.
The main purpose of this S3 generic function is to customize printing of R
objects in code chunks. We can fall back to the normal printing behavior by
setting the chunk option <code>render = normal_print</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knit_print(x, ...)

normal_print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knit_print_+3A_x">x</code></td>
<td>
<p>An R object to be printed</p>
</td></tr>
<tr><td><code id="knit_print_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the S3 method. Currently ignored,
except two optional arguments <code>options</code> and <code>inline</code>; see
the references below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Users can write custom methods based on this generic function. For example,
if we want to print all data frames as tables in the output, we can define a
method <code>knit_print.data.frame</code> that turns a data.frame into a table (the
implementation may use other R packages or functions, e.g. <span class="pkg">xtable</span> or
<code><a href="#topic+kable">kable</a>()</code>).
</p>


<h3>Value</h3>

<p>The value returned from the print method should be a character vector
or can be converted to a character value. You can wrap the value in
<code><a href="#topic+asis_output">asis_output</a>()</code> so that <span class="pkg">knitr</span> writes the character value
as is in the output.
</p>


<h3>Note</h3>

<p>It is recommended to leave a <code>...</code> argument in your method, to
allow future changes of the <code>knit_print()</code> API without breaking your
method.
</p>


<h3>References</h3>

<p>See <code>vignette('knit_print', package = 'knitr')</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(knitr)
# write tables for data frames
knit_print.data.frame = function(x, ...) {
    res = paste(c("", "", kable(x, output = FALSE)), collapse = "\n")
    asis_output(res)
}
# register the method
registerS3method("knit_print", "data.frame", knit_print.data.frame)
# after you define and register the above method, data frames will be printed
# as tables in knitr, which is different with the default print() behavior
</code></pre>

<hr>
<h2 id='knit_rd'>Knit package documentation</h2><span id='topic+knit_rd'></span><span id='topic+knit_rd_all'></span>

<h3>Description</h3>

<p>Run examples in a package and insert output into the examples code;
<code>knit_rd_all()</code> is a wrapper around <code>knit_rd()</code> to build static
HTML help pages for all packages under the &lsquo;<span class="file">html</span>&rsquo; directory of them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knit_rd(pkg, links = tools::findHTMLlinks(), frame = TRUE)

knit_rd_all()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knit_rd_+3A_pkg">pkg</code></td>
<td>
<p>Package name.</p>
</td></tr>
<tr><td><code id="knit_rd_+3A_links">links</code></td>
<td>
<p>A character vector of links to be passed to
<code>tools::<a href="tools.html#topic+Rd2HTML">Rd2HTML</a>()</code>.</p>
</td></tr>
<tr><td><code id="knit_rd_+3A_frame">frame</code></td>
<td>
<p>Boolean: whether to put a navigation frame on the left of the
index page.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>All HTML pages corresponding to topics in the package are written
under the current working directory. An &lsquo;<span class="file">index.html</span>&rsquo; is also written
as a table of content.
</p>


<h3>Note</h3>

<p>Ideally the html pages should be put under the &lsquo;<span class="file">html</span>&rsquo; directory of
an installed package which can be found via <code>system.file('html',
  package = 'your_package_name')</code>, otherwise some links may not work (e.g.
the link to the DESCRITION file).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(knitr)
## Not run: 

knit_rd("maps")
knit_rd("rpart")
setwd(system.file("html", package = "ggplot2"))
knit_rd("ggplot2")  # time-consuming!

knit_rd_all()  # this may take really long time if you have many packages installed

## End(Not run)
</code></pre>

<hr>
<h2 id='knit_theme'>Syntax highlighting themes</h2><span id='topic+knit_theme'></span>

<h3>Description</h3>

<p>This object can be used to set or get themes in <span class="pkg">knitr</span> for syntax
highlighting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knit_theme
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 2.
</p>


<h3>Details</h3>

<p>We can use <code>knit_theme$set(theme)</code> to set the theme, and
<code>knit_theme$get(theme)</code> to get a theme. The <code>theme</code> is a character
string for both methods (either the name of the theme, or the path to the CSS
file of a theme), and for the <code>set()</code> method, it can also be a list
returned by the <code>get()</code> method. See examples below.
</p>


<h3>Note</h3>

<p>The syntax highlighting here only applies to &lsquo;<span class="file">.Rnw</span>&rsquo; (LaTeX) and
&lsquo;<span class="file">.Rhtml</span>&rsquo; (HTML) documents, and it does not work for other types of
documents, such as &lsquo;<span class="file">.Rmd</span>&rsquo; (R Markdown, which has its own syntax
highlighting themes; see <a href="https://rmarkdown.rstudio.com">https://rmarkdown.rstudio.com</a>).
</p>


<h3>Author(s)</h3>

<p>Ramnath Vaidyanathan and Yihui Xie
</p>


<h3>References</h3>

<p>For a preview of all themes, see
<a href="https://gist.github.com/yihui/3422133">https://gist.github.com/yihui/3422133</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>opts_knit$set(out.format = "latex")
knit_theme$set("edit-vim")

knit_theme$get()  # names of all available themes

thm = knit_theme$get("acid")  # parse the theme to a list
knit_theme$set(thm)

opts_knit$set(out.format = NULL)  # restore option
</code></pre>

<hr>
<h2 id='knit_watch'>Watch an input file continuously and knit it when it is updated</h2><span id='topic+knit_watch'></span>

<h3>Description</h3>

<p>Check the modification time of an input file continously in an infinite loop.
Whenever the time indicates the file has been modified, call a function to
recompile the input file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knit_watch(input, compile = knit, interval = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knit_watch_+3A_input">input</code></td>
<td>
<p>An input file path, or a character vector of mutiple input file paths.</p>
</td></tr>
<tr><td><code id="knit_watch_+3A_compile">compile</code></td>
<td>
<p>A function to compile the <code>input</code> file. This could be e.g.
<code><a href="#topic+knit">knit</a></code> or <code><a href="#topic+knit2pdf">knit2pdf</a></code>, depending on the input file
and the output you want.</p>
</td></tr>
<tr><td><code id="knit_watch_+3A_interval">interval</code></td>
<td>
<p>A time interval to pause in each cycle of the infinite loop.</p>
</td></tr>
<tr><td><code id="knit_watch_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to the <code>compile</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is actually a general function not necessarily restricted to
applications in <span class="pkg">knitr</span>. You may specify any <code>compile</code> function to
process the <code>input</code> file. To stop the infinite loop, press the
&lsquo;<span class="samp">&#8288;Escape&#8288;</span>&rsquo; key or &lsquo;<span class="samp">&#8288;Ctrl + C&#8288;</span>&rsquo; (depending on your editing environment
and operating system).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># knit_watch('foo.Rnw', knit2pdf)

# knit_watch('foo.Rmd', rmarkdown::render)
</code></pre>

<hr>
<h2 id='knit2html'>Convert markdown to HTML using knit() and mark_html()</h2><span id='topic+knit2html'></span>

<h3>Description</h3>

<p>This is a convenience function to knit the input markdown source and call
<code>markdown::<a href="markdown.html#topic+mark_html">mark_html</a>()</code> in the <span class="pkg">markdown</span>
package to convert the result to HTML.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knit2html(
  input,
  output = NULL,
  ...,
  envir = parent.frame(),
  text = NULL,
  quiet = FALSE,
  encoding = "UTF-8",
  force_v1 = getOption("knitr.knit2html.force_v1", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knit2html_+3A_input">input</code></td>
<td>
<p>Path to the input file.</p>
</td></tr>
<tr><td><code id="knit2html_+3A_output">output</code></td>
<td>
<p>Path to the output file for <code>knit()</code>. If <code>NULL</code>, this
function will try to guess a default, which will be under the current
working directory.</p>
</td></tr>
<tr><td><code id="knit2html_+3A_...">...</code></td>
<td>
<p>Options passed to
<code>markdown::<a href="markdown.html#topic+mark_html">mark_html</a>()</code>.</p>
</td></tr>
<tr><td><code id="knit2html_+3A_envir">envir</code></td>
<td>
<p>Environment in which code chunks are to be evaluated, for
example, <code><a href="base.html#topic+parent.frame">parent.frame</a>()</code>, <code><a href="base.html#topic+new.env">new.env</a>()</code>, or
<code><a href="base.html#topic+globalenv">globalenv</a>()</code>).</p>
</td></tr>
<tr><td><code id="knit2html_+3A_text">text</code></td>
<td>
<p>A character vector. This is an alternative way to provide the
input file.</p>
</td></tr>
<tr><td><code id="knit2html_+3A_quiet">quiet</code></td>
<td>
<p>Boolean; suppress the progress bar and messages?</p>
</td></tr>
<tr><td><code id="knit2html_+3A_encoding">encoding</code></td>
<td>
<p>Encoding of the input file; always assumed to be UTF-8 (i.e.,
this argument is effectively ignored).</p>
</td></tr>
<tr><td><code id="knit2html_+3A_force_v1">force_v1</code></td>
<td>
<p>Boolean; whether to force rendering the input document as an
R Markdown v1 document, even if it is for v2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the argument <code>text</code> is NULL, a character string (HTML code)
is returned; otherwise the result is written into a file and the filename
is returned.
</p>


<h3>Note</h3>

<p>The <span class="pkg">markdown</span> package is for R Markdown v1, which is much less
powerful than R Markdown v2, i.e. the <span class="pkg">rmarkdown</span> package
(<a href="https://rmarkdown.rstudio.com">https://rmarkdown.rstudio.com</a>). To render R Markdown v2 documents to
HTML, please use <code>rmarkdown::render()</code> instead.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+knit">knit</a></code>, <code>markdown::<a href="markdown.html#topic+mark_html">mark_html</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># a minimal example
writeLines(c("# hello markdown", "```{r hello-random, echo=TRUE}", "rnorm(5)", "```"),
    "test.Rmd")
knit2html("test.Rmd")
if (interactive()) browseURL("test.html")

unlink(c("test.Rmd", "test.html", "test.md"))
</code></pre>

<hr>
<h2 id='knit2pandoc'>Convert various input files to various output files using <code>knit()</code> and
Pandoc</h2><span id='topic+knit2pandoc'></span>

<h3>Description</h3>

<p>Knits the input file and compiles to an output format using Pandoc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knit2pandoc(
  input,
  output = NULL,
  tangle = FALSE,
  text = NULL,
  quiet = FALSE,
  envir = parent.frame(),
  to = "html",
  pandoc_wrapper = NULL,
  ...,
  encoding = "UTF-8"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knit2pandoc_+3A_input">input</code></td>
<td>
<p>Path to the input file.</p>
</td></tr>
<tr><td><code id="knit2pandoc_+3A_output">output</code></td>
<td>
<p>Path to the output file for <code>knit()</code>. If <code>NULL</code>, this
function will try to guess a default, which will be under the current
working directory.</p>
</td></tr>
<tr><td><code id="knit2pandoc_+3A_tangle">tangle</code></td>
<td>
<p>Boolean; whether to tangle the R code from the input file (like
<code>utils::<a href="utils.html#topic+Stangle">Stangle</a></code>).</p>
</td></tr>
<tr><td><code id="knit2pandoc_+3A_text">text</code></td>
<td>
<p>A character vector. This is an alternative way to provide the
input file.</p>
</td></tr>
<tr><td><code id="knit2pandoc_+3A_quiet">quiet</code></td>
<td>
<p>Boolean; suppress the progress bar and messages?</p>
</td></tr>
<tr><td><code id="knit2pandoc_+3A_envir">envir</code></td>
<td>
<p>Environment in which code chunks are to be evaluated, for
example, <code><a href="base.html#topic+parent.frame">parent.frame</a>()</code>, <code><a href="base.html#topic+new.env">new.env</a>()</code>, or
<code><a href="base.html#topic+globalenv">globalenv</a>()</code>).</p>
</td></tr>
<tr><td><code id="knit2pandoc_+3A_to">to</code></td>
<td>
<p>Character string giving the Pandoc output format to use.</p>
</td></tr>
<tr><td><code id="knit2pandoc_+3A_pandoc_wrapper">pandoc_wrapper</code></td>
<td>
<p>An R function used to call Pandoc. If <code>NULL</code> (the
default), <code>rmarkdown::<a href="rmarkdown.html#topic+pandoc_convert">pandoc_convert</a>()</code> will be used
if <span class="pkg">rmarkdown</span> is installed, otherwise <code><a href="#topic+pandoc">pandoc</a>()</code>.</p>
</td></tr>
<tr><td><code id="knit2pandoc_+3A_...">...</code></td>
<td>
<p>Options to be passed to the <code>pandoc_wrapper</code> function.</p>
</td></tr>
<tr><td><code id="knit2pandoc_+3A_encoding">encoding</code></td>
<td>
<p>Ignored (always assumes UTF-8).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the output of the <code>pandoc_wrapper</code> function.
</p>


<h3>Author(s)</h3>

<p>Trevor L. Davis
</p>

<hr>
<h2 id='knit2pdf'>Convert Rnw or Rrst files to PDF</h2><span id='topic+knit2pdf'></span>

<h3>Description</h3>

<p>Knit the input Rnw or Rrst document, and compile to PDF using
<code>tinytex::<a href="tinytex.html#topic+latexmk">latexmk</a>()</code> or <code><a href="#topic+rst2pdf">rst2pdf</a>()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knit2pdf(
  input,
  output = NULL,
  compiler = NULL,
  envir = parent.frame(),
  quiet = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knit2pdf_+3A_input">input</code></td>
<td>
<p>Path to the input file.</p>
</td></tr>
<tr><td><code id="knit2pdf_+3A_output">output</code></td>
<td>
<p>Path to the output file for <code>knit()</code>. If <code>NULL</code>, this
function will try to guess a default, which will be under the current
working directory.</p>
</td></tr>
<tr><td><code id="knit2pdf_+3A_compiler">compiler</code></td>
<td>
<p>A character string giving the LaTeX engine used to compile
the tex document to PDF. For an Rrst file, setting <code>compiler</code> to
<code>'rst2pdf'</code> will use <code><a href="#topic+rst2pdf">rst2pdf</a></code> to compile the rst file to
PDF using the ReportLab open-source library.</p>
</td></tr>
<tr><td><code id="knit2pdf_+3A_envir">envir</code></td>
<td>
<p>Environment in which code chunks are to be evaluated, for
example, <code><a href="base.html#topic+parent.frame">parent.frame</a>()</code>, <code><a href="base.html#topic+new.env">new.env</a>()</code>, or
<code><a href="base.html#topic+globalenv">globalenv</a>()</code>).</p>
</td></tr>
<tr><td><code id="knit2pdf_+3A_quiet">quiet</code></td>
<td>
<p>Boolean; suppress the progress bar and messages?</p>
</td></tr>
<tr><td><code id="knit2pdf_+3A_...">...</code></td>
<td>
<p>Options to be passed to <code>tinytex::<a href="tinytex.html#topic+latexmk">latexmk</a>()</code>
or <code><a href="#topic+rst2pdf">rst2pdf</a>()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The filename of the PDF file.
</p>


<h3>Note</h3>

<p>The <code>output</code> argument specifies the output filename to be passed
to the PDF compiler (e.g. a tex document) instead of the PDF filename.
</p>


<h3>Author(s)</h3>

<p>Ramnath Vaidyanathan, Alex Zvoleff and Yihui Xie
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#' compile with xelatex
## knit2pdf(..., compiler = 'xelatex')

#' compile a reST file with rst2pdf
## knit2pdf(..., compiler = 'rst2pdf')
</code></pre>

<hr>
<h2 id='knit2wp'>Knit an R Markdown document and post it to WordPress</h2><span id='topic+knit2wp'></span>

<h3>Description</h3>

<p>This function is a wrapper around the <span class="pkg">RWordPress</span> package. It compiles
an R Markdown document to HTML and post the results to WordPress. Please note
that <span class="pkg">RWordPress</span> has not been updated for several years, which is
<a href="https://github.com/yihui/knitr/issues/1866">not a good sign</a>. For
blogging with R, you may want to try the <span class="pkg">blogdown</span> package instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knit2wp(
  input,
  title = "A post from knitr",
  ...,
  envir = parent.frame(),
  shortcode = FALSE,
  action = c("newPost", "editPost", "newPage"),
  postid,
  publish = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knit2wp_+3A_input">input</code></td>
<td>
<p>Filename of the Rmd document.</p>
</td></tr>
<tr><td><code id="knit2wp_+3A_title">title</code></td>
<td>
<p>Title of the post.</p>
</td></tr>
<tr><td><code id="knit2wp_+3A_...">...</code></td>
<td>
<p>Other meta information of the post, e.g. <code>categories = c('R',
'Stats')</code> and <code>mt_keywords = c('knitr', 'wordpress')</code>, et cetera.</p>
</td></tr>
<tr><td><code id="knit2wp_+3A_envir">envir</code></td>
<td>
<p>Environment in which code chunks are to be evaluated, for
example, <code><a href="base.html#topic+parent.frame">parent.frame</a>()</code>, <code><a href="base.html#topic+new.env">new.env</a>()</code>, or
<code><a href="base.html#topic+globalenv">globalenv</a>()</code>).</p>
</td></tr>
<tr><td><code id="knit2wp_+3A_shortcode">shortcode</code></td>
<td>
<p>A length-2 logical vector: whether to use the shortcode
&lsquo;<span class="samp">&#8288;[sourcecode lang='lang']&#8288;</span>&rsquo;, which can be useful to WordPress.com users
for syntax highlighting of source code and output. The first element
applies to source code, and the second applies to text output. By default,
both are <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="knit2wp_+3A_action">action</code></td>
<td>
<p>Whether to create a new post, update an existing post, or
create a new page.</p>
</td></tr>
<tr><td><code id="knit2wp_+3A_postid">postid</code></td>
<td>
<p>If <code>action</code> is <code>editPost</code>, the post id <code>postid</code>
must be specified.</p>
</td></tr>
<tr><td><code id="knit2wp_+3A_publish">publish</code></td>
<td>
<p>Boolean: publish the post immediately?</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function will convert the encoding of the post and the title to
UTF-8 internally. If you have additional data to send to WordPress (e.g.
keywords and categories), you may have to manually convert them to the
UTF-8 encoding with the <code><a href="base.html#topic+iconv">iconv</a>(x, to = 'UTF-8')</code> function
(especially when using Windows).
</p>


<h3>Author(s)</h3>

<p>William K. Morris, Yihui Xie, and Jared Lander
</p>


<h3>References</h3>

<p><a href="https://yihui.org/knitr/demo/wordpress/">https://yihui.org/knitr/demo/wordpress/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see the reference
</code></pre>

<hr>
<h2 id='knitr-package'>A general-purpose tool for dynamic report generation in R</h2><span id='topic+knitr-package'></span><span id='topic+knitr'></span>

<h3>Description</h3>

<p>The <span class="pkg">knitr</span> package is an implementation of Literate Programming, a
programming paradigm that intermingle code chunks (for computing) with prose
(for documentation) in the same document.
</p>


<h3>Details</h3>

<p>When the document is compiled, the code chunks can be executed, and the
results from computing (text or graphics) are automatically written to the
output along with the prose.
</p>
<p>This package is an alternative tool to Sweave with a more flexible design and
new features like caching and finer control of graphics. It is not limited to
LaTeX and is ready to be customized to process other file formats. See the
package website in the references for more information and examples.
</p>


<h3>Note</h3>

<p>The pronunciation of <span class="pkg">knitr</span> is similar to <em>neater</em> or you can
think of <em>knitter</em> (but it is <em>single t</em>). The name comes from
<code>knit</code> + <code>R</code> (while <code>Sweave</code> = <code>S</code> + <code>weave</code>).
</p>


<h3>Author(s)</h3>

<p>Yihui Xie &lt;<a href="https://yihui.org">https://yihui.org</a>&gt;
</p>


<h3>References</h3>

<p>Full documentation and demos: <a href="https://yihui.org/knitr/">https://yihui.org/knitr/</a>;
FAQ's: <a href="https://yihui.org/knitr/faq/">https://yihui.org/knitr/faq/</a>
</p>


<h3>See Also</h3>

<p>The core function in this package: <code><a href="#topic+knit">knit</a></code>. If you are an
Sweave user, see <code><a href="#topic+Sweave2knitr">Sweave2knitr</a></code> on how to convert Sweave files
to <span class="pkg">knitr</span>.
</p>

<hr>
<h2 id='load_cache'>Load the cache database of a code chunk</h2><span id='topic+load_cache'></span>

<h3>Description</h3>

<p>If a code chunk has turned on the chunk option <code>cache = TRUE</code>, a cache
database will be established after the document is compiled. You can use this
function to manually load the database anywhere in the document (even before
the code chunk). This makes it possible to use objects created later in the
document earlier, e.g. in an inline R expression before the cached code
chunk, which is normally not possible because <span class="pkg">knitr</span> compiles the
document in a linear fashion, and objects created later cannot be used before
they are created.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_cache(
  label,
  object,
  notfound = "NOT AVAILABLE",
  path = opts_chunk$get("cache.path"),
  dir = opts_knit$get("output.dir"),
  envir = NULL,
  lazy = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_cache_+3A_label">label</code></td>
<td>
<p>The chunk label of the code chunk that has a cache database.</p>
</td></tr>
<tr><td><code id="load_cache_+3A_object">object</code></td>
<td>
<p>The name of the object to be fetched from the database. If it
is missing, <code>NULL</code> is returned).</p>
</td></tr>
<tr><td><code id="load_cache_+3A_notfound">notfound</code></td>
<td>
<p>A value to use when the <code>object</code> cannot be found.</p>
</td></tr>
<tr><td><code id="load_cache_+3A_path">path</code></td>
<td>
<p>Path of the cache database (normally set in the global chunk
option <code>cache.path</code>).</p>
</td></tr>
<tr><td><code id="load_cache_+3A_dir">dir</code></td>
<td>
<p>Path to use as the working directory. Defaults to the output
directory if run inside a <span class="pkg">knitr</span> context and to the current working
directory otherwise. Any relative <code>path</code> is defined from <code>dir</code>.</p>
</td></tr>
<tr><td><code id="load_cache_+3A_envir">envir</code></td>
<td>
<p>Environment to use for cache loading, into which all objects in
the cache for the specified chunk (not just that in <code>object</code>) will be
loaded. Defaults to the value in <code><a href="#topic+knit_global">knit_global</a></code>.</p>
</td></tr>
<tr><td><code id="load_cache_+3A_lazy">lazy</code></td>
<td>
<p>Whether to <code><a href="base.html#topic+lazyLoad">lazyLoad</a></code> the cache database (depending
on the chunk option <code>cache.lazy = TRUE</code> or <code>FALSE</code> of that code
chunk).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisible <code>NULL</code> when <code>object</code> is not specified (the cache
database will be loaded as a side effect), otherwise the value of the
object if found.
</p>


<h3>Note</h3>

<p>Apparently this function loads the value of the object from the
<em>previous</em> run of the document, which may be problematic when the
value of the object becomes different the next time the document is
compiled. Normally you must compile the document twice to make sure the
cache database is created, and the object can be read from it. Please use
this function with caution.
</p>


<h3>References</h3>

<p>See the example #114 at
<a href="https://github.com/yihui/knitr-examples">https://github.com/yihui/knitr-examples</a>.
</p>

<hr>
<h2 id='opts_chunk'>Default and current chunk options</h2><span id='topic+opts_chunk'></span><span id='topic+opts_current'></span>

<h3>Description</h3>

<p>Options for R code chunks. When running R code, the object <code>opts_chunk</code>
(default options) is not modified by chunk headers (local chunk options are
merged with default options), whereas <code>opts_current</code> (current options)
changes with different chunk headers and it always reflects the options for
the current chunk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_chunk

opts_current
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 7.
</p>
<p>An object of class <code>list</code> of length 7.
</p>


<h3>Details</h3>

<p>Normally we set up the global options once in the first code chunk in a
document using <code>opts_chunk$set()</code>, so that all <em>latter</em> chunks will
use these options. Note the global options set in one chunk will not affect
the options in this chunk itself, and that is why we often need to set global
options in a separate chunk.
</p>
<p>See <code>str(knitr::opts_chunk$get())</code> for a list of default chunk options.
</p>


<h3>Note</h3>

<p><code>opts_current</code> should be treated as read-only and you are supposed
to only query its values via <code>opts_current$get()</code>. Calling
<code>opts_current$set()</code> will throw an error.
</p>


<h3>References</h3>

<p>Usage: <a href="https://yihui.org/knitr/objects/">https://yihui.org/knitr/objects/</a>
</p>
<p>A list of available options:
<a href="https://yihui.org/knitr/options/#chunk-options">https://yihui.org/knitr/options/#chunk-options</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>opts_chunk$get("prompt")
opts_chunk$get("fig.keep")
</code></pre>

<hr>
<h2 id='opts_hooks'>Hooks for code chunk options</h2><span id='topic+opts_hooks'></span>

<h3>Description</h3>

<p>Like <code><a href="#topic+knit_hooks">knit_hooks</a></code>, this object can be used to set hook functions
to manipulate chunk options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_hooks
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 7.
</p>


<h3>Details</h3>

<p>For every code chunk, if the chunk option named, say, <code>FOO</code>, is not
<code>NULL</code>, and a hook function with the same name has been set via
<code>opts_hooks$set(FOO = function(options) { options })</code> (you can manipuate
the <code>options</code> argument in the function and return it), the hook function
will be called to update the chunk options.
</p>


<h3>References</h3>

<p><a href="https://yihui.org/knitr/hooks/">https://yihui.org/knitr/hooks/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># make sure the figure width is no smaller than fig.height
opts_hooks$set(fig.width = function(options) {
    if (options$fig.width &lt; options$fig.height) {
        options$fig.width = options$fig.height
    }
    options
})
# remove all hooks
opts_hooks$restore()
</code></pre>

<hr>
<h2 id='opts_knit'>Options for the knitr package</h2><span id='topic+opts_knit'></span>

<h3>Description</h3>

<p>Options including whether to use a progress bar when knitting a document, and
the base directory of images, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_knit
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 7.
</p>


<h3>Details</h3>

<p>Besides the standard usage (<code>opts_knit$set()</code>), we can also set package
options prior to loading <code>knitr</code> or calling <code>knit()</code> using
<code><a href="base.html#topic+options">options</a>()</code> in base R. A global option <code>knitr.package.foo</code>
in <code>options()</code> will be set as an option <code>foo</code> in <code>opts_knit</code>,
i.e. global options in base R with the prefix <code>knitr.package.</code>
correspond to options in <code>opts_knit</code>. This can be useful to set package
options in &lsquo;<span class="file">~/.Rprofile</span>&rsquo; without loading <span class="pkg">knitr</span>.
</p>
<p>See <code>str(knitr::opts_knit$get())</code> for a list of default package options.
</p>


<h3>References</h3>

<p>Usage: <a href="https://yihui.org/knitr/objects/">https://yihui.org/knitr/objects/</a>
</p>
<p>A list of available options:
<a href="https://yihui.org/knitr/options/#package_options">https://yihui.org/knitr/options/#package_options</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>opts_knit$get("verbose")
opts_knit$set(verbose = TRUE)  # change it
if (interactive()) {
    # for unnamed chunks, use 'fig' as the figure prefix
    opts_knit$set(unnamed.chunk.label = "fig")
    knit("001-minimal.Rmd")  # from https://github.com/yihui/knitr-examples
}
</code></pre>

<hr>
<h2 id='opts_template'>Template for creating reusable chunk options</h2><span id='topic+opts_template'></span>

<h3>Description</h3>

<p>Creates a template binding a label to a set of chunk options. Every chunk
that references the template label will have the specified set of options
applied to it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_template
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 7.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>opts_template$set(myfigures = list(fig.height = 4, fig.width = 4))
# later you can reuse these chunk options by 'opts.label', e.g.

# &lt;&lt;foo, opts.label='myfigures'&gt;&gt;=

# the above is equivalent to &lt;&lt;foo, fig.height=4, fig.width=4&gt;&gt;=
</code></pre>

<hr>
<h2 id='pandoc'>A Pandoc wrapper to convert documents to other formats</h2><span id='topic+pandoc'></span>

<h3>Description</h3>

<p>This function calls Pandoc to convert documents to other formats such as
HTML, LaTeX/PDF and Word, etc, (optionally) based on a configuration file or
in-file configurations which specify the options to use for Pandoc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pandoc(input, format, config = getOption("config.pandoc"), ext = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pandoc_+3A_input">input</code></td>
<td>
<p>A character vector of Markdown filenames (must be encoded in
UTF-8).</p>
</td></tr>
<tr><td><code id="pandoc_+3A_format">format</code></td>
<td>
<p>Name of the output format (see References). This can be a
character vector of multiple formats; by default, it is obtained from the
<code>t</code> field in the configuration. If the configuration is empty or the
<code>t</code> field is not found, the default output format will be
<code>'html'</code>.</p>
</td></tr>
<tr><td><code id="pandoc_+3A_config">config</code></td>
<td>
<p>Path to the Pandoc configuration file. If missing, it is
assumed to be a file with the same base name as the <code>input</code> file and
an extension <code>.pandoc</code> (e.g. for &lsquo;<span class="file">foo.md</span>&rsquo; it looks for
&lsquo;<span class="file">foo.pandoc</span>&rsquo;)</p>
</td></tr>
<tr><td><code id="pandoc_+3A_ext">ext</code></td>
<td>
<p>Filename extensions. By default, the extension is inferred from
the <code>format</code>, e.g. <code>latex</code> creates <code>pdf</code>, <code>dzslides</code>
creates <code>html</code>, and so on</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are two ways to input the Pandoc configurations &ndash; through a config
file, or embed the configurations in the input file as special comments
between <code style="white-space: pre;">&#8288;&lt;!--pandoc&#8288;</code> and <code style="white-space: pre;">&#8288;--&gt;&#8288;</code>.
</p>
<p>The configuration file is a DCF file (see <code><a href="base.html#topic+read.dcf">read.dcf</a></code>). This file
must contain a field named <code>t</code> which means the output format. The
configurations are written in the form of <code>tag:value</code> and passed to
Pandoc (if no value is needed, just leave it empty, e.g. the option
<code>standalone</code> or <code>s</code> for short). If there are multiple output
formats, write each format and relevant configurations in a block, and
separate blocks with blank lines.
</p>
<p>If there are multiple records of the <code>t</code> field in the configuration, the
input markdown file will be converted to all these formats by default, unless
the <code>format</code> argument is specified as one single format.
</p>


<h3>Value</h3>

<p>The output filename(s) (or an error if the conversion failed).
</p>


<h3>References</h3>

<p>Pandoc: <a href="https://pandoc.org">https://pandoc.org</a>; Examples and rules of the
configurations: <a href="https://yihui.org/knitr/demo/pandoc/">https://yihui.org/knitr/demo/pandoc/</a>
</p>
<p>Also see R Markdown (v2) at <a href="https://rmarkdown.rstudio.com">https://rmarkdown.rstudio.com</a>. The
<span class="pkg">rmarkdown</span> package has several convenience functions and templates
that make it very easy to use Pandoc. The RStudio IDE also has
comprehensive support for it, so I'd recommend users who are not familiar
with command-line tools to use the <span class="pkg">rmarkdown</span> package instead.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+read.dcf">read.dcf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>system("pandoc -h")  # see possible output formats
</code></pre>

<hr>
<h2 id='partition_chunk'>Partition chunk options from the code chunk body</h2><span id='topic+partition_chunk'></span>

<h3>Description</h3>

<p>Chunk options can be written in special comments (e.g., after <code style="white-space: pre;">&#8288;#|&#8288;</code> for R
code chunks) inside a code chunk. This function partitions these options from
the chunk body.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partition_chunk(engine, code)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partition_chunk_+3A_engine">engine</code></td>
<td>
<p>The name of the language engine (to determine the appropriate
comment character).</p>
</td></tr>
<tr><td><code id="partition_chunk_+3A_code">code</code></td>
<td>
<p>A character vector (lines of code).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following items: </p>
<dl>
<dt><code>options</code></dt><dd><p>The
parsed options (if any) as a list.</p>
</dd> <dt><code>src</code></dt><dd><p>The part of the input
that contains the options.</p>
</dd> <dt><code>code</code></dt><dd><p>The part of the input that
contains the code.</p>
</dd></dl>



<h3>Note</h3>

<p>Chunk options must be written on <em>continuous</em> lines (i.e., all
lines must start with the special comment prefix such as <code style="white-space: pre;">&#8288;#|&#8288;</code>) at the
beginning of the chunk body.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># parse yaml-like items
yaml_like = c("#| label: mine", "#| echo: true", "#| fig.width: 8", "#| foo: bar",
    "1 + 1")
writeLines(yaml_like)
knitr::partition_chunk("r", yaml_like)

# parse CSV syntax
csv_like = c("#| mine, echo = TRUE, fig.width = 8, foo = 'bar'", "1 + 1")
writeLines(csv_like)
knitr::partition_chunk("r", csv_like)
</code></pre>

<hr>
<h2 id='pat_rnw'>Set regular expressions to read input documents</h2><span id='topic+pat_rnw'></span><span id='topic+pat_brew'></span><span id='topic+pat_tex'></span><span id='topic+pat_html'></span><span id='topic+pat_md'></span><span id='topic+pat_rst'></span><span id='topic+pat_asciidoc'></span><span id='topic+pat_textile'></span>

<h3>Description</h3>

<p>These are convenience functions to set pre-defined pattern lists (the syntax
to read input documents). The function names are built from corresponding
file extensions, e.g. <code>pat_rnw()</code> can set the Sweave syntax to read Rnw
documents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pat_rnw()

pat_brew()

pat_tex()

pat_html()

pat_md()

pat_rst()

pat_asciidoc()

pat_textile()
</code></pre>


<h3>Value</h3>

<p>The patterns object <code><a href="#topic+knit_patterns">knit_patterns</a></code> is modified as a side
effect.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see how knit_patterns is modified
knit_patterns$get()
pat_rnw()
knit_patterns$get()

knit_patterns$restore()  # empty the list
</code></pre>

<hr>
<h2 id='plot_crop'>Crop a plot (remove the edges) using PDFCrop or ImageMagick</h2><span id='topic+plot_crop'></span>

<h3>Description</h3>

<p>The program <code>pdfcrop</code> (often shipped with a LaTeX distribution) is
executed on a PDF plot file, and
<code>magick::<a href="magick.html#topic+transform">image_trim</a>()</code> is executed for other
types of plot files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_crop(x, quiet = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_crop_+3A_x">x</code></td>
<td>
<p>Filename of the plot.</p>
</td></tr>
<tr><td><code id="plot_crop_+3A_quiet">quiet</code></td>
<td>
<p>Whether to suppress standard output from the command.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The program <code>pdfcrop</code> can crop the extra white margins when the plot
format is PDF, to make better use of the space in the output document,
otherwise we often have to struggle with <code>graphics::<a href="graphics.html#topic+par">par</a>()</code> to set
appropriate margins. Note <code>pdfcrop</code> often comes with a LaTeX
distribution such as TinyTeX, MiKTeX, or TeX Live, and you may not need to
install it separately (use <code>Sys.which('pdfcrop')</code> to check it; if it not
empty, you are able to use it). Note that <code>pdfcrop</code> depends on
GhostScript. You can check if GhostScript is installed via
<code>tools::find_gs_cmd()</code>.
</p>


<h3>Value</h3>

<p>The original filename.
</p>


<h3>References</h3>

<p>PDFCrop: <a href="https://www.ctan.org/pkg/pdfcrop">https://www.ctan.org/pkg/pdfcrop</a>. If you use
TinyTeX, you may install <code>pdfcrop</code> with
<code>tinytex::tlmgr_install('pdfcrop')</code>.
</p>

<hr>
<h2 id='rand_seed'>An unevaluated expression to return .Random.seed if exists</h2><span id='topic+rand_seed'></span>

<h3>Description</h3>

<p>This expression returns <code>.Random.seed</code> when <code>eval(rand_seed)</code> and
<code>NULL</code> otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rand_seed
</code></pre>


<h3>Details</h3>

<p>It is designed to work with <code>opts_chunk$set(cache.extra = rand_seed)</code>
for reproducibility of chunks that involve with random number generation. See
references.
</p>


<h3>References</h3>

<p><a href="https://yihui.org/knitr/demo/cache/">https://yihui.org/knitr/demo/cache/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>eval(rand_seed)
rnorm(1)  # .Random.seed is created (or modified)
eval(rand_seed)
</code></pre>

<hr>
<h2 id='raw_block'>Mark character strings as raw blocks in R Markdown</h2><span id='topic+raw_block'></span><span id='topic+raw_latex'></span><span id='topic+raw_html'></span>

<h3>Description</h3>

<p>Wraps content in a raw attribute block, which protects it from being escaped
by Pandoc. See <a href="https://pandoc.org/MANUAL.html#generic-raw-attribute">https://pandoc.org/MANUAL.html#generic-raw-attribute</a>.
Functions <code>raw_latex()</code> and <code>raw_html()</code> are shorthands of
<code>raw_block(x, 'latex')</code> and <code>raw_block(x, 'html')</code>, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raw_block(x, type = "latex", ...)

raw_latex(x, ...)

raw_html(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raw_block_+3A_x">x</code></td>
<td>
<p>The character vector to be protected.</p>
</td></tr>
<tr><td><code id="raw_block_+3A_type">type</code></td>
<td>
<p>The type of raw blocks (i.e., the Pandoc output format). If you
are not sure about the Pandoc output format of your document, insert a code
chunk <code>knitr:::pandoc_to()</code> and see what it returns after the document
is compiled.</p>
</td></tr>
<tr><td><code id="raw_block_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="#topic+asis_output">asis_output</a>()</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>knitr::raw_latex("\\emph{some text}")
</code></pre>

<hr>
<h2 id='read_chunk'>Read chunks from an external script</h2><span id='topic+read_chunk'></span><span id='topic+read_demo'></span>

<h3>Description</h3>

<p>Chunks can be put in an external script, and this function reads chunks into
the current <span class="pkg">knitr</span> session; <code>read_demo()</code> is a convenience function
to read a demo script from a package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_chunk(
  path,
  lines = read_utf8(path),
  labels = NULL,
  from = NULL,
  to = NULL,
  from.offset = 0L,
  to.offset = 0L,
  roxygen_comments = TRUE
)

read_demo(topic, package = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_chunk_+3A_path">path</code></td>
<td>
<p>Path to the R script.</p>
</td></tr>
<tr><td><code id="read_chunk_+3A_lines">lines</code></td>
<td>
<p>Character vector of lines of code. By default, this is read from
<code>path</code>.</p>
</td></tr>
<tr><td><code id="read_chunk_+3A_labels">labels</code></td>
<td>
<p>Character vector of chunk labels (default <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="read_chunk_+3A_from">from</code>, <code id="read_chunk_+3A_to">to</code></td>
<td>
<p>Numeric vector specifying the starting/ending line numbers of
code chunks, or a character vector; see Details.</p>
</td></tr>
<tr><td><code id="read_chunk_+3A_from.offset">from.offset</code>, <code id="read_chunk_+3A_to.offset">to.offset</code></td>
<td>
<p>Offsets to be added to <code>from</code>/<code>to</code>.</p>
</td></tr>
<tr><td><code id="read_chunk_+3A_roxygen_comments">roxygen_comments</code></td>
<td>
<p>Logical dictating whether to keep trailing
roxygen-style comments from code chunks in addition to whitespace</p>
</td></tr>
<tr><td><code id="read_chunk_+3A_topic">topic</code>, <code id="read_chunk_+3A_package">package</code></td>
<td>
<p>Name of the demo and the package. See
<code>utils::<a href="utils.html#topic+demo">demo</a></code>.</p>
</td></tr>
<tr><td><code id="read_chunk_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+read_chunk">read_chunk</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are two approaches to read external code into the current session: (1)
Use a special separator of the from <code>## ---- chunk-label</code> (at least four
dashes before the chunk label) in the script; (2) Manually specify the
labels, starting and ending positions of code chunks in the script.
</p>
<p>The second approach will be used only when <code>labels</code> is not <code>NULL</code>.
For this approach, if <code>from</code> is <code>NULL</code>, the starting position is 1;
if <code>to</code> is <code>NULL</code>, each of its element takes the next element of
<code>from</code> minus 1, and the last element of <code>to</code> will be the length of
<code>lines</code> (e.g. when <code>from = c(1, 3, 8)</code> and the script has 10 lines
in total, <code>to</code> will be <code>c(2, 7, 10)</code>). Alternatively, <code>from</code>
and <code>to</code> can be character vectors as regular expressions to specify the
positions; when their length is 1, the single regular expression will be
matched against the <code>lines</code> vector, otherwise each element of
<code>from</code>/<code>to</code> is matched against <code>lines</code> and the match is
supposed to be unique so that the numeric positions returned from
<code>grep()</code> will be of the same length of <code>from</code>/<code>to</code>. Note
<code>labels</code> always has to match the length of <code>from</code> and <code>to</code>.
</p>


<h3>Value</h3>

<p>As a side effect, code chunks are read into the current session so
that future chunks can (re)use the code by chunk label references. If an
external chunk has the same label as a chunk in the current session, chunk
label references by future chunks will refer to the external chunk.
</p>


<h3>Note</h3>

<p>This function can only be used in a chunk which is <em>not</em> cached
(chunk option <code>cache = FALSE</code>), and the code is read and stored in the
current session <em>without</em> being executed (to actually run the code,
you have to use a chunk with a corresponding label).
</p>


<h3>Author(s)</h3>

<p>Yihui Xie; the idea of the second approach came from Peter
Ruckdeschel (author of the <span class="pkg">SweaveListingUtils</span> package)
</p>


<h3>References</h3>

<p><a href="https://yihui.org/knitr/demo/externalization/">https://yihui.org/knitr/demo/externalization/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## put this in foo.R and read_chunk('foo.R')

## ---- my-label ----
1 + 1
lm(y ~ x, data = data.frame(x = 1:10, y = rnorm(10)))

## later you can use &lt;&lt;my-label&gt;&gt;= to reference this chunk

## the 2nd approach
code = c("#@a", "1+1", "#@b", "#@a", "rnorm(10)", "#@b")
read_chunk(lines = code, labels = "foo")  # put all code into one chunk named foo
read_chunk(lines = code, labels = "foo", from = 2, to = 2)  # line 2 into chunk foo
read_chunk(lines = code, labels = c("foo", "bar"), from = c(1, 4), to = c(3, 6))
# automatically figure out 'to'
read_chunk(lines = code, labels = c("foo", "bar"), from = c(1, 4))
read_chunk(lines = code, labels = c("foo", "bar"), from = "^#@a", to = "^#@b")
read_chunk(lines = code, labels = c("foo", "bar"), from = "^#@a", to = "^#@b",
    from.offset = 1, to.offset = -1)

## later you can use, e.g., &lt;&lt;foo&gt;&gt;=
knitr::knit_code$get()  # use this to check chunks in the current session
knitr::knit_code$restore()  # clean up the session
</code></pre>

<hr>
<h2 id='read_rforge'>Read source code from R-Forge</h2><span id='topic+read_rforge'></span>

<h3>Description</h3>

<p>This function reads source code from the SVN repositories on R-Forge.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_rforge(path, project, extra = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_rforge_+3A_path">path</code></td>
<td>
<p>Relative path to the source script on R-Forge.</p>
</td></tr>
<tr><td><code id="read_rforge_+3A_project">project</code></td>
<td>
<p>Name of the R-Forge project.</p>
</td></tr>
<tr><td><code id="read_rforge_+3A_extra">extra</code></td>
<td>
<p>Extra parameters to be passed to the URL (e.g. <code>extra =
'&amp;revision=48'</code> to check out the source of revision 48).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of the source code.
</p>


<h3>Author(s)</h3>

<p>Yihui Xie and Peter Ruckdeschel
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(knitr)
# relies on r-forge.r-project.org being accessible
read_rforge("rgl/R/axes.R", project = "rgl")
read_rforge("rgl/R/axes.R", project = "rgl", extra = "&amp;revision=519")

</code></pre>

<hr>
<h2 id='render_html'>Set or get output hooks for different output formats</h2><span id='topic+render_html'></span><span id='topic+hooks_html'></span><span id='topic+render_asciidoc'></span><span id='topic+hooks_asciidoc'></span><span id='topic+render_latex'></span><span id='topic+hooks_latex'></span><span id='topic+render_sweave'></span><span id='topic+hooks_sweave'></span><span id='topic+render_listings'></span><span id='topic+hooks_listings'></span><span id='topic+render_markdown'></span><span id='topic+hooks_markdown'></span><span id='topic+render_jekyll'></span><span id='topic+hooks_jekyll'></span><span id='topic+render_rst'></span><span id='topic+hooks_rst'></span><span id='topic+render_textile'></span><span id='topic+hooks_textile'></span>

<h3>Description</h3>

<p>The <code>render_*()</code> functions set built-in output hooks for LaTeX, HTML,
Markdown, reStructuredText, AsciiDoc, and Textile. The <code>hooks_*()</code>
functions return a list of the output hooks for the corresponding format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render_html()

hooks_html()

render_asciidoc()

hooks_asciidoc()

render_latex()

hooks_latex()

render_sweave()

hooks_sweave(envirs = c("Sinput", "Soutput", "Schunk"))

render_listings()

hooks_listings(envirs = c("Sinput", "Soutput", "Schunk"))

render_markdown(strict = FALSE, fence_char = "`")

hooks_markdown(strict = FALSE, fence_char = "`")

render_jekyll(highlight = c("pygments", "prettify", "none"), extra = "")

hooks_jekyll(highlight = c("pygments", "prettify", "none"), extra = "")

render_rst(strict = FALSE)

hooks_rst(strict = FALSE)

render_textile()

hooks_textile()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="render_html_+3A_envirs">envirs</code></td>
<td>
<p>Names of LaTeX environments for code input, output, and chunk.</p>
</td></tr>
<tr><td><code id="render_html_+3A_strict">strict</code></td>
<td>
<p>Boolean; whether to use strict markdown or reST syntax. For markdown, if
<code>TRUE</code>, code blocks will be indented by 4 spaces, otherwise they are
put in fences made by three backticks. For reST, if <code>TRUE</code>, code is
put under two colons and indented by 4 spaces, otherwise it is put under the
&lsquo;<span class="samp">&#8288;sourcecode&#8288;</span>&rsquo; directive (this is useful for e.g. Sphinx).</p>
</td></tr>
<tr><td><code id="render_html_+3A_fence_char">fence_char</code></td>
<td>
<p>A single character to be used in the code blocks fence.
This can be e.g. a backtick or a tilde, depending on your Markdown rendering
engine.</p>
</td></tr>
<tr><td><code id="render_html_+3A_highlight">highlight</code></td>
<td>
<p>Which code highlighting engine to use: if <code>pygments</code>,
the Liquid syntax is used (default approach Jekyll); if <code>prettify</code>,
the output is prepared for the JavaScript library &lsquo;<span class="file">prettify.js</span>&rsquo;; if
<code>none</code>, no highlighting engine will be used, and code blocks are simply
indented by 4 spaces).</p>
</td></tr>
<tr><td><code id="render_html_+3A_extra">extra</code></td>
<td>
<p>Extra tags for the highlighting engine. For <code>pygments</code>, this
can be <code>'linenos'</code>; for <code>prettify</code>, it can be <code>'linenums'</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are three variants of Markdown documents: ordinary Markdown
(<code>render_markdown(strict = TRUE)</code>, which calls
<code>hooks_markdown(strict = TRUE)</code>), extended Markdown (e.g., GitHub
Flavored Markdown and Pandoc; <code>render_markdown(strict = FALSE)</code>, which
calls <code>hooks_markdown(strict = FALSE)</code>), and Jekyll (a blogging system
on GitHub; <code>render_jekyll()</code>, which calls <code>hooks_jekyll()</code>).
</p>
<p>For LaTeX output, there are three variants: <span class="pkg">knitr</span>'s default style
(<code>render_latex()</code>, which calls <code>hooks_latex()</code> and uses the LaTeX
<span class="pkg">framed</span> package), Sweave style (<code>render_sweave()</code>, which calls
<code>hooks_sweave()</code> and uses &lsquo;<span class="file">Sweave.sty</span>&rsquo;), and listings style
(<code>render_listings()</code>, which calls <code>hooks_listings()</code> and uses LaTeX
<span class="pkg">listings</span> package).
</p>
<p>Default HTML output hooks are set by <code>render_html()</code> (which calls
<code>hooks_html()</code>); <code>render_rst()</code> (which calls <code>hooks_rst()</code>) is
for reStructuredText; <code>render_textile()</code> (which calls
<code>hooks_textile()</code>) is for Textile, and <code>render_asciidoc()</code> (which
calls <code>hooks_asciidoc()</code>) is AsciiDoc.
</p>
<p>The <code>render_*()</code> functions can be used before <code>knit()</code> or in the
first chunk of the input document (ideally this chunk has options
<code>include = FALSE</code> and <code>cache = FALSE</code>) so that all the following
chunks will be formatted as expected.
</p>
<p>You can also use <code><a href="#topic+knit_hooks">knit_hooks</a></code> to set the format's hooks with the
<code>hooks_*()</code> functions; see references for more info on further
customizing output hooks.
</p>


<h3>Value</h3>

<p><code>NULL</code> for <code>render_*</code> functions; corresponding hooks are
set as a side effect. A list of output hooks for <code>hooks_*()</code>
functions.
</p>


<h3>References</h3>

<p>See output hooks in <a href="https://yihui.org/knitr/hooks/">https://yihui.org/knitr/hooks/</a>, and
some examples in
<a href="https://bookdown.org/yihui/rmarkdown-cookbook/output-hooks.html">https://bookdown.org/yihui/rmarkdown-cookbook/output-hooks.html</a>
</p>
<p>Jekyll and Liquid:
<a href="https://github.com/jekyll/jekyll/wiki/Liquid-Extensions">https://github.com/jekyll/jekyll/wiki/Liquid-Extensions</a>; prettify.js:
<a href="https://code.google.com/archive/p/google-code-prettify">https://code.google.com/archive/p/google-code-prettify</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># below is pretty much what knitr::render_markdown() does:
knitr::knit_hooks$set(knitr::hooks_markdown())

# you can retrieve a subset of the hooks and set them, e.g.,
knitr::knit_hooks$set(knitr::hooks_markdown()["source"])

knitr::knit_hooks$restore()
</code></pre>

<hr>
<h2 id='rnw2pdf'>Convert an &lsquo;<span class="file">Rnw</span>&rsquo; document to PDF</h2><span id='topic+rnw2pdf'></span>

<h3>Description</h3>

<p>Call <code><a href="#topic+knit">knit</a>()</code> to compile the &lsquo;<span class="file">.Rnw</span>&rsquo; input to &lsquo;<span class="file">.tex</span>&rsquo;,
and then <code>tinytex::<a href="tinytex.html#topic+latexmk">latexmk</a>()</code> to convert &lsquo;<span class="file">.tex</span>&rsquo; to
&lsquo;<span class="file">.pdf</span>&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rnw2pdf(
  input,
  output = with_ext(input, "pdf"),
  compiler = "xelatex",
  envir = parent.frame(),
  quiet = FALSE,
  clean = TRUE,
  error = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rnw2pdf_+3A_input">input</code></td>
<td>
<p>Path to the input file.</p>
</td></tr>
<tr><td><code id="rnw2pdf_+3A_output">output</code></td>
<td>
<p>Path of the PDF output file. By default, it uses the same name
as the <code>input</code>, but changes the file extension to &quot;.pdf&quot;.</p>
</td></tr>
<tr><td><code id="rnw2pdf_+3A_compiler">compiler</code>, <code id="rnw2pdf_+3A_...">...</code></td>
<td>
<p>The LaTeX engine and other arguments to be passed to
<code>tinytex::<a href="tinytex.html#topic+latexmk">latexmk</a>()</code>. The default compiler is
<code>xelatex</code>.</p>
</td></tr>
<tr><td><code id="rnw2pdf_+3A_envir">envir</code></td>
<td>
<p>Environment in which code chunks are to be evaluated, for
example, <code><a href="base.html#topic+parent.frame">parent.frame</a>()</code>, <code><a href="base.html#topic+new.env">new.env</a>()</code>, or
<code><a href="base.html#topic+globalenv">globalenv</a>()</code>).</p>
</td></tr>
<tr><td><code id="rnw2pdf_+3A_quiet">quiet</code></td>
<td>
<p>Boolean; suppress the progress bar and messages?</p>
</td></tr>
<tr><td><code id="rnw2pdf_+3A_clean">clean</code></td>
<td>
<p>If <code>TRUE</code>, the intermediate files will be removed.</p>
</td></tr>
<tr><td><code id="rnw2pdf_+3A_error">error</code></td>
<td>
<p>If <code>FALSE</code>, knitting stops when any error occurs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is similar to <code><a href="#topic+knit2pdf">knit2pdf</a>()</code>, with the following differences:
</p>

<ol>
<li><p> The default compiler is &quot;xelatex&quot; instead of &quot;pdflatex&quot;.
</p>
</li>
<li> <p><code>output</code> uses the file extension &quot;.pdf&quot; instead of &quot;.tex&quot;.
</p>
</li>
<li><p> Before knitting, it tries to remove the <code>output</code> file and will throw a clear error if the file cannot be removed.
</p>
</li>
<li> <p><code>output</code> could be under any dir, not necessarily the same directory as <code>input</code>.
</p>
</li>
<li><p> It cleans up intermediate files by default, including the &quot;.tex&quot; file.
</p>
</li>
<li><p> It stops knitting when any error occurs (by setting the chunk option <code>error = FALSE</code>).
</p>
</li></ol>



<h3>Value</h3>

<p>The <code>output</code> file path.
</p>

<hr>
<h2 id='rocco'>Knit R Markdown using the classic Docco style</h2><span id='topic+rocco'></span>

<h3>Description</h3>

<p>The classic Docco style is a two-column layout, with text in the left and
code in the right column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rocco(input, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rocco_+3A_input">input</code></td>
<td>
<p>Path of the input R Markdown file.</p>
</td></tr>
<tr><td><code id="rocco_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="#topic+knit2html">knit2html</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output HTML page supports resizing and hiding/showing the two columns.
Move the cursor to the center of the page, and it will change to a
bidirectional resize cursor; drag the cursor to resize the two columns. Press
the key <code>t</code> to hide the code column (show the text column only), and
press again to hide the text column (show code).
</p>


<h3>Value</h3>

<p>An HTML file is written, and its name is returned.
</p>


<h3>Author(s)</h3>

<p>Weicheng Zhu and Yihui Xie
</p>


<h3>References</h3>

<p>The Docco package by Jeremy Ashkenas:
<a href="https://github.com/jashkenas/docco">https://github.com/jashkenas/docco</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rocco_view = function(input) {
    owd = setwd(tempdir())
    on.exit(setwd(owd))
    if (!file.exists(input))
        return()
    o = rocco(input, quiet = TRUE)
    if (interactive())
        browseURL(o)
}
# knit these two vignettes using the docco style
rocco_view(system.file("doc", "docco-classic.Rmd", package = "knitr"))
rocco_view(system.file("doc", "knit_expand.Rmd", package = "knitr"))
</code></pre>

<hr>
<h2 id='rst2pdf'>A wrapper for rst2pdf</h2><span id='topic+rst2pdf'></span>

<h3>Description</h3>

<p>Convert reST to PDF using <code>rst2pdf</code> (which converts from rst to PDF
using the ReportLab open-source library).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rst2pdf(input, command = "rst2pdf", options = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rst2pdf_+3A_input">input</code></td>
<td>
<p>The input rst file.</p>
</td></tr>
<tr><td><code id="rst2pdf_+3A_command">command</code></td>
<td>
<p>Character string giving the path of the
<code>rst2pdf</code> program. If the program is not in your PATH, the full path has to be
given here.</p>
</td></tr>
<tr><td><code id="rst2pdf_+3A_options">options</code></td>
<td>
<p>Extra command line options, e.g. <code>'-v'</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An input file &lsquo;<span class="file">*.rst</span>&rsquo; will produce &lsquo;<span class="file">*.pdf</span>&rsquo; and this output
filename is returned if the conversion was successful.
</p>


<h3>Author(s)</h3>

<p>Alex Zvoleff and Yihui Xie
</p>


<h3>References</h3>

<p><a href="https://github.com/rst2pdf/rst2pdf">https://github.com/rst2pdf/rst2pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+knit2pdf">knit2pdf</a></code>
</p>

<hr>
<h2 id='set_alias'>Set aliases for chunk options</h2><span id='topic+set_alias'></span>

<h3>Description</h3>

<p>We do not have to use the chunk option names given in <span class="pkg">knitr</span>; we can set
aliases for them. The aliases are a named character vector; the names are
aliases and the elements in this vector are the real option names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_alias(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_alias_+3A_...">...</code></td>
<td>
<p>Named arguments. Argument names are aliases, and argument values
are real option names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>. <code>opts_knit$get('aliases')</code> is modified as the side effect.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set_alias(w = "fig.width", h = "fig.height")
# then we can use options w and h in chunk headers instead of fig.width and
# fig.height
</code></pre>

<hr>
<h2 id='set_header'>Set the header information</h2><span id='topic+set_header'></span>

<h3>Description</h3>

<p>Some output documents may need appropriate header information. For example,
for LaTeX output, we need to write &lsquo;<span class="samp">&#8288;\usepackage{tikz}&#8288;</span>&rsquo; into the
preamble if we use tikz graphics; this function sets the header information
to be written into the output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_header(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_header_+3A_...">...</code></td>
<td>
<p>Header components; currently possible components are
<code>highlight</code>, <code>tikz</code> and <code>framed</code>, which contain the
necessary commands to be used in the HTML header or LaTeX preamble. Note that
HTML output does not use the <code>tikz</code> and <code>framed</code> components, since
they do not make sense in the context of HTML.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, <span class="pkg">knitr</span> will set up the header automatically. For example, if
the tikz device is used, <span class="pkg">knitr</span> will add &lsquo;<span class="samp">&#8288;\usepackage{tikz}&#8288;</span>&rsquo; to
the LaTeX preamble, and this is done by setting the header component
<code>tikz</code> to be a character string: <code>set_header(tikz =
'\usepackage{tikz}')</code>. Similary, when we highlight R code using the
<span class="pkg">highlight</span> package (i.e. the chunk option <code>highlight = TRUE</code>),
<span class="pkg">knitr</span> will set the <code>highlight</code> component of the header vector
automatically; if the output type is HTML, this component will be different
&ndash; instead of LaTeX commands, it contains CSS definitions.
</p>
<p>For power users, all the components can be modified to adapt to a customized
type of output. For instance, we can change <code>highlight</code> to LaTeX
definitions of the <span class="pkg">listings</span> package (and modify the output hooks
accordingly), so we can decorate R code using the <span class="pkg">listings</span> package.
</p>


<h3>Value</h3>

<p>The header vector in <code>opts_knit</code> is set.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set_header(tikz = "\\usepackage{tikz}")
opts_knit$get("header")
</code></pre>

<hr>
<h2 id='set_parent'>Specify the parent document of child documents</h2><span id='topic+set_parent'></span>

<h3>Description</h3>

<p>This function extracts the LaTeX preamble of the parent document to use for
the child document, so that the child document can be compiled as an
individual document.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_parent(parent)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_parent_+3A_parent">parent</code></td>
<td>
<p>Path to the parent document, relative to the current child
document.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the preamble of the parent document also contains code chunks and inline
R code, they will be evaluated as if they were in this child document. For
examples, when <span class="pkg">knitr</span> hooks or other options are set in the preamble of
the parent document, it will apply to the child document as well.
</p>


<h3>Value</h3>

<p>The preamble is extracted and stored to be used later when the
complete output is written.
</p>


<h3>Note</h3>

<p>Obviously this function is only useful when the output format is LaTeX.
This function only works when the child document is compiled in a
standalone mode using <code><a href="#topic+knit">knit</a>()</code> (instead of being called in
<code><a href="#topic+knit_child">knit_child</a>()</code>); when the parent document is compiled, this
function in the child document will be ignored.
</p>


<h3>References</h3>

<p><a href="https://yihui.org/knitr/demo/child/">https://yihui.org/knitr/demo/child/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## can use, e.g. \Sexpr{set_parent('parent_doc.Rnw')} or

# &lt;&lt;setup-child, include=FALSE&gt;&gt;=

# set_parent('parent_doc.Rnw')

# @
</code></pre>

<hr>
<h2 id='sew'>Wrap evaluated results for output</h2><span id='topic+sew'></span>

<h3>Description</h3>

<p>This function is mainly for internal use: it is called on each part of the
output of the code chunk (code, messages, text output, and plots, etc.) after
all statements in the code chunk have been evaluated, and will sew these
pieces of output together into a character vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sew(x, options = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sew_+3A_x">x</code></td>
<td>
<p>Output from <code>evaluate::<a href="evaluate.html#topic+evaluate">evaluate</a>()</code>.</p>
</td></tr>
<tr><td><code id="sew_+3A_options">options</code></td>
<td>
<p>A list of chunk options used to control output.</p>
</td></tr>
<tr><td><code id="sew_+3A_...">...</code></td>
<td>
<p>Other arguments to pass to methods.</p>
</td></tr>
</table>

<hr>
<h2 id='spin'>Spin goat's hair into wool</h2><span id='topic+spin'></span>

<h3>Description</h3>

<p>This function takes a specially formatted R script and converts it to a
literate programming document. By default normal text (documentation) should
be written after the roxygen comment (<code>#'</code>) and code chunk options are
written after <code>#+</code> or <code>#-</code> or <code># ----</code> or any of these
combinations replacing <code>#</code> with <code>--</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spin(
  hair,
  knit = TRUE,
  report = TRUE,
  text = NULL,
  envir = parent.frame(),
  format = c("Rmd", "Rnw", "Rhtml", "Rtex", "Rrst", "qmd"),
  doc = "^#+'[ ]?",
  inline = "^[{][{](.+)[}][}][ ]*$",
  comment = c("^[# ]*/[*]", "^.*[*]/ *$"),
  precious = !knit &amp;&amp; is.null(text)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spin_+3A_hair">hair</code></td>
<td>
<p>Path to the R script. The script must be encoded in UTF-8 if it
contains multibyte characters.</p>
</td></tr>
<tr><td><code id="spin_+3A_knit">knit</code></td>
<td>
<p>Logical; whether to compile the document after conversion.</p>
</td></tr>
<tr><td><code id="spin_+3A_report">report</code></td>
<td>
<p>Logical; whether to generate a report for &lsquo;<span class="file">Rmd</span>&rsquo;,
&lsquo;<span class="file">Rnw</span>&rsquo; and &lsquo;<span class="file">Rtex</span>&rsquo; output. Ignored if <code>knit = FALSE</code>.</p>
</td></tr>
<tr><td><code id="spin_+3A_text">text</code></td>
<td>
<p>A character vector of code, as an alternative way to provide the
R source. If <code>text</code> is not <code>NULL</code>, <code>hair</code> will be ignored.</p>
</td></tr>
<tr><td><code id="spin_+3A_envir">envir</code></td>
<td>
<p>Environment for <code><a href="#topic+knit">knit</a>()</code> to evaluate the code.</p>
</td></tr>
<tr><td><code id="spin_+3A_format">format</code></td>
<td>
<p>Character; the output format. The default is R Markdown.</p>
</td></tr>
<tr><td><code id="spin_+3A_doc">doc</code></td>
<td>
<p>A regular expression to identify the documentation lines; by
default it follows the roxygen convention, but it can be customized, e.g.
if you want to use <code>##</code> to denote documentation, you can use
<code>'^##\\s*'</code>.</p>
</td></tr>
<tr><td><code id="spin_+3A_inline">inline</code></td>
<td>
<p>A regular expression to identify inline R expressions; by
default, code of the form <code>{{code}}</code> on its own line is treated as
an inline expression.</p>
</td></tr>
<tr><td><code id="spin_+3A_comment">comment</code></td>
<td>
<p>A pair of regular expressions for the start and end delimiters
of comments; the lines between a start and an end delimiter will be
ignored. By default, the delimiters are <code style="white-space: pre;">&#8288;/*&#8288;</code> at the beginning of a
line, and <code style="white-space: pre;">&#8288;*/&#8288;</code> at the end, following the convention of C comments.</p>
</td></tr>
<tr><td><code id="spin_+3A_precious">precious</code></td>
<td>
<p>logical: whether intermediate files (e.g., <code>.Rmd</code> files
when <code>format</code> is <code>"Rmd"</code>) should be preserved. The default is
<code>FALSE</code> if <code>knit</code> is <code>TRUE</code> and the input is a file.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Obviously the goat's hair is the original R script, and the wool is the
literate programming document (ready to be knitted).
</p>


<h3>Value</h3>

<p>If <code>text</code> is <code>NULL</code>, the path of the final output document,
otherwise the content of the output.
</p>


<h3>Note</h3>

<p>If the output format is <code>Rnw</code> and no document class is specified
in roxygen comments, this function will automatically add the
<code>article</code> class to the LaTeX document so that it is complete and can
be compiled. You can always specify the document class and other LaTeX
settings in roxygen comments manually.
</p>
<p>When the output format is <code>Rmd</code>, it is compiled to HTML via
<code><a href="#topic+knit2html">knit2html</a>()</code>, which uses R Markdown v1 instead of v2. If you
want to use the latter, you should call
<code>rmarkdown::<a href="rmarkdown.html#topic+render">render</a>()</code> instead. Similarly, if the
output format is <code>qmd</code>, you need to render the output with Quarto.
</p>


<h3>Author(s)</h3>

<p>Yihui Xie, with the original idea from Richard FitzJohn (who named it
as <code>sowsear()</code> which meant to make a silk purse out of a sow's ear)
</p>


<h3>References</h3>

<p><a href="https://yihui.org/knitr/demo/stitch/">https://yihui.org/knitr/demo/stitch/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stitch">stitch</a></code> (feed a template with an R script)
</p>

<hr>
<h2 id='spin_child'>Spin a child R script</h2><span id='topic+spin_child'></span>

<h3>Description</h3>

<p>This function is similar to <code><a href="#topic+knit_child">knit_child</a>()</code> but is used in R
scripts instead. When the main R script is not called via
<code><a href="#topic+spin">spin</a>()</code>, this function simply executes the child script via
<code><a href="base.html#topic+sys.source">sys.source</a>()</code>, otherwise it calls <code><a href="#topic+spin">spin</a>()</code> to spin
the child script into a source document, and uses <code><a href="#topic+knit_child">knit_child</a>()</code>
to compile it. You can call this function in R code, or using the syntax of
inline R expressions in <code><a href="#topic+spin">spin</a>()</code> (e.g.
<code>{{knitr::spin_child('script.R')}}</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spin_child(input, format)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spin_child_+3A_input">input</code></td>
<td>
<p>Filename of the input R script.</p>
</td></tr>
<tr><td><code id="spin_child_+3A_format">format</code></td>
<td>
<p>Passed to <code>format</code> in <code>spin()</code>. If not
provided, it will be guessed from the current knitting process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string of the knitted R script.
</p>

<hr>
<h2 id='stitch'>Automatically create a report based on an R script and a template</h2><span id='topic+stitch'></span><span id='topic+stitch_rhtml'></span><span id='topic+stitch_rmd'></span>

<h3>Description</h3>

<p>This is a convenience function for small-scale automatic reporting based on
an R script and a template. The default template is an Rnw file (LaTeX);
<code>stitch_rhtml()</code> and <code>stitch_rmd()</code> are wrappers on top of
<code>stitch()</code> using the R HTML and R Markdown templates respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stitch(
  script,
  template = system.file("misc", "knitr-template.Rnw", package = "knitr"),
  output = NULL,
  text = NULL,
  envir = parent.frame()
)

stitch_rhtml(..., envir = parent.frame())

stitch_rmd(..., envir = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stitch_+3A_script">script</code></td>
<td>
<p>Path to the R script.</p>
</td></tr>
<tr><td><code id="stitch_+3A_template">template</code></td>
<td>
<p>Path of the template to use. By default, the Rnw template in
this package; there is also an HTML template in <span class="pkg">knitr</span>.</p>
</td></tr>
<tr><td><code id="stitch_+3A_output">output</code></td>
<td>
<p>Output filename, passed to <code><a href="#topic+knit">knit</a></code>). By default,
the base filename of the script is used.</p>
</td></tr>
<tr><td><code id="stitch_+3A_text">text</code></td>
<td>
<p>A character vector. This is an alternative way to provide the
input file.</p>
</td></tr>
<tr><td><code id="stitch_+3A_envir">envir</code></td>
<td>
<p>Environment in which code chunks are to be evaluated, for
example, <code><a href="base.html#topic+parent.frame">parent.frame</a>()</code>, <code><a href="base.html#topic+new.env">new.env</a>()</code>, or
<code><a href="base.html#topic+globalenv">globalenv</a>()</code>).</p>
</td></tr>
<tr><td><code id="stitch_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>stitch()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first two lines of the R script can contain the title and author of the
report in comments of the form &lsquo;<span class="samp">&#8288;## title:&#8288;</span>&rsquo; and &lsquo;<span class="samp">&#8288;## author:&#8288;</span>&rsquo;. The
template must have a token &lsquo;<span class="samp">&#8288;%sCHUNK_LABEL_HERE&#8288;</span>&rsquo;, which will be used to
input all the R code from the script. See the examples below.
</p>
<p>The R script may contain chunk headers of the form &lsquo;<span class="samp">&#8288;## ---- label,
opt1=val1, opt2=val2&#8288;</span>&rsquo;, which will be copied to the template; if no chunk
headers are found, the whole R script will be inserted into the template as
one code chunk.
</p>


<h3>Value</h3>

<p>path of the output document
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spin">spin</a></code> (turn a specially formatted R script to a report)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s = system.file("misc", "stitch-test.R", package = "knitr")
if (interactive()) stitch(s)  # compile to PDF

# HTML report
stitch(s, system.file("misc", "knitr-template.Rhtml", package = "knitr"))

# or convert markdown to HTML
stitch(s, system.file("misc", "knitr-template.Rmd", package = "knitr"))

unlink(c("stitch-test.html", "stitch-test.md", "figure"), recursive = TRUE)
</code></pre>

<hr>
<h2 id='Sweave2knitr'>Convert Sweave to knitr documents</h2><span id='topic+Sweave2knitr'></span>

<h3>Description</h3>

<p>This function converts an Sweave document to a <span class="pkg">knitr</span>-compatible
document.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Sweave2knitr(
  file,
  output = gsub("[.]([^.]+)$", "-knitr.\\1", file),
  text = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Sweave2knitr_+3A_file">file</code></td>
<td>
<p>Path to the Rnw file (must be encoded in UTF-8).</p>
</td></tr>
<tr><td><code id="Sweave2knitr_+3A_output">output</code></td>
<td>
<p>Output file path. By default, &lsquo;<span class="file">file.Rnw</span>&rsquo; produces
&lsquo;<span class="file">file-knitr.Rnw</span>&rsquo;); if <code>text</code> is not NULL, no output file will be
produced.</p>
</td></tr>
<tr><td><code id="Sweave2knitr_+3A_text">text</code></td>
<td>
<p>An alternative way to provide the Sweave code as a character
string. If <code>text</code> is provided, <code>file</code> will be ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The pseudo command &lsquo;<span class="samp">&#8288;\SweaveInput{file.Rnw}&#8288;</span>&rsquo; is converted to a code
chunk header <code>&lt;&lt;child='file.Rnw'&gt;&gt;=</code>.
</p>
<p>Similarly &lsquo;<span class="samp">&#8288;\SweaveOpts{opt = value}&#8288;</span>&rsquo; is converted to a code chunk
&lsquo;<span class="samp">&#8288;opts_chunk$set(opt = value)&#8288;</span>&rsquo; with the chunk option <code>include =
FALSE</code>; the options are automatically fixed in the same way as local chunk
options (explained below).
</p>
<p>The Sweave package &lsquo;<span class="samp">&#8288;\usepackage{Sweave}&#8288;</span>&rsquo; in the preamble is removed
because it is not required.
</p>
<p>Chunk options are updated if necessary: option values <code>true</code> and
<code>false</code> are changed to <code>TRUE</code> and <code>FALSE</code> respectively;
<code>fig=TRUE</code> is removed because it is not necessary for <span class="pkg">knitr</span> (plots
will be automatically generated); <code>fig=FALSE</code> is changed to
<code>fig.keep='none'</code>; the devices <code>pdf/jpeg/png/eps/tikz=TRUE</code> are
converted to <code>dev='pdf'/'jpeg'/'png'/'postscript'/'tikz'</code>;
<code>pdf/jpeg/png/eps/tikz=FALSE</code> are removed;
<code>results=tex/verbatim/hide</code> are changed to
<code>results='asis'/'markup'/'hide'</code>; <code>width/height</code> are changed to
<code>fig.width/fig.height</code>; <code>prefix.string</code> is changed to
<code>fig.path</code>; <code>print/term/prefix=TRUE/FALSE</code> are removed; most of the
character options (e.g. <code>engine</code> and <code>out.width</code>) are quoted;
<code>keep.source=TRUE/FALSE</code> is changed to <code>tidy=FALSE/TRUE</code> (note the
order of values).
</p>
<p>If a line <code>@</code> (it closes a chunk) directly follows a previous
<code>@</code>, it is removed; if a line <code>@</code> appears before a code chunk and
no chunk is before it, it is also removed, because <span class="pkg">knitr</span> only uses one
&lsquo;<span class="samp">&#8288;@&#8288;</span>&rsquo; after &lsquo;<span class="samp">&#8288;&lt;&lt;&gt;&gt;=&#8288;</span>&rsquo; by default (which is not the original Noweb
syntax but more natural).
</p>


<h3>Value</h3>

<p>If <code>text</code> is <code>NULL</code>, the <code>output</code> file is written and
<code>NULL</code> is returned. Otherwise, the converted text string is returned.
</p>


<h3>Note</h3>

<p>If &lsquo;<span class="samp">&#8288;\SweaveOpts{}&#8288;</span>&rsquo; spans across multiple lines, it will not be
fixed, and you have to fix it manually. The LaTeX-style syntax of Sweave
chunks are ignored (see <code>?SweaveSyntaxLatex</code>); only the Noweb syntax
is supported.
</p>


<h3>References</h3>

<p>The motivation of the changes in the syntax:
<a href="https://yihui.org/knitr/demo/sweave/">https://yihui.org/knitr/demo/sweave/</a>
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+Sweave">Sweave</a></code>, <code><a href="base.html#topic+gsub">gsub</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Sweave2knitr(text = "&lt;&lt;echo=TRUE&gt;&gt;=")  # this is valid
Sweave2knitr(text = "&lt;&lt;png=true&gt;&gt;=")  # dev='png'
Sweave2knitr(text = "&lt;&lt;eps=TRUE, pdf=FALSE, results=tex, width=5, prefix.string=foo&gt;&gt;=")
Sweave2knitr(text = "&lt;&lt;,png=false,fig=TRUE&gt;&gt;=")
Sweave2knitr(text = "\\SweaveOpts{echo=false}")
Sweave2knitr(text = "\\SweaveInput{hello.Rnw}")
# Sweave example in utils
testfile = system.file("Sweave", "Sweave-test-1.Rnw", package = "utils")
Sweave2knitr(testfile, output = "Sweave-test-knitr.Rnw")
if (interactive()) knit("Sweave-test-knitr.Rnw")  # or knit2pdf() directly
unlink("Sweave-test-knitr.Rnw")
</code></pre>

<hr>
<h2 id='vignette_engines'>Package vignette engines</h2><span id='topic+vignette_engines'></span>

<h3>Description</h3>

<p>Since R 3.0.0, package vignettes can use non-Sweave engines, and <span class="pkg">knitr</span>
has provided a few engines to compile vignettes via <code><a href="#topic+knit">knit</a>()</code> with
different templates. See <a href="https://yihui.org/knitr/demo/vignette/">https://yihui.org/knitr/demo/vignette/</a> for
more information.
</p>


<h3>Note</h3>

<p>If you use the <code>knitr::rmarkdown</code> engine, please make sure that
you put <span class="pkg">rmarkdown</span> in the &lsquo;<span class="samp">&#8288;Suggests&#8288;</span>&rsquo; field of your
&lsquo;<span class="file">DESCRIPTION</span>&rsquo; file. Also make sure <code>pandoc</code> is available
during <code>R CMD build</code>. If you build your package from RStudio, this
is normally not a problem. If you build the package outside RStudio, run
<code>rmarkdown::find_pandoc()</code> in an R session to check if Pandoc can be
found.
</p>
<p>When the <span class="pkg">rmarkdown</span> package is not installed or not available, or
<code>pandoc</code> cannot be found, the <code>knitr::rmarkdown</code> engine will
fall back to the <code>knitr::knitr</code> engine, which uses R Markdown v1 based
on the <span class="pkg">markdown</span> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(knitr)
vig_list = tools::vignetteEngine(package = "knitr")
str(vig_list)
vig_list[["knitr::knitr"]][c("weave", "tangle")]
vig_list[["knitr::knitr_notangle"]][c("weave", "tangle")]
vig_list[["knitr::docco_classic"]][c("weave", "tangle")]
</code></pre>

<hr>
<h2 id='wrap_rmd'>Wrap long lines in Rmd files</h2><span id='topic+wrap_rmd'></span>

<h3>Description</h3>

<p>This function wraps long paragraphs in an R Markdown file. Other elements are
not wrapped: the YAML preamble, fenced code blocks, section headers and
indented elements. The main reason for wrapping long lines is to make it
easier to review differences in version control.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wrap_rmd(file, width = 80, text = NULL, backup)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wrap_rmd_+3A_file">file</code></td>
<td>
<p>The input Rmd file.</p>
</td></tr>
<tr><td><code id="wrap_rmd_+3A_width">width</code></td>
<td>
<p>The expected line width.</p>
</td></tr>
<tr><td><code id="wrap_rmd_+3A_text">text</code></td>
<td>
<p>A character vector of text lines, as an alternative to <code>file</code>. If
<code>text</code> is not <code>NULL</code>, <code>file</code> is ignored.</p>
</td></tr>
<tr><td><code id="wrap_rmd_+3A_backup">backup</code></td>
<td>
<p>Path to back up the original file in case anything goes
wrong. If set to <code>NULL</code>, no backup is made. The default value is constructed
from <code>file</code> by adding <code>__</code> before the base filename.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>file</code> is provided, it is overwritten; if <code>text</code> is
provided, a character vector is returned.
</p>


<h3>Note</h3>

<p>Currently it does not wrap blockquotes or lists (ordered or unordered).
This feature may or may not be added in the future.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wrap_rmd(text = c("```", "1+1", "```", "- a list item", "&gt; a quote", "",
    paste(rep("this is a normal paragraph", 5), collapse = " ")))
</code></pre>

<hr>
<h2 id='write_bib'>Generate BibTeX bibliography databases for R packages</h2><span id='topic+write_bib'></span>

<h3>Description</h3>

<p>This function uses <code>utils::<a href="utils.html#topic+citation">citation</a>()</code> and
<code>utils::<a href="utils.html#topic+toBibtex">toBibtex</a>()</code> to create bib entries for R packages and
write them in a file. It can facilitate the auto-generation of bibliography
databases for R packages, and it is easy to regenerate all the citations
after updating R packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_bib(
  x = .packages(),
  file = "",
  tweak = TRUE,
  width = NULL,
  prefix = getOption("knitr.bib.prefix", "R-"),
  lib.loc = NULL,
  packageURL = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_bib_+3A_x">x</code></td>
<td>
<p>Package names. Packages which are not installed are ignored.</p>
</td></tr>
<tr><td><code id="write_bib_+3A_file">file</code></td>
<td>
<p>The (&lsquo;<span class="file">.bib</span>&rsquo;) file to write. By default, or if <code>NULL</code>,
output is written to the R console.</p>
</td></tr>
<tr><td><code id="write_bib_+3A_tweak">tweak</code></td>
<td>
<p>Whether to fix some known problems in the citations, especially
non-standard format of author names.</p>
</td></tr>
<tr><td><code id="write_bib_+3A_width">width</code></td>
<td>
<p>Width of lines in bibliography entries. If <code>NULL</code>, lines
will not be wrapped.</p>
</td></tr>
<tr><td><code id="write_bib_+3A_prefix">prefix</code></td>
<td>
<p>Prefix string for keys in BibTeX entries; by default, it is
&lsquo;<span class="samp">&#8288;R-&#8288;</span>&rsquo; unless <code><a href="base.html#topic+option">option</a>('knitr.bib.prefix')</code> has been set to
another string.</p>
</td></tr>
<tr><td><code id="write_bib_+3A_lib.loc">lib.loc</code></td>
<td>
<p>A vector of path names of R libraries.</p>
</td></tr>
<tr><td><code id="write_bib_+3A_packageurl">packageURL</code></td>
<td>
<p>Use the <code>URL</code> field from the &lsquo;<span class="file">DESCRIPTION</span>&rsquo; file.
See Details below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a package, the keyword &lsquo;<span class="samp">&#8288;R-pkgname&#8288;</span>&rsquo; is used for its bib item, where
&lsquo;<span class="samp">&#8288;pkgname&#8288;</span>&rsquo; is the name of the package. Citation entries specified in the
&lsquo;<span class="file">CITATION</span>&rsquo; file of the package are also included. The main purpose of
this function is to automate the generation of the package citation
information because it often changes (e.g. author, year, package version,
...).
</p>
<p>There are at least two different uses for the URL in a reference list.  You
might want to tell users where to go for more information; in that case, use
the default <code>packageURL = TRUE</code>, and the first URL listed in the
&lsquo;<span class="file">DESCRIPTION</span>&rsquo; file will be used. Be careful:  some authors don't put the
most relevant URL first. Alternatively, you might want to identify exactly
which version of the package was used in the document.  If it was installed
from CRAN or some other repositories, the version number identifies it, and
<code>packageURL = FALSE</code> will use the repository URL (as used by
<code>utils::<a href="utils.html#topic+citation">citation</a>()</code>).
</p>


<h3>Value</h3>

<p>A list containing the citations. Citations are also written to the
<code>file</code> as a side effect.
</p>


<h3>Note</h3>

<p>Some packages on CRAN do not have standard bib entries, which was once
reported by Michael Friendly at
<a href="https://stat.ethz.ch/pipermail/r-devel/2010-November/058977.html">https://stat.ethz.ch/pipermail/r-devel/2010-November/058977.html</a>. I
find this a real pain, and there are no easy solutions except contacting
package authors to modify their DESCRIPTION files. Anyway, the argument
<code>tweak</code> has provided ugly hacks to deal with packages which are known
to be non-standard in terms of the format of citations; <code>tweak = TRUE</code>
is by no means intended to hide or modify the original citation
information. It is just due to the loose requirements on package authors
for the DESCRIPTION file. On one hand, I apologize if it really mangles the
information about certain packages; on the other, I strongly recommend
package authors to consider the &lsquo;<span class="samp">&#8288;Authors@R&#8288;</span>&rsquo; field (see the manual
<em>Writing R Extensions</em>) to make it easier for other people to cite R
packages. See <code>knitr:::.tweak.bib</code> for details of tweaks. Also note
this is subject to future changes since R packages are being updated. If
you want to contribute more tweaks, please edit the file
&lsquo;<span class="file">inst/misc/tweak_bib.csv</span>&rsquo; in the source package.
</p>


<h3>Author(s)</h3>

<p>Yihui Xie and Michael Friendly
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
write_bib(c("RGtk2", "gWidgets"), file = "R-GUI-pkgs.bib")
unlink("R-GUI-pkgs.bib")

write_bib(c("animation", "rgl", "knitr", "ggplot2"))
write_bib(c("base", "parallel", "MASS"))  # base and parallel are identical
write_bib("cluster", prefix = "")  # a empty prefix
write_bib("digest", prefix = "R-pkg-")  # a new prefix
write_bib("digest", tweak = FALSE)  # original version

# what tweak=TRUE does
str(knitr:::.tweak.bib)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
