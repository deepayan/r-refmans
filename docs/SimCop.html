<!DOCTYPE html><html lang="en"><head><title>Help for package SimCop</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SimCop}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#SimCop'><p>SimCop: A package to simulate random variates from an arbitrary multivariate copula</p></a></li>
<li><a href='#CrossSum'><p>Calculations on cubes</p></a></li>
<li><a href='#GenerateRV'><p>GenerateRV generic</p></a></li>
<li><a href='#GenerateRV.CopApprox'><p>Generates random variates from a copula approximation</p></a></li>
<li><a href='#GetApprox'><p>Approximate a copula by a histogram density</p></a></li>
<li><a href='#MaxTemp'><p>Extreme temperatures at two West Australian meteorological stations</p></a></li>
<li><a href='#NewBEVAsyLogisticCopula'><p>Creates a bivariate asymmetric logistic model extreme value copula</p></a></li>
<li><a href='#NewBEVAsyMixedModelCopula'><p>Creates a bivariate asymmetric mixed model extreme value copula</p></a></li>
<li><a href='#NewBEVLogisticCopula'><p>Creates a bivariate logistic model extreme value copula</p></a></li>
<li><a href='#NewBEVMixedModelCopula'><p>Creates a bivariate mixed model extreme value copula</p></a></li>
<li><a href='#NewBEVSplineCopula'><p>Creates a flexible extreme value copula</p></a></li>
<li><a href='#NewCube'><p>Cross-derivatives via automatic differentiation</p></a></li>
<li><a href='#NewMEVAsyLogisticCopula'><p>Creates a multivariate asymmetric logistic copula</p></a></li>
<li><a href='#NewMEVGumbelCopula'><p>Creates a Gumpel copula</p></a></li>
<li><a href='#NewMVClaytonCopula'><p>Creates a Clayton copula</p></a></li>
<li><a href='#NewMVFrankCopula'><p>Creates a Frank copula</p></a></li>
<li><a href='#NonparEstDepFct'><p>Nonparametric estimator of bivariate dependence function</p></a></li>
<li><a href='#plot.CopApprox'><p>Plot the histogram density approximation to a copula</p></a></li>
<li><a href='#print.ADCube'><p>Print method for cubes</p></a></li>
<li><a href='#print.SimCop'><p>Print basic information on a copula</p></a></li>
<li><a href='#SplineFitDepFct'><p>Fit a dependence function by spline smoothing</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Simulate from Arbitrary Copulae</td>
</tr>
<tr>
<td>Version:</td>
<td>0.7.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2017-12-16</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a framework to generating random variates from
             arbitrary multivariate copulae, while concentrating on
             (bivariate) extreme value copulae.  Particularly useful if
             the multivariate copulae are not available in closed
             form.   </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>grDevices, graphics, quadprog, stats</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-12-16 08:32:11 UTC; berwin</td>
</tr>
<tr>
<td>Author:</td>
<td>Berwin A. Turlach [aut, cre],
  Nader Tajvidi [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Berwin A. Turlach &lt;Berwin.Turlach@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-12-20 12:07:17 UTC</td>
</tr>
</table>
<hr>
<h2 id='SimCop'>SimCop: A package to simulate random variates from an arbitrary multivariate copula</h2><span id='topic+SimCop'></span><span id='topic+SimCop-package'></span>

<h3>Description</h3>

<p>R code to support Tajvidi and Turlach (2017).  The main functions implemented for the SimCop package are:
</p>

<ul>
<li><p><code>New*Copula</code>, various functions that create objects of <code><a href="base.html#topic+class">class</a></code> &lsquo;SimCop&rsquo;. These functions return a copula function with various helpful information stored in the environment of the function.
</p>
<p>Details of the implementation are subject to change and should not be relied on.
</p>
<p>Only a  <code><a href="base.html#topic+print">print</a></code> method is implemented for this class so far.
</p>
</li>
<li><p><code>GetApprox</code>, a function that calculates approximations to a copula and returns an object of <code><a href="base.html#topic+class">class</a></code> &lsquo;CopApprox&rsquo;.
</p>
<p>For bivariate copulae a method for <code><a href="base.html#topic+plot">plot</a></code> is implemented for this class.
</p>
</li>
<li><p><code>GenerateRV</code>, a generic function that generates random variates from an object, together with a method for objects of class &lsquo;CopApprox&rsquo;.
</p>
</li></ul>



<h3>References</h3>

<p>Tajvidi, N. and Turlach, B.A. (2017). A general approach to generate random variates for multivariate copulae, <em>Australian &amp; New Zealand Journal of Statistics</em>. Doi:10.1111/anzs.12209.
</p>

<hr>
<h2 id='CrossSum'>Calculations on cubes</h2><span id='topic+CrossSum'></span><span id='topic+CrossMult'></span><span id='topic+CrossDivide'></span><span id='topic+CrossSquare'></span><span id='topic+CrossExp'></span><span id='topic+CrossLog'></span><span id='topic+CrossPow'></span><span id='topic+CrossSqrt'></span><span id='topic+CrossRaisePow'></span>

<h3>Description</h3>

<p>Implements several operations of objects of <code><a href="base.html#topic+class">class</a></code> &lsquo;ADCube&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CrossSum(u, w)

CrossMult(u, w)

CrossDivide(u, w)

CrossSquare(u)

CrossExp(u)

CrossLog(u)

CrossPow(u, r)

CrossSqrt(u)

CrossRaisePow(u, w)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CrossSum_+3A_u">u</code></td>
<td>
<p>an object of <code><a href="base.html#topic+class">class</a></code> &lsquo;ADCube&rsquo;.</p>
</td></tr>
<tr><td><code id="CrossSum_+3A_w">w</code></td>
<td>
<p>an object of <code><a href="base.html#topic+class">class</a></code> &lsquo;ADCube&rsquo;.</p>
</td></tr>
<tr><td><code id="CrossSum_+3A_r">r</code></td>
<td>
<p>a positive real number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Assume <code>u</code> and <code>w</code> contain the evaluations of functions <code class="reqn">f()</code> and <code class="reqn">g()</code>, together with evaluations of all their cross-derivatives, at points <code class="reqn">x</code> and <code class="reqn">y</code>, respectively.
</p>
<p><code>CrossSum</code> returns the evaluation of <code class="reqn">f()+g()</code>, together with all evaluated cross-derivates.
</p>
<p><code>CrossMult</code> returns the evaluation of <code class="reqn">f()g()</code>, together with all evaluated cross-derivates.
</p>
<p><code>CrossDivide</code> returns the evaluation of <code class="reqn">f()/g()</code>, together with all evaluated cross-derivates.
</p>
<p><code>CrossSquare</code> returns the evaluation of <code class="reqn">(f())^2</code>, together with all evaluated cross-derivates.
</p>
<p><code>CrossExp</code> returns the evaluation of <code class="reqn">\exp(f())</code>, together with all evaluated cross-derivates.
</p>
<p><code>CrossLog</code> returns the evaluation of <code class="reqn">\log(f())</code>, together with all evaluated cross-derivates.
</p>
<p><code>CrossPow</code> returns the evaluation of <code class="reqn">(f())^r</code>, together with all evaluated cross-derivates.
</p>
<p><code>CrossSqrt</code> returns the evaluation of <code class="reqn">\sqrt{f()}</code>, together with all evaluated cross-derivates.
</p>
<p><code>CrossRaisePow</code> returns the evaluation of <code class="reqn">f()^{g()}</code>, together with all evaluated cross-derivates.
</p>


<h3>Value</h3>

<p>An object of <code><a href="base.html#topic+class">class</a></code> &lsquo;ADCube&rsquo; is returned.  See &lsquo;Details&rsquo;.
</p>


<h3>Author(s)</h3>

<p>Berwin A. Turlach &lt;berwin.turlach@gmail.com&gt;
</p>


<h3>References</h3>

<p>Griewank, A., Lehmann, L., Leovey, H. and Zilberman, M. (2014). Automatic evaluations of cross-derivatives, <em>Mathematics of Computation</em> <strong>83</strong>(285): 251-274.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NewCube">NewCube</a></code>
</p>

<hr>
<h2 id='GenerateRV'>GenerateRV generic</h2><span id='topic+GenerateRV'></span>

<h3>Description</h3>

<p>A generic to sample random variates from an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GenerateRV(obj, n, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GenerateRV_+3A_obj">obj</code></td>
<td>
<p>object from which to sample.</p>
</td></tr>
<tr><td><code id="GenerateRV_+3A_n">n</code></td>
<td>
<p>number of items to sample.</p>
</td></tr>
<tr><td><code id="GenerateRV_+3A_...">...</code></td>
<td>
<p>further arguments for methods.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Berwin A. Turlach &lt;berwin.turlach@gmail.com&gt;
</p>

<hr>
<h2 id='GenerateRV.CopApprox'>Generates random variates from a copula approximation</h2><span id='topic+GenerateRV.CopApprox'></span>

<h3>Description</h3>

<p>Method to sample random variates from an object of <code><a href="base.html#topic+class">class</a></code> &lsquo;CopApprox&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CopApprox'
GenerateRV(obj, n, MH = FALSE, trace = FALSE,
  PDF = NULL, burnin = 500, thinning = 5, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GenerateRV.CopApprox_+3A_obj">obj</code></td>
<td>
<p>object from which to sample.</p>
</td></tr>
<tr><td><code id="GenerateRV.CopApprox_+3A_n">n</code></td>
<td>
<p>number of items to sample.</p>
</td></tr>
<tr><td><code id="GenerateRV.CopApprox_+3A_mh">MH</code></td>
<td>
<p>logical, should a Metropolis-Hastings algorithm be used to refine the sample?  Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="GenerateRV.CopApprox_+3A_trace">trace</code></td>
<td>
<p>logical, indicating whether the function should be verbose.</p>
</td></tr>
<tr><td><code id="GenerateRV.CopApprox_+3A_pdf">PDF</code></td>
<td>
<p>probability density function corresponding to copula used to create <code>obj</code>, only used if <code>MH</code> is <code>TRUE</code>; see &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="GenerateRV.CopApprox_+3A_burnin">burnin</code></td>
<td>
<p>the number of burn-in iterations of the MH sampler, only used if <code>MH</code> is <code>TRUE</code>, defaults to 500.</p>
</td></tr>
<tr><td><code id="GenerateRV.CopApprox_+3A_thinning">thinning</code></td>
<td>
<p>the thining parameter, only used if <code>MH</code> is <code>TRUE</code>, defaults to 5.</p>
</td></tr>
<tr><td><code id="GenerateRV.CopApprox_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If argument <code>MH</code> is <code>FALSE</code>, the default, random variates are directly sampled from the approximation, as described in Tajvidi and Turlach (2017).
</p>
<p>If <code>MH</code> is <code>TRUE</code>, <code>GenerateRV</code> uses additionally a Metropolis-Hastings refinement.  It first samples from the approximation, but uses those samples then as proposals in a Metropolis-Hastings algorithm.  The latter needs the probability density function of the copula.  This density function has either to be passed to the argument <code>PDF</code>, or the copula (stored in argument <code>obj</code>) belonging to the approximation must have the density function (with name &lsquo;<code>pdfCopula</code>&rsquo;) stored in its environment. In the latter case, the argument <code>PDF</code> can be <code>NULL</code> (its default).
</p>


<h3>Value</h3>

<p>A matrix of dimension <code>n</code> times <code>dim</code>, where <code>dim</code> is the dimension for which the copula approximation was determined.
</p>
<p>If <code>MH</code> was <code>TRUE</code> the return value has an attribute called &lsquo;<code>AcceptanceRate</code>&rsquo;, indicating the fraction of samples that were accepted in the Metropolis-Hastings step.  This fraction is based on all <code>burnin + (n-1)*thinning + 1</code> samples that are  initially generated from the approximation.
</p>


<h3>References</h3>

<p>Tajvidi, N. and Turlach, B.A. (2017). A general approach to generate random variates for multivariate copulae, <em>Australian &amp; New Zealand Journal of Statistics</em>. Doi:10.1111/anzs.12209.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GetApprox">GetApprox</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cop &lt;- NewBEVAsyMixedModelCopula(theta=1, phi=-0.25)
approx1 &lt;- GetApprox(cop)
approx2 &lt;- GetApprox(cop, type = 1)
sample1 &lt;- GenerateRV(approx1, 100)
plot(sample1)
sample2 &lt;- GenerateRV(approx2, 100)
plot(sample2)
sample1 &lt;- GenerateRV(approx1, 50, MH = TRUE, trace = TRUE)
plot(sample1)
sample2 &lt;- GenerateRV(approx2, 50, MH = TRUE)
plot(sample2)

</code></pre>

<hr>
<h2 id='GetApprox'>Approximate a copula by a histogram density</h2><span id='topic+GetApprox'></span>

<h3>Description</h3>

<p>Approximates the &ldquo;density&rdquo; of a copula by a piece-wise constant function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetApprox(Cop, dim = 2, depth = ifelse(type == 1, 10, 32), type = 1,
  TOL = 1000 * .Machine$double.eps)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GetApprox_+3A_cop">Cop</code></td>
<td>
<p>A function defining the copula.</p>
</td></tr>
<tr><td><code id="GetApprox_+3A_dim">dim</code></td>
<td>
<p>The approximation should be calculated on the dim-dimensional unit cube, defaults to 2.</p>
</td></tr>
<tr><td><code id="GetApprox_+3A_depth">depth</code></td>
<td>
<p>The number of hyperrectangles to be used to devide the unit cube, defaults to 10 for Approximation I and to 32 for Approximation II.</p>
</td></tr>
<tr><td><code id="GetApprox_+3A_type">type</code></td>
<td>
<p>Whether Approximation I or Approximation II should be used, defaults to one.</p>
</td></tr>
<tr><td><code id="GetApprox_+3A_tol">TOL</code></td>
<td>
<p>A numerical tolerance used when calculating Approximation I.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides two methods for subdividing the <code class="reqn">d</code>-dimensional unit cube into hyper-rectangles, with <code class="reqn">d</code> being passed to the parameter <code>dim</code>.  As most of the functions in this package which create a new copula return a function that can be evaluated at points in arbitrary dimensions, it is necessary to specify for which dimension <code class="reqn">d</code> one wishes to calculate the approximation to the copula's &ldquo;density&rdquo;.
</p>
<p>The first method (Approximation I) determines <code class="reqn">2^m</code> hyper-rectangles (where <code class="reqn">m</code> is the parameter <code>depth</code>), each containing the same probability mass with respect to the copula.  The second method (Approximation II) dividies the unit cube into <code class="reqn">m^d</code> hyper-squares.
</p>
<p>These approximations can be interpreted as piecewise constant approximations of the copula's probability density function if the copula is absolutely continuous.  For futher details see &lsquo;References&rsquo;.
</p>


<h3>Value</h3>

<p><code>GetApprox</code> returns an object of <code><a href="base.html#topic+class">class</a></code> &lsquo;CopApprox&rsquo; according to its inputs. The returned object is a list containing a matrix that holds the information of the approximation, the argument <code>Cop</code>, which approximation was determined, and other auxiliary information.
</p>
<p>The only method for objects of class &lsquo;CopApprox&rsquo; implemented so far are for the generic function <code><a href="base.html#topic+plot">plot</a></code>, and then only for the case if <code>dim</code> was 2.
</p>


<h3>Author(s)</h3>

<p>Berwin A. Turlach &lt;berwin.turlach@gmail.com&gt;
</p>


<h3>References</h3>

<p>Tajvidi, N. and Turlach, B.A. (2017). A general approach to generate random variates for multivariate copulae, <em>Australian &amp; New Zealand Journal of Statistics</em>. Doi:10.1111/anzs.12209.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.CopApprox">plot.CopApprox</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Cop &lt;- NewMEVGumbelCopula(3)
CopApprox &lt;- GetApprox(Cop, dim=2)
plot(CopApprox)

</code></pre>

<hr>
<h2 id='MaxTemp'>Extreme temperatures at two West Australian meteorological stations</h2><span id='topic+MaxTemp'></span>

<h3>Description</h3>

<p>A dataset on maximum annual values of average daily temperature measurements at two meteorological stations&mdash;Leonora (latitude 28.53S, longitude 121.19E) and Menzies (latitude 29.42S, longitude 121.02E)&mdash; in Western Australia, for the period 1898&ndash;1993.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MaxTemp
</code></pre>


<h3>Format</h3>

<p>A data frame with 96 rows and 2 variables:
</p>

<dl>
<dt>Leonora</dt><dd><p>annual maximal temperature at Leonora, in degrees Celsius</p>
</dd>
<dt>Menzies</dt><dd><p>annual maximal temperature at Menzies, in degrees Celsius</p>
</dd>
</dl>


<h3>References</h3>

<p>Hall, P. and Tajvidi, N. (2004). Prediction regions for bivariate extreme events. <em>Australian &amp; New Zealand Journal of Statistics</em> <b>46</b>(1), 99&ndash;112. Doi:10.1111/j.1467-842X.2004.00316.x.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(Menzies ~ Leonora, MaxTemp,
     xlab = expression("Temperature at Leonora ("*degree*"C)"),
     ylab = expression("Temperature at Menzies ("*degree*"C)"))

</code></pre>

<hr>
<h2 id='NewBEVAsyLogisticCopula'>Creates a bivariate asymmetric logistic model extreme value copula</h2><span id='topic+NewBEVAsyLogisticCopula'></span>

<h3>Description</h3>

<p>Creates an instance of the bivariate asymmetric logistic model extreme value copula with parameters <code class="reqn">r</code>, <code class="reqn">\theta</code> and <code class="reqn">\phi</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NewBEVAsyLogisticCopula(r, theta, phi)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NewBEVAsyLogisticCopula_+3A_r">r</code></td>
<td>
<p>real.</p>
</td></tr>
<tr><td><code id="NewBEVAsyLogisticCopula_+3A_theta">theta</code></td>
<td>
<p>real.</p>
</td></tr>
<tr><td><code id="NewBEVAsyLogisticCopula_+3A_phi">phi</code></td>
<td>
<p>real.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The dependence function for this bivariate EV copula is </p>
<p style="text-align: center;"><code class="reqn">A(w) = (\theta (1-w)^r + (\phi w)^r)^{1/r} + (\theta - \phi) w + 1 - \theta</code>
</p>

<p>Necessary and sufficient conditions for the dependence function to be valid are
</p>

<ul>
<li> <p><code class="reqn">r \ge 1</code>
</p>
</li>
<li> <p><code class="reqn">0 \le \theta \le 0</code>
</p>
</li>
<li> <p><code class="reqn">0 \le \phi \le 1</code>
</p>
</li></ul>

<p>For <code class="reqn">\theta = \phi = 1</code> this model reduces to the symmetric logistic model.
</p>


<h3>Value</h3>

<p>A function that evaluates the bivariate asymmetric logistic model EV copula (with parameters <code class="reqn">r</code>, <code class="reqn">\theta</code> and <code class="reqn">phi</code>) at a given <code class="reqn">2</code>-dimensional vector in the unit square.  The environment of the function also contains a function called <code>pdfCopula</code> that evaluates the probability density function of the bivariate asymmetric mixed model EV copula via automatic differentation.
</p>


<h3>Author(s)</h3>

<p>Berwin A. Turlach &lt;berwin.turlach@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NewBEVLogisticCopula">NewBEVLogisticCopula</a></code>, <code><a href="#topic+NewMEVAsyLogisticCopula">NewMEVAsyLogisticCopula</a></code>
</p>

<hr>
<h2 id='NewBEVAsyMixedModelCopula'>Creates a bivariate asymmetric mixed model extreme value copula</h2><span id='topic+NewBEVAsyMixedModelCopula'></span>

<h3>Description</h3>

<p>Creates an instance of the bivariate asymmetric mixed model extreme value copula with parameters <code class="reqn">\phi</code> and <code class="reqn">\theta</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NewBEVAsyMixedModelCopula(theta, phi)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NewBEVAsyMixedModelCopula_+3A_theta">theta</code></td>
<td>
<p>real.</p>
</td></tr>
<tr><td><code id="NewBEVAsyMixedModelCopula_+3A_phi">phi</code></td>
<td>
<p>real.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The dependence function for this bivariate EV copula is </p>
<p style="text-align: center;"><code class="reqn">A(w) = \phi w^3 + \theta w^2 - (\phi+\theta) w + 1</code>
</p>

<p>Necessary and sufficient conditions for the dependence function to be valid are
</p>

<ul>
<li> <p><code class="reqn">\theta \ge 0</code>
</p>
</li>
<li> <p><code class="reqn">\theta + 3 \phi \ge 0</code>
</p>
</li>
<li> <p><code class="reqn">\theta + \phi \le 1</code>
</p>
</li>
<li> <p><code class="reqn">\theta + 2 \phi \le 1</code>
</p>
</li></ul>

<p>If <code class="reqn">\phi = 0</code> we obtain the symmetric mixed model.
</p>


<h3>Value</h3>

<p>A function that evaluates the bivariate asymmetric mixed model EV copula (with parameters <code class="reqn">\phi</code> and <code class="reqn">\theta</code>) at a given <code class="reqn">2</code>-dimensional vector in the unit square.  The environment of the function also contains a function called <code>pdfCopula</code> that evaluates the probability density function of the bivariate asymmetric mixed model EV copula via automatic differentation.
</p>


<h3>Author(s)</h3>

<p>Berwin A. Turlach &lt;berwin.turlach@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NewBEVMixedModelCopula">NewBEVMixedModelCopula</a></code>
</p>

<hr>
<h2 id='NewBEVLogisticCopula'>Creates a bivariate logistic model extreme value copula</h2><span id='topic+NewBEVLogisticCopula'></span>

<h3>Description</h3>

<p>Creates an instance of the bivariate logistic model extreme value copula with parameter <code class="reqn">r</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NewBEVLogisticCopula(r)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NewBEVLogisticCopula_+3A_r">r</code></td>
<td>
<p>real.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The dependence function for this bivariate EV copula is </p>
<p style="text-align: center;"><code class="reqn">A(w) = ((1-w)^r + w^r)^{1/r}</code>
</p>

<p>Necessary and sufficient conditions for the dependence function to be valid are
</p>

<ul>
<li> <p><code class="reqn">r \ge 1</code>
</p>
</li></ul>



<h3>Value</h3>

<p>A function that evaluates the bivariate logistic model EV copula (with parameter <code class="reqn">r</code>) at a given <code class="reqn">2</code>-dimensional vector in the unit square.  The environment of the function also contains a function called <code>pdfCopula</code> that evaluates the probability density function of the bivariate asymmetric mixed model EV copula via automatic differentation.
</p>


<h3>Author(s)</h3>

<p>Berwin A. Turlach &lt;berwin.turlach@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NewBEVAsyLogisticCopula">NewBEVAsyLogisticCopula</a></code>, <code><a href="#topic+NewMEVGumbelCopula">NewMEVGumbelCopula</a></code>
</p>

<hr>
<h2 id='NewBEVMixedModelCopula'>Creates a bivariate mixed model extreme value copula</h2><span id='topic+NewBEVMixedModelCopula'></span>

<h3>Description</h3>

<p>Creates an instance of the bivariate asymmetric mixed model extreme value copula with parameter <code class="reqn">\theta</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NewBEVMixedModelCopula(theta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NewBEVMixedModelCopula_+3A_theta">theta</code></td>
<td>
<p>real.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The dependence function for this bivariate EV copula is </p>
<p style="text-align: center;"><code class="reqn">A(w) = \theta w^2 - \theta w + 1</code>
</p>

<p>Necessary and sufficient conditions for the dependence function to be valid are
</p>

<ul>
<li> <p><code class="reqn">0 \le \theta \le 1</code>
</p>
</li></ul>



<h3>Value</h3>

<p>A function that evaluates the bivariate asymmetric mixed model EV copula (with parameter <code class="reqn">\theta</code>) at a given <code class="reqn">2</code>-dimensional vector in the unit square.  The environment of the function also contains a function called <code>pdfCopula</code> that evaluates the probability density function of the bivariate asymmetric mixed model EV copula via automatic differentation.
</p>


<h3>Author(s)</h3>

<p>Berwin A. Turlach &lt;berwin.turlach@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NewBEVAsyMixedModelCopula">NewBEVAsyMixedModelCopula</a></code>
</p>

<hr>
<h2 id='NewBEVSplineCopula'>Creates a flexible extreme value copula</h2><span id='topic+NewBEVSplineCopula'></span>

<h3>Description</h3>

<p>Creates a bivariate extreme value copula from a spline estimate of its dependence function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NewBEVSplineCopula(spl)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NewBEVSplineCopula_+3A_spl">spl</code></td>
<td>
<p>a spline function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function that evaluates the bivariate EV copula (whose dependence function is given by the spline) at a given <code class="reqn">2</code>-dimensional vector in the unit square.  The environment of the function also contains a function called <code>pdfCopula</code> that evaluates the probability density function of the bivariate asymmetric mixed model EV copula via automatic differentation.
</p>


<h3>Author(s)</h3>

<p>Berwin A. Turlach &lt;berwin.turlach@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SplineFitDepFct">SplineFitDepFct</a></code>
</p>

<hr>
<h2 id='NewCube'>Cross-derivatives via automatic differentiation</h2><span id='topic+NewCube'></span>

<h3>Description</h3>

<p>Basic building blocks for evaluating functionals <code class="reqn">f:R^d \to R</code> and all their cross-derivatives at a given point <code class="reqn">x \in R^d</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NewCube(x, j, dim = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NewCube_+3A_x">x</code></td>
<td>
<p>(scalar) value at which the function is evaluated.</p>
</td></tr>
<tr><td><code id="NewCube_+3A_j">j</code></td>
<td>
<p>optional input. See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="NewCube_+3A_dim">dim</code></td>
<td>
<p>dimension <code class="reqn">d</code> of the input vector, defaults to two.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the optional argument <code>j</code> is specfied, then the function <code class="reqn">f(x)=x_j</code> and all its cross-derivatives (all of which but one will be zero, the derivative with respect to the <code class="reqn">j</code>th component being 1) are evaluated with <code class="reqn">x_j</code> being set to the value of <code>x</code>.
</p>
<p>If the optional argument <code>j</code> is not used, then the function <code class="reqn">f(x) =c</code> and all its cross-derivatives (all of which will be zero) are evaluated with <code class="reqn">c</code> beting set to the value of <code>x</code>.
</p>
<p>From these primitive function evaluations, more complicated functions can be constructed using the operations documented in <code><a href="#topic+CrossSum">CrossSum</a></code>.
</p>


<h3>Value</h3>

<p><code>NewCube</code> returns an object of <code><a href="base.html#topic+class">class</a></code> &lsquo;ADCube&rsquo; according to its inputs. See &lsquo;Details&rsquo;.
</p>


<h3>Author(s)</h3>

<p>Berwin A. Turlach &lt;berwin.turlach@gmail.com&gt;
</p>


<h3>References</h3>

<p>Griewank, A., Lehmann, L., Leovey, H. and Zilberman, M. (2014). Automatic evaluations of cross-derivatives, <em>Mathematics of Computation</em> <strong>83</strong>(285): 251-274.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CrossSum">CrossSum</a></code>
</p>

<hr>
<h2 id='NewMEVAsyLogisticCopula'>Creates a multivariate asymmetric logistic copula</h2><span id='topic+NewMEVAsyLogisticCopula'></span>

<h3>Description</h3>

<p>Creates an instance of the multivariate asymmetric copula with parameters <code class="reqn">\theta</code> and r.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NewMEVAsyLogisticCopula(theta, r)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NewMEVAsyLogisticCopula_+3A_theta">theta</code></td>
<td>
<p>a <code class="reqn">k \times d</code> matrix of reals.</p>
</td></tr>
<tr><td><code id="NewMEVAsyLogisticCopula_+3A_r">r</code></td>
<td>
<p>a vector of <code class="reqn">k</code> reals</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>theta</code> has entries <code class="reqn">\theta_{ij}</code> and <code>r</code> has entries <code class="reqn">r_j</code> (<code class="reqn">i=1,\dots,k</code> and <code class="reqn">j=1,\dots,d</code>), then the following parameterisation of the copula is used:
</p>
<p style="text-align: center;"><code class="reqn">C(u_1,\dots,u_d) = \exp\left(- \sum_{i=1}^k \left\{ \sum_{j=1}^d (\theta_{ij} \bar u_j)^{r_i} \right\}^{1/r_i}  \right)</code>
</p>

<p>where <code class="reqn">\bar u_j = -\log(u_j)</code>, <code class="reqn">j=1,\dots,d</code>.
</p>
<p>Necessary and sufficient conditions for the parameters are
</p>

<ul>
<li><p> all entries in <code>theta</code> have to be non-negative.
</p>
</li>
<li><p> each column of <code>theta</code> has to add to one.
</p>
</li>
<li><p> each row of <code>theta</code> must have a unique pattern of non-zero values, including the pattern that has no zeros in a row.
</p>
</li>
<li><p> if a row of <code>theta</code> has only one non-zero value, then the corresponding entry in <code>r</code> has to be one.
</p>
</li>
<li><p> if a row of <code>theta</code> has more than one non-zero value, then the corresponding entry of <code>r</code> must be greater than one.
</p>
</li></ul>



<h3>Value</h3>

<p>A function that evaluates the multivariate asymmetric logistic copula (with parameters <code class="reqn">\theta</code> and r) at a given <code class="reqn">d</code>-dimensional vector in the unit square.  Note that for this function the dimension of vectors at which the copula can be evaluated is determined by the input parameters.  The environment of the function also contains a function called <code>pdfCopula</code> that evaluates the probability density function of the multivariate asymmetric logistic copula via automatic differentation.
</p>


<h3>Author(s)</h3>

<p>Berwin A. Turlach &lt;berwin.turlach@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NewBEVAsyLogisticCopula">NewBEVAsyLogisticCopula</a></code>, <code><a href="#topic+NewMEVGumbelCopula">NewMEVGumbelCopula</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>theta &lt;-  rbind(c(0, 0.2, 0.8), c(1,0.8,0.2))
r &lt;- c(2,3)
cop &lt;- NewMEVAsyLogisticCopula(theta, r)

## Creates the same copula
theta &lt;- 0.2
phi &lt;- 0.4
r &lt;- 2
cop1 &lt;- NewBEVAsyLogisticCopula(r, theta, phi)
theta &lt;- cbind(c(phi, 1-phi, 0), c(theta, 0, 1-theta))
r &lt;- c(r, 1,  1)
cop2 &lt;- NewMEVAsyLogisticCopula(theta, r)

</code></pre>

<hr>
<h2 id='NewMEVGumbelCopula'>Creates a Gumpel copula</h2><span id='topic+NewMEVGumbelCopula'></span>

<h3>Description</h3>

<p>Creates an instance of the Gumbel copula with parameter r.  This family is also known as the Gumbel&ndash;Hougaard copula or the logistic model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NewMEVGumbelCopula(r = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NewMEVGumbelCopula_+3A_r">r</code></td>
<td>
<p>real, the parameter of the Gumbel copula, defaults to 2, must be larger or equal to one.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following parameterisation of the copula is used:
</p>
<p style="text-align: center;"><code class="reqn">C(u_1,\dots,u_d) = \exp\left(- \left\{ \sum_{j=1}^d \bar u_j^r \right\}^{1/r}\right)</code>
</p>

<p>where <code class="reqn">\bar u_j = -\log(u_j)</code>, <code class="reqn">j=1,\dots,d</code>.
</p>


<h3>Value</h3>

<p>A function that evaluates the Gumbel copula (with parameter r) at a given <code class="reqn">d</code>-dimensional vector in the unit cube.  The environment of the function also contains a function called <code>pdfCopula</code> that evaluates the probability density function of the Gumbel copula via automatic differentation.
</p>


<h3>Author(s)</h3>

<p>Berwin A. Turlach &lt;berwin.turlach@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NewMEVAsyLogisticCopula">NewMEVAsyLogisticCopula</a></code>
</p>

<hr>
<h2 id='NewMVClaytonCopula'>Creates a Clayton copula</h2><span id='topic+NewMVClaytonCopula'></span>

<h3>Description</h3>

<p>Creates an instance of the Clayton copula with parameter <code class="reqn">\theta</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NewMVClaytonCopula(theta = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NewMVClaytonCopula_+3A_theta">theta</code></td>
<td>
<p>real, the parameter of the Clayton copula, defaults to 1; must be positive.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following parameterisation of the copula is used:
</p>
<p style="text-align: center;"><code class="reqn">C(u_1,\dots,u_d) = \left(\left\{ \sum_{j=1}^d u_j^{-\theta} \right\} - (d-1) \right)^{-1/\theta}</code>
</p>



<h3>Value</h3>

<p>A function that evaluates the Clayton copula (with parameter <code class="reqn">\alpha</code>) at a given <code class="reqn">d</code>-dimensional vector in the unit cube.  The environment of the function also contains a function called <code>pdfCopula</code> that evaluates the probability density function of the Clayton copula via automatic differentation.
</p>


<h3>Author(s)</h3>

<p>Berwin A. Turlach &lt;berwin.turlach@gmail.com&gt;
</p>

<hr>
<h2 id='NewMVFrankCopula'>Creates a Frank copula</h2><span id='topic+NewMVFrankCopula'></span>

<h3>Description</h3>

<p>Creates an instance of the Frank copula with parameter <code class="reqn">\alpha</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NewMVFrankCopula(alpha = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NewMVFrankCopula_+3A_alpha">alpha</code></td>
<td>
<p>real, the parameter of the Frank copula, defaults to 2; must be positive.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following parameterisation of the copula is used:
</p>
<p style="text-align: center;"><code class="reqn">C(u_1,\dots,u_d) = -\log(1+\exp(s) * t)/\alpha</code>
</p>

<p>where <code class="reqn">s = \sum_{j=1}^d \log\left(\frac{\exp(-\alpha u_j) -1 }{t}\right)</code> and <code class="reqn">t=\exp(-\alpha)-1</code>.
</p>


<h3>Value</h3>

<p>A function that evaluates the Frank copula (with parameter <code class="reqn">\alpha</code>) at a given <code class="reqn">d</code>-dimensional vector in the unit cube.  The environment of the function also contains a function called <code>pdfCopula</code> that evaluates the probability density function of the Frank copula via automatic differentation.
</p>


<h3>Author(s)</h3>

<p>Berwin A. Turlach &lt;berwin.turlach@gmail.com&gt;
</p>

<hr>
<h2 id='NonparEstDepFct'>Nonparametric estimator of bivariate dependence function</h2><span id='topic+NonparEstDepFct'></span>

<h3>Description</h3>

<p>Function to calculate nonparametric estimates of the dependence functions of bivariate extreme value copula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NonparEstDepFct(x, y = NULL, w.length = 101, transf.to.frechet = TRUE,
  convex.hull = TRUE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NonparEstDepFct_+3A_x">x</code>, <code id="NonparEstDepFct_+3A_y">y</code></td>
<td>
<p>vectors giving the observations of the extreme values. Alternatively a single plotting structure can be specified: see <code><a href="grDevices.html#topic+xy.coords">xy.coords</a></code>.</p>
</td></tr>
<tr><td><code id="NonparEstDepFct_+3A_w.length">w.length</code></td>
<td>
<p>number of grid points (using an equidistant grid from 0 to 1) on which the dependence function is estimated.</p>
</td></tr>
<tr><td><code id="NonparEstDepFct_+3A_transf.to.frechet">transf.to.frechet</code></td>
<td>
<p>logical, controls whether <code>x</code> and <code>y</code> are first transformed to have standard Fréchet margins: see &lsquo;Details&rsquo;; defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="NonparEstDepFct_+3A_convex.hull">convex.hull</code></td>
<td>
<p>logical, controls whether the convex hull of the modified Pickands estimator is returned; defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="NonparEstDepFct_+3A_verbose">verbose</code></td>
<td>
<p>logical, controls whether progress messages are given; defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>transf.to.frechet</code> is <code>TRUE</code>, the default, then a generalised extreme value (GEV) distribution is fitted to each margin and the fitted parameters are used to transform the data to have standard Fréchet margins.  The parameterisation of the cumulative distribution of the GEV that is used is, if <code class="reqn">\gamma \neq 0</code>:
</p>
<p style="text-align: center;"><code class="reqn">G(z) = \exp\left(-\left[1+\gamma\left(\frac{z-\mu}{\sigma}\right)\right]^{-1/\gamma}\right)</code>
</p>

<p>and for <code class="reqn">\gamma = 0</code>:
</p>
<p style="text-align: center;"><code class="reqn">G(z) = \exp(-\exp(-z))</code>
</p>

<p>If <code class="reqn">\gamma &lt; 0</code>, then the support of the GEV is the interval <code class="reqn">(-\infty, \mu - \sigma/\gamma]</code>, while it is <code class="reqn">[\mu - \sigma/\gamma, \infty)</code> if <code class="reqn">\gamma &gt; 0</code>.  For <code class="reqn">\gamma = 0</code>, the support is the real line.
</p>
<p>If <code>verbose</code> is <code>TRUE</code>, not the default, and <code>transf.to.frechet</code> is <code>TRUE</code>, the estimates for the fitted GEV distribution are printed out using <code><a href="base.html#topic+cat">cat</a></code>.
</p>


<h3>Value</h3>

<p>A list with two named components.  The component <code>x</code> contains a vector with the grid points at which the dependence function was estimated.  The component <code>y</code> contains the estimated dependence functions.
</p>


<h3>Author(s)</h3>

<p>Nader Tajvidi &lt;Nader.Tajvidi@matstat.lu.se&gt;
</p>


<h3>References</h3>

<p>Hall, P. and Tajvidi, N. (2000). Distribution and dependence-function estimation for bivariate extreme-value distributions.  <em>Bernoulli</em> <b>6</b>(5), 835&ndash;844. Doi:10.2307/3318758.
</p>
<p>Hall, P. and Tajvidi, N. (2004). Prediction regions for bivariate extreme events. <em>Australian &amp; New Zealand Journal of Statistics</em> <b>46</b>(1), 99&ndash;112. Doi:10.1111/j.1467-842X.2004.00316.x.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SplineFitDepFct">SplineFitDepFct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Data from Hall and Tajvidi (2004, ANZJS)
EstDF1 &lt;- NonparEstDepFct(MaxTemp)

## Plot modified Pickands Function and area in which
## dependence function must lie
plot(EstDF1, ylim = c(0.5,1), xlab = "w", ylab = "A(w)", type="l", lty="longdash")
polygon(c(0, 0.5, 1, 0), c(1, 0.5, 1, 1))

</code></pre>

<hr>
<h2 id='plot.CopApprox'>Plot the histogram density approximation to a copula</h2><span id='topic+plot.CopApprox'></span>

<h3>Description</h3>

<p>Plots the histogram density approximation to a copula as determined by <code><a href="#topic+GetApprox">GetApprox</a></code>.  Currently works only for bivariate copulae.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CopApprox'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.CopApprox_+3A_x">x</code></td>
<td>
<p>an object of <code><a href="base.html#topic+class">class</a></code> &lsquo;CopApprox&rsquo;.</p>
</td></tr>
<tr><td><code id="plot.CopApprox_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Berwin A. Turlach &lt;berwin.turlach@gmail.com&gt;
</p>


<h3>References</h3>

<p>Tajvidi, N. and Turlach, B.A. (2017). A general approach to generate random variates for multivariate copulae, <em>Australian &amp; New Zealand Journal of Statistics</em>. Doi:10.1111/anzs.12209.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Cop &lt;- NewMEVGumbelCopula(4)
CopApprox1 &lt;- GetApprox(Cop, dim=2)
plot(CopApprox1)
CopApprox2 &lt;- GetApprox(Cop, dim=2, type=2)
plot(CopApprox2)

</code></pre>

<hr>
<h2 id='print.ADCube'>Print method for cubes</h2><span id='topic+print.ADCube'></span>

<h3>Description</h3>

<p><code><a href="base.html#topic+print">print</a></code> method for &lsquo;ADCube&rsquo; objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ADCube'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.ADCube_+3A_x">x</code></td>
<td>
<p>an object of <code><a href="base.html#topic+class">class</a></code> &lsquo;ADCube&rsquo;.</p>
</td></tr>
<tr><td><code id="print.ADCube_+3A_...">...</code></td>
<td>
<p>arguments passed on to <code>base::print</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, the component &lsquo;<code>val</code>&rsquo; of the &lsquo;ADCube&rsquo; object is printed using <code>base::print</code>.
</p>

<hr>
<h2 id='print.SimCop'>Print basic information on a copula</h2><span id='topic+print.SimCop'></span>

<h3>Description</h3>

<p>Prints basic information on a copula created with the methods in this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SimCop'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.SimCop_+3A_x">x</code></td>
<td>
<p>an object of <code><a href="base.html#topic+class">class</a></code> &lsquo;SimCop&rsquo;.</p>
</td></tr>
<tr><td><code id="print.SimCop_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Berwin A. Turlach &lt;berwin.turlach@gmail.com&gt;
</p>

<hr>
<h2 id='SplineFitDepFct'>Fit a dependence function by spline smoothing</h2><span id='topic+SplineFitDepFct'></span>

<h3>Description</h3>

<p>Given estimates for the dependence function of a bivariate extreme value copula at specified points, this function fits a natural cubic smoothing spline, that is constrained to fulfill all the conditions of a dependence function, to the given estimates via quadratic programming.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SplineFitDepFct(x, y = NULL, alpha = 0.01, integ.value)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SplineFitDepFct_+3A_x">x</code>, <code id="SplineFitDepFct_+3A_y">y</code></td>
<td>
<p>vectors giving the coordinates of the points to be approximated. Alternatively a single plotting structure can be specified: see <code><a href="grDevices.html#topic+xy.coords">xy.coords</a></code>.</p>
</td></tr>
<tr><td><code id="SplineFitDepFct_+3A_alpha">alpha</code></td>
<td>
<p>real, the smoothing parameter for the smoothing splines.</p>
</td></tr>
<tr><td><code id="SplineFitDepFct_+3A_integ.value">integ.value</code></td>
<td>
<p>real, non-negative value that should be less than two; see &lsquo;Details&rsquo;</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>integ.value</code> should be between 0 and 2.  If a value is specified, then an additional constraint is added to the quadratic program to ensure that the integeral (over 0 to 1) of the second derivative of the spline is larger or equal to <code>integ.value</code>.  Choosing values close to 2 may lead to quadratic programms on which <code><a href="quadprog.html#topic+solve.QP">solve.QP</a></code> reports inconsistent constraints.
</p>


<h3>Value</h3>

<p>A function, created by <code><a href="stats.html#topic+splinefun">splinefun</a></code>, that evaluates the natural cubic spline that was fitted to the data.
</p>


<h3>Author(s)</h3>

<p>Nader Tajvidi &lt;Nader.Tajvidi@matstat.lu.se&gt;
</p>
<p>Berwin A Turlach &lt;Berwin.Turlach@gmail.com&gt;
</p>


<h3>References</h3>

<p>Hall, P. and Tajvidi, N. (2000). Distribution and dependence-function estimation for bivariate extreme-value distributions.  <em>Bernoulli</em> <b>6</b>(5), 835&ndash;844. Doi:10.2307/3318758.
</p>
<p>Hall, P. and Tajvidi, N. (2004). Prediction regions for bivariate extreme events. <em>Australian &amp; New Zealand Journal of Statistics</em> <b>46</b>(1), 99&ndash;112. Doi:10.1111/j.1467-842X.2004.00316.x.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NonparEstDepFct">NonparEstDepFct</a></code>, <code><a href="#topic+NewBEVSplineCopula">NewBEVSplineCopula</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Data from Hall and Tajvidi (2004, ANZJS)
EstDF2 &lt;- NonparEstDepFct(MaxTemp, convex = FALSE)

## Plot modified Pickands Function and area in which
## dependence function must lie
plot(EstDF2, ylim = c(0.5,1), xlab = "w", ylab = "A(w)", type="l", lty="longdash")
polygon(c(0, 0.5, 1, 0), c(1, 0.5, 1, 1))

## Fit spline to Pickands function and add to plot
splfit &lt;- SplineFitDepFct(EstDF2)
curve(splfit, n = 301, add = TRUE, lty = "dashed")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
