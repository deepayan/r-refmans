<!DOCTYPE html><html><head><title>Help for package ConsensusClustering</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ConsensusClustering}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adj_conv'><p>Convert adjacency function to the affinity matrix</p></a></li>
<li><a href='#adj_mat'><p>Covert data matrix to adjacency matrix</p></a></li>
<li><a href='#CC_cluster_count'><p>Count the number of clusters based on stability score.</p></a></li>
<li><a href='#cluster_relabel'><p>Relabeling clusters based on cluster similarities</p></a></li>
<li><a href='#coCluster_matrix'><p>Calculate the Co-cluster matrix for a given set of clustering results.</p></a></li>
<li><a href='#connectivity_matrix'><p>Build connectivity matrix</p></a></li>
<li><a href='#consensus_matrix'><p>Calculate consensus matrix for data perturbation consensus clustering</p></a></li>
<li><a href='#gaussian_clusters'><p>Generate clusters of data points from Gaussian distribution with randomly generated parameters</p></a></li>
<li><a href='#gaussian_clusters_with_param'><p>Generate clusters of data points from Gaussian distribution with given parameters</p></a></li>
<li><a href='#gaussian_mixture_clusters'><p>Generate clusters of data points from Gaussian-mixture-model distributions with randomly generated parameters</p></a></li>
<li><a href='#generate_gaussian_data'><p>Generate a set of data points from Gaussian distribution</p></a></li>
<li><a href='#hir_clust_from_adj_mat'><p>Hierarchical clustering from adjacency matrix</p></a></li>
<li><a href='#indicator_matrix'><p>Build indicator matrix</p></a></li>
<li><a href='#lebel_similarity'><p>Similarity between different clusters</p></a></li>
<li><a href='#Logit'><p>Logit function</p></a></li>
<li><a href='#majority_voting'><p>Consensus mechanism based on majority voting</p></a></li>
<li><a href='#multi_cluster_gen'><p>Multiple cluster generation</p></a></li>
<li><a href='#multi_kmeans_gen'><p>Multiple K-means generation</p></a></li>
<li><a href='#multi_pam_gen'><p>Multiple PAM (K-medoids) generation</p></a></li>
<li><a href='#multiview_cluster_gen'><p>Multiview cluster generation</p></a></li>
<li><a href='#multiview_clusters'><p>Generate multiview clusters from Gaussian distributions with randomly generated parameters</p></a></li>
<li><a href='#multiview_consensus_matrix'><p>Calculate consensus matrix for multi-data consensus clustering</p></a></li>
<li><a href='#multiview_kmeans_gen'><p>Multiview K-means generation</p></a></li>
<li><a href='#multiview_pam_gen'><p>Multiview PAM (K-medoids) generation</p></a></li>
<li><a href='#pam_clust_from_adj_mat'><p>PAM (k-medoids) clustering from adjacency matrix</p></a></li>
<li><a href='#spect_clust_from_adj_mat'><p>Spectral clustering from adjacency matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Consensus Clustering</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Clustering, or cluster analysis, is a widely used technique in bioinformatics to identify groups of similar biological data points. Consensus clustering is an extension to clustering algorithms that aims to construct a robust result from those clustering features that are invariant under different sources of variation. For the reference, please cite the following paper: Yousefi, Melograna, et. al., (2023) &lt;<a href="https://doi.org/10.3389%2Ffmicb.2023.1170391">doi:10.3389/fmicb.2023.1170391</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>assertthat, dplyr, igraph, cluster, mvtnorm, utils, graphics,
stats</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-03 16:29:19 UTC; behnam</td>
</tr>
<tr>
<td>Author:</td>
<td>Behnam Yousefi [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Behnam Yousefi &lt;yousefi.bme@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-05 11:20:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='adj_conv'>Convert adjacency function to the affinity matrix</h2><span id='topic+adj_conv'></span>

<h3>Description</h3>

<p>Convert adjacency function to the affinity matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adj_conv(adj.mat, alpha = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adj_conv_+3A_adj.mat">adj.mat</code></td>
<td>
<p>Adjacency matrix. The elements must be within [-1, 1].</p>
</td></tr>
<tr><td><code id="adj_conv_+3A_alpha">alpha</code></td>
<td>
<p>soft threshold value (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>adj = exp(-(1-adj)^2/(2*alpha^2))
ref: Luxburg (2007), &quot;A tutorial on spectral clustering&quot;, Stat Comput
</p>


<h3>Value</h3>

<p>the matrix if affinity values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Adj_mat = rbind(c(0.0,0.9,0.0),
                c(0.9,0.0,0.2),
                c(0.0,0.2,0.0))
adj_conv(Adj_mat)


</code></pre>

<hr>
<h2 id='adj_mat'>Covert data matrix to adjacency matrix</h2><span id='topic+adj_mat'></span>

<h3>Description</h3>

<p>Covert data matrix to adjacency matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adj_mat(X, method = "euclidian")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adj_mat_+3A_x">X</code></td>
<td>
<p>a matrix of samples by features.</p>
</td></tr>
<tr><td><code id="adj_mat_+3A_method">method</code></td>
<td>
<p>method for distance calculation:
<code>"euclidian"</code>, <code>"cosine"</code>, <code>"maximum"</code>, <code>"manhattan"</code>,
<code>"canberra"</code>, <code>"binary"</code>, <code>"minkowski"</code>,</p>
</td></tr>
</table>


<h3>Value</h3>

<p>calculated adjacency matrix from the data matrix using the specified methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X = gaussian_clusters()$X
Adj = adj_mat(X, method = "euclidian")

</code></pre>

<hr>
<h2 id='CC_cluster_count'>Count the number of clusters based on stability score.</h2><span id='topic+CC_cluster_count'></span>

<h3>Description</h3>

<p>Count the number of clusters based on stability score.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CC_cluster_count(CM, plot.cdf = TRUE, plot.logit = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CC_cluster_count_+3A_cm">CM</code></td>
<td>
<p>list of consensus matrices each for a specific number of clusters.
It can be the output of <code>consensus_matrix()</code> and <code>multiview_consensus_matrix()</code> functions.</p>
</td></tr>
<tr><td><code id="CC_cluster_count_+3A_plot.cdf">plot.cdf</code></td>
<td>
<p>binary value to plot the cumulative distribution functions of <code>CM</code> (default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="CC_cluster_count_+3A_plot.logit">plot.logit</code></td>
<td>
<p>binary value to plot the logit model of cumulative distribution functions of <code>CM</code> (default <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Count the number of clusters given a list of consensus matrices each for a specific number of clusters.
Using different methods: <code>"LogitScore", "PAC", "deltaA", "CMavg"</code>
</p>


<h3>Value</h3>

<p>results as a list:
<code>"LogitScore", "PAC", "deltaA", "CMavg"</code>,
<code>"Kopt_LogitScore", "Kopt_PAC", "Kopt_deltaA", "Kopt_CMavg"</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X = gaussian_clusters()$X
Adj = adj_mat(X, method = "euclidian")
CM = consensus_matrix(Adj, max.cluster=3, max.itter=10)
Result = CC_cluster_count(CM, plot.cdf=FALSE)

</code></pre>

<hr>
<h2 id='cluster_relabel'>Relabeling clusters based on cluster similarities</h2><span id='topic+cluster_relabel'></span>

<h3>Description</h3>

<p>Relabeling clusters based on cluster similarities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_relabel(x1, x2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster_relabel_+3A_x1">x1</code></td>
<td>
<p>clustering vector 1
Zero elements are are considered as unclustered samples</p>
</td></tr>
<tr><td><code id="cluster_relabel_+3A_x2">x2</code></td>
<td>
<p>clustering vector 2
Zero elements are are considered as unclustered samples</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When performing performing several clustering, the cluster labels may no match with each other.
To perform maximum voting, the clustering need to be relabels based on label similarities.
</p>


<h3>Value</h3>

<p>dataframe of relabeled clusters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X = gaussian_clusters()$X
x1 = kmeans(X, 5)$cluster
x2 = kmeans(X, 5)$cluster
clusters = cluster_relabel(x1, x2)

</code></pre>

<hr>
<h2 id='coCluster_matrix'>Calculate the Co-cluster matrix for a given set of clustering results.</h2><span id='topic+coCluster_matrix'></span>

<h3>Description</h3>

<p>Calculate the Co-cluster matrix for a given set of clustering results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coCluster_matrix(X, verbos = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coCluster_matrix_+3A_x">X</code></td>
<td>
<p>clustering matrix of Nsamples x Nclusterings.
Zero elements are are considered as unclustered samples</p>
</td></tr>
<tr><td><code id="coCluster_matrix_+3A_verbos">verbos</code></td>
<td>
<p>binary value for verbosity (default = <code>TRUE</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Co-cluster matrix or consensus matrix (CM) is a method for consensus mechanism explaned in Monti et al. (2003).
</p>


<h3>Value</h3>

<p>The normalized matrix of Co-cluster frequency of any pairs of samples (Nsamples x Nsamples)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Clustering = cbind(c(1,1,1,2,2,2),
                   c(1,1,2,1,2,2))
coCluster_matrix(Clustering, verbos = FALSE)

</code></pre>

<hr>
<h2 id='connectivity_matrix'>Build connectivity matrix</h2><span id='topic+connectivity_matrix'></span>

<h3>Description</h3>

<p>Build connectivity matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>connectivity_matrix(clusters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="connectivity_matrix_+3A_clusters">clusters</code></td>
<td>
<p>a vector of clusterings. Zero elements mean that the sample was absent
during clustering</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Connectivity matrix (M) is a binary matrix N-by-N
M[i,j] = 1 if sample i and j are in the same cluster
ref: Monti et al. (2003) &quot;Consensus Clustering: A Resampling-Based Method for
Class Discovery and Visualization of Gene Expression Microarray Data&quot;, Machine Learning
</p>


<h3>Value</h3>

<p>Connectivity matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>con_mat = connectivity_matrix(c(1,1,1,2,2,2))

</code></pre>

<hr>
<h2 id='consensus_matrix'>Calculate consensus matrix for data perturbation consensus clustering</h2><span id='topic+consensus_matrix'></span>

<h3>Description</h3>

<p>Calculate consensus matrix for data perturbation consensus clustering
</p>


<h3>Usage</h3>

<pre><code class='language-R'>consensus_matrix(
  X,
  max.cluster = 5,
  resample.ratio = 0.7,
  max.itter = 100,
  clustering.method = "hclust",
  adj.conv = TRUE,
  verbos = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="consensus_matrix_+3A_x">X</code></td>
<td>
<p>adjacency matrix a Nsample x Nsample</p>
</td></tr>
<tr><td><code id="consensus_matrix_+3A_max.cluster">max.cluster</code></td>
<td>
<p>maximum number of clusters</p>
</td></tr>
<tr><td><code id="consensus_matrix_+3A_resample.ratio">resample.ratio</code></td>
<td>
<p>the data ratio to use at each itteration.</p>
</td></tr>
<tr><td><code id="consensus_matrix_+3A_max.itter">max.itter</code></td>
<td>
<p>maximum number of itterations at each <code>max.cluster</code></p>
</td></tr>
<tr><td><code id="consensus_matrix_+3A_clustering.method">clustering.method</code></td>
<td>
<p>base clustering method: <code>c("hclust", "spectral", "pam")</code></p>
</td></tr>
<tr><td><code id="consensus_matrix_+3A_adj.conv">adj.conv</code></td>
<td>
<p>binary value to apply soft thresholding (default=<code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="consensus_matrix_+3A_verbos">verbos</code></td>
<td>
<p>binary value for verbosity (default=<code>TRUE</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>performs data perturbation consensus clustering and obtain consensus matrix
Monti et al. (2003) consensus clustering algorithm
</p>


<h3>Value</h3>

<p>list of consensus matrices for each k
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X = gaussian_clusters()$X
Adj = adj_mat(X, method = "euclidian")
CM = consensus_matrix(Adj, max.cluster=3, max.itter=10, verbos = FALSE)

</code></pre>

<hr>
<h2 id='gaussian_clusters'>Generate clusters of data points from Gaussian distribution with randomly generated parameters</h2><span id='topic+gaussian_clusters'></span>

<h3>Description</h3>

<p>Generate clusters of data points from Gaussian distribution with randomly generated parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussian_clusters(
  n = c(50, 50),
  dim = 2,
  sd.max = 0.1,
  sd.noise = 0.01,
  r.range = c(0.1, 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gaussian_clusters_+3A_n">n</code></td>
<td>
<p>vector of number of data points in each cluster
The length of <code>n</code> should be equal to the number of clusters.</p>
</td></tr>
<tr><td><code id="gaussian_clusters_+3A_dim">dim</code></td>
<td>
<p>number of dimensions</p>
</td></tr>
<tr><td><code id="gaussian_clusters_+3A_sd.max">sd.max</code></td>
<td>
<p>maximum standard deviation of clusters</p>
</td></tr>
<tr><td><code id="gaussian_clusters_+3A_sd.noise">sd.noise</code></td>
<td>
<p>standard deviation of the added noise</p>
</td></tr>
<tr><td><code id="gaussian_clusters_+3A_r.range">r.range</code></td>
<td>
<p>the range (min, max) of distance of cluster centers from the origin</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of data points (X) and cluster labels (class)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data = gaussian_clusters()
X = data$X
y = data$class

</code></pre>

<hr>
<h2 id='gaussian_clusters_with_param'>Generate clusters of data points from Gaussian distribution with given parameters</h2><span id='topic+gaussian_clusters_with_param'></span>

<h3>Description</h3>

<p>Generate clusters of data points from Gaussian distribution with given parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussian_clusters_with_param(n, center, sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gaussian_clusters_with_param_+3A_n">n</code></td>
<td>
<p>vector of number of data points in each cluster
The length of <code>n</code> should be equal to the number of clusters.</p>
</td></tr>
<tr><td><code id="gaussian_clusters_with_param_+3A_center">center</code></td>
<td>
<p>matrix of centers Ncluster x dim</p>
</td></tr>
<tr><td><code id="gaussian_clusters_with_param_+3A_sigma">sigma</code></td>
<td>
<p>list of covariance matrices dim X dim.
The length of sigma should be equal to the number of clusters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of Nsamples x (dim + 1). The last column is cluster labels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>center = rbind(c(0,0),
               c(1,1))
sigma = list(diag(c(1,1)),
             diag(2,2))
gaussian_clusters_with_param(c(10, 10), center, sigma)

</code></pre>

<hr>
<h2 id='gaussian_mixture_clusters'>Generate clusters of data points from Gaussian-mixture-model distributions with randomly generated parameters</h2><span id='topic+gaussian_mixture_clusters'></span>

<h3>Description</h3>

<p>Generate clusters of data points from Gaussian-mixture-model distributions with randomly generated parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussian_mixture_clusters(
  n = c(50, 50),
  dim = 2,
  sd.max = 0.1,
  sd.noise = 0.01,
  r.range = c(0.1, 1),
  mixture.range = c(1, 4),
  mixture.sep = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gaussian_mixture_clusters_+3A_n">n</code></td>
<td>
<p>vector of number of data points in each cluster
The length of <code>n</code> should be equal to the number of clusters.</p>
</td></tr>
<tr><td><code id="gaussian_mixture_clusters_+3A_dim">dim</code></td>
<td>
<p>number of dimensions</p>
</td></tr>
<tr><td><code id="gaussian_mixture_clusters_+3A_sd.max">sd.max</code></td>
<td>
<p>maximum standard deviation of clusters</p>
</td></tr>
<tr><td><code id="gaussian_mixture_clusters_+3A_sd.noise">sd.noise</code></td>
<td>
<p>standard deviation of the added noise</p>
</td></tr>
<tr><td><code id="gaussian_mixture_clusters_+3A_r.range">r.range</code></td>
<td>
<p>the range (min, max) of distance of cluster centers from the origin</p>
</td></tr>
<tr><td><code id="gaussian_mixture_clusters_+3A_mixture.range">mixture.range</code></td>
<td>
<p>range (min, max) of the number of Gaussian-mixtures.</p>
</td></tr>
<tr><td><code id="gaussian_mixture_clusters_+3A_mixture.sep">mixture.sep</code></td>
<td>
<p>scaler indicating the separability between the mixtures.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of data points (X) and cluster labels (class)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data = gaussian_mixture_clusters()
X = data$X
y = data$class

</code></pre>

<hr>
<h2 id='generate_gaussian_data'>Generate a set of data points from Gaussian distribution</h2><span id='topic+generate_gaussian_data'></span>

<h3>Description</h3>

<p>Generate a set of data points from Gaussian distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_gaussian_data(n, center = 0, sigma = 1, label = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_gaussian_data_+3A_n">n</code></td>
<td>
<p>number of generated data points</p>
</td></tr>
<tr><td><code id="generate_gaussian_data_+3A_center">center</code></td>
<td>
<p>data center of desired dimension</p>
</td></tr>
<tr><td><code id="generate_gaussian_data_+3A_sigma">sigma</code></td>
<td>
<p>covariance matrix</p>
</td></tr>
<tr><td><code id="generate_gaussian_data_+3A_label">label</code></td>
<td>
<p>cluster label</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Generated data points from Gaussian distribution with given parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>generate_gaussian_data(10, center=c(0,0), sigma=diag(c(1,1)), label=1)


</code></pre>

<hr>
<h2 id='hir_clust_from_adj_mat'>Hierarchical clustering from adjacency matrix</h2><span id='topic+hir_clust_from_adj_mat'></span>

<h3>Description</h3>

<p>Hierarchical clustering from adjacency matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hir_clust_from_adj_mat(
  adj.mat,
  k = 2,
  alpha = 1,
  adj.conv = TRUE,
  method = "ward.D"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hir_clust_from_adj_mat_+3A_adj.mat">adj.mat</code></td>
<td>
<p>adjacency matrix</p>
</td></tr>
<tr><td><code id="hir_clust_from_adj_mat_+3A_k">k</code></td>
<td>
<p>number of clusters (default=2)</p>
</td></tr>
<tr><td><code id="hir_clust_from_adj_mat_+3A_alpha">alpha</code></td>
<td>
<p>soft threshold (considered if <code>adj.conv = TRUE</code>) (default=1)</p>
</td></tr>
<tr><td><code id="hir_clust_from_adj_mat_+3A_adj.conv">adj.conv</code></td>
<td>
<p>binary value to apply soft thresholding (default=TRUE)</p>
</td></tr>
<tr><td><code id="hir_clust_from_adj_mat_+3A_method">method</code></td>
<td>
<p>distance method (default: <code>ward.D</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>apply PAM (k-medoids) clustering on the adjacency matrix
</p>


<h3>Value</h3>

<p>vector of clusters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Adj_mat = rbind(c(0.0,0.9,0.0),
                c(0.9,0.0,0.2),
                c(0.0,0.2,0.0))
hir_clust_from_adj_mat(Adj_mat)

</code></pre>

<hr>
<h2 id='indicator_matrix'>Build indicator matrix</h2><span id='topic+indicator_matrix'></span>

<h3>Description</h3>

<p>Build indicator matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indicator_matrix(clusters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="indicator_matrix_+3A_clusters">clusters</code></td>
<td>
<p>a vector of clusterings. Zero elements mean that the sample was absent
during clustering</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Indicator matrix (I) is a binary matrix N-by-N
I[i,j] = 1 if sample i and j co-exist for clustering
ref: Monti et al. (2003) &quot;Consensus Clustering: A Resampling-Based Method for
Class Discovery and Visualization of Gene Expression Microarray Data&quot;, Machine Learning
</p>


<h3>Value</h3>

<p>Indicator matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ind_mat = indicator_matrix(c(1,1,1,0,0,1))

</code></pre>

<hr>
<h2 id='lebel_similarity'>Similarity between different clusters</h2><span id='topic+lebel_similarity'></span>

<h3>Description</h3>

<p>Similarity between different clusters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lebel_similarity(x1, x2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lebel_similarity_+3A_x1">x1</code></td>
<td>
<p>clustering vector 1
Zero elements are are considered as unclustered samples</p>
</td></tr>
<tr><td><code id="lebel_similarity_+3A_x2">x2</code></td>
<td>
<p>clustering vector 2
Zero elements are are considered as unclustered samples</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When performing performing several clustering, the cluster labels may no match with each other.
To find correspondences between clusters, the similarity between different labels need to be calculated.
</p>


<h3>Value</h3>

<p>matrix of similarities between clustering labels
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X = gaussian_clusters()$X
x1 = kmeans(X, 5)$cluster
x2 = kmeans(X, 5)$cluster
Sim = lebel_similarity(x1, x2)

</code></pre>

<hr>
<h2 id='Logit'>Logit function</h2><span id='topic+Logit'></span>

<h3>Description</h3>

<p>Logit function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Logit(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Logit_+3A_x">x</code></td>
<td>
<p>numerical scaler input</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logit(x) = log(1*x/(1-x))
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y = Logit(0.5)

</code></pre>

<hr>
<h2 id='majority_voting'>Consensus mechanism based on majority voting</h2><span id='topic+majority_voting'></span>

<h3>Description</h3>

<p>Consensus mechanism based on majority voting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>majority_voting(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="majority_voting_+3A_x">X</code></td>
<td>
<p>clustering matrix of Nsamples x Nclusterings.
Zero elements are are considered as unclustered samples</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Perform majority voting as a consensus mechanism.
</p>


<h3>Value</h3>

<p>the vector of consensus clustering result
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X = gaussian_clusters()$X
x1 = kmeans(X, 5)$cluster
x2 = kmeans(X, 5)$cluster
x3 = kmeans(X, 5)$cluster
clusters = majority_voting(cbind(x1,x2,x3))

</code></pre>

<hr>
<h2 id='multi_cluster_gen'>Multiple cluster generation</h2><span id='topic+multi_cluster_gen'></span>

<h3>Description</h3>

<p>Multiple cluster generation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multi_cluster_gen(X, func, rep = 10, param, method = "random")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multi_cluster_gen_+3A_x">X</code></td>
<td>
<p>input data Nsample x Nfeatures or a distance matrix</p>
</td></tr>
<tr><td><code id="multi_cluster_gen_+3A_func">func</code></td>
<td>
<p>custom function that accepts <code>X</code> and a parameter that return a vector of clusterings.
<code>cluster_func &lt;- function(X, param)</code></p>
</td></tr>
<tr><td><code id="multi_cluster_gen_+3A_rep">rep</code></td>
<td>
<p>number of repeats</p>
</td></tr>
<tr><td><code id="multi_cluster_gen_+3A_param">param</code></td>
<td>
<p>vector of parameters</p>
</td></tr>
<tr><td><code id="multi_cluster_gen_+3A_method">method</code></td>
<td>
<p>method for the choice of k at each repeat <code>c("random", "silhouette")</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>At each repeat, k is selected randomly or based on the best silhouette width from a discrete uniform distribution between range.k[1] and range.k[2].
Then clustering is applied and result is returned.
</p>


<h3>Value</h3>

<p>matrix of clusterings Nsample x Nrepeat
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X = gaussian_clusters()$X
cluster_func = function(X, k){return(stats::kmeans(X, k)$cluster)}
Clusters = multi_cluster_gen(X, cluster_func, param = c(2,3))


</code></pre>

<hr>
<h2 id='multi_kmeans_gen'>Multiple K-means generation</h2><span id='topic+multi_kmeans_gen'></span>

<h3>Description</h3>

<p>Multiple K-means generation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multi_kmeans_gen(X, rep = 10, range.k = c(2, 5), method = "random")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multi_kmeans_gen_+3A_x">X</code></td>
<td>
<p>input data Nsample x Nfeatures</p>
</td></tr>
<tr><td><code id="multi_kmeans_gen_+3A_rep">rep</code></td>
<td>
<p>number of repeats</p>
</td></tr>
<tr><td><code id="multi_kmeans_gen_+3A_range.k">range.k</code></td>
<td>
<p>vector of minimum and maximum values for k <code>c(min, max)</code></p>
</td></tr>
<tr><td><code id="multi_kmeans_gen_+3A_method">method</code></td>
<td>
<p>method for the choice of k at each repeat <code>c("random", "silhouette")</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>At each repeat, k is selected randomly or based on the best silhouette width from a discrete uniform distribution between range.k[1] and range.k[2].
Then k-means clustering is applied and result is returned.
</p>


<h3>Value</h3>

<p>matrix of clusterings Nsample x Nrepeat
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X = gaussian_clusters()$X
Clusters = multi_kmeans_gen(X)

</code></pre>

<hr>
<h2 id='multi_pam_gen'>Multiple PAM (K-medoids) generation</h2><span id='topic+multi_pam_gen'></span>

<h3>Description</h3>

<p>Multiple PAM (K-medoids) generation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multi_pam_gen(
  X,
  rep = 10,
  range.k = c(2, 5),
  is.distance = FALSE,
  method = "random"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multi_pam_gen_+3A_x">X</code></td>
<td>
<p>input data Nsample x Nfeatures or distance matrix.</p>
</td></tr>
<tr><td><code id="multi_pam_gen_+3A_rep">rep</code></td>
<td>
<p>number of repeats</p>
</td></tr>
<tr><td><code id="multi_pam_gen_+3A_range.k">range.k</code></td>
<td>
<p>vector of minimum and maximum values for k <code>c(min, max)</code></p>
</td></tr>
<tr><td><code id="multi_pam_gen_+3A_is.distance">is.distance</code></td>
<td>
<p>binary balue indicating if the input <code>X</code> is distance</p>
</td></tr>
<tr><td><code id="multi_pam_gen_+3A_method">method</code></td>
<td>
<p>method for the choice of k at each repeat <code>c("random", "silhouette")</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>At each repeat, k is selected randomly or based on the best silhouette width from a discrete uniform distribution between range.k[1] and range.k[2].
Then PAM clustering is applied and result is returned.
</p>


<h3>Value</h3>

<p>matrix of clusterings Nsample x Nrepeat
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X = gaussian_clusters()$X
Clusters = multi_pam_gen(X)

</code></pre>

<hr>
<h2 id='multiview_cluster_gen'>Multiview cluster generation</h2><span id='topic+multiview_cluster_gen'></span>

<h3>Description</h3>

<p>Multiview cluster generation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiview_cluster_gen(
  X,
  func,
  rep = 10,
  param,
  is.distance = FALSE,
  sample.set = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiview_cluster_gen_+3A_x">X</code></td>
<td>
<p>List of input data matrices of Sample x feature or distance matrices.
The length of <code>X</code> is equal to Nviews</p>
</td></tr>
<tr><td><code id="multiview_cluster_gen_+3A_func">func</code></td>
<td>
<p>custom function that accepts <code>X</code> and a parameter that return a vector of clusterings.
<code>cluster_func &lt;- function(X, param)</code></p>
</td></tr>
<tr><td><code id="multiview_cluster_gen_+3A_rep">rep</code></td>
<td>
<p>number of repeats</p>
</td></tr>
<tr><td><code id="multiview_cluster_gen_+3A_param">param</code></td>
<td>
<p>vector of parameters</p>
</td></tr>
<tr><td><code id="multiview_cluster_gen_+3A_is.distance">is.distance</code></td>
<td>
<p>binary balue indicating if the input <code>X[i]</code> is distance</p>
</td></tr>
<tr><td><code id="multiview_cluster_gen_+3A_sample.set">sample.set</code></td>
<td>
<p>vector of samples the clustering is being applied on. can be names or indices.
if <code>sample.set</code> is <code>NA</code>, it considers all the datasets have the same samples with the same order</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At each repeat, k is selected randomly or based on the best silhouette width from a discrete uniform distribution between range.k[1] and range.k[2].
Then clustering is applied and result is returned.
</p>


<h3>Value</h3>

<p>matrix of clusterings Nsample x (Nrepeat x Nviews)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data = multiview_clusters (n = c(40,40,40), hidden.dim = 2, observed.dim = c(2,2,2),
sd.max = .1, sd.noise = 0, hidden.r.range = c(.5,1))
X_observation = data[["observation"]]
cluster_func = function(X,rep,param){return(multi_kmeans_gen(X,rep=rep,range.k=param))}
Clusters = multiview_cluster_gen(X_observation, func = cluster_func, rep = 10, param = c(2,4))

</code></pre>

<hr>
<h2 id='multiview_clusters'>Generate multiview clusters from Gaussian distributions with randomly generated parameters</h2><span id='topic+multiview_clusters'></span>

<h3>Description</h3>

<p>Generate multiview clusters from Gaussian distributions with randomly generated parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiview_clusters(
  n = c(50, 50),
  hidden.dim = 2,
  observed.dim = c(2, 2, 3),
  sd.max = 0.1,
  sd.noise = 0.01,
  hidden.r.range = c(0.1, 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiview_clusters_+3A_n">n</code></td>
<td>
<p>vector of number of data points in each cluster
The length of <code>n</code> should be equal to the number of clusters.</p>
</td></tr>
<tr><td><code id="multiview_clusters_+3A_hidden.dim">hidden.dim</code></td>
<td>
<p>scaler value of dimensions of the hidden state</p>
</td></tr>
<tr><td><code id="multiview_clusters_+3A_observed.dim">observed.dim</code></td>
<td>
<p>vector of number of dimensions of the generate clusters.
The length of <code>observed.dim</code> should be equal to the number of clusters.</p>
</td></tr>
<tr><td><code id="multiview_clusters_+3A_sd.max">sd.max</code></td>
<td>
<p>maximum standard deviation of clusters</p>
</td></tr>
<tr><td><code id="multiview_clusters_+3A_sd.noise">sd.noise</code></td>
<td>
<p>standard deviation of the added noise</p>
</td></tr>
<tr><td><code id="multiview_clusters_+3A_hidden.r.range">hidden.r.range</code></td>
<td>
<p>the range (min, max) of distance of cluster centers from the origin in the hidden space.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of data points (X) and cluster labels (class)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data = multiview_clusters()

</code></pre>

<hr>
<h2 id='multiview_consensus_matrix'>Calculate consensus matrix for multi-data consensus clustering</h2><span id='topic+multiview_consensus_matrix'></span>

<h3>Description</h3>

<p>Calculate consensus matrix for multi-data consensus clustering
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiview_consensus_matrix(
  X,
  max.cluster = 5,
  sample.set = NA,
  clustering.method = "hclust",
  adj.conv = TRUE,
  verbos = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiview_consensus_matrix_+3A_x">X</code></td>
<td>
<p>list of adjacency matrices for different cohorts (or views).</p>
</td></tr>
<tr><td><code id="multiview_consensus_matrix_+3A_max.cluster">max.cluster</code></td>
<td>
<p>maximum number of clusters</p>
</td></tr>
<tr><td><code id="multiview_consensus_matrix_+3A_sample.set">sample.set</code></td>
<td>
<p>vector of samples the clustering is being applied on. <code>sample.set</code> can be names or indices.
if <code>sample.set</code> is <code>NA</code>, it considers that all the datasets have the same samples with the same order.</p>
</td></tr>
<tr><td><code id="multiview_consensus_matrix_+3A_clustering.method">clustering.method</code></td>
<td>
<p>base clustering method: <code>c("hclust", "spectral", "pam")</code></p>
</td></tr>
<tr><td><code id="multiview_consensus_matrix_+3A_adj.conv">adj.conv</code></td>
<td>
<p>binary value to apply soft threshold (default=<code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="multiview_consensus_matrix_+3A_verbos">verbos</code></td>
<td>
<p>binary value for verbosity (default=<code>TRUE</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>performs multi-data consensus clustering and obtain consensus matrix
Monti et al. (2003) consensus clustering algorithm
</p>


<h3>Value</h3>

<p>description list of consensus matrices for each k
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data = multiview_clusters (n = c(40,40,40), hidden.dim = 2, observed.dim = c(2,2,2),
sd.max = .1, sd.noise = 0, hidden.r.range = c(.5,1))
X_observation = data[["observation"]]
Adj = list()
for (i in 1:length(X_observation))
  Adj[[i]] = adj_mat(X_observation[[i]], method = "euclidian")
CM = multiview_consensus_matrix(Adj, max.cluster = 4, verbos = FALSE)

</code></pre>

<hr>
<h2 id='multiview_kmeans_gen'>Multiview K-means generation</h2><span id='topic+multiview_kmeans_gen'></span>

<h3>Description</h3>

<p>Multiview K-means generation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiview_kmeans_gen(X, rep = 10, range.k = c(2, 5), method = "random")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiview_kmeans_gen_+3A_x">X</code></td>
<td>
<p>List of input data matrices of Sample x feature. The length of <code>X</code> is equal to Nviews</p>
</td></tr>
<tr><td><code id="multiview_kmeans_gen_+3A_rep">rep</code></td>
<td>
<p>number of repeats</p>
</td></tr>
<tr><td><code id="multiview_kmeans_gen_+3A_range.k">range.k</code></td>
<td>
<p>vector of minimum and maximum values for k <code>c(min, max)</code></p>
</td></tr>
<tr><td><code id="multiview_kmeans_gen_+3A_method">method</code></td>
<td>
<p>method for the choice of k at each repeat <code>c("random", "silhouette")</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>At each repeat, k is selected randomly or based on the best silhouette width from a discrete uniform distribution between range.k[1] and range.k[2].
Then k-means clustering is applied and result is returned.
</p>


<h3>Value</h3>

<p>matrix of clusterings Nsample x (Nrepeat x Nviews)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data = multiview_clusters (n = c(40,40,40), hidden.dim = 2, observed.dim = c(2,2,2),
sd.max = .1, sd.noise = 0, hidden.r.range = c(.5,1))
X_observation = data[["observation"]]
Clusters = multiview_kmeans_gen(X_observation)

</code></pre>

<hr>
<h2 id='multiview_pam_gen'>Multiview PAM (K-medoids) generation</h2><span id='topic+multiview_pam_gen'></span>

<h3>Description</h3>

<p>Multiview PAM (K-medoids) generation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiview_pam_gen(
  X,
  rep = 10,
  range.k = c(2, 5),
  is.distance = FALSE,
  method = "random",
  sample.set = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiview_pam_gen_+3A_x">X</code></td>
<td>
<p>List of input data matrices of Sample x feature or distance matrices.
The length of <code>X</code> is equal to Nviews</p>
</td></tr>
<tr><td><code id="multiview_pam_gen_+3A_rep">rep</code></td>
<td>
<p>number of repeats</p>
</td></tr>
<tr><td><code id="multiview_pam_gen_+3A_range.k">range.k</code></td>
<td>
<p>vector of minimum and maximum values for k <code>c(min, max)</code></p>
</td></tr>
<tr><td><code id="multiview_pam_gen_+3A_is.distance">is.distance</code></td>
<td>
<p>binary balue indicating if the input <code>X</code> is distance</p>
</td></tr>
<tr><td><code id="multiview_pam_gen_+3A_method">method</code></td>
<td>
<p>method for the choice of k at each repeat <code>c("random", "silhouette")</code></p>
</td></tr>
<tr><td><code id="multiview_pam_gen_+3A_sample.set">sample.set</code></td>
<td>
<p>vector of samples the clustering is being applied on. can be names or indices.
if <code>sample.set</code> is <code>NA</code>, it considers all the datasets have the same samples with the same order</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At each repeat, k is selected randomly or based on the best silhouette width from a discrete uniform distribution between range.k[1] and range.k[2].
Then PAM clustering is applied and result is returned.
</p>


<h3>Value</h3>

<p>matrix of clusterings Nsample x (Nrepeat x Nviews)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data = multiview_clusters (n = c(40,40,40), hidden.dim = 2, observed.dim = c(2,2,2),
sd.max = .1, sd.noise = 0, hidden.r.range = c(.5,1))
X_observation = data[["observation"]]
Clusters = multiview_pam_gen(X_observation)

</code></pre>

<hr>
<h2 id='pam_clust_from_adj_mat'>PAM (k-medoids) clustering from adjacency matrix</h2><span id='topic+pam_clust_from_adj_mat'></span>

<h3>Description</h3>

<p>PAM (k-medoids) clustering from adjacency matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pam_clust_from_adj_mat(adj.mat, k = 2, alpha = 1, adj.conv = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pam_clust_from_adj_mat_+3A_adj.mat">adj.mat</code></td>
<td>
<p>adjacency matrix</p>
</td></tr>
<tr><td><code id="pam_clust_from_adj_mat_+3A_k">k</code></td>
<td>
<p>number of clusters (default=2)</p>
</td></tr>
<tr><td><code id="pam_clust_from_adj_mat_+3A_alpha">alpha</code></td>
<td>
<p>soft threshold (considered if <code>adj.conv = TRUE</code>) (default=1)</p>
</td></tr>
<tr><td><code id="pam_clust_from_adj_mat_+3A_adj.conv">adj.conv</code></td>
<td>
<p>binary value to apply soft thresholding (default=TRUE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>apply PAM (k-medoids) clustering on the adjacency matrix
</p>


<h3>Value</h3>

<p>vector of clusters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Adj_mat = rbind(c(0.0,0.9,0.0),
                c(0.9,0.0,0.2),
                c(0.0,0.2,0.0))
pam_clust_from_adj_mat(Adj_mat)

</code></pre>

<hr>
<h2 id='spect_clust_from_adj_mat'>Spectral clustering from adjacency matrix</h2><span id='topic+spect_clust_from_adj_mat'></span>

<h3>Description</h3>

<p>Spectral clustering from adjacency matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spect_clust_from_adj_mat(
  adj.mat,
  k = 2,
  max.eig = 10,
  alpha = 1,
  adj.conv = TRUE,
  do.plot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spect_clust_from_adj_mat_+3A_adj.mat">adj.mat</code></td>
<td>
<p>adjacency matrix</p>
</td></tr>
<tr><td><code id="spect_clust_from_adj_mat_+3A_k">k</code></td>
<td>
<p>number of clusters (default=2)</p>
</td></tr>
<tr><td><code id="spect_clust_from_adj_mat_+3A_max.eig">max.eig</code></td>
<td>
<p>maximum number of eigenvectors in use (dafaut = 10).</p>
</td></tr>
<tr><td><code id="spect_clust_from_adj_mat_+3A_alpha">alpha</code></td>
<td>
<p>soft threshold (considered if <code>adj.conv = TRUE</code>) (default = 1)</p>
</td></tr>
<tr><td><code id="spect_clust_from_adj_mat_+3A_adj.conv">adj.conv</code></td>
<td>
<p>binary value to apply soft thresholding (default = <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="spect_clust_from_adj_mat_+3A_do.plot">do.plot</code></td>
<td>
<p>binary value to do plot (dafaut = <code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>apply PAM (k-medoids) clustering on the adjacency matrix
</p>


<h3>Value</h3>

<p>vector of clusters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Adj_mat = rbind(c(0.0,0.9,0.0),
                c(0.9,0.0,0.2),
                c(0.0,0.2,0.0))
hir_clust_from_adj_mat(Adj_mat)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
