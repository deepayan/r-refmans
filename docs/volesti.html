<!DOCTYPE html><html lang="en"><head><title>Help for package volesti</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {volesti}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#compute_indicators'><p>Compute an indicator for each time period that describes the state of a market.</p></a></li>
<li><a href='#copula'><p>Construct a copula using uniform sampling from the unit simplex</p></a></li>
<li><a href='#direct_sampling'><p>Sample perfect uniformly distributed points from well known convex bodies: (a) the unit simplex, (b) the canonical simplex, (c) the boundary of a hypersphere or (d) the interior of a hypersphere.</p></a></li>
<li><a href='#exact_vol'><p>Compute the exact volume of (a) a zonotope (b) an arbitrary simplex in V-representation or (c) if the volume is known and declared by the input object.</p></a></li>
<li><a href='#frustum_of_simplex'><p>Compute the percentage of the volume of the simplex that is contained in the intersection of a half-space and the simplex.</p></a></li>
<li><a href='#gen_cross'><p>Generator function for cross polytopes</p></a></li>
<li><a href='#gen_cube'><p>Generator function for hypercubes</p></a></li>
<li><a href='#gen_prod_simplex'><p>Generator function for product of simplices</p></a></li>
<li><a href='#gen_rand_hpoly'><p>Generator function for random H-polytopes</p></a></li>
<li><a href='#gen_rand_vpoly'><p>Generator function for random V-polytopes</p></a></li>
<li><a href='#gen_rand_zonotope'><p>Generator function for zonotopes</p></a></li>
<li><a href='#gen_simplex'><p>Generator function for simplices</p></a></li>
<li><a href='#gen_skinny_cube'><p>Generator function for skinny hypercubes</p></a></li>
<li><a href='#Hpolytope-class'><p>An R class to represent an H-polytope</p></a></li>
<li><a href='#inner_ball'><p>Compute an inscribed ball of a convex polytope</p></a></li>
<li><a href='#load_sdpa_format_file'><p>An internal Rccp function to read a SDPA format file</p></a></li>
<li><a href='#poly_gen'><p>An internal Rccp function as a polytope generator</p></a></li>
<li><a href='#read_sdpa_format_file'><p>Read a SDPA format file</p></a></li>
<li><a href='#rotate_polytope'><p>Apply a random rotation to a convex polytope (H-polytope, V-polytope, zonotope or intersection of two V-polytopes)</p></a></li>
<li><a href='#rotating'><p>An internal Rccp function for the random rotation of a convex polytope</p></a></li>
<li><a href='#round_polytope'><p>Apply rounding to a convex polytope (H-polytope, V-polytope or a zonotope)</p></a></li>
<li><a href='#rounding'><p>Internal rcpp function for the rounding of a convex polytope</p></a></li>
<li><a href='#sample_points'><p>Sample uniformly or normally distributed points from a convex Polytope (H-polytope, V-polytope, zonotope or intersection of two V-polytopes).</p></a></li>
<li><a href='#Spectrahedron-class'><p>An R class to represent a Spectrahedron</p></a></li>
<li><a href='#volume'><p>The main function for volume approximation of a convex Polytope (H-polytope, V-polytope, zonotope or intersection of two V-polytopes)</p></a></li>
<li><a href='#Vpolytope-class'><p>An R class to represent a V-polytope</p></a></li>
<li><a href='#VpolytopeIntersection-class'><p>An R class to represent the intersection of two V-polytopes</p></a></li>
<li><a href='#write_sdpa_format_file'><p>Write a SDPA format file</p></a></li>
<li><a href='#zono_approx'><p>An internal Rccp function for the over-approximation of a zonotope</p></a></li>
<li><a href='#zonotope_approximation'><p>A function to over-approximate a zonotope with PCA method and to evaluate the approximation by computing a ratio of fitness.</p></a></li>
<li><a href='#Zonotope-class'><p>An R class to represent a Zonotope</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a></td>
</tr>
<tr>
<td>Title:</td>
<td>Volume Approximation and Sampling of Convex Polytopes</td>
</tr>
<tr>
<td>Copyright:</td>
<td>file inst/COPYRIGHTS</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides an R interface for 'volesti' C++ package. 'volesti' computes estimations of volume
             of polytopes given by (i) a set of points, (ii) linear inequalities or (iii) Minkowski sum of segments
             (a.k.a. zonotopes). There are three algorithms for volume estimation as well as algorithms
             for sampling, rounding and rotating polytopes. Moreover, 'volesti' provides algorithms for
             estimating copulas useful in computational finance. Methods implemented in 'volesti' are described
             in A. Chalkis and V. Fisikopoulos (2022) &lt;<a href="https://doi.org/10.32614%2FRJ-2021-077">doi:10.32614/RJ-2021-077</a>&gt; and references therein.</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.2-8</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-10-7</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Vissarion Fisikopoulos &lt;vissarion.fisikopoulos@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>Rcpp (&ge; 0.12.17)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, stats</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen, BH</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/GeomScale/volesti/issues">https://github.com/GeomScale/volesti/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-10-09 07:13:22 UTC; vissarion</td>
</tr>
<tr>
<td>Author:</td>
<td>Vissarion Fisikopoulos
    <a href="https://orcid.org/0000-0002-0780-666X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre,
    cph],
  Apostolos Chalkis <a href="https://orcid.org/0000-0002-4628-1907"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-10-09 08:30:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='compute_indicators'>Compute an indicator for each time period that describes the state of a market.</h2><span id='topic+compute_indicators'></span>

<h3>Description</h3>

<p>Given a matrix that contains row-wise the assets' returns and a sliding window <code>win_length</code>, this function computes an approximation of the joint distribution (copula, e.g. see <a href="https://en.wikipedia.org/wiki/Copula_(probability_theory)">https://en.wikipedia.org/wiki/Copula_(probability_theory)</a>) between portfolios' return and volatility in each time period defined by <code>win_len</code>.
For each copula it computes an indicator: If the indicator is large it corresponds to a crisis period and if it is small it corresponds to a normal period.
In particular, the periods over which the indicator is greater than 1 for more than 60 consecutive sliding windows are warnings and for more than 100 are crisis. The sliding window is shifted by one day.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_indicators(
  returns,
  parameters = list(win_length = 60, m = 100, n = 5e+05, nwarning = 60, ncrisis = 100)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_indicators_+3A_returns">returns</code></td>
<td>
<p>A <code class="reqn">d</code>-dimensional vector that describes the direction of the first family of parallel hyperplanes.</p>
</td></tr>
<tr><td><code id="compute_indicators_+3A_parameters">parameters</code></td>
<td>
<p>A list to set a parameterization.
</p>

<dl>
<dt>win_length</dt><dd><p>The length of the sliding window. The default value is 60.</p>
</dd>
<dt>m</dt><dd><p>The number of slices for the copula. The default value is 100.</p>
</dd>
<dt>n</dt><dd><p>The number of points to sample. The default value is <code class="reqn">5\cdot 10^5</code>.</p>
</dd>
<dt>nwarning</dt><dd><p>The number of consecutive indicators larger than 1 required to declare a warning period. The default value is 60.</p>
</dd>
<dt>ncrisis</dt><dd><p>The number of consecutive indicators larger than 1 required to declare a crisis period. The default value is 100.</p>
</dd>
<dt>seed</dt><dd><p>A fixed seed for the number generator.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>A list that contains the indicators and the corresponding vector that label each time period with respect to the market state: a) normal, b) crisis, c) warning.
</p>


<h3>References</h3>

<p><cite>L. Cales, A. Chalkis, I.Z. Emiris, V. Fisikopoulos,
&ldquo;Practical volume computation of structured convex bodies, and an application to modeling portfolio dependencies and financial crises,&rdquo; <em>Proc. of Symposium on Computational Geometry, Budapest, Hungary,</em> 2018.</cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simple example on random asset returns
asset_returns = replicate(10, rnorm(14))
market_states_and_indicators = compute_indicators(asset_returns,
    parameters = list("win_length" = 10, "m" = 10, "n" = 10000, "nwarning" = 2, "ncrisis" = 3))

</code></pre>

<hr>
<h2 id='copula'>Construct a copula using uniform sampling from the unit simplex</h2><span id='topic+copula'></span>

<h3>Description</h3>

<p>Given two families of parallel hyperplanes or a family of parallel hyperplanes and a family of concentric ellispoids centered at the origin intersecting the canonical simplex, this function uniformly samples from the canonical simplex and construct an approximation of the bivariate probability distribution, called copula (see <a href="https://en.wikipedia.org/wiki/Copula_(probability_theory)">https://en.wikipedia.org/wiki/Copula_(probability_theory)</a>).
At least two families of hyperplanes or one family of hyperplanes and one family of ellipsoids have to be given as input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>copula(r1, r2 = NULL, sigma = NULL, m = NULL, n = NULL, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="copula_+3A_r1">r1</code></td>
<td>
<p>The <code class="reqn">d</code>-dimensional normal vector of the first family of parallel hyperplanes.</p>
</td></tr>
<tr><td><code id="copula_+3A_r2">r2</code></td>
<td>
<p>Optional. The <code class="reqn">d</code>-dimensional normal vector of the second family of parallel hyperplanes.</p>
</td></tr>
<tr><td><code id="copula_+3A_sigma">sigma</code></td>
<td>
<p>Optional. The <code class="reqn">d\times d</code> symmetric positive semidefine matrix that describes the family of concentric ellipsoids centered at the origin.</p>
</td></tr>
<tr><td><code id="copula_+3A_m">m</code></td>
<td>
<p>The number of the slices for the copula. The default value is 100.</p>
</td></tr>
<tr><td><code id="copula_+3A_n">n</code></td>
<td>
<p>The number of points to sample. The default value is <code class="reqn">5\cdot 10^5</code>.</p>
</td></tr>
<tr><td><code id="copula_+3A_seed">seed</code></td>
<td>
<p>Optional. A fixed seed for the number generator.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code class="reqn">m\times m</code> numerical matrix that corresponds to a copula.
</p>


<h3>References</h3>

<p><cite>L. Cales, A. Chalkis, I.Z. Emiris, V. Fisikopoulos,
&ldquo;Practical volume computation of structured convex bodies, and an application to modeling portfolio dependencies and financial crises,&rdquo; <em>Proc. of Symposium on Computational Geometry, Budapest, Hungary,</em> 2018.</cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># compute a copula for two random families of parallel hyperplanes
h1 = runif(n = 10, min = 1, max = 1000)
h1 = h1 / 1000
h2=runif(n = 10, min = 1, max = 1000)
h2 = h2 / 1000
cop = copula(r1 = h1, r2 = h2, m = 10, n = 100000)

# compute a copula for a family of parallel hyperplanes and a family of conentric ellipsoids
h = runif(n = 10, min = 1, max = 1000)
h = h / 1000
E = replicate(10, rnorm(20))
E = cov(E)
cop = copula(r1 = h, sigma = E, m = 10, n = 100000)

</code></pre>

<hr>
<h2 id='direct_sampling'>Sample perfect uniformly distributed points from well known convex bodies: (a) the unit simplex, (b) the canonical simplex, (c) the boundary of a hypersphere or (d) the interior of a hypersphere.</h2><span id='topic+direct_sampling'></span>

<h3>Description</h3>

<p>The <code class="reqn">d</code>-dimensional unit simplex is the set of points <code class="reqn">\vec{x}\in \R^d</code>, s.t.: <code class="reqn">\sum_i x_i\leq 1</code>, <code class="reqn">x_i\geq 0</code>. The <code class="reqn">d</code>-dimensional canonical simplex is the set of points <code class="reqn">\vec{x}\in \R^d</code>, s.t.: <code class="reqn">\sum_i x_i = 1</code>, <code class="reqn">x_i\geq 0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>direct_sampling(body, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="direct_sampling_+3A_body">body</code></td>
<td>
<p>A list to request exact uniform sampling from special well known convex bodies through the following input parameters:
</p>

<dl>
<dt><code>type</code> </dt><dd><p> A string that declares the type of the body for the exact sampling: a) <code>'unit_simplex'</code> for the unit simplex, b) <code>'canonical_simplex'</code> for the canonical simplex, c) <code>'hypersphere'</code> for the boundary of a hypersphere centered at the origin, d) <code>'ball'</code> for the interior of a hypersphere centered at the origin.</p>
</dd>
<dt><code>dimension</code> </dt><dd><p> An integer that declares the dimension when exact sampling is enabled for a simplex or a hypersphere.</p>
</dd>
<dt><code>radius</code> </dt><dd><p> The radius of the <code class="reqn">d</code>-dimensional hypersphere. The default value is <code class="reqn">1</code>.</p>
</dd>
<dt><code>seed</code> </dt><dd><p> A fixed seed for the number generator.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="direct_sampling_+3A_n">n</code></td>
<td>
<p>The number of points that the function is going to sample.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code class="reqn">d\times n</code> matrix that contains, column-wise, the sampled points from the convex polytope P.
</p>


<h3>References</h3>

<p><cite>R.Y. Rubinstein and B. Melamed,
&ldquo;Modern simulation and modeling&rdquo; <em> Wiley Series in Probability and Statistics,</em> 1998.</cite>
</p>
<p><cite>A Smith, Noah and W Tromble, Roy,
&ldquo;Sampling Uniformly from the Unit Simplex,&rdquo; <em> Center for Language and Speech Processing Johns Hopkins University,</em> 2004.</cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 100 uniform points from the 2-d unit ball
points = direct_sampling(n = 100, body = list("type" = "ball", "dimension" = 2))
</code></pre>

<hr>
<h2 id='exact_vol'>Compute the exact volume of (a) a zonotope (b) an arbitrary simplex in V-representation or (c) if the volume is known and declared by the input object.</h2><span id='topic+exact_vol'></span>

<h3>Description</h3>

<p>Given a zonotope (as an object of class Zonotope), this function computes the sum of the absolute values of the determinants of all the <code class="reqn">d \times d</code> submatrices of the <code class="reqn">m\times d</code> matrix <code class="reqn">G</code> that contains row-wise the <code class="reqn">m</code> <code class="reqn">d</code>-dimensional segments that define the zonotope.
For an arbitrary simplex that is given in V-representation this function computes the absolute value of the determinant formed by the simplex's points assuming it is shifted to the origin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exact_vol(P)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="exact_vol_+3A_p">P</code></td>
<td>
<p>A polytope</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The exact volume of the input polytope, for zonotopes, simplices in V-representation and polytopes with known exact volume
</p>


<h3>References</h3>

<p><cite>E. Gover and N. Krikorian,
&ldquo;Determinants and the Volumes of Parallelotopes and Zonotopes,&rdquo; <em>Linear Algebra and its Applications, 433(1), 28 - 40,</em> 2010.</cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# compute the exact volume of a 5-dimensional zonotope defined by the Minkowski sum of 10 segments
Z = gen_rand_zonotope(2, 5)
vol = exact_vol(Z)

# compute the exact volume of a 2-d arbitrary simplex
V = matrix(c(2,3,-1,7,0,0),ncol = 2, nrow = 3, byrow = TRUE)
P = Vpolytope(V = V)
vol = exact_vol(P)


# compute the exact volume the 10-dimensional cross polytope
P = gen_cross(10,'V')
vol = exact_vol(P)
</code></pre>

<hr>
<h2 id='frustum_of_simplex'>Compute the percentage of the volume of the simplex that is contained in the intersection of a half-space and the simplex.</h2><span id='topic+frustum_of_simplex'></span>

<h3>Description</h3>

<p>A half-space <code class="reqn">H</code> is given as a pair of a vector <code class="reqn">a\in R^d</code> and a scalar <code class="reqn">z0\in R</code> s.t.: <code class="reqn">a^Tx\leq z0</code>. This function calls the Ali's version of the Varsi formula to compute a frustum of the simplex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frustum_of_simplex(a, z0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="frustum_of_simplex_+3A_a">a</code></td>
<td>
<p>A <code class="reqn">d</code>-dimensional vector that defines the direction of the hyperplane.</p>
</td></tr>
<tr><td><code id="frustum_of_simplex_+3A_z0">z0</code></td>
<td>
<p>The scalar that defines the half-space.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The percentage of the volume of the simplex that is contained in the intersection of a given half-space and the simplex.
</p>


<h3>References</h3>

<p><cite>Varsi, Giulio,
&ldquo;The multidimensional content of the frustum of the simplex,&rdquo; <em>Pacific J. Math. 46, no. 1, 303&ndash;314,</em> 1973.</cite>
</p>
<p><cite>Ali, Mir M.,
&ldquo;Content of the frustum of a simplex,&rdquo; <em> Pacific J. Math. 48, no. 2, 313&ndash;322,</em> 1973.</cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># compute the frustum of H: -x1+x2&lt;=0
a=c(-1,1)
z0=0
frustum = frustum_of_simplex(a, z0)
</code></pre>

<hr>
<h2 id='gen_cross'>Generator function for cross polytopes</h2><span id='topic+gen_cross'></span>

<h3>Description</h3>

<p>This function generates the <code class="reqn">d</code>-dimensional cross polytope in H- or V-representation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_cross(dimension, representation = "H")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gen_cross_+3A_dimension">dimension</code></td>
<td>
<p>The dimension of the cross polytope.</p>
</td></tr>
<tr><td><code id="gen_cross_+3A_representation">representation</code></td>
<td>
<p>A string to declare the representation. It has to be <code>'H'</code> for H-representation or <code>'V'</code> for V-representation. Default valus is 'H'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A polytope class representing a cross polytope in H- or V-representation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a 10-dimensional cross polytope in H-representation
P = gen_cross(5, 'H')

# generate a 15-dimension cross polytope in V-representation
P = gen_cross(15, 'V')
</code></pre>

<hr>
<h2 id='gen_cube'>Generator function for hypercubes</h2><span id='topic+gen_cube'></span>

<h3>Description</h3>

<p>This function generates the <code class="reqn">d</code>-dimensional unit hypercube <code class="reqn">[-1,1]^d</code> in H- or V-representation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_cube(dimension, representation = "H")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gen_cube_+3A_dimension">dimension</code></td>
<td>
<p>The dimension of the hypercube</p>
</td></tr>
<tr><td><code id="gen_cube_+3A_representation">representation</code></td>
<td>
<p>A string to declare the representation. It has to be <code>'H'</code> for H-representation or <code>'V'</code> for V-representation. Default valus is 'H'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A polytope class representing the unit <code class="reqn">d</code>-dimensional hypercube in H- or V-representation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a 10-dimensional hypercube in H-representation
P = gen_cube(10, 'H')

# generate a 15-dimension hypercube in V-representation
P = gen_cube(5, 'V')
</code></pre>

<hr>
<h2 id='gen_prod_simplex'>Generator function for product of simplices</h2><span id='topic+gen_prod_simplex'></span>

<h3>Description</h3>

<p>This function generates a <code class="reqn">2d</code>-dimensional polytope that is defined as the product of two <code class="reqn">d</code>-dimensional unit simplices in H-representation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_prod_simplex(dimension)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gen_prod_simplex_+3A_dimension">dimension</code></td>
<td>
<p>The dimension of the simplices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A polytope class representing the product of the two <code class="reqn">d</code>-dimensional unit simplices in H-representation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a product of two 5-dimensional simplices.
P = gen_prod_simplex(5)
</code></pre>

<hr>
<h2 id='gen_rand_hpoly'>Generator function for random H-polytopes</h2><span id='topic+gen_rand_hpoly'></span>

<h3>Description</h3>

<p>This function generates a <code class="reqn">d</code>-dimensional polytope in H-representation with <code class="reqn">m</code> facets. We pick <code class="reqn">m</code> random hyperplanes tangent on the <code class="reqn">d</code>-dimensional unit hypersphere as facets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_rand_hpoly(dimension, nfacets, generator = list(constants = "sphere"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gen_rand_hpoly_+3A_dimension">dimension</code></td>
<td>
<p>The dimension of the convex polytope.</p>
</td></tr>
<tr><td><code id="gen_rand_hpoly_+3A_nfacets">nfacets</code></td>
<td>
<p>The number of the facets.</p>
</td></tr>
<tr><td><code id="gen_rand_hpoly_+3A_generator">generator</code></td>
<td>
<p>A list that could contain two elements.
</p>

<dl>
<dt>constants </dt><dd><p> To declare how to set the constants <code class="reqn">b_i</code> for each facets: (i) 'sphere', each hyperplane is tangent to the hypersphere of radius 10, (ii) 'uniform' for each <code class="reqn">b_i</code> the generator picks a uniform number from <code class="reqn">(0,1)</code>. The defalut value is 'sphere'.</p>
</dd>
<dt>seed </dt><dd><p> Optional. A fixed seed for the number generator.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>A polytope class representing a H-polytope.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a 10-dimensional polytope with 50 facets
P = gen_rand_hpoly(10, 50)
</code></pre>

<hr>
<h2 id='gen_rand_vpoly'>Generator function for random V-polytopes</h2><span id='topic+gen_rand_vpoly'></span>

<h3>Description</h3>

<p>This function generates a <code class="reqn">d</code>-dimensional polytope in V-representation with <code class="reqn">m</code> vertices. We pick <code class="reqn">m</code> random points from the boundary of the <code class="reqn">d</code>-dimensional unit hypersphere as vertices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_rand_vpoly(dimension, nvertices, generator = list(body = "sphere"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gen_rand_vpoly_+3A_dimension">dimension</code></td>
<td>
<p>The dimension of the convex polytope.</p>
</td></tr>
<tr><td><code id="gen_rand_vpoly_+3A_nvertices">nvertices</code></td>
<td>
<p>The number of the vertices.</p>
</td></tr>
<tr><td><code id="gen_rand_vpoly_+3A_generator">generator</code></td>
<td>
<p>A list that could contain two elements.
</p>

<dl>
<dt>body </dt><dd><p> the body that the generator samples uniformly the vertices from: (i) 'cube' or (ii) 'sphere', the default value is 'sphere'.</p>
</dd>
<dt>seed </dt><dd><p> Optional. A fixed seed for the number generator.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>A polytope class representing a V-polytope.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a 10-dimensional polytope defined as the convex hull of 25 random vertices
P = gen_rand_vpoly(10, 25)
</code></pre>

<hr>
<h2 id='gen_rand_zonotope'>Generator function for zonotopes</h2><span id='topic+gen_rand_zonotope'></span>

<h3>Description</h3>

<p>This function generates a random <code class="reqn">d</code>-dimensional zonotope defined by the Minkowski sum of <code class="reqn">m</code> <code class="reqn">d</code>-dimensional segments.
The function considers <code class="reqn">m</code> random directions in <code class="reqn">R^d</code>. There are three strategies to pick the length of each segment: a) it is uniformly sampled from <code class="reqn">[0,100]</code>, b) it is random from <code class="reqn">\mathcal{N}(50,(50/3)^2)</code> truncated to <code class="reqn">[0,100]</code>, c) it is random from <code class="reqn">Exp(1/30)</code> truncated to <code class="reqn">[0,100]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_rand_zonotope(
  dimension,
  nsegments,
  generator = list(distribution = "uniform")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gen_rand_zonotope_+3A_dimension">dimension</code></td>
<td>
<p>The dimension of the zonotope.</p>
</td></tr>
<tr><td><code id="gen_rand_zonotope_+3A_nsegments">nsegments</code></td>
<td>
<p>The number of segments that generate the zonotope.</p>
</td></tr>
<tr><td><code id="gen_rand_zonotope_+3A_generator">generator</code></td>
<td>
<p>A list that could contain two elements.
</p>

<dl>
<dt>distribution</dt><dd><p>The distribution to pick the length of each segment from <code class="reqn">[0,100]</code>: (i) 'uniform', (ii) 'gaussian' or (iii) 'exponential', the default value is 'uniform.</p>
</dd>
<dt>seed</dt><dd><p>Optional. A fixed seed for the number generator.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>A polytope class representing a zonotope.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a 10-dimensional zonotope defined by the Minkowski sum of 20 segments
P = gen_rand_zonotope(10, 20)
</code></pre>

<hr>
<h2 id='gen_simplex'>Generator function for simplices</h2><span id='topic+gen_simplex'></span>

<h3>Description</h3>

<p>This function generates the <code class="reqn">d</code>-dimensional unit simplex in H- or V-representation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_simplex(dimension, representation = "H")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gen_simplex_+3A_dimension">dimension</code></td>
<td>
<p>The dimension of the unit simplex.</p>
</td></tr>
<tr><td><code id="gen_simplex_+3A_representation">representation</code></td>
<td>
<p>A string to declare the representation. It has to be <code>'H'</code> for H-representation or <code>'V'</code> for V-representation.  Default valus is 'H'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A polytope class representing the <code class="reqn">d</code>-dimensional unit simplex in H- or V-representation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a 10-dimensional simplex in H-representation
PolyList = gen_simplex(10, 'H')

# generate a 20-dimensional simplex in V-representation
P = gen_simplex(20, 'V')
</code></pre>

<hr>
<h2 id='gen_skinny_cube'>Generator function for skinny hypercubes</h2><span id='topic+gen_skinny_cube'></span>

<h3>Description</h3>

<p>This function generates a <code class="reqn">d</code>-dimensional skinny hypercube <code class="reqn">[-1,1]^{d-1}\times [-100,100]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_skinny_cube(dimension)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gen_skinny_cube_+3A_dimension">dimension</code></td>
<td>
<p>The dimension of the skinny hypercube.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A polytope class representing the <code class="reqn">d</code>-dimensional skinny hypercube in H-representation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a 10-dimensional skinny hypercube.
P = gen_skinny_cube(10)
</code></pre>

<hr>
<h2 id='Hpolytope-class'>An R class to represent an H-polytope</h2><span id='topic+Hpolytope-class'></span><span id='topic+Hpolytope'></span>

<h3>Description</h3>

<p>An H-polytope is a convex polytope defined by a set of linear inequalities or equivalently a <code class="reqn">d</code>-dimensional H-polytope with <code class="reqn">m</code> facets is defined by a <code class="reqn">m\times d</code> matrix A and a <code class="reqn">m</code>-dimensional vector b, s.t.: <code class="reqn">Ax\leq b</code>.
</p>


<h3>Details</h3>


<dl>
<dt>A</dt><dd><p>An <code class="reqn">m\times d</code> numerical matrix.</p>
</dd>
<dt>b</dt><dd><p>An <code class="reqn">m</code>-dimensional vector b.</p>
</dd>
<dt>volume</dt><dd><p>The volume of the polytope if it is known, <code class="reqn">NaN</code> otherwise by default.</p>
</dd>
<dt>type</dt><dd><p>A character with default value 'Hpolytope', to declare the representation of the polytope.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>A = matrix(c(-1,0,0,-1,1,1), ncol=2, nrow=3, byrow=TRUE)
b = c(0,0,1)
P = Hpolytope(A = A, b = b)
 
</code></pre>

<hr>
<h2 id='inner_ball'>Compute an inscribed ball of a convex polytope</h2><span id='topic+inner_ball'></span>

<h3>Description</h3>

<p>For a H-polytope described by a <code class="reqn">m\times d</code> matrix <code class="reqn">A</code> and a <code class="reqn">m</code>-dimensional vector <code class="reqn">b</code>, s.t.: <code class="reqn">P=\{x\ |\  Ax\leq b\} </code>, this function computes the largest inscribed ball (Chebychev ball) by solving the corresponding linear program.
For both zonotopes and V-polytopes the function computes the minimum <code class="reqn">r</code> s.t.: <code class="reqn"> r e_i \in P</code> for all <code class="reqn">i=1, \dots ,d</code>. Then the ball centered at the origin with radius <code class="reqn">r/ \sqrt{d}</code> is an inscribed ball.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inner_ball(P)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inner_ball_+3A_p">P</code></td>
<td>
<p>A convex polytope. It is an object from class (a) Hpolytope or (b) Vpolytope or (c) Zonotope or (d) VpolytopeIntersection.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code class="reqn">(d+1)</code>-dimensional vector that describes the inscribed ball. The first <code class="reqn">d</code> coordinates corresponds to the center of the ball and the last one to the radius.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># compute the Chebychev ball of the 2d unit simplex
P = gen_simplex(2,'H')
ball_vec = inner_ball(P)

# compute an inscribed ball of the 3-dimensional unit cube in V-representation
P = gen_cube(3, 'V')
ball_vec = inner_ball(P)
</code></pre>

<hr>
<h2 id='load_sdpa_format_file'>An internal Rccp function to read a SDPA format file</h2><span id='topic+load_sdpa_format_file'></span>

<h3>Description</h3>

<p>An internal Rccp function to read a SDPA format file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_sdpa_format_file(input_file = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="load_sdpa_format_file_+3A_input_file">input_file</code></td>
<td>
<p>Name of the input file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two named items: an item &quot;matrices&quot; which is a list of the matrices and an vector &quot;objFunction&quot;
</p>

<hr>
<h2 id='poly_gen'>An internal Rccp function as a polytope generator</h2><span id='topic+poly_gen'></span>

<h3>Description</h3>

<p>An internal Rccp function as a polytope generator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poly_gen(kind_gen, Vpoly_gen, Zono_gen, dim_gen, m_gen, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="poly_gen_+3A_kind_gen">kind_gen</code></td>
<td>
<p>An integer to declare the type of the polytope.</p>
</td></tr>
<tr><td><code id="poly_gen_+3A_vpoly_gen">Vpoly_gen</code></td>
<td>
<p>A boolean parameter to declare if the requested polytope has to be in V-representation.</p>
</td></tr>
<tr><td><code id="poly_gen_+3A_zono_gen">Zono_gen</code></td>
<td>
<p>A boolean parameter to declare if the requested polytope has to be a zonotope.</p>
</td></tr>
<tr><td><code id="poly_gen_+3A_dim_gen">dim_gen</code></td>
<td>
<p>An integer to declare the dimension of the requested polytope.</p>
</td></tr>
<tr><td><code id="poly_gen_+3A_m_gen">m_gen</code></td>
<td>
<p>An integer to declare the number of generators for the requested random zonotope or the number of vertices for a V-polytope.</p>
</td></tr>
<tr><td><code id="poly_gen_+3A_seed">seed</code></td>
<td>
<p>Optional. A fixed seed for the random polytope generator.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numerical matrix describing the requested polytope
</p>

<hr>
<h2 id='read_sdpa_format_file'>Read a SDPA format file</h2><span id='topic+read_sdpa_format_file'></span>

<h3>Description</h3>

<p>Read a SDPA format file and return a spectrahedron (an object of class Spectrahedron) which is defined by
the linear matrix inequality in the input file, and the objective function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_sdpa_format_file(path)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_sdpa_format_file_+3A_path">path</code></td>
<td>
<p>Name of the input file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two named items: an item &quot;matrices&quot; which is an object of class Spectrahedron and an vector &quot;objFunction&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path = system.file('extdata', package = 'volesti')
l = read_sdpa_format_file(paste0(path,'/sdpa_n2m3.txt'))
Spectrahedron = l$spectrahedron
objFunction = l$objFunction
</code></pre>

<hr>
<h2 id='rotate_polytope'>Apply a random rotation to a convex polytope (H-polytope, V-polytope, zonotope or intersection of two V-polytopes)</h2><span id='topic+rotate_polytope'></span>

<h3>Description</h3>

<p>Given a convex H- or V- polytope or a zonotope or an intersection of two V-polytopes as input, this function applies (a) a random rotation or (b) a given rotation by an input matrix <code class="reqn">T</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotate_polytope(P, rotation = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rotate_polytope_+3A_p">P</code></td>
<td>
<p>A convex polytope. It is an object from class (a) Hpolytope, (b) Vpolytope, (c) Zonotope, (d) intersection of two V-polytopes.</p>
</td></tr>
<tr><td><code id="rotate_polytope_+3A_rotation">rotation</code></td>
<td>
<p>A list that contains (a) the rotation matrix T and (b) the 'seed' to set a spesific seed for the number generator.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">P</code> be the given polytope and <code class="reqn">Q</code> the rotated one and <code class="reqn">T</code> be the matrix of the linear transformation.
</p>

<ul>
<li><p> If <code class="reqn">P</code> is in H-representation and <code class="reqn">A</code> is the matrix that contains the normal vectors of the facets of <code class="reqn">Q</code> then <code class="reqn">AT</code> contains the normal vactors of the facets of <code class="reqn">P</code>.
</p>
</li>
<li><p> If <code class="reqn">P</code> is in V-representation and <code class="reqn">V</code> is the matrix that contains column-wise the vertices of <code class="reqn">Q</code> then <code class="reqn">T^TV</code> contains the vertices of <code class="reqn">P</code>.
</p>
</li>
<li><p> If <code class="reqn">P</code> is a zonotope and <code class="reqn">G</code> is the matrix that contains column-wise the generators of <code class="reqn">Q</code> then <code class="reqn">T^TG</code> contains the generators of <code class="reqn">P</code>.
</p>
</li>
<li><p> If <code class="reqn">M</code> is a matrix that contains column-wise points in <code class="reqn">Q</code> then <code class="reqn">T^TM</code> contains points in <code class="reqn">P</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>A list that contains the rotated polytope and the matrix <code class="reqn">T</code> of the linear transformation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># rotate a H-polytope (2d unit simplex)
P = gen_simplex(2, 'H')
poly_matrix_list = rotate_polytope(P)

# rotate a V-polytope (3d cube)
P = gen_cube(3, 'V')
poly_matrix_list = rotate_polytope(P)

# rotate a 5-dimensional zonotope defined by the Minkowski sum of 15 segments
Z = gen_rand_zonotope(3, 6)
poly_matrix_list = rotate_polytope(Z)
</code></pre>

<hr>
<h2 id='rotating'>An internal Rccp function for the random rotation of a convex polytope</h2><span id='topic+rotating'></span>

<h3>Description</h3>

<p>An internal Rccp function for the random rotation of a convex polytope
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotating(P, T = NULL, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rotating_+3A_p">P</code></td>
<td>
<p>A convex polytope (H-, V-polytope or a zonotope).</p>
</td></tr>
<tr><td><code id="rotating_+3A_t">T</code></td>
<td>
<p>Optional. A rotation matrix.</p>
</td></tr>
<tr><td><code id="rotating_+3A_seed">seed</code></td>
<td>
<p>Optional. A fixed seed for the random linear map generator.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix that describes the rotated polytope
</p>

<hr>
<h2 id='round_polytope'>Apply rounding to a convex polytope (H-polytope, V-polytope or a zonotope)</h2><span id='topic+round_polytope'></span>

<h3>Description</h3>

<p>Given a convex H or V polytope or a zonotope as input this function brings the polytope in rounded position based on minimum volume enclosing ellipsoid of a pointset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>round_polytope(P, settings = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="round_polytope_+3A_p">P</code></td>
<td>
<p>A convex polytope. It is an object from class (a) Hpolytope or (b) Vpolytope or (c) Zonotope.</p>
</td></tr>
<tr><td><code id="round_polytope_+3A_settings">settings</code></td>
<td>
<p>Optional. A list to parameterize the method by the random walk.
</p>

<dl>
<dt><code>random_walk</code> </dt><dd><p>  The random walk to sample uniformly distributed points: (a) <code>'CDHR'</code> for Coordinate Directions Hit-and-Run, (b) <code>'RDHR'</code> for Random Directions Hit-and-Run or (c) <code>'BiW'</code> for Billiard walk. The default random walk is <code>'CDHR'</code> for H-polytopes and <code>'BiW'</code> for the rest of the representations.</p>
</dd>
<dt><code>walk_length</code> </dt><dd><p> The walk length of the random walk. The default value is <code class="reqn">10 + 10d</code> for <code>'CDHR'</code> or <code>'RDHR'</code> and 2 for <code>'BiW'</code>.</p>
</dd>
<dt><code>seed</code> </dt><dd><p> Optional. A fixed seed for the number generator.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with 4 elements: (a) a polytope of the same class as the input polytope class and (b) the element &quot;T&quot; which is the matrix of the inverse linear transformation that is applied on the input polytope, (c)  the element &quot;shift&quot; which is the opposite vector of that which has shifted the input polytope, (d) the element &quot;round_value&quot; which is the determinant of the square matrix of the linear transformation that is applied on the input polytope.
</p>


<h3>References</h3>

<p><cite>I.Z.Emiris and V. Fisikopoulos,
&ldquo;Practical polytope volume approximation,&rdquo; <em>ACM Trans. Math. Soft.,</em> 2018.</cite>,
</p>
<p><cite>Michael J. Todd and E. Alper Yildirim,
&ldquo;On Khachiyan’s Algorithm for the Computation of Minimum Volume Enclosing Ellipsoids,&rdquo; <em>Discrete Applied Mathematics,</em> 2007.</cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># rotate a H-polytope (2d unit simplex)
A = matrix(c(-1,0,0,-1,1,1), ncol=2, nrow=3, byrow=TRUE)
b = c(0,0,1)
P = Hpolytope(A = A, b = b)
listHpoly = round_polytope(P)

# rotate a V-polytope (3d unit cube) using Random Directions HnR with step equal to 50
P = gen_cube(3, 'V')
ListVpoly = round_polytope(P)

# round a 2-dimensional zonotope defined by 6 generators using ball walk
Z = gen_rand_zonotope(2,6)
ListZono = round_polytope(Z)
</code></pre>

<hr>
<h2 id='rounding'>Internal rcpp function for the rounding of a convex polytope</h2><span id='topic+rounding'></span>

<h3>Description</h3>

<p>Internal rcpp function for the rounding of a convex polytope
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rounding(P, settings = NULL, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rounding_+3A_p">P</code></td>
<td>
<p>A convex polytope (H- or V-representation or zonotope).</p>
</td></tr>
<tr><td><code id="rounding_+3A_settings">settings</code></td>
<td>
<p>A list to set the random walk and its walk length</p>
</td></tr>
<tr><td><code id="rounding_+3A_seed">seed</code></td>
<td>
<p>Optional. A fixed seed for the number generator.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numerical matrix that describes the rounded polytope, a numerical matrix of the inverse linear transofmation that is applied on the input polytope, the numerical vector the the input polytope is shifted and the determinant of the matrix of the linear transformation that is applied on the input polytope.
</p>

<hr>
<h2 id='sample_points'>Sample uniformly or normally distributed points from a convex Polytope (H-polytope, V-polytope, zonotope or intersection of two V-polytopes).</h2><span id='topic+sample_points'></span>

<h3>Description</h3>

<p>Sample n points with uniform or multidimensional spherical gaussian -with a mode at any point- as the target distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_points(P, n, random_walk = NULL, distribution = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample_points_+3A_p">P</code></td>
<td>
<p>A convex polytope. It is an object from class (a) Hpolytope or (b) Vpolytope or (c) Zonotope or (d) VpolytopeIntersection.</p>
</td></tr>
<tr><td><code id="sample_points_+3A_n">n</code></td>
<td>
<p>The number of points that the function is going to sample from the convex polytope.</p>
</td></tr>
<tr><td><code id="sample_points_+3A_random_walk">random_walk</code></td>
<td>
<p>Optional. A list that declares the random walk and some related parameters as follows:
</p>

<dl>
<dt><code>walk</code> </dt><dd><p> A string to declare the random walk: i) <code>'CDHR'</code> for Coordinate Directions Hit-and-Run, ii) <code>'RDHR'</code> for Random Directions Hit-and-Run, iii) <code>'BaW'</code> for Ball Walk, iv) <code>'BiW'</code> for Billiard walk, v) <code>'BCDHR'</code> boundary sampling by keeping the extreme points of CDHR or vi) <code>'BRDHR'</code> boundary sampling by keeping the extreme points of RDHR. The default walk is <code>'BiW'</code> for the uniform distribution or <code>'CDHR'</code> for the Gaussian distribution.</p>
</dd>
<dt><code>walk_length</code> </dt><dd><p> The number of the steps per generated point for the random walk. The default value is 1.</p>
</dd>
<dt><code>nburns</code> </dt><dd><p> The number of points to burn before start sampling.</p>
</dd>
<dt><code>starting_point</code> </dt><dd><p> A <code class="reqn">d</code>-dimensional numerical vector that declares a starting point in the interior of the polytope for the random walk. The default choice is the center of the ball as that one computed by the function <code>inner_ball()</code>.</p>
</dd>
<dt><code>BaW_rad</code> </dt><dd><p> The radius for the ball walk.</p>
</dd>
<dt><code>L</code> </dt><dd><p> The maximum length of the billiard trajectory.</p>
</dd>
<dt><code>seed</code> </dt><dd><p> A fixed seed for the number generator.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="sample_points_+3A_distribution">distribution</code></td>
<td>
<p>Optional. A list that declares the target density and some related parameters as follows:
</p>

<dl>
<dt><code>density</code> </dt><dd><p> A string: (a) <code>'uniform'</code> for the uniform distribution or b) <code>'gaussian'</code> for the multidimensional spherical distribution. The default target distribution is uniform.</p>
</dd>
<dt><code>variance</code> </dt><dd><p> The variance of the multidimensional spherical gaussian. The default value is 1.</p>
</dd>
<dt><code>mode</code> </dt><dd><p> A <code class="reqn">d</code>-dimensional numerical vector that declares the mode of the Gaussian distribution. The default choice is the center of the as that one computed by the function <code>inner_ball()</code>.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code class="reqn">d\times n</code> matrix that contains, column-wise, the sampled points from the convex polytope P.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># uniform distribution from the 3d unit cube in H-representation using ball walk
P = gen_cube(3, 'H')
points = sample_points(P, n = 100, random_walk = list("walk" = "BaW", "walk_length" = 5))

# gaussian distribution from the 2d unit simplex in H-representation with variance = 2
A = matrix(c(-1,0,0,-1,1,1), ncol=2, nrow=3, byrow=TRUE)
b = c(0,0,1)
P = Hpolytope(A = A, b = b)
points = sample_points(P, n = 100, distribution = list("density" = "gaussian", "variance" = 2))

# uniform points from the boundary of a 2-dimensional random H-polytope
P = gen_rand_hpoly(2,20)
points = sample_points(P, n = 100, random_walk = list("walk" = "BRDHR"))

</code></pre>

<hr>
<h2 id='Spectrahedron-class'>An R class to represent a Spectrahedron</h2><span id='topic+Spectrahedron-class'></span><span id='topic+Spectrahedron'></span>

<h3>Description</h3>

<p>A spectrahedron is a convex body defined by a linear matrix inequality of the form <code class="reqn">A_0 + x_1 A_1 + ... + x_n A_n \preceq 0</code>.
The matrices <code class="reqn">A_i</code> are symmetric <code class="reqn">m \times m</code> real matrices and <code class="reqn">\preceq 0</code> denoted negative semidefiniteness.
</p>


<h3>Details</h3>


<dl>
<dt>matrices</dt><dd><p>A List that contains the matrices <code class="reqn">A_0, A_1, ..., A_n</code>.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>A0 = matrix(c(-1,0,0,0,-2,1,0,1,-2), nrow=3, ncol=3, byrow = TRUE)
A1 = matrix(c(-1,0,0,0,0,1,0,1,0), nrow=3, ncol=3, byrow = TRUE)
A2 = matrix(c(0,0,-1,0,0,0,-1,0,0), nrow=3, ncol=3, byrow = TRUE)
lmi = list(A0, A1, A2)
S = Spectrahedron(matrices = lmi);
 
</code></pre>

<hr>
<h2 id='volume'>The main function for volume approximation of a convex Polytope (H-polytope, V-polytope, zonotope or intersection of two V-polytopes)</h2><span id='topic+volume'></span>

<h3>Description</h3>

<p>For the volume approximation can be used three algorithms. Either CoolingBodies (CB) or SequenceOfBalls (SOB) or CoolingGaussian (CG). An H-polytope with <code class="reqn">m</code> facets is described by a <code class="reqn">m\times d</code> matrix <code class="reqn">A</code> and a <code class="reqn">m</code>-dimensional vector <code class="reqn">b</code>, s.t.: <code class="reqn">P=\{x\ |\  Ax\leq b\} </code>. A V-polytope is defined as the convex hull of <code class="reqn">m</code> <code class="reqn">d</code>-dimensional points which correspond to the vertices of P. A zonotope is desrcibed by the Minkowski sum of <code class="reqn">m</code> <code class="reqn">d</code>-dimensional segments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>volume(P, settings = NULL, rounding = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="volume_+3A_p">P</code></td>
<td>
<p>A convex polytope. It is an object from class a) Hpolytope or b) Vpolytope or c) Zonotope or d) VpolytopeIntersection.</p>
</td></tr>
<tr><td><code id="volume_+3A_settings">settings</code></td>
<td>
<p>Optional. A list that declares which algorithm, random walk and values of parameters to use, as follows:
</p>

<dl>
<dt><code>algorithm</code> </dt><dd><p> A string to set the algorithm to use: a) <code>'CB'</code> for CB algorithm, b) <code>'SoB'</code> for SOB algorithm or b) <code>'CG'</code> for CG algorithm. The defalut algorithm is <code>'CB'</code>.</p>
</dd>
<dt><code>error</code> </dt><dd><p> A numeric value to set the upper bound for the approximation error. The default value is <code class="reqn">1</code> for SOB algorithm and <code class="reqn">0.1</code> otherwise.</p>
</dd>
<dt><code>random_walk</code> </dt><dd><p> A string that declares the random walk method: a) <code>'CDHR'</code> for Coordinate Directions Hit-and-Run, b) <code>'RDHR'</code> for Random Directions Hit-and-Run, c) <code>'BaW'</code> for Ball Walk, or <code>'BiW'</code> for Billiard walk. For CB and SOB algorithms the default walk is <code>'CDHR'</code> for H-polytopes and <code>'BiW'</code> for the other representations. For CG algorithm the default walk is <code>'CDHR'</code> for H-polytopes and <code>'RDHR'</code> for the other representations.</p>
</dd>
<dt><code>walk_length</code> </dt><dd><p> An integer to set the number of the steps for the random walk. The default value is <code class="reqn">\lfloor 10 + d/10\rfloor</code> for <code>'SOB'</code> and <code class="reqn">1</code> otherwise.</p>
</dd>
<dt><code>win_len</code> </dt><dd><p> The length of the sliding window for CB or CG algorithm. The default value is <code class="reqn">400+3d^2</code> for CB or <code class="reqn">500+4d^2</code> for CG.</p>
</dd>
<dt><code>hpoly</code> </dt><dd><p> A boolean parameter to use H-polytopes in MMC of CB algorithm when the input polytope is a zonotope. The default value is <code>TRUE</code> when the order of the zonotope is <code class="reqn">&lt;5</code>, otherwise it is <code>FALSE</code>.</p>
</dd>
<dt><code>seed</code> </dt><dd><p> A fixed seed for the number generator.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="volume_+3A_rounding">rounding</code></td>
<td>
<p>A boolean parameter for rounding. The default value is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The approximation of the volume of a convex polytope.
</p>


<h3>References</h3>

<p><cite>I.Z.Emiris and V. Fisikopoulos,
&ldquo;Practical polytope volume approximation,&rdquo; <em>ACM Trans. Math. Soft.,</em> 2018.</cite>,
</p>
<p><cite>A. Chalkis and I.Z.Emiris and V. Fisikopoulos,
&ldquo;Practical Volume Estimation by a New Annealing Schedule for Cooling Convex Bodies,&rdquo; <em>CoRR, abs/1905.05494,</em> 2019.</cite>,
</p>
<p><cite>B. Cousins and S. Vempala, &ldquo;A practical volume algorithm,&rdquo; <em>Springer-Verlag Berlin Heidelberg and The Mathematical Programming Society,</em> 2015.</cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# calling SOB algorithm for a H-polytope (3d unit simplex)
HP = gen_cube(3,'H')
vol = volume(HP)

# calling CG algorithm for a V-polytope (2d simplex)
VP = gen_simplex(2,'V')
vol = volume(VP, settings = list("algorithm" = "CG"))

# calling CG algorithm for a 2-dimensional zonotope defined as the Minkowski sum of 4 segments
Z = gen_rand_zonotope(2, 4)
vol = volume(Z, settings = list("random_walk" = "RDHR", "walk_length" = 2))

</code></pre>

<hr>
<h2 id='Vpolytope-class'>An R class to represent a V-polytope</h2><span id='topic+Vpolytope-class'></span><span id='topic+Vpolytope'></span>

<h3>Description</h3>

<p>A V-polytope is a convex polytope defined by the set of its vertices.
</p>


<h3>Details</h3>


<dl>
<dt>V</dt><dd><p>An <code class="reqn">m\times d</code> numerical matrix that contains the vertices row-wise.</p>
</dd>
<dt>volume</dt><dd><p>The volume of the polytope if it is known, <code class="reqn">NaN</code> otherwise by default.</p>
</dd>
<dt>type</dt><dd><p>A character with default value 'Vpolytope', to declare the representation of the polytope.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>V = matrix(c(2,3,-1,7,0,0),ncol = 2, nrow = 3, byrow = TRUE)
P = Vpolytope(V = V)

</code></pre>

<hr>
<h2 id='VpolytopeIntersection-class'>An R class to represent the intersection of two V-polytopes</h2><span id='topic+VpolytopeIntersection-class'></span><span id='topic+VpolytopeIntersection'></span>

<h3>Description</h3>

<p>An intersection of two V-polytopes is defined by the intersection of the two coresponding convex hulls.
</p>


<h3>Details</h3>


<dl>
<dt>V1</dt><dd><p>An <code class="reqn">m\times d</code> numerical matrix that contains the vertices of the first V-polytope (row-wise).</p>
</dd>
<dt>V2</dt><dd><p>An <code class="reqn">q\times d</code> numerical matrix that contains the vertices of the second V-polytope (row-wise).</p>
</dd>
<dt>volume</dt><dd><p>The volume of the polytope if it is known, <code class="reqn">NaN</code> otherwise by default.</p>
</dd>
<dt>type</dt><dd><p>A character with default value 'VpolytopeIntersection', to declare the representation of the polytope.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>P1 = gen_simplex(2,'V')
P2 = gen_cross(2,'V')
P = VpolytopeIntersection(V1 = P1@V, V2 = P2@V)

</code></pre>

<hr>
<h2 id='write_sdpa_format_file'>Write a SDPA format file</h2><span id='topic+write_sdpa_format_file'></span>

<h3>Description</h3>

<p>Outputs a spectrahedron (the matrices defining a linear matrix inequality) and a vector (the objective function)
to a SDPA format file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_sdpa_format_file(spectrahedron, objective_function, output_file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write_sdpa_format_file_+3A_spectrahedron">spectrahedron</code></td>
<td>
<p>A spectrahedron in n dimensions; must be an object of class Spectrahedron</p>
</td></tr>
<tr><td><code id="write_sdpa_format_file_+3A_objective_function">objective_function</code></td>
<td>
<p>A numerical vector of length n</p>
</td></tr>
<tr><td><code id="write_sdpa_format_file_+3A_output_file">output_file</code></td>
<td>
<p>Name of the output file</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
A0 = matrix(c(-1,0,0,0,-2,1,0,1,-2), nrow=3, ncol=3, byrow = TRUE)
A1 = matrix(c(-1,0,0,0,0,1,0,1,0), nrow=3, ncol=3, byrow = TRUE)
A2 = matrix(c(0,0,-1,0,0,0,-1,0,0), nrow=3, ncol=3, byrow = TRUE)
lmi = list(A0, A1, A2)
S = Spectrahedron(matrices = lmi)
objFunction = c(1,1)
write_sdpa_format_file(S, objFunction, "output.txt")

</code></pre>

<hr>
<h2 id='zono_approx'>An internal Rccp function for the over-approximation of a zonotope</h2><span id='topic+zono_approx'></span>

<h3>Description</h3>

<p>An internal Rccp function for the over-approximation of a zonotope
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zono_approx(Z, fit_ratio = NULL, settings = NULL, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zono_approx_+3A_z">Z</code></td>
<td>
<p>A zonotope.</p>
</td></tr>
<tr><td><code id="zono_approx_+3A_fit_ratio">fit_ratio</code></td>
<td>
<p>Optional. A boolean parameter to request the computation of the ratio of fitness.</p>
</td></tr>
<tr><td><code id="zono_approx_+3A_settings">settings</code></td>
<td>
<p>Optional. A list that declares the values of the parameters of CB algorithm.</p>
</td></tr>
<tr><td><code id="zono_approx_+3A_seed">seed</code></td>
<td>
<p>Optional. A fixed seed for the number generator.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A List that contains a numerical matrix that describes the PCA approximation as a H-polytope and the ratio of fitness.
</p>

<hr>
<h2 id='zonotope_approximation'>A function to over-approximate a zonotope with PCA method and to evaluate the approximation by computing a ratio of fitness.</h2><span id='topic+zonotope_approximation'></span>

<h3>Description</h3>

<p>For the evaluation of the PCA method the exact volume of the approximation body is computed and the volume of the input zonotope is computed by CoolingBodies algorithm. The ratio of fitness is <code class="reqn">R=vol(P) / vol(P_{red})</code>, where <code class="reqn">P_{red}</code> is the approximate polytope.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zonotope_approximation(
  Z,
  fit_ratio = FALSE,
  settings = list(error = 0.1, walk_length = 1, win_len = 250, hpoly = FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zonotope_approximation_+3A_z">Z</code></td>
<td>
<p>A zonotope.</p>
</td></tr>
<tr><td><code id="zonotope_approximation_+3A_fit_ratio">fit_ratio</code></td>
<td>
<p>Optional. A boolean parameter to request the computation of the ratio of fitness.</p>
</td></tr>
<tr><td><code id="zonotope_approximation_+3A_settings">settings</code></td>
<td>
<p>Optional. A list that declares the values of the parameters of CB algorithm as follows:
</p>

<dl>
<dt><code>error</code> </dt><dd><p> A numeric value to set the upper bound for the approximation error. The default value is <code class="reqn">0.1</code>.</p>
</dd>
<dt><code>walk_length</code> </dt><dd><p> An integer to set the number of the steps for the random walk. The default value is <code class="reqn">1</code>.</p>
</dd>
<dt><code>win_len</code> </dt><dd><p> The length of the sliding window for CB algorithm. The default value is <code class="reqn">250</code>.</p>
</dd>
<dt><code>hpoly</code> </dt><dd><p> A boolean parameter to use H-polytopes in MMC of CB algorithm. The default value is <code>TRUE</code> when the order of the zonotope is <code class="reqn">&lt;5</code>, otherwise it is <code>FALSE</code>.</p>
</dd>
<dt><code>seed</code> </dt><dd><p> Optional. A fixed seed for the number generator.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>A list that contains the approximation body in H-representation and the ratio of fitness
</p>


<h3>References</h3>

<p><cite>A.K. Kopetzki and B. Schurmann and M. Althoff,
&ldquo;Methods for Order Reduction of Zonotopes,&rdquo; <em>IEEE Conference on Decision and Control,</em> 2017.</cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># over-approximate a 2-dimensional zonotope with 10 generators and compute the ratio of fitness
Z = gen_rand_zonotope(2, 8)
retList = zonotope_approximation(Z = Z)

</code></pre>

<hr>
<h2 id='Zonotope-class'>An R class to represent a Zonotope</h2><span id='topic+Zonotope-class'></span><span id='topic+Zonotope'></span>

<h3>Description</h3>

<p>A zonotope is a convex polytope defined by the Minkowski sum of <code class="reqn">m</code> <code class="reqn">d</code>-dimensional segments.
</p>


<h3>Details</h3>


<dl>
<dt>G</dt><dd><p>An <code class="reqn">m\times d</code> numerical matrix that contains the segments (or generators) row-wise</p>
</dd>
<dt>volume</dt><dd><p>The volume of the polytope if it is known, <code class="reqn">NaN</code> otherwise by default.</p>
</dd>
<dt>type</dt><dd><p>A character with default value 'Zonotope', to declare the representation of the polytope.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>G = matrix(c(2,3,-1,7,0,0),ncol = 2, nrow = 3, byrow = TRUE)
P = Zonotope(G = G)
 
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
