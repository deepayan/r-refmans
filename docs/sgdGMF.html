<!DOCTYPE html><html lang="en"><head><title>Help for package sgdGMF</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sgdGMF}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#sgdGMF-package'><p>sgdGMF: Estimation of Generalized Matrix Factorization Models via Stochastic Gradient Descent</p></a></li>
<li><a href='#biplot.initgmf'><p>Biplot of an initialized GMF model</p></a></li>
<li><a href='#biplot.sgdgmf'><p>Biplot of a GMF model</p></a></li>
<li><a href='#coefficients.initgmf'><p>Extract the coefficient of an initialized GMF model</p></a></li>
<li><a href='#coefficients.sgdgmf'><p>Extract the coefficient of a GMF model</p></a></li>
<li><a href='#cpp.airwls.glmfit'><p>Fisher scoring algorithm for GLMs</p></a></li>
<li><a href='#cpp.airwls.glmstep'><p>Compute one Fisher scoring step for GLMs</p></a></li>
<li><a href='#cpp.airwls.update'><p>AIRWLS update for GMF models</p></a></li>
<li><a href='#cpp.fit.airwls'><p>Fit a GMF model using the AIRWLS algorithm</p></a></li>
<li><a href='#cpp.fit.block.sgd'><p>Fit a GMF model using the adaptive SGD with block-wise minibatch subsampling</p></a></li>
<li><a href='#cpp.fit.coord.sgd'><p>Fit a GMF model using the adaptive SGD with coordinate-wise minibatch subsampling algorithm</p></a></li>
<li><a href='#cpp.fit.newton'><p>Fit a GMF model using the diagonal quasi-Newton algorithm</p></a></li>
<li><a href='#cpp.fit.random.block.sgd'><p>Fit a GMF model using the adaptive SGD with block-wise minibatch subsampling</p></a></li>
<li><a href='#deviance.initgmf'><p>Compute deviance, AIC and BIC of an initialized GMF model</p></a></li>
<li><a href='#deviance.sgdgmf'><p>Compute deviance, AIC and BIC of a GMF model</p></a></li>
<li><a href='#eigengap.act'><p>Rank selection via adjust correlation thresholding</p></a></li>
<li><a href='#eigengap.oht'><p>Rank selection via optimal hard thresholding</p></a></li>
<li><a href='#eigengap.onatski'><p>Rank selection via the Onatski method</p></a></li>
<li><a href='#fitted.initgmf'><p>Extract the fitted values of an initialized GMF model</p></a></li>
<li><a href='#fitted.sgdgmf'><p>Extract the fitted values of a GMF models</p></a></li>
<li><a href='#image.initgmf'><p>Heatmap of an initialized GMF model</p></a></li>
<li><a href='#image.sgdgmf'><p>Heatmap of a GMF model</p></a></li>
<li><a href='#make.pos.diag'><p>Fix sign ambiguity of eigen-vectors</p></a></li>
<li><a href='#matrix.deviance'><p>Model deviance of a GMF model</p></a></li>
<li><a href='#matrix.penalty'><p>Frobenius penalty for the parameters of a GMF model</p></a></li>
<li><a href='#norm.procrustes'><p>Procrustes distance</p></a></li>
<li><a href='#normalize.uv'><p>Normalize the matrices U and V</p></a></li>
<li><a href='#ols.fit.coef'><p>Estimate the coefficients of a multivariate linear model</p></a></li>
<li><a href='#omp.check'><p>Check if OpenMP is enabled</p></a></li>
<li><a href='#partition'><p>Split the data matrix in train and test sets</p></a></li>
<li><a href='#plot.initgmf'><p>Plot diagnostics for an initialized GMF model</p></a></li>
<li><a href='#plot.sgdgmf'><p>Plot diagnostics for a GMF model</p></a></li>
<li><a href='#pointwise.deviance'><p>Pointwise deviance of a GMF model</p></a></li>
<li><a href='#predict.sgdgmf'><p>Predict method for GMF models</p></a></li>
<li><a href='#print.initgmf'><p>Print the fundamental characteristics of an initialized GMF</p></a></li>
<li><a href='#print.sgdgmf'><p>Print the fundamental characteristics of a GMF</p></a></li>
<li><a href='#procrustes'><p>Procrustes rotation of two configurations</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#refit.sgdgmf'><p>Refine the final estimate of a GMF model</p></a></li>
<li><a href='#residuals.initgmf'><p>Extract the residuals of an initialized GMF model</p></a></li>
<li><a href='#residuals.sgdgmf'><p>Extract the residuals of a GMF model</p></a></li>
<li><a href='#screeplot.initgmf'><p>Screeplot for the residuals of an initialized GMF model</p></a></li>
<li><a href='#screeplot.sgdgmf'><p>Screeplot for the residuals of a GMF model</p></a></li>
<li><a href='#set.control.airwls'><p>Check and set the control parameters for the AIRWLS algorithm</p></a></li>
<li><a href='#set.control.alg'><p>Check and set the control parameters for the select optimization algorithm</p></a></li>
<li><a href='#set.control.block.sgd'><p>Check and set the control parameters for the blockwise-SGD algorithm</p></a></li>
<li><a href='#set.control.coord.sgd'><p>Check and set the control parameters for the coordinate-SGD algorithm</p></a></li>
<li><a href='#set.control.cv'><p>Check and set the cross-validation parameters</p></a></li>
<li><a href='#set.control.init'><p>Check and set the initialization parameters for a GMF model</p></a></li>
<li><a href='#set.control.newton'><p>Check and set the control parameters for the Newton algorithm</p></a></li>
<li><a href='#set.family'><p>Check and set the model family</p></a></li>
<li><a href='#set.mat.offset'><p>Check and set the offset matrix</p></a></li>
<li><a href='#set.mat.weights'><p>Check and set the weighting matrix</p></a></li>
<li><a href='#set.mat.X'><p>Check and set the covariate matrix X</p></a></li>
<li><a href='#set.mat.Y'><p>Check and set the response matrix Y</p></a></li>
<li><a href='#set.mat.Z'><p>Check and set the covariate matrix X</p></a></li>
<li><a href='#set.penalty'><p>Check and set the penalty parameters</p></a></li>
<li><a href='#sgdgmf.cv'><p>Model selection via cross-validation for generalized matrix factorization models</p></a></li>
<li><a href='#sgdgmf.cv.step'><p>Single step of cross-validation for generalized matrix factorization models</p></a></li>
<li><a href='#sgdgmf.fit'><p>Factorize a matrix of non-Gaussian observations using GMF</p></a></li>
<li><a href='#sgdgmf.init'><p>Initialize the parameters of a generalized matrix factorization model</p></a></li>
<li><a href='#sgdgmf.rank'><p>Rank selection via eigenvalue-gap methods</p></a></li>
<li><a href='#sim.gmf.data'><p>Simulate non-Gaussian data from a GMF model</p></a></li>
<li><a href='#simulate'><p>Simulate new data</p></a></li>
<li><a href='#simulate.sgdgmf'><p>Simulate method for GMF models</p></a></li>
<li><a href='#vglm.fit.coef'><p>Estimate the coefficients of a vector generalized linear model</p></a></li>
<li><a href='#whitening.matrix'><p>Compute the whitening matrix from a given covariance matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Estimation of Generalized Matrix Factorization Models via
Stochastic Gradient Descent</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-01-28</td>
</tr>
<tr>
<td>Description:</td>
<td>Efficient framework to estimate high-dimensional generalized matrix factorization models using penalized maximum likelihood under a dispersion exponential family specification. Either deterministic and stochastic methods are implemented for the numerical maximization. In particular, the package implements the stochastic gradient descent algorithm with a block-wise mini-batch strategy to speed up the computations and an efficient adaptive learning rate schedule to stabilize the convergence. All the theoretical details can be found in Castiglione et al. (2024, &lt;<a href="https://doi.org/10.48550%2FarXiv.2412.20509">doi:10.48550/arXiv.2412.20509</a>&gt;). Other methods considered for the optimization are the alternated iterative re-weighted least squares and the quasi-Newton method with diagonal approximation of the Fisher information matrix discussed in Kidzinski et al. (2022, <a href="http://jmlr.org/papers/v23/20-1104.html">http://jmlr.org/papers/v23/20-1104.html</a>).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.10), RcppArmadillo, RSpectra, parallel,
doParallel, foreach, MASS, SuppDists, methods, generics,
reshape2, ggpubr, viridisLite</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0), ggplot2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), Rtsne, dplyr, knitr, rmarkdown</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/CristianCastiglione/sgdGMF">https://github.com/CristianCastiglione/sgdGMF</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/CristianCastiglione/sgdGMF/issues">https://github.com/CristianCastiglione/sgdGMF/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-12 10:42:15 UTC; crist</td>
</tr>
<tr>
<td>Author:</td>
<td>Cristian Castiglione
    <a href="https://orcid.org/0000-0001-5883-4890"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Davide Risso <a href="https://orcid.org/0000-0001-8508-5012"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Alexandre Segers <a href="https://orcid.org/0009-0004-2028-7595"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Cristian Castiglione &lt;cristian_castiglione@libero.it&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-13 10:30:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='sgdGMF-package'>sgdGMF: Estimation of Generalized Matrix Factorization Models via Stochastic Gradient Descent</h2><span id='topic+sgdGMF'></span><span id='topic+sgdGMF-package'></span>

<h3>Description</h3>

<p>Efficient framework to estimate high-dimensional generalized matrix factorization models using penalized maximum likelihood under a dispersion exponential family specification. Either deterministic and stochastic methods are implemented for the numerical maximization. In particular, the package implements the stochastic gradient descent algorithm with a block-wise mini-batch strategy to speed up the computations and an efficient adaptive learning rate schedule to stabilize the convergence. All the theoretical details can be found in Castiglione et al. (2024, <a href="https://doi.org/10.48550/arXiv.2412.20509">doi:10.48550/arXiv.2412.20509</a>). Other methods considered for the optimization are the alternated iterative re-weighted least squares and the quasi-Newton method with diagonal approximation of the Fisher information matrix discussed in Kidzinski et al. (2022, <a href="http://jmlr.org/papers/v23/20-1104.html">http://jmlr.org/papers/v23/20-1104.html</a>).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Cristian Castiglione <a href="mailto:cristian_castiglione@libero.it">cristian_castiglione@libero.it</a> (<a href="https://orcid.org/0000-0001-5883-4890">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Davide Risso <a href="mailto:davide.risso@unipd.it">davide.risso@unipd.it</a> (<a href="https://orcid.org/0000-0001-8508-5012">ORCID</a>) [contributor]
</p>
</li>
<li><p> Alexandre Segers <a href="mailto:alexandre.segers@ugent.be">alexandre.segers@ugent.be</a> (<a href="https://orcid.org/0009-0004-2028-7595">ORCID</a>) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/CristianCastiglione/sgdGMF">https://github.com/CristianCastiglione/sgdGMF</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/CristianCastiglione/sgdGMF/issues">https://github.com/CristianCastiglione/sgdGMF/issues</a>
</p>
</li></ul>


<hr>
<h2 id='biplot.initgmf'>Biplot of an initialized GMF model</h2><span id='topic+biplot.initgmf'></span>

<h3>Description</h3>

<p>Plot the observations on a two-dimensional projection determined by the
estimated score matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'initgmf'
biplot(
  x,
  ...,
  choices = 1:2,
  arrange = TRUE,
  byrow = FALSE,
  normalize = FALSE,
  labels = NULL,
  palette = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="biplot.initgmf_+3A_x">x</code></td>
<td>
<p>an object of class <code>initgmf</code></p>
</td></tr>
<tr><td><code id="biplot.initgmf_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="biplot.initgmf_+3A_choices">choices</code></td>
<td>
<p>a length 2 vector specifying the components to plot</p>
</td></tr>
<tr><td><code id="biplot.initgmf_+3A_arrange">arrange</code></td>
<td>
<p>if <code>TRUE</code>, return a single plot with two panels</p>
</td></tr>
<tr><td><code id="biplot.initgmf_+3A_byrow">byrow</code></td>
<td>
<p>if <code>TRUE</code>, the panels are arranged row-wise (if <code>arrange=TRUE</code>)</p>
</td></tr>
<tr><td><code id="biplot.initgmf_+3A_normalize">normalize</code></td>
<td>
<p>if <code>TRUE</code>, orthogonalizes the scores using SVD</p>
</td></tr>
<tr><td><code id="biplot.initgmf_+3A_labels">labels</code></td>
<td>
<p>a vector of labels which should be plotted</p>
</td></tr>
<tr><td><code id="biplot.initgmf_+3A_palette">palette</code></td>
<td>
<p>the color-palette which should be used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>arrange=TRUE</code>, a single ggplot object with the selected biplots,
otherwise, a list of two ggplot objects showing the row and column latent variables.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+biplot.sgdgmf">biplot.sgdgmf</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the sgdGMF package
library(sgdGMF)

# Generate data from a Poisson model
data = sim.gmf.data(n = 100, m = 20, ncomp = 5, family = poisson())

# Fit a GMF model
init = sgdgmf.init(data$Y, ncomp = 3, family = poisson())

# Get the biplot of a GMF model
biplot(init) # 1st vs 2nd principal components
biplot(init, choices = 2:3) #2nd vs 3rd principal components

</code></pre>

<hr>
<h2 id='biplot.sgdgmf'>Biplot of a GMF model</h2><span id='topic+biplot.sgdgmf'></span>

<h3>Description</h3>

<p>Plot the observations on a two-dimensional projection determined by the
estimated score matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sgdgmf'
biplot(
  x,
  ...,
  choices = 1:2,
  arrange = TRUE,
  byrow = FALSE,
  normalize = FALSE,
  labels = NULL,
  palette = NULL,
  titles = c(NULL, NULL)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="biplot.sgdgmf_+3A_x">x</code></td>
<td>
<p>an object of class <code>sgdgmf</code></p>
</td></tr>
<tr><td><code id="biplot.sgdgmf_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="biplot.sgdgmf_+3A_choices">choices</code></td>
<td>
<p>a length 2 vector specifying the components to plot</p>
</td></tr>
<tr><td><code id="biplot.sgdgmf_+3A_arrange">arrange</code></td>
<td>
<p>if <code>TRUE</code>, return a single plot with two panels</p>
</td></tr>
<tr><td><code id="biplot.sgdgmf_+3A_byrow">byrow</code></td>
<td>
<p>if <code>TRUE</code>, the panels are arranged row-wise (if <code>arrange=TRUE</code>)</p>
</td></tr>
<tr><td><code id="biplot.sgdgmf_+3A_normalize">normalize</code></td>
<td>
<p>if <code>TRUE</code>, orthogonalizes the scores using SVD</p>
</td></tr>
<tr><td><code id="biplot.sgdgmf_+3A_labels">labels</code></td>
<td>
<p>a vector of labels which should be plotted</p>
</td></tr>
<tr><td><code id="biplot.sgdgmf_+3A_palette">palette</code></td>
<td>
<p>the color-palette which should be used</p>
</td></tr>
<tr><td><code id="biplot.sgdgmf_+3A_titles">titles</code></td>
<td>
<p>a 2-dimensional string vector containing the plot titles</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>arrange=TRUE</code>, a single ggplot object with the selected biplots,
otherwise, a list of two ggplot objects showing the row and column latent variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the sgdGMF package
library(sgdGMF)

# Generate data from a Poisson model
data = sim.gmf.data(n = 100, m = 20, ncomp = 5, family = poisson())

# Fit a GMF model
gmf = sgdgmf.fit(data$Y, ncomp = 3, family = poisson())

# Get the biplot of a GMF model
biplot(gmf)

</code></pre>

<hr>
<h2 id='coefficients.initgmf'>Extract the coefficient of an initialized GMF model</h2><span id='topic+coefficients.initgmf'></span><span id='topic+coef.initgmf'></span>

<h3>Description</h3>

<p>Return the initialized coefficients of a GMF model, i.e., the row- and column-specific
regression effects, the latent scores and loadings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'initgmf'
coefficients(
  object,
  ...,
  type = c("all", "colreg", "rowreg", "scores", "loadings")
)

## S3 method for class 'initgmf'
coef(object, ..., type = c("all", "colreg", "rowreg", "scores", "loadings"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coefficients.initgmf_+3A_object">object</code></td>
<td>
<p>an object of class <code>initgmf</code></p>
</td></tr>
<tr><td><code id="coefficients.initgmf_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="coefficients.initgmf_+3A_type">type</code></td>
<td>
<p>the type of coefficients which should be returned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>type="all"</code>, a list of coefficients containing the fields <code>B</code>, <code>A</code>, <code>U</code> and <code>V</code>.
Otherwise, a matrix of coefficients, corresponding to the selected <code>type</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coefficients.sgdgmf">coefficients.sgdgmf</a></code> and <code><a href="#topic+coef.sgdgmf">coef.sgdgmf</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the sgdGMF package
library(sgdGMF)

# Generate data from a Poisson model
data = sim.gmf.data(n = 100, m = 20, ncomp = 5, family = poisson())

# Fit a GMF model with 3 latent factors
init = sgdgmf.init(data$Y, ncomp = 3, family = poisson())

# Get the estimated coefficients of a GMF model
str(coefficients(init)) # returns all the coefficients
str(coefficients(init, type = "scores")) # returns only the scores, say U
str(coefficients(init, type = "loadings")) # returns only the loadings, say V

</code></pre>

<hr>
<h2 id='coefficients.sgdgmf'>Extract the coefficient of a GMF model</h2><span id='topic+coefficients.sgdgmf'></span><span id='topic+coef.sgdgmf'></span>

<h3>Description</h3>

<p>Return the estimated coefficients of a GMF model, i.e., the row- and column-specific
regression effects, the latent scores and loadings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sgdgmf'
coefficients(
  object,
  ...,
  type = c("all", "colreg", "rowreg", "scores", "loadings")
)

## S3 method for class 'sgdgmf'
coef(object, ..., type = c("all", "colreg", "rowreg", "scores", "loadings"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coefficients.sgdgmf_+3A_object">object</code></td>
<td>
<p>an object of class <code>sgdgmf</code></p>
</td></tr>
<tr><td><code id="coefficients.sgdgmf_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="coefficients.sgdgmf_+3A_type">type</code></td>
<td>
<p>the type of coefficients which should be returned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>type="all"</code>, a list of coefficients containing the fields <code>B</code>, <code>A</code>, <code>U</code> and <code>V</code>.
Otherwise, a matrix of coefficients, corresponding to the selected <code>type</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the sgdGMF package
library(sgdGMF)

# Generate data from a Poisson model
data = sim.gmf.data(n = 100, m = 20, ncomp = 5, family = poisson())

# Fit a GMF model with 3 latent factors
gmf = sgdgmf.fit(data$Y, ncomp = 3, family = poisson())

# Get the estimated coefficients of a GMF model
str(coefficients(gmf)) # returns all the coefficients
str(coefficients(gmf, type = "scores")) # returns only the scores, say U
str(coefficients(gmf, type = "loadings")) # returns only the loadings, say V

</code></pre>

<hr>
<h2 id='cpp.airwls.glmfit'>Fisher scoring algorithm for GLMs</h2><span id='topic+cpp.airwls.glmfit'></span>

<h3>Description</h3>

<p>Internal function implementing the Fisher scoring algorithms for the
estimation of GLMs. It is used in the AIRWLS algorithm for the 
estimation of GMF models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpp.airwls.glmfit(
  beta,
  y,
  X,
  familyname,
  linkname,
  varfname,
  offset,
  weights,
  penalty,
  nsteps = 100L,
  stepsize = 0.1,
  print = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cpp.airwls.glmfit_+3A_beta">beta</code></td>
<td>
<p>initial value of the regression coefficients to be estimated</p>
</td></tr>
<tr><td><code id="cpp.airwls.glmfit_+3A_y">y</code></td>
<td>
<p>response vector</p>
</td></tr>
<tr><td><code id="cpp.airwls.glmfit_+3A_x">X</code></td>
<td>
<p>design matrix</p>
</td></tr>
<tr><td><code id="cpp.airwls.glmfit_+3A_familyname">familyname</code></td>
<td>
<p>model family name</p>
</td></tr>
<tr><td><code id="cpp.airwls.glmfit_+3A_linkname">linkname</code></td>
<td>
<p>link function name</p>
</td></tr>
<tr><td><code id="cpp.airwls.glmfit_+3A_varfname">varfname</code></td>
<td>
<p>variance function name</p>
</td></tr>
<tr><td><code id="cpp.airwls.glmfit_+3A_offset">offset</code></td>
<td>
<p>vector of constants to be added to the linear predictor</p>
</td></tr>
<tr><td><code id="cpp.airwls.glmfit_+3A_weights">weights</code></td>
<td>
<p>vector of constants non-negative weights</p>
</td></tr>
<tr><td><code id="cpp.airwls.glmfit_+3A_penalty">penalty</code></td>
<td>
<p>penalty parameter of a ridge-type penalty</p>
</td></tr>
<tr><td><code id="cpp.airwls.glmfit_+3A_nsteps">nsteps</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="cpp.airwls.glmfit_+3A_stepsize">stepsize</code></td>
<td>
<p>stepsize parameter of the Fisher scoring algorithm</p>
</td></tr>
<tr><td><code id="cpp.airwls.glmfit_+3A_print">print</code></td>
<td>
<p>if <code>TRUE</code>, print the algorithm history</p>
</td></tr>
</table>

<hr>
<h2 id='cpp.airwls.glmstep'>Compute one Fisher scoring step for GLMs</h2><span id='topic+cpp.airwls.glmstep'></span>

<h3>Description</h3>

<p>Internal function to compute one Fisher scoring step for GLMs.
It constitutes the building block of the AIRWLS algorithm for the
estimation of GMF models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpp.airwls.glmstep(
  beta,
  y,
  X,
  familyname,
  linkname,
  varfname,
  offset,
  weights,
  penalty
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cpp.airwls.glmstep_+3A_beta">beta</code></td>
<td>
<p>current value of the regression coefficients to be updated</p>
</td></tr>
<tr><td><code id="cpp.airwls.glmstep_+3A_y">y</code></td>
<td>
<p>response vector</p>
</td></tr>
<tr><td><code id="cpp.airwls.glmstep_+3A_x">X</code></td>
<td>
<p>design matrix</p>
</td></tr>
<tr><td><code id="cpp.airwls.glmstep_+3A_familyname">familyname</code></td>
<td>
<p>model family name</p>
</td></tr>
<tr><td><code id="cpp.airwls.glmstep_+3A_linkname">linkname</code></td>
<td>
<p>link function name</p>
</td></tr>
<tr><td><code id="cpp.airwls.glmstep_+3A_varfname">varfname</code></td>
<td>
<p>variance function name</p>
</td></tr>
<tr><td><code id="cpp.airwls.glmstep_+3A_offset">offset</code></td>
<td>
<p>vector of constants to be added to the linear predictor</p>
</td></tr>
<tr><td><code id="cpp.airwls.glmstep_+3A_weights">weights</code></td>
<td>
<p>vector of constants non-negative weights</p>
</td></tr>
<tr><td><code id="cpp.airwls.glmstep_+3A_penalty">penalty</code></td>
<td>
<p>penalty parameter of a ridge-type penalty</p>
</td></tr>
</table>

<hr>
<h2 id='cpp.airwls.update'>AIRWLS update for GMF models</h2><span id='topic+cpp.airwls.update'></span>

<h3>Description</h3>

<p>Internal function implementing one step of AIRWLS for the
estimation of GMF models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpp.airwls.update(
  beta,
  Y,
  X,
  familyname,
  linkname,
  varfname,
  idx,
  offset,
  weights,
  penalty,
  transp = FALSE,
  nsteps = 100L,
  stepsize = 0.1,
  print = FALSE,
  parallel = FALSE,
  nthreads = 1L
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cpp.airwls.update_+3A_beta">beta</code></td>
<td>
<p>initial value of the regression coefficients to be estimated</p>
</td></tr>
<tr><td><code id="cpp.airwls.update_+3A_y">Y</code></td>
<td>
<p>response vector</p>
</td></tr>
<tr><td><code id="cpp.airwls.update_+3A_x">X</code></td>
<td>
<p>design matrix</p>
</td></tr>
<tr><td><code id="cpp.airwls.update_+3A_familyname">familyname</code></td>
<td>
<p>model family name</p>
</td></tr>
<tr><td><code id="cpp.airwls.update_+3A_linkname">linkname</code></td>
<td>
<p>link function name</p>
</td></tr>
<tr><td><code id="cpp.airwls.update_+3A_varfname">varfname</code></td>
<td>
<p>variance function name</p>
</td></tr>
<tr><td><code id="cpp.airwls.update_+3A_idx">idx</code></td>
<td>
<p>index identifying the parameters to be updated in <code>beta</code></p>
</td></tr>
<tr><td><code id="cpp.airwls.update_+3A_offset">offset</code></td>
<td>
<p>vector of constants to be added to the linear predictor</p>
</td></tr>
<tr><td><code id="cpp.airwls.update_+3A_weights">weights</code></td>
<td>
<p>vector of constants non-negative weights</p>
</td></tr>
<tr><td><code id="cpp.airwls.update_+3A_penalty">penalty</code></td>
<td>
<p>penalty parameter of a ridge-type penalty</p>
</td></tr>
<tr><td><code id="cpp.airwls.update_+3A_transp">transp</code></td>
<td>
<p>if <code>TRUE</code>, transpose the data</p>
</td></tr>
<tr><td><code id="cpp.airwls.update_+3A_nsteps">nsteps</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="cpp.airwls.update_+3A_stepsize">stepsize</code></td>
<td>
<p>stepsize parameter of the Fisher scoring algorithm</p>
</td></tr>
<tr><td><code id="cpp.airwls.update_+3A_print">print</code></td>
<td>
<p>if <code>TRUE</code>, print the algorithm history</p>
</td></tr>
<tr><td><code id="cpp.airwls.update_+3A_parallel">parallel</code></td>
<td>
<p>if <code>TRUE</code>, run the updates in parallel using <code>openMP</code></p>
</td></tr>
<tr><td><code id="cpp.airwls.update_+3A_nthreads">nthreads</code></td>
<td>
<p>number of threads to be run in parallel (only if <code>parallel=TRUE</code>)</p>
</td></tr>
</table>

<hr>
<h2 id='cpp.fit.airwls'>Fit a GMF model using the AIRWLS algorithm</h2><span id='topic+cpp.fit.airwls'></span>

<h3>Description</h3>

<p>Fit a GMF model using the AIRWLS algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpp.fit.airwls(
  Y,
  X,
  B,
  A,
  Z,
  U,
  V,
  O,
  W,
  familyname,
  linkname,
  varfname,
  ncomp,
  lambda,
  maxiter = 500L,
  nsteps = 1L,
  stepsize = 0.1,
  eps = 1e-08,
  nafill = 1L,
  tol = 1e-05,
  damping = 0.001,
  verbose = TRUE,
  frequency = 10L,
  parallel = FALSE,
  nthreads = 1L
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cpp.fit.airwls_+3A_y">Y</code></td>
<td>
<p>matrix of responses (<code class="reqn">n \times m</code>)</p>
</td></tr>
<tr><td><code id="cpp.fit.airwls_+3A_x">X</code></td>
<td>
<p>matrix of row fixed effects (<code class="reqn">n \times p</code>)</p>
</td></tr>
<tr><td><code id="cpp.fit.airwls_+3A_b">B</code></td>
<td>
<p>initial row-effect matrix (<code class="reqn">n \times p</code>)</p>
</td></tr>
<tr><td><code id="cpp.fit.airwls_+3A_a">A</code></td>
<td>
<p>initial column-effect matrix (<code class="reqn">n \times q</code>)</p>
</td></tr>
<tr><td><code id="cpp.fit.airwls_+3A_z">Z</code></td>
<td>
<p>matrix of column fixed effects (<code class="reqn">m \times q</code>)</p>
</td></tr>
<tr><td><code id="cpp.fit.airwls_+3A_u">U</code></td>
<td>
<p>initial factor matrix (<code class="reqn">n \times d</code>)</p>
</td></tr>
<tr><td><code id="cpp.fit.airwls_+3A_v">V</code></td>
<td>
<p>initial loading matrix (<code class="reqn">m \times d</code>)</p>
</td></tr>
<tr><td><code id="cpp.fit.airwls_+3A_o">O</code></td>
<td>
<p>matrix of constant offset (<code class="reqn">n \times m</code>)</p>
</td></tr>
<tr><td><code id="cpp.fit.airwls_+3A_w">W</code></td>
<td>
<p>matrix of constant weights (<code class="reqn">n \times m</code>)</p>
</td></tr>
<tr><td><code id="cpp.fit.airwls_+3A_familyname">familyname</code></td>
<td>
<p>a <code>glm</code> model family name</p>
</td></tr>
<tr><td><code id="cpp.fit.airwls_+3A_linkname">linkname</code></td>
<td>
<p>a <code>glm</code> link function name</p>
</td></tr>
<tr><td><code id="cpp.fit.airwls_+3A_varfname">varfname</code></td>
<td>
<p>variance function name</p>
</td></tr>
<tr><td><code id="cpp.fit.airwls_+3A_ncomp">ncomp</code></td>
<td>
<p>rank of the latent matrix factorization</p>
</td></tr>
<tr><td><code id="cpp.fit.airwls_+3A_lambda">lambda</code></td>
<td>
<p>penalization parameters</p>
</td></tr>
<tr><td><code id="cpp.fit.airwls_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
<tr><td><code id="cpp.fit.airwls_+3A_nsteps">nsteps</code></td>
<td>
<p>number of inner Fisher scoring iterations</p>
</td></tr>
<tr><td><code id="cpp.fit.airwls_+3A_stepsize">stepsize</code></td>
<td>
<p>stepsize of the inner Fisher scoring algorithm</p>
</td></tr>
<tr><td><code id="cpp.fit.airwls_+3A_eps">eps</code></td>
<td>
<p>shrinkage factor for extreme predictions</p>
</td></tr>
<tr><td><code id="cpp.fit.airwls_+3A_nafill">nafill</code></td>
<td>
<p>how often the missing values are updated</p>
</td></tr>
<tr><td><code id="cpp.fit.airwls_+3A_tol">tol</code></td>
<td>
<p>tolerance threshold for the stopping criterion</p>
</td></tr>
<tr><td><code id="cpp.fit.airwls_+3A_damping">damping</code></td>
<td>
<p>diagonal dumping factor for the Hessian matrix</p>
</td></tr>
<tr><td><code id="cpp.fit.airwls_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, print the optimization status</p>
</td></tr>
<tr><td><code id="cpp.fit.airwls_+3A_frequency">frequency</code></td>
<td>
<p>how often the optimization status is printed</p>
</td></tr>
<tr><td><code id="cpp.fit.airwls_+3A_parallel">parallel</code></td>
<td>
<p>if <code>TRUE</code>, allows for parallel computing</p>
</td></tr>
<tr><td><code id="cpp.fit.airwls_+3A_nthreads">nthreads</code></td>
<td>
<p>number of cores to be used in parallel</p>
</td></tr>
</table>

<hr>
<h2 id='cpp.fit.block.sgd'>Fit a GMF model using the adaptive SGD with block-wise minibatch subsampling</h2><span id='topic+cpp.fit.block.sgd'></span>

<h3>Description</h3>

<p>Fit a GMF model using the adaptive SGD with block-wise minibatch subsampling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpp.fit.block.sgd(
  Y,
  X,
  B,
  A,
  Z,
  U,
  V,
  O,
  W,
  familyname,
  linkname,
  varfname,
  ncomp,
  lambda,
  maxiter = 1000L,
  eps = 0.01,
  nafill = 10L,
  tol = 1e-08,
  size1 = 100L,
  size2 = 100L,
  burn = 0.75,
  rate0 = 0.01,
  decay = 0.01,
  damping = 0.001,
  rate1 = 0.95,
  rate2 = 0.99,
  parallel = FALSE,
  nthreads = 1L,
  verbose = TRUE,
  frequency = 250L,
  progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cpp.fit.block.sgd_+3A_y">Y</code></td>
<td>
<p>matrix of responses (<code class="reqn">n \times m</code>)</p>
</td></tr>
<tr><td><code id="cpp.fit.block.sgd_+3A_x">X</code></td>
<td>
<p>matrix of row fixed effects (<code class="reqn">n \times p</code>)</p>
</td></tr>
<tr><td><code id="cpp.fit.block.sgd_+3A_b">B</code></td>
<td>
<p>initial row-effect matrix (<code class="reqn">n \times p</code>)</p>
</td></tr>
<tr><td><code id="cpp.fit.block.sgd_+3A_a">A</code></td>
<td>
<p>initial column-effect matrix (<code class="reqn">n \times q</code>)</p>
</td></tr>
<tr><td><code id="cpp.fit.block.sgd_+3A_z">Z</code></td>
<td>
<p>matrix of column fixed effects (<code class="reqn">m \times q</code>)</p>
</td></tr>
<tr><td><code id="cpp.fit.block.sgd_+3A_u">U</code></td>
<td>
<p>initial factor matrix (<code class="reqn">n \times d</code>)</p>
</td></tr>
<tr><td><code id="cpp.fit.block.sgd_+3A_v">V</code></td>
<td>
<p>initial loading matrix (<code class="reqn">m \times d</code>)</p>
</td></tr>
<tr><td><code id="cpp.fit.block.sgd_+3A_o">O</code></td>
<td>
<p>matrix of constant offset (<code class="reqn">n \times m</code>)</p>
</td></tr>
<tr><td><code id="cpp.fit.block.sgd_+3A_w">W</code></td>
<td>
<p>matrix of constant weights (<code class="reqn">n \times m</code>)</p>
</td></tr>
<tr><td><code id="cpp.fit.block.sgd_+3A_familyname">familyname</code></td>
<td>
<p>a <code>glm</code> model family name</p>
</td></tr>
<tr><td><code id="cpp.fit.block.sgd_+3A_linkname">linkname</code></td>
<td>
<p>a <code>glm</code> link function name</p>
</td></tr>
<tr><td><code id="cpp.fit.block.sgd_+3A_varfname">varfname</code></td>
<td>
<p>variance function name</p>
</td></tr>
<tr><td><code id="cpp.fit.block.sgd_+3A_ncomp">ncomp</code></td>
<td>
<p>rank of the latent matrix factorization</p>
</td></tr>
<tr><td><code id="cpp.fit.block.sgd_+3A_lambda">lambda</code></td>
<td>
<p>penalization parameters</p>
</td></tr>
<tr><td><code id="cpp.fit.block.sgd_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
<tr><td><code id="cpp.fit.block.sgd_+3A_eps">eps</code></td>
<td>
<p>shrinkage factor for extreme predictions</p>
</td></tr>
<tr><td><code id="cpp.fit.block.sgd_+3A_nafill">nafill</code></td>
<td>
<p>how often the missing values are updated</p>
</td></tr>
<tr><td><code id="cpp.fit.block.sgd_+3A_tol">tol</code></td>
<td>
<p>tolerance threshold for the stopping criterion</p>
</td></tr>
<tr><td><code id="cpp.fit.block.sgd_+3A_size1">size1</code></td>
<td>
<p>row-minibatch dimension</p>
</td></tr>
<tr><td><code id="cpp.fit.block.sgd_+3A_size2">size2</code></td>
<td>
<p>column-minibatch dimension</p>
</td></tr>
<tr><td><code id="cpp.fit.block.sgd_+3A_burn">burn</code></td>
<td>
<p>burn-in period in which the learning late is not decreased</p>
</td></tr>
<tr><td><code id="cpp.fit.block.sgd_+3A_rate0">rate0</code></td>
<td>
<p>initial learning rate</p>
</td></tr>
<tr><td><code id="cpp.fit.block.sgd_+3A_decay">decay</code></td>
<td>
<p>decay rate of the learning rate</p>
</td></tr>
<tr><td><code id="cpp.fit.block.sgd_+3A_damping">damping</code></td>
<td>
<p>diagonal dumping factor for the Hessian matrix</p>
</td></tr>
<tr><td><code id="cpp.fit.block.sgd_+3A_rate1">rate1</code></td>
<td>
<p>decay rate of the first moment estimate of the gradient</p>
</td></tr>
<tr><td><code id="cpp.fit.block.sgd_+3A_rate2">rate2</code></td>
<td>
<p>decay rate of the second moment estimate of the gradient</p>
</td></tr>
<tr><td><code id="cpp.fit.block.sgd_+3A_parallel">parallel</code></td>
<td>
<p>if <code>TRUE</code>, allows for parallel computing</p>
</td></tr>
<tr><td><code id="cpp.fit.block.sgd_+3A_nthreads">nthreads</code></td>
<td>
<p>number of cores to be used in parallel</p>
</td></tr>
<tr><td><code id="cpp.fit.block.sgd_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, print the optimization status</p>
</td></tr>
<tr><td><code id="cpp.fit.block.sgd_+3A_frequency">frequency</code></td>
<td>
<p>how often the optimization status is printed</p>
</td></tr>
<tr><td><code id="cpp.fit.block.sgd_+3A_progress">progress</code></td>
<td>
<p>if <code>TRUE</code>, print an progress bar</p>
</td></tr>
</table>

<hr>
<h2 id='cpp.fit.coord.sgd'>Fit a GMF model using the adaptive SGD with coordinate-wise minibatch subsampling algorithm</h2><span id='topic+cpp.fit.coord.sgd'></span>

<h3>Description</h3>

<p>Fit a GMF model using the adaptive SGD with coordinate-wise minibatch subsampling algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpp.fit.coord.sgd(
  Y,
  X,
  B,
  A,
  Z,
  U,
  V,
  O,
  W,
  familyname,
  linkname,
  varfname,
  ncomp,
  lambda,
  maxiter = 1000L,
  eps = 0.01,
  nafill = 10L,
  tol = 1e-08,
  size1 = 100L,
  size2 = 100L,
  burn = 0.75,
  rate0 = 0.01,
  decay = 0.01,
  damping = 0.001,
  rate1 = 0.95,
  rate2 = 0.99,
  parallel = FALSE,
  nthreads = 1L,
  verbose = TRUE,
  frequency = 250L,
  progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cpp.fit.coord.sgd_+3A_y">Y</code></td>
<td>
<p>matrix of responses (<code class="reqn">n \times m</code>)</p>
</td></tr>
<tr><td><code id="cpp.fit.coord.sgd_+3A_x">X</code></td>
<td>
<p>matrix of row fixed effects (<code class="reqn">n \times p</code>)</p>
</td></tr>
<tr><td><code id="cpp.fit.coord.sgd_+3A_b">B</code></td>
<td>
<p>initial row-effect matrix (<code class="reqn">n \times p</code>)</p>
</td></tr>
<tr><td><code id="cpp.fit.coord.sgd_+3A_a">A</code></td>
<td>
<p>initial column-effect matrix (<code class="reqn">n \times q</code>)</p>
</td></tr>
<tr><td><code id="cpp.fit.coord.sgd_+3A_z">Z</code></td>
<td>
<p>matrix of column fixed effects (<code class="reqn">m \times q</code>)</p>
</td></tr>
<tr><td><code id="cpp.fit.coord.sgd_+3A_u">U</code></td>
<td>
<p>initial factor matrix (<code class="reqn">n \times d</code>)</p>
</td></tr>
<tr><td><code id="cpp.fit.coord.sgd_+3A_v">V</code></td>
<td>
<p>initial loading matrix (<code class="reqn">m \times d</code>)</p>
</td></tr>
<tr><td><code id="cpp.fit.coord.sgd_+3A_o">O</code></td>
<td>
<p>matrix of constant offset (<code class="reqn">n \times m</code>)</p>
</td></tr>
<tr><td><code id="cpp.fit.coord.sgd_+3A_w">W</code></td>
<td>
<p>matrix of constant weights (<code class="reqn">n \times m</code>)</p>
</td></tr>
<tr><td><code id="cpp.fit.coord.sgd_+3A_familyname">familyname</code></td>
<td>
<p>a <code>glm</code> model family name</p>
</td></tr>
<tr><td><code id="cpp.fit.coord.sgd_+3A_linkname">linkname</code></td>
<td>
<p>a <code>glm</code> link function name</p>
</td></tr>
<tr><td><code id="cpp.fit.coord.sgd_+3A_varfname">varfname</code></td>
<td>
<p>variance function name</p>
</td></tr>
<tr><td><code id="cpp.fit.coord.sgd_+3A_ncomp">ncomp</code></td>
<td>
<p>rank of the latent matrix factorization</p>
</td></tr>
<tr><td><code id="cpp.fit.coord.sgd_+3A_lambda">lambda</code></td>
<td>
<p>penalization parameters</p>
</td></tr>
<tr><td><code id="cpp.fit.coord.sgd_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
<tr><td><code id="cpp.fit.coord.sgd_+3A_eps">eps</code></td>
<td>
<p>shrinkage factor for extreme predictions</p>
</td></tr>
<tr><td><code id="cpp.fit.coord.sgd_+3A_nafill">nafill</code></td>
<td>
<p>how often the missing values are updated</p>
</td></tr>
<tr><td><code id="cpp.fit.coord.sgd_+3A_tol">tol</code></td>
<td>
<p>tolerance threshold for the stopping criterion</p>
</td></tr>
<tr><td><code id="cpp.fit.coord.sgd_+3A_size1">size1</code></td>
<td>
<p>row-minibatch dimension</p>
</td></tr>
<tr><td><code id="cpp.fit.coord.sgd_+3A_size2">size2</code></td>
<td>
<p>column-minibatch dimension</p>
</td></tr>
<tr><td><code id="cpp.fit.coord.sgd_+3A_burn">burn</code></td>
<td>
<p>burn-in period in which the learning late is not decreased</p>
</td></tr>
<tr><td><code id="cpp.fit.coord.sgd_+3A_rate0">rate0</code></td>
<td>
<p>initial learning rate</p>
</td></tr>
<tr><td><code id="cpp.fit.coord.sgd_+3A_decay">decay</code></td>
<td>
<p>decay rate of the learning rate</p>
</td></tr>
<tr><td><code id="cpp.fit.coord.sgd_+3A_damping">damping</code></td>
<td>
<p>diagonal dumping factor for the Hessian matrix</p>
</td></tr>
<tr><td><code id="cpp.fit.coord.sgd_+3A_rate1">rate1</code></td>
<td>
<p>decay rate of the first moment estimate of the gradient</p>
</td></tr>
<tr><td><code id="cpp.fit.coord.sgd_+3A_rate2">rate2</code></td>
<td>
<p>decay rate of the second moment estimate of the gradient</p>
</td></tr>
<tr><td><code id="cpp.fit.coord.sgd_+3A_parallel">parallel</code></td>
<td>
<p>if <code>TRUE</code>, allows for parallel computing</p>
</td></tr>
<tr><td><code id="cpp.fit.coord.sgd_+3A_nthreads">nthreads</code></td>
<td>
<p>number of cores to be used in parallel</p>
</td></tr>
<tr><td><code id="cpp.fit.coord.sgd_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, print the optimization status</p>
</td></tr>
<tr><td><code id="cpp.fit.coord.sgd_+3A_frequency">frequency</code></td>
<td>
<p>how often the optimization status is printed</p>
</td></tr>
<tr><td><code id="cpp.fit.coord.sgd_+3A_progress">progress</code></td>
<td>
<p>if <code>TRUE</code>, print an progress bar</p>
</td></tr>
</table>

<hr>
<h2 id='cpp.fit.newton'>Fit a GMF model using the diagonal quasi-Newton algorithm</h2><span id='topic+cpp.fit.newton'></span>

<h3>Description</h3>

<p>Fit a GMF model using the diagonal quasi-Newton algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpp.fit.newton(
  Y,
  X,
  B,
  A,
  Z,
  U,
  V,
  O,
  W,
  familyname,
  linkname,
  varfname,
  ncomp,
  lambda,
  maxiter = 500L,
  stepsize = 0.1,
  eps = 1e-08,
  nafill = 1L,
  tol = 1e-05,
  damping = 0.001,
  verbose = TRUE,
  frequency = 10L,
  parallel = FALSE,
  nthreads = 1L
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cpp.fit.newton_+3A_y">Y</code></td>
<td>
<p>matrix of responses (<code class="reqn">n \times m</code>)</p>
</td></tr>
<tr><td><code id="cpp.fit.newton_+3A_x">X</code></td>
<td>
<p>matrix of row fixed effects (<code class="reqn">n \times p</code>)</p>
</td></tr>
<tr><td><code id="cpp.fit.newton_+3A_b">B</code></td>
<td>
<p>initial row-effect matrix (<code class="reqn">n \times p</code>)</p>
</td></tr>
<tr><td><code id="cpp.fit.newton_+3A_a">A</code></td>
<td>
<p>initial column-effect matrix (<code class="reqn">n \times q</code>)</p>
</td></tr>
<tr><td><code id="cpp.fit.newton_+3A_z">Z</code></td>
<td>
<p>matrix of column fixed effects (<code class="reqn">m \times q</code>)</p>
</td></tr>
<tr><td><code id="cpp.fit.newton_+3A_u">U</code></td>
<td>
<p>initial factor matrix (<code class="reqn">n \times d</code>)</p>
</td></tr>
<tr><td><code id="cpp.fit.newton_+3A_v">V</code></td>
<td>
<p>initial loading matrix (<code class="reqn">m \times d</code>)</p>
</td></tr>
<tr><td><code id="cpp.fit.newton_+3A_o">O</code></td>
<td>
<p>matrix of constant offset (<code class="reqn">n \times m</code>)</p>
</td></tr>
<tr><td><code id="cpp.fit.newton_+3A_w">W</code></td>
<td>
<p>matrix of constant weights (<code class="reqn">n \times m</code>)</p>
</td></tr>
<tr><td><code id="cpp.fit.newton_+3A_familyname">familyname</code></td>
<td>
<p>a <code>glm</code> model family name</p>
</td></tr>
<tr><td><code id="cpp.fit.newton_+3A_linkname">linkname</code></td>
<td>
<p>a <code>glm</code> link function name</p>
</td></tr>
<tr><td><code id="cpp.fit.newton_+3A_varfname">varfname</code></td>
<td>
<p>variance function name</p>
</td></tr>
<tr><td><code id="cpp.fit.newton_+3A_ncomp">ncomp</code></td>
<td>
<p>rank of the latent matrix factorization</p>
</td></tr>
<tr><td><code id="cpp.fit.newton_+3A_lambda">lambda</code></td>
<td>
<p>penalization parameters</p>
</td></tr>
<tr><td><code id="cpp.fit.newton_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
<tr><td><code id="cpp.fit.newton_+3A_stepsize">stepsize</code></td>
<td>
<p>stepsize of the quasi-Newton update</p>
</td></tr>
<tr><td><code id="cpp.fit.newton_+3A_eps">eps</code></td>
<td>
<p>shrinkage factor for extreme predictions</p>
</td></tr>
<tr><td><code id="cpp.fit.newton_+3A_nafill">nafill</code></td>
<td>
<p>how often the missing values are updated</p>
</td></tr>
<tr><td><code id="cpp.fit.newton_+3A_tol">tol</code></td>
<td>
<p>tolerance threshold for the stopping criterion</p>
</td></tr>
<tr><td><code id="cpp.fit.newton_+3A_damping">damping</code></td>
<td>
<p>diagonal dumping factor for the Hessian matrix</p>
</td></tr>
<tr><td><code id="cpp.fit.newton_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, print the optimization status</p>
</td></tr>
<tr><td><code id="cpp.fit.newton_+3A_frequency">frequency</code></td>
<td>
<p>how often the optimization status is printed</p>
</td></tr>
<tr><td><code id="cpp.fit.newton_+3A_parallel">parallel</code></td>
<td>
<p>if <code>TRUE</code>, allows for parallel computing</p>
</td></tr>
<tr><td><code id="cpp.fit.newton_+3A_nthreads">nthreads</code></td>
<td>
<p>number of cores to be used in parallel</p>
</td></tr>
</table>

<hr>
<h2 id='cpp.fit.random.block.sgd'>Fit a GMF model using the adaptive SGD with block-wise minibatch subsampling</h2><span id='topic+cpp.fit.random.block.sgd'></span>

<h3>Description</h3>

<p>Fit a GMF model using the adaptive SGD with block-wise minibatch subsampling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpp.fit.random.block.sgd(
  Y,
  X,
  B,
  A,
  Z,
  U,
  V,
  O,
  W,
  familyname,
  linkname,
  varfname,
  ncomp,
  lambda,
  maxiter = 1000L,
  eps = 0.01,
  nafill = 10L,
  tol = 1e-08,
  size1 = 100L,
  size2 = 100L,
  burn = 0.75,
  rate0 = 0.01,
  decay = 0.01,
  damping = 0.001,
  rate1 = 0.95,
  rate2 = 0.99,
  parallel = FALSE,
  nthreads = 1L,
  verbose = TRUE,
  frequency = 250L,
  progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cpp.fit.random.block.sgd_+3A_y">Y</code></td>
<td>
<p>matrix of responses (<code class="reqn">n \times m</code>)</p>
</td></tr>
<tr><td><code id="cpp.fit.random.block.sgd_+3A_x">X</code></td>
<td>
<p>matrix of row fixed effects (<code class="reqn">n \times p</code>)</p>
</td></tr>
<tr><td><code id="cpp.fit.random.block.sgd_+3A_b">B</code></td>
<td>
<p>initial row-effect matrix (<code class="reqn">n \times p</code>)</p>
</td></tr>
<tr><td><code id="cpp.fit.random.block.sgd_+3A_a">A</code></td>
<td>
<p>initial column-effect matrix (<code class="reqn">n \times q</code>)</p>
</td></tr>
<tr><td><code id="cpp.fit.random.block.sgd_+3A_z">Z</code></td>
<td>
<p>matrix of column fixed effects (<code class="reqn">m \times q</code>)</p>
</td></tr>
<tr><td><code id="cpp.fit.random.block.sgd_+3A_u">U</code></td>
<td>
<p>initial factor matrix (<code class="reqn">n \times d</code>)</p>
</td></tr>
<tr><td><code id="cpp.fit.random.block.sgd_+3A_v">V</code></td>
<td>
<p>initial loading matrix (<code class="reqn">m \times d</code>)</p>
</td></tr>
<tr><td><code id="cpp.fit.random.block.sgd_+3A_o">O</code></td>
<td>
<p>matrix of constant offset (<code class="reqn">n \times m</code>)</p>
</td></tr>
<tr><td><code id="cpp.fit.random.block.sgd_+3A_w">W</code></td>
<td>
<p>matrix of constant weights (<code class="reqn">n \times m</code>)</p>
</td></tr>
<tr><td><code id="cpp.fit.random.block.sgd_+3A_familyname">familyname</code></td>
<td>
<p>a <code>glm</code> model family name</p>
</td></tr>
<tr><td><code id="cpp.fit.random.block.sgd_+3A_linkname">linkname</code></td>
<td>
<p>a <code>glm</code> link function name</p>
</td></tr>
<tr><td><code id="cpp.fit.random.block.sgd_+3A_varfname">varfname</code></td>
<td>
<p>variance function name</p>
</td></tr>
<tr><td><code id="cpp.fit.random.block.sgd_+3A_ncomp">ncomp</code></td>
<td>
<p>rank of the latent matrix factorization</p>
</td></tr>
<tr><td><code id="cpp.fit.random.block.sgd_+3A_lambda">lambda</code></td>
<td>
<p>penalization parameters</p>
</td></tr>
<tr><td><code id="cpp.fit.random.block.sgd_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
<tr><td><code id="cpp.fit.random.block.sgd_+3A_eps">eps</code></td>
<td>
<p>shrinkage factor for extreme predictions</p>
</td></tr>
<tr><td><code id="cpp.fit.random.block.sgd_+3A_nafill">nafill</code></td>
<td>
<p>how often the missing values are updated</p>
</td></tr>
<tr><td><code id="cpp.fit.random.block.sgd_+3A_tol">tol</code></td>
<td>
<p>tolerance threshold for the stopping criterion</p>
</td></tr>
<tr><td><code id="cpp.fit.random.block.sgd_+3A_size1">size1</code></td>
<td>
<p>row-minibatch dimension</p>
</td></tr>
<tr><td><code id="cpp.fit.random.block.sgd_+3A_size2">size2</code></td>
<td>
<p>column-minibatch dimension</p>
</td></tr>
<tr><td><code id="cpp.fit.random.block.sgd_+3A_burn">burn</code></td>
<td>
<p>burn-in period in which the learning late is not decreased</p>
</td></tr>
<tr><td><code id="cpp.fit.random.block.sgd_+3A_rate0">rate0</code></td>
<td>
<p>initial learning rate</p>
</td></tr>
<tr><td><code id="cpp.fit.random.block.sgd_+3A_decay">decay</code></td>
<td>
<p>decay rate of the learning rate</p>
</td></tr>
<tr><td><code id="cpp.fit.random.block.sgd_+3A_damping">damping</code></td>
<td>
<p>diagonal dumping factor for the Hessian matrix</p>
</td></tr>
<tr><td><code id="cpp.fit.random.block.sgd_+3A_rate1">rate1</code></td>
<td>
<p>decay rate of the first moment estimate of the gradient</p>
</td></tr>
<tr><td><code id="cpp.fit.random.block.sgd_+3A_rate2">rate2</code></td>
<td>
<p>decay rate of the second moment estimate of the gradient</p>
</td></tr>
<tr><td><code id="cpp.fit.random.block.sgd_+3A_parallel">parallel</code></td>
<td>
<p>if <code>TRUE</code>, allows for parallel computing</p>
</td></tr>
<tr><td><code id="cpp.fit.random.block.sgd_+3A_nthreads">nthreads</code></td>
<td>
<p>number of cores to be used in parallel</p>
</td></tr>
<tr><td><code id="cpp.fit.random.block.sgd_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, print the optimization status</p>
</td></tr>
<tr><td><code id="cpp.fit.random.block.sgd_+3A_frequency">frequency</code></td>
<td>
<p>how often the optimization status is printed</p>
</td></tr>
<tr><td><code id="cpp.fit.random.block.sgd_+3A_progress">progress</code></td>
<td>
<p>if <code>TRUE</code>, print an progress bar</p>
</td></tr>
</table>

<hr>
<h2 id='deviance.initgmf'>Compute deviance, AIC and BIC of an initialized GMF model</h2><span id='topic+deviance.initgmf'></span><span id='topic+AIC.initgmf'></span><span id='topic+BIC.initgmf'></span>

<h3>Description</h3>

<p>Compute deviance, AIC and BIC of an initialized GMF object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'initgmf'
deviance(object, ..., normalize = FALSE)

## S3 method for class 'initgmf'
AIC(object, ..., k = 2)

## S3 method for class 'initgmf'
BIC(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deviance.initgmf_+3A_object">object</code></td>
<td>
<p>an object of class <code>initgmf</code></p>
</td></tr>
<tr><td><code id="deviance.initgmf_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="deviance.initgmf_+3A_normalize">normalize</code></td>
<td>
<p>if <code>TRUE</code>, normalize the result using the null-deviance</p>
</td></tr>
<tr><td><code id="deviance.initgmf_+3A_k">k</code></td>
<td>
<p>the penalty parameter to be used for AIC; the default is <code>k = 2</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the deviance extracted from a <code>initgmf</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+deviance.sgdgmf">deviance.sgdgmf</a></code>, <code><a href="#topic+AIC.sgdgmf">AIC.sgdgmf</a></code> and <code><a href="#topic+AIC.sgdgmf">AIC.sgdgmf</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the sgdGMF package
library(sgdGMF)

# Generate data from a Poisson model
data = sim.gmf.data(n = 100, m = 20, ncomp = 5, family = poisson())

# Fit a GMF model with 3 latent factors
init = sgdgmf.init(data$Y, ncomp = 3, family = poisson())

# Get the GMF deviance, AIC and BIC
deviance(init)
AIC(init)
BIC(init)

</code></pre>

<hr>
<h2 id='deviance.sgdgmf'>Compute deviance, AIC and BIC of a GMF model</h2><span id='topic+deviance.sgdgmf'></span><span id='topic+AIC.sgdgmf'></span><span id='topic+BIC.sgdgmf'></span>

<h3>Description</h3>

<p>Compute deviance, AIC and BIC of a GMF object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sgdgmf'
deviance(object, ..., normalize = FALSE)

## S3 method for class 'sgdgmf'
AIC(object, ..., k = 2)

## S3 method for class 'sgdgmf'
BIC(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deviance.sgdgmf_+3A_object">object</code></td>
<td>
<p>an object of class <code>sgdgmf</code></p>
</td></tr>
<tr><td><code id="deviance.sgdgmf_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="deviance.sgdgmf_+3A_normalize">normalize</code></td>
<td>
<p>if <code>TRUE</code>, normalize the result using the null-deviance</p>
</td></tr>
<tr><td><code id="deviance.sgdgmf_+3A_k">k</code></td>
<td>
<p>the penalty parameter to be used for AIC; the default is <code>k = 2</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the deviance extracted from a <code>sgdgmf</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the sgdGMF package
library(sgdGMF)

# Generate data from a Poisson model
data = sim.gmf.data(n = 100, m = 20, ncomp = 5, family = poisson())

# Fit a GMF model with 3 latent factors
gmf = sgdgmf.fit(data$Y, ncomp = 3, family = poisson())

# Get the GMF deviance, AIC and BIC
deviance(gmf)
AIC(gmf)
BIC(gmf)

</code></pre>

<hr>
<h2 id='eigengap.act'>Rank selection via adjust correlation thresholding</h2><span id='topic+eigengap.act'></span>

<h3>Description</h3>

<p>Select the number of significant principal components of a matrix via adjust
correlation threshold (ACT)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eigengap.act(covmat, nobs, maxcomp = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eigengap.act_+3A_covmat">covmat</code></td>
<td>
<p>matrix to be decomposed</p>
</td></tr>
<tr><td><code id="eigengap.act_+3A_nobs">nobs</code></td>
<td>
<p>number of observations used to compute the covariance matrix</p>
</td></tr>
<tr><td><code id="eigengap.act_+3A_maxcomp">maxcomp</code></td>
<td>
<p>maximum number of eigenvalues to compute</p>
</td></tr>
</table>


<h3>References</h3>

<p>Fan, J., Guo, j. and Zheng, S. (2020).
<em>Estimating number of factors by adjusted eigenvalues thresholding.</em>
Journal of the American Statistical Association, 117(538): 852&ndash;861
</p>

<hr>
<h2 id='eigengap.oht'>Rank selection via optimal hard thresholding</h2><span id='topic+eigengap.oht'></span>

<h3>Description</h3>

<p>Select the number of significant principal components of a matrix via optimal
hard thresholding (OHT)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eigengap.oht(covmat, nobs, maxcomp = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eigengap.oht_+3A_covmat">covmat</code></td>
<td>
<p>matrix to be decomposed</p>
</td></tr>
<tr><td><code id="eigengap.oht_+3A_nobs">nobs</code></td>
<td>
<p>number of observations used to compute the covariance matrix</p>
</td></tr>
<tr><td><code id="eigengap.oht_+3A_maxcomp">maxcomp</code></td>
<td>
<p>maximum number of eigenvalues to compute</p>
</td></tr>
</table>


<h3>References</h3>

<p>Gavish, M., Donoho, D.L. (2014)
<em>The optimal hard thresholding for singular values is 4/sqrt(3).</em>
IEEE Transactions on Information Theory, 60(8): 5040&ndash;5053
</p>

<hr>
<h2 id='eigengap.onatski'>Rank selection via the Onatski method</h2><span id='topic+eigengap.onatski'></span>

<h3>Description</h3>

<p>Select the number of significant principal components of a matrix via the
Onatski method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eigengap.onatski(covmat, maxcomp = 50, maxiter = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eigengap.onatski_+3A_covmat">covmat</code></td>
<td>
<p>matrix to be decomposed</p>
</td></tr>
<tr><td><code id="eigengap.onatski_+3A_maxcomp">maxcomp</code></td>
<td>
<p>maximum number of eigenvalues to compute</p>
</td></tr>
<tr><td><code id="eigengap.onatski_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
</table>


<h3>References</h3>

<p>Onatski, A. (2010).
<em>Determining the number of factors from empirical distribution of eigenvalues.</em>
Review of Economics and Statistics, 92(4): 1004-1016
</p>

<hr>
<h2 id='fitted.initgmf'>Extract the fitted values of an initialized GMF model</h2><span id='topic+fitted.initgmf'></span>

<h3>Description</h3>

<p>Computes the fitted values of an initialized GMF model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'initgmf'
fitted(object, ..., type = c("link", "response", "terms"), partial = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitted.initgmf_+3A_object">object</code></td>
<td>
<p>an object of class <code>initgmf</code></p>
</td></tr>
<tr><td><code id="fitted.initgmf_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="fitted.initgmf_+3A_type">type</code></td>
<td>
<p>the type of fitted values which should be returned</p>
</td></tr>
<tr><td><code id="fitted.initgmf_+3A_partial">partial</code></td>
<td>
<p>if <code>TRUE</code>, returns the partial fitted values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>type="terms"</code>, a list of fitted values containing the fields <code>XB</code>,
<code>AZ</code> and <code>UV</code>. Otherwise, a matrix of fitted values in the link or
response scale, depending on the selected <code>type</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitted.sgdgmf">fitted.sgdgmf</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the sgdGMF package
library(sgdGMF)

# Generate data from a Poisson model
data = sim.gmf.data(n = 100, m = 20, ncomp = 5, family = poisson())

# Fit a GMF model with 3 latent factors
init = sgdgmf.init(data$Y, ncomp = 3, family = poisson())

# Get the fitted values of a GMF model
str(fitted(init)) # returns the overall fitted values in link scale
str(fitted(init, type = "response")) # returns the overall fitted values in response scale
str(fitted(init, partial = TRUE)) # returns the partial fitted values in link scale

</code></pre>

<hr>
<h2 id='fitted.sgdgmf'>Extract the fitted values of a GMF models</h2><span id='topic+fitted.sgdgmf'></span>

<h3>Description</h3>

<p>Computes the fitted values of a GMF model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sgdgmf'
fitted(object, ..., type = c("link", "response", "terms"), partial = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitted.sgdgmf_+3A_object">object</code></td>
<td>
<p>an object of class <code>sgdgmf</code></p>
</td></tr>
<tr><td><code id="fitted.sgdgmf_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="fitted.sgdgmf_+3A_type">type</code></td>
<td>
<p>the type of fitted values which should be returned</p>
</td></tr>
<tr><td><code id="fitted.sgdgmf_+3A_partial">partial</code></td>
<td>
<p>if <code>TRUE</code>, returns the partial fitted values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>type="terms"</code>, a list of fitted values containing the fields <code>XB</code>,
<code>AZ</code> and <code>UV</code>. Otherwise, a matrix of fitted values in the link or
response scale, depending on the selected <code>type</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the sgdGMF package
library(sgdGMF)

# Generate data from a Poisson model
data = sim.gmf.data(n = 100, m = 20, ncomp = 5, family = poisson())

# Fit a GMF model with 3 latent factors
gmf = sgdgmf.fit(data$Y, ncomp = 3, family = poisson())

# Get the fitted values of a GMF model
str(fitted(gmf)) # returns the overall fitted values in link scale
str(fitted(gmf, type = "response")) # returns the overall fitted values in response scale

</code></pre>

<hr>
<h2 id='image.initgmf'>Heatmap of an initialized GMF model</h2><span id='topic+image.initgmf'></span>

<h3>Description</h3>

<p>Plots a heatmap of either the data, the fitted values, or the residual values
of a GMF model allowing for different types of transformations and normalizations.
Moreover, it also permits to plot the latent score and loading matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'initgmf'
image(
  x,
  ...,
  type = c("data", "response", "link", "scores", "loadings", "deviance", "pearson",
    "working"),
  resid = FALSE,
  symmetric = FALSE,
  transpose = FALSE,
  limits = NULL,
  palette = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="image.initgmf_+3A_x">x</code></td>
<td>
<p>an object of class <code>initgmf</code></p>
</td></tr>
<tr><td><code id="image.initgmf_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="image.initgmf_+3A_type">type</code></td>
<td>
<p>the type of data/predictions/residuals which should be returned</p>
</td></tr>
<tr><td><code id="image.initgmf_+3A_resid">resid</code></td>
<td>
<p>if <code>TRUE</code>, plots the residual values</p>
</td></tr>
<tr><td><code id="image.initgmf_+3A_symmetric">symmetric</code></td>
<td>
<p>if <code>TRUE</code>, symmetrizes the color limits</p>
</td></tr>
<tr><td><code id="image.initgmf_+3A_transpose">transpose</code></td>
<td>
<p>if <code>TRUE</code>, transposes the matrix before plotting it</p>
</td></tr>
<tr><td><code id="image.initgmf_+3A_limits">limits</code></td>
<td>
<p>the color limits which should be used</p>
</td></tr>
<tr><td><code id="image.initgmf_+3A_palette">palette</code></td>
<td>
<p>the color-palette which should be used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object showing the selected heatmap.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the sgdGMF package
library(sgdGMF)

# Generate data from a Poisson model
data = sim.gmf.data(n = 100, m = 20, ncomp = 5, family = poisson())

# Fit a GMF model
init = sgdgmf.init(data$Y, ncomp = 3, family = poisson())

# Get the heatmap of a GMF model
image(init, type = "data") # original data
image(init, type = "response") # fitted values in response scale
image(init, type = "scores") # estimated score matrix
image(init, type = "loadings") # estimated loading matrix
image(init, type = "deviance", resid = TRUE) # deviance residual matrix

</code></pre>

<hr>
<h2 id='image.sgdgmf'>Heatmap of a GMF model</h2><span id='topic+image.sgdgmf'></span>

<h3>Description</h3>

<p>Plots a heatmap of either the data, the fitted values, or the residual values
of a GMF model allowing for different types of transformations and normalizations.
Moreover, it also permits to plot the latent score and loading matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sgdgmf'
image(
  x,
  ...,
  type = c("data", "response", "link", "scores", "loadings", "deviance", "pearson",
    "working"),
  resid = FALSE,
  symmetric = FALSE,
  transpose = FALSE,
  limits = NULL,
  palette = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="image.sgdgmf_+3A_x">x</code></td>
<td>
<p>an object of class <code>sgdgmf</code></p>
</td></tr>
<tr><td><code id="image.sgdgmf_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="image.sgdgmf_+3A_type">type</code></td>
<td>
<p>the type of data/predictions/residuals which should be returned</p>
</td></tr>
<tr><td><code id="image.sgdgmf_+3A_resid">resid</code></td>
<td>
<p>if <code>TRUE</code>, plots the residual values</p>
</td></tr>
<tr><td><code id="image.sgdgmf_+3A_symmetric">symmetric</code></td>
<td>
<p>if <code>TRUE</code>, symmetrizes the color limits</p>
</td></tr>
<tr><td><code id="image.sgdgmf_+3A_transpose">transpose</code></td>
<td>
<p>if <code>TRUE</code>, transposes the matrix before plotting it</p>
</td></tr>
<tr><td><code id="image.sgdgmf_+3A_limits">limits</code></td>
<td>
<p>the color limits which should be used</p>
</td></tr>
<tr><td><code id="image.sgdgmf_+3A_palette">palette</code></td>
<td>
<p>the color-palette which should be used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object showing the selected heatmap.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the sgdGMF package
library(sgdGMF)

# Generate data from a Poisson model
data = sim.gmf.data(n = 100, m = 20, ncomp = 5, family = poisson())

 # Fit a GMF model
 gmf = sgdgmf.fit(data$Y, ncomp = 3, family = poisson())

# Get the heatmap of a GMF model
image(gmf, type = "data") # original data
image(gmf, type = "response") # fitted values in response scale
image(gmf, type = "scores") # estimated score matrix
image(gmf, type = "loadings") # estimated loading matrix
image(gmf, type = "deviance", resid = TRUE) # deviance residual matrix

</code></pre>

<hr>
<h2 id='make.pos.diag'>Fix sign ambiguity of eigen-vectors</h2><span id='topic+make.pos.diag'></span>

<h3>Description</h3>

<p>Fix sign ambiguity of eigen-vectors by making U positive diagonal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.pos.diag(U)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make.pos.diag_+3A_u">U</code></td>
<td>
<p>target matrix</p>
</td></tr>
</table>

<hr>
<h2 id='matrix.deviance'>Model deviance of a GMF model</h2><span id='topic+matrix.deviance'></span>

<h3>Description</h3>

<p>Compute the overall deviance averaging the contributions of all data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix.deviance(mu, y, family = gaussian())
</code></pre>

<hr>
<h2 id='matrix.penalty'>Frobenius penalty for the parameters of a GMF model</h2><span id='topic+matrix.penalty'></span>

<h3>Description</h3>

<p>Compute the Frobenius penalty for all the parameters in the model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix.penalty(U, penalty)
</code></pre>

<hr>
<h2 id='norm.procrustes'>Procrustes distance</h2><span id='topic+norm.procrustes'></span>

<h3>Description</h3>

<p>Compute the Procrustes distance between two matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm.procrustes(A, B)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="norm.procrustes_+3A_a">A</code></td>
<td>
<p>target matrix</p>
</td></tr>
<tr><td><code id="norm.procrustes_+3A_b">B</code></td>
<td>
<p>matrix to be rotated</p>
</td></tr>
</table>

<hr>
<h2 id='normalize.uv'>Normalize the matrices U and V</h2><span id='topic+normalize.uv'></span>

<h3>Description</h3>

<p>Rotate U and V using either QR or SVD decompositions.
The QR methods rotate U and V in such a way to obtain an orthogonal U
and a lower triangular V.  The SVD method rotate U and V in such a way
to obtain an orthogonal U and a scaled orthogonal V.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize.uv(U, V, method = c("qr", "svd"))
</code></pre>

<hr>
<h2 id='ols.fit.coef'>Estimate the coefficients of a multivariate linear model</h2><span id='topic+ols.fit.coef'></span>

<h3>Description</h3>

<p>Estimate the coefficients of a multivariate linear model via ordinary least squares.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ols.fit.coef(Y, X, offset = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ols.fit.coef_+3A_y">Y</code></td>
<td>
<p><code class="reqn">n \times m</code> matrix of response variables</p>
</td></tr>
<tr><td><code id="ols.fit.coef_+3A_x">X</code></td>
<td>
<p><code class="reqn">n \times p</code> matrix of covariates</p>
</td></tr>
<tr><td><code id="ols.fit.coef_+3A_offset">offset</code></td>
<td>
<p><code class="reqn">n \times m</code> matrix of offset values</p>
</td></tr>
</table>

<hr>
<h2 id='omp.check'>Check if OpenMP is enabled</h2><span id='topic+omp.check'></span>

<h3>Description</h3>

<p>Internal function to check if OpenMP is enabled
</p>


<h3>Usage</h3>

<pre><code class='language-R'>omp.check()
</code></pre>

<hr>
<h2 id='partition'>Split the data matrix in train and test sets</h2><span id='topic+partition'></span>

<h3>Description</h3>

<p>Returns a list of two matrices <code>train</code> and <code>test</code>.
<code>train</code> corresponds to the input matrix with a fixed persentage of
entries masked by NA values. <code>test</code> is the complement of <code>train</code>
and contains the values of the input matrix in the cells where <code>train</code>
is NA, while all the other entries are filled by NA values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partition(y, p = 0.3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="partition_+3A_y">y</code></td>
<td>
<p>input matrix to be split into train and test sets</p>
</td></tr>
<tr><td><code id="partition_+3A_p">p</code></td>
<td>
<p>fraction of observations to be used for the test set</p>
</td></tr>
</table>

<hr>
<h2 id='plot.initgmf'>Plot diagnostics for an initialized GMF model</h2><span id='topic+plot.initgmf'></span>

<h3>Description</h3>

<p>Plots (one of) six diagnostics to graphically analyze the marginal and conditional
distribution of the residuals of a GMF model. Currently, the following plots are
available: residuals against observation indices, residuals agains fitted values,
absolute square-root residuals against fitted values, histogram of the residuals,
residual QQ-plot, residual ECDF-plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'initgmf'
plot(
  x,
  ...,
  type = c("res-idx", "res-fit", "std-fit", "hist", "qq", "ecdf"),
  resid = c("deviance", "pearson", "working", "response", "link"),
  subsample = FALSE,
  sample.size = 500,
  partial = FALSE,
  normalize = FALSE,
  fillna = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.initgmf_+3A_x">x</code></td>
<td>
<p>an object of class <code>initgmf</code></p>
</td></tr>
<tr><td><code id="plot.initgmf_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="plot.initgmf_+3A_type">type</code></td>
<td>
<p>the type of plot which should be returned</p>
</td></tr>
<tr><td><code id="plot.initgmf_+3A_resid">resid</code></td>
<td>
<p>the type of residuals which should be used</p>
</td></tr>
<tr><td><code id="plot.initgmf_+3A_subsample">subsample</code></td>
<td>
<p>if <code>TRUE</code>, computes the residuals over o small fraction of the data</p>
</td></tr>
<tr><td><code id="plot.initgmf_+3A_sample.size">sample.size</code></td>
<td>
<p>the dimension of the sub-sample which should be used</p>
</td></tr>
<tr><td><code id="plot.initgmf_+3A_partial">partial</code></td>
<td>
<p>if <code>TRUE</code>, computes the partial residuals</p>
</td></tr>
<tr><td><code id="plot.initgmf_+3A_normalize">normalize</code></td>
<td>
<p>if <code>TRUE</code>, standardizes the residuals column-by-column</p>
</td></tr>
<tr><td><code id="plot.initgmf_+3A_fillna">fillna</code></td>
<td>
<p>if <code>TRUE</code>, fills the <code>NA</code> values with <code>0</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object showing the selected diagnostic plot.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.sgdgmf">plot.sgdgmf</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the sgdGMF package
library(sgdGMF)

# Generate data from a Poisson model
data = sim.gmf.data(n = 100, m = 20, ncomp = 5, family = poisson())

# Fit a GMF model
init = sgdgmf.init(data$Y, ncomp = 3, family = poisson())

# Plot the residual-based GMF diagnostics
plot(init, type = "res-fit") # Residuals vs fitted values
plot(init, type = "std-fit") # Abs-sqrt-transformed residuals vs fitted values
plot(init, type = "qq") # Residual QQ-plot
plot(init, type = "hist") # Residual histogram

</code></pre>

<hr>
<h2 id='plot.sgdgmf'>Plot diagnostics for a GMF model</h2><span id='topic+plot.sgdgmf'></span>

<h3>Description</h3>

<p>Plots (one of) six diagnostics to graphically analyze the marginal and conditional
distribution of the residuals of a GMF model. Currently, the following plots are
available: residuals against observation indices, residuals agains fitted values,
absolute square-root residuals against fitted values, histogram of the residuals,
residual QQ-plot, residual ECDF-plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sgdgmf'
plot(
  x,
  ...,
  type = c("res-idx", "res-fit", "std-fit", "hist", "qq", "ecdf"),
  resid = c("deviance", "pearson", "working", "response", "link"),
  subsample = FALSE,
  sample.size = 500,
  partial = FALSE,
  normalize = FALSE,
  fillna = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.sgdgmf_+3A_x">x</code></td>
<td>
<p>an object of class <code>sgdgmf</code></p>
</td></tr>
<tr><td><code id="plot.sgdgmf_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="plot.sgdgmf_+3A_type">type</code></td>
<td>
<p>the type of plot which should be returned</p>
</td></tr>
<tr><td><code id="plot.sgdgmf_+3A_resid">resid</code></td>
<td>
<p>the type of residuals which should be used</p>
</td></tr>
<tr><td><code id="plot.sgdgmf_+3A_subsample">subsample</code></td>
<td>
<p>if <code>TRUE</code>, computes the residuals over o small fraction of the data</p>
</td></tr>
<tr><td><code id="plot.sgdgmf_+3A_sample.size">sample.size</code></td>
<td>
<p>the dimension of the sub-sample which should be used</p>
</td></tr>
<tr><td><code id="plot.sgdgmf_+3A_partial">partial</code></td>
<td>
<p>if <code>TRUE</code>, computes the partial residuals</p>
</td></tr>
<tr><td><code id="plot.sgdgmf_+3A_normalize">normalize</code></td>
<td>
<p>if <code>TRUE</code>, standardizes the residuals column-by-column</p>
</td></tr>
<tr><td><code id="plot.sgdgmf_+3A_fillna">fillna</code></td>
<td>
<p>if <code>TRUE</code>, fills the <code>NA</code> values with <code>0</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object showing the selected diagnostic plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the sgdGMF package
library(sgdGMF)

# Generate data from a Poisson model
data = sim.gmf.data(n = 100, m = 20, ncomp = 5, family = poisson())

# Fit a GMF model
gmf = sgdgmf.fit(data$Y, ncomp = 3, family = poisson())

# Plot the residual-based GMF diagnostics
plot(gmf, type = "res-fit") # Residuals vs fitted values
plot(gmf, type = "std-fit") # Abs-sqrt-transformed residuals vs fitted values
plot(gmf, type = "qq") # Residual QQ-plot
plot(gmf, type = "hist") # Residual histogram

</code></pre>

<hr>
<h2 id='pointwise.deviance'>Pointwise deviance of a GMF model</h2><span id='topic+pointwise.deviance'></span>

<h3>Description</h3>

<p>Compute the pointwise deviance for all the observations in the sample
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pointwise.deviance(mu, y, family = gaussian())
</code></pre>

<hr>
<h2 id='predict.sgdgmf'>Predict method for GMF models</h2><span id='topic+predict.sgdgmf'></span>

<h3>Description</h3>

<p>Computes the predictions of a GMF model. Out-of-sample predictions for a new
set of responses and covariates are computed via MLE, by keeping fixed the values
of the estimated <code>B</code> and <code>V</code> and maximizing the likelihood with respect
to <code>A</code> and <code>U</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sgdgmf'
predict(
  object,
  ...,
  newY = NULL,
  newX = NULL,
  type = c("link", "response", "terms", "coef"),
  parallel = FALSE,
  nthreads = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.sgdgmf_+3A_object">object</code></td>
<td>
<p>an object of class <code>sgdgmf</code></p>
</td></tr>
<tr><td><code id="predict.sgdgmf_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="predict.sgdgmf_+3A_newy">newY</code></td>
<td>
<p>optionally, a matrix of new response variable</p>
</td></tr>
<tr><td><code id="predict.sgdgmf_+3A_newx">newX</code></td>
<td>
<p>optionally, a matrix of new covariate values</p>
</td></tr>
<tr><td><code id="predict.sgdgmf_+3A_type">type</code></td>
<td>
<p>the type of prediction which should be returned</p>
</td></tr>
<tr><td><code id="predict.sgdgmf_+3A_parallel">parallel</code></td>
<td>
<p>if <code>TRUE</code>, allows for parallel computing using the package <code>foreach</code></p>
</td></tr>
<tr><td><code id="predict.sgdgmf_+3A_nthreads">nthreads</code></td>
<td>
<p>number of cores to be used in parallel (only if <code>parallel=TRUE</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>newY</code> and <code>newX</code> are omitted, the predictions are based on the data
used for the fit. In that case, the predictions corresponds to the fitted values.
If <code>newY</code> and <code>newX</code> are provided, a corresponding set of <code>A</code> and
<code>U</code> are estimated via maximum likelihood using the <code>glm.fit</code> function.
By doing so, <code>B</code> and <code>V</code> are kept fixed.
</p>


<h3>Value</h3>

<p>If <code>type="link"</code> or <code>typr="response"</code>, a matrix of predictions.
If <code>type="terms"</code>, a list of matrices containing the fields <code>XB</code>, <code>AZ</code> and <code>UV</code>.
If <code>type="coef"</code>, a list of matrices containing the field <code>B</code>, <code>A</code>, <code>U</code> and <code>V</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the sgdGMF package
library(sgdGMF)

# Generate data from a Poisson model
data = sim.gmf.data(n = 120, m = 20, ncomp = 5, family = poisson())
train = sample(1:120, size = 100)
test = setdiff(1:120, train)

Y = data$Y[train, ]
newY = data$Y[test, ]

# Fit a GMF model with 3 latent factors
gmf = sgdgmf.fit(Y, ncomp = 3, family = poisson())

# Get the fitted values of a GMF model
str(predict(gmf)) # returns the overall fitted values in link scale
str(predict(gmf, type = "response")) # returns the overall fitted values in response scale
str(predict(gmf, type = "terms")) # returns the partial fitted values in link scale
str(predict(gmf, newY = newY)) # returns the predictions for the new set of responses

</code></pre>

<hr>
<h2 id='print.initgmf'>Print the fundamental characteristics of an initialized GMF</h2><span id='topic+print.initgmf'></span>

<h3>Description</h3>

<p>Print some summary information of an initialized GMF model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'initgmf'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.initgmf_+3A_x">x</code></td>
<td>
<p>an object of class <code>initgmf</code></p>
</td></tr>
<tr><td><code id="print.initgmf_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called only for printing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the sgdGMF package
library(sgdGMF)

# Generate data from a Poisson model
data = sim.gmf.data(n = 100, m = 20, ncomp = 5, family = poisson())

# Fit a GMF model with 3 latent factors
init = sgdgmf.init(data$Y, ncomp = 3, family = poisson())

# Print the GMF object
print(init)

</code></pre>

<hr>
<h2 id='print.sgdgmf'>Print the fundamental characteristics of a GMF</h2><span id='topic+print.sgdgmf'></span>

<h3>Description</h3>

<p>Print some summary information of a GMF model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sgdgmf'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.sgdgmf_+3A_x">x</code></td>
<td>
<p>an object of class <code>sgdgmf</code></p>
</td></tr>
<tr><td><code id="print.sgdgmf_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called only for printing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the sgdGMF package
library(sgdGMF)

# Generate data from a Poisson model
data = sim.gmf.data(n = 100, m = 20, ncomp = 5, family = poisson())

# Fit a GMF model with 3 latent factors
gmf = sgdgmf.fit(data$Y, ncomp = 3, family = poisson())

# Print the GMF object
print(gmf)

</code></pre>

<hr>
<h2 id='procrustes'>Procrustes rotation of two configurations</h2><span id='topic+procrustes'></span>

<h3>Description</h3>

<p>Rotates a configuration to maximum similarity with another configuration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>procrustes(X, Y, scale = TRUE, symmetric = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="procrustes_+3A_x">X</code></td>
<td>
<p>target matrix</p>
</td></tr>
<tr><td><code id="procrustes_+3A_y">Y</code></td>
<td>
<p>matrix to be rotated</p>
</td></tr>
<tr><td><code id="procrustes_+3A_scale">scale</code></td>
<td>
<p>allow scaling of axes of Y</p>
</td></tr>
<tr><td><code id="procrustes_+3A_symmetric">symmetric</code></td>
<td>
<p>if <code>TRUE</code>, use symmetric Procrustes statistic</p>
</td></tr>
</table>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+refit'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>generics</dt><dd><p><code><a href="generics.html#topic+refit">refit</a></code></p>
</dd>
</dl>

<hr>
<h2 id='refit.sgdgmf'>Refine the final estimate of a GMF model</h2><span id='topic+refit.sgdgmf'></span>

<h3>Description</h3>

<p>Refine the estimated latent scores of a GMF model via IRWLS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sgdgmf'
refit(
  object,
  ...,
  normalize = TRUE,
  verbose = FALSE,
  parallel = FALSE,
  nthreads = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="refit.sgdgmf_+3A_object">object</code></td>
<td>
<p>an object of class <code>sgdgmf</code></p>
</td></tr>
<tr><td><code id="refit.sgdgmf_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="refit.sgdgmf_+3A_normalize">normalize</code></td>
<td>
<p>if <code>TRUE</code>, normalize <code>U</code> and <code>V</code> to uncorrelated Gaussian <code>U</code> and upper triangular <code>V</code> with positive diagonal</p>
</td></tr>
<tr><td><code id="refit.sgdgmf_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, print the optimization status</p>
</td></tr>
<tr><td><code id="refit.sgdgmf_+3A_parallel">parallel</code></td>
<td>
<p>if <code>TRUE</code>, use parallel computing using the <code>foreach</code> package</p>
</td></tr>
<tr><td><code id="refit.sgdgmf_+3A_nthreads">nthreads</code></td>
<td>
<p>number of cores to be used in the <code>"glm"</code> method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>sgdgmf</code> object containing the re-fitted model.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sgdgmf.fit">sgdgmf.fit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the sgdGMF package
library(sgdGMF)

# Generate data from a Poisson model
data = sim.gmf.data(n = 100, m = 20, ncomp = 5, family = poisson())

# Fit a GMF model using SGD
gmf_old = sgdgmf.fit(data$Y, ncomp = 3, family = poisson(), method = "sgd")

# Refine the score matrix estimate
gmf_new = refit(gmf_old)

# Get the fitted values in the link and response scales
mu_hat_old = fitted(gmf_old, type = "response")
mu_hat_new = fitted(gmf_new, type = "response")

# Compare the results
oldpar = par(no.readonly = TRUE)
par(mfrow = c(2,2), mar = c(1,1,3,1))
image(data$Y, axes = FALSE, main = expression(Y))
image(data$mu, axes = FALSE, main = expression(mu))
image(mu_hat_old, axes = FALSE, main = expression(hat(mu)[old]))
image(mu_hat_new, axes = FALSE, main = expression(hat(mu)[new]))
par(oldpar)

</code></pre>

<hr>
<h2 id='residuals.initgmf'>Extract the residuals of an initialized GMF model</h2><span id='topic+residuals.initgmf'></span><span id='topic+resid.initgmf'></span>

<h3>Description</h3>

<p>Extract the residuals of an initialized GMF model and, if required, compute
the eigenvalues of the residuals covariance/correlation matrix.
Moreover, if required, return the partial residual of the model obtained by
excluding the matrix decomposition from the linear predictor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'initgmf'
residuals(
  object,
  ...,
  type = c("deviance", "pearson", "working", "response", "link"),
  partial = FALSE,
  normalize = FALSE,
  fillna = FALSE,
  spectrum = FALSE,
  ncomp = 50
)

## S3 method for class 'initgmf'
resid(
  object,
  ...,
  type = c("deviance", "pearson", "working", "response", "link"),
  partial = FALSE,
  normalize = FALSE,
  fillna = FALSE,
  spectrum = FALSE,
  ncomp = 50
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuals.initgmf_+3A_object">object</code></td>
<td>
<p>an object of class <code>initgmf</code></p>
</td></tr>
<tr><td><code id="residuals.initgmf_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="residuals.initgmf_+3A_type">type</code></td>
<td>
<p>the type of residuals which should be returned</p>
</td></tr>
<tr><td><code id="residuals.initgmf_+3A_partial">partial</code></td>
<td>
<p>if <code>TRUE</code>, computes the residuals excluding the matrix factorization from the linear predictor</p>
</td></tr>
<tr><td><code id="residuals.initgmf_+3A_normalize">normalize</code></td>
<td>
<p>if <code>TRUE</code>, standardize the residuals column-by-column</p>
</td></tr>
<tr><td><code id="residuals.initgmf_+3A_fillna">fillna</code></td>
<td>
<p>if <code>TRUE</code>, fills <code>NA</code> values column-by-column</p>
</td></tr>
<tr><td><code id="residuals.initgmf_+3A_spectrum">spectrum</code></td>
<td>
<p>if <code>TRUE</code>, returns the eigenvalues of the residual covariance matrix</p>
</td></tr>
<tr><td><code id="residuals.initgmf_+3A_ncomp">ncomp</code></td>
<td>
<p>number of eigenvalues to be calculated (only if <code>spectrum=TRUE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>spectrum=FALSE</code>, a matrix containing the selected residuals.
If <code>spectrum=TRUE</code>, a list containing the residuals (<code>res</code>), the first <code>ncomp</code>
eigenvalues of the residual covariance matrix, say (<code>lambdas</code>), the variance explained by the first
<code>ncomp</code> principal component of the residuals (<code>explained.var</code>), the variance not
explained by the first <code>ncomp</code> principal component of the residuals (<code>residual.var</code>),
the total variance of the residuals (<code>total.var</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+residuals.sgdgmf">residuals.sgdgmf</a></code> and <code><a href="#topic+resid.sgdgmf">resid.sgdgmf</a></code> for more details on the residual computation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the sgdGMF package
library(sgdGMF)

# Generate data from a Poisson model
data = sim.gmf.data(n = 100, m = 20, ncomp = 5, family = poisson())

# Fit a GMF model with 3 latent factors
init = sgdgmf.init(data$Y, ncomp = 3, family = poisson())

# Get the deviance residuals of a GMF model
str(residuals(init)) # returns the overall deviance residuals
str(residuals(init, partial = TRUE)) # returns the partial residuals
str(residuals(init, spectrum = TRUE)) # returns the eigenvalues of the residual var-cov matrix

</code></pre>

<hr>
<h2 id='residuals.sgdgmf'>Extract the residuals of a GMF model</h2><span id='topic+residuals.sgdgmf'></span><span id='topic+resid.sgdgmf'></span>

<h3>Description</h3>

<p>Extract the residuals of a GMF model and, if required, compute the eigenvalues
of the residuals covariance/correlation matrix.
Moreover, if required, return the partial residual of the model obtained by
excluding the matrix decomposition from the linear predictor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sgdgmf'
residuals(
  object,
  ...,
  type = c("deviance", "pearson", "working", "response", "link"),
  partial = FALSE,
  normalize = FALSE,
  fillna = FALSE,
  spectrum = FALSE,
  ncomp = 50
)

## S3 method for class 'sgdgmf'
resid(
  object,
  ...,
  type = c("deviance", "pearson", "working", "response", "link"),
  partial = FALSE,
  normalize = FALSE,
  fillna = FALSE,
  spectrum = FALSE,
  ncomp = 50
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuals.sgdgmf_+3A_object">object</code></td>
<td>
<p>an object of class <code>sgdgmf</code></p>
</td></tr>
<tr><td><code id="residuals.sgdgmf_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="residuals.sgdgmf_+3A_type">type</code></td>
<td>
<p>the type of residuals which should be returned</p>
</td></tr>
<tr><td><code id="residuals.sgdgmf_+3A_partial">partial</code></td>
<td>
<p>if <code>TRUE</code>, computes the residuals excluding the matrix factorization from the linear predictor</p>
</td></tr>
<tr><td><code id="residuals.sgdgmf_+3A_normalize">normalize</code></td>
<td>
<p>if <code>TRUE</code>, standardize the residuals column-by-column</p>
</td></tr>
<tr><td><code id="residuals.sgdgmf_+3A_fillna">fillna</code></td>
<td>
<p>if <code>TRUE</code>, fills <code>NA</code> values column-by-column</p>
</td></tr>
<tr><td><code id="residuals.sgdgmf_+3A_spectrum">spectrum</code></td>
<td>
<p>if <code>TRUE</code>, returns the eigenvalues of the residual covariance matrix</p>
</td></tr>
<tr><td><code id="residuals.sgdgmf_+3A_ncomp">ncomp</code></td>
<td>
<p>number of eigenvalues to be calculated (only if <code>spectrum=TRUE</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">g(\mu) = \eta = X B^\top + \Gamma Z^\top + U V^\top</code> be the linear predictor of a
GMF model. Let <code class="reqn">R = (r_{ij})</code> be the correspondent residual matrix.
The following residuals can be considered:
</p>

<ul>
<li><p> deviance: <code class="reqn">r_{ij}^{_D} = \textrm{sign}(y_{ij} - \mu_{ij}) \sqrt{D(y_{ij}, \mu_{ij})}</code>;
</p>
</li>
<li><p> Pearson: <code class="reqn">r_{ij}^{_P} = (y_{ij} - \mu_{ij}) / \sqrt{\nu(\mu_{ij})}</code>;
</p>
</li>
<li><p> working: <code class="reqn">r_{ij}^{_W} = (y_{ij} - \mu_{ij}) / \{g'(\mu_{ij}) \,\nu(\mu_{ij})\}</code>;
</p>
</li>
<li><p> response: <code class="reqn">r_{ij}^{_R} = y_{ij} - \mu_{ij}</code>;
</p>
</li>
<li><p> link: <code class="reqn">r_{ij}^{_G} = g(y_{ij}) - \eta_{ij}</code>.
</p>
</li></ul>

<p>If <code>partial=TRUE</code>, <code class="reqn">mu</code> is computed excluding the latent matrix decomposition
from the linear predictor, so as to obtain the partial residuals.
</p>
<p>Let <code class="reqn">\Sigma</code> be the empirical variance-covariance matrix of <code class="reqn">R</code>, being
<code class="reqn">\sigma_{ij} = \textrm{Cov}(r_{:i}, r_{:j})</code>. Then, the latent spectrum of
the model is the collection of eigenvalues of <code class="reqn">\Sigma</code>.
</p>
<p>Notice that, in case of Gaussian data, the latent spectrum corresponds to the principal
component analysis on the regression residuals, whose eigenvalues can be used to
infer the amount of variance explained by each principal component. Similarly,
we can use the (partial) latent spectrum in non-Gaussian data settings to infer
the correct number of principal components to include into the GMF model or to
detect some residual dependence structures not already explained by the model.
</p>


<h3>Value</h3>

<p>If <code>spectrum=FALSE</code>, a matrix containing the selected residuals.
If <code>spectrum=TRUE</code>, a list containing the residuals (<code>res</code>), the first <code>ncomp</code>
eigenvalues of the residual covariance matrix, say (<code>lambdas</code>), the variance explained by the first
<code>ncomp</code> principal component of the residuals (<code>explained.var</code>), the variance not
explained by the first <code>ncomp</code> principal component of the residuals (<code>residual.var</code>),
the total variance of the residuals (<code>total.var</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the sgdGMF package
library(sgdGMF)

# Generate data from a Poisson model
data = sim.gmf.data(n = 100, m = 20, ncomp = 5, family = poisson())

# Fit a GMF model with 3 latent factors
gmf = sgdgmf.fit(data$Y, ncomp = 3, family = poisson())

# Get the deviance residuals of a GMF model
str(residuals(gmf)) # returns the overall deviance residuals
str(residuals(gmf, partial = TRUE)) # returns the partial residuals
str(residuals(gmf, spectrum = TRUE)) # returns the eigenvalues of the residual var-cov matrix

</code></pre>

<hr>
<h2 id='screeplot.initgmf'>Screeplot for the residuals of an initialized GMF model</h2><span id='topic+screeplot.initgmf'></span>

<h3>Description</h3>

<p>Plots the variances of the principal components of the residuals against the
number of principal component.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'initgmf'
screeplot(
  x,
  ...,
  ncomp = 20,
  type = c("deviance", "pearson", "working", "response", "link"),
  partial = FALSE,
  normalize = FALSE,
  cumulative = FALSE,
  proportion = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="screeplot.initgmf_+3A_x">x</code></td>
<td>
<p>an object of class <code>sgdgmf</code></p>
</td></tr>
<tr><td><code id="screeplot.initgmf_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="screeplot.initgmf_+3A_ncomp">ncomp</code></td>
<td>
<p>number of components to be plotted</p>
</td></tr>
<tr><td><code id="screeplot.initgmf_+3A_type">type</code></td>
<td>
<p>the type of residuals which should be used</p>
</td></tr>
<tr><td><code id="screeplot.initgmf_+3A_partial">partial</code></td>
<td>
<p>if <code>TRUE</code>, plots the eigenvalues of the partial residuals</p>
</td></tr>
<tr><td><code id="screeplot.initgmf_+3A_normalize">normalize</code></td>
<td>
<p>if <code>TRUE</code>, plots the eigenvalues of the standardized residuals</p>
</td></tr>
<tr><td><code id="screeplot.initgmf_+3A_cumulative">cumulative</code></td>
<td>
<p>if <code>TRUE</code>, plots the cumulative sum of the eigenvalues</p>
</td></tr>
<tr><td><code id="screeplot.initgmf_+3A_proportion">proportion</code></td>
<td>
<p>if <code>TRUE</code>, plots the fractions of explained variance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object showing the residual screeplot of the model.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+screeplot.sgdgmf">screeplot.sgdgmf</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the sgdGMF package
library(sgdGMF)

# Generate data from a Poisson model
data = sim.gmf.data(n = 100, m = 20, ncomp = 5, family = poisson())

# Fit a GMF model
init = sgdgmf.init(data$Y, ncomp = 3, family = poisson())

# Get the partial residual spectrum of a GMF model
screeplot(init) # screeplot of the var-cov matrix of the deviance residuals
screeplot(init, partial = TRUE) # screeplot of the partial residuals
screeplot(init, cumulative = TRUE) # cumulative screeplot
screeplot(init, proportion = TRUE) # proportion of explained residual variance

</code></pre>

<hr>
<h2 id='screeplot.sgdgmf'>Screeplot for the residuals of a GMF model</h2><span id='topic+screeplot.sgdgmf'></span>

<h3>Description</h3>

<p>Plots the variances of the principal components of the residuals against the
number of principal component.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sgdgmf'
screeplot(
  x,
  ...,
  ncomp = 20,
  type = c("deviance", "pearson", "working", "response", "link"),
  partial = FALSE,
  normalize = FALSE,
  cumulative = FALSE,
  proportion = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="screeplot.sgdgmf_+3A_x">x</code></td>
<td>
<p>an object of class <code>sgdgmf</code></p>
</td></tr>
<tr><td><code id="screeplot.sgdgmf_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="screeplot.sgdgmf_+3A_ncomp">ncomp</code></td>
<td>
<p>number of components to be plotted</p>
</td></tr>
<tr><td><code id="screeplot.sgdgmf_+3A_type">type</code></td>
<td>
<p>the type of residuals which should be used</p>
</td></tr>
<tr><td><code id="screeplot.sgdgmf_+3A_partial">partial</code></td>
<td>
<p>if <code>TRUE</code>, plots the eigenvalues of the partial residuals</p>
</td></tr>
<tr><td><code id="screeplot.sgdgmf_+3A_normalize">normalize</code></td>
<td>
<p>if <code>TRUE</code>, plots the eigenvalues of the standardized residuals</p>
</td></tr>
<tr><td><code id="screeplot.sgdgmf_+3A_cumulative">cumulative</code></td>
<td>
<p>if <code>TRUE</code>, plots the cumulative sum of the eigenvalues</p>
</td></tr>
<tr><td><code id="screeplot.sgdgmf_+3A_proportion">proportion</code></td>
<td>
<p>if <code>TRUE</code>, plots the fractions of explained variance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object showing the residual screeplot of the model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the sgdGMF package
library(sgdGMF)

# Generate data from a Poisson model
data = sim.gmf.data(n = 100, m = 20, ncomp = 5, family = poisson())

# Fit a GMF model
gmf = sgdgmf.fit(data$Y, ncomp = 3, family = poisson())

# Get the partial residual spectrum of a GMF model
screeplot(gmf) # screeplot of the var-cov matrix of the deviance residuals
screeplot(gmf, partial = TRUE) # screeplot of the partial residuals
screeplot(gmf, cumulative = TRUE) # cumulative screeplot
screeplot(gmf, proportion = TRUE) # proportion of explained residual variance

</code></pre>

<hr>
<h2 id='set.control.airwls'>Check and set the control parameters for the AIRWLS algorithm</h2><span id='topic+set.control.airwls'></span>

<h3>Description</h3>

<p>Check if the input control parameters of the AIRWLS algorithm are allowed
and set them to default values if they are not. Returns a list of
well-defined control parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.control.airwls(
  normalize = TRUE,
  maxiter = 100,
  nstep = 1,
  stepsize = 0.1,
  eps = 1e-08,
  nafill = 1,
  tol = 1e-05,
  damping = 0.001,
  verbose = FALSE,
  frequency = 10,
  parallel = FALSE,
  nthreads = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set.control.airwls_+3A_normalize">normalize</code></td>
<td>
<p>if <code>TRUE</code>, normalize <code>U</code> and <code>V</code> to uncorrelated Gaussian <code>U</code> and upper triangular <code>V</code> with positive diagonal</p>
</td></tr>
<tr><td><code id="set.control.airwls_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
<tr><td><code id="set.control.airwls_+3A_nstep">nstep</code></td>
<td>
<p>number of IRWLS steps in each inner loop of AIRWLS</p>
</td></tr>
<tr><td><code id="set.control.airwls_+3A_stepsize">stepsize</code></td>
<td>
<p>step-size parameter scaling each IRWLS step</p>
</td></tr>
<tr><td><code id="set.control.airwls_+3A_eps">eps</code></td>
<td>
<p>how much shrinkage has to be introduced on extreme predictions lying outside of the data range</p>
</td></tr>
<tr><td><code id="set.control.airwls_+3A_nafill">nafill</code></td>
<td>
<p>how frequently the <code>NA</code> values are filled, by default <code>NA</code> values are filled at each iteration of the algorithm</p>
</td></tr>
<tr><td><code id="set.control.airwls_+3A_tol">tol</code></td>
<td>
<p>tolerance threshold for the stopping criterion</p>
</td></tr>
<tr><td><code id="set.control.airwls_+3A_damping">damping</code></td>
<td>
<p>regularization parameter which is added to the diagonal of the Hessian to ensure numerical stability</p>
</td></tr>
<tr><td><code id="set.control.airwls_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, print the optimization status (default <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="set.control.airwls_+3A_frequency">frequency</code></td>
<td>
<p>how often the optimization status is printed (only if <code>verbose=TRUE</code>)</p>
</td></tr>
<tr><td><code id="set.control.airwls_+3A_parallel">parallel</code></td>
<td>
<p>if <code>TRUE</code>, allows for parallel computing using the <code>C++</code> library <code>OpenMP</code></p>
</td></tr>
<tr><td><code id="set.control.airwls_+3A_nthreads">nthreads</code></td>
<td>
<p>number of cores to be used in parallel (only if <code>parallel=TRUE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> of control parameters for the AIRWLS algorithm
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sgdGMF)

# Empty call
set.control.airwls()

# Parametrized call
set.control.airwls(maxiter = 100, nstep = 5, stepsize = 0.3)


</code></pre>

<hr>
<h2 id='set.control.alg'>Check and set the control parameters for the select optimization algorithm</h2><span id='topic+set.control.alg'></span>

<h3>Description</h3>

<p>Check if the input control parameters are allowed and set them to default
values if they are not. Returns a list of well-defined control parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.control.alg(
  method = c("airwls", "newton", "sgd"),
  sampling = c("block", "coord", "rnd-block"),
  control = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set.control.alg_+3A_method">method</code></td>
<td>
<p>optimization method to use</p>
</td></tr>
<tr><td><code id="set.control.alg_+3A_sampling">sampling</code></td>
<td>
<p>sub-sampling method to use</p>
</td></tr>
<tr><td><code id="set.control.alg_+3A_control">control</code></td>
<td>
<p>list of algorithm-specific control parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is not necessary to provide a complete list of control parameters, one can
just specify a list containing the parameters he/she needs to change from the
default values. Wrongly specified parameters are ignored or set to default values.
For a detailed description of all the algorithm-specific control parameters,
please refer to
<code><a href="#topic+set.control.airwls">set.control.airwls</a></code> (<code>method="airwls"</code>),
<code><a href="#topic+set.control.newton">set.control.newton</a></code> (<code>method="newton"</code>),
<code><a href="#topic+set.control.block.sgd">set.control.block.sgd</a></code> (<code>method="sgd"</code>, <code>sampling="block"</code>).
<code><a href="#topic+set.control.coord.sgd">set.control.coord.sgd</a></code> (<code>method="sgd"</code>, <code>sampling="coord"</code>),
</p>


<h3>Value</h3>

<p>A <code>list</code> of control parameters for the selected estimation algorithm
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set.control.init">set.control.init</a></code>, <code><a href="#topic+set.control.cv">set.control.cv</a></code>, <code><a href="#topic+sgdgmf.fit">sgdgmf.fit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sgdGMF)

# Empty call
set.control.alg()

# Parametrized call
set.control.alg(method = "airwls", control = list(maxiter = 200, stepsize = 0.3))


</code></pre>

<hr>
<h2 id='set.control.block.sgd'>Check and set the control parameters for the blockwise-SGD algorithm</h2><span id='topic+set.control.block.sgd'></span>

<h3>Description</h3>

<p>Check if the input control parameters are allowed and set them to default
values if they are not. Returns a list of well-defined control parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.control.block.sgd(
  normalize = TRUE,
  maxiter = 1000,
  eps = 1e-08,
  nafill = 10,
  tol = 1e-08,
  size = c(100, 100),
  burn = 1,
  rate0 = 0.01,
  decay = 0.01,
  damping = 0.001,
  rate1 = 0.1,
  rate2 = 0.01,
  verbose = FALSE,
  frequency = 250,
  progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set.control.block.sgd_+3A_normalize">normalize</code></td>
<td>
<p>if <code>TRUE</code>, normalize <code>U</code> and <code>V</code> to uncorrelated Gaussian <code>U</code> and upper triangular <code>V</code> with positive diagonal</p>
</td></tr>
<tr><td><code id="set.control.block.sgd_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
<tr><td><code id="set.control.block.sgd_+3A_eps">eps</code></td>
<td>
<p>how much shrinkage has to be introduced on extreme predictions lying outside of the data range</p>
</td></tr>
<tr><td><code id="set.control.block.sgd_+3A_nafill">nafill</code></td>
<td>
<p>how frequently the <code>NA</code> values are filled, by default <code>NA</code> values are filled at each iteration of the algorithm</p>
</td></tr>
<tr><td><code id="set.control.block.sgd_+3A_tol">tol</code></td>
<td>
<p>tolerance threshold for the stopping criterion</p>
</td></tr>
<tr><td><code id="set.control.block.sgd_+3A_size">size</code></td>
<td>
<p>mini-batch size, the first value is for row sub-sample, the second value is for column sub-sample</p>
</td></tr>
<tr><td><code id="set.control.block.sgd_+3A_burn">burn</code></td>
<td>
<p>percentage of iterations to ignore before performing Polyak averaging</p>
</td></tr>
<tr><td><code id="set.control.block.sgd_+3A_rate0">rate0</code></td>
<td>
<p>initial learning rate</p>
</td></tr>
<tr><td><code id="set.control.block.sgd_+3A_decay">decay</code></td>
<td>
<p>learning rate decay</p>
</td></tr>
<tr><td><code id="set.control.block.sgd_+3A_damping">damping</code></td>
<td>
<p>regularization parameter which is added to the Hessian to ensure numerical stability</p>
</td></tr>
<tr><td><code id="set.control.block.sgd_+3A_rate1">rate1</code></td>
<td>
<p>exponential decay rate for the moment estimate of the gradient</p>
</td></tr>
<tr><td><code id="set.control.block.sgd_+3A_rate2">rate2</code></td>
<td>
<p>exponential decay rate for the moment estimate of the Hessian</p>
</td></tr>
<tr><td><code id="set.control.block.sgd_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, print the optimization status</p>
</td></tr>
<tr><td><code id="set.control.block.sgd_+3A_frequency">frequency</code></td>
<td>
<p>how often the optimization status is printed (only if <code>verbose=TRUE</code>)</p>
</td></tr>
<tr><td><code id="set.control.block.sgd_+3A_progress">progress</code></td>
<td>
<p>if <code>TRUE</code>, print a compact progress-bar instead of a full-report of the optimization status (only if <code>verbose=TRUE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> of control parameters for the adaptive SGD algorithm with block-wise sub-sampling
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sgdGMF)

# Empty call
set.control.block.sgd()

# Parametrized call
set.control.block.sgd(maxiter = 2000, rate0 = 0.01, decay = 0.01)


</code></pre>

<hr>
<h2 id='set.control.coord.sgd'>Check and set the control parameters for the coordinate-SGD algorithm</h2><span id='topic+set.control.coord.sgd'></span>

<h3>Description</h3>

<p>Check if the input control parameters are allowed and set them to default
values if they are not. Returns a list of well-defined control parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.control.coord.sgd(
  normalize = TRUE,
  maxiter = 1000,
  eps = 1e-08,
  nafill = 10,
  tol = 1e-08,
  size = c(100, 100),
  burn = 1,
  rate0 = 0.01,
  decay = 0.01,
  damping = 0.001,
  rate1 = 0.1,
  rate2 = 0.01,
  verbose = FALSE,
  frequency = 250,
  progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set.control.coord.sgd_+3A_normalize">normalize</code></td>
<td>
<p>if <code>TRUE</code>, normalize <code>U</code> and <code>V</code> to uncorrelated Gaussian <code>U</code> and upper triangular <code>V</code> with positive diagonal</p>
</td></tr>
<tr><td><code id="set.control.coord.sgd_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
<tr><td><code id="set.control.coord.sgd_+3A_eps">eps</code></td>
<td>
<p>how much shrinkage has to be introduced on extreme predictions lying outside of the data range</p>
</td></tr>
<tr><td><code id="set.control.coord.sgd_+3A_nafill">nafill</code></td>
<td>
<p>how frequently the <code>NA</code> values are filled, by default <code>NA</code> values are filled at each iteration of the algorithm</p>
</td></tr>
<tr><td><code id="set.control.coord.sgd_+3A_tol">tol</code></td>
<td>
<p>tolerance threshold for the stopping criterion</p>
</td></tr>
<tr><td><code id="set.control.coord.sgd_+3A_size">size</code></td>
<td>
<p>mini-batch size, the first value is for row sub-sample, the second value is for column sub-sample</p>
</td></tr>
<tr><td><code id="set.control.coord.sgd_+3A_burn">burn</code></td>
<td>
<p>percentage of iterations to ignore before performing Polyak averaging</p>
</td></tr>
<tr><td><code id="set.control.coord.sgd_+3A_rate0">rate0</code></td>
<td>
<p>initial learning rate</p>
</td></tr>
<tr><td><code id="set.control.coord.sgd_+3A_decay">decay</code></td>
<td>
<p>learning rate decay</p>
</td></tr>
<tr><td><code id="set.control.coord.sgd_+3A_damping">damping</code></td>
<td>
<p>regularization parameter which is added to the Hessian to ensure numerical stability</p>
</td></tr>
<tr><td><code id="set.control.coord.sgd_+3A_rate1">rate1</code></td>
<td>
<p>exponential decay rate for the moment estimate of the gradient</p>
</td></tr>
<tr><td><code id="set.control.coord.sgd_+3A_rate2">rate2</code></td>
<td>
<p>exponential decay rate for the moment estimate of the Hessian</p>
</td></tr>
<tr><td><code id="set.control.coord.sgd_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, print the optimization status</p>
</td></tr>
<tr><td><code id="set.control.coord.sgd_+3A_frequency">frequency</code></td>
<td>
<p>how often the optimization status is printed (only if <code>verbose=TRUE</code>)</p>
</td></tr>
<tr><td><code id="set.control.coord.sgd_+3A_progress">progress</code></td>
<td>
<p>if <code>TRUE</code>, print a compact progress-bar instead of a full-report of the optimization status (only if <code>verbose=TRUE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> of control parameters for the adaptive SGD algorithm with coordinate-wise sub-sampling
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sgdGMF)

# Empty call
set.control.coord.sgd()

# Parametrized call
set.control.coord.sgd(maxiter = 2000, rate0 = 0.01, decay = 0.01)

</code></pre>

<hr>
<h2 id='set.control.cv'>Check and set the cross-validation parameters</h2><span id='topic+set.control.cv'></span>

<h3>Description</h3>

<p>Check if the input cross-validation parameters are allowed and set them to default
values if they are not. Returns a list of well-defined cross-validation parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.control.cv(
  criterion = c("dev", "mae", "mse", "aic", "bic"),
  refit = TRUE,
  nfolds = 5,
  proportion = 0.3,
  init = c("common", "separate"),
  verbose = FALSE,
  parallel = FALSE,
  nthreads = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set.control.cv_+3A_criterion">criterion</code></td>
<td>
<p>information criterion to minimize for selecting the matrix rank</p>
</td></tr>
<tr><td><code id="set.control.cv_+3A_refit">refit</code></td>
<td>
<p>if <code>TRUE</code>, refit the model with the selected rank and return the fitted model</p>
</td></tr>
<tr><td><code id="set.control.cv_+3A_nfolds">nfolds</code></td>
<td>
<p>number of cross-validation folds</p>
</td></tr>
<tr><td><code id="set.control.cv_+3A_proportion">proportion</code></td>
<td>
<p>proportion of the data to be used as test set in each fold</p>
</td></tr>
<tr><td><code id="set.control.cv_+3A_init">init</code></td>
<td>
<p>initialization approach to use</p>
</td></tr>
<tr><td><code id="set.control.cv_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, print the cross-validation status</p>
</td></tr>
<tr><td><code id="set.control.cv_+3A_parallel">parallel</code></td>
<td>
<p>if <code>TRUE</code>, allows for parallel computing</p>
</td></tr>
<tr><td><code id="set.control.cv_+3A_nthreads">nthreads</code></td>
<td>
<p>number of cores to use in parallel (only if <code>parallel=TRUE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> of control parameters for the cross-validation algorithm
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set.control.init">set.control.init</a></code>, <code><a href="#topic+set.control.alg">set.control.alg</a></code>, <code><a href="#topic+sgdgmf.cv">sgdgmf.cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sgdGMF)

# Empty call
set.control.cv()

# Parametrized call
set.control.cv(criterion = "bic", proportion = 0.2)

</code></pre>

<hr>
<h2 id='set.control.init'>Check and set the initialization parameters for a GMF model</h2><span id='topic+set.control.init'></span>

<h3>Description</h3>

<p>Check if the input initialization parameters are allowed and set them to default
values if they are not. Returns a list of well-defined options which specify how
to initialize a GMF model. See <code><a href="#topic+sgdgmf.init">sgdgmf.init</a></code> for more details upon the methods used for initialisation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.control.init(
  method = c("ols", "glm", "random", "values"),
  type = c("deviance", "pearson", "working", "link"),
  values = list(),
  niter = 5,
  normalize = TRUE,
  verbose = FALSE,
  parallel = FALSE,
  nthreads = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set.control.init_+3A_method">method</code></td>
<td>
<p>initialization method (see <code><a href="#topic+sgdgmf.init">sgdgmf.init</a></code> for more details upon the initialization methods used)</p>
</td></tr>
<tr><td><code id="set.control.init_+3A_type">type</code></td>
<td>
<p>residual type to be decomposed (see <code><a href="#topic+sgdgmf.init">sgdgmf.init</a></code> for more details upon the residuals used)</p>
</td></tr>
<tr><td><code id="set.control.init_+3A_values">values</code></td>
<td>
<p>list of custom initialization parameters fixed by the user</p>
</td></tr>
<tr><td><code id="set.control.init_+3A_niter">niter</code></td>
<td>
<p>number if refinement iterations in the <code>"svd"</code> method</p>
</td></tr>
<tr><td><code id="set.control.init_+3A_normalize">normalize</code></td>
<td>
<p>if <code>TRUE</code>, normalize <code>U</code> and <code>V</code> to orthogonal <code>U</code> and lower triangular <code>V</code></p>
</td></tr>
<tr><td><code id="set.control.init_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, print the initialization state</p>
</td></tr>
<tr><td><code id="set.control.init_+3A_parallel">parallel</code></td>
<td>
<p>if <code>TRUE</code>, use parallel computing for the <code>"glm"</code> method</p>
</td></tr>
<tr><td><code id="set.control.init_+3A_nthreads">nthreads</code></td>
<td>
<p>number of cores to be used in the <code>"glm"</code> method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> of control parameters for the initialization
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set.control.alg">set.control.alg</a></code>, <code><a href="#topic+set.control.cv">set.control.cv</a></code>, <code><a href="#topic+sgdgmf.init">sgdgmf.init</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sgdGMF)

# Empty call
set.control.init()

# Parametrized call
set.control.init(method = "glm", type = "deviance", niter = 10)

</code></pre>

<hr>
<h2 id='set.control.newton'>Check and set the control parameters for the Newton algorithm</h2><span id='topic+set.control.newton'></span>

<h3>Description</h3>

<p>Check if the input control parameters of the quasi-Newton algorithm  are
allowed and set them to default values if they are not. Returns a list of
well-defined control parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.control.newton(
  normalize = TRUE,
  maxiter = 500,
  stepsize = 0.01,
  eps = 1e-08,
  nafill = 1,
  tol = 1e-05,
  damping = 0.001,
  verbose = FALSE,
  frequency = 50,
  parallel = FALSE,
  nthreads = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set.control.newton_+3A_normalize">normalize</code></td>
<td>
<p>if <code>TRUE</code>, normalize <code>U</code> and <code>V</code> to uncorrelated Gaussian <code>U</code> and upper triangular <code>V</code> with positive diagonal</p>
</td></tr>
<tr><td><code id="set.control.newton_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
<tr><td><code id="set.control.newton_+3A_stepsize">stepsize</code></td>
<td>
<p>step-size parameter scaling each IRWLS step</p>
</td></tr>
<tr><td><code id="set.control.newton_+3A_eps">eps</code></td>
<td>
<p>how much shrinkage has to be introduced on extreme predictions lying outside of the data range</p>
</td></tr>
<tr><td><code id="set.control.newton_+3A_nafill">nafill</code></td>
<td>
<p>how frequently the <code>NA</code> values are filled, by default <code>NA</code> values are filled at each iteration of the algorithm</p>
</td></tr>
<tr><td><code id="set.control.newton_+3A_tol">tol</code></td>
<td>
<p>tolerance threshold for the stopping criterion</p>
</td></tr>
<tr><td><code id="set.control.newton_+3A_damping">damping</code></td>
<td>
<p>regularization parameter which is added to the Hessian to ensure numerical stability</p>
</td></tr>
<tr><td><code id="set.control.newton_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, print the optimization status</p>
</td></tr>
<tr><td><code id="set.control.newton_+3A_frequency">frequency</code></td>
<td>
<p>how often the optimization status is printed (only if <code>verbose=TRUE</code></p>
</td></tr>
<tr><td><code id="set.control.newton_+3A_parallel">parallel</code></td>
<td>
<p>if <code>TRUE</code>, allows for parallel computing using the <code>C++</code> library <code>OpenMP</code></p>
</td></tr>
<tr><td><code id="set.control.newton_+3A_nthreads">nthreads</code></td>
<td>
<p>number of cores to be used in parallel (only if <code>parallel=TTUE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> of control parameters for the quasi-Newton algorithm
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sgdGMF)

# Empty call
set.control.newton()

# Parametrized call
set.control.newton(maxiter = 1000, stepsize = 0.01, tol = 1e-04)

</code></pre>

<hr>
<h2 id='set.family'>Check and set the model family</h2><span id='topic+set.family'></span>

<h3>Description</h3>

<p>Check if the model family is allowed and return it eventually with a
different family name for compatibility with the <code>C++</code> implementation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.family(family)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set.family_+3A_family">family</code></td>
<td>
<p>a <code>glm</code> family (see <code><a href="stats.html#topic+family">family</a></code> for more details)</p>
</td></tr>
</table>

<hr>
<h2 id='set.mat.offset'>Check and set the offset matrix</h2><span id='topic+set.mat.offset'></span>

<h3>Description</h3>

<p>Check if the input offset matrix is well-defined and return the same
matrix without attributes such as row and column names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.mat.offset(O, n, m)
</code></pre>

<hr>
<h2 id='set.mat.weights'>Check and set the weighting matrix</h2><span id='topic+set.mat.weights'></span>

<h3>Description</h3>

<p>Check if the input weighting matrix is well-defined and return the same
matrix without attributes such as row and column names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.mat.weights(W, n, m)
</code></pre>

<hr>
<h2 id='set.mat.X'>Check and set the covariate matrix X</h2><span id='topic+set.mat.X'></span>

<h3>Description</h3>

<p>Check if the input covariate matrix X is well-defined and return the same
matrix without attributes such as row and column names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.mat.X(X, n, m)
</code></pre>

<hr>
<h2 id='set.mat.Y'>Check and set the response matrix Y</h2><span id='topic+set.mat.Y'></span>

<h3>Description</h3>

<p>Check if the input response matrix is well-defined and return the same
matrix without attributes such as row and column names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.mat.Y(Y)
</code></pre>

<hr>
<h2 id='set.mat.Z'>Check and set the covariate matrix X</h2><span id='topic+set.mat.Z'></span>

<h3>Description</h3>

<p>Check if the input covariate matrix X is well-defined and return the same
matrix without attributes such as row and column names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.mat.Z(Z, n, m)
</code></pre>

<hr>
<h2 id='set.penalty'>Check and set the penalty parameters</h2><span id='topic+set.penalty'></span>

<h3>Description</h3>

<p>Check if the input penalty parameters are allowed and set them to default
values if they are not. Returns a list of well-defined penalty parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.penalty(B = 0, A = 0, U = 1, V = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set.penalty_+3A_b">B</code></td>
<td>
<p>penalty parameter of <code>B</code></p>
</td></tr>
<tr><td><code id="set.penalty_+3A_a">A</code></td>
<td>
<p>penalty parameter of <code>A</code></p>
</td></tr>
<tr><td><code id="set.penalty_+3A_u">U</code></td>
<td>
<p>penalty parameter of <code>U</code></p>
</td></tr>
<tr><td><code id="set.penalty_+3A_v">V</code></td>
<td>
<p>penalty parameter of <code>V</code></p>
</td></tr>
</table>

<hr>
<h2 id='sgdgmf.cv'>Model selection via cross-validation for generalized matrix factorization models</h2><span id='topic+sgdgmf.cv'></span>

<h3>Description</h3>

<p>K-fold cross-validation for generalized matrix factorization (GMF) models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sgdgmf.cv(
  Y,
  X = NULL,
  Z = NULL,
  family = gaussian(),
  ncomps = seq(from = 1, to = 10, by = 1),
  weights = NULL,
  offset = NULL,
  method = c("airwls", "newton", "sgd"),
  sampling = c("block", "coord", "rnd-block"),
  penalty = list(),
  control.init = list(),
  control.alg = list(),
  control.cv = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sgdgmf.cv_+3A_y">Y</code></td>
<td>
<p>matrix of responses (<code class="reqn">n \times m</code>)</p>
</td></tr>
<tr><td><code id="sgdgmf.cv_+3A_x">X</code></td>
<td>
<p>matrix of row fixed effects (<code class="reqn">n \times p</code>)</p>
</td></tr>
<tr><td><code id="sgdgmf.cv_+3A_z">Z</code></td>
<td>
<p>matrix of column fixed effects (<code class="reqn">q \times m</code>)</p>
</td></tr>
<tr><td><code id="sgdgmf.cv_+3A_family">family</code></td>
<td>
<p>a <code>glm</code> family (see <code><a href="stats.html#topic+family">family</a></code> for more details)</p>
</td></tr>
<tr><td><code id="sgdgmf.cv_+3A_ncomps">ncomps</code></td>
<td>
<p>ranks of the latent matrix factorization used in cross-validation (default 1 to 10)</p>
</td></tr>
<tr><td><code id="sgdgmf.cv_+3A_weights">weights</code></td>
<td>
<p>an optional matrix of weights (<code class="reqn">n \times m</code>)</p>
</td></tr>
<tr><td><code id="sgdgmf.cv_+3A_offset">offset</code></td>
<td>
<p>an optional matrix of offset values (<code class="reqn">n \times m</code>), that specify a known component to be included in the linear predictor.</p>
</td></tr>
<tr><td><code id="sgdgmf.cv_+3A_method">method</code></td>
<td>
<p>estimation method to minimize the negative penalized log-likelihood</p>
</td></tr>
<tr><td><code id="sgdgmf.cv_+3A_sampling">sampling</code></td>
<td>
<p>sub-sampling strategy to use if <code>method = "sgd"</code></p>
</td></tr>
<tr><td><code id="sgdgmf.cv_+3A_penalty">penalty</code></td>
<td>
<p>list of penalty parameters (see <code><a href="#topic+set.penalty">set.penalty</a></code> for more details)</p>
</td></tr>
<tr><td><code id="sgdgmf.cv_+3A_control.init">control.init</code></td>
<td>
<p>list of control parameters for the initialization (see <code><a href="#topic+set.control.init">set.control.init</a></code> for more details)</p>
</td></tr>
<tr><td><code id="sgdgmf.cv_+3A_control.alg">control.alg</code></td>
<td>
<p>list of control parameters for the optimization (see <code><a href="#topic+set.control.alg">set.control.alg</a></code> for more details)</p>
</td></tr>
<tr><td><code id="sgdgmf.cv_+3A_control.cv">control.cv</code></td>
<td>
<p>list of control parameters for the cross-validation (see <code><a href="#topic+set.control.cv">set.control.cv</a></code> for more details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Cross-validation is performed by minimizing the estimated out-of-sample error, which
can be measured in terms of averaged deviance, AIC or BIC calculated on fold-specific
test sets. Within each fold, the test set is defined as a fixed proportion of entries
in the response matrix which are held out from the estimation process.
To this end, the test set entries are hidden by <code>NA</code> values when training the
model. Then, the predicted, i.e. imputed, values are used to compute the fold-specific
out-of-sample error.
</p>


<h3>Value</h3>

<p>If <code>refit = FALSE</code> (see <code><a href="#topic+set.control.cv">set.control.cv</a></code>), the function returns a list containing <code>control.init</code>,
<code>control.alg</code>, <code>control.cv</code> and <code>summary.cv</code>. The latter is a matrix
collecting the cross-validation results for each combination of fold and latent
dimension.
</p>
<p>If <code>refit = TRUE</code> (see <code><a href="#topic+set.control.cv">set.control.cv</a></code>), the function returns an object of class <code>sgdgmf</code>,
obtained by refitting the model on the whole data matrix using the latent dimension
selected via cross-validation. The returned object also contains the <code>summary.cv</code>
information along with the other standard output of the <code><a href="#topic+sgdgmf.fit">sgdgmf.fit</a></code> function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the sgdGMF package
library(sgdGMF)

# Set the data dimensions
n = 100; m = 20; d = 5

# Generate data using Poisson, Binomial and Gamma models
data_pois = sim.gmf.data(n = n, m = m, ncomp = d, family = poisson())
data_bin = sim.gmf.data(n = n, m = m, ncomp = d, family = binomial())
data_gam = sim.gmf.data(n = n, m = m, ncomp = d, family = Gamma(link = "log"), dispersion = 0.25)

# Set RUN = TRUE to run the example, it may take some time. To speed up
# the computation it is possible to run CV in parallel specifying
# control.cv = list(parallel = TRUE, nthreads = &lt;number_of_workers&gt;)
# as an argument of sgdgmf.cv()
RUN = FALSE
if (RUN) {
  # Initialize the GMF parameters assuming 3 latent factors
  gmf_pois = sgdgmf.cv(data_pois$Y, ncomp = 1:10, family = poisson())
  gmf_bin = sgdgmf.cv(data_bin$Y, ncomp = 3, family = binomial())
  gmf_gam = sgdgmf.cv(data_gam$Y, ncomp = 3, family = Gamma(link = "log"))

  # Get the fitted values in the link and response scales
  mu_hat_pois = fitted(gmf_pois, type = "response")
  mu_hat_bin = fitted(gmf_bin, type = "response")
  mu_hat_gam = fitted(gmf_gam, type = "response")

  # Compare the results
  oldpar = par(no.readonly = TRUE)
  par(mfrow = c(1,3), mar = c(1,1,3,1))
  image(data_pois$Y, axes = FALSE, main = expression(Y[Pois]))
  image(data_pois$mu, axes = FALSE, main = expression(mu[Pois]))
  image(mu_hat_pois, axes = FALSE, main = expression(hat(mu)[Pois]))
  image(data_bin$Y, axes = FALSE, main = expression(Y[Bin]))
  image(data_bin$mu, axes = FALSE, main = expression(mu[Bin]))
  image(mu_hat_bin, axes = FALSE, main = expression(hat(mu)[Bin]))
  image(data_gam$Y, axes = FALSE, main = expression(Y[Gam]))
  image(data_gam$mu, axes = FALSE, main = expression(mu[Gam]))
  image(mu_hat_gam, axes = FALSE, main = expression(hat(mu)[Gam]))
  par(oldpar)
}

</code></pre>

<hr>
<h2 id='sgdgmf.cv.step'>Single step of cross-validation for generalized matrix factorization models</h2><span id='topic+sgdgmf.cv.step'></span>

<h3>Description</h3>

<p>Internal function running a single step of cross-validation for generalized
matrix factorization (GMF) models and calculating some goodness-of-fit measures
on the train and test sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sgdgmf.cv.step(
  train,
  test,
  X,
  Z,
  family,
  ncomp,
  maxcomp,
  fold,
  nfolds,
  weights,
  offset,
  method,
  sampling,
  penalty,
  control.init,
  control.alg,
  control.cv
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sgdgmf.cv.step_+3A_train">train</code></td>
<td>
<p>train-set matrix of responses (<code class="reqn">n \times m</code>)</p>
</td></tr>
<tr><td><code id="sgdgmf.cv.step_+3A_test">test</code></td>
<td>
<p>test-set matrix of responses (<code class="reqn">n \times m</code>)</p>
</td></tr>
<tr><td><code id="sgdgmf.cv.step_+3A_x">X</code></td>
<td>
<p>matrix of row fixed effects (<code class="reqn">n \times p</code>)</p>
</td></tr>
<tr><td><code id="sgdgmf.cv.step_+3A_z">Z</code></td>
<td>
<p>matrix of column fixed effects (<code class="reqn">q \times m</code>)</p>
</td></tr>
<tr><td><code id="sgdgmf.cv.step_+3A_family">family</code></td>
<td>
<p>a <code>glm</code> family (see <code><a href="stats.html#topic+family">family</a></code> for more details)</p>
</td></tr>
<tr><td><code id="sgdgmf.cv.step_+3A_ncomp">ncomp</code></td>
<td>
<p>ranks of the latent matrix factorization used in cross-validation (default 1 to 10)</p>
</td></tr>
<tr><td><code id="sgdgmf.cv.step_+3A_maxcomp">maxcomp</code></td>
<td>
<p>maximum rank allowed in the cross-validation exploration</p>
</td></tr>
<tr><td><code id="sgdgmf.cv.step_+3A_fold">fold</code></td>
<td>
<p>integer number identifying the current fold</p>
</td></tr>
<tr><td><code id="sgdgmf.cv.step_+3A_nfolds">nfolds</code></td>
<td>
<p>maximum number of folds in the cross-validation</p>
</td></tr>
<tr><td><code id="sgdgmf.cv.step_+3A_weights">weights</code></td>
<td>
<p>an optional matrix of weights (<code class="reqn">n \times m</code>)</p>
</td></tr>
<tr><td><code id="sgdgmf.cv.step_+3A_offset">offset</code></td>
<td>
<p>an optional matrix of offset values (<code class="reqn">n \times m</code>), that specify a known component to be included in the linear predictor.</p>
</td></tr>
<tr><td><code id="sgdgmf.cv.step_+3A_method">method</code></td>
<td>
<p>estimation method to minimize the negative penalized log-likelihood</p>
</td></tr>
<tr><td><code id="sgdgmf.cv.step_+3A_sampling">sampling</code></td>
<td>
<p>sub-sampling strategy to use if <code>method = "sgd"</code></p>
</td></tr>
<tr><td><code id="sgdgmf.cv.step_+3A_penalty">penalty</code></td>
<td>
<p>list of penalty parameters (see <code><a href="#topic+set.penalty">set.penalty</a></code> for more details)</p>
</td></tr>
<tr><td><code id="sgdgmf.cv.step_+3A_control.init">control.init</code></td>
<td>
<p>list of control parameters for the initialization (see <code><a href="#topic+set.control.init">set.control.init</a></code> for more details)</p>
</td></tr>
<tr><td><code id="sgdgmf.cv.step_+3A_control.alg">control.alg</code></td>
<td>
<p>list of control parameters for the optimization (see <code><a href="#topic+set.control.alg">set.control.alg</a></code> for more details)</p>
</td></tr>
<tr><td><code id="sgdgmf.cv.step_+3A_control.cv">control.cv</code></td>
<td>
<p>list of control parameters for the cross-validation (see <code><a href="#topic+set.control.cv">set.control.cv</a></code> for more details)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>data.frame</code>  containing the current number of latent factors
in the model (<code>ncomp</code>), the fold identifier (<code>fold</code>), the degrees of
freedom, i.e. the number of parameters, of the model (<code>df</code>), the AIC, BIC
and deviance (respectively, <code>aic</code>, <code>bic</code>, <code>dev</code>)
calculated on the train and test sets.
</p>

<hr>
<h2 id='sgdgmf.fit'>Factorize a matrix of non-Gaussian observations using GMF</h2><span id='topic+sgdgmf.fit'></span>

<h3>Description</h3>

<p>Fit a generalized matrix factorization (GMF) model for non-Gaussian data using
either deterministic or stochastic optimization methods.
It is an alternative to PCA when the observed data are binary, counts, and positive
scores or, more generally, when the conditional distribution of the observations
can be appropriately described using a dispersion exponential family
or a quasi-likelihood model.
Some examples are Gaussian, Gamma, Binomial and Poisson probability laws.
</p>
<p>The dependence among the observations and the variables in the sample can be
taken into account through appropriate row- and column-specific regression effects.
The residual variability is then modeled through a low-rank matrix factorization.
</p>
<p>For the estimation, the package implements two deterministic optimization methods,
(AIRWLS and Newton) and two stochastic optimization algorithms (adaptive SGD with
coordinate-wise and block-wise sub-sampling).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sgdgmf.fit(
  Y,
  X = NULL,
  Z = NULL,
  family = gaussian(),
  ncomp = 2,
  weights = NULL,
  offset = NULL,
  method = c("airwls", "newton", "sgd"),
  sampling = c("block", "coord", "rnd-block"),
  penalty = list(),
  control.init = list(),
  control.alg = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sgdgmf.fit_+3A_y">Y</code></td>
<td>
<p>matrix of responses (<code class="reqn">n \times m</code>)</p>
</td></tr>
<tr><td><code id="sgdgmf.fit_+3A_x">X</code></td>
<td>
<p>matrix of row fixed effects (<code class="reqn">n \times p</code>)</p>
</td></tr>
<tr><td><code id="sgdgmf.fit_+3A_z">Z</code></td>
<td>
<p>matrix of column fixed effects (<code class="reqn">q \times m</code>)</p>
</td></tr>
<tr><td><code id="sgdgmf.fit_+3A_family">family</code></td>
<td>
<p>a <code>glm</code> family (see <code><a href="stats.html#topic+family">family</a></code> for more details)</p>
</td></tr>
<tr><td><code id="sgdgmf.fit_+3A_ncomp">ncomp</code></td>
<td>
<p>rank of the latent matrix factorization (default 2)</p>
</td></tr>
<tr><td><code id="sgdgmf.fit_+3A_weights">weights</code></td>
<td>
<p>an optional matrix of weights (<code class="reqn">n \times m</code>)</p>
</td></tr>
<tr><td><code id="sgdgmf.fit_+3A_offset">offset</code></td>
<td>
<p>an optional matrix of offset values (<code class="reqn">n \times m</code>), that specify a known component to be included in the linear predictor</p>
</td></tr>
<tr><td><code id="sgdgmf.fit_+3A_method">method</code></td>
<td>
<p>estimation method to minimize the negative penalized log-likelihood</p>
</td></tr>
<tr><td><code id="sgdgmf.fit_+3A_sampling">sampling</code></td>
<td>
<p>sub-sampling strategy to use if <code>method = "sgd"</code></p>
</td></tr>
<tr><td><code id="sgdgmf.fit_+3A_penalty">penalty</code></td>
<td>
<p>list of penalty parameters (see <code><a href="#topic+set.penalty">set.penalty</a></code> for more details)</p>
</td></tr>
<tr><td><code id="sgdgmf.fit_+3A_control.init">control.init</code></td>
<td>
<p>list of control parameters for the initialization (see <code><a href="#topic+set.control.init">set.control.init</a></code> for more details)</p>
</td></tr>
<tr><td><code id="sgdgmf.fit_+3A_control.alg">control.alg</code></td>
<td>
<p>list of control parameters for the optimization (see <code><a href="#topic+set.control.alg">set.control.alg</a></code> for more details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Model specification</strong>
</p>
<p>The model we consider is defined as follows.
Let <code class="reqn">Y = (y_{ij})</code> be a matrix of observed data of dimension <code class="reqn">n \times m</code>.
We assume for the <code class="reqn">(i,j)</code>th observation in the matrix a dispersion exponential family law
<code class="reqn">(y_{ij} \mid \theta_{ij}) \sim EF(\theta_{ij}, \phi)</code>, where <code class="reqn">\theta_{ij}</code> is the
natural parameter and <code class="reqn">\phi</code> is the dispersion parameter.
Recall that the conditional probability density function of <code class="reqn">y_{ij}</code> is given by
</p>
<p style="text-align: center;"><code class="reqn">f (y_{ij}; \psi) = \exp \big[ w_{ij} \{(y_{ij} \theta_{ij} - b(\theta_{ij})\} / \phi - c(y_{ij}, \phi / w_{ij}) \big],</code>
</p>

<p>where <code class="reqn">\psi</code> is the vector of unknown parameters to be estimated,
<code class="reqn">b(\cdot)</code> is a convex twice differentiable log-partition function,
and <code class="reqn">c(\cdot,\cdot)</code> is the cumulant function of the family.
</p>
<p>The conditional mean of <code class="reqn">y_{ij}</code>, say <code class="reqn">\mu_{ij}</code>, is then modeled as
</p>
<p style="text-align: center;"><code class="reqn">g(\mu_{ij}) = \eta_{ij} = x_i^\top \beta_j + \alpha_i^\top z_j + u_i^\top v_j,</code>
</p>

<p>where <code class="reqn">g(\cdot)</code> is a bijective twice differentiable link function, <code class="reqn">\eta_{ij}</code> is
a linear predictor, <code class="reqn">x_i \in \mathbb{R}^p</code> and <code class="reqn">z_j \in \mathbb{R}^q</code> are
observed covariate vectors, <code class="reqn">\beta_j \in \mathbb{R}^p</code> and <code class="reqn">\alpha_j \in \mathbb{R}^q</code>
are unknown regression parameters and, finally, <code class="reqn">u_i \in \mathbb{R}^d</code> and
<code class="reqn">v_j \in \mathbb{R}^d</code> are latent vector explaining the residual varibility
not captured by the regression effects.
Equivalently, in matrix form, we have
<code class="reqn">g(\mu) = \eta = X B^\top + A Z^\top + U V^\top.</code>
</p>
<p>The natural parameter <code class="reqn">\theta_{ij}</code> is linked to the conditional mean of <code class="reqn">y_{ij}</code>
through the equation <code class="reqn">E(y_{ij}) = \mu_{ij} = b'(\theta_{ij})</code>.
Similarly, the variance of <code class="reqn">y_{ij}</code> is given by
<code class="reqn">\text{Var}(y_{ij}) = (\phi / w_{ij}) \,\nu(\mu_{ij}) = (\phi / w_{ij}) \,b''(\mu_{ij})</code>,
where <code class="reqn">\nu(\cdot)</code> is the so-called variance function of the family.
Finally, we denote by <code class="reqn">D_\phi(y,\mu)</code> the deviance function of the family, which
is defined as <code class="reqn">D_\phi(y,\mu) = - 2 \log\{ f(y, \psi) / f_0 (y) \}</code>,
where <code class="reqn">f_0(y)</code> is the likelihood of the saturated model.
</p>
<p>The estimation of the model parameters is performed by minimizing the penalized deviance function
</p>
<p style="text-align: center;"><code class="reqn">\displaystyle \ell_\lambda (\psi; y) = - \sum_{i = 1}^{n} \sum_{j = 1}^{m} D_\phi(y_{ij}, \mu_{ij}) + \frac{\lambda_{\scriptscriptstyle U}}{2} \| U \|_F^2 + \frac{\lambda_{\scriptscriptstyle V}}{2} \| V \|_F^2,</code>
</p>

<p>where <code class="reqn">\lambda_{\scriptscriptstyle U} &gt; 0</code> and <code class="reqn">\lambda_{\scriptscriptstyle V} &gt; 0</code> are regularization parameters and <code class="reqn">\|\cdot\|_F</code> is the Frobenious norm.
Additional <code class="reqn">\ell_2</code> penalization terms can be introduced to regularize <code class="reqn">B</code> and <code class="reqn">A</code>.
Quasi-likelihood models can be considered as well, where <code class="reqn">D_\phi(y, \mu)</code> is substituted by
<code class="reqn">Q_\phi(y, \mu) = - \log (\phi/w) - (w / \phi) \int_y^\mu \{(y - t) / \nu(t) \} \,dt,</code>
under an appropriate specification of mean, variance and link functions.
</p>
<p><strong>Identifiability constraints</strong>
</p>
<p>The GMF model is not identifiable being invariant with respect to rotation, scaling
and sign-flip transformations of <code class="reqn">U</code> and <code class="reqn">V</code>. To enforce the uniqueness of the
solution, we impose the following identifiability constraints:
</p>

<ul>
<li> <p><code class="reqn">\text{Cov}(U) = U^\top (I_n - 1_n 1_n^\top / n) U / n = I_d</code>,
</p>
</li>
<li> <p><code class="reqn">V</code> is lower triangular, with positive diagonal entries,
</p>
</li></ul>

<p>where <code class="reqn">I_n</code> and <code class="reqn">1_n</code> are, respectively, the <code class="reqn">n</code>-dimensional identity
matrix and unitary vector.
</p>
<p>Alternative identifiability constraints on <code class="reqn">U</code> and <code class="reqn">V</code> can be easily obtained
by post processing. For instance, a PCA-like solution, say <code class="reqn">U^\top U</code> is diagonal
and <code class="reqn">V^\top V = I_d</code>, can by obtained by applying the truncated SVD decomposition
<code class="reqn">U V^\top = \tilde{U} \tilde{D} \tilde{V}^\top</code>, and setting
<code class="reqn">U = \tilde{U} \tilde{D}</code> and <code class="reqn">V = \tilde{V}</code>.
</p>
<p><strong>Estimation algorithms</strong>
</p>
<p>To obtain the penalized maximum likelihood estimate, we here employs
four different algorithms
</p>

<ul>
<li><p> AIRWLS: alternated iterative re-weighted least squares (<code>method="airwls"</code>);
</p>
</li>
<li><p> Newton: quasi-Newton algorithm with diagonal Hessian (<code>method="newton"</code>);
</p>
</li>
<li><p> C-SGD: adaptive stochastic gradient descent with coordinate-wise sub-sampling (<code>method="sgd", sampling="coord"</code>);
</p>
</li>
<li><p> B-SGD: adaptive stochastic gradient descent with block-wise sub-sampling (<code>method="sgd", sampling="block"</code>);
</p>
</li>
<li><p> RB-SGD: as B-SGD but with an alternative rule to scan randomly the minibatch blocks (<code>method="sgd", sampling="rnd-block"</code>).
</p>
</li></ul>

<p><strong>Likelihood families</strong>
</p>
<p>Currently, all standard <code>glm</code> families are supported, including <code>neg.bin</code>
and <code>negative.binomial</code> families from the <code>MASS</code> package.
In such a case, the deviance function we consider takes the form
<code class="reqn">D_\phi(y, \mu) = 2 w \big[ y \log(y / \mu) - (y + \phi) \log\{ (y + \phi) / (\mu + \phi) \} \big]</code>.
This corresponds to a Negative Binomial model with variance function <code class="reqn">\nu(\mu) = \mu + \mu^2 / \phi</code>.
Then, for <code class="reqn">\phi \rightarrow \infty</code>, the Negative Binomial likelihood converges
to a Poisson likelihood, having linear variance function, say <code class="reqn">\nu(\mu) = \mu</code>.
Notice that the over-dispersion parameter, that here is denoted as <code class="reqn">\phi</code>,
in the <code>MASS</code> package is referred to as <code class="reqn">\theta</code>.
If the Negative Binomial family is selected, a global over-dispersion parameter
<code class="reqn">\phi</code> is estimated from the data using the method of moments.
</p>
<p><strong>Parallelization</strong>
</p>
<p>Parallel execution is implemented in <code>C++</code> using <code>OpenMP</code>. When installing
and compiling the <code>sgdGMF</code> package, the compiler check whether <code>OpenMP</code>
is installed in the system. If it is not, the package is compiled excluding all
the <code>OpenMP</code> functionalities and no parallel execution is allowed at <code>C++</code>
level.
</p>
<p>Notice that <code>OpenMP</code> is not compatible with <code>R</code> parallel computing packages,
such as <code>parallel</code> and <code>foreach</code>. Therefore, when <code>parallel=TRUE</code>,
it is not possible to run the <code>sgdgmf.fit</code> function within <code>R</code> level
parallel functions, e.g., <code>foreach</code> loop.
</p>


<h3>Value</h3>

<p>An <code>sgdgmf</code> object, namely a list, containing the estimated parameters of the GMF model.
In particular, the returned object collects the following information:
</p>

<ul>
<li> <p><code>method</code>: the selected estimation method
</p>
</li>
<li> <p><code>family</code>: the model family
</p>
</li>
<li> <p><code>ncomp</code>: rank of the latent matrix factorization
</p>
</li>
<li> <p><code>npar</code>: number of unknown parameters to be estimated
</p>
</li>
<li> <p><code>control.init</code>: list of control parameters used for the initialization
</p>
</li>
<li> <p><code>control.alg</code>: list of control parameters used for the optimization
</p>
</li>
<li> <p><code>control.cv</code>: list of control parameters used for the cross.validation
</p>
</li>
<li> <p><code>Y</code>: response matrix
</p>
</li>
<li> <p><code>X</code>: row-specific covariate matrix
</p>
</li>
<li> <p><code>Z</code>: column-specific covariate matrix
</p>
</li>
<li> <p><code>B</code>: the estimated col-specific coefficient matrix
</p>
</li>
<li> <p><code>A</code>: the estimated row-specific coefficient matrix
</p>
</li>
<li> <p><code>U</code>: the estimated factor matrix
</p>
</li>
<li> <p><code>V</code>: the estimated loading matrix
</p>
</li>
<li> <p><code>weights</code>: weighting matrix
</p>
</li>
<li> <p><code>offset</code>: offset matrix
</p>
</li>
<li> <p><code>eta</code>: the estimated linear predictor
</p>
</li>
<li> <p><code>mu</code>: the estimated mean matrix
</p>
</li>
<li> <p><code>var</code>: the estimated variance matrix
</p>
</li>
<li> <p><code>phi</code>: the estimated dispersion parameter
</p>
</li>
<li> <p><code>penalty</code>: the penalty value at the end of the optimization
</p>
</li>
<li> <p><code>deviance</code>: the deviance value at the end of the optimization
</p>
</li>
<li> <p><code>objective</code>: the penalized objective function at the end of the optimization
</p>
</li>
<li> <p><code>aic</code>: Akaike information criterion
</p>
</li>
<li> <p><code>bic</code>: Bayesian information criterion
</p>
</li>
<li> <p><code>names</code>: list of row and column names for all the output matrices
</p>
</li>
<li> <p><code>exe.time</code>: the total execution time in seconds
</p>
</li>
<li> <p><code>trace</code>: a trace matrix recording the optimization history
</p>
</li>
<li> <p><code>summary.cv</code>:
</p>
</li></ul>



<h3>References</h3>

<p>Kidzinnski, L., Hui, F.K.C., Warton, D.I. and Hastie, J.H. (2022).
<em>Generalized Matrix Factorization: efficient algorithms for fitting generalized linear latent variable models to large data arrays.</em>
Journal of Machine Learning Research, 23: 1-29.
</p>
<p>Wang, L. and Carvalho, L. (2023).
<em>Deviance matrix factorization.</em>
Electronic Journal of Statistics, 17(2): 3762-3810.
</p>
<p>Castiglione, C., Segers, A., Clement, L, Risso, D. (2024).
<em>Stochastic gradient descent estimation of generalized matrix factorization models with application to single-cell RNA sequencing data.</em>
arXiv preprint: arXiv:2412.20509.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set.control.init">set.control.init</a></code>, <code><a href="#topic+set.control.alg">set.control.alg</a></code>,
<code><a href="#topic+sgdgmf.init">sgdgmf.init</a></code>, <code><a href="#topic+sgdgmf.rank">sgdgmf.rank</a></code>,
<code><a href="#topic+refit.sgdgmf">refit.sgdgmf</a></code>, <code><a href="#topic+coef.sgdgmf">coef.sgdgmf</a></code>, <code><a href="#topic+resid.sgdgmf">resid.sgdgmf</a></code>,
<code><a href="#topic+fitted.sgdgmf">fitted.sgdgmf</a></code>, <code><a href="#topic+predict.sgdgmf">predict.sgdgmf</a></code>, <code><a href="#topic+plot.sgdgmf">plot.sgdgmf</a></code>,
<code><a href="#topic+screeplot.sgdgmf">screeplot.sgdgmf</a></code>, <code><a href="#topic+biplot.sgdgmf">biplot.sgdgmf</a></code>, <code><a href="#topic+image.sgdgmf">image.sgdgmf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the sgdGMF package
library(sgdGMF)

# Set the data dimensions
n = 100; m = 20; d = 5

# Generate data using Poisson, Binomial and Gamma models
data = sim.gmf.data(n = n, m = m, ncomp = d, family = poisson())

# Estimate the GMF parameters assuming 3 latent factors
gmf = sgdgmf.fit(data$Y, ncomp = 3, family = poisson(), method = "airwls")

# Get the fitted values in the link and response scales
mu_hat = fitted(gmf, type = "response")

# Compare the results
oldpar = par(no.readonly = TRUE)
par(mfrow = c(1,3), mar = c(1,1,3,1))
image(data$Y, axes = FALSE, main = expression(Y))
image(data$mu, axes = FALSE, main = expression(mu))
image(mu_hat, axes = FALSE, main = expression(hat(mu)))
par(oldpar)

</code></pre>

<hr>
<h2 id='sgdgmf.init'>Initialize the parameters of a generalized matrix factorization model</h2><span id='topic+sgdgmf.init'></span><span id='topic+sgdgmf.init.ols'></span><span id='topic+sgdgmf.init.glm'></span><span id='topic+sgdgmf.init.random'></span><span id='topic+sgdgmf.init.custom'></span>

<h3>Description</h3>

<p>Provide four initialization methods to set the initial values of
a generalized matrix factorization (GMF) model identified by a <code><a href="stats.html#topic+glm">glm</a></code> family
and a linear predictor of the form <code class="reqn">g(\mu) = \eta = X B^\top + A Z^\top + U V^\top</code>,
with bijective link function <code class="reqn">g(\cdot)</code>.
See <code><a href="#topic+sgdgmf.fit">sgdgmf.fit</a></code> for more details on the model specification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sgdgmf.init(
  Y,
  X = NULL,
  Z = NULL,
  ncomp = 2,
  family = gaussian(),
  weights = NULL,
  offset = NULL,
  method = c("ols", "glm", "random", "values"),
  type = c("deviance", "pearson", "working", "link"),
  niter = 0,
  values = list(),
  verbose = FALSE,
  parallel = FALSE,
  nthreads = 1,
  savedata = TRUE
)

sgdgmf.init.ols(
  Y,
  X = NULL,
  Z = NULL,
  ncomp = 2,
  family = gaussian(),
  weights = NULL,
  offset = NULL,
  type = c("deviance", "pearson", "working", "link"),
  verbose = FALSE
)

sgdgmf.init.glm(
  Y,
  X = NULL,
  Z = NULL,
  ncomp = 2,
  family = gaussian(),
  weights = NULL,
  offset = NULL,
  type = c("deviance", "pearson", "working", "link"),
  verbose = FALSE,
  parallel = FALSE,
  nthreads = 1
)

sgdgmf.init.random(
  Y,
  X = NULL,
  Z = NULL,
  ncomp = 2,
  family = gaussian(),
  weights = NULL,
  offset = NULL,
  sigma = 1
)

sgdgmf.init.custom(
  Y,
  X = NULL,
  Z = NULL,
  ncomp = 2,
  family = gaussian(),
  values = list(),
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sgdgmf.init_+3A_y">Y</code></td>
<td>
<p>matrix of responses (<code class="reqn">n \times m</code>)</p>
</td></tr>
<tr><td><code id="sgdgmf.init_+3A_x">X</code></td>
<td>
<p>matrix of row-specific fixed effects (<code class="reqn">n \times p</code>)</p>
</td></tr>
<tr><td><code id="sgdgmf.init_+3A_z">Z</code></td>
<td>
<p>matrix of column-specific fixed effects (<code class="reqn">q \times m</code>)</p>
</td></tr>
<tr><td><code id="sgdgmf.init_+3A_ncomp">ncomp</code></td>
<td>
<p>rank of the latent matrix factorization</p>
</td></tr>
<tr><td><code id="sgdgmf.init_+3A_family">family</code></td>
<td>
<p>a model family, as in the <code><a href="stats.html#topic+glm">glm</a></code> interface</p>
</td></tr>
<tr><td><code id="sgdgmf.init_+3A_weights">weights</code></td>
<td>
<p>matrix of constant weights (<code class="reqn">n \times m</code>)</p>
</td></tr>
<tr><td><code id="sgdgmf.init_+3A_offset">offset</code></td>
<td>
<p>matrix of constant offset (<code class="reqn">n \times m</code>)</p>
</td></tr>
<tr><td><code id="sgdgmf.init_+3A_method">method</code></td>
<td>
<p>optimization method to be used for the initial fit</p>
</td></tr>
<tr><td><code id="sgdgmf.init_+3A_type">type</code></td>
<td>
<p>type of residuals to be used for initializing <code>U</code> via incomplete SVD decomposition</p>
</td></tr>
<tr><td><code id="sgdgmf.init_+3A_niter">niter</code></td>
<td>
<p>number of iterations to refine the initial estimate (only if <code>method="ols"</code> or <code>"svd"</code>)</p>
</td></tr>
<tr><td><code id="sgdgmf.init_+3A_values">values</code></td>
<td>
<p>a list of custom initial values for <code>B</code>, <code>A</code>, <code>U</code> and <code>V</code></p>
</td></tr>
<tr><td><code id="sgdgmf.init_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, prints the status of the initialization process</p>
</td></tr>
<tr><td><code id="sgdgmf.init_+3A_parallel">parallel</code></td>
<td>
<p>if <code>TRUE</code>, allows for parallel computing using the <code>foreach</code> package (only if <code>method="glm"</code>)</p>
</td></tr>
<tr><td><code id="sgdgmf.init_+3A_nthreads">nthreads</code></td>
<td>
<p>number of cores to be used in parallel (only if <code>parallel=TRUE</code> and <code>method="glm"</code>)</p>
</td></tr>
<tr><td><code id="sgdgmf.init_+3A_savedata">savedata</code></td>
<td>
<p>if <code>TRUE</code>, stores a copy of the input data</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>method = "ols"</code>, the initialization is performed fitting a sequence of linear
regressions followed by a residual SVD decomposition.
To account for non-Gaussian distribution of the data, regression and
decomposition are applied on the transformed response matrix <code class="reqn">Y_h = (g \circ h)(Y)</code>,
where <code class="reqn">h(\cdot)</code> is a function which prevent <code class="reqn">Y_h</code> to take infinite values.
For instance, in the Binomial case <code class="reqn">h(y) = 2 (1-\epsilon) y + \epsilon</code>,
while in the Poisson case <code class="reqn">h(y) = y + \epsilon</code>, where <code class="reqn">\epsilon</code> is a small
positive constant, typically <code>0.1</code> or <code>0.01</code>.
</p>
<p>If <code>method = "glm"</code>, the initialization is performed by fitting a sequence of
generalized linear models followed by a residual SVD decomposition.
In particular, to set <code class="reqn">\beta_j</code>, we use independent GLM fit with <code class="reqn">y_j \sim X \beta_j</code>.
Similarly, to set <code class="reqn">\alpha_i</code>, we fit the model <code class="reqn">y_i \sim Z \alpha_i + o_i</code>, with offset <code class="reqn">o_i = B x_i</code>.
Then, we obtain <code class="reqn">U</code> via SVD on the residuals. Finally, we obtain <code class="reqn">V</code> via independent GLM fit
under the model <code class="reqn">y_j \sim U v_j + o_j</code>, with offset <code class="reqn">o_i = X \beta_j + A z_j</code>.
</p>
<p>Both under <code>method = "ols"</code> and <code>method = "glm"</code>, it is possible to specify the
parameter <code>type</code> to change the type of residuals used for the SVD decomposition.
</p>
<p>If  <code>method = "random"</code>, the initialization is performed using independent Gaussian
random values for all the parameters in the model.
</p>
<p>If <code>method = "values"</code>, the initialization is performed using user-specified
values provided as an input, which must have compatible dimensions.
</p>


<h3>Value</h3>

<p>An <code>initgmf</code> object, namely a list, containing the initial estimates of the GMF parameters.
In particular, the returned object collects the following information:
</p>

<ul>
<li> <p><code>Y</code>: response matrix (only if <code>savedata=TRUE</code>)
</p>
</li>
<li> <p><code>X</code>: row-specific covariate matrix (only if <code>savedata=TRUE</code>)
</p>
</li>
<li> <p><code>Z</code>: column-specific covariate matrix (only if <code>savedata=TRUE</code>)
</p>
</li>
<li> <p><code>B</code>: the estimated col-specific coefficient matrix
</p>
</li>
<li> <p><code>A</code>: the estimated row-specific coefficient matrix
</p>
</li>
<li> <p><code>U</code>: the estimated factor matrix
</p>
</li>
<li> <p><code>V</code>: the estimated loading matrix
</p>
</li>
<li> <p><code>phi</code>: the estimated dispersion parameter
</p>
</li>
<li> <p><code>method</code>: the selected estimation method
</p>
</li>
<li> <p><code>family</code>: the model family
</p>
</li>
<li> <p><code>ncomp</code>: rank of the latent matrix factorization
</p>
</li>
<li> <p><code>type</code>: type of residuals used for the initialization of <code>U</code>
</p>
</li>
<li> <p><code>verbose</code>: if <code>TRUE</code>, print the status of the initialization process
</p>
</li>
<li> <p><code>parallel</code>: if <code>TRUE</code>, allows for parallel computing
</p>
</li>
<li> <p><code>nthreads</code>: number of cores to be used in parallel
</p>
</li>
<li> <p><code>savedata</code>: if <code>TRUE</code>, stores a copy of the input data
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(sgdGMF)

# Set the data dimensions
n = 100; m = 20; d = 5

# Generate data using Poisson, Binomial and Gamma models
data_pois = sim.gmf.data(n = n, m = m, ncomp = d, family = poisson())
data_bin = sim.gmf.data(n = n, m = m, ncomp = d, family = binomial())
data_gam = sim.gmf.data(n = n, m = m, ncomp = d, family = Gamma(link = "log"), dispersion = 0.25)

# Initialize the GMF parameters assuming 3 latent factors
init_pois = sgdgmf.init(data_pois$Y, ncomp = 3, family = poisson(), method = "ols")
init_bin = sgdgmf.init(data_bin$Y, ncomp = 3, family = binomial(), method = "ols")
init_gam = sgdgmf.init(data_gam$Y, ncomp = 3, family = Gamma(link = "log"), method = "ols")

# Get the fitted values in the link and response scales
mu_hat_pois = fitted(init_pois, type = "response")
mu_hat_bin = fitted(init_bin, type = "response")
mu_hat_gam = fitted(init_gam, type = "response")

# Compare the results
oldpar = par(no.readonly = TRUE)
par(mfrow = c(3,3), mar = c(1,1,3,1))
image(data_pois$Y, axes = FALSE, main = expression(Y[Pois]))
image(data_pois$mu, axes = FALSE, main = expression(mu[Pois]))
image(mu_hat_pois, axes = FALSE, main = expression(hat(mu)[Pois]))
image(data_bin$Y, axes = FALSE, main = expression(Y[Bin]))
image(data_bin$mu, axes = FALSE, main = expression(mu[Bin]))
image(mu_hat_bin, axes = FALSE, main = expression(hat(mu)[Bin]))
image(data_gam$Y, axes = FALSE, main = expression(Y[Gam]))
image(data_gam$mu, axes = FALSE, main = expression(mu[Gam]))
image(mu_hat_gam, axes = FALSE, main = expression(hat(mu)[Gam]))
par(oldpar)

</code></pre>

<hr>
<h2 id='sgdgmf.rank'>Rank selection via eigenvalue-gap methods</h2><span id='topic+sgdgmf.rank'></span>

<h3>Description</h3>

<p>Select the number of significant principal components of a GMF model via
exploitation of eigenvalue-gap methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sgdgmf.rank(
  Y,
  X = NULL,
  Z = NULL,
  maxcomp = ncol(Y),
  family = gaussian(),
  weights = NULL,
  offset = NULL,
  method = c("onatski", "act", "oht"),
  type.reg = c("ols", "glm"),
  type.res = c("deviance", "pearson", "working", "link"),
  normalize = FALSE,
  maxiter = 10,
  parallel = FALSE,
  nthreads = 1,
  return.eta = FALSE,
  return.mu = FALSE,
  return.res = FALSE,
  return.cov = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sgdgmf.rank_+3A_y">Y</code></td>
<td>
<p>matrix of responses (<code class="reqn">n \times m</code>)</p>
</td></tr>
<tr><td><code id="sgdgmf.rank_+3A_x">X</code></td>
<td>
<p>matrix of row-specific fixed effects (<code class="reqn">n \times p</code>)</p>
</td></tr>
<tr><td><code id="sgdgmf.rank_+3A_z">Z</code></td>
<td>
<p>matrix of column-specific fixed effects (<code class="reqn">q \times m</code>)</p>
</td></tr>
<tr><td><code id="sgdgmf.rank_+3A_maxcomp">maxcomp</code></td>
<td>
<p>maximum number of eigenvalues to compute</p>
</td></tr>
<tr><td><code id="sgdgmf.rank_+3A_family">family</code></td>
<td>
<p>a family as in the <code><a href="stats.html#topic+glm">glm</a></code> interface (default <code>gaussian()</code>)</p>
</td></tr>
<tr><td><code id="sgdgmf.rank_+3A_weights">weights</code></td>
<td>
<p>matrix of optional weights (<code class="reqn">n \times m</code>)</p>
</td></tr>
<tr><td><code id="sgdgmf.rank_+3A_offset">offset</code></td>
<td>
<p>matrix of optional offsets (<code class="reqn">n \times m</code>)</p>
</td></tr>
<tr><td><code id="sgdgmf.rank_+3A_method">method</code></td>
<td>
<p>rank selection method</p>
</td></tr>
<tr><td><code id="sgdgmf.rank_+3A_type.reg">type.reg</code></td>
<td>
<p>regression method to be used to profile out the covariate effects</p>
</td></tr>
<tr><td><code id="sgdgmf.rank_+3A_type.res">type.res</code></td>
<td>
<p>residual type to be decomposed</p>
</td></tr>
<tr><td><code id="sgdgmf.rank_+3A_normalize">normalize</code></td>
<td>
<p>if <code>TRUE</code>, standardize column-by-column the residual matrix</p>
</td></tr>
<tr><td><code id="sgdgmf.rank_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
<tr><td><code id="sgdgmf.rank_+3A_parallel">parallel</code></td>
<td>
<p>if <code>TRUE</code>, allows for parallel computing using <code>foreach</code></p>
</td></tr>
<tr><td><code id="sgdgmf.rank_+3A_nthreads">nthreads</code></td>
<td>
<p>number of cores to be used in parallel (only if <code>parallel=TRUE</code>)</p>
</td></tr>
<tr><td><code id="sgdgmf.rank_+3A_return.eta">return.eta</code></td>
<td>
<p>if <code>TRUE</code>, return the linear predictor martix</p>
</td></tr>
<tr><td><code id="sgdgmf.rank_+3A_return.mu">return.mu</code></td>
<td>
<p>if <code>TRUE</code>, return the fitted value martix</p>
</td></tr>
<tr><td><code id="sgdgmf.rank_+3A_return.res">return.res</code></td>
<td>
<p>if <code>TRUE</code>, return the residual matrix</p>
</td></tr>
<tr><td><code id="sgdgmf.rank_+3A_return.cov">return.cov</code></td>
<td>
<p>if <code>TRUE</code>, return the covariance matrix of the residuals</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the <code>method</code>, the selected latent rank <code>ncomp</code>,
and the eigenvalues used to select the latent rank <code>lambdas</code>.
Additionally, if required, in the output list will also provide the linear predictor
<code>eta</code>, the predicted mean matrix <code>mu</code>, the residual matrix <code>res</code>, and
the implied residual covariance matrix <code>covmat</code>.
</p>


<h3>References</h3>

<p>Onatski, A. (2010).
<em>Determining the number of factors from empirical distribution of eigenvalues.</em>
Review of Economics and Statistics, 92(4): 1004-1016
</p>
<p>Gavish, M., Donoho, D.L. (2014)
<em>The optimal hard thresholding for singular values is 4/sqrt(3).</em>
IEEE Transactions on Information Theory, 60(8): 5040&ndash;5053
</p>
<p>Fan, J., Guo, J. and Zheng, S. (2020).
<em>Estimating number of factors by adjusted eigenvalues thresholding.</em>
Journal of the American Statistical Association, 117(538): 852&ndash;861
</p>
<p>Wang, L. and Carvalho, L. (2023).
<em>Deviance matrix factorization.</em>
Electronic Journal of Statistics, 17(2): 3762-3810
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sgdGMF)

# Set the data dimensions
n = 100; m = 20; d = 5

# Generate data using Poisson, Binomial and Gamma models
data_pois = sim.gmf.data(n = n, m = m, ncomp = d, family = poisson())
data_bin = sim.gmf.data(n = n, m = m, ncomp = d, family = binomial())
data_gam = sim.gmf.data(n = n, m = m, ncomp = d, family = Gamma(link = "log"), dispersion = 0.25)

# Initialize the GMF parameters assuming 3 latent factors
ncomp_pois = sgdgmf.rank(data_pois$Y, family = poisson(), normalize = TRUE)
ncomp_bin = sgdgmf.rank(data_bin$Y, family = binomial(), normalize = TRUE)
ncomp_gam = sgdgmf.rank(data_gam$Y, family = Gamma(link = "log"), normalize = TRUE)

# Get the selected number of components
print(paste("Poisson:", ncomp_pois$ncomp))
print(paste("Binomial:", ncomp_bin$ncomp))
print(paste("Gamma:", ncomp_gam$ncomp))

# Plot the screeplot used for the component determination
oldpar = par(no.readonly = TRUE)
par(mfrow = c(3,1))
barplot(ncomp_pois$lambdas, main = "Poisson screeplot")
barplot(ncomp_bin$lambdas, main = "Binomial screeplot")
barplot(ncomp_gam$lambdas, main = "Gamma screeplot")
par(oldpar)

</code></pre>

<hr>
<h2 id='sim.gmf.data'>Simulate non-Gaussian data from a GMF model</h2><span id='topic+sim.gmf.data'></span>

<h3>Description</h3>

<p>Simulate synthetic non-Gaussian data from a generalized matrix factorization (GMF) model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.gmf.data(n = 100, m = 20, ncomp = 5, family = gaussian(), dispersion = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim.gmf.data_+3A_n">n</code></td>
<td>
<p>number of observations</p>
</td></tr>
<tr><td><code id="sim.gmf.data_+3A_m">m</code></td>
<td>
<p>number of variables</p>
</td></tr>
<tr><td><code id="sim.gmf.data_+3A_ncomp">ncomp</code></td>
<td>
<p>rank of the latent matrix factorization</p>
</td></tr>
<tr><td><code id="sim.gmf.data_+3A_family">family</code></td>
<td>
<p>a <code>glm</code> family (see <code><a href="stats.html#topic+family">family</a></code> for more details)</p>
</td></tr>
<tr><td><code id="sim.gmf.data_+3A_dispersion">dispersion</code></td>
<td>
<p>a positive dispersion parameter</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The loadings, <code>V</code>, are independently sampled from a standard normal distribution.
The scores, <code>U</code>, are simulated according to sinusoidal signals evaluated at different
phases, frequencies and amplitudes. These parameters are randomly sampled from independent
uniform distributions.
</p>


<h3>Value</h3>

<p>A list containing the following objects:
</p>

<ul>
<li> <p><code>Y</code>: simulated response matrix
</p>
</li>
<li> <p><code>U</code>: simulated factor matrix
</p>
</li>
<li> <p><code>V</code>: simulated loading matrix
</p>
</li>
<li> <p><code>eta</code>: linear predictor matrix
</p>
</li>
<li> <p><code>mu</code>: conditional mean matrix
</p>
</li>
<li> <p><code>phi</code>: scalar dispersion parameter
</p>
</li>
<li> <p><code>family</code>: model family
</p>
</li>
<li> <p><code>ncomp</code>: rank of the latent matrix factorization
</p>
</li>
<li> <p><code>param</code>: a list containing time, phase, frequency and amplitude vectors used to generate <code>U</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(sgdGMF)

# Set the data dimensions
n = 100; m = 20; d = 5

# Generate data using Poisson, Binomial and Gamma models
data_pois = sim.gmf.data(n = n, m = m, ncomp = d, family = poisson())
data_bin = sim.gmf.data(n = n, m = m, ncomp = d, family = binomial())
data_gam = sim.gmf.data(n = n, m = m, ncomp = d, family = Gamma(link = "log"), dispersion = 0.25)

# Compare the results
oldpar = par(no.readonly = TRUE)
par(mfrow = c(3,3), mar = c(1,1,3,1))
image(data_pois$Y, axes = FALSE, main = expression(Y[Pois]))
image(data_pois$mu, axes = FALSE, main = expression(mu[Pois]))
image(data_pois$U, axes = FALSE, main = expression(U[Pois]))
image(data_bin$Y, axes = FALSE, main = expression(Y[Bin]))
image(data_bin$mu, axes = FALSE, main = expression(mu[Bin]))
image(data_bin$U, axes = FALSE, main = expression(U[Bin]))
image(data_gam$Y, axes = FALSE, main = expression(Y[Gam]))
image(data_gam$mu, axes = FALSE, main = expression(mu[Gam]))
image(data_gam$U, axes = FALSE, main = expression(U[Gam]))
par(oldpar)

</code></pre>

<hr>
<h2 id='simulate'>Simulate new data</h2><span id='topic+simulate'></span>

<h3>Description</h3>

<p>Generic function to simulate new data from a statistical model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate_+3A_object">object</code></td>
<td>
<p>an object from which simulate new data</p>
</td></tr>
<tr><td><code id="simulate_+3A_...">...</code></td>
<td>
<p>additional arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array containing the simulated data.
</p>

<hr>
<h2 id='simulate.sgdgmf'>Simulate method for GMF models</h2><span id='topic+simulate.sgdgmf'></span>

<h3>Description</h3>

<p>Simulate new data from a fitted generalized matrix factorization models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sgdgmf'
simulate(object, ..., nsim = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate.sgdgmf_+3A_object">object</code></td>
<td>
<p>an object of class <code>sgdgmf</code></p>
</td></tr>
<tr><td><code id="simulate.sgdgmf_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="simulate.sgdgmf_+3A_nsim">nsim</code></td>
<td>
<p>number of samples</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An 3-fold array containing the simulated data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the sgdGMF package
library(sgdGMF)

# Generate data from a Poisson model
data = sim.gmf.data(n = 100, m = 20, ncomp = 5, family = poisson())

# Fit a GMF model
gmf = sgdgmf.fit(data$Y, ncomp = 3, family = poisson())

# Simulate new data from a GMF model
str(simulate(gmf))

</code></pre>

<hr>
<h2 id='vglm.fit.coef'>Estimate the coefficients of a vector generalized linear model</h2><span id='topic+vglm.fit.coef'></span>

<h3>Description</h3>

<p>Estimate the coefficients of a vector generalized linear model via parallel
iterative re-weighted least squares. Computations can be performed in parallel
to speed up the execution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vglm.fit.coef(
  Y,
  X,
  family = gaussian(),
  weights = NULL,
  offset = NULL,
  parallel = FALSE,
  nthreads = 1,
  clust = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vglm.fit.coef_+3A_y">Y</code></td>
<td>
<p><code class="reqn">n \times m</code> matrix of response variables</p>
</td></tr>
<tr><td><code id="vglm.fit.coef_+3A_x">X</code></td>
<td>
<p><code class="reqn">n \times p</code> matrix of covariates</p>
</td></tr>
<tr><td><code id="vglm.fit.coef_+3A_family">family</code></td>
<td>
<p>a <code>glm</code> family (see <code><a href="stats.html#topic+family">family</a></code> for more details)</p>
</td></tr>
<tr><td><code id="vglm.fit.coef_+3A_weights">weights</code></td>
<td>
<p><code class="reqn">n \times m</code> matrix of weighting values</p>
</td></tr>
<tr><td><code id="vglm.fit.coef_+3A_offset">offset</code></td>
<td>
<p><code class="reqn">n \times m</code> matrix of offset values</p>
</td></tr>
<tr><td><code id="vglm.fit.coef_+3A_parallel">parallel</code></td>
<td>
<p>if <code>TRUE</code>, allows for parallel computing using the <code>foreach</code> package</p>
</td></tr>
<tr><td><code id="vglm.fit.coef_+3A_nthreads">nthreads</code></td>
<td>
<p>number of cores to be used in parallel (only if <code>parallel=TRUE</code>)</p>
</td></tr>
<tr><td><code id="vglm.fit.coef_+3A_clust">clust</code></td>
<td>
<p>registered cluster to be used for distributing the computations (only if <code>parallel=TRUE</code>)</p>
</td></tr>
</table>

<hr>
<h2 id='whitening.matrix'>Compute the whitening matrix from a given covariance matrix</h2><span id='topic+whitening.matrix'></span>

<h3>Description</h3>

<p>Compute the whitening matrix from a given covariance matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>whitening.matrix(
  sigma,
  method = c("ZCA", "ZCA-cor", "PCA", "PCA-cor", "Cholesky")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="whitening.matrix_+3A_sigma">sigma</code></td>
<td>
<p>covariance matrix.</p>
</td></tr>
<tr><td><code id="whitening.matrix_+3A_method">method</code></td>
<td>
<p>determines the type of whitening transformation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is an internal re-implementation of the function <code>whiteningMatrix</code>
in the <code>whitening</code> package. See the original documentation to get more details.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
