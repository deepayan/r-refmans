<!DOCTYPE html><html><head><title>Help for package coala</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {coala}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#coala-package'><p>A Framework for Coalescent Simulation in R</p></a></li>
<li><a href='#+2B.coalmodelpart'><p>Add a feature or parameter to a model</p></a></li>
<li><a href='#as.segsites'><p>Convert genetic data to coala's internal format</p></a></li>
<li><a href='#as.segsites.GENOME'><p>Convert PopGenome Data into Coala's Format</p></a></li>
<li><a href='#calc_jsfs'><p>Calculates the Joint Site Frequency Spectrum</p></a></li>
<li><a href='#calc_sumstats_from_data'><p>Calculate summary statistics for biological data</p></a></li>
<li><a href='#check_model'><p>Check which simulator can simulate a model</p></a></li>
<li><a href='#coal_model'><p>Create a Coalescent Model</p></a></li>
<li><a href='#conv_to_ms_arg.growth'><p>Generate command line arguments for features</p></a></li>
<li><a href='#create_abc_param'><p>Convert Simulation Results to abc's Parameter Format</p></a></li>
<li><a href='#create_abc_sumstat'><p>Convert Simulation Results to abc's Summary Statistic Format</p></a></li>
<li><a href='#create_segsites'><p>Segregating Sites</p></a></li>
<li><a href='#feat_growth'><p>Feature: Exponential population size growth/decline</p></a></li>
<li><a href='#feat_ignore_singletons'><p>Feature: Ignore Singletons</p></a></li>
<li><a href='#feat_migration'><p>Feature: Migration/Gene Flow</p></a></li>
<li><a href='#feat_mutation'><p>Feature: Mutation</p></a></li>
<li><a href='#feat_outgroup'><p>Feature: Outgroup</p></a></li>
<li><a href='#feat_pop_merge'><p>Feature: Population Merge</p></a></li>
<li><a href='#feat_recombination'><p>Feature: Recombination</p></a></li>
<li><a href='#feat_sample'><p>Creates a feature that represents the sampling from one population</p></a></li>
<li><a href='#feat_selection'><p>Feature: Selection</p></a></li>
<li><a href='#feat_size_change'><p>Feature: Instantaneous Size Change</p></a></li>
<li><a href='#feat_unphased'><p>Feature: Unphased Sequences</p></a></li>
<li><a href='#get_outgroup'><p>Getters for coalescent models</p></a></li>
<li><a href='#list_simulators'><p>Returns the available simulators</p></a></li>
<li><a href='#locus'><p>Loci</p></a></li>
<li><a href='#locus_trio'><p>Locus Trios</p></a></li>
<li><a href='#par_variation'><p>Variable Parameters</p></a></li>
<li><a href='#par_zero_inflation'><p>Zero Inflation for Parameters</p></a></li>
<li><a href='#parameter'><p>Model Parameters</p></a></li>
<li><a href='#scale_model'><p>Function that downscales a coalescent model</p></a></li>
<li><a href='#search_executable'><p>Search the working directory and the run path for an executable</p></a></li>
<li><a href='#simulate.coalmodel'><p>Simulate Data According to a Demographic Model</p></a></li>
<li><a href='#simulator_ms'><p>Simulator: ms</p></a></li>
<li><a href='#simulator_msms'><p>Simulator: msms</p></a></li>
<li><a href='#simulator_scrm'><p>Simulator: scrm</p></a></li>
<li><a href='#simulator_seqgen'><p>Simulator: seq-gen</p></a></li>
<li><a href='#sumstat_class'><p>Base Class for Summary Statistics</p></a></li>
<li><a href='#sumstat_dna'><p>Summary Statistic: DNA</p></a></li>
<li><a href='#sumstat_file'><p>Summary Statistic: Files</p></a></li>
<li><a href='#sumstat_four_gamete'><p>Summary Statistic: Four-Gamete-Condition</p></a></li>
<li><a href='#sumstat_ihh'><p>Summary Statistic: Integrated Extended Haplotype Homozygosity</p></a></li>
<li><a href='#sumstat_jsfs'><p>Summary Statistic: Joint Site Frequency Spectrum</p></a></li>
<li><a href='#sumstat_mcmf'><p>Summary Statistic: Most Common Mutation's Frequency</p></a></li>
<li><a href='#sumstat_nucleotide_div'><p>Summary Statistic: Nucleotide Diversity</p></a></li>
<li><a href='#sumstat_omega'><p>Summary Statistic: Omega</p></a></li>
<li><a href='#sumstat_seg_sites'><p>Summary Statistic: Segregating Sites</p></a></li>
<li><a href='#sumstat_sfs'><p>Summary Statistic: Site Frequency Spectrum</p></a></li>
<li><a href='#sumstat_tajimas_d'><p>Summary Statistic: Tajima's D</p></a></li>
<li><a href='#sumstat_trees'><p>Summary Statistic: Ancestral Trees</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.7.2</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Title:</td>
<td>A Framework for Coalescent Simulation</td>
</tr>
<tr>
<td>Author:</td>
<td>Paul Staab [aut],
  Dirk Metzler [aut, ths, cre],
  Jorge E. Amaya Romero [ctb]</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/statgenlmu/coala/issues">https://github.com/statgenlmu/coala/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/statgenlmu/coala">https://github.com/statgenlmu/coala</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Coalescent simulators can rapidly simulate biological sequences
    evolving according to a given model of evolution.
    You can use this package to specify such models, to conduct the simulations
    and to calculate additional statistics from the results (Staab, Metzler,
    2016 &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtw098">doi:10.1093/bioinformatics/btw098</a>&gt;).
    It relies on existing simulators for doing the simulation, and currently
    supports the programs 'ms', 'msms' and 'scrm'. It also supports finite-sites
    mutation models by combining the simulators with the program 'seq-gen'.
    Coala provides functions for calculating certain summary statistics, which
    can also be applied to actual biological data.
    One possibility to import data is through the 'PopGenome' package
    (<a href="https://github.com/pievos101/PopGenome">https://github.com/pievos101/PopGenome</a>).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>assertthat (&ge; 0.1), digest, methods, parallel, R6 (&ge; 2.0.1),
Rcpp (&ge; 0.11.0), rehh (&ge; 3.0.0), scrm (&ge; 1.6.0-2), stats,
utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>abc (&ge; 2.0), knitr, PopGenome (&ge; 2.1.0), phyclust (&ge;
0.1-16), rmarkdown, testthat (&ge; 0.11.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo (&ge; 0.3.810.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Collate:</td>
<td>'RcppExports.R' 'cache.R' 'coala.R' 'model.R' 'feature.R'
'feature_growth.R' 'feature_ignore_singletons.R'
'feature_migration.R' 'feature_mutation.R' 'feature_outgroup.R'
'feature_pop_merge.R' 'feature_recombination.R'
'feature_sample.R' 'feature_selection.R'
'feature_size_change.R' 'feature_sumstats.R'
'feature_unphased.R' 'import_popgenome.R' 'interface_abc.R'
'locus.R' 'model_build.R' 'model_check.R' 'model_examples.R'
'model_getters.R' 'model_print.R' 'model_scale.R'
'model_simulate.R' 'onLoad.R' 'parameter.R' 'parameter_prior.R'
'parameter_variation.R' 'parameter_zero_inflation.R'
'search_executable.R' 'segsites.R' 'simulation_tasks.R'
'simulator_class.R' 'simulator_ms.R' 'simulator_msms.R'
'simulator_scrm.R' 'simulator_seqgen.R' 'sumstat.R'
'sumstat_dna.R' 'sumstat_file.R' 'sumstat_four_gamete.R'
'sumstat_ihh.R' 'sumstat_jsfs.R' 'sumstat_mcmf.R'
'sumstat_nucleotide_div.R' 'sumstat_omega.R'
'sumstat_seg_sites.R' 'sumstat_sfs.R' 'sumstat_tajimas_d.R'
'sumstat_trees.R' 'tools.R'</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-04 14:51:03 UTC; dirk</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dirk Metzler &lt;metzler@bio.lmu.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-04 16:20:17 UTC</td>
</tr>
</table>
<hr>
<h2 id='coala-package'>A Framework for Coalescent Simulation in R</h2><span id='topic+coala'></span><span id='topic+coala-package'></span>

<h3>Description</h3>

<p>This package allows to specify and simulate coalescent models from
within R. The <code>introduction</code> vignette is a good place to start.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Dirk Metzler <a href="mailto:metzler@bio.lmu.de">metzler@bio.lmu.de</a> [thesis advisor]
</p>
<p>Authors:
</p>

<ul>
<li><p> Paul Staab <a href="mailto:develop@paulstaab.de">develop@paulstaab.de</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Jorge E. Amaya Romero [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/statgenlmu/coala">https://github.com/statgenlmu/coala</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/statgenlmu/coala/issues">https://github.com/statgenlmu/coala/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+2B.coalmodelpart'>Add a feature or parameter to a model</h2><span id='topic++2B.coalmodelpart'></span>

<h3>Description</h3>

<p>Add a feature or parameter to a model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coalmodelpart'
e1 + e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B2B.coalmodelpart_+3A_e1">e1</code></td>
<td>
<p>The Model to which the feature/parameter should be added</p>
</td></tr>
<tr><td><code id="+2B2B.coalmodelpart_+3A_e2">e2</code></td>
<td>
<p>The feature/parameter to add</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The extended model
</p>

<hr>
<h2 id='as.segsites'>Convert genetic data to coala's internal format</h2><span id='topic+as.segsites'></span>

<h3>Description</h3>

<p>This function can be used to convert the genomic data formats used in other
packages to calculate coala's segregating sites object. This is useful for
calculating the summary statistics of biological data using the
<code><a href="#topic+calc_sumstats_from_data">calc_sumstats_from_data</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.segsites(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.segsites_+3A_data">data</code></td>
<td>
<p>The data object that is converted.</p>
</td></tr>
<tr><td><code id="as.segsites_+3A_...">...</code></td>
<td>
<p>Additional arguments specific for the used package.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, only the package <span class="pkg">PopGenome</span> is supported, see
<code><a href="#topic+as.segsites.GENOME">as.segsites.GENOME</a></code> for details.
</p>


<h3>Value</h3>

<p>A list of segregating sites objects.
</p>


<h3>See Also</h3>

<p>Further instructions are provided in the <code>coala-data-import</code> vignette
</p>
<p>For information about segsites: <code><a href="#topic+segsites">segsites</a></code>
</p>

<hr>
<h2 id='as.segsites.GENOME'>Convert PopGenome Data into Coala's Format</h2><span id='topic+as.segsites.GENOME'></span>

<h3>Description</h3>

<p>Using this function, you can convert genetic data imported with the package
<span class="pkg">PopGenome</span> into coala's segsites format. See <code><a href="#topic+as.segsites">as.segsites</a></code>
for general information on converting genetic data for coala.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GENOME'
as.segsites(data, only_synonymous = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.segsites.GENOME_+3A_data">data</code></td>
<td>
<p>The <code>GENOME</code> data from <span class="pkg">PopGenome</span>.</p>
</td></tr>
<tr><td><code id="as.segsites.GENOME_+3A_only_synonymous">only_synonymous</code></td>
<td>
<p>Only import synonymous SNPs if set to <code>TRUE</code>.
This requires that <span class="pkg">PopGenome</span> knows where coding regions are., e.g.
by using gff files.</p>
</td></tr>
<tr><td><code id="as.segsites.GENOME_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function imports all loci from the <code>GENOME</code> object that have at
least one valid site (<code>data@n.valid.sites</code>). The number of valid sites
is used as length of a locus.
</p>


<h3>See Also</h3>

<p>An example and additional instructions are provided in the
<code>coala-data-import</code> vignette
</p>

<hr>
<h2 id='calc_jsfs'>Calculates the Joint Site Frequency Spectrum</h2><span id='topic+calc_jsfs'></span>

<h3>Description</h3>

<p>Calculates the Joint Site Frequency Spectrum
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_jsfs(segsites_list, ind_per_pop)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_jsfs_+3A_segsites_list">segsites_list</code></td>
<td>
<p>List of segregating sites</p>
</td></tr>
<tr><td><code id="calc_jsfs_+3A_ind_per_pop">ind_per_pop</code></td>
<td>
<p>A list of integer vector, where each entry gives the
index of the haploids that belong the corresponding population.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Joint Site Frequency Spectrum, as a matrix.
</p>


<h3>Author(s)</h3>

<p>Paul Staab &amp; Dirk Metzler
</p>

<hr>
<h2 id='calc_sumstats_from_data'>Calculate summary statistics for biological data</h2><span id='topic+calc_sumstats_from_data'></span>

<h3>Description</h3>

<p>This function calculates a model's summary statistic from biological data.
The data needs to be provided as a list of segregating sites objects. These
objects can be create using the <code><a href="#topic+create_segsites">create_segsites</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_sumstats_from_data(
  model,
  segsites_list = NULL,
  tree_list = NULL,
  trios = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_sumstats_from_data_+3A_model">model</code></td>
<td>
<p>The coala model. The summary statistics present in this model
will be calculated. The model should fit to the data, in particular
regarding the number of loci and haploids.</p>
</td></tr>
<tr><td><code id="calc_sumstats_from_data_+3A_segsites_list">segsites_list</code></td>
<td>
<p>Either a list of <code>segsites</code> objects, or an object
that can be converted using <code><a href="#topic+as.segsites">as.segsites</a></code>. It is possible
to specify additional argument for the conversion using the <code>...</code>
argument.</p>
</td></tr>
<tr><td><code id="calc_sumstats_from_data_+3A_tree_list">tree_list</code></td>
<td>
<p>Not yet implemented.</p>
</td></tr>
<tr><td><code id="calc_sumstats_from_data_+3A_trios">trios</code></td>
<td>
<p>If your model is using locus trios, then you
can create these by combining individual loci. This is a list that defines
which loci are combined to a trio. Each entry should consist of either
one or three numbers. For one number, the locus used for calculating the
summary statistics is locus in the provided data that corresponds to the
number. If three numbers are provided, the locus for calculation is created
by combining the corresponding three loci from the given data.</p>
</td></tr>
<tr><td><code id="calc_sumstats_from_data_+3A_...">...</code></td>
<td>
<p>Additional arguments that will be passed to
<code><a href="#topic+as.segsites">as.segsites</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>segsites &lt;- create_segsites(matrix(c(1, 0, 0,
                                     1, 1, 0,
                                     0, 0, 1), 3, 3, TRUE),
                            c(.1, .3, .5))
model &lt;- coal_model(3, 1) +
  sumstat_sfs() +
  sumstat_nucleotide_div() +
  sumstat_mcmf()
sumstats &lt;- calc_sumstats_from_data(model, list(segsites))
print(sumstats)
</code></pre>

<hr>
<h2 id='check_model'>Check which simulator can simulate a model</h2><span id='topic+check_model'></span>

<h3>Description</h3>

<p>This function checks which of the available simulators can
simulate a given model. It also states the problems for the ones that
are incompatible with the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_model(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_model_+3A_model">model</code></td>
<td>
<p>The model which is checked</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Do view the priority of the simulators: <code><a href="#topic+list_simulators">list_simulators</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- coal_model(10, 1) +
  feat_mutation(5, fixed = TRUE)
check_model(model)
</code></pre>

<hr>
<h2 id='coal_model'>Create a Coalescent Model</h2><span id='topic+coal_model'></span><span id='topic+coalmodelpart'></span>

<h3>Description</h3>

<p>This creates a basic coalescent model to which more features, loci,
parameters and summary statistics can be added later. Data under the model
can be simulated using the <code><a href="#topic+simulate.coalmodel">simulate</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coal_model(sample_size, loci_number = 0, loci_length = 1000, ploidy = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coal_model_+3A_sample_size">sample_size</code></td>
<td>
<p>Defines the number of populations and the number of
individual sampled from each population. Given as an integer vector where
each entry gives the number of individuals sampled from the corresponding
population.</p>
</td></tr>
<tr><td><code id="coal_model_+3A_loci_number">loci_number</code></td>
<td>
<p>You can optionally add a number of loci with equal length
to the model. This gives to number of loci to add.</p>
</td></tr>
<tr><td><code id="coal_model_+3A_loci_length">loci_length</code></td>
<td>
<p>This gives the length of the loci to add.</p>
</td></tr>
<tr><td><code id="coal_model_+3A_ploidy">ploidy</code></td>
<td>
<p>The number of chromosomes that will be simulated per
individual.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The basic coalescent model which can be extended with features,
parameters, loci and summary statistics.
</p>


<h3>See Also</h3>

<p>The 'coala-intro' vignette for a general description on how to extend
models.
</p>
<p>For checking which simulators can be used for this model:
<code><a href="#topic+check_model">check_model</a></code>
</p>
<p>For adding mutation or for a list of other features:
<code><a href="#topic+feat_mutation">feat_mutation</a></code>
</p>
<p>For adding loci: <code><a href="#topic+locus_single">locus_single</a></code>,
<code><a href="#topic+locus_averaged">locus_averaged</a></code>, <code><a href="#topic+locus_trio">locus_trio</a></code>
</p>
<p>For a generating DNA sequences or for a list of summary statistics:
<code><a href="#topic+sumstat_dna">sumstat_dna</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A model with one population and 20 unlinked loci:
model &lt;- coal_model(10, 20) +
  feat_mutation(5) +
  sumstat_tajimas_d()
check_model(model)
simulate(model)

# A model with two populations:
model &lt;- coal_model(c(13, 18), 5) +
  feat_migration(.5, symmetric = TRUE) +
  sumstat_trees()
check_model(model)
simulate(model)

# A model with 10 populations:
model &lt;- coal_model(rep(2, 10), 5) +
  feat_migration(.5, symmetric = TRUE) +
  sumstat_trees()
check_model(model)
simulate(model)

# A model with recombination:
model &lt;- coal_model(20, 1, 1000) +
  feat_recombination(10) +
  feat_mutation(5) +
  sumstat_four_gamete()
check_model(model)
simulate(model)
</code></pre>

<hr>
<h2 id='conv_to_ms_arg.growth'>Generate command line arguments for features</h2><span id='topic+conv_to_ms_arg.growth'></span><span id='topic+conv_to_msms_arg.growth'></span><span id='topic+conv_to_scrm_arg.growth'></span><span id='topic+conv_to_seqgen_arg.growth'></span><span id='topic+conv_to_ms_arg.ign_singletons'></span><span id='topic+conv_to_msms_arg.ign_singletons'></span><span id='topic+conv_to_scrm_arg.ign_singletons'></span><span id='topic+conv_to_seqgen_arg.ign_singletons'></span><span id='topic+conv_to_ms_arg.migration'></span><span id='topic+conv_to_msms_arg.migration'></span><span id='topic+conv_to_scrm_arg.migration'></span><span id='topic+conv_to_seqgen_arg.migration'></span><span id='topic+conv_to_ms_arg.mutation'></span><span id='topic+conv_to_msms_arg.mutation'></span><span id='topic+conv_to_scrm_arg.mutation'></span><span id='topic+conv_to_seqgen_arg.mutation'></span><span id='topic+conv_to_ms_arg.outgroup'></span><span id='topic+conv_to_msms_arg.outgroup'></span><span id='topic+conv_to_scrm_arg.outgroup'></span><span id='topic+conv_to_seqgen_arg.outgroup'></span><span id='topic+conv_to_ms_arg.pop_merge'></span><span id='topic+conv_to_msms_arg.pop_merge'></span><span id='topic+conv_to_scrm_arg.pop_merge'></span><span id='topic+conv_to_seqgen_arg.pop_merge'></span><span id='topic+conv_to_ms_arg.recombination'></span><span id='topic+conv_to_msms_arg.recombination'></span><span id='topic+conv_to_scrm_arg.recombination'></span><span id='topic+conv_to_seqgen_arg.recombination'></span><span id='topic+conv_to_ms_arg.sample'></span><span id='topic+conv_to_msms_arg.sample'></span><span id='topic+conv_to_scrm_arg.sample'></span><span id='topic+conv_to_seqgen_arg.sample'></span><span id='topic+conv_to_ms_arg.selection'></span><span id='topic+conv_to_scrm_arg.selection'></span><span id='topic+conv_to_msms_arg.selection'></span><span id='topic+conv_to_seqgen_arg.selection'></span><span id='topic+conv_to_ms_arg.size_change'></span><span id='topic+conv_to_msms_arg.size_change'></span><span id='topic+conv_to_scrm_arg.size_change'></span><span id='topic+conv_to_seqgen_arg.size_change'></span><span id='topic+conv_to_ms_arg.seg_sites_feat'></span><span id='topic+conv_to_msms_arg.seg_sites_feat'></span><span id='topic+conv_to_scrm_arg.seg_sites_feat'></span><span id='topic+conv_to_seqgen_arg.seg_sites_feat'></span><span id='topic+conv_to_ms_arg.trees_feat'></span><span id='topic+conv_to_msms_arg.trees_feat'></span><span id='topic+conv_to_scrm_arg.trees_feat'></span><span id='topic+conv_to_seqgen_arg.trees_feat'></span><span id='topic+conv_to_ms_arg.files_feat'></span><span id='topic+conv_to_msms_arg.files_feat'></span><span id='topic+conv_to_scrm_arg.files_feat'></span><span id='topic+conv_to_seqgen_arg.files_feat'></span><span id='topic+conv_to_ms_arg.unphased'></span><span id='topic+conv_to_msms_arg.unphased'></span><span id='topic+conv_to_scrm_arg.unphased'></span><span id='topic+conv_to_seqgen_arg.unphased'></span><span id='topic+conv_to_ms_arg'></span><span id='topic+conv_to_ms_arg.default'></span><span id='topic+conv_to_msms_arg.default'></span><span id='topic+conv_to_scrm_arg.default'></span><span id='topic+conv_to_seqgen_arg.default'></span>

<h3>Description</h3>

<p>These functions are exported only for technical reasons
(because they are S3 methods) and are not intended for
users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'growth'
conv_to_ms_arg(feature, model)

## S3 method for class 'growth'
conv_to_msms_arg(feature, model)

## S3 method for class 'growth'
conv_to_scrm_arg(feature, model)

## S3 method for class 'growth'
conv_to_seqgen_arg(feature, model)

## S3 method for class 'ign_singletons'
conv_to_ms_arg(feature, model)

## S3 method for class 'ign_singletons'
conv_to_msms_arg(feature, model)

## S3 method for class 'ign_singletons'
conv_to_scrm_arg(feature, model)

## S3 method for class 'ign_singletons'
conv_to_seqgen_arg(feature, model)

## S3 method for class 'migration'
conv_to_ms_arg(feature, model)

## S3 method for class 'migration'
conv_to_msms_arg(feature, model)

## S3 method for class 'migration'
conv_to_scrm_arg(feature, model)

## S3 method for class 'migration'
conv_to_seqgen_arg(feature, model)

## S3 method for class 'mutation'
conv_to_ms_arg(feature, model)

## S3 method for class 'mutation'
conv_to_msms_arg(feature, model)

## S3 method for class 'mutation'
conv_to_scrm_arg(feature, model)

## S3 method for class 'mutation'
conv_to_seqgen_arg(feature, model)

## S3 method for class 'outgroup'
conv_to_ms_arg(feature, model)

## S3 method for class 'outgroup'
conv_to_msms_arg(feature, model)

## S3 method for class 'outgroup'
conv_to_scrm_arg(feature, model)

## S3 method for class 'outgroup'
conv_to_seqgen_arg(feature, model)

## S3 method for class 'pop_merge'
conv_to_ms_arg(feature, model)

## S3 method for class 'pop_merge'
conv_to_msms_arg(feature, model)

## S3 method for class 'pop_merge'
conv_to_scrm_arg(feature, model)

## S3 method for class 'pop_merge'
conv_to_seqgen_arg(feature, model)

## S3 method for class 'recombination'
conv_to_ms_arg(feature, model)

## S3 method for class 'recombination'
conv_to_msms_arg(feature, model)

## S3 method for class 'recombination'
conv_to_scrm_arg(feature, model)

## S3 method for class 'recombination'
conv_to_seqgen_arg(feature, model)

## S3 method for class 'sample'
conv_to_ms_arg(feature, model)

## S3 method for class 'sample'
conv_to_msms_arg(feature, model)

## S3 method for class 'sample'
conv_to_scrm_arg(feature, model)

## S3 method for class 'sample'
conv_to_seqgen_arg(feature, model)

## S3 method for class 'selection'
conv_to_ms_arg(feature, model)

## S3 method for class 'selection'
conv_to_scrm_arg(feature, model)

## S3 method for class 'selection'
conv_to_msms_arg(feature, model)

## S3 method for class 'selection'
conv_to_seqgen_arg(feature, model)

## S3 method for class 'size_change'
conv_to_ms_arg(feature, model)

## S3 method for class 'size_change'
conv_to_msms_arg(feature, model)

## S3 method for class 'size_change'
conv_to_scrm_arg(feature, model)

## S3 method for class 'size_change'
conv_to_seqgen_arg(feature, model)

## S3 method for class 'seg_sites_feat'
conv_to_ms_arg(feature, model)

## S3 method for class 'seg_sites_feat'
conv_to_msms_arg(feature, model)

## S3 method for class 'seg_sites_feat'
conv_to_scrm_arg(feature, model)

## S3 method for class 'seg_sites_feat'
conv_to_seqgen_arg(feature, model)

## S3 method for class 'trees_feat'
conv_to_ms_arg(feature, model)

## S3 method for class 'trees_feat'
conv_to_msms_arg(feature, model)

## S3 method for class 'trees_feat'
conv_to_scrm_arg(feature, model)

## S3 method for class 'trees_feat'
conv_to_seqgen_arg(feature, model)

## S3 method for class 'files_feat'
conv_to_ms_arg(feature, model)

## S3 method for class 'files_feat'
conv_to_msms_arg(feature, model)

## S3 method for class 'files_feat'
conv_to_scrm_arg(feature, model)

## S3 method for class 'files_feat'
conv_to_seqgen_arg(feature, model)

## S3 method for class 'unphased'
conv_to_ms_arg(feature, model)

## S3 method for class 'unphased'
conv_to_msms_arg(feature, model)

## S3 method for class 'unphased'
conv_to_scrm_arg(feature, model)

## S3 method for class 'unphased'
conv_to_seqgen_arg(feature, model)

conv_to_ms_arg(feature, model)

## Default S3 method:
conv_to_ms_arg(feature, model)

## Default S3 method:
conv_to_msms_arg(feature, model)

## Default S3 method:
conv_to_scrm_arg(feature, model)

## Default S3 method:
conv_to_seqgen_arg(feature, model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conv_to_ms_arg.growth_+3A_feature">feature</code></td>
<td>
<p>The feature for which the argument is generated</p>
</td></tr>
<tr><td><code id="conv_to_ms_arg.growth_+3A_model">model</code></td>
<td>
<p>The complete model for which the argument is generated</p>
</td></tr>
</table>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>conv_to_ms_arg(growth)</code>: Feature conversion
</p>
</li>
<li> <p><code>conv_to_ms_arg(ign_singletons)</code>: Feature conversion
</p>
</li>
<li> <p><code>conv_to_ms_arg(migration)</code>: Feature conversion
</p>
</li>
<li> <p><code>conv_to_ms_arg(mutation)</code>: Feature conversion
</p>
</li>
<li> <p><code>conv_to_ms_arg(outgroup)</code>: Feature conversion
</p>
</li>
<li> <p><code>conv_to_ms_arg(pop_merge)</code>: Feature conversion
</p>
</li>
<li> <p><code>conv_to_ms_arg(recombination)</code>: Feature conversion
</p>
</li>
<li> <p><code>conv_to_ms_arg(sample)</code>: Feature conversion
</p>
</li>
<li> <p><code>conv_to_ms_arg(selection)</code>: Feature conversion
</p>
</li>
<li> <p><code>conv_to_ms_arg(size_change)</code>: Feature conversion
</p>
</li>
<li> <p><code>conv_to_ms_arg(seg_sites_feat)</code>: Feature conversion
</p>
</li>
<li> <p><code>conv_to_ms_arg(trees_feat)</code>: Feature conversion
</p>
</li>
<li> <p><code>conv_to_ms_arg(files_feat)</code>: Feature conversion
</p>
</li>
<li> <p><code>conv_to_ms_arg(unphased)</code>: Feature conversion
</p>
</li>
<li> <p><code>conv_to_ms_arg(default)</code>: Feature conversion
</p>
</li></ul>


<h3>Functions</h3>


<ul>
<li> <p><code>conv_to_msms_arg(growth)</code>: Feature conversion
</p>
</li>
<li> <p><code>conv_to_scrm_arg(growth)</code>: Feature conversion
</p>
</li>
<li> <p><code>conv_to_seqgen_arg(growth)</code>: Feature conversion
</p>
</li>
<li> <p><code>conv_to_msms_arg(ign_singletons)</code>: Feature conversion
</p>
</li>
<li> <p><code>conv_to_scrm_arg(ign_singletons)</code>: Feature conversion
</p>
</li>
<li> <p><code>conv_to_seqgen_arg(ign_singletons)</code>: Feature conversion
</p>
</li>
<li> <p><code>conv_to_msms_arg(migration)</code>: Feature conversion
</p>
</li>
<li> <p><code>conv_to_scrm_arg(migration)</code>: Feature conversion
</p>
</li>
<li> <p><code>conv_to_seqgen_arg(migration)</code>: Feature conversion
</p>
</li>
<li> <p><code>conv_to_msms_arg(mutation)</code>: Feature conversion
</p>
</li>
<li> <p><code>conv_to_scrm_arg(mutation)</code>: Feature conversion
</p>
</li>
<li> <p><code>conv_to_seqgen_arg(mutation)</code>: Feature conversion
</p>
</li>
<li> <p><code>conv_to_msms_arg(outgroup)</code>: Feature conversion
</p>
</li>
<li> <p><code>conv_to_scrm_arg(outgroup)</code>: Feature conversion
</p>
</li>
<li> <p><code>conv_to_seqgen_arg(outgroup)</code>: Feature conversion
</p>
</li>
<li> <p><code>conv_to_msms_arg(pop_merge)</code>: Feature conversion
</p>
</li>
<li> <p><code>conv_to_scrm_arg(pop_merge)</code>: Feature conversion
</p>
</li>
<li> <p><code>conv_to_seqgen_arg(pop_merge)</code>: Feature conversion
</p>
</li>
<li> <p><code>conv_to_msms_arg(recombination)</code>: Feature conversion
</p>
</li>
<li> <p><code>conv_to_scrm_arg(recombination)</code>: Feature conversion
</p>
</li>
<li> <p><code>conv_to_seqgen_arg(recombination)</code>: Feature conversion
</p>
</li>
<li> <p><code>conv_to_msms_arg(sample)</code>: Feature conversion
</p>
</li>
<li> <p><code>conv_to_scrm_arg(sample)</code>: Feature conversion
</p>
</li>
<li> <p><code>conv_to_seqgen_arg(sample)</code>: Feature conversion
</p>
</li>
<li> <p><code>conv_to_scrm_arg(selection)</code>: Feature conversion
</p>
</li>
<li> <p><code>conv_to_msms_arg(selection)</code>: Feature conversion
</p>
</li>
<li> <p><code>conv_to_seqgen_arg(selection)</code>: Feature conversion
</p>
</li>
<li> <p><code>conv_to_msms_arg(size_change)</code>: Feature conversion
</p>
</li>
<li> <p><code>conv_to_scrm_arg(size_change)</code>: Feature conversion
</p>
</li>
<li> <p><code>conv_to_seqgen_arg(size_change)</code>: Feature conversion
</p>
</li>
<li> <p><code>conv_to_msms_arg(seg_sites_feat)</code>: Feature conversion
</p>
</li>
<li> <p><code>conv_to_scrm_arg(seg_sites_feat)</code>: Feature conversion
</p>
</li>
<li> <p><code>conv_to_seqgen_arg(seg_sites_feat)</code>: Feature conversion
</p>
</li>
<li> <p><code>conv_to_msms_arg(trees_feat)</code>: Feature conversion
</p>
</li>
<li> <p><code>conv_to_scrm_arg(trees_feat)</code>: Feature conversion
</p>
</li>
<li> <p><code>conv_to_seqgen_arg(trees_feat)</code>: Feature conversion
</p>
</li>
<li> <p><code>conv_to_msms_arg(files_feat)</code>: Feature conversion
</p>
</li>
<li> <p><code>conv_to_scrm_arg(files_feat)</code>: Feature conversion
</p>
</li>
<li> <p><code>conv_to_seqgen_arg(files_feat)</code>: Feature conversion
</p>
</li>
<li> <p><code>conv_to_msms_arg(unphased)</code>: Feature conversion
</p>
</li>
<li> <p><code>conv_to_scrm_arg(unphased)</code>: Feature conversion
</p>
</li>
<li> <p><code>conv_to_seqgen_arg(unphased)</code>: Feature conversion
</p>
</li>
<li> <p><code>conv_to_msms_arg(default)</code>: Feature conversion
</p>
</li>
<li> <p><code>conv_to_scrm_arg(default)</code>: Feature conversion
</p>
</li>
<li> <p><code>conv_to_seqgen_arg(default)</code>: Feature conversion
</p>
</li></ul>

<hr>
<h2 id='create_abc_param'>Convert Simulation Results to abc's Parameter Format</h2><span id='topic+create_abc_param'></span>

<h3>Description</h3>

<p>This function creates an object compatible with the <code>param</code>
argument of the <code><a href="abc.html#topic+abc">abc</a></code> function from coala's simulation
results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_abc_param(sim_results, model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_abc_param_+3A_sim_results">sim_results</code></td>
<td>
<p>The simulation results as returned from
<code><a href="#topic+simulate.coalmodel">simulate</a></code>.</p>
</td></tr>
<tr><td><code id="create_abc_param_+3A_model">model</code></td>
<td>
<p>The model used for the simulations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame that can be used as <code>param</code>
argument of <code><a href="abc.html#topic+abc">abc</a></code>.
</p>


<h3>See Also</h3>

<p>For generating abc's summary statistics format:
<code><a href="#topic+create_abc_sumstat">create_abc_sumstat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- coal_model(10, 1) +
  feat_mutation(par_prior("theta", rnorm(1, 5, .5))) +
  sumstat_sfs()
sim_results &lt;- simulate(model, nsim = 2)
abc_param &lt;- create_abc_param(sim_results, model)
print(abc_param)
</code></pre>

<hr>
<h2 id='create_abc_sumstat'>Convert Simulation Results to abc's Summary Statistic Format</h2><span id='topic+create_abc_sumstat'></span>

<h3>Description</h3>

<p>This function creates an object compatible with the <code>sumstat</code>
argument of the <code><a href="abc.html#topic+abc">abc</a></code> function from coala's simulation
results. It converts all summary statistics that are in the simulation
results and expects that each of them is a numeric vector.
Use transformation functions to convert none vector-valued  statistics
(e.g. <code><a href="#topic+sumstat_jsfs">sumstat_jsfs</a></code>, <code><a href="#topic+sumstat_omega">sumstat_omega</a></code> or
<code><a href="#topic+sumstat_trees">sumstat_trees</a></code>) into a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_abc_sumstat(sim_results, model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_abc_sumstat_+3A_sim_results">sim_results</code></td>
<td>
<p>The simulation results as returned from
<code><a href="#topic+simulate.coalmodel">simulate</a></code>.</p>
</td></tr>
<tr><td><code id="create_abc_sumstat_+3A_model">model</code></td>
<td>
<p>The model used for the simulations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame that can be used as <code>sumstat</code>
argument of <code><a href="abc.html#topic+abc">abc</a></code>.
</p>


<h3>See Also</h3>

<p>For generating abc's parameter format:
<code><a href="#topic+create_abc_param">create_abc_param</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Using the SFS:
model &lt;- coal_model(10, 1) +
  feat_mutation(par_prior("theta", rnorm(1, 5, .5))) +
  sumstat_sfs()
sim_results &lt;- simulate(model, nsim = 2)
abc_sumstat &lt;- create_abc_sumstat(sim_results, model)
print(abc_sumstat)

# Using the JSFS and converting it into a vector:
model &lt;- coal_model(c(10, 10), 1) +
  feat_mutation(par_prior("theta", rnorm(1, 5, .5))) +
  feat_migration(par_prior("m", rnorm(1, .5, .1)), symmetri = TRUE) +
  sumstat_jsfs(transformation = function(jsfs) {
    c(sum(jsfs[1, ]), sum(jsfs[, 1]), sum(jsfs[-1, -1]))
  })
sim_results &lt;- simulate(model, nsim = 2)
abc_sumstat &lt;- create_abc_sumstat(sim_results, model)
print(abc_sumstat)
</code></pre>

<hr>
<h2 id='create_segsites'>Segregating Sites</h2><span id='topic+create_segsites'></span><span id='topic+get_snps'></span><span id='topic+get_positions'></span><span id='topic+set_positions'></span><span id='topic+get_trio_locus'></span><span id='topic+set_trio_locus'></span><span id='topic+segsites'></span><span id='topic+is_segsites'></span><span id='topic+create_locus_trio'></span>

<h3>Description</h3>

<p>These functions create and modify segregating sites
objects, which are one of the basic intermediary statistics that is
calculated in coala. Segregating sites consist primarily of a SNP matrix that
contains all SNPs for one locus, with some additional information attached.
The parts of the S3 class are detailed below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_segsites(snps, positions, trio_locus = numeric(0), check = TRUE)

get_snps(segsites)

get_positions(segsites)

set_positions(segsites, positions)

get_trio_locus(segsites)

set_trio_locus(segsites, trio_locus)

is_segsites(segsites)

create_locus_trio(left, middle, right)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_segsites_+3A_snps">snps</code></td>
<td>
<p>The SNP Matrix (see Details).</p>
</td></tr>
<tr><td><code id="create_segsites_+3A_positions">positions</code></td>
<td>
<p>A numeric vector indicating the relative positions of each
SNP on the locus (see Details).</p>
</td></tr>
<tr><td><code id="create_segsites_+3A_trio_locus">trio_locus</code></td>
<td>
<p>If the locus consists of a locus trio (see Details).</p>
</td></tr>
<tr><td><code id="create_segsites_+3A_check">check</code></td>
<td>
<p>Whether non-segregating sites are removed from the segregating
sites (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="create_segsites_+3A_segsites">segsites</code></td>
<td>
<p>The segregating sites object</p>
</td></tr>
<tr><td><code id="create_segsites_+3A_left">left</code></td>
<td>
<p>The segregating sites from the left locus</p>
</td></tr>
<tr><td><code id="create_segsites_+3A_middle">middle</code></td>
<td>
<p>The segregating sites from the middle locus</p>
</td></tr>
<tr><td><code id="create_segsites_+3A_right">right</code></td>
<td>
<p>The segregating sites from the right locus</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A segregating sites object contains all SNPs for one genetic locus. Each
object consists of three parts: A SNP matrix, a vector of SNP positions and
a vector that states which transcript a SNP belong to, if the locus
consists of multiple transscripts ('locus trio').
</p>

<ul>
<li><p>In the <strong>SNP</strong> matrix, each row represents a haplotype and each
column represents a SNP. An entry is either <code>1</code> if the
haplotype carries the derived allele for the SNP, or <code>0</code> if it
carries the ancestral one.
</p>
</li>
<li><p>In the <strong>positions</strong> vector, each entry gives the relative
position of SNP in the corresponding column of the SNP matrix.
</p>
</li>
<li><p>The <strong>trio_locus</strong> vector contains the trio locus each SNP
belongs to. Entry of <code>-1</code>,<code>0</code>, <code>1</code> represent the
left, middle, and right locus, respectively. For normal loci,
this just consists of <code>0</code>'s
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>create_segsites()</code>: Creates segregating sites
</p>
</li>
<li> <p><code>get_snps()</code>: Returns the SNP matrix from a segregating sites
object.
</p>
</li>
<li> <p><code>get_positions()</code>: Returns the SNP's positions from a segregating
sites  object.
</p>
</li>
<li> <p><code>set_positions()</code>: Sets the SNP's positions in a segregating
sites object.
</p>
</li>
<li> <p><code>get_trio_locus()</code>: Returns the trio locus positions from a
segregating sites  object.
</p>
</li>
<li> <p><code>set_trio_locus()</code>: Sets the trio locus in a segregating sites
object.
</p>
</li>
<li> <p><code>is_segsites()</code>: Checks whether an object is a segsites object.
</p>
</li>
<li> <p><code>create_locus_trio()</code>: Combines three segregating sites to a locus trio
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Paul Staab
</p>


<h3>See Also</h3>

<p>For converting biological data to segsites: <code><a href="#topic+as.segsites">as.segsites</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>snps &lt;- matrix(c(1, 0, 0,
                 1, 1, 0,
                 0, 0, 1), 3, 3, TRUE)
pos &lt;- c(.1, .3, .5)
segsites &lt;- create_segsites(snps, pos)
print(segsites)
get_snps(segsites)
get_positions(segsites)

# When subsetting individuals, sites that are not
# segregating in these are automatically removed:
segsites[1:2, 1:3]
</code></pre>

<hr>
<h2 id='feat_growth'>Feature: Exponential population size growth/decline</h2><span id='topic+feat_growth'></span>

<h3>Description</h3>

<p>This feature changes the growth factor of a population at given
point in time. This factor applies to the time interval further
into the past from this point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feat_growth(rate, population = "all", time = "0", locus_group = "all")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="feat_growth_+3A_rate">rate</code></td>
<td>
<p>The growth rate. Can be a numeric or a <code><a href="#topic+parameter">parameter</a></code>.
See <code>Details</code> for an explanation how the rate affects the
population size.</p>
</td></tr>
<tr><td><code id="feat_growth_+3A_population">population</code></td>
<td>
<p>The population which growths/declines. Can be
&quot;all&quot; for all populations, or the number of one population.</p>
</td></tr>
<tr><td><code id="feat_growth_+3A_time">time</code></td>
<td>
<p>The time at which the growth rate is changed. Can also be
a <code><a href="#topic+parameter">parameter</a></code>.</p>
</td></tr>
<tr><td><code id="feat_growth_+3A_locus_group">locus_group</code></td>
<td>
<p>The loci for which this features is used. Can either be
<code>"all"</code> (default), in which case the feature is used for simulating
all loci, or a numeric vector. In the latter case, the feature is only
used for the loci added in <code>locus_</code> commands  with the corresponding
index starting from 1 in order in which the commands where added to the
model. For example, if a model has
<code>locus_single(10) + locus_averaged(10, 11) + locus_single(12)</code> and
this argument is <code>c(2, 3)</code>, than the feature is used for all but
the first locus (that is locus 2 - 12).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The population size changes by a factor <code class="reqn">exp(-\alpha*t)</code>, where
<code class="reqn">\alpha</code> is the growth parameter and <code class="reqn">t</code> is the time since
the growth has started. For positive alpha, the population will decline
backwards in time or grow forwards in time. For a negative value of
<code class="reqn">\alpha</code> it will decline (forward in time).
</p>


<h3>Value</h3>

<p>The feature, which can be added to a model created with
<code><a href="#topic+coal_model">coal_model</a></code> using <code>+</code>.
</p>


<h3>See Also</h3>

<p>For instantaneous population size
changes: <code><a href="#topic+feat_size_change">feat_size_change</a></code>
</p>
<p>For creating a model: <code><a href="#topic+coal_model">coal_model</a></code>
</p>
<p>Other features: 
<code><a href="#topic+feat_ignore_singletons">feat_ignore_singletons</a>()</code>,
<code><a href="#topic+feat_migration">feat_migration</a>()</code>,
<code><a href="#topic+feat_mutation">feat_mutation</a>()</code>,
<code><a href="#topic+feat_outgroup">feat_outgroup</a>()</code>,
<code><a href="#topic+feat_pop_merge">feat_pop_merge</a>()</code>,
<code><a href="#topic+feat_recombination">feat_recombination</a>()</code>,
<code><a href="#topic+feat_selection">feat_selection</a>()</code>,
<code><a href="#topic+feat_size_change">feat_size_change</a>()</code>,
<code><a href="#topic+feat_unphased">feat_unphased</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate a haploid population that has been expanding for
# the last 2*Ne generations
model &lt;- coal_model(10, 1) +
  feat_growth(5, time = 0) +
  feat_growth(0, time = 1) +
  feat_mutation(10) +
  sumstat_sfs()
simulate(model)
</code></pre>

<hr>
<h2 id='feat_ignore_singletons'>Feature: Ignore Singletons</h2><span id='topic+feat_ignore_singletons'></span>

<h3>Description</h3>

<p>Mutations that are observed in just one haplotype ('singletons') are often
regarded as likely candidates for sequencing errors. Sometimes, it can be
advantageous to exclude them from an analysis. This feature removes all
singletons from the simulated data before the summary statistics are
calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feat_ignore_singletons(locus_group = "all")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="feat_ignore_singletons_+3A_locus_group">locus_group</code></td>
<td>
<p>The loci for which this features is used. Can either be
<code>"all"</code> (default), in which case the feature is used for simulating
all loci, or a numeric vector. In the latter case, the feature is only
used for the loci added in <code>locus_</code> commands  with the corresponding
index starting from 1 in order in which the commands where added to the
model. For example, if a model has
<code>locus_single(10) + locus_averaged(10, 11) + locus_single(12)</code> and
this argument is <code>c(2, 3)</code>, than the feature is used for all but
the first locus (that is locus 2 - 12).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function assumes that a singleton is a mutation for which the derived
allele is observed exactly once in all sequences, regardless of the
population structure.
</p>


<h3>Value</h3>

<p>The feature, which can be added to a model created with
<code><a href="#topic+coal_model">coal_model</a></code> using <code>+</code>.
</p>


<h3>See Also</h3>

<p>For creating a model: <code><a href="#topic+coal_model">coal_model</a></code>
</p>
<p>Other features: 
<code><a href="#topic+feat_growth">feat_growth</a>()</code>,
<code><a href="#topic+feat_migration">feat_migration</a>()</code>,
<code><a href="#topic+feat_mutation">feat_mutation</a>()</code>,
<code><a href="#topic+feat_outgroup">feat_outgroup</a>()</code>,
<code><a href="#topic+feat_pop_merge">feat_pop_merge</a>()</code>,
<code><a href="#topic+feat_recombination">feat_recombination</a>()</code>,
<code><a href="#topic+feat_selection">feat_selection</a>()</code>,
<code><a href="#topic+feat_size_change">feat_size_change</a>()</code>,
<code><a href="#topic+feat_unphased">feat_unphased</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- coal_model(2, 1) +
  feat_mutation(10) +
  feat_ignore_singletons() +
  sumstat_sfs("n_mut", transformation = sum)
# In this model, all mutations are singletons. Therefore,
# the number of mutations is 0 when removing singletons:
simulate(model)$n_mut
</code></pre>

<hr>
<h2 id='feat_migration'>Feature: Migration/Gene Flow</h2><span id='topic+feat_migration'></span>

<h3>Description</h3>

<p>This feature changes the migration rates at a given time point.
Per default, no migration between the population occurs, which corresponds
to a <code>rate</code> of <code>0</code>. Set it to a value greater than zero to
enable migration from one population to another.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feat_migration(
  rate,
  pop_from = NULL,
  pop_to = NULL,
  symmetric = FALSE,
  time = "0",
  locus_group = "all"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="feat_migration_+3A_rate">rate</code></td>
<td>
<p>The migration rate. Can be a numeric or a
<code><a href="#topic+parameter">parameter</a></code>. The rate is specified as
<code class="reqn">4 * N0 * m</code>, where <code class="reqn">m</code> is the fraction of
<code>pop_to</code> that is replaced by migrants
from <code>pop_from</code> each generation (in forward time).</p>
</td></tr>
<tr><td><code id="feat_migration_+3A_pop_from">pop_from</code></td>
<td>
<p>The population from which the individuals leave.</p>
</td></tr>
<tr><td><code id="feat_migration_+3A_pop_to">pop_to</code></td>
<td>
<p>The population to which the individuals move.</p>
</td></tr>
<tr><td><code id="feat_migration_+3A_symmetric">symmetric</code></td>
<td>
<p>Use the rate for all pairs of populations.</p>
</td></tr>
<tr><td><code id="feat_migration_+3A_time">time</code></td>
<td>
<p>The time point at which the migration with the migration
rate is set. The rate applies to the time past warts
of the time point, until it is changed again.</p>
</td></tr>
<tr><td><code id="feat_migration_+3A_locus_group">locus_group</code></td>
<td>
<p>The loci for which this features is used. Can either be
<code>"all"</code> (default), in which case the feature is used for simulating
all loci, or a numeric vector. In the latter case, the feature is only
used for the loci added in <code>locus_</code> commands  with the corresponding
index starting from 1 in order in which the commands where added to the
model. For example, if a model has
<code>locus_single(10) + locus_averaged(10, 11) + locus_single(12)</code> and
this argument is <code>c(2, 3)</code>, than the feature is used for all but
the first locus (that is locus 2 - 12).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When looking forward in time, a fraction of <code>pop_to</code> that is replaced
by migrants from <code>pop_from</code> each generation (see <code>rate</code>). When
looking backwards in time, ancestral lines in <code>pop_to</code> move to
<code>pop_from</code> with the given rate.
</p>


<h3>Value</h3>

<p>The feature, which can be added to a model created with
<code><a href="#topic+coal_model">coal_model</a></code> using <code>+</code>.
</p>


<h3>See Also</h3>

<p>For creating a model: <code><a href="#topic+coal_model">coal_model</a></code>
</p>
<p>Other features: 
<code><a href="#topic+feat_growth">feat_growth</a>()</code>,
<code><a href="#topic+feat_ignore_singletons">feat_ignore_singletons</a>()</code>,
<code><a href="#topic+feat_mutation">feat_mutation</a>()</code>,
<code><a href="#topic+feat_outgroup">feat_outgroup</a>()</code>,
<code><a href="#topic+feat_pop_merge">feat_pop_merge</a>()</code>,
<code><a href="#topic+feat_recombination">feat_recombination</a>()</code>,
<code><a href="#topic+feat_selection">feat_selection</a>()</code>,
<code><a href="#topic+feat_size_change">feat_size_change</a>()</code>,
<code><a href="#topic+feat_unphased">feat_unphased</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Asymmetric migration between two populations:
model &lt;- coal_model(c(5, 5), 10) +
  feat_migration(0.5, 1, 2) +
  feat_migration(1.0, 2, 1) +
  feat_mutation(5) +
  sumstat_sfs()
simulate(model)

# Three populations that exchange migrations with equal
# rates at times more than 0.5 time units in the past:
model &lt;- coal_model(c(3, 4, 5), 2) +
  feat_migration(1.2, symmetric = TRUE, time = 0.5) +
  feat_mutation(5) +
  sumstat_sfs()
simulate(model)
</code></pre>

<hr>
<h2 id='feat_mutation'>Feature: Mutation</h2><span id='topic+feat_mutation'></span>

<h3>Description</h3>

<p>This feature adds mutations to a model. Mutations occur in the genomes
of the individuals with a given <code>rate</code>. The rate is per locus
for <a href="#topic+locus">unlinked loci</a> and per trio for linked
<a href="#topic+locus_trio">locus trios</a>. By default, the same mutation rate is used
for all loci, but it is possible to change this with <code><a href="#topic+par_variation">par_variation</a></code>
and <code><a href="#topic+par_zero_inflation">par_zero_inflation</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feat_mutation(
  rate,
  model = "IFS",
  base_frequencies = NA,
  tstv_ratio = NA,
  gtr_rates = NA,
  fixed_number = FALSE,
  locus_group = "all"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="feat_mutation_+3A_rate">rate</code></td>
<td>
<p>The mutation rate. Can be a numeric or a <code><a href="#topic+parameter">parameter</a></code>.
The rate is specified as <code class="reqn">4 * N0 * mu</code>, where <code class="reqn">mu</code> is the
mutation rate per locus.</p>
</td></tr>
<tr><td><code id="feat_mutation_+3A_model">model</code></td>
<td>
<p>The mutation model you want to use.
Can be either 'IFS' (default), 'HKY' or 'GTR'. Refer to the mutation model
section for detailed information.</p>
</td></tr>
<tr><td><code id="feat_mutation_+3A_base_frequencies">base_frequencies</code></td>
<td>
<p>The equilibrium frequencies of the four bases used in
the 'HKY' mutation model. Must be a numeric vector of length four, with the
values for A, C, G and T, in that order.</p>
</td></tr>
<tr><td><code id="feat_mutation_+3A_tstv_ratio">tstv_ratio</code></td>
<td>
<p>The ratio of transitions to transversions used in the 'HKY'
muation model.</p>
</td></tr>
<tr><td><code id="feat_mutation_+3A_gtr_rates">gtr_rates</code></td>
<td>
<p>The rates for the six amino acid substitutions used in the
'GTR' model. Must be a numeric vector of length six.
Order: A&lt;-&gt;C, A&lt;-&gt;G, A&lt;-&gt;T, C&lt;-&gt;G, C&lt;-&gt;T, G&lt;-&gt;T.</p>
</td></tr>
<tr><td><code id="feat_mutation_+3A_fixed_number">fixed_number</code></td>
<td>
<p>If set to <code>TRUE</code>, the number of mutations on each
locus will always be exactly equal to the rate, rather than happening with
a rate along the ancestral tree.</p>
</td></tr>
<tr><td><code id="feat_mutation_+3A_locus_group">locus_group</code></td>
<td>
<p>The loci for which this features is used. Can either be
<code>"all"</code> (default), in which case the feature is used for simulating
all loci, or a numeric vector. In the latter case, the feature is only
used for the loci added in <code>locus_</code> commands  with the corresponding
index starting from 1 in order in which the commands where added to the
model. For example, if a model has
<code>locus_single(10) + locus_averaged(10, 11) + locus_single(12)</code> and
this argument is <code>c(2, 3)</code>, than the feature is used for all but
the first locus (that is locus 2 - 12).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The feature, which can be added to a model using <code>+</code>.
</p>
<p>The feature, which can be added to a model created with
<code><a href="#topic+coal_model">coal_model</a></code> using <code>+</code>.
</p>


<h3>Mutation Models</h3>

<p>The infinite sites mutation (<strong>IFS</strong>) model is a frequently used simplification
in population genetics. It assumes that each locus consists of infinitely
many sites at which mutations can occur, and each mutation hits a new site.
Consequently, there are no back-mutations with this model. It does not
generate DNA sequences, but rather only 0/1 coded data, were 0 denotes the
ancestral state of the site, and 1 the derived state created by a mutation.
</p>
<p>The other mutation models are finite site models that generate more realistic
sequences.
</p>
<p>The Hasegawa, Kishino and Yano (<strong>HKY</strong>) model (Hasegawa et al., 1985) allows
for a different rate of transitions and transversions (tstv_ratio)
and unequal
frequencies of the four nucleotides (base_frequencies).
</p>
<p>The general reversible process (<strong>GTR</strong>) model (e.g. Yang, 1994) is more general
than the HKY model and allows to define the rates for each
type of substitution. The rates are assumed to be symmetric
(e.g., the rate for T to G is equal to the one for G to T).
</p>


<h3>See Also</h3>

<p>For using rates that variate between the loci in a model:
<code><a href="#topic+par_variation">par_variation</a></code>, <code><a href="#topic+par_zero_inflation">par_zero_inflation</a></code>
</p>
<p>For adding recombination: <code><a href="#topic+feat_recombination">feat_recombination</a></code>.
</p>
<p>For creating a model: <code><a href="#topic+coal_model">coal_model</a></code>
</p>
<p>Other features: 
<code><a href="#topic+feat_growth">feat_growth</a>()</code>,
<code><a href="#topic+feat_ignore_singletons">feat_ignore_singletons</a>()</code>,
<code><a href="#topic+feat_migration">feat_migration</a>()</code>,
<code><a href="#topic+feat_outgroup">feat_outgroup</a>()</code>,
<code><a href="#topic+feat_pop_merge">feat_pop_merge</a>()</code>,
<code><a href="#topic+feat_recombination">feat_recombination</a>()</code>,
<code><a href="#topic+feat_selection">feat_selection</a>()</code>,
<code><a href="#topic+feat_size_change">feat_size_change</a>()</code>,
<code><a href="#topic+feat_unphased">feat_unphased</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A model with a constant mutation rate of 5:
model &lt;- coal_model(5, 1) + feat_mutation(5) + sumstat_seg_sites()
simulate(model)

# A model with a mutation of 5.0 for the first 10 loci, and 7.5 for the
# second 10 loci
model &lt;- coal_model(4) +
  locus_averaged(10, 100) +
  locus_averaged(10, 100) +
  feat_mutation(5.0, locus_group = 1) +
  feat_mutation(7.5, locus_group = 2) +
  sumstat_seg_sites()
simulate(model)

# A model with 7 mutations per locus:
model &lt;- coal_model(5, 1) +
  feat_mutation(7, fixed = TRUE) +
  sumstat_seg_sites()
simulate(model)

# A model using the HKY model:
model &lt;- coal_model(c(10, 1), 2) +
 feat_mutation(7.5, model = "HKY", tstv_ratio = 2,
               base_frequencies = c(.25, .25, .25, .25)) +
  feat_outgroup(2) +
  feat_pop_merge(1.0, 2, 1) +
  sumstat_seg_sites()
## Not run: simulate(model)

# A model using the GTR model:
model &lt;- coal_model(c(10, 1), 1, 25) +
  feat_mutation(7.5, model = "GTR",
                gtr_rates = c(1, 1, 1, 1, 1, 1) / 6) +
  feat_outgroup(2) +
  feat_pop_merge(1.0, 2, 1) +
  sumstat_dna()
## Not run: simulate(model)$dna
</code></pre>

<hr>
<h2 id='feat_outgroup'>Feature: Outgroup</h2><span id='topic+feat_outgroup'></span>

<h3>Description</h3>

<p>This feature declares an existing population as outgroup. Outgroups are used
to determine the ancestral allele in finite sites simulations and are required
there. All individuals of the outgroup are ignored when calculating summary
statistics. If the outgroup consists of multiple individuals, all positions
where the individuals have different alleles are ignored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feat_outgroup(population, locus_group = "all")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="feat_outgroup_+3A_population">population</code></td>
<td>
<p>The population that is marked as outgroup.
If finite-sites mutation models are used, the last population must be
specified as outgroup.</p>
</td></tr>
<tr><td><code id="feat_outgroup_+3A_locus_group">locus_group</code></td>
<td>
<p>The loci for which this features is used. Can either be
<code>"all"</code> (default), in which case the feature is used for simulating
all loci, or a numeric vector. In the latter case, the feature is only
used for the loci added in <code>locus_</code> commands  with the corresponding
index starting from 1 in order in which the commands where added to the
model. For example, if a model has
<code>locus_single(10) + locus_averaged(10, 11) + locus_single(12)</code> and
this argument is <code>c(2, 3)</code>, than the feature is used for all but
the first locus (that is locus 2 - 12).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The feature, which can be added to a model created with
<code><a href="#topic+coal_model">coal_model</a></code> using <code>+</code>.
</p>


<h3>See Also</h3>

<p>For creating a model: <code><a href="#topic+coal_model">coal_model</a></code>
</p>
<p>Other features: 
<code><a href="#topic+feat_growth">feat_growth</a>()</code>,
<code><a href="#topic+feat_ignore_singletons">feat_ignore_singletons</a>()</code>,
<code><a href="#topic+feat_migration">feat_migration</a>()</code>,
<code><a href="#topic+feat_mutation">feat_mutation</a>()</code>,
<code><a href="#topic+feat_pop_merge">feat_pop_merge</a>()</code>,
<code><a href="#topic+feat_recombination">feat_recombination</a>()</code>,
<code><a href="#topic+feat_selection">feat_selection</a>()</code>,
<code><a href="#topic+feat_size_change">feat_size_change</a>()</code>,
<code><a href="#topic+feat_unphased">feat_unphased</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A simple finite sites model
model &lt;- coal_model(c(4, 6, 1), 2, 10) +
   feat_outgroup(3) +
   feat_pop_merge(0.5, 2, 1) +
   feat_pop_merge(2, 3, 1) +
   feat_mutation(5, model = "GTR", gtr_rates = 1:6)
</code></pre>

<hr>
<h2 id='feat_pop_merge'>Feature: Population Merge</h2><span id='topic+feat_pop_merge'></span>

<h3>Description</h3>

<p>Backwards in time, this feature merges one population into another.
Forwards in time, this corresponds to a speciation event.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feat_pop_merge(time, pop_source, pop_target, locus_group = "all")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="feat_pop_merge_+3A_time">time</code></td>
<td>
<p>The time at which the merge occurs.</p>
</td></tr>
<tr><td><code id="feat_pop_merge_+3A_pop_source">pop_source</code></td>
<td>
<p>The population from which all lines are moved.
This is the newly created population in the speciation event.</p>
</td></tr>
<tr><td><code id="feat_pop_merge_+3A_pop_target">pop_target</code></td>
<td>
<p>The population to which the lines are moved. This is
the population in which the speciation event occurs.</p>
</td></tr>
<tr><td><code id="feat_pop_merge_+3A_locus_group">locus_group</code></td>
<td>
<p>The loci for which this features is used. Can either be
<code>"all"</code> (default), in which case the feature is used for simulating
all loci, or a numeric vector. In the latter case, the feature is only
used for the loci added in <code>locus_</code> commands  with the corresponding
index starting from 1 in order in which the commands where added to the
model. For example, if a model has
<code>locus_single(10) + locus_averaged(10, 11) + locus_single(12)</code> and
this argument is <code>c(2, 3)</code>, than the feature is used for all but
the first locus (that is locus 2 - 12).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In addition to the merge, the growth rate of and all migration rates from
the source population will be set to 0 at the time of the merge to mimic
a speciation event forwards in time. Technically, <code>pop_source</code> is
still present in the model, but not used unless migration to the population
is manually enabled.
</p>


<h3>Value</h3>

<p>The feature, which can be added to a model created with
<code><a href="#topic+coal_model">coal_model</a></code> using <code>+</code>.
</p>


<h3>See Also</h3>

<p>For creating a model: <code><a href="#topic+coal_model">coal_model</a></code>
</p>
<p>Other features: 
<code><a href="#topic+feat_growth">feat_growth</a>()</code>,
<code><a href="#topic+feat_ignore_singletons">feat_ignore_singletons</a>()</code>,
<code><a href="#topic+feat_migration">feat_migration</a>()</code>,
<code><a href="#topic+feat_mutation">feat_mutation</a>()</code>,
<code><a href="#topic+feat_outgroup">feat_outgroup</a>()</code>,
<code><a href="#topic+feat_recombination">feat_recombination</a>()</code>,
<code><a href="#topic+feat_selection">feat_selection</a>()</code>,
<code><a href="#topic+feat_size_change">feat_size_change</a>()</code>,
<code><a href="#topic+feat_unphased">feat_unphased</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Two population which merge after 0.5 time units:
model &lt;- coal_model(c(25,25), 1) +
  feat_pop_merge(0.5, 2, 1) +
  feat_mutation(5) +
  sumstat_tajimas_d()
simulate(model)

# An standard isolation-with-migration model:
model_iwm &lt;- model +
  feat_migration(.75, symmetric = TRUE)
simulate(model_iwm)
</code></pre>

<hr>
<h2 id='feat_recombination'>Feature: Recombination</h2><span id='topic+feat_recombination'></span>

<h3>Description</h3>

<p>This feature adds intra-locus recombination to a model.  The rate is per locus
for <a href="#topic+locus">unlinked loci</a> and per trio for linked
<a href="#topic+locus_trio">locus trios</a>. By default, the same recombination rate is used
for all loci, but it is possible to change this with <code><a href="#topic+par_variation">par_variation</a></code>
and <code><a href="#topic+par_zero_inflation">par_zero_inflation</a></code>. Coala assumes that recombination events
can occur between all neighboring bases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feat_recombination(rate, locus_group = "all")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="feat_recombination_+3A_rate">rate</code></td>
<td>
<p>The recombination rate. Can be a numeric or a
<code><a href="#topic+parameter">parameter</a></code>. The rate is equal to
<code class="reqn">4*N0*r</code>, where <code class="reqn">r</code> is the probability that a
recombination event within the locus occurs in one generation.</p>
</td></tr>
<tr><td><code id="feat_recombination_+3A_locus_group">locus_group</code></td>
<td>
<p>The loci for which this features is used. Can either be
<code>"all"</code> (default), in which case the feature is used for simulating
all loci, or a numeric vector. In the latter case, the feature is only
used for the loci added in <code>locus_</code> commands  with the corresponding
index starting from 1 in order in which the commands where added to the
model. For example, if a model has
<code>locus_single(10) + locus_averaged(10, 11) + locus_single(12)</code> and
this argument is <code>c(2, 3)</code>, than the feature is used for all but
the first locus (that is locus 2 - 12).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The feature, which can be added to a model using <code>+</code>.
</p>
<p>The feature, which can be added to a model created with
<code><a href="#topic+coal_model">coal_model</a></code> using <code>+</code>.
</p>


<h3>See Also</h3>

<p>For creating a model: <code><a href="#topic+coal_model">coal_model</a></code>
</p>
<p>For adding recombination: <code><a href="#topic+feat_mutation">feat_mutation</a></code>.
</p>
<p>Other features: 
<code><a href="#topic+feat_growth">feat_growth</a>()</code>,
<code><a href="#topic+feat_ignore_singletons">feat_ignore_singletons</a>()</code>,
<code><a href="#topic+feat_migration">feat_migration</a>()</code>,
<code><a href="#topic+feat_mutation">feat_mutation</a>()</code>,
<code><a href="#topic+feat_outgroup">feat_outgroup</a>()</code>,
<code><a href="#topic+feat_pop_merge">feat_pop_merge</a>()</code>,
<code><a href="#topic+feat_selection">feat_selection</a>()</code>,
<code><a href="#topic+feat_size_change">feat_size_change</a>()</code>,
<code><a href="#topic+feat_unphased">feat_unphased</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate a 1.5kb sequence for 10 individuals with recombination:
model &lt;- coal_model(10, 2, 1500) +
  feat_recombination(1.5) +
  feat_mutation(5) +
  sumstat_sfs()
simulate(model)
</code></pre>

<hr>
<h2 id='feat_sample'>Creates a feature that represents the sampling from one population</h2><span id='topic+feat_sample'></span>

<h3>Description</h3>

<p>Creates a feature that represents the sampling from one population
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feat_sample(individuals, ploidy = 1, time = "0")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="feat_sample_+3A_individuals">individuals</code></td>
<td>
<p>The number of individuals that are sampled per population,
given as a numeric vector.</p>
</td></tr>
<tr><td><code id="feat_sample_+3A_ploidy">ploidy</code></td>
<td>
<p>The number of chromosomes that will be simulated per
individual.</p>
</td></tr>
<tr><td><code id="feat_sample_+3A_time">time</code></td>
<td>
<p>The time at which the sample is taken.</p>
</td></tr>
</table>

<hr>
<h2 id='feat_selection'>Feature: Selection</h2><span id='topic+feat_selection'></span>

<h3>Description</h3>

<p>This feature adds selection to a model. Only one site per locus can be under
selection. Using this feature requires that <code>msms</code> is installed, see
<code><a href="#topic+activate_msms">activate_msms</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feat_selection(
  strength_AA = 0,
  strength_Aa = 0,
  strength_aa = 0,
  strength_A = NULL,
  population = "all",
  time,
  start = TRUE,
  start_frequency = 5e-04,
  Ne = 10000,
  position = 0.5,
  force_keep = TRUE,
  locus_group = "all"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="feat_selection_+3A_strength_aa">strength_AA</code></td>
<td>
<p>The selection strength for the selected homozygote.
The parameter is valid for the chosen population and the time further
past-wards from either time 0 on if <code>start = TRUE</code>, or from <code>time</code>
onwards. The same applies for <code>strength_Aa</code>, <code>strength_aa</code> and
<code>strength_A</code>.</p>
</td></tr>
<tr><td><code id="feat_selection_+3A_strength_aa">strength_Aa</code></td>
<td>
<p>The selection strength for the heterozygote.</p>
</td></tr>
<tr><td><code id="feat_selection_+3A_strength_aa">strength_aa</code></td>
<td>
<p>The selection strength for the recessive homozygote.</p>
</td></tr>
<tr><td><code id="feat_selection_+3A_strength_a">strength_A</code></td>
<td>
<p>This sets the strength for the selected allele in a
haploid model or a diploid model with additive selection.
<code>strength_AA</code>, <code>strength_Aa</code>, <code>strength_aa</code>
are ignored when this is argument is given.</p>
</td></tr>
<tr><td><code id="feat_selection_+3A_population">population</code></td>
<td>
<p>The population in which the allele is selected. Can either
be <code>all</code> for all population, or the number of a population.</p>
</td></tr>
<tr><td><code id="feat_selection_+3A_time">time</code></td>
<td>
<p>The time at which the selection starts if <code>start == TRUE</code>
(looking forwards in time), or the time at which the selection strength
changes if <code>start == FALSE</code>. The new strength applies for the time
period further into the past in this case.</p>
</td></tr>
<tr><td><code id="feat_selection_+3A_start">start</code></td>
<td>
<p>Whether selection should start at this time point. At this time,
the selected allele is introduced in the population with an initial
starting frequency. This must be set to <code>TRUE</code> for exactly one
selection feature in the model. The values of <code>start_frequency</code>,
<code>Ne</code>, <code>position</code> and <code>force_keep</code> are used for the model.
You can add additional selection feature to the model to set the
selection strength for more demes or change it at different time points,
but these need to have <code>start = FALSE</code>.</p>
</td></tr>
<tr><td><code id="feat_selection_+3A_start_frequency">start_frequency</code></td>
<td>
<p>The start frequency at which the selected allele is
introduced at <code>time</code>. If the model has multiple population, this
can either be a numeric vector that contains the initial frequency for each
population or a single number. In the latter case, the value is used for
all population specified with <code>populations</code>, and 0 is used for all
other populations.</p>
</td></tr>
<tr><td><code id="feat_selection_+3A_ne">Ne</code></td>
<td>
<p>The effective population size that is used for the forward
simulations.</p>
</td></tr>
<tr><td><code id="feat_selection_+3A_position">position</code></td>
<td>
<p>The position of the selected site, relative to the
simulated sequence. Values between 0 and 1 are within the simulated area,
while smaller values are to the left of it and larger ones to the right.</p>
</td></tr>
<tr><td><code id="feat_selection_+3A_force_keep">force_keep</code></td>
<td>
<p>Whether to restart simulations in which the selected goes to
extinction or not.</p>
</td></tr>
<tr><td><code id="feat_selection_+3A_locus_group">locus_group</code></td>
<td>
<p>The loci for which this features is used. Can either be
<code>"all"</code> (default), in which case the feature is used for simulating
all loci, or a numeric vector. In the latter case, the feature is only
used for the loci added in <code>locus_</code> commands  with the corresponding
index starting from 1 in order in which the commands where added to the
model. For example, if a model has
<code>locus_single(10) + locus_averaged(10, 11) + locus_single(12)</code> and
this argument is <code>c(2, 3)</code>, than the feature is used for all but
the first locus (that is locus 2 - 12).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The feature, which can be added to a model created with
<code><a href="#topic+coal_model">coal_model</a></code> using <code>+</code>.
</p>


<h3>See Also</h3>

<p>For using rates that variate between the loci in a model:
<code><a href="#topic+par_variation">par_variation</a></code>, <code><a href="#topic+par_zero_inflation">par_zero_inflation</a></code>
</p>
<p>For summary statistics that are sensitive for selection:
<code><a href="#topic+sumstat_tajimas_d">sumstat_tajimas_d</a></code>, <code><a href="#topic+sumstat_ihh">sumstat_ihh</a></code>,
<code><a href="#topic+sumstat_omega">sumstat_omega</a></code>, <code><a href="#topic+sumstat_mcmf">sumstat_mcmf</a></code>
</p>
<p>For creating a model: <code><a href="#topic+coal_model">coal_model</a></code>
</p>
<p>Other features: 
<code><a href="#topic+feat_growth">feat_growth</a>()</code>,
<code><a href="#topic+feat_ignore_singletons">feat_ignore_singletons</a>()</code>,
<code><a href="#topic+feat_migration">feat_migration</a>()</code>,
<code><a href="#topic+feat_mutation">feat_mutation</a>()</code>,
<code><a href="#topic+feat_outgroup">feat_outgroup</a>()</code>,
<code><a href="#topic+feat_pop_merge">feat_pop_merge</a>()</code>,
<code><a href="#topic+feat_recombination">feat_recombination</a>()</code>,
<code><a href="#topic+feat_size_change">feat_size_change</a>()</code>,
<code><a href="#topic+feat_unphased">feat_unphased</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Positive additive selection in population 2:
model &lt;- coal_model(c(10, 13), 1, 10000) +
  feat_pop_merge(.5, 2, 1) +
  feat_selection(strength_A = 1000,
                 population = 2,
                 time = par_named("tau")) +
  feat_mutation(100) +
  feat_recombination(10) +
  sumstat_tajimas_d(population = 2)
## Not run: simulate(model, pars = c(tau = 0.03))
</code></pre>

<hr>
<h2 id='feat_size_change'>Feature: Instantaneous Size Change</h2><span id='topic+feat_size_change'></span>

<h3>Description</h3>

<p>This feature changes the effective population size of one
population. The change is performed at a given time point
and applies to the time interval further on into
the past from this point. The population size is set to a
fraction of N0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feat_size_change(new_size, population = 1, time = "0", locus_group = "all")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="feat_size_change_+3A_new_size">new_size</code></td>
<td>
<p>A <code><a href="#topic+parameter">parameter</a></code> giving the new size of the
population, as a fraction of N0.</p>
</td></tr>
<tr><td><code id="feat_size_change_+3A_population">population</code></td>
<td>
<p>The number of the population whichs size changes.
Can also be set to &quot;all&quot;. Then the size changes applies to all
populations.</p>
</td></tr>
<tr><td><code id="feat_size_change_+3A_time">time</code></td>
<td>
<p>The time at which the population's size is changed.</p>
</td></tr>
<tr><td><code id="feat_size_change_+3A_locus_group">locus_group</code></td>
<td>
<p>The loci for which this features is used. Can either be
<code>"all"</code> (default), in which case the feature is used for simulating
all loci, or a numeric vector. In the latter case, the feature is only
used for the loci added in <code>locus_</code> commands  with the corresponding
index starting from 1 in order in which the commands where added to the
model. For example, if a model has
<code>locus_single(10) + locus_averaged(10, 11) + locus_single(12)</code> and
this argument is <code>c(2, 3)</code>, than the feature is used for all but
the first locus (that is locus 2 - 12).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The feature, which can be added to a model using <code>+</code>.
</p>
<p>The feature, which can be added to a model created with
<code><a href="#topic+coal_model">coal_model</a></code> using <code>+</code>.
</p>


<h3>See Also</h3>

<p>For continuous size changes over time: <code><a href="#topic+feat_growth">feat_growth</a></code>.
</p>
<p>For creating a model: <code><a href="#topic+coal_model">coal_model</a></code>
</p>
<p>Other features: 
<code><a href="#topic+feat_growth">feat_growth</a>()</code>,
<code><a href="#topic+feat_ignore_singletons">feat_ignore_singletons</a>()</code>,
<code><a href="#topic+feat_migration">feat_migration</a>()</code>,
<code><a href="#topic+feat_mutation">feat_mutation</a>()</code>,
<code><a href="#topic+feat_outgroup">feat_outgroup</a>()</code>,
<code><a href="#topic+feat_pop_merge">feat_pop_merge</a>()</code>,
<code><a href="#topic+feat_recombination">feat_recombination</a>()</code>,
<code><a href="#topic+feat_selection">feat_selection</a>()</code>,
<code><a href="#topic+feat_unphased">feat_unphased</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A model with one smaller population:
model &lt;- coal_model(c(20, 5), 3) +
  feat_size_change(.1, population = 2) +
  feat_mutation(1.0) +
  feat_migration(0.5, 2, 1) +
  sumstat_sfs()
simulate(model)

# A model of one population that experienced a bottleneck:
model &lt;- coal_model(10, 1) +
  feat_size_change(0.1, time = 0.3) +
  feat_size_change(1.0, time = 0.5) +
  feat_mutation(20) +
  sumstat_sfs()
simulate(model)
</code></pre>

<hr>
<h2 id='feat_unphased'>Feature: Unphased Sequences</h2><span id='topic+feat_unphased'></span>

<h3>Description</h3>

<p>This simulates unphased data by randomly mixing the sites within one
individual. Each position is randomly taken from a phased chromosome..
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feat_unphased(samples_per_ind, locus_group = "all")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="feat_unphased_+3A_samples_per_ind">samples_per_ind</code></td>
<td>
<p>The number of pseudo-chromosomes that are created
from the phased chromosomes for each individual.</p>
</td></tr>
<tr><td><code id="feat_unphased_+3A_locus_group">locus_group</code></td>
<td>
<p>The loci for which this features is used. Can either be
<code>"all"</code> (default), in which case the feature is used for simulating
all loci, or a numeric vector. In the latter case, the feature is only
used for the loci added in <code>locus_</code> commands  with the corresponding
index starting from 1 in order in which the commands where added to the
model. For example, if a model has
<code>locus_single(10) + locus_averaged(10, 11) + locus_single(12)</code> and
this argument is <code>c(2, 3)</code>, than the feature is used for all but
the first locus (that is locus 2 - 12).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each individual, <code>ploidy</code> chromosomes are simulated, and
<code>samples_per_ind</code> pseudo-chromosomes are created of these.
</p>


<h3>Value</h3>

<p>The feature, which can be added to a model using <code>+</code>.
</p>
<p>The feature, which can be added to a model created with
<code><a href="#topic+coal_model">coal_model</a></code> using <code>+</code>.
</p>


<h3>See Also</h3>

<p>For creating a model: <code><a href="#topic+coal_model">coal_model</a></code>
</p>
<p>Other features: 
<code><a href="#topic+feat_growth">feat_growth</a>()</code>,
<code><a href="#topic+feat_ignore_singletons">feat_ignore_singletons</a>()</code>,
<code><a href="#topic+feat_migration">feat_migration</a>()</code>,
<code><a href="#topic+feat_mutation">feat_mutation</a>()</code>,
<code><a href="#topic+feat_outgroup">feat_outgroup</a>()</code>,
<code><a href="#topic+feat_pop_merge">feat_pop_merge</a>()</code>,
<code><a href="#topic+feat_recombination">feat_recombination</a>()</code>,
<code><a href="#topic+feat_selection">feat_selection</a>()</code>,
<code><a href="#topic+feat_size_change">feat_size_change</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate unphased data in a diploid population
model &lt;- coal_model(10, 1, ploidy = 2) +
  feat_mutation(10) +
  feat_unphased(2) +
  sumstat_seg_sites()
simulate(model)

# The same as before, but return only one chromosome for
# each individual:
model &lt;- coal_model(10, 1, ploidy = 2) +
  feat_mutation(10) +
  feat_unphased(1) +
  sumstat_seg_sites()
simulate(model)
</code></pre>

<hr>
<h2 id='get_outgroup'>Getters for coalescent models</h2><span id='topic+get_outgroup'></span><span id='topic+get_outgroup_size'></span><span id='topic+get_sample_size'></span><span id='topic+get_features'></span><span id='topic+get_parameter_table'></span><span id='topic+get_parameter'></span><span id='topic+get_locus_length'></span><span id='topic+get_populations'></span><span id='topic+get_locus_length_matrix'></span><span id='topic+get_locus_number'></span><span id='topic+get_population_individuals'></span><span id='topic+get_summary_statistics'></span>

<h3>Description</h3>

<p>Getters for coalescent models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_outgroup(model)

get_outgroup_size(model, for_sim = FALSE)

get_sample_size(model, for_sim = FALSE)

get_features(model)

get_parameter_table(model)

get_parameter(model)

get_locus_length(model, locus = NULL, group = NULL, total = TRUE)

get_populations(model)

get_locus_length_matrix(model)

get_locus_number(model, group = NA, ignore_variation = FALSE)

get_population_individuals(model, pop, zero_indexed = FALSE, haploids = TRUE)

get_summary_statistics(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_outgroup_+3A_model">model</code></td>
<td>
<p>The coalescent model from which aspects are returned</p>
</td></tr>
<tr><td><code id="get_outgroup_+3A_for_sim">for_sim</code></td>
<td>
<p>If true, the sample size used internally for the simulation
will be reported rather than the number of actual samples. The numbers
can be unequal for the simulation of unphased data.</p>
</td></tr>
<tr><td><code id="get_outgroup_+3A_locus">locus</code></td>
<td>
<p>The number of the locus.</p>
</td></tr>
<tr><td><code id="get_outgroup_+3A_group">group</code></td>
<td>
<p>The group of loci.</p>
</td></tr>
<tr><td><code id="get_outgroup_+3A_total">total</code></td>
<td>
<p>If <code>FALSE</code>, the length of loci in a trio will be reported
individually. If <code>TRUE</code> the sum of the loci&quot;s length will be reported.
This does not affect non-trio loci.</p>
</td></tr>
<tr><td><code id="get_outgroup_+3A_ignore_variation">ignore_variation</code></td>
<td>
<p>For internal use. Will likely be removed soon.</p>
</td></tr>
<tr><td><code id="get_outgroup_+3A_pop">pop</code></td>
<td>
<p>The population for which aspects are returned</p>
</td></tr>
<tr><td><code id="get_outgroup_+3A_zero_indexed">zero_indexed</code></td>
<td>
<p>If true, the names of the populations are started from
0 instead of from 1.</p>
</td></tr>
<tr><td><code id="get_outgroup_+3A_haploids">haploids</code></td>
<td>
<p>If <code>TRUE</code>, the function always returns all haploids
from the population, even if the model is polyploid.</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>get_outgroup()</code>: Returns the population that is marked as outgroup
</p>
</li>
<li> <p><code>get_outgroup_size()</code>: Returns the number of samples in the outgroup
</p>
</li>
<li> <p><code>get_sample_size()</code>: Returns a vector containing the number of
haploids sampled per population. This is the default ordering of
individuals used by coala.
</p>
</li>
<li> <p><code>get_parameter_table()</code>: Returns the ranged parameters of a model as a
data.frame
</p>
</li>
<li> <p><code>get_parameter()</code>: Returns the ranged parameters of a model
</p>
</li>
<li> <p><code>get_locus_length()</code>: Returns the length of the loci in a locus group
</p>
</li>
<li> <p><code>get_populations()</code>: Returns a vector of populations in the model
</p>
</li>
<li> <p><code>get_locus_length_matrix()</code>: Returns a matrix with detailed length
information about the loci in the model.
</p>
</li>
<li> <p><code>get_locus_number()</code>: Returns the number of loci in a locus group
</p>
</li>
<li> <p><code>get_population_individuals()</code>: Returns the index of the individuals of one
population. Ignores outgroups, so that it can be used for indexing
segregating sites.
</p>
</li>
<li> <p><code>get_summary_statistics()</code>: Returns the summary statistics in the model
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Paul Staab
</p>

<hr>
<h2 id='list_simulators'>Returns the available simulators</h2><span id='topic+list_simulators'></span>

<h3>Description</h3>

<p>This functions returns the usable simulators
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_simulators()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>list_simulators()
</code></pre>

<hr>
<h2 id='locus'>Loci</h2><span id='topic+locus'></span><span id='topic+loci'></span><span id='topic+locus_single'></span><span id='topic+locus_averaged'></span>

<h3>Description</h3>

<p>This functions adds one or more loci to a model. A locus is a continuous
stretch of DNA of a given length. All loci are simulated independently of each
other, and are genetically unlinked. A model can contain a
large number of different loci created with <code>locus_single</code>. This will,
however, slow down the simulation. For performance reasons, it is
better to add the same number of loci with averaged length using
<code>locus_averaged</code> if this simplification is justifiable. Both can also be
combined in a single model. In the results,
the summary statistics for the loci are returned in order in which they
are added to the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locus_single(length)

locus_averaged(number, length)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="locus_+3A_length">length</code></td>
<td>
<p>The length of the locus in base pairs.</p>
</td></tr>
<tr><td><code id="locus_+3A_number">number</code></td>
<td>
<p>The number of loci to add.</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>locus_single()</code>: Adds a single locus.
</p>
</li>
<li> <p><code>locus_averaged()</code>: Adds multiple loci with equal length.
</p>
</li></ul>


<h3>See Also</h3>

<p>For adding three loci which are linked to each other:
<code><a href="#topic+locus_trio">locus_trio</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A model with one locus of length 1005 bp:
coal_model(10) + locus_single(1005)
# This is equivalent to:
coal_model(10, 1, 1005)

# A model can contain multiple loci:
coal_model(5) + locus_single(100) + locus_single(200) + locus_single(300)
# Or more efficient with averaged length:
coal_model(5) + locus_averaged(3, 200)
# Or equivalently:
coal_model(5, 3, 200)

# Single and averaged loci can also be combined arbitrarily:
coal_model(15) + locus_averaged(10, 150) + locus_single(250)
coal_model(15, 10, 150) + locus_single(250) + locus_averaged(10, 350)
</code></pre>

<hr>
<h2 id='locus_trio'>Locus Trios</h2><span id='topic+locus_trio'></span>

<h3>Description</h3>

<p>This functions adds a group of three loci to the model that are genetically
linked to each other. They are still unlinked to all other loci or locus trios
in the model. Simulating linked loci that are far apart from each other can
be very slow. Please mind that mutation and recombination rates for locus
trios are rates per trio and not per locus, i.e. they account for mutations
that occur on the tree loci and the sequences in-between them together.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locus_trio(
  locus_length = c(left = 1000, middle = 1000, right = 1000),
  distance = c(left_middle = 500, middle_right = 500),
  number = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="locus_trio_+3A_locus_length">locus_length</code></td>
<td>
<p>An integer vector of length 3, giving the length of each
of the three loci (left, middle and right).</p>
</td></tr>
<tr><td><code id="locus_trio_+3A_distance">distance</code></td>
<td>
<p>A vector of two, giving the distance between left and middle,
and middle an right locus, in base pairs.</p>
</td></tr>
<tr><td><code id="locus_trio_+3A_number">number</code></td>
<td>
<p>The number of loci to add.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>For adding unlinked loci: <code><a href="#topic+locus">locus</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A model with one locus trio
coal_model(25) +
  locus_trio(locus_length=c(1250, 1017, 980), distance=c(257, 814))

# Ten identical locus trios:
coal_model(25) +
  locus_trio(locus_length=c(1250, 1017, 980), distance=c(257, 814), number = 10)

# Two different ones:
coal_model(25) +
  locus_trio(locus_length=c(1000, 500, 900), distance=c(200, 400)) +
  locus_trio(locus_length=c(700, 500, 800), distance=c(350, 150))
</code></pre>

<hr>
<h2 id='par_variation'>Variable Parameters</h2><span id='topic+par_variation'></span>

<h3>Description</h3>

<p>This function can be used to let the values of a parameter vary between
the different loci. When used, the values for the enclosed parameter
will follow a gamma distribution with mean of the parameters original
value, and the variance specified as argument <code>variance</code>. This requires
that the original value is positive. When using this, the simulators
are called separately for each locus, which can dramatically increase the
time needed to simulate models with many loci.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>par_variation(par, variance)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="par_variation_+3A_par">par</code></td>
<td>
<p>A parameter whichs value will be made variable between the loci.</p>
</td></tr>
<tr><td><code id="par_variation_+3A_variance">variance</code></td>
<td>
<p>The variance of the gamma distribution, which the values used
for simulation will follow.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>For parameters that are identical for all loci: <code><a href="#topic+parameter">parameter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- coal_model(5, 10) +
  feat_mutation(par_variation(par_const(5), 10)) +
  sumstat_nucleotide_div()
simulate(model)
</code></pre>

<hr>
<h2 id='par_zero_inflation'>Zero Inflation for Parameters</h2><span id='topic+par_zero_inflation'></span>

<h3>Description</h3>

<p>This adds a zero inflation to the distribution of a parameter for the
different loci. When using this, each locus will be simulated with a
parameter value of 0 with probability <code>prob</code>, or with parameter's
original value in the remaining cases.
are called separately for each locus, which can dramatically increase the
time needed to simulate models with many loci.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>par_zero_inflation(par, prob, random = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="par_zero_inflation_+3A_par">par</code></td>
<td>
<p>A parameter which will be set to 0 for part of the loci.</p>
</td></tr>
<tr><td><code id="par_zero_inflation_+3A_prob">prob</code></td>
<td>
<p>The probability that the parameters value will be set to <code>0</code>
for each locus if <code>random</code> is <code>TRUE</code>. Otherwise, it's the
fixed fraction of loci which will have a parameter value of <code>0</code>.</p>
</td></tr>
<tr><td><code id="par_zero_inflation_+3A_random">random</code></td>
<td>
<p>Whether the number of loci which are simulated with a value of
<code>0</code> should be random (<code>TRUE</code>) or a fixed fraction (<code>FALSE</code>). See
<code>prob</code> for details.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>For parameters that are identical for all loci: <code><a href="#topic+parameter">parameter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate half of the loci with recomination and the other half without it:
model &lt;- coal_model(4, 4) +
  feat_recombination(par_zero_inflation(par_named("rho"), .5, random = FALSE)) +
  sumstat_trees()
simulate(model, pars = c(rho = 1))

# Use a zero inflated gamma distribution:
model &lt;- coal_model(4, 4) +
  feat_recombination(par_zero_inflation(par_variation(1, 10), .3)) +
  sumstat_trees()
simulate(model)
</code></pre>

<hr>
<h2 id='parameter'>Model Parameters</h2><span id='topic+parameter'></span><span id='topic+par_expr'></span><span id='topic+par_const'></span><span id='topic+par_named'></span><span id='topic+par_range'></span><span id='topic+par_prior'></span>

<h3>Description</h3>

<p>These functions add parameters to a model. Parameters can either
be used in features, or added directly to a model using the plus operator.
The value of parameters can be specified in the simulation command
(for <code>par_named</code> and <code>par_range</code>), sampled from a prior
distribution (<code>par_prior</code>) or can be derived from other parameters
(<code>par_expr</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>par_expr(expr)

par_const(constant)

par_named(name)

par_range(name, lower, upper)

par_prior(name, prior)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parameter_+3A_expr">expr</code></td>
<td>
<p>An R expression.
This allows to define a parameter using an R expression.
It can contain other named parameters (e.g. <code>2 * a</code> will create an
parameter that is twice the value of an existing parameter <code>a</code>).
Make sure that the expression always evaluates
to a valid parameter value (a single numeric in almost all cases).</p>
</td></tr>
<tr><td><code id="parameter_+3A_constant">constant</code></td>
<td>
<p>An R expression.
The constant value of the parameter.
Different to <code>expr</code>, the expression is evaluated immediately and
can not depend on other named parameters.</p>
</td></tr>
<tr><td><code id="parameter_+3A_name">name</code></td>
<td>
<p>Character. The name of the parameter. Must be unique in a model.</p>
</td></tr>
<tr><td><code id="parameter_+3A_lower">lower</code></td>
<td>
<p>A numeric. The lower boundary of the parameter's range.</p>
</td></tr>
<tr><td><code id="parameter_+3A_upper">upper</code></td>
<td>
<p>A numeric. The upper boundary of the parameter's range.</p>
</td></tr>
<tr><td><code id="parameter_+3A_prior">prior</code></td>
<td>
<p>An expression. Evaluation this expression should give
a sample from the prior distribution you want for the parameter.
For example using <code>rnorm(1)</code> gives a standard normal prior.</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>par_expr()</code>: Creates a parameter with value determined by evaluating an expression.
</p>
</li>
<li> <p><code>par_const()</code>: Creates an parameter that is equal to a fixed value.
Different to <code>par_expr</code>, the value is evaluated on parameter creation.
</p>
</li>
<li> <p><code>par_named()</code>: Creates an parameter whose value is specified via the
<code>pars</code> argument in <code><a href="#topic+simulate.coalmodel">simulate.coalmodel</a></code>.
</p>
</li>
<li> <p><code>par_range()</code>: Creates an parameter that can take a range of possible
values.
Similar to <code><a href="#topic+par_named">par_named</a></code>, the value of the parameter
used in a simulation is set via the <code>pars</code> argument.
This is primarily intended for creating model parameters for
<span class="pkg">jaatha</span>.
</p>
</li>
<li> <p><code>par_prior()</code>: Creates a named parameter with a prior
distribution. Before each simulation, the expression for the prior
is evaluated. The resulting value can be used in
<code><a href="#topic+par_expr">par_expr</a></code> under the chosen name.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Paul Staab
</p>


<h3>See Also</h3>

<p>For parameters that variate between the loci in a model:
<code><a href="#topic+par_variation">par_variation</a></code>, <code><a href="#topic+par_zero_inflation">par_zero_inflation</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A parameter (here for the mutation rate) that is always
# equal to '5':
model_base &lt;- coal_model(20, 1) +
  sumstat_nucleotide_div()

model &lt;- model_base +
  feat_mutation(par_const(5))
simulate(model)

# With using a prior:
model &lt;- model_base +
  feat_mutation(par_prior("theta", rnorm(1, 5, .1)))
simulate(model)

# Using a named parater:
model &lt;- model_base +
  feat_mutation(par_named("theta"))
simulate(model, pars = c(theta = 5))

# or similarly a ranged parameter:
model &lt;- model_base +
  feat_mutation(par_range("theta", 1, 10))
simulate(model, pars = c(theta = 5))

# Expressions can be used to derive parameters from
# other parameters:
model &lt;- model_base +
  par_named("theta_half") +
  feat_mutation(par_expr(theta_half * 2))
simulate(model, pars = c(theta_half = 2.5))

model &lt;- model_base +
  par_named("theta_log") +
  feat_mutation(par_expr(exp(theta_log)))
simulate(model, pars = c(theta_log = log(5)))
</code></pre>

<hr>
<h2 id='scale_model'>Function that downscales a coalescent model</h2><span id='topic+scale_model'></span>

<h3>Description</h3>

<p>This function reduces the number of loci in all averaged loci by a
certain factor.
Non-averaged loci as created with <code><a href="#topic+locus_single">locus_single</a></code> are not
modified in any way. This function is primarily designed for jaatha,
and might be unsuitable for other purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_model(model, scaling_factor)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_model_+3A_model">model</code></td>
<td>
<p>The model to downscale</p>
</td></tr>
<tr><td><code id="scale_model_+3A_scaling_factor">scaling_factor</code></td>
<td>
<p>The factor by which the number of loci are reduced.
A value of 2 changes to numbers to half their value (rounded),
a value of 3 to a third an so on.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- coal_model(10, loci_number = 10) + locus_single(100)
model
# Group 1: 10 loci; group 2: 1 locus

model &lt;- scale_model(model, 3)
model
# Group 1: 3 loci; group 2: 1 locus
</code></pre>

<hr>
<h2 id='search_executable'>Search the working directory and the run path for an executable</h2><span id='topic+search_executable'></span>

<h3>Description</h3>

<p>This function tries to find a binary of a given name by looking
in the current working directory and the directories listed in
the $PATH environment variable. If an environment variable with
name equal to to binaries name in upper case is given, it also
tries to use this as path of the binary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search_executable(name, envir_var = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="search_executable_+3A_name">name</code></td>
<td>
<p>The name of the executable to look for</p>
</td></tr>
<tr><td><code id="search_executable_+3A_envir_var">envir_var</code></td>
<td>
<p>the name of the environment variable to use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The complete path of the executable is found, or &quot;NULL&quot; if not.
</p>

<hr>
<h2 id='simulate.coalmodel'>Simulate Data According to a Demographic Model</h2><span id='topic+simulate.coalmodel'></span>

<h3>Description</h3>

<p>This function simulates a model created with <code><a href="#topic+coal_model">coal_model</a></code>.
The model can be extended with features, <code><a href="#topic+parameter">parameter</a>s</code> and
loci. Read the 'coala-introduction' vignette for detailed instructions
on creating and simulating such models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coalmodel'
simulate(object, nsim = 1, seed, ..., pars = numeric(0), cores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.coalmodel_+3A_object">object</code></td>
<td>
<p>The coalescent model to be simulated</p>
</td></tr>
<tr><td><code id="simulate.coalmodel_+3A_nsim">nsim</code></td>
<td>
<p>currently unused</p>
</td></tr>
<tr><td><code id="simulate.coalmodel_+3A_seed">seed</code></td>
<td>
<p>A random seed that is set before simulation.</p>
</td></tr>
<tr><td><code id="simulate.coalmodel_+3A_...">...</code></td>
<td>
<p>currently unused</p>
</td></tr>
<tr><td><code id="simulate.coalmodel_+3A_pars">pars</code></td>
<td>
<p>Values for parameters specified with <code><a href="#topic+par_named">par_named</a></code> or
<code><a href="#topic+par_range">par_range</a></code>. Should be a named numeric vector.</p>
</td></tr>
<tr><td><code id="simulate.coalmodel_+3A_cores">cores</code></td>
<td>
<p>The number of cores that the independent repetitions from
<code>nsim</code> will be distributed on.
Must be <code>1</code> on Windows, and should also be <code>1</code> when using R
in a graphical environment (e.g. Rstudio).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of summary statistics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- coal_model(10, 3) +
  feat_mutation(5) +
  sumstat_sfs() +
  sumstat_tajimas_d()
simulate(model, nsim = 2)

model &lt;- coal_model(c(5,10), 20) +
  feat_pop_merge(par_range('tau', 0.01, 5), 2, 1) +
  feat_mutation(par_range('theta', 1, 10)) +
  sumstat_jsfs()
simulate(model, pars=c(tau = 1, theta = 5))
</code></pre>

<hr>
<h2 id='simulator_ms'>Simulator: ms</h2><span id='topic+simulator_ms'></span><span id='topic+activate_ms'></span>

<h3>Description</h3>

<p>This function adds the simulator 'ms' to the list of available simulators.
In order to use 'ms', you need to install the CRAN package <span class="pkg">phyclust</span>.
By default, 'scrm' will be preferred over 'ms'. Raise the priority of 'ms'
to change this behavior.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>activate_ms(priority = 300)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulator_ms_+3A_priority">priority</code></td>
<td>
<p>The priority for this simulator. If multiple simulators
can simulate a model, the one with the highest priority will be used.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Richard R. Hudson.
Generating samples under a Wright-Fisher neutral model of genetic variation.
Bioinformatics (2002) 18 (2): 337-338
doi:10.1093/bioinformatics/18.2.337
</p>


<h3>See Also</h3>

<p>Other simulators: 
<code><a href="#topic+simulator_msms">simulator_msms</a></code>,
<code><a href="#topic+simulator_scrm">simulator_scrm</a></code>,
<code><a href="#topic+simulator_seqgen">simulator_seqgen</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># To prefer ms to scrm:
## Not run: activate_ms(priority = 500)
</code></pre>

<hr>
<h2 id='simulator_msms'>Simulator: msms</h2><span id='topic+simulator_msms'></span><span id='topic+activate_msms'></span>

<h3>Description</h3>

<p>This adds the simulator 'msms' to the list of available simulators. To add
msms, you need to download the jar file and have Java installed on your
system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>activate_msms(jar = NULL, java = NULL, priority = 200, download = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulator_msms_+3A_jar">jar</code></td>
<td>
<p>The path of the msms jar file.</p>
</td></tr>
<tr><td><code id="simulator_msms_+3A_java">java</code></td>
<td>
<p>The path of the java executable on your system.</p>
</td></tr>
<tr><td><code id="simulator_msms_+3A_priority">priority</code></td>
<td>
<p>The priority for this simulator. If multiple simulators
can simulate a model, the one with the highest priority will be used.</p>
</td></tr>
<tr><td><code id="simulator_msms_+3A_download">download</code></td>
<td>
<p>If set to <code>TRUE</code>, coala will try to download
the msms jar file. In that case, the <code>jar</code> argument
is not required.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Gregory Ewing and Joachim Hermisson.
MSMS: a coalescent simulation program including recombination,
demographic structure and selection at a single locus.
Bioinformatics (2010) 26 (16): 2064-2065
doi:10.1093/bioinformatics/btq322
</p>


<h3>See Also</h3>

<p>Other simulators: 
<code><a href="#topic+simulator_ms">simulator_ms</a></code>,
<code><a href="#topic+simulator_scrm">simulator_scrm</a></code>,
<code><a href="#topic+simulator_seqgen">simulator_seqgen</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Download and activate msms (requires Java)
## Not run: activate_msms(download = TRUE)
</code></pre>

<hr>
<h2 id='simulator_scrm'>Simulator: scrm</h2><span id='topic+simulator_scrm'></span><span id='topic+activate_scrm'></span>

<h3>Description</h3>

<p>This function adds the simulator 'scrm' to the list of available simulators.
It is provided via the CRAN package <span class="pkg">scrm</span> and should be always installed
alongside with <span class="pkg">coala</span>. It should be activated automatically, and this
function is only needed to change it <code>priority</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>activate_scrm(priority = 400)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulator_scrm_+3A_priority">priority</code></td>
<td>
<p>The priority for this simulator. If multiple simulators
can simulate a model, the one with the highest priority will be used.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Paul R. Staab, Sha Zhu, Dirk Metzler and Gerton Lunter (2015).
&quot;scrm: efficiently simulating long sequences using the approximated
coalescent with recombination.&quot;
Bioinformatics, 31(10), pp. 1680-1682.
http://dx.doi.org/10.1093/bioinformatics/btu861
</p>


<h3>See Also</h3>

<p>Other simulators: 
<code><a href="#topic+simulator_ms">simulator_ms</a></code>,
<code><a href="#topic+simulator_msms">simulator_msms</a></code>,
<code><a href="#topic+simulator_seqgen">simulator_seqgen</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Change scrm's priority
model &lt;- coal_model(10, 1) + feat_mutation(5)
model # scrm is used by default
activate_scrm(250)
model # Now ms is used instead (if installed)
activate_scrm(550)
model # Now scrm is used again
</code></pre>

<hr>
<h2 id='simulator_seqgen'>Simulator: seq-gen</h2><span id='topic+simulator_seqgen'></span><span id='topic+activate_seqgen'></span>

<h3>Description</h3>

<p>This allows you to use seq-gen to simulate finite sites mutation models.
When using seq-gen, coala will simulate ancestral tress using the other
simulators, and call seq-gen to simulate finite sites mutations using the
trees. Seq-gen has a low priority, but will always be used when finite
sites mutation models are used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>activate_seqgen(binary = NULL, priority = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulator_seqgen_+3A_binary">binary</code></td>
<td>
<p>The path of the seqgen binary that will be used
for simulations. If none is provided, coala will look for a
binary called 'seqgen' or 'seq-gen' using the PATH variable.</p>
</td></tr>
<tr><td><code id="simulator_seqgen_+3A_priority">priority</code></td>
<td>
<p>The priority for this simulator. If multiple simulators
can simulate a model, the one with the highest priority will be used.</p>
</td></tr>
</table>


<h3>Installation</h3>

<p>You need to download the program from
<a href="http://tree.bio.ed.ac.uk/software/seqgen/">http://tree.bio.ed.ac.uk/software/seqgen/</a>
and compile the binary prior to invoking this function.
On Debian-based systems, you can alternatively install the package
'seg-gen'.
</p>


<h3>References</h3>

<p>Andrew Rambaut and Nicholas C. Grassly.
Seq-Gen: an application for the Monte Carlo simulation of DNA sequence
evolution along phylogenetic trees.
Comput Appl Biosci (1997) 13 (3): 235-238
doi:10.1093/bioinformatics/13.3.235
</p>


<h3>See Also</h3>

<p>Other simulators: 
<code><a href="#topic+simulator_ms">simulator_ms</a></code>,
<code><a href="#topic+simulator_msms">simulator_msms</a></code>,
<code><a href="#topic+simulator_scrm">simulator_scrm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: activate_seqgen("./bin/seqgen")
</code></pre>

<hr>
<h2 id='sumstat_class'>Base Class for Summary Statistics</h2><span id='topic+sumstat_class'></span>

<h3>Description</h3>

<p>Base Class for Summary Statistics
</p>
<p>Base Class for Summary Statistics
</p>


<h3>Details</h3>

<p>If you want to create additional summary statistics for coala, create
<span class="pkg">R6</span> classes that inherit from this object.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+coalmodelpart">coala::coalmodelpart</a></code> -&gt; <code>sumstat</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-sumstat-new"><code>sumstat_class$new()</code></a>
</p>
</li>
<li> <p><a href="#method-sumstat-calculate"><code>sumstat_class$calculate()</code></a>
</p>
</li>
<li> <p><a href="#method-sumstat-check"><code>sumstat_class$check()</code></a>
</p>
</li>
<li> <p><a href="#method-sumstat-get_name"><code>sumstat_class$get_name()</code></a>
</p>
</li>
<li> <p><a href="#method-sumstat-requires_files"><code>sumstat_class$requires_files()</code></a>
</p>
</li>
<li> <p><a href="#method-sumstat-requires_segsites"><code>sumstat_class$requires_segsites()</code></a>
</p>
</li>
<li> <p><a href="#method-sumstat-requires_trees"><code>sumstat_class$requires_trees()</code></a>
</p>
</li>
<li> <p><a href="#method-sumstat-print"><code>sumstat_class$print()</code></a>
</p>
</li>
<li> <p><a href="#method-sumstat-transform"><code>sumstat_class$transform()</code></a>
</p>
</li>
<li> <p><a href="#method-sumstat-clone"><code>sumstat_class$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-sumstat-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialization of $sumstat
</p>


<h5>Usage</h5>

<div class="r"><pre>sumstat_class$new(name, transformation)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>the name to be used for this statistic</p>
</dd>
<dt><code>transformation</code></dt><dd><p>transformation to be used for this statistic</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>NULL
</p>


<hr>
<a id="method-sumstat-calculate"></a>



<h4>Method <code>calculate()</code></h4>

<p>This function must be overwritten in the derived class
</p>


<h5>Usage</h5>

<div class="r"><pre>sumstat_class$calculate(seg_sites, trees, files, model)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>seg_sites</code></dt><dd><p>seg_sites object containing the segregating sites</p>
</dd>
<dt><code>trees</code></dt><dd><p>trees</p>
</dd>
<dt><code>files</code></dt><dd><p>files</p>
</dd>
<dt><code>model</code></dt><dd><p>demographic model</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>NULL
</p>


<hr>
<a id="method-sumstat-check"></a>



<h4>Method <code>check()</code></h4>

<p>Optional functions that checks if a model is compatible with the stat.
</p>
<p>In a derived class this can be overwritten by a function that throws
an informative error if the model is incompatible with the statistic
The function is executed before the statistic is added to the model.
</p>


<h5>Usage</h5>

<div class="r"><pre>sumstat_class$check(model)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>model</code></dt><dd><p>demographic model</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>invisible TRUE
</p>


<hr>
<a id="method-sumstat-get_name"></a>



<h4>Method <code>get_name()</code></h4>

<p>function to read the private attribute name
</p>


<h5>Usage</h5>

<div class="r"><pre>sumstat_class$get_name()</pre></div>



<h5>Returns</h5>

<p>name of the statistic
</p>


<hr>
<a id="method-sumstat-requires_files"></a>



<h4>Method <code>requires_files()</code></h4>

<p>function to check whether files are required by this statsitic
</p>


<h5>Usage</h5>

<div class="r"><pre>sumstat_class$requires_files()</pre></div>



<h5>Returns</h5>

<p>req_files, which is TRUE or FALSE and indicates whether files are required by this statsitic
</p>


<hr>
<a id="method-sumstat-requires_segsites"></a>



<h4>Method <code>requires_segsites()</code></h4>

<p>function to check whether segregating sites are required by this statsitic
</p>


<h5>Usage</h5>

<div class="r"><pre>sumstat_class$requires_segsites()</pre></div>



<h5>Returns</h5>

<p>req_segsites, which is TRUE or FALSE and indicates whether segregating sites are required by this statsiti
</p>


<hr>
<a id="method-sumstat-requires_trees"></a>



<h4>Method <code>requires_trees()</code></h4>

<p>function to check whether trees are required by this statsitic
</p>


<h5>Usage</h5>

<div class="r"><pre>sumstat_class$requires_trees()</pre></div>



<h5>Returns</h5>

<p>req_trees, which is TRUE or FALSE and indicates whether trees are required by this statsitic
</p>


<hr>
<a id="method-sumstat-print"></a>



<h4>Method <code>print()</code></h4>

<p>function to print the class of the statistic
</p>


<h5>Usage</h5>

<div class="r"><pre>sumstat_class$print()</pre></div>


<hr>
<a id="method-sumstat-transform"></a>



<h4>Method <code>transform()</code></h4>

<p>Transformation that is applied to the statistic
</p>


<h5>Usage</h5>

<div class="r"><pre>sumstat_class$transform(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>untransformed value</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>transformed value
</p>


<hr>
<a id="method-sumstat-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>sumstat_class$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='sumstat_dna'>Summary Statistic: DNA</h2><span id='topic+sumstat_dna'></span>

<h3>Description</h3>

<p>This summary statistic returns the actual DNA sequences from
finite sites simulations. It can not be
calculated together with other summary statistics or when assuming
an infinite sites mutation model. No outgroup
is needed for it, and the outgroup sequences will also be
returned if present.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sumstat_dna(name = "dna", transformation = identity)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sumstat_dna_+3A_name">name</code></td>
<td>
<p>The name of the summary statistic. When simulating a model,
the value of the statistics are written to an entry of the returned list
with this name. Summary statistic names must be unique in a model.</p>
</td></tr>
<tr><td><code id="sumstat_dna_+3A_transformation">transformation</code></td>
<td>
<p>An optional function for transforming the results
of the statistic. If specified, the results of the transformation are
returned instead of the original values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of sequences for each locus. Each entries is a
character matrix decoding the sequences. Each row
is an individual, and each column is a genetic position.
</p>


<h3>See Also</h3>

<p>To create a demographic model: <code><a href="#topic+coal_model">coal_model</a></code>
</p>
<p>To calculate this statistic from data: <code><a href="#topic+calc_sumstats_from_data">calc_sumstats_from_data</a></code>
</p>
<p>Other summary statistics: 
<code><a href="#topic+sumstat_file">sumstat_file</a>()</code>,
<code><a href="#topic+sumstat_four_gamete">sumstat_four_gamete</a>()</code>,
<code><a href="#topic+sumstat_ihh">sumstat_ihh</a>()</code>,
<code><a href="#topic+sumstat_jsfs">sumstat_jsfs</a>()</code>,
<code><a href="#topic+sumstat_mcmf">sumstat_mcmf</a>()</code>,
<code><a href="#topic+sumstat_nucleotide_div">sumstat_nucleotide_div</a>()</code>,
<code><a href="#topic+sumstat_omega">sumstat_omega</a>()</code>,
<code><a href="#topic+sumstat_seg_sites">sumstat_seg_sites</a>()</code>,
<code><a href="#topic+sumstat_sfs">sumstat_sfs</a>()</code>,
<code><a href="#topic+sumstat_tajimas_d">sumstat_tajimas_d</a>()</code>,
<code><a href="#topic+sumstat_trees">sumstat_trees</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- coal_model(5, 1, 10) +
 feat_mutation(5, model = "GTR", gtr_rates = rep(1, 6)) +
 sumstat_dna()
## Not run: simulate(model)$dna
</code></pre>

<hr>
<h2 id='sumstat_file'>Summary Statistic: Files</h2><span id='topic+sumstat_file'></span>

<h3>Description</h3>

<p>This &quot;summary statistic&quot; returns files with the raw results of
the simulation. Multiple files are returned in case coala needs
multiple calls to simulators to simulate the model. These files
do not contain any post processing of the results done by coala,
e.g. <code><a href="#topic+feat_unphased">feat_unphased</a></code> and
<code><a href="#topic+feat_ignore_singletons">feat_ignore_singletons</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sumstat_file(folder)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sumstat_file_+3A_folder">folder</code></td>
<td>
<p>The path to a folder. The files will be created there.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector containing the files in order in which they
where created.
</p>


<h3>See Also</h3>

<p>To create a demographic model: <code><a href="#topic+coal_model">coal_model</a></code>
</p>
<p>To calculate this statistic from data: <code><a href="#topic+calc_sumstats_from_data">calc_sumstats_from_data</a></code>
</p>
<p>Other summary statistics: 
<code><a href="#topic+sumstat_dna">sumstat_dna</a>()</code>,
<code><a href="#topic+sumstat_four_gamete">sumstat_four_gamete</a>()</code>,
<code><a href="#topic+sumstat_ihh">sumstat_ihh</a>()</code>,
<code><a href="#topic+sumstat_jsfs">sumstat_jsfs</a>()</code>,
<code><a href="#topic+sumstat_mcmf">sumstat_mcmf</a>()</code>,
<code><a href="#topic+sumstat_nucleotide_div">sumstat_nucleotide_div</a>()</code>,
<code><a href="#topic+sumstat_omega">sumstat_omega</a>()</code>,
<code><a href="#topic+sumstat_seg_sites">sumstat_seg_sites</a>()</code>,
<code><a href="#topic+sumstat_sfs">sumstat_sfs</a>()</code>,
<code><a href="#topic+sumstat_tajimas_d">sumstat_tajimas_d</a>()</code>,
<code><a href="#topic+sumstat_trees">sumstat_trees</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>folder &lt;- tempfile("coala-test")
model &lt;- coal_model(10, 1) +
  feat_mutation(5) +
  sumstat_file(folder)
simulate(model)$file

unlink(folder, recursive = TRUE)  # Clean up
</code></pre>

<hr>
<h2 id='sumstat_four_gamete'>Summary Statistic: Four-Gamete-Condition</h2><span id='topic+sumstat_four_gamete'></span>

<h3>Description</h3>

<p>This summary statistic calculates a number of values (see 'Value')
related to the Four-Gamete-Condition (see 'Details').
It is sensitive for recombination and particularly useful when estimating
recombination rates with <span class="pkg">jaatha</span> or Approximate Bayesian Computation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sumstat_four_gamete(
  name = "four_gamete",
  population = 1,
  transformation = identity,
  na.rm = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sumstat_four_gamete_+3A_name">name</code></td>
<td>
<p>The name of the summary statistic. When simulating a model,
the value of the statistics are written to an entry of the returned list
with this name. Summary statistic names must be unique in a model.</p>
</td></tr>
<tr><td><code id="sumstat_four_gamete_+3A_population">population</code></td>
<td>
<p>The population for which the statistic is calculated.
Can also be &quot;all&quot; to calculate it from all populations. Default is population 1.</p>
</td></tr>
<tr><td><code id="sumstat_four_gamete_+3A_transformation">transformation</code></td>
<td>
<p>An optional function for transforming the results
of the statistic. If specified, the results of the transformation are
returned instead of the original values.</p>
</td></tr>
<tr><td><code id="sumstat_four_gamete_+3A_na.rm">na.rm</code></td>
<td>
<p>should missing data be ignored? Default is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Four-Gamete-Condition for two SNPs is violated if all four combinations
of derived and ancestral alleles at the SNPs are observed in a gamete/a
haplotype. Under an Infinite-Sites mutation model, a violation indicates that
there must have been at least one recombination event between the SNPs.
</p>


<h3>Value</h3>

<p>The statistic generates a matrix where each row represents one locus, and
the columns give the statistic for different classes of pairs of SNPs:
</p>

<dl>
<dt>mid_near</dt><dd><p>The value for all pairs of SNPs that are close together,
that is within 10 percent of the locus&quot; length. If locus trios are used,
only pairs of SNPs were both SNPs are on the middle locus are considered.
</p>
</dd>
<dt>mid_far</dt><dd><p>Same as <code>mid_near</code>, but for pairs of SNPs that are
more that 10 percent of the locus&quot; length apart. </p>
</dd>
<dt>outer</dt><dd><p>Only when using locus trios. The statistic for pairs
where both SNPs are on the same outer locus.</p>
</dd>
<dt>between</dt><dd><p>Only when using locus trios. The statistic for pairs
where one SNPs is on the middle locus, and the other is on an outer one.</p>
</dd>
<dt>mid</dt><dd><p>The value for all pairs on the
middle locus or all pairs when not using trios.</p>
</dd>
<dt>perc_polym</dt><dd><p>The percentage of positions that are polymorpic.</p>
</dd>
</dl>



<h3>Unphased Data</h3>

<p>For unphased data, the four gamete condition is only counted as violated if
it is violated for all possible phasing of the data.
</p>


<h3>See Also</h3>

<p>To create a demographic model: <code><a href="#topic+coal_model">coal_model</a></code>
</p>
<p>To calculate this statistic from data: <code><a href="#topic+calc_sumstats_from_data">calc_sumstats_from_data</a></code>
</p>
<p>Other summary statistics: 
<code><a href="#topic+sumstat_dna">sumstat_dna</a>()</code>,
<code><a href="#topic+sumstat_file">sumstat_file</a>()</code>,
<code><a href="#topic+sumstat_ihh">sumstat_ihh</a>()</code>,
<code><a href="#topic+sumstat_jsfs">sumstat_jsfs</a>()</code>,
<code><a href="#topic+sumstat_mcmf">sumstat_mcmf</a>()</code>,
<code><a href="#topic+sumstat_nucleotide_div">sumstat_nucleotide_div</a>()</code>,
<code><a href="#topic+sumstat_omega">sumstat_omega</a>()</code>,
<code><a href="#topic+sumstat_seg_sites">sumstat_seg_sites</a>()</code>,
<code><a href="#topic+sumstat_sfs">sumstat_sfs</a>()</code>,
<code><a href="#topic+sumstat_tajimas_d">sumstat_tajimas_d</a>()</code>,
<code><a href="#topic+sumstat_trees">sumstat_trees</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- coal_model(5, 2) +
 feat_mutation(50) +
 feat_recombination(10) +
 sumstat_four_gamete()
stats &lt;- simulate(model)
print(stats$four_gamete)
</code></pre>

<hr>
<h2 id='sumstat_ihh'>Summary Statistic: Integrated Extended Haplotype Homozygosity</h2><span id='topic+sumstat_ihh'></span>

<h3>Description</h3>

<p>This summary statistic calculates a number of values based on
extended haplotype homozygosity (EHH), including iHH, iES
and optionally iHS.
Coala relies on <code><a href="rehh.html#topic+scan_hh">scan_hh</a></code> from package <span class="pkg">rehh</span> to
calculate this statistic. Please refer
to their documentation for detailed information on the implementation.
Please cite the corresponding publication (see below) if you use the
statistic for a publication.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sumstat_ihh(
  name = "ihh",
  population = 1,
  max_snps = 1000,
  calc_ihs = FALSE,
  transformation = identity
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sumstat_ihh_+3A_name">name</code></td>
<td>
<p>The name of the summary statistic. When simulating a model,
the value of the statistics are written to an entry of the returned list
with this name. Summary statistic names must be unique in a model.</p>
</td></tr>
<tr><td><code id="sumstat_ihh_+3A_population">population</code></td>
<td>
<p>The population for which the statistic is calculated.
Can also be &quot;all&quot; to calculate it from all populations. Default is population 1.</p>
</td></tr>
<tr><td><code id="sumstat_ihh_+3A_max_snps">max_snps</code></td>
<td>
<p>The maximal number of SNPs per locus that are used for the
calculation. If a locus has more SNPs, only a random subset of them will
be used to increase performance. Set to <code>Inf</code> to use all SNPs.</p>
</td></tr>
<tr><td><code id="sumstat_ihh_+3A_calc_ihs">calc_ihs</code></td>
<td>
<p>If set to <code>TRUE</code>, additionally standardized iHS is
calculated.</p>
</td></tr>
<tr><td><code id="sumstat_ihh_+3A_transformation">transformation</code></td>
<td>
<p>An optional function for transforming the results
of the statistic. If specified, the results of the transformation are
returned instead of the original values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>calc_ihs = FALSE</code>, a data.frame with values for
iHH and iES is returned. Otherwise, a list of two data frames are
returned, one for IHH and IES values and the other one for IHS values.
</p>
<p>In all <code>data.frames</code> rows are SNPs and the columns present the following
values for each SNP:
</p>

<ul>
<li><p>CHR: The SNP's locus
</p>
</li>
<li><p>POSITION: The SNP's absolute position on its locus
</p>
</li>
<li><p>FREQ_A: The frequency of the ancestral allele
</p>
</li>
<li><p>FREQ_D: The frequency of the derived allele
</p>
</li>
<li><p>IHH_A: integrated EHH for the ancestral allele
</p>
</li>
<li><p>IHH_D: integrated EHH for the derived allele
</p>
</li>
<li><p>IES: integrated EHHS
</p>
</li>
<li><p>INES: integrated normalized EHHS
</p>
</li>
<li><p>IHS: iHS, normalized over all loci.
</p>
</li></ul>



<h3>References</h3>


<ul>
<li><p>Mathieu Gautier and Renaud Vitalis, rehh: an R package to detect
footprints of selection in genome-wide SNP data from
haplotype structure. Bioinformatics (2012) 28 (8): 1176-1177
first published online March 7, 2012 doi:10.1093/bioinformatics/bts115
</p>
</li>
<li><p>Voight et al., A map of recent positive selection in the human
genome. PLoS Biol, 4(3):e72, Mar 2006.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Paul Staab
</p>


<h3>See Also</h3>

<p>To create a demographic model: <code><a href="#topic+coal_model">coal_model</a></code>
</p>
<p>To calculate this statistic from data: <code><a href="#topic+calc_sumstats_from_data">calc_sumstats_from_data</a></code>
</p>
<p>Other summary statistics: 
<code><a href="#topic+sumstat_dna">sumstat_dna</a>()</code>,
<code><a href="#topic+sumstat_file">sumstat_file</a>()</code>,
<code><a href="#topic+sumstat_four_gamete">sumstat_four_gamete</a>()</code>,
<code><a href="#topic+sumstat_jsfs">sumstat_jsfs</a>()</code>,
<code><a href="#topic+sumstat_mcmf">sumstat_mcmf</a>()</code>,
<code><a href="#topic+sumstat_nucleotide_div">sumstat_nucleotide_div</a>()</code>,
<code><a href="#topic+sumstat_omega">sumstat_omega</a>()</code>,
<code><a href="#topic+sumstat_seg_sites">sumstat_seg_sites</a>()</code>,
<code><a href="#topic+sumstat_sfs">sumstat_sfs</a>()</code>,
<code><a href="#topic+sumstat_tajimas_d">sumstat_tajimas_d</a>()</code>,
<code><a href="#topic+sumstat_trees">sumstat_trees</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  model &lt;- coal_model(20, 1, 1000) +
    feat_mutation(1000) +
    sumstat_ihh()

    stat &lt;- simulate(model)
    print(stat$ihh)
</code></pre>

<hr>
<h2 id='sumstat_jsfs'>Summary Statistic: Joint Site Frequency Spectrum</h2><span id='topic+sumstat_jsfs'></span>

<h3>Description</h3>

<p>The summary statistic calculates the joint site frequency
spectrum (JSFS) for multiple populations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sumstat_jsfs(
  name = "jsfs",
  populations = c(1, 2),
  per_locus = FALSE,
  transformation = identity
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sumstat_jsfs_+3A_name">name</code></td>
<td>
<p>The name of the summary statistic. When simulating a model,
the value of the statistics are written to an entry of the returned list
with this name. Summary statistic names must be unique in a model.</p>
</td></tr>
<tr><td><code id="sumstat_jsfs_+3A_populations">populations</code></td>
<td>
<p>An integer vector containing the populations for which
the JSFS is generated.</p>
</td></tr>
<tr><td><code id="sumstat_jsfs_+3A_per_locus">per_locus</code></td>
<td>
<p>If <code>TRUE</code>, the JSFS is returned for each locus instead
of globally. In this case, the result is a list, where each entry is the
JSFS for the corresponding locus.</p>
</td></tr>
<tr><td><code id="sumstat_jsfs_+3A_transformation">transformation</code></td>
<td>
<p>An optional function for transforming the results
of the statistic. If specified, the results of the transformation are
returned instead of the original values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The JSFS, given as an array. The dimensions correspond to the
populations as given in the <code>populations</code> argument.
</p>


<h3>See Also</h3>

<p>To create a demographic model: <code><a href="#topic+coal_model">coal_model</a></code>
</p>
<p>To calculate this statistic from data: <code><a href="#topic+calc_sumstats_from_data">calc_sumstats_from_data</a></code>
</p>
<p>Other summary statistics: 
<code><a href="#topic+sumstat_dna">sumstat_dna</a>()</code>,
<code><a href="#topic+sumstat_file">sumstat_file</a>()</code>,
<code><a href="#topic+sumstat_four_gamete">sumstat_four_gamete</a>()</code>,
<code><a href="#topic+sumstat_ihh">sumstat_ihh</a>()</code>,
<code><a href="#topic+sumstat_mcmf">sumstat_mcmf</a>()</code>,
<code><a href="#topic+sumstat_nucleotide_div">sumstat_nucleotide_div</a>()</code>,
<code><a href="#topic+sumstat_omega">sumstat_omega</a>()</code>,
<code><a href="#topic+sumstat_seg_sites">sumstat_seg_sites</a>()</code>,
<code><a href="#topic+sumstat_sfs">sumstat_sfs</a>()</code>,
<code><a href="#topic+sumstat_tajimas_d">sumstat_tajimas_d</a>()</code>,
<code><a href="#topic+sumstat_trees">sumstat_trees</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- coal_model(c(2, 3, 4), 2) +
  feat_mutation(5) +
  feat_migration(1, symmetric = TRUE) +
  sumstat_jsfs("jsfs_12", populations = c(1, 2)) +
  sumstat_jsfs("jsfs_123", populations = c(1, 2, 3))
stats &lt;- simulate(model)
print(stats$jsfs_12)
print(stats$jsfs_123)
</code></pre>

<hr>
<h2 id='sumstat_mcmf'>Summary Statistic: Most Common Mutation's Frequency</h2><span id='topic+sumstat_mcmf'></span>

<h3>Description</h3>

<p>This summary statistic calculates the observed frequency
of the mutational pattern that is observed most often in
the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sumstat_mcmf(
  name = "mcmf",
  population = 1,
  transformation = identity,
  expand_mcmf = FALSE,
  type_expand = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sumstat_mcmf_+3A_name">name</code></td>
<td>
<p>The name of the summary statistic. When simulating
a model, the value of the statistics are written to an entry
of the returned list with this name. Summary statistic names
must be unique in a model.</p>
</td></tr>
<tr><td><code id="sumstat_mcmf_+3A_population">population</code></td>
<td>
<p>The population for which the statistic is
calculated. Can also be &quot;all&quot; to calculate it from all populations.</p>
</td></tr>
<tr><td><code id="sumstat_mcmf_+3A_transformation">transformation</code></td>
<td>
<p>An optional function for transforming
the results of the statistic. If specified, the results of the
transformation are returned instead of the original values.</p>
</td></tr>
<tr><td><code id="sumstat_mcmf_+3A_expand_mcmf">expand_mcmf</code></td>
<td>
<p>Whether to use or not the expanded MCMF. See Details</p>
</td></tr>
<tr><td><code id="sumstat_mcmf_+3A_type_expand">type_expand</code></td>
<td>
<p>Specifies the type of expanded MCMF to be used. See Details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The expand_mcmf = FALSE calculates the mcmf per locus
and returns a vector. The expand_mcmf = TRUE and type_expand = 1
returns the same results as the first column of a Matrix. The
expand_mcmf = TRUE and type_expand = 2 adds the frequency of
derived alleles in the most frequently observed mutational pattern
as a second column. The expand_mcmf = TRUE and type_expand = 3 adds
the percentage of positions that are polymorpic. When
expanded_mcmf = TRUE results are returned as a matrix.
</p>


<h3>Value</h3>

<p>A numeric vector or matrix containing MCMF for each locus.
</p>

<dl>
<dt>mcmf</dt><dd><p>The observed frequency of the mutational pattern
that is observed most often in the data.</p>
</dd>
<dt>bal</dt><dd><p>The frequency of derived alleles in the most
frequently observed mutational pattern.</p>
</dd>
<dt>perc_poly</dt><dd><p>The percentage of positions that are polymorpic.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>To create a demographic model: <code><a href="#topic+coal_model">coal_model</a></code>
</p>
<p>To calculate this statistic from data: <code><a href="#topic+calc_sumstats_from_data">calc_sumstats_from_data</a></code>
</p>
<p>Other summary statistics: 
<code><a href="#topic+sumstat_dna">sumstat_dna</a>()</code>,
<code><a href="#topic+sumstat_file">sumstat_file</a>()</code>,
<code><a href="#topic+sumstat_four_gamete">sumstat_four_gamete</a>()</code>,
<code><a href="#topic+sumstat_ihh">sumstat_ihh</a>()</code>,
<code><a href="#topic+sumstat_jsfs">sumstat_jsfs</a>()</code>,
<code><a href="#topic+sumstat_nucleotide_div">sumstat_nucleotide_div</a>()</code>,
<code><a href="#topic+sumstat_omega">sumstat_omega</a>()</code>,
<code><a href="#topic+sumstat_seg_sites">sumstat_seg_sites</a>()</code>,
<code><a href="#topic+sumstat_sfs">sumstat_sfs</a>()</code>,
<code><a href="#topic+sumstat_tajimas_d">sumstat_tajimas_d</a>()</code>,
<code><a href="#topic+sumstat_trees">sumstat_trees</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculate MCMF for a panmictic population
model &lt;- coal_model(10, 2) +
  feat_mutation(50) +
  sumstat_mcmf()
simulate(model)
</code></pre>

<hr>
<h2 id='sumstat_nucleotide_div'>Summary Statistic: Nucleotide Diversity</h2><span id='topic+sumstat_nucleotide_div'></span>

<h3>Description</h3>

<p>The summary statistic calculates the nucleotide diversity (<code class="reqn">\pi</code>)
per locus, which is the mean number of pairwise difference for
two individuals. It is a commonly used estimator for the scaled
mutation rate <code class="reqn">\theta</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sumstat_nucleotide_div(name = "pi", population = 1, transformation = identity)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sumstat_nucleotide_div_+3A_name">name</code></td>
<td>
<p>The name of the summary statistic. When simulating a model,
the value of the statistics are written to an entry of the returned list
with this name. Summary statistic names must be unique in a model.</p>
</td></tr>
<tr><td><code id="sumstat_nucleotide_div_+3A_population">population</code></td>
<td>
<p>The population for which the statistic is calculated.
Can also be &quot;all&quot; to calculate it from all populations. Default is population 1.</p>
</td></tr>
<tr><td><code id="sumstat_nucleotide_div_+3A_transformation">transformation</code></td>
<td>
<p>An optional function for transforming the results
of the statistic. If specified, the results of the transformation are
returned instead of the original values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The nucleotide diversity was introduced by
</p>
<p>Nei and Li (1979). &quot;Mathematical Model for Studying Genetic Variation in
Terms of Restriction Endonucleases&quot;. PNAS 76 (10): 5269-73.
doi:10.1073/pnas.76.10.5269.
</p>


<h3>Value</h3>

<p>On simulation, this returns a vector with the value of pi for
each locus.
</p>


<h3>See Also</h3>

<p>To create a demographic model: <code><a href="#topic+coal_model">coal_model</a></code>
</p>
<p>To calculate this statistic from data: <code><a href="#topic+calc_sumstats_from_data">calc_sumstats_from_data</a></code>
</p>
<p>Other summary statistics: 
<code><a href="#topic+sumstat_dna">sumstat_dna</a>()</code>,
<code><a href="#topic+sumstat_file">sumstat_file</a>()</code>,
<code><a href="#topic+sumstat_four_gamete">sumstat_four_gamete</a>()</code>,
<code><a href="#topic+sumstat_ihh">sumstat_ihh</a>()</code>,
<code><a href="#topic+sumstat_jsfs">sumstat_jsfs</a>()</code>,
<code><a href="#topic+sumstat_mcmf">sumstat_mcmf</a>()</code>,
<code><a href="#topic+sumstat_omega">sumstat_omega</a>()</code>,
<code><a href="#topic+sumstat_seg_sites">sumstat_seg_sites</a>()</code>,
<code><a href="#topic+sumstat_sfs">sumstat_sfs</a>()</code>,
<code><a href="#topic+sumstat_tajimas_d">sumstat_tajimas_d</a>()</code>,
<code><a href="#topic+sumstat_trees">sumstat_trees</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- coal_model(5, 2) +
  feat_mutation(5) +
  sumstat_nucleotide_div()
stats &lt;- simulate(model)
print(stats$pi)
</code></pre>

<hr>
<h2 id='sumstat_omega'>Summary Statistic: Omega</h2><span id='topic+sumstat_omega'></span>

<h3>Description</h3>

<p>Calculates the Omega Statistic introduced by
Kim &amp; Nielsen (2004) from the simulated data. The statistic is sensitive for
hard selective sweeps. To calculate
the statistic, coala relies on the command line program
<a href="http://sco.h-its.org/exelixis/web/software/omegaplus/index.html">OmegaPlus</a>,
which needs to be downloaded and compiled manually in order to use the
statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sumstat_omega(
  name = "omega",
  min_win = 100,
  max_win = 1000,
  grid = 1000,
  binary = "automatic",
  transformation = identity
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sumstat_omega_+3A_name">name</code></td>
<td>
<p>The name of the summary statistic. When simulating a model,
the value of the statistics are written to an entry of the returned list
with this name. Summary statistic names must be unique in a model.</p>
</td></tr>
<tr><td><code id="sumstat_omega_+3A_min_win">min_win</code></td>
<td>
<p>The minimum distance from the grid point that a SNP must have
to be included in the calculation of omega.</p>
</td></tr>
<tr><td><code id="sumstat_omega_+3A_max_win">max_win</code></td>
<td>
<p>The maximum distance from the grid point that a SNP must have
to be included in the calculation of omega.</p>
</td></tr>
<tr><td><code id="sumstat_omega_+3A_grid">grid</code></td>
<td>
<p>The number of points for which omega is calculated on each
locus. Should be significantly lower than the locus length.</p>
</td></tr>
<tr><td><code id="sumstat_omega_+3A_binary">binary</code></td>
<td>
<p>The path of the binary for OmegaPlus. If set to &quot;automatic&quot;,
coala will try to find a binary called &quot;OmegaPlus&quot; using the PATH
environment variable.</p>
</td></tr>
<tr><td><code id="sumstat_omega_+3A_transformation">transformation</code></td>
<td>
<p>An optional function for transforming the results
of the statistic. If specified, the results of the transformation are
returned instead of the original values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame listing of locus, genetic position and the
calculated omega value.
</p>


<h3>References</h3>

<p>Linkage disequilibrium as a signature of selective sweeps.
Y. Kim and R. Nielsen (2004). Genetics, 167, 1513-1524.
</p>
<p>OmegaPlus: a scalable tool for rapid detection of selective
sweeps in whole-genome datasets.
N. Alachiotis, A. Stamatakis and P. Pavlidis (2012).
Bioinformatics Vol. 28 no. 17 2012, pages 2274-2275
doi:10.1093/bioinformatics/bts419
</p>


<h3>See Also</h3>

<p>To create a demographic model: <code><a href="#topic+coal_model">coal_model</a></code>
</p>
<p>To calculate this statistic from data: <code><a href="#topic+calc_sumstats_from_data">calc_sumstats_from_data</a></code>
</p>
<p>Other summary statistics: 
<code><a href="#topic+sumstat_dna">sumstat_dna</a>()</code>,
<code><a href="#topic+sumstat_file">sumstat_file</a>()</code>,
<code><a href="#topic+sumstat_four_gamete">sumstat_four_gamete</a>()</code>,
<code><a href="#topic+sumstat_ihh">sumstat_ihh</a>()</code>,
<code><a href="#topic+sumstat_jsfs">sumstat_jsfs</a>()</code>,
<code><a href="#topic+sumstat_mcmf">sumstat_mcmf</a>()</code>,
<code><a href="#topic+sumstat_nucleotide_div">sumstat_nucleotide_div</a>()</code>,
<code><a href="#topic+sumstat_seg_sites">sumstat_seg_sites</a>()</code>,
<code><a href="#topic+sumstat_sfs">sumstat_sfs</a>()</code>,
<code><a href="#topic+sumstat_tajimas_d">sumstat_tajimas_d</a>()</code>,
<code><a href="#topic+sumstat_trees">sumstat_trees</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
model &lt;- coal_model(20, 1, 50000) +
  feat_recombination(50) +
  feat_mutation(1000) +
  feat_selection(strength_A = 1000, time = 0.03) +
  sumstat_omega()
stats &lt;- simulate(model)
plot(stats$omega$omega, type = "l")
## End(Not run)
</code></pre>

<hr>
<h2 id='sumstat_seg_sites'>Summary Statistic: Segregating Sites</h2><span id='topic+sumstat_seg_sites'></span>

<h3>Description</h3>

<p>This summary statistics generates a matrix of segregating sites.
This is useful for calculating summary statistics that <span class="pkg">coala</span>
does not support..
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sumstat_seg_sites(name = "seg_sites", transformation = identity)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sumstat_seg_sites_+3A_name">name</code></td>
<td>
<p>The name of the summary statistic. When simulating a model,
the value of the statistics are written to an entry of the returned list
with this name. Summary statistic names must be unique in a model.</p>
</td></tr>
<tr><td><code id="sumstat_seg_sites_+3A_transformation">transformation</code></td>
<td>
<p>An optional function for transforming the results
of the statistic. If specified, the results of the transformation are
returned instead of the original values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code><a href="#topic+create_segsites">segsites</a></code> objects.
These can be treated as a matrix for
most applications. Rows are individuals, columns are SNPs.
</p>


<h3>See Also</h3>

<p>For a description of the segregating sites class: <code><a href="#topic+create_segsites">create_segsites</a></code>
</p>
<p>To create a demographic model: <code><a href="#topic+coal_model">coal_model</a></code>
</p>
<p>To calculate this statistic from data: <code><a href="#topic+calc_sumstats_from_data">calc_sumstats_from_data</a></code>
</p>
<p>Other summary statistics: 
<code><a href="#topic+sumstat_dna">sumstat_dna</a>()</code>,
<code><a href="#topic+sumstat_file">sumstat_file</a>()</code>,
<code><a href="#topic+sumstat_four_gamete">sumstat_four_gamete</a>()</code>,
<code><a href="#topic+sumstat_ihh">sumstat_ihh</a>()</code>,
<code><a href="#topic+sumstat_jsfs">sumstat_jsfs</a>()</code>,
<code><a href="#topic+sumstat_mcmf">sumstat_mcmf</a>()</code>,
<code><a href="#topic+sumstat_nucleotide_div">sumstat_nucleotide_div</a>()</code>,
<code><a href="#topic+sumstat_omega">sumstat_omega</a>()</code>,
<code><a href="#topic+sumstat_sfs">sumstat_sfs</a>()</code>,
<code><a href="#topic+sumstat_tajimas_d">sumstat_tajimas_d</a>()</code>,
<code><a href="#topic+sumstat_trees">sumstat_trees</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- coal_model(5, 1) +
  feat_mutation(5) +
  sumstat_seg_sites("segsites")
stats &lt;- simulate(model)
print(stats$segsites)
</code></pre>

<hr>
<h2 id='sumstat_sfs'>Summary Statistic: Site Frequency Spectrum</h2><span id='topic+sumstat_sfs'></span>

<h3>Description</h3>

<p>The Site Frequency Spectrum (SFS) counts how many
SNPs are in a sample according to their number of
derived alleles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sumstat_sfs(name = "sfs", population = "all", transformation = identity)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sumstat_sfs_+3A_name">name</code></td>
<td>
<p>The name of the summary statistic. When simulating a model,
the value of the statistics are written to an entry of the returned list
with this name. Summary statistic names must be unique in a model.</p>
</td></tr>
<tr><td><code id="sumstat_sfs_+3A_population">population</code></td>
<td>
<p>The population for which the statistic is calculated.
Can also be &quot;all&quot; to calculate it from all populations. Default is population 1.</p>
</td></tr>
<tr><td><code id="sumstat_sfs_+3A_transformation">transformation</code></td>
<td>
<p>An optional function for transforming the results
of the statistic. If specified, the results of the transformation are
returned instead of the original values.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>To create a demographic model: <code><a href="#topic+coal_model">coal_model</a></code>
</p>
<p>To calculate this statistic from data: <code><a href="#topic+calc_sumstats_from_data">calc_sumstats_from_data</a></code>
</p>
<p>Other summary statistics: 
<code><a href="#topic+sumstat_dna">sumstat_dna</a>()</code>,
<code><a href="#topic+sumstat_file">sumstat_file</a>()</code>,
<code><a href="#topic+sumstat_four_gamete">sumstat_four_gamete</a>()</code>,
<code><a href="#topic+sumstat_ihh">sumstat_ihh</a>()</code>,
<code><a href="#topic+sumstat_jsfs">sumstat_jsfs</a>()</code>,
<code><a href="#topic+sumstat_mcmf">sumstat_mcmf</a>()</code>,
<code><a href="#topic+sumstat_nucleotide_div">sumstat_nucleotide_div</a>()</code>,
<code><a href="#topic+sumstat_omega">sumstat_omega</a>()</code>,
<code><a href="#topic+sumstat_seg_sites">sumstat_seg_sites</a>()</code>,
<code><a href="#topic+sumstat_tajimas_d">sumstat_tajimas_d</a>()</code>,
<code><a href="#topic+sumstat_trees">sumstat_trees</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- coal_model(20, 500) +
  feat_mutation(2) +
  sumstat_sfs()
stats &lt;- simulate(model)
barplot(stats$sfs)
</code></pre>

<hr>
<h2 id='sumstat_tajimas_d'>Summary Statistic: Tajima's D</h2><span id='topic+sumstat_tajimas_d'></span>

<h3>Description</h3>

<p>This statistic calculates Tajima's D from the simulation
results when added to a model. Tajima's D primarily measures
an deviation of singletons from the neutral expectation of
an equilibrium model. Negative values indicate an excess of
singletons, while positive values code a depletion of them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sumstat_tajimas_d(
  name = "tajimas_d",
  population = "all",
  transformation = identity
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sumstat_tajimas_d_+3A_name">name</code></td>
<td>
<p>The name of the summary statistic. When simulating a model,
the value of the statistics are written to an entry of the returned list
with this name. Summary statistic names must be unique in a model.</p>
</td></tr>
<tr><td><code id="sumstat_tajimas_d_+3A_population">population</code></td>
<td>
<p>The population for which the statistic is calculated.
Can also be &quot;all&quot; to calculate it from all populations. Default is population 1.</p>
</td></tr>
<tr><td><code id="sumstat_tajimas_d_+3A_transformation">transformation</code></td>
<td>
<p>An optional function for transforming the results
of the statistic. If specified, the results of the transformation are
returned instead of the original values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>On simulation, this returns a vector with the value of Tajima's D for
each locus.
</p>


<h3>References</h3>

<p>Tajima, F. (1989). &quot;Statistical method for testing the neutral mutation
hypothesis by DNA polymorphism.&quot;. Genetics 123 (3): 585-95.
</p>


<h3>See Also</h3>

<p>To create a demographic model: <code><a href="#topic+coal_model">coal_model</a></code>
</p>
<p>To calculate this statistic from data: <code><a href="#topic+calc_sumstats_from_data">calc_sumstats_from_data</a></code>
</p>
<p>Other summary statistics: 
<code><a href="#topic+sumstat_dna">sumstat_dna</a>()</code>,
<code><a href="#topic+sumstat_file">sumstat_file</a>()</code>,
<code><a href="#topic+sumstat_four_gamete">sumstat_four_gamete</a>()</code>,
<code><a href="#topic+sumstat_ihh">sumstat_ihh</a>()</code>,
<code><a href="#topic+sumstat_jsfs">sumstat_jsfs</a>()</code>,
<code><a href="#topic+sumstat_mcmf">sumstat_mcmf</a>()</code>,
<code><a href="#topic+sumstat_nucleotide_div">sumstat_nucleotide_div</a>()</code>,
<code><a href="#topic+sumstat_omega">sumstat_omega</a>()</code>,
<code><a href="#topic+sumstat_seg_sites">sumstat_seg_sites</a>()</code>,
<code><a href="#topic+sumstat_sfs">sumstat_sfs</a>()</code>,
<code><a href="#topic+sumstat_trees">sumstat_trees</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A neutral model that should yield values close to zero:
model &lt;- coal_model(5, 2) +
  feat_mutation(20) +
  feat_recombination(10) +
  sumstat_tajimas_d("taji_d")
stats &lt;- simulate(model)
print(stats$taji_d)
</code></pre>

<hr>
<h2 id='sumstat_trees'>Summary Statistic: Ancestral Trees</h2><span id='topic+sumstat_trees'></span>

<h3>Description</h3>

<p>This statistic returns ancestral tress in NEWICK format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sumstat_trees(name = "trees")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sumstat_trees_+3A_name">name</code></td>
<td>
<p>The name of the summary statistic. When simulating a model,
the value of the statistics are written to an entry of the returned list
with this name. Summary statistic names must be unique in a model.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>To create a demographic model: <code><a href="#topic+coal_model">coal_model</a></code>
</p>
<p>To calculate this statistic from data: <code><a href="#topic+calc_sumstats_from_data">calc_sumstats_from_data</a></code>
</p>
<p>Other summary statistics: 
<code><a href="#topic+sumstat_dna">sumstat_dna</a>()</code>,
<code><a href="#topic+sumstat_file">sumstat_file</a>()</code>,
<code><a href="#topic+sumstat_four_gamete">sumstat_four_gamete</a>()</code>,
<code><a href="#topic+sumstat_ihh">sumstat_ihh</a>()</code>,
<code><a href="#topic+sumstat_jsfs">sumstat_jsfs</a>()</code>,
<code><a href="#topic+sumstat_mcmf">sumstat_mcmf</a>()</code>,
<code><a href="#topic+sumstat_nucleotide_div">sumstat_nucleotide_div</a>()</code>,
<code><a href="#topic+sumstat_omega">sumstat_omega</a>()</code>,
<code><a href="#topic+sumstat_seg_sites">sumstat_seg_sites</a>()</code>,
<code><a href="#topic+sumstat_sfs">sumstat_sfs</a>()</code>,
<code><a href="#topic+sumstat_tajimas_d">sumstat_tajimas_d</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Without recombination:
model &lt;- coal_model(4, 2) + sumstat_trees()
stats &lt;- simulate(model)
print(stats$trees)

# With recombination:
model &lt;- model + feat_recombination(5)
stats &lt;- simulate(model)
print(stats$trees)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
