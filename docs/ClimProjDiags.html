<!DOCTYPE html><html lang="en"><head><title>Help for package ClimProjDiags</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ClimProjDiags}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AnoAgree'><p>Percentage of anomalies which agrees with the sign of the mean anomaly for</p>
multidimensional arrays</a></li>
<li><a href='#ArrayToList'><p>Split an array into list by a given array dimension</p></a></li>
<li><a href='#Climdex'><p>Wrapper for applying the climdex routine  ETCCDI climate change indices to</p>
n-dimensional arrays.</a></li>
<li><a href='#CombineIndices'><p>Combine weighted indices of n-dimensional arrays</p></a></li>
<li><a href='#DailyAno'><p>Daily anomalies</p></a></li>
<li><a href='#DTRIndicator'><p>Diurnal temperature range indicator (DTR) of multidimensional arrays</p></a></li>
<li><a href='#DTRRef'><p>Diurnal temperature range of multidimensional arrays</p></a></li>
<li><a href='#Extremes'><p>Sum of spell lengths exceeding daily threshold for n-dimensional arrays</p></a></li>
<li><a href='#Lon2Index'><p>Obtain the index of positions for a region in longitudes</p></a></li>
<li><a href='#SeasonSelect'><p>Selects a season from daily data for multidimensional arrays</p></a></li>
<li><a href='#SelBox'><p>Select spatial region from multidimensional arrays</p></a></li>
<li><a href='#ShiftLon'><p>Shift longitudes of a data array</p></a></li>
<li><a href='#Subset'><p>Subset a Data Array</p></a></li>
<li><a href='#Threshold'><p>Daily thresholds based on quantiles for n-dimensional arrays</p></a></li>
<li><a href='#WaveDuration'><p>Heat and cold waves duration for n-dimensional arrays</p></a></li>
<li><a href='#WeightedCells'><p>Compute the square-root of the cosine of the latitude weighting on the given</p>
array.</a></li>
<li><a href='#WeightedMean'><p>Calculate spatial area-weighted average of multidimensional arrays</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Set of Tools to Compute Various Climate Indices</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Set of tools to compute metrics and indices for climate analysis.
    The package provides functions to compute extreme indices, evaluate the
    agreement between models and combine theses models into an ensemble. Multi-model
    time series of climate indices can be computed either after averaging the 2-D
    fields from different models provided they share a common grid or by combining
    time series computed on the model native grid. Indices can be assigned weights
    and/or combined to construct new indices.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>multiApply (&ge; 2.0.0), PCICt, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, testthat, markdown, rmarkdown</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://earth.bsc.es/gitlab/es/ClimProjDiags">https://earth.bsc.es/gitlab/es/ClimProjDiags</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://earth.bsc.es/gitlab/es/ClimProjDiags/-/issues">https://earth.bsc.es/gitlab/es/ClimProjDiags/-/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-25 15:06:45 UTC; vagudets</td>
</tr>
<tr>
<td>Author:</td>
<td>BSC-CNS [aut, cph],
  Victòria Agudetse [cre],
  Nuria Perez-Zanon <a href="https://orcid.org/0000-0001-8568-3071"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  An-Chi Ho [ctb],
  Nicolau Manubens [ctb],
  Alasdair Hunter [aut],
  Louis-Philippe Caron [ctb],
  Eva Rifà [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Victòria Agudetse &lt;victoria.agudetse@bsc.es&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-26 09:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='AnoAgree'>Percentage of anomalies which agrees with the sign of the mean anomaly for 
multidimensional arrays</h2><span id='topic+AnoAgree'></span>

<h3>Description</h3>

<p>This function computes the mean and the percentage of agreement 
between anomalies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AnoAgree(ano, membersdim, na.rm = TRUE, ncores = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AnoAgree_+3A_ano">ano</code></td>
<td>
<p>A multidimensional array.</p>
</td></tr>
<tr><td><code id="AnoAgree_+3A_membersdim">membersdim</code></td>
<td>
<p>The dimension in which models are stored.</p>
</td></tr>
<tr><td><code id="AnoAgree_+3A_na.rm">na.rm</code></td>
<td>
<p>A logical indicating whether missing values should be removed. If 
<code>na.rm</code> is FALSE an NA value in any of the arguments will cause a value 
of NA to be returned, otherwise (TRUE by default) NA values are ignored.</p>
</td></tr>
<tr><td><code id="AnoAgree_+3A_ncores">ncores</code></td>
<td>
<p>The number of cores to be used when computing the agreement.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array of one dimension less than the <code>ano</code> object, except for 
one dimensional arrays or vectors, for which an array of dimension 1 called 
'var' is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example with random sample:
a &lt;- NULL
for(i in 1:20) { a &lt;- c(a, rnorm(6)) }
dim(a) &lt;- c(lat = 2, lon = 3, var = 4, mod = 5)

agree &lt;- AnoAgree(ano = a, membersdim = which(names(dim(a)) == 'mod'), 
                 na.rm = TRUE, ncores = NULL)
print(agree)

a &lt;- rnorm(6)
agree &lt;- AnoAgree(ano = a, membersdim = 1, na.rm = TRUE, ncores = NULL)
print(agree)
</code></pre>

<hr>
<h2 id='ArrayToList'>Split an array into list by a given array dimension</h2><span id='topic+ArrayToList'></span>

<h3>Description</h3>

<p>This function splits an array into a list as required by 
PlotLayout function from package &quot;s2dv&quot; when parameter 'special_args' is used. 
The function ArrayToList allows to add names to the elements of the list in 
two different levels, the 'list' or the 'sublist'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ArrayToList(data, dim, level = "list", names = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ArrayToList_+3A_data">data</code></td>
<td>
<p>A multidimensional array.</p>
</td></tr>
<tr><td><code id="ArrayToList_+3A_dim">dim</code></td>
<td>
<p>A character string indicating the name of the dimension to split or 
an integer indicating the position of the dimension.</p>
</td></tr>
<tr><td><code id="ArrayToList_+3A_level">level</code></td>
<td>
<p>A string character 'list' or 'sublist' indicating if it should be 
a list or a sublist. By default it creates a list.</p>
</td></tr>
<tr><td><code id="ArrayToList_+3A_names">names</code></td>
<td>
<p>A vector of character strings to name the list (if it is a single 
string, it would be reused) or a single character string to name the 
elements in the sublist.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of arrays of the length of the dimension set in parameter 'dim'.
</p>


<h3>See Also</h3>

<p><a href="s2dv.html#topic+PlotLayout">PlotLayout</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- array(1:240, c(month = 12, member = 5, time = 4))
# Create a list:
datalist &lt;- ArrayToList(data, dim = 'month', level = 'list', names = month.name)
class(datalist)
class(datalist[[1]])
str(datalist)
# Create a sublist:
datalist &lt;- ArrayToList(data, dim = 'month', level = 'sublist', names = 'dots')
class(datalist)
class(datalist[[1]])
class(datalist[[1]][[1]])
str(datalist)
</code></pre>

<hr>
<h2 id='Climdex'>Wrapper for applying the climdex routine  ETCCDI climate change indices to 
n-dimensional arrays.</h2><span id='topic+Climdex'></span>

<h3>Description</h3>

<p>This function computes the t90p, t10p, cdd or rx5day indices from 
n-dimensional arrays.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Climdex(
  data,
  metric,
  threshold = NULL,
  base.range = NULL,
  dates = NULL,
  timedim = NULL,
  calendar = NULL,
  ncores = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Climdex_+3A_data">data</code></td>
<td>
<p>A numeric n-dimensional array containing daily maximum or minimum 
temperature, wind speed or precipitation amount.</p>
</td></tr>
<tr><td><code id="Climdex_+3A_metric">metric</code></td>
<td>
<p>The metric to be computed, either 't90p', 't10p', 'Wx', 'cdd' or 
'rx5day'.</p>
</td></tr>
<tr><td><code id="Climdex_+3A_threshold">threshold</code></td>
<td>
<p>For the 't90p' and 't10p' metrics, an array of the 90th/10th 
percentiles must be included. This parameter can be computed with the 
<code>Threshold</code> function.</p>
</td></tr>
<tr><td><code id="Climdex_+3A_base.range">base.range</code></td>
<td>
<p>The years used for the reference period. If NULL 
(by default), all years are used.</p>
</td></tr>
<tr><td><code id="Climdex_+3A_dates">dates</code></td>
<td>
<p>A vector of dates with a calendar attributes. If NULL 
(by default), the 'time' attributes of parameter 'data' are considered.</p>
</td></tr>
<tr><td><code id="Climdex_+3A_timedim">timedim</code></td>
<td>
<p>An integer number indicating the position of the time dimension 
in the parameter <code>data</code>. If NULL (by default), the dimension called 
'time' in parameter <code>data</code> is considered as temporal dimension.</p>
</td></tr>
<tr><td><code id="Climdex_+3A_calendar">calendar</code></td>
<td>
<p>A character indicating the calendar type.</p>
</td></tr>
<tr><td><code id="Climdex_+3A_ncores">ncores</code></td>
<td>
<p>The number of cores to be used when computing the index.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of length 2:
</p>

<ul>
<li><p><code>$result</code>, an array with the same dimensions as the input array, 
except for the temporal dimension which is renamed to 'year', moved 
to the first dimension position and reduce to annual resolution.
</p>
</li>
<li><p><code>$years</code>, a vector of the corresponding years.
</p>
</li></ul>



<h3>References</h3>

<p>David Bronaugh for the Pacific Climate Impacts Consortium (2015).
climdex.pcic: PCIC Implementation of Climdex Routines. R package
version 1.1-6. http://CRAN.R-project.org/package=climdex.pcic
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Example synthetic data:
data &lt;- 1:(2 * 3 * 372 * 1)
dim(data) &lt;- c(lon = 2, lat = 3, time = 372, model = 1)
time &lt;- c(seq(ISOdate(1900, 1, 1), ISOdate(1900, 1, 31), "day"), 
         seq(ISOdate(1901, 1, 1), ISOdate(1901, 1, 31), "day"),
         seq(ISOdate(1902, 1, 1), ISOdate(1902, 1, 31), "day"),
         seq(ISOdate(1903, 1, 1), ISOdate(1903, 1, 31), "day"),
         seq(ISOdate(1904, 1, 1), ISOdate(1904, 1, 31), "day"),
         seq(ISOdate(1905, 1, 1), ISOdate(1905, 1, 31), "day"),
         seq(ISOdate(1906, 1, 1), ISOdate(1906, 1, 31), "day"),
         seq(ISOdate(1907, 1, 1), ISOdate(1907, 1, 31), "day"),
         seq(ISOdate(1908, 1, 1), ISOdate(1908, 1, 31), "day"),
         seq(ISOdate(1909, 1, 1), ISOdate(1909, 1, 31), "day"),
         seq(ISOdate(1910, 1, 1), ISOdate(1910, 1, 31), "day"),
         seq(ISOdate(1911, 1, 1), ISOdate(1911, 1, 31), "day"))
metadata &lt;- list(time = list(standard_name = 'time', long_name = 'time', 
                            calendar = 'gregorian', 
                            units = 'days since 1970-01-01 00:00:00', 
                            prec = 'double', 
                            dim = list(list(name = 'time', unlim = FALSE))))
attr(time, "variables") &lt;- metadata
attr(data, 'Variables')$dat1$time &lt;- time

thres &lt;- rep(10, 31 * 2 * 3)
dim(thres) &lt;- c(jdays = 31, lon = 2, lat = 3,  model = 1)
str(thres)

clim &lt;- Climdex(data, metric = "t90p", threshold = thres)
str(clim)
</code></pre>

<hr>
<h2 id='CombineIndices'>Combine weighted indices of n-dimensional arrays</h2><span id='topic+CombineIndices'></span>

<h3>Description</h3>

<p>Function to combine climate indices for multiple models through 
addition, subtraction, division or averaging, optionally applying weights to 
each index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CombineIndices(indices, weights = NULL, operation = "mean")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CombineIndices_+3A_indices">indices</code></td>
<td>
<p>List of n-dimensional arrays with equal dimensions to be 
combined.</p>
</td></tr>
<tr><td><code id="CombineIndices_+3A_weights">weights</code></td>
<td>
<p>Vector of weights for the indices, whose length is the same as 
the list of parameter <code>indices</code>. If not provided, a weight of 1 is 
assigned to each index. If <code>operation = 'mean'</code> the weights are 
normalized to sum 1 all together.</p>
</td></tr>
<tr><td><code id="CombineIndices_+3A_operation">operation</code></td>
<td>
<p>The operation for combining the indices, either <code>"mean"</code> 
(default), <code>"add"</code>, <code>"subtract"</code> or <code>"divide"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array of the same dimensions as one of the elements in the 
parameter <code>indices</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- matrix(rnorm(6), 2, 3)
b &lt;- matrix(rnorm(6), 2, 3)

comb_ind &lt;- CombineIndices(indices = list(a, b), weights = c(2, 1), 
                          operation = "add")
print(comb_ind)

a &lt;- rnorm(24)
dim(a) &lt;- c(lon = 2, lat = 3, mod = 4)
b &lt;- rnorm(24)
dim(b) &lt;- c(lon = 2, lat = 3, mod = 4)
comb_ind &lt;- CombineIndices(indices = list(a, b), weights = c(2, 1), 
                          operation = "add")
print(comb_ind)
</code></pre>

<hr>
<h2 id='DailyAno'>Daily anomalies</h2><span id='topic+DailyAno'></span>

<h3>Description</h3>

<p>This function computes daily anomalies from a vector containing 
the daily time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DailyAno(data, jdays = NULL, dates = NULL, calendar = NULL, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DailyAno_+3A_data">data</code></td>
<td>
<p>A vector of daily data.</p>
</td></tr>
<tr><td><code id="DailyAno_+3A_jdays">jdays</code></td>
<td>
<p>A vector of the corresponding day of the year. This vector must 
be the same length as parameter <code>data</code>.</p>
</td></tr>
<tr><td><code id="DailyAno_+3A_dates">dates</code></td>
<td>
<p>If <code>jdays</code> is not supplied, a vector of dates corresponding 
to the observations in <code>data</code> with defined calendar attributes.</p>
</td></tr>
<tr><td><code id="DailyAno_+3A_calendar">calendar</code></td>
<td>
<p>A character indicating the calendar type.</p>
</td></tr>
<tr><td><code id="DailyAno_+3A_na.rm">na.rm</code></td>
<td>
<p>A logical indicating whether missing values should be removed. If 
<code>na.rm</code> is FALSE an NA value in any of the arguments will cause a value 
of NA to be returned, otherwise (TRUE by default) NA values are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of daily anomalies of the same length as parameter 
<code>data</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Time series in a vector example:
data &lt;- 1:10
jdays &lt;- c(rep(1, 5), rep(2, 5))
daily_anomaly &lt;- DailyAno(data = data, jdays = jdays, na.rm = TRUE)
print(daily_anomaly)
</code></pre>

<hr>
<h2 id='DTRIndicator'>Diurnal temperature range indicator (DTR) of multidimensional arrays</h2><span id='topic+DTRIndicator'></span>

<h3>Description</h3>

<p>This function computes the diurnal temperature indicator, defined 
as the number of days where the diurnal temperature variation exceeds the 
vulnerability threshold (defined as the mean(tmax -tmin) + 5 from the 
reference period).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DTRIndicator(
  tmax,
  tmin,
  ref,
  by.seasons = TRUE,
  dates = NULL,
  timedim = NULL,
  calendar = NULL,
  ncores = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DTRIndicator_+3A_tmax">tmax</code></td>
<td>
<p>A numeric multidimensional array containing daily maximum 
temperature.</p>
</td></tr>
<tr><td><code id="DTRIndicator_+3A_tmin">tmin</code></td>
<td>
<p>A numeric multidimensional array containing daily minimum 
temperature. This array must be the same dimensions as <code>tmax</code> 
parameter.</p>
</td></tr>
<tr><td><code id="DTRIndicator_+3A_ref">ref</code></td>
<td>
<p>An output list from the <code>DTRRef</code> function with the same 
dimensions as parameters <code>tmax</code> and <code>tmin</code>, except the time 
dimension, containing the mean diurnal temperature variation for the 
reference period.</p>
</td></tr>
<tr><td><code id="DTRIndicator_+3A_by.seasons">by.seasons</code></td>
<td>
<p>If TRUE (by default), the DTR is computed for each season 
(December-January-February, March-April-May, June-July-August and 
September-October-November) seperately. If FALSE is specified, the montly 
mean DTR is computed.</p>
</td></tr>
<tr><td><code id="DTRIndicator_+3A_dates">dates</code></td>
<td>
<p>A vector of dates with a calendar attributes. If NULL (by 
default), the 'time' attributes of parameter 'tmax' and 'tmin' are 
considered.</p>
</td></tr>
<tr><td><code id="DTRIndicator_+3A_timedim">timedim</code></td>
<td>
<p>An integer number indicating the position of the time dimension 
in the parameters <code>tmax</code> and <code>tmin</code>. If NULL (by default), the 
dimension called 'time' in parameter <code>tmax</code> and <code>tmin</code> is 
considered as time dimension.</p>
</td></tr>
<tr><td><code id="DTRIndicator_+3A_calendar">calendar</code></td>
<td>
<p>A character indicating the calendar type.</p>
</td></tr>
<tr><td><code id="DTRIndicator_+3A_ncores">ncores</code></td>
<td>
<p>The number of cores to be used when computing the index.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of length 3:
</p>

<ul>
<li><p><code>$dtr.ref</code>, an array with the same dimensions as the input 
<code>data</code>, but with the time dimension reduce from daily to monthly 
or seasonal resolution depending on the selected resolution in 
<code>by.season</code>.
</p>
</li>
<li><p><code>$year</code>, a vector of the corresponding years.
</p>
</li>
<li><p><code>$season</code>, a vector of the seasons or months corresponding to the 
resolution selected in <code>by.season</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>##Exmaple with synthetic data:
tmax &lt;- 1 : (2 * 3 * 730 * 1)
dim(tmax) &lt;- c(lon = 2, lat = 3, time = 730, model = 1)
tmin &lt;- (1 : (2 * 3 * 730 * 1)) - 1
dim(tmin) &lt;- c(lon = 2, lat = 3, time = 730, model = 1)
time &lt;- seq(as.POSIXct("1900-01-01 12:00:00", tz = "", 
                      format = "%Y-%d-%m %H:%M:%S"), 
           as.POSIXct("1901-31-12 18:00:00", tz = "", 
                      format = "%Y-%d-%m %H:%M:%S"), "day")
time &lt;- as.POSIXct(time, tz = "CET")
metadata &lt;- list(time = list(standard_name = 'time', long_name = 'time', 
                            calendar = 'noleap',
                            units = 'days since 1970-01-01 00:00:00', 
                            prec = 'double', 
                            dim = list(list(name ='time', unlim = FALSE))))
attr(time, "variables") &lt;- metadata
attr(tmax, 'Variables')$dat1$time &lt;- time
attr(tmax, 'Variables')$common[[2]]$dim[[3]]$len = length(time)
attr(tmax, 'Variables')$common[[2]]$dim[[3]]$vals &lt;- time
attr(tmin, 'Variables')$dat1$time &lt;- time
attr(tmin, 'Variables')$common[[2]]$dim[[3]]$len = length(time)
attr(tmin, 'Variables')$common[[2]]$dim[[3]]$vals &lt;- time
a &lt;- DTRRef(tmax, tmin, by.seasons = FALSE, ncores = NULL)

aa &lt;- DTRIndicator(tmax, tmin, ref = a, by.seasons = FALSE, ncores = NULL)
str(aa)
dim(aa$indicator)
</code></pre>

<hr>
<h2 id='DTRRef'>Diurnal temperature range of multidimensional arrays</h2><span id='topic+DTRRef'></span>

<h3>Description</h3>

<p>This function computes the mean diurnal temperature range 
(tmax - tmin).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DTRRef(
  tmax,
  tmin,
  by.seasons = TRUE,
  dates = NULL,
  timedim = NULL,
  calendar = NULL,
  na.rm = TRUE,
  ncores = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DTRRef_+3A_tmax">tmax</code></td>
<td>
<p>A numeric multidimensional array containing daily maximum 
temperature.</p>
</td></tr>
<tr><td><code id="DTRRef_+3A_tmin">tmin</code></td>
<td>
<p>A numeric multidimensional array containing daily minimum 
temperature.</p>
</td></tr>
<tr><td><code id="DTRRef_+3A_by.seasons">by.seasons</code></td>
<td>
<p>If TRUE (by default), the DTR is computed for each season 
(December-January-February, March-April-May, June-July-August and 
September-October-November) seperately. If FALSE is specified, the montly 
mean DTR is computed.</p>
</td></tr>
<tr><td><code id="DTRRef_+3A_dates">dates</code></td>
<td>
<p>A vector of dates with a calendar attributes. If NULL (by 
default), the 'time' attributes of parameter 'tmax' and 'tmin' are 
considered.</p>
</td></tr>
<tr><td><code id="DTRRef_+3A_timedim">timedim</code></td>
<td>
<p>An integer number indicating the position of the time dimension 
in the parameters <code>tmax</code> and <code>tmin</code>. If NULL (by default), the 
dimension called 'time' in parameter <code>tmax</code> and <code>tmin</code> is 
considered as time dimension.</p>
</td></tr>
<tr><td><code id="DTRRef_+3A_calendar">calendar</code></td>
<td>
<p>A character indicating the calendar type.</p>
</td></tr>
<tr><td><code id="DTRRef_+3A_na.rm">na.rm</code></td>
<td>
<p>A logical indicating whether missing values should be removed. If 
<code>na.rm</code> is FALSE an NA value in any of the arguments will cause a value 
of NA to be returned, otherwise (TRUE by default) NA values are ignored.</p>
</td></tr>
<tr><td><code id="DTRRef_+3A_ncores">ncores</code></td>
<td>
<p>The number of cores to be used when computing the index.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function returns a reordered array with 'time' dimension in the 
first position in the <code>dtr.ref</code> label.
</p>


<h3>Value</h3>

<p>A list of length 2:
</p>

<ul>
<li><p><code>$dtr.ref</code>, an array with the same dimensions as the input 
<code>data</code>, but with the time dimension reduce from daily to monthly 
or seasonal resolution depending on the selected resolution in 
<code>by.season</code>.
</p>
</li>
<li><p><code>$season</code>, a vector of the season or months corresponding to the 
resolution selected in <code>by.season</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>##Exmaple with synthetic data:
tmax &lt;- 1:(2 * 3 * 365 * 1)
dim(tmax) &lt;- c(lon = 2, lat = 3, time = 365, model = 1)
tmin &lt;- (1:(2 * 3 * 365 * 1))-1
dim(tmin) &lt;- c(lon = 2, lat = 3, time = 365, model = 1)
time &lt;- seq.Date(as.Date("1900-01-01", format = "%Y-%d-%m"), 
                as.Date("1900-31-12", format = "%Y-%d-%m"), 1)
time &lt;- as.POSIXct(time, tz = "CET")
metadata &lt;- list(time = list(standard_name = 'time', long_name = 'time', 
                            calendar = 'noleap',
                            units = 'days since 1970-01-01 00:00:00', 
                            prec = 'double', 
                            dim = list(list(name ='time', unlim = FALSE))))
attr(time, "variables") &lt;- metadata
attr(tmax, 'Variables')$dat1$time &lt;- time
attr(tmax, 'Variables')$common[[2]]$dim[[3]]$len = length(time)
attr(tmax, 'Variables')$common[[2]]$dim[[3]]$vals &lt;- time
attr(tmin, 'Variables')$dat1$time &lt;- time
attr(tmin, 'Variables')$common[[2]]$dim[[3]]$len = length(time)
attr(tmin, 'Variables')$common[[2]]$dim[[3]]$vals &lt;- time

a &lt;- DTRRef(tmax, tmin, by.seasons = FALSE, ncores = NULL)
str(a)

tmax &lt;- 1:(2 * 3 * 365 * 1)
dim(tmax) &lt;- c(2, 3, 365)
tmin &lt;- (1:(2 * 3 * 365 * 1))-1
dim(tmin) &lt;- c(2, 3, 365)

a &lt;- DTRRef(tmax, tmin, by.seasons = FALSE, dates = time,  timedim = 3, 
           ncores = NULL)
str(a)
</code></pre>

<hr>
<h2 id='Extremes'>Sum of spell lengths exceeding daily threshold for n-dimensional arrays</h2><span id='topic+Extremes'></span>

<h3>Description</h3>

<p>This function returns the number of spells of more than 
<code>min.length</code> days which exceed or are below the given <code>threshold</code> 
from daily data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Extremes(
  data,
  threshold,
  op = "&gt;",
  min.length = 6,
  spells.can.span.years = TRUE,
  max.missing.days = 5,
  dates = NULL,
  timedim = NULL,
  calendar = NULL,
  ncores = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Extremes_+3A_data">data</code></td>
<td>
<p>A n-dimensional array containing daily data.</p>
</td></tr>
<tr><td><code id="Extremes_+3A_threshold">threshold</code></td>
<td>
<p>A n-dimensional array with the threshold to be/not to be 
reach, usually given by the a percentile computed with the <code>Threshold</code> 
function.</p>
</td></tr>
<tr><td><code id="Extremes_+3A_op">op</code></td>
<td>
<p>The operator to use to compare data to threshold.</p>
</td></tr>
<tr><td><code id="Extremes_+3A_min.length">min.length</code></td>
<td>
<p>The minimum spell length to be considered.</p>
</td></tr>
<tr><td><code id="Extremes_+3A_spells.can.span.years">spells.can.span.years</code></td>
<td>
<p>Whether spells can span years.</p>
</td></tr>
<tr><td><code id="Extremes_+3A_max.missing.days">max.missing.days</code></td>
<td>
<p>Maximum number of NA values per time period.</p>
</td></tr>
<tr><td><code id="Extremes_+3A_dates">dates</code></td>
<td>
<p>A vector of dates with a calendar attributes. If NULL 
(by default), the 'time' attributes of parameter 'data' are considered.</p>
</td></tr>
<tr><td><code id="Extremes_+3A_timedim">timedim</code></td>
<td>
<p>An integer number indicating the position of the time dimension 
in the parameter <code>data</code>. If NULL (by default), the dimension called 
'time' in parameter <code>data</code>.</p>
</td></tr>
<tr><td><code id="Extremes_+3A_calendar">calendar</code></td>
<td>
<p>A character indicating the calendar type.</p>
</td></tr>
<tr><td><code id="Extremes_+3A_ncores">ncores</code></td>
<td>
<p>The number of cores to be used when computing the extreme.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This routine compares data to the thresholds using the given 
operator, generating a series of TRUE or FALSE values; these values are then 
filtered to remove any sequences of less than <code>min.length</code> days of TRUE 
values. It then computes the lengths of the remaining sequences of TRUE values 
(spells) and sums their lengths. The <code>spells.can.spa .years</code> option 
controls whether spells must always terminate at the end of a period, or 
whether they may continue until the criteria ceases to be met or the end of 
the data is reached. The default for fclimdex is FALSE.
</p>


<h3>Value</h3>

<p>A list of length 2:
</p>

<ul>
<li><p><code>$output1</code>, an array with the same dimensions as the original 
<code>data</code>, except the time dimension which is reduced to annual 
resolution given a timeseries of maximum spell lengths for each year.
</p>
</li>
<li><p><code>$year</code>, a vector indicating the corresponding years.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>##Example synthetic data:
data &lt;- 1:(2 * 3 * 310 * 1)
dim(data) &lt;- c(time = 310, lon = 2, lat = 3, model = 1)
time &lt;- as.POSIXct(paste(sort(rep(1902:1911, 31)), 1, 1:31, sep = "-"), tz = "CET")
metadata &lt;- list(time = list(standard_name = 'time', long_name = 'time', 
                            calendar = 'noleap', 
                            units = 'days since 1970-01-01 00:00:00', 
                            prec = 'double', 
                            dim = list(list(name = 'time', unlim = FALSE))))
attr(time, "variables") &lt;- metadata
attr(data, 'Variables')$dat1$time &lt;- time
threshold &lt;- Threshold(data, dates = NULL, base.range = NULL, qtiles = 0.9, 
                      ncores = NULL)
res &lt;- Extremes(data, threshold = threshold, op = "&gt;", min.length = 6, 
               spells.can.span.years = TRUE, max.missing.days = 5, 
               ncores = NULL)
str(res)

</code></pre>

<hr>
<h2 id='Lon2Index'>Obtain the index of positions for a region in longitudes</h2><span id='topic+Lon2Index'></span>

<h3>Description</h3>

<p>This auxiliary function returns the index of position of a region 
of longitudes in a given vector of longitudes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Lon2Index(lon, lonmin, lonmax)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Lon2Index_+3A_lon">lon</code></td>
<td>
<p>vector of longitudes values.</p>
</td></tr>
<tr><td><code id="Lon2Index_+3A_lonmin">lonmin</code></td>
<td>
<p>a numeric value indicating the minimum longitude of the region 
(understand as the left marging of the region).</p>
</td></tr>
<tr><td><code id="Lon2Index_+3A_lonmax">lonmax</code></td>
<td>
<p>a numeric value indicating the maximum longitude of the region 
(understand as the right mariging of the region).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the index of positions of all values inside the region in the vector 
lon.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
lon &lt;- 1 : 360
pos &lt;- Lon2Index(lon, lonmin = -20, lonmax = 20)
lon[pos]
pos &lt;- Lon2Index(lon, lonmin = 340, lonmax = 20)
lon[pos]
lon &lt;- -180 : 180
pos &lt;- Lon2Index(lon, lonmin = -20, lonmax = 20)
lon[pos]
pos &lt;- Lon2Index(lon, lonmin = 340, lonmax = 20)
lon[pos]

</code></pre>

<hr>
<h2 id='SeasonSelect'>Selects a season from daily data for multidimensional arrays</h2><span id='topic+SeasonSelect'></span>

<h3>Description</h3>

<p>This function selects the daily data corresponding to the 
specified season.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SeasonSelect(data, season, dates = NULL, timedim = NULL, calendar = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SeasonSelect_+3A_data">data</code></td>
<td>
<p>A numeric multidimensional array containing daily data.</p>
</td></tr>
<tr><td><code id="SeasonSelect_+3A_season">season</code></td>
<td>
<p>A charcater string indicating the season by the three months 
initials in capitals: 'DJF' for winter (summer), 'MAM' spring (autumn), 
'JJA' for summer (winter) or 'SON' for autumn (spring) in the northern 
(southern) hemisphere.</p>
</td></tr>
<tr><td><code id="SeasonSelect_+3A_dates">dates</code></td>
<td>
<p>A vector of dates with a calendar attributes. If NULL (by 
default), the 'time' attributes of parameter 'data' are considered.</p>
</td></tr>
<tr><td><code id="SeasonSelect_+3A_timedim">timedim</code></td>
<td>
<p>An integer number indicating the position of the time dimension 
in the parameter <code>data</code>. If NULL (by default), the dimension called 
'time' in parameter <code>data</code>.</p>
</td></tr>
<tr><td><code id="SeasonSelect_+3A_calendar">calendar</code></td>
<td>
<p>A character indicating the calendar type.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of length 2:
</p>

<ul>
<li><p><code>$data</code>, a vector or array containing the daily values for the 
selected season, with the same dimensions as <code>data</code> input but the 
'time' dimension reduce to the number of days corresponding to the 
selected season.
</p>
</li>
<li><p><code>$dates</code>, a vector of dates reduce to the number of days 
corresponding to the selected season.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Example with synthetic data:
data &lt;- 1:(2 * 3 * (366 + 365) * 2)
dim(data) &lt;- c(lon = 2, lat = 3, time = 366 + 365, model = 2)
time &lt;- seq(ISOdate(1903,1,1), ISOdate(1904,12,31), "days")
time &lt;- as.POSIXct(time, tz = "CET")
metadata &lt;- list(time = list(standard_name = 'time', long_name = 'time', 
                            calendar = 'noleap',
                            units = 'days since 1970-01-01 00:00:00', 
                            prec = 'double', 
                            dim = list(list(name ='time', unlim = FALSE))))
attr(time, "variables") &lt;- metadata
attr(data, 'Variables')$dat1$time &lt;- time
attr(data, 'Variables')$dat2$time &lt;- time
attr(data, 'Variables')$common[[2]]$dim[[3]]$len = length(time)
attr(data, 'Variables')$common[[2]]$dim[[3]]$vals &lt;- time

a &lt;- SeasonSelect(data = data, season = 'JJA')
str(a)
</code></pre>

<hr>
<h2 id='SelBox'>Select spatial region from multidimensional arrays</h2><span id='topic+SelBox'></span>

<h3>Description</h3>

<p>Subset a spatial region from spatial data giving a vector with 
the maximum and minimum of latitudes and longitudes of the selected region.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SelBox(data, lon, lat, region, londim = "lon", latdim = "lat", mask = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SelBox_+3A_data">data</code></td>
<td>
<p>An array with minimum two dimensions of latitude and longitude.</p>
</td></tr>
<tr><td><code id="SelBox_+3A_lon">lon</code></td>
<td>
<p>Numeric vector of longitude locations of the cell centers of the
grid of <code>data</code>'.</p>
</td></tr>
<tr><td><code id="SelBox_+3A_lat">lat</code></td>
<td>
<p>Numeric vector of latitude locations of the cell centers of the
grid of <code>data</code>'.</p>
</td></tr>
<tr><td><code id="SelBox_+3A_region">region</code></td>
<td>
<p>A vector of length four indicating the minimum longitude, the
maximum longitude, the minimum latitude and the maximum latitude.</p>
</td></tr>
<tr><td><code id="SelBox_+3A_londim">londim</code></td>
<td>
<p>A character string indicating the name of the longitudinal
dimension. The default value is 'lon'.</p>
</td></tr>
<tr><td><code id="SelBox_+3A_latdim">latdim</code></td>
<td>
<p>A character string indicating the name of the latitudinal
dimension. The default value is 'lat'.</p>
</td></tr>
<tr><td><code id="SelBox_+3A_mask">mask</code></td>
<td>
<p>A matrix with the same spatial dimensions of <code>data</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of length 4:
</p>

<ul>
<li><p><code>$data</code>, an array with the same dimensions as the input 
<code>data</code> array, but with spatial dimension reduced to the selected 
<code>region</code>.
</p>
</li>
<li><p><code>$lat</code>, a vector with the new corresponding latitudes for the 
selected <code>region</code>.
</p>
</li>
<li><p><code>$lon</code>, a vector with the new corresponding longitudes for the 
selected <code>region</code>.
</p>
</li>
<li><p><code>$mask</code>, if parameter <code>mask</code> is supplied, an array with 
reduced length of the dimensions to the selected <code>region</code>. 
Otherwise, a NULL element is returned.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Example with synthetic data:
data &lt;- 1:(20 * 3 * 2 * 4)
dim(data) &lt;- c(lon = 20, lat = 3, time = 2, model = 4)
lon &lt;- seq(2, 40, 2)
lat &lt;- c(1, 5, 10)

a &lt;- SelBox(data = data, lon = lon, lat = lat, region = c(2, 20, 1, 5), 
           londim = "lon", latdim = "lat", mask = NULL)
</code></pre>

<hr>
<h2 id='ShiftLon'>Shift longitudes of a data array</h2><span id='topic+ShiftLon'></span>

<h3>Description</h3>

<p>Shift the longitudes of a data array. Only reasonable for global
longitude shifting. It is useful for map plotting or aligning datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ShiftLon(data, lon, westB, lon_dim = "lon", ncores = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ShiftLon_+3A_data">data</code></td>
<td>
<p>A named multidimensional array with at least 'lon_dim' dimension.</p>
</td></tr>
<tr><td><code id="ShiftLon_+3A_lon">lon</code></td>
<td>
<p>A numeric vector of longitudes. The values are expected to be 
monotonic increasing.</p>
</td></tr>
<tr><td><code id="ShiftLon_+3A_westb">westB</code></td>
<td>
<p>A number indicating the west boundary of the new longitudes.</p>
</td></tr>
<tr><td><code id="ShiftLon_+3A_lon_dim">lon_dim</code></td>
<td>
<p>A character string indicating the name of the longitude 
dimension in 'data'. The default value is 'lon'.</p>
</td></tr>
<tr><td><code id="ShiftLon_+3A_ncores">ncores</code></td>
<td>
<p>An integer indicating the number of cores used for computation.
The default value is NULL (use only one core).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 2:
</p>
<table role = "presentation">
<tr><td><code>data</code></td>
<td>

<p>Array of the shifted data with the same dimensions as parameter 'data'.
</p>
</td></tr>
<tr><td><code>lon</code></td>
<td>

<p>The monotonic increasing new longitudes with the same length as parameter 
'lon' and start at 'westB'.
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- array(data = 1:50, dim = c(lon = 360, lat = 181))
lon &lt;- array(data = 0:359, dim = c(lon = 360))
lat &lt;- -90:90 ## lat does not change
shifted &lt;- ShiftLon(data = data, lon = lon, westB = -180, ncores = 1)

 ## Not run: 
s2dv::PlotEquiMap(var = data, lon = lon, lat = lat, filled.continents = FALSE)
s2dv::PlotEquiMap(var = shifted$data, lon = shifted$lon, lat = lat, filled.continents = FALSE)
 
## End(Not run)
 
</code></pre>

<hr>
<h2 id='Subset'>Subset a Data Array</h2><span id='topic+Subset'></span>

<h3>Description</h3>

<p>This function allows to subset (i.e. slice, take a chunk of) an array, in a 
similar way as done in the function <code>take()</code> in the package plyr. There
are two main snprovements:<br /><br /> First, the input array can have dimension 
names, either in <code>names(dim(x))</code> or in the attribute 'dimensions'. If 
both exist, <code>names(dim(x))</code> is prioritized. The dimensions to subset
along can be specified via the parameter <code>along</code> either with integer
indices or either by their name.<br /><br /> Second, there are additional ways to
adjust which dimensions are dropped in the resulting array: either to drop
all, to drop none, to drop only the ones that have been sliced or to drop
only the ones that have not been sliced.<br /><br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Subset(x, along, indices, drop = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Subset_+3A_x">x</code></td>
<td>
<p>A named multidimensional array to be sliced. It can have dimension 
names either in <code>names(dim(x))</code> or in the attribute 'dimensions'.</p>
</td></tr>
<tr><td><code id="Subset_+3A_along">along</code></td>
<td>
<p>A vector with references to the dimensions to take the subset 
from: either integers or dimension names.</p>
</td></tr>
<tr><td><code id="Subset_+3A_indices">indices</code></td>
<td>
<p>A list of indices to take from each dimension specified in 
'along'. If a single dimension is specified in 'along', it can be directly
provided as an integer or a vector.</p>
</td></tr>
<tr><td><code id="Subset_+3A_drop">drop</code></td>
<td>
<p>Whether to drop all the dimensions of length 1 in the resulting 
array, none, only those that are specified in 'along', or only those that 
are not specified in 'along'. The possible values are: 'all' or TRUE, 'none'
or FALSE, 'selected', and 'non-selected'. The default value is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array with similar dimensions as the <code>x</code> input, but with 
trimmed or dropped dimensions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Example synthetic data:
# Dimension has name already
data &lt;- 1:(2 * 3 * 372 * 1)
dim(data) &lt;- c(time = 372, lon = 2, lat = 3, model = 1)
data_subset &lt;- Subset(data, c('time', 'model'), 
                     list(1:10, TRUE), drop = 'selected')
dim(data_subset)
# Use attributes 'dimensions'
data &lt;- array(1:(2 * 3 * 372 * 1), dim = c(2, 3, 372, 1))
attributes(data)[['dimensions']] &lt;- c('lat', 'lon', 'time', 'model')
data_subset &lt;- Subset(data, c('lon', 'lat'), list(1, 1), drop = TRUE)
dim(data_subset)

</code></pre>

<hr>
<h2 id='Threshold'>Daily thresholds based on quantiles for n-dimensional arrays</h2><span id='topic+Threshold'></span>

<h3>Description</h3>

<p>This function computes the threshold based on a quantile value for each day of 
the year of the daily data input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Threshold(
  data,
  dates = NULL,
  calendar = NULL,
  base.range = NULL,
  qtiles = 0.9,
  ncores = NULL,
  na.rm = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Threshold_+3A_data">data</code></td>
<td>
<p>A numeric n-dimensional array containing daily data.</p>
</td></tr>
<tr><td><code id="Threshold_+3A_dates">dates</code></td>
<td>
<p>A vector of dates with a calendar attributes. If NULL (by 
default), the 'time' attributes of parameter 'data' is considered.</p>
</td></tr>
<tr><td><code id="Threshold_+3A_calendar">calendar</code></td>
<td>
<p>A character indicating the calendar type.</p>
</td></tr>
<tr><td><code id="Threshold_+3A_base.range">base.range</code></td>
<td>
<p>The years used for computing the threshold.</p>
</td></tr>
<tr><td><code id="Threshold_+3A_qtiles">qtiles</code></td>
<td>
<p>Numeric vector with values between 0 and 1 indicating the 
quantiles to be computed.</p>
</td></tr>
<tr><td><code id="Threshold_+3A_ncores">ncores</code></td>
<td>
<p>The number of cores to be used when computing the threshold.</p>
</td></tr>
<tr><td><code id="Threshold_+3A_na.rm">na.rm</code></td>
<td>
<p>A logical value. If TRUE, any NA and NaN's are removed before the 
quantiles are computed (default as FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array with similar dimensions as the <code>data</code> input, but without 
'time' dimension, and a new 'jdays' dimension.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Example synthetic data:
data &lt;- 1:(2 * 3 * 372 * 1)
dim(data) &lt;- c(time = 372, lon = 2, lat = 3, model = 1)
time &lt;- as.POSIXct(paste(sort(rep(1900:1911, 31)), 1, 1:31, sep = "-"), 
                  tz = "CET")
metadata &lt;- list(time = list(standard_name = 'time', long_name = 'time',  
                calendar = 'noleap', 
                units = 'days since 1970-01-01 00:00:00', prec = 'double', 
                dim = list(list(name = 'time', unlim = FALSE))))
attr(time, "variables") &lt;- metadata
attr(data, 'Variables')$dat1$time &lt;- time

a &lt;- Threshold(data, dates = NULL, base.range = NULL, qtiles = 0.9, 
              ncores = NULL)
str(a)

</code></pre>

<hr>
<h2 id='WaveDuration'>Heat and cold waves duration for n-dimensional arrays</h2><span id='topic+WaveDuration'></span>

<h3>Description</h3>

<p>This function computes the duration of a heat/cold wave as the number of 
consecutive days for which the maximum/minimum temperature is exceeding/below 
a threshold over a minimum number of days in month or seasonal resolution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WaveDuration(
  data,
  threshold,
  op = "&gt;",
  spell.length = 6,
  by.seasons = TRUE,
  dates = NULL,
  calendar = NULL,
  ncores = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="WaveDuration_+3A_data">data</code></td>
<td>
<p>A numeric n-dimensional array containing daily maximum or minimum 
temperature</p>
</td></tr>
<tr><td><code id="WaveDuration_+3A_threshold">threshold</code></td>
<td>
<p>An array with the threshold to be/not to be reach, usually 
given by the 90th/10th percentiles for heat/cold waves computed with the 
<code>Threshold</code> function.</p>
</td></tr>
<tr><td><code id="WaveDuration_+3A_op">op</code></td>
<td>
<p>A character &quot;&gt;&quot; (by default) or &quot;&gt;=&quot; for heat waves and &quot;&lt;&quot; or &quot;&lt;=&quot; 
for cold waves indicating the operator must be used  to compare data to 
threshold.</p>
</td></tr>
<tr><td><code id="WaveDuration_+3A_spell.length">spell.length</code></td>
<td>
<p>A number indicating the number of consecutive days with 
extreme temperature to be considered heat or cold wave.</p>
</td></tr>
<tr><td><code id="WaveDuration_+3A_by.seasons">by.seasons</code></td>
<td>
<p>If TRUE (by default), the wave duration is computed for each 
season (DJF/MAM/JJA/SON) separately. If FALSE is specified, the monthly wave 
duration is computed.</p>
</td></tr>
<tr><td><code id="WaveDuration_+3A_dates">dates</code></td>
<td>
<p>A vector of dates including calendar attributes. If NULL (by 
default), the 'time' attributes of parameter 'data' is used.</p>
</td></tr>
<tr><td><code id="WaveDuration_+3A_calendar">calendar</code></td>
<td>
<p>A character indicating the calendar type.</p>
</td></tr>
<tr><td><code id="WaveDuration_+3A_ncores">ncores</code></td>
<td>
<p>The number of cores to be used when computing the wave duration.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of length 2:
</p>

<ul>
<li><p><code>$result</code>, an array with the same dimensions as the input 
<code>data</code>, but with the time dimension reduce from daily to monthly 
or seasonal resolution depending on the selected resolution in 
<code>by.season</code>.
</p>
</li>
<li><p><code>$years</code>, a vector of the years and season/months corresponding 
to the resolution selected in <code>by.season</code> and temporal length of 
the input <code>data</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>##Example synthetic data:
data &lt;- 1:(2 * 3 * 31 * 5)
dim(data) &lt;- c(lon = 2, lat = 3, time = 31, model = 5)
time &lt;- as.POSIXct(paste(paste(1900, 1, 1:31, sep = "-"), paste(12, 0, 0.0, 
                  sep = ":")), tz = "CET")
metadata &lt;- list(time = list(standard_name = 'time', long_name = 'time', 
                calendar = 'standard', 
                units = 'days since 1970-01-01 00:00:00', prec = 'double', 
                dim = list(list(name ='time', unlim = FALSE))))
attr(time, "variables") &lt;- metadata                 
attr(data, 'Variables')$dat1$time &lt;- time
threshold &lt;- rep(40, 31)

a &lt;- WaveDuration(data, threshold, op = "&gt;", spell.length = 6, 
                 by.seasons = TRUE, ncores = NULL)
str(a)
</code></pre>

<hr>
<h2 id='WeightedCells'>Compute the square-root of the cosine of the latitude weighting on the given 
array.</h2><span id='topic+WeightedCells'></span>

<h3>Description</h3>

<p>This function performs square-root of the cosine of the latitude weighting on 
the given array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WeightedCells(data, lat, lat_dim = "lat", method = "cos", ncores = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="WeightedCells_+3A_data">data</code></td>
<td>
<p>A numeric array with named dimensions, representing the data to be
applied the weights. It should have at least the latitude dimension and it 
can have more other dimensions.</p>
</td></tr>
<tr><td><code id="WeightedCells_+3A_lat">lat</code></td>
<td>
<p>A numeric vector or array with one dimension containing the 
latitudes (in degrees).</p>
</td></tr>
<tr><td><code id="WeightedCells_+3A_lat_dim">lat_dim</code></td>
<td>
<p>A character string indicating the name of the latitudinal
dimension. The default value is 'lat'.</p>
</td></tr>
<tr><td><code id="WeightedCells_+3A_method">method</code></td>
<td>
<p>A character string indicating the type of weighting applied: 
'cos' (cosine of the latitude) or 'sqrtcos' (square-root of the 
cosine of the latitude). The default value is 'cos'.</p>
</td></tr>
<tr><td><code id="WeightedCells_+3A_ncores">ncores</code></td>
<td>
<p>An integer indicating the number of cores to use for parallel 
computation. The default value is NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array containing the latitude weighted data with same dimensions as
parameter 'data'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exp &lt;- array(rnorm(1:30), dim = c(lat = 3, lon = 5, sdate = 2))
lat &lt;- c(10, 15, 20)
res &lt;- WeightedCells(data = exp, lat = lat)
</code></pre>

<hr>
<h2 id='WeightedMean'>Calculate spatial area-weighted average of multidimensional arrays</h2><span id='topic+WeightedMean'></span>

<h3>Description</h3>

<p>This function computes a spatial area-weighted average of n-dimensional arrays 
being possible to select a region and to add a mask to be applied when 
computing the average.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WeightedMean(
  data,
  lon,
  lat,
  region = NULL,
  mask = NULL,
  londim = "lon",
  latdim = "lat",
  na.rm = TRUE,
  ncores = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="WeightedMean_+3A_data">data</code></td>
<td>
<p>A numeric array with named dimensions, representing the data to be
applied the weights. It should have at least the latitude dimension and it 
can have more other dimensions.</p>
</td></tr>
<tr><td><code id="WeightedMean_+3A_lon">lon</code></td>
<td>
<p>A numeric vector of longitude locations of the cell centers of the 
grid of <code>data</code>. This vector must be of the same length as the longitude 
dimension in the parameter <code>data</code> (in degrees).</p>
</td></tr>
<tr><td><code id="WeightedMean_+3A_lat">lat</code></td>
<td>
<p>A numeric vector of latitude locations of the cell centers of the 
grid of <code>data</code>. This vector must be of the same length as the latitude 
dimension in the parameter <code>data</code> (in degrees).</p>
</td></tr>
<tr><td><code id="WeightedMean_+3A_region">region</code></td>
<td>
<p>A vector of length four indicating the minimum longitude, the 
maximum longitude, the minimum latitude and the maximum latitude of the 
region to be averaged.</p>
</td></tr>
<tr><td><code id="WeightedMean_+3A_mask">mask</code></td>
<td>
<p>A matrix with the same spatial dimensions of <code>data</code>. It can 
contain either a) TRUE where the value at that position is to be accounted 
for and FALSE where not, or b) numeric values, where those greater or equal 
to 0.5 are to be accounted for, and those smaller are not. Attention: if the 
longitude and latitude dimensions of the data and mask coincide in length, 
the user must ensure the dimensions of the mask are in the same order as the 
dimensions in the array provided in the parameter <code>data</code>.</p>
</td></tr>
<tr><td><code id="WeightedMean_+3A_londim">londim</code></td>
<td>
<p>A character string indicating the name of the longitudinal
dimension. The default value is 'lon'.</p>
</td></tr>
<tr><td><code id="WeightedMean_+3A_latdim">latdim</code></td>
<td>
<p>A character string indicating the name of the latitudinal
dimension. The default value is 'lat'.</p>
</td></tr>
<tr><td><code id="WeightedMean_+3A_na.rm">na.rm</code></td>
<td>
<p>A logical value indicating whether missing values should be 
stripped before the computation proceeds, by default it is set to TRUE.</p>
</td></tr>
<tr><td><code id="WeightedMean_+3A_ncores">ncores</code></td>
<td>
<p>An integer indicating the number of cores to use for parallel 
computation. The default value is NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array, matrix or vector containig the area-weighted average with 
the same dimensions as <code>data</code>, except for the spatial longitude and 
latitude dimensions, which disappear.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1:
data &lt;- 1:(2 * 3 * 4 * 5)
dim(data) &lt;- c(lon = 2, lat = 3, time = 4, model = 5)
lat &lt;- c(1, 10, 20)
lon &lt;- c(1, 10)
a &lt;- WeightedMean(data = data, lon = lon, lat = lat, region = NULL)

mask &lt;- c(0, 1, 0, 1, 0, 1)
dim(mask) &lt;- c(lon = 2, lat = 3)
a &lt;- WeightedMean(data = data, lon = lon, lat = lat, mask = mask)

region &lt;- c(1, 10, 1, 10)
a &lt;- WeightedMean(data = data, lon = lon, lat = lat, region = region, 
                 mask = mask)

# Example 2:
data &lt;- 1:(2 * 3 * 4)
dim(data) &lt;- c(lon = 2, lat = 3, time = 4)
lat &lt;- c(1, 10, 20)
lon &lt;- c(1, 10)
a &lt;- WeightedMean(data = data, lon = lon, lat = lat)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
