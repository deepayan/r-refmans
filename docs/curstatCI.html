<!DOCTYPE html><html lang="en"><head><title>Help for package curstatCI</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {curstatCI}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ComputeBW'><p>Data-driven bandwidth vector</p></a></li>
<li><a href='#ComputeConfIntervals'><p>Pointwise Confidence Intervals under Current Status data</p></a></li>
<li><a href='#ComputeMLE'><p>Maximum Likelihood Estimator</p></a></li>
<li><a href='#ComputeSMLE'><p>Smoothed Maximum Likelihood Estimator</p></a></li>
<li><a href='#hepatitisA'><p>Hepatitis A data</p></a></li>
<li><a href='#rubella'><p>Rubella data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Confidence Intervals for the Current Status Model</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Computes the maximum likelihood estimator, the smoothed maximum likelihood
    estimator and pointwise bootstrap confidence intervals for the distribution 
    function under current status data. 
    Groeneboom and Hendrickx (2017) &lt;<a href="https://doi.org/10.1214%2F17-EJS1345">doi:10.1214/17-EJS1345</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1.9000</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/kimhendrickx/curstatCI">https://github.com/kimhendrickx/curstatCI</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/kimhendrickx/curstatCI/issues">https://github.com/kimhendrickx/curstatCI/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-10-12 07:58:35 UTC; lucp8442</td>
</tr>
<tr>
<td>Author:</td>
<td>Piet Groeneboom [aut],
  Kim Hendrickx [cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kim Hendrickx &lt;kim.hendrickx@uhasselt.be&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-10-12 08:05:28 UTC</td>
</tr>
</table>
<hr>
<h2 id='ComputeBW'>Data-driven bandwidth vector</h2><span id='topic+ComputeBW'></span>

<h3>Description</h3>

<p>The function ComputeBW computes the bandwidth that minimizes the pointwise Mean Squared Error using the subsampling principle in combination with undersmoothing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ComputeBW(data, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ComputeBW_+3A_data">data</code></td>
<td>
<p>Dataframe with three variables:
</p>

<dl>
<dt>t</dt><dd><p>Observation points t sorted in ascending order. All observations need to be positive. The total number of unique observation points equals <code>length(t)</code>.</p>
</dd>
<dt>freq1</dt><dd><p>Frequency of observation t satisfying <code class="reqn">x \le t</code>.
The total number of observations with censoring indicator <code class="reqn">\delta =1</code> equals <code>sum(freq1)</code>. </p>
</dd>
<dt>freq2</dt><dd><p>Frequency of observation t. The sample size equals <code>sum(freq2)</code>. If no tied observations are present in the data <code>length(t)</code> equals <code>sum(freq2)</code>. </p>
</dd>
</dl>
</td></tr>
<tr><td><code id="ComputeBW_+3A_x">x</code></td>
<td>
<p>numeric vector containing the points where the confidence intervals are computed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>bw data-driven bandwidth vector of size <code>length(x)</code> containing the bandwidth value for each point in x.
</p>


<h3>References</h3>

<p>Groeneboom, P. and Hendrickx, K. (2017). The nonparametric bootstrap for the current status model. Electronic Journal of Statistics 11(2):3446-3848.
</p>


<h3>See Also</h3>

<p><code>vignette("curstatCI")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(Rcpp)
library(curstatCI)

# sample size
n &lt;- 1000

# truncated exponential distribution on (0,2)
set.seed(100)
t &lt;- rep(NA, n)
delta &lt;- rep(NA, n)
for(i in (1:n) ){
  x&lt;-runif(1)
  y&lt;--log(1-(1-exp(-2))*x)
  t[i]&lt;-2*runif(1);
  if(y&lt;=t[i]){ delta[i]&lt;-1}
  else{delta[i]&lt;-0}}

A&lt;-cbind(t[order(t)], delta[order(t)], rep(1,n))

# x vector
grid&lt;-seq(0.1,1.9 ,by = 0.1)

# data-driven bandwidth vector
bw &lt;- ComputeBW(data =A, x = grid)
plot(grid, bw)

</code></pre>

<hr>
<h2 id='ComputeConfIntervals'>Pointwise Confidence Intervals under Current Status data</h2><span id='topic+ComputeConfIntervals'></span>

<h3>Description</h3>

<p>The function ComputeConfIntervals computes pointwise confidence intervals for the distribution function under current status data.
The confidence intervals are based on the Smoothed Maximum likelihood Estimator and constructed using the nonparametric bootstrap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ComputeConfIntervals(data, x, alpha, bw)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ComputeConfIntervals_+3A_data">data</code></td>
<td>
<p>Dataframe with three variables:
</p>

<dl>
<dt>t</dt><dd><p>Observation points t sorted in ascending order. All observations need to be positive. The total number of unique observation points equals <code>length(t)</code>.</p>
</dd>
<dt>freq1</dt><dd><p>Frequency of observation t satisfying <code class="reqn">x \le t</code>.
The total number of observations with censoring indicator <code class="reqn">\delta =1</code> equals <code>sum(freq1)</code>. </p>
</dd>
<dt>freq2</dt><dd><p>Frequency of observation t. The sample size equals <code>sum(freq2)</code>. If no tied observations are present in the data <code>length(t)</code> equals <code>sum(freq2)</code>. </p>
</dd>
</dl>
</td></tr>
<tr><td><code id="ComputeConfIntervals_+3A_x">x</code></td>
<td>
<p>numeric vector containing the points where the confidence intervals are computed.
This vector needs to be contained within the observation interval: <code class="reqn">t[1] &lt; min(x) \le max(x) &lt; t[n]</code>.</p>
</td></tr>
<tr><td><code id="ComputeConfIntervals_+3A_alpha">alpha</code></td>
<td>
<p>confidence level of pointwise confidence intervals.</p>
</td></tr>
<tr><td><code id="ComputeConfIntervals_+3A_bw">bw</code></td>
<td>
<p>numeric vector of size <code>length(x)</code>.
This vector contains the pointwise bandwidth values for each point in the vector x.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the current status model, the variable of interest <code class="reqn">X</code> with distribution function <code class="reqn">F</code> is not observed directly.
A censoring variable <code class="reqn">T</code> is observed instead together with the indicator <code class="reqn">\Delta = (X \le T)</code>.
ComputeConfIntervals computes the pointwise <code>1-alpha</code> bootstrap confidence intervals around the SMLE of <code class="reqn">F</code> based on a sample of size <code>n &lt;- sum(data$freq2)</code>.
</p>
<p>The bandwidth parameter vector that minimizes the pointwise Mean Squared Error using the subsampling principle in combination with undersmoothing is returned by the function <code><a href="#topic+ComputeBW">ComputeBW</a></code>.
</p>
<p>The default method for constructing the confidence intervals in [Groeneboom &amp; Hendrickx (2017)] is based on estimating the asymptotic variance of the SMLE.
When the bandwidth is small for some point in x, the variance estimate of the SMLE at this point might not exist.
If this happens the Non-Studentized confidence interval is returned for this particular point in x.
</p>


<h3>Value</h3>

<p>List with 5 variables:
</p>

<dl>
<dt>MLE </dt><dd><p>Maximum Likelihood Estimator. This is a matrix of dimension (m+1)x2 where m is the number of jump points of the MLE.
The first column consists of the point zero and the jump locations of the MLE. The second column contains the value zero and the values of the MLE at the jump points. </p>
</dd>
<dt>SMLE </dt><dd><p>Smoothed Maximum Likelihood Estimator. This is a vector of size <code>length(x)</code> containing the values of the SMLE for each point in the vector x. </p>
</dd>
<dt>CI </dt><dd><p>pointwise confidence interval. This is a matrix of dimension <code>length(x)</code>x2.
The first resp. second column contains the lower resp. upper values of the confidence intervals for each point in x.</p>
</dd>
<dt>Studentized</dt><dd><p>points in x for which Studentized nonparametric bootstrap confidence intervals are computed. </p>
</dd>
<dt>NonStudentized</dt><dd><p>points in x for which classical nonparametric bootstrap confidence intervals are computed.</p>
</dd>
</dl>



<h3>References</h3>

<p>Groeneboom, P. and Hendrickx, K. (2017). The nonparametric bootstrap for the current status model. Electronic Journal of Statistics 11(2):3446-3848.
</p>


<h3>See Also</h3>

<p><code>vignette("curstatCI")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(Rcpp)
library(curstatCI)

# sample size
n &lt;- 1000

# Uniform data  U(0,2)
set.seed(2)
y &lt;- runif(n,0,2)
t &lt;- runif(n,0,2)
delta &lt;- as.numeric(y &lt;= t)

A&lt;-cbind(t[order(t)], delta[order(t)], rep(1,n))

# x vector
grid&lt;-seq(0.1,1.9 ,by = 0.1)

# data-driven bandwidth vector
bw &lt;- ComputeBW(data =A, x = grid)

# pointwise confidence intervals at grid points:
out&lt;-ComputeConfIntervals(data = A,x =grid,alpha = 0.05, bw = bw)

left &lt;- out$CI[,1]
right &lt;- out$CI[,2]

plot(grid, out$SMLE,type ='l', ylim=c(0,1), main= "",ylab="",xlab="",las=1)
points(grid, left, col = 4)
points(grid, right, col = 4)
segments(grid,left, grid, right)

</code></pre>

<hr>
<h2 id='ComputeMLE'>Maximum Likelihood Estimator</h2><span id='topic+ComputeMLE'></span>

<h3>Description</h3>

<p>The function ComputeMLE computes the Maximum Likelihood Estimator of the distribution function under current status data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ComputeMLE(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ComputeMLE_+3A_data">data</code></td>
<td>
<p>Dataframe with three variables:
</p>

<dl>
<dt>t</dt><dd><p>Observation points t sorted in ascending order. All observations need to be positive. The total number of unique observation points equals <code>length(t)</code>.</p>
</dd>
<dt>freq1</dt><dd><p>Frequency of observation t satisfying <code class="reqn">x \le t</code>.
The total number of observations with censoring indicator <code class="reqn">\delta =1</code> equals <code>sum(freq1)</code>. </p>
</dd>
<dt>freq2</dt><dd><p>Frequency of observation t. The sample size equals <code>sum(freq2)</code>. If no tied observations are present in the data <code>length(t)</code> equals <code>sum(freq2)</code>. </p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>In the current status model, the variable of interest <code class="reqn">X</code> with distribution function <code class="reqn">F</code> is not observed directly.
A censoring variable <code class="reqn">T</code> is observed instead together with the indicator <code class="reqn">\Delta = (X \le T)</code>.
ComputeMLE computes the MLE of <code class="reqn">F</code> based on a sample of size <code>n &lt;- sum(data$freq2)</code>.
</p>


<h3>Value</h3>

<p>Dataframe with two variables :
</p>

<dl>
<dt>x</dt><dd><p>jump locations of the MLE</p>
</dd>
<dt>mle</dt><dd><p>MLE evaluated at the jump locations</p>
</dd>
</dl>



<h3>References</h3>

<p>Groeneboom, P. and Hendrickx, K. (2017). The nonparametric bootstrap for the current status model. Electronic Journal of Statistics 11(2):3446-3848.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ComputeConfIntervals">ComputeConfIntervals</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(Rcpp)
library(curstatCI)

# sample size
n &lt;- 1000

# Uniform data  U(0,2)
set.seed(2)
y &lt;- runif(n,0,2)
t &lt;- runif(n,0,2)
delta &lt;- as.numeric(y &lt;= t)

A&lt;-cbind(t[order(t)], delta[order(t)], rep(1,n))
mle &lt;-ComputeMLE(A)
plot(mle$x, mle$mle,type ='s', ylim=c(0,1), main= "",ylab="",xlab="",las=1)

</code></pre>

<hr>
<h2 id='ComputeSMLE'>Smoothed Maximum Likelihood Estimator</h2><span id='topic+ComputeSMLE'></span>

<h3>Description</h3>

<p>The function ComputeSMLE computes the Smoothed Maximum Likelihood Estimator of the distribution function under current status data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ComputeSMLE(data, x, bw)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ComputeSMLE_+3A_data">data</code></td>
<td>
<p>Dataframe with three variables:
</p>

<dl>
<dt>t</dt><dd><p>Observation points t sorted in ascending order. All observations need to be positive. The total number of unique observation points equals <code>length(t)</code>.</p>
</dd>
<dt>freq1</dt><dd><p>Frequency of observation t satisfying <code class="reqn">x \le t</code>.
The total number of observations with censoring indicator <code class="reqn">\delta =1</code> equals <code>sum(freq1)</code>. </p>
</dd>
<dt>freq2</dt><dd><p>Frequency of observation t. The sample size equals <code>sum(freq2)</code>. If no tied observations are present in the data <code>length(t)</code> equals <code>sum(freq2)</code>. </p>
</dd>
</dl>
</td></tr>
<tr><td><code id="ComputeSMLE_+3A_x">x</code></td>
<td>
<p>numeric vector containing the points where the confidence intervals are computed.</p>
</td></tr>
<tr><td><code id="ComputeSMLE_+3A_bw">bw</code></td>
<td>
<p>numeric vector of size <code>length(x)</code>. This vector contains the pointwise bandwidth values for each point in the vector x.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the current status model, the variable of interest <code class="reqn">X</code> with distribution function <code class="reqn">F</code> is not observed directly.
A censoring variable <code class="reqn">T</code> is observed instead together with the indicator <code class="reqn">\Delta = (X \le T)</code>.
ComputeSMLE computes the SMLE of <code class="reqn">F</code> based on a sample of size <code>n &lt;- sum(data$freq2)</code>.
The bandwidth parameter vector that minimizes the pointwise Mean Squared Error using the subsampling principle in combination with undersmoothing is returned by the function <a href="#topic+ComputeBW">ComputeBW</a>.
</p>


<h3>Value</h3>

<p>SMLE(x) Smoothed Maximum Likelihood Estimator. This is a vector of size <code>length(x)</code> containing the values of the SMLE for each point in the vector x.
</p>


<h3>References</h3>

<p>Groeneboom, P. and Hendrickx, K. (2017). The nonparametric bootstrap for the current status model. Electronic Journal of Statistics 11(2):3446-3848.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ComputeConfIntervals">ComputeConfIntervals</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(Rcpp)
library(curstatCI)

# sample size
n &lt;- 1000

# Uniform data  U(0,2)
set.seed(2)
y &lt;- runif(n,0,2)
t &lt;- runif(n,0,2)
delta &lt;- as.numeric(y &lt;= t)

A&lt;-cbind(t[order(t)], delta[order(t)], rep(1,n))
grid &lt;-seq(0,2 ,by = 0.01)

# bandwidth vector
h&lt;-rep(2*n^-0.2,length(grid))

smle &lt;-ComputeSMLE(A,grid,h)
plot(grid, smle,type ='l', ylim=c(0,1), main= "",ylab="",xlab="",las=1)


</code></pre>

<hr>
<h2 id='hepatitisA'>Hepatitis A data</h2><span id='topic+hepatitisA'></span>

<h3>Description</h3>

<p>A dataset on the prevalence of hepatitis A in individuals from Bulgaria
with age ranging from 1 to 86 years.
The data consists of a cross-sectional survey conducted in 1964.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hepatitisA
</code></pre>


<h3>Format</h3>

<p>A data frame with 83 rows and  three variables:
</p>

<dl>
<dt>t</dt><dd><p> Age of the individual</p>
</dd>
<dt>freq1</dt><dd><p> Number of individuals of age t that are seropositive for Hepatitis A</p>
</dd>
<dt>freq2</dt><dd><p> Total number of individuals of age t</p>
</dd>
</dl>


<h3>References</h3>

<p>Keiding, N. (1991). Age-specic incidence and prevalence: a statistical perspective. J. Roy. Statist. Soc. Ser. A,154(3):371-412.
</p>

<hr>
<h2 id='rubella'>Rubella data</h2><span id='topic+rubella'></span>

<h3>Description</h3>

<p>A dataset on the prevalence of rubella in 230 Austrian males
older than three months for whom the exact date of birth was known.
Each individual was tested at the Institute of Virology, Vienna
during the period 1–25 March 1988 for immunization against Rubella.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rubella
</code></pre>


<h3>Format</h3>

<p>A data frame with 225 rows and  three variables:
</p>

<dl>
<dt>t</dt><dd><p> Age of the individual at the time of testing for immunization</p>
</dd>
<dt>freq1</dt><dd><p> Number of individuals of age t that are immune for Rubella</p>
</dd>
<dt>freq2</dt><dd><p> Total number of individuals of age t</p>
</dd>
</dl>


<h3>References</h3>

<p>Keiding, N., Begtrup, K., Scheike, T., and Hasibeder, G. (1996). Estimation from current status data in continuous time. Lifetime Data Anal., 2:119-129.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
