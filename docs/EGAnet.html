<!DOCTYPE html><html><head><title>Help for package EGAnet</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {EGAnet}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#EGAnet-package'><p>EGAnet-package</p></a></li>
<li><a href='#auto.correlate'><p>Automatic correlations</p></a></li>
<li><a href='#boot.ergoInfo'><p>Bootstrap Test for the Ergodicity Information Index</p></a></li>
<li><a href='#boot.wmt'><p><code>bootEGA</code> Results of <code>wmt2</code>Data</p></a></li>
<li><a href='#bootEGA'><p>Bootstrap Exploratory Graph Analysis</p></a></li>
<li><a href='#CFA'><p>CFA Fit of <code>EGA</code> or <code>hierEGA</code> Structure</p></a></li>
<li><a href='#color_palette_EGA'><p><code>EGA</code> Color Palettes</p></a></li>
<li><a href='#community.compare'><p>Compares Community Detection Solutions Using Permutation</p></a></li>
<li><a href='#community.consensus'><p>Applies the Consensus Clustering Method (Louvain only)</p></a></li>
<li><a href='#community.detection'><p>Apply a Community Detection Algorithm</p></a></li>
<li><a href='#community.homogenize'><p>Homogenize Community Memberships</p></a></li>
<li><a href='#community.unidimensional'><p>Approaches to Detect Unidimensional Communities</p></a></li>
<li><a href='#compare.EGA.plots'><p>Visually Compare Two or More <code>EGAnet</code> plots</p></a></li>
<li><a href='#convert2igraph'><p>Convert networks to <code>igraph</code></p></a></li>
<li><a href='#convert2tidygraph'><p>Convert networks to <code>tidygraph</code></p></a></li>
<li><a href='#depression'><p>Depression Data</p></a></li>
<li><a href='#dimensionStability'><p>Dimension Stability Statistics from <code>bootEGA</code></p></a></li>
<li><a href='#dnn.weights'><p>Loadings Comparison Test Deep Learning Neural Network Weights</p></a></li>
<li><a href='#dynEGA'><p>Dynamic Exploratory Graph Analysis</p></a></li>
<li><a href='#dynEGA.ind.pop'><p>Intra- and Inter-individual <code>dynEGA</code></p></a></li>
<li><a href='#EBICglasso.qgraph'><p><code>EBICglasso</code> from <code>qgraph</code> 1.4.4</p></a></li>
<li><a href='#EGA'><p>Exploratory Graph Analysis</p></a></li>
<li><a href='#EGA.estimate'><p>Estimates <code>EGA</code> for Multidimensional Structures</p></a></li>
<li><a href='#EGA.fit'><p><code>EGA</code> Optimal Model Fit using the Total Entropy Fit Index  (<code>tefi</code>)</p></a></li>
<li><a href='#ega.wmt'><p><code>EGA</code> Network of <code>wmt2</code>Data</p></a></li>
<li><a href='#EGAnet-plot'><p>S3 Plot Methods for <code>EGAnet</code></p></a></li>
<li><a href='#Embed'><p>Time-delay Embedding</p></a></li>
<li><a href='#entropyFit'><p>Entropy Fit Index</p></a></li>
<li><a href='#ergoInfo'><p>Ergodicity Information Index</p></a></li>
<li><a href='#genTEFI'><p>Generalized Total Entropy Fit Index using Von Neumman's entropy (Quantum Information Theory) for correlation matrices</p></a></li>
<li><a href='#glla'><p>Generalized Local Linear Approximation</p></a></li>
<li><a href='#hierEGA'><p>Hierarchical <code>EGA</code></p></a></li>
<li><a href='#igraph2matrix'><p>Convert <code>igraph</code> network to matrix</p></a></li>
<li><a href='#infoCluster'><p>Information Theoretic Mixture Clustering for <code>dynEGA</code></p></a></li>
<li><a href='#intelligenceBattery'><p>Intelligence Data</p></a></li>
<li><a href='#invariance'><p>Measurement Invariance of <code>EGA</code> Structure</p></a></li>
<li><a href='#itemStability'><p>Item Stability Statistics from <code>bootEGA</code></p></a></li>
<li><a href='#jsd'><p>Jensen-Shannon Distance</p></a></li>
<li><a href='#LCT'><p>Loadings Comparison Test</p></a></li>
<li><a href='#modularity'><p>Computes the (Signed) Modularity Statistic</p></a></li>
<li><a href='#net.loads'><p>Network Loadings</p></a></li>
<li><a href='#net.scores'><p>Network Scores</p></a></li>
<li><a href='#network.estimation'><p>Apply a Network Estimation Method</p></a></li>
<li><a href='#network.generalizability'><p>Estimate the Generalizability of Network</p></a></li>
<li><a href='#network.predictability'><p>Predict New Data based on Network</p></a></li>
<li><a href='#optimism'><p>Optimism Data</p></a></li>
<li><a href='#polychoric.matrix'><p>Computes Polychoric Correlations</p></a></li>
<li><a href='#prime.num'><p>Prime Numbers through 100,000</p></a></li>
<li><a href='#riEGA'><p>Random-Intercept <code>EGA</code></p></a></li>
<li><a href='#sim.dynEGA'><p>sim.dynEGA Data</p></a></li>
<li><a href='#simDFM'><p>Simulate data following a Dynamic Factor Model</p></a></li>
<li><a href='#tefi'><p>Total Entropy Fit Index using Von Neumman's entropy (Quantum Information Theory) for correlation matrices</p></a></li>
<li><a href='#TMFG'><p>Triangulated Maximally Filtered Graph</p></a></li>
<li><a href='#totalCor'><p>Total Correlation</p></a></li>
<li><a href='#totalCorMat'><p>Total Correlation Matrix</p></a></li>
<li><a href='#UVA'><p>Unique Variable Analysis</p></a></li>
<li><a href='#vn.entropy'><p>Entropy Fit Index using Von Neumman's entropy (Quantum Information Theory) for correlation matrices</p></a></li>
<li><a href='#wmt2'><p>WMT-2 Data</p></a></li>
<li><a href='#wto'><p>Weighted Topological Overlap</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Exploratory Graph Analysis â€“ a Framework for Estimating the
Number of Dimensions in Multivariate Data using Network
Psychometrics</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-04-22</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hudson Golino &lt;hfg9s@virginia.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements the Exploratory Graph Analysis (EGA) framework for dimensionality
             and psychometric assessment. EGA estimates the number of dimensions in
	     	 psychological data using network estimation methods and community detection
             algorithms. A bootstrap method is provided to assess the stability of dimensions
	     	 and items. Fit is evaluated using the Entropy Fit family of indices. Unique 
             Variable Analysis evaluates the extent to which items are locally dependent (or
             redundant). Network loadings provide similar information to factor loadings and
	     	 can be used to compute network scores. A bootstrap and permutation approach are
             available to assess configural and metric invariance. Hierarchical structures
             can be detected using Hierarchical EGA. Time series and intensive longitudinal 
	     	 data can be analyzed using Dynamic EGA, supporting individual, group, and 
             population level assessments.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3.0)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>dendextend, fungible, future, future.apply, glasso, GGally,
ggplot2, ggpubr, GPArotation, igraph (&ge; 1.3.0), lavaan,
Matrix, methods, network, progressr, qgraph, semPlot, sna,
stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>fitdistrplus, gridExtra, knitr, markdown, pbapply, progress,
psych, pwr, RColorBrewer</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://r-ega.net">https://r-ega.net</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/hfgolino/EGAnet/issues">https://github.com/hfgolino/EGAnet/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-22 12:09:21 UTC; alextops</td>
</tr>
<tr>
<td>Author:</td>
<td>Hudson Golino <a href="https://orcid.org/0000-0002-1601-1447"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Alexander Christensen
    <a href="https://orcid.org/0000-0002-9798-7037"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Robert Moulder <a href="https://orcid.org/0000-0001-7504-9560"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Luis E. Garrido <a href="https://orcid.org/0000-0001-8932-6063"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Laura Jamison <a href="https://orcid.org/0000-0002-4656-8684"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Dingjing Shi <a href="https://orcid.org/0000-0002-5652-3818"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-22 21:50:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='EGAnet-package'>EGAnet-package</h2><span id='topic+EGAnet'></span><span id='topic+EGAnet-package'></span>

<h3>Description</h3>

<p>Implements the Exploratory Graph Analysis (EGA) framework for dimensionality
and psychometric assessment. EGA estimates the number of dimensions in
psychological data using network estimation methods and community detection
algorithms. A bootstrap method is provided to assess the stability of dimensions
and items. Fit is evaluated using the Entropy Fit family of indices. Unique 
Variable Analysis evaluates the extent to which items are locally dependent (or
redundant). Network loadings provide similar information to factor loadings and
can be used to compute network scores. A bootstrap and permutation approach are
available to assess configural and metric invariance. Hierarchical structures
can be detected using Hierarchical EGA. Time series and intensive longitudinal 
data can be analyzed using Dynamic EGA, supporting individual, group, and 
population level assessments.
</p>


<h3>Author(s)</h3>

<p>Hudson Golino &lt;hfg9s@virginia.edu&gt; and Alexander P. Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>References</h3>

<p>Christensen, A. P. (2023).
Unidimensional community detection: A Monte Carlo simulation, grid search, and comparison.
<em>PsyArXiv</em>. <br />
# Related functions: <code><a href="#topic+community.unidimensional">community.unidimensional</a></code>
</p>
<p>Christensen, A. P., Garrido, L. E., &amp; Golino, H. (2023).
Unique variable analysis: A network psychometrics method to detect local dependence.
<em>Multivariate Behavioral Research</em>. <br />
# Related functions: <code><a href="#topic+UVA">UVA</a></code>
</p>
<p>Christensen, A. P., Garrido, L. E., Guerra-Pena, K., &amp; Golino, H. (2023).
Comparing community detection algorithms in psychometric networks: A Monte Carlo simulation.
<em>Behavior Research Methods</em>. <br />
# Related functions: <code><a href="#topic+EGA">EGA</a></code>
</p>
<p>Christensen, A. P., &amp; Golino, H. (2021a).
Estimating the stability of the number of factors via Bootstrap Exploratory Graph Analysis: A tutorial.
<em>Psych</em>, <em>3</em>(3), 479-500. <br />
# Related functions: <code><a href="#topic+bootEGA">bootEGA</a></code>, <code><a href="#topic+dimensionStability">dimensionStability</a></code>,
# and <code><a href="#topic+itemStability">itemStability</a></code>
</p>
<p>Christensen, A. P., &amp; Golino, H. (2021b).
Factor or network model? Predictions from neural networks.
<em>Journal of Behavioral Data Science</em>, <em>1</em>(1), 85-126. <br />
# Related functions: <code><a href="#topic+LCT">LCT</a></code>
</p>
<p>Christensen, A. P., &amp; Golino, H. (2021c).
On the equivalency of factor and network loadings.
<em>Behavior Research Methods</em>, <em>53</em>, 1563-1580. <br />
# Related functions: <code><a href="#topic+LCT">LCT</a></code> and <code><a href="#topic+net.loads">net.loads</a></code>
</p>
<p>Christensen, A. P., Golino, H., &amp; Silvia, P. J. (2020).
A psychometric network perspective on the validity and validation of personality trait questionnaires.
<em>European Journal of Personality</em>, <em>34</em>, 1095-1108. <br />
# Related functions: <code><a href="#topic+bootEGA">bootEGA</a></code>, <code><a href="#topic+dimensionStability">dimensionStability</a></code>,
# <code><a href="#topic+EGA">EGA</a></code>, <code><a href="#topic+itemStability">itemStability</a></code>, and <code><a href="#topic+UVA">UVA</a></code>
</p>
<p>Christensen, A. P., Gross, G. M., Golino, H., Silvia, P. J., &amp; Kwapil, T. R. (2019).
Exploratory graph analysis of the Multidimensional Schizotypy Scale.
<em>Schizophrenia Research</em>, <em>206</em>, 43-51.
# Related functions: <code><a href="#topic+CFA">CFA</a></code> and <code><a href="#topic+EGA">EGA</a></code>
</p>
<p>Golino, H., Christensen, A. P., Moulder, R., Kim, S., &amp; Boker, S. M. (2021).
Modeling latent topics in social media using Dynamic Exploratory Graph Analysis: The case of the right-wing and left-wing trolls in the 2016 US elections.
<em>Psychometrika</em>. <br />
# Related functions: <code><a href="#topic+dynEGA">dynEGA</a></code> and <code><a href="#topic+simDFM">simDFM</a></code>
</p>
<p>Golino, H., &amp; Demetriou, A. (2017).
Estimating the dimensionality of intelligence like data using Exploratory Graph Analysis.
<em>Intelligence</em>, <em>62</em>, 54-70. <br />
# Related functions: <code><a href="#topic+EGA">EGA</a></code>
</p>
<p>Golino, H., &amp; Epskamp, S. (2017).
Exploratory graph analysis: A new approach for estimating the number of dimensions in psychological research.
<em>PLoS ONE</em>, <em>12</em>, e0174035. <br />
# Related functions: <code><a href="#topic+CFA">CFA</a></code>, <code><a href="#topic+EGA">EGA</a></code>, and <code><a href="#topic+bootEGA">bootEGA</a></code>
</p>
<p>Golino, H., Moulder, R., Shi, D., Christensen, A. P., Garrido, L. E., Nieto, M. D., Nesselroade, J., Sadana, R., Thiyagarajan, J. A., &amp; Boker, S. M. (2020).
Entropy fit indices: New fit measures for assessing the structure and dimensionality of multiple latent variables.
<em>Multivariate Behavioral Research</em>. <br />
# Related functions: <code><a href="#topic+entropyFit">entropyFit</a></code>, <code><a href="#topic+tefi">tefi</a></code>, and <code><a href="#topic+vn.entropy">vn.entropy</a></code> 
</p>
<p>Golino, H., Nesselroade, J. R., &amp; Christensen, A. P. (2022).
Towards a psychology of individuals: The ergodicity information index and a bottom-up approach for finding generalizations.
<em>PsyArXiv</em>. <br />
# Related functions: <code><a href="#topic+boot.ergoInfo">boot.ergoInfo</a></code>, <code><a href="#topic+ergoInfo">ergoInfo</a></code>,
<code><a href="#topic+jsd">jsd</a></code>, and <code><a href="#topic+infoCluster">infoCluster</a></code>
</p>
<p>Golino, H., Shi, D., Christensen, A. P., Garrido, L. E., Nieto, M. D., Sadana, R., Thiyagarajan, J. A., &amp; Martinez-Molina, A. (2020).
Investigating the performance of exploratory graph analysis and traditional techniques to identify the number of latent factors:
A simulation and tutorial.
<em>Psychological Methods</em>, <em>25</em>, 292-320. <br />
# Related functions: <code><a href="#topic+EGA">EGA</a></code>
</p>
<p>Golino, H., Thiyagarajan, J. A., Sadana, M., Teles, M., Christensen, A. P., &amp; Boker, S. M. (2020).
Investigating the broad domains of intrinsic capacity, functional ability, and environment:
An exploratory graph analysis approach for improving analytical methodologies for measuring healthy aging.
<em>PsyArXiv</em>. <br />
# Related functions: <code><a href="#topic+EGA.fit">EGA.fit</a></code> and <code><a href="#topic+tefi">tefi</a></code>
</p>
<p>Jamison, L., Christensen, A. P., &amp; Golino, H. (2021).
Optimizing Walktrap's community detection in networks using the Total Entropy Fit Index.
<em>PsyArXiv</em>. <br />
# Related functions: <code><a href="#topic+EGA.fit">EGA.fit</a></code> and <code><a href="#topic+tefi">tefi</a></code>
</p>
<p>Jamison, L., Golino, H., &amp; Christensen, A. P. (2023).
Metric invariance in exploratory graph analysis via permutation testing.
<em>PsyArXiv</em>. <br />
# Related functions: <code><a href="#topic+invariance">invariance</a></code>
</p>
<p>Shi, D., Christensen, A. P., Day, E., Golino, H., &amp; Garrido, L. E. (2023).
A Bayesian approach for dimensionality assessment in psychological networks.
<em>PsyArXiv</em> <br />
# Related functions: <code><a href="#topic+EGA">EGA</a></code>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://r-ega.net">https://r-ega.net</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/hfgolino/EGAnet/issues">https://github.com/hfgolino/EGAnet/issues</a>
</p>
</li></ul>


<hr>
<h2 id='auto.correlate'>Automatic correlations</h2><span id='topic+auto.correlate'></span>

<h3>Description</h3>

<p>This wrapper is similar to <code><a href="qgraph.html#topic+cor_auto">cor_auto</a></code>. There
are some minor adjustments that make this function simpler and to
function within <code><a href="#topic+EGAnet">EGAnet</a></code>. <code>NA</code> values are not treated
as categories (this behavior differs from <code><a href="qgraph.html#topic+cor_auto">cor_auto</a></code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auto.correlate(
  data,
  corr = c("kendall", "pearson", "spearman"),
  ordinal.categories = 7,
  forcePD = TRUE,
  na.data = c("pairwise", "listwise"),
  empty.method = c("none", "zero", "all"),
  empty.value = c("none", "point_five", "one_over"),
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="auto.correlate_+3A_data">data</code></td>
<td>
<p>Matrix or data frame.
Should consist only of variables to be used in the analysis</p>
</td></tr>
<tr><td><code id="auto.correlate_+3A_corr">corr</code></td>
<td>
<p>Character (length = 1).
The standard correlation method to be used.
Defaults to <code>"pearson"</code>.
Using <code>"pearson"</code> will compute polychoric, tetrachoric, polyserial,
and biserial correlations for categorical and categorical/continuous correlations
by default. To obtain <code>"pearson"</code> correlations regardless, use <code><a href="stats.html#topic+cor">cor</a></code>.
Other options of <code>"kendall"</code> and <code>"spearman"</code> are provided for
completeness and use <code><a href="stats.html#topic+cor">cor</a></code></p>
</td></tr>
<tr><td><code id="auto.correlate_+3A_ordinal.categories">ordinal.categories</code></td>
<td>
<p>Numeric (length = 1).
<em>Up to</em> the number of categories <em>before</em> a variable is considered continuous.
Defaults to <code>7</code> categories before <code>8</code> is considered continuous</p>
</td></tr>
<tr><td><code id="auto.correlate_+3A_forcepd">forcePD</code></td>
<td>
<p>Boolean (length = 1).
Whether positive definite matrix should be enforced.
Defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="auto.correlate_+3A_na.data">na.data</code></td>
<td>
<p>Character (length = 1).
How should missing data be handled?
Defaults to <code>"pairwise"</code>.
Available options:
</p>

<ul>
<li> <p><code>"pairwise"</code> &mdash; Computes correlation for all available
cases between two variables
</p>
</li>
<li> <p><code>"listwise"</code> &mdash; Computes correlation for all complete
cases in the dataset
</p>
</li></ul>
</td></tr>
<tr><td><code id="auto.correlate_+3A_empty.method">empty.method</code></td>
<td>
<p>Character (length = 1).
Method for empty cell correction in <code><a href="#topic+polychoric.matrix">polychoric.matrix</a></code>.
Defaults to <code>"none"</code>
Available options:
</p>

<ul>
<li> <p><code>"none"</code> &mdash; Adds no value (<code>empty.value = "none"</code>)
to the empirical joint frequency table between two variables
</p>
</li>
<li> <p><code>"zero"</code> &mdash; Adds <code>empty.value</code> to the cells with
zero in the joint frequency table between two variables
</p>
</li>
<li> <p><code>"all"</code> &mdash; Adds <code>empty.value</code> to all
in the joint frequency table between two variables
</p>
</li></ul>
</td></tr>
<tr><td><code id="auto.correlate_+3A_empty.value">empty.value</code></td>
<td>
<p>Character (length = 1).
Value to add to the joint frequency table cells in <code><a href="#topic+polychoric.matrix">polychoric.matrix</a></code>.
Defaults to <code>"none"</code>.
Accepts numeric values between 0 and 1 or specific methods:
</p>

<ul>
<li> <p><code>"none"</code> &mdash; Adds no value (<code>0</code>) to the empirical
joint  frequency table between two variables
</p>
</li>
<li> <p><code>"point_five"</code> &mdash; Adds <code>0.5</code> to the cells
defined by <code>empty.method</code>
</p>
</li>
<li> <p><code>"one_over"</code> &mdash; Adds <code>1 / n</code> where <code>n</code> equals the
number of cells based on <code>empty.method</code>. For
<code>empty.method = "zero"</code>, <code>n</code> equals the number of zero cells
</p>
</li></ul>
</td></tr>
<tr><td><code id="auto.correlate_+3A_verbose">verbose</code></td>
<td>
<p>Boolean (length = 1).
Whether messages should be printed.
Defaults to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="auto.correlate_+3A_...">...</code></td>
<td>
<p>Not actually used but makes it easier for general functionality
in the package</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alexander P. Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
wmt &lt;- wmt2[,7:24]

# Obtain correlations
wmt_corr &lt;- auto.correlate(wmt)

</code></pre>

<hr>
<h2 id='boot.ergoInfo'>Bootstrap Test for the Ergodicity Information Index</h2><span id='topic+boot.ergoInfo'></span>

<h3>Description</h3>

<p>Tests the Ergodicity Information Index obtained in the 
empirical sample with a distribution of EII obtained by a variant of
bootstrap sampling (see <strong>Details</strong> for the procedure)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot.ergoInfo(
  dynEGA.object,
  EII,
  use = c("edge.list", "unweighted", "weighted"),
  shuffles = 5000,
  iter = 100,
  ncores,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot.ergoInfo_+3A_dynega.object">dynEGA.object</code></td>
<td>
<p>A <code><a href="#topic+dynEGA">dynEGA</a></code> or a
<code><a href="#topic+dynEGA.ind.pop">dynEGA.ind.pop</a></code> object. If a <code><a href="#topic+dynEGA">dynEGA</a></code>
object, then <code>level = c("individual", "population")</code> is required</p>
</td></tr>
<tr><td><code id="boot.ergoInfo_+3A_eii">EII</code></td>
<td>
<p>A <code><a href="#topic+ergoInfo">ergoInfo</a></code> object 
used to estimate the Empirical Ergodicity Information Index 
or the estimated value of EII estimated using the <code><a href="#topic+ergoInfo">ergoInfo</a></code> 
function. Inherits <code>use</code> from <code><a href="#topic+ergoInfo">ergoInfo</a></code>.
If no <code><a href="#topic+ergoInfo">ergoInfo</a></code> object is provided, then it is estimated</p>
</td></tr>
<tr><td><code id="boot.ergoInfo_+3A_use">use</code></td>
<td>
<p>Character (length = 1).
A string indicating what network element will be used
to compute the algorithm complexity, the list of edges or the weights of the network.
Defaults to <code>use = "unweighted"</code>.
Current options are:
</p>

<ul>
<li> <p><code>"edge.list"</code> &mdash; Calculates the algorithm complexity using the list of edges
</p>
</li>
<li> <p><code>"unweighted"</code> &mdash; Calculates the algorithm complexity using the binary weights of the encoded prime 
transformed network. 0 = edge absent and 1 = edge present
</p>
</li>
<li> <p><code>"weighted"</code> &mdash; Calculates the algorithm complexity using the weights of encoded prime-weight transformed network
</p>
</li></ul>
</td></tr>
<tr><td><code id="boot.ergoInfo_+3A_shuffles">shuffles</code></td>
<td>
<p>Numeric.
Number of shuffles used to compute the Kolmogorov complexity.
Defaults to <code>5000</code></p>
</td></tr>
<tr><td><code id="boot.ergoInfo_+3A_iter">iter</code></td>
<td>
<p>Numeric (length = 1).
Number of replica samples to generate from the bootstrap analysis.
Defaults to <code>100</code> (<code>1000</code> for robustness)</p>
</td></tr>
<tr><td><code id="boot.ergoInfo_+3A_ncores">ncores</code></td>
<td>
<p>Numeric (length = 1).
Number of cores to use in computing results.
Defaults to <code>ceiling(parallel::detectCores() / 2)</code> or half of your
computer's processing power.
Set to <code>1</code> to not use parallel computing
</p>
<p>If you're unsure how many cores your computer has,
then type: <code>parallel::detectCores()</code></p>
</td></tr>
<tr><td><code id="boot.ergoInfo_+3A_verbose">verbose</code></td>
<td>
<p>Boolean (length = 1).
Should progress be displayed?
Defaults to <code>TRUE</code>.
Set to <code>FALSE</code> to not display progress</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In traditional bootstrap sampling, individual participants are resampled 
with replacement from the empirical sample. This process is time consuming 
when carried out across <em>v</em> number of variables, <em>n</em> number of 
participants, <em>t</em> number of time points, and <em>i</em> number of iterations.
Instead, <code>boot.ergoInfo</code> uses the premise of an ergodic process to 
establish more efficient test that works directly on the sample's networks.
</p>
<p>With an ergodic process, the expectation is that all individuals will have
a systematic relationship with the population. Destroying this relationship
should result in a significant loss of information. Following this conjecture,
<code>boot.ergoInfo</code> shuffles a random subset of edges that exist in the
<strong>population</strong> that is <em>equal</em> to the number of shared edges
it has with an individual. An individual's unique edges remain the same,
controlling for their unique information. The result is a replicate individual
that contains the same total number of edges as the actual individual but
its shared information with the population has been scrambled. 
</p>
<p>This process is repeated over each individual to create a replicate sample
and is repeated for <em>X</em> iterations (e.g., 100). This approach creates
a sampling distribution that represents the expected information between
the population and individuals when a random process generates the shared
information between them. If the shared information between the population
and individuals in the empirical sample is sufficiently meaningful, then
this process should result in significant information loss.
</p>
<p>How to interpret the results: the result of <code>boot.ergoInfo</code> is a sampling 
distribution of EII values that would be expected if the process was random 
(null distribution). If the empirical EII value is <em>greater than</em> or
not significantly different from the null distribution, then the empirical 
data can be expected to be generated from an nonergodic process and the 
population structure is not sufficient to describe all individuals. If the 
empirical EII value is significantly <em>lower than</em> the null distribution, 
then the empirical data can be described by the population structure &ndash; the
population structure is sufficient to describe all individuals.
</p>


<h3>Value</h3>

<p>Returns a list containing:
</p>
<table>
<tr><td><code>empirical.ergoInfo</code></td>
<td>
<p>Empirical Ergodicity Information Index</p>
</td></tr>
<tr><td><code>boot.ergoInfo</code></td>
<td>
<p>The values of the Ergodicity Information Index obtained in the bootstrap</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided <em>p</em>-value of the bootstrap test for the Ergodicity Information Index.
The null hypothesis is that the empirical Ergodicity Information index is equal to the expected value of the EII
with small variation in the population structure</p>
</td></tr>
<tr><td><code>effect</code></td>
<td>
<p>Indicates wheter the empirical EII is greater or less then the bootstrap distribution of EII.</p>
</td></tr>
<tr><td><code>interpretation</code></td>
<td>
<p>How you can interpret the result of the test in plain English</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hudson Golino &lt;hfg9s at virginia.edu&gt; &amp; Alexander P. Christensen &lt;alexander.christensen at Vanderbilt.Edu&gt;
</p>


<h3>References</h3>

<p><strong>Original Implementation</strong> <br />
Golino, H., Nesselroade, J. R., &amp; Christensen, A. P. (2022).
Toward a psychology of individuals: The ergodicity information index and a bottom-up approach for finding generalizations.
<em>PsyArXiv</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.EGAnet">plot.EGAnet</a></code> for plot usage in <code><a href="#topic+EGAnet">EGAnet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Obtain simulated data
sim.data &lt;- sim.dynEGA

## Not run: 
# Dynamic EGA individual and population structures
dyn1 &lt;- dynEGA.ind.pop(
  data = sim.dynEGA[,-26], n.embed = 5, tau = 1,
  delta = 1, id = 25, use.derivatives = 1,
  model = "glasso", ncores = 2, corr = "pearson"
)

# Empirical Ergodicity Information Index
eii1 &lt;- ergoInfo(dynEGA.object = dyn1, use = "unweighted")

# Bootstrap Test for Ergodicity Information Index
testing.ergoinfo &lt;- boot.ergoInfo(
  dynEGA.object = dyn1, EII = eii1,
  ncores = 2, use = "unweighted"
)

# Plot result
plot(testing.ergoinfo)

# Example using `dynEGA`
dyn2 &lt;- dynEGA(
  data = sim.dynEGA, n.embed = 5, tau = 1,
  delta = 1, use.derivatives = 1, ncores = 2,
  level = c("individual", "population")
)

# Empirical Ergodicity Information Index
eii2 &lt;- ergoInfo(dynEGA.object = dyn2, use = "unweighted")

# Bootstrap Test for Ergodicity Information Index
testing.ergoinfo2 &lt;- boot.ergoInfo(
  dynEGA.object = dyn2, EII = eii2,
  ncores = 2
)

# Plot result
plot(testing.ergoinfo2)
## End(Not run)

</code></pre>

<hr>
<h2 id='boot.wmt'><code><a href="#topic+bootEGA">bootEGA</a></code> Results of <code><a href="#topic+wmt2">wmt2</a></code>Data</h2><span id='topic+boot.wmt'></span>

<h3>Description</h3>

<p><code><a href="#topic+bootEGA">bootEGA</a></code> results from <code>boot.wmt &lt;- bootEGA(wmt2[,7:24], seed = 1234)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(boot.wmt)
</code></pre>


<h3>Format</h3>

<p>A list with 12 objects (see <strong>Value</strong> in <code><a href="#topic+bootEGA">bootEGA</a></code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("boot.wmt")
</code></pre>

<hr>
<h2 id='bootEGA'>Bootstrap Exploratory Graph Analysis</h2><span id='topic+bootEGA'></span>

<h3>Description</h3>

<p><code>bootEGA</code> Estimates the number of dimensions of <code>iter</code> bootstraps
using the empirical zero-order correlation matrix (<code>"parametric"</code>) or
<code>"resampling"</code> from the empirical dataset (non-parametric). <code>bootEGA</code>
estimates a typical median network structure, which is formed by the median or
mean pairwise (partial) correlations over the <em>iter</em> bootstraps (see
<strong>Details</strong> for information about the typical median network structure).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootEGA(
  data,
  n = NULL,
  corr = c("auto", "cor_auto", "pearson", "spearman"),
  na.data = c("pairwise", "listwise"),
  model = c("BGGM", "glasso", "TMFG"),
  algorithm = c("leiden", "louvain", "walktrap"),
  uni.method = c("expand", "LE", "louvain"),
  iter = 500,
  type = c("parametric", "resampling"),
  ncores,
  EGA.type = c("EGA", "EGA.fit", "hierEGA", "riEGA"),
  plot.itemStability = TRUE,
  typicalStructure = FALSE,
  plot.typicalStructure = FALSE,
  seed = NULL,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootEGA_+3A_data">data</code></td>
<td>
<p>Matrix or data frame.
Should consist only of variables to be used in the analysis</p>
</td></tr>
<tr><td><code id="bootEGA_+3A_n">n</code></td>
<td>
<p>Numeric (length = 1).
Sample size if <code>data</code> provided is a correlation matrix</p>
</td></tr>
<tr><td><code id="bootEGA_+3A_corr">corr</code></td>
<td>
<p>Character (length = 1).
Method to compute correlations.
Defaults to <code>"auto"</code>.
Available options:
</p>

<ul>
<li> <p><code>"auto"</code> &mdash; Automatically computes appropriate correlations for
the data using Pearson's for continuous, polychoric for ordinal,
tetrachoric for binary, and polyserial/biserial for ordinal/binary with
continuous. To change the number of categories that are considered
ordinal, use <code>ordinal.categories</code>
(see <code><a href="#topic+polychoric.matrix">polychoric.matrix</a></code> for more details)
</p>
</li>
<li> <p><code>"cor_auto"</code> &mdash; Uses <code><a href="qgraph.html#topic+cor_auto">cor_auto</a></code> to compute correlations.
Arguments can be passed along to the function
</p>
</li>
<li> <p><code>"pearson"</code> &mdash; Pearson's correlation is computed for all
variables regardless of categories
</p>
</li>
<li> <p><code>"spearman"</code> &mdash; Spearman's rank-order correlation is computed
for all variables regardless of categories
</p>
</li></ul>

<p>For other similarity measures, compute them first and input them
into <code>data</code> with the sample size (<code>n</code>)</p>
</td></tr>
<tr><td><code id="bootEGA_+3A_na.data">na.data</code></td>
<td>
<p>Character (length = 1).
How should missing data be handled?
Defaults to <code>"pairwise"</code>.
Available options:
</p>

<ul>
<li> <p><code>"pairwise"</code> &mdash; Computes correlation for all available cases between
two variables
</p>
</li>
<li> <p><code>"listwise"</code> &mdash; Computes correlation for all complete cases in the dataset
</p>
</li></ul>
</td></tr>
<tr><td><code id="bootEGA_+3A_model">model</code></td>
<td>
<p>Character (length = 1).
Defaults to <code>"glasso"</code>.
Available options:
</p>

<ul>
<li> <p><code>"BGGM"</code> &mdash; Computes the Bayesian Gaussian Graphical Model.
Set argument <code>ordinal.categories</code> to determine
levels allowed for a variable to be considered ordinal.
See <code>?BGGM::estimate</code> for more details
</p>
</li>
<li> <p><code>"glasso"</code> &mdash; Computes the GLASSO with EBIC model selection.
See <code><a href="#topic+EBICglasso.qgraph">EBICglasso.qgraph</a></code> for more details
</p>
</li>
<li> <p><code>"TMFG"</code> &mdash; Computes the TMFG method.
See <code><a href="#topic+TMFG">TMFG</a></code> for more details
</p>
</li></ul>
</td></tr>
<tr><td><code id="bootEGA_+3A_algorithm">algorithm</code></td>
<td>
<p>Character or
<code><a href="igraph.html#topic+igraph">igraph</a></code> <code>cluster_*</code> function (length = 1).
Defaults to <code>"walktrap"</code>.
Three options are listed below but all are available
(see <code><a href="#topic+community.detection">community.detection</a></code> for other options):
</p>

<ul>
<li> <p><code>"leiden"</code> &mdash; See <code><a href="igraph.html#topic+cluster_leiden">cluster_leiden</a></code> for more details
</p>
</li>
<li> <p><code>"louvain"</code> &mdash; By default, <code>"louvain"</code> will implement the Louvain algorithm using
the consensus clustering method (see <code><a href="#topic+community.consensus">community.consensus</a></code>
for more information). This function will implement
<code>consensus.method = "most_common"</code> and <code>consensus.iter = 1000</code>
unless specified otherwise
</p>
</li>
<li> <p><code>"walktrap"</code> &mdash; See <code><a href="igraph.html#topic+cluster_walktrap">cluster_walktrap</a></code> for more details
</p>
</li></ul>
</td></tr>
<tr><td><code id="bootEGA_+3A_uni.method">uni.method</code></td>
<td>
<p>Character (length = 1).
What unidimensionality method should be used?
Defaults to <code>"louvain"</code>.
Available options:
</p>

<ul>
<li> <p><code>"expand"</code> &mdash; Expands the correlation matrix with four variables correlated 0.50.
If number of dimension returns 2 or less in check, then the data
are unidimensional; otherwise, regular EGA with no matrix
expansion is used. This method was used in the Golino et al.'s (2020)
<em>Psychological Methods</em> simulation
</p>
</li>
<li> <p><code>"LE"</code> &mdash; Applies the Leading Eigenvector algorithm
(<code><a href="igraph.html#topic+cluster_leading_eigen">cluster_leading_eigen</a></code>)
on the empirical correlation matrix. If the number of dimensions is 1,
then the Leading Eigenvector solution is used; otherwise, regular EGA
is used. This method was used in the Christensen et al.'s (2023)
<em>Behavior Research Methods</em> simulation
</p>
</li>
<li> <p><code>"louvain"</code> &mdash; Applies the Louvain algorithm (<code><a href="igraph.html#topic+cluster_louvain">cluster_louvain</a></code>)
on the empirical correlation matrix. If the number of dimensions is 1,
then the Louvain solution is used; otherwise, regular EGA is used.
This method was validated Christensen's (2022) <em>PsyArXiv</em> simulation.
Consensus clustering can be used by specifying either
<code>"consensus.method"</code> or <code>"consensus.iter"</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="bootEGA_+3A_iter">iter</code></td>
<td>
<p>Numeric (length = 1).
Number of replica samples to generate from the bootstrap analysis.
Defaults to <code>500</code> (recommended)</p>
</td></tr>
<tr><td><code id="bootEGA_+3A_type">type</code></td>
<td>
<p>Character (length = 1).
What type of bootstrap should be performed?
Defaults to <code>"parametric"</code>.
Available options:
</p>

<ul>
<li> <p><code>"parametric"</code> &mdash; Generates <code>iter</code> new datasets from
(multivariate normal random distributions) based on the
original dataset using <code><a href="MASS.html#topic+mvrnorm">mvrnorm</a></code>
</p>
</li>
<li> <p><code>"resampling"</code> &mdash; Generates <code>iter</code> new datasets from random subsamples
of the original data
</p>
</li></ul>
</td></tr>
<tr><td><code id="bootEGA_+3A_ncores">ncores</code></td>
<td>
<p>Numeric (length = 1).
Number of cores to use in computing results.
Defaults to <code>ceiling(parallel::detectCores() / 2)</code> or half of your
computer's processing power.
Set to <code>1</code> to not use parallel computing
</p>
<p>If you're unsure how many cores your computer has,
then type: <code>parallel::detectCores()</code></p>
</td></tr>
<tr><td><code id="bootEGA_+3A_ega.type">EGA.type</code></td>
<td>
<p>Character (length = 1).
Type of EGA model to use.
Defaults to <code>"EGA"</code>
Available options:
</p>

<ul>
<li> <p><code>"<a href="#topic+EGA">EGA</a>"</code> &mdash; Uses standard exploratory graph analysis
</p>
</li>
<li> <p><code>"<a href="#topic+EGA.fit">EGA.fit</a>"</code> &mdash; Uses <code><a href="#topic+tefi">tefi</a></code> to determine best fit of
<code><a href="#topic+EGA">EGA</a></code>
</p>
</li>
<li> <p><code>"<a href="#topic+hierEGA">hierEGA</a>"</code> &mdash; Uses hierarchical exploratory graph analysis
</p>
</li>
<li> <p><code>"<a href="#topic+riEGA">riEGA</a>"</code> &mdash; Uses random-intercept exploratory graph analysis
</p>
</li></ul>

<p>Arguments for <code>EGA.type</code> can be added (see links
for details on specific function arguments)</p>
</td></tr>
<tr><td><code id="bootEGA_+3A_plot.itemstability">plot.itemStability</code></td>
<td>
<p>Boolean (length = 1).
Should the plot be produced for <code>item.replication</code>?
Defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="bootEGA_+3A_typicalstructure">typicalStructure</code></td>
<td>
<p>Boolean (length = 1).
If <code>TRUE</code>, returns the median (<code>"glasso"</code> or <code>"BGGM"</code>) or
mean (<code>"TMFG"</code>) network structure and estimates its dimensions
(see <strong>Details</strong> for more information).
Defaults to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="bootEGA_+3A_plot.typicalstructure">plot.typicalStructure</code></td>
<td>
<p>Boolean (length = 1).
If <code>TRUE</code>, returns a plot of the typical network structure.
Defaults to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="bootEGA_+3A_seed">seed</code></td>
<td>
<p>Numeric (length = 1).
Defaults to <code>NULL</code> or random results.
Set for reproducible results.
See <a href="https://r-ega.net/articles/reproducibility-prng.html">Reproducibility and PRNG</a>
for more details on random number generation in <code><a href="#topic+EGAnet">EGAnet</a></code></p>
</td></tr>
<tr><td><code id="bootEGA_+3A_verbose">verbose</code></td>
<td>
<p>Boolean (length = 1).
Should progress be displayed?
Defaults to <code>TRUE</code>.
Set to <code>FALSE</code> to not display progress</p>
</td></tr>
<tr><td><code id="bootEGA_+3A_...">...</code></td>
<td>
<p>Additional arguments that can be passed on to
<code><a href="#topic+auto.correlate">auto.correlate</a></code>,
<code><a href="#topic+network.estimation">network.estimation</a></code>,
<code><a href="#topic+community.detection">community.detection</a></code>,
<code><a href="#topic+community.consensus">community.consensus</a></code>,
<code><a href="#topic+EGA">EGA</a></code>,
<code><a href="#topic+EGA.fit">EGA.fit</a></code>,
<code><a href="#topic+hierEGA">hierEGA</a></code>, and
<code><a href="#topic+riEGA">riEGA</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The typical network structure is derived from the median (or mean) value
of each pairwise relationship. These values tend to reflect the
&quot;typical&quot; value taken by an edge across the bootstrap networks. Afterward,
the same community detection algorithm is applied to the typical network as the
bootstrap networks.
</p>
<p>Because the community detection algorithm is applied to the typical network structure,
there is a possibility that the community algorithm determines
a different number of dimensions than the median number derived from the bootstraps.
The typical network structure (and number of dimensions) may <em>not</em>
match the empirical <code><a href="#topic+EGA">EGA</a></code> number of dimensions or
the median number of dimensions from the bootstrap. This result is known
and <em>not</em> a bug.
</p>


<h3>Value</h3>

<p>Returns a list containing:
</p>
<table>
<tr><td><code>iter</code></td>
<td>
<p>Number of replica samples in bootstrap</p>
</td></tr>
<tr><td><code>bootGraphs</code></td>
<td>
<p>A list containing the networks of each replica sample</p>
</td></tr>
<tr><td><code>boot.wc</code></td>
<td>
<p>A matrix of membership assignments for each replica network
with variables down the columns and replicas across the rows</p>
</td></tr>
<tr><td><code>boot.ndim</code></td>
<td>
<p>Number of dimensions identified in each replica sample</p>
</td></tr>
<tr><td><code>summary.table</code></td>
<td>
<p>A data frame containing number of replica samples,
median, standard deviation, standard error, 95% confidence intervals, and
quantiles (lower = 2.5% and upper = 97.5%)</p>
</td></tr>
<tr><td><code>frequency</code></td>
<td>
<p>A data frame containing the proportion of times the number of dimensions was identified
(e.g., .85 of 1,000 = 850 times that specific number of dimensions was found)</p>
</td></tr>
<tr><td><code>TEFI</code></td>
<td>
<p><code><a href="#topic+tefi">tefi</a></code> value for each replica sample</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Type of bootstrap used</p>
</td></tr>
<tr><td><code>EGA</code></td>
<td>
<p>Output of the empirical EGA results
(output will vary based on <code>EGA.type</code>)</p>
</td></tr>
<tr><td><code>EGA.type</code></td>
<td>
<p>Type of <code>*EGA</code> function used</p>
</td></tr>
<tr><td><code>typicalGraph</code></td>
<td>
<p>A list containing:
</p>

<ul>
<li> <p><code>graph</code> &mdash; Network matrix of the median network structure
</p>
</li>
<li> <p><code>typical.dim.variables</code> &mdash; An ordered matrix of item allocation
</p>
</li>
<li> <p><code>wc</code> &mdash; Membership assignments of the median network
</p>
</li></ul>

</td></tr>
<tr><td><code>plot.typical.ega</code></td>
<td>
<p>Plot output if <code>plot.typicalStructure = TRUE</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hudson Golino &lt;hfg9s at virginia.edu&gt; and Alexander P. Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>References</h3>

<p><strong>Original implementation of bootEGA</strong> <br />
Christensen, A. P., &amp; Golino, H. (2021).
Estimating the stability of the number of factors via Bootstrap Exploratory Graph Analysis: A tutorial.
<em>Psych</em>, <em>3</em>(3), 479-500.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+itemStability">itemStability</a></code> to estimate the stability of
the variables in the empirical dimensions and
<code><a href="#topic+dimensionStability">dimensionStability</a></code> to estimate the stability of
the dimensions (structural consistency)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
wmt &lt;- wmt2[,7:24]

## Not run: 
# Standard EGA parametric example
boot.wmt &lt;- bootEGA(
  data = wmt, iter = 500,
  type = "parametric", ncores = 2
)

# Standard resampling example
boot.wmt &lt;- bootEGA(
  data = wmt, iter = 500,
  type = "resampling", ncores = 2
)

# Example using {igraph} `cluster_*` function
boot.wmt.spinglass &lt;- bootEGA(
  data = wmt, iter = 500,
  algorithm = igraph::cluster_spinglass,
  # use any function from {igraph}
  type = "parametric", ncores = 2
)

# EGA fit example
boot.wmt.fit &lt;- bootEGA(
  data = wmt, iter = 500,
  EGA.type = "EGA.fit",
  type = "parametric", ncores = 2
)

# Hierarchical EGA example
boot.wmt.hier &lt;- bootEGA(
  data = wmt, iter = 500,
  EGA.type = "hierEGA",
  type = "parametric", ncores = 2
)

# Random-intercept EGA example
boot.wmt.ri &lt;- bootEGA(
  data = wmt, iter = 500,
  EGA.type = "riEGA",
  type = "parametric", ncores = 2
)
## End(Not run)

</code></pre>

<hr>
<h2 id='CFA'>CFA Fit of <code><a href="#topic+EGA">EGA</a></code> or <code><a href="#topic+hierEGA">hierEGA</a></code> Structure</h2><span id='topic+CFA'></span>

<h3>Description</h3>

<p>Verifies the fit of the structure suggested by 
<code><a href="#topic+EGA">EGA</a></code> or by <code><a href="#topic+hierEGA">hierEGA</a></code> using 
confirmatory factor analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CFA(ega.obj, data, estimator, plot.CFA = TRUE, layout = "spring", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CFA_+3A_ega.obj">ega.obj</code></td>
<td>
<p>An <code><a href="#topic+EGA">EGA</a></code> object or 
an <code><a href="#topic+hierEGA">hierEGA</a></code></p>
</td></tr>
<tr><td><code id="CFA_+3A_data">data</code></td>
<td>
<p>Matrix or data frame.
Should consist only of variables to be used in the analysis</p>
</td></tr>
<tr><td><code id="CFA_+3A_estimator">estimator</code></td>
<td>
<p>The estimator used in the confirmatory factor analysis.
'WLSMV' is the estimator of choice for ordinal variables.
'ML' or 'WLS' for interval variables.
See <code><a href="lavaan.html#topic+lavOptions">lavOptions</a></code> for more details</p>
</td></tr>
<tr><td><code id="CFA_+3A_plot.cfa">plot.CFA</code></td>
<td>
<p>Logical.
Should the CFA structure with its standardized loadings be plot?
Defaults to TRUE</p>
</td></tr>
<tr><td><code id="CFA_+3A_layout">layout</code></td>
<td>
<p>Layout of plot (see <code><a href="semPlot.html#topic+semPaths">semPaths</a></code>).
Defaults to &quot;spring&quot;</p>
</td></tr>
<tr><td><code id="CFA_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="lavaan.html#topic+cfa">cfa</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing:
</p>
<table>
<tr><td><code>fit</code></td>
<td>
<p>Output from <code><a href="lavaan.html#topic+cfa">cfa</a></code></p>
</td></tr>
<tr><td><code>summary</code></td>
<td>
<p>Summary output from <code><a href="lavaan.html#topic+lavaan-class">lavaan-class</a></code></p>
</td></tr>
<tr><td><code>fit.measures</code></td>
<td>
<p>Fit measures: chi-squared,
degrees of freedom, p-value, CFI, RMSEA, GFI, and NFI.
Additional fit measures can be applied using the
<code><a href="lavaan.html#topic+fitMeasures">fitMeasures</a></code> function (see examples)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hudson F. Golino &lt;hfg9s at virginia.edu&gt;
</p>


<h3>References</h3>

<p><strong>Demonstrative use</strong> <br />
Christensen, A. P., Gross, G. M., Golino, H., Silvia, P. J., &amp; Kwapil, T. R. (2019).
Exploratory graph analysis of the Multidimensional Schizotypy Scale.
<em>Schizophrenia Research</em>, <em>206</em>, 43-51.
</p>
<p><strong>Initial implementation</strong> <br />
Golino, H., &amp; Epskamp, S. (2017).
Exploratory graph analysis: A new approach for estimating the number of dimensions in psychological research.
<em>PLoS ONE</em>, <em>12</em>, e0174035.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
wmt &lt;- wmt2[,7:24]

## Not run: 
# Estimate EGA
ega.wmt &lt;- EGA(
  data = wmt,
  plot.EGA = FALSE # No plot for CRAN checks
)

# Fit CFA model to EGA results
cfa.wmt &lt;- CFA(
  ega.obj = ega.wmt, estimator = "WLSMV",
  plot.CFA = FALSE, # No plot for CRAN checks
  data = wmt
)

# Additional fit measures
lavaan::fitMeasures(cfa.wmt$fit, fit.measures = "all")
## End(Not run)

</code></pre>

<hr>
<h2 id='color_palette_EGA'><code><a href="#topic+EGA">EGA</a></code> Color Palettes</h2><span id='topic+color_palette_EGA'></span>

<h3>Description</h3>

<p>Color palettes for plotting <code><a href="GGally.html#topic+ggnet2">ggnet2</a></code> 
<code><a href="#topic+EGA">EGA</a></code> network plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>color_palette_EGA(
  name = c("polychrome", "blue.ridge1", "blue.ridge2", "rainbow", "rio", "itacare",
    "grayscale"),
  wc,
  sorted = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="color_palette_EGA_+3A_name">name</code></td>
<td>
<p>Character.
Name of color scheme (see <code><a href="RColorBrewer.html#topic+RColorBrewer">RColorBrewer</a></code>).
Defaults to <code>"polychrome"</code>.
<code><a href="#topic+EGA">EGA</a></code> palettes:
</p>

<ul>
<li> <p><code>"polychrome"</code> &mdash; Default 40 color palette
</p>
</li>
<li> <p><code>"grayscale"</code> &mdash; &quot;grayscale&quot;, &quot;greyscale&quot;, or &quot;colorblind&quot; will produce
plots suitable for publication purposes
</p>
</li>
<li> <p><code>"blue.ridge1"</code> &mdash; Palette inspired by the Blue Ridge Mountains
</p>
</li>
<li> <p><code>"blue.ridge2"</code> &mdash; Second palette inspired by the Blue Ridge Mountains
</p>
</li>
<li> <p><code>"rainbow"</code> &mdash; Rainbow colors. Default for <code><a href="qgraph.html#topic+qgraph">qgraph</a></code>
</p>
</li>
<li> <p><code>"rio"</code> &mdash; Palette inspired by Rio de Janiero, Brazil
</p>
</li>
<li> <p><code>"itacare"</code> &mdash; Palette inspired by Itacare, Brazil
</p>
</li></ul>

<p>For custom colors, enter HEX codes for each dimension in a vector</p>
</td></tr>
<tr><td><code id="color_palette_EGA_+3A_wc">wc</code></td>
<td>
<p>Numeric vector.
A vector representing the community (dimension) membership
of each node in the network. <code>NA</code> values mean that the node
was disconnected from the network</p>
</td></tr>
<tr><td><code id="color_palette_EGA_+3A_sorted">sorted</code></td>
<td>
<p>Boolean.
Should colors be sorted by <code>wc</code>?
Defaults to <code>FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of colors for community memberships
</p>


<h3>Author(s)</h3>

<p>Hudson Golino &lt;hfg9s at virginia.edu&gt;, Alexander P. Christensen &lt;alexpaulchristensen at gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.EGAnet">plot.EGAnet</a></code> for plot usage in <code><a href="#topic+EGAnet">EGAnet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Default
color_palette_EGA(name = "polychrome", wc = ega.wmt$wc)

# Blue Ridge Moutains 1
color_palette_EGA(name = "blue.ridge1", wc = ega.wmt$wc)

# Custom
color_palette_EGA(name = c("#7FD1B9", "#24547e"), wc = ega.wmt$wc)

</code></pre>

<hr>
<h2 id='community.compare'>Compares Community Detection Solutions Using Permutation</h2><span id='topic+community.compare'></span>

<h3>Description</h3>

<p>A permutation implementation to determine statistical
significance of whether the community comparison measure is different
from zero
</p>


<h3>Usage</h3>

<pre><code class='language-R'>community.compare(
  base,
  comparison,
  method = c("vi", "nmi", "split.join", "rand", "adjusted.rand"),
  iter = 1000,
  shuffle.base = TRUE,
  verbose = TRUE,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="community.compare_+3A_base">base</code></td>
<td>
<p>Character or numeric vector.
A vector of characters or numbers that are treated as the
baseline communities</p>
</td></tr>
<tr><td><code id="community.compare_+3A_comparison">comparison</code></td>
<td>
<p>Character or numeric vector (length = <code>length(base)</code>).
A vector of characters or numbers that are treated as the
baseline communities</p>
</td></tr>
<tr><td><code id="community.compare_+3A_method">method</code></td>
<td>
<p>Character (length = 1).
Comparison metrics from <code><a href="igraph.html#topic+compare">compare</a></code>.
Defaults to <code>"adjusted.rand"</code>.
Available options:
</p>

<ul>
<li> <p><code>"vi"</code> &mdash; Variation of information (Meila, 2003)
</p>
</li>
<li> <p><code>"nmi"</code> &mdash; Normalized mutual information (Danon et al., 2003)
</p>
</li>
<li> <p><code>"split.join"</code> &mdash; Split-join distance (Dongen, 2000)
</p>
</li>
<li> <p><code>"rand"</code> &mdash; Rand index (Rand, 1971)
</p>
</li>
<li> <p><code>"adjusted.rand"</code> &mdash; adjusted Rand index (Hubert &amp; Arabie, 1985; Steinley, 2004)
</p>
</li></ul>
</td></tr>
<tr><td><code id="community.compare_+3A_iter">iter</code></td>
<td>
<p>Numeric (length = 1).
Number of permutations to perform.
Defaults to <code>1000</code> (recommended)</p>
</td></tr>
<tr><td><code id="community.compare_+3A_shuffle.base">shuffle.base</code></td>
<td>
<p>Boolean (length = 1).
Whether the <code>base</code> cluster solution should be shuffled.
Defaults to <code>TRUE</code> to remain consistent with original
implementation (Qannari et al., 2014); however, from a theoretical
standpoint, it might make sense to only shuffle the <code>comparison</code>
to determine whether it is specifically different
from the recognized <code>base</code></p>
</td></tr>
<tr><td><code id="community.compare_+3A_verbose">verbose</code></td>
<td>
<p>Boolean (length = 1).
Should progress be displayed?
Defaults to <code>TRUE</code>.
Set to <code>FALSE</code> to not display progress</p>
</td></tr>
<tr><td><code id="community.compare_+3A_seed">seed</code></td>
<td>
<p>Numeric (length = 1).
Defaults to <code>NULL</code> or random results.
Set for reproducible results.
See <a href="https://r-ega.net/articles/reproducibility-prng.html">Reproducibility and PRNG</a>
for more details on random number generation in <code><a href="#topic+EGAnet">EGAnet</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns data frame containing method used (<code>Method</code>), empirical or observed
value (<code>Empirical</code>), and p-value based on the permutation test (<code>p.value</code>)
</p>


<h3>Author(s)</h3>

<p>Hudson Golino &lt;hfg9s at virginia.edu&gt; and Alexander P. Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>References</h3>

<p><strong>Implementation of Permutation Test</strong> <br />
Qannari, E. M., Courcoux, P., &amp; Faye, P. (2014).
Significance test of the adjusted Rand index. Application to the free sorting task.
<em>Food Quality and Preference</em>, <em>32</em>, 93â€“97.
</p>
<p><strong>Variation of Information</strong> <br />
Meila, M. (2003, August).
Comparing clusterings by the variation of information.
In <em>Learning Theory and Kernel Machines: 16th Annual Conference on Learning Theory and 7th Kernel Workshop</em>,
COLT/Kernel 2003, Washington, DC, USA, August 24-27, 2003. Proceedings (pp. 173-187). Berlin, DE: Springer Berlin Heidelberg.
</p>
<p><strong>Normalized Mutual Information</strong> <br />
Danon, L., Diaz-Guilera, A., Duch, J., &amp; Arenas, A. (2005).
Comparing community structure identification.
<em>Journal of Statistical Mechanics: Theory and Experiment</em>, <em>2005</em>(09), P09008.
</p>
<p><strong>Split-join Distance</strong> <br />
Dongen, S. (2000).
Performance criteria for graph clustering and Markov cluster experiments.
<em>CWI (Centre for Mathematics and Computer Science)</em>.
</p>
<p><strong>Rand Index</strong> <br />
Rand, W. M. (1971).
Objective criteria for the evaluation of clustering methods.
<em>Journal of the American Statistical Association</em>, <em>66</em>(336), 846-850.
</p>
<p><strong>Adjusted Rand Index</strong> <br />
Hubert, L., &amp; Arabie, P. (1985).
Comparing partitions.
<em>Journal of Classification</em>, <em>2</em>, 193-218.
</p>
<p>Steinley, D. (2004).
Properties of the Hubert-Arabie adjusted rand index.
<em>Psychological Methods</em>, <em>9</em>(3), 386.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
wmt &lt;- wmt2[,7:24]

# Estimate network
network &lt;- EBICglasso.qgraph(data = wmt)

# Compute Edge Betweenness
edge_between &lt;- community.detection(network, algorithm = "edge_betweenness")

# Compute Fast Greedy
fast_greedy &lt;- community.detection(network, algorithm = "fast_greedy")

# Perform permutation test
community.compare(edge_between, fast_greedy)

</code></pre>

<hr>
<h2 id='community.consensus'>Applies the Consensus Clustering Method (Louvain only)</h2><span id='topic+community.consensus'></span>

<h3>Description</h3>

<p>Applies the consensus clustering method introduced by (Lancichinetti &amp; Fortunato, 2012).
The original implementation of this method applies a community detection algorithm repeatedly
to the same network. With stochastic networks, the algorithm is likely to identify different
community solutions with many repeated applications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>community.consensus(
  network,
  order = c("lower", "higher"),
  resolution = 1,
  consensus.method = c("highest_modularity", "iterative", "most_common", "lowest_tefi"),
  consensus.iter = 1000,
  correlation.matrix = NULL,
  allow.singleton = FALSE,
  membership.only = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="community.consensus_+3A_network">network</code></td>
<td>
<p>Matrix or <code><a href="igraph.html#topic+igraph">igraph</a></code> network object</p>
</td></tr>
<tr><td><code id="community.consensus_+3A_order">order</code></td>
<td>
<p>Character (length = 1).
Defaults to <code>"higher"</code>.
Whether <code>"lower"</code> or <code>"higher"</code> order memberships from
the Louvain algorithm should be obtained for the consensus.
The <code>"lower"</code> order Louvain memberships are from the first
initial pass of the Louvain algorithm whereas the <code>"higher"</code>
order Louvain memberships are from the last pass of the Louvain
algorithm</p>
</td></tr>
<tr><td><code id="community.consensus_+3A_resolution">resolution</code></td>
<td>
<p>Numeric (length = 1).
A parameter that adjusts modularity to allow the algorithm to
prefer smaller (<code>resolution</code> &gt; 1) or larger
(0 &lt; <code>resolution</code> &lt; 1) communities.
Defaults to <code>1</code> (standard modularity computation)</p>
</td></tr>
<tr><td><code id="community.consensus_+3A_consensus.method">consensus.method</code></td>
<td>
<p>Character (length = 1).
Defaults to <code>"most_common"</code>.
Available options for arriving at a consensus (<em>Note</em>: 
All methods except <code>"iterative"</code> are considered experimental
until validated):
</p>

<ul>
<li> <p><code>"highest_modularity"</code> &mdash; <strong>EXPERIMENTAL.</strong> Selects the community solution with the highest modularity across
the applications. Modularity is a reasonable metric for identifying the number
of communities in a network but it comes with limitations (e.g., resolution limit)
</p>
</li>
<li> <p><code>"iterative"</code> &mdash; The original approach proposed by Lancichinetti &amp; Fortunato (2012). See
&quot;Details&quot; for more information
</p>
</li>
<li> <p><code>"most_common"</code> &mdash; Selects the community solution that appears the most
frequently across the applications. The idea behind this method is that the solution
that appears most often will be the most likely solution for the algorithm as well
as most reproducible. Can be less stable as the number of nodes increase requiring
a larger value for <code>consensus.iter</code>.  This method is the <strong>default</strong>
</p>
</li>
<li> <p><code>"lowest_tefi"</code> &mdash; <strong>EXPERIMENTAL.</strong> Selects the community solution with the lowest Total Entropy
Fit Index (<code><a href="#topic+tefi">tefi</a></code>) across the applications. TEFI is a reasonable metric
to identify the number of communities in a network based on Golino, Moulder et al. (2020)
</p>
</li></ul>
</td></tr>
<tr><td><code id="community.consensus_+3A_consensus.iter">consensus.iter</code></td>
<td>
<p>Numeric (length = 1).
Number of algorithm applications to the network.
Defaults to <code>1000</code></p>
</td></tr>
<tr><td><code id="community.consensus_+3A_correlation.matrix">correlation.matrix</code></td>
<td>
<p>Symmetric matrix.
Used for computation of <code><a href="#topic+tefi">tefi</a></code>.
Only needed when <code>consensus.method = "tefi"</code></p>
</td></tr>
<tr><td><code id="community.consensus_+3A_allow.singleton">allow.singleton</code></td>
<td>
<p>Boolean (length = 1).
Whether singleton or single node communities should be allowed.
Defaults to <code>FALSE</code>.
When <code>FALSE</code>, singleton communities will be set to
missing (<code>NA</code>); otherwise, when <code>TRUE</code>, singleton
communities will be allowed</p>
</td></tr>
<tr><td><code id="community.consensus_+3A_membership.only">membership.only</code></td>
<td>
<p>Boolean.
Whether the memberships only should be output.
Defaults to <code>TRUE</code>.
Set to <code>FALSE</code> to obtain all output for the
community detection algorithm</p>
</td></tr>
<tr><td><code id="community.consensus_+3A_...">...</code></td>
<td>
<p>Not actually used but makes it easier for general functionality
in the package</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The goal of the consensus clustering method is to identify a stable solution across
algorithm applications to derive a &quot;consensus&quot; clustering. The standard or &quot;iterative&quot;
approach is to apply the community detection algorithm <em>N</em> times. Then, a co-occurrence
matrix is created representing how often each pair of nodes co-occurred across the
applications. Based on some cut-off value (e.g., 0.30), co-occurrences below this value
are set to zero, forming a &quot;new&quot; sparse network. The procedure proceeds until all nodes
co-occur with all other nodes in their community (or a proportion of 1.00).
</p>
<p>Variations of this procedure are also available in this package but are
<strong>experimental</strong>. Use these experimental procedures with caution.
More work is necessary before these experimental procedures are validated
</p>
<p><em>At this time, seed setting for consensus clustering is not supported</em>
</p>


<h3>Value</h3>

<p>Returns either a vector with the selected solution
or a list when <code>membership.only = FALSE</code>:
</p>
<table>
<tr><td><code>selected_solution</code></td>
<td>
<p>Resulting solution from the consensus method</p>
</td></tr>
<tr><td><code>memberships</code></td>
<td>
<p>Matrix of memberships across the consensus iterations</p>
</td></tr>
<tr><td><code>proportion_table</code></td>
<td>
<p>For methods that use frequency, a table that
reports those frequencies alongside their corresponding memberships</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hudson Golino &lt;hfg9s at virginia.edu&gt; and Alexander P. Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>References</h3>

<p><strong>Louvain algorithm</strong> <br />
Blondel, V. D., Guillaume, J.-L., Lambiotte, R., &amp; Lefebvre, E. (2008).
Fast unfolding of communities in large networks.
<em>Journal of Statistical Mechanics: Theory and Experiment</em>, <em>2008</em>(10), P10008.
</p>
<p><strong>Consensus clustering</strong> <br />
Lancichinetti, A., &amp; Fortunato, S. (2012).
Consensus clustering in complex networks.
<em>Scientific Reports</em>, <em>2</em>(1), 1â€“7.
</p>
<p><strong>Entropy fit indices</strong> <br />
Golino, H., Moulder, R. G., Shi, D., Christensen, A. P., Garrido, L. E., Nieto, M. D., Nesselroade, J., Sadana, R., Thiyagarajan, J. A., &amp; Boker, S. M. (2020).
Entropy fit indices: New fit measures for assessing the structure and dimensionality of multiple latent variables.
<em>Multivariate Behavioral Research</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
wmt &lt;- wmt2[,7:24]

# Estimate correlation matrix
correlation.matrix &lt;- auto.correlate(wmt)

# Estimate network
network &lt;- EBICglasso.qgraph(data = wmt)

# Compute standard Louvain with highest modularity approach
community.consensus(
  network,
  consensus.method = "highest_modularity"
)

# Compute standard Louvain with iterative (original) approach
community.consensus(
  network,
  consensus.method = "iterative"
)

# Compute standard Louvain with most common approach
community.consensus(
  network,
  consensus.method = "most_common"
)

# Compute standard Louvain with lowest TEFI approach
community.consensus(
  network,
  consensus.method = "lowest_tefi",
  correlation.matrix = correlation.matrix
)

</code></pre>

<hr>
<h2 id='community.detection'>Apply a Community Detection Algorithm</h2><span id='topic+community.detection'></span>

<h3>Description</h3>

<p>General function to apply community detection algorithms available in
<code><a href="igraph.html#topic+igraph">igraph</a></code>. Follows the <code><a href="#topic+EGAnet">EGAnet</a></code> approach of setting
singleton and disconnected nodes to missing (<code>NA</code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>community.detection(
  network,
  algorithm = c("edge_betweenness", "fast_greedy", "fluid", "infomap", "label_prop",
    "leading_eigen", "leiden", "louvain", "optimal", "spinglass", "walktrap"),
  allow.singleton = FALSE,
  membership.only = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="community.detection_+3A_network">network</code></td>
<td>
<p>Matrix or <code><a href="igraph.html#topic+igraph">igraph</a></code> network object</p>
</td></tr>
<tr><td><code id="community.detection_+3A_algorithm">algorithm</code></td>
<td>
<p>Character or <code><a href="igraph.html#topic+igraph">igraph</a></code> <code>cluster_*</code> function
(length = 1).
Available options:
</p>

<ul>
<li> <p><code>"edge_betweenness"</code> &mdash; See <code><a href="igraph.html#topic+cluster_edge_betweenness">cluster_edge_betweenness</a></code> for more details
</p>
</li>
<li> <p><code>"fast_greedy"</code> &mdash; See <code><a href="igraph.html#topic+cluster_fast_greedy">cluster_fast_greedy</a></code> for more details
</p>
</li>
<li> <p><code>"fluid"</code> &mdash; See <code><a href="igraph.html#topic+cluster_fluid_communities">cluster_fluid_communities</a></code> for more details
</p>
</li>
<li> <p><code>"infomap"</code> &mdash; See <code><a href="igraph.html#topic+cluster_infomap">cluster_infomap</a></code> for more details
</p>
</li>
<li> <p><code>"label_prop"</code> &mdash; See <code><a href="igraph.html#topic+cluster_label_prop">cluster_label_prop</a></code> for more details
</p>
</li>
<li> <p><code>"leading_eigen"</code> &mdash; See <code><a href="igraph.html#topic+cluster_leading_eigen">cluster_leading_eigen</a></code> for more details
</p>
</li>
<li> <p><code>"leiden"</code> &mdash; See <code><a href="igraph.html#topic+cluster_leiden">cluster_leiden</a></code> for more details.
<em>Note</em>: The Leiden algorithm will default to the
modularity objective function (<code>objective_function = "modularity"</code>). 
Set <code>objective_function = "CPM"</code> to use the 
Constant Potts Model instead (see examples)
</p>
</li>
<li> <p><code>"louvain"</code> &mdash; See <code><a href="igraph.html#topic+cluster_louvain">cluster_louvain</a></code> for more details
</p>
</li>
<li> <p><code>"optimal"</code> &mdash; See <code><a href="igraph.html#topic+cluster_optimal">cluster_optimal</a></code> for more details
</p>
</li>
<li> <p><code>"spinglass"</code> &mdash; See <code><a href="igraph.html#topic+cluster_spinglass">cluster_spinglass</a></code> for more details
</p>
</li>
<li> <p><code>"walktrap"</code> &mdash; See <code><a href="igraph.html#topic+cluster_walktrap">cluster_walktrap</a></code> for more details
</p>
</li></ul>
</td></tr>
<tr><td><code id="community.detection_+3A_allow.singleton">allow.singleton</code></td>
<td>
<p>Boolean (length = 1).
Whether singleton or single node communities should be allowed.
Defaults to <code>FALSE</code>.
When <code>FALSE</code>, singleton communities will be set to
missing (<code>NA</code>); otherwise, when <code>TRUE</code>, singleton
communities will be allowed</p>
</td></tr>
<tr><td><code id="community.detection_+3A_membership.only">membership.only</code></td>
<td>
<p>Boolean (length = 1).
Whether the memberships only should be output.
Defaults to <code>TRUE</code>.
Set to <code>FALSE</code> to obtain all output for the
community detection algorithm</p>
</td></tr>
<tr><td><code id="community.detection_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed on to
<code><a href="igraph.html#topic+igraph">igraph</a></code>'s community detection functions
(see <code>algorithm</code> for link to arguments of each algorithm)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns memberships from a community detection algorithm
</p>


<h3>Author(s)</h3>

<p>Hudson Golino &lt;hfg9s at virginia.edu&gt; and Alexander P. Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>References</h3>

<p>Csardi, G., &amp; Nepusz, T. (2006). 
The igraph software package for complex network research.
<em>InterJournal, Complex Systems</em>, 1695.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
wmt &lt;- wmt2[,7:24]

# Estimate network
network &lt;- EBICglasso.qgraph(data = wmt)

# Compute Edge Betweenness
community.detection(network, algorithm = "edge_betweenness")

# Compute Fast Greedy
community.detection(network, algorithm = "fast_greedy")

# Compute Fluid
community.detection(
  network, algorithm = "fluid",
  no.of.communities = 2 # needs to be set
)

# Compute Infomap
community.detection(network, algorithm = "infomap")

# Compute Label Propagation
community.detection(network, algorithm = "label_prop")

# Compute Leading Eigenvector
community.detection(network, algorithm = "leading_eigen")

# Compute Leiden (with modularity)
community.detection(
  network, algorithm = "leiden",
  objective_function = "modularity"
)

# Compute Leiden (with CPM)
community.detection(
  network, algorithm = "leiden",
  objective_function = "CPM",
  resolution_parameter = 0.05 # "edge density"
)

# Compute Louvain
community.detection(network, algorithm = "louvain")

# Compute Optimal (identifies maximum modularity solution)
community.detection(network, algorithm = "optimal")

# Compute Spinglass
community.detection(network, algorithm = "spinglass")

# Compute Walktrap
community.detection(network, algorithm = "walktrap")

# Example with {igraph} network
community.detection(
  convert2igraph(network), algorithm = "walktrap"
)

</code></pre>

<hr>
<h2 id='community.homogenize'>Homogenize Community Memberships</h2><span id='topic+community.homogenize'></span>

<h3>Description</h3>

<p>Memberships from community detection algorithms do not always
align numerically. This function seeks to homogenize 
community memberships between a target membership (the 
membership to homogenize toward) and one or more other 
memberships. This function is the core of the 
<code><a href="#topic+dimensionStability">dimensionStability</a></code> and 
<code><a href="#topic+itemStability">itemStability</a></code> functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>community.homogenize(target.membership, convert.membership)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="community.homogenize_+3A_target.membership">target.membership</code></td>
<td>
<p>Vector, matrix, or data frame.
The target memberships that all other memberships input into
<code>convert.membership</code> should be homogenize <strong>toward</strong></p>
</td></tr>
<tr><td><code id="community.homogenize_+3A_convert.membership">convert.membership</code></td>
<td>
<p>Vector, matrix, or data frame.
Either a vector of memberships the same length as
<code>target.membership</code> or a matrix or data frame of many
membership solutions with either across rows or down columns the same
length as <code>target.membership</code> (this function will automatically
determine this orientation for you with precedence given solutions
<em>across rows</em>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector or matrix the length or size of
<code>convert.membership</code> with memberships homogenized toward
<code>target.membership</code>
</p>


<h3>Author(s)</h3>

<p>Hudson Golino &lt;hfg9s at virginia.edu&gt; and Alexander P. Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>References</h3>

<p><strong>Original implementation of bootEGA</strong> <br />
Christensen, A. P., &amp; Golino, H. (2021).
Estimating the stability of the number of factors via Bootstrap Exploratory Graph Analysis: A tutorial.
<em>Psych</em>, <em>3</em>(3), 479-500.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get network
network &lt;- network.estimation(wmt2[,7:24])

# Apply Walktrap
network_walktrap &lt;- community.detection(
  network, algorithm = "walktrap"
)

# Apply Louvain
network_louvain &lt;- community.detection(
  network, algorithm = "louvain"
)

# Homogenize toward Walktrap
community.homogenize(network_walktrap, network_louvain)

</code></pre>

<hr>
<h2 id='community.unidimensional'>Approaches to Detect Unidimensional Communities</h2><span id='topic+community.unidimensional'></span>

<h3>Description</h3>

<p>A function to apply several approaches to detect a unidimensional community in 
networks. There have many different approaches recently such as expanding
the correlation matrix to have orthogonal correlations (<code>"expand"</code>),
applying the Leading Eigenvalue community detection algorithm
<code><a href="igraph.html#topic+cluster_leading_eigen">cluster_leading_eigen</a></code> to the correlation matrix
(<code>"LE"</code>), and applying the Louvain community detection algorithm
<code><a href="igraph.html#topic+cluster_louvain">cluster_louvain</a></code> to the correlation matrix (<code>"louvain"</code>).
Not necessarily intended for individual use &ndash; it's better to use <code><a href="#topic+EGA">EGA</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>community.unidimensional(
  data,
  n = NULL,
  corr = c("auto", "cor_auto", "pearson", "spearman"),
  na.data = c("pairwise", "listwise"),
  model = c("BGGM", "glasso", "TMFG"),
  uni.method = c("expand", "LE", "louvain"),
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="community.unidimensional_+3A_data">data</code></td>
<td>
<p>Matrix or data frame.
Should consist only of variables that are desired to be in analysis</p>
</td></tr>
<tr><td><code id="community.unidimensional_+3A_n">n</code></td>
<td>
<p>Numeric (length = 1).
Sample size if <code>data</code> provided is a correlation matrix</p>
</td></tr>
<tr><td><code id="community.unidimensional_+3A_corr">corr</code></td>
<td>
<p>Character (length = 1).
Method to compute correlations.
Defaults to <code>"auto"</code>.
Available options:
</p>

<ul>
<li> <p><code>"auto"</code> &mdash; Automatically computes appropriate correlations for
the data using Pearson's for continuous, polychoric for ordinal,
tetrachoric for binary, and polyserial/biserial for ordinal/binary with
continuous. To change the number of categories that are considered
ordinal, use <code>ordinal.categories</code>
(see <code><a href="#topic+polychoric.matrix">polychoric.matrix</a></code> for more details)
</p>
</li>
<li> <p><code>"cor_auto"</code> &mdash; Uses <code><a href="qgraph.html#topic+cor_auto">cor_auto</a></code> to compute correlations. 
Arguments can be passed along to the function
</p>
</li>
<li> <p><code>"pearson"</code> &mdash; Pearson's correlation is computed for all 
variables regardless of categories
</p>
</li>
<li> <p><code>"spearman"</code> &mdash; Spearman's rank-order correlation is computed 
for all variables regardless of categories
</p>
</li></ul>

<p>For other similarity measures, compute them first and input them
into <code>data</code> with the sample size (<code>n</code>)</p>
</td></tr>
<tr><td><code id="community.unidimensional_+3A_na.data">na.data</code></td>
<td>
<p>Character (length = 1).
How should missing data be handled?
Defaults to <code>"pairwise"</code>.
Available options:
</p>

<ul>
<li> <p><code>"pairwise"</code> &mdash; Computes correlation for all available cases between
two variables
</p>
</li>
<li> <p><code>"listwise"</code> &mdash; Computes correlation for all complete cases in the dataset
</p>
</li></ul>
</td></tr>
<tr><td><code id="community.unidimensional_+3A_model">model</code></td>
<td>
<p>Character (length = 1).
Defaults to <code>"glasso"</code>.
Available options:
</p>

<ul>
<li> <p><code>"BGGM"</code> &mdash; Computes the Bayesian Gaussian Graphical Model.
Set argument <code>ordinal.categories</code> to determine
levels allowed for a variable to be considered ordinal.
See <code>?BGGM::estimate</code> for more details
</p>
</li>
<li> <p><code>"glasso"</code> &mdash; Computes the GLASSO with EBIC model selection.
See <code><a href="#topic+EBICglasso.qgraph">EBICglasso.qgraph</a></code> for more details
</p>
</li>
<li> <p><code>"TMFG"</code> &mdash; Computes the TMFG method.
See <code><a href="#topic+TMFG">TMFG</a></code> for more details
</p>
</li></ul>
</td></tr>
<tr><td><code id="community.unidimensional_+3A_uni.method">uni.method</code></td>
<td>
<p>Character (length = 1).
What unidimensionality method should be used? 
Defaults to <code>"louvain"</code>.
Available options:
</p>

<ul>
<li> <p><code>"expand"</code> &mdash; Expands the correlation matrix with four variables correlated 0.50.
If number of dimension returns 2 or less in check, then the data 
are unidimensional; otherwise, regular EGA with no matrix
expansion is used. This method was used in the Golino et al.'s (2020)
<em>Psychological Methods</em> simulation
</p>
</li>
<li> <p><code>"LE"</code> &mdash; Applies the Leading Eigenvector algorithm
(<code><a href="igraph.html#topic+cluster_leading_eigen">cluster_leading_eigen</a></code>)
on the empirical correlation matrix. If the number of dimensions is 1,
then the Leading Eigenvector solution is used; otherwise, regular EGA
is used. This method was used in the Christensen et al.'s (2023) 
<em>Behavior Research Methods</em> simulation
</p>
</li>
<li> <p><code>"louvain"</code> &mdash; Applies the Louvain algorithm (<code><a href="igraph.html#topic+cluster_louvain">cluster_louvain</a></code>)
on the empirical correlation matrix. If the number of dimensions is 1, 
then the Louvain solution is used; otherwise, regular EGA is used. 
This method was validated Christensen's (2022) <em>PsyArXiv</em> simulation.
Consensus clustering can be used by specifying either
<code>"consensus.method"</code> or <code>"consensus.iter"</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="community.unidimensional_+3A_verbose">verbose</code></td>
<td>
<p>Boolean.
Whether messages and (insignificant) warnings should be output.
Defaults to <code>FALSE</code> (silent calls).
Set to <code>TRUE</code> to see all messages and warnings for every function call</p>
</td></tr>
<tr><td><code id="community.unidimensional_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed on to
<code><a href="#topic+auto.correlate">auto.correlate</a></code>, 
<code><a href="#topic+network.estimation">network.estimation</a></code>,
<code><a href="#topic+community.consensus">community.consensus</a></code>, and 
<code><a href="#topic+community.detection">community.detection</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the memberships of the community detection algorithm.
The memberships will output <em>regardless</em> of whether the
network is unidimensional
</p>


<h3>Author(s)</h3>

<p>Hudson Golino &lt;hfg9s at virginia.edu&gt; and Alexander P. Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>References</h3>

<p><strong>Expand approach</strong> <br />
Golino, H., Shi, D., Christensen, A. P., Garrido, L. E., Nieto, M. D., Sadana, R., Thiyagarajan, J. A., &amp; Martinez-Molina, A. (2020).
Investigating the performance of exploratory graph analysis and traditional techniques to identify the number of latent factors:
A simulation and tutorial.
<em>Psychological Methods</em>, <em>25</em>, 292-320. 
</p>
<p><strong>Leading Eigenvector approach</strong> <br />
Christensen, A. P., Garrido, L. E., Guerra-Pena, K., &amp; Golino, H. (2023).
Comparing community detection algorithms in psychometric networks: A Monte Carlo simulation.
<em>Behavior Research Methods</em>.
</p>
<p><strong>Louvain approach</strong> <br />
Christensen, A. P. (2023).
Unidimensional community detection: A Monte Carlo simulation, grid search, and comparison.
<em>PsyArXiv</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
wmt &lt;- wmt2[,7:24]

# Louvain with Consensus Clustering (default)
community.unidimensional(wmt)

# Leading Eigenvector
community.unidimensional(wmt, uni.method = "LE")

# Expand
community.unidimensional(wmt, uni.method = "expand")

</code></pre>

<hr>
<h2 id='compare.EGA.plots'>Visually Compare Two or More <code><a href="#topic+EGAnet">EGAnet</a></code> plots</h2><span id='topic+compare.EGA.plots'></span>

<h3>Description</h3>

<p>Organizes EGA plots for comparison. Ensures that 
nodes are placed in the same layout to maximize comparison
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare.EGA.plots(
  ...,
  input.list = NULL,
  base = 1,
  labels = NULL,
  rows = NULL,
  columns = NULL,
  plot.all = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare.EGA.plots_+3A_...">...</code></td>
<td>
<p>Handles multiple arguments:
</p>

<ul>
<li> <p><code>*EGA</code> objects &mdash; can be dropped in without any argument
designation. The function will search across input to find
necessary <code><a href="#topic+EGAnet">EGAnet</a></code> objects
</p>
</li>
<li> <p><code><a href="GGally.html#topic+ggnet2">ggnet2</a></code> arguments &mdash; can be passed along to <code><a href="GGally.html#topic+ggnet2">ggnet2</a></code>
</p>
</li>
<li> <p><code><a href="sna.html#topic+gplot.layout">gplot.layout</a></code> &mdash; can be specified using <code>mode = </code> or
<code>layout = </code> using the name of the layout
(e.g., <code>mode = "circle"</code> will produce the 
circle layout from <a href="sna.html#topic+gplot.layout">gplot.layout</a>).
By default, the layout is the same as <code><a href="qgraph.html#topic+qgraph">qgraph</a></code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="compare.EGA.plots_+3A_input.list">input.list</code></td>
<td>
<p>List.
Bypasses <code>...</code> argument in favor of using a list
as an input</p>
</td></tr>
<tr><td><code id="compare.EGA.plots_+3A_base">base</code></td>
<td>
<p>Numeric (length = 1).
Plot to be used as the base for the configuration of the networks.
Uses the number of the order in which the plots are input.
Defaults to <code>1</code> or the first plot</p>
</td></tr>
<tr><td><code id="compare.EGA.plots_+3A_labels">labels</code></td>
<td>
<p>Character (same length as input).
Labels for each <code><a href="#topic+EGAnet">EGAnet</a></code> object</p>
</td></tr>
<tr><td><code id="compare.EGA.plots_+3A_rows">rows</code></td>
<td>
<p>Numeric (length = 1).
Number of rows to spread plots across</p>
</td></tr>
<tr><td><code id="compare.EGA.plots_+3A_columns">columns</code></td>
<td>
<p>Numeric (length = 1).
Number of columns to spread plots down</p>
</td></tr>
<tr><td><code id="compare.EGA.plots_+3A_plot.all">plot.all</code></td>
<td>
<p>Boolean (length = 1).
Whether plot should be produced or just output.
Defaults to <code>TRUE</code>.
Set to <code>FALSE</code> to avoid plotting (but still obtain
plot objects)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Visual comparison of <code><a href="#topic+EGAnet">EGAnet</a></code> objects
</p>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.EGAnet">plot.EGAnet</a></code> for plot usage in <code><a href="#topic+EGAnet">EGAnet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Obtain WMT-2 data
wmt &lt;- wmt2[,7:24]

# Draw random samples of 300 cases
sample1 &lt;- wmt[sample(1:nrow(wmt), 300),]
sample2 &lt;- wmt[sample(1:nrow(wmt), 300),]

# Estimate EGAs
ega1 &lt;- EGA(sample1)
ega2 &lt;- EGA(sample2)


# Compare EGAs via plot
compare.EGA.plots(
  ega1, ega2,
  base = 1, # use "ega1" as base for comparison
  labels = c("Sample 1", "Sample 2"),
  rows = 1, columns = 2
)

# Change layout to circle plots
compare.EGA.plots(
  ega1, ega2,
  labels = c("Sample 1", "Sample 2"),
  mode = "circle"
)

</code></pre>

<hr>
<h2 id='convert2igraph'>Convert networks to <code><a href="igraph.html#topic+igraph">igraph</a></code></h2><span id='topic+convert2igraph'></span>

<h3>Description</h3>

<p>Converts networks to <code><a href="igraph.html#topic+igraph">igraph</a></code> format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert2igraph(A, diagonal = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert2igraph_+3A_a">A</code></td>
<td>
<p>Matrix or data frame.
<em>N</em> x <em>N</em> matrix where <em>N</em> is the number of nodes</p>
</td></tr>
<tr><td><code id="convert2igraph_+3A_diagonal">diagonal</code></td>
<td>
<p>Numeric.
Value to be placed on the diagonal of <code>A</code>.
Defaults to <code>0</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a network in the <code><a href="igraph.html#topic+igraph">igraph</a></code> format
</p>


<h3>Author(s)</h3>

<p>Hudson Golino &lt;hfg9s at virginia.edu&gt; &amp; Alexander P. Christensen &lt;alexander.christensen at Vanderbilt.Edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>convert2igraph(ega.wmt$network)

</code></pre>

<hr>
<h2 id='convert2tidygraph'>Convert networks to <code>tidygraph</code></h2><span id='topic+convert2tidygraph'></span>

<h3>Description</h3>

<p>Converts networks to <code>tidygraph</code> format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert2tidygraph(EGA.object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert2tidygraph_+3A_ega.object">EGA.object</code></td>
<td>
<p>A single <code><a href="#topic+EGAnet">EGAnet</a></code> object containing the outputs
<code>$network</code> and <code>$wc</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a network in the <code>tidygraph</code> format
</p>


<h3>Author(s)</h3>

<p>Dominique Makowski, Hudson Golino &lt;hfg9s at virginia.edu&gt;, &amp; Alexander P. Christensen &lt;alexander.christensen at Vanderbilt.Edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>convert2tidygraph(ega.wmt)

</code></pre>

<hr>
<h2 id='depression'>Depression Data</h2><span id='topic+depression'></span>

<h3>Description</h3>

<p>A response matrix (<em>n</em> = 574) of the Beck Depression Inventory, 
Beck Anxiety Inventory, and the Athens Insomnia Scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(depression)
</code></pre>


<h3>Format</h3>

<p>A 574x78 response matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("depression")

</code></pre>

<hr>
<h2 id='dimensionStability'>Dimension Stability Statistics from <code><a href="#topic+bootEGA">bootEGA</a></code></h2><span id='topic+dimensionStability'></span>

<h3>Description</h3>

<p>Based on the <code><a href="#topic+bootEGA">bootEGA</a></code> results, 
this function computes the stability of dimensions. Stability is 
computed by assessing the proportion of times the 
original dimension is exactly replicated in across bootstrap samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dimensionStability(bootega.obj, IS.plot = TRUE, structure = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dimensionStability_+3A_bootega.obj">bootega.obj</code></td>
<td>
<p>A <code><a href="#topic+bootEGA">bootEGA</a></code> object</p>
</td></tr>
<tr><td><code id="dimensionStability_+3A_is.plot">IS.plot</code></td>
<td>
<p>Boolean (length = 1).
Should the plot be produced for <code>item.replication</code>?
Defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="dimensionStability_+3A_structure">structure</code></td>
<td>
<p>Numeric (length = number of variables).
A theoretical or pre-defined structure.
Defaults to <code>NULL</code> or the empirical <code><a href="#topic+EGA">EGA</a></code>
result in the <code>bootega.obj</code></p>
</td></tr>
<tr><td><code id="dimensionStability_+3A_...">...</code></td>
<td>
<p>Additional arguments.
Used for deprecated arguments from previous versions of <code><a href="#topic+itemStability">itemStability</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing:
</p>
<table>
<tr><td><code>dimension.stability</code></td>
<td>
<p>A list containing:
</p>

<ul>
<li> <p><code>structural.consistency</code> &mdash; The proportion of times that 
each empirical <code><a href="#topic+EGA">EGA</a></code> dimension <em>exactly</em> 
replicates across the <code><a href="#topic+bootEGA">bootEGA</a></code> samples
</p>
</li>
<li> <p><code>average.item.stability</code> &mdash; The average item stability in 
each empirical <code><a href="#topic+EGA">EGA</a></code> dimension
</p>
</li></ul>

</td></tr>
<tr><td><code>item.stability</code></td>
<td>
<p>Results from <code><a href="#topic+itemStability">itemStability</a></code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hudson Golino &lt;hfg9s at virginia.edu&gt; and Alexander P. Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>References</h3>

<p><strong>Original implementation of bootEGA</strong> <br />
Christensen, A. P., &amp; Golino, H. (2021).
Estimating the stability of the number of factors via Bootstrap Exploratory Graph Analysis: A tutorial.
<em>Psych</em>, <em>3</em>(3), 479-500.
</p>
<p><strong>Conceptual introduction</strong> <br />
Christensen, A. P., Golino, H., &amp; Silvia, P. J. (2020).
A psychometric network perspective on the validity and validation of personality trait questionnaires.
<em>European Journal of Personality</em>, <em>34</em>(6), 1095-1108.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
wmt &lt;- wmt2[,7:24]

## Not run: 
# Estimate bootstrap EGA
boot.wmt &lt;- bootEGA(
  data = wmt, iter = 500,
  type = "parametric", ncores = 2
)
## End(Not run)

# Estimate stability statistics
dimensionStability(boot.wmt)

</code></pre>

<hr>
<h2 id='dnn.weights'>Loadings Comparison Test Deep Learning Neural Network Weights</h2><span id='topic+dnn.weights'></span>

<h3>Description</h3>

<p>A list of weights from four different neural network models:
random vs. non-random model (<code>r_nr_weights</code>),
low correlation factor vs. network model (<code>lf_n_weights</code>),
high correlation with variables less than or equal to factors vs. network model (<code>hlf_n_weights</code>), and
high correlation with variables greater than factors vs. network model (<code>hgf_n_weights</code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dnn.weights)
</code></pre>


<h3>Format</h3>

<p>A list of with a length of 4
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("dnn.weights")

</code></pre>

<hr>
<h2 id='dynEGA'>Dynamic Exploratory Graph Analysis</h2><span id='topic+dynEGA'></span>

<h3>Description</h3>

<p>Estimates dynamic communities in multivariate time series 
(e.g., panel data, longitudinal data, intensive longitudinal data) at multiple
time scales and at different levels of analysis: 
individuals (intraindividual structure), groups, and population (interindividual structure)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dynEGA(
  data,
  id = NULL,
  group = NULL,
  n.embed = 5,
  tau = 1,
  delta = 1,
  use.derivatives = 1,
  level = c("individual", "group", "population"),
  corr = c("auto", "cor_auto", "pearson", "spearman"),
  na.data = c("pairwise", "listwise"),
  model = c("BGGM", "glasso", "TMFG"),
  algorithm = c("leiden", "louvain", "walktrap"),
  uni.method = c("expand", "LE", "louvain"),
  ncores,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dynEGA_+3A_data">data</code></td>
<td>
<p>Matrix or data frame.
Participants and variable should be in long format such that
row <em>t</em> represents observations for all variables at time point 
<em>t</em> for a participant. The next row, <em>t + 1</em>, represents
the next measurement occasion for that same participant. The next
participant's data should immediately follow, in the same pattern,
after the previous participant
</p>
<p><code>data</code> should have an ID variable labeled <code>"ID"</code>; otherwise, it is
assumed that the data represent the population
</p>
<p>For groups, <code>data</code> should have a Group variable labeled <code>"Group"</code>;
otherwise, it is assumed that there are no groups in <code>data</code>
</p>
<p>Arguments <code>id</code> and <code>group</code> can be specified to tell the function
which column in <code>data</code> it should use as the ID and Group variable, respectively
</p>
<p>A measurement occasion variable is not necessary and should be <em>removed</em>
from the data before proceeding with the analysis</p>
</td></tr>
<tr><td><code id="dynEGA_+3A_id">id</code></td>
<td>
<p>Numeric or character (length = 1).
Number or name of the column identifying each individual.
Defaults to <code>NULL</code></p>
</td></tr>
<tr><td><code id="dynEGA_+3A_group">group</code></td>
<td>
<p>Numeric or character (length = 1).
Number of the column identifying group membership.
Defaults to <code>NULL</code></p>
</td></tr>
<tr><td><code id="dynEGA_+3A_n.embed">n.embed</code></td>
<td>
<p>Numeric (length = 1).
Defaults to <code>5</code>.
Number of embedded dimensions (the number of observations to 
be used in the <code><a href="#topic+Embed">Embed</a></code> function). For example,
an <code>"n.embed = 5"</code> will use five consecutive observations 
to estimate a single derivative</p>
</td></tr>
<tr><td><code id="dynEGA_+3A_tau">tau</code></td>
<td>
<p>Numeric (length = 1).
Defaults to <code>1</code>.
Number of observations to offset successive embeddings in 
the <code><a href="#topic+Embed">Embed</a></code> function.
Generally recommended to leave &quot;as is&quot;</p>
</td></tr>
<tr><td><code id="dynEGA_+3A_delta">delta</code></td>
<td>
<p>Numeric (length = 1).
Defaults to <code>1</code>.
The time between successive observations in the time series (i.e, lag).
Generally recommended to leave &quot;as is&quot;</p>
</td></tr>
<tr><td><code id="dynEGA_+3A_use.derivatives">use.derivatives</code></td>
<td>
<p>Numeric (length = 1).
Defaults to <code>1</code>.
The order of the derivative to be used in the analysis.
Available options:
</p>

<ul>
<li> <p><code>0</code> &mdash; No derivatives; consistent with moving average
</p>
</li>
<li> <p><code>1</code> &mdash; First-order derivatives; interpreted as &quot;velocity&quot; or 
rate of change over time
</p>
</li>
<li> <p><code>2</code> &mdash; Second-order derivatives; interpreted as &quot;acceleration&quot; or
rate of the rate of change over time
</p>
</li></ul>

<p>Generally recommended to leave &quot;as is&quot;</p>
</td></tr>
<tr><td><code id="dynEGA_+3A_level">level</code></td>
<td>
<p>Character vector (up to length of 3).
A character vector indicating which level(s) to estimate:
</p>

<ul>
<li> <p><code>"individual"</code> &mdash; Estimates <code><a href="#topic+EGA">EGA</a></code> for each individual in <code>data</code>
(intraindividual structure; requires an <code>"ID"</code> column, see <code>data</code>)
</p>
</li>
<li> <p><code>"group"</code> &mdash; Estimates <code><a href="#topic+EGA">EGA</a></code> for each group in <code>data</code>
(group structure; requires a <code>"Group"</code> column, see <code>data</code>)
</p>
</li>
<li> <p><code>"population"</code> &mdash; Estimates <code><a href="#topic+EGA">EGA</a></code> across all <code>data</code>
(interindividual structure)
</p>
</li></ul>
</td></tr>
<tr><td><code id="dynEGA_+3A_corr">corr</code></td>
<td>
<p>Character (length = 1).
Method to compute correlations.
Defaults to <code>"auto"</code>.
Available options:
</p>

<ul>
<li> <p><code>"auto"</code> &mdash; Automatically computes appropriate correlations for
the data using Pearson's for continuous, polychoric for ordinal,
tetrachoric for binary, and polyserial/biserial for ordinal/binary with
continuous. To change the number of categories that are considered
ordinal, use <code>ordinal.categories</code>
(see <code><a href="#topic+polychoric.matrix">polychoric.matrix</a></code> for more details)
</p>
</li>
<li> <p><code>"cor_auto"</code> &mdash; Uses <code><a href="qgraph.html#topic+cor_auto">cor_auto</a></code> to compute correlations. 
Arguments can be passed along to the function
</p>
</li>
<li> <p><code>"pearson"</code> &mdash; Pearson's correlation is computed for all 
variables regardless of categories
</p>
</li>
<li> <p><code>"spearman"</code> &mdash; Spearman's rank-order correlation is computed 
for all variables regardless of categories
</p>
</li></ul>

<p>For other similarity measures, compute them first and input them
into <code>data</code> with the sample size (<code>n</code>)</p>
</td></tr>
<tr><td><code id="dynEGA_+3A_na.data">na.data</code></td>
<td>
<p>Character (length = 1).
How should missing data be handled?
Defaults to <code>"pairwise"</code>.
Available options:
</p>

<ul>
<li> <p><code>"pairwise"</code> &mdash; Computes correlation for all available cases between
two variables
</p>
</li>
<li> <p><code>"listwise"</code> &mdash; Computes correlation for all complete cases in the dataset
</p>
</li></ul>
</td></tr>
<tr><td><code id="dynEGA_+3A_model">model</code></td>
<td>
<p>Character (length = 1).
Defaults to <code>"glasso"</code>.
Available options:
</p>

<ul>
<li> <p><code>"BGGM"</code> &mdash; Computes the Bayesian Gaussian Graphical Model.
Set argument <code>ordinal.categories</code> to determine
levels allowed for a variable to be considered ordinal.
See <code>?BGGM::estimate</code> for more details
</p>
</li>
<li> <p><code>"glasso"</code> &mdash; Computes the GLASSO with EBIC model selection.
See <code><a href="#topic+EBICglasso.qgraph">EBICglasso.qgraph</a></code> for more details
</p>
</li>
<li> <p><code>"TMFG"</code> &mdash; Computes the TMFG method.
See <code><a href="#topic+TMFG">TMFG</a></code> for more details
</p>
</li></ul>
</td></tr>
<tr><td><code id="dynEGA_+3A_algorithm">algorithm</code></td>
<td>
<p>Character or 
<code><a href="igraph.html#topic+igraph">igraph</a></code> <code>cluster_*</code> function (length = 1).
Defaults to <code>"walktrap"</code>.
Three options are listed below but all are available
(see <code><a href="#topic+community.detection">community.detection</a></code> for other options):
</p>

<ul>
<li> <p><code>"leiden"</code> &mdash; See <code><a href="igraph.html#topic+cluster_leiden">cluster_leiden</a></code> for more details
</p>
</li>
<li> <p><code>"louvain"</code> &mdash; By default, <code>"louvain"</code> will implement the Louvain algorithm using 
the consensus clustering method (see <code><a href="#topic+community.consensus">community.consensus</a></code> 
for more information). This function will implement
<code>consensus.method = "most_common"</code> and <code>consensus.iter = 1000</code> 
unless specified otherwise
</p>
</li>
<li> <p><code>"walktrap"</code> &mdash; See <code><a href="igraph.html#topic+cluster_walktrap">cluster_walktrap</a></code> for more details
</p>
</li></ul>
</td></tr>
<tr><td><code id="dynEGA_+3A_uni.method">uni.method</code></td>
<td>
<p>Character (length = 1).
What unidimensionality method should be used? 
Defaults to <code>"louvain"</code>.
Available options:
</p>

<ul>
<li> <p><code>"expand"</code> &mdash; Expands the correlation matrix with four variables correlated 0.50.
If number of dimension returns 2 or less in check, then the data 
are unidimensional; otherwise, regular EGA with no matrix
expansion is used. This method was used in the Golino et al.'s (2020)
<em>Psychological Methods</em> simulation
</p>
</li>
<li> <p><code>"LE"</code> &mdash; Applies the Leading Eigenvector algorithm
(<code><a href="igraph.html#topic+cluster_leading_eigen">cluster_leading_eigen</a></code>)
on the empirical correlation matrix. If the number of dimensions is 1,
then the Leading Eigenvector solution is used; otherwise, regular EGA
is used. This method was used in the Christensen et al.'s (2023) 
<em>Behavior Research Methods</em> simulation
</p>
</li>
<li> <p><code>"louvain"</code> &mdash; Applies the Louvain algorithm (<code><a href="igraph.html#topic+cluster_louvain">cluster_louvain</a></code>)
on the empirical correlation matrix. If the number of dimensions is 1, 
then the Louvain solution is used; otherwise, regular EGA is used. 
This method was validated Christensen's (2022) <em>PsyArXiv</em> simulation.
Consensus clustering can be used by specifying either
<code>"consensus.method"</code> or <code>"consensus.iter"</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="dynEGA_+3A_ncores">ncores</code></td>
<td>
<p>Numeric (length = 1).
Number of cores to use in computing results.
Defaults to <code>ceiling(parallel::detectCores() / 2)</code> or half of your
computer's processing power.
Set to <code>1</code> to not use parallel computing
</p>
<p>If you're unsure how many cores your computer has,
then type: <code>parallel::detectCores()</code></p>
</td></tr>
<tr><td><code id="dynEGA_+3A_verbose">verbose</code></td>
<td>
<p>Boolean (length = 1).
Should progress be displayed?
Defaults to <code>TRUE</code>.
Set to <code>FALSE</code> to not display progress</p>
</td></tr>
<tr><td><code id="dynEGA_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed on to
<code><a href="#topic+auto.correlate">auto.correlate</a></code>,
<code><a href="#topic+network.estimation">network.estimation</a></code>,
<code><a href="#topic+community.detection">community.detection</a></code>,
<code><a href="#topic+community.consensus">community.consensus</a></code>, and
<code><a href="#topic+EGA">EGA</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Derivatives for each variable's time series for each participant are
estimated using generalized local linear approximation (see <code><a href="#topic+glla">glla</a></code>).
<code><a href="#topic+EGA">EGA</a></code> is then applied to these derivatives to model how variables
are changing together over time. Variables that change together over time are detected
as communities
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>Derivatives</code></td>
<td>
<p>A list containing:
</p>

<ul>
<li> <p><code>Estimates</code> &mdash; A list the length of the unique IDs containing
data frames of zero- to second-order derivatives for each ID in <code>data</code>
</p>
</li>
<li> <p><code>EstimatesDF</code> &mdash; A data frame of derivatives across all IDs containing
columns of the zero- to second-order derivatives as well as <code>id</code> and
<code>group</code> variables (<code>group</code> is automatically set to <code>1</code>
for all if no <code>group</code> is provided)
</p>
</li></ul>

</td></tr>
<tr><td><code>dynEGA</code></td>
<td>
<p>A list containing:
</p>

<ul>
<li> <p><code>population</code> &mdash; If <code>level</code> includes <code>"populaton"</code>, then
the <code><a href="#topic+EGA">EGA</a></code> results for the entire sample
</p>
</li>
<li> <p><code>group</code> &mdash; If <code>level</code> includes <code>"group"</code>, then
a list containing the <code><a href="#topic+EGA">EGA</a></code> results for each <code>group</code>
</p>
</li>
<li> <p><code>individual</code> &mdash; If <code>level</code> includes <code>"individual"</code>, then
a list containing the <code><a href="#topic+EGA">EGA</a></code> results for each <code>id</code>
</p>
</li></ul>

</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hudson Golino &lt;hfg9s at virginia.edu&gt; and Alexander P. Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>References</h3>

<p><strong>Generalized local linear approximation</strong> <br />
Boker, S. M., Deboeck, P. R., Edler, C., &amp; Keel, P. K. (2010)
Generalized local linear approximation of derivatives from time series. In S.-M. Chow, E. Ferrer, &amp; F. Hsieh (Eds.),
<em>The Notre Dame series on quantitative methodology. Statistical methods for modeling human dynamics: An interdisciplinary dialogue</em>,
(p. 161-178). <em>Routledge/Taylor &amp; Francis Group</em>.
</p>
<p>Deboeck, P. R., Montpetit, M. A., Bergeman, C. S., &amp; Boker, S. M. (2009)
Using derivative estimates to describe intraindividual variability at multiple time scales.
<em>Psychological Methods</em>, <em>14(4)</em>, 367-386.
</p>
<p><strong>Original dynamic EGA implementation</strong> <br />
Golino, H., Christensen, A. P., Moulder, R. G., Kim, S., &amp; Boker, S. M. (2021).
Modeling latent topics in social media using Dynamic Exploratory Graph Analysis: The case of the right-wing and left-wing trolls in the 2016 US elections.
<em>Psychometrika</em>.
</p>
<p><strong>Time delay embedding procedure</strong> <br />
Savitzky, A., &amp; Golay, M. J. (1964).
Smoothing and differentiation of data by simplified least squares procedures.
<em>Analytical Chemistry</em>, <em>36(8)</em>, 1627-1639.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.EGAnet">plot.EGAnet</a></code> for plot usage in <code><a href="#topic+EGAnet">EGAnet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Population structure
simulated_population &lt;- dynEGA(
  data = sim.dynEGA, level = "population"
  # uses simulated data in package
  # useful to understand how data should be structured
)

# Group structure
simulated_group &lt;- dynEGA(
  data = sim.dynEGA, level = "group"
  # uses simulated data in package
  # useful to understand how data should be structured
)

## Not run: 
# Individual structure
simulated_individual &lt;- dynEGA(
  data = sim.dynEGA, level = "individual",
  ncores = 2, # use more for quicker results
  verbose = TRUE # progress bar
)

# Population, group, and individual structure
simulated_all &lt;- dynEGA(
  data = sim.dynEGA, 
  level = c("individual", "group", "population"),
  ncores = 2, # use more for quicker results
  verbose = TRUE # progress bar
)

# Plot population
plot(simulated_all$dynEGA$population)

# Plot groups
plot(simulated_all$dynEGA$group)

# Plot individual
plot(simulated_all$dynEGA$individual, id = 1)

# Step through all plots
# Unless `id` is specified, 4 random IDs
# will be drawn from individuals
plot(simulated_all)
## End(Not run)

</code></pre>

<hr>
<h2 id='dynEGA.ind.pop'>Intra- and Inter-individual <code><a href="#topic+dynEGA">dynEGA</a></code></h2><span id='topic+dynEGA.ind.pop'></span>

<h3>Description</h3>

<p>A wrapper function to estimate both intraindividiual
(<code>level = "individual"</code>) and interindividual (<code>level = "population"</code>)
structures using <code><a href="#topic+dynEGA">dynEGA</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dynEGA.ind.pop(
  data,
  id = NULL,
  n.embed = 5,
  tau = 1,
  delta = 1,
  use.derivatives = 1,
  corr = c("auto", "cor_auto", "pearson", "spearman"),
  na.data = c("pairwise", "listwise"),
  model = c("BGGM", "glasso", "TMFG"),
  algorithm = c("leiden", "louvain", "walktrap"),
  uni.method = c("expand", "LE", "louvain"),
  ncores,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dynEGA.ind.pop_+3A_data">data</code></td>
<td>
<p>Matrix or data frame.
Participants and variable should be in long format such that
row <em>t</em> represents observations for all variables at time point 
<em>t</em> for a participant. The next row, <em>t + 1</em>, represents
the next measurement occasion for that same participant. The next
participant's data should immediately follow, in the same pattern,
after the previous participant
</p>
<p><code>data</code> should have an ID variable labeled <code>"ID"</code>; otherwise, it is
assumed that the data represent the population
</p>
<p>For groups, <code>data</code> should have a Group variable labeled <code>"Group"</code>;
otherwise, it is assumed that there are no groups in <code>data</code>
</p>
<p>Arguments <code>id</code> and <code>group</code> can be specified to tell the function
which column in <code>data</code> it should use as the ID and Group variable, respectively
</p>
<p>A measurement occasion variable is not necessary and should be <em>removed</em>
from the data before proceeding with the analysis</p>
</td></tr>
<tr><td><code id="dynEGA.ind.pop_+3A_id">id</code></td>
<td>
<p>Numeric or character (length = 1).
Number or name of the column identifying each individual.
Defaults to <code>NULL</code></p>
</td></tr>
<tr><td><code id="dynEGA.ind.pop_+3A_n.embed">n.embed</code></td>
<td>
<p>Numeric (length = 1).
Defaults to <code>5</code>.
Number of embedded dimensions (the number of observations to 
be used in the <code><a href="#topic+Embed">Embed</a></code> function). For example,
an <code>"n.embed = 5"</code> will use five consecutive observations 
to estimate a single derivative</p>
</td></tr>
<tr><td><code id="dynEGA.ind.pop_+3A_tau">tau</code></td>
<td>
<p>Numeric (length = 1).
Defaults to <code>1</code>.
Number of observations to offset successive embeddings in 
the <code><a href="#topic+Embed">Embed</a></code> function.
Generally recommended to leave &quot;as is&quot;</p>
</td></tr>
<tr><td><code id="dynEGA.ind.pop_+3A_delta">delta</code></td>
<td>
<p>Numeric (length = 1).
Defaults to <code>1</code>.
The time between successive observations in the time series (i.e, lag).
Generally recommended to leave &quot;as is&quot;</p>
</td></tr>
<tr><td><code id="dynEGA.ind.pop_+3A_use.derivatives">use.derivatives</code></td>
<td>
<p>Numeric (length = 1).
Defaults to <code>1</code>.
The order of the derivative to be used in the analysis.
Available options:
</p>

<ul>
<li> <p><code>0</code> &mdash; No derivatives; consistent with moving average
</p>
</li>
<li> <p><code>1</code> &mdash; First-order derivatives; interpreted as &quot;velocity&quot; or 
rate of change over time
</p>
</li>
<li> <p><code>2</code> &mdash; Second-order derivatives; interpreted as &quot;acceleration&quot; or
rate of the rate of change over time
</p>
</li></ul>

<p>Generally recommended to leave &quot;as is&quot;</p>
</td></tr>
<tr><td><code id="dynEGA.ind.pop_+3A_corr">corr</code></td>
<td>
<p>Character (length = 1).
Method to compute correlations.
Defaults to <code>"auto"</code>.
Available options:
</p>

<ul>
<li> <p><code>"auto"</code> &mdash; Automatically computes appropriate correlations for
the data using Pearson's for continuous, polychoric for ordinal,
tetrachoric for binary, and polyserial/biserial for ordinal/binary with
continuous. To change the number of categories that are considered
ordinal, use <code>ordinal.categories</code>
(see <code><a href="#topic+polychoric.matrix">polychoric.matrix</a></code> for more details)
</p>
</li>
<li> <p><code>"cor_auto"</code> &mdash; Uses <code><a href="qgraph.html#topic+cor_auto">cor_auto</a></code> to compute correlations. 
Arguments can be passed along to the function
</p>
</li>
<li> <p><code>"pearson"</code> &mdash; Pearson's correlation is computed for all 
variables regardless of categories
</p>
</li>
<li> <p><code>"spearman"</code> &mdash; Spearman's rank-order correlation is computed 
for all variables regardless of categories
</p>
</li></ul>

<p>For other similarity measures, compute them first and input them
into <code>data</code> with the sample size (<code>n</code>)</p>
</td></tr>
<tr><td><code id="dynEGA.ind.pop_+3A_na.data">na.data</code></td>
<td>
<p>Character (length = 1).
How should missing data be handled?
Defaults to <code>"pairwise"</code>.
Available options:
</p>

<ul>
<li> <p><code>"pairwise"</code> &mdash; Computes correlation for all available cases between
two variables
</p>
</li>
<li> <p><code>"listwise"</code> &mdash; Computes correlation for all complete cases in the dataset
</p>
</li></ul>
</td></tr>
<tr><td><code id="dynEGA.ind.pop_+3A_model">model</code></td>
<td>
<p>Character (length = 1).
Defaults to <code>"glasso"</code>.
Available options:
</p>

<ul>
<li> <p><code>"BGGM"</code> &mdash; Computes the Bayesian Gaussian Graphical Model.
Set argument <code>ordinal.categories</code> to determine
levels allowed for a variable to be considered ordinal.
See <code>?BGGM::estimate</code> for more details
</p>
</li>
<li> <p><code>"glasso"</code> &mdash; Computes the GLASSO with EBIC model selection.
See <code><a href="#topic+EBICglasso.qgraph">EBICglasso.qgraph</a></code> for more details
</p>
</li>
<li> <p><code>"TMFG"</code> &mdash; Computes the TMFG method.
See <code><a href="#topic+TMFG">TMFG</a></code> for more details
</p>
</li></ul>
</td></tr>
<tr><td><code id="dynEGA.ind.pop_+3A_algorithm">algorithm</code></td>
<td>
<p>Character or 
<code><a href="igraph.html#topic+igraph">igraph</a></code> <code>cluster_*</code> function (length = 1).
Defaults to <code>"walktrap"</code>.
Three options are listed below but all are available
(see <code><a href="#topic+community.detection">community.detection</a></code> for other options):
</p>

<ul>
<li> <p><code>"leiden"</code> &mdash; See <code><a href="igraph.html#topic+cluster_leiden">cluster_leiden</a></code> for more details
</p>
</li>
<li> <p><code>"louvain"</code> &mdash; By default, <code>"louvain"</code> will implement the Louvain algorithm using 
the consensus clustering method (see <code><a href="#topic+community.consensus">community.consensus</a></code> 
for more information). This function will implement
<code>consensus.method = "most_common"</code> and <code>consensus.iter = 1000</code> 
unless specified otherwise
</p>
</li>
<li> <p><code>"walktrap"</code> &mdash; See <code><a href="igraph.html#topic+cluster_walktrap">cluster_walktrap</a></code> for more details
</p>
</li></ul>
</td></tr>
<tr><td><code id="dynEGA.ind.pop_+3A_uni.method">uni.method</code></td>
<td>
<p>Character (length = 1).
What unidimensionality method should be used? 
Defaults to <code>"louvain"</code>.
Available options:
</p>

<ul>
<li> <p><code>"expand"</code> &mdash; Expands the correlation matrix with four variables correlated 0.50.
If number of dimension returns 2 or less in check, then the data 
are unidimensional; otherwise, regular EGA with no matrix
expansion is used. This method was used in the Golino et al.'s (2020)
<em>Psychological Methods</em> simulation
</p>
</li>
<li> <p><code>"LE"</code> &mdash; Applies the Leading Eigenvector algorithm
(<code><a href="igraph.html#topic+cluster_leading_eigen">cluster_leading_eigen</a></code>)
on the empirical correlation matrix. If the number of dimensions is 1,
then the Leading Eigenvector solution is used; otherwise, regular EGA
is used. This method was used in the Christensen et al.'s (2023) 
<em>Behavior Research Methods</em> simulation
</p>
</li>
<li> <p><code>"louvain"</code> &mdash; Applies the Louvain algorithm (<code><a href="igraph.html#topic+cluster_louvain">cluster_louvain</a></code>)
on the empirical correlation matrix. If the number of dimensions is 1, 
then the Louvain solution is used; otherwise, regular EGA is used. 
This method was validated Christensen's (2022) <em>PsyArXiv</em> simulation.
Consensus clustering can be used by specifying either
<code>"consensus.method"</code> or <code>"consensus.iter"</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="dynEGA.ind.pop_+3A_ncores">ncores</code></td>
<td>
<p>Numeric (length = 1).
Number of cores to use in computing results.
Defaults to <code>ceiling(parallel::detectCores() / 2)</code> or half of your
computer's processing power.
Set to <code>1</code> to not use parallel computing
</p>
<p>If you're unsure how many cores your computer has,
then type: <code>parallel::detectCores()</code></p>
</td></tr>
<tr><td><code id="dynEGA.ind.pop_+3A_verbose">verbose</code></td>
<td>
<p>Boolean (length = 1).
Should progress be displayed?
Defaults to <code>TRUE</code>.
Set to <code>FALSE</code> to not display progress</p>
</td></tr>
<tr><td><code id="dynEGA.ind.pop_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed on to
<code><a href="#topic+auto.correlate">auto.correlate</a></code>,
<code><a href="#topic+network.estimation">network.estimation</a></code>,
<code><a href="#topic+community.detection">community.detection</a></code>,
<code><a href="#topic+community.consensus">community.consensus</a></code>, and
<code><a href="#topic+EGA">EGA</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Same output as <code><a href="#topic+EGAnet">EGAnet</a>{dynEGA}</code> returning list
objects for <code>level = "individual"</code> and <code>level = "population"</code>
</p>


<h3>Author(s)</h3>

<p>Hudson Golino &lt;hfg9s at virginia.edu&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.EGAnet">plot.EGAnet</a></code> for plot usage in <code><a href="#topic+EGAnet">EGAnet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Obtain data
sim.dynEGA &lt;- sim.dynEGA # bypasses CRAN checks

## Not run: 
# Dynamic EGA individual and population structure
dyn.ega1 &lt;- dynEGA.ind.pop(
  data = sim.dynEGA, n.embed = 5, tau = 1,
  delta = 1, id = 25, use.derivatives = 1,
  ncores = 2, corr = "pearson"
)
## End(Not run)

</code></pre>

<hr>
<h2 id='EBICglasso.qgraph'><code><a href="qgraph.html#topic+EBICglasso">EBICglasso</a></code> from <code><a href="qgraph.html#topic+qgraph">qgraph</a></code> 1.4.4</h2><span id='topic+EBICglasso.qgraph'></span>

<h3>Description</h3>

<p>This function uses the <code><a href="glasso.html#topic+glasso">glasso</a></code> package
(Friedman, Hastie and Tibshirani, 2011) to compute a
sparse gaussian graphical model with the graphical lasso
(Friedman, Hastie &amp; Tibshirani, 2008).
The tuning parameter is chosen using the Extended Bayesian Information criterion
(EBIC) described by Foygel &amp; Drton (2010).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EBICglasso.qgraph(
  data,
  n = NULL,
  corr = c("auto", "cor_auto", "pearson", "spearman"),
  na.data = c("pairwise", "listwise"),
  gamma = 0.5,
  penalize.diagonal = FALSE,
  nlambda = 100,
  lambda.min.ratio = 0.1,
  returnAllResults = FALSE,
  penalizeMatrix,
  countDiagonal = FALSE,
  refit = FALSE,
  model.selection = c("EBIC", "JSD"),
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EBICglasso.qgraph_+3A_data">data</code></td>
<td>
<p>Matrix or data frame.
Should consist only of variables to be used in the analysis</p>
</td></tr>
<tr><td><code id="EBICglasso.qgraph_+3A_n">n</code></td>
<td>
<p>Numeric (length = 1).
Sample size if <code>data</code> provided is a correlation matrix</p>
</td></tr>
<tr><td><code id="EBICglasso.qgraph_+3A_corr">corr</code></td>
<td>
<p>Character (length = 1).
Method to compute correlations.
Defaults to <code>"auto"</code>.
Available options:
</p>

<ul>
<li> <p><code>"auto"</code> &mdash; Automatically computes appropriate correlations for
the data using Pearson's for continuous, polychoric for ordinal,
tetrachoric for binary, and polyserial/biserial for ordinal/binary with
continuous. To change the number of categories that are considered
ordinal, use <code>ordinal.categories</code>
(see <code><a href="#topic+polychoric.matrix">polychoric.matrix</a></code> for more details)
</p>
</li>
<li> <p><code>"cor_auto"</code> &mdash; Uses <code><a href="qgraph.html#topic+cor_auto">cor_auto</a></code> to
compute correlations. Arguments can be passed along to the function
</p>
</li>
<li> <p><code>"pearson"</code> &mdash; Pearson's correlation is computed for
all variables regardless of categories
</p>
</li>
<li> <p><code>"spearman"</code> &mdash; Spearman's rank-order correlation is
computed for all variables regardless of categories
</p>
</li></ul>
</td></tr>
<tr><td><code id="EBICglasso.qgraph_+3A_na.data">na.data</code></td>
<td>
<p>Character (length = 1).
How should missing data be handled?
Defaults to <code>"pairwise"</code>.
Available options:
</p>

<ul>
<li> <p><code>"pairwise"</code> &mdash; Computes correlation for all available
cases between two variables
</p>
</li>
<li> <p><code>"listwise"</code> &mdash; Computes correlation for all complete
cases in the dataset
</p>
</li></ul>
</td></tr>
<tr><td><code id="EBICglasso.qgraph_+3A_gamma">gamma</code></td>
<td>
<p>Numeric (length = 1)
EBIC tuning parameter.
Defaults to <code>0.50</code> and is generally a good choice.
Setting to <code>0</code> will cause regular BIC to be used</p>
</td></tr>
<tr><td><code id="EBICglasso.qgraph_+3A_penalize.diagonal">penalize.diagonal</code></td>
<td>
<p>Boolean (length = 1).
Should the diagonal be penalized?
Defaults to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="EBICglasso.qgraph_+3A_nlambda">nlambda</code></td>
<td>
<p>Numeric (length = 1).
Number of lambda values to test.
Defaults to <code>100</code></p>
</td></tr>
<tr><td><code id="EBICglasso.qgraph_+3A_lambda.min.ratio">lambda.min.ratio</code></td>
<td>
<p>Numeric (length = 1).
Ratio of lowest lambda value compared to maximal lambda.
Defaults to <code>0.1</code>.
<strong>NOTE</strong> <code><a href="qgraph.html#topic+qgraph">qgraph</a></code> sets the default to <code>0.01</code></p>
</td></tr>
<tr><td><code id="EBICglasso.qgraph_+3A_returnallresults">returnAllResults</code></td>
<td>
<p>Boolean (length = 1).
Whether all results should be returned.
Defaults to <code>FALSE</code> (network only).
Set to <code>TRUE</code> to access <code><a href="glasso.html#topic+glassopath">glassopath</a></code> output</p>
</td></tr>
<tr><td><code id="EBICglasso.qgraph_+3A_penalizematrix">penalizeMatrix</code></td>
<td>
<p>Boolean matrix.
Optional logical matrix to indicate which elements are penalized</p>
</td></tr>
<tr><td><code id="EBICglasso.qgraph_+3A_countdiagonal">countDiagonal</code></td>
<td>
<p>Boolean (length = 1).
Should diagonal be counted in EBIC computation?
Defaults to <code>FALSE</code>.
Set to <code>TRUE</code> to mimic <code><a href="qgraph.html#topic+qgraph">qgraph</a></code> &lt; 1.3 behavior (not recommended!)</p>
</td></tr>
<tr><td><code id="EBICglasso.qgraph_+3A_refit">refit</code></td>
<td>
<p>Boolean (length = 1).
Should the optimal graph be refitted without LASSO regularization?
Defaults to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="EBICglasso.qgraph_+3A_model.selection">model.selection</code></td>
<td>
<p>Character (length = 1).
How lambda should be selected within GLASSO.
Defaults to <code>"EBIC"</code>.
<code>"JSD"</code> is experimental and should not be used otherwise</p>
</td></tr>
<tr><td><code id="EBICglasso.qgraph_+3A_verbose">verbose</code></td>
<td>
<p>Boolean (length = 1).
Whether messages and (insignificant) warnings should be output.
Defaults to <code>FALSE</code> (silent calls).
Set to <code>TRUE</code> to see all messages and warnings for every function call</p>
</td></tr>
<tr><td><code id="EBICglasso.qgraph_+3A_...">...</code></td>
<td>
<p>Arguments sent to <code><a href="glasso.html#topic+glasso">glasso</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The glasso is run for 100 values of the tuning parameter logarithmically
spaced between the maximal value of the tuning parameter at which all edges are zero,
lambda_max, and lambda_max/100. For each of these graphs the EBIC is computed and
the graph with the best EBIC is selected. The partial correlation matrix
is computed using <code><a href="qgraph.html#topic+wi2net">wi2net</a></code> and returned.
</p>


<h3>Value</h3>

<p>A partial correlation matrix
</p>


<h3>Author(s)</h3>

<p>Sacha Epskamp; for maintanence,
Hudson Golino &lt;hfg9s at virginia.edu&gt; and Alexander P. Christensen &lt;alexpaulchristensen at gmail.com&gt;
</p>


<h3>References</h3>

<p><strong>Instantiation of GLASSO</strong> <br />
Friedman, J., Hastie, T., &amp; Tibshirani, R. (2008).
Sparse inverse covariance estimation with the graphical lasso.
<em>Biostatistics</em>, <em>9</em>, 432-441.
</p>
<p><strong>glasso + EBIC</strong> <br />
Foygel, R., &amp; Drton, M. (2010).
Extended Bayesian information criteria for Gaussian graphical models.
<em>In Advances in neural information processing systems</em> (pp. 604-612).
</p>
<p><strong>glasso package</strong> <br />
Friedman, J., Hastie, T., &amp; Tibshirani, R. (2011).
glasso: Graphical lasso-estimation of Gaussian graphical models.
R package version 1.7.
</p>
<p><strong>Tutorial on EBICglasso</strong> <br />
Epskamp, S., &amp; Fried, E. I. (2018).
A tutorial on regularized partial correlation networks.
<em>Psychological Methods</em>, <em>23</em>(4), 617â€“634.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Obtain data
wmt &lt;- wmt2[,7:24]

# Compute graph with tuning = 0 (BIC)
BICgraph &lt;- EBICglasso.qgraph(data = wmt, gamma = 0)

# Compute graph with tuning = 0.5 (EBIC)
EBICgraph &lt;- EBICglasso.qgraph(data = wmt, gamma = 0.5)

</code></pre>

<hr>
<h2 id='EGA'>Exploratory Graph Analysis</h2><span id='topic+EGA'></span>

<h3>Description</h3>

<p>Estimates the number of communities (dimensions) of
a dataset or correlation matrix using a network estimation method
(Golino &amp; Epskamp, 2017; Golino et al., 2020). After, a community
detection algorithm is applied (Christensen et al., 2023) for
multidimensional data. A unidimensional check is also applied
based on findings from Golino et al. (2020) and Christensen (2023)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EGA(
  data,
  n = NULL,
  corr = c("auto", "cor_auto", "pearson", "spearman"),
  na.data = c("pairwise", "listwise"),
  model = c("BGGM", "glasso", "TMFG"),
  algorithm = c("leiden", "louvain", "walktrap"),
  uni.method = c("expand", "LE", "louvain"),
  plot.EGA = TRUE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EGA_+3A_data">data</code></td>
<td>
<p>Matrix or data frame.
Should consist only of variables to be used in the analysis.
Can be raw data or a correlation matrix</p>
</td></tr>
<tr><td><code id="EGA_+3A_n">n</code></td>
<td>
<p>Numeric (length = 1).
Sample size if <code>data</code> provided is a correlation matrix</p>
</td></tr>
<tr><td><code id="EGA_+3A_corr">corr</code></td>
<td>
<p>Character (length = 1).
Method to compute correlations.
Defaults to <code>"auto"</code>.
Available options:
</p>

<ul>
<li> <p><code>"auto"</code> &mdash; Automatically computes appropriate correlations for
the data using Pearson's for continuous, polychoric for ordinal,
tetrachoric for binary, and polyserial/biserial for ordinal/binary with
continuous. To change the number of categories that are considered
ordinal, use <code>ordinal.categories</code>
(see <code><a href="#topic+polychoric.matrix">polychoric.matrix</a></code> for more details)
</p>
</li>
<li> <p><code>"cor_auto"</code> &mdash; Uses <code><a href="qgraph.html#topic+cor_auto">cor_auto</a></code> to compute correlations. 
Arguments can be passed along to the function
</p>
</li>
<li> <p><code>"pearson"</code> &mdash; Pearson's correlation is computed for all 
variables regardless of categories
</p>
</li>
<li> <p><code>"spearman"</code> &mdash; Spearman's rank-order correlation is computed 
for all variables regardless of categories
</p>
</li></ul>

<p>For other similarity measures, compute them first and input them
into <code>data</code> with the sample size (<code>n</code>)</p>
</td></tr>
<tr><td><code id="EGA_+3A_na.data">na.data</code></td>
<td>
<p>Character (length = 1).
How should missing data be handled?
Defaults to <code>"pairwise"</code>.
Available options:
</p>

<ul>
<li> <p><code>"pairwise"</code> &mdash; Computes correlation for all available cases between
two variables
</p>
</li>
<li> <p><code>"listwise"</code> &mdash; Computes correlation for all complete cases in the dataset
</p>
</li></ul>
</td></tr>
<tr><td><code id="EGA_+3A_model">model</code></td>
<td>
<p>Character (length = 1).
Defaults to <code>"glasso"</code>.
Available options:
</p>

<ul>
<li> <p><code>"BGGM"</code> &mdash; Computes the Bayesian Gaussian Graphical Model.
Set argument <code>ordinal.categories</code> to determine
levels allowed for a variable to be considered ordinal.
See <code>?BGGM::estimate</code> for more details
</p>
</li>
<li> <p><code>"glasso"</code> &mdash; Computes the GLASSO with EBIC model selection.
See <code><a href="#topic+EBICglasso.qgraph">EBICglasso.qgraph</a></code> for more details
</p>
</li>
<li> <p><code>"TMFG"</code> &mdash; Computes the TMFG method.
See <code><a href="#topic+TMFG">TMFG</a></code> for more details
</p>
</li></ul>
</td></tr>
<tr><td><code id="EGA_+3A_algorithm">algorithm</code></td>
<td>
<p>Character or 
<code><a href="igraph.html#topic+igraph">igraph</a></code> <code>cluster_*</code> function (length = 1).
Defaults to <code>"walktrap"</code>.
Three options are listed below but all are available
(see <code><a href="#topic+community.detection">community.detection</a></code> for other options):
</p>

<ul>
<li> <p><code>"leiden"</code> &mdash; See <code><a href="igraph.html#topic+cluster_leiden">cluster_leiden</a></code> for more details
</p>
</li>
<li> <p><code>"louvain"</code> &mdash; By default, <code>"louvain"</code> will implement the Louvain algorithm using 
the consensus clustering method (see <code><a href="#topic+community.consensus">community.consensus</a></code> 
for more information). This function will implement
<code>consensus.method = "most_common"</code> and <code>consensus.iter = 1000</code> 
unless specified otherwise
</p>
</li>
<li> <p><code>"walktrap"</code> &mdash; See <code><a href="igraph.html#topic+cluster_walktrap">cluster_walktrap</a></code> for more details
</p>
</li></ul>
</td></tr>
<tr><td><code id="EGA_+3A_uni.method">uni.method</code></td>
<td>
<p>Character (length = 1).
What unidimensionality method should be used? 
Defaults to <code>"louvain"</code>.
Available options:
</p>

<ul>
<li> <p><code>"expand"</code> &mdash; Expands the correlation matrix with four variables correlated 0.50.
If number of dimension returns 2 or less in check, then the data 
are unidimensional; otherwise, regular EGA with no matrix
expansion is used. This method was used in the Golino et al.'s (2020)
<em>Psychological Methods</em> simulation
</p>
</li>
<li> <p><code>"LE"</code> &mdash; Applies the Leading Eigenvector algorithm
(<code><a href="igraph.html#topic+cluster_leading_eigen">cluster_leading_eigen</a></code>)
on the empirical correlation matrix. If the number of dimensions is 1,
then the Leading Eigenvector solution is used; otherwise, regular EGA
is used. This method was used in the Christensen et al.'s (2023) 
<em>Behavior Research Methods</em> simulation
</p>
</li>
<li> <p><code>"louvain"</code> &mdash; Applies the Louvain algorithm (<code><a href="igraph.html#topic+cluster_louvain">cluster_louvain</a></code>)
on the empirical correlation matrix. If the number of dimensions is 1, 
then the Louvain solution is used; otherwise, regular EGA is used. 
This method was validated Christensen's (2022) <em>PsyArXiv</em> simulation.
Consensus clustering can be used by specifying either
<code>"consensus.method"</code> or <code>"consensus.iter"</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="EGA_+3A_plot.ega">plot.EGA</code></td>
<td>
<p>Boolean (length = 1).
Defaults to <code>TRUE</code>.
Whether the plot should be returned with the results.
Set to <code>FALSE</code> for no plot</p>
</td></tr>
<tr><td><code id="EGA_+3A_verbose">verbose</code></td>
<td>
<p>Boolean (length = 1).
Whether messages and (insignificant) warnings should be output.
Defaults to <code>FALSE</code> (silent calls).
Set to <code>TRUE</code> to see all messages and warnings for every function call</p>
</td></tr>
<tr><td><code id="EGA_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed on to
<code><a href="#topic+auto.correlate">auto.correlate</a></code>, 
<code><a href="#topic+network.estimation">network.estimation</a></code>,
<code><a href="#topic+community.detection">community.detection</a></code>, 
<code><a href="#topic+community.consensus">community.consensus</a></code>, and
<code><a href="#topic+community.unidimensional">community.unidimensional</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing:
</p>
<table>
<tr><td><code>network</code></td>
<td>
<p>A matrix containing a network estimated using 
<code>link[EGAnet]{network.estimation}</code></p>
</td></tr>
<tr><td><code>wc</code></td>
<td>
<p>A vector representing the community (dimension) membership
of each node in the network. <code>NA</code> values mean that the node
was disconnected from the network</p>
</td></tr>
<tr><td><code>n.dim</code></td>
<td>
<p>A scalar of how many total dimensions were identified in the network</p>
</td></tr>
<tr><td><code>correlation</code></td>
<td>
<p>The zero-order correlation matrix</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>Number of cases in <code>data</code></p>
</td></tr>
<tr><td><code>dim.variables</code></td>
<td>
<p>An ordered matrix of item allocation</p>
</td></tr>
<tr><td><code>TEFI</code></td>
<td>
<p><code>link[EGAnet]{tefi}</code> for the estimated structure</p>
</td></tr>
<tr><td><code>plot.EGA</code></td>
<td>
<p>Plot output if <code>plot.EGA = TRUE</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hudson Golino &lt;hfg9s at virginia.edu&gt;, Alexander P. Christensen &lt;alexpaulchristensen at gmail.com&gt;, Maria Dolores Nieto &lt;acinodam at gmail.com&gt; and Luis E. Garrido &lt;garrido.luiseduardo at gmail.com&gt;
</p>


<h3>References</h3>

<p><strong>Original simulation and implementation of EGA</strong> <br />
Golino, H. F., &amp; Epskamp, S. (2017).
Exploratory graph analysis: A new approach for estimating the number of dimensions in psychological research.
<em>PLoS ONE</em>, <em>12</em>, e0174035.
</p>
<p><strong>Current implementation of EGA, introduced unidimensional checks, continuous and dichotomous data</strong> <br />
Golino, H., Shi, D., Christensen, A. P., Garrido, L. E., Nieto, M. D., Sadana, R., &amp; Thiyagarajan, J. A. (2020).
Investigating the performance of Exploratory Graph Analysis and traditional techniques to identify the number of latent factors: A simulation and tutorial.
<em>Psychological Methods</em>, <em>25</em>, 292-320.
</p>
<p><strong>Compared all <em>igraph</em> community detection algorithms, introduced Louvain algorithm, simulation with continuous and polytomous data</strong> <br />
<strong>Also implements the Leading Eigenvalue unidimensional method</strong> <br />
Christensen, A. P., Garrido, L. E., Pena, K. G., &amp; Golino, H. (2023).
Comparing community detection algorithms in psychological data: A Monte Carlo simulation.
<em>Behavior Research Methods</em>.
</p>
<p><strong>Comprehensive unidimensionality simulation</strong> <br />
Christensen, A. P. (2023).
Unidimensional community detection: A Monte Carlo simulation, grid search, and comparison.
<em>PsyArXiv</em>.
</p>
<p><strong>Compared all</strong> <code><a href="igraph.html#topic+igraph">igraph</a></code> <strong>community detection algorithms, simulation with continuous and polytomous data</strong> <br />
Christensen, A. P., Garrido, L. E., Guerra-Pena, K., &amp; Golino, H. (2023).
Comparing community detection algorithms in psychometric networks: A Monte Carlo simulation.
<em>Behavior Research Methods</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.EGAnet">plot.EGAnet</a></code> for plot usage in <code><a href="#topic+EGAnet">EGAnet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Obtain data
wmt &lt;- wmt2[,7:24]

# Estimate EGA
ega.wmt &lt;- EGA(
  data = wmt,
  plot.EGA = FALSE # No plot for CRAN checks
)

# Print results
print(ega.wmt)

# Estimate EGAtmfg
ega.wmt.tmfg &lt;- EGA(
  data = wmt, model = "TMFG",
  plot.EGA = FALSE # No plot for CRAN checks
)

# Estimate EGA with Louvain algorithm
ega.wmt.louvain &lt;- EGA(
  data = wmt, algorithm = "louvain",
  plot.EGA = FALSE # No plot for CRAN checks
)

# Estimate EGA with an {igraph} function (Fast-greedy)
ega.wmt.greedy &lt;- EGA(
  data = wmt,
  algorithm = igraph::cluster_fast_greedy,
  plot.EGA = FALSE # No plot for CRAN checks
)

</code></pre>

<hr>
<h2 id='EGA.estimate'>Estimates <code><a href="#topic+EGA">EGA</a></code> for Multidimensional Structures</h2><span id='topic+EGA.estimate'></span>

<h3>Description</h3>

<p>A basic function to estimate <code><a href="#topic+EGA">EGA</a></code> for multidimensional structures.
This function does <em>not</em> include the unidimensional check and it does not
plot the results. This function can be used as a streamlined approach
for quick <code><a href="#topic+EGA">EGA</a></code> estimation when unidimensionality or visualization
is not a priority
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EGA.estimate(
  data,
  n = NULL,
  corr = c("auto", "cor_auto", "pearson", "spearman"),
  na.data = c("pairwise", "listwise"),
  model = c("BGGM", "glasso", "TMFG"),
  algorithm = c("leiden", "louvain", "walktrap"),
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EGA.estimate_+3A_data">data</code></td>
<td>
<p>Matrix or data frame.
Should consist only of variables to be used in the analysis</p>
</td></tr>
<tr><td><code id="EGA.estimate_+3A_n">n</code></td>
<td>
<p>Numeric (length = 1).
Sample size if <code>data</code> provided is a correlation matrix</p>
</td></tr>
<tr><td><code id="EGA.estimate_+3A_corr">corr</code></td>
<td>
<p>Character (length = 1).
Method to compute correlations.
Defaults to <code>"auto"</code>.
Available options:
</p>

<ul>
<li> <p><code>"auto"</code> &mdash; Automatically computes appropriate correlations for
the data using Pearson's for continuous, polychoric for ordinal,
tetrachoric for binary, and polyserial/biserial for ordinal/binary with
continuous. To change the number of categories that are considered
ordinal, use <code>ordinal.categories</code>
(see <code><a href="#topic+polychoric.matrix">polychoric.matrix</a></code> for more details)
</p>
</li>
<li> <p><code>"cor_auto"</code> &mdash; Uses <code><a href="qgraph.html#topic+cor_auto">cor_auto</a></code> to compute correlations. 
Arguments can be passed along to the function
</p>
</li>
<li> <p><code>"pearson"</code> &mdash; Pearson's correlation is computed for all 
variables regardless of categories
</p>
</li>
<li> <p><code>"spearman"</code> &mdash; Spearman's rank-order correlation is computed 
for all variables regardless of categories
</p>
</li></ul>

<p>For other similarity measures, compute them first and input them
into <code>data</code> with the sample size (<code>n</code>)</p>
</td></tr>
<tr><td><code id="EGA.estimate_+3A_na.data">na.data</code></td>
<td>
<p>Character (length = 1).
How should missing data be handled?
Defaults to <code>"pairwise"</code>.
Available options:
</p>

<ul>
<li> <p><code>"pairwise"</code> &mdash; Computes correlation for all available cases between
two variables
</p>
</li>
<li> <p><code>"listwise"</code> &mdash; Computes correlation for all complete cases in the dataset
</p>
</li></ul>
</td></tr>
<tr><td><code id="EGA.estimate_+3A_model">model</code></td>
<td>
<p>Character (length = 1).
Defaults to <code>"glasso"</code>.
Available options:
</p>

<ul>
<li> <p><code>"BGGM"</code> &mdash; Computes the Bayesian Gaussian Graphical Model.
Set argument <code>ordinal.categories</code> to determine
levels allowed for a variable to be considered ordinal.
See <code>?BGGM::estimate</code> for more details
</p>
</li>
<li> <p><code>"glasso"</code> &mdash; Computes the GLASSO with EBIC model selection.
See <code><a href="#topic+EBICglasso.qgraph">EBICglasso.qgraph</a></code> for more details
</p>
</li>
<li> <p><code>"TMFG"</code> &mdash; Computes the TMFG method.
See <code><a href="#topic+TMFG">TMFG</a></code> for more details
</p>
</li></ul>
</td></tr>
<tr><td><code id="EGA.estimate_+3A_algorithm">algorithm</code></td>
<td>
<p>Character or 
<code><a href="igraph.html#topic+igraph">igraph</a></code> <code>cluster_*</code> function (length = 1).
Defaults to <code>"walktrap"</code>.
Three options are listed below but all are available
(see <code><a href="#topic+community.detection">community.detection</a></code> for other options):
</p>

<ul>
<li> <p><code>"leiden"</code> &mdash; See <code><a href="igraph.html#topic+cluster_leiden">cluster_leiden</a></code> for more details
</p>
</li>
<li> <p><code>"louvain"</code> &mdash; By default, <code>"louvain"</code> will implement the Louvain algorithm using 
the consensus clustering method (see <code><a href="#topic+community.consensus">community.consensus</a></code> 
for more information). This function will implement
<code>consensus.method = "most_common"</code> and <code>consensus.iter = 1000</code> 
unless specified otherwise
</p>
</li>
<li> <p><code>"walktrap"</code> &mdash; See <code><a href="igraph.html#topic+cluster_walktrap">cluster_walktrap</a></code> for more details
</p>
</li></ul>
</td></tr>
<tr><td><code id="EGA.estimate_+3A_verbose">verbose</code></td>
<td>
<p>Boolean (length = 1).
Whether messages and (insignificant) warnings should be output.
Defaults to <code>FALSE</code> (silent calls).
Set to <code>TRUE</code> to see all messages and warnings for every function call</p>
</td></tr>
<tr><td><code id="EGA.estimate_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed on to
<code><a href="#topic+auto.correlate">auto.correlate</a></code>, 
<code><a href="#topic+network.estimation">network.estimation</a></code>,
<code><a href="#topic+community.detection">community.detection</a></code>, and
<code><a href="#topic+community.consensus">community.consensus</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing:
</p>
<table>
<tr><td><code>network</code></td>
<td>
<p>A matrix containing a network estimated using 
<code>link[EGAnet]{network.estimation}</code></p>
</td></tr>
<tr><td><code>wc</code></td>
<td>
<p>A vector representing the community (dimension) membership
of each node in the network. <code>NA</code> values mean that the node
was disconnected from the network</p>
</td></tr>
<tr><td><code>n.dim</code></td>
<td>
<p>A scalar of how many total dimensions were identified in the network</p>
</td></tr>
<tr><td><code>cor.data</code></td>
<td>
<p>The zero-order correlation matrix</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>Number of cases in <code>data</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alexander P. Christensen &lt;alexpaulchristensen at gmail.com&gt; and Hudson Golino &lt;hfg9s at virginia.edu&gt;
</p>


<h3>References</h3>

<p><strong>Original simulation and implementation of EGA</strong> <br />
Golino, H. F., &amp; Epskamp, S. (2017).
Exploratory graph analysis: A new approach for estimating the number of dimensions in psychological research.
<em>PLoS ONE</em>, <em>12</em>, e0174035.
</p>
<p><strong>Introduced unidimensional checks, simulation with continuous and dichotomous data</strong> <br />
Golino, H., Shi, D., Christensen, A. P., Garrido, L. E., Nieto, M. D., Sadana, R., &amp; Thiyagarajan, J. A. (2020).
Investigating the performance of Exploratory Graph Analysis and traditional techniques to identify the number of latent factors: A simulation and tutorial.
<em>Psychological Methods</em>, <em>25</em>, 292-320.
</p>
<p><strong>Compared all</strong> <code><a href="igraph.html#topic+igraph">igraph</a></code> <strong>community detection algorithms, simulation with continuous and polytomous data</strong> <br />
Christensen, A. P., Garrido, L. E., Guerra-Pena, K., &amp; Golino, H. (2023).
Comparing community detection algorithms in psychometric networks: A Monte Carlo simulation.
<em>Behavior Research Methods</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.EGAnet">plot.EGAnet</a></code> for plot usage in <code><a href="#topic+EGAnet">EGAnet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Obtain data
wmt &lt;- wmt2[,7:24]

# Estimate EGA
ega.wmt &lt;- EGA.estimate(data = wmt)

# Estimate EGA with TMFG
ega.wmt.tmfg &lt;- EGA.estimate(data = wmt, model = "TMFG")

# Estimate EGA with an {igraph} function (Fast-greedy)
ega.wmt.greedy &lt;- EGA.estimate(
  data = wmt,
  algorithm = igraph::cluster_fast_greedy
)

</code></pre>

<hr>
<h2 id='EGA.fit'><code><a href="#topic+EGA">EGA</a></code> Optimal Model Fit using the Total Entropy Fit Index  (<code><a href="#topic+tefi">tefi</a></code>)</h2><span id='topic+EGA.fit'></span>

<h3>Description</h3>

<p>Estimates the best fitting model using <code><a href="#topic+EGA">EGA</a></code>.
The number of steps in the <code><a href="igraph.html#topic+cluster_walktrap">cluster_walktrap</a></code> detection
algorithm is varied and unique community solutions are compared using
<code><a href="#topic+tefi">tefi</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EGA.fit(
  data,
  n = NULL,
  corr = c("auto", "cor_auto", "pearson", "spearman"),
  na.data = c("pairwise", "listwise"),
  model = c("BGGM", "glasso", "TMFG"),
  algorithm = c("leiden", "louvain", "walktrap"),
  plot.EGA = TRUE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EGA.fit_+3A_data">data</code></td>
<td>
<p>Matrix or data frame.
Should consist only of variables to be used in the analysis</p>
</td></tr>
<tr><td><code id="EGA.fit_+3A_n">n</code></td>
<td>
<p>Numeric (length = 1).
Sample size if <code>data</code> is a correlation matrix</p>
</td></tr>
<tr><td><code id="EGA.fit_+3A_corr">corr</code></td>
<td>
<p>Character (length = 1).
Method to compute correlations.
Defaults to <code>"auto"</code>.
Available options:
</p>

<ul>
<li> <p><code>"auto"</code> &mdash; Automatically computes appropriate correlations for
the data using Pearson's for continuous, polychoric for ordinal,
tetrachoric for binary, and polyserial/biserial for ordinal/binary with
continuous. To change the number of categories that are considered
ordinal, use <code>ordinal.categories</code>
(see <code><a href="#topic+polychoric.matrix">polychoric.matrix</a></code> for more details)
</p>
</li>
<li> <p><code>"cor_auto"</code> &mdash; Uses <code><a href="qgraph.html#topic+cor_auto">cor_auto</a></code> to compute correlations.
Arguments can be passed along to the function
</p>
</li>
<li> <p><code>"pearson"</code> &mdash; Pearson's correlation is computed for all
variables regardless of categories
</p>
</li>
<li> <p><code>"spearman"</code> &mdash; Spearman's rank-order correlation is computed
for all variables regardless of categories
</p>
</li></ul>

<p>For other similarity measures, compute them first and input them
into <code>data</code> with the sample size (<code>n</code>)</p>
</td></tr>
<tr><td><code id="EGA.fit_+3A_na.data">na.data</code></td>
<td>
<p>Character (length = 1).
How should missing data be handled?
Defaults to <code>"pairwise"</code>.
Available options:
</p>

<ul>
<li> <p><code>"pairwise"</code> &mdash; Computes correlation for all available cases between
two variables
</p>
</li>
<li> <p><code>"listwise"</code> &mdash; Computes correlation for all complete cases in the dataset
</p>
</li></ul>
</td></tr>
<tr><td><code id="EGA.fit_+3A_model">model</code></td>
<td>
<p>Character (length = 1).
Defaults to <code>"glasso"</code>.
Available options:
</p>

<ul>
<li> <p><code>"BGGM"</code> &mdash; Computes the Bayesian Gaussian Graphical Model.
Set argument <code>ordinal.categories</code> to determine
levels allowed for a variable to be considered ordinal.
See <code>?BGGM::estimate</code> for more details
</p>
</li>
<li> <p><code>"glasso"</code> &mdash; Computes the GLASSO with EBIC model selection.
See <code><a href="#topic+EBICglasso.qgraph">EBICglasso.qgraph</a></code> for more details
</p>
</li>
<li> <p><code>"TMFG"</code> &mdash; Computes the TMFG method.
See <code><a href="#topic+TMFG">TMFG</a></code> for more details
</p>
</li></ul>
</td></tr>
<tr><td><code id="EGA.fit_+3A_algorithm">algorithm</code></td>
<td>
<p>Character or <code><a href="igraph.html#topic+igraph">igraph</a></code> <code>cluster_*</code> function.
Three options are listed below but all are available
(see <code><a href="#topic+community.detection">community.detection</a></code> for other options):
</p>

<ul>
<li> <p><code>"leiden"</code> &mdash; See <code><a href="igraph.html#topic+cluster_leiden">cluster_leiden</a></code> for more details.
<em>Note</em>: The Leiden algorithm will default to the
Constant Potts Model objective function
(<code>objective_function = "CPM"</code>). Set
<code>objective_function = "modularity"</code> to use
modularity instead (see examples). By default, searches along
resolutions from 0 to <code>max(abs(network))</code> or the maximum
absolute edge weight in the network in 0.01 increments
(<code>resolution_parameter = seq.int(0, max(abs(network)), 0.01)</code>).
For modularity, searches along resolutions from 0 to 2 in 0.05 increments
(<code>resolution_parameter = seq.int(0, 2, 0.05)</code>) by default.
Use the argument <code>resolution_parameter</code> to change the search parameters
(see examples)
</p>
</li>
<li> <p><code>"louvain"</code> &mdash; See <code><a href="#topic+community.consensus">community.consensus</a></code> for more details.
By default, searches along resolutions from 0 to 2 in 0.05 increments
(<code>resolution_parameter = seq.int(0, 2, 0.05)</code>). Use the argument <code>resolution_parameter</code>
to change the search parameters (see examples)
</p>
</li>
<li> <p><code>"walktrap"</code> &mdash; This algorithm is the default. See <code><a href="igraph.html#topic+cluster_walktrap">cluster_walktrap</a></code> for more details.
By default, searches along 3 to 8 steps (<code>steps = 3:8</code>). Use the argument <code>steps</code>
to change the search parameters (see examples)
</p>
</li></ul>
</td></tr>
<tr><td><code id="EGA.fit_+3A_plot.ega">plot.EGA</code></td>
<td>
<p>Boolean.
If <code>TRUE</code>, returns a plot of the network and its estimated dimensions.
Defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="EGA.fit_+3A_verbose">verbose</code></td>
<td>
<p>Boolean.
Whether messages and (insignificant) warnings should be output.
Defaults to <code>FALSE</code> (silent calls).
Set to <code>TRUE</code> to see all messages and warnings for every function call</p>
</td></tr>
<tr><td><code id="EGA.fit_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed on to
<code><a href="#topic+auto.correlate">auto.correlate</a></code>, <code><a href="#topic+network.estimation">network.estimation</a></code>,
<code><a href="#topic+community.detection">community.detection</a></code>, <code><a href="#topic+community.consensus">community.consensus</a></code>,
and <code><a href="#topic+EGA.estimate">EGA.estimate</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing:
</p>
<table>
<tr><td><code>EGA</code></td>
<td>
<p><code><a href="#topic+EGA">EGA</a></code> results of the best fitting solution</p>
</td></tr>
<tr><td><code>EntropyFit</code></td>
<td>
<p><code><a href="#topic+tefi">tefi</a></code> fit values for each solution</p>
</td></tr>
<tr><td><code>Lowest.EntropyFit</code></td>
<td>
<p>The best fitting solution based on <code><a href="#topic+tefi">tefi</a></code></p>
</td></tr>
<tr><td><code>parameter.space</code></td>
<td>
<p>Parameter values used in search space</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hudson Golino &lt;hfg9s at virginia.edu&gt; and Alexander P. Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>References</h3>

<p><strong>Entropy fit measures</strong> <br />
Golino, H., Moulder, R. G., Shi, D., Christensen, A. P., Garrido, L. E., Neito, M. D., Nesselroade, J., Sadana, R., Thiyagarajan, J. A., &amp; Boker, S. M. (in press).
Entropy fit indices: New fit measures for assessing the structure and dimensionality of multiple latent variables.
<em>Multivariate Behavioral Research</em>.
</p>
<p><strong>Simulation for EGA.fit</strong> <br />
Jamison, L., Christensen, A. P., &amp; Golino, H. (under review).
Optimizing Walktrap's community detection in networks using the Total Entropy Fit Index.
<em>PsyArXiv</em>.
</p>
<p><strong>Leiden algorithm</strong> <br />
Traag, V. A., Waltman, L., &amp; Van Eck, N. J. (2019).
From Louvain to Leiden: guaranteeing well-connected communities.
<em>Scientific Reports</em>, <em>9</em>(1), 1-12.
</p>
<p><strong>Louvain algorithm</strong> <br />
Blondel, V. D., Guillaume, J. L., Lambiotte, R., &amp; Lefebvre, E. (2008).
Fast unfolding of communities in large networks.
<em>Journal of Statistical Mechanics: Theory and Experiment</em>, <em>2008</em>(10), P10008.
</p>
<p><strong>Walktrap algorithm</strong> <br />
Pons, P., &amp; Latapy, M. (2006).
Computing communities in large networks using random walks.
<em>Journal of Graph Algorithms and Applications</em>, <em>10</em>, 191-218.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.EGAnet">plot.EGAnet</a></code> for plot usage in <code><a href="#topic+EGAnet">EGAnet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
wmt &lt;- wmt2[,7:24]

# Estimate optimal EGA with Walktrap
fit.walktrap &lt;- EGA.fit(
  data = wmt, algorithm = "walktrap",
  steps = 3:8, # default
  plot.EGA = FALSE # no plot for CRAN checks
)

# Estimate optimal EGA with Leiden and CPM
fit.leiden &lt;- EGA.fit(
  data = wmt, algorithm = "leiden",
  objective_function = "CPM", # default
  # resolution_parameter = seq.int(0, max(abs(network)), 0.01),
  # For CPM, the default max resolution parameter
  # is set to the largest absolute edge in the network
  plot.EGA = FALSE # no plot for CRAN checks
)

# Estimate optimal EGA with Leiden and modularity
fit.leiden &lt;- EGA.fit(
  data = wmt, algorithm = "leiden",
  objective_function = "modularity",
  resolution_parameter = seq.int(0, 2, 0.05),
  # default for modularity
  plot.EGA = FALSE # no plot for CRAN checks
)

## Not run: 
# Estimate optimal EGA with Louvain
fit.louvain &lt;- EGA.fit(
  data = wmt, algorithm = "louvain",
  resolution_parameter = seq.int(0, 2, 0.05), # default
  plot.EGA = FALSE # no plot for CRAN checks
)
## End(Not run)

</code></pre>

<hr>
<h2 id='ega.wmt'><code><a href="#topic+EGA">EGA</a></code> Network of <code><a href="#topic+wmt2">wmt2</a></code>Data</h2><span id='topic+ega.wmt'></span>

<h3>Description</h3>

<p><code><a href="#topic+EGA">EGA</a></code> results from <code>ega.wmt &lt;- EGA(wmt2[,7:24])</code>
for the Wiener Matrizen-Test (WMT-2)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ega.wmt)
</code></pre>


<h3>Format</h3>

<p>A list with 8 objects (see <strong>Value</strong> in <code><a href="#topic+EGA">EGA</a></code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("ega.wmt")
</code></pre>

<hr>
<h2 id='EGAnet-plot'>S3 Plot Methods for <code><a href="#topic+EGAnet">EGAnet</a></code></h2><span id='topic+EGAnet-plot'></span><span id='topic+plot.EGAnet'></span>

<h3>Description</h3>

<p>General usage for plots created by <code><a href="#topic+EGAnet">EGAnet</a></code>'s S3 methods.
Plots across the <code><a href="#topic+EGAnet">EGAnet</a></code> package leverage {<a href="GGally.html#topic+GGally">GGally</a>}'s <code><a href="GGally.html#topic+ggnet2">ggnet2</a></code>
and {<a href="ggplot2.html#topic+ggplot2">ggplot2</a>}'s <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>.
</p>
<p>Most plots allow the full usage of the <code>gg*</code> series functionality and therefore
plotting arguments should be referenced through those packages rather than here in
<code><a href="#topic+EGAnet">EGAnet</a></code>.
</p>
<p>The sections below list the functions and their usage for the S3 plot methods.
The plot methods are intended to be generic and without many arguments so that
nearly all arguments are passed to <code><a href="GGally.html#topic+ggnet2">ggnet2</a></code> and <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>.
</p>
<p>There are some constraints placed on certain plots to keep the <code><a href="#topic+EGAnet">EGAnet</a></code> style
throughout the (network) plots in the package, so be aware that if some settings are
not changing your plot output, then these settings might be fixed
to maintain the <code><a href="#topic+EGAnet">EGAnet</a></code> style
</p>


<h3>General Usage</h3>

<pre>
plot(x, ...)

plot.dynEGA(x, base = 1, id = NULL, ...)

plot.dynEGA.Group(x, base = 1, ...)

plot.dynEGA.Individual(x, base = 1, id = NULL, ...)

plot.hierEGA(
  x, plot.type = c("multilevel", "separate"),
  color.match = FALSE, ...
)

plot.invariance(x, p_type = c("p", "p_BH"), p_value = 0.05, ...)
</pre>


<h3>General Arguments</h3>


<ul>
<li> <p><code>x</code> &mdash; <code><a href="#topic+EGAnet">EGAnet</a></code> object with available S3 plot method
(see full list below)
</p>
</li>
<li> <p><code>color.palette</code> &mdash; Character (vector). Either a character (length = 1) from the
pre-defined palettes in <code><a href="#topic+color_palette_EGA">color_palette_EGA</a></code>
or character (length = total number of communities) using
HEX codes (see <strong>Color Palettes</strong> and <strong>Examples</strong> sections)
</p>
</li>
<li> <p><code>layout</code> &mdash; Character (length = 1). Layouts can be set using <code><a href="sna.html#topic+gplot.layout">gplot.layout</a></code> and the
ending layout name; for example, <code>gplot.layout.circle</code> can be set
in these functions using <code>layout = "circle"</code> or <code>mode = "circle"</code>
(see <strong>Examples</strong>)
</p>
</li>
<li> <p><code>base</code> &mdash; Numeric (length = 1). Plot to be used as the base for the configuration of the networks.
Uses the number of the order in which the plots are input.
Defaults to <code>1</code> or the first plot
</p>
</li>
<li> <p><code>id</code> &mdash; Numeric index(es) or character name(s). IDs to use when plotting
<code><a href="#topic+dynEGA">dynEGA</a></code> <code>level = "individual"</code>.
Defaults to <code>NULL</code> or 4 IDs drawn at random
</p>
</li>
<li> <p><code>plot.type</code> &mdash; Character (length = 1). Whether <code><a href="#topic+hierEGA">hierEGA</a></code>
networks should plotted in a stacked, <code>"multilevel"</code> fashion
or as <code>"separate"</code> plots. Defaults to <code>"multilevel"</code>
</p>
</li>
<li> <p><code>color.match</code> &mdash; Boolean (length = 1). Whether lower order community colors in the
<code><a href="#topic+hierEGA">hierEGA</a></code> plot should be &quot;matched&quot; and used as
the border color for the higher order communities. Defaults to <code>FALSE</code>
</p>
</li>
<li> <p><code>p_type</code> &mdash; Character (length = 1). Type of <em>p</em>-value when plotting
<code><a href="#topic+invariance">invariance</a></code>. Defaults to <code>"p"</code> or
uncorrected <em>p</em>-value. Set to <code>"p_BH"</code> for the
Benjamini-Hochberg corrected <em>p</em>-value
</p>
</li>
<li> <p><code>p_value</code> &mdash; Numeric (length = 1). The <em>p</em>-value to use alongside <code>p_type</code> when
plotting <code><a href="#topic+invariance">invariance</a></code>. Defaults to <code>0.05</code>
</p>
</li>
<li> <p><code>...</code> &mdash; Additional arguments to pass on to
<code><a href="GGally.html#topic+ggnet2">ggnet2</a></code> and <code><a href="sna.html#topic+gplot.layout">gplot.layout</a></code>
(see <strong>Examples</strong>)
</p>
</li></ul>



<h3><code>*EGA</code> Plots</h3>

<p><code><a href="#topic+bootEGA">bootEGA</a></code>, <code><a href="#topic+dynEGA">dynEGA</a></code>,
<code><a href="#topic+EGA">EGA</a></code>, <code><a href="#topic+EGA.estimate">EGA.estimate</a></code>,
<code><a href="#topic+EGA.fit">EGA.fit</a></code>, <code><a href="#topic+hierEGA">hierEGA</a></code>,
<code><a href="#topic+invariance">invariance</a></code>, <code><a href="#topic+riEGA">riEGA</a></code>
</p>


<h3>All Available S3 Plot Methods</h3>

<p><code><a href="#topic+boot.ergoInfo">boot.ergoInfo</a></code>, <code><a href="#topic+bootEGA">bootEGA</a></code>,
<code><a href="#topic+dynEGA">dynEGA</a></code>, <code>dynEGA.Group</code>, <code>dynEGA.Individual</code>,
<code>dynEGA.Population</code>, <code><a href="#topic+EGA">EGA</a></code>,
<code><a href="#topic+EGA.estimate">EGA.estimate</a></code>, <code><a href="#topic+EGA.fit">EGA.fit</a></code>,
<code><a href="#topic+hierEGA">hierEGA</a></code>, <code><a href="#topic+infoCluster">infoCluster</a></code>,
<code><a href="#topic+invariance">invariance</a></code>, <code><a href="#topic+itemStability">itemStability</a></code>,
<code><a href="#topic+riEGA">riEGA</a></code>
</p>


<h3>Color Palettes</h3>

<p><code><a href="#topic+color_palette_EGA">color_palette_EGA</a></code> will implement some color palettes in
<code><a href="#topic+EGAnet">EGAnet</a></code>. The main <code><a href="#topic+EGAnet">EGAnet</a></code> style palette is <code>"polychrome"</code>.
This palette currently has 40 colors but there will likely be a need to expand it further
(e.g., <code><a href="#topic+hierEGA">hierEGA</a></code> demands a lot of colors).
</p>
<p>The <code>color.palette</code> argument will also accept HEX code colors that
are the same length as the number of communities in the plot.
</p>
<p>In any network plots, the <code>color.palette</code> argument can be used to
select color palettes from <code><a href="#topic+color_palette_EGA">color_palette_EGA</a></code> as well
as those in the color scheme of <code><a href="RColorBrewer.html#topic+RColorBrewer">RColorBrewer</a></code>
</p>
<p><em>For more worked examples than below, see <a href="https://r-ega.net/articles/plotting.html">Plots in {EGAnet}</a></em>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Using different arguments in {GGally}'s `ggnet2`
plot(ega.wmt, node.size = 6, edge.size = 4)

# Using a different layout in {sna}'s `gplot.layout`
plot(ega.wmt, layout = "circle") # 'layout' argument
plot(ega.wmt, mode = "circle") # 'mode' argument

# Using different color palettes with `color_palette_EGA`

## Pre-defined palette
plot(ega.wmt, color.palette = "blue.ridge2")

## University of Virginia colors
plot(ega.wmt, color.palette = c("#232D4B", "#F84C1E"))

## Vanderbilt University colors
## (with additional {GGally} `ggnet2` argument)
plot(
  ega.wmt, color.palette = c("#FFFFFF", "#866D4B"),
  label.color = "#000000"
)

</code></pre>

<hr>
<h2 id='Embed'>Time-delay Embedding</h2><span id='topic+Embed'></span>

<h3>Description</h3>

<p>Reorganizes a single observed time series into an embedded matrix. The embedded 
matrix is constructed with replicates of an individual time series that are offset from 
each other in time. The function requires two parameters, one that specifies the number 
of observations to be used (i.e., the number of embedded dimensions) and the other that 
specifies the number of observations to offset successive embeddings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Embed(x, E, tau)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Embed_+3A_x">x</code></td>
<td>
<p>Numeric vector.
An observed time series to be reorganized into a time-delayed embedded matrix.</p>
</td></tr>
<tr><td><code id="Embed_+3A_e">E</code></td>
<td>
<p>Numeric (length = 1).
Number of embedded dimensions or the number of observations to 
be used. <code>E = 5</code>, for example, will generate a matrix with 
five columns corresponding to five consecutive observations across
each row of the embedded matrix</p>
</td></tr>
<tr><td><code id="Embed_+3A_tau">tau</code></td>
<td>
<p>Numeric (length = 1).
Number of observations to offset successive embeddings. 
A tau of one uses adjacent observations.
Default is <code>tau = 1</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numeric matrix
</p>


<h3>Author(s)</h3>

<p>Pascal Deboeck &lt;pascal.deboeck at psych.utah.edu&gt; and Alexander P. Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>References</h3>

<p>Deboeck, P. R., Montpetit, M. A., Bergeman, C. S., &amp; Boker, S. M. (2009)
Using derivative estimates to describe intraindividual variability at multiple time scales.
<em>Psychological Methods</em>, <em>14</em>, 367-386.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A time series with 8 time points
time_series &lt;- 49:56

# Time series embedding
Embed(time_series, E = 5, tau = 1)

</code></pre>

<hr>
<h2 id='entropyFit'>Entropy Fit Index</h2><span id='topic+entropyFit'></span>

<h3>Description</h3>

<p>Computes the fit of a dimensionality structure using empirical entropy.
Lower values suggest better fit of a structure to the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>entropyFit(data, structure)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="entropyFit_+3A_data">data</code></td>
<td>
<p>Matrix or data frame.
Contains variables to be used in the analysis</p>
</td></tr>
<tr><td><code id="entropyFit_+3A_structure">structure</code></td>
<td>
<p>Numeric or character vector (length = <code>ncol(data)</code>).
A vector representing the structure (numbers or labels for each item).
Can be theoretical factors or the structure detected by <code><a href="#topic+EGA">EGA</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing:
</p>
<table>
<tr><td><code>Total.Correlation</code></td>
<td>
<p>The total correlation of the dataset</p>
</td></tr>
<tr><td><code>Total.Correlation.MM</code></td>
<td>
<p>Miller-Madow correction for the total correlation of the dataset</p>
</td></tr>
<tr><td><code>Entropy.Fit</code></td>
<td>
<p>The Entropy Fit Index</p>
</td></tr>
<tr><td><code>Entropy.Fit.MM</code></td>
<td>
<p>Miller-Madow correction for the Entropy Fit Index</p>
</td></tr>
<tr><td><code>Average.Entropy</code></td>
<td>
<p>The average entropy of the dataset</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hudson F. Golino &lt;hfg9s at virginia.edu&gt;, Alexander P. Christensen &lt;alexpaulchristensen@gmail.com&gt; and Robert Moulder &lt;rgm4fd@virginia.edu&gt;
</p>


<h3>References</h3>

<p><strong>Initial formalization and simulation</strong> <br />
Golino, H., Moulder, R. G., Shi, D., Christensen, A. P., Garrido, L. E., Nieto, M. D., Nesselroade, J., Sadana, R., Thiyagarajan, J. A., &amp; Boker, S. M. (2020).
Entropy fit indices: New fit measures for assessing the structure and dimensionality of multiple latent variables.
<em>Multivariate Behavioral Research</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
wmt &lt;- wmt2[,7:24]

## Not run: 
# Estimate EGA model
ega.wmt &lt;- EGA(data = wmt)
## End(Not run)

# Compute entropy indices
entropyFit(data = wmt, structure = ega.wmt$wc)

</code></pre>

<hr>
<h2 id='ergoInfo'>Ergodicity Information Index</h2><span id='topic+ergoInfo'></span>

<h3>Description</h3>

<p>Computes the Ergodicity Information Index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ergoInfo(
  dynEGA.object,
  use = c("edge.list", "unweighted", "weighted"),
  shuffles = 5000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ergoInfo_+3A_dynega.object">dynEGA.object</code></td>
<td>
<p>A <code><a href="#topic+dynEGA.ind.pop">dynEGA.ind.pop</a></code> object</p>
</td></tr>
<tr><td><code id="ergoInfo_+3A_use">use</code></td>
<td>
<p>Character (length = 1).
A string indicating what network element will be used
to compute the algorithm complexity, the list of edges or the weights of the network.
Defaults to <code>use = "unweighted"</code>.
Current options are:
</p>

<ul>
<li> <p><code>"edge.list"</code> &mdash; Calculates the algorithm complexity using the list of edges
</p>
</li>
<li> <p><code>"unweighted"</code> &mdash; Calculates the algorithm complexity using the binary weights of the encoded prime 
transformed network. 0 = edge absent and 1 = edge present
</p>
</li>
<li> <p><code>"weighted"</code> &mdash; Calculates the algorithm complexity using the weights of encoded prime-weight transformed network
</p>
</li></ul>
</td></tr>
<tr><td><code id="ergoInfo_+3A_shuffles">shuffles</code></td>
<td>
<p>Numeric.
Number of shuffles used to compute the Kolmogorov complexity.
Defaults to <code>5000</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing:
</p>
<table>
<tr><td><code>PrimeWeight</code></td>
<td>
<p>The prime-weight encoding of the individual networks</p>
</td></tr>
<tr><td><code>PrimeWeight.pop</code></td>
<td>
<p>The prime-weight encoding of the population network</p>
</td></tr>
<tr><td><code>Kcomp</code></td>
<td>
<p>The Kolmogorov complexity of the prime-weight encoded individual networks</p>
</td></tr>
<tr><td><code>Kcomp.pop</code></td>
<td>
<p>The Kolmogorov complexity of the prime-weight encoded population network</p>
</td></tr>
<tr><td><code>complexity</code></td>
<td>
<p>The complexity metric proposed by Santora and Nicosia (2020)</p>
</td></tr>
<tr><td><code>EII</code></td>
<td>
<p>The Ergodicity Information Index</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hudson Golino &lt;hfg9s at virginia.edu&gt; and Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>References</h3>

<p><strong>Original Implementation</strong> <br />
Golino, H., Nesselroade, J. R., &amp; Christensen, A. P. (2022).
Toward a psychology of individuals: The ergodicity information index and a bottom-up approach for finding generalizations.
<em>PsyArXiv</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Obtain data
sim.dynEGA &lt;- sim.dynEGA # bypasses CRAN checks

## Not run: 
# Dynamic EGA individual and population structure
dyn.ega1 &lt;- dynEGA.ind.pop(
  data = sim.dynEGA[,-26], n.embed = 5, tau = 1,
  delta = 1, id = 25, use.derivatives = 1,
  ncores = 2, corr = "pearson"
)

# Compute empirical ergodicity information index
eii &lt;- ergoInfo(dyn.ega1)
## End(Not run)

</code></pre>

<hr>
<h2 id='genTEFI'>Generalized Total Entropy Fit Index using Von Neumman's entropy (Quantum Information Theory) for correlation matrices</h2><span id='topic+genTEFI'></span>

<h3>Description</h3>

<p>Computes the fit (Generalized TEFI) of a hierarchical or correlated bifactor 
dimensionality structure (or <code><a href="#topic+hierEGA">hierEGA</a></code> objects) using Von Neumman's entropy 
when the input is a correlation matrix. Lower values suggest better fit of a structure to the data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genTEFI(data, structure = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genTEFI_+3A_data">data</code></td>
<td>
<p>Matrix, data frame, or <code><a href="#topic+hierEGA">hierEGA</a></code> object.
Can be raw data or correlation matrix</p>
</td></tr>
<tr><td><code id="genTEFI_+3A_structure">structure</code></td>
<td>
<p>For high-order and correlated bifactor structures,
<code>structure</code> should be a list containing:
</p>

<ul>
<li> <p><code>lower_order</code> &mdash; A vector (length = <code>ncol(data)</code>) representing the first-order structure 
(numbers or labels for each item in each first-order factor or community)
</p>
</li>
<li> <p><code>higher_order</code> &mdash; A vector (length = <code>ncol(data)</code> or number of <code>lower_order</code> communities)representing 
the second-order structure (numbers or labels for each item in each second-order 
factor or community)
</p>
</li></ul>
</td></tr>
<tr><td><code id="genTEFI_+3A_verbose">verbose</code></td>
<td>
<p>Boolean (length = 1).
Whether messages and (insignificant) warnings should be output.
Defaults to <code>TRUE</code> to see all messages and warnings for every 
function call.
Set to <code>FALSE</code> to ignore messages and warnings</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a three-column data frame of the Generalized Total Entropy 
Fit Index using Von Neumman's entropy (<code>VN.Entropy.Fit</code>) (first column), as well as
<code>Lower.Order.VN</code> - TEFI for the first-order factors (second column), and
<code>Higher.Order.VN</code>, the equivalent for the second-order factors.
</p>


<h3>Author(s)</h3>

<p>Hudson Golino &lt;hfg9s at virginia.edu&gt; and Alexander P. Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example using network scores
opt.hier &lt;- hierEGA(
  data = optimism, scores = "network",
  plot.EGA = FALSE # No plot for CRAN checks
)

# Compute the Generalized Total Entropy Fit Index
genTEFI(opt.hier)

</code></pre>

<hr>
<h2 id='glla'>Generalized Local Linear Approximation</h2><span id='topic+glla'></span>

<h3>Description</h3>

<p>Estimates the derivatives of a time series using generalized 
local linear approximation (GLLA). GLLA is a filtering method for 
estimating derivatives from data that uses time delay embedding and a 
variant of Savitzky-Golay filtering to accomplish the task.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glla(x, n.embed, tau, delta, order)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glla_+3A_x">x</code></td>
<td>
<p>Numeric vector.
An observed time series</p>
</td></tr>
<tr><td><code id="glla_+3A_n.embed">n.embed</code></td>
<td>
<p>Numeric (length = 1).
Number of embedded dimensions (the number of observations 
to be used in the <code><a href="#topic+Embed">Embed</a></code> function)</p>
</td></tr>
<tr><td><code id="glla_+3A_tau">tau</code></td>
<td>
<p>Numeric (length = 1).
Number of observations to offset successive embeddings in 
the <code><a href="#topic+Embed">Embed</a></code> function. A <code>tau</code> of one 
uses adjacent observations.
Default is <code>1</code></p>
</td></tr>
<tr><td><code id="glla_+3A_delta">delta</code></td>
<td>
<p>Numeric (length = 1).
The time between successive observations in the time series.
Default is <code>1</code></p>
</td></tr>
<tr><td><code id="glla_+3A_order">order</code></td>
<td>
<p>Numeric (length = 1).
The maximum order of the derivative to be estimated. For example,
<code>"order = 2"</code> will return a matrix with three columns with the estimates
of the observed scores and the first and second derivative for each row of the embedded
matrix (i.e. the reorganization of the time series implemented via
the <code><a href="#topic+Embed">Embed</a></code> function)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix containing <em>n</em> columns in which <em>n</em>
is one plus the maximum order of the derivatives to be estimated via 
generalized local linear approximation
</p>


<h3>Author(s)</h3>

<p>Hudson Golino &lt;hfg9s at virginia.edu&gt;
</p>


<h3>References</h3>

<p><strong>GLLA implementation</strong> <br />
Boker, S. M., Deboeck, P. R., Edler, C., &amp; Keel, P. K. (2010)
Generalized local linear approximation of derivatives from time series. In S.-M. Chow, E. Ferrer, &amp; F. Hsieh (Eds.),
<em>The Notre Dame series on quantitative methodology. Statistical methods for modeling human dynamics: An interdisciplinary dialogue</em>,
(p. 161-178). <em>Routledge/Taylor &amp; Francis Group</em>.
</p>
<p>Deboeck, P. R., Montpetit, M. A., Bergeman, C. S., &amp; Boker, S. M. (2009)
Using derivative estimates to describe intraindividual variability at multiple time scales.
<em>Psychological Methods</em>, <em>14(4)</em>, 367-386.
</p>
<p><strong>Filtering procedure</strong> <br />
Savitzky, A., &amp; Golay, M. J. (1964).
Smoothing and differentiation of data by simplified least squares procedures.
<em>Analytical Chemistry</em>, <em>36(8)</em>, 1627-1639.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A time series with 8 time points
tseries &lt;- 49:56
deriv.tseries &lt;- glla(tseries, n.embed = 4, tau = 1, delta = 1, order = 2)

</code></pre>

<hr>
<h2 id='hierEGA'>Hierarchical <code><a href="#topic+EGA">EGA</a></code></h2><span id='topic+hierEGA'></span>

<h3>Description</h3>

<p>Estimates EGA using the lower-order solution of the Louvain
algorithm (<code><a href="igraph.html#topic+cluster_louvain">cluster_louvain</a></code>)to identify the lower-order
dimensions and then uses factor or network loadings to estimate factor
or network scores, which are used to estimate the higher-order dimensions
(for more details, see JimÃ©nez et al., 2023)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hierEGA(
  data,
  loading.method = c("BRM", "experimental"),
  rotation = NULL,
  scores = c("factor", "network"),
  loading.structure = c("simple", "full"),
  impute = c("mean", "median", "none"),
  corr = c("auto", "cor_auto", "pearson", "spearman"),
  na.data = c("pairwise", "listwise"),
  model = c("BGGM", "glasso", "TMFG"),
  lower.algorithm = "louvain",
  higher.algorithm = c("leiden", "louvain", "walktrap"),
  uni.method = c("expand", "LE", "louvain"),
  plot.EGA = TRUE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hierEGA_+3A_data">data</code></td>
<td>
<p>Matrix or data frame.
Should consist only of variables to be used in the analysis
(does not accept correlation matrices)</p>
</td></tr>
<tr><td><code id="hierEGA_+3A_loading.method">loading.method</code></td>
<td>
<p>Character (length = 1).
Sets network loading calculation based on implementation
described in <code>"BRM"</code> (Christensen &amp; Golino, 2021) or
an <code>"experimental"</code> implementation.
Defaults to <code>"BRM"</code></p>
</td></tr>
<tr><td><code id="hierEGA_+3A_rotation">rotation</code></td>
<td>
<p>Character.
A rotation to use to obtain a simpler structure.
For a list of rotations, see <code><a href="GPArotation.html#topic+rotations">rotations</a></code> for options.
Defaults to <code>NULL</code> or no rotation.
By setting a rotation, <code>scores</code> estimation will be
based on the rotated loadings rather than unrotated loadings</p>
</td></tr>
<tr><td><code id="hierEGA_+3A_scores">scores</code></td>
<td>
<p>Character (length = 1).
How should scores for the higher-order structure be estimated?
Defaults to <code>"network"</code> for network scores computed using
the <code><a href="#topic+net.scores">net.scores</a></code> function.
Set to <code>"factor"</code> for factor scores computed using
<code><a href="psych.html#topic+fa">fa</a></code>. Factors scores will be based on
<strong>EFA</strong> (as in JimÃ©nez et al., 2023)
</p>
<p><em>Factor scores use the number of communities from
<code><a href="#topic+EGA">EGA</a></code>. Estimated factor loadings may
not align with these communities. The plots using factor scores
will have higher order factors that may not completely map on to
the lower order communities. Look at
<code>$hierarchical$higher_order$lower_loadings</code> to determine the
composition of the lower order factors.</em></p>
</td></tr>
<tr><td><code id="hierEGA_+3A_loading.structure">loading.structure</code></td>
<td>
<p>Character (length = 1).
Whether simple structure or the saturated loading matrix
should be used when computing scores (<code>scores = "network"</code> only).
Defaults to <code>"simple"</code>
</p>
<p><code>"simple"</code> structure more closely mirrors traditional
hierarchical factor analytic methods such as CFA; <code>"full"</code>
structure more closely mirrors EFA methods
</p>
<p>Simple structure is the more conservative (established) approach
and is therefore the default. Treat <code>"full"</code> as experimental
as proper vetting and validation has not been established</p>
</td></tr>
<tr><td><code id="hierEGA_+3A_impute">impute</code></td>
<td>
<p>Character (length = 1).
If there are any missing data, then imputation can be implemented.
Available options:
</p>

<ul>
<li> <p><code>"none"</code> &mdash; Default. No imputation is performed
</p>
</li>
<li> <p><code>"mean"</code> &mdash; The mean value of each variable is used to replace missing data
for that variable
</p>
</li>
<li> <p><code>"median"</code> &mdash; The median value of each variable is used to replace missing data
for that variable
</p>
</li></ul>
</td></tr>
<tr><td><code id="hierEGA_+3A_corr">corr</code></td>
<td>
<p>Character (length = 1).
Method to compute correlations.
Defaults to <code>"auto"</code>.
Available options:
</p>

<ul>
<li> <p><code>"auto"</code> &mdash; Automatically computes appropriate correlations for
the data using Pearson's for continuous, polychoric for ordinal,
tetrachoric for binary, and polyserial/biserial for ordinal/binary with
continuous. To change the number of categories that are considered
ordinal, use <code>ordinal.categories</code>
(see <code><a href="#topic+polychoric.matrix">polychoric.matrix</a></code> for more details)
</p>
</li>
<li> <p><code>"cor_auto"</code> &mdash; Uses <code><a href="qgraph.html#topic+cor_auto">cor_auto</a></code> to compute correlations.
Arguments can be passed along to the function
</p>
</li>
<li> <p><code>"pearson"</code> &mdash; Pearson's correlation is computed for all
variables regardless of categories
</p>
</li>
<li> <p><code>"spearman"</code> &mdash; Spearman's rank-order correlation is computed
for all variables regardless of categories
</p>
</li></ul>

<p>For other similarity measures, compute them first and input them
into <code>data</code> with the sample size (<code>n</code>)</p>
</td></tr>
<tr><td><code id="hierEGA_+3A_na.data">na.data</code></td>
<td>
<p>Character (length = 1).
How should missing data be handled?
Defaults to <code>"pairwise"</code>.
Available options:
</p>

<ul>
<li> <p><code>"pairwise"</code> &mdash; Computes correlation for all available cases between
two variables
</p>
</li>
<li> <p><code>"listwise"</code> &mdash; Computes correlation for all complete cases in the dataset
</p>
</li></ul>
</td></tr>
<tr><td><code id="hierEGA_+3A_model">model</code></td>
<td>
<p>Character (length = 1).
Defaults to <code>"glasso"</code>.
Available options:
</p>

<ul>
<li> <p><code>"BGGM"</code> &mdash; Computes the Bayesian Gaussian Graphical Model.
Set argument <code>ordinal.categories</code> to determine
levels allowed for a variable to be considered ordinal.
See <code>?BGGM::estimate</code> for more details
</p>
</li>
<li> <p><code>"glasso"</code> &mdash; Computes the GLASSO with EBIC model selection.
See <code><a href="#topic+EBICglasso.qgraph">EBICglasso.qgraph</a></code> for more details
</p>
</li>
<li> <p><code>"TMFG"</code> &mdash; Computes the TMFG method.
See <code><a href="#topic+TMFG">TMFG</a></code> for more details
</p>
</li></ul>
</td></tr>
<tr><td><code id="hierEGA_+3A_lower.algorithm">lower.algorithm</code></td>
<td>
<p>Character or
<code><a href="igraph.html#topic+igraph">igraph</a></code> <code>cluster_*</code> function (length = 1).
Defaults to the lower order <code>"louvain"</code> with most common
consensus clustering (1000 iterations; see
<code><a href="#topic+community.consensus">community.consensus</a></code> for more details)
</p>
<p>Louvain with consensus clustering is <em>strongly</em>
recommended. Using any other algorithm is considered
<em>experimental</em> as they have not been designed to
capture lower order communities</p>
</td></tr>
<tr><td><code id="hierEGA_+3A_higher.algorithm">higher.algorithm</code></td>
<td>
<p>Character or
<code><a href="igraph.html#topic+igraph">igraph</a></code> <code>cluster_*</code> function (length = 1).
Defaults to <code>"walktrap"</code>.
Three options are listed below but all are available
(see <code><a href="#topic+community.detection">community.detection</a></code> for other options):
</p>

<ul>
<li> <p><code>"leiden"</code> &mdash; See <code><a href="igraph.html#topic+cluster_leiden">cluster_leiden</a></code> for more details
</p>
</li>
<li> <p><code>"louvain"</code> &mdash; By default, <code>"louvain"</code> will implement the Louvain algorithm using
the consensus clustering method (see <code><a href="#topic+community.consensus">community.consensus</a></code>
for more information). This function will implement
<code>consensus.method = "most_common"</code> and <code>consensus.iter = 1000</code>
unless specified otherwise
</p>
</li>
<li> <p><code>"walktrap"</code> &mdash; See <code><a href="igraph.html#topic+cluster_walktrap">cluster_walktrap</a></code> for more details
</p>
</li></ul>

<p>Using <code>algorithm</code> will set only <code>higher.algorithm</code> and
<code>lower.algorithm</code> will default to Louvain with most common
consensus clustering (1000 iterations)</p>
</td></tr>
<tr><td><code id="hierEGA_+3A_uni.method">uni.method</code></td>
<td>
<p>Character (length = 1).
What unidimensionality method should be used?
Defaults to <code>"louvain"</code>.
Available options:
</p>

<ul>
<li> <p><code>"expand"</code> &mdash; Expands the correlation matrix with four variables correlated 0.50.
If number of dimension returns 2 or less in check, then the data
are unidimensional; otherwise, regular EGA with no matrix
expansion is used. This method was used in the Golino et al.'s (2020)
<em>Psychological Methods</em> simulation
</p>
</li>
<li> <p><code>"LE"</code> &mdash; Applies the Leading Eigenvector algorithm
(<code><a href="igraph.html#topic+cluster_leading_eigen">cluster_leading_eigen</a></code>)
on the empirical correlation matrix. If the number of dimensions is 1,
then the Leading Eigenvector solution is used; otherwise, regular EGA
is used. This method was used in the Christensen et al.'s (2023)
<em>Behavior Research Methods</em> simulation
</p>
</li>
<li> <p><code>"louvain"</code> &mdash; Applies the Louvain algorithm (<code><a href="igraph.html#topic+cluster_louvain">cluster_louvain</a></code>)
on the empirical correlation matrix. If the number of dimensions is 1,
then the Louvain solution is used; otherwise, regular EGA is used.
This method was validated Christensen's (2022) <em>PsyArXiv</em> simulation.
Consensus clustering can be used by specifying either
<code>"consensus.method"</code> or <code>"consensus.iter"</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="hierEGA_+3A_plot.ega">plot.EGA</code></td>
<td>
<p>Boolean.
If <code>TRUE</code>, returns a plot of the network and its estimated dimensions.
Defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="hierEGA_+3A_verbose">verbose</code></td>
<td>
<p>Boolean (length = 1).
Whether messages and (insignificant) warnings should be output.
Defaults to <code>FALSE</code> (silent calls).
Set to <code>TRUE</code> to see all messages and warnings for every function call</p>
</td></tr>
<tr><td><code id="hierEGA_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed on to
<code><a href="#topic+auto.correlate">auto.correlate</a></code>,
<code><a href="#topic+network.estimation">network.estimation</a></code>,
<code><a href="#topic+community.detection">community.detection</a></code>,
<code><a href="#topic+community.consensus">community.consensus</a></code>,
<code><a href="#topic+EGA">EGA</a></code>, and
<code><a href="GPArotation.html#topic+rotations">rotations</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of lists containing:
</p>
<table>
<tr><td><code>lower_order</code></td>
<td>
<p><code><a href="#topic+EGA">EGA</a></code> results for the lower order structure</p>
</td></tr>
<tr><td><code>higher_order</code></td>
<td>
<p><code><a href="#topic+EGA">EGA</a></code> results for the higher order structure</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>A list containing <code>lower_loadings</code> and <code>lower_scores</code>
that were used to estimate scores and the higher order <code><a href="#topic+EGA">EGA</a></code>
results, respectively</p>
</td></tr>
<tr><td><code>dim.variables</code></td>
<td>
<p>A data frame with variable names and their lower and higher
order assignments</p>
</td></tr>
<tr><td><code>TEFI</code></td>
<td>
<p>Generalized TEFI using <code><a href="#topic+tefi">tefi</a></code></p>
</td></tr>
<tr><td><code>plot.hierEGA</code></td>
<td>
<p>Plot output if <code>plot.EGA = TRUE</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marcos JimÃ©nez &lt;marcosjnezhquez@gmailcom&gt;,
Francisco J. Abad &lt;fjose.abad@uam.es&gt;,
Eduardo Garcia-Garzon &lt;egarcia@ucjc.edu&gt;,
Hudson Golino &lt;hfg9s@virginia.edu&gt;,
Alexander P. Christensen &lt;alexpaulchristensen@gmail.com&gt;, and
Luis Eduardo Garrido &lt;luisgarrido@pucmm.edu.do&gt;
</p>


<h3>References</h3>

<p><strong>Hierarchical EGA simulation</strong> <br />
JimÃ©nez, M., Abad, F. J., Garcia-Garzon, E., Golino, H., Christensen, A. P., &amp; Garrido, L. E. (2023).
Dimensionality assessment in bifactor structures with multiple general factors: A network psychometrics approach.
<em>Psychological Methods</em>.
</p>
<p><strong>Conceptual implementation</strong> <br />
Golino, H., Thiyagarajan, J. A., Sadana, R., Teles, M., Christensen, A. P., &amp; Boker, S. M. (2020).
Investigating the broad domains of intrinsic capacity, functional ability and
environment: An exploratory graph analysis approach for improving analytical
methodologies for measuring healthy aging.
<em>PsyArXiv</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.EGAnet">plot.EGAnet</a></code> for plot usage in <code><a href="#topic+EGAnet">EGAnet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example using network scores
opt.hier &lt;- hierEGA(
  data = optimism, scores = "network",
  plot.EGA = FALSE # No plot for CRAN checks
)


# Plot multilevel plot
plot(opt.hier, plot.type = "multilevel")

# Plot multilevel plot with higher order
# border color matching the corresponding
# lower order color
plot(opt.hier, color.match = TRUE)

# Plot levels separately
plot(opt.hier, plot.type = "separate")

</code></pre>

<hr>
<h2 id='igraph2matrix'>Convert <code><a href="igraph.html#topic+igraph">igraph</a></code> network to matrix</h2><span id='topic+igraph2matrix'></span>

<h3>Description</h3>

<p>Converts <code><a href="igraph.html#topic+igraph">igraph</a></code> network to matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>igraph2matrix(igraph_network, diagonal = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="igraph2matrix_+3A_igraph_network">igraph_network</code></td>
<td>
<p><code><a href="igraph.html#topic+igraph">igraph</a></code> network object</p>
</td></tr>
<tr><td><code id="igraph2matrix_+3A_diagonal">diagonal</code></td>
<td>
<p>Numeric (length = 1).
Value to be placed on the diagonal of <code>network</code>.
Defaults to <code>0</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a network in the <code><a href="igraph.html#topic+igraph">igraph</a></code> format
</p>


<h3>Author(s)</h3>

<p>Hudson Golino &lt;hfg9s at virginia.edu&gt; &amp; Alexander P. Christensen &lt;alexander.christensen at Vanderbilt.Edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Convert network to {igraph}
igraph_network &lt;- convert2igraph(ega.wmt$network)

# Convert network back to matrix
igraph2matrix(igraph_network)

</code></pre>

<hr>
<h2 id='infoCluster'>Information Theoretic Mixture Clustering for <code><a href="#topic+dynEGA">dynEGA</a></code></h2><span id='topic+infoCluster'></span>

<h3>Description</h3>

<p>Performs hierarchical clustering using Jensen-Shannon distance
followed by the Louvain algorithm with consensus clustering. The method
iteratively identifies smaller and smaller clusters until there is no
change in the clusters identified
</p>


<h3>Usage</h3>

<pre><code class='language-R'>infoCluster(dynEGA.object, plot.cluster = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="infoCluster_+3A_dynega.object">dynEGA.object</code></td>
<td>
<p>A <code><a href="#topic+dynEGA">dynEGA</a></code> or a
<code><a href="#topic+dynEGA.ind.pop">dynEGA.ind.pop</a></code> object that is used to match
the arguments of the EII object</p>
</td></tr>
<tr><td><code id="infoCluster_+3A_plot.cluster">plot.cluster</code></td>
<td>
<p>Boolean (length = 1).
Should plot of optimal and hierarchical clusters be output?
Defaults to <code>TRUE</code>.
Set to <code>FALSE</code> to not plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing:
</p>
<table>
<tr><td><code>clusters</code></td>
<td>
<p>A vector corresponding to cluster each participant belongs to</p>
</td></tr>
<tr><td><code>clusterTree</code></td>
<td>
<p>The dendogram from <code><a href="stats.html#topic+hclust">hclust</a></code> the hierarhical clustering</p>
</td></tr>
<tr><td><code>clusterPlot</code></td>
<td>
<p>Plot output from results</p>
</td></tr>
<tr><td><code>JSD</code></td>
<td>
<p>Jensen-Shannon Distance</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hudson Golino &lt;hfg9s at virginia.edu&gt; &amp; Alexander P. Christensen &lt;alexander.christensen at Vanderbilt.Edu&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.EGAnet">plot.EGAnet</a></code> for plot usage in <code><a href="#topic+EGAnet">EGAnet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Obtain data
sim.dynEGA &lt;- sim.dynEGA # bypasses CRAN checks

## Not run: 
# Dynamic EGA individual and population structure
dyn.ega1 &lt;- dynEGA.ind.pop(
  data = sim.dynEGA, n.embed = 5, tau = 1,
  delta = 1, id = 25, use.derivatives = 1,
  ncores = 2, corr = "pearson"
)

# Perform information-theoretic clustering
clust1 &lt;- infoCluster(dynEGA.object = dyn.ega1)
## End(Not run)

</code></pre>

<hr>
<h2 id='intelligenceBattery'>Intelligence Data</h2><span id='topic+intelligenceBattery'></span>

<h3>Description</h3>

<p>A response matrix (n = 1152) of the International Cognitive Ability Resource (ICAR)
intelligence battery developed by Condon and Revelle (2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(intelligenceBattery)
</code></pre>


<h3>Format</h3>

<p>A 1185x125 response matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("intelligenceBattery")

</code></pre>

<hr>
<h2 id='invariance'>Measurement Invariance of <code><a href="#topic+EGA">EGA</a></code> Structure</h2><span id='topic+invariance'></span>

<h3>Description</h3>

<p>Estimates configural invariance using <code><a href="#topic+bootEGA">bootEGA</a></code>
on all data (across groups) first. After configural variance is established,
then metric invariance is tested using the community structure that established
configural invariance (see <strong>Details</strong> for more information on this process)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invariance(
  data,
  groups,
  structure = NULL,
  iter = 500,
  configural.threshold = 0.7,
  configural.type = c("parametric", "resampling"),
  corr = c("auto", "cor_auto", "pearson", "spearman"),
  na.data = c("pairwise", "listwise"),
  model = c("BGGM", "glasso", "TMFG"),
  algorithm = c("leiden", "louvain", "walktrap"),
  uni.method = c("expand", "LE", "louvain"),
  ncores,
  seed = NULL,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invariance_+3A_data">data</code></td>
<td>
<p>Matrix or data frame.
Should consist only of variables to be used in the analysis</p>
</td></tr>
<tr><td><code id="invariance_+3A_groups">groups</code></td>
<td>
<p>Numeric or character vector (length = <code>nrow(data)</code>).
Group membership corresponding to each case in data</p>
</td></tr>
<tr><td><code id="invariance_+3A_structure">structure</code></td>
<td>
<p>Numeric or character vector (length = <code>ncol(data)</code>).
A vector representing the structure (numbers or labels for each item).
Can be theoretical factors or the structure detected by <code><a href="#topic+EGA">EGA</a></code>.
If supplied, then configural invariance check is skipped (i.e., configural
invariance is assumed based on the given structure)</p>
</td></tr>
<tr><td><code id="invariance_+3A_iter">iter</code></td>
<td>
<p>Numeric (length = 1).
Number of iterations to perform for the permutation.
Defaults to <code>500</code> (recommended)</p>
</td></tr>
<tr><td><code id="invariance_+3A_configural.threshold">configural.threshold</code></td>
<td>
<p>Numeric (length = 1).
Value to use a threshold in <code><a href="#topic+itemStability">itemStability</a></code> to determine
which items should be removed during configural invariance (see <strong>Details</strong>
for more information).
Defaults to <code>0.70</code> (recommended)</p>
</td></tr>
<tr><td><code id="invariance_+3A_configural.type">configural.type</code></td>
<td>
<p>Character (length = 1).
Type of bootstrap to use for configural invariance in <code><a href="#topic+bootEGA">bootEGA</a></code>.
Defaults to <code>"parametric"</code></p>
</td></tr>
<tr><td><code id="invariance_+3A_corr">corr</code></td>
<td>
<p>Character (length = 1).
Method to compute correlations.
Defaults to <code>"auto"</code>.
Available options:
</p>

<ul>
<li> <p><code>"auto"</code> &mdash; Automatically computes appropriate correlations for
the data using Pearson's for continuous, polychoric for ordinal,
tetrachoric for binary, and polyserial/biserial for ordinal/binary with
continuous. To change the number of categories that are considered
ordinal, use <code>ordinal.categories</code>
(see <code><a href="#topic+polychoric.matrix">polychoric.matrix</a></code> for more details)
</p>
</li>
<li> <p><code>"cor_auto"</code> &mdash; Uses <code><a href="qgraph.html#topic+cor_auto">cor_auto</a></code> to compute correlations.
Arguments can be passed along to the function
</p>
</li>
<li> <p><code>"pearson"</code> &mdash; Pearson's correlation is computed for all
variables regardless of categories
</p>
</li>
<li> <p><code>"spearman"</code> &mdash; Spearman's rank-order correlation is computed
for all variables regardless of categories
</p>
</li></ul>

<p>For other similarity measures, compute them first and input them
into <code>data</code> with the sample size (<code>n</code>)</p>
</td></tr>
<tr><td><code id="invariance_+3A_na.data">na.data</code></td>
<td>
<p>Character (length = 1).
How should missing data be handled?
Defaults to <code>"pairwise"</code>.
Available options:
</p>

<ul>
<li> <p><code>"pairwise"</code> &mdash; Computes correlation for all available cases between
two variables
</p>
</li>
<li> <p><code>"listwise"</code> &mdash; Computes correlation for all complete cases in the dataset
</p>
</li></ul>
</td></tr>
<tr><td><code id="invariance_+3A_model">model</code></td>
<td>
<p>Character (length = 1).
Defaults to <code>"glasso"</code>.
Available options:
</p>

<ul>
<li> <p><code>"BGGM"</code> &mdash; Computes the Bayesian Gaussian Graphical Model.
Set argument <code>ordinal.categories</code> to determine
levels allowed for a variable to be considered ordinal.
See <code>?BGGM::estimate</code> for more details
</p>
</li>
<li> <p><code>"glasso"</code> &mdash; Computes the GLASSO with EBIC model selection.
See <code><a href="#topic+EBICglasso.qgraph">EBICglasso.qgraph</a></code> for more details
</p>
</li>
<li> <p><code>"TMFG"</code> &mdash; Computes the TMFG method.
See <code><a href="#topic+TMFG">TMFG</a></code> for more details
</p>
</li></ul>
</td></tr>
<tr><td><code id="invariance_+3A_algorithm">algorithm</code></td>
<td>
<p>Character or
<code><a href="igraph.html#topic+igraph">igraph</a></code> <code>cluster_*</code> function (length = 1).
Defaults to <code>"walktrap"</code>.
Three options are listed below but all are available
(see <code><a href="#topic+community.detection">community.detection</a></code> for other options):
</p>

<ul>
<li> <p><code>"leiden"</code> &mdash; See <code><a href="igraph.html#topic+cluster_leiden">cluster_leiden</a></code> for more details
</p>
</li>
<li> <p><code>"louvain"</code> &mdash; By default, <code>"louvain"</code> will implement the Louvain algorithm using
the consensus clustering method (see <code><a href="#topic+community.consensus">community.consensus</a></code>
for more information). This function will implement
<code>consensus.method = "most_common"</code> and <code>consensus.iter = 1000</code>
unless specified otherwise
</p>
</li>
<li> <p><code>"walktrap"</code> &mdash; See <code><a href="igraph.html#topic+cluster_walktrap">cluster_walktrap</a></code> for more details
</p>
</li></ul>
</td></tr>
<tr><td><code id="invariance_+3A_uni.method">uni.method</code></td>
<td>
<p>Character (length = 1).
What unidimensionality method should be used?
Defaults to <code>"louvain"</code>.
Available options:
</p>

<ul>
<li> <p><code>"expand"</code> &mdash; Expands the correlation matrix with four variables correlated 0.50.
If number of dimension returns 2 or less in check, then the data
are unidimensional; otherwise, regular EGA with no matrix
expansion is used. This method was used in the Golino et al.'s (2020)
<em>Psychological Methods</em> simulation
</p>
</li>
<li> <p><code>"LE"</code> &mdash; Applies the Leading Eigenvector algorithm
(<code><a href="igraph.html#topic+cluster_leading_eigen">cluster_leading_eigen</a></code>)
on the empirical correlation matrix. If the number of dimensions is 1,
then the Leading Eigenvector solution is used; otherwise, regular EGA
is used. This method was used in the Christensen et al.'s (2023)
<em>Behavior Research Methods</em> simulation
</p>
</li>
<li> <p><code>"louvain"</code> &mdash; Applies the Louvain algorithm (<code><a href="igraph.html#topic+cluster_louvain">cluster_louvain</a></code>)
on the empirical correlation matrix. If the number of dimensions is 1,
then the Louvain solution is used; otherwise, regular EGA is used.
This method was validated Christensen's (2022) <em>PsyArXiv</em> simulation.
Consensus clustering can be used by specifying either
<code>"consensus.method"</code> or <code>"consensus.iter"</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="invariance_+3A_ncores">ncores</code></td>
<td>
<p>Numeric (length = 1).
Number of cores to use in computing results.
Defaults to <code>ceiling(parallel::detectCores() / 2)</code> or half of your
computer's processing power.
Set to <code>1</code> to not use parallel computing
</p>
<p>If you're unsure how many cores your computer has,
then type: <code>parallel::detectCores()</code></p>
</td></tr>
<tr><td><code id="invariance_+3A_seed">seed</code></td>
<td>
<p>Numeric (length = 1).
Defaults to <code>NULL</code> or random results.
Set for reproducible results.
See <a href="https://github.com/hfgolino/EGAnet/wiki/Reproducibility-and-PRNG">Reproducibility and PRNG</a>
for more details on random number generation in <code><a href="#topic+EGAnet">EGAnet</a></code></p>
</td></tr>
<tr><td><code id="invariance_+3A_verbose">verbose</code></td>
<td>
<p>Boolean (length = 1).
Should progress be displayed?
Defaults to <code>TRUE</code>.
Set to <code>FALSE</code> to not display progress</p>
</td></tr>
<tr><td><code id="invariance_+3A_...">...</code></td>
<td>
<p>Additional arguments that can be passed on to
<code><a href="#topic+auto.correlate">auto.correlate</a></code>,
<code><a href="#topic+network.estimation">network.estimation</a></code>,
<code><a href="#topic+community.detection">community.detection</a></code>,
<code><a href="#topic+community.consensus">community.consensus</a></code>,
<code><a href="#topic+EGA">EGA</a></code>,
<code><a href="#topic+bootEGA">bootEGA</a></code>, and
<code><a href="#topic+net.loads">net.loads</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>In traditional psychometrics, measurement invariance is performed in
sequential testing from more flexible (more free parameters) to more rigid
(fewer free parameters) structures. Measurement invariance in network
psychometrics is no different.
</p>
<p><strong>Configural Invariance</strong>
</p>
<p>To establish configural invariance, the data are collapsed across groups
and a common sample structure is identified used <code><a href="#topic+bootEGA">bootEGA</a></code>
and <code><a href="#topic+itemStability">itemStability</a></code>. If some variables have a replication
less than 0.70 in their assigned dimension, then they are considered unstable
and therefore not invariant. These variables are removed and this process
is repeated until all items are considered stable (replication values greater
than 0.70) or there are no variables left. If configural invariance cannot be
established, then the last run of results are returned and metric invariance
is not tested (because configural invariance is not met). Importantly, if any
variables <em>are</em> removed, then configural invariance is not met for the
original structure. Any removal would suggest only partial configural invariance
is met.
</p>
<p><strong>Metric Invariance</strong>
</p>
<p>The variables that remain after configural invariance are submitted to metric
invariance. First, each group estimates a network and then network loadings
(<code><a href="#topic+net.loads">net.loads</a></code>) are computed using the assigned
community memberships (determined during configural invariance). Then,
the difference between the assigned loadings of the groups is computed. This
difference represents the empirical values. Second, the group memberships
are permutated and networks are estimated based on the these permutated
groups for <code>iter</code> times. Then, network loadings are computed and
the difference between the assigned loadings of the group is computed, resulting
in a null distribution. The empirical difference is then compared against
the null distribution using a two-tailed <em>p</em>-value based on the number
of null distribution differences that are greater and less than the empirical
differences for each variable. Both uncorrected and false discovery rate
corrected <em>p</em>-values are returned in the results. Uncorrected <em>p</em>-values
are flagged for significance along with the direction of group differences.
</p>
<p><strong>Three or More Groups</strong>
</p>
<p>At this time, only two groups are supported. There is a method proposed to
test three or more groups in Jamison, Golino, and Christensen (2023) but
this approach has not been thoroughly vetted and validated. Future versions
of the package will provide support for three or more groups once there is
an established consensus for best practice.
</p>
<p>For more details, see Jamison, Golino, and Christensen (2023)
</p>


<h3>Value</h3>

<p>Returns a list containing:
</p>
<table>
<tr><td><code>configural.results</code></td>
<td>
<p><code><a href="#topic+bootEGA">bootEGA</a></code> results from
the final run that produced configural invariance. This output will be
output on the final run of unsuccessful configural invariance runs</p>
</td></tr>
<tr><td><code>memberships</code></td>
<td>
<p>Original memberships provided in <code>structure</code>
or from <code><a href="#topic+EGA">EGA</a></code> if <code>structure = NULL</code></p>
</td></tr>
<tr><td><code>EGA</code></td>
<td>
<p>Original <code><a href="#topic+EGA">EGA</a></code> results for the full sample</p>
</td></tr>
<tr><td><code>groups</code></td>
<td>
<p>A list containing:
</p>

<ul>
<li> <p><code><a href="#topic+EGA">EGA</a></code> &mdash; <code><a href="#topic+EGA">EGA</a></code> results for each group
</p>
</li>
<li> <p><code>loadings</code> &mdash; Network loadings (<code><a href="#topic+net.loads">net.loads</a></code>) for each group
</p>
</li>
<li> <p><code>loadingsDifference</code> &mdash; Difference between the dominant loadings of each group
</p>
</li></ul>

</td></tr>
<tr><td><code>permutation</code></td>
<td>
<p>A list containing:
</p>

<ul>
<li> <p><code>groups</code> &mdash; Permutated groups acorss iterations
</p>
</li>
<li> <p><code>loadings</code> &mdash; Network loadings (<code><a href="#topic+net.loads">net.loads</a></code>) for each group for each permutation
</p>
</li>
<li> <p><code>loadingsDifference</code> &mdash; Difference between the dominant loadings of each group for each permutation
</p>
</li></ul>

</td></tr>
<tr><td><code>results</code></td>
<td>
<p>Data frame of the results (which are printed)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Laura Jamison &lt;lj5yn@virginia.edu&gt;,
Hudson F. Golino &lt;hfg9s at virginia.edu&gt;, and
Alexander P. Christensen &lt;alexpaulchristensen@gmail.com&gt;,
</p>


<h3>References</h3>

<p><strong>Original implementation</strong> <br />
Jamison, L., Golino, H., &amp; Christensen, A. P. (2023).
Metric invariance in exploratory graph analysis via permutation testing.
<em>PsyArXiv</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.EGAnet">plot.EGAnet</a></code> for plot usage in <code><a href="#topic+EGAnet">EGAnet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
wmt &lt;- wmt2[-1,7:24]

# Groups
groups &lt;- rep(1:2, each = nrow(wmt) / 2)

## Not run: 
# Measurement invariance
results &lt;- invariance(wmt, groups, ncores = 2)

# Plot with uncorrected alpha = 0.05
plot(results, p_type = "p", p_value = 0.05)

# Plot with BH-corrected alpha = 0.10
plot(results, p_type = "p_BH", p_value = 0.10)
## End(Not run)

</code></pre>

<hr>
<h2 id='itemStability'>Item Stability Statistics from <code><a href="#topic+bootEGA">bootEGA</a></code></h2><span id='topic+itemStability'></span>

<h3>Description</h3>

<p>Based on the <code><a href="#topic+bootEGA">bootEGA</a></code> results, this function
computes and plots the number of times an variable is estimated
in the same dimension as originally estimated by an empirical
<code><a href="#topic+EGA">EGA</a></code> structure or a theoretical/input structure.
The output also contains each variable's replication frequency (i.e., proportion of
bootstraps that a variable appeared in each dimension
</p>


<h3>Usage</h3>

<pre><code class='language-R'>itemStability(bootega.obj, IS.plot = TRUE, structure = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="itemStability_+3A_bootega.obj">bootega.obj</code></td>
<td>
<p>A <code><a href="#topic+bootEGA">bootEGA</a></code> object</p>
</td></tr>
<tr><td><code id="itemStability_+3A_is.plot">IS.plot</code></td>
<td>
<p>Boolean (length = 1).
Should the plot be produced for <code>item.replication</code>?
Defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="itemStability_+3A_structure">structure</code></td>
<td>
<p>Numeric (length = number of variables).
A theoretical or pre-defined structure.
Defaults to <code>NULL</code> or the empirical <code><a href="#topic+EGA">EGA</a></code>
result in the <code>bootega.obj</code></p>
</td></tr>
<tr><td><code id="itemStability_+3A_...">...</code></td>
<td>
<p>Deprecated arguments from previous versions of <code><a href="#topic+itemStability">itemStability</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing:
</p>
<table>
<tr><td><code>membership</code></td>
<td>
<p>A list containing:
</p>

<ul>
<li> <p><code>empirical</code> &mdash; A vector of the empirical memberships from the
empirical <code><a href="#topic+EGA">EGA</a></code> result
</p>
</li>
<li> <p><code>bootstrap</code> &mdash; A matrix of the homogenized memberships from the replicate samples in
the <code><a href="#topic+bootEGA">bootEGA</a></code> results
</p>
</li>
<li> <p><code>structure</code> &mdash; A vector of the structure used in the analysis. If <code>structure = NULL</code>, then this output
will be the same as <code>empirical</code>
</p>
</li></ul>

</td></tr>
<tr><td><code>item.stability</code></td>
<td>
<p>A list containing:
</p>

<ul>
<li> <p><code>empirical.dimensions</code> &mdash; A vector of the proportion of times each item replicated
within the structure defined by <code>structure</code>
</p>
</li>
<li> <p><code>all.dimensions</code> &mdash; A matrix of the proportion of times each item replicated
in each of the <code>structure</code> defined dimensions
</p>
</li></ul>

</td></tr>
<tr><td><code>plot</code></td>
<td>
<p>Plot output if <code>IS.plot = TRUE</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hudson Golino &lt;hfg9s at virginia.edu&gt; and Alexander P. Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>References</h3>

<p><strong>Original implementation of bootEGA</strong> <br />
Christensen, A. P., &amp; Golino, H. (2021).
Estimating the stability of the number of factors via Bootstrap Exploratory Graph Analysis: A tutorial.
<em>Psych</em>, <em>3</em>(3), 479-500.
</p>
<p><strong>Conceptual introduction</strong> <br />
Christensen, A. P., Golino, H., &amp; Silvia, P. J. (2020).
A psychometric network perspective on the validity and validation of personality trait questionnaires.
<em>European Journal of Personality</em>, <em>34</em>(6), 1095-1108.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.EGAnet">plot.EGAnet</a></code> for plot usage in <code><a href="#topic+EGAnet">EGAnet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
wmt &lt;- wmt2[,7:24]

## Not run: 
# Standard EGA example
boot.wmt &lt;- bootEGA(
  data = wmt, iter = 500,
  type = "parametric", ncores = 2
)
## End(Not run)

# Standard item stability
wmt.is &lt;- itemStability(boot.wmt)

## Not run: 
# EGA fit example
boot.wmt.fit &lt;- bootEGA(
  data = wmt, iter = 500,
  EGA.type = "EGA.fit",
  type = "parametric", ncores = 2
)

# EGA fit item stability
wmt.is.fit &lt;- itemStability(boot.wmt.fit)

# Hierarchical EGA example
boot.wmt.hier &lt;- bootEGA(
  data = wmt, iter = 500,
  EGA.type = "hierEGA",
  type = "parametric", ncores = 2
)

# Hierarchical EGA item stability
wmt.is.hier &lt;- itemStability(boot.wmt.hier)

# Random-intercept EGA example
boot.wmt.ri &lt;- bootEGA(
  data = wmt, iter = 500,
  EGA.type = "riEGA",
  type = "parametric", ncores = 2
)

# Random-intercept EGA item stability
wmt.is.ri &lt;- itemStability(boot.wmt.ri)
## End(Not run)

</code></pre>

<hr>
<h2 id='jsd'>Jensen-Shannon Distance</h2><span id='topic+jsd'></span>

<h3>Description</h3>

<p>Computes the Jensen-Shannon Distance between two networks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jsd(network1, network2, method = c("kld", "spectral"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jsd_+3A_network1">network1</code></td>
<td>
<p>Matrix or data frame.
Network to be compared</p>
</td></tr>
<tr><td><code id="jsd_+3A_network2">network2</code></td>
<td>
<p>Matrix or data frame.
Second network to be compared</p>
</td></tr>
<tr><td><code id="jsd_+3A_method">method</code></td>
<td>
<p>Character (length = 1).
Method to compute Jensen-Shannon Distance.
Defaults to <code>"spectral"</code>.
Available options:
</p>

<ul>
<li> <p><code>"kld"</code> &mdash; Uses Kullback-Leibler Divergence
</p>
</li>
<li> <p><code>"spectral"</code> &mdash; Uses eigenvalues of combinatorial Laplacian matrix to compute
Von Neumann entropy
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns Jensen-Shannon Distance
</p>


<h3>Author(s)</h3>

<p>Hudson Golino &lt;hfg9s at virginia.edu&gt; &amp; Alexander P. Christensen &lt;alexander.christensen at Vanderbilt.Edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Obtain wmt2 data
wmt &lt;- wmt2[,7:24]

# Set seed (for reproducibility)
set.seed(1234)

# Split data
split1 &lt;- sample(
  1:nrow(wmt), floor(nrow(wmt) / 2)
)
split2 &lt;- setdiff(1:nrow(wmt), split1)

# Obtain split data
data1 &lt;- wmt[split1,]
data2 &lt;- wmt[split2,]

# Perform EBICglasso
glas1 &lt;- EBICglasso.qgraph(data1)
glas2 &lt;- EBICglasso.qgraph(data2)

# Spectral JSD 
jsd(glas1, glas2) 
# 0.1595893

# Spectral JSS (similarity)
1 - jsd(glas1, glas2) 
# 0.8404107

# Jensen-Shannon Divergence
jsd(glas1, glas2, method = "kld") 
# 0.1393621

</code></pre>

<hr>
<h2 id='LCT'>Loadings Comparison Test</h2><span id='topic+LCT'></span>

<h3>Description</h3>

<p>An algorithm to identify whether data were generated from a
factor or network model using factor and network loadings.
The algorithm uses heuristics based on theory and simulation. These
heuristics were then submitted to several deep learning neural networks
with 240,000 samples per model with varying parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LCT(
  data,
  n = NULL,
  corr = c("auto", "cor_auto", "pearson", "spearman"),
  na.data = c("pairwise", "listwise"),
  model = c("BGGM", "glasso", "TMFG"),
  algorithm = c("leiden", "louvain", "walktrap"),
  uni.method = c("expand", "LE", "louvain"),
  iter = 100,
  seed = NULL,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LCT_+3A_data">data</code></td>
<td>
<p>Matrix or data frame.
Should consist only of variables to be used in the analysis.
Can be raw data or a correlation matrix</p>
</td></tr>
<tr><td><code id="LCT_+3A_n">n</code></td>
<td>
<p>Numeric (length = 1).
Sample size if <code>data</code> provided is a correlation matrix</p>
</td></tr>
<tr><td><code id="LCT_+3A_corr">corr</code></td>
<td>
<p>Character (length = 1).
Method to compute correlations.
Defaults to <code>"auto"</code>.
Available options:
</p>

<ul>
<li> <p><code>"auto"</code> &mdash; Automatically computes appropriate correlations for
the data using Pearson's for continuous, polychoric for ordinal,
tetrachoric for binary, and polyserial/biserial for ordinal/binary with
continuous. To change the number of categories that are considered
ordinal, use <code>ordinal.categories</code>
(see <code><a href="#topic+polychoric.matrix">polychoric.matrix</a></code> for more details)
</p>
</li>
<li> <p><code>"cor_auto"</code> &mdash; Uses <code><a href="qgraph.html#topic+cor_auto">cor_auto</a></code> to compute correlations. 
Arguments can be passed along to the function
</p>
</li>
<li> <p><code>"pearson"</code> &mdash; Pearson's correlation is computed for all 
variables regardless of categories
</p>
</li>
<li> <p><code>"spearman"</code> &mdash; Spearman's rank-order correlation is computed 
for all variables regardless of categories
</p>
</li></ul>

<p>For other similarity measures, compute them first and input them
into <code>data</code> with the sample size (<code>n</code>)</p>
</td></tr>
<tr><td><code id="LCT_+3A_na.data">na.data</code></td>
<td>
<p>Character (length = 1).
How should missing data be handled?
Defaults to <code>"pairwise"</code>.
Available options:
</p>

<ul>
<li> <p><code>"pairwise"</code> &mdash; Computes correlation for all available cases between
two variables
</p>
</li>
<li> <p><code>"listwise"</code> &mdash; Computes correlation for all complete cases in the dataset
</p>
</li></ul>
</td></tr>
<tr><td><code id="LCT_+3A_model">model</code></td>
<td>
<p>Character (length = 1).
Defaults to <code>"glasso"</code>.
Available options:
</p>

<ul>
<li> <p><code>"BGGM"</code> &mdash; Computes the Bayesian Gaussian Graphical Model.
Set argument <code>ordinal.categories</code> to determine
levels allowed for a variable to be considered ordinal.
See <code>?BGGM::estimate</code> for more details
</p>
</li>
<li> <p><code>"glasso"</code> &mdash; Computes the GLASSO with EBIC model selection.
See <code><a href="#topic+EBICglasso.qgraph">EBICglasso.qgraph</a></code> for more details
</p>
</li>
<li> <p><code>"TMFG"</code> &mdash; Computes the TMFG method.
See <code><a href="#topic+TMFG">TMFG</a></code> for more details
</p>
</li></ul>
</td></tr>
<tr><td><code id="LCT_+3A_algorithm">algorithm</code></td>
<td>
<p>Character or 
<code><a href="igraph.html#topic+igraph">igraph</a></code> <code>cluster_*</code> function (length = 1).
Defaults to <code>"walktrap"</code>.
Three options are listed below but all are available
(see <code><a href="#topic+community.detection">community.detection</a></code> for other options):
</p>

<ul>
<li> <p><code>"leiden"</code> &mdash; See <code><a href="igraph.html#topic+cluster_leiden">cluster_leiden</a></code> for more details
</p>
</li>
<li> <p><code>"louvain"</code> &mdash; By default, <code>"louvain"</code> will implement the Louvain algorithm using 
the consensus clustering method (see <code><a href="#topic+community.consensus">community.consensus</a></code> 
for more information). This function will implement
<code>consensus.method = "most_common"</code> and <code>consensus.iter = 1000</code> 
unless specified otherwise
</p>
</li>
<li> <p><code>"walktrap"</code> &mdash; See <code><a href="igraph.html#topic+cluster_walktrap">cluster_walktrap</a></code> for more details
</p>
</li></ul>
</td></tr>
<tr><td><code id="LCT_+3A_uni.method">uni.method</code></td>
<td>
<p>Character (length = 1).
What unidimensionality method should be used? 
Defaults to <code>"louvain"</code>.
Available options:
</p>

<ul>
<li> <p><code>"expand"</code> &mdash; Expands the correlation matrix with four variables correlated 0.50.
If number of dimension returns 2 or less in check, then the data 
are unidimensional; otherwise, regular EGA with no matrix
expansion is used. This method was used in the Golino et al.'s (2020)
<em>Psychological Methods</em> simulation
</p>
</li>
<li> <p><code>"LE"</code> &mdash; Applies the Leading Eigenvector algorithm
(<code><a href="igraph.html#topic+cluster_leading_eigen">cluster_leading_eigen</a></code>)
on the empirical correlation matrix. If the number of dimensions is 1,
then the Leading Eigenvector solution is used; otherwise, regular EGA
is used. This method was used in the Christensen et al.'s (2023) 
<em>Behavior Research Methods</em> simulation
</p>
</li>
<li> <p><code>"louvain"</code> &mdash; Applies the Louvain algorithm (<code><a href="igraph.html#topic+cluster_louvain">cluster_louvain</a></code>)
on the empirical correlation matrix. If the number of dimensions is 1, 
then the Louvain solution is used; otherwise, regular EGA is used. 
This method was validated Christensen's (2022) <em>PsyArXiv</em> simulation.
Consensus clustering can be used by specifying either
<code>"consensus.method"</code> or <code>"consensus.iter"</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="LCT_+3A_iter">iter</code></td>
<td>
<p>Numeric (length = 1).
Number of replicate samples to be drawn from a multivariate
normal distribution (uses <code>MASS::mvrnorm</code>).
Defaults to <code>100</code> (recommended)</p>
</td></tr>
<tr><td><code id="LCT_+3A_seed">seed</code></td>
<td>
<p>Numeric (length = 1).
Defaults to <code>NULL</code> or random results.
Set for reproducible results.
See <a href="https://github.com/hfgolino/EGAnet/wiki/Reproducibility-and-PRNG">Reproducibility and PRNG</a>
for more details on random number generation in <code><a href="#topic+EGAnet">EGAnet</a></code></p>
</td></tr>
<tr><td><code id="LCT_+3A_verbose">verbose</code></td>
<td>
<p>Boolean (length = 1).
Should progress be displayed?
Defaults to <code>TRUE</code>.
Set to <code>FALSE</code> to not display progress</p>
</td></tr>
<tr><td><code id="LCT_+3A_...">...</code></td>
<td>
<p>Additional arguments that can be passed on to
<code><a href="#topic+auto.correlate">auto.correlate</a></code>,
<code><a href="#topic+network.estimation">network.estimation</a></code>,
<code><a href="#topic+community.detection">community.detection</a></code>,
<code><a href="#topic+community.consensus">community.consensus</a></code>, and
<code><a href="#topic+EGA">EGA</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing:
</p>
<table>
<tr><td><code>empirical</code></td>
<td>
<p>Prediction of model based on empirical dataset only</p>
</td></tr>
<tr><td><code>bootstrap</code></td>
<td>
<p>Prediction of model based on means of the loadings across
the bootstrap replicate samples</p>
</td></tr>
<tr><td><code>proportion</code></td>
<td>
<p>Proportions of models suggested across bootstraps</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hudson F. Golino &lt;hfg9s at virginia.edu&gt; and Alexander P. Christensen &lt;alexpaulchristensen at gmail.com&gt;
</p>


<h3>References</h3>

<p><strong>Model training and validation</strong> <br />
Christensen, A. P., &amp; Golino, H. (2021).
Factor or network model? Predictions from neural networks.
<em>Journal of Behavioral Data Science</em>, <em>1</em>(1), 85-126.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get data
data &lt;- psych::bfi[,1:25]

## Not run: # Compute LCT
## Factor model
LCT(data)
## End(Not run) 

</code></pre>

<hr>
<h2 id='modularity'>Computes the (Signed) Modularity Statistic</h2><span id='topic+modularity'></span>

<h3>Description</h3>

<p>Computes (signed) modularity statistic
given a network and community structure. Allows the
resolution parameter to be set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modularity(network, memberships, resolution = 1, signed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modularity_+3A_network">network</code></td>
<td>
<p>Matrix or data frame.
A symmetric matrix representing a network</p>
</td></tr>
<tr><td><code id="modularity_+3A_memberships">memberships</code></td>
<td>
<p>Numeric (length = <code>ncol(network)</code>).
A numeric vector of integer values corresponding to 
each node's community membership</p>
</td></tr>
<tr><td><code id="modularity_+3A_resolution">resolution</code></td>
<td>
<p>Numeric (length = 1).
A parameter that adjusts modularity to
prefer smaller (<code>resolution</code> &gt; 1) or larger
(0 &lt; <code>resolution</code> &lt; 1) communities.
Defaults to <code>1</code> (standard modularity computation)</p>
</td></tr>
<tr><td><code id="modularity_+3A_signed">signed</code></td>
<td>
<p>Boolean (length = 1).
Whether signed or absolute modularity should be computed.
The most common modularity metric is defined by positive values only. 
Gomez et al. (2009) introduced a signed version of modularity that
will discount modularity for edges with negative values. This property
isn't always desired for psychometric networks. If <code>TRUE</code>, then
this signed modularity metric will be computed. If <code>FALSE</code>, then
the absolute value of the edges in the network (using <code>abs</code>) will
be used to compute modularity.
Defaults to <code>FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the modularity statistic
</p>


<h3>Author(s)</h3>

<p>Alexander P. Christensen &lt;alexpaulchristensen@gmail.com&gt; with assistance from GPT-4
</p>


<h3>References</h3>

<p>Gomez, S., Jensen, P., &amp; Arenas, A. (2009).
Analysis of community structure in networks of correlated data.
<em>Physical Review E</em>, <em>80</em>(1), 016114.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
wmt &lt;- wmt2[,7:24]

# Estimate EGA
ega.wmt &lt;- EGA(wmt, model = "glasso")

# Compute standard (absolute values) modularity
modularity(
  network = ega.wmt$network,
  memberships = ega.wmt$wc,
  signed = FALSE
)
# 0.1697952

# Compute signed modularity
modularity(
  network = ega.wmt$network,
  memberships = ega.wmt$wc,
  signed = TRUE
)
# 0.1701946

</code></pre>

<hr>
<h2 id='net.loads'>Network Loadings</h2><span id='topic+net.loads'></span>

<h3>Description</h3>

<p>Computes the between- and within-community
<code>strength</code> of each variable for each community
</p>


<h3>Usage</h3>

<pre><code class='language-R'>net.loads(
  A,
  wc,
  loading.method = c("BRM", "experimental"),
  scaling = 2,
  rotation = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="net.loads_+3A_a">A</code></td>
<td>
<p>Network matrix, data frame, or <code><a href="#topic+EGA">EGA</a></code> object</p>
</td></tr>
<tr><td><code id="net.loads_+3A_wc">wc</code></td>
<td>
<p>Numeric or character vector (length = <code>ncol(A)</code>).
A vector of community assignments.
If input into <code>A</code> is an <code><a href="#topic+EGA">EGA</a></code> object,
then <code>wc</code> is automatically detected</p>
</td></tr>
<tr><td><code id="net.loads_+3A_loading.method">loading.method</code></td>
<td>
<p>Character (length = 1).
Sets network loading calculation based on implementation
described in <code>"BRM"</code> (Christensen &amp; Golino, 2021) or
an <code>"experimental"</code> implementation.
Defaults to <code>"BRM"</code></p>
</td></tr>
<tr><td><code id="net.loads_+3A_scaling">scaling</code></td>
<td>
<p>Numeric (length = 1).
Scaling factor for the magnitude of the <code>"experimental"</code> network loadings.
Defaults to <code>2</code>.
<code>10</code> makes loadings roughly the size of factor loadings when correlations
between factors are orthogonal</p>
</td></tr>
<tr><td><code id="net.loads_+3A_rotation">rotation</code></td>
<td>
<p>Character.
A rotation to use to obtain a simpler structure.
For a list of rotations, see <code><a href="GPArotation.html#topic+rotations">rotations</a></code> for options.
Defaults to <code>NULL</code> or no rotation.
By setting a rotation, <code>scores</code> estimation will be
based on the rotated loadings rather than unrotated loadings</p>
</td></tr>
<tr><td><code id="net.loads_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass on to <code><a href="GPArotation.html#topic+rotations">rotations</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simulation studies have demonstrated that a node's strength
centrality is roughly equivalent to factor loadings
(Christensen &amp; Golino, 2021; Hallquist, Wright, &amp; Molenaar, 2019).
Hallquist and colleagues (2019) found that node strength represented a
combination of dominant and cross-factor loadings. This function computes
each node's strength within each specified dimension, providing a rough
equivalent to factor loadings (including cross-loadings; Christensen &amp; Golino, 2021).
</p>


<h3>Value</h3>

<p>Returns a list containing:
</p>
<table>
<tr><td><code>unstd</code></td>
<td>
<p>A matrix of the unstandardized within- and between-community
strength values for each node</p>
</td></tr>
<tr><td><code>std</code></td>
<td>
<p>A matrix of the standardized within- and between-community
strength values for each node</p>
</td></tr>
<tr><td><code>rotated</code></td>
<td>
<p><code>NULL</code> if <code>rotation = NULL</code>; otherwise,
a list containing the rotated standardized network loadings
(<code>loadings</code>) and correlations between dimensions (<code>Phi</code>)
from the rotation</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alexander P. Christensen &lt;alexpaulchristensen@gmail.com&gt; and Hudson Golino &lt;hfg9s at virginia.edu&gt;
</p>


<h3>References</h3>

<p><strong>Original implementation and simulation</strong> <br />
Christensen, A. P., &amp; Golino, H. (2021).
On the equivalency of factor and network loadings.
<em>Behavior Research Methods</em>, <em>53</em>, 1563-1580.
</p>
<p><strong>Demonstration of node strength similarity to CFA loadings</strong> <br />
Hallquist, M., Wright, A. C. G., &amp; Molenaar, P. C. M. (2019).
Problems with centrality measures in psychopathology symptom networks: Why network psychometrics cannot escape psychometric theory.
<em>Multivariate Behavioral Research</em>, 1-25.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
wmt &lt;- wmt2[,7:24]

# Estimate EGA
ega.wmt &lt;- EGA(
  data = wmt,
  plot.EGA = FALSE # No plot for CRAN checks
)

# Network loadings
net.loads(ega.wmt)

</code></pre>

<hr>
<h2 id='net.scores'>Network Scores</h2><span id='topic+net.scores'></span>

<h3>Description</h3>

<p>This function computes network scores computed based on
each node's <code>strength</code> within each community in the network 
(see <code><a href="#topic+net.loads">net.loads</a></code>). These values are used as &quot;network loadings&quot; 
for the weights of each variable.
</p>
<p>Network scores are computed as a formative composite rather than a reflective factor.
This composite representation is consistent with no latent factors that psychometric
network theory proposes.
</p>
<p>Scores can be computed as a &quot;simple&quot; structure, which is equivalent to a weighted
sum scores or as a &quot;full&quot; structure, which is equivalent to an EFA approach.
Conservatively, the &quot;simple&quot; structure approach is recommended until further
validation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>net.scores(
  data,
  A,
  wc,
  loading.method = c("BRM", "experimental"),
  rotation = NULL,
  scores = c("Anderson", "Bartlett", "components", "Harman", "network", "tenBerge",
    "Thurstone"),
  loading.structure = c("simple", "full"),
  impute = c("mean", "median", "none"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="net.scores_+3A_data">data</code></td>
<td>
<p>Matrix or data frame.
Should consist only of variables to be used in the analysis</p>
</td></tr>
<tr><td><code id="net.scores_+3A_a">A</code></td>
<td>
<p>Network matrix, data frame, or <code><a href="#topic+EGA">EGA</a></code> object</p>
</td></tr>
<tr><td><code id="net.scores_+3A_wc">wc</code></td>
<td>
<p>Numeric or character vector (length = <code>ncol(A)</code>).
A vector of community assignments.
If input into <code>A</code> is an <code><a href="#topic+EGA">EGA</a></code> object,
then <code>wc</code> is automatically detected</p>
</td></tr>
<tr><td><code id="net.scores_+3A_loading.method">loading.method</code></td>
<td>
<p>Character (length = 1).
Sets network loading calculation based on implementation
described in <code>"BRM"</code> (Christensen &amp; Golino, 2021) or
an <code>"experimental"</code> implementation.
Defaults to <code>"BRM"</code></p>
</td></tr>
<tr><td><code id="net.scores_+3A_rotation">rotation</code></td>
<td>
<p>Character.
A rotation to use to obtain a simpler structure. 
For a list of rotations, see <code><a href="GPArotation.html#topic+rotations">rotations</a></code> for options.
Defaults to <code>NULL</code> or no rotation.
By setting a rotation, <code>scores</code> estimation will be
based on the rotated loadings rather than unrotated loadings</p>
</td></tr>
<tr><td><code id="net.scores_+3A_scores">scores</code></td>
<td>
<p>Character (length = 1).
How should scores be estimated?
Defaults to <code>"network"</code> for network scores.
Set to other scoring methods which will be computed using
<code><a href="psych.html#topic+factor.scores">factor.scores</a></code> (see link for arguments
and explanations for other methods)</p>
</td></tr>
<tr><td><code id="net.scores_+3A_loading.structure">loading.structure</code></td>
<td>
<p>Character (length = 1).
Whether simple structure or the saturated loading matrix
should be used when computing scores.
Defaults to <code>"simple"</code>
</p>
<p><code>"simple"</code> structure more closely mirrors sum scores and CFA; 
<code>"full"</code> structure more closely mirrors EFA
</p>
<p>Simple structure is the more &quot;conservative&quot; (established) approach
and is therefore the default. Treat <code>"full"</code> as experimental
as proper vetting and validation has not been established</p>
</td></tr>
<tr><td><code id="net.scores_+3A_impute">impute</code></td>
<td>
<p>Character (length = 1).
If there are any missing data, then imputation can be implemented. 
Available options:
</p>

<ul>
<li> <p><code>"none"</code> &mdash; Default. No imputation is performed
</p>
</li>
<li> <p><code>"mean"</code> &mdash; The mean value of each variable is used to replace missing data
for that variable
</p>
</li>
<li> <p><code>"median"</code> &mdash; The median value of each variable is used to replace missing data
for that variable
</p>
</li></ul>
</td></tr>
<tr><td><code id="net.scores_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed on to 
<code><a href="#topic+net.loads">net.loads</a></code> and
<code><a href="psych.html#topic+factor.scores">factor.scores</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing:
</p>
<table>
<tr><td><code>scores</code></td>
<td>
<p>A list containing the standardized (<code>std.scores</code>)
rotated (<code>rot.scores</code>) scores. If <code>rotation = NULL</code>, then
<code>rot.scores</code> will be <code>NULL</code></p>
</td></tr>
<tr><td><code>loadings</code></td>
<td>
<p>Output from <code><a href="#topic+net.loads">net.loads</a></code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alexander P. Christensen &lt;alexpaulchristensen@gmail.com&gt; and Hudson F. Golino &lt;hfg9s at virginia.edu&gt;
</p>


<h3>References</h3>

<p><strong>Original implementation and simulation for loadings</strong> <br />
Christensen, A. P., &amp; Golino, H. (2021).
On the equivalency of factor and network loadings.
<em>Behavior Research Methods</em>, <em>53</em>, 1563-1580.
</p>
<p><strong>Preliminary simulation for scores</strong> <br />
Golino, H., Christensen, A. P., Moulder, R., Kim, S., &amp; Boker, S. M. (2021).
Modeling latent topics in social media using Dynamic Exploratory Graph Analysis: The case of the right-wing and left-wing trolls in the 2016 US elections.
<em>Psychometrika</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
wmt &lt;- wmt2[,7:24]

# Estimate EGA
ega.wmt &lt;- EGA(
  data = wmt,
  plot.EGA = FALSE # No plot for CRAN checks
)

# Network scores
net.scores(data = wmt, A = ega.wmt)

</code></pre>

<hr>
<h2 id='network.estimation'>Apply a Network Estimation Method</h2><span id='topic+network.estimation'></span>

<h3>Description</h3>

<p>General function to apply network estimation methods in <code><a href="#topic+EGAnet">EGAnet</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>network.estimation(
  data,
  n = NULL,
  corr = c("auto", "cor_auto", "pearson", "spearman"),
  na.data = c("pairwise", "listwise"),
  model = c("BGGM", "glasso", "TMFG"),
  network.only = TRUE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network.estimation_+3A_data">data</code></td>
<td>
<p>Matrix or data frame.
Should consist only of variables to be used in the analysis</p>
</td></tr>
<tr><td><code id="network.estimation_+3A_n">n</code></td>
<td>
<p>Numeric (length = 1).
Sample size if <code>data</code> provided is a correlation matrix</p>
</td></tr>
<tr><td><code id="network.estimation_+3A_corr">corr</code></td>
<td>
<p>Character (length = 1).
Method to compute correlations.
Defaults to <code>"auto"</code>.
Available options:
</p>

<ul>
<li> <p><code>"auto"</code> &mdash; Automatically computes appropriate correlations for
the data using Pearson's for continuous, polychoric for ordinal,
tetrachoric for binary, and polyserial/biserial for ordinal/binary with
continuous. To change the number of categories that are considered
ordinal, use <code>ordinal.categories</code>
(see <code><a href="#topic+polychoric.matrix">polychoric.matrix</a></code> for more details)
</p>
</li>
<li> <p><code>"cor_auto"</code> &mdash; Uses <code><a href="qgraph.html#topic+cor_auto">cor_auto</a></code> to compute correlations. 
Arguments can be passed along to the function
</p>
</li>
<li> <p><code>"pearson"</code> &mdash; Pearson's correlation is computed for all 
variables regardless of categories
</p>
</li>
<li> <p><code>"spearman"</code> &mdash; Spearman's rank-order correlation is computed 
for all variables regardless of categories
</p>
</li></ul>

<p>For other similarity measures, compute them first and input them
into <code>data</code> with the sample size (<code>n</code>)</p>
</td></tr>
<tr><td><code id="network.estimation_+3A_na.data">na.data</code></td>
<td>
<p>Character (length = 1).
How should missing data be handled?
Defaults to <code>"pairwise"</code>.
Available options:
</p>

<ul>
<li> <p><code>"pairwise"</code> &mdash; Computes correlation for all available cases between
two variables
</p>
</li>
<li> <p><code>"listwise"</code> &mdash; Computes correlation for all complete cases in the dataset
</p>
</li></ul>
</td></tr>
<tr><td><code id="network.estimation_+3A_model">model</code></td>
<td>
<p>Character (length = 1).
Defaults to <code>"glasso"</code>.
Available options:
</p>

<ul>
<li> <p><code>"BGGM"</code> &mdash; Computes the Bayesian Gaussian Graphical Model.
Set argument <code>ordinal.categories</code> to determine
levels allowed for a variable to be considered ordinal.
See <code>?BGGM::estimate</code> for more details
</p>
</li>
<li> <p><code>"glasso"</code> &mdash; Computes the GLASSO with EBIC model selection.
See <code><a href="#topic+EBICglasso.qgraph">EBICglasso.qgraph</a></code> for more details
</p>
</li>
<li> <p><code>"TMFG"</code> &mdash; Computes the TMFG method.
See <code><a href="#topic+TMFG">TMFG</a></code> for more details
</p>
</li></ul>
</td></tr>
<tr><td><code id="network.estimation_+3A_network.only">network.only</code></td>
<td>
<p>Boolean (length = 1).
Whether the network only should be output.
Defaults to <code>TRUE</code>.
Set to <code>FALSE</code> to obtain all output for the
network estimation method</p>
</td></tr>
<tr><td><code id="network.estimation_+3A_verbose">verbose</code></td>
<td>
<p>Boolean (length = 1).
Whether messages and (insignificant) warnings should be output.
Defaults to <code>FALSE</code> (silent calls).
Set to <code>TRUE</code> to see all messages and warnings for every function call</p>
</td></tr>
<tr><td><code id="network.estimation_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed on to
<code><a href="#topic+auto.correlate">auto.correlate</a></code> and the different
network estimation methods (see <code>model</code> for
model specific details)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix populated with a network from the input data
</p>


<h3>Author(s)</h3>

<p>Hudson Golino &lt;hfg9s at virginia.edu&gt; and Alexander P. Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>References</h3>

<p><strong>Graphical Least Absolute Shrinkage and Selection Operator (GLASSO)</strong> <br />
Friedman, J., Hastie, T., &amp; Tibshirani, R. (2008). 
Sparse inverse covariance estimation with the graphical lasso. 
<em>Biostatistics</em>, <em>9</em>(3), 432â€“441.
</p>
<p><strong>GLASSO with Extended Bayesian Information Criterion (EBICglasso)</strong> <br />
Epskamp, S., &amp; Fried, E. I. (2018).
A tutorial on regularized partial correlation networks.
<em>Psychological Methods</em>, <em>23</em>(4), 617â€“634.
</p>
<p><strong>Bayesian Gaussian Graphical Model (BGGM)</strong> <br />
Williams, D. R. (2021).
Bayesian estimation for Gaussian graphical models: Structure learning, predictability, and network comparisons.
<em>Multivariate Behavioral Research</em>, <em>56</em>(2), 336â€“352. 
</p>
<p><strong>Triangulated Maximally Filtered Graph (TMFG)</strong> <br />
Massara, G. P., Di Matteo, T., &amp; Aste, T. (2016).
Network filtering for big data: Triangulated maximally filtered graph.
<em>Journal of Complex Networks</em>, <em>5</em>, 161-178.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
wmt &lt;- wmt2[,7:24]

# EBICglasso (default for EGA functions)
glasso_network &lt;- network.estimation(
  data = wmt, model = "glasso"
)

# TMFG
tmfg_network &lt;- network.estimation(
  data = wmt, model = "TMFG"
)

</code></pre>

<hr>
<h2 id='network.generalizability'>Estimate the Generalizability of Network</h2><span id='topic+network.generalizability'></span>

<h3>Description</h3>

<p>General function to compute a network's predictive power on new data,
following Haslbeck and Waldorp (2018) and Williams and Rodriguez (2022) and using
generalizability methods of data splitting, <em>k</em>-folds cross-validation,
and leave-one-out cross-validation
</p>
<p>Uses <code><a href="#topic+network.predictability">network.predictability</a></code> as the basis to then perform
generalizability methods over
</p>


<h3>Usage</h3>

<pre><code class='language-R'>network.generalizability(
  data,
  method = c("split", "cv", "loocv"),
  number,
  corr = c("auto", "cor_auto", "pearson", "spearman"),
  na.data = c("pairwise", "listwise"),
  model = c("BGGM", "glasso", "TMFG"),
  algorithm = c("leiden", "louvain", "walktrap"),
  uni.method = c("expand", "LE", "louvain"),
  seed = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network.generalizability_+3A_data">data</code></td>
<td>
<p>Matrix or data frame.
Should consist only of variables to be used in the analysis.
Can be raw data or a correlation matrix</p>
</td></tr>
<tr><td><code id="network.generalizability_+3A_method">method</code></td>
<td>
<p>Character (length = 1).
Generalizability method.
Available options:
</p>

<ul>
<li> <p><code>"split"</code> &mdash; Performs train/test data split on the data using
<code>number</code> to adjust the size of the <strong>training</strong> split
</p>
</li>
<li> <p><code>"cv"</code> &mdash; (default) Performs <em>k</em>-folds cross-validation using
<code>number</code> to adjust the number of folds (e.g., 5 = 80/20 splits; 10 = 90/10 splits)
</p>
</li>
<li> <p><code>"loocv"</code> &mdash; Performs leave-one-out cross-validation. Leave-one-out
has a tendency to <strong>overestimate</strong> the generalizability of the model and
is not recommended (<em>k</em>-folds cross-validation should be preferred)
</p>
</li></ul>
</td></tr>
<tr><td><code id="network.generalizability_+3A_number">number</code></td>
<td>
<p>Numeric (length = 1).
Parameter to adjust the <code>method</code> argument. Ranges 0-1
for <code>method = "split"</code> and 1-N for <code>method = "cv"</code>.
Defaults to <code>0.80</code> and <code>5</code>, respectively</p>
</td></tr>
<tr><td><code id="network.generalizability_+3A_corr">corr</code></td>
<td>
<p>Character (length = 1).
Method to compute correlations.
Defaults to <code>"auto"</code>.
Available options:
</p>

<ul>
<li> <p><code>"auto"</code> &mdash; Automatically computes appropriate correlations for
the data using Pearson's for continuous, polychoric for ordinal,
tetrachoric for binary, and polyserial/biserial for ordinal/binary with
continuous. To change the number of categories that are considered
ordinal, use <code>ordinal.categories</code>
(see <code><a href="#topic+polychoric.matrix">polychoric.matrix</a></code> for more details)
</p>
</li>
<li> <p><code>"cor_auto"</code> &mdash; Uses <code><a href="qgraph.html#topic+cor_auto">cor_auto</a></code> to compute correlations.
Arguments can be passed along to the function
</p>
</li>
<li> <p><code>"pearson"</code> &mdash; Pearson's correlation is computed for all
variables regardless of categories
</p>
</li>
<li> <p><code>"spearman"</code> &mdash; Spearman's rank-order correlation is computed
for all variables regardless of categories
</p>
</li></ul>

<p>For other similarity measures, compute them first and input them
into <code>data</code> with the sample size (<code>n</code>)</p>
</td></tr>
<tr><td><code id="network.generalizability_+3A_na.data">na.data</code></td>
<td>
<p>Character (length = 1).
How should missing data be handled?
Defaults to <code>"pairwise"</code>.
Available options:
</p>

<ul>
<li> <p><code>"pairwise"</code> &mdash; Computes correlation for all available cases between
two variables
</p>
</li>
<li> <p><code>"listwise"</code> &mdash; Computes correlation for all complete cases in the dataset
</p>
</li></ul>
</td></tr>
<tr><td><code id="network.generalizability_+3A_model">model</code></td>
<td>
<p>Character (length = 1).
Defaults to <code>"glasso"</code>.
Available options:
</p>

<ul>
<li> <p><code>"BGGM"</code> &mdash; Computes the Bayesian Gaussian Graphical Model.
Set argument <code>ordinal.categories</code> to determine
levels allowed for a variable to be considered ordinal.
See <code>?BGGM::estimate</code> for more details
</p>
</li>
<li> <p><code>"glasso"</code> &mdash; Computes the GLASSO with EBIC model selection.
See <code><a href="#topic+EBICglasso.qgraph">EBICglasso.qgraph</a></code> for more details
</p>
</li>
<li> <p><code>"TMFG"</code> &mdash; Computes the TMFG method.
See <code><a href="#topic+TMFG">TMFG</a></code> for more details
</p>
</li></ul>
</td></tr>
<tr><td><code id="network.generalizability_+3A_algorithm">algorithm</code></td>
<td>
<p>Character or
<code><a href="igraph.html#topic+igraph">igraph</a></code> <code>cluster_*</code> function (length = 1).
Defaults to <code>"walktrap"</code>.
Three options are listed below but all are available
(see <code><a href="#topic+community.detection">community.detection</a></code> for other options):
</p>

<ul>
<li> <p><code>"leiden"</code> &mdash; See <code><a href="igraph.html#topic+cluster_leiden">cluster_leiden</a></code> for more details
</p>
</li>
<li> <p><code>"louvain"</code> &mdash; By default, <code>"louvain"</code> will implement the Louvain algorithm using
the consensus clustering method (see <code><a href="#topic+community.consensus">community.consensus</a></code>
for more information). This function will implement
<code>consensus.method = "most_common"</code> and <code>consensus.iter = 1000</code>
unless specified otherwise
</p>
</li>
<li> <p><code>"walktrap"</code> &mdash; See <code><a href="igraph.html#topic+cluster_walktrap">cluster_walktrap</a></code> for more details
</p>
</li></ul>
</td></tr>
<tr><td><code id="network.generalizability_+3A_uni.method">uni.method</code></td>
<td>
<p>Character (length = 1).
What unidimensionality method should be used?
Defaults to <code>"louvain"</code>.
Available options:
</p>

<ul>
<li> <p><code>"expand"</code> &mdash; Expands the correlation matrix with four variables correlated 0.50.
If number of dimension returns 2 or less in check, then the data
are unidimensional; otherwise, regular EGA with no matrix
expansion is used. This method was used in the Golino et al.'s (2020)
<em>Psychological Methods</em> simulation
</p>
</li>
<li> <p><code>"LE"</code> &mdash; Applies the Leading Eigenvector algorithm
(<code><a href="igraph.html#topic+cluster_leading_eigen">cluster_leading_eigen</a></code>)
on the empirical correlation matrix. If the number of dimensions is 1,
then the Leading Eigenvector solution is used; otherwise, regular EGA
is used. This method was used in the Christensen et al.'s (2023)
<em>Behavior Research Methods</em> simulation
</p>
</li>
<li> <p><code>"louvain"</code> &mdash; Applies the Louvain algorithm (<code><a href="igraph.html#topic+cluster_louvain">cluster_louvain</a></code>)
on the empirical correlation matrix. If the number of dimensions is 1,
then the Louvain solution is used; otherwise, regular EGA is used.
This method was validated Christensen's (2022) <em>PsyArXiv</em> simulation.
Consensus clustering can be used by specifying either
<code>"consensus.method"</code> or <code>"consensus.iter"</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="network.generalizability_+3A_seed">seed</code></td>
<td>
<p>Numeric (length = 1).
Defaults to <code>NULL</code> or random results.
Set for reproducible results.
See <a href="https://r-ega.net/articles/reproducibility-prng.html">Reproducibility and PRNG</a>
for more details on random number generation in <code><a href="#topic+EGAnet">EGAnet</a></code></p>
</td></tr>
<tr><td><code id="network.generalizability_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed on to
<code><a href="#topic+auto.correlate">auto.correlate</a></code>,
<code><a href="#topic+network.estimation">network.estimation</a></code>,
<code><a href="#topic+community.detection">community.detection</a></code>,
<code><a href="#topic+community.consensus">community.consensus</a></code>, and
<code><a href="#topic+community.unidimensional">community.unidimensional</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This implementation of network predictability proceeds in several steps
with important assumptions:
</p>
<p>1. Network was estimated using (partial) correlations (not regression like the
<code>mgm</code> package!)
</p>
<p>2. Original data that was used to estimate the network in 1. is necessary to
apply the original scaling to the new data
</p>
<p>3. (Linear) regression-like coefficients are obtained by reserve engineering the
inverse covariance matrix using the network's partial correlations (i.e.,
by setting the diagonal of the network to -1 and computing the inverse
of the opposite signed partial correlation matrix; see <code>EGAnet:::pcor2inv</code>)
</p>
<p>4. Predicted values are obtained by matrix multiplying the new data with these
coefficients
</p>
<p>5. <strong>Dichotomous and polytomous</strong> data are given categorical values based
on the <strong>original data's</strong> thresholds and these thresholds are used to
convert the continuous predicted values into their corresponding categorical values
</p>
<p>6. Evaluation metrics:
</p>

<ul>
<li><p> dichotomous &mdash; Accuracy or the percent correctly predicted for the 0s and 1s
</p>
</li>
<li><p> polytomous &mdash; Accuracy based on the correctly predicting the ordinal category exactly
(i.e., 1 = 1, 2, = 2, etc.) and a weighted accuracy such that absolute distance of the
predicted value from the actual value (e.g., |prediction - actual| = 1) is used
as the power of 0.5. This weighted approach provides an overall distance in terms of
accuracy where each predicted value away from the actual value is given a harsher
penalty (absolute difference = accuracy value): 0 = 1.000, 1 = 0.500, 2 = 0.2500,
3 = 0.1250, 4 = 0.0625, etc.
</p>
</li>
<li><p> continuous &mdash; R-sqaured and root mean square error
</p>
</li></ul>



<h3>Value</h3>

<p>Returns a list containing:
</p>
<table>
<tr><td><code>node</code></td>
<td>
<p>Node-wise metrics output from <code><a href="#topic+network.predictability">network.predictability</a></code></p>
</td></tr>
<tr><td><code>community</code></td>
<td>
<p>Community-wise metrics output from <code><a href="#topic+tefi">tefi</a></code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hudson Golino &lt;hfg9s at virginia.edu&gt; and Alexander P. Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>References</h3>

<p><strong>Original Implementation of Node Predictability</strong> <br />
Haslbeck, J. M., &amp; Waldorp, L. J. (2018).
How well do network models predict observations? On the importance of predictability in network models.
<em>Behavior Research Methods</em>, <em>50</em>(2), 853â€“861.
</p>
<p><strong>Derivation of Regression Coefficients Used (Formula 3)</strong> <br />
Williams, D. R., &amp; Rodriguez, J. E. (2022).
Why overfitting is not (usually) a problem in partial correlation networks.
<em>Psychological Methods</em>, <em>27</em>(5), 822â€“840.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Data splitting
network.generalizability(
  data = wmt2[,7:24], method = "split",
  number = 0.80 # 80/20 training/testing
)

# k-folds cross-validation
network.generalizability(
  data = wmt2[,7:24], method = "cv",
  number = 5 # 5-fold cross-validation
)

## Not run: 
# Leave-one-out cross-validation
network.generalizability(
  data = wmt2[,7:24], method = "loocv"
)
## End(Not run)

</code></pre>

<hr>
<h2 id='network.predictability'>Predict New Data based on Network</h2><span id='topic+network.predictability'></span>

<h3>Description</h3>

<p>General function to compute a network's predictive power on new data,
following Haslbeck and Waldorp (2018) and Williams and Rodriguez (2022)
</p>
<p>This implementation is different from the <code>predictability</code> in the <code>mgm</code> package
(Haslbeck), which is based on (regularized) regression. This implementation uses
the network directly, converting the partial correlations into an implied
precision (inverse covariance) matrix. See <strong>Details</strong> for more information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>network.predictability(network, original.data, newdata, ordinal.categories = 7)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network.predictability_+3A_network">network</code></td>
<td>
<p>Matrix or data frame.
A partial correlation network</p>
</td></tr>
<tr><td><code id="network.predictability_+3A_original.data">original.data</code></td>
<td>
<p>Matrix or data frame.
Must consist only of variables to be used to estimate the <code>network</code>.
See <strong>Examples</strong></p>
</td></tr>
<tr><td><code id="network.predictability_+3A_newdata">newdata</code></td>
<td>
<p>Matrix or data frame.
Must consist of the same variables in the same order as <code>original.data</code>.
See <strong>Examples</strong></p>
</td></tr>
<tr><td><code id="network.predictability_+3A_ordinal.categories">ordinal.categories</code></td>
<td>
<p>Numeric (length = 1).
<em>Up to</em> the number of categories <em>before</em> a variable is considered continuous.
Defaults to <code>7</code> categories before <code>8</code> is considered continuous</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This implementation of network predictability proceeds in several steps
with important assumptions:
</p>
<p>1. Network was estimated using (partial) correlations (not regression like the
<code>mgm</code> package!)
</p>
<p>2. Original data that was used to estimate the network in 1. is necessary to
apply the original scaling to the new data
</p>
<p>3. (Linear) regression-like coefficients are obtained by reserve engineering the
inverse covariance matrix using the network's partial correlations (i.e.,
by setting the diagonal of the network to -1 and computing the inverse
of the opposite signed partial correlation matrix; see <code>EGAnet:::pcor2inv</code>)
</p>
<p>4. Predicted values are obtained by matrix multiplying the new data with these
coefficients
</p>
<p>5. <strong>Dichotomous and polytomous</strong> data are given categorical values based
on the <strong>original data's</strong> thresholds and these thresholds are used to
convert the continuous predicted values into their corresponding categorical values
</p>
<p>6. Evaluation metrics:
</p>

<ul>
<li><p> dichotomous &mdash; <code>"Accuracy"</code> or the percent correctly predicted for the 0s and 1s
and <code>"Kappa"</code> or Cohen's Kappa (see cite)
</p>
</li>
<li><p> polytomous &mdash; <code>"Linear Kappa"</code> or linearly weighted Kappa and
<code>"Krippendorff's alpha"</code> (see cite)
</p>
</li>
<li><p> continuous &mdash; R-squared (<code>"R2"</code>) and root mean square error (<code>"RMSE"</code>)
</p>
</li></ul>



<h3>Value</h3>

<p>Returns a list containing:
</p>
<table>
<tr><td><code>predictions</code></td>
<td>
<p>Predicted values of <code>newdata</code> based on the <code>network</code></p>
</td></tr>
<tr><td><code>betas</code></td>
<td>
<p>Beta coefficients derived from the <code>network</code></p>
</td></tr>
<tr><td><code>results</code></td>
<td>
<p>Performance metrics for each variable in <code>newdata</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hudson Golino &lt;hfg9s at virginia.edu&gt; and Alexander P. Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>References</h3>

<p><strong>Original Implementation of Node Predictability</strong> <br />
Haslbeck, J. M., &amp; Waldorp, L. J. (2018).
How well do network models predict observations? On the importance of predictability in network models.
<em>Behavior Research Methods</em>, <em>50</em>(2), 853â€“861.
</p>
<p><strong>Derivation of Regression Coefficients Used (Formula 3)</strong> <br />
Williams, D. R., &amp; Rodriguez, J. E. (2022).
Why overfitting is not (usually) a problem in partial correlation networks.
<em>Psychological Methods</em>, <em>27</em>(5), 822â€“840.
</p>
<p><strong>Cohen's Kappa</strong> <br />
Cohen, J. (1960). A coefficient of agreement for nominal scales.
<em>Educational and Psychological Measurement</em>, <em>20</em>(1), 37-46.
</p>
<p>Cohen, J. (1968). Weighted kappa: nominal scale agreement provision for scaled disagreement or partial credit.
<em>Psychological Bulletin</em>, <em>70</em>(4), 213-220.
</p>
<p><strong>Krippendorff's alpha</strong> <br />
Krippendorff, K. (2013).
Content analysis: An introduction to its methodology (3rd ed.).
Thousand Oaks, CA: Sage.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
wmt &lt;- wmt2[,7:24]

# Set seed (to reproduce results)
set.seed(42)

# Split data
training &lt;- sample(
  1:nrow(wmt), round(nrow(wmt) * 0.80) # 80/20 split
)

# Set splits
wmt_train &lt;- wmt[training,]
wmt_test &lt;- wmt[-training,]

# EBICglasso (default for EGA functions)
glasso_network &lt;- network.estimation(
  data = wmt_train, model = "glasso"
)

# Check predictability
network.predictability(
  network = glasso_network, original.data = wmt_train,
  newdata = wmt_test
)

</code></pre>

<hr>
<h2 id='optimism'>Optimism Data</h2><span id='topic+optimism'></span>

<h3>Description</h3>

<p>A response matrix (n = 282) containing responses to 10 items of the Revised Life
Orientation Test (LOT-R), developed by Scheier, Carver, &amp; Bridges (1994).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(optimism)
</code></pre>


<h3>Format</h3>

<p>A 282x10 response matrix
</p>


<h3>References</h3>

<p>Scheier, M. F., Carver, C. S., &amp; Bridges, M. W. (1994).
Distinguishing optimism from neuroticism (and trait anxiety, self-mastery, and self-esteem): a reevaluation of the Life Orientation Test.
<em>Journal of Personality and Social Psychology</em>, <em>67</em>, 1063-1078.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("optimism")

</code></pre>

<hr>
<h2 id='polychoric.matrix'>Computes Polychoric Correlations</h2><span id='topic+polychoric.matrix'></span>

<h3>Description</h3>

<p>A fast implementation of polychoric correlations in C.
Uses the Beasley-Springer-Moro algorithm (Boro &amp; Springer, 1977; Moro, 1995)
to estimate the inverse univariate normal CDF, the Drezner-Wesolosky 
approximation (Drezner &amp; Wesolosky, 1990) to estimate the bivariate normal
CDF, and Brent's method (Brent, 2013) for optimization of rho
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polychoric.matrix(
  data,
  na.data = c("pairwise", "listwise"),
  empty.method = c("none", "zero", "all"),
  empty.value = c("none", "point_five", "one_over"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="polychoric.matrix_+3A_data">data</code></td>
<td>
<p>Matrix or data frame.
A dataset with all ordinal values
(rows = cases, columns = variables).
Data are required to be between <code>0</code> and <code>11</code>.
Proper adjustments should be made prior to analysis (e.g.,
scales from -3 to 3 in increments of 1 should be shifted
by added 4 to all values)</p>
</td></tr>
<tr><td><code id="polychoric.matrix_+3A_na.data">na.data</code></td>
<td>
<p>Character (length = 1).
How should missing data be handled?
Defaults to <code>"pairwise"</code>.
Available options:
</p>

<ul>
<li> <p><code>"pairwise"</code> &mdash; Computes correlation for all available cases between
two variables
</p>
</li>
<li> <p><code>"listwise"</code> &mdash; Computes correlation for all complete cases in the dataset
</p>
</li></ul>
</td></tr>
<tr><td><code id="polychoric.matrix_+3A_empty.method">empty.method</code></td>
<td>
<p>Character (length = 1).
Method for empty cell correction.
Available options:
</p>

<ul>
<li> <p><code>"none"</code> &mdash; Adds no value (<code>empty.value = "none"</code>)
to the empirical joint frequency table between two variables
</p>
</li>
<li> <p><code>"zero"</code> &mdash; Adds <code>empty.value</code> to the cells with zero
in the joint frequency table between two variables
</p>
</li>
<li> <p><code>"all"</code> &mdash; Adds <code>empty.value</code> to all
in the joint frequency table between two variables
</p>
</li></ul>
</td></tr>
<tr><td><code id="polychoric.matrix_+3A_empty.value">empty.value</code></td>
<td>
<p>Character (length = 1).
Value to add to the joint frequency table cells.
Accepts numeric values between 0 and 1 or
specific methods:
</p>

<ul>
<li> <p><code>"none"</code> &mdash; Adds no value (<code>0</code>) to the empirical joint
frequency table between two variables
</p>
</li>
<li> <p><code>"point_five"</code> &mdash; Adds <code>0.5</code> to the cells defined by <code>empty.method</code>
</p>
</li>
<li> <p><code>"one_over"</code> &mdash; Adds <code>1 / n</code> where <em>n</em> equals the number of cells
based on <code>empty.method</code>. For <code>empty.method = "zero"</code>,
<em>n</em> equals the number of <em>zero</em> cells
</p>
</li></ul>
</td></tr>
<tr><td><code id="polychoric.matrix_+3A_...">...</code></td>
<td>
<p>Not used but made available for easier
argument passing</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a polychoric correlation matrix
</p>


<h3>Author(s)</h3>

<p>Alexander P. Christensen &lt;alexpaulchristensen@gmail.com&gt; with assistance from GPT-4
</p>


<h3>References</h3>

<p><strong>Beasley-Moro-Springer algorithm</strong> <br />
Beasley, J. D., &amp; Springer, S. G. (1977).
Algorithm AS 111: The percentage points of the normal distribution.
<em>Journal of the Royal Statistical Society. Series C (Applied Statistics)</em>, <em>26</em>(1), 118-121.
</p>
<p>Moro, B. (1995).
The full monte.
<em>Risk 8 (February)</em>, 57-58.
</p>
<p><strong>Brent optimization</strong> <br />
Brent, R. P. (2013). 
Algorithms for minimization without derivatives.
Mineola, NY: Dover Publications, Inc.
</p>
<p><strong>Drezner-Wesolowsky bivariate normal approximation</strong> <br />
Drezner, Z., &amp; Wesolowsky, G. O. (1990).
On the computation of the bivariate normal integral.
<em>Journal of Statistical Computation and Simulation</em>, <em>35</em>(1-2), 101-107.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data (ensure matrix for missing data example)
wmt &lt;- as.matrix(wmt2[,7:24])

# Compute polychoric correlation matrix
correlations &lt;- polychoric.matrix(wmt)

# Randomly assign missing data
wmt[sample(1:length(wmt), 1000)] &lt;- NA

# Compute polychoric correlation matrix 
# with pairwise missing
pairwise_correlations &lt;- polychoric.matrix(
  wmt, na.data = "pairwise"
)

# Compute polychoric correlation matrix 
# with listwise missing
pairwise_correlations &lt;- polychoric.matrix(
  wmt, na.data = "listwise"
)

</code></pre>

<hr>
<h2 id='prime.num'>Prime Numbers through 100,000</h2><span id='topic+prime.num'></span>

<h3>Description</h3>

<p>Numeric vector of primes generated from the primes package. Used in
the function <code>[EGAnet]{ergoInfo}</code>. Not for general use
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(prime.num)
</code></pre>


<h3>Format</h3>

<p>A 1185x24 response matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("prime.num")

</code></pre>

<hr>
<h2 id='riEGA'>Random-Intercept <code><a href="#topic+EGA">EGA</a></code></h2><span id='topic+riEGA'></span>

<h3>Description</h3>

<p>Estimates the number of substantive dimensions after controlling 
for wording effects. EGA is applied to a residual correlation matrix after 
subtracting and random intercept factor with equal unstandardized loadings 
from all the regular and unrecoded reversed items in the database
</p>


<h3>Usage</h3>

<pre><code class='language-R'>riEGA(
  data,
  n = NULL,
  corr = c("auto", "cor_auto", "pearson", "spearman"),
  na.data = c("pairwise", "listwise"),
  model = c("glasso", "TMFG"),
  algorithm = c("leiden", "louvain", "walktrap"),
  uni.method = c("expand", "LE", "louvain"),
  estimator = c("auto", "WLSMV", "MLR"),
  plot.EGA = TRUE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="riEGA_+3A_data">data</code></td>
<td>
<p>Matrix or data frame.
Should consist only of variables to be used in the analysis.
<strong>Must</strong> be raw data and not a correlation matrix</p>
</td></tr>
<tr><td><code id="riEGA_+3A_n">n</code></td>
<td>
<p>Numeric (length = 1).
Sample size if <code>data</code> provided is a correlation matrix</p>
</td></tr>
<tr><td><code id="riEGA_+3A_corr">corr</code></td>
<td>
<p>Character (length = 1).
Method to compute correlations.
Defaults to <code>"auto"</code>.
Available options:
</p>

<ul>
<li> <p><code>"auto"</code> &mdash; Automatically computes appropriate correlations for
the data using Pearson's for continuous, polychoric for ordinal,
tetrachoric for binary, and polyserial/biserial for ordinal/binary with
continuous. To change the number of categories that are considered
ordinal, use <code>ordinal.categories</code>
(see <code><a href="#topic+polychoric.matrix">polychoric.matrix</a></code> for more details)
</p>
</li>
<li> <p><code>"cor_auto"</code> &mdash; Uses <code><a href="qgraph.html#topic+cor_auto">cor_auto</a></code> to compute correlations. 
Arguments can be passed along to the function
</p>
</li>
<li> <p><code>"pearson"</code> &mdash; Pearson's correlation is computed for all 
variables regardless of categories
</p>
</li>
<li> <p><code>"spearman"</code> &mdash; Spearman's rank-order correlation is computed 
for all variables regardless of categories
</p>
</li></ul>

<p>For other similarity measures, compute them first and input them
into <code>data</code> with the sample size (<code>n</code>)</p>
</td></tr>
<tr><td><code id="riEGA_+3A_na.data">na.data</code></td>
<td>
<p>Character (length = 1).
How should missing data be handled?
Defaults to <code>"pairwise"</code>.
Available options:
</p>

<ul>
<li> <p><code>"pairwise"</code> &mdash; Computes correlation for all available cases between
two variables
</p>
</li>
<li> <p><code>"listwise"</code> &mdash; Computes correlation for all complete cases in the dataset
</p>
</li></ul>
</td></tr>
<tr><td><code id="riEGA_+3A_model">model</code></td>
<td>
<p>Character (length = 1).
Defaults to <code>"glasso"</code>.
Available options:
</p>

<ul>
<li> <p><code>"BGGM"</code> &mdash; Computes the Bayesian Gaussian Graphical Model.
Set argument <code>ordinal.categories</code> to determine
levels allowed for a variable to be considered ordinal.
See <code>?BGGM::estimate</code> for more details
</p>
</li>
<li> <p><code>"glasso"</code> &mdash; Computes the GLASSO with EBIC model selection.
See <code><a href="#topic+EBICglasso.qgraph">EBICglasso.qgraph</a></code> for more details
</p>
</li>
<li> <p><code>"TMFG"</code> &mdash; Computes the TMFG method.
See <code><a href="#topic+TMFG">TMFG</a></code> for more details
</p>
</li></ul>
</td></tr>
<tr><td><code id="riEGA_+3A_algorithm">algorithm</code></td>
<td>
<p>Character or 
<code><a href="igraph.html#topic+igraph">igraph</a></code> <code>cluster_*</code> function (length = 1).
Defaults to <code>"walktrap"</code>.
Three options are listed below but all are available
(see <code><a href="#topic+community.detection">community.detection</a></code> for other options):
</p>

<ul>
<li> <p><code>"leiden"</code> &mdash; See <code><a href="igraph.html#topic+cluster_leiden">cluster_leiden</a></code> for more details
</p>
</li>
<li> <p><code>"louvain"</code> &mdash; By default, <code>"louvain"</code> will implement the Louvain algorithm using 
the consensus clustering method (see <code><a href="#topic+community.consensus">community.consensus</a></code> 
for more information). This function will implement
<code>consensus.method = "most_common"</code> and <code>consensus.iter = 1000</code> 
unless specified otherwise
</p>
</li>
<li> <p><code>"walktrap"</code> &mdash; See <code><a href="igraph.html#topic+cluster_walktrap">cluster_walktrap</a></code> for more details
</p>
</li></ul>
</td></tr>
<tr><td><code id="riEGA_+3A_uni.method">uni.method</code></td>
<td>
<p>Character (length = 1).
What unidimensionality method should be used? 
Defaults to <code>"louvain"</code>.
Available options:
</p>

<ul>
<li> <p><code>"expand"</code> &mdash; Expands the correlation matrix with four variables correlated 0.50.
If number of dimension returns 2 or less in check, then the data 
are unidimensional; otherwise, regular EGA with no matrix
expansion is used. This method was used in the Golino et al.'s (2020)
<em>Psychological Methods</em> simulation
</p>
</li>
<li> <p><code>"LE"</code> &mdash; Applies the Leading Eigenvector algorithm
(<code><a href="igraph.html#topic+cluster_leading_eigen">cluster_leading_eigen</a></code>)
on the empirical correlation matrix. If the number of dimensions is 1,
then the Leading Eigenvector solution is used; otherwise, regular EGA
is used. This method was used in the Christensen et al.'s (2023) 
<em>Behavior Research Methods</em> simulation
</p>
</li>
<li> <p><code>"louvain"</code> &mdash; Applies the Louvain algorithm (<code><a href="igraph.html#topic+cluster_louvain">cluster_louvain</a></code>)
on the empirical correlation matrix. If the number of dimensions is 1, 
then the Louvain solution is used; otherwise, regular EGA is used. 
This method was validated Christensen's (2022) <em>PsyArXiv</em> simulation.
Consensus clustering can be used by specifying either
<code>"consensus.method"</code> or <code>"consensus.iter"</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="riEGA_+3A_estimator">estimator</code></td>
<td>
<p>Character (length = 1).
Estimator to use for random-intercept model (see <a href="https://lavaan.ugent.be/tutorial/est.html">Estimators</a>
for more details).
Defaults to <code>"auto"</code>, which selects <code>"MLR"</code> for continuous data and
<code>"WLSMV"</code> for mixed and categorical data.
Data are considered continuous data if they have <code>8</code> or
more categories (see Rhemtulla, Brosseau-Liard, &amp; Savalei, 2012).
To change this behavior, set <code>oridinal.categories</code> as an argument</p>
</td></tr>
<tr><td><code id="riEGA_+3A_plot.ega">plot.EGA</code></td>
<td>
<p>Boolean (length = 1).
If <code>TRUE</code>, returns a plot of the network and its estimated dimensions.
Defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="riEGA_+3A_verbose">verbose</code></td>
<td>
<p>Boolean (length = 1).
Whether messages and (insignificant) warnings should be output.
Defaults to <code>FALSE</code> (silent calls).
Set to <code>TRUE</code> to see all messages and warnings for every function call</p>
</td></tr>
<tr><td><code id="riEGA_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed on to
<code><a href="#topic+auto.correlate">auto.correlate</a></code>, 
<code><a href="#topic+network.estimation">network.estimation</a></code>,
<code><a href="#topic+community.detection">community.detection</a></code>,
<code><a href="#topic+community.consensus">community.consensus</a></code>, and
<code><a href="#topic+EGA">EGA</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing:
</p>
<table>
<tr><td><code>EGA</code></td>
<td>
<p>Results from <code><a href="#topic+EGA">EGA</a></code></p>
</td></tr>
<tr><td><code>RI</code></td>
<td>
<p>A list containing information about the random-intercept
model (if the model converged):
</p>

<ul>
<li> <p><code>fit</code> &mdash; The fit object for the random-intercept model using <code><a href="lavaan.html#topic+cfa">cfa</a></code>
</p>
</li>
<li> <p><code>lavaan.args</code> &mdash; The arguments used in <code><a href="lavaan.html#topic+cfa">cfa</a></code>
</p>
</li>
<li> <p><code>loadings</code> &mdash; Standardized loadings from the random-intercept model
</p>
</li>
<li> <p><code>correlation</code> &mdash; Residual correlations after accounting for the random-intercept model
</p>
</li></ul>

</td></tr>
<tr><td><code>TEFI</code></td>
<td>
<p><code>link[EGAnet]{tefi}</code> for the estimated structure</p>
</td></tr>
<tr><td><code>plot.EGA</code></td>
<td>
<p>Plot output if <code>plot.EGA = TRUE</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alejandro Garcia-Pardina &lt;alejandrogp97@gmail.com&gt;,
Francisco J. Abad &lt;fjose.abad@uam.es&gt;,
Alexander P. Christensen &lt;alexpaulchristensen@gmail.com&gt;,
Hudson Golino &lt;hfg9s at virginia.edu&gt;,
Luis Eduardo Garrido &lt;luisgarrido@pucmm.edu.do&gt;, and
Robert Moulder &lt;rgm4fd@virginia.edu&gt;
</p>


<h3>References</h3>

<p><strong>Selection of CFA Estimator</strong> <br />
Rhemtulla, M., Brosseau-Liard, P. E., &amp; Savalei, V. (2012).
When can categorical variables be treated as continuous? A comparison of robust continuous and categorical SEM estimation methods under suboptimal conditions.
<em>Psychological Methods</em>, <em>17</em>, 354-373.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.EGAnet">plot.EGAnet</a></code> for plot usage in <code><a href="#topic+EGAnet">EGAnet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Obtain example data
wmt &lt;- wmt2[,7:24]

# riEGA example
riEGA(data = wmt, plot.EGA = FALSE)
# no plot for CRAN checks

</code></pre>

<hr>
<h2 id='sim.dynEGA'>sim.dynEGA Data</h2><span id='topic+sim.dynEGA'></span>

<h3>Description</h3>

<p>A simulated (multivariate time series) data with 24 variables,
100 individual observations, 50 time points per individual and 
2 groups of individuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sim.dynEGA)
</code></pre>


<h3>Format</h3>

<p>A 5000 x 26 multivariate time series
</p>


<h3>Details</h3>

<p>Data were generated using the <code><a href="#topic+simDFM">simDFM</a></code> function
with the following arguments:
</p>
<p><strong>Group 1</strong>
</p>
<p><code>simDFM(
 variab = 12, timep = 50,
 nfact = 2, error = 0.125,
 dfm = "DAFS", 
 loadings = EGAnet:::runif_xoshiro(
   1, min = 0.50, max = 0.70
 ), autoreg = 0.80, crossreg = 0.00,
 var.shock = 0.36, cov.shock = 0.18
)</code>
</p>
<p><strong>Group 2</strong>
</p>
<p><code>simDFM(
 variab = 8, timep = 50,
 nfact = 3, error = 0.125,
 dfm = "DAFS", 
 loadings = EGAnet:::runif_xoshiro(
   1, min = 0.50, max = 0.70
 ), autoreg = 0.80, crossreg = 0.00,
 var.shock = 0.36, cov.shock = 0.18
)</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("sim.dynEGA")

</code></pre>

<hr>
<h2 id='simDFM'>Simulate data following a Dynamic Factor Model</h2><span id='topic+simDFM'></span>

<h3>Description</h3>

<p>Function to simulate data following a dynamic factor model (DFM). Two DFMs are currently available:
the direct autoregressive factor score model (Engle &amp; Watson, 1981; Nesselroade, McArdle, Aggen, and Meyers, 2002) and the
dynamic factor model with random walk factor scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simDFM(
  variab,
  timep,
  nfact,
  error,
  dfm = c("DAFS", "RandomWalk"),
  loadings,
  autoreg,
  crossreg,
  var.shock,
  cov.shock,
  burnin = 1000,
  variation = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simDFM_+3A_variab">variab</code></td>
<td>
<p>Number of variables per factor.</p>
</td></tr>
<tr><td><code id="simDFM_+3A_timep">timep</code></td>
<td>
<p>Number of time points.</p>
</td></tr>
<tr><td><code id="simDFM_+3A_nfact">nfact</code></td>
<td>
<p>Number of factors.</p>
</td></tr>
<tr><td><code id="simDFM_+3A_error">error</code></td>
<td>
<p>Value to be used to construct a diagonal matrix Q. This matrix is p x p covariance matrix Q that will
generate random errors following a multivariate normal distribution with mean zeros.
The value provided is squared before constructing Q.</p>
</td></tr>
<tr><td><code id="simDFM_+3A_dfm">dfm</code></td>
<td>
<p>A string indicating the dynamical factor model to use.
Current options are:
</p>

<ul>
<li> <p><strong><code>DAFS</code></strong> &mdash; Simulates data using the direct autoregressive factor score model.
This is the default method
</p>
</li>
<li> <p><strong><code>RandomWalk</code></strong> &mdash; Simulates data using a dynamic factor model with random walk factor scores
</p>
</li></ul>
</td></tr>
<tr><td><code id="simDFM_+3A_loadings">loadings</code></td>
<td>
<p>Magnitude of the loadings.</p>
</td></tr>
<tr><td><code id="simDFM_+3A_autoreg">autoreg</code></td>
<td>
<p>Magnitude of the autoregression coefficients.</p>
</td></tr>
<tr><td><code id="simDFM_+3A_crossreg">crossreg</code></td>
<td>
<p>Magnitude of the cross-regression coefficients.</p>
</td></tr>
<tr><td><code id="simDFM_+3A_var.shock">var.shock</code></td>
<td>
<p>Magnitude of the random shock variance.</p>
</td></tr>
<tr><td><code id="simDFM_+3A_cov.shock">cov.shock</code></td>
<td>
<p>Magnitude of the random shock covariance</p>
</td></tr>
<tr><td><code id="simDFM_+3A_burnin">burnin</code></td>
<td>
<p>Number of n first samples to discard when computing the factor scores. Defaults to 1000.</p>
</td></tr>
<tr><td><code id="simDFM_+3A_variation">variation</code></td>
<td>
<p>Boolean.
Whether parameters should be varied.
Defaults to <code>FALSE</code>.
Set to <code>TRUE</code> to add slight variation to all parameters</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hudson F. Golino &lt;hfg9s at virginia.edu&gt;
</p>


<h3>References</h3>

<p>Engle, R., &amp; Watson, M. (1981).
A one-factor multivariate time series model of metropolitan wage rates.
<em>Journal of the American Statistical Association</em>, <em>76</em>(376), 774-781.
</p>
<p>Nesselroade, J. R., McArdle, J. J., Aggen, S. H., &amp; Meyers, J. M. (2002).
Dynamic factor analysis models for representing process in multivariate time-series. In D. S. Moskowitz &amp; S. L. Hershberger (Eds.),
<em>Multivariate applications book series. Modeling intraindividual variability with repeated measures data: Methods and applications</em>, 235-265.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Estimate EGA network
data1 &lt;- simDFM(variab = 5, timep = 50, nfact = 3, error = 0.05,
dfm = "DAFS", loadings = 0.7, autoreg = 0.8,
crossreg = 0.1, var.shock = 0.36,
cov.shock = 0.18, burnin = 1000)
## End(Not run)

</code></pre>

<hr>
<h2 id='tefi'>Total Entropy Fit Index using Von Neumman's entropy (Quantum Information Theory) for correlation matrices</h2><span id='topic+tefi'></span>

<h3>Description</h3>

<p>Computes the fit (TEFI) of a dimensionality structure using Von Neumman's entropy 
when the input is a correlation matrix. Lower values suggest better fit of a structure to the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tefi(data, structure = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tefi_+3A_data">data</code></td>
<td>
<p>Matrix, data frame, or <code>*EGA</code> class object.
Matrix or data frame can be raw data or a correlation matrix.
All <code>*EGA</code> objects are accepted. <code><a href="#topic+hierEGA">hierEGA</a></code>
input will produced the Generalized TEFI (see <code><a href="#topic+genTEFI">genTEFI</a></code>)</p>
</td></tr>
<tr><td><code id="tefi_+3A_structure">structure</code></td>
<td>
<p>Numeric or character vector (length = <code>ncol(data)</code>).
Can be theoretical factors or the structure detected by <code><a href="#topic+EGA">EGA</a></code></p>
</td></tr>
<tr><td><code id="tefi_+3A_verbose">verbose</code></td>
<td>
<p>Boolean (length = 1).
Whether messages and (insignificant) warnings should be output.
Defaults to <code>TRUE</code> to see all messages and warnings for every 
function call.
Set to <code>FALSE</code> to ignore messages and warnings</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame with columns:
</p>
<p><strong>Non-hierarchical Structure</strong>
</p>
<table>
<tr><td><code>VN.Entropy.Fit</code></td>
<td>
<p>The Total Entropy Fit Index using Von Neumman's entropy</p>
</td></tr>
<tr><td><code>Total.Correlation</code></td>
<td>
<p>The total correlation of the dataset</p>
</td></tr>
<tr><td><code>Average.Entropy</code></td>
<td>
<p>The average entropy of the dataset</p>
</td></tr>
</table>
<p><strong>Hierarchical Structure</strong>
</p>
<table>
<tr><td><code>VN.Entropy.Fit</code></td>
<td>
<p>The Generalized Total Entropy Fit Index using Von Neumman's entropy</p>
</td></tr>
<tr><td><code>Lower.Order.VN</code></td>
<td>
<p>Lower order (only) Total Entropy Fit Index</p>
</td></tr>
<tr><td><code>Higher.Order.VN</code></td>
<td>
<p>Higher order (only) Total Entropy Fit Index</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hudson Golino &lt;hfg9s at virginia.edu&gt;, Alexander P. Christensen &lt;alexpaulchristensen@gmail.com&gt;, and Robert Moulder &lt;rgm4fd@virginia.edu&gt;
</p>


<h3>References</h3>

<p><strong>Initial formalization and simulation</strong> <br />
Golino, H., Moulder, R. G., Shi, D., Christensen, A. P., Garrido, L. E., Nieto, M. D., Nesselroade, J., Sadana, R., Thiyagarajan, J. A., &amp; Boker, S. M. (2020).
Entropy fit indices: New fit measures for assessing the structure and dimensionality of multiple latent variables.
<em>Multivariate Behavioral Research</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
wmt &lt;- wmt2[,7:24]

# Estimate EGA model
ega.wmt &lt;- EGA(
  data = wmt, model = "glasso",
  plot.EGA = FALSE # no plot for CRAN checks
)

# Compute entropy indices for empirical EGA
tefi(ega.wmt)

# User-defined structure (with `EGA` object)
tefi(ega.wmt, structure = c(rep(1, 5), rep(2, 5), rep(3, 8)))

</code></pre>

<hr>
<h2 id='TMFG'>Triangulated Maximally Filtered Graph</h2><span id='topic+TMFG'></span>

<h3>Description</h3>

<p>Applies the Triangulated Maximally Filtered Graph (TMFG) filtering method
(see Massara et al., 2016). The TMFG method uses a structural
constraint that limits the number of zero-order correlations included in the network
(3<em>n</em> - 6; where <em>n</em> is the number of variables). The TMFG algorithm begins by
identifying four variables which have the largest sum of correlations to all other
variables. Then, it iteratively adds each variable with the largest sum of three
correlations to nodes already in the network until all variables have been added to
the network. This structure can be associated with the inverse correlation matrix
(i.e., precision matrix) to be turned into a GGM (i.e., partial correlation network)
by using Local-Global Inversion Method (LoGo; see Barfuss et al., 2016 for more details).
See <strong>Details</strong> for more information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TMFG(
  data,
  n = NULL,
  corr = c("auto", "cor_auto", "pearson", "spearman"),
  na.data = c("pairwise", "listwise"),
  partial = FALSE,
  returnAllResults = FALSE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TMFG_+3A_data">data</code></td>
<td>
<p>Matrix or data frame.
Should consist only of variables to be used in the analysis.
Can be raw data or correlation matrix</p>
</td></tr>
<tr><td><code id="TMFG_+3A_n">n</code></td>
<td>
<p>Numeric (length = 1).
Sample size for when a correlation matrix is input into <code>data</code>.
Defaults to <code>NULL</code>.
<code>n</code> is not necessary and is provided for better functionality in
<code><a href="#topic+EGAnet">EGAnet</a></code></p>
</td></tr>
<tr><td><code id="TMFG_+3A_corr">corr</code></td>
<td>
<p>Character (length = 1).
Method to compute correlations.
Defaults to <code>"auto"</code>.
Available options:
</p>

<ul>
<li> <p><code>"auto"</code> &mdash; Automatically computes appropriate correlations for
the data using Pearson's for continuous, polychoric for ordinal,
tetrachoric for binary, and polyserial/biserial for ordinal/binary with
continuous. To change the number of categories that are considered
ordinal, use <code>ordinal.categories</code>
(see <code><a href="#topic+polychoric.matrix">polychoric.matrix</a></code> for more details)
</p>
</li>
<li> <p><code>"cor_auto"</code> &mdash; Uses <code><a href="qgraph.html#topic+cor_auto">cor_auto</a></code> to compute correlations.
Arguments can be passed along to the function
</p>
</li>
<li> <p><code>"pearson"</code> &mdash; Pearson's correlation is computed for all
variables regardless of categories
</p>
</li>
<li> <p><code>"spearman"</code> &mdash; Spearman's rank-order correlation is computed
for all variables regardless of categories
</p>
</li></ul>

<p>For other similarity measures, compute them first and input them
into <code>data</code> with the sample size (<code>n</code>)</p>
</td></tr>
<tr><td><code id="TMFG_+3A_na.data">na.data</code></td>
<td>
<p>Character (length = 1).
How should missing data be handled?
Defaults to <code>"pairwise"</code>.
Available options:
</p>

<ul>
<li> <p><code>"pairwise"</code> &mdash; Computes correlation for all available cases between
two variables
</p>
</li>
<li> <p><code>"listwise"</code> &mdash; Computes correlation for all complete cases in the dataset
</p>
</li></ul>
</td></tr>
<tr><td><code id="TMFG_+3A_partial">partial</code></td>
<td>
<p>Boolean (length = 1).
Whether partial correlations should be output.
Defaults to <code>FALSE</code>.
The TMFG method is based on the zero-order correlations;
the Local-Global Inversion Method (LoGo; see Barfuss et al., 2016 for more details)
uses the decomposability of the TMFG network to obtain the inverse covariance
structure of the network (which is then converted to partial correlations).
Set to <code>TRUE</code> to obtain the partial correlations from the LoGo method</p>
</td></tr>
<tr><td><code id="TMFG_+3A_returnallresults">returnAllResults</code></td>
<td>
<p>Boolean (length = 1).
Whether all results should be returned.
Defaults to <code>FALSE</code> (network only).
Set to <code>TRUE</code> to access separators and cliques</p>
</td></tr>
<tr><td><code id="TMFG_+3A_verbose">verbose</code></td>
<td>
<p>Boolean (length = 1).
Whether messages and (insignificant) warnings should be output.
Defaults to <code>FALSE</code> (silent calls).
Set to <code>TRUE</code> to see all messages and warnings for every function call</p>
</td></tr>
<tr><td><code id="TMFG_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed on to
<code><a href="#topic+auto.correlate">auto.correlate</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The TMFG method applies a structural constraint on the network,
which restrains the network to retain a certain number of edges (3<em>n</em>-6, where <em>n</em>
is the number of nodes; Massara et al., 2016). The network is also composed of 3- and 4-node
cliques (i.e., sets of connected nodes; a triangle and tetrahedron, respectively). The
TMFG method constructs a network using zero-order correlations and the resulting network
can be associated with the inverse covariance matrix
(yielding a GGM; Barfuss, Massara, Di Matteo, &amp; Aste, 2016).
Notably, the TMFG can use any association measure and thus does not assume the data is multivariate normal.
</p>
<p>Construction begins by forming a tetrahedron of the four nodes that have
the highest sum of correlations that are greater than the average correlation in the
correlation matrix. Next, the algorithm iteratively identifies the node that maximizes
its sum of correlations to a connected set of three nodes (triangles) already included
in the network and then adds that node to the network. The process is completed once
every node is connected in the network. In this process, the network automatically
generates what's called a planar network. A planar network is a network that could be
drawn on a sphere with no edges crossing (often, however, the networks are depicted
with edges crossing; Tumminello, Aste, Di Matteo, &amp; Mantegna, 2005).
</p>


<h3>Value</h3>

<p>Returns a network or list containing:
</p>
<table>
<tr><td><code>network</code></td>
<td>
<p>The filtered adjacency matrix</p>
</td></tr>
<tr><td><code>separators</code></td>
<td>
<p>The separators (3-cliques) in the network</p>
</td></tr>
<tr><td><code>cliques</code></td>
<td>
<p>The cliques (4-cliques) in the network</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alexander Christensen &lt;alexpaulchristensen@gmail.com&gt;
</p>


<h3>References</h3>

<p><strong>Local-Global Inversion Method</strong> <br />
Barfuss, W., Massara, G. P., Di Matteo, T., &amp; Aste, T. (2016).
Parsimonious modeling with information filtering networks.
<em>Physical Review E</em>, <em>94</em>, 062306.
</p>
<p><strong>Psychometric network introduction to TMFG</strong> <br />
Christensen, A. P., Kenett, Y. N., Aste, T., Silvia, P. J., &amp; Kwapil, T. R. (2018).
Network structure of the Wisconsin Schizotypy Scales-Short Forms: Examining psychometric network filtering approaches.
<em>Behavior Research Methods</em>, <em>50</em>, 2531-2550.
</p>
<p><strong>Triangulated Maximally Filtered Graph</strong> <br />
Massara, G. P., Di Matteo, T., &amp; Aste, T. (2016).
Network filtering for big data: Triangulated maximally filtered graph.
<em>Journal of Complex Networks</em>, <em>5</em>, 161-178.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># TMFG filtered network
TMFG(wmt2[,7:24])

# Partial correlations using the LoGo method
TMFG(wmt2[,7:24], partial = TRUE)

</code></pre>

<hr>
<h2 id='totalCor'>Total Correlation</h2><span id='topic+totalCor'></span>

<h3>Description</h3>

<p>Computes the total correlation of a dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>totalCor(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="totalCor_+3A_data">data</code></td>
<td>
<p>Matrix or data frame.
Should consist only of variables to be used in the analysis</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing:
</p>
<table>
<tr><td><code>Ind.Entropies</code></td>
<td>
<p>Individual entropies for each variable</p>
</td></tr>
<tr><td><code>Joint.Entropy</code></td>
<td>
<p>The joint entropy of the dataset</p>
</td></tr>
<tr><td><code>Total.Cor</code></td>
<td>
<p>The total correlation of the dataset</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hudson F. Golino &lt;hfg9s at virginia.edu&gt;
</p>


<h3>References</h3>

<p><strong>Formalization of total correlation</strong> <br />
Watanabe, S. (1960).
Information theoretical analysis of multivariate correlation.
<em>IBM Journal of Research and Development</em> <em>4</em>, 66-82.
</p>
<p><strong>Applied implementation</strong> <br />
Felix, L. M., Mansur-Alves, M., Teles, M., Jamison, L., &amp; Golino, H. (2021).
Longitudinal impact and effects of booster sessions in a cognitive training program for healthy older adults.
<em>Archives of Gerontology and Geriatrics</em>, <em>94</em>, 104337.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute total correlation
totalCor(wmt2[,7:24])

</code></pre>

<hr>
<h2 id='totalCorMat'>Total Correlation Matrix</h2><span id='topic+totalCorMat'></span>

<h3>Description</h3>

<p>Computes the pairwise total correlation
(<code><a href="#topic+totalCor">totalCor</a></code>) for a dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>totalCorMat(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="totalCorMat_+3A_data">data</code></td>
<td>
<p>Matrix or data frame.
Should consist only of variables to be used in the analysis</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a symmetric matrix with pairwise total correlations
</p>


<h3>Author(s)</h3>

<p>Hudson F. Golino &lt;hfg9s at virginia.edu&gt;
</p>


<h3>References</h3>

<p><strong>Formalization of total correlation</strong> <br />
Watanabe, S. (1960).
Information theoretical analysis of multivariate correlation.
<em>IBM Journal of Research and Development</em> <em>4</em>, 66-82.
</p>
<p><strong>Applied implementation</strong> <br />
Felix, L. M., Mansur-Alves, M., Teles, M., Jamison, L., &amp; Golino, H. (2021).
Longitudinal impact and effects of booster sessions in a cognitive training program for healthy older adults.
<em>Archives of Gerontology and Geriatrics</em>, <em>94</em>, 104337.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute total correlation matrix
totalCorMat(wmt2[,7:24])

</code></pre>

<hr>
<h2 id='UVA'>Unique Variable Analysis</h2><span id='topic+UVA'></span>

<h3>Description</h3>

<p>Identifies locally dependent (redundant) variables in a 
multivariate dataset using the <code><a href="#topic+EBICglasso.qgraph">EBICglasso.qgraph</a></code> 
network estimation method and weighted topological overlap
(see Christensen, Garrido, &amp; Golino, 2023 for more details)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UVA(
  data = NULL,
  network = NULL,
  n = NULL,
  key = NULL,
  uva.method = c("MBR", "EJP"),
  cut.off = 0.25,
  reduce = TRUE,
  reduce.method = c("latent", "mean", "remove", "sum"),
  auto = TRUE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UVA_+3A_data">data</code></td>
<td>
<p>Matrix or data frame.
Should consist only of variables to be used in the analysis.
Can be raw data or a correlation matrix.
Defaults to <code>NULL</code></p>
</td></tr>
<tr><td><code id="UVA_+3A_network">network</code></td>
<td>
<p>Symmetric matrix or data frame.
A symmetric network.
Defaults to <code>NULL</code>
</p>
<p>If both <code>data</code> and <code>network</code> are provided,
then <code>UVA</code> will use the <code>network</code>
with the <code>data</code> (rather than estimating a 
network from the <code>data</code>)</p>
</td></tr>
<tr><td><code id="UVA_+3A_n">n</code></td>
<td>
<p>Numeric (length = 1).
Sample size if <code>data</code> provided is a correlation matrix.
Defaults to <code>NULL</code></p>
</td></tr>
<tr><td><code id="UVA_+3A_key">key</code></td>
<td>
<p>Character vector (length = <code>ncol(data)</code>).
Item key for labeling variables in the results</p>
</td></tr>
<tr><td><code id="UVA_+3A_uva.method">uva.method</code></td>
<td>
<p>Character (length = 1).
Whether the method described in Christensen, Garrido, and
Golino (2023) publication in <em>Multivariate Behavioral Research</em>
(<code>"MBR"</code>) or Christensen, Golino, and Silvia (2020) publication
in <em>European Journal of Personality</em> (<code>"EJP"</code>) should be used.
Defaults to <code>"MBR"</code>
</p>
<p>Based on simulation and accumulating empirical evidence, the methods
described in Christensen, Golino, and Silvia (2020) such as 
adaptive alpha are <strong>outdated</strong>. Evidence supports using a 
single cut-off value (regardless of continuous, polytomous, or
dichotomous data; Christensen, Garrido, &amp; Golino, 2023)</p>
</td></tr>
<tr><td><code id="UVA_+3A_cut.off">cut.off</code></td>
<td>
<p>Numeric (length = 1).
Cut-off used to determine when pairwise <code><a href="#topic+wto">wto</a></code>
values are considered locally dependent (or redundant).
Must be values between <code>0</code> and <code>1</code>.
Defaults to <code>0.25</code>
</p>
<p>This cut-off value is <strong>recommended</strong> and based on extensive simulation
(Christensen, Garrido, &amp; Golino, 2023). Printing the result will
provide a gradient of pairwise redundancies in increments of 0.20,
0.25, and 0.30. Use <code>print</code> or <code>summary</code> on the output
rather than adjusting this cut-off value</p>
</td></tr>
<tr><td><code id="UVA_+3A_reduce">reduce</code></td>
<td>
<p>Logical (length = 1).
Whether redundancies should be reduced in data.
Defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="UVA_+3A_reduce.method">reduce.method</code></td>
<td>
<p>Character (length = 1).
Method to reduce redundancies.
Available options:
</p>

<ul>
<li> <p><code>"latent"</code> &mdash; Computes latent variables using <code><a href="lavaan.html#topic+cfa">cfa</a></code> when 
there are three or more redundant variables. If variables are not 
all coded in the same direction, then they will be recoded as necessary.
A warning will be produced for all variables that are flipped
</p>
</li>
<li> <p><code>"mean"</code> &mdash; Computes mean of redundant variables. If variables are not all coded in the
same direction, then they will be recoded as necessary.
A warning will be produced for all variables that are flipped
</p>
</li>
<li> <p><code>"remove"</code> &mdash; Removes all but one variable from a set of redundant variables
</p>
</li>
<li> <p><code>"sum"</code> &mdash; Computes sum of redundant variables. If variables are not all coded in the
same direction, then they will be recoded as necessary.
A warning will be produced for all variables that are flipped
</p>
</li></ul>
</td></tr>
<tr><td><code id="UVA_+3A_auto">auto</code></td>
<td>
<p>Logical (length = 1).
Whether <code>reduce</code> should occur automatically. For
<code>reduce.method = "remove"</code>, the automated decision
process is as follows:
</p>

<ul>
<li> <p><code>Two variables</code> &mdash; The variable with the lowest maximum <code><a href="#topic+wto">wto</a></code> 
to all other variables (other than the one it is redundant with)
is retained and the other is removed
</p>
</li>
<li> <p><code>Three or more variables</code> &mdash; The variable with the highest mean <code><a href="#topic+wto">wto</a></code>
to all other variables that are redundant with one another
is retained and all others are removed
</p>
</li></ul>
</td></tr>
<tr><td><code id="UVA_+3A_verbose">verbose</code></td>
<td>
<p>Boolean (length = 1).
Whether messages and (insignificant) warnings should be output.
Defaults to <code>FALSE</code> (silent calls).
Set to <code>TRUE</code> to see all messages and warnings for every function call</p>
</td></tr>
<tr><td><code id="UVA_+3A_...">...</code></td>
<td>
<p>Additional arguments that should be passed on to 
old versions of <code>UVA</code> or to
<code><a href="#topic+EGA">EGA</a></code> and
<code><a href="lavaan.html#topic+cfa">cfa</a></code></p>
</td></tr>
</table>


<h3>References</h3>

<p><strong>Most recent simulation and implementation</strong> <br />
Christensen, A. P., Garrido, L. E., &amp; Golino, H. (2023).
Unique variable analysis: A network psychometrics method to detect local dependence.
<em>Multivariate Behavioral Research</em>.
</p>
<p><strong>Conceptual foundation and outdated methods</strong> <br />
Christensen, A. P., Golino, H., &amp; Silvia, P. J. (2020).
A psychometric network perspective on the validity and validation of personality trait questionnaires.
<em>European Journal of Personality</em>, <em>34</em>(6), 1095-1108.
</p>
<p><strong>Weighted topological overlap</strong> <br />
Nowick, K., Gernat, T., Almaas, E., &amp; Stubbs, L. (2009).
Differences in human and chimpanzee gene expression patterns define an evolving network of transcription factors in brain.
<em>Proceedings of the National Academy of Sciences</em>, <em>106</em>, 22358-22363.
</p>
<p><strong>Selection of CFA Estimator</strong> <br />
Rhemtulla, M., Brosseau-Liard, P. E., &amp; Savalei, V. (2012).
When can categorical variables be treated as continuous? A comparison of robust continuous and categorical SEM estimation methods under suboptimal conditions.
<em>Psychological Methods</em>, <em>17</em>(3), 354-373.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Perform UVA
uva.wmt &lt;- UVA(wmt2[,7:24])

# Show summary
summary(uva.wmt)

</code></pre>

<hr>
<h2 id='vn.entropy'>Entropy Fit Index using Von Neumman's entropy (Quantum Information Theory) for correlation matrices</h2><span id='topic+vn.entropy'></span>

<h3>Description</h3>

<p>Computes the fit of a dimensionality structure using Von Neumman's 
entropy when the input is a correlation matrix. Lower values suggest better 
fit of a structure to the data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vn.entropy(data, structure)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vn.entropy_+3A_data">data</code></td>
<td>
<p>Matrix or data frame.
Contains variables to be used in the analysis</p>
</td></tr>
<tr><td><code id="vn.entropy_+3A_structure">structure</code></td>
<td>
<p>Numeric or character vector (length = <code>ncol(data)</code>).
A vector representing the structure (numbers or labels for each item).
Can be theoretical factors or the structure detected by <code><a href="#topic+EGA">EGA</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing:
</p>
<table>
<tr><td><code>VN.Entropy.Fit</code></td>
<td>
<p>The Entropy Fit Index using Von Neumman's entropy</p>
</td></tr>
<tr><td><code>Total.Correlation</code></td>
<td>
<p>The total correlation of the dataset</p>
</td></tr>
<tr><td><code>Average.Entropy</code></td>
<td>
<p>The average entropy of the dataset</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hudson Golino &lt;hfg9s at virginia.edu&gt;, Alexander P. Christensen &lt;alexpaulchristensen@gmail.com&gt;, and Robert Moulder &lt;rgm4fd@virginia.edu&gt;
</p>


<h3>References</h3>

<p><strong>Initial formalization and simulation</strong> <br />
Golino, H., Moulder, R. G., Shi, D., Christensen, A. P., Garrido, L. E., Nieto, M. D., Nesselroade, J., Sadana, R., Thiyagarajan, J. A., &amp; Boker, S. M. (2020).
Entropy fit indices: New fit measures for assessing the structure and dimensionality of multiple latent variables.
<em>Multivariate Behavioral Research</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get EGA result
ega.wmt &lt;- EGA(
  data = wmt2[,7:24], model = "glasso",
  plot.EGA = FALSE # no plot for CRAN checks
)

# Compute Von Neumman entropy
vn.entropy(ega.wmt$correlation, ega.wmt$wc)

</code></pre>

<hr>
<h2 id='wmt2'>WMT-2 Data</h2><span id='topic+wmt2'></span>

<h3>Description</h3>

<p>A response matrix (n = 1185) of the Wiener Matrizen-Test 2 (WMT-2).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(wmt2)
</code></pre>


<h3>Format</h3>

<p>A 1185x24 response matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("wmt2")

</code></pre>

<hr>
<h2 id='wto'>Weighted Topological Overlap</h2><span id='topic+wto'></span>

<h3>Description</h3>

<p>Computes weighted topological overlap following
the Novick et al. (2009) definition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wto(network, signed = TRUE, diagonal.zero = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wto_+3A_network">network</code></td>
<td>
<p>Symmetric matrix or data frame.
A symmetric network</p>
</td></tr>
<tr><td><code id="wto_+3A_signed">signed</code></td>
<td>
<p>Boolean (length = 1).
Whether the signed version should be used.
Defaults to <code>TRUE</code>.
Use <code>FALSE</code> for absolute values</p>
</td></tr>
<tr><td><code id="wto_+3A_diagonal.zero">diagonal.zero</code></td>
<td>
<p>Boolean (length = 1).
Whether diagonal of overlap matrix should be set to zero.
Defaults to <code>TRUE</code>.
Use <code>FALSE</code> to allow overlap of a node with itself</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A symmetric matrix of weighted topological overlap
values between each pair of variables
</p>


<h3>References</h3>

<p><strong>Original formalization</strong> <br />
Nowick, K., Gernat, T., Almaas, E., &amp; Stubbs, L. (2009).
Differences in human and chimpanzee gene expression patterns define an evolving network of transcription factors in brain.
<em>Proceedings of the National Academy of Sciences</em>, <em>106</em>, 22358-22363.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Obtain network
network &lt;- network.estimation(wmt2[,7:24], model = "glasso")

# Compute wTO
wto(network)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
