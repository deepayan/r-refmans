<!DOCTYPE html><html><head><title>Help for package walker</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {walker}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as.data.frame.walker_fit'><p>Coerce Posterior Samples of walker Fit to a Data Frame</p></a></li>
<li><a href='#coef.walker_fit'><p>Extract Coeffients of Walker Fit</p></a></li>
<li><a href='#fitted.walker_fit'><p>Extract Fitted Values of Walker Fit</p></a></li>
<li><a href='#lfo'><p>Leave-Future-Out Cross-Validation</p></a></li>
<li><a href='#plot_coefs'><p>Posterior predictive check for walker object</p></a></li>
<li><a href='#plot_fit'><p>Plot the fitted values and sample quantiles for a walker object</p></a></li>
<li><a href='#plot_predict'><p>Prediction intervals for walker object</p></a></li>
<li><a href='#pp_check.walker_fit'><p>Posterior predictive check for walker object</p></a></li>
<li><a href='#predict_counterfactual'><p>Predictions for walker object</p></a></li>
<li><a href='#predict.walker_fit'><p>Predictions for walker object</p></a></li>
<li><a href='#print.walker_fit'><p>Print Summary of walker_fit Object</p></a></li>
<li><a href='#rw1'><p>Construct a first-order random walk component</p></a></li>
<li><a href='#rw2'><p>Construct a second-order random walk component</p></a></li>
<li><a href='#summary.walker_fit'><p>Summary of walker_fit Object</p></a></li>
<li><a href='#walker'><p>Bayesian regression with random walk coefficients</p></a></li>
<li><a href='#walker_glm'><p>Bayesian generalized linear model with time-varying coefficients</p></a></li>
<li><a href='#walker_rw1'><p>Comparison of naive and state space implementation of RW1 regression model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Generalized Linear Models with Time-Varying
Coefficients</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.8</td>
</tr>
<tr>
<td>Description:</td>
<td>Efficient Bayesian generalized linear models with time-varying coefficients 
    as in Helske (2022, &lt;<a href="https://doi.org/10.1016%2Fj.softx.2022.101016">doi:10.1016/j.softx.2022.101016</a>&gt;). Gaussian, Poisson, and binomial 
    observations are supported. The Markov chain Monte Carlo (MCMC) computations are done using 
    Hamiltonian Monte Carlo provided by Stan, using a state space representation 
    of the model in order to marginalise over the coefficients for efficient sampling. 
    For non-Gaussian models, the package uses the importance sampling type estimators based on 
    approximate marginal MCMC as in Vihola, Helske, Franks (2020, &lt;<a href="https://doi.org/10.1111%2Fsjos.12492">doi:10.1111/sjos.12492</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>diagis, gridExtra, knitr (&ge; 1.11), rmarkdown (&ge; 0.8.1),
testthat</td>
</tr>
<tr>
<td>Depends:</td>
<td>bayesplot, R (&ge; 3.4.0), Rcpp (&ge; 0.12.9), rstan (&ge; 2.26.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>coda, dplyr, Hmisc, ggplot2, KFAS, loo, methods, RcppParallel,
rlang, rstantools (&ge; 2.0.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>StanHeaders (&ge; 2.26.0), rstan (&ge; 2.26.0), BH (&ge; 1.66.0),
Rcpp (&ge; 0.12.9), RcppArmadillo, RcppEigen (&ge; 0.3.3.3.0),
RcppParallel</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/helske/walker">https://github.com/helske/walker</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/helske/walker/issues">https://github.com/helske/walker/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-11 12:04:59 UTC; jvhels</td>
</tr>
<tr>
<td>Author:</td>
<td>Jouni Helske <a href="https://orcid.org/0000-0001-7130-793X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jouni Helske &lt;jouni.helske@iki.fi&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-11 13:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='as.data.frame.walker_fit'>Coerce Posterior Samples of walker Fit to a Data Frame</h2><span id='topic+as.data.frame.walker_fit'></span>

<h3>Description</h3>

<p>Creates a data.frame object from the output of walker fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'walker_fit'
as.data.frame(x, row.names = NULL, optional = FALSE, type, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.walker_fit_+3A_x">x</code></td>
<td>
<p>An output from <code><a href="#topic+walker">walker</a></code> or <code><a href="#topic+walker_glm">walker_glm</a></code>.</p>
</td></tr>
<tr><td><code id="as.data.frame.walker_fit_+3A_row.names">row.names</code></td>
<td>
<p><code>NULL</code> (default) or a character vector giving the row names 
for the data frame.</p>
</td></tr>
<tr><td><code id="as.data.frame.walker_fit_+3A_optional">optional</code></td>
<td>
<p>Ignored (part of generic <code>as.data.frame</code> signature).</p>
</td></tr>
<tr><td><code id="as.data.frame.walker_fit_+3A_type">type</code></td>
<td>
<p>Either <code>tiv</code> (time-invariant parameters) or <code>tv</code> (time-varying coefficients).</p>
</td></tr>
<tr><td><code id="as.data.frame.walker_fit_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 as.data.frame(fit, "tiv") %&gt;% 
 group_by(variable) %&gt;%
 summarise(mean = mean(value),
           lwr = quantile(value, 0.05),
           upr = quantile(value, 0.95))

## End(Not run)

</code></pre>

<hr>
<h2 id='coef.walker_fit'>Extract Coeffients of Walker Fit</h2><span id='topic+coef.walker_fit'></span>

<h3>Description</h3>

<p>Returns the time-varying regression coefficients from output of <code>walker</code> or <code>walker_glm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'walker_fit'
coef(object, summary = TRUE, transform = identity, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.walker_fit_+3A_object">object</code></td>
<td>
<p>Output of <code>walker</code> or <code>walker_glm</code>.</p>
</td></tr>
<tr><td><code id="coef.walker_fit_+3A_summary">summary</code></td>
<td>
<p>If <code>TRUE</code> (default), return summary statistics. Otherwise returns samples.</p>
</td></tr>
<tr><td><code id="coef.walker_fit_+3A_transform">transform</code></td>
<td>
<p>Optional vectorized function for transforming the coefficients (for example exp).</p>
</td></tr>
<tr><td><code id="coef.walker_fit_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Time series containing coefficient values.
</p>

<hr>
<h2 id='fitted.walker_fit'>Extract Fitted Values of Walker Fit</h2><span id='topic+fitted.walker_fit'></span>

<h3>Description</h3>

<p>Returns fitted values (posterior means) from output of <code>walker</code> or <code>walker_glm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'walker_fit'
fitted(object, summary = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.walker_fit_+3A_object">object</code></td>
<td>
<p>Output of <code>walker</code> or <code>walker_glm</code>.</p>
</td></tr>
<tr><td><code id="fitted.walker_fit_+3A_summary">summary</code></td>
<td>
<p>If <code>TRUE</code> (default), return summary statistics. Otherwise returns samples.</p>
</td></tr>
<tr><td><code id="fitted.walker_fit_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>summary=TRUE</code>, matrix containing summary statistics of fitted values. 
Otherwise a matrix of samples.
</p>

<hr>
<h2 id='lfo'>Leave-Future-Out Cross-Validation</h2><span id='topic+lfo'></span>

<h3>Description</h3>

<p>Estimates the leave-future-out (LFO) information criterion for <code>walker</code> and <code>walker_glm</code> models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lfo(object, L, exact = FALSE, verbose = TRUE, k_thres = 0.7)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lfo_+3A_object">object</code></td>
<td>
<p>Output of <code>walker</code> or <code>walker_glm</code>.</p>
</td></tr>
<tr><td><code id="lfo_+3A_l">L</code></td>
<td>
<p>Positive integer defining how many observations should be used for the initial fit.</p>
</td></tr>
<tr><td><code id="lfo_+3A_exact">exact</code></td>
<td>
<p>If <code>TRUE</code>, computes exact 1-step predictions by re-estimating the model repeatedly. 
If <code>FALSE</code> (default), uses approximate method based on BÃ¼rkner, Gabry and Vehtari (2020).</p>
</td></tr>
<tr><td><code id="lfo_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> (default), print the progress of the LFO computations to the console.</p>
</td></tr>
<tr><td><code id="lfo_+3A_k_thres">k_thres</code></td>
<td>
<p>Threshold for the pareto k estimate triggering refit. Default is 0.7.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The LFO for non-Gaussian models is (currently) based on the corresponding Gaussian approximation and 
not the importance sampling corrected true posterior.
</p>


<h3>Value</h3>

<p>List with components <code>ELPD</code> (Expected log predictive density), <code>ELPDs</code> (observation-specific ELPDs),
<code>ks</code> (Pareto k values in case of approximation was used), and <code>refits</code> (time points where model was re-estimated)
</p>


<h3>References</h3>

<p>Paul-Christian BÃ¼rkner, Jonah Gabry &amp; Aki Vehtari (2020). 
Approximate leave-future-out cross-validation for Bayesian time series models, 
Journal of Statistical Computation and Simulation, 90:14, 2499-2523, DOI: 10.1080/00949655.2020.1783262.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fit &lt;- walker(Nile ~ -1 + 
  rw1(~ 1, 
    beta = c(1000, 100), 
    sigma = c(2, 0.001)), 
  sigma_y_prior = c(2, 0.005), 
  iter = 2000, chains = 1)
 
fit_lfo &lt;- lfo(fit, L = 20, exact = FALSE)
fit_lfo$ELPD

## End(Not run)
</code></pre>

<hr>
<h2 id='plot_coefs'>Posterior predictive check for walker object</h2><span id='topic+plot_coefs'></span>

<h3>Description</h3>

<p>Plots sample quantiles from posterior predictive sample. 
See <code><a href="bayesplot.html#topic+ppc_ribbon">ppc_ribbon</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_coefs(
  object,
  level = 0.05,
  alpha = 0.33,
  transform = identity,
  scales = "fixed",
  add_zero = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_coefs_+3A_object">object</code></td>
<td>
<p>An output from <code><a href="#topic+walker">walker</a></code>.</p>
</td></tr>
<tr><td><code id="plot_coefs_+3A_level">level</code></td>
<td>
<p>Level for intervals. Default is 0.05, leading to 90% intervals.</p>
</td></tr>
<tr><td><code id="plot_coefs_+3A_alpha">alpha</code></td>
<td>
<p>Transparency level for <code>geom_ribbon</code>.</p>
</td></tr>
<tr><td><code id="plot_coefs_+3A_transform">transform</code></td>
<td>
<p>Optional vectorized function for transforming the coefficients (for example <code>exp</code>).</p>
</td></tr>
<tr><td><code id="plot_coefs_+3A_scales">scales</code></td>
<td>
<p>Should y-axis of the panels be <code>"fixed"</code> (default) or <code>"free"</code>?</p>
</td></tr>
<tr><td><code id="plot_coefs_+3A_add_zero">add_zero</code></td>
<td>
<p>Logical, should a dashed line indicating a zero be included?</p>
</td></tr>
</table>

<hr>
<h2 id='plot_fit'>Plot the fitted values and sample quantiles for a walker object</h2><span id='topic+plot_fit'></span>

<h3>Description</h3>

<p>Plot the fitted values and sample quantiles for a walker object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_fit(object, level = 0.05, alpha = 0.33, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_fit_+3A_object">object</code></td>
<td>
<p>An output from <code><a href="#topic+walker">walker</a></code> or <code><a href="#topic+walker_glm">walker_glm</a></code>.</p>
</td></tr>
<tr><td><code id="plot_fit_+3A_level">level</code></td>
<td>
<p>Level for intervals. Default is 0.05, leading to 90% intervals.</p>
</td></tr>
<tr><td><code id="plot_fit_+3A_alpha">alpha</code></td>
<td>
<p>Transparency level for <code>geom_ribbon</code>.</p>
</td></tr>
<tr><td><code id="plot_fit_+3A_...">...</code></td>
<td>
<p>Further arguments to <code><a href="bayesplot.html#topic+ppc_ribbon">ppc_ribbon</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='plot_predict'>Prediction intervals for walker object</h2><span id='topic+plot_predict'></span>

<h3>Description</h3>

<p>Plots sample quantiles and posterior means of the predictions 
of the <code>predict.walker_fit</code> output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_predict(object, draw_obs = NULL, level = 0.05, alpha = 0.33)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_predict_+3A_object">object</code></td>
<td>
<p>An output from <code><a href="#topic+predict.walker_fit">predict.walker_fit</a></code>.</p>
</td></tr>
<tr><td><code id="plot_predict_+3A_draw_obs">draw_obs</code></td>
<td>
<p>Either <code>"response"</code>, <code>"mean"</code>, or <code>"none"</code>, 
where <code>"mean"</code> is response variable divided by number of trials or exposures 
in case of binomial/poisson models.</p>
</td></tr>
<tr><td><code id="plot_predict_+3A_level">level</code></td>
<td>
<p>Level for intervals. Default is 0.05, leading to 90% intervals.</p>
</td></tr>
<tr><td><code id="plot_predict_+3A_alpha">alpha</code></td>
<td>
<p>Transparency level for <code><a href="ggplot2.html#topic+geom_ribbon">geom_ribbon</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
n &lt;- 60
slope &lt;- 0.0001 + cumsum(rnorm(n, 0, sd = 0.01))
beta &lt;- numeric(n)
beta[1] &lt;- 1
for(i in 2:n) beta[i] &lt;- beta[i-1] + slope[i-1]
ts.plot(beta)                
x &lt;- rnorm(n, 1, 0.5)
alpha &lt;- 2
ts.plot(beta * x)

signal &lt;- alpha + beta * x
y &lt;- rnorm(n, signal, 0.25)
ts.plot(cbind(signal, y), col = 1:2)
data_old &lt;- data.frame(y = y[1:(n-10)], x = x[1:(n-10)])

# note very small number of iterations for the CRAN checks!
rw2_fit &lt;- walker(y ~ 1 + 
                    rw2(~ -1 + x,
                        beta = c(0, 10), 
                        nu = c(0, 10)),
                  beta = c(0, 10), data = data_old,
                  iter = 300, chains = 1, init = 0, refresh = 0)

pred &lt;- predict(rw2_fit, newdata = data.frame(x=x[(n-9):n]))
data_new &lt;- data.frame(t = (n-9):n, y = y[(n-9):n])
plot_predict(pred) + 
  ggplot2::geom_line(data = data_new, ggplot2:: aes(t, y), 
  linetype = "dashed", colour = "red", inherit.aes = FALSE)

</code></pre>

<hr>
<h2 id='pp_check.walker_fit'>Posterior predictive check for walker object</h2><span id='topic+pp_check.walker_fit'></span>

<h3>Description</h3>

<p>Plots sample quantiles from posterior predictive sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'walker_fit'
pp_check(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pp_check.walker_fit_+3A_object">object</code></td>
<td>
<p>An output from <code><a href="#topic+walker">walker</a></code>.</p>
</td></tr>
<tr><td><code id="pp_check.walker_fit_+3A_...">...</code></td>
<td>
<p>Further parameters to <code><a href="bayesplot.html#topic+ppc_ribbon">ppc_ribbon</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For other types of posterior predictive checks for example with <code>bayesplot</code>, 
you can extract the variable <code>yrep</code> from the output, see examples.#'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Extracting the yrep variable for general use:
# extract yrep
y_rep &lt;- extract(object$stanfit, pars = "y_rep", permuted = TRUE)$y_rep

# For non-gaussian model:
weights &lt;- extract(object$stanfit, pars = "weights", permuted = TRUE)$weights
y_rep &lt;- y_rep[sample(1:nrow(y_rep), 
  size = nrow(y_rep), replace = TRUE, prob = weights), , drop = FALSE]

## End(Not run)

</code></pre>

<hr>
<h2 id='predict_counterfactual'>Predictions for walker object</h2><span id='topic+predict_counterfactual'></span>

<h3>Description</h3>

<p>Given the new covariate data and output from <code>walker</code>, 
obtain samples from posterior predictive distribution for counterfactual case,
i.e. for past time points with different covariate values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_counterfactual(
  object,
  newdata,
  u,
  summary = TRUE,
  type = ifelse(object$distribution == "gaussian", "response", "mean")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_counterfactual_+3A_object">object</code></td>
<td>
<p>An output from <code><a href="#topic+walker">walker</a></code> or <code><a href="#topic+walker_glm">walker_glm</a></code>.</p>
</td></tr>
<tr><td><code id="predict_counterfactual_+3A_newdata">newdata</code></td>
<td>
<p>A <code>data.frame</code> containing covariates used for prediction. 
Should have equal number of rows as the original data</p>
</td></tr>
<tr><td><code id="predict_counterfactual_+3A_u">u</code></td>
<td>
<p>For Poisson model, a vector of exposures i.e. E(y) = u*exp(x*beta). 
For binomial, a vector containing the number of trials. Defaults 1.</p>
</td></tr>
<tr><td><code id="predict_counterfactual_+3A_summary">summary</code></td>
<td>
<p>If <code>TRUE</code> (default), return summary statistics. Otherwise returns samples.</p>
</td></tr>
<tr><td><code id="predict_counterfactual_+3A_type">type</code></td>
<td>
<p>If <code>"response"</code> (default for Gaussian model), predictions are on the response level 
(e.g., number of successes for Binomial case, and for Gaussian case the observational 
level noise is added to the mean predictions).
If <code>"mean"</code> (default for non-Gaussian case), predict means (e.g., success probabilities in Binomial case).
If <code>"link"</code>, predictions for non-Gaussian models are returned before applying the inverse of the link-function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>summary=TRUE</code>, time series containing summary statistics of predicted values. 
Otherwise a matrix of samples from predictive distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(1)
n &lt;- 50
x1 &lt;- rnorm(n, 0, 1)
x2 &lt;- rnorm(n, 1, 0.5)
x3 &lt;- rnorm(n)
beta1 &lt;- cumsum(c(1, rnorm(n - 1, sd = 0.1)))
beta2 &lt;- cumsum(c(0, rnorm(n - 1, sd = 0.1)))
beta3 &lt;- -1
u &lt;- sample(1:10, size = n, replace = TRUE)
y &lt;- rbinom(n, u, plogis(beta3 * x3 + beta1 * x1 + beta2 * x2))

d &lt;- data.frame(y, x1, x2, x3)
out &lt;- walker_glm(y ~ x3 + rw1(~ -1 + x1 + x2, beta = c(0, 2), 
  sigma = c(2, 10)), distribution = "binomial", beta = c(0, 2), 
  u = u, data = d,
  iter = 2000, chains = 1, refresh = 0)

# what if our covariates were constant?
newdata &lt;- data.frame(x1 = rep(0.4, n), x2 = 1, x3 = -0.1)

fitted &lt;- fitted(out)
pred &lt;- predict_counterfactual(out, newdata, type = "mean")

ts.plot(cbind(fitted[, c(1, 3, 5)], pred[, c(1, 3, 5)]), 
  col = rep(1:2, each = 3), lty = c(1, 2, 2))

## End(Not run)
</code></pre>

<hr>
<h2 id='predict.walker_fit'>Predictions for walker object</h2><span id='topic+predict.walker_fit'></span>

<h3>Description</h3>

<p>Given the new covariate data and output from <code>walker</code>, 
obtain samples from posterior predictive distribution for future time points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'walker_fit'
predict(
  object,
  newdata,
  u,
  type = ifelse(object$distribution == "gaussian", "response", "mean"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.walker_fit_+3A_object">object</code></td>
<td>
<p>An output from <code><a href="#topic+walker">walker</a></code> or <code><a href="#topic+walker_glm">walker_glm</a></code>.</p>
</td></tr>
<tr><td><code id="predict.walker_fit_+3A_newdata">newdata</code></td>
<td>
<p>A <code>data.frame</code> containing covariates used for prediction.</p>
</td></tr>
<tr><td><code id="predict.walker_fit_+3A_u">u</code></td>
<td>
<p>For Poisson model, a vector of future exposures i.e. E(y) = u*exp(x*beta). 
For binomial, a vector containing the number of trials for future time points. Defaults 1.</p>
</td></tr>
<tr><td><code id="predict.walker_fit_+3A_type">type</code></td>
<td>
<p>If <code>"response"</code> (default for Gaussian model), predictions are on the response level 
(e.g., number of successes for Binomial case, and for Gaussian case the observational 
level noise is added to the mean predictions).
If <code>"mean"</code> (default for non-Gaussian case), predict means (e.g., success probabilities in Binomial case).
If <code>"link"</code>, predictions for non-Gaussian models are returned before applying the inverse of the link-function.</p>
</td></tr>
<tr><td><code id="predict.walker_fit_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing samples from posterior predictive distribution.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_predict">plot_predict</a></code> for example.
</p>

<hr>
<h2 id='print.walker_fit'>Print Summary of walker_fit Object</h2><span id='topic+print.walker_fit'></span>

<h3>Description</h3>

<p>Prints the summary information of time-invariant model parameters. In case of non-Gaussian models, 
results based on approximate model are returned with a warning.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'walker_fit'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.walker_fit_+3A_x">x</code></td>
<td>
<p>An output from <code><a href="#topic+walker">walker</a></code> or <code><a href="#topic+walker_glm">walker_glm</a></code>.</p>
</td></tr>
<tr><td><code id="print.walker_fit_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code><a href="rstan.html#topic+print.stanfit">print.stanfit</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='rw1'>Construct a first-order random walk component</h2><span id='topic+rw1'></span>

<h3>Description</h3>

<p>Auxiliary function used inside of the formula of <code>walker</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rw1(formula, data, beta, sigma = c(2, 1e-04), gamma = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rw1_+3A_formula">formula</code></td>
<td>
<p>Formula for RW1 part of the model. Only right-hand-side is used.</p>
</td></tr>
<tr><td><code id="rw1_+3A_data">data</code></td>
<td>
<p>Optional data.frame.</p>
</td></tr>
<tr><td><code id="rw1_+3A_beta">beta</code></td>
<td>
<p>A length vector of length two which defines the 
prior mean and standard deviation of the Gaussian prior for coefficients at time 1.</p>
</td></tr>
<tr><td><code id="rw1_+3A_sigma">sigma</code></td>
<td>
<p>A vector of length two, defining the Gamma prior for 
the coefficient level standard deviation. First element corresponds to the shape parameter and 
second to the rate parameter. Default is Gamma(2, 0.0001).</p>
</td></tr>
<tr><td><code id="rw1_+3A_gamma">gamma</code></td>
<td>
<p>An optional k times n matrix defining a known non-negative weights of the 
random walk noises, where k is the number of coefficients and n is the 
number of time points. Then, the standard deviation of the random walk noise
for each coefficient is of form gamma_t * sigma (instead of just sigma).</p>
</td></tr>
</table>

<hr>
<h2 id='rw2'>Construct a second-order random walk component</h2><span id='topic+rw2'></span>

<h3>Description</h3>

<p>Auxiliary function used inside of the formula of <code>walker</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rw2(formula, data, beta, sigma = c(2, 1e-04), nu, gamma = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rw2_+3A_formula">formula</code></td>
<td>
<p>Formula for RW2 part of the model. Only right-hand-side is used.</p>
</td></tr>
<tr><td><code id="rw2_+3A_data">data</code></td>
<td>
<p>Optional data.frame.</p>
</td></tr>
<tr><td><code id="rw2_+3A_beta">beta</code></td>
<td>
<p>A vector of length two which defines the 
prior mean and standard deviation of the Gaussian prior for coefficients at time 1.</p>
</td></tr>
<tr><td><code id="rw2_+3A_sigma">sigma</code></td>
<td>
<p>A vector of length two, defining the Gamma prior for 
the slope level standard deviation. First element corresponds to the shape parameter and 
second to the rate parameter. Default is Gamma(2, 0.0001).</p>
</td></tr>
<tr><td><code id="rw2_+3A_nu">nu</code></td>
<td>
<p>A vector of length two which defines the 
prior mean and standard deviation of the Gaussian prior for the slopes nu at time 1.</p>
</td></tr>
<tr><td><code id="rw2_+3A_gamma">gamma</code></td>
<td>
<p>An optional k times n matrix defining a known non-negative 
weights of the slope noises, where k is the number of coefficients 
and n is the number of time points. Then, the standard deviation of the 
noise term for each coefficient's slope is of form gamma_t * sigma 
(instead of just sigma).</p>
</td></tr>
</table>

<hr>
<h2 id='summary.walker_fit'>Summary of walker_fit Object</h2><span id='topic+summary.walker_fit'></span>

<h3>Description</h3>

<p>Return summary information of time-invariant model parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'walker_fit'
summary(object, type = "tiv", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.walker_fit_+3A_object">object</code></td>
<td>
<p>An output from <code><a href="#topic+walker">walker</a></code> or <code><a href="#topic+walker_glm">walker_glm</a></code>.</p>
</td></tr>
<tr><td><code id="summary.walker_fit_+3A_type">type</code></td>
<td>
<p>Either <code>tiv</code> (time-invariant parameters, the default) or <code>tv</code> (time-varying coefficients).</p>
</td></tr>
<tr><td><code id="summary.walker_fit_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>

<hr>
<h2 id='walker'>Bayesian regression with random walk coefficients</h2><span id='topic+walker'></span>

<h3>Description</h3>

<p>Function <code>walker</code> performs Bayesian inference of a linear 
regression model with time-varying, random walk regression coefficients, 
i.e. ordinary regression model where instead of constant coefficients the 
coefficients follow first or second order random walks. 
All Markov chain Monte Carlo computations are done using Hamiltonian 
Monte Carlo provided by Stan, using a state space representation of the model 
in order to marginalise over the coefficients for efficient sampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>walker(
  formula,
  data,
  sigma_y_prior = c(2, 0.01),
  beta,
  init,
  chains,
  return_x_reg = FALSE,
  gamma_y = NULL,
  return_data = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="walker_+3A_formula">formula</code></td>
<td>
<p>An object of class <code>{formula}</code> with additional terms 
<code>rw1</code> and/or <code>rw2</code> e.g. <code>y ~ x1 + rw1(~ -1 + x2)</code>. See details.</p>
</td></tr>
<tr><td><code id="walker_+3A_data">data</code></td>
<td>
<p>An optional data.frame or object coercible to such, as in <code>{lm}</code>.</p>
</td></tr>
<tr><td><code id="walker_+3A_sigma_y_prior">sigma_y_prior</code></td>
<td>
<p>A vector of length two, defining the a Gamma prior for 
the observation level standard deviation with first element corresponding to the shape parameter and 
second to rate parameter. Default is Gamma(2, 0.0001). Not used in <code>walker_glm</code>.</p>
</td></tr>
<tr><td><code id="walker_+3A_beta">beta</code></td>
<td>
<p>A length vector of length two which defines the 
prior mean and standard deviation of the Gaussian prior for time-invariant coefficients</p>
</td></tr>
<tr><td><code id="walker_+3A_init">init</code></td>
<td>
<p>Initial value specification, see <code><a href="rstan.html#topic+sampling">sampling</a></code>. 
Note that compared to default in <code>rstan</code>, here the default is a to sample from the priors.</p>
</td></tr>
<tr><td><code id="walker_+3A_chains">chains</code></td>
<td>
<p>Number of Markov chains. Default is 4.</p>
</td></tr>
<tr><td><code id="walker_+3A_return_x_reg">return_x_reg</code></td>
<td>
<p>If <code>TRUE</code>, does not perform sampling, but instead returns the matrix of 
predictors after processing the <code>formula</code>.</p>
</td></tr>
<tr><td><code id="walker_+3A_gamma_y">gamma_y</code></td>
<td>
<p>An optional vector defining known non-negative weights for the standard 
deviation of the observational level noise at each time point. 
More specifically, the observational level standard deviation sigma_t is 
defined as <code class="reqn">\sigma_t = gamma_t * \sigma_y</code> (in default case 
<code class="reqn">\sigma_t = sigma_y</code>)</p>
</td></tr>
<tr><td><code id="walker_+3A_return_data">return_data</code></td>
<td>
<p>if <code>TRUE</code>, returns data input to <code>sampling</code>. This is needed for
<code>lfo</code>.</p>
</td></tr>
<tr><td><code id="walker_+3A_...">...</code></td>
<td>
<p>Further arguments to <code><a href="rstan.html#topic+sampling">sampling</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>rw1</code> and <code>rw2</code> functions used in the formula define new formulas 
for the first and second order random walks. In addition, these functions 
need to be supplied with priors for initial coefficients and the 
standard deviations. For second order random walk model, these sigma priors 
correspond to the standard deviation of slope disturbances. For <code>rw2</code>, 
also a prior for the initial slope nu needs to be defined. See examples.
</p>


<h3>Value</h3>

<p>A list containing the <code>stanfit</code> object, observations <code>y</code>,
and covariates <code>xreg</code> and <code>xreg_new</code>.
</p>


<h3>Note</h3>

<p>Beware of overfitting and identifiability issues. In particular, 
be careful in not defining multiple intercept terms 
(only one should be present).
By default <code>rw1</code> and <code>rw2</code> calls add their own time-varying 
intercepts, so you should use <code>0</code> or <code>-1</code> to remove some of them 
(or the time-invariant intercept in the fixed-part of the formula).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+walker_glm">walker_glm</a></code> for non-Gaussian models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
set.seed(1)
x &lt;- rnorm(10)
y &lt;- x + rnorm(10)

# different intercept definitions:

# both fixed intercept and time-varying level,
# can be unidentifiable without strong priors:
fit1 &lt;- walker(y ~ rw1(~ x, beta = c(0, 1)), 
  beta = c(0, 1), chains = 1, iter = 1000, init = 0) 

# only time-varying level, using 0 or -1 removes intercept:
fit2 &lt;- walker(y ~ 0 + rw1(~ x, beta = c(0, 1)), chains = 1, iter = 1000,
  init = 0)

# time-varying level, no covariates:
fit3 &lt;- walker(y ~ 0 + rw1(~ 1, beta = c(0, 1)), chains = 1, iter = 1000)

# fixed intercept no time-varying level:
fit4 &lt;- walker(y ~ rw1(~ 0 + x, beta = c(0, 1)), 
  beta = c(0, 1), chains = 1, iter = 1000) 

# only time-varying effect of x:
fit5 &lt;- walker(y ~ 0 + rw1(~ 0 + x, beta = c(0, 1)), chains = 1, iter = 1000) 

## End(Not run)

## Not run: 

rw1_fit &lt;- walker(Nile ~ -1 + 
  rw1(~ 1, 
    beta = c(1000, 100), 
    sigma = c(2, 0.001)), 
  sigma_y_prior = c(2, 0.005), 
  iter = 2000, chains = 1)
  
rw2_fit &lt;- walker(Nile ~ -1 + 
  rw2(~ 1,
    beta = c(1000, 100), 
    sigma = c(2, 0.001), 
    nu = c(0, 100)), 
  sigma_y_prior = c(2, 0.005), 
  iter = 2000, chains = 1)
  
g_y &lt;- geom_point(data = data.frame(y = Nile, x = time(Nile)), 
  aes(x, y, alpha = 0.5), inherit.aes = FALSE) 
g_rw1 &lt;- plot_coefs(rw1_fit) + g_y
g_rw2 &lt;- plot_coefs(rw2_fit) + g_y
if(require("gridExtra")) {
  grid.arrange(g_rw1, g_rw2, ncol=2, top = "RW1 (left) versus RW2 (right)")
} else {
  g_rw1
  g_rw2
}

y &lt;- window(log10(UKgas), end = time(UKgas)[100])
n &lt;- 100
cos_t &lt;- cos(2 * pi * 1:n / 4)
sin_t &lt;- sin(2 * pi * 1:n / 4)
dat &lt;- data.frame(y, cos_t, sin_t)
fit &lt;- walker(y ~ -1 + 
  rw1(~ cos_t + sin_t, beta = c(0, 10), sigma = c(2, 1)), 
  sigma_y_prior = c(2, 10), data = dat, chains = 1, iter = 2000)
print(fit$stanfit, pars = c("sigma_y", "sigma_rw1"))

plot_coefs(fit)
# posterior predictive check:
pp_check(fit)

newdata &lt;- data.frame(
  cos_t = cos(2 * pi * 101:108 / 4), 
  sin_t = sin(2 * pi * 101:108 / 4))
pred &lt;- predict(fit, newdata)
plot_predict(pred)

# example on scalability
set.seed(1)
n &lt;- 2^12
beta1 &lt;- cumsum(c(0.5, rnorm(n - 1, 0, sd = 0.05)))
beta2 &lt;- cumsum(c(-1, rnorm(n - 1, 0, sd = 0.15)))
x1 &lt;- rnorm(n, mean = 2)
x2 &lt;- cos(1:n)
rw &lt;- cumsum(rnorm(n, 0, 0.5))
signal &lt;- rw + beta1 * x1 + beta2 * x2
y &lt;- rnorm(n, signal, 0.5)

d &lt;- data.frame(y, x1, x2)

n &lt;- 2^(6:12)
times &lt;- numeric(length(n))
for(i in seq_along(n)) {
  times[i] &lt;- sum(get_elapsed_time(
    walker(y ~ 0 + rw1(~ x1 + x2, 
      beta = c(0, 10)), 
      data = d[1:n[i],],
      chains = 1, seed = 1, refresh = 0)$stanfit))
}
plot(log2(n), log2(times))

## End(Not run)
</code></pre>

<hr>
<h2 id='walker_glm'>Bayesian generalized linear model with time-varying coefficients</h2><span id='topic+walker_glm'></span>

<h3>Description</h3>

<p>Function <code>walker_glm</code> is a generalization of <code>walker</code> for non-Gaussian 
models. Compared to <code>walker</code>, the returned samples are based on Gaussian approximation, 
which can then be used for exact-approximate analysis by weighting the sample properly. These weights 
are also returned as a part of the <code>stanfit</code> (they are generated in the 
generated quantities block of Stan model). Note that plotting functions <code>pp_check</code>, 
<code>plot_coefs</code>, and <code>plot_predict</code> resample the posterior based on weights 
before plotting, leading to &quot;exact&quot; analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>walker_glm(
  formula,
  data,
  beta,
  init,
  chains,
  return_x_reg = FALSE,
  distribution,
  initial_mode = "kfas",
  u,
  mc_sim = 50,
  return_data = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="walker_glm_+3A_formula">formula</code></td>
<td>
<p>An object of class <code>{formula}</code> with additional terms 
<code>rw1</code> and/or <code>rw2</code> e.g. <code>y ~ x1 + rw1(~ -1 + x2)</code>. See details.</p>
</td></tr>
<tr><td><code id="walker_glm_+3A_data">data</code></td>
<td>
<p>An optional data.frame or object coercible to such, as in <code>{lm}</code>.</p>
</td></tr>
<tr><td><code id="walker_glm_+3A_beta">beta</code></td>
<td>
<p>A length vector of length two which defines the 
prior mean and standard deviation of the Gaussian prior for time-invariant coefficients</p>
</td></tr>
<tr><td><code id="walker_glm_+3A_init">init</code></td>
<td>
<p>Initial value specification, see <code><a href="rstan.html#topic+sampling">sampling</a></code>. 
Note that compared to default in <code>rstan</code>, here the default is a to sample from the priors.</p>
</td></tr>
<tr><td><code id="walker_glm_+3A_chains">chains</code></td>
<td>
<p>Number of Markov chains. Default is 4.</p>
</td></tr>
<tr><td><code id="walker_glm_+3A_return_x_reg">return_x_reg</code></td>
<td>
<p>If <code>TRUE</code>, does not perform sampling, but instead returns the matrix of 
predictors after processing the <code>formula</code>.</p>
</td></tr>
<tr><td><code id="walker_glm_+3A_distribution">distribution</code></td>
<td>
<p>Either <code>"poisson"</code> or <code>"binomial"</code>.</p>
</td></tr>
<tr><td><code id="walker_glm_+3A_initial_mode">initial_mode</code></td>
<td>
<p>The initial guess of the fitted values on log-scale. 
Defines the Gaussian approximation used in the MCMC.
Either <code>"obs"</code> (corresponds to log(y+0.1) in Poisson case), 
<code>"glm"</code> (mode is obtained from time-invariant GLM), <code>"mle"</code> 
(default; mode is obtained from maximum likelihood estimate of the model), 
or numeric vector (custom guess).</p>
</td></tr>
<tr><td><code id="walker_glm_+3A_u">u</code></td>
<td>
<p>For Poisson model, a vector of exposures i.e. <code class="reqn">E(y) = u*exp(x*beta)</code>. 
For binomial, a vector containing the number of trials. Defaults 1.</p>
</td></tr>
<tr><td><code id="walker_glm_+3A_mc_sim">mc_sim</code></td>
<td>
<p>Number of samples used in importance sampling. Default is 50.</p>
</td></tr>
<tr><td><code id="walker_glm_+3A_return_data">return_data</code></td>
<td>
<p>if <code>TRUE</code>, returns data input to <code>sampling</code>. This is needed for
<code>lfo</code>.</p>
</td></tr>
<tr><td><code id="walker_glm_+3A_...">...</code></td>
<td>
<p>Further arguments to <code><a href="rstan.html#topic+sampling">sampling</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The underlying idea of <code>walker_glm</code> is based on paper 
&quot;Importance sampling type estimators based on approximate marginal MCMC&quot; by 
Vihola M, Helske J and Franks J which is available at ArXiv.
</p>
<p><code>walker_glm</code> uses the global approximation (i.e. start of the MCMC) instead of more accurate 
but slower local approximation (where model is approximated at each iteration). 
However for these restricted models global approximation should be sufficient, 
assuming the the initial estimate of the conditional mode of p(xbeta | y, sigma) not too 
far away from the true posterior. Therefore by default <code>walker_glm</code> first finds the 
maximum likelihood estimates of the standard deviation parameters 
(using <code><a href="KFAS.html#topic+KFAS">KFAS</a></code>) package, and 
constructs the approximation at that point, before running the Bayesian 
analysis.
</p>


<h3>Value</h3>

<p>A list containing the <code>stanfit</code> object, observations <code>y</code>,
covariates <code>xreg_fixed</code>, and <code>xreg_rw</code>.
</p>


<h3>See Also</h3>

<p>Package <code>diagis</code> in CRAN, which provides functions for computing weighted 
summary statistics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
n &lt;- 25
x &lt;- rnorm(n, 1, 1)
beta &lt;- cumsum(c(1, rnorm(n - 1, sd = 0.1)))

level &lt;- -1
u &lt;- sample(1:10, size = n, replace = TRUE)
y &lt;- rpois(n, u * exp(level + beta * x))
ts.plot(y)

# note very small number of iterations for the CRAN checks!
out &lt;- walker_glm(y ~ -1 + rw1(~ x, beta = c(0, 10), 
  sigma = c(2, 10)), distribution = "poisson", 
  iter = 200, chains = 1, refresh = 0)
print(out$stanfit, pars = "sigma_rw1") ## approximate results
if (require("diagis")) {
  weighted_mean(extract(out$stanfit, pars = "sigma_rw1")$sigma_rw1, 
    extract(out$stanfit, pars = "weights")$weights)
}
plot_coefs(out)
pp_check(out)
             
## Not run: 
data("discoveries", package = "datasets")
out &lt;- walker_glm(discoveries ~ -1 + 
  rw2(~ 1, beta = c(0, 10), sigma = c(2, 10), nu = c(0, 2)), 
  distribution = "poisson", iter = 2000, chains = 1, refresh = 0)

plot_fit(out)

# Dummy covariate example

fit &lt;- walker_glm(VanKilled ~ -1 + 
  rw1(~ law, beta = c(0, 1), sigma = c(2, 10)), dist = "poisson", 
   data = as.data.frame(Seatbelts), chains = 1, refresh = 0)

# compute effect * law
d &lt;- coef(fit, transform = function(x) {
  x[, 2, 1:170] &lt;- 0
  x
})

require("ggplot2")
d %&gt;% ggplot(aes(time, mean)) +
  geom_ribbon(aes(ymin = `2.5%`, ymax = `97.5%`), fill = "grey90") +
  geom_line() + facet_wrap(~ beta, scales = "free") + theme_bw()

## End(Not run)

</code></pre>

<hr>
<h2 id='walker_rw1'>Comparison of naive and state space implementation of RW1 regression model</h2><span id='topic+walker_rw1'></span>

<h3>Description</h3>

<p>This function is the first iteration of the function <code>walker</code>,
which supports only time-varying model where all coefficients ~ rw1.
This is kept as part of the package in order to compare &quot;naive&quot; and 
state space versions of the model in the vignette, 
but there is little reason to use it for other purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>walker_rw1(
  formula,
  data,
  beta,
  sigma,
  init,
  chains,
  naive = FALSE,
  return_x_reg = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="walker_rw1_+3A_formula">formula</code></td>
<td>
<p>An object of class <code><a href="stats.html#topic+formula">formula</a></code>. See <code><a href="stats.html#topic+lm">lm</a></code> for details.</p>
</td></tr>
<tr><td><code id="walker_rw1_+3A_data">data</code></td>
<td>
<p>An optional data.frame or object coercible to such, as in <code><a href="stats.html#topic+lm">lm</a></code>.</p>
</td></tr>
<tr><td><code id="walker_rw1_+3A_beta">beta</code></td>
<td>
<p>A matrix with <code class="reqn">k</code> rows and 2 columns, where first columns defines the 
prior means of the Gaussian priors of the corresponding <code class="reqn">k</code> regression coefficients, 
and the second column defines the the standard deviations of those prior distributions.</p>
</td></tr>
<tr><td><code id="walker_rw1_+3A_sigma">sigma</code></td>
<td>
<p>A matrix with <code class="reqn">k + 1</code> rows and two colums with similar structure as 
<code>beta</code>, with first row corresponding to the prior of the standard deviation of the 
observation level noise, and rest of the rows define the priors for the standard deviations of 
random walk noise terms. The prior distributions for all sigmas are 
Gaussians truncated to positive real axis. For non-Gaussian models, this should contain only k rows. 
For second order random walk model, these priors correspond to the slope level standard deviations.</p>
</td></tr>
<tr><td><code id="walker_rw1_+3A_init">init</code></td>
<td>
<p>Initial value specification, see <code><a href="rstan.html#topic+sampling">sampling</a></code>.</p>
</td></tr>
<tr><td><code id="walker_rw1_+3A_chains">chains</code></td>
<td>
<p>Number of Markov chains. Default is 4.</p>
</td></tr>
<tr><td><code id="walker_rw1_+3A_naive">naive</code></td>
<td>
<p>Only used for <code>walker</code> function. 
If <code>TRUE</code>, use &quot;standard&quot; approach which samples the joint posterior 
<code class="reqn">p(beta, sigma | y)</code>. If <code>FALSE</code> (the default), use marginalisation approach 
where we sample the marginal posterior <code class="reqn">p(sigma | y)</code> and generate the samples of 
<code class="reqn">p(beta | sigma, y)</code> using state space modelling techniques 
(namely simulation smoother by Durbin and Koopman (2002)). Both methods give asymptotically 
identical results, but the latter approach is computationally much more efficient.</p>
</td></tr>
<tr><td><code id="walker_rw1_+3A_return_x_reg">return_x_reg</code></td>
<td>
<p>If <code>TRUE</code>, does not perform sampling, but instead returns the matrix of 
predictors after processing the <code>formula</code>.</p>
</td></tr>
<tr><td><code id="walker_rw1_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code><a href="rstan.html#topic+sampling">sampling</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Comparing the approaches, note that with such a small data 
## the differences aren't huge, but try same with n = 500 and/or more terms...
set.seed(123)
n &lt;- 100
beta1 &lt;- cumsum(c(0.5, rnorm(n - 1, 0, sd = 0.05)))
beta2 &lt;- cumsum(c(-1, rnorm(n - 1, 0, sd = 0.15)))
x1 &lt;- rnorm(n, 1)
x2 &lt;- 0.25 * cos(1:n)
ts.plot(cbind(beta1 * x1, beta2 *x2), col = 1:2)
u &lt;- cumsum(rnorm(n))
y &lt;- rnorm(n, u + beta1 * x1 + beta2 * x2)
ts.plot(y)
lines(u + beta1 * x1 + beta2 * x2, col = 2)
kalman_walker &lt;- walker_rw1(y ~ -1 + 
  rw1(~ x1 + x2, beta = c(0, 2), sigma = c(0, 2)), 
  sigma_y = c(0, 2), iter = 2000, chains = 1)
print(kalman_walker$stanfit, pars = c("sigma_y", "sigma_rw1"))
betas &lt;- extract(kalman_walker$stanfit, "beta")[[1]]
ts.plot(cbind(u, beta1, beta2, apply(betas, 2, colMeans)), 
  col = 1:3, lty = rep(2:1, each = 3))
sum(get_elapsed_time(kalman_walker$stanfit))
naive_walker &lt;- walker_rw1(y ~ x1 + x2, iter = 2000, chains = 1, 
  beta = cbind(0, rep(2, 3)), sigma = cbind(0, rep(2, 4)), 
  naive = TRUE)
print(naive_walker$stanfit, pars = c("sigma_y", "sigma_b"))
sum(get_elapsed_time(naive_walker$stanfit))

## Larger problem, this takes some time with naive approach

set.seed(123)
n &lt;- 500
beta1 &lt;- cumsum(c(1.5, rnorm(n - 1, 0, sd = 0.05)))
beta2 &lt;- cumsum(c(-1, rnorm(n - 1, 0, sd = 0.5)))
beta3 &lt;- cumsum(c(-1.5, rnorm(n - 1, 0, sd = 0.15)))
beta4 &lt;- 2
x1 &lt;- rnorm(n, 1)
x2 &lt;- 0.25 * cos(1:n)
x3 &lt;- runif(n, 1, 3)
ts.plot(cbind(beta1 * x1, beta2 * x2, beta3 * x3), col = 1:3)
a &lt;- cumsum(rnorm(n))
signal &lt;- a + beta1 * x1 + beta2 * x2 + beta3 * x3
y &lt;- rnorm(n, signal)
ts.plot(y)
lines(signal, col = 2)
kalman_walker &lt;- walker_rw1(y ~ x1 + x2 + x3, iter = 2000, chains = 1,
  beta = cbind(0, rep(2, 4)), sigma = cbind(0, rep(2, 5)))
print(kalman_walker$stanfit, pars = c("sigma_y", "sigma_b"))
betas &lt;- extract(kalman_walker$stanfit, "beta")[[1]]
ts.plot(cbind(u, beta1, beta2, beta3, apply(betas, 2, colMeans)), 
  col = 1:4, lty = rep(2:1, each = 4))
sum(get_elapsed_time(kalman_walker$stanfit))
# need to increase adapt_delta in order to get rid of divergences
# and max_treedepth to get rid of related warnings
# and still we end up with low BFMI warning after hours of computation
naive_walker &lt;- walker_rw1(y ~ x1 + x2 + x3, iter = 2000, chains = 1, 
  beta = cbind(0, rep(2, 4)), sigma = cbind(0, rep(2, 5)),
  naive = TRUE, control = list(adapt_delta = 0.9, max_treedepth = 15)) 
print(naive_walker$stanfit, pars = c("sigma_y", "sigma_b"))
sum(get_elapsed_time(naive_walker$stanfit))

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
