<!DOCTYPE html><html lang="en"><head><title>Help for package gofreg</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gofreg}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CondKolmbXY'><p>Conditional Kolmogorov test statistic for the joint distribution of</p>
(beta^T X,Y)</a></li>
<li><a href='#CondKolmXY'><p>Conditional Kolmogorov test statistic for the joint distribution of</p>
(X,Y)</a></li>
<li><a href='#CondKolmY'><p>Conditional Kolmogorov test statistic for the marginal distribution</p>
of Y</a></li>
<li><a href='#CondKolmY_RCM'><p>Conditional Kolmogorov test statistic for the marginal distribution</p>
of Y under random censorship</a></li>
<li><a href='#ExpGLM'><p>Generalized linear model with exponential distribution</p></a></li>
<li><a href='#GammaGLM'><p>Generalized linear model with gamma distribution</p></a></li>
<li><a href='#GLM'><p>Generalized linear model (abstract class)</p></a></li>
<li><a href='#GLM.new'><p>Create GLM object with specific distribution family</p></a></li>
<li><a href='#GOFTest'><p>Goodness-of-fit test for parametric regression</p></a></li>
<li><a href='#loglik_xy'><p>Negative log-likelihood function for a parametric regression model</p></a></li>
<li><a href='#loglik_xzd'><p>Negative log-likelihood function for a parametric regression model under</p>
random censorship</a></li>
<li><a href='#MEP'><p>Marked empirical process test statistic for a given GLM</p></a></li>
<li><a href='#NegBinomGLM'><p>Generalized linear model with negative binomial distribution</p></a></li>
<li><a href='#NormalGLM'><p>Generalized linear model with normal distribution</p></a></li>
<li><a href='#ParamRegrModel'><p>Parametric regression model (abstract class)</p></a></li>
<li><a href='#resample_param'><p>Parametric resampling scheme for a parametric regression model</p></a></li>
<li><a href='#resample_param_cens'><p>Parametric resampling scheme for a parametric regression model under random</p>
censorship</a></li>
<li><a href='#resample_param_rsmplx'><p>Parametric resampling scheme for a parametric regression model with</p>
resampling of covariates</a></li>
<li><a href='#SICM'><p>Simulated integrated conditional moment test statistic</p></a></li>
<li><a href='#TestStatistic'><p>Test Statistic for parametric regression models (abstract class)</p></a></li>
<li><a href='#WeibullGLM'><p>Generalized linear model with Weibull distribution</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Bootstrap-Based Goodness-of-Fit Tests for Parametric Regression</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides statistical methods to check if a parametric family of
  conditional density functions fits to some given dataset of covariates and 
  response variables. Different test statistics can be used to determine the 
  goodness-of-fit of the assumed model, see Andrews (1997) 
  &lt;<a href="https://doi.org/10.2307%2F2171880">doi:10.2307/2171880</a>&gt;, Bierens &amp; Wang (2012) &lt;<a href="https://doi.org/10.1017%2FS0266466611000168">doi:10.1017/S0266466611000168</a>&gt;,
  Dikta &amp; Scheer (2021) &lt;<a href="https://doi.org/10.1007%2F978-3-030-73480-0">doi:10.1007/978-3-030-73480-0</a>&gt; and Kremling &amp; Dikta 
  (2024) &lt;<a href="https://doi.org/10.48550%2FarXiv.2409.20262">doi:10.48550/arXiv.2409.20262</a>&gt;. As proposed in these papers, the 
  corresponding p-values are approximated using a parametric bootstrap method.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Imports:</td>
<td>checkmate, dplyr, ggplot2, R6, survival</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/gkremling/gofreg">https://github.com/gkremling/gofreg</a>,
<a href="https://gkremling.github.io/gofreg/">https://gkremling.github.io/gofreg/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/gkremling/gofreg/issues">https://github.com/gkremling/gofreg/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-10-04 09:05:04 UTC; gitte</td>
</tr>
<tr>
<td>Author:</td>
<td>Gitte Kremling <a href="https://orcid.org/0000-0002-0753-1520"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gitte Kremling &lt;gitte.kremling@web.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-10-04 10:20:17 UTC</td>
</tr>
</table>
<hr>
<h2 id='CondKolmbXY'>Conditional Kolmogorov test statistic for the joint distribution of
(beta^T X,Y)</h2><span id='topic+CondKolmbXY'></span>

<h3>Description</h3>

<p>This class inherits from <a href="#topic+TestStatistic">TestStatistic</a> and implements a
function to calculate the test statistic (and x-y-values that can be used
to plot the underlying process).
</p>
<p>The process underlying the test statistic is defined by
</p>
<p style="text-align: center;"><code class="reqn">\bar{\alpha}_n(s,t) = \frac{1}{\sqrt{n}} \sum_{i=1}^n
  \left( I_{\{Y_i \le t\}} - F(t|\hat{\vartheta}_n, X_i) \right)
  I_{\{\hat{\beta}_n^T X_i \le s\}}, \quad (s,t) \in R^{2}.</code>
</p>



<h3>Super class</h3>

<p><code><a href="#topic+TestStatistic">gofreg::TestStatistic</a></code> -&gt; <code>CondKolmbXY</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-CondKolmbXY-calc_stat"><code>CondKolmbXY$calc_stat()</code></a>
</p>
</li>
<li> <p><a href="#method-CondKolmbXY-clone"><code>CondKolmbXY$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="TestStatistic" data-id="geom_ts_proc"><a href='../../gofreg/html/TestStatistic.html#method-TestStatistic-geom_ts_proc'><code>gofreg::TestStatistic$geom_ts_proc()</code></a></span></li>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="TestStatistic" data-id="get_plot_xy"><a href='../../gofreg/html/TestStatistic.html#method-TestStatistic-get_plot_xy'><code>gofreg::TestStatistic$get_plot_xy()</code></a></span></li>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="TestStatistic" data-id="get_value"><a href='../../gofreg/html/TestStatistic.html#method-TestStatistic-get_value'><code>gofreg::TestStatistic$get_value()</code></a></span></li>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="TestStatistic" data-id="plot"><a href='../../gofreg/html/TestStatistic.html#method-TestStatistic-plot'><code>gofreg::TestStatistic$plot()</code></a></span></li>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="TestStatistic" data-id="print"><a href='../../gofreg/html/TestStatistic.html#method-TestStatistic-print'><code>gofreg::TestStatistic$print()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-CondKolmbXY-calc_stat"></a>



<h4>Method <code>calc_stat()</code></h4>

<p>Calculate the value of the test statistic for given data
and a model to test for.
</p>


<h5>Usage</h5>

<div class="r"><pre>CondKolmbXY$calc_stat(data, model)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p><code>data.frame()</code> with columns x and y containing the data</p>
</dd>
<dt><code>model</code></dt><dd><p><a href="#topic+ParamRegrModel">ParamRegrModel</a> to test for, already fitted to the data</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The modified object (<code>self</code>), allowing for method chaining.
</p>


<hr>
<a id="method-CondKolmbXY-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>CondKolmbXY$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'># Create an example dataset
n &lt;- 100
x &lt;- cbind(runif(n), rbinom(n, 1, 0.5))
model &lt;- NormalGLM$new()
y &lt;- model$sample_yx(x, params=list(beta=c(2,3), sd=1))
data &lt;- dplyr::tibble(x = x, y = y)

# Fit the correct model
model$fit(data, params_init=list(beta=c(1,1), sd=3), inplace = TRUE)

# Print value of test statistic and plot corresponding process
ts &lt;- CondKolmbXY$new()
ts$calc_stat(data, model)
print(ts)
plot(ts)

# Fit a wrong model
model2 &lt;- NormalGLM$new(linkinv = function(u) {u+10})
model2$fit(data, params_init=list(beta=c(1,1), sd=3), inplace = TRUE)

# Print value of test statistic and plot corresponding process
ts2 &lt;- CondKolmbXY$new()
ts2$calc_stat(data, model2)
print(ts2)
plot(ts2)
</code></pre>

<hr>
<h2 id='CondKolmXY'>Conditional Kolmogorov test statistic for the joint distribution of
(X,Y)</h2><span id='topic+CondKolmXY'></span>

<h3>Description</h3>

<p>This class inherits from <a href="#topic+TestStatistic">TestStatistic</a> and implements a
function to calculate the test statistic (and x-y-values that can be used
to plot the underlying process).
</p>
<p>The process underlying the test statistic is given in Andrews (1997)
doi: <a href="https://doi.org/10.2307/2171880">10.2307/2171880</a> and defined by </p>
<p style="text-align: center;"><code class="reqn">\nu_n(x,y) = \frac{1}{\sqrt{n}}
  \sum_{i=1}^n \left(I_{\{Y_i \le y\}} - F(y|\hat{\vartheta}_n, X_i) \right)
  I_{\{X_i \le x\}},\quad (x,y) \in R^{p+1}.</code>
</p>



<h3>Super class</h3>

<p><code><a href="#topic+TestStatistic">gofreg::TestStatistic</a></code> -&gt; <code>CondKolmXY</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-CondKolmXY-calc_stat"><code>CondKolmXY$calc_stat()</code></a>
</p>
</li>
<li> <p><a href="#method-CondKolmXY-clone"><code>CondKolmXY$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="TestStatistic" data-id="geom_ts_proc"><a href='../../gofreg/html/TestStatistic.html#method-TestStatistic-geom_ts_proc'><code>gofreg::TestStatistic$geom_ts_proc()</code></a></span></li>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="TestStatistic" data-id="get_plot_xy"><a href='../../gofreg/html/TestStatistic.html#method-TestStatistic-get_plot_xy'><code>gofreg::TestStatistic$get_plot_xy()</code></a></span></li>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="TestStatistic" data-id="get_value"><a href='../../gofreg/html/TestStatistic.html#method-TestStatistic-get_value'><code>gofreg::TestStatistic$get_value()</code></a></span></li>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="TestStatistic" data-id="plot"><a href='../../gofreg/html/TestStatistic.html#method-TestStatistic-plot'><code>gofreg::TestStatistic$plot()</code></a></span></li>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="TestStatistic" data-id="print"><a href='../../gofreg/html/TestStatistic.html#method-TestStatistic-print'><code>gofreg::TestStatistic$print()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-CondKolmXY-calc_stat"></a>



<h4>Method <code>calc_stat()</code></h4>

<p>Calculate the value of the test statistic for given data
and a model to test for.
</p>


<h5>Usage</h5>

<div class="r"><pre>CondKolmXY$calc_stat(data, model)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p><code>data.frame()</code> with columns x and y containing the data</p>
</dd>
<dt><code>model</code></dt><dd><p><a href="#topic+ParamRegrModel">ParamRegrModel</a> to test for, already fitted to the data</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The modified object (<code>self</code>), allowing for method chaining.
</p>


<hr>
<a id="method-CondKolmXY-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>CondKolmXY$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'># Create an example dataset
n &lt;- 100
x &lt;- cbind(runif(n), rbinom(n, 1, 0.5))
model &lt;- NormalGLM$new()
y &lt;- model$sample_yx(x, params=list(beta=c(2,3), sd=1))
data &lt;- dplyr::tibble(x = x, y = y)

# Fit the correct model
model$fit(data, params_init=list(beta=c(1,1), sd=3), inplace = TRUE)

# Print value of test statistic and plot corresponding process
ts &lt;- CondKolmXY$new()
ts$calc_stat(data, model)
print(ts)
plot(ts)

# Fit a wrong model
model2 &lt;- NormalGLM$new(linkinv = function(u) {u+10})
model2$fit(data, params_init=list(beta=c(1,1), sd=3), inplace = TRUE)

# Print value of test statistic and plot corresponding process
ts2 &lt;- CondKolmXY$new()
ts2$calc_stat(data, model2)
print(ts2)
plot(ts2)
</code></pre>

<hr>
<h2 id='CondKolmY'>Conditional Kolmogorov test statistic for the marginal distribution
of Y</h2><span id='topic+CondKolmY'></span>

<h3>Description</h3>

<p>This class inherits from <a href="#topic+TestStatistic">TestStatistic</a> and implements a
function to calculate the test statistic (and x-y-values that can be used
to plot the underlying process).
</p>
<p>The process underlying the test statistic is given in Kremling &amp; Dikta
(2024) <a href="https://arxiv.org/abs/2409.20262">https://arxiv.org/abs/2409.20262</a> and defined by </p>
<p style="text-align: center;"><code class="reqn">\tilde{\alpha}_n(t) = \frac{1}{\sqrt{n}}
  \sum_{i=1}^n \left( I_{\{Y_i \le t\}} - F(t|\hat{\vartheta}_n, X_i)
  \right), \quad -\infty \le t \le \infty.</code>
</p>



<h3>Super class</h3>

<p><code><a href="#topic+TestStatistic">gofreg::TestStatistic</a></code> -&gt; <code>CondKolmY</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-CondKolmY-calc_stat"><code>CondKolmY$calc_stat()</code></a>
</p>
</li>
<li> <p><a href="#method-CondKolmY-clone"><code>CondKolmY$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="TestStatistic" data-id="geom_ts_proc"><a href='../../gofreg/html/TestStatistic.html#method-TestStatistic-geom_ts_proc'><code>gofreg::TestStatistic$geom_ts_proc()</code></a></span></li>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="TestStatistic" data-id="get_plot_xy"><a href='../../gofreg/html/TestStatistic.html#method-TestStatistic-get_plot_xy'><code>gofreg::TestStatistic$get_plot_xy()</code></a></span></li>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="TestStatistic" data-id="get_value"><a href='../../gofreg/html/TestStatistic.html#method-TestStatistic-get_value'><code>gofreg::TestStatistic$get_value()</code></a></span></li>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="TestStatistic" data-id="plot"><a href='../../gofreg/html/TestStatistic.html#method-TestStatistic-plot'><code>gofreg::TestStatistic$plot()</code></a></span></li>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="TestStatistic" data-id="print"><a href='../../gofreg/html/TestStatistic.html#method-TestStatistic-print'><code>gofreg::TestStatistic$print()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-CondKolmY-calc_stat"></a>



<h4>Method <code>calc_stat()</code></h4>

<p>Calculate the value of the test statistic for given data
and a model to test for.
</p>


<h5>Usage</h5>

<div class="r"><pre>CondKolmY$calc_stat(data, model)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p><code>data.frame()</code> with columns x and y containing the data</p>
</dd>
<dt><code>model</code></dt><dd><p><a href="#topic+ParamRegrModel">ParamRegrModel</a> to test for, already fitted to the data</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The modified object (<code>self</code>), allowing for method chaining.
</p>


<hr>
<a id="method-CondKolmY-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>CondKolmY$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'># Create an example dataset
n &lt;- 100
x &lt;- cbind(runif(n), rbinom(n, 1, 0.5))
model &lt;- NormalGLM$new()
y &lt;- model$sample_yx(x, params=list(beta=c(2,3), sd=1))
data &lt;- dplyr::tibble(x = x, y = y)

# Fit the correct model
model$fit(data, params_init=list(beta=c(1,1), sd=3), inplace = TRUE)

# Print value of test statistic and plot corresponding process
ts &lt;- CondKolmY$new()
ts$calc_stat(data, model)
print(ts)
plot(ts)

# Fit a wrong model
model2 &lt;- NormalGLM$new(linkinv = function(u) {u+10})
model2$fit(data, params_init=list(beta=c(1,1), sd=3), inplace = TRUE)

# Print value of test statistic and plot corresponding process
ts2 &lt;- CondKolmY$new()
ts2$calc_stat(data, model2)
print(ts2)
plot(ts2)
</code></pre>

<hr>
<h2 id='CondKolmY_RCM'>Conditional Kolmogorov test statistic for the marginal distribution
of Y under random censorship</h2><span id='topic+CondKolmY_RCM'></span>

<h3>Description</h3>

<p>This class inherits from <a href="#topic+TestStatistic">TestStatistic</a> and implements a
function to calculate the test statistic (and x-y-values that can be used
to plot the underlying process).
</p>
<p>The process underlying the test statistic is defined by
</p>
<p style="text-align: center;"><code class="reqn">\tilde{\alpha}_n^{KM}(t) = \sqrt{n} \left( \hat{F}^{KM}_n(t) -
  \frac{1}{n} \sum_{i=1}^n F(t|\hat{\vartheta}_n, X_i) \right), \quad
  -\infty \le t \le \infty.</code>
</p>



<h3>Super class</h3>

<p><code><a href="#topic+TestStatistic">gofreg::TestStatistic</a></code> -&gt; <code>CondKolmY_RCM</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-CondKolmY_RCM-calc_stat"><code>CondKolmY_RCM$calc_stat()</code></a>
</p>
</li>
<li> <p><a href="#method-CondKolmY_RCM-clone"><code>CondKolmY_RCM$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="TestStatistic" data-id="geom_ts_proc"><a href='../../gofreg/html/TestStatistic.html#method-TestStatistic-geom_ts_proc'><code>gofreg::TestStatistic$geom_ts_proc()</code></a></span></li>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="TestStatistic" data-id="get_plot_xy"><a href='../../gofreg/html/TestStatistic.html#method-TestStatistic-get_plot_xy'><code>gofreg::TestStatistic$get_plot_xy()</code></a></span></li>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="TestStatistic" data-id="get_value"><a href='../../gofreg/html/TestStatistic.html#method-TestStatistic-get_value'><code>gofreg::TestStatistic$get_value()</code></a></span></li>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="TestStatistic" data-id="plot"><a href='../../gofreg/html/TestStatistic.html#method-TestStatistic-plot'><code>gofreg::TestStatistic$plot()</code></a></span></li>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="TestStatistic" data-id="print"><a href='../../gofreg/html/TestStatistic.html#method-TestStatistic-print'><code>gofreg::TestStatistic$print()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-CondKolmY_RCM-calc_stat"></a>



<h4>Method <code>calc_stat()</code></h4>

<p>Calculate the value of the test statistic for given data
and a model to test for.
</p>


<h5>Usage</h5>

<div class="r"><pre>CondKolmY_RCM$calc_stat(data, model)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p><code>data.frame()</code> with columns x and y containing the data</p>
</dd>
<dt><code>model</code></dt><dd><p><a href="#topic+ParamRegrModel">ParamRegrModel</a> to test for, already fitted to the data</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The modified object (<code>self</code>), allowing for method chaining.
</p>


<hr>
<a id="method-CondKolmY_RCM-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>CondKolmY_RCM$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'># Create an example dataset
n &lt;- 100
x &lt;- cbind(runif(n), rbinom(n, 1, 0.5))
model &lt;- NormalGLM$new()
y &lt;- model$sample_yx(x, params=list(beta=c(2,3), sd=1))
c &lt;- rnorm(n, mean(y)*1.2, sd(y)*0.5)
data &lt;- dplyr::tibble(x = x, z = pmin(y,c), delta = as.numeric(y &lt;= c))

# Fit the correct model
model$fit(data, params_init=list(beta=c(1,1), sd=3), inplace = TRUE, loglik = loglik_xzd)

# Print value of test statistic and plot corresponding process
ts &lt;- CondKolmY_RCM$new()
ts$calc_stat(data, model)
print(ts)
plot(ts)

# Fit a wrong model
model2 &lt;- NormalGLM$new(linkinv = function(u) {u+10})
model2$fit(data, params_init=list(beta=c(1,1), sd=3), inplace = TRUE, loglik = loglik_xzd)

# Print value of test statistic and plot corresponding process
ts2 &lt;- CondKolmY_RCM$new()
ts2$calc_stat(data, model2)
print(ts2)
plot(ts2)
</code></pre>

<hr>
<h2 id='ExpGLM'>Generalized linear model with exponential distribution</h2><span id='topic+ExpGLM'></span>

<h3>Description</h3>

<p>This class represents a generalized linear model with
exponential distribution. It inherits from <a href="#topic+GLM">GLM</a> and implements its
functions that, for example, evaluate the conditional density and
distribution functions.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+ParamRegrModel">gofreg::ParamRegrModel</a></code> -&gt; <code><a href="#topic+GLM">gofreg::GLM</a></code> -&gt; <code>ExpGLM</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ExpGLM-fit"><code>ExpGLM$fit()</code></a>
</p>
</li>
<li> <p><a href="#method-ExpGLM-f_yx"><code>ExpGLM$f_yx()</code></a>
</p>
</li>
<li> <p><a href="#method-ExpGLM-F_yx"><code>ExpGLM$F_yx()</code></a>
</p>
</li>
<li> <p><a href="#method-ExpGLM-F1_yx"><code>ExpGLM$F1_yx()</code></a>
</p>
</li>
<li> <p><a href="#method-ExpGLM-sample_yx"><code>ExpGLM$sample_yx()</code></a>
</p>
</li>
<li> <p><a href="#method-ExpGLM-clone"><code>ExpGLM$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="ParamRegrModel" data-id="get_params"><a href='../../gofreg/html/ParamRegrModel.html#method-ParamRegrModel-get_params'><code>gofreg::ParamRegrModel$get_params()</code></a></span></li>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="ParamRegrModel" data-id="set_params"><a href='../../gofreg/html/ParamRegrModel.html#method-ParamRegrModel-set_params'><code>gofreg::ParamRegrModel$set_params()</code></a></span></li>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="GLM" data-id="initialize"><a href='../../gofreg/html/GLM.html#method-GLM-initialize'><code>gofreg::GLM$initialize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="GLM" data-id="mean_yx"><a href='../../gofreg/html/GLM.html#method-GLM-mean_yx'><code>gofreg::GLM$mean_yx()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ExpGLM-fit"></a>



<h4>Method <code>fit()</code></h4>

<p>Calculates the maximum likelihood estimator for the model
parameters based on given data.
</p>


<h5>Usage</h5>

<div class="r"><pre>ExpGLM$fit(
  data,
  params_init = private$params,
  loglik = loglik_xy,
  inplace = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>tibble containing the data to fit the model to</p>
</dd>
<dt><code>params_init</code></dt><dd><p>initial value of the model parameters to use for the
optimization (defaults to the fitted parameter values)</p>
</dd>
<dt><code>loglik</code></dt><dd><p><code style="white-space: pre;">&#8288;function(data, model, params)&#8288;</code> defaults to <code><a href="#topic+loglik_xy">loglik_xy()</a></code></p>
</dd>
<dt><code>inplace</code></dt><dd><p><code>logical</code>; if <code>TRUE</code>, default model parameters are set
accordingly and parameter estimator is not returned</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>MLE of the model parameters for the given data, same shape as
<code>params_init</code>
</p>


<hr>
<a id="method-ExpGLM-f_yx"></a>



<h4>Method <code>f_yx()</code></h4>

<p>Evaluates the conditional density function.
</p>


<h5>Usage</h5>

<div class="r"><pre>ExpGLM$f_yx(t, x, params = private$params)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>t</code></dt><dd><p>value(s) at which the conditional density shall be evaluated</p>
</dd>
<dt><code>x</code></dt><dd><p>matrix of covariates, each row representing one sample</p>
</dd>
<dt><code>params</code></dt><dd><p>model parameters to use (<code>list()</code> with tag beta), defaults to
the fitted parameter values</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>value(s) of the conditional density function, same shape as <code>t</code>
</p>


<hr>
<a id="method-ExpGLM-F_yx"></a>



<h4>Method <code>F_yx()</code></h4>

<p>Evaluates the conditional distribution function.
</p>


<h5>Usage</h5>

<div class="r"><pre>ExpGLM$F_yx(t, x, params = private$params)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>t</code></dt><dd><p>value(s) at which the conditional distribution shall be
evaluated</p>
</dd>
<dt><code>x</code></dt><dd><p>matrix of covariates, each row representing one sample</p>
</dd>
<dt><code>params</code></dt><dd><p>model parameters to use (<code>list()</code> with tag beta), defaults to
the fitted parameter values</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>value(s) of the conditional distribution function,  same shape as
<code>t</code>
</p>


<hr>
<a id="method-ExpGLM-F1_yx"></a>



<h4>Method <code>F1_yx()</code></h4>

<p>Evaluates the conditional quantile function.
</p>


<h5>Usage</h5>

<div class="r"><pre>ExpGLM$F1_yx(t, x, params = private$params)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>t</code></dt><dd><p>value(s) at which the conditional quantile function shall be
evaluated</p>
</dd>
<dt><code>x</code></dt><dd><p>matrix of covariates, each row representing one sample</p>
</dd>
<dt><code>params</code></dt><dd><p>model parameters to use (<code>list()</code> with tag beta), defaults to
the fitted parameter values</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>value(s) of the conditional quantile function, same shape as
<code>t</code>
</p>


<hr>
<a id="method-ExpGLM-sample_yx"></a>



<h4>Method <code>sample_yx()</code></h4>

<p>Generates a new sample of response variables with the same
conditional distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>ExpGLM$sample_yx(x, params = private$params)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>matrix of covariates, each row representing one sample</p>
</dd>
<dt><code>params</code></dt><dd><p>model parameters to use (<code>list()</code> with tag beta), defaults to
the fitted parameter values</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>vector of sampled response variables, same length as <code>nrow(x)</code>
</p>


<hr>
<a id="method-ExpGLM-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ExpGLM$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'># Use the built-in cars dataset
x &lt;- datasets::cars$speed
y &lt;- datasets::cars$dist
data &lt;- dplyr::tibble(x=x, y=y)

# Create an instance of ExpGLM
model &lt;- ExpGLM$new()

# Fit an Exponential GLM to the cars dataset
model$fit(data, params_init = list(beta=3), inplace=TRUE)
params_opt &lt;- model$get_params()

# Plot the resulting regression function
plot(datasets::cars)
abline(a = 0, b = params_opt$beta)

# Generate a sample for y for given x following the same distribution
x.new &lt;- seq(min(x), max(x), by=2)
y.smpl &lt;- model$sample_yx(x.new)
points(x.new, y.smpl, col="red")

# Evaluate the conditional density, distribution, quantile and regression
# function at given values
model$f_yx(y.smpl, x.new)
model$F_yx(y.smpl, x.new)
model$F1_yx(y.smpl, x.new)
y.pred &lt;- model$mean_yx(x.new)
points(x.new, y.pred, col="blue")
</code></pre>

<hr>
<h2 id='GammaGLM'>Generalized linear model with gamma distribution</h2><span id='topic+GammaGLM'></span>

<h3>Description</h3>

<p>This class represents a generalized linear model with Gamma
distribution. It inherits from <a href="#topic+GLM">GLM</a> and implements its functions that,
for example, evaluate the conditional density and distribution functions.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+ParamRegrModel">gofreg::ParamRegrModel</a></code> -&gt; <code><a href="#topic+GLM">gofreg::GLM</a></code> -&gt; <code>GammaGLM</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-GammaGLM-fit"><code>GammaGLM$fit()</code></a>
</p>
</li>
<li> <p><a href="#method-GammaGLM-f_yx"><code>GammaGLM$f_yx()</code></a>
</p>
</li>
<li> <p><a href="#method-GammaGLM-F_yx"><code>GammaGLM$F_yx()</code></a>
</p>
</li>
<li> <p><a href="#method-GammaGLM-F1_yx"><code>GammaGLM$F1_yx()</code></a>
</p>
</li>
<li> <p><a href="#method-GammaGLM-sample_yx"><code>GammaGLM$sample_yx()</code></a>
</p>
</li>
<li> <p><a href="#method-GammaGLM-clone"><code>GammaGLM$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="ParamRegrModel" data-id="get_params"><a href='../../gofreg/html/ParamRegrModel.html#method-ParamRegrModel-get_params'><code>gofreg::ParamRegrModel$get_params()</code></a></span></li>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="ParamRegrModel" data-id="set_params"><a href='../../gofreg/html/ParamRegrModel.html#method-ParamRegrModel-set_params'><code>gofreg::ParamRegrModel$set_params()</code></a></span></li>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="GLM" data-id="initialize"><a href='../../gofreg/html/GLM.html#method-GLM-initialize'><code>gofreg::GLM$initialize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="GLM" data-id="mean_yx"><a href='../../gofreg/html/GLM.html#method-GLM-mean_yx'><code>gofreg::GLM$mean_yx()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-GammaGLM-fit"></a>



<h4>Method <code>fit()</code></h4>

<p>Calculates the maximum likelihood estimator for the model
parameters based on given data.
</p>


<h5>Usage</h5>

<div class="r"><pre>GammaGLM$fit(
  data,
  params_init = private$params,
  loglik = loglik_xy,
  inplace = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>tibble containing the data to fit the model to</p>
</dd>
<dt><code>params_init</code></dt><dd><p>initial value of the model parameters to use for the
optimization (defaults to the fitted parameter values)</p>
</dd>
<dt><code>loglik</code></dt><dd><p><code style="white-space: pre;">&#8288;function(data, model, params)&#8288;</code> defaults to <code><a href="#topic+loglik_xy">loglik_xy()</a></code></p>
</dd>
<dt><code>inplace</code></dt><dd><p><code>logical</code>; if <code>TRUE</code>, default model parameters are set
accordingly and parameter estimator is not returned</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>MLE of the model parameters for the given data, same shape as
<code>params_init</code>
</p>


<hr>
<a id="method-GammaGLM-f_yx"></a>



<h4>Method <code>f_yx()</code></h4>

<p>Evaluates the conditional density function.
</p>


<h5>Usage</h5>

<div class="r"><pre>GammaGLM$f_yx(t, x, params = private$params)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>t</code></dt><dd><p>value(s) at which the conditional density shall be evaluated</p>
</dd>
<dt><code>x</code></dt><dd><p>matrix of covariates, each row representing one sample</p>
</dd>
<dt><code>params</code></dt><dd><p>model parameters to use (<code>list()</code> with tags beta and shape),
defaults to the fitted parameter values</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>value(s) of the conditional density function, same shape as <code>t</code>
</p>


<hr>
<a id="method-GammaGLM-F_yx"></a>



<h4>Method <code>F_yx()</code></h4>

<p>Evaluates the conditional distribution function.
</p>


<h5>Usage</h5>

<div class="r"><pre>GammaGLM$F_yx(t, x, params = private$params)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>t</code></dt><dd><p>value(s) at which the conditional distribution shall be
evaluated</p>
</dd>
<dt><code>x</code></dt><dd><p>matrix of covariates, each row representing one sample</p>
</dd>
<dt><code>params</code></dt><dd><p>model parameters to use (<code>list()</code> with tags beta and shape),
defaults to the fitted parameter values</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>value(s) of the conditional distribution function,  same shape as
<code>t</code>
</p>


<hr>
<a id="method-GammaGLM-F1_yx"></a>



<h4>Method <code>F1_yx()</code></h4>

<p>Evaluates the conditional quantile function.
</p>


<h5>Usage</h5>

<div class="r"><pre>GammaGLM$F1_yx(t, x, params = private$params)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>t</code></dt><dd><p>value(s) at which the conditional quantile function shall be
evaluated</p>
</dd>
<dt><code>x</code></dt><dd><p>matrix of covariates, each row representing one sample</p>
</dd>
<dt><code>params</code></dt><dd><p>model parameters to use (<code>list()</code> with tags beta and shape),
defaults to the fitted parameter values</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>value(s) of the conditional quantile function, same shape as
<code>t</code>
</p>


<hr>
<a id="method-GammaGLM-sample_yx"></a>



<h4>Method <code>sample_yx()</code></h4>

<p>Generates a new sample of response variables with the same
conditional distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>GammaGLM$sample_yx(x, params = private$params)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>matrix of covariates, each row representing one sample</p>
</dd>
<dt><code>params</code></dt><dd><p>model parameters to use (<code>list()</code> with tags beta and shape),
defaults to the fitted parameter values</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>vector of sampled response variables, same length as <code>nrow(x)</code>
</p>


<hr>
<a id="method-GammaGLM-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>GammaGLM$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'># Use the built-in cars dataset
x &lt;- datasets::cars$speed
y &lt;- datasets::cars$dist
data &lt;- dplyr::tibble(x=x, y=y)

# Create an instance of GammaGLM
model &lt;- GammaGLM$new()

# Fit an Gamma GLM to the cars dataset
model$fit(data, params_init = list(beta=3, shape=1), inplace=TRUE)
params_opt &lt;- model$get_params()

# Plot the resulting regression function
plot(datasets::cars)
abline(a = 0, b = params_opt$beta)

# Generate a sample for y for given x following the same distribution
x.new &lt;- seq(min(x), max(x), by=2)
y.smpl &lt;- model$sample_yx(x.new)
points(x.new, y.smpl, col="red")

# Evaluate the conditional density, distribution, quantile and regression
# function at given values
model$f_yx(y.smpl, x.new)
model$F_yx(y.smpl, x.new)
model$F1_yx(y.smpl, x.new)
y.pred &lt;- model$mean_yx(x.new)
points(x.new, y.pred, col="blue")
</code></pre>

<hr>
<h2 id='GLM'>Generalized linear model (abstract class)</h2><span id='topic+GLM'></span>

<h3>Description</h3>

<p>This class specializes <a href="#topic+ParamRegrModel">ParamRegrModel</a>. It is the abstract
base class for parametric generalized linear model objects with specific
distribution family such as <a href="#topic+NormalGLM">NormalGLM</a> and handles the (inverse) link
function.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+ParamRegrModel">gofreg::ParamRegrModel</a></code> -&gt; <code>GLM</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-GLM-new"><code>GLM$new()</code></a>
</p>
</li>
<li> <p><a href="#method-GLM-mean_yx"><code>GLM$mean_yx()</code></a>
</p>
</li>
<li> <p><a href="#method-GLM-clone"><code>GLM$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="ParamRegrModel" data-id="F1_yx"><a href='../../gofreg/html/ParamRegrModel.html#method-ParamRegrModel-F1_yx'><code>gofreg::ParamRegrModel$F1_yx()</code></a></span></li>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="ParamRegrModel" data-id="F_yx"><a href='../../gofreg/html/ParamRegrModel.html#method-ParamRegrModel-F_yx'><code>gofreg::ParamRegrModel$F_yx()</code></a></span></li>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="ParamRegrModel" data-id="f_yx"><a href='../../gofreg/html/ParamRegrModel.html#method-ParamRegrModel-f_yx'><code>gofreg::ParamRegrModel$f_yx()</code></a></span></li>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="ParamRegrModel" data-id="fit"><a href='../../gofreg/html/ParamRegrModel.html#method-ParamRegrModel-fit'><code>gofreg::ParamRegrModel$fit()</code></a></span></li>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="ParamRegrModel" data-id="get_params"><a href='../../gofreg/html/ParamRegrModel.html#method-ParamRegrModel-get_params'><code>gofreg::ParamRegrModel$get_params()</code></a></span></li>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="ParamRegrModel" data-id="sample_yx"><a href='../../gofreg/html/ParamRegrModel.html#method-ParamRegrModel-sample_yx'><code>gofreg::ParamRegrModel$sample_yx()</code></a></span></li>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="ParamRegrModel" data-id="set_params"><a href='../../gofreg/html/ParamRegrModel.html#method-ParamRegrModel-set_params'><code>gofreg::ParamRegrModel$set_params()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-GLM-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize an object of class GLM.
</p>


<h5>Usage</h5>

<div class="r"><pre>GLM$new(linkinv = identity, params = NA)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>linkinv</code></dt><dd><p>inverse link function, defaults to identity function</p>
</dd>
<dt><code>params</code></dt><dd><p>model parameters to use as default (optional)</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a new instance of the class
</p>


<hr>
<a id="method-GLM-mean_yx"></a>



<h4>Method <code>mean_yx()</code></h4>

<p>Evaluates the regression function or in other terms the
expected value of Y given X=x.
</p>


<h5>Usage</h5>

<div class="r"><pre>GLM$mean_yx(x, params = private$params)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>vector of covariates</p>
</dd>
<dt><code>params</code></dt><dd><p>model parameters to use, defaults to the fitted parameter
values</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>value of the regression function
</p>


<hr>
<a id="method-GLM-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>GLM$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='GLM.new'>Create GLM object with specific distribution family</h2><span id='topic+GLM.new'></span>

<h3>Description</h3>

<p>This constructor function can be used to create an instance of a
parametric GLM with specific distribution family, returning a new object of
<a href="#topic+NormalGLM">NormalGLM</a>, <a href="#topic+ExpGLM">ExpGLM</a>, <a href="#topic+WeibullGLM">WeibullGLM</a> or <a href="#topic+GammaGLM">GammaGLM</a>, depending on the value of
<code>distr</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GLM.new(distr, linkinv = identity, params = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GLM.new_+3A_distr">distr</code></td>
<td>
<p>distribution family</p>
</td></tr>
<tr><td><code id="GLM.new_+3A_linkinv">linkinv</code></td>
<td>
<p>inverse link function, defaults to identity function</p>
</td></tr>
<tr><td><code id="GLM.new_+3A_params">params</code></td>
<td>
<p>model parameters to use as default (optional)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a new instance of a GLM-subclass
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- GLM.new(distr = "normal")
# see examples of GLM-subclasses (e.g. NormalGLM) for how to use such models
</code></pre>

<hr>
<h2 id='GOFTest'>Goodness-of-fit test for parametric regression</h2><span id='topic+GOFTest'></span>

<h3>Description</h3>

<p>This class implements functions to calculate the test statistic
for the original data as well as the statistics for bootstrap samples. It
also offers the possibility to compute the corresponding bootstrap
p-value.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-GOFTest-new"><code>GOFTest$new()</code></a>
</p>
</li>
<li> <p><a href="#method-GOFTest-get_stat_orig"><code>GOFTest$get_stat_orig()</code></a>
</p>
</li>
<li> <p><a href="#method-GOFTest-get_stats_boot"><code>GOFTest$get_stats_boot()</code></a>
</p>
</li>
<li> <p><a href="#method-GOFTest-get_pvalue"><code>GOFTest$get_pvalue()</code></a>
</p>
</li>
<li> <p><a href="#method-GOFTest-plot_procs"><code>GOFTest$plot_procs()</code></a>
</p>
</li>
<li> <p><a href="#method-GOFTest-clone"><code>GOFTest$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-GOFTest-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize an instance of class <a href="#topic+GOFTest">GOFTest</a>.
</p>


<h5>Usage</h5>

<div class="r"><pre>GOFTest$new(
  data,
  model_fitted,
  test_stat,
  nboot,
  resample = resample_param,
  loglik = loglik_xy
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p><code>data.frame()</code> containing the data</p>
</dd>
<dt><code>model_fitted</code></dt><dd><p>object of class <a href="#topic+ParamRegrModel">ParamRegrModel</a> with fitted
parameters</p>
</dd>
<dt><code>test_stat</code></dt><dd><p>object of class <a href="#topic+TestStatistic">TestStatistic</a></p>
</dd>
<dt><code>nboot</code></dt><dd><p>number of bootstrap iterations</p>
</dd>
<dt><code>resample</code></dt><dd><p><code style="white-space: pre;">&#8288;function(data, model)&#8288;</code> used to resample data in
bootstrap iterations, defaults to <code><a href="#topic+resample_param">resample_param()</a></code></p>
</dd>
<dt><code>loglik</code></dt><dd><p><code style="white-space: pre;">&#8288;function(data, model, params)&#8288;</code> negative log-likelihood
function used to fit model to resampled data in bootstrap iterations,
defaults to <code><a href="#topic+loglik_xy">loglik_xy()</a></code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a new instance of the class
</p>


<hr>
<a id="method-GOFTest-get_stat_orig"></a>



<h4>Method <code>get_stat_orig()</code></h4>

<p>Calculates the test statistic for the original data and
model.
</p>


<h5>Usage</h5>

<div class="r"><pre>GOFTest$get_stat_orig()</pre></div>



<h5>Returns</h5>

<p>object of class <a href="#topic+TestStatistic">TestStatistic</a>
</p>


<hr>
<a id="method-GOFTest-get_stats_boot"></a>



<h4>Method <code>get_stats_boot()</code></h4>

<p>Calculates the test statistics for the resampled data and
corresponding models.
</p>


<h5>Usage</h5>

<div class="r"><pre>GOFTest$get_stats_boot()</pre></div>



<h5>Returns</h5>

<p>vector of length <code>nboot</code> containing objects of class
<a href="#topic+TestStatistic">TestStatistic</a>
</p>


<hr>
<a id="method-GOFTest-get_pvalue"></a>



<h4>Method <code>get_pvalue()</code></h4>

<p>Calculates the bootstrap p-value for the given model.
</p>


<h5>Usage</h5>

<div class="r"><pre>GOFTest$get_pvalue()</pre></div>



<h5>Returns</h5>

<p>p-value for the null hypothesis that <code>y</code> was generated according
to <code>model</code>
</p>


<hr>
<a id="method-GOFTest-plot_procs"></a>



<h4>Method <code>plot_procs()</code></h4>

<p>Plots the processes underlying the bootstrap test statistics
(gray) and the original test statistic (red)
</p>


<h5>Usage</h5>

<div class="r"><pre>GOFTest$plot_procs(
  title = sprintf("Test Statistic: %s, p-value: %s", class(private$test_stat)[1],
    self$get_pvalue()),
  subtitle = ggplot2::waiver(),
  color_boot = "gray40",
  color_orig = "red",
  x_lab = "plot.x",
  y_lab = "plot.y"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>title</code></dt><dd><p>text to be displayed as title of the plot; defaults to &quot;Test
statistic: xxx, p-value: xxx&quot;</p>
</dd>
<dt><code>subtitle</code></dt><dd><p>text to be displayed as subtitle of the plot; default is
no subtitle</p>
</dd>
<dt><code>color_boot</code></dt><dd><p>color used to plot bootstrap test statistics; default
is &quot;red&quot;</p>
</dd>
<dt><code>color_orig</code></dt><dd><p>color used to plot original test statistic; default is
&quot;gray40&quot;</p>
</dd>
<dt><code>x_lab</code></dt><dd><p>label to use for the x-axis; default is &quot;plot.x&quot;</p>
</dd>
<dt><code>y_lab</code></dt><dd><p>label to use for the y-axis; default is &quot;plot.y&quot;</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The object (<code>self</code>), allowing for method chaining.
</p>


<hr>
<a id="method-GOFTest-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>GOFTest$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'># Create an example dataset
n &lt;- 100
x &lt;- cbind(runif(n), rbinom(n, 1, 0.5))
model &lt;- NormalGLM$new()
y &lt;- model$sample_yx(x, params=list(beta=c(2,3), sd=1))
data &lt;- dplyr::tibble(x = x, y = y)

# Fit the correct model
model$fit(data, params_init=list(beta=c(1,1), sd=3), inplace = TRUE)

# Calculate the bootstrap p-value and plot the corresponding processes
goftest &lt;- GOFTest$new(data, model, test_stat = CondKolmY$new(), nboot = 10)
goftest$get_pvalue()
goftest$plot_procs()

# Fit a wrong model
model2 &lt;- NormalGLM$new(linkinv = function(u) {u+10})
model2$fit(data, params_init=list(beta=c(1,1), sd=3), inplace = TRUE)

# Calculate the bootstrap p-value and plot the corresponding processes
goftest2 &lt;- GOFTest$new(data, model2, test_stat = CondKolmY$new(), nboot = 10)
goftest2$get_pvalue()
goftest2$plot_procs()
</code></pre>

<hr>
<h2 id='loglik_xy'>Negative log-likelihood function for a parametric regression model</h2><span id='topic+loglik_xy'></span>

<h3>Description</h3>

<p>The log-likelihood function for a parametric regression model
with data (x,y) is given by the sum of the logarithm of the conditional
density of Y given X=x evaluated at y.
</p>
<p>This function is one option that can be used to fit a <a href="#topic+ParamRegrModel">ParamRegrModel</a>. It
returns the negative log-likelihood value in order for <code>optim()</code> to
maximize (instead of minimize).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglik_xy(data, model, params)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loglik_xy_+3A_data">data</code></td>
<td>
<p><code>list()</code> with tags x and y containing the data</p>
</td></tr>
<tr><td><code id="loglik_xy_+3A_model">model</code></td>
<td>
<p><a href="#topic+ParamRegrModel">ParamRegrModel</a> to use for the likelihood function</p>
</td></tr>
<tr><td><code id="loglik_xy_+3A_params">params</code></td>
<td>
<p>vector with model parameters to compute likelihood function for</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value of the negative log-likelihood function
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create an example dataset
n &lt;- 100
x &lt;- cbind(runif(n), rbinom(n, 1, 0.5))
model &lt;- NormalGLM$new()
params.true &lt;- list(beta = c(2,3), sd = 1)
y &lt;- model$sample_yx(x, params = params.true)
data &lt;- dplyr::tibble(x = x, y = y)

# Compute negative log likelihood for true parameters
loglik_xy(data, model, params.true)

# Compute negative log likelihood for wrong parameters (should be higher)
loglik_xy(data, model, params = list(beta = c(1,2), sd = 0.5))
</code></pre>

<hr>
<h2 id='loglik_xzd'>Negative log-likelihood function for a parametric regression model under
random censorship</h2><span id='topic+loglik_xzd'></span>

<h3>Description</h3>

<p>The log-likelihood function for a parametric regression model
under random censorship with data (x,z,delta) is given by the sum of the
logarithm of the conditional density of Y given X=x evaluated at z if z was
uncensored or the logarithm of the conditional survival of Y given X=x
evaluated at z if z was censored.
</p>
<p>This function is one option that can be used to fit a <a href="#topic+ParamRegrModel">ParamRegrModel</a>. It
returns the negative log-likelihood value in order for <code>optim()</code> to
maximize (instead of minimize).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglik_xzd(data, model, params)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loglik_xzd_+3A_data">data</code></td>
<td>
<p><code>list()</code> with tags x, z and delta containing the data</p>
</td></tr>
<tr><td><code id="loglik_xzd_+3A_model">model</code></td>
<td>
<p><a href="#topic+ParamRegrModel">ParamRegrModel</a> to use for the likelihood function</p>
</td></tr>
<tr><td><code id="loglik_xzd_+3A_params">params</code></td>
<td>
<p>vector with model parameters to compute likelihood function for</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value of the negative log-likelihood function
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create an example dataset
n &lt;- 100
x &lt;- cbind(runif(n), rbinom(n, 1, 0.5))
model &lt;- NormalGLM$new()
params.true &lt;- list(beta = c(2,3), sd = 1)
y &lt;- model$sample_yx(x, params = params.true)
c &lt;- rnorm(n, mean(y) * 1.2, sd(y) * 0.5)
data &lt;- dplyr::tibble(x = x, z = pmin(y, c), delta = as.numeric(y &lt;= c))

# Compute negative log likelihood for true parameters
loglik_xzd(data, model, params.true)

# Compute negative log likelihood for wrong parameters (should be higher)
loglik_xzd(data, model, params = list(beta = c(1,2), sd = 0.5))
</code></pre>

<hr>
<h2 id='MEP'>Marked empirical process test statistic for a given GLM</h2><span id='topic+MEP'></span>

<h3>Description</h3>

<p>This class inherits from <a href="#topic+TestStatistic">TestStatistic</a> and implements a
function to calculate the test statistic (and x-y-values that can be used
to plot the underlying process).
</p>
<p>The process underlying the test statistic is given in Dikta &amp; Scheer
(2021) doi: <a href="https://doi.org/10.1007/978-3-030-73480-0">10.1007/978-3-030-73480-0</a> and defined by </p>
<p style="text-align: center;"><code class="reqn">\bar{R}^1_n(u)
  = \frac{1}{\sqrt{n}} \sum_{i=1}^n \left( Y_i - m(X_i, \hat{\beta}_n)
  \right) I_{\{\hat{\beta}_n X_i \le u\}}, \quad -\infty \le u \le \infty.</code>
</p>



<h3>Super class</h3>

<p><code><a href="#topic+TestStatistic">gofreg::TestStatistic</a></code> -&gt; <code>MEP</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-MEP-calc_stat"><code>MEP$calc_stat()</code></a>
</p>
</li>
<li> <p><a href="#method-MEP-clone"><code>MEP$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="TestStatistic" data-id="geom_ts_proc"><a href='../../gofreg/html/TestStatistic.html#method-TestStatistic-geom_ts_proc'><code>gofreg::TestStatistic$geom_ts_proc()</code></a></span></li>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="TestStatistic" data-id="get_plot_xy"><a href='../../gofreg/html/TestStatistic.html#method-TestStatistic-get_plot_xy'><code>gofreg::TestStatistic$get_plot_xy()</code></a></span></li>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="TestStatistic" data-id="get_value"><a href='../../gofreg/html/TestStatistic.html#method-TestStatistic-get_value'><code>gofreg::TestStatistic$get_value()</code></a></span></li>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="TestStatistic" data-id="plot"><a href='../../gofreg/html/TestStatistic.html#method-TestStatistic-plot'><code>gofreg::TestStatistic$plot()</code></a></span></li>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="TestStatistic" data-id="print"><a href='../../gofreg/html/TestStatistic.html#method-TestStatistic-print'><code>gofreg::TestStatistic$print()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-MEP-calc_stat"></a>



<h4>Method <code>calc_stat()</code></h4>

<p>Calculate the value of the test statistic for given data
and a model to test for.
</p>


<h5>Usage</h5>

<div class="r"><pre>MEP$calc_stat(data, model)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p><code>data.frame()</code> with columns x and y containing the data</p>
</dd>
<dt><code>model</code></dt><dd><p><a href="#topic+ParamRegrModel">ParamRegrModel</a> to test for</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The modified object (<code>self</code>), allowing for method chaining.
</p>


<hr>
<a id="method-MEP-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>MEP$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'># Create an example dataset
n &lt;- 100
x &lt;- cbind(runif(n), rbinom(n, 1, 0.5))
model &lt;- NormalGLM$new()
y &lt;- model$sample_yx(x, params=list(beta=c(2,3), sd=1))
data &lt;- dplyr::tibble(x = x, y = y)

# Fit the correct model
model$fit(data, params_init=list(beta=c(1,1), sd=3), inplace = TRUE)

# Print value of test statistic and plot corresponding process
ts &lt;- MEP$new()
ts$calc_stat(data, model)
print(ts)
plot(ts)

# Fit a wrong model
model2 &lt;- NormalGLM$new(linkinv = function(u) {u+10})
model2$fit(data, params_init=list(beta=c(1,1), sd=3), inplace = TRUE)

# Print value of test statistic and plot corresponding process
ts2 &lt;- MEP$new()
ts2$calc_stat(data, model2)
print(ts2)
plot(ts2)
</code></pre>

<hr>
<h2 id='NegBinomGLM'>Generalized linear model with negative binomial distribution</h2><span id='topic+NegBinomGLM'></span>

<h3>Description</h3>

<p>This class represents a generalized linear model with negative
binomial distribution. It inherits from <a href="#topic+GLM">GLM</a> and implements its functions
that, for example, evaluate the conditional density and distribution
functions.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+ParamRegrModel">gofreg::ParamRegrModel</a></code> -&gt; <code><a href="#topic+GLM">gofreg::GLM</a></code> -&gt; <code>NegBinomGLM</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-NegBinomGLM-fit"><code>NegBinomGLM$fit()</code></a>
</p>
</li>
<li> <p><a href="#method-NegBinomGLM-f_yx"><code>NegBinomGLM$f_yx()</code></a>
</p>
</li>
<li> <p><a href="#method-NegBinomGLM-F_yx"><code>NegBinomGLM$F_yx()</code></a>
</p>
</li>
<li> <p><a href="#method-NegBinomGLM-F1_yx"><code>NegBinomGLM$F1_yx()</code></a>
</p>
</li>
<li> <p><a href="#method-NegBinomGLM-sample_yx"><code>NegBinomGLM$sample_yx()</code></a>
</p>
</li>
<li> <p><a href="#method-NegBinomGLM-clone"><code>NegBinomGLM$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="ParamRegrModel" data-id="get_params"><a href='../../gofreg/html/ParamRegrModel.html#method-ParamRegrModel-get_params'><code>gofreg::ParamRegrModel$get_params()</code></a></span></li>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="ParamRegrModel" data-id="set_params"><a href='../../gofreg/html/ParamRegrModel.html#method-ParamRegrModel-set_params'><code>gofreg::ParamRegrModel$set_params()</code></a></span></li>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="GLM" data-id="initialize"><a href='../../gofreg/html/GLM.html#method-GLM-initialize'><code>gofreg::GLM$initialize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="GLM" data-id="mean_yx"><a href='../../gofreg/html/GLM.html#method-GLM-mean_yx'><code>gofreg::GLM$mean_yx()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-NegBinomGLM-fit"></a>



<h4>Method <code>fit()</code></h4>

<p>Calculates the maximum likelihood estimator for the model
parameters based on given data.
</p>


<h5>Usage</h5>

<div class="r"><pre>NegBinomGLM$fit(
  data,
  params_init = private$params,
  loglik = loglik_xy,
  inplace = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>tibble containing the data to fit the model to</p>
</dd>
<dt><code>params_init</code></dt><dd><p>initial value of the model parameters to use for the
optimization (defaults to the fitted parameter values)</p>
</dd>
<dt><code>loglik</code></dt><dd><p><code style="white-space: pre;">&#8288;function(data, model, params)&#8288;</code> defaults to <code><a href="#topic+loglik_xy">loglik_xy()</a></code></p>
</dd>
<dt><code>inplace</code></dt><dd><p><code>logical</code>; if <code>TRUE</code>, default model parameters are set
accordingly and parameter estimator is not returned</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>MLE of the model parameters for the given data, same shape as
<code>params_init</code>
</p>


<hr>
<a id="method-NegBinomGLM-f_yx"></a>



<h4>Method <code>f_yx()</code></h4>

<p>Evaluates the conditional density function.
</p>


<h5>Usage</h5>

<div class="r"><pre>NegBinomGLM$f_yx(t, x, params = private$params)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>t</code></dt><dd><p>value(s) at which the conditional density shall be evaluated</p>
</dd>
<dt><code>x</code></dt><dd><p>matrix of covariates, each row representing one sample</p>
</dd>
<dt><code>params</code></dt><dd><p>model parameters to use (<code>list()</code> with tags beta and shape),
defaults to the fitted parameter values</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>value(s) of the conditional density function, same shape as <code>t</code>
</p>


<hr>
<a id="method-NegBinomGLM-F_yx"></a>



<h4>Method <code>F_yx()</code></h4>

<p>Evaluates the conditional distribution function.
</p>


<h5>Usage</h5>

<div class="r"><pre>NegBinomGLM$F_yx(t, x, params = private$params)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>t</code></dt><dd><p>value(s) at which the conditional distribution shall be
evaluated</p>
</dd>
<dt><code>x</code></dt><dd><p>matrix of covariates, each row representing one sample</p>
</dd>
<dt><code>params</code></dt><dd><p>model parameters to use (<code>list()</code> with tags beta and shape),
defaults to the fitted parameter values</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>value(s) of the conditional distribution function,  same shape as
<code>t</code>
</p>


<hr>
<a id="method-NegBinomGLM-F1_yx"></a>



<h4>Method <code>F1_yx()</code></h4>

<p>Evaluates the conditional quantile function.
</p>


<h5>Usage</h5>

<div class="r"><pre>NegBinomGLM$F1_yx(t, x, params = private$params)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>t</code></dt><dd><p>value(s) at which the conditional quantile function shall be
evaluated</p>
</dd>
<dt><code>x</code></dt><dd><p>matrix of covariates, each row representing one sample</p>
</dd>
<dt><code>params</code></dt><dd><p>model parameters to use (<code>list()</code> with tags beta and shape),
defaults to the fitted parameter values</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>value(s) of the conditional quantile function, same shape as
<code>t</code>
</p>


<hr>
<a id="method-NegBinomGLM-sample_yx"></a>



<h4>Method <code>sample_yx()</code></h4>

<p>Generates a new sample of response variables with the same
conditional distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>NegBinomGLM$sample_yx(x, params = private$params)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>matrix of covariates, each row representing one sample</p>
</dd>
<dt><code>params</code></dt><dd><p>model parameters to use (<code>list()</code> with tags beta and shape),
defaults to the fitted parameter values</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>vector of sampled response variables, same length as <code>nrow(x)</code>
</p>


<hr>
<a id="method-NegBinomGLM-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>NegBinomGLM$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'># Use the built-in cars dataset
x &lt;- datasets::cars$speed
y &lt;- datasets::cars$dist
data &lt;- dplyr::tibble(x=x, y=y)

# Create an instance of a NegBinomGLM
model &lt;- NegBinomGLM$new()

# Fit a Negative Binomial GLM to the cars dataset
model$fit(data, params_init = list(beta=3, shape=2), inplace=TRUE)
params_opt &lt;- model$get_params()

# Plot the resulting regression function
plot(datasets::cars)
abline(a = 0, b = params_opt$beta)

# Generate a sample for y for given x following the same distribution
x.new &lt;- seq(min(x), max(x), by=2)
y.smpl &lt;- model$sample_yx(x.new)
points(x.new, y.smpl, col="red")

# Evaluate the conditional density, distribution, quantile and regression
# function at given values
model$f_yx(y.smpl, x.new)
model$F_yx(y.smpl, x.new)
model$F1_yx(y.smpl, x.new)
y.pred &lt;- model$mean_yx(x.new)
points(x.new, y.pred, col="blue")
</code></pre>

<hr>
<h2 id='NormalGLM'>Generalized linear model with normal distribution</h2><span id='topic+NormalGLM'></span>

<h3>Description</h3>

<p>This class represents a generalized linear model with normal
distribution. It inherits from <a href="#topic+GLM">GLM</a> and implements its functions that,
for example, evaluate the conditional density and distribution functions.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+ParamRegrModel">gofreg::ParamRegrModel</a></code> -&gt; <code><a href="#topic+GLM">gofreg::GLM</a></code> -&gt; <code>NormalGLM</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-NormalGLM-fit"><code>NormalGLM$fit()</code></a>
</p>
</li>
<li> <p><a href="#method-NormalGLM-f_yx"><code>NormalGLM$f_yx()</code></a>
</p>
</li>
<li> <p><a href="#method-NormalGLM-F_yx"><code>NormalGLM$F_yx()</code></a>
</p>
</li>
<li> <p><a href="#method-NormalGLM-F1_yx"><code>NormalGLM$F1_yx()</code></a>
</p>
</li>
<li> <p><a href="#method-NormalGLM-sample_yx"><code>NormalGLM$sample_yx()</code></a>
</p>
</li>
<li> <p><a href="#method-NormalGLM-clone"><code>NormalGLM$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="ParamRegrModel" data-id="get_params"><a href='../../gofreg/html/ParamRegrModel.html#method-ParamRegrModel-get_params'><code>gofreg::ParamRegrModel$get_params()</code></a></span></li>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="ParamRegrModel" data-id="set_params"><a href='../../gofreg/html/ParamRegrModel.html#method-ParamRegrModel-set_params'><code>gofreg::ParamRegrModel$set_params()</code></a></span></li>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="GLM" data-id="initialize"><a href='../../gofreg/html/GLM.html#method-GLM-initialize'><code>gofreg::GLM$initialize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="GLM" data-id="mean_yx"><a href='../../gofreg/html/GLM.html#method-GLM-mean_yx'><code>gofreg::GLM$mean_yx()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-NormalGLM-fit"></a>



<h4>Method <code>fit()</code></h4>

<p>Calculates the maximum likelihood estimator for the model
parameters based on given data.
</p>


<h5>Usage</h5>

<div class="r"><pre>NormalGLM$fit(
  data,
  params_init = private$params,
  loglik = loglik_xy,
  inplace = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>tibble containing the data to fit the model to</p>
</dd>
<dt><code>params_init</code></dt><dd><p>initial value of the model parameters to use for the
optimization (defaults to the fitted parameter values)</p>
</dd>
<dt><code>loglik</code></dt><dd><p><code style="white-space: pre;">&#8288;function(data, model, params)&#8288;</code> defaults to <code><a href="#topic+loglik_xy">loglik_xy()</a></code></p>
</dd>
<dt><code>inplace</code></dt><dd><p><code>logical</code>; if <code>TRUE</code>, default model parameters are set
accordingly and parameter estimator is not returned</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>MLE of the model parameters for the given data, same shape as
<code>params_init</code>
</p>


<hr>
<a id="method-NormalGLM-f_yx"></a>



<h4>Method <code>f_yx()</code></h4>

<p>Evaluates the conditional density function.
</p>


<h5>Usage</h5>

<div class="r"><pre>NormalGLM$f_yx(t, x, params = private$params)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>t</code></dt><dd><p>value(s) at which the conditional density shall be evaluated</p>
</dd>
<dt><code>x</code></dt><dd><p>matrix of covariates, each row representing one sample</p>
</dd>
<dt><code>params</code></dt><dd><p>model parameters to use (<code>list()</code> with tags beta and sd),
defaults to the fitted parameter values</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>value(s) of the conditional density function, same shape as <code>t</code>
</p>


<hr>
<a id="method-NormalGLM-F_yx"></a>



<h4>Method <code>F_yx()</code></h4>

<p>Evaluates the conditional distribution function.
</p>


<h5>Usage</h5>

<div class="r"><pre>NormalGLM$F_yx(t, x, params = private$params)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>t</code></dt><dd><p>value(s) at which the conditional distribution shall be
evaluated</p>
</dd>
<dt><code>x</code></dt><dd><p>matrix of covariates, each row representing one sample</p>
</dd>
<dt><code>params</code></dt><dd><p>model parameters to use (<code>list()</code> with tags beta and sd),
defaults to the fitted parameter values</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>value(s) of the conditional distribution function,  same shape as
<code>t</code>
</p>


<hr>
<a id="method-NormalGLM-F1_yx"></a>



<h4>Method <code>F1_yx()</code></h4>

<p>Evaluates the conditional quantile function.
</p>


<h5>Usage</h5>

<div class="r"><pre>NormalGLM$F1_yx(t, x, params = private$params)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>t</code></dt><dd><p>value(s) at which the conditional quantile function shall be
evaluated</p>
</dd>
<dt><code>x</code></dt><dd><p>matrix of covariates, each row representing one sample</p>
</dd>
<dt><code>params</code></dt><dd><p>model parameters to use (<code>list()</code> with tags beta and sd),
defaults to the fitted parameter values</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>value(s) of the conditional quantile function, same shape as
<code>t</code>
</p>


<hr>
<a id="method-NormalGLM-sample_yx"></a>



<h4>Method <code>sample_yx()</code></h4>

<p>Generates a new sample of response variables with the same
conditional distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>NormalGLM$sample_yx(x, params = private$params)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>matrix of covariates, each row representing one sample</p>
</dd>
<dt><code>params</code></dt><dd><p>model parameters to use (<code>list()</code> with tags beta and sd),
defaults to the fitted parameter values</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>vector of sampled response variables, same length as <code>nrow(x)</code>
</p>


<hr>
<a id="method-NormalGLM-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>NormalGLM$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'># Use the built-in cars dataset
x &lt;- datasets::cars$speed
y &lt;- datasets::cars$dist
data &lt;- dplyr::tibble(x=x, y=y)

# Create an instance of a NormalGLM
model &lt;- NormalGLM$new()

# Fit a Normal GLM to the cars dataset
model$fit(data, params_init = list(beta=3, sd=2), inplace=TRUE)
params_opt &lt;- model$get_params()

# Plot the resulting regression function
plot(datasets::cars)
abline(a = 0, b = params_opt$beta)

# Generate a sample for y for given x following the same distribution
x.new &lt;- seq(min(x), max(x), by=2)
y.smpl &lt;- model$sample_yx(x.new)
points(x.new, y.smpl, col="red")

# Evaluate the conditional density, distribution, quantile and regression
# function at given values
model$f_yx(y.smpl, x.new)
model$F_yx(y.smpl, x.new)
model$F1_yx(y.smpl, x.new)
y.pred &lt;- model$mean_yx(x.new)
points(x.new, y.pred, col="blue")
</code></pre>

<hr>
<h2 id='ParamRegrModel'>Parametric regression model (abstract class)</h2><span id='topic+ParamRegrModel'></span>

<h3>Description</h3>

<p>This is the abstract base class for parametric regression model
objects like <a href="#topic+NormalGLM">NormalGLM</a>.
</p>
<p>Parametric regression models are built around the following key tasks:
</p>

<ul>
<li><p> A method <code>fit()</code> to fit the model to given data, i.e. compute the MLE
for the model parameters
</p>
</li>
<li><p> Methods <code>f_yx()</code>, <code>F_yx()</code> and <code>mean_yx()</code> to evaluate the conditional
density, distribution and regression function
</p>
</li>
<li><p> A method <code>sample_yx()</code> to generate a random sample of response variables
following the model given a vector of covariates
</p>
</li></ul>



<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ParamRegrModel-set_params"><code>ParamRegrModel$set_params()</code></a>
</p>
</li>
<li> <p><a href="#method-ParamRegrModel-get_params"><code>ParamRegrModel$get_params()</code></a>
</p>
</li>
<li> <p><a href="#method-ParamRegrModel-fit"><code>ParamRegrModel$fit()</code></a>
</p>
</li>
<li> <p><a href="#method-ParamRegrModel-f_yx"><code>ParamRegrModel$f_yx()</code></a>
</p>
</li>
<li> <p><a href="#method-ParamRegrModel-F_yx"><code>ParamRegrModel$F_yx()</code></a>
</p>
</li>
<li> <p><a href="#method-ParamRegrModel-F1_yx"><code>ParamRegrModel$F1_yx()</code></a>
</p>
</li>
<li> <p><a href="#method-ParamRegrModel-sample_yx"><code>ParamRegrModel$sample_yx()</code></a>
</p>
</li>
<li> <p><a href="#method-ParamRegrModel-mean_yx"><code>ParamRegrModel$mean_yx()</code></a>
</p>
</li>
<li> <p><a href="#method-ParamRegrModel-clone"><code>ParamRegrModel$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-ParamRegrModel-set_params"></a>



<h4>Method <code>set_params()</code></h4>

<p>Set the value of the model parameters used as default for the
class functions.
</p>


<h5>Usage</h5>

<div class="r"><pre>ParamRegrModel$set_params(params)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>model parameters to use as default</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The modified object (<code>self</code>), allowing for method chaining.
</p>


<hr>
<a id="method-ParamRegrModel-get_params"></a>



<h4>Method <code>get_params()</code></h4>

<p>Returns the value of the model parameters used as default for
the class functions.
</p>


<h5>Usage</h5>

<div class="r"><pre>ParamRegrModel$get_params()</pre></div>



<h5>Returns</h5>

<p>model parameters used as default
</p>


<hr>
<a id="method-ParamRegrModel-fit"></a>



<h4>Method <code>fit()</code></h4>

<p>Calculates the maximum likelihood estimator for the model
parameters based on given data.
</p>


<h5>Usage</h5>

<div class="r"><pre>ParamRegrModel$fit(data, params_init = private$params, loglik = loglik_xy)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>list containing the data to fit the model to</p>
</dd>
<dt><code>params_init</code></dt><dd><p>initial value of the model parameters to use for the
optimization (defaults to the fitted parameter values)</p>
</dd>
<dt><code>loglik</code></dt><dd><p><code style="white-space: pre;">&#8288;function(data, model, params)&#8288;</code> defaults to <code><a href="#topic+loglik_xy">loglik_xy()</a></code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>MLE of the model parameters for the given data, same shape as
<code>params_init</code>
</p>


<hr>
<a id="method-ParamRegrModel-f_yx"></a>



<h4>Method <code>f_yx()</code></h4>

<p>Evaluates the conditional density function.
</p>


<h5>Usage</h5>

<div class="r"><pre>ParamRegrModel$f_yx(t, x, params = private$params)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>t</code></dt><dd><p>value(s) at which the conditional density shall be evaluated</p>
</dd>
<dt><code>x</code></dt><dd><p>vector of covariates</p>
</dd>
<dt><code>params</code></dt><dd><p>model parameters to use, defaults to the fitted parameter
values</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>value(s) of the conditional density function, same shape as <code>t</code>
</p>


<hr>
<a id="method-ParamRegrModel-F_yx"></a>



<h4>Method <code>F_yx()</code></h4>

<p>Evaluates the conditional distribution function.
</p>


<h5>Usage</h5>

<div class="r"><pre>ParamRegrModel$F_yx(t, x, params = private$params)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>t</code></dt><dd><p>value(s) at which the conditional distribution shall be
evaluated</p>
</dd>
<dt><code>x</code></dt><dd><p>vector of covariates</p>
</dd>
<dt><code>params</code></dt><dd><p>model parameters to use, defaults to the fitted parameter
values</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>value(s) of the conditional distribution function, same shape as
<code>t</code>
</p>


<hr>
<a id="method-ParamRegrModel-F1_yx"></a>



<h4>Method <code>F1_yx()</code></h4>

<p>Evaluates the conditional quantile function.
</p>


<h5>Usage</h5>

<div class="r"><pre>ParamRegrModel$F1_yx(t, x, params = private$params)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>t</code></dt><dd><p>value(s) at which the conditional quantile function shall be
evaluated</p>
</dd>
<dt><code>x</code></dt><dd><p>vector of covariates</p>
</dd>
<dt><code>params</code></dt><dd><p>model parameters to use, defaults to the fitted parameter
values</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>value(s) of the conditional quantile function, same shape as
<code>t</code>
</p>


<hr>
<a id="method-ParamRegrModel-sample_yx"></a>



<h4>Method <code>sample_yx()</code></h4>

<p>Generates a new sample of response variables with the same
conditional distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>ParamRegrModel$sample_yx(x, params = private$params)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>vector of covariates</p>
</dd>
<dt><code>params</code></dt><dd><p>model parameters to use, defaults to the fitted parameter
values</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>vector of sampled response variables, same length as <code>x</code>
</p>


<hr>
<a id="method-ParamRegrModel-mean_yx"></a>



<h4>Method <code>mean_yx()</code></h4>

<p>Evaluates the regression function or in other terms the
expected value of Y given X=x.
</p>


<h5>Usage</h5>

<div class="r"><pre>ParamRegrModel$mean_yx(x, params = private$params)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>vector of covariates</p>
</dd>
<dt><code>params</code></dt><dd><p>model parameters to use, defaults to the fitted parameter
values</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>value of the regression function
</p>


<hr>
<a id="method-ParamRegrModel-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ParamRegrModel$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='resample_param'>Parametric resampling scheme for a parametric regression model</h2><span id='topic+resample_param'></span>

<h3>Description</h3>

<p>Generate a new, resampled dataset of the same shape as data
following the given model. The covariates are kept the same and the
response variables are drawn according to <code>model$sample_yx()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resample_param(data, model)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resample_param_+3A_data">data</code></td>
<td>
<p><code>data.frame()</code> with columns x and y containing the original data</p>
</td></tr>
<tr><td><code id="resample_param_+3A_model">model</code></td>
<td>
<p><a href="#topic+ParamRegrModel">ParamRegrModel</a> to use for the resampling</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame()</code> with columns x and y containing the resampled data
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create an example dataset
n &lt;- 10
x &lt;- cbind(runif(n), rbinom(n, 1, 0.5))
model &lt;- NormalGLM$new()
params &lt;- list(beta = c(2, 3), sd = 1)
y &lt;- model$sample_yx(x, params = params)
data &lt;- dplyr::tibble(x = x, y = y)

# Fit the model to the data
model$fit(data, params_init = params, inplace = TRUE)

# Resample from the model given data
resample_param(data, model)
</code></pre>

<hr>
<h2 id='resample_param_cens'>Parametric resampling scheme for a parametric regression model under random
censorship</h2><span id='topic+resample_param_cens'></span>

<h3>Description</h3>

<p>Generate a new, resampled dataset of the same shape as data
following the given model. The covariates X are kept the same. Survival
times Y are drawn according to <code>model$sample_yx()</code> and censoring times C
according to the KM estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resample_param_cens(data, model)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resample_param_cens_+3A_data">data</code></td>
<td>
<p><code>data.frame()</code> with columns x, z and delta containing the
original data</p>
</td></tr>
<tr><td><code id="resample_param_cens_+3A_model">model</code></td>
<td>
<p><a href="#topic+ParamRegrModel">ParamRegrModel</a> to use for the resampling</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame()</code> with columns x, z and delta containing the resampled
data
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create an example dataset
n &lt;- 10
x &lt;- cbind(runif(n), rbinom(n, 1, 0.5))
model &lt;- NormalGLM$new()
params &lt;- list(beta = c(2, 3), sd = 1)
y &lt;- model$sample_yx(x, params = params)
c &lt;- rnorm(n, mean(y) * 1.2, sd(y) * 0.5)
z &lt;- pmin(y, c)
delta &lt;- as.numeric(y &lt;= c)
data &lt;- dplyr::tibble(x = x, z = z, delta = delta)

# Fit the model to the data
model$fit(data, params_init = params, inplace = TRUE, loglik = loglik_xzd)

# Resample from the model given data
resample_param_cens(data, model)
</code></pre>

<hr>
<h2 id='resample_param_rsmplx'>Parametric resampling scheme for a parametric regression model with
resampling of covariates</h2><span id='topic+resample_param_rsmplx'></span>

<h3>Description</h3>

<p>Generate a new, resampled dataset of the same shape as data
following the given model. The covariates are resampled from <code>data$x</code> and
the response variables are drawn according to <code>model$sample_yx()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resample_param_rsmplx(data, model)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resample_param_rsmplx_+3A_data">data</code></td>
<td>
<p><code>data.frame()</code> with columns x and y containing the original data</p>
</td></tr>
<tr><td><code id="resample_param_rsmplx_+3A_model">model</code></td>
<td>
<p><a href="#topic+ParamRegrModel">ParamRegrModel</a> to use for the resampling</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame()</code> with columns x and y containing the resampled data
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create an example dataset
n &lt;- 10
x &lt;- cbind(runif(n), rbinom(n, 1, 0.5))
model &lt;- NormalGLM$new()
params &lt;- list(beta = c(2, 3), sd = 1)
y &lt;- model$sample_yx(x, params = params)
data &lt;- dplyr::tibble(x = x, y = y)

# Fit the model to the data
model$fit(data, params_init = params, inplace = TRUE)

# Resample from the model given data
resample_param(data, model)
</code></pre>

<hr>
<h2 id='SICM'>Simulated integrated conditional moment test statistic</h2><span id='topic+SICM'></span>

<h3>Description</h3>

<p>This class inherits from <a href="#topic+TestStatistic">TestStatistic</a> and implements a
function to calculate the test statistic (and x-y-values that can be used
to plot the underlying process).
</p>
<p>The process underlying the test statistic is given in Bierens &amp; Wang
(2012) doi: <a href="https://doi.org/10.1017/S0266466611000168">10.1017/S0266466611000168</a> and defined by
</p>
<p style="text-align: center;"><code class="reqn">\hat{T}_n^{(s)}(c) = \frac{1}{(2c)^{p+1}} \int_{[-c,c]^p}
  \int_{-c}^c \left|\frac{1}{\sqrt{n}} \sum_{j=1}^n \Big(\exp(i \tau Y_j) -
  \exp(i \tau \tilde{Y}_j)\Big) \exp(i \xi^T X_j)\right|^2 d\tau d\xi </code>
</p>



<h3>Super class</h3>

<p><code><a href="#topic+TestStatistic">gofreg::TestStatistic</a></code> -&gt; <code>SICM</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-SICM-new"><code>SICM$new()</code></a>
</p>
</li>
<li> <p><a href="#method-SICM-calc_stat"><code>SICM$calc_stat()</code></a>
</p>
</li>
<li> <p><a href="#method-SICM-clone"><code>SICM$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="TestStatistic" data-id="geom_ts_proc"><a href='../../gofreg/html/TestStatistic.html#method-TestStatistic-geom_ts_proc'><code>gofreg::TestStatistic$geom_ts_proc()</code></a></span></li>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="TestStatistic" data-id="get_plot_xy"><a href='../../gofreg/html/TestStatistic.html#method-TestStatistic-get_plot_xy'><code>gofreg::TestStatistic$get_plot_xy()</code></a></span></li>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="TestStatistic" data-id="get_value"><a href='../../gofreg/html/TestStatistic.html#method-TestStatistic-get_value'><code>gofreg::TestStatistic$get_value()</code></a></span></li>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="TestStatistic" data-id="plot"><a href='../../gofreg/html/TestStatistic.html#method-TestStatistic-plot'><code>gofreg::TestStatistic$plot()</code></a></span></li>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="TestStatistic" data-id="print"><a href='../../gofreg/html/TestStatistic.html#method-TestStatistic-print'><code>gofreg::TestStatistic$print()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-SICM-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize an instance of class <a href="#topic+SICM">SICM</a>.
</p>


<h5>Usage</h5>

<div class="r"><pre>SICM$new(
  c,
  transx = function(values) {
     tvals &lt;- atan(scale(values))
     tvals[,
    apply(values, 2, sd) == 0] &lt;- 0
     return(tvals)
 },
  transy = function(values, data) {
     array(atan(scale(values, center = mean(data$y),
    scale = sd(data$y))))
 }
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>c</code></dt><dd><p>chosen value for integral boundaries (see Bierens &amp; Wang (2012))</p>
</dd>
<dt><code>transx</code></dt><dd><p><code style="white-space: pre;">&#8288;function(values)&#8288;</code> used to transform x-values to be
standardized and bounded; default is standardization by subtracting the
mean and dividing by the standard deviation and then applying arctan</p>
</dd>
<dt><code>transy</code></dt><dd><p><code style="white-space: pre;">&#8288;function(values, data)&#8288;</code> used to transform y-values to be
standardized and bounded (same method is used for simulated y-values);
default is standardization by subtracting the mean and dividing by the
standard deviation and then applying arctan</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a new instance of the class
</p>


<hr>
<a id="method-SICM-calc_stat"></a>



<h4>Method <code>calc_stat()</code></h4>

<p>Calculate the value of the test statistic for given data
and a model to test for.
</p>


<h5>Usage</h5>

<div class="r"><pre>SICM$calc_stat(data, model)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p><code>data.frame()</code> with columns x and y containing the data</p>
</dd>
<dt><code>model</code></dt><dd><p><a href="#topic+ParamRegrModel">ParamRegrModel</a> to test for</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The modified object (<code>self</code>), allowing for method chaining.
</p>


<hr>
<a id="method-SICM-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SICM$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'># Create an example dataset
n &lt;- 100
x &lt;- cbind(runif(n), rbinom(n, 1, 0.5))
model &lt;- NormalGLM$new()
y &lt;- model$sample_yx(x, params=list(beta=c(2,3), sd=1))
data &lt;- dplyr::tibble(x = x, y = y)

# Fit the correct model
model$fit(data, params_init=list(beta=c(1,1), sd=3), inplace = TRUE)

# Print value of test statistic and plot corresponding process
ts &lt;- SICM$new(c = 5)
ts$calc_stat(data, model)
print(ts)
plot(ts)

# Fit a wrong model
model2 &lt;- NormalGLM$new(linkinv = function(u) {u+10})
model2$fit(data, params_init=list(beta=c(1,1), sd=3), inplace = TRUE)

# Print value of test statistic and plot corresponding process
ts2 &lt;- SICM$new(c = 5)
ts2$calc_stat(data, model2)
print(ts2)
plot(ts2)
</code></pre>

<hr>
<h2 id='TestStatistic'>Test Statistic for parametric regression models (abstract class)</h2><span id='topic+TestStatistic'></span>

<h3>Description</h3>

<p>This is the abstract base class for test statistic objects like
<a href="#topic+CondKolmY">CondKolmY</a> or <a href="#topic+MEP">MEP</a>.
</p>
<p>Test statistics are built around the key method
<code>calc_stat()</code> which calculates the particular test statistic (and
x-y-values that can be used to plot the underlying process).
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-TestStatistic-get_value"><code>TestStatistic$get_value()</code></a>
</p>
</li>
<li> <p><a href="#method-TestStatistic-calc_stat"><code>TestStatistic$calc_stat()</code></a>
</p>
</li>
<li> <p><a href="#method-TestStatistic-get_plot_xy"><code>TestStatistic$get_plot_xy()</code></a>
</p>
</li>
<li> <p><a href="#method-TestStatistic-print"><code>TestStatistic$print()</code></a>
</p>
</li>
<li> <p><a href="#method-TestStatistic-geom_ts_proc"><code>TestStatistic$geom_ts_proc()</code></a>
</p>
</li>
<li> <p><a href="#method-TestStatistic-plot"><code>TestStatistic$plot()</code></a>
</p>
</li>
<li> <p><a href="#method-TestStatistic-clone"><code>TestStatistic$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-TestStatistic-get_value"></a>



<h4>Method <code>get_value()</code></h4>

<p>Returns the value of the test statistic.
</p>


<h5>Usage</h5>

<div class="r"><pre>TestStatistic$get_value()</pre></div>



<h5>Returns</h5>

<p>value of the test statistic
</p>


<hr>
<a id="method-TestStatistic-calc_stat"></a>



<h4>Method <code>calc_stat()</code></h4>

<p>Calculate the value of the test statistic for given data
and a model to test for.
</p>


<h5>Usage</h5>

<div class="r"><pre>TestStatistic$calc_stat(data, model)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p><code>list()</code> containing the data</p>
</dd>
<dt><code>model</code></dt><dd><p><a href="#topic+ParamRegrModel">ParamRegrModel</a> to test for</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>The modified object (<code>self</code>), allowing for method chaining.
</p>


<hr>
<a id="method-TestStatistic-get_plot_xy"></a>



<h4>Method <code>get_plot_xy()</code></h4>

<p>Returns vectors of x and y that can be used to plot the
process corresponding to the test statistic.
</p>


<h5>Usage</h5>

<div class="r"><pre>TestStatistic$get_plot_xy()</pre></div>



<h5>Returns</h5>

<p>list with plot.x and plot.y being vectors of the same length
</p>


<hr>
<a id="method-TestStatistic-print"></a>



<h4>Method <code>print()</code></h4>

<p>Overrides the print-method for objects of type
<code>TestStatistic</code> to only print its value.
</p>


<h5>Usage</h5>

<div class="r"><pre>TestStatistic$print()</pre></div>



<h5>Returns</h5>

<p>The object (<code>self</code>), allowing for method chaining.
</p>


<hr>
<a id="method-TestStatistic-geom_ts_proc"></a>



<h4>Method <code>geom_ts_proc()</code></h4>

<p>Creates a line plot showing the underlying process of the
test statistic.
</p>


<h5>Usage</h5>

<div class="r"><pre>TestStatistic$geom_ts_proc(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Other arguments passed on to <code><a href="ggplot2.html#topic+geom_path">ggplot2::geom_line()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A ggplot2 layer representing a line plot.
</p>


<hr>
<a id="method-TestStatistic-plot"></a>



<h4>Method <code>plot()</code></h4>

<p>Creates a new ggplot showing the underlying process of the
test statistic.
</p>


<h5>Usage</h5>

<div class="r"><pre>TestStatistic$plot(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Other arguments passed on to <code><a href="ggplot2.html#topic+geom_path">ggplot2::geom_line()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A ggplot2 object representing the complete plot, including a line
geometry.
</p>


<hr>
<a id="method-TestStatistic-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>TestStatistic$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='WeibullGLM'>Generalized linear model with Weibull distribution</h2><span id='topic+WeibullGLM'></span>

<h3>Description</h3>

<p>This class represents a generalized linear model with Weibull
distribution. It inherits from <a href="#topic+GLM">GLM</a> and implements its functions that,
for example, evaluate the conditional density and distribution functions.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+ParamRegrModel">gofreg::ParamRegrModel</a></code> -&gt; <code><a href="#topic+GLM">gofreg::GLM</a></code> -&gt; <code>WeibullGLM</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-WeibullGLM-fit"><code>WeibullGLM$fit()</code></a>
</p>
</li>
<li> <p><a href="#method-WeibullGLM-f_yx"><code>WeibullGLM$f_yx()</code></a>
</p>
</li>
<li> <p><a href="#method-WeibullGLM-F_yx"><code>WeibullGLM$F_yx()</code></a>
</p>
</li>
<li> <p><a href="#method-WeibullGLM-F1_yx"><code>WeibullGLM$F1_yx()</code></a>
</p>
</li>
<li> <p><a href="#method-WeibullGLM-sample_yx"><code>WeibullGLM$sample_yx()</code></a>
</p>
</li>
<li> <p><a href="#method-WeibullGLM-clone"><code>WeibullGLM$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="ParamRegrModel" data-id="get_params"><a href='../../gofreg/html/ParamRegrModel.html#method-ParamRegrModel-get_params'><code>gofreg::ParamRegrModel$get_params()</code></a></span></li>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="ParamRegrModel" data-id="set_params"><a href='../../gofreg/html/ParamRegrModel.html#method-ParamRegrModel-set_params'><code>gofreg::ParamRegrModel$set_params()</code></a></span></li>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="GLM" data-id="initialize"><a href='../../gofreg/html/GLM.html#method-GLM-initialize'><code>gofreg::GLM$initialize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="gofreg" data-topic="GLM" data-id="mean_yx"><a href='../../gofreg/html/GLM.html#method-GLM-mean_yx'><code>gofreg::GLM$mean_yx()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-WeibullGLM-fit"></a>



<h4>Method <code>fit()</code></h4>

<p>Calculates the maximum likelihood estimator for the model
parameters based on given data.
</p>


<h5>Usage</h5>

<div class="r"><pre>WeibullGLM$fit(
  data,
  params_init = private$params,
  loglik = loglik_xy,
  inplace = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>tibble containing the data to fit the model to</p>
</dd>
<dt><code>params_init</code></dt><dd><p>initial value of the model parameters to use for the
optimization (defaults to the fitted parameter values)</p>
</dd>
<dt><code>loglik</code></dt><dd><p><code style="white-space: pre;">&#8288;function(data, model, params)&#8288;</code> defaults to <code><a href="#topic+loglik_xy">loglik_xy()</a></code></p>
</dd>
<dt><code>inplace</code></dt><dd><p><code>logical</code>; if <code>TRUE</code>, default model parameters are set
accordingly and parameter estimator is not returned</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>MLE of the model parameters for the given data, same shape as
<code>params_init</code>
</p>


<hr>
<a id="method-WeibullGLM-f_yx"></a>



<h4>Method <code>f_yx()</code></h4>

<p>Evaluates the conditional density function.
</p>


<h5>Usage</h5>

<div class="r"><pre>WeibullGLM$f_yx(t, x, params = private$params)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>t</code></dt><dd><p>value(s) at which the conditional density shall be evaluated</p>
</dd>
<dt><code>x</code></dt><dd><p>matrix of covariates, each row representing one sample</p>
</dd>
<dt><code>params</code></dt><dd><p>model parameters to use (<code>list()</code> with tags beta and shape),
defaults to the fitted parameter values</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>value(s) of the conditional density function, same shape as <code>t</code>
</p>


<hr>
<a id="method-WeibullGLM-F_yx"></a>



<h4>Method <code>F_yx()</code></h4>

<p>Evaluates the conditional distribution function.
</p>


<h5>Usage</h5>

<div class="r"><pre>WeibullGLM$F_yx(t, x, params = private$params)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>t</code></dt><dd><p>value(s) at which the conditional distribution shall be
evaluated</p>
</dd>
<dt><code>x</code></dt><dd><p>matrix of covariates, each row representing one sample</p>
</dd>
<dt><code>params</code></dt><dd><p>model parameters to use (<code>list()</code> with tags beta and shape),
defaults to the fitted parameter values</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>value(s) of the conditional distribution function,  same shape as
<code>t</code>
</p>


<hr>
<a id="method-WeibullGLM-F1_yx"></a>



<h4>Method <code>F1_yx()</code></h4>

<p>Evaluates the conditional quantile function.
</p>


<h5>Usage</h5>

<div class="r"><pre>WeibullGLM$F1_yx(t, x, params = private$params)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>t</code></dt><dd><p>value(s) at which the conditional quantile function shall be
evaluated</p>
</dd>
<dt><code>x</code></dt><dd><p>matrix of covariates, each row representing one sample</p>
</dd>
<dt><code>params</code></dt><dd><p>model parameters to use (<code>list()</code> with tags beta and shape),
defaults to the fitted parameter values</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>value(s) of the conditional quantile function, same shape as
<code>t</code>
</p>


<hr>
<a id="method-WeibullGLM-sample_yx"></a>



<h4>Method <code>sample_yx()</code></h4>

<p>Generates a new sample of response variables with the same
conditional distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>WeibullGLM$sample_yx(x, params = private$params)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>matrix of covariates, each row representing one sample</p>
</dd>
<dt><code>params</code></dt><dd><p>model parameters to use (<code>list()</code> with tags beta and shape),
defaults to the fitted parameter values</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>vector of sampled response variables, same length as <code>nrow(x)</code>
</p>


<hr>
<a id="method-WeibullGLM-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>WeibullGLM$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'># Use the built-in cars dataset
x &lt;- datasets::cars$speed
y &lt;- datasets::cars$dist
data &lt;- dplyr::tibble(x=x, y=y)

# Create an instance of WeibullGLM
model &lt;- WeibullGLM$new()

# Fit an Weibull GLM to the cars dataset
model$fit(data, params_init = list(beta=3, shape=1), inplace=TRUE)
params_opt &lt;- model$get_params()

# Plot the resulting regression function
plot(datasets::cars)
abline(a = 0, b = params_opt$beta)

# Generate a sample for y for given x following the same distribution
x.new &lt;- seq(min(x), max(x), by=2)
y.smpl &lt;- model$sample_yx(x.new)
points(x.new, y.smpl, col="red")

# Evaluate the conditional density, distribution, quantile and regression
# function at given values
model$f_yx(y.smpl, x.new)
model$F_yx(y.smpl, x.new)
model$F1_yx(y.smpl, x.new)
y.pred &lt;- model$mean_yx(x.new)
points(x.new, y.pred, col="blue")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
