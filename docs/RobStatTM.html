<!DOCTYPE html><html><head><title>Help for package RobStatTM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RobStatTM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#alcohol'><p>Alcohol data</p></a></li>
<li><a href='#algae'><p>Algae data</p></a></li>
<li><a href='#biochem'><p>Biochem data</p></a></li>
<li><a href='#bisquare'><p>Tuning parameter the rho loss functions</p></a></li>
<li><a href='#breslow.dat'><p>Breslow Data</p></a></li>
<li><a href='#bus'><p>Bus data</p></a></li>
<li><a href='#cov.dcml'><p>Approximate covariance matrix of the DCML regression estimator.</p></a></li>
<li><a href='#covClassic'><p>Classical Covariance Estimation</p></a></li>
<li><a href='#covRob'><p>Robust multivariate location and scatter estimators</p></a></li>
<li><a href='#covRobMM'><p>MM robust multivariate location and scatter estimator</p></a></li>
<li><a href='#covRobRocke'><p>Rocke's robust multivariate location and scatter estimator</p></a></li>
<li><a href='#DCML'><p>DCML regression estimator</p></a></li>
<li><a href='#drop1.lmrobdetMM'><p>RFPE of submodels of an <code>lmrobdetMM</code> fit</p></a></li>
<li><a href='#fastmve'><p>Minimum Volume Ellipsoid covariance estimator</p></a></li>
<li><a href='#flour'><p>Flour data</p></a></li>
<li><a href='#glass'><p>Glass data</p></a></li>
<li><a href='#hearing'><p>Hearing data</p></a></li>
<li><a href='#huber'><p>Tuning parameter the rho loss functions</p></a></li>
<li><a href='#image'><p>Image data</p></a></li>
<li><a href='#initPP'><p>Robust multivariate location and scatter estimators</p></a></li>
<li><a href='#INVTR2'><p>Robust R^2 coefficient of determination</p></a></li>
<li><a href='#leuk.dat'><p>Leukemia Data</p></a></li>
<li><a href='#lmrobdet.control'><p>Tuning parameters for lmrobdetMM and lmrobdetDCML</p></a></li>
<li><a href='#lmrobdetDCML'><p>Robust Distance Constrained Maximum Likelihood estimators for linear regression</p></a></li>
<li><a href='#lmrobdetLinTest'><p>Robust likelihood ratio test for linear hypotheses</p></a></li>
<li><a href='#lmrobdetMM'><p>Robust Linear Regression Estimators</p></a></li>
<li><a href='#lmrobdetMM.RFPE'><p>Robust Final Prediction Error</p></a></li>
<li><a href='#lmrobM'><p>Robust estimators for linear regression with fixed designs</p></a></li>
<li><a href='#lmrobM.control'><p>Tuning parameters for lmrobM</p></a></li>
<li><a href='#locScaleM'><p>Robust univariate location and scale M-estimators</p></a></li>
<li><a href='#logregBY'><p>Bianco and Yohai estimator for logistic regression</p></a></li>
<li><a href='#logregWBY'><p>Bianco and Yohai estimator for logistic regression</p></a></li>
<li><a href='#logregWML'><p>Weighted likelihood estimator for the logistic model</p></a></li>
<li><a href='#mineral'><p>Mineral data</p></a></li>
<li><a href='#MMPY'><p>MM regression estimator using Pen~a-Yohai candidates</p></a></li>
<li><a href='#mopt'><p>Tuning parameter for a rho function in the modified (asymptotic bias-) optimal family</p></a></li>
<li><a href='#moptv0'><p>Tuning parameter for a rho function in the modified (asymptotic bias-) optimal family</p></a></li>
<li><a href='#neuralgia'><p>Neuralgia data</p></a></li>
<li><a href='#oats'><p>Oats data</p></a></li>
<li><a href='#opt'><p>Tuning parameter for a rho function in the (asymptotic bias-) optimal family</p></a></li>
<li><a href='#optv0'><p>Tuning parameter for a rho function in the (asymptotic bias-) optimal family</p></a></li>
<li><a href='#pcaRobS'><p>Robust principal components</p></a></li>
<li><a href='#prcompRob'><p>Robust Principal Components Cont'd</p></a></li>
<li><a href='#refine.sm'><p>IRWLS iterations for S- or M-estimators</p></a></li>
<li><a href='#resex'><p>Resex data</p></a></li>
<li><a href='#rho'><p>Rho functions</p></a></li>
<li><a href='#rhoprime'><p>The first derivative of the rho function</p></a></li>
<li><a href='#rhoprime2'><p>The second derivative of the rho function</p></a></li>
<li><a href='#scaleM'><p>M-scale estimator</p></a></li>
<li><a href='#shock'><p>Shock data</p></a></li>
<li><a href='#skin'><p>Skin data</p></a></li>
<li><a href='#SMPY'><p>SM regression estimator using Pen~a-Yohai candidates</p></a></li>
<li><a href='#stackloss'><p>Stackloss data</p></a></li>
<li><a href='#step.lmrobdetMM'><p>Robust stepwise using RFPE</p></a></li>
<li><a href='#vehicle'><p>Vehicle data</p></a></li>
<li><a href='#waste'><p>Waste data</p></a></li>
<li><a href='#wine'><p>Wine data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.0.8</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-27</td>
</tr>
<tr>
<td>Title:</td>
<td>Robust Statistics: Theory and Methods</td>
</tr>
<tr>
<td>Description:</td>
<td>Companion package for the book: "Robust Statistics: Theory and Methods, second edition", <a href="http://www.wiley.com/go/maronna/robust">http://www.wiley.com/go/maronna/robust</a>.  This package contains code that implements the robust estimators discussed in the recent second edition of the book above, as well as the scripts reproducing all the examples in the book.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, pyinit, rrcov, robustbase</td>
</tr>
<tr>
<td>Suggests:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-27 22:48:25 UTC; matias</td>
</tr>
<tr>
<td>Author:</td>
<td>Matias Salibian-Barrera [cre],
  Victor Yohai [aut],
  Ricardo Maronna [aut],
  Doug Martin [aut],
  Gregory Brownson [aut] (ShinyUI),
  Kjell Konis [aut],
  Kjell Konis [cph] (erfi),
  Christophe Croux [ctb] (WBYlogreg, BYlogreg),
  Gentiane Haesbroeck [ctb] (WBYlogreg, BYlogreg),
  Martin Maechler [cph] (lmrob.fit, lmrob..M..fit, lmrob.S),
  Manuel Koller [cph] (lmrob.fit, .vcov.avar1, lmrob.S, lmrob.lar),
  Matias Salibian-Barrera [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matias Salibian-Barrera &lt;matias@stat.ubc.ca&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-27 23:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='alcohol'>Alcohol data</h2><span id='topic+alcohol'></span>

<h3>Description</h3>

<p>This data set  contains physicochemical characteristics of 44 aliphatic alcohols.
The aim of the experiment was the prediction of the solubility on the basis of
molecular descriptors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(alcohol)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"data.frame"</code>.
</p>


<h3>Details</h3>

<p>Format: 44 cases and 7 continuous variables.
The columns are:
1. SAG=solvent accessible surface-bounded molecular volume
2. V=volume
3. log PC (PC=octanol–water partitions coefficient)
4. P=polarizability
5. RM=molar refractivity
6. Mass
7. log(Solubility) (response)
</p>


<h3>Source</h3>

<p>Romanelli, G.P., Martino, C.M. and Castro, E.A. (2001), Modeling the
solubility of aliphatic alcohols via molecular descriptors, Journal of the Chemical
Society of Pakistan, 23, 195-199.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(alcohol)
</code></pre>

<hr>
<h2 id='algae'>Algae data</h2><span id='topic+algae'></span>

<h3>Description</h3>

<p>Each row of the data set is a set of 90 measurements at a river in some place in Europe.
There are 11 predictors. The response is the logarithm of the abundance of a certain
class of algae. Description: The columns are:
1. season, categorical  (1,2,3,4 for winter, spring, summer and autumn)
2. river size (categorical) (1,2,3 for small, medium and large)
3. fluid velocity (categorical) (1,2,3 for low, medium and high)
4-11 (numerci): content of nitrogen in the form of nitrates, nitrites and ammonia, and other
chemical compounds.
Col. 12 ia the response:  abundance of a type of algae (type 6 in the complete file). For
simplicity we deleted the rows with missing values and took the logarithm of the response.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(algae)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"data.frame"</code>.
</p>


<h3>Details</h3>

<p>Format 90 rows, 12 columns (3 categorical, 9 numeric)
</p>


<h3>Source</h3>

<p>Hettich, S. and Bay, S.D. (1999), The UCI KDD Archive http://kdd.ics.uci.edu.
Irvine, CA: University of California, Department of Information and Computer Science.
</p>


<h3>References</h3>

<p>References go here.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(algae)
</code></pre>

<hr>
<h2 id='biochem'>Biochem data</h2><span id='topic+biochem'></span>

<h3>Description</h3>

<p>Two biochemical measurements on 12 men with similar weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(biochem)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"data.frame"</code>.
</p>


<h3>Details</h3>

<p>Format: Numeric, 12 rows, two columns
</p>


<h3>Source</h3>

<p>Seber, G.A.F. (1984), Multivariate Observations. New York: John Wiley.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(biochem)
</code></pre>

<hr>
<h2 id='bisquare'>Tuning parameter the rho loss functions</h2><span id='topic+bisquare'></span>

<h3>Description</h3>

<p>This function computes the tuning constant that yields an MM-regression
estimator with a desired asymptotic efficiency when computed with a
rho function in the corresponding family. The output of this
function can be passed to the functions <a href="#topic+lmrobdet.control">lmrobdet.control</a>,
<a href="#topic+mscale">mscale</a> and <a href="#topic+rho">rho</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bisquare(e)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bisquare_+3A_e">e</code></td>
<td>
<p>the desired efficiency of the corresponding regression
estimator for Gaussian errors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A length-1 vector with the corresponding tuning constant.
</p>


<h3>Author(s)</h3>

<p>Kjell Konis
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Tuning parameters for an 85%-efficient M-estimator at a Gaussian model
bisquare(.85)

</code></pre>

<hr>
<h2 id='breslow.dat'>Breslow Data</h2><span id='topic+breslow.dat'></span>

<h3>Description</h3>

<p>Patients suffering from simple or complex partial seizures 
were randomized to receive either the antiepileptic drug 
progabide or a placebo. At each of four successive post
randomization clinic visits, the number of seizures occuring 
over the previous two weeks was reported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(breslow.dat)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"data.frame"</code>.
</p>


<h3>Details</h3>

<p>Description: A data frame with 59 observations on the 
following 12 variables: <code>ID</code>: an integer value 
specifying the patient identification number; <code>Y1</code>:
an integer value, the number of seizures during the first 
two week period; <code>Y2</code>: an integer value, the number of 
seizures during the second two week period; <code>Y3</code>: an integer 
value, the number of seizures during the third two week period.
<code>Y4</code>: an integer value, the number of seizures during the 
fourth two week period; <code>Base</code>: an integer value giving 
the eight-week baseline seizure count; <code>Age</code>: an integer 
value giving the age of the parient in years; <code>Trt</code>:
the treatment: a factor with levels placebo and progabide; 
<code>Ysum</code>: an integer value, the sum of Y1, Y2, Y3 and Y4;
<code>sumY</code>: an integer value, the sum of Y1, Y2, Y3 and Y4;
<code>Age10</code>: a numeric value, Age divided by 10; <code>Base4</code>:
a numeric value, Base divided by 4. 
</p>
<p>Format: Numeric, 59 rows and 12 columns.
</p>


<h3>Source</h3>

<p>Breslow, N. E., and Clayton, D. G. (1993), &quot;Approximate 
Inference in Generalized Linear Mixed Models,&quot; Journal of the 
American Statistical Association, Vol. 88, No. 421, pp. 9-25.
</p>
<p>Thrall, P. F., and Vail, S. C. (1990), &quot;Some Covariance Models 
for Longitudinal Count Data With Overdispersion,&quot; Biometrics, 
Vol. 46, pp. 657-671.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(breslow.dat)
</code></pre>

<hr>
<h2 id='bus'>Bus data</h2><span id='topic+bus'></span>

<h3>Description</h3>

<p>This data set corresponds to a study in automatic vehicle recognition.
Each of the 218 rows corresponds to a view of a bus silhouette, and contains
18 attributes of the image. It was decided to exclude variable 9 and divide the
remaining variables by their MADN’s.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bus)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"data.frame"</code>.
</p>


<h3>Details</h3>

<p>Description: The following features were extracted from the silhouettes.
1. compactness
2. circularity
3. distance circularity
4. radius ratio
5. principal axis aspect ratio
6. maximum length aspect ratio
7. scatter ratio
8. elongatedness
9. principal axis rectangularity
10. maximum length rectangularity
11. scaled variance along major axis
12. scaled variance along minor axis
13. scaled radius of gyration
14. skewness about major axis
15. skewness about minor axis
16. kurtosis about minor axis
17. kurtosis about major axis
18. hollows ratio
</p>
<p>Format: Numeric, 218 rows and 18 columns.
</p>


<h3>Source</h3>

<p>Hettich, S. and Bay, S.D. (1999), The UCI KDD Archive http://kdd.ics.uci.edu.
Irvine, CA: University of California, Department of Information and Computer Science.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bus)
</code></pre>

<hr>
<h2 id='cov.dcml'>Approximate covariance matrix of the DCML regression estimator.</h2><span id='topic+cov.dcml'></span>

<h3>Description</h3>

<p>The estimated covariance matrix of the DCML regression estimator.
This function is used internally and not meant to be used
directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov.dcml(res.LS, res.R, CC, sig.R, t0, p, n, control)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cov.dcml_+3A_res.ls">res.LS</code></td>
<td>
<p>vector of residuals from the least squares fit</p>
</td></tr>
<tr><td><code id="cov.dcml_+3A_res.r">res.R</code></td>
<td>
<p>vector of residuals from the robust regression fit</p>
</td></tr>
<tr><td><code id="cov.dcml_+3A_cc">CC</code></td>
<td>
<p>estimated covariance matrix of the robust regression estimator</p>
</td></tr>
<tr><td><code id="cov.dcml_+3A_sig.r">sig.R</code></td>
<td>
<p>robust estimate of the scale of the residuals</p>
</td></tr>
<tr><td><code id="cov.dcml_+3A_t0">t0</code></td>
<td>
<p>mixing parameter</p>
</td></tr>
<tr><td><code id="cov.dcml_+3A_p">p</code>, <code id="cov.dcml_+3A_n">n</code></td>
<td>
<p>the dimensions of the problem, needed for the finite
sample correction of the tuning constant of the M-scale</p>
</td></tr>
<tr><td><code id="cov.dcml_+3A_control">control</code></td>
<td>
<p>a list of control parameters as returned by <code><a href="#topic+lmrobdet.control">lmrobdet.control</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The covariance matrix estimate.
</p>


<h3>Author(s)</h3>

<p>Victor Yohai, <a href="mailto:victoryohai@gmail.com">victoryohai@gmail.com</a>
</p>

<hr>
<h2 id='covClassic'>Classical Covariance Estimation</h2><span id='topic+covClassic'></span>

<h3>Description</h3>

<p>Compute an estimate of the covariance/correlation matrix and location
vector using classical methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covClassic(
  data,
  corr = FALSE,
  center = TRUE,
  distance = TRUE,
  na.action = na.fail,
  unbiased = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covClassic_+3A_data">data</code></td>
<td>
<p>a numeric matrix or data frame containing the data.</p>
</td></tr>
<tr><td><code id="covClassic_+3A_corr">corr</code></td>
<td>
<p>a logical flag.  If <code>corr = TRUE</code> then the estimated correlation matrix is computed.</p>
</td></tr>
<tr><td><code id="covClassic_+3A_center">center</code></td>
<td>
<p>a logical flag or a numeric vector of length <code>p</code> (where <code>p</code> is the number of columns of <code>x</code>) specifying the center.  If <code>center = TRUE</code> then the center is estimated.  Otherwise the center is taken to be 0.</p>
</td></tr>
<tr><td><code id="covClassic_+3A_distance">distance</code></td>
<td>
<p>a logical flag.  If <code>distance = TRUE</code> the Mahalanobis distances are computed.</p>
</td></tr>
<tr><td><code id="covClassic_+3A_na.action">na.action</code></td>
<td>
<p>a function to filter missing data.  The default <code>na.fail</code> produces an error if missing values are present.  An alternative is <code>na.omit</code> which deletes observations that contain one or more missing values.</p>
</td></tr>
<tr><td><code id="covClassic_+3A_unbiased">unbiased</code></td>
<td>
<p>a logical flag. If <code>TRUE</code> the unbiased estimator is returned (computed with denominator equal to <code>n-1</code>), else the MLE (computed with denominator equal to <code>n</code>) is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Its main intention is to return an object compatible to that
produced by <code><a href="#topic+covRob">covRob</a></code>, but fit using classical methods.
</p>


<h3>Value</h3>

<p>a list with class &ldquo;covClassic&rdquo; containing the following elements:
</p>
<table>
<tr><td><code>center</code></td>
<td>
<p>a numeric vector containing the estimate of the location vector.</p>
</td></tr>
<tr><td><code>cov</code></td>
<td>
<p>a numeric matrix containing the estimate of the covariance matrix.</p>
</td></tr>
<tr><td><code>cor</code></td>
<td>
<p>a numeric matrix containing the estimate of the correlation matrix if the argument <code>corr = TRUE</code>. Otherwise it is set to <code>NULL</code>.</p>
</td></tr>
<tr><td><code>dist</code></td>
<td>
<p>a numeric vector containing the squared Mahalanobis distances. Only present if <code>distance = TRUE</code> in the <code>call</code>.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>an image of the call that produced the object with all the arguments named. The matched call.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Originally, and in S-PLUS, this function was called <code>cov</code>; it has
been renamed, as that did mask the function in the standard package <span class="pkg">stats</span>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(wine)
round( covClassic(wine)$cov, 2)

</code></pre>

<hr>
<h2 id='covRob'>Robust multivariate location and scatter estimators</h2><span id='topic+covRob'></span><span id='topic+Multirobu'></span>

<h3>Description</h3>

<p>This function computes robust estimators for multivariate location and scatter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covRob(X, type = "auto", maxit = 50, tol = 1e-04, corr = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covRob_+3A_x">X</code></td>
<td>
<p>a data matrix with observations in rows.</p>
</td></tr>
<tr><td><code id="covRob_+3A_type">type</code></td>
<td>
<p>a string indicating which estimator to compute. Valid options
are &quot;Rocke&quot; for Rocke's S-estimator, &quot;MM&quot; for an MM-estimator with a
SHR rho function, or &quot;auto&quot; (default) which selects &quot;Rocke&quot; if the number
of variables is greater than or equal to 10, and &quot;MM&quot; otherwise.</p>
</td></tr>
<tr><td><code id="covRob_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations, defaults to 50.</p>
</td></tr>
<tr><td><code id="covRob_+3A_tol">tol</code></td>
<td>
<p>Tolerance for convergence, defaults to 1e-4.</p>
</td></tr>
<tr><td><code id="covRob_+3A_corr">corr</code></td>
<td>
<p>A logical value. If <code>TRUE</code> a correlation matrix is included in the element <code>cor</code> of the returned object. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes robust estimators for multivariate location and scatter.
The default behaviour (<code>type = "auto"</code>) computes a &quot;Rocke&quot; estimator
(as implemented in <code><a href="#topic+covRobRocke">covRobRocke</a></code>) if the number
of variables is greater than or equal to 10, and an MM-estimator with a
SHR rho function (as implemented in <code><a href="#topic+covRobMM">covRobMM</a></code>) otherwise.
</p>


<h3>Value</h3>

<p>A list with class &ldquo;covClassic&rdquo; with the following components:
</p>
<table>
<tr><td><code>center</code></td>
<td>
<p>The location estimate.</p>
</td></tr>
<tr><td><code>cov</code></td>
<td>
<p>The scatter matrix estimate, scaled for consistency at the normal distribution.</p>
</td></tr>
<tr><td><code>cor</code></td>
<td>
<p>The correlation matrix estimate, if the argument <code>cor</code> equals <code>TRUE</code>. Otherwise it is set to <code>NULL</code>.</p>
</td></tr>
<tr><td><code>dist</code></td>
<td>
<p>Robust Mahalanobis distances</p>
</td></tr>
<tr><td><code>wts</code></td>
<td>
<p>weights</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>an image of the call that produced the object with all the arguments named. The matched call.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>The location estimate. Same as <code>center</code> above.</p>
</td></tr>
<tr><td><code>V</code></td>
<td>
<p>The scatter matrix estimate, scaled for consistency at the normal distribution. Same as <code>cov</code> above.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ricardo Maronna, <a href="mailto:rmaronna@retina.ar">rmaronna@retina.ar</a>
</p>


<h3>References</h3>

<p><a href="http://www.wiley.com/go/maronna/robust">http://www.wiley.com/go/maronna/robust</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+covRobRocke">covRobRocke</a></code>, <code><a href="#topic+covRobMM">covRobMM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bus)
X0 &lt;- as.matrix(bus)
X1 &lt;- X0[,-9]
tmp &lt;- covRob(X1)
round(tmp$cov[1:10, 1:10], 3)
tmp$mu

</code></pre>

<hr>
<h2 id='covRobMM'>MM robust multivariate location and scatter estimator</h2><span id='topic+covRobMM'></span><span id='topic+MMultiSHR'></span>

<h3>Description</h3>

<p>This function computes an MM robust estimator for multivariate location and scatter with the &quot;SHR&quot; loss function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covRobMM(X, maxit = 50, tolpar = 1e-04, corr = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covRobMM_+3A_x">X</code></td>
<td>
<p>a data matrix with observations in rows.</p>
</td></tr>
<tr><td><code id="covRobMM_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations.</p>
</td></tr>
<tr><td><code id="covRobMM_+3A_tolpar">tolpar</code></td>
<td>
<p>Tolerance to decide converngence.</p>
</td></tr>
<tr><td><code id="covRobMM_+3A_corr">corr</code></td>
<td>
<p>A logical value. If <code>TRUE</code> a correlation matrix is included in the element <code>cor</code> of the returned object. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes an MM robust estimator for multivariate location and scatter with the &quot;SHR&quot; loss function.
</p>


<h3>Value</h3>

<p>A list with class &ldquo;covRob&rdquo; containing the following elements
</p>
<table>
<tr><td><code>center</code></td>
<td>
<p>The location estimate.</p>
</td></tr>
<tr><td><code>cov</code></td>
<td>
<p>The scatter matrix estimate, scaled for consistency at the normal distribution. Same as <code>V</code> above.</p>
</td></tr>
<tr><td><code>cor</code></td>
<td>
<p>The correlation matrix estimate, if the argument <code>cor</code> equals <code>TRUE</code>. Otherwise it is set to <code>NULL</code>.</p>
</td></tr>
<tr><td><code>dist</code></td>
<td>
<p>Robust Mahalanobis distances</p>
</td></tr>
<tr><td><code>wts</code></td>
<td>
<p>weights</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>an image of the call that produced the object with all the arguments named. The matched call.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>The location estimate. Same as <code>center</code> above.</p>
</td></tr>
<tr><td><code>V</code></td>
<td>
<p>The scatter or correlation matrix estimate, scaled for consistency at the normal distribution</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ricardo Maronna, <a href="mailto:rmaronna@retina.ar">rmaronna@retina.ar</a>
</p>


<h3>References</h3>

<p><a href="http://www.wiley.com/go/maronna/robust">http://www.wiley.com/go/maronna/robust</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bus)
X0 &lt;- as.matrix(bus)
X1 &lt;- X0[,-9]
tmp &lt;- covRobMM(X1)
round(tmp$cov[1:10, 1:10], 3)
tmp$mu

</code></pre>

<hr>
<h2 id='covRobRocke'>Rocke's robust multivariate location and scatter estimator</h2><span id='topic+covRobRocke'></span><span id='topic+RockeMulti'></span>

<h3>Description</h3>

<p>This function computes Rocke's robust estimator for multivariate location and scatter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covRobRocke(
  X,
  initial = "K",
  maxsteps = 5,
  propmin = 2,
  qs = 2,
  maxit = 50,
  tol = 1e-04,
  corr = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covRobRocke_+3A_x">X</code></td>
<td>
<p>a data matrix with observations in rows.</p>
</td></tr>
<tr><td><code id="covRobRocke_+3A_initial">initial</code></td>
<td>
<p>A character indicating the initial estimator. Valid options are 'K' (default)
for the Pena-Prieto 'KSD' estimate, and 'mve' for the Minimum Volume Ellipsoid.</p>
</td></tr>
<tr><td><code id="covRobRocke_+3A_maxsteps">maxsteps</code></td>
<td>
<p>Maximum number of steps for the line search section of the algorithm.</p>
</td></tr>
<tr><td><code id="covRobRocke_+3A_propmin">propmin</code></td>
<td>
<p>Regulates the proportion of weights computed from the initial estimator that
will be different from zero. The number of observations with initial non-zero weights will
be at least p (the number of columns of X) times propmin.</p>
</td></tr>
<tr><td><code id="covRobRocke_+3A_qs">qs</code></td>
<td>
<p>Tuning paramater for Rocke's loss functions.</p>
</td></tr>
<tr><td><code id="covRobRocke_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations.</p>
</td></tr>
<tr><td><code id="covRobRocke_+3A_tol">tol</code></td>
<td>
<p>Tolerance to decide converngence.</p>
</td></tr>
<tr><td><code id="covRobRocke_+3A_corr">corr</code></td>
<td>
<p>A logical value. If <code>TRUE</code> a correlation matrix is included in the element <code>cor</code> of the returned object. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes Rocke's robust estimator for multivariate location and scatter.
</p>


<h3>Value</h3>

<p>A list with class &ldquo;covRob&rdquo; containing the following elements:
</p>
<table>
<tr><td><code>center</code></td>
<td>
<p>The location estimate.</p>
</td></tr>
<tr><td><code>cov</code></td>
<td>
<p>The scatter matrix estimate, scaled for consistency at the normal distribution.</p>
</td></tr>
<tr><td><code>cor</code></td>
<td>
<p>The correlation matrix estimate, if the argument <code>cor</code> equals <code>TRUE</code>. Otherwise it is set to <code>NULL</code>.</p>
</td></tr>
<tr><td><code>dist</code></td>
<td>
<p>Robust Mahalanobis distances.</p>
</td></tr>
<tr><td><code>wts</code></td>
<td>
<p>weights</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>an image of the call that produced the object with all the arguments named. The matched call.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>The location estimate. Same as <code>center</code> above.</p>
</td></tr>
<tr><td><code>V</code></td>
<td>
<p>The scatter (or correlation) matrix estimate, scaled for consistency at the normal distribution.  Same as <code>cov</code> above.</p>
</td></tr>
<tr><td><code>sig</code></td>
<td>
<p>sig</p>
</td></tr>
<tr><td><code>gamma</code></td>
<td>
<p>Final value of the constant gamma that regulates the efficiency.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ricardo Maronna, <a href="mailto:rmaronna@retina.ar">rmaronna@retina.ar</a>
</p>


<h3>References</h3>

<p><a href="http://www.wiley.com/go/maronna/robust">http://www.wiley.com/go/maronna/robust</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bus)
X0 &lt;- as.matrix(bus)
X1 &lt;- X0[,-9]
tmp &lt;- covRobRocke(X1)
round(tmp$cov[1:10, 1:10], 3)
tmp$mu

</code></pre>

<hr>
<h2 id='DCML'>DCML regression estimator</h2><span id='topic+DCML'></span>

<h3>Description</h3>

<p>This function computes the DCML regression estimator. This function is used
internally by <code><a href="#topic+lmrobdetDCML">lmrobdetDCML</a></code>, and not meant to be used
directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DCML(x, y, z, z0, control)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DCML_+3A_x">x</code></td>
<td>
<p>design matrix</p>
</td></tr>
<tr><td><code id="DCML_+3A_y">y</code></td>
<td>
<p>response vector</p>
</td></tr>
<tr><td><code id="DCML_+3A_z">z</code></td>
<td>
<p>robust fit as returned by <code><a href="#topic+MMPY">MMPY</a></code> or <code><a href="#topic+SMPY">SMPY</a></code></p>
</td></tr>
<tr><td><code id="DCML_+3A_z0">z0</code></td>
<td>
<p>least squares fit as returned by <code><a href="stats.html#topic+lm.fit">lm.fit</a></code></p>
</td></tr>
<tr><td><code id="DCML_+3A_control">control</code></td>
<td>
<p>a list of control parameters as returned by <code><a href="#topic+lmrobdet.control">lmrobdet.control</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the following components
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>the vector of regression coefficients</p>
</td></tr>
<tr><td><code>cov</code></td>
<td>
<p>the estimated covariance matrix of the DCML regression estimator</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>the vector of regression residuals from the DCML fit</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>a robust residual (M-)scale estimate</p>
</td></tr>
<tr><td><code>t0</code></td>
<td>
<p>the mixing proportion between the least squares and robust regression estimators</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Victor Yohai, <a href="mailto:victoryohai@gmail.com">victoryohai@gmail.com</a>, Matias Salibian-Barrera, <a href="mailto:matias@stat.ubc.ca">matias@stat.ubc.ca</a>
</p>


<h3>References</h3>

<p><a href="http://www.wiley.com/go/maronna/robust">http://www.wiley.com/go/maronna/robust</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DCML">DCML</a></code>, <code><a href="#topic+MMPY">MMPY</a></code>, <code><a href="#topic+SMPY">SMPY</a></code>
</p>

<hr>
<h2 id='drop1.lmrobdetMM'>RFPE of submodels of an <code><a href="#topic+lmrobdetMM">lmrobdetMM</a></code> fit</h2><span id='topic+drop1.lmrobdetMM'></span>

<h3>Description</h3>

<p>This function computes the RFPE for the MM-estimators obtained with <code><a href="#topic+lmrobdetMM">lmrobdetMM</a></code> by
recomputing it, successively removing each of a number of specified terms. 
It is used internally by <code><a href="#topic+step.lmrobdetMM">step.lmrobdetMM</a></code> and not meant to be used
directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmrobdetMM'
drop1(object, scope, scale, keep, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drop1.lmrobdetMM_+3A_object">object</code></td>
<td>
<p>the <code>MM</code> element (of class <code><a href="robustbase.html#topic+lmrob">lmrob</a></code>) in an object of class <code><a href="#topic+lmrobdetMM">lmrobdetMM</a></code>.</p>
</td></tr>
<tr><td><code id="drop1.lmrobdetMM_+3A_scope">scope</code></td>
<td>
<p>an optional <code>formula</code> giving the terms to be considered for dropping. Typically 
this argument is omitted, in which case all possible terms are dropped (without breaking hierarchy 
rules). The <code>scope</code> can also be a character vector of term labels. If the argument is supplied as a 
formula, any <code>.</code> is interpreted relative to the formula implied by the <code>object</code> argument.</p>
</td></tr>
<tr><td><code id="drop1.lmrobdetMM_+3A_scale">scale</code></td>
<td>
<p>an optional residual scale estimate. If missing the residual
scale estimate in <code>object</code> is used.</p>
</td></tr>
<tr><td><code id="drop1.lmrobdetMM_+3A_keep">keep</code></td>
<td>
<p>a character vector of names of components that should be saved for each subset model. 
Only names from the set <code>"coefficients"</code>, <code>"fitted"</code> and <code>"residuals"</code>
are allowed. If <code>keep == TRUE</code>, the complete set is saved. The default behavior is 
not to keep anything.</p>
</td></tr>
<tr><td><code id="drop1.lmrobdetMM_+3A_...">...</code></td>
<td>
<p>additional parameters to match generic method <code>drop1</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An anova object consisting of the term labels, the degrees of freedom, and Robust Final 
Prediction Errors (RFPE) for each subset model. If <code>keep</code> is missing, the anova object is 
returned. If <code>keep</code> is present, a list with components <code>"anova"</code> and <code>"keep"</code> is returned. 
In this case, the <code>"keep"</code> component is a matrix of mode <code>"list"</code>, with a column for each 
subset model, and a row for each component kept.
</p>


<h3>Author(s)</h3>

<p>Victor Yohai, <a href="mailto:victoryohai@gmail.com">victoryohai@gmail.com</a>,  Matias Salibian-Barrera, <a href="mailto:matias@stat.ubc.ca">matias@stat.ubc.ca</a>
</p>


<h3>References</h3>

<p><a href="http://www.wiley.com/go/maronna/robust">http://www.wiley.com/go/maronna/robust</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lmrobdetMM">lmrobdetMM</a></code>
</p>

<hr>
<h2 id='fastmve'>Minimum Volume Ellipsoid covariance estimator</h2><span id='topic+fastmve'></span>

<h3>Description</h3>

<p>This function uses a fast algorithm to compute the Minimum Volume
Ellipsoid (MVE) for multivariate location and scatter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastmve(x, nsamp = 500)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fastmve_+3A_x">x</code></td>
<td>
<p>data matrix (n x p) with cases stored in rows.</p>
</td></tr>
<tr><td><code id="fastmve_+3A_nsamp">nsamp</code></td>
<td>
<p>number of random starts for the iterative algorithm, these
are constructed using subsamples of the data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the Minimum Volume
Ellipsoid (MVE) for multivariate location and scatter, using a
fast algorithm related to the fast algorithm for S-regression
estimators (see <code><a href="robustbase.html#topic+lmrob">lmrob</a></code>).
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>center</code></td>
<td>
<p>a vector with the robust multivariate location estimate</p>
</td></tr>
<tr><td><code>cov</code></td>
<td>
<p>a matrix with the robust covariance / scatter matrix estimate</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>A scalar that equals the median of the mahalanobis distances of the
data to the <code>center</code>, multiplied by the determinant of the covariance matrix
to the power 1/p</p>
</td></tr>
<tr><td><code>best</code></td>
<td>
<p>Indices of the observations that correspond to the MVE estimator</p>
</td></tr>
<tr><td><code>nsamp</code></td>
<td>
<p>Number of random starts used for the iterative algorithm</p>
</td></tr>
<tr><td><code>nsing</code></td>
<td>
<p>Number of random subsamples (among the <code>nsamp</code> attempted)
that failed (resulting in singular initial values)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matias Salibian-Barrera, <a href="mailto:matias@stat.ubc.ca">matias@stat.ubc.ca</a>
</p>


<h3>References</h3>

<p><a href="http://www.wiley.com/go/maronna/robust">http://www.wiley.com/go/maronna/robust</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bus)
X0 &lt;- as.matrix(bus)
X1 &lt;- X0[,-9]
tmp &lt;- fastmve(X1)
round(tmp$cov[1:10, 1:10], 3)
tmp$center

</code></pre>

<hr>
<h2 id='flour'>Flour data</h2><span id='topic+flour'></span>

<h3>Description</h3>

<p>Determinations of the copper content in wholemeal flour
(in parts per million), sorted in ascending order.
Format: numeric vector of size 24.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(flour)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"data.frame"</code>.
</p>


<h3>Source</h3>

<p>Analytical Methods Committee (1989), Robust statistics-How not to reject
outliers, Analyst, 114, 1693-1702.
</p>


<h3>References</h3>

<p>References go here.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(flour)
</code></pre>

<hr>
<h2 id='glass'>Glass data</h2><span id='topic+glass'></span>

<h3>Description</h3>

<p>Measurements of the presence of seven chemical constituents in
76 pieces of glass from nonfloat car windows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(glass)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"data.frame"</code>.
</p>


<h3>Details</h3>

<p>Format: 76 cases and 7 continuous variables.
Description: The columns are:
1. RI refractive index
2. Na2O sodium oxide (unit measurement: weight percent in
corresponding oxide, as are the rest of attributes)
3. MgO magnesium oxide
4. Al2O3 aluminum oxide
5. SiO2 silcon oxide
6. K2O potassium oxide
7. CaO calcium oxide
</p>


<h3>Source</h3>

<p>Hettich, S. and Bay, S.D. (1999), The UCI KDD Archive
http://kdd.ics.uci.edu, Irvine, CA: University of California,
Department of Information and Computer Science.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(glass)
</code></pre>

<hr>
<h2 id='hearing'>Hearing data</h2><span id='topic+hearing'></span>

<h3>Description</h3>

<p>Prevalence rates in percent for men aged 55–64 with hearing levels
16 decibels or more above the audiometric zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(hearing)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"data.frame"</code>.
</p>


<h3>Details</h3>

<p>Format: Two-way ANOVA.
Description: The rows correspond to different frequencies and to normal speech.
1. 500 hertz
2. 1000 hertz
3. 2000 hertz
4. 3000 hertz
5. 4000 hertz
6. 6000 hertz
7. Normal speech
The columns classify the data in seven occupational groups:
1. professional–managerial
2. farm
3. clerical sales
4. craftsmen
5. operatives
6. service
7. laborers
</p>


<h3>Source</h3>

<p>Roberts, J. and Cohrssen, J. (1968), Hearing
levels of adults, US National Center for Health Statistics Publications,
Series 11, No. 31
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hearing)
</code></pre>

<hr>
<h2 id='huber'>Tuning parameter the rho loss functions</h2><span id='topic+huber'></span>

<h3>Description</h3>

<p>This function computes the tuning constant that yields an MM-regression
estimator with a desired asymptotic efficiency when computed with a
rho function in the corresponding family. The output of this
function can be passed to the functions <a href="#topic+lmrobdet.control">lmrobdet.control</a>,
<a href="#topic+mscale">mscale</a> and <a href="#topic+rho">rho</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>huber(e)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="huber_+3A_e">e</code></td>
<td>
<p>the desired efficiency of the corresponding regression
estimator for Gaussian errors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A length-1 vector with the corresponding tuning constant.
</p>


<h3>Author(s)</h3>

<p>Kjell Konis
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Tuning parameters for an 85%-efficient M-estimator at a Gaussian model
huber(.95)

</code></pre>

<hr>
<h2 id='image'>Image data</h2><span id='topic+image'></span>

<h3>Description</h3>

<p>These data are part of a synthetic aperture satellite radar image corresponding
to a suburb of Munich, and  contain the values corresponding to three frequency
bands for each of 1573 pixels of a radar image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(image)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"data.frame"</code>.
</p>


<h3>Details</h3>

<p>Format: 1573 cases and 3 variables.
</p>


<h3>Source</h3>

<p>Source: Frery, A. (2005), Personal communication.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(image)
</code></pre>

<hr>
<h2 id='initPP'>Robust multivariate location and scatter estimators</h2><span id='topic+initPP'></span><span id='topic+KurtSDNew'></span>

<h3>Description</h3>

<p>This function computes robust multivariate location and scatter
estimators using both random and deterministic starting points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initPP(X, muldirand = 20, muldifix = 10, dirmin = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initPP_+3A_x">X</code></td>
<td>
<p>a data matrix with observations in rows.</p>
</td></tr>
<tr><td><code id="initPP_+3A_muldirand">muldirand</code></td>
<td>
<p>used to determine the number of random directions (candidates), which
is <code>max(p*muldirand, dirmin)</code>, where <code>p</code> is the number of columns in <code>X</code>.</p>
</td></tr>
<tr><td><code id="initPP_+3A_muldifix">muldifix</code></td>
<td>
<p>used to determine the number of random directions (candidates), which
is <code>min(n, 2*muldifix*p)</code>.</p>
</td></tr>
<tr><td><code id="initPP_+3A_dirmin">dirmin</code></td>
<td>
<p>minimum number of random directions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes robust multivariate location and scatter
using both Pen~a-Prieto and random candidates.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>idx</code></td>
<td>
<p>A zero/one vector with ones in the positions of the suspected outliers</p>
</td></tr>
<tr><td><code>disma</code></td>
<td>
<p>Robust squared Mahalanobis distances</p>
</td></tr>
<tr><td><code>center</code></td>
<td>
<p>Robust mean estimate</p>
</td></tr>
<tr><td><code>cova</code></td>
<td>
<p>Robust covariance matrix estimate</p>
</td></tr>
<tr><td><code>t</code></td>
<td>
<p>Outlyingness of data points</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ricardo Maronna, <a href="mailto:rmaronna@retina.ar">rmaronna@retina.ar</a>, based on original code
by D. Pen~a and J. Prieto
</p>


<h3>References</h3>

<p><a href="http://www.wiley.com/go/maronna/robust">http://www.wiley.com/go/maronna/robust</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bus)
X0 &lt;- as.matrix(bus)
X1 &lt;- X0[,-9]
tmp &lt;- initPP(X1)
round(tmp$cov[1:10, 1:10], 3)
tmp$center

</code></pre>

<hr>
<h2 id='INVTR2'>Robust R^2 coefficient of determination</h2><span id='topic+INVTR2'></span>

<h3>Description</h3>

<p>This function computes a robust version of the R^2 coefficient of determination.
It is used internally by <code><a href="#topic+lmrobdetMM">lmrobdetMM</a></code>,
and not meant to be used directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>INVTR2(RR2, family, cc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="INVTR2_+3A_rr2">RR2</code></td>
<td>
<p>the proportional difference in loss functions (a naive robust R^2 coefficient).</p>
</td></tr>
<tr><td><code id="INVTR2_+3A_family">family</code></td>
<td>
<p>family string specifying the name of the family of loss function to be used (current valid
options are &quot;bisquare&quot;, &quot;opt&quot; and &quot;mopt&quot;).</p>
</td></tr>
<tr><td><code id="INVTR2_+3A_cc">cc</code></td>
<td>
<p>tuning parameters to be computed according to efficiency and / or breakdown
considerations. See <a href="#topic+lmrobdet.control">lmrobdet.control</a>, <a href="#topic+bisquare">bisquare</a>, <a href="#topic+mopt">mopt</a>
and <a href="#topic+opt">opt</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes a robust version of the R^2 coefficient.
It is used internally by <code><a href="#topic+lmrobdetMM">lmrobdetMM</a></code>,
and not meant to be used directly.
</p>


<h3>Value</h3>

<p>An unbiased version of the robust R^2 coefficient of determination.
</p>


<h3>Author(s)</h3>

<p>Victor Yohai, <a href="mailto:victoryohai@gmail.com">victoryohai@gmail.com</a>
</p>


<h3>References</h3>

<p><a href="http://www.wiley.com/go/maronna/robust">http://www.wiley.com/go/maronna/robust</a>
</p>

<hr>
<h2 id='leuk.dat'>Leukemia Data</h2><span id='topic+leuk.dat'></span>

<h3>Description</h3>

<p>Records for 33 leukemia patients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(leuk.dat)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"data.frame"</code>.
</p>


<h3>Details</h3>

<p>Description: The following features are present:
<code>wbc</code>: white blood cell count;
<code>ag</code>: presence or absence of a certain
morphological characteristic in the white cells; and
<code>y</code>: binary response
variable, equals <code>1</code> if the patient survives more than 52 weeks, <code>0</code> otherwise.
</p>
<p>Format: Numeric, 33 rows and 3 columns.
</p>


<h3>Source</h3>

<p>Cook, R.D. and Weisberg, S. (1982). Residuals and Influence in Regression, Chapman
and Hall; Johnson, W. (1985), Influence measures for logistic regression: another point of
view, Biometrika, 72, 59-65.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(leuk.dat)
</code></pre>

<hr>
<h2 id='lmrobdet.control'>Tuning parameters for lmrobdetMM and lmrobdetDCML</h2><span id='topic+lmrobdet.control'></span>

<h3>Description</h3>

<p>This function sets tuning parameters for the MM estimator implemented in <code>lmrobdetMM</code> and
the Distance Constrained Maximum Likelihood regression estimators
computed by <code>lmrobdetDCML</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmrobdet.control(
  bb = 0.5,
  efficiency = 0.95,
  family = "mopt",
  tuning.psi,
  tuning.chi,
  compute.rd = FALSE,
  corr.b = TRUE,
  split.type = "f",
  initial = "S",
  max.it = 100,
  refine.tol = 1e-07,
  rel.tol = 1e-07,
  refine.S.py = 1e-07,
  refine.PY = 10,
  solve.tol = 1e-07,
  trace.lev = 0,
  psc_keep = 0.5,
  resid_keep_method = "threshold",
  resid_keep_thresh = 2,
  resid_keep_prop = 0.2,
  py_maxit = 20,
  py_eps = 1e-05,
  mscale_maxit = 50,
  mscale_tol = 1e-06,
  mscale_rho_fun = "bisquare"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lmrobdet.control_+3A_bb">bb</code></td>
<td>
<p>tuning constant (between 0 and 1/2) for the M-scale used to compute the initial S-estimator. It
determines the robusness (breakdown point) of the resulting MM-estimator, which is
<code>bb</code>. Defaults to 0.5.</p>
</td></tr>
<tr><td><code id="lmrobdet.control_+3A_efficiency">efficiency</code></td>
<td>
<p>desired asymptotic efficiency of the final regression M-estimator. Defaults to 0.95.</p>
</td></tr>
<tr><td><code id="lmrobdet.control_+3A_family">family</code></td>
<td>
<p>string specifying the name of the family of loss function to be used (current valid
options are &quot;bisquare&quot;, &quot;opt&quot; and &quot;mopt&quot;). Incomplete entries will be matched to the current valid options. Defaults to &quot;mopt&quot;.</p>
</td></tr>
<tr><td><code id="lmrobdet.control_+3A_tuning.psi">tuning.psi</code></td>
<td>
<p>tuning parameters for the regression M-estimator computed with a rho function
as specified with argument <code>family</code>. If missing, it is computed inside <code>lmrobdet.control</code> to match
the value of <code>efficiency</code> according to the family of rho functions specified in <code>family</code>.
Appropriate values for <code>tuning.psi</code> for a given desired efficiency for Gaussian errors
can be constructed using the functions <a href="#topic+bisquare">bisquare</a>, <a href="#topic+mopt">mopt</a> and <a href="#topic+opt">opt</a>.</p>
</td></tr>
<tr><td><code id="lmrobdet.control_+3A_tuning.chi">tuning.chi</code></td>
<td>
<p>tuning constant for the function used to compute the M-scale
used for the initial S-estimator. If missing, it is computed inside <code>lmrobdet.control</code> to match
the value of <code>bb</code> according to the family of rho functions specified in <code>family</code>.</p>
</td></tr>
<tr><td><code id="lmrobdet.control_+3A_compute.rd">compute.rd</code></td>
<td>
<p>logical value indicating whether robust leverage distances need to be computed.</p>
</td></tr>
<tr><td><code id="lmrobdet.control_+3A_corr.b">corr.b</code></td>
<td>
<p>logical value indicating whether a finite-sample correction should be applied
to the M-scale parameter <code>bb</code>.</p>
</td></tr>
<tr><td><code id="lmrobdet.control_+3A_split.type">split.type</code></td>
<td>
<p>determines how categorical and continuous variables are split. See
<code><a href="robustbase.html#topic+splitFrame">splitFrame</a></code>.</p>
</td></tr>
<tr><td><code id="lmrobdet.control_+3A_initial">initial</code></td>
<td>
<p>string specifying the initial value for the M-step of the MM-estimator. Valid
options are <code>'S'</code>, for an S-estimator and <code>'MS'</code> for an M-S estimator which is
appropriate when there are categorical explanatory variables in the model.</p>
</td></tr>
<tr><td><code id="lmrobdet.control_+3A_max.it">max.it</code></td>
<td>
<p>maximum number of IRWLS iterations for the MM-estimator</p>
</td></tr>
<tr><td><code id="lmrobdet.control_+3A_refine.tol">refine.tol</code></td>
<td>
<p>relative convergence tolerance for the S-estimator</p>
</td></tr>
<tr><td><code id="lmrobdet.control_+3A_rel.tol">rel.tol</code></td>
<td>
<p>relative convergence tolerance for the IRWLS iterations for the MM-estimator</p>
</td></tr>
<tr><td><code id="lmrobdet.control_+3A_refine.s.py">refine.S.py</code></td>
<td>
<p>relative convergence tolerance for the local improvements of the Pena-Yohai candidates for the S-estimator</p>
</td></tr>
<tr><td><code id="lmrobdet.control_+3A_refine.py">refine.PY</code></td>
<td>
<p>number of refinement steps for the Pen~a-Yohai candidates</p>
</td></tr>
<tr><td><code id="lmrobdet.control_+3A_solve.tol">solve.tol</code></td>
<td>
<p>(for the S algorithm): relative tolerance for matrix inversion. Hence, this corresponds to <code><a href="base.html#topic+solve.default">solve.default</a></code>'s tol.</p>
</td></tr>
<tr><td><code id="lmrobdet.control_+3A_trace.lev">trace.lev</code></td>
<td>
<p>positive values (increasingly) provide details on the progress of the MM-algorithm</p>
</td></tr>
<tr><td><code id="lmrobdet.control_+3A_psc_keep">psc_keep</code></td>
<td>
<p>For <code>pyinit</code>, proportion of observations to remove based on PSCs. The effective proportion of removed
observations is adjusted according to the sample size to be <code>prosac*(1-p/n)</code>. See <code><a href="pyinit.html#topic+pyinit">pyinit</a></code>.</p>
</td></tr>
<tr><td><code id="lmrobdet.control_+3A_resid_keep_method">resid_keep_method</code></td>
<td>
<p>For <code>pyinit</code>, how to clean the data based on large residuals. If
<code>"threshold"</code>, all observations with scaled residuals larger than <code>C.res</code> will
be removed, if <code>"proportion"</code>, observations with the largest <code>prop</code> residuals will
be removed. See <code><a href="pyinit.html#topic+pyinit">pyinit</a></code>.</p>
</td></tr>
<tr><td><code id="lmrobdet.control_+3A_resid_keep_thresh">resid_keep_thresh</code></td>
<td>
<p>See parameter <code>resid_keep_method</code> above. See <code><a href="pyinit.html#topic+pyinit">pyinit</a></code>.</p>
</td></tr>
<tr><td><code id="lmrobdet.control_+3A_resid_keep_prop">resid_keep_prop</code></td>
<td>
<p>See parameter <code>resid_keep_method</code> above. See <code><a href="pyinit.html#topic+pyinit">pyinit</a></code>.</p>
</td></tr>
<tr><td><code id="lmrobdet.control_+3A_py_maxit">py_maxit</code></td>
<td>
<p>Maximum number of iterations. See <code><a href="pyinit.html#topic+pyinit">pyinit</a></code>.</p>
</td></tr>
<tr><td><code id="lmrobdet.control_+3A_py_eps">py_eps</code></td>
<td>
<p>Relative tolerance for convergence.  See <code><a href="pyinit.html#topic+pyinit">pyinit</a></code>.</p>
</td></tr>
<tr><td><code id="lmrobdet.control_+3A_mscale_maxit">mscale_maxit</code></td>
<td>
<p>Maximum number of iterations for the M-scale algorithm. See <code><a href="pyinit.html#topic+pyinit">pyinit</a></code> and <code><a href="#topic+mscale">mscale</a></code>.</p>
</td></tr>
<tr><td><code id="lmrobdet.control_+3A_mscale_tol">mscale_tol</code></td>
<td>
<p>Convergence tolerance for the M-scale algorithm. See <code><a href="#topic+mscale">mscale</a></code> and <code><a href="#topic+mscale">mscale</a></code>.</p>
</td></tr>
<tr><td><code id="lmrobdet.control_+3A_mscale_rho_fun">mscale_rho_fun</code></td>
<td>
<p>String indicating the loss function used for the M-scale. See <code><a href="pyinit.html#topic+pyinit">pyinit</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>family</code> specifies the name of the family of loss
function to be used. Current valid options are &quot;bisquare&quot;, &quot;opt&quot;, &quot;mopt&quot;, 
&quot;optV0&quot; and &quot;moptV0&quot;. &quot;mopt&quot; is a modified  version of the optimal psi 
function to make it strictly increasing close to 0, and to make the
corresponding weight function non-increasing.
</p>


<h3>Value</h3>

<p>A list with the necessary tuning parameters.
</p>


<h3>Choice of Rho Loss Function</h3>

<p>As of RobStatTM Versopm 1.0.7, the opt and mopt rhos functions are
calculated using polynomials, rather than using the standard normal error
function (erf) as in versions of RobStatTM prior to 1.0.7. The numerical
results one now gets with the opt or mopt choices will differ by small
amounts from those in earlier RobStatTM versions. Users who wish to replicate
results from releases prior to 1.0.7 may do so using the family arguments
family = &quot;optV0&quot; or family = &quot;moptV0&quot;. Note that the derivative of the rho
loss function, known as the &quot;psi&quot; function, is not the derivative of the rho
polynomial,instead it is still the analytic optimal psi function whose formula
is given in the second of the Vignettes referenced just below.
</p>


<h3>Related Vignettes</h3>

<p>For further details, see the Vignettes &quot;Polynomial Opt and mOpt Rho Functions&quot;,
and &quot;Optimal Bias Robust Regression Psi and Rho&quot;.
</p>


<h3>Author(s)</h3>

<p>Matias Salibian-Barrera, <a href="mailto:matias@stat.ubc.ca">matias@stat.ubc.ca</a>
</p>


<h3>See Also</h3>

<p><code><a href="pyinit.html#topic+pyinit">pyinit</a></code>, <code><a href="#topic+mscale">mscale</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(coleman, package='robustbase')
m2 &lt;- lmrobdetMM(Y ~ ., data=coleman, control=lmrobdet.control(refine.PY=50))
m2
summary(m2)

</code></pre>

<hr>
<h2 id='lmrobdetDCML'>Robust Distance Constrained Maximum Likelihood estimators for linear regression</h2><span id='topic+lmrobdetDCML'></span>

<h3>Description</h3>

<p>This function computes robust Distance Constrained Maximum Likelihood
estimators for linear models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmrobdetDCML(
  formula,
  data,
  subset,
  weights,
  na.action,
  model = TRUE,
  x = !control$compute.rd,
  y = FALSE,
  singular.ok = TRUE,
  contrasts = NULL,
  offset = NULL,
  control = lmrobdet.control()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lmrobdetDCML_+3A_formula">formula</code></td>
<td>
<p>a symbolic description of the model to be fit.</p>
</td></tr>
<tr><td><code id="lmrobdetDCML_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment containing
the variables in the model. If not found in <code>data</code>, model variables
are taken from <code>environment(formula)</code>, which usually is the
root environment of the current R session.</p>
</td></tr>
<tr><td><code id="lmrobdetDCML_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be used.</p>
</td></tr>
<tr><td><code id="lmrobdetDCML_+3A_weights">weights</code></td>
<td>
<p>an optional vector of weights to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="lmrobdetDCML_+3A_na.action">na.action</code></td>
<td>
<p>a function to indicates what should happen when the data contain NAs.
The default is set by the <a href="stats.html#topic+na.action">na.action</a> setting of <code><a href="base.html#topic+options">options</a></code>, and is
<code>na.fail</code> if that is unset.</p>
</td></tr>
<tr><td><code id="lmrobdetDCML_+3A_model">model</code></td>
<td>
<p>logical value indicating whether to return the model frame</p>
</td></tr>
<tr><td><code id="lmrobdetDCML_+3A_x">x</code></td>
<td>
<p>logical value indicating whether to return the model matrix</p>
</td></tr>
<tr><td><code id="lmrobdetDCML_+3A_y">y</code></td>
<td>
<p>logical value indicating whether to return the vector of responses</p>
</td></tr>
<tr><td><code id="lmrobdetDCML_+3A_singular.ok">singular.ok</code></td>
<td>
<p>logical value. If <code>FALSE</code> a singular fit produces an error.</p>
</td></tr>
<tr><td><code id="lmrobdetDCML_+3A_contrasts">contrasts</code></td>
<td>
<p>an optional list. See the <code>contrasts.arg</code> of <a href="stats.html#topic+model.matrix.default">model.matrix.default</a>.</p>
</td></tr>
<tr><td><code id="lmrobdetDCML_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an a priori known component to be included
in the linear predictor during fitting. An offset term can be included in the formula
instead or as well, and if both are specified their sum is used.</p>
</td></tr>
<tr><td><code id="lmrobdetDCML_+3A_control">control</code></td>
<td>
<p>a list specifying control parameters as returned by the function
<a href="#topic+lmrobdet.control">lmrobdet.control</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes Distance Constrained Maximum Likelihood regression estimators
computed using an MM-regression estimator based on Pen~a-Yohai
candidates (instead of subsampling ones).
This function makes use of the functions <code>lmrob.fit</code>,
<code>lmrob..M..fit</code>, <code>.vcov.avar1</code>, <code>lmrob.S</code> and
<code>lmrob.lar</code>, from robustbase,
along with utility functions used by these functions,
modified so as to include use of the analytic form of the
optimal psi and rho functions (for the optimal psi function , see
Section 5.8.1 of Maronna, Martin, Yohai and Salibian Barrera, 2019)
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>The estimated vector of regression coefficients</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>The estimated scale of the residuals</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>The vector of residuals associated with the robust fit</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>Logical value indicating whether IRWLS iterations for the MM-estimator have converged</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Number of IRWLS iterations for the MM-estimator</p>
</td></tr>
<tr><td><code>rweightsMM</code></td>
<td>
<p>Robustness weights for the MM-estimator</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>Fitted values associated with the robust fit</p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p>Numeric rank of the fitted linear model</p>
</td></tr>
<tr><td><code>cov</code></td>
<td>
<p>The estimated covariance matrix of the regression estimates</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>The residual degrees of freedom</p>
</td></tr>
<tr><td><code>contrasts</code></td>
<td>
<p>(only where relevant) the contrasts used</p>
</td></tr>
<tr><td><code>xlevels</code></td>
<td>
<p>(only where relevant) a record of the levels of the factors used in fitting</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>if requested, the model frame used</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>if requested, the model matrix used</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>if requested, the response vector used</p>
</td></tr>
<tr><td><code>na.action</code></td>
<td>
<p>(where relevant) information returned by model.frame on the special handling of NAs</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matias Salibian-Barrera, <a href="mailto:matias@stat.ubc.ca">matias@stat.ubc.ca</a>, based on <code>lmrob</code>
</p>


<h3>References</h3>

<p><a href="http://www.wiley.com/go/maronna/robust">http://www.wiley.com/go/maronna/robust</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DCML">DCML</a></code>, <code><a href="#topic+MMPY">MMPY</a></code>, <code><a href="#topic+SMPY">SMPY</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(coleman, package='robustbase')
m1 &lt;- lmrobdetDCML(Y ~ ., data=coleman)
m1
summary(m1)

</code></pre>

<hr>
<h2 id='lmrobdetLinTest'>Robust likelihood ratio test for linear hypotheses</h2><span id='topic+lmrobdetLinTest'></span><span id='topic+rob.linear.test'></span>

<h3>Description</h3>

<p>This function computes a robust likelihood ratio test for linear hypotheses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmrobdetLinTest(object1, object2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lmrobdetLinTest_+3A_object1">object1</code></td>
<td>
<p>an <code>lmrobdetMM</code> or <code>lmrobM</code> object with the fit corresponding to the complete model</p>
</td></tr>
<tr><td><code id="lmrobdetLinTest_+3A_object2">object2</code></td>
<td>
<p>an <code>lmrobdetMM</code> or <code>lmrobM</code> object with the fit corresponding to the model
restricted under the null linear hypothesis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components: c(&quot;test&quot;,&quot;chisq.pvalue&quot;,&quot;f.pvalue&quot;,&quot;df&quot;)
</p>
<table>
<tr><td><code>test</code></td>
<td>
<p>The value of the F-statistic</p>
</td></tr>
<tr><td><code>f.pvalue</code></td>
<td>
<p>p-value based on the F distribution</p>
</td></tr>
<tr><td><code>chisq.pvalue</code></td>
<td>
<p>p-value based on the chi-squared distribution</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>degrees of freedom</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Victor Yohai, <a href="mailto:vyohai@gmail.com">vyohai@gmail.com</a>
</p>


<h3>References</h3>

<p><a href="http://www.wiley.com/go/maronna/robust">http://www.wiley.com/go/maronna/robust</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(oats)
cont &lt;- lmrobdet.control(bb = 0.5, efficiency = 0.85, family = "bisquare")
oats1M &lt;- lmrobM(response1 ~ variety+block, control=cont, data=oats)
oats1M_var &lt;- lmrobM(response1 ~ block, control=cont, data=oats)
( anov1M_var &lt;- rob.linear.test(oats1M, oats1M_var) )

</code></pre>

<hr>
<h2 id='lmrobdetMM'>Robust Linear Regression Estimators</h2><span id='topic+lmrobdetMM'></span>

<h3>Description</h3>

<p>This function computes an MM-regression estimators for linear models
using deterministic starting points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmrobdetMM(
  formula,
  data,
  subset,
  weights,
  na.action,
  model = TRUE,
  x = !control$compute.rd,
  y = FALSE,
  singular.ok = TRUE,
  contrasts = NULL,
  offset = NULL,
  control = lmrobdet.control()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lmrobdetMM_+3A_formula">formula</code></td>
<td>
<p>a symbolic description of the model to be fit.</p>
</td></tr>
<tr><td><code id="lmrobdetMM_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment containing
the variables in the model. If not found in <code>data</code>, model variables
are taken from <code>environment(formula)</code>, which usually is the
root environment of the current R session.</p>
</td></tr>
<tr><td><code id="lmrobdetMM_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be used.</p>
</td></tr>
<tr><td><code id="lmrobdetMM_+3A_weights">weights</code></td>
<td>
<p>an optional vector of weights to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="lmrobdetMM_+3A_na.action">na.action</code></td>
<td>
<p>a function to indicates what should happen when the data contain NAs.
The default is set by the <a href="stats.html#topic+na.action">na.action</a> setting of <code><a href="base.html#topic+options">options</a></code>, and is
<code>na.fail</code> if that is unset.</p>
</td></tr>
<tr><td><code id="lmrobdetMM_+3A_model">model</code></td>
<td>
<p>logical value indicating whether to return the model frame</p>
</td></tr>
<tr><td><code id="lmrobdetMM_+3A_x">x</code></td>
<td>
<p>logical value indicating whether to return the model matrix</p>
</td></tr>
<tr><td><code id="lmrobdetMM_+3A_y">y</code></td>
<td>
<p>logical value indicating whether to return the vector of responses</p>
</td></tr>
<tr><td><code id="lmrobdetMM_+3A_singular.ok">singular.ok</code></td>
<td>
<p>logical value. If <code>FALSE</code> a singular fit produces an error.</p>
</td></tr>
<tr><td><code id="lmrobdetMM_+3A_contrasts">contrasts</code></td>
<td>
<p>an optional list. See the <code>contrasts.arg</code> of <a href="stats.html#topic+model.matrix.default">model.matrix.default</a>.</p>
</td></tr>
<tr><td><code id="lmrobdetMM_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an a priori known component to be included
in the linear predictor during fitting. An offset term can be included in the formula
instead or as well, and if both are specified their sum is used.</p>
</td></tr>
<tr><td><code id="lmrobdetMM_+3A_control">control</code></td>
<td>
<p>a list specifying control parameters as returned by the function
<a href="#topic+lmrobdet.control">lmrobdet.control</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes MM-regression estimators
computed using Pen~a-Yohai candidates (instead of subsampling ones).
This function makes use of the functions <code>lmrob.fit</code>,
<code>lmrob..M..fit</code>, <code>.vcov.avar1</code>, <code>lmrob.S</code> and
<code>lmrob.lar</code>, from robustbase,
along with utility functions used by these functions,
modified so as to include use of the analytic form of the
optimal psi and rho functions (for the optimal psi function , see
Section 5.8.1 of Maronna, Martin, Yohai and Salibian Barrera, 2019).
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>The estimated vector of regression coefficients</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>The robust residual M-scale estimate using the final residuals from the converged iterated weighted least square (IRWLS) algorithm final estimate</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>The vector of residuals associated with the robust fit</p>
</td></tr>
<tr><td><code>loss</code></td>
<td>
<p>Value of the objective function at the final MM-estimator</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>Logical value indicating whether IRWLS iterations for the MM-estimator have converged</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Number of IRWLS iterations for the MM-estimator</p>
</td></tr>
<tr><td><code>rweights</code></td>
<td>
<p>Robustness weights for the MM-estimator</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>Fitted values associated with the robust fit</p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p>Numeric rank of the fitted linear model</p>
</td></tr>
<tr><td><code>cov</code></td>
<td>
<p>The estimated covariance matrix of the regression estimates</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>The residual degrees of freedom</p>
</td></tr>
<tr><td><code>degree.freedom</code></td>
<td>
<p>The residual degrees of freedom</p>
</td></tr>
<tr><td><code>scale.S</code></td>
<td>
<p>Minimum robust scale associated with the preliminary highly robust but inefficient S-estimator.</p>
</td></tr>
<tr><td><code>r.squared</code></td>
<td>
<p>The robust multiple correlation coefficient</p>
</td></tr>
<tr><td><code>adj.r.squared</code></td>
<td>
<p>The adjusted robust multiple correlation coefficient taking into account the degrees of freedom of each term</p>
</td></tr>
<tr><td><code>contrasts</code></td>
<td>
<p>(only where relevant) the contrasts used</p>
</td></tr>
<tr><td><code>xlevels</code></td>
<td>
<p>(only where relevant) a record of the levels of the factors used in fitting</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>if requested, the model frame used</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>if requested, the model matrix used</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>if requested, the response vector used</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>The <a href="stats.html#topic+terms">terms</a> object used.</p>
</td></tr>
<tr><td><code>iters.py</code></td>
<td>
<p>The number of refinement iterations for each Pena-Yohai candidate for the S-estimator.</p>
</td></tr>
<tr><td><code>iters.const</code></td>
<td>
<p>The number of refinement iterations used to compute the estimator without covariates (to calculate the robust R^2).</p>
</td></tr>
<tr><td><code>assign</code></td>
<td>
<p>Used to separate continuous from categorical columns in the design matrix</p>
</td></tr>
<tr><td><code>na.action</code></td>
<td>
<p>(where relevant) information returned by model.frame on the special handling of NAs</p>
</td></tr>
</table>


<h3>Choice of Rho Loss Function</h3>

<p>This is done by the user choice of family = &quot;opt&quot; or family = &quot;mopt&quot;
in the function lmrobdet.control. As of RobStatTM Versopm 1.0.7, the
opt and mopt rhos functions are calculated using polynomials, rather
than using the standard normal error function (erf) as in versions of
RobStatTM prior to 1.0.7. The numerical results one now gets with the
opt or mopt choices will differ by small amounts from those in earlier
RobStatTM versions. Users who wish to replicate results from releases
prior to 1.0.7 may do so using the family arguments family = &quot;optV0&quot; 
or family = &quot;moptV0&quot;. Note that the derivative of the rho loss function,
known as the &quot;psi&quot; function, is not the derivative of the rho polynomial,
instead it is still the optimal psi function referred to above.
</p>


<h3>Related Vignettes</h3>

<p>For further details, see the Vignettes &quot;Polynomial Opt and mOpt Rho Functions&quot;,
and &quot;Optimal Bias Robust Regression Psi and Rho&quot;.
</p>


<h3>Author(s)</h3>

<p>Matias Salibian-Barrera, <a href="mailto:matias@stat.ubc.ca">matias@stat.ubc.ca</a>, based on <code>lmrob</code> from package <code>robustbase</code>
</p>


<h3>References</h3>

<p><a href="http://www.wiley.com/go/maronna/robust">http://www.wiley.com/go/maronna/robust</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+DCML">DCML</a>, <a href="#topic+MMPY">MMPY</a>, <a href="#topic+SMPY">SMPY</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(coleman, package='robustbase')
m2 &lt;- lmrobdetMM(Y ~ ., data=coleman)
m2
summary(m2)

</code></pre>

<hr>
<h2 id='lmrobdetMM.RFPE'>Robust Final Prediction Error</h2><span id='topic+lmrobdetMM.RFPE'></span>

<h3>Description</h3>

<p>This function computes the robust Final Prediction Errors (RFPE) for a robust regression fit using M-estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmrobdetMM.RFPE(object, scale = NULL, bothVals = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lmrobdetMM.RFPE_+3A_object">object</code></td>
<td>
<p>an object of class <code>lmrobdetMM</code> or <code>lmrobM</code>.</p>
</td></tr>
<tr><td><code id="lmrobdetMM.RFPE_+3A_scale">scale</code></td>
<td>
<p>a numeric value specifying the scale estimate used to compute the RFPE. Usually this 
should be the scale estimate from an encompassing model. If <code>NULL</code>, the scale estimate in 
<code>object</code> is used.</p>
</td></tr>
<tr><td><code id="lmrobdetMM.RFPE_+3A_bothvals">bothVals</code></td>
<td>
<p>a logical value: if <code>TRUE</code> the function returns the two terms of the RFPE expression separately (equation 
(5.39) in the reference book); otherwise, the value of RFPE is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the argument <code>bothVals</code> is <code>FALSE</code>, the robust final prediction error (numeric). Otherwise,
the two terms of the RFPE expression in equation (5.39), Section 5.6.2 of Maronna
et al. (2019), <a href="http://www.wiley.com/go/maronna/robust">http://www.wiley.com/go/maronna/robust</a>, are returned separately 
in a list with components named <code>minRhoMM.C</code> and <code>penaltyRFPE</code>
</p>


<h3>Author(s)</h3>

<p>Victor Yohai, <a href="mailto:victoryohai@gmail.com">victoryohai@gmail.com</a>, Matias Salibian-Barrera, <a href="mailto:matias@stat.ubc.ca">matias@stat.ubc.ca</a>
</p>


<h3>References</h3>

<p><a href="http://www.wiley.com/go/maronna/robust">http://www.wiley.com/go/maronna/robust</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lmrobdetMM">lmrobdetMM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(coleman, package='robustbase')
m2 &lt;- lmrobdetMM(Y ~ ., data=coleman)
lmrobdetMM.RFPE(m2)

</code></pre>

<hr>
<h2 id='lmrobM'>Robust estimators for linear regression with fixed designs</h2><span id='topic+lmrobM'></span>

<h3>Description</h3>

<p>This function computes a robust regression
estimator for a linear models with fixed designs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmrobM(
  formula,
  data,
  subset,
  weights,
  na.action,
  model = TRUE,
  x = FALSE,
  y = FALSE,
  singular.ok = TRUE,
  contrasts = NULL,
  offset = NULL,
  control = lmrobM.control()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lmrobM_+3A_formula">formula</code></td>
<td>
<p>a symbolic description of the model to be fit.</p>
</td></tr>
<tr><td><code id="lmrobM_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment containing
the variables in the model. If not found in <code>data</code>, model variables
are taken from <code>environment(formula)</code>, which usually is the
root environment of the current R session.</p>
</td></tr>
<tr><td><code id="lmrobM_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be used.</p>
</td></tr>
<tr><td><code id="lmrobM_+3A_weights">weights</code></td>
<td>
<p>an optional vector of weights to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="lmrobM_+3A_na.action">na.action</code></td>
<td>
<p>a function to indicates what should happen when the data contain NAs.
The default is set by the <a href="stats.html#topic+na.action">na.action</a> setting of <code><a href="base.html#topic+options">options</a></code>, and is
<code>na.fail</code> if that is unset.</p>
</td></tr>
<tr><td><code id="lmrobM_+3A_model">model</code></td>
<td>
<p>logical value indicating whether to return the model frame</p>
</td></tr>
<tr><td><code id="lmrobM_+3A_x">x</code></td>
<td>
<p>logical value indicating whether to return the model matrix</p>
</td></tr>
<tr><td><code id="lmrobM_+3A_y">y</code></td>
<td>
<p>logical value indicating whether to return the vector of responses</p>
</td></tr>
<tr><td><code id="lmrobM_+3A_singular.ok">singular.ok</code></td>
<td>
<p>logical value. If <code>FALSE</code> a singular fit produces an error.</p>
</td></tr>
<tr><td><code id="lmrobM_+3A_contrasts">contrasts</code></td>
<td>
<p>an optional list. See the <code>contrasts.arg</code> of <a href="stats.html#topic+model.matrix.default">model.matrix.default</a>.</p>
</td></tr>
<tr><td><code id="lmrobM_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an a priori known component to be included
in the linear predictor during fitting. An offset term can be included in the formula
instead or as well, and if both are specified their sum is used.</p>
</td></tr>
<tr><td><code id="lmrobM_+3A_control">control</code></td>
<td>
<p>a list specifying control parameters as returned by the function
<a href="#topic+lmrobM.control">lmrobM.control</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes robust regression estimators for linear
models with fixed designs. It computes an L1 estimator,
and uses it as a starting point to find a minimum of a
re-descending M estimator. The scale is set to a quantile of the
absolute residuals from the L1 estimator.
This function makes use of the functions <code>lmrob.fit</code>,
<code>lmrob..M..fit</code>, <code>.vcov.avar1</code>, <code>lmrob.S</code> and
<code>lmrob.lar</code>, from robustbase,
along with utility functions used by these functions,
modified so as to include use of the analytic form of the
optimal psi and rho functions (for the optimal psi function , see
Section 5.8.1 of Maronna, Martin, Yohai and Salibian Barrera, 2019)
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>The estimated vector of regression coefficients</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>The estimated scale of the residuals</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>The vector of residuals associated with the robust fit</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>Logical value indicating whether IRWLS iterations for the MM-estimator have converged</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Number of IRWLS iterations for the MM-estimator</p>
</td></tr>
<tr><td><code>rweights</code></td>
<td>
<p>Robustness weights for the MM-estimator</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>Fitted values associated with the robust fit</p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p>Numeric rank of the fitted linear model</p>
</td></tr>
<tr><td><code>cov</code></td>
<td>
<p>The estimated covariance matrix of the regression estimates</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>The residual degrees of freedom</p>
</td></tr>
<tr><td><code>contrasts</code></td>
<td>
<p>(only where relevant) the contrasts used</p>
</td></tr>
<tr><td><code>xlevels</code></td>
<td>
<p>(only where relevant) a record of the levels of the factors used in fitting</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>if requested, the model frame used</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>if requested, the model matrix used</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>if requested, the response vector used</p>
</td></tr>
<tr><td><code>na.action</code></td>
<td>
<p>(where relevant) information returned by model.frame on the special handling of NAs</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Victor Yohai, <a href="mailto:vyohai@gmail.com">vyohai@gmail.com</a>, based on <code>lmrob</code>
</p>


<h3>References</h3>

<p><a href="http://www.wiley.com/go/maronna/robust">http://www.wiley.com/go/maronna/robust</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(shock)
cont &lt;- lmrobM.control(bb = 0.5, efficiency = 0.85, family = "bisquare")
shockrob &lt;- lmrobM(time ~ n.shocks, data = shock, control=cont)
shockrob
summary(shockrob)

</code></pre>

<hr>
<h2 id='lmrobM.control'>Tuning parameters for lmrobM</h2><span id='topic+lmrobM.control'></span>

<h3>Description</h3>

<p>This function sets tuning parameters for the M estimators of regression implemented
in <code><a href="#topic+lmrobM">lmrobM</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmrobM.control(
  bb = 0.5,
  efficiency = 0.99,
  family = "opt",
  tuning.chi,
  tuning.psi,
  max.it = 100,
  rel.tol = 1e-07,
  mscale_tol = 1e-06,
  mscale_maxit = 50,
  trace.lev = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lmrobM.control_+3A_bb">bb</code></td>
<td>
<p>tuning constant (between 0 and 1/2) for the M-scale used to compute the residual
scale estimator. Defaults to 0.5.</p>
</td></tr>
<tr><td><code id="lmrobM.control_+3A_efficiency">efficiency</code></td>
<td>
<p>desired asymptotic efficiency of the final regression M-estimator. Defaults to 0.85.</p>
</td></tr>
<tr><td><code id="lmrobM.control_+3A_family">family</code></td>
<td>
<p>string specifying the name of the family of loss function to be used (current valid
options are &quot;bisquare&quot;, &quot;opt&quot; and &quot;mopt&quot;). Incomplete entries will be matched to
the current valid options.</p>
</td></tr>
<tr><td><code id="lmrobM.control_+3A_tuning.chi">tuning.chi</code></td>
<td>
<p>tuning constant for the function used to compute the M-scale
used for the residual scale estimator. If missing, it is computed inside <code>lmrobdet.control</code> to match
the value of <code>bb</code> according to the family of rho functions specified in <code>family</code>.</p>
</td></tr>
<tr><td><code id="lmrobM.control_+3A_tuning.psi">tuning.psi</code></td>
<td>
<p>tuning parameters for the regression M-estimator computed with a rho function
as specified with argument <code>family</code>. If missing, it is computed inside <code>lmrobdet.control</code> to match
the value of <code>efficiency</code> according to the family of rho functions specified in <code>family</code>.
Appropriate values for <code>tuning.psi</code> for a given desired efficiency for Gaussian errors
can be constructed using the functions <a href="#topic+bisquare">bisquare</a>, <a href="#topic+mopt">mopt</a> and <a href="#topic+opt">opt</a>.</p>
</td></tr>
<tr><td><code id="lmrobM.control_+3A_max.it">max.it</code></td>
<td>
<p>maximum number of IRWLS iterations for the M-estimator</p>
</td></tr>
<tr><td><code id="lmrobM.control_+3A_rel.tol">rel.tol</code></td>
<td>
<p>relative covergence tolerance for the IRWLS iterations for the M-estimator</p>
</td></tr>
<tr><td><code id="lmrobM.control_+3A_mscale_tol">mscale_tol</code></td>
<td>
<p>Convergence tolerance for the M-scale algorithm. See <code><a href="#topic+mscale">mscale</a></code>.</p>
</td></tr>
<tr><td><code id="lmrobM.control_+3A_mscale_maxit">mscale_maxit</code></td>
<td>
<p>Maximum number of iterations for the M-scale algorithm. See <code><a href="#topic+mscale">mscale</a></code>.</p>
</td></tr>
<tr><td><code id="lmrobM.control_+3A_trace.lev">trace.lev</code></td>
<td>
<p>positive values (increasingly) provide details on the progress of the M-algorithm</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the necessary tuning parameters.
</p>


<h3>Author(s)</h3>

<p>Matias Salibian-Barrera, <a href="mailto:matias@stat.ubc.ca">matias@stat.ubc.ca</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(coleman, package='robustbase')
m2 &lt;- lmrobM(Y ~ ., data=coleman, control=lmrobM.control())
m2
summary(m2)

</code></pre>

<hr>
<h2 id='locScaleM'>Robust univariate location and scale M-estimators</h2><span id='topic+locScaleM'></span><span id='topic+MLocDis'></span>

<h3>Description</h3>

<p>This function computes M-estimators for location and scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locScaleM(x, psi = "mopt", eff = 0.95, maxit = 50, tol = 1e-04, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="locScaleM_+3A_x">x</code></td>
<td>
<p>a vector of univariate observations</p>
</td></tr>
<tr><td><code id="locScaleM_+3A_psi">psi</code></td>
<td>
<p>a string indicating which score function to use. Valid options are &quot;bisquare&quot;, &quot;huber&quot;,
&quot;opt&quot; and &quot;mopt&quot;.</p>
</td></tr>
<tr><td><code id="locScaleM_+3A_eff">eff</code></td>
<td>
<p>desired asymptotic efficiency. Valid options are 0.85, 0.9 and 0.95 (default) when
<code>psi</code> = &quot;bisquare&quot; or &quot;huber&quot;, and 0.85, 0.9, 0.95 (default) and 0.99 when
<code>psi</code> = &quot;opt&quot; or &quot;mopt&quot;.</p>
</td></tr>
<tr><td><code id="locScaleM_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of iterations allowed.</p>
</td></tr>
<tr><td><code id="locScaleM_+3A_tol">tol</code></td>
<td>
<p>tolerance to decide convergence of the iterative algorithm.</p>
</td></tr>
<tr><td><code id="locScaleM_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether <code>NA</code> values should be stripped before
the computation proceeds. Defaults to <code>FALSE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes M-estimators for location and scale.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>mu</code></td>
<td>
<p>The location estimate</p>
</td></tr>
<tr><td><code>std.mu</code></td>
<td>
<p>Estimated standard deviation of the location estimator <code>mu</code></p>
</td></tr>
<tr><td><code>disper</code></td>
<td>
<p>M-scale/dispersion estimate</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ricardo Maronna, <a href="mailto:rmaronna@retina.ar">rmaronna@retina.ar</a>
</p>


<h3>References</h3>

<p><a href="http://www.wiley.com/go/maronna/robust">http://www.wiley.com/go/maronna/robust</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
r &lt;- rnorm(150, sd=1.5)
locScaleM(r)
# 10% of outliers, sd of good points is 1.5
set.seed(123)
r2 &lt;- c(rnorm(135, sd=1.5), rnorm(15, mean=-10, sd=.5))
locScaleM(r2)

</code></pre>

<hr>
<h2 id='logregBY'>Bianco and Yohai estimator for logistic regression</h2><span id='topic+logregBY'></span><span id='topic+BYlogreg'></span>

<h3>Description</h3>

<p>This function computes the M-estimator proposed by Bianco and Yohai for
logistic regression. By default, an intercept term is included and p
parameters are estimated. Modified by Yohai (2018) to take as initial estimator
a weighted ML estimator with weights derived from the MCD estimator.
For more details we refer to Croux, C., and Haesbroeck, G. (2002),
&quot;Implementing the Bianco and Yohai estimator for Logistic Regression&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logregBY(x0, y, intercept = 1, const = 0.5, kmax = 1000, maxhalf = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logregBY_+3A_x0">x0</code></td>
<td>
<p>matrix of explanatory variables;</p>
</td></tr>
<tr><td><code id="logregBY_+3A_y">y</code></td>
<td>
<p>vector of binomial responses (0 or 1);</p>
</td></tr>
<tr><td><code id="logregBY_+3A_intercept">intercept</code></td>
<td>
<p>1 or 0 indicating if an intercept is included or or not</p>
</td></tr>
<tr><td><code id="logregBY_+3A_const">const</code></td>
<td>
<p>tuning constant used in the computation of the estimator (default=0.5);</p>
</td></tr>
<tr><td><code id="logregBY_+3A_kmax">kmax</code></td>
<td>
<p>maximum number of iterations before convergence (default=1000);</p>
</td></tr>
<tr><td><code id="logregBY_+3A_maxhalf">maxhalf</code></td>
<td>
<p>max number of step-halving (default=10).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>estimates for the regression coefficients</p>
</td></tr>
<tr><td><code>standard.deviation</code></td>
<td>
<p>standard deviations of the coefficients</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>fitted values</p>
</td></tr>
<tr><td><code>residual.deviances</code></td>
<td>
<p>residual deviances</p>
</td></tr>
<tr><td><code>components</code></td>
<td>
<p>logical value indicating whether convergence was achieved</p>
</td></tr>
<tr><td><code>objective</code></td>
<td>
<p>value of the objective function at the minimum</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christophe Croux, Gentiane Haesbroeck, Victor Yohai
</p>


<h3>References</h3>

<p><a href="http://www.wiley.com/go/maronna/robust">http://www.wiley.com/go/maronna/robust</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(skin)
Xskin &lt;- as.matrix( skin[, 1:2] )
yskin &lt;- skin$vasoconst
skinBY &lt;- logregBY(Xskin, yskin, intercept=1)
skinBY$coeff
skinBY$standard.deviation

</code></pre>

<hr>
<h2 id='logregWBY'>Bianco and Yohai estimator for logistic regression</h2><span id='topic+logregWBY'></span><span id='topic+WBYlogreg'></span>

<h3>Description</h3>

<p>This function computes the weighted M-estimator of Bianco and Yohai in logistic regression.
By default, an intercept term is included and p parameters are estimated. Modified by
Yohai (2018) to take as initial estimator a weighted ML estimator computed with weights
derived from the MCD estimator of the continuous explanatory variables. The same weights
are used to compute the final weighted M-estimator. For more details we refer to
Croux, C., and Haesbroeck, G. (2002), &quot;Implementing the Bianco and Yohai estimator for
Logistic Regression&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logregWBY(x0, y, intercept = 1, const = 0.5, kmax = 1000, maxhalf = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logregWBY_+3A_x0">x0</code></td>
<td>
<p>matrix of explanatory variables;</p>
</td></tr>
<tr><td><code id="logregWBY_+3A_y">y</code></td>
<td>
<p>vector of binomial responses (0 or 1);</p>
</td></tr>
<tr><td><code id="logregWBY_+3A_intercept">intercept</code></td>
<td>
<p>1 or 0 indicating if an intercept is included or or not</p>
</td></tr>
<tr><td><code id="logregWBY_+3A_const">const</code></td>
<td>
<p>tuning constant used in the computation of the estimator (default=0.5);</p>
</td></tr>
<tr><td><code id="logregWBY_+3A_kmax">kmax</code></td>
<td>
<p>maximum number of iterations before convergence (default=1000);</p>
</td></tr>
<tr><td><code id="logregWBY_+3A_maxhalf">maxhalf</code></td>
<td>
<p>max number of step-halving (default=10).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>estimates for the regression coefficients</p>
</td></tr>
<tr><td><code>standard.deviation</code></td>
<td>
<p>standard deviations of the coefficients</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>fitted values</p>
</td></tr>
<tr><td><code>residual.deviances</code></td>
<td>
<p>residual deviances</p>
</td></tr>
<tr><td><code>components</code></td>
<td>
<p>logical value indicating whether convergence was achieved</p>
</td></tr>
<tr><td><code>objective</code></td>
<td>
<p>value of the objective function at the minimum</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christophe Croux, Gentiane Haesbroeck, Victor Yohai
</p>


<h3>References</h3>

<p><a href="http://www.wiley.com/go/maronna/robust">http://www.wiley.com/go/maronna/robust</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(skin)
Xskin &lt;- as.matrix( skin[, 1:2] )
yskin &lt;- skin$vasoconst
skinWBY &lt;- logregWBY(Xskin, yskin, intercept=1)
skinWBY$coeff
skinWBY$standard.deviation

</code></pre>

<hr>
<h2 id='logregWML'>Weighted likelihood estimator for the logistic model</h2><span id='topic+logregWML'></span><span id='topic+WMLlogreg'></span>

<h3>Description</h3>

<p>This function computes a weighted likelihood estimator for the logistic model, where
the weights penalize high leverage observations. In this version the weights are zero or one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logregWML(x0, y, intercept = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logregWML_+3A_x0">x0</code></td>
<td>
<p>p x n matrix of explanatory variables, p is the number of explanatory variables, n is the number of observations</p>
</td></tr>
<tr><td><code id="logregWML_+3A_y">y</code></td>
<td>
<p>response vector</p>
</td></tr>
<tr><td><code id="logregWML_+3A_intercept">intercept</code></td>
<td>
<p>1 or 0 indicating if an intercept is included or or not</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>vector of regression coefficients</p>
</td></tr>
<tr><td><code>standard.deviation</code></td>
<td>
<p>standard deviations of the regression coefficient estimators</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>vector with the probabilities of success</p>
</td></tr>
<tr><td><code>residual.deviances</code></td>
<td>
<p>residual deviances</p>
</td></tr>
<tr><td><code>cov</code></td>
<td>
<p>covariance matrix of the regression estimates</p>
</td></tr>
<tr><td><code>objective</code></td>
<td>
<p>value of the objective function at the minimum</p>
</td></tr>
<tr><td><code>xweights</code></td>
<td>
<p>vector of zeros and ones used to compute the weighted maimum likelihood estimator</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Victor Yohai
</p>


<h3>References</h3>

<p><a href="http://www.wiley.com/go/maronna/robust">http://www.wiley.com/go/maronna/robust</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(skin)
Xskin &lt;- as.matrix( skin[, 1:2] )
yskin &lt;- skin$vasoconst
skinWML &lt;- logregWML(Xskin, yskin, intercept=1)
skinWML$coeff
skinWML$standard.deviation

</code></pre>

<hr>
<h2 id='mineral'>Mineral data</h2><span id='topic+mineral'></span>

<h3>Description</h3>

<p>Contents (in parts per million) of 22 chemical elements in
53 samples of rocks in Western Australia.
Two columns (8 and 9) were selected for use in this book.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mineral)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"data.frame"</code>.
</p>


<h3>Details</h3>

<p>Format: Numeric with 53 rows and 2 columns:
</p>


<h3>Source</h3>

<p>Smith, R.E., Campbell, N.A. and Lichfield, A. (1984), Multivariate
statistical techniques applied to pisolitic laterite geochemistry at Golden Grove,
Western Australia, Journal of Geochemical Exploration, 22, 193-216.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mineral)
</code></pre>

<hr>
<h2 id='MMPY'>MM regression estimator using Pen~a-Yohai candidates</h2><span id='topic+MMPY'></span>

<h3>Description</h3>

<p>This function computes MM-regression estimator using Pen~a-Yohai
candidates for the initial S-estimator. This function is used
internally by <code><a href="#topic+lmrobdetMM">lmrobdetMM</a></code>, and not meant to be used
directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MMPY(X, y, control, mf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MMPY_+3A_x">X</code></td>
<td>
<p>design matrix</p>
</td></tr>
<tr><td><code id="MMPY_+3A_y">y</code></td>
<td>
<p>response vector</p>
</td></tr>
<tr><td><code id="MMPY_+3A_control">control</code></td>
<td>
<p>a list of control parameters as returned by <code><a href="#topic+lmrobdet.control">lmrobdet.control</a></code></p>
</td></tr>
<tr><td><code id="MMPY_+3A_mf">mf</code></td>
<td>
<p>model frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code><a href="robustbase.html#topic+lmrob">lmrob</a></code> object witht the M-estimator
obtained starting from the S-estimator computed with the
Pen~a-Yohai initial candidates. The properties of the final
estimator (efficiency, etc.) are determined by the tuning constants in
the argument <code>control</code>.
</p>


<h3>Author(s)</h3>

<p>Victor Yohai, <a href="mailto:victoryohai@gmail.com">victoryohai@gmail.com</a>, Matias Salibian-Barrera, <a href="mailto:matias@stat.ubc.ca">matias@stat.ubc.ca</a>
</p>


<h3>References</h3>

<p><a href="http://www.wiley.com/go/maronna/robust">http://www.wiley.com/go/maronna/robust</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DCML">DCML</a></code>, <code><a href="#topic+MMPY">MMPY</a></code>, <code><a href="#topic+SMPY">SMPY</a></code>
</p>

<hr>
<h2 id='mopt'>Tuning parameter for a rho function in the modified (asymptotic bias-) optimal family</h2><span id='topic+mopt'></span>

<h3>Description</h3>

<p>This function computes the tuning constant that yields an MM-regression
estimator with a desired asymptotic efficiency when computed with a
rho function in the corresponding family. The output of this
function can be passed to the functions <a href="#topic+lmrobdet.control">lmrobdet.control</a>,
<a href="#topic+mscale">mscale</a> and <a href="#topic+rho">rho</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mopt(e)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mopt_+3A_e">e</code></td>
<td>
<p>the desired efficiency of the corresponding regression
estimator for Gaussian errors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with named elements containing the corresponding tuning
parameters.
</p>


<h3>Author(s)</h3>

<p>Kjell Konis
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Tuning parameters for an 85%-efficient M-estimator at a Gaussian model
mopt(.85)

</code></pre>

<hr>
<h2 id='moptv0'>Tuning parameter for a rho function in the modified (asymptotic bias-) optimal family</h2><span id='topic+moptv0'></span>

<h3>Description</h3>

<p>This function computes the tuning constant that yields an MM-regression
estimator with a desired asymptotic efficiency when computed with a
rho function in the corresponding family. The output of this
function can be passed to the functions <a href="#topic+lmrobdet.control">lmrobdet.control</a>,
<a href="#topic+mscale">mscale</a> and <a href="#topic+rho">rho</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moptv0(e)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moptv0_+3A_e">e</code></td>
<td>
<p>the desired efficiency of the corresponding regression
estimator for Gaussian errors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with named elements containing the corresponding tuning
parameters.
</p>


<h3>Author(s)</h3>

<p>Kjell Konis
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Tuning parameters for an 85%-efficient M-estimator at a Gaussian model
moptv0(.85)

</code></pre>

<hr>
<h2 id='neuralgia'>Neuralgia data</h2><span id='topic+neuralgia'></span>

<h3>Description</h3>

<p>Neuralgia data. More details here.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(neuralgia)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"data.frame"</code>.
</p>


<h3>Source</h3>

<p>Source goes here.
</p>


<h3>References</h3>

<p>References go here.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(neuralgia)
</code></pre>

<hr>
<h2 id='oats'>Oats data</h2><span id='topic+oats'></span>

<h3>Description</h3>

<p>Yield of grain for eight varieties of oats in five replications of a randomized-block experiment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(oats)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"data.frame"</code>.
</p>


<h3>Details</h3>

<p>Format: Two-way ANOVA table with 8 rows and 5 columns.
</p>


<h3>Source</h3>

<p>Scheffe, H. (1959), Analysis of Variance. New York: John Wiley.
</p>


<h3>References</h3>

<p>References go here.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(oats)
</code></pre>

<hr>
<h2 id='opt'>Tuning parameter for a rho function in the (asymptotic bias-) optimal family</h2><span id='topic+opt'></span>

<h3>Description</h3>

<p>This function computes the tuning constant that yields an MM-regression
estimator with a desired asymptotic efficiency when computed with a
rho function in the corresponding family. The output of this
function can be passed to the functions <a href="#topic+lmrobdet.control">lmrobdet.control</a>,
<a href="#topic+mscale">mscale</a> and <a href="#topic+rho">rho</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opt(e)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opt_+3A_e">e</code></td>
<td>
<p>the desired efficiency of the corresponding regression
estimator for Gaussian errors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with named elements containing the corresponding tuning
parameters.
</p>


<h3>Author(s)</h3>

<p>Kjell Konis
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Tuning parameters for an 85%-efficient M-estimator at a Gaussian model
opt(.85)

</code></pre>

<hr>
<h2 id='optv0'>Tuning parameter for a rho function in the (asymptotic bias-) optimal family</h2><span id='topic+optv0'></span>

<h3>Description</h3>

<p>This function computes the tuning constant that yields an MM-regression
estimator with a desired asymptotic efficiency when computed with a
rho function in the corresponding family. The output of this
function can be passed to the functions <a href="#topic+lmrobdet.control">lmrobdet.control</a>,
<a href="#topic+mscale">mscale</a> and <a href="#topic+rho">rho</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optv0(e)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optv0_+3A_e">e</code></td>
<td>
<p>the desired efficiency of the corresponding regression
estimator for Gaussian errors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with named elements containing the corresponding tuning
parameters.
</p>


<h3>Author(s)</h3>

<p>Kjell Konis
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Tuning parameters for an 85%-efficient M-estimator at a Gaussian model
optv0(.85)

</code></pre>

<hr>
<h2 id='pcaRobS'>Robust principal components</h2><span id='topic+pcaRobS'></span><span id='topic+SMPCA'></span>

<h3>Description</h3>

<p>This function computes robust principal components based on the minimization of
the &quot;residual&quot; M-scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcaRobS(X, ncomp, desprop = 0.9, deltasca = 0.5, maxit = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcaRobS_+3A_x">X</code></td>
<td>
<p>a data matrix with observations in rows.</p>
</td></tr>
<tr><td><code id="pcaRobS_+3A_ncomp">ncomp</code></td>
<td>
<p>desired (maximum) number of components</p>
</td></tr>
<tr><td><code id="pcaRobS_+3A_desprop">desprop</code></td>
<td>
<p>desired (minimum) proportion of explained variability (default = 0.9)</p>
</td></tr>
<tr><td><code id="pcaRobS_+3A_deltasca">deltasca</code></td>
<td>
<p>&quot;delta&quot; parameter of the scale M-estimator (default=0.5)</p>
</td></tr>
<tr><td><code id="pcaRobS_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of iterations (default= 100)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>q</code></td>
<td>
<p>The actual number of principal components</p>
</td></tr>
<tr><td><code>propex</code></td>
<td>
<p>The actual proportion of unexplained variability</p>
</td></tr>
<tr><td><code>eigvec</code></td>
<td>
<p>Eigenvectors, in a <code>p x q</code> matrix</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>an <code>n x p</code> matrix with the rank-q approximation to <code>X</code></p>
</td></tr>
<tr><td><code>repre</code></td>
<td>
<p>An <code>n x q</code> matrix with representation of data in R^q (scores)</p>
</td></tr>
<tr><td><code>propSPC</code></td>
<td>
<p>A vector of length <code>p</code> with the cumulative explained variance from initial SPC</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ricardo Maronna, <a href="mailto:rmaronna@retina.ar">rmaronna@retina.ar</a>, based on original code
by D. Pen~a and J. Prieto
</p>


<h3>References</h3>

<p><a href="http://www.wiley.com/go/maronna/robust">http://www.wiley.com/go/maronna/robust</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bus)
X0 &lt;- as.matrix(bus)
X1 &lt;- X0[,-9]
ss &lt;- apply(X1, 2, mad)
mu &lt;- apply(X1, 2, median)
X &lt;- scale(X1, center=mu, scale=ss)
q &lt;- 3  #compute three components
rr &lt;- pcaRobS(X, q, 0.99)
round(rr$eigvec, 3)

</code></pre>

<hr>
<h2 id='prcompRob'>Robust Principal Components Cont'd</h2><span id='topic+prcompRob'></span>

<h3>Description</h3>

<p>This function uses the pcaRobS function to compute all principal components while
behaving similarly to the prcomp function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prcompRob(x, rank. = NULL, delta.scale = 0.5, max.iter = 100L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prcompRob_+3A_x">x</code></td>
<td>
<p>data matrix with observations in rows</p>
</td></tr>
<tr><td><code id="prcompRob_+3A_rank.">rank.</code></td>
<td>
<p>Maximal number of principal components to be used (optional)</p>
</td></tr>
<tr><td><code id="prcompRob_+3A_delta.scale">delta.scale</code></td>
<td>
<p>&quot;delta&quot; parametor of the scale M-estimator (default = 0.5)</p>
</td></tr>
<tr><td><code id="prcompRob_+3A_max.iter">max.iter</code></td>
<td>
<p>maximum number of iterations (default = 100)</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>sdev</code></td>
<td>
<p>the standard deviation of the principal components</p>
</td></tr>
<tr><td><code>rotation</code></td>
<td>
<p>matrix containing the factor loadings</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>matrix containing the rotated data</p>
</td></tr>
<tr><td><code>center</code></td>
<td>
<p>the centering used</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gregory Brownson, <a href="mailto:gregory.brownson@gmail.com">gregory.brownson@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(wine)

p.wine &lt;- prcompRob(wine)
summary(p.wine)

## Choose only 5
p5.wine &lt;- prcompRob(wine, rank. = 5)
summary(p5.wine)

</code></pre>

<hr>
<h2 id='refine.sm'>IRWLS iterations for S- or M-estimators</h2><span id='topic+refine.sm'></span>

<h3>Description</h3>

<p>This function performs iterative improvements for S- or
M-estimators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>refine.sm(
  x,
  y,
  initial.beta,
  initial.scale,
  k = 50,
  conv = 1,
  b,
  cc,
  family,
  step = "M",
  tol
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="refine.sm_+3A_x">x</code></td>
<td>
<p>design matrix</p>
</td></tr>
<tr><td><code id="refine.sm_+3A_y">y</code></td>
<td>
<p>vector of responses</p>
</td></tr>
<tr><td><code id="refine.sm_+3A_initial.beta">initial.beta</code></td>
<td>
<p>vector of initial regression estimates</p>
</td></tr>
<tr><td><code id="refine.sm_+3A_initial.scale">initial.scale</code></td>
<td>
<p>initial residual scale estimate. If missing the (scaled) median of
the absolute residuals is used.</p>
</td></tr>
<tr><td><code id="refine.sm_+3A_k">k</code></td>
<td>
<p>maximum number of refining steps to be performed</p>
</td></tr>
<tr><td><code id="refine.sm_+3A_conv">conv</code></td>
<td>
<p>an integer indicating whether to check for convergence (1) at each step,
or to force running k steps (0)</p>
</td></tr>
<tr><td><code id="refine.sm_+3A_b">b</code></td>
<td>
<p>tuning constant for the M-scale estimator, used if iterations are for an S-estimator.</p>
</td></tr>
<tr><td><code id="refine.sm_+3A_cc">cc</code></td>
<td>
<p>tuning constant for the rho function.</p>
</td></tr>
<tr><td><code id="refine.sm_+3A_family">family</code></td>
<td>
<p>string specifying the name of the family of loss function to be used (current
valid options are &quot;bisquare&quot;, &quot;opt&quot; and &quot;mopt&quot;)</p>
</td></tr>
<tr><td><code id="refine.sm_+3A_step">step</code></td>
<td>
<p>a string indicating whether the iterations are to compute an S-estimator
('S') or an M-estimator ('M')</p>
</td></tr>
<tr><td><code id="refine.sm_+3A_tol">tol</code></td>
<td>
<p>tolerance to detect convergence (relative difference of consecutive vectors of parameters)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs iterative improvements for S- or
M-estimators. Both iterations are formally the same, the
only difference is that for M-iterations the residual
scale estimate remains fixed, while for S-iterations
it is updated at each step. In this case, we follow
the Fast-S algorithm of Salibian-Barrera and Yohai
an use one step updates for the M-scale, as opposed
to a full computation. This as internal function.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>beta.rw</code></td>
<td>
<p>The updated vector of regression coefficients</p>
</td></tr>
<tr><td><code>scale.rw</code></td>
<td>
<p>The corresponding estimated residual scale</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>A logical value indicating whether the algorithm
converged</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matias Salibian-Barrera, <a href="mailto:matias@stat.ubc.ca">matias@stat.ubc.ca</a>.
</p>

<hr>
<h2 id='resex'>Resex data</h2><span id='topic+resex'></span>

<h3>Description</h3>

<p>A monthly series of inward movement of residential telephone extensions in a
fixed geographic area from January 1966 to May 1973.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(resex)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"data.frame"</code>.
</p>


<h3>Details</h3>

<p>Format: numeric vector of size 89.
</p>


<h3>Source</h3>

<p>Source Engineering, 2nd. Edition, New York, John Wiley.
</p>


<h3>References</h3>

<p>Brubacher. S.R. (1974), Time series outlier detection and modeling
with interpolation, Bell Laboratories Technical Memo.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(resex)
</code></pre>

<hr>
<h2 id='rho'>Rho functions</h2><span id='topic+rho'></span>

<h3>Description</h3>

<p>This function returns the value of the &quot;rho&quot; loss function used
to compute either an M-scale estimator or a robust regression
estimator. It currently can be used to compute the bisquare, optimal
and modified optimal loss functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rho(u, family = " bisquare", cc, standardize = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rho_+3A_u">u</code></td>
<td>
<p>point or vector at which rho is to be evaluated</p>
</td></tr>
<tr><td><code id="rho_+3A_family">family</code></td>
<td>
<p>family string specifying the name of the family of loss function to be used (current valid
options are &quot;bisquare&quot;, &quot;opt&quot; and &quot;mopt&quot;).</p>
</td></tr>
<tr><td><code id="rho_+3A_cc">cc</code></td>
<td>
<p>tuning parameters to be computed according to efficiency and / or breakdown
considerations. See <a href="#topic+lmrobdet.control">lmrobdet.control</a>, <a href="#topic+bisquare">bisquare</a>, <a href="#topic+mopt">mopt</a>
and <a href="#topic+opt">opt</a>.</p>
</td></tr>
<tr><td><code id="rho_+3A_standardize">standardize</code></td>
<td>
<p>logical value determining whether the rho function is to be
standardized so that its maximum value is 1. See <a href="robustbase.html#topic+Mpsi">Mpsi</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value(s) of <code>rho</code> at <code>u</code>
</p>


<h3>Author(s)</h3>

<p>Matias Salibian-Barrera, <a href="mailto:matias@stat.ubc.ca">matias@stat.ubc.ca</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Evaluate rho tuned for 85% efficiency
rho(u=1.1, family='bisquare', cc=bisquare(.85))
# Evaluate rho tuned for 50% breakdown
rho(u=1.1, family='opt', cc=lmrobdet.control(bb=.5, family='opt')$tuning.chi)

</code></pre>

<hr>
<h2 id='rhoprime'>The first derivative of the rho function</h2><span id='topic+rhoprime'></span>

<h3>Description</h3>

<p>The first derivative of the rho function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rhoprime(u, family, cc, standardize = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rhoprime_+3A_u">u</code></td>
<td>
<p>point or vector at which rho is to be evaluated</p>
</td></tr>
<tr><td><code id="rhoprime_+3A_family">family</code></td>
<td>
<p>family string specifying the name of the family of loss function to be used (current valid
options are &quot;bisquare&quot;, &quot;opt&quot; and &quot;mopt&quot;).</p>
</td></tr>
<tr><td><code id="rhoprime_+3A_cc">cc</code></td>
<td>
<p>tuning parameters to be computed according to efficiency and / or breakdown
considerations. See <a href="#topic+lmrobdet.control">lmrobdet.control</a>, <a href="#topic+bisquare">bisquare</a>, <a href="#topic+mopt">mopt</a>
and <a href="#topic+opt">opt</a>.</p>
</td></tr>
<tr><td><code id="rhoprime_+3A_standardize">standardize</code></td>
<td>
<p>logical value determining whether the rho function is to be
standardized so that its maximum value is 1. See <a href="robustbase.html#topic+Mpsi">Mpsi</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the first derivative <code>rho</code> evaluated at <code>u</code>
</p>


<h3>Author(s)</h3>

<p>Matias Salibian-Barrera, <a href="mailto:matias@stat.ubc.ca">matias@stat.ubc.ca</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Evaluate the derivative of a rho function tuned for 85% efficiency
rhoprime(u=1.1, family='bisquare', cc=bisquare(.85))
# Evaluate the derivative of a rho function tuned for 50% breakdown
rhoprime(u=1.1, family='opt', cc=lmrobdet.control(bb=.5, family='opt')$tuning.chi)

</code></pre>

<hr>
<h2 id='rhoprime2'>The second derivative of the rho function</h2><span id='topic+rhoprime2'></span>

<h3>Description</h3>

<p>The second derivative of the rho function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rhoprime2(u, family, cc, standardize = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rhoprime2_+3A_u">u</code></td>
<td>
<p>point or vector at which rho is to be evaluated</p>
</td></tr>
<tr><td><code id="rhoprime2_+3A_family">family</code></td>
<td>
<p>family string specifying the name of the family of loss function to be used (current valid
options are &quot;bisquare&quot;, &quot;opt&quot; and &quot;mopt&quot;).</p>
</td></tr>
<tr><td><code id="rhoprime2_+3A_cc">cc</code></td>
<td>
<p>tuning parameters to be computed according to efficiency and / or breakdown
considerations. See <a href="#topic+lmrobdet.control">lmrobdet.control</a>, <a href="#topic+bisquare">bisquare</a>, <a href="#topic+mopt">mopt</a>
and <a href="#topic+opt">opt</a>.</p>
</td></tr>
<tr><td><code id="rhoprime2_+3A_standardize">standardize</code></td>
<td>
<p>logical value determining whether the rho function is to be
standardized so that its maximum value is 1. See <a href="robustbase.html#topic+Mpsi">Mpsi</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the second derivative of <code>rho</code> evaluated at <code>u</code>
</p>


<h3>Author(s)</h3>

<p>Matias Salibian-Barrera, <a href="mailto:matias@stat.ubc.ca">matias@stat.ubc.ca</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Evaluate the 2nd derivative of a rho function tuned for 85% efficiency
rhoprime2(u=1.1, family='bisquare', cc=bisquare(.85))
# Evaluate the 2nd derivative of a rho function tuned for 50% breakdown
rhoprime2(u=1.1, family='opt', cc=lmrobdet.control(bb=.5, family='opt')$tuning.chi)

</code></pre>

<hr>
<h2 id='scaleM'>M-scale estimator</h2><span id='topic+scaleM'></span><span id='topic+mscale'></span>

<h3>Description</h3>

<p>This function computes an M-scale, which is a robust
scale (spread) estimator.
M-estimators of scale are a robust alternative to
the sample standard deviation. Given a vector of
residuals <code>r</code>, the M-scale estimator <code>s</code>
solves the non-linear equation <code>mean(rho(r/s, cc))=b</code>,
where <code>b</code> and <code>cc</code> are user-chosen tuning constants.
In this package the function <code>rho</code> is one of
Tukey's bisquare family.
The breakdown point of the estimator is <code>min(b, 1-b)</code>,
so the optimal choice for <code>b</code> is 0.5. To obtain a
consistent estimator the constant
<code>cc</code> should be chosen such that E(rho(Z, cc)) = b, where
Z is a standard normal random variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scaleM(
  u,
  delta = 0.5,
  tuning.chi = 1.547645,
  family = "bisquare",
  max.it = 100,
  tol = 1e-06,
  tolerancezero = .Machine$double.eps
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scaleM_+3A_u">u</code></td>
<td>
<p>vector of residuals</p>
</td></tr>
<tr><td><code id="scaleM_+3A_delta">delta</code></td>
<td>
<p>the right hand side of the M-scale equation</p>
</td></tr>
<tr><td><code id="scaleM_+3A_tuning.chi">tuning.chi</code></td>
<td>
<p>the tuning object for the rho function as returned
by <code><a href="#topic+lmrobdet.control">lmrobdet.control</a></code>, <a href="#topic+bisquare">bisquare</a>, <a href="#topic+mopt">mopt</a> or <a href="#topic+opt">opt</a>.
It should correspond to the family of rho functions specified in the argument <code>family</code>.</p>
</td></tr>
<tr><td><code id="scaleM_+3A_family">family</code></td>
<td>
<p>string specifying the name of the family of loss function to be used (current valid
options are &quot;bisquare&quot;, &quot;opt&quot; and &quot;mopt&quot;).</p>
</td></tr>
<tr><td><code id="scaleM_+3A_max.it">max.it</code></td>
<td>
<p>maximum number of iterations allowed</p>
</td></tr>
<tr><td><code id="scaleM_+3A_tol">tol</code></td>
<td>
<p>relative tolerance for convergence</p>
</td></tr>
<tr><td><code id="scaleM_+3A_tolerancezero">tolerancezero</code></td>
<td>
<p>smallest (in absolute value) non-zero value accepted as a scale. Defaults to <code>.Machine$double.eps</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The iterative algorithm starts from the scaled median of
the absolute values of the input vector, and then
cycles through the equation s^2 = s^2 * mean(rho(r/s, cc)) / b.
</p>


<h3>Value</h3>

<p>The scale estimate value at the last iteration or at convergence.
</p>


<h3>Author(s)</h3>

<p>Matias Salibian-Barrera, <a href="mailto:matias@stat.ubc.ca">matias@stat.ubc.ca</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
r &lt;- rnorm(150, sd=1.5)
mscale(r)
sd(r)
# 10% of outliers, sd of good points is 1.5
set.seed(123)
r2 &lt;- c(rnorm(135, sd=1.5), rnorm(15, mean=-5, sd=.5))
mscale(r2)
sd(r2)

</code></pre>

<hr>
<h2 id='shock'>Shock data</h2><span id='topic+shock'></span>

<h3>Description</h3>

<p>Times recorded for a rat to go through a shuttlebox in successive attempts. If the
time exceeded 5 seconds, the rat received an electric shock for the duration of the
next attempt. The data are the number of shocks received and the average time for
all attempts between shocks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(shock)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"data.frame"</code>.
</p>


<h3>Details</h3>

<p>Format: Numeric matrix with 16 rows and 2 columns
</p>


<h3>Source</h3>

<p>Bond, N.W. (1979), Impairment of shuttlebox avoidance-learning following repeated
alcohol withdrawal episodes in rats, Pharmacology, Biochemistry and Behavior,
11, 589-591.
</p>


<h3>References</h3>

<p>References go here.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(shock)
</code></pre>

<hr>
<h2 id='skin'>Skin data</h2><span id='topic+skin'></span>

<h3>Description</h3>

<p>These data correspond to a study of the relationship between air inspiration and
blood circulation in the skin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(skin)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"data.frame"</code>.
</p>


<h3>Details</h3>

<p>Description: The covariates are the logarithms of the volume of air inspired (log VOL)
and of the inspiration rate (log RATE). The response (column 3) is the presence or
absence of vasoconstriction of the skin of the digits after air inspiration. Format
Numeric, 23 rows and 3 columns.
</p>


<h3>Source</h3>

<p>Finney, D.J. (1947), The estimation from individual records of the relationship
between dose and quantal response, Biometrika, 34, 320-334.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(skin)
</code></pre>

<hr>
<h2 id='SMPY'>SM regression estimator using Pen~a-Yohai candidates</h2><span id='topic+SMPY'></span>

<h3>Description</h3>

<p>This function computes a robust regression estimator when there
are categorical / dummy explanatory variables. It uses Pen~a-Yohai
candidates for the S-estimator. This function is used
internally by <code><a href="#topic+lmrobdetMM">lmrobdetMM</a></code>, and not meant to be used
directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SMPY(mf, y, control, split)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SMPY_+3A_mf">mf</code></td>
<td>
<p>model frame</p>
</td></tr>
<tr><td><code id="SMPY_+3A_y">y</code></td>
<td>
<p>response vector</p>
</td></tr>
<tr><td><code id="SMPY_+3A_control">control</code></td>
<td>
<p>a list of control parameters as returned by <code><a href="#topic+lmrobdet.control">lmrobdet.control</a></code></p>
</td></tr>
<tr><td><code id="SMPY_+3A_split">split</code></td>
<td>
<p>a list as returned by <code><a href="robustbase.html#topic+splitFrame">splitFrame</a></code> containing the continuous and
dummy components of the design matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code><a href="robustbase.html#topic+lmrob">lmrob</a></code> object witht the M-estimator
obtained starting from the MS-estimator computed with the
Pen~a-Yohai initial candidates. The properties of the final
estimator (efficiency, etc.) are determined by the tuning constants in
the argument <code>control</code>.
</p>


<h3>Author(s)</h3>

<p>Victor Yohai, <a href="mailto:victoryohai@gmail.com">victoryohai@gmail.com</a>, Matias Salibian-Barrera, <a href="mailto:matias@stat.ubc.ca">matias@stat.ubc.ca</a>
</p>


<h3>References</h3>

<p><a href="http://www.wiley.com/go/maronna/robust">http://www.wiley.com/go/maronna/robust</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DCML">DCML</a></code>, <code><a href="#topic+MMPY">MMPY</a></code>, <code><a href="#topic+SMPY">SMPY</a></code>
</p>

<hr>
<h2 id='stackloss'>Stackloss data</h2><span id='topic+stackloss'></span>

<h3>Description</h3>

<p>Observations from 21 days operation of a plant for the oxidation
of ammonia as a stage in the production of nitric acid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(stackloss)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"data.frame"</code>.
</p>


<h3>Details</h3>

<p>Format: 21 cases and 4 continuous variables.
Description: The columns are:
1. air flow
2. cooling water inlet temperature (C)
3. acid concentration (
4. Stack loss, defined as the percentage of ingoing ammonia
that escapes unabsorbed (response)
</p>


<h3>Source</h3>

<p>Brownlee, K.A. (1965), Statistical Theory and Methodology in Science and
Engineering, 2nd Edition, New York: John Wiley &amp; Sons, Inc.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(stackloss)
</code></pre>

<hr>
<h2 id='step.lmrobdetMM'>Robust stepwise using RFPE</h2><span id='topic+step.lmrobdetMM'></span><span id='topic+step.lmrobdet'></span>

<h3>Description</h3>

<p>This function performs stepwise model selection on a robustly fitted
linear model using the RFPE
criterion and the robust regression estimators computed with
<code><a href="#topic+lmrobdetMM">lmrobdetMM</a></code>. Only backwards stepwise is currently implemented.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step.lmrobdetMM(
  object,
  scope,
  direction = c("both", "backward", "forward"),
  trace = TRUE,
  keep = NULL,
  steps = 1000,
  whole.path = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step.lmrobdetMM_+3A_object">object</code></td>
<td>
<p>a robust fit as returned by <code><a href="#topic+lmrobdetMM">lmrobdetMM</a></code></p>
</td></tr>
<tr><td><code id="step.lmrobdetMM_+3A_scope">scope</code></td>
<td>
<p>either a formula or a list with elements <code>lower</code> and <code>upper</code> each of 
which is a formula. The terms in the right-hand-side of <code>lower</code> are always included 
in the model and the additional terms in the right-hand-side of <code>upper</code> are the
candidates for inclusion/exclusion from the model. If a single formula is given, it is 
taken to be <code>upper</code>, and <code>lower</code> is set to the empty model. The <code>.</code> operator 
is interpreted in the context of the formula in <code>object</code>.</p>
</td></tr>
<tr><td><code id="step.lmrobdetMM_+3A_direction">direction</code></td>
<td>
<p>the direction of stepwise search. Currenly only <code>backward</code> stepwise 
searches are implemented.</p>
</td></tr>
<tr><td><code id="step.lmrobdetMM_+3A_trace">trace</code></td>
<td>
<p>logical. If <code>TRUE</code> information about each step is printed on the screen.</p>
</td></tr>
<tr><td><code id="step.lmrobdetMM_+3A_keep">keep</code></td>
<td>
<p>a filter function whose input is a fitted model object and the associated AIC statistic, and whose output is arbitrary. Typically keep will select a subset of the components of the object and return them. The default is not to keep anything.</p>
</td></tr>
<tr><td><code id="step.lmrobdetMM_+3A_steps">steps</code></td>
<td>
<p>maximum number of steps to be performed. Defaults to 1000, which should mean as many as needed.</p>
</td></tr>
<tr><td><code id="step.lmrobdetMM_+3A_whole.path">whole.path</code></td>
<td>
<p>if <code>FALSE</code> (default) variables are dropped until the RFPE fails to improve. If <code>TRUE</code> the best variable to be dropped is removed, even if this does not improve the RFPE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Presently only backward stepwise selection is supported. During each step the 
Robust Final Prediction Error (as computed by the function <code>lmrobdetMM.RFPE</code>) is 
calculated for the current model and for each sub-model achievable by deleting a 
single term. If the argument <code>whole.path</code> is <code>FALSE</code>, the function steps 
to the sub-model with the lowest 
Robust Final Prediction Error or, if the current model has the lowest Robust Final 
Prediction Error, terminates. If the argument <code>whole.path</code> is <code>TRUE</code>, the 
function steps through all smaller submodels removing, at each step, the variable 
that most reduces the Robust Final Prediction Error. The scale estimate from <code>object</code> 
is used to compute the Robust Final Prediction Error throughout the procedure.
</p>


<h3>Value</h3>

<p>If <code>whole.path == FALSE</code> the function returns the robust fit as obtained by <code>lmrobdetMM</code> using the final model. 
If <code>whole.path == TRUE</code> a list is returned containing the RFPE of each model on the sequence
of submodels. The names of the components of this list are the formulas that correspods to each model.
</p>


<h3>Author(s)</h3>

<p>Victor Yohai, <a href="mailto:victoryohai@gmail.com">victoryohai@gmail.com</a>, Matias Salibian-Barrera, <a href="mailto:matias@stat.ubc.ca">matias@stat.ubc.ca</a>
</p>


<h3>References</h3>

<p><a href="http://www.wiley.com/go/maronna/robust">http://www.wiley.com/go/maronna/robust</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DCML">DCML</a></code>, <code><a href="#topic+MMPY">MMPY</a></code>, <code><a href="#topic+SMPY">SMPY</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cont &lt;- lmrobdet.control(bb = 0.5, efficiency = 0.85, family = "bisquare")
set.seed(300)
X &lt;- matrix(rnorm(50*6), 50, 6)
beta &lt;- c(1,1,1,0,0,0)
y &lt;- as.vector(X %*% beta) + 1 + rnorm(50)
y[1:6] &lt;- seq(30, 55, 5)
for (i in 1:6) X[i,] &lt;- c(X[i,1:3],i/2,i/2,i/2)
Z &lt;- cbind(y,X)
Z &lt;- as.data.frame(Z)
obj &lt;- lmrobdetMM(y ~ ., data=Z, control=cont)
out &lt;- step.lmrobdetMM(obj)

</code></pre>

<hr>
<h2 id='vehicle'>Vehicle data</h2><span id='topic+vehicle'></span>

<h3>Description</h3>

<p>The original data set contains an ensemble of shape feature extractors to the
2D silhouettes of different vehicles. The purpose is to classify a given
silhouette as one of four types of vehicle, using a set of 18 features extracted
from the silhouette. Here we deal with the &quot;van&quot; type, which has 217 cases.
Description; The following features were extracted from the silhouettes.
1. compactness
2. circularity
3. distance circularity
4. radius ratio
5. principal axis aspect ratio
6. maximum length aspect ratio
7. scatter ratio
8. elongatedness
9. principal axis rectangularity
10. maximum length rectangularity
11. scaled variance along major axis
12. scaled variance along minor axis
13. scaled radius of gyration
14. skewness about major axis
15. skewness about minor axis
16. kurtosis about minor axis
17. kurtosis about major axis
18. hollows ratio
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(vehicle)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"data.frame"</code>.
</p>


<h3>Details</h3>

<p>Format: Numeric, 217 rows and 18 columns.
</p>


<h3>Source</h3>

<p>Turing Institute, Glasgow, and are available at https://archive.ics.uci.edu/ml/datasets/Statlog+(Vehicle+Silhouettes).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vehicle)
</code></pre>

<hr>
<h2 id='waste'>Waste data</h2><span id='topic+waste'></span>

<h3>Description</h3>

<p>Waste data. The original data are the result of a study on production
waste and land use by Golueke and McGauhey (1970), and contain nine variables,
of which we consider six.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(waste)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"data.frame"</code>.
</p>


<h3>Details</h3>

<p>Format: 40 cases and 6 continuous variables.
Description: The columns are
1. industrial land (acres)
2. fabricated metals (acres)
3. trucking and wholesale trade (acres)
4. retail trade (acres)
5. restaurants and hotels (acres)
6. solid waste (millions of tons), response
</p>


<h3>Source</h3>

<p>Golueke, C.G. and McGauhey, P.H. (1970), Comprehensive Studies of
Solid Waste Management, US Department of Health, Education and Welfare, Public
Health Services Publication No. 2039.
</p>


<h3>References</h3>

<p>Golueke, C.G. and McGauhey, P.H. (1970), Comprehensive Studies of
Solid Waste Management, US Department of Health, Education and Welfare, Public
Health Services Publication No. 2039.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(waste)
</code></pre>

<hr>
<h2 id='wine'>Wine data</h2><span id='topic+wine'></span>

<h3>Description</h3>

<p>It contains, for each of 59 wines grown in the same region in Italy, the quantities of 13
constituents. The original purpose of the analysis was to classify wines from different
cultivars by means of these measurements. In this example we treat cultivar one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(wine)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"data.frame"</code>.
</p>


<h3>Details</h3>

<p>Format: Numeric, 59 rows and 13 columns. Description: The attributes are:
1. Alcohol
2. Malic acid
3. Ash
4. Alcalinity of ash
5. Magnesium
6. Total phenols
7. Flavanoids
8. Nonflavanoid phenols
9. Proanthocyanins
10. Color intensity
11. Hue
12. OD280/OD315 of diluted wines
13. Proline
</p>


<h3>Source</h3>

<p>Hettich, S. and Bay, S.D. (1999), The UCI KDD Archive http://kdd.ics.uci.edu.
Irvine, CA: University of California, Department of Information and Computer Science.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(wine)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
