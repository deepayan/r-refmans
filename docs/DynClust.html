<!DOCTYPE html><html><head><title>Help for package DynClust</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DynClust}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#DynClust-package'><p>Denoising and clustering for dynamical image sequence (2D or 3D)+T</p></a></li>
<li><a href='#adu340_4small'><p>Calcium-imaging dataset using Fura-2</p></a></li>
<li><a href='#GetClusteringResults'><p>Get clustering step result</p></a></li>
<li><a href='#GetDenoisingResults'><p>Get denoising step result</p></a></li>
<li><a href='#MultiTestH0'><p>Statistical test of zero mean for dynamics</p></a></li>
<li><a href='#RunClustering'><p>Clustering of a dynamical image sequence</p></a></li>
<li><a href='#RunDenoising'><p>Denoising step of a dynamical image sequence</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Denoising and Clustering for Dynamical Image Sequence (2D or
3D)+t</td>
</tr>
<tr>
<td>Version:</td>
<td>3.24</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-04-11</td>
</tr>
<tr>
<td>Author:</td>
<td>Yves Rozenholc (UR7537, Univ. Paris Cit√©), Christophe Pouzat (IRMA, CNRS UMR 7501) and Tiffany Lieury (Cerebral Physiology lab, Univ. Paris Descartes)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yves Rozenholc &lt;yves.rozenholc@u-paris.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A two-stage procedure for the denoising and clustering of stack of noisy images acquired over time. Clustering only assumes that the data contain an unknown but small number of dynamic features. The method first denoises the signals using local spatial and full temporal information. The clustering step uses the previous output to aggregate voxels based on the knowledge of their spatial neighborhood. Both steps use a single keytool based on the statistical comparison of the difference of two signals with the null signal. No assumption is therefore required on the shape of the signals. The data are assumed to be normally distributed (or at least follow a symmetric distribution) with a known constant variance. Working pixelwise, the method can be time-consuming depending on the size of the data-array but harnesses the power of multicore cpus.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), parallel</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-04-11 09:58:03 UTC; rozen</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-04-11 12:12:33 UTC</td>
</tr>
</table>
<hr>
<h2 id='DynClust-package'>Denoising and clustering for dynamical image sequence (2D or 3D)+T</h2><span id='topic+DynClust-package'></span>

<h3>Description</h3>

<p>DynClust is a two-stage procedure for the denoising and
clustering of stack of noisy images acquired over time.
Clustering only assumes that the data contain an unknown
but small number of dynamic features. The method first
denoises the signals using local spatial and full temporal
information. The clustering step uses the previous output
to aggregate voxels based on the knowledge of their spatial
neighborhood. Both steps use a single keytool based on the
statistical comparison of the difference of two signals
with the null signal. No assumption is therefore required
on the shape of the signals. The data are assumed to be
normally distributed (or at least follow a symmetric
distribution) with a known constant variance. Working
pixelwise, the method can be time-consuming depending on
the size of the data-array but harnesses the power of
multicore cpus.
</p>


<h3>Author(s)</h3>

<p>Tiffany Lieury, Christophe Pouzat, Yves Rozenholc
</p>

<hr>
<h2 id='adu340_4small'>Calcium-imaging dataset using Fura-2</h2><span id='topic+adu340_4small'></span>

<h3>Description</h3>

<p>adu340_4small is the result from a calcium-buffering
experiment performed in a glomerulus of the Cockroach
(<em>Periplaneta americana</em>) antennal lobe, where the
projection neurons were imaged using Fura-2. Calcium
variations were measured through time and space at 340 nm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(adu340_4small)
</code></pre>


<h3>Format</h3>

<p>50x50x128 array of integers</p>


<h3>Author(s)</h3>

<p>Debora Fusca at Kloppenburg Lab &ndash;University of Cologne,
Germany
</p>

<hr>
<h2 id='GetClusteringResults'>Get clustering step result</h2><span id='topic+GetClusteringResults'></span>

<h3>Description</h3>

<p><code>GetClusteringResults</code> returns the results of the
clustering procedure <code>RunClustering</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetClusteringResults(data.array, res.listdenois, res.cluster)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetClusteringResults_+3A_data.array">data.array</code></td>
<td>
<p>a (2D or 3D)+T array containing the
original dynamic sequence of images (the dataset). The
last dimension is the time.</p>
</td></tr>
<tr><td><code id="GetClusteringResults_+3A_res.listdenois">res.listdenois</code></td>
<td>
<p>the list resulting from the
<code><a href="#topic+RunDenoising">RunDenoising</a></code> procedure applied to
<code>data.array</code>. This parameter may be replaced by the
component <code>info.den</code> of the former.</p>
</td></tr>
<tr><td><code id="GetClusteringResults_+3A_res.cluster">res.cluster</code></td>
<td>
<p>the list resulting from a call to
<code><a href="#topic+RunClustering">RunClustering</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing two components <code>clust.array</code> and
<code>clust.map</code>. <code>clust.array</code> is an array with same
dimension as the original sequence <code>data.array</code>
containing the clustered version. <code>clust.map</code> is an
array with only spatial dimensions of <code>data.array</code>
whose elements provide the cluster number at each location.
</p>


<h3>Author(s)</h3>

<p>Tiffany Lieury, Christophe Pouzat, Yves Rozenholc
</p>


<h3>References</h3>

<p>Rozenholc, Y. and Reiss, M. (2012) <em>Preserving time
structures while denoising a dynamical image</em>, Mathematical
Methods for Signal and Image Analysis and Representation
(Chapter 12), Florack, L. and Duits, R. and Jongbloed, G.
and van~Lieshout, M.-C. and Davies, L. Ed.,
Springer-Verlag, Berlin
</p>
<p>Lieury, T. and Pouzat, C. and Rozenholc, Y. (submitted)
<em>Spatial denoising and clustering of dynamical image
sequence: application to DCE imaging in medicine and
calcium imaging in neurons</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RunDenoising">RunDenoising</a></code>, <code><a href="#topic+RunClustering">RunClustering</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
    library(DynClust)
    
    ## use fluorescence calcium imaging of neurons performed with Fura 2 excited at 340 nm
    data('adu340_4small',package='DynClust')
    
    ## Gain of the CCD camera:
    G &lt;- 0.146
    ## readout variance of the CCD camera:
    sro2 &lt;- (16.4)^2
    ## Stabilization of the variance to get a normalized dataset (variance=1)
    FT &lt;- 2*sqrt(adu340_4small/G + sro2)
    FT.range = range(FT)
    
    ## launches the denoising step on the dataset with a statistical level of 5%
    FT.den.tmp &lt;- RunDenoising(FT,1,mask.size=NA,nproc=2)
    
    ## launches the clustering step on the dataset with a statistical level of 5%
    FT.clust.tmp  &lt;- RunClustering(FT,FT.den.tmp,nproc=2)
    n.cluster &lt;- length(FT.clust.tmp$clusters)
    print(paste(n.cluster,'clusters using variance set to',sqrt(FT.den.tmp$var),'^2'))
    
    ## get the classified version of the data array and the map of the clusters
    FT.clust.res &lt;- GetClusteringResults(FT,FT.den.tmp,FT.clust.tmp)
    
    ## plotting results of the clusterization
    par(mfrow=c(2,2))
    image(FT.clust.res$clust.map,col=rainbow(n.cluster))
    title('Cluster map')
    matplot(FT.clust.res$clust.center,col=rainbow(n.cluster),type="l",lwd=0.1,lty=1)
    title('Cluster centers')

    ## and more: original and clustered slices at time 50
    image(FT[,,50],zlim=FT.range,col=grey(seq(0,1,length=n.cluster)))
    title('Original sequence at time 50')
    image(FT.clust.res$clust.array[,,50],zlim=FT.range,col=grey(seq(0,1,length=n.cluster)))
    title('Clustered sequence at time 50')

    ####################################################################################
    ## reapply clustering with twice the nominal variance: forces stronger clustering ##
    ####################################################################################

    ## launches the denoising step on the dataset with a statistical level of 5%
    FT.den.tmp &lt;- RunDenoising(FT,2,mask.size=NA,nproc=2)

    ## launches the clustering step on the dataset with a statistical level of 5%
    FT.clust.tmp  &lt;- RunClustering(FT,FT.den.tmp,nproc=2)
    n.cluster &lt;- length(FT.clust.tmp$clusters)
    print(paste(n.cluster,'clusters using twice the nominal variance'))
    
    ## get the classified version of the data array and the map of the clusters
    FT.clust.res &lt;- GetClusteringResults(FT,FT.den.tmp,FT.clust.tmp)
    
    ## plotting results of the clusterization
    par(mfrow=c(2,2))
    image(FT.clust.res$clust.map,col=rainbow(n.cluster))
    title('Cluster map')
    matplot(FT.clust.res$clust.center,col=rainbow(n.cluster),type="l",lwd=0.1,lty=1)
    title('Cluster centers')

    ## and more: original and clustered slices at time 50
    image(FT[,,50],zlim=FT.range,col=grey(seq(0,1,length=n.cluster)))
    title('Original sequence at time 50')
    image(FT.clust.res$clust.array[,,50],zlim=FT.range,col=grey(seq(0,1,length=n.cluster)))
    title('Clustered sequence at time 50')

## End(Not run)
</code></pre>

<hr>
<h2 id='GetDenoisingResults'>Get denoising step result</h2><span id='topic+GetDenoisingResults'></span>

<h3>Description</h3>

<p><code>GetDenoisingResults</code> returns the denoised version of
a dynamical image sequence as an array having the same
dimensions as the original sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetDenoisingResults(data.array, res.listdenois)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetDenoisingResults_+3A_data.array">data.array</code></td>
<td>
<p>a (2D or 3D)+T array containing the
original dynamic sequence of images (the dataset). The
last dimension is the time.</p>
</td></tr>
<tr><td><code id="GetDenoisingResults_+3A_res.listdenois">res.listdenois</code></td>
<td>
<p>the list resulting from the
<code><a href="#topic+RunDenoising">RunDenoising</a></code> procedure applied to
<code>data.array</code>. This parameter may be replaced by the
component <code>info.den</code> of the former.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an array with same dimension as <code>data.array</code>
containing the denoised version.
</p>


<h3>Author(s)</h3>

<p>Tiffany Lieury, Christophe Pouzat, Yves Rozenholc
</p>


<h3>References</h3>

<p>Rozenholc, Y. and Reiss, M. (2012) <em>Preserving time
structures while denoising a dynamical image</em>, Mathematical
Methods for Signal and Image Analysis and Representation
(Chapter 12), Florack, L. and Duits, R. and Jongbloed, G.
and van~Lieshout, M.-C. and Davies, L. Ed.,
Springer-Verlag, Berlin
</p>
<p>Lieury, T. and Pouzat, C. and Rozenholc, Y. (submitted)
<em>Spatial denoising and clustering of dynamical image
sequence: application to DCE imaging in medicine and
calcium imaging in neurons</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RunDenoising">RunDenoising</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
    library(DynClust)

    ## use fluorescence calcium imaging of neurons performed with Fura 2 excited at 340 nm
    data('adu340_4small',package='DynClust')

    ## Gain of the CCD camera:
    G &lt;- 0.146
    ## readout variance of the CCD camera:
    sro2 &lt;- (16.4)^2
    ## Stabilization of the variance to get a normalized dataset (variance=1)
    FT &lt;- 2*sqrt(adu340_4small/G + sro2)
    FT.range = range(FT)

    ## launches the denoising step on the dataset with a statistical level of 5%
    FT.den.tmp &lt;- RunDenoising(FT,1,mask.size=NA,nproc=2)

    ## get the results of the denoising step
    FT.den.res &lt;- GetDenoisingResults(FT,FT.den.tmp)

    ## plot results at time 50 in same grey scale
    par(mfrow=c(1,3))
    image(FT[,,50],zlim=FT.range,col=gray(seq(0,1,l=128)))
    title('Original')
    image(FT.den.res[,,50],zlim=FT.range,col=gray(seq(0,1,l=128)))
    title('Denoised')
    image(FT.den.res[,,50]-FT[,,50],col=gray(seq(0,1,l=128)))
    title('Residuals')

## End(Not run)
</code></pre>

<hr>
<h2 id='MultiTestH0'>Statistical test of zero mean for dynamics</h2><span id='topic+MultiTestH0'></span>

<h3>Description</h3>

<p>MultiTestH0 tests if each column vectors of a matrix seen
as a noisy dynamic is of zero mean (<code class="reqn">H_0</code>) or not. The
multiple statistical test assumes known variance and is
based on a multiple <code class="reqn">\chi^2</code> test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MultiTestH0(proj.matrix, data.var, thrs = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MultiTestH0_+3A_proj.matrix">proj.matrix</code></td>
<td>
<p>a matrix whose colummns are tested to
have zero mean or not.</p>
</td></tr>
<tr><td><code id="MultiTestH0_+3A_data.var">data.var</code></td>
<td>
<p>a numeric providing the known variance</p>
</td></tr>
<tr><td><code id="MultiTestH0_+3A_thrs">thrs</code></td>
<td>
<p>a numeric vector of thresholds specified as
the <code class="reqn">1-\alpha</code> quantiles of the multiple test under
the null on each partition. If thrs=NULL (default) return
the global p-value which is the minimum of all p-values
obtained on each partition.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If thrs is provide returns a Boolean vector with length the
number of columns of proj.matrix. Element j is TRUE if the
null hypothesis (no difference with the null vector) is
accepted for column j of proj.matrix. Otherwise, return one
p-value per column.
</p>


<h3>Author(s)</h3>

<p>Tiffany Lieury, Christophe Pouzat, Yves Rozenholc
</p>


<h3>References</h3>

<p>Baraud Y., Huet S., Laurent B. <em>Ann. Stat.</em> (2003)
Durot C., Rozenholc Y. <em>Methods Math. Stat.</em> (2006)
</p>

<hr>
<h2 id='RunClustering'>Clustering of a dynamical image sequence</h2><span id='topic+RunClustering'></span>

<h3>Description</h3>

<p>Clusters dynamics of an image sequence. Assumes prior
sequence denoising.
</p>
<p>The clustering procedure is an iterative procedure. At each
step, the (available) children of the voxel associated to a
largest neighborhoods (result of the denoising step or made
of its children as a result of the getChildren function)
are used to build a robust cluster. The center of the
latter is compared to previously build ones using the
MultiTestH0 procedure. The clusters with equivalent centers
are merged together until no further merging are possible.
The resulting cluster is added to the cluster list if the
number of outliers generated by the robust cluster
procedure does not exceed the original number of children.
If not the voxel is added to the closest existing cluster.
</p>
<p>Further details about the clustering procedure can be found
in the references.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RunClustering(data.array, denois, nproc = 1, min.size = 1, alpha = 0.05,
  do.children.first = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RunClustering_+3A_data.array">data.array</code></td>
<td>
<p>a (2D or 3D)+T array containing the
dynamic sequence of images (the dataset). The last
dimension is the time.</p>
</td></tr>
<tr><td><code id="RunClustering_+3A_denois">denois</code></td>
<td>
<p>the result of the denoising procedure
RunDenoising.</p>
</td></tr>
<tr><td><code id="RunClustering_+3A_nproc">nproc</code></td>
<td>
<p>a numeric value indicating the number of
processors used for parallel computation. Default set to
1 (no parallelization).</p>
</td></tr>
<tr><td><code id="RunClustering_+3A_min.size">min.size</code></td>
<td>
<p>a numeric value indicating the smallest
size of the neighborhood for a voxel to be clusterized.
Default set to 1 (no limitation).</p>
</td></tr>
<tr><td><code id="RunClustering_+3A_alpha">alpha</code></td>
<td>
<p>a numeric value indicating the global level
of the multitest. Default set to 0.05.</p>
</td></tr>
<tr><td><code id="RunClustering_+3A_do.children.first">do.children.first</code></td>
<td>
<p>an boolean. If TRUE compute
children list for all voxels before starting the
clusterization which will use these lists as
neighborhoods.If FALSE (default) neighborhood are those
resulting from the denoising step.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing: </p>
 <ul>
<li> <p><code>cluster</code>, a list
of vectors&mdash;each vector contains the voxel indexes of one
cluster. </p>
</li>
<li> <p><code>centers</code>, a matrix whose columns
contain the average dynamics of each cluster. </p>
</li>
<li>
<p><code>bad.voxels</code>, vector of non clusterized voxel indexes.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Tiffany Lieury, Christophe Pouzat, Yves Rozenholc
</p>


<h3>References</h3>

<p>Rozenholc, Y. and Reiss, M. (2012) <em>Preserving time
structures while denoising a dynamical image</em>, Mathematical
Methods for Signal and Image Analysis and Representation
(Chapter 12), Florack, L. and Duits, R. and Jongbloed, G.
and van~Lieshout, M.-C. and Davies, L. Ed.,
Springer-Verlag, Berlin
</p>
<p>Lieury, T. and Pouzat, C. and Rozenholc, Y. (submitted)
<em>Spatial denoising and clustering of dynamical image
sequence: application to DCE imaging in medicine and
calcium imaging in neurons</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GetClusteringResults">GetClusteringResults</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
    library(DynClust)
    
    ## use fluorescence calcium imaging of neurons performed with Fura 2 excited at 340 nm
    data('adu340_4small',package='DynClust')
    
    ## Gain of the CCD camera:
    G &lt;- 0.146
    ## readout variance of the CCD camera:
    sro2 &lt;- (16.4)^2
    ## Stabilization of the variance to get a normalized dataset (variance=1)
    FT &lt;- 2*sqrt(adu340_4small/G + sro2)
    FT.range = range(FT)
    
    ## launches the denoising step on the dataset with a statistical level of 5%
    FT.den.tmp &lt;- RunDenoising(FT,1,mask.size=NA,nproc=2)
    
    ## launches the clustering step on the dataset with a statistical level of 5%
    FT.clust.tmp  &lt;- RunClustering(FT,FT.den.tmp,nproc=2)
    n.cluster &lt;- length(FT.clust.tmp$clusters)
    print(paste(n.cluster,'clusters using variance set to',sqrt(FT.den.tmp$var),'^2'))
    
    ## get the classified version of the data array and the map of the clusters
    FT.clust.res &lt;- GetClusteringResults(FT,FT.den.tmp,FT.clust.tmp)
    
    ## plotting results of the clusterization
    par(mfrow=c(2,2))
    image(FT.clust.res$clust.map,col=rainbow(n.cluster))
    title('Cluster map')
    matplot(FT.clust.res$clust.center,col=rainbow(n.cluster),type="l",lwd=0.1,lty=1)
    title('Cluster centers')

    ## and more: original and clustered slices at time 50
    image(FT[,,50],zlim=FT.range,col=grey(seq(0,1,length=n.cluster)))
    title('Original sequence at time 50')
    image(FT.clust.res$clust.array[,,50],zlim=FT.range,col=grey(seq(0,1,length=n.cluster)))
    title('Clustered sequence at time 50')

    ####################################################################################
    ## reapply clustering with twice the nominal variance: forces stronger clustering ##
    ####################################################################################

    ## launches the denoising step on the dataset with a statistical level of 5%
    FT.den.tmp &lt;- RunDenoising(FT,2,mask.size=NA,nproc=2)

    ## launches the clustering step on the dataset with a statistical level of 5%
    FT.clust.tmp  &lt;- RunClustering(FT,FT.den.tmp,nproc=2)
    n.cluster &lt;- length(FT.clust.tmp$clusters)
    print(paste(n.cluster,'clusters using twice the nominal variance'))
    
    ## get the classified version of the data array and the map of the clusters
    FT.clust.res &lt;- GetClusteringResults(FT,FT.den.tmp,FT.clust.tmp)
    
    ## plotting results of the clusterization
    par(mfrow=c(2,2))
    image(FT.clust.res$clust.map,col=rainbow(n.cluster))
    title('Cluster map')
    matplot(FT.clust.res$clust.center,col=rainbow(n.cluster),type="l",lwd=0.1,lty=1)
    title('Cluster centers')

    ## and more: original and clustered slices at time 50
    image(FT[,,50],zlim=FT.range,col=grey(seq(0,1,length=n.cluster)))
    title('Original sequence at time 50')
    image(FT.clust.res$clust.array[,,50],zlim=FT.range,col=grey(seq(0,1,length=n.cluster)))
    title('Clustered sequence at time 50')

## End(Not run)
</code></pre>

<hr>
<h2 id='RunDenoising'>Denoising step of a dynamical image sequence</h2><span id='topic+RunDenoising'></span>

<h3>Description</h3>

<p>Performs the denoising step of a dynamic sequence of
images. It is also the first step of the clustering.
</p>
<p>The denoising procedure is iteratively applied on each
voxel.
</p>
<p>The denoised version of Fx is obtained with a three stages
procedure: 1) Selection of time-homogeneous voxels in the
sub-mask around the voxel of interest; 2) Growth of spatial
neighborhoods made of time-homogeneous voxels obtained at
stage 1 with sizes growing geometrically&mdash;each neiborhood
is associated to a denoised version by averaging over its
members; 3) Selection of the largest spatial neighborhood
such that its associated denoised version is
time-homogeneous with all the previous ones.
</p>
<p>Time homogeneity is tested with function
<code>MultiTestH0</code>.
</p>
<p>Further details about the denoising method and the
statistical test of homogeneity can be found in the
references.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RunDenoising(data.array, data.var = 1, depth = 1, alpha = 0.05,
  mask.size = NA, nproc = 1, enhStart = ifelse(is.null(var), 2, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RunDenoising_+3A_data.array">data.array</code></td>
<td>
<p>a (2D or 3D)+T array containing the
dynamic sequence of images (the dataset). The last
dimension is the time.</p>
</td></tr>
<tr><td><code id="RunDenoising_+3A_data.var">data.var</code></td>
<td>
<p>a numeric indicating the variance of the
dataset (default 1). If set to NULL, the variance is
computed using a baseline image. See <code>enhStart</code>
parameter.</p>
</td></tr>
<tr><td><code id="RunDenoising_+3A_depth">depth</code></td>
<td>
<p>a numeric indicating the depth of a voxel.</p>
</td></tr>
<tr><td><code id="RunDenoising_+3A_alpha">alpha</code></td>
<td>
<p>a numeric value indicating the global level
of the multitest.</p>
</td></tr>
<tr><td><code id="RunDenoising_+3A_mask.size">mask.size</code></td>
<td>
<p>a vector indicating the size of the
spatial hypercube defined around voxels used to search
for neighbors.
</p>
<p>If NA (default):
sqrt(dim(data.array)[1:length(dim(data.array))-1]).
</p>
<p>If NULL (complete image):
dim(data.array)[1:length(dim(data.array))-1]</p>
</td></tr>
<tr><td><code id="RunDenoising_+3A_nproc">nproc</code></td>
<td>
<p>a numeric value indicating the number of
processors used for parallel computation.</p>
</td></tr>
<tr><td><code id="RunDenoising_+3A_enhstart">enhStart</code></td>
<td>
<p>an integer, if larger than 1, a baseline
is computed as a median image obtain from time indexes
between 1 and enhStart-1. Default value
<code>ifelse(is.null(var),2,1)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing: </p>
 <ul>
<li> <p><code>info.den</code>, a list
of list whose length is the number of voxels, each sub-list
contains the result of buildEstimate for one voxel. </p>
</li>
<li>
<p><code>data.proj</code>, the projections of the dynamics. a list
containing a denoised version of the dataset as an array,
as well as a list for which each element contains a list
with the voxel index, the indexes of its neighboors, the
resulting denoised signal, and the variance of the denoised
signal </p>
</li>
<li> <p><code>var</code>, a numeric providing the known
variance </p>
</li></ul>



<h3>Author(s)</h3>

<p>Tiffany Lieury, Christophe Pouzat, Yves Rozenholc
</p>


<h3>References</h3>

<p>Rozenholc, Y. and Reiss, M. (2012) <em>Preserving time
structures while denoising a dynamical image</em>, Mathematical
Methods for Signal and Image Analysis and Representation
(Chapter 12), Florack, L. and Duits, R. and Jongbloed, G.
and van~Lieshout, M.-C. and Davies, L. Ed.,
Springer-Verlag, Berlin
</p>
<p>Lieury, T. and Pouzat, C. and Rozenholc, Y. (submitted)
<em>Spatial denoising and clustering of dynamical image
sequence: application to DCE imaging in medicine and
calcium imaging in neurons</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GetDenoisingResults">GetDenoisingResults</a></code>,
<code><a href="#topic+MultiTestH0">MultiTestH0</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
    library(DynClust)

    ## use fluorescence calcium imaging of neurons performed with Fura 2 excited at 340 nm
    data('adu340_4small',package='DynClust')

    ## Gain of the CCD camera:
    G &lt;- 0.146
    ## readout variance of the CCD camera:
    sro2 &lt;- (16.4)^2
    ## Stabilization of the variance to get a normalized dataset (variance=1)
    FT &lt;- 2*sqrt(adu340_4small/G + sro2)
    FT.range = range(FT)

    ## launches the denoising step on the dataset with a statistical level of 5%
    FT.den.tmp &lt;- RunDenoising(FT,1,mask.size=NA,nproc=2)

    ## get the results of the denoising step
    FT.den.res &lt;- GetDenoisingResults(FT,FT.den.tmp)

    ## plot results at time 50 in same grey scale
    par(mfrow=c(1,3))
    image(FT[,,50],zlim=FT.range,col=gray(seq(0,1,l=128)))
    title('Original')
    image(FT.den.res[,,50],zlim=FT.range,col=gray(seq(0,1,l=128)))
    title('Denoised')
    image(FT.den.res[,,50]-FT[,,50],col=gray(seq(0,1,l=128)))
    title('Residuals')

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
