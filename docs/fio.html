<!DOCTYPE html><html lang="en-US"><head><title>Help for package fio</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fio}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#br_2020'><p>Brazil input-output matrix, year 2020, 51 sectors</p></a></li>
<li><a href='#fio_addin'><p>Conveniently import data from an Excel file</p></a></li>
<li><a href='#import_element'><p>Import IOM data</p></a></li>
<li><a href='#iom'><p>R6 class for input-output matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Friendly Input-Output Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Simplifies the process of importing and managing input-output
  matrices from 'Microsoft Excel' into R, and provides a suite of functions for
  analysis. It leverages the 'R6' class for clean, memory-efficient
  object-oriented programming. Furthermore, all linear algebra computations are
  implemented in 'Rust' to achieve highly optimized performance.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://albersonmiranda.github.io/fio/">https://albersonmiranda.github.io/fio/</a>,
<a href="https://github.com/albersonmiranda/fio">https://github.com/albersonmiranda/fio</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/albersonmiranda/fio/issues">https://github.com/albersonmiranda/fio/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>Cargo (Rust's package manager), rustc &gt;= 1.67.1, xz</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, clipr, emoji, fs, miniUI, readxl, rlang, shiny, Rdpack,
R6</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Config/rextendr/version:</td>
<td>0.3.1.9000</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, spelling, microbenchmark, leontief,
ggplot2, writexl, callr, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-08-26 03:56:16 UTC; albersonmiranda</td>
</tr>
<tr>
<td>Author:</td>
<td>Alberson da Silva Miranda
    <a href="https://orcid.org/0000-0001-9252-4175"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre,
    cph],
  Celso Bissoli Sessa
    <a href="https://orcid.org/0000-0001-7616-0244"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [dtc]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alberson da Silva Miranda &lt;albersonmiranda@hotmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-08-27 08:10:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='br_2020'>Brazil input-output matrix, year 2020, 51 sectors</h2><span id='topic+br_2020'></span>

<h3>Description</h3>

<p>This dataset contains the Brazilian input-output matrix for the year 2020, with 51 sectors.
The data is based on the Brazilian Institute of Geography and Statistics (IBGE) and
the Brazilian Institute of Applied Economic Research (IPEA).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>br_2020
</code></pre>


<h3>Format</h3>



<h4><code>br_2020</code></h4>

<p>A R6 class containing a set of matrices:
</p>

<dl>
<dt><code>id</code></dt><dd><p>Identifier of the new instance</p>
</dd>
<dt><code>intermediate_transactions</code></dt><dd><p>Intermediate transactions matrix.</p>
</dd>
<dt><code>total_production</code></dt><dd><p>Total production matrix.</p>
</dd>
<dt><code>final_demand</code></dt><dd><p>Final demand matrix.</p>
</dd>
<dt><code>exports</code></dt><dd><p>Exports matrix.</p>
</dd>
<dt><code>imports</code></dt><dd><p>Imports matrix.</p>
</dd>
<dt><code>taxes</code></dt><dd><p>Taxes matrix.</p>
</dd>
<dt><code>value_added</code></dt><dd><p>Value added matrix.</p>
</dd>
</dl>



<hr>
<h2 id='fio_addin'>Conveniently import data from an Excel file</h2><span id='topic+fio_addin'></span>

<h3>Description</h3>

<p><code>fio_addin()</code> opens an <a href="https://shiny.rstudio.com/articles/gadgets.html">RStudio gadget</a> and
<a href="https://rstudio.github.io/rstudioaddins/">addin</a> that allows you to say
where the data source is (either clipboard or Excel file) and import the
data into the global environment.
Appears as &quot;Import input-output data&quot; in the RStudio Addins menu.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fio_addin()
</code></pre>


<h3>References</h3>

<p>This function is based on the <a href="https://github.com/tidyverse/reprex">reprex</a> package.
</p>

<hr>
<h2 id='import_element'>Import IOM data</h2><span id='topic+import_element'></span>

<h3>Description</h3>

<p>Import data from a input-output matrix (IOM) from Excel format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import_element(file, sheet, range, col_names = FALSE, row_names = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="import_element_+3A_file">file</code></td>
<td>
<p>Path to the Excel file.</p>
</td></tr>
<tr><td><code id="import_element_+3A_sheet">sheet</code></td>
<td>
<p>Name of the sheet in the Excel file.</p>
</td></tr>
<tr><td><code id="import_element_+3A_range">range</code></td>
<td>
<p>Range of cells in the Excel file.</p>
</td></tr>
<tr><td><code id="import_element_+3A_col_names">col_names</code></td>
<td>
<p>Range of cells with column names.</p>
</td></tr>
<tr><td><code id="import_element_+3A_row_names">row_names</code></td>
<td>
<p>Range of cells with row names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A (<code>matrix</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Excel file with IOM data
path_to_xlsx &lt;- system.file("extdata", "iom/br/2020.xlsx", package = "fio")
# Import IOM data
intermediate_transactions = import_element(
  file = path_to_xlsx,
  sheet = "MIP",
  range = "D6:BB56",
  col_names = "D4:BB4",
  row_names = "B6:B56"
)
# Show the first 6 rows and 6 columns
intermediate_transactions[1:6, 1:6]
</code></pre>

<hr>
<h2 id='iom'>R6 class for input-output matrix</h2><span id='topic+iom'></span>

<h3>Description</h3>

<p>R6 class for input-output matrix.
</p>


<h3>Value</h3>

<p>A new instance of the <code>iom</code> class.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>id</code></dt><dd><p>(<code>character</code>)<br />
Identifier of the new instance.</p>
</dd>
<dt><code>intermediate_transactions</code></dt><dd><p>(<code>matrix</code>)<br />
Intermediate transactions matrix.</p>
</dd>
<dt><code>total_production</code></dt><dd><p>(<code>matrix</code>)<br />
Total production vector.</p>
</dd>
<dt><code>household_consumption</code></dt><dd><p>(<code>matrix</code>)<br />
Household consumption vector.</p>
</dd>
<dt><code>government_consumption</code></dt><dd><p>(<code>matrix</code>)<br />
Government consumption vector.</p>
</dd>
<dt><code>exports</code></dt><dd><p>(<code>matrix</code>)<br />
Exports vector.</p>
</dd>
<dt><code>final_demand_others</code></dt><dd><p>(<code>matrix</code>)<br />
Other vectors of final demand that doesn't have dedicated slots.</p>
</dd>
<dt><code>final_demand_matrix</code></dt><dd><p>(<code>matrix</code>)<br />
Aggregates final demand vectors into a matrix.</p>
</dd>
<dt><code>imports</code></dt><dd><p>(<code>matrix</code>)<br />
Imports vector.</p>
</dd>
<dt><code>taxes</code></dt><dd><p>(<code>matrix</code>)<br />
Taxes vector.</p>
</dd>
<dt><code>wages</code></dt><dd><p>(<code>matrix</code>)<br />
Wages vector.</p>
</dd>
<dt><code>operating_income</code></dt><dd><p>(<code>matrix</code>)<br />
Operating income vector.</p>
</dd>
<dt><code>value_added_others</code></dt><dd><p>(<code>matrix</code>)<br />
Other vectors of value-added that doesn't have dedicated slots.</p>
</dd>
<dt><code>value_added_matrix</code></dt><dd><p>(<code>matrix</code>)<br />
Aggregates value-added vectors into a matrix.</p>
</dd>
<dt><code>occupation</code></dt><dd><p>(<code>matrix</code>)<br />
Occupation vector.</p>
</dd>
<dt><code>technical_coefficients_matrix</code></dt><dd><p>(<code>matrix</code>)<br />
Technical coefficients matrix.</p>
</dd>
<dt><code>leontief_inverse_matrix</code></dt><dd><p>(<code>matrix</code>)<br />
Leontief inverse matrix.</p>
</dd>
<dt><code>multiplier_output</code></dt><dd><p>(<code>data.frame</code>)<br />
Output multiplier dataframe.</p>
</dd>
<dt><code>multiplier_employment</code></dt><dd><p>(<code>data.frame</code>)<br />
Employment multiplier dataframe.</p>
</dd>
<dt><code>multiplier_taxes</code></dt><dd><p>(<code>data.frame</code>)<br />
Taxes multiplier dataframe.</p>
</dd>
<dt><code>multiplier_wages</code></dt><dd><p>(<code>data.frame</code>)<br />
Wages multiplier dataframe.</p>
</dd>
<dt><code>field_influence</code></dt><dd><p>(<code>matrix</code>)<br />
Influence field matrix.</p>
</dd>
<dt><code>key_sectors</code></dt><dd><p>(<code>data.frame</code>)<br />
Key sectors dataframe.</p>
</dd>
<dt><code>allocation_coefficients_matrix</code></dt><dd><p>(<code>matrix</code>)<br />
Allocation coefficients matrix.</p>
</dd>
<dt><code>ghosh_inverse_matrix</code></dt><dd><p>(<code>matrix</code>)<br />
Ghosh inverse matrix.</p>
</dd>
<dt><code>hypothetical_extraction</code></dt><dd><p>(<code>matrix</code>)<br />
Absolute and relative backward and forward differences in total output after a hypothetical extraction</p>
</dd>
<dt><code>threads</code></dt><dd><p>(<code>integer</code>)<br />
Number of threads available for Rust to run in parallel</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-iom-new"><code>iom$new()</code></a>
</p>
</li>
<li> <p><a href="#method-iom-add"><code>iom$add()</code></a>
</p>
</li>
<li> <p><a href="#method-iom-remove"><code>iom$remove()</code></a>
</p>
</li>
<li> <p><a href="#method-iom-update_final_demand_matrix"><code>iom$update_final_demand_matrix()</code></a>
</p>
</li>
<li> <p><a href="#method-iom-update_value_added_matrix"><code>iom$update_value_added_matrix()</code></a>
</p>
</li>
<li> <p><a href="#method-iom-compute_tech_coeff"><code>iom$compute_tech_coeff()</code></a>
</p>
</li>
<li> <p><a href="#method-iom-compute_leontief_inverse"><code>iom$compute_leontief_inverse()</code></a>
</p>
</li>
<li> <p><a href="#method-iom-compute_multiplier_output"><code>iom$compute_multiplier_output()</code></a>
</p>
</li>
<li> <p><a href="#method-iom-compute_multiplier_employment"><code>iom$compute_multiplier_employment()</code></a>
</p>
</li>
<li> <p><a href="#method-iom-compute_multiplier_wages"><code>iom$compute_multiplier_wages()</code></a>
</p>
</li>
<li> <p><a href="#method-iom-compute_multiplier_taxes"><code>iom$compute_multiplier_taxes()</code></a>
</p>
</li>
<li> <p><a href="#method-iom-compute_field_influence"><code>iom$compute_field_influence()</code></a>
</p>
</li>
<li> <p><a href="#method-iom-compute_key_sectors"><code>iom$compute_key_sectors()</code></a>
</p>
</li>
<li> <p><a href="#method-iom-compute_allocation_coeff"><code>iom$compute_allocation_coeff()</code></a>
</p>
</li>
<li> <p><a href="#method-iom-compute_ghosh_inverse"><code>iom$compute_ghosh_inverse()</code></a>
</p>
</li>
<li> <p><a href="#method-iom-compute_hypothetical_extraction"><code>iom$compute_hypothetical_extraction()</code></a>
</p>
</li>
<li> <p><a href="#method-iom-set_max_threads"><code>iom$set_max_threads()</code></a>
</p>
</li>
<li> <p><a href="#method-iom-clone"><code>iom$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-iom-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>iom$new(
  id,
  intermediate_transactions,
  total_production,
  household_consumption = NULL,
  government_consumption = NULL,
  exports = NULL,
  final_demand_others = NULL,
  imports = NULL,
  taxes = NULL,
  wages = NULL,
  operating_income = NULL,
  value_added_others = NULL,
  occupation = NULL,
  threads = 0
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>(<code>character</code>)<br />
Identifier for the input-output matrix.</p>
</dd>
<dt><code>intermediate_transactions</code></dt><dd><p>(<code>matrix</code>)<br />
Intermediate transactions matrix.</p>
</dd>
<dt><code>total_production</code></dt><dd><p>(<code>matrix</code>)<br />
Total production vector.</p>
</dd>
<dt><code>household_consumption</code></dt><dd><p>(<code>matrix</code>)<br />
Household consumption vector.</p>
</dd>
<dt><code>government_consumption</code></dt><dd><p>(<code>matrix</code>)<br />
Government consumption vector.</p>
</dd>
<dt><code>exports</code></dt><dd><p>(<code>matrix</code>)<br />
Exports vector.</p>
</dd>
<dt><code>final_demand_others</code></dt><dd><p>(<code>matrix</code>)<br />
Other vectors of final demand that doesn't have dedicated slots.
Setting column names is advised for better readability.</p>
</dd>
<dt><code>imports</code></dt><dd><p>(<code>matrix</code>)<br />
Imports vector.</p>
</dd>
<dt><code>taxes</code></dt><dd><p>(<code>matrix</code>)<br />
Taxes vector.</p>
</dd>
<dt><code>wages</code></dt><dd><p>(<code>matrix</code>)<br />
Wages vector.</p>
</dd>
<dt><code>operating_income</code></dt><dd><p>(<code>matrix</code>)<br />
Operating income vector.</p>
</dd>
<dt><code>value_added_others</code></dt><dd><p>(<code>matrix</code>)<br />
Other vectors of value-added that doesn't have dedicated slots.
Setting row names is advised for better readability.</p>
</dd>
<dt><code>occupation</code></dt><dd><p>(<code>matrix</code>)<br />
Occupation matrix.</p>
</dd>
<dt><code>threads</code></dt><dd><p>(<code>integer</code>)<br />
Number of threads available for Rust to run in parallel.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-iom-add"></a>



<h4>Method <code>add()</code></h4>

<p>Adds a <code>matrix</code> to the <code>iom</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>iom$add(matrix_name, matrix)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>matrix_name</code></dt><dd><p>(<code>character</code>)<br />
One of household_consumption, government_consumption, exports, final_demand_others,
imports, taxes, wages, operating income, value_added_others or occupation matrix to be added.</p>
</dd>
<dt><code>matrix</code></dt><dd><p>(<code>matrix</code>)<br />
Matrix object to be added.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Self (invisibly).
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># data
intermediate_transactions &lt;- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), 3, 3)
total_production &lt;- matrix(c(100, 200, 300), 1, 3)
# instantiate iom object
my_iom &lt;- iom$new("mock", intermediate_transactions, total_production)
# Create a dummy matrix
exports_data &lt;- matrix(as.numeric(1:3), 3, 1)
# Add the matrix
my_iom$add("exports", exports_data)
</pre>
</div>


<hr>
<a id="method-iom-remove"></a>



<h4>Method <code>remove()</code></h4>

<p>Removes a <code>matrix</code> from the <code>iom</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>iom$remove(matrix_name)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>matrix_name</code></dt><dd><p>(<code>character</code>)<br />
One of household_consumption, government_consumption, exports, final_demand_others,
imports, taxes, wages, operating_income, value_added_others or occupation matrix to be removed.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Self (invisibly).
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># data
intermediate_transactions &lt;- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), 3, 3)
total_production &lt;- matrix(c(100, 200, 300), 1, 3)
 exports_data &lt;- matrix(as.numeric(1:3), 3, 1)
# instantiate iom object
my_iom &lt;- iom$new("mock", intermediate_transactions, total_production, exports = exports_data)
# Remove the matrix
my_iom$remove("exports")
</pre>
</div>


<hr>
<a id="method-iom-update_final_demand_matrix"></a>



<h4>Method <code>update_final_demand_matrix()</code></h4>

<p>Aggregates final demand vectors into the <code>final_demand_matrix</code> field.
</p>


<h5>Usage</h5>

<div class="r"><pre>iom$update_final_demand_matrix()</pre></div>



<h5>Details</h5>

<p>Some methods, as <code style="white-space: pre;">&#8288;$compute_hypothetical_extraction()&#8288;</code>, require the final demand and value-added vectors
to be aggregated into a matrix. This method does this aggregation, binding the vectors into
<code style="white-space: pre;">&#8288;$final_demand_matrix&#8288;</code>.
</p>



<h5>Returns</h5>

<p>This functions doesn't returns a value.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># data
intermediate_transactions &lt;- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), 3, 3)
total_production &lt;- matrix(c(100, 200, 300), 1, 3)
exports_data &lt;- matrix(c(10, 20, 30), 3, 1)
households &lt;- matrix(as.numeric(4:6), 3, 1)
# instantiate iom object
my_iom &lt;- iom$new(
 "mock",
 intermediate_transactions,
 total_production,
 exports = exports_data,
 household_consumption = households
)
# aggregate all final demand vectors
my_iom$update_final_demand_matrix()
# check final demand matrix
my_iom$final_demand_matrix
</pre>
</div>


<hr>
<a id="method-iom-update_value_added_matrix"></a>



<h4>Method <code>update_value_added_matrix()</code></h4>

<p>Aggregates value-added vectors into the <code>value_added_matrix</code> field.
</p>


<h5>Usage</h5>

<div class="r"><pre>iom$update_value_added_matrix()</pre></div>



<h5>Details</h5>

<p>Some methods, as <code style="white-space: pre;">&#8288;$compute_hypothetical_extraction()&#8288;</code>, require the final demand and value-added vectors
to be aggregated into a matrix. This method does this aggregation, binding the vectors into
<code style="white-space: pre;">&#8288;$value_added_matrix&#8288;</code>.
</p>



<h5>Returns</h5>

<p>This functions doesn't returns a value.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># data
intermediate_transactions &lt;- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), 3, 3)
total_production &lt;- matrix(c(100, 200, 300), 1, 3)
imports_data &lt;- matrix(c(5, 10, 15), 1, 3)
taxes_data &lt;- matrix(c(2, 5, 10), 1, 3)
# instantiate iom object
my_iom &lt;- iom$new(
"mock",
intermediate_transactions,
total_production,
imports = imports_data,
taxes = taxes_data
)
# aggregate all value-added vectors
my_iom$update_value_added_matrix()
# check value-added matrix
my_iom$value_added_matrix
</pre>
</div>


<hr>
<a id="method-iom-compute_tech_coeff"></a>



<h4>Method <code>compute_tech_coeff()</code></h4>

<p>Computes the technical coefficients matrix and populate the <code>technical_coefficients_matrix</code> field with the
resulting <code>(matrix)</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>iom$compute_tech_coeff()</pre></div>



<h5>Details</h5>

<p>It computes the technical coefficients matrix, a <code class="reqn">n x n</code> matrix known as <code>A</code> matrix which is the column-wise
ratio of intermediate transactions to total production (Leontief 1983).
</p>



<h5>Returns</h5>

<p>Self (invisibly).
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>intermediate_transactions &lt;- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), 3, 3)
total_production &lt;- matrix(c(100, 200, 300), 1, 3)
# instantiate iom object
my_iom &lt;- iom$new("test", intermediate_transactions, total_production)
# Calculate the technical coefficients
my_iom$compute_tech_coeff()
# show the technical coefficients
my_iom$technical_coefficients_matrix
</pre>
</div>


<hr>
<a id="method-iom-compute_leontief_inverse"></a>



<h4>Method <code>compute_leontief_inverse()</code></h4>

<p>Computes the Leontief inverse matrix and populate the <code>leontief_inverse_matrix</code> field with the resulting
<code>(matrix)</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>iom$compute_leontief_inverse()</pre></div>



<h5>Details</h5>

<p>It computes the Leontief inverse matrix (Leontief 1983), which is the inverse of the
Leontief matrix, defined as:
</p>
<p style="text-align: center;"><code class="reqn">L = I - A</code>
</p>

<p>where I is the identity matrix and A is the technical coefficients matrix.
The Leontief inverse matrix is calculated by solving the following equation:
</p>
<p style="text-align: center;"><code class="reqn">L^{-1} = (I - A)^{-1}</code>
</p>

<p>Since the Leontief matrix is a square matrix and the subtraction of the technical coefficients matrix from the
identity matrix guarantees that the Leontief matrix is invertible, underlined Rust function uses LU decomposition
to solve the equation.
</p>



<h5>Returns</h5>

<p>Self (invisibly).
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>intermediate_transactions &lt;- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), 3, 3)
total_production &lt;- matrix(c(100, 200, 300), 1, 3)
# instantiate iom object
my_iom &lt;- fio::iom$new("test", intermediate_transactions, total_production)
# calculate the technical coefficients
my_iom$compute_tech_coeff()
# calculate the Leontief inverse
my_iom$compute_leontief_inverse()
# show the Leontief inverse
my_iom$leontief_inverse_matrix
</pre>
</div>


<hr>
<a id="method-iom-compute_multiplier_output"></a>



<h4>Method <code>compute_multiplier_output()</code></h4>

<p>Computes the output multiplier and populate the <code>multiplier_output</code> field with the resulting <code>(data.frame)</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>iom$compute_multiplier_output()</pre></div>



<h5>Details</h5>

<p>An output multiplier for sector <em>j</em> is defined as the total value of production in all sectors of the economy
that is necessary in order to satisfy a monetary unit (e.g., a dollar) worth of final demand for sector <em>j</em>'s
output (Miller and Blair 2009).
</p>
<p>This method computes the simple output multiplier, defined as the column sums of the Leontief inverse matrix,
the direct and indirect output multipliers, which are the column sums of the technical
coefficients matrix and the difference between total and direct output multipliers, respectively
(Vale and Perobelli 2020).
</p>



<h5>Returns</h5>

<p>Self (invisibly).
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># data
intermediate_transactions &lt;- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), 3, 3)
total_production &lt;- matrix(c(100, 200, 300), 1, 3)
# instantiate iom object
my_iom &lt;- fio::iom$new("test", intermediate_transactions, total_production)
# calculate the technical coefficients
my_iom$compute_tech_coeff()
# calculate the Leontief inverse
my_iom$compute_leontief_inverse()
# calculate the output multiplier
my_iom$compute_multiplier_output()
# show the output multiplier
my_iom$multiplier_output
</pre>
</div>


<hr>
<a id="method-iom-compute_multiplier_employment"></a>



<h4>Method <code>compute_multiplier_employment()</code></h4>

<p>Computes the employment multiplier and populate the <code>multiplier_employment</code> field with the resulting
<code>(data.frame)</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>iom$compute_multiplier_employment()</pre></div>



<h5>Details</h5>

<p>The employment multiplier for sector <em>j</em> relates the jobs created in each sector in response to a
initial exogenous shock (Miller and Blair 2009).
</p>
<p>Current implementation follows (Vale and Perobelli 2020).
</p>



<h5>Returns</h5>

<p>Self (invisibly).
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># data
intermediate_transactions &lt;- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), 3, 3)
total_production &lt;- matrix(c(100, 200, 300), 1, 3)
jobs_data &lt;- matrix(c(10, 12, 15), 1, 3)
# instantiate iom object
my_iom &lt;- fio::iom$new("test", intermediate_transactions, total_production, occupation = jobs_data)
# calculate the technical coefficients
my_iom$compute_tech_coeff()
# calculate the Leontief inverse
my_iom$compute_leontief_inverse()
# calculate the employment multiplier
my_iom$compute_multiplier_employment()
# show the employment multiplier
my_iom$multiplier_employment
</pre>
</div>


<hr>
<a id="method-iom-compute_multiplier_wages"></a>



<h4>Method <code>compute_multiplier_wages()</code></h4>

<p>Computes the wages multiplier dataframe and populate the <code>multiplier_wages</code> field with the resulting
<code>(data.frame)</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>iom$compute_multiplier_wages()</pre></div>



<h5>Details</h5>

<p>The wages multiplier for sector <em>j</em> relates increases in wages for each
sector in response to a initial exogenous shock
(Miller and Blair 2009).
</p>
<p>Current implementation follows (Vale and Perobelli 2020).
</p>



<h5>Returns</h5>

<p>Self (invisibly).
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># data
intermediate_transactions &lt;- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), 3, 3)
total_production &lt;- matrix(c(100, 200, 300), 1, 3)
wages_data &lt;- matrix(c(10, 12, 15), 1, 3)
# instantiate iom object
my_iom &lt;- fio::iom$new("test", intermediate_transactions, total_production, wages = wages_data)
# calculate the technical coefficients
my_iom$compute_tech_coeff()
# calculate the Leontief inverse
my_iom$compute_leontief_inverse()
# calculate the wages multiplier
my_iom$compute_multiplier_wages()
# show the wages multiplier
my_iom$multiplier_wages
</pre>
</div>


<hr>
<a id="method-iom-compute_multiplier_taxes"></a>



<h4>Method <code>compute_multiplier_taxes()</code></h4>

<p>Computes the taxes multiplier and populate the <code>multiplier_taxes</code> field with
the resulting <code>(data.frame)</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>iom$compute_multiplier_taxes()</pre></div>



<h5>Details</h5>

<p>The taxes multiplier for sector <em>j</em> relates the increases on tax revenue from
each sector in response to a initial exogenous shock
(Miller and Blair 2009).
</p>
<p>Current implementation follows (Vale and Perobelli 2020).
</p>



<h5>Returns</h5>

<p>Self (invisibly).
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># data
intermediate_transactions &lt;- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), 3, 3)
total_production &lt;- matrix(c(100, 200, 300), 1, 3)
tax_data &lt;- matrix(c(10, 12, 15), 1, 3)
# instantiate iom object
my_iom &lt;- fio::iom$new("test", intermediate_transactions, total_production, taxes = tax_data)
# calculate the technical coefficients
my_iom$compute_tech_coeff()
# calculate the Leontief inverse
my_iom$compute_leontief_inverse()
# calculate the tax multiplier
my_iom$compute_multiplier_taxes()
# show the taxes multiplier
my_iom$multiplier_taxes
</pre>
</div>


<hr>
<a id="method-iom-compute_field_influence"></a>



<h4>Method <code>compute_field_influence()</code></h4>

<p>Computes the field of influence for all sectors and populate the
<code>field_influence</code> field with the resulting <code>(matrix)</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>iom$compute_field_influence(epsilon)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>epsilon</code></dt><dd><p>(<code>numeric</code>)<br />
Epsilon value. A technical change in the input-output matrix, caused by a variation of size <code>epsilon</code> into each
element of technical coefficients matrix.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>The field of influence shows how changes in direct coefficients are
distributed throughout the entire economic system, allowing for the
determination of which relationships between sectors are most important
within the production process.
</p>
<p>It determines which sectors have the greatest influence over others,
specifically, which coefficients, when altered, would have the greatest
impact on the system as a whole (Vale and Perobelli 2020).
</p>



<h5>Returns</h5>

<p>Self (invisibly).
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># data
intermediate_transactions &lt;- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), 3, 3)
total_production &lt;- matrix(c(100, 200, 300), 1, 3)
# instantiate iom object
my_iom &lt;- fio::iom$new("test", intermediate_transactions, total_production)
# calculate the technical coefficients
my_iom$compute_tech_coeff()
# calculate the Leontief inverse
my_iom$compute_leontief_inverse()
# calculate field of influence
my_iom$compute_field_influence(epsilon = 0.01)
# show the field of influence
my_iom$field_influence
</pre>
</div>


<hr>
<a id="method-iom-compute_key_sectors"></a>



<h4>Method <code>compute_key_sectors()</code></h4>

<p>Computes the key sectors dataframe, based on it's power and sensitivity of dispersion,
and populate the <code>key_sectors</code> field with the resulting <code>(data.frame)</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>iom$compute_key_sectors()</pre></div>



<h5>Details</h5>

<p>Increased production from a sector <em>j</em> means that the sector <em>j</em> will need to
purchase more goods from other sectors. At the same time, it means that more goods from sector <em>j</em> will be
available for other sectors to purchase. Sectors that are above average in the demand sense (stronger backward
linkage) have power of dispersion indices greater than 1. Sectors that are above average in the supply sense
(stronger forward linkage) have sensitivity of dispersion indices greater than 1
(Miller and Blair 2009).
</p>
<p>As both power and sensitivity of dispersion are related to average values on the economy, coefficients of
variation are also calculated for both indices. The lesser the coefficient of variation, greater the number of
sectors on the demand or supply structure of that sector (Vale and Perobelli 2020).
</p>



<h5>Returns</h5>

<p>Self (invisibly).
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># data
intermediate_transactions &lt;- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), 3, 3)
total_production &lt;- matrix(c(100, 200, 300), 1, 3)
# instantiate iom object
my_iom &lt;- fio::iom$new("test", intermediate_transactions, total_production)
# calculate the technical coefficients
my_iom$compute_tech_coeff()
# calculate the Leontief inverse
my_iom$compute_leontief_inverse()
# calculate key sectors
my_iom$compute_key_sectors()
# show the key sectors
my_iom$key_sectors
</pre>
</div>


<hr>
<a id="method-iom-compute_allocation_coeff"></a>



<h4>Method <code>compute_allocation_coeff()</code></h4>

<p>Computes the allocation coefficients matrix and populate the <code>allocation_coefficients_matrix</code> field with the
resulting <code>(matrix)</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>iom$compute_allocation_coeff()</pre></div>



<h5>Details</h5>

<p>It computes the allocation coefficients matrix, a <code class="reqn">n x n</code> matrix known as <code>B</code> matrix which is the row-wise
ratio of intermediate transactions to total production (Miller and Blair 2009).
</p>



<h5>Returns</h5>

<p>Self (invisibly).
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>intermediate_transactions &lt;- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), 3, 3)
total_production &lt;- matrix(c(100, 200, 300), 1, 3)
# instantiate iom object
my_iom &lt;- fio::iom$new("test", intermediate_transactions, total_production)
# Calculate the allocation coefficients
my_iom$compute_allocation_coeff()
# show the allocation coefficients
my_iom$allocation_coefficients_matrix
</pre>
</div>


<hr>
<a id="method-iom-compute_ghosh_inverse"></a>



<h4>Method <code>compute_ghosh_inverse()</code></h4>

<p>Computes the Ghosh inverse matrix and populate the <code>ghosh_inverse_matrix</code> field with the resulting <code>(matrix)</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>iom$compute_ghosh_inverse()</pre></div>



<h5>Details</h5>

<p>It computes the Ghosh inverse matrix (Miller and Blair 2009), defined as:
</p>
<p style="text-align: center;"><code class="reqn">G = (I - B)^{-1}</code>
</p>

<p>where I is the identity matrix and B is the allocation coefficients matrix.
</p>



<h5>Returns</h5>

<p>Self (invisibly).
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>intermediate_transactions &lt;- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), 3, 3)
total_production &lt;- matrix(c(100, 200, 300), 1, 3)
# instantiate iom object
my_iom &lt;- fio::iom$new("test", intermediate_transactions, total_production)
# Calculate the allocation coefficients
my_iom$compute_allocation_coeff()
# Calculate the Ghosh inverse
my_iom$compute_ghosh_inverse()
# show the Ghosh inverse
my_iom$ghosh_inverse_matrix
</pre>
</div>


<hr>
<a id="method-iom-compute_hypothetical_extraction"></a>



<h4>Method <code>compute_hypothetical_extraction()</code></h4>

<p>Computes total impact after extracting a each sector and populate the <code>hypothetical_extraction</code> field with the
resulting <code>(data.frame)</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>iom$compute_hypothetical_extraction()</pre></div>



<h5>Details</h5>

<p>Computes impact on demand and supply structures after extracting each
sector (Miller and Blair 2009).
</p>
<p>The total impact is calculated by the sum of the direct and indirect impacts.
</p>



<h5>Returns</h5>

<p>Self (invisibly).
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre># data
intermediate_transactions &lt;- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), 3, 3)
total_production &lt;- matrix(c(100, 200, 300), 1, 3)
exports_data &lt;- matrix(c(5, 10, 15), 3, 1)
holsehold_consumption_data &lt;- matrix(c(20, 25, 30), 3, 1)
operating_income_data &lt;- matrix(c(2, 5, 10), 1, 3)
taxes_data &lt;- matrix(c(1, 2, 3), 1, 3)
# instantiate iom object
my_iom &lt;- fio::iom$new(
 "test",
 intermediate_transactions,
 total_production,
 exports = exports_data,
 household_consumption = holsehold_consumption_data,
 operating_income = operating_income_data,
 taxes = taxes_data
)
# update value-added matrix
my_iom$update_value_added_matrix()
# update final demand matrix
my_iom$update_final_demand_matrix()
# calculate the technical coefficients
my_iom$compute_tech_coeff()
# calculate the Leontief inverse
my_iom$compute_leontief_inverse()
# calculate allocation coefficients
my_iom$compute_allocation_coeff()
# calculate Ghosh inverse
my_iom$compute_ghosh_inverse()
# calculate hypothetical extraction
my_iom$compute_hypothetical_extraction()
# show results
my_iom$hypothetical_extraction
</pre>
</div>


<hr>
<a id="method-iom-set_max_threads"></a>



<h4>Method <code>set_max_threads()</code></h4>

<p>Sets max number of threads used by fio and populate the <code>threads</code> field with the resulting <code>(integer)</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>iom$set_max_threads(max_threads)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>max_threads</code></dt><dd><p>(<code>integer</code>)<br />
Number of threads enabled for parallel computing. Defaults to 0, meaning all
threads available.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Calling this function sets a global limit of threads to Rayon crate, affecting
all computations that runs in parallel by default.
</p>
<p>Default behavior of Rayon is to use all available threads (including logical). Setting to 1 will result in
single threaded (sequential) computations.
</p>
<p>Initialization of the global thread pool happens exactly once. Once started, the configuration cannot be changed
in the current session. If <code style="white-space: pre;">&#8288;$set_max_threads()&#8288;</code> is called again in the same session, it'll result in an error.
</p>
<p>Methods that deals with linear algebra computations, like <code style="white-space: pre;">&#8288;$compute_leontief_inverse()&#8288;</code> and
<code style="white-space: pre;">&#8288;$compute_ghosh_inverse()&#8288;</code>, will try to use all available threads by default, so they also initializes global
thread pool. In order to choose a maximum number of threads other than default, <code style="white-space: pre;">&#8288;$set_max_threads()&#8288;</code> must be
called before any computation, preferably right after <code>iom$new()</code>.
</p>



<h5>Returns</h5>

<p>This function does not return a value.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>intermediate_transactions &lt;- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), 3, 3)
total_production &lt;- matrix(c(100, 200, 300), 1, 3)
# instantiate iom object
my_iom &lt;- fio::iom$new("test", intermediate_transactions, total_production)
# to run single threaded (sequential)
my_iom$set_max_threads(1L)
my_iom$threads
</pre>
</div>


<hr>
<a id="method-iom-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>iom$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>There are no references for Rd macro <code style="white-space: pre;">&#8288;\insertAllCites&#8288;</code> on this help page.
</p>
<p>There are no references for Rd macro <code style="white-space: pre;">&#8288;\insertAllCites&#8288;</code> on this help page.
</p>
<p>There are no references for Rd macro <code style="white-space: pre;">&#8288;\insertAllCites&#8288;</code> on this help page.
</p>
<p>There are no references for Rd macro <code style="white-space: pre;">&#8288;\insertAllCites&#8288;</code> on this help page.
</p>
<p>There are no references for Rd macro <code style="white-space: pre;">&#8288;\insertAllCites&#8288;</code> on this help page.
</p>
<p>There are no references for Rd macro <code style="white-space: pre;">&#8288;\insertAllCites&#8288;</code> on this help page.
</p>
<p>There are no references for Rd macro <code style="white-space: pre;">&#8288;\insertAllCites&#8288;</code> on this help page.
</p>
<p>There are no references for Rd macro <code style="white-space: pre;">&#8288;\insertAllCites&#8288;</code> on this help page.
</p>
<p>There are no references for Rd macro <code style="white-space: pre;">&#8288;\insertAllCites&#8288;</code> on this help page.
</p>
<p>There are no references for Rd macro <code style="white-space: pre;">&#8288;\insertAllCites&#8288;</code> on this help page.
</p>
<p>There are no references for Rd macro <code style="white-space: pre;">&#8288;\insertAllCites&#8288;</code> on this help page.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># data
intermediate_transactions &lt;- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), 3, 3)
total_production &lt;- matrix(c(100, 200, 300), 1, 3)
exports &lt;- matrix(c(10, 20, 30), 3, 1)
households &lt;- matrix(as.numeric(4:6), 3, 1)
imports &lt;- matrix(c(5, 10, 15), 1, 3)
jobs &lt;- matrix(c(10, 12, 15), 1, 3)
taxes &lt;- matrix(c(2, 5, 10), 1, 3)
wages &lt;- matrix(c(11, 12, 13), 1, 3)

# a new iom instance can be created by passing just intermediate transactions and total production
my_iom &lt;- iom$new(
 "example_1",
 intermediate_transactions,
 total_production
)

# or by passing optional arguments
my_iom &lt;- iom$new(
"example_2",
intermediate_transactions,
total_production,
household_consumption = households,
exports = exports,
imports = imports,
taxes = taxes,
wages = wages,
occupation = jobs
)


## ------------------------------------------------
## Method `iom$add`
## ------------------------------------------------

# data
intermediate_transactions &lt;- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), 3, 3)
total_production &lt;- matrix(c(100, 200, 300), 1, 3)
# instantiate iom object
my_iom &lt;- iom$new("mock", intermediate_transactions, total_production)
# Create a dummy matrix
exports_data &lt;- matrix(as.numeric(1:3), 3, 1)
# Add the matrix
my_iom$add("exports", exports_data)

## ------------------------------------------------
## Method `iom$remove`
## ------------------------------------------------

# data
intermediate_transactions &lt;- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), 3, 3)
total_production &lt;- matrix(c(100, 200, 300), 1, 3)
 exports_data &lt;- matrix(as.numeric(1:3), 3, 1)
# instantiate iom object
my_iom &lt;- iom$new("mock", intermediate_transactions, total_production, exports = exports_data)
# Remove the matrix
my_iom$remove("exports")

## ------------------------------------------------
## Method `iom$update_final_demand_matrix`
## ------------------------------------------------

# data
intermediate_transactions &lt;- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), 3, 3)
total_production &lt;- matrix(c(100, 200, 300), 1, 3)
exports_data &lt;- matrix(c(10, 20, 30), 3, 1)
households &lt;- matrix(as.numeric(4:6), 3, 1)
# instantiate iom object
my_iom &lt;- iom$new(
 "mock",
 intermediate_transactions,
 total_production,
 exports = exports_data,
 household_consumption = households
)
# aggregate all final demand vectors
my_iom$update_final_demand_matrix()
# check final demand matrix
my_iom$final_demand_matrix

## ------------------------------------------------
## Method `iom$update_value_added_matrix`
## ------------------------------------------------

# data
intermediate_transactions &lt;- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), 3, 3)
total_production &lt;- matrix(c(100, 200, 300), 1, 3)
imports_data &lt;- matrix(c(5, 10, 15), 1, 3)
taxes_data &lt;- matrix(c(2, 5, 10), 1, 3)
# instantiate iom object
my_iom &lt;- iom$new(
"mock",
intermediate_transactions,
total_production,
imports = imports_data,
taxes = taxes_data
)
# aggregate all value-added vectors
my_iom$update_value_added_matrix()
# check value-added matrix
my_iom$value_added_matrix

## ------------------------------------------------
## Method `iom$compute_tech_coeff`
## ------------------------------------------------

intermediate_transactions &lt;- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), 3, 3)
total_production &lt;- matrix(c(100, 200, 300), 1, 3)
# instantiate iom object
my_iom &lt;- iom$new("test", intermediate_transactions, total_production)
# Calculate the technical coefficients
my_iom$compute_tech_coeff()
# show the technical coefficients
my_iom$technical_coefficients_matrix

## ------------------------------------------------
## Method `iom$compute_leontief_inverse`
## ------------------------------------------------

intermediate_transactions &lt;- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), 3, 3)
total_production &lt;- matrix(c(100, 200, 300), 1, 3)
# instantiate iom object
my_iom &lt;- fio::iom$new("test", intermediate_transactions, total_production)
# calculate the technical coefficients
my_iom$compute_tech_coeff()
# calculate the Leontief inverse
my_iom$compute_leontief_inverse()
# show the Leontief inverse
my_iom$leontief_inverse_matrix

## ------------------------------------------------
## Method `iom$compute_multiplier_output`
## ------------------------------------------------

# data
intermediate_transactions &lt;- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), 3, 3)
total_production &lt;- matrix(c(100, 200, 300), 1, 3)
# instantiate iom object
my_iom &lt;- fio::iom$new("test", intermediate_transactions, total_production)
# calculate the technical coefficients
my_iom$compute_tech_coeff()
# calculate the Leontief inverse
my_iom$compute_leontief_inverse()
# calculate the output multiplier
my_iom$compute_multiplier_output()
# show the output multiplier
my_iom$multiplier_output

## ------------------------------------------------
## Method `iom$compute_multiplier_employment`
## ------------------------------------------------

# data
intermediate_transactions &lt;- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), 3, 3)
total_production &lt;- matrix(c(100, 200, 300), 1, 3)
jobs_data &lt;- matrix(c(10, 12, 15), 1, 3)
# instantiate iom object
my_iom &lt;- fio::iom$new("test", intermediate_transactions, total_production, occupation = jobs_data)
# calculate the technical coefficients
my_iom$compute_tech_coeff()
# calculate the Leontief inverse
my_iom$compute_leontief_inverse()
# calculate the employment multiplier
my_iom$compute_multiplier_employment()
# show the employment multiplier
my_iom$multiplier_employment

## ------------------------------------------------
## Method `iom$compute_multiplier_wages`
## ------------------------------------------------

# data
intermediate_transactions &lt;- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), 3, 3)
total_production &lt;- matrix(c(100, 200, 300), 1, 3)
wages_data &lt;- matrix(c(10, 12, 15), 1, 3)
# instantiate iom object
my_iom &lt;- fio::iom$new("test", intermediate_transactions, total_production, wages = wages_data)
# calculate the technical coefficients
my_iom$compute_tech_coeff()
# calculate the Leontief inverse
my_iom$compute_leontief_inverse()
# calculate the wages multiplier
my_iom$compute_multiplier_wages()
# show the wages multiplier
my_iom$multiplier_wages

## ------------------------------------------------
## Method `iom$compute_multiplier_taxes`
## ------------------------------------------------

# data
intermediate_transactions &lt;- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), 3, 3)
total_production &lt;- matrix(c(100, 200, 300), 1, 3)
tax_data &lt;- matrix(c(10, 12, 15), 1, 3)
# instantiate iom object
my_iom &lt;- fio::iom$new("test", intermediate_transactions, total_production, taxes = tax_data)
# calculate the technical coefficients
my_iom$compute_tech_coeff()
# calculate the Leontief inverse
my_iom$compute_leontief_inverse()
# calculate the tax multiplier
my_iom$compute_multiplier_taxes()
# show the taxes multiplier
my_iom$multiplier_taxes

## ------------------------------------------------
## Method `iom$compute_field_influence`
## ------------------------------------------------

# data
intermediate_transactions &lt;- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), 3, 3)
total_production &lt;- matrix(c(100, 200, 300), 1, 3)
# instantiate iom object
my_iom &lt;- fio::iom$new("test", intermediate_transactions, total_production)
# calculate the technical coefficients
my_iom$compute_tech_coeff()
# calculate the Leontief inverse
my_iom$compute_leontief_inverse()
# calculate field of influence
my_iom$compute_field_influence(epsilon = 0.01)
# show the field of influence
my_iom$field_influence

## ------------------------------------------------
## Method `iom$compute_key_sectors`
## ------------------------------------------------

# data
intermediate_transactions &lt;- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), 3, 3)
total_production &lt;- matrix(c(100, 200, 300), 1, 3)
# instantiate iom object
my_iom &lt;- fio::iom$new("test", intermediate_transactions, total_production)
# calculate the technical coefficients
my_iom$compute_tech_coeff()
# calculate the Leontief inverse
my_iom$compute_leontief_inverse()
# calculate key sectors
my_iom$compute_key_sectors()
# show the key sectors
my_iom$key_sectors

## ------------------------------------------------
## Method `iom$compute_allocation_coeff`
## ------------------------------------------------

intermediate_transactions &lt;- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), 3, 3)
total_production &lt;- matrix(c(100, 200, 300), 1, 3)
# instantiate iom object
my_iom &lt;- fio::iom$new("test", intermediate_transactions, total_production)
# Calculate the allocation coefficients
my_iom$compute_allocation_coeff()
# show the allocation coefficients
my_iom$allocation_coefficients_matrix

## ------------------------------------------------
## Method `iom$compute_ghosh_inverse`
## ------------------------------------------------

intermediate_transactions &lt;- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), 3, 3)
total_production &lt;- matrix(c(100, 200, 300), 1, 3)
# instantiate iom object
my_iom &lt;- fio::iom$new("test", intermediate_transactions, total_production)
# Calculate the allocation coefficients
my_iom$compute_allocation_coeff()
# Calculate the Ghosh inverse
my_iom$compute_ghosh_inverse()
# show the Ghosh inverse
my_iom$ghosh_inverse_matrix

## ------------------------------------------------
## Method `iom$compute_hypothetical_extraction`
## ------------------------------------------------

# data
intermediate_transactions &lt;- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), 3, 3)
total_production &lt;- matrix(c(100, 200, 300), 1, 3)
exports_data &lt;- matrix(c(5, 10, 15), 3, 1)
holsehold_consumption_data &lt;- matrix(c(20, 25, 30), 3, 1)
operating_income_data &lt;- matrix(c(2, 5, 10), 1, 3)
taxes_data &lt;- matrix(c(1, 2, 3), 1, 3)
# instantiate iom object
my_iom &lt;- fio::iom$new(
 "test",
 intermediate_transactions,
 total_production,
 exports = exports_data,
 household_consumption = holsehold_consumption_data,
 operating_income = operating_income_data,
 taxes = taxes_data
)
# update value-added matrix
my_iom$update_value_added_matrix()
# update final demand matrix
my_iom$update_final_demand_matrix()
# calculate the technical coefficients
my_iom$compute_tech_coeff()
# calculate the Leontief inverse
my_iom$compute_leontief_inverse()
# calculate allocation coefficients
my_iom$compute_allocation_coeff()
# calculate Ghosh inverse
my_iom$compute_ghosh_inverse()
# calculate hypothetical extraction
my_iom$compute_hypothetical_extraction()
# show results
my_iom$hypothetical_extraction

## ------------------------------------------------
## Method `iom$set_max_threads`
## ------------------------------------------------

intermediate_transactions &lt;- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), 3, 3)
total_production &lt;- matrix(c(100, 200, 300), 1, 3)
# instantiate iom object
my_iom &lt;- fio::iom$new("test", intermediate_transactions, total_production)
# to run single threaded (sequential)
my_iom$set_max_threads(1L)
my_iom$threads
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
