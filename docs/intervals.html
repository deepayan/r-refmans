<!DOCTYPE html><html><head><title>Help for package intervals</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {intervals}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as.matrix'><p>Extract matrix of endpoints</p></a></li>
<li><a href='#c'><p>Combine different interval matrix objects</p></a></li>
<li><a href='#close_intervals'><p>Re-represent integer intervals with open or closed endpoints</p></a></li>
<li><a href='#clusters'><p>Identify clusters in a collection of positions or intervals</p></a></li>
<li><a href='#distance_to_nearest'><p>Compute distance to nearest position in a set of intervals</p></a></li>
<li><a href='#empty'><p>Identify empty interval rows</p></a></li>
<li><a href='#expand'><p>Expand or contract intervals</p></a></li>
<li><a href='#interval_complement'><p>Compute the complement of a set of intervals</p></a></li>
<li><a href='#interval_difference'><p>Compute set difference</p></a></li>
<li><a href='#interval_included'><p>Assess inclusion of one set of intervals with respect to another</p></a></li>
<li><a href='#interval_intersection'><p>Compute the intersection of one or more sets of intervals</p></a></li>
<li><a href='#interval_overlap'><p>Assess overlap from one set of intervals to another</p></a></li>
<li><a href='#interval_union'><p>Compute the union of intervals in one or more interval matrices</p></a></li>
<li><a href='#Intervals_virtual_or_numeric-class'><p>Class &quot;Intervals_virtual_or_numeric&quot;</p></a></li>
<li><a href='#Intervals_virtual-class'><p>Class &quot;Intervals_virtual&quot;</p></a></li>
<li><a href='#Intervals-class'><p>Classes &quot;Intervals&quot; and &quot;Intervals_full&quot;</p></a></li>
<li><a href='#intervals-package'>
<p>Tools for working with points and intervals</p></a></li>
<li><a href='#plot.Intervals'><p>Plotting methods for interval objects</p></a></li>
<li><a href='#reduce'><p>Compactly re-represent the points in a set of intervals</p></a></li>
<li><a href='#sgd'><p>Yeast gene model sample data</p></a></li>
<li><a href='#size'><p>Compute interval sizes</p></a></li>
<li><a href='#split'><p>Split an intervals object according to a factor</p></a></li>
<li><a href='#which_nearest'><p>Identify nearest member(s) in a set of intervals</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.15.4</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools for Working with Points and Intervals</td>
</tr>
<tr>
<td>Author:</td>
<td>Richard Bourgon &lt;bourgon.richard@gene.com&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Edzer Pebesma &lt;edzer.pebesma@uni-muenster.de&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.9.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils, graphics, methods</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for working with and comparing sets of points and intervals.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/Artistic-2.0">Artistic-2.0</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/edzer/intervals">https://github.com/edzer/intervals</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-27 10:00:08 UTC; edzer</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-29 13:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='as.matrix'>Extract matrix of endpoints</h2><span id='topic+as.matrix'></span><span id='topic+as.matrix.Intervals_virtual'></span><span id='topic+as.matrix+2CIntervals_virtual-method'></span>

<h3>Description</h3>

<p> S3 and S4 methods for extracting the matrix of endpoints
from S4 objects. </p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Intervals_virtual'
as.matrix(x, ...)

## S4 method for signature 'Intervals_virtual'
as.matrix(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.matrix_+3A_x">x</code></td>
<td>
<p><code>"Intervals"</code> or <code>"Intervals_full"</code> objects.</p>
</td></tr>
<tr><td><code id="as.matrix_+3A_...">...</code></td>
<td>
<p>Unused, but required by the S3 generic.</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>A two-column matrix, equivalent to <code>x@.Data</code> or <code>as(x,
  "matrix")</code>.
</p>

<hr>
<h2 id='c'>Combine different interval matrix objects</h2><span id='topic+c'></span><span id='topic+c.Intervals'></span><span id='topic+c.Intervals_full'></span>

<h3>Description</h3>

<p>S3 methods for concatenating sets of intervals into a single set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Intervals'
c(...)
## S3 method for class 'Intervals_full'
c(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_+3A_...">...</code></td>
<td>
<p><code>"Intervals"</code> or <code>"Intervals_full"</code> objects.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All objects are expected to have the same value in the <code>type</code>
slot. If the <code>closed</code> slots differ for
<code>"<a href="#topic+Intervals-class">Intervals</a>"</code> objects and <code>type == "Z"</code>, the
objects will be adjusted to have <code>closed</code> values matching that of
<code>x</code>; if <code>type == "R"</code>, however, then all objects must first
be coerced to class <code>"<a href="#topic+Intervals_full-class">Intervals_full</a>"</code>, with a
warning. This coercion also occurs when a mixture of object types is
passed in. A <code>NULL</code> in any argument is ignored.
</p>


<h3>Value</h3>

<p>A single <code>"<a href="#topic+Intervals-class">Intervals</a>"</code> or
<code>"<a href="#topic+Intervals_full-class">Intervals_full</a>"</code> object. Input objects are
concatenated in their order of appearance in the the argument list.
</p>
<p>If any input argument is not a set of intervals, <code>list(...)</code> is
returned instead.
</p>


<h3>Note</h3>

<p>These methods will be converted to S4 once the necessary dispatch on
<code>...</code> is supported.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f1 &lt;- Intervals( 1:2, type = "Z" )
g1 &lt;- open_intervals( f1 + 5 )

# Combining Intervals objects over Z may require closure adjustment
c( f1, g1 )

f2 &lt;- f1; g2 &lt;- g1
type( f2 ) &lt;- type( g2 ) &lt;- "R"

# Combine Intervals objects over R which have different closure requires
# coercion

h &lt;- c( f2, g2 )

# Coercion for mixed combinations as well
c( h, g2 + 10 )

## Not run: 
# Combining different types is not permitted
c( h, g1 + 10 )

## End(Not run)

</code></pre>

<hr>
<h2 id='close_intervals'>Re-represent integer intervals with open or closed endpoints</h2><span id='topic+close_intervals'></span><span id='topic+close_intervals+2CIntervals_virtual-method'></span><span id='topic+open_intervals'></span><span id='topic+open_intervals+2CIntervals_virtual-method'></span><span id='topic+adjust_closure'></span><span id='topic+adjust_closure+2CIntervals-method'></span><span id='topic+adjust_closure+2CIntervals_full-method'></span>

<h3>Description</h3>

<p>Given an integer interval matrix, adjust endpoints so that all
intervals have the requested closure status.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Intervals_virtual'
close_intervals(x)

## S4 method for signature 'Intervals_virtual'
open_intervals(x)

## S4 method for signature 'Intervals'
adjust_closure(x, close_left = TRUE, close_right = TRUE)

## S4 method for signature 'Intervals_full'
adjust_closure(x, close_left = TRUE, close_right = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="close_intervals_+3A_x">x</code></td>
<td>

<p>An object of appropriate class, and for which <code>x@type ==
    "Z"</code>. If <code>x@type == "R"</code>, an error is generated.
</p>
</td></tr>
<tr><td><code id="close_intervals_+3A_close_left">close_left</code></td>
<td>

<p>Should the left endpoints be closed or open?
</p>
</td></tr>
<tr><td><code id="close_intervals_+3A_close_right">close_right</code></td>
<td>

<p>Should the right endpoints be closed or open?
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same class as <code>x</code>, with endpoints adjusted as
necessary and all <code>closed(x)</code> set to either <code>TRUE</code> or
<code>FALSE</code>, as appropriate.
</p>


<h3>Note</h3>

<p>The <code>close_intervals</code> and <code>open_intervals</code> are for
convenience, and just call <code>adjust_closure</code> with the approriate
arguments.
</p>
<p>The <code>x</code> object may contain empty intervals, with at least one
open endpoint, and still be valid. (Intervals are invalid if their
second endpoint is less than their first.) The <code>close_intervals</code>
method would, in such cases, create an invalid result; to prevent
this, empty intervals are detected and removed, with a warning.
</p>
<p>This package does not make a distinction between closed and open
infinite endpoints: an interval with an infinite endpoint extends to
(plus or minus) infinity regardless of the closure state. For example,
<code><a href="#topic+distance_to_nearest">distance_to_nearest</a></code> will return a <code>0</code> when
<code>Inf</code> is compared to both <code>"[0, Inf)"</code> and <code>"[0, Inf]"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- Intervals(
               c( 1, 5, 10, 1, 6, 20 ),
               closed = c( TRUE, FALSE ),
               type = "Z"
               )

# Empties are dropped
close_intervals(x)
adjust_closure(x, FALSE, TRUE)

# Intervals_full
y &lt;- as( x, "Intervals_full" )
closed(y)[1,2] &lt;- TRUE
open_intervals(y)
</code></pre>

<hr>
<h2 id='clusters'>Identify clusters in a collection of positions or intervals</h2><span id='topic+clusters'></span><span id='topic+clusters+2Cnumeric-method'></span><span id='topic+clusters+2CIntervals_virtual-method'></span>

<h3>Description</h3>

<p>This function uses tools in the <span class="pkg">intervals</span> package to quickly
identify clusters &ndash; contiguous collections of positions or intervals
which are separated by no more than a given distance from their
neighbors to either side.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'numeric'
clusters(x, w, which = FALSE, check_valid = TRUE)

## S4 method for signature 'Intervals_virtual'
clusters(x, w, which = FALSE, check_valid = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clusters_+3A_x">x</code></td>
<td>
<p>An appropriate object.</p>
</td></tr>
<tr><td><code id="clusters_+3A_w">w</code></td>
<td>

<p>Maximum permitted distance between a cluster member and its
neighbors to either side.
</p>
</td></tr>
<tr><td><code id="clusters_+3A_which">which</code></td>
<td>

<p>Should indices into the <code>x</code> object be returned instead of
actual subsets?
</p>
</td></tr>
<tr><td><code id="clusters_+3A_check_valid">check_valid</code></td>
<td>

<p>Should <code><a href="methods.html#topic+validObject">validObject</a></code> be called before passing to
compiled code? Also see <code><a href="#topic+interval_overlap">interval_overlap</a></code> and
<code><a href="#topic+reduce">reduce</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A cluster is defined to be a maximal collection, with at least two
members, of components of <code>x</code> which are separated by no more than
<code>w</code>. Note that when <code>x</code> represents intervals, an interval
must actually <em>contain a point</em> at distance <code>w</code> or less from
a neighboring interval to be assigned to the same cluster. If the ends
of both intervals in question are open and exactly at distance
<code>w</code>, they will not be deemed to be cluster co-members. See the
example below.
</p>


<h3>Value</h3>

<p>A list whose components are the clusters. Each component is thus a
subset of <code>x</code>, or, if <code>which == TRUE</code>, a vector of
indices into the <code>x</code> object. (The indices correspond to row
numbers when <code>x</code> is of class <code>"Intervals_virtual"</code>.)
</p>


<h3>Note</h3>

<p>Implementation is by a call to <code><a href="#topic+reduce">reduce</a></code> followed by a call
to <code><a href="#topic+interval_overlap">interval_overlap</a></code>. The <code>clusters</code> methods are
included to illustrate the utility of the core functions in the
<span class="pkg">intervals</span> package, although they are also useful in their own
right.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Numeric method
w &lt;- 20
x &lt;- sample( 1000, 100 )
c1 &lt;- clusters( x, w )

# Check results
sapply( c1, function( x ) all( diff(x) &lt;= w ) )
d1 &lt;- diff( sort(x) )
all.equal(
          as.numeric( d1[ d1 &lt;= w ] ),
          unlist( sapply( c1, diff ) )
          )

# Intervals method, starting with a reduced object so we know that all
# intervals are disjoint and sorted.
B &lt;- 100
left &lt;- runif( B, 0, 1e4 )
right &lt;- left + rexp( B, rate = 1/10 )
y &lt;- reduce( Intervals( cbind( left, right ) ) )

gaps &lt;- function(x) x[-1,1] - x[-nrow(x),2]
hist( gaps(y), breaks = 30 )

w &lt;- 200
c2 &lt;- clusters( y, w )
head( c2 )
sapply( c2, function(x) all( gaps(x) &lt;= w ) )

# Clusters and open end points. See "Details".
z &lt;- Intervals(
               matrix( 1:4, 2, 2, byrow = TRUE ),
               closed = c( TRUE, FALSE )
               )
z
clusters( z, 1 )
closed(z)[1] &lt;- FALSE
z
clusters( z, 1 )
</code></pre>

<hr>
<h2 id='distance_to_nearest'>Compute distance to nearest position in a set of intervals</h2><span id='topic+distance_to_nearest'></span><span id='topic+distance_to_nearest+2CIntervals_virtual_or_numeric+2CIntervals_virtual_or_numeric-method'></span>

<h3>Description</h3>

<p>For each point or interval in the <code>from</code> argument, compute the
distance to the nearest position in the <code>to</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 
## 'Intervals_virtual_or_numeric,Intervals_virtual_or_numeric'
distance_to_nearest(from, to, check_valid = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distance_to_nearest_+3A_from">from</code></td>
<td>
<p>An object of appropriate type.</p>
</td></tr>
<tr><td><code id="distance_to_nearest_+3A_to">to</code></td>
<td>
<p>An object of appropriate type.</p>
</td></tr>
<tr><td><code id="distance_to_nearest_+3A_check_valid">check_valid</code></td>
<td>

<p>Should <code><a href="methods.html#topic+validObject">validObject</a></code> be called before passing to
compiled code? Also see <code><a href="#topic+interval_overlap">interval_overlap</a></code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of distances, with one entry per point or interval in
<code>from</code>. Any intervals in <code>from</code> which are either empty (see
<code><a href="#topic+empty">empty</a></code>) or have <code>NA</code> endpoints produce a <code>NA</code>
result. 
</p>


<h3>Note</h3>

<p>This function is now just a wrapper for <code><a href="#topic+which_nearest">which_nearest</a></code>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+which_nearest">which_nearest</a></code>, which also returns indices for the
interval or intervals (in case of ties) at the distance reported.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Point to interval

to &lt;- Intervals( c(0,5,3,Inf) )
from &lt;- -5:10
plot( from, distance_to_nearest( from, to ), type = "l" ) 
segments( to[,1], 1, pmin(to[,2], par("usr")[2]), 1, col = "red" )

# Interval to interval

from &lt;- Intervals( c(-Inf,-Inf,3.5,-1,1,4) )
distance_to_nearest( from, to )
</code></pre>

<hr>
<h2 id='empty'>Identify empty interval rows</h2><span id='topic+empty'></span><span id='topic+empty+2CIntervals-method'></span><span id='topic+empty+2CIntervals_full-method'></span>

<h3>Description</h3>

<p>A valid interval matrix may contain empty intervals: those with common
endpoints, at least one of which is open. The <code>empty</code> method
identifies these rows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Intervals'
empty(x)

## S4 method for signature 'Intervals_full'
empty(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="empty_+3A_x">x</code></td>
<td>
<p>An <code>"Intervals"</code> or <code>"Intervals_full"</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Intervals are deemed to be empty when their endpoints are equal and
not both closed, or for <code>type == "Z"</code>, when their endpoints differ
by 1 and both are open. The matrices <code>x</code> and <code>x[!empty(x),]</code>
represent the same subset of the integers or the real line.
</p>


<h3>Value</h3>

<p>A boolean vector with length equal to <code>nrow(x)</code>.
</p>


<h3>Warning</h3>

<p>Exact equality (<code>==</code>) comparisons are used by <code>empty</code>. See
the package vignette for a discussion of equality and floating point
numbers.
</p>


<h3>Note</h3>

<p>Note that intervals of size 0 may not be empty over the reals, and
intervals whose second endpoint is strictly greater than the first
<em>may</em> be empty over the integers, if both endpoints are open.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+size">size</a></code> to compute the size of each interval in an
object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z1 &lt;- Intervals( cbind( 1, 1:3 ), type = "Z" )
z2 &lt;- z1; closed(z2)[1] &lt;- FALSE
z3 &lt;- z1; closed(z3) &lt;- FALSE

empty(z1)
empty(z2)
empty(z3)

r1 &lt;- z1; type(r1) &lt;- "R"
r2 &lt;- z2; type(r2) &lt;- "R"
r3 &lt;- z3; type(r3) &lt;- "R"

empty(r1)
empty(r2)
empty(r3)

s1 &lt;- Intervals_full( matrix( 1, 3, 2 ), type = "Z" )
closed(s1)[2,2] &lt;- FALSE
closed(s1)[3,] &lt;- FALSE

empty(s1)
</code></pre>

<hr>
<h2 id='expand'>Expand or contract intervals</h2><span id='topic+expand'></span><span id='topic+expand+2CIntervals_virtual-method'></span><span id='topic+contract'></span><span id='topic+contract+2CIntervals_virtual-method'></span>

<h3>Description</h3>

<p>It is often useful to shrink or grow each interval in a set of
intervals: to smooth over small, uninteresting gaps, or to address
possible imprecision resulting from floating point arithmetic. The
<code>expand</code> and <code>contract</code> methods implement this, using either
absolute or relative difference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Intervals_virtual'
expand(x, delta = 0, type = c("absolute", "relative"))

## S4 method for signature 'Intervals_virtual'
contract(x, delta = 0, type = c("absolute", "relative"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand_+3A_x">x</code></td>
<td>
<p> An <code>"Intervals"</code> or <code>"Intervals_full"</code> object.</p>
</td></tr>
<tr><td><code id="expand_+3A_delta">delta</code></td>
<td>

<p>A non-negative adjustement value. A vector is permitted,
and its entries will be recycled if necessary.
</p>
</td></tr>
<tr><td><code id="expand_+3A_type">type</code></td>
<td>

<p>Should adjustment be based on relative or absolute difference.  When
<code>type == "relative"</code> intervals are expanded/contracted to
include/exclude points for which a relative difference with respect
to the nominal value is less than or equal to <code>delta</code>. (See the
note below.) When <code>type == "absolute"</code>, absolute rather than
relative difference is used, i.e., all intervals are expanded or
contracted by the same amount.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single object of appropriate class, with endpoint positions adjusted
as requested. Expansion returns an object with the same dimension as
<code>x</code>; contraction may lead to the elimination of now-empty rows.
</p>


<h3>Note</h3>

<p>Here, the relative difference between <em>x</em> and <em>y</em> is
|<em>x</em> - <em>y</em>|/max(|<em>x</em>|, |<em>y</em>|).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Using adjustment to remove small gaps

x &lt;- Intervals( c(1,10,100,8,50,200), type = "Z" )
close_intervals( contract( reduce( expand(x, 1) ), 1 ) )

# Finding points for which, as a result of possible floating point
# error, intersection may be ambiguous. Whether y1 intersects y2[2,]
# depends on precision.

delta &lt;- .Machine$double.eps^0.5
y1 &lt;- Intervals( c( .5, 1 - delta / 2 ) )
y2 &lt;- Intervals( c( .25, 1, .75, 2 ) )

# Nominal 

interval_intersection( y1, y2 )

# Inner limit

inner &lt;- interval_intersection(
                               contract( y1, delta, "relative" ),
                               contract( y2, delta, "relative" )
                               )

# Outer limit

outer &lt;- interval_intersection(
                               expand( y1, delta, "relative" ),
                               expand( y2, delta, "relative" )
                               )

# The ambiguous set, corresponding to points which may or may not be in
# the intersection -- depending on numerical values for endpoints
# which are, with respect to relative difference, indistinguishable from
# the nominal values.

interval_difference( outer, inner )
</code></pre>

<hr>
<h2 id='interval_complement'>Compute the complement of a set of intervals</h2><span id='topic+interval_complement'></span><span id='topic+interval_complement+2CIntervals_virtual-method'></span>

<h3>Description</h3>

<p>Compute the complement of a set of intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Intervals_virtual'
interval_complement(x, check_valid = TRUE)
</code></pre>


<h3>Arguments</h3>

  
<table>
<tr><td><code id="interval_complement_+3A_x">x</code></td>
<td>
<p>An <code>"Intervals"</code> or <code>"Intervals_full"</code> object.</p>
</td></tr>
<tr><td><code id="interval_complement_+3A_check_valid">check_valid</code></td>
<td>

<p>Should <code><a href="methods.html#topic+validObject">validObject</a></code> be called before passing to
compiled code? Also see <code><a href="#topic+interval_overlap">interval_overlap</a></code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same class as <code>x</code>, compactly representing the
complement of the intervals described in <code>x</code>.
</p>


<h3>Note</h3>

<p>For objects of class <code>"Intervals"</code>, closure on <code>-Inf</code> or
<code>Inf</code> endpoints is set to match that of all the intervals with
finite endpoints. For objects of class <code>"Intervals_full"</code>,
non-finite endpoints are left open (although in general, this package
does not make a distinction between closed and open infinite
endpoints). 
</p>

<hr>
<h2 id='interval_difference'>Compute set difference</h2><span id='topic+interval_difference'></span><span id='topic+interval_difference+2CIntervals_virtual+2CIntervals_virtual-method'></span>

<h3>Description</h3>

<p>Compute the set difference between two objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Intervals_virtual,Intervals_virtual'
interval_difference(x, y, check_valid = TRUE)
</code></pre>


<h3>Arguments</h3>

  
<table>
<tr><td><code id="interval_difference_+3A_x">x</code></td>
<td>
<p>An <code>"Intervals"</code> or <code>"Intervals_full"</code> object.</p>
</td></tr>
<tr><td><code id="interval_difference_+3A_y">y</code></td>
<td>

<p>An <code>"Intervals"</code> or <code>"Intervals_full"</code> object, with a
<code>type</code> slot matching that of <code>x</code>.
</p>
</td></tr>
<tr><td><code id="interval_difference_+3A_check_valid">check_valid</code></td>
<td>

<p>Should <code><a href="methods.html#topic+validObject">validObject</a></code> be called on <code>x</code> and <code>y</code>
before passing to compiled code? Also see
<code><a href="#topic+interval_overlap">interval_overlap</a></code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object representing the subset of the integers or real line, as
determined by <code>type(x)</code>, found in <code>x</code> but not in <code>y</code>.
</p>


<h3>See Also</h3>

<p>These methods are just wrappers for
<code><a href="#topic+interval_intersection">interval_intersection</a></code> and
<code><a href="#topic+interval_complement">interval_complement</a></code>.
</p>

<hr>
<h2 id='interval_included'>Assess inclusion of one set of intervals with respect to another</h2><span id='topic+interval_included'></span><span id='topic+interval_included+2CIntervals+2CIntervals-method'></span><span id='topic+interval_included+2CIntervals_full+2CIntervals_full-method'></span>

<h3>Description</h3>

<p>Determine which intervals in the one set are completely included in
the intervals of a second set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Intervals,Intervals'
interval_included(from, to, check_valid = TRUE)
## S4 method for signature 'Intervals_full,Intervals_full'
interval_included(from, to, check_valid = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interval_included_+3A_from">from</code></td>
<td>

<p>An <code>"Intervals"</code> or <code>"Intervals_full"</code> object, or a
vector of class <code>"numeric"</code>.
</p>
</td></tr>
<tr><td><code id="interval_included_+3A_to">to</code></td>
<td>

<p>An <code>"Intervals"</code> or <code>"Intervals_full"</code> object, or a
vector of class <code>"numeric"</code>.
</p>
</td></tr>
<tr><td><code id="interval_included_+3A_check_valid">check_valid</code></td>
<td>

<p>Should <code><a href="methods.html#topic+validObject">validObject</a></code> be called before passing to
compiled code? This, among other things, verifies that endpoints are
of data type <code>"numeric"</code> and the <code>closed</code> vector/matrix is
appropriately sized and of the correct data type. (Compiled code
does no further checking.)
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list, with one element for each row/component of <code>from</code>. The
elements are vectors of indices, indicating which <code>to</code> rows (or
components, for the <code>"numeric"</code> method) are completely included
within each interval in <code>from</code>. A list element of length 0
indicates no included elements. Note that empty <code>to</code> elements are
not included in anything, and empty <code>from</code> elements do not
include anything.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+interval_overlap">interval_overlap</a></code> for partial overlaps &ndash; i.e., at at
least a point.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Note that 'from' and 'to' contain valid but empty intervals.

to &lt;- Intervals(
               matrix(
                      c(
                        2,  6,
                        2,  8,
                        2,  9,
                        4,  4,
                        6,  8
                        ),
                      ncol = 2, byrow = TRUE
                      ),
               closed = c( TRUE, FALSE ),
               type = "Z"
               )

from &lt;- Intervals(
               matrix(
                      c(
                         2,  8,
                         8,  9,
                         6,  9,
                        11, 12,
                         3,  3
                        ),
                      ncol = 2, byrow = TRUE
                      ),
               closed = c( TRUE, FALSE ),
               type = "Z"
               )
rownames(from) &lt;- letters[1:nrow(from)]

from
to
interval_included(from, to)

closed(to) &lt;- TRUE
to
interval_included(from, to)

# Intervals_full

F &lt;- FALSE
T &lt;- TRUE

to &lt;- Intervals_full(
                     rep( c(2,8), c(4,4) ),
                     closed = matrix( c(F,F,T,T,F,T,F,T), ncol = 2 ),
                     type = "R"
                     )

type( from ) &lt;- "R"
from &lt;- as( from, "Intervals_full" )

from
to
interval_included(from, to)

# Testing

B &lt;- 1000

x1 &lt;- rexp( B, 1/1000 )
s1 &lt;- runif( B, max=5 )
x2 &lt;- rexp( B, 1/1000 )
s2 &lt;- runif( B, max=3 )

from &lt;- Intervals_full( cbind( x1, x1 + s1 ) )
to &lt;- Intervals_full( cbind( x2, x2 + s2 ) )

ii &lt;- interval_included( from, to )
ii_match &lt;- which( sapply( ii, length ) &gt; 0 )

from[ ii_match[1:3], ]
lapply( ii[ ii_match[1:3] ], function(x) to[x,] )

included &lt;- to[ unlist( ii ), ]
dim( included )

interval_intersection( included, interval_complement( from ) )
</code></pre>

<hr>
<h2 id='interval_intersection'>Compute the intersection of one or more sets of intervals</h2><span id='topic+interval_intersection'></span><span id='topic+interval_intersection+2CIntervals_virtual-method'></span><span id='topic+interval_intersection+2Cmissing-method'></span>

<h3>Description</h3>

<p>Given one or more sets of intervals, produce a new set compactly
representing points contained in at least one interval of each input
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Intervals_virtual'
interval_intersection(x, ..., check_valid = TRUE)

## S4 method for signature 'missing'
interval_intersection(x, ..., check_valid = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interval_intersection_+3A_x">x</code></td>
<td>
<p> An <code>"Intervals"</code> or <code>"Intervals_full"</code> object.</p>
</td></tr>
<tr><td><code id="interval_intersection_+3A_...">...</code></td>
<td>
<p>Additional objects of the same classes permitted for <code>x</code>.</p>
</td></tr>
<tr><td><code id="interval_intersection_+3A_check_valid">check_valid</code></td>
<td>

<p>Should <code><a href="methods.html#topic+validObject">validObject</a></code> be called before passing to
compiled code? Also see <code><a href="#topic+interval_overlap">interval_overlap</a></code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single object representing points contained in each of the objects
supplied in the <code>x</code> and <code>...</code> arguments.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+interval_union">interval_union</a></code> and
<code><a href="#topic+interval_complement">interval_complement</a></code>, which are used to produce the
results. 
</p>

<hr>
<h2 id='interval_overlap'>Assess overlap from one set of intervals to another</h2><span id='topic+interval_overlap'></span><span id='topic+interval_overlap+2CIntervals_virtual_or_numeric+2CIntervals_virtual_or_numeric-method'></span><span id='topic+interval_overlap+2Cmissing+2CANY-method'></span><span id='topic+interval_overlap+2CANY+2Cmissing-method'></span>

<h3>Description</h3>

<p>Assess overlap from intervals in one set to intervals in another set,
and return the relevant indices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 
## 'Intervals_virtual_or_numeric,Intervals_virtual_or_numeric'
interval_overlap(from, to, check_valid = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interval_overlap_+3A_from">from</code></td>
<td>

<p>An <code>"Intervals"</code> or <code>"Intervals_full"</code> object, or a
vector of class <code>"numeric"</code>. <em>Note!</em> Prior to v. 0.11.1,
this argument was called <code>target</code>.
</p>
</td></tr>
<tr><td><code id="interval_overlap_+3A_to">to</code></td>
<td>

<p>An <code>"Intervals"</code> or <code>"Intervals_full"</code> object, or a
vector of class <code>"numeric"</code>. <em>Note!</em> Prior to v. 0.11.1,
this argument was called <code>query</code>.
</p>
</td></tr>
<tr><td><code id="interval_overlap_+3A_check_valid">check_valid</code></td>
<td>

<p>Should <code><a href="methods.html#topic+validObject">validObject</a></code> be called before passing to
compiled code? This, among other things, verifies that endpoints are
of data type <code>"numeric"</code> and the <code>closed</code> vector/matrix is
appropriately sized and of the correct data type. (Compiled code
does no further checking.)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Intervals which meet at endpoints overlap only if both endpoints are
closed. Intervals in <code>to</code> with <code>NA</code> endpoints are
ignored, with a warning; in <code>from</code>, such intervals produce no
matches. Intervals in either <code>to</code> or <code>from</code> which are
actually empty have their endpoints set to <code>NA</code> before
proceeding, with warning, and so do not generate matches. If
eith <code>to</code> or <code>from</code> is a vector of class <code>"numeric"</code>,
overlap will be assess for the corresponding set of points.
</p>


<h3>Value</h3>

<p>A list, with one element for each row/component of <code>from</code>. The
elements are vectors of indices, indicating which <code>to</code> rows (or
components, for the <code>"numeric"</code> method) overlap each interval in
<code>from</code>. A list element of length 0 indicates no overlapping
elements.
</p>


<h3>Note</h3>

<p>If you want real (<code>type == "R"</code>) intervals that overlap in a set
of positive measure &mdash; not just at endpoints &mdash; set all endpoints to
open (i.e., <code>close(from) &lt;- FALSE; closed(to) &lt;- FALSE</code>) first.
</p>
<p>This function is now just a wrapper for <code><a href="#topic+which_nearest">which_nearest</a></code>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+which_nearest">which_nearest</a></code> for details on nearby as well as
overlapping intervals in <code>to</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Note that 'from' contains a valid but empty interval.

to &lt;- Intervals(
               matrix(
                      c(
                        2,  8,
                        3,  4,
                        5, 10
                        ),
                      ncol = 2, byrow = TRUE
                      ),
               closed = c( TRUE, FALSE ),
               type = "Z"
               )

from &lt;- Intervals(
               matrix(
                      c(
                         2,  8,
                         8,  9,
                         6,  9,
                        11, 12,
                         3,  3
                        ),
                      ncol = 2, byrow = TRUE
                      ),
               closed = c( TRUE, FALSE ),
               type = "Z"
               )
rownames(from) &lt;- letters[1:nrow(from)]

empty(to)
empty(from)

interval_overlap(from, to)

# Non-empty real intevals of size 0 can overlap other intervals.

u &lt;- to
type(u) &lt;- "R"

v &lt;- Intervals_full( rep(3,4) )
closed(v)[2,] &lt;- FALSE
v
empty(v)
size(v)

interval_overlap(v, u)

# Working with points

interval_overlap( from, c( 2, 3, 6, NA ) )
</code></pre>

<hr>
<h2 id='interval_union'>Compute the union of intervals in one or more interval matrices</h2><span id='topic+interval_union'></span><span id='topic+interval_union+2CIntervals_virtual-method'></span><span id='topic+interval_union+2Cmissing-method'></span>

<h3>Description</h3>

<p>Compute the union of intervals in one or more interval matrices. The
intervals contained in a single interval matrix object need not, in
general, be disjoint; <code>interval_union</code>, however, always returns a
matrix with sorted, disjoint intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Intervals_virtual'
interval_union(x, ..., check_valid = TRUE)

## S4 method for signature 'missing'
interval_union(x, ..., check_valid = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interval_union_+3A_x">x</code></td>
<td>
<p> An <code>"Intervals"</code> or <code>"Intervals_full"</code> object.</p>
</td></tr>
<tr><td><code id="interval_union_+3A_...">...</code></td>
<td>

<p>Optionally, additional objects which can be combined with
<code>x</code>. See <code><a href="#topic+c.Intervals">c.Intervals</a></code> for details on mixing
different types of objects.
</p>
</td></tr>
<tr><td><code id="interval_union_+3A_check_valid">check_valid</code></td>
<td>

<p>Should <code><a href="methods.html#topic+validObject">validObject</a></code> be called before passing to
compiled code? Also see <code><a href="#topic+interval_overlap">interval_overlap</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All supplied objects are combined using <code><a href="#topic+c.Intervals">c</a></code>
and then then passed to <code><a href="#topic+reduce">reduce</a></code>. The <code>missing</code>
method is only to permit use of <code><a href="base.html#topic+do.call">do.call</a></code> with named list,
since no named element will typically match <code>x</code>.
</p>


<h3>Value</h3>

<p>A single object of appropriate class, compactly representing the union
of all intervals in <code>x</code>, and optionally, in <code>...</code> as
well. For class <code>"Intervals"</code>, the result will have the same
<code>closed</code> values as <code>x</code>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+reduce">reduce</a></code>, which is used to produce the results. 
</p>

<hr>
<h2 id='Intervals_virtual_or_numeric-class'>Class &quot;Intervals_virtual_or_numeric&quot;</h2><span id='topic+Intervals_virtual_or_numeric-class'></span>

<h3>Description</h3>

<p>A class union combining <code>"<a href="#topic+Intervals_virtual-class">Intervals_virtual</a>"</code> and
<code>"<a href="methods.html#topic+numeric-class">numeric</a>"</code>. Used by, e.g.,
<code><a href="#topic+distance_to_nearest">distance_to_nearest</a></code> and <code><a href="#topic+which_nearest">which_nearest</a></code>.
</p>


<h3>Methods</h3>


<dl>
<dt>distance_to_nearest</dt><dd><p><code>signature(from = "Intervals_virtual_or_numeric", to = "Intervals_virtual_or_numeric")</code></p>
</dd>
<dt>interval_overlap</dt><dd><p><code>signature(from = "Intervals_virtual_or_numeric", to = "Intervals_virtual_or_numeric")</code></p>
</dd>
</dl>


<hr>
<h2 id='Intervals_virtual-class'>Class &quot;Intervals_virtual&quot;</h2><span id='topic+Intervals_virtual-class'></span><span id='topic+closed'></span><span id='topic+closed+2CIntervals_virtual-method'></span><span id='topic+closed+2CIntervals_virtual-method'></span><span id='topic+coerce+2CIntervals_virtual+2Ccharacter-method'></span><span id='topic+head+2CIntervals_virtual-method'></span><span id='topic+initialize+2CIntervals_virtual-method'></span><span id='topic+is.na+2CIntervals_virtual-method'></span><span id='topic+show+2CIntervals_virtual-method'></span><span id='topic+t+2CIntervals_virtual-method'></span><span id='topic+tail+2CIntervals_virtual-method'></span><span id='topic+type'></span><span id='topic+type+2CIntervals_virtual-method'></span><span id='topic+type+3C-'></span><span id='topic+type+3C-+2CIntervals_virtual-method'></span>

<h3>Description</h3>

<p>A virtual class from which the <code>"Intervals"</code> and
<code>"Intervals_full"</code> classes derive.
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code>:</dt><dd>
<p>Object of class <code>"matrix"</code>. A two-column, numeric (see below)
format is required. For a valid object, no value in the first
column may exceed its partner in the second column. (Note that
this <em>does</em> permit empty interval rows, when both endpoints
are of equal value and not both closed.) Only integral (though not
<code>"integer"</code> class) endpoints are permitted if <code>type</code> is
<code>"Z"</code>. See the note on this point in documentation for
<code>"<a href="#topic+Intervals-class">Intervals</a>"</code>.
</p>
</dd>
<dt><code>type</code>:</dt><dd>
<p>Object of class <code>"character"</code>. A one-element character vector
with either <code>"Z"</code> or <code>"R"</code> is required.
</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="methods.html#topic+matrix-class">matrix</a>"</code>, from data part.
</p>
<p>Class <code>"<a href="methods.html#topic+array-class">array</a>"</code>, by class &quot;matrix&quot;, distance 2.
</p>
<p>Class <code>"<a href="methods.html#topic+structure-class">structure</a>"</code>, by class &quot;matrix&quot;, distance 3.
</p>
<p>Class <code>"<a href="methods.html#topic+vector-class">vector</a>"</code>, by class &quot;matrix&quot;, distance 4,
with explicit coerce.
</p>


<h3>Methods</h3>


<dl>
<dt>close_intervals</dt><dd> <p><code>signature(x = "Intervals_virtual")</code> </p>
</dd>
<dt>closed</dt><dd> <p><code>signature(x = "Intervals_virtual")</code> </p>
</dd>
<dt>clusters</dt><dd> <p><code>signature(x = "Intervals_virtual")</code> </p>
</dd>
<dt>coerce</dt><dd> <p><code>signature(from = "Intervals_virtual", to = "character")</code> </p>
</dd>
<dt>contract</dt><dd> <p><code>signature(x = "Intervals_virtual")</code> </p>
</dd>
<dt>expand</dt><dd> <p><code>signature(x = "Intervals_virtual")</code> </p>
</dd>
<dt>head</dt><dd> <p><code>signature(x = "Intervals_virtual")</code> </p>
</dd>
<dt>initialize</dt><dd> <p><code>signature(.Object = "Intervals_virtual")</code> </p>
</dd>
<dt>interval_complement</dt><dd> <p><code>signature(x = "Intervals_virtual")</code> </p>
</dd>
<dt>interval_difference</dt><dd> <p><code>signature(x = "Intervals_virtual", y = "Intervals_virtual")</code> </p>
</dd>
<dt>interval_intersection</dt><dd> <p><code>signature(x = "Intervals_virtual")</code> </p>
</dd>
<dt>interval_union</dt><dd> <p><code>signature(x = "Intervals_virtual")</code> </p>
</dd>
<dt>is.na</dt><dd> <p><code>signature(x = "Intervals_virtual")</code> </p>
</dd>
<dt>open_intervals</dt><dd> <p><code>signature(x = "Intervals_virtual")</code> </p>
</dd>
<dt>reduce</dt><dd> <p><code>signature(x = "Intervals_virtual")</code> </p>
</dd>
<dt>show</dt><dd> <p><code>signature(object = "Intervals_virtual")</code> </p>
</dd>
<dt>t</dt><dd> <p><code>signature(x = "Intervals_virtual")</code> </p>
</dd>
<dt>tail</dt><dd> <p><code>signature(x = "Intervals_virtual")</code> </p>
</dd>
<dt>type</dt><dd> <p><code>signature(x = "Intervals_virtual")</code> </p>
</dd>
<dt>type&lt;-</dt><dd> <p><code>signature(x = "Intervals_virtual")</code> </p>
</dd>
<dt>which_nearest</dt><dd> <p><code>signature(from = "numeric", to = "Intervals_virtual")</code> </p>
</dd>
<dt>which_nearest</dt><dd> <p><code>signature(from = "Intervals_virtual", to = "numeric")</code> </p>
</dd>
<dt>which_nearest</dt><dd> <p><code>signature(from = "Intervals_virtual", to = "Intervals_virtual")</code> </p>
</dd>
</dl>



<h3>See Also</h3>

<p>See the <code>"<a href="#topic+Intervals-class">Intervals</a>"</code> and
<code>"<a href="#topic+Intervals_full-class">Intervals_full</a>"</code> classes.
</p>

<hr>
<h2 id='Intervals-class'>Classes &quot;Intervals&quot; and &quot;Intervals_full&quot;</h2><span id='topic+Intervals'></span><span id='topic+Intervals_full'></span><span id='topic+Intervals-class'></span><span id='topic+Intervals_full-class'></span><span id='topic++5B+2CIntervals-method'></span><span id='topic++5B+2CIntervals_full-method'></span><span id='topic++5B+3C-+2CIntervals+2CANY+2Cmissing+2CIntervals_virtual-method'></span><span id='topic++5B+3C-+2CIntervals_full+2CANY+2Cmissing+2CIntervals_virtual-method'></span><span id='topic+closed+3C-'></span><span id='topic+closed+3C-+2CIntervals-method'></span><span id='topic+closed+3C-+2CIntervals_full-method'></span><span id='topic+coerce+2CIntervals+2CIntervals_full-method'></span><span id='topic+coerce+2CIntervals_full+2CIntervals-method'></span><span id='topic+initialize+2CIntervals-method'></span><span id='topic+initialize+2CIntervals_full-method'></span>

<h3>Description</h3>

<p><code>"Intervals"</code> objects are two-column matrices which represent
sets, possibly non-disjoint and in no particular order, of intervals
on either the integers or the real line. All intervals in each object
have the same endpoint closure pattern. <code>"Intervals_full"</code>
objects are similar, but permit interval-by-interval endpoint closure
specification.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("Intervals",
    ...)</code>, or better, by using the constructor functions
<code><a href="#topic+Intervals">Intervals</a>(...)</code> and
<code><a href="#topic+Intervals_full">Intervals_full</a>(...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code>:</dt><dd><p>See <code>"<a href="#topic+Intervals_virtual-class">Intervals_virtual</a>"</code>.</p>
</dd>
<dt><code>closed</code>:</dt><dd>
<p>For <code>"Intervals"</code> objects, a two-element logical vector. For
<code>"Intervals_full"</code> objects, a two-column logical matrix with
the same dimensions as <code>.Data</code>. If omitted in a <code>new</code>
call, the <code>closed</code> slot will be initialized to an object of
appropriate type and size, with all entries <code>TRUE</code>. If
<code>closed</code> is a vector of length 1, or a vector of length 2 for
the <code>"Intervals_full"</code> class, an appropriate object will be
made by reusing the supplied values row-wise. See the example
below.
</p>
</dd>
<dt><code>type</code>:</dt><dd><p>See <code>"<a href="#topic+Intervals_virtual-class">Intervals_virtual</a>"</code>.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+Intervals_virtual-class">Intervals_virtual</a>"</code>, directly.
</p>
<p>Class <code>"<a href="methods.html#topic+matrix-class">matrix</a>"</code>, by class
<code>"Intervals_virtual"</code>, distance 2.
</p>
<p>Class <code>"<a href="methods.html#topic+array-class">array</a>"</code>, by class
<code>"Intervals_virtual"</code>, distance 3.
</p>
<p>Class <code>"<a href="methods.html#topic+structure-class">structure</a>"</code>, by class
<code>"Intervals_virtual"</code>, distance 4.
</p>
<p>Class <code>"<a href="methods.html#topic+vector-class">vector</a>"</code>, by class
<code>"Intervals_virtual"</code>, distance 5, with explicit coerce.
</p>


<h3>S3 methods</h3>

<p>As of R 2.8.1, it still does not seem possible to write S4 methods for
<code>rbind</code> or <code>c</code>. To concatenate sets of intervals into a
single sets, the S3 methods <code><a href="#topic+c.Intervals">c.Intervals</a></code> and
<code><a href="#topic+c.Intervals_full">c.Intervals_full</a></code> are provided. While <code>rbind</code> might
seem more natural, its S3 dispatch is non-standard and it could not be
used. Both methods are documented separately.
</p>


<h3>S4 methods</h3>


<dl>
<dt>[</dt><dd><p><code> signature(x = "Intervals")</code> </p>
</dd>
<dt>[</dt><dd><p><code> signature(x = "Intervals_full")</code> </p>
</dd>
<dt>[&lt;-</dt><dd><p><code> signature(x = "Intervals", i = "ANY", j = "missing", value = "Intervals_virtual")</code> </p>
</dd>
<dt>[&lt;-</dt><dd><p><code> signature(x = "Intervals_full", i = "ANY", j = "missing", value = "Intervals_virtual")</code> </p>
</dd>
<dt>adjust_closure</dt><dd><p><code> signature(x = "Intervals")</code> </p>
</dd>
<dt>adjust_closure</dt><dd><p><code> signature(x = "Intervals_full")</code> </p>
</dd>
<dt>closed&lt;-</dt><dd><p><code> signature(x = "Intervals")</code> </p>
</dd>
<dt>closed&lt;-</dt><dd><p><code> signature(x = "Intervals_full")</code> </p>
</dd>
<dt>coerce</dt><dd><p><code> signature(from = "Intervals", to = "Intervals_full")</code> </p>
</dd>
<dt>coerce</dt><dd><p><code> signature(from = "Intervals_full", to = "Intervals")</code> </p>
</dd>
<dt>empty</dt><dd><p><code> signature(x = "Intervals")</code> </p>
</dd>
<dt>empty</dt><dd><p><code> signature(x = "Intervals_full")</code> </p>
</dd>
<dt>initialize</dt><dd><p><code> signature(.Object = "Intervals")</code> </p>
</dd>
<dt>initialize</dt><dd><p><code> signature(.Object = "Intervals_full")</code> </p>
</dd>
<dt>size</dt><dd><p><code> signature(x = "Intervals")</code> </p>
</dd>
<dt>size</dt><dd><p><code> signature(x = "Intervals_full")</code> </p>
</dd>






















</dl>



<h3>Warning</h3>

<p>Validity checking takes place when, for example, using the
<code>type&lt;-</code> replacement accessor: if one attempts to set type to
<code>"Z"</code> but the endpoint matrix contains non-integer values, an
error is generated. Because accessors are not used for the endpoint
matrix itself, though, it is possible to create invalid <code>"Z"</code>
objects by setting endpoints to inappropriate values.
</p>


<h3>Note</h3>

<p>We do not currently permit an integer data type for the endpoints
matrix, even when <code>type == "Z"</code>, because this creates
complications when taking complements &ndash; which is most easily handled
through the use of <code>-Inf</code> and <code>Inf</code>. This is particularly
awkward for objects of class <code>"Intervals"</code>, since current endpoint
closure settings may not permit inclusion of the minimal/maximal
integer. This issue may be addressed, however, in future updates. (We
do, however, check that endpoints are congruent to 0 mod 1 when
<code>type == "Z"</code>.)
</p>
<p>When creating object, non-matrix endpoint sources will be converted to
a two-column matrix, for convenience. Recycling is supported for the
<code>closed</code> slot when creating new objects.
</p>


<h3>See Also</h3>

<p>See <code>"<a href="#topic+Intervals_virtual-class">Intervals_virtual</a>"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# The "Intervals" class

i &lt;- Intervals(
               matrix(
                      c(1,2,  
                        3,5,
                        4,6,
                        8,9
                        ),
                      byrow = TRUE,
                      ncol = 2
               ),
               closed = c( TRUE, TRUE ),
               type = "Z"
               )

# Row subsetting preserves class. Column subsetting causes coercion to
# "matrix" class. 

i
i[1:2,]
i[,1:2]

# Full endpoint control

j &lt;- as( i, "Intervals_full" )
closed(j)[ 3:4, 2 ] &lt;- FALSE
closed(j)[ 4, 1 ] &lt;- FALSE
j

# Rownames may be used

rownames(j) &lt;- c( "apple", "banana", "cherry", "date" )
j

# Assignment preserves class, coercing if necessary

j[2:3] &lt;- i[1:2,]
j

</code></pre>

<hr>
<h2 id='intervals-package'>
Tools for working with points and intervals
</h2><span id='topic+intervals-package'></span><span id='topic+intervals'></span>

<h3>Description</h3>

<p>Tools for working with and comparing sets of points and intervals.
</p>


<h3>Details</h3>

<p>Index:
</p>

<dl>
<dt><code><a href="#topic+Intervals-class">Intervals-class</a></code></dt><dd><p>Classes <code>"Intervals"</code> and <code>"Intervals_full"</code>.</p>
</dd>
<dt><code><a href="#topic+Intervals_virtual-class">Intervals_virtual-class</a></code></dt><dd><p>Class <code>"Intervals_virtual"</code>.</p>
</dd>
<dt><code><a href="#topic+Intervals_virtual_or_numeric-class">Intervals_virtual_or_numeric-class</a></code></dt><dd><p>Class union <code>"Intervals_virtual_or_numeric"</code>.</p>
</dd>
<dt><code><a href="#topic+as.matrix.Intervals_virtual">as.matrix</a></code></dt><dd><p>Coerce endpoints to a matrix.</p>
</dd>
<dt><code><a href="#topic+c.Intervals">c</a></code></dt><dd><p>Concatenate different sets of intervals.</p>
</dd>
<dt><code><a href="#topic+close_intervals">close_intervals</a></code></dt><dd><p>Re-represent integer intervals with open or closed endpoints.</p>
</dd>
<dt><code><a href="#topic+closed">closed</a></code></dt><dd><p>Accessor for <code>closed</code> slot: closure vector/matrix.</p>
</dd>
<dt><code><a href="#topic+clusters">clusters</a></code></dt><dd><p>Identify clusters in a collection of positions or intervals.</p>
</dd>
<dt><code><a href="#topic+contract">contract</a></code></dt><dd><p>Contract sets.</p>
</dd>
<dt><code><a href="#topic+distance_to_nearest">distance_to_nearest</a></code></dt><dd><p>Compute distance to nearest position in a set of intervals.</p>
</dd>
<dt><code><a href="#topic+empty">empty</a></code></dt><dd><p>Identify empty interval rows.</p>
</dd>
<dt><code><a href="#topic+expand">expand</a></code></dt><dd><p>Expand sets.</p>
</dd>
<dt><code><a href="#topic+interval_complement">interval_complement</a></code></dt><dd><p>Compute the complement of a set of intervals.</p>
</dd>
<dt><code><a href="#topic+interval_difference">interval_difference</a></code></dt><dd><p>Compute set difference.</p>
</dd>
<dt><code><a href="#topic+interval_included">interval_included</a></code></dt><dd><p>Assess inclusion of one set of intervals with respect to another.</p>
</dd>
<dt><code><a href="#topic+interval_intersection">interval_intersection</a></code></dt><dd><p>Compute the intersection of one or more sets of intervals.</p>
</dd>
<dt><code><a href="#topic+interval_overlap">interval_overlap</a></code></dt><dd><p>Assess which query intervals overlap which targets.</p>
</dd>
<dt><code><a href="#topic+interval_union">interval_union</a></code></dt><dd><p>Compute the union of intervals in one or more interval matrices.</p>
</dd>
<dt><code><a href="Matrix.html#topic+is.na">is.na</a></code></dt><dd><p>Identify interval rows with <code>NA</code> endpoints.</p>
</dd>
<dt><code><a href="#topic+plot.Intervals">plot</a></code></dt><dd><p>S3 plotting methods for intervals objects.</p>
</dd>
<dt><code><a href="#topic+reduce">reduce</a></code></dt><dd><p>Compactly re-represent the points in a set of intervals.</p>
</dd>
<dt><code><a href="#topic+sgd">sgd</a></code></dt><dd><p>Yeast gene model sample data.</p>
</dd>
<dt><code><a href="#topic+size">size</a></code></dt><dd><p>Compute interval sizes.</p>
</dd>
<dt><code><a href="#topic+split.Intervals_virtual">split</a></code></dt><dd><p>Split an intervals object according to a factor.</p>
</dd>
<dt><code><a href="#topic+type">type</a></code></dt><dd><p>Accessor for <code>type</code> slot: Z or R.</p>
</dd>
<dt><code><a href="#topic+which_nearest">which_nearest</a></code></dt><dd><p>Identify nearest member(s) in a set of intervals.</p>
</dd>
</dl>

<p>Further information is available in the following vignettes:
</p>

<dl>
<dt><code>intervals_overview</code></dt><dd><p>Overview of the intervals package.</p>
</dd>    
</dl>



<h3>Acknowledgments</h3>

<p>Thanks to Julien Gagneur, Simon Anders, and Wolfgang Huber for
numerous helpful suggestions about the package content and code.
</p>


<h3>Author(s)</h3>

<p>Richard Bourgon &lt;bourgon@ebi.ac.uk&gt;
</p>


<h3>See Also</h3>

<p>See the <span class="pkg">genomeIntervals</span> package in Bioconductor, which extends
the functionality of this package.
</p>

<hr>
<h2 id='plot.Intervals'>Plotting methods for interval objects</h2><span id='topic+plot'></span><span id='topic+plot.Intervals'></span><span id='topic+plot.Intervals_full'></span><span id='topic+plot+2CIntervals+2Cmissing-method'></span><span id='topic+plot+2CIntervals_full+2Cmissing-method'></span><span id='topic+plot+2CIntervals+2CANY-method'></span><span id='topic+plot+2CIntervals_full+2CANY-method'></span>

<h3>Description</h3>

<p>S3 methods for plotting <code>"Intervals"</code> and <code>"Intervals_full"</code>
objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Intervals'
plot(x, y, ...)
## S3 method for class 'Intervals_full'
plot(
     x, y = NULL,
     axes = TRUE,
     xlab = "", ylab = "",
     xlim = NULL, ylim = NULL,
     col = "black", lwd = 1,
     cex = 1,
     use_points = TRUE,
     use_names = TRUE,
     names_cex = 1,
     ...
     )

## S4 method for signature 'Intervals,missing'
plot(x, y, ...)
## S4 method for signature 'Intervals_full,missing'
plot(x, y, ...)
## S4 method for signature 'Intervals,ANY'
plot(x, y, ...)
## S4 method for signature 'Intervals_full,ANY'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.Intervals_+3A_x">x</code></td>
<td>
<p>An <code>"Intervals"</code> or <code>"Intervals_full"</code> object.</p>
</td></tr>
<tr><td><code id="plot.Intervals_+3A_y">y</code></td>
<td>

<p>Optional vector of heights at which to plot intervals. If omitted,
<code>y</code> will be automatically computed to generate a compact plot
but with no overlap.
</p>
</td></tr>
<tr><td><code id="plot.Intervals_+3A_axes">axes</code></td>
<td>
<p>As for <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.</p>
</td></tr> 
<tr><td><code id="plot.Intervals_+3A_xlab">xlab</code></td>
<td>
<p>As for <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.</p>
</td></tr>
<tr><td><code id="plot.Intervals_+3A_ylab">ylab</code></td>
<td>
<p>As for <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.</p>
</td></tr>
<tr><td><code id="plot.Intervals_+3A_xlim">xlim</code></td>
<td>
<p>As for <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.</p>
</td></tr>
<tr><td><code id="plot.Intervals_+3A_ylim">ylim</code></td>
<td>

<p>If not explicitly supplied, <code>ylim</code> is set to the maximum value
required for intervals which are visible for the given <code>xlim</code>.
</p>
</td></tr>
<tr><td><code id="plot.Intervals_+3A_col">col</code></td>
<td>

<p>Color used for segments and endpoint points and interiors. Recycled
if necessary.
</p>
</td></tr>
<tr><td><code id="plot.Intervals_+3A_lwd">lwd</code></td>
<td>
<p>Line width for segments. See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.Intervals_+3A_cex">cex</code></td>
<td>

<p>Endpoint magnification. Only relevant if <code>use_points =
      TRUE</code>. See <code><a href="graphics.html#topic+par">par</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.Intervals_+3A_use_points">use_points</code></td>
<td>
<p>Should points be plotted at interval endpoints?</p>
</td></tr>
<tr><td><code id="plot.Intervals_+3A_use_names">use_names</code></td>
<td>

<p>Should <code>rownames(x)</code> by used for segment labels in the plot?
</p>
</td></tr>
<tr><td><code id="plot.Intervals_+3A_names_cex">names_cex</code></td>
<td>

<p>Segment label magnification. Only relevant if <code>use_names =
      TRUE</code>.
</p>
</td></tr>
<tr><td><code id="plot.Intervals_+3A_...">...</code></td>
<td>
<p>Other arguments for <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Intervals with <code>NA</code> for either endpoint are not
plotted. Vertical placement is on the integers, beginning with 0.
</p>


<h3>Value</h3>

<p>None.</p>


<h3>Examples</h3>

<pre><code class='language-R'># Note plot symbol for empty interval in 'from'.

from &lt;- Intervals(
                  matrix(
                         c(
                            2,  8,
                            8,  9,
                            6,  9,
                           11, 12,
                            3,  3
                           ),
                         ncol = 2, byrow = TRUE
                         ),
                  closed = c( FALSE, TRUE ),
                  type = "Z"
                  )

rownames(from) &lt;- c("a","b","c","d","e")

to &lt;- Intervals(
                matrix(
                       c(
                         2,  8,
                         3,  4,
                         5, 10
                         ),
                       ncol = 2, byrow = TRUE
                       ),
                closed = c( FALSE, TRUE  ),
                type = "Z"
                )

rownames(to) &lt;- c("x","y","z")

empty(from)

plot(
     c(from,to),
     col = rep(1:2, c(nrow(from), nrow(to)))
     )

legend("topright", c("from","to"), col=1:2, lwd=1)

# More intervals. The maximal height shown is adapted to the plotting
# window.

B &lt;- 10000
left &lt;- runif( B, 0, 1e5 )
right &lt;- left + rexp( B, rate = 1/10 )
x &lt;- Intervals( cbind( left, right ) )

plot(x, use_points=FALSE)
plot(x, use_points=FALSE, xlim = c(0, 500))
</code></pre>

<hr>
<h2 id='reduce'>Compactly re-represent the points in a set of intervals</h2><span id='topic+reduce'></span><span id='topic+reduce+2CIntervals_virtual-method'></span>

<h3>Description</h3>

<p>In general, <code>"<a href="#topic+Intervals-class">Intervals</a>"</code> and
<code>"<a href="#topic+Intervals_full-class">Intervals_full</a>"</code> objects may be redundant, the
intervals they contain may be in arbitrary order, and they may contain
non-informative intervals for which one or both endpoints are
<code>NA</code>. The <code>reduce</code> function re-represents the underlying
subsets of the integers or the real line in the unique, minimal form,
removing intervals with <code>NA</code> endpoints (with warning).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Intervals_virtual'
reduce( x, check_valid = TRUE )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reduce_+3A_x">x</code></td>
<td>
<p> An <code>"Intervals"</code> or <code>"Intervals_full"</code> object.</p>
</td></tr>
<tr><td><code id="reduce_+3A_check_valid">check_valid</code></td>
<td>

<p>Should <code><a href="methods.html#topic+validObject">validObject</a></code> be called before passing to
compiled code? Also see <code><a href="#topic+interval_overlap">interval_overlap</a></code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single object of appropriate class, compactly representing the
union of all intervals in <code>x</code>. All intervals in <code>reduce(x)</code>
have numeric (i.e., not <code>NA</code>) endpoints.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+interval_union">interval_union</a></code>, which is really just concatenates its
arguments and then calls <code>reduce</code>.
</p>

<hr>
<h2 id='sgd'>Yeast gene model sample data</h2><span id='topic+sgd'></span>

<h3>Description</h3>

<p>This data set contains a data frame describing a subset of
the chromosome feature data represented in Fall 2007 version of
&lsquo;<span class="file">saccharomyces_cerevisiae.gff</span>&rsquo;, available for download from the
<em>Saccharomyces</em> Genome Database (<a href="https://www.yeastgenome.org:443/">https://www.yeastgenome.org:443/</a>). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sgd)</code></pre>


<h3>Format</h3>

<p>A data frame with 14080 observations on the following 8 variables.
</p>

<dl>
<dt><code>SGDID</code></dt><dd><p>SGD feature ID.</p>
</dd>
<dt><code>type</code></dt><dd>
<p>Only four feature types have been retatined: <code>"CDS"</code>,
<code>"five_prime_UTR_intron"</code>, <code>"intron"</code>, and <code>"ORF"</code>. Note
that <code>"ORF"</code> correspond to a whole gene while <code>"CDS"</code>, to an
exon. <em>S. cerevisae</em> does not, however, have many
multi-exonic genes.
</p>
</dd>
<dt><code>feature_name</code></dt><dd><p>A character vector</p>
</dd>
<dt><code>parent_feature_name</code></dt><dd>
<p>The <code>feature_name</code> of the a larger element to which the
current feature belongs. All retained <code>"CDS"</code> entries, for
example, belong to an <code>"ORF"</code> entry.
</p>
</dd>
<dt><code>chr</code></dt><dd>
<p>The chromosome on which the feature occurs.
</p>
</dd>
<dt><code>start</code></dt><dd><p>Feature start base.</p>
</dd>
<dt><code>stop</code></dt><dd><p>Feature stop base.</p>
</dd>
<dt><code>strand</code></dt><dd><p>Is the feature on the Watson or Crick strand?</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
# An example to compute "promoters", defined to be the 500 bases
# upstream from an ORF annotation, provided these bases don't intersect
# another orf. See documentation for the sgd data set for more details
# on the annotation set.

use_chr &lt;- "chr01"

data( sgd )
sgd &lt;- subset( sgd, chr == use_chr )

orf &lt;- Intervals(
                 subset( sgd, type == "ORF", c( "start", "stop" ) ),
                 type = "Z"
                 )
rownames( orf ) &lt;- subset( sgd, type == "ORF" )$feature_name

W &lt;- subset( sgd, type == "ORF", "strand" ) == "W"

promoters_W &lt;- Intervals(
                         cbind( orf[W,1] - 500, orf[W,1] - 1 ),
                         type = "Z"
                         )

promoters_W &lt;- interval_intersection(
                                     promoters_W,
                                     interval_complement( orf )
                                     )

# Many Watson-strand genes have another ORF upstream at a distance of
# less than 500 bp

hist( size( promoters_W ) )

# All CDS entries are completely within their corresponding ORF entry.

cds_W &lt;- Intervals(
                 subset( sgd, type == "CDS" &amp; strand == "W", c( "start", "stop" ) ),
                 type = "Z"
                 )
rownames( cds_W ) &lt;- NULL

interval_intersection( cds_W, interval_complement( orf[W,] ) )

</code></pre>

<hr>
<h2 id='size'>Compute interval sizes</h2><span id='topic+size'></span><span id='topic+size+2CIntervals-method'></span><span id='topic+size+2CIntervals_full-method'></span>

<h3>Description</h3>

<p>Compute the size, in either Z or R as appropriate, for each interval
in an interval matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Intervals'
size(x, as = type(x))

## S4 method for signature 'Intervals_full'
size(x, as = type(x))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="size_+3A_x">x</code></td>
<td>
<p>An <code>"Intervals"</code> or <code>"Intervals_full"</code> object.</p>
</td></tr>
<tr><td><code id="size_+3A_as">as</code></td>
<td>

<p>Should the intervals be thought of as in Z or R? This is usually
determined automatically from the <code>type</code> slot, but because
changing type may cause object copying, it is sometimes convenient
to temporarily override this slot without actually resetting it.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For type <code>"Z"</code> objects, counting measure; for type <code>"R"</code>
objects, Lebesgue measure. For type <code>"Z"</code> objects, intervals of
form (<em>a</em>,<em>a</em>] and (<em>a</em>,<em>a</em>) are both of length
0.
</p>


<h3>Value</h3>

<p>A numeric vector with length equal to <code>nrow(x)</code>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+empty">empty</a></code> to identify empty intervals. Note that when
<code>type(x) == "R"</code>, a size of 0 does not imply that an interval is
empty.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z1 &lt;- Intervals( cbind( 1, 1:3 ), type = "Z" )
z2 &lt;- z1; closed(z2)[1] &lt;- FALSE
z3 &lt;- z1; closed(z3) &lt;- FALSE

size(z1)
size(z2)
size(z3)

r1 &lt;- z1; type(r1) &lt;- "R"
r2 &lt;- z2; type(r2) &lt;- "R"
r3 &lt;- z3; type(r3) &lt;- "R"

size(r1)
size(r2)
size(r3)

s1 &lt;- Intervals_full( matrix( 1, 3, 2 ), type = "Z" )
closed(s1)[2,2] &lt;- FALSE
closed(s1)[3,] &lt;- FALSE

size(s1)
</code></pre>

<hr>
<h2 id='split'>Split an intervals object according to a factor</h2><span id='topic+split'></span><span id='topic+split.Intervals_virtual'></span><span id='topic+split+2CIntervals_virtual-method'></span>

<h3>Description</h3>

<p>S3 and S4 methods for splitting <code>"Intervals"</code> or
<code>"Intervals_full"</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Intervals_virtual'
split(x, f, drop = FALSE, ...)

## S4 method for signature 'Intervals_virtual'
split(x, f, drop = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_+3A_x">x</code></td>
<td>
 <p><code>"Intervals"</code> or <code>"Intervals_full"</code> objects. </p>
</td></tr>
<tr><td><code id="split_+3A_f">f</code></td>
<td>
<p> Passed to <code><a href="base.html#topic+split.data.frame">split.data.frame</a></code>. </p>
</td></tr>
<tr><td><code id="split_+3A_drop">drop</code></td>
<td>
<p> Passed to <code><a href="base.html#topic+split.data.frame">split.data.frame</a></code>. </p>
</td></tr>
<tr><td><code id="split_+3A_...">...</code></td>
<td>
<p> Passed to <code><a href="base.html#topic+split.data.frame">split.data.frame</a></code>. </p>
</td></tr>  
</table>


<h3>Value</h3>

<p> A list of objects of the same class as <code>x</code>, split by the
levels of <code>f</code>. Until R 2.15, special handling was not
required. Subsequent changes to the <span class="pkg">base</span> package
<code><a href="#topic+split">split</a></code> function required an explicit method here, but
code already provided by <code><a href="base.html#topic+split.data.frame">split.data.frame</a></code> was
sufficient. </p>

<hr>
<h2 id='which_nearest'>Identify nearest member(s) in a set of intervals</h2><span id='topic+which_nearest'></span><span id='topic+which_nearest+2Cnumeric+2CIntervals_virtual-method'></span><span id='topic+which_nearest+2CIntervals_virtual+2CIntervals_virtual-method'></span><span id='topic+which_nearest+2CIntervals_virtual+2Cnumeric-method'></span><span id='topic+which_nearest+2Cnumeric+2Cnumeric-method'></span>

<h3>Description</h3>

<p>For each point or interval in the <code>from</code> argument,
identify the nearest member or members (in case of ties) of the
interval set in the <code>to</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'numeric,Intervals_virtual'
which_nearest(from, to, check_valid = TRUE)

## S4 method for signature 'Intervals_virtual,numeric'
which_nearest(from, to, check_valid = TRUE)

## S4 method for signature 'Intervals_virtual,Intervals_virtual'
which_nearest(from, to, check_valid = TRUE)

## S4 method for signature 'numeric,numeric'
which_nearest(from, to, check_valid = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="which_nearest_+3A_from">from</code></td>
<td>
<p>An object of appropriate type.</p>
</td></tr>
<tr><td><code id="which_nearest_+3A_to">to</code></td>
<td>
<p>An object of appropriate type.</p>
</td></tr>
<tr><td><code id="which_nearest_+3A_check_valid">check_valid</code></td>
<td>

<p>Should <code><a href="methods.html#topic+validObject">validObject</a></code> be called before passing to
compiled code? Also see <code><a href="#topic+interval_overlap">interval_overlap</a></code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with three columns: <code>distance_to_nearest</code>,
<code>which_nearest</code>, and <code>which_overlap</code>. The last two are
actually lists, since there may be zero, one, or more
nearest/overlapping intervals in the <code>to</code> object for any given
interval in <code>from</code>.
</p>
<p>Empty intervals in <code>to</code>, or intervals with <code>NA</code> endpoints,
produce a <code>NA</code> distance result, and no nearest or overlapping
hits. 
</p>


<h3>Note</h3>

<p>(v. 0.11.0) The code used for the <code>distance_to_nearest</code> column
here is completely distinct from that used for the original
<code><a href="#topic+distance_to_nearest">distance_to_nearest</a></code> function. For the moment, they will
co-exist for testing purposes, but this function's code will
eventually replace the older code.
</p>
<p>Note that a naive way of implementing <code>which_nearest</code> would be to
use the simpler, old implementation of <code>distance_to_nearest</code>, use
<code>expand</code> to grow all intervals by the correspnoding amount, and
then use <code>interval_overlap</code> to identify target. This approach,
however, will miss a small fraction of targets due to floating point
issues.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Point to interval. Empty rows, or those with NA endpoints, do not
# generate hits. Note that distance_to_nearest can be 0 but without
# overlap, depending on endpoint closure.

to &lt;- Intervals_full( c(-1,0,NA,5,-1,3,10,Inf) )
closed(to)[1,] &lt;- FALSE
closed(to)[2,2] &lt;- FALSE
from &lt;- c( NA, -3:5 )

to
cbind( from, which_nearest( from, to ) )

# Completely empty to object

which_nearest( from, to[1,] )

# Interval to interval

from &lt;- Intervals( c(-Inf,-Inf,3.5,-1,1,4) )
from
which_nearest( from, to )

# Checking behavior with ties

from &lt;- Intervals_full( c(2,2,4,4,3,3,5,5) )
closed( from )[2:3,] &lt;- FALSE
to &lt;- Intervals_full( c(0,0,6,6,1,1,7,8) )
closed( to )[2:3,] &lt;- FALSE

from
to
which_nearest( from, to )

from &lt;- Intervals_full( c(1,3,6,2,4,7) )
to &lt;- Intervals_full( c(4,4,5,5) )
closed( to )[1,] &lt;- FALSE

from
to
which_nearest( from, to )
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
