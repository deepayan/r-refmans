<!DOCTYPE html><html><head><title>Help for package PINstimation</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PINstimation}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#PINstimation-package'><p>An R package for estimating the probability of informed trading</p></a></li>
<li><a href='#adjpin'><p>Estimation of adjusted PIN model</p></a></li>
<li><a href='#dailytrades'><p>Example of quarterly data</p></a></li>
<li><a href='#data.series-class'><p>List of dataset objects</p></a></li>
<li><a href='#dataset-class'><p>Simulated data object</p></a></li>
<li><a href='#detecting-layers'><p>Layer detection in trade-data</p></a></li>
<li><a href='#estimate.adjpin-class'><p>AdjPIN estimation results</p></a></li>
<li><a href='#estimate.mpin-class'><p>MPIN estimation results</p></a></li>
<li><a href='#estimate.mpin.ecm-class'><p>MPIN estimation results (ECM)</p></a></li>
<li><a href='#estimate.pin-class'><p>PIN estimation results</p></a></li>
<li><a href='#estimate.vpin-class'><p>VPIN estimation results</p></a></li>
<li><a href='#factorizations'><p>Factorizations of the different PIN likelihood functions</p></a></li>
<li><a href='#generatedata_adjpin'><p>Simulation of AdjPIN model data.</p></a></li>
<li><a href='#generatedata_mpin'><p>Simulation of MPIN model data</p></a></li>
<li><a href='#get_posteriors'><p>Posterior probabilities for PIN and MPIN estimates</p></a></li>
<li><a href='#hfdata'><p>High-frequency trade-data</p></a></li>
<li><a href='#initials_adjpin'><p>AdjPIN initial parameter sets of Ersan &amp; Ghachem (2022b)</p></a></li>
<li><a href='#initials_adjpin_cl'><p>AdjPIN initial parameter sets of Cheng and Lai (2021)</p></a></li>
<li><a href='#initials_adjpin_rnd'><p>AdjPIN random initial sets</p></a></li>
<li><a href='#initials_mpin'><p>MPIN initial parameter sets of Ersan (2016)</p></a></li>
<li><a href='#initials_pin_ea'><p>Initial parameter sets of Ersan &amp; Alici (2016)</p></a></li>
<li><a href='#initials_pin_gwj'><p>Initial parameter set of Gan et al.(2015)</p></a></li>
<li><a href='#initials_pin_yz'><p>Initial parameter sets of Yan and Zhang (2012)</p></a></li>
<li><a href='#mpin_ecm'><p>MPIN model estimation via an ECM algorithm</p></a></li>
<li><a href='#mpin_ml'><p>MPIN model estimation via standard ML methods</p></a></li>
<li><a href='#pin'><p>PIN estimation - custom initial parameter sets</p></a></li>
<li><a href='#pin_bayes'><p>PIN estimation - Bayesian approach</p></a></li>
<li><a href='#pin_ea'><p>PIN estimation - initial parameter sets of Ersan &amp; Alici (2016)</p></a></li>
<li><a href='#pin_gwj'><p>PIN estimation - initial parameter set of Gan et al. (2015)</p></a></li>
<li><a href='#pin_yz'><p>PIN estimation - initial parameter sets of Yan &amp; Zhang (2012)</p></a></li>
<li><a href='#set_display_digits'><p>Package-wide number of digits</p></a></li>
<li><a href='#trade_classification'><p>Classification and aggregation of high-frequency data</p></a></li>
<li><a href='#vpin'><p>Estimation of Volume-Synchronized PIN model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-03-20</td>
</tr>
<tr>
<td>Title:</td>
<td>Estimation of the Probability of Informed Trading</td>
</tr>
<tr>
<td>Author:</td>
<td>Montasser Ghachem <a href="https://orcid.org/0000-0001-6991-3316"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Oguz Ersan <a href="https://orcid.org/0000-0003-3135-5317"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Montasser Ghachem &lt;montasser.ghachem@pinstimation.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A comprehensive bundle of utilities for the estimation of probability of informed trading models: original PIN in Easley and O'Hara (1992) and Easley et al. (1996); Multilayer PIN (MPIN) in Ersan (2016); Adjusted PIN (AdjPIN) in Duarte and Young (2009); and volume-synchronized PIN (VPIN) in Easley et al. (2011, 2012). Implementations of various estimation methods suggested in the literature are included. Additional compelling features comprise posterior probabilities, an implementation of an expectation-maximization (EM) algorithm, and PIN decomposition into layers, and into bad/good components. Versatile data simulation tools, and trade classification algorithms are among the supplementary utilities. The package provides fast, compact, and precise utilities to tackle the sophisticated, error-prone, and time-consuming estimation procedure of informed trading, and this solely using the raw trade-level data. </td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.pinstimation.com">https://www.pinstimation.com</a>,
<a href="https://github.com/monty-se/PINstimation">https://github.com/monty-se/PINstimation</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/monty-se/PINstimation/issues">https://github.com/monty-se/PINstimation/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LazyDataCompression:</td>
<td>xz</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rdpack, knitr, methods, skellam, nloptr, furrr, future, dplyr,
rmarkdown, coda</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>fansi, htmltools</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-20 22:39:05 UTC; road_</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-20 23:10:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='PINstimation-package'>An R package for estimating the probability of informed trading</h2><span id='topic+PINstimation-package'></span>

<h3>Description</h3>

<p>The package provides utilities for the estimation
of probability of informed trading measures: original PIN (<code>PIN</code>) as
introduced by Easley and Ohara (1992) and
Easley et al. (1996)
, multilayer PIN (<code>MPIN</code>) as introduced by
Ersan (2016), adjusted PIN (<code>AdjPIN</code>) model
as introduced in Duarte and Young (2009), and
volume-synchronized PIN (<code>VPIN</code>) as introduced by
Easley et al. (2011) and
Easley et al. (2012). Estimations of
<code>PIN</code>, <code>MPIN</code>, and <code>adjPIN</code> are subject to floating-point exception
error, and are sensitive to the choice of initial values.
Therefore, researchers developed factorizations of the model likelihood
functions as well as algorithms for determining initial parameter sets for
the maximum likelihood estimation - (MLE henceforth).
<br /><br /><br /> As for the factorizations, the package includes three
different factorizations of the <code>PIN</code> likelihood function :<code>fact_pin_eho()</code>
as in Easley et al. (2010), <code>fact_pin_lk()</code> as in
Lin and Ke (2011), and <code>fact_pin_e()</code> as in
Ersan (2016);
one factorization for <code>MPIN</code> likelihood function: <code>fact_mpin()</code> as in
Ersan (2016); and one factorization for
<code>AdjPIN</code> likelihood function: <code>fact_adjpin()</code> as in
Ersan and Ghachem (2022b).
<br /><br /> The package implements three algorithms to generate initial
parameter sets for the MLE of the <code>PIN</code> model in: <code>initials_pin_yz()</code>
for the algorithm of Yan and Zhang (2012),
<code>initials_pin_gwj()</code> for the algorithm of
Gan et al. (2015), and <code>initials_pin_ea()</code> for the
algorithm of Ersan and Alici (2016). As for the
initial parameter sets for the MLE of the <code>MPIN</code> model, the function
<code>initials_mpin()</code> implements a multilayer extension of the algorithm of
Ersan and Alici (2016). Finally, three functions
implement three algorithms of initial parameter sets for the MLE of
the <code>AdjPIN</code> model, namely <code>initials_adjpin()</code> for the algorithm in
Ersan and Ghachem (2022b), <code>initials_adjpin_cl()</code>
for the algorithm of Cheng and Lai (2021); and
<code>initials_adjpin_rnd()</code> for randomly generated initial parameter sets.
The choice of the initial parameter sets can be done directly, either using
specific functions implementing MLE for the PIN model, such as, <code>pin_yz()</code>,
<code>pin_gwj()</code>, <code>pin_ea()</code>; or through the argument <code>initialsets</code> in generic
functions implementing MLE for the <code>MPIN</code> and <code>AdjPIN</code> models, namely
<code>mpin_ml()</code>, and <code>adjpin()</code>.
Besides, <code>PIN</code>, <code>MPIN</code> and <code>AdjPIN</code> models can be estimated using custom
initial parameter set(s) provided by the user and fed through
the argument <code>initialsets</code> for the functions <code>pin()</code>, <code>mpin_ml()</code> and
<code>adjpin()</code>. Through the function <code>get_posteriors()</code>, the package also
allows users to assign, for each day in the sample, the posterior
probability that the day is a no-information day, good-information day
and bad-information day.
<br /><br /> As an alternative to the standard maximum likelihood estimation,
estimation via expectation conditional maximization algorithm (<code>ECM</code>)
is suggested in Ghachem and Ersan (2022a), and is
implemented through the function <code>mpin_ecm()</code> for the <code>MPIN</code> model, and
the function <code>adjpin()</code> for the <code>AdjPIN</code> model.
<br /><br /> Dataset(s) of daily aggregated numbers of buys and sells with user
determined number of information layers can be simulated with the function
<code>generatedata_mpin()</code> for the <code>MPIN</code> (<code>PIN</code>) model;
and <code>generatedata_adjpin()</code>
for the <code>AdjPIN</code> model. The output of these functions contains the
theoretical parameters used in the data generation, empirical parameters
computed from the generated data, alongside the generated data itself.
Data simulation functions allow for broad customization
to produce data that fit the user's preferences. Therefore, simulated data
series can be utilized in comparative analyses for the applied methods in
different scenarios. Alternatively, the user can use two example datasets
preloaded in the package: <code>dailytrades</code> as a representative of a quarterly
trade data with daily buys and sells; and <code>hfdata</code> as a simulated
high-frequency dataset comprising <code style="white-space: pre;">&#8288;100 000&#8288;</code> trades.
<br /><br /> Finally, the package provides two functions to deal with
high-frequency data.
First, the function <code>vpin()</code> estimates and provides detailed output on the
order flow toxicity metric, volume-synchronized probability of informed
trading, as developed in Easley et al. (2011) and
Easley et al. (2012). Second, the function
<code>aggregate_trades()</code> aggregates the high-frequency trade-data into daily
data using several trade classification algorithms, namely the <code>tick</code>
algorithm, the <code>quote</code> algorithm, <code>LR</code> algorithm
(Lee and Ready 1991) and the <code>EMO</code>
algorithm (Ellis et al. 2000).
<br /><br /> The package provides fast, compact, and precise utilities to tackle
the sophisticated, error-prone, and time-consuming estimation procedure of
informed trading, and this solely using the raw trade-level data.
Ghachem and Ersan (2022b)
provides comprehensive overview of the package: it first
details the underlying theoretical background, provides a thorough
description of the functions, before using them to tackle relevant
research questions.
</p>


<h3>Functions</h3>


<ul>
<li> <p><a href="#topic+adjpin">adjpin</a> estimates the adjusted probability of informed trading
(<code>AdjPIN</code>) of the model of Duarte and Young (2009).
</p>
</li>
<li> <p><a href="#topic+aggregate_trades">aggregate_trades</a> aggregates the trading data per day using
different trade classification algorithms.
</p>
</li>
<li> <p><a href="#topic+detectlayers_e">detectlayers_e</a> detects the number of information layers present
in the trade-data using the algorithm in
Ersan (2016).
</p>
</li>
<li> <p><a href="#topic+detectlayers_eg">detectlayers_eg</a> detects the number of information layers present
in the trade-data using the algorithm in
Ersan and Ghachem (2022a).
</p>
</li>
<li> <p><a href="#topic+detectlayers_ecm">detectlayers_ecm</a> detects the number of information layers
present in the trade-data using the expectation-conditional maximization
algorithm in Ghachem and Ersan (2022a).
</p>
</li>
<li> <p><a href="#topic+fact_adjpin">fact_adjpin</a> returns the <code>AdjPIN</code> factorization of the likelihood
function by Ersan and Ghachem (2022b) evaluated at the
provided data and parameter sets.
</p>
</li>
<li> <p><a href="#topic+fact_pin_e">fact_pin_e</a> returns the <code>PIN</code> factorization of the likelihood
function by Ersan (2016) evaluated at
the provided data and parameter sets.
</p>
</li>
<li> <p><a href="#topic+fact_pin_eho">fact_pin_eho</a> returns the <code>PIN</code> factorization of the likelihood
function by Easley et al. (2010) evaluated at the
provided data and parameter sets.
</p>
</li>
<li> <p><a href="#topic+fact_pin_lk">fact_pin_lk</a> returns the <code>PIN</code> factorization of the likelihood
function by Lin and Ke (2011) evaluated
at the provided data and parameter sets.
</p>
</li>
<li> <p><a href="#topic+fact_mpin">fact_mpin</a> returns the <code>MPIN</code> factorization of the likelihood
function by Ersan (2016) evaluated at the
provided data and parameter sets.
</p>
</li>
<li> <p><a href="#topic+generatedata_adjpin">generatedata_adjpin</a> generates a dataset object or a list of
dataset objects generated according to the assumptions of the <code>AdjPIN</code> model.
</p>
</li>
<li> <p><a href="#topic+generatedata_mpin">generatedata_mpin</a> generates a dataset object or a list of
dataset objects generated according to the assumptions of the <code>MPIN</code> model.
</p>
</li>
<li> <p><a href="#topic+get_posteriors">get_posteriors</a> computes, for each day in the sample, the
posterior probabilities that it is a no-information day, good-information day
and bad-information day respectively.
</p>
</li>
<li> <p><a href="#topic+initials_adjpin">initials_adjpin</a> generates the initial parameter sets for the
<code>ML</code>/<code>ECM</code> estimation of the adjusted probability of informed trading using
the algorithm of Ersan and Ghachem (2022b).
</p>
</li>
<li> <p><a href="#topic+initials_adjpin_cl">initials_adjpin_cl</a> generates the initial parameter sets for the
<code>ML</code>/<code>ECM</code> estimation of the adjusted probability of informed trading using
an extension of the algorithm of
Cheng and Lai (2021).
</p>
</li>
<li> <p><a href="#topic+initials_adjpin_rnd">initials_adjpin_rnd</a> generates random parameter sets for the
estimation of the <code>AdjPIN</code> model.
</p>
</li>
<li> <p><a href="#topic+initials_mpin">initials_mpin</a> generates initial parameter sets for the maximum
likelihood estimation of the multilayer
probability of informed trading (<code>MPIN</code>) using the
Ersan (2016) generalization of the algorithm
in Ersan and Alici (2016).
</p>
</li>
<li> <p><a href="#topic+initials_pin_ea">initials_pin_ea</a> generates the initial parameter sets for the
maximum likelihood estimation of the probability of informed trading (<code>PIN</code>)
using the algorithm of Ersan and Alici (2016).
</p>
</li>
<li> <p><a href="#topic+initials_pin_gwj">initials_pin_gwj</a> generates the initial parameter set for the
maximum likelihood estimation of the probability of informed trading (<code>PIN</code>)
using the algorithm of Gan et al. (2015).
</p>
</li>
<li> <p><a href="#topic+initials_pin_yz">initials_pin_yz</a> generates the initial parameter sets for the
maximum likelihood estimation of the probability of informed trading (<code>PIN</code>)
using the algorithm of Yan and Zhang (2012).
</p>
</li>
<li> <p><a href="#topic+mpin_ecm">mpin_ecm</a> estimates the multilayer probability of informed
trading (<code>MPIN</code>) using the expectation-conditional maximization algorithm
(<code>ECM</code>) as in Ghachem and Ersan (2022a).
</p>
</li>
<li> <p><a href="#topic+mpin_ml">mpin_ml</a> estimates the multilayer probability of informed trading
(<code>MPIN</code>) using layer detection algorithms in
Ersan (2016), and
Ersan and Ghachem (2022a); and standard maximum
likelihood estimation.
</p>
</li>
<li> <p><a href="#topic+pin">pin</a> estimates the probability of informed trading (<code>PIN</code>) using
custom initial parameter set(s) provided by the user.
</p>
</li>
<li> <p><a href="#topic+pin_bayes">pin_bayes</a> estimates the probability of informed trading (<code>PIN</code>) using
the Bayesian approach in Griffin et al. (2021).
</p>
</li>
<li> <p><a href="#topic+pin_ea">pin_ea</a> estimates the probability of informed trading (<code>PIN</code>)
using the initial parameter sets from the algorithm of
Ersan and Alici (2016).
</p>
</li>
<li> <p><a href="#topic+pin_gwj">pin_gwj</a> estimates the probability of informed trading (<code>PIN</code>)
using the initial parameter set from the algorithm of
Gan et al. (2015).
</p>
</li>
<li> <p><a href="#topic+pin_yz">pin_yz</a> estimates the probability of informed trading (<code>PIN</code>)
using the initial parameter sets from the grid-search algorithm of
Yan and Zhang (2012).
</p>
</li>
<li> <p><a href="#topic+vpin">vpin</a> estimates the volume-synchronized probability of informed
trading (<code>VPIN</code>).
</p>
</li></ul>



<h3>Datasets</h3>


<ul>
<li> <p><a href="#topic+dailytrades">dailytrades</a> A dataframe representative of quarterly (60
trading days) data of simulated daily buys and sells.
</p>
</li>
<li> <p><a href="#topic+hfdata">hfdata</a> A dataframe containing simulated high-frequency
trade-data on 100 000 timestamps with the variables
<code style="white-space: pre;">&#8288;{timestamp, price, volume, bid, ask}&#8288;</code>.
</p>
</li></ul>



<h3>Estimation results</h3>


<ul>
<li> <p><a href="#topic+estimate.adjpin-class">estimate.adjpin-class</a> The class <code>estimate.adjpin</code> stores the
estimation results of the function <code>adjpin()</code>.
</p>
</li>
<li> <p><a href="#topic+estimate.mpin-class">estimate.mpin-class</a> The class <code>estimate.mpin</code> stores the
estimation results of the <code>MPIN</code> model as estimated by the function
<code>mpin_ml()</code>.
</p>
</li>
<li> <p><a href="#topic+estimate.mpin.ecm-class">estimate.mpin.ecm-class</a> The class <code>estimate.mpin.ecm</code> stores
the estimation results of the <code>MPIN</code> model as estimated by the function
<code>mpin_ecm()</code>.
</p>
</li>
<li> <p><a href="#topic+estimate.pin-class">estimate.pin-class</a> The class <code>estimate.pin</code> stores the
estimation results of the following <code>PIN</code> functions: <code>pin(), pin_yz(),
  pin_gwj()</code>, and <code>pin_ea()</code>.
</p>
</li>
<li> <p><a href="#topic+estimate.vpin-class">estimate.vpin-class</a> The class <code>estimate.vpin</code> stores the
estimation results of the <code>VPIN</code> model using the function <code>vpin()</code>.
</p>
</li></ul>



<h3>Data simulation</h3>


<ul>
<li> <p><a href="#topic+dataset-class">dataset-class</a> The class <code>dataset</code> stores the result of
simulation of the aggregate daily trading data.
</p>
</li>
<li> <p><a href="#topic+data.series-class">data.series-class</a> The class <code>data.series</code> stores a list of
<code>dataset</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Montasser Ghachem <a href="mailto:montasser.ghachem@pinstimation.com">montasser.ghachem@pinstimation.com</a> <br />
Department of Economics at Stockholm University, Stockholm, Sweden. <br />
</p>
<p>Oguz Ersan <a href="mailto:oguz.ersan@pinstimation.com">oguz.ersan@pinstimation.com</a> <br />
Department of International Trade and Finance at Kadir Has University,
Istanbul, Turkey.<br />
</p>


<h3>References</h3>

<p>Cheng T, Lai H (2021).
&ldquo;Improvements in estimating the probability of informed trading models.&rdquo;
<em>Quantitative Finance</em>, <b>21</b>(5), 771-796.<br /><br /> Duarte J, Young L (2009).
&ldquo;Why is PIN priced?&rdquo;
<em>Journal of Financial Economics</em>, <b>91</b>(2), 119&ndash;138.
ISSN 0304405X.<br /><br /> Easley D, De Prado MML, Ohara M (2011).
&ldquo;The microstructure of the \&quot;flash crash\&quot;: flow toxicity, liquidity crashes, and the probability of informed trading.&rdquo;
<em>The Journal of Portfolio Management</em>, <b>37</b>(2), 118&ndash;128.<br /><br /> Easley D, Hvidkjaer S, Ohara M (2010).
&ldquo;Factoring information into returns.&rdquo;
<em>Journal of Financial and Quantitative Analysis</em>, <b>45</b>(2), 293&ndash;309.
ISSN 00221090.<br /><br /> Easley D, Kiefer NM, Ohara M, Paperman JB (1996).
&ldquo;Liquidity, information, and infrequently traded stocks.&rdquo;
<em>Journal of Finance</em>, <b>51</b>(4), 1405&ndash;1436.
ISSN 00221082.<br /><br /> Easley D, Lopez De Prado MM, OHara M (2012).
&ldquo;Flow toxicity and liquidity in a high-frequency world.&rdquo;
<em>Review of Financial Studies</em>, <b>25</b>(5), 1457&ndash;1493.
ISSN 08939454.<br /><br /> Easley D, Ohara M (1992).
&ldquo;Time and the Process of Security Price Adjustment.&rdquo;
<em>The Journal of Finance</em>, <b>47</b>(2), 577&ndash;605.
ISSN 15406261.<br /><br /> Ellis K, Michaely R, Ohara M (2000).
&ldquo;The Accuracy of Trade Classification Rules: Evidence from Nasdaq.&rdquo;
<em>The Journal of Financial and Quantitative Analysis</em>, <b>35</b>(4), 529&ndash;551.<br /><br /> Ersan O (2016).
&ldquo;Multilayer Probability of Informed Trading.&rdquo;
<em>Available at SSRN 2874420</em>.<br /><br /> Ersan O, Alici A (2016).
&ldquo;An unbiased computation methodology for estimating the probability of informed trading (PIN).&rdquo;
<em>Journal of International Financial Markets, Institutions and Money</em>, <b>43</b>, 74&ndash;94.
ISSN 10424431.<br /><br /> Ersan O, Ghachem M (2022a).
&ldquo;Identifying information types in probability of informed trading (PIN) models: An improved algorithm.&rdquo;
<em>Available at SSRN 4117956</em>.<br /><br /> Ersan O, Ghachem M (2022b).
&ldquo;A methodological approach to the computational problems in the estimation of adjusted PIN model.&rdquo;
<em>Available at SSRN 4117954</em>.<br /><br /> Gan Q, Wei WC, Johnstone D (2015).
&ldquo;A faster estimation method for the probability of informed trading using hierarchical agglomerative clustering.&rdquo;
<em>Quantitative Finance</em>, <b>15</b>(11), 1805&ndash;1821.<br /><br /> Ghachem M, Ersan O (2022a).
&ldquo;Estimation of the probability of informed trading models via an expectation-conditional maximization algorithm.&rdquo;
<em>Available at SSRN 4117952</em>.<br /><br /> Ghachem M, Ersan O (2022b).
&ldquo;PINstimation: An R package for estimating models of probability of informed trading.&rdquo;
<em>Available at SSRN 4117946</em>.<br /><br /> Griffin J, Oberoi J, Oduro SD (2021).
&ldquo;Estimating the probability of informed trading: A Bayesian approach.&rdquo;
<em>Journal of Banking &amp; Finance</em>, <b>125</b>, 106045.<br /><br /> Lee CMC, Ready MJ (1991).
&ldquo;Inferring Trade Direction from Intraday Data.&rdquo;
<em>The Journal of Finance</em>, <b>46</b>(2), 733&ndash;746.
ISSN 00221082, 15406261.<br /><br /> Lin H, Ke W (2011).
&ldquo;A computing bias in estimating the probability of informed trading.&rdquo;
<em>Journal of Financial Markets</em>, <b>14</b>(4), 625-640.
ISSN 1386-4181.<br /><br /> Yan Y, Zhang S (2012).
&ldquo;An improved estimation method and empirical properties of the probability of informed trading.&rdquo;
<em>Journal of Banking and Finance</em>, <b>36</b>(2), 454&ndash;467.
ISSN 03784266.
</p>

<hr>
<h2 id='adjpin'>Estimation of adjusted PIN model</h2><span id='topic+adjpin'></span>

<h3>Description</h3>

<p>Estimates the Adjusted Probability of Informed Trading
(<code>adjPIN</code>) as well as the Probability of Symmetric Order-flow Shock
(<code>PSOS</code>) from the <code>AdjPIN</code> model of Duarte and Young(2009).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjpin(data, method = "ECM", initialsets = "GE", num_init = 20,
              restricted = list(), ..., verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjpin_+3A_data">data</code></td>
<td>
<p>A dataframe with 2 variables: the first
corresponds to buyer-initiated trades (buys), and the second corresponds
to seller-initiated trades (sells).</p>
</td></tr>
<tr><td><code id="adjpin_+3A_method">method</code></td>
<td>
<p>A character string referring to the method
used to estimate the model of Duarte and Young (2009).
It takes one of two values: <code>"ML"</code> refers to the standard maximum likelihood
estimation, and <code>"ECM"</code> refers to the expectation-conditional maximization
algorithm. The default value is <code>"ECM"</code>. Details of the ECM method,
and comparative results can be found in
Ghachem and Ersan (2022a), and in
Ghachem and Ersan (2022b).</p>
</td></tr>
<tr><td><code id="adjpin_+3A_initialsets">initialsets</code></td>
<td>
<p>It can either be a character string referring to
prebuilt algorithms generating initial parameter sets or a dataframe
containing custom initial parameter sets.
If <code>initialsets</code> is a character string, it refers to the method of generation
of the initial parameter sets, and takes one of three values: <code>"GE"</code>, <code>"CL"</code>,
or <code>"RANDOM"</code>. <code>"GE"</code> refers to initial parameter sets generated by the
algorithm of Ersan and Ghachem (2022b), and implemented
in <code>initials_adjpin()</code>, <code>"CL"</code> refers to initial parameter sets generated by
the algorithm of Cheng and Lai (2021), and
implemented in <code>initials_adjpin_cl()</code>, while <code>"RANDOM"</code> generates random
initial parameter sets as implemented in <code>initials_adjpin_rnd()</code>.
The default value is <code>"GE"</code>. If <code>initialsets</code> is a dataframe, the function
<code>adjpin()</code> will estimate the AdjPIN model using the provided initial
parameter sets.</p>
</td></tr>
<tr><td><code id="adjpin_+3A_num_init">num_init</code></td>
<td>
<p>An integer specifying the maximum number of
initial parameter sets to be used in the estimation.
If <code>initialsets="GE"</code>, the generation of initial parameter sets will stop
when the number of initial parameter sets reaches <code>num_init</code>. It can stop
earlier if the number of all possible generated initial parameter sets is
lower than <code>num_init</code>. If <code>initialsets="RANDOM"</code>, exactly <code>num_init</code>
initial parameter sets are returned. If <code>initialsets="CL"</code>: then <code>num_init</code>
is ignored, and all <code>256</code> initial parameter sets are used. The default
value is <code>20</code>. <code style="white-space: pre;">&#8288;[i]&#8288;</code> The argument <code>num_init</code> is ignored when the argument
<code>initialsets</code> is a dataframe.</p>
</td></tr>
<tr><td><code id="adjpin_+3A_restricted">restricted</code></td>
<td>
<p>A binary list that allows estimating restricted
AdjPIN models by specifying which model parameters are assumed to be equal.
It contains one or multiple of the following four elements
<code style="white-space: pre;">&#8288;{theta, mu, eps, d}&#8288;</code>. For instance, If <code>theta</code> is set to <code>TRUE</code>,
then the probability of liquidity shock in no-information days, and in
information days is assumed to be the same (<code class="reqn">\theta</code><code>=</code><code class="reqn">\theta'</code>). If any of
the remaining rate elements <code style="white-space: pre;">&#8288;{mu, eps, d}&#8288;</code> is set to <code>TRUE</code>,
(say  <code>mu=TRUE</code>), then the rate is assumed to be the same on the buy side,
and on the sell side (<code class="reqn">\mu</code><sub>b</sub><code>=</code><code class="reqn">\mu</code><sub>s</sub>). If more than one element is set to
<code>TRUE</code>, then the restrictions are combined. For instance, if the argument
<code>restricted</code> is set to <code>list(theta=TRUE, eps=TRUE, d=TRUE)</code>, then the
restricted AdjPIN model is estimated, where <code class="reqn">\theta</code><code>=</code><code class="reqn">\theta'</code>, <code class="reqn">\epsilon</code><sub>b</sub><code>=</code><code class="reqn">\epsilon</code><sub>s</sub>,
and <code class="reqn">\Delta</code><sub>b</sub><code>=</code><code class="reqn">\Delta</code><sub>s</sub>. If the value of the argument <code>restricted</code> is the empty list
(<code>list()</code>), then all parameters of the model are assumed to be independent,
and the unrestricted model is estimated. The default value is the empty
list <code>list()</code>.</p>
</td></tr>
<tr><td><code id="adjpin_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to the function <code>adjpin()</code>. The
recognized arguments are <code>hyperparams</code>, and <code>fact</code>. The argument
<code>hyperparams</code> consists of a list containing the hyperparameters of the <code>ECM</code>
algorithm. When not empty, it contains one or more  of the following
elements: <code>maxeval</code>, and <code>tolerance</code>. It is used only when the <code>method</code>
argument is set to <code>"ECM"</code>. The argument <code>fact</code> is a binary value that
determines which likelihood functional form is used: A factorization of
the likelihood function by Ersan and Ghachem (2022b)
when it is set to <code>TRUE</code>, otherwise, the original likelihood function of
Duarte and Young (2009). The default value is <code>TRUE</code>.
More about these arguments are in the Details section.</p>
</td></tr>
<tr><td><code id="adjpin_+3A_verbose">verbose</code></td>
<td>
<p>A binary variable that determines whether
detailed information about the steps of the estimation of the AdjPIN model
is displayed. No output is produced when <code>verbose</code> is set to
<code>FALSE</code>. The default value is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument 'data' should be a numeric dataframe, and contain
at least two variables. Only the first two variables will be considered:
The first variable is assumed to correspond to the total number of
buyer-initiated trades, while the second variable is assumed to
correspond to the total number of seller-initiated trades. Each row or
observation correspond to a trading day. <code>NA</code> values will be ignored.
</p>
<p>If <code>initialsets</code> is neither a dataframe, nor a character string from the
set <code style="white-space: pre;">&#8288;{"GE",&#8288;</code> <code style="white-space: pre;">&#8288;"CL",&#8288;</code> <code style="white-space: pre;">&#8288;"RANDOM"}&#8288;</code>, the estimation of the <code>AdjPIN</code> model is
aborted. The default initial parameters (<code>"GE"</code>) for the estimation
method are generated using a modified hierarchical agglomerative
clustering. For more information, see <code>initials_adjpin()</code>.
</p>
<p>The argument <code>hyperparams</code>  contains the hyperparameters of the <code>ECM</code>
algorithm. It is either empty or contains one or two  of the following
elements:
</p>

<ul>
<li> <p><code>maxeval</code>: (<code>integer</code>) It stands for maximum number of iterations of
the <code>ECM</code>  algorithm for each initial parameter set. When missing, <code>maxeval</code>
takes the default value of <code>100</code>.
</p>
</li>
<li> <p><code>tolerance</code> (<code>numeric</code>) The <code>ECM</code> algorithm is stopped when the
(relative) change of log-likelihood is  smaller than tolerance. When
missing, <code>tolerance</code> takes the default value of <code>0.001</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>Returns an object of class <code>estimate.adjpin</code>.
</p>


<h3>References</h3>

<p>Cheng T, Lai H (2021).
&ldquo;Improvements in estimating the probability of informed trading models.&rdquo;
<em>Quantitative Finance</em>, <b>21</b>(5), 771-796.<br /><br /> Duarte J, Young L (2009).
&ldquo;Why is PIN priced?&rdquo;
<em>Journal of Financial Economics</em>, <b>91</b>(2), 119&ndash;138.
ISSN 0304405X.<br /><br /> Ersan O, Ghachem M (2022b).
&ldquo;A methodological approach to the computational problems in the estimation of adjusted PIN model.&rdquo;
<em>Available at SSRN 4117954</em>.<br /><br /> Ghachem M, Ersan O (2022a).
&ldquo;Estimation of the probability of informed trading models via an expectation-conditional maximization algorithm.&rdquo;
<em>Available at SSRN 4117952</em>.<br /><br /> Ghachem M, Ersan O (2022b).
&ldquo;PINstimation: An R package for estimating models of probability of informed trading.&rdquo;
<em>Available at SSRN 4117946</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We use 'generatedata_adjpin()' to generate a S4 object of type 'dataset'
# with 60 observations.

sim_data &lt;- generatedata_adjpin(days = 60)

# The actual dataset of 60 observations is stored in the slot 'data' of the
# S4 object 'sim_data'. Each observation corresponds to a day and contains
# the total number of buyer-initiated transactions ('B') and seller-
# initiated transactions ('S') on that day.

xdata &lt;- sim_data@data

# ------------------------------------------------------------------------ #
# Compare the unrestricted AdjPIN model with various restricted models     #
# ------------------------------------------------------------------------ #

# Estimate the unrestricted AdjPIN model using the ECM algorithm (default),
# and show the estimation output

estimate.adjpin.0 &lt;- adjpin(xdata, verbose = FALSE)

show(estimate.adjpin.0)

# Estimate the restricted AdjPIN model where mub=mus

estimate.adjpin.1 &lt;- adjpin(xdata, restricted = list(mu = TRUE),
                                  verbose = FALSE)

# Estimate the restricted AdjPIN model where eps.b=eps.s

estimate.adjpin.2 &lt;- adjpin(xdata, restricted = list(eps = TRUE),
                                  verbose = FALSE)

# Estimate the restricted AdjPIN model where d.b=d.s

estimate.adjpin.3 &lt;- adjpin(xdata, restricted = list(d = TRUE),
                                  verbose = FALSE)

# Compare the different values of adjusted PIN

estimates &lt;- list(estimate.adjpin.0, estimate.adjpin.1,
                  estimate.adjpin.2, estimate.adjpin.3)

adjpins &lt;- sapply(estimates, function(x) x@adjpin)

psos &lt;- sapply(estimates, function(x) x@psos)

summary &lt;- cbind(adjpins, psos)
rownames(summary) &lt;- c("unrestricted", "same.mu", "same.eps", "same.d")

show(round(summary, 5))

</code></pre>

<hr>
<h2 id='dailytrades'>Example of quarterly data</h2><span id='topic+dailytrades'></span>

<h3>Description</h3>

<p>An example dataset representative of quarterly data containing
the aggregate numbers of buyer-initiated and seller-initiated trades for
each trading day.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dailytrades
</code></pre>


<h3>Format</h3>

<p>A data frame with <code>60</code> observations and <code>2</code> variables:
</p>

<ul>
<li> <p><code>B</code>: total number of buyer-initiated trades.
</p>
</li>
<li> <p><code>S</code>: total number of seller-initiated trades.
</p>
</li></ul>



<h3>Source</h3>

<p>Artificially created data set.
</p>

<hr>
<h2 id='data.series-class'>List of dataset objects</h2><span id='topic+data.series-class'></span><span id='topic+show+2Cdata.series-method'></span>

<h3>Description</h3>

<p>The class <code>data.series</code> is the blueprint of <code>S4</code> objects that
store a list of <code>dataset</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'data.series'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data.series-class_+3A_object">object</code></td>
<td>
<p>an object of class <code>data.series</code></p>
</td></tr>
</table>


<h3>Slots</h3>


<dl>
<dt><code>series</code></dt><dd><p>(<code>numeric</code>) returns the number of <code>dataset</code> objects stored.</p>
</dd>
<dt><code>days</code></dt><dd><p>(<code>numeric</code>) returns the length of the simulated data in days
common to all <code>dataset</code> objects stored. The default value is <code>60</code>.</p>
</dd>
<dt><code>model</code></dt><dd><p>(<code>character</code>) returns a character string, either <code>'MPIN'</code> or
<code>'adjPIN'</code>.</p>
</dd>
<dt><code>layers</code></dt><dd><p>(<code>numeric</code>)  returns the number of information layers in
all <code>dataset</code> objects stored. It takes the value <code>1</code> for the adjusted PIN
model, i.e. when <code>model</code> takes the value <code>'adjPIN'</code>.</p>
</dd>
<dt><code>datasets</code></dt><dd><p>(<code>list</code>) returns the list of the <code>dataset</code> objects stored.</p>
</dd>
<dt><code>restrictions</code></dt><dd><p>(<code>list</code>) returns a binary list that contains the set of
parameter restrictions on the original AdjPIN model in the estimated AdjPIN
model. The restrictions are imposed equality constraints on model parameters.
If the value of the parameter  <code>restricted</code> is the empty list <code>(list())</code>,
then the model has no restrictions, and the estimated model is the
unrestricted, i.e., the original AdjPIN model. If not empty, the list
contains one or multiple of the following four elements
<code style="white-space: pre;">&#8288;{theta, mu, eps, d}&#8288;</code>. For instance, If <code>theta</code> is set to <code>TRUE</code>,
then the estimated model has assumed the equality of the probability of
liquidity shocks in no-information, and information days, i.e.,
<code class="reqn">\theta</code><code>=</code><code class="reqn">\theta'</code>. If any of the remaining rate elements
<code style="white-space: pre;">&#8288;{mu, eps, d}&#8288;</code> is equal to <code>TRUE</code>, (say  <code>mu=TRUE</code>), then the
estimated model imposed equality of the concerned parameter on the buy
side, and on the sell side (<code class="reqn">\mu</code><sub>b</sub><code>=</code><code class="reqn">\mu</code><sub>s</sub>). If more than one element is
equal to <code>TRUE</code>,  then the restrictions are combined. For instance,
if  the slot <code>restrictions</code> contains <code>list(theta=TRUE, eps=TRUE, d=TRUE)</code>,
then the estimated AdjPIN model has three restrictions <code class="reqn">\theta</code><code>=</code><code class="reqn">\theta'</code>,
<code class="reqn">\epsilon</code><sub>b</sub><code>=</code><code class="reqn">\epsilon</code><sub>s</sub>, and <code class="reqn">\Delta</code><sub>b</sub><code>=</code><code class="reqn">\Delta</code><sub>s</sub>, i.e., it has been estimated with just <code>7</code>
parameters, in comparison to <code>10</code> in the original unrestricted model.
<code style="white-space: pre;">&#8288;[i]&#8288;</code> This slot only concerns datasets generated by the function
<code>generatedata_adjpin()</code>.</p>
</dd>
<dt><code>warnings</code></dt><dd><p>(<code>numeric</code>) returns numbers referring to the warning errors
caused by a conflict between the different arguments used to call the
function <code>generatedata_mpin()</code>.</p>
</dd>
<dt><code>runningtime</code></dt><dd><p>(<code>numeric</code>) returns the running time of the data
simulation in seconds.</p>
</dd>
</dl>

<hr>
<h2 id='dataset-class'>Simulated data object</h2><span id='topic+dataset-class'></span><span id='topic+show+2Cdataset-method'></span>

<h3>Description</h3>

<p>The class <code>dataset</code> is a blueprint of <code>S4</code> objects that store
the result of simulation of the aggregate daily trading data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'dataset'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dataset-class_+3A_object">object</code></td>
<td>
<p>an object of class <code>dataset</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>theoreticals</code> are the parameters used to generate the daily buys
and sells. <code>empiricals</code> are computed from the generated daily buys and sells.
If we generate data for a 60 days using <code class="reqn">\alpha</code>=0.1, the most likely
outcome is to obtain 6 days (0.1 x 60) as
information event days. In this case, the theoretical value of
<code class="reqn">\alpha</code><code style="white-space: pre;">&#8288;=0.1&#8288;</code> is equal to the empirically estimated value of
<code class="reqn">\alpha</code><code style="white-space: pre;">&#8288;=6/60=0.1&#8288;</code>.
The number of generated information days can, however, be different from <code>6</code>;
say <code>5</code>. In this case, empirical (actual) <code class="reqn">\alpha</code> parameter derived
from the generated numbers would be <code>5/60=0.0833</code>, which differs from the
theoretical <code class="reqn">\alpha</code><code style="white-space: pre;">&#8288;=0.1&#8288;</code>.
The weak law of large numbers ensures the empirical parameters (<code>empiricals</code>)
converge towards the theoretical parameters (<code>theoreticals</code>) when the number
of days becomes very large.
To detect the estimation biases from the models/methods, comparing the
estimates with <code>empiricals</code> rather than <code>theoreticals</code> would yield more
realistic results.
</p>


<h3>Slots</h3>


<dl>
<dt><code>model</code></dt><dd><p>(<code>character</code>) returns the model being simulated, either <code>"MPIN"</code>,
or <code>"adjPIN"</code>.</p>
</dd>
<dt><code>days</code></dt><dd><p>(<code>numeric</code>) returns the length of the generated data in days.</p>
</dd>
<dt><code>layers</code></dt><dd><p>(<code>numeric</code>)  returns the number of information layers in the
simulated data. It takes the value <code>1</code> for the adjusted PIN
model, i.e. when <code>model</code> takes the value <code>'adjPIN'</code>.</p>
</dd>
<dt><code>theoreticals</code></dt><dd><p>(<code>list</code>) returns the list of the theoretical parameters
used to generate the data.</p>
</dd>
<dt><code>empiricals</code></dt><dd><p>(<code>list</code>) returns the list of the empirical parameters
computed from the generated data.</p>
</dd>
<dt><code>aggregates</code></dt><dd><p>(<code>numeric</code>) returns an aggregation of information layers'
empirical parameters alongside with <code class="reqn">\epsilon</code><sub>b</sub> and <code class="reqn">\epsilon</code><sub>s</sub>. The aggregated parameters
are calculated as follows:
<code class="reqn">\alpha_{agg} = \sum \alpha_j</code><code class="reqn">\alpha*= \sum
\alpha</code><sub>j</sub> <code class="reqn">\delta_{agg} = \sum \alpha_j \times \delta_j</code>
<code class="reqn">\delta*= \sum \alpha</code><sub>j</sub><code class="reqn">\delta</code><sub>j</sub>,
and <code class="reqn">\mu_{agg} = \sum \alpha_j \times \mu_j</code><code class="reqn">\mu*= \sum
\alpha</code><sub>j</sub><code class="reqn">\mu</code><sub>j</sub>.</p>
</dd>
<dt><code>emp.pin</code></dt><dd><p>(<code>numeric</code>) returns the <code>PIN/MPIN/AdjPIN</code> value derived from
the empirically estimated parameters of the generated data.</p>
</dd>
<dt><code>data</code></dt><dd><p>(<code>dataframe</code>) returns a dataframe containing the generated data.</p>
</dd>
<dt><code>likelihood</code></dt><dd><p>(<code>numeric</code>) returns the value of the (log-)likelihood
function evaluated at the empirical parameters.</p>
</dd>
<dt><code>warnings</code></dt><dd><p>(<code>character</code>) stores warning messages for events that occurred
during the data generation, such as conflict between two arguments.</p>
</dd>
<dt><code>restrictions</code></dt><dd><p>(<code>list</code>) returns a binary list that contains the set of
parameter restrictions on the original AdjPIN model in the estimated AdjPIN
model. The restrictions are imposed equality constraints on model parameters.
If the value of the parameter  <code>restricted</code> is the empty list <code>(list())</code>,
then the model has no restrictions, and the estimated model is the
unrestricted, i.e., the original AdjPIN model. If not empty, the list
contains one or multiple of the following four elements
<code style="white-space: pre;">&#8288;{theta, mu, eps, d}&#8288;</code>. For instance, If <code>theta</code> is set to <code>TRUE</code>,
then the estimated model has assumed the equality of the probability of
liquidity shocks in no-information, and information days, i.e.,
<code class="reqn">\theta</code><code>=</code><code class="reqn">\theta'</code>. If any of the remaining rate elements
<code style="white-space: pre;">&#8288;{mu, eps, d}&#8288;</code> is equal to <code>TRUE</code>, (say  <code>mu=TRUE</code>), then the
estimated model imposed equality of the concerned parameter on the buy
side, and on the sell side (<code class="reqn">\mu</code><sub>b</sub><code>=</code><code class="reqn">\mu</code><sub>s</sub>). If more than one element is
equal to <code>TRUE</code>,  then the restrictions are combined. For instance,
if  the slot <code>restrictions</code> contains <code>list(theta=TRUE, eps=TRUE, d=TRUE)</code>,
then the estimated AdjPIN model has three restrictions <code class="reqn">\theta</code><code>=</code><code class="reqn">\theta'</code>,
<code class="reqn">\epsilon</code><sub>b</sub><code>=</code><code class="reqn">\epsilon</code><sub>s</sub>, and <code class="reqn">\Delta</code><sub>b</sub><code>=</code><code class="reqn">\Delta</code><sub>s</sub>, i.e., it has been estimated with just <code>7</code>
parameters, in comparison to <code>10</code> in the original unrestricted model.
<code style="white-space: pre;">&#8288;[i]&#8288;</code> This slot only concerns datasets generated by the function
<code>generatedata_adjpin()</code>.</p>
</dd>
</dl>

<hr>
<h2 id='detecting-layers'>Layer detection in trade-data</h2><span id='topic+detecting-layers'></span><span id='topic+detectlayers_ecm'></span><span id='topic+detectlayers_e'></span><span id='topic+detectlayers_eg'></span>

<h3>Description</h3>

<p>Detects the number of information layers present in trade-data
using the algorithms in Ersan (2016),
Ersan and Ghachem (2022a),
and Ghachem and Ersan (2022a).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detectlayers_e(data, confidence = 0.995, correction = TRUE)

detectlayers_eg(data, confidence = 0.995)

detectlayers_ecm(data, hyperparams = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detecting-layers_+3A_data">data</code></td>
<td>
<p>A dataframe with 2 variables: the first
corresponds to buyer-initiated trades (buys), and the second corresponds
to seller-initiated trades (sells).</p>
</td></tr>
<tr><td><code id="detecting-layers_+3A_confidence">confidence</code></td>
<td>
<p>A number from <code style="white-space: pre;">&#8288;(0.5,1)&#8288;</code>, corresponding to the
range of the confidence interval used to determine whether a given cluster is
compact, and therefore can be considered an information layer.
If all values of absolute order imbalances (AOI) within a given cluster are
within the confidence interval of a Skellam distribution with level equal to
<code>'confidence'</code>, and centered on the mean of AOI, then the cluster is
considered compact, and, therefore, an information layer. If some
observations are outside the confidence interval, then the data is clustered
further. The default value is <code>0.995</code>. <code style="white-space: pre;">&#8288;[i]&#8288;</code> This is an argument of the
functions <code>detectlayers_e()</code>, and <code>detectlayers_eg()</code>.</p>
</td></tr>
<tr><td><code id="detecting-layers_+3A_correction">correction</code></td>
<td>
<p>A binary variable that determines whether the
data will be adjusted prior to implementing the algorithm of
Ersan (2016). The default value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="detecting-layers_+3A_hyperparams">hyperparams</code></td>
<td>
<p>A list containing the hyperparameters of the <code>ECM</code>
algorithm. When not empty, it contains one or more of the following
elements: <code>maxeval</code>, <code>tolerance</code>, <code>maxinit</code>, and <code>maxlayers</code>. More
about these elements are found in the Details section. <code style="white-space: pre;">&#8288;[i]&#8288;</code> This is
an argument of the function <code>detectlayers_ecm()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument 'data' should be a numeric dataframe, and contain
at least two variables. Only the first two variables will be considered:
The first variable is assumed to correspond to the total number of
buyer-initiated trades, while the second variable is assumed to
correspond to the total number of seller-initiated trades. Each row or
observation correspond to a trading day. <code>NA</code> values will be ignored.
</p>
<p>The argument <code>hyperparams</code>  contains the hyperparameters of the <code>ECM</code>
algorithm. It is either empty or contains one or more of the following
elements:
</p>

<ul>
<li> <p><code>maxeval</code>: (<code>integer</code>) It stands for maximum number of iterations
of the <code>ECM</code>  for each initial parameter set. When missing, <code>maxeval</code>
takes the default value of <code>100</code>.
</p>
</li>
<li> <p><code>tolerance</code> (<code>numeric</code>) The <code>ECM</code> algorithm is stopped when the
(relative) change of log-likelihood is smaller than tolerance. When
missing, <code>tolerance</code> takes the default value of <code>0.001</code>.
</p>
</li>
<li> <p><code>maxinit</code>: (<code>integer</code>) It is the maximum number of initial
parameter sets used for the <code>ECM</code> estimation per layer. When missing,
<code>maxinit</code> takes the default value of <code>20</code>.
</p>
</li>
<li> <p><code>maxlayers</code> (<code>integer</code>) It is the upper limit of number of layers
used in the ECM algorithm. To find the optimal number of layers, the ECM
algorithm will estimate a model for each value of the number of layers
between <code>1</code> and <code>maxlayers</code>, and then picks the model that has the lowest
Bayes information criterion (BIC). When missing, <code>maxlayers</code> takes the
default value of <code>8</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>Returns an integer corresponding to the number of layers detected in
the data.
</p>


<h3>References</h3>

<p>Ersan O (2016).
&ldquo;Multilayer Probability of Informed Trading.&rdquo;
<em>Available at SSRN 2874420</em>.<br /><br /> Ersan O, Ghachem M (2022a).
&ldquo;Identifying information types in probability of informed trading (PIN) models: An improved algorithm.&rdquo;
<em>Available at SSRN 4117956</em>.<br /><br /> Ghachem M, Ersan O (2022a).
&ldquo;Estimation of the probability of informed trading models via an expectation-conditional maximization algorithm.&rdquo;
<em>Available at SSRN 4117952</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># There is a preloaded quarterly dataset called 'dailytrades' with 60
# observations. Each observation corresponds to a day and contains the
# total number of buyer-initiated trades ('B') and seller-initiated
# trades ('S') on that day. To know more, type ?dailytrades

xdata &lt;- dailytrades

# Detect the number of layers present in the dataset 'dailytrades' using the
# different algorithms and display the results

e.layers &lt;- detectlayers_e(xdata)
eg.layers &lt;- detectlayers_eg(xdata)
em.layers &lt;- detectlayers_ecm(xdata)

show(c(e = e.layers, eg = eg.layers, em = em.layers))

</code></pre>

<hr>
<h2 id='estimate.adjpin-class'>AdjPIN estimation results</h2><span id='topic+estimate.adjpin-class'></span><span id='topic+show+2Cestimate.adjpin-method'></span>

<h3>Description</h3>

<p>The class <code>estimate.adjpin</code> is a blueprint of the <code>S4</code>
objects that store the results of the estimation of the <code>AdjPIN</code> model using
<code>adjpin()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'estimate.adjpin'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate.adjpin-class_+3A_object">object</code></td>
<td>
<p>(estimate.adjpin-class)</p>
</td></tr>
</table>


<h3>Slots</h3>


<dl>
<dt><code>success</code></dt><dd><p>(<code>logical</code>) takes the value <code>TRUE</code> when the estimation has
succeeded, <code>FALSE</code> otherwise.</p>
</dd>
<dt><code>errorMessage</code></dt><dd><p>(<code>character</code>)  contains an error message if the estimation
of the <code>AdjPIN</code> model has failed, and is empty otherwise.</p>
</dd>
<dt><code>convergent.sets</code></dt><dd><p>(<code>numeric</code>) returns the number of initial parameter
sets, for which the likelihood maximization converged.</p>
</dd>
<dt><code>method</code></dt><dd><p>(<code>character</code>) contains a reference to the estimation method:
<code>"ECM"</code> for expectation-conditional maximization algorithm and '<code>"ML"</code>'
for standard maximum likelihood estimation.</p>
</dd>
<dt><code>factorization</code></dt><dd><p>(<code>character</code>) contains a reference to the factorization
of the likelihood function used: <code>"GE"</code>for the factorization in
Ersan and Ghachem (2022b), and <code>"NONE"</code> for the
original likelihood function in Duarte and Young (2009).</p>
</dd>
<dt><code>restrictions</code></dt><dd><p>(<code>list</code>) returns a binary list that contains the set of
parameter restrictions on the original AdjPIN model in the estimated AdjPIN
model. The restrictions are imposed equality constraints on model parameters.
If the value of the parameter  <code>restricted</code> is the empty list <code>(list())</code>,
then the model has no restrictions, and the estimated model is the
unrestricted, i.e., the original AdjPIN model. If not empty, the list
contains one or multiple of the following four elements
<code style="white-space: pre;">&#8288;{theta, mu, eps, d}&#8288;</code>. For instance, If <code>theta</code> is set to <code>TRUE</code>,
then the estimated model has assumed the equality of the probability of
liquidity shocks in no-information, and information days, i.e.,
<code class="reqn">\theta</code><code>=</code><code class="reqn">\theta'</code>. If any of the remaining rate elements
<code style="white-space: pre;">&#8288;{mu, eps, d}&#8288;</code> is equal to <code>TRUE</code>, (say  <code>mu=TRUE</code>), then the
estimated model imposed equality of the concerned parameter on the buy
side, and on the sell side (<code class="reqn">\mu</code><sub>b</sub><code>=</code><code class="reqn">\mu</code><sub>s</sub>). If more than one element is
equal to <code>TRUE</code>,  then the restrictions are combined. For instance,
if  the slot <code>restrictions</code> contains <code>list(theta=TRUE, eps=TRUE, d=TRUE)</code>,
then the estimated AdjPIN model has three restrictions <code class="reqn">\theta</code><code>=</code><code class="reqn">\theta'</code>,
<code class="reqn">\epsilon</code><sub>b</sub><code>=</code><code class="reqn">\epsilon</code><sub>s</sub>, and <code class="reqn">\Delta</code><sub>b</sub><code>=</code><code class="reqn">\Delta</code><sub>s</sub>, i.e., it has been estimated with just <code>7</code>
parameters, in comparison to <code>10</code> in the original unrestricted model.</p>
</dd>
<dt><code>algorithm</code></dt><dd><p>(<code>character</code>) returns the implemented initial parameter
set determination algorithm. <code>"GE"</code> is for
Ersan and Ghachem (2022b),
<code>"CL"</code> is for Cheng and Lai (2021),
<code>"RANDOM"</code> for random initial parameter sets, and <code>"CUSTOM"</code> for
custom initial parameter sets.</p>
</dd>
<dt><code>parameters</code></dt><dd><p>(<code>numeric</code>) returns the vector of the optimal
maximum-likelihood estimates ( <code class="reqn">\alpha</code>, <code class="reqn">\delta</code>, <code class="reqn">\theta</code>,
<code class="reqn">\theta'</code>, <code class="reqn">\epsilon</code><sub>b</sub>, <code class="reqn">\epsilon</code><sub>s</sub>, <code class="reqn">\mu</code><sub>b</sub>, <code class="reqn">\mu</code><sub>s</sub>, <code class="reqn">\Delta</code><sub>b</sub>, <code class="reqn">\Delta</code><sub>s</sub>).</p>
</dd>
<dt><code>likelihood</code></dt><dd><p>(<code>numeric</code>) returns the value (of the factorization) of the
likelihood function, as in Ersan and Ghachem (2022b),
evaluated at the set of optimal parameters.</p>
</dd>
<dt><code>adjpin</code></dt><dd><p>(<code>numeric</code>) returns the value of the adjusted probability of
informed trading (Duarte and Young 2009).</p>
</dd>
<dt><code>psos</code></dt><dd><p>(<code>numeric</code>) returns the probability of symmetric order flow shock
(Duarte and Young 2009).</p>
</dd>
<dt><code>dataset</code></dt><dd><p>(<code>dataframe</code>) returns the dataset of buys and sells used
in the estimation of the AdjPIN model.</p>
</dd>
<dt><code>initialsets</code></dt><dd><p>(<code>dataframe</code>) returns the initial parameter sets used
in the estimation of AdjPIN model.</p>
</dd>
<dt><code>details</code></dt><dd><p>(<code>dataframe</code>) returns a dataframe containing the estimated
parameters for each initial parameter set.</p>
</dd>
<dt><code>hyperparams</code></dt><dd><p>(<code>list</code>) returns the hyperparameters of the <code>ECM</code>
algorithm, which are <code>maxeval</code>, and <code>tolerance</code>.</p>
</dd>
<dt><code>runningtime</code></dt><dd><p>(<code>numeric</code>) returns the running time of the <code>AdjPIN</code>
estimation in seconds.</p>
</dd>
</dl>

<hr>
<h2 id='estimate.mpin-class'>MPIN estimation results</h2><span id='topic+estimate.mpin-class'></span><span id='topic+show+2Cestimate.mpin-method'></span>

<h3>Description</h3>

<p>The class <code>estimate.mpin</code> is the blueprint of <code>S4</code> objects
that store the results of the estimation of the <code>MPIN</code> model, using the
function <code>mpin_ml()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'estimate.mpin'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate.mpin-class_+3A_object">object</code></td>
<td>
<p>an object of class <code>estimate.mpin</code></p>
</td></tr>
</table>


<h3>Slots</h3>


<dl>
<dt><code>success</code></dt><dd><p>(<code>logical</code>) returns the value <code>TRUE</code> when the
estimation has succeeded, <code>FALSE</code> otherwise.</p>
</dd>
<dt><code>errorMessage</code></dt><dd><p>(<code>character</code>) returns an error message if the estimation
of the <code>MPIN</code> model has failed, and is empty otherwise.</p>
</dd>
<dt><code>convergent.sets</code></dt><dd><p>(<code>numeric</code>) returns the number of initial parameter
sets at which the likelihood maximization converged.</p>
</dd>
<dt><code>method</code></dt><dd><p>(<code>character</code>) returns the method of estimation used, and is
equal to 'Maximum Likelihood Estimation'.</p>
</dd>
<dt><code>layers</code></dt><dd><p>(<code>numeric</code>) returns the number of layers detected in the trading
data, or provided by the user.</p>
</dd>
<dt><code>detection</code></dt><dd><p>(logical) returns a reference to the layer-detection
algorithm used (<code>"E"</code>, <code>"EG"</code>, <code>"ECM"</code>), if any algorithm is used. If the
number of layers is provided by the user, detection takes the value <code>"USER"</code>.</p>
</dd>
<dt><code>parameters</code></dt><dd><p>(<code>list</code>) returns the list of the maximum likelihood
estimates (<code class="reqn">\alpha</code>, <code class="reqn">\delta</code>, <code class="reqn">\mu</code>, <code class="reqn">\epsilon</code><sub>b</sub>, <code class="reqn">\epsilon</code><sub>s</sub>), where
<code class="reqn">\alpha</code>, <code class="reqn">\delta</code>, and <code class="reqn">\mu</code> are numeric vectors of length
<code>layers</code>.</p>
</dd>
<dt><code>aggregates</code></dt><dd><p>(<code>numeric</code>) returns an aggregation of information layers'
estimated parameters alongside with <code class="reqn">\epsilon</code><sub>b</sub>, and <code class="reqn">\epsilon</code><sub>s</sub>. The aggregated parameters
are calculated as follows:
<code class="reqn">\alpha_{agg} = \sum \alpha_j</code><code class="reqn">\alpha*= \sum
\alpha</code><sub>j</sub>
<code class="reqn">\delta_{agg} = \sum \alpha_j \times \delta_j</code><code class="reqn">\delta*=
\sum \alpha</code><sub>j</sub><code class="reqn">\delta</code><sub>j</sub>,
and <code class="reqn">\mu_{agg} = \sum \alpha_j \times \mu_j</code><code class="reqn">\mu*= \sum
\alpha</code><sub>j</sub><code class="reqn">\mu</code><sub>j</sub>.</p>
</dd>
<dt><code>likelihood</code></dt><dd><p>(<code>numeric</code>) returns the value of the (log-)likelihood
function evaluated at the optimal set of parameters.</p>
</dd>
<dt><code>mpinJ</code></dt><dd><p>(<code>numeric</code>) returns the values of the multilayer probability of
informed trading per layer, calculated using the layer-specific estimated
parameters.</p>
</dd>
<dt><code>mpin</code></dt><dd><p>(<code>numeric</code>) returns the global value of the multilayer probability
of informed trading. It is the sum of the multilayer probabilities of
informed trading per layer stored in the slot <code>mpinJ</code>.</p>
</dd>
<dt><code>mpin.goodbad</code></dt><dd><p>(<code>list</code>) returns a list containing a decomposition of
<code>MPIN</code> into good-news, and bad-news <code>MPIN</code> components. The decomposition
has been suggested for PIN measure in
Brennan et al. (2016). The list has four elements:
<code>mpinG</code>, and <code>mpinB</code> are the global good-news, and bad-news components of
<code>MPIN</code>, while <code>mpinGj</code>, and <code>mpinBj</code> are two vectors containing  the
good-news (bad-news) components of <code>MPIN</code> computed per layer.</p>
</dd>
<dt><code>dataset</code></dt><dd><p>(<code>dataframe</code>) returns the dataset of buys and sells used
in the maximum likelihood estimation of the MPIN model.</p>
</dd>
<dt><code>initialsets</code></dt><dd><p>(<code>dataframe</code>) returns the initial parameter sets used
in the maximum likelihood estimation of the MPIN model.</p>
</dd>
<dt><code>details</code></dt><dd><p>(<code>dataframe</code>) returns a dataframe containing the estimated
parameters of the <code>MLE</code> method for each initial parameter set.</p>
</dd>
<dt><code>runningtime</code></dt><dd><p>(<code>numeric</code>) returns the running time of the estimation of
the <code>MPIN</code> model in seconds.</p>
</dd>
</dl>

<hr>
<h2 id='estimate.mpin.ecm-class'>MPIN estimation results (ECM)</h2><span id='topic+estimate.mpin.ecm-class'></span><span id='topic+show+2Cestimate.mpin.ecm-method'></span><span id='topic+selectModel'></span><span id='topic+selectModel+2Cestimate.mpin.ecm-method'></span><span id='topic+getSummary'></span><span id='topic+getSummary+2Cestimate.mpin.ecm-method'></span>

<h3>Description</h3>

<p>The class <code>estimate.mpin.ecm</code> is the blueprint of
<code>S4</code> objects that store the results of the estimation of the <code>MPIN</code>
model using the Expectation-Conditional Maximization method, as
implemented in the function <code>mpin_ecm()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'estimate.mpin.ecm'
show(object)

selectModel(object, criterion)

## S4 method for signature 'estimate.mpin.ecm'
selectModel(object, criterion)

getSummary(object)

## S4 method for signature 'estimate.mpin.ecm'
getSummary(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate.mpin.ecm-class_+3A_object">object</code></td>
<td>
<p>an object of class <code>estimate.mpin.ecm</code>.</p>
</td></tr>
<tr><td><code id="estimate.mpin.ecm-class_+3A_criterion">criterion</code></td>
<td>
<p>a character string specifying the model selection criterion.
<code>criterion</code> should take one of these values <code style="white-space: pre;">&#8288;{"BIC", "AIC", "AWE"}&#8288;</code>.
They stand for Bayesian Information Criterion, Akaike Information Criterion,
and Approximate Weight of Evidence, respectively.</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>selectModel(estimate.mpin.ecm)</code>: returns the optimal model among
the estimated models, i.e., the model having the lowest information
criterion, provided by the user.
</p>
</li>
<li> <p><code>getSummary(estimate.mpin.ecm)</code>: returns a summary of
the estimation of the <code>MPIN</code> model using the <code>ECM</code> algorithm for different
values of the argument <code>layers</code>. For each estimation, the number of layers,
the <code>MPIN</code> value, the log-likelihood value, as well as the values of the
different information criteria, namely <code>AIC</code>, <code>BIC</code> and <code>AWE</code> are displayed.
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>success</code></dt><dd><p>(<code>logical</code>) returns the value <code>TRUE</code> when the
estimation has succeeded, <code>FALSE</code> otherwise.</p>
</dd>
<dt><code>errorMessage</code></dt><dd><p>(<code>character</code>) returns an error message if the <code>MPIN</code>
estimation has failed, and is empty otherwise.</p>
</dd>
<dt><code>convergent.sets</code></dt><dd><p>(<code>numeric</code>) returns the number of initial parameter
sets at which the likelihood maximization converged.</p>
</dd>
<dt><code>method</code></dt><dd><p>(<code>character</code>) returns the method of estimation, and is equal
to 'Expectation-Conditional Maximization Algorithm'.</p>
</dd>
<dt><code>layers</code></dt><dd><p>(<code>numeric</code>) returns the number of layers estimated by the
Expectation-Conditional Maximization algorithm, or provided by the user.</p>
</dd>
<dt><code>optimal</code></dt><dd><p>(<code>logical</code>) returns whether the number of layers used for
the estimation is provided by the user <code>(optimal=FALSE)</code>, or determined
by the <code>ECM</code> algorithm <code>(optimal=TRUE)</code>.</p>
</dd>
<dt><code>parameters</code></dt><dd><p>(<code>list</code>) returns the list of the maximum likelihood
estimates (<code class="reqn">\alpha</code>, <code class="reqn">\delta</code>, <code class="reqn">\mu</code>, <code class="reqn">\epsilon</code><sub>b</sub>, <code class="reqn">\epsilon</code><sub>s</sub>), where
<code class="reqn">\alpha</code>, <code class="reqn">\delta</code>, and <code class="reqn">\mu</code> are numeric vectors of
length <code>layers</code>.</p>
</dd>
<dt><code>aggregates</code></dt><dd><p>(<code>numeric</code>) returns an aggregation of information layers'
parameters alongside with <code class="reqn">\epsilon</code><sub>b</sub> and <code class="reqn">\epsilon</code><sub>s</sub>. The aggregated parameters are
calculated as follows:
<code class="reqn">\alpha_{agg} = \sum \alpha_j</code><code class="reqn">\alpha*= \sum
\alpha</code><sub>j</sub> <code class="reqn">\delta_{agg} = \sum \alpha_j \times \delta_j</code>
<code class="reqn">\delta*= \sum \alpha</code><sub>j</sub><code class="reqn">\delta</code><sub>j</sub>,
and <code class="reqn">\mu_{agg} = \sum \alpha_j \times \mu_j</code><code class="reqn">\mu*= \sum
\alpha</code><sub>j</sub><code class="reqn">\mu</code><sub>j</sub>.</p>
</dd>
<dt><code>likelihood</code></dt><dd><p>(<code>numeric</code>) returns the value of the (log-)likelihood
function evaluated at the optimal set of parameters.</p>
</dd>
<dt><code>mpinJ</code></dt><dd><p>(<code>numeric</code>) returns the values of the multilayer probability of
informed trading per layer, calculated using the layer-specific estimated
parameters.</p>
</dd>
<dt><code>mpin</code></dt><dd><p>(<code>numeric</code>) returns the global value of the multilayer probability
of informed trading. It is the sum of the multilayer probabilities of
informed trading per layer stored in the slot <code>mpinJ</code>.</p>
</dd>
<dt><code>mpin.goodbad</code></dt><dd><p>(<code>list</code>) returns a list containing a decomposition of
<code>MPIN</code> into good-news, and bad-news <code>MPIN</code> components. The decomposition
has been suggested for PIN measure in
Brennan et al. (2016). The list has four elements:
<code>mpinG</code>, and <code>mpinB</code> are the global good-news, and bad-news components of
<code>MPIN</code>, while <code>mpinGj</code>, and <code>mpinBj</code> are two vectors containing  the
good-news (bad-news) components of <code>MPIN</code> computed per layer.</p>
</dd>
<dt><code>dataset</code></dt><dd><p>(<code>dataframe</code>) returns the dataset of buys and sells used
in the ECM estimation of the MPIN model.</p>
</dd>
<dt><code>initialsets</code></dt><dd><p>(<code>dataframe</code>) returns the initial parameter sets used
in the ECM estimation of the MPIN model.</p>
</dd>
<dt><code>details</code></dt><dd><p>(<code>dataframe</code>) returns a dataframe containing the estimated
parameters of the <code>ECM</code> method for each initial parameter set.</p>
</dd>
<dt><code>models</code></dt><dd><p>(<code>list</code>) returns the list of <code>estimate.mpin.ecm</code> objects
storing the results of estimation using the function <code>mpin_ecm()</code> for
different values of the argument <code>layers</code>. It returns <code>NULL</code> when the
argument <code>layers</code> of the function <code>mpin_ecm()</code> take a specific value.</p>
</dd>
<dt><code>AIC</code></dt><dd><p>(<code>numeric</code>) returns the value of the Akaike Information Criterion
(AIC).</p>
</dd>
<dt><code>BIC</code></dt><dd><p>(<code>numeric</code>) returns the value of the Bayesian Information Criterion
(BIC).</p>
</dd>
<dt><code>AWE</code></dt><dd><p>(<code>numeric</code>) returns the value of the Approximate Weight of
Evidence.</p>
</dd>
<dt><code>criterion</code></dt><dd><p>(<code>character</code>) returns the model selection criterion used to
find the optimal estimate for the <code>MPIN</code> model. It takes one of these values
<code>'BIC'</code>, <code>'AIC'</code>, <code>'AWE'</code>; which stand for Bayesian Information Criterion,
Akaike Information Criterion, and Approximate Weight of Evidence,
respectively.</p>
</dd>
<dt><code>hyperparams</code></dt><dd><p>(<code>list</code>) returns the hyperparameters of the <code>ECM</code>
algorithm, which are <code>minalpha</code>, <code>maxeval</code>, <code>tolerance</code>, and <code>maxlayers</code>.
Check the details section of <code>mpin_ecm()</code> to know more about these
parameters.</p>
</dd>
<dt><code>runningtime</code></dt><dd><p>(<code>numeric</code>) returns the running time of the estimation
in seconds.</p>
</dd>
</dl>

<hr>
<h2 id='estimate.pin-class'>PIN estimation results</h2><span id='topic+estimate.pin-class'></span><span id='topic+show+2Cestimate.pin-method'></span>

<h3>Description</h3>

<p>The class <code>estimate.pin</code> is a blueprint of <code>S4</code> objects
that store the results of the different <code>PIN</code> functions: <code>pin()</code>, <code>pin_yz()</code>,
<code>pin_gwj()</code>, and <code>pin_ea()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'estimate.pin'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate.pin-class_+3A_object">object</code></td>
<td>
<p>an object of class <code>estimate.pin</code></p>
</td></tr>
</table>


<h3>Slots</h3>


<dl>
<dt><code>success</code></dt><dd><p>(<code>logical</code>) takes the value <code>TRUE</code> when the estimation has
succeeded, <code>FALSE</code> otherwise.</p>
</dd>
<dt><code>errorMessage</code></dt><dd><p>(<code>character</code>)  contains an error message if the <code>PIN</code>
estimation has failed, and is empty otherwise.</p>
</dd>
<dt><code>convergent.sets</code></dt><dd><p>(<code>numeric</code>) returns the number of initial parameter
sets at which the likelihood maximization converged.</p>
</dd>
<dt><code>algorithm</code></dt><dd><p>(<code>character</code>) returns the algorithm used to determine the set
of initial parameter sets for the maximum likelihood estimation.
It takes one of the following values:
</p>

<ul>
<li> <p><code>"YZ"</code>: Yan and Zhang (2012)
</p>
</li>
<li> <p><code>"GWJ"</code>: Gan, Wei and Johnstone (2015)
</p>
</li>
<li> <p><code>"YZ*"</code>: Yan and Zhang (2012) as modified by Ersan and Alici (2016)
</p>
</li>
<li> <p><code>"EA"</code>: Ersan and Alici (2016)
</p>
</li>
<li> <p><code>"CUSTOM"</code>: Custom initial parameter sets
</p>
</li></ul>
</dd>
<dt><code>factorization</code></dt><dd><p>(<code>character</code>) returns the factorization of the <code>PIN</code>
likelihood function as used in the maximum likelihood estimation.
It takes one of the following values:
</p>

<ul>
<li> <p><code>"NONE"</code>: No factorization
</p>
</li>
<li> <p><code>"EHO"</code>: Easley, Hvidkjaer and O'Hara (2010)
</p>
</li>
<li> <p><code>"LK"</code>: Lin and Ke (2011)
</p>
</li>
<li> <p><code>"E"</code>: Ersan (2016)
</p>
</li></ul>
</dd>
<dt><code>parameters</code></dt><dd><p>(<code>list</code>) returns the list of the maximum likelihood
estimates (<code class="reqn">\alpha</code>, <code class="reqn">\delta</code>, <code class="reqn">\mu</code>, <code class="reqn">\epsilon</code><sub>b</sub>, <code class="reqn">\epsilon</code><sub>s</sub>)</p>
</dd>
<dt><code>likelihood</code></dt><dd><p>(<code>numeric</code>) returns the value of (the factorization of)
the likelihood function evaluated at the optimal set of parameters.</p>
</dd>
<dt><code>pin</code></dt><dd><p>(<code>numeric</code>) returns the value of the probability of informed
trading.</p>
</dd>
<dt><code>pin.goodbad</code></dt><dd><p>(<code>list</code>) returns a list containing a decomposition
of <code>PIN</code> into good-news, and bad-news <code>PIN</code> components. The decomposition has
been suggested in Brennan et al. (2016). The list
has two elements: <code>pinG</code>, and <code>pinB</code> are the good-news, and bad-news
components of <code>PIN</code>, respectively.</p>
</dd>
<dt><code>dataset</code></dt><dd><p>(<code>dataframe</code>) returns the dataset of buys and sells used
in the maximum likelihood estimation of the PIN model.</p>
</dd>
<dt><code>initialsets</code></dt><dd><p>(<code>dataframe</code>) returns the initial parameter sets used
in the maximum likelihood estimation of the PIN model.</p>
</dd>
<dt><code>details</code></dt><dd><p>(<code>dataframe</code>) returns a dataframe containing the estimated
parameters by the <code>MLE</code> method for each initial parameter set.</p>
</dd>
<dt><code>runningtime</code></dt><dd><p>(<code>numeric</code>) returns the running time of the estimation
of the <code>PIN</code> model in seconds.</p>
</dd>
</dl>

<hr>
<h2 id='estimate.vpin-class'>VPIN estimation results</h2><span id='topic+estimate.vpin-class'></span><span id='topic+show+2Cestimate.vpin-method'></span>

<h3>Description</h3>

<p>The class <code>estimate.vpin</code> is a blueprint for <code>S4</code> objects
that store the results of the <code>VPIN</code> estimation method using the function
<code>vpin()</code>.
</p>
<p>The function show() displays a description of the
estimate.vpin object: descriptive statistics of the <code>VPIN</code> variable,
the set of relevant parameters, and the running time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'estimate.vpin'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate.vpin-class_+3A_object">object</code></td>
<td>
<p>an object of class <code>estimate.vpin</code></p>
</td></tr>
</table>


<h3>Slots</h3>


<dl>
<dt><code>success</code></dt><dd><p>(<code>logical</code>) returns the value <code>TRUE</code> when the estimation
has succeeded, <code>FALSE</code> otherwise.</p>
</dd>
<dt><code>errorMessage</code></dt><dd><p>(<code>character</code>) returns an error message if the <code>VPIN</code>
estimation has failed, and is empty otherwise.</p>
</dd>
<dt><code>parameters</code></dt><dd><p>(<code>numeric</code>) returns a numeric vector of estimation
parameters (tbSize, buckets, samplength, VBS, #days), where <code>tbSize</code> is the
size of timebars (in seconds); <code>buckets</code> is the number of buckets per average
volume day; <code>VBS</code> is  Volume Bucket Size (daily average volume/number of
buckets <code>buckets</code>); <code>samplength</code> is the length of the window used to estimate
<code>VPIN</code>; and  <code style="white-space: pre;">&#8288;#days&#8288;</code> is the number of days in the dataset.</p>
</dd>
<dt><code>bucketdata</code></dt><dd><p>(<code>dataframe</code>) returns the dataframe containing detailed
information about buckets. Following the output of
Abad and Yague (2012), we report for each bucket its
identifier (<code>bucket</code>), the aggregate buy
volume (<code>agg.bVol</code>), the aggregate sell volume (<code>agg.sVol</code>), the
absolute order imbalance (<code>AOI=|agg.bVol-agg.sVol|</code>),
the start time (<code>starttime</code>), the end time (<code>endtime</code>), the
duration in seconds (<code>duration</code>) as well as
the <code>VPIN</code> vector.</p>
</dd>
<dt><code>vpin</code></dt><dd><p>(<code>numeric</code>) returns the vector of the volume-synchronized
probabilities of informed trading.</p>
</dd>
<dt><code>dailyvpin</code></dt><dd><p>(<code>dataframe</code>) returns the daily <code>VPIN</code> values. Two
variants are provided for any given day: <code>dvpin</code> corresponds to
the unweighted average of vpin values, and <code>dvpin.weighted</code>
corresponds to the average of vpin values weighted by bucket duration.</p>
</dd>
<dt><code>runningtime</code></dt><dd><p>(<code>numeric</code>) returns the running time of the <code>VPIN</code>
estimation in seconds.</p>
</dd>
</dl>

<hr>
<h2 id='factorizations'>Factorizations of the different PIN likelihood functions</h2><span id='topic+factorizations'></span><span id='topic+fact_pin_eho'></span><span id='topic+fact_pin_lk'></span><span id='topic+fact_pin_e'></span><span id='topic+fact_mpin'></span><span id='topic+fact_adjpin'></span>

<h3>Description</h3>

<p>The <code>PIN</code> likelihood function is derived from the original <code>PIN</code> model as
developed by Easley and Ohara (1992) and
Easley et al. (1996). The maximization of the
likelihood function as is leads to computational problems, in particular,
to floating point errors. To remedy to this issue, several
log-transformations or factorizations of the different <code>PIN</code> likelihood
functions have been suggested.
The main factorizations in the literature are:
</p>

<ul>
<li> <p><code>fact_pin_eho()</code>: factorization of
Easley et al. (2010)
</p>
</li>
<li> <p><code>fact_pin_lk()</code>: factorization of
Lin and Ke (2011)
</p>
</li>
<li> <p><code>fact_pin_e()</code>: factorization of
Ersan (2016)
</p>
</li></ul>

<p>The factorization of the likelihood function of the multilayer <code>PIN</code> model,
as developed in Ersan (2016).
</p>

<ul>
<li> <p><code>fact_mpin()</code>: factorization of
Ersan (2016)
</p>
</li></ul>

<p>The factorization of the likelihood function of the adjusted <code>PIN</code> model
(Duarte and Young 2009), is derived, and presented in
Ersan and Ghachem (2022b).
</p>

<ul>
<li> <p><code>fact_adjpin()</code>: factorization in
Ersan and Ghachem (2022b)
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>fact_pin_eho(data, parameters = NULL)

fact_pin_lk(data, parameters = NULL)

fact_pin_e(data, parameters = NULL)

fact_mpin(data, parameters = NULL)

fact_adjpin(data, parameters = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="factorizations_+3A_data">data</code></td>
<td>
<p>A dataframe with 2 variables: the first
corresponds to buyer-initiated trades (buys), and the second corresponds
to seller-initiated trades (sells).</p>
</td></tr>
<tr><td><code id="factorizations_+3A_parameters">parameters</code></td>
<td>
<p>In the case of the <code>PIN</code> likelihood
factorization, it is an ordered numeric vector (<code class="reqn">\alpha</code>, <code class="reqn">\delta</code>,
<code class="reqn">\mu</code>, <code class="reqn">\epsilon</code><sub>b</sub>, <code class="reqn">\epsilon</code><sub>s</sub>). In the case of the <code>MPIN</code> likelihood factorization,
it is an ordered numeric vector (<strong><code class="reqn">\alpha</code></strong>, <strong><code class="reqn">\delta</code></strong>,
<strong><code class="reqn">\mu</code></strong>, <code class="reqn">\epsilon</code><sub>b</sub>, <code class="reqn">\epsilon</code><sub>s</sub>), where <strong><code class="reqn">\alpha</code></strong>, <strong><code class="reqn">\delta</code></strong>,
and <strong><code class="reqn">\mu</code></strong> are numeric vectors of size <code>J</code>, where <code>J</code> is the
number of information layers in the data.
In the case of the <code>AdjPIN</code> likelihood factorization, it is an ordered
numeric vector (<code class="reqn">\alpha</code>, <code class="reqn">\delta</code>, <code class="reqn">\theta</code>, <code class="reqn">\theta'</code>,
<code class="reqn">\epsilon</code><sub>b</sub>, <code class="reqn">\epsilon</code><sub>s</sub>, <code class="reqn">\mu</code><sub>b</sub>, <code class="reqn">\mu</code><sub>s</sub>, <code class="reqn">\Delta</code><sub>b</sub>, <code class="reqn">\Delta</code><sub>s</sub>). The default value is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument 'data' should be a numeric dataframe, and contain
at least two variables. Only the first two variables will be considered:
The first variable is assumed to correspond to the total number of
buyer-initiated trades, while the second variable is assumed to
correspond to the total number of seller-initiated trades. Each row or
observation correspond to a trading day. <code>NA</code> values will be ignored.
</p>
<p>Our tests, in line with Lin and Ke (2011),
and Ersan and Alici (2016), demonstrate very
similar results for <code>fact_pin_lk()</code>, and <code>fact_pin_e()</code>, both
having substantially better estimates than <code>fact_pin_eho()</code>.
</p>


<h3>Value</h3>

<p>If the argument <code>parameters</code> is omitted, returns a function
object that can be used with the optimization functions <code>optim()</code>,
and <code>neldermead()</code>.
</p>
<p>If the argument <code>parameters</code> is provided, returns a numeric value of the
log-likelihood function evaluated at the dataset <code>data</code> and the
parameters <code>parameters</code>, where <code>parameters</code> is a numeric vector
following this order (<code class="reqn">\alpha</code>, <code class="reqn">\delta</code>, <code class="reqn">\mu</code>, <code class="reqn">\epsilon</code><sub>b</sub>, <code class="reqn">\epsilon</code><sub>s</sub>)
for the factorizations of the <code>PIN</code> likelihood function, (<strong><code class="reqn">\alpha</code></strong>,
<strong><code class="reqn">\delta</code></strong>, <strong><code class="reqn">\mu</code></strong>, <code class="reqn">\epsilon</code><sub>b</sub>, <code class="reqn">\epsilon</code><sub>s</sub>) for the factorization of the
<code>MPIN</code> likelihood function, and (<code class="reqn">\alpha</code>, <code class="reqn">\delta</code>, <code class="reqn">\theta</code>,
<code class="reqn">\theta'</code>, <code class="reqn">\epsilon</code><sub>b</sub>, <code class="reqn">\epsilon</code><sub>s</sub> ,<code class="reqn">\mu</code><sub>b</sub>, <code class="reqn">\mu</code><sub>s</sub>, <code class="reqn">\Delta</code><sub>b</sub>, <code class="reqn">\Delta</code><sub>s</sub>) for the factorization of
the <code>AdjPIN</code> likelihood function.
</p>


<h3>References</h3>

<p>Duarte J, Young L (2009).
&ldquo;Why is PIN priced?&rdquo;
<em>Journal of Financial Economics</em>, <b>91</b>(2), 119&ndash;138.
ISSN 0304405X.<br /><br /> Easley D, Hvidkjaer S, Ohara M (2010).
&ldquo;Factoring information into returns.&rdquo;
<em>Journal of Financial and Quantitative Analysis</em>, <b>45</b>(2), 293&ndash;309.
ISSN 00221090.<br /><br /> Easley D, Kiefer NM, Ohara M, Paperman JB (1996).
&ldquo;Liquidity, information, and infrequently traded stocks.&rdquo;
<em>Journal of Finance</em>, <b>51</b>(4), 1405&ndash;1436.
ISSN 00221082.<br /><br /> Easley D, Ohara M (1992).
&ldquo;Time and the Process of Security Price Adjustment.&rdquo;
<em>The Journal of Finance</em>, <b>47</b>(2), 577&ndash;605.
ISSN 15406261.<br /><br /> Ersan O (2016).
&ldquo;Multilayer Probability of Informed Trading.&rdquo;
<em>Available at SSRN 2874420</em>.<br /><br /> Ersan O, Alici A (2016).
&ldquo;An unbiased computation methodology for estimating the probability of informed trading (PIN).&rdquo;
<em>Journal of International Financial Markets, Institutions and Money</em>, <b>43</b>, 74&ndash;94.
ISSN 10424431.<br /><br /> Ersan O, Ghachem M (2022b).
&ldquo;A methodological approach to the computational problems in the estimation of adjusted PIN model.&rdquo;
<em>Available at SSRN 4117954</em>.<br /><br /> Lin H, Ke W (2011).
&ldquo;A computing bias in estimating the probability of informed trading.&rdquo;
<em>Journal of Financial Markets</em>, <b>14</b>(4), 625-640.
ISSN 1386-4181.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># There is a preloaded quarterly dataset called 'dailytrades' with 60
# observations. Each observation corresponds to a day and contains the
# total number of buyer-initiated trades ('B') and seller-initiated
# trades ('S') on that day. To know more, type ?dailytrades

xdata &lt;- dailytrades

# ------------------------------------------------------------------------ #
# Using fact_pin_eho(), fact_pin_lk(), fact_pin_e() to find the likelihood #
# value as factorized by Easley(2010), Lin &amp; Ke (2011), and Ersan(2016).   #
# ------------------------------------------------------------------------ #

# Choose a given parameter set to evaluate the likelihood function at a
# givenpoint  = (alpha, delta, mu, eps.b, eps.s)

givenpoint &lt;- c(0.4, 0.1, 800, 300, 200)

# Use the ouput of fact_pin_e() with the optimization function optim() to
# find optimal estimates of the PIN model.

model &lt;- suppressWarnings(optim(givenpoint, fact_pin_e(xdata)))

# Collect the model estimates from the variable model and display them.

varnames &lt;- c("alpha", "delta", "mu", "eps.b", "eps.s")
estimates &lt;- setNames(model$par, varnames)
show(estimates)

# Find the value of the log-likelihood function at givenpoint

lklValue &lt;- fact_pin_lk(xdata, givenpoint)

show(lklValue)

# ------------------------------------------------------------------------ #
# Using fact_mpin() to find the value of the MPIN likelihood function as   #
# factorized by Ersan (2016).                                              #
# ------------------------------------------------------------------------ #

# Choose a given parameter set to evaluate the likelihood function at a
# givenpoint  = (alpha(), delta(), mu(), eps.b, eps.s) where alpha(), delta()
# and mu() are vectors of size 2.

givenpoint &lt;- c(0.4, 0.5, 0.1, 0.6, 600, 1000, 300, 200)

# Use the output of fact_mpin() with the optimization function optim() to
# find optimal estimates of the PIN model.

model &lt;- suppressWarnings(optim(givenpoint, fact_mpin(xdata)))

# Collect the model estimates from the variable model and display them.

varnames &lt;- c(paste("alpha", 1:2, sep = ""), paste("delta", 1:2, sep = ""),
              paste("mu", 1:2, sep = ""), "eb", "es")
estimates &lt;- setNames(model$par, varnames)
show(estimates)

# Find the value of the MPIN likelihood function at givenpoint

lklValue &lt;- fact_mpin(xdata, givenpoint)

show(lklValue)

# ------------------------------------------------------------------------ #
# Using fact_adjpin() to find the value of the DY likelihood function as   #
# factorized by Ersan and Ghachem (2022b).                                 #
# ------------------------------------------------------------------------ #

# Choose a given parameter set to evaluate the likelihood function
# at a the initial parameter set givenpoint = (alpha, delta,
# theta, theta',eps.b, eps.s, muB, muS, db, ds)

givenpoint &lt;- c(0.4, 0.1, 0.3, 0.7, 500, 600, 800, 1000, 300, 200)

# Use the output of fact_adjpin() with the optimization function
# neldermead() to find optimal estimates of the AdjPIN model.

low &lt;- c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
up &lt;- c(1, 1, 1, 1, Inf, Inf, Inf, Inf, Inf, Inf)
model &lt;- nloptr::neldermead(
givenpoint, fact_adjpin(xdata), lower = low, upper = up)

# Collect the model estimates from the variable model and display them.

varnames &lt;- c("alpha", "delta", "theta", "thetap", "eps.b", "eps.s",
              "muB", "muS", "db", "ds")
estimates &lt;- setNames(model$par, varnames)
show(estimates)

# Find the value of the log-likelihood function at givenpoint

adjlklValue &lt;- fact_adjpin(xdata, givenpoint)
show(adjlklValue)
</code></pre>

<hr>
<h2 id='generatedata_adjpin'>Simulation of AdjPIN model data.</h2><span id='topic+generatedata_adjpin'></span>

<h3>Description</h3>

<p>Generates a <code>dataset</code> object or a <code>data.series</code> object (a list
of <code>dataset</code> objects) storing simulation parameters as well as aggregate
daily buys and sells simulated following the assumption of the <code>AdjPIN</code> model
of Duarte and Young (2009).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generatedata_adjpin(series=1, days = 60, parameters = NULL, ranges = list(),
restricted = list(), verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generatedata_adjpin_+3A_series">series</code></td>
<td>
<p>The number of datasets to generate.</p>
</td></tr>
<tr><td><code id="generatedata_adjpin_+3A_days">days</code></td>
<td>
<p>The number of trading days, for which aggregated
buys and sells are generated. The default value is <code>60</code>.</p>
</td></tr>
<tr><td><code id="generatedata_adjpin_+3A_parameters">parameters</code></td>
<td>
<p>A vector of model parameters of size <code>10</code> and it has
the following form {<code class="reqn">\alpha</code>, <code class="reqn">\delta</code>, <code class="reqn">\theta</code>, <code class="reqn">\theta'</code>,
<code class="reqn">\epsilon</code><sub>b</sub>, <code class="reqn">\epsilon</code><sub>s</sub>, <code class="reqn">\mu</code><sub>b</sub>, <code class="reqn">\mu</code><sub>s</sub>, <code class="reqn">\Delta</code><sub>b</sub>, <code class="reqn">\Delta</code><sub>s</sub>}.</p>
</td></tr>
<tr><td><code id="generatedata_adjpin_+3A_ranges">ranges</code></td>
<td>
<p>A list of ranges for the different simulation
parameters having named elements <code>alpha</code> <code class="reqn">(\alpha)</code>,
<code>delta</code> <code class="reqn">(\delta)</code>, <code>theta</code> <code class="reqn">(\theta)</code>, <code>thetap</code> <code class="reqn">(\theta')</code>,
<code>eps.b</code> (<code class="reqn">\epsilon</code><sub>b</sub>), <code>eps.s</code> (<code class="reqn">\epsilon</code><sub>s</sub>), <code>mu.b</code> (<code class="reqn">\mu</code><sub>b</sub>), <code>mu.s</code> (<code class="reqn">\mu</code><sub>s</sub>), <code>d.b</code> (<code class="reqn">\Delta</code><sub>b</sub>),
<code>d.s</code> (<code class="reqn">\Delta</code><sub>s</sub>).
The value of each element is a vector of two numbers: the first one is the
minimal value <code>min_v</code> and the second one is the maximal value <code>max_v</code>.
If the element corresponding to a given parameter is missing, the default
range for that parameter is used, otherwise, the simulation parameters are
uniformly drawn from the interval (<code>min_v</code>, <code>max_v</code>). The default value
is <code>list()</code>.</p>
</td></tr>
<tr><td><code id="generatedata_adjpin_+3A_restricted">restricted</code></td>
<td>
<p>A binary list that allows estimating restricted
AdjPIN models by specifying which model parameters are assumed to be equal.
It contains one or multiple of the following four elements
<code style="white-space: pre;">&#8288;{theta, mu, eps, d}&#8288;</code>. For instance, If <code>theta</code> is set to <code>TRUE</code>,
then the probability of liquidity shock in no-information days, and in
information days is assumed to be the same (<code class="reqn">\theta</code><code>=</code><code class="reqn">\theta'</code>). If any of
the remaining rate elements <code style="white-space: pre;">&#8288;{mu, eps, d}&#8288;</code> is set to <code>TRUE</code>,
(say  <code>mu=TRUE</code>), then the rate is assumed to be the same on the buy side,
and on the sell side (<code class="reqn">\mu</code><sub>b</sub><code>=</code><code class="reqn">\mu</code><sub>s</sub>). If more than one element is set to
<code>TRUE</code>, then the restrictions are combined. For instance, if the argument
<code>restricted</code> is set to <code>list(theta=TRUE, eps=TRUE, d=TRUE)</code>, then the
restricted AdjPIN model is estimated, where <code class="reqn">\theta</code><code>=</code><code class="reqn">\theta'</code>, <code class="reqn">\epsilon</code><sub>b</sub><code>=</code><code class="reqn">\epsilon</code><sub>s</sub>,
and <code class="reqn">\Delta</code><sub>b</sub><code>=</code><code class="reqn">\Delta</code><sub>s</sub>. If the value of the argument <code>restricted</code> is the empty list
(<code>list()</code>), then all parameters of the model are assumed to be independent,
and the unrestricted model is estimated. The default value is the empty
list <code>list()</code>.</p>
</td></tr>
<tr><td><code id="generatedata_adjpin_+3A_verbose">verbose</code></td>
<td>
<p>A binary variable that determines whether detailed
information about the progress of the data generation is displayed.
No output is produced when <code>verbose</code> is set to <code>FALSE</code>. The default
value is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the argument <code>parameters</code> is missing, then the parameters are
generated using the ranges specified in the argument <code>ranges</code>.
If the argument <code>ranges</code> is set to <code>list()</code>, default ranges are used. Using
the default ranges, the simulation parameters are obtained using the
following procedure:
</p>

<ul>
<li> <p><code class="reqn">\alpha</code>, <code class="reqn">\delta</code>: <code>(alpha, delta)</code> uniformly
distributed on <code>(0, 1)</code>.
</p>
</li>
<li> <p><code class="reqn">\theta</code>, <code class="reqn">\theta'</code>: <code>(theta,thetap)</code> uniformly
distributed on <code>(0, 1)</code>.
</p>
</li>
<li> <p><code class="reqn">\epsilon</code><sub>b</sub>: <code>(eps.b)</code> an integer uniformly drawn from the interval
<code>(100, 10000)</code> with step <code>50</code>.
</p>
</li>
<li> <p><code class="reqn">\epsilon</code><sub>s</sub>: <code>(eps.s)</code> an integer uniformly drawn from (<code>(4/5)</code><code class="reqn">\epsilon</code><sub>b</sub>,
<code>(6/5)</code><code class="reqn">\epsilon</code><sub>b</sub>) with step <code>50</code>.
</p>
</li>
<li> <p><code class="reqn">\Delta</code><sub>b</sub>: <code>(d.b)</code> an integer uniformly drawn from (<code>(1/2)</code><code class="reqn">\epsilon</code><sub>b</sub>,
<code>2</code><code class="reqn">\epsilon</code><sub>b</sub>).
</p>
</li>
<li> <p><code class="reqn">\Delta</code><sub>s</sub>: <code>(d.s)</code> an integer uniformly drawn from (<code>(4/5)</code><code class="reqn">\Delta</code><sub>b</sub>,
<code>(6/5)</code><code class="reqn">\Delta</code><sub>b</sub>).
</p>
</li>
<li> <p><code class="reqn">\mu</code><sub>b</sub>: <code>(mu.b)</code> uniformly distributed on the interval
<code style="white-space: pre;">&#8288;((1/2) max&#8288;</code>(<code class="reqn">\epsilon</code><sub>b</sub>, <code class="reqn">\epsilon</code><sub>s</sub>)<code style="white-space: pre;">&#8288;, 5 max&#8288;</code>(<code class="reqn">\epsilon</code><sub>b</sub>, <code class="reqn">\epsilon</code><sub>s</sub>)<code style="white-space: pre;">&#8288;)&#8288;</code>.
</p>
</li>
<li> <p><code class="reqn">\mu</code><sub>s</sub>: <code>(mu.s)</code> uniformly distributed on the interval
(<code>(4/5)</code><code class="reqn">\mu</code><sub>b</sub>, <code>(6/5)</code><code class="reqn">\mu</code><sub>b</sub>)..
</p>
</li></ul>

<p>Based on the simulation parameters <code>parameters</code>, daily buys and sells are
generated by the assumption that buys and sells follow Poisson
distributions with mean parameters:
</p>

<ul>
<li><p> (<code class="reqn">\epsilon</code><sub>b</sub>, <code class="reqn">\epsilon</code><sub>s</sub>) in a day with no information and no liquidity shock;
</p>
</li>
<li><p> (<code class="reqn">\epsilon</code><sub>b</sub>+<code class="reqn">\Delta</code><sub>b</sub>, <code class="reqn">\epsilon</code><sub>s</sub>+<code class="reqn">\Delta</code><sub>s</sub>) in a day with no information and with liquidity
shock;
</p>
</li>
<li><p> (<code class="reqn">\epsilon</code><sub>b</sub>+<code class="reqn">\mu</code><sub>b</sub>, <code class="reqn">\epsilon</code><sub>s</sub>) in a day with good information and no liquidity
shock;
</p>
</li>
<li><p> (<code class="reqn">\epsilon</code><sub>b</sub>+<code class="reqn">\mu</code><sub>b</sub>+<code class="reqn">\Delta</code><sub>b</sub>, <code class="reqn">\epsilon</code><sub>s</sub>+<code class="reqn">\Delta</code><sub>s</sub>) in a day with good information and
liquidity shock;
</p>
</li>
<li><p> (<code class="reqn">\epsilon</code><sub>b</sub>, <code class="reqn">\epsilon</code><sub>s</sub>+<code class="reqn">\mu</code><sub>s</sub>) in a day with bad information and no liquidity
shock;
</p>
</li>
<li><p> (<code class="reqn">\epsilon</code><sub>b</sub>+<code class="reqn">\Delta</code><sub>s</sub>, <code class="reqn">\epsilon</code><sub>s</sub>+<code class="reqn">\mu</code><sub>s</sub>+<code class="reqn">\Delta</code><sub>s</sub>) in a day with bad information and
liquidity shock;
</p>
</li></ul>



<h3>Value</h3>

<p>Returns an object of class <code>dataset</code> if <code>series=1</code>, and an
object of class <code>data.series</code> if <code>series&gt;1</code>.
</p>


<h3>References</h3>

<p>Duarte J, Young L (2009).
&ldquo;Why is PIN priced?&rdquo;
<em>Journal of Financial Economics</em>, <b>91</b>(2), 119&ndash;138.
ISSN 0304405X.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># ------------------------------------------------------------------------ #
# Generate data following the AdjPIN model using generatedata_adjpin()     #
# ------------------------------------------------------------------------ #

# With no arguments, the function generates one dataset object spanning
# 60 days, and where the parameters are chosen as described in the section
# 'Details'.

sdata &lt;- generatedata_adjpin()

# Alternatively, simulation parameters can be provided. Recall the order of
# parameters (alpha, delta, theta, theta', eps.b, eps.s, mub, mus, db, ds).

givenpoint &lt;- c(0.4, 0.1, 0.5, 0.6, 800, 1000, 2300, 4000, 500, 500)
sdata &lt;- generatedata_adjpin(parameters = givenpoint)

# Data can be generated following restricted AdjPIN models, for example, with
# restrictions 'eps.b = eps.s', and 'mu.b = mu.s'.

sdata &lt;- generatedata_adjpin(restricted = list(eps = TRUE, mu = TRUE))

# Data can be generated using provided ranges of simulation parameters as fed
# to the function using the argument 'ranges', where thetap corresponds to
# theta'.

sdata &lt;- generatedata_adjpin(ranges = list(
  alpha = c(0.1, 0.15), delta = c(0.2, 0.2),
  theta = c(0.2, 0.6), thetap = c(0.2, 0.4)
))

# The value of a given simulation parameter can be set to a specific value by
# setting the range of the desired parameter takes a unique value, instead of
# a pair of values.

sdata &lt;- generatedata_adjpin(ranges = list(
  alpha = 0.4, delta = c(0.2, 0.7),
  eps.b = c(100, 7000), mu.b = 8000
))

# Display the details of the generated simulation data

show(sdata)

# ------------------------------------------------------------------------ #
# Use generatedata_adjpin() to check the accuracy of adjpin()              #
# ------------------------------------------------------------------------ #

model &lt;- adjpin(sdata@data, verbose = FALSE)

summary &lt;- cbind(
  c(sdata@emp.pin['adjpin'], model@adjpin, abs(model@adjpin -
  sdata@emp.pin['adjpin'])),
  c(sdata@emp.pin['psos'], model@psos, abs(model@psos -
  sdata@emp.pin['psos']))
)
colnames(summary) &lt;- c('adjpin', 'psos')
rownames(summary) &lt;- c('Data', 'Model', 'Difference')

show(knitr::kable(summary, 'simple'))

</code></pre>

<hr>
<h2 id='generatedata_mpin'>Simulation of MPIN model data</h2><span id='topic+generatedata_mpin'></span>

<h3>Description</h3>

<p>Generates a <code>dataset</code> object or a <code>data.series</code> object (a list
of <code>dataset</code> objects) storing simulation parameters as well as aggregate
daily buys and sells simulated following the assumption of the <code>MPIN</code> model
of (Ersan 2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generatedata_mpin(series = 1, days = 60, layers = NULL,
                         parameters = NULL, ranges = list(), ...,
                         verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generatedata_mpin_+3A_series">series</code></td>
<td>
<p>The number of datasets to generate.</p>
</td></tr>
<tr><td><code id="generatedata_mpin_+3A_days">days</code></td>
<td>
<p>The number of trading days for which aggregated buys and
sells are generated. Default value is <code>60</code>.</p>
</td></tr>
<tr><td><code id="generatedata_mpin_+3A_layers">layers</code></td>
<td>
<p>The number of information layers to be included in the
simulated data. Default value is <code>NULL</code>.
If <code>layers</code> is omitted or set to <code>NULL</code>, the number of layers is uniformly
selected from the set <code>{1, ..., maxlayers}</code>.</p>
</td></tr>
<tr><td><code id="generatedata_mpin_+3A_parameters">parameters</code></td>
<td>
<p>A vector of model parameters of size <code>3J+2</code>
where <code>J</code> is the number of information layers and it has the
following form
{<code class="reqn">\alpha</code><sub>1</sub>,
...,<code class="reqn">\alpha</code><sub>J</sub>,
<code class="reqn">\delta</code><sub>1</sub>,...,
<code class="reqn">\delta</code><sub>J</sub>,
<code class="reqn">\mu</code><sub>1</sub>,...,
<code class="reqn">\mu</code><sub>J</sub>, <code class="reqn">\epsilon</code><sub>b</sub>, <code class="reqn">\epsilon</code><sub>s</sub>}.</p>
</td></tr>
<tr><td><code id="generatedata_mpin_+3A_ranges">ranges</code></td>
<td>
<p>A list of ranges for the different simulation
parameters having named elements <code class="reqn">\alpha</code>, <code class="reqn">\delta</code>, <code class="reqn">\epsilon</code><sub>b</sub>, <code class="reqn">\epsilon</code><sub>s</sub>,
and <code class="reqn">\mu</code>.
The value of each element is a vector of two numbers: the first one is the
minimal value <code>min_v</code> and the second one is the maximal value <code>max_v</code>.
If the element corresponding to a given parameter is missing, the default
range for that parameter is used. If the argument <code>ranges</code> is an empty
list and <code>parameters</code> is <code>NULL</code>, the default ranges for the parameters
are used. The simulation parameters are uniformly drawn from the interval
(<code>min_v</code>, <code>max_v</code>) for the specified parameters.
The default value is <code>list()</code>.</p>
</td></tr>
<tr><td><code id="generatedata_mpin_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to the function
<code>generatedata_mpin()</code>. The recognized arguments are <code>confidence</code>,
<code>maxlayers</code>, <code>eps_ratio</code>, <code>mu_ratio</code>.
</p>

<ul>
<li> <p><code>confidence</code> (<code>numeric</code>) denotes the range of the confidence interval
associated with each layer such that all observations within the layer <code>j</code>
lie in the theoretical confidence interval of the Skellam distribution
centered on the mean order imbalance, at the level <code>'confidence'</code>.
The default value is <code>0.99</code>.
</p>
</li>
<li> <p><code>maxlayers</code> (<code>integer</code>) denotes the upper limit of number of layers
for the generated datasets. If the argument <code>layers</code> is missing, the layers
of the simulated datasets will be uniformly drawn from
<code>{1,..., maxlayers}</code>. When missing, <code>maxlayers</code> takes the default
value of <code>5</code>.
</p>
</li>
<li> <p><code>eps_ratio</code> (<code>numeric</code>) specifies the admissible range for the value
of the ratio <code class="reqn">\epsilon</code><sub>s</sub>/<code class="reqn">\epsilon</code><sub>b</sub>, It can be a two-value vector or just a single value.
If <code>eps_ratio</code> is a vector of two values: the first one is the minimal value
and the second one is the maximal value; and the function tries to generate
<code class="reqn">\epsilon</code><sub>s</sub> and <code class="reqn">\epsilon</code><sub>b</sub> satisfying that their ratios <code class="reqn">\epsilon</code><sub>s</sub>/<code class="reqn">\epsilon</code><sub>b</sub> lies within the interval
<code>eps_ratio</code>. If <code>eps_ratio</code> is a single number, then the function tries to
generate <code class="reqn">\epsilon</code><sub>s</sub> and <code class="reqn">\epsilon</code><sub>b</sub> satisfying <code class="reqn">\epsilon</code><sub>s</sub> = <code class="reqn">\epsilon</code><sub>b</sub> x <code>eps_ratio</code>. If this range
conflicts with other arguments such as <code>ranges</code>, a warning is displayed.
The default value is <code>c(0.75, 1.25)</code>.
</p>
</li>
<li> <p><code>mu_ratio</code> (<code>numeric</code>) it is the minimal value of the ratio between
two consecutive values of the vector <code>mu</code>. If <code>mu_ratio = 1.25</code> e.g., then
<code class="reqn">\mu</code><sub>j+1</sub> should be larger than
<code>1.25</code>* <code class="reqn">\mu</code><sub>j</sub> for all
<code style="white-space: pre;">&#8288;j = 1, .., J&#8288;</code>. If <code>mu_ratio</code> conflicts with other arguments such as <code>ranges</code>
or <code>confidence</code>, a warning is displayed. The default value is <code>NULL</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="generatedata_mpin_+3A_verbose">verbose</code></td>
<td>
<p>(<code>logical</code>) a binary variable that determines whether detailed
information about the progress of the data generation is displayed.
No output is produced when <code>verbose</code> is set to <code>FALSE</code>. The default
value is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An information layer refers to a given type of information event existing
in the data. The <code>PIN</code> model assumes a single type of information events
characterized by three parameters for <code class="reqn">\alpha</code>, <code class="reqn">\delta</code>, and
<code class="reqn">\mu</code>. The <code>MPIN</code> model relaxes the assumption, by relinquishing the
restriction on the number of information event types. When <code>layers = 1</code>,
generated data fit the assumptions of the <code>PIN</code> model.
</p>
<p>If the argument <code>parameters</code> is missing, then the simulation parameters are
generated using the ranges specified in the argument <code>ranges</code>.
If the argument <code>ranges</code> is <code>list()</code>, default ranges are used. Using the
default ranges, the simulation parameters are obtained using the following
procedure:
</p>

<ul>
<li> <p><code class="reqn">\alpha()</code>: a vector of length <code>layers</code>, where each
<code class="reqn">\alpha</code><sub>j</sub> is uniformly
distributed on <code>(0, 1)</code> subject to the condition:
<code class="reqn">\sum \alpha</code><sub>j</sub><code class="reqn">&lt; 1</code>.
</p>
</li>
<li> <p><code class="reqn">\delta()</code>: a vector of length <code>layers</code>, where each
<code class="reqn">\delta</code><sub>j</sub> uniformly distributed
on <code>(0, 1)</code>.
</p>
</li>
<li> <p><code class="reqn">\mu()</code>: a vector of length <code>layers</code>, where each
<code class="reqn">\mu</code><sub>j</sub> is uniformly distributed
on the interval <code style="white-space: pre;">&#8288;(0.5 max(&#8288;</code><code class="reqn">\epsilon</code><sub>b</sub><code style="white-space: pre;">&#8288;,&#8288;</code> <code class="reqn">\epsilon</code><sub>s</sub><code style="white-space: pre;">&#8288;), 5 max(&#8288;</code><code class="reqn">\epsilon</code><sub>b</sub><code style="white-space: pre;">&#8288;,&#8288;</code> <code class="reqn">\epsilon</code><sub>s</sub><code style="white-space: pre;">&#8288;))&#8288;</code>.
The <code class="reqn">\mu</code>:s are then sorted so the excess trading increases in the
information layers, subject to the condition that the ratio of two
consecutive <code class="reqn">\mu</code>'s should be at least <code>1.25</code>.
</p>
</li>
<li> <p><code class="reqn">\epsilon</code><sub>b</sub>: an integer drawn uniformly from the interval <code>(100, 10000)</code>
with step <code>50</code>.
</p>
</li>
<li> <p><code class="reqn">\epsilon</code><sub>s</sub>: an integer uniformly drawn from (<code>(3/4)</code><code class="reqn">\epsilon</code><sub>b</sub>, <code>(5/4)</code><code class="reqn">\epsilon</code><sub>b</sub>) with step
<code>50</code>.
</p>
</li></ul>

<p>Based on the simulation parameters <code>parameters</code>, daily buys and sells are
generated by the assumption that buys and sells
follow Poisson distributions with mean parameters (<code class="reqn">\epsilon</code><sub>b</sub>, <code class="reqn">\epsilon</code><sub>s</sub>) on days with no
information; with mean parameters
(<code class="reqn">\epsilon</code><sub>b</sub> + <code class="reqn">\mu</code><sub>j</sub>, <code class="reqn">\epsilon</code><sub>s</sub>) on days
with good information of layer <code class="reqn">j</code> and
(<code class="reqn">\epsilon</code><sub>b</sub>, <code class="reqn">\epsilon</code><sub>s</sub> + <code class="reqn">\mu</code><sub>j</sub>) on days
with bad information of layer <code class="reqn">j</code>.
</p>
<p><strong>Considerations for the ranges of simulation parameters:</strong> While
<code>generatedata_mpin()</code> function enables the user to simulate data series
with any set of theoretical parameters,
we strongly recommend the use of parameter sets satisfying below conditions
which are in line with the nature of empirical data and the theoretical
models used within this package.
When parameter values are not assigned by the user, the function, by default,
simulates data series that are in line with these criteria.
</p>

<ul>
<li> <p><em>Consideration 1</em>: any <code class="reqn">\mu</code>'s value separable from <code class="reqn">\epsilon</code><sub>b</sub> and <code class="reqn">\epsilon</code><sub>s</sub>
values, as well as other <code class="reqn">\mu</code> values. Otherwise, the <code>PIN</code> and <code>MPIN</code>
estimation would not yield expected results.<br />
[x] Sharp example.1: <code class="reqn">\epsilon</code><sub>b</sub><code class="reqn"> = 1000</code>; <code class="reqn">\mu = 1</code>. In this case, no
information layer can be captured in a healthy way by the use of the models
which relies on Poisson distributions.<br />
[x] Sharp example.2: <code class="reqn">\epsilon</code><sub>s</sub><code class="reqn"> = 1000</code>,
<code class="reqn">\mu</code><sub>1</sub><code class="reqn"> = 1000</code>,
and <code class="reqn">\mu</code><sub>2</sub><code class="reqn"> = 1001</code>.
Similarly, no distinction can be
made on the two simulated layers of informed trading. In real life, this
entails that there is only one type of information which would also be the
estimate of the <code>MPIN</code> model. However, in the simulated data properties,
there would be 2 layers which will lead the user to make a wrong
evaluation of model performance.
</p>
</li>
<li> <p><em>Consideration 2</em>: <code class="reqn">\epsilon</code><sub>b</sub> and <code class="reqn">\epsilon</code><sub>s</sub> being relatively close to each other.
When they are far from each other, that would indicate that there is
substantial asymmetry between buyer and seller initiated trades, being a
strong signal for informed trading.
There is no theoretical evidence to indicate that the uninformed trading in
buy and sell sides deviate much from each other in real life.
Besides, numerous papers that work with <code>PIN</code> model provide close to
each other uninformed intensities.
when no parameter values are assigned by the user, the function generates
data with the condition of sell side uninformed trading to be in the range of
<code style="white-space: pre;">&#8288;(4/5):=80%&#8288;</code> and <code style="white-space: pre;">&#8288;(6/5):=120%&#8288;</code> of buy side uninformed rate.<br />
[x] Sharp example.3: <code class="reqn">\epsilon</code><sub>b</sub><code class="reqn"> = 1000</code>, <code class="reqn">\epsilon</code><sub>s</sub><code class="reqn"> = 10000</code>. In this
case, the <code>PIN</code> and <code>MPIN</code> models would tend to consider some of the trading
in sell side to be informed (which should be the actual case).
Again, the estimation results would deviate much from the simulation
parameters being a good news by itself but a misleading factor in model
evaluation.
See for example Cheng and Lai (2021) as a
misinterpretation of comparative performances. The paper's findings highly
rely on the simulations with extremely different <code class="reqn">\epsilon</code><sub>b</sub> and <code class="reqn">\epsilon</code><sub>s</sub> values
(813-8124 pair and 8126-812).
</p>
</li></ul>



<h3>Value</h3>

<p>Returns an object of class <code>dataset</code> if <code>series=1</code>, and an
object of class <code>data.series</code> if <code>series&gt;1</code>.
</p>


<h3>References</h3>

<p>Cheng T, Lai H (2021).
&ldquo;Improvements in estimating the probability of informed trading models.&rdquo;
<em>Quantitative Finance</em>, <b>21</b>(5), 771-796.<br /><br /> Ersan O (2016).
&ldquo;Multilayer Probability of Informed Trading.&rdquo;
<em>Available at SSRN 2874420</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># ------------------------------------------------------------------------ #
# There are different scenarios of using the function generatedata_mpin()  #
# ------------------------------------------------------------------------ #

# With no arguments, the function generates one dataset object spanning
# 60 days, containing a number of information layers uniformly selected
# from `{1, 2, 3, 4, 5}`, and where the parameters are chosen as
# described in the details.

sdata &lt;- generatedata_mpin()

# The number of layers can be deduced from the simulation parameters, if
# fed directly to the function generatedata_mpin() through the argument
# 'parameters'. In this case, the output is a dataset object with one
# information layer.

givenpoint &lt;- c(0.4, 0.1, 800, 300, 200)
sdata &lt;- generatedata_mpin(parameters = givenpoint)

# The number of layers can alternatively be set directly through the
# argument 'layers'.

sdata &lt;- generatedata_mpin(layers = 2)

# The simulation parameters can be randomly drawn from their corresponding
# ranges fed through the argument 'ranges'.

sdata &lt;- generatedata_mpin(ranges = list(alpha = c(0.1, 0.7),
                                        delta = c(0.2, 0.7),
                                        mu = c(3000, 5000)))

# The value of a given simulation parameter can be set to a specific value by
# setting the range of the desired parameter takes a unique value, instead of
# a pair of values.

sdata &lt;- generatedata_mpin(ranges = list(alpha = 0.4, delta = c(0.2, 0.7),
                                        eps.b = c(100, 7000),
                                        mu = c(8000, 12000)))

# If both arguments 'parameters', and 'layers' are simultaneously provided,
# and the number of layers detected from the length of the argument
# 'parameters' is different from the argument 'layers', the former is used
# and a warning is displayed.

sim.params &lt;- c(0.4, 0.2, 0.9, 0.1, 400, 700, 300, 200)
sdata &lt;- generatedata_mpin(days = 120, layers = 3, parameters = sim.params)

# Display the details of the generated data

show(sdata)

# ------------------------------------------------------------------------ #
# Use generatedata_mpin() to compare the accuracy of estimation methods    #
# ------------------------------------------------------------------------ #

# The example below illustrates the use of the function 'generatedata_mpin()'
# to compare the accuracy of the functions 'mpin_ml()', and 'mpin_ecm()'.

# The example will depend on three variables:
# n: the number of datasets used
# l: the number of layers in each simulated datasets
# xc : the number of extra clusters used in initials_mpin

# For consideration of speed, we will set n = 2, l = 2, and xc = 2
# These numbers can change to fit the user's preferences
n &lt;- l &lt;- xc &lt;- 2

# We start by generating n datasets simulated according to the
# assumptions of the MPIN model.

dataseries &lt;- generatedata_mpin(series = n, layers = l, verbose = FALSE)

# Store the estimates in two different lists: 'mllist', and 'ecmlist'

mllist &lt;- lapply(dataseries@datasets, function(x)
  mpin_ml(x@data, xtraclusters = xc, layers = l, verbose = FALSE))

ecmlist &lt;- lapply(dataseries@datasets, function(x)
  mpin_ecm(x@data, xtraclusters = xc, layers = l, verbose = FALSE))

# For each estimate, we calculate the absolute difference between the
# estimated mpin, and empirical mpin computed using dataset parameters.
# The absolute differences are stored in 'mldmpin' ('ecmdpin') for the
# ML (ECM) method,

mldpin &lt;- sapply(1:n,
 function(x) abs(mllist[[x]]@mpin - dataseries@datasets[[x]]@emp.pin))

ecmdpin &lt;- sapply(1:n,
 function(x) abs(ecmlist[[x]]@mpin - dataseries@datasets[[x]]@emp.pin))

# Similarly, we obtain vectors of running times for both estimation methods.
# They are stored in 'mltime' ('ecmtime') for the ML (ECM) method.

mltime &lt;- sapply(mllist, function(x) x@runningtime)
ecmtime &lt;- sapply(ecmlist, function(x) x@runningtime)

# Finally, we calculate the average absolute deviation from empirical PIN
# as well as the average running time for both methods. This allows us to
# compare them in terms of accuracy, and speed.

accuracy &lt;- c(mean(mldpin), mean(ecmdpin))
timing &lt;- c(mean(mltime), mean(ecmtime))
comparison &lt;- as.data.frame(rbind(accuracy, timing))
colnames(comparison) &lt;- c("ML", "ECM")
rownames(comparison) &lt;- c("Accuracy", "Timing")

show(round(comparison, 6))

</code></pre>

<hr>
<h2 id='get_posteriors'>Posterior probabilities for PIN and MPIN estimates</h2><span id='topic+get_posteriors'></span>

<h3>Description</h3>

<p>Computes, for each day in the sample, the posterior probability
that the day is a no-information day, good-information day and
bad-information day, respectively
(Easley and Ohara (1992),
Easley et al. (1996),
Ersan (2016)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_posteriors(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_posteriors_+3A_object">object</code></td>
<td>
<p>(S4 object) an object of type <code>estimate.pin</code>,
<code>estimate.mpin</code>, or <code>estimate.mpin.ecm</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the argument <code>object</code> is of type <code>estimate.pin</code>, returns a dataframe of
three variables <code>post.N</code>, <code>post.G</code> and <code>post.B</code> containing in each row the
posterior probability that a given day is a no-information day (<code>N</code>),
good-information day (<code>G</code>), or bad-information day (<code>B</code>) respectively.
</p>
<p>If the argument <code>object</code> is of type <code>estimate.mpin</code> or <code>estimate.mpin.ecm</code>,
with <code>J</code> layers, returns a dataframe of <code>2*J+1</code> variables <code>Post.N</code>, and
<code>Post.G[j]</code> and <code>Post.B[j]</code> for each layer <code>j</code> containing in each row the
posterior probability that a given day is a no-information day,
good-information day in layer <code>j</code> or bad-information day in layer <code>j</code>,
for each layer <code>j</code> respectively.
</p>
<p>If the argument <code>object</code> is of any other type, an error is returned.
</p>


<h3>References</h3>

<p>Easley D, Kiefer NM, Ohara M, Paperman JB (1996).
&ldquo;Liquidity, information, and infrequently traded stocks.&rdquo;
<em>Journal of Finance</em>, <b>51</b>(4), 1405&ndash;1436.
ISSN 00221082.<br /><br /> Easley D, Ohara M (1992).
&ldquo;Time and the Process of Security Price Adjustment.&rdquo;
<em>The Journal of Finance</em>, <b>47</b>(2), 577&ndash;605.
ISSN 15406261.<br /><br /> Ersan O (2016).
&ldquo;Multilayer Probability of Informed Trading.&rdquo;
<em>Available at SSRN 2874420</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># There is a preloaded quarterly dataset called 'dailytrades' with 60
# observations. Each observation corresponds to a day and contains the
# total number of buyer-initiated trades ('B') and seller-initiated
# trades ('S') on that day. To know more, type ?dailytrades

xdata &lt;- dailytrades

# ------------------------------------------------------------------------ #
# Posterior probabilities for PIN estimates                                #
# ------------------------------------------------------------------------ #

# Estimate PIN using the Ersan and Alici (2016) algorithm and the
# factorization Lin and Ke(2011).

estimate &lt;- pin_ea(xdata, "LK", verbose = FALSE)

# Display the estimated PIN value

estimate@pin

# Store the posterior probabilities in a dataframe variable and display its
# first 6 rows.

modelposteriors &lt;- get_posteriors(estimate)
show(round(head(modelposteriors), 3))

# ------------------------------------------------------------------------ #
# Posterior probabilities for MPIN estimates                               #
# ------------------------------------------------------------------------ #

# Estimate MPIN via the ECM algorithm, assuming that the dataset has 2
# information layers

estimate &lt;- mpin_ecm(xdata, layers = 2, verbose = FALSE)

# Display the estimated Multilayer PIN value

show(estimate@mpin)

# Store the posterior probabilities in a dataframe variable and display its
# first six rows. The posterior probabilities are contained in a dataframe
# with 7 variables: one for no-information days, and two variables for each
# layer, one for good-information days and one for bad-information days.

modelposteriors &lt;- get_posteriors(estimate)
show(round(head(modelposteriors), 3))

</code></pre>

<hr>
<h2 id='hfdata'>High-frequency trade-data</h2><span id='topic+hfdata'></span>

<h3>Description</h3>

<p>A simulated dataset containing sample <code>timestamp</code>, <code>price</code>,
<code>volume</code>, <code>bid</code> and <code>ask</code> for <code style="white-space: pre;">&#8288;100 000&#8288;</code> high frequency transactions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hfdata
</code></pre>


<h3>Format</h3>

<p>A data frame with <code style="white-space: pre;">&#8288;100 000&#8288;</code> observations with <code>5</code> variables:
</p>

<ul>
<li> <p><code>timestamp</code>: time of the trade.
</p>
</li>
<li> <p><code>price</code>: transaction price.
</p>
</li>
<li> <p><code>volume</code>: volume of the transactions, in asset units.
</p>
</li>
<li> <p><code>bid</code>: best bid price.
</p>
</li>
<li> <p><code>ask</code>: best ask price.
</p>
</li></ul>



<h3>Source</h3>

<p>Artificially created data set.
</p>

<hr>
<h2 id='initials_adjpin'>AdjPIN initial parameter sets of Ersan &amp; Ghachem (2022b)</h2><span id='topic+initials_adjpin'></span>

<h3>Description</h3>

<p>Based on the algorithm in Ersan and Ghachem (2022b),
generates sets of initial parameters to be used in the maximum likelihood
estimation of <code>AdjPIN</code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initials_adjpin(data, xtraclusters = 4, restricted = list(),
 verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initials_adjpin_+3A_data">data</code></td>
<td>
<p>A dataframe with 2 variables: the first
corresponds to buyer-initiated trades (buys), and the second corresponds
to seller-initiated trades (sells).</p>
</td></tr>
<tr><td><code id="initials_adjpin_+3A_xtraclusters">xtraclusters</code></td>
<td>
<p>An integer used to divide trading days into
#<code>(4 + xtraclusters)</code> clusters, thereby resulting in
#<code>comb(4 + xtraclusters - 1, 4 - 1)</code> initial parameter sets in line
with Ersan and Alici (2016), and
Ersan and Ghachem (2022b).The default value is <code>4</code> as
chosen in Ersan (2016).</p>
</td></tr>
<tr><td><code id="initials_adjpin_+3A_restricted">restricted</code></td>
<td>
<p>A binary list that allows estimating restricted
AdjPIN models by specifying which model parameters are assumed to be equal.
It contains one or multiple of the following four elements
<code style="white-space: pre;">&#8288;{theta, mu, eps, d}&#8288;</code>. For instance, If <code>theta</code> is set to <code>TRUE</code>,
then the probability of liquidity shock in no-information days, and in
information days is assumed to be the same (<code class="reqn">\theta</code><code>=</code><code class="reqn">\theta'</code>). If any of
the remaining rate elements <code style="white-space: pre;">&#8288;{mu, eps, d}&#8288;</code> is set to <code>TRUE</code>,
(say  <code>mu=TRUE</code>), then the rate is assumed to be the same on the buy side,
and on the sell side (<code class="reqn">\mu</code><sub>b</sub><code>=</code><code class="reqn">\mu</code><sub>s</sub>). If more than one element is set to
<code>TRUE</code>, then the restrictions are combined. For instance, if the argument
<code>restricted</code> is set to <code>list(theta=TRUE, eps=TRUE, d=TRUE)</code>, then the
restricted AdjPIN model is estimated, where <code class="reqn">\theta</code><code>=</code><code class="reqn">\theta'</code>, <code class="reqn">\epsilon</code><sub>b</sub><code>=</code><code class="reqn">\epsilon</code><sub>s</sub>,
and <code class="reqn">\Delta</code><sub>b</sub><code>=</code><code class="reqn">\Delta</code><sub>s</sub>. If the value of the argument <code>restricted</code> is the empty list,
then all parameters of the model are assumed to be independent,
and the unrestricted model is estimated. The default value is the empty
list <code>list()</code>.</p>
</td></tr>
<tr><td><code id="initials_adjpin_+3A_verbose">verbose</code></td>
<td>
<p>a binary variable that determines whether information messages
about the initial parameter sets, including the number of the initial
parameter sets generated. No message is shown when <code>verbose</code> is set
to <code>FALSE</code>. The default value is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument 'data' should be a numeric dataframe, and contain
at least two variables. Only the first two variables will be considered:
The first variable is assumed to correspond to the total number of
buyer-initiated trades, while the second variable is assumed to
correspond to the total number of seller-initiated trades. Each row or
observation correspond to a trading day. <code>NA</code> values will be ignored.
</p>
<p>The function <code>initials_adjpin()</code> implements the algorithm suggested in
Ersan and Ghachem (2022b), and uses a hierarchical
agglomerative clustering (HAC) to find initial parameter sets for
the maximum likelihood estimation.
</p>


<h3>Value</h3>

<p>Returns a dataframe of numerical vectors of ten elements
{<code class="reqn">\alpha</code>, <code class="reqn">\delta</code>, <code class="reqn">\theta</code>, <code class="reqn">\theta'</code>,
<code class="reqn">\epsilon</code><sub>b</sub>, <code class="reqn">\epsilon</code><sub>s</sub>, <code class="reqn">\mu</code><sub>b</sub>, <code class="reqn">\mu</code><sub>s</sub>, <code class="reqn">\Delta</code><sub>b</sub>, <code class="reqn">\Delta</code><sub>s</sub>}.
</p>


<h3>References</h3>

<p>Ersan O (2016).
&ldquo;Multilayer Probability of Informed Trading.&rdquo;
<em>Available at SSRN 2874420</em>.<br /><br /> Ersan O, Alici A (2016).
&ldquo;An unbiased computation methodology for estimating the probability of informed trading (PIN).&rdquo;
<em>Journal of International Financial Markets, Institutions and Money</em>, <b>43</b>, 74&ndash;94.
ISSN 10424431.<br /><br /> Ersan O, Ghachem M (2022b).
&ldquo;A methodological approach to the computational problems in the estimation of adjusted PIN model.&rdquo;
<em>Available at SSRN 4117954</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># There is a preloaded quarterly dataset called 'dailytrades' with 60
# observations. Each observation corresponds to a day and contains the
# total number of buyer-initiated trades ('B') and seller-initiated
# trades ('S') on that day. To know more, type ?dailytrades

xdata &lt;- dailytrades

# Obtain a dataframe of initial parameter sets for the maximum likelihood
# estimation using the algorithm of Ersan and Ghachem (2022b).

init.sets &lt;- initials_adjpin(xdata)

# Use the list to estimate adjpin using the adjpin() method
# Show the value of adjusted PIN

estimate &lt;- adjpin(xdata, initialsets = init.sets, verbose = FALSE)
show(estimate@adjpin)

</code></pre>

<hr>
<h2 id='initials_adjpin_cl'>AdjPIN initial parameter sets of Cheng and Lai (2021)</h2><span id='topic+initials_adjpin_cl'></span>

<h3>Description</h3>

<p>Based on an extension of the algorithm in
Cheng and Lai (2021), generates sets of initial
parameters to be used in the maximum likelihood
estimation of <code>AdjPIN</code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initials_adjpin_cl(data, restricted = list(), verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initials_adjpin_cl_+3A_data">data</code></td>
<td>
<p>A dataframe with 2 variables: the first
corresponds to buyer-initiated trades (buys), and the second corresponds
to seller-initiated trades (sells).</p>
</td></tr>
<tr><td><code id="initials_adjpin_cl_+3A_restricted">restricted</code></td>
<td>
<p>A binary list that allows estimating restricted
AdjPIN models by specifying which model parameters are assumed to be equal.
It contains one or multiple of the following four elements
<code style="white-space: pre;">&#8288;{theta, mu, eps, d}&#8288;</code>. For instance, If <code>theta</code> is set to <code>TRUE</code>,
then the probability of liquidity shock in no-information days, and in
information days is assumed to be the same (<code class="reqn">\theta</code><code>=</code><code class="reqn">\theta'</code>). If any of
the remaining rate elements <code style="white-space: pre;">&#8288;{mu, eps, d}&#8288;</code> is set to <code>TRUE</code>,
(say  <code>mu=TRUE</code>), then the rate is assumed to be the same on the buy side,
and on the sell side (<code class="reqn">\mu</code><sub>b</sub><code>=</code><code class="reqn">\mu</code><sub>s</sub>). If more than one element is set to
<code>TRUE</code>, then the restrictions are combined. For instance, if the argument
<code>restricted</code> is set to <code>list(theta=TRUE, eps=TRUE, d=TRUE)</code>, then the
restricted AdjPIN model is estimated, where <code class="reqn">\theta</code><code>=</code><code class="reqn">\theta'</code>, <code class="reqn">\epsilon</code><sub>b</sub><code>=</code><code class="reqn">\epsilon</code><sub>s</sub>,
and <code class="reqn">\Delta</code><sub>b</sub><code>=</code><code class="reqn">\Delta</code><sub>s</sub>. If the value of the argument <code>restricted</code> is the empty list,
then all parameters of the model are assumed to be independent,
and the unrestricted model is estimated. The default value is the empty
list <code>list()</code>.</p>
</td></tr>
<tr><td><code id="initials_adjpin_cl_+3A_verbose">verbose</code></td>
<td>
<p>a binary variable that determines whether information messages
about the initial parameter sets, including the number of the initial
parameter sets generated. No message is shown when <code>verbose</code> is set
to <code>FALSE</code>. The default value is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument 'data' should be a numeric dataframe, and contain
at least two variables. Only the first two variables will be considered:
The first variable is assumed to correspond to the total number of
buyer-initiated trades, while the second variable is assumed to
correspond to the total number of seller-initiated trades. Each row or
observation correspond to a trading day. <code>NA</code> values will be ignored.
<br /><br /> The function implements an extension of the algorithm of
Cheng and Lai (2021). In their paper, the authors
assume that the probability of liquidity shock is the same in no-information,
and information days, i.e., <code class="reqn">\theta</code><code>=</code><code class="reqn">\theta'</code>, and use a procedure similar to
that of Yan and Zhang (2012) to generate 64 initial
parameter sets. The function implements an extension of their algorithm,
by relaxing the assumption of equality of liquidity shock probabilities,
and generates thereby <code>256</code> initial parameter sets for the unrestricted
<code>AdjPIN</code> model.
</p>


<h3>Value</h3>

<p>Returns a dataframe of numerical vectors of ten elements
{<code class="reqn">\alpha</code>, <code class="reqn">\delta</code>, <code class="reqn">\theta</code>, <code class="reqn">\theta'</code>,
<code class="reqn">\epsilon</code><sub>b</sub>, <code class="reqn">\epsilon</code><sub>s</sub>, <code class="reqn">\mu</code><sub>b</sub>, <code class="reqn">\mu</code><sub>s</sub>, <code class="reqn">\Delta</code><sub>b</sub>, <code class="reqn">\Delta</code><sub>s</sub>}.
</p>


<h3>References</h3>

<p>Cheng T, Lai H (2021).
&ldquo;Improvements in estimating the probability of informed trading models.&rdquo;
<em>Quantitative Finance</em>, <b>21</b>(5), 771-796.<br /><br /> Yan Y, Zhang S (2012).
&ldquo;An improved estimation method and empirical properties of the probability of informed trading.&rdquo;
<em>Journal of Banking and Finance</em>, <b>36</b>(2), 454&ndash;467.
ISSN 03784266.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># There is a preloaded quarterly dataset called 'dailytrades' with 60
# observations. Each observation corresponds to a day and contains the
# total number of buyer-initiated trades ('B') and seller-initiated
# trades ('S') on that day. To know more, type ?dailytrades

xdata &lt;- dailytrades

# The function adjpin(xdata, initialsets="CL") allows the user to directly
# estimate the AdjPIN model using the full set of initial parameter sets
# generated using the algorithm Cheng and Lai (2021)

estimate.1 &lt;- adjpin(xdata,  initialsets="CL", verbose = FALSE)


# Obtaining the set of initial parameter sets using initials_adjpin_cl
# allows us to estimate the PIN model using a subset of these initial sets.

# Use initials_adjpin_cl() to generate 256 initial parameter sets using the
# algorithm of Cheng and Lai (2021).

initials_cl &lt;- initials_adjpin_cl(xdata, verbose = FALSE)

# Use 20 randonly chosen initial sets from the dataframe 'initials_cl' in
# order to estimate the AdjPIN model using the function adjpin() with custom
# initial parameter sets

numberofsets &lt;- nrow(initials_cl)
selectedsets &lt;- initials_cl[sample(numberofsets, 20),]

estimate.2 &lt;- adjpin(xdata, initialsets = selectedsets, verbose = FALSE)

# Compare the parameters and the pin values of both specifications

comparison &lt;- rbind(
c(estimate.1@parameters, adjpin = estimate.1@adjpin, psos = estimate.1@psos),
c(estimate.2@parameters, estimate.2@adjpin, estimate.2@psos))

rownames(comparison) &lt;- c("all", "50")

show(comparison)


</code></pre>

<hr>
<h2 id='initials_adjpin_rnd'>AdjPIN random initial sets</h2><span id='topic+initials_adjpin_rnd'></span>

<h3>Description</h3>

<p>Generates random initial parameter sets to be used in the estimation of the
<code>AdjPIN</code> model of Duarte and Young (2009).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initials_adjpin_rnd(data, restricted = list(), num_init = 20,
 verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initials_adjpin_rnd_+3A_data">data</code></td>
<td>
<p>A dataframe with 2 variables: the first
corresponds to buyer-initiated trades (buys), and the second corresponds
to seller-initiated trades (sells).</p>
</td></tr>
<tr><td><code id="initials_adjpin_rnd_+3A_restricted">restricted</code></td>
<td>
<p>A binary list that allows estimating restricted
AdjPIN models by specifying which model parameters are assumed to be equal.
It contains one or multiple of the following four elements
<code style="white-space: pre;">&#8288;{theta, mu, eps, d}&#8288;</code>. For instance, If <code>theta</code> is set to <code>TRUE</code>,
then the probability of liquidity shock in no-information days, and in
information days is assumed to be the same (<code class="reqn">\theta</code><code>=</code><code class="reqn">\theta'</code>). If any of
the remaining rate elements <code style="white-space: pre;">&#8288;{mu, eps, d}&#8288;</code> is set to <code>TRUE</code>,
(say  <code>mu=TRUE</code>), then the rate is assumed to be the same on the buy side,
and on the sell side (<code class="reqn">\mu</code><sub>b</sub><code>=</code><code class="reqn">\mu</code><sub>s</sub>). If more than one element is set to
<code>TRUE</code>, then the restrictions are combined. For instance, if the argument
<code>restricted</code> is set to <code>list(theta=TRUE, eps=TRUE, d=TRUE)</code>, then the
restricted AdjPIN model is estimated, where <code class="reqn">\theta</code><code>=</code><code class="reqn">\theta'</code>, <code class="reqn">\epsilon</code><sub>b</sub><code>=</code><code class="reqn">\epsilon</code><sub>s</sub>,
and <code class="reqn">\Delta</code><sub>b</sub><code>=</code><code class="reqn">\Delta</code><sub>s</sub>. If the value of the argument <code>restricted</code> is the empty list
(<code>list()</code>), then all parameters of the model are assumed to be independent,
and the unrestricted model is estimated. The default value is the empty
list <code>list()</code>.</p>
</td></tr>
<tr><td><code id="initials_adjpin_rnd_+3A_num_init">num_init</code></td>
<td>
<p>An integer corresponds to the number of initial
parameter sets to be generated. The default value is <code>20</code>.</p>
</td></tr>
<tr><td><code id="initials_adjpin_rnd_+3A_verbose">verbose</code></td>
<td>
<p>a binary variable that determines whether information messages
about the initial parameter sets, including the number of the initial
parameter sets generated. No message is shown when <code>verbose</code> is set to
<code>FALSE</code>. The default value is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument 'data' should be a numeric dataframe, and contain
at least two variables. Only the first two variables will be considered:
The first variable is assumed to correspond to the total number of
buyer-initiated trades, while the second variable is assumed to
correspond to the total number of seller-initiated trades. Each row or
observation correspond to a trading day. <code>NA</code> values will be ignored.
<br /><br /> The buy rate parameters {<code class="reqn">\epsilon</code><sub>b</sub>, <code class="reqn">\mu</code><sub>b</sub>, <code class="reqn">\Delta</code><sub>b</sub>} are randomly generated
from the interval (<code>minB</code>, <code>maxB</code>), where <code>minB</code> (<code>maxB</code>) is the smallest
(largest) value of buys in the dataset, under the condition that
<code class="reqn">\epsilon</code><sub>b</sub><code>+</code><code class="reqn">\mu</code><sub>b</sub><code>+</code><code class="reqn">\Delta</code><sub>b</sub>&lt; <code>maxB</code>. Analogously, the sell rate parameters
{<code class="reqn">\epsilon</code><sub>s</sub>, <code class="reqn">\mu</code><sub>s</sub>, <code class="reqn">\Delta</code><sub>s</sub>} are randomly generated from the interval (<code>minS</code>, <code>maxS</code>),
where <code>minS</code> (<code>maxS</code>) is the smallest(largest) value of sells in the
dataset, under the condition that <code class="reqn">\epsilon</code><sub>s</sub><code>+</code><code class="reqn">\mu</code><sub>s</sub><code>+</code><code class="reqn">\Delta</code><sub>s</sub> &lt; <code>maxS</code>.
</p>


<h3>Value</h3>

<p>Returns a dataframe of numerical vectors of ten elements
{<code class="reqn">\alpha</code>, <code class="reqn">\delta</code>, <code class="reqn">\theta</code>, <code class="reqn">\theta'</code>,
<code class="reqn">\epsilon</code><sub>b</sub>, <code class="reqn">\epsilon</code><sub>s</sub>, <code class="reqn">\mu</code><sub>b</sub>, <code class="reqn">\mu</code><sub>s</sub>, <code class="reqn">\Delta</code><sub>b</sub>, <code class="reqn">\Delta</code><sub>s</sub>}.
</p>


<h3>References</h3>

<p>Duarte J, Young L (2009).
&ldquo;Why is PIN priced?&rdquo;
<em>Journal of Financial Economics</em>, <b>91</b>(2), 119&ndash;138.
ISSN 0304405X.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># There is a preloaded quarterly dataset called 'dailytrades' with 60
# observations. Each observation corresponds to a day and contains the
# total number of buyer-initiated trades ('B') and seller-initiated
# trades ('S') on that day. To know more, type ?dailytrades

xdata &lt;- dailytrades

# Obtain a dataframe of 20 random initial parameters for the MLE of
# the AdjPIN model using the initials_adjpin_rnd().

initial.sets &lt;- initials_adjpin_rnd(xdata, num_init = 20)

# Use the dataframe to estimate the AdjPIN model using the adjpin()
# function.

estimate &lt;- adjpin(xdata, initialsets = initial.sets, verbose = FALSE)

# Show the value of adjusted PIN

show(estimate@adjpin)

</code></pre>

<hr>
<h2 id='initials_mpin'>MPIN initial parameter sets of Ersan (2016)</h2><span id='topic+initials_mpin'></span>

<h3>Description</h3>

<p>Based on the algorithm in
Ersan (2016), generates
initial parameter sets for the maximum likelihood estimation of the <code>MPIN</code>
model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initials_mpin(data, layers = NULL, detectlayers = "EG",
 xtraclusters = 4, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initials_mpin_+3A_data">data</code></td>
<td>
<p>A dataframe with 2 variables: the first
corresponds to buyer-initiated trades (buys), and the second corresponds
to seller-initiated trades (sells).</p>
</td></tr>
<tr><td><code id="initials_mpin_+3A_layers">layers</code></td>
<td>
<p>An integer referring to the assumed number of
information layers in the data. If the value of <code>layers</code> is <code>NULL</code>, then
the number of layers is automatically determined by one of the following
functions: <code>detectlayers_e()</code>, <code>detectlayers_eg()</code>, and <code>detectlayers_ecm()</code>.
The default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="initials_mpin_+3A_detectlayers">detectlayers</code></td>
<td>
<p>A character string referring to the layer
detection algorithm used to determine the number of layers in the data. It
takes one of three values: <code>"E"</code>, <code>"EG"</code>, and <code>"ECM"</code>. <code>"E"</code> refers to the
algorithm in Ersan (2016), <code>"EG"</code> refers to
the algorithm in Ersan and Ghachem (2022a); while
<code>"ECM"</code> refers to the algorithm in
Ghachem and Ersan (2022a). The default value is <code>"EG"</code>.
Comparative results between the layer detection
algorithms can be found in Ersan and Ghachem (2022a).</p>
</td></tr>
<tr><td><code id="initials_mpin_+3A_xtraclusters">xtraclusters</code></td>
<td>
<p>An integer used to divide trading days into
<code>#(1 + layers + xtraclusters)</code> clusters, thereby resulting in
<code>#comb(layers + xtraclusters, layers)</code> initial parameter sets in
line with Ersan and Alici (2016), and
Ersan (2016). The default value is <code>4</code>
as chosen in Ersan (2016).</p>
</td></tr>
<tr><td><code id="initials_mpin_+3A_verbose">verbose</code></td>
<td>
<p>a binary variable that determines whether information messages
about the initial parameter sets, including the number of the initial
parameter sets generated. No message is shown when <code>verbose</code> is set
to <code>FALSE</code>. The default value is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument 'data' should be a numeric dataframe, and contain
at least two variables. Only the first two variables will be considered:
The first variable is assumed to correspond to the total number of
buyer-initiated trades, while the second variable is assumed to
correspond to the total number of seller-initiated trades. Each row or
observation correspond to a trading day. <code>NA</code> values will be ignored.
</p>


<h3>Value</h3>

<p>Returns a dataframe of initial parameter sets each consisting of
<code style="white-space: pre;">&#8288;3J + 2&#8288;</code> variables {<code class="reqn">\alpha</code>, <code class="reqn">\delta</code>, <code class="reqn">\mu</code>, <code class="reqn">\epsilon</code><sub>b</sub>, <code class="reqn">\epsilon</code><sub>s</sub>}.
<code class="reqn">\alpha</code>, <code class="reqn">\delta</code>, and <code class="reqn">\mu</code> are vectors of length <code>J</code> where
<code>J</code> is the number of layers in the <code>MPIN</code> model.
</p>


<h3>References</h3>

<p>Ersan O (2016).
&ldquo;Multilayer Probability of Informed Trading.&rdquo;
<em>Available at SSRN 2874420</em>.<br /><br /> Ersan O, Alici A (2016).
&ldquo;An unbiased computation methodology for estimating the probability of informed trading (PIN).&rdquo;
<em>Journal of International Financial Markets, Institutions and Money</em>, <b>43</b>, 74&ndash;94.
ISSN 10424431.<br /><br /> Ersan O, Ghachem M (2022a).
&ldquo;Identifying information types in probability of informed trading (PIN) models: An improved algorithm.&rdquo;
<em>Available at SSRN 4117956</em>.<br /><br /> Ghachem M, Ersan O (2022a).
&ldquo;Estimation of the probability of informed trading models via an expectation-conditional maximization algorithm.&rdquo;
<em>Available at SSRN 4117952</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># There is a preloaded quarterly dataset called 'dailytrades' with 60
# observations. Each observation corresponds to a day and contains the
# total number of buyer-initiated trades ('B') and seller-initiated
# trades ('S') on that day. To know more, type ?dailytrades

xdata &lt;- dailytrades

# Obtain a dataframe of initial parameter sets for estimation of the MPIN
# model using the algorithm of Ersan (2016) with 3 extra clusters.
# By default, the number of layers in the data is detected using the
# algorithm of Ersan and Ghachem (2022a).

initparams &lt;- initials_mpin(xdata, xtraclusters = 3, verbose = FALSE)

# Show the six first initial parameter sets

print(round(t(head(initparams)), 3))

# Use 10 randomly selected initial parameter sets from initparams to
# estimate the probability of informed trading via mpin_ecm. The number
# of information layers will be detected from the initial parameter sets.

numberofsets &lt;- nrow(initparams)
selectedsets &lt;- initparams[sample(numberofsets, 10),]

estimate &lt;- mpin_ecm(xdata, initialsets = selectedsets, verbose = FALSE)

# Display the estimated MPIN value

show(estimate@mpin)

# Display the estimated parameters as a numeric vector.

show(unlist(estimate@parameters))

# Store the posterior probabilities in a variable, and show the first 6 rows.

modelposteriors &lt;- get_posteriors(estimate)
show(round(head(modelposteriors), 3))

</code></pre>

<hr>
<h2 id='initials_pin_ea'>Initial parameter sets of Ersan &amp; Alici (2016)</h2><span id='topic+initials_pin_ea'></span>

<h3>Description</h3>

<p>Based on the algorithm in Ersan and Alici (2016),
generates initial parameter sets for the maximum likelihood
estimation of the <code>PIN</code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initials_pin_ea(data, xtraclusters = 4, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initials_pin_ea_+3A_data">data</code></td>
<td>
<p>A dataframe with 2 variables: the first
corresponds to buyer-initiated trades (buys), and the second corresponds
to seller-initiated trades (sells).</p>
</td></tr>
<tr><td><code id="initials_pin_ea_+3A_xtraclusters">xtraclusters</code></td>
<td>
<p>An integer used to divide trading days into
<code>#(2 + xtraclusters)</code> clusters, thereby resulting in
<code style="white-space: pre;">&#8288;#comb(1 + xtraclusters, 1)&#8288;</code> initial parameter sets in line with
Ersan and Alici (2016). The default value is <code>4</code>.</p>
</td></tr>
<tr><td><code id="initials_pin_ea_+3A_verbose">verbose</code></td>
<td>
<p>a binary variable that determines whether information messages
about the initial parameter sets, including the number of the initial
parameter sets generated. No message is shown when <code>verbose</code> is set
to <code>FALSE</code>. The default value is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument 'data' should be a numeric dataframe, and contain
at least two variables. Only the first two variables will be considered:
The first variable is assumed to correspond to the total number of
buyer-initiated trades, while the second variable is assumed to
correspond to the total number of seller-initiated trades. Each row or
observation correspond to a trading day. <code>NA</code> values will be ignored.
</p>
<p>The function <code>initials_pin_ea()</code> uses a hierarchical agglomerative
clustering (HAC) to find initial parameter sets for
the maximum likelihood estimation. The steps in
Ersan and Alici (2016) algorithm differ from those
used by Gan et al. (2015), and are summarized below.
</p>
<p>Via the use of HAC, daily absolute order imbalances (AOIs) are grouped in
<code>2+J</code> (default <code>J=4</code>) clusters. After sorting the clusters based on
AOIs, they are combined into two larger groups of days (event and no-event)
by merging neighboring clusters with each other. Consequently, those groups
are formed in <code style="white-space: pre;">&#8288;#comb(5, 1) = 5&#8288;</code> different ways. For each of the <code>5</code>
configurations with which, days are grouped into two (event group and
no-event group), the procedure below is applied to obtain initial parameter
sets. <br /><br />
Days in the event group (the one with larger mean AOI) are distributed into
two groups, i.e. good-event days (days with positive OI) and bad-event days
(days with negative OI).
Initial parameters are obtained from the frequencies, and average trade
rates of three types of days. See
Ersan and Alici (2016) for further details.<br /><br />
The higher the number of the additional clusters (<code>xtraclusters</code>), the
better is the estimation. Ersan and Alici (2016),
however, have shown the benefit of increasing this number beyond 4 is
marginal, and statistically insignificant.
</p>


<h3>Value</h3>

<p>Returns a dataframe of initial sets each consisting of five
variables {<code class="reqn">\alpha</code>, <code class="reqn">\delta</code>, <code class="reqn">\mu</code>, <code class="reqn">\epsilon</code><sub>b</sub>, <code class="reqn">\epsilon</code><sub>s</sub>}.
</p>


<h3>References</h3>

<p>Ersan O, Alici A (2016).
&ldquo;An unbiased computation methodology for estimating the probability of informed trading (PIN).&rdquo;
<em>Journal of International Financial Markets, Institutions and Money</em>, <b>43</b>, 74&ndash;94.
ISSN 10424431.<br /><br /> Gan Q, Wei WC, Johnstone D (2015).
&ldquo;A faster estimation method for the probability of informed trading using hierarchical agglomerative clustering.&rdquo;
<em>Quantitative Finance</em>, <b>15</b>(11), 1805&ndash;1821.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># There is a preloaded quarterly dataset called 'dailytrades' with 60
# observations. Each observation corresponds to a day and contains the
# total number of buyer-initiated trades ('B') and seller-initiated
# trades ('S') on that day. To know more, type ?dailytrades

xdata &lt;- dailytrades

# Obtain a dataframe of initial parameters for the maximum likelihood
# estimation using the algorithm of Ersan and Alici (2016).

init.sets &lt;- initials_pin_ea(xdata)

# Use the obtained dataframe to estimate the PIN model using the function
# pin() with custom initial parameter sets

estimate.1 &lt;- pin(xdata, initialsets = init.sets, verbose = FALSE)

# pin_ea() directly estimates the PIN model using initial parameter sets
# generated using the algorithm of Ersan &amp; Alici (2016).

estimate.2 &lt;- pin_ea(xdata, verbose = FALSE)

# Check that the obtained results are identical

show(estimate.1@parameters)
show(estimate.2@parameters)

</code></pre>

<hr>
<h2 id='initials_pin_gwj'>Initial parameter set of Gan et al.(2015)</h2><span id='topic+initials_pin_gwj'></span>

<h3>Description</h3>

<p>Based on the algorithm in
Gan et al. (2015), generates an initial parameter
set for the maximum likelihood estimation of the <code>PIN</code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initials_pin_gwj(data, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initials_pin_gwj_+3A_data">data</code></td>
<td>
<p>A dataframe with 2 variables: the first
corresponds to buyer-initiated trades (buys), and the second corresponds
to seller-initiated trades (sells).</p>
</td></tr>
<tr><td><code id="initials_pin_gwj_+3A_verbose">verbose</code></td>
<td>
<p>a binary variable that determines whether information messages
about the initial parameter sets, including the number of the initial
parameter sets generated. No message is shown when <code>verbose</code> is set
to <code>FALSE</code>. The default value is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument 'data' should be a numeric dataframe, and contain
at least two variables. Only the first two variables will be considered:
The first variable is assumed to correspond to the total number of
buyer-initiated trades, while the second variable is assumed to
correspond to the total number of seller-initiated trades. Each row or
observation correspond to a trading day. <code>NA</code> values will be ignored.
</p>


<h3>Value</h3>

<p>Returns a dataframe containing numerical vector of five elements
{<code class="reqn">\alpha</code>, <code class="reqn">\delta</code>, <code class="reqn">\mu</code>, <code class="reqn">\epsilon</code><sub>b</sub>, <code class="reqn">\epsilon</code><sub>s</sub>}.
</p>


<h3>References</h3>

<p>Gan Q, Wei WC, Johnstone D (2015).
&ldquo;A faster estimation method for the probability of informed trading using hierarchical agglomerative clustering.&rdquo;
<em>Quantitative Finance</em>, <b>15</b>(11), 1805&ndash;1821.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># There is a preloaded quarterly dataset called 'dailytrades' with 60
# observations. Each observation corresponds to a day and contains the
# total number of buyer-initiated trades ('B') and seller-initiated
# trades ('S') on that day. To know more, type ?dailytrades

xdata &lt;- dailytrades

# Obtain the initial parameter set for the maximum likelihood estimation
# using the algorithm of Gan et al.(2015).

initparams &lt;- initials_pin_gwj(xdata)

# Use the obtained dataframe to estimate the PIN model using the function
# pin() with custom initial parameter sets

estimate.1 &lt;- pin(xdata, initialsets = initparams, verbose = FALSE)

# pin_gwj() directly estimates the PIN model using an initial parameter set
# generated using the algorithm of Gan et al.(2015).

estimate.2 &lt;- pin_gwj(xdata, "E", verbose = FALSE)

# Check that the obtained results are identical

show(estimate.1@parameters)
show(estimate.2@parameters)

</code></pre>

<hr>
<h2 id='initials_pin_yz'>Initial parameter sets of Yan and Zhang (2012)</h2><span id='topic+initials_pin_yz'></span>

<h3>Description</h3>

<p>Based on the grid search algorithm of
Yan and Zhang (2012), generates
initial parameter sets for the maximum likelihood estimation of the <code>PIN</code>
model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initials_pin_yz(data, grid_size = 5, ea_correction = FALSE,
 verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initials_pin_yz_+3A_data">data</code></td>
<td>
<p>A dataframe with 2 variables: the first
corresponds to buyer-initiated trades (buys), and the second corresponds
to seller-initiated trades (sells).</p>
</td></tr>
<tr><td><code id="initials_pin_yz_+3A_grid_size">grid_size</code></td>
<td>
<p>An integer between <code>1</code>, and <code>20</code>;
representing the size of the grid. The default value is <code>5</code>. See
more in details.</p>
</td></tr>
<tr><td><code id="initials_pin_yz_+3A_ea_correction">ea_correction</code></td>
<td>
<p>A binary variable determining whether the
modifications of the algorithm of Yan and Zhang (2012)
suggested by Ersan and Alici (2016) are
implemented. The default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="initials_pin_yz_+3A_verbose">verbose</code></td>
<td>
<p>a binary variable that determines whether information messages
about the initial parameter sets, including the number of the initial
parameter sets generated. No message is shown when <code>verbose</code> is set
to <code>FALSE</code>. The default value is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument 'data' should be a numeric dataframe, and contain
at least two variables. Only the first two variables will be considered:
The first variable is assumed to correspond to the total number of
buyer-initiated trades, while the second variable is assumed to
correspond to the total number of seller-initiated trades. Each row or
observation correspond to a trading day. <code>NA</code> values will be ignored.
</p>
<p>The argument <code>grid_size</code> determines the size of the grid of the variables:
<code>alpha</code>, <code>delta</code>, and <code>eps.b</code>. If <code>grid_size</code> is set to a given value <code>m</code>,
the algorithm creates a sequence starting from <code>1/2m</code>, and ending in
<code>1 - 1/2m</code>, with a step of <code>1/m</code>. The default value of <code>5</code> corresponds
to the size of the grid in Yan and Zhang (2012).
In that case, the sequence starts at <code>0.1 = 1/(2 x 5)</code>, and ends in
<code>0.9 = 1 - 1/(2 x 5)</code> with a step of <code>0.2 = 1/m</code>.
</p>
<p>The function <code>initials_pin_yz()</code> implements, by default, the original
Yan and Zhang (2012) algorithm as the default value of
<code>ea_correction</code> takes the value <code>FALSE</code>.
When the value of <code>ea_correction</code> is set to <code>TRUE</code>; then, sets
with irrelevant <code>mu</code> values are excluded, and sets with boundary values are
reintegrated in the initial parameter sets.
</p>


<h3>Value</h3>

<p>Returns a dataframe of initial sets each consisting of five
variables {<code class="reqn">\alpha</code>, <code class="reqn">\delta</code>, <code class="reqn">\mu</code>, <code class="reqn">\epsilon</code><sub>b</sub>, <code class="reqn">\epsilon</code><sub>s</sub>}.
</p>


<h3>References</h3>

<p>Ersan O, Alici A (2016).
&ldquo;An unbiased computation methodology for estimating the probability of informed trading (PIN).&rdquo;
<em>Journal of International Financial Markets, Institutions and Money</em>, <b>43</b>, 74&ndash;94.
ISSN 10424431.<br /><br /> Yan Y, Zhang S (2012).
&ldquo;An improved estimation method and empirical properties of the probability of informed trading.&rdquo;
<em>Journal of Banking and Finance</em>, <b>36</b>(2), 454&ndash;467.
ISSN 03784266.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># There is a preloaded quarterly dataset called 'dailytrades' with 60
# observations. Each observation corresponds to a day and contains the
# total number of buyer-initiated trades ('B') and seller-initiated
# trades ('S') on that day. To know more, type ?dailytrades

xdata &lt;- dailytrades

# The function pin_yz() allows the user to directly estimate the PIN model
# using the full set of initial parameter sets generated using the algorithm
# of Yan and # Zhang (2012).

estimate.1 &lt;- pin_yz(xdata, verbose = FALSE)

# Obtaining the set of initial parameter sets using initials_pin_yz allows
# us to estimate the PIN model using a subset of these initial sets.

initparams &lt;- initials_pin_yz(xdata, verbose = FALSE)

# Use 10 randonly chosen initial sets from the dataframe 'initparams' in
# order to estimate the PIN model using the function pin() with custom
# initial parameter sets

numberofsets &lt;- nrow(initparams)
selectedsets &lt;- initparams[sample(numberofsets, 10),]

estimate.2 &lt;- pin(xdata, initialsets = selectedsets, verbose = FALSE)

# Compare the parameters and the pin values of both specifications

comparison &lt;- rbind(c(estimate.1@parameters, pin = estimate.1@pin),
                    c(estimate.2@parameters, estimate.2@pin))

rownames(comparison) &lt;- c("all", "10")

show(comparison)


</code></pre>

<hr>
<h2 id='mpin_ecm'>MPIN model estimation via an ECM algorithm</h2><span id='topic+mpin_ecm'></span>

<h3>Description</h3>

<p>Estimates the multilayer probability of informed trading
(<code>MPIN</code>) using an Expectation Conditional Maximization algorithm, as in
Ghachem and Ersan (2022a).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpin_ecm(data, layers = NULL, xtraclusters = 4, initialsets = NULL,
                      ..., verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpin_ecm_+3A_data">data</code></td>
<td>
<p>A dataframe with 2 variables: the first
corresponds to buyer-initiated trades (buys), and the second corresponds
to seller-initiated trades (sells).</p>
</td></tr>
<tr><td><code id="mpin_ecm_+3A_layers">layers</code></td>
<td>
<p>An integer referring to the assumed number of
information layers in the data. If the argument <code>layers</code> is given, then
the ECM algorithm will use the number of layers provided. If <code>layers</code> is
omitted, the function <code>mpin_ecm()</code> will simultaneously optimize the number
of layers as well as the parameters of the <code>MPIN</code> model.</p>
</td></tr>
<tr><td><code id="mpin_ecm_+3A_xtraclusters">xtraclusters</code></td>
<td>
<p>An integer used to divide trading days into
<code>#(1 + layers + xtraclusters)</code> clusters, thereby resulting in
<code>#comb((layers + xtraclusters, layers)</code> initial parameter sets in line
with Ersan and Alici (2016), and
Ersan (2016). The default value is <code>4</code>
as chosen in Ersan (2016).</p>
</td></tr>
<tr><td><code id="mpin_ecm_+3A_initialsets">initialsets</code></td>
<td>
<p>A dataframe containing initial parameter
sets for estimation of the <code>MPIN</code> model. The default value is <code>NULL</code>.
If <code>initialsets</code> is <code>NULL</code>, the initial parameter sets are provided by
the function <code>initials_mpin()</code>.</p>
</td></tr>
<tr><td><code id="mpin_ecm_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to the function <code>mpin_ecm</code>. The
recognized arguments are <code>hyperparams</code>, and <code>is_parallel</code>.
</p>

<ul>
<li> <p><code>hyperparams</code> is a list containing the hyperparameters of the ECM
algorithm. When not empty, it contains one or more  of the following
elements: <code>minalpha</code>, <code>maxeval</code>, <code>tolerance</code>, <code>criterion</code>, and <code>maxlayers</code>.
More about these elements are in the details section.
</p>
</li>
<li>  <p><code>is_parallel</code> is a logical variable that specifies whether
the computation is performed using parallel or sequential processing. The
default value is <code>FALSE</code>. For more details, please refer to the
vignette 'Parallel processing' in the package, or
<a href="https://pinstimation.com/articles/parallel_processing.html">online</a>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="mpin_ecm_+3A_verbose">verbose</code></td>
<td>
<p>(<code>logical</code>) a binary variable that determines whether detailed
information about the steps of the estimation of the MPIN model is displayed.
No output is produced when <code>verbose</code> is set to <code>FALSE</code>. The default
value is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument 'data' should be a numeric dataframe, and contain
at least two variables. Only the first two variables will be considered:
The first variable is assumed to correspond to the total number of
buyer-initiated trades, while the second variable is assumed to
correspond to the total number of seller-initiated trades. Each row or
observation correspond to a trading day. <code>NA</code> values will be ignored.
</p>
<p>The initial parameters for the expectation-conditional maximization
algorithm are computed using the function <code>initials_mpin()</code>  with
default settings. The factorization of the <code>MPIN</code> likelihood function
used is developed by Ersan (2016), and
is implemented in <code>fact_mpin()</code>.<br /><br />
The argument <code>hyperparams</code> contains the hyperparameters of the ECM algorithm.
It is either empty or contains one or more of the following elements:
</p>

<ul>
<li> <p><code>minalpha</code> (<code>numeric</code>) It stands for the minimum share of days
belonging  to a given layer, i.e., layers falling below this threshold are
removed during the iteration, and the model is estimated with a lower number
of layers. When missing, <code>minalpha</code> takes the default value of <code>0.001</code>.
</p>
</li>
<li> <p><code>maxeval</code>: (<code>integer</code>) It stands for maximum number of iterations of
the ECM  algorithm for each initial parameter set. When missing, <code>maxeval</code>
takes the default value of <code>100</code>.
</p>
</li>
<li> <p><code>tolerance</code> (<code>numeric</code>) The ECM algorithm is stopped when the
(relative) change of log-likelihood is  smaller than tolerance. When
missing, <code>tolerance</code> takes the default value of <code>0.001</code>.
</p>
</li>
<li> <p><code>criterion</code> (<code>character</code>) It is the model selection criterion used to
find the optimal estimate  for the <code>MPIN</code> model. It take one of these values
<code>"BIC"</code>, <code>"AIC"</code> and <code>"AWE"</code>; which stand for Bayesian Information
Criterion,  Akaike Information Criterion and Approximate Weight of Evidence,
respectively (Akogul and Erisoglu 2016). When missing,
<code>criterion</code> takes  the default value of <code>"BIC"</code>.
</p>
</li>
<li> <p><code>maxlayers</code> (<code>integer</code>) It is the upper limit of number of layers used
for estimation in the ECM algorithm.  If the argument <code>layers</code> is missing,
the ECM algorithm will estimate <code>MPIN</code> models for all layers in the integer
set from <code>1</code> to <code>maxlayers</code>. When missing, <code>maxlayers</code> takes the default
value of <code>8</code>.
</p>
</li>
<li> <p><code>maxinit</code> (<code>integer</code>) It is the maximum number of initial sets used
for each individual estimation in the ECM algorithm. When missing, <code>maxinit</code>
takes the default value of <code>100</code>.
</p>
</li></ul>

<p>If the argument <code>layers</code> is given, then the Expectation Conditional
Maximization algorithm will use the number of  layers provided. If
<code>layers</code> is omitted, the function <code>mpin_ecm()</code> will simultaneously
optimize the number of layers as well as the parameters of the <code>MPIN</code> model.
Practically, the function <code>mpin_ecm()</code> uses the ECM algorithm to optimize
the <code>MPIN</code> model parameters for each number of layers within the integer
set from <code>1</code> to <code>8</code> (or to <code>maxlayers</code> if specified in the argument
<code>hyperparams</code>); and returns the optimal model with the lowest Bayesian
information  criterion (BIC) (or the lowest information criterion
<code>criterion</code> if specified in the argument <code>hyperparams</code>).
</p>


<h3>Value</h3>

<p>Returns an object of class <code>estimate.mpin.ecm</code>.
</p>


<h3>References</h3>

<p>Akogul S, Erisoglu M (2016).
&ldquo;A comparison of information criteria in clustering based on mixture of multivariate normal distributions.&rdquo;
<em>Mathematical and Computational Applications</em>, <b>21</b>(3), 34.<br /><br /> Ersan O (2016).
&ldquo;Multilayer Probability of Informed Trading.&rdquo;
<em>Available at SSRN 2874420</em>.<br /><br /> Ersan O, Alici A (2016).
&ldquo;An unbiased computation methodology for estimating the probability of informed trading (PIN).&rdquo;
<em>Journal of International Financial Markets, Institutions and Money</em>, <b>43</b>, 74&ndash;94.
ISSN 10424431.<br /><br /> Ghachem M, Ersan O (2022a).
&ldquo;Estimation of the probability of informed trading models via an expectation-conditional maximization algorithm.&rdquo;
<em>Available at SSRN 4117952</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># There is a preloaded quarterly dataset called 'dailytrades' with 60
# observations. Each observation corresponds to a day and contains the
# total number of buyer-initiated trades ('B') and seller-initiated
# trades ('S') on that day. To know more, type ?dailytrades

xdata &lt;- dailytrades

# Estimate the MPIN model using the expectation-conditional maximization
# (ECM) algorithm.

# ------------------------------------------------------------------------ #
# Estimate the MPIN model, assuming that there exists 2 information layers #
# in the dataset                                                           #
# ------------------------------------------------------------------------ #

estimate &lt;- mpin_ecm(xdata, layers = 2, verbose = FALSE)

# Show the estimation output

show(estimate)

# Display the optimal parameters from the Expectation Conditional
# Maximization algorithm

show(estimate@parameters)

# Display the global multilayer probability of informed trading

show(estimate@mpin)

# Display the multilayer probability of informed trading per layer

show(estimate@mpinJ)

# Display the first five rows of the initial parameter sets used in the
# expectation-conditional maximization estimation

show(round(head(estimate@initialsets, 5), 4))

# ------------------------------------------------------------------------ #
# Omit the argument 'layers', so the ECM algorithm optimizes both the      #
# number of layers and the MPIN model parameters.                          #
# ------------------------------------------------------------------------ #

estimate &lt;- mpin_ecm(xdata, verbose = FALSE)

# Show the estimation output

show(estimate)

# Display the optimal parameters from the estimation of the MPIN model using
# the expectation-conditional maximization (ECM) algorithm

show(estimate@parameters)

# Display the multilayer probability of informed trading

show(estimate@mpin)

# Display the multilayer probability of informed trading per layer

show(estimate@mpinJ)

# Display the first five rows of the initial parameter sets used in the
# expectation-conditional maximization estimation.

show(round(head(estimate@initialsets, 5), 4))

# ------------------------------------------------------------------------ #
# Tweak in the hyperparameters of the ECM algorithm                        #
# ------------------------------------------------------------------------ #

# Create a variable ecm.params containing the hyperparameters of the ECM
# algorithm. This will surely make the ECM algorithm take more time to give
# results

ecm.params &lt;- list(tolerance = 0.0000001)

# If we suspect that the data contains more than eight information layers, we
# can raise the number of models to be estimated to 10 as an example, i.e.,
# maxlayers = 10.

ecm.params$maxlayers &lt;- 10

# We can also choose Approximate Weight of Evidence (AWE) for model
# selection instead of the default Bayesian Information Criterion (BIC)

ecm.params$criterion &lt;- 'AWE'

# We can also increase the maximum number of initial sets to 200, in
# order to obtain higher level of accuracy for models with high number of
# layers.  We set the sub-argument 'maxinit' to `200`. Remember that its
# default value is `100`.

ecm.params$maxinit &lt;- 200

estimate &lt;- mpin_ecm(xdata, xtraclusters = 2, hyperparams = ecm.params,
                                                      verbose = FALSE)

# We can change the model selection criterion by calling selectModel()

estimate &lt;- selectModel(estimate, "AIC")

# We get the mpin_ecm estimation results for the MPIN model with 2 layers
# using the slot models. We then show the first five rows of the
# corresponding slot details.

models &lt;- estimate@models
show(round(head(models[[2]]@details, 5), 4))

# We can also use the function getSummary to get an idea about the change in
# the estimation parameters as a function of the number of layers in the
# MPIN model. The function getSummary returns a dataframe that contains,
# among others, the number of layers of the model, the number of layers in
# the optimal model,the MPIN value, and the values of the different
# information criteria, namely AIC, BIC and AWE.

summary &lt;- getSummary(estimate)

# We can plot the MPIN value and the layers at the optimal model as a
# function of the number of layers to see whether additional layers in the
# model actually contribute to a better precision in the probability of
# informed trading. Remember that the hyperparameter 'minalpha' is
# responsible for dropping layers with "frequency" lower than 'minalpha'.

plot(summary$layers, summary$MPIN,
   type = "o", col = "red",
   xlab = "MPIN model layers", ylab = "MPIN value"
 )

plot(summary$layers, summary$em.layers,
   type = "o", col = "blue",
   xlab = "MPIN model layers", ylab = "layers at the optimal model"
)

</code></pre>

<hr>
<h2 id='mpin_ml'>MPIN model estimation via standard ML methods</h2><span id='topic+mpin_ml'></span>

<h3>Description</h3>

<p>Estimates the multilayer probability of informed trading
(<code>MPIN</code>) using the standard Maximum Likelihood method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpin_ml(data, layers = NULL, xtraclusters = 4, initialsets = NULL,
detectlayers = "EG", ..., verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpin_ml_+3A_data">data</code></td>
<td>
<p>A dataframe with 2 variables: the first
corresponds to buyer-initiated trades (buys), and the second corresponds
to seller-initiated trades (sells).</p>
</td></tr>
<tr><td><code id="mpin_ml_+3A_layers">layers</code></td>
<td>
<p>An integer referring to the assumed number of
information layers in the data. If the argument <code>layers</code> is given,
then the maximum likelihood estimation will use the number of layers
provided. If <code>layers</code> is omitted,
the function <code>mpin_ml()</code> will find the optimal number of layers using
the algorithm developed in Ersan and Ghachem (2022a)
(as default).</p>
</td></tr>
<tr><td><code id="mpin_ml_+3A_xtraclusters">xtraclusters</code></td>
<td>
<p>An integer used to divide trading days into
<code>(1 + layers + xtraclusters)</code> clusters, thereby resulting in
<code>#comb(layers + xtraclusters, layers)</code> initial parameter sets in line
with Ersan and Alici (2016), and
Ersan (2016). The default value is <code>4</code> as
chosen in Ersan (2016).</p>
</td></tr>
<tr><td><code id="mpin_ml_+3A_initialsets">initialsets</code></td>
<td>
<p>A dataframe containing initial parameter
sets for the estimation of the <code>MPIN</code> model. The default value is <code>NULL</code>.
If <code>initialsets</code> is <code>NULL</code>, the initial parameter sets are determined by the
function <code>initials_mpin()</code>.</p>
</td></tr>
<tr><td><code id="mpin_ml_+3A_detectlayers">detectlayers</code></td>
<td>
<p>A character string referring to the layer
detection algorithm used to determine the number of  layer in the data. It
takes one of three values: <code>"E"</code>, <code>"EG"</code>, and <code>"ECM"</code>. <code>"E"</code> refers to the
algorithm in Ersan (2016), <code>"EG"</code> refers to
the algorithm in Ersan and Ghachem (2022a);
while <code>"ECM"</code> refers to the algorithm in
Ghachem and Ersan (2022a).
The default value is <code>"EG"</code>. Comparative results between the layer detection
algorithms can be found in Ersan and Ghachem (2022a).</p>
</td></tr>
<tr><td><code id="mpin_ml_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to the function <code>mpin_ml</code>. The
recognized argument is <code>is_parallel</code>. <code>is_parallel</code> is a logical variable
that specifies whether the computation is performed using parallel
processing. The default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mpin_ml_+3A_verbose">verbose</code></td>
<td>
<p>A binary variable that determines whether detailed
information about the steps of the estimation of the MPIN model is displayed.
No output is produced when <code>verbose</code> is set to <code>FALSE</code>. The default
value is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument 'data' should be a numeric dataframe, and contain
at least two variables. Only the first two variables will be considered:
The first variable is assumed to correspond to the total number of
buyer-initiated trades, while the second variable is assumed to
correspond to the total number of seller-initiated trades. Each row or
observation correspond to a trading day. <code>NA</code> values will be ignored. <br />
</p>


<h3>Value</h3>

<p>Returns an object of class <code>estimate.mpin</code>
</p>


<h3>References</h3>

<p>Ersan O (2016).
&ldquo;Multilayer Probability of Informed Trading.&rdquo;
<em>Available at SSRN 2874420</em>.<br /><br /> Ersan O, Alici A (2016).
&ldquo;An unbiased computation methodology for estimating the probability of informed trading (PIN).&rdquo;
<em>Journal of International Financial Markets, Institutions and Money</em>, <b>43</b>, 74&ndash;94.
ISSN 10424431.<br /><br /> Ersan O, Ghachem M (2022a).
&ldquo;Identifying information types in probability of informed trading (PIN) models: An improved algorithm.&rdquo;
<em>Available at SSRN 4117956</em>.<br /><br /> Ghachem M, Ersan O (2022a).
&ldquo;Estimation of the probability of informed trading models via an expectation-conditional maximization algorithm.&rdquo;
<em>Available at SSRN 4117952</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># There is a preloaded quarterly dataset called 'dailytrades' with 60
# observations. Each observation corresponds to a day and contains the
# total number of buyer-initiated trades ('B') and seller-initiated
# trades ('S') on that day. To know more, type ?dailytrades

xdata &lt;- dailytrades

# ------------------------------------------------------------------------ #
# Estimate MPIN model using the standard ML method                         #
# ------------------------------------------------------------------------ #

# Estimate the MPIN model using mpin_ml() assuming that there is a single
# information layer in the data. The model is then equivalent to the PIN
# model. The argument 'layers' takes the value '1'.
# We use two extra clusters to generate the initial parameter sets.

estimate &lt;- mpin_ml(xdata, layers = 1, xtraclusters = 2, verbose = FALSE)

# Show the estimation output

show(estimate)

# Estimate the MPIN model using the function mpin_ml(), without specifying
# the number of layers. The number of layers is then detected using Ersan and
# Ghachem (2022a).
# -------------------------------------------------------------

estimate &lt;- mpin_ml(xdata, xtraclusters = 2, verbose = FALSE)

# Show the estimation output

show(estimate)

# Display the likelihood-maximizing parameters

show(estimate@parameters)

# Display the global multilayer probability of informed trading

show(estimate@mpin)

# Display the multilayer probabilities of informed trading per layer

show(estimate@mpinJ)

# Display the first five initial parameters sets used in the maximum
# likelihood estimation

show(round(head(estimate@initialsets, 5), 4))

</code></pre>

<hr>
<h2 id='pin'>PIN estimation - custom initial parameter sets</h2><span id='topic+pin'></span>

<h3>Description</h3>

<p>Estimates the Probability of Informed Trading (<code>PIN</code>)
using custom initial parameter sets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pin(data, initialsets, factorization = "E", verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pin_+3A_data">data</code></td>
<td>
<p>A dataframe with 2 variables: the first
corresponds to buyer-initiated trades (buys), and the second corresponds
to seller-initiated trades (sells).</p>
</td></tr>
<tr><td><code id="pin_+3A_initialsets">initialsets</code></td>
<td>
<p>A dataframe with the following variables in
this order (<code class="reqn">\alpha</code>, <code class="reqn">\delta</code>, <code class="reqn">\mu</code>, <code class="reqn">\epsilon</code><sub>b</sub>, <code class="reqn">\epsilon</code><sub>s</sub>).</p>
</td></tr>
<tr><td><code id="pin_+3A_factorization">factorization</code></td>
<td>
<p>A character string from
<code>{"EHO", "LK", "E", "NONE"}</code> referring to a given factorization. The
default value is set to <code>"E"</code>.</p>
</td></tr>
<tr><td><code id="pin_+3A_verbose">verbose</code></td>
<td>
<p>A binary variable that determines whether detailed
information about the steps of the estimation of the PIN model is displayed.
No output is produced when <code>verbose</code> is set to <code>FALSE</code>. The default
value is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument 'data' should be a numeric dataframe, and contain
at least two variables. Only the first two variables will be considered:
The first variable is assumed to correspond to the total number of
buyer-initiated trades, while the second variable is assumed to
correspond to the total number of seller-initiated trades. Each row or
observation correspond to a trading day. <code>NA</code> values will be ignored.
</p>
<p>The factorization variable takes one of four values:
</p>

<ul>
<li> <p><code>"EHO"</code> refers to the factorization in
Easley et al. (2010)
</p>
</li>
<li> <p><code>"LK"</code>  refers to the factorization in
Lin and Ke (2011)
</p>
</li>
<li> <p><code>"E"</code>  refers to the factorization in
Ersan (2016)
</p>
</li>
<li> <p><code>"NONE"</code> refers to the original likelihood function - with no
factorization
</p>
</li></ul>



<h3>Value</h3>

<p>Returns an object of class <code>estimate.pin</code>
</p>


<h3>References</h3>

<p>Easley D, Hvidkjaer S, Ohara M (2010).
&ldquo;Factoring information into returns.&rdquo;
<em>Journal of Financial and Quantitative Analysis</em>, <b>45</b>(2), 293&ndash;309.
ISSN 00221090.<br /><br /> Ersan O (2016).
&ldquo;Multilayer Probability of Informed Trading.&rdquo;
<em>Available at SSRN 2874420</em>.<br /><br /> Lin H, Ke W (2011).
&ldquo;A computing bias in estimating the probability of informed trading.&rdquo;
<em>Journal of Financial Markets</em>, <b>14</b>(4), 625-640.
ISSN 1386-4181.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># There is a preloaded quarterly dataset called 'dailytrades' with 60
# observations. Each observation corresponds to a day and contains the
# total number of buyer-initiated trades ('B') and seller-initiated
# trades ('S') on that day. To know more, type ?dailytrades

xdata &lt;- dailytrades

#--------------------------------------------------------------
# Using generic function pin()
#--------------------------------------------------------------

# Define initial parameters:
# initialset = (alpha, delta, mu, eps.b, eps.s)

initialset &lt;- c(0.3, 0.1, 800, 300, 200)

# Estimate the PIN model using the factorization of the PIN likelihood
# function by Ersan (2016)

estimate &lt;- pin(xdata, initialsets = initialset, verbose = FALSE)

# Display the estimated PIN value

show(estimate@pin)

# Display the estimated parameters

show(estimate@parameters)

# Store the initial parameter sets used for MLE in a dataframe variable,
# and display its first five rows

initialsets &lt;- estimate@initialsets
show(head(initialsets, 5))

</code></pre>

<hr>
<h2 id='pin_bayes'>PIN estimation - Bayesian approach</h2><span id='topic+pin_bayes'></span>

<h3>Description</h3>

<p>Estimates the Probability of Informed Trading (<code>PIN</code>) using
Bayesian Gibbs sampling as in
Griffin et al. (2021) and the initial sets
from the algorithm in Ersan and Alici (2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pin_bayes(data, xtraclusters = 4, sweeps = 1000, burnin = 500,
                 prior.a = 1, prior.b = 2, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pin_bayes_+3A_data">data</code></td>
<td>
<p>A dataframe with 2 variables: the first
corresponds to buyer-initiated trades (buys), and the second corresponds
to seller-initiated trades (sells).</p>
</td></tr>
<tr><td><code id="pin_bayes_+3A_xtraclusters">xtraclusters</code></td>
<td>
<p>An integer used to divide trading days into
<code>#(2 + xtraclusters)</code> clusters, thereby resulting in
<code>#comb(1 + xtraclusters, 1)</code> initial parameter sets in line with
Ersan and Alici (2016). The default value is <code>4</code>.</p>
</td></tr>
<tr><td><code id="pin_bayes_+3A_sweeps">sweeps</code></td>
<td>
<p>An integer referring to the number of iterations for the Gibbs
Sampler. This has to be large enough to ensure convergence of the Markov chain.
The default value is <code>1000</code>.</p>
</td></tr>
<tr><td><code id="pin_bayes_+3A_burnin">burnin</code></td>
<td>
<p>An integer referring to the number of initial iterations for
which the parameter draws should be discarded. This is to ensure that we keep
the draws at the point where the MCMC has converged to the parameter space in
which the parameter estimate is likely to fall. This figure must always be
less than the sweeps. The default value is <code>500</code>.</p>
</td></tr>
<tr><td><code id="pin_bayes_+3A_prior.a">prior.a</code></td>
<td>
<p>An integer controlling the mean number of informed trades,
such as the prior of informed buys and sells is the Gamma density function
with <code class="reqn">\mu</code> ~ <code style="white-space: pre;">&#8288;Ga(prior.a,&#8288;</code> <code class="reqn">\eta</code><code style="white-space: pre;">&#8288;)&#8288;</code>. The default value is <code>1</code>.
For more details, please refer to
Griffin et al. (2021).</p>
</td></tr>
<tr><td><code id="pin_bayes_+3A_prior.b">prior.b</code></td>
<td>
<p>An integer controlling the mean number of uninformed trades,
such as the prior of uninformed buys and sells is the Gamma density function
with <code class="reqn">\epsilon</code><sub>b</sub> ~ <code style="white-space: pre;">&#8288;Ga(prior.b,&#8288;</code> <code class="reqn">\eta</code><code style="white-space: pre;">&#8288;)&#8288;</code>, and <code class="reqn">\epsilon</code><sub>s</sub> ~ <code style="white-space: pre;">&#8288;Ga(prior.b,&#8288;</code> <code class="reqn">\eta</code><code style="white-space: pre;">&#8288;)&#8288;</code>.
The default value is <code>2</code>. For more details, please refer to
Griffin et al. (2021).</p>
</td></tr>
<tr><td><code id="pin_bayes_+3A_verbose">verbose</code></td>
<td>
<p>A binary variable that determines whether detailed
information about the steps of the estimation of the PIN model is displayed.
No output is produced when <code>verbose</code> is set to <code>FALSE</code>. The default
value is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument 'data' should be a numeric dataframe, and contain
at least two variables. Only the first two variables will be considered:
The first variable is assumed to correspond to the total number of
buyer-initiated trades, while the second variable is assumed to
correspond to the total number of seller-initiated trades. Each row or
observation correspond to a trading day. <code>NA</code> values will be ignored.
</p>
<p>The function <code>pin_bayes()</code> implements the algorithm detailed in
Ersan and Alici (2016).
The higher the number of the additional clusters (<code>xtraclusters</code>), the
better is the estimation. Ersan and Alici (2016),
however, have shown the benefit of increasing this number beyond 5 is
marginal, and statistically insignificant.<br /> <br />
The function <code>initials_pin_ea()</code> provides the initial parameter sets
obtained through the implementation of the
Ersan and Alici (2016) algorithm.
For further information on the initial parameter set determination, see
<code>initials_pin_ea()</code>.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>estimate.pin</code>
</p>


<h3>References</h3>

<p>Ersan O, Alici A (2016).
&ldquo;An unbiased computation methodology for estimating the probability of informed trading (PIN).&rdquo;
<em>Journal of International Financial Markets, Institutions and Money</em>, <b>43</b>, 74&ndash;94.
ISSN 10424431.<br /><br /> Griffin J, Oberoi J, Oduro SD (2021).
&ldquo;Estimating the probability of informed trading: A Bayesian approach.&rdquo;
<em>Journal of Banking &amp; Finance</em>, <b>125</b>, 106045.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use the function generatedata_mpin() to generate a dataset of
# 60 days according to the assumptions of the original PIN model.

sdata &lt;- generatedata_mpin(layers = 1)
xdata &lt;- sdata@data

# Estimate the PIN model using the Bayesian approach developed in
# Griffin et al. (2021), and initial parameter sets generated using the
# algorithm of Ersan and Alici (2016). The argument xtraclusters is
# set to 1. We also leave the arguments 'sweeps' and 'burnin' at their
# default values.

estimate &lt;- pin_bayes(xdata, xtraclusters = 1, verbose = FALSE)


# Display the empirical PIN value at the data, and the PIN value
# estimated using the bayesian approach

setNames(c(sdata@emp.pin, estimate@pin), c("data", "estimate"))

# Display the empirial and the estimated parameters

show(unlist(sdata@empiricals))
show(estimate@parameters)

# Find the initial set that leads to the optimal estimate
optimal &lt;- which.max(estimate@details$likelihood)

# Store the matrix of Monte Carlo simulation for the optimal
# estimate, and display its last five rows

mcmatrix &lt;- estimate@details$markovmatrix[[optimal]]
show(tail(mcmatrix, 5))

# Display the summary of Geweke test for the Monte Carlo matrix above.
show(estimate@details$summary[[optimal]])

</code></pre>

<hr>
<h2 id='pin_ea'>PIN estimation - initial parameter sets of Ersan &amp; Alici (2016)</h2><span id='topic+pin_ea'></span>

<h3>Description</h3>

<p>Estimates the Probability of Informed Trading (<code>PIN</code>) using the
initial sets from the algorithm in
Ersan and Alici (2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pin_ea(data, factorization, xtraclusters = 4, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pin_ea_+3A_data">data</code></td>
<td>
<p>A dataframe with 2 variables: the first
corresponds to buyer-initiated trades (buys), and the second corresponds
to seller-initiated trades (sells).</p>
</td></tr>
<tr><td><code id="pin_ea_+3A_factorization">factorization</code></td>
<td>
<p>A character string from
<code>{"E", "EHO", "LK", "NONE"}</code> referring to a given factorization. The
default value is <code>"E"</code>.</p>
</td></tr>
<tr><td><code id="pin_ea_+3A_xtraclusters">xtraclusters</code></td>
<td>
<p>An integer used to divide trading days into
<code>#(2 + xtraclusters)</code> clusters, thereby resulting in
<code>#comb(1 + xtraclusters, 1)</code> initial parameter sets in line with
Ersan and Alici (2016). The default value is <code>4</code>.</p>
</td></tr>
<tr><td><code id="pin_ea_+3A_verbose">verbose</code></td>
<td>
<p>A binary variable that determines whether detailed
information about the steps of the estimation of the PIN model is displayed.
No output is produced when <code>verbose</code> is set to <code>FALSE</code>. The default
value is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument 'data' should be a numeric dataframe, and contain
at least two variables. Only the first two variables will be considered:
The first variable is assumed to correspond to the total number of
buyer-initiated trades, while the second variable is assumed to
correspond to the total number of seller-initiated trades. Each row or
observation correspond to a trading day. <code>NA</code> values will be ignored.
</p>
<p>The factorization variable takes one of four values:
</p>

<ul>
<li> <p><code>"EHO"</code> refers to the factorization in
Easley et al. (2010)
</p>
</li>
<li> <p><code>"LK"</code>  refers to the factorization in
Lin and Ke (2011)
</p>
</li>
<li> <p><code>"E"</code>  refers to the factorization in
Ersan (2016)
</p>
</li>
<li> <p><code>"NONE"</code> refers to the original likelihood function - with no
factorization
</p>
</li></ul>

<p>The function <code>pin_ea()</code> implements the algorithm detailed in
Ersan and Alici (2016).
The higher the number of the additional layers (<code>xtraclusters</code>), the
better is the estimation. Ersan and Alici (2016),
however, have shown the benefit of increasing this number beyond 5 is
marginal, and statistically insignificant.<br /> <br />
The function <code>initials_pin_ea()</code> provides the initial parameter sets
obtained through the implementation of the
Ersan and Alici (2016) algorithm.
For further information on the initial parameter set determination, see
<code>initials_pin_ea()</code>.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>estimate.pin</code>
</p>


<h3>References</h3>

<p>Easley D, Hvidkjaer S, Ohara M (2010).
&ldquo;Factoring information into returns.&rdquo;
<em>Journal of Financial and Quantitative Analysis</em>, <b>45</b>(2), 293&ndash;309.
ISSN 00221090.<br /><br /> Ersan O (2016).
&ldquo;Multilayer Probability of Informed Trading.&rdquo;
<em>Available at SSRN 2874420</em>.<br /><br /> Ersan O, Alici A (2016).
&ldquo;An unbiased computation methodology for estimating the probability of informed trading (PIN).&rdquo;
<em>Journal of International Financial Markets, Institutions and Money</em>, <b>43</b>, 74&ndash;94.
ISSN 10424431.<br /><br /> Lin H, Ke W (2011).
&ldquo;A computing bias in estimating the probability of informed trading.&rdquo;
<em>Journal of Financial Markets</em>, <b>14</b>(4), 625-640.
ISSN 1386-4181.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># There is a preloaded quarterly dataset called 'dailytrades' with 60
# observations. Each observation corresponds to a day and contains the
# total number of buyer-initiated trades ('B') and seller-initiated
# trades ('S') on that day. To know more, type ?dailytrades

xdata &lt;- dailytrades

# Estimate the PIN model using the factorization of Ersan (2016), and initial
# parameter sets generated using the algorithm of Ersan and Alici (2016).
# The argument xtraclusters is omitted so will take its default value 4.

estimate &lt;- pin_ea(xdata, verbose = FALSE)

# Display the estimated PIN value

show(estimate@pin)

# Display the estimated parameters

show(estimate@parameters)

# Store the initial parameter sets used for MLE in a dataframe variable,
# and display its first five rows

initialsets &lt;- estimate@initialsets
show(head(initialsets, 5))

</code></pre>

<hr>
<h2 id='pin_gwj'>PIN estimation - initial parameter set of Gan et al. (2015)</h2><span id='topic+pin_gwj'></span>

<h3>Description</h3>

<p>Estimates the Probability of Informed Trading (<code>PIN</code>) using the
initial set from the algorithm in Gan et al.(2015).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pin_gwj(data, factorization = "E", verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pin_gwj_+3A_data">data</code></td>
<td>
<p>A dataframe with 2 variables: the first corresponds to
buyer-initiated trades (buys), and the second corresponds to seller-initiated
trades (sells).</p>
</td></tr>
<tr><td><code id="pin_gwj_+3A_factorization">factorization</code></td>
<td>
<p>A character string from
<code>{"EHO", "LK", "E", "NONE"}</code> referring to a given factorization. The
default value is set to <code>"E"</code>.</p>
</td></tr>
<tr><td><code id="pin_gwj_+3A_verbose">verbose</code></td>
<td>
<p>A binary variable that determines whether detailed
information about the steps of the estimation of the PIN model is displayed.
No output is produced when <code>verbose</code> is set to <code>FALSE</code>. The default
value is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument 'data' should be a numeric dataframe, and contain
at least two variables. Only the first two variables will be considered:
The first variable is assumed to correspond to the total number of
buyer-initiated trades, while the second variable is assumed to
correspond to the total number of seller-initiated trades. Each row or
observation correspond to a trading day. <code>NA</code> values will be ignored.
</p>
<p>The factorization variable takes one of four values:
</p>

<ul>
<li> <p><code>"EHO"</code> refers to the factorization in
Easley et al. (2010)
</p>
</li>
<li> <p><code>"LK"</code>  refers to the factorization in
Lin and Ke (2011)
</p>
</li>
<li> <p><code>"E"</code>  refers to the factorization in
Ersan (2016)
</p>
</li>
<li> <p><code>"NONE"</code> refers to the original likelihood function - with no
factorization
</p>
</li></ul>

<p>The function <code>pin_gwj()</code> implements the algorithm detailed in
Gan et al. (2015). You can use the function
<code>initials_pin_gwj()</code> in order to get the initial parameter set.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>estimate.pin</code>
</p>


<h3>References</h3>

<p>Easley D, Hvidkjaer S, Ohara M (2010).
&ldquo;Factoring information into returns.&rdquo;
<em>Journal of Financial and Quantitative Analysis</em>, <b>45</b>(2), 293&ndash;309.
ISSN 00221090.<br /><br /> Ersan O (2016).
&ldquo;Multilayer Probability of Informed Trading.&rdquo;
<em>Available at SSRN 2874420</em>.<br /><br /> Gan Q, Wei WC, Johnstone D (2015).
&ldquo;A faster estimation method for the probability of informed trading using hierarchical agglomerative clustering.&rdquo;
<em>Quantitative Finance</em>, <b>15</b>(11), 1805&ndash;1821.<br /><br /> Lin H, Ke W (2011).
&ldquo;A computing bias in estimating the probability of informed trading.&rdquo;
<em>Journal of Financial Markets</em>, <b>14</b>(4), 625-640.
ISSN 1386-4181.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># There is a preloaded quarterly dataset called 'dailytrades' with 60
# observations. Each observation corresponds to a day and contains the
# total number of buyer-initiated trades ('B') and seller-initiated
# trades ('S') on that day. To know more, type ?dailytrades

xdata &lt;- dailytrades

# Estimate the PIN model using the factorization of Ersan (2016), and initial
# parameter sets generated using the algorithm of Gan et al. (2015).
# The argument xtraclusters is omitted so will take its default value 4.

estimate &lt;- pin_gwj(xdata, verbose = FALSE)

# Display the estimated PIN value

show(estimate@pin)

# Display the estimated parameters

show(estimate@parameters)

# Store the initial parameter sets used for MLE in a dataframe variable,
# and display its first five rows

initialsets &lt;- estimate@initialsets
show(head(initialsets, 5))

</code></pre>

<hr>
<h2 id='pin_yz'>PIN estimation - initial parameter sets of Yan &amp; Zhang (2012)</h2><span id='topic+pin_yz'></span>

<h3>Description</h3>

<p>Estimates the Probability of Informed Trading (<code>PIN</code>) using the
initial parameter sets generated using the grid search algorithm of
Yan and Zhang (2012).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pin_yz(data, factorization, ea_correction = FALSE, grid_size = 5,
                                                  verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pin_yz_+3A_data">data</code></td>
<td>
<p>A dataframe with 2 variables: the first
corresponds to buyer-initiated trades (buys), and the second corresponds
to seller-initiated trades (sells).</p>
</td></tr>
<tr><td><code id="pin_yz_+3A_factorization">factorization</code></td>
<td>
<p>A character string from
<code>{"EHO", "LK", "E", "NONE"}</code> referring to a given factorization. The
default value is <code>"E"</code>.</p>
</td></tr>
<tr><td><code id="pin_yz_+3A_ea_correction">ea_correction</code></td>
<td>
<p>A binary variable determining whether the
modifications of the algorithm of Yan and Zhang (2012)
suggested by Ersan and Alici (2016) are
implemented. The default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="pin_yz_+3A_grid_size">grid_size</code></td>
<td>
<p>An integer between <code>1</code>, and <code>20</code>;
representing the size of the grid. The default value is <code>5</code>. See
more in details.</p>
</td></tr>
<tr><td><code id="pin_yz_+3A_verbose">verbose</code></td>
<td>
<p>A binary variable that determines whether detailed
information about the steps of the estimation of the PIN model is displayed.
No output is produced when <code>verbose</code> is set to <code>FALSE</code>. The default
value is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument 'data' should be a numeric dataframe, and contain
at least two variables. Only the first two variables will be considered:
The first variable is assumed to correspond to the total number of
buyer-initiated trades, while the second variable is assumed to
correspond to the total number of seller-initiated trades. Each row or
observation correspond to a trading day. <code>NA</code> values will be ignored.
</p>
<p>The factorization variable takes one of four values:
</p>

<ul>
<li> <p><code>"EHO"</code> refers to the factorization in
Easley et al. (2010)
</p>
</li>
<li> <p><code>"LK"</code>  refers to the factorization in
Lin and Ke (2011)
</p>
</li>
<li> <p><code>"E"</code>  refers to the factorization in
Ersan (2016)
</p>
</li>
<li> <p><code>"NONE"</code> refers to the original likelihood function - with no
factorization
</p>
</li></ul>

<p>The argument <code>grid_size</code> determines the size of the grid of the variables:
<code>alpha</code>, <code>delta</code>, and <code>eps.b</code>. If <code>grid_size</code> is set to a given value <code>m</code>,
the algorithm creates a sequence starting from <code>1/2m</code>, and ending in
<code>1 - 1/2m</code>, with a step of <code>1/m</code>. The default value of <code>5</code> corresponds
to the size of the grid in Yan and Zhang (2012).
In that case, the sequence starts at <code>0.1 = 1/(2 x 5)</code>, and ends in
<code>0.9 = 1 - 1/(2 x 5)</code> with a step of <code>0.2 = 1/m</code>.
</p>
<p>The function <code>pin_yz()</code> implements, by default, the original
Yan and Zhang (2012) algorithm as the default value of
<code>ea_correction</code> takes the value <code>FALSE</code>.
When the value of <code>ea_correction</code> is set to <code>TRUE</code>; then, sets
with irrelevant <code>mu</code> values are excluded, and sets with boundary values are
reintegrated in the initial parameter sets.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>estimate.pin</code>
</p>


<h3>References</h3>

<p>Easley D, Hvidkjaer S, Ohara M (2010).
&ldquo;Factoring information into returns.&rdquo;
<em>Journal of Financial and Quantitative Analysis</em>, <b>45</b>(2), 293&ndash;309.
ISSN 00221090.<br /><br /> Ersan O (2016).
&ldquo;Multilayer Probability of Informed Trading.&rdquo;
<em>Available at SSRN 2874420</em>.<br /><br /> Ersan O, Alici A (2016).
&ldquo;An unbiased computation methodology for estimating the probability of informed trading (PIN).&rdquo;
<em>Journal of International Financial Markets, Institutions and Money</em>, <b>43</b>, 74&ndash;94.
ISSN 10424431.<br /><br /> Lin H, Ke W (2011).
&ldquo;A computing bias in estimating the probability of informed trading.&rdquo;
<em>Journal of Financial Markets</em>, <b>14</b>(4), 625-640.
ISSN 1386-4181.<br /><br /> Yan Y, Zhang S (2012).
&ldquo;An improved estimation method and empirical properties of the probability of informed trading.&rdquo;
<em>Journal of Banking and Finance</em>, <b>36</b>(2), 454&ndash;467.
ISSN 03784266.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># There is a preloaded quarterly dataset called 'dailytrades' with 60
# observations. Each observation corresponds to a day and contains the
# total number of buyer-initiated trades ('B') and seller-initiated
# trades ('S') on that day. To know more, type ?dailytrades

xdata &lt;- dailytrades

# Estimate the PIN model using the factorization of Lin and Ke(2011), and
# initial parameter sets generated using the algorithm of Yan &amp; Zhang (2012).
# In contrast to the original algorithm, we set the grid size for the grid
# search algorithm at 3. The original algorithm assumes a grid of size 5.

estimate &lt;- pin_yz(xdata, "LK", grid_size = 3, verbose = FALSE)

# Display the estimated PIN value

show(estimate@pin)

# Display the estimated parameters

show(estimate@parameters)

# Store the initial parameter sets used for MLE in a dataframe variable,
# and display its first five rows

initialsets &lt;- estimate@initialsets
show(head(initialsets, 5))

</code></pre>

<hr>
<h2 id='set_display_digits'>Package-wide number of digits</h2><span id='topic+set_display_digits'></span>

<h3>Description</h3>

<p>Sets the number of digits to display in the output of the
different package functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_display_digits(digits = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_display_digits_+3A_digits">digits</code></td>
<td>
<p>A list of numbers corresponding to the different
display digits. The default value is <code>list()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameter <code>digits</code> is a named list. It will be containing:
</p>

<ul>
<li>  <p><code>d1</code>: contains the number of display digits for the values of
probability estimates such as <code class="reqn">\alpha</code>, <code class="reqn">\delta</code>, <code>pin</code>, <code>mpin</code>,
<code>mpin(j)</code>, <code>adjpin</code>, <code>psos</code>, <code class="reqn">\theta</code>, and <code class="reqn">\theta'</code>.
</p>
</li>
<li>  <p><code>d2</code>: contains the number of display digits for the values of
<code class="reqn">\mu</code>, <code class="reqn">\epsilon</code><sub>b</sub> and <code class="reqn">\epsilon</code><sub>s</sub>, as well as information criteria: <code>AIC</code>, <code>BIC</code>, and
<code>AWE</code>.
</p>
</li>
<li>  <p><code>d3</code>: contains the number of display digits for the remaining values
such as <code>vpin</code> statistics and <code>likelihood</code> value .
</p>
</li></ul>

<p>If the function is called with no arguments, the display digits will be reset
to the default values, i.e., <code>list(d1 = 6, d2 = 2, d3 = 3))</code>.
If the argument <code>digits</code> is not omitted, the function will only accept a list
containing exactly three numerical values, each ranging
between <code>0</code> and <code>10</code>. The list can be named or unnamed. If the numbers in the
argument <code>digits</code> are not integers, they will be rounded.
</p>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># There is a preloaded quarterly dataset called 'dailytrades' with 60
# observations. Each observation corresponds to a day and contains the
# total number of buyer-initiated trades ('B') and seller-initiated
# trades ('S') on that day. To know more, type ?dailytrades

xdata &lt;- dailytrades

# We show the output of the function pin_ea() using the default values
# of display digits. We then change these values using the function
# set_display_digits(), before displaying the same estimate.pin object
# again to see the difference.

model &lt;- pin_ea(xdata, verbose = FALSE)
show(model)

# Change the number of digits for d1 to 3, of d2 to 0 and of d3 to 2

set_display_digits(list(3, 0, 2))

# No need to run the function mpin_ml() again to update the display of an
# estimate.mpin object.This holds for all estimate* S4 objects.

show(model)

</code></pre>

<hr>
<h2 id='trade_classification'>Classification and aggregation of high-frequency data</h2><span id='topic+trade_classification'></span><span id='topic+classify_trades'></span><span id='topic+aggregate_trades'></span>

<h3>Description</h3>

<p><code>classify_trades()</code> classifies high-frequency trading data into
buyer-initiated and seller-initiated trades using different algorithms, and
different time lags.
<br /> <code>aggregate_trades()</code> aggregates high-frequency trading data into aggregated
data for provided frequency of aggregation. The aggregation is preceded by
a trade classification step which classifies trades using different trade
classification algorithms and time lags.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classify_trades(data, algorithm = "Tick", timelag = 0, ..., verbose = TRUE)

aggregate_trades(
  data,
  algorithm = "Tick",
  timelag = 0,
  frequency = "day",
  unit = 1,
  ...,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trade_classification_+3A_data">data</code></td>
<td>
<p>A dataframe with 4 variables in the following
order (<code>timestamp</code>, <code>price</code>, <code>bid</code>, <code>ask</code>).</p>
</td></tr>
<tr><td><code id="trade_classification_+3A_algorithm">algorithm</code></td>
<td>
<p>A character string refers to the algorithm used
to determine the trade initiator, a buyer or a seller. It takes one of four
values (<code>"Tick"</code>, <code>"Quote"</code>, <code>"LR"</code>, <code>"EMO"</code>). The default value is
<code>"Tick"</code>. For more information about the different algorithms, check the
details section.</p>
</td></tr>
<tr><td><code id="trade_classification_+3A_timelag">timelag</code></td>
<td>
<p>A number referring to the time lag in milliseconds
used to calculate the lagged midquote, bid and ask for the algorithms
<code>"Quote"</code>, <code>"EMO"</code> and <code>"LR"</code>.</p>
</td></tr>
<tr><td><code id="trade_classification_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to the functions <code>classify_trades()</code>
<code>aggregate_trades()</code>. The recognized arguments are <code>fullreport</code>,
and <code>is_parallel</code>. Other arguments will be ignored.
</p>

<ul>
<li> <p><code>fullreport</code> is binary variable passed to <code>aggregate_trades()</code> that
specifies whether the variable <code>freq</code> is returned. The default value is
<code>FALSE</code>.
</p>
</li>
<li> <p><code>is_parallel</code> is a logical variable passed to <code>classify_trades()</code> that
specifies whether the computation is performed using parallel or sequential
processing. #' The default value is <code>TRUE</code>. For more details, please refer to the
vignette 'Parallel processing' in the package, or
<a href="https://pinstimation.com/articles/parallel_processing.html">online</a>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="trade_classification_+3A_verbose">verbose</code></td>
<td>
<p>A binary variable that determines whether detailed
information about the progress of the trade classification is displayed.
No output is produced when <code>verbose</code> is set to <code>FALSE</code>. The default
value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="trade_classification_+3A_frequency">frequency</code></td>
<td>
<p>The frequency used to aggregate intraday data. It takes one
of the following values: <code>"sec"</code>, <code>"min"</code>, <code>"hour"</code>, <code>"day"</code>, <code>"week"</code>,
<code>"month"</code>. The default value is <code>"day"</code>.</p>
</td></tr>
<tr><td><code id="trade_classification_+3A_unit">unit</code></td>
<td>
<p>An integer referring to the size of the aggregation window
used to aggregate intraday data. The default value is <code>1</code>. For example, when
the parameter <code>frequency</code> is set to <code>"min"</code>, and the parameter <code>unit</code> is set
to 15, then the intraday data is aggregated every 15 minutes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>algorithm</code> takes one of four values:
</p>

<ul>
<li> <p><code>"Tick"</code> refers to the tick algorithm: Trade is classified as a
buy (sell) if the price of the trade to be classified
is above (below) the closest different price of a previous trade.
</p>
</li>
<li> <p><code>"Quote"</code> refers to the quote algorithm: it classifies a
trade as a buy (sell) if the trade price of the trade to be
classified is above (below) the mid-point of the bid and ask spread.
Trades executed at the mid-spread are not classified.
</p>
</li>
<li> <p><code>"LR"</code>  refers to <code>LR</code> algorithm as in
Lee and Ready (1991). It classifies a trade
as a buy (sell) if its price is above (below) the mid-spread (quote
algorithm), and  uses the tick algorithm if the trade price is at
the mid-spread.
</p>
</li>
<li> <p><code>"EMO"</code> refers to <code>EMO</code> algorithm as in
Ellis et al. (2000).
It classifies trades at the bid (ask) as sells (buys) and uses the tick
algorithm to classify trades within the then prevailing bid-ask spread.
</p>
</li></ul>

<p><code>LR</code> recommend the use of mid-spread five-seconds earlier ('5-second'
rule) mitigating trade misclassifications for many of the <code>150</code>
NYSE stocks they analyze. On the other hand, in more recent studies such
as Piwowar and Wei (2006) and
Aktas and Kryzanowski (2014), the use of
1-second lagged midquotes are shown to yield lower rates of
misclassifications. The default value is set to <code>0</code> seconds (no time-lag).
Considering the ultra-fast nature of todays financial markets, time-lag
is in the unit of milliseconds. Shorter than 1-second lags can also be
implemented by entering values such as  <code>100</code> or <code>500</code>.
</p>


<h3>Value</h3>

<p>The function classify_trades() returns a dataframe of five variables. The
first four variables are obtained from the argument <code>data</code>: <code>timestamp</code>,
<code>price</code>, <code>bid</code>, <code>ask</code>. The fifth variable is <code>isbuy</code>, which takes the value
<code>TRUE</code>, when the trade is classified as a buyer-initiated trade, and <code>FALSE</code>
when the trade is classified as a seller-initiated trade.
</p>
<p>The function aggregate_trades() returns a dataframe of two
(or three) variables. If <code>fullreport</code> is set to <code>TRUE</code>, then
the returned dataframe has three variables <code style="white-space: pre;">&#8288;{freq, b, s}&#8288;</code>. If
<code>fullreport</code> is set to <code>FALSE</code>, then the returned dataframe has
two variables <code style="white-space: pre;">&#8288;{b, s}&#8288;</code>, and, therefore, can be #'directly used for the
estimation of the <code>PIN</code> and <code>MPIN</code> models.
</p>


<h3>References</h3>

<p>Aktas OU, Kryzanowski L (2014).
&ldquo;Trade classification accuracy for the BIST.&rdquo;
<em>Journal of International Financial Markets, Institutions and Money</em>, <b>33</b>, 259-282.
ISSN 1042-4431.<br /><br /> Ellis K, Michaely R, Ohara M (2000).
&ldquo;The Accuracy of Trade Classification Rules: Evidence from Nasdaq.&rdquo;
<em>The Journal of Financial and Quantitative Analysis</em>, <b>35</b>(4), 529&ndash;551.<br /><br /> Lee CMC, Ready MJ (1991).
&ldquo;Inferring Trade Direction from Intraday Data.&rdquo;
<em>The Journal of Finance</em>, <b>46</b>(2), 733&ndash;746.
ISSN 00221082, 15406261.<br /><br /> Piwowar MS, Wei L (2006).
&ldquo;The Sensitivity of Effective Spread Estimates to Trade-Quote Matching Algorithms.&rdquo;
<em>Electronic Markets</em>, <b>16</b>(2), 112-129.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># There is a preloaded dataset called 'hfdata' contained in the package.
# It is an artificially created high-frequency trading data. The dataset
# contains  100 000 trades and five variables 'timestamp', 'price',
# 'volume', 'bid', and 'ask'. For more information, type ?hfdata.

xdata &lt;- hfdata
xdata$volume &lt;- NULL

# Use the EMO algorithm with a timelag of 500 milliseconds to classify
# high-frequency trades in the dataset 'xdata'

ctrades &lt;- classify_trades(xdata, algorithm = "EMO", timelag = 500, verbose = FALSE)

# Use the LR algorithm with a timelag of 1 second to aggregate intraday data
# in the dataset 'xdata' at a frequency of 15 minutes.


lrtrades &lt;- aggregate_trades(xdata, algorithm = "LR", timelag = 1000,
frequency = "min", unit = 15, verbose = FALSE)

# Use the Quote algorithm with a timelag of 1 second to aggregate intraday data
# in the dataset 'xdata' at a daily frequency.

qtrades &lt;- aggregate_trades(xdata, algorithm = "Quote", timelag = 1000,
frequency = "day", unit = 1, verbose = FALSE)

# Since the argument 'fullreport' is set to FALSE by default, then the
# output 'qtrades' can be used directly for the estimation of the PIN
# model, namely using pin_ea().

estimate &lt;- pin_ea(qtrades, verbose = FALSE)

# Show the estimate

show(estimate)

</code></pre>

<hr>
<h2 id='vpin'>Estimation of Volume-Synchronized PIN model</h2><span id='topic+vpin'></span>

<h3>Description</h3>

<p>Estimates the Volume-Synchronized Probability of Informed
Trading as developed in Easley et al. (2011)
and Easley et al. (2012).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vpin(data, timebarsize = 60, buckets = 50, samplength = 50,
            tradinghours = 24, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vpin_+3A_data">data</code></td>
<td>
<p>A dataframe with 3 variables:
<code>{timestamp, price, volume}</code>.</p>
</td></tr>
<tr><td><code id="vpin_+3A_timebarsize">timebarsize</code></td>
<td>
<p>An integer referring to  the size of timebars
in seconds. The default value is <code>60</code>.</p>
</td></tr>
<tr><td><code id="vpin_+3A_buckets">buckets</code></td>
<td>
<p>An integer referring to the number of buckets in a
daily average volume. The default value is <code>50</code>.</p>
</td></tr>
<tr><td><code id="vpin_+3A_samplength">samplength</code></td>
<td>
<p>An integer referring to the sample length
or the window size used to calculate the <code>VPIN</code> vector.
The default value is <code>50</code>.</p>
</td></tr>
<tr><td><code id="vpin_+3A_tradinghours">tradinghours</code></td>
<td>
<p>An integer referring to the length of daily
trading sessions in hours. The default value is <code>24</code>.</p>
</td></tr>
<tr><td><code id="vpin_+3A_verbose">verbose</code></td>
<td>
<p>A binary variable that determines whether detailed
information about the steps of the estimation of the VPIN model is displayed.
No output is produced when <code>verbose</code> is set to <code>FALSE</code>. The default
value is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The dataframe data should contain at least three variables. Only the
first three variables will be considered and in the following order
<code>{timestamp, price, volume}</code>.
</p>
<p>The property <code>@bucketdata</code> is created as in
Abad and Yague (2012).
</p>
<p>The argument <code>timebarsize</code> is in seconds enabling the user to implement
shorter than <code>1</code> minute intervals. The default value is set to <code>1</code> minute
(<code>60</code> seconds) following Easley et al. (2011, 2012).
</p>
<p>The parameter <code>tradinghours</code> is used to eventually correct the duration per
bucket. The duration of a given bucket is the difference between the
timestamp of the last trade <code>endtime</code> and the timestamp of the first trade
<code>stime</code> in the bucket. If the first trade and the last trade in a
bucket occur in two different days, and the market trading session does not
cover a full day <code>(24 hours)</code>; then the duration of the bucket will be
inflated. Assume that the daily trading session is 8 hours
<code>(tradinghours=8)</code>, the start time of a bucket is <code>2018-10-12 17:06:40</code>
and its end time is <code>2018-10-13 09:36:00</code>. A straightforward calculation
gives that the duration of this bucket is <code>59,360 secs</code>. However, this
duration includes the time during which the market is closed <code style="white-space: pre;">&#8288;(16 hours)&#8288;</code>.
The corrected duration takes into consideration only the time of market
activity: <code style="white-space: pre;">&#8288;duration=59,360-16*3600= 1760 secs&#8288;</code>, i.e., about <code style="white-space: pre;">&#8288;30 minutes&#8288;</code>.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>estimate.vpin</code>.
</p>


<h3>References</h3>

<p>Abad D, Yague J (2012).
&ldquo;From PIN to VPIN: An introduction to order flow toxicity.&rdquo;
<em>The Spanish Review of Financial Economics</em>, <b>10</b>(2), 74&ndash;83.<br /><br /> Easley D, De Prado MML, Ohara M (2011).
&ldquo;The microstructure of the \&quot;flash crash\&quot;: flow toxicity, liquidity crashes, and the probability of informed trading.&rdquo;
<em>The Journal of Portfolio Management</em>, <b>37</b>(2), 118&ndash;128.<br /><br /> Easley D, Lopez De Prado MM, OHara M (2012).
&ldquo;Flow toxicity and liquidity in a high-frequency world.&rdquo;
<em>Review of Financial Studies</em>, <b>25</b>(5), 1457&ndash;1493.
ISSN 08939454.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># There is a preloaded dataset called 'hfdata' contained in the package.
# It is an artificially created high-frequency trading data. The dataset
# contains 100 000 trades and five variables 'timestamp', 'price',
# 'volume', 'bid' and 'ask'. For more information, type ?hfdata.

xdata &lt;- hfdata

# Estimate VPIN model, using the following parameter set where the time
# bar size is 5 minutes, i.e., 300 seconds (timebarsize = 300), 50
# buckets per average daily volume (buckets = 50), and a window size of
# 250 for the VPIN calculation (samplength = 250).

estimate &lt;- vpin(xdata, timebarsize = 300, buckets = 50, samplength = 250)

# Display a description of the estimate

show(estimate)

# Plot the estimated VPIN vector

plot(estimate@vpin, type = "l", xlab = "time", ylab = "VPIN", col = "blue")

# Display the parameters of VPIN estimates

show(estimate@parameters)

# Store the computed data of the different buckets in a dataframe 'buckets'.
# Display the first 10 rows of the dataframe 'buckets'.

buckets &lt;- estimate@bucketdata
show(head(buckets, 10))

# Store the daily VPIN values (weighted and unweighted) in a dataframe
# 'dayvpin'.

# Display the first 10 rows of the dataframe 'dayvpin'.

dayvpin &lt;- estimate@dailyvpin
show(head(dayvpin, 10))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
