<!DOCTYPE html><html lang="en"><head><title>Help for package anndata</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {anndata}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#anndata-package'><p>anndata - Annotated Data</p></a></li>
<li><a href='#all.equal.AnnDataR6'><p>Test if two objects objects are equal</p></a></li>
<li><a href='#AnnData'><p>Create an Annotated Data Matrix</p></a></li>
<li><a href='#concat'><p>concat</p></a></li>
<li><a href='#dimnames.AnnDataR6'><p>AnnData Helpers</p></a></li>
<li><a href='#dimnames.RawR6'><p>Raw Helpers</p></a></li>
<li><a href='#install_anndata'><p>Install anndata</p></a></li>
<li><a href='#Layers'><p>Create a Layers object</p></a></li>
<li><a href='#names.LayersR6'><p>Layers Helpers</p></a></li>
<li><a href='#r-py-conversion'><p>Convert between Python and R objects</p></a></li>
<li><a href='#Raw'><p>Create a Raw object</p></a></li>
<li><a href='#read_csv'><p>read_csv</p></a></li>
<li><a href='#read_excel'><p>read_excel</p></a></li>
<li><a href='#read_h5ad'><p>read_h5ad</p></a></li>
<li><a href='#read_hdf'><p>read_hdf</p></a></li>
<li><a href='#read_loom'><p>read_loom</p></a></li>
<li><a href='#read_mtx'><p>read_mtx</p></a></li>
<li><a href='#read_text'><p>read_text</p></a></li>
<li><a href='#read_umi_tools'><p>read_umi_tools</p></a></li>
<li><a href='#write_csvs'><p>Write annotation to .csv files.</p></a></li>
<li><a href='#write_h5ad'><p>Write .h5ad-formatted hdf5 file.</p></a></li>
<li><a href='#write_loom'><p>Write .loom-formatted hdf5 file.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>'anndata' for R</td>
</tr>
<tr>
<td>Version:</td>
<td>0.7.5.6</td>
</tr>
<tr>
<td>Description:</td>
<td>A 'reticulate' wrapper for the Python package 'anndata'.
    Provides a scalable way of keeping track of data and learned
    annotations.  Used to read from and write to the h5ad file format.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://anndata.dynverse.org">https://anndata.dynverse.org</a>, <a href="https://github.com/dynverse/anndata">https://github.com/dynverse/anndata</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/dynverse/anndata/issues">https://github.com/dynverse/anndata/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>assertthat, Matrix, methods, R6, reticulate (&ge; 1.17)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>stats, testthat, knitr, rmarkdown</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Config/reticulate:</td>
<td>list( packages = list( list(package = "anndata") ) )</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-17 14:08:01 UTC; rcannood</td>
</tr>
<tr>
<td>Author:</td>
<td>Philipp Angerer <a href="https://orcid.org/0000-0002-0369-2888"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ccp] (github: flying-sheep),
  Alex Wolf <a href="https://orcid.org/0000-0002-8760-7838"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ccp]
    (github: falexwolf),
  Isaac Virshup [ccp] (github: ivirshup),
  Sergei Rybakov [ccp] (github: Koncopd),
  Robrecht Cannoodt <a href="https://orcid.org/0000-0003-3641-729X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph] (github: rcannood)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Robrecht Cannoodt &lt;rcannood@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-17 14:50:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='anndata-package'>anndata - Annotated Data</h2><span id='topic+anndata-package'></span><span id='topic+anndata'></span>

<h3>Description</h3>

<p><code>anndata</code> provides a scalable way of keeping track of data
and learned annotations, and can be used to read from and write to the h5ad
file format. <code>AnnData()</code> stores a data matrix <code>X</code> together with annotations
of observations <code>obs</code> (<code>obsm</code>, <code>obsp</code>), variables <code>var</code> (<code>varm</code>, <code>varp</code>),
and unstructured annotations <code>uns</code>.
</p>


<h3>Details</h3>

<p>This package is, in essense, an R wrapper for the similarly named Python package
<a href="https://anndata.readthedocs.io/en/latest/"><code>anndata</code></a>, with some added functionality
to support more R-like syntax.
The version number of the anndata R package is synced
with the version number of the python version.
</p>
<p>Check out <code>?anndata</code> for a full list of the functions provided by this package.
</p>


<h3>Creating an AnnData object</h3>


<ul>
<li> <p><code><a href="#topic+AnnData">AnnData()</a></code>
</p>
</li></ul>



<h3>Concatenating two or more AnnData objects</h3>


<ul>
<li> <p><code><a href="#topic+concat">concat()</a></code>
</p>
</li></ul>



<h3>Reading an AnnData object from a file</h3>


<ul>
<li> <p><code><a href="#topic+read_csv">read_csv()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+read_excel">read_excel()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+read_h5ad">read_h5ad()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+read_hdf">read_hdf()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+read_loom">read_loom()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+read_mtx">read_mtx()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+read_text">read_text()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+read_umi_tools">read_umi_tools()</a></code>
</p>
</li></ul>



<h3>Writing an AnnData object to a file</h3>


<ul>
<li> <p><code><a href="#topic+write_csvs">write_csvs()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+write_h5ad">write_h5ad()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+write_loom">write_loom()</a></code>
</p>
</li></ul>



<h3>Install the <code>anndata</code> Python package</h3>


<ul>
<li> <p><code><a href="#topic+install_anndata">install_anndata()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ad &lt;- AnnData(
  X = matrix(1:6, nrow = 2),
  obs = data.frame(group = c("a", "b"), row.names = c("s1", "s2")),
  var = data.frame(type = c(1L, 2L, 3L), row.names = c("var1", "var2", "var3")),
  layers = list(
    spliced = matrix(4:9, nrow = 2),
    unspliced = matrix(8:13, nrow = 2)
  ),
  obsm = list(
    ones = matrix(rep(1L, 10), nrow = 2),
    rand = matrix(rnorm(6), nrow = 2),
    zeros = matrix(rep(0L, 10), nrow = 2)
  ),
  varm = list(
    ones = matrix(rep(1L, 12), nrow = 3),
    rand = matrix(rnorm(6), nrow = 3),
    zeros = matrix(rep(0L, 12), nrow = 3)
  ),
  uns = list(
    a = 1,
    b = data.frame(i = 1:3, j = 4:6, value = runif(3)),
    c = list(c.a = 3, c.b = 4)
  )
)

ad$X

ad$obs
ad$var

ad$obsm["ones"]
ad$varm["rand"]

ad$layers["unspliced"]
ad$layers["spliced"]

ad$uns["b"]

ad[,c("var1", "var2")]
ad[-1, , drop = FALSE]
ad[, 2] &lt;- 10

## End(Not run)
</code></pre>

<hr>
<h2 id='all.equal.AnnDataR6'>Test if two objects objects are equal</h2><span id='topic+all.equal.AnnDataR6'></span><span id='topic+all.equal.LayersR6'></span><span id='topic+all.equal.RawR6'></span>

<h3>Description</h3>

<p>Test if two objects objects are equal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'equal.AnnDataR6'
all(target, current, ...)

## S3 method for class 'equal.LayersR6'
all(target, current, ...)

## S3 method for class 'equal.RawR6'
all(target, current, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="all.equal.AnnDataR6_+3A_target">target</code></td>
<td>
<p><span class="rlang"><b>R</b></span> object.</p>
</td></tr>
<tr><td><code id="all.equal.AnnDataR6_+3A_current">current</code></td>
<td>
<p>other <span class="rlang"><b>R</b></span> object, to be compared with <code>target</code>.</p>
</td></tr>
<tr><td><code id="all.equal.AnnDataR6_+3A_...">...</code></td>
<td>
<p>further arguments for different methods, notably the
following two, for numerical comparison:</p>
</td></tr>
</table>

<hr>
<h2 id='AnnData'>Create an Annotated Data Matrix</h2><span id='topic+AnnData'></span><span id='topic+AnnDataR6'></span>

<h3>Description</h3>

<p><code>AnnData</code> stores a data matrix <code>X</code> together with annotations
of observations <code>obs</code> (<code>obsm</code>, <code>obsp</code>), variables <code>var</code> (<code>varm</code>, <code>varp</code>),
and unstructured annotations <code>uns</code>.
</p>
<p>An <code>AnnData</code> object <code>adata</code> can be sliced like a data frame,
for instance <code>adata_subset &lt;- adata[, list_of_variable_names]</code>. <code>AnnData</code>’s
basic structure is similar to R's ExpressionSet.
</p>
<p>If setting an <code>h5ad</code>-formatted HDF5 backing file <code>filename</code>,
data remains on the disk but is automatically loaded into memory if needed.
See this <a href="https://falexwolf.de/blog/171223_AnnData_indexing_views_HDF5-backing/">blog post</a> for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AnnData(
  X = NULL,
  obs = NULL,
  var = NULL,
  uns = NULL,
  obsm = NULL,
  varm = NULL,
  layers = NULL,
  raw = NULL,
  dtype = "float32",
  shape = NULL,
  filename = NULL,
  filemode = NULL,
  obsp = NULL,
  varp = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AnnData_+3A_x">X</code></td>
<td>
<p>A #observations × #variables data matrix. A view of the data is used if the data type matches, otherwise, a copy is made.</p>
</td></tr>
<tr><td><code id="AnnData_+3A_obs">obs</code></td>
<td>
<p>Key-indexed one-dimensional observations annotation of length #observations.</p>
</td></tr>
<tr><td><code id="AnnData_+3A_var">var</code></td>
<td>
<p>Key-indexed one-dimensional variables annotation of length #variables.</p>
</td></tr>
<tr><td><code id="AnnData_+3A_uns">uns</code></td>
<td>
<p>Key-indexed unstructured annotation.</p>
</td></tr>
<tr><td><code id="AnnData_+3A_obsm">obsm</code></td>
<td>
<p>Key-indexed multi-dimensional observations annotation of length #observations. If passing a <code>~numpy.ndarray</code>, it needs to have a structured datatype.</p>
</td></tr>
<tr><td><code id="AnnData_+3A_varm">varm</code></td>
<td>
<p>Key-indexed multi-dimensional variables annotation of length #variables. If passing a <code>~numpy.ndarray</code>, it needs to have a structured datatype.</p>
</td></tr>
<tr><td><code id="AnnData_+3A_layers">layers</code></td>
<td>
<p>Key-indexed multi-dimensional arrays aligned to dimensions of <code>X</code>.</p>
</td></tr>
<tr><td><code id="AnnData_+3A_raw">raw</code></td>
<td>
<p>Store raw version of <code>X</code> and <code>var</code> as <code style="white-space: pre;">&#8288;$raw$X&#8288;</code> and <code style="white-space: pre;">&#8288;$raw$var&#8288;</code>.</p>
</td></tr>
<tr><td><code id="AnnData_+3A_dtype">dtype</code></td>
<td>
<p>Data type used for storage.</p>
</td></tr>
<tr><td><code id="AnnData_+3A_shape">shape</code></td>
<td>
<p>Shape list (#observations, #variables). Can only be provided if <code>X</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="AnnData_+3A_filename">filename</code></td>
<td>
<p>Name of backing file. See <a href="https://docs.h5py.org/en/latest/high/file.html#h5py.File">h5py.File</a>.</p>
</td></tr>
<tr><td><code id="AnnData_+3A_filemode">filemode</code></td>
<td>
<p>Open mode of backing file. See <a href="https://docs.h5py.org/en/latest/high/file.html#h5py.File">h5py.File</a>.</p>
</td></tr>
<tr><td><code id="AnnData_+3A_obsp">obsp</code></td>
<td>
<p>Pairwise annotation of observations, a mutable mapping with array-like values.</p>
</td></tr>
<tr><td><code id="AnnData_+3A_varp">varp</code></td>
<td>
<p>Pairwise annotation of observations, a mutable mapping with array-like values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>AnnData</code> stores observations (samples) of variables/features in the rows of a matrix.
This is the convention of the modern classics of statistic and machine learning,
the convention of dataframes both in R and Python and the established statistics
and machine learning packages in Python (statsmodels, scikit-learn).
</p>
<p>Single dimensional annotations of the observation and variables are stored
in the <code>obs</code> and <code>var</code> attributes as data frames.
This is intended for metrics calculated over their axes.
Multi-dimensional annotations are stored in <code>obsm</code> and <code>varm</code>,
which are aligned to the objects observation and variable dimensions respectively.
Square matrices representing graphs are stored in <code>obsp</code> and <code>varp</code>,
with both of their own dimensions aligned to their associated axis.
Additional measurements across both observations and variables are stored in
<code>layers</code>.
</p>
<p>Indexing into an AnnData object can be performed by relative position
with numeric indices,  or by labels.
To avoid ambiguity with numeric indexing into observations or variables,
indexes of the AnnData object are converted to strings by the constructor.
</p>
<p>Subsetting an AnnData object by indexing into it will also subset its elements
according to the dimensions they were aligned to.
This means an operation like <code>adata[list_of_obs, ]</code> will also subset <code>obs</code>,
<code>obsm</code>, and <code>layers</code>.
</p>
<p>Subsetting an AnnData object returns a view into the original object,
meaning very little additional memory is used upon subsetting.
This is achieved lazily, meaning that the constituent arrays are subset on access.
Copying a view causes an equivalent “real” AnnData object to be generated.
Attempting to modify a view (at any attribute except X) is handled
in a copy-on-modify manner, meaning the object is initialized in place.
Here's an example
</p>
<div class="sourceCode r"><pre>batch1 &lt;- adata[adata$obs["batch"] == "batch1", ]
batch1$obs["value"] = 0 # This makes batch1 a “real” AnnData object
</pre></div>
<p>At the end of this snippet: <code>adata</code> was not modified,
and <code>batch1</code> is its own AnnData object with its own data.
</p>
<p>Similar to Bioconductor’s <code>ExpressionSet</code> and <code>scipy.sparse</code> matrices,
subsetting an AnnData object retains the dimensionality of its constituent arrays.
Therefore, unlike with the classes exposed by <code>pandas</code>, <code>numpy</code>,
and <code>xarray</code>, there is no concept of a one dimensional AnnData object.
AnnDatas always have two inherent dimensions, <code>obs</code> and <code>var</code>.
Additionally, maintaining the dimensionality of the AnnData object allows for
consistent handling of <code>scipy.sparse</code> matrices and <code>numpy</code> arrays.
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>X</code></dt><dd><p>Data matrix of shape <code>n_obs</code> × <code>n_vars</code>.</p>
</dd>
<dt><code>filename</code></dt><dd><p>Name of the backing file.
</p>
<p>Change to backing mode by setting the filename of a <code>.h5ad</code> file.
</p>

<ul>
<li><p> Setting the filename writes the stored data to disk.
</p>
</li>
<li><p> Setting the filename when the filename was previously another name
moves the backing file from the previous file to the new file.
If you want to copy the previous file, use <code>copy(filename='new_filename')</code>.
</p>
</li></ul>
</dd>
<dt><code>layers</code></dt><dd><p>A list-like object with values of the same dimensions as <code>X</code>.
Layers in AnnData are inspired by <a href="https://linnarssonlab.org/loompy/apiwalkthrough/index.html#loomlayers">loompy's layers</a>.
</p>
<p>Overwrite the layers:
</p>
<div class="sourceCode"><pre>adata$layers &lt;- list(spliced = spliced, unspliced = unspliced)
</pre></div>
<p>Return the layer named <code>"unspliced"</code>:
</p>
<div class="sourceCode"><pre>adata$layers["unspliced"]
</pre></div>
<p>Create or replace the <code>"spliced"</code> layer:
</p>
<div class="sourceCode"><pre>adata$layers["spliced"] = example_matrix
</pre></div>
<p>Assign the 10th column of layer <code>"spliced"</code> to the variable a:
</p>
<div class="sourceCode"><pre>a &lt;- adata$layers["spliced"][, 10]
</pre></div>
<p>Delete the <code>"spliced"</code>:
</p>
<div class="sourceCode"><pre>adata$layers["spliced"] &lt;- NULL
</pre></div>
<p>Return layers' names:
</p>
<div class="sourceCode"><pre>names(adata$layers)
</pre></div></dd>
<dt><code>T</code></dt><dd><p>Transpose whole object.
</p>
<p>Data matrix is transposed, observations and variables are interchanged.
</p>
<p>Ignores <code>.raw</code>.</p>
</dd>
<dt><code>is_view</code></dt><dd><p><code>TRUE</code> if object is view of another AnnData object, <code>FALSE</code> otherwise.</p>
</dd>
<dt><code>isbacked</code></dt><dd><p><code>TRUE</code> if object is backed on disk, <code>FALSE</code> otherwise.</p>
</dd>
<dt><code>n_obs</code></dt><dd><p>Number of observations.</p>
</dd>
<dt><code>obs</code></dt><dd><p>One-dimensional annotation of observations (data.frame).</p>
</dd>
<dt><code>obs_names</code></dt><dd><p>Names of observations.</p>
</dd>
<dt><code>obsm</code></dt><dd><p>Multi-dimensional annotation of observations (matrix).
</p>
<p>Stores for each key a two or higher-dimensional matrix with <code>n_obs</code> rows.</p>
</dd>
<dt><code>obsp</code></dt><dd><p>Pairwise annotation of observations, a mutable mapping with array-like values.
</p>
<p>Stores for each key a two or higher-dimensional matrix whose first two dimensions are of length <code>n_obs</code>.</p>
</dd>
<dt><code>n_vars</code></dt><dd><p>Number of variables.</p>
</dd>
<dt><code>var</code></dt><dd><p>One-dimensional annotation of variables (data.frame).</p>
</dd>
<dt><code>var_names</code></dt><dd><p>Names of variables.</p>
</dd>
<dt><code>varm</code></dt><dd><p>Multi-dimensional annotation of variables (matrix).
</p>
<p>Stores for each key a two or higher-dimensional matrix with <code>n_vars</code> rows.</p>
</dd>
<dt><code>varp</code></dt><dd><p>Pairwise annotation of variables, a mutable mapping with array-like values.
</p>
<p>Stores for each key a two or higher-dimensional matrix whose first two dimensions are of length <code>n_vars</code>.</p>
</dd>
<dt><code>shape</code></dt><dd><p>Shape of data matrix (<code>n_obs</code>, <code>n_vars</code>).</p>
</dd>
<dt><code>uns</code></dt><dd><p>Unstructured annotation (ordered dictionary).</p>
</dd>
<dt><code>raw</code></dt><dd><p>Store raw version of <code>X</code> and <code>var</code> as <code style="white-space: pre;">&#8288;$raw$X&#8288;</code> and <code style="white-space: pre;">&#8288;$raw$var&#8288;</code>.
</p>
<p>The <code>raw</code> attribute is initialized with the current content of an object
by setting:
</p>
<div class="sourceCode"><pre>adata$raw = adata
</pre></div>
<p>Its content can be deleted:
</p>
<div class="sourceCode"><pre>adata$raw &lt;- NULL
</pre></div>
<p>Upon slicing an AnnData object along the obs (row) axis, <code>raw</code> is also
sliced. Slicing an AnnData object along the vars (columns) axis
leaves <code>raw</code> unaffected. Note that you can call:
</p>
<div class="sourceCode"><pre>adata$raw[, 'orig_variable_name']$X
</pre></div>
<p><code style="white-space: pre;">&#8288;to retrieve the data associated with a variable that might have been filtered out or "compressed away" in&#8288;</code>X'.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-AnnDataR6-new"><code>AnnDataR6$new()</code></a>
</p>
</li>
<li> <p><a href="#method-AnnDataR6-obs_keys"><code>AnnDataR6$obs_keys()</code></a>
</p>
</li>
<li> <p><a href="#method-AnnDataR6-obs_names_make_unique"><code>AnnDataR6$obs_names_make_unique()</code></a>
</p>
</li>
<li> <p><a href="#method-AnnDataR6-obsm_keys"><code>AnnDataR6$obsm_keys()</code></a>
</p>
</li>
<li> <p><a href="#method-AnnDataR6-var_keys"><code>AnnDataR6$var_keys()</code></a>
</p>
</li>
<li> <p><a href="#method-AnnDataR6-var_names_make_unique"><code>AnnDataR6$var_names_make_unique()</code></a>
</p>
</li>
<li> <p><a href="#method-AnnDataR6-varm_keys"><code>AnnDataR6$varm_keys()</code></a>
</p>
</li>
<li> <p><a href="#method-AnnDataR6-uns_keys"><code>AnnDataR6$uns_keys()</code></a>
</p>
</li>
<li> <p><a href="#method-AnnDataR6-chunk_X"><code>AnnDataR6$chunk_X()</code></a>
</p>
</li>
<li> <p><a href="#method-AnnDataR6-chunked_X"><code>AnnDataR6$chunked_X()</code></a>
</p>
</li>
<li> <p><a href="#method-AnnDataR6-concatenate"><code>AnnDataR6$concatenate()</code></a>
</p>
</li>
<li> <p><a href="#method-AnnDataR6-copy"><code>AnnDataR6$copy()</code></a>
</p>
</li>
<li> <p><a href="#method-AnnDataR6-rename_categories"><code>AnnDataR6$rename_categories()</code></a>
</p>
</li>
<li> <p><a href="#method-AnnDataR6-strings_to_categoricals"><code>AnnDataR6$strings_to_categoricals()</code></a>
</p>
</li>
<li> <p><a href="#method-AnnDataR6-to_df"><code>AnnDataR6$to_df()</code></a>
</p>
</li>
<li> <p><a href="#method-AnnDataR6-transpose"><code>AnnDataR6$transpose()</code></a>
</p>
</li>
<li> <p><a href="#method-AnnDataR6-write_csvs"><code>AnnDataR6$write_csvs()</code></a>
</p>
</li>
<li> <p><a href="#method-AnnDataR6-write_h5ad"><code>AnnDataR6$write_h5ad()</code></a>
</p>
</li>
<li> <p><a href="#method-AnnDataR6-write_loom"><code>AnnDataR6$write_loom()</code></a>
</p>
</li>
<li> <p><a href="#method-AnnDataR6-print"><code>AnnDataR6$print()</code></a>
</p>
</li>
<li> <p><a href="#method-AnnDataR6-.set_py_object"><code>AnnDataR6$.set_py_object()</code></a>
</p>
</li>
<li> <p><a href="#method-AnnDataR6-.get_py_object"><code>AnnDataR6$.get_py_object()</code></a>
</p>
</li></ul>


<hr>
<a id="method-AnnDataR6-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new AnnData object
</p>


<h5>Usage</h5>

<div class="r"><pre>AnnDataR6$new(obj)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>obj</code></dt><dd><p>A Python anndata object</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# use AnnData() instead of AnnDataR6$new()
ad &lt;- AnnData(
  X = matrix(c(0, 1, 2, 3), nrow = 2),
  obs = data.frame(group = c("a", "b"), row.names = c("s1", "s2")),
  var = data.frame(type = c(1L, 2L), row.names = c("var1", "var2"))
)
}
</pre>
</div>


<hr>
<a id="method-AnnDataR6-obs_keys"></a>



<h4>Method <code>obs_keys()</code></h4>

<p>List keys of observation annotation <code>obs</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>AnnDataR6$obs_keys()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
ad &lt;- AnnData(
  X = matrix(c(0, 1, 2, 3), nrow = 2),
  obs = data.frame(group = c("a", "b"), row.names = c("s1", "s2"))
)
ad$obs_keys()
}
</pre>
</div>


<hr>
<a id="method-AnnDataR6-obs_names_make_unique"></a>



<h4>Method <code>obs_names_make_unique()</code></h4>

<p>Makes the index unique by appending a number string to each duplicate index element: 1, 2, etc.
</p>
<p>If a tentative name created by the algorithm already exists in the index, it tries the next integer in the sequence.
</p>
<p>The first occurrence of a non-unique value is ignored.
</p>


<h5>Usage</h5>

<div class="r"><pre>AnnDataR6$obs_names_make_unique(join = "-")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>join</code></dt><dd><p>The connecting string between name and integer (default: <code>"-"</code>).</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
ad &lt;- AnnData(
  X = matrix(rep(1, 6), nrow = 3),
  obs = data.frame(field = c(1, 2, 3))
)
ad$obs_names &lt;- c("a", "a", "b")
ad$obs_names_make_unique()
ad$obs_names
}
</pre>
</div>


<hr>
<a id="method-AnnDataR6-obsm_keys"></a>



<h4>Method <code>obsm_keys()</code></h4>

<p>List keys of observation annotation <code>obsm</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>AnnDataR6$obsm_keys()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
ad &lt;- AnnData(
  X = matrix(c(0, 1, 2, 3), nrow = 2),
  obs = data.frame(group = c("a", "b"), row.names = c("s1", "s2")),
  obsm = list(
    ones = matrix(rep(1L, 10), nrow = 2),
    rand = matrix(rnorm(6), nrow = 2),
    zeros = matrix(rep(0L, 10), nrow = 2)
  )
)
ad$obs_keys()
}
</pre>
</div>


<hr>
<a id="method-AnnDataR6-var_keys"></a>



<h4>Method <code>var_keys()</code></h4>

<p>List keys of variable annotation <code>var</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>AnnDataR6$var_keys()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
ad &lt;- AnnData(
  X = matrix(c(0, 1, 2, 3), nrow = 2),
  var = data.frame(type = c(1L, 2L), row.names = c("var1", "var2"))
)
ad$var_keys()
}
</pre>
</div>


<hr>
<a id="method-AnnDataR6-var_names_make_unique"></a>



<h4>Method <code>var_names_make_unique()</code></h4>

<p>Makes the index unique by appending a number string to each duplicate index element: 1, 2, etc.
</p>
<p>If a tentative name created by the algorithm already exists in the index, it tries the next integer in the sequence.
</p>
<p>The first occurrence of a non-unique value is ignored.
</p>


<h5>Usage</h5>

<div class="r"><pre>AnnDataR6$var_names_make_unique(join = "-")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>join</code></dt><dd><p>The connecting string between name and integer (default: <code>"-"</code>).</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
ad &lt;- AnnData(
  X = matrix(rep(1, 6), nrow = 2),
  var = data.frame(field = c(1, 2, 3))
)
ad$var_names &lt;- c("a", "a", "b")
ad$var_names_make_unique()
ad$var_names
}
</pre>
</div>


<hr>
<a id="method-AnnDataR6-varm_keys"></a>



<h4>Method <code>varm_keys()</code></h4>

<p>List keys of variable annotation <code>varm</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>AnnDataR6$varm_keys()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
ad &lt;- AnnData(
  X = matrix(c(0, 1, 2, 3), nrow = 2),
  var = data.frame(type = c(1L, 2L), row.names = c("var1", "var2")),
  varm = list(
    ones = matrix(rep(1L, 10), nrow = 2),
    rand = matrix(rnorm(6), nrow = 2),
    zeros = matrix(rep(0L, 10), nrow = 2)
  )
)
ad$varm_keys()
}
</pre>
</div>


<hr>
<a id="method-AnnDataR6-uns_keys"></a>



<h4>Method <code>uns_keys()</code></h4>

<p>List keys of unstructured annotation <code>uns</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>AnnDataR6$uns_keys()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
ad &lt;- AnnData(
  X = matrix(c(0, 1, 2, 3), nrow = 2),
  obs = data.frame(group = c("a", "b"), row.names = c("s1", "s2")),
  var = data.frame(type = c(1L, 2L), row.names = c("var1", "var2")),
  uns = list(a = 1, b = 2, c = list(c.a = 3, c.b = 4))
)
}
</pre>
</div>


<hr>
<a id="method-AnnDataR6-chunk_X"></a>



<h4>Method <code>chunk_X()</code></h4>

<p>Return a chunk of the data matrix <code>X</code> with random or specified indices.
</p>


<h5>Usage</h5>

<div class="r"><pre>AnnDataR6$chunk_X(select = 1000L, replace = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>select</code></dt><dd><p>Depending on the values:
</p>

<ul>
<li><p> 1 integer: A random chunk with select rows will be returned.
</p>
</li>
<li><p> multiple integers: A chunk with these indices will be returned.
</p>
</li></ul>
</dd>
<dt><code>replace</code></dt><dd><p>if <code>select</code> is an integer then <code>TRUE</code> means random sampling of indices with replacement,
<code>FALSE</code> without replacement.</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
ad &lt;- AnnData(
  X = matrix(runif(10000), nrow = 50)
)

ad$chunk_X(select = 10L) # 10 random samples
ad$chunk_X(select = 1:3) # first 3 samples
}
</pre>
</div>


<hr>
<a id="method-AnnDataR6-chunked_X"></a>



<h4>Method <code>chunked_X()</code></h4>

<p>Return an iterator over the rows of the data matrix X.
</p>


<h5>Usage</h5>

<div class="r"><pre>AnnDataR6$chunked_X(chunk_size = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>chunk_size</code></dt><dd><p>Row size of a single chunk.</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
ad &lt;- AnnData(
  X = matrix(runif(10000), nrow = 50)
)
ad$chunked_X(10)
}
</pre>
</div>


<hr>
<a id="method-AnnDataR6-concatenate"></a>



<h4>Method <code>concatenate()</code></h4>

<p>Concatenate along the observations axis.
</p>


<h5>Usage</h5>

<div class="r"><pre>AnnDataR6$concatenate(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Deprecated</p>
</dd>
</dl>

</div>


<hr>
<a id="method-AnnDataR6-copy"></a>



<h4>Method <code>copy()</code></h4>

<p>Full copy, optionally on disk.
</p>


<h5>Usage</h5>

<div class="r"><pre>AnnDataR6$copy(filename = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>filename</code></dt><dd><p>Path to filename (default: <code>NULL</code>).</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
ad &lt;- AnnData(
  X = matrix(c(0, 1, 2, 3), nrow = 2)
)
ad$copy()
ad$copy("file.h5ad")
}
</pre>
</div>


<hr>
<a id="method-AnnDataR6-rename_categories"></a>



<h4>Method <code>rename_categories()</code></h4>

<p>Rename categories of annotation <code>key</code> in <code>obs</code>, <code>var</code>, and <code>uns</code>.
Only supports passing a list/array-like <code>categories</code> argument.
Besides calling <code style="white-space: pre;">&#8288;self.obs[key].cat.categories = categories&#8288;</code> –
similar for <code>var</code> - this also renames categories in unstructured
annotation that uses the categorical annotation <code>key</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>AnnDataR6$rename_categories(key, categories)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>key</code></dt><dd><p>Key for observations or variables annotation.</p>
</dd>
<dt><code>categories</code></dt><dd><p>New categories, the same number as the old categories.</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
ad &lt;- AnnData(
  X = matrix(c(0, 1, 2, 3), nrow = 2),
  obs = data.frame(group = c("a", "b"), row.names = c("s1", "s2"))
)
ad$rename_categories("group", c(a = "A", b = "B")) # ??
}
</pre>
</div>


<hr>
<a id="method-AnnDataR6-strings_to_categoricals"></a>



<h4>Method <code>strings_to_categoricals()</code></h4>

<p>Transform string annotations to categoricals.
</p>
<p>Only affects string annotations that lead to less categories than the total number of observations.
</p>


<h5>Usage</h5>

<div class="r"><pre>AnnDataR6$strings_to_categoricals(df = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>df</code></dt><dd><p>If <code>df</code> is <code>NULL</code>, modifies both <code>obs</code> and <code>var</code>, otherwise modifies <code>df</code> inplace.</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
ad &lt;- AnnData(
  X = matrix(c(0, 1, 2, 3), nrow = 2),
  obs = data.frame(group = c("a", "b"), row.names = c("s1", "s2")),
  var = data.frame(type = c(1L, 2L), row.names = c("var1", "var2")),
)
ad$strings_to_categoricals() # ??
}
</pre>
</div>


<hr>
<a id="method-AnnDataR6-to_df"></a>



<h4>Method <code>to_df()</code></h4>

<p>Generate shallow data frame.
</p>
<p>The data matrix <code>X</code> is returned as data frame, where <code>obs_names</code> are the rownames, and <code>var_names</code> the columns names.
</p>
<p>No annotations are maintained in the returned object.
</p>
<p>The data matrix is densified in case it is sparse.
</p>


<h5>Usage</h5>

<div class="r"><pre>AnnDataR6$to_df(layer = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>layer</code></dt><dd><p>Key for layers</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
ad &lt;- AnnData(
  X = matrix(c(0, 1, 2, 3), nrow = 2),
  obs = data.frame(group = c("a", "b"), row.names = c("s1", "s2")),
  var = data.frame(type = c(1L, 2L), row.names = c("var1", "var2")),
  layers = list(
    spliced = matrix(c(4, 5, 6, 7), nrow = 2),
    unspliced = matrix(c(8, 9, 10, 11), nrow = 2)
  )
)

ad$to_df()
ad$to_df("unspliced")
}
</pre>
</div>


<hr>
<a id="method-AnnDataR6-transpose"></a>



<h4>Method <code>transpose()</code></h4>

<p>transpose Transpose whole object.
</p>
<p>Data matrix is transposed, observations and variables are interchanged.
</p>
<p>Ignores <code>.raw</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>AnnDataR6$transpose()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
ad &lt;- AnnData(
  X = matrix(c(0, 1, 2, 3), nrow = 2),
  obs = data.frame(group = c("a", "b"), row.names = c("s1", "s2")),
  var = data.frame(type = c(1L, 2L), row.names = c("var1", "var2"))
)

ad$transpose()
}
</pre>
</div>


<hr>
<a id="method-AnnDataR6-write_csvs"></a>



<h4>Method <code>write_csvs()</code></h4>

<p>Write annotation to .csv files.
</p>
<p>It is not possible to recover the full AnnData from these files. Use <code><a href="#topic+write_h5ad">write_h5ad()</a></code> for this.
</p>


<h5>Usage</h5>

<div class="r"><pre>AnnDataR6$write_csvs(dirname, skip_data = TRUE, sep = ",")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dirname</code></dt><dd><p>Name of the directory to which to export.</p>
</dd>
<dt><code>skip_data</code></dt><dd><p>Skip the data matrix <code>X</code>.</p>
</dd>
<dt><code>sep</code></dt><dd><p>Separator for the data</p>
</dd>
<dt><code>anndata</code></dt><dd><p>An <code><a href="#topic+AnnData">AnnData()</a></code> object</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
ad &lt;- AnnData(
  X = matrix(c(0, 1, 2, 3), nrow = 2),
  obs = data.frame(group = c("a", "b"), row.names = c("s1", "s2")),
  var = data.frame(type = c(1L, 2L), row.names = c("var1", "var2")),
  varm = list(
    ones = matrix(rep(1L, 10), nrow = 2),
    rand = matrix(rnorm(6), nrow = 2),
    zeros = matrix(rep(0L, 10), nrow = 2)
  ),
  uns = list(a = 1, b = 2, c = list(c.a = 3, c.b = 4))
)

ad$to_write_csvs("output")

unlink("output", recursive = TRUE)
}
</pre>
</div>


<hr>
<a id="method-AnnDataR6-write_h5ad"></a>



<h4>Method <code>write_h5ad()</code></h4>

<p>Write .h5ad-formatted hdf5 file.
</p>
<p>Generally, if you have sparse data that are stored as a dense matrix, you can
dramatically improve performance and reduce disk space by converting to a csr_matrix:
</p>


<h5>Usage</h5>

<div class="r"><pre>AnnDataR6$write_h5ad(
  filename,
  compression = NULL,
  compression_opts = NULL,
  as_dense = list()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>filename</code></dt><dd><p>Filename of data file. Defaults to backing file.</p>
</dd>
<dt><code>compression</code></dt><dd><p>See the h5py <a href="http://docs.h5py.org/en/latest/high/dataset.html#dataset-compression">filter pipeline</a>.
Options are <code>"gzip"</code>, <code>"lzf"</code> or <code>NULL</code>.</p>
</dd>
<dt><code>compression_opts</code></dt><dd><p>See the h5py <a href="http://docs.h5py.org/en/latest/high/dataset.html#dataset-compression">filter pipeline</a>.</p>
</dd>
<dt><code>as_dense</code></dt><dd><p>Sparse in AnnData object to write as dense. Currently only supports <code>"X"</code> and <code>"raw/X"</code>.</p>
</dd>
<dt><code>anndata</code></dt><dd><p>An <code><a href="#topic+AnnData">AnnData()</a></code> object</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
ad &lt;- AnnData(
  X = matrix(c(0, 1, 2, 3), nrow = 2),
  obs = data.frame(group = c("a", "b"), row.names = c("s1", "s2")),
  var = data.frame(type = c(1L, 2L), row.names = c("var1", "var2")),
  varm = list(
    ones = matrix(rep(1L, 10), nrow = 2),
    rand = matrix(rnorm(6), nrow = 2),
    zeros = matrix(rep(0L, 10), nrow = 2)
  ),
  uns = list(a = 1, b = 2, c = list(c.a = 3, c.b = 4))
)

ad$write_h5ad("output.h5ad")

file.remove("output.h5ad")
}
</pre>
</div>


<hr>
<a id="method-AnnDataR6-write_loom"></a>



<h4>Method <code>write_loom()</code></h4>

<p>Write .loom-formatted hdf5 file.
</p>


<h5>Usage</h5>

<div class="r"><pre>AnnDataR6$write_loom(filename, write_obsm_varm = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>filename</code></dt><dd><p>The filename.</p>
</dd>
<dt><code>write_obsm_varm</code></dt><dd><p>Whether or not to also write the varm and obsm.</p>
</dd>
<dt><code>anndata</code></dt><dd><p>An <code><a href="#topic+AnnData">AnnData()</a></code> object</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
ad &lt;- AnnData(
  X = matrix(c(0, 1, 2, 3), nrow = 2),
  obs = data.frame(group = c("a", "b"), row.names = c("s1", "s2")),
  var = data.frame(type = c(1L, 2L), row.names = c("var1", "var2")),
  varm = list(
    ones = matrix(rep(1L, 10), nrow = 2),
    rand = matrix(rnorm(6), nrow = 2),
    zeros = matrix(rep(0L, 10), nrow = 2)
  ),
  uns = list(a = 1, b = 2, c = list(c.a = 3, c.b = 4))
)

ad$write_loom("output.loom")

file.remove("output.loom")
}
</pre>
</div>


<hr>
<a id="method-AnnDataR6-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print AnnData object
</p>


<h5>Usage</h5>

<div class="r"><pre>AnnDataR6$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>optional arguments to print method.</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
ad &lt;- AnnData(
  X = matrix(c(0, 1, 2, 3), nrow = 2),
  obs = data.frame(group = c("a", "b"), row.names = c("s1", "s2")),
  var = data.frame(type = c(1L, 2L), row.names = c("var1", "var2")),
  layers = list(
    spliced = matrix(c(4, 5, 6, 7), nrow = 2),
    unspliced = matrix(c(8, 9, 10, 11), nrow = 2)
  ),
  obsm = list(
    ones = matrix(rep(1L, 10), nrow = 2),
    rand = matrix(rnorm(6), nrow = 2),
    zeros = matrix(rep(0L, 10), nrow = 2)
  ),
  varm = list(
    ones = matrix(rep(1L, 10), nrow = 2),
    rand = matrix(rnorm(6), nrow = 2),
    zeros = matrix(rep(0L, 10), nrow = 2)
  ),
  uns = list(a = 1, b = 2, c = list(c.a = 3, c.b = 4))
)

ad$print()
print(ad)
}
</pre>
</div>


<hr>
<a id="method-AnnDataR6-.set_py_object"></a>



<h4>Method <code>.set_py_object()</code></h4>

<p>Set internal Python object
</p>


<h5>Usage</h5>

<div class="r"><pre>AnnDataR6$.set_py_object(obj)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>obj</code></dt><dd><p>A python anndata object</p>
</dd>
</dl>

</div>


<hr>
<a id="method-AnnDataR6-.get_py_object"></a>



<h4>Method <code>.get_py_object()</code></h4>

<p>Get internal Python object
</p>


<h5>Usage</h5>

<div class="r"><pre>AnnDataR6$.get_py_object()</pre></div>




<h3>See Also</h3>

<p><code><a href="#topic+read_h5ad">read_h5ad()</a></code> <code><a href="#topic+read_csv">read_csv()</a></code> <code><a href="#topic+read_excel">read_excel()</a></code> <code><a href="#topic+read_hdf">read_hdf()</a></code> <code><a href="#topic+read_loom">read_loom()</a></code> <code><a href="#topic+read_mtx">read_mtx()</a></code> <code><a href="#topic+read_text">read_text()</a></code> <code><a href="#topic+read_umi_tools">read_umi_tools()</a></code> <code><a href="#topic+write_h5ad">write_h5ad()</a></code> <code><a href="#topic+write_csvs">write_csvs()</a></code> <code><a href="#topic+write_loom">write_loom()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ad &lt;- AnnData(
  X = matrix(c(0, 1, 2, 3), nrow = 2),
  obs = data.frame(group = c("a", "b"), row.names = c("s1", "s2")),
  var = data.frame(type = c(1L, 2L), row.names = c("var1", "var2")),
  layers = list(
    spliced = matrix(c(4, 5, 6, 7), nrow = 2),
    unspliced = matrix(c(8, 9, 10, 11), nrow = 2)
  ),
  obsm = list(
    ones = matrix(rep(1L, 10), nrow = 2),
    rand = matrix(rnorm(6), nrow = 2),
    zeros = matrix(rep(0L, 10), nrow = 2)
  ),
  varm = list(
    ones = matrix(rep(1L, 10), nrow = 2),
    rand = matrix(rnorm(6), nrow = 2),
    zeros = matrix(rep(0L, 10), nrow = 2)
  ),
  uns = list(a = 1, b = 2, c = list(c.a = 3, c.b = 4))
)

value &lt;- matrix(c(1,2,3,4), nrow = 2)
ad$X &lt;- value
ad$X

ad$layers
ad$layers["spliced"]
ad$layers["test"] &lt;- value
ad$layers

ad$to_df()
ad$uns

as.matrix(ad)
as.matrix(ad, layer = "unspliced")
dim(ad)
rownames(ad)
colnames(ad)

## End(Not run)

## ------------------------------------------------
## Method `AnnDataR6$new`
## ------------------------------------------------

## Not run: 
# use AnnData() instead of AnnDataR6$new()
ad &lt;- AnnData(
  X = matrix(c(0, 1, 2, 3), nrow = 2),
  obs = data.frame(group = c("a", "b"), row.names = c("s1", "s2")),
  var = data.frame(type = c(1L, 2L), row.names = c("var1", "var2"))
)

## End(Not run)

## ------------------------------------------------
## Method `AnnDataR6$obs_keys`
## ------------------------------------------------

## Not run: 
ad &lt;- AnnData(
  X = matrix(c(0, 1, 2, 3), nrow = 2),
  obs = data.frame(group = c("a", "b"), row.names = c("s1", "s2"))
)
ad$obs_keys()

## End(Not run)

## ------------------------------------------------
## Method `AnnDataR6$obs_names_make_unique`
## ------------------------------------------------

## Not run: 
ad &lt;- AnnData(
  X = matrix(rep(1, 6), nrow = 3),
  obs = data.frame(field = c(1, 2, 3))
)
ad$obs_names &lt;- c("a", "a", "b")
ad$obs_names_make_unique()
ad$obs_names

## End(Not run)

## ------------------------------------------------
## Method `AnnDataR6$obsm_keys`
## ------------------------------------------------

## Not run: 
ad &lt;- AnnData(
  X = matrix(c(0, 1, 2, 3), nrow = 2),
  obs = data.frame(group = c("a", "b"), row.names = c("s1", "s2")),
  obsm = list(
    ones = matrix(rep(1L, 10), nrow = 2),
    rand = matrix(rnorm(6), nrow = 2),
    zeros = matrix(rep(0L, 10), nrow = 2)
  )
)
ad$obs_keys()

## End(Not run)

## ------------------------------------------------
## Method `AnnDataR6$var_keys`
## ------------------------------------------------

## Not run: 
ad &lt;- AnnData(
  X = matrix(c(0, 1, 2, 3), nrow = 2),
  var = data.frame(type = c(1L, 2L), row.names = c("var1", "var2"))
)
ad$var_keys()

## End(Not run)

## ------------------------------------------------
## Method `AnnDataR6$var_names_make_unique`
## ------------------------------------------------

## Not run: 
ad &lt;- AnnData(
  X = matrix(rep(1, 6), nrow = 2),
  var = data.frame(field = c(1, 2, 3))
)
ad$var_names &lt;- c("a", "a", "b")
ad$var_names_make_unique()
ad$var_names

## End(Not run)

## ------------------------------------------------
## Method `AnnDataR6$varm_keys`
## ------------------------------------------------

## Not run: 
ad &lt;- AnnData(
  X = matrix(c(0, 1, 2, 3), nrow = 2),
  var = data.frame(type = c(1L, 2L), row.names = c("var1", "var2")),
  varm = list(
    ones = matrix(rep(1L, 10), nrow = 2),
    rand = matrix(rnorm(6), nrow = 2),
    zeros = matrix(rep(0L, 10), nrow = 2)
  )
)
ad$varm_keys()

## End(Not run)

## ------------------------------------------------
## Method `AnnDataR6$uns_keys`
## ------------------------------------------------

## Not run: 
ad &lt;- AnnData(
  X = matrix(c(0, 1, 2, 3), nrow = 2),
  obs = data.frame(group = c("a", "b"), row.names = c("s1", "s2")),
  var = data.frame(type = c(1L, 2L), row.names = c("var1", "var2")),
  uns = list(a = 1, b = 2, c = list(c.a = 3, c.b = 4))
)

## End(Not run)

## ------------------------------------------------
## Method `AnnDataR6$chunk_X`
## ------------------------------------------------

## Not run: 
ad &lt;- AnnData(
  X = matrix(runif(10000), nrow = 50)
)

ad$chunk_X(select = 10L) # 10 random samples
ad$chunk_X(select = 1:3) # first 3 samples

## End(Not run)

## ------------------------------------------------
## Method `AnnDataR6$chunked_X`
## ------------------------------------------------

## Not run: 
ad &lt;- AnnData(
  X = matrix(runif(10000), nrow = 50)
)
ad$chunked_X(10)

## End(Not run)

## ------------------------------------------------
## Method `AnnDataR6$copy`
## ------------------------------------------------

## Not run: 
ad &lt;- AnnData(
  X = matrix(c(0, 1, 2, 3), nrow = 2)
)
ad$copy()
ad$copy("file.h5ad")

## End(Not run)

## ------------------------------------------------
## Method `AnnDataR6$rename_categories`
## ------------------------------------------------

## Not run: 
ad &lt;- AnnData(
  X = matrix(c(0, 1, 2, 3), nrow = 2),
  obs = data.frame(group = c("a", "b"), row.names = c("s1", "s2"))
)
ad$rename_categories("group", c(a = "A", b = "B")) # ??

## End(Not run)

## ------------------------------------------------
## Method `AnnDataR6$strings_to_categoricals`
## ------------------------------------------------

## Not run: 
ad &lt;- AnnData(
  X = matrix(c(0, 1, 2, 3), nrow = 2),
  obs = data.frame(group = c("a", "b"), row.names = c("s1", "s2")),
  var = data.frame(type = c(1L, 2L), row.names = c("var1", "var2")),
)
ad$strings_to_categoricals() # ??

## End(Not run)

## ------------------------------------------------
## Method `AnnDataR6$to_df`
## ------------------------------------------------

## Not run: 
ad &lt;- AnnData(
  X = matrix(c(0, 1, 2, 3), nrow = 2),
  obs = data.frame(group = c("a", "b"), row.names = c("s1", "s2")),
  var = data.frame(type = c(1L, 2L), row.names = c("var1", "var2")),
  layers = list(
    spliced = matrix(c(4, 5, 6, 7), nrow = 2),
    unspliced = matrix(c(8, 9, 10, 11), nrow = 2)
  )
)

ad$to_df()
ad$to_df("unspliced")

## End(Not run)

## ------------------------------------------------
## Method `AnnDataR6$transpose`
## ------------------------------------------------

## Not run: 
ad &lt;- AnnData(
  X = matrix(c(0, 1, 2, 3), nrow = 2),
  obs = data.frame(group = c("a", "b"), row.names = c("s1", "s2")),
  var = data.frame(type = c(1L, 2L), row.names = c("var1", "var2"))
)

ad$transpose()

## End(Not run)

## ------------------------------------------------
## Method `AnnDataR6$write_csvs`
## ------------------------------------------------

## Not run: 
ad &lt;- AnnData(
  X = matrix(c(0, 1, 2, 3), nrow = 2),
  obs = data.frame(group = c("a", "b"), row.names = c("s1", "s2")),
  var = data.frame(type = c(1L, 2L), row.names = c("var1", "var2")),
  varm = list(
    ones = matrix(rep(1L, 10), nrow = 2),
    rand = matrix(rnorm(6), nrow = 2),
    zeros = matrix(rep(0L, 10), nrow = 2)
  ),
  uns = list(a = 1, b = 2, c = list(c.a = 3, c.b = 4))
)

ad$to_write_csvs("output")

unlink("output", recursive = TRUE)

## End(Not run)

## ------------------------------------------------
## Method `AnnDataR6$write_h5ad`
## ------------------------------------------------

## Not run: 
ad &lt;- AnnData(
  X = matrix(c(0, 1, 2, 3), nrow = 2),
  obs = data.frame(group = c("a", "b"), row.names = c("s1", "s2")),
  var = data.frame(type = c(1L, 2L), row.names = c("var1", "var2")),
  varm = list(
    ones = matrix(rep(1L, 10), nrow = 2),
    rand = matrix(rnorm(6), nrow = 2),
    zeros = matrix(rep(0L, 10), nrow = 2)
  ),
  uns = list(a = 1, b = 2, c = list(c.a = 3, c.b = 4))
)

ad$write_h5ad("output.h5ad")

file.remove("output.h5ad")

## End(Not run)

## ------------------------------------------------
## Method `AnnDataR6$write_loom`
## ------------------------------------------------

## Not run: 
ad &lt;- AnnData(
  X = matrix(c(0, 1, 2, 3), nrow = 2),
  obs = data.frame(group = c("a", "b"), row.names = c("s1", "s2")),
  var = data.frame(type = c(1L, 2L), row.names = c("var1", "var2")),
  varm = list(
    ones = matrix(rep(1L, 10), nrow = 2),
    rand = matrix(rnorm(6), nrow = 2),
    zeros = matrix(rep(0L, 10), nrow = 2)
  ),
  uns = list(a = 1, b = 2, c = list(c.a = 3, c.b = 4))
)

ad$write_loom("output.loom")

file.remove("output.loom")

## End(Not run)

## ------------------------------------------------
## Method `AnnDataR6$print`
## ------------------------------------------------

## Not run: 
ad &lt;- AnnData(
  X = matrix(c(0, 1, 2, 3), nrow = 2),
  obs = data.frame(group = c("a", "b"), row.names = c("s1", "s2")),
  var = data.frame(type = c(1L, 2L), row.names = c("var1", "var2")),
  layers = list(
    spliced = matrix(c(4, 5, 6, 7), nrow = 2),
    unspliced = matrix(c(8, 9, 10, 11), nrow = 2)
  ),
  obsm = list(
    ones = matrix(rep(1L, 10), nrow = 2),
    rand = matrix(rnorm(6), nrow = 2),
    zeros = matrix(rep(0L, 10), nrow = 2)
  ),
  varm = list(
    ones = matrix(rep(1L, 10), nrow = 2),
    rand = matrix(rnorm(6), nrow = 2),
    zeros = matrix(rep(0L, 10), nrow = 2)
  ),
  uns = list(a = 1, b = 2, c = list(c.a = 3, c.b = 4))
)

ad$print()
print(ad)

## End(Not run)
</code></pre>

<hr>
<h2 id='concat'>concat</h2><span id='topic+concat'></span>

<h3>Description</h3>

<p>Concatenates AnnData objects along an axis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>concat(
  adatas,
  axis = 0L,
  join = "inner",
  merge = NULL,
  uns_merge = NULL,
  label = NULL,
  keys = NULL,
  index_unique = NULL,
  fill_value = NULL,
  pairwise = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="concat_+3A_adatas">adatas</code></td>
<td>
<p>The objects to be concatenated. If a Mapping is passed, keys are used for the <code>keys</code> argument and values are concatenated.</p>
</td></tr>
<tr><td><code id="concat_+3A_axis">axis</code></td>
<td>
<p>Which axis to concatenate along.</p>
</td></tr>
<tr><td><code id="concat_+3A_join">join</code></td>
<td>
<p>How to align values when concatenating. If &quot;outer&quot;, the union of the other axis is taken. If &quot;inner&quot;, the intersection. See <code>concatenation</code> for more.</p>
</td></tr>
<tr><td><code id="concat_+3A_merge">merge</code></td>
<td>
<p>How elements not aligned to the axis being concatenated along are selected. Currently implemented strategies include: * <code>NULL</code>: No elements are kept. * <code>"same"</code>: Elements that are the same in each of the objects. * <code>"unique"</code>: Elements for which there is only one possible value. * <code>"first"</code>: The first element seen at each from each position. * <code>"only"</code>: Elements that show up in only one of the objects.</p>
</td></tr>
<tr><td><code id="concat_+3A_uns_merge">uns_merge</code></td>
<td>
<p>How the elements of <code>.uns</code> are selected. Uses the same set of strategies as the <code>merge</code> argument, except applied recursively.</p>
</td></tr>
<tr><td><code id="concat_+3A_label">label</code></td>
<td>
<p>Column in axis annotation (i.e. <code>.obs</code> or <code>.var</code>) to place batch information in. If it's NULL, no column is added.</p>
</td></tr>
<tr><td><code id="concat_+3A_keys">keys</code></td>
<td>
<p>Names for each object being added. These values are used for column values for <code>label</code> or appended to the index if <code>index_unique</code> is not <code>NULL</code>. Defaults to incrementing integer labels.</p>
</td></tr>
<tr><td><code id="concat_+3A_index_unique">index_unique</code></td>
<td>
<p>Whether to make the index unique by using the keys. If provided, this is the delimeter between &quot;orig_idxindex_uniquekey&quot;. When <code>NULL</code>, the original indices are kept.</p>
</td></tr>
<tr><td><code id="concat_+3A_fill_value">fill_value</code></td>
<td>
<p>When <code>join="outer"</code>, this is the value that will be used to fill the introduced indices. By default, sparse arrays are padded with zeros, while dense arrays and DataFrames are padded with missing values.</p>
</td></tr>
<tr><td><code id="concat_+3A_pairwise">pairwise</code></td>
<td>
<p>Whether pairwise elements along the concatenated dimension should be included. This is FALSE by default, since the resulting arrays are often not meaningful.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the <code>concatenation</code> section in the docs for a more in-depth description.
</p>
<p>warning: This function is marked as experimental for the <code>0.7</code> release series, and will supercede the <code>AnnData$concatenate()</code> method in future releases.
</p>
<p>warning: If you use <code>join='outer'</code> this fills 0s for sparse data when variables are absent in a batch. Use this with care. Dense data is filled with <code>NaN</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Preparing example objects
a &lt;- AnnData(
  X = matrix(c(0, 1, 2, 3), nrow = 2, byrow = TRUE),
  obs = data.frame(group = c("a", "b"), row.names = c("s1", "s2")),
  var = data.frame(type = c(1L, 2L), row.names = c("var1", "var2")),
  varm = list(
    ones = matrix(rep(1L, 10), nrow = 2),
    rand = matrix(rnorm(6), nrow = 2),
    zeros = matrix(rep(0L, 10), nrow = 2)
  ),
  uns = list(
    a = 1,
    b = 2,
    c = list(
      c.a = 3,
      c.b = 4
    )
  )
)

b &lt;- AnnData(
  X = matrix(c(4, 5, 6, 7, 8, 9), nrow = 2, byrow = TRUE),
  obs = data.frame(group = c("b", "c"), row.names = c("s3", "s4")),
  var = data.frame(type = c(1L, 2L, 3L), row.names = c("var1", "var2", "var3")),
  varm = list(
    ones = matrix(rep(1L, 15), nrow = 3),
    rand = matrix(rnorm(15), nrow = 3)
  ),
  uns = list(
    a = 1,
    b = 3,
    c = list(
      c.a = 3
    )
  )
)

c &lt;- AnnData(
  X = matrix(c(10, 11, 12, 13), nrow = 2, byrow = TRUE),
  obs = data.frame(group = c("a", "b"), row.names = c("s1", "s2")),
  var = data.frame(type = c(3L, 4L), row.names = c("var3", "var4")),
  uns = list(
    a = 1,
    b = 4,
    c = list(
      c.a = 3,
      c.b = 4,
      c.c = 5
    )
  )
)

# Concatenating along different axes
concat(list(a, b))$to_df()
concat(list(a, c), axis = 1L)$to_df()

# Inner and outer joins
inner &lt;- concat(list(a, b))
inner
inner$obs_names
inner$var_names

outer &lt;- concat(list(a, b), join = "outer")
outer
outer$var_names
outer$to_df()

# Keeping track of source objects
concat(list(a = a, b = b), label = "batch")$obs
concat(list(a, b), label = "batch", keys = c("a", "b"))$obs
concat(list(a = a, b = b), index_unique = "-")$obs

# Combining values not aligned to axis of concatenation
concat(list(a, b), merge = "same")
concat(list(a, b), merge = "unique")
concat(list(a, b), merge = "first")
concat(list(a, b), merge = "only")

# The same merge strategies can be used for elements in .uns
concat(list(a, b, c), uns_merge = "same")$uns
concat(list(a, b, c), uns_merge = "unique")$uns
concat(list(a, b, c), uns_merge = "first")$uns
concat(list(a, b, c), uns_merge = "only")$uns

## End(Not run)
</code></pre>

<hr>
<h2 id='dimnames.AnnDataR6'>AnnData Helpers</h2><span id='topic+dimnames.AnnDataR6'></span><span id='topic+dimnames+3C-.AnnDataR6'></span><span id='topic+dim.AnnDataR6'></span><span id='topic+as.data.frame.AnnDataR6'></span><span id='topic+as.matrix.AnnDataR6'></span><span id='topic+r_to_py.AnnDataR6'></span><span id='topic+py_to_r.anndata._core.anndata.AnnData'></span><span id='topic++5B.AnnDataR6'></span><span id='topic+t.AnnDataR6'></span><span id='topic+py_to_r.anndata._core.sparse_dataset.SparseDataset'></span><span id='topic+py_to_r.h5py._hl.dataset.Dataset'></span>

<h3>Description</h3>

<p>AnnData Helpers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'AnnDataR6'
dimnames(x)

## S3 replacement method for class 'AnnDataR6'
dimnames(x) &lt;- value

## S3 method for class 'AnnDataR6'
dim(x)

## S3 method for class 'AnnDataR6'
as.data.frame(x, row.names = NULL, optional = FALSE, layer = NULL, ...)

## S3 method for class 'AnnDataR6'
as.matrix(x, layer = NULL, ...)

## S3 method for class 'AnnDataR6'
r_to_py(x, convert = FALSE)

## S3 method for class 'anndata._core.anndata.AnnData'
py_to_r(x)

## S3 method for class 'AnnDataR6'
x[oidx, vidx]

## S3 method for class 'AnnDataR6'
t(x)

## S3 method for class 'anndata._core.sparse_dataset.SparseDataset'
py_to_r(x)

## S3 method for class 'h5py._hl.dataset.Dataset'
py_to_r(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dimnames.AnnDataR6_+3A_x">x</code></td>
<td>
<p>An AnnData object.</p>
</td></tr>
<tr><td><code id="dimnames.AnnDataR6_+3A_value">value</code></td>
<td>
<p>a possible valie for <code>dimnames(ad)</code>. The dimnames of a AnnData
can be <code>NULL</code> (which is not stored) or a list of the same length as <code>dim(ad)</code>.
If a list, its components are either NULL or a character vector with
positive length of the appropriate dimension of <code>ad</code>.</p>
</td></tr>
<tr><td><code id="dimnames.AnnDataR6_+3A_row.names">row.names</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="dimnames.AnnDataR6_+3A_optional">optional</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="dimnames.AnnDataR6_+3A_layer">layer</code></td>
<td>
<p>An AnnData layer. If <code>NULL</code>, will use <code>ad$X</code>, otherwise <code>ad$layers[layer]</code>.</p>
</td></tr>
<tr><td><code id="dimnames.AnnDataR6_+3A_...">...</code></td>
<td>
<p>Parameters passed to the underlying function.</p>
</td></tr>
<tr><td><code id="dimnames.AnnDataR6_+3A_convert">convert</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="dimnames.AnnDataR6_+3A_oidx">oidx</code></td>
<td>
<p>Observation indices</p>
</td></tr>
<tr><td><code id="dimnames.AnnDataR6_+3A_vidx">vidx</code></td>
<td>
<p>Variable indices</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ad &lt;- AnnData(
  X = matrix(c(0, 1, 2, 3, 4, 5), nrow = 2),
  obs = data.frame(group = c("a", "b"), row.names = c("s1", "s2")),
  var = data.frame(type = c(1L, 2L, 3L), row.names = c("var1", "var2", "var3")),
  layers = list(
    spliced = matrix(c(4, 5, 6, 7, 8, 9), nrow = 2),
    unspliced = matrix(c(8, 9, 10, 11, 12, 13), nrow = 2)
  ),
  obsm = list(
    ones = matrix(rep(1L, 10), nrow = 2),
    rand = matrix(rnorm(6), nrow = 2),
    zeros = matrix(rep(0L, 10), nrow = 2)
  ),
  varm = list(
    ones = matrix(rep(1L, 12), nrow = 3),
    rand = matrix(rnorm(6), nrow = 3),
    zeros = matrix(rep(0L, 12), nrow = 3)
  ),
  uns = list(a = 1, b = 2, c = list(c.a = 3, c.b = 4))
)

dimnames(ad)
dim(ad)
as.data.frame(ad)
as.data.frame(ad, layer = "unspliced")
as.matrix(ad)
as.matrix(ad, layer = "unspliced")
ad[2,,drop=FALSE]
ad[,-1]
ad[,c("var1", "var2")]

## End(Not run)
</code></pre>

<hr>
<h2 id='dimnames.RawR6'>Raw Helpers</h2><span id='topic+dimnames.RawR6'></span><span id='topic+dim.RawR6'></span><span id='topic+as.matrix.RawR6'></span><span id='topic+r_to_py.RawR6'></span><span id='topic+py_to_r.anndata._core.raw.Raw'></span><span id='topic++5B.RawR6'></span>

<h3>Description</h3>

<p>Raw Helpers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'RawR6'
dimnames(x)

## S3 method for class 'RawR6'
dim(x)

## S3 method for class 'RawR6'
as.matrix(x, ...)

## S3 method for class 'RawR6'
r_to_py(x, convert = FALSE)

## S3 method for class 'anndata._core.raw.Raw'
py_to_r(x)

## S3 method for class 'RawR6'
x[...]
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dimnames.RawR6_+3A_x">x</code></td>
<td>
<p>An AnnData object.</p>
</td></tr>
<tr><td><code id="dimnames.RawR6_+3A_...">...</code></td>
<td>
<p>Parameters passed to the underlying function.</p>
</td></tr>
<tr><td><code id="dimnames.RawR6_+3A_convert">convert</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ad &lt;- AnnData(
  X = matrix(c(0, 1, 2, 3, 4, 5), nrow = 2),
  obs = data.frame(group = c("a", "b"), row.names = c("s1", "s2")),
  var = data.frame(type = c(1L, 2L, 3L), row.names = c("var1", "var2", "var3")),
  layers = list(
    spliced = matrix(c(4, 5, 6, 7, 8, 9), nrow = 2),
    unspliced = matrix(c(8, 9, 10, 11, 12, 13), nrow = 2)
  ),
  obsm = list(
    ones = matrix(rep(1L, 10), nrow = 2),
    rand = matrix(rnorm(6), nrow = 2),
    zeros = matrix(rep(0L, 10), nrow = 2)
  ),
  varm = list(
    ones = matrix(rep(1L, 12), nrow = 3),
    rand = matrix(rnorm(6), nrow = 3),
    zeros = matrix(rep(0L, 12), nrow = 3)
  ),
  uns = list(a = 1, b = 2, c = list(c.a = 3, c.b = 4))
)
ad$raw &lt;- ad

dimnames(ad$raw)
dim(ad$raw)
as.matrix(ad$raw)
ad$raw[2,,drop=FALSE]
ad$raw[,-1]
ad$raw[,c("var1", "var2")]

## End(Not run)
</code></pre>

<hr>
<h2 id='install_anndata'>Install anndata</h2><span id='topic+install_anndata'></span>

<h3>Description</h3>

<p>Needs to be run after installing the anndata R package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>install_anndata(method = "auto", conda = "auto")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="install_anndata_+3A_method">method</code></td>
<td>
<p>Installation method. By default, &quot;auto&quot; automatically finds a
method that will work in the local environment. Change the default to force
a specific installation method. Note that the &quot;virtualenv&quot; method is not
available on Windows.</p>
</td></tr>
<tr><td><code id="install_anndata_+3A_conda">conda</code></td>
<td>
<p>The path to a <code>conda</code> executable. Use <code>"auto"</code> to allow
<code>reticulate</code> to automatically find an appropriate <code>conda</code> binary.
See <strong>Finding Conda</strong> and <code><a href="reticulate.html#topic+conda_binary">conda_binary()</a></code> for more details.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
reticulate::conda_install()
install_anndata()

## End(Not run)
</code></pre>

<hr>
<h2 id='Layers'>Create a Layers object</h2><span id='topic+Layers'></span><span id='topic+LayersR6'></span>

<h3>Description</h3>

<p>Create a Layers object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Layers(parent, vals = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Layers_+3A_parent">parent</code></td>
<td>
<p>An AnnData object.</p>
</td></tr>
<tr><td><code id="Layers_+3A_vals">vals</code></td>
<td>
<p>A named list of matrices with the same dimensions as <code>parent</code>.</p>
</td></tr>
</table>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>parent</code></dt><dd><p>Reference to parent AnnData view</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-LayersR6-new"><code>LayersR6$new()</code></a>
</p>
</li>
<li> <p><a href="#method-LayersR6-print"><code>LayersR6$print()</code></a>
</p>
</li>
<li> <p><a href="#method-LayersR6-get"><code>LayersR6$get()</code></a>
</p>
</li>
<li> <p><a href="#method-LayersR6-set"><code>LayersR6$set()</code></a>
</p>
</li>
<li> <p><a href="#method-LayersR6-del"><code>LayersR6$del()</code></a>
</p>
</li>
<li> <p><a href="#method-LayersR6-keys"><code>LayersR6$keys()</code></a>
</p>
</li>
<li> <p><a href="#method-LayersR6-length"><code>LayersR6$length()</code></a>
</p>
</li>
<li> <p><a href="#method-LayersR6-.set_py_object"><code>LayersR6$.set_py_object()</code></a>
</p>
</li>
<li> <p><a href="#method-LayersR6-.get_py_object"><code>LayersR6$.get_py_object()</code></a>
</p>
</li></ul>


<hr>
<a id="method-LayersR6-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new Layers object
</p>


<h5>Usage</h5>

<div class="r"><pre>LayersR6$new(obj)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>obj</code></dt><dd><p>A Python Layers object</p>
</dd>
</dl>

</div>


<hr>
<a id="method-LayersR6-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print Layers object
</p>


<h5>Usage</h5>

<div class="r"><pre>LayersR6$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>optional arguments to print method.</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
ad &lt;- AnnData(
  X = matrix(c(0, 1, 2, 3), nrow = 2),
  obs = data.frame(group = c("a", "b"), row.names = c("s1", "s2")),
  var = data.frame(type = c(1L, 2L), row.names = c("var1", "var2")),
  layers = list(
    spliced = matrix(c(4, 5, 6, 7), nrow = 2),
    unspliced = matrix(c(8, 9, 10, 11), nrow = 2)
  )
)

print(ad$layers)
}
</pre>
</div>


<hr>
<a id="method-LayersR6-get"></a>



<h4>Method <code>get()</code></h4>

<p>Get a layer
</p>


<h5>Usage</h5>

<div class="r"><pre>LayersR6$get(name)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>Name of the layer</p>
</dd>
</dl>

</div>


<hr>
<a id="method-LayersR6-set"></a>



<h4>Method <code>set()</code></h4>

<p>Set a layer
</p>


<h5>Usage</h5>

<div class="r"><pre>LayersR6$set(name, value)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>Name of the layer</p>
</dd>
<dt><code>value</code></dt><dd><p>A matrix</p>
</dd>
</dl>

</div>


<hr>
<a id="method-LayersR6-del"></a>



<h4>Method <code>del()</code></h4>

<p>Delete a layer
</p>


<h5>Usage</h5>

<div class="r"><pre>LayersR6$del(name)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>name</code></dt><dd><p>Name of the layer</p>
</dd>
</dl>

</div>


<hr>
<a id="method-LayersR6-keys"></a>



<h4>Method <code>keys()</code></h4>

<p>Get the names of the layers
</p>


<h5>Usage</h5>

<div class="r"><pre>LayersR6$keys()</pre></div>


<hr>
<a id="method-LayersR6-length"></a>



<h4>Method <code>length()</code></h4>

<p>Get the number of layers
</p>


<h5>Usage</h5>

<div class="r"><pre>LayersR6$length()</pre></div>


<hr>
<a id="method-LayersR6-.set_py_object"></a>



<h4>Method <code>.set_py_object()</code></h4>

<p>Set internal Python object
</p>


<h5>Usage</h5>

<div class="r"><pre>LayersR6$.set_py_object(obj)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>obj</code></dt><dd><p>A Python layers object</p>
</dd>
</dl>

</div>


<hr>
<a id="method-LayersR6-.get_py_object"></a>



<h4>Method <code>.get_py_object()</code></h4>

<p>Get internal Python object
</p>


<h5>Usage</h5>

<div class="r"><pre>LayersR6$.get_py_object()</pre></div>




<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ad &lt;- AnnData(
  X = matrix(c(0, 1, 2, 3), nrow = 2),
  obs = data.frame(group = c("a", "b"), row.names = c("s1", "s2")),
  var = data.frame(type = c(1L, 2L), row.names = c("var1", "var2")),
  layers = list(
    spliced = matrix(c(4, 5, 6, 7), nrow = 2),
    unspliced = matrix(c(8, 9, 10, 11), nrow = 2)
  )
)
ad$layers["spliced"]
ad$layers["test"] &lt;- matrix(c(1, 3, 5, 7), nrow = 2)

length(ad$layers)
names(ad$layers)

## End(Not run)

## ------------------------------------------------
## Method `LayersR6$print`
## ------------------------------------------------

## Not run: 
ad &lt;- AnnData(
  X = matrix(c(0, 1, 2, 3), nrow = 2),
  obs = data.frame(group = c("a", "b"), row.names = c("s1", "s2")),
  var = data.frame(type = c(1L, 2L), row.names = c("var1", "var2")),
  layers = list(
    spliced = matrix(c(4, 5, 6, 7), nrow = 2),
    unspliced = matrix(c(8, 9, 10, 11), nrow = 2)
  )
)

print(ad$layers)

## End(Not run)
</code></pre>

<hr>
<h2 id='names.LayersR6'>Layers Helpers</h2><span id='topic+names.LayersR6'></span><span id='topic+length.LayersR6'></span><span id='topic+r_to_py.LayersR6'></span><span id='topic+py_to_r.anndata._core.aligned_mapping.LayersBase'></span><span id='topic++5B.LayersR6'></span><span id='topic++5B+3C-.LayersR6'></span><span id='topic++5B+5B.LayersR6'></span><span id='topic++5B+5B+3C-.LayersR6'></span>

<h3>Description</h3>

<p>Layers Helpers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'LayersR6'
names(x)

## S3 method for class 'LayersR6'
length(x)

## S3 method for class 'LayersR6'
r_to_py(x, convert = FALSE)

## S3 method for class 'anndata._core.aligned_mapping.LayersBase'
py_to_r(x)

## S3 method for class 'LayersR6'
x[name]

## S3 replacement method for class 'LayersR6'
x[name] &lt;- value

## S3 method for class 'LayersR6'
x[[name]]

## S3 replacement method for class 'LayersR6'
x[[name]] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="names.LayersR6_+3A_x">x</code></td>
<td>
<p>An AnnData object.</p>
</td></tr>
<tr><td><code id="names.LayersR6_+3A_convert">convert</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="names.LayersR6_+3A_name">name</code></td>
<td>
<p>Name of the layer.</p>
</td></tr>
<tr><td><code id="names.LayersR6_+3A_value">value</code></td>
<td>
<p>Replacement value.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ad &lt;- AnnData(
  X = matrix(c(0, 1, 2, 3, 4, 5), nrow = 2),
  obs = data.frame(group = c("a", "b"), row.names = c("s1", "s2")),
  var = data.frame(type = c(1L, 2L, 3L), row.names = c("var1", "var2", "var3")),
  layers = list(
    spliced = matrix(c(4, 5, 6, 7, 8, 9), nrow = 2),
    unspliced = matrix(c(8, 9, 10, 11, 12, 13), nrow = 2)
  )
)

ad$layers["spliced"]
ad$layers["test"] &lt;- matrix(c(1, 3, 5, 7), nrow = 2)

length(ad$layers)
names(ad$layers)

## End(Not run)
</code></pre>

<hr>
<h2 id='r-py-conversion'>Convert between Python and R objects</h2><span id='topic+r-py-conversion'></span><span id='topic++5B+5B+3C-.collections.abc.MutableMapping'></span><span id='topic++5B+5B.collections.abc.Mapping'></span><span id='topic++5B+3C-.collections.abc.MutableMapping'></span><span id='topic++5B.collections.abc.Mapping'></span><span id='topic+names.collections.abc.Mapping'></span><span id='topic+py_to_r.collections.abc.Set'></span><span id='topic+py_to_r.pandas.core.indexes.base.Index'></span><span id='topic+py_to_r.collections.abc.KeysView'></span><span id='topic+py_to_r.collections.abc.Mapping'></span>

<h3>Description</h3>

<p>Convert between Python and R objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 replacement method for class 'collections.abc.MutableMapping'
x[[name]] &lt;- value

## S3 method for class 'collections.abc.Mapping'
x[[name]]

## S3 replacement method for class 'collections.abc.MutableMapping'
x[name] &lt;- value

## S3 method for class 'collections.abc.Mapping'
x[name]

## S3 method for class 'collections.abc.Mapping'
names(x)

## S3 method for class 'collections.abc.Set'
py_to_r(x)

## S3 method for class 'pandas.core.indexes.base.Index'
py_to_r(x)

## S3 method for class 'collections.abc.KeysView'
py_to_r(x)

## S3 method for class 'collections.abc.Mapping'
py_to_r(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="r-py-conversion_+3A_x">x</code></td>
<td>
<p>A Python object.</p>
</td></tr>
<tr><td><code id="r-py-conversion_+3A_name">name</code></td>
<td>
<p>A name</p>
</td></tr>
<tr><td><code id="r-py-conversion_+3A_value">value</code></td>
<td>
<p>A value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <span class="rlang"><b>R</b></span> object, as converted from the Python object.
</p>

<hr>
<h2 id='Raw'>Create a Raw object</h2><span id='topic+Raw'></span><span id='topic+RawR6'></span>

<h3>Description</h3>

<p>Create a Raw object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Raw(adata, X = NULL, var = NULL, varm = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Raw_+3A_adata">adata</code></td>
<td>
<p>An AnnData object.</p>
</td></tr>
<tr><td><code id="Raw_+3A_x">X</code></td>
<td>
<p>A #observations × #variables data matrix.</p>
</td></tr>
<tr><td><code id="Raw_+3A_var">var</code></td>
<td>
<p>Key-indexed one-dimensional variables annotation of length #variables.</p>
</td></tr>
<tr><td><code id="Raw_+3A_varm">varm</code></td>
<td>
<p>Key-indexed multi-dimensional variables annotation of length #variables.</p>
</td></tr>
</table>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>X</code></dt><dd><p>Data matrix of shape <code>n_obs</code> × <code>n_vars</code>.</p>
</dd>
<dt><code>n_obs</code></dt><dd><p>Number of observations.</p>
</dd>
<dt><code>obs_names</code></dt><dd><p>Names of observations.</p>
</dd>
<dt><code>n_vars</code></dt><dd><p>Number of variables.</p>
</dd>
<dt><code>var</code></dt><dd><p>One-dimensional annotation of variables (data.frame).</p>
</dd>
<dt><code>var_names</code></dt><dd><p>Names of variables.</p>
</dd>
<dt><code>varm</code></dt><dd><p>Multi-dimensional annotation of variables (matrix).
</p>
<p>Stores for each key a two or higher-dimensional matrix with <code>n_var</code> rows.</p>
</dd>
<dt><code>shape</code></dt><dd><p>Shape of data matrix (<code>n_obs</code>, <code>n_vars</code>).</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-RawR6-new"><code>RawR6$new()</code></a>
</p>
</li>
<li> <p><a href="#method-RawR6-copy"><code>RawR6$copy()</code></a>
</p>
</li>
<li> <p><a href="#method-RawR6-to_adata"><code>RawR6$to_adata()</code></a>
</p>
</li>
<li> <p><a href="#method-RawR6-print"><code>RawR6$print()</code></a>
</p>
</li>
<li> <p><a href="#method-RawR6-.set_py_object"><code>RawR6$.set_py_object()</code></a>
</p>
</li>
<li> <p><a href="#method-RawR6-.get_py_object"><code>RawR6$.get_py_object()</code></a>
</p>
</li></ul>


<hr>
<a id="method-RawR6-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new Raw object
</p>


<h5>Usage</h5>

<div class="r"><pre>RawR6$new(obj)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>obj</code></dt><dd><p>A Python Raw object</p>
</dd>
</dl>

</div>


<hr>
<a id="method-RawR6-copy"></a>



<h4>Method <code>copy()</code></h4>

<p>Full copy, optionally on disk.
</p>


<h5>Usage</h5>

<div class="r"><pre>RawR6$copy()</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>filename</code></dt><dd><p>Path to filename (default: <code>NULL</code>).</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
ad &lt;- AnnData(
  X = matrix(c(0, 1, 2, 3), nrow = 2)
)
ad$copy()
ad$copy("file.h5ad")
}
</pre>
</div>


<hr>
<a id="method-RawR6-to_adata"></a>



<h4>Method <code>to_adata()</code></h4>

<p>Create a full AnnData object
</p>


<h5>Usage</h5>

<div class="r"><pre>RawR6$to_adata()</pre></div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
ad &lt;- AnnData(
  X = matrix(c(0, 1, 2, 3), nrow = 2),
  obs = data.frame(group = c("a", "b"), row.names = c("s1", "s2")),
  var = data.frame(type = c(1L, 2L), row.names = c("var1", "var2")),
  layers = list(
    spliced = matrix(c(4, 5, 6, 7), nrow = 2),
    unspliced = matrix(c(8, 9, 10, 11), nrow = 2)
  )
)
ad$raw &lt;- ad

ad$raw$to_adata()
}
</pre>
</div>


<hr>
<a id="method-RawR6-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print Raw object
</p>


<h5>Usage</h5>

<div class="r"><pre>RawR6$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>optional arguments to print method.</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
ad &lt;- AnnData(
  X = matrix(c(0, 1, 2, 3), nrow = 2),
  obs = data.frame(group = c("a", "b"), row.names = c("s1", "s2")),
  var = data.frame(type = c(1L, 2L), row.names = c("var1", "var2")),
  layers = list(
    spliced = matrix(c(4, 5, 6, 7), nrow = 2),
    unspliced = matrix(c(8, 9, 10, 11), nrow = 2)
  ),
  obsm = list(
    ones = matrix(rep(1L, 10), nrow = 2),
    rand = matrix(rnorm(6), nrow = 2),
    zeros = matrix(rep(0L, 10), nrow = 2)
  ),
  varm = list(
    ones = matrix(rep(1L, 10), nrow = 2),
    rand = matrix(rnorm(6), nrow = 2),
    zeros = matrix(rep(0L, 10), nrow = 2)
  ),
  uns = list(a = 1, b = 2, c = list(c.a = 3, c.b = 4))
)
ad$raw &lt;- ad

library(reticulate)
sc &lt;- import("scanpy")
sc$pp$normalize_per_cell(ad)

ad[]
ad$raw[]

ad$print()
print(ad)
}
</pre>
</div>


<hr>
<a id="method-RawR6-.set_py_object"></a>



<h4>Method <code>.set_py_object()</code></h4>

<p>Set internal Python object
</p>


<h5>Usage</h5>

<div class="r"><pre>RawR6$.set_py_object(obj)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>obj</code></dt><dd><p>A Python Raw object</p>
</dd>
</dl>

</div>


<hr>
<a id="method-RawR6-.get_py_object"></a>



<h4>Method <code>.get_py_object()</code></h4>

<p>Get internal Python object
</p>


<h5>Usage</h5>

<div class="r"><pre>RawR6$.get_py_object()</pre></div>




<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ad &lt;- AnnData(
  X = matrix(c(0, 1, 2, 3), nrow = 2),
  obs = data.frame(group = c("a", "b"), row.names = c("s1", "s2")),
  var = data.frame(type = c(1L, 2L), row.names = c("var1", "var2")),
  layers = list(
    spliced = matrix(c(4, 5, 6, 7), nrow = 2),
    unspliced = matrix(c(8, 9, 10, 11), nrow = 2)
  ),
  obsm = list(
    ones = matrix(rep(1L, 10), nrow = 2),
    rand = matrix(rnorm(6), nrow = 2),
    zeros = matrix(rep(0L, 10), nrow = 2)
  ),
  varm = list(
    ones = matrix(rep(1L, 10), nrow = 2),
    rand = matrix(rnorm(6), nrow = 2),
    zeros = matrix(rep(0L, 10), nrow = 2)
  ),
  uns = list(a = 1, b = 2, c = list(c.a = 3, c.b = 4))
)
ad$raw &lt;- ad

library(reticulate)
sc &lt;- import("scanpy")
sc$pp$normalize_per_cell(ad)

ad[]
ad$raw[]

## End(Not run)

## ------------------------------------------------
## Method `RawR6$copy`
## ------------------------------------------------

## Not run: 
ad &lt;- AnnData(
  X = matrix(c(0, 1, 2, 3), nrow = 2)
)
ad$copy()
ad$copy("file.h5ad")

## End(Not run)

## ------------------------------------------------
## Method `RawR6$to_adata`
## ------------------------------------------------

## Not run: 
ad &lt;- AnnData(
  X = matrix(c(0, 1, 2, 3), nrow = 2),
  obs = data.frame(group = c("a", "b"), row.names = c("s1", "s2")),
  var = data.frame(type = c(1L, 2L), row.names = c("var1", "var2")),
  layers = list(
    spliced = matrix(c(4, 5, 6, 7), nrow = 2),
    unspliced = matrix(c(8, 9, 10, 11), nrow = 2)
  )
)
ad$raw &lt;- ad

ad$raw$to_adata()

## End(Not run)

## ------------------------------------------------
## Method `RawR6$print`
## ------------------------------------------------

## Not run: 
ad &lt;- AnnData(
  X = matrix(c(0, 1, 2, 3), nrow = 2),
  obs = data.frame(group = c("a", "b"), row.names = c("s1", "s2")),
  var = data.frame(type = c(1L, 2L), row.names = c("var1", "var2")),
  layers = list(
    spliced = matrix(c(4, 5, 6, 7), nrow = 2),
    unspliced = matrix(c(8, 9, 10, 11), nrow = 2)
  ),
  obsm = list(
    ones = matrix(rep(1L, 10), nrow = 2),
    rand = matrix(rnorm(6), nrow = 2),
    zeros = matrix(rep(0L, 10), nrow = 2)
  ),
  varm = list(
    ones = matrix(rep(1L, 10), nrow = 2),
    rand = matrix(rnorm(6), nrow = 2),
    zeros = matrix(rep(0L, 10), nrow = 2)
  ),
  uns = list(a = 1, b = 2, c = list(c.a = 3, c.b = 4))
)
ad$raw &lt;- ad

library(reticulate)
sc &lt;- import("scanpy")
sc$pp$normalize_per_cell(ad)

ad[]
ad$raw[]

ad$print()
print(ad)

## End(Not run)
</code></pre>

<hr>
<h2 id='read_csv'>read_csv</h2><span id='topic+read_csv'></span>

<h3>Description</h3>

<p>Read <code>.csv</code> file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_csv(
  filename,
  delimiter = ",",
  first_column_names = NULL,
  dtype = "float32"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_csv_+3A_filename">filename</code></td>
<td>
<p>Data file.</p>
</td></tr>
<tr><td><code id="read_csv_+3A_delimiter">delimiter</code></td>
<td>
<p>Delimiter that separates data within text file. If <code>NULL</code>, will split at arbitrary number of white spaces, which is different from enforcing splitting at single white space <code>' '</code>.</p>
</td></tr>
<tr><td><code id="read_csv_+3A_first_column_names">first_column_names</code></td>
<td>
<p>Assume the first column stores row names.</p>
</td></tr>
<tr><td><code id="read_csv_+3A_dtype">dtype</code></td>
<td>
<p>Numpy data type.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Same as <code><a href="#topic+read_text">read_text()</a></code> but with default delimiter <code>','</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ad &lt;- read_csv("matrix.csv")

## End(Not run)
</code></pre>

<hr>
<h2 id='read_excel'>read_excel</h2><span id='topic+read_excel'></span>

<h3>Description</h3>

<p>Read <code>.xlsx</code> (Excel) file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_excel(filename, sheet, dtype = "float32")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_excel_+3A_filename">filename</code></td>
<td>
<p>File name to read from.</p>
</td></tr>
<tr><td><code id="read_excel_+3A_sheet">sheet</code></td>
<td>
<p>Name of sheet in Excel file.</p>
</td></tr>
<tr><td><code id="read_excel_+3A_dtype">dtype</code></td>
<td>
<p>Numpy data type.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Assumes that the first columns stores the row names and the first row the
column names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ad &lt;- read_excel("spreadsheet.xls")

## End(Not run)
</code></pre>

<hr>
<h2 id='read_h5ad'>read_h5ad</h2><span id='topic+read_h5ad'></span>

<h3>Description</h3>

<p>Read <code>.h5ad</code>-formatted hdf5 file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_h5ad(filename, backed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_h5ad_+3A_filename">filename</code></td>
<td>
<p>File name of data file.</p>
</td></tr>
<tr><td><code id="read_h5ad_+3A_backed">backed</code></td>
<td>
<p>If <code>'r'</code>, load <code>~anndata.AnnData</code> in <code>backed</code> mode instead of fully loading it into memory (<code>memory</code> mode). If you want to modify backed attributes of the AnnData object, you need to choose <code>'r+'</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ad &lt;- read_h5ad("example_formats/pbmc_1k_protein_v3_processed.h5ad")

## End(Not run)
</code></pre>

<hr>
<h2 id='read_hdf'>read_hdf</h2><span id='topic+read_hdf'></span>

<h3>Description</h3>

<p>Read <code>.h5</code> (hdf5) file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_hdf(filename, key)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_hdf_+3A_filename">filename</code></td>
<td>
<p>Filename of data file.</p>
</td></tr>
<tr><td><code id="read_hdf_+3A_key">key</code></td>
<td>
<p>Name of dataset in the file.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: Also looks for fields <code>row_names</code> and <code>col_names</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ad &lt;- read_hdf("file.h5")

## End(Not run)
</code></pre>

<hr>
<h2 id='read_loom'>read_loom</h2><span id='topic+read_loom'></span>

<h3>Description</h3>

<p>Read <code>.loom</code>-formatted hdf5 file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_loom(
  filename,
  sparse = TRUE,
  cleanup = FALSE,
  X_name = "spliced",
  obs_names = "CellID",
  obsm_names = NULL,
  var_names = "Gene",
  varm_names = NULL,
  dtype = "float32",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_loom_+3A_filename">filename</code></td>
<td>
<p>The filename.</p>
</td></tr>
<tr><td><code id="read_loom_+3A_sparse">sparse</code></td>
<td>
<p>Whether to read the data matrix as sparse.</p>
</td></tr>
<tr><td><code id="read_loom_+3A_cleanup">cleanup</code></td>
<td>
<p>Whether to collapse all obs/var fields that only store one unique value into <code>.uns['loom-.']</code>.</p>
</td></tr>
<tr><td><code id="read_loom_+3A_x_name">X_name</code></td>
<td>
<p>Loompy key with which the data matrix <code>AnnData.X</code> is initialized.</p>
</td></tr>
<tr><td><code id="read_loom_+3A_obs_names">obs_names</code></td>
<td>
<p>Loompy key where the observation/cell names are stored.</p>
</td></tr>
<tr><td><code id="read_loom_+3A_obsm_names">obsm_names</code></td>
<td>
<p>Loompy keys which will be constructed into observation matrices</p>
</td></tr>
<tr><td><code id="read_loom_+3A_var_names">var_names</code></td>
<td>
<p>Loompy key where the variable/gene names are stored.</p>
</td></tr>
<tr><td><code id="read_loom_+3A_varm_names">varm_names</code></td>
<td>
<p>Loompy keys which will be constructed into variable matrices</p>
</td></tr>
<tr><td><code id="read_loom_+3A_dtype">dtype</code></td>
<td>
<p>Numpy data type.</p>
</td></tr>
<tr><td><code id="read_loom_+3A_...">...</code></td>
<td>
<p>Arguments to loompy.connect</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This reads the whole file into memory. Beware that you have to explicitly state when you want to read the file as
sparse data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ad &lt;- read_loom("dataset.loom")

## End(Not run)
</code></pre>

<hr>
<h2 id='read_mtx'>read_mtx</h2><span id='topic+read_mtx'></span>

<h3>Description</h3>

<p>Read <code>.mtx</code> file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_mtx(filename, dtype = "float32")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_mtx_+3A_filename">filename</code></td>
<td>
<p>The filename.</p>
</td></tr>
<tr><td><code id="read_mtx_+3A_dtype">dtype</code></td>
<td>
<p>Numpy data type.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ad &lt;- read_mtx("matrix.mtx")

## End(Not run)
</code></pre>

<hr>
<h2 id='read_text'>read_text</h2><span id='topic+read_text'></span>

<h3>Description</h3>

<p>Read <code>.txt</code>, <code>.tab</code>, <code>.data</code> (text) file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_text(
  filename,
  delimiter = NULL,
  first_column_names = NULL,
  dtype = "float32"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_text_+3A_filename">filename</code></td>
<td>
<p>Data file, filename or stream.</p>
</td></tr>
<tr><td><code id="read_text_+3A_delimiter">delimiter</code></td>
<td>
<p>Delimiter that separates data within text file.
If <code>NULL</code>, will split at arbitrary number of white spaces, which is different
from enforcing splitting at single white space <code>' '</code>.</p>
</td></tr>
<tr><td><code id="read_text_+3A_first_column_names">first_column_names</code></td>
<td>
<p>Assume the first column stores row names.</p>
</td></tr>
<tr><td><code id="read_text_+3A_dtype">dtype</code></td>
<td>
<p>Numpy data type.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Same as <code><a href="#topic+read_csv">read_csv()</a></code> but with default delimiter <code>NULL</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ad &lt;- read_text("matrix.tab")

## End(Not run)
</code></pre>

<hr>
<h2 id='read_umi_tools'>read_umi_tools</h2><span id='topic+read_umi_tools'></span>

<h3>Description</h3>

<p>Read a gzipped condensed count matrix from umi_tools.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_umi_tools(filename, dtype = "float32")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_umi_tools_+3A_filename">filename</code></td>
<td>
<p>File name to read from.</p>
</td></tr>
<tr><td><code id="read_umi_tools_+3A_dtype">dtype</code></td>
<td>
<p>Numpy data type.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ad &lt;- read_umi_tools("...")

## End(Not run)
</code></pre>

<hr>
<h2 id='write_csvs'>Write annotation to .csv files.</h2><span id='topic+write_csvs'></span>

<h3>Description</h3>

<p>It is not possible to recover the full AnnData from these files. Use <code><a href="#topic+write_h5ad">write_h5ad()</a></code> for this.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_csvs(anndata, dirname, skip_data = TRUE, sep = ",")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write_csvs_+3A_anndata">anndata</code></td>
<td>
<p>An <code><a href="#topic+AnnData">AnnData()</a></code> object</p>
</td></tr>
<tr><td><code id="write_csvs_+3A_dirname">dirname</code></td>
<td>
<p>Name of the directory to which to export.</p>
</td></tr>
<tr><td><code id="write_csvs_+3A_skip_data">skip_data</code></td>
<td>
<p>Skip the data matrix <code>X</code>.</p>
</td></tr>
<tr><td><code id="write_csvs_+3A_sep">sep</code></td>
<td>
<p>Separator for the data</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ad &lt;- AnnData(
  X = matrix(c(0, 1, 2, 3), nrow = 2, byrow = TRUE),
  obs = data.frame(group = c("a", "b"), row.names = c("s1", "s2")),
  var = data.frame(type = c(1L, 2L), row.names = c("var1", "var2")),
  varm = list(
    ones = matrix(rep(1L, 10), nrow = 2),
    rand = matrix(rnorm(6), nrow = 2),
    zeros = matrix(rep(0L, 10), nrow = 2)
  ),
  uns = list(a = 1, b = 2, c = list(c.a = 3, c.b = 4))
)

write_csvs(ad, "output")

unlink("output", recursive = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='write_h5ad'>Write .h5ad-formatted hdf5 file.</h2><span id='topic+write_h5ad'></span>

<h3>Description</h3>

<p>Generally, if you have sparse data that are stored as a dense matrix, you can
dramatically improve performance and reduce disk space by converting to a csr_matrix:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_h5ad(
  anndata,
  filename,
  compression = NULL,
  compression_opts = NULL,
  as_dense = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write_h5ad_+3A_anndata">anndata</code></td>
<td>
<p>An <code><a href="#topic+AnnData">AnnData()</a></code> object</p>
</td></tr>
<tr><td><code id="write_h5ad_+3A_filename">filename</code></td>
<td>
<p>Filename of data file. Defaults to backing file.</p>
</td></tr>
<tr><td><code id="write_h5ad_+3A_compression">compression</code></td>
<td>
<p>See the h5py <a href="http://docs.h5py.org/en/latest/high/dataset.html#dataset-compression">filter pipeline</a>.
Options are <code>"gzip"</code>, <code>"lzf"</code> or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="write_h5ad_+3A_compression_opts">compression_opts</code></td>
<td>
<p>See the h5py <a href="http://docs.h5py.org/en/latest/high/dataset.html#dataset-compression">filter pipeline</a>.</p>
</td></tr>
<tr><td><code id="write_h5ad_+3A_as_dense">as_dense</code></td>
<td>
<p>Sparse in AnnData object to write as dense. Currently only supports <code>"X"</code> and <code>"raw/X"</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ad &lt;- AnnData(
  X = matrix(c(0, 1, 2, 3), nrow = 2, byrow = TRUE),
  obs = data.frame(group = c("a", "b"), row.names = c("s1", "s2")),
  var = data.frame(type = c(1L, 2L), row.names = c("var1", "var2")),
  varm = list(
    ones = matrix(rep(1L, 10), nrow = 2),
    rand = matrix(rnorm(6), nrow = 2),
    zeros = matrix(rep(0L, 10), nrow = 2)
  ),
  uns = list(a = 1, b = 2, c = list(c.a = 3, c.b = 4))
)

write_h5ad(ad, "output.h5ad")

file.remove("output.h5ad")

## End(Not run)
</code></pre>

<hr>
<h2 id='write_loom'>Write .loom-formatted hdf5 file.</h2><span id='topic+write_loom'></span>

<h3>Description</h3>

<p>Write .loom-formatted hdf5 file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_loom(anndata, filename, write_obsm_varm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write_loom_+3A_anndata">anndata</code></td>
<td>
<p>An <code><a href="#topic+AnnData">AnnData()</a></code> object</p>
</td></tr>
<tr><td><code id="write_loom_+3A_filename">filename</code></td>
<td>
<p>The filename.</p>
</td></tr>
<tr><td><code id="write_loom_+3A_write_obsm_varm">write_obsm_varm</code></td>
<td>
<p>Whether or not to also write the varm and obsm.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ad &lt;- AnnData(
  X = matrix(c(0, 1, 2, 3), nrow = 2, byrow = TRUE),
  obs = data.frame(group = c("a", "b"), row.names = c("s1", "s2")),
  var = data.frame(type = c(1L, 2L), row.names = c("var1", "var2")),
  varm = list(
    ones = matrix(rep(1L, 10), nrow = 2),
    rand = matrix(rnorm(6), nrow = 2),
    zeros = matrix(rep(0L, 10), nrow = 2)
  ),
  uns = list(a = 1, b = 2, c = list(c.a = 3, c.b = 4))
)

write_loom(ad, "output.loom")

file.remove("output.loom")

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
