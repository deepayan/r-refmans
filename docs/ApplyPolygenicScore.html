<!DOCTYPE html><html lang="en"><head><title>Help for package ApplyPolygenicScore</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ApplyPolygenicScore}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#apply.polygenic.score'><p>Apply polygenic score to VCF data</p></a></li>
<li><a href='#assess.pgs.vcf.allele.match'><p>Assess PGS allele match to VCF allele</p></a></li>
<li><a href='#check.pgs.weight.columns'><p>Check PGS weight file columns</p></a></li>
<li><a href='#combine.pgs.bed'><p>Combine PGS BED files</p></a></li>
<li><a href='#combine.vcf.with.pgs'><p>Combine VCF with PGS</p></a></li>
<li><a href='#convert.allele.frequency.to.dosage'><p>Convert allele frequency to mean dosage</p></a></li>
<li><a href='#convert.alleles.to.pgs.dosage'><p>Convert alleles to dosage</p></a></li>
<li><a href='#convert.pgs.to.bed'><p>Convert PGS data to BED format</p></a></li>
<li><a href='#create.pgs.density.plot'><p>Plot PGS Density</p></a></li>
<li><a href='#create.pgs.rank.plot'><p>Plot PGS Rank</p></a></li>
<li><a href='#create.pgs.with.continuous.phenotype.plot'><p>Plot PGS Scatterplots</p></a></li>
<li><a href='#flip.DNA.allele'><p>Flip DNA allele</p></a></li>
<li><a href='#format.chromosome.notation'><p>Format chromosome names</p></a></li>
<li><a href='#get.pgs.percentiles'><p>get.pgs.percentiles</p></a></li>
<li><a href='#import.pgs.weight.file'><p>Import PGS weight file</p></a></li>
<li><a href='#import.vcf'><p>Import VCF file</p></a></li>
<li><a href='#parse.pgs.input.header'><p>Parse PGS input file header</p></a></li>
<li><a href='#run.pgs.regression'><p>Run linear and logistic regression on a polygenic score and a set of phenotypes</p></a></li>
<li><a href='#write.apply.polygenic.score.output.to.file'><p>Write apply.polygenic.score output to file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Utilities for the Application of a Polygenic Score to a VCF</td>
</tr>
<tr>
<td>Version:</td>
<td>3.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Simple and transparent parsing of genotype/dosage data
    from an input Variant Call Format (VCF) file, matching of genotype
    coordinates to the component Single Nucleotide Polymorphisms (SNPs)
    of an existing polygenic score (PGS), and application of SNP weights
    to dosages for the calculation of a polygenic score for each individual
    in accordance with the additive weighted sum of dosages model. Methods
    are designed in reference to best practices described by
    Collister, Liu, and Clifton (2022) &lt;<a href="https://doi.org/10.3389%2Ffgene.2022.818574">doi:10.3389/fgene.2022.818574</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>vcfR, pROC, data.table, reshape2, BoutrosLab.plotting.general,
lattice</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-04 01:32:04 UTC; nzeltser</td>
</tr>
<tr>
<td>Author:</td>
<td>Paul Boutros [cre],
  Nicole Zeltser <a href="https://orcid.org/0000-0001-7246-2771"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Rachel Dang [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Paul Boutros &lt;PBoutros@mednet.ucla.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-05 15:50:15 UTC</td>
</tr>
</table>
<hr>
<h2 id='apply.polygenic.score'>Apply polygenic score to VCF data</h2><span id='topic+apply.polygenic.score'></span>

<h3>Description</h3>

<p>Apply a polygenic score to VCF data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply.polygenic.score(
  vcf.data,
  pgs.weight.data,
  phenotype.data = NULL,
  phenotype.analysis.columns = NULL,
  correct.strand.flips = TRUE,
  remove.ambiguous.allele.matches = FALSE,
  remove.mismatched.indels = FALSE,
  output.dir = NULL,
  file.prefix = NULL,
  missing.genotype.method = "mean.dosage",
  use.external.effect.allele.frequency = FALSE,
  n.percentiles = NULL,
  analysis.source.pgs = NULL,
  validate.inputs.only = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apply.polygenic.score_+3A_vcf.data">vcf.data</code></td>
<td>
<p>A data.frame containing VCF genotype data as formatted by <code>import.vcf()</code>.</p>
</td></tr>
<tr><td><code id="apply.polygenic.score_+3A_pgs.weight.data">pgs.weight.data</code></td>
<td>
<p>A data.frame containing PGS weight data as formatted by <code>import.pgs.weight.file()</code>.</p>
</td></tr>
<tr><td><code id="apply.polygenic.score_+3A_phenotype.data">phenotype.data</code></td>
<td>
<p>A data.frame containing phenotype data. Must have an Indiv column matching vcf.data. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="apply.polygenic.score_+3A_phenotype.analysis.columns">phenotype.analysis.columns</code></td>
<td>
<p>A character vector of phenotype columns from phenotype.data to analyze in a regression analsyis. Default is <code>NULL</code>.
Phenotype variables are automatically classified as continuous, binary, or neither based on data type and number of unique values. The calculated PGS is associated
with each phenotype variable using linear or logistic regression for continuous or binary phenotypes, respectively. See <code>run.pgs.regression</code> for more details.
If no phenotype.analysis.columns are provided, no regression analysis is performed.</p>
</td></tr>
<tr><td><code id="apply.polygenic.score_+3A_correct.strand.flips">correct.strand.flips</code></td>
<td>
<p>A logical indicating whether to check PGS weight data/VCF genotype data matches for strand flips and correct them. Default is <code>TRUE</code>.
The PGS catalog standard column <code>other_allele</code> in <code>pgs.weight.data</code> is required for this check.</p>
</td></tr>
<tr><td><code id="apply.polygenic.score_+3A_remove.ambiguous.allele.matches">remove.ambiguous.allele.matches</code></td>
<td>
<p>A logical indicating whether to remove PGS variants with ambiguous allele matches between PGS weight data and VCF genotype data. Default is <code>FALSE</code>.
The PGS catalog standard column <code>other_allele</code> in <code>pgs.weight.data</code> is required for this check.</p>
</td></tr>
<tr><td><code id="apply.polygenic.score_+3A_remove.mismatched.indels">remove.mismatched.indels</code></td>
<td>
<p>A logical indicating whether to remove indel variants that are mismatched between PGS weight data and VCF genotype data. Default is <code>FALSE</code>.
The PGS catalog standard column <code>other_allele</code> in <code>pgs.weight.data</code> is required for this check.</p>
</td></tr>
<tr><td><code id="apply.polygenic.score_+3A_output.dir">output.dir</code></td>
<td>
<p>A character string indicating the directory to write output files. Separate files are written for per-sample pgs results and optional regression results.
Files are tab-separate .txt files. Default is NULL in which case no files are written.</p>
</td></tr>
<tr><td><code id="apply.polygenic.score_+3A_file.prefix">file.prefix</code></td>
<td>
<p>A character string to prepend to the output file names. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="apply.polygenic.score_+3A_missing.genotype.method">missing.genotype.method</code></td>
<td>
<p>A character string indicating the method to handle missing genotypes. Options are &quot;mean.dosage&quot;, &quot;normalize&quot;, or &quot;none&quot;. Default is &quot;mean.dosage&quot;.</p>
</td></tr>
<tr><td><code id="apply.polygenic.score_+3A_use.external.effect.allele.frequency">use.external.effect.allele.frequency</code></td>
<td>
<p>A logical indicating whether to use an external effect allele frequency for calculating mean dosage when handling missing genotypes. Default is <code>FALSE</code>.
Provide allele frequency as a column is <code>pgs.weight.data</code> named <code>allelefrequency_effect</code>.</p>
</td></tr>
<tr><td><code id="apply.polygenic.score_+3A_n.percentiles">n.percentiles</code></td>
<td>
<p>An integer indicating the number of percentiles to calculate for the PGS. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="apply.polygenic.score_+3A_analysis.source.pgs">analysis.source.pgs</code></td>
<td>
<p>A character string indicating the source PGS for percentile calculation and regression analyses. Options are &quot;mean.dosage&quot;, &quot;normalize&quot;, or &quot;none&quot;.
When not specified, defaults to <code>missing.genotype.method</code> choice and if more than one PGS missing genotype method is chosen, calculation defaults to the first selection.</p>
</td></tr>
<tr><td><code id="apply.polygenic.score_+3A_validate.inputs.only">validate.inputs.only</code></td>
<td>
<p>A logical indicating whether to only perform input data validation checks without running PGS application.
If no errors are triggered, a message is printed and TRUE is returned. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing per-sample PGS output and per-phenotype regression output if phenotype analysis columns are provided.
</p>
<p><strong>Output Structure</strong>
</p>
<p>The outputed list contains the following elements:
</p>

<ul>
<li><p> pgs.output: A data.frame containing the PGS per sample and optional phenotype data.
</p>
</li>
<li><p> regression.output: A data.frame containing the results of the regression analysis if phenotype.analysis.columns are provided, otherwise <code>NULL</code>.
</p>
</li></ul>

<p>pgs.output columns:
</p>

<ul>
<li> <p><code>Indiv</code>: A character string indicating the sample ID.
</p>
</li>
<li> <p><code>PGS</code>: A numeric vector indicating the PGS per sample. (only if missing.genotype.method includes &quot;none&quot;)
</p>
</li>
<li> <p><code>PGS.with.normalized.missing</code>: A numeric vector indicating the PGS per sample with missing genotypes normalized. (only if missing.genotype.method includes &quot;normalize&quot;)
</p>
</li>
<li> <p><code>PGS.with.replaced.missing</code>: A numeric vector indicating the PGS per sample with missing genotypes replaced by mean dosage. (only if missing.genotype.method includes &quot;mean.dosage&quot;)
</p>
</li>
<li> <p><code>percentile</code>: A numeric vector indicating the percentile rank of the PGS.
</p>
</li>
<li> <p><code>decile</code>: A numeric vector indicating the decile rank of the PGS.
</p>
</li>
<li> <p><code>quartile</code>: A numeric vector indicating the quartile rank of the PGS.
</p>
</li>
<li> <p><code>percentile.X:</code> A numeric vector indicating the user-specified percentile rank of the PGS where &quot;X&quot; is substituted by <code>n.percentiles</code>. (only if <code>n.percentiles</code> is specified)
</p>
</li>
<li> <p><code>n.missing.genotypes</code>: A numeric vector indicating the number of missing genotypes per sample.
</p>
</li>
<li> <p><code>percent.missing.genotypes</code>: A numeric vector indicating the percentage of missing genotypes per sample.
</p>
</li>
<li><p> All columns in <code>phenotype.data</code> if provided.
</p>
</li></ul>

<p>regression.output columns:
</p>

<ul>
<li><p> phenotype: A character vector of phenotype names.
</p>
</li>
<li> <p><code>model</code>: A character vector indicating the regression model used. One of &quot;logistic.regression&quot; or &quot;linear.regression&quot;.
</p>
</li>
<li> <p><code>beta</code>: A numeric vector indicating the beta coefficient of the regression analysis.
</p>
</li>
<li> <p><code>se</code>: A numeric vector indicating the standard error of the beta coefficient.
</p>
</li>
<li> <p><code>p.value</code>: A numeric vector indicating the p-value of the beta coefficient.
</p>
</li>
<li> <p><code>r.squared</code>: A numeric vector indicating the r-squared value of linear regression analysis. NA for logistic regression.
</p>
</li>
<li> <p><code>AUC</code>: A numeric vector indicating the area under the curve of logistic regression analysis. NA for linear regression.
</p>
</li></ul>

<p><strong>PGS Calculation</strong>
</p>
<p>PGS for each individual <em>i</em> is calculated as the sum of the product of the dosage and beta coefficient for each variant in the PGS:
</p>
<p style="text-align: center;"><code class="reqn">PGS_i = \sum_{m=1}^{M} \left( \beta_m \times dosage_{im} \right)</code>
</p>

<p>Where <em>m</em> is a PGS component variant out of a total <em>M</em> variants.
</p>
<p><strong>Missing Genotype Handling</strong>
</p>
<p>VCF genotype data are matched to PGS data by chromosome and position. If a SNP cannot be matched by genomic coordinate,
an attempt is made to match by rsID (if available). If a SNP from the PGS weight data is not found in the VCF data after these two matching attempts,
it is considered a cohort-wide missing variant.
</p>
<p>Missing genotypes (in individual samples) among successfully matched variants are handled by three methods:
</p>
<p><code>none</code>: Missing genotype dosages are excluded from the PGS calculation.
This is equivalent to assuming that all missing genotypes are homozygous for the non-effect allele, resulting in a dosage of 0.
</p>
<p><code>normalize</code>: Missing genotypes are excluded from score calculation but the final score is normalized by the number of non-missing alleles.
The calculation assumes a diploid genome:
</p>
<p style="text-align: center;"><code class="reqn">PGS_i = \dfrac{\sum \left( \beta_m \times dosage_{im} \right)}{P_i * M_{non-missing}}</code>
</p>

<p>Where <em>P</em> is the ploidy and has the value <code>2</code> and <code class="reqn">M_{non-missing}</code> is the number of non-missing genotypes.
</p>
<p><code>mean.dosage</code>: Missing genotype dosages are replaced by the mean population dosage of the variant which is calculated as the product of the effect allele frequency <em>EAF</em> and the ploidy of a diploid genome:
</p>
<p style="text-align: center;"><code class="reqn">\overline{dosage_{k}} = EAF_k * P</code>
</p>

<p>where <em>k</em> is a PGS component variant that is missing in between 1 and n-1 individuals in the cohort and <em>P</em> = ploidy = 2
This dosage calculation holds under assumptions of Hardy-Weinberg equilibrium.
By default, the effect allele frequency is calculated from the provided VCF data.
For variants that are missing in all individuals (cohort-wide), dosage is assumed to be zero (homozygous non-reference) for all individuals.
An external allele frequency can be provided in the <code>pgs.weight.data</code> as a column named <code>allelefrequency_effect</code> and by setting <code>use.external.effect.allele.frequency</code> to <code>TRUE</code>.
</p>
<p><strong>Multiallelic Site Handling</strong>
</p>
<p>If a PGS weight file provides weights for multiple effect alleles, the appropriate dosage is calculated for the alleles that each individual carries.
It is assumed that multiallelic variants are encoded in the same row in the VCF data. This is known as &quot;merged&quot; format. Split multiallelic sites are not accepted.
VCF data can be formatted to merged format using external tools for VCF file manipulation.
</p>
<p><strong>Allele Mismatch Handling</strong>
Variants from the PGS weight data are merged with records in the VCF data by genetic coordinate.
After the merge is complete, there may be cases where the VCF reference (REF) and alternative (ALT) alleles do not match their conventional counterparts in the
PGS weight data (other allele and effect allele, respectively).
This is usually caused by a strand flip: the variant in question was called against opposite DNA reference strands in the PGS training data and the VCF data.
Strand flips can be detected and corrected by flipping the affected allele to its reverse complement.
<code>apply.polygenic.score</code> uses <code>assess.pgs.vcf.allele.match</code> to assess allele concordance, and is controlled through the following arguments:
</p>

<ul>
<li> <p><code>correct.strand.flips</code>: When <code>TRUE</code>, detected strand flips are corrected by flipping the affected value in the <code>effect_allele</code> column prior to dosage calling.
</p>
</li>
<li> <p><code>remove.ambiguous.allele.matches</code>: Corresponds to the <code>return.ambiguous.as.missing</code> argument in <code>assess.pgs.vcf.allele.match</code>. When <code>TRUE</code>, non-INDEL allele
mismatches that cannot be resolved (due to palindromic alleles or causes other than strand flips) are removed by marking the affected value in the <code>effect_allele</code> column as missing
prior to dosage calling and missing genotype handling. The corresponding dosage is set to NA and the variant is handled according to the chosen missing genotype method.
</p>
</li>
<li> <p><code>remove.mismatched.indels</code>: Corresponds to the <code>return.indels.as.missing</code> argument in <code>assess.pgs.vcf.allele.match</code>. When <code>TRUE</code>, INDEL allele mismatches
(which cannot be assessed for strand flips) are removed by marking the affected value in the <code>effect_allele</code> column as missing prior to dosage calling and missing genotype handling.
The corresponding dosage is set to NA and the variant is handled according to the chosen missing genotype method.
</p>
</li></ul>

<p>Note that an allele match assessment requires the presence of both the <code>other_allele</code> and <code>effect_allele</code> in the PGS weight data.
The <code>other_allele</code> column is not required by the PGS Catalog, and so is not always available.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example VCF
vcf.path &lt;- system.file(
    'extdata',
    'HG001_GIAB.vcf.gz',
    package = 'ApplyPolygenicScore',
    mustWork = TRUE
    );
vcf.import &lt;- import.vcf(vcf.path);

# Example pgs weight file
pgs.weight.path &lt;- system.file(
    'extdata',
    'PGS000662_hmPOS_GRCh38.txt.gz',
    package = 'ApplyPolygenicScore',
    mustWork = TRUE
    );
pgs.import &lt;- import.pgs.weight.file(pgs.weight.path);

pgs.data &lt;- apply.polygenic.score(
    vcf.data = vcf.import$dat,
    pgs.weight.data = pgs.import$pgs.weight.data,
    missing.genotype.method = 'none'
    );

# Specify different methods for handling missing genotypes
pgs.import$pgs.weight.data$allelefrequency_effect &lt;- rep(0.5, nrow(pgs.import$pgs.weight.data));
pgs.data &lt;- apply.polygenic.score(
    vcf.data = vcf.import$dat,
    pgs.weight.data = pgs.import$pgs.weight.data,
    missing.genotype.method = c('none', 'mean.dosage', 'normalize'),
    use.external.effect.allele.frequency = TRUE
    );

# Specify allele mismatch handling
pgs.data &lt;- apply.polygenic.score(
   vcf.data = vcf.import$dat,
   pgs.weight.data = pgs.import$pgs.weight.data,
   correct.strand.flips = TRUE,
   remove.ambiguous.allele.matches = TRUE,
   remove.mismatched.indels = FALSE
   );

# Provide phenotype data for basic correlation analysis
phenotype.data &lt;- data.frame(
    Indiv = unique(vcf.import$dat$Indiv),
    continuous.phenotype = rnorm(length(unique(vcf.import$dat$Indiv))),
    binary.phenotype = sample(
        c('a', 'b'),
        length(unique(vcf.import$dat$Indiv)),
        replace = TRUE
        )
    );

pgs.data &lt;- apply.polygenic.score(
    vcf.data = vcf.import$dat,
    pgs.weight.data = pgs.import$pgs.weight.data,
    phenotype.data = phenotype.data
    );

# Only run validation checks on input data and report back
apply.polygenic.score(
    vcf.data = vcf.import$dat,
    pgs.weight.data = pgs.import$pgs.weight.data,
    validate.inputs.only = TRUE
    );
</code></pre>

<hr>
<h2 id='assess.pgs.vcf.allele.match'>Assess PGS allele match to VCF allele</h2><span id='topic+assess.pgs.vcf.allele.match'></span>

<h3>Description</h3>

<p>Assess whether PGS reference and effect alleles match provided VCF reference and alternative alleles.
Mismatches are checked for potential switching of effect and reference PGS alleles (cases where the effect allele is the REF VCF allele)
and are evaluated for DNA strand flips (by flipping the PGS alleles). INDEL alleles are not supported for strand flip assessment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assess.pgs.vcf.allele.match(
  vcf.ref.allele,
  vcf.alt.allele,
  pgs.ref.allele,
  pgs.effect.allele,
  return.indels.as.missing = FALSE,
  return.ambiguous.as.missing = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assess.pgs.vcf.allele.match_+3A_vcf.ref.allele">vcf.ref.allele</code></td>
<td>
<p>A character vector of singular VCF reference (REF) alleles.</p>
</td></tr>
<tr><td><code id="assess.pgs.vcf.allele.match_+3A_vcf.alt.allele">vcf.alt.allele</code></td>
<td>
<p>A character vector of VCF alternative (ALT) alleles. Multiple alleles at a multiallelic site must be separated by commas.</p>
</td></tr>
<tr><td><code id="assess.pgs.vcf.allele.match_+3A_pgs.ref.allele">pgs.ref.allele</code></td>
<td>
<p>A character vector of singular PGS reference alleles aka &quot;non-effect&quot; or &quot;other&quot; alleles.</p>
</td></tr>
<tr><td><code id="assess.pgs.vcf.allele.match_+3A_pgs.effect.allele">pgs.effect.allele</code></td>
<td>
<p>A character vector of singular PGS effect alleles.</p>
</td></tr>
<tr><td><code id="assess.pgs.vcf.allele.match_+3A_return.indels.as.missing">return.indels.as.missing</code></td>
<td>
<p>A logical value indicating whether to return NA for INDEL alleles with detected mismatches. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="assess.pgs.vcf.allele.match_+3A_return.ambiguous.as.missing">return.ambiguous.as.missing</code></td>
<td>
<p>A logical value indicating whether to return NA for ambiguous cases where both a strand flip and effect switch are possible,
or no strand flip is detected and a mismatch cannot be resolved. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the match assessment, a new PGS effect allele, and a new PGS other allele.
</p>
<p><strong>Output Structure</strong>
</p>
<p>The outputed list contains the following elements:
</p>

<ul>
<li> <p><code>match.status</code>: A character vector indicating the match status for each pair of allele pairs. Possible values are <code>default_match</code>, <code>effect_switch</code>, <code>strand_flip</code>, <code>effect_switch_with_strand_flip</code>, <code>ambiguous_flip</code>, <code>indel_mismatch</code>, and <code>unresolved_mismatch</code>.
</p>
</li>
<li> <p><code>new.pgs.effect.allele</code>: A character vector of new PGS effect alleles based on the match status. If the match status is <code>default_match</code>, <code>effect_switch</code> or <code>missing_allele</code>, the original PGS effect allele is returned.
If the match status is <code>strand_flip</code> or <code>effect_switch_with_strand_flip</code> the flipped PGS effect allele is returned. If the match status is <code>ambiguous_flip</code>, <code>indel_mismatch</code>, or <code>unresolved_mismatch</code>,
the return value is either the original allele or NA as dictated by the <code>return.indels.as.missing</code> and <code>return.ambiguous.as.missing</code> parameters.
</p>
</li>
<li> <p><code>new.pgs.other.allele</code>: A character vector of new PGS other alleles based on the match status, following the same logic as <code>new.pgs.effect.allele</code>.
</p>
</li></ul>

<p>The match.status output indicates the following:
</p>

<ul>
<li> <p><code>default_match</code>: The default PGS reference allele matches the VCF REF allele and the default PGS effect allele matches one of the VCF ALT alleles.
</p>
</li>
<li> <p><code>effect_switch</code>: The PGS effect allele matches the VCF REF allele and the PGS reference allele matches one of the VCF ALT alleles.
</p>
</li>
<li> <p><code>strand_flip</code>: The PGS reference and effect alleles match their respective VCF pairs when flipped.
</p>
</li>
<li> <p><code>effect_switch_with_strand_flip</code>: The PGS effect allele matches the VCF REF allele and the PGS reference allele matches one of the VCF ALT alleles when flipped.
</p>
</li>
<li> <p><code>ambiguous_flip</code>: Both an effect switch and a strand flip have been detected. This is an ambiguous case caused by palindromic SNPs.
</p>
</li>
<li> <p><code>indel_mismatch</code>: A mismatch was detected between pairs of alleles where at least one was an INDEL. INDEL alleles are not supported for strand flip assessment.
</p>
</li>
<li> <p><code>unresolved_mismatch</code>: A mismatch was detected between pairs of non-INDEL alleles that could not be resolved by an effect switch or flipping the PGS alleles.
</p>
</li>
<li> <p><code>missing_allele</code>: One of the four alleles is missing, making it impossible to assess the match.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Example data demonstrating the following cases in each vector element:
# 1. no strand flips
# 2. effect allele switch
# 3. strand flip
# 4. effect allele switch AND strand flip
# 5. palindromic (ambiguous) alleles
# 6. unresolved mismatch
vcf.ref.allele &lt;- c('A', 'A', 'A', 'A', 'A', 'A');
vcf.alt.allele &lt;- c('G', 'G', 'G', 'G', 'T', 'G');
pgs.ref.allele &lt;- c('A', 'G', 'T', 'C', 'T', 'A');
pgs.effect.allele &lt;- c('G', 'A', 'C', 'T', 'A', 'C');
assess.pgs.vcf.allele.match(vcf.ref.allele, vcf.alt.allele, pgs.ref.allele, pgs.effect.allele);
</code></pre>

<hr>
<h2 id='check.pgs.weight.columns'>Check PGS weight file columns</h2><span id='topic+check.pgs.weight.columns'></span>

<h3>Description</h3>

<p>Check that a PGS weight file contains the required columns for PGS application with <code>apply.polygenic.score</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.pgs.weight.columns(pgs.weight.colnames, harmonized = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check.pgs.weight.columns_+3A_pgs.weight.colnames">pgs.weight.colnames</code></td>
<td>
<p>A character vector of column names.</p>
</td></tr>
<tr><td><code id="check.pgs.weight.columns_+3A_harmonized">harmonized</code></td>
<td>
<p>A logical indicating whether the presence of harmonized columns should be checked.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical indicating whether the file contains the required columns.
</p>

<hr>
<h2 id='combine.pgs.bed'>Combine PGS BED files</h2><span id='topic+combine.pgs.bed'></span>

<h3>Description</h3>

<p>Merge overlapping PGS coordinates in multiple BED files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine.pgs.bed(
  pgs.bed.list,
  add.annotation.data = FALSE,
  annotation.column.index = 4,
  slop = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="combine.pgs.bed_+3A_pgs.bed.list">pgs.bed.list</code></td>
<td>
<p>A named list of data.frames containing PGS coordinates in BED format.</p>
</td></tr>
<tr><td><code id="combine.pgs.bed_+3A_add.annotation.data">add.annotation.data</code></td>
<td>
<p>A logical indicating whether an additional annotation data column should be added to the annotation column.</p>
</td></tr>
<tr><td><code id="combine.pgs.bed_+3A_annotation.column.index">annotation.column.index</code></td>
<td>
<p>An integer indicating the index of the column in the data frames in <code>pgs.bed.list</code> that should be added to the annotation column.</p>
</td></tr>
<tr><td><code id="combine.pgs.bed_+3A_slop">slop</code></td>
<td>
<p>An integer indicating the number of base pairs to add to the BED interval on either side.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame containing the merged PGS coordinates in BED format with an extra annotation column containing the name of the PGS and data from one additional column optionally selected by the user.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bed1 &lt;- data.frame(
    chr = c(1, 2, 3),
    start = c(1, 2, 3),
    end = c(2, 3, 4),
    annotation = c('a', 'b', 'c')
    );
bed2 &lt;- data.frame(
    chr = c(1, 2, 3),
    start = c(1, 20, 30),
    end = c(2, 21, 31),
    annotation = c('d', 'e', 'f')
    );
bed.input &lt;- list(bed1 = bed1, bed2 = bed2);
combine.pgs.bed(bed.input);
</code></pre>

<hr>
<h2 id='combine.vcf.with.pgs'>Combine VCF with PGS</h2><span id='topic+combine.vcf.with.pgs'></span>

<h3>Description</h3>

<p>Match PGS SNPs to corresponding VCF information by genomic coordinates or rsID using a merge operation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine.vcf.with.pgs(vcf.data, pgs.weight.data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="combine.vcf.with.pgs_+3A_vcf.data">vcf.data</code></td>
<td>
<p>A data.frame containing VCF data. Required columns: <code>CHROM, POS</code>.</p>
</td></tr>
<tr><td><code id="combine.vcf.with.pgs_+3A_pgs.weight.data">pgs.weight.data</code></td>
<td>
<p>A data.frame containing PGS data. Required columns: <code>CHROM, POS</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing a data.frame of merged VCF and PGS data and a data.frame of PGS SNPs missing from the VCF.
</p>
<p>A primary merge is first performed on chromosome and base pair coordinates. For SNPs that could not be matched in the first mergs, a second merge is attempted by rsID if available.
This action can account for short INDELs that can have coordinate mismatches between the PGS and VCF data.
The merge is a left outer join: all PGS SNPs are kept as rows even if they are missing from the VCF, and all VCF SNPs that are not a component of the PGS are dropped.
If no PGS SNPs are present in the VCF, the function will terminate with an error.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example VCF
vcf.path &lt;- system.file(
    'extdata',
    'HG001_GIAB.vcf.gz',
    package = 'ApplyPolygenicScore',
    mustWork = TRUE
    );
vcf.import &lt;- import.vcf(vcf.path);

# Example pgs weight file
pgs.weight.path &lt;- system.file(
    'extdata',
    'PGS000662_hmPOS_GRCh38.txt.gz',
    package = 'ApplyPolygenicScore',
    mustWork = TRUE
    );
pgs.import &lt;- import.pgs.weight.file(pgs.weight.path);

merge.data &lt;- combine.vcf.with.pgs(
    vcf.data = vcf.import$dat,
    pgs.weight.data = pgs.import$pgs.weight.data
    );
</code></pre>

<hr>
<h2 id='convert.allele.frequency.to.dosage'>Convert allele frequency to mean dosage</h2><span id='topic+convert.allele.frequency.to.dosage'></span>

<h3>Description</h3>

<p>Convert a population allele frequency to a mean dosage for that allele.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert.allele.frequency.to.dosage(allele.frequency)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert.allele.frequency.to.dosage_+3A_allele.frequency">allele.frequency</code></td>
<td>
<p>A numeric vector of allele frequencies.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of mean dosages for the allele frequencies.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>allele.frequency &lt;- seq(0.1, 0.9, 0.1);
convert.allele.frequency.to.dosage(allele.frequency);
</code></pre>

<hr>
<h2 id='convert.alleles.to.pgs.dosage'>Convert alleles to dosage</h2><span id='topic+convert.alleles.to.pgs.dosage'></span>

<h3>Description</h3>

<p>Convert genotype calls in the form of witten out alleles (e.g. 'A/T') to dosages (0, 1, 2) based on provided risk alleles from a PGS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert.alleles.to.pgs.dosage(called.alleles, risk.alleles)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert.alleles.to.pgs.dosage_+3A_called.alleles">called.alleles</code></td>
<td>
<p>A vector of genotypes in allelic notation separated by a slash or pipe.</p>
</td></tr>
<tr><td><code id="convert.alleles.to.pgs.dosage_+3A_risk.alleles">risk.alleles</code></td>
<td>
<p>A vector of risk alleles from a polygenic score corresponding to each genotype (by locus) in called.alleles.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of dosages corresponding to each genotype in called.alleles. Hemizygous genotypes (one allele e.g. 'A') are counted as 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>called.alleles &lt;- c('A/A', 'A/T', 'T/T');
risk.alleles &lt;- c('T', 'T', 'T');
convert.alleles.to.pgs.dosage(called.alleles, risk.alleles);
</code></pre>

<hr>
<h2 id='convert.pgs.to.bed'>Convert PGS data to BED format</h2><span id='topic+convert.pgs.to.bed'></span>

<h3>Description</h3>

<p>Convert imported and formatted PGS compnent SNP coordinate data to BED format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert.pgs.to.bed(
  pgs.weight.data,
  chr.prefix = TRUE,
  numeric.sex.chr = FALSE,
  slop = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert.pgs.to.bed_+3A_pgs.weight.data">pgs.weight.data</code></td>
<td>
<p>A data.frame containing SNP coordinate data with standardized CHROM and POS columns.</p>
</td></tr>
<tr><td><code id="convert.pgs.to.bed_+3A_chr.prefix">chr.prefix</code></td>
<td>
<p>A logical indicating whether the 'chr' prefix should be used when formatting chromosome name.</p>
</td></tr>
<tr><td><code id="convert.pgs.to.bed_+3A_numeric.sex.chr">numeric.sex.chr</code></td>
<td>
<p>A logical indicating whether the sex chromosomes should be formatted numerically, as opposed to alphabetically.</p>
</td></tr>
<tr><td><code id="convert.pgs.to.bed_+3A_slop">slop</code></td>
<td>
<p>An integer indicating the number of base pairs to add to the BED interval on either side.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame containing the PGS component SNP coordinate data in BED format and any other columns provided in pgs.weight.data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pgs.weight.data &lt;- data.frame(
    CHROM = c('chr1', 'chrX'),
    POS = c(10, 20)
    );
convert.pgs.to.bed(pgs.weight.data);

# Switch between different chromosome notations
convert.pgs.to.bed(pgs.weight.data, chr.prefix = FALSE, numeric.sex.chr = TRUE);

# Add slop to BED intervals
convert.pgs.to.bed(pgs.weight.data, slop = 10);
</code></pre>

<hr>
<h2 id='create.pgs.density.plot'>Plot PGS Density</h2><span id='topic+create.pgs.density.plot'></span>

<h3>Description</h3>

<p>Plot density curves of PGS data outputted by <code>apply.polygenic.score</code>.
If phenotype columns are provided, multiple density curves are plotted for automatically detected categories for each categorical variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create.pgs.density.plot(
  pgs.data,
  phenotype.columns = NULL,
  output.dir = NULL,
  filename.prefix = NULL,
  file.extension = "png",
  tidy.titles = FALSE,
  width = 10,
  height = 10,
  xaxes.cex = 1.5,
  yaxes.cex = 1.5,
  titles.cex = 1.5,
  key.cex = 1,
  border.padding = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create.pgs.density.plot_+3A_pgs.data">pgs.data</code></td>
<td>
<p>data.frame PGS data as formatted by <code>apply.polygenic.score()</code>. Required columns are at least one of PGS, PGS.with.replaced.missing, or PGS.with.normalized.missing.
This function is designed to work with the output of <code>apply.polygenic.score()</code>.</p>
</td></tr>
<tr><td><code id="create.pgs.density.plot_+3A_phenotype.columns">phenotype.columns</code></td>
<td>
<p>character vector of phenotype columns in <code>pgs.data</code> to plot (optional)</p>
</td></tr>
<tr><td><code id="create.pgs.density.plot_+3A_output.dir">output.dir</code></td>
<td>
<p>character directory to save output plots</p>
</td></tr>
<tr><td><code id="create.pgs.density.plot_+3A_filename.prefix">filename.prefix</code></td>
<td>
<p>character prefix for output filenames</p>
</td></tr>
<tr><td><code id="create.pgs.density.plot_+3A_file.extension">file.extension</code></td>
<td>
<p>character file extension for output plots</p>
</td></tr>
<tr><td><code id="create.pgs.density.plot_+3A_tidy.titles">tidy.titles</code></td>
<td>
<p>logical whether to reformat PGS plot titles to remove periods</p>
</td></tr>
<tr><td><code id="create.pgs.density.plot_+3A_width">width</code></td>
<td>
<p>numeric width of output plot in inches</p>
</td></tr>
<tr><td><code id="create.pgs.density.plot_+3A_height">height</code></td>
<td>
<p>numeric height of output plot in inches</p>
</td></tr>
<tr><td><code id="create.pgs.density.plot_+3A_xaxes.cex">xaxes.cex</code></td>
<td>
<p>numeric size for all x-axis labels</p>
</td></tr>
<tr><td><code id="create.pgs.density.plot_+3A_yaxes.cex">yaxes.cex</code></td>
<td>
<p>numeric size for all y-axis labels</p>
</td></tr>
<tr><td><code id="create.pgs.density.plot_+3A_titles.cex">titles.cex</code></td>
<td>
<p>numeric size for all plot titles</p>
</td></tr>
<tr><td><code id="create.pgs.density.plot_+3A_key.cex">key.cex</code></td>
<td>
<p>numeric size of color key legend</p>
</td></tr>
<tr><td><code id="create.pgs.density.plot_+3A_border.padding">border.padding</code></td>
<td>
<p>numeric padding for plot borders</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If no output directory is provided, a multipanel lattice plot object is returned, otherwise a plot is written to the indicated path and <code>NULL</code> is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(100);
pgs.data &lt;- data.frame(
    PGS = rnorm(100, 0, 1)
    );
 temp.dir &lt;- tempdir();

# Basic Plot
create.pgs.density.plot(
    pgs.data,
    output.dir = temp.dir,
    filename.prefix = 'basic-plot',
    width = 6,
    height = 6
    );

# Plot multiple PGS outputs
pgs.data$PGS.with.normalized.missing &lt;- rnorm(100, 1, 1);
create.pgs.density.plot(pgs.data, output.dir = temp.dir);

# Plot phenotype categories

pgs.data$sex &lt;- sample(c('male', 'female', 100, replace = TRUE));
create.pgs.density.plot(
    pgs.data,
    output.dir = temp.dir,
    filename.prefix = 'multiple-pgs',
    phenotype.columns = 'sex'
    );

# Plot multiple phenotypes

pgs.data$letters &lt;- sample(letters[1:5], 100, replace = TRUE);
create.pgs.density.plot(
    pgs.data,
    output.dir = temp.dir,
    filename.prefix = 'multiple-phenotypes',
    phenotype.columns = c('sex', 'letters')
    );

</code></pre>

<hr>
<h2 id='create.pgs.rank.plot'>Plot PGS Rank</h2><span id='topic+create.pgs.rank.plot'></span>

<h3>Description</h3>

<p>Plot PGS percentile rank of each sample outputted by <code>apply.polygenic.score()</code> as a barplot, plot missing genotypes if any are present, plot corresponding decile and quartile markers as a heatmap, optionally plot phenotype covariates as color bars.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create.pgs.rank.plot(
  pgs.data,
  phenotype.columns = NULL,
  missing.genotype.style = "count",
  categorical.palette = NULL,
  binary.palette = NULL,
  output.dir = NULL,
  filename.prefix = NULL,
  file.extension = "png",
  width = 8,
  height = 8,
  xaxis.cex = 1.2,
  yaxis.cex = 1,
  titles.cex = 1.2,
  border.padding = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create.pgs.rank.plot_+3A_pgs.data">pgs.data</code></td>
<td>
<p>data.frame PGS data as formatted by <code>apply.polygenic.score()</code> Required columns: <code>Indiv, percentile, decile, quartile, n.missing.genotypes, percent.missing.genotypes,</code> and optionally user-defined percentiles and phenotype covariates.
This function is designed to work with the output of the function apply.polygenic.score().</p>
</td></tr>
<tr><td><code id="create.pgs.rank.plot_+3A_phenotype.columns">phenotype.columns</code></td>
<td>
<p>character vector of column names in pgs.data containing phenotype covariates to plot as color bars. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="create.pgs.rank.plot_+3A_missing.genotype.style">missing.genotype.style</code></td>
<td>
<p>character style of missing genotype barplot. Default is &quot;count&quot;. Options are &quot;count&quot; or &quot;percent&quot;.</p>
</td></tr>
<tr><td><code id="create.pgs.rank.plot_+3A_categorical.palette">categorical.palette</code></td>
<td>
<p>character vector of colors to use for categorical phenotype covariates. Default is <code>NULL</code> in which case the default palette is used, which contains 12 unique colors.
If the number of unique categories exceeds the number of colors in the color palette, an error will be thrown.</p>
</td></tr>
<tr><td><code id="create.pgs.rank.plot_+3A_binary.palette">binary.palette</code></td>
<td>
<p>character vector of colors to use for binary and continuous phenotype covariates. Each color is contrasted with white to create a color ramp or binary categories.
Default is <code>NULL</code> in which case the default palette is used, which contains 9 unique colors paired with white.
If the number of binary and continuous phenotype covariates exceeds the number of colors in the color palette, an error will be thrown.</p>
</td></tr>
<tr><td><code id="create.pgs.rank.plot_+3A_output.dir">output.dir</code></td>
<td>
<p>character directory path to write plot to file. Default is <code>NULL</code> in which case the plot is returned as lattice multipanel object.</p>
</td></tr>
<tr><td><code id="create.pgs.rank.plot_+3A_filename.prefix">filename.prefix</code></td>
<td>
<p>character prefix for plot filename.</p>
</td></tr>
<tr><td><code id="create.pgs.rank.plot_+3A_file.extension">file.extension</code></td>
<td>
<p>character file extension for plot file. Default is &quot;png&quot;.</p>
</td></tr>
<tr><td><code id="create.pgs.rank.plot_+3A_width">width</code></td>
<td>
<p>numeric width of plot in inches.</p>
</td></tr>
<tr><td><code id="create.pgs.rank.plot_+3A_height">height</code></td>
<td>
<p>numeric height of plot in inches.</p>
</td></tr>
<tr><td><code id="create.pgs.rank.plot_+3A_xaxis.cex">xaxis.cex</code></td>
<td>
<p>numeric size of x-axis labels.</p>
</td></tr>
<tr><td><code id="create.pgs.rank.plot_+3A_yaxis.cex">yaxis.cex</code></td>
<td>
<p>numeric size of y-axis labels.</p>
</td></tr>
<tr><td><code id="create.pgs.rank.plot_+3A_titles.cex">titles.cex</code></td>
<td>
<p>numeric size of plot titles.</p>
</td></tr>
<tr><td><code id="create.pgs.rank.plot_+3A_border.padding">border.padding</code></td>
<td>
<p>numeric padding around plot border.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If no output directory is provided, a multipanel lattice plot object is returned, otherwise a plot is written to the indicated path and <code>NULL</code> is returned.
</p>
<p>For clarity, certain plot aspects change when sample size exceeds 50:
</p>

<ul>
<li><p> x-axis labels are no longer displayed
</p>
</li>
<li><p> missing (NA) values are not labeled with text in heatmaps but are color-coded with a legend
</p>
</li></ul>

<p>Colors for continuous and binary phenotypes are chosen from the binary color palettes in <code>BoutrosLab.plotting.general::default.colours()</code>.
Colors for categorical phenotypes are chosen by default from the qualitative color palette in <code>BoutrosLab.plotting.general::default.colours()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(200);
percentiles &lt;- get.pgs.percentiles(rnorm(200, 0, 1));
pgs.data &lt;- data.frame(
    Indiv = paste0('sample', 1:200),
    percentile = percentiles$percentile,
    decile = percentiles$decile,
    quartile = percentiles$quartile,
    n.missing.genotypes = sample(1:10, 200, replace = TRUE),
    percent.missing.genotypes = sample(1:10, 200, replace = TRUE) / 100,
    continuous.pheno = rnorm(200, 1, 1),
    categorical.pheno = sample(letters[1:5], 200, replace = TRUE),
    binary.pheno = sample(c(0,1), 200, replace = TRUE)
    );

temp.dir &lt;- tempdir();

create.pgs.rank.plot(
    pgs.data,
    phenotype.columns = c('continuous.pheno', 'categorical.pheno', 'binary.pheno'),
    missing.genotype.style = 'percent',
    output.dir = temp.dir,
    filename.prefix = 'example-rank-plot'
    );
</code></pre>

<hr>
<h2 id='create.pgs.with.continuous.phenotype.plot'>Plot PGS Scatterplots</h2><span id='topic+create.pgs.with.continuous.phenotype.plot'></span>

<h3>Description</h3>

<p>Create scatterplots for PGS data outputed by <code>apply.polygenic.score()</code> with continuous phenotype variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create.pgs.with.continuous.phenotype.plot(
  pgs.data,
  phenotype.columns,
  hexbin.threshold = 1000,
  hexbin.colour.scheme = NULL,
  hexbin.colourkey = TRUE,
  hexbin.colourcut = seq(0, 1, length = 11),
  hexbin.mincnt = 1,
  hexbin.maxcnt = NULL,
  hexbin.xbins = 30,
  hexbin.aspect = 1,
  output.dir = NULL,
  filename.prefix = NULL,
  file.extension = "png",
  tidy.titles = FALSE,
  compute.correlation = TRUE,
  corr.legend.corner = c(0, 1),
  corr.legend.cex = 1.5,
  include.origin = FALSE,
  width = 10,
  height = 10,
  xaxes.cex = 1.5,
  yaxes.cex = 1.5,
  titles.cex = 1.5,
  point.cex = 0.75,
  border.padding = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create.pgs.with.continuous.phenotype.plot_+3A_pgs.data">pgs.data</code></td>
<td>
<p>data.frame PGS data as formatted by <code>apply.polygenic.score()</code>. Required columns are at least one of PGS, PGS.with.replaced.missing, or PGS.with.normalized.missing, and at least one continuous phenotype column.
This function is designed to work with the output of <code>apply.polygenic.score()</code>.</p>
</td></tr>
<tr><td><code id="create.pgs.with.continuous.phenotype.plot_+3A_phenotype.columns">phenotype.columns</code></td>
<td>
<p>character vector of continuous phenotype column names in pgs.data to plot</p>
</td></tr>
<tr><td><code id="create.pgs.with.continuous.phenotype.plot_+3A_hexbin.threshold">hexbin.threshold</code></td>
<td>
<p>numeric threshold (exclusive) for cohort size at which to switch from scatterplot to hexbin plot.</p>
</td></tr>
<tr><td><code id="create.pgs.with.continuous.phenotype.plot_+3A_hexbin.colour.scheme">hexbin.colour.scheme</code></td>
<td>
<p>character vector of colors for hexbin plot bins. Default is <code>NULL</code> which uses gray/black.</p>
</td></tr>
<tr><td><code id="create.pgs.with.continuous.phenotype.plot_+3A_hexbin.colourkey">hexbin.colourkey</code></td>
<td>
<p>logical whether a legend should be drawn for a hexbinplot, defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="create.pgs.with.continuous.phenotype.plot_+3A_hexbin.colourcut">hexbin.colourcut</code></td>
<td>
<p>numeric vector of values covering [0, 1] that determine hexagon colour class boundaries and hexagon legend size boundaries.
Alternatively, an integer (&lt;= hexbin.maxcnt) specifying the number of equispaced colourcut values in [0,1].</p>
</td></tr>
<tr><td><code id="create.pgs.with.continuous.phenotype.plot_+3A_hexbin.mincnt">hexbin.mincnt</code></td>
<td>
<p>integer, minimum count for a hexagon to be plotted. Default is 1.</p>
</td></tr>
<tr><td><code id="create.pgs.with.continuous.phenotype.plot_+3A_hexbin.maxcnt">hexbin.maxcnt</code></td>
<td>
<p>integer, maximum count for a hexagon to be plotted. Cells with more counts are not plotted. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="create.pgs.with.continuous.phenotype.plot_+3A_hexbin.xbins">hexbin.xbins</code></td>
<td>
<p>integer, number of bins in the x direction for hexbin plot. Default is 30.</p>
</td></tr>
<tr><td><code id="create.pgs.with.continuous.phenotype.plot_+3A_hexbin.aspect">hexbin.aspect</code></td>
<td>
<p>numeric, aspect ratio of hexbin plot to control plot dimensions. Default is 1.</p>
</td></tr>
<tr><td><code id="create.pgs.with.continuous.phenotype.plot_+3A_output.dir">output.dir</code></td>
<td>
<p>character directory to save output plots</p>
</td></tr>
<tr><td><code id="create.pgs.with.continuous.phenotype.plot_+3A_filename.prefix">filename.prefix</code></td>
<td>
<p>character prefix for output filenames</p>
</td></tr>
<tr><td><code id="create.pgs.with.continuous.phenotype.plot_+3A_file.extension">file.extension</code></td>
<td>
<p>character file extension for output plots</p>
</td></tr>
<tr><td><code id="create.pgs.with.continuous.phenotype.plot_+3A_tidy.titles">tidy.titles</code></td>
<td>
<p>logical whether to reformat PGS plot titles to remove periods</p>
</td></tr>
<tr><td><code id="create.pgs.with.continuous.phenotype.plot_+3A_compute.correlation">compute.correlation</code></td>
<td>
<p>logical whether to compute correlation between PGS and phenotype and display in plot</p>
</td></tr>
<tr><td><code id="create.pgs.with.continuous.phenotype.plot_+3A_corr.legend.corner">corr.legend.corner</code></td>
<td>
<p>numeric vector indicating the corner of the correlation legend e.g. <code>c(0,1)</code> for top left</p>
</td></tr>
<tr><td><code id="create.pgs.with.continuous.phenotype.plot_+3A_corr.legend.cex">corr.legend.cex</code></td>
<td>
<p>numeric cex for correlation legend</p>
</td></tr>
<tr><td><code id="create.pgs.with.continuous.phenotype.plot_+3A_include.origin">include.origin</code></td>
<td>
<p>logical whether to include the origin (zero) in plot axes</p>
</td></tr>
<tr><td><code id="create.pgs.with.continuous.phenotype.plot_+3A_width">width</code></td>
<td>
<p>numeric width of output plot in inches</p>
</td></tr>
<tr><td><code id="create.pgs.with.continuous.phenotype.plot_+3A_height">height</code></td>
<td>
<p>numeric height of output plot in inches</p>
</td></tr>
<tr><td><code id="create.pgs.with.continuous.phenotype.plot_+3A_xaxes.cex">xaxes.cex</code></td>
<td>
<p>numeric size for x-axis labels</p>
</td></tr>
<tr><td><code id="create.pgs.with.continuous.phenotype.plot_+3A_yaxes.cex">yaxes.cex</code></td>
<td>
<p>numeric size for y-axis labels</p>
</td></tr>
<tr><td><code id="create.pgs.with.continuous.phenotype.plot_+3A_titles.cex">titles.cex</code></td>
<td>
<p>numeric size for plot titles</p>
</td></tr>
<tr><td><code id="create.pgs.with.continuous.phenotype.plot_+3A_point.cex">point.cex</code></td>
<td>
<p>numeric size for plot points</p>
</td></tr>
<tr><td><code id="create.pgs.with.continuous.phenotype.plot_+3A_border.padding">border.padding</code></td>
<td>
<p>numeric padding for plot borders</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If no output directory is provided, a multipanel lattice plot object is returned, otherwise a plot is written to the indicated path and <code>NULL</code> is returned.
If no continuous phenotype variables are detected, a warning is issued and <code>NULL</code> is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(100);

pgs.data &lt;- data.frame(
    PGS = rnorm(100, 0, 1),
    continuous.phenotype = rnorm(100, 2, 1)
    );
 temp.dir &lt;- tempdir();

# Basic Plot
create.pgs.with.continuous.phenotype.plot(
    pgs.data,
    output.dir = temp.dir,
    filename.prefix = 'basic-plot',
    phenotype.columns = 'continuous.phenotype',
    width = 6,
    height = 6
    );

# Plot multiple PGS outputs

pgs.data$PGS.with.normalized.missing &lt;- rnorm(100, 1, 1);
create.pgs.with.continuous.phenotype.plot(
    pgs.data,
    output.dir = temp.dir,
    filename.prefix = 'multiple-pgs',
    phenotype.columns = 'continuous.phenotype'
    );


# Plot multiple phenotypes

pgs.data$continuous.phenotype2 &lt;- rnorm(100, 10, 1);
create.pgs.with.continuous.phenotype.plot(
    pgs.data,
    output.dir = temp.dir,
    filename.prefix = 'multiple-phenotypes',
    phenotype.columns = c('continuous.phenotype', 'continuous.phenotype2')
    );

</code></pre>

<hr>
<h2 id='flip.DNA.allele'>Flip DNA allele</h2><span id='topic+flip.DNA.allele'></span>

<h3>Description</h3>

<p>Flip single base pair DNA alleles to their reverse complement. INDEL flipping is not supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flip.DNA.allele(alleles, return.indels.as.missing = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flip.DNA.allele_+3A_alleles">alleles</code></td>
<td>
<p>A character vector of DNA alleles.</p>
</td></tr>
<tr><td><code id="flip.DNA.allele_+3A_return.indels.as.missing">return.indels.as.missing</code></td>
<td>
<p>A logical value indicating whether to return NA for INDEL alleles. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of flipped DNA alleles. INDEL alleles are returned as is unless <code>return.indels.as.missing</code> is <code>TRUE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>alleles &lt;- c('A', 'T', 'C', 'G', 'ATG', NA);
flip.DNA.allele(alleles);
</code></pre>

<hr>
<h2 id='format.chromosome.notation'>Format chromosome names</h2><span id='topic+format.chromosome.notation'></span>

<h3>Description</h3>

<p>Format chromosome names according to user specifications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'chromosome.notation'
format(chromosome, chr.prefix, numeric.sex.chr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="format.chromosome.notation_+3A_chromosome">chromosome</code></td>
<td>
<p>A character vector of chromosome names.</p>
</td></tr>
<tr><td><code id="format.chromosome.notation_+3A_chr.prefix">chr.prefix</code></td>
<td>
<p>A logical indicating whether the 'chr' prefix should be used when formatting chromosome name.</p>
</td></tr>
<tr><td><code id="format.chromosome.notation_+3A_numeric.sex.chr">numeric.sex.chr</code></td>
<td>
<p>A logical indicating whether the sex chromosomes should be formatted numerically, as opposed to alphabetically.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of chromosome names formatted according to user specifications.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>numeric.chr &lt;- c(1,2,23,24);
chr.with.prefix &lt;- c('chr1', 'chr2', 'chrX', 'chrY');
format.chromosome.notation(numeric.chr, chr.prefix = TRUE, numeric.sex.chr = FALSE);
format.chromosome.notation(chr.with.prefix, chr.prefix = FALSE, numeric.sex.chr = TRUE);
</code></pre>

<hr>
<h2 id='get.pgs.percentiles'>get.pgs.percentiles</h2><span id='topic+get.pgs.percentiles'></span>

<h3>Description</h3>

<p>Calculate percentiles and report decile and quartile ranks for a vector of polygenic scores
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.pgs.percentiles(pgs, n.percentiles = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.pgs.percentiles_+3A_pgs">pgs</code></td>
<td>
<p>numeric vector of polygenic scores</p>
</td></tr>
<tr><td><code id="get.pgs.percentiles_+3A_n.percentiles">n.percentiles</code></td>
<td>
<p>integer number of percentiles to calculate (optional)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame with columns for percentile, decile, quartile, and optional n.percentiles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(100);
get.pgs.percentiles(x, n.percentiles = 20);
</code></pre>

<hr>
<h2 id='import.pgs.weight.file'>Import PGS weight file</h2><span id='topic+import.pgs.weight.file'></span>

<h3>Description</h3>

<p>Import a PGS weight file formatted according to PGS catalog guidelines, and prepare for PGS application with <code>apply.polygenic.score()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import.pgs.weight.file(pgs.weight.path, use.harmonized.data = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="import.pgs.weight.file_+3A_pgs.weight.path">pgs.weight.path</code></td>
<td>
<p>A character string indicating the path to the pgs weight file.</p>
</td></tr>
<tr><td><code id="import.pgs.weight.file_+3A_use.harmonized.data">use.harmonized.data</code></td>
<td>
<p>A logical indicating whether the file should be formatted to indicate harmonized data columns for use in future PGS application.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the file metadata and the weight data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example pgs weight file
pgs.weight.path &lt;- system.file(
    'extdata',
    'PGS000662_hmPOS_GRCh38.txt.gz',
    package = 'ApplyPolygenicScore',
    mustWork = TRUE
    );
import.pgs.weight.file(pgs.weight.path);

# Note, harmonized data is used by default. To disable set `use.harmonized.data = FALSE`
import.pgs.weight.file(pgs.weight.path, use.harmonized.data = FALSE);
</code></pre>

<hr>
<h2 id='import.vcf'>Import VCF file</h2><span id='topic+import.vcf'></span>

<h3>Description</h3>

<p>A wrapper for the VCF import function in the vcfR package that formats VCF data for PGS application with <code>apply.polygenic.score()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import.vcf(vcf.path, info.fields = NULL, format.fields = NULL, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="import.vcf_+3A_vcf.path">vcf.path</code></td>
<td>
<p>A character string indicating the path to the VCF file to be imported.</p>
</td></tr>
<tr><td><code id="import.vcf_+3A_info.fields">info.fields</code></td>
<td>
<p>A character vector indicating the INFO fields to be imported.</p>
</td></tr>
<tr><td><code id="import.vcf_+3A_format.fields">format.fields</code></td>
<td>
<p>A character vector indicating the FORMAT fields to be imported.</p>
</td></tr>
<tr><td><code id="import.vcf_+3A_verbose">verbose</code></td>
<td>
<p>A logical indicating whether verbose output should be printed by vcfR.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing a tibble of VCF meta data and a tibble data.frame containing the parsed VCF data in long form.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example VCF
vcf &lt;- system.file(
    'extdata',
    'HG001_GIAB.vcf.gz',
    package = 'ApplyPolygenicScore',
    mustWork = TRUE
    );
vcf.data &lt;- import.vcf(vcf.path = vcf);
</code></pre>

<hr>
<h2 id='parse.pgs.input.header'>Parse PGS input file header</h2><span id='topic+parse.pgs.input.header'></span>

<h3>Description</h3>

<p>Parse metadata from a PGS input file header.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse.pgs.input.header(pgs.weight.path)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse.pgs.input.header_+3A_pgs.weight.path">pgs.weight.path</code></td>
<td>
<p>A character string indicating the path to the pgs weight file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the metadata from the file header.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example pgs weight file
pgs.weight.path &lt;- system.file(
    'extdata',
    'PGS000662_hmPOS_GRCh38.txt.gz',
    package = 'ApplyPolygenicScore',
    mustWork = TRUE
    );
parse.pgs.input.header(pgs.weight.path);
</code></pre>

<hr>
<h2 id='run.pgs.regression'>Run linear and logistic regression on a polygenic score and a set of phenotypes</h2><span id='topic+run.pgs.regression'></span>

<h3>Description</h3>

<p>Phenotype data variables are automatically classified as continuous or binary and a simple linear regression or logistic regression, respectively, is run between the polygenic score and each phenotype.
Categorical phenotypes with more than two category are ignored.
If a binary variable is not formatted as a factor, it is converted to a factor using <code>as.factor()</code> defaults. For logistic regression, the first level is classified as &quot;failure&quot; and the second &quot;success&quot; by <code>glm()</code> defaults.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run.pgs.regression(pgs, phenotype.data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="run.pgs.regression_+3A_pgs">pgs</code></td>
<td>
<p>numeric vector of polygenic scores</p>
</td></tr>
<tr><td><code id="run.pgs.regression_+3A_phenotype.data">phenotype.data</code></td>
<td>
<p>data.frame of phenotypes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame with columns for phenotype, model, beta, se, p.value, r.squared, and AUC
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(200);
pgs &lt;- rnorm(200, 0, 1);
phenotype.data &lt;- data.frame(
    continuous.pheno = rnorm(200, 1, 1),
    binary.pheno = sample(c(0, 1), 200, replace = TRUE)
    );
run.pgs.regression(pgs, phenotype.data);
</code></pre>

<hr>
<h2 id='write.apply.polygenic.score.output.to.file'>Write apply.polygenic.score output to file</h2><span id='topic+write.apply.polygenic.score.output.to.file'></span>

<h3>Description</h3>

<p>A utility function that writes the two data frames outputted by apply.polygenic.score to two tab-delimited text files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.apply.polygenic.score.output.to.file(
  apply.polygenic.score.output,
  output.dir,
  file.prefix = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write.apply.polygenic.score.output.to.file_+3A_apply.polygenic.score.output">apply.polygenic.score.output</code></td>
<td>
<p>list of two data frames: <code>pgs.output</code> and <code>regression.output</code></p>
</td></tr>
<tr><td><code id="write.apply.polygenic.score.output.to.file_+3A_output.dir">output.dir</code></td>
<td>
<p>character string of the path to write both output files</p>
</td></tr>
<tr><td><code id="write.apply.polygenic.score.output.to.file_+3A_file.prefix">file.prefix</code></td>
<td>
<p>character string of the file prefix to use for both output files</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
