<!DOCTYPE html><html><head><title>Help for package STRMPS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {STRMPS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BLMM'><p>Block length of the missing motif.</p></a></li>
<li><a href='#extractedReadsList-class'><p>Extract STR region information</p></a></li>
<li><a href='#extractedReadsListCombined-class'><p>Combined extract STR region information.</p></a></li>
<li><a href='#extractedReadsListNonCombined-class'><p>Combined extract STR region information.</p></a></li>
<li><a href='#extractedReadsListReverseComplement-class'><p>Extract STR region information of the reverse complement DNA strand.</p></a></li>
<li><a href='#findNeighbours'><p>Find neighbours</p></a></li>
<li><a href='#findNeighbours,stringCoverageGenotypeList-method'><p>Find neighbours</p></a></li>
<li><a href='#findStutter'><p>Find stutters</p></a></li>
<li><a href='#findStutter,stringCoverageGenotypeList-method'><p>Find stutters</p></a></li>
<li><a href='#flankingRegions'><p>Flanking regions</p></a></li>
<li><a href='#genotypeIdentifiedList-class'><p>Genotype list</p></a></li>
<li><a href='#genotypeList'><p>Genotype list</p></a></li>
<li><a href='#getGenotype'><p>Assigns genotype.</p></a></li>
<li><a href='#getGenotype,stringCoverageList-method'><p>Assigns genotype.</p></a></li>
<li><a href='#identifiedSTRs'><p>Identified STR regions</p></a></li>
<li><a href='#identifyNoise'><p>Idenfities the noise.</p></a></li>
<li><a href='#identifyNoise,stringCoverageList-method'><p>Idenfities the noise.</p></a></li>
<li><a href='#identifySTRRegions'><p>Identify the STR regions of a fastq-file or ShortReadQ-object.</p></a></li>
<li><a href='#identifySTRRegions,character-method'><p>Identify the STR regions of a fastq-file or ShortReadQ-object.</p></a></li>
<li><a href='#identifySTRRegions,ShortReadQ-method'><p>Identify the STR regions of a fastq-file or ShortReadQ-object.</p></a></li>
<li><a href='#identifySTRRegions.control'><p>Control function for identifySTRRegions</p></a></li>
<li><a href='#mergeGenotypeStringCoverage'><p>Merge genotypeIdentifiedList and stringCoverageList.</p></a></li>
<li><a href='#mergeGenotypeStringCoverage,genotypeIdentifiedList-method'><p>Merge genotypeIdentifiedList and stringCoverageList.</p></a></li>
<li><a href='#mergeNoiseStringCoverage'><p>Merge noiseIdentifiedList and stringCoverageList.</p></a></li>
<li><a href='#mergeNoiseStringCoverage,noiseIdentifiedList-method'><p>Merge noiseIdentifiedList and stringCoverageList.</p></a></li>
<li><a href='#neighbourList-class'><p>A neighbour list</p></a></li>
<li><a href='#noiseIdentifiedList-class'><p>Noise list</p></a></li>
<li><a href='#noiseList'><p>Noise list</p></a></li>
<li><a href='#phredQualityProbability'><p>Quality score to probability</p></a></li>
<li><a href='#phredQualityScore'><p>Convert probability to quality score</p></a></li>
<li><a href='#stringCoverage'><p>Get string coverage STR identified objects.</p></a></li>
<li><a href='#stringCoverage,extractedReadsList-method'><p>Get string coverage STR identified objects.</p></a></li>
<li><a href='#stringCoverage,extractedReadsListCombined-method'><p>Get string coverage STR identified objects.</p></a></li>
<li><a href='#stringCoverage,extractedReadsListNonCombined-method'><p>Get string coverage STR identified objects.</p></a></li>
<li><a href='#stringCoverage,extractedReadsListReverseComplement-method'><p>Get string coverage STR identified objects.</p></a></li>
<li><a href='#stringCoverage.control'><p>String coverage coontrol object</p></a></li>
<li><a href='#stringCoverageGenotypeList'><p>Combined string coverage and genotype information</p></a></li>
<li><a href='#stringCoverageGenotypeList-class'><p>Combined stringCoverage- and genotypeIdentifiedList</p></a></li>
<li><a href='#stringCoverageList'><p>Aggregated string coverage.</p></a></li>
<li><a href='#stringCoverageList-class'><p>A string coverage list</p></a></li>
<li><a href='#stringCoverageNoiseList-class'><p>Combined stringCoverage- and noiseIdentifiedList</p></a></li>
<li><a href='#STRMPSWorkflow'><p>Workflow function</p></a></li>
<li><a href='#STRMPSWorkflowBatch'><p>Batch wrapper for the workflow function</p></a></li>
<li><a href='#STRMPSWorkflowCollectStutters'><p>Collect stutters files</p></a></li>
<li><a href='#workflow.control'><p>Workflow default options</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Analysis of Short Tandem Repeat (STR) Massively Parallel
Sequencing (MPS) Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.8</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-07-01</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Author:</td>
<td>Søren B. Vilsen</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Søren B. Vilsen &lt;svilsen@math.aau.dk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Loading, identifying, aggregating, manipulating, and analysing short tandem repeat regions of massively parallel sequencing data in forensic genetics. 'STRMPS' can work with the package 'STRaitRazoR' (an R interface to the 'STRaitRazor' commandline tool) for added speed. 'STRaitRazoR' only works on linux and can found at <a href="https://github.com/svilsen/STRaitRazoR">https://github.com/svilsen/STRaitRazoR</a>. The analyses and framework implemented in this package relies on the papers of Vilsen et al. (2017) &lt;<a href="https://doi.org/10.1016%2Fj.fsigen.2017.01.017">doi:10.1016/j.fsigen.2017.01.017</a>&gt; and Vilsen et al. (2018) &lt;<a href="https://doi.org/10.1016%2Fj.fsigen.2018.04.003">doi:10.1016/j.fsigen.2018.04.003</a>&gt;. Lastly, note that the parallelisation in the package relies on mclapply() and, thus, speed-ups will only be seen on UNIX based systems.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0), Biostrings, ShortRead</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, utils, IRanges, tidyr, tibble, dplyr, stringr, purrr,
parallel</td>
</tr>
<tr>
<td>Suggests:</td>
<td>STRaitRazoR</td>
</tr>
<tr>
<td>biocViews:</td>
<td>Biostrings, ShortRead, IRanges</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-07-01 17:49:52 UTC; vilsen</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-07-02 08:30:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='BLMM'>Block length of the missing motif.</h2><span id='topic+BLMM'></span>

<h3>Description</h3>

<p>Given a motif length and a string it finds the blocks of the string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BLMM(s, motifLength = 4, returnType = "numeric")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BLMM_+3A_s">s</code></td>
<td>
<p>a string of either class: 'character' or 'DNAString'.</p>
</td></tr>
<tr><td><code id="BLMM_+3A_motiflength">motifLength</code></td>
<td>
<p>the known motif length of the STR region.</p>
</td></tr>
<tr><td><code id="BLMM_+3A_returntype">returnType</code></td>
<td>
<p>the type of return wanted. Takes three values 'numeric', 'string', or 'fullList' (or any other combination cased letters).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If returnType is 'numeric', the function returns the numeric value of the LUS.
If returnType is instead chosen as 'string', the function returns &quot;[AATG]x&quot; i.e. the motif, AATG, is repeated 'x' times.
Lastly if the returnType is set to fullList, the function returns a list of data.frames containing every possible repeat structure their start and the numeric value of the repeat unit length.
</p>


<h3>Value</h3>

<p>Depending on returnType it return an object of class 'numeric', 'string', or 'fulllist'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creating compound string 's'
stretch1 = paste0(rep("AATG", 10), collapse = "")
stretch2 = paste0(rep("ATCG", 4), collapse = "")

s = paste0(stretch1, stretch2)

# Return BLMM only
BLMM(s, motifLength = 4, returnType = "numeric")

# Return BLMM and motif of stretch
BLMM(s, motifLength = 4, returnType = "string")

# Return all blocks of 's'
BLMM(s, motifLength = 4, returnType = "fulllist")
</code></pre>

<hr>
<h2 id='extractedReadsList-class'>Extract STR region information</h2><span id='topic+extractedReadsList-class'></span>

<h3>Description</h3>

<p>Identifies the marker of the read using flanking regions and trims the read to include what is between the flanking regions.
</p>

<hr>
<h2 id='extractedReadsListCombined-class'>Combined extract STR region information.</h2><span id='topic+extractedReadsListCombined-class'></span>

<h3>Description</h3>

<p>Identifies the marker of the read for both the provided and reverse complement flanking regions. The resulting lists are then combined into a single list.
</p>

<hr>
<h2 id='extractedReadsListNonCombined-class'>Combined extract STR region information.</h2><span id='topic+extractedReadsListNonCombined-class'></span>

<h3>Description</h3>

<p>Identifies the marker of the read for both the provided and reverse complement flanking regions.
</p>

<hr>
<h2 id='extractedReadsListReverseComplement-class'>Extract STR region information of the reverse complement DNA strand.</h2><span id='topic+extractedReadsListReverseComplement-class'></span>

<h3>Description</h3>

<p>Identifies the marker of the read using reverse complement flanking regions and trims the read to include what is between the flanking regions.
</p>

<hr>
<h2 id='findNeighbours'>Find neighbours</h2><span id='topic+findNeighbours'></span>

<h3>Description</h3>

<p>Generic function for finding neighbouring strings, given identified alleles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findNeighbours(stringCoverageGenotypeListObject, searchDirection,
  trace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findNeighbours_+3A_stringcoveragegenotypelistobject">stringCoverageGenotypeListObject</code></td>
<td>
<p>A <a href="#topic+stringCoverageGenotypeList-class">stringCoverageGenotypeList-class</a> object.</p>
</td></tr>
<tr><td><code id="findNeighbours_+3A_searchdirection">searchDirection</code></td>
<td>
<p>The direction to search for neighbouring strings. Default is -1, indicating a search for '-1' stutters.</p>
</td></tr>
<tr><td><code id="findNeighbours_+3A_trace">trace</code></td>
<td>
<p>Should a trace be shown?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'neighbourList' with the neighbouring strings, in the specified direction, for the identified allele regions.
</p>

<hr>
<h2 id='findNeighbours+2CstringCoverageGenotypeList-method'>Find neighbours</h2><span id='topic+findNeighbours+2CstringCoverageGenotypeList-method'></span>

<h3>Description</h3>

<p>Generic function for finding neighbouring strings, given identified alleles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
  ## S4 method for signature 'stringCoverageGenotypeList'
findNeighbours(stringCoverageGenotypeListObject,
  searchDirection = -1, trace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findNeighbours+2B2CstringCoverageGenotypeList-method_+3A_stringcoveragegenotypelistobject">stringCoverageGenotypeListObject</code></td>
<td>
<p>A <a href="#topic+stringCoverageGenotypeList-class">stringCoverageGenotypeList-class</a> object.</p>
</td></tr>
<tr><td><code id="findNeighbours+2B2CstringCoverageGenotypeList-method_+3A_searchdirection">searchDirection</code></td>
<td>
<p>The direction to search for neighbouring strings. Default is -1, indicating a search for '-1' stutters.</p>
</td></tr>
<tr><td><code id="findNeighbours+2B2CstringCoverageGenotypeList-method_+3A_trace">trace</code></td>
<td>
<p>Should a trace be shown?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'neighbourList' with the neighbouring strings, in the specified direction, for the identified allele regions.
</p>

<hr>
<h2 id='findStutter'>Find stutters</h2><span id='topic+findStutter'></span>

<h3>Description</h3>

<p>Given identified alleles it search for '-1' stutters of the alleles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findStutter(stringCoverageGenotypeListObject, trace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findStutter_+3A_stringcoveragegenotypelistobject">stringCoverageGenotypeListObject</code></td>
<td>
<p>A <a href="#topic+stringCoverageGenotypeList-class">stringCoverageGenotypeList-class</a> object.</p>
</td></tr>
<tr><td><code id="findStutter_+3A_trace">trace</code></td>
<td>
<p>Should a trace be shown?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'neighbourList' with the stutter strings for the identified allele regions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The object returned by merging a stringCoverageList-Object
# and a genotypeList-Object.
data("stringCoverageGenotypeList")

stutterList &lt;- findStutter(stringCoverageGenotypeList)
stutterTibble &lt;- subset(do.call("rbind", stutterList), !is.na(Genotype))

stutterTibble$BlockLengthMissingMotif
stutterTibble$NeighbourRatio
</code></pre>

<hr>
<h2 id='findStutter+2CstringCoverageGenotypeList-method'>Find stutters</h2><span id='topic+findStutter+2CstringCoverageGenotypeList-method'></span>

<h3>Description</h3>

<p>Given identified alleles it search for '-1' stutters of the alleles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
  ## S4 method for signature 'stringCoverageGenotypeList'
findStutter(stringCoverageGenotypeListObject,
  trace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findStutter+2B2CstringCoverageGenotypeList-method_+3A_stringcoveragegenotypelistobject">stringCoverageGenotypeListObject</code></td>
<td>
<p>A <a href="#topic+stringCoverageGenotypeList-class">stringCoverageGenotypeList-class</a> object.</p>
</td></tr>
<tr><td><code id="findStutter+2B2CstringCoverageGenotypeList-method_+3A_trace">trace</code></td>
<td>
<p>Should a trace be shown?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'neighbourList' with the stutter strings for the identified allele regions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The object returned by merging a stringCoverageList-Object
# and a genotypeList-Object.
data("stringCoverageGenotypeList")

stutterList &lt;- findStutter(stringCoverageGenotypeList)
stutterTibble &lt;- subset(do.call("rbind", stutterList), !is.na(Genotype))

stutterTibble$BlockLengthMissingMotif
stutterTibble$NeighbourRatio
</code></pre>

<hr>
<h2 id='flankingRegions'>Flanking regions</h2><span id='topic+flankingRegions'></span>

<h3>Description</h3>

<p>The flanking regions searched for to identify the markers and STR regions of all autosomal/X/Y STR's in the Illumina ForenSeq prep kit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("flankingRegions")
</code></pre>


<h3>Format</h3>

<p>A <a href="dplyr.html#topic+tibble">tibble</a> containing the flanks (forward and reverse), motif, motif length, adjustment need to make it compatible with CE, and the shifts needed for further trimming, for each marker</p>


<h3>Author(s)</h3>

<p>Søren B. Vilsen <a href="mailto:svilsen@math.aau.dk">svilsen@math.aau.dk</a>
</p>

<hr>
<h2 id='genotypeIdentifiedList-class'>Genotype list</h2><span id='topic+genotypeIdentifiedList-class'></span>

<h3>Description</h3>

<p>A reduced stringCoverageList restricted to the identified genotypes.
</p>

<hr>
<h2 id='genotypeList'>Genotype list</h2><span id='topic+genotypeList'></span>

<h3>Description</h3>

<p>The identified genotypes of the <a href="#topic+stringCoverageList">stringCoverageList</a> data, created by the  <a href="#topic+getGenotype">getGenotype</a> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("genotypeList")
</code></pre>


<h3>Format</h3>

<p>A list of <a href="dplyr.html#topic+tibble">tibble</a>'s one for each of the 10 markers, showing which strings are the potential alleles based on the 'Coverage'.</p>


<h3>Author(s)</h3>

<p>Søren B. Vilsen <a href="mailto:svilsen@math.aau.dk">svilsen@math.aau.dk</a>
</p>

<hr>
<h2 id='getGenotype'>Assigns genotype.</h2><span id='topic+getGenotype'></span>

<h3>Description</h3>

<p><code>getGenotype</code> takes an stringCoverageList-object, assumes the sample is a reference file and assings a genotype, based on a heterozygote threshold, for every marker in the provided list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getGenotype(stringCoverageListObject, colBelief = "Coverage",
  thresholdSignal = 0, thresholdHeterozygosity = 0.35,
  thresholdAbsoluteLowerLimit = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getGenotype_+3A_stringcoveragelistobject">stringCoverageListObject</code></td>
<td>
<p>an stringCoverageList-object, created using the <a href="#topic+stringCoverage">stringCoverage</a>-function.</p>
</td></tr>
<tr><td><code id="getGenotype_+3A_colbelief">colBelief</code></td>
<td>
<p>the name of the coloumn used for identification.</p>
</td></tr>
<tr><td><code id="getGenotype_+3A_thresholdsignal">thresholdSignal</code></td>
<td>
<p>threshold applied to the signal (generally the coverage) of every string.</p>
</td></tr>
<tr><td><code id="getGenotype_+3A_thresholdheterozygosity">thresholdHeterozygosity</code></td>
<td>
<p>threshold used to determine whether a marker is hetero- or homozygous.</p>
</td></tr>
<tr><td><code id="getGenotype_+3A_thresholdabsolutelowerlimit">thresholdAbsoluteLowerLimit</code></td>
<td>
<p>a lower limit on the coverage for it to be called as an allele.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list, with an element for every marker in stringCoverageList-object, each element contains the genotype for a given marker.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Strings aggregated by 'stringCoverage()'
data("stringCoverageList")

getGenotype(stringCoverageList)
</code></pre>

<hr>
<h2 id='getGenotype+2CstringCoverageList-method'>Assigns genotype.</h2><span id='topic+getGenotype+2CstringCoverageList-method'></span>

<h3>Description</h3>

<p><code>getGenotype</code> takes an stringCoverageList-object, assumes the sample is a reference file and assings a genotype, based on a heterozygote threshold, for every marker in the provided list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'stringCoverageList'
getGenotype(stringCoverageListObject,
  colBelief = "Coverage", thresholdSignal = 0,
  thresholdHeterozygosity = 0.35, thresholdAbsoluteLowerLimit = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getGenotype+2B2CstringCoverageList-method_+3A_stringcoveragelistobject">stringCoverageListObject</code></td>
<td>
<p>an stringCoverageList-object, created using the <a href="#topic+stringCoverage">stringCoverage</a>-function.</p>
</td></tr>
<tr><td><code id="getGenotype+2B2CstringCoverageList-method_+3A_colbelief">colBelief</code></td>
<td>
<p>the name of the coloumn used for identification.</p>
</td></tr>
<tr><td><code id="getGenotype+2B2CstringCoverageList-method_+3A_thresholdsignal">thresholdSignal</code></td>
<td>
<p>threshold applied to the signal (generally the coverage) of every string.</p>
</td></tr>
<tr><td><code id="getGenotype+2B2CstringCoverageList-method_+3A_thresholdheterozygosity">thresholdHeterozygosity</code></td>
<td>
<p>threshold used to determine whether a marker is hetero- or homozygous.</p>
</td></tr>
<tr><td><code id="getGenotype+2B2CstringCoverageList-method_+3A_thresholdabsolutelowerlimit">thresholdAbsoluteLowerLimit</code></td>
<td>
<p>a lower limit on the coverage for it to be called as an allele.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list, with an element for every marker in stringCoverageList-object, each element contains the genotype for a given marker.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Strings aggregated by 'stringCoverage()'
data("stringCoverageList")

getGenotype(stringCoverageList)
</code></pre>

<hr>
<h2 id='identifiedSTRs'>Identified STR regions</h2><span id='topic+identifiedSTRs'></span>

<h3>Description</h3>

<p>The identified STR regions of the sampleSequences.fastq file, created by the  <a href="#topic+identifySTRRegions">identifySTRRegions</a> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("identifiedSTRs")
</code></pre>


<h3>Format</h3>

<p>A list with an element for each of the 10 identified markers indicating which sequences were identified for each marker.</p>


<h3>Author(s)</h3>

<p>Søren B. Vilsen <a href="mailto:svilsen@math.aau.dk">svilsen@math.aau.dk</a>
</p>

<hr>
<h2 id='identifyNoise'>Idenfities the noise.</h2><span id='topic+identifyNoise'></span>

<h3>Description</h3>

<p><code>identifyNoise</code> takes an stringCoverageList-object and identifies the noise based on a signal threshold for every marker in the provided list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>identifyNoise(stringCoverageListObject, colBelief = "Coverage",
  thresholdSignal = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="identifyNoise_+3A_stringcoveragelistobject">stringCoverageListObject</code></td>
<td>
<p>an stringCoverageList-object, created using the <a href="#topic+stringCoverage">stringCoverage</a>-function.</p>
</td></tr>
<tr><td><code id="identifyNoise_+3A_colbelief">colBelief</code></td>
<td>
<p>the name of the coloumn used for identification.</p>
</td></tr>
<tr><td><code id="identifyNoise_+3A_thresholdsignal">thresholdSignal</code></td>
<td>
<p>threshold applied to the signal (generally the coverage) of every string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list, with an element for every marker in stringCoverageList-object, each element contains the genotype for a given marker.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Strings aggregated by 'stringCoverage()'
data("stringCoverageList")

identifyNoise(stringCoverageList, thresholdSignal = 0.03)
</code></pre>

<hr>
<h2 id='identifyNoise+2CstringCoverageList-method'>Idenfities the noise.</h2><span id='topic+identifyNoise+2CstringCoverageList-method'></span>

<h3>Description</h3>

<p><code>identifyNoise</code> takes an stringCoverageList-object and identifies the noise based on a signal threshold for every marker in the provided list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'stringCoverageList'
identifyNoise(stringCoverageListObject,
  colBelief = "Coverage", thresholdSignal = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="identifyNoise+2B2CstringCoverageList-method_+3A_stringcoveragelistobject">stringCoverageListObject</code></td>
<td>
<p>an stringCoverageList-object, created using the <a href="#topic+stringCoverage">stringCoverage</a>-function.</p>
</td></tr>
<tr><td><code id="identifyNoise+2B2CstringCoverageList-method_+3A_colbelief">colBelief</code></td>
<td>
<p>the name of the coloumn used for identification.</p>
</td></tr>
<tr><td><code id="identifyNoise+2B2CstringCoverageList-method_+3A_thresholdsignal">thresholdSignal</code></td>
<td>
<p>threshold applied to the signal (generally the coverage) of every string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list, with an element for every marker in stringCoverageList-object, each element contains the genotype for a given marker.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Strings aggregated by 'stringCoverage()'
data("stringCoverageList")

identifyNoise(stringCoverageList, thresholdSignal = 0.03)
</code></pre>

<hr>
<h2 id='identifySTRRegions'>Identify the STR regions of a fastq-file or ShortReadQ-object.</h2><span id='topic+identifySTRRegions'></span>

<h3>Description</h3>

<p><code>identifySTRRegions</code> takes a fastq-file location or a ShortReadQ-object and identifies the STR regions
based on a directly adjacent flanking regions.
The function allows for mutation in the flanking regions through the numberOfMutation argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>identifySTRRegions(reads, flankingRegions, numberOfMutation, control)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="identifySTRRegions_+3A_reads">reads</code></td>
<td>
<p>either a fastq-file location or a ShortReadQ-object</p>
</td></tr>
<tr><td><code id="identifySTRRegions_+3A_flankingregions">flankingRegions</code></td>
<td>
<p>containing marker ID/name, the directly adjacent forward and reverse flanking regions, used for identification.</p>
</td></tr>
<tr><td><code id="identifySTRRegions_+3A_numberofmutation">numberOfMutation</code></td>
<td>
<p>the maximum number of mutations (base-calling errors) allowed during flanking region identification.</p>
</td></tr>
<tr><td><code id="identifySTRRegions_+3A_control">control</code></td>
<td>
<p>an <a href="#topic+identifySTRRegions.control">identifySTRRegions.control</a>-object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The returned object is a list of lists. If the reverse complement strings are not included or if the <code>control$combineLists == TRUE</code>,
a list, contains lists of untrimmed and trimmed strings for each row in <code>flankingRegions</code>. If <code>control$combineLists == FALSE</code>, the function returns a list of two such lists,
one for forward strings and one for the reverse complement strings.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("Biostrings")
library("ShortRead")

# Path to file
readPath &lt;- system.file('extdata', "sampleSequences.fastq", package = 'STRMPS')

# Flanking regions
data("flankingRegions")

# Read the file into memory
readFile &lt;- readFastq(readPath)
sread(readFile)
quality(readFile)

# Identify the STR's of the file, both readPath and readFile can be used.

identifySTRRegions(reads = readFile, flankingRegions = flankingRegions,
                   numberOfMutation = 1,
                   control = identifySTRRegions.control(
                       numberOfThreads = 1,
                       includeReverseComplement = FALSE)
                   )

</code></pre>

<hr>
<h2 id='identifySTRRegions+2Ccharacter-method'>Identify the STR regions of a fastq-file or ShortReadQ-object.</h2><span id='topic+identifySTRRegions+2Ccharacter-method'></span>

<h3>Description</h3>

<p><code>identifySTRRegions</code> takes a fastq-file location or a ShortReadQ-object and identifies the STR regions
based on a directly adjacent flanking regions.
The function allows for mutation in the flanking regions through the numberOfMutation argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'character'
identifySTRRegions(reads, flankingRegions,
  numberOfMutation = 1, control = identifySTRRegions.control())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="identifySTRRegions+2B2Ccharacter-method_+3A_reads">reads</code></td>
<td>
<p>path to fastq-file.</p>
</td></tr>
<tr><td><code id="identifySTRRegions+2B2Ccharacter-method_+3A_flankingregions">flankingRegions</code></td>
<td>
<p>containing marker ID/name, the directly adjacent forward and reverse flanking regions, used for identification.</p>
</td></tr>
<tr><td><code id="identifySTRRegions+2B2Ccharacter-method_+3A_numberofmutation">numberOfMutation</code></td>
<td>
<p>the maximum number of mutations (base-calling errors) allowed during flanking region identification.</p>
</td></tr>
<tr><td><code id="identifySTRRegions+2B2Ccharacter-method_+3A_control">control</code></td>
<td>
<p>an <a href="#topic+identifySTRRegions.control">identifySTRRegions.control</a>-object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The returned object is a list of lists. If the reverse complement strings are not included or if the <code>control$combineLists == TRUE</code>,
a list, contains lists of untrimmed and trimmed strings for each row in <code>flankingRegions</code>. If <code>control$combineLists == FALSE</code>, the function returns a list of two such lists,
one for forward strings and one for the reverse complement strings.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("Biostrings")
library("ShortRead")

# Path to file
readPath &lt;- system.file('extdata', "sampleSequences.fastq", package = 'STRMPS')

# Flanking regions
data("flankingRegions")

# Read the file into memory
readFile &lt;- readFastq(readPath)
sread(readFile)
quality(readFile)

# Identify the STR's of the file, both readPath and readFile can be used.

identifySTRRegions(reads = readFile, flankingRegions = flankingRegions,
                   numberOfMutation = 1,
                   control = identifySTRRegions.control(
                       numberOfThreads = 1,
                       includeReverseComplement = FALSE)
                   )

</code></pre>

<hr>
<h2 id='identifySTRRegions+2CShortReadQ-method'>Identify the STR regions of a fastq-file or ShortReadQ-object.</h2><span id='topic+identifySTRRegions+2CShortReadQ-method'></span>

<h3>Description</h3>

<p><code>identifySTRRegions</code> takes a fastq-file location or a ShortReadQ-object and identifies the STR regions
based on a directly adjacent flanking regions.
The function allows for mutation in the flanking regions through the numberOfMutation argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ShortReadQ'
identifySTRRegions(reads, flankingRegions,
  numberOfMutation = 1, control = identifySTRRegions.control())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="identifySTRRegions+2B2CShortReadQ-method_+3A_reads">reads</code></td>
<td>
<p>a ShortReadQ-object</p>
</td></tr>
<tr><td><code id="identifySTRRegions+2B2CShortReadQ-method_+3A_flankingregions">flankingRegions</code></td>
<td>
<p>containing marker ID/name, the directly adjacent forward and reverse flanking regions, used for identification.</p>
</td></tr>
<tr><td><code id="identifySTRRegions+2B2CShortReadQ-method_+3A_numberofmutation">numberOfMutation</code></td>
<td>
<p>the maximum number of mutations (base-calling errors) allowed during flanking region identification.</p>
</td></tr>
<tr><td><code id="identifySTRRegions+2B2CShortReadQ-method_+3A_control">control</code></td>
<td>
<p>an <a href="#topic+identifySTRRegions.control">identifySTRRegions.control</a>-object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The returned object is a list of lists. If the reverse complement strings are not included or if the <code>control$combineLists == TRUE</code>,
a list, contains lists of untrimmed and trimmed strings for each row in <code>flankingRegions</code>. If <code>control$combineLists == FALSE</code>, the function returns a list of two such lists,
one for forward strings and one for the reverse complement strings.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("Biostrings")
library("ShortRead")

# Path to file
readPath &lt;- system.file('extdata', "sampleSequences.fastq", package = 'STRMPS')

# Flanking regions
data("flankingRegions")

# Read the file into memory
readFile &lt;- readFastq(readPath)
sread(readFile)
quality(readFile)

# Identify the STR's of the file, both readPath and readFile can be used.

identifySTRRegions(reads = readFile, flankingRegions = flankingRegions,
                   numberOfMutation = 1,
                   control = identifySTRRegions.control(
                       numberOfThreads = 1,
                       includeReverseComplement = FALSE)
                   )

</code></pre>

<hr>
<h2 id='identifySTRRegions.control'>Control function for identifySTRRegions</h2><span id='topic+identifySTRRegions.control'></span>

<h3>Description</h3>

<p>A list containing default parameters passed to the <a href="#topic+identifySTRRegions">identifySTRRegions</a> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>identifySTRRegions.control(colList = NULL, numberOfThreads = 4L,
  reversed = TRUE, includeReverseComplement = TRUE, combineLists = TRUE,
  removeEmptyMarkers = TRUE, matchPatternMethod = "mclapply")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="identifySTRRegions.control_+3A_collist">colList</code></td>
<td>
<p>The position of the forward, reverse, and motifLength columns in the flanking region tibble/data.frame. If 'NULL' a function searches for the words 'forward', 'reverse', and 'motif' ot identify the columns.</p>
</td></tr>
<tr><td><code id="identifySTRRegions.control_+3A_numberofthreads">numberOfThreads</code></td>
<td>
<p>The number of threads used by mclapply (stuck at '2' on windows).</p>
</td></tr>
<tr><td><code id="identifySTRRegions.control_+3A_reversed">reversed</code></td>
<td>
<p>TRUE/FALSE: In a revrse complementary run, should the strings/quality be reversed (recommended)?</p>
</td></tr>
<tr><td><code id="identifySTRRegions.control_+3A_includereversecomplement">includeReverseComplement</code></td>
<td>
<p>TRUE/FALSE: Should the function also search for the reverse complement DNA strand (recommended)?</p>
</td></tr>
<tr><td><code id="identifySTRRegions.control_+3A_combinelists">combineLists</code></td>
<td>
<p>TRUE/FALSE: If 'includeReverseComplement' is TRUE, should the sets be combined?</p>
</td></tr>
<tr><td><code id="identifySTRRegions.control_+3A_removeemptymarkers">removeEmptyMarkers</code></td>
<td>
<p>TRUE/FALSE: Should markers returning no identified regions be removed?</p>
</td></tr>
<tr><td><code id="identifySTRRegions.control_+3A_matchpatternmethod">matchPatternMethod</code></td>
<td>
<p>Which method should be used to identify the flanking regions (only 'mclapply' implemented at the moment)?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A control list setting default behaviour.
</p>

<hr>
<h2 id='mergeGenotypeStringCoverage'>Merge genotypeIdentifiedList and stringCoverageList.</h2><span id='topic+mergeGenotypeStringCoverage'></span>

<h3>Description</h3>

<p><code>mergeGenotypeStringCoverage</code> merges genotypeIdentifiedList-objects and stringCoverageList-objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeGenotypeStringCoverage(stringCoverageListObject,
  noiseGenotypeIdentifiedListObject)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeGenotypeStringCoverage_+3A_stringcoveragelistobject">stringCoverageListObject</code></td>
<td>
<p>a stringCoverageList-object, created using the <a href="#topic+stringCoverage">stringCoverage</a>-function.</p>
</td></tr>
<tr><td><code id="mergeGenotypeStringCoverage_+3A_noisegenotypeidentifiedlistobject">noiseGenotypeIdentifiedListObject</code></td>
<td>
<p>a noiseGenotypeIdentifiedList-object, created using the <a href="#topic+getGenotype">getGenotype</a>-function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list, with an element for every marker in extractedReadsList-object, each element contains the string coverage of all unique strings of a given marker.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Strings aggregated by 'stringCoverage()'
data("stringCoverageList")
# Genotypes identified by 'getGenotype()'
data("genotypeList")
# Noise identified by 'identifyNoise()'
data("noiseList")

mergeGenotypeStringCoverage(stringCoverageList, genotypeList)
mergeNoiseStringCoverage(stringCoverageList, noiseList)
</code></pre>

<hr>
<h2 id='mergeGenotypeStringCoverage+2CgenotypeIdentifiedList-method'>Merge genotypeIdentifiedList and stringCoverageList.</h2><span id='topic+mergeGenotypeStringCoverage+2CgenotypeIdentifiedList-method'></span>

<h3>Description</h3>

<p><code>mergeGenotypeStringCoverage</code> merges genotypeIdentifiedList-objects and stringCoverageList-objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
  ## S4 method for signature 'genotypeIdentifiedList'
mergeGenotypeStringCoverage(stringCoverageListObject,
  noiseGenotypeIdentifiedListObject)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeGenotypeStringCoverage+2B2CgenotypeIdentifiedList-method_+3A_stringcoveragelistobject">stringCoverageListObject</code></td>
<td>
<p>a stringCoverageList-object, created using the <a href="#topic+stringCoverage">stringCoverage</a>-function.</p>
</td></tr>
<tr><td><code id="mergeGenotypeStringCoverage+2B2CgenotypeIdentifiedList-method_+3A_noisegenotypeidentifiedlistobject">noiseGenotypeIdentifiedListObject</code></td>
<td>
<p>a noiseGenotypeIdentifiedList-object, created using the <a href="#topic+getGenotype">getGenotype</a>-function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list, with an element for every marker in extractedReadsList-object, each element contains the string coverage of all unique strings of a given marker.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Strings aggregated by 'stringCoverage()'
data("stringCoverageList")
# Genotypes identified by 'getGenotype()'
data("genotypeList")
# Noise identified by 'identifyNoise()'
data("noiseList")

mergeGenotypeStringCoverage(stringCoverageList, genotypeList)
mergeNoiseStringCoverage(stringCoverageList, noiseList)
</code></pre>

<hr>
<h2 id='mergeNoiseStringCoverage'>Merge noiseIdentifiedList and stringCoverageList.</h2><span id='topic+mergeNoiseStringCoverage'></span>

<h3>Description</h3>

<p><code>mergeNoiseStringCoverage</code> merges noiseIdentifiedList-objects and stringCoverageList-objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeNoiseStringCoverage(stringCoverageListObject,
  noiseGenotypeIdentifiedListObject)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeNoiseStringCoverage_+3A_stringcoveragelistobject">stringCoverageListObject</code></td>
<td>
<p>a stringCoverageList-object, created using the <a href="#topic+stringCoverage">stringCoverage</a>-function.</p>
</td></tr>
<tr><td><code id="mergeNoiseStringCoverage_+3A_noisegenotypeidentifiedlistobject">noiseGenotypeIdentifiedListObject</code></td>
<td>
<p>a noiseGenotypeIdentifiedList-object, created using the <a href="#topic+identifyNoise">identifyNoise</a>-function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list, with an element for every marker in extractedReadsList-object, each element contains the string coverage of all unique strings of a given marker.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Strings aggregated by 'stringCoverage()'
data("stringCoverageList")
# Genotypes identified by 'getGenotype()'
data("genotypeList")
# Noise identified by 'identifyNoise()'
data("noiseList")

mergeGenotypeStringCoverage(stringCoverageList, genotypeList)
mergeNoiseStringCoverage(stringCoverageList, noiseList)
</code></pre>

<hr>
<h2 id='mergeNoiseStringCoverage+2CnoiseIdentifiedList-method'>Merge noiseIdentifiedList and stringCoverageList.</h2><span id='topic+mergeNoiseStringCoverage+2CnoiseIdentifiedList-method'></span>

<h3>Description</h3>

<p><code>mergeNoiseStringCoverage</code> merges noiseIdentifiedList-objects and stringCoverageList-objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
  ## S4 method for signature 'noiseIdentifiedList'
mergeNoiseStringCoverage(stringCoverageListObject,
  noiseGenotypeIdentifiedListObject)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeNoiseStringCoverage+2B2CnoiseIdentifiedList-method_+3A_stringcoveragelistobject">stringCoverageListObject</code></td>
<td>
<p>a stringCoverageList-object, created using the <a href="#topic+stringCoverage">stringCoverage</a>-function.</p>
</td></tr>
<tr><td><code id="mergeNoiseStringCoverage+2B2CnoiseIdentifiedList-method_+3A_noisegenotypeidentifiedlistobject">noiseGenotypeIdentifiedListObject</code></td>
<td>
<p>a noiseGenotypeIdentifiedList-object, created using the <a href="#topic+identifyNoise">identifyNoise</a>-function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list, with an element for every marker in extractedReadsList-object, each element contains the string coverage of all unique strings of a given marker.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Strings aggregated by 'stringCoverage()'
data("stringCoverageList")
# Genotypes identified by 'getGenotype()'
data("genotypeList")
# Noise identified by 'identifyNoise()'
data("noiseList")

mergeGenotypeStringCoverage(stringCoverageList, genotypeList)
mergeNoiseStringCoverage(stringCoverageList, noiseList)
</code></pre>

<hr>
<h2 id='neighbourList-class'>A neighbour list</h2><span id='topic+neighbourList-class'></span>

<h3>Description</h3>

<p>A list of the identified neightbours of the called alleles in a stringCoverageGenotypeList
</p>

<hr>
<h2 id='noiseIdentifiedList-class'>Noise list</h2><span id='topic+noiseIdentifiedList-class'></span>

<h3>Description</h3>

<p>Creates a flag to the sequences in a stringCoverageList which cloud be classified as noise.
</p>

<hr>
<h2 id='noiseList'>Noise list</h2><span id='topic+noiseList'></span>

<h3>Description</h3>

<p>The identified noise of the <a href="#topic+stringCoverageList">stringCoverageList</a> data, created by the  <a href="#topic+identifyNoise">identifyNoise</a> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("noiseList")
</code></pre>


<h3>Format</h3>

<p>A list of <a href="dplyr.html#topic+tibble">tibble</a>'s one for each of the 10 markers, showing which strings can be safely classified as noise based on the 'Coverage'.</p>


<h3>Author(s)</h3>

<p>Søren B. Vilsen <a href="mailto:svilsen@math.aau.dk">svilsen@math.aau.dk</a>
</p>

<hr>
<h2 id='phredQualityProbability'>Quality score to probability</h2><span id='topic+phredQualityProbability'></span><span id='topic+solexaQualityProbability'></span><span id='topic+solexaQualityProbability'></span>

<h3>Description</h3>

<p>Converts a quality score (Phred or Solexa) to a probability of error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phredQualityProbability(q)

solexaQualityProbability(q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phredQualityProbability_+3A_q">q</code></td>
<td>
<p>Quality score.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>phredQualityScore(q_phred)</code> and <code>solexaQualityScore(q_solexa)</code> returns a probability of error.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>q_phred = phredQualityScore(1e-3)
q_solexa = solexaQualityScore(1e-3)

phredQualityProbability(q_phred)
solexaQualityProbability(q_solexa)
</code></pre>

<hr>
<h2 id='phredQualityScore'>Convert probability to quality score</h2><span id='topic+phredQualityScore'></span><span id='topic+solexaQualityScore'></span><span id='topic+solexaQualityScore'></span>

<h3>Description</h3>

<p>Calculates the quality score (Phred or Solexa) given a probability of error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phredQualityScore(p)

solexaQualityScore(p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phredQualityScore_+3A_p">p</code></td>
<td>
<p>Probability of error.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>phredQualityScore(p)</code> returns a Phred quality score.
</p>
<p><code>solexaQualityScore(p)</code> returns a Solexa quality score.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- 1e-3
phredQualityScore(p)
solexaQualityScore(p)
</code></pre>

<hr>
<h2 id='stringCoverage'>Get string coverage STR identified objects.</h2><span id='topic+stringCoverage'></span>

<h3>Description</h3>

<p><code>stringCoverage</code> takes an extractedReadsList-object and finds the coverage of every unique string for every marker in the provided list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stringCoverage(extractedReadsListObject, control = stringCoverage.control())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stringCoverage_+3A_extractedreadslistobject">extractedReadsListObject</code></td>
<td>
<p>an extractedReadsList-object, created using the <a href="#topic+identifySTRRegions">identifySTRRegions</a>-function.</p>
</td></tr>
<tr><td><code id="stringCoverage_+3A_control">control</code></td>
<td>
<p>an <a href="#topic+stringCoverage.control">stringCoverage.control</a>-object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list, with an element for every marker in extractedReadsList-object, each element contains the string coverage of all unique strings of a given marker.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Regions identified using 'identifySTRs()'
data("identifiedSTRs")

# Limiting and restructuring
sortedIncludedMarkers &lt;- sapply(names(identifiedSTRs$identifiedMarkersSequencesUniquelyAssigned),
                                function(m) which(m == flankingRegions$Marker))

# Aggregate the strings
stringCoverage(extractedReadsListObject = identifiedSTRs,
               control = stringCoverage.control(
                   motifLength = flankingRegions$MotifLength[sortedIncludedMarkers],
                   Type = flankingRegions$Type[sortedIncludedMarkers],
                   numberOfThreads = 1,
                   trace = FALSE,
                   simpleReturn = TRUE))
</code></pre>

<hr>
<h2 id='stringCoverage+2CextractedReadsList-method'>Get string coverage STR identified objects.</h2><span id='topic+stringCoverage+2CextractedReadsList-method'></span>

<h3>Description</h3>

<p><code>stringCoverage</code> takes an extractedReadsList-object and finds the coverage of every unique string for every marker in the provided list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'extractedReadsList'
stringCoverage(extractedReadsListObject,
  control = stringCoverage.control())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stringCoverage+2B2CextractedReadsList-method_+3A_extractedreadslistobject">extractedReadsListObject</code></td>
<td>
<p>an extractedReadsList-object, created using the <a href="#topic+identifySTRRegions">identifySTRRegions</a>-function.</p>
</td></tr>
<tr><td><code id="stringCoverage+2B2CextractedReadsList-method_+3A_control">control</code></td>
<td>
<p>an <a href="#topic+stringCoverage.control">stringCoverage.control</a>-object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list, with an element for every marker in extractedReadsList-object, each element contains the string coverage of all unique strings of a given marker.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Regions identified using 'identifySTRs()'
data("identifiedSTRs")

# Limiting and restructuring
sortedIncludedMarkers &lt;- sapply(names(identifiedSTRs$identifiedMarkersSequencesUniquelyAssigned),
                                function(m) which(m == flankingRegions$Marker))

# Aggregate the strings
stringCoverage(extractedReadsListObject = identifiedSTRs,
               control = stringCoverage.control(
                   motifLength = flankingRegions$MotifLength[sortedIncludedMarkers],
                   Type = flankingRegions$Type[sortedIncludedMarkers],
                   numberOfThreads = 1,
                   trace = FALSE,
                   simpleReturn = TRUE))
</code></pre>

<hr>
<h2 id='stringCoverage+2CextractedReadsListCombined-method'>Get string coverage STR identified objects.</h2><span id='topic+stringCoverage+2CextractedReadsListCombined-method'></span>

<h3>Description</h3>

<p><code>stringCoverage</code> takes an extractedReadsList-object and finds the coverage of every unique string for every marker in the provided list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'extractedReadsListCombined'
stringCoverage(extractedReadsListObject,
  control = stringCoverage.control())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stringCoverage+2B2CextractedReadsListCombined-method_+3A_extractedreadslistobject">extractedReadsListObject</code></td>
<td>
<p>an extractedReadsList-object, created using the <a href="#topic+identifySTRRegions">identifySTRRegions</a>-function.</p>
</td></tr>
<tr><td><code id="stringCoverage+2B2CextractedReadsListCombined-method_+3A_control">control</code></td>
<td>
<p>an <a href="#topic+stringCoverage.control">stringCoverage.control</a>-object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list, with an element for every marker in extractedReadsList-object, each element contains the string coverage of all unique strings of a given marker.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Regions identified using 'identifySTRs()'
data("identifiedSTRs")

# Limiting and restructuring
sortedIncludedMarkers &lt;- sapply(names(identifiedSTRs$identifiedMarkersSequencesUniquelyAssigned),
                                function(m) which(m == flankingRegions$Marker))

# Aggregate the strings
stringCoverage(extractedReadsListObject = identifiedSTRs,
               control = stringCoverage.control(
                   motifLength = flankingRegions$MotifLength[sortedIncludedMarkers],
                   Type = flankingRegions$Type[sortedIncludedMarkers],
                   numberOfThreads = 1,
                   trace = FALSE,
                   simpleReturn = TRUE))
</code></pre>

<hr>
<h2 id='stringCoverage+2CextractedReadsListNonCombined-method'>Get string coverage STR identified objects.</h2><span id='topic+stringCoverage+2CextractedReadsListNonCombined-method'></span>

<h3>Description</h3>

<p><code>stringCoverage</code> takes an extractedReadsList-object and finds the coverage of every unique string for every marker in the provided list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
  ## S4 method for signature 'extractedReadsListNonCombined'
stringCoverage(extractedReadsListObject,
  control = stringCoverage.control())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stringCoverage+2B2CextractedReadsListNonCombined-method_+3A_extractedreadslistobject">extractedReadsListObject</code></td>
<td>
<p>an extractedReadsList-object, created using the <a href="#topic+identifySTRRegions">identifySTRRegions</a>-function.</p>
</td></tr>
<tr><td><code id="stringCoverage+2B2CextractedReadsListNonCombined-method_+3A_control">control</code></td>
<td>
<p>an <a href="#topic+stringCoverage.control">stringCoverage.control</a>-object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list, with an element for every marker in extractedReadsList-object, each element contains the string coverage of all unique strings of a given marker.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Regions identified using 'identifySTRs()'
data("identifiedSTRs")

# Limiting and restructuring
sortedIncludedMarkers &lt;- sapply(names(identifiedSTRs$identifiedMarkersSequencesUniquelyAssigned),
                                function(m) which(m == flankingRegions$Marker))

# Aggregate the strings
stringCoverage(extractedReadsListObject = identifiedSTRs,
               control = stringCoverage.control(
                   motifLength = flankingRegions$MotifLength[sortedIncludedMarkers],
                   Type = flankingRegions$Type[sortedIncludedMarkers],
                   numberOfThreads = 1,
                   trace = FALSE,
                   simpleReturn = TRUE))
</code></pre>

<hr>
<h2 id='stringCoverage+2CextractedReadsListReverseComplement-method'>Get string coverage STR identified objects.</h2><span id='topic+stringCoverage+2CextractedReadsListReverseComplement-method'></span>

<h3>Description</h3>

<p><code>stringCoverage</code> takes an extractedReadsList-object and finds the coverage of every unique string for every marker in the provided list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
  ## S4 method for signature 'extractedReadsListReverseComplement'
stringCoverage(extractedReadsListObject,
  control = stringCoverage.control())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stringCoverage+2B2CextractedReadsListReverseComplement-method_+3A_extractedreadslistobject">extractedReadsListObject</code></td>
<td>
<p>an extractedReadsList-object, created using the <a href="#topic+identifySTRRegions">identifySTRRegions</a>-function.</p>
</td></tr>
<tr><td><code id="stringCoverage+2B2CextractedReadsListReverseComplement-method_+3A_control">control</code></td>
<td>
<p>an <a href="#topic+stringCoverage.control">stringCoverage.control</a>-object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list, with an element for every marker in extractedReadsList-object, each element contains the string coverage of all unique strings of a given marker.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Regions identified using 'identifySTRs()'
data("identifiedSTRs")

# Limiting and restructuring
sortedIncludedMarkers &lt;- sapply(names(identifiedSTRs$identifiedMarkersSequencesUniquelyAssigned),
                                function(m) which(m == flankingRegions$Marker))

# Aggregate the strings
stringCoverage(extractedReadsListObject = identifiedSTRs,
               control = stringCoverage.control(
                   motifLength = flankingRegions$MotifLength[sortedIncludedMarkers],
                   Type = flankingRegions$Type[sortedIncludedMarkers],
                   numberOfThreads = 1,
                   trace = FALSE,
                   simpleReturn = TRUE))
</code></pre>

<hr>
<h2 id='stringCoverage.control'>String coverage coontrol object</h2><span id='topic+stringCoverage.control'></span>

<h3>Description</h3>

<p>String coverage coontrol object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stringCoverage.control(motifLength = 4, Type = "AUTOSOMAL",
  simpleReturn = TRUE, includeLUS = FALSE, numberOfThreads = 4L,
  meanFunction = mean, includeAverageBaseQuality = FALSE, trace = FALSE,
  uniquelyAssigned = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stringCoverage.control_+3A_motiflength">motifLength</code></td>
<td>
<p>The motif lengths of each marker.</p>
</td></tr>
<tr><td><code id="stringCoverage.control_+3A_type">Type</code></td>
<td>
<p>The chromosome type of each marker (autosomal, X, or Y).</p>
</td></tr>
<tr><td><code id="stringCoverage.control_+3A_simplereturn">simpleReturn</code></td>
<td>
<p>TRUE/FALSE: Should the returned object be simplified?</p>
</td></tr>
<tr><td><code id="stringCoverage.control_+3A_includelus">includeLUS</code></td>
<td>
<p>TRUE/FALSE: Should the LUS of each region be calculated?</p>
</td></tr>
<tr><td><code id="stringCoverage.control_+3A_numberofthreads">numberOfThreads</code></td>
<td>
<p>The number of cores used for parallelisation.</p>
</td></tr>
<tr><td><code id="stringCoverage.control_+3A_meanfunction">meanFunction</code></td>
<td>
<p>The function used to average the base qualities.</p>
</td></tr>
<tr><td><code id="stringCoverage.control_+3A_includeaveragebasequality">includeAverageBaseQuality</code></td>
<td>
<p>Should the average base quality of the region be included?</p>
</td></tr>
<tr><td><code id="stringCoverage.control_+3A_trace">trace</code></td>
<td>
<p>TRUE/FALSE: Show trace?</p>
</td></tr>
<tr><td><code id="stringCoverage.control_+3A_uniquelyassigned">uniquelyAssigned</code></td>
<td>
<p>TRUE/FALSE: Should regions not uniquely assigned be removed?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Control function for the 'stringCoverage' function. Sets default values for the parameters.
</p>


<h3>Value</h3>

<p>List of parameters used for the 'stringCoverage' function.
</p>

<hr>
<h2 id='stringCoverageGenotypeList'>Combined string coverage and genotype information</h2><span id='topic+stringCoverageGenotypeList'></span>

<h3>Description</h3>

<p>A merge of the <a href="#topic+stringCoverageList">stringCoverageList</a> and <a href="#topic+genotypeList">genotypeList</a> data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("stringCoverageGenotypeList")
</code></pre>


<h3>Format</h3>

<p>A list of <a href="dplyr.html#topic+tibble">tibble</a>'s one for each of the 10 markers containing the combined string coverage and genotypic information.</p>


<h3>Author(s)</h3>

<p>Søren B. Vilsen <a href="mailto:svilsen@math.aau.dk">svilsen@math.aau.dk</a>
</p>

<hr>
<h2 id='stringCoverageGenotypeList-class'>Combined stringCoverage- and genotypeIdentifiedList</h2><span id='topic+stringCoverageGenotypeList-class'></span>

<h3>Description</h3>

<p>Merges a stringCoverageList with a genotypeIdentifiedList.
</p>

<hr>
<h2 id='stringCoverageList'>Aggregated string coverage.</h2><span id='topic+stringCoverageList'></span>

<h3>Description</h3>

<p>The aggregated string coverage of the <a href="#topic+identifiedSTRs">identifiedSTRs</a> data, created by the  <a href="#topic+stringCoverage">stringCoverage</a> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("stringCoverageList")
</code></pre>


<h3>Format</h3>

<p>A list of <a href="dplyr.html#topic+tibble">tibble</a>'s one for each of the 10 markers, showing the aggregated information on a string-by-string basis.</p>


<h3>Author(s)</h3>

<p>Søren B. Vilsen <a href="mailto:svilsen@math.aau.dk">svilsen@math.aau.dk</a>
</p>

<hr>
<h2 id='stringCoverageList-class'>A string coverage list</h2><span id='topic+stringCoverageList-class'></span>

<h3>Description</h3>

<p>A list of tibbles, one for every marker, used to contain the sequencing information of STR MPS data.
The tibbles should include columns with the following names: &quot;Marker&quot;, &quot;BasePairs&quot;, &quot;Allele&quot;, &quot;Type&quot;, &quot;MotifLength&quot;, &quot;ForwardFlank&quot;, &quot;Region&quot;, &quot;ReverseFlank&quot;, &quot;Coverage&quot;, &quot;AggregateQuality&quot;, and &quot;Quality&quot;.
</p>

<hr>
<h2 id='stringCoverageNoiseList-class'>Combined stringCoverage- and noiseIdentifiedList</h2><span id='topic+stringCoverageNoiseList-class'></span>

<h3>Description</h3>

<p>Merges a stringCoverageList with a noiseIdentifiedList
</p>

<hr>
<h2 id='STRMPSWorkflow'>Workflow function</h2><span id='topic+STRMPSWorkflow'></span>

<h3>Description</h3>

<p>The function takes an input file and performs all preliminary analyses.
The function creates a series of objects which can be further analysed.
An output folder can be provided to store the objects as <code>.RData</code>-files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>STRMPSWorkflow(input, output = NULL, continueCheckpoint = NULL,
  control = workflow.control())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="STRMPSWorkflow_+3A_input">input</code></td>
<td>
<p>A path to a <code>.fastq</code>-file.</p>
</td></tr>
<tr><td><code id="STRMPSWorkflow_+3A_output">output</code></td>
<td>
<p>A directory where output-files are stored.</p>
</td></tr>
<tr><td><code id="STRMPSWorkflow_+3A_continuecheckpoint">continueCheckpoint</code></td>
<td>
<p>Choose a checkpoint to continue from in the workflow. If NULL the function will run the entire workflow.</p>
</td></tr>
<tr><td><code id="STRMPSWorkflow_+3A_control">control</code></td>
<td>
<p>Function controlling non-crucial parameters and other control functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If 'output' not provided the function simply returns the stringCoverageList-object.
If an output is provided the function will store ALL created objects at the output-path, i.e. nothing is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>readPath &lt;- system.file('extdata', 'sampleSequences.fastq', package = 'STRMPS')

STRMPSWorkflow(readPath,
               control = workflow.control(restrictType = "Autosomal",
                                          numberOfThreads = 1)
               )

</code></pre>

<hr>
<h2 id='STRMPSWorkflowBatch'>Batch wrapper for the workflow function</h2><span id='topic+STRMPSWorkflowBatch'></span>

<h3>Description</h3>

<p>The function takes an input directory and performs the entire analysis workflow described in (ADD REF).
The function creates a series of objects needed for further analyses and stores them at the output location.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>STRMPSWorkflowBatch(input, output, ignorePattern = NULL,
  continueCheckpoint = NULL, control = workflow.control())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="STRMPSWorkflowBatch_+3A_input">input</code></td>
<td>
<p>A directory where fastq input-files are stored.</p>
</td></tr>
<tr><td><code id="STRMPSWorkflowBatch_+3A_output">output</code></td>
<td>
<p>A directory where output-files are stored.</p>
</td></tr>
<tr><td><code id="STRMPSWorkflowBatch_+3A_ignorepattern">ignorePattern</code></td>
<td>
<p>A pattern parsed to grepl used to filter input strings.</p>
</td></tr>
<tr><td><code id="STRMPSWorkflowBatch_+3A_continuecheckpoint">continueCheckpoint</code></td>
<td>
<p>Choose a checkpoint to continue from in the workflow. If NULL the function will run the entire workflow.</p>
</td></tr>
<tr><td><code id="STRMPSWorkflowBatch_+3A_control">control</code></td>
<td>
<p>Function controlling non-crucial parameters and other control functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If 'output' not provided the function simply returns the stringCoverageList-object.
If an output is provided the function will store ALL created objects at the output-path, i.e. nothing is returned.
</p>

<hr>
<h2 id='STRMPSWorkflowCollectStutters'>Collect stutters files</h2><span id='topic+STRMPSWorkflowCollectStutters'></span>

<h3>Description</h3>

<p>Collects all stutter files created by the batch version of the <a href="#topic+STRMPSWorkflow">STRMPSWorkflow</a> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>STRMPSWorkflowCollectStutters(stutterDirectory, storeCollection = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="STRMPSWorkflowCollectStutters_+3A_stutterdirectory">stutterDirectory</code></td>
<td>
<p>The out most directory containing all stutter files to be collected.</p>
</td></tr>
<tr><td><code id="STRMPSWorkflowCollectStutters_+3A_storecollection">storeCollection</code></td>
<td>
<p>TRUE/FALSE: Should the collected tibble be stored? If 'FALSE' the tibble is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If 'storeCollection' is TRUE nothing is returned, else the stutter collection is returned.
</p>

<hr>
<h2 id='workflow.control'>Workflow default options</h2><span id='topic+workflow.control'></span>

<h3>Description</h3>

<p>Control object for workflow function returning a list of default parameter options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>workflow.control(numberOfMutations = 1, numberOfThreads = 4,
  createdThresholdSignal = 0.05, thresholdHomozygote = 0.4,
  internalTrace = FALSE, simpleReturn = TRUE, identifyNoise = FALSE,
  identifyStutter = FALSE, flankingRegions = NULL, useSTRaitRazor = FALSE,
  trimRegions = TRUE, restrictType = NULL, trace = TRUE,
  variantDatabase = NULL, reduceSize = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="workflow.control_+3A_numberofmutations">numberOfMutations</code></td>
<td>
<p>The maximum number of mutations (base-calling errors) allowed during flanking region identification.</p>
</td></tr>
<tr><td><code id="workflow.control_+3A_numberofthreads">numberOfThreads</code></td>
<td>
<p>The number of threads used by either the <a href="parallel.html#topic+mclapply">mclapply</a>-function (stuck at '2' on windows) or STRaitRazor.</p>
</td></tr>
<tr><td><code id="workflow.control_+3A_createdthresholdsignal">createdThresholdSignal</code></td>
<td>
<p>Noise threshold.</p>
</td></tr>
<tr><td><code id="workflow.control_+3A_thresholdhomozygote">thresholdHomozygote</code></td>
<td>
<p>Homozygote threshold for genotype identiication.</p>
</td></tr>
<tr><td><code id="workflow.control_+3A_internaltrace">internalTrace</code></td>
<td>
<p>Show trace.</p>
</td></tr>
<tr><td><code id="workflow.control_+3A_simplereturn">simpleReturn</code></td>
<td>
<p>TRUE/FALSE: Should the regions be aggregated without including flanking regions?</p>
</td></tr>
<tr><td><code id="workflow.control_+3A_identifynoise">identifyNoise</code></td>
<td>
<p>TRUE/FALSE: Should noise be identified.</p>
</td></tr>
<tr><td><code id="workflow.control_+3A_identifystutter">identifyStutter</code></td>
<td>
<p>TRUE/FALSE: Should stutters be identified.</p>
</td></tr>
<tr><td><code id="workflow.control_+3A_flankingregions">flankingRegions</code></td>
<td>
<p>The flanking regions used to identify the STR regions. If 'NULL' a default set is loaded and used.</p>
</td></tr>
<tr><td><code id="workflow.control_+3A_usestraitrazor">useSTRaitRazor</code></td>
<td>
<p>TRUE/FALSE: Should the STRaitRazor command line tool (only linux is implemented) be used for flanking region identification.</p>
</td></tr>
<tr><td><code id="workflow.control_+3A_trimregions">trimRegions</code></td>
<td>
<p>TRUE/FALSE: Should the identified regions be further trimmed.</p>
</td></tr>
<tr><td><code id="workflow.control_+3A_restricttype">restrictType</code></td>
<td>
<p>A character vector specifying the marker 'Types' to be identified.</p>
</td></tr>
<tr><td><code id="workflow.control_+3A_trace">trace</code></td>
<td>
<p>TRUE/FALSE: Should a trace be shown?</p>
</td></tr>
<tr><td><code id="workflow.control_+3A_variantdatabase">variantDatabase</code></td>
<td>
<p>A <a href="dplyr.html#topic+tibble">tibble</a> of 'trusted' STR regions.</p>
</td></tr>
<tr><td><code id="workflow.control_+3A_reducesize">reduceSize</code></td>
<td>
<p>TRUE/FALSE: Should the size of the data-set be reduced using the quality and the variant database?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of default of options.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
