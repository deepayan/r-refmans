<!DOCTYPE html><html><head><title>Help for package MLVSBM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MLVSBM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#ARI'><p>Compare two clustering with the Adjusted Rand Index</p></a></li>
<li><a href='#build_fold_matrix'><p>Title</p></a></li>
<li><a href='#coef.FitMLVSBM'><p>Extract model coefficients</p></a></li>
<li><a href='#FitMLVSBM'><p>An R6 Class object, a fitted multilevel network once $dovem() is done</p></a></li>
<li><a href='#FitSBM'><p>An R6 Class object for unilevel network</p></a></li>
<li><a href='#hierarClust'><p>Perform a Hierarchical Clustering</p></a></li>
<li><a href='#merge_clust'><p>Merge a list of clusters</p></a></li>
<li><a href='#MLVSBM'><p>R6Class for multilevel object</p></a></li>
<li><a href='#mlvsbm_create_network'><p>Create a MLVSBM object from observed data</p></a></li>
<li><a href='#mlvsbm_estimate_network'><p>Infer a multilevel network (MLVSBM object), the original object is modified</p></a></li>
<li><a href='#mlvsbm_log_likelihood'><p>Compute the complete log likelihood of a multilevel network for a given</p>
clustering of the nodes.</a></li>
<li><a href='#mlvsbm_simulate_network'><p>Create a simulated multilevel network (MLVSBM object)</p></a></li>
<li><a href='#plot.FitMLVSBM'><p>Multilevel SBM Plot</p></a></li>
<li><a href='#predict.FitMLVSBM'><p>Model Predictions</p></a></li>
<li><a href='#simulate_adjacency'><p>Simulation an adjacency matrix</p></a></li>
<li><a href='#simulate_affiliation'><p>Simulate of matrix of affiliation</p></a></li>
<li><a href='#spcClust'><p>Perform a spectral clustering</p></a></li>
<li><a href='#split_clust'><p>Merge a list of clusters</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Stochastic Block Model for Multilevel Networks</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.4</td>
</tr>
<tr>
<td>Description:</td>
<td>Simulation, inference and clustering of multilevel networks using a
    Stochastic Block Model framework as described in Chabert-Liddell, Barbillon,
    Donnet and Lazega (2021) &lt;<a href="https://doi.org/10.1016%2Fj.csda.2021.107179">doi:10.1016/j.csda.2021.107179</a>&gt;. 
    A multilevel network is defined as the junction of two interaction networks, 
    the upper level or inter-organizational level and the lower level or 
    inter-individual level. The inter-level represents an affiliation 
    relationship.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Chabert-Liddell/MLVSBM">https://github.com/Chabert-Liddell/MLVSBM</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Chabert-Liddell/MLVSBM/issues">https://github.com/Chabert-Liddell/MLVSBM/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>R6, blockmodels, ape, magrittr, cluster</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.1.0), covr, knitr, rmarkdown, ggplot2 (&ge;
3.3.2), ggforce, spelling, cowplot, reshape2, dplyr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-04 17:05:33 UTC; stc</td>
</tr>
<tr>
<td>Author:</td>
<td>Saint-Clair Chabert-Liddell
    <a href="https://orcid.org/0000-0001-5604-7308"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Saint-Clair Chabert-Liddell &lt;academic@chabert-liddell.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-05 10:10:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='ARI'>Compare two clustering with the Adjusted Rand Index</h2><span id='topic+ARI'></span>

<h3>Description</h3>

<p>Compare two clustering with the Adjusted Rand Index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ARI(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ARI_+3A_x">x</code></td>
<td>
<p>A vector of integers, the clusters labels</p>
</td></tr>
<tr><td><code id="ARI_+3A_y">y</code></td>
<td>
<p>A vector of integers of the same length as x, the clusters labels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number between 0 (random clustering) and 1 (identical clustering)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ARI(x = c(1, 2, 1), y = c(2, 2, 1))
</code></pre>

<hr>
<h2 id='build_fold_matrix'>Title</h2><span id='topic+build_fold_matrix'></span>

<h3>Description</h3>

<p>Title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_fold_matrix(X, K)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_fold_matrix_+3A_x">X</code></td>
<td>
<p>An adjacency matrix</p>
</td></tr>
<tr><td><code id="build_fold_matrix_+3A_k">K</code></td>
<td>
<p>An integer, the number of folds</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of the same size than X with class integer as coefficient
</p>

<hr>
<h2 id='coef.FitMLVSBM'>Extract model coefficients</h2><span id='topic+coef.FitMLVSBM'></span>

<h3>Description</h3>

<p>Extracts model coefficients from objects with class <code><a href="#topic+FitMLVSBM">FitMLVSBM</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'FitMLVSBM'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.FitMLVSBM_+3A_object">object</code></td>
<td>
<p>an R6 object of class FitMLVSBM</p>
</td></tr>
<tr><td><code id="coef.FitMLVSBM_+3A_...">...</code></td>
<td>
<p>additional parameters for S3 compatibility. Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of parameters.
</p>

<hr>
<h2 id='FitMLVSBM'>An R6 Class object, a fitted multilevel network once $dovem() is done</h2><span id='topic+FitMLVSBM'></span>

<h3>Description</h3>

<p>An R6 Class object, a fitted multilevel network once $dovem() is done
</p>
<p>An R6 Class object, a fitted multilevel network once $dovem() is done
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>vbound</code></dt><dd><p>The vector of variational bound for monitoring convergence</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>affiliation_matrix</code></dt><dd><p>Get the affiliation matrix</p>
</dd>
<dt><code>adjacency_matrix</code></dt><dd><p>Get the list of adjacency matrices</p>
</dd>
<dt><code>nb_nodes</code></dt><dd><p>Get the list of the number of nodes</p>
</dd>
<dt><code>nb_clusters</code></dt><dd><p>Get the list of the number of blocks</p>
</dd>
<dt><code>parameters</code></dt><dd><p>Get the list of the model parameters</p>
</dd>
<dt><code>membership</code></dt><dd><p>Get the list of the variational parameters</p>
</dd>
<dt><code>independent</code></dt><dd><p>Are the levels independent?</p>
</dd>
<dt><code>distribution</code></dt><dd><p>Emission distribution of each level</p>
</dd>
<dt><code>directed</code></dt><dd><p>Are the levels directed?</p>
</dd>
<dt><code>entropy</code></dt><dd><p>Get the entropy of the model</p>
</dd>
<dt><code>bound</code></dt><dd><p>Get the variational bound of the model</p>
</dd>
<dt><code>df_mixture</code></dt><dd><p>Get the degrees of freedom of the
mixture parameters</p>
</dd>
<dt><code>df_connect</code></dt><dd><p>Get the degrees of freedom of the
connection parameters</p>
</dd>
<dt><code>connect</code></dt><dd><p>Get the number of possible observed connections</p>
</dd>
<dt><code>ICL</code></dt><dd><p>Get the ICL model selection criterion of the model</p>
</dd>
<dt><code>full_penalty</code></dt><dd><p>Get the penalty used to compute the ICL</p>
</dd>
<dt><code>Z</code></dt><dd><p>Get the list of block memberships (vector form)</p>
</dd>
<dt><code>X_hat</code></dt><dd><p>Get the list of the matrices of probability connection
predictions</p>
</dd>
<dt><code>map</code></dt><dd><p>Get the list of block memberships (matrix form)</p>
</dd>
<dt><code>penalty</code></dt><dd><p>Get the ICL penalty</p>
</dd>
<dt><code>likelihood</code></dt><dd><p>Compute the likelihood of both levels</p>
</dd>
<dt><code>complete_likelihood</code></dt><dd><p>Get the complete likelihood of the model</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-new"><code>FitMLVSBM$new()</code></a>
</p>
</li>
<li> <p><a href="#method-update_alpha"><code>FitMLVSBM$update_alpha()</code></a>
</p>
</li>
<li> <p><a href="#method-update_pi"><code>FitMLVSBM$update_pi()</code></a>
</p>
</li>
<li> <p><a href="#method-update_gamma"><code>FitMLVSBM$update_gamma()</code></a>
</p>
</li>
<li> <p><a href="#method-init_clustering"><code>FitMLVSBM$init_clustering()</code></a>
</p>
</li>
<li> <p><a href="#method-clear"><code>FitMLVSBM$clear()</code></a>
</p>
</li>
<li> <p><a href="#method-m_step"><code>FitMLVSBM$m_step()</code></a>
</p>
</li>
<li> <p><a href="#method-ve_step"><code>FitMLVSBM$ve_step()</code></a>
</p>
</li>
<li> <p><a href="#method-do_vem"><code>FitMLVSBM$do_vem()</code></a>
</p>
</li>
<li> <p><a href="#method-permute_empty_class"><code>FitMLVSBM$permute_empty_class()</code></a>
</p>
</li>
<li> <p><a href="#method-plot"><code>FitMLVSBM$plot()</code></a>
</p>
</li>
<li> <p><a href="#method-show"><code>FitMLVSBM$show()</code></a>
</p>
</li>
<li> <p><a href="#method-print"><code>FitMLVSBM$print()</code></a>
</p>
</li>
<li> <p><a href="#method-clone"><code>FitMLVSBM$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-new"></a>



<h4>Method <code>new()</code></h4>

<p>Constructor for the FitMLVSBM class
</p>


<h5>Usage</h5>

<div class="r"><pre>FitMLVSBM$new(
  Q = list(I = 1, O = 1),
  A = NA,
  X = NA,
  M = list(I = NA, O = NA),
  directed = NA,
  distribution = list("bernoulli", "bernoulli"),
  independent = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>Q</code></dt><dd><p>List of number of blocks</p>
</dd>
<dt><code>A</code></dt><dd><p>Affiliation matrix</p>
</dd>
<dt><code>X</code></dt><dd><p>List of adjacency matrices</p>
</dd>
<dt><code>M</code></dt><dd><p>List of Mask matrices</p>
</dd>
<dt><code>directed</code></dt><dd><p>List of boolean</p>
</dd>
<dt><code>distribution</code></dt><dd><p>List of string</p>
</dd>
<dt><code>independent</code></dt><dd><p>Boolean</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A FitMLVSBM object
</p>


<hr>
<a id="method-update_alpha"></a>



<h4>Method <code>update_alpha()</code></h4>

<p>Update the connection parameters for the M step
</p>


<h5>Usage</h5>

<div class="r"><pre>FitMLVSBM$update_alpha(safeguard = 2 * .Machine$double.eps)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>safeguard</code></dt><dd><p>Parameter live in a compact [safeguard, 1-safeguard]</p>
</dd>
</dl>

</div>


<hr>
<a id="method-update_pi"></a>



<h4>Method <code>update_pi()</code></h4>

<p>Update the upper level mixture parameter for the M step
</p>


<h5>Usage</h5>

<div class="r"><pre>FitMLVSBM$update_pi(safeguard = 0.001)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>safeguard</code></dt><dd><p>Parameter live in a compact [safeguard, 1-safeguard]</p>
</dd>
</dl>

</div>


<hr>
<a id="method-update_gamma"></a>



<h4>Method <code>update_gamma()</code></h4>

<p>Update the lower level mixture parameter for the M step
</p>


<h5>Usage</h5>

<div class="r"><pre>FitMLVSBM$update_gamma(safeguard = 1e-06)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>safeguard</code></dt><dd><p>Parameter live in a compact [safeguard, 1-safeguard]</p>
</dd>
</dl>

</div>


<hr>
<a id="method-init_clustering"></a>



<h4>Method <code>init_clustering()</code></h4>

<p>init_clustering Initial clustering for VEM algorithm
</p>


<h5>Usage</h5>

<div class="r"><pre>FitMLVSBM$init_clustering(
  safeguard = 2 * .Machine$double.eps,
  method = "hierarchical",
  Z = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>safeguard</code></dt><dd><p>Parameter live in a compact [safeguard, 1-safeguard]</p>
</dd>
<dt><code>method</code></dt><dd><p>Algorithm used to initiate the clustering, either
&quot;spectral&quot;, &quot;hierarchical&quot; or &quot;merge_split&quot; (if <code>Z</code> is provided)</p>
</dd>
<dt><code>Z</code></dt><dd><p>Initial clustering if provided</p>
</dd>
</dl>

</div>


<hr>
<a id="method-clear"></a>



<h4>Method <code>clear()</code></h4>

<p>Reset all parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>FitMLVSBM$clear()</pre></div>


<hr>
<a id="method-m_step"></a>



<h4>Method <code>m_step()</code></h4>

<p>m_step Compute the M step of the VEM algorithm
</p>


<h5>Usage</h5>

<div class="r"><pre>FitMLVSBM$m_step(safeguard = 1e-06)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>safeguard</code></dt><dd><p>Parameter live in a compact [safeguard, 1-safeguard]</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ve_step"></a>



<h4>Method <code>ve_step()</code></h4>

<p>Compute the VE step of the VEM algorithm
</p>


<h5>Usage</h5>

<div class="r"><pre>FitMLVSBM$ve_step(threshold = 1e-06, fixPointIter = 10, safeguard = 1e-06)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>threshold</code></dt><dd><p>The convergence threshold</p>
</dd>
<dt><code>fixPointIter</code></dt><dd><p>The maximum number of fixed point iterations</p>
</dd>
<dt><code>safeguard</code></dt><dd><p>Parameter live in a compact [safeguard, 1-safeguard]</p>
</dd>
</dl>

</div>


<hr>
<a id="method-do_vem"></a>



<h4>Method <code>do_vem()</code></h4>

<p>Launch a Variational EM algorithm
</p>


<h5>Usage</h5>

<div class="r"><pre>FitMLVSBM$do_vem(
  init = "hierarchical",
  threshold = 1e-06,
  maxIter = 1000,
  fixPointIter = 100,
  safeguard = 1e-06,
  Z = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>init</code></dt><dd><p>The method for <code>self$init_clustering</code></p>
</dd>
<dt><code>threshold</code></dt><dd><p>The convergence threshold</p>
</dd>
<dt><code>maxIter</code></dt><dd><p>The max number of VEM iterations</p>
</dd>
<dt><code>fixPointIter</code></dt><dd><p>The max number of fixed point iterations for VE step</p>
</dd>
<dt><code>safeguard</code></dt><dd><p>Parameter live in a compact [safeguard, 1-safeguard]</p>
</dd>
<dt><code>Z</code></dt><dd><p>Initial clustering if provided</p>
</dd>
</dl>

</div>


<hr>
<a id="method-permute_empty_class"></a>



<h4>Method <code>permute_empty_class()</code></h4>

<p>permute_empty_class Put empty blocks numbers at the end
</p>


<h5>Usage</h5>

<div class="r"><pre>FitMLVSBM$permute_empty_class()</pre></div>


<hr>
<a id="method-plot"></a>



<h4>Method <code>plot()</code></h4>

<p>Plot of FitMLVSBM objects
</p>


<h5>Usage</h5>

<div class="r"><pre>FitMLVSBM$plot(type = c("matrix"), ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>type</code></dt><dd><p>A string for the type of plot, just &quot;matrix&quot; for now</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a ggplot2 object
</p>


<hr>
<a id="method-show"></a>



<h4>Method <code>show()</code></h4>

<p>print method
</p>


<h5>Usage</h5>

<div class="r"><pre>FitMLVSBM$show(type = "Multilevel Stochastic Block Model")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>type</code></dt><dd><p>character to tune the displayed name</p>
</dd>
</dl>

</div>


<hr>
<a id="method-print"></a>



<h4>Method <code>print()</code></h4>

<p>print method
</p>


<h5>Usage</h5>

<div class="r"><pre>FitMLVSBM$print()</pre></div>


<hr>
<a id="method-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>FitMLVSBM$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='FitSBM'>An R6 Class object for unilevel network</h2><span id='topic+FitSBM'></span>

<h3>Description</h3>

<p>a fitted level of a unilevel network once
$do_vem() is done
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>vbound</code></dt><dd><p>vector of variational bound for convergence monitoring</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>adjacency</code></dt><dd><p>Get the adjacency matrix</p>
</dd>
<dt><code>mask</code></dt><dd><p>Get the mask matrix for dealing with NA</p>
</dd>
<dt><code>nb_nodes</code></dt><dd><p>Get the number of nodes of the level</p>
</dd>
<dt><code>nb_clusters</code></dt><dd><p>Get the number of blocks</p>
</dd>
<dt><code>distribution</code></dt><dd><p>Get the distribution used for the connections</p>
</dd>
<dt><code>directed</code></dt><dd><p>Get if the level is directed or not</p>
</dd>
<dt><code>mixture_parameter</code></dt><dd><p>Access the block proportions</p>
</dd>
<dt><code>connectivity_parameter</code></dt><dd><p>Access the connectivity matrix</p>
</dd>
<dt><code>membership</code></dt><dd><p>Access the variational parameters</p>
</dd>
<dt><code>entropy</code></dt><dd><p>Get the entropy of the model</p>
</dd>
<dt><code>bound</code></dt><dd><p>Get the variational bound of the model</p>
</dd>
<dt><code>df_mixture</code></dt><dd><p>Get the degree of freedom of the block proportion</p>
</dd>
<dt><code>df_connect</code></dt><dd><p>Get the degree of freedom of the connection parameters</p>
</dd>
<dt><code>connect</code></dt><dd><p>Get the number of observed dyads</p>
</dd>
<dt><code>ICL</code></dt><dd><p>Get the ICL model selection criterion</p>
</dd>
<dt><code>penalty</code></dt><dd><p>Get the penalty used for computing the ICL</p>
</dd>
<dt><code>Z</code></dt><dd><p>Access the vector of block membership (clustering)</p>
</dd>
<dt><code>X_hat</code></dt><dd><p>Get the connection probability matrix</p>
</dd>
<dt><code>X_likelihood</code></dt><dd><p>adjacency part of the log likelihood</p>
</dd>
<dt><code>Z_likelihood</code></dt><dd><p>block part of the log likelihood</p>
</dd>
<dt><code>likelihood</code></dt><dd><p>complete log likelihood</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-new"><code>FitSBM$new()</code></a>
</p>
</li>
<li> <p><a href="#method-update_alpha"><code>FitSBM$update_alpha()</code></a>
</p>
</li>
<li> <p><a href="#method-update_pi"><code>FitSBM$update_pi()</code></a>
</p>
</li>
<li> <p><a href="#method-init_clustering"><code>FitSBM$init_clustering()</code></a>
</p>
</li>
<li> <p><a href="#method-m_step"><code>FitSBM$m_step()</code></a>
</p>
</li>
<li> <p><a href="#method-ve_step"><code>FitSBM$ve_step()</code></a>
</p>
</li>
<li> <p><a href="#method-do_vem"><code>FitSBM$do_vem()</code></a>
</p>
</li>
<li> <p><a href="#method-permute_empty_class"><code>FitSBM$permute_empty_class()</code></a>
</p>
</li>
<li> <p><a href="#method-clear"><code>FitSBM$clear()</code></a>
</p>
</li>
<li> <p><a href="#method-clone"><code>FitSBM$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-new"></a>



<h4>Method <code>new()</code></h4>

<p>Constructor for FitSBM  R6 class
</p>


<h5>Usage</h5>

<div class="r"><pre>FitSBM$new(
  Q = 1,
  X = NULL,
  M = NULL,
  directed = FALSE,
  distribution = "bernoulli"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>Q</code></dt><dd><p>Number of blocks</p>
</dd>
<dt><code>X</code></dt><dd><p>Adjacency matrix</p>
</dd>
<dt><code>M</code></dt><dd><p>Mask matrix</p>
</dd>
<dt><code>directed</code></dt><dd><p>boolean</p>
</dd>
<dt><code>distribution</code></dt><dd><p>string (only &quot;bernoulli&quot;)</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new FitSBM object
</p>


<hr>
<a id="method-update_alpha"></a>



<h4>Method <code>update_alpha()</code></h4>

<p>Update the connection parameter for the M step
</p>


<h5>Usage</h5>

<div class="r"><pre>FitSBM$update_alpha(safeguard = 1e-06)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>safeguard</code></dt><dd><p>Parameter live in a compact [safeguard, 1-safeguard]</p>
</dd>
</dl>

</div>


<hr>
<a id="method-update_pi"></a>



<h4>Method <code>update_pi()</code></h4>

<p>Update the upper level mixture parameter for the M step
</p>


<h5>Usage</h5>

<div class="r"><pre>FitSBM$update_pi(safeguard = 1e-06)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>safeguard</code></dt><dd><p>Parameter live in a compact [safeguard, 1-safeguard]</p>
</dd>
</dl>

</div>


<hr>
<a id="method-init_clustering"></a>



<h4>Method <code>init_clustering()</code></h4>

<p>init_clustering Initial clustering for VEM algorithm
</p>


<h5>Usage</h5>

<div class="r"><pre>FitSBM$init_clustering(safeguard = 1e-06, method = "hierarchical", Z = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>safeguard</code></dt><dd><p>Parameter live in a compact [safeguard, 1-safeguard]</p>
</dd>
<dt><code>method</code></dt><dd><p>Algorithm used to initiate the clustering, either
&quot;spectral&quot;, &quot;hierarchical&quot; or &quot;merge_split&quot; (if <code>Z</code> is provided)</p>
</dd>
<dt><code>Z</code></dt><dd><p>Initial clustering if provided</p>
</dd>
</dl>

</div>


<hr>
<a id="method-m_step"></a>



<h4>Method <code>m_step()</code></h4>

<p>m_step Compute the M step of the VEM algorithm
</p>


<h5>Usage</h5>

<div class="r"><pre>FitSBM$m_step(safeguard = 1e-06)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>safeguard</code></dt><dd><p>Parameter live in a compact [safeguard, 1-safeguard]</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ve_step"></a>



<h4>Method <code>ve_step()</code></h4>

<p>Compute the VE step of the VEM algorithm
</p>


<h5>Usage</h5>

<div class="r"><pre>FitSBM$ve_step(threshold = 1e-06, fixPointIter = 100, safeguard = 1e-06)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>threshold</code></dt><dd><p>The convergence threshold</p>
</dd>
<dt><code>fixPointIter</code></dt><dd><p>The maximum number of fixed point iterations</p>
</dd>
<dt><code>safeguard</code></dt><dd><p>Parameter live in a compact [safeguard, 1-safeguard]</p>
</dd>
</dl>

</div>


<hr>
<a id="method-do_vem"></a>



<h4>Method <code>do_vem()</code></h4>

<p>Launch a Variational EM algorithm
</p>


<h5>Usage</h5>

<div class="r"><pre>FitSBM$do_vem(
  init = "hierarchical",
  threshold = 1e-06,
  maxIter = 1000,
  fixPointIter = 100,
  safeguard = 1e-06,
  Z = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>init</code></dt><dd><p>The method for <code>self$init_clustering</code></p>
</dd>
<dt><code>threshold</code></dt><dd><p>The convergence threshold</p>
</dd>
<dt><code>maxIter</code></dt><dd><p>The max number of VEM iterations</p>
</dd>
<dt><code>fixPointIter</code></dt><dd><p>The max number of fixed point iterations for VE step</p>
</dd>
<dt><code>safeguard</code></dt><dd><p>Parameter live in a compact [safeguard, 1-safeguard]</p>
</dd>
<dt><code>Z</code></dt><dd><p>Initial clustering if provided</p>
</dd>
</dl>

</div>


<hr>
<a id="method-permute_empty_class"></a>



<h4>Method <code>permute_empty_class()</code></h4>

<p>permute_empty_class Put empty blocks numbers at the end
</p>


<h5>Usage</h5>

<div class="r"><pre>FitSBM$permute_empty_class()</pre></div>


<hr>
<a id="method-clear"></a>



<h4>Method <code>clear()</code></h4>

<p>Reset all parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>FitSBM$clear()</pre></div>


<hr>
<a id="method-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>FitSBM$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='hierarClust'>Perform a Hierarchical Clustering</h2><span id='topic+hierarClust'></span>

<h3>Description</h3>

<p>Perform a Hierarchical Clustering
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hierarClust(X, K)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hierarClust_+3A_x">X</code></td>
<td>
<p>An Adjacency Matrix</p>
</td></tr>
<tr><td><code id="hierarClust_+3A_k">K</code></td>
<td>
<p>the number of wanted clusters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector : The clusters labels
</p>

<hr>
<h2 id='merge_clust'>Merge a list of clusters</h2><span id='topic+merge_clust'></span>

<h3>Description</h3>

<p>Merge a list of clusters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_clust(Z, Q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_clust_+3A_z">Z</code></td>
<td>
<p>a vector of cluster memberships</p>
</td></tr>
<tr><td><code id="merge_clust_+3A_q">Q</code></td>
<td>
<p>the number of original clusters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of Q(Q-1)/2 clustering of Q-1 clusters
</p>

<hr>
<h2 id='MLVSBM'>R6Class for multilevel object</h2><span id='topic+MLVSBM'></span>

<h3>Description</h3>

<p>Store all simulation parameters and list of fittedmodels.
Methods for global inference and model selection are included.
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>nb_nodes</code></dt><dd><p>List of the umber of nodes for each levels</p>
</dd>
<dt><code>simulation_parameters</code></dt><dd><p>List of parameters of the MLVSBM</p>
</dd>
<dt><code>affiliation_matrix</code></dt><dd><p>Access the affiliation matrix</p>
</dd>
<dt><code>adjacency_matrix</code></dt><dd><p>Access the list of adjacency_matrix</p>
</dd>
<dt><code>memberships</code></dt><dd><p>Access the list of the clusterings</p>
</dd>
<dt><code>fittedmodels</code></dt><dd><p>Get the list of selected fitted FitMLVSBM objects</p>
</dd>
<dt><code>ICL</code></dt><dd><p>A summary table of selected fitted models and ICL model selection criterion</p>
</dd>
<dt><code>ICL_sbm</code></dt><dd><p>Summary table of ICL by levels</p>
</dd>
<dt><code>tmp_fittedmodels</code></dt><dd><p>A list of all fitted FitMLVSBM objects</p>
</dd>
<dt><code>fittedmodels_sbm</code></dt><dd><p>A list of selected fitted FitSBM objects of each levels</p>
</dd>
<dt><code>max_clusters</code></dt><dd><p>Access the list of maximum model size</p>
</dd>
<dt><code>min_clusters</code></dt><dd><p>Access the list of minimum model size</p>
</dd>
<dt><code>directed</code></dt><dd><p>Access the list of boolean for levels  direction</p>
</dd>
<dt><code>directed</code></dt><dd><p>Access the list of the distribution used for each levels</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-estimate_level"><code>MLVSBM$estimate_level()</code></a>
</p>
</li>
<li> <p><a href="#method-estimate_sbm_neighbours"><code>MLVSBM$estimate_sbm_neighbours()</code></a>
</p>
</li>
<li> <p><a href="#method-estimate_sbm_from_neighbours"><code>MLVSBM$estimate_sbm_from_neighbours()</code></a>
</p>
</li>
<li> <p><a href="#method-estimate_sbm"><code>MLVSBM$estimate_sbm()</code></a>
</p>
</li>
<li> <p><a href="#method-mcestimate"><code>MLVSBM$mcestimate()</code></a>
</p>
</li>
<li> <p><a href="#method-estimate_from_neighbours"><code>MLVSBM$estimate_from_neighbours()</code></a>
</p>
</li>
<li> <p><a href="#method-estimate_neighbours"><code>MLVSBM$estimate_neighbours()</code></a>
</p>
</li>
<li> <p><a href="#method-merge_split_membership"><code>MLVSBM$merge_split_membership()</code></a>
</p>
</li>
<li> <p><a href="#method-mc_ms_estimate"><code>MLVSBM$mc_ms_estimate()</code></a>
</p>
</li>
<li> <p><a href="#method-estimate_one"><code>MLVSBM$estimate_one()</code></a>
</p>
</li>
<li> <p><a href="#method-estimate_all_bm"><code>MLVSBM$estimate_all_bm()</code></a>
</p>
</li>
<li> <p><a href="#method-new"><code>MLVSBM$new()</code></a>
</p>
</li>
<li> <p><a href="#method-findmodel"><code>MLVSBM$findmodel()</code></a>
</p>
</li>
<li> <p><a href="#method-clearmodels"><code>MLVSBM$clearmodels()</code></a>
</p>
</li>
<li> <p><a href="#method-addmodel"><code>MLVSBM$addmodel()</code></a>
</p>
</li>
<li> <p><a href="#method-simulate"><code>MLVSBM$simulate()</code></a>
</p>
</li>
<li> <p><a href="#method-clone"><code>MLVSBM$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-estimate_level"></a>



<h4>Method <code>estimate_level()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>MLVSBM$estimate_level(
  level = "lower",
  Q_min = 1,
  Q_max = 10,
  Z = NULL,
  init = "hierarchical",
  depth = 1,
  nb_cores = NULL
)</pre></div>


<hr>
<a id="method-estimate_sbm_neighbours"></a>



<h4>Method <code>estimate_sbm_neighbours()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>MLVSBM$estimate_sbm_neighbours(
  level = "lower",
  Q = NULL,
  Q_min = 1,
  Q_max = 10,
  fit = NULL,
  nb_cores = NULL,
  init = NULL
)</pre></div>


<hr>
<a id="method-estimate_sbm_from_neighbours"></a>



<h4>Method <code>estimate_sbm_from_neighbours()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>MLVSBM$estimate_sbm_from_neighbours(
  level = "lower",
  Q = NULL,
  fits = NULL,
  nb_cores = NULL
)</pre></div>


<hr>
<a id="method-estimate_sbm"></a>



<h4>Method <code>estimate_sbm()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>MLVSBM$estimate_sbm(level = "lower", Q = Q, Z = NULL, init = "hierarchical")</pre></div>


<hr>
<a id="method-mcestimate"></a>



<h4>Method <code>mcestimate()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>MLVSBM$mcestimate(Q, Z = NULL, init = "hierarchical", independent = FALSE)</pre></div>


<hr>
<a id="method-estimate_from_neighbours"></a>



<h4>Method <code>estimate_from_neighbours()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>MLVSBM$estimate_from_neighbours(
  Q,
  models = NULL,
  independent = FALSE,
  nb_cores = nb_cores
)</pre></div>


<hr>
<a id="method-estimate_neighbours"></a>



<h4>Method <code>estimate_neighbours()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>MLVSBM$estimate_neighbours(
  Q,
  fit = NULL,
  independent = independent,
  nb_cores = NULL
)</pre></div>


<hr>
<a id="method-merge_split_membership"></a>



<h4>Method <code>merge_split_membership()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>MLVSBM$merge_split_membership(
  fitted = private$fitted[[length(private$fitted)]]
)</pre></div>


<hr>
<a id="method-mc_ms_estimate"></a>



<h4>Method <code>mc_ms_estimate()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>MLVSBM$mc_ms_estimate(Z = NA, independent = FALSE, nb_cores = NULL)</pre></div>


<hr>
<a id="method-estimate_one"></a>



<h4>Method <code>estimate_one()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>MLVSBM$estimate_one(
  Q,
  Z = NULL,
  independent = FALSE,
  init = "hierarchical",
  nb_cores = NULL
)</pre></div>


<hr>
<a id="method-estimate_all_bm"></a>



<h4>Method <code>estimate_all_bm()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>MLVSBM$estimate_all_bm(
  Q = NULL,
  Z = NULL,
  independent = FALSE,
  clear = TRUE,
  nb_cores = NULL
)</pre></div>


<hr>
<a id="method-new"></a>



<h4>Method <code>new()</code></h4>

<p>Constructor for R6 class MLVSBM
</p>


<h5>Usage</h5>

<div class="r"><pre>MLVSBM$new(
  n = NULL,
  X = NULL,
  A = NULL,
  Z = NULL,
  directed = NULL,
  sim_param = NULL,
  distribution = list("bernoulli", "bernoulli")
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n</code></dt><dd><p>A list of size 2, the number of nodes</p>
</dd>
<dt><code>X</code></dt><dd><p>A list of 2 adjacency matrices</p>
</dd>
<dt><code>A</code></dt><dd><p>The affiliation matrix</p>
</dd>
<dt><code>Z</code></dt><dd><p>A list of 2 vectors, the blocks membership</p>
</dd>
<dt><code>directed</code></dt><dd><p>A list of 2 booleans</p>
</dd>
<dt><code>sim_param</code></dt><dd><p>A list of MLVSBM parameters for simulating networks</p>
</dd>
<dt><code>distribution</code></dt><dd><p>The distributions of the interactions (&quot;bernoulli&quot;)</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A MLVSBM object
</p>


<hr>
<a id="method-findmodel"></a>



<h4>Method <code>findmodel()</code></h4>

<p>Find a fitted model of a given size
</p>


<h5>Usage</h5>

<div class="r"><pre>MLVSBM$findmodel(nb_clusters = NA, fit = NA)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>nb_clusters</code></dt><dd><p>A list of the size of the model</p>
</dd>
<dt><code>fit</code></dt><dd><p>if fit = &quot;best&quot; return the best model according to the ICL</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A FitMLVSBM object
</p>


<hr>
<a id="method-clearmodels"></a>



<h4>Method <code>clearmodels()</code></h4>

<p>delete all fitted models
</p>


<h5>Usage</h5>

<div class="r"><pre>MLVSBM$clearmodels()</pre></div>


<hr>
<a id="method-addmodel"></a>



<h4>Method <code>addmodel()</code></h4>

<p>Added a FitMLVSBM object to the list of fitted model
</p>


<h5>Usage</h5>

<div class="r"><pre>MLVSBM$addmodel(fit)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>fit</code></dt><dd><p>The FitMLVSBM object to be added</p>
</dd>
</dl>

</div>


<hr>
<a id="method-simulate"></a>



<h4>Method <code>simulate()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>MLVSBM$simulate()</pre></div>


<hr>
<a id="method-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>MLVSBM$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='mlvsbm_create_network'>Create a MLVSBM object from observed data</h2><span id='topic+mlvsbm_create_network'></span>

<h3>Description</h3>

<p>Create a MLVSBM object from observed data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mlvsbm_create_network(
  X,
  A,
  directed = NULL,
  distribution = list("bernoulli", "bernoulli")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mlvsbm_create_network_+3A_x">X</code></td>
<td>
<p>A list of 2 squares binary matrices,
the first one being the individual or lower level
the second one being the organizational or upper level</p>
</td></tr>
<tr><td><code id="mlvsbm_create_network_+3A_a">A</code></td>
<td>
<p>A matrix the affiliation matrix with individuals in rows and
organizations in columns</p>
</td></tr>
<tr><td><code id="mlvsbm_create_network_+3A_directed">directed</code></td>
<td>
<p>A list of 2 boolean are the upper and lower level
directed or not. Default will check if the matrix are symmetric or not.</p>
</td></tr>
<tr><td><code id="mlvsbm_create_network_+3A_distribution">distribution</code></td>
<td>
<p>A list for the distribution of X,
only &quot;bernoulli&quot; is implemented</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An unfitted MLVSBM object corresponding to the multilevel network
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ind_adj &lt;- matrix(stats::rbinom(n = 10**2, size = 1, prob = .2),
                  nrow = 10, ncol = 10)
org_adj &lt;- matrix(stats::rbinom(n = 10**2, size = 1, prob = .3),
                  nrow = 10, ncol = 10)
affiliation &lt;- diag(1, 10)
my_mlvsbm &lt;- mlvsbm_create_network(X = list(I = ind_adj, O = org_adj),
                                   directed = list(I = FALSE, O = FALSE),
                                   A = affiliation)
</code></pre>

<hr>
<h2 id='mlvsbm_estimate_network'>Infer a multilevel network (MLVSBM object), the original object is modified</h2><span id='topic+mlvsbm_estimate_network'></span>

<h3>Description</h3>

<p>The inference use a greedy algorithm to navigate between model
size. For a given model size, the inference is done via a variational EM
algorithm. The returned model is the one with the highest ICL criterion among
all visited models.
</p>
<p>By default the algorithm fits a single level SBM for each level, before
inferring the multilevel network. This step can be skipped by specifying an
initial clustering with the <code>init_clustering</code>. Also, a given model size
can be force by setting the parameters <code>nb_clusters</code> to a given value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mlvsbm_estimate_network(
  mlv,
  nb_clusters = NULL,
  init_clustering = NULL,
  nb_cores = NULL,
  init_method = "hierarchical"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mlvsbm_estimate_network_+3A_mlv">mlv</code></td>
<td>
<p>A MLVSBM object, the network to be inferred.</p>
</td></tr>
<tr><td><code id="mlvsbm_estimate_network_+3A_nb_clusters">nb_clusters</code></td>
<td>
<p>A list of 2 integers, the model size.
If left to <code>NULL</code>, the algorithm
will navigate freely. Otherwise it will navigate between the specified model
size and its neighbors.</p>
</td></tr>
<tr><td><code id="mlvsbm_estimate_network_+3A_init_clustering">init_clustering</code></td>
<td>
<p>A list of 2 vectors of integers of the same length as
the number of node of each level. If specified, the algorithm will start from
this clustering, then navigate freely.</p>
</td></tr>
<tr><td><code id="mlvsbm_estimate_network_+3A_nb_cores">nb_cores</code></td>
<td>
<p>An integer, the number of cores to use. Default to <code>1</code>
for Windows and <code>detectCores()/2</code> for Linux and MacOS</p>
</td></tr>
<tr><td><code id="mlvsbm_estimate_network_+3A_init_method">init_method</code></td>
<td>
<p>One of &quot;hierarchical&quot; (the default) or &quot;spectral&quot;,
&quot;spectral&quot; might be more efficient but can lead to some numeric errors.
Not used when int_clustering is given.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A FitMLVSBM object, the best inference of the network
</p>


<h3>Examples</h3>

<pre><code class='language-R'>my_mlvsbm &lt;- MLVSBM::mlvsbm_simulate_network(
  n = list(I = 10, O = 20), # Number of nodes for the lower level and the upper level
  Q = list(I = 2, O = 2), # Number of blocks for the lower level and the upper level
  pi = c(.3, .7), # Block proportion for the upper level, must sum to one
  gamma = matrix(c(.9, .2,   # Block proportion for the lower level,
                   .1, .8), # each column must sum to one
                 nrow = 2, ncol = 2, byrow = TRUE),
  alpha = list(I = matrix(c(.8, .2,
                            .2, .1),
                          nrow = 2, ncol = 2, byrow = TRUE), # Connection matrix
               O = matrix(c(.99, .3,
                            .3, .1),
                          nrow = 2, ncol = 2, byrow = TRUE)),# between blocks
  directed = list(I = FALSE, O = FALSE), # Are the upper and lower level directed or not ?
  affiliation = "preferential") # How the affiliation matrix is generated
fit &lt;- MLVSBM::mlvsbm_estimate_network(mlv = my_mlvsbm, nb_cores = 1)
</code></pre>

<hr>
<h2 id='mlvsbm_log_likelihood'>Compute the complete log likelihood of a multilevel network for a given
clustering of the nodes.</h2><span id='topic+mlvsbm_log_likelihood'></span>

<h3>Description</h3>

<p>This function is useful to compute the likelihood for clusters
obtained by different methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mlvsbm_log_likelihood(mlv, clustering)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mlvsbm_log_likelihood_+3A_mlv">mlv</code></td>
<td>
<p>A MLVSBM object, the network data</p>
</td></tr>
<tr><td><code id="mlvsbm_log_likelihood_+3A_clustering">clustering</code></td>
<td>
<p>A list of 2 vectors of integers of the same length as
the number of node of each level.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric, the log likelihood of the multilevel network
for the given clustering.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>my_mlvsbm &lt;- MLVSBM::mlvsbm_simulate_network(
  n = list(I = 40, O = 20), # Number of nodes for the lower level and the upper level
  Q = list(I = 2, O = 2), # Number of blocks for the lower level and the upper level
  pi = c(.3, .7), # Block proportion for the upper level, must sum to one
  gamma = matrix(c(.9, .2,   # Block proportion for the lower level,
                   .1, .8), # each column must sum to one
                 nrow = 2, ncol = 2, byrow = TRUE),
  alpha = list(I = matrix(c(.8, .2,
                            .2, .1),
                          nrow = 2, ncol = 2, byrow = TRUE), # Connection matrix
               O = matrix(c(.99, .3,
                            .3, .1),
                          nrow = 2, ncol = 2, byrow = TRUE)),# between blocks
  directed = list(I = FALSE, O = FALSE), # Are the upper and lower level directed or not ?
  affiliation = "preferential") # How the affiliation matrix is generated
mlvsbm_log_likelihood(mlv = my_mlvsbm, clustering = my_mlvsbm$memberships)
</code></pre>

<hr>
<h2 id='mlvsbm_simulate_network'>Create a simulated multilevel network (MLVSBM object)</h2><span id='topic+mlvsbm_simulate_network'></span>

<h3>Description</h3>

<p>Create a simulated multilevel network (MLVSBM object)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mlvsbm_simulate_network(
  n,
  Q,
  pi,
  gamma,
  alpha,
  directed,
  affiliation = "uniform",
  distribution = list("bernoulli", "bernoulli"),
  no_empty_org = FALSE,
  no_isolated_node = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mlvsbm_simulate_network_+3A_n">n</code></td>
<td>
<p>A list of 2 positive integers,
the number of individuals and organizations.</p>
</td></tr>
<tr><td><code id="mlvsbm_simulate_network_+3A_q">Q</code></td>
<td>
<p>A list of 2 positive integers,
the number of clusters of individuals and organizations.</p>
</td></tr>
<tr><td><code id="mlvsbm_simulate_network_+3A_pi">pi</code></td>
<td>
<p>A vector of probabilities of length Q_O,
the mixture parameter for the organizations.</p>
</td></tr>
<tr><td><code id="mlvsbm_simulate_network_+3A_gamma">gamma</code></td>
<td>
<p>A <code class="reqn">Q_I \times Q_O</code> matrix with each column summing to one,
the mixture parameters for the individuals</p>
</td></tr>
<tr><td><code id="mlvsbm_simulate_network_+3A_alpha">alpha</code></td>
<td>
<p>A list of 2 matrices, a <code class="reqn">Q_I \times Q_I</code> matrix giving the
connectivity probabilities of the individuals and a <code class="reqn">Q_O \times Q_O</code>
matrix giving the connectivity probabilities of the organizations.</p>
</td></tr>
<tr><td><code id="mlvsbm_simulate_network_+3A_directed">directed</code></td>
<td>
<p>A list of 2 logical. Is the individual level a directed
network ? Is the inter-organizational level a directed network?</p>
</td></tr>
<tr><td><code id="mlvsbm_simulate_network_+3A_affiliation">affiliation</code></td>
<td>
<p>The distribution under which the affiliation matrix is
simulated in c(&quot;uniform&quot;, &quot;preferential&quot;).</p>
</td></tr>
<tr><td><code id="mlvsbm_simulate_network_+3A_distribution">distribution</code></td>
<td>
<p>A list for the distribution of X,
only &quot;bernoulli&quot; is implemented.</p>
</td></tr>
<tr><td><code id="mlvsbm_simulate_network_+3A_no_empty_org">no_empty_org</code></td>
<td>
<p>A logical with FALSE as default, should
every organizations have at least one affiliated individual?
Needs to have <code class="reqn">n_I \geq n_O</code>.</p>
</td></tr>
<tr><td><code id="mlvsbm_simulate_network_+3A_no_isolated_node">no_isolated_node</code></td>
<td>
<p>A logical, if TRUE then the network is simulated
again until all nodes are connected.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An MLVSBM object, a simulated multilevel network with levels,
affiliations and memberships.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>my_mlvsbm &lt;- MLVSBM::mlvsbm_simulate_network(
  n = list(I = 10, O = 20), # Number of nodes for the lower level and the upper level
  Q = list(I = 2, O = 2), # Number of blocks for the lower level and the upper level
  pi = c(.3, .7), # Block proportion for the upper level, must sum to one
  gamma = matrix(c(.9, .2,   # Block proportion for the lower level,
                   .1, .8), # each column must sum to one
                 nrow = 2, ncol = 2, byrow = TRUE),
  alpha = list(I = matrix(c(.8, .2,
                            .2, .1),
                          nrow = 2, ncol = 2, byrow = TRUE), # Connection matrix
               O = matrix(c(.99, .3,
                            .3, .1),
                          nrow = 2, ncol = 2, byrow = TRUE)),# between blocks
  directed = list(I = FALSE, O = FALSE)) # Are the upper and lower level directed
</code></pre>

<hr>
<h2 id='plot.FitMLVSBM'>Multilevel SBM Plot</h2><span id='topic+plot.FitMLVSBM'></span>

<h3>Description</h3>

<p>basic matrix plot method for a FitMLVSBM object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'FitMLVSBM'
plot(x, type = c("matrix"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.FitMLVSBM_+3A_x">x</code></td>
<td>
<p>an R6 object of class <code><a href="#topic+FitMLVSBM">FitMLVSBM</a></code></p>
</td></tr>
<tr><td><code id="plot.FitMLVSBM_+3A_type">type</code></td>
<td>
<p>A string for the type of plot, just &quot;matrix&quot; for now</p>
</td></tr>
<tr><td><code id="plot.FitMLVSBM_+3A_...">...</code></td>
<td>
<p>additional parameters. block ordering with
order = c(&quot;affiliation&quot;, &quot;degree&quot;, &quot;natural&quot;)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Basic matrix plot method for a FitMLVSBM object
</p>


<h3>Value</h3>

<p>a ggplot2 object
</p>

<hr>
<h2 id='predict.FitMLVSBM'>Model Predictions</h2><span id='topic+predict.FitMLVSBM'></span>

<h3>Description</h3>

<p>Make predictions from an SBM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'FitMLVSBM'
predict(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.FitMLVSBM_+3A_object">object</code></td>
<td>
<p>an R6 object of class <code><a href="#topic+FitMLVSBM">FitMLVSBM</a></code></p>
</td></tr>
<tr><td><code id="predict.FitMLVSBM_+3A_...">...</code></td>
<td>
<p>additional parameters for S3 compatibility. Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following entries:
</p>

<dl>
<dt>dyads</dt><dd><p>A list of matrix with the probability of each dyads</p>
</dd>
<dt>nodes</dt><dd><p>A list of vectors with the clustering of each nodes</p>
</dd>
</dl>


<hr>
<h2 id='simulate_adjacency'>Simulation an adjacency matrix</h2><span id='topic+simulate_adjacency'></span>

<h3>Description</h3>

<p>Simulation an adjacency matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_adjacency(
  Z,
  n,
  alpha,
  directed,
  distribution = "bernoulli",
  no_isolated_node = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_adjacency_+3A_z">Z</code></td>
<td>
<p>A vector of integer of size n, the label</p>
</td></tr>
<tr><td><code id="simulate_adjacency_+3A_n">n</code></td>
<td>
<p>An integer, the number of rows or columns of the matrix</p>
</td></tr>
<tr><td><code id="simulate_adjacency_+3A_alpha">alpha</code></td>
<td>
<p>A <code class="reqn">\max(Z)\times \max(Z)</code> matrix, the connectivity parameters</p>
</td></tr>
<tr><td><code id="simulate_adjacency_+3A_directed">directed</code></td>
<td>
<p>A boolean, Is the network directed or not ?</p>
</td></tr>
<tr><td><code id="simulate_adjacency_+3A_distribution">distribution</code></td>
<td>
<p>The distribution of the indices: only &quot;bernoulli&quot;</p>
</td></tr>
<tr><td><code id="simulate_adjacency_+3A_no_isolated_node">no_isolated_node</code></td>
<td>
<p>A boolean, may row and column of adjacency matrices sum to 0</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A nxn adjacency matrix
</p>

<hr>
<h2 id='simulate_affiliation'>Simulate of matrix of affiliation</h2><span id='topic+simulate_affiliation'></span>

<h3>Description</h3>

<p>Simulate of matrix of affiliation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_affiliation(n, m, affiliation = "uniform", no_empty_org = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_affiliation_+3A_n">n</code></td>
<td>
<p>An integer, the number of individuals</p>
</td></tr>
<tr><td><code id="simulate_affiliation_+3A_m">m</code></td>
<td>
<p>An integer, the number of organizations</p>
</td></tr>
<tr><td><code id="simulate_affiliation_+3A_affiliation">affiliation</code></td>
<td>
<p>The type of affiliation between c(&quot;uniform&quot;, &quot;preferential&quot;)</p>
</td></tr>
<tr><td><code id="simulate_affiliation_+3A_no_empty_org">no_empty_org</code></td>
<td>
<p>A Boolean. Force all columns to have at least a 1.
Must have <code class="reqn">n&gt;m</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code class="reqn">n \times m</code> affiliation matrix, with a unique 1 on each rows
</p>

<hr>
<h2 id='spcClust'>Perform a spectral clustering</h2><span id='topic+spcClust'></span>

<h3>Description</h3>

<p>Perform a spectral clustering
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spcClust(X, K)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spcClust_+3A_x">X</code></td>
<td>
<p>an Adjacency matrix</p>
</td></tr>
<tr><td><code id="spcClust_+3A_k">K</code></td>
<td>
<p>the number of clusters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector : The clusters labels
</p>

<hr>
<h2 id='split_clust'>Merge a list of clusters</h2><span id='topic+split_clust'></span>

<h3>Description</h3>

<p>Merge a list of clusters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_clust(X, Z, Q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_clust_+3A_x">X</code></td>
<td>
<p>an adjacency matrix</p>
</td></tr>
<tr><td><code id="split_clust_+3A_z">Z</code></td>
<td>
<p>a vector of cluster memberships</p>
</td></tr>
<tr><td><code id="split_clust_+3A_q">Q</code></td>
<td>
<p>The number of maximal clusters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of Q clustering of Q+1 clusters
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
