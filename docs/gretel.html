<!DOCTYPE html><html><head><title>Help for package gretel</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gretel}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#all_opt_gpv'><p>Optimize All Generalized Path Values</p></a></li>
<li><a href='#all_opt_ppv'><p>Optimize All Probabilistic Path Values</p></a></li>
<li><a href='#binary_distance'><p>Binary Distance of a Network Path</p></a></li>
<li><a href='#BuchDarrah19'><p>Example data for gretel</p></a></li>
<li><a href='#dijkstra_inf'><p>Find the shortest L-Inf norm paths to other vertices</p></a></li>
<li><a href='#dijkstra_nodes'><p>Find the shortest paths to other vertices</p></a></li>
<li><a href='#flament_average_path_length'><p>Yang and Knoke's Average Path Length</p></a></li>
<li><a href='#flament_path_length'><p>Flament's Path Length Measure</p></a></li>
<li><a href='#generate_proximities'><p>Generate a Proximity Matrix</p></a></li>
<li><a href='#gpv'><p>Generalized Path Value</p></a></li>
<li><a href='#gretel'><p>sconduct: Generalized Path Analysis for Social Networks</p></a></li>
<li><a href='#OpsahlEtAl10'><p>Example data from Opsahl, Agneessens, Skvoretz (2010)</p></a></li>
<li><a href='#opt_gpv'><p>Optimize Generalized Path Value</p></a></li>
<li><a href='#opt_ppv'><p>Optimize Probabilistic Path Value</p></a></li>
<li><a href='#peay_average_path_value'><p>Yang and Knoke's Average Path Value</p></a></li>
<li><a href='#peay_path_value'><p>Peay's Path Value Measure</p></a></li>
<li><a href='#ppv'><p>Calculate probabilistic path value</p></a></li>
<li><a href='#unpack'><p>Unpacks a Path from a Dijkstra-Format Spanning Tree</p></a></li>
<li><a href='#YangKnoke01'><p>Example data from Yang, Knoke (2001)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Generalized Path Analysis for Social Networks</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-08-09</td>
</tr>
<tr>
<td>Description:</td>
<td>The social network literature features numerous methods for assigning
    value to paths as a function of their ties. 'gretel' systemizes these approaches,
    casting them as instances of a generalized path value function indexed by 
    a penalty parameter. The package also calculates probabilistic path value and
    identifies optimal paths in either value framework. Finally, proximity 
    matrices can be generated in these frameworks that capture high-order connections 
    overlooked in primitive adjacency sociomatrices. Novel methods are described
    in Buch (2019) <a href="https://davidbuch.github.io/analyzing-networks-with-gretel.html">https://davidbuch.github.io/analyzing-networks-with-gretel.html</a>. 
    More traditional methods are also implemented, as described in Yang, Knoke (2001) 
    &lt;<a href="https://doi.org/10.1016%2FS0378-8733%2801%2900043-0">doi:10.1016/S0378-8733(01)00043-0</a>&gt;.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Buch &lt;davidbuch42@gmail.com&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/davidbuch/gretel">https://github.com/davidbuch/gretel</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/davidbuch/gretel/issues">https://github.com/davidbuch/gretel/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.0), ResistorArray (&ge; 1.0-32)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 2.1.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-08-21 11:38:45 UTC; Buch</td>
</tr>
<tr>
<td>Author:</td>
<td>David Buch <a href="https://orcid.org/0000-0002-4574-0075"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-08-22 12:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='all_opt_gpv'>Optimize All Generalized Path Values</h2><span id='topic+all_opt_gpv'></span>

<h3>Description</h3>

<p>Identify the path of optimal generalized path value from every source 
to every target in <code>sociomatrix</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_opt_gpv(sociomatrix, p = Inf, node_costs = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all_opt_gpv_+3A_sociomatrix">sociomatrix</code></td>
<td>
<p>a nonnegative, real valued sociomatrix.</p>
</td></tr>
<tr><td><code id="all_opt_gpv_+3A_p">p</code></td>
<td>
<p>a nonnegative real number that sets the 'p-norm' parameter for 
generalized path value calculation.</p>
</td></tr>
<tr><td><code id="all_opt_gpv_+3A_node_costs">node_costs</code></td>
<td>
<p>a list of costs, in order, of all nodes represented in the 
sociomatrix, all are assumed 0 if unspecified</p>
</td></tr>
</table>


<h3>Value</h3>

<p>All optimal paths from source to target nodes in <code>sociomatrix</code>. To
minimize memory usage, paths are returned as a list of trees in Dijkstra's 
format. Specific paths can be unpacked with <code>unpack</code> as described in the
example below.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gpv">gpv</a></code> to calculate the value of a user-specified path, 
<code><a href="#topic+opt_gpv">opt_gpv</a></code> to identify the optimal path from a single source 
node to a single target node
</p>

<hr>
<h2 id='all_opt_ppv'>Optimize All Probabilistic Path Values</h2><span id='topic+all_opt_ppv'></span>

<h3>Description</h3>

<p>Identify the path of optimal probabilistic path value from every source 
to every target in <code>sociomatrix</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_opt_ppv(sociomatrix, odds_scale = 1, odds_scale_by_node = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all_opt_ppv_+3A_sociomatrix">sociomatrix</code></td>
<td>
<p>a nonnegative, real valued sociomatrix.</p>
</td></tr>
<tr><td><code id="all_opt_ppv_+3A_odds_scale">odds_scale</code></td>
<td>
<p>a nonnegative real number indicating the observed tie
strength value that corresponds to 1-1 transmission odds</p>
</td></tr>
<tr><td><code id="all_opt_ppv_+3A_odds_scale_by_node">odds_scale_by_node</code></td>
<td>
<p>sets a transfer odds scale for each node in a 
probabilistic path value calculation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>All optimal paths from source to target nodes in <code>sociomatrix</code>. To
minimize memory usage, paths are returned as a list of trees in Dijkstra's 
format. Specific paths can be unpacked with <code>unpack</code> as described in the
example below.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppv">ppv</a></code> to calculate the value of a user-specified path, 
<code><a href="#topic+opt_ppv">opt_ppv</a></code> to identify the optimal path from a single source 
node to a single target node
</p>

<hr>
<h2 id='binary_distance'>Binary Distance of a Network Path</h2><span id='topic+binary_distance'></span>

<h3>Description</h3>

<p>Calculates the binary distance of a user-specified network path through a network,
if all edges exist. Otherwise, returns <code>Inf</code> to signify infinite distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binary_distance(sociomatrix, path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binary_distance_+3A_sociomatrix">sociomatrix</code></td>
<td>
<p>a nonnegative, real valued sociomatrix.</p>
</td></tr>
<tr><td><code id="binary_distance_+3A_path">path</code></td>
<td>
<p>an integer vector of node indices from <code>sociomatrix</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Calculate binary distance along a path in a sociomatrix
binary_distance(YangKnoke01, path = c(1,2,5))

## This path doesn't exist
binary_distance(YangKnoke01, path = c(1,2,4,5))

</code></pre>

<hr>
<h2 id='BuchDarrah19'>Example data for gretel</h2><span id='topic+BuchDarrah19'></span>

<h3>Description</h3>

<p>A sociomatrix encoding tie strengths among five nodes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BuchDarrah19
</code></pre>


<h3>Format</h3>

<p>a numeric matrix with 5 rows and 5 columns</p>


<h3>Source</h3>

<p>&lt;DOI:10.1016/j.socnet.2010.03.006&gt;
</p>

<hr>
<h2 id='dijkstra_inf'>Find the shortest L-Inf norm paths to other vertices</h2><span id='topic+dijkstra_inf'></span>

<h3>Description</h3>

<p>Find the shortest L-Inf norm paths to other vertices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dijkstra_inf(dist, src)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dijkstra_inf_+3A_dist">dist</code></td>
<td>
<p>A matrix of distances between nodes</p>
</td></tr>
<tr><td><code id="dijkstra_inf_+3A_src">src</code></td>
<td>
<p>An integer vertex ID</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector, entry <em>i</em> of which is the vertex immediately preceeding 
vertex <em>i</em> in the shortest path leading to <em>i</em>. Full paths must be constructed
recursively.
</p>

<hr>
<h2 id='dijkstra_nodes'>Find the shortest paths to other vertices</h2><span id='topic+dijkstra_nodes'></span>

<h3>Description</h3>

<p>Find the shortest paths to other vertices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dijkstra_nodes(dist, src, node_costs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dijkstra_nodes_+3A_dist">dist</code></td>
<td>
<p>A matrix of distances between nodes</p>
</td></tr>
<tr><td><code id="dijkstra_nodes_+3A_src">src</code></td>
<td>
<p>An integer vertex ID</p>
</td></tr>
<tr><td><code id="dijkstra_nodes_+3A_node_costs">node_costs</code></td>
<td>
<p>a list of costs, in order, of all nodes represented in the 
sociomatrix, all are assumed 0 if unspecified</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector, entry <em>i</em> of which is the vertex immediately preceeding 
vertex <em>i</em> in the shortest path leading to <em>i</em>. Full paths must be constructed
recursively.
</p>

<hr>
<h2 id='flament_average_path_length'>Yang and Knoke's Average Path Length</h2><span id='topic+flament_average_path_length'></span>

<h3>Description</h3>

<p>Calculates 'APL' (Average Path Length) as defined in Yang, Knoke (2001).
Called <code>flament_average_path_length</code> in homage to A.C. Flament, who defined
path length in 1963.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flament_average_path_length(sociomatrix, path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flament_average_path_length_+3A_sociomatrix">sociomatrix</code></td>
<td>
<p>a nonnegative, real valued sociomatrix.</p>
</td></tr>
<tr><td><code id="flament_average_path_length_+3A_path">path</code></td>
<td>
<p>an integer vector of node indices from <code>sociomatrix</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+flament_path_length">flament_path_length</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Calculate 'APL' of a path in a sociomatrix
flament_average_path_length(YangKnoke01, path = c(1,2,5))

## This path doesn't exist
flament_average_path_length(YangKnoke01, path = c(1,2,4,5))

</code></pre>

<hr>
<h2 id='flament_path_length'>Flament's Path Length Measure</h2><span id='topic+flament_path_length'></span>

<h3>Description</h3>

<p>Calculates path length as defined in Flament (1963). That is, sums the
values of each edge in the path, if all edges exist. Otherwise, returns <code>NA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flament_path_length(sociomatrix, path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flament_path_length_+3A_sociomatrix">sociomatrix</code></td>
<td>
<p>a nonnegative, real valued sociomatrix.</p>
</td></tr>
<tr><td><code id="flament_path_length_+3A_path">path</code></td>
<td>
<p>an integer vector of node indices from <code>sociomatrix</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+flament_average_path_length">flament_average_path_length</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Calculate Flament's Path Length along a path in a sociomatrix
flament_path_length(YangKnoke01, path = c(1,2,5))

## This path doesn't exist
flament_path_length(YangKnoke01, path = c(1,2,4,5))

</code></pre>

<hr>
<h2 id='generate_proximities'>Generate a Proximity Matrix</h2><span id='topic+generate_proximities'></span>

<h3>Description</h3>

<p>Generates a proximity matrix in one of three modes:
</p>

<dl>
<dt><code>'ogpv'</code></dt><dd><p>Optimal Generalized Path Value. Entry <code>i,j</code> of the 
proximity matrix will equal the optimal 'gpv' among all paths connecting node 
<code>i</code> to node <code>j</code>.</p>
</dd>
<dt><code>'oppv'</code></dt><dd><p>Optimal Probabilistic Path Value. Entry <code>i,j</code> of the 
proximity matrix will equal the optimal 'ppv' among all paths connecting node 
<code>i</code> to node <code>j</code>.</p>
</dd>
<dt><code>'sconductivity'</code></dt><dd><p>Social Conductivity (Random Walk Probability). If 
each tie strength recorded in <code>sociomatrix</code> is taken to be analogous to the 
conductivity of an electrical component, <code>i,j</code> of the proximity matrix 
will equal total conductivity of all paths from node <code>i</code> to node <code>j</code>.</p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>generate_proximities(sociomatrix, mode = c("ogpv", "oppv",
  "sconductivity"), p = Inf, node_costs = NULL, odds_scale = 1,
  odds_scale_by_node = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_proximities_+3A_sociomatrix">sociomatrix</code></td>
<td>
<p>a nonnegative, real valued sociomatrix.</p>
</td></tr>
<tr><td><code id="generate_proximities_+3A_mode">mode</code></td>
<td>
<p>a selection of <code>'ogpv'</code>, <code>'oppv'</code>, or <code>'sconductivity'</code></p>
</td></tr>
<tr><td><code id="generate_proximities_+3A_p">p</code></td>
<td>
<p>if <code>mode</code> is <code>'ogpv'</code>, determines 'p-norm' parameter for 
generalized path value calculation.</p>
</td></tr>
<tr><td><code id="generate_proximities_+3A_node_costs">node_costs</code></td>
<td>
<p>if <code>mode</code> is <code>'ogpv'</code>, assigns transmission costs to
vertices within the sociomatrix.</p>
</td></tr>
<tr><td><code id="generate_proximities_+3A_odds_scale">odds_scale</code></td>
<td>
<p>if <code>mode</code> is <code>'oppv'</code>, sets a global transfer odds 
scale for probabilistic path value calculation.</p>
</td></tr>
<tr><td><code id="generate_proximities_+3A_odds_scale_by_node">odds_scale_by_node</code></td>
<td>
<p>if <code>mode</code> is <code>'oppv'</code>, sets a transfer odds 
scale for each node in a probabilistic path value calculation.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+gpv">gpv</a></code>, <code><a href="#topic+ppv">ppv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate a proximity matrix in each mode
## Optimal Generalized Path Value
generate_proximities(YangKnoke01, mode = "ogpv", p = Inf, node_costs = c(1,3,3,2,1))

## Optimal Probabilistic Path Value
generate_proximities(YangKnoke01, mode = "oppv", odds_scale = 2)

## Sconductivity
generate_proximities(YangKnoke01, mode = "sconductivity")

</code></pre>

<hr>
<h2 id='gpv'>Generalized Path Value</h2><span id='topic+gpv'></span>

<h3>Description</h3>

<p>Calculates the generalized path value of a user-specified path through 
<code>sociomatrix</code>. Parameter <code>p</code> sets the p-norm used in calculation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gpv(sociomatrix, path, p = Inf, node_costs = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gpv_+3A_sociomatrix">sociomatrix</code></td>
<td>
<p>a nonnegative, real valued sociomatrix.</p>
</td></tr>
<tr><td><code id="gpv_+3A_path">path</code></td>
<td>
<p>an integer vector of node indices from <code>sociomatrix</code>.</p>
</td></tr>
<tr><td><code id="gpv_+3A_p">p</code></td>
<td>
<p>a nonnegative real number that sets the 'p-norm' parameter for 
generalized path value calculation.</p>
</td></tr>
<tr><td><code id="gpv_+3A_node_costs">node_costs</code></td>
<td>
<p>a list of costs, in order, of all nodes represented in the 
sociomatrix, all are assumed 0 if unspecified</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As a rule of thumb, p close to 0 will downweight the impact of particular
tie strengths and upweight the impact of binary path length. p equal to 
infinity will recapitulate the traditional path value measure of Peay (1980)
and is therefore the default. In other words, the value of a path under 
<code>p = Inf</code> will be the value of the weakest tie. The value of the same
path under <code>p = 0</code> will be the inverse of its binary length.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+opt_gpv">opt_gpv</a></code> to identify the path of optimal 'gpv' between two nodes 
and <code><a href="#topic+all_opt_gpv">all_opt_gpv</a></code> to identify the optimal paths between all pairs of 
nodes. Calling <code><a href="#topic+generate_proximities">generate_proximities</a></code> with <code>mode = 'gpv'</code> 
returns a matrix 'gpv' values for the optimal paths between all pairs of 
nodes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Calculate gpv along a path in a sociomatrix
gpv(YangKnoke01, path = c(1,2,5), p = 1)

## The same calculation, with nonzero node costs
gpv(YangKnoke01, path = c(1,2,5), p = 1, node_costs = c(1,3,3,2,1))

## This path doesn't exist
gpv(YangKnoke01, path = c(1,2,4,5), p = 0)

</code></pre>

<hr>
<h2 id='gretel'>sconduct: Generalized Path Analysis for Social Networks</h2><span id='topic+gretel'></span><span id='topic+gretel-package'></span>

<h3>Description</h3>

<p>This package contains two categories of functions. The first category is concerned
with assigning values to user specified paths, while the second identifies
paths of optimal value.
</p>


<h3>Details</h3>

<p>Key functions in the path value calculation category are
- <code>gpv</code>, which calculates Generalized Path Value
- <code>ppv</code>, which calculates Probabilistic Path Value
- <code>binary_distance</code>, <code>peay_path_value</code>, <code>flament_path_length</code>,
<code>peay_average_path_value</code>, and <code>flament_average_path_length</code>, which
calculate path value measures described in <em>Yang, Knoke</em> (2001).
- <code>generate_proximities</code>, which generates a matrix of values representing the
measures of optimal paths from each source node (row index) to each target node 
(column index).
</p>
<p>Key functions in the optimal path identification category are
- <code>opt_gpv</code>, which identifies the path of optimal Generalized Path Value from 
a particular source node to a particular target node
- <code>opt_ppv</code>, which identifies the path of optimal Probabilistic Path Value from
a particular source node to a particular target node
- <code>all_opt_gpv</code>, which identifies the 'gpv'-optimal paths from every source node 
to every target node
- <code>all_opt_ppv</code>, which identifies the 'ppv'-optimal paths from every source node
to every target node
- <code>unpack</code>, which unpacks the Dijkstra-format encoded shortest paths returned by
<code>all_opt_gpv</code> and <code>all_opt_ppv</code>. See their help pages for details.
</p>

<hr>
<h2 id='OpsahlEtAl10'>Example data from Opsahl, Agneessens, Skvoretz (2010)</h2><span id='topic+OpsahlEtAl10'></span>

<h3>Description</h3>

<p>A sociomatrix encoding tie strengths among five nodes, used for examples in
Opsahl, Agneessens, Skvoretz (2010) Social Networks 32(2010):245-251
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OpsahlEtAl10
</code></pre>


<h3>Format</h3>

<p>a numeric matrix with 5 rows and 5 columns</p>


<h3>Source</h3>

<p>&lt;DOI:10.1016/j.socnet.2010.03.006&gt;
</p>

<hr>
<h2 id='opt_gpv'>Optimize Generalized Path Value</h2><span id='topic+opt_gpv'></span>

<h3>Description</h3>

<p>Identify the path of optimal generalized path value from a source node
to a target node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opt_gpv(sociomatrix, source, target, p = Inf, node_costs = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opt_gpv_+3A_sociomatrix">sociomatrix</code></td>
<td>
<p>a nonnegative, real valued sociomatrix.</p>
</td></tr>
<tr><td><code id="opt_gpv_+3A_source">source</code></td>
<td>
<p>an integer index corresponding to a node in <code>sociomatrix</code></p>
</td></tr>
<tr><td><code id="opt_gpv_+3A_target">target</code></td>
<td>
<p>an integer index corresponding to a node in <code>sociomatrix</code></p>
</td></tr>
<tr><td><code id="opt_gpv_+3A_p">p</code></td>
<td>
<p>a nonnegative real number that sets the 'p-norm' parameter for 
generalized path value calculation.</p>
</td></tr>
<tr><td><code id="opt_gpv_+3A_node_costs">node_costs</code></td>
<td>
<p>a list of costs, in order, of all nodes represented in the 
sociomatrix, all are assumed 0 if unspecified</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+gpv">gpv</a></code> to calculate the value of a user-specified path,
<code><a href="#topic+all_opt_gpv">all_opt_gpv</a></code> to simultaneously identify the optimal paths 
from any source node to any target node.
</p>

<hr>
<h2 id='opt_ppv'>Optimize Probabilistic Path Value</h2><span id='topic+opt_ppv'></span>

<h3>Description</h3>

<p>Identify the path of optimal probabilistic path value from a source node
to a target node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opt_ppv(sociomatrix, source, target, odds_scale = 1,
  odds_scale_by_node = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opt_ppv_+3A_sociomatrix">sociomatrix</code></td>
<td>
<p>a nonnegative, real valued sociomatrix.</p>
</td></tr>
<tr><td><code id="opt_ppv_+3A_source">source</code></td>
<td>
<p>an integer index corresponding to a node in <code>sociomatrix</code></p>
</td></tr>
<tr><td><code id="opt_ppv_+3A_target">target</code></td>
<td>
<p>an integer index corresponding to a node in <code>sociomatrix</code></p>
</td></tr>
<tr><td><code id="opt_ppv_+3A_odds_scale">odds_scale</code></td>
<td>
<p>a nonnegative real number indicating the observed tie
strength value that corresponds to 1-1 transmission odds</p>
</td></tr>
<tr><td><code id="opt_ppv_+3A_odds_scale_by_node">odds_scale_by_node</code></td>
<td>
<p>sets a transfer odds scale for each node in a 
probabilistic path value calculation.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ppv">ppv</a></code> to calculate the value of a user-specified path,
<code><a href="#topic+all_opt_ppv">all_opt_ppv</a></code> to simultaneously identify the optimal paths 
from any source node to any target node.
</p>

<hr>
<h2 id='peay_average_path_value'>Yang and Knoke's Average Path Value</h2><span id='topic+peay_average_path_value'></span>

<h3>Description</h3>

<p>Calculates 'APV' (Average Path Value) as defined in Yang, Knoke (2001)
Called <code>peay_average_path_value</code> in homage to E.R. Peay, who defined 
path length in 1980.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>peay_average_path_value(sociomatrix, path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="peay_average_path_value_+3A_sociomatrix">sociomatrix</code></td>
<td>
<p>a nonnegative, real valued sociomatrix.</p>
</td></tr>
<tr><td><code id="peay_average_path_value_+3A_path">path</code></td>
<td>
<p>an integer vector of node indices from <code>sociomatrix</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+peay_path_value">peay_path_value</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Calculate 'APV' of a path in a sociomatrix
peay_average_path_value(YangKnoke01, path = c(1,2,5))

## This path doesn't exist
peay_average_path_value(YangKnoke01, path = c(1,2,4,5))

</code></pre>

<hr>
<h2 id='peay_path_value'>Peay's Path Value Measure</h2><span id='topic+peay_path_value'></span>

<h3>Description</h3>

<p>Calculates path value as defined in Peay (1980). That is, returns the
value of the weakest connection in the path, if all edges exist. 
Otherwise, returns 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>peay_path_value(sociomatrix, path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="peay_path_value_+3A_sociomatrix">sociomatrix</code></td>
<td>
<p>a nonnegative, real valued sociomatrix.</p>
</td></tr>
<tr><td><code id="peay_path_value_+3A_path">path</code></td>
<td>
<p>an integer vector of node indices from <code>sociomatrix</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+peay_average_path_value">peay_average_path_value</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Calculate Peay's Path Value along a path in a sociomatrix
peay_path_value(YangKnoke01, path = c(1,2,5))

## This path doesn't exist
peay_path_value(YangKnoke01, path = c(1,2,4,5))

</code></pre>

<hr>
<h2 id='ppv'>Calculate probabilistic path value</h2><span id='topic+ppv'></span>

<h3>Description</h3>

<p>Given a real valued sociomatrix, a path, and an optional <code>odds_scale</code>, <code>ppv</code>
calculates the transmission odds for the path and returns the transmission odds
times <code>odds_scale</code> so the result can be directly compared with observed 
tie strenghts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ppv(sociomatrix, path, odds_scale = 1, odds_scale_by_node = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ppv_+3A_sociomatrix">sociomatrix</code></td>
<td>
<p>a nonnegative, real valued sociomatrix.</p>
</td></tr>
<tr><td><code id="ppv_+3A_path">path</code></td>
<td>
<p>an integer vector of node indices from <code>sociomatrix</code>.</p>
</td></tr>
<tr><td><code id="ppv_+3A_odds_scale">odds_scale</code></td>
<td>
<p>a nonnegative real number indicating the observed tie
strength value that corresponds to 1-1 transmission odds</p>
</td></tr>
<tr><td><code id="ppv_+3A_odds_scale_by_node">odds_scale_by_node</code></td>
<td>
<p>sets a transfer odds scale for each node in a 
probabilistic path value calculation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We assume that observed tie strengths in <code>sociomatrix</code> are linearly
proportional to transmission odds. That is, if the transmission odds for
a strength 1 tie are 1 to 1, the transmission odds for a strength 5 tie are
1 to 5.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+opt_ppv">opt_ppv</a></code> to identify the path of optimal 'ppv' between two nodes 
and <code><a href="#topic+all_opt_ppv">all_opt_ppv</a></code> to identify the optimal paths between all pairs of 
nodes. Calling <code><a href="#topic+generate_proximities">generate_proximities</a></code> with <code>mode = 'ppv'</code> 
returns a matrix 'ppv' values for the optimal paths between all pairs of 
nodes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Calculate ppv along a path in a sociomatrix
ppv(YangKnoke01, path = c(1,2,5), odds_scale = 3)

## This path doesn't exist
gpv(YangKnoke01, path = c(1,2,4,5))

</code></pre>

<hr>
<h2 id='unpack'>Unpacks a Path from a Dijkstra-Format Spanning Tree</h2><span id='topic+unpack'></span>

<h3>Description</h3>

<p>Used with <code>all_opt_gpv</code> and <code>all_opt_ppv</code> to 
unpack individual paths from the Dijkstra-format trees that 
those functions return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unpack(tree, source, target)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unpack_+3A_tree">tree</code></td>
<td>
<p>a Dijkstra-format tree returned by <code>all_opt_gpv</code> or <code>all_opt_ppv</code></p>
</td></tr>
<tr><td><code id="unpack_+3A_source">source</code></td>
<td>
<p>an integer index corresponding to a node in <code>sociomatrix</code></p>
</td></tr>
<tr><td><code id="unpack_+3A_target">target</code></td>
<td>
<p>an integer index corresponding to a node in <code>sociomatrix</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns <code>NA</code> if a path does not exist
</p>

<hr>
<h2 id='YangKnoke01'>Example data from Yang, Knoke (2001)</h2><span id='topic+YangKnoke01'></span>

<h3>Description</h3>

<p>A sociomatrix encoding tie strengths among five nodes, used 
for examples in Yang, S., Knoke, D. (2001) Social Networks 23(4):285-295
</p>


<h3>Usage</h3>

<pre><code class='language-R'>YangKnoke01
</code></pre>


<h3>Format</h3>

<p>a numeric matrix with 5 rows and 5 columns</p>


<h3>Source</h3>

<p>&lt;DOI: 10.1016/S0378-8733(01)00043-0&gt;
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
