<!DOCTYPE html><html><head><title>Help for package proporz</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {proporz}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#biproporz'><p>Biproportional apportionment</p></a></li>
<li><a href='#ceil_at'><p>Rounding with predefined thresholds</p></a></li>
<li><a href='#divide_votes_matrix'><p>Calculate raw seat matrix</p></a></li>
<li><a href='#divisor_methods'><p>Divisor methods</p></a></li>
<li><a href='#find_divisor'><p>Find divisor to assign seats</p></a></li>
<li><a href='#find_matrix_divisors'><p>Find divisors for a matrix with alternate scaling</p></a></li>
<li><a href='#finland2019'><p>Finnish Parliamentary Elections Data (2019)</p></a></li>
<li><a href='#get_divisors'><p>Get district and party divisors from biproporz result</p></a></li>
<li><a href='#highest_averages_method'><p>Highest averages method</p></a></li>
<li><a href='#largest_remainder_method'><p>Largest remainder method</p></a></li>
<li><a href='#lower_apportionment'><p>Calculate lower apportionment</p></a></li>
<li><a href='#pivot_to_matrix'><p>Pivot long data.frame to wide matrix and vice versa</p></a></li>
<li><a href='#proporz'><p>Proportional apportionment</p></a></li>
<li><a href='#proporz_methods'><p>List of method names and their implementation</p></a></li>
<li><a href='#pukelsheim'><p>Biproportional apportionment with data frames</p></a></li>
<li><a href='#quorum_functions'><p>Create quorum functions for biproportional apportionment</p></a></li>
<li><a href='#reached_quorum_any_district'><p>Check if lists/parties have reached a quorum in at least one district</p></a></li>
<li><a href='#reached_quorum_total'><p>Check if lists/parties have reached the quorum for all votes</p></a></li>
<li><a href='#reached_quorums'><p>Apply a list of quorum functions to a votes matrix</p></a></li>
<li><a href='#run_app'><p>Use biproportional apportionment interactively in a shiny app</p></a></li>
<li><a href='#upper_apportionment'><p>Calculate upper apportionment</p></a></li>
<li><a href='#uri2020'><p>Election Data for the Cantonal Council of Uri (2020)</p></a></li>
<li><a href='#weight_list_votes'><p>Create weighted votes matrix</p></a></li>
<li><a href='#zug2018'><p>Election Data for the Cantonal Council of Zug (2018)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Proportional Apportionment</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Calculate seat apportionment for legislative bodies with 
    various methods. The algorithms include divisor or highest averages methods
    (e.g. Jefferson, Webster or Adams), largest remainder methods and 
    biproportional apportionment.
    Gaffke, N. &amp; Pukelsheim, F. (2008) &lt;<a href="https://doi.org/10.1016%2Fj.mathsocsci.2008.01.004">doi:10.1016/j.mathsocsci.2008.01.004</a>&gt;
    Oelbermann, K. F. (2016) &lt;<a href="https://doi.org/10.1016%2Fj.mathsocsci.2016.02.003">doi:10.1016/j.mathsocsci.2016.02.003</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>shiny, shinyMatrix, testthat, knitr, rmarkdown</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/polettif/proporz">https://github.com/polettif/proporz</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/polettif/proporz/issues">https://github.com/polettif/proporz/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-03 16:00:49 UTC; flaviopoletti</td>
</tr>
<tr>
<td>Author:</td>
<td>Flavio Poletti [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Flavio Poletti &lt;flavio.poletti@hotmail.ch&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-03 16:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='biproporz'>Biproportional apportionment</h2><span id='topic+biproporz'></span>

<h3>Description</h3>

<p>Method to proportionally allocate seats among parties (or lists) and districts (or
entities, regions), thus bi-proportional.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>biproporz(
  votes_matrix,
  district_seats,
  quorum,
  use_list_votes = TRUE,
  method = "round"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="biproporz_+3A_votes_matrix">votes_matrix</code></td>
<td>
<p>Vote count matrix with votes by party in rows and votes by district
in columns</p>
</td></tr>
<tr><td><code id="biproporz_+3A_district_seats">district_seats</code></td>
<td>
<p>Vector defining the number of seats per district. Must be the same
length as <code>ncol(votes_matrix)</code>. Values are name-matched to <code>votes_matrix</code> if both are
named. If the number of seats per district should be assigned according to the number
of votes (not the general use case), a single number for the total number of seats can
be used.</p>
</td></tr>
<tr><td><code id="biproporz_+3A_quorum">quorum</code></td>
<td>
<p>Optional list of functions which take the votes_matrix and return a logical
vector that denotes for each list/party whether they reached the quorum (i.e. are
eligible for seats). The easiest way to do this is via <code><a href="#topic+quorum_any">quorum_any()</a></code> or
<code><a href="#topic+quorum_all">quorum_all()</a></code>, see examples. Alternatively you can pass a precalculated logical
vector. No quorum is applied if parameter is missing or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="biproporz_+3A_use_list_votes">use_list_votes</code></td>
<td>
<p>By default (<code>TRUE</code>) it's assumed that each voter in a district has
as many votes as there are seats in a district. Thus, votes are weighted according to
the number of available district seats with <code><a href="#topic+weight_list_votes">weight_list_votes()</a></code>. Set to <code>FALSE</code> if
<code>votes_matrix</code> shows the number of voters (e.g. they can only cast one vote for one
party).</p>
</td></tr>
<tr><td><code id="biproporz_+3A_method">method</code></td>
<td>
<p>Defines which method is used to assign seats. The following methods are
recommended:
</p>

<ul>
<li><p><code>round</code>: Uses the Sainte-Laguë/Webster method (rounding half up) for the upper
and lower apportionment which is the standard for biproportional apportionment and
the only method guaranteed to terminate.
</p>
</li>
<li><p><code>wto</code>: &quot;winner take one&quot; works like &quot;round&quot; with a condition that the party that
got the most votes in a district must get <em>at least</em> one seat ('Majorzbedingung')
in said district. Seats in the upper apportionment are assigned with
Sainte-Laguë/Webster. <code>votes_matrix</code> must have row and column names to use this
method. See <code><a href="#topic+lower_apportionment">lower_apportionment()</a></code> for more details.
</p>
</li></ul>

<p>It is also possible to use any divisor method name listed in <code><a href="#topic+proporz">proporz()</a></code>. If you want to
use a different method for the upper and lower apportionment, provide a list with two
entries.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each party nominates a candidate list for every district. The voters vote for
the parties of their district. The seat allocation is calculated in two steps:
</p>

<ol>
<li><p> In the so called <code><a href="#topic+upper_apportionment">upper apportionment</a></code>
the number of seats for each party (over all districts) is determined.
Normally, the number of seats for each region are defined before the
election and are independent of the vote counts.
</p>
</li>
<li><p> In the so called <code><a href="#topic+lower_apportionment">lower apportionment</a></code>
the seats are distributed to the regional party list respecting the
results from the upper apportionment.
</p>
</li></ol>

<p>Parties failing to reach quorums cannot get seats. This function does not handle seat
assignment to candidates.
</p>


<h3>Value</h3>

<p>Matrix with the same dimension as <code>votes_matrix</code> containing the number of seats
with the row and column divisors stored in attributes (hidden from print, see
<code><a href="#topic+get_divisors">get_divisors()</a></code>).
</p>


<h3>Note</h3>

<p>The iterative process in the lower apportionment is only guaranteed to terminate
with the default Sainte-Laguë/Webster method.
</p>


<h3>References</h3>

<p>Gaffke, Norbert; Pukelsheim, Friedrich (2008): Divisor methods for
proportional representation systems: An optimization approach to vector and matrix
apportionment problems. Mathematical Social Sciences, 56 (2), 166-184.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pukelsheim">pukelsheim()</a></code> for biproportional apportionment with <code>data.frames</code> as inputs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>votes_matrix = uri2020$votes_matrix
district_seats = uri2020$seats_vector

biproporz(votes_matrix, district_seats)

# apply quorum (high values for illustrative purposes)
biproporz(votes_matrix, district_seats,
          quorum_all(any_district = 0.1, total = 0.25))

</code></pre>

<hr>
<h2 id='ceil_at'>Rounding with predefined thresholds</h2><span id='topic+ceil_at'></span>

<h3>Description</h3>

<p>Round <code>x</code> up to <code>ceiling(x)</code> if <code>x-floor(x) &gt;= threshold</code>,
otherwise round down to <code>floor(x)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ceil_at(x, threshold)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ceil_at_+3A_x">x</code></td>
<td>
<p>numeric vector or matrix &gt;= 0 (<code>NaN</code> is not supported)</p>
</td></tr>
<tr><td><code id="ceil_at_+3A_threshold">threshold</code></td>
<td>
<p>threshold in [0,1] or &quot;harmonic&quot;/&quot;geometric&quot; to use
harmonic or geometric mean thresholds</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the rounded vector or matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ceil_at(c(0.5, 1.5, 2.49, 2.5, 2.51), 0.5)
# compare to
round(c(0.5, 1.5, 2.49, 2.5, 2.51))

ceil_at(c(1.45, 2.45, 3.45), 0) # like floor()
ceil_at(c(1.45, 2.45, 3.45, 0.2), "geometric")
</code></pre>

<hr>
<h2 id='divide_votes_matrix'>Calculate raw seat matrix</h2><span id='topic+divide_votes_matrix'></span>

<h3>Description</h3>

<p>Apply row and column divisors to matrix to get non-rounded seat values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>divide_votes_matrix(M, col_divisors, row_divisors)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="divide_votes_matrix_+3A_m">M</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="divide_votes_matrix_+3A_col_divisors">col_divisors</code></td>
<td>
<p>divisors to apply to columns</p>
</td></tr>
<tr><td><code id="divide_votes_matrix_+3A_row_divisors">row_divisors</code></td>
<td>
<p>divisors to apply to rows</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with the same dimension as <code>M</code> containing non-rounded seat values
</p>

<hr>
<h2 id='divisor_methods'>Divisor methods</h2><span id='topic+divisor_methods'></span><span id='topic+divisor_round'></span><span id='topic+divisor_floor'></span><span id='topic+divisor_harmonic'></span><span id='topic+divisor_geometric'></span><span id='topic+divisor_ceiling'></span>

<h3>Description</h3>

<p>Functions to directly apply divisor apportionment methods instead
of calling <code><a href="#topic+proporz">proporz()</a></code> with a method parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>divisor_round(votes, n_seats, quorum = 0)

divisor_floor(votes, n_seats, quorum = 0)

divisor_harmonic(votes, n_seats, quorum = 0)

divisor_geometric(votes, n_seats, quorum = 0)

divisor_ceiling(votes, n_seats, quorum = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="divisor_methods_+3A_votes">votes</code></td>
<td>
<p>numeric vector with number of votes for each party</p>
</td></tr>
<tr><td><code id="divisor_methods_+3A_n_seats">n_seats</code></td>
<td>
<p>total number of seats</p>
</td></tr>
<tr><td><code id="divisor_methods_+3A_quorum">quorum</code></td>
<td>
<p>Vote threshold a party must reach. Used as quota of total
votes within a district if less than 1 otherwise as number
of votes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Divisor methods are known under different names:
</p>

<ul>
<li><p>d'hondt, jefferson, hagenbach-bischoff: use <code><a href="#topic+divisor_floor">divisor_floor()</a></code>
</p>
</li>
<li><p>sainte-lague, webster: use <code><a href="#topic+divisor_round">divisor_round()</a></code>
</p>
</li>
<li><p>adams: use <code><a href="#topic+divisor_ceiling">divisor_ceiling()</a></code>
</p>
</li>
<li><p>dean: use <code><a href="#topic+divisor_harmonic">divisor_harmonic()</a></code>
</p>
</li>
<li><p>huntington-hill, hill-huntington: use <code><a href="#topic+divisor_geometric">divisor_geometric()</a></code>
</p>
</li></ul>

<p>All divisor functions call <code><a href="#topic+highest_averages_method">highest_averages_method()</a></code> with a different sequence of
divisors.
</p>


<h3>Value</h3>

<p>The number of seats per party as a vector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+proporz">proporz()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>votes = c("Party A" = 690, "Party B" = 400,
          "Party C" = 250, "Party D" = 120)

divisor_round(votes, 10)

divisor_floor(votes, 10)

divisor_ceiling(votes, 10)

divisor_ceiling(votes, 5)

divisor_geometric(votes, 10, quorum = 0.05)

divisor_harmonic(votes, 10)
</code></pre>

<hr>
<h2 id='find_divisor'>Find divisor to assign seats</h2><span id='topic+find_divisor'></span>

<h3>Description</h3>

<p>Find a divisor between <code>divisor_from</code> and <code>divisor_to</code> such as
<code>sum(round_func(votes/divisor))</code> equals <code>target_seats</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_divisor(votes, divisor_from, divisor_to, target_seats, round_func)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_divisor_+3A_votes">votes</code></td>
<td>
<p>votes (matrix with only one column or vector, allows to use row/colnames
within <code>round_func</code>)</p>
</td></tr>
<tr><td><code id="find_divisor_+3A_divisor_from">divisor_from</code></td>
<td>
<p>lower bound for divisor search range (is decreased if necessary)</p>
</td></tr>
<tr><td><code id="find_divisor_+3A_divisor_to">divisor_to</code></td>
<td>
<p>upper bound for divisor search range (is increased if necessary)</p>
</td></tr>
<tr><td><code id="find_divisor_+3A_target_seats">target_seats</code></td>
<td>
<p>number of seats to distribute (single number)</p>
</td></tr>
<tr><td><code id="find_divisor_+3A_round_func">round_func</code></td>
<td>
<p>rounding function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>divisor
</p>

<hr>
<h2 id='find_matrix_divisors'>Find divisors for a matrix with alternate scaling</h2><span id='topic+find_matrix_divisors'></span>

<h3>Description</h3>

<p>Find divisors for a matrix with alternate scaling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_matrix_divisors(M, seats_cols, seats_rows, round_func)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_matrix_divisors_+3A_m">M</code></td>
<td>
<p>votes_matrix</p>
</td></tr>
<tr><td><code id="find_matrix_divisors_+3A_seats_cols">seats_cols</code></td>
<td>
<p>target seats for each column</p>
</td></tr>
<tr><td><code id="find_matrix_divisors_+3A_seats_rows">seats_rows</code></td>
<td>
<p>target seats for each row</p>
</td></tr>
<tr><td><code id="find_matrix_divisors_+3A_round_func">round_func</code></td>
<td>
<p>rounding function. Called like
<code>round_func(M/row_divisors/col_divisors)</code>, divisors are applied row/col-wise with
<code><a href="#topic+divide_votes_matrix">divide_votes_matrix()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of divisors (column and row)
</p>

<hr>
<h2 id='finland2019'>Finnish Parliamentary Elections Data (2019)</h2><span id='topic+finland2019'></span>

<h3>Description</h3>

<p>Example data from the 2019 Finnish parliamentary elections. The data has been
cleaned up and only contains information relevant for this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>finland2019
</code></pre>


<h3>Format</h3>

<p>List containing two data.frames:
</p>

<ul>
<li><p><code>votes_df</code> containing the number of votes for each party and district.
229 rows, 3 columns (<code>party_name</code>, <code>district_name</code>, <code>votes</code>)
</p>
</li>
<li><p><code>district_seats_df</code> with the number of seats per district.
12 rows, 2 columns (<code>district_name</code>, <code>seats</code>)
</p>
</li></ul>



<h3>Source</h3>

<p><a href="https://tulospalvelu.vaalit.fi/EKV-2019/en/ladattavat_tiedostot.html">https://tulospalvelu.vaalit.fi/EKV-2019/en/ladattavat_tiedostot.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>finland2019$district_seats_df

head(finland2019$votes_df)
</code></pre>

<hr>
<h2 id='get_divisors'>Get district and party divisors from biproporz result</h2><span id='topic+get_divisors'></span>

<h3>Description</h3>

<p>Show the district and party divisors used to assign seats.
This method provides easier access to divisors stored in
<code>attributes(...)$divisors</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_divisors(biproporz_result)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_divisors_+3A_biproporz_result">biproporz_result</code></td>
<td>
<p>a matrix created by <code><a href="#topic+biproporz">biproporz()</a></code>
or a data.frame created by <code><a href="#topic+pukelsheim">pukelsheim()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The district and party divisors in a list, each as a vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>seats_matrix = biproporz(uri2020$votes_matrix, uri2020$seats_vector)
get_divisors(seats_matrix)

</code></pre>

<hr>
<h2 id='highest_averages_method'>Highest averages method</h2><span id='topic+highest_averages_method'></span>

<h3>Description</h3>

<p>Allocate seats proportionally for <code><a href="#topic+divisor_methods">divisor methods</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>highest_averages_method(votes, n_seats, divisors)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="highest_averages_method_+3A_votes">votes</code></td>
<td>
<p>numeric vector with number of votes for each party</p>
</td></tr>
<tr><td><code id="highest_averages_method_+3A_n_seats">n_seats</code></td>
<td>
<p>total number of seats</p>
</td></tr>
<tr><td><code id="highest_averages_method_+3A_divisors">divisors</code></td>
<td>
<p>sequence of divisors (length equal to the number of seats).
If it is a single number (e.g. 0.5), a sequence is generated
starting with it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The highest averages method requires the number of votes for each party to
be divided successively by a series of divisors. This produces a table of
quotients, or averages, with a row for each divisor and a column for each
party. The nth seat is allocated to the party whose column contains the nth
largest entry in this table, up to the total number of seats
available. (<a href="https://en.wikipedia.org/wiki/Highest_averages_method">Wikipedia</a>)
</p>


<h3>Value</h3>

<p>The number of seats per party as a vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>highest_averages_method(c(5200, 1700, 3100), 15, 0.5)

highest_averages_method(votes = c(50, 0, 30), n_seats = 3,
                        divisors = c(0, 1.3333, 2.4))
</code></pre>

<hr>
<h2 id='largest_remainder_method'>Largest remainder method</h2><span id='topic+largest_remainder_method'></span>

<h3>Description</h3>

<p>Allocate seats based on the largest fractional remainder. The largest remainder method is
also known as: Hamilton, Hare-Niemeyer or Vinton method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>largest_remainder_method(votes, n_seats, quorum = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="largest_remainder_method_+3A_votes">votes</code></td>
<td>
<p>numeric vector with number of votes for each party</p>
</td></tr>
<tr><td><code id="largest_remainder_method_+3A_n_seats">n_seats</code></td>
<td>
<p>total number of seats</p>
</td></tr>
<tr><td><code id="largest_remainder_method_+3A_quorum">quorum</code></td>
<td>
<p>Vote threshold a party must reach. Used as quota of total
votes within a district if less than 1 otherwise as number
of votes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The numbers of votes for each party is divided by a quota representing the number of
votes required for a seat. Then, each party receives the rounded down quota value as
seats. The remaining seats are given to the party with the largest remainder until all
seats have been distributed.
</p>


<h3>Value</h3>

<p>The number of seats per party as a vector
</p>


<h3>Note</h3>

<p>Only the quota <code style="white-space: pre;">&#8288;total votes / total seats&#8288;</code> (which is used by the aforementioned
methods) is implemented.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+proporz">proporz()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>votes = c(47000, 16000, 15800, 12000, 6100, 3100)
largest_remainder_method(votes, 10)

</code></pre>

<hr>
<h2 id='lower_apportionment'>Calculate lower apportionment</h2><span id='topic+lower_apportionment'></span>

<h3>Description</h3>

<p>Iterate and change column and row divisors such that the row and column sums of the seats
matrix satisfies the constraints given by the upper apportionment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lower_apportionment(votes_matrix, seats_cols, seats_rows, method = "round")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lower_apportionment_+3A_votes_matrix">votes_matrix</code></td>
<td>
<p>matrix with votes by party in rows and votes by district in columns.</p>
</td></tr>
<tr><td><code id="lower_apportionment_+3A_seats_cols">seats_cols</code></td>
<td>
<p>number of seats per column (districts/regions), predetermined or
calculated with <code><a href="#topic+upper_apportionment">upper_apportionment()</a></code>.</p>
</td></tr>
<tr><td><code id="lower_apportionment_+3A_seats_rows">seats_rows</code></td>
<td>
<p>number of seats per row (parties/lists), calculated with
<code><a href="#topic+upper_apportionment">upper_apportionment()</a></code>.</p>
</td></tr>
<tr><td><code id="lower_apportionment_+3A_method">method</code></td>
<td>
<p>Apportion method that defines how seats are assigned. The
following methods are supported:
</p>

<ul>
<li><p><code>round</code>: The default Sainte-Laguë/Webster method is the standard
for biproportional apportionment and the only method guaranteed to terminate.
</p>
</li>
<li><p><code>wto</code>: &quot;winner take one&quot; works like &quot;round&quot; with a condition that the party that
got the most votes in a district must get <em>at least</em> one seat ('Majorzbedingung').
The condition does not apply in a district if two or more parties have the same
number of votes and there are not enough seats for these parties. A warning is
issued in this case. Modify the votes matrix to explicitly break ties.
</p>
</li>
<li><p>You can provide a custom function that rounds a matrix (i.e. the
the votes_matrix divided by party and list divisors).
</p>
</li>
<li><p>It is possible to use any divisor method name listed in <code><a href="#topic+proporz">proporz()</a></code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>The result is obtained by an iterative process ('Alternate Scaling Algorithm', see
Reference). Initially, for each district a divisor is chosen using the highest averages
method for the votes allocated to each regional party list in this region. For each party
a party divisor is initialized with 1.
</p>
<p>Effectively, the objective of the iterative process is to modify the regional divisors
and party divisors so that the number of seats in each regional party list equals the
number of their votes divided by both the regional and the party divisors.
</p>
<p>The following two correction steps are executed until this objective is satisfied:
</p>

<ul>
<li><p> modify the party divisors such that the apportionment within each
party is correct with the chosen rounding method,
</p>
</li>
<li><p> modify the regional divisors such that the apportionment within the
region is correct with the chosen rounding method.
</p>
</li></ul>



<h3>Value</h3>

<p>A seat matrix with district (columns) and party (rows) divisors stored in
attributes.
</p>


<h3>References</h3>

<p>Oelbermann, K. F. (2016): Alternate scaling algorithm for biproportional
divisor methods. Mathematical Social Sciences, 80, 25-32.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+biproporz">biproporz()</a></code>, <code><a href="#topic+upper_apportionment">upper_apportionment()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>votes_matrix = matrix(c(123,912,312,45,714,255,815,414,215), nrow = 3)
district_seats = c(7,5,8)
party_seats = c(5,11,4)

lower_apportionment(votes_matrix, district_seats, party_seats)


# using "winner take one"
vm = matrix(c(200,100,10,11), 2,
            dimnames = list(c("Party A", "Party B"), c("I", "II")))
district_seats = setNames(c(2,1), colnames(vm))
ua = upper_apportionment(vm, district_seats)

lower_apportionment(vm, ua$district, ua$party, method = "wto")

# compare to standard method
lower_apportionment(vm, ua$district, ua$party, method = "round")

</code></pre>

<hr>
<h2 id='pivot_to_matrix'>Pivot long data.frame to wide matrix and vice versa</h2><span id='topic+pivot_to_matrix'></span><span id='topic+pivot_to_df'></span>

<h3>Description</h3>

<p>Create a matrix in 'wide' format from a data.frame with 3 columns with
<code>pivot_to_matrix</code> or create a data.frame in long format from a matrix with
<code>pivot_to_df.</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pivot_to_matrix(df_long)

pivot_to_df(matrix_wide, value_colname = "values")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pivot_to_matrix_+3A_df_long">df_long</code></td>
<td>
<p>data.frame in long format with exactly 3 columns</p>
</td></tr>
<tr><td><code id="pivot_to_matrix_+3A_matrix_wide">matrix_wide</code></td>
<td>
<p>matrix in wide format</p>
</td></tr>
<tr><td><code id="pivot_to_matrix_+3A_value_colname">value_colname</code></td>
<td>
<p>name for the new value column in the
resulting data.frame</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These pivot functions are used to prepare data for <code><a href="#topic+biproporz">biproporz()</a></code> in
<code><a href="#topic+pukelsheim">pukelsheim()</a></code>. They are not supposed to cover general use cases or provide
customization. They mainly exist because reshape is hard to handle and the
package should have no dependencies.
</p>


<h3>Value</h3>

<p>A data.frame with 3 columns or a matrix. Note that the results are
sorted by the first and second column (data.frame) or row/column
names (matrix).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># From data.frame to matrix
df = data.frame(party = c("A", "A", "A", "B", "B", "B"),
                region = c("III", "II", "I", "I", "II", "III"),
                seats = c(5L, 3L, 1L, 2L, 4L, 6L))
pivot_to_matrix(df)

# from matrix to data.frame
mtrx = matrix(1:6, nrow = 2)
pivot_to_df(mtrx)

# from matrix to data.frame using dimnames
dimnames(mtrx) &lt;- list(party = c("A", "B"), region = c("I", "II", "III"))
pivot_to_df(mtrx, "seats")

# Note that pivot results are sorted
pivot_to_df(pivot_to_matrix(df)) == df[order(df[[1]], df[[2]]),]

</code></pre>

<hr>
<h2 id='proporz'>Proportional apportionment</h2><span id='topic+proporz'></span>

<h3>Description</h3>

<p>Calculate seat apportionment for legislative bodies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proporz(votes, n_seats, method, quorum = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="proporz_+3A_votes">votes</code></td>
<td>
<p>numeric vector with number of votes for each party</p>
</td></tr>
<tr><td><code id="proporz_+3A_n_seats">n_seats</code></td>
<td>
<p>total number of seats</p>
</td></tr>
<tr><td><code id="proporz_+3A_method">method</code></td>
<td>
<p>Apportionment method to use, as character. Not case sensitive. See details.</p>
</td></tr>
<tr><td><code id="proporz_+3A_quorum">quorum</code></td>
<td>
<p>Vote threshold a party must reach. Used as quota of total
votes within a district if less than 1 otherwise as number
of votes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following methods are available: </p>

<ul>
<li><p>d'hondt, jefferson, hagenbach-bischoff, floor: use <code><a href="#topic+divisor_floor">divisor_floor()</a></code>
</p>
</li>
<li><p>sainte-lague, webster, round: use <code><a href="#topic+divisor_round">divisor_round()</a></code>
</p>
</li>
<li><p>adams, ceiling: use <code><a href="#topic+divisor_ceiling">divisor_ceiling()</a></code>
</p>
</li>
<li><p>dean, harmonic: use <code><a href="#topic+divisor_harmonic">divisor_harmonic()</a></code>
</p>
</li>
<li><p>huntington-hill, hill-huntington, geometric: use <code><a href="#topic+divisor_geometric">divisor_geometric()</a></code>
</p>
</li>
<li><p>hare-niemeyer, hamilton, vinton, largest_remainder_method: use <code><a href="#topic+largest_remainder_method">largest_remainder_method()</a></code>
</p>
</li></ul>



<h3>Value</h3>

<p>The number of seats per party as a vector
</p>


<h3>Note</h3>

<p>Seats can also be apportioned among regions instead of parties. The
parameter <code>votes</code> is then normally used with census data (e.g.
population counts).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>votes = c("Party A" = 651, "Party B" = 349, "Party C" = 50)

proporz(votes, 10, "sainte-lague")

proporz(votes, 10, "hill-huntington")

proporz(votes, 10, "hill-huntington", quorum = 0.05)

proporz(votes, 10, "jefferson", quorum = 70)

</code></pre>

<hr>
<h2 id='proporz_methods'>List of method names and their implementation</h2><span id='topic+proporz_methods'></span>

<h3>Description</h3>

<p>Names can be used in <code><a href="#topic+proporz">proporz()</a></code> or <code><a href="#topic+biproporz">biproporz()</a></code>, the list entries
denote the name of the implementation function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proporz_methods
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 23.
</p>


<h3>Value</h3>

<p>Named list of methods
</p>

<hr>
<h2 id='pukelsheim'>Biproportional apportionment with data frames</h2><span id='topic+pukelsheim'></span>

<h3>Description</h3>

<p>Method to proportionally allocate seats among parties/lists and
districts/regions/entities ('Doppelter Pukelsheim').
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pukelsheim(
  votes_df,
  district_seats_df,
  quorum,
  new_seats_col = "seats",
  use_list_votes = TRUE,
  winner_take_one = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pukelsheim_+3A_votes_df">votes_df</code></td>
<td>
<p>data.frame (long format) with 3 columns (actual colnames can differ):
</p>

<ul>
<li><p> party id/name
</p>
</li>
<li><p> district id/name
</p>
</li>
<li><p> votes
</p>
</li></ul>
</td></tr>
<tr><td><code id="pukelsheim_+3A_district_seats_df">district_seats_df</code></td>
<td>
<p>data.frame with 2 columns (actual colnames can differ):
</p>

<ul>
<li><p> district id/name
</p>
</li>
<li><p> number of seats for a district
</p>
</li></ul>
</td></tr>
<tr><td><code id="pukelsheim_+3A_quorum">quorum</code></td>
<td>
<p>Optional list of functions which take the votes_matrix and return a logical
vector that denotes for each list/party whether they reached the quorum (i.e. are
eligible for seats). The easiest way to do this is via <code><a href="#topic+quorum_any">quorum_any()</a></code> or
<code><a href="#topic+quorum_all">quorum_all()</a></code>, see examples. Alternatively you can pass a precalculated logical
vector. No quorum is applied if parameter is missing or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="pukelsheim_+3A_new_seats_col">new_seats_col</code></td>
<td>
<p>name of the new column</p>
</td></tr>
<tr><td><code id="pukelsheim_+3A_use_list_votes">use_list_votes</code></td>
<td>
<p>By default (<code>TRUE</code>) it's assumed that each voter in a district has
as many votes as there are seats in a district. Set to <code>FALSE</code> if <code>votes_df</code> shows the
number of voters (e.g. they can only vote for one party).</p>
</td></tr>
<tr><td><code id="pukelsheim_+3A_winner_take_one">winner_take_one</code></td>
<td>
<p>Set to <code>TRUE</code> if the party that got the most votes in a district
must get <em>at least</em> one seat ('Majorzbedingung') in this district. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each party nominates a candidate list for every district. The voters vote for the parties
of their district. The seat allocation is calculated in two steps:
</p>

<ol>
<li><p> In the so called <code><a href="#topic+upper_apportionment">upper apportionment</a></code>
the number of seats for each party (over all districts) is determined.
</p>
</li>
<li><p> In the so called <code><a href="#topic+lower_apportionment">lower apportionment</a></code>
the seats are distributed to the regional party list respecting the results
from the upper apportionment.
</p>
</li></ol>

<p>Parties failing to reach quorums cannot get seats. This function does not handle seat
assignment to candidates.
</p>
<p>If you want to use other apportion methods than Sainte-Laguë use <code><a href="#topic+biproporz">biproporz()</a></code>.
</p>


<h3>Value</h3>

<p>A data.frame like <code>votes_df</code> with a new column denoting the number seats per
party and district. Party and district divisors stored in attributes in attributes
(hidden from print, see <code><a href="#topic+get_divisors">get_divisors()</a></code>).
</p>


<h3>See Also</h3>

<p>This function calls <code><a href="#topic+biproporz">biproporz()</a></code> after preparing the input data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Zug 2018
votes_df = unique(zug2018[c("list_id", "entity_id", "list_votes")])
district_seats_df = unique(zug2018[c("entity_id", "election_mandates")])

seats_df = pukelsheim(votes_df,
                      district_seats_df,
                      quorum_any(any_district = 0.05, total = 0.03),
                      winner_take_one = TRUE)

head(seats_df)

# Finland 2019
finland19_result = pukelsheim(finland2019$votes_df,
                             finland2019$district_seats_df,
                             new_seats_col = "mandates",
                             use_list_votes = FALSE)
tail(finland19_result[order(finland19_result$mandates),])

</code></pre>

<hr>
<h2 id='quorum_functions'>Create quorum functions for biproportional apportionment</h2><span id='topic+quorum_functions'></span><span id='topic+quorum_all'></span><span id='topic+quorum_any'></span>

<h3>Description</h3>

<p><code>quorum_any()</code> and <code>quorum_all()</code> are used for the <code>quorum</code> parameter in
<code><a href="#topic+biproporz">biproporz()</a></code> or <code><a href="#topic+pukelsheim">pukelsheim()</a></code> and help describe how quorums should be
applied previous to seat distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quorum_all(any_district, total)

quorum_any(any_district, total)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quorum_functions_+3A_any_district">any_district</code></td>
<td>
<p>Vote threshold a party must reach in <em>at least</em> one
district. Used as share of total votes within a district if less than 1
otherwise as number of votes. Must be greater than 0. Uses
<code><a href="#topic+reached_quorum_any_district">reached_quorum_any_district()</a></code>.</p>
</td></tr>
<tr><td><code id="quorum_functions_+3A_total">total</code></td>
<td>
<p>Vote threshold a party must reach for all votes cast. Used as
share of total votes if less than 1, otherwise as number of votes. Must be
greater than 0. Uses <code><a href="#topic+reached_quorum_total">reached_quorum_total()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There's a difference in how the functions work. With <code>quroum_any</code>,
<em>at least one</em> quorum must be reached. With <code>quorum_all</code> <em>all</em>
(i.e. both) quorums must be reached. If you only use one parameter,
<code>quorum_any()</code> and <code>quorum_all()</code> are identical.
</p>


<h3>Value</h3>

<p>a function which, when called with <code style="white-space: pre;">&#8288;function(votes_matrix)&#8288;</code>, returns
a boolean vector with length equal to the number of lists/parties
(<code>votes_matrix</code> rows). The vector shows whether a party has reached any/all
quorums.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>votes_matrix = matrix(c(502, 55, 80, 10, 104, 55, 0, 1), ncol = 2)
dimnames(votes_matrix) &lt;- list(c("A", "B", "C", "D"), c("Z1", "Z2"))
seats = c(Z1 = 50, Z2 = 20)

# use as parameter in biproporz or pukelsheim (general use case)
biproporz(votes_matrix, seats, quorum = quorum_any(any_district = 0.1, total = 100))

biproporz(votes_matrix, seats, quorum = quorum_all(any_district = 0.1, total = 100))

biproporz(votes_matrix, seats, quorum = quorum_any(any_district = 0.1))

biproporz(votes_matrix, seats, quorum = quorum_any(total = 100))

biproporz(votes_matrix, seats, quorum = quorum_any(total = 0.5))

# the quorum parameter also accepts vectors (e.g. calculated elsewhere)
biproporz(votes_matrix, seats, quorum = c(FALSE, TRUE, TRUE, TRUE))

</code></pre>

<hr>
<h2 id='reached_quorum_any_district'>Check if lists/parties have reached a quorum in at least one district</h2><span id='topic+reached_quorum_any_district'></span>

<h3>Description</h3>

<p>Base implementation, used by <code><a href="#topic+quorum_any">quorum_any()</a></code> and <code><a href="#topic+quorum_all">quorum_all()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reached_quorum_any_district(votes_matrix, quorum_districts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reached_quorum_any_district_+3A_votes_matrix">votes_matrix</code></td>
<td>
<p>votes matrix</p>
</td></tr>
<tr><td><code id="reached_quorum_any_district_+3A_quorum_districts">quorum_districts</code></td>
<td>
<p>Vote threshold a party must reach in <em>at least</em>
one district. Used as quota of total votes within a
district if less than 1 otherwise as number of votes.
Must be greater than 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>boolean vector with length equal to the number of lists/parties
(<code>votes_matrix</code> rows) whether they reached the quorum or not
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reached_quorum_total">reached_quorum_total()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(vm = matrix(c(239, 10, 308, 398, 20, 925), nrow = 3))
reached_quorum_any_district(vm, 25)
</code></pre>

<hr>
<h2 id='reached_quorum_total'>Check if lists/parties have reached the quorum for all votes</h2><span id='topic+reached_quorum_total'></span>

<h3>Description</h3>

<p>Base implementation, used by <code><a href="#topic+quorum_any">quorum_any()</a></code> and <code><a href="#topic+quorum_all">quorum_all()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reached_quorum_total(votes_matrix, quorum_total)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reached_quorum_total_+3A_votes_matrix">votes_matrix</code></td>
<td>
<p>votes matrix</p>
</td></tr>
<tr><td><code id="reached_quorum_total_+3A_quorum_total">quorum_total</code></td>
<td>
<p>Vote threshold a party must reach for all votes cast.
Used as quota of total votes if less than 1, otherwise
as number of votes. Must be greater than 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>boolean vector with length equal to the number of lists/parties
(<code>votes_matrix</code> rows) whether they reached the quorum or not
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reached_quorum_any_district">reached_quorum_any_district()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(vm = matrix(c(239, 10, 308, 398, 20, 925), nrow = 3))
reached_quorum_total(vm, 35)
</code></pre>

<hr>
<h2 id='reached_quorums'>Apply a list of quorum functions to a votes matrix</h2><span id='topic+reached_quorums'></span>

<h3>Description</h3>

<p>Apply a list of quorum functions to a votes matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reached_quorums(votes_matrix, quorum_funcs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reached_quorums_+3A_votes_matrix">votes_matrix</code></td>
<td>
<p>votes matrix</p>
</td></tr>
<tr><td><code id="reached_quorums_+3A_quorum_funcs">quorum_funcs</code></td>
<td>
<p>List of quorum functions. If list, the attribute &quot;type&quot;
must be set which indicates whether <code>ALL</code> or <code>ANY</code>
(i.e. at least one) quorum must be reached.
</p>
<p>This is a low-level implementation for quorum calculations and is
called within <code><a href="#topic+biproporz">biproporz()</a></code>. There's generally no need to call it
directly.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>boolean vector with length equal to the number of lists/parties
(<code>votes_matrix</code> rows) whether they reached the quorum or not
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quorum_all">quorum_all()</a></code>, <code><a href="#topic+quorum_any">quorum_any()</a></code> to create a list of quorum functions.
</p>

<hr>
<h2 id='run_app'>Use biproportional apportionment interactively in a shiny app</h2><span id='topic+run_app'></span>

<h3>Description</h3>

<p>Use biproportional apportionment interactively in a shiny app
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_app(votes_matrix = NULL, district_seats = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_app_+3A_votes_matrix">votes_matrix</code></td>
<td>
<p>optional votes_matrix to load upon start</p>
</td></tr>
<tr><td><code id="run_app_+3A_district_seats">district_seats</code></td>
<td>
<p>optional district_seats to load upon start</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Calling the function starts the shiny app
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
    # You need to have the packages 'shiny' and 'shinyMatrix' installed to run the app
    run_app()

    # It's possible to load a matrix with the app
    run_app(uri2020$votes_matrix, uri2020$seats_vector)
}
</code></pre>

<hr>
<h2 id='upper_apportionment'>Calculate upper apportionment</h2><span id='topic+upper_apportionment'></span>

<h3>Description</h3>

<p>In the upper apportionment, the seats for each party are computed with a highest averages
method. This determines how many of all seats each party deserves due to the total of all
their votes (that is the sum of the votes for all regional lists of that party).
Analogical, the same highest averages method is used to determine how many of all seats
each region deserves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>upper_apportionment(
  votes_matrix,
  district_seats,
  use_list_votes = TRUE,
  method = "round"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="upper_apportionment_+3A_votes_matrix">votes_matrix</code></td>
<td>
<p>Vote count matrix with votes by party in rows and votes by district
in columns</p>
</td></tr>
<tr><td><code id="upper_apportionment_+3A_district_seats">district_seats</code></td>
<td>
<p>Vector defining the number of seats per district. Must be the same
length as <code>ncol(votes_matrix)</code>. Values are name-matched to <code>votes_matrix</code> if both are
named. If the number of seats per district should be assigned according to the number
of votes (not the general use case), a single number for the total number of seats can
be used.</p>
</td></tr>
<tr><td><code id="upper_apportionment_+3A_use_list_votes">use_list_votes</code></td>
<td>
<p>By default (<code>TRUE</code>) it's assumed that each voter in a district has
as many votes as there are seats in a district. Thus, votes are weighted according to
the number of available district seats with <code><a href="#topic+weight_list_votes">weight_list_votes()</a></code>. Set to <code>FALSE</code> if
<code>votes_matrix</code> shows the number of voters (e.g. they can only cast one vote for one
party).</p>
</td></tr>
<tr><td><code id="upper_apportionment_+3A_method">method</code></td>
<td>
<p>Apportion method that defines how seats are assigned, see <code><a href="#topic+proporz">proporz()</a></code>. Default
is the Saintë-Lague/Webster method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with district seats (for <code>votes_matrix</code> columns) and party seats
(for rows).
</p>


<h3>Note</h3>

<p>The results from the upper apportionment are final results for the number of the
seats of one party (and analogically for the number of the seats of one region) within
the whole voting area, the lower apportionment will only determine where (which
regions) the party seats are allocated. Thus, after the upper apportionment is done,
the final strength of a party/region within the parliament is definite.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+biproporz">biproporz()</a></code>, <code><a href="#topic+lower_apportionment">lower_apportionment()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>votes_matrix = matrix(c(123,912,312,45,714,255,815,414,215), nrow = 3)
district_seats = c(7,5,8)

upper_apportionment(votes_matrix, district_seats)

</code></pre>

<hr>
<h2 id='uri2020'>Election Data for the Cantonal Council of Uri (2020)</h2><span id='topic+uri2020'></span>

<h3>Description</h3>

<p>Example election data from the 2020 election for the cantonal council
of Uri (Landrat) in Switzerland. The data has been extracted from the report
&quot;Landratswahlen 2020: Statistische Auswertung&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uri2020
</code></pre>


<h3>Format</h3>

<p>List containing:
</p>

<ul>
<li><p><code>votes_matrix</code> the number of votes for each party and district
(4 rows, 4 columns)
</p>
</li>
<li><p><code>seats_vector</code> with the number of seats per district
(length 4)
</p>
</li></ul>



<h3>Source</h3>

<p><a href="https://www.ur.ch/abstimmungen/termine/9322">https://www.ur.ch/abstimmungen/termine/9322</a>
</p>

<hr>
<h2 id='weight_list_votes'>Create weighted votes matrix</h2><span id='topic+weight_list_votes'></span>

<h3>Description</h3>

<p>Weigh list votes by dividing the votes matrix entries by the number
of seats per district. This method is used in <code><a href="#topic+upper_apportionment">upper_apportionment()</a></code> if
<code>use_list_votes</code> is <code>TRUE</code> (default). The weighted votes are not rounded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weight_list_votes(votes_matrix, seats_district)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weight_list_votes_+3A_votes_matrix">votes_matrix</code></td>
<td>
<p>votes matrix</p>
</td></tr>
<tr><td><code id="weight_list_votes_+3A_seats_district">seats_district</code></td>
<td>
<p>seats per district, vector with same length
as <code>ncol(votes_matrix)</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the weighted <code>votes_matrix</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>weight_list_votes(uri2020$votes_matrix, uri2020$seats_vector)

</code></pre>

<hr>
<h2 id='zug2018'>Election Data for the Cantonal Council of Zug (2018)</h2><span id='topic+zug2018'></span>

<h3>Description</h3>

<p>Example election data from the 2018 election for the cantonal council
of Zug (Kantonsrat) in Switzerland.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zug2018
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 267 rows and 49 columns.
</p>


<h3>Source</h3>

<p>Kanton Zug (01.07.2022, 10:27:58). Kantonsratswahl 2018 (CSV).
<a href="https://wab.zug.ch/elections/kantonsratswahl-2018/data-csv">https://wab.zug.ch/elections/kantonsratswahl-2018/data-csv</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
