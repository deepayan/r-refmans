<!DOCTYPE html><html><head><title>Help for package waywiser</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {waywiser}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#waywiser-package'><p>waywiser: Ergonomic Methods for Assessing Spatial Models</p></a></li>
<li><a href='#guerry'><p>Guerry &quot;Moral Statistics&quot; (1830s)</p></a></li>
<li><a href='#ny_trees'><p>Number of trees and aboveground biomass for Forest Inventory and Analysis plots in New York State</p></a></li>
<li><a href='#predict.ww_area_of_applicability'><p>Predict from a <code>ww_area_of_applicability</code></p></a></li>
<li><a href='#print.ww_area_of_applicability'><p>Print number of predictors and area-of-applicability threshold</p></a></li>
<li><a href='#worldclim_simulation'><p>Simulated data based on WorldClim Bioclimatic variables</p></a></li>
<li><a href='#ww_agreement_coefficient'><p>Agreement coefficients and related methods</p></a></li>
<li><a href='#ww_area_of_applicability'><p>Find the area of applicability</p></a></li>
<li><a href='#ww_build_neighbors'><p>Make 'nb' objects from sf objects</p></a></li>
<li><a href='#ww_build_weights'><p>Build &quot;listw&quot; objects of spatial weights</p></a></li>
<li><a href='#ww_global_geary_c'><p>Global Geary's C statistic</p></a></li>
<li><a href='#ww_global_moran_i'><p>Global Moran's I statistic</p></a></li>
<li><a href='#ww_local_geary_c'><p>Local Geary's C statistic</p></a></li>
<li><a href='#ww_local_getis_ord_g'><p>Local Getis-Ord G and G* statistic</p></a></li>
<li><a href='#ww_local_moran_i'><p>Local Moran's I statistic</p></a></li>
<li><a href='#ww_make_point_neighbors'><p>Make 'nb' objects from point geometries</p></a></li>
<li><a href='#ww_make_polygon_neighbors'><p>Make 'nb' objects from polygon geometries</p></a></li>
<li><a href='#ww_multi_scale'><p>Evaluate metrics at multiple scales of aggregation</p></a></li>
<li><a href='#ww_willmott_d'><p>Willmott's d and related values</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Ergonomic Methods for Assessing Spatial Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Assessing predictive models of spatial data can be
    challenging, both because these models are typically built for
    extrapolating outside the original region represented by training data
    and due to potential spatially structured errors, with "hot spots" of
    higher than expected error clustered geographically due to spatial
    structure in the underlying data. Methods are provided for assessing
    models fit to spatial data, including approaches for measuring the
    spatial structure of model errors, assessing model predictions at
    multiple spatial scales, and evaluating where predictions can be made
    safely. Methods are particularly useful for models fit using the
    'tidymodels' framework. Methods include Moran's I ('Moran' (1950)
    &lt;<a href="https://doi.org/10.2307%2F2332142">doi:10.2307/2332142</a>&gt;), Geary's C ('Geary' (1954)
    &lt;<a href="https://doi.org/10.2307%2F2986645">doi:10.2307/2986645</a>&gt;), Getis-Ord's G ('Ord' and 'Getis' (1995)
    &lt;<a href="https://doi.org/10.1111%2Fj.1538-4632.1995.tb00912.x">doi:10.1111/j.1538-4632.1995.tb00912.x</a>&gt;), agreement coefficients from
    'Ji' and Gallo (2006) (&lt;<a href="https://doi.org/10.14358%2FPERS.72.7.823">doi:10.14358/PERS.72.7.823</a>&gt;), agreement
    metrics from 'Willmott' (1981) (&lt;<a href="https://doi.org/10.1080%2F02723646.1981.10642213">doi:10.1080/02723646.1981.10642213</a>&gt;)
    and 'Willmott' 'et' 'al'. (2012) (&lt;<a href="https://doi.org/10.1002%2Fjoc.2419">doi:10.1002/joc.2419</a>&gt;), an
    implementation of the area of applicability methodology from 'Meyer'
    and 'Pebesma' (2021) (&lt;<a href="https://doi.org/10.1111%2F2041-210X.13650">doi:10.1111/2041-210X.13650</a>&gt;), and an
    implementation of multi-scale assessment as described in 'Riemann'
    'et' 'al'. (2010) (&lt;<a href="https://doi.org/10.1016%2Fj.rse.2010.05.010">doi:10.1016/j.rse.2010.05.010</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ropensci/waywiser">https://github.com/ropensci/waywiser</a>,
<a href="https://docs.ropensci.org/waywiser/">https://docs.ropensci.org/waywiser/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ropensci/waywiser/issues">https://github.com/ropensci/waywiser/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr (&ge; 1.1.0), fields, FNN, glue, hardhat, Matrix, purrr,
rlang (&ge; 1.1.0), sf (&ge; 1.0-0), spdep (&ge; 1.1-9), stats,
tibble, tidyselect, vctrs, yardstick (&ge; 1.2.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>applicable, caret, CAST, covr, exactextractr, ggplot2, knitr,
modeldata, recipes, rmarkdown, rsample, spatialsample, terra,
testthat (&ge; 3.0.0), tidymodels, tidyr, tigris, units, vip,
whisker, withr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>kableExtra</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-27 18:47:42 UTC; mikemahoney218</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Mahoney <a href="https://orcid.org/0000-0003-2402-304X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Lucas Johnson <a href="https://orcid.org/0000-0002-7953-0260"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Virgilio GÃ³mez-Rubio [rev] (Virgilio reviewed the package (v.
    0.2.0.9000) for rOpenSci, see
    &lt;https://github.com/ropensci/software-review/issues/571&gt;),
  Jakub Nowosad [rev] (Jakub reviewed the package (v. 0.2.0.9000) for
    rOpenSci, see
    &lt;https://github.com/ropensci/software-review/issues/571&gt;),
  Posit Software, PBC [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Mahoney &lt;mike.mahoney.218@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-27 19:10:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='waywiser-package'>waywiser: Ergonomic Methods for Assessing Spatial Models</h2><span id='topic+waywiser'></span><span id='topic+waywiser-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Assessing predictive models of spatial data can be challenging, both because these models are typically built for extrapolating outside the original region represented by training data and due to potential spatially structured errors, with &quot;hot spots&quot; of higher than expected error clustered geographically due to spatial structure in the underlying data. Methods are provided for assessing models fit to spatial data, including approaches for measuring the spatial structure of model errors, assessing model predictions at multiple spatial scales, and evaluating where predictions can be made safely. Methods are particularly useful for models fit using the 'tidymodels' framework. Methods include Moran's I ('Moran' (1950) <a href="https://doi.org/10.2307/2332142">doi:10.2307/2332142</a>), Geary's C ('Geary' (1954) <a href="https://doi.org/10.2307/2986645">doi:10.2307/2986645</a>), Getis-Ord's G ('Ord' and 'Getis' (1995) <a href="https://doi.org/10.1111/j.1538-4632.1995.tb00912.x">doi:10.1111/j.1538-4632.1995.tb00912.x</a>), agreement coefficients from 'Ji' and Gallo (2006) (<a href="https://doi.org/%2010.14358/PERS.72.7.823">doi: 10.14358/PERS.72.7.823</a>), agreement metrics from 'Willmott' (1981) (<a href="https://doi.org/%2010.1080/02723646.1981.10642213">doi: 10.1080/02723646.1981.10642213</a>) and 'Willmott' 'et' 'al'. (2012) (<a href="https://doi.org/%2010.1002/joc.2419">doi: 10.1002/joc.2419</a>), an implementation of the area of applicability methodology from 'Meyer' and 'Pebesma' (2021) (<a href="https://doi.org/10.1111/2041-210X.13650">doi:10.1111/2041-210X.13650</a>), and an implementation of multi-scale assessment as described in 'Riemann' 'et' 'al'. (2010) (<a href="https://doi.org/10.1016/j.rse.2010.05.010">doi:10.1016/j.rse.2010.05.010</a>).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Michael Mahoney <a href="mailto:mike.mahoney.218@gmail.com">mike.mahoney.218@gmail.com</a> (<a href="https://orcid.org/0000-0003-2402-304X">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Lucas Johnson <a href="mailto:lucas.k.johnson03@gmail.com">lucas.k.johnson03@gmail.com</a> (<a href="https://orcid.org/0000-0002-7953-0260">ORCID</a>) [contributor]
</p>
</li>
<li><p> Virgilio GÃ³mez-Rubio (Virgilio reviewed the package (v. 0.2.0.9000) for rOpenSci, see &lt;https://github.com/ropensci/software-review/issues/571&gt;) [reviewer]
</p>
</li>
<li><p> Jakub Nowosad (Jakub reviewed the package (v. 0.2.0.9000) for rOpenSci, see &lt;https://github.com/ropensci/software-review/issues/571&gt;) [reviewer]
</p>
</li>
<li><p> Posit Software, PBC [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/ropensci/waywiser">https://github.com/ropensci/waywiser</a>
</p>
</li>
<li> <p><a href="https://docs.ropensci.org/waywiser/">https://docs.ropensci.org/waywiser/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/ropensci/waywiser/issues">https://github.com/ropensci/waywiser/issues</a>
</p>
</li></ul>


<hr>
<h2 id='guerry'>Guerry &quot;Moral Statistics&quot; (1830s)</h2><span id='topic+guerry'></span>

<h3>Description</h3>

<p>This data and description are taken from the geodaData R package.
Classic social science foundational study by Andre-Michel Guerry on crime, suicide, literacy and other âmoral statisticsâ in 1830s France. Data from the R package Guerry (Michael Friendly and Stephane Dray).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guerry
</code></pre>


<h3>Format</h3>

<p>An sf data frame with 85 rows, 23 variables, and a geometry column:
</p>

<dl>
<dt>	dept	</dt><dd><p>	Department ID: Standard numbers for the departments 	</p>
</dd>
<dt>	Region	</dt><dd><p>	Region of France ('N'='North', 'S'='South', 'E'='East', 'W'='West', 'C'='Central').  Corsica is coded as NA.	</p>
</dd>
<dt>	Dprtmnt	</dt><dd><p>	Department name: Departments are named according to usage in 1830, but without accents. A factor with levels <em>Ain</em> <em>Aisne</em> <em>Allier</em> ... <em>Vosges Yonne</em> 	</p>
</dd>
<dt>	Crm_prs	</dt><dd><p>	Population per Crime against persons.	</p>
</dd>
<dt>	Crm_prp	</dt><dd><p>	Population per Crime against property.	</p>
</dd>
<dt>	Litercy	</dt><dd><p>	Percent of military conscripts who can read and write.	</p>
</dd>
<dt>	Donatns	</dt><dd><p>	Donations to the poor.	</p>
</dd>
<dt>	Infants	</dt><dd><p>	Population per illegitimate birth.	</p>
</dd>
<dt>	Suicids	</dt><dd><p>	Population per suicide.	</p>
</dd>
<dt>	Maincty	</dt><dd><p>	Size of principal city ('1:Sm', '2:Med', '3:Lg'), used as a surrogate for population density. Large refers to the top 10, small to the bottom 10; all the rest are classed Medium.	</p>
</dd>
<dt>	Wealth	</dt><dd><p>	Per capita tax on personal property. A ranked index based on taxes on personal and movable property per inhabitant.	</p>
</dd>
<dt>	Commerc	</dt><dd><p>	Commerce and Industry, measured by the rank of the number of patents / population.	</p>
</dd>
<dt>	Clergy	</dt><dd><p>	Distribution of clergy, measured by the rank of the number of Catholic priests in active service population.	</p>
</dd>
<dt>	Crim_prn	</dt><dd><p>	Crimes against parents, measured by the rank of the ratio of crimes against parents to all crimes â Average for the years 1825-1830.	</p>
</dd>
<dt>	Infntcd	</dt><dd><p>	Infanticides per capita. A ranked ratio of number of infanticides to population â Average for the years 1825-1830.	</p>
</dd>
<dt>	Dntn_cl	</dt><dd><p>	Donations to the clergy. A ranked ratio of the number of bequests and donations inter vivios to population â Average for the years 1815-1824.	</p>
</dd>
<dt>	Lottery	</dt><dd><p>	Per capita wager on Royal Lottery. Ranked ratio of the proceeds bet on the royal lottery to population â Average for the years 1822-1826.	</p>
</dd>
<dt>	Desertn	</dt><dd><p>	Military desertion, ratio of number of young soldiers accused of desertion to the force of the military contingent, minus the deficit produced by the insufficiency of available billets â Average of the years 1825-1827.	</p>
</dd>
<dt>	Instrct	</dt><dd><p>	Instruction. Ranks recorded from Guerry's map of Instruction. Note: this is inversely related to Literacy  	</p>
</dd>
<dt>	Prsttts	</dt><dd><p>	Number of prostitutes registered in Paris from 1816 to 1834, classified by the department of their birth 	</p>
</dd>
<dt>	Distanc	</dt><dd><p>	Distance to Paris (km). Distance of each department centroid to the centroid of the Seine (Paris)	</p>
</dd>
<dt>	Area	</dt><dd><p>	 Area (1000 km^2).	</p>
</dd>
<dt>	Pop1831	</dt><dd><p>	Population in 1831, in 1000s	</p>
</dd>
</dl>



<h3>Details</h3>

<p>Sf object, units in m. EPSG 27572: NTF (Paris) / Lambert zone II.
</p>


<h3>Source</h3>


<ul>
<li><p>Angeville, A. (1836). Essai sur la Statistique de la Population franÃ§aise Paris: F. Doufour.
</p>
</li>
<li><p>Guerry, A.-M. (1833). Essai sur la statistique morale de la France Paris: Crochard. English translation: Hugh P. Whitt and Victor W. Reinking, Lewiston, N.Y. : Edwin Mellen Press, 2002.
</p>
</li>
<li><p>Parent-Duchatelet, A. (1836). De la prostitution dans la ville de Paris, 3rd ed, 1857, p. 32, 36
</p>
</li></ul>

<p><a href="https://geodacenter.github.io/data-and-lab/Guerry/">https://geodacenter.github.io/data-and-lab/Guerry/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("sf", quietly = TRUE)) {
  library(sf)
  data(guerry)

  plot(guerry["Donatns"])
}
</code></pre>

<hr>
<h2 id='ny_trees'>Number of trees and aboveground biomass for Forest Inventory and Analysis plots in New York State</h2><span id='topic+ny_trees'></span>

<h3>Description</h3>

<p>The original data is derived from the Forest Inventory and Analysis program,
implemented by the US Department of Agriculture's Forest Service.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ny_trees
</code></pre>


<h3>Format</h3>

<p>An sf object using EPSG 5070: NAD83 / Conus Albers (in meters), with 5,303 rows and 5 columns:
</p>

<dl>
<dt>yr</dt><dd><p>The year measurements were taken.</p>
</dd>
<dt>plot</dt><dd><p>A unique identifier signifying the plot measurements were taken at.</p>
</dd>
<dt>n_trees</dt><dd><p>The number of trees present on a plot.</p>
</dd>
<dt>agb</dt><dd><p>The total aboveground biomass at the plot location, in pounds.</p>
</dd>
<dt>geometry</dt><dd><p>The centroid of the plot location.</p>
</dd>
</dl>


<hr>
<h2 id='predict.ww_area_of_applicability'>Predict from a <code>ww_area_of_applicability</code></h2><span id='topic+predict.ww_area_of_applicability'></span>

<h3>Description</h3>

<p>Predict from a <code>ww_area_of_applicability</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ww_area_of_applicability'
predict(object, new_data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.ww_area_of_applicability_+3A_object">object</code></td>
<td>
<p>A <code>ww_area_of_applicability</code> object.</p>
</td></tr>
<tr><td><code id="predict.ww_area_of_applicability_+3A_new_data">new_data</code></td>
<td>
<p>A data frame or matrix of new samples.</p>
</td></tr>
<tr><td><code id="predict.ww_area_of_applicability_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes the distance indices of the new data and
whether or not they are &quot;inside&quot; the area of applicability.
</p>


<h3>Value</h3>

<p>A tibble of predictions, with two columns: <code>di</code>, numeric, contains the
&quot;dissimilarity index&quot; of each point in <code>new_data</code>, while <code>aoa</code>, logical,
contains whether a row is inside (<code>TRUE</code>) or outside (<code>FALSE</code>) the area of
applicability.
</p>
<p>Note that this function is often called using
<code><a href="terra.html#topic+predict">terra::predict()</a></code>, in which case <code>aoa</code> will be converted to numeric
implicitly; <code>1</code> values correspond to cells &quot;inside&quot; the area of applicability
and <code>0</code> corresponds to cells &quot;outside&quot; the AOA.
</p>
<p>The number of rows in the tibble is guaranteed
to be the same as the number of rows in <code>new_data</code>. Rows with <code>NA</code> predictor
values will have <code>NA</code> <code>di</code> and <code>aoa</code> values.
</p>


<h3>See Also</h3>

<p>Other area of applicability functions: 
<code><a href="#topic+ww_area_of_applicability">ww_area_of_applicability</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(vip)
train &lt;- gen_friedman(1000, seed = 101) # ?vip::gen_friedman
test &lt;- train[701:1000, ]
train &lt;- train[1:700, ]
pp &lt;- stats::ppr(y ~ ., data = train, nterms = 11)
metric_name &lt;- ifelse(
  packageVersion("vip") &gt; package_version("0.3.2"),
  "rsq",
  "rsquared"
)

importance &lt;- vip::vi_permute(
  pp,
  target = "y",
  metric = metric_name,
  pred_wrapper = predict,
  train = train
)

aoa &lt;- ww_area_of_applicability(y ~ ., train, test, importance = importance)
predict(aoa, test)

</code></pre>

<hr>
<h2 id='print.ww_area_of_applicability'>Print number of predictors and area-of-applicability threshold</h2><span id='topic+print.ww_area_of_applicability'></span>

<h3>Description</h3>

<p>Print number of predictors and area-of-applicability threshold
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ww_area_of_applicability'
print(x, digits = getOption("digits"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.ww_area_of_applicability_+3A_x">x</code></td>
<td>
<p>A <code>ww_area_of_applicability</code> object.</p>
</td></tr>
<tr><td><code id="print.ww_area_of_applicability_+3A_digits">digits</code></td>
<td>
<p>The number of digits to print, used when rounding the AOA threshold.</p>
</td></tr>
<tr><td><code id="print.ww_area_of_applicability_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
library(vip)
trn &lt;- gen_friedman(500, seed = 101) # ?vip::gen_friedman
pp &lt;- ppr(y ~ ., data = trn, nterms = 11)
metric_name &lt;- ifelse(
  packageVersion("vip") &gt; package_version("0.3.2"),
  "rsq",
  "rsquared"
)

importance &lt;- vip::vi_permute(
  pp,
  target = "y",
  metric = metric_name,
  pred_wrapper = predict,
  train = trn
)


ww_area_of_applicability(trn[2:11], importance = importance)

</code></pre>

<hr>
<h2 id='worldclim_simulation'>Simulated data based on WorldClim Bioclimatic variables</h2><span id='topic+worldclim_simulation'></span>

<h3>Description</h3>

<p>This data is adapted from the CAST vignette
<code>vignette("cast02-AOA-tutorial", package = "CAST")</code>.
The original data is derived from the Worldclim global climate variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>worldclim_simulation
</code></pre>


<h3>Format</h3>

<p>An sf object with 10,000 rows and 6 columns:
</p>

<dl>
<dt>bio2</dt><dd><p>Mean Diurnal Range (Mean of monthly (max temp - min temp))</p>
</dd>
<dt>bio10</dt><dd><p>Mean Temperature of Warmest Quarter</p>
</dd>
<dt>bio13</dt><dd><p>Precipitation of Wettest Month</p>
</dd>
<dt>bio19</dt><dd><p>Precipitation of Coldest Quarter</p>
</dd>
<dt>geometry</dt><dd><p>The location of the sampled point.</p>
</dd>
<dt>response</dt><dd><p>A virtual species distribution, generated using the <code>generateSpFromPCA()</code> function from the <code>virtualspecies</code> package.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.worldclim.org">https://www.worldclim.org</a>
</p>

<hr>
<h2 id='ww_agreement_coefficient'>Agreement coefficients and related methods</h2><span id='topic+ww_agreement_coefficient'></span><span id='topic+ww_agreement_coefficient.data.frame'></span><span id='topic+ww_agreement_coefficient_vec'></span><span id='topic+ww_systematic_agreement_coefficient'></span><span id='topic+ww_systematic_agreement_coefficient.data.frame'></span><span id='topic+ww_systematic_agreement_coefficient_vec'></span><span id='topic+ww_unsystematic_agreement_coefficient'></span><span id='topic+ww_unsystematic_agreement_coefficient.data.frame'></span><span id='topic+ww_unsystematic_agreement_coefficient_vec'></span><span id='topic+ww_unsystematic_mpd'></span><span id='topic+ww_unsystematic_mpd.data.frame'></span><span id='topic+ww_unsystematic_mpd_vec'></span><span id='topic+ww_systematic_mpd'></span><span id='topic+ww_systematic_mpd.data.frame'></span><span id='topic+ww_systematic_mpd_vec'></span><span id='topic+ww_unsystematic_rmpd'></span><span id='topic+ww_unsystematic_rmpd.data.frame'></span><span id='topic+ww_unsystematic_rmpd_vec'></span><span id='topic+ww_systematic_rmpd'></span><span id='topic+ww_systematic_rmpd.data.frame'></span><span id='topic+ww_systematic_rmpd_vec'></span>

<h3>Description</h3>

<p>These functions calculate the agreement coefficient and mean product
difference (MPD), as well as their systematic and unsystematic components,
from Ji and Gallo (2006). Agreement coefficients provides a useful
measurement of agreement between two data sets which is bounded, symmetrical,
and can be decomposed into systematic and unsystematic components;
however, it assumes a linear relationship between the two data sets and
treats both &quot;truth&quot; and &quot;estimate&quot; as being of equal quality, and as such may
not be a useful metric in all scenarios.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ww_agreement_coefficient(data, ...)

## S3 method for class 'data.frame'
ww_agreement_coefficient(data, truth, estimate, na_rm = TRUE, ...)

ww_agreement_coefficient_vec(truth, estimate, na_rm = TRUE, ...)

ww_systematic_agreement_coefficient(data, ...)

## S3 method for class 'data.frame'
ww_systematic_agreement_coefficient(data, truth, estimate, na_rm = TRUE, ...)

ww_systematic_agreement_coefficient_vec(truth, estimate, na_rm = TRUE, ...)

ww_unsystematic_agreement_coefficient(data, ...)

## S3 method for class 'data.frame'
ww_unsystematic_agreement_coefficient(data, truth, estimate, na_rm = TRUE, ...)

ww_unsystematic_agreement_coefficient_vec(truth, estimate, na_rm = TRUE, ...)

ww_unsystematic_mpd(data, ...)

## S3 method for class 'data.frame'
ww_unsystematic_mpd(data, truth, estimate, na_rm = TRUE, ...)

ww_unsystematic_mpd_vec(truth, estimate, na_rm = TRUE, ...)

ww_systematic_mpd(data, ...)

## S3 method for class 'data.frame'
ww_systematic_mpd(data, truth, estimate, na_rm = TRUE, ...)

ww_systematic_mpd_vec(truth, estimate, na_rm = TRUE, ...)

ww_unsystematic_rmpd(data, ...)

## S3 method for class 'data.frame'
ww_unsystematic_rmpd(data, truth, estimate, na_rm = TRUE, ...)

ww_unsystematic_rmpd_vec(truth, estimate, na_rm = TRUE, ...)

ww_systematic_rmpd(data, ...)

## S3 method for class 'data.frame'
ww_systematic_rmpd(data, truth, estimate, na_rm = TRUE, ...)

ww_systematic_rmpd_vec(truth, estimate, na_rm = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ww_agreement_coefficient_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> containing the columns specified by the <code>truth</code>
and <code>estimate</code> arguments.</p>
</td></tr>
<tr><td><code id="ww_agreement_coefficient_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
<tr><td><code id="ww_agreement_coefficient_+3A_truth">truth</code></td>
<td>
<p>The column identifier for the true results
(that is <code>numeric</code>). This should be an unquoted column name although
this argument is passed by expression and supports
<a href="rlang.html#topic+topic-inject">quasiquotation</a> (you can unquote column
names). For <code style="white-space: pre;">&#8288;_vec()&#8288;</code> functions, a <code>numeric</code> vector.</p>
</td></tr>
<tr><td><code id="ww_agreement_coefficient_+3A_estimate">estimate</code></td>
<td>
<p>The column identifier for the predicted
results (that is also <code>numeric</code>). As with <code>truth</code> this can be
specified different ways but the primary method is to use an
unquoted variable name. For <code style="white-space: pre;">&#8288;_vec()&#8288;</code> functions, a <code>numeric</code> vector.</p>
</td></tr>
<tr><td><code id="ww_agreement_coefficient_+3A_na_rm">na_rm</code></td>
<td>
<p>A <code>logical</code> value indicating whether <code>NA</code>
values should be stripped before the computation proceeds.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Agreement coefficient values range from 0 to 1, with 1 indicating perfect
agreement. <code>truth</code> and <code>estimate</code> must be the same length. This function is
not explicitly spatial and as such can be applied to data with any number of
dimensions and any coordinate reference system.
</p>


<h3>Value</h3>

<p>A tibble with columns .metric, .estimator, and .estimate and 1 row of values.
For grouped data frames, the number of rows returned will be the same as the number of groups.
For <code style="white-space: pre;">&#8288;_vec()&#8288;</code> functions, a single value (or NA).
</p>


<h3>References</h3>

<p>Ji, L. and Gallo, K. 2006. &quot;An Agreement Coefficient for Image Comparison.&quot;
Photogrammetric Engineering &amp; Remote Sensing 72(7), pp 823â833,
doi: 10.14358/PERS.72.7.823.
</p>


<h3>See Also</h3>

<p>Other agreement metrics: 
<code><a href="#topic+ww_willmott_d">ww_willmott_d</a>()</code>
</p>
<p>Other yardstick metrics: 
<code><a href="#topic+ww_global_geary_c">ww_global_geary_c</a>()</code>,
<code><a href="#topic+ww_global_moran_i">ww_global_moran_i</a>()</code>,
<code><a href="#topic+ww_local_geary_c">ww_local_geary_c</a>()</code>,
<code><a href="#topic+ww_local_getis_ord_g">ww_local_getis_ord_g</a>()</code>,
<code><a href="#topic+ww_local_moran_i">ww_local_moran_i</a>()</code>,
<code><a href="#topic+ww_willmott_d">ww_willmott_d</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculated values match Ji and Gallo 2006:
x &lt;- c(6, 8, 9, 10, 11, 14)
y &lt;- c(2, 3, 5, 5, 6, 8)

ww_agreement_coefficient_vec(x, y)
ww_systematic_agreement_coefficient_vec(x, y)
ww_unsystematic_agreement_coefficient_vec(x, y)
ww_systematic_mpd_vec(x, y)
ww_unsystematic_mpd_vec(x, y)
ww_systematic_rmpd_vec(x, y)
ww_unsystematic_rmpd_vec(x, y)

example_df &lt;- data.frame(x = x, y = y)
ww_agreement_coefficient(example_df, x, y)
ww_systematic_agreement_coefficient(example_df, x, y)
ww_unsystematic_agreement_coefficient(example_df, x, y)
ww_systematic_mpd(example_df, x, y)
ww_unsystematic_mpd(example_df, x, y)
ww_systematic_rmpd(example_df, x, y)
ww_unsystematic_rmpd(example_df, x, y)

</code></pre>

<hr>
<h2 id='ww_area_of_applicability'>Find the area of applicability</h2><span id='topic+ww_area_of_applicability'></span><span id='topic+ww_area_of_applicability.data.frame'></span><span id='topic+ww_area_of_applicability.matrix'></span><span id='topic+ww_area_of_applicability.formula'></span><span id='topic+ww_area_of_applicability.recipe'></span><span id='topic+ww_area_of_applicability.rset'></span>

<h3>Description</h3>

<p>This function calculates the &quot;area of applicability&quot; of a model, as
introduced by Meyer and Pebesma (2021). While the initial paper introducing
this method focused on spatial models, there is nothing inherently spatial
about the method; it can be used with any type of data (and, because it does
not care about the spatial arrangement of your data, can be used with 2D or
3D spatial data, and with geographic or projected CRS).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ww_area_of_applicability(x, ...)

## S3 method for class 'data.frame'
ww_area_of_applicability(x, testing = NULL, importance, ..., na_rm = FALSE)

## S3 method for class 'matrix'
ww_area_of_applicability(x, testing = NULL, importance, ..., na_rm = FALSE)

## S3 method for class 'formula'
ww_area_of_applicability(
  x,
  data,
  testing = NULL,
  importance,
  ...,
  na_rm = FALSE
)

## S3 method for class 'recipe'
ww_area_of_applicability(
  x,
  data,
  testing = NULL,
  importance,
  ...,
  na_rm = FALSE
)

## S3 method for class 'rset'
ww_area_of_applicability(x, y = NULL, importance, ..., na_rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ww_area_of_applicability_+3A_x">x</code></td>
<td>
<p>Either a data frame, matrix, formula
(specifying predictor terms on the right-hand side), recipe
(from <code><a href="recipes.html#topic+recipe">recipes::recipe()</a></code>, or <code>rset</code> object, produced by resampling functions
from rsample or spatialsample.
</p>
<p>If <code>x</code> is a recipe, it should be the same one used to pre-process the data
used in your model. If the recipe used to build the area of applicability
doesn't match the one used to build the model, the returned area of
applicability won't be correct.</p>
</td></tr>
<tr><td><code id="ww_area_of_applicability_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
<tr><td><code id="ww_area_of_applicability_+3A_testing">testing</code></td>
<td>
<p>A data frame or matrix containing the data used to
validate your model. This should be the same data as used to calculate all
model accuracy metrics.
</p>
<p>If this argument is <code>NULL</code>, then this function will use the training data
(from <code>x</code> or <code>data</code>) to calculate within-sample distances.
This may result in the area of applicability threshold being set too high,
with the result that too many points are classed as &quot;inside&quot; the area of
applicability.</p>
</td></tr>
<tr><td><code id="ww_area_of_applicability_+3A_importance">importance</code></td>
<td>
<p>Either:
</p>

<ul>
<li><p> A data.frame with two columns: <code>term</code>, containing the names of each
variable in the training and testing data, and <code>estimate</code>, containing
the (raw or scaled) feature importance for each variable.
</p>
</li>
<li><p> An object of class <code>vi</code> with at least two columns, <code>Variable</code> and
<code>Importance</code>.
</p>
</li></ul>

<p>All variables in the training data (<code>x</code> or <code>data</code>, depending on the context)
must have a matching importance estimate, and all terms with importance
estimates must be in the training data.</p>
</td></tr>
<tr><td><code id="ww_area_of_applicability_+3A_na_rm">na_rm</code></td>
<td>
<p>A logical of length 1, indicating whether observations (in both
training and testing) with <code>NA</code> values in predictors should be removed. Only
predictor variables are considered, and this value has no impact on
predictions (where <code>NA</code> values produce <code>NA</code> predictions). If <code>na_rm = FALSE</code>
and <code>NA</code> values are found, this function returns an error.</p>
</td></tr>
<tr><td><code id="ww_area_of_applicability_+3A_data">data</code></td>
<td>
<p>The data frame representing your &quot;training&quot; data, when using the
formula or recipe methods.</p>
</td></tr>
<tr><td><code id="ww_area_of_applicability_+3A_y">y</code></td>
<td>
<p>Optional: a recipe (from <code><a href="recipes.html#topic+recipe">recipes::recipe()</a></code>) or formula.
</p>
<p>If <code>y</code> is a recipe, it should be the same one used to pre-process the data
used in your model. If the recipe used to build the area of applicability
doesn't match the one used to build the model, the returned area of
applicability won't be correct.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Predictions made on points &quot;inside&quot; the area of applicability should be as
accurate as predictions made on the data provided to <code>testing</code>.
That means that generally <code>testing</code> should be your final hold-out
set so that predictions on points inside the area of applicability are
accurately described by your reported model metrics.
When passing an <code>rset</code> object to <code>x</code>, predictions made on points &quot;inside&quot; the
area of applicability instead should be as accurate as predictions made on
the assessment sets during cross-validation.
</p>
<p>This method assumes your model was fit using dummy variables in the place of
any non-numeric predictor, and that you have one importance score per
dummy variable. Having non-numeric predictors will cause this function to
fail.
</p>


<h3>Value</h3>

<p>A <code>ww_area_of_applicability</code> object, which can be used with <code><a href="stats.html#topic+predict">predict()</a></code> to
calculate the distance of new data to the original training data, and
determine if new data is within a model's area of applicability.
</p>


<h3>Differences from CAST</h3>

<p>This implementation differs from
Meyer and Pebesma (2021) (and therefore from CAST) when using cross-validated
data in order to minimize data leakage. Namely, in order to calculate
the dissimilarity index <code class="reqn">DI_{k}</code>, CAST:
</p>

<ol>
<li><p> Rescales all data used for cross validation at once, lumping assessment
folds in with analysis data.
</p>
</li>
<li><p> Calculates a single <code class="reqn">\bar{d}</code> as the mean distance between all points
in the rescaled data set, including between points in the same assessment
fold.
</p>
</li>
<li><p> For each point <code class="reqn">k</code> that's used in an assessment fold, calculates
<code class="reqn">d_{k}</code> as the minimum distance between <code class="reqn">k</code> and any point in its
corresponding analysis fold.
</p>
</li>
<li><p> Calculates <code class="reqn">DI_{k}</code> by dividing <code class="reqn">d_{k}</code> by <code class="reqn">\bar{d}</code> (which
was partially calculated as the distance between <code class="reqn">k</code> and the rest of
the rescaled data).
</p>
</li></ol>

<p>Because assessment data is used to calculate constants for rescaling analysis
data and <code class="reqn">\bar{d}</code>, the assessment data may appear too &quot;similar&quot; to
the analysis data when calculating <code class="reqn">DI_{k}</code>. As such, waywiser treats
each fold in an <code>rset</code> independently:
</p>

<ol>
<li><p> Each analysis set is rescaled independently.
</p>
</li>
<li><p> Separate <code class="reqn">\bar{d}</code> are calculated for each fold, as the mean distance
between all points in the analysis set for that fold.
</p>
</li>
<li><p> Identically to CAST, <code class="reqn">d_{k}</code> is the minimum distance between a point
<code class="reqn">k</code> in the assessment fold and any point in the
corresponding analysis fold.
</p>
</li>
<li> <p><code class="reqn">DI_{k}</code> is then found by dividing <code class="reqn">d_{k}</code> by <code class="reqn">\bar{d}</code>,
which was calculated independently from <code class="reqn">k</code>.
</p>
</li></ol>

<p>Predictions are made using the full training data set, rescaled once (in
the same way as CAST), and the mean <code class="reqn">\bar{d}</code> across folds, under the
assumption that the &quot;final&quot; model in use will be retrained using the entire
data set.
</p>
<p>In practice, this means waywiser produces very slightly higher <code class="reqn">\bar{d}</code>
values than CAST and a slightly higher area of applicability threshold than
CAST when using <code>rset</code> objects.
</p>


<h3>References</h3>

<p>H. Meyer and E. Pebesma. 2021. &quot;Predicting into unknown space? Estimating
the area of applicability of spatial prediction models,&quot; Methods in Ecology
and Evolution 12(9), pp 1620 - 1633, doi: 10.1111/2041-210X.13650.
</p>


<h3>See Also</h3>

<p>Other area of applicability functions: 
<code><a href="#topic+predict.ww_area_of_applicability">predict.ww_area_of_applicability</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
train &lt;- vip::gen_friedman(1000, seed = 101) # ?vip::gen_friedman
test &lt;- train[701:1000, ]
train &lt;- train[1:700, ]
pp &lt;- stats::ppr(y ~ ., data = train, nterms = 11)
metric_name &lt;- ifelse(
  packageVersion("vip") &gt; package_version("0.3.2"),
  "rsq",
  "rsquared"
)

importance &lt;- vip::vi_permute(
  pp,
  target = "y",
  metric = metric_name,
  pred_wrapper = predict,
  train = train
)

aoa &lt;- ww_area_of_applicability(y ~ ., train, test, importance = importance)
predict(aoa, test)

# Equivalent methods for calculating AOA:
ww_area_of_applicability(train[2:11], test[2:11], importance)
ww_area_of_applicability(
  as.matrix(train[2:11]),
  as.matrix(test[2:11]),
  importance
)

</code></pre>

<hr>
<h2 id='ww_build_neighbors'>Make 'nb' objects from sf objects</h2><span id='topic+ww_build_neighbors'></span>

<h3>Description</h3>

<p>These functions can be used for geographic or projected coordinate reference
systems and expect 2D data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ww_build_neighbors(data, nb = NULL, ..., call = rlang::caller_env())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ww_build_neighbors_+3A_data">data</code></td>
<td>
<p>An sf object (of class &quot;sf&quot; or &quot;sfc&quot;).</p>
</td></tr>
<tr><td><code id="ww_build_neighbors_+3A_nb">nb</code></td>
<td>
<p>An object of class &quot;nb&quot; (in which case it will be returned
unchanged), or a function to create an object of class &quot;nb&quot; from <code>data</code> and
<code>...</code>, or <code>NULL</code>. See details.</p>
</td></tr>
<tr><td><code id="ww_build_neighbors_+3A_...">...</code></td>
<td>
<p>Arguments passed to the neighbor-creating function.</p>
</td></tr>
<tr><td><code id="ww_build_neighbors_+3A_call">call</code></td>
<td>
<p>The execution environment of a currently running
function, e.g. <code>call = caller_env()</code>. The corresponding function
call is retrieved and mentioned in error messages as the source
of the error.
</p>
<p>You only need to supply <code>call</code> when throwing a condition from a
helper function which wouldn't be relevant to mention in the
message.
</p>
<p>Can also be <code>NULL</code> or a <a href="rlang.html#topic+topic-defuse">defused function call</a> to
respectively not display any call or hard-code a code to display.
</p>
<p>For more information about error calls, see <a href="rlang.html#topic+topic-error-call">Including function calls in error messages</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>nb = NULL</code>, the method used to create neighbors from <code>data</code> is
dependent on what geometry type <code>data</code> is:
</p>

<ul>
<li><p> If <code>nb = NULL</code> and <code>data</code> is a point geometry
(classes &quot;sfc_POINT&quot; or &quot;sfc_MULTIPOINT&quot;) the &quot;nb&quot; object will be created
using <code><a href="#topic+ww_make_point_neighbors">ww_make_point_neighbors()</a></code>.
</p>
</li>
<li><p> If <code>nb = NULL</code> and <code>data</code> is a polygon geometry
(classes &quot;sfc_POLYGON&quot; or &quot;sfc_MULTIPOLYGON&quot;) the &quot;nb&quot; object will be created
using <code><a href="#topic+ww_make_polygon_neighbors">ww_make_polygon_neighbors()</a></code>.
</p>
</li>
<li><p> If <code>nb = NULL</code> and <code>data</code> is any other geometry type, the &quot;nb&quot; object will
be created using the centroids of the data as points, with a warning.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class &quot;nb&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ww_build_neighbors(guerry)

</code></pre>

<hr>
<h2 id='ww_build_weights'>Build &quot;listw&quot; objects of spatial weights</h2><span id='topic+ww_build_weights'></span>

<h3>Description</h3>

<p>These functions can be used for geographic or projected coordinate reference
systems and expect 2D data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ww_build_weights(x, wt = NULL, include_self = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ww_build_weights_+3A_x">x</code></td>
<td>
<p>Either an sf object or a &quot;nb&quot; neighbors list object.
If an sf object, will be converted into a neighbors list via
<code><a href="#topic+ww_build_neighbors">ww_build_neighbors()</a></code>.</p>
</td></tr>
<tr><td><code id="ww_build_weights_+3A_wt">wt</code></td>
<td>
<p>Either a &quot;listw&quot; object (which will be returned unchanged),
a function for creating a &quot;listw&quot; object from <code>x</code>, or <code>NULL</code>, in which case
weights will be constructed via <code><a href="spdep.html#topic+nb2listw">spdep::nb2listw()</a></code>.</p>
</td></tr>
<tr><td><code id="ww_build_weights_+3A_include_self">include_self</code></td>
<td>
<p>Include each region itself in its own list of neighbors?</p>
</td></tr>
<tr><td><code id="ww_build_weights_+3A_...">...</code></td>
<td>
<p>Arguments passed to the weight constructing function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>listw</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ww_build_weights(guerry)

</code></pre>

<hr>
<h2 id='ww_global_geary_c'>Global Geary's C statistic</h2><span id='topic+ww_global_geary_c'></span><span id='topic+ww_global_geary_c_vec'></span><span id='topic+ww_global_geary_pvalue'></span><span id='topic+ww_global_geary_pvalue_vec'></span>

<h3>Description</h3>

<p>Calculate the global Geary's C statistic for model residuals.
<code>ww_global_geary_c()</code> returns the statistic itself, while
<code>ww_global_geary_pvalue()</code> returns the associated p value.
These functions are meant to help assess model predictions, for instance by
identifying if there are clusters of higher residuals than expected. For
statistical testing and inference applications, use
<code><a href="spdep.html#topic+geary.test">spdep::geary.test()</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ww_global_geary_c(data, ...)

ww_global_geary_c_vec(truth, estimate, wt, na_rm = FALSE, ...)

ww_global_geary_pvalue(data, ...)

ww_global_geary_pvalue_vec(truth, estimate, wt = NULL, na_rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ww_global_geary_c_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> containing the columns specified by the <code>truth</code>
and <code>estimate</code> arguments.</p>
</td></tr>
<tr><td><code id="ww_global_geary_c_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="spdep.html#topic+geary">spdep::geary()</a></code> (for
<code>ww_global_geary_c()</code>) or <code><a href="spdep.html#topic+geary.test">spdep::geary.test()</a></code> (for
<code>ww_global_geary_pvalue()</code>).</p>
</td></tr>
<tr><td><code id="ww_global_geary_c_+3A_truth">truth</code></td>
<td>
<p>The column identifier for the true results
(that is <code>numeric</code>). This should be an unquoted column name although
this argument is passed by expression and supports
<a href="rlang.html#topic+topic-inject">quasiquotation</a> (you can unquote column
names). For <code style="white-space: pre;">&#8288;_vec()&#8288;</code> functions, a <code>numeric</code> vector.</p>
</td></tr>
<tr><td><code id="ww_global_geary_c_+3A_estimate">estimate</code></td>
<td>
<p>The column identifier for the predicted
results (that is also <code>numeric</code>). As with <code>truth</code> this can be
specified different ways but the primary method is to use an
unquoted variable name. For <code style="white-space: pre;">&#8288;_vec()&#8288;</code> functions, a <code>numeric</code> vector.</p>
</td></tr>
<tr><td><code id="ww_global_geary_c_+3A_wt">wt</code></td>
<td>
<p>A <code>listw</code> object, for instance as created with <code><a href="#topic+ww_build_weights">ww_build_weights()</a></code>.
For data.frame input, may also be a function that takes <code>data</code> and returns a
<code>listw</code> object.</p>
</td></tr>
<tr><td><code id="ww_global_geary_c_+3A_na_rm">na_rm</code></td>
<td>
<p>A <code>logical</code> value indicating whether <code>NA</code>
values should be stripped before the computation proceeds.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions can be used for geographic or projected coordinate reference
systems and expect 2D data.
</p>


<h3>Value</h3>

<p>A tibble with columns .metric, .estimator, and .estimate and 1 row of values.
For grouped data frames, the number of rows returned will be the same as the
number of groups.
For <code style="white-space: pre;">&#8288;_vec()&#8288;</code> functions, a single value (or NA).
</p>


<h3>References</h3>

<p>Geary, R. C. (1954). &quot;The Contiguity Ratio and Statistical Mapping&quot;. The
Incorporated Statistician. 5 (3): 115â145. doi:10.2307/2986645.
</p>
<p>Cliff, A. D., Ord, J. K. 1981 Spatial processes, Pion, p. 17.
</p>


<h3>See Also</h3>

<p>Other autocorrelation metrics: 
<code><a href="#topic+ww_global_moran_i">ww_global_moran_i</a>()</code>,
<code><a href="#topic+ww_local_geary_c">ww_local_geary_c</a>()</code>,
<code><a href="#topic+ww_local_getis_ord_g">ww_local_getis_ord_g</a>()</code>,
<code><a href="#topic+ww_local_moran_i">ww_local_moran_i</a>()</code>
</p>
<p>Other yardstick metrics: 
<code><a href="#topic+ww_agreement_coefficient">ww_agreement_coefficient</a>()</code>,
<code><a href="#topic+ww_global_moran_i">ww_global_moran_i</a>()</code>,
<code><a href="#topic+ww_local_geary_c">ww_local_geary_c</a>()</code>,
<code><a href="#topic+ww_local_getis_ord_g">ww_local_getis_ord_g</a>()</code>,
<code><a href="#topic+ww_local_moran_i">ww_local_moran_i</a>()</code>,
<code><a href="#topic+ww_willmott_d">ww_willmott_d</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>guerry_model &lt;- guerry
guerry_lm &lt;- lm(Crm_prs ~ Litercy, guerry_model)
guerry_model$predictions &lt;- predict(guerry_lm, guerry_model)

ww_global_geary_c(guerry_model, Crm_prs, predictions)
ww_global_geary_pvalue(guerry_model, Crm_prs, predictions)

wt &lt;- ww_build_weights(guerry_model)

ww_global_geary_c_vec(
  guerry_model$Crm_prs,
  guerry_model$predictions,
  wt = wt
)
ww_global_geary_pvalue_vec(
  guerry_model$Crm_prs,
  guerry_model$predictions,
  wt = wt
)

</code></pre>

<hr>
<h2 id='ww_global_moran_i'>Global Moran's I statistic</h2><span id='topic+ww_global_moran_i'></span><span id='topic+ww_global_moran_i_vec'></span><span id='topic+ww_global_moran_pvalue'></span><span id='topic+ww_global_moran_pvalue_vec'></span>

<h3>Description</h3>

<p>Calculate the global Moran's I statistic for model residuals.
<code>ww_global_moran_i()</code> returns the statistic itself, while
<code>ww_global_moran_pvalue()</code> returns the associated p value.
These functions are meant to help assess model predictions, for instance by
identifying if there are clusters of higher residuals than expected. For
statistical testing and inference applications, use
<code><a href="spdep.html#topic+moran.test">spdep::moran.test()</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ww_global_moran_i(data, ...)

ww_global_moran_i_vec(truth, estimate, wt = NULL, na_rm = FALSE, ...)

ww_global_moran_pvalue(data, ...)

ww_global_moran_pvalue_vec(truth, estimate, wt = NULL, na_rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ww_global_moran_i_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> containing the columns specified by the <code>truth</code>
and <code>estimate</code> arguments.</p>
</td></tr>
<tr><td><code id="ww_global_moran_i_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="spdep.html#topic+moran">spdep::moran()</a></code> (for
<code>ww_global_moran_i()</code>) or <code><a href="spdep.html#topic+moran.test">spdep::moran.test()</a></code> (for
<code>ww_global_moran_pvalue()</code>).</p>
</td></tr>
<tr><td><code id="ww_global_moran_i_+3A_truth">truth</code></td>
<td>
<p>The column identifier for the true results
(that is <code>numeric</code>). This should be an unquoted column name although
this argument is passed by expression and supports
<a href="rlang.html#topic+topic-inject">quasiquotation</a> (you can unquote column
names). For <code style="white-space: pre;">&#8288;_vec()&#8288;</code> functions, a <code>numeric</code> vector.</p>
</td></tr>
<tr><td><code id="ww_global_moran_i_+3A_estimate">estimate</code></td>
<td>
<p>The column identifier for the predicted
results (that is also <code>numeric</code>). As with <code>truth</code> this can be
specified different ways but the primary method is to use an
unquoted variable name. For <code style="white-space: pre;">&#8288;_vec()&#8288;</code> functions, a <code>numeric</code> vector.</p>
</td></tr>
<tr><td><code id="ww_global_moran_i_+3A_wt">wt</code></td>
<td>
<p>A <code>listw</code> object, for instance as created with <code><a href="#topic+ww_build_weights">ww_build_weights()</a></code>.
For data.frame input, may also be a function that takes <code>data</code> and returns a
<code>listw</code> object.</p>
</td></tr>
<tr><td><code id="ww_global_moran_i_+3A_na_rm">na_rm</code></td>
<td>
<p>A <code>logical</code> value indicating whether <code>NA</code>
values should be stripped before the computation proceeds.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions can be used for geographic or projected coordinate reference
systems and expect 2D data.
</p>


<h3>Value</h3>

<p>A tibble with columns .metric, .estimator, and .estimate and 1 row of values.
For grouped data frames, the number of rows returned will be the same as the
number of groups.
For <code style="white-space: pre;">&#8288;_vec()&#8288;</code> functions, a single value (or NA).
</p>


<h3>References</h3>

<p>Moran, P.A.P. (1950). &quot;Notes on Continuous Stochastic Phenomena.&quot; Biometrika,
37(1/2), pp 17. doi: 10.2307/2332142
</p>
<p>Cliff, A. D., Ord, J. K. 1981 Spatial processes, Pion, p. 17.
</p>


<h3>See Also</h3>

<p>Other autocorrelation metrics: 
<code><a href="#topic+ww_global_geary_c">ww_global_geary_c</a>()</code>,
<code><a href="#topic+ww_local_geary_c">ww_local_geary_c</a>()</code>,
<code><a href="#topic+ww_local_getis_ord_g">ww_local_getis_ord_g</a>()</code>,
<code><a href="#topic+ww_local_moran_i">ww_local_moran_i</a>()</code>
</p>
<p>Other yardstick metrics: 
<code><a href="#topic+ww_agreement_coefficient">ww_agreement_coefficient</a>()</code>,
<code><a href="#topic+ww_global_geary_c">ww_global_geary_c</a>()</code>,
<code><a href="#topic+ww_local_geary_c">ww_local_geary_c</a>()</code>,
<code><a href="#topic+ww_local_getis_ord_g">ww_local_getis_ord_g</a>()</code>,
<code><a href="#topic+ww_local_moran_i">ww_local_moran_i</a>()</code>,
<code><a href="#topic+ww_willmott_d">ww_willmott_d</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>guerry_model &lt;- guerry
guerry_lm &lt;- lm(Crm_prs ~ Litercy, guerry_model)
guerry_model$predictions &lt;- predict(guerry_lm, guerry_model)

ww_global_moran_i(guerry_model, Crm_prs, predictions)
ww_global_moran_pvalue(guerry_model, Crm_prs, predictions)

wt &lt;- ww_build_weights(guerry_model)

ww_global_moran_i_vec(
  guerry_model$Crm_prs,
  guerry_model$predictions,
  wt = wt
)
ww_global_moran_pvalue_vec(
  guerry_model$Crm_prs,
  guerry_model$predictions,
  wt = wt
)

</code></pre>

<hr>
<h2 id='ww_local_geary_c'>Local Geary's C statistic</h2><span id='topic+ww_local_geary_c'></span><span id='topic+ww_local_geary_c_vec'></span><span id='topic+ww_local_geary_pvalue'></span><span id='topic+ww_local_geary_pvalue_vec'></span>

<h3>Description</h3>

<p>Calculate the local Geary's C statistic for model residuals.
<code>ww_local_geary_c()</code> returns the statistic itself, while
<code>ww_local_geary_pvalue()</code> returns the associated p value.
These functions are meant to help assess model predictions, for instance by
identifying clusters of higher residuals than expected. For statistical
testing and inference applications, use <code><a href="spdep.html#topic+localC">spdep::localC_perm()</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ww_local_geary_c(data, ...)

ww_local_geary_c_vec(truth, estimate, wt, na_rm = FALSE, ...)

ww_local_geary_pvalue(data, ...)

ww_local_geary_pvalue_vec(truth, estimate, wt = NULL, na_rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ww_local_geary_c_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> containing the columns specified by the <code>truth</code>
and <code>estimate</code> arguments.</p>
</td></tr>
<tr><td><code id="ww_local_geary_c_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="spdep.html#topic+localC">spdep::localC()</a></code> (for
<code>ww_local_geary_c()</code>) or <code><a href="spdep.html#topic+localC">spdep::localC_perm()</a></code> (for
<code>ww_local_geary_pvalue()</code>).</p>
</td></tr>
<tr><td><code id="ww_local_geary_c_+3A_truth">truth</code></td>
<td>
<p>The column identifier for the true results
(that is <code>numeric</code>). This should be an unquoted column name although
this argument is passed by expression and supports
<a href="rlang.html#topic+topic-inject">quasiquotation</a> (you can unquote column
names). For <code style="white-space: pre;">&#8288;_vec()&#8288;</code> functions, a <code>numeric</code> vector.</p>
</td></tr>
<tr><td><code id="ww_local_geary_c_+3A_estimate">estimate</code></td>
<td>
<p>The column identifier for the predicted
results (that is also <code>numeric</code>). As with <code>truth</code> this can be
specified different ways but the primary method is to use an
unquoted variable name. For <code style="white-space: pre;">&#8288;_vec()&#8288;</code> functions, a <code>numeric</code> vector.</p>
</td></tr>
<tr><td><code id="ww_local_geary_c_+3A_wt">wt</code></td>
<td>
<p>A <code>listw</code> object, for instance as created with <code><a href="#topic+ww_build_weights">ww_build_weights()</a></code>.
For data.frame input, may also be a function that takes <code>data</code> and returns a
<code>listw</code> object.</p>
</td></tr>
<tr><td><code id="ww_local_geary_c_+3A_na_rm">na_rm</code></td>
<td>
<p>A <code>logical</code> value indicating whether <code>NA</code>
values should be stripped before the computation proceeds.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions can be used for geographic or projected coordinate reference
systems and expect 2D data.
</p>


<h3>Value</h3>

<p>A tibble with columns .metric, .estimator, and .estimate and <code>nrow(data)</code>
rows of values.
For <code style="white-space: pre;">&#8288;_vec()&#8288;</code> functions, a numeric vector of <code>length(truth)</code> (or NA).
</p>


<h3>References</h3>

<p>Anselin, L. 1995. Local indicators of spatial association, Geographical
Analysis, 27, pp 93â115. doi: 10.1111/j.1538-4632.1995.tb00338.x.
</p>
<p>Anselin, L. 2019. A Local Indicator of Multivariate Spatial Association:
Extending Geary's C. Geographical Analysis, 51, pp 133-150.
doi: 10.1111/gean.12164
</p>


<h3>See Also</h3>

<p>Other autocorrelation metrics: 
<code><a href="#topic+ww_global_geary_c">ww_global_geary_c</a>()</code>,
<code><a href="#topic+ww_global_moran_i">ww_global_moran_i</a>()</code>,
<code><a href="#topic+ww_local_getis_ord_g">ww_local_getis_ord_g</a>()</code>,
<code><a href="#topic+ww_local_moran_i">ww_local_moran_i</a>()</code>
</p>
<p>Other yardstick metrics: 
<code><a href="#topic+ww_agreement_coefficient">ww_agreement_coefficient</a>()</code>,
<code><a href="#topic+ww_global_geary_c">ww_global_geary_c</a>()</code>,
<code><a href="#topic+ww_global_moran_i">ww_global_moran_i</a>()</code>,
<code><a href="#topic+ww_local_getis_ord_g">ww_local_getis_ord_g</a>()</code>,
<code><a href="#topic+ww_local_moran_i">ww_local_moran_i</a>()</code>,
<code><a href="#topic+ww_willmott_d">ww_willmott_d</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>guerry_model &lt;- guerry
guerry_lm &lt;- lm(Crm_prs ~ Litercy, guerry_model)
guerry_model$predictions &lt;- predict(guerry_lm, guerry_model)

ww_local_geary_c(guerry_model, Crm_prs, predictions)
ww_local_geary_pvalue(guerry_model, Crm_prs, predictions)

wt &lt;- ww_build_weights(guerry_model)

ww_local_geary_c_vec(
  guerry_model$Crm_prs,
  guerry_model$predictions,
  wt = wt
)
ww_local_geary_pvalue_vec(
  guerry_model$Crm_prs,
  guerry_model$predictions,
  wt = wt
)

</code></pre>

<hr>
<h2 id='ww_local_getis_ord_g'>Local Getis-Ord G and G* statistic</h2><span id='topic+ww_local_getis_ord_g'></span><span id='topic+ww_local_getis_ord_g_vec'></span><span id='topic+ww_local_getis_ord_g_pvalue'></span><span id='topic+ww_local_getis_ord_g_pvalue_vec'></span>

<h3>Description</h3>

<p>Calculate the local Getis-Ord G and G* statistic for model residuals.
<code>ww_local_getis_ord_g()</code> returns the statistic itself, while
<code>ww_local_getis_ord_pvalue()</code> returns the associated p value.
These functions are meant to help assess model predictions, for instance by
identifying clusters of higher residuals than expected. For statistical
testing and inference applications, use <code><a href="spdep.html#topic+localG">spdep::localG_perm()</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ww_local_getis_ord_g(data, ...)

ww_local_getis_ord_g_vec(truth, estimate, wt, na_rm = FALSE, ...)

ww_local_getis_ord_g_pvalue(data, ...)

ww_local_getis_ord_g_pvalue_vec(truth, estimate, wt, na_rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ww_local_getis_ord_g_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> containing the columns specified by the <code>truth</code>
and <code>estimate</code> arguments.</p>
</td></tr>
<tr><td><code id="ww_local_getis_ord_g_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="spdep.html#topic+localG">spdep::localG()</a></code> (for
<code>ww_local_getis_ord_g()</code>) or <code><a href="spdep.html#topic+localG">spdep::localG_perm()</a></code> (for
<code>ww_local_getis_ord_pvalue()</code>).</p>
</td></tr>
<tr><td><code id="ww_local_getis_ord_g_+3A_truth">truth</code></td>
<td>
<p>The column identifier for the true results
(that is <code>numeric</code>). This should be an unquoted column name although
this argument is passed by expression and supports
<a href="rlang.html#topic+topic-inject">quasiquotation</a> (you can unquote column
names). For <code style="white-space: pre;">&#8288;_vec()&#8288;</code> functions, a <code>numeric</code> vector.</p>
</td></tr>
<tr><td><code id="ww_local_getis_ord_g_+3A_estimate">estimate</code></td>
<td>
<p>The column identifier for the predicted
results (that is also <code>numeric</code>). As with <code>truth</code> this can be
specified different ways but the primary method is to use an
unquoted variable name. For <code style="white-space: pre;">&#8288;_vec()&#8288;</code> functions, a <code>numeric</code> vector.</p>
</td></tr>
<tr><td><code id="ww_local_getis_ord_g_+3A_wt">wt</code></td>
<td>
<p>A <code>listw</code> object, for instance as created with <code><a href="#topic+ww_build_weights">ww_build_weights()</a></code>.
For data.frame input, may also be a function that takes <code>data</code> and returns a
<code>listw</code> object.</p>
</td></tr>
<tr><td><code id="ww_local_getis_ord_g_+3A_na_rm">na_rm</code></td>
<td>
<p>A <code>logical</code> value indicating whether <code>NA</code>
values should be stripped before the computation proceeds.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions can be used for geographic or projected coordinate reference
systems and expect 2D data.
</p>


<h3>Value</h3>

<p>A tibble with columns .metric, .estimator, and .estimate and <code>nrow(data)</code>
rows of values.
For <code style="white-space: pre;">&#8288;_vec()&#8288;</code> functions, a numeric vector of <code>length(truth)</code> (or NA).
</p>


<h3>References</h3>

<p>Ord, J. K. and Getis, A. 1995. Local spatial autocorrelation statistics:
distributional issues and an application. Geographical Analysis, 27, 286â306.
doi: 10.1111/j.1538-4632.1995.tb00912.x
</p>


<h3>See Also</h3>

<p>Other autocorrelation metrics: 
<code><a href="#topic+ww_global_geary_c">ww_global_geary_c</a>()</code>,
<code><a href="#topic+ww_global_moran_i">ww_global_moran_i</a>()</code>,
<code><a href="#topic+ww_local_geary_c">ww_local_geary_c</a>()</code>,
<code><a href="#topic+ww_local_moran_i">ww_local_moran_i</a>()</code>
</p>
<p>Other yardstick metrics: 
<code><a href="#topic+ww_agreement_coefficient">ww_agreement_coefficient</a>()</code>,
<code><a href="#topic+ww_global_geary_c">ww_global_geary_c</a>()</code>,
<code><a href="#topic+ww_global_moran_i">ww_global_moran_i</a>()</code>,
<code><a href="#topic+ww_local_geary_c">ww_local_geary_c</a>()</code>,
<code><a href="#topic+ww_local_moran_i">ww_local_moran_i</a>()</code>,
<code><a href="#topic+ww_willmott_d">ww_willmott_d</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>guerry_model &lt;- guerry
guerry_lm &lt;- lm(Crm_prs ~ Litercy, guerry_model)
guerry_model$predictions &lt;- predict(guerry_lm, guerry_model)

ww_local_getis_ord_g(guerry_model, Crm_prs, predictions)
ww_local_getis_ord_g_pvalue(guerry_model, Crm_prs, predictions)

wt &lt;- ww_build_weights(guerry_model)

ww_local_getis_ord_g_vec(
  guerry_model$Crm_prs,
  guerry_model$predictions,
  wt = wt
)
ww_local_getis_ord_g_pvalue_vec(
  guerry_model$Crm_prs,
  guerry_model$predictions,
  wt = wt
)

</code></pre>

<hr>
<h2 id='ww_local_moran_i'>Local Moran's I statistic</h2><span id='topic+ww_local_moran_i'></span><span id='topic+ww_local_moran_i_vec'></span><span id='topic+ww_local_moran_pvalue'></span><span id='topic+ww_local_moran_pvalue_vec'></span>

<h3>Description</h3>

<p>Calculate the local Moran's I statistic for model residuals.
<code>ww_local_moran_i()</code> returns the statistic itself, while
<code>ww_local_moran_pvalue()</code> returns the associated p value.
These functions are meant to help assess model predictions, for instance by
identifying clusters of higher residuals than expected. For statistical
testing and inference applications, use <code><a href="spdep.html#topic+localmoran">spdep::localmoran_perm()</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ww_local_moran_i(data, ...)

ww_local_moran_i_vec(truth, estimate, wt, na_rm = FALSE, ...)

ww_local_moran_pvalue(data, ...)

ww_local_moran_pvalue_vec(truth, estimate, wt = NULL, na_rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ww_local_moran_i_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> containing the columns specified by the <code>truth</code>
and <code>estimate</code> arguments.</p>
</td></tr>
<tr><td><code id="ww_local_moran_i_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="spdep.html#topic+localmoran">spdep::localmoran()</a></code>.</p>
</td></tr>
<tr><td><code id="ww_local_moran_i_+3A_truth">truth</code></td>
<td>
<p>The column identifier for the true results
(that is <code>numeric</code>). This should be an unquoted column name although
this argument is passed by expression and supports
<a href="rlang.html#topic+topic-inject">quasiquotation</a> (you can unquote column
names). For <code style="white-space: pre;">&#8288;_vec()&#8288;</code> functions, a <code>numeric</code> vector.</p>
</td></tr>
<tr><td><code id="ww_local_moran_i_+3A_estimate">estimate</code></td>
<td>
<p>The column identifier for the predicted
results (that is also <code>numeric</code>). As with <code>truth</code> this can be
specified different ways but the primary method is to use an
unquoted variable name. For <code style="white-space: pre;">&#8288;_vec()&#8288;</code> functions, a <code>numeric</code> vector.</p>
</td></tr>
<tr><td><code id="ww_local_moran_i_+3A_wt">wt</code></td>
<td>
<p>A <code>listw</code> object, for instance as created with <code><a href="#topic+ww_build_weights">ww_build_weights()</a></code>.
For data.frame input, may also be a function that takes <code>data</code> and returns a
<code>listw</code> object.</p>
</td></tr>
<tr><td><code id="ww_local_moran_i_+3A_na_rm">na_rm</code></td>
<td>
<p>A <code>logical</code> value indicating whether <code>NA</code>
values should be stripped before the computation proceeds.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions can be used for geographic or projected coordinate reference
systems and expect 2D data.
</p>


<h3>Value</h3>

<p>A tibble with columns .metric, .estimator, and .estimate and <code>nrow(data)</code>
rows of values.
For <code style="white-space: pre;">&#8288;_vec()&#8288;</code> functions, a numeric vector of <code>length(truth)</code> (or NA).
</p>


<h3>References</h3>

<p>Anselin, L. 1995. Local indicators of spatial association, Geographical
Analysis, 27, pp 93â115. doi: 10.1111/j.1538-4632.1995.tb00338.x.
</p>
<p>Sokal, R. R, Oden, N. L. and Thomson, B. A. 1998. Local Spatial
Autocorrelation in a Biological Model. Geographical Analysis, 30, pp 331â354.
doi: 10.1111/j.1538-4632.1998.tb00406.x
</p>


<h3>See Also</h3>

<p>Other autocorrelation metrics: 
<code><a href="#topic+ww_global_geary_c">ww_global_geary_c</a>()</code>,
<code><a href="#topic+ww_global_moran_i">ww_global_moran_i</a>()</code>,
<code><a href="#topic+ww_local_geary_c">ww_local_geary_c</a>()</code>,
<code><a href="#topic+ww_local_getis_ord_g">ww_local_getis_ord_g</a>()</code>
</p>
<p>Other yardstick metrics: 
<code><a href="#topic+ww_agreement_coefficient">ww_agreement_coefficient</a>()</code>,
<code><a href="#topic+ww_global_geary_c">ww_global_geary_c</a>()</code>,
<code><a href="#topic+ww_global_moran_i">ww_global_moran_i</a>()</code>,
<code><a href="#topic+ww_local_geary_c">ww_local_geary_c</a>()</code>,
<code><a href="#topic+ww_local_getis_ord_g">ww_local_getis_ord_g</a>()</code>,
<code><a href="#topic+ww_willmott_d">ww_willmott_d</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>guerry_model &lt;- guerry
guerry_lm &lt;- lm(Crm_prs ~ Litercy, guerry_model)
guerry_model$predictions &lt;- predict(guerry_lm, guerry_model)

ww_local_moran_i(guerry_model, Crm_prs, predictions)
ww_local_moran_pvalue(guerry_model, Crm_prs, predictions)

wt &lt;- ww_build_weights(guerry_model)

ww_local_moran_i_vec(
  guerry_model$Crm_prs,
  guerry_model$predictions,
  wt = wt
)
ww_local_moran_pvalue_vec(
  guerry_model$Crm_prs,
  guerry_model$predictions,
  wt = wt
)

</code></pre>

<hr>
<h2 id='ww_make_point_neighbors'>Make 'nb' objects from point geometries</h2><span id='topic+ww_make_point_neighbors'></span>

<h3>Description</h3>

<p>This function uses <code><a href="spdep.html#topic+knearneigh">spdep::knearneigh()</a></code> and <code><a href="spdep.html#topic+knn2nb">spdep::knn2nb()</a></code> to
create a &quot;nb&quot; neighbors list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ww_make_point_neighbors(data, k = 1, sym = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ww_make_point_neighbors_+3A_data">data</code></td>
<td>
<p>An <code>sfc_POINT</code> or <code>sfc_MULTIPOINT</code> object.</p>
</td></tr>
<tr><td><code id="ww_make_point_neighbors_+3A_k">k</code></td>
<td>
<p>How many nearest neighbors to use in <code><a href="spdep.html#topic+knearneigh">spdep::knearneigh()</a></code>.</p>
</td></tr>
<tr><td><code id="ww_make_point_neighbors_+3A_sym">sym</code></td>
<td>
<p>Force the output neighbors list (from <code><a href="spdep.html#topic+knn2nb">spdep::knn2nb()</a></code>) to
symmetry.</p>
</td></tr>
<tr><td><code id="ww_make_point_neighbors_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="spdep.html#topic+knearneigh">spdep::knearneigh()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions can be used for geographic or projected coordinate reference
systems and expect 2D data.
</p>


<h3>Value</h3>

<p>An object of class &quot;nb&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ww_make_point_neighbors(ny_trees)

</code></pre>

<hr>
<h2 id='ww_make_polygon_neighbors'>Make 'nb' objects from polygon geometries</h2><span id='topic+ww_make_polygon_neighbors'></span>

<h3>Description</h3>

<p>This function is an extremely thin wrapper around <code><a href="spdep.html#topic+poly2nb">spdep::poly2nb()</a></code>,
renamed to use the waywiser &quot;ww&quot; prefix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ww_make_polygon_neighbors(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ww_make_polygon_neighbors_+3A_data">data</code></td>
<td>
<p>An <code>sfc_POLYGON</code> or <code>sfc_MULTIPOLYGON</code> object.</p>
</td></tr>
<tr><td><code id="ww_make_polygon_neighbors_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="spdep.html#topic+poly2nb">spdep::poly2nb()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions can be used for geographic or projected coordinate reference
systems and expect 2D data.
</p>


<h3>Value</h3>

<p>An object of class &quot;nb&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ww_make_polygon_neighbors(guerry)

</code></pre>

<hr>
<h2 id='ww_multi_scale'>Evaluate metrics at multiple scales of aggregation</h2><span id='topic+ww_multi_scale'></span>

<h3>Description</h3>

<p>Evaluate metrics at multiple scales of aggregation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ww_multi_scale(
  data = NULL,
  truth,
  estimate,
  metrics = list(yardstick::rmse, yardstick::mae),
  grids = NULL,
  ...,
  na_rm = TRUE,
  aggregation_function = "mean",
  autoexpand_grid = TRUE,
  progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ww_multi_scale_+3A_data">data</code></td>
<td>
<p>Either: a point geometry <code>sf</code> object containing the columns
specified by the <code>truth</code> and <code>estimate</code> arguments; a <code>SpatRaster</code> from
the <code>terra</code> package containing layers specified by the <code>truth</code> and <code>estimate</code>
arguments; or <code>NULL</code> if <code>truth</code> and <code>estimate</code> are <code>SpatRaster</code> objects.</p>
</td></tr>
<tr><td><code id="ww_multi_scale_+3A_truth">truth</code>, <code id="ww_multi_scale_+3A_estimate">estimate</code></td>
<td>
<p>If <code>data</code> is an <code>sf</code> object, the names (optionally
unquoted) for the columns in <code>data</code> containing the true and predicted values,
respectively. If <code>data</code> is a <code>SpatRaster</code> object, either (quoted) layer names or
indices which will select the true and predicted layers, respectively, via
<code><a href="terra.html#topic+subset">terra::subset()</a></code> If <code>data</code> is <code>NULL</code>, <code>SpatRaster</code> objects with a single
layer containing the true and predicted values, respectively.</p>
</td></tr>
<tr><td><code id="ww_multi_scale_+3A_metrics">metrics</code></td>
<td>
<p>Either a <code><a href="yardstick.html#topic+metric_set">yardstick::metric_set()</a></code> object, or a list of
functions which will be used to construct a <code><a href="yardstick.html#topic+metric_set">yardstick::metric_set()</a></code> object
specifying the performance metrics to evaluate at each scale.</p>
</td></tr>
<tr><td><code id="ww_multi_scale_+3A_grids">grids</code></td>
<td>
<p>Optionally, a list of pre-computed <code>sf</code> or <code>sfc</code> objects
specifying polygon boundaries to use for assessments.</p>
</td></tr>
<tr><td><code id="ww_multi_scale_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="sf.html#topic+st_make_grid">sf::st_make_grid()</a></code>.
<strong>You almost certainly should provide these arguments as lists.</strong>
For instance, passing <code>n = list(c(1, 2))</code> will create a single 1x2 grid;
passing <code>n = c(1, 2)</code> will create a 1x1 grid <em>and</em> a 2x2 grid.</p>
</td></tr>
<tr><td><code id="ww_multi_scale_+3A_na_rm">na_rm</code></td>
<td>
<p>Boolean: Should polygons with NA values be removed before
calculating metrics? Note that this does <em>not</em> impact how values are
aggregated to polygons: if you want to remove NA values before aggregating,
provide a function to <code>aggregation_function</code> which will remove NA values.</p>
</td></tr>
<tr><td><code id="ww_multi_scale_+3A_aggregation_function">aggregation_function</code></td>
<td>
<p>The function to use to aggregate predictions and
true values at various scales, by default <code><a href="base.html#topic+mean">mean()</a></code>. For the <code>sf</code> method,
you can pass any function which takes a single vector and returns a scalar.
For raster methods, any function accepted by
<code><a href="exactextractr.html#topic+exact_extract">exactextractr::exact_extract()</a></code> (note that built-in function names must be
quoted). Note that this function does <em>not</em> pay attention to the value of
<code>na_rm</code>; any NA handling you want to do during aggregation should be handled
by this function directly.</p>
</td></tr>
<tr><td><code id="ww_multi_scale_+3A_autoexpand_grid">autoexpand_grid</code></td>
<td>
<p>Boolean: if <code>data</code> is in geographic coordinates and
<code>grids</code> aren't provided, the grids generated by <code><a href="sf.html#topic+st_make_grid">sf::st_make_grid()</a></code> may not
contain all observations. If <code>TRUE</code>, this function will automatically expand
generated grids by a tiny factor to attempt to capture all observations.</p>
</td></tr>
<tr><td><code id="ww_multi_scale_+3A_progress">progress</code></td>
<td>
<p>Boolean: if <code>data</code> is <code>NULL</code>, should aggregation via
<code><a href="exactextractr.html#topic+exact_extract">exactextractr::exact_extract()</a></code> show a progress bar? Separate progress bars
will be shown for each time <code>truth</code> and <code>estimate</code> are aggregated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with six columns: <code>.metric</code>, with the name
of the metric that the row describes; <code>.estimator</code>, with the name of the
estimator used, <code>.estimate</code>, with the output of the metric function;
<code>.grid_args</code>, with the arguments passed to <code><a href="sf.html#topic+st_make_grid">sf::st_make_grid()</a></code> via <code>...</code>
(if any), <code>.grid</code>, containing the grids used to aggregate predictions,
as well as the aggregated values of <code>truth</code> and <code>estimate</code> as well as the
count of non-NA values for each, and <code>.notes</code>, which (if <code>data</code> is an <code>sf</code>
object) will indicate any observations which were not used in a given
assessment.
</p>


<h3>Raster inputs</h3>

<p>If <code>data</code> is <code>NULL</code>, then <code>truth</code> and <code>estimate</code> should both be <code>SpatRaster</code>
objects, as created via <code><a href="terra.html#topic+rast">terra::rast()</a></code>. These rasters will then be
aggregated to each grid using <code><a href="exactextractr.html#topic+exact_extract">exactextractr::exact_extract()</a></code>. If <code>data</code>
is a <code>SpatRaster</code> object, then <code>truth</code> and <code>estimate</code> should be indices to
select the appropriate layers of the raster via <code><a href="terra.html#topic+subset">terra::subset()</a></code>.
</p>
<p>Grids are calculated using the bounding box of <code>truth</code>, under the assumption
that you may have extrapolated into regions which do not have matching &quot;true&quot;
values. This function does not check that <code>truth</code> and <code>estimate</code> overlap at
all, or that they are at all contained within the grid.
</p>


<h3>Creating grid blocks</h3>

<p>The grid blocks can be controlled by passing arguments to
<code><a href="sf.html#topic+st_make_grid">sf::st_make_grid()</a></code> via <code>...</code>. Some particularly useful arguments include:
</p>

<ul>
<li> <p><code>cellsize</code>: Target cellsize, expressed as the &quot;diameter&quot; (shortest
straight-line distance between opposing sides; two times the apothem)
of each block, in map units.
</p>
</li>
<li> <p><code>n</code>: The number of grid blocks in the x and y direction (columns, rows).
</p>
</li>
<li> <p><code>square</code>: A logical value indicating whether to create square (<code>TRUE</code>) or
hexagonal (<code>FALSE</code>) cells.
</p>
</li></ul>

<p>If both <code>cellsize</code> and <code>n</code> are provided, then the number of blocks requested
by <code>n</code> of sizes specified by <code>cellsize</code> will be returned, likely not
lining up with the bounding box of <code>data</code>. If only <code>cellsize</code>
is provided, this function will return as many blocks of size
<code>cellsize</code> as fit inside the bounding box of <code>data</code>. If only <code>n</code> is provided,
then <code>cellsize</code> will be automatically adjusted to create the requested
number of cells.
</p>
<p>Grids are created by mapping over each argument passed via <code>...</code>
simultaneously, in a similar manner to <code><a href="base.html#topic+mapply">mapply()</a></code> or <code><a href="purrr.html#topic+pmap">purrr::pmap()</a></code>. This
means that, for example, passing <code>n = list(c(1, 2))</code> will create a single
1x2 grid, while passing <code>n = c(1, 2)</code> will create a 1x1 grid <em>and</em> a 2x2
grid. It also means that arguments will be recycled using R's standard
vector recycling rules, so that passing <code>n = c(1, 2)</code> and <code>square = FALSE</code>
will create two separate grids of hexagons.
</p>
<p>This function can be used for geographic or projected coordinate reference
systems and expects 2D data.
</p>


<h3>References</h3>

<p>Riemann, R., Wilson, B. T., Lister, A., and Parks, S. (2010). &quot;An effective
assessment protocol for continuous geospatial datasets of forest
characteristics using USFS Forest Inventory and Analysis (FIA) data.&quot;
Remote Sensing of Environment 114(10), pp 2337-2352,
doi: 10.1016/j.rse.2010.05.010 .
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ames, package = "modeldata")
ames_sf &lt;- sf::st_as_sf(ames, coords = c("Longitude", "Latitude"), crs = 4326)
ames_model &lt;- lm(Sale_Price ~ Lot_Area, data = ames_sf)
ames_sf$predictions &lt;- predict(ames_model, ames_sf)

ww_multi_scale(
  ames_sf,
  Sale_Price,
  predictions,
  n = list(
    c(10, 10),
    c(1, 1)
  ),
  square = FALSE
)

# or, mostly equivalently
# (there will be a slight difference due to `autoexpand_grid = TRUE`)
grids &lt;- list(
  sf::st_make_grid(ames_sf, n = c(10, 10), square = FALSE),
  sf::st_make_grid(ames_sf, n = c(1, 1), square = FALSE)
)
ww_multi_scale(ames_sf, Sale_Price, predictions, grids = grids)

</code></pre>

<hr>
<h2 id='ww_willmott_d'>Willmott's d and related values</h2><span id='topic+ww_willmott_d'></span><span id='topic+ww_willmott_d.data.frame'></span><span id='topic+ww_willmott_d_vec'></span><span id='topic+ww_willmott_d1'></span><span id='topic+ww_willmott_d1.data.frame'></span><span id='topic+ww_willmott_d1_vec'></span><span id='topic+ww_willmott_dr'></span><span id='topic+ww_willmott_dr.data.frame'></span><span id='topic+ww_willmott_dr_vec'></span><span id='topic+ww_systematic_mse'></span><span id='topic+ww_systematic_mse.data.frame'></span><span id='topic+ww_systematic_mse_vec'></span><span id='topic+ww_unsystematic_mse'></span><span id='topic+ww_unsystematic_mse.data.frame'></span><span id='topic+ww_unsystematic_mse_vec'></span><span id='topic+ww_systematic_rmse'></span><span id='topic+ww_systematic_rmse.data.frame'></span><span id='topic+ww_systematic_rmse_vec'></span><span id='topic+ww_unsystematic_rmse'></span><span id='topic+ww_unsystematic_rmse.data.frame'></span><span id='topic+ww_unsystematic_rmse_vec'></span>

<h3>Description</h3>

<p>These functions calculate Willmott's d value, a proposed replacement for R2
which better differentiates between types and magnitudes of possible
covariations. Additional functions calculate systematic and unsystematic
components of MSE and RMSE; the sum of the systematic and unsystematic
components of MSE equal total MSE (though the same is not true for RMSE).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ww_willmott_d(data, ...)

## S3 method for class 'data.frame'
ww_willmott_d(data, truth, estimate, na_rm = TRUE, ...)

ww_willmott_d_vec(truth, estimate, na_rm = TRUE, ...)

ww_willmott_d1(data, ...)

## S3 method for class 'data.frame'
ww_willmott_d1(data, truth, estimate, na_rm = TRUE, ...)

ww_willmott_d1_vec(truth, estimate, na_rm = TRUE, ...)

ww_willmott_dr(data, ...)

## S3 method for class 'data.frame'
ww_willmott_dr(data, truth, estimate, na_rm = TRUE, ...)

ww_willmott_dr_vec(truth, estimate, na_rm = TRUE, ...)

ww_systematic_mse(data, ...)

## S3 method for class 'data.frame'
ww_systematic_mse(data, truth, estimate, na_rm = TRUE, ...)

ww_systematic_mse_vec(truth, estimate, na_rm = TRUE, ...)

ww_unsystematic_mse(data, ...)

## S3 method for class 'data.frame'
ww_unsystematic_mse(data, truth, estimate, na_rm = TRUE, ...)

ww_unsystematic_mse_vec(truth, estimate, na_rm = TRUE, ...)

ww_systematic_rmse(data, ...)

## S3 method for class 'data.frame'
ww_systematic_rmse(data, truth, estimate, na_rm = TRUE, ...)

ww_systematic_rmse_vec(truth, estimate, na_rm = TRUE, ...)

ww_unsystematic_rmse(data, ...)

## S3 method for class 'data.frame'
ww_unsystematic_rmse(data, truth, estimate, na_rm = TRUE, ...)

ww_unsystematic_rmse_vec(truth, estimate, na_rm = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ww_willmott_d_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> containing the columns specified by the <code>truth</code>
and <code>estimate</code> arguments.</p>
</td></tr>
<tr><td><code id="ww_willmott_d_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
<tr><td><code id="ww_willmott_d_+3A_truth">truth</code></td>
<td>
<p>The column identifier for the true results
(that is <code>numeric</code>). This should be an unquoted column name although
this argument is passed by expression and supports
<a href="rlang.html#topic+topic-inject">quasiquotation</a> (you can unquote column
names). For <code style="white-space: pre;">&#8288;_vec()&#8288;</code> functions, a <code>numeric</code> vector.</p>
</td></tr>
<tr><td><code id="ww_willmott_d_+3A_estimate">estimate</code></td>
<td>
<p>The column identifier for the predicted
results (that is also <code>numeric</code>). As with <code>truth</code> this can be
specified different ways but the primary method is to use an
unquoted variable name. For <code style="white-space: pre;">&#8288;_vec()&#8288;</code> functions, a <code>numeric</code> vector.</p>
</td></tr>
<tr><td><code id="ww_willmott_d_+3A_na_rm">na_rm</code></td>
<td>
<p>A <code>logical</code> value indicating whether <code>NA</code>
values should be stripped before the computation proceeds.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Values of d and d1 range from 0 to 1, with 1 indicating perfect agreement.
Values of
dr range from -1 to 1, with 1 similarly indicating perfect agreement. Values
of RMSE are in the same units as <code>truth</code> and <code>estimate</code>, while values of MSE
are in squared units. <code>truth</code> and <code>estimate</code> must be the same length. This
function is not explicitly spatial and as such can be applied to data with
any number of dimensions and any coordinate reference system.
</p>


<h3>Value</h3>

<p>A tibble with columns .metric, .estimator, and .estimate and 1 row of values.
For grouped data frames, the number of rows returned will be the same as the number of groups.
For <code style="white-space: pre;">&#8288;_vec()&#8288;</code> functions, a single value (or NA).
</p>


<h3>References</h3>

<p>Willmott, C. J. 1981. &quot;On the Validation of Models&quot;. Physical Geography 2(2),
pp 184-194, doi: 10.1080/02723646.1981.10642213.
</p>
<p>Willmott, C. J. 1982. &quot;Some Comments on the Evaluation of Model Performance&quot;.
Bulletin of the American Meteorological Society 63(11), pp 1309-1313,
doi: 10.1175/1520-0477(1982)063&lt;1309:SCOTEO&gt;2.0.CO;2.
</p>
<p>Willmott C. J., Ackleson S. G., Davis R. E., Feddema J. J., Klink K. M.,
Legates D. R., OâDonnell J., Rowe C. M. 1985. &quot;Statistics for the
evaluation of model performance.&quot; Journal of Geophysical Research
90(C5): 8995â9005, doi: 10.1029/jc090ic05p08995
</p>
<p>Willmott, C. J., Robeson, S. M., and Matsuura, K. &quot;A refined index of model
performance&quot;. International Journal of Climatology 32, pp 2088-2094, doi:
10.1002/joc.2419.
</p>


<h3>See Also</h3>

<p>Other agreement metrics: 
<code><a href="#topic+ww_agreement_coefficient">ww_agreement_coefficient</a>()</code>
</p>
<p>Other yardstick metrics: 
<code><a href="#topic+ww_agreement_coefficient">ww_agreement_coefficient</a>()</code>,
<code><a href="#topic+ww_global_geary_c">ww_global_geary_c</a>()</code>,
<code><a href="#topic+ww_global_moran_i">ww_global_moran_i</a>()</code>,
<code><a href="#topic+ww_local_geary_c">ww_local_geary_c</a>()</code>,
<code><a href="#topic+ww_local_getis_ord_g">ww_local_getis_ord_g</a>()</code>,
<code><a href="#topic+ww_local_moran_i">ww_local_moran_i</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(6, 8, 9, 10, 11, 14)
y &lt;- c(2, 3, 5, 5, 6, 8)

ww_willmott_d_vec(x, y)
ww_willmott_d1_vec(x, y)
ww_willmott_dr_vec(x, y)
ww_systematic_mse_vec(x, y)
ww_unsystematic_mse_vec(x, y)
ww_systematic_rmse_vec(x, y)
ww_unsystematic_rmse_vec(x, y)

example_df &lt;- data.frame(x = x, y = y)
ww_willmott_d(example_df, x, y)
ww_willmott_d1(example_df, x, y)
ww_willmott_dr(example_df, x, y)
ww_systematic_mse(example_df, x, y)
ww_unsystematic_mse(example_df, x, y)
ww_systematic_rmse(example_df, x, y)
ww_unsystematic_rmse(example_df, x, y)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
