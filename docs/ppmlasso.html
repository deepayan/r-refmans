<!DOCTYPE html><html><head><title>Help for package ppmlasso</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ppmlasso}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ppmlasso-package'><p>PPM-LASSO: Point process models with LASSO-type penalties</p></a></li>
<li><a href='#BlueMountains'><p>Blue Mountains eucalypt and environmental data.</p></a></li>
<li><a href='#diagnose-methods'><p>Methods for function <code>diagnose</code></p></a></li>
<li><a href='#diagnose.ppmlasso'><p>Create diagnostic plots for a fitted point process model.</p></a></li>
<li><a href='#envelope-methods'><p>Methods for function <code>envelope</code></p></a></li>
<li><a href='#envelope.ppmlasso'><p>Calculates simulation envelopes for goodness-of-fit</p></a></li>
<li><a href='#findRes'><p>Choose spatial resolution for analysis</p></a></li>
<li><a href='#getEnvVar'><p>Extract environmental data to presence locations</p></a></li>
<li><a href='#griddify'><p>Ensure that a geo-referenced matrix of environmental grids is rectangular</p></a></li>
<li><a href='#plotFit'><p>Plot the predicted intensity of a fitted <code>ppmlasso</code> model</p></a></li>
<li><a href='#plotPath'><p>Plot of the regularisation path of a <code>ppmlasso</code> model</p></a></li>
<li><a href='#pointInteractions'><p>Calculate point interactions for area-interaction models</p></a></li>
<li><a href='#ppmdat'><p>Prepare data for model fitting</p></a></li>
<li><a href='#ppmlasso'><p>Fit point process models with LASSO penalties</p></a></li>
<li><a href='#ppmlasso-class'><p>Class <code>"ppmlasso"</code></p></a></li>
<li><a href='#ppmlasso-internal'><p>Internal ppmlasso functions</p></a></li>
<li><a href='#predict-methods'><p>Methods for function <code>predict</code></p></a></li>
<li><a href='#predict.ppmlasso'><p>Prediction to new data from a fitted regularisation path</p></a></li>
<li><a href='#print-methods'><p>Methods for function <code>print</code></p></a></li>
<li><a href='#print.ppmlasso'><p>Print a fitted regularisation path</p></a></li>
<li><a href='#sampleQuad'><p>Generate regular grid of quadrature points with environmental data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Point Process Models with LASSO-Type Penalties</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-29</td>
</tr>
<tr>
<td>Author:</td>
<td>Ian Renner</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ian Renner &lt;Ian.Renner@newcastle.edu.au&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Toolkit for fitting point process models with sequences of LASSO penalties ("regularisation paths"), as described in Renner, I.W. and Warton, D.I. (2013) &lt;<a href="https://doi.org/10.1111%2Fj.1541-0420.2012.01824.x">doi:10.1111/j.1541-0420.2012.01824.x</a>&gt;. Regularisation paths of Poisson point process models or area-interaction models can be fitted with LASSO, adaptive LASSO or elastic net penalties. A number of criteria are available to judge the bias-variance tradeoff.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0), spatstat (&ge; 3.0-0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, data.table, lattice, stats, plyr, spatstat.explore,
spatstat.model, spatstat.geom</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-30 02:58:25 UTC; iwr478</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-31 23:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ppmlasso-package'>PPM-LASSO: Point process models with LASSO-type penalties</h2><span id='topic+ppmlasso-package'></span>

<h3>Description</h3>

<p>This package contains tools to fit point process models with sequences of LASSO penalties (&quot;regularisation paths&quot;). 
Regularisation paths of Poisson point process models or area-interaction models can be fitted with LASSO, 
adaptive LASSO or elastic net penalties. A number of criteria are available to judge the bias-variance tradeoff.</p>


<h3>Details</h3>

<p>The key functions in ppmlasso are as follows:
</p>
<p><b>Useful pre-analysis functions:</b>
</p>

<dl>
<dt><code><a href="#topic+findRes">findRes</a></code></dt><dd><p>Determine the optimal spatial resolution at which to perform analysis</p>
</dd>
<dt><code><a href="#topic+getEnvVar">getEnvVar</a></code></dt><dd><p>Interpolate environmental data to species presence locations</p>
</dd>
<dt><code><a href="#topic+griddify">griddify</a></code></dt><dd><p>Ensure a matrix of environmental data is on a rectangular grid</p>
</dd>
<dt><code><a href="#topic+ppmdat">ppmdat</a></code></dt><dd><p>Calculate observation weights and set up design matrix for fitting</p>
</dd>
<dt><code><a href="#topic+pointInteractions">pointInteractions</a></code></dt><dd><p>Calculate interpoint interactions for fitting area-interaction models</p>
</dd>
<dt><code><a href="#topic+sampleQuad">sampleQuad</a></code></dt><dd><p>Set up a regular grid of quadrature points</p>
</dd>
</dl>

<p><b>Creating regularisation paths of point process models:</b>
</p>

<dl>
<dt><code><a href="#topic+ppmlasso">ppmlasso</a></code></dt><dd><p>Fit a regularisation path of point process models</p>
</dd>
<dt><code><a href="#topic+plotFit">plotFit</a></code></dt><dd><p>Plot the fitted intensity of a <code>ppmlasso</code> object</p>
</dd>
<dt><code><a href="#topic+plotPath">plotPath</a></code></dt><dd><p>Plot the regularisation path of a <code>ppmlasso</code> object</p>
</dd>
<dt><code><a href="#topic+print.ppmlasso">print.ppmlasso</a></code></dt><dd><p>Print output from a <code>ppmlasso</code> object</p>
</dd>
<dt><code><a href="#topic+predict.ppmlasso">predict.ppmlasso</a></code></dt><dd><p>Make predictions from a fitted point process model to new data</p>
</dd>
</dl>

<p><b>Checking assumptions:</b>
</p>

<dl>
<dt><code><a href="#topic+diagnose.ppmlasso">diagnose.ppmlasso</a></code></dt><dd><p>Create diagnostic residual plots of <code>ppmlasso</code> object</p>
</dd>
<dt><code><a href="#topic+envelope.ppmlasso">envelope.ppmlasso</a></code></dt><dd><p>Create simulation envelope for goodness-of-fit checks on a <code>ppmlasso</code> object</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ian W. Renner
</p>
<p>Maintainer: Ian W. Renner &lt;Ian.Renner@newcastle.edu.au&gt;
</p>


<h3>References</h3>

<p>Renner, I.W. &amp; Warton, D.I. (2013). Equivalence of MAXENT and Poisson point process models for 
species distribution modeling in ecology <em>Biometrics</em> <b>69</b>, 274-281.
</p>
<p>Renner, I.W. et al (2015). Point process models for presence-only analysis. <em>Methods in Ecology and Evolution</em> <b>6</b>, 366-379.
</p>
<p>Renner, I.W., Warton, D.I., &amp; Hui, F.K.C. (2021). What is the effective sample size of a spatial point process? <em>Australian &amp; New Zealand Journal of Statistics</em> <b>63</b>, 144-158.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Fit a regularisation path of Poisson point process models
data(BlueMountains)
sub.env = BlueMountains$env[BlueMountains$env$Y &gt; 6270 &amp; BlueMountains$env$X &gt; 300,]
sub.euc = BlueMountains$eucalypt[BlueMountains$eucalypt$Y &gt; 6270 &amp; BlueMountains$eucalypt$X &gt; 300,]
ppm.form = ~ poly(FC, TMP_MIN, TMP_MAX, RAIN_ANN, degree = 2, raw = TRUE)
ppm.fit  = ppmlasso(ppm.form, sp.xy = sub.euc, env.grid = sub.env, sp.scale = 1, n.fits = 20,
writefile = FALSE)

# Fit a regularisation path of area-interaction models
data(BlueMountains)
ai.form  = ~ poly(FC, TMP_MIN, TMP_MAX, RAIN_ANN, degree = 2, raw = TRUE)
ai.fit   = ppmlasso(ai.form, sp.xy = sub.euc, env.grid = sub.env, sp.scale = 1, 
family = "area.inter", r = 2, availability = BlueMountains$availability, n.fits = 20,
writefile = FALSE)

# Print a ppmlasso object
print(ppm.fit, out = "model")

# Residual plot of a ppmlasso object
diagnose(ppm.fit, which = "smooth", type = "Pearson")

# Make predictions
pred.mu = predict(ppm.fit, newdata = sub.env)

# Plot the intensity from a fitted ppmlasso object
plotFit(ppm.fit)

# Plot the regularisation path from a fitted ppmlasso object
plotPath(ppm.fit)

</code></pre>

<hr>
<h2 id='BlueMountains'>Blue Mountains eucalypt and environmental data.</h2><span id='topic+BlueMountains'></span><span id='topic+eucalypt'></span><span id='topic+env'></span><span id='topic+availability'></span>

<h3>Description</h3>

<p>This data set contains the observed presence locations of a Sydney eucalypt (<code>eucalypt</code>), the values of four
environmental variables and two variables related to site accessibility throughout the region at a spatial
resolution of 500m (<code>env</code>), and a matrix indicating whether locations in the region are available to the species (<code>availability</code>).</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(BlueMountains)</code></pre>


<h3>Format</h3>

<p>A list with three objects:
</p>

<dl>
<dt>eucalypt</dt><dd><p>A data frame with a column <code>X</code> of UTM Easting coordinates (km) and a column <code>Y</code> of UTM Northing coordinates (km) of observed locations of a Sydney eucalypt</p>
</dd>
<dt>env</dt><dd><p>A data frame containing environmental data in the Blue Mountains region near Sydney</p>
</dd>
<dt>availability</dt><dd><p>A 301x201 matrix with UTM Northing and Easting locations stored in <code>dimnames</code> indicating whether locations are accessible or not</p>
</dd>
</dl>

<p>The data frame <code>env</code> contains the following environmental data:
</p>

<dl>
<dt>X</dt><dd><p>UTM Easting coordinates (km)</p>
</dd>
<dt>Y</dt><dd><p>UTM Northing coordinates (km)</p>
</dd>
<dt>FC</dt><dd><p>Number of fires since 1943</p>
</dd>
<dt>D_MAIN_RDS</dt><dd><p>Distance from the nearest main road (m)</p>
</dd>
<dt>D_URBAN</dt><dd><p>Distance from the nearest urban area (m)</p>
</dd>
<dt>RAIN_ANN</dt><dd><p>Average annual rainfall (mm)</p>
</dd>
<dt>TMP_MAX</dt><dd><p>Average maximum temperature (degrees Celsius)</p>
</dd>
<dt>TMP_MIN</dt><dd><p>Average minimum temperature (degrees Celsius)</p>
</dd>
</dl>


<hr>
<h2 id='diagnose-methods'>Methods for function <code>diagnose</code></h2><span id='topic+diagnose-methods'></span><span id='topic+diagnose+2Cppm-method'></span><span id='topic+diagnose+2Cppmlasso-method'></span>

<h3>Description</h3>

<p>Methods for function <code><a href="#topic+diagnose">diagnose</a></code>
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(fit = "ppm")</code></dt><dd>
<p>Creates residual plots for a <code>ppm</code> object. See the help function for <code>diagnose.ppm</code> in <code>spatstat</code> for more details.
</p>
</dd>
<dt><code>signature(fit = "ppmlasso")</code></dt><dd>
<p>Creates residual plots for a <code>ppmlasso</code> object. See the help function for <code>diagnose.ppm</code> in <code>spatstat</code> for more details.
</p>
</dd>
</dl>

<hr>
<h2 id='diagnose.ppmlasso'>Create diagnostic plots for a fitted point process model.</h2><span id='topic+diagnose.ppmlasso'></span><span id='topic+diagnose'></span>

<h3>Description</h3>

<p>This function is analogous to the <code>diagnose.ppm</code> function of the <code>spatstat</code> package.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ppmlasso'
diagnose(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagnose.ppmlasso_+3A_object">object</code></td>
<td>
<p>A fitted regularisation path of point process models. The diagnostic plots will be created for the model that optimises the given criterion.</p>
</td></tr>
<tr><td><code id="diagnose.ppmlasso_+3A_...">...</code></td>
<td>
<p>Other arguments for producing diagnostic plots, as given by the <code>diagnose.ppm</code> function of the <code>spatstat</code> package.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the help file for <code>diagnose.ppm</code> in the <code>spatstat</code> package for further details of diagnostic plots.</p>


<h3>Author(s)</h3>

<p>Ian W. Renner</p>


<h3>References</h3>

<p>Baddeley, A.J. &amp; Turner, R. (2005). Spatstat: an R package for analyzing spatial
point patterns. <em>Journal of Statistical Software</em> <b>12</b>, 1-42.</p>


<h3>See Also</h3>

<p><code><a href="#topic+envelope.ppmlasso">envelope.ppmlasso</a></code>, for other goodness-of-fit functions inherited from <code>spatstat</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(BlueMountains)
sub.env = BlueMountains$env[BlueMountains$env$Y &gt; 6270 &amp; BlueMountains$env$X &gt; 300,]
sub.euc = BlueMountains$eucalypt[BlueMountains$eucalypt$Y &gt; 6270 &amp; BlueMountains$eucalypt$X &gt; 300,]
ppm.form = ~poly(FC, TMP_MIN, TMP_MAX, RAIN_ANN, degree = 2) + poly(D_MAIN_RDS, D_URBAN, degree = 2)
ppm.fit  = ppmlasso(ppm.form, sp.xy = sub.euc, env.grid = sub.env, sp.scale = 1, n.fits = 20,
writefile = FALSE)
diagnose(ppm.fit, which = "smooth", type = "Pearson")
</code></pre>

<hr>
<h2 id='envelope-methods'>Methods for function <code>envelope</code></h2><span id='topic+envelope-methods'></span><span id='topic+envelope+2Cppmlasso-method'></span>

<h3>Description</h3>

<p>Methods for function <code><a href="boot.html#topic+envelope">envelope</a></code>
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(Y = "ppmlasso")</code></dt><dd>
<p>Creates Monte Carlo simulation envelopes for a given function for a <code>ppmlasso</code> object. See the help function for <code>envelope</code> in <code>spatstat</code> for more details.
</p>
</dd>
</dl>

<hr>
<h2 id='envelope.ppmlasso'>Calculates simulation envelopes for goodness-of-fit</h2><span id='topic+envelope.ppmlasso'></span>

<h3>Description</h3>

<p>This function is analogous to the <code>envelope</code> function of the <code>spatstat</code> package.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ppmlasso'
envelope(Y, fun = Kest, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="envelope.ppmlasso_+3A_y">Y</code></td>
<td>
<p>A fitted regularisation path of point process models. The simulation envelopes will be calculated for the model that optimises the given criterion.</p>
</td></tr>
<tr><td><code id="envelope.ppmlasso_+3A_fun">fun</code></td>
<td>
<p>The summary function to be computed for the given point process model. See the help file for the <code>envelope</code> function of the <code>spatstat</code> package for more details.</p>
</td></tr>
<tr><td><code id="envelope.ppmlasso_+3A_...">...</code></td>
<td>
<p>Other arguments for producing diagnostic plots, as given by the <code>envelope</code> function of the <code>spatstat</code> package.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the help file for <code>envelope</code> in the <code>spatstat</code> package for further details of simulation envelopes.</p>


<h3>Author(s)</h3>

<p>Ian W. Renner</p>


<h3>References</h3>

<p>Baddeley, A.J. &amp; Turner, R. (2005). Spatstat: an R package for analyzing spatial
point patterns. <em>Journal of Statistical Software</em> <b>12</b>, 1-42.</p>


<h3>See Also</h3>

<p><code><a href="#topic+diagnose.ppmlasso">diagnose.ppmlasso</a></code>, for residual plots inherited from <code>spatstat</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(BlueMountains)
sub.env = BlueMountains$env[BlueMountains$env$Y &gt; 6270 &amp; BlueMountains$env$X &gt; 300,]
sub.euc = BlueMountains$eucalypt[BlueMountains$eucalypt$Y &gt; 6270 &amp; BlueMountains$eucalypt$X &gt; 300,]
ppm.form = ~poly(FC, TMP_MIN, TMP_MAX, RAIN_ANN, degree = 2) + poly(D_MAIN_RDS, D_URBAN, degree = 2)
ppm.fit  = ppmlasso(ppm.form, sp.xy = sub.euc, env.grid = sub.env, sp.scale = 1, n.fits = 20,
writefile = FALSE)
envelope(ppm.fit, Kinhom, nsim = 20)
</code></pre>

<hr>
<h2 id='findRes'>Choose spatial resolution for analysis</h2><span id='topic+findRes'></span>

<h3>Description</h3>

<p>This function produces a plot to choose the optimal spatial resolution for
analysis. A point process model is calculated for each nominated spatial resolution and the
log-likelihood of all fitted models are plotted against the spatial resolutions.</p>


<h3>Usage</h3>

<pre><code class='language-R'>findRes(scales, lambda = 0, coord = c("X", "Y"), sp.xy, env.grid, 
formula, tol = 0.01, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findRes_+3A_scales">scales</code></td>
<td>
<p>A vector of spatial resolutions for which to produce the plot.</p>
</td></tr>
<tr><td><code id="findRes_+3A_lambda">lambda</code></td>
<td>
<p>The penalty for each fitted spatial resolution. This should be a
single value such that only one point process model is computed for each spatial resolution.</p>
</td></tr>
<tr><td><code id="findRes_+3A_coord">coord</code></td>
<td>
<p>A vector containing the names of the longitude and latitude coordinates,
used by <code><a href="#topic+getEnvVar">getEnvVar</a></code>.</p>
</td></tr>
<tr><td><code id="findRes_+3A_sp.xy">sp.xy</code></td>
<td>
<p>A matrix of species locations containing at least one column representing
longitude and one column representing latitude, as in <code><a href="#topic+ppmlasso">ppmlasso</a></code>.</p>
</td></tr>
<tr><td><code id="findRes_+3A_env.grid">env.grid</code></td>
<td>
<p>The geo-referenced matrix of environmental grids, as in <code><a href="#topic+ppmlasso">ppmlasso</a></code>.</p>
</td></tr>
<tr><td><code id="findRes_+3A_formula">formula</code></td>
<td>
<p>The formula of the fitted model, as in <code><a href="#topic+ppmlasso">ppmlasso</a></code>.</p>
</td></tr>
<tr><td><code id="findRes_+3A_tol">tol</code></td>
<td>
<p>An optional argument to specify the tolerance level of coordinate error passed to an internal call to the <code><a href="#topic+griddify">griddify</a></code> function, set to 0.01 by default.</p>
</td></tr>
<tr><td><code id="findRes_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+ppmlasso">ppmlasso</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function produces a plot which can be used to judge an optimal spatial resolution for analysis. As the spatial resolution gets finer, the log-likelihood tends to stabilise to a constant value. The largest spatial resolution at which the log-likelihood appears to stabilise may be considered optimal for model fitting.</p>


<h3>Value</h3>

<p>A plot of log-likelihood versus spatial resolution.</p>


<h3>Author(s)</h3>

<p>Ian W. Renner</p>


<h3>References</h3>

<p>Renner, I.W. et al (2015). Point process models for presence-only analysis. <em>Methods in Ecology and Evolution</em> <b>6</b>, 366-379.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(BlueMountains)
sub.env = BlueMountains$env[BlueMountains$env$Y &gt; 6270 &amp; BlueMountains$env$X &gt; 300,]
sub.euc = BlueMountains$eucalypt[BlueMountains$eucalypt$Y &gt; 6270 &amp; BlueMountains$eucalypt$X &gt; 300,]
scales = c(0.5, 1, 2, 4, 8, 16)
ppm.form = ~ poly(FC, TMP_MIN, TMP_MAX, RAIN_ANN, degree = 2)
findRes(scales, formula = ppm.form, sp.xy = sub.euc, env.grid = sub.env)
</code></pre>

<hr>
<h2 id='getEnvVar'>Extract environmental data to presence locations</h2><span id='topic+getEnvVar'></span>

<h3>Description</h3>

<p>Given a matrix of quadrature points and a list of species presences, this
function extracts environmental data to presence locations using bilinear interpolation.</p>


<h3>Usage</h3>

<pre><code class='language-R'>getEnvVar(sp.xy, env.grid, env.scale, coord = c("X", "Y"), envfilename = "SpEnvData", 
tol = 0.01, writefile = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getEnvVar_+3A_sp.xy">sp.xy</code></td>
<td>
<p>A matrix of species locations containing at least one column representing
longitude and one column representing latitude.</p>
</td></tr>
<tr><td><code id="getEnvVar_+3A_env.grid">env.grid</code></td>
<td>
<p>The geo-referenced matrix of environmental grids.</p>
</td></tr>
<tr><td><code id="getEnvVar_+3A_env.scale">env.scale</code></td>
<td>
<p>The spatial resolution of the quadrature scheme from which the 
environmental data is extracted.</p>
</td></tr>
<tr><td><code id="getEnvVar_+3A_coord">coord</code></td>
<td>
<p>A vector containing the names of the longitude and latitude coordinates,
as in <code><a href="#topic+sampleQuad">sampleQuad</a></code>.</p>
</td></tr>
<tr><td><code id="getEnvVar_+3A_envfilename">envfilename</code></td>
<td>
<p>An optional argument containing the name of the saved file. Setting
<code>envfilename =</code> <code>"SpEnvData"</code> will save a matrix <code>sp.dat</code> containing the species presence
locations and the interpolated environmental data to the file <code>"SpEnvData.RData"</code>.</p>
</td></tr>
<tr><td><code id="getEnvVar_+3A_tol">tol</code></td>
<td>
<p>An optional argument to specify the tolerance level of coordinate error passed to an internal call to the <code><a href="#topic+griddify">griddify</a></code> function, set to 0.01 by default.</p>
</td></tr>
<tr><td><code id="getEnvVar_+3A_writefile">writefile</code></td>
<td>
<p>A logical argument to determine whether the output should be written to a file or not. If <code>TRUE</code> (the default), the output will be saved with the file name as described in the <code>envfilename</code> argument.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At a given species location with coordinates <code class="reqn">(x, y)</code>, the interpolated value of the
environmental variable <code class="reqn">z</code> is calculated as a weighted average of <code class="reqn">z</code> at four reference
quadrature points <code class="reqn">(x^{(1)}, y^{(1)})</code>, <code class="reqn">(x^{(1)}, y^{(2)})</code>, <code class="reqn">(x^{(2)}, y^{(1)})</code> and <code class="reqn">(x^{(2)}, y^{(2)})</code>
that form a square of nominated side length <code>env.scale</code> surrounding <code class="reqn">(x, y)</code>.</p>


<h3>Value</h3>

<p>A matrix containing locations of species presences in the first two columns
and the interpolated environmental data in the remaining columns.</p>


<h3>Author(s)</h3>

<p>Ian W. Renner</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(BlueMountains)
species.env = getEnvVar(BlueMountains$eucalypt, env.grid = BlueMountains$env, env.scale = 0.5,
envfilename = NA, writefile = FALSE)
</code></pre>

<hr>
<h2 id='griddify'>Ensure that a geo-referenced matrix of environmental grids is rectangular</h2><span id='topic+griddify'></span>

<h3>Description</h3>

<p>This function ensures that the coordinates of the supplied geo-referenced matrix of environmental grids constitutes a rectangular grid.</p>


<h3>Usage</h3>

<pre><code class='language-R'>griddify(envframe, tol = 0.01, coord = c("X", "Y"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="griddify_+3A_envframe">envframe</code></td>
<td>
<p>The geo-referenced matrix of environmental grids.</p>
</td></tr>
<tr><td><code id="griddify_+3A_tol">tol</code></td>
<td>
<p>The tolerance level within which to correct coordinate errors.</p>
</td></tr>
<tr><td><code id="griddify_+3A_coord">coord</code></td>
<td>
<p>A vector containing the names of the longitude and latitude coordinates.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions in the <code>ppmlasso</code> package require a set of quadrature points along a rectangular grid. At times a set of quadrature points with a desired spatial resolution of <code class="reqn">x_\delta \times y_\delta</code> will have some minor machine error in some coordinates such that the coordinates as supplied do not consistute a rectangular grid. The <code>griddify</code> function corrects this error as follows:
</p>
<p>Let <code class="reqn">\{x_1, x_2, \ldots, x_n\}</code> and <code class="reqn">\{y_1, y_2, \ldots, y_n\}</code> be the supplied coordinates contained in <code>envframe</code>. The function first determines the spatial resolution <code class="reqn">x_\delta \times y_\delta</code> based on the median of the differences in the unique values of <code class="reqn">x_i</code> and <code class="reqn">y_i</code> as well as the coordinates of a rectangular grid with this spatial resolution <code class="reqn">\{x^{grid}_1, x^{grid}_2, \ldots, x^{grid}_n\}</code> and <code class="reqn">\{y^{grid}_1, y^{grid}_2, \ldots, y^{grid}_n\}</code>. Given the tolerance <code class="reqn">\epsilon</code> supplied to <code>tol</code>, any coordinate <code class="reqn">x_i</code> for which <code class="reqn">0 &lt; \left|x_i - x^{grid}_i\right| \leq \epsilon \times x_\delta</code> will be adjusted to <code class="reqn">x^{grid}_i</code>. Likewise, any coordinate <code class="reqn">y_i</code> for which <code class="reqn">0 &lt; \left|y_i - y^{grid}_i\right| \leq \epsilon \times y_\delta</code> will be adjusted to <code class="reqn">y^{grid}_i</code>.
</p>
<p>Any environmental variables contained in <code>envframe</code> are left unchanged.
</p>


<h3>Value</h3>

<p>A data frame containing the coordinates on a rectangular grid as well as any environmental variables left unchanged.</p>


<h3>Author(s)</h3>

<p>Ian W. Renner</p>


<h3>Examples</h3>

<pre><code class='language-R'>X = seq(0, 5, 1)
Y = seq(1, 11, 2)
XY = expand.grid(X, Y) # generate 1 x 2 rectangular grid
names(XY) = c("X", "Y")
#move some coordinates off of rectangular grid
XY$X[1] = XY$X[1] - 0.01
XY$Y[1] = XY$Y[1] - 0.01
XY$X[7] = XY$X[7] + 0.01
XY$Y[7] = XY$Y[7] + 0.01

#generate environmental variables
XY$V1 = 0.1*XY$X + 0.2*XY$Y + rnorm(36, 0, 1)
XY$V2 = -0.2*XY$X + 0.1*XY$Y + 0.05*XY$X*XY$Y + rnorm(36, 0, 5)

XY_grid = griddify(XY)
</code></pre>

<hr>
<h2 id='plotFit'>Plot the predicted intensity of a fitted <code>ppmlasso</code> model</h2><span id='topic+plotFit'></span>

<h3>Description</h3>

<p>This function produces a levelplot of the predicted intensity from a fitted <code>ppmlasso</code> model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotFit(fit, pred.data = data.frame(X = fit$x[fit$pres == 0], 
Y = fit$y[fit$pres == 0], 1, scale(fit$data[fit$pres == 0, -1], 
center = -fit$s.means/fit$s.sds, scale = 1/fit$s.sds)), 
coord = c("X", "Y"), asp = "iso", ylab = "", xlab = "", 
col.regions = heat.colors(1024)[900:1], cuts = length(col.regions), 
cex = 1.4, main.text = paste(toupper(fit$criterion), "fit"), cex.color = 1.4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotFit_+3A_fit">fit</code></td>
<td>
<p>A fitted <code>ppmlasso</code> object.</p>
</td></tr>
<tr><td><code id="plotFit_+3A_pred.data">pred.data</code></td>
<td>
<p>A data frame which defines the coordinates and the environmental variables for which the predicted intensity will be calculated. By default, this uses the coordinates and environmental variables from the object supplied to the <code>fit</code> argument.</p>
</td></tr>
<tr><td><code id="plotFit_+3A_coord">coord</code></td>
<td>
<p>A vector containing the names of the longitude and latitude coordinates,
as in <code><a href="#topic+sampleQuad">sampleQuad</a></code>.</p>
</td></tr>
<tr><td><code id="plotFit_+3A_asp">asp</code></td>
<td>
<p>Aspect of the plot, with &quot;iso&quot; as default. See the documentation for the <code>levelplot</code> function of the <code>lattice</code> pacakge for more details.</p>
</td></tr>
<tr><td><code id="plotFit_+3A_ylab">ylab</code></td>
<td>
<p>Label for the <code class="reqn">y</code>-axis. Blank by default.</p>
</td></tr>
<tr><td><code id="plotFit_+3A_xlab">xlab</code></td>
<td>
<p>Label for the <code class="reqn">x</code>-axis. Blank by default</p>
</td></tr>
<tr><td><code id="plotFit_+3A_col.regions">col.regions</code></td>
<td>
<p>A vector of colours to define the intensity gradient. See the documentation for the <code>levelplot</code> function of the <code>lattice</code> pacakge for more details.</p>
</td></tr>
<tr><td><code id="plotFit_+3A_cuts">cuts</code></td>
<td>
<p>The number of levels the color gradient for the intensity surface is divided into. See the documentation for the <code>levelplot</code> function of the <code>lattice</code> pacakge for more details.</p>
</td></tr>
<tr><td><code id="plotFit_+3A_cex">cex</code></td>
<td>
<p>Character size for axis labels.</p>
</td></tr>
<tr><td><code id="plotFit_+3A_main.text">main.text</code></td>
<td>
<p>Title of the plot.</p>
</td></tr> 
<tr><td><code id="plotFit_+3A_cex.color">cex.color</code></td>
<td>
<p>Character size for the colorkey labels.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will compute the predicted intensity of a fitted <code>ppmlasso</code> object using the model within the regularisation path which optimises the criterion specified in the call to <code><a href="#topic+ppmlasso">ppmlasso</a></code>.</p>


<h3>Author(s)</h3>

<p>Ian W. Renner</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(BlueMountains)
sub.env = BlueMountains$env[BlueMountains$env$Y &gt; 6270 &amp; BlueMountains$env$X &gt; 300,]
sub.euc = BlueMountains$eucalypt[BlueMountains$eucalypt$Y &gt; 6270 &amp; BlueMountains$eucalypt$X &gt; 300,]
ppm.form = ~poly(FC, TMP_MIN, TMP_MAX, RAIN_ANN, degree = 2) + poly(D_MAIN_RDS, D_URBAN, degree = 2)
ppm.fit  = ppmlasso(ppm.form, sp.xy = sub.euc, env.grid = sub.env, sp.scale = 1, n.fits = 20,
writefile = FALSE)
plotFit(ppm.fit)
</code></pre>

<hr>
<h2 id='plotPath'>Plot of the regularisation path of a <code>ppmlasso</code> model</h2><span id='topic+plotPath'></span>

<h3>Description</h3>

<p>This function produces a trace plot of the coefficient estimates of a fitted <code>ppmlasso</code> object and identifies the models which optimise the various penalisation criteria.</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPath(fit, colors = c("gold", "green3", "blue", "brown", "pink"), logX = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPath_+3A_fit">fit</code></td>
<td>
<p>A fitted <code>ppmlasso</code> object.</p>
</td></tr>
<tr><td><code id="plotPath_+3A_colors">colors</code></td>
<td>
<p>A vector of colours for each criterion: <code>"aic"</code>, <code>"bic"</code>, <code>"hqc"</code>, <code>"gcv"</code>, and <code>"nlgcv"</code>.</p>
</td></tr>
<tr><td><code id="plotPath_+3A_logx">logX</code></td>
<td>
<p>A logical argument to indicate whether the plot should utilise a logarithmic scale on the x-axis (the default) or not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A fitted <code>ppmlasso</code> object contains a matrix called <code>betas</code> which stores the coefficient estimates of each of the <code>n.fits</code> models fitted. This function produces a traceplot of these coefficient estimates for each environmental variable and highlights the models which optimise each of the penalisation criteria.</p>


<h3>Author(s)</h3>

<p>Ian W. Renner</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(BlueMountains)
sub.env = BlueMountains$env[BlueMountains$env$Y &gt; 6270 &amp; BlueMountains$env$X &gt; 300,]
sub.euc = BlueMountains$eucalypt[BlueMountains$eucalypt$Y &gt; 6270 &amp; BlueMountains$eucalypt$X &gt; 300,]
ppm.form = ~poly(FC, TMP_MIN, TMP_MAX, RAIN_ANN, degree = 2) + poly(D_MAIN_RDS, D_URBAN, degree = 2)
ppm.fit  = ppmlasso(ppm.form, sp.xy = sub.euc, env.grid = sub.env, sp.scale = 1, n.fits = 20,
writefile = FALSE)
plotPath(ppm.fit)
</code></pre>

<hr>
<h2 id='pointInteractions'>Calculate point interactions for area-interaction models</h2><span id='topic+pointInteractions'></span>

<h3>Description</h3>

<p>This function calculates point interactions at presence locations and
quadrature points required for fitting a regularisation path of area-interaction
models.</p>


<h3>Usage</h3>

<pre><code class='language-R'>pointInteractions(dat.ppm, r, availability = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pointInteractions_+3A_dat.ppm">dat.ppm</code></td>
<td>
<p>A design matrix generated using the <code><a href="#topic+ppmdat">ppmdat</a></code> function.</p>
</td></tr>
<tr><td><code id="pointInteractions_+3A_r">r</code></td>
<td>
<p>The radius of point interactions.</p>
</td></tr>
<tr><td><code id="pointInteractions_+3A_availability">availability</code></td>
<td>
<p>An optional binary matrix used in calculating point interactions indicating
whether locations are available (<code>availability = 1</code>) or not (<code>availability = 0</code>). 
If no such matrix is provided, <code>availability</code> is automatically generated with all
values set to <code>1</code> at a special resolution of half of <code>r</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Theoretically, the point interaction <code class="reqn">t(y)</code> at a point <code class="reqn">y</code> is calculated
as the proportion of available area in a circular region <code class="reqn">Y</code> or radius <code class="reqn">r</code> centred
at <code class="reqn">y</code> that overlaps with circles of radius <code class="reqn">r</code> centred at other presence locations
(Baddeley &amp; Turner, 2005).
</p>
<p>This function discretises the study region at the same spatial resolution
as <code>availability</code> by defining the matrix <code>occupied</code>, a fine grid of locations
spanning the study region initialised to zero. The values of <code>occupied</code> within a 
distance of <code>r</code> of each presence location are then augmented by <code>1</code>, such that
<code>occupied</code> then contains the total number of presence locations with which each
grid location interacts. To prevent unavailable areas from being included in the
calculation of point interactions, the values of <code>occupied</code> at grid locations for which
<code>availability = 0</code> are set to zero.
</p>
<p><code class="reqn">t(y)</code> is then estimated as the proportion of available grid locations within <code class="reqn">Y</code>
that overlap circular regions around other presence locations.
</p>
<p>The availability matrix is particularly useful for regions that have inaccessible areas
(<strong>e.g.</strong> due to the presence of ocean or urban areas).
</p>
<p>Finer resolutions of the <code>availability</code> matrix will yield more precise estimates but
at a cost of greater computation time.</p>


<h3>Value</h3>

<p>A vector of point interactions corresponding to the locations contained in the
<code>dat.ppm</code> argument.</p>


<h3>Author(s)</h3>

<p>Ian W. Renner</p>


<h3>References</h3>

<p>Baddeley, A.J. &amp; Turner, R. (2005). Spatstat: an <code>R</code> package for analyzing spatial
point patterns. <em>Journal of Statistical Software</em> <b>12</b>, 1-42.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppmlasso">ppmlasso</a></code> for fitting a regularisation path of area-interaction models
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(BlueMountains)
species.ppm = ppmdat(sp.xy = BlueMountains$eucalypt, back.xy = BlueMountains$env, 
sp.scale = 1, datfilename = NA, writefile = FALSE) # generate design matrix
species.int = pointInteractions(species.ppm, 2, BlueMountains$availability)
</code></pre>

<hr>
<h2 id='ppmdat'>Prepare data for model fitting</h2><span id='topic+ppmdat'></span>

<h3>Description</h3>

<p>This function prepares the data for model fitting. In particular, it
determines observation weights and sets up the design matrix required for fitting
a regularisation path.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ppmdat(sp.xy, sp.scale, back.xy, coord = c("X","Y"), sp.dat = getEnvVar(sp.xy = sp.xy, 
env.scale = sp.scale, env.grid = back.xy, coord = coord, writefile = writefile), 
sp.file = NA, quad.file = NA, datfilename = "PPMDat", writefile = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ppmdat_+3A_sp.xy">sp.xy</code></td>
<td>
<p>A matrix of species locations containing at least one column representing
longitude and one column representing latitude.</p>
</td></tr>
<tr><td><code id="ppmdat_+3A_sp.scale">sp.scale</code></td>
<td>
<p>The spatial resolution at which to sample quadrature points.</p>
</td></tr>
<tr><td><code id="ppmdat_+3A_back.xy">back.xy</code></td>
<td>
<p>The geo-referenced matrix of environmental grids.</p>
</td></tr>
<tr><td><code id="ppmdat_+3A_coord">coord</code></td>
<td>
<p>A vector containing the names of the longitude and latitude coordinates, as
in <code><a href="#topic+sampleQuad">sampleQuad</a></code>.</p>
</td></tr>
<tr><td><code id="ppmdat_+3A_sp.dat">sp.dat</code></td>
<td>
<p>A matrix of species presence locations and the corresponding environmental
data, as generated by <code><a href="#topic+getEnvVar">getEnvVar</a></code>.</p>
</td></tr>
<tr><td><code id="ppmdat_+3A_sp.file">sp.file</code></td>
<td>
<p>The name of a saved file containing a matrix of species presence locations 
and the corresponding environmental data, as generated by <code><a href="#topic+getEnvVar">getEnvVar</a></code>.</p>
</td></tr>
<tr><td><code id="ppmdat_+3A_quad.file">quad.file</code></td>
<td>
<p>The name of a fie containing the quadrature points created from the
<code><a href="#topic+sampleQuad">sampleQuad</a></code> function.</p>
</td></tr>
<tr><td><code id="ppmdat_+3A_datfilename">datfilename</code></td>
<td>
<p>An optional argument containing the name of the saved file. Setting
<code>datfilename =</code> <code>"PPMDat"</code> will save a matrix <code>dat.ppm</code> containing the species presence
locations and quadrature points, the environmental data, as well as an indicator for whether the locations correspond to presence locations or quadrature points and the corresponding quadrature weights to the file <code>"PPMDat.RData"</code>.</p>
</td></tr>
<tr><td><code id="ppmdat_+3A_writefile">writefile</code></td>
<td>
<p>A logical argument to determine whether the output should be written to a file or not. If <code>TRUE</code> (the default), the output will be saved with the file name as described in the <code>datfilename</code> argument.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will call the <code><a href="#topic+sampleQuad">sampleQuad</a></code> and <code><a href="#topic+getEnvVar">getEnvVar</a></code>
functions to generate a quadrature scheme and interpolate environmental data to presence
locations. Alternatively, the quadrature scheme may be directly supplied to the
<code>quad.file</code> argument, and the matrix of presence locations and associated environmental
data may be directly supplied to either the <code>sp.dat</code> argument (as an object in the
workspace) or to the <code>sp.file</code> argument (as the name of a saved file containing this
matrix).</p>


<h3>Value</h3>

<p>A matrix <code>dat.ppm</code> with columns representing the latitude and longitude of presence
locations and quadrature points along with the associated environmental data, as well as
a column <code>Pres</code> indicating whether either point corresponds to a presence location or
a quadrature point, and a column <code>wt</code> of observation weights.</p>


<h3>Author(s)</h3>

<p>Ian W. Renner</p>


<h3>See Also</h3>

<p><code><a href="#topic+sampleQuad">sampleQuad</a></code> for generating a regular grid of quadrature points.
</p>
<p><code><a href="#topic+getEnvVar">getEnvVar</a></code> for interpolating environmental data to species presence locations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Do not run because of NOTE Examples with CPU time &gt; 2.5 times elapsed time
#data(BlueMountains)
#species.ppm = ppmdat(sp.xy = BlueMountains$eucalypt, back.xy = BlueMountains$env, 
#sp.scale = 1, datfilename = NA, writefile = FALSE)
</code></pre>

<hr>
<h2 id='ppmlasso'>Fit point process models with LASSO penalties</h2><span id='topic+ppmlasso'></span>

<h3>Description</h3>

<p>The ppmlasso function fits point process models (either Poisson or area-interaction
models) with a sequence of LASSO, adaptive LASSO or elastic net penalties (a &quot;regularisation path&quot;).</p>


<h3>Usage</h3>

<pre><code class='language-R'>ppmlasso(formula, sp.xy, env.grid, sp.scale, coord = c("X", "Y"), 
data = ppmdat(sp.xy = sp.xy, sp.scale = sp.scale, back.xy = env.grid, coord = c("X","Y"),
sp.file = NA, quad.file = NA, datfilename = "PPMDat", writefile = writefile), lamb = NA,
n.fits = 200, ob.wt = NA, criterion = "bic", alpha = 1, family = "poisson", tol = 1.e-9, 
gamma = 0, init.coef = NA, mu.min = 1.e-16, mu.max = 1/mu.min, r = NA, interactions = NA, 
availability = NA, max.it = 25, min.lamb = -10, standardise = TRUE, n.blocks = NA, 
block.size = sp.scale*100, seed = 1, writefile = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ppmlasso_+3A_formula">formula</code></td>
<td>
<p>The formula of the fitted model. For a point process model, the correct form is <code>~ variables</code>.</p>
</td></tr>
<tr><td><code id="ppmlasso_+3A_sp.xy">sp.xy</code></td>
<td>
<p>A matrix of species locations containing at least one column representing
longitude and one column representing latitude. Environmental variables are
interpolated to the locations of <code>sp.xy</code> using the <code><a href="#topic+getEnvVar">getEnvVar</a></code> function, unless the
<code>data</code> argument is supplied.</p>
</td></tr>
<tr><td><code id="ppmlasso_+3A_env.grid">env.grid</code></td>
<td>
<p>The geo-referenced matrix of environmental grids. This matrix is used to
generate quadrature points using the <code><a href="#topic+sampleQuad">sampleQuad</a></code> function, interpolate environmental
data to the species locations of <code>sp.xy</code> using the <code><a href="#topic+getEnvVar">getEnvVar</a></code> function,
and calculate observation weights using the <code><a href="#topic+ppmdat">ppmdat</a></code> function, unless the <code>data</code>
argument is supplied. This creates a data matrix <code>data</code> which provides the
variables for the <code>formula</code> argument.</p>
</td></tr>
<tr><td><code id="ppmlasso_+3A_sp.scale">sp.scale</code></td>
<td>
<p>The spatial resolution at which to define the regular grid of quadrature
points. <code><a href="#topic+sampleQuad">sampleQuad</a></code> will subsample from the rows of <code>data</code> that coincide with
a regular grid at a resolution of <code>sp.scale</code>.</p>
</td></tr>
<tr><td><code id="ppmlasso_+3A_coord">coord</code></td>
<td>
<p>A vector containing the names of the longitude and latitude coordinates.</p>
</td></tr>
<tr><td><code id="ppmlasso_+3A_data">data</code></td>
<td>
<p>An optional data matrix generated from the <code><a href="#topic+ppmdat">ppmdat</a></code> function. Supplying a
matrix to <code>data</code> is an alternative way of providing the environmental variables
used in the <code>formula</code> argument, instead of specifying <code>sp.xy</code> and <code>env.grid</code>.</p>
</td></tr>
<tr><td><code id="ppmlasso_+3A_lamb">lamb</code></td>
<td>
<p>A vector of penalty values that will be used to create the regularisation path.
If <code>lamb = NA</code>, the penalty values are automatically generated from the
<code>data</code> and the <code>n.fits</code> argument.</p>
</td></tr>
<tr><td><code id="ppmlasso_+3A_n.fits">n.fits</code></td>
<td>
<p>The number of models fitted in the regularisation path. If <code>lamb = NA</code>, the
<code>n.fits</code> penalty values will be equally spaced on a logarithmic scale from <code class="reqn">e^{-10}</code>
to <code class="reqn">\lambda_{max}</code>, the smallest penalty that shrinks all parameter coefficients to zero.</p>
</td></tr>
<tr><td><code id="ppmlasso_+3A_ob.wt">ob.wt</code></td>
<td>
<p>Quadrature weights, usually inherited from the <code><a href="#topic+ppmdat">ppmdat</a></code> function.</p>
</td></tr>
<tr><td><code id="ppmlasso_+3A_criterion">criterion</code></td>
<td>
<p>The penalisation criteria to be optimised by the regularisation path. The
options include <code>"aic"</code>, <code>"bic"</code>, <code>"blockCV"</code>, <code>"hqc"</code>, <code>"gcv"</code>, <code>"nlgcv"</code> and <code>"msi"</code>.</p>
</td></tr>
<tr><td><code id="ppmlasso_+3A_alpha">alpha</code></td>
<td>
<p>The elastic net parameter. The form of the penalty is </p>
<p style="text-align: center;"><code class="reqn">\alpha*\lambda*\sum_{j = 1}^p |\beta_j| + (1 - \alpha)*\lambda*\sum_{j = 1}^p (\beta_j)^2.</code>
</p>
<p> The default value <code>alpha = 1</code> corresponds to a LASSO penalty,
while <code>alpha = 0</code> corresponds to a ridge regression penalty.</p>
</td></tr>
<tr><td><code id="ppmlasso_+3A_family">family</code></td>
<td>
<p>The family of models to be fitted &ndash; <code>family = "poisson"</code> for Poisson point process models
or <code>family = "area.inter"</code> for area-interaction models.</p>
</td></tr>
<tr><td><code id="ppmlasso_+3A_tol">tol</code></td>
<td>
<p>The convergence threshold for the descent algorithm. The algorithm continues
for a maximum of <code>max.it</code> iterations until the difference in likelihood between
successive fits falls below <code>tol</code>.</p>
</td></tr>
<tr><td><code id="ppmlasso_+3A_gamma">gamma</code></td>
<td>
<p>The exponent of the adaptive weights for the adaptive LASSO penalty. The
default value <code>gamma = 0</code> corresponds to a normal LASSO penalty.</p>
</td></tr>
<tr><td><code id="ppmlasso_+3A_init.coef">init.coef</code></td>
<td>
<p>The initial coefficients used for an adaptive LASSO penalty.</p>
</td></tr>
<tr><td><code id="ppmlasso_+3A_mu.min">mu.min</code></td>
<td>
<p>The threshold for small fitted values. Any fitted value less than the threshold
is set to <code>mu.min</code>.</p>
</td></tr>
<tr><td><code id="ppmlasso_+3A_mu.max">mu.max</code></td>
<td>
<p>The threshold for large fitted values. Any fitted value larger than the threshold
will be set to <code>mu.max</code>.</p>
</td></tr>
<tr><td><code id="ppmlasso_+3A_r">r</code></td>
<td>
<p>The radius of point interactions, required if <code>family = "area.inter"</code>.</p>
</td></tr>
<tr><td><code id="ppmlasso_+3A_interactions">interactions</code></td>
<td>
<p>A vector of point interactions calculated from the <code><a href="#topic+pointInteractions">pointInteractions</a></code>
function necessary for fitting area-interaction models. If <code>interactions = NA</code>
and <code>family = "area.inter"</code>, point interactions will be automatically calculated
for radius <code>r</code> to the locations of <code>data</code>.</p>
</td></tr>
<tr><td><code id="ppmlasso_+3A_availability">availability</code></td>
<td>
<p>An optional binary matrix used in calculating point interactions indicating
whether locations are available (1) or not (0). See <code><a href="#topic+pointInteractions">pointInteractions</a></code> for more details.</p>
</td></tr>
<tr><td><code id="ppmlasso_+3A_max.it">max.it</code></td>
<td>
<p>The maximum number of iterations of the descent algorithm for fitting the
model.</p>
</td></tr>
<tr><td><code id="ppmlasso_+3A_min.lamb">min.lamb</code></td>
<td>
<p>The power <code class="reqn">x</code> of smallest penalty <code class="reqn">e^x</code> among the <code>n.fits</code> models.</p>
</td></tr>
<tr><td><code id="ppmlasso_+3A_standardise">standardise</code></td>
<td>
<p>A logical argument indicating whether the environmental variables
should be standardised to have mean 0 and variance 1. It is recommended that variables are
standardised for analysis.</p>
</td></tr>
<tr><td><code id="ppmlasso_+3A_n.blocks">n.blocks</code></td>
<td>
<p>This argument controls the number of cross validation groups into which the spatial blocks
are divided if the <code>criterion</code> argument is set to <code>"blockCV"</code>. See details.</p>
</td></tr>
<tr><td><code id="ppmlasso_+3A_block.size">block.size</code></td>
<td>
<p>The length of the edges for the spatial blocks created if the <code>criterion</code> argument 
is set to <code>"blockCV"</code>. Only square spatial blocks are currently supported. See details.</p>
</td></tr>
<tr><td><code id="ppmlasso_+3A_seed">seed</code></td>
<td>
<p>The random seed used for controlling the allocation of spatial blocks to cross validation groups
if the <code>criterion</code> argument is set to <code>"blockCV"</code>.</p>
</td></tr>
<tr><td><code id="ppmlasso_+3A_writefile">writefile</code></td>
<td>
<p>A logical argument passed to the <code><a href="#topic+ppmdat">ppmdat</a></code> function to determine whether its output should be written to a file or not, set to <code>TRUE</code> by default. See the documentation for <code><a href="#topic+ppmdat">ppmdat</a></code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits a regularisation path of point process models provided a list of species locations
and a geo-referenced grid of environmental data. It is assumed that Poisson point process models (Warton &amp; Shepherd, 2010)
fit intensity as a log-linear model of environmental covariates, and that area-interaction models
(Widom &amp; Rowlinson, 1970; Baddeley &amp; van Lieshout, 1995) fit conditional intensity as a log-linear model of
environmental covariates and point interactions. Parameter coefficients are estimated by maximum likelihood for
Poisson point process models and by maximum pseudolikelihood (Besag, 1977) for area-interaction models. The expressions
for both the likelihood and pseudolikelihood involve an intractable integral which is approximated using a quadrature
scheme (Berman &amp; Turner, 1992).
</p>
<p>Each model in the regularisation path is fitted by extending the Osborne descent algorithm (Osborne, 2000) to
generalised linear models with penalised iteratively reweighted least squares.
</p>
<p>Three classes of penalty <code class="reqn">p(\beta)</code> are available for the vector of parameter coefficients <code class="reqn">\beta</code>:
</p>
<p>For the LASSO (Tibshirani, 1996), <code class="reqn">p(\beta) = \lambda*\sum_{j = 1}^p |\beta_j|</code>
</p>
<p>For the adaptive LASSO (Zou, 2006), <code class="reqn">p(\beta) = \lambda*\sum_{j = 1}^p w_j*|\beta_j|</code>, where <code class="reqn">w_j = 1/|\hat{\beta}_{init, j}|^\gamma</code>
for some initial estimate of parameters <code class="reqn">\hat{\beta}_{init}</code>.
</p>
<p>For the elastic net (Zou &amp; Hastie, 2005), <code class="reqn">\alpha*\lambda*\sum_{j = 1}^p |\beta_j| + (1 - \alpha)*\lambda*\sum_{j = 1}^p (\beta_j)^2</code>.
Note that this form of the penalty is a restricted case of the general elastic net penalty.
</p>
<p>There are various criteria available for managing the bias-variance tradeoff (Renner, 2013).
The default choice is BIC, the Bayesian Information Criterion, which has been shown to have
good performance. 
</p>
<p>An alternative criterion useful when data are sparse is MSI, the maximum score 
of the intercept model (Renner, in prep). For a set of <code class="reqn">m</code> presence locations, the
MSI penalty is <code class="reqn">\lambda_{MSI} = \lambda_{max}/\sqrt{m}</code>, where <code class="reqn">\lambda_{max}</code> is the smallest penalty
that shrinks all environmental coefficients to zero. The MSI penalty differs from the other criteria in that does
not require an entire regularisation path to be fitted.
</p>
<p>It is also possible to control the magnitude of the penalty by spatial cross validation by setting the 
<code>criterion</code> argument to <code>"blockCV"</code>. The study region is then divided into square blocks with edge
lengths controlled by the <code>block.size</code> argument, which are assigned to one of a number of cross validation
groups controlled by the <code>n.groups</code> argument. The penalty which maximises the predicted log-likelihood is
chosen.
</p>


<h3>Value</h3>

<p>An object of class <code>"ppmlasso"</code>, with elements:
</p>
<table>
<tr><td><code>betas</code></td>
<td>
<p>A matrix of fitted coefficients of the <code>n.fits</code> models.</p>
</td></tr>
<tr><td><code>lambdas</code></td>
<td>
<p>A vector containing the <code>n.fits</code> penalty values.</p>
</td></tr>
<tr><td><code>likelihoods</code></td>
<td>
<p>A vector containing the likelihood of <code>n.fits</code> fitted models.</p>
</td></tr>
<tr><td><code>pen.likelihoods</code></td>
<td>
<p>A vector containing the penalised likelihood of <code>n.fits</code> fitted
models.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>A vector containing the coefficients of the model that optimises the specified <code>criterion</code>.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>The penalty value of the model that optimises the specified <code>criterion</code>.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>A vector of fitted values from the model that optimises the specified <code>criterion</code>.</p>
</td></tr>
<tr><td><code>likelihood</code></td>
<td>
<p>The likelihood of the model that optimises the specified <code>criterion</code>.</p>
</td></tr>
<tr><td><code>criterion</code></td>
<td>
<p>The specified <code>criterion</code> of the function call.</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>The specified <code>family</code> of the function call.</p>
</td></tr>
<tr><td><code>gamma</code></td>
<td>
<p>The specified <code>gamma</code> of the function call.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>The specified <code>alpha</code> of the function call.</p>
</td></tr>
<tr><td><code>init.coef</code></td>
<td>
<p>The specified <code>init.coef</code> of the function call.</p>
</td></tr>
<tr><td><code>criterion.matrix</code></td>
<td>
<p>A matrix with <code>n.fits</code> rows corresponding to the observed values
of AIC, BIC, HQC, GCV, and non-linear GCV.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The design matrix. For the point process models fitted with this function,
<code>mu = e^{data*beta}</code>.</p>
</td></tr>
<tr><td><code>pt.interactions</code></td>
<td>
<p>The calculated point interactions.</p>
</td></tr>
<tr><td><code>wt</code></td>
<td>
<p>The vector of quadrature weights.</p>
</td></tr>
<tr><td><code>pres</code></td>
<td>
<p>A vector indicating presence (1) or quadrature point (0).</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>A vector of point longitudes.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>A vector of point latitudes.</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p>The radius of point interactions.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The function call.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>The <code>formula</code> argument.</p>
</td></tr>
<tr><td><code>s.means</code></td>
<td>
<p>If <code>standardise = TRUE</code>, the means of each column of <code>data</code> prior to standardisation.</p>
</td></tr>
<tr><td><code>s.sds</code></td>
<td>
<p>If <code>standardise = TRUE</code>, the standard deviations of each column of <code>data</code> prior to standardisation.</p>
</td></tr>
<tr><td><code>cv.group</code></td>
<td>
<p>The cross validation group associated with each point in the data set.</p>
</td></tr>
<tr><td><code>n.blocks</code></td>
<td>
<p>The number of cross validation groups specified.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ian W. Renner</p>


<h3>References</h3>

<p>Baddeley, A.J. &amp; van Lieshout, M.N.M. (1995). Area-interaction point processes.
<em>Annals of the Institute of Statistical Mathematics</em> <b>47</b>, 601-619.
</p>
<p>Berman, M. &amp; Turner, T.R. (1992). Approximating point process likelihoods with
GLIM. <em>Journal of the Royal Statistics Society, Series C</em> <b>41</b>, 31-38.
</p>
<p>Besag, J. (1977). Some methods of statistical analysis for spatial data. <em>Bulletin of
the International Statistical Institute</em> <b>47</b>, 77-91.
</p>
<p>Osborne, M.R., Presnell, B., &amp; Turlach, B.A. (2000). On the lasso and its dual.
<em>Journal of Computational and Graphical Statistics</em> <b>9</b>, 319-337.
</p>
<p>Renner, I.W. &amp; Warton, D.I. (2013). Equivalence of MAXENT and Poisson point process 
models for species distribution modeling in ecology. <em>Biometrics</em> <b>69</b>, 274-281.
</p>
<p>Renner, I.W. (2013). Advances in presence-only methods in ecology.
<a href="https://unsworks.unsw.edu.au/fapi/datastream/unsworks:11510/SOURCE01">https://unsworks.unsw.edu.au/fapi/datastream/unsworks:11510/SOURCE01</a>
</p>
<p>Tibshirani, R. (1996). Regression shrinkage and selection via the lasso. <em>Journal of
the Royal Statistical Society, Series B</em> <b>58</b>, 267-288.
</p>
<p>Warton, D.I. &amp; Shepherd, L.C. (2010). Poisson point process models solve the
&quot;pseudo-absence problem&quot; for presence-only data in ecology. <em>Annals of Applied
Statistics</em> <b>4</b>, 1383-1402.
</p>
<p>Widom, B. &amp; Rowlinson, J.S. (1970). New model for the study of liquid-vapor
phase transitions. <em>The Journal of Chemical Physics</em> <b>52</b>, 1670-1684.
</p>
<p>Zou, H. (2006). The adaptive lasso and its oracle properties. <em>Journal of the American
Statistical Association</em> <b>101</b>, 1418-1429.
</p>
<p>Zou, H. &amp; Hastie, T. (2005). Regularization and variable selection via the elastic
net. <em>Journal of the Royal Statistical Society, Series B</em> <b>67</b>, 301-320.</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.ppmlasso">print.ppmlasso</a></code> for printing features of the fitted regularisation path.
</p>
<p><code><a href="#topic+predict.ppmlasso">predict.ppmlasso</a></code> for predicting intensity for a set of new data.
</p>
<p><code><a href="#topic+envelope.ppmlasso">envelope.ppmlasso</a></code> for constructing a K-envelope of the model which optimises
the given criterion from the <code>spatstat</code> package.
</p>
<p><code><a href="#topic+diagnose.ppmlasso">diagnose.ppmlasso</a></code> for diagnostic plots from the <code>spatstat</code> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Fit a regularisation path of Poisson point process models
data(BlueMountains)
sub.env = BlueMountains$env[BlueMountains$env$Y &gt; 6270 &amp; BlueMountains$env$X &gt; 300,]
sub.euc = BlueMountains$eucalypt[BlueMountains$eucalypt$Y &gt; 6270 &amp; BlueMountains$eucalypt$X &gt; 300,]
ppm.form = ~ poly(FC, TMP_MIN, TMP_MAX, RAIN_ANN, degree = 2)
ppm.fit  = ppmlasso(ppm.form, sp.xy = sub.euc, env.grid = sub.env, sp.scale = 1, n.fits = 20,
writefile = FALSE)

#Fit a regularisation path of area-interaction models
data(BlueMountains)
ai.form  = ~ poly(FC, TMP_MIN, TMP_MAX, RAIN_ANN, degree = 2)
ai.fit   = ppmlasso(ai.form, sp.xy = sub.euc, env.grid = sub.env, sp.scale = 1, 
family = "area.inter", r = 2, availability = BlueMountains$availability, n.fits = 20,
writefile = FALSE)
</code></pre>

<hr>
<h2 id='ppmlasso-class'>Class <code>"ppmlasso"</code></h2><span id='topic+ppmlasso-class'></span>

<h3>Description</h3>

<p>A class <code>ppmlasso</code> which represents a point process model with a LASSO-type penalty.
</p>


<h3>Methods</h3>


<dl>
<dt>diagnose</dt><dd><p><code>signature(object = "ppmlasso")</code>: Produce diagnostic plots for a fitted point process model.</p>
</dd>
<dt>envelope</dt><dd><p><code>signature(Y = "ppmlasso")</code>: Produce a Monte Carlo simulation envelope for a summary function of a fitted point process model.</p>
</dd>
<dt>predict</dt><dd><p><code>signature(object = "ppmlasso")</code>: Calculate the predicted intensity for a fitted point process model to a set of data.</p>
</dd>
<dt>print</dt><dd><p><code>signature(x = "ppmlasso")</code>: Print the details of a fitted point process model.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ian W. Renner
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("ppmlasso")
</code></pre>

<hr>
<h2 id='ppmlasso-internal'>Internal ppmlasso functions</h2><span id='topic+blocks'></span><span id='topic+calculateGCV'></span><span id='topic+calculateLikelihood'></span><span id='topic+calculateUnpenalisedLikelihood'></span><span id='topic+catConvert'></span><span id='topic+catFrame'></span><span id='topic+decimalCount'></span><span id='topic+etaFromMu'></span><span id='topic+interp'></span><span id='topic+irlsUpdate'></span><span id='topic+makeMask'></span><span id='topic+muFromEta'></span><span id='topic+polyNames'></span><span id='topic+ppmSpatstat'></span><span id='topic+scoreIntercept'></span><span id='topic+singleLasso'></span><span id='topic+spatRes'></span><span id='topic+standardiseX'></span><span id='topic+weights'></span><span id='topic+zapCoord'></span>

<h3>Description</h3>

<p>These are internal functions called by the main functions of <code>ppmlasso</code>, but are not generally used directly by the user.</p>


<h3>Usage</h3>

<pre><code class='language-R'>blocks(n.blocks, block.scale, dat, seed = 1)
calculateGCV(y, X, ob.wt, b.lasso, lambda, alpha = alpha, 
unp.likelihood = unp.likelihood, penalty = TRUE, family = "poisson", 
mu.min = 1.e-16, mu.max = 1.e16, eta.min = log(1.e-16), eta.max = log(1.e16),
tol = 1.e-9, area.int = FALSE)
calculateLikelihood(X, family, ob.wt, mu, y, alpha, lambda, beta, penalty = FALSE)
calculateUnpenalisedLikelihood(ob.wt, y, mu)
catConvert(env.frame)
catFrame(cat.mat)
decimalCount(x, max.dec = max(10, max(nchar(x))), tol = 0.1)
etaFromMu(mu, family, mu.min = 1.e-16, mu.max = 1/mu.min, eta.min, eta.max)
interp(sp.xy, sp.scale, f, back.xy, coord = c("X", "Y"))
irlsUpdate(y, X, ob.wt, is.in, signs, eta, mu, alpha, lambda, beta.old, 
penalty = FALSE, family, mu.min = 1.e-16, mu.max = 1/mu.min, eta.min, 
eta.max, tol = tol)
makeMask(dat.ppm)
muFromEta(eta, family, mu.min = 1.e-16, mu.max = 1/mu.min)
polyNames(X)
ppmSpatstat(fit)
scoreIntercept(y, X.des, ob.wt = rep(1, length(y)), area.int = FALSE, int = NA, family)
singleLasso(y, X, lamb, ob.wt = rep(1, length(y)), alpha = 1, b.init = NA,
intercept = NA, family = "gaussian", tol = 1.e-9, gamma = 0, init.coef = NA, 
mu.min = 1.e-16, mu.max = 1/mu.min, area.int = FALSE, interactions, max.it = 25,
standardise = TRUE)
spatRes(env.grid, coord = c("X", "Y"))
standardiseX(mat)
weights(sp.xy, quad.xy, coord = c("X", "Y"))
zapCoord(x, numdec = decimalCount(x))
</code></pre>


<h3>Details</h3>

<p>These are generally not called by the user.</p>


<h3>Author(s)</h3>

<p>Ian W. Renner</p>

<hr>
<h2 id='predict-methods'>Methods for function <code>predict</code></h2><span id='topic+predict-methods'></span><span id='topic+predict+2Cppmlasso-method'></span>

<h3>Description</h3>

<p>Methods for function <code><a href="stats.html#topic+predict">predict</a></code>
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "ppmlasso")</code></dt><dd>
<p>Creates a vector of predicted intensities for an object of class <code>ppmlasso</code>.
</p>
</dd>
</dl>

<hr>
<h2 id='predict.ppmlasso'>Prediction to new data from a fitted regularisation path</h2><span id='topic+predict.ppmlasso'></span>

<h3>Description</h3>

<p>Given a fitted regularisation path produced by <code><a href="#topic+ppmlasso">ppmlasso</a></code>, this function will predict the intensity for a new
set of data.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ppmlasso'
predict(object, ..., newdata, interactions = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.ppmlasso_+3A_object">object</code></td>
<td>
<p>A fitted regularisation path produced by <code><a href="#topic+ppmlasso">ppmlasso</a></code>.</p>
</td></tr>
<tr><td><code id="predict.ppmlasso_+3A_...">...</code></td>
<td>
<p>Additional arguments impacting the prediction calculations.</p>
</td></tr>
<tr><td><code id="predict.ppmlasso_+3A_newdata">newdata</code></td>
<td>
<p>A data frame of new environmental data for which predicted intensities are computed.</p>
</td></tr>
<tr><td><code id="predict.ppmlasso_+3A_interactions">interactions</code></td>
<td>
<p>A vector of point interactions for predictions of area-interaction models.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of predicted intensities corresponding to the environmental data provided in the <code>newdata</code> argument.</p>


<h3>Author(s)</h3>

<p>Ian W. Renner</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppmlasso">ppmlasso</a></code> for fitting a regularisation path of point process models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(BlueMountains)
sub.env = BlueMountains$env[BlueMountains$env$Y &gt; 6270 &amp; BlueMountains$env$X &gt; 300,]
sub.euc = BlueMountains$eucalypt[BlueMountains$eucalypt$Y &gt; 6270 &amp; BlueMountains$eucalypt$X &gt; 300,]
ppm.form = ~ poly(FC, TMP_MIN, TMP_MAX, RAIN_ANN, degree = 2, raw = TRUE)
ppm.fit  = ppmlasso(ppm.form, sp.xy = sub.euc, env.grid = sub.env, sp.scale = 1, n.fits = 20,
writefile = FALSE)
pred.mu  = predict(ppm.fit, newdata = sub.env)
</code></pre>

<hr>
<h2 id='print-methods'>Methods for function <code>print</code></h2><span id='topic+print-methods'></span><span id='topic+print+2Cppmlasso-method'></span>

<h3>Description</h3>

<p>Methods for function <code><a href="base.html#topic+print">print</a></code>
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "ppmlasso")</code></dt><dd>
<p>Prints output for a <code>ppmlasso</code> object with details controlled by arguments of the 
<code><a href="#topic+print.ppmlasso">print.ppmlasso</a></code> function.
</p>
</dd>
</dl>

<hr>
<h2 id='print.ppmlasso'>Print a fitted regularisation path</h2><span id='topic+print.ppmlasso'></span>

<h3>Description</h3>

<p>This function prints output from a fitted regularisation path.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ppmlasso'
print(x, ..., output = c("all", "path", "model", "interaction"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.ppmlasso_+3A_x">x</code></td>
<td>
<p>A regularisation path fitted by <code><a href="#topic+ppmlasso">ppmlasso</a></code>.</p>
</td></tr>
<tr><td><code id="print.ppmlasso_+3A_...">...</code></td>
<td>
<p>Further arguments controlling the printed output.</p>
</td></tr>
<tr><td><code id="print.ppmlasso_+3A_output">output</code></td>
<td>
<p>This argument controls what output is printed to the screen. If <code>output</code> includes <code>"path"</code>,
information about the entire regularisation path is printed. If <code>output</code> includes <code>"model"</code>,
information about the model that optimises the given criterion is printed. If <code>output</code> includes <code>"interaction"</code>,
information about the point interactions is printed. Setting <code>output = "all"</code> will print all available information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>N/A</p>


<h3>Author(s)</h3>

<p>Ian W. Renner</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppmlasso">ppmlasso</a></code> for fitting regularisation paths.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Fit a regularisation path of Poisson point process models
data(BlueMountains)
ppm.form = ~ poly(FC, TMP_MIN, TMP_MAX, RAIN_ANN, degree = 2)
ppm.fit  = ppmlasso(ppm.form, sp.xy = BlueMountains$eucalypt, 
env.grid = BlueMountains$env, sp.scale = 1, n.fits = 20, writefile = FALSE)
print(ppm.fit)
</code></pre>

<hr>
<h2 id='sampleQuad'>Generate regular grid of quadrature points with environmental data</h2><span id='topic+sampleQuad'></span>

<h3>Description</h3>

<p>This function generates a regular grid of quadrature points and
associated environmental data at a nominated spatial resolution.</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleQuad(env.grid, sp.scale, coord = c("X", "Y"), quadfilename = "Quad", tol = 0.01, 
writefile = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampleQuad_+3A_env.grid">env.grid</code></td>
<td>
<p>The geo-referenced matrix of environmental grids. It must
have a vector of longitude and a vector of latitude.</p>
</td></tr>
<tr><td><code id="sampleQuad_+3A_sp.scale">sp.scale</code></td>
<td>
<p>The spatial resolution at which to sample quadrature points.</p>
</td></tr>
<tr><td><code id="sampleQuad_+3A_coord">coord</code></td>
<td>
<p>A vector containing the names of the longitude and latitude coordinates.</p>
</td></tr>
<tr><td><code id="sampleQuad_+3A_quadfilename">quadfilename</code></td>
<td>
<p>An optional argument containing the prefix of the name of the saved file. The
default is <code>"Quad"</code> so that a matrix generated at a spatial resolution of 1 would
be saved in the file <code>"Quad1.RData"</code>. A file is saved for every resolution given
in <code>sp.scale</code>.</p>
</td></tr>
<tr><td><code id="sampleQuad_+3A_tol">tol</code></td>
<td>
<p>An optional argument to specify the tolerance level of coordinate error passed to an internal call to the <code><a href="#topic+griddify">griddify</a></code> function, set to 0.01 by default.</p>
</td></tr>
<tr><td><code id="sampleQuad_+3A_writefile">writefile</code></td>
<td>
<p>A logical argument to determine whether the output should be written to a file or not. If <code>TRUE</code> (the default), the output will be saved with the file name as described in the <code>quadfilename</code> argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output is a matrix of quadrature points at the spatial resolution
supplied to <code>sp.scale</code>. If a vector of resolutions is supplied, the output is a list of
matrices for each spatial resolution.</p>


<h3>Author(s)</h3>

<p>Ian W. Renner</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(BlueMountains)
quad.1 = sampleQuad(env.grid = BlueMountains$env, sp.scale = 1, quadfilename = NA, 
writefile = FALSE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
