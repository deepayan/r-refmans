<!DOCTYPE html><html><head><title>Help for package future.apply</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {future.apply}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#fold'><p>Efficient Fold, Reduce, Accumulate, Combine of a Vector</p></a></li>
<li><a href='#future_apply'><p>Apply Functions Over Array Margins via Futures</p></a></li>
<li><a href='#future_by'><p>Apply a Function to a Data Frame Split by Factors via Futures</p></a></li>
<li><a href='#future_eapply'><p>Apply a Function over a List or Vector via Futures</p></a></li>
<li><a href='#future_Map'><p>Apply a Function to Multiple List or Vector Arguments</p></a></li>
<li><a href='#future.apply'><p>future.apply: Apply Function to Elements in Parallel using Futures</p></a></li>
<li><a href='#future.apply.options'><p>Options used for future.apply</p></a></li>
<li><a href='#makeChunks'><p>Create Chunks of Index Vectors</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.11.1</td>
</tr>
<tr>
<td>Title:</td>
<td>Apply Function to Elements in Parallel using Futures</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0), future (&ge; 1.28.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>globals (&ge; 0.16.1), parallel, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>datasets, stats, tools, listenv (&ge; 0.8.0), R.rsp, markdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementations of apply(), by(), eapply(), lapply(), Map(), .mapply(), mapply(), replicate(), sapply(), tapply(), and vapply() that can be resolved using any future-supported backend, e.g. parallel on the local machine or distributed on a compute cluster.  These future_*apply() functions come with the same pros and cons as the corresponding base-R *apply() functions but with the additional feature of being able to be processed via the future framework.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>TRUE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://future.apply.futureverse.org">https://future.apply.futureverse.org</a>,
<a href="https://github.com/HenrikBengtsson/future.apply">https://github.com/HenrikBengtsson/future.apply</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/HenrikBengtsson/future.apply/issues">https://github.com/HenrikBengtsson/future.apply/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-20 07:12:01 UTC; henrik</td>
</tr>
<tr>
<td>Author:</td>
<td>Henrik Bengtsson <a href="https://orcid.org/0000-0002-7579-5165"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  R Core Team [cph, ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Henrik Bengtsson &lt;henrikb@braju.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-21 22:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='fold'>Efficient Fold, Reduce, Accumulate, Combine of a Vector</h2><span id='topic+fold'></span>

<h3>Description</h3>

<p>Efficient Fold, Reduce, Accumulate, Combine of a Vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fold(x, f, left = TRUE, unname = TRUE, threshold = 1000L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fold_+3A_x">x</code></td>
<td>
<p>A vector.</p>
</td></tr>
<tr><td><code id="fold_+3A_f">f</code></td>
<td>
<p>A binary function, i.e. a function take takes two arguments.</p>
</td></tr>
<tr><td><code id="fold_+3A_left">left</code></td>
<td>
<p>If <code>TRUE</code>, vector is combined from the left (the first element),
otherwise the right (the last element).</p>
</td></tr>
<tr><td><code id="fold_+3A_unname">unname</code></td>
<td>
<p>If <code>TRUE</code>, function <code>f</code> is called as
<code>f(unname(y), x[[ii]])</code>, otherwise as <code>f(y, x[[ii]])</code>,
which may introduce name <code>"y"</code>.</p>
</td></tr>
<tr><td><code id="fold_+3A_threshold">threshold</code></td>
<td>
<p>An integer (&gt;= 2) specifying the length where the
recursive divide-and-conquer call will stop and incremental building of
the partial value is performed.  Using <code>threshold = +Inf</code> will disable
recursive folding.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order for recursive folding to give the same results as non-recursive
folding, binary function <code>f</code> must be <em>associative</em> with itself, i.e.
<code>f(f(x[[1]], x[[2]]), x[[3]])</code> equals
<code>f(x[[1]], f(x[[2]]), x[[3]])</code>.
</p>
<p>This function is a more efficient (memory and speed) of
<code><a href="base.html#topic+funprog">Reduce(f, x, right = !left, accumulate = FALSE)</a></code>,
especially when <code>x</code> is long.
</p>


<h3>Value</h3>

<p>A vector.
</p>

<hr>
<h2 id='future_apply'>Apply Functions Over Array Margins via Futures</h2><span id='topic+future_apply'></span>

<h3>Description</h3>

<p><code>future_apply()</code> implements <code><a href="base.html#topic+apply">base::apply()</a></code> using future with perfect
replication of results, regardless of future backend used.
It returns a vector or array or list of values obtained by applying a
function to margins of an array or matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>future_apply(
  X,
  MARGIN,
  FUN,
  ...,
  simplify = TRUE,
  future.envir = parent.frame(),
  future.stdout = TRUE,
  future.conditions = "condition",
  future.globals = TRUE,
  future.packages = NULL,
  future.seed = FALSE,
  future.scheduling = 1,
  future.chunk.size = NULL,
  future.label = "future_apply-%d"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="future_apply_+3A_x">X</code></td>
<td>
<p>an array, including a matrix.</p>
</td></tr>
<tr><td><code id="future_apply_+3A_margin">MARGIN</code></td>
<td>
<p>A vector giving the subscripts which the function will be
applied over. For example, for a matrix <code>1</code> indicates rows, <code>2</code> indicates
columns, <code>c(1, 2)</code> indicates rows and columns.
Where <code>X</code> has named dimnames, it can be a character vector selecting
dimension names.</p>
</td></tr>
<tr><td><code id="future_apply_+3A_fun">FUN</code></td>
<td>
<p>A function taking at least one argument.</p>
</td></tr>
<tr><td><code id="future_apply_+3A_simplify">simplify</code></td>
<td>
<p>a logical indicating whether results should be simplified
if possible.</p>
</td></tr>
<tr><td><code id="future_apply_+3A_future.envir">future.envir</code></td>
<td>
<p>An <a href="base.html#topic+environment">environment</a> passed as argument <code>envir</code> to
<code><a href="future.html#topic+future">future::future()</a></code> as-is.</p>
</td></tr>
<tr><td><code id="future_apply_+3A_future.stdout">future.stdout</code></td>
<td>
<p>If <code>TRUE</code> (default), then the standard output of the
underlying futures is captured, and re-outputted as soon as possible.
If <code>FALSE</code>, any output is silenced (by sinking it to the null device
as it is outputted).
If <code>NA</code> (not recommended), output is <em>not</em> intercepted.</p>
</td></tr>
<tr><td><code id="future_apply_+3A_future.conditions">future.conditions</code></td>
<td>
<p>A character string of conditions classes to be
captured and relayed.  The default is the same as the <code>condition</code>
argument of <code><a href="future.html#topic+Future-class">future::Future()</a></code>.
To not intercept conditions, use <code>conditions = character(0L)</code>.
Errors are always relayed.</p>
</td></tr>
<tr><td><code id="future_apply_+3A_future.globals">future.globals</code></td>
<td>
<p>A logical, a character vector, or a named list for
controlling how globals are handled. For details, see below section.</p>
</td></tr>
<tr><td><code id="future_apply_+3A_future.packages">future.packages</code></td>
<td>
<p>(optional) a character vector specifying packages
to be attached in the R environment evaluating the future.</p>
</td></tr>
<tr><td><code id="future_apply_+3A_future.seed">future.seed</code></td>
<td>
<p>A logical or an integer (of length one or seven),
or a list of <code>length(X)</code> with pre-generated random seeds.
For details, see below section.</p>
</td></tr>
<tr><td><code id="future_apply_+3A_future.scheduling">future.scheduling</code></td>
<td>
<p>Average number of futures (&quot;chunks&quot;) per worker.
If <code>0.0</code>, then a single future is used to process all elements
of <code>X</code>.
If <code>1.0</code> or <code>TRUE</code>, then one future per worker is used.
If <code>2.0</code>, then each worker will process two futures
(if there are enough elements in <code>X</code>).
If <code>Inf</code> or <code>FALSE</code>, then one future per element of
<code>X</code> is used.
Only used if <code>future.chunk.size</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="future_apply_+3A_future.chunk.size">future.chunk.size</code></td>
<td>
<p>The average number of elements per future (&quot;chunk&quot;).
If <code>Inf</code>, then all elements are processed in a single future.
If <code>NULL</code>, then argument <code>future.scheduling</code> is used.</p>
</td></tr>
<tr><td><code id="future_apply_+3A_future.label">future.label</code></td>
<td>
<p>If a character string, then each future is assigned
a label <code>sprintf(future.label, chunk_idx)</code>.  If TRUE, then the
same as <code>future.label = "future_lapply-%d"</code>.  If FALSE, no labels
are assigned.</p>
</td></tr>
<tr><td><code id="future_apply_+3A_...">...</code></td>
<td>
<p>(optional) Additional arguments passed to <code>FUN()</code>, except
<code style="white-space: pre;">&#8288;future.*&#8288;</code> arguments, which are passed on to <code><a href="#topic+future_lapply">future_lapply()</a></code> used
internally.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector or array or list of values obtained by applying a
function to margins of an array or matrix.
See <code><a href="base.html#topic+apply">base::apply()</a></code> for details.
</p>


<h3>Author(s)</h3>

<p>The implementations of <code>future_apply()</code> is adopted from the source code
of the corresponding base <span class="rlang"><b>R</b></span> function, which is licensed under GPL (&gt;= 2)
with 'The R Core Team' as the copyright holder.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## ---------------------------------------------------------
## apply()
## ---------------------------------------------------------
X &lt;- matrix(c(1:4, 1, 6:8), nrow = 2L)

Y0 &lt;- apply(X, MARGIN = 1L, FUN = table)
Y1 &lt;- future_apply(X, MARGIN = 1L, FUN = table)
print(Y1)
stopifnot(all.equal(Y1, Y0, check.attributes = FALSE)) ## FIXME

Y0 &lt;- apply(X, MARGIN = 1L, FUN = stats::quantile)
Y1 &lt;- future_apply(X, MARGIN = 1L, FUN = stats::quantile)
print(Y1)
stopifnot(all.equal(Y1, Y0))


## ---------------------------------------------------------
## Parallel Random Number Generation
## ---------------------------------------------------------

## Regardless of the future plan, the number of workers, and
## where they are, the random numbers produced are identical

X &lt;- matrix(c(1:4, 1, 6:8), nrow = 2L)

plan(multisession)
set.seed(0xBEEF)
Y1 &lt;- future_apply(X, MARGIN = 1L, FUN = sample, future.seed = TRUE)
print(Y1)

plan(sequential)
set.seed(0xBEEF)
Y2 &lt;- future_apply(X, MARGIN = 1L, FUN = sample, future.seed = TRUE)
print(Y2)

stopifnot(all.equal(Y1, Y2))



</code></pre>

<hr>
<h2 id='future_by'>Apply a Function to a Data Frame Split by Factors via Futures</h2><span id='topic+future_by'></span>

<h3>Description</h3>

<p>Apply a Function to a Data Frame Split by Factors via Futures
</p>


<h3>Usage</h3>

<pre><code class='language-R'>future_by(
  data,
  INDICES,
  FUN,
  ...,
  simplify = TRUE,
  future.envir = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="future_by_+3A_data">data</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object, normally a data frame, possibly a matrix.</p>
</td></tr>
<tr><td><code id="future_by_+3A_indices">INDICES</code></td>
<td>
<p>A factor or a list of factors, each of length <code>nrow(data)</code>.</p>
</td></tr>
<tr><td><code id="future_by_+3A_fun">FUN</code></td>
<td>
<p>a function to be applied to (usually data-frame) subsets of <code>data</code>.</p>
</td></tr>
<tr><td><code id="future_by_+3A_simplify">simplify</code></td>
<td>
<p>logical: see <a href="base.html#topic+tapply">base::tapply</a>.</p>
</td></tr>
<tr><td><code id="future_by_+3A_future.envir">future.envir</code></td>
<td>
<p>An <a href="base.html#topic+environment">environment</a> passed as argument <code>envir</code> to
<code><a href="future.html#topic+future">future::future()</a></code> as-is.</p>
</td></tr>
<tr><td><code id="future_by_+3A_...">...</code></td>
<td>
<p>Additional arguments pass to <code><a href="#topic+future_lapply">future_lapply()</a></code> and
then to <code>FUN()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internally, <code>data</code> is grouped by <code>INDICES</code> into a list of <code>data</code>
subset elements which is then processed by <code><a href="#topic+future_lapply">future_lapply()</a></code>.
When the groups differ significantly in size, the processing time
may differ significantly between the groups.
To correct for processing-time imbalances, adjust the amount of chunking
via arguments <code>future.scheduling</code> and <code>future.chunk.size</code>.
</p>


<h3>Value</h3>

<p>An object of class &quot;by&quot;, giving the results for each subset.
This is always a list if simplify is false, otherwise a list
or array (see <a href="base.html#topic+tapply">base::tapply</a>).
See also <code><a href="base.html#topic+by">base::by()</a></code> for details.
</p>


<h3>Note on 'stringsAsFactors'</h3>

<p>The <code>future_by()</code> is modeled as closely as possible to the
behavior of <code>base::by()</code>.  Both functions have &quot;default&quot; S3 methods that
calls <code>data &lt;- as.data.frame(data)</code> internally.  This call may in turn call
an S3 method for <code>as.data.frame()</code> that coerces strings to factors or not
depending on whether it has a <code>stringsAsFactors</code> argument and what its
default is.
For example, the S3 method of <code>as.data.frame()</code> for lists changed its
(effective) default from <code>stringsAsFactors = TRUE</code> to
<code>stringsAsFactors = TRUE</code> in R 4.0.0.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## ---------------------------------------------------------
## by()
## ---------------------------------------------------------
library(datasets) ## warpbreaks
library(stats)    ## lm()

y0 &lt;- by(warpbreaks, warpbreaks[,"tension"],
         function(x) lm(breaks ~ wool, data = x))

plan(multisession)
y1 &lt;- future_by(warpbreaks, warpbreaks[,"tension"],
                function(x) lm(breaks ~ wool, data = x))

plan(sequential)
y2 &lt;- future_by(warpbreaks, warpbreaks[,"tension"],
                function(x) lm(breaks ~ wool, data = x))
</code></pre>

<hr>
<h2 id='future_eapply'>Apply a Function over a List or Vector via Futures</h2><span id='topic+future_eapply'></span><span id='topic+future_lapply'></span><span id='topic+future_replicate'></span><span id='topic+future_sapply'></span><span id='topic+future_tapply'></span><span id='topic+future_vapply'></span>

<h3>Description</h3>

<p><code>future_lapply()</code> implements <code><a href="base.html#topic+lapply">base::lapply()</a></code> using futures with perfect
replication of results, regardless of future backend used.
Analogously, this is true for all the other <code>future_nnn()</code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>future_eapply(
  env,
  FUN,
  ...,
  all.names = FALSE,
  USE.NAMES = TRUE,
  future.envir = parent.frame(),
  future.label = "future_eapply-%d"
)

future_lapply(
  X,
  FUN,
  ...,
  future.envir = parent.frame(),
  future.stdout = TRUE,
  future.conditions = "condition",
  future.globals = TRUE,
  future.packages = NULL,
  future.seed = FALSE,
  future.scheduling = 1,
  future.chunk.size = NULL,
  future.label = "future_lapply-%d"
)

future_replicate(
  n,
  expr,
  simplify = "array",
  future.seed = TRUE,
  ...,
  future.envir = parent.frame(),
  future.label = "future_replicate-%d"
)

future_sapply(
  X,
  FUN,
  ...,
  simplify = TRUE,
  USE.NAMES = TRUE,
  future.envir = parent.frame(),
  future.label = "future_sapply-%d"
)

future_tapply(
  X,
  INDEX,
  FUN = NULL,
  ...,
  default = NA,
  simplify = TRUE,
  future.envir = parent.frame(),
  future.label = "future_tapply-%d"
)

future_vapply(
  X,
  FUN,
  FUN.VALUE,
  ...,
  USE.NAMES = TRUE,
  future.envir = parent.frame(),
  future.label = "future_vapply-%d"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="future_eapply_+3A_env">env</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> environment.</p>
</td></tr>
<tr><td><code id="future_eapply_+3A_fun">FUN</code></td>
<td>
<p>A function taking at least one argument.</p>
</td></tr>
<tr><td><code id="future_eapply_+3A_all.names">all.names</code></td>
<td>
<p>If <code>TRUE</code>, the function will also be applied to variables
that start with a period (<code>.</code>), otherwise not.
See <code><a href="base.html#topic+eapply">base::eapply()</a></code> for details.</p>
</td></tr>
<tr><td><code id="future_eapply_+3A_use.names">USE.NAMES</code></td>
<td>
<p>See <code><a href="base.html#topic+lapply">base::sapply()</a></code>.</p>
</td></tr>
<tr><td><code id="future_eapply_+3A_future.envir">future.envir</code></td>
<td>
<p>An <a href="base.html#topic+environment">environment</a> passed as argument <code>envir</code> to
<code><a href="future.html#topic+future">future::future()</a></code> as-is.</p>
</td></tr>
<tr><td><code id="future_eapply_+3A_future.label">future.label</code></td>
<td>
<p>If a character string, then each future is assigned
a label <code>sprintf(future.label, chunk_idx)</code>.  If TRUE, then the
same as <code>future.label = "future_lapply-%d"</code>.  If FALSE, no labels
are assigned.</p>
</td></tr>
<tr><td><code id="future_eapply_+3A_x">X</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object for which a <code><a href="base.html#topic+split">split</a></code> method
exists.  Typically vector-like, allowing subsetting with
<code><a href="base.html#topic++5B">[</a></code>, or a data frame.</p>
</td></tr>
<tr><td><code id="future_eapply_+3A_future.stdout">future.stdout</code></td>
<td>
<p>If <code>TRUE</code> (default), then the standard output of the
underlying futures is captured, and re-outputted as soon as possible.
If <code>FALSE</code>, any output is silenced (by sinking it to the null device
as it is outputted).
If <code>NA</code> (not recommended), output is <em>not</em> intercepted.</p>
</td></tr>
<tr><td><code id="future_eapply_+3A_future.conditions">future.conditions</code></td>
<td>
<p>A character string of conditions classes to be
captured and relayed.  The default is the same as the <code>condition</code>
argument of <code><a href="future.html#topic+Future-class">future::Future()</a></code>.
To not intercept conditions, use <code>conditions = character(0L)</code>.
Errors are always relayed.</p>
</td></tr>
<tr><td><code id="future_eapply_+3A_future.globals">future.globals</code></td>
<td>
<p>A logical, a character vector, or a named list for
controlling how globals are handled. For details, see below section.</p>
</td></tr>
<tr><td><code id="future_eapply_+3A_future.packages">future.packages</code></td>
<td>
<p>(optional) a character vector specifying packages
to be attached in the R environment evaluating the future.</p>
</td></tr>
<tr><td><code id="future_eapply_+3A_future.seed">future.seed</code></td>
<td>
<p>A logical or an integer (of length one or seven),
or a list of <code>length(X)</code> with pre-generated random seeds.
For details, see below section.</p>
</td></tr>
<tr><td><code id="future_eapply_+3A_future.scheduling">future.scheduling</code></td>
<td>
<p>Average number of futures (&quot;chunks&quot;) per worker.
If <code>0.0</code>, then a single future is used to process all elements
of <code>X</code>.
If <code>1.0</code> or <code>TRUE</code>, then one future per worker is used.
If <code>2.0</code>, then each worker will process two futures
(if there are enough elements in <code>X</code>).
If <code>Inf</code> or <code>FALSE</code>, then one future per element of
<code>X</code> is used.
Only used if <code>future.chunk.size</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="future_eapply_+3A_future.chunk.size">future.chunk.size</code></td>
<td>
<p>The average number of elements per future (&quot;chunk&quot;).
If <code>Inf</code>, then all elements are processed in a single future.
If <code>NULL</code>, then argument <code>future.scheduling</code> is used.</p>
</td></tr>
<tr><td><code id="future_eapply_+3A_n">n</code></td>
<td>
<p>The number of replicates.</p>
</td></tr>
<tr><td><code id="future_eapply_+3A_expr">expr</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> expression to evaluate repeatedly.</p>
</td></tr>
<tr><td><code id="future_eapply_+3A_simplify">simplify</code></td>
<td>
<p>See <code><a href="base.html#topic+lapply">base::sapply()</a></code> and <code><a href="base.html#topic+tapply">base::tapply()</a></code>, respectively.</p>
</td></tr>
<tr><td><code id="future_eapply_+3A_index">INDEX</code></td>
<td>
<p>A list of one or more factors, each of same length as <code>X</code>.
The elements are coerced to <code><a href="base.html#topic+factor">factor</a></code>s by
<code><a href="base.html#topic+as.factor">as.factor()</a></code>. Can also be a formula, which
is useful if <code>X</code> is a data frame; see the <code>f</code> argument in
<code><a href="base.html#topic+split">split()</a></code> for interpretation.</p>
</td></tr>
<tr><td><code id="future_eapply_+3A_default">default</code></td>
<td>
<p>See <code><a href="base.html#topic+tapply">base::tapply()</a></code>.</p>
</td></tr>
<tr><td><code id="future_eapply_+3A_fun.value">FUN.VALUE</code></td>
<td>
<p>A template for the required return value from
each <code>FUN(X[ii], ...)</code>.
Types may be promoted to a higher type within the ordering
logical &lt; integer &lt; double &lt; complex, but not demoted.
See <code><a href="base.html#topic+lapply">base::vapply()</a></code> for details.</p>
</td></tr>
<tr><td><code id="future_eapply_+3A_...">...</code></td>
<td>
<p>(optional) Additional arguments passed to <code>FUN()</code>.
For <code>future_*apply()</code> functions and <code>replicate()</code>, any <code style="white-space: pre;">&#8288;future.*&#8288;</code> arguments
part of <code style="white-space: pre;">&#8288;\ldots&#8288;</code> are passed on to <code>future_lapply()</code> used internally.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named (unless <code>USE.NAMES = FALSE</code>) list.
See <code><a href="base.html#topic+eapply">base::eapply()</a></code> for details.
</p>
<p>For <code>future_lapply()</code>, a list with same length and names as <code>X</code>.
See <code><a href="base.html#topic+lapply">base::lapply()</a></code> for details.
</p>
<p><code>future_replicate()</code> is a wrapper around <code>future_sapply()</code> and return
simplified object according to the <code>simplify</code> argument.
See <code><a href="base.html#topic+lapply">base::replicate()</a></code> for details.
Since <code>future_replicate()</code> usually involves random number generation (RNG),
it uses <code>future.seed = TRUE</code> by default in order produce sound random
numbers regardless of future backend and number of background workers used.
</p>
<p>For <code>future_sapply()</code>, a vector with same length and names as <code>X</code>.
See <code><a href="base.html#topic+lapply">base::sapply()</a></code> for details.
</p>
<p><code>future_tapply()</code> returns an array with mode <code>"list"</code>, unless
<code>simplify = TRUE</code> (default) <em>and</em> <code>FUN</code> returns a scalar, in which
case the mode of the array is the same as the returned scalars.
See <code><a href="base.html#topic+tapply">base::tapply()</a></code> for details.
</p>
<p>For <code>future_vapply()</code>, a vector with same length and names as <code>X</code>.
See <code><a href="base.html#topic+lapply">base::vapply()</a></code> for details.
</p>


<h3>Global variables</h3>

<p>Argument <code>future.globals</code> may be used to control how globals
should be handled similarly how the <code>globals</code> argument is used with
<code>future()</code>.
Since all function calls use the same set of globals, this function can do
any gathering of globals upfront (once), which is more efficient than if
it would be done for each future independently.
If <code>TRUE</code>, <code>NULL</code> or not is specified (default), then globals
are automatically identified and gathered.
If a character vector of names is specified, then those globals are gathered.
If a named list, then those globals are used as is.
In all cases, <code>FUN</code> and any <code style="white-space: pre;">&#8288;\ldots&#8288;</code> arguments are automatically
passed as globals to each future created as they are always needed.
</p>


<h3>Reproducible random number generation (RNG)</h3>

<p>Unless <code>future.seed</code> is <code>FALSE</code> or <code>NULL</code>, this function guarantees to
generate the exact same sequence of random numbers <em>given the same initial
seed / RNG state</em> - this regardless of type of futures, scheduling
(&quot;chunking&quot;) strategy, and number of workers.
</p>
<p>RNG reproducibility is achieved by pregenerating the random seeds for all
iterations (over <code>X</code>) by using L'Ecuyer-CMRG RNG streams.  In each
iteration, these seeds are set before calling <code>FUN(X[[ii]], ...)</code>.
<em>Note, for large <code>length(X)</code> this may introduce a large overhead.</em>
</p>
<p>If <code>future.seed = TRUE</code>, then <code><a href="base.html#topic+Random">.Random.seed</a></code>
is used if it holds a L'Ecuyer-CMRG RNG seed, otherwise one is created
randomly.
</p>
<p>If <code>future.seed = FALSE</code>, it is expected that none of the
<code>FUN(X[[ii]], ...)</code> function calls use random number generation.
If they do, then an informative warning or error is produces depending
on settings. See <a href="future.html#topic+future">future::future</a> for more details.
Using <code>future.seed = NULL</code>, is like <code>future.seed = FALSE</code> but without
the check whether random numbers were generated or not.
</p>
<p>As input, <code>future.seed</code> may also take a fixed initial seed (integer),
either as a full L'Ecuyer-CMRG RNG seed (vector of 1+6 integers), or
as a seed generating such a full L'Ecuyer-CMRG seed. This seed will
be used to generated <code>length(X)</code> L'Ecuyer-CMRG RNG streams.
</p>
<p>In addition to the above, it is possible to specify a pre-generated
sequence of RNG seeds as a list such that
<code>length(future.seed) == length(X)</code> and where each element is an
integer seed vector that can be assigned to
<code><a href="base.html#topic+Random">.Random.seed</a></code>.  One approach to generate a
set of valid RNG seeds based on fixed initial seed (here <code>42L</code>) is:
</p>
<div class="sourceCode r"><pre>seeds &lt;- future_lapply(seq_along(X), FUN = function(x) .Random.seed,
                       future.chunk.size = Inf, future.seed = 42L)
</pre></div>
<p><strong>Note that <code>as.list(seq_along(X))</code> is <em>not</em> a valid set of such
<code>.Random.seed</code> values.</strong>
</p>
<p>In all cases but <code>future.seed = FALSE</code> and <code>NULL</code>, the RNG state of the
calling R processes after this function returns is guaranteed to be
&quot;forwarded one step&quot; from the RNG state that was before the call and
in the same way regardless of <code>future.seed</code>, <code>future.scheduling</code>
and future strategy used.  This is done in order to guarantee that an <span class="rlang"><b>R</b></span>
script calling <code>future_lapply()</code> multiple times should be numerically
reproducible given the same initial seed.
</p>


<h3>Control processing order of elements</h3>

<p>Attribute <code>ordering</code> of <code>future.chunk.size</code> or <code>future.scheduling</code> can
be used to control the ordering the elements are iterated over, which
only affects the processing order and <em>not</em> the order values are returned.
This attribute can take the following values:
</p>

<ul>
<li><p> index vector - an numeric vector of length <code>length(X)</code>
</p>
</li>
<li><p> function     - an function taking one argument which is called as
<code>ordering(length(X))</code> and which must return an
index vector of length <code>length(X)</code>, e.g.
<code>function(n) rev(seq_len(n))</code> for reverse ordering.
</p>
</li>
<li> <p><code>"random"</code>   - this will randomize the ordering via random index
vector <code>sample.int(length(X))</code>.
For example, <code>future.scheduling = structure(TRUE, ordering = "random")</code>.
<em>Note</em>, when elements are processed out of order, then captured standard
output and conditions are also relayed in that order, that is out of order.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>The implementations of <code>future_replicate()</code>, <code>future_sapply()</code>, and
<code>future_tapply()</code> are adopted from the source code of the corresponding
base <span class="rlang"><b>R</b></span> functions, which are licensed under GPL (&gt;= 2) with
'The R Core Team' as the copyright holder.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## ---------------------------------------------------------
## lapply(), sapply(), tapply()
## ---------------------------------------------------------
x &lt;- list(a = 1:10, beta = exp(-3:3), logic = c(TRUE, FALSE, FALSE, TRUE))
y0 &lt;- lapply(x, FUN = quantile, probs = 1:3/4)
y1 &lt;- future_lapply(x, FUN = quantile, probs = 1:3/4)
print(y1)
stopifnot(all.equal(y1, y0))

y0 &lt;- sapply(x, FUN = quantile)
y1 &lt;- future_sapply(x, FUN = quantile)
print(y1)
stopifnot(all.equal(y1, y0))

y0 &lt;- vapply(x, FUN = quantile, FUN.VALUE = double(5L))
y1 &lt;- future_vapply(x, FUN = quantile, FUN.VALUE = double(5L))
print(y1)
stopifnot(all.equal(y1, y0))


## ---------------------------------------------------------
## Parallel Random Number Generation
## ---------------------------------------------------------

## Regardless of the future plan, the number of workers, and
## where they are, the random numbers produced are identical

plan(multisession)
set.seed(0xBEEF)
y1 &lt;- future_lapply(1:5, FUN = rnorm, future.seed = TRUE)
str(y1)

plan(sequential)
set.seed(0xBEEF)
y2 &lt;- future_lapply(1:5, FUN = rnorm, future.seed = TRUE)
str(y2)

stopifnot(all.equal(y1, y2))



## ---------------------------------------------------------
## Process chunks of data.frame rows in parallel
## ---------------------------------------------------------
iris &lt;- datasets::iris
chunks &lt;- split(iris, seq(1, nrow(iris), length.out = 3L))
y0 &lt;- lapply(chunks, FUN = function(iris) sum(iris$Sepal.Length))
y0 &lt;- do.call(sum, y0)
y1 &lt;- future_lapply(chunks, FUN = function(iris) sum(iris$Sepal.Length))
y1 &lt;- do.call(sum, y1)
print(y1)
stopifnot(all.equal(y1, y0))



</code></pre>

<hr>
<h2 id='future_Map'>Apply a Function to Multiple List or Vector Arguments</h2><span id='topic+future_Map'></span><span id='topic+future_mapply'></span><span id='topic+future_.mapply'></span>

<h3>Description</h3>

<p><code>future_mapply()</code> implements <code><a href="base.html#topic+mapply">base::mapply()</a></code> using futures with perfect
replication of results, regardless of future backend used.
Analogously to <code>mapply()</code>, <code>future_mapply()</code> is a multivariate version of
<code>future_sapply()</code>.
It applies <code>FUN</code> to the first elements of each <code style="white-space: pre;">&#8288;\ldots&#8288;</code> argument,
the second elements, the third elements, and so on.
Arguments are recycled if necessary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>future_Map(
  f,
  ...,
  future.envir = parent.frame(),
  future.label = "future_Map-%d"
)

future_mapply(
  FUN,
  ...,
  MoreArgs = NULL,
  SIMPLIFY = TRUE,
  USE.NAMES = TRUE,
  future.envir = parent.frame(),
  future.stdout = TRUE,
  future.conditions = "condition",
  future.globals = TRUE,
  future.packages = NULL,
  future.seed = FALSE,
  future.scheduling = 1,
  future.chunk.size = NULL,
  future.label = "future_mapply-%d"
)

future_.mapply(FUN, dots, MoreArgs, ..., future.label = "future_.mapply-%d")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="future_Map_+3A_f">f</code></td>
<td>
<p>A function of the arity <code class="reqn">k</code> if <code>future_Map()</code> is called with
<code class="reqn">k</code> arguments.</p>
</td></tr>
<tr><td><code id="future_Map_+3A_future.envir">future.envir</code></td>
<td>
<p>An <a href="base.html#topic+environment">environment</a> passed as argument <code>envir</code> to
<code><a href="future.html#topic+future">future::future()</a></code> as-is.</p>
</td></tr>
<tr><td><code id="future_Map_+3A_future.label">future.label</code></td>
<td>
<p>If a character string, then each future is assigned
a label <code>sprintf(future.label, chunk_idx)</code>.  If TRUE, then the
same as <code>future.label = "future_lapply-%d"</code>.  If FALSE, no labels
are assigned.</p>
</td></tr>
<tr><td><code id="future_Map_+3A_fun">FUN</code></td>
<td>
<p>A function to apply, found via <code><a href="base.html#topic+match.fun">base::match.fun()</a></code>.</p>
</td></tr>
<tr><td><code id="future_Map_+3A_moreargs">MoreArgs</code></td>
<td>
<p>A list of other arguments to <code>FUN</code>.</p>
</td></tr>
<tr><td><code id="future_Map_+3A_simplify">SIMPLIFY</code></td>
<td>
<p>A logical or character string; attempt to reduce the
result to a vector, matrix or higher dimensional array; see the simplify
argument of <code><a href="base.html#topic+lapply">base::sapply()</a></code>.</p>
</td></tr>
<tr><td><code id="future_Map_+3A_use.names">USE.NAMES</code></td>
<td>
<p>A logical; use names if the first <code style="white-space: pre;">&#8288;\ldots&#8288;</code> argument has
names, or if it is a character vector, use that character vector as the
names.</p>
</td></tr>
<tr><td><code id="future_Map_+3A_future.stdout">future.stdout</code></td>
<td>
<p>If <code>TRUE</code> (default), then the standard output of the
underlying futures is captured, and re-outputted as soon as possible.
If <code>FALSE</code>, any output is silenced (by sinking it to the null device
as it is outputted).
If <code>NA</code> (not recommended), output is <em>not</em> intercepted.</p>
</td></tr>
<tr><td><code id="future_Map_+3A_future.conditions">future.conditions</code></td>
<td>
<p>A character string of conditions classes to be
captured and relayed.  The default is the same as the <code>condition</code>
argument of <code><a href="future.html#topic+Future-class">future::Future()</a></code>.
To not intercept conditions, use <code>conditions = character(0L)</code>.
Errors are always relayed.</p>
</td></tr>
<tr><td><code id="future_Map_+3A_future.globals">future.globals</code></td>
<td>
<p>A logical, a character vector, or a named list for
controlling how globals are handled.
For details, see <code><a href="#topic+future_lapply">future_lapply()</a></code>.</p>
</td></tr>
<tr><td><code id="future_Map_+3A_future.packages">future.packages</code></td>
<td>
<p>(optional) a character vector specifying packages
to be attached in the R environment evaluating the future.</p>
</td></tr>
<tr><td><code id="future_Map_+3A_future.seed">future.seed</code></td>
<td>
<p>A logical or an integer (of length one or seven), or
a list of <code>max(lengths(list(...)))</code> with pre-generated random seeds.
For details, see <code><a href="#topic+future_lapply">future_lapply()</a></code>.</p>
</td></tr>
<tr><td><code id="future_Map_+3A_future.scheduling">future.scheduling</code></td>
<td>
<p>Average number of futures (&quot;chunks&quot;) per worker.
If <code>0.0</code>, then a single future is used to process all elements
of <code>X</code>.
If <code>1.0</code> or <code>TRUE</code>, then one future per worker is used.
If <code>2.0</code>, then each worker will process two futures
(if there are enough elements in <code>X</code>).
If <code>Inf</code> or <code>FALSE</code>, then one future per element of
<code>X</code> is used.
Only used if <code>future.chunk.size</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="future_Map_+3A_future.chunk.size">future.chunk.size</code></td>
<td>
<p>The average number of elements per future (&quot;chunk&quot;).
If <code>Inf</code>, then all elements are processed in a single future.
If <code>NULL</code>, then argument <code>future.scheduling</code> is used.</p>
</td></tr>
<tr><td><code id="future_Map_+3A_dots">dots</code></td>
<td>
<p>A list of arguments to vectorize over (vectors or lists of
strictly positive length, or all of zero length).</p>
</td></tr>
<tr><td><code id="future_Map_+3A_...">...</code></td>
<td>
<p>Arguments to vectorize over, will be recycled to common
length, or zero if one of them is of length zero.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that <code><a href="base.html#topic+mapply">base::.mapply()</a></code>, which <code>future_.mapply()</code> is modeled after
is listed as an &quot;internal&quot; function in <span class="rlang"><b>R</b></span> despite being exported.
</p>


<h3>Value</h3>

<p><code>future_Map()</code> is a simple wrapper to <code>future_mapply()</code> which does not
attempt to simplify the result.
See <code><a href="base.html#topic+funprog">base::Map()</a></code> for details.
</p>
<p><code>future_mapply()</code> returns a list, or for <code>SIMPLIFY = TRUE</code>, a vector,
array or list.  See <code><a href="base.html#topic+mapply">base::mapply()</a></code> for details.
</p>
<p><code>future_.mapply()</code> returns a list. See <code><a href="base.html#topic+mapply">base::.mapply()</a></code> for details.
</p>


<h3>Author(s)</h3>

<p>The implementations of <code>future_Map()</code> is adopted from the source code
of the corresponding base <span class="rlang"><b>R</b></span> function <code>Map()</code>, which is licensed under
GPL (&gt;= 2) with 'The R Core Team' as the copyright holder.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## ---------------------------------------------------------
## mapply()
## ---------------------------------------------------------
y0 &lt;- mapply(rep, 1:4, 4:1)
y1 &lt;- future_mapply(rep, 1:4, 4:1)
stopifnot(identical(y1, y0))

y0 &lt;- mapply(rep, times = 1:4, x = 4:1)
y1 &lt;- future_mapply(rep, times = 1:4, x = 4:1)
stopifnot(identical(y1, y0))

y0 &lt;- mapply(rep, times = 1:4, MoreArgs = list(x = 42))
y1 &lt;- future_mapply(rep, times = 1:4, MoreArgs = list(x = 42))
stopifnot(identical(y1, y0))

y0 &lt;- mapply(function(x, y) seq_len(x) + y,
             c(a =  1, b = 2, c = 3),  # names from first
             c(A = 10, B = 0, C = -10))
y1 &lt;- future_mapply(function(x, y) seq_len(x) + y,
                    c(a =  1, b = 2, c = 3),  # names from first
                    c(A = 10, B = 0, C = -10))
stopifnot(identical(y1, y0))

word &lt;- function(C, k) paste(rep.int(C, k), collapse = "")
y0 &lt;- mapply(word, LETTERS[1:6], 6:1, SIMPLIFY = FALSE)
y1 &lt;- future_mapply(word, LETTERS[1:6], 6:1, SIMPLIFY = FALSE)
stopifnot(identical(y1, y0))


## ---------------------------------------------------------
## Parallel Random Number Generation
## ---------------------------------------------------------

## Regardless of the future plan, the number of workers, and
## where they are, the random numbers produced are identical

plan(multisession)
set.seed(0xBEEF)
y1 &lt;- future_mapply(stats::runif, n = 1:4, max = 2:5,
                    MoreArgs = list(min = 1), future.seed = TRUE)
print(y1)

plan(sequential)
set.seed(0xBEEF)
y2 &lt;- future_mapply(stats::runif, n = 1:4, max = 2:5,
                    MoreArgs = list(min = 1), future.seed = TRUE)
print(y2)

stopifnot(all.equal(y1, y2))



</code></pre>

<hr>
<h2 id='future.apply'>future.apply: Apply Function to Elements in Parallel using Futures</h2><span id='topic+future.apply'></span><span id='topic+future.apply-package'></span>

<h3>Description</h3>

<p>The <span class="pkg">future.apply</span> packages provides parallel implementations of
common &quot;apply&quot; functions provided by base <span class="rlang"><b>R</b></span>.  The parallel processing
is performed via the <span class="pkg">future</span> ecosystem, which provides a large
number of parallel backends, e.g. on the local machine, a remote cluster,
and a high-performance compute cluster.
</p>


<h3>Details</h3>

<p>Currently implemented functions are:
</p>

<ul>
<li> <p><code><a href="#topic+future_apply">future_apply()</a></code>: a parallel version of <a href="base.html#topic+apply">apply()</a>
</p>
</li>
<li> <p><code><a href="#topic+future_by">future_by()</a></code>: a parallel version of <a href="base.html#topic+by">by()</a>
</p>
</li>
<li> <p><code><a href="#topic+future_eapply">future_eapply()</a></code>: a parallel version of <a href="base.html#topic+lapply">eapply()</a>
</p>
</li>
<li> <p><code><a href="#topic+future_lapply">future_lapply()</a></code>: a parallel version of <a href="base.html#topic+lapply">lapply()</a>
</p>
</li>
<li> <p><code><a href="#topic+future_mapply">future_mapply()</a></code>: a parallel version of <a href="base.html#topic+mapply">mapply()</a>
</p>
</li>
<li> <p><code><a href="#topic+future_sapply">future_sapply()</a></code>: a parallel version of <a href="base.html#topic+lapply">sapply()</a>
</p>
</li>
<li> <p><code><a href="#topic+future_tapply">future_tapply()</a></code>: a parallel version of <a href="base.html#topic+tapply">tapply()</a>
</p>
</li>
<li> <p><code><a href="#topic+future_vapply">future_vapply()</a></code>: a parallel version of <a href="base.html#topic+lapply">vapply()</a>
</p>
</li>
<li> <p><code><a href="#topic+future_Map">future_Map()</a></code>: a parallel version of <a href="base.html#topic+funprog">Map()</a>
</p>
</li>
<li> <p><code><a href="#topic+future_replicate">future_replicate()</a></code>: a parallel version of <a href="base.html#topic+lapply">replicate()</a>
</p>
</li>
<li> <p><code><a href="#topic+future_.mapply">future_.mapply()</a></code>: a parallel version of <a href="base.html#topic+mapply">.mapply()</a>
</p>
</li></ul>

<p>Reproducibility is part of the core design, which means that perfect,
parallel random number generation (RNG) is supported regardless of the
amount of chunking, type of load balancing, and future backend being used.
</p>
<p>Since these <code style="white-space: pre;">&#8288;future_*()&#8288;</code> functions have the same arguments as the
corresponding base <span class="rlang"><b>R</b></span> function, start using them is often as simple as
renaming the function in the code.  For example, after attaching the package:
</p>
<div class="sourceCode r"><pre>library(future.apply)
</pre></div>
<p>code such as:
</p>
<div class="sourceCode r"><pre>x &lt;- list(a = 1:10, beta = exp(-3:3), logic = c(TRUE,FALSE,FALSE,TRUE))
y &lt;- lapply(x, quantile, probs = 1:3/4)
</pre></div>
<p>can be updated to:
</p>
<div class="sourceCode r"><pre>y &lt;- future_lapply(x, quantile, probs = 1:3/4)
</pre></div>
<p>The default settings in the <span class="pkg">future</span> framework is to process code
<em>sequentially</em>.  To run the above in parallel on the local machine
(on any operating system), use:
</p>
<div class="sourceCode r"><pre>plan(multisession)
</pre></div>
<p>first.  That's it!
</p>
<p>To go back to sequential processing, use <code>plan(sequential)</code>.
If you have access to multiple machines on your local network, use:
</p>
<div class="sourceCode r"><pre>plan(cluster, workers = c("n1", "n2", "n2", "n3"))
</pre></div>
<p>This will set up four workers, one on <code>n1</code> and <code>n3</code>, and two on <code>n2</code>.
If you have SSH access to some remote machines, use:
</p>
<div class="sourceCode r"><pre>plan(cluster, workers = c("m1.myserver.org", "m2.myserver.org))
</pre></div>
<p>See the <span class="pkg">future</span> package and <code><a href="future.html#topic+plan">future::plan()</a></code> for more examples.
</p>
<p>The <span class="pkg">future.batchtools</span> package provides support for high-performance
compute (HPC) cluster schedulers such as SGE, Slurm, and TORQUE / PBS.
For example,
</p>

<ul>
<li> <p><code>plan(batchtools_slurm)</code>:
Process via a Slurm scheduler job queue.
</p>
</li>
<li> <p><code>plan(batchtools_torque)</code>:
Process via a TORQUE / PBS scheduler job queue.
</p>
</li></ul>

<p>This builds on top of the queuing framework that the <span class="pkg">batchtools</span>
package provides. For more details on backend configuration, please see
the <span class="pkg">future.batchtools</span> and <span class="pkg">batchtools</span> packages.
</p>
<p>These are just a few examples of parallel/distributed backend for the
future ecosystem.  For more alternatives, see the 'Reverse dependencies'
section on the
<a href="https://cran.r-project.org/package=future">future CRAN package page</a>.
</p>


<h3>Author(s)</h3>

<p>Henrik Bengtsson, except for the implementations of <code>future_apply()</code>,
<code>future_Map()</code>, <code>future_replicate()</code>, <code>future_sapply()</code>, and
<code>future_tapply()</code>, which are adopted from the source code of the
corresponding base <span class="rlang"><b>R</b></span> functions, which are licensed under GPL (&gt;= 2)
with 'The R Core Team' as the copyright holder.
Because of these dependencies, the license of this package is GPL (&gt;= 2).
</p>

<hr>
<h2 id='future.apply.options'>Options used for future.apply</h2><span id='topic+future.apply.options'></span><span id='topic+future.apply.debug'></span><span id='topic+R_FUTURE_APPLY_DEBUG'></span>

<h3>Description</h3>

<p>Below are the <span class="rlang"><b>R</b></span> options and environment variables that are used by the
<span class="pkg">future.apply</span> package and packages enhancing it.<br />
<br />
<em>WARNING: Note that the names and the default values of these options may
change in future versions of the package.  Please use with care until
further notice.</em>
</p>


<h3>Details</h3>

<p>For settings specific to the <span class="pkg">future</span> package, see
<a href="future.html#topic+future.options">future::future.options</a> page.
</p>


<h3>Options for debugging future.apply</h3>


<dl>
<dt><span class="option">future.apply.debug</span>:</dt><dd><p>(logical) If <code>TRUE</code>, extensive debug messages are generated. (Default: <code>FALSE</code>)</p>
</dd>
</dl>



<h3>Environment variables that set R options</h3>

<p>All of the above <span class="rlang"><b>R</b></span> <span class="option">future.apply.*</span> options can be set by
corresponding environment variable <span class="env">R_FUTURE_APPLY_*</span> <em>when the
<span class="pkg">future.apply</span> package is loaded</em>.
For example, if <code>R_FUTURE_APPLY_DEBUG = "TRUE"</code>, then option
<span class="option">future.apply.debug</span> is set to <code>TRUE</code> (logical).
</p>


<h3>See Also</h3>

<p>To set <span class="rlang"><b>R</b></span> options or environment variables when <span class="rlang"><b>R</b></span> starts (even before the <span class="pkg">future</span> package is loaded), see the <a href="base.html#topic+Startup">Startup</a> help page.  The <a href="https://cran.r-project.org/package=startup"><span class="pkg">startup</span></a> package provides a friendly mechanism for configuring <span class="rlang"><b>R</b></span>'s startup process.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
options(future.apply.debug = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='makeChunks'>Create Chunks of Index Vectors</h2><span id='topic+makeChunks'></span>

<h3>Description</h3>

<p><em>This is an internal function.</em>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeChunks(
  nbrOfElements,
  nbrOfWorkers,
  future.scheduling = 1,
  future.chunk.size = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeChunks_+3A_nbrofelements">nbrOfElements</code></td>
<td>
<p>(integer) Total number of elements to iterate over.</p>
</td></tr>
<tr><td><code id="makeChunks_+3A_nbrofworkers">nbrOfWorkers</code></td>
<td>
<p>(integer) Number of workers available.</p>
</td></tr>
<tr><td><code id="makeChunks_+3A_future.scheduling">future.scheduling</code></td>
<td>
<p>(numeric) A strictly positive scalar.
Only used if argument <code>future.chunk.size</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="makeChunks_+3A_future.chunk.size">future.chunk.size</code></td>
<td>
<p>(numeric) The maximum number of elements per
chunk, or <code>NULL</code>.  If <code>NULL</code>, then the chunk sizes are given by the
<code>future.scheduling</code> argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of chunks, where each chunk is an integer vector of
unique indices <code>[1, nbrOfElements]</code>.  The union of all chunks
holds <code>nbrOfElements</code> elements and equals <code>1:nbrOfElements</code>.
If <code>nbrOfElements == 0</code>, then an empty list is returned.
</p>


<h3>Control processing order of elements</h3>

<p>Attribute <code>ordering</code> of <code>future.chunk.size</code> or <code>future.scheduling</code> can
be used to control the ordering the elements are iterated over, which
only affects the processing order <em>not</em> the order values are returned.
This attribute can take the following values:
</p>

<ul>
<li><p> index vector - an numeric vector of length <code>nbrOfElements</code> specifying
how elements are remapped
</p>
</li>
<li><p> function     - an function taking one argument which is called as
<code>ordering(nbrOfElements)</code> and which must return an
index vector of length <code>nbrOfElements</code>, e.g.
<code>function(n) rev(seq_len(n))</code> for reverse ordering.
</p>
</li>
<li> <p><code>"random"</code>   - this will randomize the ordering via random index
vector <code>sample.int(nbrOfElements)</code>.
</p>
</li></ul>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
