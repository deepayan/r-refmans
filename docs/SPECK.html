<!DOCTYPE html><html lang="en"><head><title>Help for package SPECK</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SPECK}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#SPECK-package'><p>SPECK: Receptor Abundance Estimation using Reduced Rank Reconstruction and Clustered Thresholding</p></a></li>
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#ckmeansThreshold'><p>Clustered thresholding of a vector.</p></a></li>
<li><a href='#pbmc.rna.mat'><p>Single cell RNA-sequencing (scRNA-seq) peripheral blood (PBMC) data sample.</p></a></li>
<li><a href='#randomizedRRR'><p>Reduced rank reconstruction (RRR) of a matrix.</p></a></li>
<li><a href='#speck'><p>Abundance estimation for single cell RNA-sequencing (scRNA-seq) data.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Receptor Abundance Estimation using Reduced Rank Reconstruction
and Clustered Thresholding</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Azka Javaid &lt;azka.javaid.gr@dartmouth.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Surface Protein abundance Estimation using CKmeans-based clustered thresholding ('SPECK') is an unsupervised learning-based method that performs receptor abundance estimation for single cell RNA-sequencing data based on reduced rank reconstruction (RRR) and a clustered thresholding mechanism. Seurat's normalization method is described in: Hao et al., (2021) &lt;<a href="https://doi.org/10.1016%2Fj.cell.2021.04.048">doi:10.1016/j.cell.2021.04.048</a>&gt;, Stuart et al., (2019) &lt;<a href="https://doi.org/10.1016%2Fj.cell.2019.05.031">doi:10.1016/j.cell.2019.05.031</a>&gt;, Butler et al., (2018) &lt;<a href="https://doi.org/10.1038%2Fnbt.4096">doi:10.1038/nbt.4096</a>&gt; and Satija et al., (2015) &lt;<a href="https://doi.org/10.1038%2Fnbt.3192">doi:10.1038/nbt.3192</a>&gt;. Method for the RRR is further detailed in: Erichson et al., (2019) &lt;<a href="https://doi.org/10.18637%2Fjss.v089.i11">doi:10.18637/jss.v089.i11</a>&gt; and Halko et al., (2009) &lt;<a href="https://doi.org/10.48550/arXiv.0909.4061">doi:10.48550/arXiv.0909.4061</a>&gt;. Clustering method is outlined in: Song et al., (2020) &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtaa613">doi:10.1093/bioinformatics/btaa613</a>&gt; and Wang et al., (2011) &lt;<a href="https://doi.org/10.32614%2FRJ-2011-015">doi:10.32614/RJ-2011-015</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2, gridExtra, knitr, rmarkdown, SeuratObject, usethis</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Ckmeans.1d.dp, magrittr, Matrix (&ge; 1.6.1.1), rsvd, Seurat</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-17 15:06:41 UTC; azkajavaid</td>
</tr>
<tr>
<td>Author:</td>
<td>H. Robert Frost [aut],
  Azka Javaid [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-17 17:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='SPECK-package'>SPECK: Receptor Abundance Estimation using Reduced Rank Reconstruction and Clustered Thresholding</h2><span id='topic+SPECK-package'></span><span id='topic+_PACKAGE'></span>

<h3>Description</h3>

<p>Surface Protein abundance Estimation using CKmeans-based clustered thresholding ('SPECK') is an unsupervised learning-based method that performs receptor abundance estimation for single cell RNA-sequencing data based on reduced rank reconstruction (RRR) and a clustered thresholding mechanism. Seurat's normalization method is described in: Hao et al., (2021) <a href="https://doi.org/10.1016/j.cell.2021.04.048">doi:10.1016/j.cell.2021.04.048</a>, Stuart et al., (2019) <a href="https://doi.org/10.1016/j.cell.2019.05.031">doi:10.1016/j.cell.2019.05.031</a>, Butler et al., (2018) <a href="https://doi.org/10.1038/nbt.4096">doi:10.1038/nbt.4096</a> and Satija et al., (2015) <a href="https://doi.org/10.1038/nbt.3192">doi:10.1038/nbt.3192</a>. Method for the RRR is further detailed in: Erichson et al., (2019) <a href="https://doi.org/10.18637/jss.v089.i11">doi:10.18637/jss.v089.i11</a> and Halko et al., (2009) <a href="https://arxiv.org/abs/0909.4061">arXiv:0909.4061</a>. Clustering method is outlined in: Song et al., (2020) <a href="https://doi.org/10.1093/bioinformatics/btaa613">doi:10.1093/bioinformatics/btaa613</a> and Wang et al., (2011) <a href="https://doi.org/10.32614/RJ-2011-015">doi:10.32614/RJ-2011-015</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Azka Javaid <a href="mailto:azka.javaid.gr@dartmouth.edu">azka.javaid.gr@dartmouth.edu</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> H. Robert Frost <a href="mailto:hildreth.r.frost@dartmouth.edu">hildreth.r.frost@dartmouth.edu</a>
</p>
</li></ul>


<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling 'rhs(lhs)'.
</p>

<hr>
<h2 id='ckmeansThreshold'>Clustered thresholding of a vector.</h2><span id='topic+ckmeansThreshold'></span>

<h3>Description</h3>

<p>Performs thresholding for a vector of length <code class="reqn">m</code> from a corresponding <code class="reqn">m x n</code> reduced rank
reconstructed (RRR) matrix. Thresholding of a vector is only performed
if more than one cluster is identified using the <code><a href="Ckmeans.1d.dp.html#topic+Ckmeans.1d.dp">Ckmeans.1d.dp::Ckmeans.1d.dp()</a></code> function
based on a one-dimensional dynamic programming clustering algorithm, which functions
by minimizing the sum of squares of within-cluster distances from an element to its associated cluster mean. If more than
one cluster is present, then the RRR output corresponding to the nonzero elements of the least-valued cluster, as identified by
the cluster mean, is set to zero. All other values in the least and higher-valued clusters are retained.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ckmeansThreshold(rrr.vector, max.num.clusters = 4, seed.ckmeans = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ckmeansThreshold_+3A_rrr.vector">rrr.vector</code></td>
<td>
<p>Vector of length <code class="reqn">m</code> from the corresponding <code class="reqn">m x n</code>
RRR matrix.</p>
</td></tr>
<tr><td><code id="ckmeansThreshold_+3A_max.num.clusters">max.num.clusters</code></td>
<td>
<p>Maximum number of clusters for computation.</p>
</td></tr>
<tr><td><code id="ckmeansThreshold_+3A_seed.ckmeans">seed.ckmeans</code></td>
<td>
<p>Seed specified to ensure reproducibility of the clustered thresholding.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p> rrr.thresholded.vector - A thresholded vector of length <code class="reqn">m</code>.
</p>
</li>
<li><p> num.centers - Number of identified clusters.
</p>
</li>
<li><p> max.clust.prop - Proportion of samples with the specified maximum number of clusters.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>set.seed(10)
data.mat &lt;- matrix(data = rbinom(n = 18400, size = 230, prob = 0.01), nrow = 80)
rrr.object &lt;- randomizedRRR(counts.matrix = data.mat, rank.range.end = 60,
min.consec.diff = 0.01, rep.consec.diff = 2,
manual.rank = NULL, seed.rsvd = 1)
thresh.full.output &lt;- ckmeansThreshold(rrr.vector = rrr.object$rrr.mat[,1],
max.num.clusters = 4, seed.ckmeans = 2)
head(thresh.full.output$rrr.thresholded.vector)
print(thresh.full.output$num.centers)
print(thresh.full.output$max.clust.prop)

</code></pre>

<hr>
<h2 id='pbmc.rna.mat'>Single cell RNA-sequencing (scRNA-seq) peripheral blood (PBMC) data sample.</h2><span id='topic+pbmc.rna.mat'></span>

<h3>Description</h3>

<p>Single cell RNA-sequencing (scRNA-seq) subset of the Hao et al. 2021 human peripheral blood mononuclear cell (PBMC) data (GEO: GSE164378, DOI: 10.1016/j.cell.2021.04.048).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pbmc.rna.mat
</code></pre>


<h3>Format</h3>

<p>A scRNA-seq data of dgCMatrix class with 1000 rows and 33538 columns
</p>

<dl>
<dt>pbmc.rna.mat</dt><dd><p>RNA expression data for 1000 cells and 33538 genes</p>
</dd>
</dl>


<hr>
<h2 id='randomizedRRR'>Reduced rank reconstruction (RRR) of a matrix.</h2><span id='topic+randomizedRRR'></span>

<h3>Description</h3>

<p>Computes the rank and subsequent RRR of a <code class="reqn">m x n</code> counts matrix. Log-normalization is first performed
using the <code><a href="Seurat.html#topic+NormalizeData">Seurat::NormalizeData()</a></code> function. RRR is next performed on the normalized <code class="reqn">m x n</code>
matrix using randomized Singular Value Decomposition with the <code><a href="rsvd.html#topic+rsvd">rsvd::rsvd()</a></code> function. Estimated rank is selected via a
construction of the standard deviations of non-centered sample principal components, which are used in a subsequent rate of change computation
where each successive standard deviation value is compared to the previous to determine the rank at which the absolute value of the rate of change
between consecutive values is at least 0.01 for at least two value pairs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randomizedRRR(
  counts.matrix,
  rank.range.end = 100,
  min.consec.diff = 0.01,
  rep.consec.diff = 2,
  manual.rank = NULL,
  seed.rsvd = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="randomizedRRR_+3A_counts.matrix">counts.matrix</code></td>
<td>
<p>A <code class="reqn">m x n</code> counts matrix.</p>
</td></tr>
<tr><td><code id="randomizedRRR_+3A_rank.range.end">rank.range.end</code></td>
<td>
<p>Upper value of the rank for RRR.</p>
</td></tr>
<tr><td><code id="randomizedRRR_+3A_min.consec.diff">min.consec.diff</code></td>
<td>
<p>Minimum difference in the rate of change between a pair of successive standard deviation estimate.</p>
</td></tr>
<tr><td><code id="randomizedRRR_+3A_rep.consec.diff">rep.consec.diff</code></td>
<td>
<p>Frequency of the minimum difference in the rate of change between a pair of successive standard deviation estimate.</p>
</td></tr>
<tr><td><code id="randomizedRRR_+3A_manual.rank">manual.rank</code></td>
<td>
<p>Optional, user-specified upper value of the rank used
for RRR as an alternative to automatically computed rank.</p>
</td></tr>
<tr><td><code id="randomizedRRR_+3A_seed.rsvd">seed.rsvd</code></td>
<td>
<p>Seed specified to ensure reproducibility of the RRR.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p> rrr.mat - A <code class="reqn">m x n</code> RRR matrix.
</p>
</li>
<li><p> rrr.rank - Automatically computed rank.
</p>
</li>
<li><p> component.stdev - A vector corresponding to standard deviations of non-centered sample principal components.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>set.seed(10)
data.mat &lt;- matrix(data = rbinom(n = 18400, size = 230, prob = 0.2), nrow = 80)
rrr.object &lt;- randomizedRRR(counts.matrix = data.mat, rank.range.end = 60,
min.consec.diff = 0.01, rep.consec.diff = 2,
manual.rank = NULL, seed.rsvd = 1)
print(rrr.object$component.stdev)
print(rrr.object$rrr.rank)
dim(rrr.object$rrr.mat); str(rrr.object$rrr.mat)
</code></pre>

<hr>
<h2 id='speck'>Abundance estimation for single cell RNA-sequencing (scRNA-seq) data.</h2><span id='topic+speck'></span>

<h3>Description</h3>

<p>Performs normalization, reduced rank reconstruction (RRR) and thresholding for a <code class="reqn">m x n</code> scRNA-seq matrix
with <code class="reqn">m</code> samples and <code class="reqn">n</code> genes. The <code><a href="#topic+speck">speck()</a></code> function calls the
<code><a href="#topic+randomizedRRR">randomizedRRR()</a></code> function on the scRNA-seq matrix. Thresholding is next
applied to each gene from the <code class="reqn">m x n</code> RRR matrix using the <code><a href="#topic+ckmeansThreshold">ckmeansThreshold()</a></code>
function, resulting in a <code class="reqn">m x n</code> thresholded matrix. See documentation for the <code><a href="#topic+randomizedRRR">randomizedRRR()</a></code> and
<code><a href="#topic+ckmeansThreshold">ckmeansThreshold()</a></code> functions for individual implementation details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>speck(
  counts.matrix,
  rank.range.end = 100,
  min.consec.diff = 0.01,
  rep.consec.diff = 2,
  manual.rank = NULL,
  max.num.clusters = 4,
  seed.rsvd = 1,
  seed.ckmeans = 2
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="speck_+3A_counts.matrix">counts.matrix</code></td>
<td>
<p><code class="reqn">m x n</code> scRNA-seq counts matrix with <code class="reqn">m</code> samples
and <code class="reqn">n</code> genes.</p>
</td></tr>
<tr><td><code id="speck_+3A_rank.range.end">rank.range.end</code></td>
<td>
<p>Upper value of the rank for RRR.</p>
</td></tr>
<tr><td><code id="speck_+3A_min.consec.diff">min.consec.diff</code></td>
<td>
<p>Minimum difference in the rate of change between a pair of successive standard deviation estimate.</p>
</td></tr>
<tr><td><code id="speck_+3A_rep.consec.diff">rep.consec.diff</code></td>
<td>
<p>Frequency of the minimum difference in the rate of change between a pair of successive standard deviation estimate.</p>
</td></tr>
<tr><td><code id="speck_+3A_manual.rank">manual.rank</code></td>
<td>
<p>Optional, user-specified upper value of the rank used
for RRR as an alternative to automatically computed rank.</p>
</td></tr>
<tr><td><code id="speck_+3A_max.num.clusters">max.num.clusters</code></td>
<td>
<p>Maximum number of clusters for computation.</p>
</td></tr>
<tr><td><code id="speck_+3A_seed.rsvd">seed.rsvd</code></td>
<td>
<p>Seed specified to ensure reproducibility of the RRR.</p>
</td></tr>
<tr><td><code id="speck_+3A_seed.ckmeans">seed.ckmeans</code></td>
<td>
<p>Seed specified to ensure reproducibility of the clustered thresholding.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p> thresholded.mat - A <code class="reqn">m x n</code> thresholded RRR matrix with <code class="reqn">m</code> samples and <code class="reqn">n</code> genes.
</p>
</li>
<li><p> rrr.mat - A <code class="reqn">m x n</code> RRR matrix with <code class="reqn">m</code> samples and <code class="reqn">n</code> genes.
</p>
</li>
<li><p> rrr.rank - Automatically computed rank.
</p>
</li>
<li><p> component.stdev - A vector corresponding to standard deviations of non-centered sample principal components.
</p>
</li>
<li><p> clust.num - A vector of length <code class="reqn">n</code> indicating the number of clusters identified by the
<code><a href="Ckmeans.1d.dp.html#topic+Ckmeans.1d.dp">Ckmeans.1d.dp()</a></code> algorithm for each gene.
</p>
</li>
<li><p> clust.max.prop - A vector of length <code class="reqn">n</code> indicating the proportion of samples with the
specified maximum number of clusters for each gene.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>set.seed(10)
data.mat &lt;- matrix(data = rbinom(n = 18400, size = 230, prob = 0.01), nrow = 80)
speck.full &lt;- speck(counts.matrix = data.mat, rank.range.end = 60,
min.consec.diff = 0.01, rep.consec.diff = 2,
manual.rank = NULL, max.num.clusters = 4,
seed.rsvd = 1, seed.ckmeans = 2)
print(speck.full$component.stdev)
print(speck.full$rrr.rank)
head(speck.full$clust.num); table(speck.full$clust.num)
head(speck.full$clust.max.prop); table(speck.full$clust.max.prop)
speck.output &lt;- speck.full$thresholded.mat
dim(speck.output); str(speck.output)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
