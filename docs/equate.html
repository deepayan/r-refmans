<!DOCTYPE html><html><head><title>Help for package equate</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {equate}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ACTmath'><p>ACT Mathematics Test Scores</p></a></li>
<li><a href='#bootstrap'><p>Bootstrap Equating Error</p></a></li>
<li><a href='#composite'><p>Composite Linking and Equating</p></a></li>
<li><a href='#equate'><p>Observed Score Linking and Equating</p></a></li>
<li><a href='#equate-package'><p>Observed-Score Linking and Equating</p></a></li>
<li><a href='#freqtab'><p>Frequency Distribution Tables</p></a></li>
<li><a href='#KBneat'><p>Test Scores under a NEAT design</p></a></li>
<li><a href='#PISA'><p>Programme for International Student Assessment 2009 USA Data</p></a></li>
<li><a href='#plot.bootstrap'><p>Plotting Bootstrap Equating Results</p></a></li>
<li><a href='#plot.equate'><p>Plotting Equating Results</p></a></li>
<li><a href='#plot.freqtab'><p>Plotting Frequency Distributions</p></a></li>
<li><a href='#presmoothing'><p>Frequency Distribution Presmoothing</p></a></li>
<li><a href='#px'><p>Percentile Ranks and Cumulative Frequencies</p></a></li>
<li><a href='#sample.freqtab'><p>Bootstrap Random Sampling from Frequency Tables</p></a></li>
<li><a href='#summary.freqtab'><p>Descriptive Statistics for Frequency Tables</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.8</td>
</tr>
<tr>
<td>Title:</td>
<td>Observed-Score Linking and Equating</td>
</tr>
<tr>
<td>Author:</td>
<td>Anthony Albano &lt;tony.d.albano@gmail.com&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Anthony Albano &lt;tony.d.albano@gmail.com&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/talbano/equate">https://github.com/talbano/equate</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/talbano/equate/issues">https://github.com/talbano/equate/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils, grDevices, graphics, stats</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains methods for observed-score linking
  and equating under the single-group, equivalent-groups,
  and nonequivalent-groups with anchor test(s) designs.
  Equating types include identity, mean, linear, general
  linear, equipercentile, circle-arc, and composites of
  these. Equating methods include synthetic, nominal
  weights, Tucker, Levine observed score, Levine true
  score, Braun/Holland, frequency estimation, and chained
  equating. Plotting and summary methods, and methods for
  multivariate presmoothing and bootstrap error estimation
  are also provided.</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, bookdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-06-07 16:00:55 UTC; albano</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-06-07 16:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ACTmath'>ACT Mathematics Test Scores</h2><span id='topic+ACTmath'></span>

<h3>Description</h3>

<p>This dataset contains score distributions for two forms of the ACT
mathematics test, as presented in table 2.5 of <em>Test Equating, Scaling,
and Linking</em> (Kolen and Brennan, 2004; p. 50).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ACTmath
</code></pre>


<h3>Format</h3>

<p>A 41 by 3 <code>data.frame</code> containing the score scale, frequencies
for form X, and frequencies for form Y.
</p>


<h3>Source</h3>

<p>Kolen, M. J., and Brennan, R. L. (2004). <em>Test Equating,
Scaling, and Linking</em>. (2nd ed.), New York: Springer.
</p>
<p>The dataset is also provided with the equating software RAGE, available at
the following link:
<a href="https://education.uiowa.edu/casma/computer-programs">https://education.uiowa.edu/casma/computer-programs</a>
</p>

<hr>
<h2 id='bootstrap'>Bootstrap Equating Error</h2><span id='topic+bootstrap'></span><span id='topic+bootstrap.default'></span><span id='topic+bootstrap.equate'></span><span id='topic+bootstrap.freqtab'></span><span id='topic+summary.bootstrap'></span>

<h3>Description</h3>

<p>These functions return bootstrap standard errors, bias, and RMSE of
equating. A summary method estimates mean and weighted mean errors over the
score scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootstrap(x, ...)

## Default S3 method:
bootstrap(x, y, ...)

## S3 method for class 'equate'
bootstrap(x, xp = x$x, yp = x$y, ...)

## S3 method for class 'freqtab'
bootstrap(
  x,
  y,
  xn = sum(x),
  yn = sum(y),
  reps = 100,
  crit,
  args,
  eqs = FALSE,
  sharesmooth = FALSE,
  ...
)

## S3 method for class 'bootstrap'
summary(object, weights, subset, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootstrap_+3A_x">x</code></td>
<td>
<p>either an equating object, obtained with the <code><a href="#topic+equate">equate</a></code>
function, or a score distribution of class &ldquo;<code><a href="#topic+freqtab">freqtab</a></code>&rdquo;.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_y">y</code></td>
<td>
<p>score distribution of class &ldquo;<code><a href="#topic+freqtab">freqtab</a></code>&rdquo;.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_xp">xp</code>, <code id="bootstrap_+3A_yp">yp</code></td>
<td>
<p>optional frequency tables replacing those equated in <code>x</code>,
used for parametric bootstrap resampling.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_xn">xn</code>, <code id="bootstrap_+3A_yn">yn</code></td>
<td>
<p>integers specifying the number of scores to sample from each
distribution at each replication (default is the total number observed in
each).</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_reps">reps</code></td>
<td>
<p>number of bootstrap replications.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_crit">crit</code></td>
<td>
<p>vector of equated scores serving as the criterion equating
function when calculating bootstrap bias and RMSE, both of which are
returned when <code>crit</code> is specified.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_args">args</code></td>
<td>
<p>named list of equating arguments, passed to
<code><a href="#topic+equate">equate</a></code>, specifying, e.g., the equating type and method. See
below for details.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_eqs">eqs</code></td>
<td>
<p>logical, with default <code>FALSE</code>, indicating whether or not the
matrices of equating functions (one column per replication, per equating)
should be returned.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_sharesmooth">sharesmooth</code></td>
<td>
<p>logical, defaulting to <code>FALSE</code>, indicating whether
or not loglinear presmoothing should be performed once per replication
using arguments given in <code>args</code>. Ignored if
<code>smoothmethod = "loglinear"</code> is not given in any <code>args</code>.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_object">object</code></td>
<td>
<p><code>bootstrap</code> output to be summarized.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_weights">weights</code></td>
<td>
<p>vector of weights to be used in calculating weighted average
errors with <code>summary</code>, defaulting to the frequencies in
<code>margin(object$x)</code>.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_subset">subset</code></td>
<td>
<p>vector indicating a subset of the score scale for which errors
should be summarized.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Samples are drawn of size <code>xn</code> and <code>yn</code>, with replacement, from
each score distribution. Form Y equivalents of each form X score are then
obtained using either the arguments in the equating output or those
provided. This process is repeated <code>reps</code> times. Standard errors are
calculated as standard deviations over replications for each score point;
bias is the mean equated score over replications, minus the criterion; and
RMSE is the square root of the squared standard error and squared bias
combined.
</p>
<p>The bootstrap method for objects of class &ldquo;<code>equate</code>&rdquo; is designed
to be called from within <code><a href="#topic+equate">equate</a></code>. It simply extracts the
necessary arguments from the equating output before bootstrapping.
</p>
<p>When each element in <code>args</code> is a named list of equating arguments,
multiple equatings are performed at each replication in the bootstrapping.
</p>
<p>The summary method returns a <code>data.frame</code> of mean standard errors,
bias, and rmse, and weighted means, as applicable.
</p>


<h3>Value</h3>

<p>With <code>bootstrap</code>, a list is returned, containing arguments
supplied for <code>x</code>, <code>y</code>, <code>reps</code>, <code>xn</code>, <code>yn</code>, and
<code>args</code>. For a single equating, the <code>mean</code> equating function over
replications and a vector of standard errors <code>se</code> are included,
along with vectors of <code>bias</code> and <code>rmse</code>, when <code>crit</code> is
provided, and a matrix of equating functions <code>eqs</code> when
<code>eqs = TRUE</code>. For multiple equatings, where each element of
<code>args</code> is a list of equating arguments, matrices are returned for the
mean functions, standard error, bias, and RMSE, and the equating functions
will be returned as a list of matrices. The <code>summary</code> method returns a
data frame of mean standard errors, bias, and rmse, and weighted means,
as applicable.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>default</code>: Default bootstrap method for
&ldquo;<code><a href="#topic+freqtab">freqtab</a></code>&rdquo; objects.
</p>
</li>
<li> <p><code>equate</code>: Method for &ldquo;<code><a href="#topic+equate">equate</a></code>&rdquo; objects.
</p>
</li>
<li> <p><code>freqtab</code>: Bootstrap method for &ldquo;<code><a href="#topic+freqtab">freqtab</a></code>&rdquo;
objects.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Anthony Albano <a href="mailto:tony.d.albano@gmail.com">tony.d.albano@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.bootstrap">plot.bootstrap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Parametric bootstrapping using smoothed
# frequency distributions
set.seed(111213)
x &lt;- freqtab(KBneat$x, scales = list(0:36, 0:12))
y &lt;- freqtab(KBneat$y, scales = list(0:36, 0:12))
xp &lt;- loglinear(x, asfreqtab = TRUE)
yp &lt;- loglinear(y, asfreqtab = TRUE)
crit &lt;- equate(xp, yp, "e", "c")$conc$yx
eqargs &lt;- list(m.t = list(type = "m", method = "t"),
  l.t = list(type = "l", method = "t"))
bootout1 &lt;- bootstrap(x = x, y = y, xn = 20, yn = 20,
  crit = crit, args = eqargs, reps = 30)
plot(bootout1, out = "rmse", legendplace = "top",
  addident = FALSE)

# Bootstraps for an existing equating
eq &lt;- equate(x, y, type = "m", method = "t")
bootout2 &lt;- bootstrap(eq, xn = 100, yn = 100,
  crit = crit, reps = 20)
summary(bootout2)

</code></pre>

<hr>
<h2 id='composite'>Composite Linking and Equating</h2><span id='topic+composite'></span><span id='topic+composite.default'></span><span id='topic+composite.equate.list'></span><span id='topic+composite.list'></span>

<h3>Description</h3>

<p>This function creates a composite linking or equating as a combination of
two or more other linking or equating functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>composite(x, ...)

## Default S3 method:
composite(x, wc, ...)

## S3 method for class 'equate.list'
composite(x, wc, name, symmetric = FALSE, p = 1, verbose = TRUE, ...)

## S3 method for class 'list'
composite(x, wc, name, symmetric = FALSE, p = 1, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="composite_+3A_x">x</code></td>
<td>
<p>for the default method, <code>x</code> is a matrix of equating functions,
with one function per column. Otherwise, <code>x</code> is a list of equatings,
where each element is an object of class &ldquo;<code><a href="#topic+equate">equate</a></code>&rdquo;.</p>
</td></tr>
<tr><td><code id="composite_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other functions.</p>
</td></tr>
<tr><td><code id="composite_+3A_wc">wc</code></td>
<td>
<p>vector of weights for creating the composite. <code>length(wc)</code>
should match either <code>ncol(x)</code> for the default method or
<code>length(x)</code>.</p>
</td></tr>
<tr><td><code id="composite_+3A_name">name</code></td>
<td>
<p>an optional name, used to label the output. If missing, a name
will be created using <code>x</code>.</p>
</td></tr>
<tr><td><code id="composite_+3A_symmetric">symmetric</code></td>
<td>
<p>logical, with default <code>FALSE</code>, indicating whether or
not weights <code>wc</code> should be modified to create symmetric weights. Only
supported for composites of linear functions.</p>
</td></tr>
<tr><td><code id="composite_+3A_p">p</code></td>
<td>
<p>integer specifying the type of circle used to define symmetry.</p>
</td></tr>
<tr><td><code id="composite_+3A_verbose">verbose</code></td>
<td>
<p>logical, with default <code>TRUE</code>, indicating whether or not
full output should be returned. When <code>FALSE</code>, only the equated scores
are returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Composite linking and equating create a single linking or equating function
as a weighted combination of two or more other linking or equating
functions. See Holland and Strawderman (2011) for details.
</p>


<h3>Value</h3>

<p>For the default method, and when <code>verbose = FALSE</code>, a vector of
composite equated scores is returned. Otherwise, a list of equating output
is returned, including output for the composite and each function being
combined.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>default</code>: Default method for a matrix of equating functions,
one per column.
</p>
</li>
<li> <p><code>equate.list</code>: Create composite across functions in
&ldquo;<code>equate.list</code>&rdquo; object.
</p>
</li>
<li> <p><code>list</code>: Create composite across functions in
&ldquo;<code>list</code>&rdquo; object.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Anthony Albano <a href="mailto:tony.d.albano@gmail.com">tony.d.albano@gmail.com</a>
</p>


<h3>References</h3>

<p>Holland, P. W., and Strawderman, W. E. (2011). How to average
equating functions, if you must. In A. A. von Davier (Ed.), Statistical
models for test equating, scaling, and linking (pp. 89-107). New York, NY:
Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+equate">equate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See vignette("equatevignette") for additional examples

# Example from the equate help file, without the bootstrapping
# Random groups equating for (1) identity, (2) mean, 
# (3) linear, (4) equipercentile with loglinear
# smoothing, and (5) a composite of mean and identity
rx &lt;- as.freqtab(ACTmath[, 1:2])
ry &lt;- as.freqtab(ACTmath[, c(1, 3)])
set.seed(2007)

req1 &lt;- equate(rx, ry, type = "i")
req2 &lt;- equate(rx, ry, type = "m")
req3 &lt;- equate(rx, ry, type = "l")
req4 &lt;- equate(rx, ry, type = "e", smooth = "loglin",
  degrees = 3)
req5 &lt;- composite(list(req1, req2), wc = .5, symmetric = TRUE)

# Compare equating functions
plot(req1, req2, req3, req4, req5[[1]], addident = FALSE)

</code></pre>

<hr>
<h2 id='equate'>Observed Score Linking and Equating</h2><span id='topic+equate'></span><span id='topic+equate.list'></span><span id='topic+equate.freqtab'></span><span id='topic+equate.default'></span><span id='topic+summary.equate'></span><span id='topic+summary.equate.list'></span>

<h3>Description</h3>

<p>This function links the scale of <code>x</code> to the scale of <code>y</code> for the
single-group, equivalent-groups, and nonequivalent-groups with anchor test
designs. A summary method is also provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>equate(x, ...)

## S3 method for class 'list'
equate(x, args, ...)

## S3 method for class 'freqtab'
equate(
  x,
  y,
  type = c("identity", "mean", "linear", "general linear", "circle-arc",
    "equipercentile"),
  method = c("none", "nominal weights", "tucker", "levine", "frequency estimation",
    "chained", "braun/holland"),
  name,
  lowp,
  highp,
  boot = FALSE,
  verbose = TRUE,
  ...
)

## Default S3 method:
equate(x, y, ...)

## S3 method for class 'equate'
summary(object, ...)

## S3 method for class 'equate.list'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="equate_+3A_x">x</code>, <code id="equate_+3A_y">y</code></td>
<td>
<p>for the default method, <code>x</code> must be a vector of scores and
<code>y</code> an object of class &ldquo;<code>equate</code>&rdquo;, the output of a previous
equating. The standard usage is to provide <code>x</code> as a frequency table of
class &ldquo;<code>freqtab</code>&rdquo;, where <code>y</code> is also a frequency table, and
<code>x</code> is equated to <code>y</code>; if <code>y</code> is missing, a single-group
design is assumed. Finally, <code>x</code> may be a list of two or more frequency
tables, in which case the required arguments for one or more equatings are
listed in <code>args</code>. See below for details.</p>
</td></tr>
<tr><td><code id="equate_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other functions, including
arguments specific to different equating methods. See below for details.</p>
</td></tr>
<tr><td><code id="equate_+3A_args">args</code></td>
<td>
<p>list of arguments passed to <code>equate</code>. See below for
details.</p>
</td></tr>
<tr><td><code id="equate_+3A_type">type</code></td>
<td>
<p>the type of equating. See below for details.</p>
</td></tr>
<tr><td><code id="equate_+3A_method">method</code></td>
<td>
<p>the equating method, where <code>"none"</code> (default) indicates
equating under the single-group or equivalent-groups design, and
<code>"nominal weights"</code>, <code>"tucker"</code>, <code>"levine"</code>, <code>"frequency
estimation"</code>, <code>"braun/holland"</code>, and <code>"chained"</code> indicate the
corresponding methods under the nonequivalent groups design.</p>
</td></tr>
<tr><td><code id="equate_+3A_name">name</code></td>
<td>
<p>an optional name, used to label the output. If missing, a name
will be created using <code>type</code> and <code>method</code>.</p>
</td></tr>
<tr><td><code id="equate_+3A_lowp">lowp</code>, <code id="equate_+3A_highp">highp</code></td>
<td>
<p>two vectors, each of length 2, specifying the coordinates
for the low and high points of the X and Y scales. <code>lowp</code> defaults to
the minimums and <code>highp</code> the maximums of the scales. Recycled if
necessary. When <code>lowp = "obs"</code> or <code>highp = "obs"</code>, minimum and
maximum observed scores are used.</p>
</td></tr>
<tr><td><code id="equate_+3A_boot">boot</code></td>
<td>
<p>logical indicating whether or not bootstrapping should be
performed. Default is <code>FALSE</code>. See below and the
<code><a href="#topic+bootstrap">bootstrap</a></code> function for details.</p>
</td></tr>
<tr><td><code id="equate_+3A_verbose">verbose</code></td>
<td>
<p>logical, with default <code>TRUE</code>, indicating whether or not
full output should be returned. When <code>FALSE</code>, only the equated scores
are returned.</p>
</td></tr>
<tr><td><code id="equate_+3A_object">object</code></td>
<td>
<p>output from either an equating or list of equatings, produced
by the <code>equate</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Equating is typically performed on two frequency tables, <code>x</code> and
<code>y</code>. In this case, the scores from both are used to define the equating
function that links the scale of <code>x</code> to <code>y</code>. The equivalent-groups
design is assumed when <code>x</code> and <code>y</code> are separate, univariate
frequency tables. The nonequivalent-groups design is assumed when a
<code>method</code> is specified, and <code>x</code> and <code>y</code> are separate
multivariate frequency tables. Finally, a single-group design is assumed
when <code>x</code> is a bivariate frequency table (containing scores on X and Y)
and <code>y</code> is missing.
</p>
<p>The single-group design currently only differs from the equivalent groups
design in that presmoothing can be used to preserve bivariate moments for
<code>x</code> and <code>y</code> in the single-group design, whereas in the
equivalent-groups design, with <code>x</code> and <code>y</code> specified separately,
presmoothing is performed separately. If presmoothing is not performed via
<code>equate</code>, the single-group and equivalent-groups designs produce the
same result.
</p>
<p>When <code>x</code> is a vector of scores and equating output is supplied for
<code>y</code>, no other arguments are required. Scores from <code>x</code> are
converted directly to the scale indicated in <code>y</code>. If <code>y</code> is a
composite equating, composite equated scores will be returned based on the
weighted combination of equating functions included in <code>y</code>.
</p>
<p>When <code>x</code> is a <code>list</code> of frequency tables, each element in
<code>args</code> must be a named list of equating arguments. In this case, the
length of <code>args</code> corresponds to the number of equatings that will be
performed. The arguments for each equating are specified as they would be
when <code>x</code> and <code>y</code> are frequency tables, except for <code>x</code> and
<code>y</code>; the frequency tables to be equated are specified in <code>args</code> by
referencing their names in the list of frequency tables. See below for
examples.
</p>
<p>Six equating types are currently supported: identity, mean, linear, and
equipercentile, as described by Kolen and Brennan (2004); circle-arc
equating, as described by Livingston and Kim (2009); and a general linear
function that extends the traditional identity, mean, and linear types.
Corresponding linking methods are also supported. The equating design is
implied by the <code>method</code> argument, where <code>"none"</code> (default)
indicates that no method is needed (because examinees taking forms X and Y
are assumed to be the same or equivalent). The nominal weights, Tucker,
Levine observed score, Levine true score, frequency estimation,
Braun/Holland, and chained equating methods are supported for the
nonequivalent-groups with anchor test design. All but the Levine true score
and chained method rely on a &ldquo;synthetic&rdquo; distribution of scores
(Braun and Holland, 1982), a weighted combination of <code>x</code> and <code>y</code>.
</p>
<p>Depending on the equating method, the following additional arguments may be
required:
</p>
 <dl>
<dt>midp</dt><dd><p> coordinates for the midpoint of
the equating line, used in general linear and circle-arc equating. </p>
</dd>
<dt>cx, cy, sx, sy</dt><dd><p> parameters used in general linear equating.
See below for details. </p>
</dd> <dt>wax, way, wbx, wby</dt><dd><p> weights used
when finding the slope and intercept in general linear equating. See below.
</p>
</dd> <dt>ws</dt><dd><p> value between 0 and 1 specifying the weight applied to
form X scores (and implicitly specifying the form Y weight as <code>1 - ws</code>)
when estimating the synthetic population. When set to -1 (the default),
proportional weights are calculated for X and Y based on sample size. </p>
</dd>
<dt>internal</dt><dd><p> logical indicating whether or not the anchor item
scores are included in the total scores. This applies only to the Levine
method, as all other methods assume an internal anchor test. Default is
<code>TRUE</code>. </p>
</dd> <dt>lts</dt><dd><p> logical indicating whether or not to use
levine true score (&ldquo;lts&rdquo;) equating. Default is <code>FALSE</code>. </p>
</dd>
<dt>smoothmethod</dt><dd><p> string indicating one of four smoothing methods
to be used in equipercentile equating: <code>"none"</code> (default),
<code>"average"</code>, <code>"bump"</code>, and <code>"loglinear"</code> (see below). </p>
</dd>
<dt>chainmidp</dt><dd><p> string specifying the type of chained linear
equating used to obtain the midpoint in chained circle-arc equating, whether
<code>"mean"</code> (default) or <code>"linear"</code>. </p>
</dd> <dt>simple</dt><dd>
<p>logical, with default <code>TRUE</code>, indicating whether or not simplified
circle-arc equating should be used (see below). </p>
</dd> <dt>reps</dt><dd><p> the
number of replications to use in bootstrapping. Passed to
<code><a href="#topic+bootstrap">bootstrap</a></code>. </p>
</dd> <dt>xp, yp</dt><dd><p> optional parametric
distributions, as frequency tables, replacing <code>x</code> and <code>y</code> when
bootstrapping. </p>
</dd> <dt>xn, yn</dt><dd><p> sample sizes to be drawn from
<code>x</code> and <code>y</code>, or <code>xp</code> and <code>yp</code>, at each bootstrap
replication. These default to the observed sample sizes. </p>
</dd>
<dt>crit</dt><dd><p> a vector of equated scores serving as the criterion
equating function when calculating bootstrap bias and RMSE; both are
returned when <code>crit</code> is specified. </p>
</dd> </dl>

<p>General linear equating is a new
approach to estimating a linear linking or equating function. The slope and
intercept of the line are estimated based on multiple sources of
information, including the means and standard deviations of X and Y, and
other values supplied through <code>cx</code> and <code>cy</code>, representing the
centrality of X and Y, and <code>sx</code> and <code>sy</code>, representing the scaling
or variability of X and Y. The weights <code>wax</code> and <code>way</code> specify the
proportional weighting given to the standard deviations of X and Y, and
indirectly the weighting given to <code>sx</code> and <code>sy</code>, in determining
the slope. <code>wbx</code> and <code>wby</code> specify the proportional weighting
given to the means of X and Y, and indirectly the weighting given to
<code>cx</code> and <code>cy</code>, in determining the intercept. Synthetic means and
standard deviations will be used when appropriate. Chained general linear
equating is not currently supported.
</p>
<p>For equipercentile equating under the random groups design, three smoothing
options are available: <code>smoothmethod = "average"</code> and
<code>smoothmethod = "bump"</code> require the additional argument <code>jmin</code>,
and loglinear smoothing (<code>smoothmethod = "loglinear"</code>) requires either
a score function or maximum polynomial terms. For frequency estimation and
chained methods, only smoothing methods <code>"bump"</code> and <code>"loglinear"</code>
are supported. See the <code><a href="#topic+presmoothing">presmoothing</a></code> function for details and
examples.
</p>
<p>In equipercentile equating, the high point for <code>y</code>, i.e.,
<code>highp[2]</code>, is used to obtain form Y equivalents of form X scores with
percentile ranks of 100. Typically this is set to be the number of score
points in the form Y scale, which assumes that scores are integers ranging
from 1 (or 0) to the total number of items, and that each item is scored
correct/incorrect. Scores on other scales (such as scales which include
negative values, or which exclude zero) may also be used. In such cases
<code>highp[2]</code> can be set to the highest possible score on form Y, or
alternatively the highest observed score on Y.
</p>
<p><code>lowp</code> and <code>highp</code> are used to define the slope and intercept of
the identity linking function. When the score scales for X and Y are
equivalent, the identity function is simply the unequated X scale; however,
when forms differ in their scales, e.g., because of changes in content or
length, the identity linking function will map X onto Y based on the low and
high coordinates.
</p>
<p>The simplified approach to circle-arc equating, as demonstrated by
Livingston and Kim (2009), involves combining a circle-arc with the identity
function. When the low and high scores differ for the X and Y scales, this
becomes the identity linking function. The linear component can be omitted,
and symmetric circle-arc equating used, with <code>simple = FALSE</code>. The
result is an equating function based only on the circle-arc that passes
through the points <code>lowp</code>, <code>highp</code>, and the estimated midpoint.
</p>
<p>Analytical standard errors are currently returned for linear
equating under equivalent groups and chained, Tucker, and Levine
equating with nonequivalent groups. Chained, Tucker, and Levine
standard errors are provided with and without assumptions of
normality, as shown in Zu (2012). With <code>boot = TRUE</code>,
bootstrap standard errors are estimated using a default of
<code>reps = 100</code> replications, sampling the maximum amount from each score
distribution (controlled by the arguments <code>xn</code> and <code>yn</code>). See
<code><a href="#topic+bootstrap">bootstrap</a></code> for details and examples, including how to obtain
bootstrap bias and RMSE.
</p>


<h3>Value</h3>

<p>When <code>y</code> contains output from an equating, a vector of equated
scores is returned. Otherwise, an object of class &ldquo;<code>equate</code>&rdquo; is
returned, listing the following components, some of which are dependent on
the equating type, method, and smoothing:
</p>
<table>
<tr><td><code>name</code></td>
<td>
<p><code>name</code> for the equating</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>equating type</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>equating method</p>
</td></tr>
<tr><td><code>design</code></td>
<td>
<p>equating design, as specified in <code>x</code></p>
</td></tr>
<tr><td><code>x</code>, <code>y</code></td>
<td>
<p>original frequency tables for X and Y</p>
</td></tr>
<tr><td><code>concordance</code></td>
<td>
<p>conversion table containing scores on X with
their form Y equivalents, and standard errors, when available.</p>
</td></tr>
<tr><td><code>points</code></td>
<td>
<p>low and high points defining the identity line,
and midpoints for general linear and circle-arc equating</p>
</td></tr>
<tr><td><code>weight</code></td>
<td>
<p>weights used in general linear equating</p>
</td></tr>
<tr><td><code>internal</code>, <code>lts</code>, <code>jmin</code>, <code>degree</code>, <code>xdegree</code>, <code>scorefun</code></td>
<td>
<p>additional
arguments, as supplied in ...</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>conversion coefficients intercept and slope;
for circle-arc equating, circle center points and radius are also
included; for general linear equating, slope and intercept
components are included</p>
</td></tr>
<tr><td><code>ws</code></td>
<td>
<p>weight applied to X in synthetic estimation</p>
</td></tr>
<tr><td><code>synthstats</code></td>
<td>
<p>means and standard deviations for the synthetic
distributions</p>
</td></tr>
<tr><td><code>xsynthetic</code>, <code>ysynthetic</code></td>
<td>
<p>frequency tables for the
synthetic distributions</p>
</td></tr>
<tr><td><code>smoothmethod</code></td>
<td>
<p>smoothing method</p>
</td></tr>
<tr><td><code>xsmooth</code>, <code>ysmooth</code></td>
<td>
<p>smoothed frequency tables for X and Y</p>
</td></tr>
<tr><td><code>bootstraps</code></td>
<td>
<p>list containing bootstrap standard errors, and,
optionally, other bootstrap output</p>
</td></tr>
</table>
<p>The summary method returns a list with the name, type, method,
design, and synthetic weight, along with frequency tables for
the total, anchor, and equated score distributions and
descriptive statistics for each.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>list</code>: Equating a list of frequency tables.
</p>
</li>
<li> <p><code>freqtab</code>: Equating frequency distributions in <code>x</code> and <code>y</code>.
</p>
</li>
<li> <p><code>default</code>: Default equating method for a vector of raw scores <code>x</code>
and equating output in <code>y</code>.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Anthony Albano <a href="mailto:tony.d.albano@gmail.com">tony.d.albano@gmail.com</a>
</p>


<h3>References</h3>

<p>Albano, A. D. (2016). equate: An R package for
observed-score linking and equating. <em>Journal of Statistical
Software, 74</em>(8), 1&ndash;36.
</p>
<p>Kolen, M. J., and Brennan, R. L. (2004). <em>Test Equating,
Scaling, and Linking</em>. (2nd ed.), New York: Springer.
</p>
<p>Livingston, S. A., and Kim, S. (2009). The circle-arc method for equating in
small samples, <em>Journal of Educational Measurement, 46</em>, 330&ndash;343.
</p>
<p>Zu, J., and Yuan, K. H. (2012). Standard error of linear 
observed-score equating for the NEAT design with nonnormally
distributed data. <em>Journal of Educational Measurement, 49</em>,
190&ndash;213.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+freqbump">freqbump</a></code>, <code><a href="#topic+freqavg">freqavg</a></code>,
<code><a href="#topic+loglinear">loglinear</a></code>, <code><a href="#topic+bootstrap">bootstrap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# See vignette("equatevignette") and Albano (2016) for a
# description of methods and additional examples

# Random groups equating for (1) identity, (2) mean, 
# (3) linear, (4) equipercentile with loglinear
# smoothing, and (5) a composite of mean and identity
rx &lt;- as.freqtab(ACTmath[, 1:2])
ry &lt;- as.freqtab(ACTmath[, c(1, 3)])
set.seed(2007)

req1 &lt;- equate(rx, ry, type = "i", boot = TRUE, reps = 5)
req2 &lt;- equate(rx, ry, type = "m", boot = TRUE, reps = 5)
req3 &lt;- equate(rx, ry, type = "l", boot = TRUE, reps = 5)
req4 &lt;- equate(rx, ry, type = "e", boot = TRUE, reps = 5,
  smooth = "loglin", degree = 3)
req5 &lt;- composite(list(req1, req2), wc = .5, symmetric = TRUE)

# Compare equating functions
plot(req1, req2, req3, req4, req5[[1]], addident = FALSE)

# Compare boostrap standard errors
# Bootstrapping isn't supported for composite equating
plot(req1, req2, req3, req4, addident = FALSE, out = "se",
  legendplace = "topleft")

# Nonequivalent groups design for (1) Tucker linear,
# (2) frequency estimation , and (3) Braun/Holland linear
nx &lt;- freqtab(KBneat$x, scales = list(0:36, 0:12))
ny &lt;- freqtab(KBneat$y, scales = list(0:36, 0:12))

neq1 &lt;- equate(nx, ny, type = "linear", method = "tuck", ws = 1)
neq2 &lt;- equate(nx, ny, type = "equip", method = "freq", ws = 1)
neq3 &lt;- equate(nx, ny, type = "linear", method = "braun", ws = 1)

# Compare equated scores
round(cbind(xscale = 0:36, tucker = neq1$conc$yx,
	fe = neq2$conc$yx, braun = neq3$conc$yx), 2)

# Multiple linkings using PISA reading booklet 6
# clusters 3a, 5, 6, and 7
r3 &lt;- freqtab(PISA$totals$b6$r3a, scales = 0:15)
r5 &lt;- freqtab(PISA$totals$b6$r5, scales = 0:15)
r6 &lt;- freqtab(PISA$totals$b6$r6, scales = 0:15)
r7 &lt;- freqtab(PISA$totals$b6$r7, scales = 0:14)
eqargs &lt;- list(r3r5 = list(type = "linear", x = "r3", y = "r5",
    name = "Linear Linking PISA r3 to r5"),
  r5r6 = list(type = "linear", x = "r5", y = "r6",
    name = "Linear Linking PISA r5 to r6"),
  r6r7 = list(type = "linear", x = "r6", y = "r7",
    name = "Linear Linking PISA r6 to r7"))
req &lt;- equate(list(r3 = r3, r5 = r5, r6 = r6, r7 = r7), eqargs)

# Put PISA r3 on the scale of r7 using the linking chain
# Compare to a direct linking of r3 to r7
equate(equate(req$r3r5$conc$yx, req$r5r6), req$r6r7)
equate(r3, r7, "linear")$conc$yx

# Linking PISA cluster r3a to r5 with multiple anchors
m367 &lt;- freqtab(PISA$totals$b6[1:198, c("r3a", "r6", "r7")],
	scales = list(0:15, 0:16, 0:14))
m567 &lt;- freqtab(PISA$totals$b6[199:396, c("r5", "r6", "r7")],
	scales = list(0:15, 0:16, 0:14))
meq1 &lt;- equate(m367, m567, type = "mean", method = "nom")
meq2 &lt;- equate(m367, m567, type = "mean", method = "tuck")
meq3 &lt;- equate(m367, m567, type = "lin", method = "tuck")
meq4 &lt;- equate(m367, m567, type = "equip", method = "freq",
	smooth = "log", show = FALSE)
meq &lt;- equate(m367, m567, type = "mean", method = "nom")
plot(meq1, meq2, meq3, meq4, meq, req[[1]])

</code></pre>

<hr>
<h2 id='equate-package'>Observed-Score Linking and Equating</h2><span id='topic+equate-package'></span>

<h3>Description</h3>

<p>Contains methods for observed-score linking and equating under the
single-group, equivalent-groups, and nonequivalent-groups with anchor
test(s) designs. Equating types include identity, mean, linear, general
linear, equipercentile, circle-arc, and composites of these. Equating
methods include synthetic, nominal weights, Tucker, Levine observed score,
Levine true score, Braun/Holland, frequency estimation, and chained
equating. Plotting and summary methods, and methods for multivariate
presmoothing and bootstrap error estimation are also provided.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;"> Package: </td><td style="text-align: left;"> equate</td>
</tr>
<tr>
 <td style="text-align: left;"> Version: </td><td style="text-align: left;"> 2.0.8</td>
</tr>
<tr>
 <td style="text-align: left;"> Date: </td><td style="text-align: left;">
2022-06-05</td>
</tr>
<tr>
 <td style="text-align: left;"> Depends: </td><td style="text-align: left;"> R (&gt;= 4.1.0)</td>
</tr>
<tr>
 <td style="text-align: left;"> License: </td><td style="text-align: left;"> GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>

<p>Index: </p>

<table>
<tr>
 <td style="text-align: left;">
ACTmath </td><td style="text-align: left;"> ACT Mathematics Test Scores</td>
</tr>
<tr>
 <td style="text-align: left;">
KBneat </td><td style="text-align: left;"> Test Scores Under a NEAT design</td>
</tr>
<tr>
 <td style="text-align: left;">
PISA </td><td style="text-align: left;"> Programme for International Student Assessment 2009 USA Data</td>
</tr>
<tr>
 <td style="text-align: left;">
descriptives </td><td style="text-align: left;"> Descriptive Statistics for Frequency Tables</td>
</tr>
<tr>
 <td style="text-align: left;">
percentiles </td><td style="text-align: left;"> Percentile Ranks and Cumulative Frequencies for Frequency Tables</td>
</tr>
<tr>
 <td style="text-align: left;">
equate </td><td style="text-align: left;"> Observed Score Linking and Equating</td>
</tr>
<tr>
 <td style="text-align: left;">
composite </td><td style="text-align: left;"> Composite Linking and Equating</td>
</tr>
<tr>
 <td style="text-align: left;">
bootstrap </td><td style="text-align: left;"> Bootstrap Equating Error</td>
</tr>
<tr>
 <td style="text-align: left;">
freqtab </td><td style="text-align: left;"> Frequency Distribution Tables</td>
</tr>
<tr>
 <td style="text-align: left;">
presmoothing </td><td style="text-align: left;"> Frequency Distribution Presmoothing</td>
</tr>
<tr>
 <td style="text-align: left;">
plot.freqtab </td><td style="text-align: left;"> Plotting Frequency Distributions</td>
</tr>
<tr>
 <td style="text-align: left;">
plot.equate </td><td style="text-align: left;"> Plotting Equating Results</td>
</tr>

</table>

<p>Further information is available in the following vignettes:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>equatevignette</code> </td><td style="text-align: left;"> equate vignette (source, pdf)</td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>

<p>The package vignette provides an introduction to linking and equating and includes
descriptions of the supported equating methods and examples. The help page
for the main function of the package, <code><a href="#topic+equate">equate</a></code>, contains
additional examples.
</p>


<h3>Author(s)</h3>

<p>Anthony Albano &lt;tony.d.albano@gmail.com&gt;
</p>

<hr>
<h2 id='freqtab'>Frequency Distribution Tables</h2><span id='topic+freqtab'></span><span id='topic+freqtab.default'></span><span id='topic+as.freqtab'></span><span id='topic+freqtab.table'></span><span id='topic+as.data.frame.freqtab'></span><span id='topic+head.freqtab'></span><span id='topic+tail.freqtab'></span><span id='topic+scales'></span><span id='topic+margin'></span><span id='topic+margins'></span><span id='topic+droplevels.freqtab'></span>

<h3>Description</h3>

<p>Functions for creating and manipulating frequency tables of class
&ldquo;<code>freqtab</code>&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>freqtab(x, ...)

## Default S3 method:
freqtab(x, scales, items, design, na.rm = TRUE, ...)

as.freqtab(x, scales, design, drop = FALSE, ...)

## S3 method for class 'table'
freqtab(x, design, ...)

## S3 method for class 'freqtab'
as.data.frame(x, row.names = NULL, optional = FALSE, drop = FALSE, ...)

## S3 method for class 'freqtab'
head(x, ...)

## S3 method for class 'freqtab'
tail(x, ...)

scales(x, margin = 1)

margin(x, margin = 1)

margins(x)

## S3 method for class 'freqtab'
droplevels(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="freqtab_+3A_x">x</code></td>
<td>
<p>either an object (vector or <code>data.frame</code>) containing total
scores or item responses with which total scores will be calculated, or an
object inheriting from class &ldquo;<code>freqtab</code>&rdquo;. In the <code>freqtab</code>
function, the first column in <code>x</code> must be the total test; any remaining
columns may contain anchor scores. See below for details.</p>
</td></tr>
<tr><td><code id="freqtab_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other functions.</p>
</td></tr>
<tr><td><code id="freqtab_+3A_scales">scales</code></td>
<td>
<p>list of vectors containing the score scales for each score scale
in <code>x</code>.</p>
</td></tr>
<tr><td><code id="freqtab_+3A_items">items</code></td>
<td>
<p>list of vectors of column indices (numbers or column names)
with which total scores will be computed for <code>x</code> when it contains item
responses.</p>
</td></tr>
<tr><td><code id="freqtab_+3A_design">design</code></td>
<td>
<p>the equating design used in data collection. For univariate
<code>x</code>, <code>design = "eg"</code> is assumed for equivalent groups. For
multivariate <code>x</code>, <code>design = "ng"</code> is assumed for nonequivalent
groups. Single-groups and counterbalanced designs must be specified with
<code>design = "sg"</code> and <code>design = "cb"</code>.</p>
</td></tr>
<tr><td><code id="freqtab_+3A_na.rm">na.rm</code></td>
<td>
<p>logical with default <code>TRUE</code> specifying whether or not
missing item responses should be ignored, i.e., treated as 0, when
calculating total scores.</p>
</td></tr>
<tr><td><code id="freqtab_+3A_drop">drop</code></td>
<td>
<p>logical, with default <code>FALSE</code>, indicating whether or not
unused factor levels, or score values with zero counts, should be dropped.
See below for details.</p>
</td></tr>
<tr><td><code id="freqtab_+3A_row.names">row.names</code>, <code id="freqtab_+3A_optional">optional</code></td>
<td>
<p>arguments passed to <code>as.data.frame</code>,
currently ignored.</p>
</td></tr>
<tr><td><code id="freqtab_+3A_margin">margin</code></td>
<td>
<p>integer vector specifying the margin(s) over which frequencies
should be summed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>freqtab</code> creates a frequency table from a vector or <code>data.frame</code>
of scores. When the <code>items</code> argument is included, scores are assumed to
be item responses, which are summed to create total scores. The scores are
tabulated and stored as an array, with dimensions for each variable. Note
that in previous versions of the &ldquo;<code>freqtab</code>&rdquo; class the frequency
table was stored as a <code>data.frame</code>. This is no longer the case.
Instead, the table is stored as an array and converted to a
<code>data.frame</code> when printed or manipulated with the <code>head</code> and
<code>tail</code> methods.
</p>
<p><code>as.data.frame</code> converts an object of class &ldquo;<code>freqtab</code>&rdquo; to
&ldquo;<code>data.frame</code>&rdquo;. <code>droplevels</code> returns <code>x</code> with any
unused factor levels, or levels with zero counts, removed.
</p>
<p>When <code>x</code> is an object of class &ldquo;<code>table</code>&rdquo;, <code>freqtab</code>
simply modifies the attributes and converts to class
&ldquo;<code>freqtab</code>&rdquo;. In this case, <code>x</code> must already be structured
similar to a &ldquo;<code>freqtab</code>&rdquo; object, with the first dimension
containing counts for total scores, and remaining dimensions containing
counts for one or more anchor tests.
</p>
<p><code>as.freqtab</code> converts a 'flat' contingency table (see
<code><a href="stats.html#topic+ftable">ftable</a></code>) to class &ldquo;<code>freqtab</code>&rdquo; with the appropriate
attributes. A flat contingency table is the <code>data.frame</code> version of a
&ldquo;<code>freqtab</code>&rdquo; object, where the first column contains the total
score scale, the last column contains counts, and the columns in between
contain different anchor test score combinations. <code>is.freqtab</code> tests
for class &ldquo;<code>freqtab</code>&rdquo;.
</p>
<p><code>scales</code> extracts the measurement scales for the variables specified in
<code>margin</code>, with <code>margin = 1</code> referring to the total score scale,
and subsequent margins referring to anchor tests. <code>margin</code> is a wrapper
for <code><a href="base.html#topic+margin.table">margin.table</a></code>, which itself is a simple wrapper for summing
over marginal counts, i.e., <code>apply(x, margin, sum)</code>. And <code>margins</code>
returns the number of dimensions, i.e., score variables, in a frequency
table.
</p>
<p><code>design</code> is used to set the dimnames of the frequency table, with
<code>total1</code> and <code>total2</code> used with single and counterbalanced groups,
and <code>total</code> and <code>anchor</code>(s) used otherwise. <code>design</code> also
sets the design attribute, which is used in <code><a href="#topic+equate">equate</a></code>.
</p>
<p>The main difference between the &ldquo;<code>freqtab</code>&rdquo; class and other
tabulation classes, like &ldquo;<code>table</code>&rdquo; and &ldquo;<code>ftable</code>&rdquo;,
is that the <code>dimnames</code>, i.e., the score scales, are required to be
numeric. This facilitates plotting with <code><a href="#topic+plot.freqtab">plot.freqtab</a></code>, equating
with the <code><a href="#topic+equate">equate</a></code> function, and descriptive statistics with the
<code><a href="#topic+summary.freqtab">summary.freqtab</a></code> and other methods.
</p>


<h3>Value</h3>

<p>A table array with dimensions equal to the number of score scales.
In most cases, this will be a univariate or bivariate distribution, but
multivariate distributions are supported. <code>scales</code> and <code>margins</code>
return numeric vectors.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>default</code>: Default method for a <code>data.frame</code> of item responses,
a <code>data.frame</code> of total and anchor scores, or a vector of total scores.
</p>
</li>
<li> <p><code>table</code>: Method for <code>table</code>s.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Anthony Albano <a href="mailto:tony.d.albano@gmail.com">tony.d.albano@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+table">table</a></code>, <code><a href="stats.html#topic+ftable">ftable</a></code>,
<code><a href="#topic+summary.freqtab">summary.freqtab</a></code>, <code><a href="#topic+plot.freqtab">plot.freqtab</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Univariate distribution with score scale
set.seed(2005)
x &lt;- round(rnorm(1000, 100, 10))
head(freqtab(x, scales = 70:130))

# Existing frequency table converted to class "freqtab"
# The first score of zero, with zero counts, is dropped
head(as.freqtab(ACTmath[, 1:2], drop = TRUE))

# Bivariate distribution
# Reduce y to the anchor test margin (2)
ny &lt;- freqtab(x = KBneat$y, scales = list(0:36, 0:12))
margin(ny, margin = 2)

# Summing scored item responses with the PISA data
attach(PISA)
r6items &lt;- paste(items$itemid[items$clusterid == "r6"])
r7items &lt;- paste(items$itemid[items$clusterid == "r7"])
pisa67 &lt;- freqtab(students[students$book == 6, ],
	items = list(r6items, r7items),
	scales = list(0:16, 0:14))
detach(PISA)

# Scales for both margins
# Zero total score is unobserved
scales(pisa67, 1:2)
scales(droplevels(pisa67), 1:2)

</code></pre>

<hr>
<h2 id='KBneat'>Test Scores under a NEAT design</h2><span id='topic+KBneat'></span>

<h3>Description</h3>

<p>This dataset contains scores for two forms of a 36-item test administered
under a nonequivalent groups with anchor test design. The anchor test is
internal and consists of twelve items taken by both groups of examinees. The
data is distributed as part of the equating software CIPE (see link below),
and additional examples using this dataset are presented in <em>Test
Equating, Scaling, and Linking</em> (Kolen and Brennan, 2004).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KBneat
</code></pre>


<h3>Format</h3>

<p>A list of length two, where each element (<code>$x</code> and <code>$y</code>)
contains two columns of data, one for the total score and another for the
anchor test score for each examinee.
</p>


<h3>Source</h3>

<p>Kolen, M. J., &amp; Brennan, R. L. (2004). <em>Test Equating, Scaling,
and Linking</em>. (2nd ed.), New York: Springer.
</p>
<p>The dataset can be downloaded as part of the CIPE software, available at the
following link:
<a href="https://education.uiowa.edu/casma">https://education.uiowa.edu/casma</a>
</p>

<hr>
<h2 id='PISA'>Programme for International Student Assessment 2009 USA Data</h2><span id='topic+PISA'></span>

<h3>Description</h3>

<p>This dataset contains scored cognitive item response data from the 2009
administration of the Programme for International Student Assessment (PISA),
an international study of education systems. The data, and license
under which they are released, are available online at
<a href="https://www.oecd.org/pisa/">https://www.oecd.org/pisa/</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PISA
</code></pre>


<h3>Format</h3>

<p><code>PISA</code> is a <code>list</code> containing four elements. The first,
<code>PISA$students</code>, is a <code>data.frame</code> containing 233 variables across
5233 individuals, with one row per individual. All but one variable come
from the USA PISA data file &quot;INT_COG09_S_DEC11.txt&quot;. The remaining variable,
language spoken at home, has been merged in from the student questionnaire
file &quot;INT_STQ09_DEC11.txt&quot;. Variable names match those found in the original
files:
</p>
 <dl>
<dt>list(&quot;stidstd&quot;)</dt><dd><p> Unique student ID (one for each of
the 5233 cases); </p>
</dd> <dt>list(&quot;schoolid&quot;)</dt><dd><p> School ID (there are 165
different schools); </p>
</dd> <dt>list(&quot;bookid&quot;)</dt><dd><p> ID for the test booklet given
to a particular student, of which there were 13; </p>
</dd> <dt>list(&quot;langn&quot;)</dt><dd>
<p>Student-reported language spoken at home, with 4466 students reporting
English (indicated by code 313), 484 students reporting Spanish (with code
156) and 185 students reporting &quot;another language&quot; (code 859); </p>
</dd>
<dt>list(&quot;m033q01&quot;)</dt><dd><p> Scored item-response data across the 189 items
included in the general cognitive assessment, described below; and </p>
</dd><dt>
to </dt><dd><p> Scored item-response data across the 189 items included in the general
cognitive assessment, described below; and </p>
</dd><dt>list(&quot;s527q04t&quot;)</dt><dd><p> Scored
item-response data across the 189 items included in the general cognitive
assessment, described below; and </p>
</dd> <dt>list(&quot;pv1math&quot;)</dt><dd><p> PISA scale
scores, referred to in the PISA technical documentation as &quot;plausible
values&quot;.  </p>
</dd><dt> to </dt><dd><p> PISA scale scores, referred to in the PISA technical
documentation as &quot;plausible values&quot;.  </p>
</dd><dt>list(&quot;pv5read5&quot;)</dt><dd><p> PISA scale
scores, referred to in the PISA technical documentation as &quot;plausible
values&quot;.  </p>
</dd> </dl>
<p> Next, <code>PISA$booklets</code> is a <code>data.frame</code> containing 4
columns and 756 rows and describes the 13 general cognitive assessment
booklets. Variables include: </p>
 <dl>
<dt>list(&quot;bookid&quot;)</dt><dd><p> The test
booklet ID, as in <code>PISA$students</code>; </p>
</dd> <dt>list(&quot;clusterid&quot;)</dt><dd><p> ID for
the cluster or item subset in which an item was placed; items were fully
nested within clusters; however, each item cluster appeared in four
different test booklets; </p>
</dd> <dt>list(&quot;itemid&quot;)</dt><dd><p> Item ID, matching the
columns of <code>PISA$students</code>; each item appears in <code>PISA$booklets</code>
four times, once for each booklet; and </p>
</dd> <dt>list(&quot;order&quot;)</dt><dd><p> The order in
which the cluster was presented within a given booklet.  </p>
</dd> </dl>

<p><code>PISA$items</code> is a <code>data.frame</code> containing 4 columns and 189 rows,
with one row per item. Variables include: </p>
 <dl>
<dt>list(&quot;itemid&quot;)</dt><dd>
<p>Item ID, as in <code>PISA$booklets</code> </p>
</dd> <dt>list(&quot;clusterid&quot;)</dt><dd><p> Cluster ID,
as in <code>PISA$booklets</code> </p>
</dd> <dt>list(&quot;max&quot;)</dt><dd><p> Maximum possible score
value, either 1 or 2 points, with dichotomous scoring (max of 1) used for
the majority of items; and </p>
</dd> <dt>list(&quot;subject&quot;)</dt><dd><p> The subject of an item,
equivalent to the first character in <code>itemid</code> and <code>clusterid</code>.  </p>
</dd>
<dt>list(&quot;format&quot;)</dt><dd><p> Item format, abbreviated as <code>mc</code> for multiple
choice, <code>cmc</code> for complex multiple choice, <code>ocr</code> for open
constructed response, and <code>ccr</code> for closed constructed response.  </p>
</dd>
<dt>list(&quot;noptions&quot;)</dt><dd><p> Number of options, zero except for some multiple
choice items.  </p>
</dd> </dl>
<p> Finally, <code>PISA$totals</code> is a list of 13
<code>data.frame</code>s, one per booklet, where the columns correspond to total
scores for all students on each cluster for the corresponding booklet. These
total scores were calculated using <code>PISA$students</code> and
<code>PISA$booklets</code>. Elements within the <code>PISA$totals</code> list are named
by booklet, and the columns in the <code>data.frame</code> are named by cluster.
For example, <code>PISA$totals$b1$m1</code> contains the total scores on cluster
M1 for students taking booklet 1.
</p>


<h3>Source</h3>

<p>OECD (2012). PISA 2009 Technical Report, PISA, OECD Publishing.
http://dx.doi.org/10.1787/9789264167872-en
</p>
<p>Addition information can be found at the PISA website:
<a href="https://www.oecd.org/pisa/">https://www.oecd.org/pisa/</a>
</p>

<hr>
<h2 id='plot.bootstrap'>Plotting Bootstrap Equating Results</h2><span id='topic+plot.bootstrap'></span>

<h3>Description</h3>

<p>This function plots bootstrap equating results for objects of class
&ldquo;<code><a href="#topic+bootstrap">bootstrap</a></code>&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bootstrap'
plot(
  x,
  add = FALSE,
  out = "mean",
  xpoints,
  ypoints,
  addident = TRUE,
  identy,
  identcol = 1,
  rescale = c(0, 1),
  xlab = "Total Score",
  ylab,
  col = rainbow(length(x$args)),
  pch,
  lty = 1,
  subset,
  morepars = NULL,
  addlegend = TRUE,
  legendtext,
  legendplace = "bottomright",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.bootstrap_+3A_x">x</code></td>
<td>
<p>output from the <code><a href="#topic+bootstrap">bootstrap</a></code> function.</p>
</td></tr>
<tr><td><code id="plot.bootstrap_+3A_add">add</code></td>
<td>
<p>logical, with default <code>FALSE</code>, specifying whether to create
a new plot or add to the current one.</p>
</td></tr>
<tr><td><code id="plot.bootstrap_+3A_out">out</code></td>
<td>
<p>character vector specifying the output to be plotted, either the
mean equated scores (<code>"mean"</code>), standard errors (<code>"se"</code>), bias
(<code>"bias"</code>), or RMSE (<code>"rmse"</code>).</p>
</td></tr>
<tr><td><code id="plot.bootstrap_+3A_xpoints">xpoints</code>, <code id="plot.bootstrap_+3A_ypoints">ypoints</code></td>
<td>
<p>optional vectors of the same length containing raw
scores on forms X and Y, assuming a single group or equivalent groups
design.</p>
</td></tr>
<tr><td><code id="plot.bootstrap_+3A_addident">addident</code></td>
<td>
<p>logical, with default <code>TRUE</code>, for plotting the identity
function. The result depends on <code>out</code>.</p>
</td></tr>
<tr><td><code id="plot.bootstrap_+3A_identy">identy</code></td>
<td>
<p>vector of y coordinates for plotting the identity line.
Defaults to the identity function when <code>out = "eqs"</code>, otherwise, a
horizontal line with intercept 0.</p>
</td></tr>
<tr><td><code id="plot.bootstrap_+3A_identcol">identcol</code></td>
<td>
<p>color used for plotting the identity line.</p>
</td></tr>
<tr><td><code id="plot.bootstrap_+3A_rescale">rescale</code></td>
<td>
<p>intercept and slope, with default 0 and 1, used to rescale
all lines before plotting.</p>
</td></tr>
<tr><td><code id="plot.bootstrap_+3A_xlab">xlab</code>, <code id="plot.bootstrap_+3A_ylab">ylab</code>, <code id="plot.bootstrap_+3A_col">col</code>, <code id="plot.bootstrap_+3A_pch">pch</code>, <code id="plot.bootstrap_+3A_lty">lty</code></td>
<td>
<p>graphical parameters passed to <code>par</code>, with
the lengths of col and lty recycled as necessary.</p>
</td></tr>
<tr><td><code id="plot.bootstrap_+3A_subset">subset</code></td>
<td>
<p>vector for subsetting the output when multiple equating
functions are included in <code>x</code>.</p>
</td></tr>
<tr><td><code id="plot.bootstrap_+3A_morepars">morepars</code></td>
<td>
<p>list of additional graphical parameters, excluding
<code>xlab</code>, <code>ylab</code>, <code>col</code>, <code>pch</code>, <code>lty</code>.</p>
</td></tr>
<tr><td><code id="plot.bootstrap_+3A_addlegend">addlegend</code></td>
<td>
<p>logical, with default <code>TRUE</code>, indicating whether or
not a legend should be added.</p>
</td></tr>
<tr><td><code id="plot.bootstrap_+3A_legendtext">legendtext</code></td>
<td>
<p>character vector of text to be passed to the <code>legend</code>
argument of the <code>legend</code> function, defaulting to a combination of the
equating types and methods specified in each equating object.</p>
</td></tr>
<tr><td><code id="plot.bootstrap_+3A_legendplace">legendplace</code></td>
<td>
<p>placement of the legend.</p>
</td></tr>
<tr><td><code id="plot.bootstrap_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods, excluding
graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Lines are plotted for the chosen output type, whether mean equated scores
across replications (<code>out = "mean"</code>), standard errors (<code>out =
"se"</code>), bias (<code>out = "bias"</code>) or RMSE (<code>out = "rmse"</code>). The result
is similar to that of <code><a href="#topic+plot.equate">plot.equate</a></code>.
</p>


<h3>Author(s)</h3>

<p>Anthony Albano <a href="mailto:tony.d.albano@gmail.com">tony.d.albano@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bootstrap">bootstrap</a></code>, <code><a href="#topic+plot.equate">plot.equate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(122713)
neat.x &lt;- freqtab(KBneat$x, scales = list(0:36, 0:12))
neat.y &lt;- freqtab(KBneat$y, scales = list(0:36, 0:12))
eqargs &lt;- list(m.t = list(type = "mean", method = "t"),
  l.t = list(type = "lin", method = "t"),
	c.t = list(type = "circ", method = "t"))
bootout &lt;- bootstrap(x = neat.x, y = neat.y, args = eqargs,
	reps = 20)
plot(bootout, out = "se", legendplace = "top")

</code></pre>

<hr>
<h2 id='plot.equate'>Plotting Equating Results</h2><span id='topic+plot.equate'></span><span id='topic+plot.equate.list'></span>

<h3>Description</h3>

<p>Functions for plotting equating functions from one or more objects
of class &ldquo;<code>equate</code>&rdquo; or &ldquo;<code>equate.list</code>&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'equate'
plot(
  ...,
  elist = NULL,
  add = FALSE,
  out = "eqs",
  xpoints,
  ypoints,
  addident = TRUE,
  identy,
  identcol = 1,
  rescale = c(0, 1),
  xlab = "Total Score",
  ylab,
  col = rainbow(length(x)),
  pch,
  lty = 1,
  lwd = 1,
  subset,
  morepars = NULL,
  addlegend = TRUE,
  legendtext,
  legendplace = "bottomright"
)

## S3 method for class 'equate.list'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.equate_+3A_...">...</code></td>
<td>
<p>one or more equating objects, each containing results for
equating the same two test forms.</p>
</td></tr>
<tr><td><code id="plot.equate_+3A_elist">elist</code></td>
<td>
<p>list of equatings to be plotted.</p>
</td></tr>
<tr><td><code id="plot.equate_+3A_add">add</code></td>
<td>
<p>logical, with default <code>FALSE</code>, specifying whether to
create a new plot or add to the current one.</p>
</td></tr>
<tr><td><code id="plot.equate_+3A_out">out</code></td>
<td>
<p>character vector specifying the output to be plotted, either
equating functions (<code>"eqs"</code>), standard errors (<code>"se"</code>),
bias (<code>"bias"</code>), or RMSE (<code>"rmse"</code>).</p>
</td></tr>
<tr><td><code id="plot.equate_+3A_xpoints">xpoints</code>, <code id="plot.equate_+3A_ypoints">ypoints</code></td>
<td>
<p>optional vectors of the same length containing
raw scores on forms X and Y, assuming a single group or equivalent groups
design.</p>
</td></tr>
<tr><td><code id="plot.equate_+3A_addident">addident</code></td>
<td>
<p>logical, with default <code>TRUE</code>, for plotting the
identity function. The result depends on <code>out</code>.</p>
</td></tr>
<tr><td><code id="plot.equate_+3A_identy">identy</code></td>
<td>
<p>vector of y coordinates for plotting the identity line.
Defaults to the X scale when <code>out = "eqs"</code>, otherwise, a horizontal
line with intercept 0.</p>
</td></tr>
<tr><td><code id="plot.equate_+3A_identcol">identcol</code></td>
<td>
<p>color used for plotting the identity line.</p>
</td></tr>
<tr><td><code id="plot.equate_+3A_rescale">rescale</code></td>
<td>
<p>intercept and slope, with default 0 and 1, used to rescale
all lines before plotting.</p>
</td></tr>
<tr><td><code id="plot.equate_+3A_xlab">xlab</code>, <code id="plot.equate_+3A_ylab">ylab</code>, <code id="plot.equate_+3A_col">col</code>, <code id="plot.equate_+3A_pch">pch</code>, <code id="plot.equate_+3A_lty">lty</code>, <code id="plot.equate_+3A_lwd">lwd</code></td>
<td>
<p>graphical parameters passed to <code>par</code>,
with <code>col</code>, <code>pch</code>, <code>lty</code>, and <code>lwd</code> recycled as necessary.</p>
</td></tr>
<tr><td><code id="plot.equate_+3A_subset">subset</code></td>
<td>
<p>vector for subsetting the output when multiple equating
functions are included in <code>x</code>.</p>
</td></tr>
<tr><td><code id="plot.equate_+3A_morepars">morepars</code></td>
<td>
<p>list of additional graphical parameters, excluding
<code>xlab</code>, <code>ylab</code>, <code>col</code>, <code>pch</code>, <code>lty</code>, and <code>lwd</code>.</p>
</td></tr>
<tr><td><code id="plot.equate_+3A_addlegend">addlegend</code></td>
<td>
<p>logical, with default <code>TRUE</code>, indicating whether or
not a legend should be added.</p>
</td></tr>
<tr><td><code id="plot.equate_+3A_legendtext">legendtext</code></td>
<td>
<p>character vector of text to be passed to the <code>legend</code>
argument of the <code>legend</code> function, defaulting to a combination of the
equating types and methods specified in each equating object.</p>
</td></tr>
<tr><td><code id="plot.equate_+3A_legendplace">legendplace</code></td>
<td>
<p>placement of the legend.</p>
</td></tr>
<tr><td><code id="plot.equate_+3A_x">x</code></td>
<td>
<p>&ldquo;<code><a href="#topic+equate.list">equate.list</a></code>&rdquo; object, containing output from
multiple equatings.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Equating functions (<code>out = "eqs"</code>) are plotted as lines based on
the concordance table for each equating object that is supplied. Standard
errors (<code>out = "se"</code>) default to bootstrap standard errors, if
available, otherwise, analytical standard errors are plotted. Bias
(<code>out = "bias"</code>) and RMSE (<code>out = "rmse"</code>) are also taken
from bootstrapping output.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# See ?equate for additional examples

rx &lt;- as.freqtab(ACTmath[, 1:2])
ry &lt;- as.freqtab(ACTmath[, c(1, 3)])
set.seed(2007)

req1 &lt;- equate(rx, ry, type = "i", boot = TRUE, reps = 5)
req2 &lt;- equate(rx, ry, type = "m", boot = TRUE, reps = 5)
req3 &lt;- equate(rx, ry, type = "l", boot = TRUE, reps = 5)
req4 &lt;- equate(rx, ry, type = "e", boot = TRUE, reps = 5,
  smooth = "loglin", degree = 3)
req5 &lt;- composite(list(req1, req2), wc = .5, symmetric = TRUE)

plot(req1, req2, req3, req4, req5[[1]], addident = FALSE)
plot(req5)

</code></pre>

<hr>
<h2 id='plot.freqtab'>Plotting Frequency Distributions</h2><span id='topic+plot.freqtab'></span><span id='topic+points.freqtab'></span><span id='topic+bfreqplot'></span><span id='topic+ufreqplot'></span>

<h3>Description</h3>

<p>This function plots univariate and bivariate frequency tables of class
&ldquo;<code><a href="#topic+freqtab">freqtab</a></code>&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'freqtab'
plot(
  x,
  y = NULL,
  xcol = 1,
  ycol,
  pch = 16,
  ylty = 1,
  xlab = names(dimnames(x))[1],
  addlegend = !missing(y),
  legendtext,
  ...
)

## S3 method for class 'freqtab'
points(x, xcol = 1, pch = 16, ds = 50, dm = 100, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.freqtab_+3A_x">x</code></td>
<td>
<p>univariate or bivariate score distribution of class
&ldquo;<code><a href="#topic+freqtab">freqtab</a></code>&rdquo;.</p>
</td></tr>
<tr><td><code id="plot.freqtab_+3A_y">y</code></td>
<td>
<p>either an object of class &ldquo;<code>freqtab</code>&rdquo;, where
frequencies will be extracted, or a vector or matrix of frequencies, to be
added to the plot of <code>x</code>. See below for details.</p>
</td></tr>
<tr><td><code id="plot.freqtab_+3A_xcol">xcol</code>, <code id="plot.freqtab_+3A_ycol">ycol</code></td>
<td>
<p>colors used in plotting <code>x</code> and <code>y</code>.</p>
</td></tr>
<tr><td><code id="plot.freqtab_+3A_pch">pch</code></td>
<td>
<p>plotting symbol used to plot bivariate points.</p>
</td></tr>
<tr><td><code id="plot.freqtab_+3A_ylty">ylty</code></td>
<td>
<p>line type used to plot frequencies in <code>y</code>.</p>
</td></tr>
<tr><td><code id="plot.freqtab_+3A_xlab">xlab</code></td>
<td>
<p>label for the x axis.</p>
</td></tr>
<tr><td><code id="plot.freqtab_+3A_addlegend">addlegend</code></td>
<td>
<p>logical indicating whether or not a legend should be added.</p>
</td></tr>
<tr><td><code id="plot.freqtab_+3A_legendtext">legendtext</code></td>
<td>
<p>character vector of text to be passed to the <code>legend</code>
argument of the <code>legend</code> function, defaulting to column names used in
<code>y</code>.</p>
</td></tr>
<tr><td><code id="plot.freqtab_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods, such as
graphical parameters besides <code>col</code>, <code>type</code>, and <code>pch</code>.</p>
</td></tr>
<tr><td><code id="plot.freqtab_+3A_ds">ds</code>, <code id="plot.freqtab_+3A_dm">dm</code></td>
<td>
<p>integers for the scaling and center of the RGB density values,
with defaults of 50 and 100. These are used to convert the observed counts
in <code>x</code> to the [0, 255] range of RGB values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the points method, a scatterplot for <code>x</code> is added to the current
opened plot.
</p>
<p>For the plot method, when <code>x</code> is univariate, i.e, having 2 columns, a
frequency plot is created for <code>x</code>. When <code>x</code> is bivariate, e.g.,
coming from a single group equating design or one form of a nonequivalent
groups design, a scatterplot is produced with frequency plots for the
marginal distributions.
</p>
<p><code>y</code> is used to superimpose lines, e.g., smoothed frequencies, over the
(marginal) frequencies of <code>x</code>.
</p>
<p>Colors must be specified using <code>xcol</code> and <code>ycol</code>. When <code>ycol</code>
is missing, a vector of colors is created using <code>rainbow(ncol(y))</code>.
</p>


<h3>Value</h3>

<p>The univariate option produces a single line plot of <code>type =
"h"</code>. Frequencies from <code>y</code> are then superimposed. The bivariate option
produces a scatterplot with a marginal frequency plot for each distribution.
</p>


<h3>Author(s)</h3>

<p>Anthony Albano <a href="mailto:tony.d.albano@gmail.com">tony.d.albano@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+plot.table">plot.table</a></code>, <code><a href="#topic+plot.equate">plot.equate</a></code>,
<code><a href="graphics.html#topic+lines">lines</a></code>, <code><a href="graphics.html#topic+points">points</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- freqtab(KBneat$x, scales = list(0:36, 0:12))
plot(x)

xs &lt;- loglinear(x, degrees = c(4, 1),
  stepup = TRUE, showWarnings = FALSE)
plot(x, xs, lwd = 2)

</code></pre>

<hr>
<h2 id='presmoothing'>Frequency Distribution Presmoothing</h2><span id='topic+presmoothing'></span><span id='topic+presmoothing.default'></span><span id='topic+presmoothing.formula'></span><span id='topic+loglinear'></span><span id='topic+freqbump'></span><span id='topic+freqavg'></span>

<h3>Description</h3>

<p>These functions are used to smooth frequency distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>presmoothing(x, ...)

## Default S3 method:
presmoothing(
  x,
  smoothmethod = c("none", "average", "bump", "loglinear"),
  jmin,
  asfreqtab = TRUE,
  ...
)

## S3 method for class 'formula'
presmoothing(x, data, ...)

loglinear(
  x,
  scorefun,
  degrees = list(4, 2, 2),
  grid,
  rmimpossible,
  asfreqtab = TRUE,
  models,
  stepup = !missing(models),
  compare = FALSE,
  choose = FALSE,
  choosemethod = c("chi", "aic", "bic"),
  chip,
  verbose = FALSE,
  ...
)

freqbump(x, jmin = 1e-06, asfreqtab = FALSE, ...)

freqavg(x, jmin = 1, asfreqtab = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="presmoothing_+3A_x">x</code></td>
<td>
<p>either an object of class &ldquo;<code>freqtab</code>&rdquo; specifying a
univariate or multivariate score distribution, or a &ldquo;<code>formula</code>&rdquo;
object.</p>
</td></tr>
<tr><td><code id="presmoothing_+3A_...">...</code></td>
<td>
<p>further arguments passed to other methods. For
<code>presmoothing</code>, these are passed to <code>loglinear</code> and include those
listed above.</p>
</td></tr>
<tr><td><code id="presmoothing_+3A_smoothmethod">smoothmethod</code></td>
<td>
<p>character string indicating the smoothing method to be
used by <code>presmoothing</code>. <code>"none"</code> returns unsmoothed frequencies,
<code>"bump"</code> adds a small frequency to each score value, <code>"average"</code>
imputes small frequencies with average values, and <code>"loglinear"</code> fits
loglinear models. See below for details.</p>
</td></tr>
<tr><td><code id="presmoothing_+3A_jmin">jmin</code></td>
<td>
<p>for <code>smoothmethod = "average"</code>, the minimum frequency, as
an integer, below which frequencies will be replaced (default is 1). for
<code>smoothmethod = "bump"</code>, the value to be added to each score point (as
a probability, with default 1e-6).</p>
</td></tr>
<tr><td><code id="presmoothing_+3A_asfreqtab">asfreqtab</code></td>
<td>
<p>logical, with default <code>TRUE</code>, indicating whether or
not a frequency table should be returned. For <code>smoothmethod =
"average"</code> and <code>smoothmethod = "bump"</code>, the alternative is a vector of
frequencies. For <code>loglinear</code>, there are other options.</p>
</td></tr>
<tr><td><code id="presmoothing_+3A_data">data</code></td>
<td>
<p>an object of class &ldquo;<code>freqtab</code>&rdquo;.</p>
</td></tr>
<tr><td><code id="presmoothing_+3A_scorefun">scorefun</code></td>
<td>
<p>matrix of score functions used in loglinear presmoothing,
where each column includes a transformation of the score scale or
interactions between score scales. If missing, <code>degrees</code> and
<code>xdegree</code> will be used to construct polynomial score functions.</p>
</td></tr>
<tr><td><code id="presmoothing_+3A_degrees">degrees</code></td>
<td>
<p>list of integer vectors, each one indicating the maximum
polynomial score transformations to be computed for each variable at a given
order of interactions. Defaults (<code>degrees = list(4, 2, 2)</code>) are
provided for up to trivariate interactions. <code>degrees</code> are ignored if
<code>scorefun</code> or <code>grid</code> are provided. See below for details.</p>
</td></tr>
<tr><td><code id="presmoothing_+3A_grid">grid</code></td>
<td>
<p>matrix with one column per margin in <code>x</code> and one row per
term in the model. See below for details.</p>
</td></tr>
<tr><td><code id="presmoothing_+3A_rmimpossible">rmimpossible</code></td>
<td>
<p>integer vector indicating columns in <code>x</code> to be used
in removing impossible scores before smoothing, assuming internal anchor
variables. Impossible scores are kept by default. See below.</p>
</td></tr>
<tr><td><code id="presmoothing_+3A_models">models</code></td>
<td>
<p>integer vector indicating which model terms should be grouped
together when fitting multiple nested models. E.g., <code>models = c(1, 1,
2, 3)</code> will compare three models, with the first two terms in model one, the
third term added in model two, and the fourth in model three.</p>
</td></tr>
<tr><td><code id="presmoothing_+3A_stepup">stepup</code></td>
<td>
<p>logical, with default <code>FALSE</code>, indicating whether or not
multiple nested models should be automatically fit. If <code>TRUE</code> and
<code>models</code> is missing, an attempt will be made to create it using
<code>grid</code> and/or <code>degrees</code>. Otherwise, in the absence of
<code>models</code>, each column in <code>scorefun</code> will define a new sequential
model.</p>
</td></tr>
<tr><td><code id="presmoothing_+3A_compare">compare</code></td>
<td>
<p>logical, with default <code>FALSE</code>, indicating whether or not
fit for nested models should be compared. If <code>TRUE</code>, <code>stepup</code> is
also set to <code>TRUE</code> and only results from the model fit comparison are
returned, that is, <code>verbose</code> is ignored.</p>
</td></tr>
<tr><td><code id="presmoothing_+3A_choose">choose</code></td>
<td>
<p>logical, with default <code>FALSE</code>, indicating whether or not
the best-fitting model should be returned after comparing fit of nested
models. Useful for automating model selection in simulations.</p>
</td></tr>
<tr><td><code id="presmoothing_+3A_choosemethod">choosemethod</code></td>
<td>
<p>string, indicating the method for selecting a
best-fitting model when <code>choose = TRUE</code>. <code>"chi"</code>
selects the most complex model with chi-square p-value below the criterion
in <code>chip</code>. Remaining methods choose the model with lowest value.</p>
</td></tr>
<tr><td><code id="presmoothing_+3A_chip">chip</code></td>
<td>
<p>proportion specifying the type-I error rate for model selection
based on <code>choosemethod = "chi"</code>.</p>
</td></tr>
<tr><td><code id="presmoothing_+3A_verbose">verbose</code></td>
<td>
<p>logical, with default <code>FALSE</code>, indicating whether or not
full <code>glm</code> output should be returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Loglinear smoothing is a flexible procedure for reducing irregularities in a
frequency distribution prior to equating, where the degree of each
polynomial term determines the specific moment of the observed distribution
that is preserved in the fitted distribution (see below for examples). The
<code>loglinear</code> function is a wrapper for <code><a href="stats.html#topic+glm">glm</a></code>, and is used to
simplify the creation of polynomial score functions and the fitting and
comparing of multiple loglinear models.
</p>
<p><code>scorefun</code>, if supplied, must contain at least one score function of
the scale score values. Specifying a list to <code>degrees</code> is an
alternative to supplying <code>scorefun</code>. Each list element in
<code>degrees</code> should be a vector equal in length to the number of variables
contained in <code>x</code>; there should also be one such vector for each
possible level of interaction between the variables in <code>x</code>.
</p>
<p>For example, the default <code>degrees = list(4, 2, 2)</code> is recycled to
produce <code>list(c(4, 4, 4), c(2, 2, 2), c(2, 2, 2))</code>, resulting in
polynomials to the fourth power for each univariate distribution, to the
second power for each two-way interaction, and to the second power for the
three-way interaction.
</p>
<p>Terms can also be specified with <code>grid</code>, which is a matrix with each
row containing integers specifying the powers for each variable at each
interaction term, including main effects. For example, the main effect to
the first power for the total score in a bivariate distribution would be
<code>c(1, 0)</code>; the interaction to the second power would be <code>c(2, 2)</code>.
</p>
<p><code>stepup</code> is used to run nested models based on subsets of the columns
in <code>scorefun</code>. Output will correspond to models based on columns 1 and
2, 1 through 3, 1 through 4, to 1 through <code>ncol(scorefun)</code>. This list
of polynomial terms is then used to create a <code>grid</code> using
<code>expand.grid</code>. The <code>grid</code> can also be supplied directly, in which
case <code>degrees</code> will be ignored.
</p>
<p><code>compare</code> returns output as an <code>anova</code> table, comparing model fit
for all the models run with <code>stepup = TRUE</code>, or by specifying more than
one model in <code>models</code>. When <code>choose = TRUE</code>, the arguments
<code>choosemethod</code> and <code>chip</code> are used to automatically select the
best-fitting model based on the <code>anova</code> table from running
<code>compare</code>.
</p>
<p>The remaining smoothing methods make adjustments to scores with low or zero
frequencies. <code>smoothmethod = "bump"</code> adds the proportion <code>jmin</code> to
each score point and then adjusts the probabilities to sum to 1.
<code>smoothmethod = "average"</code> replaces frequencies falling below the
minimum <code>jmin</code> with averages of adjacent values.
</p>


<h3>Value</h3>

<p>When <code>smoothmethod = "average"</code> or <code>smoothmethod =
"bump"</code>, either a smoothed frequency vector or table is returned. Otherwise,
<code>loglinear</code> returns the following: </p>
<ul>
<li><p>when <code>compare = TRUE</code>,
an anova table for model fit </p>
</li>
<li><p>when <code>asfreqtab = TRUE</code>, a
smoothed frequency table </p>
</li>
<li><p>when <code>choose = TRUE</code>, a smoothed
frequency table with attribute &quot;anova&quot; containing the model fit table for
all models compared </p>
</li>
<li><p>when <code>verbose = TRUE</code>, full <code>glm</code>
output, for all nested models when <code>stepup = TRUE</code> </p>
</li>
<li><p>when
<code>stepup = TRUE</code> and <code>verbose = FALSE</code>, a <code>data.frame</code> of
fitted frequencies, with one column per model</p>
</li></ul>



<h3>Methods (by class)</h3>


<ul>
<li> <p><code>default</code>: Default method for frequency tables.
</p>
</li>
<li> <p><code>formula</code>: Method for &ldquo;<code>formula</code>&rdquo; objects.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Anthony Albano <a href="mailto:tony.d.albano@gmail.com">tony.d.albano@gmail.com</a>
</p>


<h3>References</h3>

<p>Holland, P. W., and Thayer, D. T. (1987). <em>Notes on the use
of log-linear models for fitting discrete probability distributions</em> (PSR
Technical Rep. No. 87-79; ETS RR-87-31). Princeton, NJ: ETS.
</p>
<p>Holland, P. W., and Thayer, D. T. (2000). Univariate and bivariate loglinear
models for discrete test score distributions. <em>Journal of Educational
and Behavioral Statistics, 25</em>, 133&ndash;183.
</p>
<p>Moses, T., and Holland, P. W. (2008). <em>Notes on a general framework for
observed score equating</em> (ETS Research Rep. No. RR-08-59). Princeton, NJ:
ETS.
</p>
<p>Moses, T., and Holland, P. W. (2009). Selection strategies for
univariate loglinear smoothing models and their effect on
equating function accuracy. <em>Journal of Educational Measurement, 46</em>, 159&ndash;176.
ETS.
</p>
<p>Wang, T. (2009). Standard errors of equating for the percentile rank-based
equipercentile equating with log-linear presmoothing. <em>Journal of
Educational and Behavioral Statistics, 34</em>, 7&ndash;23.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="stats.html#topic+loglin">loglin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(2010)
x &lt;- round(rnorm(1000, 100, 15))
xscale &lt;- 50:150
xtab &lt;- freqtab(x, scales = xscale)

# Adjust frequencies
plot(xtab, y = cbind(average = freqavg(xtab),
  bump = freqbump(xtab)))

# Smooth x up to 8 degrees and choose best fitting model
# based on aic minimization
xlog1 &lt;- loglinear(xtab, degrees = 8,
  choose = TRUE, choosemethod = "aic")
plot(xtab, as.data.frame(xlog1)[, 2],
  legendtext = "degree = 3")

# Add "teeth" and "gaps" to x
# Smooth with formula interface
teeth &lt;- c(.5, rep(c(1, 1, 1, 1, .5), 20))
xttab &lt;- as.freqtab(cbind(xscale, c(xtab) * teeth))
xlog2 &lt;- presmoothing(~ poly(total, 3, raw = TRUE),
  xttab, showWarnings = FALSE)

# Smooth xt using score functions that preserve 
# the teeth structure (also 3 moments)
teeth2 &lt;- c(1, rep(c(0, 0, 0, 0, 1), 20))
xt.fun &lt;- cbind(xscale, xscale^2, xscale^3)
xt.fun &lt;- cbind(xt.fun, teeth2, xt.fun * teeth2)
xlog3 &lt;- loglinear(xttab, xt.fun, showWarnings = FALSE)

# Plot to compare teeth versus no teeth
op &lt;- par(no.readonly = TRUE)
par(mfrow = c(3, 1))
plot(xttab, main = "unsmoothed", ylim = c(0, 30))
plot(xlog2, main = "ignoring teeth", ylim = c(0, 30))
plot(xlog3, main = "preserving teeth", ylim = c(0, 30))
par(op)

# Bivariate example, preserving first 3 moments of total
# and anchor for x and y, and the covariance
# between anchor and total
# see equated scores in Wang (2009), Table 4
xvtab &lt;- freqtab(KBneat$x, scales = list(0:36, 0:12))
yvtab &lt;- freqtab(KBneat$y, scales = list(0:36, 0:12))
Y &lt;- as.data.frame(yvtab)[, 1]
V &lt;- as.data.frame(yvtab)[, 2]
scorefun &lt;- cbind(Y, Y^2, Y^3, V, V^2, V^3, V*Y)
wang09 &lt;- equate(xvtab, yvtab, type = "equip",
  method = "chained", smooth = "loglin",
  scorefun = scorefun)
wang09$concordance

# Removing impossible scores has essentially no impact
xvlog1 &lt;- loglinear(xvtab, scorefun, asfreqtab = FALSE)
xvlog2 &lt;- loglinear(xvtab, scorefun, rmimpossible = 1:2)
plot(xvtab, cbind(xvlog1,
	xvlog2 = as.data.frame(xvlog2)[, 3]))

</code></pre>

<hr>
<h2 id='px'>Percentile Ranks and Cumulative Frequencies</h2><span id='topic+px'></span><span id='topic+px.default'></span><span id='topic+px.freqtab'></span><span id='topic+fx'></span><span id='topic+fx.default'></span><span id='topic+fx.freqtab'></span>

<h3>Description</h3>

<p>These functions compute percentile ranks and cumulative frequency
distributions for frequency tables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>px(x, ...)

## Default S3 method:
px(x, y, ys, ...)

## S3 method for class 'freqtab'
px(x, margin = 1, y, ymargin = 1, ...)

fx(x, ...)

## Default S3 method:
fx(x, ...)

## S3 method for class 'freqtab'
fx(x, margin = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="px_+3A_x">x</code></td>
<td>
<p>either a vector of counts, or an object of class
&ldquo;<code>freqtab</code>&rdquo; from which counts will be taken.</p>
</td></tr>
<tr><td><code id="px_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="px_+3A_y">y</code></td>
<td>
<p>an object of class &ldquo;<code>freqtab</code>&rdquo; when <code>x</code> is as
well, otherwise, a vector or <code>data.frame</code> of counts. See below for
details.</p>
</td></tr>
<tr><td><code id="px_+3A_ys">ys</code></td>
<td>
<p>vector specifying the <code>y</code> score scale, when it is not
contained in the first column of <code>y</code>. If <code>y</code> can be converted to a
<code>data.frame</code>, it is assumed to be univariate with the first column
containing the score scale and the second containing the counts.</p>
</td></tr>
<tr><td><code id="px_+3A_margin">margin</code>, <code id="px_+3A_ymargin">ymargin</code></td>
<td>
<p>integers specifying the margins for which frequencies
or percentile ranks will be returned. <code>margin</code> applies to <code>x</code> and
<code>ymargin</code> to <code>y</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions compute percentile ranks and cumulative frequencies for a
univariate distribution, and percentile ranks from one univariate
distribution (<code>x</code>) corresponding to score values in another (<code>y</code>).
</p>


<h3>Value</h3>

<p>A vector is returned containing either percentile ranks or
cumulative frequencies with length equal to <code>length(x)</code>.
</p>


<h3>Author(s)</h3>

<p>Anthony Albano <a href="mailto:tony.d.albano@gmail.com">tony.d.albano@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+freqtab">freqtab</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- as.freqtab(ACTmath[, 1:2], drop = TRUE)
y &lt;- as.freqtab(ACTmath[, c(1, 3)], drop = TRUE)

# Percentile ranks for the x scale
round(px(x), 3)

# Percentile ranks in y for x each score
round(px(x, y = y), 3)

# Cumulative frequency distribution for x
round(fx(x), 3)

</code></pre>

<hr>
<h2 id='sample.freqtab'>Bootstrap Random Sampling from Frequency Tables</h2><span id='topic+sample.freqtab'></span>

<h3>Description</h3>

<p>An extension of <code><a href="base.html#topic+sample">sample</a></code> to objects of class
&ldquo;<code>freqtab</code>&rdquo; for bootstrap sampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample.freqtab(x, size = sum(x), replace = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample.freqtab_+3A_x">x</code></td>
<td>
<p>object of class &ldquo;<code>freqtab</code>&rdquo;, which is an array of
counts across one or more numeric dimensions.</p>
</td></tr>
<tr><td><code id="sample.freqtab_+3A_size">size</code></td>
<td>
<p>non-negative integer giving the sample size.</p>
</td></tr>
<tr><td><code id="sample.freqtab_+3A_replace">replace</code></td>
<td>
<p>logical with default <code>TRUE</code> indicating whether
sampling should be with replacement.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table array, as a &ldquo;<code>freqtab</code>&rdquo; object, sampled
from the original <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Anthony Albano <a href="mailto:tony.d.albano@gmail.com">tony.d.albano@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+table">table</a></code>, <code><a href="stats.html#topic+ftable">ftable</a></code>,
<code><a href="#topic+summary.freqtab">summary.freqtab</a></code>, <code><a href="#topic+plot.freqtab">plot.freqtab</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Sample with replacement from ACT math and compare results
set.seed(2021)
rx &lt;- as.freqtab(ACTmath[, 1:2])
rxs &lt;- sample.freqtab(rx)
summary(rx)
summary(rxs)

</code></pre>

<hr>
<h2 id='summary.freqtab'>Descriptive Statistics for Frequency Tables</h2><span id='topic+summary.freqtab'></span><span id='topic+mean.freqtab'></span><span id='topic+sd.freqtab'></span><span id='topic+var.freqtab'></span><span id='topic+cov.freqtab'></span><span id='topic+cor.freqtab'></span><span id='topic+min.freqtab'></span><span id='topic+max.freqtab'></span><span id='topic+range.freqtab'></span><span id='topic+skew.freqtab'></span><span id='topic+kurt.freqtab'></span>

<h3>Description</h3>

<p>These functions return descriptive statistics for a frequency table of class
&ldquo;<code><a href="#topic+freqtab">freqtab</a></code>&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'freqtab'
summary(object, margin = seq(margins(object)), ...)

## S3 method for class 'freqtab'
mean(x, margin = 1, ...)

sd.freqtab(x, margin = 1)

var.freqtab(x, margin = 1)

cov.freqtab(x, margin = seq(margins(x)))

cor.freqtab(x, margin = seq(margins(x)))

## S3 method for class 'freqtab'
min(x, margin = 1, ..., na.rm = FALSE)

## S3 method for class 'freqtab'
max(x, margin = 1, ..., na.rm = FALSE)

## S3 method for class 'freqtab'
range(x, margin = 1, ..., na.rm = FALSE)

skew.freqtab(x, margin = 1)

kurt.freqtab(x, margin = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.freqtab_+3A_object">object</code>, <code id="summary.freqtab_+3A_x">x</code></td>
<td>
<p>object of class &ldquo;<code>freqtab</code>&rdquo;.</p>
</td></tr>
<tr><td><code id="summary.freqtab_+3A_margin">margin</code></td>
<td>
<p>integer vector specifying the margin(s) for which summary
statistics will be returned. This defaults to <code>1</code> for univariate
statistics, and <code>seq(margins(x))</code>, i.e., all the margins, for
multivariate statistics (covariance and correlation).</p>
</td></tr>
<tr><td><code id="summary.freqtab_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.freqtab_+3A_na.rm">na.rm</code></td>
<td>
<p>logical indicating whether missing values should be removed,
currently ignored since frequency tables cannot contain missing values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mean</code>, <code>sd.freqtab</code>, <code>var.freqtab</code>, <code>skew.freqtab</code>, and
<code>kurt.freqtab</code> return the mean, standard deviation, variance, skewness,
and kurtosis. <code>min</code> and <code>max</code> return the minimum and maximum
observed scores, and <code>range</code> returns both. <code>cov.freqtab</code> and
<code>cor.freqtab</code> return the covariance and correlation matrices for one or
more variables. <code>summary</code> returns univariate statistics across one or
more margins.
</p>


<h3>Value</h3>

<p><code>summary</code> returns a data frame of summary statistics, including
the mean, standard deviation, skewness, kurtosis, minimum, maximum, and
number of observations for each variable in <code>margin</code>. Otherwise, a
vector of length <code>length(margin)</code> is returned with the corresponding
statistic for each variable.
</p>


<h3>Author(s)</h3>

<p>Anthony Albano <a href="mailto:tony.d.albano@gmail.com">tony.d.albano@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+freqtab">freqtab</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
summary(as.freqtab(ACTmath[, 1:2]))

ny &lt;- freqtab(KBneat$y, scales = list(0:36, 0:12))
summary(ny)
cov.freqtab(ny)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
