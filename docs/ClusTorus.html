<!DOCTYPE html><html><head><title>Help for package ClusTorus</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ClusTorus}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ClusTorus-package'><p>ClusTorus: Prediction and Clustering on the Torus by Conformal Prediction</p></a></li>
<li><a href='#ang.dist'><p>Angular distance</p></a></li>
<li><a href='#ang.minus'><p>Angular subtraction</p></a></li>
<li><a href='#ang.pdist'><p>Pairwise L2 angular distance</p></a></li>
<li><a href='#clus.torus'><p>Clustering on the torus by conformal prediction</p></a></li>
<li><a href='#cluster.assign.torus'><p>Clustering by connected components of ellipsoids</p></a></li>
<li><a href='#cp.torus.kde'><p>Conformal prediction set indices with kernel density estimation</p></a></li>
<li><a href='#data_6VXX'><p>6VXX: Structure of the SARS-CoV-2 spike glycoprotein(closed state)</p></a></li>
<li><a href='#ellip.kmeans.torus'><p>K-Means Clustering to K-Spheres Clustering on Torus</p></a></li>
<li><a href='#EMsinvMmix'><p>Fitting mixtures of bivariate von Mises distribution</p></a></li>
<li><a href='#grid.torus'><p>Grid on torus</p></a></li>
<li><a href='#hyperparam.alpha'><p>Selecting optimal level based on the runs of the number of clusters</p></a></li>
<li><a href='#hyperparam.J'><p>Selecting optimal number of mixture components based on various criteria</p></a></li>
<li><a href='#hyperparam.torus'><p>Selecting optimal hyperparameters for the conformal prediction set</p></a></li>
<li><a href='#icp.torus'><p>Conformity score for inductive prediction sets</p></a></li>
<li><a href='#icp.torus.eval'><p>Inductive prediction sets for each level</p></a></li>
<li><a href='#ILE'><p>ILE: Structure of the Isoleucine</p></a></li>
<li><a href='#kde.torus'><p>Kernel density estimation using circular von Mises distribution</p></a></li>
<li><a href='#kmeans.torus'><p>K-Means Clustering on Torus</p></a></li>
<li><a href='#on.torus'><p>Transform the angular data to be on principal interval</p></a></li>
<li><a href='#SARS_CoV_2'><p>SARS-CoV-2: chain B of Structure of the SARS-CoV-2 spike glycoprotein(closed state)</p></a></li>
<li><a href='#tor.minus'><p>Toroidal subtraction</p></a></li>
<li><a href='#toydata1'><p>toydata1: Labelled Data for 5 Clusters</p></a></li>
<li><a href='#toydata2'><p>toydata2: Labelled Data for 3 Clusters</p></a></li>
<li><a href='#wtd.stat.ang'><p>Weighted extrinsic mean direction and mean resultant length</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Prediction and Clustering on the Torus by Conformal Prediction</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides various tools of for clustering multivariate angular 
  data on the torus. The package provides angular 
  adaptations of usual clustering methods such as the k-means 
  clustering, pairwise angular distances, which can be used as an 
  input for distance-based clustering algorithms, and implements
  clustering based on the conformal prediction framework. Options 
  for the conformal scores include scores based on a kernel density 
  estimate, multivariate von Mises mixtures, and naive k-means clusters. 
  Moreover, the package provides some basic data handling tools for 
  angular data.</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.2</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/sungkyujung/ClusTorus">https://github.com/sungkyujung/ClusTorus</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/sungkyujung/ClusTorus/issues">https://github.com/sungkyujung/ClusTorus/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>BAMBI, igraph, purrr, ggplot2, rlang, stats, utils, cowplot</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, tidyverse</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-01-04 01:58:20 UTC; hongseung-gi</td>
</tr>
<tr>
<td>Author:</td>
<td>Sungkyu Jung [aut, cph],
  Seungki Hong [aut, cre],
  Kiho Park [ctb],
  Byungwon Kim [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Seungki Hong &lt;skgaboja@snu.ac.kr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-01-04 10:10:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='ClusTorus-package'>ClusTorus: Prediction and Clustering on the Torus by Conformal Prediction</h2><span id='topic+ClusTorus'></span><span id='topic+ClusTorus-package'></span>

<h3>Description</h3>

<p>Provides various tools of for clustering multivariate angular 
data on the torus. The package provides angular 
adaptations of usual clustering methods such as the k-means 
clustering, pairwise angular distances, which can be used as an 
input for distance-based clustering algorithms, and implements
clustering based on the conformal prediction framework. Options 
for the conformal scores include scores based on a kernel density 
estimate, multivariate von Mises mixtures, and naive k-means clusters. 
Moreover, the package provides some basic data handling tools for 
angular data.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Seungki Hong <a href="mailto:skgaboja@snu.ac.kr">skgaboja@snu.ac.kr</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Sungkyu Jung <a href="mailto:sungkyu@snu.ac.kr">sungkyu@snu.ac.kr</a> [copyright holder]
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Kiho Park [contributor]
</p>
</li>
<li><p> Byungwon Kim [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/sungkyujung/ClusTorus">https://github.com/sungkyujung/ClusTorus</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/sungkyujung/ClusTorus/issues">https://github.com/sungkyujung/ClusTorus/issues</a>
</p>
</li></ul>


<hr>
<h2 id='ang.dist'>Angular distance</h2><span id='topic+ang.dist'></span>

<h3>Description</h3>

<p><code>ang.dist</code> computes element-wise angular distance between
two angular values in <code class="reqn">[0,2\pi)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ang.dist(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ang.dist_+3A_x">x</code>, <code id="ang.dist_+3A_y">y</code></td>
<td>
<p>angular data(both scalar or vector) whose elements are in <code class="reqn">[0, 2\pi)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>angular data (scalar or vector) whose elements are in <code class="reqn">[0, 2\pi)</code>
</p>


<h3>References</h3>

<p>Jung, S., Park, K., &amp; Kim, B. (2021). Clustering on the torus by conformal prediction. <em>The Annals of Applied Statistics</em>, 15(4), 1583-1603.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(pi/3, 0)
y &lt;- c(pi/4, pi/2)

ang.dist(x, y)
</code></pre>

<hr>
<h2 id='ang.minus'>Angular subtraction</h2><span id='topic+ang.minus'></span>

<h3>Description</h3>

<p><code>ang.minus</code> computes element-wise angular subtraction defined as
</p>
<p style="text-align: center;"><code class="reqn">x -  y := Arg(exp(i(x-y)))</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>ang.minus(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ang.minus_+3A_x">x</code>, <code id="ang.minus_+3A_y">y</code></td>
<td>
<p>angular data(scalar or vector) whose elements are in <code class="reqn">[0, 2\pi)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a scalar or a vector whose elements are in
<code class="reqn">[-\pi, \pi)</code>.
</p>


<h3>References</h3>

<p>Jung, S., Park, K., &amp; Kim, B. (2021). Clustering on the torus by conformal prediction. The Annals of Applied Statistics, 15(4), 1583-1603.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(pi/2, 0)
y &lt;- c(pi, pi/3)

ang.minus(x, y)
</code></pre>

<hr>
<h2 id='ang.pdist'>Pairwise L2 angular distance</h2><span id='topic+ang.pdist'></span>

<h3>Description</h3>

<p><code>ang.pdist</code> computes pairwise angular distances matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ang.pdist(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ang.pdist_+3A_data">data</code></td>
<td>
<p>n x d angular data on <code class="reqn">[0, 2\pi)^d</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ang.pdist</code> returns pairwise angular distances matrix
with the class <code>dist</code>
</p>


<h3>References</h3>

<p>Jung, S., Park, K., &amp; Kim, B. (2021). Clustering on the torus by conformal prediction. The Annals of Applied Statistics, 15(4), 1583-1603.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ang.dist">ang.dist</a></code>, <code><a href="stats.html#topic+dist">dist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- matrix(c(pi/3, pi/3, pi/2,
                 pi, pi/4, pi/2,
                 0, pi/3, pi/6),
               ncol = 3, byrow = TRUE)

ang.pdist(data)
</code></pre>

<hr>
<h2 id='clus.torus'>Clustering on the torus by conformal prediction</h2><span id='topic+clus.torus'></span><span id='topic+plot.clus.torus'></span>

<h3>Description</h3>

<p><code>clus.torus</code> returns clustering results of data on the torus based on
inductive conformal prediction set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clus.torus(
  data,
  split.id = NULL,
  model = c("kmeans", "mixture"),
  mixturefitmethod = c("axis-aligned", "circular", "general"),
  kmeansfitmethod = c("general", "homogeneous-circular", "heterogeneous-circular",
    "ellipsoids"),
  J = NULL,
  level = NULL,
  option = NULL,
  verbose = TRUE,
  ...
)

## S3 method for class 'clus.torus'
plot(
  x,
  panel = 1,
  assignment = "outlier",
  data = NULL,
  ellipse = TRUE,
  type = NULL,
  overlay = FALSE,
  out = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clus.torus_+3A_data">data</code></td>
<td>
<p>n x d matrix of toroidal data on <code class="reqn">[0, 2\pi)^d</code>
or <code class="reqn">[-\pi, \pi)^d</code>. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="clus.torus_+3A_split.id">split.id</code></td>
<td>
<p>a n-dimensional vector consisting of values 1 (estimation)
and 2(evaluation)</p>
</td></tr>
<tr><td><code id="clus.torus_+3A_model">model</code></td>
<td>
<p>A string. One of &quot;mixture&quot; and &quot;kmeans&quot; which
determines the model or estimation methods. If &quot;mixture&quot;, the model is based
on the von Mises mixture, fitted
with an EM algorithm. It supports the von Mises mixture and its variants
based conformity scores. If &quot;kmeans&quot;, the model is also based on the von
Mises mixture, but the parameter estimation is implemented with the
elliptical k-means algorithm. It supports the
log-max-mixture based conformity score only. If the
dimension of data space is greater than 2, only &quot;kmeans&quot; is supported.
Default is <code>model = "kmeans"</code>.</p>
</td></tr>
<tr><td><code id="clus.torus_+3A_mixturefitmethod">mixturefitmethod</code></td>
<td>
<p>A string. One of &quot;circular&quot;, &quot;axis-aligned&quot;, and
&quot;general&quot; which determines the constraint of the EM fitting. Default is
&quot;axis-aligned&quot;. This argument only works for <code>model = "mixture"</code>.</p>
</td></tr>
<tr><td><code id="clus.torus_+3A_kmeansfitmethod">kmeansfitmethod</code></td>
<td>
<p>A string. One of &quot;general&quot;, ellipsoids&quot;,
&quot;heterogeneous-circular&quot; or &quot;homogeneous-circular&quot;. If &quot;general&quot;, the
elliptical k-means algorithm with no constraint is used. If &quot;ellipsoids&quot;,
only the one iteration of the algorithm is used. If&quot;heterogeneous-circular&quot;,
the same as above, but with the constraint that ellipsoids must be spheres.
If &quot;homogeneous-circular&quot;, the same as above but the radii of the spheres are
identical. Default is &quot;general&quot;. This argument only works for <code>model = "kmeans"</code>.</p>
</td></tr>
<tr><td><code id="clus.torus_+3A_j">J</code></td>
<td>
<p>the number of components for mixture model fitting. If <code>J</code> is a vector,
then <code>hyperparam.torus</code> is used to choose optimal <code>J</code>. If
<code>J == NULL</code>, then <code>J = 4:30</code> is used.</p>
</td></tr>
<tr><td><code id="clus.torus_+3A_level">level</code></td>
<td>
<p>a scalar in <code class="reqn">[0,1]</code>. The level of the conformal prediction set
used for clustering. If <code>level == NULL</code>, then <code>hyperparam.alpha</code> is
used to choose optimal <code>level</code></p>
</td></tr>
<tr><td><code id="clus.torus_+3A_option">option</code></td>
<td>
<p>A string. One of &quot;elbow&quot;, &quot;risk&quot;, &quot;AIC&quot;, or &quot;BIC&quot;, which determines the
criterion for the model selection. &quot;risk&quot; is based on the negative log-likelihood, &quot;AIC&quot;
for the Akaike Information Criterion, and &quot;BIC&quot; for the Bayesian Information Criterion.
&quot;elbow&quot; is based on minimizing the criterion used in Jung et. al.(2021).
This argument is only used if <code>J</code> is a vector or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="clus.torus_+3A_verbose">verbose</code></td>
<td>
<p>boolean index, which indicates whether display
additional details as to what the algorithm is doing or
how many loops are done. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="clus.torus_+3A_...">...</code></td>
<td>
<p>Further arguments that will be passed to <code>icp.torus</code> and
<code>hyperparam.torus</code></p>
</td></tr>
<tr><td><code id="clus.torus_+3A_x">x</code></td>
<td>
<p><code>clus.torus</code> object</p>
</td></tr>
<tr><td><code id="clus.torus_+3A_panel">panel</code></td>
<td>
<p>One of 1 or 2 which determines the type of plot. If <code>panel = 1</code>,
<code>x$cluster.obj</code> will be plotted, if <code>panel = 2</code>, <code>x$icp.torus</code> will be plotted.
If <code>panel = 3</code>, <code>x$hyperparam.select</code> will be plotted. Default is <code>panel = 1</code>.</p>
</td></tr>
<tr><td><code id="clus.torus_+3A_assignment">assignment</code></td>
<td>
<p>A string. One of &quot;outlier&quot;, &quot;log.density&quot;, &quot;posterior&quot;, &quot;mahalanobis&quot;. Default is &quot;outlier&quot;.</p>
</td></tr>
<tr><td><code id="clus.torus_+3A_ellipse">ellipse</code></td>
<td>
<p>A boolean index which determines whether plotting ellipse-intersections. Default is <code>TRUE</code>. Only available
for <code>panel = 2</code>.</p>
</td></tr>
<tr><td><code id="clus.torus_+3A_type">type</code></td>
<td>
<p>A string. One of &quot;mix&quot;, &quot;max&quot; or &quot;e&quot;. This argument is only available if <code>icp.torus</code>
object is fitted with <code>model = "mixture"</code>. Default is <code>NULL</code>. If <code>type != NULL</code>, argument
<code>ellipse</code> automatically becomes <code>FALSE</code>. If &quot;mix&quot;, it plots based on von Mises mixture.
If &quot;max&quot;, it plots based on von Mises max-mixture. If &quot;e&quot;, it plots based on ellipse-approximation.</p>
</td></tr>
<tr><td><code id="clus.torus_+3A_overlay">overlay</code></td>
<td>
<p>A boolean index which determines whether plotting ellipse-intersections on clustering plots. Default is <code>FALSE</code>.
Only available for <code>panel = 1</code>.</p>
</td></tr>
<tr><td><code id="clus.torus_+3A_out">out</code></td>
<td>
<p>An option for returning the ggplot object. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>clus.torus</code> is a user-friendly all-in-one function which implements following
procedures automatically: 1. compute conformity scores for given model and fitting method,
2. choose optimal model and level based on prespecified criterion, and
3. make clusters based on the chosen model and level. Procedure 1-3 can be
independently done with <code>icp.torus</code>, <code>hyperparam.torus</code>,
<code>hyperparam.J</code>, <code>hyperparam.alpha</code> and <code>cluster.assign.torus</code>.
If you want to see more detail for each procedure, please see
<code><a href="#topic+icp.torus">icp.torus</a></code>, <code><a href="#topic+hyperparam.J">hyperparam.J</a></code>, <code><a href="#topic+hyperparam.alpha">hyperparam.alpha</a></code>
<code><a href="#topic+hyperparam.torus">hyperparam.torus</a></code>, <code><a href="#topic+cluster.assign.torus">cluster.assign.torus</a></code>.
</p>


<h3>Value</h3>

<p><code>clus.torus</code> returns a <code>clus.torus</code> object, which consists of following 3 different S3 objects;
</p>

<dl>
<dt><code>cluster.obj</code></dt><dd><p><code>cluster.obj</code> object; clustering assignment results for
several methods. For detail, see <code><a href="#topic+cluster.assign.torus">cluster.assign.torus</a></code>.</p>
</dd>
<dt><code>icp.torus</code></dt><dd><p><code>icp.torus</code> object; containing model parameters and
conformity scores. For detail, see <code><a href="#topic+icp.torus">icp.torus</a></code>.</p>
</dd>
<dt><code>hyperparam.select</code></dt><dd><p><code>hyperparam.torus</code> object (if <code>J = NULL</code> or a
sequence of numbers, and  <code>level = NULL</code> or a sequence of numbers), <code>hyperparam.J</code> object (if <code>level</code> is a scalar), or <code>hyperparam.alpha</code> object (if <code>J</code> is a scalar);
contains information for the optimally chosen model (number of components J) and level (alpha)
based on prespecified criterion.  For detail, see <code><a href="#topic+hyperparam.torus">hyperparam.torus</a></code>, <code><a href="#topic+hyperparam.J">hyperparam.J</a></code>, and <code><a href="#topic+hyperparam.alpha">hyperparam.alpha</a></code>.</p>
</dd>
</dl>



<h3>References</h3>

<p>Jung, S., Park, K., &amp; Kim, B. (2021). Clustering on the torus by conformal prediction. <em>The Annals of Applied Statistics</em>, 15(4), 1583-1603.
</p>
<p>Mardia, K. V., Kent, J. T., Zhang, Z., Taylor, C. C., &amp; Hamelryck, T. (2012). Mixtures of concentrated multivariate sine distributions with applications to bioinformatics. <em>Journal of Applied Statistics</em>, 39(11), 2475-2492.
</p>
<p>Shin, J., Rinaldo, A., &amp; Wasserman, L. (2019). Predictive clustering. <em>arXiv preprint arXiv:1903.08125</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+icp.torus">icp.torus</a></code>, <code><a href="#topic+hyperparam.torus">hyperparam.torus</a></code>,
<code><a href="#topic+hyperparam.J">hyperparam.J</a></code>, <code><a href="#topic+hyperparam.alpha">hyperparam.alpha</a></code>
<code><a href="#topic+cluster.assign.torus">cluster.assign.torus</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data &lt;- toydata2[, 1:2]
n &lt;- nrow(data)
clus.torus(data = data, model = "kmeans", kmeansfitmethod = "general", J = 5:30, option = "risk")

</code></pre>

<hr>
<h2 id='cluster.assign.torus'>Clustering by connected components of ellipsoids</h2><span id='topic+cluster.assign.torus'></span><span id='topic+plot.cluster.obj'></span>

<h3>Description</h3>

<p><code>cluster.assign.torus</code> returns clustering assignment for data
given <code>icp.torus</code> objects, which can be constructed with
<code>icp.torus</code>.
</p>
<p><code>plot.clus.torus</code> plots clustering results, which is given by <code>cluster.obj</code> object, with some options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster.assign.torus(icp.object, data = NULL, level = NULL)

## S3 method for class 'cluster.obj'
plot(
  x,
  assignment = c("outlier", "log.density", "posterior", "mahalanobis"),
  overlay = FALSE,
  out = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster.assign.torus_+3A_icp.object">icp.object</code></td>
<td>
<p>an object must be an <code>icp.torus</code> object, which contains
all values to compute the conformity score constructed with <code>icp.torus</code>,
or a <code>hyperparam.torus</code> object which is generated by <code>hyperparam.torus</code>.</p>
</td></tr>
<tr><td><code id="cluster.assign.torus_+3A_data">data</code></td>
<td>
<p>n x d matrix of toroidal data on <code class="reqn">[0, 2\pi)^d</code>
or <code class="reqn">[-\pi, \pi)^d</code>.
If <code>data = NULL</code>, then data within the <code>icp.object</code> is used.</p>
</td></tr>
<tr><td><code id="cluster.assign.torus_+3A_level">level</code></td>
<td>
<p>a scalar in <code class="reqn">[0,1]</code>. If argument <code>icp.object</code> is an <code>icp.torus</code> object,
the default value for <code>level</code> is 0.1. If argument <code>icp.object</code> is
a <code>hyperparam.torus</code> object and <code>level = NULL</code>, then <code>level</code>
is set as the optimal level <code>hyperparam.torus$alphahat</code>.</p>
</td></tr>
<tr><td><code id="cluster.assign.torus_+3A_x">x</code></td>
<td>
<p><code>cluster.obj</code> object</p>
</td></tr>
<tr><td><code id="cluster.assign.torus_+3A_assignment">assignment</code></td>
<td>
<p>A string. One of &quot;outlier&quot;, &quot;log.density&quot;, &quot;posterior&quot;, &quot;mahalanobis&quot;. Default is &quot;outlier&quot;.</p>
</td></tr>
<tr><td><code id="cluster.assign.torus_+3A_overlay">overlay</code></td>
<td>
<p>A boolean index which determines whether plotting ellipse-intersections on clustering plots.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="cluster.assign.torus_+3A_out">out</code></td>
<td>
<p>An option for returning the ggplot object. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="cluster.assign.torus_+3A_...">...</code></td>
<td>
<p>additional parameter for ggplot2::ggplot()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>clustering assignment for data, given <code>icp.torus</code> objects
</p>

<dl>
<dt><code>cluster.id.by.log.density</code></dt><dd><p>cluster assignment result based on approximate log-density.</p>
</dd>
<dt><code>cluster.id.by.posterior</code></dt><dd><p>cluster assignment result based on the posterior probability.</p>
</dd>
<dt><code>cluster.id.outlier</code></dt><dd><p>cluster assignment result which regards data not included in conformal prediction set
as outliers.</p>
</dd>
<dt><code>cluster.id.by.Mah.dist</code></dt><dd><p>cluster assignment result based on Mahalanobis distance.</p>
</dd>
<dt><code>level</code></dt><dd><p>used level which determines the size of clusters(conformal prediction set).</p>
</dd>
<dt><code>data</code></dt><dd><p>input data which are assigned to each cluster.</p>
</dd>
<dt><code>icp.torus</code></dt><dd><p><code>icp.torus</code> object which is used for cluster assignment.</p>
</dd>
</dl>



<h3>References</h3>

<p>Jung, S., Park, K., &amp; Kim, B. (2021). Clustering on the torus by conformal prediction. <em>The Annals of Applied Statistics</em>, 15(4), 1583-1603.
</p>
<p>Gilitschenski, I., &amp; Hanebeck, U. D. (2012, July). A robust computational test for overlap of two arbitrary-dimensional ellipsoids in fault-detection of kalman filters. In <em>2012 15th International Conference on Information Fusion</em> (pp. 396-401). IEEE.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+icp.torus">icp.torus</a></code>, <code><a href="#topic+hyperparam.torus">hyperparam.torus</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- toydata1[, 1:2]
icp.torus &lt;- icp.torus(data, model = "kmeans",
                       kmeansfitmethod = "general",
                       J = 4, concentration = 25)
level &lt;- 0.1

cluster.assign.torus(icp.torus, level = level)
</code></pre>

<hr>
<h2 id='cp.torus.kde'>Conformal prediction set indices with kernel density estimation</h2><span id='topic+cp.torus.kde'></span><span id='topic+plot.cp.torus.kde'></span>

<h3>Description</h3>

<p><code>cp.torus.kde</code> computes conformal prediction set indices
(TRUE if in the set) using kernel density estimation as conformity score.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cp.torus.kde(data, eval.point = grid.torus(), level = 0.1, concentration = 25)

## S3 method for class 'cp.torus.kde'
plot(x, level.id = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cp.torus.kde_+3A_data">data</code></td>
<td>
<p>n x d matrix of toroidal data on <code class="reqn">[0, 2\pi)^d</code></p>
</td></tr>
<tr><td><code id="cp.torus.kde_+3A_eval.point">eval.point</code></td>
<td>
<p>N x N numeric matrix on <code class="reqn">[0, 2\pi)^d</code>. Default input is
<code>NULL</code>, which represents the fine grid points on <code class="reqn">[0, 2\pi)^d</code>.</p>
</td></tr>
<tr><td><code id="cp.torus.kde_+3A_level">level</code></td>
<td>
<p>either a scalar or a vector, or even <code>NULL</code>. Default value
is 0.1.</p>
</td></tr>
<tr><td><code id="cp.torus.kde_+3A_concentration">concentration</code></td>
<td>
<p>positive number which has the role of <code class="reqn">\kappa</code> of
von Mises distribution. Default value is 25.</p>
</td></tr>
<tr><td><code id="cp.torus.kde_+3A_x">x</code></td>
<td>
<p><code>cp.torus.kde</code> object</p>
</td></tr>
<tr><td><code id="cp.torus.kde_+3A_level.id">level.id</code></td>
<td>
<p>an integer among <code>1:length(cp.torus$level)</code>.</p>
</td></tr>
<tr><td><code id="cp.torus.kde_+3A_...">...</code></td>
<td>
<p>additional parameter for ggplot2::ggplot()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>level</code> is <code>NULL</code>, then return kde at <code>eval.point</code>
and at data points.
</p>
<p>If <code>level</code> is a vector, return the above and prediction set indices
for each value of level.
</p>


<h3>References</h3>

<p>Jung, S., Park, K., &amp; Kim, B. (2021). Clustering on the torus by conformal prediction. <em>The Annals of Applied Statistics</em>, 15(4), 1583-1603.
</p>
<p>Di Marzio, M., Panzera, A., &amp; Taylor, C. C. (2011). Kernel density estimation on the torus. <em>Journal of Statistical Planning and Inference</em>, 141(6), 2156-2173.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kde.torus">kde.torus</a></code>, <code><a href="#topic+grid.torus">grid.torus</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- ILE[1:200, 1:2]
cp.torus.kde(data, eval.point = grid.torus(),
             level = 0.05, concentration = 25)
</code></pre>

<hr>
<h2 id='data_6VXX'>6VXX: Structure of the SARS-CoV-2 spike glycoprotein(closed state)</h2><span id='topic+data_6VXX'></span>

<h3>Description</h3>

<p>The torsion angle dataset of SARS-CoV-2 spike glycopreotein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_6VXX
</code></pre>


<h3>Format</h3>

<p><code>data_6VXX</code> consists of following informations:
</p>

<dl>
<dt><code>phi</code></dt><dd><p>main chain torsion angle for atoms C,N,CA,C.</p>
</dd>
<dt><code>psi</code></dt><dd><p>main chain torsion angle for atoms N,CA,C,N.</p>
</dd>
<dt><code>omega</code></dt><dd><p>main chain torsion angle for atoms CA,C,N,CA.</p>
</dd>
<dt><code>alpha</code></dt><dd><p>virtual torsion angle between consecutive C-alpha atoms.</p>
</dd>
<dt><code>chi1</code></dt><dd><p>side chain torsion angle for atoms N,CA,CB,*G.</p>
</dd>
<dt><code>chi2</code></dt><dd><p>side chain torsion angle for atoms CA,CB,*G,*D.</p>
</dd>
<dt><code>chi3</code></dt><dd><p>side chain torsion angle for atoms CB,*G,*D,*E.</p>
</dd>
<dt><code>chi4</code></dt><dd><p>side chain torsion angle for atoms *G,*D,*E,*Z.</p>
</dd>
<dt><code>chi5</code></dt><dd><p>side chain torsion angle for atoms *D,*E,*Z, NH1.</p>
</dd>
<dt><code>coords</code></dt><dd><p>numeric matrix of ‘justified’ coordinates.</p>
</dd>
<dt><code>tbl</code></dt><dd><p>a numeric matrix of psi, phi and chi torsion angles.</p>
</dd>
</dl>



<h3>Source</h3>

<p>This data can be downloaded in
<a href="https://www.rcsb.org/structure/6VXX">https://www.rcsb.org/structure/6VXX</a>, or with using R package
<code>bio3d</code>. Precisely, we use the code: <code>bio3d::torsion.pdb(bio3d::read.pdb("6vxx"))</code>
</p>


<h3>References</h3>

<p>Walls, A. C., Park, Y. J., Tortorici, M. A., Wall, A., McGuire, A. T., &amp; Veesler, D. (2020). Structure, function, and antigenicity of the SARS-CoV-2 spike glycoprotein. <em>Cell</em>, 181(2), 281-292.
Retrived from <a href="https://www.wwpdb.org/pdb?id=pdb_00006vxx">https://www.wwpdb.org/pdb?id=pdb_00006vxx</a>
</p>


<h3>See Also</h3>

<p>Description of the angluar information is from the 'value'
part of <code>torsion.pdb</code> in the package <code>bio3d</code>.
</p>

<hr>
<h2 id='ellip.kmeans.torus'>K-Means Clustering to K-Spheres Clustering on Torus</h2><span id='topic+ellip.kmeans.torus'></span>

<h3>Description</h3>

<p><code>ellip.kmeans.torus</code> prepares the parameters for conformity scores
which are derived by k-means clustering on torus.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ellip.kmeans.torus(
  data,
  centers = 10,
  type = c("homogeneous-circular", "heterogeneous-circular", "ellipsoids", "general"),
  init = c("kmeans", "hierarchical"),
  d = NULL,
  additional.condition = TRUE,
  THRESHOLD = 1e-10,
  maxiter = 200,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ellip.kmeans.torus_+3A_data">data</code></td>
<td>
<p>data n x d matrix of toroidal data on <code class="reqn">[0, 2\pi)^d</code></p>
</td></tr>
<tr><td><code id="ellip.kmeans.torus_+3A_centers">centers</code></td>
<td>
<p>either the number of clusters or a set of initial
cluster centers. If a number, a random set of row in x is
chosen as the initial centers.</p>
</td></tr>
<tr><td><code id="ellip.kmeans.torus_+3A_type">type</code></td>
<td>
<p>character which must be &quot;homogeneous-circular&quot;,
&quot;heterogeneous-circular&quot;, or &quot;general&quot;.
If &quot;homogeneous-circular&quot;, the radii of k-spheres are identical.
If &quot;heterogeneous-circular&quot;, the radii of k-spheres may be different.
If &quot;ellipsoids&quot;, cluster with k-ellipsoids without optimized parameters.
If, &quot;general&quot;, clustering with k-ellipsoids. The parameters to construct
the ellipses are optimized with elliptical k-means algorithm, which is
modified for toroidal space. See references for the detail.
Default is &quot;homogeneous-circular&quot;.</p>
</td></tr>
<tr><td><code id="ellip.kmeans.torus_+3A_init">init</code></td>
<td>
<p>determine the initial parameter for option &quot;general&quot;. Must be
&quot;kmeans&quot; or &quot;hierarchical&quot;.
If &quot;kmeans&quot;, the initial parameters are obtained with extrinsic kmeans
method.
If &quot;hierarchical&quot;, the initial parameters are obtained with hierarchical
clustering method. Default is &quot;hierarchical&quot;.</p>
</td></tr>
<tr><td><code id="ellip.kmeans.torus_+3A_d">d</code></td>
<td>
<p>pairwise distance matrix(<code>dist</code> object) for <code>init = "hierarchical"</code>,
which used in hierarchical clustering. If <code>init = "hierarchical"</code> and <code>d = NULL</code>,
<code>d</code> will be automatically filled with <code>ang.pdist(data)</code>.</p>
</td></tr>
<tr><td><code id="ellip.kmeans.torus_+3A_additional.condition">additional.condition</code></td>
<td>
<p>boolean index.
If <code>TRUE</code>, a singular matrix will be altered to the scalar identity.</p>
</td></tr>
<tr><td><code id="ellip.kmeans.torus_+3A_threshold">THRESHOLD</code></td>
<td>
<p>number of threshold for difference between updating and
updated parameters. Default is 1e-10.</p>
</td></tr>
<tr><td><code id="ellip.kmeans.torus_+3A_maxiter">maxiter</code></td>
<td>
<p>the maximal number of iteration. Default is 200.</p>
</td></tr>
<tr><td><code id="ellip.kmeans.torus_+3A_verbose">verbose</code></td>
<td>
<p>boolean index, which indicates whether display
additional details as to what the algorithm is doing or
how many loops are done. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="ellip.kmeans.torus_+3A_...">...</code></td>
<td>
<p>Further arguments for argument <code>init</code>. If <code>init = "kmeans"</code>,
these are for <code><a href="stats.html#topic+kmeans">kmeans</a></code>. If <code>init = "hierarchical"</code>,
there are for <code><a href="stats.html#topic+hclust">hclust</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list,
containing all values which determines the shape and
location of spheres.
</p>


<h3>References</h3>

<p>Jung, S., Park, K., &amp; Kim, B. (2021). Clustering on the torus by conformal prediction. <em>The Annals of Applied Statistics</em>, 15(4), 1583-1603.
</p>
<p>Mardia, K. V., Kent, J. T., Zhang, Z., Taylor, C. C., &amp; Hamelryck, T. (2012). Mixtures of concentrated multivariate sine distributions with applications to bioinformatics. <em>Journal of Applied Statistics</em>, 39(11), 2475-2492.
</p>
<p>Shin, J., Rinaldo, A., &amp; Wasserman, L. (2019). Predictive clustering. <em>arXiv preprint arXiv:1903.08125</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kmeans.torus">kmeans.torus</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- ILE[1:200, 1:2]

ellip.kmeans.torus(data, centers = 3, type = "general", init = "hierarchical")
</code></pre>

<hr>
<h2 id='EMsinvMmix'>Fitting mixtures of bivariate von Mises distribution</h2><span id='topic+EMsinvMmix'></span>

<h3>Description</h3>

<p><code>EMsinvMmix</code> returns fitted parameters of J-mixture of
bivariate sine von Mises distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EMsinvMmix(
  data,
  J = 4,
  parammat = EMsinvMmix.init(data, J),
  THRESHOLD = 1e-10,
  maxiter = 100,
  type = c("circular", "axis-aligned", "general"),
  kmax = 500,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EMsinvMmix_+3A_data">data</code></td>
<td>
<p>n x 2 matrix of toroidal data on <code class="reqn">[0, 2\pi)^2</code></p>
</td></tr>
<tr><td><code id="EMsinvMmix_+3A_j">J</code></td>
<td>
<p>number of components of mixture density</p>
</td></tr>
<tr><td><code id="EMsinvMmix_+3A_parammat">parammat</code></td>
<td>
<p>6 x J parameter data with the following components:
</p>
<p><code>parammat[1, ]</code> : the weights for each von Mises sine density
</p>
<p><code>parammat[n + 1, ]</code> : <code class="reqn">\kappa_n</code> for each von Mises
sine density for n = 1, 2, 3
</p>
<p><code>parammat[m + 4, ]</code> : <code class="reqn">\mu_m</code> for each von Mises
sine density for m = 1, 2</p>
</td></tr>
<tr><td><code id="EMsinvMmix_+3A_threshold">THRESHOLD</code></td>
<td>
<p>number of threshold for difference between updating and
updated parameters.</p>
</td></tr>
<tr><td><code id="EMsinvMmix_+3A_maxiter">maxiter</code></td>
<td>
<p>the maximal number of iteration.</p>
</td></tr>
<tr><td><code id="EMsinvMmix_+3A_type">type</code></td>
<td>
<p>a string one of &quot;circular&quot;, &quot;axis-aligned&quot;, &quot;general&quot;,
and &quot;Bayesian&quot; which determines the fitting method.</p>
</td></tr>
<tr><td><code id="EMsinvMmix_+3A_kmax">kmax</code></td>
<td>
<p>the maximal number of kappa. If estimated kappa is
larger than <code>kmax</code>, then put kappa as <code>kmax</code>.</p>
</td></tr>
<tr><td><code id="EMsinvMmix_+3A_verbose">verbose</code></td>
<td>
<p>boolean index, which indicates whether display
additional details as to what the algorithm is doing or
how many loops are done.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm is based on ECME algorithm. That is,
constructed with E - step and M - step and M - step
maximizes the parameters with given <code>type</code>.
</p>
<p>If <code>type == "circular"</code>, then the mixture density is
just a product of two independent von Mises.
</p>
<p>If <code>type == "axis-aligned"</code>, then the mixture density is
the special case of <code>type == "circular"</code>: only need to
take care of the common concentration parameter.
</p>
<p>If<code>type == "general"</code>, then the fitting the mixture
density is more complicated than before, check the detail of
the reference article.
</p>


<h3>Value</h3>

<p>returns approximated parameters for bivariate normal
distribution with <code>list</code>:
</p>
<p><code>list$Sigmainv[j]</code> : approximated covariance matrix for
j-th bivariate normal distribution, approximation of the j-th von Mises.
</p>
<p><code>list$c[j]</code> : approximated <code class="reqn">|2\pi\Sigma|^{-1}</code> for
j-th bivariate normal distribution, approximation of the j-th von Mises.
</p>


<h3>References</h3>

<p>Jung, S., Park, K., &amp; Kim, B. (2021). Clustering on the torus by conformal prediction. <em>The Annals of Applied Statistics</em>, 15(4), 1583-1603.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data &lt;- ILE[1:200, 1:2]

EMsinvMmix(data, J = 3,
           THRESHOLD = 1e-10, maxiter = 200,
           type = "general", kmax = 500, verbose = FALSE)

</code></pre>

<hr>
<h2 id='grid.torus'>Grid on torus</h2><span id='topic+grid.torus'></span>

<h3>Description</h3>

<p><code>grid.torus</code> returns an equally-spaced grid on torus.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.torus(d = 2, grid.size = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.torus_+3A_d">d</code></td>
<td>
<p>number for dimension. Default is 2.</p>
</td></tr>
<tr><td><code id="grid.torus_+3A_grid.size">grid.size</code></td>
<td>
<p>number of grid for each axis. Default value is 100.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns (grid.size) x (grid.size) numeric matrix
which indicates the grid points on torus.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grid.torus(d = 2, grid.size = 100)
</code></pre>

<hr>
<h2 id='hyperparam.alpha'>Selecting optimal level based on the runs of the number of clusters</h2><span id='topic+hyperparam.alpha'></span><span id='topic+plot.hyperparam.alpha'></span>

<h3>Description</h3>

<p><code>hyperparam.alpha</code> evaluates the numbers of clusters for various
levels, and select the optimal level based on the runs of the cluster numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hyperparam.alpha(icp.torus, alphavec = NULL, alpha.lim = 0.15)

## S3 method for class 'hyperparam.alpha'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hyperparam.alpha_+3A_icp.torus">icp.torus</code></td>
<td>
<p>an object containing all values to compute the conformity
score, which will be constructed with <code>icp.torus.score</code>.</p>
</td></tr>
<tr><td><code id="hyperparam.alpha_+3A_alphavec">alphavec</code></td>
<td>
<p>either a scalar or a vector, or even <code>NULL</code> for the levels.
Default value is <code>NULL</code>. If <code>NULL</code>, then <code>alphavec</code> is
automatically generated as a sequence from 0 to <code>alpha.lim</code>.</p>
</td></tr>
<tr><td><code id="hyperparam.alpha_+3A_alpha.lim">alpha.lim</code></td>
<td>
<p>a positive number lower than 1, which is the upper bound of
Default is 0.15.</p>
</td></tr>
<tr><td><code id="hyperparam.alpha_+3A_x">x</code></td>
<td>
<p><code>hyperparam.alpha</code> object</p>
</td></tr>
<tr><td><code id="hyperparam.alpha_+3A_...">...</code></td>
<td>
<p>additional parameter for ggplot2::ggplot()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a <code>hyperparam.alpha</code> object which contains a <code>data.frame</code> for
the numbers of clusters corresponding to the levels and the optimal level.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hyperparam.J">hyperparam.J</a></code>, <code><a href="#topic+hyperparam.torus">hyperparam.torus</a></code>
<code><a href="#topic+icp.torus">icp.torus</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data &lt;- toydata2[, 1:2]
n &lt;- nrow(data)
split.id &lt;- rep(2, n)
split.id[sample(n, floor(n/2))] &lt;- 1
icp.torus &lt;- icp.torus(data, split.id = split.id, model = "kmeans",
                       kmeansfitmethod = "ge", init = "h",
                       J = 25, verbose = TRUE)
hyperparam.alpha(icp.torus)

</code></pre>

<hr>
<h2 id='hyperparam.J'>Selecting optimal number of mixture components based on various criteria</h2><span id='topic+hyperparam.J'></span><span id='topic+plot.hyperparam.J'></span>

<h3>Description</h3>

<p><code>hyperparam.J</code> evaluates criterion for each <code>icp.torus</code> objects, and select
the optimal number of mixture components based on the evaluated criterion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hyperparam.J(icp.torus.objects, option = c("risk", "AIC", "BIC"))

## S3 method for class 'hyperparam.J'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hyperparam.J_+3A_icp.torus.objects">icp.torus.objects</code></td>
<td>
<p>a list whose elements are icp.torus objects, generated by
<code>icp.torus</code>.</p>
</td></tr>
<tr><td><code id="hyperparam.J_+3A_option">option</code></td>
<td>
<p>a string one of &quot;risk&quot;, &quot;AIC&quot;, or &quot;BIC&quot;, which determines the criterion
for the model selection. &quot;risk&quot; is based on the negative log-likelihood, &quot;AIC&quot; for the
Akaike Information Criterion, and &quot;BIC&quot; for the Bayesian Information Criterion.</p>
</td></tr>
<tr><td><code id="hyperparam.J_+3A_x">x</code></td>
<td>
<p><code>hyperparam.J</code> object</p>
</td></tr>
<tr><td><code id="hyperparam.J_+3A_...">...</code></td>
<td>
<p>additional parameter for ggplot2::ggplot()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a <code>hyperparam.J</code> object which contains a <code>data.frame</code> for
the evaluated criterion corresponding to each number of components, the optimal
number of components, and the corresponding <code>icp.torus</code> object.
</p>


<h3>References</h3>

<p>Jung, S., Park, K., &amp; Kim, B. (2021). Clustering on the torus by conformal prediction. <em>The Annals of Applied Statistics</em>, 15(4), 1583-1603.
</p>
<p>Akaike, H. (1974). A new look at the statistical model identification. <em>IEEE transactions on automatic control</em>, 19(6), 716-723.
</p>
<p>Schwarz, G. (1978). Estimating the dimension of a model. <em>The annals of statistics</em>, 461-464.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+icp.torus">icp.torus</a></code>, <code><a href="#topic+hyperparam.torus">hyperparam.torus</a></code>,
<code><a href="#topic+hyperparam.alpha">hyperparam.alpha</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data &lt;- toydata1[,1:2]
n &lt;- nrow(data)
split.id &lt;- rep(2,n)
split.id[ sample(n,floor(n/2)) ] &lt;- 1

Jvec = 4:20
icp.torus.objects &lt;- icp.torus(data, split.id = split.id, model = "kmeans", J = Jvec)

hyperparam.J(icp.torus.objects, option = "AIC")
</code></pre>

<hr>
<h2 id='hyperparam.torus'>Selecting optimal hyperparameters for the conformal prediction set</h2><span id='topic+hyperparam.torus'></span><span id='topic+plot.hyperparam.torus'></span>

<h3>Description</h3>

<p><code>hyperparam.torus</code> selects optimal hyperparameters for constructing the conformal prediction
set, based on the type of postulated model and the criterion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hyperparam.torus(
  icp.torus.objects,
  option = NULL,
  alphavec = NULL,
  alpha.lim = NULL,
  eval.point = NULL
)

## S3 method for class 'hyperparam.torus'
plot(x, color = "auto", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hyperparam.torus_+3A_icp.torus.objects">icp.torus.objects</code></td>
<td>
<p>list whose elements are icp.torus objects, generated by
<code>icp.torus</code></p>
</td></tr>
<tr><td><code id="hyperparam.torus_+3A_option">option</code></td>
<td>
<p>A string. One of &quot;elbow&quot;, &quot;risk&quot;, &quot;AIC&quot;, or &quot;BIC&quot;, which determines the
criterion for the model selection. &quot;risk&quot; is based on the negative log-likelihood, &quot;AIC&quot;
for the Akaike Information Criterion, and &quot;BIC&quot; for the Bayesian Information Criterion.
&quot;elbow&quot; is based on minimizing the criterion used in Jung et. al.(2021). Default is
<code>option = "elbow"</code> for 2-dimensional cases and <code>option = "risk"</code> for d(&gt;2)-dimensional cases.</p>
</td></tr>
<tr><td><code id="hyperparam.torus_+3A_alphavec">alphavec</code></td>
<td>
<p>either a scalar or a vector, or even <code>NULL</code> for the levels.
Default value is <code>NULL</code>. If <code>NULL</code>, then <code>alphavec</code> is
automatically generated as a sequence from 0 to <code>alpha.lim</code>.</p>
</td></tr>
<tr><td><code id="hyperparam.torus_+3A_alpha.lim">alpha.lim</code></td>
<td>
<p>a positive number lower than 1. Default value is <code>NULL</code>.
If <code>NULL</code>, then <code>alpha.vec</code> is is 0.5 for <code>option = "elbow"</code>, and
0.15 for options c(&quot;risk&quot;, &quot;AIC&quot;, or &quot;BIC&quot;).</p>
</td></tr>
<tr><td><code id="hyperparam.torus_+3A_eval.point">eval.point</code></td>
<td>
<p>N x N numeric matrix on <code class="reqn">[0, 2\pi)^2</code>.
Default input is <code>grid.torus</code>.</p>
</td></tr>
<tr><td><code id="hyperparam.torus_+3A_x">x</code></td>
<td>
<p><code>hyperparam.torus</code> object</p>
</td></tr>
<tr><td><code id="hyperparam.torus_+3A_color">color</code></td>
<td>
<p>A string for plotting <code>hyperparam.torus</code> object, whose criterion option is <code>option = "elbow"</code>.
One of &quot;auto&quot;, &quot;sequential&quot;, or &quot;qualitative&quot;. If <code>color = "auto"</code>,
color assignment will be done automatically based on the number of J or concentration.
If <code>color = "sequential"</code>, color assignment will be done by regarding each J or concentration as quantitative variable.
If <code>color = "qualitative"</code>, color assignment will be done by regarding each J or concentration as qualitative variable.
Default is <code>color = "auto"</code>.</p>
</td></tr>
<tr><td><code id="hyperparam.torus_+3A_...">...</code></td>
<td>
<p>additional parameter for ggplot2::ggplot()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list object which contains <code>data.frame</code> objects for
the evaluated criterion corresponding to each hyperparameter,
selected hyperparameters based on the designated criterion, and
an <code>icp.torus</code> object based the selected hyperparameters.
</p>


<h3>References</h3>

<p>Jung, S., Park, K., &amp; Kim, B. (2021). Clustering on the torus by conformal prediction. <em>The Annals of Applied Statistics</em>, 15(4), 1583-1603.
</p>
<p>Akaike, H. (1974). A new look at the statistical model identification. <em>IEEE transactions on automatic control</em>, 19(6), 716-723.
</p>
<p>Schwarz, G. (1978). Estimating the dimension of a model. <em>The annals of statistics</em>, 461-464.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data &lt;- toydata2[, 1:2]
n &lt;- nrow(data)
split.id &lt;- rep(2, n)
split.id[sample(n, floor(n/2))] &lt;- 1
Jvec &lt;- 3:35
icp.torus.objects &lt;- icp.torus(data, split.id = split.id, model = "kmeans",
                                      kmeansfitmethod = "ge", init = "h",
                                      J = Jvec, verbose = TRUE)
hyperparam.torus(icp.torus.objects, option = "risk")

</code></pre>

<hr>
<h2 id='icp.torus'>Conformity score for inductive prediction sets</h2><span id='topic+icp.torus'></span><span id='topic+logLik.icp.torus'></span><span id='topic+predict.icp.torus'></span><span id='topic+plot.icp.torus'></span>

<h3>Description</h3>

<p><code>icp.torus</code> prepares all values
for computing the conformity score for specified methods.
</p>
<p><code>plot.icp.torus</code> plots <code>icp.torus</code> object with some options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>icp.torus(
  data,
  split.id = NULL,
  model = c("kmeans", "kde", "mixture"),
  mixturefitmethod = c("axis-aligned", "circular", "general"),
  kmeansfitmethod = c("general", "homogeneous-circular", "heterogeneous-circular",
    "ellipsoids"),
  init = c("hierarchical", "kmeans"),
  d = NULL,
  additional.condition = TRUE,
  J = 4,
  concentration = 25,
  kmax = 500,
  THRESHOLD = 1e-10,
  maxiter = 200,
  verbose = TRUE,
  ...
)

## S3 method for class 'icp.torus'
logLik(object, ...)

## S3 method for class 'icp.torus'
predict(object, newdata, ...)

## S3 method for class 'icp.torus'
plot(
  x,
  data = NULL,
  level = 0.1,
  ellipse = TRUE,
  out = FALSE,
  type = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="icp.torus_+3A_data">data</code></td>
<td>
<p>n x d matrix of toroidal data on <code class="reqn">[0, 2\pi)^d</code>
or <code class="reqn">[-\pi, \pi)^d</code>. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="icp.torus_+3A_split.id">split.id</code></td>
<td>
<p>a n-dimensional vector consisting of values 1 (estimation)
and 2(evaluation)</p>
</td></tr>
<tr><td><code id="icp.torus_+3A_model">model</code></td>
<td>
<p>A string. One of &quot;kde&quot;, &quot;mixture&quot;, and &quot;kmeans&quot; which
determines the model or estimation methods. If &quot;kde&quot;, the model is based
on the kernel density estimates. It supports the kde-based conformity score
only. If &quot;mixture&quot;, the model is based on the von Mises mixture, fitted
with an EM algorithm. It supports the von Mises mixture and its variants
based conformity scores. If &quot;kmeans&quot;, the model is also based on the von
Mises mixture, but the parameter estimation is implemented with the
elliptical k-means algorithm illustrated in Appendix. It supports the
log-max-mixture based conformity score only. If the
dimension of data space is greater than 2, only &quot;kmeans&quot; is supported.
Default is <code>model = "kmeans"</code>.</p>
</td></tr>
<tr><td><code id="icp.torus_+3A_mixturefitmethod">mixturefitmethod</code></td>
<td>
<p>A string. One of &quot;circular&quot;, &quot;axis-aligned&quot;, and
&quot;general&quot; which determines the constraint of the EM fitting. Default is
&quot;axis-aligned&quot;. This argument only works for <code>model = "mixture"</code>.</p>
</td></tr>
<tr><td><code id="icp.torus_+3A_kmeansfitmethod">kmeansfitmethod</code></td>
<td>
<p>A string. One of &quot;general&quot;, ellipsoids&quot;,
&quot;heterogeneous-circular&quot; or &quot;homogeneous-circular&quot;. If &quot;general&quot;, the
elliptical k-means algorithm with no constraint is used. If &quot;ellipsoids&quot;,
only the one iteration of the algorithm is used. If&quot;heterogeneous-circular&quot;,
the same as above, but with the constraint that ellipsoids must be spheres.
If &quot;homogeneous-circular&quot;, the same as above but the radii of the spheres are
identical. Default is &quot;general&quot;. This argument only works for <code>model = "kmeans"</code>.</p>
</td></tr>
<tr><td><code id="icp.torus_+3A_init">init</code></td>
<td>
<p>Methods for choosing initial values of &quot;kmeans&quot; fitting.
Must be &quot;hierarchical&quot; or &quot;kmeans&quot;. If &quot;hierarchical&quot;, the initial
parameters are obtained with hierarchical clustering method.
If &quot;kmeans&quot;, the initial parameters are obtained with extrinsic k-means method.
Additional arguments for k-means clustering and hierarchical clustering can be designated
via argument <code>...</code>. If no options are designated, <code>nstart=1</code> for <code>init="kmeans"</code>
and <code>method="complete"</code> for <code>init="hierarchical"</code> are used. Default is &quot;hierarchical&quot;.</p>
</td></tr>
<tr><td><code id="icp.torus_+3A_d">d</code></td>
<td>
<p>pairwise distance matrix(<code>dist</code> object) for <code>init = "hierarchical"</code>,
which used in hierarchical clustering. If <code>init = "hierarchical"</code> and <code>d = NULL</code>,
<code>d</code> will be automatically filled with <code>ang.pdist(data)</code>.</p>
</td></tr>
<tr><td><code id="icp.torus_+3A_additional.condition">additional.condition</code></td>
<td>
<p>boolean index.
If <code>TRUE</code>, a singular matrix will be altered to the scaled identity.</p>
</td></tr>
<tr><td><code id="icp.torus_+3A_j">J</code></td>
<td>
<p>A scalar or numeric vector for the number(s) of components for <code>model = c("mixture", "kmeans")</code>.
Default is <code>J = 4</code>.</p>
</td></tr>
<tr><td><code id="icp.torus_+3A_concentration">concentration</code></td>
<td>
<p>A scalar or numeric vector for the concentration parameter(s) for <code>model = "kde"</code>.
Default is <code>concentration = 25</code>.</p>
</td></tr>
<tr><td><code id="icp.torus_+3A_kmax">kmax</code></td>
<td>
<p>the maximal number of kappa. If estimated kappa is
larger than <code>kmax</code>, then put kappa as <code>kmax</code>.</p>
</td></tr>
<tr><td><code id="icp.torus_+3A_threshold">THRESHOLD</code></td>
<td>
<p>number for difference between updating and
updated parameters. Default is 1e-10.</p>
</td></tr>
<tr><td><code id="icp.torus_+3A_maxiter">maxiter</code></td>
<td>
<p>the maximal number of iteration. Default is 200.</p>
</td></tr>
<tr><td><code id="icp.torus_+3A_verbose">verbose</code></td>
<td>
<p>boolean index, which indicates whether display
additional details as to what the algorithm is doing or
how many loops are done. Moreover, if <code>additional.condition</code> is
<code>TRUE</code>, the warning message will be reported.</p>
</td></tr>
<tr><td><code id="icp.torus_+3A_...">...</code></td>
<td>
<p>additional parameters. For plotting icp.torus, these parameters are for ggplot2::ggplot().</p>
</td></tr>
<tr><td><code id="icp.torus_+3A_object">object</code></td>
<td>
<p><code>icp.torus</code> object</p>
</td></tr>
<tr><td><code id="icp.torus_+3A_newdata">newdata</code></td>
<td>
<p>n x d matrix of toroidal data on <code class="reqn">[0, 2\pi)^d</code>.
Dimension d must be the same as data used for <code>icp.torus</code> object.</p>
</td></tr>
<tr><td><code id="icp.torus_+3A_x">x</code></td>
<td>
<p><code>icp.torus</code> object</p>
</td></tr>
<tr><td><code id="icp.torus_+3A_level">level</code></td>
<td>
<p>either a numeric scalar or a vector in <code class="reqn">[0,1]</code>. Default value is 0.1.</p>
</td></tr>
<tr><td><code id="icp.torus_+3A_ellipse">ellipse</code></td>
<td>
<p>A boolean index which determines whether plotting ellipses from
mixture models. Default is <code>TRUE</code>. (This option is used only when the
<code>icp.torus</code> object <code>x</code> is fitted by model <code>kmeans</code> or <code>mixture</code>.)</p>
</td></tr>
<tr><td><code id="icp.torus_+3A_out">out</code></td>
<td>
<p>An option for returning the ggplot object. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="icp.torus_+3A_type">type</code></td>
<td>
<p>A string. One of &quot;mix&quot;, &quot;max&quot; or &quot;e&quot;. This argument is only available if <code>icp.torus</code>
object is fitted with <code>model = "mixture"</code>. Default is <code>NULL</code>. If <code>type != NULL</code>, argument
<code>ellipse</code> automatically becomes <code>FALSE</code>. If &quot;mix&quot;, it plots based on von Mises mixture.
If &quot;max&quot;, it plots based on von Mises max-mixture. If &quot;e&quot;, it plots based on ellipse-approximation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>icp.torus</code> returns an <code>icp.torus</code> object, containing all values
to compute the conformity score (if <code>J</code> or <code>concentration</code> is a
single value). if <code>J</code> or <code>concentration</code> is a vector containing
multiple values, then <code>icp.torus</code> returns a list of <code>icp.torus</code> objects
</p>


<h3>References</h3>

<p>Jung, S., Park, K., &amp; Kim, B. (2021). Clustering on the torus by conformal prediction. <em>The Annals of Applied Statistics</em>, 15(4), 1583-1603.
</p>
<p>Mardia, K. V., Kent, J. T., Zhang, Z., Taylor, C. C., &amp; Hamelryck, T. (2012). Mixtures of concentrated multivariate sine distributions with applications to bioinformatics. <em>Journal of Applied Statistics</em>, 39(11), 2475-2492.
</p>
<p>Di Marzio, M., Panzera, A., &amp; Taylor, C. C. (2011). Kernel density estimation on the torus. <em>Journal of Statistical Planning and Inference</em>, 141(6), 2156-2173.
</p>
<p>Shin, J., Rinaldo, A., &amp; Wasserman, L. (2019). Predictive clustering. <em>arXiv preprint arXiv:1903.08125</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data &lt;- toydata1[, 1:2]

icp.torus &lt;- icp.torus(data, model = "kmeans",
                       kmeansfitmethod = "general",
                       J = 4, concentration = 25)

</code></pre>

<hr>
<h2 id='icp.torus.eval'>Inductive prediction sets for each level</h2><span id='topic+icp.torus.eval'></span>

<h3>Description</h3>

<p><code>icp.torus.eval</code> evaluates whether each pre-specified evaluation point
is contained in the inductive conformal prediction sets for each given
level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>icp.torus.eval(icp.torus, level = 0.1, eval.point = grid.torus())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="icp.torus.eval_+3A_icp.torus">icp.torus</code></td>
<td>
<p>an object containing all values to compute the conformity
score, which will be constructed with <code>icp.torus</code>.</p>
</td></tr>
<tr><td><code id="icp.torus.eval_+3A_level">level</code></td>
<td>
<p>either a scalar or a vector, or even <code>NULL</code>. Default value
is 0.1.</p>
</td></tr>
<tr><td><code id="icp.torus.eval_+3A_eval.point">eval.point</code></td>
<td>
<p>N x N numeric matrix on <code class="reqn">[0, 2\pi)^2</code>. Default input is
<code>grid.torus</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a <code>cp</code> object with the boolean values which
indicate whether each evaluation point is contained in the inductive
conformal prediction sets for each given level.
</p>


<h3>References</h3>

<p>Jung, S., Park, K., &amp; Kim, B. (2021). Clustering on the torus by conformal prediction. <em>The Annals of Applied Statistics</em>, 15(4), 1583-1603.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grid.torus">grid.torus</a></code>, <code><a href="#topic+icp.torus">icp.torus</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data &lt;- toydata1[, 1:2]

icp.torus &lt;- icp.torus(data, model = "kmeans",
                       mixturefitmethod = "general",
                       J = 4, concentration = 25)

icp.torus.eval(icp.torus, level = c(0.1, 0.08), eval.point = grid.torus())

</code></pre>

<hr>
<h2 id='ILE'>ILE: Structure of the Isoleucine</h2><span id='topic+ILE'></span>

<h3>Description</h3>

<p>An isomer of leucine, essential branched-chain aliphatic amino acid found in many proteins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ILE
</code></pre>


<h3>Format</h3>

<p>This list contains the following components:
</p>

<dl>
<dt><code>phi</code></dt><dd><p>main chain torsion angle for atoms C,N,CA,C.</p>
</dd>
<dt><code>psi</code></dt><dd><p>main chain torsion angle for atoms N,CA,C,N.</p>
</dd>
<dt><code>chi1</code></dt><dd><p>side chain torsion angle for atoms N,CA,CB,*G.</p>
</dd>
<dt><code>chi2</code></dt><dd><p>side chain torsion angle for atoms CA,CB,*G,*D.</p>
</dd>
</dl>



<h3>Details</h3>

<p>ILE data is generated with collection of different pdb files. To select adequate protein
data, we use PISCES server. (the method is introduced in articles of references.)
To select high-quality protein data, we use several benchmarks:
resolution : 1.6A(angstrom) or better,
R-factor : 0.22 or better,
Sequence percentage identity: &lt;= 25
Then, we select ILE only angular data for each protein data. To see the detail code, visit
<a href="https://github.com/sungkyujung/ClusTorus">https://github.com/sungkyujung/ClusTorus</a>
</p>


<h3>Source</h3>

<p>This data is extracted from PISCES server <a href="http://dunbrack.fccc.edu/pisces/">http://dunbrack.fccc.edu/pisces/</a>
</p>


<h3>References</h3>

<p>Data description is from <a href="https://www.rcsb.org/ligand/ILE">https://www.rcsb.org/ligand/ILE</a>.
</p>
<p>The data extracting method is from Harder, T., Boomsma, W., Paluszewski, M., Frellsen, J., Johansson, K. E., &amp; Hamelryck, T. (2010). Beyond rotamers: a generative, probabilistic model of side chains in proteins. <em>BMC bioinformatics</em>, 11(1), 1-13.
</p>
<p>Mardia, K. V., Kent, J. T., Zhang, Z., Taylor, C. C., &amp; Hamelryck, T. (2012). Mixtures of concentrated multivariate sine distributions with applications to bioinformatics. <em>Journal of Applied Statistics</em>, 39(11), 2475-2492.
</p>


<h3>See Also</h3>

<p>Description of the angluar information is from the 'value'
part of <code>torsion.pdb</code> in the package <code>bio3d</code>.
</p>

<hr>
<h2 id='kde.torus'>Kernel density estimation using circular von Mises distribution</h2><span id='topic+kde.torus'></span>

<h3>Description</h3>

<p><code>kde.torus</code> returns a kde using independent multivariate von mises kernel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kde.torus(data, eval.point = NULL, concentration = 25)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kde.torus_+3A_data">data</code></td>
<td>
<p>n x d matrix of toroidal data on <code class="reqn">[0, 2\pi)^d</code></p>
</td></tr>
<tr><td><code id="kde.torus_+3A_eval.point">eval.point</code></td>
<td>
<p>N x N numeric matrix on <code class="reqn">[0, 2\pi)^d</code>. Default input is
<code>NULL</code>, which represents the fine grid points on <code class="reqn">[0, 2\pi)^d</code>.</p>
</td></tr>
<tr><td><code id="kde.torus_+3A_concentration">concentration</code></td>
<td>
<p>positive number which has the role of <code class="reqn">\kappa</code> of
von Mises distribution. Default value is 25.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>kde.torus</code> returns N-dimensional vector of kdes evaluated at eval.point
</p>


<h3>References</h3>

<p>Jung, S., Park, K., &amp; Kim, B. (2021). Clustering on the torus by conformal prediction. <em>The Annals of Applied Statistics</em>, 15(4), 1583-1603.
</p>
<p>Di Marzio, M., Panzera, A., &amp; Taylor, C. C. (2011). Kernel density estimation on the torus. <em>Journal of Statistical Planning and Inference</em>, 141(6), 2156-2173.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grid.torus">grid.torus</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- ILE[1:200, 1:2]

kde.torus(data)
</code></pre>

<hr>
<h2 id='kmeans.torus'>K-Means Clustering on Torus</h2><span id='topic+kmeans.torus'></span><span id='topic+predict.kmeans.torus'></span>

<h3>Description</h3>

<p><code>kmeans.torus</code> implements extrinsic k-means clustering
on toroidal space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kmeans.torus(data, centers = 10, ...)

## S3 method for class 'kmeans.torus'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kmeans.torus_+3A_data">data</code></td>
<td>
<p>n x d matrix of toroidal data on <code class="reqn">[0, 2\pi)^d</code></p>
</td></tr>
<tr><td><code id="kmeans.torus_+3A_centers">centers</code></td>
<td>
<p>either the number of clusters or a set of initial
cluster centers. If a number, a random set of row in x is
chosen as the initial centers.</p>
</td></tr>
<tr><td><code id="kmeans.torus_+3A_...">...</code></td>
<td>
<p>additional parameter</p>
</td></tr>
<tr><td><code id="kmeans.torus_+3A_object">object</code></td>
<td>
<p><code>kmeans.torus</code> object</p>
</td></tr>
<tr><td><code id="kmeans.torus_+3A_newdata">newdata</code></td>
<td>
<p>n x d matrix of toroidal data on <code class="reqn">[0, 2\pi)^d</code>.
Dimension d must be the same as data used for <code>kmeans.torus</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In Euclidean space, we know that the total sum of squares
is equal to the summation of the within cluster sum of squares and
the between cluster centers sum of squares. However, toroidal space
does not satisfy the property; the equality does not hold. Thus,
you need to be careful to use the sum of squares.
</p>
<p>Extrinsic k-means algorithm uses the ambient space for <code class="reqn">[0, 2\pi)^d</code>.
Each datum is transformed to a vector in 2d-dimensional
Euclidean space, whose elements are sine and cosine values of the datum,
then a usual k-means algorithm is applied to transformed data.
</p>


<h3>Value</h3>

<p>returns a <code>kmeans</code> object, which contains
</p>

<dl>
<dt><code>extrinsic.results</code></dt><dd><p>extrinsic k-means clustering results using ordinary kmeans algorithm.</p>
</dd>
<dt><code>centers</code></dt><dd><p>A matrix of cluster centers.</p>
</dd>
<dt><code>membership</code></dt><dd><p>A vector of integers indicating the cluster to which each point is allocated.</p>
</dd>
<dt><code>size</code></dt><dd><p>The number of points in each cluster.</p>
</dd>
<dt><code>withinss</code></dt><dd><p>Vector of within-cluster sum of squares, one component per cluster.</p>
</dd>
<dt><code>totss</code></dt><dd><p>The total sum of squares, based on angular distance.</p>
</dd>
<dt><code>betweenss</code></dt><dd><p>The between-cluster sum of squares.</p>
</dd>
</dl>



<h3>References</h3>

<p>Jung, S., Park, K., &amp; Kim, B. (2021). Clustering on the torus by conformal prediction. <em>The Annals of Applied Statistics</em>, 15(4), 1583-1603.
</p>
<p>Gao, Y., Wang, S., Deng, M., &amp; Xu, J. (2018). RaptorX-Angle: real-value prediction of protein backbone dihedral angles through a hybrid method of clustering and deep learning. <em>BMC bioinformatics</em>, 19(4), 73-84.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+kmeans">kmeans</a></code>, <code><a href="#topic+ang.minus">ang.minus</a></code>, <code><a href="#topic+ang.dist">ang.dist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- ILE[1:200, 1:2]

kmeans.torus(data, centers = 2,
             iter.max = 100, nstart = 1)
</code></pre>

<hr>
<h2 id='on.torus'>Transform the angular data to be on principal interval</h2><span id='topic+on.torus'></span>

<h3>Description</h3>

<p><code>on.torus</code> transforms d-dimensional angular data
to be on <code class="reqn">[0, 2\pi)^d</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>on.torus(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="on.torus_+3A_x">x</code></td>
<td>
<p>d-dimensional angular data(vector or matrix) whose unit is the radian.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>d-dimensional radian-unit angular data on <code class="reqn">[0, 2\pi)^d</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- SARS_CoV_2 * pi / 180

on.torus(data)
</code></pre>

<hr>
<h2 id='SARS_CoV_2'>SARS-CoV-2: chain B of Structure of the SARS-CoV-2 spike glycoprotein(closed state)</h2><span id='topic+SARS_CoV_2'></span>

<h3>Description</h3>

<p>The torsion angle dataset of the chain B of SARS-CoV-2 spike glycopreotein. This data is originally
from first two main torsion angles of <code>data_6VXX</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SARS_CoV_2
</code></pre>


<h3>Format</h3>

<p>This data.frame contains the following columns:
</p>

<dl>
<dt><code>phi</code></dt><dd><p>main chain torsion angle for atoms C,N,CA,C.</p>
</dd>
<dt><code>psi</code></dt><dd><p>main chain torsion angle for atoms N,CA,C,N.</p>
</dd>
</dl>



<h3>Details</h3>

<p>This data is obtained with following codes:
</p>


<h3>Source</h3>

<p>This data can be downloaded in
<a href="https://www.rcsb.org/structure/6VXX">https://www.rcsb.org/structure/6VXX</a>, or with using R package
<code>bio3d</code>. To see the precise extracting code, visit <a href="https://github.com/sungkyujung/ClusTorus/tree/master/data-raw">https://github.com/sungkyujung/ClusTorus/tree/master/data-raw</a>
</p>


<h3>References</h3>

<p>Walls, A. C., Park, Y. J., Tortorici, M. A., Wall, A., McGuire, A. T., &amp; Veesler, D. (2020). Structure, function, and antigenicity of the SARS-CoV-2 spike glycoprotein. <em>Cell</em>, 181(2), 281-292.
Retrived from <a href="https://www.wwpdb.org/pdb?id=pdb_00006vxx">https://www.wwpdb.org/pdb?id=pdb_00006vxx</a>
</p>


<h3>See Also</h3>

<p>Description of the angluar information is from the 'value'
part of <code>torsion.pdb</code> in the package <code>bio3d</code>.
</p>

<hr>
<h2 id='tor.minus'>Toroidal subtraction</h2><span id='topic+tor.minus'></span>

<h3>Description</h3>

<p><code>tor.minus</code> computes angular subtraction bewtween n x d toroidal data and
a d dimensional vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tor.minus(data, mu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tor.minus_+3A_data">data</code></td>
<td>
<p>n x d matrix of toroidal data</p>
</td></tr>
<tr><td><code id="tor.minus_+3A_mu">mu</code></td>
<td>
<p>a d-dimensinal vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>angular subtraction bewtween n x d toroidal data and
a d dimensional vector.
</p>


<h3>References</h3>

<p>Jung, S., Park, K., &amp; Kim, B. (2021). Clustering on the torus by conformal prediction. <em>The Annals of Applied Statistics</em>, 15(4), 1583-1603.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ang.minus">ang.minus</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- ILE[1:200, 1:2]
Mu1 &lt;- c(4.5, 3)
tor.minus(data, Mu1)
</code></pre>

<hr>
<h2 id='toydata1'>toydata1: Labelled Data for 5 Clusters</h2><span id='topic+toydata1'></span>

<h3>Description</h3>

<p>Artificially generated data on the 2 dimensional torus
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toydata1
</code></pre>


<h3>Format</h3>

<p>This <code>data.frame</code> contains the following components:
</p>

<dl>
<dt><code>phi</code></dt><dd><p>column for the first angle</p>
</dd>
<dt><code>psi</code></dt><dd><p>column for the second angle</p>
</dd>
<dt><code>label</code></dt><dd><p>column for the clustering membership</p>
</dd>
</dl>



<h3>Details</h3>

<p>toydata1 is an artificial data generated from a mixture of 5 clusters,
where three clusters are sampled from bivariate normal distributions
and the other two are each sampled from the uniform distribution on a rectangle.
</p>


<h3>References</h3>

<p>Jung, S., Park, K., &amp; Kim, B. (2021). Clustering on the torus by conformal prediction. <em>The Annals of Applied Statistics</em>, 15(4), 1583-1603.
</p>

<hr>
<h2 id='toydata2'>toydata2: Labelled Data for 3 Clusters</h2><span id='topic+toydata2'></span>

<h3>Description</h3>

<p>Artificially generated data on the 2 dimensional torus
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toydata2
</code></pre>


<h3>Format</h3>

<p>This <code>data.frame</code> contains the following components:
</p>

<dl>
<dt><code>phi</code></dt><dd><p>column for the first angle</p>
</dd>
<dt><code>psi</code></dt><dd><p>column for the second angle</p>
</dd>
<dt><code>label</code></dt><dd><p>column for the clustering membership</p>
</dd>
</dl>



<h3>Details</h3>

<p>toydata2 is an artificial data generated from a mixture of 3 clusters,
where the first cluster is sampled from a spherical normal distribution,
the second cluster is from the uniform distribution on a large “L”-shaped region,
and the third cluster of size 50 is sampled from the uniform distribution on the
entire 2-dimensional torus.
</p>


<h3>References</h3>

<p>Jung, S., Park, K., &amp; Kim, B. (2021). Clustering on the torus by conformal prediction. <em>The Annals of Applied Statistics</em>, 15(4), 1583-1603.
</p>

<hr>
<h2 id='wtd.stat.ang'>Weighted extrinsic mean direction and mean resultant length</h2><span id='topic+wtd.stat.ang'></span>

<h3>Description</h3>

<p><code>wtd.stat.ang</code> computes weighted extrinsic mean direction and
mean resultant length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wtd.stat.ang(data, w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wtd.stat.ang_+3A_data">data</code></td>
<td>
<p>angular data whose elements are in <code class="reqn">[0, 2\pi)</code></p>
</td></tr>
<tr><td><code id="wtd.stat.ang_+3A_w">w</code></td>
<td>
<p>numeric vector whose each element is non-negative and
<code>sum(w) == 1</code>. Moreover, the length of <code>w</code> is the same with
<code>nrow(data)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list which is consisting of the following components:
</p>
<p><code>Mean</code> weighted extrinsic mean direction
</p>
<p><code>R</code> mean resultant length
</p>


<h3>References</h3>

<p>Jung, S., Park, K., &amp; Kim, B. (2021). Clustering on the torus by conformal prediction. <em>The Annals of Applied Statistics</em>, 15(4), 1583-1603.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- matrix(c(pi/3, pi/3, pi/2,
                 pi, pi/4, pi/2,
                 0, pi/3, pi/6),
               ncol = 3, byrow = TRUE)
w &lt;- c(0.3, 0.3, 0.4)
wtd.stat.ang(data, w)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
