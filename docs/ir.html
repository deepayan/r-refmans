<!DOCTYPE html><html><head><title>Help for package ir</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ir}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ir-package'><p>ir: Functions to Handle and Preprocess Infrared Spectra</p></a></li>
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#arrange.ir'><p>Arrange rows in <code>ir</code> objects by column values</p></a></li>
<li><a href='#bind'><p>Bind rows of <code>ir</code> objects</p></a></li>
<li><a href='#distinct.ir'><p>Subset distinct/unique rows in <code>ir</code> objects</p></a></li>
<li><a href='#extract.ir'><p>Extract a character column in an <code>ir</code> object into multiple columns using regular expression groups</p></a></li>
<li><a href='#filter-joins'><p>Filtering joins for an <code>ir</code> object</p></a></li>
<li><a href='#filter.ir'><p>Subset rows in <code>ir</code> objects using column values</p></a></li>
<li><a href='#group_by'><p>Group rows in <code>ir</code> objects by one or more variables</p></a></li>
<li><a href='#ir_add'><p>Add infrared spectra</p></a></li>
<li><a href='#ir_as_ir'><p>Generic to convert objects to class <code>ir</code></p></a></li>
<li><a href='#ir_average'><p>Averages infrared spectra within groups</p></a></li>
<li><a href='#ir_bc'><p>Performs baseline correction on infrared spectra</p></a></li>
<li><a href='#ir_bc_polynomial'><p>Performs baseline correction on infrared spectra using a polynomial</p></a></li>
<li><a href='#ir_bc_rubberband'><p>Performs baseline correction on infrared spectra using a rubberband algorithm</p></a></li>
<li><a href='#ir_bc_sg'><p>Performs baseline correction on infrared spectra using a Savitzky-Golay baseline</p></a></li>
<li><a href='#ir_bin'><p>Bins infrared spectra</p></a></li>
<li><a href='#ir_clip'><p>Clips infrared spectra to new wavenumber ranges</p></a></li>
<li><a href='#ir_divide'><p>Divide infrared spectra or divide infrared spectra by a numeric value</p></a></li>
<li><a href='#ir_drop_spectra'><p>Drops the column <code>spectra</code> from an object is of class <code>ir</code></p></a></li>
<li><a href='#ir_flat_clean'><p>Cleans objects of class <code>ir_flat</code></p></a></li>
<li><a href='#ir_flatten'><p>Converts objects of class <code>ir</code> to objects of class <code>ir_flat</code></p></a></li>
<li><a href='#ir_get_intensity'><p>Extracts intensities from spectra in an <code>ir</code> object for specific spectral channels</p></a></li>
<li><a href='#ir_get_spectrum'><p>Extracts selected spectra from an object of class <code>ir</code></p></a></li>
<li><a href='#ir_get_wavenumberindex'><p>Gets the index of a defined wavenumber value for a spectrum</p></a></li>
<li><a href='#ir_import_csv'><p>Imports infrared spectra from various files</p></a></li>
<li><a href='#ir_import_spc'><p>Imports infrared spectra from Thermo Galactic's files</p></a></li>
<li><a href='#ir_interpolate'><p>Interpolates intensity values of infrared spectra in an <code>ir</code> object for new wavenumber values</p></a></li>
<li><a href='#ir_interpolate_region'><p>Interpolates selected regions in infrared spectra in an <code>ir</code> object</p></a></li>
<li><a href='#ir_multiply'><p>Multiply infrared spectra or multiply infrared spectra with a numeric value</p></a></li>
<li><a href='#ir_new_ir'><p>Creates an object of class <code>ir</code></p></a></li>
<li><a href='#ir_new_ir_flat'><p>Creates an object of class <code>ir_flat</code></p></a></li>
<li><a href='#ir_normalize'><p>Normalizes infrared spectra in an <code>ir</code> object</p></a></li>
<li><a href='#ir_remove_missing'><p>Removes empty data values in an object of class <code>ir</code></p></a></li>
<li><a href='#ir_sample_data'><p>Sample object of class <code>ir</code></p></a></li>
<li><a href='#ir_smooth'><p>Smooths infrared spectra in an <code>ir</code> object</p></a></li>
<li><a href='#ir_stack'><p>Stacks a matrix or data frame with spectra into a list column</p></a></li>
<li><a href='#ir_subtract'><p>Subtract infrared spectra</p></a></li>
<li><a href='#ir_to_transmittance'><p>Converts absorbance spectra to transmittance spectra or vice versa</p></a></li>
<li><a href='#ir_variance_region'><p>Computes the variance of a spectrum in an <code>ir</code> object in a given region</p></a></li>
<li><a href='#mutate'><p>Mutate an <code>ir</code> object by adding new or replacing existing columns</p></a></li>
<li><a href='#mutate-joins'><p>Mutating joins for an <code>ir</code> object</p></a></li>
<li><a href='#nest'><p>Nest and un-nest an <code>ir</code> object</p></a></li>
<li><a href='#Ops.ir'><p>Arithmetic operations for <code>ir</code> objects</p></a></li>
<li><a href='#pivot_longer.ir'><p>Pivot an <code>ir</code> object from wide to long</p></a></li>
<li><a href='#pivot_wider.ir'><p>Pivot an <code>ir</code> object from wide to long</p></a></li>
<li><a href='#plot.ir'><p>Plots an object of class <code>ir</code></p></a></li>
<li><a href='#range'><p>Get the minima/maxima/range/median of x axis values or intensity values of infrared spectra</p></a></li>
<li><a href='#rename'><p>Rename columns in <code>ir</code> objects</p></a></li>
<li><a href='#rep.ir'><p>Replicate ir objects</p></a></li>
<li><a href='#rowwise.ir'><p>Group input <code>ir</code> objects by rows</p></a></li>
<li><a href='#select.ir'><p>Subset columns in <code>ir</code> objects using column names and types</p></a></li>
<li><a href='#separate_rows.ir'><p>Separate a collapsed column in an <code>ir</code> object into multiple rows</p></a></li>
<li><a href='#separate.ir'><p>Separate a character column in an <code>ir</code> object into multiple columns with a regular expression or numeric locations</p></a></li>
<li><a href='#slice'><p>Subset rows in <code>ir</code> objects using their positions</p></a></li>
<li><a href='#subsetting'><p>Subsetting <code>ir</code> objects</p></a></li>
<li><a href='#summarize'><p>Summarize each group in a <code>ir</code> object to fewer rows</p></a></li>
<li><a href='#unite.ir'><p>Unite multiple columns in an <code>ir</code> object into one by pasting strings together</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Functions to Handle and Preprocess Infrared Spectra</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.1</td>
</tr>
<tr>
<td>Description:</td>
<td>
  Functions to import and handle infrared spectra (import from '.csv' and
  Thermo Galactic's '.spc', baseline correction, binning, clipping,
  interpolating, smoothing, averaging, adding, subtracting, dividing, 
  multiplying, plotting).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2.9000</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>tidyr, dplyr, purrr, tibble, ggplot2, stringr, ChemoSpec (&ge;
5.2.12), hyperSpec (&ge; 0.99.20200527), signal, grDevices,
rlang, methods, units, Rdpack, magrittr, stats, lifecycle,
baseline</td>
</tr>
<tr>
<td>Suggests:</td>
<td>kableExtra, fda, knitr, rmarkdown, spelling, vctrs,
tidyselect</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-05-02</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://henningte.github.io/ir/">https://henningte.github.io/ir/</a></td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-05-02 11:27:00 UTC; henni</td>
</tr>
<tr>
<td>Author:</td>
<td>Henning Teickner <a href="https://orcid.org/0000-0002-3993-1182"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Henning Teickner &lt;henning.teickner@uni-muenster.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-05-02 11:50:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='ir-package'>ir: Functions to Handle and Preprocess Infrared Spectra</h2><span id='topic+ir'></span><span id='topic+ir-package'></span>

<h3>Description</h3>

<p>Functions to import and handle infrared spectra (import from '.csv' and Thermo Galactic's '.spc', baseline correction, binning, clipping, interpolating, smoothing, averaging, adding, subtracting, dividing, multiplying, plotting).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Henning Teickner <a href="mailto:henning.teickner@uni-muenster.de">henning.teickner@uni-muenster.de</a> (<a href="https://orcid.org/0000-0002-3993-1182">ORCID</a>) [copyright holder]
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://henningte.github.io/ir/">https://henningte.github.io/ir/</a>
</p>
</li></ul>


<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code style="white-space: pre;">&#8288;magrittr::[\%&gt;\%][magrittr::pipe]&#8288;</code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling <code>rhs(lhs)</code>.
</p>

<hr>
<h2 id='arrange.ir'>Arrange rows in <code>ir</code> objects by column values</h2><span id='topic+arrange.ir'></span>

<h3>Description</h3>

<p>Arrange rows in <code>ir</code> objects by column values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arrange.ir(.data, ..., .by_group = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arrange.ir_+3A_.data">.data</code></td>
<td>
<p>An object of class <code>ir</code>.</p>
</td></tr>
<tr><td><code id="arrange.ir_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_data_masking">data-masking</a></code>&gt; Variables, or functions of
variables. Use <code><a href="dplyr.html#topic+desc">desc()</a></code> to sort a variable in descending order.</p>
</td></tr>
<tr><td><code id="arrange.ir_+3A_.by_group">.by_group</code></td>
<td>
<p>If <code>TRUE</code>, will sort first by grouping variable. Applies to
grouped data frames only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>.data</code> with arranged rows.
</p>


<h3>Source</h3>

<p><code><a href="dplyr.html#topic+arrange">dplyr::arrange()</a></code>
</p>


<h3>See Also</h3>

<p>Other tidyverse: 
<code><a href="#topic+distinct.ir">distinct.ir</a>()</code>,
<code><a href="#topic+extract.ir">extract.ir</a>()</code>,
<code><a href="#topic+filter-joins">filter-joins</a></code>,
<code><a href="#topic+filter.ir">filter.ir</a>()</code>,
<code><a href="#topic+group_by">group_by</a></code>,
<code><a href="#topic+mutate-joins">mutate-joins</a></code>,
<code><a href="#topic+mutate">mutate</a></code>,
<code><a href="#topic+nest">nest</a></code>,
<code><a href="#topic+pivot_longer.ir">pivot_longer.ir</a>()</code>,
<code><a href="#topic+pivot_wider.ir">pivot_wider.ir</a>()</code>,
<code><a href="#topic+rename">rename</a></code>,
<code><a href="#topic+rowwise.ir">rowwise.ir</a>()</code>,
<code><a href="#topic+select.ir">select.ir</a>()</code>,
<code><a href="#topic+separate.ir">separate.ir</a>()</code>,
<code><a href="#topic+separate_rows.ir">separate_rows.ir</a>()</code>,
<code><a href="#topic+slice">slice</a></code>,
<code><a href="#topic+summarize">summarize</a></code>,
<code><a href="#topic+unite.ir">unite.ir</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## arrange
dplyr::arrange(ir_sample_data, dplyr::desc(sample_type))


</code></pre>

<hr>
<h2 id='bind'>Bind rows of <code>ir</code> objects</h2><span id='topic+bind'></span><span id='topic+rbind.ir'></span><span id='topic+cbind.ir'></span>

<h3>Description</h3>

<p>Bind rows of <code>ir</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ir'
rbind(..., deparse.level = 1)

## S3 method for class 'ir'
cbind(..., deparse.level = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bind_+3A_...">...</code></td>
<td>
<p>Objects to bind together. For <code>cbind</code>, only the first of the
objects is allowed to be of class <code>ir</code>.</p>
</td></tr>
<tr><td><code id="bind_+3A_deparse.level">deparse.level</code></td>
<td>
<p>An integer value; see <code><a href="base.html#topic+rbind">rbind()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>ir</code>. <code>rbind</code> returns all input
<code>ir</code> objects combined row-wise. <code>cbind</code> returns the input <code>ir</code>
object and the other objects combined column-wise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># rbind
rbind(ir_sample_data, ir_sample_data)
rbind(ir_sample_data %&gt;% dplyr::select(spectra),
      ir_sample_data %&gt;% dplyr::select(spectra))

# cbind
cbind(ir_sample_data, a = seq_len(nrow(ir_sample_data)))

</code></pre>

<hr>
<h2 id='distinct.ir'>Subset distinct/unique rows in <code>ir</code> objects</h2><span id='topic+distinct.ir'></span>

<h3>Description</h3>

<p>Subset distinct/unique rows in <code>ir</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distinct.ir(.data, ..., .keep_all = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distinct.ir_+3A_.data">.data</code></td>
<td>
<p>An object of class <code>ir</code>.</p>
</td></tr>
<tr><td><code id="distinct.ir_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_data_masking">data-masking</a></code>&gt; Optional variables to use
when determining uniqueness. If there are multiple rows for a given
combination of inputs, only the first row will be preserved. If omitted,
will use all variables.</p>
</td></tr>
<tr><td><code id="distinct.ir_+3A_.keep_all">.keep_all</code></td>
<td>
<p>If <code>TRUE</code>, keep all variables in <code>.data</code>.
If a combination of <code>...</code> is not distinct, this keeps the
first row of values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>.data</code> with distinct rows.
</p>


<h3>Source</h3>

<p><code><a href="dplyr.html#topic+distinct">dplyr::distinct()</a></code>
</p>


<h3>See Also</h3>

<p>Other tidyverse: 
<code><a href="#topic+arrange.ir">arrange.ir</a>()</code>,
<code><a href="#topic+extract.ir">extract.ir</a>()</code>,
<code><a href="#topic+filter-joins">filter-joins</a></code>,
<code><a href="#topic+filter.ir">filter.ir</a>()</code>,
<code><a href="#topic+group_by">group_by</a></code>,
<code><a href="#topic+mutate-joins">mutate-joins</a></code>,
<code><a href="#topic+mutate">mutate</a></code>,
<code><a href="#topic+nest">nest</a></code>,
<code><a href="#topic+pivot_longer.ir">pivot_longer.ir</a>()</code>,
<code><a href="#topic+pivot_wider.ir">pivot_wider.ir</a>()</code>,
<code><a href="#topic+rename">rename</a></code>,
<code><a href="#topic+rowwise.ir">rowwise.ir</a>()</code>,
<code><a href="#topic+select.ir">select.ir</a>()</code>,
<code><a href="#topic+separate.ir">separate.ir</a>()</code>,
<code><a href="#topic+separate_rows.ir">separate_rows.ir</a>()</code>,
<code><a href="#topic+slice">slice</a></code>,
<code><a href="#topic+summarize">summarize</a></code>,
<code><a href="#topic+unite.ir">unite.ir</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## distinct
dplyr::distinct(rep(ir_sample_data, 2))


</code></pre>

<hr>
<h2 id='extract.ir'>Extract a character column in an <code>ir</code> object into multiple columns using regular expression groups</h2><span id='topic+extract.ir'></span>

<h3>Description</h3>

<p>Extract a character column in an <code>ir</code> object into multiple columns using regular expression groups
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract.ir(
  data,
  col,
  into,
  regex = "([[:alnum:]]+)",
  remove = TRUE,
  convert = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract.ir_+3A_data">data</code></td>
<td>
<p>An object of class <code>ir</code>.</p>
</td></tr>
<tr><td><code id="extract.ir_+3A_col">col</code></td>
<td>
<p>Column name or position. This is passed to
<code><a href="tidyselect.html#topic+vars_pull">tidyselect::vars_pull()</a></code>.
</p>
<p>This argument is passed by expression and supports
<a href="rlang.html#topic+nse-force">quasiquotation</a> (you can unquote column
names or column positions).</p>
</td></tr>
<tr><td><code id="extract.ir_+3A_into">into</code></td>
<td>
<p>Names of new variables to create as character vector.
Use <code>NA</code> to omit the variable in the output.</p>
</td></tr>
<tr><td><code id="extract.ir_+3A_regex">regex</code></td>
<td>
<p>A string representing a regular expression used to extract the
desired values. There should be one group (defined by <code style="white-space: pre;">&#8288;()&#8288;</code>) for each
element of <code>into</code>.</p>
</td></tr>
<tr><td><code id="extract.ir_+3A_remove">remove</code></td>
<td>
<p>If <code>TRUE</code>, remove input column from output data frame.</p>
</td></tr>
<tr><td><code id="extract.ir_+3A_convert">convert</code></td>
<td>
<p>If <code>TRUE</code>, will run <code><a href="utils.html#topic+type.convert">type.convert()</a></code> with
<code>as.is = TRUE</code> on new columns. This is useful if the component
columns are integer, numeric or logical.
</p>
<p>NB: this will cause string <code>"NA"</code>s to be converted to <code>NA</code>s.</p>
</td></tr>
<tr><td><code id="extract.ir_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data</code> with an extracted character column. See
<code><a href="tidyr.html#topic+extract">tidyr::extract()</a></code>.
</p>


<h3>Source</h3>

<p><code><a href="tidyr.html#topic+extract">tidyr::extract()</a></code>
</p>


<h3>See Also</h3>

<p>Other tidyverse: 
<code><a href="#topic+arrange.ir">arrange.ir</a>()</code>,
<code><a href="#topic+distinct.ir">distinct.ir</a>()</code>,
<code><a href="#topic+filter-joins">filter-joins</a></code>,
<code><a href="#topic+filter.ir">filter.ir</a>()</code>,
<code><a href="#topic+group_by">group_by</a></code>,
<code><a href="#topic+mutate-joins">mutate-joins</a></code>,
<code><a href="#topic+mutate">mutate</a></code>,
<code><a href="#topic+nest">nest</a></code>,
<code><a href="#topic+pivot_longer.ir">pivot_longer.ir</a>()</code>,
<code><a href="#topic+pivot_wider.ir">pivot_wider.ir</a>()</code>,
<code><a href="#topic+rename">rename</a></code>,
<code><a href="#topic+rowwise.ir">rowwise.ir</a>()</code>,
<code><a href="#topic+select.ir">select.ir</a>()</code>,
<code><a href="#topic+separate.ir">separate.ir</a>()</code>,
<code><a href="#topic+separate_rows.ir">separate_rows.ir</a>()</code>,
<code><a href="#topic+slice">slice</a></code>,
<code><a href="#topic+summarize">summarize</a></code>,
<code><a href="#topic+unite.ir">unite.ir</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## extract
ir_sample_data %&gt;%
  tidyr::extract(
    id_sample,  "a"
  )


</code></pre>

<hr>
<h2 id='filter-joins'>Filtering joins for an <code>ir</code> object</h2><span id='topic+filter-joins'></span><span id='topic+semi_join.ir'></span><span id='topic+anti_join.ir'></span>

<h3>Description</h3>

<p>Filtering joins for an <code>ir</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>semi_join.ir(x, y, by = NULL, copy = FALSE, ..., na_matches = c("na", "never"))

anti_join.ir(x, y, by = NULL, copy = FALSE, ..., na_matches = c("na", "never"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter-joins_+3A_x">x</code></td>
<td>
<p>An object of class <code>ir</code>.</p>
</td></tr>
<tr><td><code id="filter-joins_+3A_y">y</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="filter-joins_+3A_by">by</code></td>
<td>
<p>A character vector of variables to join by.
</p>
<p>If <code>NULL</code>, the default, <code style="white-space: pre;">&#8288;*_join()&#8288;</code> will perform a natural join, using all
variables in common across <code>x</code> and <code>y</code>. A message lists the variables so that you
can check they're correct; suppress the message by supplying <code>by</code> explicitly.
</p>
<p>To join by different variables on <code>x</code> and <code>y</code>, use a named vector.
For example, <code>by = c("a" = "b")</code> will match <code>x$a</code> to <code>y$b</code>.
</p>
<p>To join by multiple variables, use a vector with length &gt; 1.
For example, <code>by = c("a", "b")</code> will match <code>x$a</code> to <code>y$a</code> and <code>x$b</code> to
<code>y$b</code>. Use a named vector to match different variables in <code>x</code> and <code>y</code>.
For example, <code>by = c("a" = "b", "c" = "d")</code> will match <code>x$a</code> to <code>y$b</code> and
<code>x$c</code> to <code>y$d</code>.
</p>
<p>To perform a cross-join, generating all combinations of <code>x</code> and <code>y</code>,
use <code>by = character()</code>.</p>
</td></tr>
<tr><td><code id="filter-joins_+3A_copy">copy</code></td>
<td>
<p>If <code>x</code> and <code>y</code> are not from the same data source,
and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the
same src as <code>x</code>.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.</p>
</td></tr>
<tr><td><code id="filter-joins_+3A_...">...</code></td>
<td>
<p>Other parameters passed onto methods.</p>
</td></tr>
<tr><td><code id="filter-joins_+3A_na_matches">na_matches</code></td>
<td>
<p>Should <code>NA</code> and <code>NaN</code> values match one another?
</p>
<p>The default, <code>"na"</code>, treats two <code>NA</code> or <code>NaN</code> values as equal, like
<code>%in%</code>, <code><a href="base.html#topic+match">match()</a></code>, <code><a href="base.html#topic+merge">merge()</a></code>.
</p>
<p>Use <code>"never"</code> to always treat two <code>NA</code> or <code>NaN</code> values as different, like
joins for database sources, similarly to <code>merge(incomparables = FALSE)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> and <code>y</code> joined. If the <code>spectra</code> column is renamed, the <code>ir</code>
class is dropped. See <code><a href="dplyr.html#topic+filter-joins">filter-joins</a></code>.
</p>


<h3>Source</h3>

<p><code><a href="dplyr.html#topic+filter-joins">filter-joins</a></code>
</p>


<h3>See Also</h3>

<p>Other tidyverse: 
<code><a href="#topic+arrange.ir">arrange.ir</a>()</code>,
<code><a href="#topic+distinct.ir">distinct.ir</a>()</code>,
<code><a href="#topic+extract.ir">extract.ir</a>()</code>,
<code><a href="#topic+filter.ir">filter.ir</a>()</code>,
<code><a href="#topic+group_by">group_by</a></code>,
<code><a href="#topic+mutate-joins">mutate-joins</a></code>,
<code><a href="#topic+mutate">mutate</a></code>,
<code><a href="#topic+nest">nest</a></code>,
<code><a href="#topic+pivot_longer.ir">pivot_longer.ir</a>()</code>,
<code><a href="#topic+pivot_wider.ir">pivot_wider.ir</a>()</code>,
<code><a href="#topic+rename">rename</a></code>,
<code><a href="#topic+rowwise.ir">rowwise.ir</a>()</code>,
<code><a href="#topic+select.ir">select.ir</a>()</code>,
<code><a href="#topic+separate.ir">separate.ir</a>()</code>,
<code><a href="#topic+separate_rows.ir">separate_rows.ir</a>()</code>,
<code><a href="#topic+slice">slice</a></code>,
<code><a href="#topic+summarize">summarize</a></code>,
<code><a href="#topic+unite.ir">unite.ir</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## semi_join
set.seed(234)
dplyr::semi_join(
  ir_sample_data,
  tibble::tibble(
    id_measurement = c(1:5, 101:105),
    nitrogen_content = rbeta(n = 10, 0.2, 0.1)
  ),
  by = "id_measurement"
)


## anti_join
set.seed(234)
dplyr::anti_join(
  ir_sample_data,
  tibble::tibble(
    id_measurement = c(1:5, 101:105),
    nitrogen_content = rbeta(n = 10, 0.2, 0.1)
  ),
  by = "id_measurement"
)


</code></pre>

<hr>
<h2 id='filter.ir'>Subset rows in <code>ir</code> objects using column values</h2><span id='topic+filter.ir'></span>

<h3>Description</h3>

<p>Subset rows in <code>ir</code> objects using column values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter.ir(.data, ..., .preserve = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter.ir_+3A_.data">.data</code></td>
<td>
<p>An object of class <code>ir</code>.</p>
</td></tr>
<tr><td><code id="filter.ir_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_data_masking">data-masking</a></code>&gt; Expressions that return a
logical value, and are defined in terms of the variables in <code>.data</code>.
If multiple expressions are included, they are combined with the <code>&amp;</code> operator.
Only rows for which all conditions evaluate to <code>TRUE</code> are kept.</p>
</td></tr>
<tr><td><code id="filter.ir_+3A_.preserve">.preserve</code></td>
<td>
<p>Relevant when the <code>.data</code> input is grouped.
If <code>.preserve = FALSE</code> (the default), the grouping structure
is recalculated based on the resulting data, otherwise the grouping is kept as is.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>.data</code> with filtered rows.
</p>


<h3>Source</h3>

<p><code><a href="dplyr.html#topic+filter">dplyr::filter()</a></code>
</p>


<h3>See Also</h3>

<p>Other tidyverse: 
<code><a href="#topic+arrange.ir">arrange.ir</a>()</code>,
<code><a href="#topic+distinct.ir">distinct.ir</a>()</code>,
<code><a href="#topic+extract.ir">extract.ir</a>()</code>,
<code><a href="#topic+filter-joins">filter-joins</a></code>,
<code><a href="#topic+group_by">group_by</a></code>,
<code><a href="#topic+mutate-joins">mutate-joins</a></code>,
<code><a href="#topic+mutate">mutate</a></code>,
<code><a href="#topic+nest">nest</a></code>,
<code><a href="#topic+pivot_longer.ir">pivot_longer.ir</a>()</code>,
<code><a href="#topic+pivot_wider.ir">pivot_wider.ir</a>()</code>,
<code><a href="#topic+rename">rename</a></code>,
<code><a href="#topic+rowwise.ir">rowwise.ir</a>()</code>,
<code><a href="#topic+select.ir">select.ir</a>()</code>,
<code><a href="#topic+separate.ir">separate.ir</a>()</code>,
<code><a href="#topic+separate_rows.ir">separate_rows.ir</a>()</code>,
<code><a href="#topic+slice">slice</a></code>,
<code><a href="#topic+summarize">summarize</a></code>,
<code><a href="#topic+unite.ir">unite.ir</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## filter
dplyr::filter(ir_sample_data, sample_type == "office paper")


</code></pre>

<hr>
<h2 id='group_by'>Group rows in <code>ir</code> objects by one or more variables</h2><span id='topic+group_by'></span><span id='topic+group_by.ir'></span><span id='topic+ungroup.ir'></span>

<h3>Description</h3>

<p>Group rows in <code>ir</code> objects by one or more variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_by.ir(
  .data,
  ...,
  .add = FALSE,
  .drop = dplyr::group_by_drop_default(.data)
)

ungroup.ir(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="group_by_+3A_.data">.data</code></td>
<td>
<p>An object of class <code>ir</code>.</p>
</td></tr>
<tr><td><code id="group_by_+3A_...">...</code></td>
<td>
<p>In <code>group_by()</code>, variables or computations to group by.
Computations are always done on the ungrouped data frame.
To perform computations on the grouped data, you need to use
a separate <code>mutate()</code> step before the <code>group_by()</code>.
Computations are not allowed in <code>nest_by()</code>.
In <code>ungroup()</code>, variables to remove from the grouping.</p>
</td></tr>
<tr><td><code id="group_by_+3A_.add">.add</code></td>
<td>
<p>When <code>FALSE</code>, the default, <code>group_by()</code> will
override existing groups. To add to the existing groups, use
<code>.add = TRUE</code>.
</p>
<p>This argument was previously called <code>add</code>, but that prevented
creating a new grouping variable called <code>add</code>, and conflicts with
our naming conventions.</p>
</td></tr>
<tr><td><code id="group_by_+3A_.drop">.drop</code></td>
<td>
<p>Drop groups formed by factor levels that don't appear in the
data? The default is <code>TRUE</code> except when <code>.data</code> has been previously
grouped with <code>.drop = FALSE</code>. See <code><a href="dplyr.html#topic+group_by_drop_default">group_by_drop_default()</a></code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>.data</code> with grouped rows (<code>group_by.ir()</code>) or ungrouped rows
(<code>ungroup.ir()</code>).
</p>


<h3>Source</h3>

<p><code><a href="dplyr.html#topic+group_by">dplyr::group_by()</a></code>
</p>


<h3>See Also</h3>

<p>Other tidyverse: 
<code><a href="#topic+arrange.ir">arrange.ir</a>()</code>,
<code><a href="#topic+distinct.ir">distinct.ir</a>()</code>,
<code><a href="#topic+extract.ir">extract.ir</a>()</code>,
<code><a href="#topic+filter-joins">filter-joins</a></code>,
<code><a href="#topic+filter.ir">filter.ir</a>()</code>,
<code><a href="#topic+mutate-joins">mutate-joins</a></code>,
<code><a href="#topic+mutate">mutate</a></code>,
<code><a href="#topic+nest">nest</a></code>,
<code><a href="#topic+pivot_longer.ir">pivot_longer.ir</a>()</code>,
<code><a href="#topic+pivot_wider.ir">pivot_wider.ir</a>()</code>,
<code><a href="#topic+rename">rename</a></code>,
<code><a href="#topic+rowwise.ir">rowwise.ir</a>()</code>,
<code><a href="#topic+select.ir">select.ir</a>()</code>,
<code><a href="#topic+separate.ir">separate.ir</a>()</code>,
<code><a href="#topic+separate_rows.ir">separate_rows.ir</a>()</code>,
<code><a href="#topic+slice">slice</a></code>,
<code><a href="#topic+summarize">summarize</a></code>,
<code><a href="#topic+unite.ir">unite.ir</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## group_by
dplyr::group_by(ir_sample_data, sample_type)


## ungroup
dplyr::ungroup(dplyr::group_by(ir_sample_data, sample_type))


</code></pre>

<hr>
<h2 id='ir_add'>Add infrared spectra</h2><span id='topic+ir_add'></span>

<h3>Description</h3>

<p><code>ir_add</code> takes two objects of class <code>ir</code>, <code>x</code> and
<code>y</code>, and adds the intensity values of spectra in matching rows from
<code>y</code> to that of <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ir_add(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ir_add_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+ir_new_ir">ir</a></code>.</p>
</td></tr>
<tr><td><code id="ir_add_+3A_y">y</code></td>
<td>
<p>An object of class <code><a href="#topic+ir_new_ir">ir</a></code> or a numeic value. If <code>y</code>
is an object of class <code>ir</code>, it must have the same number of rows as
<code>x</code> and the same x axis values (e.g. wavenumber values) in each matching
spectrum as in <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> where for each spectrum the respective intensity values in
<code>y</code> are added.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;-
  ir::ir_add(ir::ir_sample_data, ir::ir_sample_data)
x1 &lt;-
  ir::ir_add(ir::ir_sample_data, ir::ir_sample_data[1, ])

</code></pre>

<hr>
<h2 id='ir_as_ir'>Generic to convert objects to class <code>ir</code></h2><span id='topic+ir_as_ir'></span><span id='topic+ir_as_ir.ir'></span><span id='topic+ir_as_ir.data.frame'></span>

<h3>Description</h3>

<p><code>ir_as_ir</code> ir the generic to convert an object to an object of class
<code><a href="#topic+ir_new_ir">ir</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ir_as_ir(x, ...)

## S3 method for class 'ir'
ir_as_ir(x, ...)

## S3 method for class 'data.frame'
ir_as_ir(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ir_as_ir_+3A_x">x</code></td>
<td>
<p>An object.</p>
</td></tr>
<tr><td><code id="ir_as_ir_+3A_...">...</code></td>
<td>
<p>Further arguments passed to individual methods.
</p>

<ul>
<li><p> If <code>x</code> is a data frame or an object of class <code>ir</code>, these are
ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>ir</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># conversion from an ir object
ir::ir_sample_data %&gt;%
  ir_as_ir()

# conversion from a data frame
x_ir &lt;- ir::ir_sample_data

x_df &lt;-
  x_ir %&gt;%
  ir_drop_spectra() %&gt;%
  dplyr::mutate(
    spectra = x_ir$spectra
  ) %&gt;%
  ir_as_ir()

# check that ir_as_ir preserves the input class
ir_sample_data %&gt;%
  structure(class = setdiff(class(.), "ir")) %&gt;%
  dplyr::group_by(sample_type) %&gt;%
  ir_as_ir()


</code></pre>

<hr>
<h2 id='ir_average'>Averages infrared spectra within groups</h2><span id='topic+ir_average'></span>

<h3>Description</h3>

<p><code>ir_average</code> averages infrared spectra within a user-defined group. <code>NA</code>
values are omitted by default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ir_average(x, ..., na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ir_average_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+ir_new_ir">ir</a></code>.</p>
</td></tr>
<tr><td><code id="ir_average_+3A_...">...</code></td>
<td>
<p>Variables in <code>x</code> to use as groups.</p>
</td></tr>
<tr><td><code id="ir_average_+3A_na.rm">na.rm</code></td>
<td>
<p>A logical value indicating if <code>NA</code> values should be dropped
(<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>ir</code> where spectra have been averaged within
groups defined by <code>...</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># average the sample data spectra across sample types
x &lt;-
  ir::ir_sample_data %&gt;%
  ir::ir_average(sample_type)
</code></pre>

<hr>
<h2 id='ir_bc'>Performs baseline correction on infrared spectra</h2><span id='topic+ir_bc'></span>

<h3>Description</h3>

<p><code>ir_bc</code> performs baseline correction for infrared spectra. Baseline
correction is either performed by using a polynomial with user defined
degree fitted to each spectrum (see <code><a href="ChemoSpec.html#topic+baselineSpectra">ChemoSpec::baselineSpectra()</a></code>), or by
using a rubberband function that is fitted to each spectrum (see
<code><a href="hyperSpec.html#topic+spc-rubberband">hyperSpec::spc.rubberband()</a></code>), or using a Savitzky-Golay smoothed version of
the input spectra (see <code><a href="#topic+ir_bc_sg">ir_bc_sg()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ir_bc(x, method = "rubberband", ..., return_bl = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ir_bc_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+ir_new_ir">ir</a></code>.</p>
</td></tr>
<tr><td><code id="ir_bc_+3A_method">method</code></td>
<td>
<p>A character value indicating which method should be used
for baseline correction. If <code>method = "polynomial"</code>, a polynomial
is used for baseline correction. If <code>method = "rubberband"</code>, a
rubberband function is used for baseline correction. If <code>method = "sg"</code>,
a Savitzky-Golay smoothed version of the input spectra is used for baseline
correction.</p>
</td></tr>
<tr><td><code id="ir_bc_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+ir_bc_polynomial">ir_bc_polynomial()</a></code> or
<code><a href="#topic+ir_bc_sg">ir_bc_sg()</a></code>.</p>
</td></tr>
<tr><td><code id="ir_bc_+3A_return_bl">return_bl</code></td>
<td>
<p>A logical value indicating if for each spectrum the baseline
should be returned instead of the corrected intensity values
(<code>return_bl = TRUE</code>) or not (<code>return_bl = FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>ir</code> with the baseline corrected spectra, or if
<code>return_bl = TRUE</code>, the baselines instead of the spectra in column <code>spectra</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

# rubberband baseline correction
x1 &lt;-
   ir::ir_sample_data %&gt;%
   dplyr::slice(1:10) %&gt;%
   ir::ir_bc(method = "rubberband")

# polynomial baseline correction
x2 &lt;-
   ir::ir_sample_data %&gt;%
   dplyr::slice(1:10) %&gt;%
   ir::ir_bc(method = "polynomial", degree = 2)

# Savitzky-Golay baseline correction
x3 &lt;-
   ir::ir_sample_data %&gt;%
   dplyr::slice(1:10) %&gt;%
   ir::ir_bc(method = "sg", p = 3, n = 199, ts = 1, m = 0)

# return the baseline instead of the baseline corrected spectra
x1_bl &lt;-
   ir::ir_sample_data %&gt;%
   dplyr::slice(1:10) %&gt;%
   ir::ir_bc(method = "rubberband", return_bl = TRUE)

</code></pre>

<hr>
<h2 id='ir_bc_polynomial'>Performs baseline correction on infrared spectra using a polynomial</h2><span id='topic+ir_bc_polynomial'></span>

<h3>Description</h3>

<p><code>ir_bc_polynomial</code> performs baseline correction for infrared
spectra using a polynomial.
<code>ir_bc_polynomial</code> is an extended wrapper function
for <code><a href="ChemoSpec.html#topic+baselineSpectra">ChemoSpec::baselineSpectra()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ir_bc_polynomial(x, degree = 2, return_bl = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ir_bc_polynomial_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+ir_new_ir">ir</a></code>.</p>
</td></tr>
<tr><td><code id="ir_bc_polynomial_+3A_degree">degree</code></td>
<td>
<p>An integer value representing the degree of the polynomial
used for baseline correction.</p>
</td></tr>
<tr><td><code id="ir_bc_polynomial_+3A_return_bl">return_bl</code></td>
<td>
<p>A logical value indicating if for each spectrum the baseline
should be returned instead of the corrected intensity values
(<code>return_bl = TRUE</code>) or not (<code>return_bl = FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>ir</code> with the baseline corrected spectra if
<code>returnbl = FALSE</code> or the baselines if <code>returnbl = TRUE</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ir_bc">ir_bc()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x2 &lt;-
   ir::ir_sample_data %&gt;%
   ir::ir_bc_polynomial(degree = 2, return_bl = FALSE)

</code></pre>

<hr>
<h2 id='ir_bc_rubberband'>Performs baseline correction on infrared spectra using a rubberband algorithm</h2><span id='topic+ir_bc_rubberband'></span>

<h3>Description</h3>

<p><code>ir_bc_rubberband</code> performs baseline correction for infrared spectra
using a rubberband algorithm. <code>ir_bc_rubberband</code> is an extended wrapper
function for <code><a href="hyperSpec.html#topic+spc-rubberband">hyperSpec::spc.rubberband()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ir_bc_rubberband(x, return_bl = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ir_bc_rubberband_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+ir_new_ir">ir</a></code>.</p>
</td></tr>
<tr><td><code id="ir_bc_rubberband_+3A_return_bl">return_bl</code></td>
<td>
<p>A logical value indicating if for each spectrum the baseline
should be returned instead of the corrected intensity values
(<code>return_bl = TRUE</code>) or not (<code>return_bl = FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>ir</code> with the baseline corrected spectra and,
if <code>returnbl = TRUE</code>,  the baselines.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ir_bc">ir_bc()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;-
   ir::ir_sample_data %&gt;%
   ir::ir_bc_rubberband(return_bl = FALSE)

</code></pre>

<hr>
<h2 id='ir_bc_sg'>Performs baseline correction on infrared spectra using a Savitzky-Golay baseline</h2><span id='topic+ir_bc_sg'></span>

<h3>Description</h3>

<p><code>ir_bc_sg</code> computes a smoothed version of spectra using
<code><a href="#topic+ir_smooth">ir_smooth()</a></code> with <code>method = "sg"</code> and uses this as baseline
which is subtracted from the spectra to perform a baseline correction
(Lasch 2012).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ir_bc_sg(x, ..., return_bl = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ir_bc_sg_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+ir_new_ir">ir</a></code>.</p>
</td></tr>
<tr><td><code id="ir_bc_sg_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+ir_smooth">ir_smooth()</a></code> (except for
<code>method</code> which is always set to <code>"sg"</code>).</p>
</td></tr>
<tr><td><code id="ir_bc_sg_+3A_return_bl">return_bl</code></td>
<td>
<p>A logical value indicating if for each spectrum the baseline
should be returned instead of the corrected intensity values
(<code>return_bl = TRUE</code>) or not (<code>return_bl = FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>ir</code> with the baseline corrected spectra and,
if <code>returnbl = TRUE</code>,  the baselines.
</p>


<h3>References</h3>

<p>Lasch P (2012).
&ldquo;Spectral Pre-Processing for Biomedical Vibrational Spectroscopy and Microspectroscopic Imaging.&rdquo;
<em>Chemometrics and Intelligent Laboratory Systems</em>, <b>117</b>, 100&ndash;114.
ISSN 01697439, <a href="https://doi.org/10.1016/j.chemolab.2012.03.011">doi:10.1016/j.chemolab.2012.03.011</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;-
   ir::ir_sample_data %&gt;%
   ir::ir_bc_sg(p = 3, n = 199, ts = 1, m = 0, return_bl = FALSE)

</code></pre>

<hr>
<h2 id='ir_bin'>Bins infrared spectra</h2><span id='topic+ir_bin'></span>

<h3>Description</h3>

<p><code>ir_bin</code> bins intensity values of infrared spectra into bins of a
defined width or into a defined number of bins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ir_bin(x, width = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ir_bin_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+ir_new_ir">ir</a></code> with integer wavenumber
values increasing by 1.</p>
</td></tr>
<tr><td><code id="ir_bin_+3A_width">width</code></td>
<td>
<p>An integer value indicating the wavenumber width of each
resulting bin. Must be set to <code>NULL</code> if <code>n</code> is specified.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the last bin contains fewer input values than the remaining bins, it
will be dropped and a warning will be printed. If a wavenumber value exactly
matches the boundary of a bin window, the respective intensity value will be
assigned to both neighboring bins.
</p>


<h3>Value</h3>

<p>An object of class <code>ir</code> where spectra have been binned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;-
   ir::ir_sample_data %&gt;%
   ir_bin(width = 50)

</code></pre>

<hr>
<h2 id='ir_clip'>Clips infrared spectra to new wavenumber ranges</h2><span id='topic+ir_clip'></span>

<h3>Description</h3>

<p><code>ir_clip</code> clips infrared spectra to a new, specified, wavenumber range
or multiple new specified wavenumber ranges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ir_clip(x, range)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ir_clip_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+ir_new_ir">ir</a></code>.</p>
</td></tr>
<tr><td><code id="ir_clip_+3A_range">range</code></td>
<td>
<p>A <code>data.frame</code> with two columns and a row for each
wavenumber range to keep. The columns are:
</p>

<dl>
<dt>start</dt><dd><p>A numeric vector with start values for wavenumber ranges.</p>
</dd>
<dt>end</dt><dd><p>A numeric vector with end values for wavenumber ranges.</p>
</dd>
</dl>

<p>If <code>range</code> has more than one row, multiple ranges are clipped from
<code>x</code> and merged together. Overlapping ranges are not allowed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>ir</code> where spectra have been clipped.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## clipping with one range

# define clipping range
range &lt;-
  data.frame(start = 900, end = 1000)

# clip
x &lt;-
   ir::ir_sample_data %&gt;%
   ir::ir_clip(range = range)

## clipping with mutliple ranges

range &lt;-
  data.frame(start = c(900, 1900), end = c(1000, 2200))

# clip
x &lt;-
   ir::ir_sample_data %&gt;%
   ir::ir_clip(range = range)
</code></pre>

<hr>
<h2 id='ir_divide'>Divide infrared spectra or divide infrared spectra by a numeric value</h2><span id='topic+ir_divide'></span>

<h3>Description</h3>

<p><code>ir_divide</code> takes two objects of class <code>ir</code>, <code>x</code> and
<code>y</code>, and divides their intensity values, or it takes one object of
class <code>ir</code>, <code>x</code>, and one numeric value, <code>y</code>, and divides
all intensity values in <code>x</code> by <code>y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ir_divide(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ir_divide_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+ir_new_ir">ir</a></code>.</p>
</td></tr>
<tr><td><code id="ir_divide_+3A_y">y</code></td>
<td>
<p>An object of class <code><a href="#topic+ir_new_ir">ir</a></code> or a numeic value. If <code>y</code>
is an object of class <code>ir</code>, it must have the same number of rows as
<code>x</code> and the same x axis values (e.g. wavenumber values) in each matching
spectrum as in <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> where for each spectrum intensity values are divided by
the respective intensity values in <code>y</code> (if <code>y</code> is an object of
class <code>ir</code>), or where all intensity values are divided by <code>y</code> if
<code>y</code> is a numeric value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># division with y as ir object
x1 &lt;-
  ir::ir_divide(ir::ir_sample_data, ir::ir_sample_data)
x1 &lt;-
  ir::ir_divide(ir::ir_sample_data, ir::ir_sample_data[1, ])

# division with y being a numeric value
x2 &lt;-
  ir::ir_divide(ir::ir_sample_data, y = 20)

</code></pre>

<hr>
<h2 id='ir_drop_spectra'>Drops the column <code>spectra</code> from an object is of class <code>ir</code></h2><span id='topic+ir_drop_spectra'></span>

<h3>Description</h3>

<p><code>ir_drop_spectra</code> removes the column <code>spectra</code> from an object
of class <code>ir</code> and removes the <code>"ir"</code> class attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ir_drop_spectra(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ir_drop_spectra_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+ir_new_ir">ir</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> without column <code>spectra</code> and without <code>"ir"</code> class
attribute.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ir::ir_sample_data %&gt;%
  ir_drop_spectra()

</code></pre>

<hr>
<h2 id='ir_flat_clean'>Cleans objects of class <code>ir_flat</code></h2><span id='topic+ir_flat_clean'></span>

<h3>Description</h3>

<p><code>ir_flatten_clean</code> takes an object of class <code>ir_flat</code> and either
returns all non-empty spectra or all empty spectra as object of class
<code>ir_flat</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ir_flat_clean(x, return_empty = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ir_flat_clean_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+ir_new_ir_flat">ir_flat</a></code>.</p>
</td></tr>
<tr><td><code id="ir_flat_clean_+3A_return_empty">return_empty</code></td>
<td>
<p>A logical value indicating if the empty spectra should be
returned (<code>return_empty = TRUE</code>) or the non-empty spectra
(<code>return_empty = FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> where empty spectra are dropped (if <code>return_empty = TRUE</code>) or
only empty spectra are returned (<code>return_empty = FALSE</code>).
</p>

<hr>
<h2 id='ir_flatten'>Converts objects of class <code>ir</code> to objects of class <code>ir_flat</code></h2><span id='topic+ir_flatten'></span>

<h3>Description</h3>

<p><code>ir_flatten</code> takes and object of class <code>ir</code>, extracts the
<code>spectra</code> column and combines the spectra into an object of class
<code><a href="#topic+ir_new_ir_flat">ir_flat</a></code>. Metadata are not retained during flattening.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ir_flatten(x, measurement_id = as.character(seq_len(nrow(x))))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ir_flatten_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+ir_new_ir">ir</a></code>.</p>
</td></tr>
<tr><td><code id="ir_flatten_+3A_measurement_id">measurement_id</code></td>
<td>
<p>A character vector an element for each row in <code>x</code>
that contains the names to use as column names for the spectra in the
<code>ir_flat</code> object to create.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+ir_new_ir_flat">ir_flat</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x_flat &lt;-
   ir::ir_sample_data %&gt;%
   ir::ir_flatten()

</code></pre>

<hr>
<h2 id='ir_get_intensity'>Extracts intensities from spectra in an <code>ir</code> object for specific spectral channels</h2><span id='topic+ir_get_intensity'></span>

<h3>Description</h3>

<p><code>ir_get_intensity</code> extracts intensity values of spectra for specific
user-defined spectral channels (&quot;x axis values&quot;, e.g. wavenumber values).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ir_get_intensity(x, wavenumber, warn = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ir_get_intensity_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+ir_new_ir">ir</a></code>.</p>
</td></tr>
<tr><td><code id="ir_get_intensity_+3A_wavenumber">wavenumber</code></td>
<td>
<p>A numeric vector with spectral channels (&quot;x axis values&quot;,
e.g. wavenumber values) for which to extract intensities.</p>
</td></tr>
<tr><td><code id="ir_get_intensity_+3A_warn">warn</code></td>
<td>
<p>logical value indicating if warnings should be displayed
(<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> with an additional column <code>intensity</code>.
<code>x$intensity</code> is a list column with each element representing a
<code>data.frame</code> with a row for each element in <code>wavenumber</code> and two
columns:
</p>

<dl>
<dt>x</dt><dd><p>The &quot;x axis values&quot; extracted with
<code><a href="#topic+ir_get_wavenumberindex">ir_get_wavenumberindex()</a></code> applied on <code>wavenumber</code> and the
corresponding spectrum in <code>x</code>.</p>
</dd>
<dt>y</dt><dd><p>The extracted intensity values</p>
</dd></dl>
<p>.

</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;-
   ir::ir_sample_data %&gt;%
   ir::ir_get_intensity(wavenumber = 1090)

</code></pre>

<hr>
<h2 id='ir_get_spectrum'>Extracts selected spectra from an object of class <code>ir</code></h2><span id='topic+ir_get_spectrum'></span>

<h3>Description</h3>

<p><code>ir_get_spectrum</code> extracts selected spectra from an object of class <code>ir</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ir_get_spectrum(x, what)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ir_get_spectrum_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+ir_new_ir">ir</a></code>.</p>
</td></tr>
<tr><td><code id="ir_get_spectrum_+3A_what">what</code></td>
<td>
<p>A numeric vector with each element representing a row in <code>x</code>
for which to extract the spectrum.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector with the same length as <code>wavenumber</code> with the
row indices of <code>x</code> corresponding to the wavenumber values in <code>wavenumber</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;-
   ir::ir_sample_data %&gt;%
   ir::ir_get_spectrum(what = c(5, 9))

</code></pre>

<hr>
<h2 id='ir_get_wavenumberindex'>Gets the index of a defined wavenumber value for a spectrum</h2><span id='topic+ir_get_wavenumberindex'></span>

<h3>Description</h3>

<p><code>ir_get_wavenumberindex</code> gets for a defined wavenumber value or set of
wavenumber values the corresponding indices (row number) in an object of
class <code>ir</code> that has been flattened with <code><a href="#topic+ir_flatten">ir_flatten()</a></code>. If the
specified wavenumber values do not match exactly the wavenumber values in the
<code>ir</code> object, the indices for the next wavenumber values will be
returned, along with a warning.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ir_get_wavenumberindex(x, wavenumber, warn = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ir_get_wavenumberindex_+3A_x">x</code></td>
<td>
<p>A data.frame with a column x representing the x units of a spectrum
or several spectra (e.g. in the form of an object of class
<code><a href="#topic+ir_new_ir_flat">ir_flat</a></code>).</p>
</td></tr>
<tr><td><code id="ir_get_wavenumberindex_+3A_wavenumber">wavenumber</code></td>
<td>
<p>A numeric vector with wavenumber values for which to get
indices.</p>
</td></tr>
<tr><td><code id="ir_get_wavenumberindex_+3A_warn">warn</code></td>
<td>
<p>logical value indicating if warnings should be displayed
(<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector with the same length as <code>wavenumber</code> with the
row indices of <code>x</code> corresponding to the wavenumber values in <code>wavenumber</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x_index_1090 &lt;-
   ir::ir_sample_data %&gt;%
   ir::ir_flatten() %&gt;%
   ir::ir_get_wavenumberindex(wavenumber = 1090)

</code></pre>

<hr>
<h2 id='ir_import_csv'>Imports infrared spectra from various files</h2><span id='topic+ir_import_csv'></span>

<h3>Description</h3>

<p><code>ir_import_csv</code> imports raw infrared spectra from one or more <code>.csv</code> file
that contains at least one spectrum, with x axis values (e.g. wavenumbers) in
the first column and intensity values of spectra in remaining columns. Note
that the function does not perform any checks for the validity of the content
read from the .csv file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ir_import_csv(filenames, sample_id = "from_filenames", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ir_import_csv_+3A_filenames">filenames</code></td>
<td>
<p>A character vector representing the complete paths to
the <code>.csv</code> files to import.</p>
</td></tr>
<tr><td><code id="ir_import_csv_+3A_sample_id">sample_id</code></td>
<td>
<p>Either:
</p>

<ul>
<li> <p><code>NULL</code>: Nothing additional happens.
</p>
</li>
<li><p> A character vector with the same length as <code>filenames</code>: This
vector will be added as column <code>sample_id</code> to the <code>ir</code> object.
</p>
</li>
<li> <p><code>"from_filenames"</code>: The file name(s) will be used as values for
a new column <code>sample_id</code> to add (the default).
</p>
</li>
<li> <p><code>"from_colnames"</code>: The header in the csv file will be used as
values for a new column <code>sample_id</code> to add.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ir_import_csv_+3A_...">...</code></td>
<td>
<p>Further arguments passed to
<code><a href="utils.html#topic+read.table">read.csv()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+ir_new_ir">ir</a></code> containing the
infrared spectra extracted from the <code>.csv</code> file(s).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# import data from csv files
d &lt;- ir::ir_import_csv(
  system.file(package = "ir", "extdata/klh_hodgkins_mir.csv"),
  sample_id = "from_colnames")

</code></pre>

<hr>
<h2 id='ir_import_spc'>Imports infrared spectra from Thermo Galactic's files</h2><span id='topic+ir_import_spc'></span>

<h3>Description</h3>

<p><code>ir_import_spc</code> imports raw infrared spectra from a Thermo Galactic's
<code>.spc</code> file or several of such files. <code>ir_import_spc</code> is a wrapper
function to <code><a href="hyperSpec.html#topic+read-spc">hyperSpec::read.spc()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ir_import_spc(filenames, log.txt = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ir_import_spc_+3A_filenames">filenames</code></td>
<td>
<p>A character vector representing the complete paths to
the <code>.spc</code> files to import.</p>
</td></tr>
<tr><td><code id="ir_import_spc_+3A_log.txt">log.txt</code></td>
<td>
<p>A logical value indicating whether to import metadata (<code>TRUE</code>)
or not (<code>FALSE</code>). See the details section. If set to <code>FALSE</code>, only the
metadata variables <code>exponentiation_factor</code> to <code>measurement_device</code> listed in
the Value section below are included in the <code>ir</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, <code>log.txt</code> must be set to <code>FALSE</code> due to a bug in
<code><a href="hyperSpec.html#topic+read-spc">hyperSpec::read.spc()</a></code>. This bug fill be fixed in the upcoming weeks and
currently can be circumvented by using the development version of 'hyperSpec'.
See https://github.com/r-hyperspec/hyperSpec/issues/80.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+ir_new_ir">ir</a></code> containing the
infrared spectra extracted from the <code>.spc</code> file(s) and the metadata as
extracted by <code><a href="hyperSpec.html#topic+read-spc">hyperSpec::read.spc()</a></code>. Metadata variables are:
</p>

<dl>
<dt>scan_number</dt><dd><p>An integer value representing the number of scans.</p>
</dd>
<dt>detection_gain_factor</dt><dd><p>The detection gain factor.</p>
</dd>
<dt>scan_speed</dt><dd><p>The scan speed [kHz].</p>
</dd>
<dt>laser_wavenumber</dt><dd><p>The wavenumber of the laser.</p>
</dd>
<dt>detector_name</dt><dd><p>The name of the detector.</p>
</dd>
<dt>source_name</dt><dd><p>The name of the infrared radiation source.</p>
</dd>
<dt>purge_delay</dt><dd><p>The duration of purge delay before a measurement [s].</p>
</dd>
<dt>zero_filling_factor</dt><dd><p>A numeric value representing the zero filling
factor.</p>
</dd>
<dt>apodisation_function</dt><dd><p>The name of the apodisation function.</p>
</dd>
<dt>exponentiation_factor</dt><dd><p>The exponentiation factor used for file
compression.</p>
</dd>
<dt>data_point_number</dt><dd><p>The number of data points in the spectrum</p>
</dd>
<dt>x_variable_type</dt><dd><p>The type of the x variable.</p>
</dd>
<dt>y_variable_type</dt><dd><p>The type of the y variable.</p>
</dd>
<dt>measurement_date</dt><dd><p>A POSIXct representing the measurement date and
time.</p>
</dd>
<dt>measurement_device</dt><dd><p>The name of the measurement device.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># import a sample .spc file
x &lt;-
  ir::ir_import_spc(
    system.file("extdata/1.spc", package = "ir"),
    log.txt = FALSE
  )

</code></pre>

<hr>
<h2 id='ir_interpolate'>Interpolates intensity values of infrared spectra in an <code>ir</code> object for new wavenumber values</h2><span id='topic+ir_interpolate'></span>

<h3>Description</h3>

<p><code>ir_interpolate</code> interpolates intensity values for infrared spectra for
new wavenumber values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ir_interpolate(x, start = NULL, dw = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ir_interpolate_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+ir_new_ir">ir</a></code>.</p>
</td></tr>
<tr><td><code id="ir_interpolate_+3A_start">start</code></td>
<td>
<p>A numerical value indicating the start wavenumber value relative
to which new wavenumber values will be interpolated. The value is not allowed
to be &lt; <code>floor(firstvalue) - 2</code>, whereby <code>firstvalue</code> is the first
wavenumber value within <code>x</code>. If <code>start = NULL</code>,
<code>floor(firstvalue)</code> will be used as first wavenumber value.</p>
</td></tr>
<tr><td><code id="ir_interpolate_+3A_dw">dw</code></td>
<td>
<p>A numerical value representing the desired wavenumber value
difference between adjacent values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>ir</code> containing the interpolated spectra. Any
<code>NA</code> values resulting from interpolation will be automatically dropped.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;-
   ir::ir_sample_data %&gt;%
   ir::ir_interpolate(start = NULL, dw = 1)

</code></pre>

<hr>
<h2 id='ir_interpolate_region'>Interpolates selected regions in infrared spectra in an <code>ir</code> object</h2><span id='topic+ir_interpolate_region'></span>

<h3>Description</h3>

<p><code>ir_interpolate_region</code> linearly interpolates a user-defined region in
infrared spectra.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ir_interpolate_region(x, range)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ir_interpolate_region_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+ir_new_ir">ir</a></code>.</p>
</td></tr>
<tr><td><code id="ir_interpolate_region_+3A_range">range</code></td>
<td>
<p>A <code>data.frame</code> with a row for each region to interpolate
linearly and two columns:
</p>

<dl>
<dt>start</dt><dd><p>A numeric vector with start values for regions to interpolate
linearly (x axis values).</p>
</dd>
<dt>end</dt><dd><p>A numeric vector with end values for regions to interpolate
linearly (x axis values).</p>
</dd>
</dl>

<p>For each row in <code>range</code>, the values in <code>range$start</code> have to be
smaller than the values in <code>range$end</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> with the defined wavenumber region(s) interpolated linearly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># interpolation range
range &lt;- data.frame(start = 1000, end = 1500)

# do the interpolation
x &lt;-
   ir::ir_sample_data %&gt;%
   ir::ir_interpolate_region(range = range)

</code></pre>

<hr>
<h2 id='ir_multiply'>Multiply infrared spectra or multiply infrared spectra with a numeric value</h2><span id='topic+ir_multiply'></span>

<h3>Description</h3>

<p><code>ir_multiply</code> takes two objects of class <code>ir</code>, <code>x</code> and
<code>y</code>, and multiplies their intensity values, or it takes one object of
class <code>ir</code>, <code>x</code>, and one numeric value, <code>y</code>, and multiplies
all intensity values in <code>x</code> with <code>y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ir_multiply(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ir_multiply_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+ir_new_ir">ir</a></code>.</p>
</td></tr>
<tr><td><code id="ir_multiply_+3A_y">y</code></td>
<td>
<p>An object of class <code><a href="#topic+ir_new_ir">ir</a></code> or a numeic value. If <code>y</code>
is an object of class <code>ir</code>, it must have the same number of rows as
<code>x</code> and the same x axis values (e.g. wavenumber values) in each matching
spectrum as in <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> where for each spectrum intensity values are multiplied with
the respective intensity values in <code>y</code> (if <code>y</code> is an object of
class <code>ir</code>), or where all intensity values are multiplied with <code>y</code>
if <code>y</code> is a numeric value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># multiplication with y as ir object
x1 &lt;-
  ir::ir_multiply(ir::ir_sample_data, ir::ir_sample_data)
x1 &lt;-
  ir::ir_multiply(ir::ir_sample_data, ir::ir_sample_data[1, ])

# multiplication with y being a numeric value
x2 &lt;-
  ir::ir_multiply(ir::ir_sample_data, y = -1)

</code></pre>

<hr>
<h2 id='ir_new_ir'>Creates an object of class <code>ir</code></h2><span id='topic+ir_new_ir'></span>

<h3>Description</h3>

<p><code>ir_new_ir</code> is the constructor function for objects of class
<code>ir</code>.
An object of class <code>ir</code> is a <code><a href="tibble.html#topic+tbl_df-class">tibble::tbl_df()</a></code> with a
sample in each row and a list column containing spectra for each sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ir_new_ir(spectra, metadata = tibble::tibble())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ir_new_ir_+3A_spectra">spectra</code></td>
<td>
<p>A named list in which each element contains spectral data
for one measurement. Each list element must be a <code>data.frame</code> with two
columns and a row for each wavenumber value in the spectra data. The first
column must contain unique wavenumber values and the second column intensity
values of the measured spectrum of the sample.</p>
</td></tr>
<tr><td><code id="ir_new_ir_+3A_metadata">metadata</code></td>
<td>
<p>An optional <code>data.frame</code> with additional
columns containing metadata for the spectra in <code>spectra</code>. Optionally, an
empty <code>data.frame</code> can be defined if no metadata are available.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>ir</code> with the following columns:
</p>

<dl>
<dt>spectra</dt><dd><p>A list column identical to <code>spectra</code>.</p>
</dd>
<dt>...</dt><dd><p>Additional columns contained in <code>metadata</code>.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>ir_new_ir(
  spectra = ir_sample_data$spectra,
  metadata = ir_sample_data %&gt;% dplyr::select(-spectra)
)

</code></pre>

<hr>
<h2 id='ir_new_ir_flat'>Creates an object of class <code>ir_flat</code></h2><span id='topic+ir_new_ir_flat'></span>

<h3>Description</h3>

<p><code>ir_new_ir_flat</code> is the constructor function for objects of class <code>ir_flat</code>.
An object of class <code>ir_flat</code> is a <code>data.frame</code> where the first
column (<code>"x"</code>) contains unique x values of spectra (e.g. wavenumbers)
and all remaining columns represent intensity values from spectra
corresponding to the x values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ir_new_ir_flat(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ir_new_ir_flat_+3A_x">x</code></td>
<td>
<p>A <code>data.frame</code> with only numeric columns and only the first
column name being &quot;x&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>ir_flat</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x_flat &lt;-
   ir::ir_sample_data %&gt;%
   ir::ir_flatten()

</code></pre>

<hr>
<h2 id='ir_normalize'>Normalizes infrared spectra in an <code>ir</code> object</h2><span id='topic+ir_normalize'></span><span id='topic+ir_normalise'></span>

<h3>Description</h3>

<p><code>ir_normalize</code> normalizes the intensity values of infrared spectra.
Spectra can be normalized in three ways (value for argument <code>method</code>):
</p>

<dl>
<dt>&quot;zeroone&quot;</dt><dd><p>Normalization so that the intensity values range in [0;1].
Note that for different spectra, for different wavenumber values the
intensity may be 1 after normalization, depending on the location of the
peak with the maximum height.</p>
</dd>
<dt>&quot;area&quot;</dt><dd><p>Normalization so that the intensity values of each spectrum
sum to 1. Note that in the case of negative intensities values, these will
be count as negative values during summation.</p>
</dd>
<dt>A numeric value</dt><dd><p>Normalization so that the intensity at a specified
wavenumber value has value 1 and the minimum intensity value is 0.</p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>ir_normalize(x, method = "area")

ir_normalise(x, method = "area")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ir_normalize_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+ir_new_ir">ir</a></code>.</p>
</td></tr>
<tr><td><code id="ir_normalize_+3A_method">method</code></td>
<td>
<p>A character value specifying which normalization method to
apply. If <code>method = "zeroone"</code>, all intensity values will be normalized
to [0;1]. If <code>method = "area"</code>, all intensity values will be divided by
the sum of the intensity values at all wavenumber values of the spectrum. If
<code>method</code> is convertible to a numeric value, e.g. <code>method = "980"</code>,
the intensity of all spectra at a wavenumber value of 980 will be set to 1
and the minimum intensity value of each spectrum will be set to 0, i.e. the
spectra will be normalized referring to a specific wavenumber value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>ir</code> representing a normalized version of
<code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># with method = "area"
x &lt;-
   ir::ir_sample_data %&gt;%
   ir::ir_normalize(method = "area")

# normalizing to a specific peak
x &lt;-
   ir::ir_sample_data %&gt;%
   ir::ir_normalize(method = 1090)

</code></pre>

<hr>
<h2 id='ir_remove_missing'>Removes empty data values in an object of class <code>ir</code></h2><span id='topic+ir_remove_missing'></span>

<h3>Description</h3>

<p><code>ir_remove_missing</code> takes and object of class <code>ir</code> and removes all
rows in the <code>data.frame</code>s of the list column <code>spectra</code> that have
<code>NA</code> intensity values (column <code>y</code>). Additionally, one can specify
to remove rows in the <code>ir</code> object to discard if they contain empty
spectra.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ir_remove_missing(x, remove_rows = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ir_remove_missing_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+ir_new_ir">ir</a></code>.</p>
</td></tr>
<tr><td><code id="ir_remove_missing_+3A_remove_rows">remove_rows</code></td>
<td>
<p>A logical value indicating if rows in <code>x</code> with empty
spectra should be discarded (<code>remove_rows = TRUE</code>) or not
(<code>remove_rows = FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> with cleaned spectra.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create sample data with some missing rows and one entire missing spectra
x &lt;-
   ir::ir_sample_data
x$spectra[[1]] &lt;- x$spectra[[1]][0, ]
x$spectra[[2]][1:100, "y"] &lt;- NA_real_

# remove missing values (but remove no rows in x)
x1 &lt;-
   x %&gt;%
   ir::ir_remove_missing(remove_rows = FALSE)

# remove missing values (and remove rows in x if a compete spectrum is
# missing)
x2 &lt;-
   x %&gt;%
   ir::ir_remove_missing(remove_rows = TRUE)

nrow(x)
nrow(x1)
nrow(x2)

</code></pre>

<hr>
<h2 id='ir_sample_data'>Sample object of class <code>ir</code></h2><span id='topic+ir_sample_data'></span>

<h3>Description</h3>

<p>A sample object of class <code><a href="#topic+ir_new_ir">ir</a></code>. The data set
contains ATR-MIR spectra for a set of organic reference materials
along with their metadata (types of samples and a description) and
accessory data (Klason lignin mass fraction and holocellulose mass fraction).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ir_sample_data
</code></pre>


<h3>Format</h3>

<p>A data frame with 58 rows and 7 variables:
</p>

<dl>
<dt>id_measurement</dt><dd><p>An integer vector with a unique id for each
spectrum.</p>
</dd>
<dt>id_sample</dt><dd><p>A character vector with a unique id for each sample.</p>
</dd>
<dt>sample_type</dt><dd><p>A character vector containing class labels
for the types of reference materials.</p>
</dd>
<dt>sample_comment</dt><dd><p>A character vector containing comments to
each sample.</p>
</dd>
<dt>klason_lignin</dt><dd><p>A numeric vector with the mass fractions of
Klason lignin in each sample.</p>
</dd>
<dt>holocellulose</dt><dd><p>A numeric vector with the mass fractions of
holocellulose in each sample.</p>
</dd>
<dt>spectra</dt><dd><p>See <code><a href="#topic+ir_new_ir">ir_new_ir()</a></code>.</p>
</dd>
</dl>



<h3>Source</h3>

<p>The data set was derived from <a href="https://www.nature.com/articles/s41467-018-06050-2">https://www.nature.com/articles/s41467-018-06050-2</a>
and published by Hodgkins et al. (2018) under the CC BY 4.0 license <a href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</a>.
Hodgkins et al. (2018) originally derived the data on Klason Lignin and Holocellulose content from
De La Cruz, Florentino B. et al. (2016).
</p>


<h3>References</h3>

<p>De La Cruz, Florentino B., Osborne J, Barlaz MA (2016).
&ldquo;Determination of Sources of Organic Matter in Solid Waste by Analysis of Phenolic Copper Oxide Oxidation Products of Lignin.&rdquo;
<em>Journal of Environmental Engineering</em>, <b>142</b>(2), 04015076.
ISSN 0733-9372, <a href="https://doi.org/10.1061/%28ASCE%29EE.1943-7870.0001038">doi:10.1061/(ASCE)EE.1943-7870.0001038</a>.<br /><br /> Hodgkins SB, Richardson CJ, Dommain R, Wang H, Glaser PH, Verbeke B, Winkler BR, Cobb AR, Rich VI, Missilmani M, Flanagan N, Ho M, Hoyt AM, Harvey CF, Vining SR, Hough MA, Moore TR, Richard PJH, De La Cruz, Florentino B., Toufaily J, Hamdan R, Cooper WT, Chanton JP (2018).
&ldquo;Tropical peatland carbon storage linked to global latitudinal trends in peat recalcitrance.&rdquo;
<em>Nature communications</em>, <b>9</b>(1), 3640.
<a href="https://doi.org/10.1038/s41467-018-06050-2">doi:10.1038/s41467-018-06050-2</a>.
</p>

<hr>
<h2 id='ir_smooth'>Smooths infrared spectra in an <code>ir</code> object</h2><span id='topic+ir_smooth'></span>

<h3>Description</h3>

<p><code>ir_smooth</code> applies smoothing functions to infrared spectra.
<code>ir_smooth</code> either performs Savitzky-Golay smoothing, using on
<code><a href="signal.html#topic+sgolayfilt">signal::sgolayfilt()</a></code>, or Fourier smoothing using
<code><a href="fda.html#topic+smooth.basis">fda::smooth.basis()</a></code>. Savitzky-Golay smoothing can
also be used to compute derivatives of spectra.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ir_smooth(
  x,
  method = "sg",
  p = 3,
  n = p + 3 - p%%2,
  ts = 1,
  m = 0,
  k = 111,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ir_smooth_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+ir_new_ir">ir</a></code>.</p>
</td></tr>
<tr><td><code id="ir_smooth_+3A_method">method</code></td>
<td>
<p>A character value specifying which smoothing method to apply.
If <code>method = "sg"</code>, a Savitzky-Golay filter will be applied on the
spectra. The Savitzky-Golay smoothing will be performed using the function
<code><a href="signal.html#topic+sgolayfilt">signal::sgolayfilt()</a></code>. If <code>method = "fourier"</code>,
Fourier smoothing will be performed. Fourier transformation of the spectra is
performed using the fast discrete Fourier transformation (FFT) as implemented
in <code><a href="fda.html#topic+smooth.basis">fda::smooth.basis()</a></code>. A smoothing function can be
defined by the argment <code>f</code>.</p>
</td></tr>
<tr><td><code id="ir_smooth_+3A_p">p</code></td>
<td>
<p>An integer value representing the filter order (i.e. the degree of
the polynom) of the Savitzky-Golay filter if <code>method = "sg"</code>.</p>
</td></tr>
<tr><td><code id="ir_smooth_+3A_n">n</code></td>
<td>
<p>An odd integer value representing the length (i.e. the number of
wavenumber values used to construct the polynom) of the Savitzky-Golay filter
if <code>method = "sg"</code>.</p>
</td></tr>
<tr><td><code id="ir_smooth_+3A_ts">ts</code></td>
<td>
<p>time scaling factor. See <code><a href="signal.html#topic+sgolayfilt">signal::sgolayfilt()</a></code>.</p>
</td></tr>
<tr><td><code id="ir_smooth_+3A_m">m</code></td>
<td>
<p>An integer value representing the mth derivative to compute. This
option can be used to compute derivatives of spectra. See
<code><a href="signal.html#topic+sgolayfilt">signal::sgolayfilt()</a></code>.</p>
</td></tr>
<tr><td><code id="ir_smooth_+3A_k">k</code></td>
<td>
<p>A positive odd integer representing the number of Fourier basis
functions to use as smoothed representation of the spectra if
<code>method = "fourier"</code>.</p>
</td></tr>
<tr><td><code id="ir_smooth_+3A_...">...</code></td>
<td>
<p>additional arguments (ignored).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>x</code> contains spectra with different wavenumber values, the
filters are applied for each spectra only on existing wavenumber values. This
means that the filter window (if <code>method == "sg"</code>) will be different for
these different spectra.
</p>


<h3>Value</h3>

<p><code>x</code> with smoothed spectra.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#' # Savitzky-Golay smoothing
x1 &lt;-
   ir::ir_sample_data[1:5, ] %&gt;%
   ir::ir_smooth(method = "sg", p = 3, n = 51, ts = 1, m = 0)

# Fourier smoothing
x2 &lt;-
   ir::ir_sample_data[1:5, ] %&gt;%
   ir::ir_smooth(method = "fourier", k = 21)

# computing derivative spectra with Savitzky-Golay smoothing (here: first
# derivative)
x3 &lt;-
   ir::ir_sample_data[1:5, ] %&gt;%
   ir::ir_smooth(method = "sg", p = 3, n = 51, ts = 1, m = 1)

</code></pre>

<hr>
<h2 id='ir_stack'>Stacks a matrix or data frame with spectra into a list column</h2><span id='topic+ir_stack'></span>

<h3>Description</h3>

<p><code>ir_stack</code> takes a matrix or data frame with infrared spectra and
converts it into a  list column corresponding to the column <code>spectra</code> in
objects of class <code>ir</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ir_stack(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ir_stack_+3A_x">x</code></td>
<td>
<p>A matrix or data frame with a first column (<code>x</code>) containing &quot;x
axis values&quot; of the spectra (e.g. wavenumbers) and all remaining columns
containing intensity values of spectra.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with the stacked spectra in column <code>spectra</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># from data frame
x1 &lt;-
   ir::ir_sample_data %&gt;%
   ir::ir_flatten() %&gt;%
   ir::ir_stack()

# from matrix
x2 &lt;-
   ir::ir_sample_data %&gt;%
   ir::ir_flatten() %&gt;%
   as.matrix() %&gt;%
   ir::ir_stack()

</code></pre>

<hr>
<h2 id='ir_subtract'>Subtract infrared spectra</h2><span id='topic+ir_subtract'></span>

<h3>Description</h3>

<p><code>ir_subtract</code> takes two objects of class <code>ir</code>, <code>x</code> and
<code>y</code>, and subtracts the intensity values of spectra in matching rows from
<code>y</code> from that of <code>x</code>. Alternatively, takes an object of class
<code>ir</code>, <code>x</code>, and a numeric value, <code>y</code>, and subtracts <code>y</code>
from all intensity values in <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ir_subtract(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ir_subtract_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+ir_new_ir">ir</a></code>.</p>
</td></tr>
<tr><td><code id="ir_subtract_+3A_y">y</code></td>
<td>
<p>An object of class <code><a href="#topic+ir_new_ir">ir</a></code> or a numeic value. If <code>y</code>
is an object of class <code>ir</code>, it must have the same number of rows as
<code>x</code> and the same x axis values (e.g. wavenumber values) in each matching
spectrum as in <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> where for each spectrum the respective intensity values in
<code>y</code> are subtracted (if <code>y</code> is an object of class <code>ir</code>), or
where for each spectrum <code>y</code> has been subtracted from the intensity
values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># subtracting two objects of class ir
x1 &lt;-
  ir::ir_subtract(ir::ir_sample_data, ir::ir_sample_data)
x1 &lt;-
  ir::ir_subtract(ir::ir_sample_data, ir::ir_sample_data[1, ])

# subtracting a numeric value from an object of class `ir`.
x2 &lt;-
  ir::ir_subtract(ir::ir_sample_data, 20)

</code></pre>

<hr>
<h2 id='ir_to_transmittance'>Converts absorbance spectra to transmittance spectra or vice versa</h2><span id='topic+ir_to_transmittance'></span><span id='topic+ir_to_absorbance'></span>

<h3>Description</h3>

<p><code>ir_to_transmittance</code> converts absorbance spectra to transmittance
spectra. <code>ir_to_absorbance</code> converts transmittance spectra to absorbance
spectra. Note that neither function checks whether the input spectra are
absorbance or transmittance spectra.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ir_to_transmittance(x)

ir_to_absorbance(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ir_to_transmittance_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+ir_new_ir">ir</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> with y values fore each spectrum as transmittance values
(in case of <code>ir_to_transmittance</code>) or absorbance values (in case of
<code>ir_to_absorbance</code>).
</p>


<h3>Source</h3>

<p>(Stuart 2004).
</p>


<h3>References</h3>

<p>Stuart BH (2004).
<em>Infrared Spectroscopy: Fundamentals and Applications: Stuart/Infrared Spectroscopy: Fundamentals and Applications</em>,  Analytical Techniques in the Sciences.
John Wiley \&amp; Sons, Ltd, Chichester, UK.
ISBN 978-0-470-01114-0 978-0-470-85428-0, <a href="https://doi.org/10.1002/0470011149">doi:10.1002/0470011149</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># convert from absorbance to transmittance
x1 &lt;-
    ir_sample_data %&gt;%
    ir_to_transmittance()

# convert from transmittance to absorbance
x2 &lt;-
    x1 %&gt;%
    ir::ir_to_absorbance()

vapply(
  seq_along(x2$spectra),
  FUN = function(i) all.equal(x2$spectra[[i]], ir::ir_sample_data$spectra[[i]]),
  FUN.VALUE = logical(1L)
) %&gt;%
  all()

</code></pre>

<hr>
<h2 id='ir_variance_region'>Computes the variance of a spectrum in an <code>ir</code> object in a given region</h2><span id='topic+ir_variance_region'></span>

<h3>Description</h3>

<p><code>ir_variance_region</code> takes a spectrum <code>x</code> and, depending on the
arguments computes the following summary:
</p>

<dl>
<dt>if <code>subtract_smoothed = FALSE</code></dt><dd><p>it computes the variance of the
intensity values for each spectrum in <code>x</code>. If in addition <code>range</code>
is not <code>NULL</code>, it computes the variance only for the region(s)
represented by <code>range</code>.</p>
</dd>
<dt>if <code>subtract_smoothed = TRUE</code></dt><dd><p>it smoothes <code>x</code>, subtracts
the smoothed <code>x</code> from the unsmoothed <code>x</code> and computes the
variance of the difference intensity values. If in addition <code>range</code> is
not <code>NULL</code>, it computes the variance only for the region(s)
represented by <code>range</code>.</p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>ir_variance_region(
  x,
  subtract_smoothed = FALSE,
  do_normalize = FALSE,
  normalize_method,
  ...,
  range = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ir_variance_region_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+ir_new_ir">ir</a></code>. These are the spectra for
which to compute the variance.</p>
</td></tr>
<tr><td><code id="ir_variance_region_+3A_subtract_smoothed">subtract_smoothed</code></td>
<td>
<p>A logical value. If <code>subtract_smoothed = TRUE</code>,
<code>x</code> is copied, the copy smoothed using <code>ir_smooth</code> with
<code>method = "sg"</code> and subtracted from <code>x</code> before the variance of the
intensity values from <code>x</code> is computed. This allows e.g. to estimate the
noise level in a specific region of spectra. If
<code>subtract_smoothed = FALSE</code> (the default), nothing is subtracted from
<code>x</code> before computing the variance of the intensity values.</p>
</td></tr>
<tr><td><code id="ir_variance_region_+3A_do_normalize">do_normalize</code></td>
<td>
<p>A logical value. If set to <code>TRUE</code>, the spectra in
<code>x</code> are normalized after subtraction of a smoothed version, else no
normalization is performed.</p>
</td></tr>
<tr><td><code id="ir_variance_region_+3A_normalize_method">normalize_method</code></td>
<td>
<p>See <code><a href="#topic+ir_normalize">ir_normalize()</a></code>.</p>
</td></tr>
<tr><td><code id="ir_variance_region_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+ir_smooth">ir_smooth()</a></code> (except for
<code>method</code> which is always set to <code>"sg"</code> if <code>subtract_smoothed</code> is
<code>TRUE</code>). If <code>subtract_smoothed = FALSE</code>, these arguments will be
ignored.</p>
</td></tr>
<tr><td><code id="ir_variance_region_+3A_range">range</code></td>
<td>
<p>See <code><a href="#topic+ir_clip">ir_clip()</a></code>. This is the range for which the
variance of the intensity values will be computed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> with two additional columns:
</p>

<dl>
<dt>variance</dt><dd><p>A numeric vector with the computed variances of the
intensity values for the respective spectra.</p>
</dd>
<dt>n_variance</dt><dd><p>An integer vector with the number of intensity values
used during computing the variance.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># Whole spectra variance
x1 &lt;-
   ir::ir_sample_data %&gt;%
   ir::ir_variance_region(
      subtract_smoothed = FALSE,
      do_normalize = TRUE,
      normalize_method = "area",
      range = NULL
   )

# Spectra variance, but only from a specific region
range &lt;- data.frame(start = 2700, end = 2800)

x2 &lt;-
   ir::ir_sample_data %&gt;%
   ir::ir_normalize(method = "area") %&gt;%
   ir::ir_variance_region(
      subtract_smoothed = FALSE,
      do_normalize = TRUE,
      normalize_method = "area",
      range = range
   )

# Spectra variance after subtracting a smoothed version of the spectra and
# only from a specific region
x3 &lt;-
   ir::ir_sample_data %&gt;%
   ir::ir_variance_region(
      subtract_smoothed = TRUE,
      do_normalize = FALSE,
      range = range,
      p = 3, n = 31, ts = 1, m = 0
   )

</code></pre>

<hr>
<h2 id='mutate'>Mutate an <code>ir</code> object by adding new or replacing existing columns</h2><span id='topic+mutate'></span><span id='topic+mutate.ir'></span><span id='topic+transmute.ir'></span>

<h3>Description</h3>

<p>Mutate an <code>ir</code> object by adding new or replacing existing columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutate.ir(
  .data,
  ...,
  .keep = c("all", "used", "unused", "none"),
  .before = NULL,
  .after = NULL
)

transmute.ir(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutate_+3A_.data">.data</code></td>
<td>
<p>An object of class <code>ir</code>.</p>
</td></tr>
<tr><td><code id="mutate_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_data_masking">data-masking</a></code>&gt; Name-value pairs.
The name gives the name of the column in the output.
</p>
<p>The value can be:
</p>

<ul>
<li><p> A vector of length 1, which will be recycled to the correct length.
</p>
</li>
<li><p> A vector the same length as the current group (or the whole data frame
if ungrouped).
</p>
</li>
<li> <p><code>NULL</code>, to remove the column.
</p>
</li>
<li><p> A data frame or tibble, to create multiple columns in the output.
</p>
</li></ul>
</td></tr>
<tr><td><code id="mutate_+3A_.keep">.keep</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
Control which columns from <code>.data</code> are retained in the output. Grouping
columns and columns created by <code>...</code> are always kept.
</p>

<ul>
<li> <p><code>"all"</code> retains all columns from <code>.data</code>. This is the default.
</p>
</li>
<li> <p><code>"used"</code> retains only the columns used in <code>...</code> to create new
columns. This is useful for checking your work, as it displays inputs
and outputs side-by-side.
</p>
</li>
<li> <p><code>"unused"</code> retains only the columns <em>not</em> used in <code>...</code> to create new
columns. This is useful if you generate new columns, but no longer need
the columns used to generate them.
</p>
</li>
<li> <p><code>"none"</code> doesn't retain any extra columns from <code>.data</code>. Only the grouping
variables and columns created by <code>...</code> are kept.
</p>
</li></ul>
</td></tr>
<tr><td><code id="mutate_+3A_.before">.before</code>, <code id="mutate_+3A_.after">.after</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Optionally, control where new columns
should appear (the default is to add to the right hand side). See
<code><a href="dplyr.html#topic+relocate">relocate()</a></code> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>.data</code> with modified columns. If the <code>spectra</code> column is dropped or
invalidated (see <code><a href="#topic+ir_new_ir">ir_new_ir()</a></code>), the <code>ir</code> class is dropped, else the object
is of class <code>ir</code>.
</p>


<h3>Source</h3>

<p><code><a href="dplyr.html#topic+mutate">dplyr::mutate()</a></code>
</p>


<h3>See Also</h3>

<p>Other tidyverse: 
<code><a href="#topic+arrange.ir">arrange.ir</a>()</code>,
<code><a href="#topic+distinct.ir">distinct.ir</a>()</code>,
<code><a href="#topic+extract.ir">extract.ir</a>()</code>,
<code><a href="#topic+filter-joins">filter-joins</a></code>,
<code><a href="#topic+filter.ir">filter.ir</a>()</code>,
<code><a href="#topic+group_by">group_by</a></code>,
<code><a href="#topic+mutate-joins">mutate-joins</a></code>,
<code><a href="#topic+nest">nest</a></code>,
<code><a href="#topic+pivot_longer.ir">pivot_longer.ir</a>()</code>,
<code><a href="#topic+pivot_wider.ir">pivot_wider.ir</a>()</code>,
<code><a href="#topic+rename">rename</a></code>,
<code><a href="#topic+rowwise.ir">rowwise.ir</a>()</code>,
<code><a href="#topic+select.ir">select.ir</a>()</code>,
<code><a href="#topic+separate.ir">separate.ir</a>()</code>,
<code><a href="#topic+separate_rows.ir">separate_rows.ir</a>()</code>,
<code><a href="#topic+slice">slice</a></code>,
<code><a href="#topic+summarize">summarize</a></code>,
<code><a href="#topic+unite.ir">unite.ir</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## mutate
dplyr::mutate(ir_sample_data, hkl = klason_lignin + holocellulose)


## transmute
dplyr::transmute(ir_sample_data, hkl = klason_lignin + holocellulose)


</code></pre>

<hr>
<h2 id='mutate-joins'>Mutating joins for an <code>ir</code> object</h2><span id='topic+mutate-joins'></span><span id='topic+inner_join.ir'></span><span id='topic+left_join.ir'></span><span id='topic+right_join.ir'></span><span id='topic+full_join.ir'></span>

<h3>Description</h3>

<p>Mutating joins for an <code>ir</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inner_join.ir(
  x,
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  keep = FALSE,
  na_matches = c("na", "never")
)

left_join.ir(
  x,
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  keep = FALSE,
  na_matches = c("na", "never")
)

right_join.ir(
  x,
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  keep = FALSE,
  na_matches = c("na", "never")
)

full_join.ir(
  x,
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  keep = FALSE,
  na_matches = c("na", "never")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutate-joins_+3A_x">x</code></td>
<td>
<p>An object of class <code>ir</code>.</p>
</td></tr>
<tr><td><code id="mutate-joins_+3A_y">y</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="mutate-joins_+3A_by">by</code></td>
<td>
<p>A character vector of variables to join by.
</p>
<p>If <code>NULL</code>, the default, <code style="white-space: pre;">&#8288;*_join()&#8288;</code> will perform a natural join, using all
variables in common across <code>x</code> and <code>y</code>. A message lists the variables so that you
can check they're correct; suppress the message by supplying <code>by</code> explicitly.
</p>
<p>To join by different variables on <code>x</code> and <code>y</code>, use a named vector.
For example, <code>by = c("a" = "b")</code> will match <code>x$a</code> to <code>y$b</code>.
</p>
<p>To join by multiple variables, use a vector with length &gt; 1.
For example, <code>by = c("a", "b")</code> will match <code>x$a</code> to <code>y$a</code> and <code>x$b</code> to
<code>y$b</code>. Use a named vector to match different variables in <code>x</code> and <code>y</code>.
For example, <code>by = c("a" = "b", "c" = "d")</code> will match <code>x$a</code> to <code>y$b</code> and
<code>x$c</code> to <code>y$d</code>.
</p>
<p>To perform a cross-join, generating all combinations of <code>x</code> and <code>y</code>,
use <code>by = character()</code>.</p>
</td></tr>
<tr><td><code id="mutate-joins_+3A_copy">copy</code></td>
<td>
<p>If <code>x</code> and <code>y</code> are not from the same data source,
and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the
same src as <code>x</code>.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.</p>
</td></tr>
<tr><td><code id="mutate-joins_+3A_suffix">suffix</code></td>
<td>
<p>If there are non-joined duplicate variables in <code>x</code> and
<code>y</code>, these suffixes will be added to the output to disambiguate them.
Should be a character vector of length 2.</p>
</td></tr>
<tr><td><code id="mutate-joins_+3A_...">...</code></td>
<td>
<p>Other parameters passed onto methods.</p>
</td></tr>
<tr><td><code id="mutate-joins_+3A_keep">keep</code></td>
<td>
<p>Should the join keys from both <code>x</code> and <code>y</code> be preserved in the
output?</p>
</td></tr>
<tr><td><code id="mutate-joins_+3A_na_matches">na_matches</code></td>
<td>
<p>Should <code>NA</code> and <code>NaN</code> values match one another?
</p>
<p>The default, <code>"na"</code>, treats two <code>NA</code> or <code>NaN</code> values as equal, like
<code>%in%</code>, <code><a href="base.html#topic+match">match()</a></code>, <code><a href="base.html#topic+merge">merge()</a></code>.
</p>
<p>Use <code>"never"</code> to always treat two <code>NA</code> or <code>NaN</code> values as different, like
joins for database sources, similarly to <code>merge(incomparables = FALSE)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> and <code>y</code> joined. If the <code>spectra</code> column is renamed, the <code>ir</code>
class is dropped. See <code><a href="dplyr.html#topic+mutate-joins">mutate-joins</a></code>.
</p>


<h3>Source</h3>

<p><code><a href="dplyr.html#topic+mutate-joins">mutate-joins</a></code>
</p>


<h3>See Also</h3>

<p>Other tidyverse: 
<code><a href="#topic+arrange.ir">arrange.ir</a>()</code>,
<code><a href="#topic+distinct.ir">distinct.ir</a>()</code>,
<code><a href="#topic+extract.ir">extract.ir</a>()</code>,
<code><a href="#topic+filter-joins">filter-joins</a></code>,
<code><a href="#topic+filter.ir">filter.ir</a>()</code>,
<code><a href="#topic+group_by">group_by</a></code>,
<code><a href="#topic+mutate">mutate</a></code>,
<code><a href="#topic+nest">nest</a></code>,
<code><a href="#topic+pivot_longer.ir">pivot_longer.ir</a>()</code>,
<code><a href="#topic+pivot_wider.ir">pivot_wider.ir</a>()</code>,
<code><a href="#topic+rename">rename</a></code>,
<code><a href="#topic+rowwise.ir">rowwise.ir</a>()</code>,
<code><a href="#topic+select.ir">select.ir</a>()</code>,
<code><a href="#topic+separate.ir">separate.ir</a>()</code>,
<code><a href="#topic+separate_rows.ir">separate_rows.ir</a>()</code>,
<code><a href="#topic+slice">slice</a></code>,
<code><a href="#topic+summarize">summarize</a></code>,
<code><a href="#topic+unite.ir">unite.ir</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## inner_join
set.seed(234)
dplyr::inner_join(
  ir_sample_data,
  tibble::tibble(
    id_measurement = c(1:5, 101:105),
    nitrogen_content = rbeta(n = 10, 0.2, 0.1)
  ),
  by = "id_measurement"
)


## left_join
set.seed(234)
dplyr::left_join(
  ir_sample_data,
  tibble::tibble(
    id_measurement = c(1:5, 101:105),
    nitrogen_content = rbeta(n = 10, 0.2, 0.1)
  ),
  by = "id_measurement"
)


## right_join
set.seed(234)
dplyr::right_join(
  ir_sample_data,
  tibble::tibble(
    id_measurement = c(1:5, 101:105),
    nitrogen_content = rbeta(n = 10, 0.2, 0.1)
  ),
  by = "id_measurement"
)


## full_join
set.seed(234)
dplyr::full_join(
  ir_sample_data,
  tibble::tibble(
    id_measurement = c(1:5, 101:105),
    nitrogen_content = rbeta(n = 10, 0.2, 0.1)
  ),
  by = "id_measurement"
)


</code></pre>

<hr>
<h2 id='nest'>Nest and un-nest an <code>ir</code> object</h2><span id='topic+nest'></span><span id='topic+nest.ir'></span><span id='topic+unnest.ir'></span>

<h3>Description</h3>

<p>Nest and un-nest an <code>ir</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nest.ir(.data, ..., .names_sep = NULL, .key = deprecated())

unnest.ir(
  data,
  cols,
  ...,
  keep_empty = FALSE,
  ptype = NULL,
  names_sep = NULL,
  names_repair = "check_unique",
  .drop = deprecated(),
  .id = deprecated(),
  .sep = deprecated(),
  .preserve = deprecated()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nest_+3A_.data">.data</code></td>
<td>
<p>An object of class <code>ir</code>.</p>
</td></tr>
<tr><td><code id="nest_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; Columns to nest, specified
using name-variable pairs of the form <code>new_col = c(col1, col2, col3)</code>.
The right hand side can be any valid tidy select expression.
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>:
previously you could write <code>df %&gt;% nest(x, y, z)</code> and <code>df %&gt;% unnest(x, y, z)</code>. Convert to <code>df %&gt;% nest(data = c(x, y, z))</code>.
and <code>df %&gt;% unnest(c(x, y, z))</code>.
</p>
<p>If you previously created new variable in <code>unnest()</code> you'll now need to
do it explicitly with <code>mutate()</code>. Convert <code>df %&gt;% unnest(y = fun(x, y, z))</code>
to <code>df %&gt;% mutate(y = fun(x, y, z)) %&gt;% unnest(y)</code>.</p>
</td></tr>
<tr><td><code id="nest_+3A_.key">.key</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>:
No longer needed because of the new <code>new_col = c(col1, col2, col3)</code> syntax.</p>
</td></tr>
<tr><td><code id="nest_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="nest_+3A_cols">cols</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; Columns to unnest.
</p>
<p>If you <code>unnest()</code> multiple columns, parallel entries must be of
compatible sizes, i.e. they're either equal or length 1 (following the
standard tidyverse recycling rules).</p>
</td></tr>
<tr><td><code id="nest_+3A_keep_empty">keep_empty</code></td>
<td>
<p>By default, you get one row of output for each element
of the list your unchopping/unnesting. This means that if there's a
size-0 element (like <code>NULL</code> or an empty data frame), that entire row
will be dropped from the output. If you want to preserve all rows,
use <code>keep_empty = TRUE</code> to replace size-0 elements with a single row
of missing values.</p>
</td></tr>
<tr><td><code id="nest_+3A_ptype">ptype</code></td>
<td>
<p>Optionally, a named list of column name-prototype pairs to
coerce <code>cols</code> to, overriding the default that will be guessed from
combining the individual values. Alternatively, a single empty ptype
can be supplied, which will be applied to all <code>cols</code>.</p>
</td></tr>
<tr><td><code id="nest_+3A_names_sep">names_sep</code>, <code id="nest_+3A_.names_sep">.names_sep</code></td>
<td>
<p>If <code>NULL</code>, the default, the names will be left
as is. In <code>nest()</code>, inner names will come from the former outer names;
in <code>unnest()</code>, the new outer names will come from the inner names.
</p>
<p>If a string, the inner and outer names will be used together. In
<code>unnest()</code>, the names of the new outer columns will be formed by pasting
together the outer and the inner column names, separated by <code>names_sep</code>. In
<code>nest()</code>, the new inner names will have the outer names + <code>names_sep</code>
automatically stripped. This makes <code>names_sep</code> roughly symmetric between
nesting and unnesting.</p>
</td></tr>
<tr><td><code id="nest_+3A_names_repair">names_repair</code></td>
<td>
<p>Used to check that output data frame has valid
names. Must be one of the following options:
</p>

<ul>
<li><p> &quot;minimal&quot;: no name repair or checks, beyond basic existence,
</p>
</li>
<li><p> &quot;unique&quot;: make sure names are unique and not empty,
</p>
</li>
<li><p> &quot;check_unique&quot;: (the default), no name repair, but check they are unique,
</p>
</li>
<li><p> &quot;universal&quot;: make the names unique and syntactic
</p>
</li>
<li><p> a function: apply custom name repair.
</p>
</li>
<li> <p><a href="tidyr.html#topic+tidyr_legacy">tidyr_legacy</a>: use the name repair from tidyr 0.8.
</p>
</li>
<li><p> a formula: a purrr-style anonymous function (see <code><a href="rlang.html#topic+as_function">rlang::as_function()</a></code>)
</p>
</li></ul>

<p>See <code><a href="vctrs.html#topic+vec_as_names">vctrs::vec_as_names()</a></code> for more details on these terms and the
strategies used to enforce them.</p>
</td></tr>
<tr><td><code id="nest_+3A_.drop">.drop</code>, <code id="nest_+3A_.preserve">.preserve</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>:
all list-columns are now preserved; If there are any that you
don't want in the output use <code>select()</code> to remove them prior to
unnesting.</p>
</td></tr>
<tr><td><code id="nest_+3A_.id">.id</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>:
convert <code>df %&gt;% unnest(x, .id = "id")</code> to <code style="white-space: pre;">&#8288;df %&gt;% mutate(id = names(x)) %&gt;% unnest(x))&#8288;</code>.</p>
</td></tr>
<tr><td><code id="nest_+3A_.sep">.sep</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>:
use <code>names_sep</code> instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>.data</code> with nested or unnested columns. If the <code>spectra</code> column is
dropped or invalidated (see <code><a href="#topic+ir_new_ir">ir_new_ir()</a></code>), the <code>ir</code> class is dropped, else
the object is of class <code>ir</code>.
</p>


<h3>Source</h3>

<p><code><a href="tidyr.html#topic+nest">tidyr::nest()</a></code>
</p>


<h3>See Also</h3>

<p>Other tidyverse: 
<code><a href="#topic+arrange.ir">arrange.ir</a>()</code>,
<code><a href="#topic+distinct.ir">distinct.ir</a>()</code>,
<code><a href="#topic+extract.ir">extract.ir</a>()</code>,
<code><a href="#topic+filter-joins">filter-joins</a></code>,
<code><a href="#topic+filter.ir">filter.ir</a>()</code>,
<code><a href="#topic+group_by">group_by</a></code>,
<code><a href="#topic+mutate-joins">mutate-joins</a></code>,
<code><a href="#topic+mutate">mutate</a></code>,
<code><a href="#topic+pivot_longer.ir">pivot_longer.ir</a>()</code>,
<code><a href="#topic+pivot_wider.ir">pivot_wider.ir</a>()</code>,
<code><a href="#topic+rename">rename</a></code>,
<code><a href="#topic+rowwise.ir">rowwise.ir</a>()</code>,
<code><a href="#topic+select.ir">select.ir</a>()</code>,
<code><a href="#topic+separate.ir">separate.ir</a>()</code>,
<code><a href="#topic+separate_rows.ir">separate_rows.ir</a>()</code>,
<code><a href="#topic+slice">slice</a></code>,
<code><a href="#topic+summarize">summarize</a></code>,
<code><a href="#topic+unite.ir">unite.ir</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## nest
ir_sample_data %&gt;%
  tidyr::nest(
    contents = c(holocellulose, klason_lignin)
  )


## unnest
ir_sample_data %&gt;%
  tidyr::nest(
    contents = c(holocellulose, klason_lignin)
  ) %&gt;%
  tidyr::unnest("contents")


</code></pre>

<hr>
<h2 id='Ops.ir'>Arithmetic operations for <code>ir</code> objects</h2><span id='topic+Ops.ir'></span>

<h3>Description</h3>

<p>Arithmetic operations for <code>ir</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ir'
Ops(e1, e2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ops.ir_+3A_e1">e1</code></td>
<td>
<p>An object of class <code>ir</code>.</p>
</td></tr>
<tr><td><code id="Ops.ir_+3A_e2">e2</code></td>
<td>
<p>An object of class <code>ir</code> or a numeric value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>e1</code> with intensity values of the spectra added to/subtracted
with/multiplied with/divided by those in <code>e2</code>:
</p>

<ul>
<li><p> If <code>e2</code> is a numeric value, all intensity values in the spectra of <code>e1</code> are
added/subtracted/multiplied/divided by <code>e2</code>.
</p>
</li>
<li><p> If <code>e2</code> is an <code>ir</code> object with one row, it is replicated (see <a href="#topic+rep.ir">rep.ir</a>) so
that the row numbers match to those of <code>e1</code> and intensity values are
added/subtracted/multiplied/divided row-wise.
</p>
</li>
<li><p> If <code>e2</code> is an <code>ir</code> object with the same number of rows as <code>e1</code>, intensity
values are added/subtracted/multiplied/divided row-wise.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## addition
ir::ir_sample_data + ir::ir_sample_data
ir::ir_sample_data + 2

## subtraction
ir::ir_sample_data - ir::ir_sample_data
ir::ir_sample_data - 2

## multiplication
ir::ir_sample_data * ir::ir_sample_data
ir::ir_sample_data * 2

## division
ir::ir_sample_data / ir::ir_sample_data
ir::ir_sample_data / 2

</code></pre>

<hr>
<h2 id='pivot_longer.ir'>Pivot an <code>ir</code> object from wide to long</h2><span id='topic+pivot_longer.ir'></span>

<h3>Description</h3>

<p>Pivot an <code>ir</code> object from wide to long
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pivot_longer.ir(
  data,
  cols,
  names_to = "name",
  names_prefix = NULL,
  names_sep = NULL,
  names_pattern = NULL,
  names_ptypes = list(),
  names_transform = list(),
  names_repair = "check_unique",
  values_to = "value",
  values_drop_na = FALSE,
  values_ptypes = list(),
  values_transform = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pivot_longer.ir_+3A_data">data</code></td>
<td>
<p>An object of class <code>ir</code>.</p>
</td></tr>
<tr><td><code id="pivot_longer.ir_+3A_cols">cols</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; Columns to pivot into
longer format.</p>
</td></tr>
<tr><td><code id="pivot_longer.ir_+3A_names_to">names_to</code></td>
<td>
<p>A character vector specifying the new column or columns to
create from the information stored in the column names of <code>data</code> specified
by <code>cols</code>.
</p>

<ul>
<li><p> If length 0, or if <code>NULL</code> is supplied, no columns will be created.
</p>
</li>
<li><p> If length 1, a single column will be created which will contain the
column names specified by <code>cols</code>.
</p>
</li>
<li><p> If length &gt;1, multiple columns will be created. In this case, one of
<code>names_sep</code> or <code>names_pattern</code> must be supplied to specify how the
column names should be split. There are also two additional character
values you can take advantage of:
</p>

<ul>
<li> <p><code>NA</code> will discard the corresponding component of the column name.
</p>
</li>
<li> <p><code>".value"</code> indicates that the corresponding component of the column
name defines the name of the output column containing the cell values,
overriding <code>values_to</code> entirely.
</p>
</li></ul>

</li></ul>
</td></tr>
<tr><td><code id="pivot_longer.ir_+3A_names_prefix">names_prefix</code></td>
<td>
<p>A regular expression used to remove matching text
from the start of each variable name.</p>
</td></tr>
<tr><td><code id="pivot_longer.ir_+3A_names_sep">names_sep</code>, <code id="pivot_longer.ir_+3A_names_pattern">names_pattern</code></td>
<td>
<p>If <code>names_to</code> contains multiple values,
these arguments control how the column name is broken up.
</p>
<p><code>names_sep</code> takes the same specification as <code><a href="tidyr.html#topic+separate">separate()</a></code>, and can either
be a numeric vector (specifying positions to break on), or a single string
(specifying a regular expression to split on).
</p>
<p><code>names_pattern</code> takes the same specification as <code><a href="tidyr.html#topic+extract">extract()</a></code>, a regular
expression containing matching groups (<code style="white-space: pre;">&#8288;()&#8288;</code>).
</p>
<p>If these arguments do not give you enough control, use
<code>pivot_longer_spec()</code> to create a spec object and process manually as
needed.</p>
</td></tr>
<tr><td><code id="pivot_longer.ir_+3A_names_ptypes">names_ptypes</code>, <code id="pivot_longer.ir_+3A_values_ptypes">values_ptypes</code></td>
<td>
<p>Optionally, a list of column name-prototype
pairs. Alternatively, a single empty prototype can be supplied, which will
be applied to all columns. A prototype (or ptype for short) is a
zero-length vector (like <code>integer()</code> or <code>numeric()</code>) that defines the type,
class, and attributes of a vector. Use these arguments if you want to
confirm that the created columns are the types that you expect. Note that
if you want to change (instead of confirm) the types of specific columns,
you should use <code>names_transform</code> or <code>values_transform</code> instead.
</p>
<p>For backwards compatibility reasons, supplying <code>list()</code> is interpreted as
being identical to <code>NULL</code> rather than as using a list prototype on all
columns. Expect this to change in the future.</p>
</td></tr>
<tr><td><code id="pivot_longer.ir_+3A_names_transform">names_transform</code>, <code id="pivot_longer.ir_+3A_values_transform">values_transform</code></td>
<td>
<p>Optionally, a list of column
name-function pairs. Alternatively, a single function can be supplied,
which will be applied to all columns. Use these arguments if you need to
change the types of specific columns. For example, <code>names_transform = list(week = as.integer)</code> would convert a character variable called <code>week</code>
to an integer.
</p>
<p>If not specified, the type of the columns generated from <code>names_to</code> will
be character, and the type of the variables generated from <code>values_to</code>
will be the common type of the input columns used to generate them.</p>
</td></tr>
<tr><td><code id="pivot_longer.ir_+3A_names_repair">names_repair</code></td>
<td>
<p>What happens if the output has invalid column names?
The default, <code>"check_unique"</code> is to error if the columns are duplicated.
Use <code>"minimal"</code> to allow duplicates in the output, or <code>"unique"</code> to
de-duplicated by adding numeric suffixes. See <code><a href="vctrs.html#topic+vec_as_names">vctrs::vec_as_names()</a></code>
for more options.</p>
</td></tr>
<tr><td><code id="pivot_longer.ir_+3A_values_to">values_to</code></td>
<td>
<p>A string specifying the name of the column to create
from the data stored in cell values. If <code>names_to</code> is a character
containing the special <code>.value</code> sentinel, this value will be ignored,
and the name of the value column will be derived from part of the
existing column names.</p>
</td></tr>
<tr><td><code id="pivot_longer.ir_+3A_values_drop_na">values_drop_na</code></td>
<td>
<p>If <code>TRUE</code>, will drop rows that contain only <code>NA</code>s
in the <code>value_to</code> column. This effectively converts explicit missing values
to implicit missing values, and should generally be used only when missing
values in <code>data</code> were created by its structure.</p>
</td></tr>
<tr><td><code id="pivot_longer.ir_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data</code> in a long format. If the <code>spectra</code> column is dropped
or invalidated (see <code><a href="#topic+ir_new_ir">ir_new_ir()</a></code>), the <code>ir</code> class is dropped, else the
object is of class <code>ir</code>.
</p>


<h3>Source</h3>

<p><code><a href="tidyr.html#topic+pivot_longer">tidyr::pivot_longer()</a></code>
</p>


<h3>See Also</h3>

<p>Other tidyverse: 
<code><a href="#topic+arrange.ir">arrange.ir</a>()</code>,
<code><a href="#topic+distinct.ir">distinct.ir</a>()</code>,
<code><a href="#topic+extract.ir">extract.ir</a>()</code>,
<code><a href="#topic+filter-joins">filter-joins</a></code>,
<code><a href="#topic+filter.ir">filter.ir</a>()</code>,
<code><a href="#topic+group_by">group_by</a></code>,
<code><a href="#topic+mutate-joins">mutate-joins</a></code>,
<code><a href="#topic+mutate">mutate</a></code>,
<code><a href="#topic+nest">nest</a></code>,
<code><a href="#topic+pivot_wider.ir">pivot_wider.ir</a>()</code>,
<code><a href="#topic+rename">rename</a></code>,
<code><a href="#topic+rowwise.ir">rowwise.ir</a>()</code>,
<code><a href="#topic+select.ir">select.ir</a>()</code>,
<code><a href="#topic+separate.ir">separate.ir</a>()</code>,
<code><a href="#topic+separate_rows.ir">separate_rows.ir</a>()</code>,
<code><a href="#topic+slice">slice</a></code>,
<code><a href="#topic+summarize">summarize</a></code>,
<code><a href="#topic+unite.ir">unite.ir</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## pivot_longer
ir_sample_data %&gt;%
  tidyr::pivot_longer(
    cols = dplyr::any_of(c("holocellulose", "klason_lignin"))
  )


</code></pre>

<hr>
<h2 id='pivot_wider.ir'>Pivot an <code>ir</code> object from wide to long</h2><span id='topic+pivot_wider.ir'></span>

<h3>Description</h3>

<p>Pivot an <code>ir</code> object from wide to long
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pivot_wider.ir(
  data,
  id_cols = NULL,
  names_from = "name",
  names_prefix = "",
  names_sep = "_",
  names_glue = NULL,
  names_sort = FALSE,
  names_repair = "check_unique",
  values_from = "value",
  values_fill = NULL,
  values_fn = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pivot_wider.ir_+3A_data">data</code></td>
<td>
<p>An object of class <code>ir</code>.</p>
</td></tr>
<tr><td><code id="pivot_wider.ir_+3A_id_cols">id_cols</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; A set of columns that
uniquely identifies each observation. Defaults to all columns in <code>data</code>
except for the columns specified in <code>names_from</code> and <code>values_from</code>.
Typically used when you have redundant variables, i.e. variables whose
values are perfectly correlated with existing variables.</p>
</td></tr>
<tr><td><code id="pivot_wider.ir_+3A_names_from">names_from</code>, <code id="pivot_wider.ir_+3A_values_from">values_from</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; A pair of
arguments describing which column (or columns) to get the name of the
output column (<code>names_from</code>), and which column (or columns) to get the
cell values from (<code>values_from</code>).
</p>
<p>If <code>values_from</code> contains multiple values, the value will be added to the
front of the output column.</p>
</td></tr>
<tr><td><code id="pivot_wider.ir_+3A_names_prefix">names_prefix</code></td>
<td>
<p>String added to the start of every variable name. This is
particularly useful if <code>names_from</code> is a numeric vector and you want to
create syntactic variable names.</p>
</td></tr>
<tr><td><code id="pivot_wider.ir_+3A_names_sep">names_sep</code></td>
<td>
<p>If <code>names_from</code> or <code>values_from</code> contains multiple
variables, this will be used to join their values together into a single
string to use as a column name.</p>
</td></tr>
<tr><td><code id="pivot_wider.ir_+3A_names_glue">names_glue</code></td>
<td>
<p>Instead of <code>names_sep</code> and <code>names_prefix</code>, you can supply
a glue specification that uses the <code>names_from</code> columns (and special
<code>.value</code>) to create custom column names.</p>
</td></tr>
<tr><td><code id="pivot_wider.ir_+3A_names_sort">names_sort</code></td>
<td>
<p>Should the column names be sorted? If <code>FALSE</code>, the default,
column names are ordered by first appearance.</p>
</td></tr>
<tr><td><code id="pivot_wider.ir_+3A_names_repair">names_repair</code></td>
<td>
<p>What happens if the output has invalid column names?
The default, <code>"check_unique"</code> is to error if the columns are duplicated.
Use <code>"minimal"</code> to allow duplicates in the output, or <code>"unique"</code> to
de-duplicated by adding numeric suffixes. See <code><a href="vctrs.html#topic+vec_as_names">vctrs::vec_as_names()</a></code>
for more options.</p>
</td></tr>
<tr><td><code id="pivot_wider.ir_+3A_values_fill">values_fill</code></td>
<td>
<p>Optionally, a (scalar) value that specifies what each
<code>value</code> should be filled in with when missing.
</p>
<p>This can be a named list if you want to apply different fill values to
different value columns.</p>
</td></tr>
<tr><td><code id="pivot_wider.ir_+3A_values_fn">values_fn</code></td>
<td>
<p>Optionally, a function applied to the value in each cell
in the output. You will typically use this when the combination of
<code>id_cols</code> and <code>names_from</code> columns does not uniquely identify an
observation.
</p>
<p>This can be a named list if you want to apply different aggregations
to different <code>values_from</code> columns.</p>
</td></tr>
<tr><td><code id="pivot_wider.ir_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data</code> in a wide format. If the <code>spectra</code> column is dropped
or invalidated (see <code><a href="#topic+ir_new_ir">ir_new_ir()</a></code>), the <code>ir</code> class is dropped, else the
object is of class <code>ir</code>.
</p>


<h3>Source</h3>

<p><code><a href="tidyr.html#topic+pivot_wider">tidyr::pivot_wider()</a></code>
</p>


<h3>See Also</h3>

<p>Other tidyverse: 
<code><a href="#topic+arrange.ir">arrange.ir</a>()</code>,
<code><a href="#topic+distinct.ir">distinct.ir</a>()</code>,
<code><a href="#topic+extract.ir">extract.ir</a>()</code>,
<code><a href="#topic+filter-joins">filter-joins</a></code>,
<code><a href="#topic+filter.ir">filter.ir</a>()</code>,
<code><a href="#topic+group_by">group_by</a></code>,
<code><a href="#topic+mutate-joins">mutate-joins</a></code>,
<code><a href="#topic+mutate">mutate</a></code>,
<code><a href="#topic+nest">nest</a></code>,
<code><a href="#topic+pivot_longer.ir">pivot_longer.ir</a>()</code>,
<code><a href="#topic+rename">rename</a></code>,
<code><a href="#topic+rowwise.ir">rowwise.ir</a>()</code>,
<code><a href="#topic+select.ir">select.ir</a>()</code>,
<code><a href="#topic+separate.ir">separate.ir</a>()</code>,
<code><a href="#topic+separate_rows.ir">separate_rows.ir</a>()</code>,
<code><a href="#topic+slice">slice</a></code>,
<code><a href="#topic+summarize">summarize</a></code>,
<code><a href="#topic+unite.ir">unite.ir</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## pivot_wider
ir_sample_data %&gt;%
  tidyr::pivot_longer(
    cols = dplyr::any_of(c("holocellulose", "klason_lignin"))
  ) %&gt;%
  tidyr::pivot_wider(names_from = "name", values_from = "value")


</code></pre>

<hr>
<h2 id='plot.ir'>Plots an object of class <code>ir</code></h2><span id='topic+plot.ir'></span>

<h3>Description</h3>

<p><code>plot.ir</code> is the plot method for objects of class <code>ir</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ir'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ir_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+ir_new_ir">ir</a></code>.</p>
</td></tr>
<tr><td><code id="plot.ir_+3A_...">...</code></td>
<td>
<p>Further arguments, will be ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="ggplot2.html#topic+ggplot">ggplot2</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simple plotting
plot(ir::ir_sample_data[1:2, ])

# advanced functions
plot(ir::ir_sample_data) +
   ggplot2::facet_wrap(~ sample_type)
</code></pre>

<hr>
<h2 id='range'>Get the minima/maxima/range/median of x axis values or intensity values of infrared spectra</h2><span id='topic+range'></span><span id='topic+range.ir'></span><span id='topic+min.ir'></span><span id='topic+max.ir'></span><span id='topic+median.ir'></span>

<h3>Description</h3>

<p><code>range.ir</code> extracts the range of x axis values (e.g. wavenumbers) or
intensity values of infrared spectra.
</p>
<p><code>min.ir</code> extracts the minimum x axis value (e.g. wavenumber) or
intensity value of infrared spectra.
</p>
<p><code>max.ir</code> extracts the maximum x axis value (e.g. wavenumber) or
intensity value of infrared spectra.
</p>
<p><code>median.ir</code> extracts the median x axis value (e.g. wavenumber) or
intensity value of infrared spectra.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ir'
range(
  x,
  ...,
  na.rm = FALSE,
  .dimension = "y",
  .col_names = c("y_min", "y_max")
)

## S3 method for class 'ir'
min(x, ..., na.rm = FALSE, .dimension = "y", .col_name = "y_min")

## S3 method for class 'ir'
max(x, ..., na.rm = FALSE, .dimension = "y", .col_name = "y_max")

## S3 method for class 'ir'
median(x, na.rm = FALSE, ..., .dimension = "y", .col_name = "y_median")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="range_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+ir_new_ir">ir</a></code>.</p>
</td></tr>
<tr><td><code id="range_+3A_...">...</code></td>
<td>
<p>Further arguments, ignored.</p>
</td></tr>
<tr><td><code id="range_+3A_na.rm">na.rm</code></td>
<td>
<p>A logical value. See <code><a href="base.html#topic+max">max()</a></code>.</p>
</td></tr>
<tr><td><code id="range_+3A_.dimension">.dimension</code></td>
<td>
<p>A character value. Must be one of the following:
</p>

<dl>
<dt>&quot;x&quot;</dt><dd><p>In this case, the minimum/maximum/range/median of x axis values
of the spectra in <code>x</code> are extracted.</p>
</dd>
<dt>&quot;y&quot;</dt><dd><p>In this case, the minimum/maximum/range/median of intensity
values of the spectra in <code>x</code> are extracted.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="range_+3A_.col_names">.col_names</code></td>
<td>
<p>A character vector of length 2 representing the names of the
columns in which to store the extracted values. The first element is the name
for the column with minima values, the second the name for the column with
maxima values.</p>
</td></tr>
<tr><td><code id="range_+3A_.col_name">.col_name</code></td>
<td>
<p>A character value representing the name of the column in
which to store the extracted values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> with the extracted values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># range of intensity values
x1 &lt;-
   ir::ir_sample_data %&gt;%
   range(.dimension = "y")

# minimum intensity values
x1 &lt;-
   ir::ir_sample_data %&gt;%
   min(.dimension = "y")

# maximum intensity values
x1 &lt;-
   ir::ir_sample_data %&gt;%
   max(.dimension = "y")

# median intensity values
x1 &lt;-
   ir::ir_sample_data %&gt;%
   stats::median(.dimension = "y")

</code></pre>

<hr>
<h2 id='rename'>Rename columns in <code>ir</code> objects</h2><span id='topic+rename'></span><span id='topic+rename.ir'></span><span id='topic+rename_with.ir'></span>

<h3>Description</h3>

<p>Rename columns in <code>ir</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rename.ir(.data, ...)

rename_with.ir(.data, .fn, .cols = dplyr::everything(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rename_+3A_.data">.data</code></td>
<td>
<p>An object of class <code>ir</code>.</p>
</td></tr>
<tr><td><code id="rename_+3A_...">...</code></td>
<td>
<p>For <code>rename()</code>: &lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Use
<code>new_name = old_name</code> to rename selected variables.
</p>
<p>For <code>rename_with()</code>: additional arguments passed onto <code>.fn</code>.</p>
</td></tr>
<tr><td><code id="rename_+3A_.fn">.fn</code></td>
<td>
<p>A function used to transform the selected <code>.cols</code>. Should
return a character vector the same length as the input.</p>
</td></tr>
<tr><td><code id="rename_+3A_.cols">.cols</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Columns to rename;
defaults to all columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>.data</code> with renamed columns. If the <code>spectra</code> column is renamed,
and no new valid <code>spectra</code> column is created, the <code>ir</code> class is dropped, else
the object is of class <code>ir</code>.
</p>


<h3>Source</h3>

<p><code><a href="dplyr.html#topic+rename">dplyr::rename()</a></code>
</p>


<h3>See Also</h3>

<p>Other tidyverse: 
<code><a href="#topic+arrange.ir">arrange.ir</a>()</code>,
<code><a href="#topic+distinct.ir">distinct.ir</a>()</code>,
<code><a href="#topic+extract.ir">extract.ir</a>()</code>,
<code><a href="#topic+filter-joins">filter-joins</a></code>,
<code><a href="#topic+filter.ir">filter.ir</a>()</code>,
<code><a href="#topic+group_by">group_by</a></code>,
<code><a href="#topic+mutate-joins">mutate-joins</a></code>,
<code><a href="#topic+mutate">mutate</a></code>,
<code><a href="#topic+nest">nest</a></code>,
<code><a href="#topic+pivot_longer.ir">pivot_longer.ir</a>()</code>,
<code><a href="#topic+pivot_wider.ir">pivot_wider.ir</a>()</code>,
<code><a href="#topic+rowwise.ir">rowwise.ir</a>()</code>,
<code><a href="#topic+select.ir">select.ir</a>()</code>,
<code><a href="#topic+separate.ir">separate.ir</a>()</code>,
<code><a href="#topic+separate_rows.ir">separate_rows.ir</a>()</code>,
<code><a href="#topic+slice">slice</a></code>,
<code><a href="#topic+summarize">summarize</a></code>,
<code><a href="#topic+unite.ir">unite.ir</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## rename
dplyr::rename(ir_sample_data, hol = "holocellulose")
dplyr::rename(ir_sample_data, spec = "spectra") # drops ir class


## rename_with
dplyr::rename_with(ir_sample_data, .cols = dplyr::starts_with("id_"),
  toupper)
dplyr::rename_with(ir_sample_data, toupper) # drops ir class


</code></pre>

<hr>
<h2 id='rep.ir'>Replicate ir objects</h2><span id='topic+rep.ir'></span>

<h3>Description</h3>

<p><code>rep.ir</code> is the replicate method for <code><a href="#topic+ir_new_ir">ir</a></code> objects.
Replicating and <code>ir</code> object means to replicate its rows and bind these
together to a larger <code>ir</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ir'
rep(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rep.ir_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+ir_new_ir">ir</a></code>.</p>
</td></tr>
<tr><td><code id="rep.ir_+3A_...">...</code></td>
<td>
<p>See <code><a href="base.html#topic+rep">rep()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>ir</code> with replicated spectra.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># replicate the sample data
x &lt;- rep(ir::ir_sample_data, times = 2)
x &lt;- rep(ir::ir_sample_data, each = 2)
x &lt;- rep(ir::ir_sample_data, length.out = 3)

</code></pre>

<hr>
<h2 id='rowwise.ir'>Group input <code>ir</code> objects by rows</h2><span id='topic+rowwise.ir'></span>

<h3>Description</h3>

<p>Group input <code>ir</code> objects by rows
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowwise.ir(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowwise.ir_+3A_.data">.data</code></td>
<td>
<p>Input data frame.</p>
</td></tr>
<tr><td><code id="rowwise.ir_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Variables to be preserved
when calling <code><a href="dplyr.html#topic+summarise">summarise()</a></code>. This is typically a set of variables whose
combination uniquely identify each row.
</p>
<p><strong>NB</strong>: unlike <code>group_by()</code> you can not create new variables here but
instead you can select multiple variables with (e.g.) <code>everything()</code>.</p>
</td></tr>
<tr><td><code id="rowwise.ir_+3A_data">data</code></td>
<td>
<p>An object of class <code>ir</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data</code> as row-wise data frame. See <code><a href="dplyr.html#topic+rowwise">dplyr::rowwise()</a></code>.
</p>


<h3>Source</h3>

<p><code><a href="dplyr.html#topic+rowwise">dplyr::rowwise()</a></code>
</p>


<h3>See Also</h3>

<p>Other tidyverse: 
<code><a href="#topic+arrange.ir">arrange.ir</a>()</code>,
<code><a href="#topic+distinct.ir">distinct.ir</a>()</code>,
<code><a href="#topic+extract.ir">extract.ir</a>()</code>,
<code><a href="#topic+filter-joins">filter-joins</a></code>,
<code><a href="#topic+filter.ir">filter.ir</a>()</code>,
<code><a href="#topic+group_by">group_by</a></code>,
<code><a href="#topic+mutate-joins">mutate-joins</a></code>,
<code><a href="#topic+mutate">mutate</a></code>,
<code><a href="#topic+nest">nest</a></code>,
<code><a href="#topic+pivot_longer.ir">pivot_longer.ir</a>()</code>,
<code><a href="#topic+pivot_wider.ir">pivot_wider.ir</a>()</code>,
<code><a href="#topic+rename">rename</a></code>,
<code><a href="#topic+select.ir">select.ir</a>()</code>,
<code><a href="#topic+separate.ir">separate.ir</a>()</code>,
<code><a href="#topic+separate_rows.ir">separate_rows.ir</a>()</code>,
<code><a href="#topic+slice">slice</a></code>,
<code><a href="#topic+summarize">summarize</a></code>,
<code><a href="#topic+unite.ir">unite.ir</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## rowwise
dplyr::rowwise(ir_sample_data) %&gt;%
  dplyr::mutate(
    hkl =
      mean(
        units::drop_units(klason_lignin),
        units::drop_units(holocellulose)
      )
  )


</code></pre>

<hr>
<h2 id='select.ir'>Subset columns in <code>ir</code> objects using column names and types</h2><span id='topic+select.ir'></span>

<h3>Description</h3>

<p>Subset columns in <code>ir</code> objects using column names and types
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select.ir(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select.ir_+3A_.data">.data</code></td>
<td>
<p>An object of class <code>ir</code>.</p>
</td></tr>
<tr><td><code id="select.ir_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; One or more unquoted
expressions separated by commas. Variable names can be used as if they
were positions in the data frame, so expressions like <code>x:y</code> can
be used to select a range of variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>.data</code> with the selected columns. If the <code>spectra</code> column is dropped,
the <code>ir</code> class is dropped, else the object is of class <code>ir</code>.
</p>


<h3>Source</h3>

<p><code><a href="dplyr.html#topic+select">dplyr::select()</a></code>
</p>


<h3>See Also</h3>

<p>Other tidyverse: 
<code><a href="#topic+arrange.ir">arrange.ir</a>()</code>,
<code><a href="#topic+distinct.ir">distinct.ir</a>()</code>,
<code><a href="#topic+extract.ir">extract.ir</a>()</code>,
<code><a href="#topic+filter-joins">filter-joins</a></code>,
<code><a href="#topic+filter.ir">filter.ir</a>()</code>,
<code><a href="#topic+group_by">group_by</a></code>,
<code><a href="#topic+mutate-joins">mutate-joins</a></code>,
<code><a href="#topic+mutate">mutate</a></code>,
<code><a href="#topic+nest">nest</a></code>,
<code><a href="#topic+pivot_longer.ir">pivot_longer.ir</a>()</code>,
<code><a href="#topic+pivot_wider.ir">pivot_wider.ir</a>()</code>,
<code><a href="#topic+rename">rename</a></code>,
<code><a href="#topic+rowwise.ir">rowwise.ir</a>()</code>,
<code><a href="#topic+separate.ir">separate.ir</a>()</code>,
<code><a href="#topic+separate_rows.ir">separate_rows.ir</a>()</code>,
<code><a href="#topic+slice">slice</a></code>,
<code><a href="#topic+summarize">summarize</a></code>,
<code><a href="#topic+unite.ir">unite.ir</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## select
dplyr::select(ir_sample_data, spectra)
dplyr::select(ir_sample_data, holocellulose) # drops ir class


</code></pre>

<hr>
<h2 id='separate_rows.ir'>Separate a collapsed column in an <code>ir</code> object into multiple rows</h2><span id='topic+separate_rows.ir'></span>

<h3>Description</h3>

<p>Separate a collapsed column in an <code>ir</code> object into multiple rows
</p>


<h3>Usage</h3>

<pre><code class='language-R'>separate_rows.ir(data, ..., sep = "[^[:alnum:].]+", convert = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="separate_rows.ir_+3A_data">data</code></td>
<td>
<p>An object of class <code>ir</code>.</p>
</td></tr>
<tr><td><code id="separate_rows.ir_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; Columns to separate across
multiple rows</p>
</td></tr>
<tr><td><code id="separate_rows.ir_+3A_sep">sep</code></td>
<td>
<p>Separator delimiting collapsed values.</p>
</td></tr>
<tr><td><code id="separate_rows.ir_+3A_convert">convert</code></td>
<td>
<p>If <code>TRUE</code> will automatically run
<code><a href="utils.html#topic+type.convert">type.convert()</a></code> on the key column. This is useful if the column
types are actually numeric, integer, or logical.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data</code> with a collapsed column separated into multiple rows. See
<code><a href="tidyr.html#topic+separate_rows">tidyr::separate_rows()</a></code>.
</p>


<h3>Source</h3>

<p><code><a href="tidyr.html#topic+separate_rows">tidyr::separate_rows()</a></code>
</p>


<h3>See Also</h3>

<p>Other tidyverse: 
<code><a href="#topic+arrange.ir">arrange.ir</a>()</code>,
<code><a href="#topic+distinct.ir">distinct.ir</a>()</code>,
<code><a href="#topic+extract.ir">extract.ir</a>()</code>,
<code><a href="#topic+filter-joins">filter-joins</a></code>,
<code><a href="#topic+filter.ir">filter.ir</a>()</code>,
<code><a href="#topic+group_by">group_by</a></code>,
<code><a href="#topic+mutate-joins">mutate-joins</a></code>,
<code><a href="#topic+mutate">mutate</a></code>,
<code><a href="#topic+nest">nest</a></code>,
<code><a href="#topic+pivot_longer.ir">pivot_longer.ir</a>()</code>,
<code><a href="#topic+pivot_wider.ir">pivot_wider.ir</a>()</code>,
<code><a href="#topic+rename">rename</a></code>,
<code><a href="#topic+rowwise.ir">rowwise.ir</a>()</code>,
<code><a href="#topic+select.ir">select.ir</a>()</code>,
<code><a href="#topic+separate.ir">separate.ir</a>()</code>,
<code><a href="#topic+slice">slice</a></code>,
<code><a href="#topic+summarize">summarize</a></code>,
<code><a href="#topic+unite.ir">unite.ir</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## separate_rows
ir_sample_data %&gt;%
  tidyr::unite(
    col = content, holocellulose, klason_lignin
  ) %&gt;%
  tidyr::separate_rows(
    col
  )


</code></pre>

<hr>
<h2 id='separate.ir'>Separate a character column in an <code>ir</code> object into multiple columns with a regular expression or numeric locations</h2><span id='topic+separate.ir'></span>

<h3>Description</h3>

<p>Separate a character column in an <code>ir</code> object into multiple columns with a regular expression or numeric locations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>separate.ir(
  data,
  col,
  into,
  sep = "[^[:alnum:]]+",
  remove = TRUE,
  convert = FALSE,
  extra = "warn",
  fill = "warn",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="separate.ir_+3A_data">data</code></td>
<td>
<p>An object of class <code>ir</code>.</p>
</td></tr>
<tr><td><code id="separate.ir_+3A_col">col</code></td>
<td>
<p>Column name or position. This is passed to
<code><a href="tidyselect.html#topic+vars_pull">tidyselect::vars_pull()</a></code>.
</p>
<p>This argument is passed by expression and supports
<a href="rlang.html#topic+nse-force">quasiquotation</a> (you can unquote column
names or column positions).</p>
</td></tr>
<tr><td><code id="separate.ir_+3A_into">into</code></td>
<td>
<p>Names of new variables to create as character vector.
Use <code>NA</code> to omit the variable in the output.</p>
</td></tr>
<tr><td><code id="separate.ir_+3A_sep">sep</code></td>
<td>
<p>Separator between columns.
</p>
<p>If character, <code>sep</code> is interpreted as a regular expression. The default
value is a regular expression that matches any sequence of
non-alphanumeric values.
</p>
<p>If numeric, <code>sep</code> is interpreted as character positions to split at. Positive
values start at 1 at the far-left of the string; negative value start at -1 at
the far-right of the string. The length of <code>sep</code> should be one less than
<code>into</code>.</p>
</td></tr>
<tr><td><code id="separate.ir_+3A_remove">remove</code></td>
<td>
<p>If <code>TRUE</code>, remove input column from output data frame.</p>
</td></tr>
<tr><td><code id="separate.ir_+3A_convert">convert</code></td>
<td>
<p>If <code>TRUE</code>, will run <code><a href="utils.html#topic+type.convert">type.convert()</a></code> with
<code>as.is = TRUE</code> on new columns. This is useful if the component
columns are integer, numeric or logical.
</p>
<p>NB: this will cause string <code>"NA"</code>s to be converted to <code>NA</code>s.</p>
</td></tr>
<tr><td><code id="separate.ir_+3A_extra">extra</code></td>
<td>
<p>If <code>sep</code> is a character vector, this controls what
happens when there are too many pieces. There are three valid options:
</p>

<ul>
<li><p> &quot;warn&quot; (the default): emit a warning and drop extra values.
</p>
</li>
<li><p> &quot;drop&quot;: drop any extra values without a warning.
</p>
</li>
<li><p> &quot;merge&quot;: only splits at most <code>length(into)</code> times
</p>
</li></ul>
</td></tr>
<tr><td><code id="separate.ir_+3A_fill">fill</code></td>
<td>
<p>If <code>sep</code> is a character vector, this controls what
happens when there are not enough pieces. There are three valid options:
</p>

<ul>
<li><p> &quot;warn&quot; (the default): emit a warning and fill from the right
</p>
</li>
<li><p> &quot;right&quot;: fill with missing values on the right
</p>
</li>
<li><p> &quot;left&quot;: fill with missing values on the left
</p>
</li></ul>
</td></tr>
<tr><td><code id="separate.ir_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>.data</code> with separated columns. If the <code>spectra</code> column is
dropped or invalidated (see <code><a href="#topic+ir_new_ir">ir_new_ir()</a></code>), the <code>ir</code> class is dropped, else
the object is of class <code>ir</code>.
</p>


<h3>Source</h3>

<p><code><a href="tidyr.html#topic+separate">tidyr::separate()</a></code>
</p>


<h3>See Also</h3>

<p>Other tidyverse: 
<code><a href="#topic+arrange.ir">arrange.ir</a>()</code>,
<code><a href="#topic+distinct.ir">distinct.ir</a>()</code>,
<code><a href="#topic+extract.ir">extract.ir</a>()</code>,
<code><a href="#topic+filter-joins">filter-joins</a></code>,
<code><a href="#topic+filter.ir">filter.ir</a>()</code>,
<code><a href="#topic+group_by">group_by</a></code>,
<code><a href="#topic+mutate-joins">mutate-joins</a></code>,
<code><a href="#topic+mutate">mutate</a></code>,
<code><a href="#topic+nest">nest</a></code>,
<code><a href="#topic+pivot_longer.ir">pivot_longer.ir</a>()</code>,
<code><a href="#topic+pivot_wider.ir">pivot_wider.ir</a>()</code>,
<code><a href="#topic+rename">rename</a></code>,
<code><a href="#topic+rowwise.ir">rowwise.ir</a>()</code>,
<code><a href="#topic+select.ir">select.ir</a>()</code>,
<code><a href="#topic+separate_rows.ir">separate_rows.ir</a>()</code>,
<code><a href="#topic+slice">slice</a></code>,
<code><a href="#topic+summarize">summarize</a></code>,
<code><a href="#topic+unite.ir">unite.ir</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## separate
ir_sample_data %&gt;%
  tidyr::separate(
    col = "id_sample",  c("a", "b", "c")
  )


</code></pre>

<hr>
<h2 id='slice'>Subset rows in <code>ir</code> objects using their positions</h2><span id='topic+slice'></span><span id='topic+slice.ir'></span><span id='topic+slice_sample.ir'></span>

<h3>Description</h3>

<p>Subset rows in <code>ir</code> objects using their positions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slice.ir(.data, ..., .preserve = FALSE)

slice_sample.ir(.data, ..., n, prop, weight_by = NULL, replace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slice_+3A_.data">.data</code></td>
<td>
<p>An object of class <code>ir</code>.</p>
</td></tr>
<tr><td><code id="slice_+3A_...">...</code></td>
<td>
<p>For <code>slice()</code>: &lt;<code><a href="dplyr.html#topic+dplyr_data_masking">data-masking</a></code>&gt; Integer row
values.
</p>
<p>Provide either positive values to keep, or negative values to drop.
The values provided must be either all positive or all negative.
Indices beyond the number of rows in the input are silently ignored.
</p>
<p>For <code>slice_helpers()</code>, these arguments are passed on to methods.</p>
</td></tr>
<tr><td><code id="slice_+3A_.preserve">.preserve</code></td>
<td>
<p>Relevant when the <code>.data</code> input is grouped.
If <code>.preserve = FALSE</code> (the default), the grouping structure
is recalculated based on the resulting data, otherwise the grouping is kept as is.</p>
</td></tr>
<tr><td><code id="slice_+3A_n">n</code>, <code id="slice_+3A_prop">prop</code></td>
<td>
<p>Provide either <code>n</code>, the number of rows, or <code>prop</code>, the
proportion of rows to select. If neither are supplied, <code>n = 1</code> will be
used.
</p>
<p>If a negative value of <code>n</code> or <code>prop</code> is provided, the specified number or
proportion of rows will be removed.
</p>
<p>If <code>n</code> is greater than the number of rows in the group (or <code>prop &gt; 1</code>),
the result will be silently truncated to the group size. If the
<code>prop</code>ortion of a group size does not yield an integer number of rows, the
absolute value of <code>prop*nrow(.data)</code> is rounded down.</p>
</td></tr>
<tr><td><code id="slice_+3A_weight_by">weight_by</code></td>
<td>
<p>Sampling weights. This must evaluate to a vector of
non-negative numbers the same length as the input. Weights are
automatically standardised to sum to 1.</p>
</td></tr>
<tr><td><code id="slice_+3A_replace">replace</code></td>
<td>
<p>Should sampling be performed with (<code>TRUE</code>) or without
(<code>FALSE</code>, the default) replacement.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>.data</code> with subsetted rows.
</p>


<h3>Source</h3>

<p><code><a href="dplyr.html#topic+slice">dplyr::slice()</a></code>
</p>


<h3>See Also</h3>

<p>Other tidyverse: 
<code><a href="#topic+arrange.ir">arrange.ir</a>()</code>,
<code><a href="#topic+distinct.ir">distinct.ir</a>()</code>,
<code><a href="#topic+extract.ir">extract.ir</a>()</code>,
<code><a href="#topic+filter-joins">filter-joins</a></code>,
<code><a href="#topic+filter.ir">filter.ir</a>()</code>,
<code><a href="#topic+group_by">group_by</a></code>,
<code><a href="#topic+mutate-joins">mutate-joins</a></code>,
<code><a href="#topic+mutate">mutate</a></code>,
<code><a href="#topic+nest">nest</a></code>,
<code><a href="#topic+pivot_longer.ir">pivot_longer.ir</a>()</code>,
<code><a href="#topic+pivot_wider.ir">pivot_wider.ir</a>()</code>,
<code><a href="#topic+rename">rename</a></code>,
<code><a href="#topic+rowwise.ir">rowwise.ir</a>()</code>,
<code><a href="#topic+select.ir">select.ir</a>()</code>,
<code><a href="#topic+separate.ir">separate.ir</a>()</code>,
<code><a href="#topic+separate_rows.ir">separate_rows.ir</a>()</code>,
<code><a href="#topic+summarize">summarize</a></code>,
<code><a href="#topic+unite.ir">unite.ir</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## slice
dplyr::slice(ir_sample_data, 1:5)
dplyr::slice_min(ir_sample_data, holocellulose, n = 3)
dplyr::slice_max(ir_sample_data, holocellulose, n = 3)
dplyr::slice_head(ir_sample_data, n = 5)
dplyr::slice_tail(ir_sample_data, n = 5)

## slice_sample
set.seed(234)
dplyr::slice_sample(ir_sample_data, n = 3)


</code></pre>

<hr>
<h2 id='subsetting'>Subsetting <code>ir</code> objects</h2><span id='topic+subsetting'></span><span id='topic++5B.ir'></span><span id='topic++24.ir'></span><span id='topic++5B+5B.ir'></span><span id='topic++24+3C-.ir'></span><span id='topic++5B+3C-.ir'></span><span id='topic++5B+5B+3C-.ir'></span>

<h3>Description</h3>

<p>Subsetting <code>ir</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ir'
x[i, j, ..., exact = TRUE]

## S3 method for class 'ir'
x$i

## S3 method for class 'ir'
x[[i, j, ..., exact = TRUE]]

## S3 replacement method for class 'ir'
x$i, j, ... &lt;- value

## S3 replacement method for class 'ir'
i[j, ..., exact = TRUE] &lt;- value

## S3 replacement method for class 'ir'
i[[j, ..., exact = TRUE]] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subsetting_+3A_x">x</code></td>
<td>
<p>An object of class <code>ir</code>.</p>
</td></tr>
<tr><td><code id="subsetting_+3A_i">i</code>, <code id="subsetting_+3A_j">j</code></td>
<td>
<p>Row and column indices. If <code>j</code> is omitted, <code>i</code> is used as column index.</p>
</td></tr>
<tr><td><code id="subsetting_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="subsetting_+3A_exact">exact</code></td>
<td>
<p>Ignored, with a warning.</p>
</td></tr>
<tr><td><code id="subsetting_+3A_value">value</code></td>
<td>
<p>A value to store in a row, column, range or cell.
Tibbles are stricter than data frames in what is accepted here.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the subsetting operation preserves a valid <code>spectra</code> column
(see <code><a href="#topic+ir_new_ir">ir()</a></code>), an object of class <code>ir</code> with
accordingly subsetted rows or columns. Else a <code><a href="tibble.html#topic+tbl_df-class">tibble::tbl_df()</a></code> or
vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># subsetting rows
ir_sample_data[1, ]
ir_sample_data[10:15, ]
ir_sample_data[ir_sample_data$sample_type == "office paper", ]

# subsetting columns
ir_sample_data[, "spectra"]
ir_sample_data[["spectra"]]
ir_sample_data$spectra

# not explicitly selecting the spectra column drops the ir class
class(ir_sample_data[, 1])
class(ir_sample_data[, "spectra"])

# subsetting values
ir_sample_data[, 1] # drops the ir class
ir_sample_data[, c("id_sample", "spectra")]
ir_sample_data$id_sample
ir_sample_data[[1, 1]]

# setting and replacing columns
x &lt;- ir::ir_sample_data
x$a &lt;- 3
x[, "a"] &lt;- 4
x$sample_type &lt;- "a"
x[[1]] &lt;- rev(x[[1]])

# deleting the spectra column drops the ir class
x$spectra &lt;- NULL
class(x)

# setting and replacing rows
x &lt;- ir::ir_sample_data
x[1, ] &lt;- x[2, ]
class(x)

# setting invalid values in the spectra column drops the ir class
x_replacement &lt;- x[1, ]
x_replacement$spectra &lt;- list(1)
x[1, ] &lt;- x_replacement
class(x)

# setting and replacing values
x &lt;- ir::ir_sample_data
x[[1, 1]] &lt;- 100

# replacing an element in the spectra column by an invalid element drops the
# ir class attribute
x[[3, "spectra"]] &lt;- list(1)
class(x)

</code></pre>

<hr>
<h2 id='summarize'>Summarize each group in a <code>ir</code> object to fewer rows</h2><span id='topic+summarize'></span><span id='topic+summarize.ir'></span><span id='topic+summarise'></span><span id='topic+summarise.ir'></span>

<h3>Description</h3>

<p>Summarize each group in a <code>ir</code> object to fewer rows
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize.ir(.data, ..., .groups = NULL)

summarise.ir(.data, ..., .groups = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarize_+3A_.data">.data</code></td>
<td>
<p>An object of class <code>ir</code>.</p>
</td></tr>
<tr><td><code id="summarize_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_data_masking">data-masking</a></code>&gt; Name-value pairs of summary
functions. The name will be the name of the variable in the result.
</p>
<p>The value can be:
</p>

<ul>
<li><p> A vector of length 1, e.g. <code>min(x)</code>, <code>n()</code>, or <code>sum(is.na(y))</code>.
</p>
</li>
<li><p> A vector of length <code>n</code>, e.g. <code>quantile()</code>.
</p>
</li>
<li><p> A data frame, to add multiple columns from a single expression.
</p>
</li></ul>
</td></tr>
<tr><td><code id="summarize_+3A_.groups">.groups</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a> Grouping structure of the result.
</p>

<ul>
<li><p> &quot;drop_last&quot;: dropping the last level of grouping. This was the
only supported option before version 1.0.0.
</p>
</li>
<li><p> &quot;drop&quot;: All levels of grouping are dropped.
</p>
</li>
<li><p> &quot;keep&quot;: Same grouping structure as <code>.data</code>.
</p>
</li>
<li><p> &quot;rowwise&quot;: Each row is its own group.
</p>
</li></ul>

<p>When <code>.groups</code> is not specified, it is chosen
based on the number of rows of the results:
</p>

<ul>
<li><p> If all the results have 1 row, you get &quot;drop_last&quot;.
</p>
</li>
<li><p> If the number of rows varies, you get &quot;keep&quot;.
</p>
</li></ul>

<p>In addition, a message informs you of that choice, unless the result is ungrouped,
the option &quot;dplyr.summarise.inform&quot; is set to <code>FALSE</code>,
or when <code>summarise()</code> is called from a function in a package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>.data</code> with summarized columns. If the <code>spectra</code> column is dropped
or invalidated (see <code><a href="#topic+ir_new_ir">ir_new_ir()</a></code>), the <code>ir</code> class is dropped, else the
object is of class <code>ir</code>.
</p>


<h3>Source</h3>

<p><code><a href="dplyr.html#topic+summarise">dplyr::summarize()</a></code>
</p>


<h3>See Also</h3>

<p>Other tidyverse: 
<code><a href="#topic+arrange.ir">arrange.ir</a>()</code>,
<code><a href="#topic+distinct.ir">distinct.ir</a>()</code>,
<code><a href="#topic+extract.ir">extract.ir</a>()</code>,
<code><a href="#topic+filter-joins">filter-joins</a></code>,
<code><a href="#topic+filter.ir">filter.ir</a>()</code>,
<code><a href="#topic+group_by">group_by</a></code>,
<code><a href="#topic+mutate-joins">mutate-joins</a></code>,
<code><a href="#topic+mutate">mutate</a></code>,
<code><a href="#topic+nest">nest</a></code>,
<code><a href="#topic+pivot_longer.ir">pivot_longer.ir</a>()</code>,
<code><a href="#topic+pivot_wider.ir">pivot_wider.ir</a>()</code>,
<code><a href="#topic+rename">rename</a></code>,
<code><a href="#topic+rowwise.ir">rowwise.ir</a>()</code>,
<code><a href="#topic+select.ir">select.ir</a>()</code>,
<code><a href="#topic+separate.ir">separate.ir</a>()</code>,
<code><a href="#topic+separate_rows.ir">separate_rows.ir</a>()</code>,
<code><a href="#topic+slice">slice</a></code>,
<code><a href="#topic+unite.ir">unite.ir</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## summarize

# select in each sample_type groups the first spectrum
ir_sample_data %&gt;%
  dplyr::group_by(sample_type) %&gt;%
  dplyr::summarize(spectra = spectra[[1]])


</code></pre>

<hr>
<h2 id='unite.ir'>Unite multiple columns in an <code>ir</code> object into one by pasting strings together</h2><span id='topic+unite.ir'></span>

<h3>Description</h3>

<p>Unite multiple columns in an <code>ir</code> object into one by pasting strings together
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unite.ir(data, col, ..., sep = "_", remove = TRUE, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unite.ir_+3A_data">data</code></td>
<td>
<p>An object of class <code>ir</code>.</p>
</td></tr>
<tr><td><code id="unite.ir_+3A_col">col</code></td>
<td>
<p>The name of the new column, as a string or symbol.
</p>
<p>This argument is passed by expression and supports
<a href="rlang.html#topic+nse-force">quasiquotation</a> (you can unquote strings
and symbols). The name is captured from the expression with
<code><a href="rlang.html#topic+nse-defuse">rlang::ensym()</a></code> (note that this kind of interface where
symbols do not represent actual objects is now discouraged in the
tidyverse; we support it here for backward compatibility).</p>
</td></tr>
<tr><td><code id="unite.ir_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; Columns to unite</p>
</td></tr>
<tr><td><code id="unite.ir_+3A_sep">sep</code></td>
<td>
<p>Separator to use between values.</p>
</td></tr>
<tr><td><code id="unite.ir_+3A_remove">remove</code></td>
<td>
<p>If <code>TRUE</code>, remove input columns from output data frame.</p>
</td></tr>
<tr><td><code id="unite.ir_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>TRUE</code>, missing values will be remove prior to uniting
each value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>.data</code> with united columns. If the <code>spectra</code> column is
dropped or invalidated (see <code><a href="#topic+ir_new_ir">ir_new_ir()</a></code>), the <code>ir</code> class is dropped, else
the object is of class <code>ir</code>.
</p>


<h3>Source</h3>

<p><code><a href="tidyr.html#topic+unite">tidyr::unite()</a></code>
</p>


<h3>See Also</h3>

<p>Other tidyverse: 
<code><a href="#topic+arrange.ir">arrange.ir</a>()</code>,
<code><a href="#topic+distinct.ir">distinct.ir</a>()</code>,
<code><a href="#topic+extract.ir">extract.ir</a>()</code>,
<code><a href="#topic+filter-joins">filter-joins</a></code>,
<code><a href="#topic+filter.ir">filter.ir</a>()</code>,
<code><a href="#topic+group_by">group_by</a></code>,
<code><a href="#topic+mutate-joins">mutate-joins</a></code>,
<code><a href="#topic+mutate">mutate</a></code>,
<code><a href="#topic+nest">nest</a></code>,
<code><a href="#topic+pivot_longer.ir">pivot_longer.ir</a>()</code>,
<code><a href="#topic+pivot_wider.ir">pivot_wider.ir</a>()</code>,
<code><a href="#topic+rename">rename</a></code>,
<code><a href="#topic+rowwise.ir">rowwise.ir</a>()</code>,
<code><a href="#topic+select.ir">select.ir</a>()</code>,
<code><a href="#topic+separate.ir">separate.ir</a>()</code>,
<code><a href="#topic+separate_rows.ir">separate_rows.ir</a>()</code>,
<code><a href="#topic+slice">slice</a></code>,
<code><a href="#topic+summarize">summarize</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## unite
ir_sample_data %&gt;%
  tidyr::separate(
    "id_sample",  c("a", "b", "c")
  ) %&gt;%
  tidyr::unite(id_sample, a, b, c)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
