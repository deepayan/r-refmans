<!DOCTYPE html><html><head><title>Help for package comsimitv</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {comsimitv}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#asymmetric.competition.kernel'><p>Asymmetric competition kernels</p></a></li>
<li><a href='#comm.sampling'><p>Converting simulation results into site-by-species matrix</p></a></li>
<li><a href='#comm.simul'><p>Framework for community assembly simulation</p></a></li>
<li><a href='#competition.kernel'><p>Competition kernels</p></a></li>
<li><a href='#fDispersal'><p>User defined functions for dispersal</p></a></li>
<li><a href='#fITV'><p>Intraspecific Trait Variation</p></a></li>
<li><a href='#Gaussian.competition.kernel'><p>Gaussian competition kernel</p></a></li>
<li><a href='#Gaussian.tolerance'><p>Bell-shaped tolerance function</p></a></li>
<li><a href='#Gener.species.pool'><p>Generating trait values for the species pool</p></a></li>
<li><a href='#MetaCom.Dispersal'><p>Seed dispersion in a metacommunity</p></a></li>
<li><a href='#randomITV'><p>Intraspecific Trait Variation</p></a></li>
<li><a href='#SeedProduction'><p>Calculating number of produced seeds</p></a></li>
<li><a href='#tolerance'><p>Habitat suitability (tolerance) functions</p></a></li>
<li><a href='#trait.sampling'><p>Simulated sampling for trait value measurement</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Flexible Framework for Simulating Community Assembly</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.5</td>
</tr>
<tr>
<td>Author:</td>
<td>Zoltan Botta-Dukat</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Zoltan Botta-Dukat &lt;botta-dukat.zoltan@okologia.mta.hu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Flexible framework for trait-based simulation of community assembly, where components could be replaced by user-defined function and that
             allows variation of traits within species.</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, vegan</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, markdown, rmarkdown, testthat, bookdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-07-08 09:07:01 UTC; bfakos</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-07-17 16:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='asymmetric.competition.kernel'>Asymmetric competition kernels</h2><span id='topic+asymmetric.competition.kernel'></span>

<h3>Description</h3>

<p>It calculates asymmetric competition coefficients
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asymmetric.competition.kernel(
  trait.values,
  trait.compet = "trait.b",
  ac.type = c("Kisdi", "Nattrass"),
  sigma.b = 0.03,
  ac.C = 1,
  ac.v = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asymmetric.competition.kernel_+3A_trait.values">trait.values</code></td>
<td>
<p>Dataframe of all traits</p>
</td></tr>
<tr><td><code id="asymmetric.competition.kernel_+3A_trait.compet">trait.compet</code></td>
<td>
<p>Name of trait related to resource use</p>
</td></tr>
<tr><td><code id="asymmetric.competition.kernel_+3A_ac.type">ac.type</code></td>
<td>
<p>Type of the function (see <code>vignette("competition")</code>)</p>
</td></tr>
<tr><td><code id="asymmetric.competition.kernel_+3A_sigma.b">sigma.b</code></td>
<td>
<p>steepness of competition kernel</p>
</td></tr>
<tr><td><code id="asymmetric.competition.kernel_+3A_ac.c">ac.C</code></td>
<td>
<p>parameter influencing shape of the function (has to be positive)</p>
</td></tr>
<tr><td><code id="asymmetric.competition.kernel_+3A_ac.v">ac.v</code></td>
<td>
<p>parameter influencing shape of the function (has to be positive)</p>
</td></tr>
<tr><td><code id="asymmetric.competition.kernel_+3A_...">...</code></td>
<td>
<p>Any additional parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on value of ac.type the convex-concave function from Kisdi (1999)
or  smooth function suggested by Nattrass et al (2012) are used.
</p>
<p>For formulas and meaning of parameters see the <code>vignette("competition")</code>
</p>


<h3>References</h3>

<p>Kisdi, E. (1999) Evolutionary Branching under Asymmetric
Competition
<em>Journal of Theoretical Biology</em> <b>197</b>(2): 149-162.
doi: <a href="https://doi.org/10.1006/jtbi.1998.0864">10.1006/jtbi.1998.0864</a>
</p>
<p>Nattrass, S., Baigent, S., &amp; Murrell, D. J. (2012) Quantifying
the Likelihood of Co-existence for Communities with Asymmetric Competition.
<em>Bulletin of Mathematical Biology</em>, <b>74</b>(10): 2315â€“2338.
doi: <a href="https://doi.org/10.1007/s11538-012-9755-8">10.1007/s11538-012-9755-8</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+competition.kernel">competition.kernel</a></code>
</p>

<hr>
<h2 id='comm.sampling'>Converting simulation results into site-by-species matrix</h2><span id='topic+comm.sampling'></span>

<h3>Description</h3>

<p>Converts simulation result into site-by-species matrix of abundances,
and optionally in the same step simulates random sampling with fixed number of individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comm.sampling(x, type = c("full", "random"), size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comm.sampling_+3A_x">x</code></td>
<td>
<p>community and trait data matrix produced by <code><a href="#topic+comm.simul">comm.simul</a></code>
function</p>
</td></tr>
<tr><td><code id="comm.sampling_+3A_type">type</code></td>
<td>
<p>Type of sampling. If <code>type=="full"</code> sample size equals to community size.
It simply converts <code>x</code> into a site-by-species matrix
If <code>type=="random"</code>, it applies random sampling by calling (<code><a href="vegan.html#topic+rrarefy">rrarefy</a></code>) function</p>
</td></tr>
<tr><td><code id="comm.sampling_+3A_size">size</code></td>
<td>
<p>Number of individuals in the random samples. It should be smaller
than number of individuals in simulated (sub)communities. Otherwise,
<code>x</code> is converted into a site-by-species matrix without (re)sampling</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>type=="full"</code> it simply converts simulation results from long to wide format.
If <code>type=="random"</code> it randomly selects <code>size</code> individuals in each (sub)community
and abundances in these samples are converted into site-by-species matrix format.
</p>


<h3>Value</h3>

<p>A site-by-species matrix containing abundances.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-comm.simul(S=20, J=30)
str(x$final.community)

w&lt;-comm.sampling(x$final.community,type="full")
str(w)

w.rarefied&lt;-comm.sampling(x$final.community,type="random",size=10)
rowSums(w)
rowSums(w.rarefied)

</code></pre>

<hr>
<h2 id='comm.simul'>Framework for community assembly simulation</h2><span id='topic+comm.simul'></span>

<h3>Description</h3>

<p>Flexible framework of individual-based simulation of community assembly
following framework proposed by Botta-Dukat &amp; Czucz (2016), but allowing
intraspecific trait variation (ITV)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comm.simul(
  x = vector(),
  S = 200,
  n.traits = 3,
  J = 300,
  rand.seed = NULL,
  sim.length = 1,
  fSpecPool = "Gener.species.pool",
  competition.kernel = "Gaussian.competition.kernel",
  fSurvive = "Gaussian.tolerance",
  fSeedProduction = "SeedProduction",
  fDispersal = "MetaCom.Dispersal",
  fITV = "randomITV",
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comm.simul_+3A_x">x</code></td>
<td>
<p>Vector of environmental values in communities. If not given, 40
communities are created, with environmental variable equally
spacing from 0.11 to 0.89</p>
</td></tr>
<tr><td><code id="comm.simul_+3A_s">S</code></td>
<td>
<p>Species pool size</p>
</td></tr>
<tr><td><code id="comm.simul_+3A_n.traits">n.traits</code></td>
<td>
<p>Number of traits</p>
</td></tr>
<tr><td><code id="comm.simul_+3A_j">J</code></td>
<td>
<p>Number of individuals in each community</p>
</td></tr>
<tr><td><code id="comm.simul_+3A_rand.seed">rand.seed</code></td>
<td>
<p>Random seed number. Setting the same value allows repeating
the same simulation</p>
</td></tr>
<tr><td><code id="comm.simul_+3A_sim.length">sim.length</code></td>
<td>
<p>Length of simulation. <code>sim.length*S</code> cycle (disturbance-seed
production-dispersal-establishment) will happen.</p>
</td></tr>
<tr><td><code id="comm.simul_+3A_fspecpool">fSpecPool</code></td>
<td>
<p>Name of (the user defined) function that generates the
species pool. See <code><a href="#topic+Gener.species.pool">Gener.species.pool</a></code></p>
</td></tr>
<tr><td><code id="comm.simul_+3A_competition.kernel">competition.kernel</code></td>
<td>
<p>Name of the (user defined) function for calculating
pairwise competition coefficients. See more details
in available functions and specification of your own
function in <code><a href="#topic+competition.kernel">competition.kernel</a></code></p>
</td></tr>
<tr><td><code id="comm.simul_+3A_fsurvive">fSurvive</code></td>
<td>
<p>Name of the (user defined) function for calculating survival
probability of seeds. See more details
in available functions and specification of your own
function in <code><a href="#topic+tolerance">tolerance</a></code></p>
</td></tr>
<tr><td><code id="comm.simul_+3A_fseedproduction">fSeedProduction</code></td>
<td>
<p>Name of the user defined function for calculating
number of produced seeds See <code><a href="#topic+SeedProduction">SeedProduction</a></code></p>
</td></tr>
<tr><td><code id="comm.simul_+3A_fdispersal">fDispersal</code></td>
<td>
<p>Name of the user defined function for dispersal of
produced seeds among local communities.
See more details in available functions and specification
of your own function in <code><a href="#topic+fDispersal">fDispersal</a></code></p>
</td></tr>
<tr><td><code id="comm.simul_+3A_fitv">fITV</code></td>
<td>
<p>Name of the function that define seeds trait values, possibly
considering mother's trait and mothers environment.
If &quot;noITV&quot;, there is no intraspecific trait variation.
See more details in available functions and specification
of your own function in <code><a href="#topic+fITV">fITV</a></code></p>
</td></tr>
<tr><td><code id="comm.simul_+3A_verbose">verbose</code></td>
<td>
<p>Runing may take long time. If <code>verbose</code> set to <code>TRUE</code>,
it writes messages into the screen indicating the progress.</p>
</td></tr>
<tr><td><code id="comm.simul_+3A_...">...</code></td>
<td>
<p>Additional parameters of functions called by the framework.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a framework for simulation of assembly in a meta-community.
The simulation consists of a community initialization followed by an
iterative simulation of a &quot;disturbanceâ€“regeneration&quot; cycle.
During initialization a species pool is created defining each species by
its trait values. Each locality is characterized by an environmental variable.
Initial composition of local communities is a random selection from the species
pool: species identity is selected independently for each individal with
probability of seedling survival (that depends on local environment and trait value).
</p>
<p>The &quot;disturbance-regeneration&quot; cycle consists of the following steps:
</p>

<ol>
<li><p> disturbance event: some randomly selected individuals
die in each community
</p>
</li>
<li><p> survivors produce seeds. Seed production depends on fertility
of the locality and competition among coexisting individuals
</p>
</li>
<li><p> seeds are dispersed among localities
</p>
</li>
<li><p> all seeds germinate and seedlings struggle for survival. The number of
adults in local communities is fixed, thus number of seedlings that can
survive and grow up equals to the number of individulas died in the
disturbance event (in the recent version one individual dies, but planed development
is introducing a disturbance severity/number of deaths parameter)
</p>
</li></ol>

<p>It is a flexible framework that calls funcions for:
</p>

<ul>
<li><p> generating species pool
(<code><a href="#topic+Gener.species.pool">Gener.species.pool</a></code>)
</p>
</li>
<li><p> calculating pairwise competition coefficients
(<code><a href="#topic+competition.kernel">competition.kernel</a></code>)
</p>
</li>
<li><p> calculating seedling's survival probabilities
(<code><a href="#topic+tolerance">tolerance</a></code>)
</p>
</li>
<li><p> calculating number of produced seeds
(<code><a href="#topic+SeedProduction">SeedProduction</a></code>)
</p>
</li>
<li><p> calculating trait values of offsprings
(<code><a href="#topic+fITV">fITV</a></code>)
</p>
</li>
<li><p> seed dispersal among localities
(<code><a href="#topic+fDispersal">fDispersal</a></code>)
</p>
</li></ul>

<p>Functions available in the package can be easily replaced by user-defined
functions.
</p>


<h3>Value</h3>

<p>A list with two elements:
</p>
<p><code>$final.community</code> a dataframe containing data on individuals in the final meta-community.
Each individual represented by a row; columns are: sub-community,
species identity, trait values.
</p>
<p><code>$parameters</code> list of simulation parameters (including parameters of functions called by the framework function)
</p>


<h3>References</h3>

<p>Botta-Dukat Z, Czucz B (2016) Testing the ability of
functional diversity indices to detect trait convergence and divergence
using individual-based simulation.
<em>Methods in Ecology and Evolution</em> <b>7</b>(1): 114-126.
doi: <a href="https://doi.org/10.1111/2041-210X.12450">10.1111/2041-210X.12450</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>w&lt;-comm.simul(S=20, J=30)
str(w)

set.seed(1)
w&lt;-comm.simul(S=20, J=30, fITV=NULL)$final.community
w[w[,2]==1,] # Each individuals belonging to Species1 has the same trait values
</code></pre>

<hr>
<h2 id='competition.kernel'>Competition kernels</h2><span id='topic+competition.kernel'></span>

<h3>Description</h3>

<p>User defined functions for calculating pairwise competition coefficients
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="competition.kernel_+3A_trait.values">trait.values</code></td>
<td>
<p>Values of trait related to resource use</p>
</td></tr>
<tr><td><code id="competition.kernel_+3A_...">...</code></td>
<td>
<p>Additional parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>User can defined any specific from of competition.
Pairwise competition between species/individuals should depend on their
trait values related to resource use. Vector of these trait values has to be
the first parameter of the function, and any further parameters are allowed.
The output has to be a square matrix of pairwise competition coefficients.
</p>
<p>Competition kernels available in the package: <br />
<code><a href="#topic+asymmetric.competition.kernel">asymmetric.competition.kernel</a></code> <br />
<code><a href="#topic+Gaussian.competition.kernel">Gaussian.competition.kernel</a></code> <br />
</p>


<h3>Value</h3>

<p>Square matrix of pairwise competition coefficients
</p>

<hr>
<h2 id='fDispersal'>User defined functions for dispersal</h2><span id='topic+fDispersal'></span>

<h3>Description</h3>

<p>These functions define how seeds can spread among local communities.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="fDispersal_+3A_before">before</code></td>
<td>
<p>matrix where each seed is represented by one row, and seeds's attributes (location, species, trait values) are in the columns</p>
</td></tr>
<tr><td><code id="fDispersal_+3A_...">...</code></td>
<td>
<p>Additional parameters of functions called by the framework.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>User can define any rule for seed dispersal. The only requirement is that both first argument and value of the function should be a matrix where each seed is represented by one row, and seeds's attributes (location, species, trait values) are in the columns. The locality information has to be stored in column named 'site'.
</p>
<p>Available function in the package:
</p>
<p><code><a href="#topic+MetaCom.Dispersal">MetaCom.Dispersal</a></code>
</p>


<h3>Value</h3>

<p>Same type as the first argument.
</p>

<hr>
<h2 id='fITV'>Intraspecific Trait Variation</h2><span id='topic+fITV'></span>

<h3>Description</h3>

<p>User defined function for Intraspecific Trait Variation
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="fITV_+3A_seeds">seeds</code></td>
<td>
<p>Matrix of produced seeds (with mother's trait values) as produced by
<code><a href="#topic+SeedProduction">SeedProduction</a></code> function</p>
</td></tr>
<tr><td><code id="fITV_+3A_...">...</code></td>
<td>
<p>Other parameters of the function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>User can defined any specific function for ITV, e.g. random variation around mothers value, or maternal effect.
</p>
<p>The first parameter has to be matrix of produced seeds, in the form as it created by <code><a href="#topic+SeedProduction">SeedProduction</a></code> function, and the results has to be in the same matrix form with updated trait values.
</p>
<p>ITV functions available in the package:
</p>
<p><code><a href="#topic+randomITV">randomITV</a></code>
</p>


<h3>Value</h3>

<p>The same type as <code>seeds</code> parameter, i.e. a matrix where each seed is represented by one row, and seeds's attributes (location, species, trait values) are in the columns
</p>

<hr>
<h2 id='Gaussian.competition.kernel'>Gaussian competition kernel</h2><span id='topic+Gaussian.competition.kernel'></span>

<h3>Description</h3>

<p>It calculates pairwise competition coefficients as overlap of Gaussian resource utilization curve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Gaussian.competition.kernel(
  trait.values,
  trait.compet = "trait.b",
  sigma.b = 0.03,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Gaussian.competition.kernel_+3A_trait.values">trait.values</code></td>
<td>
<p>Dataframe of all traits</p>
</td></tr>
<tr><td><code id="Gaussian.competition.kernel_+3A_trait.compet">trait.compet</code></td>
<td>
<p>Name of trait related to resource use</p>
</td></tr>
<tr><td><code id="Gaussian.competition.kernel_+3A_sigma.b">sigma.b</code></td>
<td>
<p>Width of Gaussian kernel</p>
</td></tr>
<tr><td><code id="Gaussian.competition.kernel_+3A_...">...</code></td>
<td>
<p>Any additional parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It assumes that each species has Gaussian resource utilization curve:
</p>
<p style="text-align: center;"><code class="reqn">\exp(\frac{(x-trait.value)^2}{sigma.b})</code>
</p>

<p>where:      x = quality of resource (e.g. seed size or rooting depth<br />
</p>
<p>Optima of curves depend on trait value related to resource use,
while standard deviation is the same for all species (note that for technical reason
parameter <code>sigma.b</code> is twice of the common sqared s.d.).
Pairwise competition coefficients are calculated as overlap of
resource utilization functions (MacArthur &amp; Levins 1967).See details in
<code>vignette("competition")</code>
</p>


<h3>References</h3>

<p>MacArthur R, Levins R (1967) The Limiting Similarity,
Convergence, and Divergence of Coexisting Species.
<em>The American Naturalist</em> <b>101</b>: 377-385.
doi: <a href="https://doi.org/10.1086/282505">10.1086/282505</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+competition.kernel">competition.kernel</a></code>
</p>

<hr>
<h2 id='Gaussian.tolerance'>Bell-shaped tolerance function</h2><span id='topic+Gaussian.tolerance'></span>

<h3>Description</h3>

<p>It calculates probability of seedling's survival from their trait related to habitat filtering and the local environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Gaussian.tolerance(
  trait.values,
  env,
  env.trait = "trait.a",
  sigma.a = 0.001,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Gaussian.tolerance_+3A_trait.values">trait.values</code></td>
<td>
<p>Dataframe of all traits</p>
</td></tr>
<tr><td><code id="Gaussian.tolerance_+3A_env">env</code></td>
<td>
<p>Vector of environmental conditions in the local communities</p>
</td></tr>
<tr><td><code id="Gaussian.tolerance_+3A_env.trait">env.trait</code></td>
<td>
<p>Name of trait related to environmental tolerance</p>
</td></tr>
<tr><td><code id="Gaussian.tolerance_+3A_sigma.a">sigma.a</code></td>
<td>
<p>Tolerance width (same for all species)</p>
</td></tr>
<tr><td><code id="Gaussian.tolerance_+3A_...">...</code></td>
<td>
<p>Any additional parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It assumes that probability of seedling's survival is maximal if the local
environment has the same value as its trait. Survival probability decrease as
environmental value departs from the optimum according to a Gaussian (bell-shaped)
curve. The speed of decrease depends on the tolerance width parameter (<code>sigma.a</code>).
</p>


<h3>Value</h3>

<p>A matrix of survival probabilities, communities in rows, species/individuals in columns
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tolerance">tolerance</a></code>
</p>

<hr>
<h2 id='Gener.species.pool'>Generating trait values for the species pool</h2><span id='topic+Gener.species.pool'></span>

<h3>Description</h3>

<p>It generates random trait values for species. Each species (individual)
are characterized by three traits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Gener.species.pool(
  S,
  n.traits = 3,
  distribs = rep("unif", n.traits),
  distr.parms = list(),
  sigma = diag(1, n.traits, n.traits),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Gener.species.pool_+3A_s">S</code></td>
<td>
<p>Species pool size</p>
</td></tr>
<tr><td><code id="Gener.species.pool_+3A_n.traits">n.traits</code></td>
<td>
<p>Number of traits</p>
</td></tr>
<tr><td><code id="Gener.species.pool_+3A_distribs">distribs</code></td>
<td>
<p>Types of the distributions of traits</p>
</td></tr>
<tr><td><code id="Gener.species.pool_+3A_distr.parms">distr.parms</code></td>
<td>
<p>Parameters of distribution (see Details)</p>
</td></tr>
<tr><td><code id="Gener.species.pool_+3A_sigma">sigma</code></td>
<td>
<p>Matrix of variance-covariance matrix of traits</p>
</td></tr>
<tr><td><code id="Gener.species.pool_+3A_...">...</code></td>
<td>
<p>Any additional parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each species are characterized by three traits called trait A,
B and C. Trait A describes the habitat preference,
trait B influences the competitive interactions, while trait C
is a completely neutral trait.
</p>
<p>Any standard distribution of stats package can be used for generating
the random numbers. For list of these distribution see <code><a href="stats.html#topic+Distributions">Distributions</a></code>
In stats package the functions for the density/mass function are named
in the form dxxx.&quot;xxx&quot; (without d!) as string (i.e. between quatation marks)
should be supplied for parameter <code>distribs</code>.
</p>
<p>In this step single value of each trait is generated for each species,
i.e. there is no intraspecific trait variation.
</p>
<p>If traits are independent (it is the default option), random number
generating functions are called with parameters specified by the user.
</p>
<p>Otherwise, a variance-covariance matrix has to be given. First, triplets of
random numbers are drawn from multivariate normal distribution with zero
means and the supplied variance-covariance matrix as parameters.
Then these random numbers are converted to probability by standard normal
probability function, and then these probabilities converted to trait values
using quantile function of selected distribution with parameters given
by the user.
</p>


<h3>Value</h3>

<p>A data frame with traits as columns
</p>

<hr>
<h2 id='MetaCom.Dispersal'>Seed dispersion in a metacommunity</h2><span id='topic+MetaCom.Dispersal'></span>

<h3>Description</h3>

<p>Seeds can disperse to any other local community with the same probability;
i.e. probability to disperse other subcommunity/(number local communities - 1). Each seed is dispersed independently.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MetaCom.Dispersal(n, before, m = 0.1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MetaCom.Dispersal_+3A_n">n</code></td>
<td>
<p>number of local (sub)communities</p>
</td></tr>
<tr><td><code id="MetaCom.Dispersal_+3A_before">before</code></td>
<td>
<p>A matrix of seed's attributes; seeds in rows, their location,
species identity and traits are in columns. Column that contains information on
locality has to be called 'site'</p>
</td></tr>
<tr><td><code id="MetaCom.Dispersal_+3A_m">m</code></td>
<td>
<p>probability that a seed are dispersed into other (sub)community</p>
</td></tr>
<tr><td><code id="MetaCom.Dispersal_+3A_...">...</code></td>
<td>
<p>Additional parameters. It necessary for thechnical reasons: the framework don't know the current list of parameters when call this function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both input and output is a matrix where seeds are in the rows, and their
attributes (i.e. location, species identity and trait values) are in the
columns.
</p>


<h3>Value</h3>

<p>Same type of matrix as <code>before</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fDispersal">fDispersal</a></code>
</p>

<hr>
<h2 id='randomITV'>Intraspecific Trait Variation</h2><span id='topic+randomITV'></span>

<h3>Description</h3>

<p>This function adds a random noise to mother's trait values of each seed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randomITV(
  seeds = matrix(),
  n.traits = 3,
  distribs = rep("unif", n.traits),
  distr.parms = list(),
  sigma = diag(1, n.traits, n.traits),
  ITV.ratio = 0.01,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randomITV_+3A_seeds">seeds</code></td>
<td>
<p>Matrix of produced seeds (with mother'trait values) as produced by
<code><a href="#topic+SeedProduction">SeedProduction</a></code> function</p>
</td></tr>
<tr><td><code id="randomITV_+3A_n.traits">n.traits</code></td>
<td>
<p>Number of traits</p>
</td></tr>
<tr><td><code id="randomITV_+3A_distribs">distribs</code></td>
<td>
<p>Types of the distributions of traits (see <code><a href="#topic+Gener.species.pool">Gener.species.pool</a></code>)</p>
</td></tr>
<tr><td><code id="randomITV_+3A_distr.parms">distr.parms</code></td>
<td>
<p>Parameters of distribution (see <code><a href="#topic+Gener.species.pool">Gener.species.pool</a></code>)</p>
</td></tr>
<tr><td><code id="randomITV_+3A_sigma">sigma</code></td>
<td>
<p>Matrix of variance-covariance matrix of traits (see <code><a href="#topic+Gener.species.pool">Gener.species.pool</a></code>)</p>
</td></tr>
<tr><td><code id="randomITV_+3A_itv.ratio">ITV.ratio</code></td>
<td>
<p>Ratio of within/between species variances of traits</p>
</td></tr>
<tr><td><code id="randomITV_+3A_...">...</code></td>
<td>
<p>Any additional parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses parameters of <code><a href="#topic+Gener.species.pool">Gener.species.pool</a></code>. First it
transforms back mother's trait values to multivariate normal distribution.
Then random noise was added to this values. Random noise has multivariate
normal distribution, with zero means and the same  <strong>correlation</strong> structure
as specified in parameter <em>sigma</em>. <strong>Note</strong> that <em>sigma</em> specifies
covariance matrix, not correlation structure <em>per se</em>. Variances in the random noise
are diagonals (i.e. variance componens) of parameter <em>sigma</em> multiplied by
<em>ITV.ratio</em>. The non-diagonal elements of covariance matrix were specified
to conserve the correlation structure among traits.
</p>


<h3>Value</h3>

<p>Matrix of produced seeds as produced by
<code><a href="#topic+SeedProduction">SeedProduction</a></code> function
</p>

<hr>
<h2 id='SeedProduction'>Calculating number of produced seeds</h2><span id='topic+SeedProduction'></span>

<h3>Description</h3>

<p>Number of seeds calculated following the formula used by Botta-Dukat &amp; Czucz (2016).
This built-in function can be replaced by a user-defined one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SeedProduction(compet, b0 = 1, K = 200, seed.distrib = c("pois", "binom"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SeedProduction_+3A_compet">compet</code></td>
<td>
<p>Matrix of pairwise competition coefficients</p>
</td></tr>
<tr><td><code id="SeedProduction_+3A_b0">b0</code></td>
<td>
<p>Probability of producing seed, if no competition</p>
</td></tr>
<tr><td><code id="SeedProduction_+3A_k">K</code></td>
<td>
<p>Critical level of competition (See Details)</p>
</td></tr>
<tr><td><code id="SeedProduction_+3A_seed.distrib">seed.distrib</code></td>
<td>
<p>Distribution of seed numbers (See Details)</p>
</td></tr>
<tr><td><code id="SeedProduction_+3A_...">...</code></td>
<td>
<p>any additional parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Expected value of produced seeds is a decreasing sigmoid function of strength of
competition  (sum of abundances weighted by competition coefficients).
If strength of competition is higher than parameter K, probability is set to
zero. See <code>vignette("competition")</code> for formulas
</p>
<p>In simulation of Botta-Dukat &amp; Czucz (2016) each individual produces one seed or does 
not produce seed at all. In this case number of seeds follows binomial distribution 
(i.e. distrib=&quot;binom&quot;). A more realistic alternative is using Poisson distribution 
(distrib=&quot;pois&quot;).
</p>


<h3>Value</h3>

<p>Matrix of produced seeds
</p>

<hr>
<h2 id='tolerance'>Habitat suitability (tolerance) functions</h2><span id='topic+tolerance'></span>

<h3>Description</h3>

<p>User defined functions for habitat suitability
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="tolerance_+3A_trait.values">trait.values</code></td>
<td>
<p>Values of trait related to habitat filtering</p>
</td></tr>
<tr><td><code id="tolerance_+3A_env">env</code></td>
<td>
<p>Vector of environmental conditions in the local communities</p>
</td></tr>
<tr><td><code id="tolerance_+3A_...">...</code></td>
<td>
<p>Additional parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>User can defined any specific function of habitat suitability, depending on environmental conditions and trait value related to habitat filtering.
Vectors of these trait values and environmental conditions have to be
the first and second parameter of the function, and any further parameters are allowed.
The output has to be a matrix of habitat suitabilities, communities in rows, species/individuals in columns.
</p>
<p>Tolerance functions available in the package:
</p>
<p><code><a href="#topic+Gaussian.tolerance">Gaussian.tolerance</a></code>
</p>


<h3>Value</h3>

<p>A matrix of habitat suitabilities, communities in rows, individuals in columns
</p>

<hr>
<h2 id='trait.sampling'>Simulated sampling for trait value measurement</h2><span id='topic+trait.sampling'></span>

<h3>Description</h3>

<p>Randomly selects individuals for trait value measurement and gives back raw measured
traits or their means
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trait.sampling(x, ITV = FALSE, aggregate = TRUE, n = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trait.sampling_+3A_x">x</code></td>
<td>
<p>community and trait data matrix produced by <code><a href="#topic+comm.simul">comm.simul</a></code>
function</p>
</td></tr>
<tr><td><code id="trait.sampling_+3A_itv">ITV</code></td>
<td>
<p>If <code>TRUE</code> each subcommunity are sampled separately, otherwise
the meta-community level sampling was done</p>
</td></tr>
<tr><td><code id="trait.sampling_+3A_aggregate">aggregate</code></td>
<td>
<p>If <code>TRUE</code> mean trait values are returned, otherwise the raw values
of sampled individuals</p>
</td></tr>
<tr><td><code id="trait.sampling_+3A_n">n</code></td>
<td>
<p>Number of sampled individuals</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It simulates the real world situation that not all individuals are collected for trait measurement.
If <code>ITV==FALSE</code>, all individuals belonging to the species are pooled, and then <code>n</code>
randomly selected individuals are measured. If <code>ITV==TRUE</code>, <code>n</code> individuals are
measured in each (sub)community, where the species occur. If the occurring individuals are
less than <code>n</code>, all individuals are measured.
</p>
<p>If <code>aggregate==TRUE</code>, meta-community or subcommunity level means are calculated, otherwise
raw measurements are returned.
</p>


<h3>Value</h3>

<p>data.frame with fields: <code>species</code>, <code>site</code> (only if <code>ITV=TRUE</code>),
<code>trait.a</code>, <code>trait.b</code>, <code>trait.c</code> (raw values or means depending on parameter <code>aggregate</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-comm.simul(S=20, J=30)
str(x)

w&lt;-trait.sampling(x$final.community)
w

w&lt;-trait.sampling(x$final.community,ITV=TRUE,aggregate=TRUE)
str(w)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
