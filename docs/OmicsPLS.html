<!DOCTYPE html><html><head><title>Help for package OmicsPLS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {OmicsPLS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adjR2'><p>Gridwise adjusted R2 for O2PLS</p></a></li>
<li><a href='#crossval_o2m'><p>Cross-validate procedure for O2PLS</p></a></li>
<li><a href='#crossval_o2m_adjR2'><p>Adjusted Cross-validate procedure for O2PLS</p></a></li>
<li><a href='#crossval_sparsity'><p>Perform cross-validation to find the optimal number of variables/groups to keep for each joint component</p></a></li>
<li><a href='#cv_lambda_checker'><p>Check if sparsity parameters satisfy input conditions in cross-validation functions</p></a></li>
<li><a href='#cv_lambda_checker_group'><p>Check if sparsity parameters satisfy input conditions in cross-validation functions</p></a></li>
<li><a href='#err_back'><p>Internal function for crossval_sparsity</p></a></li>
<li><a href='#impute_matrix'><p>Impute missing values in a matrix</p></a></li>
<li><a href='#input_checker'><p>Check if matrices satisfy input conditions</p></a></li>
<li><a href='#lambda_checker'><p>Check if penalization parameters satisfy input conditions</p></a></li>
<li><a href='#lambda_checker_group'><p>Check if penalization parameters for groups satisfy input conditions</p></a></li>
<li><a href='#loadings'><p>Extract the loadings from an O2PLS fit</p></a></li>
<li><a href='#loocv'><p>K fold CV for O2PLS</p></a></li>
<li><a href='#loocv_combi'><p>K-fold CV based on symmetrized prediction error</p></a></li>
<li><a href='#mse'><p>Calculate mean squared difference</p></a></li>
<li><a href='#norm_vec'><p>Norm of a vector</p></a></li>
<li><a href='#o2m'><p>Perform O2PLS data integration with two-way orthogonal corrections</p></a></li>
<li><a href='#o2m_stripped'><p>Perform O2-PLS with two-way orthogonal corrections</p></a></li>
<li><a href='#o2m_stripped2'><p>Perform O2-PLS with two-way orthogonal corrections</p></a></li>
<li><a href='#o2m2'><p>Perform O2-PLS with two-way orthogonal corrections</p></a></li>
<li><a href='#OmicsPLS'><p>Data integration with O2PLS: Two-Way Orthogonal Partial Least Squares</p></a></li>
<li><a href='#orth'><p>Orthogonalize a matrix</p></a></li>
<li><a href='#orth_vec'><p>Orthogonalize a sparse loading vector with regard to a matrix</p></a></li>
<li><a href='#plot.o2m'><p>Plot one or two loading vectors for class o2m</p></a></li>
<li><a href='#pow_o2m'><p>NIPALS method for PLS2</p></a></li>
<li><a href='#pow_o2m2'><p>Power method for PLS2</p></a></li>
<li><a href='#predict.o2m'><p>Predicts X or Y</p></a></li>
<li><a href='#print.cvo2m'><p>Cross-validate procedure for O2PLS</p></a></li>
<li><a href='#print.o2m'><p>Print function for O2PLS.</p></a></li>
<li><a href='#print.pre.o2m'><p>Print function for O2PLS.</p></a></li>
<li><a href='#print.summary.o2m'><p>Prints the summary of an O2PLS fit</p></a></li>
<li><a href='#rmsep'><p>Root MSE of Prediction</p></a></li>
<li><a href='#rmsep_combi'><p>Symmetrized root MSE of Prediction</p></a></li>
<li><a href='#scores'><p>Extract the scores from an O2PLS fit</p></a></li>
<li><a href='#so2m_group'><p>Perform Group Sparse O2PLS</p></a></li>
<li><a href='#ssq'><p>Calculate Sum of Squares</p></a></li>
<li><a href='#summary.o2m'><p>Summary of an O2PLS fit</p></a></li>
<li><a href='#thresh_n'><p>Soft threshholding a vector with respect to a number of variables</p></a></li>
<li><a href='#thresh_n_gr'><p>Soft threshholding a vector with respect to a number of groups</p></a></li>
<li><a href='#vnorm'><p>Norm of a vector or columns of a matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Data Integration with Two-Way Orthogonal Partial Least Squares</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-05-19</td>
</tr>
<tr>
<td>Author:</td>
<td>Said el Bouhaddani, Zhujie Gu, Jeanine Houwing-Duistermaat, Geurt Jongbloed, Szymon Kielbasa and
    Hae-Won Uh</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Said el Bouhaddani &lt;s.elbouhaddani@umcutrecht.nl&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Performs the O2PLS data integration method for two datasets, yielding joint and data-specific parts for each dataset.
    The algorithm automatically switches to a memory-efficient approach to fit O2PLS to high dimensional data.
    It provides a rigorous and a faster alternative cross-validation method to select the number of components,
    as well as functions to report proportions of explained variation and to construct plots of the results. 
    See the software article by el Bouhaddani et al (2018) &lt;<a href="https://doi.org/10.1186%2Fs12859-018-2371-3">doi:10.1186/s12859-018-2371-3</a>&gt;, 
    and Trygg and Wold (2003) &lt;<a href="https://doi.org/10.1002%2Fcem.775">doi:10.1002/cem.775</a>&gt;.
    It also performs Sparse Group (Penalized) O2PLS, see Gu et al (2020) &lt;<a href="https://doi.org/10.1186%2Fs12859-021-03958-3">doi:10.1186/s12859-021-03958-3</a>&gt; and cross-validation for the degree of sparsity. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, stats, dplyr, ggplot2, parallel, magrittr, tibble,
softImpute</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, gplots,</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-05-19 08:05:46 UTC; sbouhad2</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-05-19 09:40:12 UTC</td>
</tr>
</table>
<hr>
<h2 id='adjR2'>Gridwise adjusted R2 for O2PLS</h2><span id='topic+adjR2'></span>

<h3>Description</h3>

<p>For (a grid of) values for <code>a</code>, <code>nx</code> and <code>ny</code>, <code>loocv</code> calculates the R2 of the joint part. Parallel computing is supported on Windows with package <code>parallel</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjR2(
  X,
  Y,
  a = 1:2,
  a2 = 1,
  b2 = 1,
  func = o2m,
  parall = F,
  cl = NULL,
  stripped = TRUE,
  p_thresh = 3000,
  q_thresh = p_thresh,
  tol = 1e-10,
  max_iterations = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjR2_+3A_x">X</code></td>
<td>
<p>Numeric matrix. Vectors will be coerced to matrix with <code>as.matrix</code> (if this is possible)</p>
</td></tr>
<tr><td><code id="adjR2_+3A_y">Y</code></td>
<td>
<p>Numeric matrix. Vectors will be coerced to matrix with <code>as.matrix</code> (if this is possible)</p>
</td></tr>
<tr><td><code id="adjR2_+3A_a">a</code></td>
<td>
<p>Vector of integers. Contains the numbers of joint components.</p>
</td></tr>
<tr><td><code id="adjR2_+3A_a2">a2</code></td>
<td>
<p>Vector of integers. Contains the numbers of orthogonal components in <code class="reqn">X</code>.</p>
</td></tr>
<tr><td><code id="adjR2_+3A_b2">b2</code></td>
<td>
<p>Vector of integers. Contains the numbers of orthogonal components in <code class="reqn">Y</code>.</p>
</td></tr>
<tr><td><code id="adjR2_+3A_func">func</code></td>
<td>
<p>Function to fit the O2PLS model with. Only <code><a href="#topic+o2m">o2m</a></code> and <code><a href="#topic+o2m_stripped">o2m_stripped</a></code> are supported.</p>
</td></tr>
<tr><td><code id="adjR2_+3A_parall">parall</code></td>
<td>
<p>Integer. Should a parallel cluster be set up using package <code>parallel</code> (Windows)? Best is to leave it to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="adjR2_+3A_cl">cl</code></td>
<td>
<p>Object of class '<code>cluster</code>'. If parall is <code>TRUE</code> and <code>cl</code> is not <code>NULL</code>, calculations are parallelized over workers in cl.</p>
</td></tr>
<tr><td><code id="adjR2_+3A_stripped">stripped</code></td>
<td>
<p>Logical. Use the stripped version of o2m (usually when cross-validating)?</p>
</td></tr>
<tr><td><code id="adjR2_+3A_p_thresh">p_thresh</code></td>
<td>
<p>Integer. If <code>X</code> has more than <code>p_thresh</code> columns, a power method optimization is used, see <code><a href="#topic+o2m2">o2m2</a></code></p>
</td></tr>
<tr><td><code id="adjR2_+3A_q_thresh">q_thresh</code></td>
<td>
<p>Integer. If <code>Y</code> has more than <code>q_thresh</code> columns, a power method optimization is used, see <code><a href="#topic+o2m2">o2m2</a></code></p>
</td></tr>
<tr><td><code id="adjR2_+3A_tol">tol</code></td>
<td>
<p>Double. Threshold for which the NIPALS method is deemed converged. Must be positive.</p>
</td></tr>
<tr><td><code id="adjR2_+3A_max_iterations">max_iterations</code></td>
<td>
<p>Integer. Maximum number of iterations for the NIPALS method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The use of this function is to calculate the R2 of the joint part, while varying the number of orthogonal components. Adding more joint components will increase the R2!
</p>
<p>A parallelized version is built in -tested on windows-, use package <code>parallel</code> and set <code>parall=TRUE</code> to activate this. There should not be already a cluster object with the name <code>cl</code>.
In case of some error, don't forget to invoke <code>stopCluster(cl)</code> to end the cluster. See Task Manager (Windows) to verify that the workers are spanned/ended.
</p>
<p>See <code><a href="#topic+loocv">loocv</a></code> for more intuition.
</p>


<h3>Value</h3>

<p>Matrix with two rows:
</p>
<table>
<tr><td><code>adjR2X</code></td>
<td>
<p>Contains the joint R2 in X</p>
</td></tr>
<tr><td><code>adjR2Y</code></td>
<td>
<p>Contains the joint R2 in Y</p>
</td></tr>
</table>

<hr>
<h2 id='crossval_o2m'>Cross-validate procedure for O2PLS</h2><span id='topic+crossval_o2m'></span>

<h3>Description</h3>

<p>Cross-validate procedure for O2PLS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crossval_o2m(
  X,
  Y,
  a,
  ax,
  ay,
  nr_folds,
  nr_cores = 1,
  stripped = TRUE,
  p_thresh = 3000,
  q_thresh = p_thresh,
  tol = 1e-10,
  max_iterations = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crossval_o2m_+3A_x">X</code></td>
<td>
<p>Numeric matrix. Vectors will be coerced to matrix with <code>as.matrix</code> (if this is possible)</p>
</td></tr>
<tr><td><code id="crossval_o2m_+3A_y">Y</code></td>
<td>
<p>Numeric matrix. Vectors will be coerced to matrix with <code>as.matrix</code> (if this is possible)</p>
</td></tr>
<tr><td><code id="crossval_o2m_+3A_a">a</code></td>
<td>
<p>Vector of positive integers. Denotes the numbers of joint components to consider.</p>
</td></tr>
<tr><td><code id="crossval_o2m_+3A_ax">ax</code></td>
<td>
<p>Vector of non-negative integers. Denotes the numbers of X-specific components to consider.</p>
</td></tr>
<tr><td><code id="crossval_o2m_+3A_ay">ay</code></td>
<td>
<p>Vector of non-negative integers. Denotes the numbers of Y-specific components to consider.</p>
</td></tr>
<tr><td><code id="crossval_o2m_+3A_nr_folds">nr_folds</code></td>
<td>
<p>Positive integer. Number of folds to consider. Note: <code>kcv=N</code> gives leave-one-out CV. Note that CV with less than two folds does not make sense.</p>
</td></tr>
<tr><td><code id="crossval_o2m_+3A_nr_cores">nr_cores</code></td>
<td>
<p>Positive integer. Number of cores to use for CV. You might want to use <code><a href="parallel.html#topic+detectCores">detectCores</a>()</code>. Defaults to 1.</p>
</td></tr>
<tr><td><code id="crossval_o2m_+3A_stripped">stripped</code></td>
<td>
<p>Logical. Use the stripped version of o2m (usually when cross-validating)?</p>
</td></tr>
<tr><td><code id="crossval_o2m_+3A_p_thresh">p_thresh</code></td>
<td>
<p>Integer. If <code>X</code> has more than <code>p_thresh</code> columns, a power method optimization is used, see <code><a href="#topic+o2m2">o2m2</a></code></p>
</td></tr>
<tr><td><code id="crossval_o2m_+3A_q_thresh">q_thresh</code></td>
<td>
<p>Integer. If <code>Y</code> has more than <code>q_thresh</code> columns, a power method optimization is used, see <code><a href="#topic+o2m2">o2m2</a></code></p>
</td></tr>
<tr><td><code id="crossval_o2m_+3A_tol">tol</code></td>
<td>
<p>Double. Threshold for which the NIPALS method is deemed converged. Must be positive.</p>
</td></tr>
<tr><td><code id="crossval_o2m_+3A_max_iterations">max_iterations</code></td>
<td>
<p>Integer. Maximum number of iterations for the NIPALS method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the standard CV approach. It minimizes the sum of the prediction errors of X and Y over a three-dimensional grid of integers.
Parallelization is possible on all platforms. On Windows it uses <code><a href="parallel.html#topic+makePSOCKcluster">makePSOCKcluster</a></code>, then exports all necessary objects to the workers,
and then calls <code><a href="parallel.html#topic+parLapply">parLapply</a></code>. On OSX and Linux the more friendly <code><a href="parallel.html#topic+mclapply">mclapply</a></code> is used, which uses forking.
A print method is defined, printing the minimizers and minimum in a readable way. Also the elapsed time is tracked and reported.
</p>


<h3>Value</h3>

<p>List of class <code>"cvo2m"</code> with the original and sorted Prediction errors and the number of folds used.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>local({
X = scale(jitter(tcrossprod(rnorm(100),runif(10))))
Y = scale(jitter(tcrossprod(rnorm(100),runif(10))))
crossval_o2m(X, Y, a = 1:4, ax = 1:2, ay = 1:2,
             nr_folds = 5, nr_cores = 1)
})

</code></pre>

<hr>
<h2 id='crossval_o2m_adjR2'>Adjusted Cross-validate procedure for O2PLS</h2><span id='topic+crossval_o2m_adjR2'></span>

<h3>Description</h3>

<p>Combines CV with R2 optimization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crossval_o2m_adjR2(
  X,
  Y,
  a,
  ax,
  ay,
  nr_folds,
  nr_cores = 1,
  stripped = TRUE,
  p_thresh = 3000,
  q_thresh = p_thresh,
  tol = 1e-10,
  max_iterations = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crossval_o2m_adjR2_+3A_x">X</code></td>
<td>
<p>Numeric matrix. Vectors will be coerced to matrix with <code>as.matrix</code> (if this is possible)</p>
</td></tr>
<tr><td><code id="crossval_o2m_adjR2_+3A_y">Y</code></td>
<td>
<p>Numeric matrix. Vectors will be coerced to matrix with <code>as.matrix</code> (if this is possible)</p>
</td></tr>
<tr><td><code id="crossval_o2m_adjR2_+3A_a">a</code></td>
<td>
<p>Vector of positive integers. Denotes the numbers of joint components to consider.</p>
</td></tr>
<tr><td><code id="crossval_o2m_adjR2_+3A_ax">ax</code></td>
<td>
<p>Vector of non-negative integers. Denotes the numbers of X-specific components to consider.</p>
</td></tr>
<tr><td><code id="crossval_o2m_adjR2_+3A_ay">ay</code></td>
<td>
<p>Vector of non-negative integers. Denotes the numbers of Y-specific components to consider.</p>
</td></tr>
<tr><td><code id="crossval_o2m_adjR2_+3A_nr_folds">nr_folds</code></td>
<td>
<p>Positive integer. Number of folds to consider. Note: <code>kcv=N</code> gives leave-one-out CV. Note that CV with less than two folds does not make sense.</p>
</td></tr>
<tr><td><code id="crossval_o2m_adjR2_+3A_nr_cores">nr_cores</code></td>
<td>
<p>Positive integer. Number of cores to use for CV. You might want to use <code><a href="parallel.html#topic+detectCores">detectCores</a>()</code>. Defaults to 1.</p>
</td></tr>
<tr><td><code id="crossval_o2m_adjR2_+3A_stripped">stripped</code></td>
<td>
<p>Logical. Use the stripped version of o2m (usually when cross-validating)?</p>
</td></tr>
<tr><td><code id="crossval_o2m_adjR2_+3A_p_thresh">p_thresh</code></td>
<td>
<p>Integer. If <code>X</code> has more than <code>p_thresh</code> columns, a power method optimization is used, see <code><a href="#topic+o2m2">o2m2</a></code></p>
</td></tr>
<tr><td><code id="crossval_o2m_adjR2_+3A_q_thresh">q_thresh</code></td>
<td>
<p>Integer. If <code>Y</code> has more than <code>q_thresh</code> columns, a power method optimization is used, see <code><a href="#topic+o2m2">o2m2</a></code></p>
</td></tr>
<tr><td><code id="crossval_o2m_adjR2_+3A_tol">tol</code></td>
<td>
<p>Double. Threshold for which the NIPALS method is deemed converged. Must be positive.</p>
</td></tr>
<tr><td><code id="crossval_o2m_adjR2_+3A_max_iterations">max_iterations</code></td>
<td>
<p>Integer. Maximum number of iterations for the NIPALS method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an alternative way of cross-validating. It is proposed in <code>citation(OmicsPLS)</code>.
This approach is (much) faster than the standard <code>crossval_o2m</code> approach and works fine even with two folds.
For each element in <code>n</code> it looks for nx and ny that maximize the <code class="reqn">R^2</code> between T and U in the O2PLS model.
This approach often yields similar integer as the standard approach.
We however suggest to use the standard approach to minimize the prediction error around the found integers.
</p>


<h3>Value</h3>

<p>data.frame with four columns: MSE, n, nx and ny. Each row corresponds to an element in <code>a</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>local({
X = scale(jitter(tcrossprod(rnorm(100),runif(10))))
Y = scale(jitter(tcrossprod(rnorm(100),runif(10))))
crossval_o2m_adjR2(X, Y, a = 1:4, ax = 1:2, ay = 1:2,
             nr_folds = 5, nr_cores = 1)
})
</code></pre>

<hr>
<h2 id='crossval_sparsity'>Perform cross-validation to find the optimal number of variables/groups to keep for each joint component</h2><span id='topic+crossval_sparsity'></span>

<h3>Description</h3>

<p>Perform cross-validation to find the optimal number of variables/groups to keep for each joint component
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crossval_sparsity(
  X,
  Y,
  n,
  nx,
  ny,
  nr_folds,
  keepx_seq = NULL,
  keepy_seq = NULL,
  groupx = NULL,
  groupy = NULL,
  tol = 1e-10,
  max_iterations = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crossval_sparsity_+3A_x">X</code></td>
<td>
<p>Numeric matrix. Vectors will be coerced to matrix with <code>as.matrix</code> (if this is possible)</p>
</td></tr>
<tr><td><code id="crossval_sparsity_+3A_y">Y</code></td>
<td>
<p>Numeric matrix. Vectors will be coerced to matrix with <code>as.matrix</code> (if this is possible)</p>
</td></tr>
<tr><td><code id="crossval_sparsity_+3A_n">n</code></td>
<td>
<p>Integer. Number of joint PLS components. Must be positive.</p>
</td></tr>
<tr><td><code id="crossval_sparsity_+3A_nx">nx</code></td>
<td>
<p>Integer. Number of orthogonal components in <code class="reqn">X</code>. Negative values are interpreted as 0</p>
</td></tr>
<tr><td><code id="crossval_sparsity_+3A_ny">ny</code></td>
<td>
<p>Integer. Number of orthogonal components in <code class="reqn">Y</code>. Negative values are interpreted as 0</p>
</td></tr>
<tr><td><code id="crossval_sparsity_+3A_nr_folds">nr_folds</code></td>
<td>
<p>Integer. Number of folds of CV</p>
</td></tr>
<tr><td><code id="crossval_sparsity_+3A_keepx_seq">keepx_seq</code></td>
<td>
<p>Numeric vector. A vector indicating how many variables/groups to keep for CV in each of the joint component of X. Sparsity of each joint component will be selected sequentially.</p>
</td></tr>
<tr><td><code id="crossval_sparsity_+3A_keepy_seq">keepy_seq</code></td>
<td>
<p>Numeric vector. A vector indicating how many variables/groups to keep for CV in each of the joint component of Y. Sparsity of each joint component will be selected sequentially.</p>
</td></tr>
<tr><td><code id="crossval_sparsity_+3A_groupx">groupx</code></td>
<td>
<p>Vector. Used when <code>sparse = TRUE</code>. A vector of strings indicating group names of each X-variable. Its length must be equal to the number of variables in <code class="reqn">X</code>. The order of group names must corresponds to the order of the variables.</p>
</td></tr>
<tr><td><code id="crossval_sparsity_+3A_groupy">groupy</code></td>
<td>
<p>Vector. Used when <code>sparse = TRUE</code>. A vector of strings indicating group names of each Y-variable. The length must be equal to the number of variables in <code class="reqn">Y</code>. The order of group names must corresponds to the order of the variables.</p>
</td></tr>
<tr><td><code id="crossval_sparsity_+3A_tol">tol</code></td>
<td>
<p>Double. Threshold for which the NIPALS method is deemed converged. Must be positive.</p>
</td></tr>
<tr><td><code id="crossval_sparsity_+3A_max_iterations">max_iterations</code></td>
<td>
<p>Integer. Maximum number of iterations for the NIPALS method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing
</p>
<table>
<tr><td><code>x_1sd</code></td>
<td>
<p>A vector with length n, giving the optimal number of variables/groups to keep for each X-joint compoent. One standard error rule is applied</p>
</td></tr>
<tr><td><code>y_1sd</code></td>
<td>
<p>A vector with length n, giving the optimal number of variables/groups to keep for each Y-joint compoent. One standard error rule is applied</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>A vector with length n, giving the optimal number of variables/groups to keep for each X-joint compoent, without applying the one standard error rule</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>A vector with length n, giving the optimal number of variables/groups to keep for each Y-joint compoent, without applying the one standard error rule</p>
</td></tr>
</table>

<hr>
<h2 id='cv_lambda_checker'>Check if sparsity parameters satisfy input conditions in cross-validation functions</h2><span id='topic+cv_lambda_checker'></span>

<h3>Description</h3>

<p>Check if sparsity parameters satisfy input conditions in cross-validation functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv_lambda_checker(x, y, keepx_seq = NULL, keepy_seq = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv_lambda_checker_+3A_x">x</code></td>
<td>
<p>Should be numeric matrix.</p>
</td></tr>
<tr><td><code id="cv_lambda_checker_+3A_y">y</code></td>
<td>
<p>Should be numeric matrix.</p>
</td></tr>
<tr><td><code id="cv_lambda_checker_+3A_keepx_seq">keepx_seq</code></td>
<td>
<p>Input of <code>crossval_sparsity</code> function.</p>
</td></tr>
<tr><td><code id="cv_lambda_checker_+3A_keepy_seq">keepy_seq</code></td>
<td>
<p>Input of <code>crossval_sparsity</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function throws an error if sparsity parameters are not valid.
</p>

<hr>
<h2 id='cv_lambda_checker_group'>Check if sparsity parameters satisfy input conditions in cross-validation functions</h2><span id='topic+cv_lambda_checker_group'></span>

<h3>Description</h3>

<p>Check if sparsity parameters satisfy input conditions in cross-validation functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv_lambda_checker_group(groupx, groupy, keepx_seq = NULL, keepy_seq = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv_lambda_checker_group_+3A_groupx">groupx</code></td>
<td>
<p>Vector. Input of <code>crossval_sparsity</code> function.</p>
</td></tr>
<tr><td><code id="cv_lambda_checker_group_+3A_groupy">groupy</code></td>
<td>
<p>Vector. Input of <code>crossval_sparsity</code> function.</p>
</td></tr>
<tr><td><code id="cv_lambda_checker_group_+3A_keepx_seq">keepx_seq</code></td>
<td>
<p>Input of <code>crossval_sparsity</code> function.</p>
</td></tr>
<tr><td><code id="cv_lambda_checker_group_+3A_keepy_seq">keepy_seq</code></td>
<td>
<p>Input of <code>crossval_sparsity</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function throws an error if sparsity parameters are not valid.
</p>

<hr>
<h2 id='err_back'>Internal function for crossval_sparsity</h2><span id='topic+err_back'></span>

<h3>Description</h3>

<p>Internal function for crossval_sparsity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>err_back(dat, index, p, q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="err_back_+3A_dat">dat</code></td>
<td>
<p>Matrix with numeric row/col names</p>
</td></tr>
<tr><td><code id="err_back_+3A_index">index</code></td>
<td>
<p>Get from which(..., arr.ind = T)</p>
</td></tr>
<tr><td><code id="err_back_+3A_p">p</code></td>
<td>
<p>Number of variables in X</p>
</td></tr>
<tr><td><code id="err_back_+3A_q">q</code></td>
<td>
<p>Number of variables in Y</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function finds the most sparse combination of keepx and keepy (min(keepx/p + keepy/q)) that yields cov(T,U) within 1 std error of the largest cov(T,U). Note that it's possible that the resulting keepx or keepy is larger than the orignal when p &gt;&gt; q or p &lt;&lt; q.
</p>

<hr>
<h2 id='impute_matrix'>Impute missing values in a matrix</h2><span id='topic+impute_matrix'></span>

<h3>Description</h3>

<p>Impute missing values in a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impute_matrix(X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impute_matrix_+3A_x">X</code></td>
<td>
<p>A matrix with missing values in some entries.</p>
</td></tr>
<tr><td><code id="impute_matrix_+3A_...">...</code></td>
<td>
<p>Further arguments for <code>softimpute</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is based on the <code><a href="softImpute.html#topic+softImpute">softImpute</a></code> function in its eponymous package.
</p>


<h3>Value</h3>

<p>An imputed version of matrix <code class="reqn">X</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(rnorm(20*100),20)
Xmis &lt;- X
Xmis[sample(length(Xmis),length(Xmis)/10)] &lt;- NA
anyNA(X)
anyNA(impute_matrix(Xmis))
</code></pre>

<hr>
<h2 id='input_checker'>Check if matrices satisfy input conditions</h2><span id='topic+input_checker'></span>

<h3>Description</h3>

<p>Check if matrices satisfy input conditions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>input_checker(X, Y = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="input_checker_+3A_x">X</code></td>
<td>
<p>Should be numeric matrix.</p>
</td></tr>
<tr><td><code id="input_checker_+3A_y">Y</code></td>
<td>
<p>Should be numeric matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function throws an error if any of the elements is <code>NA</code>, <code>Inf</code>, <code>NaN</code> or <code>nrow(X)</code> doesn't match <code>nrow(Y)</code>.
</p>

<hr>
<h2 id='lambda_checker'>Check if penalization parameters satisfy input conditions</h2><span id='topic+lambda_checker'></span>

<h3>Description</h3>

<p>Check if penalization parameters satisfy input conditions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lambda_checker(x, y, keepx, keepy, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lambda_checker_+3A_x">x</code></td>
<td>
<p>Should be numeric matrix.</p>
</td></tr>
<tr><td><code id="lambda_checker_+3A_y">y</code></td>
<td>
<p>Should be numeric matrix.</p>
</td></tr>
<tr><td><code id="lambda_checker_+3A_keepx">keepx</code></td>
<td>
<p>Input of <code>o2m</code> function.</p>
</td></tr>
<tr><td><code id="lambda_checker_+3A_keepy">keepy</code></td>
<td>
<p>Input of <code>o2m</code> function.</p>
</td></tr>
<tr><td><code id="lambda_checker_+3A_n">n</code></td>
<td>
<p>Number of joint components.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function throws an error if lambda is not within the range.
</p>

<hr>
<h2 id='lambda_checker_group'>Check if penalization parameters for groups satisfy input conditions</h2><span id='topic+lambda_checker_group'></span>

<h3>Description</h3>

<p>Check if penalization parameters for groups satisfy input conditions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lambda_checker_group(groupx, groupy, keepx, keepy, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lambda_checker_group_+3A_groupx">groupx</code></td>
<td>
<p>Vector. Input of <code>o2m</code> function.</p>
</td></tr>
<tr><td><code id="lambda_checker_group_+3A_groupy">groupy</code></td>
<td>
<p>Vector. Input of <code>o2m</code> function.</p>
</td></tr>
<tr><td><code id="lambda_checker_group_+3A_keepx">keepx</code></td>
<td>
<p>Input of <code>o2m</code> function or <code>crossval_sparsity</code> function.</p>
</td></tr>
<tr><td><code id="lambda_checker_group_+3A_keepy">keepy</code></td>
<td>
<p>Input of <code>o2m</code> function or <code>crossval_sparsity</code> function.</p>
</td></tr>
<tr><td><code id="lambda_checker_group_+3A_n">n</code></td>
<td>
<p>Number of joint components.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function throws an error if lambda is not within the range.
</p>

<hr>
<h2 id='loadings'>Extract the loadings from an O2PLS fit</h2><span id='topic+loadings'></span><span id='topic+loadings.o2m'></span>

<h3>Description</h3>

<p>This function extracts loading parameters from an O2PLS fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadings(x, ...)

## S3 method for class 'o2m'
loadings(
  x,
  loading_name = c("Xjoint", "Yjoint", "gr_Xjoint", "gr_Yjoint", "Xorth", "Yorth"),
  subset = 0,
  sorted = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loadings_+3A_x">x</code></td>
<td>
<p>Object of class <code>o2m</code></p>
</td></tr>
<tr><td><code id="loadings_+3A_...">...</code></td>
<td>
<p>For consistency</p>
</td></tr>
<tr><td><code id="loadings_+3A_loading_name">loading_name</code></td>
<td>
<p>character string. One of the following: 'Xjoint', 'Yjoint', 'gr_Xjoint', 'gr_Yjoint', 'Xorth' or 'Yorth'.</p>
</td></tr>
<tr><td><code id="loadings_+3A_subset">subset</code></td>
<td>
<p>subset of loading vectors to be extracted.</p>
</td></tr>
<tr><td><code id="loadings_+3A_sorted">sorted</code></td>
<td>
<p>Logical. Should the rows of the loadings be sorted according to the 
absolute magnitute of the first column?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Loading matrix
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scores.o2m">scores.o2m</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>loadings(o2m(scale(-2:2),scale(-2:2*4),1,0,0))

</code></pre>

<hr>
<h2 id='loocv'>K fold CV for O2PLS</h2><span id='topic+loocv'></span>

<h3>Description</h3>

<p>For (a grid of) values for <code>a</code>, <code>nx</code> and <code>ny</code>, <code>loocv</code> estimates the prediction error using k-fold CV.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loocv(
  X,
  Y,
  a = 1:2,
  a2 = 1,
  b2 = 1,
  fitted_model = NULL,
  func = o2m,
  app_err = F,
  kcv,
  stripped = TRUE,
  p_thresh = 3000,
  q_thresh = p_thresh,
  tol = 1e-10,
  max_iterations = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loocv_+3A_x">X</code></td>
<td>
<p>Numeric matrix. Vectors will be coerced to matrix with <code>as.matrix</code> (if this is possible)</p>
</td></tr>
<tr><td><code id="loocv_+3A_y">Y</code></td>
<td>
<p>Numeric matrix. Vectors will be coerced to matrix with <code>as.matrix</code> (if this is possible)</p>
</td></tr>
<tr><td><code id="loocv_+3A_a">a</code></td>
<td>
<p>Vector of integers. Contains the numbers of joint components.</p>
</td></tr>
<tr><td><code id="loocv_+3A_a2">a2</code></td>
<td>
<p>Vector of integers. Contains the numbers of orthogonal components in <code class="reqn">X</code>.</p>
</td></tr>
<tr><td><code id="loocv_+3A_b2">b2</code></td>
<td>
<p>Vector of integers. Contains the numbers of orthogonal components in <code class="reqn">Y</code>.</p>
</td></tr>
<tr><td><code id="loocv_+3A_fitted_model">fitted_model</code></td>
<td>
<p>List. Deprecated. O2PLS model fit with <code><a href="#topic+o2m">o2m</a></code>. Is used to calculate the apparent error without recalculating this fit.</p>
</td></tr>
<tr><td><code id="loocv_+3A_func">func</code></td>
<td>
<p>Function to fit the O2PLS model with. Only <code><a href="#topic+o2m">o2m</a></code> and <code><a href="#topic+o2m_stripped">o2m_stripped</a></code> are supported.</p>
</td></tr>
<tr><td><code id="loocv_+3A_app_err">app_err</code></td>
<td>
<p>Logical. Deprecated. Should the apparent error also be computed?</p>
</td></tr>
<tr><td><code id="loocv_+3A_kcv">kcv</code></td>
<td>
<p>Integer. The value of <code class="reqn">k</code>, i.e. the number of folds. Choose <code class="reqn">N</code> for LOO-CV.</p>
</td></tr>
<tr><td><code id="loocv_+3A_stripped">stripped</code></td>
<td>
<p>Logical. Use the stripped version of o2m (usually when cross-validating)?</p>
</td></tr>
<tr><td><code id="loocv_+3A_p_thresh">p_thresh</code></td>
<td>
<p>Integer. If <code>X</code> has more than <code>p_thresh</code> columns, a power method optimization is used, see <code><a href="#topic+o2m2">o2m2</a></code></p>
</td></tr>
<tr><td><code id="loocv_+3A_q_thresh">q_thresh</code></td>
<td>
<p>Integer. If <code>Y</code> has more than <code>q_thresh</code> columns, a power method optimization is used, see <code><a href="#topic+o2m2">o2m2</a></code></p>
</td></tr>
<tr><td><code id="loocv_+3A_tol">tol</code></td>
<td>
<p>Double. Threshold for which the NIPALS method is deemed converged. Must be positive.</p>
</td></tr>
<tr><td><code id="loocv_+3A_max_iterations">max_iterations</code></td>
<td>
<p>Integer. Maximum number of iterations for the NIPALS method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this function can be easily parallelized (on Windows e.g. with the <code>parallel</code> package.).
</p>
<p>The parameters <code>a</code>, <code>a2</code> and <code>b2</code> can be integers or vectors of integers. A for loop is used to loop over all combinations.
The resulting output is a list, which is more easy to interpret if you use <code>array(unlist(output_of_loocv$CVerr))</code> as in the example below.
The array wil have varying <code>a</code> along the first dimension and <code>a2</code> and <code>b2</code> along the second and third respectively.
Typing <code>example(loocv)</code> (hopefully) clarifies this function.
</p>


<h3>Value</h3>

<p>List with two numeric vectors:
</p>
<table>
<tr><td><code>CVerr</code></td>
<td>
<p>Contains the k-fold CV estimated RMSEP</p>
</td></tr>
<tr><td><code>Fiterr</code></td>
<td>
<p>Contains the apparent error</p>
</td></tr>
</table>

<hr>
<h2 id='loocv_combi'>K-fold CV based on symmetrized prediction error</h2><span id='topic+loocv_combi'></span>

<h3>Description</h3>

<p>The prediction error of both <code>X~Xhat</code> and <code>Y~Yhat</code> are summed. This provides a symmetrized version of <code><a href="#topic+loocv">loocv</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loocv_combi(
  X,
  Y,
  a = 1:2,
  a2 = 1,
  b2 = 1,
  fitted_model = NULL,
  func = o2m,
  app_err = F,
  kcv,
  stripped = TRUE,
  p_thresh = 3000,
  q_thresh = p_thresh,
  tol = 1e-10,
  max_iterations = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loocv_combi_+3A_x">X</code></td>
<td>
<p>Numeric matrix. Vectors will be coerced to matrix with <code>as.matrix</code> (if this is possible)</p>
</td></tr>
<tr><td><code id="loocv_combi_+3A_y">Y</code></td>
<td>
<p>Numeric matrix. Vectors will be coerced to matrix with <code>as.matrix</code> (if this is possible)</p>
</td></tr>
<tr><td><code id="loocv_combi_+3A_a">a</code></td>
<td>
<p>Vector of integers. Contains the numbers of joint components.</p>
</td></tr>
<tr><td><code id="loocv_combi_+3A_a2">a2</code></td>
<td>
<p>Vector of integers. Contains the numbers of orthogonal components in <code class="reqn">X</code>.</p>
</td></tr>
<tr><td><code id="loocv_combi_+3A_b2">b2</code></td>
<td>
<p>Vector of integers. Contains the numbers of orthogonal components in <code class="reqn">Y</code>.</p>
</td></tr>
<tr><td><code id="loocv_combi_+3A_fitted_model">fitted_model</code></td>
<td>
<p>List. Deprecated. O2PLS model fit with <code><a href="#topic+o2m">o2m</a></code>. Is used to calculate the apparent error without recalculating this fit.</p>
</td></tr>
<tr><td><code id="loocv_combi_+3A_func">func</code></td>
<td>
<p>Function to fit the O2PLS model with. Only <code><a href="#topic+o2m">o2m</a></code> and <code><a href="#topic+o2m_stripped">o2m_stripped</a></code> are supported.</p>
</td></tr>
<tr><td><code id="loocv_combi_+3A_app_err">app_err</code></td>
<td>
<p>Logical. Deprecated. Should the apparent error also be computed?</p>
</td></tr>
<tr><td><code id="loocv_combi_+3A_kcv">kcv</code></td>
<td>
<p>Integer. The value of <code class="reqn">k</code>, i.e. the number of folds. Choose <code class="reqn">N</code> for LOO-CV.</p>
</td></tr>
<tr><td><code id="loocv_combi_+3A_stripped">stripped</code></td>
<td>
<p>Logical. Use the stripped version of o2m (usually when cross-validating)?</p>
</td></tr>
<tr><td><code id="loocv_combi_+3A_p_thresh">p_thresh</code></td>
<td>
<p>Integer. If <code>X</code> has more than <code>p_thresh</code> columns, a power method optimization is used, see <code><a href="#topic+o2m2">o2m2</a></code></p>
</td></tr>
<tr><td><code id="loocv_combi_+3A_q_thresh">q_thresh</code></td>
<td>
<p>Integer. If <code>Y</code> has more than <code>q_thresh</code> columns, a power method optimization is used, see <code><a href="#topic+o2m2">o2m2</a></code></p>
</td></tr>
<tr><td><code id="loocv_combi_+3A_tol">tol</code></td>
<td>
<p>Double. Threshold for which the NIPALS method is deemed converged. Must be positive.</p>
</td></tr>
<tr><td><code id="loocv_combi_+3A_max_iterations">max_iterations</code></td>
<td>
<p>Integer. Maximum number of iterations for the NIPALS method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this function can be easily parallelized (on Windows e.g. with the <code>parallel</code> package.).
If there are NAs in the CVerr component, this is due to an error in the fitting.
</p>


<h3>Value</h3>

<p>List with two numeric vectors:
</p>
<table>
<tr><td><code>CVerr</code></td>
<td>
<p>Contains the k-fold CV estimated RMSEP</p>
</td></tr>
<tr><td><code>Fiterr</code></td>
<td>
<p>Contains the apparent error</p>
</td></tr>
</table>

<hr>
<h2 id='mse'>Calculate mean squared difference</h2><span id='topic+mse'></span>

<h3>Description</h3>

<p>Calculate mean squared difference
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mse(x, y = 0, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mse_+3A_x">x</code></td>
<td>
<p>Numeric vector or matrix.</p>
</td></tr>
<tr><td><code id="mse_+3A_y">y</code></td>
<td>
<p>Numeric vector or matrix. Defaults to 0.</p>
</td></tr>
<tr><td><code id="mse_+3A_na.rm">na.rm</code></td>
<td>
<p>Remove NA's?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Is equal to ssq(<code>x-y</code>)/length(c(<code>x</code>)). If <code>x</code> and <code>y</code> are of unequal length, the invoked minus-operator will try to make the best out of it by recycling elements of the shorter object (usually you don't want that).
In particular if <code>x</code> is an N x p matrix and <code>y</code> an N x 1 vector, y is subtracted from each column of <code>x</code>, and if <code>y=0</code> (default) you get the mean of vec(<code>x^2</code>)
</p>


<h3>Value</h3>

<p>The mean of the squared differences elementwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mse(2)
mse(1:10,2:11) == 1
mse(matrix(rnorm(500),100,5),matrix(rnorm(500),100,5))
</code></pre>

<hr>
<h2 id='norm_vec'>Norm of a vector</h2><span id='topic+norm_vec'></span>

<h3>Description</h3>

<p>Norm of a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm_vec(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="norm_vec_+3A_x">x</code></td>
<td>
<p>Numerical vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>L2 norm of a vector
</p>

<hr>
<h2 id='o2m'>Perform O2PLS data integration with two-way orthogonal corrections</h2><span id='topic+o2m'></span>

<h3>Description</h3>

<p>NOTE THAT THIS FUNCTION DOES NOT CENTER NOR SCALE THE MATRICES! Any normalization you will have to do yourself. It is best practice to at least center the variables though.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>o2m(
  X,
  Y,
  n,
  nx,
  ny,
  stripped = FALSE,
  p_thresh = 3000,
  q_thresh = p_thresh,
  tol = 1e-10,
  max_iterations = 1000,
  sparse = F,
  groupx = NULL,
  groupy = NULL,
  keepx = NULL,
  keepy = NULL,
  max_iterations_sparsity = 1000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="o2m_+3A_x">X</code></td>
<td>
<p>Numeric matrix. Vectors will be coerced to matrix with <code>as.matrix</code> (if this is possible)</p>
</td></tr>
<tr><td><code id="o2m_+3A_y">Y</code></td>
<td>
<p>Numeric matrix. Vectors will be coerced to matrix with <code>as.matrix</code> (if this is possible)</p>
</td></tr>
<tr><td><code id="o2m_+3A_n">n</code></td>
<td>
<p>Integer. Number of joint PLS components. Must be positive.</p>
</td></tr>
<tr><td><code id="o2m_+3A_nx">nx</code></td>
<td>
<p>Integer. Number of orthogonal components in <code class="reqn">X</code>. Negative values are interpreted as 0</p>
</td></tr>
<tr><td><code id="o2m_+3A_ny">ny</code></td>
<td>
<p>Integer. Number of orthogonal components in <code class="reqn">Y</code>. Negative values are interpreted as 0</p>
</td></tr>
<tr><td><code id="o2m_+3A_stripped">stripped</code></td>
<td>
<p>Logical. Use the stripped version of o2m (usually when cross-validating)?</p>
</td></tr>
<tr><td><code id="o2m_+3A_p_thresh">p_thresh</code></td>
<td>
<p>Integer. If <code>X</code> has more than <code>p_thresh</code> columns, a power method optimization is used, see <code><a href="#topic+o2m2">o2m2</a></code></p>
</td></tr>
<tr><td><code id="o2m_+3A_q_thresh">q_thresh</code></td>
<td>
<p>Integer. If <code>Y</code> has more than <code>q_thresh</code> columns, a power method optimization is used, see <code><a href="#topic+o2m2">o2m2</a></code></p>
</td></tr>
<tr><td><code id="o2m_+3A_tol">tol</code></td>
<td>
<p>Double. Threshold for which the NIPALS method is deemed converged. Must be positive.</p>
</td></tr>
<tr><td><code id="o2m_+3A_max_iterations">max_iterations</code></td>
<td>
<p>Integer. Maximum number of iterations for the NIPALS method.</p>
</td></tr>
<tr><td><code id="o2m_+3A_sparse">sparse</code></td>
<td>
<p>Boolean. Default value is <code>FALSE</code>, in which case O2PLS will be fitted. Set to <code>TRUE</code> for GO2PLS.</p>
</td></tr>
<tr><td><code id="o2m_+3A_groupx">groupx</code></td>
<td>
<p>Vector. Used when <code>sparse = TRUE</code>. A vector of strings indicating group names of each X-variable. Its length must be equal to the number of variables in <code class="reqn">X</code>. The order of group names must corresponds to the order of the variables.</p>
</td></tr>
<tr><td><code id="o2m_+3A_groupy">groupy</code></td>
<td>
<p>Vector. Used when <code>sparse = TRUE</code>. A vector of strings indicating group names of each Y-variable. The length must be equal to the number of variables in <code class="reqn">Y</code>. The order of group names must corresponds to the order of the variables.</p>
</td></tr>
<tr><td><code id="o2m_+3A_keepx">keepx</code></td>
<td>
<p>Vector. Used when <code>sparse = TRUE</code>. A vector of length <code>n</code> indicating how many variables (or groups if <code>groupx</code> is provided) to keep in each of the joint component of <code class="reqn">X</code>. If the input is an integer, all the components will have the same amount of variables or groups retained.</p>
</td></tr>
<tr><td><code id="o2m_+3A_keepy">keepy</code></td>
<td>
<p>Vector. Used when <code>sparse = TRUE</code>. A vector of length <code>n</code> indicating how many variables (or groups if <code>groupx</code> is provided) to keep in each of the joint component of <code class="reqn">Y</code>. If the input is an integer, all the components will have the same amount of variables or groups retained.</p>
</td></tr>
<tr><td><code id="o2m_+3A_max_iterations_sparsity">max_iterations_sparsity</code></td>
<td>
<p>Integer. Used when <code>sparse = TRUE</code>. Maximum number of iterations for the NIPALS method for GO2PLS.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If both <code>nx</code> and <code>ny</code> are zero, <code>o2m</code> is equivalent to PLS2 with orthonormal loadings.
This is a &lsquo;slower&rsquo; (in terms of memory) implementation of O2PLS, and is using <code><a href="base.html#topic+svd">svd</a></code>, use <code>stripped=T</code> for a stripped version with less output.
If either <code>ncol(X) &gt; p_thresh</code> or <code>ncol(Y) &gt; q_thresh</code>, the NIPALS method is used which does not store the entire covariance matrix.
The squared error between iterands in the NIPALS approach can be adjusted with <code>tol</code>.
The maximum number of iterations in the NIPALS approach is tuned by <code>max_iterations</code>.
</p>


<h3>Value</h3>

<p>A list containing
</p>
<table>
<tr><td><code>Tt</code></td>
<td>
<p>Joint <code class="reqn">X</code> scores</p>
</td></tr>
<tr><td><code>W.</code></td>
<td>
<p>Joint <code class="reqn">X</code> loadings</p>
</td></tr>
<tr><td><code>U</code></td>
<td>
<p>Joint <code class="reqn">Y</code> scores</p>
</td></tr>
<tr><td><code>C.</code></td>
<td>
<p>Joint <code class="reqn">Y</code> loadings</p>
</td></tr>
<tr><td><code>E</code></td>
<td>
<p>Residuals in <code class="reqn">X</code></p>
</td></tr>
<tr><td><code>Ff</code></td>
<td>
<p>Residuals in <code class="reqn">Y</code></p>
</td></tr>
<tr><td><code>T_Yosc</code></td>
<td>
<p>Orthogonal <code class="reqn">X</code> scores</p>
</td></tr>
<tr><td><code>P_Yosc.</code></td>
<td>
<p>Orthogonal <code class="reqn">X</code> loadings</p>
</td></tr>
<tr><td><code>W_Yosc</code></td>
<td>
<p>Orthogonal <code class="reqn">X</code> weights</p>
</td></tr>
<tr><td><code>U_Xosc</code></td>
<td>
<p>Orthogonal <code class="reqn">Y</code> scores</p>
</td></tr>
<tr><td><code>P_Xosc.</code></td>
<td>
<p>Orthogonal <code class="reqn">Y</code> loadings</p>
</td></tr>
<tr><td><code>C_Xosc</code></td>
<td>
<p>Orthogonal <code class="reqn">Y</code> weights</p>
</td></tr>
<tr><td><code>B_U</code></td>
<td>
<p>Regression coefficient in <code>Tt</code> ~ <code>U</code></p>
</td></tr>
<tr><td><code>B_T.</code></td>
<td>
<p>Regression coefficient in <code>U</code> ~ <code>Tt</code></p>
</td></tr>
<tr><td><code>H_TU</code></td>
<td>
<p>Residuals in <code>Tt</code> in <code>Tt</code> ~ <code>U</code></p>
</td></tr>
<tr><td><code>H_UT</code></td>
<td>
<p>Residuals in <code>U</code> in <code>U</code> ~ <code>Tt</code></p>
</td></tr>
<tr><td><code>X_hat</code></td>
<td>
<p>Prediction of <code class="reqn">X</code> with <code class="reqn">Y</code></p>
</td></tr>
<tr><td><code>Y_hat</code></td>
<td>
<p>Prediction of <code class="reqn">Y</code> with <code class="reqn">X</code></p>
</td></tr>
<tr><td><code>R2X</code></td>
<td>
<p>Variation (measured with <code><a href="#topic+ssq">ssq</a></code>) of the modeled part in <code class="reqn">X</code> (defined by joint + orthogonal variation) as proportion of variation in <code class="reqn">X</code></p>
</td></tr>
<tr><td><code>R2Y</code></td>
<td>
<p>Variation (measured with <code><a href="#topic+ssq">ssq</a></code>) of the modeled part in <code class="reqn">Y</code> (defined by joint + orthogonal variation) as proportion of variation in <code class="reqn">Y</code></p>
</td></tr>
<tr><td><code>R2Xcorr</code></td>
<td>
<p>Variation (measured with <code><a href="#topic+ssq">ssq</a></code>) of the joint part in <code class="reqn">X</code> as proportion of variation in <code class="reqn">X</code></p>
</td></tr>
<tr><td><code>R2Ycorr</code></td>
<td>
<p>Variation (measured with <code><a href="#topic+ssq">ssq</a></code>) of the joint part in <code class="reqn">Y</code> as proportion of variation in <code class="reqn">Y</code></p>
</td></tr>
<tr><td><code>R2X_YO</code></td>
<td>
<p>Variation (measured with <code><a href="#topic+ssq">ssq</a></code>) of the orthogonal part in <code class="reqn">X</code> as proportion of variation in <code class="reqn">X</code></p>
</td></tr>
<tr><td><code>R2Y_XO</code></td>
<td>
<p>Variation (measured with <code><a href="#topic+ssq">ssq</a></code>) of the orthogonal part in <code class="reqn">Y</code> as proportion of variation in <code class="reqn">Y</code></p>
</td></tr>
<tr><td><code>R2Xhat</code></td>
<td>
<p>Variation (measured with <code><a href="#topic+ssq">ssq</a></code>) of the predicted <code class="reqn">X</code> as proportion of variation in <code class="reqn">X</code></p>
</td></tr>
<tr><td><code>R2Yhat</code></td>
<td>
<p>Variation (measured with <code><a href="#topic+ssq">ssq</a></code>) of the predicted <code class="reqn">Y</code> as proportion of variation in <code class="reqn">Y</code></p>
</td></tr>
<tr><td><code>W_gr</code></td>
<td>
<p>Joint loadings of <code class="reqn">X</code> at group level (only available when GO2PLS is used)</p>
</td></tr>
<tr><td><code>C_gr</code></td>
<td>
<p>Joint loadings of <code class="reqn">Y</code> at group level (only available when GO2PLS is used)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+summary.o2m">summary.o2m</a></code>, <code><a href="#topic+plot.o2m">plot.o2m</a></code>, <code><a href="#topic+crossval_o2m_adjR2">crossval_o2m_adjR2</a></code>, <code><a href="#topic+crossval_sparsity">crossval_sparsity</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test_X &lt;- scale(matrix(rnorm(100*10),100,10))
test_Y &lt;- scale(matrix(rnorm(100*11),100,11))
#  --------- Default run ------------ 
o2m(test_X, test_Y, 3, 2, 1)
#  ---------- Stripped version ------------- 
o2m(test_X, test_Y, 3, 2, 1, stripped = TRUE)
#  ---------- High dimensional version ---------- 
o2m(test_X, test_Y, 3, 2, 1, p_thresh = 1)
#  ------ High D and stripped version --------- 
o2m(test_X, test_Y, 3, 2, 1, stripped = TRUE, p_thresh = 1)
#  ------ Now with more iterations -------- 
o2m(test_X, test_Y, 3, 2, 1, stripped = TRUE, p_thresh = 1, max_iterations = 1e6)
#  ---------------------------------- 

</code></pre>

<hr>
<h2 id='o2m_stripped'>Perform O2-PLS with two-way orthogonal corrections</h2><span id='topic+o2m_stripped'></span>

<h3>Description</h3>

<p>NOTE THAT THIS FUNCTION DOES NOT CENTER NOR SCALES THE MATRICES! Any normalization you will have to do yourself. It is best practice to at least center the variables though.
A stripped version of O2PLS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>o2m_stripped(X, Y, n, nx, ny)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="o2m_stripped_+3A_x">X</code></td>
<td>
<p>Numeric matrix. Vectors will be coerced to matrix with <code>as.matrix</code> (if this is possible)</p>
</td></tr>
<tr><td><code id="o2m_stripped_+3A_y">Y</code></td>
<td>
<p>Numeric matrix. Vectors will be coerced to matrix with <code>as.matrix</code> (if this is possible)</p>
</td></tr>
<tr><td><code id="o2m_stripped_+3A_n">n</code></td>
<td>
<p>Integer. Number of joint PLS components. Must be positive.</p>
</td></tr>
<tr><td><code id="o2m_stripped_+3A_nx">nx</code></td>
<td>
<p>Integer. Number of orthogonal components in <code class="reqn">X</code>. Negative values are interpreted as 0</p>
</td></tr>
<tr><td><code id="o2m_stripped_+3A_ny">ny</code></td>
<td>
<p>Integer. Number of orthogonal components in <code class="reqn">Y</code>. Negative values are interpreted as 0</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If both <code>nx</code> and <code>ny</code> are zero, <code>o2m</code> is equivalent to PLS2 with orthonormal loadings.
This is a stripped implementation of O2PLS, using <code><a href="base.html#topic+svd">svd</a></code>. For data analysis purposes, consider using <code><a href="#topic+o2m">o2m</a></code>.
</p>


<h3>Value</h3>

<p>A list containing
</p>
<table>
<tr><td><code>Tt</code></td>
<td>
<p>Joint <code class="reqn">X</code> scores</p>
</td></tr>
<tr><td><code>W.</code></td>
<td>
<p>Joint <code class="reqn">X</code> loadings</p>
</td></tr>
<tr><td><code>U</code></td>
<td>
<p>Joint <code class="reqn">Y</code> scores</p>
</td></tr>
<tr><td><code>C.</code></td>
<td>
<p>Joint <code class="reqn">Y</code> loadings</p>
</td></tr>
<tr><td><code>P_Yosc.</code></td>
<td>
<p>Orthogonal <code class="reqn">X</code> loadings</p>
</td></tr>
<tr><td><code>P_Xosc.</code></td>
<td>
<p>Orthogonal <code class="reqn">Y</code> loadings</p>
</td></tr>
<tr><td><code>B_U</code></td>
<td>
<p>Regression coefficient in <code>Tt</code> ~ <code>U</code></p>
</td></tr>
<tr><td><code>B_T.</code></td>
<td>
<p>Regression coefficient in <code>U</code> ~ <code>Tt</code></p>
</td></tr>
<tr><td><code>H_TU</code></td>
<td>
<p>Residuals in <code>Tt</code> in <code>Tt</code> ~ <code>U</code></p>
</td></tr>
<tr><td><code>H_UT</code></td>
<td>
<p>Residuals in <code>U</code> in <code>U</code> ~ <code>Tt</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+o2m">o2m</a></code>
</p>

<hr>
<h2 id='o2m_stripped2'>Perform O2-PLS with two-way orthogonal corrections</h2><span id='topic+o2m_stripped2'></span>

<h3>Description</h3>

<p>DEFUNCT!!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>o2m_stripped2(X, Y, n, nx, ny, tol = 1e-10, max_iterations = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="o2m_stripped2_+3A_x">X</code></td>
<td>
<p>Numeric matrix. Vectors will be coerced to matrix with <code>as.matrix</code> (if this is possible)</p>
</td></tr>
<tr><td><code id="o2m_stripped2_+3A_y">Y</code></td>
<td>
<p>Numeric matrix. Vectors will be coerced to matrix with <code>as.matrix</code> (if this is possible)</p>
</td></tr>
<tr><td><code id="o2m_stripped2_+3A_n">n</code></td>
<td>
<p>Integer. Number of joint PLS components. Must be positive.</p>
</td></tr>
<tr><td><code id="o2m_stripped2_+3A_nx">nx</code></td>
<td>
<p>Integer. Number of orthogonal components in <code class="reqn">X</code>. Negative values are interpreted as 0</p>
</td></tr>
<tr><td><code id="o2m_stripped2_+3A_ny">ny</code></td>
<td>
<p>Integer. Number of orthogonal components in <code class="reqn">Y</code>. Negative values are interpreted as 0</p>
</td></tr>
<tr><td><code id="o2m_stripped2_+3A_tol">tol</code></td>
<td>
<p>Double. Threshold for which the NIPALS method is deemed converged. Must be positive.</p>
</td></tr>
<tr><td><code id="o2m_stripped2_+3A_max_iterations">max_iterations</code></td>
<td>
<p>Integer. Maximum number of iterations for the NIPALS method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NOTE THAT THIS FUNCTION DOES NOT CENTER NOR SCALES THE MATRICES! Any normalization you will have to do yourself. It is best practice to at least center the variables though.
A stripped version of O2PLS
</p>
<p>If both <code>nx</code> and <code>ny</code> are zero, <code>o2m</code> is equivalent to PLS2 with orthonormal loadings.
This is a stripped implementation of O2PLS, using <code><a href="base.html#topic+svd">svd</a></code>. For data analysis purposes, consider using <code><a href="#topic+o2m">o2m</a></code>.
</p>


<h3>Value</h3>

<p>A list containing
</p>
<table>
<tr><td><code>Tt</code></td>
<td>
<p>Joint <code class="reqn">X</code> scores</p>
</td></tr>
<tr><td><code>W.</code></td>
<td>
<p>Joint <code class="reqn">X</code> loadings</p>
</td></tr>
<tr><td><code>U</code></td>
<td>
<p>Joint <code class="reqn">Y</code> scores</p>
</td></tr>
<tr><td><code>C.</code></td>
<td>
<p>Joint <code class="reqn">Y</code> loadings</p>
</td></tr>
<tr><td><code>P_Yosc.</code></td>
<td>
<p>Orthogonal <code class="reqn">X</code> loadings</p>
</td></tr>
<tr><td><code>P_Xosc.</code></td>
<td>
<p>Orthogonal <code class="reqn">Y</code> loadings</p>
</td></tr>
<tr><td><code>B_U</code></td>
<td>
<p>Regression coefficient in <code>Tt</code> ~ <code>U</code></p>
</td></tr>
<tr><td><code>B_T.</code></td>
<td>
<p>Regression coefficient in <code>U</code> ~ <code>Tt</code></p>
</td></tr>
<tr><td><code>H_TU</code></td>
<td>
<p>Residuals in <code>Tt</code> in <code>Tt</code> ~ <code>U</code></p>
</td></tr>
<tr><td><code>H_UT</code></td>
<td>
<p>Residuals in <code>U</code> in <code>U</code> ~ <code>Tt</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+o2m">o2m</a></code>
</p>

<hr>
<h2 id='o2m2'>Perform O2-PLS with two-way orthogonal corrections</h2><span id='topic+o2m2'></span>

<h3>Description</h3>

<p>NOTE THAT THIS FUNCTION DOES NOT CENTER NOR SCALES THE MATRICES! Any normalization you will have to do yourself. It is best practice to at least center the variables though.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>o2m2(X, Y, n, nx, ny, stripped = TRUE, tol = 1e-10, max_iterations = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="o2m2_+3A_x">X</code></td>
<td>
<p>Numeric matrix. Vectors will be coerced to matrix with <code>as.matrix</code> (if this is possible)</p>
</td></tr>
<tr><td><code id="o2m2_+3A_y">Y</code></td>
<td>
<p>Numeric matrix. Vectors will be coerced to matrix with <code>as.matrix</code> (if this is possible)</p>
</td></tr>
<tr><td><code id="o2m2_+3A_n">n</code></td>
<td>
<p>Integer. Number of joint PLS components. Must be positive.</p>
</td></tr>
<tr><td><code id="o2m2_+3A_nx">nx</code></td>
<td>
<p>Integer. Number of orthogonal components in <code class="reqn">X</code>. Negative values are interpreted as 0</p>
</td></tr>
<tr><td><code id="o2m2_+3A_ny">ny</code></td>
<td>
<p>Integer. Number of orthogonal components in <code class="reqn">Y</code>. Negative values are interpreted as 0</p>
</td></tr>
<tr><td><code id="o2m2_+3A_stripped">stripped</code></td>
<td>
<p>Logical. Use the stripped version of o2m (usually when cross-validating)?</p>
</td></tr>
<tr><td><code id="o2m2_+3A_tol">tol</code></td>
<td>
<p>Double. Threshold for which the NIPALS method is deemed converged. Must be positive.</p>
</td></tr>
<tr><td><code id="o2m2_+3A_max_iterations">max_iterations</code></td>
<td>
<p>Integer. Maximum number of iterations for the NIPALS method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If both <code>nx</code> and <code>ny</code> are zero, <code>o2m2</code> is equivalent to PLS2 with orthonormal loadings.
For cross-validation purposes, consider using <code>stripped = TRUE</code>.
</p>
<p>Note that in this function, a power-method based approach is used when the data dimensionality is larger than the sample size. E.g. for genomic data the covariance matrix might be too memory expensive.
</p>


<h3>Value</h3>

<p>A list containing
</p>
<table>
<tr><td><code>Tt</code></td>
<td>
<p>Joint <code class="reqn">X</code> scores</p>
</td></tr>
<tr><td><code>W.</code></td>
<td>
<p>Joint <code class="reqn">X</code> loadings</p>
</td></tr>
<tr><td><code>U</code></td>
<td>
<p>Joint <code class="reqn">Y</code> scores</p>
</td></tr>
<tr><td><code>C.</code></td>
<td>
<p>Joint <code class="reqn">Y</code> loadings</p>
</td></tr>
<tr><td><code>E</code></td>
<td>
<p>Residuals in <code class="reqn">X</code></p>
</td></tr>
<tr><td><code>Ff</code></td>
<td>
<p>Residuals in <code class="reqn">Y</code></p>
</td></tr>
<tr><td><code>T_Yosc</code></td>
<td>
<p>Orthogonal <code class="reqn">X</code> scores</p>
</td></tr>
<tr><td><code>P_Yosc.</code></td>
<td>
<p>Orthogonal <code class="reqn">X</code> loadings</p>
</td></tr>
<tr><td><code>W_Yosc</code></td>
<td>
<p>Orthogonal <code class="reqn">X</code> weights</p>
</td></tr>
<tr><td><code>U_Xosc</code></td>
<td>
<p>Orthogonal <code class="reqn">Y</code> scores</p>
</td></tr>
<tr><td><code>P_Xosc.</code></td>
<td>
<p>Orthogonal <code class="reqn">Y</code> loadings</p>
</td></tr>
<tr><td><code>C_Xosc</code></td>
<td>
<p>Orthogonal <code class="reqn">Y</code> weights</p>
</td></tr>
<tr><td><code>B_U</code></td>
<td>
<p>Regression coefficient in <code>Tt</code> ~ <code>U</code></p>
</td></tr>
<tr><td><code>B_T.</code></td>
<td>
<p>Regression coefficient in <code>U</code> ~ <code>Tt</code></p>
</td></tr>
<tr><td><code>H_TU</code></td>
<td>
<p>Residuals in <code>Tt</code> in <code>Tt</code> ~ <code>U</code></p>
</td></tr>
<tr><td><code>H_UT</code></td>
<td>
<p>Residuals in <code>U</code> in <code>U</code> ~ <code>Tt</code></p>
</td></tr>
<tr><td><code>X_hat</code></td>
<td>
<p>Prediction of <code class="reqn">X</code> with <code class="reqn">Y</code></p>
</td></tr>
<tr><td><code>Y_hat</code></td>
<td>
<p>Prediction of <code class="reqn">Y</code> with <code class="reqn">X</code></p>
</td></tr>
<tr><td><code>R2X</code></td>
<td>
<p>Variation (measured with <code><a href="#topic+ssq">ssq</a></code>) of the modeled part in <code class="reqn">X</code> (defined by joint + orthogonal variation) as proportion of variation in <code class="reqn">X</code></p>
</td></tr>
<tr><td><code>R2Y</code></td>
<td>
<p>Variation (measured with <code><a href="#topic+ssq">ssq</a></code>) of the modeled part in <code class="reqn">Y</code> (defined by joint + orthogonal variation) as proportion of variation in <code class="reqn">Y</code></p>
</td></tr>
<tr><td><code>R2Xcorr</code></td>
<td>
<p>Variation (measured with <code><a href="#topic+ssq">ssq</a></code>) of the joint part in <code class="reqn">X</code> as proportion of variation in <code class="reqn">X</code></p>
</td></tr>
<tr><td><code>R2Ycorr</code></td>
<td>
<p>Variation (measured with <code><a href="#topic+ssq">ssq</a></code>) of the joint part in <code class="reqn">Y</code> as proportion of variation in <code class="reqn">Y</code></p>
</td></tr>
<tr><td><code>R2X_YO</code></td>
<td>
<p>Variation (measured with <code><a href="#topic+ssq">ssq</a></code>) of the orthogonal part in <code class="reqn">X</code> as proportion of variation in <code class="reqn">X</code></p>
</td></tr>
<tr><td><code>R2Y_XO</code></td>
<td>
<p>Variation (measured with <code><a href="#topic+ssq">ssq</a></code>) of the orthogonal part in <code class="reqn">Y</code> as proportion of variation in <code class="reqn">Y</code></p>
</td></tr>
<tr><td><code>R2Xhat</code></td>
<td>
<p>Variation (measured with <code><a href="#topic+ssq">ssq</a></code>) of the predicted <code class="reqn">X</code> as proportion of variation in <code class="reqn">X</code></p>
</td></tr>
<tr><td><code>R2Yhat</code></td>
<td>
<p>Variation (measured with <code><a href="#topic+ssq">ssq</a></code>) of the predicted <code class="reqn">Y</code> as proportion of variation in <code class="reqn">Y</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+o2m">o2m</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This takes a couple of seconds on an intel i5
system.time(
             o2m2(matrix(rnorm(50*2000),50),matrix(rnorm(50*2000),50),1,0,0)
)

# This however takes 10 times as much...
# system.time(
#              o2m(matrix(rnorm(50*2000),50),matrix(rnorm(50*2000),50),1,0,0,
#              p_thresh = 1e4,q_thresh = 1e4)  # makes sure power method is not used
# )

</code></pre>

<hr>
<h2 id='OmicsPLS'>Data integration with O2PLS: Two-Way Orthogonal Partial Least Squares</h2><span id='topic+OmicsPLS'></span>

<h3>Description</h3>

<p>The OmicsPLS package is an R package for penalized integration of heterogeneous omics data. 
The software articles are published in (el Bouhaddani et al, 2018, doi: <a href="https://doi.org/10.1186/s12859-018-2371-3">10.1186/s12859-018-2371-3</a>) and (Gu et al, 2020, doi: <a href="https://doi.org/10.1186/s12859-021-03958-3">10.1186/s12859-021-03958-3</a>).
OmicsPLS includes the O2PLS fit, the GO2PLS fit, cross-validation tools and some misc functions.
</p>


<h3>Model and assumptions</h3>

<p><strong>Note that the rows of <code>X</code> and <code>Y</code> are the subjects and columns are variables.</strong>
The number of columns may be different, but the subjects should be the same in both datasets.
</p>
<p>The O2PLS model (Trygg &amp; Wold, 2003) decomposes two datasets <code class="reqn">X</code> and <code class="reqn">Y</code> into three parts. 
</p>

<ul>
<li><p>1. A joint part, representing the relationship between <code class="reqn">X</code> and <code class="reqn">Y</code>
</p>
</li>
<li><p>2. An orthogonal part, representing the unrelated latent variation in <code class="reqn">X</code> and <code class="reqn">Y</code> separately.
</p>
</li>
<li><p>3. A noise part capturing all residual variation.
</p>
</li></ul>

<p>See also the corresponding paper (el Bouhaddani et al, 2018).
</p>


<h3>Fitting</h3>

<p>The O2PLS fit is done with <code><a href="#topic+o2m">o2m</a></code>. 
For data <code>X</code> and <code>Y</code> you can run <code>o2m(X,Y,n,nx,ny)</code> for an O2PLS fit with <code>n</code> joint and <code>nx, ny</code> orthogonal components.
See the help page of <code><a href="#topic+o2m">o2m</a></code> for more information on parameters.
There are four ways to obtain an O2PLS fit, depending on the dimensionality.
</p>

<ul>
<li><p> For the not-too-high dimensional case, you may use <code><a href="#topic+o2m">o2m</a></code> with default parameters. E.g. <code>o2m(X,Y,n,nx,ny)</code>.
</p>
</li>
<li><p> In case you only want the parameters, you may add <code>stripped = TRUE</code> to obtain a stripped version of <code>o2m</code> which avoids calculating and storing some matrices. E.g. <code>o2m(X,Y,n,nx,ny,stripped=TRUE)</code>.
</p>
</li>
<li><p> For high dimensional cases, defined by <code>ncol(X)&gt;p_thresh</code> and <code>ncol(Y)&gt;q_thresh</code>, a NIPALS approach is used which avoids storing large matrices. E.g. <code>o2m(X,Y,n,nx,ny,p_thresh=3000,q_thresh=3000)</code>.
The thresholds are by default both at 3000 variables.
</p>
</li>
<li><p> If you want a stripped version in the high dimensional case, add <code>stripped = TRUE</code>. E.g. <code>o2m(X,Y,n,nx,ny,stripped=TRUE,p_thresh=3000,q_thresh=3000)</code>.
</p>
</li>
<li><p> For GO2PLS, add <code>sparsity = TRUE</code> and specify how many variables or groups to retain. E.g. <code>o2m(X,Y,n,nx,ny,sparse=TRUE,keepx, keepy)</code>.
</p>
</li></ul>



<h3>Obtaining results</h3>

<p>After fitting an O2PLS model, by running e.g. <code>fit = o2m(X,Y,n,nx,ny)</code>, the results can be visualised.
Use <code><a href="graphics.html#topic+plot">plot</a>(fit,...)</code> to plot the desired loadings with/without ggplot2.
Use <code><a href="base.html#topic+summary">summary</a>(fit,...)</code> to see the relative explained variances in the joint/orthogonal parts.
Also plotting the joint scores <code>fit$Tt, fit$U</code> and orthogonal scores <code>fit$T_Yosc, fit$U_Xosc</code> are of help.
</p>


<h3>Cross-validating</h3>

<p>Determining the number of components <code>n,nx,ny</code> is an important task. For this we have two methods.
See <code>citation("OmicsPLS")</code> for our proposed approach for determining the number of components, implemented in <code>crossval_o2m_adjR2</code>!
</p>

<ul>
<li><p> Cross-validation (CV) is done with <code><a href="#topic+crossval_o2m">crossval_o2m</a></code> and <code><a href="#topic+crossval_o2m_adjR2">crossval_o2m_adjR2</a></code>, both have built in parallelization which relies on the <code>parallel</code> package.
Usage is something like <code>crossval_o2m(X,Y,a,ax,ay,nr_folds)</code> where <code>a,ax,ay</code> are vectors of integers. See the help pages.
<code>nr_folds</code> is the number of folds, with <code>nr_folds = nrow(X)</code> for Leave-One-Out CV.
</p>
</li>
<li><p> For <code>crossval_o2m_adjR2</code> the same parameters are to be specified. This way of cross-validating is (potentially much)
faster than the standard approach. It is also recommended over the standard CV.
</p>
</li>
<li><p> To cross-validate the number of variables to keep, use <code><a href="#topic+crossval_sparsity">crossval_sparsity</a></code>. 
</p>
</li></ul>



<h3>S3 methods</h3>

<p>There are S3 methods implemented for a fit obtained with <code>o2m</code>, i.e. <code>fit &lt;- o2m(X,Y,n,nx,ny)</code>
</p>

<ul>
<li><p> Use plot(fit) to plot the loadings, see above.
</p>
</li>
<li><p> Use <code><a href="#topic+loadings">loadings</a>(fit)</code> to extract a matrix with loading values
</p>
</li>
<li><p> Use <code><a href="#topic+scores">scores</a>(fit)</code> to extract the scores
</p>
</li>
<li><p> Use <code><a href="base.html#topic+print">print</a></code> and <code><a href="base.html#topic+summary">summary</a></code> to print and summarize the fit object
</p>
</li></ul>



<h3>Imputation</h3>

<p>When the data contains missing values, one should impute them prior to using O2PLS.
There are many sophisticated approaches available, such as MICE and MissForest, and no one approach is the best for all situations.
To still allow users to quickly impute missing values in their data matrix, 
the <code><a href="#topic+impute_matrix">impute_matrix</a></code> function is implemented. 
It relies on the <code><a href="softImpute.html#topic+softImpute">softImpute</a></code> function+package and imputes based on the singular value decomposition.
</p>


<h3>Misc</h3>

<p>Also some handy tools are available
</p>

<ul>
<li> <p><code><a href="#topic+orth">orth</a>(X)</code> is a function to obtain an orthogonalized version of a matrix or vector <code>X</code>.
</p>
</li>
<li> <p><code><a href="#topic+ssq">ssq</a>(X)</code> is a function to calculate the sum of squares (or squared Frobenius norm) of <code>X</code>. See also <code><a href="#topic+vnorm">vnorm</a></code> for calculating the norm of each column in <code>X</code>.
</p>
</li>
<li> <p><code><a href="#topic+mse">mse</a>(x, y)</code> returns the mean squared difference between two matrices/vectors. 
</p>
</li></ul>



<h3>Citation</h3>

<p>If you use the OmicsPLS R package in your research, please cite the corresponding software paper:
</p>
<p><strong>el Bouhaddani, S., Uh, H.-W., Jongbloed, G., Hayward, C., Klarić, L., Kiełbasa, S. M., &amp; Houwing-Duistermaat, J.</strong> (2018).
<em>Integrating omics datasets with the OmicsPLS package.</em>
BMC Bioinformatics, 19(1). doi: <a href="https://doi.org/10.1186/s12859-018-2371-3">10.1186/s12859-018-2371-3</a>
</p>
<p>The bibtex entry can be obtained with command <code>citation("OmicsPLS")</code>.
Thank you!
</p>
<p>The original paper proposing O2PLS is
</p>
<p><strong>Trygg, J., &amp; Wold, S.</strong> (2003). 
<em>O2-PLS, a two-block (X-Y) latent variable regression (LVR) method with an integral OSC filter.</em> 
Journal of Chemometrics, 17(1), 53-64. doi: <a href="https://doi.org/10.1002/cem.775">10.1002/cem.775</a>
</p>


<h3>Author(s)</h3>

<p>Said el Bouhaddani (<a href="mailto:s.elbouhaddani@umcutrecht.nl">s.elbouhaddani@umcutrecht.nl</a>, Twitter: @selbouhaddani),
Zhujie Gu, 
Szymon Kielbasa,
Geurt Jongbloed,
Jeanine Houwing-Duistermaat,
Hae-Won Uh.
</p>
<p>Maintainer: Said el Bouhaddani (<a href="mailto:s.elbouhaddani@umcutrecht.nl">s.elbouhaddani@umcutrecht.nl</a>).
</p>

<hr>
<h2 id='orth'>Orthogonalize a matrix</h2><span id='topic+orth'></span>

<h3>Description</h3>

<p>Orthogonalize a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orth(X, X_true = NULL, type = c("QR", "SVD"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="orth_+3A_x">X</code></td>
<td>
<p>Numeric vector or matrix.</p>
</td></tr>
<tr><td><code id="orth_+3A_x_true">X_true</code></td>
<td>
<p>(optional) A 'true' matrix/vector. Used to correct the sign of the orthonormalized X if QR is used. Only the first column is corrected.</p>
</td></tr>
<tr><td><code id="orth_+3A_type">type</code></td>
<td>
<p>A character or numeric. Should be one of &quot;QR&quot; or &quot;SVD&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Choosing type='QR' uses a QR decomposition of X to produce orthonormal columns. For type=='SVD' it uses an SVD decomposition.
The columns are corrected for sign.
</p>


<h3>Value</h3>

<p>An orthogonalized representation of <code class="reqn">X</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>orth(c(3,4))
round(crossprod(orth(matrix(rnorm(500),100,5))),4)
orth(matrix(1:9,3,3),type='QR')[,1] - orth(1:3); orth(matrix(1:9,3,3),type='SVD')[,1] - orth(1:3);
</code></pre>

<hr>
<h2 id='orth_vec'>Orthogonalize a sparse loading vector with regard to a matrix</h2><span id='topic+orth_vec'></span>

<h3>Description</h3>

<p>Orthogonalize a sparse loading vector with regard to a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orth_vec(x, W)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="orth_vec_+3A_x">x</code></td>
<td>
<p>sparse loading vector to be orthogonalized</p>
</td></tr>
<tr><td><code id="orth_vec_+3A_w">W</code></td>
<td>
<p>sparse loading matrix of the previous loading vectors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sparse loading vector
</p>

<hr>
<h2 id='plot.o2m'>Plot one or two loading vectors for class o2m</h2><span id='topic+plot.o2m'></span>

<h3>Description</h3>

<p>This function plots one or two loading vectors, by default with ggplot2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'o2m'
plot(
  x,
  loading_name = c("Xjoint", "Yjoint", "gr_Xjoint", "gr_Yjoint", "Xorth", "Yorth"),
  i = 1,
  j = NULL,
  use_ggplot2 = TRUE,
  label = c("number", "colnames"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.o2m_+3A_x">x</code></td>
<td>
<p>An O2PLS fit, with class 'o2m'</p>
</td></tr>
<tr><td><code id="plot.o2m_+3A_loading_name">loading_name</code></td>
<td>
<p>character string. One of the following: 'Xjoint', 'Yjoint', 'gr_Xjoint', 'gr_Yjoint', 'Xorth' or 'Yorth'.</p>
</td></tr>
<tr><td><code id="plot.o2m_+3A_i">i</code></td>
<td>
<p>Integer. First component to be plotted.</p>
</td></tr>
<tr><td><code id="plot.o2m_+3A_j">j</code></td>
<td>
<p>NULL (default) or Integer. Second component to be plotted.</p>
</td></tr>
<tr><td><code id="plot.o2m_+3A_use_ggplot2">use_ggplot2</code></td>
<td>
<p>Logical. Default is <code>TRUE</code>. If <code>FALSE</code>, the usual plot device will be used.</p>
</td></tr>
<tr><td><code id="plot.o2m_+3A_label">label</code></td>
<td>
<p>Character, either 'number' or 'colnames'. The first option prints numbers, the second prints the colnames</p>
</td></tr>
<tr><td><code id="plot.o2m_+3A_...">...</code></td>
<td>
<p>Further arguments to <code>geom_text</code>, such as size, col, alpha, etc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>use_ggplot2</code> is <code>TRUE</code> a ggplot2 object. Else NULL.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.o2m">summary.o2m</a></code>
</p>

<hr>
<h2 id='pow_o2m'>NIPALS method for PLS2</h2><span id='topic+pow_o2m'></span>

<h3>Description</h3>

<p>Performs power method for PLS2 loadings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pow_o2m(X, Y, n, tol = 1e-10, max_iterations = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pow_o2m_+3A_x">X</code></td>
<td>
<p>Numeric matrix. Vectors will be coerced to matrix with <code>as.matrix</code> (if this is possible)</p>
</td></tr>
<tr><td><code id="pow_o2m_+3A_y">Y</code></td>
<td>
<p>Numeric matrix. Vectors will be coerced to matrix with <code>as.matrix</code> (if this is possible)</p>
</td></tr>
<tr><td><code id="pow_o2m_+3A_n">n</code></td>
<td>
<p>Integer. Number of joint PLS components. Must be positive.</p>
</td></tr>
<tr><td><code id="pow_o2m_+3A_tol">tol</code></td>
<td>
<p>Double. Threshold for which the NIPALS method is deemed converged. Must be positive.</p>
</td></tr>
<tr><td><code id="pow_o2m_+3A_max_iterations">max_iterations</code></td>
<td>
<p>Integer. Maximum number of iterations for the NIPALS method.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+o2m">o2m</a></code>
</p>

<hr>
<h2 id='pow_o2m2'>Power method for PLS2</h2><span id='topic+pow_o2m2'></span>

<h3>Description</h3>

<p>DEFUNCT!!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pow_o2m2(X, Y, n, tol = 1e-10, max_iterations = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pow_o2m2_+3A_x">X</code></td>
<td>
<p>Numeric matrix. Vectors will be coerced to matrix with <code>as.matrix</code> (if this is possible)</p>
</td></tr>
<tr><td><code id="pow_o2m2_+3A_y">Y</code></td>
<td>
<p>Numeric matrix. Vectors will be coerced to matrix with <code>as.matrix</code> (if this is possible)</p>
</td></tr>
<tr><td><code id="pow_o2m2_+3A_n">n</code></td>
<td>
<p>Integer. Number of joint PLS components. Must be positive.</p>
</td></tr>
<tr><td><code id="pow_o2m2_+3A_tol">tol</code></td>
<td>
<p>Double. Threshold for which the NIPALS method is deemed converged. Must be positive.</p>
</td></tr>
<tr><td><code id="pow_o2m2_+3A_max_iterations">max_iterations</code></td>
<td>
<p>Integer. Maximum number of iterations for the NIPALS method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Performs power method for PLS2 loadings.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+o2m">o2m</a></code>
</p>

<hr>
<h2 id='predict.o2m'>Predicts X or Y</h2><span id='topic+predict.o2m'></span>

<h3>Description</h3>

<p>Predicts X or Y based on new data on Y or X
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'o2m'
predict(object, newdata, XorY = c("X", "Y"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.o2m_+3A_object">object</code></td>
<td>
<p>List. Should be of class <code><a href="#topic+o2m">o2m</a></code>.</p>
</td></tr>
<tr><td><code id="predict.o2m_+3A_newdata">newdata</code></td>
<td>
<p>New data, which one of X or Y is specified in <code>XorY</code>.</p>
</td></tr>
<tr><td><code id="predict.o2m_+3A_xory">XorY</code></td>
<td>
<p>Character specifying whether <code>newdata</code> is X or Y.</p>
</td></tr>
<tr><td><code id="predict.o2m_+3A_...">...</code></td>
<td>
<p>For compatibility</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prediction is done after correcting for orthogonal parts.
</p>


<h3>Value</h3>

<p>Predicted Data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>predict(o2m(scale(1:10), scale(1:10), 1, 0, 0), newdata = scale(1:5), XorY = "X")
</code></pre>

<hr>
<h2 id='print.cvo2m'>Cross-validate procedure for O2PLS</h2><span id='topic+print.cvo2m'></span>

<h3>Description</h3>

<p>Cross-validate procedure for O2PLS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cvo2m'
print(x, include_matrix = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.cvo2m_+3A_x">x</code></td>
<td>
<p>List of class <code>"cvo2m"</code>, produced by <code><a href="#topic+crossval_o2m">crossval_o2m</a></code>.</p>
</td></tr>
<tr><td><code id="print.cvo2m_+3A_include_matrix">include_matrix</code></td>
<td>
<p>Logical. Should the 3-d array with Prediction errors also be printed.</p>
</td></tr>
<tr><td><code id="print.cvo2m_+3A_...">...</code></td>
<td>
<p>For consistency.</p>
</td></tr>
</table>

<hr>
<h2 id='print.o2m'>Print function for O2PLS.</h2><span id='topic+print.o2m'></span>

<h3>Description</h3>

<p>This function is the print method for an O2PLS fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'o2m'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.o2m_+3A_x">x</code></td>
<td>
<p>An O2PLS fit (an object of class o2m)</p>
</td></tr>
<tr><td><code id="print.o2m_+3A_...">...</code></td>
<td>
<p>For consistency</p>
</td></tr>
</table>

<hr>
<h2 id='print.pre.o2m'>Print function for O2PLS.</h2><span id='topic+print.pre.o2m'></span>

<h3>Description</h3>

<p>This function is the print method for an O2PLS fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pre.o2m'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.pre.o2m_+3A_x">x</code></td>
<td>
<p>An O2PLS fit (an object of class o2m)</p>
</td></tr>
<tr><td><code id="print.pre.o2m_+3A_...">...</code></td>
<td>
<p>For consistency</p>
</td></tr>
</table>

<hr>
<h2 id='print.summary.o2m'>Prints the summary of an O2PLS fit</h2><span id='topic+print.summary.o2m'></span>

<h3>Description</h3>

<p>Readable output is given in the form of percentages of variances explained.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.o2m'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.o2m_+3A_...">...</code></td>
<td>
<p>For compatibility</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>summary(o2m(scale(-2:2),scale(-2:2*4),1,0,0))
</code></pre>

<hr>
<h2 id='rmsep'>Root MSE of Prediction</h2><span id='topic+rmsep'></span>

<h3>Description</h3>

<p>Calculates the Root MSE of prediction on test data. Only tested to work inside <code><a href="#topic+loocv">loocv</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmsep(Xtst, Ytst, fit, combi = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmsep_+3A_xtst">Xtst</code></td>
<td>
<p>Numeric vector or matrix.</p>
</td></tr>
<tr><td><code id="rmsep_+3A_ytst">Ytst</code></td>
<td>
<p>Numeric vector or matrix.</p>
</td></tr>
<tr><td><code id="rmsep_+3A_fit">fit</code></td>
<td>
<p><code><a href="#topic+o2m">o2m</a></code> fit (on data without <code>Xtst</code> and <code>Ytst</code>).</p>
</td></tr>
<tr><td><code id="rmsep_+3A_combi">combi</code></td>
<td>
<p>Logical. Should the symmetrized MSE be used, i.e. add both MSEs. Not yet implemented, but see <code><a href="#topic+rmsep_combi">rmsep_combi</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is the building block for <code><a href="#topic+loocv">loocv</a></code>, as it produced the prediction error for test (left out) data.
</p>


<h3>Value</h3>

<p>Mean squares difference between predicted Y and true Y
</p>

<hr>
<h2 id='rmsep_combi'>Symmetrized root MSE of Prediction</h2><span id='topic+rmsep_combi'></span>

<h3>Description</h3>

<p>Calculates the symmetrized root MSE of prediction on test data. *Expected* to work in combination with <code><a href="#topic+loocv">loocv</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmsep_combi(Xtst, Ytst, fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmsep_combi_+3A_xtst">Xtst</code></td>
<td>
<p>Numeric vector or matrix.</p>
</td></tr>
<tr><td><code id="rmsep_combi_+3A_ytst">Ytst</code></td>
<td>
<p>Numeric vector or matrix.</p>
</td></tr>
<tr><td><code id="rmsep_combi_+3A_fit">fit</code></td>
<td>
<p><code><a href="#topic+o2m">o2m</a></code> fit (on data without <code>Xtst</code> and <code>Ytst</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is the building block for <code><a href="#topic+loocv">loocv</a></code>, as it produced the prediction error for test (left out) data.
</p>
<p>This is a symmetrized version of <code><a href="#topic+rmsep">rmsep</a></code>, and is used by <code><a href="#topic+loocv">loocv</a></code>. The predicion error of both <code>Xtst</code> and <code>Ytst</code> are calculated and summed.
Whether this is a good idea depends: If <code class="reqn">X</code> and <code class="reqn">Y</code> have similar meanings (LC-MS versus MALDI) this is a good thing to do. If the two matrices do not have similar meanings,
(Metabolomics versus Transcriptomics) then you may want to not sum up the two prediction errors or include weights in the sum.
</p>


<h3>Value</h3>

<p>Mean squares difference between predicted Y and true Y
</p>

<hr>
<h2 id='scores'>Extract the scores from an O2PLS fit</h2><span id='topic+scores'></span><span id='topic+scores.o2m'></span>

<h3>Description</h3>

<p>This function extracts score matrices from an O2PLS fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scores(x, ...)

## S3 method for class 'o2m'
scores(
  x,
  which_part = c("Xjoint", "Yjoint", "Xorth", "Yorth"),
  subset = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scores_+3A_x">x</code></td>
<td>
<p>Object of class <code>o2m</code></p>
</td></tr>
<tr><td><code id="scores_+3A_...">...</code></td>
<td>
<p>For consistency</p>
</td></tr>
<tr><td><code id="scores_+3A_which_part">which_part</code></td>
<td>
<p>character string. One of the following: 'Xjoint', 'Yjoint', 'Xorth' or 'Yorth'.</p>
</td></tr>
<tr><td><code id="scores_+3A_subset">subset</code></td>
<td>
<p>subset of scores vectors to be extracted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Scores matrix
</p>


<h3>See Also</h3>

<p><code><a href="#topic+loadings.o2m">loadings.o2m</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>scores(o2m(scale(-2:2),scale(-2:2*4),1,0,0))

</code></pre>

<hr>
<h2 id='so2m_group'>Perform Group Sparse O2PLS</h2><span id='topic+so2m_group'></span>

<h3>Description</h3>

<p>Perform Group Sparse O2PLS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>so2m_group(
  X,
  Y,
  n,
  nx,
  ny,
  groupx = NULL,
  groupy = NULL,
  keepx = NULL,
  keepy = NULL,
  tol = 1e-10,
  max_iterations = 1000,
  max_iterations_sparsity = 1000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="so2m_group_+3A_x">X</code></td>
<td>
<p>Numeric matrix. Vectors will be coerced to matrix with <code>as.matrix</code> (if this is possible)</p>
</td></tr>
<tr><td><code id="so2m_group_+3A_y">Y</code></td>
<td>
<p>Numeric matrix. Vectors will be coerced to matrix with <code>as.matrix</code> (if this is possible)</p>
</td></tr>
<tr><td><code id="so2m_group_+3A_n">n</code></td>
<td>
<p>Integer. Number of joint PLS components. Must be positive.</p>
</td></tr>
<tr><td><code id="so2m_group_+3A_nx">nx</code></td>
<td>
<p>Integer. Number of orthogonal components in <code class="reqn">X</code>. Negative values are interpreted as 0</p>
</td></tr>
<tr><td><code id="so2m_group_+3A_ny">ny</code></td>
<td>
<p>Integer. Number of orthogonal components in <code class="reqn">Y</code>. Negative values are interpreted as 0</p>
</td></tr>
<tr><td><code id="so2m_group_+3A_groupx">groupx</code></td>
<td>
<p>Vector. Used when <code>sparse = TRUE</code>. A vector of strings indicating group names of each X-variable. Its length must be equal to the number of variables in <code class="reqn">X</code>. The order of group names must corresponds to the order of the variables.</p>
</td></tr>
<tr><td><code id="so2m_group_+3A_groupy">groupy</code></td>
<td>
<p>Vector. Used when <code>sparse = TRUE</code>. A vector of strings indicating group names of each Y-variable. The length must be equal to the number of variables in <code class="reqn">Y</code>. The order of group names must corresponds to the order of the variables.</p>
</td></tr>
<tr><td><code id="so2m_group_+3A_keepx">keepx</code></td>
<td>
<p>Vector. Used when <code>sparse = TRUE</code>. A vector of length <code>n</code> indicating how many variables (or groups if <code>groupx</code> is provided) to keep in each of the joint component of <code class="reqn">X</code>. If the input is an integer, all the components will have the same amount of variables or groups retained.</p>
</td></tr>
<tr><td><code id="so2m_group_+3A_keepy">keepy</code></td>
<td>
<p>Vector. Used when <code>sparse = TRUE</code>. A vector of length <code>n</code> indicating how many variables (or groups if <code>groupx</code> is provided) to keep in each of the joint component of <code class="reqn">Y</code>. If the input is an integer, all the components will have the same amount of variables or groups retained.</p>
</td></tr>
<tr><td><code id="so2m_group_+3A_tol">tol</code></td>
<td>
<p>Double. Threshold for which the NIPALS method is deemed converged. Must be positive.</p>
</td></tr>
<tr><td><code id="so2m_group_+3A_max_iterations">max_iterations</code></td>
<td>
<p>Integer. Maximum number of iterations for the NIPALS method.</p>
</td></tr>
<tr><td><code id="so2m_group_+3A_max_iterations_sparsity">max_iterations_sparsity</code></td>
<td>
<p>Integer. Used when <code>sparse = TRUE</code>. Maximum number of iterations for the NIPALS method for GO2PLS.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing
</p>
<table>
<tr><td><code>Tt</code></td>
<td>
<p>Joint <code class="reqn">X</code> scores</p>
</td></tr>
<tr><td><code>W.</code></td>
<td>
<p>Joint <code class="reqn">X</code> loadings</p>
</td></tr>
<tr><td><code>U</code></td>
<td>
<p>Joint <code class="reqn">Y</code> scores</p>
</td></tr>
<tr><td><code>C.</code></td>
<td>
<p>Joint <code class="reqn">Y</code> loadings</p>
</td></tr>
<tr><td><code>T_Yosc</code></td>
<td>
<p>Orthogonal <code class="reqn">X</code> scores</p>
</td></tr>
<tr><td><code>P_Yosc.</code></td>
<td>
<p>Orthogonal <code class="reqn">X</code> loadings</p>
</td></tr>
<tr><td><code>W_Yosc</code></td>
<td>
<p>Orthogonal <code class="reqn">X</code> weights</p>
</td></tr>
<tr><td><code>U_Xosc</code></td>
<td>
<p>Orthogonal <code class="reqn">Y</code> scores</p>
</td></tr>
<tr><td><code>P_Xosc.</code></td>
<td>
<p>Orthogonal <code class="reqn">Y</code> loadings</p>
</td></tr>
<tr><td><code>C_Xosc</code></td>
<td>
<p>Orthogonal <code class="reqn">Y</code> weights</p>
</td></tr>
<tr><td><code>B_U</code></td>
<td>
<p>Regression coefficient in <code>Tt</code> ~ <code>U</code></p>
</td></tr>
<tr><td><code>B_T.</code></td>
<td>
<p>Regression coefficient in <code>U</code> ~ <code>Tt</code></p>
</td></tr>
<tr><td><code>H_TU</code></td>
<td>
<p>Residuals in <code>Tt</code> in <code>Tt</code> ~ <code>U</code></p>
</td></tr>
<tr><td><code>H_UT</code></td>
<td>
<p>Residuals in <code>U</code> in <code>U</code> ~ <code>Tt</code></p>
</td></tr>
<tr><td><code>W_gr</code></td>
<td>
<p>Joint weights of X variables at group level. They are the norms of the X-joint loadings per group</p>
</td></tr>
<tr><td><code>C_gr</code></td>
<td>
<p>Joint weights of Y variables at group level. They are the norms of the Y-joint loadings per group</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+o2m">o2m</a></code>
</p>

<hr>
<h2 id='ssq'>Calculate Sum of Squares</h2><span id='topic+ssq'></span>

<h3>Description</h3>

<p>Calculate Sum of Squares
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssq(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ssq_+3A_x">X</code></td>
<td>
<p>Numeric vector or matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the Frobenius norm of <code class="reqn">X</code>.
</p>


<h3>Value</h3>

<p>The sum of squared elements of <code class="reqn">X</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ssq(tcrossprod(1:5))
ssq(rnorm(1e5))/1e5
</code></pre>

<hr>
<h2 id='summary.o2m'>Summary of an O2PLS fit</h2><span id='topic+summary.o2m'></span>

<h3>Description</h3>

<p>Until now only variational summary given by the R2's is outputted
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'o2m'
summary(object, digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.o2m_+3A_object">object</code></td>
<td>
<p>List. Should be of class <code><a href="#topic+o2m">o2m</a></code>.</p>
</td></tr>
<tr><td><code id="summary.o2m_+3A_digits">digits</code></td>
<td>
<p>Integer, number of digits.</p>
</td></tr>
<tr><td><code id="summary.o2m_+3A_...">...</code></td>
<td>
<p>For compatibility</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with R2 values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.o2m">plot.o2m</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(o2m(scale(-2:2),scale(-2:2*4),1,0,0))

</code></pre>

<hr>
<h2 id='thresh_n'>Soft threshholding a vector with respect to a number of variables</h2><span id='topic+thresh_n'></span>

<h3>Description</h3>

<p>Soft threshholding a vector with respect to a number of variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thresh_n(x, keepx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thresh_n_+3A_x">x</code></td>
<td>
<p>Numerical vector</p>
</td></tr>
<tr><td><code id="thresh_n_+3A_keepx">keepx</code></td>
<td>
<p>How many non-zero</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Soft-thresholded vector
</p>

<hr>
<h2 id='thresh_n_gr'>Soft threshholding a vector with respect to a number of groups</h2><span id='topic+thresh_n_gr'></span>

<h3>Description</h3>

<p>Soft threshholding a vector with respect to a number of groups
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thresh_n_gr(w, keep_gr, index_gr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thresh_n_gr_+3A_w">w</code></td>
<td>
<p>Numerical loading vector</p>
</td></tr>
<tr><td><code id="thresh_n_gr_+3A_keep_gr">keep_gr</code></td>
<td>
<p>How many groups to retain</p>
</td></tr>
<tr><td><code id="thresh_n_gr_+3A_index_gr">index_gr</code></td>
<td>
<p>List of index and size. index are the index of variables belongs to the group in the original vector, size is the group size</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing sparse loading vector and names of the selected groups
</p>

<hr>
<h2 id='vnorm'>Norm of a vector or columns of a matrix</h2><span id='topic+vnorm'></span>

<h3>Description</h3>

<p>Norm of a vector or columns of a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vnorm(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vnorm_+3A_x">x</code></td>
<td>
<p>Numeric vector or matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(columnwise) Euclidian norm of <code class="reqn">x</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vnorm(orth(1:5))
vnorm(matrix(1:9,3,3))^2 - colSums(matrix(1:9,3)^2)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
