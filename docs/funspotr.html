<!DOCTYPE html><html><head><title>Help for package funspotr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {funspotr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#check_pkgs_availability'><p>Check Packages Availability</p></a></li>
<li><a href='#funspotr-package'><p>funspotr: Spot R Functions &amp; Packages</p></a></li>
<li><a href='#install_missing_pkgs'><p>Install Missing Packages From CRAN</p></a></li>
<li><a href='#list_files_github_gists'><p>List Github Gists of User</p></a></li>
<li><a href='#list_files_github_repo'><p>List Files in Github Repo</p></a></li>
<li><a href='#list_files_wd'><p>List Files in Working Directory</p></a></li>
<li><a href='#network_plot'><p>funspotr Network Plot</p></a></li>
<li><a href='#spot_funs'><p>Spot Functions</p></a></li>
<li><a href='#spot_funs_custom'><p>Spot Functions Custom</p></a></li>
<li><a href='#spot_funs_files'><p>Spot Packages or Functions in dataframe of Paths</p></a></li>
<li><a href='#spot_pkgs'><p>Spot Packages</p></a></li>
<li><a href='#spot_pkgs_from_description'><p>Spot package dependencies from DESCRIPTION file</p></a></li>
<li><a href='#spot_pkgs_used'><p>Spot Packages Used</p></a></li>
<li><a href='#spot_tags'><p>Spot Tags</p></a></li>
<li><a href='#str_detect_r_docs'><p>String Detect R or Rmarkdown or Quarto File endings</p></a></li>
<li><a href='#unnest_results'><p>Unnest Results</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Spot R Functions &amp; Packages</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.4</td>
</tr>
<tr>
<td>Description:</td>
<td>Helpers for parsing out the R functions
  and packages used in R scripts and notebooks.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/brshallo/funspotr/issues">https://github.com/brshallo/funspotr/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr (&ge; 0.8.3), tidyr, purrr, stringr, glue, knitr, httr,
callr, readr, here, formatR, fs, tibble, utils, import (&ge;
1.3.0), lifecycle</td>
</tr>
<tr>
<td>Suggests:</td>
<td>remotes, visNetwork, igraph</td>
</tr>
<tr>
<td>Enhances:</td>
<td>blogdown</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://brshallo.github.io/funspotr/">https://brshallo.github.io/funspotr/</a></td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-22 00:07:46 UTC; bshallow</td>
</tr>
<tr>
<td>Author:</td>
<td>Bryan Shalloway [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Bryan Shalloway &lt;brshallodev@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-22 00:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='check_pkgs_availability'>Check Packages Availability</h2><span id='topic+check_pkgs_availability'></span>

<h3>Description</h3>

<p>Check whether packages are available in current library.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_pkgs_availability(pkgs, quietly = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_pkgs_availability_+3A_pkgs">pkgs</code></td>
<td>
<p>Character vector of package names. (Typically the output from
<code>spot_pkgs()</code>).</p>
</td></tr>
<tr><td><code id="check_pkgs_availability_+3A_quietly">quietly</code></td>
<td>
<p>logical: should progress and error messages be suppressed?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named logical vector indicating whether each package is available on
the machine.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(funspotr)
library(dplyr)

file_lines &lt;- "
library(dplyr)
require(tidyr)
library(madeUpPkg)

as_tibble(mpg) %&gt;%
  group_by(class) %&gt;%
  nest() %&gt;%
  mutate(stats = purrr::map(data,
                            ~lm(cty ~ hwy, data = .x)))

made_up_fun()
"

file_output &lt;- tempfile(fileext = ".R")
writeLines(file_lines, file_output)

spot_pkgs(file_output) %&gt;%
  check_pkgs_availability()

</code></pre>

<hr>
<h2 id='funspotr-package'>funspotr: Spot R Functions &amp; Packages</h2><span id='topic+funspotr'></span><span id='topic+funspotr-package'></span>

<h3>Description</h3>

<p>To learn more about funspotr see https://github.com/brshallo/funspotr
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Bryan Shalloway <a href="mailto:brshallodev@gmail.com">brshallodev@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://brshallo.github.io/funspotr/">https://brshallo.github.io/funspotr/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/brshallo/funspotr/issues">https://github.com/brshallo/funspotr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='install_missing_pkgs'>Install Missing Packages From CRAN</h2><span id='topic+install_missing_pkgs'></span>

<h3>Description</h3>

<p>Attempt to install missing packages from CRAN. In most cases, it is safer to
clone and use <code>renv::dependencies()</code>. See README for example. You should
first verify packages specified are available on CRAN, otherwise will error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>install_missing_pkgs(pkgs_availability)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="install_missing_pkgs_+3A_pkgs_availability">pkgs_availability</code></td>
<td>
<p>Named logical vector where names are packages &ndash;
generally the output of running <code>check_pkgs_availability()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Installs packages from cran using <code>remotes::install_cran()</code> if
available, else <code>install.packages()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(funspotr)
library(dplyr)

file_lines &lt;- "
library(dplyr)
require(tidyr)

as_tibble(mpg) %&gt;%
  group_by(class) %&gt;%
  nest() %&gt;%
  mutate(stats = purrr::map(data,
                            ~lm(cty ~ hwy, data = .x)))

"

file_output &lt;- tempfile(fileext = '.R')
writeLines(file_lines, file_output)

spot_pkgs(file_output) %&gt;%
  check_pkgs_availability() %&gt;%
  install_missing_pkgs()

## End(Not run)
</code></pre>

<hr>
<h2 id='list_files_github_gists'>List Github Gists of User</h2><span id='topic+list_files_github_gists'></span>

<h3>Description</h3>

<p>Given a username, return a dataframe with paths to all the gists by that user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_files_github_gists(
  user,
  pattern = stringr::regex("(r|rmd|rmarkdown|qmd)$", ignore_case = TRUE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list_files_github_gists_+3A_user">user</code></td>
<td>
<p>Character string of username whose github gists you want to pull.</p>
</td></tr>
<tr><td><code id="list_files_github_gists_+3A_pattern">pattern</code></td>
<td>
<p>Regex pattern to keep only matching files. Default is
<code>stringr::regex("(r|rmd|rmarkdown|qmd)$", ignore_case = TRUE)</code> which will
keep only R, Rmarkdown and Quarto documents. If you have a lot of .md gists
that can be converted to .R files you may want to edit this argument. To
keep all files use <code>"."</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe with <code>relative_paths</code> and <code>absolute_paths</code> of file paths.
Because gists do not exist in a folder structure <code>relative_paths</code> will
generally just be a file name. <code>absolute_paths</code> a url to the raw file. See
<code>unnest_results()</code> for helper to put into an easier to read format.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+list_files_github_repo">list_files_github_repo()</a></code>, <code><a href="#topic+list_files_wd">list_files_wd()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
library(funspotr)

# pulling and analyzing my R file github gists
gists_urls &lt;- list_files_github_gists("brshallo", pattern = ".")

# Will just parse the first 2 files/gists
# Note that is easy to hit the API limit if have lots of gists
contents &lt;- filter(gists_urls, str_detect_r_docs(absolute_paths)) %&gt;%
  slice(1:2) %&gt;%
  spot_funs_files()


contents %&gt;%
  unnest_results()

</code></pre>

<hr>
<h2 id='list_files_github_repo'>List Files in Github Repo</h2><span id='topic+list_files_github_repo'></span>

<h3>Description</h3>

<p>Return a dataframe containing the paths of files in a github repostiory.
Generally used prior to <code style="white-space: pre;">&#8288;spot_{funs/pkgs}_files()&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_files_github_repo(
  repo,
  branch = NULL,
  pattern = stringr::regex("(r|rmd|rmarkdown|qmd)$", ignore_case = TRUE),
  rmv_index = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list_files_github_repo_+3A_repo">repo</code></td>
<td>
<p>Github repository, e.g. &quot;brshallo/feat-eng-lags-presentation&quot;</p>
</td></tr>
<tr><td><code id="list_files_github_repo_+3A_branch">branch</code></td>
<td>
<p>Branch of github repository, default is &quot;main&quot;.</p>
</td></tr>
<tr><td><code id="list_files_github_repo_+3A_pattern">pattern</code></td>
<td>
<p>Regex pattern to keep only matching files. Default is
<code>stringr::regex("(r|rmd|rmarkdown|qmd)$", ignore_case = TRUE)</code> which will
keep only R, Rmarkdown and Quarto documents. To keep all files use <code>"."</code>.</p>
</td></tr>
<tr><td><code id="list_files_github_repo_+3A_rmv_index">rmv_index</code></td>
<td>
<p>Logical, most repos containing blogdown sites will have an
index.R file at the root. Change to <code>FALSE</code> if you don't want this file
removed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe with columns of <code>relative_paths</code> and <code>absolute_paths</code> for
file path locations. <code>absolute_paths</code> will be urls to raw files.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+list_files_wd">list_files_wd()</a></code>, <code><a href="#topic+list_files_github_gists">list_files_github_gists()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
library(funspotr)

# pulling and analyzing my R file github gists
gh_urls &lt;- list_files_github_repo("brshallo/feat-eng-lags-presentation", branch = "main")

# Will just parse the first 2 files/gists
contents &lt;- spot_funs_files(slice(gh_urls, 1:2))

contents %&gt;%
  unnest_results()

</code></pre>

<hr>
<h2 id='list_files_wd'>List Files in Working Directory</h2><span id='topic+list_files_wd'></span>

<h3>Description</h3>

<p>Return a dataframe containing the paths of files in the working directory.
Generally used prior to <code style="white-space: pre;">&#8288;spot_{funs/pkgs}_files()&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_files_wd(
  path = ".",
  pattern = stringr::regex("(r|rmd|rmarkdown|qmd)$", ignore_case = TRUE),
  rmv_index = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list_files_wd_+3A_path">path</code></td>
<td>
<p>Character vector or path. Default is &quot;.&quot; which will set the
starting location for <code>relative_paths</code>.</p>
</td></tr>
<tr><td><code id="list_files_wd_+3A_pattern">pattern</code></td>
<td>
<p>Regex pattern to keep only matching files. Default is
<code>stringr::regex("(r|rmd|rmarkdown|qmd)$", ignore_case = TRUE)</code> which will
keep only R, Rmarkdown and Quarto documents. To keep all files use <code>"."</code>.</p>
</td></tr>
<tr><td><code id="list_files_wd_+3A_rmv_index">rmv_index</code></td>
<td>
<p>Logical, most repos containing blogdown sites will have an
index.R file at the root. Change to <code>FALSE</code> if you don't want this file
removed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Can also be used outside of working directory if <code>path</code> is specified.
</p>


<h3>Value</h3>

<p>Dataframe with columns of <code>relative_paths</code> and <code>absolute_paths</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+list_files_github_repo">list_files_github_repo()</a></code>, <code><a href="#topic+list_files_github_gists">list_files_github_gists()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
library(funspotr)

# pulling and analyzing my R file github gists
files_local &lt;- list_files_wd()

# Will just parse the first 2 files/gists
contents &lt;- spot_funs_files(slice(files_local, 2:3))

contents %&gt;%
  unnest_results()

</code></pre>

<hr>
<h2 id='network_plot'>funspotr Network Plot</h2><span id='topic+network_plot'></span>

<h3>Description</h3>

<p>Output simple network plot using
<a href="https://github.com/datastorm-open/visNetwork">visNetwork</a> connecting either
<code>funs</code> or <code>pkgs</code> to <code>relative_paths</code>/<code>absolute_paths</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>network_plot(df, to = .data$pkgs, show_each_use = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network_plot_+3A_df">df</code></td>
<td>
<p>Dataframe containing columns <code>relative_paths</code>, <code>absolute_paths</code> and either <code>funs</code>
or <code>pkgs</code>. Generally the output from running:
<code style="white-space: pre;">&#8288;github_spot_*() %&gt;% unnest_results()&#8288;</code></p>
</td></tr>
<tr><td><code id="network_plot_+3A_to">to</code></td>
<td>
<p><code>funs</code> or <code>pkgs</code></p>
</td></tr>
<tr><td><code id="network_plot_+3A_show_each_use">show_each_use</code></td>
<td>
<p>Binary, default is <code>FALSE</code>. If <code>TRUE</code> edge thickness
will be based on the number of times a package or function is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>visNetwork plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
library(funspotr)

gh_ex_pkgs &lt;- list_files_github_repo(
  repo = "brshallo/feat-eng-lags-presentation",
  branch = "main") %&gt;%
  spot_funs_files()

gh_ex_pkgs %&gt;%
  unnest_results() %&gt;%
  network_plot(to = pkgs)

</code></pre>

<hr>
<h2 id='spot_funs'>Spot Functions</h2><span id='topic+spot_funs'></span>

<h3>Description</h3>

<p>Given <code>file_path</code> extract all functions and their associated packages from
specified file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spot_funs(file_path, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spot_funs_+3A_file_path">file_path</code></td>
<td>
<p>character vector of path to file.</p>
</td></tr>
<tr><td><code id="spot_funs_+3A_...">...</code></td>
<td>
<p>This allows you to pass additional arguments through to
<code>spot_funs_custom()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>spot_funs()</code> uses <code>spot_funs_custom()</code> to run &ndash; it is a less verbose
version and does not require passing in the packages separately. See README
and <code>?spot_funs_custom</code> for details on how the function works and arguments
that can be passed through (via <code>...</code>).
</p>
<p>If code syntax is malformed and cannot be properly parsed, function will error.
</p>


<h3>Value</h3>

<p>Given default arguments and no missing packages, a dataframe with the
following columns is returned:
</p>
<p><code>funs</code>: specifying functions in file.
<code>pkgs</code>: the package a function came from. If <code>funs</code> is a custom function or
if it came from a package not installed on your machine, <code>pkgs</code> will return
&quot;(unknown)&quot;.
</p>
<p>Note that any unused loaded packages / <code>pkgs</code> are dropped from output.
Any functions without an available package are returned with the value
&quot;(unknown)&quot;.
</p>
<p>See README for further documentation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spot_funs_custom">spot_funs_custom()</a></code>, <code><a href="#topic+spot_funs_files">spot_funs_files()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(funspotr)

file_lines &lt;- "
library(dplyr)
require(tidyr)
library(madeUpPkg)

as_tibble(mpg) %&gt;%
  group_by(class) %&gt;%
  nest() %&gt;%
  mutate(stats = purrr::map(data,
                            ~lm(cty ~ hwy, data = .x)))

made_up_fun()
"

file_output &lt;- tempfile(fileext = ".R")
writeLines(file_lines, file_output)

spot_funs(file_output)
</code></pre>

<hr>
<h2 id='spot_funs_custom'>Spot Functions Custom</h2><span id='topic+spot_funs_custom'></span>

<h3>Description</h3>

<p>Engine that runs <code>spot_funs()</code>. <code>spot_funs_custom()</code> has options for changing
returned output and for producing print statements and errors. It also
requires you to provide a character vector for <code>pkgs</code> rather than identifying
these automatically via <code>spot_pkgs()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spot_funs_custom(
  pkgs,
  file_path,
  show_each_use = FALSE,
  keep_search_list = FALSE,
  copy_local = TRUE,
  print_pkgs_load_status = FALSE,
  error_if_missing_pkg = FALSE,
  keep_in_multiple_pkgs = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spot_funs_custom_+3A_pkgs">pkgs</code></td>
<td>
<p>Character vector of packages that are added to search space via
<code>require()</code> or <code>import::from()</code> so can be found by <code>utils::find()</code>.
Generally will be the returned value from <code>spot_pkgs(file_path, show_explicit_funs = TRUE)</code>.</p>
</td></tr>
<tr><td><code id="spot_funs_custom_+3A_file_path">file_path</code></td>
<td>
<p>character vector of path to file.</p>
</td></tr>
<tr><td><code id="spot_funs_custom_+3A_show_each_use">show_each_use</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. If changed to <code>TRUE</code> will
return individual rows for each time a function is used (rather than just
once for the entire file).</p>
</td></tr>
<tr><td><code id="spot_funs_custom_+3A_keep_search_list">keep_search_list</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. If changed to <code>TRUE</code>
will include entire search list for function. May be helpful for debugging
in cases where funspotr may not be doing a good job of recreating the
search list for identifying which packages function(s) came from. This will
print all packages in the search list for each function.</p>
</td></tr>
<tr><td><code id="spot_funs_custom_+3A_copy_local">copy_local</code></td>
<td>
<p>Logical, if changed to <code>FALSE</code> will not copy to a local
temporary folder prior to doing analysis. Many functions require file to
already be an .R file and for the file to exist locally. This should
generally not be set to <code>TRUE</code> unless these hold.</p>
</td></tr>
<tr><td><code id="spot_funs_custom_+3A_print_pkgs_load_status">print_pkgs_load_status</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. If set to <code>TRUE</code>
will print a named vector of logicals showing whether packages are on
machine along with any warning messages that come when running <code>require()</code>.
Will continue on to produce output of function.</p>
</td></tr>
<tr><td><code id="spot_funs_custom_+3A_error_if_missing_pkg">error_if_missing_pkg</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. If set to <code>TRUE</code> then
<code>print_pkgs_load_status = TRUE</code> automatically. If a package is not
installed on the machine then will print load status of individual pkgs and
result in an error.</p>
</td></tr>
<tr><td><code id="spot_funs_custom_+3A_keep_in_multiple_pkgs">keep_in_multiple_pkgs</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. If set to <code>TRUE</code>
will include in the outputted dataframe a column <code>in_multiple_pkgs</code>:
logical, whether a function exists in multiple packages loaded (i.e. on the
search space of <code>utils::find()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>spot_funs_custom()</code> is also what you should use in cases where you don't
trust <code>spot_pkgs()</code> to properly identify package dependencies from within the
same file and instead want to pass in your own character vector of packages.
</p>
<p>See README for a description of how the function works.
</p>
<p>If a package is not included in <code>pkgs</code>, any functions called that should come
from that package will be assigned a value of &quot;(unknown)&quot; in the <code>pkgs</code>
column of the returned output. You can also use the <code>print_pkgs_load_status</code>
and <code>error_if_missing_pkg</code> arguments to alter how output works in cases when
not all packages are on the machine.
</p>
<p>Explicit calls to unexported functions i.e. <code>pkg:::fun()</code> will have <code>pkgs = "(unknown)"</code> in the returned dataframe.
</p>


<h3>Value</h3>

<p>Given default arguments and no missing packages, a dataframe with the
following columns is returned:
</p>
<p><code>funs</code>: specifying functions in file.
<code>pkgs</code>: the package a function came from. If <code>funs</code> is a custom function or
if it came from a package not installed on your machine, <code>pkgs</code> will return
&quot;(unknown)&quot;.
</p>
<p>Note that any unused loaded packages / <code>pkgs</code> are dropped from output.
Any functions without an available package are returned with the value
&quot;(unknown)&quot;.
</p>
<p>See README for further documentation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spot_funs">spot_funs()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(funspotr)

file_lines &lt;- "
library(dplyr)
require(tidyr)
library(madeUpPkg)

as_tibble(mpg) %&gt;%
  group_by(class) %&gt;%
  nest() %&gt;%
  mutate(stats = purrr::map(data,
                            ~lm(cty ~ hwy, data = .x)))

made_up_fun()
"

file_output &lt;- tempfile(fileext = ".R")
writeLines(file_lines, file_output)

pkgs &lt;- spot_pkgs(file_output)

spot_funs_custom(pkgs, file_output)

# If you'd rather it error when a pkg doesn't exist e.g. for {madeUpPkg}
# set`error_if_missing_pkg = TRUE`
</code></pre>

<hr>
<h2 id='spot_funs_files'>Spot Packages or Functions in dataframe of Paths</h2><span id='topic+spot_funs_files'></span><span id='topic+spot_pkgs_files'></span>

<h3>Description</h3>

<p><code>spot_pkgs_files()</code> : Spot all packages that show-up in R or Rmarkdown or
quarto documents in a dataframe of filepaths.
</p>
<p><code>spot_funs_files()</code> : Spot all functions and their corresponding packages
that show-up in R or Rmarkdown or quarto documents in a dataframe of
filepaths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spot_funs_files(df, ..., .progress = TRUE)

spot_pkgs_files(df, ..., .progress = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spot_funs_files_+3A_df">df</code></td>
<td>
<p>Dataframe containing a column of <code>absolute_paths</code>.</p>
</td></tr>
<tr><td><code id="spot_funs_files_+3A_...">...</code></td>
<td>
<p>Arguments passed onto <code style="white-space: pre;">&#8288;spot_{pkgs|funs}()&#8288;</code>.</p>
</td></tr>
<tr><td><code id="spot_funs_files_+3A_.progress">.progress</code></td>
<td>
<p>Whether to show a progress bar. Use <code>TRUE</code> to a turn on
a basic progress bar, use a string to give it a name, or see
<a href="purrr.html#topic+progress_bars">progress_bars</a> for more details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code>purrr::safely()</code> wrapper for mapping <code>spot_pkgs()</code> or <code>spot_funs()</code> across
multiple filepaths. I.e. even if some files fail to parse the function will
continue on.
</p>
<p>Default settings are meant for files where package libraries are referenced
<em>within</em> the files themselves. See README for more details.
</p>


<h3>Value</h3>

<p>Dataframe with <code>relative_paths</code> and <code>absolute_paths</code> of file paths
along with a list-column <code>spotted</code> containing <code>purrr::safely()</code> named list
of &quot;result&quot; and &quot;error&quot; for each file parsed. Use <code>unnest_results()</code> to
unnest only the &quot;result&quot; values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spot_pkgs">spot_pkgs()</a></code>, <code><a href="#topic+spot_funs">spot_funs()</a></code>, <code><a href="#topic+unnest_results">unnest_results()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(funspotr)
library(dplyr)

list_files_github_repo("brshallo/feat-eng-lags-presentation", branch = "main") %&gt;%
  spot_funs_files()

</code></pre>

<hr>
<h2 id='spot_pkgs'>Spot Packages</h2><span id='topic+spot_pkgs'></span>

<h3>Description</h3>

<p>Extract all <code>pkg</code> called in either <code>library(pkg)</code>, <code>require(pkg)</code>
<code>requireNamespace("pkg")</code> or <code>pkg::fun()</code>. Will not identify packages loaded
in other ways not typically done in interactive R scripts (e.g. relying on a
DESCRIPTION file for a pkg or something like <code>source("lib-calls.R")</code>).
Inspiration: <a href="https://github.com/rstudio/blogdown/issues/647">blogdown#647</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spot_pkgs(
  file_path,
  show_explicit_funs = FALSE,
  copy_local = TRUE,
  as_yaml_tags = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spot_pkgs_+3A_file_path">file_path</code></td>
<td>
<p>String of path to file of interest.</p>
</td></tr>
<tr><td><code id="spot_pkgs_+3A_show_explicit_funs">show_explicit_funs</code></td>
<td>
<p>In cases where a function is called explicitly,
show both the package dependency and the function together. For example a
script containing <code>dplyr::select()</code> (as opposed to <code style="white-space: pre;">&#8288;library(dplyr); select()&#8288;</code>) would have <code>spot_pkgs(show_explicit_funs = TRUE)</code> return the
item as &quot;dplyr::select&quot; rather than just &quot;dplyr&quot;)</p>
</td></tr>
<tr><td><code id="spot_pkgs_+3A_copy_local">copy_local</code></td>
<td>
<p>Logical, default is <code>TRUE</code>. If changed to <code>FALSE</code> will not
copy to a local temporary folder prior to doing analysis. Many processes
require file to already be a .R file and for the file to exist locally,
hence this should usually be set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="spot_pkgs_+3A_as_yaml_tags">as_yaml_tags</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. If set to <code>TRUE</code> flattens
and puts into a format convenient for pasting in &quot;tags&quot; section of YAML
header of  a Rmd document for a blogdown post.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In cases where <code>show_explicit_funs = TRUE</code> and there are explicit calls in
the package, &quot;pkg:fun&quot; is returned instead.
</p>
<p>Packages are extracted solely based on text &ndash; not whether the
package actually exists or not. Hence even packages that you do not have
installed on your machine but show-up in the script will be returned in the
character vector.
</p>


<h3>Value</h3>

<p>Character vector of all packages loaded in file.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spot_pkgs_used">spot_pkgs_used()</a></code>, <code><a href="#topic+spot_pkgs_from_description">spot_pkgs_from_description()</a></code>,
<code><a href="#topic+spot_pkgs_files">spot_pkgs_files()</a></code>, <code>renv::dependencies()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(funspotr)

file_lines &lt;- "
library(dplyr)
require(tidyr)
library(madeUpPkg)

as_tibble(mpg) %&gt;%
  group_by(class) %&gt;%
  nest() %&gt;%
  mutate(stats = purrr::map(data,
                            ~lm(cty ~ hwy, data = .x)))

made_up_fun()
"

file_output &lt;- tempfile(fileext = ".R")
writeLines(file_lines, file_output)

spot_pkgs(file_output)

# To view `purrr::map` as an explicit call
spot_pkgs(file_output, show_explicit_funs = TRUE)

# To output for blogdown post YAML header tags
cat(spot_pkgs(file_output, as_yaml_tags = TRUE))
</code></pre>

<hr>
<h2 id='spot_pkgs_from_description'>Spot package dependencies from DESCRIPTION file</h2><span id='topic+spot_pkgs_from_description'></span>

<h3>Description</h3>

<p>Given explicit path to DESCRIPTION file return package dependencies therein.
Inspiration: <a href="https://stackoverflow.com/a/30225680/9059865">blogdown#647</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spot_pkgs_from_description(DESCRIPTION_path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spot_pkgs_from_description_+3A_description_path">DESCRIPTION_path</code></td>
<td>
<p>Path to DESCRIPTION file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector of packages.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>funspotr::spot_pkgs_from_description(
  "https://raw.githubusercontent.com/brshallo/animatrixr/master/DESCRIPTION"
)
</code></pre>

<hr>
<h2 id='spot_pkgs_used'>Spot Packages Used</h2><span id='topic+spot_pkgs_used'></span>

<h3>Description</h3>

<p>Primarily used for cases where you load metapackages like <code>tidyverse</code> or
<code>tidymodels</code> but only want to return those packages that have functions from
the package that are actually called. E.g. say you have a
<code>library(tidyverse)</code> call but only end-up using functions that are in <code>dplyr</code>
&ndash; in that case <code>spot_pkgs()</code> would return <code>"tidyverse"</code> whereas
<code>spot_pkgs_used()</code> would return <code>"dplyr"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spot_pkgs_used(file_path, as_yaml_tags = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spot_pkgs_used_+3A_file_path">file_path</code></td>
<td>
<p>String of path to file of interest.</p>
</td></tr>
<tr><td><code id="spot_pkgs_used_+3A_as_yaml_tags">as_yaml_tags</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. If set to <code>TRUE</code> flattens
and puts into a format convenient for pasting in &quot;tags&quot; section of a
blogdown post Rmd document.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Also does not return uninstalled packages or those loaded when R starts up.
</p>
<p>Is essentially just calling <code>spot_funs() |&gt; with(unique(pkgs))</code> in the
background. Does not have as many options as <code>spot_pkgs()</code> though.
</p>


<h3>Value</h3>

<p>Character vector of all packages with functions used in the file.
</p>

<hr>
<h2 id='spot_tags'>Spot Tags</h2><span id='topic+spot_tags'></span>

<h3>Description</h3>

<p>Put quoted inline R function in your blogdown or quarto post's YAML header to
have the packages be the packages used in your post (wrapper around
<code>funspotr::spot_pkgs()</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spot_tags(
  file_path = knitr::current_input(),
  used = FALSE,
  drop_knitr = FALSE,
  yaml_bullet = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spot_tags_+3A_file_path">file_path</code></td>
<td>
<p>Default is the file being knitted but can change to some
other file (e.g. in cases where the code for the post may reside in a
different file).</p>
</td></tr>
<tr><td><code id="spot_tags_+3A_used">used</code></td>
<td>
<p>Default is <code>FALSE</code>. If <code>TRUE</code> will pass to <code>show_pkgs_used()</code>
rather than <code>show_pkgs()</code>. (Mainly useful for showing actual packages used
rather than meta-packages being called like <code>tidyverse</code> or <code>tidymodels</code>.
Also uses a more strict parsing method.</p>
</td></tr>
<tr><td><code id="spot_tags_+3A_drop_knitr">drop_knitr</code></td>
<td>
<p>Many blogdown posts have <code>knitr::opts_chunk$set()</code> in them
and you may not want this tag showing-up. Default is to keep this, but set
to <code>FALSE</code> to drop &quot;knitr&quot; from being tagged.</p>
</td></tr>
<tr><td><code id="spot_tags_+3A_yaml_bullet">yaml_bullet</code></td>
<td>
<p>Default is <code>NULL</code> meaning that <code>file_path</code> is read-in and
correct format is guessed based on &quot;spot_tags&quot; appearance with either a
hyphen or bracket (corresponding with bulleted or array format in the YAML
header).
</p>
<p>If it's first occurrence happens on a line that contains a bracket
the value becomes <code>FALSE</code> else it becomes <code>TRUE</code>. If set to <code>NULL</code> and
&quot;spot_tags&quot; is not detected at all in <code>file_path</code> it will default to
<code>FALSE</code>. <code>yaml_bullet</code> can also be specified directly with either <code>TRUE</code> or
<code>FALSE</code>. <code>TRUE</code> entails that <code>spot_tags()</code> is set in a YAML bullet, <code>FALSE</code>
indicates the user is inputting it in an array (see examples below).
</p>
<p>See examples for how to hard-code.</p>
</td></tr>
<tr><td><code id="spot_tags_+3A_...">...</code></td>
<td>
<p>Any additional arguments to pass to <code style="white-space: pre;">&#8288;spot_pkgs*()&#8288;</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<div class="sourceCode"><pre>tags:
  - "`r funspotr::spot_tags()`"
</pre></div>
<p>OR
</p>
<div class="sourceCode"><pre>tags: ["`r funspotr::spot_tags()`"]
</pre></div>
<p>OR
</p>
<div class="sourceCode"><pre>categories: ["`r funspotr::spot_tags()`"]
</pre></div>
<p>Thanks Yihui for the suggestions and for getting this working
<a href="https://github.com/rstudio/blogdown/issues/647">blogdown#647</a>, <a href="https://github.com/rstudio/blogdown/issues/693">blogdown#693</a>.)
</p>


<h3>Value</h3>

<p>Character vector in a format meant to be read while evaluating the
YAML header when rendering.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spot_pkgs">spot_pkgs()</a></code>, <code><a href="#topic+spot_pkgs_used">spot_pkgs_used()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# To review input interactively from within rstudio you might also try:
## Not run: 
funspotr::spot_tags(rstudioapi::getSourceEditorContext()$path)

## End(Not run)
</code></pre>

<hr>
<h2 id='str_detect_r_docs'>String Detect R or Rmarkdown or Quarto File endings</h2><span id='topic+str_detect_r_docs'></span>

<h3>Description</h3>

<p>Wrapper on <code>stringr::str_detect()</code> to return <code>TRUE</code> for only R and Rmarkdown
or Quarto files, else <code>FALSE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_detect_r_docs(
  contents,
  pattern = stringr::regex("(r|rmd|rmarkdown|qmd)$", ignore_case = TRUE),
  rmv_index = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_detect_r_docs_+3A_contents">contents</code></td>
<td>
<p>Character vector of file path.</p>
</td></tr>
<tr><td><code id="str_detect_r_docs_+3A_pattern">pattern</code></td>
<td>
<p>Regex pattern to identify file types.</p>
</td></tr>
<tr><td><code id="str_detect_r_docs_+3A_rmv_index">rmv_index</code></td>
<td>
<p>Logical, default to <code>TRUE</code>, most repos containing blogdown
sites will have an index.R file at the root. Change to <code>FALSE</code> if you don't
want this file removed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>files &lt;- c("file1.R", "file2.Rmd", "file3.Rmarkdown", "file4.Rproj", "file5.qmd")
funspotr::str_detect_r_docs(files)
</code></pre>

<hr>
<h2 id='unnest_results'>Unnest Results</h2><span id='topic+unnest_results'></span>

<h3>Description</h3>

<p>Run after running <code style="white-space: pre;">&#8288;list_files_*() |&gt; spot_{funs|pkgs}_files()&#8288;</code> to unnest the
<code>spotted</code> list-column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unnest_results(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unnest_results_+3A_df">df</code></td>
<td>
<p>Dataframe outputted by <code style="white-space: pre;">&#8288;spot_{funs|pkgs}_files()&#8288;</code> that contains a
<code>spotted</code> list-column.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An unnested dataframe with what was in <code>spotted</code> moved to the front.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spot_funs_files">spot_funs_files()</a></code>, <code><a href="#topic+spot_pkgs_files">spot_pkgs_files()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(funspotr)
library(dplyr)

list_files_github_repo("brshallo/feat-eng-lags-presentation", branch = "main") %&gt;%
  spot_funs_files() %&gt;%
  unnest_results()

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
