<!DOCTYPE html><html><head><title>Help for package mgcViz</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mgcViz}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ALE'><p>Generic function for Accumulated Local Effect (ALE)</p></a></li>
<li><a href='#ALE.gam'><p>Create Accumulated Local Effects (ALE) for GAMs</p></a></li>
<li><a href='#bamV'><p>Fit a GAM model and get a gamViz object</p></a></li>
<li><a href='#check.gamViz'><p>Some diagnostics for a fitted gam model</p></a></li>
<li><a href='#check0D'><p>Checking GAM simulated residuals or responses</p></a></li>
<li><a href='#check1D'><p>Checking GAM residuals or responses along one covariate</p></a></li>
<li><a href='#check2D'><p>Checking GAM residuals along two covariates</p></a></li>
<li><a href='#fix.family.cdf'><p>Getting the CDF of a gam family</p></a></li>
<li><a href='#gamm4V'><p>Fit a GAMM or GAMM4 model and get a gamViz object</p></a></li>
<li><a href='#getGam'><p>Convert gamViz object to gamObject</p></a></li>
<li><a href='#getViz'><p>Converting gam objects to gamViz objects</p></a></li>
<li><a href='#gridPrint'><p>Plotting plotSmooth objects on a grid</p></a></li>
<li><a href='#l_bound'><p>Add boundaries to smooth effect plot</p></a></li>
<li><a href='#l_ciBar'><p>Adding confidence intervals to barplots</p></a></li>
<li><a href='#l_ciLine'><p>Adding confidence intervals to effect plot</p></a></li>
<li><a href='#l_ciPoly'><p>Adding confidence band to effect plots</p></a></li>
<li><a href='#l_clusterLine'><p>Cluster and plot smooth effects</p></a></li>
<li><a href='#l_coordContour'><p>Adding coordinate lines</p></a></li>
<li><a href='#l_dens1D'><p>Adding density estimate to a plot</p></a></li>
<li><a href='#l_dens2D'><p>Adding density estimate heatmap</p></a></li>
<li><a href='#l_densCheck'><p>Checking residuals conditional density</p></a></li>
<li><a href='#l_fitBar'><p>Adding barplot to effect plots</p></a></li>
<li><a href='#l_fitContour'><p>Adding fitted effect contour lines</p></a></li>
<li><a href='#l_fitDens'><p>Adding density strip of fitted effect</p></a></li>
<li><a href='#l_fitLine'><p>Add fitted smooth effect curve</p></a></li>
<li><a href='#l_fitPoints'><p>Adding points representing the fitted effect</p></a></li>
<li><a href='#l_fitRaster'><p>Adding raster representing the fitted effect</p></a></li>
<li><a href='#l_glyphs2D'><p>Adding glyphs to 2D plots</p></a></li>
<li><a href='#l_gridCheck1D'><p>Binning and checking GAM residuals</p></a></li>
<li><a href='#l_gridCheck2D'><p>Binning and checking GAM residuals</p></a></li>
<li><a href='#l_gridQCheck1D'><p>Checking sign of residuals along one covariate</p></a></li>
<li><a href='#l_gridQCheck2D'><p>Binning and checking QGAM residuals</p></a></li>
<li><a href='#l_hist'><p>Adding histogram to a plot</p></a></li>
<li><a href='#l_points'><p>Add points to plot</p></a></li>
<li><a href='#l_poly'><p>Add polygons to effect plots</p></a></li>
<li><a href='#l_pvContour'><p>Adding contour of p-values</p></a></li>
<li><a href='#l_pvRaster'><p>Adding raster or heat-map of p-values</p></a></li>
<li><a href='#l_rug'><p>Adding rug to margins of a plot</p></a></li>
<li><a href='#l_simLine'><p>Add simulated smooth effect curves</p></a></li>
<li><a href='#l_vline'><p>Adding vertical line to a plot</p></a></li>
<li><a href='#listLayers'><p>Lists available layers for plotSmooth objects</p></a></li>
<li><a href='#mqgamV'><p>Fit multiple QGAM models and get a mgamViz object</p></a></li>
<li><a href='#plot.ALE1D'><p>Plot 1D Accumulated Local Effects (ALE)</p></a></li>
<li><a href='#plot.fs.interaction.1D'><p>Plotting one dimensional smooth factor interactions</p></a></li>
<li><a href='#plot.gamViz'><p>Basic GAM plotting</p></a></li>
<li><a href='#plot.mgamViz'><p>Plotting multiple quantile GAMs</p></a></li>
<li><a href='#plot.mgcv.smooth.1D'><p>Plotting one dimensional smooth effects</p></a></li>
<li><a href='#plot.mgcv.smooth.2D'><p>Plotting two dimensional smooth effects</p></a></li>
<li><a href='#plot.mgcv.smooth.MD'><p>Plotting slice of higher-dimensional smooth effects</p></a></li>
<li><a href='#plot.mrf.smooth'><p>Plotting Markov random field smooths</p></a></li>
<li><a href='#plot.multi.ptermFactor'><p>Plotting factor or logical parametric effects</p></a></li>
<li><a href='#plot.multi.random.effect'><p>Plotting random effects</p></a></li>
<li><a href='#plot.ptermInteraction'><p>Plotting parametric interactions</p></a></li>
<li><a href='#plot.ptermMatrixNumeric'><p>Plotting numeric parametric effects</p></a></li>
<li><a href='#plot.sos.smooth'><p>Plotting smooths on the sphere</p></a></li>
<li><a href='#plotDiff'><p>Generic plotting of differences</p></a></li>
<li><a href='#plotDiff.mgcv.smooth.1D'><p>Plotting differences between two 1D smooth effects</p></a></li>
<li><a href='#plotDiff.mgcv.smooth.2D'><p>Plotting differences between two 2D smooth effects</p></a></li>
<li><a href='#plotDiff.sos.smooth'><p>Plotting differences between two smooths on the sphere</p></a></li>
<li><a href='#plotRGL'><p>Generic RGL plotting function</p></a></li>
<li><a href='#plotRGL.mgcv.smooth.2D'><p>Visualizing 2D smooth effects in 3D</p></a></li>
<li><a href='#plotRGL.mgcv.smooth.MD'><p>Visualizing a 2D slice of a smooth effects in 3D</p></a></li>
<li><a href='#plotSlice'><p>Plotting sequence of slices of 2D smooth effect</p></a></li>
<li><a href='#postSim'><p>Posterior simulation from a GAM object</p></a></li>
<li><a href='#print.checkGam'><p>Printing the output of check.gamViz</p></a></li>
<li><a href='#print.plotGam'><p>Printing the output of plot.gamViz</p></a></li>
<li><a href='#print.plotSmooth'><p>Printing plots of smooth effects</p></a></li>
<li><a href='#print.qqGam'><p>Printing the output of qq.gamViz</p></a></li>
<li><a href='#pterm'><p>Extracting parametric effects from a GAM model</p></a></li>
<li><a href='#qgamV'><p>Fit a QGAM model and get a gamViz object</p></a></li>
<li><a href='#qq'><p>Generic QQ plots</p></a></li>
<li><a href='#qq.gamViz'><p>QQ plots for gam model residuals</p></a></li>
<li><a href='#qqplots'><p>Quantile-Quantile Plots</p></a></li>
<li><a href='#residuals.gamViz'><p>Generalized Additive Model residuals</p></a></li>
<li><a href='#shine'><p>Generic shine function</p></a></li>
<li><a href='#shine.qqGam'><p>Shiny QQ-plots for GAMs</p></a></li>
<li><a href='#simulate.gam'><p>Simulating responses from a GAM object</p></a></li>
<li><a href='#sm'><p>Extracting a smooth effect from a GAM model</p></a></li>
<li><a href='#zoom'><p>Generic zooming function</p></a></li>
<li><a href='#zoom.qqGam'><p>Efficiently zooming on GAM QQ-plots</p></a></li>
<li><a href='#zto1'><p>Constructing a decreasing function from (0,1) to (0,1)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Visualisations for Generalized Additive Models</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-05</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.11</td>
</tr>
<tr>
<td>Description:</td>
<td>Extension of the 'mgcv' package, providing visual tools for Generalized Additive Models that exploit the additive structure of such models, scale to large data sets and can be used in conjunction with a wide range of response distributions. The focus is providing visual methods for better understanding the model output and for aiding model checking and development beyond simple exponential family regression. The graphical framework is based on the layering system provided by 'ggplot2'.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4), mgcv (&ge; 1.8-28), qgam (&ge; 1.2.3), ggplot2</td>
</tr>
<tr>
<td>Imports:</td>
<td>gamm4, matrixStats, viridis, GGally, KernSmooth, gridExtra,
plyr, shiny, miniUI</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rgl, knitr, rmarkdown, testthat, MASS, webshot2</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mfasiolo/mgcViz">https://github.com/mfasiolo/mgcViz</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mfasiolo/mgcViz/issues">https://github.com/mfasiolo/mgcViz/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-06 09:59:43 UTC; mf15002</td>
</tr>
<tr>
<td>Author:</td>
<td>Matteo Fasiolo [aut, cre],
  Raphael Nedellec [aut],
  Yannig Goude [ctb],
  Christian Capezza [ctb],
  Simon N. Wood [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matteo Fasiolo &lt;matteo.fasiolo@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-06 10:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ALE'>Generic function for Accumulated Local Effect (ALE)</h2><span id='topic+ALE'></span>

<h3>Description</h3>

<p>Generic function for producing ALE effects, to be plottied using the <code>plot</code> generic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ALE(o, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ALE_+3A_o">o</code></td>
<td>
<p>the model we want to use to produce the ALE effect.</p>
</td></tr>
<tr><td><code id="ALE_+3A_...">...</code></td>
<td>
<p>arguments to be passed to methods.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Apley, D.W., and Zhu, J, 2016. Visualizing the effects of predictor variables in black
box supervised learning models. arXiv preprint arXiv:1612.08468.
</p>


<h3>See Also</h3>

<p>ALE.gam
</p>

<hr>
<h2 id='ALE.gam'>Create Accumulated Local Effects (ALE) for GAMs</h2><span id='topic+ALE.gam'></span>

<h3>Description</h3>

<p>Create Accumulated Local Effects (ALE) for GAMs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gam'
ALE(
  o,
  x,
  newdata = NULL,
  type = "link",
  nbin = 40,
  bins = NULL,
  oind = 1,
  center = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ALE.gam_+3A_o">o</code></td>
<td>
<p>a fitted GAM model.</p>
</td></tr>
<tr><td><code id="ALE.gam_+3A_x">x</code></td>
<td>
<p>the name of the variable along which we want to produce the ALE effect.</p>
</td></tr>
<tr><td><code id="ALE.gam_+3A_newdata">newdata</code></td>
<td>
<p>optional argument indicating the data to be used to produce the ALE effect.
If <code>NULL</code> the data contained in <code>o</code> will be used.</p>
</td></tr>
<tr><td><code id="ALE.gam_+3A_type">type</code></td>
<td>
<p>if set to &quot;link&quot; (the default option) the model output will be the linear predictor, if
set to &quot;response&quot; the model output is on the scale of the response.</p>
</td></tr>
<tr><td><code id="ALE.gam_+3A_nbin">nbin</code></td>
<td>
<p>number of intervals into which the predictor range is divided
when calculating the ALE effects. Ignored for factor predictors of if the <code>bins</code> argument is provided.</p>
</td></tr>
<tr><td><code id="ALE.gam_+3A_bins">bins</code></td>
<td>
<p>a grid defining the interval into which the predictor should be binned. Determined
automatically by default. Ignored for factor predictors.</p>
</td></tr>
<tr><td><code id="ALE.gam_+3A_oind">oind</code></td>
<td>
<p>relevant only when the model <code>o</code> has multiple linear predictors (e.g. for GAMLSS models
or for <code>multinom</code> regression). <code>oind</code> is the index of the output variable used for
the ALE effect (i.e., only <code>predict(o)[ , oind]</code>.</p>
</td></tr>
<tr><td><code id="ALE.gam_+3A_center">center</code></td>
<td>
<p>if set to 0 the ALE effect is not centered and the effect is equal to zero at the smallest
value on x-grid. If set to 1 (default) the effect is centered as done in Apley and Zhu, 2016.
That is, an estimate of the expected value of the uncentered effect is subtracted, so the effect is
centered similarly to smooth effects in GAMs. If set to 2, the expected value of the model output
at the smallest value on the x-grid is added to the uncentered effect.</p>
</td></tr>
<tr><td><code id="ALE.gam_+3A_...">...</code></td>
<td>
<p>extra arguments that will be passed to <code>predict</code> and <code>vcov</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>ALEXD</code>, where <code>X</code> is the number of dimensions, which can be plotted
using <code>plot.ALEXD</code> (only <code>X=1</code> is provided at the moment).
</p>


<h3>Author(s)</h3>

<p>Matteo Fasiolo and Christian Capezza, with some internal code having been adapted from the ALEPlot
package of Dan Apley.
</p>


<h3>References</h3>

<p>Apley, D.W., and Zhu, J, 2016. Visualizing the effects of predictor variables in black
box supervised learning models. arXiv preprint arXiv:1612.08468.
</p>


<h3>See Also</h3>

<p><a href="#topic+plot.ALE1D">plot.ALE1D</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example using Tweedie distribution
library(mgcViz)
set.seed(3)
n&lt;-400
## Simulate data...
dat &lt;- gamSim(1,n=n,dist="poisson",scale=.2)
dat$y &lt;- rTweedie(exp(dat$f),p=1.3,phi=.5) ## Tweedie response

## Fit a fixed p Tweedie, with wrong link ...
b &lt;- gam(list(y~s(x0)+s(x1)+s(x2)+s(x3),~1,~1), family=twlss(), data=dat)

plot(ALE(b, "x2", type = "response", oind = 1))

# With manually chosen bins
plot(ALE(b, "x2", type = "response", oind = 1, 
         bins = c(0.1, 0.25, 0.5, 0.6, 0.9, 0.95, 0.99, 1)))

</code></pre>

<hr>
<h2 id='bamV'>Fit a GAM model and get a gamViz object</h2><span id='topic+bamV'></span><span id='topic+gamV'></span>

<h3>Description</h3>

<p>These are wrapper that fits a GAM model using <a href="mgcv.html#topic+gam">mgcv::gam</a> or <a href="mgcv.html#topic+bam">mgcv::bam</a> and
converts it to a <code>gamViz</code> object using the <a href="#topic+getViz">getViz</a> function.
It is essentially a shortcut.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bamV(
  formula,
  family = gaussian(),
  data = list(),
  method = "fREML",
  aGam = list(),
  aViz = list()
)

gamV(
  formula,
  family = gaussian(),
  data = list(),
  method = "REML",
  aGam = list(),
  aViz = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bamV_+3A_formula">formula</code>, <code id="bamV_+3A_family">family</code>, <code id="bamV_+3A_data">data</code>, <code id="bamV_+3A_method">method</code></td>
<td>
<p>same arguments as in <a href="mgcv.html#topic+gam">mgcv::gam</a> or <a href="mgcv.html#topic+bam">mgcv::bam</a>.</p>
</td></tr>
<tr><td><code id="bamV_+3A_agam">aGam</code></td>
<td>
<p>list of further arguments to be passed to <a href="mgcv.html#topic+gam">mgcv::gam</a> or <a href="mgcv.html#topic+bam">mgcv::bam</a>.</p>
</td></tr>
<tr><td><code id="bamV_+3A_aviz">aViz</code></td>
<td>
<p>list of arguments to be passed to <a href="#topic+getViz">getViz</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;gamViz&quot; which can, for instance, be plotted using <a href="#topic+plot.gamViz">plot.gamViz</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##### gam example
# Simulate data
library(mgcViz)
set.seed(2) ## simulate some data...
dat &lt;- gamSim(1,n=1000,dist="normal",scale=2)

# Fit GAM and get gamViz object
b &lt;- gamV(y~s(x0)+s(x1, x2)+s(x3), data = dat, 
          aGam = list(scale = 2), aViz = list("nsim" = 20))

# This is equivalent to doing
# 1. Fit GAM
# b &lt;- gam(y~s(x0)+s(x1, x2)+s(x3), data=dat, method="REML", scale = 2)
# 2. Convert to gamViz object
# b &lt;- getViz(b, nsim = 20)

# Either way, we plot first and third effects by doing
print(plot(b, select = c(1, 3)), pages = 1)

##### bam example
# Simulate data
library(mgcViz)
set.seed(2) ## simulate some data...
dat &lt;- gamSim(1,n=2000,dist="normal",scale=2)

# Fit using bam() and get gamViz object
b &lt;- bamV(y~s(x0)+s(x1, x2)+s(x3), data = dat, 
          aGam = list(discrete = TRUE), aViz = list("nsim" = 0))
          
# Either way, we plot first and third effects by doing
print(plot(b, select = c(2)), pages = 1)
</code></pre>

<hr>
<h2 id='check.gamViz'>Some diagnostics for a fitted gam model</h2><span id='topic+check.gamViz'></span>

<h3>Description</h3>

<p>Takes a fitted GAM model and produces some diagnostic information about the fitting
procedure and results. The default is to produce 4 residual plots, some information about
the convergence of the smoothness selection optimization, and to run diagnostic tests of
whether the basis dimension choises are adequate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gamViz'
check(
  obj,
  type = c("auto", "deviance", "pearson", "response", "tunif", "tnormal"),
  k.sample = 5000,
  k.rep = 200,
  maxpo = 10000,
  a.qq = list(),
  a.hist = list(),
  a.respoi = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check.gamViz_+3A_obj">obj</code></td>
<td>
<p>an object of class <code>gamViz</code>, the output of a <code>getViz()</code> call.</p>
</td></tr>
<tr><td><code id="check.gamViz_+3A_type">type</code></td>
<td>
<p>type of residuals, see <a href="#topic+residuals.gamViz">residuals.gamViz</a>, used in all plots.</p>
</td></tr>
<tr><td><code id="check.gamViz_+3A_k.sample">k.sample</code></td>
<td>
<p>above this k testing uses a random sub-sample of data.</p>
</td></tr>
<tr><td><code id="check.gamViz_+3A_k.rep">k.rep</code></td>
<td>
<p>how many re-shuffles to do to get p-value for k testing.</p>
</td></tr>
<tr><td><code id="check.gamViz_+3A_maxpo">maxpo</code></td>
<td>
<p>maximum number of residuals points that will be plotted in the scatter-plots.
If number of datapoints &gt; <code>maxpo</code>, then a subsample of <code>maxpo</code> points will be plotted.</p>
</td></tr>
<tr><td><code id="check.gamViz_+3A_a.qq">a.qq</code></td>
<td>
<p>list of arguments to be passed to <code>qq.gamViz</code>. See <a href="#topic+qq.gamViz">qq.gamViz</a>.</p>
</td></tr>
<tr><td><code id="check.gamViz_+3A_a.hist">a.hist</code></td>
<td>
<p>list of arguments to be passed to <code>ggplot2::geom_histogram</code>.</p>
</td></tr>
<tr><td><code id="check.gamViz_+3A_a.respoi">a.respoi</code></td>
<td>
<p>list of arguments to be passed to <code>ggplot2::geom_point</code>.</p>
</td></tr>
<tr><td><code id="check.gamViz_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a essentially a re-write of <code>mgcv::gam.check</code> using <code>ggplot2</code>. See
<a href="mgcv.html#topic+gam.check">mgcv::gam.check</a> for details.
</p>


<h3>Value</h3>

<p>An object of class <code>checkGam</code>, which is simply a list of <code>ggplot</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mgcViz)
set.seed(0)
dat &lt;- gamSim(1, n = 200)
b &lt;- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = dat)
b &lt;- getViz(b)

# Checks using default options
check(b)

# Change some algorithmic and graphical parameters
check(b,
      a.qq = list(method = "tnorm", 
                  a.cipoly = list(fill = "light blue")), 
      a.respoi = list(size = 0.2), 
      a.hist = list(bins = 10))
</code></pre>

<hr>
<h2 id='check0D'>Checking GAM simulated residuals or responses</h2><span id='topic+check0D'></span>

<h3>Description</h3>

<p>This function extracts the residuals or responses of a fitted GAM model, then it compares
their distribution with that of model-based simulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check0D(
  o,
  type = "auto",
  maxpo = 10000,
  na.rm = TRUE,
  trans = NULL,
  useSim = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check0D_+3A_o">o</code></td>
<td>
<p>an object of class <code>gamViz</code>.</p>
</td></tr>
<tr><td><code id="check0D_+3A_type">type</code></td>
<td>
<p>the type of residuals to be used. See <a href="#topic+residuals.gamViz">residuals.gamViz</a>.
If <code>"type == y"</code> then the raw observations will be used.</p>
</td></tr>
<tr><td><code id="check0D_+3A_maxpo">maxpo</code></td>
<td>
<p>maximum number of residuals points that will be used by layers such as
<code>l_rug()</code>. If number of datapoints &gt; <code>maxpo</code>, then a subsample of <code>maxpo</code> points
will be taken.</p>
</td></tr>
<tr><td><code id="check0D_+3A_na.rm">na.rm</code></td>
<td>
<p>if <code>TRUE</code> missing cases in <code>x</code> or <code>y</code> will be dropped out.</p>
</td></tr>
<tr><td><code id="check0D_+3A_trans">trans</code></td>
<td>
<p>function used to transform the observed and simulated residuals or responses.
It must take a vector of as input, and it must either a vector of the same length or a scalar.</p>
</td></tr>
<tr><td><code id="check0D_+3A_usesim">useSim</code></td>
<td>
<p>if <code>FALSE</code> then the simulated responses contained in object <code>o</code> will not be used
by this function or by any of the layers that can be used with its output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>c("plotSmooth", "gg")</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The variance of the response distribution changes along x2 
library(mgcViz)
n  &lt;- 400
x1 &lt;- runif(n, -1, 1)
x2 &lt;- runif(n, -1, 1)
dat &lt;- data.frame("x1" = x1, "x2" = x2,
                  "y" = sin(3*x1) + 0.5 * x2^2 + pmax(x2, 0.2) * rnorm(n))

# Fit model with constant variance and perform posterior simulations (post = TRUE) 
# which take into account smoothing parameter uncertainty (unconditional = TRUE)
b &lt;- gamV(y ~ s(x1)+s(x2), data = dat, 
          aViz = list(nsim = 50, post = TRUE, unconditional = TRUE))

# Histogram of simulated vs observed residuals: the latter are fat tailed
check0D(b) + l_hist() + l_rug()

# Histogram of simulated 4th central moment (~ kurtosis) of simulated residuals.
# The vertical line is the 4th moment of the observed residuals
check0D(b, trans = function(.y) mean((.y - mean(.y))^4)) + l_dens1D() + l_vline() + l_rug()
# Residuals look very fat tails, but the real problem here is the heteroscedasticity 
# which can be diagnosted using check1D(b, "x2") + l_gridCheck1D(sd)
</code></pre>

<hr>
<h2 id='check1D'>Checking GAM residuals or responses along one covariate</h2><span id='topic+check1D'></span>

<h3>Description</h3>

<p>This function extracts the residuals of a fitted GAM model, and orders
them according to the value of a single covariate. Then several visual residuals diagnostics
can be plotted by adding layers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check1D(
  o,
  x,
  type = "auto",
  maxpo = 10000,
  na.rm = TRUE,
  trans = NULL,
  useSim = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check1D_+3A_o">o</code></td>
<td>
<p>an object of class <code>gamViz</code>.</p>
</td></tr>
<tr><td><code id="check1D_+3A_x">x</code></td>
<td>
<p>it can be either a) a single character, b) a numeric vector or c) a list of characters.
In case a) it should be the name of one of the variables in the dataframe used to fit <code>o</code>.
In case b) its length should be equal to the length of <code>o$y</code>.
In case c) it should be a list of names variables in the dataframe used to fit <code>o</code>.</p>
</td></tr>
<tr><td><code id="check1D_+3A_type">type</code></td>
<td>
<p>the type of residuals to be used. See <a href="#topic+residuals.gamViz">residuals.gamViz</a>.
If <code>"type == y"</code> then the raw observations will be used.</p>
</td></tr>
<tr><td><code id="check1D_+3A_maxpo">maxpo</code></td>
<td>
<p>maximum number of residuals points that will be used by layers such as
<code>l_rug()</code>. If number of datapoints &gt; <code>maxpo</code>,
then a subsample of <code>maxpo</code> points will be taken.</p>
</td></tr>
<tr><td><code id="check1D_+3A_na.rm">na.rm</code></td>
<td>
<p>if <code>TRUE</code> missing cases in <code>x</code> or <code>y</code> will be dropped out.</p>
</td></tr>
<tr><td><code id="check1D_+3A_trans">trans</code></td>
<td>
<p>function used to transform the observed and simulated residuals or responses. It must take a vector of
as input, and must return a vector of the same length.</p>
</td></tr>
<tr><td><code id="check1D_+3A_usesim">useSim</code></td>
<td>
<p>if <code>FALSE</code> then the simulated responses contained in object <code>o</code> will not be used
by this function or by any of the layers that can be used with its output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function will return an object of class <code>c("plotSmooth", "gg")</code>, unless argument <code>x</code> is a
list. In that case the function will return an object of class <code>c("plotGam", "gg")</code> containing
a checking plot for each variable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Example 1: diagnosing heteroscedasticity
library(mgcViz);
set.seed(4124)
n &lt;- 1e4
x &lt;- rnorm(n); y &lt;- rnorm(n);

# Residuals are heteroscedastic w.r.t. x
ob &lt;- (x)^2 + (y)^2 + (0.2*abs(x) + 1)  * rnorm(n)
b &lt;- bam(ob ~ s(x,k=30) + s(y, k=30), discrete = TRUE)
b &lt;- getViz(b)

# Look at residuals along "x"
ck &lt;- check1D(b, "x", type = "tnormal")

# Can't see that much
ck + l_dens(type = "cond", alpha = 0.8) + l_points() + l_rug(alpha = 0.2)

# Some evidence of heteroscedasticity
ck + l_densCheck()

# Compare observed residuals std dev with that of simulated data,
# heteroscedasticity is clearly visible
b &lt;- getViz(b, nsim = 50)
check1D(b, "x") + l_gridCheck1D(gridFun = sd, showReps = TRUE)

# This also works with factor or logical data
fac &lt;- sample(letters, n, replace = TRUE)
logi &lt;- sample(c(TRUE, FALSE), n, replace = TRUE)
b &lt;- bam(ob ~ s(x,k=30) + s(y, k=30) + fac + logi, discrete = TRUE)
b &lt;- getViz(b, nsim = 50)

# Look along "fac"
ck &lt;- check1D(b, "fac") 
ck + l_points() + l_rug() 
ck + l_gridCheck1D(gridFun = sd)

# Look along "logi"
ck &lt;- check1D(b, "logi") 
ck + l_points() + l_rug() 
ck + l_gridCheck1D(gridFun = sd)

</code></pre>

<hr>
<h2 id='check2D'>Checking GAM residuals along two covariates</h2><span id='topic+check2D'></span>

<h3>Description</h3>

<p>This function extracts the residuals of a fitted GAM model, and plots them
according to the values of two covariates. Then several visual residuals diagnostics
can be plotted by adding layers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check2D(
  o,
  x1,
  x2,
  type = "auto",
  maxpo = 10000,
  na.rm = TRUE,
  trans = NULL,
  useSim = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check2D_+3A_o">o</code></td>
<td>
<p>an object of class <code>gamViz</code>.</p>
</td></tr>
<tr><td><code id="check2D_+3A_x1">x1</code></td>
<td>
<p>it can be either a) a single character, b) a numeric vector or c) a list of characters.
In case a) it should be the name of one of the variables in the dataframe used to fit <code>o</code>.
In case b) its length should be equal to the length of <code>o$y</code>.
In case c) it should be a list of names of variables in the dataframe used to fit <code>o</code>.</p>
</td></tr>
<tr><td><code id="check2D_+3A_x2">x2</code></td>
<td>
<p>same as <code>x2</code>, but this will appear on the y-axis.</p>
</td></tr>
<tr><td><code id="check2D_+3A_type">type</code></td>
<td>
<p>the type of residuals to be used. See <a href="#topic+residuals.gamViz">residuals.gamViz</a>.
If <code>"type == y"</code> then the raw observations will be used.</p>
</td></tr>
<tr><td><code id="check2D_+3A_maxpo">maxpo</code></td>
<td>
<p>maximum number of residuals points that will be used by layers such as
<code>l_rug()</code>. If number of datapoints &gt; <code>maxpo</code>,
then a subsample of <code>maxpo</code> points will be taken.</p>
</td></tr>
<tr><td><code id="check2D_+3A_na.rm">na.rm</code></td>
<td>
<p>if <code>TRUE</code> missing cases in <code>x</code> or <code>y</code> will be dropped out</p>
</td></tr>
<tr><td><code id="check2D_+3A_trans">trans</code></td>
<td>
<p>function used to transform the observed and simulated residuals or responses. It must take a vector of
as input, and must return a vector of the same length.</p>
</td></tr>
<tr><td><code id="check2D_+3A_usesim">useSim</code></td>
<td>
<p>if <code>FALSE</code> then the simulated responses contained in object <code>o</code> will not be used
by this function or by any of the layers that can be used with its output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function will return an object of class <code>c("plotSmooth", "gg")</code>, unless arguments <code>x1</code> and/or
<code>x2</code> are lists. If they are lists of the same length, then the function will return an object of class
<code>c("plotGam", "gg")</code> containing a checking plot for each pair of variables. If <code>x1</code> is a list
and <code>x2</code> is not specified, the function will return an object of class <code>c("plotGam", "gg")</code> containing
a plot for each unique combination of the variables in <code>x1</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(mgcViz);
#### Example 1: Rosenbrock function
# Simulate data
n &lt;- 1e4
X &lt;- data.frame("x1"=rnorm(n, 0.5, 0.5), "x2"=rnorm(n, 1.5, 1))
X$y &lt;- (1-X$x1)^2 + 100*(X$x2 - X$x1^2)^2 + rnorm(n, 0, 2)
b &lt;- bam(y ~ te(x1, x2, k = 5), data = X, discrete = TRUE)
b &lt;- getViz(b, nsim = 50)

# Plot joint density of observed covariate x1 and x2
check2D(b, x1 = "x1", x2 = "x2") + l_rug() + l_dens(type="joint", alpha=0.6) + l_points()

# Look at how mean of residuals varies across x1 and x2
check2D(b, x1 = "x1", x2 = "x2") + l_gridCheck2D() + l_points()

# Can't see much in previous plot, let's zoom in central area, where most
# data is. Here we can clearly see that the mean model is mispecified
check2D(b, x1 = "x1", x2 = "x2") + l_gridCheck2D(bw = c(0.05, 0.1)) +
                                   xlim(-1, 1) + ylim(0, 3)
# Fit can be improved by increasing k in the bam() call

#### Example 2: checking along factor variables
# Simulate data where variance changes along factor variable "fac"
n &lt;- 1e4
X &lt;- data.frame("x1"=rnorm(n, 0.5, 0.5), "x2"=rnorm(n, 1.5, 1))
X$fac &lt;- as.factor( sample(letters, n, replace = TRUE) )
X$fac2 &lt;- as.factor( sample(c("F1", "F2", "F3", "F4", "F5"), n, replace = TRUE) )
X$y &lt;- (1-X$x1)^2 + 5*(X$x2 - X$x1^2)^2 + 0.1*as.numeric(X$fac) * rnorm(n, 0, 2)
b &lt;- bam(y ~ te(x1, x2, k = 5) + fac + fac2, data = X, discrete = TRUE)
b &lt;- getViz(b, nsim = 50)

# Check standard deviation of residuals along covariates "x1" and "fac"
a &lt;- check2D(b, x1 = "x2", x2 = "fac")
a + l_gridCheck2D(gridFun = sd) + l_rug() + l_points() 

# Points and rug are jittered by default, but we can over-ride this
a + l_rug(position = position_jitter(width = 0, height = 0)) + 
  l_points(position = position_jitter(width = 0, height = 0)) 

# Check standard deviation of residuals along the two factor variables
a &lt;- check2D(b, x1 = "fac", x2 = "fac2")
a + l_gridCheck2D(gridFun = sd, bw = c(1, 4)) + l_rug() + l_points() 

## End(Not run)

</code></pre>

<hr>
<h2 id='fix.family.cdf'>Getting the CDF of a gam family</h2><span id='topic+fix.family.cdf'></span>

<h3>Description</h3>

<p>Some methods implemented in <code>mgcViz</code> require the c.d.f. of the response distribution.
This function takes a family object as input and returns the same object, but with the cdf
function added to the <code>$cdf</code> slot. Mainly for internal use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fix.family.cdf(fam)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fix.family.cdf_+3A_fam">fam</code></td>
<td>
<p>an object of class <code>family</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='gamm4V'>Fit a GAMM or GAMM4 model and get a gamViz object</h2><span id='topic+gamm4V'></span><span id='topic+gammV'></span>

<h3>Description</h3>

<p>These are wrappers that fit GAM models using <a href="mgcv.html#topic+gamm">mgcv::gamm</a> or <a href="gamm4.html#topic+gamm4">gamm4::gamm4</a> and
convert them to a <code>gamViz</code> object using the <a href="#topic+getViz">getViz</a> function.
It is essentially a shortcut.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gamm4V(
  formula,
  random = NULL,
  family = gaussian(),
  data = list(),
  REML = TRUE,
  aGam = list(),
  aViz = list(),
  keepGAMObj = FALSE
)

gammV(
  formula,
  random = NULL,
  family = gaussian(),
  data = list(),
  method = "REML",
  aGam = list(),
  aViz = list(),
  keepGAMObj = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gamm4V_+3A_formula">formula</code>, <code id="gamm4V_+3A_random">random</code>, <code id="gamm4V_+3A_family">family</code>, <code id="gamm4V_+3A_data">data</code></td>
<td>
<p>same arguments as in <a href="mgcv.html#topic+gamm">mgcv::gamm</a> or <a href="gamm4.html#topic+gamm4">gamm4::gamm4</a>.</p>
</td></tr>
<tr><td><code id="gamm4V_+3A_reml">REML</code></td>
<td>
<p>same as in <a href="gamm4.html#topic+gamm4">gamm4::gamm4</a></p>
</td></tr>
<tr><td><code id="gamm4V_+3A_agam">aGam</code></td>
<td>
<p>list of further arguments to be passed to <a href="mgcv.html#topic+gamm">mgcv::gamm</a> or <a href="gamm4.html#topic+gamm4">gamm4::gamm4</a>.</p>
</td></tr>
<tr><td><code id="gamm4V_+3A_aviz">aViz</code></td>
<td>
<p>list of arguments to be passed to <a href="#topic+getViz">getViz</a>.</p>
</td></tr>
<tr><td><code id="gamm4V_+3A_keepgamobj">keepGAMObj</code></td>
<td>
<p>if <code>TRUE</code> a copy of the gamViz Object is kept under $gam to assure compatibility with <a href="mgcv.html#topic+gamm">mgcv::gamm</a> and <a href="gamm4.html#topic+gamm4">gamm4::gamm4</a>. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="gamm4V_+3A_method">method</code></td>
<td>
<p>same as in <a href="mgcv.html#topic+gamm">mgcv::gamm</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>WARNING: Model comparisons (e.g. with <code>anova</code>) should only be done using the mixed model part as described in <a href="gamm4.html#topic+gamm4">gamm4::gamm4</a>.
For <a href="mgcv.html#topic+gamm">mgcv::gamm</a> please refer to the original help file.
</p>


<h3>Value</h3>

<p>An object of class &quot;gamViz&quot; which can, for instance, be plotted using <a href="#topic+plot.gamViz">plot.gamViz</a>. Also the object has the following additional elements:
</p>

<ul>
<li> <p><code>lme</code> mixed model as in <a href="mgcv.html#topic+gamm">mgcv::gamm</a>
</p>
</li>
<li> <p><code>mer</code> mixed model as in <a href="gamm4.html#topic+gamm4">gamm4::gamm4</a>
</p>
</li>
<li> <p><code>gam</code> a copy of the gamViz Object if setting <code>keepGAMObj = TRUE</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>##### gam example
library(mgcViz)
# Simulate data
dat &lt;- gamSim(1,n=400,scale=2) ## simulate 4 term additive truth
## Now add 20 level random effect `fac'...
dat$fac &lt;- fac &lt;- as.factor(sample(1:20,400,replace=TRUE))
dat$y &lt;- dat$y + model.matrix(~fac-1) %*% rnorm(20) * 0.5

br &lt;- gammV(y~s(x0)+x1+s(x2), data=dat,random=list(fac=~1))
summary(br)
plot(br)

summary(br$lme)

## Not run: 
## gamm4::gamm4 example
br4 &lt;- gamm4V(y~s(x0)+x1+s(x2),data=dat,random=~(1|fac))
summary(br4)
plot(br4)

summary(br4$mer)

## End(Not run)

</code></pre>

<hr>
<h2 id='getGam'>Convert gamViz object to gamObject</h2><span id='topic+getGam'></span>

<h3>Description</h3>

<p>Function for converting a <code>gamViz</code> object to a <code>gamObject</code>.
It is essentially the inverse of the <a href="#topic+getViz">getViz</a> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getGam(o)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getGam_+3A_o">o</code></td>
<td>
<p>a <code>gamViz</code> object, the output of <a href="#topic+getViz">getViz</a>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(mgcViz)
set.seed(2) ## simulate some data...
dat &lt;- gamSim(1,n=1000,dist="normal",scale=2)
b &lt;- gam(y~s(x0)+s(x1, x2)+s(x3), data=dat, method="REML")
a &lt;- getViz(b)
identical(b, getGam(a)) # Must be TRUE
</code></pre>

<hr>
<h2 id='getViz'>Converting gam objects to gamViz objects</h2><span id='topic+getViz'></span>

<h3>Description</h3>

<p>This function converts <code>gam</code> objects into <code>gamViz</code> objects,
for which <code>mgcViz</code> provides several plotting methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getViz(o, nsim = 0, post = FALSE, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getViz_+3A_o">o</code></td>
<td>
<p>an object of class <code>gam</code>.</p>
</td></tr>
<tr><td><code id="getViz_+3A_nsim">nsim</code></td>
<td>
<p>the number of simulated vectors of responses. A positive integer.</p>
</td></tr>
<tr><td><code id="getViz_+3A_post">post</code></td>
<td>
<p>if <code>TRUE</code> then posterior simulation is performed. That is, we simulate <code>nsim</code> vectors
of regression coefficients from a Gaussian approximation to the posterior, and then we simulate
a vector of response using each parameter vector. If <code>FALSE</code>, then <code>nsim</code> vectors of
responses are simulated using parameters fixed at the posterior mode.</p>
</td></tr>
<tr><td><code id="getViz_+3A_newdata">newdata</code></td>
<td>
<p>Optional new data frame used to perform the simulations. To be passed to <a href="mgcv.html#topic+predict.gam">predict.gam</a> and,
if <code>post == TRUE</code>, to <code>postSim</code>.</p>
</td></tr>
<tr><td><code id="getViz_+3A_...">...</code></td>
<td>
<p>extra arguments to be passed to <a href="#topic+simulate.gam">simulate.gam</a> (if <code>post==FALSE</code>) or
<a href="#topic+postSim">postSim</a> (if <code>post==TRUE</code>). For instance, we could pass prior
weights <code>w</code> and <code>offset</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>gamViz</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mgcViz)
set.seed(2) ## simulate some data...
dat &lt;- gamSim(1,n=1000,dist="normal",scale=2)
b &lt;- gam(y~s(x0)+s(x1, x2)+s(x3), data=dat, method="REML")
b &lt;- getViz(b, nsim = 20)
str(b$store$sim) # Simulated responses now stored here

plot(sm(b,1)) + l_fitLine() + l_ciLine() + l_rug() + l_points()
plot(sm(b,2)) + l_rug() + l_fitRaster() + l_fitContour()
</code></pre>

<hr>
<h2 id='gridPrint'>Plotting plotSmooth objects on a grid</h2><span id='topic+gridPrint'></span>

<h3>Description</h3>

<p>This is a wrapper for <code>gridExtra::grid.arrange</code>, which allows to
plot several <code>plotSmooth</code> objects on a grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gridPrint(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gridPrint_+3A_...">...</code></td>
<td>
<p>arguments to be passed to <code>gridExtra::grid.arrange</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function simply extracts the <code>ggplot</code> objects contained in any
object of class <code>plotSmooth</code> and passes them to <code>gridExtra::grid.arrange</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mgcViz)
n  &lt;- 1e3
x1 &lt;- rnorm(n)
x2 &lt;- rnorm(n)
dat &lt;- data.frame("x1" = x1, "x2" = x2,
                  "y" = sin(x1) + 0.5 * x2^2 + pmax(x2, 0.2) * rnorm(n))
b &lt;- bam(y ~ s(x1)+s(x2), data = dat, method = "fREML", discrete = TRUE)
b &lt;- getViz(b)

o1 &lt;- plot( sm(b, 1) ) + l_fitLine() + l_ciLine() 
o2 &lt;- plot( sm(b, 2) ) + l_fitLine() + l_ciLine() 
qpl &lt;- qq(b)

# All on one page, method 1:
gridPrint(o1, o2, qpl, ncol = 2)

# All on one page, method 2:
gridPrint(grobs = list(o1, o2, qpl), ncol = 2)

# Works also when some ggplot objects are present
gridPrint(o1, o2, qpl, ggplot(), ncol = 2)

</code></pre>

<hr>
<h2 id='l_bound'>Add boundaries to smooth effect plot</h2><span id='topic+l_bound'></span>

<h3>Description</h3>

<p>This layer adds boundaries to a smooth effect plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>l_bound(n = 200, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="l_bound_+3A_n">n</code></td>
<td>
<p>number of discrete intervals along the boundary.</p>
</td></tr>
<tr><td><code id="l_bound_+3A_...">...</code></td>
<td>
<p>graphical arguments to be passed to <code>ggplot2::geom_path</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>gamLayer</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+plot.sos.smooth">plot.sos.smooth</a>
</p>

<hr>
<h2 id='l_ciBar'>Adding confidence intervals to barplots</h2><span id='topic+l_ciBar'></span>

<h3>Description</h3>

<p>This layer adds confidence intervals to barplots, such as those produced by factor effects GAM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>l_ciBar(level = 0.95, mul = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="l_ciBar_+3A_level">level</code></td>
<td>
<p>the level of the confidence intervals (e.g. 0.9 means 90% intervals).</p>
</td></tr>
<tr><td><code id="l_ciBar_+3A_mul">mul</code></td>
<td>
<p>number multiplied by the standard errors when calculating
standard error curves. By default <code>NULL</code>, if
set to a positive number it will over-ride <code>level</code>.</p>
</td></tr>
<tr><td><code id="l_ciBar_+3A_...">...</code></td>
<td>
<p>graphical arguments to be passed to <code>ggplot2::geom_errorbar</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>gamLayer</code>.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+plot.ptermFactor">plot.ptermFactor</a> for examples.
</p>

<hr>
<h2 id='l_ciLine'>Adding confidence intervals to effect plot</h2><span id='topic+l_ciLine'></span>

<h3>Description</h3>

<p>This layer adds confidence interval lines to smooth, random or parametric effect plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>l_ciLine(level = 0.95, mul = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="l_ciLine_+3A_level">level</code></td>
<td>
<p>coverage level (e.g. 0.9 means 90% intervals). Should be in (0, 1).</p>
</td></tr>
<tr><td><code id="l_ciLine_+3A_mul">mul</code></td>
<td>
<p>number multiplied by the standard errors when calculating
standard error curves. By default <code>NULL</code>, if
set to a positive number it will over-ride <code>level</code>.</p>
</td></tr>
<tr><td><code id="l_ciLine_+3A_...">...</code></td>
<td>
<p>graphical arguments to be passed to <code>ggplot2::geom_line</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>gamLayer</code>.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+plot.mgcv.smooth.1D">plot.mgcv.smooth.1D</a>, <a href="#topic+plot.ptermNumeric">plot.ptermNumeric</a> or <a href="#topic+plot.random.effect">plot.random.effect</a>  for examples.
</p>

<hr>
<h2 id='l_ciPoly'>Adding confidence band to effect plots</h2><span id='topic+l_ciPoly'></span>

<h3>Description</h3>

<p>This layer adds a polygon representing the confidence band of a
smooth, random or parametric effect plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>l_ciPoly(level = 0.95, mul = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="l_ciPoly_+3A_level">level</code></td>
<td>
<p>coverage level (e.g. 0.9 means 90% intervals). Should be in (0, 1).</p>
</td></tr>
<tr><td><code id="l_ciPoly_+3A_mul">mul</code></td>
<td>
<p>number multiplied by the standard errors when calculating
standard error curves. By default <code>NULL</code>, if
set to a positive number it will over-ride <code>level</code>.</p>
</td></tr>
<tr><td><code id="l_ciPoly_+3A_...">...</code></td>
<td>
<p>graphical arguments to be passed to <code>ggplot2::geom_polygon</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>gamLayer</code>
</p>


<h3>See Also</h3>

<p>See <a href="#topic+plot.mgcv.smooth.1D">plot.mgcv.smooth.1D</a>, <a href="#topic+plot.ptermNumeric">plot.ptermNumeric</a> or <a href="#topic+plot.random.effect">plot.random.effect</a> for examples.
</p>

<hr>
<h2 id='l_clusterLine'>Cluster and plot smooth effects</h2><span id='topic+l_clusterLine'></span>

<h3>Description</h3>

<p>This layers clusters several smooth effects and plots the cluster centers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>l_clusterLine(centers, cluFun = kmeans, a.clu = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="l_clusterLine_+3A_centers">centers</code></td>
<td>
<p>the number of clusters. This is the same a the <code>centers</code>
argument in <a href="stats.html#topic+kmeans">stats::kmeans</a>.</p>
</td></tr>
<tr><td><code id="l_clusterLine_+3A_clufun">cluFun</code></td>
<td>
<p>the function used for clustering. I must take (at least) arguments <code>x</code>,
<code>centers</code> and <code>data</code>, which have the same interpretation as in
<a href="stats.html#topic+kmeans">stats::kmeans</a> (which is the default).</p>
</td></tr>
<tr><td><code id="l_clusterLine_+3A_a.clu">a.clu</code></td>
<td>
<p>list of further argument to be passed to <code>cluFun</code>.</p>
</td></tr>
<tr><td><code id="l_clusterLine_+3A_...">...</code></td>
<td>
<p>graphical arguments to be passed to <code>ggplot2::geom_line</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>gamLayer</code>.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+plot.fs.interaction.1D">plot.fs.interaction.1D</a> for examples.
</p>

<hr>
<h2 id='l_coordContour'>Adding coordinate lines</h2><span id='topic+l_coordContour'></span>

<h3>Description</h3>

<p>This layers adds coordinate contours to smooth effect plots. It is mainly
useful for smooth-on-the-sphere plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>l_coordContour(brLO = c(-9:9 * 20), brLA = c(-8:8 * 10), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="l_coordContour_+3A_brlo">brLO</code></td>
<td>
<p>a vector of meridians to be plotted.</p>
</td></tr>
<tr><td><code id="l_coordContour_+3A_brla">brLA</code></td>
<td>
<p>a vector of parallels to be plotted.</p>
</td></tr>
<tr><td><code id="l_coordContour_+3A_...">...</code></td>
<td>
<p>graphical arguments to be passed to  <code>ggplot2::geom_contour</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>gamLayer</code>.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+plot.sos.smooth">plot.sos.smooth</a> for examples.
</p>

<hr>
<h2 id='l_dens1D'>Adding density estimate to a plot</h2><span id='topic+l_dens1D'></span>

<h3>Description</h3>

<p>This layer adds a density estimate to a plot. It is mainly a
wrapper around <a href="ggplot2.html#topic+geom_density">ggplot2::geom_density</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>l_dens1D(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="l_dens1D_+3A_...">...</code></td>
<td>
<p>graphical arguments to be passed to <code>ggplot2::geom_density</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>gamLayer</code>.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+check0D">check0D</a> for examples.
</p>

<hr>
<h2 id='l_dens2D'>Adding density estimate heatmap</h2><span id='topic+l_dens2D'></span><span id='topic+l_dens'></span>

<h3>Description</h3>

<p>This layer adds a 2D density estimate heat-map to a plot.
For 1D effect plots, it adds either the conditional density of the partial
residuals, <code>p(r|x)</code>, or the joint density <code>p(r, x)</code>. For 2D
effect plots it adds either <code>p(x1|x2)</code> or <code>p(x1, x2)</code>, where
<code>x1</code> and <code>x2</code> are the relevant covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>l_dens2D(type, n = c(50, 50), bw = NULL, tol = 1e-06, trans = sqrt, ...)

l_dens(type, n = c(50, 50), bw = NULL, tol = 1e-06, trans = sqrt, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="l_dens2D_+3A_type">type</code></td>
<td>
<p>for 1D effect plots, if set to &quot;cond&quot; then the conditional residual
density <code>p(r|x)</code> is plotted. If set to &quot;joint&quot; the
joint density of residuals, <code>p(r, x)</code>, is plotted.
The behaviour is similar for 2D effect plots, but <code>r</code> indicates
the second covariate, not the residuals.</p>
</td></tr>
<tr><td><code id="l_dens2D_+3A_n">n</code></td>
<td>
<p>vector of two positive integers, indicating the number of grid points
at which the density is evaluated on the x and y axes.</p>
</td></tr>
<tr><td><code id="l_dens2D_+3A_bw">bw</code></td>
<td>
<p>vector with two positive entries, indicating the bandwidth to be used
by the kernel density estimator of <code>p(x1, x2)</code> along x1 and x2.</p>
</td></tr>
<tr><td><code id="l_dens2D_+3A_tol">tol</code></td>
<td>
<p>small positive numerical tolerance. The estimated density at a certain
location is set to <code>NA</code> (hence it will appear white) when it falls
below <code>tol/sqrt(2*pi*sig)</code>, where <code>sig</code> is the standard
deviation of the residuals. Set <code>tol</code> to -1 plot the density on
the whole x-y plane, no matter how low it is.</p>
</td></tr>
<tr><td><code id="l_dens2D_+3A_trans">trans</code></td>
<td>
<p>the density on x-y is transformed using this function before being plotted.</p>
</td></tr>
<tr><td><code id="l_dens2D_+3A_...">...</code></td>
<td>
<p>graphical arguments to be passed to <code>ggplot2::geom_raster</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The density function is estimated using the fast binned kernel density estimation
methods provided by the <code>KernSmooth</code> package, hence this function should be
able to handle relatively large datasets (~ 10^6 observations).
</p>


<h3>Value</h3>

<p>An object of class <code>gamLayer</code>.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+plot.mgcv.smooth.1D">plot.mgcv.smooth.1D</a>, <a href="#topic+plot.mgcv.smooth.2D">plot.mgcv.smooth.2D</a> and <a href="#topic+check1D">check1D</a> for examples.
</p>

<hr>
<h2 id='l_densCheck'>Checking residuals conditional density</h2><span id='topic+l_densCheck'></span>

<h3>Description</h3>

<p>This layer calculates and plots how the empirical conditional density of
the residuals, r, differs from its theoretical or model-based counterpart,
along a covariate, x.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>l_densCheck(n = c(80, 80), bw = NULL, tol = 1e-06, dFun = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="l_densCheck_+3A_n">n</code></td>
<td>
<p>vector of two positive integers, indicating the number of grid points
at which the density is evaluated on the x and r axes.</p>
</td></tr>
<tr><td><code id="l_densCheck_+3A_bw">bw</code></td>
<td>
<p>vector with two positive entries, indicating the bandwidth to be used
by the kernel density estimator of <code>p(r|x)</code> along x and r.</p>
</td></tr>
<tr><td><code id="l_densCheck_+3A_tol">tol</code></td>
<td>
<p>small positive numerical tolerance. The estimated density at a certain
location is set to <code>NA</code> (hence it will appear white) when it falls
below <code>tol/sqrt(2*pi*sig)</code>, where <code>sig</code> is the standard
deviation of the residuals. Set <code>tol</code> to -1 plot the density on
the whole x-y plane, no matter how low it is.</p>
</td></tr>
<tr><td><code id="l_densCheck_+3A_dfun">dFun</code></td>
<td>
<p>function used to compute the difference between the empirical (em) and theoretical (th)
conditional density of the residuals. By default it is <code>(sqrt(em)-sqrt(th))^(1/3)</code>,
where <code>th</code> is computed using either a uniform or a normal density, depending on the
type of residuals used in the <a href="#topic+check1D">check1D</a> call. It should have as arguments three vectors: <code>.ed</code> (the empirical
conditional density), <code>.gr</code> (the points along the y-axis where the density is evaluated) and
<code>.y</code> (the residuals).</p>
</td></tr>
<tr><td><code id="l_densCheck_+3A_...">...</code></td>
<td>
<p>graphical arguments to be passed to <code>ggplot2::geom_raster</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This layer is mainly meant to work together with the <a href="#topic+check1D">check1D</a> function. If check1D() is called with
residual type == &quot;tunif&quot; or &quot;tnormal&quot;, then <code>l_densCheck</code> compares the conditional distribution
of the residuals with Unif(0, 1) or N(0, 1). By changing the distance function <code>dFun</code>
one could of course change both the distance metric and the reference distribution (see Examples below). <br /> <br />
WARNING: if check1D() is called with type != &quot;tunif&quot; or &quot;tnormal&quot;, then the default distance used by l_densCheck is <br />
<code>dFun &lt;- function(.ed, .gr, .y)</code> <code>{</code><br />
<code>d &lt;- dnorm(.gr, 0, sd=sd(.y)) # sd=sd(.y) !!!</code><br />
<code>d &lt;- sqrt(.ed)-sqrt(d) </code><br />
<code>return(sign(d)*abs(d)^(1/3))</code><br />
<code>}</code> <br />
so the residuals are standardized using their own std dev <code>sd(.y)</code>.
Hence <code>l_densCheck</code> might not detect that the mean estimated variance
under the fitted model is different from the residuals variance.
Hence it is safer to use residual types &quot;tunif&quot; or &quot;tnormal&quot;, or a
customized distance function dFun (see below for an example on how to do this).
</p>


<h3>Value</h3>

<p>An object of class <code>gamLayer</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mgcViz);
# Dataset where variance increases linearly with x2, for x2 &gt; 0.2
n &lt;- 1e3
x1 &lt;- rnorm(1e3)
x2 &lt;- rnorm(1e3)
dat &lt;- data.frame("x1"=x1, 
                  "x2"=x2, "y"=sin(x1) + 0.5*x2^2 + pmax(x2, 0.2)*rnorm(n))
b &lt;- gam(y ~ s(x1)+s(x2), data=dat)
b &lt;- getViz(b)

# (Red) Blue indicates area where the empirical density 
# of the residuals is (lower) higher than it should be under 
# the model (residuals should be N(0, sigma) here).
# Here there are clear signs of heteroscedasticity: 
# the conditional variance is is increasing for x2 &gt; 0.2. 
check1D(b, "x2", type = "tnormal") + l_densCheck() + l_rug()

# Suppose we want to compare the conditional density of the standardized residuals
# not with a Gaussian, but with a Student-t density with 3 degree of freedom.
# We could achieve this as follows:
myDistance &lt;- function(.ed, .gr, .y){
  d &lt;- dt(.gr / sd(.y), df = 3)
  d &lt;- abs( sqrt(.ed) - sqrt(d) ) # We are using absolute difference between sqrt-densities 
}

check1D(b, "x2", type = "response") + l_densCheck(dFun = myDistance) + l_rug()
# NB comparing with a Student density is not useful for this example, but it illustrates
# how both the distance function and the reference density can be customized.

</code></pre>

<hr>
<h2 id='l_fitBar'>Adding barplot to effect plots</h2><span id='topic+l_fitBar'></span>

<h3>Description</h3>

<p>This layer adds a barplot to an effect plots. Mainly useful for factor or
binary effect plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>l_fitBar(a.aes = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="l_fitBar_+3A_a.aes">a.aes</code></td>
<td>
<p>list of aesthetic mapping arguments that will be passed to
<code>ggplot2::geom_bar</code>. For instance we could set <code>a.aes=list("fill"="red")</code>
to change the colour of the barplot.</p>
</td></tr>
<tr><td><code id="l_fitBar_+3A_...">...</code></td>
<td>
<p>graphical arguments to be passed to <a href="ggplot2.html#topic+geom_bar">ggplot2::geom_bar</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>gamLayer</code>.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+plot.ptermFactor">plot.ptermFactor</a> for examples.
</p>

<hr>
<h2 id='l_fitContour'>Adding fitted effect contour lines</h2><span id='topic+l_fitContour'></span>

<h3>Description</h3>

<p>This layer adds the contour lines corresponding to a fitted multidimensional effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>l_fitContour(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="l_fitContour_+3A_...">...</code></td>
<td>
<p>graphical arguments to be passed to  <code>ggplot2::geom_contour</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>gamLayer</code>.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+plot.mgcv.smooth.2D">plot.mgcv.smooth.2D</a>, <a href="#topic+plot.mgcv.smooth.MD">plot.mgcv.smooth.MD</a>, <a href="#topic+plot.sos.smooth">plot.sos.smooth</a> and
<a href="#topic+plotSlice">plotSlice</a> for examples.
</p>

<hr>
<h2 id='l_fitDens'>Adding density strip of fitted effect</h2><span id='topic+l_fitDens'></span>

<h3>Description</h3>

<p>This layer adds a conditional posterior density strip to 1D smooth effects plots.
With the default colour scale, the opacity is proportional to the conditional density of the fitted
effects, under the usual Gaussian approximation the posterior.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>l_fitDens(n = 50, level = 0.95, trans = identity, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="l_fitDens_+3A_n">n</code></td>
<td>
<p>sqrt of the number of grid points used to compute the effect plot.</p>
</td></tr>
<tr><td><code id="l_fitDens_+3A_level">level</code></td>
<td>
<p>confidence level. By default the conditional density of the fit will be plotted
between the Gaussian quantiles 0.025 and 0.975, hence the <code>level</code> determines the
width of the y-axis.</p>
</td></tr>
<tr><td><code id="l_fitDens_+3A_trans">trans</code></td>
<td>
<p>monotonic function to be applied to the density of the fit, which determines colour of
the plot. Monotonicity is not checked.</p>
</td></tr>
<tr><td><code id="l_fitDens_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code>ggplot2::geom_raster</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Bowman (2018) for explanations about the advantages of density strips, relative
to plots including the mean fit + confidence intervals.
</p>


<h3>Value</h3>

<p>An object of class gamLayer.
</p>


<h3>References</h3>

<p>Bowman, D. W (2018). Graphics for uncertainty. Journal of the Royal Statistical Society: Series A.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mgcViz)
set.seed(44)
dat &lt;- gamSim(1,n=400,dist="normal",scale=2)
b &lt;- gamV(y~s(x0)+x1+s(x2)+s(x3),data=dat)

plot(sm(b, 1)) + l_fitDens() + l_fitLine()
plot(pterm(b, 1)) + l_fitDens(trans = function(x) x^0.25) + l_fitLine()
               
</code></pre>

<hr>
<h2 id='l_fitLine'>Add fitted smooth effect curve</h2><span id='topic+l_fitLine'></span>

<h3>Description</h3>

<p>This layer add lines representing a single or a group of
parametric or smooth 1D effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>l_fitLine(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="l_fitLine_+3A_...">...</code></td>
<td>
<p>graphical arguments to be passed to <code>ggplot2::geom_line</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When used in conjuction with <a href="#topic+plot.fs.interaction.1D">plot.fs.interaction.1D</a>, which plots smooth effects
of type <code>bs="fs"</code>, this function uses transparency to avoid over-plotting.
This can be avoided by setting <code>alpha = 1</code> in the call to <code>l_fitLine</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>gamLayer</code>.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+plot.mgcv.smooth.1D">plot.mgcv.smooth.1D</a>, <a href="#topic+plot.ptermNumeric">plot.ptermNumeric</a>, or
<a href="#topic+plot.fs.interaction.1D">plot.fs.interaction.1D</a> for examples.
</p>

<hr>
<h2 id='l_fitPoints'>Adding points representing the fitted effect</h2><span id='topic+l_fitPoints'></span>

<h3>Description</h3>

<p>This function adds points representing the fitted effect. Mainly
useful for plotting factor effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>l_fitPoints(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="l_fitPoints_+3A_...">...</code></td>
<td>
<p>graphical arguments to be passed to <code>ggplot2::geom_point</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>gamLayer</code>.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+plot.ptermFactor">plot.ptermFactor</a> for examples.
</p>

<hr>
<h2 id='l_fitRaster'>Adding raster representing the fitted effect</h2><span id='topic+l_fitRaster'></span>

<h3>Description</h3>

<p>This layer adds a raster or heat-map representing a fitted multidimensional effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>l_fitRaster(pTrans = function(.p) 1, noiseup = FALSE, mul = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="l_fitRaster_+3A_ptrans">pTrans</code></td>
<td>
<p>a function from (0, 1) to (0, 1) which takes as input a p-value and returns a value,
<code>alpha</code>, which will be passed on to <a href="ggplot2.html#topic+geom_tile">ggplot2::geom_raster</a>, and will determine
the opacity of the heat-map. The p-value quantifies the significance of the smooth
effect at each location (x1, x2). By default <code>pTrans</code> returns 1, but if we
set it to, say, <code>pTrans = function(.p) .p&lt;0.05</code> then the regions with p-values
higher than 0.05 will disappear. The <a href="#topic+zto1">zto1</a> function can be used to specify <code>pTrans</code>
in a flexible way.</p>
</td></tr>
<tr><td><code id="l_fitRaster_+3A_noiseup">noiseup</code></td>
<td>
<p>if <code>TRUE</code> the fitted effect, mu(x1, x2), will be perturbed with random
noise before being plotted. That is, at each location (x1, x2) a random
variable z(x1, x2) ~ N(0, mul * V(x1, x2)) will be added to mu(x1, x2). Here
V(x1, x2) is the estimated variance of mu(x1, x2) and <code>mul</code>
is a scalar multiplier (see next argument). This is useful for understanding in
which areas the smooth is more uncertain, as these areas will appear more noisy.</p>
</td></tr>
<tr><td><code id="l_fitRaster_+3A_mul">mul</code></td>
<td>
<p>positive multiplier that scales the variance of the fitted effect. See the <code>noiseup</code>
argument.</p>
</td></tr>
<tr><td><code id="l_fitRaster_+3A_...">...</code></td>
<td>
<p>graphical arguments to be passed to <code>ggplot2::geom_raster</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>gamLayer</code>.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+plot.mgcv.smooth.2D">plot.mgcv.smooth.2D</a>, <a href="#topic+plot.sos.smooth">plot.sos.smooth</a> or <a href="#topic+plotSlice">plotSlice</a> for examples.
</p>

<hr>
<h2 id='l_glyphs2D'>Adding glyphs to 2D plots</h2><span id='topic+l_glyphs2D'></span>

<h3>Description</h3>

<p>This layer adds glyphs or subplots to 2D plots. It is mainly meant to
be used with <a href="#topic+check2D">check2D</a> and to produce residuals checks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>l_glyphs2D(
  glyFun,
  ggLay = "geom_points",
  n = c(4, 4),
  mapping = NULL,
  data = NULL,
  polar = FALSE,
  height = ggplot2::rel(0.95),
  width = ggplot2::rel(0.95),
  y_scale = I,
  x_scale = I,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="l_glyphs2D_+3A_glyfun">glyFun</code></td>
<td>
<p>the function that produces the data needed to construct the glyphs.
It will take a single argument (<code>.d</code>), which is a <code>data.frame</code>
with columns <code>"x"</code>, <code>"y"</code> and <code>"z"</code>. When <code>l_glyphs2D</code>
is used with <code>check2D</code>, then <code>"x"</code> and <code>"y"</code> will be the
locations of the residual <code>"z"</code> in the relevant covariates.
<code>glyFun</code> needs to output a <code>data.frame</code> that will be passed to
the <code>ggLay</code> function, which does the plotting.</p>
</td></tr>
<tr><td><code id="l_glyphs2D_+3A_gglay">ggLay</code></td>
<td>
<p>the <code>ggplot2</code> layer function (such as <code>"geom_point"</code>) used to
plot the glyphs. Its mapping needs to take at least argument &quot;x&quot;, &quot;y&quot; and
&quot;group&quot;. See the <code>mapping</code> argument below.</p>
</td></tr>
<tr><td><code id="l_glyphs2D_+3A_n">n</code></td>
<td>
<p>vector of two positive integers, indicating the number of 2D grid cell
along x and y in which the data is divided.</p>
</td></tr>
<tr><td><code id="l_glyphs2D_+3A_mapping">mapping</code></td>
<td>
<p>list of aesthetic mappings to be used by <code>ggLay</code>. By default it is
<code>aes(x=gx, y=gy, group = gid)</code>. Here gx and gy specify the x-y
location of each data-point used to plot the glyphs, while gid specifies
to which glyph each data-point belongs (there are <code>n[1]*n[2]</code> glyphs).</p>
</td></tr>
<tr><td><code id="l_glyphs2D_+3A_data">data</code></td>
<td>
<p>an optional data.frame to be used for computing the glyphs.
It must have two variables called <code>x</code> and <code>y</code>. If left to <code>NULL</code> then
the glyphs will be computed using the data in the <code>plotSmooth</code> object
to which this layer is being added.</p>
</td></tr>
<tr><td><code id="l_glyphs2D_+3A_polar">polar</code>, <code id="l_glyphs2D_+3A_height">height</code>, <code id="l_glyphs2D_+3A_width">width</code>, <code id="l_glyphs2D_+3A_y_scale">y_scale</code>, <code id="l_glyphs2D_+3A_x_scale">x_scale</code></td>
<td>
<p>see <a href="GGally.html#topic+glyphs">GGally::glyphs</a>.</p>
</td></tr>
<tr><td><code id="l_glyphs2D_+3A_...">...</code></td>
<td>
<p>graphical arguments to be passed to <code>ggLay</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>gamLayer</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+check2D">check2D</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mgcViz);
set.seed(4124)
n &lt;- 1e4
dat &lt;- data.frame("x1" = rnorm(n), "x2" = rnorm(n))

# Residuals are heteroscedastic w.r.t. x1
dat$y &lt;- (dat$x1)^2 + (dat$x2)^2 + (1*abs(dat$x1) + 1)  * rnorm(n)
b &lt;- bam(y ~ s(x1,k=30) + s(x2, k=30), data = dat, discrete = TRUE)
b &lt;- getViz(b)

pl &lt;- check2D(b, x1 = "x1", x2 = "x2", type = "tnormal") + 
  l_points(colour = "blue", alpha = 0.5)

# Look at distributions of residuals across x1 and x2
# Approach 1: using binned kernel density estimate
# Colour indicates whether we have more that 50 obs in that bin
glyFun &lt;- function(.d){
  .r &lt;- .d$z
  .qq &lt;- as.data.frame( density(.r)[c("x", "y")], n = 100 )
  .qq$colour &lt;- rep(ifelse(length(.r)&gt;50, "black", "red"), nrow(.qq))
  return( .qq )
}

pl + l_glyphs2D(glyFun = glyFun, ggLay = "geom_path", n = c(8, 8),
                 mapping = aes(x=gx, y=gy, group = gid, colour = I(colour)), 
                 height=1.5, width = 1) 

# Approach 2: using binned worm-plots. These are simply rotated QQplots.
# An horizontal plot indicates well specified residual model. 
# Increasing (decreasing) worm indicates over (under) dispersion
glyFun &lt;- function(.d){
  n &lt;- nrow(.d)
  px &lt;- qnorm( (1:n - 0.5)/(n) )
  py &lt;- sort( .d$z )
  clr &lt;- if(n &gt; 50) { "black" } else { "red" }
  clr &lt;- rep(clr, n)
  return( data.frame("x" = px, "y" = py - px, "colour" = clr))
}

pl + l_glyphs2D(glyFun = glyFun, ggLay = "geom_point", n = c(10, 10),
                mapping = aes(x=gx, y=gy, group = gid, colour = I(colour)),
                height=2, width = 1, size = 0.2) 

</code></pre>

<hr>
<h2 id='l_gridCheck1D'>Binning and checking GAM residuals</h2><span id='topic+l_gridCheck1D'></span>

<h3>Description</h3>

<p>This layer bins the residuals, r, according to the value of the corresponding
covariate, x. Then the residuals in each bin are summarized using a
scalar-valued statistic. Confidence intervals for the statistic corresponding
to each bin can be obtained by simulating residuals from the fitted GAM
model, binning and summarizing them. Mainly useful in conjuction with <a href="#topic+check1D">check1D</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>l_gridCheck1D(
  gridFun = NULL,
  n = 20,
  level = 0.8,
  stand = "none",
  showReps = TRUE,
  showObs = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="l_gridCheck1D_+3A_gridfun">gridFun</code></td>
<td>
<p>scalar-valued function used to summarize the residuals in each bin.
It takes a vector as input. By default it is
<code>mean(r)*sqrt(length(r))</code>, where <code>r</code> is the vector of
residuals in that bin.</p>
</td></tr>
<tr><td><code id="l_gridCheck1D_+3A_n">n</code></td>
<td>
<p>number of grid intervals along the relevant covariate.</p>
</td></tr>
<tr><td><code id="l_gridCheck1D_+3A_level">level</code></td>
<td>
<p>the level of the confidence intervals (e.g. 0.9 means 90% intervals).</p>
</td></tr>
<tr><td><code id="l_gridCheck1D_+3A_stand">stand</code></td>
<td>
<p>if &quot;none&quot; the residuals in each bin are transformed by <code>gridFun</code> and
the result statistics are plotted directly. If &quot;sc&quot; the statistics
in each bin are scaled and centered using the mean and standard
deviation of the simulated stats in that bin.
If &quot;s&quot; we do only scaling, if &quot;c&quot; only centering.</p>
</td></tr>
<tr><td><code id="l_gridCheck1D_+3A_showreps">showReps</code></td>
<td>
<p>if <code>TRUE</code> the individuals simulated statistics are also plotted using small points.</p>
</td></tr>
<tr><td><code id="l_gridCheck1D_+3A_showobs">showObs</code></td>
<td>
<p>if <code>TRUE</code> the observed statistics are plotted using large points.</p>
</td></tr>
<tr><td><code id="l_gridCheck1D_+3A_...">...</code></td>
<td>
<p>graphical arguments to be passed to <code>ggplot2::geom_point</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>gamLayer</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mgcViz);
set.seed(4124)
n &lt;- 1e4
x &lt;- rnorm(n); y &lt;- rnorm(n);

# Residuals are heteroscedastic w.r.t. x
ob &lt;- (x)^2 + (y)^2 + (0.2*abs(x) + 1)  * rnorm(n)
b &lt;- bam(ob ~ s(x,k=30) + s(y, k=30), discrete = TRUE)
b &lt;- getViz(b, nsim = 50)

# Don't see much by looking at mean
check1D(b, "x") + l_gridCheck1D()

# Heteroscedasticity clearly visible here
check1D(b, "x") + l_gridCheck1D(gridFun = sd, stand = "sc") # &lt;- we are scaling and centering
# Last point on the right of the rug seems to indicate that a bin is missing.
# It is not an error, only on observation falls in that bin, hence the
# standard deviation is not defined there.

</code></pre>

<hr>
<h2 id='l_gridCheck2D'>Binning and checking GAM residuals</h2><span id='topic+l_gridCheck2D'></span>

<h3>Description</h3>

<p>This layer bins the residuals, r, according to the value of the corresponding
covariates, x1 and x2. Then the residuals in each bin are summarized using a
scalar-valued statistic. Confidence intervals for the statistic corresponding
to each bin can be obtained by simulating residuals from the fitted GAM
model, which are then binned and summarized. Mainly useful in conjuction with <a href="#topic+check2D">check2D</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>l_gridCheck2D(gridFun = mean, bw = c(NA, NA), stand = TRUE, binFun = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="l_gridCheck2D_+3A_gridfun">gridFun</code></td>
<td>
<p>scalar-valued function used to summarize the residuals in each bin.</p>
</td></tr>
<tr><td><code id="l_gridCheck2D_+3A_bw">bw</code></td>
<td>
<p>numeric vector giving bin width in the vertical and horizontal directions. See the <code>binwidth</code>
arguments in <code>?ggplot2::stat_summary_hex</code>. If left to <code>NA</code>, it will be set to 1/20
of the ranges of x1 and x2.</p>
</td></tr>
<tr><td><code id="l_gridCheck2D_+3A_stand">stand</code></td>
<td>
<p>if left to <code>TRUE</code> then the observed statistic in the i-th cell is normalized using
the simulated statistics in that same cell. That is, we will actually plot
<code>std_stat = (obs_stat-mean(sim_stat))/sd(sim_stat)</code>.</p>
</td></tr>
<tr><td><code id="l_gridCheck2D_+3A_binfun">binFun</code></td>
<td>
<p>the <code>ggplot2</code> function used to perform the binning. By default it
is either <a href="ggplot2.html#topic+stat_summary_2d">ggplot2::stat_summary_2d</a> or <a href="ggplot2.html#topic+stat_summary_2d">ggplot2::stat_summary_hex</a>, depending
on the class of the covariates x1 and x2.</p>
</td></tr>
<tr><td><code id="l_gridCheck2D_+3A_...">...</code></td>
<td>
<p>graphical arguments to be passed to <code>ggplot2::stat_summary_hex</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>gamLayer</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mgcViz);
set.seed(4124)
n &lt;- 1e4
x &lt;- rnorm(n); y &lt;- rnorm(n);

# Residuals are heteroscedastic w.r.t. x
ob &lt;- (x)^2 + (y)^2 + (1*abs(x) + 1)  * rnorm(n)
b &lt;- bam(ob ~ s(x,k=30) + s(y, k=30), discrete = TRUE)
b &lt;- getViz(b, nsim = 50)

# Don't see much by looking at mean
check2D(b, "x", "y") + l_gridCheck2D(gridFun = mean, bw = c(0.4, 0.4))

# Variance pattern along x-axis clearer now
check2D(b, "x", "y") + l_gridCheck2D(gridFun = sd, bw = c(0.4, 0.4))
 
</code></pre>

<hr>
<h2 id='l_gridQCheck1D'>Checking sign of residuals along one covariate</h2><span id='topic+l_gridQCheck1D'></span>

<h3>Description</h3>

<p>This layer is mainly useful when checking quantile GAMs fitted using the <code>qgam</code>
package. The residuals, r, are binned according to the corresponding value of a
covariate, x. Then the proportions of negative residuals within each bin are calculated, and
compared with the theoretical value, <code>qu</code>. Confidence intervals for the proportion
of negative residuals can be derived using binomial quantiles (under an independence
assumption). To be used in conjuction with <a href="#topic+check1D">check1D</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>l_gridQCheck1D(qu = NULL, n = 20, level = 0.8, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="l_gridQCheck1D_+3A_qu">qu</code></td>
<td>
<p>the quantile of interest. Should be in (0, 1).</p>
</td></tr>
<tr><td><code id="l_gridQCheck1D_+3A_n">n</code></td>
<td>
<p>number of grid intervals.</p>
</td></tr>
<tr><td><code id="l_gridQCheck1D_+3A_level">level</code></td>
<td>
<p>the level of the confidence intervals plotted.</p>
</td></tr>
<tr><td><code id="l_gridQCheck1D_+3A_...">...</code></td>
<td>
<p>graphical arguments to be passed to <code>ggplot2::geom_point</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>gamLayer</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate some data
library(mgcViz)
set.seed(3841)
dat &lt;- gamSim(1,n=400,dist="normal",scale=2)
dat$fac &lt;- as.factor( sample(letters[1:8], nrow(dat), replace = TRUE) ) 
fit &lt;- qgam(y~s(x1)+s(x2)+s(x3)+fac, data=dat, err = 0.05, qu = 0.4)
fit &lt;- getViz(fit)

# "x0" effect is missing, but should be there. l_gridQCheck1D shows
# that fraction of negative residuals is quite different from the theoretical 0.4
# in several places along "x0".
check1D(fit, dat$x0) + l_gridQCheck1D(qu = 0.4, n = 20)
# The problem gets better if s(x0) is added to the model.

# Works also with factor variables
check1D(fit, "fac") + l_gridQCheck1D(qu = 0.4)
</code></pre>

<hr>
<h2 id='l_gridQCheck2D'>Binning and checking QGAM residuals</h2><span id='topic+l_gridQCheck2D'></span>

<h3>Description</h3>

<p>This layer bins the residuals, r, according to the value of the corresponding
covariates, x1 and x2. Then we calculate the proportion of negative residuals
in each bin, which should not deviate too much from the theoretical proportion (eg 0.5 if
we fit the median). Mainly useful in conjuction with <a href="#topic+check2D">check2D</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>l_gridQCheck2D(qu = NULL, bw = c(NA, NA), stand = TRUE, binFun = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="l_gridQCheck2D_+3A_qu">qu</code></td>
<td>
<p>the quantile of interest. Should be in (0, 1).</p>
</td></tr>
<tr><td><code id="l_gridQCheck2D_+3A_bw">bw</code></td>
<td>
<p>numeric vector giving bin width in the vertical and horizontal directions. See the <code>binwidth</code>
arguments in <code>?ggplot2::stat_summary_hex</code>. If left to <code>NA</code>, it will be set to 1/20
of the ranges of x1 and x2.</p>
</td></tr>
<tr><td><code id="l_gridQCheck2D_+3A_stand">stand</code></td>
<td>
<p>if left to <code>TRUE</code> then the observed proportion of negative residuals <code>p_hat</code> in the i-th cell
is normalized using the standard error <code>se = sqrt(qu(1-qu)/n)</code>, where <code>n</code> is the number of
observation in that cell. That is, if <code>stand=TRUE</code> we plot <code>(p_hat-qu)/se</code> rather than
simply <code>p_hat</code>.</p>
</td></tr>
<tr><td><code id="l_gridQCheck2D_+3A_binfun">binFun</code></td>
<td>
<p>the <code>ggplot2</code> function used to perform the binning. By default it
is either <a href="ggplot2.html#topic+stat_summary_2d">ggplot2::stat_summary_2d</a> or <a href="ggplot2.html#topic+stat_summary_2d">ggplot2::stat_summary_hex</a>, depending
on the class of the covariates x1 and x2.</p>
</td></tr>
<tr><td><code id="l_gridQCheck2D_+3A_...">...</code></td>
<td>
<p>graphical arguments to be passed to <code>ggplot2::stat_summary_hex</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>gamLayer</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mgcViz);
set.seed(4124)
n &lt;- 4e2 
dat &lt;- data.frame(x = rnorm(n), y = rnorm(n))

# Simulate some data, residuals are heteroscedastic w.r.t. x
dat$ob &lt;- (dat$x)^2 + (dat$y)^2 + (0.2*abs(dat$x) + 1)  * rnorm(n)
b &lt;- qgamV(ob ~ x + s(y), qu = 0.3, data = dat)

# We have a residual pattern along x (increase n above to 
# see the problem more clearly) 
check2D(b, "x", "y") + l_gridQCheck2D(qu = 0.3, bw = c(0.4, 0.4))

# We need a smooth wrt x to make the pattern disappear
## Not run: 
b1 &lt;- qgamV(ob ~ s(x) + s(y), qu = 0.3, data = dat)
 
check2D(b1, "x", "y") + l_gridQCheck2D(qu = 0.3, bw = c(0.4, 0.4))

## End(Not run)

</code></pre>

<hr>
<h2 id='l_hist'>Adding histogram to a plot</h2><span id='topic+l_hist'></span>

<h3>Description</h3>

<p>This layer adds a histogram to a plot. It is mainly a
wrapper around <a href="ggplot2.html#topic+geom_histogram">ggplot2::geom_histogram</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>l_hist(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="l_hist_+3A_...">...</code></td>
<td>
<p>graphical arguments to be passed to <code>ggplot2::geom_histogram</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>gamLayer</code>.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+check0D">check0D</a> for examples.
</p>

<hr>
<h2 id='l_points'>Add points to plot</h2><span id='topic+l_points'></span>

<h3>Description</h3>

<p>This layers add points to smooth, parametric or random effect plots.
It can also be used to add points to the output of <code>check1D</code>
and <code>check2D</code>. The meaning of the added points, which could represent
residuals or covariate values, should be clear from context.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>l_points(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="l_points_+3A_...">...</code></td>
<td>
<p>graphical arguments to be passed to <code>ggplot2::geom_point</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>gamLayer</code>.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+plot.mgcv.smooth.1D">plot.mgcv.smooth.1D</a>, <a href="#topic+plot.mgcv.smooth.2D">plot.mgcv.smooth.2D</a>, <a href="#topic+check1D">check1D</a> or <a href="#topic+check2D">check2D</a> for examples.
</p>

<hr>
<h2 id='l_poly'>Add polygons to effect plots</h2><span id='topic+l_poly'></span>

<h3>Description</h3>

<p>This layers adds polygons to plots and it is mainly usefuls for
plotting Markov random field smooths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>l_poly(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="l_poly_+3A_...">...</code></td>
<td>
<p>graphical arguments to be passed to <code>ggplot2::geom_polygon</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>gamLayer</code>.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+plot.mrf.smooth">plot.mrf.smooth</a> for examples.
</p>

<hr>
<h2 id='l_pvContour'>Adding contour of p-values</h2><span id='topic+l_pvContour'></span>

<h3>Description</h3>

<p>This function adds contour lines proportional to the p-value
of a multidimensional smooth effects. It is useful for checking
where (across covariates x1 and x2) the fitted smooth is significantly
different from zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>l_pvContour(pTrans = identity, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="l_pvContour_+3A_ptrans">pTrans</code></td>
<td>
<p>a transformation to be applied to the p-values before plotting.</p>
</td></tr>
<tr><td><code id="l_pvContour_+3A_...">...</code></td>
<td>
<p>graphical arguments to be passed to  <code>ggplot2::geom_contour</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>gamLayer</code>.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+plotDiff.mgcv.smooth.2D">plotDiff.mgcv.smooth.2D</a> and <a href="#topic+plotDiff.sos.smooth">plotDiff.sos.smooth</a> for examples.
</p>

<hr>
<h2 id='l_pvRaster'>Adding raster or heat-map of p-values</h2><span id='topic+l_pvRaster'></span>

<h3>Description</h3>

<p>This function adds a raster or heat-map proportional to the p-value
of a multidimensional smooth effects. It is useful for checking
where (across covariates x1 and x2) the fitted smooth is significantly
different from zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>l_pvRaster(pTrans = identity, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="l_pvRaster_+3A_ptrans">pTrans</code></td>
<td>
<p>a transformation to be applied to the p-values before plotting.</p>
</td></tr>
<tr><td><code id="l_pvRaster_+3A_...">...</code></td>
<td>
<p>graphical arguments to be passed to  <code>ggplot2::geom_raster</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>gamLayer</code>.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+plotDiff.mgcv.smooth.2D">plotDiff.mgcv.smooth.2D</a> and <a href="#topic+plotDiff.sos.smooth">plotDiff.sos.smooth</a> for examples.
</p>

<hr>
<h2 id='l_rug'>Adding rug to margins of a plot</h2><span id='topic+l_rug'></span>

<h3>Description</h3>

<p>This layer adds a rug plot to the margins of a plot. It is mainly a
wrapper around <a href="ggplot2.html#topic+geom_rug">ggplot2::geom_rug</a>. Notice that for factor effects
plots the rug is jittered by default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>l_rug(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="l_rug_+3A_...">...</code></td>
<td>
<p>graphical arguments to be passed to <code>ggplot2::geom_rug</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>gamLayer</code>.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+plot.mgcv.smooth.1D">plot.mgcv.smooth.1D</a>, <a href="#topic+plot.mgcv.smooth.2D">plot.mgcv.smooth.2D</a> or <a href="#topic+check1D">check1D</a> for examples.
</p>

<hr>
<h2 id='l_simLine'>Add simulated smooth effect curves</h2><span id='topic+l_simLine'></span>

<h3>Description</h3>

<p>This layer adds curves representing smooth effects simulated from the
posterior distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>l_simLine(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="l_simLine_+3A_...">...</code></td>
<td>
<p>graphical arguments to be passed to <code>ggplot2::geom_line</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses transparency to avoid over-plotting.
This can be avoided by setting <code>alpha = 1</code> in the call to <code>l_simLine</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>gamLayer</code>.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+plot.mgcv.smooth.1D">plot.mgcv.smooth.1D</a> for examples.
</p>

<hr>
<h2 id='l_vline'>Adding vertical line to a plot</h2><span id='topic+l_vline'></span>

<h3>Description</h3>

<p>This layer adds a vertical to a plot. It is mainly a
wrapper around <a href="ggplot2.html#topic+geom_abline">ggplot2::geom_vline</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>l_vline(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="l_vline_+3A_...">...</code></td>
<td>
<p>graphical arguments to be passed to <code>ggplot2::geom_vline</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>gamLayer</code>.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+check0D">check0D</a> for examples.
</p>

<hr>
<h2 id='listLayers'>Lists available layers for plotSmooth objects</h2><span id='topic+listLayers'></span>

<h3>Description</h3>

<p>This function takes as input an object of class <code>plotSmooth</code> and
returns the names of all the possible visual layers that
could be used with that object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>listLayers(o)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="listLayers_+3A_o">o</code></td>
<td>
<p>an object of class <code>plotSmooth</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the names of the available layers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mgcViz)
n  &lt;- 400
x1 &lt;- rnorm(n)
x2 &lt;- rnorm(n)
dat &lt;- data.frame("x1" = x1, "x2" = x2,
                  "y" = sin(x1) + 0.5 * x2^2 + rnorm(n))
b &lt;- gam(y ~ x1+s(x2), data = dat, method = "REML")
b &lt;- getViz(b)

# List layers available for parametric effect plot
o &lt;- plot( pterm(b, 1) )
listLayers(o)

# List layers available for smooth effect plot
o &lt;- plot( sm(b, 1) )
listLayers(o)

# List layers available for checking plot
o &lt;- check1D(b, x1)
listLayers(o)

</code></pre>

<hr>
<h2 id='mqgamV'>Fit multiple QGAM models and get a mgamViz object</h2><span id='topic+mqgamV'></span>

<h3>Description</h3>

<p>These are wrapper that fits multple QGAM models using <a href="qgam.html#topic+mqgam">qgam::mqgam</a> and
converts it to a <code>mgamViz</code> object using the <a href="#topic+getViz">getViz</a> function.
It is essentially a shortcut.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mqgamV(form, data, qu, lsig = NULL, err = NULL, aQgam = list(), aViz = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mqgamV_+3A_form">form</code>, <code id="mqgamV_+3A_data">data</code>, <code id="mqgamV_+3A_qu">qu</code>, <code id="mqgamV_+3A_lsig">lsig</code>, <code id="mqgamV_+3A_err">err</code></td>
<td>
<p>same arguments as in <a href="qgam.html#topic+mqgam">qgam::mqgam</a>.</p>
</td></tr>
<tr><td><code id="mqgamV_+3A_aqgam">aQgam</code></td>
<td>
<p>list of further arguments to be passed to <a href="qgam.html#topic+mqgam">qgam::mqgam</a>.</p>
</td></tr>
<tr><td><code id="mqgamV_+3A_aviz">aViz</code></td>
<td>
<p>list of arguments to be passed to <a href="#topic+getViz">getViz</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;mgamViz&quot; which can, for instance, be plotted using <a href="#topic+plot.mgamViz">plot.mgamViz</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mgcViz)
set.seed(2) ## simulate some data...
dat &lt;- gamSim(2,n=500,dist="normal",scale=0.25)$data

# Fit GAM and get gamViz object
b &lt;- mqgamV(y~s(x) + s(z) + I(x*z), data = dat, qu = c(0.25, 0.5, 0.75),
            aQgam = list(argGam = list(select = TRUE)), aViz = list("nsim" = 0))

# This is equivalent to doing
# 1. Fit QGAM
# b &lt;- mqgam(y~s(x) + s(z) + I(x*z), data=dat, 
#            qu = c(0.25, 0.5, 0.75), argGam = list(select = TRUE))
# 2. Convert to gamViz object
# b &lt;- getViz(b, nsim = 0)

# Either way, we all effects by doing
print(plot(b, allTerms = TRUE), pages = 1)


</code></pre>

<hr>
<h2 id='plot.ALE1D'>Plot 1D Accumulated Local Effects (ALE)</h2><span id='topic+plot.ALE1D'></span>

<h3>Description</h3>

<p>Plot 1D Accumulated Local Effects (ALE)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ALE1D'
plot(x, trans = identity, maxpo = 10000, nsim = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ALE1D_+3A_x">x</code></td>
<td>
<p>a 1D ALE effects, produced by the <code>ALE</code> function</p>
</td></tr>
<tr><td><code id="plot.ALE1D_+3A_trans">trans</code></td>
<td>
<p>monotonic function to apply to the ALE effect, before plotting.
Monotonicity is not checked.</p>
</td></tr>
<tr><td><code id="plot.ALE1D_+3A_maxpo">maxpo</code></td>
<td>
<p>maximum number of rug lines that will be used by <code>l_rug</code>.
If number of datapoints &gt; <code>maxpo</code>, then a subsample of <code>maxpo</code> points will be taken.</p>
</td></tr>
<tr><td><code id="plot.ALE1D_+3A_nsim">nsim</code></td>
<td>
<p>number of ALE effect curves to be simulated from the posterior distribution.
These can be plotted using the <a href="#topic+l_simLine">l_simLine</a> layer. See Examples section below.</p>
</td></tr>
<tr><td><code id="plot.ALE1D_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An objects of class <code>plotSmooth</code>.
</p>


<h3>Author(s)</h3>

<p>Matteo Fasiolo and Christian Capezza, with some internal code having been adapted from the ALEPlot
package of Dan Apley.
</p>


<h3>References</h3>

<p>Apley, D.W., and Zhu, J, 2016. Visualizing the effects of predictor variables in black
box supervised learning models. arXiv preprint arXiv:1612.08468.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(mgcViz)
# Here x1 and x2 are very correlated, but only 
# x1 has influence of the response
set.seed(4141)
n &lt;- 1000
X &lt;- rmvn(n, c(0, 0), matrix(c(1, 0.9, 0.9, 1), 2, 2))
y &lt;- X[ , 1] + 0.2 * X[ , 1]^2 + rnorm(n, 0, 0.8)
dat &lt;- data.frame(y = y, x1 = X[ , 1], x2 = X[ , 2])
fit &lt;- gam(y ~ te(x1, x2), data = dat)

# Marginal plot suggests that E(y) depends on x2, but
# this is due to the correlation between x1 and x2...
plot(dat$x2, fit$fitted.values)

# ... in fact ALE effect of x2 is flat ...
plot(ALE(fit, "x2")) + l_ciPoly() + l_fitLine() + l_rug()

# ... while ALE effect of x1 is strong.
plot(ALE(fit, "x1", center = 2), nsim = 20) + 
  l_simLine() + l_fitLine()
  
</code></pre>

<hr>
<h2 id='plot.fs.interaction.1D'>Plotting one dimensional smooth factor interactions</h2><span id='topic+plot.fs.interaction.1D'></span>

<h3>Description</h3>

<p>This method should be used to plot smooth effects
of class <code>"fs.interaction.1D"</code>, that is smooth constructed
using the basis <code>bs="tp"</code>. See <a href="mgcv.html#topic+s">mgcv::s</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fs.interaction.1D'
plot(x, n = 100, xlim = NULL, trans = identity, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.fs.interaction.1D_+3A_x">x</code></td>
<td>
<p>a smooth effect object.</p>
</td></tr>
<tr><td><code id="plot.fs.interaction.1D_+3A_n">n</code></td>
<td>
<p>number of grid points used to compute main effect and c.i. lines.
For a nice smooth plot this needs to be several times the estimated degrees of
freedom for the smooth.</p>
</td></tr>
<tr><td><code id="plot.fs.interaction.1D_+3A_xlim">xlim</code></td>
<td>
<p>if supplied then this pair of numbers are used as the x limits for the plot.</p>
</td></tr>
<tr><td><code id="plot.fs.interaction.1D_+3A_trans">trans</code></td>
<td>
<p>monotonic function to apply to the smooth and residuals, before plotting.
Monotonicity is not checked.</p>
</td></tr>
<tr><td><code id="plot.fs.interaction.1D_+3A_...">...</code></td>
<td>
<p>currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>c("plotSmooth", "gg")</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mgcViz)
set.seed(0)
## simulate data...
f0 &lt;- function(x) 2 * sin(pi * x)
f1 &lt;- function(x, a = 2, b = -1) exp(a * x) + b
f2 &lt;- function(x) 0.2 * x^11 * (10 * (1 - x))^6 + 10 *
  (10 * x)^3 * (1 - x)^10
n &lt;- 500; nf &lt;- 25
fac &lt;- sample(1:nf, n, replace = TRUE)
x0 &lt;- runif(n); x1 &lt;- runif(n); x2 &lt;- runif(n)
a &lt;- rnorm(nf) * .2 + 2; b &lt;- rnorm(nf) * .5
f &lt;- f0(x0) + f1(x1, a[fac], b[fac]) + f2(x2)
fac &lt;- factor(fac)
y &lt;- f + rnorm(n) * 2
## so response depends on global smooths of x0 and
## x2, and a smooth of x1 for each level of fac.

## fit model (note p-values not available when fit
## using gamm)...
bm &lt;- gamm(y ~ s(x0)+ s(x1, fac, bs = "fs", k = 5) + s(x2, k = 20))
v &lt;- getViz(bm$gam)

# Plot with fitted effects and changing title 
plot(sm(v, 2)) + l_fitLine(alpha = 0.6) + labs(title = "Smooth factor interactions")

# Changing plotting limits
plot(sm(v, 2)) + l_fitLine() + ylim(-0.5, 0.5) + xlim(0.25, 0.75)

# Change line type and remove legend
plot(sm(v, 2)) + l_fitLine(size = 1.3, linetype="dotted") + 
                 theme(legend.position="none")
                 
# Clustering smooth effects in 3 groups
plot(sm(v, 2)) + l_fitLine(colour = "grey") + 
                 l_clusterLine(centers = 3, a.clu = list(nstart = 100))
</code></pre>

<hr>
<h2 id='plot.gamViz'>Basic GAM plotting</h2><span id='topic+plot.gamViz'></span>

<h3>Description</h3>

<p>This function is the <code>mgcViz</code> equivalent of <a href="mgcv.html#topic+plot.gam">plot.gam</a>. It is the workhorse of the
<code>mgcViz</code> package, and allows plotting (almost) any type of smooth,
parametric or random effects. It is basically a wrapper around plotting
methods that are specific to individual smooth effect classes (such as
<a href="#topic+plot.mgcv.smooth.1D">plot.mgcv.smooth.1D</a> and <a href="#topic+plot.random.effect">plot.random.effect</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gamViz'
plot(x, n = 100, n2 = 40, select = NULL, allTerms = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.gamViz_+3A_x">x</code></td>
<td>
<p>an object of class <code>gamViz</code>, the output of a <a href="#topic+getViz">getViz</a> call.</p>
</td></tr>
<tr><td><code id="plot.gamViz_+3A_n">n</code></td>
<td>
<p>number of points used for each 1-d plot. For a nice smooth plot
this needs to be several times the estimated degrees of freedom for the smooth.</p>
</td></tr>
<tr><td><code id="plot.gamViz_+3A_n2">n2</code></td>
<td>
<p>square root of number of grid points used for plotting 2D functions effects
using contours or heatmaps.</p>
</td></tr>
<tr><td><code id="plot.gamViz_+3A_select">select</code></td>
<td>
<p>allows plotting a subset of model terms. For instance, if you just want the plot
for the second smooth term, set <code>select = 2</code>. Parametric effects always come
after smooth or random effects.</p>
</td></tr>
<tr><td><code id="plot.gamViz_+3A_allterms">allTerms</code></td>
<td>
<p>if <code>TRUE</code> also the parametric effects will be plotted.</p>
</td></tr>
<tr><td><code id="plot.gamViz_+3A_...">...</code></td>
<td>
<p>other parameters, such as <code>maxpo</code> or <code>trans</code>, to be passed to the specific
plotting methods for each effect (e.g. to <a href="#topic+plot.mgcv.smooth.1D">plot.mgcv.smooth.1D</a>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>c("plotGam", "gg")</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mgcViz)

######## Basic example
# Simulate some data and fit model
set.seed(2)  
dat &lt;- gamSim(1,n=1e3,dist="normal",scale=2)
b &lt;- bam(y~s(x0)+s(x1, x2)+s(x3), data=dat)
b &lt;- getViz(b)

# Default smooth effect plotting
print(plot(b), ask = FALSE)

# Now on one page and with out title on the second plot
print(plot(b) + labs(title = NULL), pages = 1) 

# So far we used default layers, added in the printing phase, but
# we might want to specify our own layers. Here we is how to do it
pl &lt;- plot(b) + l_points() + l_fitLine(linetype = 3) + l_fitContour() + 
  l_ciLine(colour = 2) + theme_get() + labs(title = NULL)
print(pl, pages = 1)

# We might want to plot only the first smooth
plot(b, select = 1) + l_dens(type = "cond") + l_fitLine() + l_ciLine()

## Not run: 
######## Example with "by variable" smooth effect
# Simulate data and fit model
dat &lt;- gamSim(4)
b &lt;- gam(y ~ fac+s(x2,by=fac)+s(x0),data=dat)
b &lt;- getViz(b)
# print() only needed because we want to plot on a single page
print(plot(b), pages = 1) 
print(plot(b, allTerms = TRUE), pages = 1) # Including also parametric effect

######## Example with 3D smooth effect which cannot be plotted
# Simulate data and fit model
n &lt;- 5e3
x &lt;- rnorm(n); y &lt;- rnorm(n); z &lt;- rnorm(n); z2 &lt;- rnorm(n)

ob &lt;- (x-z)^2 + (y-z)^2 + z2^3 + rnorm(n)
b1 &lt;- bam(ob ~ s(x, y, z) + s(z2), discrete = TRUE)
b1 &lt;- getViz(b1)

# Only second effect get plotted
plot(b1)
# In fact this does not plot anything
plot(b1, select = 1)
# For plotting effects with more than 2D, one we need specific method. 
# See ?plot.mgcv.smooth.MD

######## Examples about plotting parametric effects
# 1 Gaussian GAM
set.seed(3)
dat &lt;- gamSim(1,n=2500,dist="normal",scale=20)
dat$fac &lt;- as.factor( sample(c("A1", "A2", "A3"), nrow(dat), replace = TRUE) ) 
dat$logi &lt;- as.logical( sample(c(TRUE, FALSE), nrow(dat), replace = TRUE) ) 
bs &lt;- "cr"; k &lt;- 12
b &lt;- bam(y ~ x0 + x1 + I(x1^2) + s(x2,bs=bs,k=k) + fac + x3:fac + I(x1*x2) + logi +
            s(x3, bs=bs),data=dat, discrete = TRUE)
b &lt;- getViz(b)

# All effects in one page. Notably 'x3:fac' is missing: we have no methods
# for plotting second order effects.
print(plot(b, allTerms = TRUE), pages = 1)

# Plotting only parametric effects
print(plot(b, select = 3:9), pages = 1)

# 2 GAMLSS Gaussian model
library(mgcv);library(MASS)
mcycle$fac &lt;- as.factor( sample(c("z", "k", "a", "f"), nrow(mcycle), replace = TRUE) ) 
b &lt;- gam(list(accel~times + I(times^2) + s(times,k=10), ~ times + fac + s(times)),
          data=mcycle,family=gaulss())
b &lt;- getViz(b)

# All effects on one page: effect of second linear predictor end with '.1'
print(plot(b, allTerms = TRUE), pages = 1)

## End(Not run)

</code></pre>

<hr>
<h2 id='plot.mgamViz'>Plotting multiple quantile GAMs</h2><span id='topic+plot.mgamViz'></span>

<h3>Description</h3>

<p>This function is similar to <a href="#topic+plot.gamViz">plot.gamViz</a>, but it is used
to plot multiple quantile GAM models fitted using <a href="#topic+mqgamV">mqgamV</a> or mqgam.
It allows plotting standards 1D and 2D smooths, and parametric effects,
It is basically a wrapper around plotting methods that are specific to
individual smooth effect classes (such as <a href="#topic+plot.multi.mgcv.smooth.1D">plot.multi.mgcv.smooth.1D</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mgamViz'
plot(x, n = 100, n2 = 40, select = NULL, allTerms = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mgamViz_+3A_x">x</code></td>
<td>
<p>an object of class <code>mgamViz</code>, the output of a <a href="#topic+getViz">getViz</a> call. Alternatively x can
be a list of fitted GAM models, each having the same model formula.</p>
</td></tr>
<tr><td><code id="plot.mgamViz_+3A_n">n</code></td>
<td>
<p>number of points used for each 1-d plot. For a nice smooth plot
this needs to be several times the estimated degrees of freedom for the smooth.</p>
</td></tr>
<tr><td><code id="plot.mgamViz_+3A_n2">n2</code></td>
<td>
<p>square root of number of grid points used for plotting 2D functions effects
using contours or heatmaps.</p>
</td></tr>
<tr><td><code id="plot.mgamViz_+3A_select">select</code></td>
<td>
<p>allows plotting a subset of model terms. For instance, if you just want the plot
for the second smooth term, set <code>select = 2</code>. Parametric effects always come
after smooth or random effects.</p>
</td></tr>
<tr><td><code id="plot.mgamViz_+3A_allterms">allTerms</code></td>
<td>
<p>if <code>TRUE</code> also the parametric effects will be plotted.</p>
</td></tr>
<tr><td><code id="plot.mgamViz_+3A_...">...</code></td>
<td>
<p>other parameters, such as <code>maxpo</code> or <code>trans</code>, to be passed to the specific
plotting methods for each effect (e.g. to <a href="#topic+plot.multi.mgcv.smooth.1D">plot.multi.mgcv.smooth.1D</a>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>c("plotGam", "gg")</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mgcViz)
set.seed(2) ## simulate some data...
dat &lt;- gamSim(1,n=500,dist="normal",scale=2)
dat$logi &lt;- as.logical( sample(c(TRUE, FALSE), nrow(dat), replace = TRUE) )

dat$fac &lt;- as.factor( sample(c("A1", "A2", "A3"), nrow(dat), replace = TRUE) )

# Fit GAM and get gamViz object
fit &lt;- mqgamV(y ~ fac + s(x0) + s(x1, x2) + x3 + logi, data = dat, 
              qu = c(0.2, 0.4, 0.6, 0.8))

print(plot(fit, select = 1:4, allTerms = T), pages = 1)

## Not run: 
# Example where we are fitting the same model to different datasets, but
# plotting the estimate effects together 
dat &lt;- list()
for(ii in 1:4){
  # Simulate 4 datasets, we are adding 2 factor variables "fac" and "ref" just
  # for illustrating the plotting method (the two factors have no effect on y)
  n &lt;- 1000
  dat[[ii]] &lt;- gamSim(1,n=n,dist="normal",scale=2)
  dat[[ii]]$fac &lt;- as.factor( sample(c("A1", "A2", "A3"), n, replace = TRUE) )
  dat[[ii]]$ref &lt;- as.factor( sample(letters[1:10], n, replace = TRUE) )
}

# Estimating model on each dataset
mods &lt;- list()
for(ii in 1:4){
  mods[[ii]] &lt;- gamV(y~s(x0)+s(x1, x2)+x3+fac+s(ref, bs = "re"), data = dat[[ii]])
}

# Names will be used to identify the four models we have fitted 
names(mods) &lt;- c("M1", "M2", "M3", "M4")
# Plotting on the same plots
print(plot.mgamViz(mods, allTerms = TRUE), pages = 1)

## End(Not run)

</code></pre>

<hr>
<h2 id='plot.mgcv.smooth.1D'>Plotting one dimensional smooth effects</h2><span id='topic+plot.mgcv.smooth.1D'></span><span id='topic+plot.multi.mgcv.smooth.1D'></span>

<h3>Description</h3>

<p>Plotting method for one dimensional smooth effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mgcv.smooth.1D'
plot(
  x,
  n = 100,
  xlim = NULL,
  maxpo = 10000,
  trans = identity,
  unconditional = FALSE,
  seWithMean = FALSE,
  nsim = 0,
  ...
)

## S3 method for class 'multi.mgcv.smooth.1D'
plot(
  x,
  n = 100,
  xlim = NULL,
  maxpo = 10000,
  trans = identity,
  unconditional = FALSE,
  seWithMean = FALSE,
  asFact = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mgcv.smooth.1D_+3A_x">x</code></td>
<td>
<p>a smooth effect object, extracted using <a href="#topic+sm">sm</a>.</p>
</td></tr>
<tr><td><code id="plot.mgcv.smooth.1D_+3A_n">n</code></td>
<td>
<p>number of grid points used to compute main effect and c.i. lines.
For a nice smooth plot this needs to be several times the estimated degrees of
freedom for the smooth.</p>
</td></tr>
<tr><td><code id="plot.mgcv.smooth.1D_+3A_xlim">xlim</code></td>
<td>
<p>if supplied then this pair of numbers are used as the x limits for the plot.</p>
</td></tr>
<tr><td><code id="plot.mgcv.smooth.1D_+3A_maxpo">maxpo</code></td>
<td>
<p>maximum number of residuals points that will be used by layers such as
<code>resRug()</code> and <code>resPoints()</code>. If number of datapoints &gt; <code>maxpo</code>,
then a subsample of <code>maxpo</code> points will be taken.</p>
</td></tr>
<tr><td><code id="plot.mgcv.smooth.1D_+3A_trans">trans</code></td>
<td>
<p>monotonic function to apply to the smooth and residuals, before plotting.
Monotonicity is not checked.</p>
</td></tr>
<tr><td><code id="plot.mgcv.smooth.1D_+3A_unconditional">unconditional</code></td>
<td>
<p>if <code>TRUE</code> then the smoothing parameter uncertainty corrected covariance
matrix is used to compute uncertainty bands, if available.
Otherwise the bands treat the smoothing parameters as fixed.</p>
</td></tr>
<tr><td><code id="plot.mgcv.smooth.1D_+3A_sewithmean">seWithMean</code></td>
<td>
<p>if TRUE the component smooths are shown with confidence intervals that
include the uncertainty about the overall mean. If FALSE then the uncertainty
relates purely to the centred smooth itself. Marra and Wood (2012) suggests
that TRUE results in better coverage performance, and this is also suggested
by simulation.</p>
</td></tr>
<tr><td><code id="plot.mgcv.smooth.1D_+3A_nsim">nsim</code></td>
<td>
<p>number of smooth effect curves to be simulated from the posterior distribution.
These can be plotted using the <a href="#topic+l_simLine">l_simLine</a> layer. See Examples section below.</p>
</td></tr>
<tr><td><code id="plot.mgcv.smooth.1D_+3A_...">...</code></td>
<td>
<p>currently unused.</p>
</td></tr>
<tr><td><code id="plot.mgcv.smooth.1D_+3A_asfact">asFact</code></td>
<td>
<p>determines whether to use a factor or colour bar legend for plot.multi.mgcv.smooth.1D.
For most models the default is <code>TRUE</code>. When working with QGAM models fitted with
<a href="#topic+mqgamV">mqgamV</a>, the default is <code>FALSE</code> for less than 10 quantiles,
<code>TRUE</code> otherwise. For QGAM models there a third option, <code>asFact = "force"</code>,
which forces the use of a discrete colour scale.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An objects of class <code>plotSmooth</code>.
</p>


<h3>References</h3>

<p>Marra, G and S.N. Wood (2012) Coverage Properties of Confidence Intervals for
Generalized Additive Model Components. Scandinavian Journal of Statistics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mgcViz)
n  &lt;- 1e3
x1 &lt;- rnorm(n)
x2 &lt;- rnorm(n)
dat &lt;- data.frame("x1" = x1, "x2" = x2,
                  "y" = sin(x1) + 0.5 * x2^2 + pmax(x2, 0.2) * rnorm(n))
b &lt;- bamV(y ~ s(x1)+s(x2), data = dat, method = "fREML", aGam = list(discrete = TRUE))

o &lt;- plot(sm(b, 1), nsim = 50) # 50 posterior simulations 

## Not run: 
# Plot with fitted effect + posterior simulations + rug on x axis
( o &lt;- o + l_simLine() + l_fitLine(colour = "red") + 
       l_rug(alpha = 0.8) )

# Add CI lines at 1*sigma and 5*sigma
( o &lt;- o + l_ciLine(mul = 1) + l_ciLine(mul = 5, colour = "blue", linetype = 2) )

# Add partial residuals and change theme
( o + l_points(shape = 19, size = 1, alpha = 0.2) + theme_classic() )

# Get second effect plot
o2 &lt;- plot( sm(b, 2) )

# Plot it with polygon for partial residuals
o2 + l_ciPoly(mul = 5, fill = "light blue") + 
  l_fitLine(linetype = 2, colour = "red")

# Plot is with conditional density of partial residuals
o2 + l_dens(type = "cond", alpha = 0.9)  + 
  l_fitLine(linetype = 2, colour = "red")
  
########
# Quantile GAM example
########
# Fit model
b &lt;- mqgamV(y ~ s(x1) + s(x2), qu = c(0.2, 0.5, 0.8), data = dat)

plot(sm(b, 1)) + l_fitLine(linetype = 2) + l_rug(colour = "blue")

## End(Not run)

</code></pre>

<hr>
<h2 id='plot.mgcv.smooth.2D'>Plotting two dimensional smooth effects</h2><span id='topic+plot.mgcv.smooth.2D'></span><span id='topic+plot.multi.mgcv.smooth.2D'></span>

<h3>Description</h3>

<p>Plotting method for two dimensional smooth effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mgcv.smooth.2D'
plot(
  x,
  n = 40,
  xlim = NULL,
  ylim = NULL,
  maxpo = 10000,
  too.far = 0.1,
  trans = identity,
  seWithMean = FALSE,
  unconditional = FALSE,
  ...
)

## S3 method for class 'multi.mgcv.smooth.2D'
plot(
  x,
  n = 30,
  xlim = NULL,
  ylim = NULL,
  maxpo = 10000,
  too.far = 0.1,
  trans = identity,
  seWithMean = FALSE,
  unconditional = FALSE,
  a.facet = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mgcv.smooth.2D_+3A_x">x</code></td>
<td>
<p>a smooth effect object, extracted using <a href="#topic+sm">sm</a>.</p>
</td></tr>
<tr><td><code id="plot.mgcv.smooth.2D_+3A_n">n</code></td>
<td>
<p>sqrt of the number of grid points used to compute the effect plot.</p>
</td></tr>
<tr><td><code id="plot.mgcv.smooth.2D_+3A_xlim">xlim</code></td>
<td>
<p>if supplied then this pair of numbers are used as the x limits for the plot.</p>
</td></tr>
<tr><td><code id="plot.mgcv.smooth.2D_+3A_ylim">ylim</code></td>
<td>
<p>if supplied then this pair of numbers are used as the y limits for the plot.</p>
</td></tr>
<tr><td><code id="plot.mgcv.smooth.2D_+3A_maxpo">maxpo</code></td>
<td>
<p>maximum number of residuals points that will be used by layers such as
<code>resRug()</code> and <code>resPoints()</code>. If number of datapoints &gt; <code>maxpo</code>,
then a subsample of <code>maxpo</code> points will be taken.</p>
</td></tr>
<tr><td><code id="plot.mgcv.smooth.2D_+3A_too.far">too.far</code></td>
<td>
<p>if greater than 0 then this is used to determine when a location is too far
from data to be plotted. This is useful since smooths tend to go wild
away from data. The data are scaled into the unit square before deciding
what to exclude, and too.far is a distance within the unit square.
Setting to zero can make plotting faster for large datasets, but care
then needed with interpretation of plots.</p>
</td></tr>
<tr><td><code id="plot.mgcv.smooth.2D_+3A_trans">trans</code></td>
<td>
<p>monotonic function to apply to the smooth and residuals, before plotting.
Monotonicity is not checked.</p>
</td></tr>
<tr><td><code id="plot.mgcv.smooth.2D_+3A_sewithmean">seWithMean</code></td>
<td>
<p>if TRUE the component smooths are shown with confidence intervals that
include the uncertainty about the overall mean. If FALSE then the uncertainty
relates purely to the centred smooth itself. Marra and Wood (2012) suggests
that TRUE results in better coverage performance, and this is also suggested
by simulation.</p>
</td></tr>
<tr><td><code id="plot.mgcv.smooth.2D_+3A_unconditional">unconditional</code></td>
<td>
<p>if <code>TRUE</code> then the smoothing parameter uncertainty corrected covariance
matrix is used to compute uncertainty bands, if available.
Otherwise the bands treat the smoothing parameters as fixed.</p>
</td></tr>
<tr><td><code id="plot.mgcv.smooth.2D_+3A_...">...</code></td>
<td>
<p>currently unused.</p>
</td></tr>
<tr><td><code id="plot.mgcv.smooth.2D_+3A_a.facet">a.facet</code></td>
<td>
<p>arguments to be passed to <a href="ggplot2.html#topic+facet_wrap">ggplot2::facet_wrap</a> or <a href="ggplot2.html#topic+facet_grid">ggplot2::facet_grid</a>. The former gets
called when <code>fix</code> contains one vector, the latter when <code>fix</code> contains two vectors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An objects of class <code>plotSmooth</code>.
</p>


<h3>References</h3>

<p>Marra, G and S.N. Wood (2012) Coverage Properties of Confidence Intervals for
Generalized Additive Model Components. Scandinavian Journal of Statistics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mgcViz)
set.seed(2) ## simulate some data...
dat &lt;- gamSim(1, n = 700, dist = "normal", scale = 2)
b &lt;- gam(y ~ s(x0) + s(x1, x2) + s(x3), data = dat, method = "REML")
b &lt;- getViz(b)

# Plot 2D effect with noised-up raster, contour and rug for design points 
# Opacity is proportional to the significance of the effect
plot(sm(b, 2)) + l_fitRaster(pTrans = zto1(0.05, 2, 0.1), noiseup = TRUE) + 
  l_rug() + l_fitContour()  

# Plot contour of effect joint density of design points
plot(sm(b, 2)) + l_dens(type = "joint") + l_points() + l_fitContour() + 
  coord_cartesian(expand = FALSE) # Fill the plot
  
###
# Quantile GAM example
###
b &lt;- mqgamV(y ~ s(x0) + s(x1, x2) + s(x3), qu = c(0.3, 0.7), data = dat)

plot(sm(b, 2)) + l_fitRaster(noiseup = TRUE) + l_fitContour(colour = 2)

</code></pre>

<hr>
<h2 id='plot.mgcv.smooth.MD'>Plotting slice of higher-dimensional smooth effects</h2><span id='topic+plot.mgcv.smooth.MD'></span>

<h3>Description</h3>

<p>This function plots a 2D slice of a higher-dimensional smooth effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mgcv.smooth.MD'
plot(
  x,
  fix,
  n = 40,
  xlim = NULL,
  ylim = NULL,
  maxpo = 10000,
  too.far = c(0.1, NA),
  trans = identity,
  seWithMean = FALSE,
  unconditional = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mgcv.smooth.MD_+3A_x">x</code></td>
<td>
<p>a smooth effect object, extracted using <a href="#topic+sm">sm</a>.</p>
</td></tr>
<tr><td><code id="plot.mgcv.smooth.MD_+3A_fix">fix</code></td>
<td>
<p>a named vector indicating which variables must be kept fixed and to what values.
When plotting a smooth in (d+2) dimensions, then d variables must be fixed.</p>
</td></tr>
<tr><td><code id="plot.mgcv.smooth.MD_+3A_n">n</code></td>
<td>
<p>sqrt of the number of grid points used to compute the effect plot.</p>
</td></tr>
<tr><td><code id="plot.mgcv.smooth.MD_+3A_xlim">xlim</code></td>
<td>
<p>if supplied then this pair of numbers are used as the x limits for the plot.</p>
</td></tr>
<tr><td><code id="plot.mgcv.smooth.MD_+3A_ylim">ylim</code></td>
<td>
<p>if supplied then this pair of numbers are used as the y limits for the plot.</p>
</td></tr>
<tr><td><code id="plot.mgcv.smooth.MD_+3A_maxpo">maxpo</code></td>
<td>
<p>maximum number of residuals points that will be used by layers such as
<code>resRug()</code> and <code>resPoints()</code>. If number of datapoints &gt; <code>maxpo</code>,
then a subsample of <code>maxpo</code> points will be taken.</p>
</td></tr>
<tr><td><code id="plot.mgcv.smooth.MD_+3A_too.far">too.far</code></td>
<td>
<p>a numeric vector with two entries. The first has the same interpretation
as in <a href="#topic+plot.mgcv.smooth.2D">plot.mgcv.smooth.2D</a> and it avoids plotting the smooth effect
in areas that are too far form any observation. The distance will be calculated only
using the variables which are not in <code>fix</code> (see above). Hence in two dimensions,
not in the full d+2 dimensions. Set it to -1 to plot the whole
smooth. The second entry determines which residuals and covariates pairs are closed
enough to the selected slice. If left to <code>NA</code> on the 10\
closest (in terms of scaled Euclidean distance) to the current slice will be plotted.
Set it to -1 to plot all the residuals.</p>
</td></tr>
<tr><td><code id="plot.mgcv.smooth.MD_+3A_trans">trans</code></td>
<td>
<p>monotonic function to apply to the smooth and residuals, before plotting.
Monotonicity is not checked.</p>
</td></tr>
<tr><td><code id="plot.mgcv.smooth.MD_+3A_sewithmean">seWithMean</code></td>
<td>
<p>if TRUE the component smooths are shown with confidence intervals that
include the uncertainty about the overall mean. If FALSE then the uncertainty
relates purely to the centred smooth itself. Marra and Wood (2012) suggests
that TRUE results in better coverage performance, and this is also suggested
by simulation.</p>
</td></tr>
<tr><td><code id="plot.mgcv.smooth.MD_+3A_unconditional">unconditional</code></td>
<td>
<p>if <code>TRUE</code> then the smoothing parameter uncertainty corrected covariance
matrix is used to compute uncertainty bands, if available.
Otherwise the bands treat the smoothing parameters as fixed.</p>
</td></tr>
<tr><td><code id="plot.mgcv.smooth.MD_+3A_...">...</code></td>
<td>
<p>currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An objects of class <code>plotSmooth</code>.
</p>


<h3>References</h3>

<p>Marra, G and S.N. Wood (2012) Coverage Properties of Confidence Intervals for
Generalized Additive Model Components. Scandinavian Journal of Statistics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## 3D example
library(mgcViz)
n &lt;- 1e3
x &lt;- rnorm(n); y &lt;- rnorm(n); z &lt;- rnorm(n)

ob &lt;- (x-z)^2 + (y-z)^2 + rnorm(n)
b &lt;- gam(ob ~ s(x, y, z))
b &lt;- getViz(b)

# Plot one 2D slice
plot( sm(b, 1), fix = c("z"=0) ) + l_fitRaster(noiseup = TRUE, mul = 3) + 
  l_fitContour(linetype = 2) + l_points(shape =  2)

## 4D
n &lt;- 5e3
x &lt;- rnorm(n); y &lt;- rnorm(n); z &lt;- rnorm(n); z2 &lt;- rnorm(n)

ob &lt;- (x-z)^2 + (y-z)^2 + z2^3 + rnorm(n)
b1 &lt;- bam(ob ~ s(x, y, z, z2), discrete = TRUE)
b1 &lt;- getViz(b1)

# Plot one 2D slice
plot(sm(b1, 1), fix = c("z"=0, "z2"=1)) + l_fitRaster() + l_fitContour()

## End(Not run)

</code></pre>

<hr>
<h2 id='plot.mrf.smooth'>Plotting Markov random field smooths</h2><span id='topic+plot.mrf.smooth'></span>

<h3>Description</h3>

<p>This is the plotting method for Markov random field smooths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mrf.smooth'
plot(x, trans = identity, seWithMean = FALSE, unconditional = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mrf.smooth_+3A_x">x</code></td>
<td>
<p>a smooth effect object, extracted using <a href="#topic+sm">sm</a>.</p>
</td></tr>
<tr><td><code id="plot.mrf.smooth_+3A_trans">trans</code></td>
<td>
<p>monotonic function to apply to the smooth and residuals, before plotting.
Monotonicity is not checked.</p>
</td></tr>
<tr><td><code id="plot.mrf.smooth_+3A_sewithmean">seWithMean</code></td>
<td>
<p>if TRUE the component smooths are shown with confidence intervals that
include the uncertainty about the overall mean. If FALSE then the uncertainty
relates purely to the centred smooth itself. Marra and Wood (2012) suggests
that TRUE results in better coverage performance, and this is also suggested
by simulation.</p>
</td></tr>
<tr><td><code id="plot.mrf.smooth_+3A_unconditional">unconditional</code></td>
<td>
<p>if <code>TRUE</code> then the smoothing parameter uncertainty corrected covariance
matrix is used to compute uncertainty bands, if available.
Otherwise the bands treat the smoothing parameters as fixed.</p>
</td></tr>
<tr><td><code id="plot.mrf.smooth_+3A_...">...</code></td>
<td>
<p>currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An objects of class <code>plotSmooth</code>.
</p>


<h3>References</h3>

<p>Marra, G and S.N. Wood (2012) Coverage Properties of Confidence Intervals for
Generalized Additive Model Components. Scandinavian Journal of Statistics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mgcViz)
## Load Columbus Ohio crime data (see ?columbus for details and credits)
data(columb)       ## data frame
data(columb.polys) ## district shapes list
xt &lt;- list(polys=columb.polys) ## neighbourhood structure info for MRF
par(mfrow=c(2,2))
## First a full rank MRF...
b &lt;- gam(crime ~ s(district,bs="mrf",xt=xt),data=columb,method="REML")
b &lt;- getViz(b) 

# Manual plot
plot(sm(b, 1)) + l_poly(colour = 2) + 
  scale_fill_gradientn(colours = heat.colors(50))

# Default plot 
plot(b)

</code></pre>

<hr>
<h2 id='plot.multi.ptermFactor'>Plotting factor or logical parametric effects</h2><span id='topic+plot.multi.ptermFactor'></span><span id='topic+plot.multi.ptermLogical'></span><span id='topic+plot.ptermFactor'></span><span id='topic+plot.ptermLogical'></span>

<h3>Description</h3>

<p>These are the plotting methods for parametric factor or logical effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'multi.ptermFactor'
plot(x, a.facet = list(), asFact = TRUE, ...)

## S3 method for class 'multi.ptermLogical'
plot(x, ...)

## S3 method for class 'ptermFactor'
plot(x, maxpo = 10000, trans = identity, ...)

## S3 method for class 'ptermLogical'
plot(x, maxpo = 10000, trans = identity, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.multi.ptermFactor_+3A_x">x</code></td>
<td>
<p>a factor or logical parametric effect object, extracted using <a href="#topic+pterm">pterm</a>.</p>
</td></tr>
<tr><td><code id="plot.multi.ptermFactor_+3A_a.facet">a.facet</code></td>
<td>
<p>arguments to be passed to <a href="ggplot2.html#topic+facet_wrap">ggplot2::facet_wrap</a> or <a href="ggplot2.html#topic+facet_grid">ggplot2::facet_grid</a>. The former gets
called when <code>fix</code> contains one vector, the latter when <code>fix</code> contains two vectors.</p>
</td></tr>
<tr><td><code id="plot.multi.ptermFactor_+3A_asfact">asFact</code></td>
<td>
<p>relevant only when working with models fitted with <a href="#topic+mqgamV">mqgamV</a>. If
<code>FALSE</code> quantile of interest (qu) is treated as a continuous variable, otherwise as
a factor.</p>
</td></tr>
<tr><td><code id="plot.multi.ptermFactor_+3A_...">...</code></td>
<td>
<p>currently unused.</p>
</td></tr>
<tr><td><code id="plot.multi.ptermFactor_+3A_maxpo">maxpo</code></td>
<td>
<p>maximum number of residuals points that will be used by layers such as
<code>resRug()</code> and <code>resPoints()</code>. If number of datapoints &gt; <code>maxpo</code>,
then a subsample of <code>maxpo</code> points will be taken.</p>
</td></tr>
<tr><td><code id="plot.multi.ptermFactor_+3A_trans">trans</code></td>
<td>
<p>monotonic function to apply to the fit, confidence intervals and residuals,
before plotting. Monotonicity is not checked.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>plotSmooth</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate data and fit GAM
set.seed(3)
dat &lt;- gamSim(1,n=2000,dist="normal",scale=20)
dat$fac &lt;- as.factor( sample(c("A1", "A2", "A3"), nrow(dat), replace = TRUE) )
dat$logi &lt;- as.logical( sample(c(TRUE, FALSE), nrow(dat), replace = TRUE) )
bs &lt;- "cr"; k &lt;- 12
b &lt;- gam(y~fac + s(x0) + s(x1) + s(x2) + s(x3) + logi, data=dat)
o &lt;- getViz(b, nsim = 0)

# Extract factor terms and plot it
pt &lt;- pterm(o, 1)
plot(pt) + l_ciBar() + l_fitPoints(colour = 2) + l_rug(alpha = 0.2)

# Use barplot instead of points
pt &lt;- pterm(o, 1)
plot(pt) + l_fitBar() + l_ciBar()

# Same with binary varible
pt &lt;- pterm(o, 2)
plot(pt) + l_fitPoints() + l_ciBar()

</code></pre>

<hr>
<h2 id='plot.multi.random.effect'>Plotting random effects</h2><span id='topic+plot.multi.random.effect'></span><span id='topic+plot.random.effect'></span>

<h3>Description</h3>

<p>This is the plotting method for random effects (simple random intercepts).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'multi.random.effect'
plot(x, trans = identity, ...)

## S3 method for class 'random.effect'
plot(x, trans = identity, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.multi.random.effect_+3A_x">x</code></td>
<td>
<p>a random effect object, extracted using <a href="#topic+sm">sm</a>.</p>
</td></tr>
<tr><td><code id="plot.multi.random.effect_+3A_trans">trans</code></td>
<td>
<p>monotonic function to apply to the fit, confidence intervals and residuals,
before plotting. Monotonicity is not checked.</p>
</td></tr>
<tr><td><code id="plot.multi.random.effect_+3A_...">...</code></td>
<td>
<p>currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>plotSmooth</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mgcViz)
b &lt;- gam(travel~s(Rail,bs="re"), data=Rail, method="REML")
b &lt;- getViz(b)
plot(sm(b, 1)) + l_fitLine(colour = 2, linetype = 2) + l_points() + 
  l_ciLine(colour = 4, linetype = 3)

plot(sm(b, 1)) + l_ciPoly() + l_points()

# Default
plot(b)

###
# Quantile GAM version
###
b &lt;- mqgamV(travel~s(Rail,bs="re"), data=as.data.frame(Rail), qu = c(0.2, 0.4, 0.6, 0.8))

plot(sm(b, 1)) + l_ciPoly() + l_points()

# Default
plot(b)

</code></pre>

<hr>
<h2 id='plot.ptermInteraction'>Plotting parametric interactions</h2><span id='topic+plot.ptermInteraction'></span><span id='topic+plot.multi.ptermInteraction'></span>

<h3>Description</h3>

<p>This function is here only to deal with parametric interactions (eg x0:fact), which
cannot be plotted at the moment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ptermInteraction'
plot(x, ...)

## S3 method for class 'multi.ptermInteraction'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ptermInteraction_+3A_x">x</code></td>
<td>
<p>a parametric interaction object, extracted using <a href="#topic+pterm">pterm</a>.</p>
</td></tr>
<tr><td><code id="plot.ptermInteraction_+3A_...">...</code></td>
<td>
<p>currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Currently it returns <code>NULL</code>.
</p>

<hr>
<h2 id='plot.ptermMatrixNumeric'>Plotting numeric parametric effects</h2><span id='topic+plot.ptermMatrixNumeric'></span><span id='topic+plot.multi.ptermNumeric'></span><span id='topic+plot.ptermNumeric'></span>

<h3>Description</h3>

<p>This is the plotting method for parametric numerical effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ptermMatrixNumeric'
plot(x, n = 100, xlim = NULL, trans = identity, ...)

## S3 method for class 'multi.ptermNumeric'
plot(x, ...)

## S3 method for class 'ptermNumeric'
plot(x, n = 100, xlim = NULL, maxpo = 10000, trans = identity, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ptermMatrixNumeric_+3A_x">x</code></td>
<td>
<p>a numerical parametric effect object, extracted using <a href="#topic+pterm">pterm</a>.</p>
</td></tr>
<tr><td><code id="plot.ptermMatrixNumeric_+3A_n">n</code></td>
<td>
<p>number of grid points used to compute main effect and c.i. lines.</p>
</td></tr>
<tr><td><code id="plot.ptermMatrixNumeric_+3A_xlim">xlim</code></td>
<td>
<p>if supplied then this pair of numbers are used as the x limits for the plot.</p>
</td></tr>
<tr><td><code id="plot.ptermMatrixNumeric_+3A_trans">trans</code></td>
<td>
<p>monotonic function to apply to the fit, confidence intervals and residuals,
before plotting. Monotonicity is not checked.</p>
</td></tr>
<tr><td><code id="plot.ptermMatrixNumeric_+3A_...">...</code></td>
<td>
<p>currently unused.</p>
</td></tr>
<tr><td><code id="plot.ptermMatrixNumeric_+3A_maxpo">maxpo</code></td>
<td>
<p>maximum number of residuals points that will be used by layers such as
<code>resRug()</code> and <code>resPoints()</code>. If number of datapoints &gt; <code>maxpo</code>,
then a subsample of <code>maxpo</code> points will be taken.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>plotSmooth</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate data and fit GAM
set.seed(3)
dat &lt;- gamSim(1,n=2000,dist="normal",scale=20)
bs &lt;- "cr"; k &lt;- 12
b &lt;- gam(y ~  x0 + x1 + I(x1^2) + s(x2,bs=bs,k=k) + 
              I(x1*x2) + s(x3, bs=bs), data=dat)
o &lt;- getViz(b, nsim = 0)

# Extract first terms and plot it
pt &lt;- pterm(o, 1)
plot(pt, n = 60) + l_ciPoly() + l_fitLine() + l_ciLine()

# Extract I(x1^2) terms and plot it with partial residuals
pt &lt;- pterm(o, 3)
plot(pt, n = 60) + l_ciPoly() + l_fitLine() + l_ciLine() + l_points()

</code></pre>

<hr>
<h2 id='plot.sos.smooth'>Plotting smooths on the sphere</h2><span id='topic+plot.sos.smooth'></span>

<h3>Description</h3>

<p>This is the plotting method for smooth effects on the sphere.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sos.smooth'
plot(
  x,
  n = 40,
  xlim = NULL,
  ylim = NULL,
  maxpo = 10000,
  too.far = 0.1,
  phi = 30,
  theta = 30,
  trans = identity,
  scheme = 0,
  seWithMean = FALSE,
  unconditional = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.sos.smooth_+3A_x">x</code></td>
<td>
<p>a smooth effect object, extracted using <a href="#topic+sm">sm</a>.</p>
</td></tr>
<tr><td><code id="plot.sos.smooth_+3A_n">n</code></td>
<td>
<p>sqrt of the number of grid points used to compute the effect plot.</p>
</td></tr>
<tr><td><code id="plot.sos.smooth_+3A_xlim">xlim</code></td>
<td>
<p>if supplied then this pair of numbers are used as the x limits for the plot.</p>
</td></tr>
<tr><td><code id="plot.sos.smooth_+3A_ylim">ylim</code></td>
<td>
<p>if supplied then this pair of numbers are used as the y limits for the plot.</p>
</td></tr>
<tr><td><code id="plot.sos.smooth_+3A_maxpo">maxpo</code></td>
<td>
<p>maximum number of residuals points that will be used by layers such as
<code>resRug()</code> and <code>resPoints()</code>. If number of datapoints &gt; <code>maxpo</code>,
then a subsample of <code>maxpo</code> points will be taken.</p>
</td></tr>
<tr><td><code id="plot.sos.smooth_+3A_too.far">too.far</code></td>
<td>
<p>if greater than 0 then this is used to determine when a location is too far
from data to be plotted. This is useful since smooths tend to go wild
away from data. The data are scaled into the unit square before deciding
what to exclude, and too.far is a distance within the unit square.
Setting to zero can make plotting faster for large datasets, but care
then needed with interpretation of plots.</p>
</td></tr>
<tr><td><code id="plot.sos.smooth_+3A_phi">phi</code></td>
<td>
<p>one of the plotting angles, relevant only if <code>scheme = 0</code>.</p>
</td></tr>
<tr><td><code id="plot.sos.smooth_+3A_theta">theta</code></td>
<td>
<p>the other plotting angle, relevant only if <code>scheme = 0</code>.</p>
</td></tr>
<tr><td><code id="plot.sos.smooth_+3A_trans">trans</code></td>
<td>
<p>monotonic function to apply to the smooth and residuals, before plotting.
Monotonicity is not checked.</p>
</td></tr>
<tr><td><code id="plot.sos.smooth_+3A_scheme">scheme</code></td>
<td>
<p>if 0 the smooth effect is plotted on the sphere. If 1 the smooth effect is plotted
on the two hemispheres.</p>
</td></tr>
<tr><td><code id="plot.sos.smooth_+3A_sewithmean">seWithMean</code></td>
<td>
<p>if TRUE the component smooths are shown with confidence intervals that
include the uncertainty about the overall mean. If FALSE then the uncertainty
relates purely to the centred smooth itself. Marra and Wood (2012) suggests
that TRUE results in better coverage performance, and this is also suggested
by simulation.</p>
</td></tr>
<tr><td><code id="plot.sos.smooth_+3A_unconditional">unconditional</code></td>
<td>
<p>if <code>TRUE</code> then the smoothing parameter uncertainty corrected covariance
matrix is used to compute uncertainty bands, if available.
Otherwise the bands treat the smoothing parameters as fixed.</p>
</td></tr>
<tr><td><code id="plot.sos.smooth_+3A_...">...</code></td>
<td>
<p>currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An objects of class <code>plotSmooth</code>.
</p>


<h3>References</h3>

<p>Marra, G and S.N. Wood (2012) Coverage Properties of Confidence Intervals for
Generalized Additive Model Components. Scandinavian Journal of Statistics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mgcViz)
set.seed(0)
n &lt;- 400

f &lt;- function(la,lo) { ## a test function...
  sin(lo)*cos(la-.3)
}

## generate with uniform density on sphere...  
lo &lt;- runif(n)*2*pi-pi ## longitude
la &lt;- runif(3*n)*pi-pi/2
ind &lt;- runif(3*n)&lt;=cos(la)
la &lt;- la[ind];
la &lt;- la[1:n]

ff &lt;- f(la,lo)
y &lt;- ff + rnorm(n)*.2 ## test data

## generate data for plotting truth...
lam &lt;- seq(-pi/2,pi/2,length=30)
lom &lt;- seq(-pi,pi,length=60)
gr &lt;- expand.grid(la=lam,lo=lom)
fz &lt;- f(gr$la,gr$lo)
zm &lt;- matrix(fz,30,60)

require(mgcv)
dat &lt;- data.frame(la = la *180/pi,lo = lo *180/pi,y=y)

## fit spline on sphere model...
bp &lt;- gam(y~s(la,lo,bs="sos",k=60),data=dat)
bp &lt;- getViz(bp)

# Plot on sphere
plot(sm(bp, 1), scheme=0) + l_fitRaster() + l_fitContour() + 
   l_points(shape = 19) + l_rug() + l_coordContour() + l_bound() 
 
# Plotting as in standard 2D plots
plot(sm(bp, 1), scheme=1) + l_fitRaster() + l_fitContour() + 
           l_points(shape = 19) + l_rug()
</code></pre>

<hr>
<h2 id='plotDiff'>Generic plotting of differences</h2><span id='topic+plotDiff'></span>

<h3>Description</h3>

<p>Generic function for plotting differences between objects. Useful
mainly for plotting the differences between two smooth effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotDiff(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotDiff_+3A_...">...</code></td>
<td>
<p>arguments to be passed to methods. This first one will determine which
method will be called.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+plotDiff.mgcv.smooth.1D">plotDiff.mgcv.smooth.1D</a>, <a href="#topic+plotDiff.mgcv.smooth.2D">plotDiff.mgcv.smooth.2D</a>, <a href="#topic+plotDiff.sos.smooth">plotDiff.sos.smooth</a>
</p>

<hr>
<h2 id='plotDiff.mgcv.smooth.1D'>Plotting differences between two 1D smooth effects</h2><span id='topic+plotDiff.mgcv.smooth.1D'></span>

<h3>Description</h3>

<p>This method can be used to plot the difference between two 1D
smooth effects. Mainly meant to be used with by-factor smooths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mgcv.smooth.1D'
plotDiff(s1, s2, n = 100, trans = identity, unconditional = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotDiff.mgcv.smooth.1D_+3A_s1">s1</code></td>
<td>
<p>a smooth effect object, extracted using <a href="#topic+sm">sm</a>.</p>
</td></tr>
<tr><td><code id="plotDiff.mgcv.smooth.1D_+3A_s2">s2</code></td>
<td>
<p>another smooth effect object.</p>
</td></tr>
<tr><td><code id="plotDiff.mgcv.smooth.1D_+3A_n">n</code></td>
<td>
<p>number of grid points used to compute main effects and c.i. lines.
For a nice smooth plot this needs to be several times the estimated degrees of
freedom for the smooth.</p>
</td></tr>
<tr><td><code id="plotDiff.mgcv.smooth.1D_+3A_trans">trans</code></td>
<td>
<p>monotonic function to apply to the smooth and residuals, before plotting.
Monotonicity is not checked.</p>
</td></tr>
<tr><td><code id="plotDiff.mgcv.smooth.1D_+3A_unconditional">unconditional</code></td>
<td>
<p>if <code>TRUE</code> then the smoothing parameter uncertainty corrected covariance
matrix is used to compute uncertainty bands, if available.
Otherwise the bands treat the smoothing parameters as fixed.</p>
</td></tr>
<tr><td><code id="plotDiff.mgcv.smooth.1D_+3A_...">...</code></td>
<td>
<p>currently unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let sd be the difference between the fitted smooths, that is: sd = s1 - s2.
sd is a vector of length n, and its covariance matrix is
Cov(sd) = X1\
where: X1 (X2) and Sig11 (Sig22) are the design matrix and the covariance matrix
of the coefficients of s1 (s2), while Sig12 is the cross-covariance matrix between
the coefficients of s1 and s2. To get the confidence intervals we need only diag(Cov(sd)),
which here is calculated efficiently (without computing the whole of Cov(sd)).
</p>


<h3>Value</h3>

<p>An objects of class <code>plotSmooth</code>.
</p>


<h3>References</h3>

<p>Marra, G and S.N. Wood (2012) Coverage Properties of Confidence Intervals for
Generalized Additive Model Components. Scandinavian Journal of Statistics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate data and add factors uncorrelated to the response
library(mgcViz)
set.seed(6898)
dat &lt;- gamSim(1,n=1500,dist="normal",scale=20)
dat$fac &lt;- as.factor( sample(c("A1", "A2", "A3"), nrow(dat), replace = TRUE) ) 
dat$logi &lt;- as.logical( sample(c(TRUE, FALSE), nrow(dat), replace = TRUE) ) 
bs &lt;- "cr"; k &lt;- 12
b &lt;- gam(y ~ s(x2,bs=bs,by = fac), data=dat)
o &lt;- getViz(b, nsim = 0)

# Extract the smooths correspoding to "A1" and "A2" and plot their differences
# with credible intervals
plotDiff(s1 = sm(o, 1), s2 = sm(o, 2)) + l_ciPoly() + 
  l_fitLine() + geom_hline(yintercept = 0, linetype = 2)
  
</code></pre>

<hr>
<h2 id='plotDiff.mgcv.smooth.2D'>Plotting differences between two 2D smooth effects</h2><span id='topic+plotDiff.mgcv.smooth.2D'></span>

<h3>Description</h3>

<p>This method can be used to plot the difference between two 2D
smooth effects. Mainly meant to be used with by-factor smooths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mgcv.smooth.2D'
plotDiff(
  s1,
  s2,
  n = 40,
  too.far = 0.1,
  trans = identity,
  unconditional = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotDiff.mgcv.smooth.2D_+3A_s1">s1</code></td>
<td>
<p>a smooth effect object, extracted using <a href="#topic+sm">sm</a>.</p>
</td></tr>
<tr><td><code id="plotDiff.mgcv.smooth.2D_+3A_s2">s2</code></td>
<td>
<p>another smooth effect object.</p>
</td></tr>
<tr><td><code id="plotDiff.mgcv.smooth.2D_+3A_n">n</code></td>
<td>
<p>sqrt of the number of grid points used to compute the effect plot.</p>
</td></tr>
<tr><td><code id="plotDiff.mgcv.smooth.2D_+3A_too.far">too.far</code></td>
<td>
<p>if greater than 0 then this is used to determine when a location is too far
from data to be plotted. This is useful since smooths tend to go wild
away from data. The data are scaled into the unit square before deciding
what to exclude, and too.far is a distance within the unit square.
Setting to zero can make plotting faster for large datasets, but care
then needed with interpretation of plots.</p>
</td></tr>
<tr><td><code id="plotDiff.mgcv.smooth.2D_+3A_trans">trans</code></td>
<td>
<p>monotonic function to apply to the smooth and residuals, before plotting.
Monotonicity is not checked.</p>
</td></tr>
<tr><td><code id="plotDiff.mgcv.smooth.2D_+3A_unconditional">unconditional</code></td>
<td>
<p>if <code>TRUE</code> then the smoothing parameter uncertainty corrected covariance
matrix is used to compute uncertainty bands, if available.
Otherwise the bands treat the smoothing parameters as fixed.</p>
</td></tr>
<tr><td><code id="plotDiff.mgcv.smooth.2D_+3A_...">...</code></td>
<td>
<p>currently unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let sd be the difference between the fitted smooths, that is: sd = s1 - s2.
sd is a vector of length n, and its covariance matrix is
Cov(sd) = X1\
where: X1 (X2) and Sig11 (Sig22) are the design matrix and the covariance matrix
of the coefficients of s1 (s2), while Sig12 is the cross-covariance matrix between
the coefficients of s1 and s2. To get the confidence intervals we need only diag(Cov(sd)),
which here is calculated efficiently (without computing the whole of Cov(sd)).
</p>


<h3>Value</h3>

<p>An objects of class <code>plotSmooth</code>.
</p>


<h3>References</h3>

<p>Marra, G and S.N. Wood (2012) Coverage Properties of Confidence Intervals for
Generalized Additive Model Components. Scandinavian Journal of Statistics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate data and add factors uncorrelated to the response
library(mgcViz)
set.seed(235)
dat &lt;- gamSim(1,n=1500,dist="normal",scale=20)
dat$fac &lt;- as.factor( sample(c("A1", "A2", "A3"), nrow(dat), replace = TRUE) ) 
dat$logi &lt;- as.logical( sample(c(TRUE, FALSE), nrow(dat), replace = TRUE) ) 
bs &lt;- "cr"; k &lt;- 12
b &lt;- gam(y ~ s(x2, x1, by = fac), data=dat)
o &lt;- getViz(b, nsim = 0)

# Extract the smooths correspoding to "A1" and "A2" and plot their difference
pl &lt;- plotDiff(s1 = sm(o, 1), s2 = sm(o, 2))
pl + l_fitRaster() + l_fitContour()

# Plot p-values for differences between the two smooths
pl + l_pvRaster() + l_pvContour()

</code></pre>

<hr>
<h2 id='plotDiff.sos.smooth'>Plotting differences between two smooths on the sphere</h2><span id='topic+plotDiff.sos.smooth'></span>

<h3>Description</h3>

<p>This method can be used to plot the difference between two smooth
effects on the sphere. Mainly meant to be used with by-factor smooths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sos.smooth'
plotDiff(
  s1,
  s2,
  n = 40,
  too.far = 0.1,
  phi = 30,
  theta = 30,
  scheme = 0,
  trans = identity,
  unconditional = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotDiff.sos.smooth_+3A_s1">s1</code></td>
<td>
<p>a smooth effect object, extracted using <a href="#topic+sm">sm</a>.</p>
</td></tr>
<tr><td><code id="plotDiff.sos.smooth_+3A_s2">s2</code></td>
<td>
<p>another smooth effect object.</p>
</td></tr>
<tr><td><code id="plotDiff.sos.smooth_+3A_n">n</code></td>
<td>
<p>sqrt of the number of grid points used to compute the effect plot.</p>
</td></tr>
<tr><td><code id="plotDiff.sos.smooth_+3A_too.far">too.far</code></td>
<td>
<p>if greater than 0 then this is used to determine when a location is too far
from data to be plotted. This is useful since smooths tend to go wild
away from data. The data are scaled into the unit square before deciding
what to exclude, and too.far is a distance within the unit square.
Setting to zero can make plotting faster for large datasets, but care
then needed with interpretation of plots.</p>
</td></tr>
<tr><td><code id="plotDiff.sos.smooth_+3A_phi">phi</code></td>
<td>
<p>one of the plotting angles, relevant only if <code>scheme = 0</code>.</p>
</td></tr>
<tr><td><code id="plotDiff.sos.smooth_+3A_theta">theta</code></td>
<td>
<p>the other plotting angle, relevant only if <code>scheme = 0</code>.</p>
</td></tr>
<tr><td><code id="plotDiff.sos.smooth_+3A_scheme">scheme</code></td>
<td>
<p>if 0 the smooth effect is plotted on the sphere. If 1 the smooth effect is plotted
on the two hemispheres.</p>
</td></tr>
<tr><td><code id="plotDiff.sos.smooth_+3A_trans">trans</code></td>
<td>
<p>monotonic function to apply to the smooth and residuals, before plotting.
Monotonicity is not checked.</p>
</td></tr>
<tr><td><code id="plotDiff.sos.smooth_+3A_unconditional">unconditional</code></td>
<td>
<p>if <code>TRUE</code> then the smoothing parameter uncertainty corrected covariance
matrix is used to compute uncertainty bands, if available.
Otherwise the bands treat the smoothing parameters as fixed.</p>
</td></tr>
<tr><td><code id="plotDiff.sos.smooth_+3A_...">...</code></td>
<td>
<p>currently unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let sd be the difference between the fitted smooths, that is: sd = s1 - s2.
sd is a vector of length n, and its covariance matrix is
Cov(sd) = X1\
where: X1 (X2) and Sig11 (Sig22) are the design matrix and the covariance matrix
of the coefficients of s1 (s2), while Sig12 is the cross-covariance matrix between
the coefficients of s1 and s2. To get the confidence intervals we need only diag(Cov(sd)),
which here is calculated efficiently (without computing the whole of Cov(sd)).
</p>


<h3>Value</h3>

<p>An objects of class <code>plotSmooth</code>.
</p>


<h3>References</h3>

<p>Marra, G and S.N. Wood (2012) Coverage Properties of Confidence Intervals for
Generalized Additive Model Components. Scandinavian Journal of Statistics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#### 1) Simulate data and add factors uncorrelated to the response
library(mgcViz)
set.seed(0)
n &lt;- 500

f &lt;- function(la,lo) { ## a test function...
  sin(lo)*cos(la-.3)
}

## generate with uniform density on sphere...  
lo &lt;- runif(n)*2*pi-pi ## longitude
la &lt;- runif(3*n)*pi-pi/2
ind &lt;- runif(3*n)&lt;=cos(la)
la &lt;- la[ind];
la &lt;- la[1:n]

ff &lt;- f(la,lo)
y &lt;- ff + rnorm(n)*.2 ## test data

## generate data for plotting truth...
lam &lt;- seq(-pi/2,pi/2,length=30)
lom &lt;- seq(-pi,pi,length=60)
gr &lt;- expand.grid(la=lam,lo=lom)
fz &lt;- f(gr$la,gr$lo)
zm &lt;- matrix(fz,30,60)

dat &lt;- data.frame(la = la *180/pi,lo = lo *180/pi,y=y)
dat$fac &lt;- as.factor( sample(c("A1", "A2", "A3"), nrow(dat), replace = TRUE) ) 

#### 2) fit spline on sphere model...
bp &lt;- gam(y~s(la,lo,bs="sos",k=60, by = fac),data=dat)
bp &lt;- getViz(bp)

# Extract the smooths correspoding to "A1" and "A3" and plot their difference
# Using scheme = 0 
pl0 &lt;- plotDiff(s1 = sm(bp, 1), s2 = sm(bp, 3))
pl0 + l_fitRaster() + l_fitContour() + l_coordContour() + l_bound()

# Plot p-values for significance of differences
pl0 + l_pvRaster() + l_pvContour(breaks=c(0.05, 0.1, 0.2, 0.3, 0.5))

# Using scheme = 1
pl1 &lt;- plotDiff(s1 = sm(bp, 1), s2 = sm(bp, 2), scheme = 1) 
pl1 + l_fitRaster() + l_fitContour()

# Plot p-values for significance of differences
pl1 + l_pvRaster() + l_pvContour(breaks=c(0.05, 0.1, 0.2, 0.3, 0.5))

## End(Not run)
</code></pre>

<hr>
<h2 id='plotRGL'>Generic RGL plotting function</h2><span id='topic+plotRGL'></span>

<h3>Description</h3>

<p>Generic function for producing an interactive RGL plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotRGL(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotRGL_+3A_x">x</code></td>
<td>
<p>the object we want to plot using the <code>rgl</code> package.</p>
</td></tr>
<tr><td><code id="plotRGL_+3A_...">...</code></td>
<td>
<p>arguments to be passed to methods.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+plotRGL.mgcv.smooth.2D">plotRGL.mgcv.smooth.2D</a>, <a href="#topic+plotRGL.mgcv.smooth.MD">plotRGL.mgcv.smooth.MD</a>
</p>

<hr>
<h2 id='plotRGL.mgcv.smooth.2D'>Visualizing 2D smooth effects in 3D</h2><span id='topic+plotRGL.mgcv.smooth.2D'></span>

<h3>Description</h3>

<p>This method plots an interactive 3D representation of a 2D smooth effect, using
the rgl package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mgcv.smooth.2D'
plotRGL(
  x,
  se = TRUE,
  n = 40,
  residuals = FALSE,
  type = "auto",
  maxpo = 1000,
  too.far = 0,
  xlab = NULL,
  ylab = NULL,
  main = NULL,
  xlim = NULL,
  ylim = NULL,
  se.mult = 1,
  trans = identity,
  seWithMean = FALSE,
  unconditional = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotRGL.mgcv.smooth.2D_+3A_x">x</code></td>
<td>
<p>a smooth effect object, extracted using <a href="#topic+sm">sm</a>.</p>
</td></tr>
<tr><td><code id="plotRGL.mgcv.smooth.2D_+3A_se">se</code></td>
<td>
<p>when TRUE (default) upper and lower surfaces are added to the plot at <code>se.mult</code>
(see below) standard deviations for the fitted surface.</p>
</td></tr>
<tr><td><code id="plotRGL.mgcv.smooth.2D_+3A_n">n</code></td>
<td>
<p>sqrt of the number of grid points used to compute the effect plot.</p>
</td></tr>
<tr><td><code id="plotRGL.mgcv.smooth.2D_+3A_residuals">residuals</code></td>
<td>
<p>if TRUE, then the partial residuals will be added.</p>
</td></tr>
<tr><td><code id="plotRGL.mgcv.smooth.2D_+3A_type">type</code></td>
<td>
<p>the type of residuals that should be plotted. See <a href="#topic+residuals.gamViz">residuals.gamViz</a>.</p>
</td></tr>
<tr><td><code id="plotRGL.mgcv.smooth.2D_+3A_maxpo">maxpo</code></td>
<td>
<p>maximum number of residuals points that will be plotted.
If number of datapoints &gt; <code>maxpo</code>, then a subsample of <code>maxpo</code> points will be taken.</p>
</td></tr>
<tr><td><code id="plotRGL.mgcv.smooth.2D_+3A_too.far">too.far</code></td>
<td>
<p>if greater than 0 then this is used to determine when a location is too far
from data to be plotted. This is useful since smooths tend to go wild
away from data. The data are scaled into the unit square before deciding
what to exclude, and too.far is a distance within the unit square.
Setting to zero can make plotting faster for large datasets, but care
is then needed when interpreting the plots.</p>
</td></tr>
<tr><td><code id="plotRGL.mgcv.smooth.2D_+3A_xlab">xlab</code></td>
<td>
<p>if supplied then this will be used as the x label of the plot.</p>
</td></tr>
<tr><td><code id="plotRGL.mgcv.smooth.2D_+3A_ylab">ylab</code></td>
<td>
<p>if supplied then this will be used as the y label of the plot.</p>
</td></tr>
<tr><td><code id="plotRGL.mgcv.smooth.2D_+3A_main">main</code></td>
<td>
<p>used as title for the plot if supplied.</p>
</td></tr>
<tr><td><code id="plotRGL.mgcv.smooth.2D_+3A_xlim">xlim</code></td>
<td>
<p>if supplied then this pair of numbers are used as the x limits for the plot.</p>
</td></tr>
<tr><td><code id="plotRGL.mgcv.smooth.2D_+3A_ylim">ylim</code></td>
<td>
<p>if supplied then this pair of numbers are used as the y limits for the plot.</p>
</td></tr>
<tr><td><code id="plotRGL.mgcv.smooth.2D_+3A_se.mult">se.mult</code></td>
<td>
<p>a positive number which will be the multiplier of the standard errors
when calculating standard error surfaces.</p>
</td></tr>
<tr><td><code id="plotRGL.mgcv.smooth.2D_+3A_trans">trans</code></td>
<td>
<p>monotonic function to apply to the smooth and residuals, before plotting.
Monotonicity is not checked.</p>
</td></tr>
<tr><td><code id="plotRGL.mgcv.smooth.2D_+3A_sewithmean">seWithMean</code></td>
<td>
<p>if TRUE the component smooths are shown with confidence intervals that
include the uncertainty about the overall mean. If FALSE then the uncertainty
relates purely to the centred smooth itself. Marra and Wood (2012) suggests
that TRUE results in better coverage performance, and this is also suggested
by simulation.</p>
</td></tr>
<tr><td><code id="plotRGL.mgcv.smooth.2D_+3A_unconditional">unconditional</code></td>
<td>
<p>if <code>TRUE</code> then the smoothing parameter uncertainty corrected covariance
matrix is used to compute uncertainty bands, if available.
Otherwise the bands treat the smoothing parameters as fixed.</p>
</td></tr>
<tr><td><code id="plotRGL.mgcv.smooth.2D_+3A_...">...</code></td>
<td>
<p>currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>NULL</code> invisibly.
</p>


<h3>References</h3>

<p>Marra, G and S.N. Wood (2012) Coverage Properties of Confidence Intervals for
Generalized Additive Model Components. Scandinavian Journal of Statistics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1: taken from ?mgcv::te, shows how tensor pruduct deals nicely with 
# badly scaled covariates (range of x 5% of range of z )
library(mgcViz)

# Simulate some data
test1 &lt;- function(x,z,sx=0.3,sz=0.4) { 
  x &lt;- x*20
  (pi**sx*sz)*(1.2*exp(-(x-0.2)^2/sx^2-(z-0.3)^2/sz^2)+
                 0.8*exp(-(x-0.7)^2/sx^2-(z-0.8)^2/sz^2))
}
n &lt;- 500
old.par &lt;- par(mfrow=c(2,2))
x &lt;- runif(n)/20;z &lt;- runif(n);
xs &lt;- seq(0,1,length=30)/20;zs &lt;- seq(0,1,length=30)
pr &lt;- data.frame(x=rep(xs,30),z=rep(zs,rep(30,30)))
truth &lt;- matrix(test1(pr$x,pr$z),30,30)
f &lt;- test1(x,z)
y &lt;- f + rnorm(n)*0.2

# Fit with t.p.r.s. basis and plot
b1 &lt;- gam(y~s(x,z))
plotRGL(sm(getViz(b1), 1))

# Need to load rgl at this point
## Not run: 
library(rgl)
rgl.close() # Close

# Fit with tensor products basis and plot (with residuals)
b2 &lt;- gam(y~te(x,z))
plotRGL(sm(getViz(b2), 1), residuals = TRUE)

# We can still work on the plot, for instance change the aspect ratio
aspect3d(1, 2, 1)

rgl.close() # Close

## End(Not run)
</code></pre>

<hr>
<h2 id='plotRGL.mgcv.smooth.MD'>Visualizing a 2D slice of a smooth effects in 3D</h2><span id='topic+plotRGL.mgcv.smooth.MD'></span>

<h3>Description</h3>

<p>This method plots an interactive 3D representation of a 2-dimensional
slice of a multi-dimensional smooth effect, using the rgl package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mgcv.smooth.MD'
plotRGL(
  x,
  fix,
  se = TRUE,
  n = 40,
  residuals = FALSE,
  type = "auto",
  maxpo = 1000,
  too.far = c(0, NA),
  xlab = NULL,
  ylab = NULL,
  main = NULL,
  xlim = NULL,
  ylim = NULL,
  se.mult = 1,
  trans = identity,
  seWithMean = FALSE,
  unconditional = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotRGL.mgcv.smooth.MD_+3A_x">x</code></td>
<td>
<p>a smooth effect object, extracted using <a href="#topic+sm">sm</a>.</p>
</td></tr>
<tr><td><code id="plotRGL.mgcv.smooth.MD_+3A_fix">fix</code></td>
<td>
<p>a named vector indicating which variables must be kept fixed and to what values.
When plotting a smooth in (d+2) dimensions, then d variables must be fixed.</p>
</td></tr>
<tr><td><code id="plotRGL.mgcv.smooth.MD_+3A_se">se</code></td>
<td>
<p>when TRUE (default) upper and lower surfaces are added to the plot at <code>se.mult</code>
(see below) standard deviations for the fitted surface.</p>
</td></tr>
<tr><td><code id="plotRGL.mgcv.smooth.MD_+3A_n">n</code></td>
<td>
<p>sqrt of the number of grid points used to compute the effect plot.</p>
</td></tr>
<tr><td><code id="plotRGL.mgcv.smooth.MD_+3A_residuals">residuals</code></td>
<td>
<p>if TRUE, then the partial residuals will be added.</p>
</td></tr>
<tr><td><code id="plotRGL.mgcv.smooth.MD_+3A_type">type</code></td>
<td>
<p>the type of residuals that should be plotted. See <a href="#topic+residuals.gamViz">residuals.gamViz</a>.</p>
</td></tr>
<tr><td><code id="plotRGL.mgcv.smooth.MD_+3A_maxpo">maxpo</code></td>
<td>
<p>maximum number of residuals points that will be plotted.
If number of datapoints &gt; <code>maxpo</code>, then a subsample of <code>maxpo</code> points will be taken.</p>
</td></tr>
<tr><td><code id="plotRGL.mgcv.smooth.MD_+3A_too.far">too.far</code></td>
<td>
<p>a numeric vector with two entries. The first has the same interpretation
as in <a href="#topic+plot.mgcv.smooth.2D">plot.mgcv.smooth.2D</a> and it avoids plotting the smooth effect
in areas that are too far form any observation. The distance will be calculated only
using the variables which are not in <code>fix</code> (see above). Hence in two dimensions,
not in the full d+2 dimensions. Set it to -1 to plot the whole
smooth. The second entry determines which residuals and covariates pairs are closed
enough to the selected slice. If left to <code>NA</code> on the 10\
closest (in terms of scaled Euclidean distance) to the current slice will be plotted.
Set it to -1 to plot all the residuals.</p>
</td></tr>
<tr><td><code id="plotRGL.mgcv.smooth.MD_+3A_xlab">xlab</code></td>
<td>
<p>if supplied then this will be used as the x label of the plot.</p>
</td></tr>
<tr><td><code id="plotRGL.mgcv.smooth.MD_+3A_ylab">ylab</code></td>
<td>
<p>if supplied then this will be used as the y label of the plot.</p>
</td></tr>
<tr><td><code id="plotRGL.mgcv.smooth.MD_+3A_main">main</code></td>
<td>
<p>used as title for the plot if supplied.</p>
</td></tr>
<tr><td><code id="plotRGL.mgcv.smooth.MD_+3A_xlim">xlim</code></td>
<td>
<p>if supplied then this pair of numbers are used as the x limits for the plot.</p>
</td></tr>
<tr><td><code id="plotRGL.mgcv.smooth.MD_+3A_ylim">ylim</code></td>
<td>
<p>if supplied then this pair of numbers are used as the y limits for the plot.</p>
</td></tr>
<tr><td><code id="plotRGL.mgcv.smooth.MD_+3A_se.mult">se.mult</code></td>
<td>
<p>a positive number which will be the multiplier of the standard errors
when calculating standard error surfaces.</p>
</td></tr>
<tr><td><code id="plotRGL.mgcv.smooth.MD_+3A_trans">trans</code></td>
<td>
<p>monotonic function to apply to the smooth and residuals, before plotting.
Monotonicity is not checked.</p>
</td></tr>
<tr><td><code id="plotRGL.mgcv.smooth.MD_+3A_sewithmean">seWithMean</code></td>
<td>
<p>if TRUE the component smooths are shown with confidence intervals that
include the uncertainty about the overall mean. If FALSE then the uncertainty
relates purely to the centred smooth itself. Marra and Wood (2012) suggests
that TRUE results in better coverage performance, and this is also suggested
by simulation.</p>
</td></tr>
<tr><td><code id="plotRGL.mgcv.smooth.MD_+3A_unconditional">unconditional</code></td>
<td>
<p>if <code>TRUE</code> then the smoothing parameter uncertainty corrected covariance
matrix is used to compute uncertainty bands, if available.
Otherwise the bands treat the smoothing parameters as fixed.</p>
</td></tr>
<tr><td><code id="plotRGL.mgcv.smooth.MD_+3A_...">...</code></td>
<td>
<p>currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>NULL</code> invisibly.
</p>


<h3>References</h3>

<p>Marra, G and S.N. Wood (2012) Coverage Properties of Confidence Intervals for
Generalized Additive Model Components. Scandinavian Journal of Statistics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1: taken from ?mgcv::te, shows how tensor pruduct deals nicely with 
# badly scaled covariates (range of x 5% of range of z )
library(mgcViz)
n &lt;- 1e3
x &lt;- rnorm(n); y &lt;- rnorm(n); z &lt;- rnorm(n)

ob &lt;- (x-z)^2 + (y-z)^2 + rnorm(n)
b &lt;- gam(ob ~ s(x, y, z))
v &lt;- getViz(b)

plotRGL(sm(v, 1), fix = c("z" = 0))

# Need to load rgl at this point
## Not run: 
library(rgl)
rgl.close() # Close

plotRGL(sm(v, 1), fix = c("z" = 1), residuals = TRUE)

# We can still work on the plot, for instance change the aspect ratio
aspect3d(1, 2, 1)

rgl.close() # Close

## End(Not run)

</code></pre>

<hr>
<h2 id='plotSlice'>Plotting sequence of slices of 2D smooth effect</h2><span id='topic+plotSlice'></span>

<h3>Description</h3>

<p>This function allows to slice a multi-dimensional (D &gt; 2) smooth effect,
and to plot the resulting sequence of 2D slices in an array of plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSlice(x, fix, a.facet = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotSlice_+3A_x">x</code></td>
<td>
<p>a smooth effect object, extracted using <a href="#topic+sm">sm</a>.</p>
</td></tr>
<tr><td><code id="plotSlice_+3A_fix">fix</code></td>
<td>
<p>a named list of vectors, where the i-th entry of each vector indicates the value we want to
use for the covariate for i-th slice. When plotting a smooth in (d+2) dimensions,
we need d vectors, because d variables must be fixed. All vectors must have either the same length
(the number of slices) or length 1. <code>fix</code> can contain at most 2 vectors, so if d&gt;=5, we need to set
at least one covariate to a scalar.</p>
</td></tr>
<tr><td><code id="plotSlice_+3A_a.facet">a.facet</code></td>
<td>
<p>arguments to be passed to <a href="ggplot2.html#topic+facet_wrap">ggplot2::facet_wrap</a> or <a href="ggplot2.html#topic+facet_grid">ggplot2::facet_grid</a>. The former gets
called when <code>fix</code> contains one vector, the latter when <code>fix</code> contains two vectors.</p>
</td></tr>
<tr><td><code id="plotSlice_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <a href="#topic+plot.mgcv.smooth.MD">plot.mgcv.smooth.MD</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An objects of class <code>plotSmooth</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### Example 1: plotting slices of 3D smooth
# Simulate data and fit GAM
library(mgcViz)
n &lt;- 1e3
x &lt;- rnorm(n); y &lt;- rnorm(n); z &lt;- rnorm(n)
ob &lt;- (x-z)^2 + (y-z)^2 + rnorm(n)
b &lt;- gam(ob ~ s(x, y, z))
v &lt;- getViz(b)

# Get plot of slices and add layers
pl &lt;- plotSlice(x = sm(v, 1), 
                fix = list("z" = seq(-2, 2, length.out = 9)))
pl + l_fitRaster() + l_fitContour() + l_points() + l_rug()

# Over-ride default layout
pl &lt;- plotSlice(x = sm(v, 1), 
                fix = list("z" = seq(-2, 2, length.out = 9)), 
                a.facet = list(nrow = 2))
pl + l_fitRaster() + l_fitContour() + theme(panel.spacing = unit(0.5, "lines"))

### Example 2: plotting slices of 4D smooth
# Simulate data and fit GAM
n &lt;- 5e3
x &lt;- rnorm(n); y &lt;- rnorm(n); z &lt;- rnorm(n); z2 &lt;- rnorm(n)
ob &lt;- (x-z)^2 + (y-z)^2 + z2^3 + rnorm(n)
b &lt;- bam(ob ~ s(x, y, z, z2), discrete = TRUE)
v &lt;- getViz(b)

# Plot slices across "z" and "x"
pl &lt;- plotSlice(x = sm(v, 1), 
                fix = list("z" = seq(-2, 2, length.out = 3), "x" = c(-1, 0, 1)))
pl + l_fitRaster() + l_fitContour() + l_points() + l_rug()

# Plot slices across "x", keeping "z" fixed
pl &lt;- plotSlice(x = sm(v, 1), 
                fix = list("z" = 0, "x" = seq(-3, 3, length.out = 9)))
pl + l_fitRaster() + l_fitContour() + l_points() + l_rug()

## End(Not run)

</code></pre>

<hr>
<h2 id='postSim'>Posterior simulation from a GAM object</h2><span id='topic+postSim'></span>

<h3>Description</h3>

<p>This method can be used to simulate vectors of responses from the
Gaussian posterior approximation of a gamObject.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>postSim(
  o,
  nsim,
  newdata,
  trans = NULL,
  method = "auto",
  w = NULL,
  offset = NULL,
  savePar = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="postSim_+3A_o">o</code></td>
<td>
<p>the output of a <code>gam()</code> or <code>bam()</code> call.</p>
</td></tr>
<tr><td><code id="postSim_+3A_nsim">nsim</code></td>
<td>
<p>the number of simulated vectors of responses. A positive integer.</p>
</td></tr>
<tr><td><code id="postSim_+3A_newdata">newdata</code></td>
<td>
<p>Optional new data frame used to perform the simulations. To be passed to <a href="mgcv.html#topic+predict.gam">predict.gam</a>.</p>
</td></tr>
<tr><td><code id="postSim_+3A_trans">trans</code></td>
<td>
<p>function used to transform or summarize each vector of simulated responses.
It must take a vector as argument, but it can output a vector or a scalar.
Potentially useful for saving storage (e.g. by transforming each simulated vector
to a scalar). If left to <code>NULL</code> then <code>trans = identity</code> will be used.</p>
</td></tr>
<tr><td><code id="postSim_+3A_method">method</code></td>
<td>
<p>the method used for the simulation of responses. See <a href="#topic+simulate.gam">simulate.gam</a>.</p>
</td></tr>
<tr><td><code id="postSim_+3A_w">w</code></td>
<td>
<p>vector of prior weights of each response. See <a href="#topic+simulate.gam">simulate.gam</a>.</p>
</td></tr>
<tr><td><code id="postSim_+3A_offset">offset</code></td>
<td>
<p>numeric vector of offsets. For GAMs with multiple linear predictor (see eg <a href="mgcv.html#topic+gaulss">gaulss</a>) it
must be a list of vectors. If <code>newdata!=NULL</code> the offsets will be assumed to be zero,
unless their are explicitly provided. If <code>newdata==NULL</code> the simulations will use the
offsets used during model fitting, unless offset is explicitly provided.</p>
</td></tr>
<tr><td><code id="postSim_+3A_savepar">savePar</code></td>
<td>
<p>if <code>TRUE</code> than also the simulated parameters will be returned.</p>
</td></tr>
<tr><td><code id="postSim_+3A_...">...</code></td>
<td>
<p>arguments to be passed to <a href="mgcv.html#topic+vcov.gam">vcov.gam</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>savePar == FALSE</code> the function will return a matrix where each column is a vector of
simulated responses or a transformed version of it. If <code>savePar == TRUE</code> it will return
a list where the <code>$simY</code> entry will contain the simulated responses and <code>$simBeta</code>
the simulated parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mgcViz)
library(MASS)
b &lt;- gam(accel~s(times, k=20), data=mcycle)

# Simulate list of 10 vectors of responses from posterior, taking into
# account smoothing parameters uncertainty (see ?vcov.gam)
n &lt;- 10
sim &lt;- postSim(o = b, nsim = n, unconditional = TRUE)

# Posterior simulations in grey and data in red
plot(rep(mcycle$times, n), as.vector(sim), col = "grey", 
     ylab = "Acceleration", xlab = "Times")
points(mcycle$times, mcycle$accel, col = 2)

# There is clear disagreement between simulations' and data's 
# conditional variance, which can be solved using flexible GAMLSS model:
b &lt;- gam(list(accel~s(times, k=20), ~s(times)), data=mcycle, family = gaulss)
sim &lt;- postSim(o = b, nsim = n)
plot(rep(mcycle$times, n), as.vector(sim), col = "grey", 
     ylab = "Acceleration", xlab = "Times")
points(mcycle$times, mcycle$accel, col = 2)

</code></pre>

<hr>
<h2 id='print.checkGam'>Printing the output of check.gamViz</h2><span id='topic+print.checkGam'></span>

<h3>Description</h3>

<p>This method prints the output of <a href="#topic+check.gamViz">check.gamViz</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'checkGam'
print(x, lay = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.checkGam_+3A_x">x</code></td>
<td>
<p>the output of <code>check.gamViz</code>.</p>
</td></tr>
<tr><td><code id="print.checkGam_+3A_lay">lay</code></td>
<td>
<p>the <code>layout_matrix</code> passed to <a href="gridExtra.html#topic+arrangeGrob">gridExtra::grid.arrange</a>.</p>
</td></tr>
<tr><td><code id="print.checkGam_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code>grid.arrange</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the output of <code>grid.arrange</code>, invisibly.
</p>

<hr>
<h2 id='print.plotGam'>Printing the output of plot.gamViz</h2><span id='topic+print.plotGam'></span>

<h3>Description</h3>

<p>This method prints the output of <a href="#topic+plot.gamViz">plot.gamViz</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'plotGam'
print(x, ask = TRUE, pages = NULL, addLay = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.plotGam_+3A_x">x</code></td>
<td>
<p>an object of class <code>plotGam</code>.</p>
</td></tr>
<tr><td><code id="print.plotGam_+3A_ask">ask</code></td>
<td>
<p>should we ask before moving from one page to the next?</p>
</td></tr>
<tr><td><code id="print.plotGam_+3A_pages">pages</code></td>
<td>
<p>the number of pages over which to spread the output.</p>
</td></tr>
<tr><td><code id="print.plotGam_+3A_addlay">addLay</code></td>
<td>
<p>if TRUE, and if the <code>$empty</code> slot of the <code>plotGam</code> object is TRUE,
we add some default layers to the plots, before printing. Does not have
any affect if the <code>plotGam</code> object already contains some layers.</p>
</td></tr>
<tr><td><code id="print.plotGam_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code>grid.arrange</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the output of <a href="gridExtra.html#topic+arrangeGrob">gridExtra::grid.arrange</a>, invisibly.
</p>

<hr>
<h2 id='print.plotSmooth'>Printing plots of smooth effects</h2><span id='topic+print.plotSmooth'></span>

<h3>Description</h3>

<p>This method prints objects of class <code>plotSmooth</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'plotSmooth'
print(x, addLay = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.plotSmooth_+3A_x">x</code></td>
<td>
<p>an object of class <code>plotSmooth</code>.</p>
</td></tr>
<tr><td><code id="print.plotSmooth_+3A_addlay">addLay</code></td>
<td>
<p>if TRUE, and if the <code>$empty</code> slot of the <code>plotSmooth</code> object is TRUE
or NULL, we add some default layers to the plots, before printing. Does not have
any affect if the <code>plotSmooth</code> object already contains some layers (e.g. <code>l_rug()</code>).</p>
</td></tr>
<tr><td><code id="print.plotSmooth_+3A_...">...</code></td>
<td>
<p>currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>NULL</code>, invisibly.
</p>

<hr>
<h2 id='print.qqGam'>Printing the output of qq.gamViz</h2><span id='topic+print.qqGam'></span>

<h3>Description</h3>

<p>This method prints the output of <a href="#topic+qq.gamViz">qq.gamViz</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'qqGam'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.qqGam_+3A_x">x</code></td>
<td>
<p>an object of class <code>qqGam</code>.</p>
</td></tr>
<tr><td><code id="print.qqGam_+3A_...">...</code></td>
<td>
<p>currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>NULL</code>, invisibly.
</p>

<hr>
<h2 id='pterm'>Extracting parametric effects from a GAM model</h2><span id='topic+pterm'></span>

<h3>Description</h3>

<p>This function can be used to extract a parametric effect from an object of
class <code>gamViz</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pterm(o, select)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pterm_+3A_o">o</code></td>
<td>
<p>an object of class <code>gamViz</code>, the output of a <code>getViz()</code> call.</p>
</td></tr>
<tr><td><code id="pterm_+3A_select">select</code></td>
<td>
<p>index of the selected parametric effect.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;pTermSomething&quot; where &quot;Something&quot; is substituted with
the class of the variable of interest. For instance if this &quot;numeric&quot;, the <code>pterm</code>
will return an object of class &quot;ptermNumeric&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>####### 1. Gaussian GAM 
library(mgcViz)
set.seed(3)
dat &lt;- gamSim(1,n=1500,dist="normal",scale=20)
dat$fac &lt;- as.factor( sample(c("A1", "A2", "A3"), nrow(dat), replace = TRUE) ) 
dat$logi &lt;- as.logical( sample(c(TRUE, FALSE), nrow(dat), replace = TRUE) ) 
bs &lt;- "cr"; k &lt;- 12
b &lt;- gam(y ~ x0 + x1 + I(x1^2) + s(x2,bs=bs,k=k) + fac + x3:fac + I(x1*x2) + logi,data=dat)
o &lt;- getViz(b)

# Plot effect of 'x0'
pt &lt;- pterm(o, 1)
plot(pt, n = 60) + l_ciPoly() + l_fitLine() + l_ciLine() + l_points()

# Plot effect of 'x3'
pt &lt;- pterm(o, 1)
plot(pt, n = 60) + l_fitLine() + l_ciLine(colour = 2)

# Plot effect of 'fac'
pt &lt;- pterm(o, 4)
plot(pt) + l_ciBar(colour = "blue") + l_fitPoints(colour = "red") + 
           l_rug(alpha = 0.3)

# Plot effect of 'logi'
pt &lt;- pterm(o, 6)
plot(pt) + l_fitBar(a.aes = list(fill = I("light blue"))) + l_ciBar(colour = "blue")

# Plot effect of 'x3:fac': no method available yet available for second order terms
pt &lt;- pterm(o, 7)
plot(pt)

## Not run: 
####### 1. Continued: Quantile GAMs
b &lt;- mqgamV(y ~ x0 + x1 + I(x1^2) + s(x2,bs=bs,k=k) + x3:fac + 
              I(x1*x2) + logi, data=dat, qu = c(0.3, 0.5, 0.8))

plot(pterm(b, 3)) + l_ciBar(colour = 2) + l_fitPoints()

plot(pterm(b, 4)) + l_fitBar(colour = "blue", fill = 3) + l_ciBar(colour = 2) 

# Don't know how to plot this interaction
plot(pterm(b, 6))
 
####### 2. Gaussian GAMLSS model
library(MASS)
mcycle$fac &lt;- as.factor( sample(c("z", "k", "a", "f"), nrow(mcycle), replace = TRUE) ) 
b &lt;- gam(list(accel~times + I(times^2) + s(times,k=10), ~ times + fac + s(times)),
          data=mcycle,family=gaulss(), optimizer = "efs")
o &lt;- getViz(b)

# Plot effect of 'I(times^2)' on mean: notice that partial residuals
# are unavailable for GAMLSS models, hence l_point does not do anything here.
pt &lt;- pterm(o, 2)
plot(pt) + l_ciPoly() + l_fitLine() + l_ciLine() + l_points()

# Plot effect of 'times' in second linear predictor.
# Notice that partial residuals are unavailable.
pt &lt;- pterm(o, 3)
plot(pt) + l_ciPoly() + l_fitLine() + l_ciLine(linetype = 3) + l_rug()

# Plot effect of 'fac' in second linear predictor.
pt &lt;- pterm(o, 4)
plot(pt) + l_ciBar(colour = "blue") + l_fitPoints(colour = "red") + 
           l_rug() 

## End(Not run)

</code></pre>

<hr>
<h2 id='qgamV'>Fit a QGAM model and get a gamViz object</h2><span id='topic+qgamV'></span>

<h3>Description</h3>

<p>These are wrapper that fits a QGAM model using <a href="qgam.html#topic+qgam">qgam::qgam</a> and
converts it to a <code>gamViz</code> object using the <a href="#topic+getViz">getViz</a> function.
It is essentially a shortcut.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qgamV(form, data, qu, lsig = NULL, err = NULL, aQgam = list(), aViz = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qgamV_+3A_form">form</code>, <code id="qgamV_+3A_data">data</code>, <code id="qgamV_+3A_qu">qu</code>, <code id="qgamV_+3A_lsig">lsig</code>, <code id="qgamV_+3A_err">err</code></td>
<td>
<p>same arguments as in <a href="qgam.html#topic+qgam">qgam::qgam</a>.</p>
</td></tr>
<tr><td><code id="qgamV_+3A_aqgam">aQgam</code></td>
<td>
<p>list of further arguments to be passed to <a href="qgam.html#topic+qgam">qgam::qgam</a>.</p>
</td></tr>
<tr><td><code id="qgamV_+3A_aviz">aViz</code></td>
<td>
<p>list of arguments to be passed to <a href="#topic+getViz">getViz</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;gamViz&quot; which can, for instance, be plotted using <a href="#topic+plot.gamViz">plot.gamViz</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mgcViz)
set.seed(2) ## simulate some data...
dat &lt;- gamSim(2,n=1000,dist="normal",scale=0.25)$data

# Fit GAM and get gamViz object
b &lt;- qgamV(y~s(x) + s(z) + I(x*z), data = dat, qu = 0.2,
           aQgam = list(argGam = list(select = TRUE)), aViz = list("nsim" = 0))

# This is equivalent to doing
# 1. Fit QGAM
# b &lt;- qgam(y~s(x) + s(z) + I(x*z), data=dat, qu = 0.2, argGam = list(select = TRUE))
# 2. Convert to gamViz object
# b &lt;- getViz(b, nsim = 0)

# Either way, we all effects by doing
print(plot(b, allTerms = TRUE), pages = 1)

</code></pre>

<hr>
<h2 id='qq'>Generic QQ plots</h2><span id='topic+qq'></span>

<h3>Description</h3>

<p>Generic function for producing QQ-plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qq(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qq_+3A_...">...</code></td>
<td>
<p>arguments to be passed to methods. This first one will determine which
method will be called.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+qq.gamViz">qq.gamViz</a>
</p>

<hr>
<h2 id='qq.gamViz'>QQ plots for gam model residuals</h2><span id='topic+qq.gamViz'></span>

<h3>Description</h3>

<p>Takes a fitted gam object, converted using <a href="#topic+getViz">getViz</a>, and produces QQ plots of its residuals
(conditional on the fitted model coefficients and scale parameter). If the model distributional
assumptions are met then usually these plots should be close to a straight line (although
discrete data can yield marked random departures from this line).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gamViz'
qq(
  o,
  rep = 10,
  level = 0.8,
  method = "auto",
  type = "auto",
  CI = "none",
  worm = FALSE,
  showReps = FALSE,
  sortFun = NULL,
  discrete = NULL,
  ngr = 1000,
  xlim = NULL,
  ylim = NULL,
  a.qqpoi = list(),
  a.ablin = list(),
  a.cipoly = list(),
  a.replin = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qq.gamViz_+3A_o">o</code></td>
<td>
<p>an object of class <code>gamViz</code>, the output of a <code>getViz()</code> call.</p>
</td></tr>
<tr><td><code id="qq.gamViz_+3A_rep">rep</code></td>
<td>
<p>how many replicate datasets to generate to simulate quantiles of the residual distribution.
Relevant only if <code>method</code> is set to <code>"simul1"</code> or <code>"simul2"</code>.</p>
</td></tr>
<tr><td><code id="qq.gamViz_+3A_level">level</code></td>
<td>
<p>the level of the confidence intervals (e.g. 0.9 means 90% intervals).</p>
</td></tr>
<tr><td><code id="qq.gamViz_+3A_method">method</code></td>
<td>
<p>the method used to calculate the QQ-plot and, possibly, the confidence intervals. If set
to (<code>"tunif"</code>) <code>"tnormal"</code> the residuals are transformed to (uniform) normal, for which
analytic expression for the confidence intervals are available. If set to <code>"simul1"</code> or
<code>"simul2"</code> the theoretical QQ-line is constructed by simulating residuals from the model.
Method <code>"simul2"</code> does not produce confidence intervals. If set to <code>"normal"</code> no simulation
or transformation is performed, and a simple normal QQ-plot is produced. If set to <code>"auto"</code> the
method used to produce the QQ-plot is determined automatically.</p>
</td></tr>
<tr><td><code id="qq.gamViz_+3A_type">type</code></td>
<td>
<p>the type of residuals to be used. See <a href="#topic+residuals.gamViz">residuals.gamViz</a>.</p>
</td></tr>
<tr><td><code id="qq.gamViz_+3A_ci">CI</code></td>
<td>
<p>the type of confidence intervals to be plotted. If set to <code>"none"</code> they are not added, if
set to <code>"normal"</code> they will be based on the assumption that the theoretical quantile
distribution is Gaussian and if set to <code>"quantile"</code> they will be sample quantiles of simulated
responses from the model.</p>
</td></tr>
<tr><td><code id="qq.gamViz_+3A_worm">worm</code></td>
<td>
<p>if <code>TRUE</code> a worm-plot (a de-trended QQ-plot) is plotted.</p>
</td></tr>
<tr><td><code id="qq.gamViz_+3A_showreps">showReps</code></td>
<td>
<p>if <code>TRUE</code> all the QQ-lines corresponding to the simulated (model-based) QQ-plots.</p>
</td></tr>
<tr><td><code id="qq.gamViz_+3A_sortfun">sortFun</code></td>
<td>
<p>the function to be used for sorting the residuals. If left to <code>NULL</code> it will be set to
<code>function(.x) sort(.x, method = "quick")</code> internally.</p>
</td></tr>
<tr><td><code id="qq.gamViz_+3A_discrete">discrete</code></td>
<td>
<p>if <code>TRUE</code> the QQ-plot is discretized into <code>ngr</code> bins before plotting,
in order to save plotting time (when the number of observations is large). If left
to <code>NULL</code>, the discretization is used if there are more than 10^4 observations.</p>
</td></tr>
<tr><td><code id="qq.gamViz_+3A_ngr">ngr</code></td>
<td>
<p>number of bins to be used in the discretization.</p>
</td></tr>
<tr><td><code id="qq.gamViz_+3A_xlim">xlim</code></td>
<td>
<p>if supplied then this pair of numbers are used as the x limits for the plot.</p>
</td></tr>
<tr><td><code id="qq.gamViz_+3A_ylim">ylim</code></td>
<td>
<p>if supplied then this pair of numbers are used as the y limits for the plot.</p>
</td></tr>
<tr><td><code id="qq.gamViz_+3A_a.qqpoi">a.qqpoi</code></td>
<td>
<p>list of arguments to be passed to <code>ggplot2::geom_point</code>, which plots the main QQ-plot.</p>
</td></tr>
<tr><td><code id="qq.gamViz_+3A_a.ablin">a.ablin</code></td>
<td>
<p>list of arguments to be passed to <code>ggplot2::geom_abline</code>, which adds the reference line.</p>
</td></tr>
<tr><td><code id="qq.gamViz_+3A_a.cipoly">a.cipoly</code></td>
<td>
<p>list of arguments to be passed to <code>ggplot2::geom_polygon</code>, which add the confidence intervals.</p>
</td></tr>
<tr><td><code id="qq.gamViz_+3A_a.replin">a.replin</code></td>
<td>
<p>list of arguments to be passed to <code>ggplot2::geom_line</code>, which adds a line for each simulated
QQ-plot.</p>
</td></tr>
<tr><td><code id="qq.gamViz_+3A_...">...</code></td>
<td>
<p>currently unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Here <code>method = "simul1"</code> corresponds to the algorithm described in section 2.1 of Augustin et al. (2012), which
involves direct simulations of residuals from the models. This requires <code>o$family$rd</code> to be defined.
Setting <code>method = "simul2"</code> results in a cheaper method, described in section 2.2 of Augustin et al. (2012),
which requires <code>o$family$qf</code> to be defined.
</p>


<h3>Value</h3>

<p>An object of class <code>c("qqGam", "plotSmooth", "gg")</code>.
</p>


<h3>References</h3>

<p>Augustin, N.H., Sauleau, E.A. and Wood, S.N., 2012. On quantile quantile plots for generalized linear models.
Computational Statistics &amp; Data Analysis, 56(8), pp.2404-2409.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>######## Example: simulate binomial data
library(mgcViz)
set.seed(0)
n.samp &lt;- 400
dat &lt;- gamSim(1,n = n.samp, dist = "binary", scale = .33)
p &lt;- binomial()$linkinv(dat$f) ## binomial p
n &lt;- sample(c(1, 3), n.samp, replace = TRUE) ## binomial n
dat$y &lt;- rbinom(n, n, p)
dat$n &lt;- n
lr.fit &lt;- gam(y/n ~ s(x0) + s(x1) + s(x2) + s(x3)
              , family = binomial, data = dat,
              weights = n, method = "REML")
lr.fit &lt;- getViz(lr.fit)

# Quick QQ-plot of deviance residuals
qq(lr.fit, method = "simul2")

# Same, but changing points share and type of reference list
qq(lr.fit, method = "simul2", 
       a.qqpoi = list("shape" = 1), a.ablin = list("linetype" = 2))

# Simulation based QQ-plot with reference bands 
qq(lr.fit, rep = 100, level = .9, CI = "quantile")

# Simulation based QQ-plot, Pearson resids, all simulations lines shown 
qq(lr.fit, rep = 100, CI = "none", showReps = TRUE, type = "pearson", 
       a.qqpoi = list(shape=19, size = 0.5))

### Now fit the wrong model and check
pif &lt;- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3)
           , family = poisson, data = dat, method = "REML")
pif &lt;- getViz(pif)

qq(pif, method = "simul2")

qq(pif, rep = 100, level = .9, CI = "quantile")

qq(pif, rep = 100, type = "pearson", CI = "none", showReps = TRUE, 
               a.qqpoi = list(shape=19, size = 0.5))

######## Example: binary data model violation so gross that you see a problem 
######## on the QQ plot
y &lt;- c(rep(1, 10), rep(0, 20), rep(1, 40), rep(0, 10), rep(1, 40), rep(0, 40))
x &lt;- 1:160
b &lt;- glm(y ~ x, family = binomial)
class(b) &lt;- c("gamViz", class(b)) # Tricking qq.gamViz to use it on a glm

# Note that the next two are not necessarily similar under gross 
# model violation...
qq(b, method = "simul2")
qq(b, rep = 50, CI = "none", showReps = TRUE)

### alternative model
b &lt;- gam(y ~ s(x, k = 5), family = binomial, method = "ML")
b &lt;- getViz(b)

qq(b, method = "simul2")
qq(b, rep = 50, showReps = TRUE, CI = "none", shape = 19)

## Not run: 
########  "Big Data" example: 
set.seed(0)
n.samp &lt;- 50000
dat &lt;- gamSim(1,n=n.samp,dist="binary",scale=.33)
p &lt;- binomial()$linkinv(dat$f) ## binomial p
n &lt;- sample(c(1,3),n.samp,replace=TRUE) ## binomial n
dat$y &lt;- rbinom(n,n,p)
dat$n &lt;- n
lr.fit &lt;- bam(y/n ~ s(x0) + s(x1) + s(x2) + s(x3)
              , family = binomial, data = dat,
              weights = n, method = "fREML", discrete = TRUE)
lr.fit &lt;- getViz(lr.fit)

# Turning discretization off (on by default for large datasets).
set.seed(414) # Setting the seed because qq.gamViz is doing simulations
o &lt;- qq(lr.fit, rep = 10, method = "simul1", CI = "normal", showReps = TRUE, 
            discrete = F, a.replin = list(alpha = 0.1))
o # This might take some time!

# Using default discretization
set.seed(414)
o &lt;- qq(lr.fit, rep = 10, method = "simul1", CI = "normal", showReps = TRUE, 
            a.replin = list(alpha = 0.1))
o # Much faster plotting!

# Very coarse discretization
set.seed(414)
o &lt;- qq(lr.fit, rep = 10, method = "simul1", CI = "normal", showReps = TRUE,
            ngr = 1e2, a.replin = list(alpha = 0.1), a.qqpoi = list(shape = 19))
o 

# We can also zoom in at no extra costs (most work already done by qq.gamViz)
zoom(o, xlim = c(-0.25, 0.25), showReps = TRUE, discrete = TRUE, a.replin = list(alpha = 0.2))

## End(Not run)

</code></pre>

<hr>
<h2 id='qqplots'>Quantile-Quantile Plots</h2><span id='topic+qqplots'></span><span id='topic+qqnorm'></span><span id='topic+qqplot'></span><span id='topic+qqline'></span>

<h3>Description</h3>

<p>This is a re-write of the QQ-plotting functions provided by <code>stats</code>, using the
<code>ggplot2</code> library.
<code>qqnorm</code> is a generic function the default method of which produces a normal
QQ plot of the values in y. <code>qqline</code> adds a line to a “theoretical”, by default normal,
quantile-quantile plot which passes through the <code>probs</code> quantiles, by default the
first and third quartiles. <code>qqplot</code> produces a QQ plot of two datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qqnorm(
  y,
  ylim,
  main = "Normal Q-Q Plot",
  xlab = "Theoretical Quantiles",
  ylab = "Sample Quantiles",
  datax = FALSE
)

qqplot(
  x,
  y,
  xlab = deparse(substitute(x)),
  ylab = deparse(substitute(y)),
  main = "Q-Q Plot"
)

qqline(
  y,
  datax = FALSE,
  distribution = qnorm,
  probs = c(0.25, 0.75),
  qtype = 7,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qqplots_+3A_y">y</code></td>
<td>
<p>The second or only data sample.</p>
</td></tr>
<tr><td><code id="qqplots_+3A_ylim">ylim</code>, <code id="qqplots_+3A_...">...</code></td>
<td>
<p>Graphical parameters.</p>
</td></tr>
<tr><td><code id="qqplots_+3A_main">main</code>, <code id="qqplots_+3A_xlab">xlab</code>, <code id="qqplots_+3A_ylab">ylab</code></td>
<td>
<p>Plot labels. The xlab and ylab refer to the y and x axes
respectively if datax = TRUE.</p>
</td></tr>
<tr><td><code id="qqplots_+3A_datax">datax</code></td>
<td>
<p>Logical. Should data values be on the x-axis ?</p>
</td></tr>
<tr><td><code id="qqplots_+3A_x">x</code></td>
<td>
<p>The first sample for <code>qqplot</code>.</p>
</td></tr>
<tr><td><code id="qqplots_+3A_distribution">distribution</code></td>
<td>
<p>quantile function for reference theoretical distribution.</p>
</td></tr>
<tr><td><code id="qqplots_+3A_probs">probs</code></td>
<td>
<p>numeric vector of length two, representing probabilities.
Corresponding quantile pairs define the line drawn.</p>
</td></tr>
<tr><td><code id="qqplots_+3A_qtype">qtype</code></td>
<td>
<p>the type of quantile computation used in <a href="stats.html#topic+quantile">quantile</a>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Help file is mainly from <code>stats::qqnorm</code> since this is a rewrite of <code>stats::qqplot</code>,
<code>stats::qqline</code> and <code>stats::qqnorm</code> using the ggplot2 library.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mgcViz)
y &lt;- rt(500, df = 5)

# Compare new and old version of qqnorm
stats::qqnorm(y)
qqnorm(y)

# Compare new and old version of qqplot
x &lt;- rt(200, df = 5)
y &lt;- rt(300, df = 5)
stats::qqplot(x, y)
qqplot(x, y)
# add a qqline()
ggplot2::last_plot() + qqline(y = rt(500, df = 4.8), col = "green") 

## "QQ-Chisquare" : --------------------------
y &lt;- rchisq(500, df = 3)
## Q-Q plot for Chi^2 data against true theoretical distribution:
x &lt;- qchisq(ppoints(500), df = 3)
stats::qqplot(qchisq(ppoints(500), df = 3), rchisq(500, df = 3),
      main = expression("Q-Q plot for" ~~ {chi^2}[nu == 3]))
qqplot(qchisq(ppoints(500), df = 3), rchisq(500, df = 3),
      main = expression("Q-Q plot for" ~~ {chi^2}[nu == 3])) + theme_bw()
</code></pre>

<hr>
<h2 id='residuals.gamViz'>Generalized Additive Model residuals</h2><span id='topic+residuals.gamViz'></span>

<h3>Description</h3>

<p>Extension of <code>mgcv::residuals.gam</code>. Returns residuals for a fitted GAM model object.
Pearson, deviance, working and response residuals are available as in the method from
<code>mgcv</code>, but this version also provides residual types &quot;tunif&quot; and &quot;tnormal&quot;. The former are
obtained using the cdf of the response distribution (if available). The latter are obtained
by further transforming the uniform residuals using the quantile function (i.e. the inverse
cdf) of a standard normal variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gamViz'
residuals(object, type = "deviance", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.gamViz_+3A_object">object</code></td>
<td>
<p>an object of class <code>gamViz</code>, the output of a <code>getViz()</code> call.</p>
</td></tr>
<tr><td><code id="residuals.gamViz_+3A_type">type</code></td>
<td>
<p>the type of residuals wanted. If should be one of &quot;deviance&quot;, &quot;pearson&quot;, &quot;scaled.pearson&quot;,
&quot;working&quot;, &quot;response&quot;, &quot;tunif&quot; or &quot;tnormal&quot;. Not all are available for each family.</p>
</td></tr>
<tr><td><code id="residuals.gamViz_+3A_...">...</code></td>
<td>
<p>further arguments passed to <a href="mgcv.html#topic+residuals.gam">mgcv::residuals.gam</a>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>See also <a href="mgcv.html#topic+residuals.gam">mgcv::residuals.gam</a> for details.
</p>

<hr>
<h2 id='shine'>Generic shine function</h2><span id='topic+shine'></span>

<h3>Description</h3>

<p>Generic function for taking an object and transforming it into a <code>shiny</code> app.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shine(o, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shine_+3A_o">o</code></td>
<td>
<p>the object we want to transform into a <code>shiny</code> app.</p>
</td></tr>
<tr><td><code id="shine_+3A_...">...</code></td>
<td>
<p>arguments to be passed to methods.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>shine.qqGam
</p>

<hr>
<h2 id='shine.qqGam'>Shiny QQ-plots for GAMs</h2><span id='topic+shine.qqGam'></span>

<h3>Description</h3>

<p>This function takes the output of <a href="#topic+qq.gamViz">qq.gamViz</a> and transforms it
into an interactive shiny app.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'qqGam'
shine(o, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shine.qqGam_+3A_o">o</code></td>
<td>
<p>the output of <a href="#topic+qq.gamViz">qq.gamViz</a>.</p>
</td></tr>
<tr><td><code id="shine.qqGam_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In RStudio, this function returns a call to <code>qq.gamViz</code> that reproduces the last plot
rendered in the interactive shiny window.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

## simulate binomial data...
library(mgcv)
library(mgcViz)
set.seed(0)
n.samp &lt;- 400
dat &lt;- gamSim(1,n = n.samp, dist = "binary", scale = .33)
p &lt;- binomial()$linkinv(dat$f) ## binomial p
n &lt;- sample(c(1, 3), n.samp, replace = TRUE) ## binomial n
dat$y &lt;- rbinom(n, n, p)
dat$n &lt;- n
lr.fit &lt;- gam(y/n ~ s(x0) + s(x1) + s(x2) + s(x3)
              , family = binomial, data = dat,
              weights = n, method = "REML")
lr.fit &lt;- getViz(lr.fit)
# launch shiny gagdet
shine(qq(lr.fit))
 

## End(Not run)

</code></pre>

<hr>
<h2 id='simulate.gam'>Simulating responses from a GAM object</h2><span id='topic+simulate.gam'></span>

<h3>Description</h3>

<p>This method can be used to simulate vectors of responses from a gamObject.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gam'
simulate(
  object,
  nsim = 1,
  seed = NULL,
  method = "auto",
  newdata,
  u = NULL,
  w = NULL,
  offset = NULL,
  trans = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.gam_+3A_object">object</code></td>
<td>
<p>the output of a <code>gam()</code> or <code>bam()</code> call.</p>
</td></tr>
<tr><td><code id="simulate.gam_+3A_nsim">nsim</code></td>
<td>
<p>the number of simulated vectors of responses. A positive integer.</p>
</td></tr>
<tr><td><code id="simulate.gam_+3A_seed">seed</code></td>
<td>
<p>currently not used.</p>
</td></tr>
<tr><td><code id="simulate.gam_+3A_method">method</code></td>
<td>
<p>the method used for the simulation. If set to &quot;rd&quot; then <code>o$family$rd()</code>
will be used, if available. If set to &quot;qf&quot; then <code>o$family$qf()</code> (which is
the inverse cdf of the response distribution) will be used to transform some
uniform variates.</p>
</td></tr>
<tr><td><code id="simulate.gam_+3A_newdata">newdata</code></td>
<td>
<p>Optional new data frame or list to be passed to <a href="mgcv.html#topic+predict.gam">predict.gam</a>.</p>
</td></tr>
<tr><td><code id="simulate.gam_+3A_u">u</code></td>
<td>
<p>a matrix where each row is a vector of uniform random variables in (0, 1).
This will be used to simulate responses only if <code>method = "qf"</code>.</p>
</td></tr>
<tr><td><code id="simulate.gam_+3A_w">w</code></td>
<td>
<p>vector of prior weights to be used in the simulations. If <code>newdata==NULL</code> then
<code>w</code> is set to <code>object$prior.weights</code> otherwise it is a vector of ones.</p>
</td></tr>
<tr><td><code id="simulate.gam_+3A_offset">offset</code></td>
<td>
<p>numeric vector of offsets. For GAMs with multiple linear predictor (see eg <a href="mgcv.html#topic+gaulss">gaulss</a>) it
must be a list of vectors. NB: if <code>newdata!=NULL</code> the offsets will be assumed to be zero,
unless their are explicitly provided. If <code>newdata==NULL</code> then simulations will use the
offsets used during model fitting, and <code>offset</code> argument will be ignored.</p>
</td></tr>
<tr><td><code id="simulate.gam_+3A_trans">trans</code></td>
<td>
<p>function used to transform or summarize each vector of simulated responses.
It must take a vector as argument, but it can output a vector or a scalar.
Potentially useful for saving storage (e.g. by transforming each simulated vector
to a scalar). If left to <code>NULL</code> then <code>trans = identity</code> will be used.</p>
</td></tr>
<tr><td><code id="simulate.gam_+3A_...">...</code></td>
<td>
<p>extra arguments passed to <code>predict.gam</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix where each column is a vector of simulated responses. The number of rows
is equal to the number of responses in the fitted object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mgcViz)

set.seed(2) ## simulate some data... 
dat &lt;- gamSim(1,n=400,dist="normal",scale=2)
b &lt;- gam(y~s(x0)+s(x1)+s(x2)+s(x3),data=dat)

# Simulate three vectors of responses
matplot(simulate(b, nsim = 3), pch = 19, col = c(1, 3, 4)) 

</code></pre>

<hr>
<h2 id='sm'>Extracting a smooth effect from a GAM model</h2><span id='topic+sm'></span>

<h3>Description</h3>

<p>This function can be used to extract a smooth or random effect from an object of
class <code>gamViz</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sm(o, select)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sm_+3A_o">o</code></td>
<td>
<p>an object of class <code>gamViz</code>, the output of a <a href="#topic+getViz">getViz</a> call.</p>
</td></tr>
<tr><td><code id="sm_+3A_select">select</code></td>
<td>
<p>index of the selected smooth or random effect.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object representing a smooth effect.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+getViz">getViz</a> for examples.
</p>

<hr>
<h2 id='zoom'>Generic zooming function</h2><span id='topic+zoom'></span>

<h3>Description</h3>

<p>Generic function for zooming, mainly meant to work with graphical objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zoom(o, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zoom_+3A_o">o</code></td>
<td>
<p>the object we want to zoom into.</p>
</td></tr>
<tr><td><code id="zoom_+3A_...">...</code></td>
<td>
<p>arguments to be passed to methods.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>zoom.qqGam
</p>

<hr>
<h2 id='zoom.qqGam'>Efficiently zooming on GAM QQ-plots</h2><span id='topic+zoom.qqGam'></span>

<h3>Description</h3>

<p>This function allows to zoom into a QQ-plot produced by <a href="#topic+qq.gamViz">qq.gamViz</a>,
in a computationally efficient manner.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'qqGam'
zoom(
  o,
  xlim = NULL,
  ylim = NULL,
  discrete = NULL,
  ngr = 1000,
  adGrid = TRUE,
  CI = FALSE,
  worm = FALSE,
  showReps = FALSE,
  a.qqpoi = list(),
  a.ablin = list(),
  a.cipoly = list(),
  a.replin = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zoom.qqGam_+3A_o">o</code></td>
<td>
<p>the output of <code>mgcViz::qq.gamViz</code>.</p>
</td></tr>
<tr><td><code id="zoom.qqGam_+3A_xlim">xlim</code></td>
<td>
<p>if supplied then this pair of numbers are used as the x limits for the plot.</p>
</td></tr>
<tr><td><code id="zoom.qqGam_+3A_ylim">ylim</code></td>
<td>
<p>if supplied then this pair of numbers are used as the y limits for the plot.</p>
</td></tr>
<tr><td><code id="zoom.qqGam_+3A_discrete">discrete</code></td>
<td>
<p>if <code>TRUE</code> the QQ-plot is discretized into <code>ngr</code> bins before plotting,
in order to save plotting time (when the number of observations is large). If left
to <code>NULL</code>, the discretization is used if there are more than 10^4 observations.</p>
</td></tr>
<tr><td><code id="zoom.qqGam_+3A_ngr">ngr</code></td>
<td>
<p>number of bins to be used in the discretization.</p>
</td></tr>
<tr><td><code id="zoom.qqGam_+3A_adgrid">adGrid</code></td>
<td>
<p>if <code>TRUE</code> the discretization grid is computed using the QQ-points falling within
<code>xlim</code>. If <code>FALSE</code>, <code>zoom.qqGam</code> will compute <code>ngr</code> values using all
the QQ-points used in the original <code>qq.gamViz</code> call (but only those falling within
<code>xlim</code> and <code>ylim</code> will be plotted).</p>
</td></tr>
<tr><td><code id="zoom.qqGam_+3A_ci">CI</code></td>
<td>
<p>if <code>TRUE</code> confidence intervals are plotted.</p>
</td></tr>
<tr><td><code id="zoom.qqGam_+3A_worm">worm</code></td>
<td>
<p>if <code>TRUE</code> a worm-plot (a de-trended QQ-plot) is plotted, rather than a QQ-plot.</p>
</td></tr>
<tr><td><code id="zoom.qqGam_+3A_showreps">showReps</code></td>
<td>
<p>if <code>TRUE</code> all the QQ-lines corresponding to the simulated (model-based) QQ-plots.</p>
</td></tr>
<tr><td><code id="zoom.qqGam_+3A_a.qqpoi">a.qqpoi</code></td>
<td>
<p>list of arguments to be passed to <code>ggplot2::geom_point</code>, which plots the main QQ-plot.</p>
</td></tr>
<tr><td><code id="zoom.qqGam_+3A_a.ablin">a.ablin</code></td>
<td>
<p>list of arguments to be passed to <code>ggplot2::geom_abline</code>, which adds the reference line.</p>
</td></tr>
<tr><td><code id="zoom.qqGam_+3A_a.cipoly">a.cipoly</code></td>
<td>
<p>list of arguments to be passed to <code>ggplot2::geom_polygon</code>, which add the confidence intervals.</p>
</td></tr>
<tr><td><code id="zoom.qqGam_+3A_a.replin">a.replin</code></td>
<td>
<p>list of arguments to be passed to <code>ggplot2::geom_line</code>, which adds a line for each simulated
QQ-plot.</p>
</td></tr>
<tr><td><code id="zoom.qqGam_+3A_...">...</code></td>
<td>
<p>currently unused.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(mgcViz);
set.seed(0)
n.samp &lt;- 500
dat &lt;- gamSim(1,n=n.samp,dist="binary",scale=.33)
p &lt;- binomial()$linkinv(dat$f) ## binomial p
n &lt;- sample(c(1,3),n.samp,replace=TRUE) ## binomial n
dat$y &lt;- rbinom(n,n,p)
dat$n &lt;- n
lr.fit &lt;- bam(y/n ~ s(x0) + s(x1) + s(x2) + s(x3)
              , family = binomial, data = dat,
              weights = n, method = "REML")
lr.fit &lt;- getViz(lr.fit)

set.seed(414)
o &lt;- qq(lr.fit, rep = 50, method = "simul1", CI = "normal")
o # This is the whole qqplot

# We can zoom in along x at little extra costs (most computation already done by qq.gamViz)
zoom(o, xlim = c(0, 1), showReps = TRUE, 
     a.replin = list(alpha = 0.1), a.qqpoi =  list(shape = 19))
</code></pre>

<hr>
<h2 id='zto1'>Constructing a decreasing function from (0,1) to (0,1)</h2><span id='topic+zto1'></span>

<h3>Description</h3>

<p>This function returns a non-increasing function from (0, 1) to (0, 1).
It takes inputs o, a and m, and it returns the function
<code>f(p)={z=max(0, p-o); return(max((1-z)^a, m))}</code>. The function f(p) can be used,
for instance, for transforming p-values before plotting them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zto1(o, a, m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zto1_+3A_o">o</code>, <code id="zto1_+3A_a">a</code>, <code id="zto1_+3A_m">m</code></td>
<td>
<p>the output function's parameters, as described above.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function whose parameters o, a and m have been fixed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mgcViz)
x &lt;- seq(0, 1, by = 0.01)
plot(x, zto1(0.05, 2, 0.1)(x), ylim = c(0, 1), type = 'l')
lines(x, zto1(0.05, 1, 0.2)(x), col = 2)
lines(x, zto1(0.1, 3, 0)(x), col = 3)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
