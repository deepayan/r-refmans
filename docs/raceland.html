<!DOCTYPE html><html lang="en"><head><title>Help for package raceland</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {raceland}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#raceland-package'><p>raceland: Pattern-Based Zoneless Method for Analysis and Visualization of Racial Topography</p></a></li>
<li><a href='#calculate_densities'><p>Calculate Densities</p></a></li>
<li><a href='#calculate_metrics'><p>Calculate Metrics</p></a></li>
<li><a href='#create_densities'><p>Create Densities</p></a></li>
<li><a href='#create_grid'><p>Create a grid of square-shaped windows</p></a></li>
<li><a href='#create_realizations'><p>Create Realizations</p></a></li>
<li><a href='#plot_realization'><p>Plot a Realization</p></a></li>
<li><a href='#pop_vector'><p>An sf object</p></a></li>
<li><a href='#quantify_raceland'><p>Quantify a racial landscape</p></a></li>
<li><a href='#race_raster.tif'><p>A raster file</p></a></li>
<li><a href='#zones_to_raster'><p>Convert zones to rasters</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Pattern-Based Zoneless Method for Analysis and Visualization of
Racial Topography</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements a computational framework for a pattern-based, 
    zoneless analysis, and visualization of (ethno)racial topography 
    (Dmowska, Stepinski, and Nowosad (2020) &lt;<a href="https://doi.org/10.1016%2Fj.apgeog.2020.102239">doi:10.1016/j.apgeog.2020.102239</a>&gt;).
    It is a reimagined
    approach for analyzing residential segregation and racial diversity based on 
    the concept of 'landscape’ used in the domain of landscape ecology.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, comat (&ge; 0.9.0), RcppArmadillo</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, plotwidgets, terra, sf, Rcpp, comat</td>
</tr>
<tr>
<td>Suggests:</td>
<td>dplyr, pbapply, testthat (&ge; 2.1.0), knitr, rmarkdown, covr,
raster</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://jakubnowosad.com/raceland/">https://jakubnowosad.com/raceland/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Nowosad/raceland/issues">https://github.com/Nowosad/raceland/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-14 14:02:10 UTC; jn</td>
</tr>
<tr>
<td>Author:</td>
<td>Jakub Nowosad <a href="https://orcid.org/0000-0002-1057-3721"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Anna Dmowska [aut],
  Tomasz Stepinski [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jakub Nowosad &lt;nowosad.jakub@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-14 14:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='raceland-package'>raceland: Pattern-Based Zoneless Method for Analysis and Visualization of Racial Topography</h2><span id='topic+raceland'></span><span id='topic+raceland-package'></span>

<h3>Description</h3>

<p>Implements a computational framework for a pattern-based, zoneless analysis, and visualization of (ethno)racial topography (Dmowska, Stepinski, and Nowosad (2020) <a href="https://doi.org/10.1016/j.apgeog.2020.102239">doi:10.1016/j.apgeog.2020.102239</a>). It is a reimagined approach for analyzing residential segregation and racial diversity based on the concept of 'landscape’ used in the domain of landscape ecology.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Jakub Nowosad <a href="mailto:nowosad.jakub@gmail.com">nowosad.jakub@gmail.com</a> (<a href="https://orcid.org/0000-0002-1057-3721">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Anna Dmowska
</p>
</li>
<li><p> Tomasz Stepinski
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://jakubnowosad.com/raceland/">https://jakubnowosad.com/raceland/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/Nowosad/raceland/issues">https://github.com/Nowosad/raceland/issues</a>
</p>
</li></ul>


<hr>
<h2 id='calculate_densities'>Calculate Densities</h2><span id='topic+calculate_densities'></span>

<h3>Description</h3>

<p>Calculate Densities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_densities(x, y, window_size)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_densities_+3A_x">x</code></td>
<td>
<p>SpatRaster with realizations</p>
</td></tr>
<tr><td><code id="calculate_densities_+3A_y">y</code></td>
<td>
<p>SpatRaster with shares</p>
</td></tr>
<tr><td><code id="calculate_densities_+3A_window_size">window_size</code></td>
<td>
<p>size of a local window</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of data.frames
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)
race_raster = rast(system.file("extdata/race_raster.tif", package = "raceland"))
real_rasters = create_realizations(race_raster, n = 5)
plot(real_rasters)
d = raceland:::calculate_densities(real_rasters, race_raster, window_size = 10)

</code></pre>

<hr>
<h2 id='calculate_metrics'>Calculate Metrics</h2><span id='topic+calculate_metrics'></span>

<h3>Description</h3>

<p>Calculates exposure matrix and quantifies it by calculating four IT-derived metrics: entropy (ent), joint entropy (joinent), conditional entropy (condent) and mutual information (mutinf).
Entropy is associated with measuring racial diversity and mutual information is associated with measuring racial segregation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_metrics(
  x,
  w,
  neighbourhood = 4,
  fun,
  size = NULL,
  shift = NULL,
  na_action = "replace",
  base = "log2",
  ordered = TRUE,
  threshold = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_metrics_+3A_x">x</code></td>
<td>
<p>SpatRaster with realizations</p>
</td></tr>
<tr><td><code id="calculate_metrics_+3A_w">w</code></td>
<td>
<p>SpatRaster with local densities</p>
</td></tr>
<tr><td><code id="calculate_metrics_+3A_neighbourhood">neighbourhood</code></td>
<td>
<p>The number of directions in which cell adjacencies are considered as neighbours: <code>4</code> (rook's case), <code>8</code> (queen's case). The default is <code>4</code>.</p>
</td></tr>
<tr><td><code id="calculate_metrics_+3A_fun">fun</code></td>
<td>
<p>Function to calculate values from adjacent cells to contribute to exposure matrix, <code>"mean"</code> - calculate average values of local population densities from adjacent cells, <code>"geometric_mean"</code> - calculate geometric mean values of local population densities from adjacent cells, or <code>"focal"</code> assign value from the focal cell</p>
</td></tr>
<tr><td><code id="calculate_metrics_+3A_size">size</code></td>
<td>
<p>Expressed in the numbers of cells, is a length of the side of a square-shaped block of cells. It defines the extent of a local pattern. If <code>size=NULL</code> calculations are performed for a whole area</p>
</td></tr>
<tr><td><code id="calculate_metrics_+3A_shift">shift</code></td>
<td>
<p>Defines the shift between adjacent squares of cells along with the N-S and W-E directions. It describes the density (resolution) of the output grid. The resolution of the output map will be reduced to the original resolution multiplied by the shift. If shift=size the input map will be divided into a grid of non-overlapping square windows. Each square window defines the extent of a local pattern. If shift &lt; size - results in the grid of overlapping square windows.</p>
</td></tr>
<tr><td><code id="calculate_metrics_+3A_na_action">na_action</code></td>
<td>
<p>Decides on how to behave in the presence of missing values in <code>w</code>. Possible options are <code>"replace"</code>, <code>"omit"</code>, <code>"keep"</code>. The default, <code>"replace"</code>, replaces missing values with 0, <code>"omit"</code> does not use cells with missing values, and <code>"keep"</code> keeps missing values.</p>
</td></tr>
<tr><td><code id="calculate_metrics_+3A_base">base</code></td>
<td>
<p>The unit in which entropy is measured. The default is &quot;log2&quot;, which compute entropy in &quot;bits&quot;. <code>"log"</code> and <code>"log10"</code> can be also used</p>
</td></tr>
<tr><td><code id="calculate_metrics_+3A_ordered">ordered</code></td>
<td>
<p>The type of pairs considered. Either ordered (<code>TRUE</code>) or unordered (<code>FALSE</code>). The default is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="calculate_metrics_+3A_threshold">threshold</code></td>
<td>
<p>The share of NA cells to allow metrics calculation in a square-shaped window</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)
race_raster = rast(system.file("extdata/race_raster.tif", package = "raceland"))
x = create_realizations(race_raster, n = 5)
w = create_densities(x, race_raster, window_size = 10)

#1
df = calculate_metrics(x, w, neighbourhood = 4, fun = "mean")

#2
df2 = calculate_metrics(x, w, neighbourhood = 4, fun = "mean", size = 10, threshold = 0.5)
my_grid = create_grid(x, size = 10)

df3 = dplyr::filter(df2, realization == 2)
result = dplyr::left_join(my_grid, df2, by = c("row", "col"))
plot(result)
</code></pre>

<hr>
<h2 id='create_densities'>Create Densities</h2><span id='topic+create_densities'></span>

<h3>Description</h3>

<p>Calculate local densities of subpopulations (race-specific local densities)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_densities(x, y, window_size)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_densities_+3A_x">x</code></td>
<td>
<p>SpatRaster with realizations</p>
</td></tr>
<tr><td><code id="create_densities_+3A_y">y</code></td>
<td>
<p>SpatRaster with shares of subpopulations</p>
</td></tr>
<tr><td><code id="create_densities_+3A_window_size">window_size</code></td>
<td>
<p>Size, expressed in the number of cells, of a square-shaped local window for which local densities will be calculated; it is recommended to use the small window_size, i.e., 10</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a SpatRaster containing n local densities. Local density layer is calculated for each realization
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)
race_raster = rast(system.file("extdata/race_raster.tif", package = "raceland"))
real_rasters = create_realizations(race_raster, n = 5)
plot(real_rasters)
dens_raster = create_densities(real_rasters, race_raster, window_size = 10)
dens_raster
plot(dens_raster)

</code></pre>

<hr>
<h2 id='create_grid'>Create a grid of square-shaped windows</h2><span id='topic+create_grid'></span>

<h3>Description</h3>

<p>Create a grid of square-shaped windows
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_grid(x, size, shift = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_grid_+3A_x">x</code></td>
<td>
<p>A SpatRaster</p>
</td></tr>
<tr><td><code id="create_grid_+3A_size">size</code></td>
<td>
<p>Expressed in the numbers of cells, is a length of the side of a square-shaped block of cells. It defines the extent of a local pattern. If <code>size=NULL</code> calculations are perfomed for the whole area</p>
</td></tr>
<tr><td><code id="create_grid_+3A_shift">shift</code></td>
<td>
<p>Defines the shift between adjacent squares of cells along with the N-S and W-E directions. It describes the density (resolution) of the output grid. The resolution of the output map will be reduced to the original resolution multiplied by the shift. If shift=size the input map will be divided into a grid of non-overlapping square windows. Each square window defines the extent of a local pattern. If shift &lt; size - results in the grid of overlapping square windows.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An sf polygon object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)
race_raster = rast(system.file("extdata/race_raster.tif", package = "raceland"))
x = create_realizations(race_raster, 1)
y = create_grid(x, size = 10)
y
</code></pre>

<hr>
<h2 id='create_realizations'>Create Realizations</h2><span id='topic+create_realizations'></span>

<h3>Description</h3>

<p>It constructs a high-resolution grid (a racial landscape) in which each cell contains only inhabitants of a single race.
Realization is constructed based on race-specific grids. Racial composition at each cell is translated to probabilities of drawing a person of a specific race from a cell.
Thus, the race label of a cell is a random variable. To obtain a stochastic realization of racial landscape, we use the cell's race probabilities and a random number generator to randomly assign specific race label to each cell (Monte Carlo procedure).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_realizations(x, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_realizations_+3A_x">x</code></td>
<td>
<p>SpatRaster with race-specific population densities assign to each cell</p>
</td></tr>
<tr><td><code id="create_realizations_+3A_n">n</code></td>
<td>
<p>A number of realizations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A SpatRaster object containing n realizations. Single race label in a racial landscape is assigned based on the order of race-specific grids in SpatRaster with input data (For example, the <code>race_raster</code> object has five layers named: asian, black, hispanic, other, white. The race labels in racial landscape raster will be 1 - asian, 2- black, 3 - hispanic, 4 - other, 5 - white).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)
race_raster = rast(system.file("extdata/race_raster.tif", package = "raceland"))
real = create_realizations(race_raster, 10)
plot(real)

</code></pre>

<hr>
<h2 id='plot_realization'>Plot a Realization</h2><span id='topic+plot_realization'></span>

<h3>Description</h3>

<p>Displays realization taking into account also subpopulation density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_realization(x, y, hex, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_realization_+3A_x">x</code></td>
<td>
<p>A SpatRaster with one layer.
Each value should correspond to a layer in <code>y</code>.</p>
</td></tr>
<tr><td><code id="plot_realization_+3A_y">y</code></td>
<td>
<p>A SpatRaster with race-specific population densities</p>
</td></tr>
<tr><td><code id="plot_realization_+3A_hex">hex</code></td>
<td>
<p>A character vector with colors specified in hexadecimal format.
Each color should correspond to a layer in <code>y</code> and value in <code>x</code>.</p>
</td></tr>
<tr><td><code id="plot_realization_+3A_...">...</code></td>
<td>
<p>Additional arguments as for <code><a href="terra.html#topic+plotRGB">terra::plotRGB()</a></code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)
race_raster = rast(system.file("extdata/race_raster.tif", package = "raceland"))
hex_colors = c("#F16667", "#6EBE44", "#7E69AF", "#C77213","#F8DF1D")
realization = create_realizations(race_raster, 1)
plot(race_raster)
plot(realization)

plot_realization(realization, race_raster, hex = hex_colors)
</code></pre>

<hr>
<h2 id='pop_vector'>An sf object</h2><span id='topic+pop_vector'></span>

<h3>Description</h3>

<p>It is an sf POLYGON object with census block-level data. It consists of 7 variables: GISJOIN - block ID, ASIAN, BLACK, HISPANIC, OTHER, WHITE - number of people of given race/ethnicity in each block
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pop_vector
</code></pre>


<h3>Format</h3>

<p>An sf object
</p>

<hr>
<h2 id='quantify_raceland'>Quantify a racial landscape</h2><span id='topic+quantify_raceland'></span>

<h3>Description</h3>

<p>This function is a wrapper of several steps (functions) implemented in the raceland package: <code>create_realizations()</code>, <code>create_densities()</code>, <code>calculate_metrics()</code>, and <code>create_grid()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantify_raceland(
  x,
  n,
  window_size,
  neighbourhood = 4,
  fun,
  size = NULL,
  na_action = "replace",
  base = "log2",
  ordered = TRUE,
  threshold = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quantify_raceland_+3A_x">x</code></td>
<td>
<p>SpatRaster with race-specific population densities assign to each cell</p>
</td></tr>
<tr><td><code id="quantify_raceland_+3A_n">n</code></td>
<td>
<p>A number of realizations</p>
</td></tr>
<tr><td><code id="quantify_raceland_+3A_window_size">window_size</code></td>
<td>
<p>Size, expressed in the number of cells, of a square-shaped local window for which local densities will be calculated; it is recommended to use the small window_size, i.e., 10</p>
</td></tr>
<tr><td><code id="quantify_raceland_+3A_neighbourhood">neighbourhood</code></td>
<td>
<p>The number of directions in which cell adjacencies are considered as neighbours: <code>4</code> (rook's case), <code>8</code> (queen's case). The default is <code>4</code>.</p>
</td></tr>
<tr><td><code id="quantify_raceland_+3A_fun">fun</code></td>
<td>
<p>Function to calculate values from adjacent cells to contribute to exposure matrix, <code>"mean"</code> - calculate average values of local population densities from adjacent cells, <code>"geometric_mean"</code> - calculate geometric mean values of local population densities from adjacent cells, or <code>"focal"</code> assign value from the focal cell</p>
</td></tr>
<tr><td><code id="quantify_raceland_+3A_size">size</code></td>
<td>
<p>Expressed in the numbers of cells, is a length of the side of a square-shaped block of cells. It defines the extent of a local pattern. If <code>size=NULL</code> calculations are performed for a whole area</p>
</td></tr>
<tr><td><code id="quantify_raceland_+3A_na_action">na_action</code></td>
<td>
<p>Decides on how to behave in the presence of missing values in <code>w</code>. Possible options are <code>"replace"</code>, <code>"omit"</code>, <code>"keep"</code>. The default, <code>"replace"</code>, replaces missing values with 0, <code>"omit"</code> does not use cells with missing values, and <code>"keep"</code> keeps missing values.</p>
</td></tr>
<tr><td><code id="quantify_raceland_+3A_base">base</code></td>
<td>
<p>The unit in which entropy is measured. The default is &quot;log2&quot;, which compute entropy in &quot;bits&quot;. <code>"log"</code> and <code>"log10"</code> can be also used</p>
</td></tr>
<tr><td><code id="quantify_raceland_+3A_ordered">ordered</code></td>
<td>
<p>The type of pairs considered. Either ordered (<code>TRUE</code>) or unordered (<code>FALSE</code>). The default is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="quantify_raceland_+3A_threshold">threshold</code></td>
<td>
<p>The share of NA cells to allow metrics calculation in a square-shaped window</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An sf polygon object with five columns - <code>row</code> and <code>col</code> allowing for identification of each square polygon, <code>ent</code> - entropy measuring racial diversity, <code>mutinf</code> - mutual information, which is associated with measuring racial segregation, and <code>geometry</code> containing spatial geometries.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)
race_raster = rast(system.file("extdata/race_raster.tif", package = "raceland"))
rl = quantify_raceland(race_raster, n = 10, window_size = 10,
 neighbourhood = 4, fun = "mean", size = 20)
</code></pre>

<hr>
<h2 id='race_raster.tif'>A raster file</h2><span id='topic+race_raster.tif'></span>

<h3>Description</h3>

<p>A raster file covering an area of 60x60 cells. The raster file contains 5 layers - a high resolution (30m) race-specific grids with values of subpopulation densities for Asian, Black, Hispanic, other and Whites.
<code>system.file("extdata/race_raster.tif", package = "raceland")</code>
</p>


<h3>Format</h3>

<p>A raster file
</p>

<hr>
<h2 id='zones_to_raster'>Convert zones to rasters</h2><span id='topic+zones_to_raster'></span>

<h3>Description</h3>

<p>Convert zones to rasters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zones_to_raster(v, resolution, variables, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zones_to_raster_+3A_v">v</code></td>
<td>
<p>An sf object (POLYGON or MULTIPOLYGON)</p>
</td></tr>
<tr><td><code id="zones_to_raster_+3A_resolution">resolution</code></td>
<td>
<p>A numeric vector of length 1 or 2 to set the resolution</p>
</td></tr>
<tr><td><code id="zones_to_raster_+3A_variables">variables</code></td>
<td>
<p>A character vector with columns names from <code>v</code>.
The values from these columns will be (1) rasterized and (2) recalculated to densities.
Each column will be represented as an layer in the output RasterStack</p>
</td></tr>
<tr><td><code id="zones_to_raster_+3A_...">...</code></td>
<td>
<p>Additional arguments as for <code><a href="terra.html#topic+rasterize">terra::rasterize()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a SpatRaster
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
library(terra)
plot(pop_vector)
popdens_raster = zones_to_raster(pop_vector, resolution = 30,
                                 variables = c("ASIAN", "BLACK", "HISPANIC", "OTHER", "WHITE"))
plot(popdens_raster)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
