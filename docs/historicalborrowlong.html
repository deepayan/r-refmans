<!DOCTYPE html><html lang="en-US"><head><title>Help for package historicalborrowlong</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {historicalborrowlong}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#historicalborrowlong-package'><p>historicalborrowlong: Bayesian longitudinal historical borrowing models</p>
for clinical studies.</a></li>
<li><a href='#hbl_convergence'><p>Check convergence diagnostics</p></a></li>
<li><a href='#hbl_data'><p>Standardize data</p></a></li>
<li><a href='#hbl_ess'><p>Effective sample size (ESS)</p></a></li>
<li><a href='#hbl_mcmc_hierarchical'><p>Longitudinal hierarchical MCMC</p></a></li>
<li><a href='#hbl_mcmc_independent'><p>Longitudinal independent MCMC</p></a></li>
<li><a href='#hbl_mcmc_pool'><p>Longitudinal pooled MCMC</p></a></li>
<li><a href='#hbl_mcmc_sge'><p>Run all MCMCs on a Sun Grid Engine (SGE) cluster.</p></a></li>
<li><a href='#hbl_metrics'><p>Legacy function to compute superseded borrowing metrics</p></a></li>
<li><a href='#hbl_plot_borrow'><p>Plot the hierarchical model response</p>
against the benchmark models.</a></li>
<li><a href='#hbl_plot_group'><p>Plot the groups of the hierarchical model</p>
and its benchmark models.</a></li>
<li><a href='#hbl_plot_tau'><p>Plot tau</p></a></li>
<li><a href='#hbl_s_tau'><p>Superseded: suggest a value of s_tau</p></a></li>
<li><a href='#hbl_sim_hierarchical'><p>Non-longitudinal hierarchical simulations.</p></a></li>
<li><a href='#hbl_sim_independent'><p>Longitudinal independent simulations.</p></a></li>
<li><a href='#hbl_sim_pool'><p>Longitudinal pooled simulations.</p></a></li>
<li><a href='#hbl_summary'><p>Model summary</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Longitudinal Bayesian Historical Borrowing Models</td>
</tr>
<tr>
<td>Description:</td>
<td>Historical borrowing in clinical trials can improve
  precision and operating characteristics. This package supports
  a longitudinal hierarchical model to borrow historical
  control data from other studies to better characterize the
  control response of the current study. It also quantifies
  the amount of borrowing through longitudinal benchmark models (independent
  and pooled). The hierarchical model approach to historical borrowing
  is discussed by Viele et al. (2013) &lt;<a href="https://doi.org/10.1002%2Fpst.1589">doi:10.1002/pst.1589</a>&gt;.</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://wlandau.github.io/historicalborrowlong/">https://wlandau.github.io/historicalborrowlong/</a>,
<a href="https://github.com/wlandau/historicalborrowlong">https://github.com/wlandau/historicalborrowlong</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/wlandau/historicalborrowlong/issues">https://github.com/wlandau/historicalborrowlong/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>clustermq, dplyr, ggplot2, MASS, Matrix, methods, posterior,
Rcpp, RcppParallel, rlang, rstan (&ge; 2.26.0), rstantools,
stats, tibble, tidyr, tidyselect, trialr, utils, withr, zoo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, markdown, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>BH, Rcpp, RcppEigen, RcppParallel, rstan (&ge; 2.26.0),
StanHeaders (&ge; 2.26.0)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-25 16:07:38 UTC; c240390</td>
</tr>
<tr>
<td>Author:</td>
<td>William Michael Landau
    <a href="https://orcid.org/0000-0003-1878-3253"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Albert Man [rev],
  Eli Lilly and Company [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>William Michael Landau &lt;will.landau.oss@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-25 17:40:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='historicalborrowlong-package'>historicalborrowlong: Bayesian longitudinal historical borrowing models
for clinical studies.</h2><span id='topic+historicalborrowlong-package'></span>

<h3>Description</h3>

<p>Bayesian longitudinal historical borrowing models for
clinical studies.
</p>

<hr>
<h2 id='hbl_convergence'>Check convergence diagnostics</h2><span id='topic+hbl_convergence'></span>

<h3>Description</h3>

<p>Check the convergence diagnostics on a model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hbl_convergence(mcmc)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hbl_convergence_+3A_mcmc">mcmc</code></td>
<td>
<p>A wide data frame of posterior samples returned by
<code><a href="#topic+hbl_mcmc_hierarchical">hbl_mcmc_hierarchical()</a></code> or similar MCMC function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of summarized convergence diagnostics.
<code>max_rhat</code> is the maximum univariate Gelman/Rubin potential scale
reduction factor over all the parameters of the model,
<code>min_ess_bulk</code> is the minimum bulk effective sample size over the
parameters, and <code>min_ess_tail</code> is the minimum tail effective
sample size. <code>max_rhat</code> should be below 1.01, and the ESS metrics
should both be above 100 times the number of MCMC chains. If
any of these conditions are not true, the MCMC did not converge,
and it is recommended to try running the model for more saved
iterations (and if <code>max_rhat</code> is high, possibly more warmup
iterations).
</p>


<h3>See Also</h3>

<p>Other mcmc: 
<code><a href="#topic+hbl_mcmc_hierarchical">hbl_mcmc_hierarchical</a>()</code>,
<code><a href="#topic+hbl_mcmc_independent">hbl_mcmc_independent</a>()</code>,
<code><a href="#topic+hbl_mcmc_pool">hbl_mcmc_pool</a>()</code>,
<code><a href="#topic+hbl_mcmc_sge">hbl_mcmc_sge</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (!identical(Sys.getenv("HBL_TEST", unset = ""), "")) {
set.seed(0)
data &lt;- hbl_sim_pool(
  n_study = 2,
  n_group = 2,
  n_patient = 5,
  n_rep = 3
)$data
tmp &lt;- utils::capture.output(
  suppressWarnings(
    mcmc &lt;- hbl_mcmc_pool(
      data,
      chains = 1,
      warmup = 10,
      iter = 20,
      seed = 0
    )
  )
)
hbl_convergence(mcmc)
}
</code></pre>

<hr>
<h2 id='hbl_data'>Standardize data</h2><span id='topic+hbl_data'></span>

<h3>Description</h3>

<p>Standardize a tidy input dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hbl_data(
  data,
  response,
  study,
  study_reference,
  group,
  group_reference,
  patient,
  rep,
  rep_reference,
  covariates
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hbl_data_+3A_data">data</code></td>
<td>
<p>A tidy data frame or <code>tibble</code> with the data.</p>
</td></tr>
<tr><td><code id="hbl_data_+3A_response">response</code></td>
<td>
<p>Character of length 1,
name of the column in <code>data</code> with the response/outcome variable.
<code>data[[response]]</code> must be a continuous variable,
and it <em>should</em> be the change from baseline of a
clinical endpoint of interest, as opposed to just
the raw response. Treatment differences
are computed directly from this scale, please supply
change from baseline unless you are absolutely certain
that treatment differences computed directly from
this quantity are clinically meaningful.</p>
</td></tr>
<tr><td><code id="hbl_data_+3A_study">study</code></td>
<td>
<p>Character of length 1,
name of the column in <code>data</code> with the study ID.</p>
</td></tr>
<tr><td><code id="hbl_data_+3A_study_reference">study_reference</code></td>
<td>
<p>Atomic of length 1,
element of the <code>study</code> column that indicates
the current study.
(The other studies are historical studies.)</p>
</td></tr>
<tr><td><code id="hbl_data_+3A_group">group</code></td>
<td>
<p>Character of length 1,
name of the column in <code>data</code> with the group ID.</p>
</td></tr>
<tr><td><code id="hbl_data_+3A_group_reference">group_reference</code></td>
<td>
<p>Atomic of length 1,
element of the <code>group</code> column that indicates
the control group.
(The other groups may be treatment groups.)</p>
</td></tr>
<tr><td><code id="hbl_data_+3A_patient">patient</code></td>
<td>
<p>Character of length 1,
name of the column in <code>data</code> with the patient ID.</p>
</td></tr>
<tr><td><code id="hbl_data_+3A_rep">rep</code></td>
<td>
<p>Character of length 1,
name of the column in <code>data</code> with the rep ID.</p>
</td></tr>
<tr><td><code id="hbl_data_+3A_rep_reference">rep_reference</code></td>
<td>
<p>Atomic of length 1,
element of the <code>rep</code> column that indicates
baseline, i.e. the first rep chronologically.
(The other reps may be post-baseline study visits or time points.)</p>
</td></tr>
<tr><td><code id="hbl_data_+3A_covariates">covariates</code></td>
<td>
<p>Character vector of column names
in <code>data</code> with the columns with baseline covariates.
These can be continuous, categorical, or binary.
Regardless, <code>historicalborrowlong</code> derives the appropriate
model matrix.
</p>
<p>Each baseline covariate column must truly be a <em>baseline</em> covariate:
elements must be equal for all time points within each patient
(after the steps in the &quot;Data processing&quot; section).
In other words, covariates must not be time-varying.
</p>
<p>A large number of covariates, or a large number of levels in a
categorical covariate, can severely slow down the computation.
Please consider carefully if you really need to include
such complicated baseline covariates.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Users do not normally need to call this function.
It mainly serves exposes the indexing behavior of
studies and group levels to aid in interpreting
summary tables.
</p>


<h3>Value</h3>

<p>A standardized tidy data frame with one row per patient
and the following columns:
</p>

<ul>
<li> <p><code>response</code>: continuous response/outcome variable. (Should be
change from baseline of an outcome of interest.)
</p>
</li>
<li> <p><code>study_label</code>: human-readable label of the study.
</p>
</li>
<li> <p><code>study</code>: integer study index with the max index equal to the
current study (at <code>study_reference</code>).
</p>
</li>
<li> <p><code>group_label</code>: human-readable group label (e.g. treatment arm name).
</p>
</li>
<li> <p><code>group</code>: integer group index with an index of 1 equal to the control
group (at <code>group_reference</code>).
</p>
</li>
<li> <p><code>patient_label</code>: original patient ID.
</p>
</li>
<li> <p><code>patient</code>: integer patient index.
</p>
</li>
<li> <p><code>rep_label</code>: original rep ID (e.g. time point or patient visit).
</p>
</li>
<li> <p><code>rep</code>: integer rep index.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;covariate_*&#8288;</code>: baseline covariate columns.
</p>
</li></ul>



<h3>Data processing</h3>

<p>Before running the MCMC, dataset is pre-processed.
This includes expanding the rows of the data so every rep
of every patient gets an explicit row. So if your
original data has irregular rep IDs, e.g. unscheduled
visits in a clinical trial that few patients attend,
please remove them before the analysis. Only the most
common rep IDs should be added.
</p>
<p>After expanding the rows, the function fills in missing
values for every column except the response. That includes
covariates. Missing covariate values are filled in,
first with last observation carried forward,
then with last observation carried backward.
If there are still missing values after this process,
the program throws an informative error.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(0)
data &lt;- hbl_sim_independent(n_continuous = 1, n_study = 2)$data
data &lt;- dplyr::select(
  data,
  study,
  group,
  rep,
  patient,
  response,
  tidyselect::everything()
)
data &lt;- dplyr::rename(
  data,
  change = response,
  trial = study,
  arm = group,
  subject = patient,
  visit = rep,
  cov1 = covariate_study1_continuous1,
  cov2 = covariate_study2_continuous1
)
data$trial &lt;- paste0("trial", data$trial)
data$arm &lt;- paste0("arm", data$arm)
data$subject &lt;- paste0("subject", data$subject)
data$visit &lt;- paste0("visit", data$visit)
hbl_data(
  data = data,
  response = "change",
  study = "trial",
  study_reference = "trial1",
  group = "arm",
  group_reference = "arm1",
  patient = "subject",
  rep = "visit",
  rep_reference = "visit1",
  covariates = c("cov1", "cov2")
)
</code></pre>

<hr>
<h2 id='hbl_ess'>Effective sample size (ESS)</h2><span id='topic+hbl_ess'></span>

<h3>Description</h3>

<p>Quantify borrowing with effective sample size (ESS)
as cited and explained in the methods vignette at
<a href="https://wlandau.github.io/historicalborrowlong/articles/methods.html">https://wlandau.github.io/historicalborrowlong/articles/methods.html</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hbl_ess(
  mcmc_pool,
  mcmc_hierarchical,
  data,
  response = "response",
  study = "study",
  study_reference = max(data[[study]]),
  group = "group",
  group_reference = min(data[[group]]),
  patient = "patient",
  rep = "rep",
  rep_reference = min(data[[rep]])
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hbl_ess_+3A_mcmc_pool">mcmc_pool</code></td>
<td>
<p>A fitted model from <code><a href="#topic+hbl_mcmc_pool">hbl_mcmc_pool()</a></code>.</p>
</td></tr>
<tr><td><code id="hbl_ess_+3A_mcmc_hierarchical">mcmc_hierarchical</code></td>
<td>
<p>A fitted model from <code><a href="#topic+hbl_mcmc_hierarchical">hbl_mcmc_hierarchical()</a></code>.</p>
</td></tr>
<tr><td><code id="hbl_ess_+3A_data">data</code></td>
<td>
<p>A tidy data frame or <code>tibble</code> with the data.</p>
</td></tr>
<tr><td><code id="hbl_ess_+3A_response">response</code></td>
<td>
<p>Character of length 1,
name of the column in <code>data</code> with the response/outcome variable.
<code>data[[response]]</code> must be a continuous variable,
and it <em>should</em> be the change from baseline of a
clinical endpoint of interest, as opposed to just
the raw response. Treatment differences
are computed directly from this scale, please supply
change from baseline unless you are absolutely certain
that treatment differences computed directly from
this quantity are clinically meaningful.</p>
</td></tr>
<tr><td><code id="hbl_ess_+3A_study">study</code></td>
<td>
<p>Character of length 1,
name of the column in <code>data</code> with the study ID.</p>
</td></tr>
<tr><td><code id="hbl_ess_+3A_study_reference">study_reference</code></td>
<td>
<p>Atomic of length 1,
element of the <code>study</code> column that indicates
the current study.
(The other studies are historical studies.)</p>
</td></tr>
<tr><td><code id="hbl_ess_+3A_group">group</code></td>
<td>
<p>Character of length 1,
name of the column in <code>data</code> with the group ID.</p>
</td></tr>
<tr><td><code id="hbl_ess_+3A_group_reference">group_reference</code></td>
<td>
<p>Atomic of length 1,
element of the <code>group</code> column that indicates
the control group.
(The other groups may be treatment groups.)</p>
</td></tr>
<tr><td><code id="hbl_ess_+3A_patient">patient</code></td>
<td>
<p>Character of length 1,
name of the column in <code>data</code> with the patient ID.</p>
</td></tr>
<tr><td><code id="hbl_ess_+3A_rep">rep</code></td>
<td>
<p>Character of length 1,
name of the column in <code>data</code> with the rep ID.</p>
</td></tr>
<tr><td><code id="hbl_ess_+3A_rep_reference">rep_reference</code></td>
<td>
<p>Atomic of length 1,
element of the <code>rep</code> column that indicates
baseline, i.e. the first rep chronologically.
(The other reps may be post-baseline study visits or time points.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with one row per discrete time point (&quot;rep&quot;)
and the following columns:
</p>

<ul>
<li> <p><code>v0</code>: posterior predictive variance of the control group mean of a
hypothetical new study given the pooled model.
Calculated as the mean over MCMC samples of <code>1 / sum(sigma_i ^ 2)</code>,
where each <code>sigma_i</code> is the residual standard deviation of
study <code>i</code> estimated from the pooled model.
</p>
</li>
<li> <p><code>v_tau</code>: posterior predictive variance of a hypothetical
new control group mean under the hierarchical model.
Calculated by averaging over predictive draws,
where each predictive draw is from
<code>rnorm(n = 1, mean = mu_, sd = tau_)</code> and <code>mu_</code> and <code>tau_</code> are the
<code>mu</code> and <code>tau</code> components of an MCMC sample.
</p>
</li>
<li> <p><code>n</code>: number of non-missing historical control patients.
</p>
</li>
<li> <p><code>weight</code>: strength of borrowing as a ratio of variances: <code>v0 / v_tau</code>.
</p>
</li>
<li> <p><code>ess</code>: strength of borrowing as a prior effective sample size:
<code style="white-space: pre;">&#8288;n v0 / v_tau&#8288;</code>, where <code>n</code> is the number of non-missing historical
control patients.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other summary: 
<code><a href="#topic+hbl_summary">hbl_summary</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  set.seed(0)
  data &lt;- hbl_sim_independent(n_continuous = 2)$data
  data$group &lt;- sprintf("group%s", data$group)
  data$study &lt;- sprintf("study%s", data$study)
  data$rep &lt;- sprintf("rep%s", data$rep)
  tmp &lt;- utils::capture.output(
    suppressWarnings(
      pool &lt;- hbl_mcmc_pool(
        data,
        chains = 1,
        warmup = 10,
        iter = 20,
        seed = 0
      )
    )
  )
  tmp &lt;- utils::capture.output(
    suppressWarnings(
      hierarchical &lt;- hbl_mcmc_hierarchical(
        data,
        chains = 1,
        warmup = 10,
        iter = 20,
        seed = 0
      )
    )
  )
  hbl_ess(
    mcmc_pool = pool,
    mcmc_hierarchical = hierarchical,
    data = data
  )
</code></pre>

<hr>
<h2 id='hbl_mcmc_hierarchical'>Longitudinal hierarchical MCMC</h2><span id='topic+hbl_mcmc_hierarchical'></span>

<h3>Description</h3>

<p>Run the longitudinal hierarchical model with MCMC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hbl_mcmc_hierarchical(
  data,
  response = "response",
  study = "study",
  study_reference = max(data[[study]]),
  group = "group",
  group_reference = min(data[[group]]),
  patient = "patient",
  rep = "rep",
  rep_reference = min(data[[rep]]),
  covariates = grep("^covariate", colnames(data), value = TRUE),
  constraint = FALSE,
  s_delta = 30,
  s_beta = 30,
  s_sigma = 30,
  s_lambda = 1,
  s_mu = 30,
  s_tau = 30,
  d_tau = 4,
  prior_tau = "half_t",
  covariance_current = "unstructured",
  covariance_historical = "unstructured",
  control = list(max_treedepth = 17, adapt_delta = 0.99),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hbl_mcmc_hierarchical_+3A_data">data</code></td>
<td>
<p>Tidy data frame with one row per patient per rep,
indicator columns for the response variable,
study, group, patient, rep,
and covariates. All columns must be atomic vectors
(e.g. not lists).</p>
</td></tr>
<tr><td><code id="hbl_mcmc_hierarchical_+3A_response">response</code></td>
<td>
<p>Character of length 1,
name of the column in <code>data</code> with the response/outcome variable.
<code>data[[response]]</code> must be a continuous variable,
and it <em>should</em> be the change from baseline of a
clinical endpoint of interest, as opposed to just
the raw response. Treatment differences
are computed directly from this scale, please supply
change from baseline unless you are absolutely certain
that treatment differences computed directly from
this quantity are clinically meaningful.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_hierarchical_+3A_study">study</code></td>
<td>
<p>Character of length 1,
name of the column in <code>data</code> with the study ID.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_hierarchical_+3A_study_reference">study_reference</code></td>
<td>
<p>Atomic of length 1,
element of the <code>study</code> column that indicates
the current study.
(The other studies are historical studies.)</p>
</td></tr>
<tr><td><code id="hbl_mcmc_hierarchical_+3A_group">group</code></td>
<td>
<p>Character of length 1,
name of the column in <code>data</code> with the group ID.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_hierarchical_+3A_group_reference">group_reference</code></td>
<td>
<p>Atomic of length 1,
element of the <code>group</code> column that indicates
the control group.
(The other groups may be treatment groups.)</p>
</td></tr>
<tr><td><code id="hbl_mcmc_hierarchical_+3A_patient">patient</code></td>
<td>
<p>Character of length 1,
name of the column in <code>data</code> with the patient ID.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_hierarchical_+3A_rep">rep</code></td>
<td>
<p>Character of length 1,
name of the column in <code>data</code> with the rep ID.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_hierarchical_+3A_rep_reference">rep_reference</code></td>
<td>
<p>Atomic of length 1,
element of the <code>rep</code> column that indicates
baseline, i.e. the first rep chronologically.
(The other reps may be post-baseline study visits or time points.)</p>
</td></tr>
<tr><td><code id="hbl_mcmc_hierarchical_+3A_covariates">covariates</code></td>
<td>
<p>Character vector of column names
in <code>data</code> with the columns with baseline covariates.
These can be continuous, categorical, or binary.
Regardless, <code>historicalborrowlong</code> derives the appropriate
model matrix.
</p>
<p>Each baseline covariate column must truly be a <em>baseline</em> covariate:
elements must be equal for all time points within each patient
(after the steps in the &quot;Data processing&quot; section).
In other words, covariates must not be time-varying.
</p>
<p>A large number of covariates, or a large number of levels in a
categorical covariate, can severely slow down the computation.
Please consider carefully if you really need to include
such complicated baseline covariates.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_hierarchical_+3A_constraint">constraint</code></td>
<td>
<p>Logical of length 1, whether to pool all study arms
at baseline (first rep). Appropriate when the response is the raw
response (as opposed to change from baseline) and the first rep
(i.e. time point) is prior to treatment.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_hierarchical_+3A_s_delta">s_delta</code></td>
<td>
<p>Numeric of length 1, prior standard deviation
of the study-by-group effect parameters <code>delta</code>.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_hierarchical_+3A_s_beta">s_beta</code></td>
<td>
<p>Numeric of length 1, prior standard deviation
of the fixed effects <code>beta</code>.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_hierarchical_+3A_s_sigma">s_sigma</code></td>
<td>
<p>Numeric of length 1, prior upper bound
of the residual standard deviations.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_hierarchical_+3A_s_lambda">s_lambda</code></td>
<td>
<p>shape parameter of the LKJ priors
on the unstructured correlation matrices.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_hierarchical_+3A_s_mu">s_mu</code></td>
<td>
<p>Numeric of length 1,
prior standard deviation of <code>mu</code>.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_hierarchical_+3A_s_tau">s_tau</code></td>
<td>
<p>Non-negative numeric of length 1.
If <code>prior_tau</code> is <code>"half_t"</code>, then <code>s_tau</code> is the scale parameter of
the Student t prior of <code>tau</code> and analogous to the <code>sigma</code> parameter of
the Student-t parameterization given at
<a href="https://mc-stan.org/docs/functions-reference/unbounded_continuous_distributions.html">https://mc-stan.org/docs/functions-reference/unbounded_continuous_distributions.html</a>. # nolint
If <code>prior_tau</code> is <code>"uniform"</code>, then <code>s_tau</code> is the upper bound of <code>tau</code>.
Upper bound on <code>tau</code> if <code>prior_tau</code> is <code>"uniform"</code>.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_hierarchical_+3A_d_tau">d_tau</code></td>
<td>
<p>Positive numeric of length 1. Degrees of freedom of the
Student t prior of <code>tau</code> if <code>prior_tau</code> is <code>"half_t"</code>.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_hierarchical_+3A_prior_tau">prior_tau</code></td>
<td>
<p>Character string, family of the prior of <code>tau</code>.
If <code>prior_tau</code> equals <code>"uniform"</code>, then the prior on <code>tau</code> is
a uniform prior with lower bound 0 and upper bound <code>s_tau</code>.
If <code>prior_tau</code> equals <code>"half_t"</code>, then the prior on <code>tau</code> is a
half Student-t prior with center 0, lower bound 0, scale parameter
<code>s_tau</code>, and degrees of freedom <code>d_tau</code>. The scale parameter <code>s_tau</code>
is analogous to the <code>sigma</code> parameter of
the Student-t parameterization given at
<a href="https://mc-stan.org/docs/functions-reference/unbounded_continuous_distributions.html">https://mc-stan.org/docs/functions-reference/unbounded_continuous_distributions.html</a>. # nolint</p>
</td></tr>
<tr><td><code id="hbl_mcmc_hierarchical_+3A_covariance_current">covariance_current</code></td>
<td>
<p>Character of length 1,
covariance structure of the current study.
Possible values are <code>"unstructured"</code> for fully parameterized
covariance matrices, <code>"ar1"</code> for AR(1) covariance matrices,
and <code>"diagonal"</code> for residuals independent across time within
each patient. In MCMC (e.g. <code><a href="#topic+hbl_mcmc_hierarchical">hbl_mcmc_hierarchical()</a></code>),
the covariance structure affects computational speed.
Unstructured covariance is slower than AR(1), and AR(1) is slower
than diagonal. This is particularly true for <code>covariance_historical</code>
if there are many historical studies in the data.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_hierarchical_+3A_covariance_historical">covariance_historical</code></td>
<td>
<p>Same as <code>covariance_current</code>,
but for the covariance structure of each separate historical study.
Each historical study has its own separate covariance matrix.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_hierarchical_+3A_control">control</code></td>
<td>
<p>A named <code>list</code> of parameters to control the sampler's
behavior. It defaults to <code>NULL</code> so all the default values are used.
First, the following are adaptation parameters for sampling algorithms.
These are parameters used in Stan with similar names here.
</p>

<ul>
<li> <p><code>adapt_engaged</code> (<code>logical</code>)
</p>
</li>
<li> <p><code>adapt_gamma</code> (<code>double</code>, positive, defaults to 0.05)
</p>
</li>
<li> <p><code>adapt_delta</code> (<code>double</code>, between 0 and 1, defaults to 0.8)
</p>
</li>
<li> <p><code>adapt_kappa</code> (<code>double</code>, positive, defaults to 0.75)
</p>
</li>
<li> <p><code>adapt_t0</code> (<code>double</code>, positive, defaults to 10)
</p>
</li>
<li> <p><code>adapt_init_buffer</code> (<code>integer</code>, positive, defaults to 75)
</p>
</li>
<li> <p><code>adapt_term_buffer</code> (<code>integer</code>, positive, defaults to 50)
</p>
</li>
<li> <p><code>adapt_window</code> (<code>integer</code>, positive, defaults to 25)
</p>
</li></ul>

<p>In addition, algorithm HMC (called 'static HMC' in Stan) and NUTS share the
following parameters:
</p>

<ul>
<li> <p><code>stepsize</code> (<code>double</code>, positive, defaults to 1)
Note: this controls the <em>initial</em> stepsize only, unless <code>adapt_engaged=FALSE</code>.
</p>
</li>
<li> <p><code>stepsize_jitter</code> (<code>double</code>, [0,1], defaults to 0)
</p>
</li>
<li> <p><code>metric</code> (<code>string</code>, one of &quot;unit_e&quot;, &quot;diag_e&quot;, &quot;dense_e&quot;,
defaults to &quot;diag_e&quot;)
</p>
</li></ul>

<p>For algorithm NUTS, we can also set:
</p>

<ul>
<li> <p><code>max_treedepth</code> (<code>integer</code>, positive, defaults to 10)
</p>
</li></ul>

<p>For algorithm HMC, we can also set:
</p>

<ul>
<li> <p><code>int_time</code> (<code>double</code>, positive)
</p>
</li></ul>

<p>For <code>test_grad</code> mode, the following parameters can be set:
</p>

<ul>
<li> <p><code>epsilon</code> (<code>double</code>, defaults to 1e-6)
</p>
</li>
<li> <p><code>error</code> (<code>double</code>, defaults to 1e-6)
</p>
</li></ul>

</td></tr>
<tr><td><code id="hbl_mcmc_hierarchical_+3A_...">...</code></td>
<td>
<p>Other optional parameters:
</p>

<ul>
<li> <p><code>chain_id</code> (<code>integer</code>)
</p>
</li>
<li> <p><code>init_r</code> (<code>double</code>, positive)
</p>
</li>
<li> <p><code>test_grad</code> (<code>logical</code>)
</p>
</li>
<li> <p><code>append_samples</code> (<code>logical</code>)
</p>
</li>
<li> <p><code>refresh</code>(<code>integer</code>)
</p>
</li>
<li> <p><code>save_warmup</code>(<code>logical</code>)
</p>
</li>
<li><p> deprecated: <code>enable_random_init</code>(<code>logical</code>)
</p>
</li></ul>

<p><code>chain_id</code> can be a vector to specify the chain_id for all
chains or an integer. For the former case, they should be unique.
For the latter, the sequence of integers starting from the given
<code>chain_id</code> are used for all chains.
</p>
<p><code>init_r</code> is used only for generating random initial values,
specifically when <code>init="random"</code> or not all parameters
are initialized in the user-supplied list or function. If specified,
the initial values are simulated uniformly from interval
[-<code>init_r</code>, <code>init_r</code>] rather than using the default interval
(see the manual of (cmd)Stan).
</p>
<p><code>test_grad</code> (<code>logical</code>).
If <code>test_grad=TRUE</code>, Stan will not do any sampling. Instead,
the gradient calculation is tested and printed out and the fitted
<code>stanfit</code> object is in test gradient mode.  By default, it is
<code>FALSE</code>.
</p>
<p><code>append_samples</code> (<code>logical</code>).
Only relevant if <code>sample_file</code> is specified <em>and</em> is an
existing file. In that case, setting <code>append_samples=TRUE</code> will append
the samples to the existing file rather than overwriting the contents of
the file.
</p>
<p><code>refresh</code> (<code>integer</code>) can be used to
control how often the progress of the sampling is reported (i.e.
show the progress every <code>refresh</code> iterations).
By default, <code>refresh = max(iter/10, 1)</code>.
The progress indicator is turned off if <code>refresh &lt;= 0</code>.
</p>
<p>Deprecated: <code>enable_random_init</code> (<code>logical</code>) being <code>TRUE</code>
enables specifying initial values randomly when the initial
values are not fully specified from the user.
</p>
<p><code>save_warmup</code> (<code>logical</code>) indicates whether to
save draws during the warmup phase and defaults to <code>TRUE</code>. Some
memory related problems can be avoided by setting it to <code>FALSE</code>,
but some diagnostics are more limited if the warmup draws are not
stored.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tidy data frame of parameter samples from the
posterior distribution. Columns <code>.chain</code>, <code>.iteration</code>,
and <code>.draw</code> have the meanings documented in the
<code>posterior</code> package.
</p>


<h3>Data processing</h3>

<p>Before running the MCMC, dataset is pre-processed.
This includes expanding the rows of the data so every rep
of every patient gets an explicit row. So if your
original data has irregular rep IDs, e.g. unscheduled
visits in a clinical trial that few patients attend,
please remove them before the analysis. Only the most
common rep IDs should be added.
</p>
<p>After expanding the rows, the function fills in missing
values for every column except the response. That includes
covariates. Missing covariate values are filled in,
first with last observation carried forward,
then with last observation carried backward.
If there are still missing values after this process,
the program throws an informative error.
</p>


<h3>See Also</h3>

<p>Other mcmc: 
<code><a href="#topic+hbl_convergence">hbl_convergence</a>()</code>,
<code><a href="#topic+hbl_mcmc_independent">hbl_mcmc_independent</a>()</code>,
<code><a href="#topic+hbl_mcmc_pool">hbl_mcmc_pool</a>()</code>,
<code><a href="#topic+hbl_mcmc_sge">hbl_mcmc_sge</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (!identical(Sys.getenv("HBL_TEST", unset = ""), "")) {
set.seed(0)
data &lt;- hbl_sim_hierarchical(
  n_study = 2,
  n_group = 2,
  n_patient = 5,
  n_rep = 3
)$data
tmp &lt;- utils::capture.output(
  suppressWarnings(
    mcmc &lt;- hbl_mcmc_hierarchical(
      data,
      chains = 1,
      warmup = 10,
      iter = 20,
      seed = 0
    )
  )
)
mcmc
}
</code></pre>

<hr>
<h2 id='hbl_mcmc_independent'>Longitudinal independent MCMC</h2><span id='topic+hbl_mcmc_independent'></span>

<h3>Description</h3>

<p>Run the longitudinal independent model with MCMC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hbl_mcmc_independent(
  data,
  response = "response",
  study = "study",
  study_reference = max(data[[study]]),
  group = "group",
  group_reference = min(data[[group]]),
  patient = "patient",
  rep = "rep",
  rep_reference = min(data[[rep]]),
  covariates = grep("^covariate", colnames(data), value = TRUE),
  constraint = FALSE,
  s_alpha = 30,
  s_delta = 30,
  s_beta = 30,
  s_sigma = 30,
  s_lambda = 1,
  covariance_current = "unstructured",
  covariance_historical = "unstructured",
  control = list(max_treedepth = 17, adapt_delta = 0.99),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hbl_mcmc_independent_+3A_data">data</code></td>
<td>
<p>Tidy data frame with one row per patient per rep,
indicator columns for the response variable,
study, group, patient, rep,
and covariates. All columns must be atomic vectors
(e.g. not lists).</p>
</td></tr>
<tr><td><code id="hbl_mcmc_independent_+3A_response">response</code></td>
<td>
<p>Character of length 1,
name of the column in <code>data</code> with the response/outcome variable.
<code>data[[response]]</code> must be a continuous variable,
and it <em>should</em> be the change from baseline of a
clinical endpoint of interest, as opposed to just
the raw response. Treatment differences
are computed directly from this scale, please supply
change from baseline unless you are absolutely certain
that treatment differences computed directly from
this quantity are clinically meaningful.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_independent_+3A_study">study</code></td>
<td>
<p>Character of length 1,
name of the column in <code>data</code> with the study ID.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_independent_+3A_study_reference">study_reference</code></td>
<td>
<p>Atomic of length 1,
element of the <code>study</code> column that indicates
the current study.
(The other studies are historical studies.)</p>
</td></tr>
<tr><td><code id="hbl_mcmc_independent_+3A_group">group</code></td>
<td>
<p>Character of length 1,
name of the column in <code>data</code> with the group ID.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_independent_+3A_group_reference">group_reference</code></td>
<td>
<p>Atomic of length 1,
element of the <code>group</code> column that indicates
the control group.
(The other groups may be treatment groups.)</p>
</td></tr>
<tr><td><code id="hbl_mcmc_independent_+3A_patient">patient</code></td>
<td>
<p>Character of length 1,
name of the column in <code>data</code> with the patient ID.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_independent_+3A_rep">rep</code></td>
<td>
<p>Character of length 1,
name of the column in <code>data</code> with the rep ID.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_independent_+3A_rep_reference">rep_reference</code></td>
<td>
<p>Atomic of length 1,
element of the <code>rep</code> column that indicates
baseline, i.e. the first rep chronologically.
(The other reps may be post-baseline study visits or time points.)</p>
</td></tr>
<tr><td><code id="hbl_mcmc_independent_+3A_covariates">covariates</code></td>
<td>
<p>Character vector of column names
in <code>data</code> with the columns with baseline covariates.
These can be continuous, categorical, or binary.
Regardless, <code>historicalborrowlong</code> derives the appropriate
model matrix.
</p>
<p>Each baseline covariate column must truly be a <em>baseline</em> covariate:
elements must be equal for all time points within each patient
(after the steps in the &quot;Data processing&quot; section).
In other words, covariates must not be time-varying.
</p>
<p>A large number of covariates, or a large number of levels in a
categorical covariate, can severely slow down the computation.
Please consider carefully if you really need to include
such complicated baseline covariates.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_independent_+3A_constraint">constraint</code></td>
<td>
<p>Logical of length 1, whether to pool all study arms
at baseline (first rep). Appropriate when the response is the raw
response (as opposed to change from baseline) and the first rep
(i.e. time point) is prior to treatment.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_independent_+3A_s_alpha">s_alpha</code></td>
<td>
<p>Numeric of length 1, prior standard deviation
of the study-specific control group mean parameters <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_independent_+3A_s_delta">s_delta</code></td>
<td>
<p>Numeric of length 1, prior standard deviation
of the study-by-group effect parameters <code>delta</code>.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_independent_+3A_s_beta">s_beta</code></td>
<td>
<p>Numeric of length 1, prior standard deviation
of the fixed effects <code>beta</code>.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_independent_+3A_s_sigma">s_sigma</code></td>
<td>
<p>Numeric of length 1, prior upper bound
of the residual standard deviations.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_independent_+3A_s_lambda">s_lambda</code></td>
<td>
<p>shape parameter of the LKJ priors
on the unstructured correlation matrices.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_independent_+3A_covariance_current">covariance_current</code></td>
<td>
<p>Character of length 1,
covariance structure of the current study.
Possible values are <code>"unstructured"</code> for fully parameterized
covariance matrices, <code>"ar1"</code> for AR(1) covariance matrices,
and <code>"diagonal"</code> for residuals independent across time within
each patient. In MCMC (e.g. <code><a href="#topic+hbl_mcmc_hierarchical">hbl_mcmc_hierarchical()</a></code>),
the covariance structure affects computational speed.
Unstructured covariance is slower than AR(1), and AR(1) is slower
than diagonal. This is particularly true for <code>covariance_historical</code>
if there are many historical studies in the data.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_independent_+3A_covariance_historical">covariance_historical</code></td>
<td>
<p>Same as <code>covariance_current</code>,
but for the covariance structure of each separate historical study.
Each historical study has its own separate covariance matrix.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_independent_+3A_control">control</code></td>
<td>
<p>A named <code>list</code> of parameters to control the sampler's
behavior. It defaults to <code>NULL</code> so all the default values are used.
First, the following are adaptation parameters for sampling algorithms.
These are parameters used in Stan with similar names here.
</p>

<ul>
<li> <p><code>adapt_engaged</code> (<code>logical</code>)
</p>
</li>
<li> <p><code>adapt_gamma</code> (<code>double</code>, positive, defaults to 0.05)
</p>
</li>
<li> <p><code>adapt_delta</code> (<code>double</code>, between 0 and 1, defaults to 0.8)
</p>
</li>
<li> <p><code>adapt_kappa</code> (<code>double</code>, positive, defaults to 0.75)
</p>
</li>
<li> <p><code>adapt_t0</code> (<code>double</code>, positive, defaults to 10)
</p>
</li>
<li> <p><code>adapt_init_buffer</code> (<code>integer</code>, positive, defaults to 75)
</p>
</li>
<li> <p><code>adapt_term_buffer</code> (<code>integer</code>, positive, defaults to 50)
</p>
</li>
<li> <p><code>adapt_window</code> (<code>integer</code>, positive, defaults to 25)
</p>
</li></ul>

<p>In addition, algorithm HMC (called 'static HMC' in Stan) and NUTS share the
following parameters:
</p>

<ul>
<li> <p><code>stepsize</code> (<code>double</code>, positive, defaults to 1)
Note: this controls the <em>initial</em> stepsize only, unless <code>adapt_engaged=FALSE</code>.
</p>
</li>
<li> <p><code>stepsize_jitter</code> (<code>double</code>, [0,1], defaults to 0)
</p>
</li>
<li> <p><code>metric</code> (<code>string</code>, one of &quot;unit_e&quot;, &quot;diag_e&quot;, &quot;dense_e&quot;,
defaults to &quot;diag_e&quot;)
</p>
</li></ul>

<p>For algorithm NUTS, we can also set:
</p>

<ul>
<li> <p><code>max_treedepth</code> (<code>integer</code>, positive, defaults to 10)
</p>
</li></ul>

<p>For algorithm HMC, we can also set:
</p>

<ul>
<li> <p><code>int_time</code> (<code>double</code>, positive)
</p>
</li></ul>

<p>For <code>test_grad</code> mode, the following parameters can be set:
</p>

<ul>
<li> <p><code>epsilon</code> (<code>double</code>, defaults to 1e-6)
</p>
</li>
<li> <p><code>error</code> (<code>double</code>, defaults to 1e-6)
</p>
</li></ul>

</td></tr>
<tr><td><code id="hbl_mcmc_independent_+3A_...">...</code></td>
<td>
<p>Other optional parameters:
</p>

<ul>
<li> <p><code>chain_id</code> (<code>integer</code>)
</p>
</li>
<li> <p><code>init_r</code> (<code>double</code>, positive)
</p>
</li>
<li> <p><code>test_grad</code> (<code>logical</code>)
</p>
</li>
<li> <p><code>append_samples</code> (<code>logical</code>)
</p>
</li>
<li> <p><code>refresh</code>(<code>integer</code>)
</p>
</li>
<li> <p><code>save_warmup</code>(<code>logical</code>)
</p>
</li>
<li><p> deprecated: <code>enable_random_init</code>(<code>logical</code>)
</p>
</li></ul>

<p><code>chain_id</code> can be a vector to specify the chain_id for all
chains or an integer. For the former case, they should be unique.
For the latter, the sequence of integers starting from the given
<code>chain_id</code> are used for all chains.
</p>
<p><code>init_r</code> is used only for generating random initial values,
specifically when <code>init="random"</code> or not all parameters
are initialized in the user-supplied list or function. If specified,
the initial values are simulated uniformly from interval
[-<code>init_r</code>, <code>init_r</code>] rather than using the default interval
(see the manual of (cmd)Stan).
</p>
<p><code>test_grad</code> (<code>logical</code>).
If <code>test_grad=TRUE</code>, Stan will not do any sampling. Instead,
the gradient calculation is tested and printed out and the fitted
<code>stanfit</code> object is in test gradient mode.  By default, it is
<code>FALSE</code>.
</p>
<p><code>append_samples</code> (<code>logical</code>).
Only relevant if <code>sample_file</code> is specified <em>and</em> is an
existing file. In that case, setting <code>append_samples=TRUE</code> will append
the samples to the existing file rather than overwriting the contents of
the file.
</p>
<p><code>refresh</code> (<code>integer</code>) can be used to
control how often the progress of the sampling is reported (i.e.
show the progress every <code>refresh</code> iterations).
By default, <code>refresh = max(iter/10, 1)</code>.
The progress indicator is turned off if <code>refresh &lt;= 0</code>.
</p>
<p>Deprecated: <code>enable_random_init</code> (<code>logical</code>) being <code>TRUE</code>
enables specifying initial values randomly when the initial
values are not fully specified from the user.
</p>
<p><code>save_warmup</code> (<code>logical</code>) indicates whether to
save draws during the warmup phase and defaults to <code>TRUE</code>. Some
memory related problems can be avoided by setting it to <code>FALSE</code>,
but some diagnostics are more limited if the warmup draws are not
stored.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tidy data frame of parameter samples from the
posterior distribution. Columns <code>.chain</code>, <code>.iteration</code>,
and <code>.draw</code> have the meanings documented in the
<code>posterior</code> package.
</p>


<h3>Data processing</h3>

<p>Before running the MCMC, dataset is pre-processed.
This includes expanding the rows of the data so every rep
of every patient gets an explicit row. So if your
original data has irregular rep IDs, e.g. unscheduled
visits in a clinical trial that few patients attend,
please remove them before the analysis. Only the most
common rep IDs should be added.
</p>
<p>After expanding the rows, the function fills in missing
values for every column except the response. That includes
covariates. Missing covariate values are filled in,
first with last observation carried forward,
then with last observation carried backward.
If there are still missing values after this process,
the program throws an informative error.
</p>


<h3>See Also</h3>

<p>Other mcmc: 
<code><a href="#topic+hbl_convergence">hbl_convergence</a>()</code>,
<code><a href="#topic+hbl_mcmc_hierarchical">hbl_mcmc_hierarchical</a>()</code>,
<code><a href="#topic+hbl_mcmc_pool">hbl_mcmc_pool</a>()</code>,
<code><a href="#topic+hbl_mcmc_sge">hbl_mcmc_sge</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (!identical(Sys.getenv("HBL_TEST", unset = ""), "")) {
set.seed(0)
data &lt;- hbl_sim_independent(
  n_study = 2,
  n_group = 2,
  n_patient = 5,
  n_rep = 3
)$data
tmp &lt;- utils::capture.output(
  suppressWarnings(
    mcmc &lt;- hbl_mcmc_independent(
      data,
      chains = 1,
      warmup = 10,
      iter = 20,
      seed = 0
    )
  )
)
mcmc
}
</code></pre>

<hr>
<h2 id='hbl_mcmc_pool'>Longitudinal pooled MCMC</h2><span id='topic+hbl_mcmc_pool'></span>

<h3>Description</h3>

<p>Run the longitudinal pooled model with MCMC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hbl_mcmc_pool(
  data,
  response = "response",
  study = "study",
  study_reference = max(data[[study]]),
  group = "group",
  group_reference = min(data[[group]]),
  patient = "patient",
  rep = "rep",
  rep_reference = min(data[[rep]]),
  covariates = grep("^covariate", colnames(data), value = TRUE),
  constraint = FALSE,
  s_alpha = 30,
  s_delta = 30,
  s_beta = 30,
  s_sigma = 30,
  s_lambda = 1,
  covariance_current = "unstructured",
  covariance_historical = "unstructured",
  control = list(max_treedepth = 17, adapt_delta = 0.99),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hbl_mcmc_pool_+3A_data">data</code></td>
<td>
<p>Tidy data frame with one row per patient per rep,
indicator columns for the response variable,
study, group, patient, rep,
and covariates. All columns must be atomic vectors
(e.g. not lists).</p>
</td></tr>
<tr><td><code id="hbl_mcmc_pool_+3A_response">response</code></td>
<td>
<p>Character of length 1,
name of the column in <code>data</code> with the response/outcome variable.
<code>data[[response]]</code> must be a continuous variable,
and it <em>should</em> be the change from baseline of a
clinical endpoint of interest, as opposed to just
the raw response. Treatment differences
are computed directly from this scale, please supply
change from baseline unless you are absolutely certain
that treatment differences computed directly from
this quantity are clinically meaningful.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_pool_+3A_study">study</code></td>
<td>
<p>Character of length 1,
name of the column in <code>data</code> with the study ID.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_pool_+3A_study_reference">study_reference</code></td>
<td>
<p>Atomic of length 1,
element of the <code>study</code> column that indicates
the current study.
(The other studies are historical studies.)</p>
</td></tr>
<tr><td><code id="hbl_mcmc_pool_+3A_group">group</code></td>
<td>
<p>Character of length 1,
name of the column in <code>data</code> with the group ID.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_pool_+3A_group_reference">group_reference</code></td>
<td>
<p>Atomic of length 1,
element of the <code>group</code> column that indicates
the control group.
(The other groups may be treatment groups.)</p>
</td></tr>
<tr><td><code id="hbl_mcmc_pool_+3A_patient">patient</code></td>
<td>
<p>Character of length 1,
name of the column in <code>data</code> with the patient ID.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_pool_+3A_rep">rep</code></td>
<td>
<p>Character of length 1,
name of the column in <code>data</code> with the rep ID.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_pool_+3A_rep_reference">rep_reference</code></td>
<td>
<p>Atomic of length 1,
element of the <code>rep</code> column that indicates
baseline, i.e. the first rep chronologically.
(The other reps may be post-baseline study visits or time points.)</p>
</td></tr>
<tr><td><code id="hbl_mcmc_pool_+3A_covariates">covariates</code></td>
<td>
<p>Character vector of column names
in <code>data</code> with the columns with baseline covariates.
These can be continuous, categorical, or binary.
Regardless, <code>historicalborrowlong</code> derives the appropriate
model matrix.
</p>
<p>Each baseline covariate column must truly be a <em>baseline</em> covariate:
elements must be equal for all time points within each patient
(after the steps in the &quot;Data processing&quot; section).
In other words, covariates must not be time-varying.
</p>
<p>A large number of covariates, or a large number of levels in a
categorical covariate, can severely slow down the computation.
Please consider carefully if you really need to include
such complicated baseline covariates.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_pool_+3A_constraint">constraint</code></td>
<td>
<p>Logical of length 1, whether to pool all study arms
at baseline (first rep). Appropriate when the response is the raw
response (as opposed to change from baseline) and the first rep
(i.e. time point) is prior to treatment.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_pool_+3A_s_alpha">s_alpha</code></td>
<td>
<p>Numeric of length 1, prior standard deviation
of the study-specific control group mean parameters <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_pool_+3A_s_delta">s_delta</code></td>
<td>
<p>Numeric of length 1, prior standard deviation
of the study-by-group effect parameters <code>delta</code>.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_pool_+3A_s_beta">s_beta</code></td>
<td>
<p>Numeric of length 1, prior standard deviation
of the fixed effects <code>beta</code>.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_pool_+3A_s_sigma">s_sigma</code></td>
<td>
<p>Numeric of length 1, prior upper bound
of the residual standard deviations.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_pool_+3A_s_lambda">s_lambda</code></td>
<td>
<p>shape parameter of the LKJ priors
on the unstructured correlation matrices.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_pool_+3A_covariance_current">covariance_current</code></td>
<td>
<p>Character of length 1,
covariance structure of the current study.
Possible values are <code>"unstructured"</code> for fully parameterized
covariance matrices, <code>"ar1"</code> for AR(1) covariance matrices,
and <code>"diagonal"</code> for residuals independent across time within
each patient. In MCMC (e.g. <code><a href="#topic+hbl_mcmc_hierarchical">hbl_mcmc_hierarchical()</a></code>),
the covariance structure affects computational speed.
Unstructured covariance is slower than AR(1), and AR(1) is slower
than diagonal. This is particularly true for <code>covariance_historical</code>
if there are many historical studies in the data.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_pool_+3A_covariance_historical">covariance_historical</code></td>
<td>
<p>Same as <code>covariance_current</code>,
but for the covariance structure of each separate historical study.
Each historical study has its own separate covariance matrix.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_pool_+3A_control">control</code></td>
<td>
<p>A named <code>list</code> of parameters to control the sampler's
behavior. It defaults to <code>NULL</code> so all the default values are used.
First, the following are adaptation parameters for sampling algorithms.
These are parameters used in Stan with similar names here.
</p>

<ul>
<li> <p><code>adapt_engaged</code> (<code>logical</code>)
</p>
</li>
<li> <p><code>adapt_gamma</code> (<code>double</code>, positive, defaults to 0.05)
</p>
</li>
<li> <p><code>adapt_delta</code> (<code>double</code>, between 0 and 1, defaults to 0.8)
</p>
</li>
<li> <p><code>adapt_kappa</code> (<code>double</code>, positive, defaults to 0.75)
</p>
</li>
<li> <p><code>adapt_t0</code> (<code>double</code>, positive, defaults to 10)
</p>
</li>
<li> <p><code>adapt_init_buffer</code> (<code>integer</code>, positive, defaults to 75)
</p>
</li>
<li> <p><code>adapt_term_buffer</code> (<code>integer</code>, positive, defaults to 50)
</p>
</li>
<li> <p><code>adapt_window</code> (<code>integer</code>, positive, defaults to 25)
</p>
</li></ul>

<p>In addition, algorithm HMC (called 'static HMC' in Stan) and NUTS share the
following parameters:
</p>

<ul>
<li> <p><code>stepsize</code> (<code>double</code>, positive, defaults to 1)
Note: this controls the <em>initial</em> stepsize only, unless <code>adapt_engaged=FALSE</code>.
</p>
</li>
<li> <p><code>stepsize_jitter</code> (<code>double</code>, [0,1], defaults to 0)
</p>
</li>
<li> <p><code>metric</code> (<code>string</code>, one of &quot;unit_e&quot;, &quot;diag_e&quot;, &quot;dense_e&quot;,
defaults to &quot;diag_e&quot;)
</p>
</li></ul>

<p>For algorithm NUTS, we can also set:
</p>

<ul>
<li> <p><code>max_treedepth</code> (<code>integer</code>, positive, defaults to 10)
</p>
</li></ul>

<p>For algorithm HMC, we can also set:
</p>

<ul>
<li> <p><code>int_time</code> (<code>double</code>, positive)
</p>
</li></ul>

<p>For <code>test_grad</code> mode, the following parameters can be set:
</p>

<ul>
<li> <p><code>epsilon</code> (<code>double</code>, defaults to 1e-6)
</p>
</li>
<li> <p><code>error</code> (<code>double</code>, defaults to 1e-6)
</p>
</li></ul>

</td></tr>
<tr><td><code id="hbl_mcmc_pool_+3A_...">...</code></td>
<td>
<p>Additional named arguments of <code>rstan::sampling()</code>.
See the documentation of <code>rstan::sampling()</code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tidy data frame of parameter samples from the
posterior distribution. Columns <code>.chain</code>, <code>.iteration</code>,
and <code>.draw</code> have the meanings documented in the
<code>posterior</code> package.
</p>


<h3>Data processing</h3>

<p>Before running the MCMC, dataset is pre-processed.
This includes expanding the rows of the data so every rep
of every patient gets an explicit row. So if your
original data has irregular rep IDs, e.g. unscheduled
visits in a clinical trial that few patients attend,
please remove them before the analysis. Only the most
common rep IDs should be added.
</p>
<p>After expanding the rows, the function fills in missing
values for every column except the response. That includes
covariates. Missing covariate values are filled in,
first with last observation carried forward,
then with last observation carried backward.
If there are still missing values after this process,
the program throws an informative error.
</p>


<h3>See Also</h3>

<p>Other mcmc: 
<code><a href="#topic+hbl_convergence">hbl_convergence</a>()</code>,
<code><a href="#topic+hbl_mcmc_hierarchical">hbl_mcmc_hierarchical</a>()</code>,
<code><a href="#topic+hbl_mcmc_independent">hbl_mcmc_independent</a>()</code>,
<code><a href="#topic+hbl_mcmc_sge">hbl_mcmc_sge</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (!identical(Sys.getenv("HBL_TEST", unset = ""), "")) {
set.seed(0)
data &lt;- hbl_sim_pool(
  n_study = 3,
  n_group = 2,
  n_patient = 5,
  n_rep = 3
)$data
tmp &lt;- utils::capture.output(
  suppressWarnings(
    mcmc &lt;- hbl_mcmc_pool(
      data,
      chains = 1,
      warmup = 10,
      iter = 20,
      seed = 0
    )
  )
)
mcmc
}
</code></pre>

<hr>
<h2 id='hbl_mcmc_sge'>Run all MCMCs on a Sun Grid Engine (SGE) cluster.</h2><span id='topic+hbl_mcmc_sge'></span>

<h3>Description</h3>

<p>Run all MCMCs on a Sun Grid Engine (SGE) cluster.
Different models run in different jobs, and different chains run on
different cores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hbl_mcmc_sge(
  data,
  response = "response",
  study = "study",
  study_reference = max(data[[study]]),
  group = "group",
  group_reference = min(data[[group]]),
  patient = "patient",
  rep = "rep",
  rep_reference = min(data[[rep]]),
  covariates = grep("^covariate", colnames(data), value = TRUE),
  constraint = FALSE,
  s_alpha = 30,
  s_delta = 30,
  s_beta = 30,
  s_sigma = 30,
  s_lambda = 1,
  s_mu = 30,
  s_tau = 30,
  covariance_current = "unstructured",
  covariance_historical = "unstructured",
  control = list(max_treedepth = 17, adapt_delta = 0.99),
  log = "/dev/null",
  scheduler = "sge",
  chains = 1,
  cores = chains,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hbl_mcmc_sge_+3A_data">data</code></td>
<td>
<p>Tidy data frame with one row per patient per rep,
indicator columns for the response variable,
study, group, patient, rep,
and covariates. All columns must be atomic vectors
(e.g. not lists).</p>
</td></tr>
<tr><td><code id="hbl_mcmc_sge_+3A_response">response</code></td>
<td>
<p>Character of length 1,
name of the column in <code>data</code> with the response/outcome variable.
<code>data[[response]]</code> must be a continuous variable,
and it <em>should</em> be the change from baseline of a
clinical endpoint of interest, as opposed to just
the raw response. Treatment differences
are computed directly from this scale, please supply
change from baseline unless you are absolutely certain
that treatment differences computed directly from
this quantity are clinically meaningful.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_sge_+3A_study">study</code></td>
<td>
<p>Character of length 1,
name of the column in <code>data</code> with the study ID.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_sge_+3A_study_reference">study_reference</code></td>
<td>
<p>Atomic of length 1,
element of the <code>study</code> column that indicates
the current study.
(The other studies are historical studies.)</p>
</td></tr>
<tr><td><code id="hbl_mcmc_sge_+3A_group">group</code></td>
<td>
<p>Character of length 1,
name of the column in <code>data</code> with the group ID.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_sge_+3A_group_reference">group_reference</code></td>
<td>
<p>Atomic of length 1,
element of the <code>group</code> column that indicates
the control group.
(The other groups may be treatment groups.)</p>
</td></tr>
<tr><td><code id="hbl_mcmc_sge_+3A_patient">patient</code></td>
<td>
<p>Character of length 1,
name of the column in <code>data</code> with the patient ID.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_sge_+3A_rep">rep</code></td>
<td>
<p>Character of length 1,
name of the column in <code>data</code> with the rep ID.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_sge_+3A_rep_reference">rep_reference</code></td>
<td>
<p>Atomic of length 1,
element of the <code>rep</code> column that indicates
baseline, i.e. the first rep chronologically.
(The other reps may be post-baseline study visits or time points.)</p>
</td></tr>
<tr><td><code id="hbl_mcmc_sge_+3A_covariates">covariates</code></td>
<td>
<p>Character vector of column names
in <code>data</code> with the columns with baseline covariates.
These can be continuous, categorical, or binary.
Regardless, <code>historicalborrowlong</code> derives the appropriate
model matrix.
</p>
<p>Each baseline covariate column must truly be a <em>baseline</em> covariate:
elements must be equal for all time points within each patient
(after the steps in the &quot;Data processing&quot; section).
In other words, covariates must not be time-varying.
</p>
<p>A large number of covariates, or a large number of levels in a
categorical covariate, can severely slow down the computation.
Please consider carefully if you really need to include
such complicated baseline covariates.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_sge_+3A_constraint">constraint</code></td>
<td>
<p>Logical of length 1, whether to pool all study arms
at baseline (first rep). Appropriate when the response is the raw
response (as opposed to change from baseline) and the first rep
(i.e. time point) is prior to treatment.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_sge_+3A_s_alpha">s_alpha</code></td>
<td>
<p>Numeric of length 1, prior standard deviation
of the study-specific control group mean parameters <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_sge_+3A_s_delta">s_delta</code></td>
<td>
<p>Numeric of length 1, prior standard deviation
of the study-by-group effect parameters <code>delta</code>.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_sge_+3A_s_beta">s_beta</code></td>
<td>
<p>Numeric of length 1, prior standard deviation
of the fixed effects <code>beta</code>.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_sge_+3A_s_sigma">s_sigma</code></td>
<td>
<p>Numeric of length 1, prior upper bound
of the residual standard deviations.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_sge_+3A_s_lambda">s_lambda</code></td>
<td>
<p>shape parameter of the LKJ priors
on the unstructured correlation matrices.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_sge_+3A_s_mu">s_mu</code></td>
<td>
<p>Numeric of length 1,
prior standard deviation of <code>mu</code>.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_sge_+3A_s_tau">s_tau</code></td>
<td>
<p>Non-negative numeric of length 1.
If <code>prior_tau</code> is <code>"half_t"</code>, then <code>s_tau</code> is the scale parameter of
the Student t prior of <code>tau</code> and analogous to the <code>sigma</code> parameter of
the Student-t parameterization given at
<a href="https://mc-stan.org/docs/functions-reference/unbounded_continuous_distributions.html">https://mc-stan.org/docs/functions-reference/unbounded_continuous_distributions.html</a>. # nolint
If <code>prior_tau</code> is <code>"uniform"</code>, then <code>s_tau</code> is the upper bound of <code>tau</code>.
Upper bound on <code>tau</code> if <code>prior_tau</code> is <code>"uniform"</code>.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_sge_+3A_covariance_current">covariance_current</code></td>
<td>
<p>Character of length 1,
covariance structure of the current study.
Possible values are <code>"unstructured"</code> for fully parameterized
covariance matrices, <code>"ar1"</code> for AR(1) covariance matrices,
and <code>"diagonal"</code> for residuals independent across time within
each patient. In MCMC (e.g. <code><a href="#topic+hbl_mcmc_hierarchical">hbl_mcmc_hierarchical()</a></code>),
the covariance structure affects computational speed.
Unstructured covariance is slower than AR(1), and AR(1) is slower
than diagonal. This is particularly true for <code>covariance_historical</code>
if there are many historical studies in the data.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_sge_+3A_covariance_historical">covariance_historical</code></td>
<td>
<p>Same as <code>covariance_current</code>,
but for the covariance structure of each separate historical study.
Each historical study has its own separate covariance matrix.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_sge_+3A_control">control</code></td>
<td>
<p>A named <code>list</code> of parameters to control the sampler's
behavior. It defaults to <code>NULL</code> so all the default values are used.
First, the following are adaptation parameters for sampling algorithms.
These are parameters used in Stan with similar names here.
</p>

<ul>
<li> <p><code>adapt_engaged</code> (<code>logical</code>)
</p>
</li>
<li> <p><code>adapt_gamma</code> (<code>double</code>, positive, defaults to 0.05)
</p>
</li>
<li> <p><code>adapt_delta</code> (<code>double</code>, between 0 and 1, defaults to 0.8)
</p>
</li>
<li> <p><code>adapt_kappa</code> (<code>double</code>, positive, defaults to 0.75)
</p>
</li>
<li> <p><code>adapt_t0</code> (<code>double</code>, positive, defaults to 10)
</p>
</li>
<li> <p><code>adapt_init_buffer</code> (<code>integer</code>, positive, defaults to 75)
</p>
</li>
<li> <p><code>adapt_term_buffer</code> (<code>integer</code>, positive, defaults to 50)
</p>
</li>
<li> <p><code>adapt_window</code> (<code>integer</code>, positive, defaults to 25)
</p>
</li></ul>

<p>In addition, algorithm HMC (called 'static HMC' in Stan) and NUTS share the
following parameters:
</p>

<ul>
<li> <p><code>stepsize</code> (<code>double</code>, positive, defaults to 1)
Note: this controls the <em>initial</em> stepsize only, unless <code>adapt_engaged=FALSE</code>.
</p>
</li>
<li> <p><code>stepsize_jitter</code> (<code>double</code>, [0,1], defaults to 0)
</p>
</li>
<li> <p><code>metric</code> (<code>string</code>, one of &quot;unit_e&quot;, &quot;diag_e&quot;, &quot;dense_e&quot;,
defaults to &quot;diag_e&quot;)
</p>
</li></ul>

<p>For algorithm NUTS, we can also set:
</p>

<ul>
<li> <p><code>max_treedepth</code> (<code>integer</code>, positive, defaults to 10)
</p>
</li></ul>

<p>For algorithm HMC, we can also set:
</p>

<ul>
<li> <p><code>int_time</code> (<code>double</code>, positive)
</p>
</li></ul>

<p>For <code>test_grad</code> mode, the following parameters can be set:
</p>

<ul>
<li> <p><code>epsilon</code> (<code>double</code>, defaults to 1e-6)
</p>
</li>
<li> <p><code>error</code> (<code>double</code>, defaults to 1e-6)
</p>
</li></ul>

</td></tr>
<tr><td><code id="hbl_mcmc_sge_+3A_log">log</code></td>
<td>
<p>Character of length 1, path to a directory (with a trailing <code>/</code>)
or a single file path. The SGE log files go here. Only works if
<code>scheduler</code> is <code>"sge"</code>.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_sge_+3A_scheduler">scheduler</code></td>
<td>
<p>Either <code>"sge"</code> or <code>"local"</code>, high-performance computing
scheduler / resource manager to use. Choose <code>"sge"</code> for serious use cases
with a Sun Grid Engine (SGE) cluster. Otherwise, to run models
sequentially on the current node, choose <code>"local"</code>.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_sge_+3A_chains">chains</code></td>
<td>
<p>A positive integer specifying the number of Markov chains.
The default is 4.</p>
</td></tr>
<tr><td><code id="hbl_mcmc_sge_+3A_cores">cores</code></td>
<td>

<p>The number of cores to use when executing the Markov chains in parallel.
The default is to use the value of the <code>"mc.cores"</code> option if it
has been set and otherwise to default to 1 core. However, we recommend
setting it to be as many processors as the hardware and RAM allow
(up to the number of chains). See <code><a href="parallel.html#topic+detectCores">detectCores</a></code>
if you don't know this number for your system.
</p>
</td></tr>
<tr><td><code id="hbl_mcmc_sge_+3A_...">...</code></td>
<td>
<p>Other optional parameters:
</p>

<ul>
<li> <p><code>chain_id</code> (<code>integer</code>)
</p>
</li>
<li> <p><code>init_r</code> (<code>double</code>, positive)
</p>
</li>
<li> <p><code>test_grad</code> (<code>logical</code>)
</p>
</li>
<li> <p><code>append_samples</code> (<code>logical</code>)
</p>
</li>
<li> <p><code>refresh</code>(<code>integer</code>)
</p>
</li>
<li> <p><code>save_warmup</code>(<code>logical</code>)
</p>
</li>
<li><p> deprecated: <code>enable_random_init</code>(<code>logical</code>)
</p>
</li></ul>

<p><code>chain_id</code> can be a vector to specify the chain_id for all
chains or an integer. For the former case, they should be unique.
For the latter, the sequence of integers starting from the given
<code>chain_id</code> are used for all chains.
</p>
<p><code>init_r</code> is used only for generating random initial values,
specifically when <code>init="random"</code> or not all parameters
are initialized in the user-supplied list or function. If specified,
the initial values are simulated uniformly from interval
[-<code>init_r</code>, <code>init_r</code>] rather than using the default interval
(see the manual of (cmd)Stan).
</p>
<p><code>test_grad</code> (<code>logical</code>).
If <code>test_grad=TRUE</code>, Stan will not do any sampling. Instead,
the gradient calculation is tested and printed out and the fitted
<code>stanfit</code> object is in test gradient mode.  By default, it is
<code>FALSE</code>.
</p>
<p><code>append_samples</code> (<code>logical</code>).
Only relevant if <code>sample_file</code> is specified <em>and</em> is an
existing file. In that case, setting <code>append_samples=TRUE</code> will append
the samples to the existing file rather than overwriting the contents of
the file.
</p>
<p><code>refresh</code> (<code>integer</code>) can be used to
control how often the progress of the sampling is reported (i.e.
show the progress every <code>refresh</code> iterations).
By default, <code>refresh = max(iter/10, 1)</code>.
The progress indicator is turned off if <code>refresh &lt;= 0</code>.
</p>
<p>Deprecated: <code>enable_random_init</code> (<code>logical</code>) being <code>TRUE</code>
enables specifying initial values randomly when the initial
values are not fully specified from the user.
</p>
<p><code>save_warmup</code> (<code>logical</code>) indicates whether to
save draws during the warmup phase and defaults to <code>TRUE</code>. Some
memory related problems can be avoided by setting it to <code>FALSE</code>,
but some diagnostics are more limited if the warmup draws are not
stored.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of tidy data frames of parameter samples from the
posterior distribution.
Columns <code>.chain</code>, <code>.iteration</code>,
and <code>.draw</code> have the meanings documented in the
<code>posterior</code> package.
</p>


<h3>Data processing</h3>

<p>Before running the MCMC, dataset is pre-processed.
This includes expanding the rows of the data so every rep
of every patient gets an explicit row. So if your
original data has irregular rep IDs, e.g. unscheduled
visits in a clinical trial that few patients attend,
please remove them before the analysis. Only the most
common rep IDs should be added.
</p>
<p>After expanding the rows, the function fills in missing
values for every column except the response. That includes
covariates. Missing covariate values are filled in,
first with last observation carried forward,
then with last observation carried backward.
If there are still missing values after this process,
the program throws an informative error.
</p>


<h3>See Also</h3>

<p>Other mcmc: 
<code><a href="#topic+hbl_convergence">hbl_convergence</a>()</code>,
<code><a href="#topic+hbl_mcmc_hierarchical">hbl_mcmc_hierarchical</a>()</code>,
<code><a href="#topic+hbl_mcmc_independent">hbl_mcmc_independent</a>()</code>,
<code><a href="#topic+hbl_mcmc_pool">hbl_mcmc_pool</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("HBL_SGE"), "true")) {
if (!identical(Sys.getenv("HBL_TEST", unset = ""), "")) {
set.seed(0)
data &lt;- hbl_sim_hierarchical(
  n_study = 2,
  n_group = 2,
  n_patient = 5,
  n_rep = 3
)$data
tmp &lt;- utils::capture.output(
  suppressWarnings(
    mcmc &lt;- hbl_mcmc_sge(
      data,
      chains = 2,
      warmup = 10,
      iter = 20,
      seed = 0,
      scheduler = "local" # change to "sge" for serious runs
    )
  )
)
mcmc
}
}
</code></pre>

<hr>
<h2 id='hbl_metrics'>Legacy function to compute superseded borrowing metrics</h2><span id='topic+hbl_metrics'></span>

<h3>Description</h3>

<p>Calculate legacy/superseded borrowing metrics using
summary output from a fitted borrowing model and
analogous summaries from the benchmark models.
<code><a href="#topic+hbl_ess">hbl_ess()</a></code> is preferred over <code><a href="#topic+hbl_metrics">hbl_metrics()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hbl_metrics(borrow, pool, independent)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hbl_metrics_+3A_borrow">borrow</code></td>
<td>
<p>A data frame returned by <code><a href="#topic+hbl_summary">hbl_summary()</a></code>
for the hierarchical model.</p>
</td></tr>
<tr><td><code id="hbl_metrics_+3A_pool">pool</code></td>
<td>
<p>A data frame returned by <code><a href="#topic+hbl_summary">hbl_summary()</a></code>
for the pooled model.</p>
</td></tr>
<tr><td><code id="hbl_metrics_+3A_independent">independent</code></td>
<td>
<p>A data frame returned by <code><a href="#topic+hbl_summary">hbl_summary()</a></code>
for the independent model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with borrowing metrics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (!identical(Sys.getenv("HBL_TEST", unset = ""), "")) {
set.seed(0)
data &lt;- hbl_sim_independent(
  n_study = 2,
  n_group = 2,
  n_patient = 5,
  n_rep = 3
)$data
tmp &lt;- utils::capture.output(
  suppressWarnings(
    mcmc_borrow &lt;- hbl_mcmc_hierarchical(
      data,
      chains = 1,
      warmup = 10,
      iter = 20,
      seed = 0
    )
  )
)
tmp &lt;- utils::capture.output(
  suppressWarnings(
    mcmc_pool &lt;- hbl_mcmc_pool(
      data,
      chains = 1,
      warmup = 10,
      iter = 20,
      seed = 0
    )
  )
)
tmp &lt;- utils::capture.output(
  suppressWarnings(
    mcmc_independent &lt;- hbl_mcmc_independent(
      data,
      chains = 1,
      warmup = 10,
      iter = 20,
      seed = 0
    )
  )
)
borrow &lt;- hbl_summary(mcmc_borrow, data)
pool &lt;- hbl_summary(mcmc_pool, data)
independent &lt;- hbl_summary(mcmc_independent, data)
hbl_metrics(
  borrow = borrow,
  pool = pool,
  independent = independent
)
}
</code></pre>

<hr>
<h2 id='hbl_plot_borrow'>Plot the hierarchical model response
against the benchmark models.</h2><span id='topic+hbl_plot_borrow'></span>

<h3>Description</h3>

<p>Plot the response from a
hierarchical model.
against the independent and pooled benchmark models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hbl_plot_borrow(
  borrow,
  pool,
  independent,
  outcome = c("response", "change", "diff")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hbl_plot_borrow_+3A_borrow">borrow</code></td>
<td>
<p>A data frame returned by <code><a href="#topic+hbl_summary">hbl_summary()</a></code>
for the hierarchical model.</p>
</td></tr>
<tr><td><code id="hbl_plot_borrow_+3A_pool">pool</code></td>
<td>
<p>A data frame returned by <code><a href="#topic+hbl_summary">hbl_summary()</a></code>
for the pooled model.</p>
</td></tr>
<tr><td><code id="hbl_plot_borrow_+3A_independent">independent</code></td>
<td>
<p>A data frame returned by <code><a href="#topic+hbl_summary">hbl_summary()</a></code>
for the independent model.</p>
</td></tr>
<tr><td><code id="hbl_plot_borrow_+3A_outcome">outcome</code></td>
<td>
<p>Character of length 1, either <code>"response"</code>, <code>"change"</code>,
or <code>"diff"</code>: the quantity to plot on the vertical axis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> object
</p>


<h3>See Also</h3>

<p>Other plot: 
<code><a href="#topic+hbl_plot_group">hbl_plot_group</a>()</code>,
<code><a href="#topic+hbl_plot_tau">hbl_plot_tau</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (!identical(Sys.getenv("HBL_TEST", unset = ""), "")) {
set.seed(0)
data &lt;- hbl_sim_independent(
  n_study = 2,
  n_group = 2,
  n_patient = 5,
  n_rep = 3
)$data
tmp &lt;- utils::capture.output(
  suppressWarnings(
    mcmc_borrow &lt;- hbl_mcmc_hierarchical(
      data,
      chains = 1,
      warmup = 10,
      iter = 20,
      seed = 0
    )
  )
)
tmp &lt;- utils::capture.output(
  suppressWarnings(
    mcmc_pool &lt;- hbl_mcmc_pool(
      data,
      chains = 1,
      warmup = 10,
      iter = 20,
      seed = 0
    )
  )
)
tmp &lt;- utils::capture.output(
  suppressWarnings(
    mcmc_independent &lt;- hbl_mcmc_independent(
      data,
      chains = 1,
      warmup = 10,
      iter = 20,
      seed = 0
    )
  )
)
borrow &lt;- hbl_summary(mcmc_borrow, data)
pool &lt;- hbl_summary(mcmc_pool, data)
independent &lt;- hbl_summary(mcmc_independent, data)
hbl_plot_borrow(
  borrow = borrow,
  pool = pool,
  independent = independent
)
}
</code></pre>

<hr>
<h2 id='hbl_plot_group'>Plot the groups of the hierarchical model
and its benchmark models.</h2><span id='topic+hbl_plot_group'></span>

<h3>Description</h3>

<p>Plot the groups against one another
for a hierarchical model.
and the independent and pooled benchmark models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hbl_plot_group(
  borrow,
  pool,
  independent,
  outcome = c("response", "change", "diff")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hbl_plot_group_+3A_borrow">borrow</code></td>
<td>
<p>A data frame returned by <code><a href="#topic+hbl_summary">hbl_summary()</a></code>
for the hierarchical model.</p>
</td></tr>
<tr><td><code id="hbl_plot_group_+3A_pool">pool</code></td>
<td>
<p>A data frame returned by <code><a href="#topic+hbl_summary">hbl_summary()</a></code>
for the pooled model.</p>
</td></tr>
<tr><td><code id="hbl_plot_group_+3A_independent">independent</code></td>
<td>
<p>A data frame returned by <code><a href="#topic+hbl_summary">hbl_summary()</a></code>
for the independent model.</p>
</td></tr>
<tr><td><code id="hbl_plot_group_+3A_outcome">outcome</code></td>
<td>
<p>Character of length 1, either <code>"response"</code>, <code>"change"</code>,
or <code>"diff"</code>: the quantity to plot on the vertical axis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> object
</p>


<h3>See Also</h3>

<p>Other plot: 
<code><a href="#topic+hbl_plot_borrow">hbl_plot_borrow</a>()</code>,
<code><a href="#topic+hbl_plot_tau">hbl_plot_tau</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (!identical(Sys.getenv("HBL_TEST", unset = ""), "")) {
set.seed(0)
data &lt;- hbl_sim_independent(
  n_study = 2,
  n_group = 2,
  n_patient = 5,
  n_rep = 3
)$data
tmp &lt;- utils::capture.output(
  suppressWarnings(
    mcmc_borrow &lt;- hbl_mcmc_hierarchical(
      data,
      chains = 1,
      warmup = 10,
      iter = 20,
      seed = 0
    )
  )
)
tmp &lt;- utils::capture.output(
  suppressWarnings(
    mcmc_pool &lt;- hbl_mcmc_pool(
      data,
      chains = 1,
      warmup = 10,
      iter = 20,
      seed = 0
    )
  )
)
tmp &lt;- utils::capture.output(
  suppressWarnings(
    mcmc_independent &lt;- hbl_mcmc_independent(
      data,
      chains = 1,
      warmup = 10,
      iter = 20,
      seed = 0
    )
  )
)
borrow &lt;- hbl_summary(mcmc_borrow, data)
pool &lt;- hbl_summary(mcmc_pool, data)
independent &lt;- hbl_summary(mcmc_independent, data)
hbl_plot_group(
  borrow = borrow,
  pool = pool,
  independent = independent
)
}
</code></pre>

<hr>
<h2 id='hbl_plot_tau'>Plot tau</h2><span id='topic+hbl_plot_tau'></span>

<h3>Description</h3>

<p>Plot the rep-specific tau parameters
of a fitted hierarchical model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hbl_plot_tau(mcmc)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hbl_plot_tau_+3A_mcmc">mcmc</code></td>
<td>
<p>Data frame of posterior samples generated by
<code><a href="#topic+hbl_mcmc_hierarchical">hbl_mcmc_hierarchical()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> object
</p>


<h3>See Also</h3>

<p>Other plot: 
<code><a href="#topic+hbl_plot_borrow">hbl_plot_borrow</a>()</code>,
<code><a href="#topic+hbl_plot_group">hbl_plot_group</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (!identical(Sys.getenv("HBL_TEST", unset = ""), "")) {
set.seed(0)
data &lt;- hbl_sim_independent(n_continuous = 2)$data
tmp &lt;- utils::capture.output(
  suppressWarnings(
    mcmc &lt;- hbl_mcmc_hierarchical(
      data,
      chains = 1,
      warmup = 10,
      iter = 20,
      seed = 0
    )
  )
)
hbl_plot_tau(mcmc)
}
</code></pre>

<hr>
<h2 id='hbl_s_tau'>Superseded: suggest a value of s_tau</h2><span id='topic+hbl_s_tau'></span>

<h3>Description</h3>

<p>Superseded:
suggest a value of the <code>s_tau</code> hyperparameter
to roughly target a specified minimum amount of borrowing
in the hierarchical model with the uniform prior.
Only use if a diffuse prior on <code>tau</code> is not feasible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hbl_s_tau(precision_ratio = 0.5, sigma = 1, n = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hbl_s_tau_+3A_precision_ratio">precision_ratio</code></td>
<td>
<p>Positive numeric vector of elements between 0 and 1
with target precision ratios.</p>
</td></tr>
<tr><td><code id="hbl_s_tau_+3A_sigma">sigma</code></td>
<td>
<p>Positive numeric vector of residual standard deviations.</p>
</td></tr>
<tr><td><code id="hbl_s_tau_+3A_n">n</code></td>
<td>
<p>Number of non-missing patients.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The target minimum amount of borrowing
is expressed in the <code>precision_ratio</code> argument.
The precision ratio is a metric that quantifies the amount of
borrowing in the hierarchical model. See the &quot;Methods&quot; vignette
for details.
</p>


<h3>Value</h3>

<p>Numeric of length equal to <code>length(precision_ratio)</code> and
<code>length(sigma)</code>, suggested values of s_tau for each element of
<code>precision_ratio</code> and <code>sigma</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hbl_s_tau(precision_ratio = 0.5, sigma = 1, n = 100)
</code></pre>

<hr>
<h2 id='hbl_sim_hierarchical'>Non-longitudinal hierarchical simulations.</h2><span id='topic+hbl_sim_hierarchical'></span>

<h3>Description</h3>

<p>Simulate from the non-longitudinal hierarchical model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hbl_sim_hierarchical(
  n_study = 5,
  n_group = 3,
  n_patient = 100,
  n_rep = 4,
  n_continuous = 0,
  n_binary = 0,
  constraint = FALSE,
  s_delta = 1,
  s_beta = 1,
  s_sigma = 1,
  s_lambda = 1,
  s_mu = 1,
  s_tau = 1,
  d_tau = 4,
  prior_tau = "half_t",
  covariance_current = "unstructured",
  covariance_historical = "unstructured",
  alpha = NULL,
  delta = stats::rnorm(n = (n_group - 1) * (n_rep - as.integer(constraint)), mean = 0, sd
    = s_delta),
  beta = stats::rnorm(n = n_study * (n_continuous + n_binary), mean = 0, sd = s_delta),
  sigma = stats::runif(n = n_study * n_rep, min = 0, max = s_sigma),
  mu = stats::rnorm(n = n_rep, mean = 0, sd = s_mu),
  tau = NULL,
  rho_current = stats::runif(n = 1, min = -1, max = 1),
  rho_historical = stats::runif(n = n_study - 1, min = -1, max = 1)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hbl_sim_hierarchical_+3A_n_study">n_study</code></td>
<td>
<p>Number of studies to simulate.</p>
</td></tr>
<tr><td><code id="hbl_sim_hierarchical_+3A_n_group">n_group</code></td>
<td>
<p>Number of groups (e.g. study arms) to simulate per study.</p>
</td></tr>
<tr><td><code id="hbl_sim_hierarchical_+3A_n_patient">n_patient</code></td>
<td>
<p>Number of patients to simulate per study per group.</p>
</td></tr>
<tr><td><code id="hbl_sim_hierarchical_+3A_n_rep">n_rep</code></td>
<td>
<p>Number of repeated measures (time points) per patient.</p>
</td></tr>
<tr><td><code id="hbl_sim_hierarchical_+3A_n_continuous">n_continuous</code></td>
<td>
<p>Number of continuous covariates to simulate
(all from independent standard normal distributions).</p>
</td></tr>
<tr><td><code id="hbl_sim_hierarchical_+3A_n_binary">n_binary</code></td>
<td>
<p>Number of binary covariates to simulate
(all from independent Bernoulli distributions with p = 0.5).</p>
</td></tr>
<tr><td><code id="hbl_sim_hierarchical_+3A_constraint">constraint</code></td>
<td>
<p>Logical of length 1, whether to pool all study arms
at baseline (first rep). Appropriate when the response is the raw
response (as opposed to change from baseline) and the first rep
(i.e. time point) is prior to treatment.</p>
</td></tr>
<tr><td><code id="hbl_sim_hierarchical_+3A_s_delta">s_delta</code></td>
<td>
<p>Numeric of length 1, prior standard deviation
of the study-by-group effect parameters <code>delta</code>.</p>
</td></tr>
<tr><td><code id="hbl_sim_hierarchical_+3A_s_beta">s_beta</code></td>
<td>
<p>Numeric of length 1, prior standard deviation
of the fixed effects <code>beta</code>.</p>
</td></tr>
<tr><td><code id="hbl_sim_hierarchical_+3A_s_sigma">s_sigma</code></td>
<td>
<p>Numeric of length 1, prior upper bound
of the residual standard deviations.</p>
</td></tr>
<tr><td><code id="hbl_sim_hierarchical_+3A_s_lambda">s_lambda</code></td>
<td>
<p>shape parameter of the LKJ priors
on the unstructured correlation matrices.</p>
</td></tr>
<tr><td><code id="hbl_sim_hierarchical_+3A_s_mu">s_mu</code></td>
<td>
<p>Numeric of length 1,
prior standard deviation of <code>mu</code>.</p>
</td></tr>
<tr><td><code id="hbl_sim_hierarchical_+3A_s_tau">s_tau</code></td>
<td>
<p>Non-negative numeric of length 1.
If <code>prior_tau</code> is <code>"half_t"</code>, then <code>s_tau</code> is the scale parameter of
the Student t prior of <code>tau</code> and analogous to the <code>sigma</code> parameter of
the Student-t parameterization given at
<a href="https://mc-stan.org/docs/functions-reference/unbounded_continuous_distributions.html">https://mc-stan.org/docs/functions-reference/unbounded_continuous_distributions.html</a>. # nolint
If <code>prior_tau</code> is <code>"uniform"</code>, then <code>s_tau</code> is the upper bound of <code>tau</code>.
Upper bound on <code>tau</code> if <code>prior_tau</code> is <code>"uniform"</code>.</p>
</td></tr>
<tr><td><code id="hbl_sim_hierarchical_+3A_d_tau">d_tau</code></td>
<td>
<p>Positive numeric of length 1. Degrees of freedom of the
Student t prior of <code>tau</code> if <code>prior_tau</code> is <code>"half_t"</code>.</p>
</td></tr>
<tr><td><code id="hbl_sim_hierarchical_+3A_prior_tau">prior_tau</code></td>
<td>
<p>Character string, family of the prior of <code>tau</code>.
If <code>prior_tau</code> equals <code>"uniform"</code>, then the prior on <code>tau</code> is
a uniform prior with lower bound 0 and upper bound <code>s_tau</code>.
If <code>prior_tau</code> equals <code>"half_t"</code>, then the prior on <code>tau</code> is a
half Student-t prior with center 0, lower bound 0, scale parameter
<code>s_tau</code>, and degrees of freedom <code>d_tau</code>. The scale parameter <code>s_tau</code>
is analogous to the <code>sigma</code> parameter of
the Student-t parameterization given at
<a href="https://mc-stan.org/docs/functions-reference/unbounded_continuous_distributions.html">https://mc-stan.org/docs/functions-reference/unbounded_continuous_distributions.html</a>. # nolint</p>
</td></tr>
<tr><td><code id="hbl_sim_hierarchical_+3A_covariance_current">covariance_current</code></td>
<td>
<p>Character of length 1,
covariance structure of the current study.
Possible values are <code>"unstructured"</code> for fully parameterized
covariance matrices, <code>"ar1"</code> for AR(1) covariance matrices,
and <code>"diagonal"</code> for residuals independent across time within
each patient. In MCMC (e.g. <code><a href="#topic+hbl_mcmc_hierarchical">hbl_mcmc_hierarchical()</a></code>),
the covariance structure affects computational speed.
Unstructured covariance is slower than AR(1), and AR(1) is slower
than diagonal. This is particularly true for <code>covariance_historical</code>
if there are many historical studies in the data.</p>
</td></tr>
<tr><td><code id="hbl_sim_hierarchical_+3A_covariance_historical">covariance_historical</code></td>
<td>
<p>Same as <code>covariance_current</code>,
but for the covariance structure of each separate historical study.
Each historical study has its own separate covariance matrix.</p>
</td></tr>
<tr><td><code id="hbl_sim_hierarchical_+3A_alpha">alpha</code></td>
<td>
<p>Numeric vector of length <code>n_rep</code> for the pooled
and model and length <code>n_study * n_rep</code> for the
independent and hierarchical models.
<code>alpha</code> is the vector of control group mean parameters.
<code>alpha</code> enters the model by multiplying with
<code style="white-space: pre;">&#8288;$matrices$x_alpha&#8288;</code> (see the return value).
The control group in the data is the one with the
<code>group</code> column equal to 1.</p>
</td></tr>
<tr><td><code id="hbl_sim_hierarchical_+3A_delta">delta</code></td>
<td>
<p>Numeric vector of length
<code>(n_group - 1) * (n_rep - as.integer(constraint))</code>
of treatment effect parameters.
<code>delta</code> enters the model by multiplying with
<code style="white-space: pre;">&#8288;$matrices$x_delta&#8288;</code> (see the return value).
The control (non-treatment) group in the data is the one with the
<code>group</code> column equal to 1.</p>
</td></tr>
<tr><td><code id="hbl_sim_hierarchical_+3A_beta">beta</code></td>
<td>
<p>Numeric vector of <code>n_study * (n_continuous + n_binary)</code>
fixed effect parameters. Within each study,
the first <code>n_continuous</code> betas
are for the continuous covariates, and the rest are for
the binary covariates. All the <code>beta</code>s for one study
appear before all the <code>beta</code>s for the next study,
and studies are arranged in increasing order of
the sorted unique values in <code style="white-space: pre;">&#8288;$data$study&#8288;</code> in the output.
<code>betas</code> enters the model by multiplying with
<code style="white-space: pre;">&#8288;$matrices$x_alpha&#8288;</code> (see the return value).</p>
</td></tr>
<tr><td><code id="hbl_sim_hierarchical_+3A_sigma">sigma</code></td>
<td>
<p>Numeric vector of <code>n_study * n_rep</code>
residual standard deviation parameters for each study
and rep. The elements are sorted with all the standard deviations
of study 1 first (all the reps), then all the reps of study 2, etc.</p>
</td></tr>
<tr><td><code id="hbl_sim_hierarchical_+3A_mu">mu</code></td>
<td>
<p>Numeric of length <code>n_rep</code>,
mean of the control group means <code>alpha</code> for each rep.</p>
</td></tr>
<tr><td><code id="hbl_sim_hierarchical_+3A_tau">tau</code></td>
<td>
<p>Numeric of length <code>n_rep</code>,
standard deviation of the control group means <code>alpha</code> for each rep.</p>
</td></tr>
<tr><td><code id="hbl_sim_hierarchical_+3A_rho_current">rho_current</code></td>
<td>
<p>Numeric of length 1 between -1 and 1,
AR(1) residual correlation parameter for the current study.</p>
</td></tr>
<tr><td><code id="hbl_sim_hierarchical_+3A_rho_historical">rho_historical</code></td>
<td>
<p>Numeric of length <code>n_study - 1</code> between -1 and 1,
AR(1) residual correlation parameters for the historical studies.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li> <p><code>data</code>: tidy long-form dataset with the patient-level data.
one row per patient per rep and indicator columns for the study,
group (e.g. treatment arm), patient ID, and rep. The <code>response</code>
columns is the patient response. The other columns are
baseline covariates. The control group is the one with
the <code>group</code> column equal to 1, and the current study (non-historical)
is the one with the maximum value of the <code>study</code> column.
Only the current study has any non-control-group patients,
the historical studies have only the control group.
</p>
</li>
<li> <p><code>parameters</code>: named list of model parameter values.
See the model specification vignette for details.
</p>
</li>
<li> <p><code>matrices</code>: A named list of model matrices.
See the model specification vignette for details.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other simulate: 
<code><a href="#topic+hbl_sim_independent">hbl_sim_independent</a>()</code>,
<code><a href="#topic+hbl_sim_pool">hbl_sim_pool</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hbl_sim_hierarchical(n_continuous = 1)$data
</code></pre>

<hr>
<h2 id='hbl_sim_independent'>Longitudinal independent simulations.</h2><span id='topic+hbl_sim_independent'></span>

<h3>Description</h3>

<p>Simulate from the longitudinal independent model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hbl_sim_independent(
  n_study = 5,
  n_group = 3,
  n_patient = 100,
  n_rep = 4,
  n_continuous = 0,
  n_binary = 0,
  constraint = FALSE,
  s_alpha = 1,
  s_delta = 1,
  s_beta = 1,
  s_sigma = 1,
  s_lambda = 1,
  covariance_current = "unstructured",
  covariance_historical = "unstructured",
  alpha = stats::rnorm(n = n_study * n_rep, mean = 0, sd = s_alpha),
  delta = stats::rnorm(n = (n_group - 1) * (n_rep - as.integer(constraint)), mean = 0, sd
    = s_delta),
  beta = stats::rnorm(n = n_study * (n_continuous + n_binary), mean = 0, sd = s_delta),
  sigma = stats::runif(n = n_study * n_rep, min = 0, max = s_sigma),
  rho_current = stats::runif(n = 1, min = -1, max = 1),
  rho_historical = stats::runif(n = n_study - 1, min = -1, max = 1)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hbl_sim_independent_+3A_n_study">n_study</code></td>
<td>
<p>Number of studies to simulate.</p>
</td></tr>
<tr><td><code id="hbl_sim_independent_+3A_n_group">n_group</code></td>
<td>
<p>Number of groups (e.g. study arms) to simulate per study.</p>
</td></tr>
<tr><td><code id="hbl_sim_independent_+3A_n_patient">n_patient</code></td>
<td>
<p>Number of patients to simulate per study per group.</p>
</td></tr>
<tr><td><code id="hbl_sim_independent_+3A_n_rep">n_rep</code></td>
<td>
<p>Number of repeated measures (time points) per patient.</p>
</td></tr>
<tr><td><code id="hbl_sim_independent_+3A_n_continuous">n_continuous</code></td>
<td>
<p>Number of continuous covariates to simulate
(all from independent standard normal distributions).</p>
</td></tr>
<tr><td><code id="hbl_sim_independent_+3A_n_binary">n_binary</code></td>
<td>
<p>Number of binary covariates to simulate
(all from independent Bernoulli distributions with p = 0.5).</p>
</td></tr>
<tr><td><code id="hbl_sim_independent_+3A_constraint">constraint</code></td>
<td>
<p>Logical of length 1, whether to pool all study arms
at baseline (first rep). Appropriate when the response is the raw
response (as opposed to change from baseline) and the first rep
(i.e. time point) is prior to treatment.</p>
</td></tr>
<tr><td><code id="hbl_sim_independent_+3A_s_alpha">s_alpha</code></td>
<td>
<p>Numeric of length 1, prior standard deviation
of the study-specific control group mean parameters <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="hbl_sim_independent_+3A_s_delta">s_delta</code></td>
<td>
<p>Numeric of length 1, prior standard deviation
of the study-by-group effect parameters <code>delta</code>.</p>
</td></tr>
<tr><td><code id="hbl_sim_independent_+3A_s_beta">s_beta</code></td>
<td>
<p>Numeric of length 1, prior standard deviation
of the fixed effects <code>beta</code>.</p>
</td></tr>
<tr><td><code id="hbl_sim_independent_+3A_s_sigma">s_sigma</code></td>
<td>
<p>Numeric of length 1, prior upper bound
of the residual standard deviations.</p>
</td></tr>
<tr><td><code id="hbl_sim_independent_+3A_s_lambda">s_lambda</code></td>
<td>
<p>shape parameter of the LKJ priors
on the unstructured correlation matrices.</p>
</td></tr>
<tr><td><code id="hbl_sim_independent_+3A_covariance_current">covariance_current</code></td>
<td>
<p>Character of length 1,
covariance structure of the current study.
Possible values are <code>"unstructured"</code> for fully parameterized
covariance matrices, <code>"ar1"</code> for AR(1) covariance matrices,
and <code>"diagonal"</code> for residuals independent across time within
each patient. In MCMC (e.g. <code><a href="#topic+hbl_mcmc_hierarchical">hbl_mcmc_hierarchical()</a></code>),
the covariance structure affects computational speed.
Unstructured covariance is slower than AR(1), and AR(1) is slower
than diagonal. This is particularly true for <code>covariance_historical</code>
if there are many historical studies in the data.</p>
</td></tr>
<tr><td><code id="hbl_sim_independent_+3A_covariance_historical">covariance_historical</code></td>
<td>
<p>Same as <code>covariance_current</code>,
but for the covariance structure of each separate historical study.
Each historical study has its own separate covariance matrix.</p>
</td></tr>
<tr><td><code id="hbl_sim_independent_+3A_alpha">alpha</code></td>
<td>
<p>Numeric vector of length <code>n_rep</code> for the pooled
and model and length <code>n_study * n_rep</code> for the
independent and hierarchical models.
<code>alpha</code> is the vector of control group mean parameters.
<code>alpha</code> enters the model by multiplying with
<code style="white-space: pre;">&#8288;$matrices$x_alpha&#8288;</code> (see the return value).
The control group in the data is the one with the
<code>group</code> column equal to 1.</p>
</td></tr>
<tr><td><code id="hbl_sim_independent_+3A_delta">delta</code></td>
<td>
<p>Numeric vector of length
<code>(n_group - 1) * (n_rep - as.integer(constraint))</code>
of treatment effect parameters.
<code>delta</code> enters the model by multiplying with
<code style="white-space: pre;">&#8288;$matrices$x_delta&#8288;</code> (see the return value).
The control (non-treatment) group in the data is the one with the
<code>group</code> column equal to 1.</p>
</td></tr>
<tr><td><code id="hbl_sim_independent_+3A_beta">beta</code></td>
<td>
<p>Numeric vector of <code>n_study * (n_continuous + n_binary)</code>
fixed effect parameters. Within each study,
the first <code>n_continuous</code> betas
are for the continuous covariates, and the rest are for
the binary covariates. All the <code>beta</code>s for one study
appear before all the <code>beta</code>s for the next study,
and studies are arranged in increasing order of
the sorted unique values in <code style="white-space: pre;">&#8288;$data$study&#8288;</code> in the output.
<code>betas</code> enters the model by multiplying with
<code style="white-space: pre;">&#8288;$matrices$x_alpha&#8288;</code> (see the return value).</p>
</td></tr>
<tr><td><code id="hbl_sim_independent_+3A_sigma">sigma</code></td>
<td>
<p>Numeric vector of <code>n_study * n_rep</code>
residual standard deviation parameters for each study
and rep. The elements are sorted with all the standard deviations
of study 1 first (all the reps), then all the reps of study 2, etc.</p>
</td></tr>
<tr><td><code id="hbl_sim_independent_+3A_rho_current">rho_current</code></td>
<td>
<p>Numeric of length 1 between -1 and 1,
AR(1) residual correlation parameter for the current study.</p>
</td></tr>
<tr><td><code id="hbl_sim_independent_+3A_rho_historical">rho_historical</code></td>
<td>
<p>Numeric of length <code>n_study - 1</code> between -1 and 1,
AR(1) residual correlation parameters for the historical studies.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li> <p><code>data</code>: tidy long-form dataset with the patient-level data.
one row per patient per rep and indicator columns for the study,
group (e.g. treatment arm), patient ID, and rep. The <code>response</code>
columns is the patient response. The other columns are
baseline covariates. The control group is the one with
the <code>group</code> column equal to 1, and the current study (non-historical)
is the one with the maximum value of the <code>study</code> column.
Only the current study has any non-control-group patients,
the historical studies have only the control group.
</p>
</li>
<li> <p><code>parameters</code>: named list of model parameter values.
See the model specification vignette for details.
</p>
</li>
<li> <p><code>matrices</code>: A named list of model matrices.
See the model specification vignette for details.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other simulate: 
<code><a href="#topic+hbl_sim_hierarchical">hbl_sim_hierarchical</a>()</code>,
<code><a href="#topic+hbl_sim_pool">hbl_sim_pool</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hbl_sim_independent(n_continuous = 1)$data
</code></pre>

<hr>
<h2 id='hbl_sim_pool'>Longitudinal pooled simulations.</h2><span id='topic+hbl_sim_pool'></span>

<h3>Description</h3>

<p>Simulate from the longitudinal pooled model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hbl_sim_pool(
  n_study = 5,
  n_group = 3,
  n_patient = 100,
  n_rep = 4,
  n_continuous = 0,
  n_binary = 0,
  constraint = FALSE,
  s_alpha = 1,
  s_delta = 1,
  s_beta = 1,
  s_sigma = 1,
  s_lambda = 1,
  covariance_current = "unstructured",
  covariance_historical = "unstructured",
  alpha = stats::rnorm(n = n_rep, mean = 0, sd = s_alpha),
  delta = stats::rnorm(n = (n_group - 1) * (n_rep - as.integer(constraint)), mean = 0, sd
    = s_delta),
  beta = stats::rnorm(n = n_study * (n_continuous + n_binary), mean = 0, sd = s_delta),
  sigma = stats::runif(n = n_study * n_rep, min = 0, max = s_sigma),
  rho_current = stats::runif(n = 1, min = -1, max = 1),
  rho_historical = stats::runif(n = n_study - 1, min = -1, max = 1)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hbl_sim_pool_+3A_n_study">n_study</code></td>
<td>
<p>Number of studies to simulate.</p>
</td></tr>
<tr><td><code id="hbl_sim_pool_+3A_n_group">n_group</code></td>
<td>
<p>Number of groups (e.g. study arms) to simulate per study.</p>
</td></tr>
<tr><td><code id="hbl_sim_pool_+3A_n_patient">n_patient</code></td>
<td>
<p>Number of patients to simulate per study per group.</p>
</td></tr>
<tr><td><code id="hbl_sim_pool_+3A_n_rep">n_rep</code></td>
<td>
<p>Number of repeated measures (time points) per patient.</p>
</td></tr>
<tr><td><code id="hbl_sim_pool_+3A_n_continuous">n_continuous</code></td>
<td>
<p>Number of continuous covariates to simulate
(all from independent standard normal distributions).</p>
</td></tr>
<tr><td><code id="hbl_sim_pool_+3A_n_binary">n_binary</code></td>
<td>
<p>Number of binary covariates to simulate
(all from independent Bernoulli distributions with p = 0.5).</p>
</td></tr>
<tr><td><code id="hbl_sim_pool_+3A_constraint">constraint</code></td>
<td>
<p>Logical of length 1, whether to pool all study arms
at baseline (first rep). Appropriate when the response is the raw
response (as opposed to change from baseline) and the first rep
(i.e. time point) is prior to treatment.</p>
</td></tr>
<tr><td><code id="hbl_sim_pool_+3A_s_alpha">s_alpha</code></td>
<td>
<p>Numeric of length 1, prior standard deviation
of the study-specific control group mean parameters <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="hbl_sim_pool_+3A_s_delta">s_delta</code></td>
<td>
<p>Numeric of length 1, prior standard deviation
of the study-by-group effect parameters <code>delta</code>.</p>
</td></tr>
<tr><td><code id="hbl_sim_pool_+3A_s_beta">s_beta</code></td>
<td>
<p>Numeric of length 1, prior standard deviation
of the fixed effects <code>beta</code>.</p>
</td></tr>
<tr><td><code id="hbl_sim_pool_+3A_s_sigma">s_sigma</code></td>
<td>
<p>Numeric of length 1, prior upper bound
of the residual standard deviations.</p>
</td></tr>
<tr><td><code id="hbl_sim_pool_+3A_s_lambda">s_lambda</code></td>
<td>
<p>shape parameter of the LKJ priors
on the unstructured correlation matrices.</p>
</td></tr>
<tr><td><code id="hbl_sim_pool_+3A_covariance_current">covariance_current</code></td>
<td>
<p>Character of length 1,
covariance structure of the current study.
Possible values are <code>"unstructured"</code> for fully parameterized
covariance matrices, <code>"ar1"</code> for AR(1) covariance matrices,
and <code>"diagonal"</code> for residuals independent across time within
each patient. In MCMC (e.g. <code><a href="#topic+hbl_mcmc_hierarchical">hbl_mcmc_hierarchical()</a></code>),
the covariance structure affects computational speed.
Unstructured covariance is slower than AR(1), and AR(1) is slower
than diagonal. This is particularly true for <code>covariance_historical</code>
if there are many historical studies in the data.</p>
</td></tr>
<tr><td><code id="hbl_sim_pool_+3A_covariance_historical">covariance_historical</code></td>
<td>
<p>Same as <code>covariance_current</code>,
but for the covariance structure of each separate historical study.
Each historical study has its own separate covariance matrix.</p>
</td></tr>
<tr><td><code id="hbl_sim_pool_+3A_alpha">alpha</code></td>
<td>
<p>Numeric vector of length <code>n_rep</code> for the pooled
and model and length <code>n_study * n_rep</code> for the
independent and hierarchical models.
<code>alpha</code> is the vector of control group mean parameters.
<code>alpha</code> enters the model by multiplying with
<code style="white-space: pre;">&#8288;$matrices$x_alpha&#8288;</code> (see the return value).
The control group in the data is the one with the
<code>group</code> column equal to 1.</p>
</td></tr>
<tr><td><code id="hbl_sim_pool_+3A_delta">delta</code></td>
<td>
<p>Numeric vector of length
<code>(n_group - 1) * (n_rep - as.integer(constraint))</code>
of treatment effect parameters.
<code>delta</code> enters the model by multiplying with
<code style="white-space: pre;">&#8288;$matrices$x_delta&#8288;</code> (see the return value).
The control (non-treatment) group in the data is the one with the
<code>group</code> column equal to 1.</p>
</td></tr>
<tr><td><code id="hbl_sim_pool_+3A_beta">beta</code></td>
<td>
<p>Numeric vector of <code>n_study * (n_continuous + n_binary)</code>
fixed effect parameters. Within each study,
the first <code>n_continuous</code> betas
are for the continuous covariates, and the rest are for
the binary covariates. All the <code>beta</code>s for one study
appear before all the <code>beta</code>s for the next study,
and studies are arranged in increasing order of
the sorted unique values in <code style="white-space: pre;">&#8288;$data$study&#8288;</code> in the output.
<code>betas</code> enters the model by multiplying with
<code style="white-space: pre;">&#8288;$matrices$x_alpha&#8288;</code> (see the return value).</p>
</td></tr>
<tr><td><code id="hbl_sim_pool_+3A_sigma">sigma</code></td>
<td>
<p>Numeric vector of <code>n_study * n_rep</code>
residual standard deviation parameters for each study
and rep. The elements are sorted with all the standard deviations
of study 1 first (all the reps), then all the reps of study 2, etc.</p>
</td></tr>
<tr><td><code id="hbl_sim_pool_+3A_rho_current">rho_current</code></td>
<td>
<p>Numeric of length 1 between -1 and 1,
AR(1) residual correlation parameter for the current study.</p>
</td></tr>
<tr><td><code id="hbl_sim_pool_+3A_rho_historical">rho_historical</code></td>
<td>
<p>Numeric of length <code>n_study - 1</code> between -1 and 1,
AR(1) residual correlation parameters for the historical studies.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li> <p><code>data</code>: tidy long-form dataset with the patient-level data.
one row per patient per rep and indicator columns for the study,
group (e.g. treatment arm), patient ID, and rep. The <code>response</code>
columns is the patient response. The other columns are
baseline covariates. The control group is the one with
the <code>group</code> column equal to 1, and the current study (non-historical)
is the one with the maximum value of the <code>study</code> column.
Only the current study has any non-control-group patients,
the historical studies have only the control group.
</p>
</li>
<li> <p><code>parameters</code>: named list of model parameter values.
See the model specification vignette for details.
</p>
</li>
<li> <p><code>matrices</code>: A named list of model matrices.
See the model specification vignette for details.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other simulate: 
<code><a href="#topic+hbl_sim_hierarchical">hbl_sim_hierarchical</a>()</code>,
<code><a href="#topic+hbl_sim_independent">hbl_sim_independent</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hbl_sim_pool(n_continuous = 1)$data
</code></pre>

<hr>
<h2 id='hbl_summary'>Model summary</h2><span id='topic+hbl_summary'></span>

<h3>Description</h3>

<p>Summarize a fitted model in a table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hbl_summary(
  mcmc,
  data,
  response = "response",
  response_type = "raw",
  study = "study",
  study_reference = max(data[[study]]),
  group = "group",
  group_reference = min(data[[group]]),
  patient = "patient",
  rep = "rep",
  rep_reference = min(data[[rep]]),
  covariates = grep("^covariate", colnames(data), value = TRUE),
  constraint = FALSE,
  eoi = 0,
  direction = "&lt;"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hbl_summary_+3A_mcmc">mcmc</code></td>
<td>
<p>A wide data frame of posterior samples returned by
<code><a href="#topic+hbl_mcmc_hierarchical">hbl_mcmc_hierarchical()</a></code> or similar MCMC function.</p>
</td></tr>
<tr><td><code id="hbl_summary_+3A_data">data</code></td>
<td>
<p>Tidy data frame with one row per patient per rep,
indicator columns for the response variable,
study, group, patient, rep,
and covariates. All columns must be atomic vectors
(e.g. not lists).</p>
</td></tr>
<tr><td><code id="hbl_summary_+3A_response">response</code></td>
<td>
<p>Character of length 1,
name of the column in <code>data</code> with the response/outcome variable.
<code>data[[response]]</code> must be a continuous variable,
and it <em>should</em> be the change from baseline of a
clinical endpoint of interest, as opposed to just
the raw response. Treatment differences
are computed directly from this scale, please supply
change from baseline unless you are absolutely certain
that treatment differences computed directly from
this quantity are clinically meaningful.</p>
</td></tr>
<tr><td><code id="hbl_summary_+3A_response_type">response_type</code></td>
<td>
<p>Character of length 1: <code>"raw"</code> if the response
column in the data is the raw response, <code>"change"</code> if the response
columns is change from baseline. In the latter case, the <code style="white-space: pre;">&#8288;change_*&#8288;</code>
columns in the output table are omitted because the response
is already a change from baseline. Must be one of <code>"raw"</code> or <code>"change"</code>.</p>
</td></tr>
<tr><td><code id="hbl_summary_+3A_study">study</code></td>
<td>
<p>Character of length 1,
name of the column in <code>data</code> with the study ID.</p>
</td></tr>
<tr><td><code id="hbl_summary_+3A_study_reference">study_reference</code></td>
<td>
<p>Atomic of length 1,
element of the <code>study</code> column that indicates
the current study.
(The other studies are historical studies.)</p>
</td></tr>
<tr><td><code id="hbl_summary_+3A_group">group</code></td>
<td>
<p>Character of length 1,
name of the column in <code>data</code> with the group ID.</p>
</td></tr>
<tr><td><code id="hbl_summary_+3A_group_reference">group_reference</code></td>
<td>
<p>Atomic of length 1,
element of the <code>group</code> column that indicates
the control group.
(The other groups may be treatment groups.)</p>
</td></tr>
<tr><td><code id="hbl_summary_+3A_patient">patient</code></td>
<td>
<p>Character of length 1,
name of the column in <code>data</code> with the patient ID.</p>
</td></tr>
<tr><td><code id="hbl_summary_+3A_rep">rep</code></td>
<td>
<p>Character of length 1,
name of the column in <code>data</code> with the rep ID.</p>
</td></tr>
<tr><td><code id="hbl_summary_+3A_rep_reference">rep_reference</code></td>
<td>
<p>Atomic of length 1,
element of the <code>rep</code> column that indicates
baseline, i.e. the first rep chronologically.
(The other reps may be post-baseline study visits or time points.)</p>
</td></tr>
<tr><td><code id="hbl_summary_+3A_covariates">covariates</code></td>
<td>
<p>Character vector of column names
in <code>data</code> with the columns with baseline covariates.
These can be continuous, categorical, or binary.
Regardless, <code>historicalborrowlong</code> derives the appropriate
model matrix.
</p>
<p>Each baseline covariate column must truly be a <em>baseline</em> covariate:
elements must be equal for all time points within each patient
(after the steps in the &quot;Data processing&quot; section).
In other words, covariates must not be time-varying.
</p>
<p>A large number of covariates, or a large number of levels in a
categorical covariate, can severely slow down the computation.
Please consider carefully if you really need to include
such complicated baseline covariates.</p>
</td></tr>
<tr><td><code id="hbl_summary_+3A_constraint">constraint</code></td>
<td>
<p>Logical of length 1, whether to pool all study arms
at baseline (first rep). Appropriate when the response is the raw
response (as opposed to change from baseline) and the first rep
(i.e. time point) is prior to treatment.</p>
</td></tr>
<tr><td><code id="hbl_summary_+3A_eoi">eoi</code></td>
<td>
<p>Numeric of length at least 1,
vector of effects of interest (EOIs) for critical success factors (CSFs).</p>
</td></tr>
<tr><td><code id="hbl_summary_+3A_direction">direction</code></td>
<td>
<p>Character of length <code>length(eoi)</code> indicating how
to compare the treatment effect to each EOI. <code>"&gt;"</code> means
Prob(treatment effect &gt; EOI), and <code>"&lt;"</code> means
Prob(treatment effect &lt; EOI). All elements of <code>direction</code>
must be either <code>"&gt;"</code> or <code>"&lt;"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>hb_summary()</code> function post-processes the results from
the model. It estimates marginal means of the response,
treatment effect, and other quantities of interest.
</p>


<h3>Value</h3>

<p>A tidy data frame with one row per group (e.g. treatment arm)
and the columns in the following list. Unless otherwise specified,
the quantities are calculated at the group-by-rep level.
Some are calculated for the current (non-historical) study only,
while others pertain to the combined dataset which includes
all historical studies.
</p>

<ul>
<li> <p><code>group</code>: group index.
</p>
</li>
<li> <p><code>group_label</code>: original group label in the data.
</p>
</li>
<li> <p><code>rep</code>: rep index.
</p>
</li>
<li> <p><code>rep_label</code>: original rep label in the data.
</p>
</li>
<li> <p><code>data_mean</code>: observed mean of the response specific to the current
study.
</p>
</li>
<li> <p><code>data_sd</code>: observed standard deviation of the response
specific to the current study.
</p>
</li>
<li> <p><code>data_lower</code>: lower bound of a simple frequentist 95% confidence
interval of the observed data mean specific to the current study.
</p>
</li>
<li> <p><code>data_upper</code>: upper bound of a simple frequentist 95% confidence
interval of the observed data mean specific to the current study.
</p>
</li>
<li> <p><code>data_n</code>: number of non-missing observations in the combined dataset
(all studies).
</p>
</li>
<li> <p><code>data_N</code>: total number of observations (missing and non-missing)
in the combined dataset (all studies).
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;data_n_study_*&#8288;</code>: number of non-missing observations in each study.
The suffixes of these column names are integer study indexes.
Call <code>dplyr::distinct(hbl_data(your_data), study, study_label)</code>
to see which study labels correspond to these integer indexes.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;data_N_study_*&#8288;</code>: total number of observations
(missing and non-missing) within each study.
The suffixes of these column names are integer study indexes.
Call <code>dplyr::distinct(hbl_data(your_data), study, study_label)</code>
to see which study labels correspond to these integer indexes.
</p>
</li>
<li> <p><code>response_mean</code>: Estimated posterior mean of the response
from the model. (Here, the response variable in the data
should be a change from baseline outcome.)
Specific to the current study.
</p>
</li>
<li> <p><code>response_sd</code>: Estimated posterior standard deviation of the mean
response from the model.
Specific to the current study.
</p>
</li>
<li> <p><code>response_variance</code>: Estimated posterior variance of the mean
response from the model.
Specific to the current study.
</p>
</li>
<li> <p><code>response_lower</code>: Lower bound of a 95% posterior interval on the mean
response from the model.
Specific to the current study.
</p>
</li>
<li> <p><code>response_upper</code>: Upper bound of a 95% posterior interval on the mean
response from the model.
Specific to the current study.
</p>
</li>
<li> <p><code>response_mean_mcse</code>: Monte Carlo standard error of <code>response_mean</code>.
</p>
</li>
<li> <p><code>response_sd_mcse</code>: Monte Carlo standard error of <code>response_sd</code>.
</p>
</li>
<li> <p><code>response_lower_mcse</code>: Monte Carlo standard error of <code>response_lower</code>.
</p>
</li>
<li> <p><code>response_upper_mcse</code>: Monte Carlo standard error of <code>response_upper</code>.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;change_*&#8288;</code>: same as the <code style="white-space: pre;">&#8288;response_*&#8288;</code> columns, but for change
from baseline instead of the response. Not included if <code>response_type</code>
is <code>"change"</code> because in that case the response is already
change from baseline.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;change_percent_*&#8288;</code>: same as the <code style="white-space: pre;">&#8288;change_*&#8288;</code> columns, but for the
<em>percent</em> change from baseline (from 0% to 100%).
Not included if <code>response_type</code>
is <code>"change"</code> because in that case the response is already
change from baseline.
Specific to the current study.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;diff_*&#8288;</code>: same as the <code style="white-space: pre;">&#8288;response_*&#8288;</code> columns, but for treatment effect.
</p>
</li>
<li> <p><code>P(diff &gt; EOI)</code>, <code>P(diff &lt; EOI)</code>: CSF probabilities on the
treatment effect specified with the <code>eoi</code> and <code>direction</code>
arguments.
Specific to the current study.
</p>
</li>
<li> <p><code>effect_mean</code>: same as the <code style="white-space: pre;">&#8288;response_*&#8288;</code> columns, but for the effect size
(diff / residual standard deviation).
Specific to the current study.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;precision_ratio*&#8288;</code>: same as the <code style="white-space: pre;">&#8288;response_*&#8288;</code> columns,
but for the precision ratio, which compares within-study variance
to among-study variance. Only returned for the hierarchical model.
Specific to the current study.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other summary: 
<code><a href="#topic+hbl_ess">hbl_ess</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (!identical(Sys.getenv("HBL_TEST", unset = ""), "")) {
set.seed(0)
data &lt;- hbl_sim_pool(
  n_study = 2,
  n_group = 2,
  n_patient = 5,
  n_rep = 3
)$data
tmp &lt;- utils::capture.output(
  suppressWarnings(
    mcmc &lt;- hbl_mcmc_hierarchical(
      data,
      chains = 1,
      warmup = 10,
      iter = 20,
      seed = 0
    )
  )
)
hbl_summary(mcmc, data)
}
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
