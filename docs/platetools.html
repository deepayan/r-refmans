<!DOCTYPE html><html lang="en"><head><title>Help for package platetools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {platetools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#b_grid'><p>Plots multiple b-scored normalised platemaps</p></a></li>
<li><a href='#b_map'><p>Plots a heatmap of b-score normalised values in a plate layout</p></a></li>
<li><a href='#b_score'><p>2 way median polish</p></a></li>
<li><a href='#bhit_map'><p>Platemap to identify 'hits' following a B-score normalisation</p></a></li>
<li><a href='#check_plate_input'><p>checks plate input for dodgy well plate combinations</p></a></li>
<li><a href='#dist_map'><p>Plots distributions per well in a plate layout</p></a></li>
<li><a href='#fill_plate'><p>Fill in missing wells</p></a></li>
<li><a href='#hit_grid'><p>Plots multiple platemaps with and identifies hits</p></a></li>
<li><a href='#hit_map'><p>Platemap to identify 'hits' in a screen</p></a></li>
<li><a href='#is_1536'><p>internal 1536 plate function for plate_map</p></a></li>
<li><a href='#is_old_ggplot'><p>check ggplot2 version</p></a></li>
<li><a href='#legend_title'><p>change legend title</p></a></li>
<li><a href='#list_to_dataframe'><p>Converts list to a dataframe in a sensible way</p></a></li>
<li><a href='#med_smooth'><p>2-way median smooth</p></a></li>
<li><a href='#missing_wells'><p>Returns wells that are missing from a complete plate</p></a></li>
<li><a href='#num_to_well'><p>Converts numbers to well labels</p></a></li>
<li><a href='#pc_grid'><p>Plots multiple platemaps as a heatmap of the first principal component.</p></a></li>
<li><a href='#pc_map'><p>Principal component heatmap in a plate layout</p></a></li>
<li><a href='#pchit_grid'><p>Plots multiple heatmaps identifying hits from the first principal component</p></a></li>
<li><a href='#pchit_map'><p>Plots a heatmap identifying hits from the first principal component</p></a></li>
<li><a href='#plate_effect'><p>Two way-median smooth on a plate map</p></a></li>
<li><a href='#plate_map'><p>creates dataframe of row,column,data from wellID and data</p></a></li>
<li><a href='#plate_map_grid'><p>creates dataframe of row, column, plate_id from data regarding wellIDs</p></a></li>
<li><a href='#plate_map_grid_scale'><p>creates dataframe of row, column, plate_id from data regarding wellIDs</p></a></li>
<li><a href='#plate_map_multiple'><p>row, column for multiple features</p></a></li>
<li><a href='#plate_map_scale'><p>creates dataframe of row, column, and scaled data from well IDs</p></a></li>
<li><a href='#plate_matrix'><p>plate layout matrix from well IDs</p></a></li>
<li><a href='#plt12'><p>ggplot plate object</p></a></li>
<li><a href='#plt1536'><p>ggplot plate object</p></a></li>
<li><a href='#plt24'><p>ggplot plate object</p></a></li>
<li><a href='#plt384'><p>ggplot plate object</p></a></li>
<li><a href='#plt48'><p>ggplot plate object</p></a></li>
<li><a href='#plt6'><p>ggplot plate object</p></a></li>
<li><a href='#plt96'><p>ggplot plate object</p></a></li>
<li><a href='#raw_grid'><p>Plots multiple platemaps with heatmap of raw values</p></a></li>
<li><a href='#raw_map'><p>Plots a platemap with heatmap of raw values</p></a></li>
<li><a href='#read_map'><p>Annotates dataframe with metadata in a platemap matrix</p></a></li>
<li><a href='#readmap_data'><p>example data in a plate map form</p></a></li>
<li><a href='#rotate_plate'><p>rotates matrix by 180 degrees</p></a></li>
<li><a href='#set_block'><p>Set values in rectangular areas of a plate</p></a></li>
<li><a href='#well_to_num'><p>Converts well labels to numbers</p></a></li>
<li><a href='#z_grid'><p>Plots multiple platemaps with heatmap of scaled values</p></a></li>
<li><a href='#z_map'><p>Plots a platemap with heatmap of scaled values</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Tools and Plots for Multi-Well Plates</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.7</td>
</tr>
<tr>
<td>Description:</td>
<td>Collection of functions for working with multi-well microtitre
    plates, mainly 96, 384 and 1536 well plates.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/swarchal/platetools">https://github.com/swarchal/platetools</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/swarchal/platetools/issues">https://github.com/swarchal/platetools/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>RColorBrewer, ggplot2 (&ge; 2.2.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, viridis</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-07 16:29:21 UTC; warchas</td>
</tr>
<tr>
<td>Author:</td>
<td>Scott Warchal [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Scott Warchal &lt;scott.warchal@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-07 16:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='b_grid'>Plots multiple b-scored normalised platemaps</h2><span id='topic+b_grid'></span>

<h3>Description</h3>

<p>Transforms numerical values using the b-score normalisation process to
account for row and column effects. Uses well and plate labels to plot the
normalised values in the form of microtitre plates. Works for 96, 384 and
1536 well plates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>b_grid(
  data,
  well,
  plate_id,
  plate = 96,
  eps = 0.01,
  maxiter = 10,
  trace.iter = FALSE,
  na.rm = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="b_grid_+3A_data">data</code></td>
<td>
<p>Numerical values to be plotted</p>
</td></tr>
<tr><td><code id="b_grid_+3A_well">well</code></td>
<td>
<p>Vector of well identifiers e.g &quot;A01&quot;</p>
</td></tr>
<tr><td><code id="b_grid_+3A_plate_id">plate_id</code></td>
<td>
<p>Vector of plate identifiers e.g &quot;Plate_1&quot;</p>
</td></tr>
<tr><td><code id="b_grid_+3A_plate">plate</code></td>
<td>
<p>Number of wells in complete plate (96, 384 or 1536)</p>
</td></tr>
<tr><td><code id="b_grid_+3A_eps">eps</code></td>
<td>
<p>real number greater than 0. A tolerance for divergence</p>
</td></tr>
<tr><td><code id="b_grid_+3A_maxiter">maxiter</code></td>
<td>
<p>int, the maximum number of iterations</p>
</td></tr>
<tr><td><code id="b_grid_+3A_trace.iter">trace.iter</code></td>
<td>
<p>Boolean, should progress in convergence be reported?</p>
</td></tr>
<tr><td><code id="b_grid_+3A_na.rm">na.rm</code></td>
<td>
<p>Boolean, should missing values be removed?</p>
</td></tr>
<tr><td><code id="b_grid_+3A_...">...</code></td>
<td>
<p>additional parameters to plot wrappers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df01 &lt;- data.frame(well = num_to_well(1:96),
                   vals = rnorm(96),
                   plate = 1)

df02 &lt;- data.frame(well = num_to_well(1:96),
                   vals = rnorm(96),
                   plate = 2)

df &lt;- rbind(df01, df02)

b_grid(data = df$vals,
       well = df$well,
       plate_id = df$plate,
       plate = 96)
</code></pre>

<hr>
<h2 id='b_map'>Plots a heatmap of b-score normalised values in a plate layout</h2><span id='topic+b_map'></span>

<h3>Description</h3>

<p>Transforms numerical values using the b-score normalisation process to account
for row and column effects. Uses well labels to plot the normalised values in
the form of a microtitre plate. Works for 6, 12, 24, 48, 96, 384 or 1536 well plates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>b_map(
  data,
  well,
  normalise = FALSE,
  plate = 96,
  eps = 0.01,
  maxiter = 10,
  trace.iter = FALSE,
  na.rm = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="b_map_+3A_data">data</code></td>
<td>
<p>Numerical values in the form of a vector to be normalised</p>
</td></tr>
<tr><td><code id="b_map_+3A_well">well</code></td>
<td>
<p>Vector of well identifiers, e.g &quot;A01&quot;</p>
</td></tr>
<tr><td><code id="b_map_+3A_normalise">normalise</code></td>
<td>
<p>Boolean, if TRUE then the residual values will be divded by
the plate median absolute deviation as per Malo et al.</p>
</td></tr>
<tr><td><code id="b_map_+3A_plate">plate</code></td>
<td>
<p>integer, 6, 12, 24, 48, 96, 384 or 1536</p>
</td></tr>
<tr><td><code id="b_map_+3A_eps">eps</code></td>
<td>
<p>real number greater than 0. A tolerance for divergence</p>
</td></tr>
<tr><td><code id="b_map_+3A_maxiter">maxiter</code></td>
<td>
<p>int, the maximum number of iterations</p>
</td></tr>
<tr><td><code id="b_map_+3A_trace.iter">trace.iter</code></td>
<td>
<p>Boolean, should progress in convergence be reported?</p>
</td></tr>
<tr><td><code id="b_map_+3A_na.rm">na.rm</code></td>
<td>
<p>Boolean, should missing values be removed?</p>
</td></tr>
<tr><td><code id="b_map_+3A_...">...</code></td>
<td>
<p>additional parameters to plot wrappers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(well = num_to_well(1:96),
vals = rnorm(96))

b_map(data = df$vals,
     well = df$well,
     plate = 96)

df_384 &lt;- data.frame(
         well = num_to_well(1:384, plate = 384),
         vals = rnorm(384))

b_map(data = df_384$vals,
     well = df_384$well,
     plate = 384)
</code></pre>

<hr>
<h2 id='b_score'>2 way median polish</h2><span id='topic+b_score'></span>

<h3>Description</h3>

<p>2 way median polish to remove plate effects such as row/column/edge effects.
Given a dataframe containing alpha-numeric wellIDs and numerical values,
this <code>b_score</code> will return a dataframe of the same structure after
a two-way median smooth.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>b_score(data, well, plate, plate_id = NULL, normalise = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="b_score_+3A_data">data</code></td>
<td>
<p>numeric data, either a vector or dataframe column</p>
</td></tr>
<tr><td><code id="b_score_+3A_well">well</code></td>
<td>
<p>alpha-numeric wellIDs. e.g 'A01'</p>
</td></tr>
<tr><td><code id="b_score_+3A_plate">plate</code></td>
<td>
<p>numeric, number of wells within a plate</p>
</td></tr>
<tr><td><code id="b_score_+3A_plate_id">plate_id</code></td>
<td>
<p>Vector of plate_identifiers e.g &quot;plate_01&quot;</p>
</td></tr>
<tr><td><code id="b_score_+3A_normalise">normalise</code></td>
<td>
<p>Boolean, whether or not to divide by &lsquo;data'&rsquo;s MAD</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(well = num_to_well(1:96),
                 vals = rnorm(96))

b_score(data = df$vals,
        well = df$well,
        plate = 96)
</code></pre>

<hr>
<h2 id='bhit_map'>Platemap to identify 'hits' following a B-score normalisation</h2><span id='topic+bhit_map'></span>

<h3>Description</h3>

<p>Produces a platemap with colours indicating wells above or below selected threshold
after normalising for systematic plate effects via B-score smooth. The threshold is
definined calculated from a z-score, i.e plus or minus standard deviations from the
plate mean.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bhit_map(
  data,
  well,
  plate = 96,
  threshold = 2,
  palette = "Spectral",
  eps = 0.01,
  maxiter = 10,
  trace.iter = FALSE,
  na.rm = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bhit_map_+3A_data">data</code></td>
<td>
<p>Vector of numerical values</p>
</td></tr>
<tr><td><code id="bhit_map_+3A_well">well</code></td>
<td>
<p>Vector of well identifiers, e.g &quot;A01&quot;</p>
</td></tr>
<tr><td><code id="bhit_map_+3A_plate">plate</code></td>
<td>
<p>Number of wells in whole plate (96, 384 or 1536)</p>
</td></tr>
<tr><td><code id="bhit_map_+3A_threshold">threshold</code></td>
<td>
<p>Standard deviations from the plate average to indicate a hit.
default is set to +/- 2 SD.</p>
</td></tr>
<tr><td><code id="bhit_map_+3A_palette">palette</code></td>
<td>
<p>RColorBrewer palette</p>
</td></tr>
<tr><td><code id="bhit_map_+3A_eps">eps</code></td>
<td>
<p>real number greater than 0. A tolerance for divergence</p>
</td></tr>
<tr><td><code id="bhit_map_+3A_maxiter">maxiter</code></td>
<td>
<p>int, the maximum number of iterations</p>
</td></tr>
<tr><td><code id="bhit_map_+3A_trace.iter">trace.iter</code></td>
<td>
<p>Boolean, should progress in convergence be reported?</p>
</td></tr>
<tr><td><code id="bhit_map_+3A_na.rm">na.rm</code></td>
<td>
<p>Boolean, should missing values be removed?</p>
</td></tr>
<tr><td><code id="bhit_map_+3A_...">...</code></td>
<td>
<p>additional parameters to plot wrappers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(vals = rnorm(384),
   well = num_to_well(1:384, plate = 384))

bhit_map(data = df$vals,
   well = df$well,
   plate = 384,
   threshold = 3)
</code></pre>

<hr>
<h2 id='check_plate_input'>checks plate input for dodgy well plate combinations</h2><span id='topic+check_plate_input'></span>

<h3>Description</h3>

<p>checks plate input for dodgy well plate combinations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_plate_input(well, plate)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_plate_input_+3A_well">well</code></td>
<td>
<p>vector of well labels</p>
</td></tr>
<tr><td><code id="check_plate_input_+3A_plate">plate</code></td>
<td>
<p>integer, number of wells in full plate</p>
</td></tr>
</table>

<hr>
<h2 id='dist_map'>Plots distributions per well in a plate layout</h2><span id='topic+dist_map'></span>

<h3>Description</h3>

<p>Produces distribution plots facetted in a plate-layout format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_map(well, data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dist_map_+3A_well">well</code></td>
<td>
<p>vector of alphanumeric wellIDs e.g 'A01'</p>
</td></tr>
<tr><td><code id="dist_map_+3A_data">data</code></td>
<td>
<p>numeric vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot plot
</p>

<hr>
<h2 id='fill_plate'>Fill in missing wells</h2><span id='topic+fill_plate'></span>

<h3>Description</h3>

<p>Fills in missing wells with rows of NA values. Useful for any functions
that require a complete plate such as 'b_score'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fill_plate(df, well, plate = 96)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fill_plate_+3A_df">df</code></td>
<td>
<p>dataframe</p>
</td></tr>
<tr><td><code id="fill_plate_+3A_well">well</code></td>
<td>
<p>Column containing well identifiers i.e &quot;A01&quot;</p>
</td></tr>
<tr><td><code id="fill_plate_+3A_plate">plate</code></td>
<td>
<p>Number of wells in complete plate (96, 384 or 1536)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vals &lt;- rnorm(96) ; wells &lt;- num_to_well(1:96)
df &lt;- data.frame(wells, vals)
df_missing &lt;- df[-c(1:10), ]
fill_plate(df_missing, "wells")
</code></pre>

<hr>
<h2 id='hit_grid'>Plots multiple platemaps with and identifies hits</h2><span id='topic+hit_grid'></span>

<h3>Description</h3>

<p>Converts numerical values and well labels into 'hits' in the form of
multiple plate maps. Hits are calculated as wells above or below a
specified number of standard deviations from the overall average
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hit_grid(
  data,
  well,
  plate_id,
  threshold = 2,
  ncols = 2,
  plate = 96,
  each = FALSE,
  scale_each = FALSE,
  palette = "Spectral",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hit_grid_+3A_data">data</code></td>
<td>
<p>Numerical values to be scaled and plotted</p>
</td></tr>
<tr><td><code id="hit_grid_+3A_well">well</code></td>
<td>
<p>Vector of well identifiers. e.g &quot;A01&quot;</p>
</td></tr>
<tr><td><code id="hit_grid_+3A_plate_id">plate_id</code></td>
<td>
<p>Vector of plate identifiers e.g &quot;Plate_1&quot;</p>
</td></tr>
<tr><td><code id="hit_grid_+3A_threshold">threshold</code></td>
<td>
<p>Numerical value of standard deviations from the mean
for a well to be classified as a 'hit'. Default it +/- 2 SD</p>
</td></tr>
<tr><td><code id="hit_grid_+3A_ncols">ncols</code></td>
<td>
<p>Number of columns in the grid of plates</p>
</td></tr>
<tr><td><code id="hit_grid_+3A_plate">plate</code></td>
<td>
<p>Number of wells in the complete plates (96, 384 or 1536)</p>
</td></tr>
<tr><td><code id="hit_grid_+3A_each">each</code></td>
<td>
<p>boolean, allowed for backwards compatibility, <code>scale_each</code>
is now the preferred argument name</p>
</td></tr>
<tr><td><code id="hit_grid_+3A_scale_each">scale_each</code></td>
<td>
<p>boolean, if true scales each plate individually, if false
will scale the pooled values of <code>data</code></p>
</td></tr>
<tr><td><code id="hit_grid_+3A_palette">palette</code></td>
<td>
<p>RColorBrewer palette</p>
</td></tr>
<tr><td><code id="hit_grid_+3A_...">...</code></td>
<td>
<p>additional arguments for plot wrappers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df01 &lt;- data.frame(well = num_to_well(1:96),
  vals = rnorm(96),
  plate = 1)

df02 &lt;- data.frame(well = num_to_well(1:96),
  vals = rnorm(96),
  plate = 2)

df &lt;- rbind(df01, df02)

hit_grid(data = df$vals,
    well = df$well,
    plate_id = df$plate,
    plate = 96,
    each = FALSE)
</code></pre>

<hr>
<h2 id='hit_map'>Platemap to identify 'hits' in a screen</h2><span id='topic+hit_map'></span>

<h3>Description</h3>

<p>Produces a plot in the form of a micro-titre layout,
with colours indicating wells above or below a nominated threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hit_map(data, well, plate = 96, threshold = 2, palette = "Spectral", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hit_map_+3A_data">data</code></td>
<td>
<p>Vector of numerical values to score</p>
</td></tr>
<tr><td><code id="hit_map_+3A_well">well</code></td>
<td>
<p>Vector of well identifiers e.g &quot;A01&quot;</p>
</td></tr>
<tr><td><code id="hit_map_+3A_plate">plate</code></td>
<td>
<p>Number of wells in complete plate (6, 12, 24, 48, 96, 384 or 1536)</p>
</td></tr>
<tr><td><code id="hit_map_+3A_threshold">threshold</code></td>
<td>
<p>Numerical value of standard deviations from the mean
for a well to be classified as a 'hit'. Default it +/- 2 SD</p>
</td></tr>
<tr><td><code id="hit_map_+3A_palette">palette</code></td>
<td>
<p>RColorBrewer palette</p>
</td></tr>
<tr><td><code id="hit_map_+3A_...">...</code></td>
<td>
<p>additional parameters for plot wrappers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(vals = rnorm(1:384),
                 well = num_to_well(1:384, plate = 384))

hit_map(data = df$vals,
        well = df$well,
        plate = 384,
        threshold = 3)
</code></pre>

<hr>
<h2 id='is_1536'>internal 1536 plate function for plate_map</h2><span id='topic+is_1536'></span>

<h3>Description</h3>

<p>internal 1536 plate function for plate_map
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_1536(well)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_1536_+3A_well">well</code></td>
<td>
<p>vector of alphanumeric well labels</p>
</td></tr>
</table>

<hr>
<h2 id='is_old_ggplot'>check ggplot2 version</h2><span id='topic+is_old_ggplot'></span>

<h3>Description</h3>

<p>after ggplot2 v3.3.0, using scale_y_reverse() also reverses the order
of the ylim arguments in coord_fixed()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_old_ggplot()
</code></pre>

<hr>
<h2 id='legend_title'>change legend title</h2><span id='topic+legend_title'></span>

<h3>Description</h3>

<p>Change the legend title. This can be done in ggplot but there
are a million incomprehensible ways to do it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>legend_title(title)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="legend_title_+3A_title">title</code></td>
<td>
<p>string new title</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot object
</p>

<hr>
<h2 id='list_to_dataframe'>Converts list to a dataframe in a sensible way</h2><span id='topic+list_to_dataframe'></span>

<h3>Description</h3>

<p>Given a list of dataframes with the same columns, this function will row bind
them together, and if passed a <code>col_name</code> arguement, will produce a
column containing their original element name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_to_dataframe(l, col_name = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="list_to_dataframe_+3A_l">l</code></td>
<td>
<p>list of dataframes to be converted into single dataframe</p>
</td></tr>
<tr><td><code id="list_to_dataframe_+3A_col_name">col_name</code></td>
<td>
<p>(optional) name of column to put element names under</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe
</p>

<hr>
<h2 id='med_smooth'>2-way median smooth</h2><span id='topic+med_smooth'></span>

<h3>Description</h3>

<p>Given a platemap produced by <code>plate_map</code>, will return
a dataframe with after values have been transformed into
a matrix mirroring the plate structure and undergoing a
2-way median polish to remove row or column effects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>med_smooth(
  platemap,
  plate,
  eps = 0.01,
  maxiter = 10,
  trace.iter = FALSE,
  na.rm = TRUE,
  normalise = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="med_smooth_+3A_platemap">platemap</code></td>
<td>
<p>dataframe produced by <code>plate_map</code></p>
</td></tr>
<tr><td><code id="med_smooth_+3A_plate">plate</code></td>
<td>
<p>numeric, number of wells in plate, either 96 or 384</p>
</td></tr>
<tr><td><code id="med_smooth_+3A_eps">eps</code></td>
<td>
<p>real number greater than 0. A tolerance for divergence</p>
</td></tr>
<tr><td><code id="med_smooth_+3A_maxiter">maxiter</code></td>
<td>
<p>int, the maximum number of iterations</p>
</td></tr>
<tr><td><code id="med_smooth_+3A_trace.iter">trace.iter</code></td>
<td>
<p>Boolean, should progress in convergence be reported?</p>
</td></tr>
<tr><td><code id="med_smooth_+3A_na.rm">na.rm</code></td>
<td>
<p>Boolean, should missing values be removed?</p>
</td></tr>
<tr><td><code id="med_smooth_+3A_normalise">normalise</code></td>
<td>
<p>Boolean, should the data be divided by the MAD?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe consisting of two column, wellID and
polished numeric values
</p>

<hr>
<h2 id='missing_wells'>Returns wells that are missing from a complete plate</h2><span id='topic+missing_wells'></span>

<h3>Description</h3>

<p>Returns a vector of wells that are missing from a complete plate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>missing_wells(df, well, plate = 96)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="missing_wells_+3A_df">df</code></td>
<td>
<p>dataframe</p>
</td></tr>
<tr><td><code id="missing_wells_+3A_well">well</code></td>
<td>
<p>Column containing well identifiers i.e &quot;A01&quot;</p>
</td></tr>
<tr><td><code id="missing_wells_+3A_plate">plate</code></td>
<td>
<p>Number of wells in complete plate (96 or 384)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of missing wells
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vals &lt;- rnorm(96) ; wells &lt;- num_to_well(1:96)
df &lt;- data.frame(vals, wells)
df_missing &lt;- df[-c(1:10), ]
missing_wells(df_missing, "wells")
</code></pre>

<hr>
<h2 id='num_to_well'>Converts numbers to well labels</h2><span id='topic+num_to_well'></span>

<h3>Description</h3>

<p>Converts numerical values to corresponding alpha-numeric well labels
for 6, 12, 24, 48, 96, 384 or 1536 well plates.
Note, it's advisable to specify the number of wells in 'plate'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num_to_well(x, plate = 96)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="num_to_well_+3A_x">x</code></td>
<td>
<p>Vector of numbers to be converted</p>
</td></tr>
<tr><td><code id="num_to_well_+3A_plate">plate</code></td>
<td>
<p>Number of wells in complete plate (96 or 384)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of alpha-numeric well labels
</p>


<h3>Examples</h3>

<pre><code class='language-R'>num_to_well(1:96)
num_to_well(1:96, plate = 384)

nums &lt;- c(1:10, 20:40, 60:96)
num_to_well(nums)
</code></pre>

<hr>
<h2 id='pc_grid'>Plots multiple platemaps as a heatmap of the first principal component.</h2><span id='topic+pc_grid'></span>

<h3>Description</h3>

<p>Converts multivariate data and well labels into a heatmap of the first
principal component in the form of a grid of platemaps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pc_grid(data, well, plate_id, ncols = 2, plate = 96, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pc_grid_+3A_data">data</code></td>
<td>
<p>Numerical values be transformed, scaled and plotted as a colour</p>
</td></tr>
<tr><td><code id="pc_grid_+3A_well">well</code></td>
<td>
<p>Vector of well identifiers e.g &quot;A01&quot;</p>
</td></tr>
<tr><td><code id="pc_grid_+3A_plate_id">plate_id</code></td>
<td>
<p>Vector of plate labels or identifiers e.g &quot;plate_1&quot;</p>
</td></tr>
<tr><td><code id="pc_grid_+3A_ncols">ncols</code></td>
<td>
<p>Number of columns to plot multiple platemaps</p>
</td></tr>
<tr><td><code id="pc_grid_+3A_plate">plate</code></td>
<td>
<p>Number of wells in complete plate (96, 384 or 1536)</p>
</td></tr>
<tr><td><code id="pc_grid_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to z_grid</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df01 &lt;- data.frame(
  well = num_to_well(1:96),
  plate = 1,
  vals1 = rnorm(1:96),
  vals2 = rnorm(1:96))

df02 &lt;- data.frame(
  well = num_to_well(1:96),
  plate = 2,
  vals1 = rnorm(1:96),
  vals2 = rnorm(1:96))

df &lt;- rbind(df01, df02)

pc_grid(data = df[, 3:4],
        well = df$well,
        plate_id = df$plate,
        plate = 96)
</code></pre>

<hr>
<h2 id='pc_map'>Principal component heatmap in a plate layout</h2><span id='topic+pc_map'></span>

<h3>Description</h3>

<p>Takes the values and well identifiers, calculates the first principal
component, scales and plots the component as a heatmap in the form of
a 96 or 384-well plate. A way to quickly show variation of
multi-parametric data within a plate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pc_map(data, well, plate = 96, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pc_map_+3A_data">data</code></td>
<td>
<p>Vector of numerical data to calculate the first principal component</p>
</td></tr>
<tr><td><code id="pc_map_+3A_well">well</code></td>
<td>
<p>Vector of well identifiers e.g &quot;A01&quot;</p>
</td></tr>
<tr><td><code id="pc_map_+3A_plate">plate</code></td>
<td>
<p>Number of wells in complete plate (96, 384 or 1536</p>
</td></tr>
<tr><td><code id="pc_map_+3A_...">...</code></td>
<td>
<p>additional parameters to platetools::z_map</p>
</td></tr>
</table>


<h3>Value</h3>

<p>gplot plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(
  well = num_to_well(1:96),
  vals1 = rnorm(1:96),
  vals2 = rnorm(1:96))

pc_map(data = df[, 2:3],
       well = df$well,
       plate = 96)
</code></pre>

<hr>
<h2 id='pchit_grid'>Plots multiple heatmaps identifying hits from the first principal component</h2><span id='topic+pchit_grid'></span>

<h3>Description</h3>

<p>Converts numerical values, well labels, and plate labels into multiple heatmaps
of plates, with z-scored principal components coloured dependent on a specified
threshold of standard deviations above or below the average.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pchit_grid(data, well, plate_id, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pchit_grid_+3A_data">data</code></td>
<td>
<p>Numerical values, either a dataframe or a matrix</p>
</td></tr>
<tr><td><code id="pchit_grid_+3A_well">well</code></td>
<td>
<p>Vector of well identifers e.g &quot;A01&quot;</p>
</td></tr>
<tr><td><code id="pchit_grid_+3A_plate_id">plate_id</code></td>
<td>
<p>Vector of plate identifiers e.g &quot;Plate_1&quot;</p>
</td></tr>
<tr><td><code id="pchit_grid_+3A_...">...</code></td>
<td>
<p>additional arguments to 'platetools::hit_grid()'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df01 &lt;- data.frame(
  well = num_to_well(1:96),
  plate = 1,
  vals1 = rnorm(1:96),
  vals2 = rnorm(1:96))

df02 &lt;- data.frame(
  well = num_to_well(1:96),
  plate = 2,
  vals1 = rnorm(1:96),
  vals2 = rnorm(1:96))

df &lt;- rbind(df01, df02)

pchit_grid(data = df[,3:4],
           well = df$well,
           plate_id = df$plate,
           plate = 96)
</code></pre>

<hr>
<h2 id='pchit_map'>Plots a heatmap identifying hits from the first principal component</h2><span id='topic+pchit_map'></span>

<h3>Description</h3>

<p>Converts numerical values  and plate labels intoa plate heatmap
with z-scored principal components coloured dependent on a specified
threshold of standard deviations above or below the average.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pchit_map(data, well, plate = 96, threshold = 2, palette = "Spectral", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pchit_map_+3A_data">data</code></td>
<td>
<p>Numerical values, either a dataframe or a matrix</p>
</td></tr>
<tr><td><code id="pchit_map_+3A_well">well</code></td>
<td>
<p>Vector of well identifers e.g &quot;A01&quot;</p>
</td></tr>
<tr><td><code id="pchit_map_+3A_plate">plate</code></td>
<td>
<p>Number of wells in complete plate (96, 384 or 1536)</p>
</td></tr>
<tr><td><code id="pchit_map_+3A_threshold">threshold</code></td>
<td>
<p>Threshold of +/- standard deviations form the average
to determine a hit</p>
</td></tr>
<tr><td><code id="pchit_map_+3A_palette">palette</code></td>
<td>
<p>RColorBrewer palette</p>
</td></tr>
<tr><td><code id="pchit_map_+3A_...">...</code></td>
<td>
<p>additional arguments to platetools::hit_map</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>v1 &lt;- rnorm(1:96)
v2 &lt;- rnorm(1:96)
v3 &lt;- rnorm(1:96)
wells &lt;- num_to_well(1:96)
df &lt;- data.frame(wells, v1, v2, v3)


pchit_map(data = df[, 2:4],
          well = df$wells,
          threshold = 1.5)
</code></pre>

<hr>
<h2 id='plate_effect'>Two way-median smooth on a plate map</h2><span id='topic+plate_effect'></span>

<h3>Description</h3>

<p>Given a platemap produced by <code>plate_map</code>, this will perform
a two way median smooth, and return the results of <code>medpolish</code>.
Useful for row and column effects, as well as the raw residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plate_effect(platemap, plate)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plate_effect_+3A_platemap">platemap</code></td>
<td>
<p>platemap produced by <code>plate_map</code></p>
</td></tr>
<tr><td><code id="plate_effect_+3A_plate">plate</code></td>
<td>
<p>integer, the number of wells in a single plate</p>
</td></tr>
</table>

<hr>
<h2 id='plate_map'>creates dataframe of row,column,data from wellID and data</h2><span id='topic+plate_map'></span>

<h3>Description</h3>

<p>internal function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plate_map(data, well)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plate_map_+3A_data">data</code></td>
<td>
<p>numeric data to be used as colour scale</p>
</td></tr>
<tr><td><code id="plate_map_+3A_well">well</code></td>
<td>
<p>alpha-numeric well IDs, e.g 'A01'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe
</p>

<hr>
<h2 id='plate_map_grid'>creates dataframe of row, column, plate_id from data regarding wellIDs</h2><span id='topic+plate_map_grid'></span>

<h3>Description</h3>

<p>internal function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plate_map_grid(data, well, plate_id)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plate_map_grid_+3A_data">data</code></td>
<td>
<p>numerical data to be used as colour scale</p>
</td></tr>
<tr><td><code id="plate_map_grid_+3A_well">well</code></td>
<td>
<p>alpha-numeric wellIDs, e.g 'A01'</p>
</td></tr>
<tr><td><code id="plate_map_grid_+3A_plate_id">plate_id</code></td>
<td>
<p>plate identifers e.g 'plate_1'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe
</p>

<hr>
<h2 id='plate_map_grid_scale'>creates dataframe of row, column, plate_id from data regarding wellIDs</h2><span id='topic+plate_map_grid_scale'></span>

<h3>Description</h3>

<p>internal function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plate_map_grid_scale(data, well, plate_id, each)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plate_map_grid_scale_+3A_data">data</code></td>
<td>
<p>numerical data to be used as colour scale</p>
</td></tr>
<tr><td><code id="plate_map_grid_scale_+3A_well">well</code></td>
<td>
<p>alpha-numeric wellIDs, e.g 'A01'</p>
</td></tr>
<tr><td><code id="plate_map_grid_scale_+3A_plate_id">plate_id</code></td>
<td>
<p>plate identifers e.g 'plate_1'</p>
</td></tr>
<tr><td><code id="plate_map_grid_scale_+3A_each">each</code></td>
<td>
<p>boolean, if true scales each plate individually, if false will
scale the pooled values of <code>data</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe
</p>

<hr>
<h2 id='plate_map_multiple'>row, column for multiple features</h2><span id='topic+plate_map_multiple'></span>

<h3>Description</h3>

<p>Generates a dataframe for multiple features, given a wellID column and multiple
features
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plate_map_multiple(data, well)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plate_map_multiple_+3A_data">data</code></td>
<td>
<p>vector or dataframe of numeric data</p>
</td></tr>
<tr><td><code id="plate_map_multiple_+3A_well">well</code></td>
<td>
<p>vector of alphanumeric well IDs e.g 'A01'</p>
</td></tr>
</table>

<hr>
<h2 id='plate_map_scale'>creates dataframe of row, column, and scaled data from well IDs</h2><span id='topic+plate_map_scale'></span>

<h3>Description</h3>

<p>internal function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plate_map_scale(data, well)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plate_map_scale_+3A_data">data</code></td>
<td>
<p>numeric data to be used as colour scale</p>
</td></tr>
<tr><td><code id="plate_map_scale_+3A_well">well</code></td>
<td>
<p>alpha-numeric well IDs, e.g 'A01'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe
</p>

<hr>
<h2 id='plate_matrix'>plate layout matrix from well IDs</h2><span id='topic+plate_matrix'></span>

<h3>Description</h3>

<p>Given a dataframe of alpha-numeric well IDs e.g (&quot;A01&quot;), and values,
this function will produce a matrix in the form of a plate layout.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plate_matrix(data, well, plate = 96)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plate_matrix_+3A_data">data</code></td>
<td>
<p>vector of data to be placed in matrix</p>
</td></tr>
<tr><td><code id="plate_matrix_+3A_well">well</code></td>
<td>
<p>vector of alphanumeric well IDs. e.g (&quot;A01&quot;)</p>
</td></tr>
<tr><td><code id="plate_matrix_+3A_plate">plate</code></td>
<td>
<p>number of wells in plate (6, 12, 24, 48, 96 or 384, 1536)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- 1:96
wells &lt;- num_to_well(1:96)
plate_matrix(data = a, well = wells)

x &lt;- rnorm(384)
wells &lt;- num_to_well(1:384, plate = 384)
plate_matrix(data = x, well = wells, plate = 384)
</code></pre>

<hr>
<h2 id='plt12'>ggplot plate object</h2><span id='topic+plt12'></span>

<h3>Description</h3>

<p>internal function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plt12(
  platemap,
  size = 38,
  shape = 21,
  na_fill = "white",
  na_alpha = 0.1,
  na_size_ratio = 0.9
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plt12_+3A_platemap">platemap</code></td>
<td>
<p>platemap dataframe produced by <code>plate_map</code></p>
</td></tr>
<tr><td><code id="plt12_+3A_size">size</code></td>
<td>
<p>int, size parameter for ggplot2::geom_point</p>
</td></tr>
<tr><td><code id="plt12_+3A_shape">shape</code></td>
<td>
<p>int, shape parameter for ggplot2::geom_point</p>
</td></tr>
<tr><td><code id="plt12_+3A_na_fill">na_fill</code></td>
<td>
<p>string, fill colour for na or missing values</p>
</td></tr>
<tr><td><code id="plt12_+3A_na_alpha">na_alpha</code></td>
<td>
<p>float, alpha transparancy for missing or na values</p>
</td></tr>
<tr><td><code id="plt12_+3A_na_size_ratio">na_size_ratio</code></td>
<td>
<p>float, size ratio for missing values, set to 1 for same
size as normal values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot object
</p>

<hr>
<h2 id='plt1536'>ggplot plate object</h2><span id='topic+plt1536'></span>

<h3>Description</h3>

<p>internal function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plt1536(
  platemap,
  size = 3.5,
  shape = 22,
  na_fill = "white",
  na_size_ratio = 0.95,
  na_alpha = 0.1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plt1536_+3A_platemap">platemap</code></td>
<td>
<p>platemap dataframe produced by <code>plate_map</code></p>
</td></tr>
<tr><td><code id="plt1536_+3A_size">size</code></td>
<td>
<p>int, size parameter for ggplot2::geom_point</p>
</td></tr>
<tr><td><code id="plt1536_+3A_shape">shape</code></td>
<td>
<p>int, shape parameter for ggplot2::geom_point</p>
</td></tr>
<tr><td><code id="plt1536_+3A_na_fill">na_fill</code></td>
<td>
<p>string, fill colour for na or missing values</p>
</td></tr>
<tr><td><code id="plt1536_+3A_na_size_ratio">na_size_ratio</code></td>
<td>
<p>float, size ratio for missing values, set to 1 for same
size as normal values.</p>
</td></tr>
<tr><td><code id="plt1536_+3A_na_alpha">na_alpha</code></td>
<td>
<p>float, alpha transparancy for missing or na values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot object
</p>

<hr>
<h2 id='plt24'>ggplot plate object</h2><span id='topic+plt24'></span>

<h3>Description</h3>

<p>internal function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plt24(
  platemap,
  size = 26,
  shape = 21,
  na_fill = "white",
  na_size_ratio = 0.9,
  na_alpha = 0.1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plt24_+3A_platemap">platemap</code></td>
<td>
<p>platemap dataframe produced by <code>plate_map</code></p>
</td></tr>
<tr><td><code id="plt24_+3A_size">size</code></td>
<td>
<p>int, size parameter for ggplot2::geom_point</p>
</td></tr>
<tr><td><code id="plt24_+3A_shape">shape</code></td>
<td>
<p>int, shape parameter for ggplot2::geom_point</p>
</td></tr>
<tr><td><code id="plt24_+3A_na_fill">na_fill</code></td>
<td>
<p>string, fill colour for na or missing values</p>
</td></tr>
<tr><td><code id="plt24_+3A_na_size_ratio">na_size_ratio</code></td>
<td>
<p>float, size ratio for missing values, set to 1 for same
size as normal values.</p>
</td></tr>
<tr><td><code id="plt24_+3A_na_alpha">na_alpha</code></td>
<td>
<p>float, alpha transparancy for missing or na values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot object
</p>

<hr>
<h2 id='plt384'>ggplot plate object</h2><span id='topic+plt384'></span>

<h3>Description</h3>

<p>internal function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plt384(
  platemap,
  size = 5,
  shape = 22,
  na_fill = "white",
  na_size_ratio = 0.95,
  na_alpha = 0.1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plt384_+3A_platemap">platemap</code></td>
<td>
<p>platemap dataframe produced by <code>plate_map</code></p>
</td></tr>
<tr><td><code id="plt384_+3A_size">size</code></td>
<td>
<p>int, size parameter for ggplot2::geom_point</p>
</td></tr>
<tr><td><code id="plt384_+3A_shape">shape</code></td>
<td>
<p>int, shape parameter for ggplot2::geom_point</p>
</td></tr>
<tr><td><code id="plt384_+3A_na_fill">na_fill</code></td>
<td>
<p>string, fill colour for na or missing values</p>
</td></tr>
<tr><td><code id="plt384_+3A_na_size_ratio">na_size_ratio</code></td>
<td>
<p>float, size ratio for missing values, set to 1 for same
size as normal values.</p>
</td></tr>
<tr><td><code id="plt384_+3A_na_alpha">na_alpha</code></td>
<td>
<p>float, alpha transparancy for missing or na values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot object
</p>

<hr>
<h2 id='plt48'>ggplot plate object</h2><span id='topic+plt48'></span>

<h3>Description</h3>

<p>internal function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plt48(
  platemap,
  size = 18,
  shape = 21,
  na_fill = "white",
  na_size_ratio = 0.9,
  na_alpha = 0.1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plt48_+3A_platemap">platemap</code></td>
<td>
<p>platemap dataframe produced by <code>plate_map</code></p>
</td></tr>
<tr><td><code id="plt48_+3A_size">size</code></td>
<td>
<p>int, size parameter for ggplot2::geom_point</p>
</td></tr>
<tr><td><code id="plt48_+3A_shape">shape</code></td>
<td>
<p>int, shape parameter for ggplot2::geom_point</p>
</td></tr>
<tr><td><code id="plt48_+3A_na_fill">na_fill</code></td>
<td>
<p>string, fill colour for na or missing values</p>
</td></tr>
<tr><td><code id="plt48_+3A_na_size_ratio">na_size_ratio</code></td>
<td>
<p>float, size ratio for missing values, set to 1 for same
size as normal values.</p>
</td></tr>
<tr><td><code id="plt48_+3A_na_alpha">na_alpha</code></td>
<td>
<p>float, alpha transparancy for missing or na values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot object
</p>

<hr>
<h2 id='plt6'>ggplot plate object</h2><span id='topic+plt6'></span>

<h3>Description</h3>

<p>internal function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plt6(
  platemap,
  size = 50,
  shape = 21,
  na_fill = "white",
  na_alpha = 0.1,
  na_size_ratio = 0.9
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plt6_+3A_platemap">platemap</code></td>
<td>
<p>platemap dataframe produced by <code>plate_map</code></p>
</td></tr>
<tr><td><code id="plt6_+3A_size">size</code></td>
<td>
<p>int, size parameter for ggplot2::geom_point</p>
</td></tr>
<tr><td><code id="plt6_+3A_shape">shape</code></td>
<td>
<p>int, shape parameter for ggplot2::geom_point</p>
</td></tr>
<tr><td><code id="plt6_+3A_na_fill">na_fill</code></td>
<td>
<p>string, fill colour for na or missing values</p>
</td></tr>
<tr><td><code id="plt6_+3A_na_alpha">na_alpha</code></td>
<td>
<p>float, alpha transparancy for missing or na values</p>
</td></tr>
<tr><td><code id="plt6_+3A_na_size_ratio">na_size_ratio</code></td>
<td>
<p>float, size ratio for missing values, set to 1 for same
size as normal values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot object
</p>

<hr>
<h2 id='plt96'>ggplot plate object</h2><span id='topic+plt96'></span>

<h3>Description</h3>

<p>internal function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plt96(
  platemap,
  size = 10,
  shape = 21,
  na_fill = "white",
  na_size_ratio = 0.9,
  na_alpha = 0.1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plt96_+3A_platemap">platemap</code></td>
<td>
<p>platemap dataframe produced by <code>plate_map</code></p>
</td></tr>
<tr><td><code id="plt96_+3A_size">size</code></td>
<td>
<p>int, size parameter for ggplot2::geom_point</p>
</td></tr>
<tr><td><code id="plt96_+3A_shape">shape</code></td>
<td>
<p>int, shape parameter for ggplot2::geom_point</p>
</td></tr>
<tr><td><code id="plt96_+3A_na_fill">na_fill</code></td>
<td>
<p>string, fill colour for na or missing values</p>
</td></tr>
<tr><td><code id="plt96_+3A_na_size_ratio">na_size_ratio</code></td>
<td>
<p>float, size ratio for missing values, set to 1 for same
size as normal values.</p>
</td></tr>
<tr><td><code id="plt96_+3A_na_alpha">na_alpha</code></td>
<td>
<p>float, alpha transparancy for missing or na values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot object
</p>

<hr>
<h2 id='raw_grid'>Plots multiple platemaps with heatmap of raw values</h2><span id='topic+raw_grid'></span>

<h3>Description</h3>

<p>Converts numerical values. well labels, and plate labels into multiple
plate heatmaps
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raw_grid(data, well, plate_id, ncols = 2, plate = 96, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="raw_grid_+3A_data">data</code></td>
<td>
<p>Numerical values to be plotted</p>
</td></tr>
<tr><td><code id="raw_grid_+3A_well">well</code></td>
<td>
<p>Vector of well identifiers e.g &quot;A01&quot;</p>
</td></tr>
<tr><td><code id="raw_grid_+3A_plate_id">plate_id</code></td>
<td>
<p>Vector of plate identifiers e.g &quot;Plate_1&quot;</p>
</td></tr>
<tr><td><code id="raw_grid_+3A_ncols">ncols</code></td>
<td>
<p>Number of columns to display multiple heatmaps</p>
</td></tr>
<tr><td><code id="raw_grid_+3A_plate">plate</code></td>
<td>
<p>Number of wells in complete plate (96, 384 or 1536)</p>
</td></tr>
<tr><td><code id="raw_grid_+3A_...">...</code></td>
<td>
<p>additional parameters to plot wrappers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df01 &lt;- data.frame(well = num_to_well(1:96),
  vals = rnorm(96),
  plate = 1)

df02 &lt;- data.frame(well = num_to_well(1:96),
  vals = rnorm(96),
  plate = 2)

df &lt;- rbind(df01, df02)

raw_grid(data = df$vals,
    well = df$well,
    plate_id = df$plate,
    plate = 96)
</code></pre>

<hr>
<h2 id='raw_map'>Plots a platemap with heatmap of raw values</h2><span id='topic+raw_map'></span>

<h3>Description</h3>

<p>Converts numerical values and  well labels into multiple plate heatmaps
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raw_map(data, well, plate = 96, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="raw_map_+3A_data">data</code></td>
<td>
<p>Numerical values to be plotted</p>
</td></tr>
<tr><td><code id="raw_map_+3A_well">well</code></td>
<td>
<p>Vector of well identifiers e.g &quot;A01&quot;</p>
</td></tr>
<tr><td><code id="raw_map_+3A_plate">plate</code></td>
<td>
<p>Number of wells in complete plate (6, 12, 24, 48, 96, 384 or 1536)</p>
</td></tr>
<tr><td><code id="raw_map_+3A_...">...</code></td>
<td>
<p>additional parameters to plot wrappers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(vals = rnorm(1:384),
  well = num_to_well(1:384, plate = 384))

raw_map(data = df$vals,
        well = df$well,
        plate = 384)
</code></pre>

<hr>
<h2 id='read_map'>Annotates dataframe with metadata in a platemap matrix</h2><span id='topic+read_map'></span>

<h3>Description</h3>

<p>Annotates a dataframe containined well identifiers with metadata in the
form of a platemap matrix, matching the existing well-labels to the well
position in the platemap
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_map(data, map, verbose = TRUE, new_col_name = "header")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_map_+3A_data">data</code></td>
<td>
<p>existing daatframe, with wellIDs under the column name of 'well'</p>
</td></tr>
<tr><td><code id="read_map_+3A_map">map</code></td>
<td>
<p>Matrix of metadata to be added to the dataframe, N.B NO MISSING WELLS!</p>
</td></tr>
<tr><td><code id="read_map_+3A_verbose">verbose</code></td>
<td>
<p>Boolean, if TRUE will add row and column numbers to dataframe</p>
</td></tr>
<tr><td><code id="read_map_+3A_new_col_name">new_col_name</code></td>
<td>
<p>What to call the added metadata</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe with new column named after 'new_col_name'
</p>

<hr>
<h2 id='readmap_data'>example data in a plate map form</h2><span id='topic+readmap_data'></span>

<h3>Description</h3>

<p>example data in a plate map form
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readmap_data
</code></pre>


<h3>Format</h3>

<p>96 integers structured in a the form of a 96-well plate
</p>


<h3>Source</h3>

<p>none
</p>

<hr>
<h2 id='rotate_plate'>rotates matrix by 180 degrees</h2><span id='topic+rotate_plate'></span>

<h3>Description</h3>

<p>If someone (no names) puts in a plate upside down, this function 
will rotate a plate matrix produced by <code>plate_matrix</code> to be
the correct way up. I.e if A01 is in the bottom right hand corner rather
than the top left.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotate_plate(m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rotate_plate_+3A_m">m</code></td>
<td>
<p>matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix
</p>

<hr>
<h2 id='set_block'>Set values in rectangular areas of a plate</h2><span id='topic+set_block'></span>

<h3>Description</h3>

<p>Updates a table representing a multiwell plate, by setting a given value
for all wells in a block or a list of blocks defined by the well coordinates
of their upper-left and bottom-right corners.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_block(plate, block, what, value)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_block_+3A_plate">plate</code></td>
<td>
<p>A table representing a multiwell plate, with one column
named &ldquo;well&rdquo; representing the well identifiers.</p>
</td></tr>
<tr><td><code id="set_block_+3A_block">block</code></td>
<td>
<p>Coordinates of a rectangular block (such as &ldquo;A01~B02&rdquo;),
or a vector of coordinates.</p>
</td></tr>
<tr><td><code id="set_block_+3A_what">what</code></td>
<td>
<p>A column name in the table.</p>
</td></tr>
<tr><td><code id="set_block_+3A_value">value</code></td>
<td>
<p>The value to set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the &lsquo;<code>plate</code>&rsquo; table, where the values for
the wells indicated in the blocks have been updated.
</p>


<h3>Author(s)</h3>

<p>Charles Plessy
</p>


<h3>See Also</h3>

<p><code><a href="#topic+num_to_well">num_to_well</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- data.frame(well = num_to_well(1:96))
head(p)

p &lt;- set_block(p, c("A01~B02", "A05~D05"), "dNTP", 0.25)
p &lt;- set_block(p,   "A03",                 "dNTP", 0.50)
head(p)

# Be careful with the column names
p &lt;- set_block(p, "A01~H12", "Mg2+", 3.0)
head(p)

## Not run: 
# Chained updates with magrittr
p %&lt;&gt;%
  setBlock("A01~C04", "dNTP", 0.5) %&gt;%
  setBlock("A01~C04", "Mg",   3.0)

## End(Not run)

</code></pre>

<hr>
<h2 id='well_to_num'>Converts well labels to numbers</h2><span id='topic+well_to_num'></span>

<h3>Description</h3>

<p>Converts alpha-numeric well labels to numbers corresponding to positions
within a microtitre plate. Either 96 or 384 well plate, in column-wise order
or in a column snaking pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>well_to_num(wells, style = "normal", plate = 96)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="well_to_num_+3A_wells">wells</code></td>
<td>
<p>Vector of well identifiers e.g &quot;A01&quot;</p>
</td></tr>
<tr><td><code id="well_to_num_+3A_style">style</code></td>
<td>
<p>Either normal, starting at the left hand column at each row
or in a snaking fashion. ('normal' or 'snake')</p>
</td></tr>
<tr><td><code id="well_to_num_+3A_plate">plate</code></td>
<td>
<p>Number of wells in the complete plate (96 or 384)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of numbers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>well_to_num("A01")

well_to_num("P12", plate = 384)

well_to_num("P12", plate = 384, style = "snake")

wells &lt;- c("A01", "A02", "A03")
well_to_num(wells)
</code></pre>

<hr>
<h2 id='z_grid'>Plots multiple platemaps with heatmap of scaled values</h2><span id='topic+z_grid'></span>

<h3>Description</h3>

<p>Converts numerical values. well labels, and plate labels into multiple
plate heatmaps
</p>


<h3>Usage</h3>

<pre><code class='language-R'>z_grid(
  data,
  well,
  plate_id,
  ncols = 2,
  plate = 96,
  each = FALSE,
  scale_each = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="z_grid_+3A_data">data</code></td>
<td>
<p>Numerical values to be plotted</p>
</td></tr>
<tr><td><code id="z_grid_+3A_well">well</code></td>
<td>
<p>Vector of well identifiers e.g &quot;A01&quot;</p>
</td></tr>
<tr><td><code id="z_grid_+3A_plate_id">plate_id</code></td>
<td>
<p>Vector of plate identifiers e.g &quot;Plate_1&quot;</p>
</td></tr>
<tr><td><code id="z_grid_+3A_ncols">ncols</code></td>
<td>
<p>Number of columns to display multiple heatmaps</p>
</td></tr>
<tr><td><code id="z_grid_+3A_plate">plate</code></td>
<td>
<p>Number of wells in complete plate (96, 384 or 1569)</p>
</td></tr>
<tr><td><code id="z_grid_+3A_each">each</code></td>
<td>
<p>boolean, allowed for backwards compatibility, <code>scale_each</code>
is now the preferred argument name</p>
</td></tr>
<tr><td><code id="z_grid_+3A_scale_each">scale_each</code></td>
<td>
<p>boolean, if true scales each plate individually, if false
will scale the pooled values of <code>data</code></p>
</td></tr>
<tr><td><code id="z_grid_+3A_...">...</code></td>
<td>
<p>additional parameters to plot wrappers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df01 &lt;- data.frame(well = num_to_well(1:96),
  vals = rnorm(96),
  plate = 1)

df02 &lt;- data.frame(well = num_to_well(1:96),
  vals = rnorm(96),
  plate = 2)

df &lt;- rbind(df01, df02)

z_grid(data = df$vals,
       well = df$well,
       plate_id = df$plate,
       plate = 96)
</code></pre>

<hr>
<h2 id='z_map'>Plots a platemap with heatmap of scaled values</h2><span id='topic+z_map'></span>

<h3>Description</h3>

<p>Converts numerical values and  well labels into multiple plate heatmaps
</p>


<h3>Usage</h3>

<pre><code class='language-R'>z_map(data, well, plate = 96, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="z_map_+3A_data">data</code></td>
<td>
<p>Numerical values to be plotted</p>
</td></tr>
<tr><td><code id="z_map_+3A_well">well</code></td>
<td>
<p>Vector of well identifiers e.g &quot;A01&quot;</p>
</td></tr>
<tr><td><code id="z_map_+3A_plate">plate</code></td>
<td>
<p>Number of wells in complete plate (6, 12, 24, 48, 96, 384 or 1536))</p>
</td></tr>
<tr><td><code id="z_map_+3A_...">...</code></td>
<td>
<p>additional parameters to plot wrappers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(vals = rnorm(1:384),
  well = num_to_well(1:384, plate = 384))

z_map(data = df$vals,
      well = df$well,
      plate = 384)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
