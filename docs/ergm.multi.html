<!DOCTYPE html><html><head><title>Help for package ergm.multi</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ergm.multi}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as_tibble.combined_networks'><p>An <code>as_tibble</code> method for combined networks.</p></a></li>
<li><a href='#b1degreeL-ergmTerm'><p>Degree for the first mode in a bipartite (aka two-mode) network</p></a></li>
<li><a href='#b2degree-ergmTerm'><p>Degree for the second mode in a bipartite (aka two-mode) network</p></a></li>
<li><a href='#blacklist_block-ergmConstraint'><p>Blacklist blocks of dyads from toggling in a way that</p>
propagates through combined networks</a></li>
<li><a href='#blockdiag-ergmProposal'><p>A Metropolis&ndash;Hastings proposal for diagonal block constraints</p></a></li>
<li><a href='#blockdiagTNT-ergmProposal'><p>A Metropolis&ndash;Hastings proposal for diagonal block constraints</p></a></li>
<li><a href='#CMBL-ergmTerm'><p>Conway&ndash;Maxwell-Binomial dependence among layers</p></a></li>
<li><a href='#combine_ergmlhs'><p>Combine the <code>%ergmlhs%</code> settings of a list of networks</p></a></li>
<li><a href='#combine_networks'><p>A single block-diagonal network created by combining multiple networks</p></a></li>
<li><a href='#control.gofN.ergm'><p>Auxiliary for Controlling Multinetwork ERGM Linear Goodness-of-Fit Evaluation</p></a></li>
<li><a href='#ddspL-ergmTerm'><p>Dyadwise shared partners on layers</p></a></li>
<li><a href='#degreeL-ergmTerm'><p>Degree</p></a></li>
<li><a href='#despL-ergmTerm'><p>Edgewise shared partners on layers</p></a></li>
<li><a href='#dgwdspL-ergmTerm'><p>Geometrically weighted dyadwise shared partner distribution on layers</p></a></li>
<li><a href='#dgwespL-ergmTerm'><p>Geometrically weighted edgewise shared partner distribution on layers</p></a></li>
<li><a href='#dgwnspL-ergmTerm'><p>Geometrically weighted non-edgewise shared partner distribution on layers</p></a></li>
<li><a href='#direct.network'><p>Returns a directed version of an undirected binary network</p></a></li>
<li><a href='#dnspL-ergmTerm'><p>Non-edgewise shared partners and paths on layers</p></a></li>
<li><a href='#ergm_block_diag_samp_info'><p>Compute and serialize information needed by the block-diagonal</p>
Metropolis-Hastings samplers.</a></li>
<li><a href='#ergm_LayerLogic'><p>Internal representation of Layer Logic</p></a></li>
<li><a href='#ergm.multi-package'><p>ergm.multi: Fit, Simulate and Diagnose Exponential-Family Models for Multiple or Multilayer Networks</p></a></li>
<li><a href='#Goeyvaerts'><p>A sample of within-household contact networks in Flanders and Brussels</p></a></li>
<li><a href='#gofN'><p>Linear model diagnostics for multinetwork linear models</p></a></li>
<li><a href='#gwb1degreeL-ergmTerm'><p>Geometrically weighted degree distribution for the first mode in a bipartite (aka two-mode) network</p></a></li>
<li><a href='#gwb2degreeL-ergmTerm'><p>Geometrically weighted degree distribution for the second mode in a bipartite (aka two-mode) network</p></a></li>
<li><a href='#gwdegreeL-ergmTerm'><p>Geometrically weighted degree distribution</p></a></li>
<li><a href='#gwidegreeL-ergmTerm'><p>Geometrically weighted in-degree distribution</p></a></li>
<li><a href='#gwodegreeL-ergmTerm'><p>Geometrically weighted out-degree distribution</p></a></li>
<li><a href='#idegreeL-ergmTerm'><p>In-degree</p></a></li>
<li><a href='#L-ergmTerm'><p>Evaluation on layers</p></a></li>
<li><a href='#Layer'><p>A multilayer network representation.</p></a></li>
<li><a href='#Lazega'><p>A network of advice, collaboration, and friendship in a law firm</p></a></li>
<li><a href='#lm.gofN'><p>Fit a linear model to the residuals in a gofN object.</p></a></li>
<li><a href='#marg_cond_sim'><p>Calculate gofN()-style Pearson residuals for arbitrary statistics</p></a></li>
<li><a href='#mutualL-ergmTerm'><p>Mutuality</p></a></li>
<li><a href='#N-ergmTerm'><p>Evaluation on multiple networks</p></a></li>
<li><a href='#network_view'><p>Construct a &quot;view&quot; of a network.</p></a></li>
<li><a href='#Networks'><p>A multinetwork network representation.</p></a></li>
<li><a href='#odegreeL-ergmTerm'><p>Out-degree</p></a></li>
<li><a href='#plot.gofN'><p>Plotting methods for <code>gofN</code>, making residual and scale-location plots.</p></a></li>
<li><a href='#snctrl'><p>Statnet Control</p></a></li>
<li><a href='#split.network'><p>A <code>split()</code> method for <code>network::network</code> objects.</p></a></li>
<li><a href='#subnetwork_templates'><p>Obtain empty networks representing constituents of a combined network</p></a></li>
<li><a href='#twostarL-ergmTerm'><p>Multilayer two-star</p></a></li>
<li><a href='#uncombine_network'><p>Split up a network into a list of subgraphs</p></a></li>
<li><a href='#upper_tri-ergmConstraint'><p>Only dyads in the upper-triangle of the sociomatrix may be</p>
toggled</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.2.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-20</td>
</tr>
<tr>
<td>Title:</td>
<td>Fit, Simulate and Diagnose Exponential-Family Models for
Multiple or Multilayer Networks</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), ergm (&ge; 4.6.0), network (&ge; 1.18.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>statnet.common (&ge; 4.9.0), rlang (&ge; 1.1.3), purrr (&ge; 1.0.2),
tibble (&ge; 3.2.1), glue (&ge; 1.7.0), rle (&ge; 0.9.2), Rdpack (&ge;
2.6), Matrix, methods, parallel</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>ergm</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown (&ge; 2.25), knitr (&ge; 1.45), dplyr (&ge; 1.1.4),
testthat (&ge; 3.2.1), ggplot2 (&ge; 3.4.4), ggrepel (&ge; 0.9.5),
generics (&ge; 0.1.3)</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/statnet/ergm.multi/issues">https://github.com/statnet/ergm.multi/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>A set of extensions for the 'ergm' package to fit multilayer/multiplex/multirelational networks and samples of multiple networks. 'ergm.multi' is a part of the Statnet suite of packages for network analysis. See Krivitsky, Koehly, and Marcum (2020) &lt;<a href="https://doi.org/10.1007%2Fs11336-020-09720-7">doi:10.1007/s11336-020-09720-7</a>&gt; and Krivitsky, Coletti, and Hens (2023) &lt;<a href="https://doi.org/10.1080%2F01621459.2023.2242627">doi:10.1080/01621459.2023.2242627</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://statnet.org">https://statnet.org</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>rmarkdown, knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-20 12:50:23 UTC; pavel</td>
</tr>
<tr>
<td>Author:</td>
<td>Pavel N. Krivitsky
    <a href="https://orcid.org/0000-0002-9101-3362"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Mark S. Handcock [ctb],
  David R. Hunter [ctb],
  Chad Klumb [ctb],
  Pietro Coletti [ctb],
  Joyce Cheng [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Pavel N. Krivitsky &lt;pavel@statnet.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-20 23:20:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='as_tibble.combined_networks'>An <code>as_tibble</code> method for combined networks.</h2><span id='topic+as_tibble.combined_networks'></span>

<h3>Description</h3>

<p>A method to obtain a network attribute table from a
<code><a href="#topic+combined_networks">combined_networks</a></code> object, falling back to the
<code><a href="network.html#topic+as.matrix.network">network::as_tibble.network()</a></code> if vertex or edge attributes are
required.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'combined_networks'
as_tibble(
  x,
  attrnames = (match.arg(unit) %in% c("vertices", "networks")),
  ...,
  unit = c("edges", "vertices", "networks"),
  .NetworkID = ".NetworkID",
  .NetworkName = ".NetworkName"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_tibble.combined_networks_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+combined_networks">combined_networks</a></code> (inheriting from <code><a href="network.html#topic+network">network::network</a></code>).</p>
</td></tr>
<tr><td><code id="as_tibble.combined_networks_+3A_attrnames">attrnames</code></td>
<td>
<p>a list (or a selection index) for attributes to obtain; for combined networks, defaults to all.</p>
</td></tr>
<tr><td><code id="as_tibble.combined_networks_+3A_...">...</code></td>
<td>
<p>additional arguments, currently passed to unlist()].</p>
</td></tr>
<tr><td><code id="as_tibble.combined_networks_+3A_unit">unit</code></td>
<td>
<p>whether to obtain edge, vertex, or network attributes.</p>
</td></tr>
<tr><td><code id="as_tibble.combined_networks_+3A_.networkid">.NetworkID</code>, <code id="as_tibble.combined_networks_+3A_.networkname">.NetworkName</code></td>
<td>
<p>Optional strings indicating the
vertex attributes used to distinguish and name the networks;
intended to be used by term developers.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="network.html#topic+as.matrix.network">network::as_tibble.network()</a></code>
</p>

<hr>
<h2 id='b1degreeL-ergmTerm'>Degree for the first mode in a bipartite (aka two-mode) network</h2><span id='topic+b1degreeL-ergmTerm'></span><span id='topic+InitErgmTerm.b1degreeL'></span>

<h3>Description</h3>

<p>This term adds one network statistic to the model for
each element in <code>d</code> ; the <code class="reqn">i</code> th such statistic equals the number of
nodes of degree <code>d[i]</code> in the first mode of a bipartite network, i.e.
with exactly <code>d[i]</code> edges. The first mode of a bipartite network object
is sometimes known as the &quot;actor&quot; mode.
</p>
<p>This term can only be used with undirected bipartite networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: b1degreeL(d, by=NULL, levels=NULL, Ls=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="b1degreeL-ergmTerm_+3A_d">d</code></td>
<td>
<p>a vector of distinct integers.</p>
</td></tr>
<tr><td><code id="b1degreeL-ergmTerm_+3A_by">by</code></td>
<td>
<p>a character string giving the name of an attribute in the network's vertex
attribute list. If this is specified
then each node's degree is tabulated only with other nodes having the same
value of the <code>by</code> attribute.</p>
</td></tr>
<tr><td><code id="b1degreeL-ergmTerm_+3A_levels">levels</code></td>
<td>
<p>if <code>by</code> is specified, which levels to consider.</p>
</td></tr>
<tr><td><code id="b1degreeL-ergmTerm_+3A_ls">Ls</code></td>
<td>
<p>either a Layer Logic specification formula (c.f. Layer Logic section in the <code><a href="#topic+Layer">Layer()</a></code> documentation) or a list thereof (constructed by <code><a href="base.html#topic+list">list()</a></code> or <code><a href="base.html#topic+c">c()</a></code>). If given, degree of a node</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="ergm.html#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>bipartite, categorical nodal attribute, frequently-used, undirected, binary</p>


<hr>
<h2 id='b2degree-ergmTerm'>Degree for the second mode in a bipartite (aka two-mode) network</h2><span id='topic+b2degree-ergmTerm'></span><span id='topic+InitErgmTerm.b2degreeL'></span>

<h3>Description</h3>

<p>This term adds one network statistic to the model for
each element in <code>d</code> ; the <code class="reqn">i</code> th such statistic equals the number of
nodes of degree <code>d[i]</code> in the second mode of a bipartite network, i.e.
with exactly <code>d[i]</code> edges. The second mode of a bipartite network
object is sometimes known as the &quot;event&quot; mode. The optional term
<code>by</code> is a character string giving the name of an attribute in the
network's vertex attribute list.
This term can only be used with undirected bipartite networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: b2degree(d, by=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="b2degree-ergmTerm_+3A_d">d</code></td>
<td>
<p>a vector of distinct integers</p>
</td></tr>
<tr><td><code id="b2degree-ergmTerm_+3A_by">by</code></td>
<td>
<p>a character string giving the name of an attribute in the network's vertex
attribute list. If this is specified
then each node's degree is tabulated only with other nodes having the same
value of the <code>by</code> attribute.</p>
</td></tr>
<tr><td><code id="b2degree-ergmTerm_+3A_levels">levels</code></td>
<td>
<p>if <code>by</code> is specified, which levels to consider.</p>
</td></tr>
<tr><td><code id="b2degree-ergmTerm_+3A_ls">Ls</code></td>
<td>
<p>either a Layer Logic specification formula (c.f. Layer Logic section in the <code><a href="#topic+Layer">Layer()</a></code> documentation) or a list thereof (constructed by <code><a href="base.html#topic+list">list()</a></code> or <code><a href="base.html#topic+c">c()</a></code>). If given, degree of a node</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="ergm.html#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>bipartite, categorical nodal attribute, frequently-used, undirected, binary</p>


<hr>
<h2 id='blacklist_block-ergmConstraint'>Blacklist blocks of dyads from toggling in a way that
propagates through combined networks</h2><span id='topic+blacklist_block-ergmConstraint'></span><span id='topic+InitErgmConstraint.blacklist_block'></span>

<h3>Description</h3>

<p>This constraint is primarily for internal use,
alongside the block blacklist API implemented in
<code>block_blacklist.R</code>, which assigns and interprets vertex and
network attributes allowing certain blocks of dyads to be
blacklisted in a way that will survive even network manipulations
such as subgraph extraction and combining into block-diagonal
using <code><a href="#topic+combine_networks">combine_networks()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># blacklist_block(block_vattr = ".ubid",
#                 blacklist_nattr = ".block_blacklist")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blacklist_block-ergmConstraint_+3A_block_vattr">block_vattr</code></td>
<td>
<p>a character string giving the name of vertex
attribute containing globally unique vertex block membership IDs.</p>
</td></tr>
<tr><td><code id="blacklist_block-ergmConstraint_+3A_blacklist_nattr">blacklist_nattr</code></td>
<td>
<p>a character string giving the name of a
network attribute containing the list of pairs of vertex IDs that
are to be blacklisted.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="ergm.html#topic+ergmConstraint">ergmConstraint</a></code> for index of constraints and hints currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, dyad-independent, undirected</p>


<hr>
<h2 id='blockdiag-ergmProposal'>A Metropolis&ndash;Hastings proposal for diagonal block constraints</h2><span id='topic+blockdiag-ergmProposal'></span><span id='topic+InitErgmProposal.blockdiag'></span>

<h3>Description</h3>

<p>Typically used for <code class="reqn">constraints= ~blockdiag</code>. Select a diagonal
block according to the weight, then randomly select a dayd within the
block for the toggle proposal.
</p>


<h3>Details</h3>

<p>This proposal is not referenced in the lookup table.</p>




<h3>See Also</h3>

<p><code><a href="ergm.html#topic+ergmProposal">ergmProposal</a></code> for index of proposals currently visible to the package.
</p>


<h4>Keywords</h4>

<p>None</p>


<hr>
<h2 id='blockdiagTNT-ergmProposal'>A Metropolis&ndash;Hastings proposal for diagonal block constraints</h2><span id='topic+blockdiagTNT-ergmProposal'></span><span id='topic+InitErgmProposal.blockdiagTNT'></span>

<h3>Description</h3>

<p>Typically used for <code class="reqn">constraints=
  ~blockdiag</code>. Similar to InitErgmProposal.blockdiag, except that
it selects ties and non-ties for proposed toggles (in the block
by construction) with equal probability.  Like the unconstrained
TNT proposal, this is useful for improving performance in sparse
networks.
</p>


<h3>Details</h3>

<p>This proposal is not referenced in the lookup table.</p>




<h3>See Also</h3>

<p><code><a href="ergm.html#topic+ergmProposal">ergmProposal</a></code> for index of proposals currently visible to the package.
</p>


<h4>Keywords</h4>

<p>None</p>


<hr>
<h2 id='CMBL-ergmTerm'>Conway&ndash;Maxwell-Binomial dependence among layers</h2><span id='topic+CMBL-ergmTerm'></span><span id='topic+InitErgmTerm.CMBL'></span>

<h3>Description</h3>

<p>Models marginal dependence layers within each dyad by imposing
a Conway&ndash;Maxwell-Binomial (CMB) distribution on the number of
layers in each dyad that have a tie.
</p>
<p>The term adds one statistic to the model, equalling the sum over
all the dyads in the network of <code class="reqn">\log\{E!(R-E)!/R!\}</code> , where
<code class="reqn">E</code> is the number of layers in <code>Ls</code> with an edge in that
dyad and <code class="reqn">R</code> being the total number of layers in <code>Ls</code> .
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: CMBL(Ls=~.)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CMBL-ergmTerm_+3A_ls">Ls</code></td>
<td>
<p>a list (constructed by <code><a href="base.html#topic+list">list()</a></code> or <code><a href="base.html#topic+c">c()</a></code> of at least two Layer Logic specifications (c.f. Layer Logic section in the <code><a href="#topic+Layer">Layer()</a></code> documentation).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A positive coefficient induces positive dependence and a negative
one induces negative dependence.
</p>


<h3>See Also</h3>

<p><code><a href="ergm.html#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, layer-aware, undirected, binary</p>


<hr>
<h2 id='combine_ergmlhs'>Combine the <code><a href="ergm.html#topic++25ergmlhs+25">%ergmlhs%</a></code> settings of a list of networks</h2><span id='topic+combine_ergmlhs'></span>

<h3>Description</h3>

<p>This is a helper function to go through the <code><a href="network.html#topic+network">network</a></code> objects in the list
and accumulate their <code><a href="ergm.html#topic++25ergmlhs+25">%ergmlhs%</a></code> settings, printing a message if
the settings clash. Later networks' settings overwrite the earlier.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine_ergmlhs(nwl, ignore.settings = c())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine_ergmlhs_+3A_nwl">nwl</code></td>
<td>
<p>a <code><a href="base.html#topic+list">list</a></code> of <code><a href="network.html#topic+network">network</a></code> objects whose settings are to
be combined.</p>
</td></tr>
<tr><td><code id="combine_ergmlhs_+3A_ignore.settings">ignore.settings</code></td>
<td>
<p>a <code><a href="base.html#topic+character">character</a></code> vector of setting names to
be ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+list">list</a></code> of settings, suitable for being assigned as the
<code>ergm</code> network attribute.
</p>

<hr>
<h2 id='combine_networks'>A single block-diagonal network created by combining multiple networks</h2><span id='topic+combine_networks'></span><span id='topic+combined_networks'></span><span id='topic+print.combined_networks'></span><span id='topic+summary.combined_networks'></span><span id='topic+print.summary.combined_networks'></span>

<h3>Description</h3>

<p>Given a list of compatible networks, the <code><a href="#topic+combine_networks">combine_networks()</a></code> returns a single
block-diagonal network, preserving attributes that can be
preserved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine_networks(
  nwl,
  ignore.nattr = c("mnext"),
  ignore.vattr = c(),
  ignore.eattr = c(),
  blockID.vattr = ".NetworkID",
  blockName.vattr = NULL,
  detect.edgecov = FALSE,
  keep.unshared.attr = FALSE,
  subnet.cache = FALSE
)

## S3 method for class 'combined_networks'
print(x, ...)

## S3 method for class 'combined_networks'
summary(object, ...)

## S3 method for class 'summary.combined_networks'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine_networks_+3A_nwl">nwl</code></td>
<td>
<p>a list of <code><a href="network.html#topic+network">network::network</a></code>s to be combined; they
must have similar fundamental properties: directedness and
bipartedness, though their sizes (and the size of each bipartite
group) can vary.</p>
</td></tr>
<tr><td><code id="combine_networks_+3A_ignore.nattr">ignore.nattr</code>, <code id="combine_networks_+3A_ignore.vattr">ignore.vattr</code>, <code id="combine_networks_+3A_ignore.eattr">ignore.eattr</code></td>
<td>
<p>network, vertex, and
edge attributes not to be processed as described below.</p>
</td></tr>
<tr><td><code id="combine_networks_+3A_blockid.vattr">blockID.vattr</code></td>
<td>
<p>name of the vertex attribute into which to store
the index of the network to which that vertex originally belonged.</p>
</td></tr>
<tr><td><code id="combine_networks_+3A_blockname.vattr">blockName.vattr</code></td>
<td>
<p>if not <code>NULL</code>, the name of the vertex
attribute into which to store the name of the network to which
that vertex originally belonged.</p>
</td></tr>
<tr><td><code id="combine_networks_+3A_detect.edgecov">detect.edgecov</code></td>
<td>
<p>if <code>TRUE</code>, combine network attributes that
look like dyadic covariate (<code><a href="ergm.html#topic+edgecov-ergmTerm-1fb5ef19">ergm::edgecov</a></code>) matrices into a
block-diagonal matrix.</p>
</td></tr>
<tr><td><code id="combine_networks_+3A_keep.unshared.attr">keep.unshared.attr</code></td>
<td>
<p>whether to keep those network, vertex,
and edge attributes not shared by all networks in the list; if
<code>TRUE</code>, positions corresponding to networks lacking the
attribute are replaced with <code>NA</code>, <code>NULL</code>, or some other
placeholder; incompatible with <code>detect.edgecov==TRUE</code>.</p>
</td></tr>
<tr><td><code id="combine_networks_+3A_subnet.cache">subnet.cache</code></td>
<td>
<p>whether to save the input network list as an
attribute of the combined network, so that if the network is
resplit using on the same attribute (e.g. using
<code><a href="#topic+uncombine_network">uncombine_network()</a></code>), an expensive call to <code><a href="#topic+split.network">split.network()</a></code>
can be avoided, at the cost of storage.</p>
</td></tr>
<tr><td><code id="combine_networks_+3A_x">x</code>, <code id="combine_networks_+3A_object">object</code></td>
<td>
<p>a combined network.</p>
</td></tr>
<tr><td><code id="combine_networks_+3A_...">...</code></td>
<td>
<p>additional arguments to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>combined_networks</code> inheriting from
<code><a href="network.html#topic+network">network::network</a></code> with a block-diagonal structure (or its
bipartite equivalent) comprising the networks passed in <code>nwl</code>. In
particular,
</p>

<ul>
<li><p> the returned network's size is the sum of the input networks';
</p>
</li>
<li><p> its basic properties (directedness and bipartednes) are the same;
</p>
</li>
<li><p> the input networks' sociomatrices (both edge presence and edge
attributes) are the blocks in the sociomatrix of the returned
network;
</p>
</li>
<li><p> vertex attributes are concatenated;
</p>
</li>
<li><p> edge attributes are assigned to their respective edges in
the returned network;
</p>
</li>
<li><p> network attributes are stored in a list; but if
<code>detect.edgecov==TRUE</code>, those network attributes that have the
same dimension as the sociomatrices of the constituent networks,
they are combined into a single block-diagonal matrix that is
then stored as that attribute.
</p>
</li></ul>

<p>In addition, two new vertex attributes, specified by
<code>blockID.vattr</code> and (optionally) <code>blockName.vattr</code> contain,
respectively, the index in <code>nwl</code> of the network from which that
vertex came and its name, determined as follows:
</p>

<ol>
<li><p> If <code>nwl</code> is a named list, names from the list are used.
</p>
</li>
<li><p> If not 1, but the network has an attribute <code>title</code>, it is used.
</p>
</li>
<li><p> Otherwise, a numerical index is used.
</p>
</li></ol>

<p>If <code>blockID.vattr</code> already exists on the constituent networks, the
index is <em>prepended</em> to the attribute.
</p>
<p>The values of <code>blockID.vattr</code> and <code>blockName.vattr</code> are stored in
network attributes <code>".blockID.vattr"</code> and <code>".blockName.vattr"</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>print(combined_networks)</code>: A wrapper around
<code><a href="network.html#topic+network">network::print.network()</a></code> to print constituent network
information and omit some internal variables.
</p>
</li>
<li> <p><code>summary(combined_networks)</code>: A wrapper around
<code><a href="network.html#topic+network">network::summary.network()</a></code> to print constituent network
information and omit some internal variables.
</p>
</li>
<li> <p><code>print(summary.combined_networks)</code>: A wrapper around
<code><a href="network.html#topic+network">network::print.summary.network()</a></code> to print constituent network
information and omit some internal variables.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
data(samplk)

o1 &lt;- combine_networks(list(samplk1, samplk2, samplk3))
image(as.matrix(o1))
head(get.vertex.attribute(o1, ".NetworkID"))
o2 &lt;- combine_networks(list(o1, o1))
image(as.matrix(o2))
head(get.vertex.attribute(o2, ".NetworkID", unlist=FALSE))

data(florentine)
f1 &lt;- combine_networks(list(business=flobusiness, marriage=flomarriage),
                       blockName.vattr=".NetworkName")
image(as.matrix(f1))
head(get.vertex.attribute(f1, ".NetworkID"))
head(get.vertex.attribute(f1, ".NetworkName"))
</code></pre>

<hr>
<h2 id='control.gofN.ergm'>Auxiliary for Controlling Multinetwork ERGM Linear Goodness-of-Fit Evaluation</h2><span id='topic+control.gofN.ergm'></span><span id='topic+control.gofN'></span>

<h3>Description</h3>

<p><code>control.gofN.ergm</code> (or its alias, <code>control.gofN</code>) is
intended to be used with <code><a href="#topic+gofN">gofN()</a></code> specifically and will &quot;inherit&quot;
as many control parameters from <code><a href="ergm.html#topic+ergm">ergm</a></code> fit as possible().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>control.gofN.ergm(
  nsim = 100,
  obs.twostage = nsim/2,
  array.max = 128,
  simulate = control.simulate.ergm(),
  obs.simulate = control.simulate.ergm(),
  parallel = 0,
  parallel.type = NULL,
  parallel.version.check = TRUE,
  parallel.inherit.MT = FALSE
)

control.gofN(
  nsim = 100,
  obs.twostage = nsim/2,
  array.max = 128,
  simulate = control.simulate.ergm(),
  obs.simulate = control.simulate.ergm(),
  parallel = 0,
  parallel.type = NULL,
  parallel.version.check = TRUE,
  parallel.inherit.MT = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="control.gofN.ergm_+3A_nsim">nsim</code></td>
<td>
<p>Number of networks to be randomly drawn using Markov chain Monte
Carlo.  This sample of networks provides the basis for comparing the model
to the observed network.</p>
</td></tr>
<tr><td><code id="control.gofN.ergm_+3A_obs.twostage">obs.twostage</code></td>
<td>
<p>Either <code>FALSE</code> or an integer. This parameter
only has an effect if the network has missing data or
observational process. For such networks, evaluating the Pearson
residual requires simulating the expected value of the
conditional variance under the observation process. If <code>FALSE</code>,
the simulation is performed conditional on the observed
network. However, a more accurate estimate can be obtained via a
two-stage process: </p>

<ol>
<li><p> Sample networks from the model without the observational
constraint.
</p>
</li>
<li><p> Conditional on each of those networks, sample with the
observational constraint, estimating the variance within each
sample and then averaging over the first-stage sample.
</p>
</li></ol>

<p>Then, <code>obs.twostage</code> specifies the number of unconstrained networks
to simulate from, which should divide the <code><a href="#topic+control.gofN.ergm">control.gofN.ergm()</a></code>'s
<code>nsim</code> argument evenly.</p>
</td></tr>
<tr><td><code id="control.gofN.ergm_+3A_array.max">array.max</code></td>
<td>
<p>Try to avoid creating arrays larger in size (in
megabytes) than this. Is ignored if <code>save_stats</code> is passed.</p>
</td></tr>
<tr><td><code id="control.gofN.ergm_+3A_simulate">simulate</code>, <code id="control.gofN.ergm_+3A_obs.simulate">obs.simulate</code></td>
<td>
<p>Control lists produced by
<code><a href="ergm.html#topic+control.simulate.ergm">control.simulate.ergm()</a></code> or equivalent for unconstrained and
constrained simulation, respectively. Parameters are inherited
from the model fit and can be overridden here.</p>
</td></tr>
<tr><td><code id="control.gofN.ergm_+3A_parallel">parallel</code></td>
<td>
<p>Number of threads in which to run the sampling. Defaults to
0 (no parallelism). See the entry on <a href="ergm.html#topic+ergm-parallel">parallel processing</a>
for details and troubleshooting.</p>
</td></tr>
<tr><td><code id="control.gofN.ergm_+3A_parallel.type">parallel.type</code></td>
<td>
<p>API to use for parallel processing. Supported values
are <code>"MPI"</code> and <code>"PSOCK"</code>. Defaults to using the <code>parallel</code>
package with PSOCK clusters. See <code><a href="ergm.html#topic+ergm-parallel">ergm-parallel</a></code></p>
</td></tr>
<tr><td><code id="control.gofN.ergm_+3A_parallel.version.check">parallel.version.check</code></td>
<td>
<p>Logical: If TRUE, check that the version of
<code><a href="ergm.html#topic+ergm-package">ergm</a></code> running on the slave nodes is the same as
that running on the master node.</p>
</td></tr>
<tr><td><code id="control.gofN.ergm_+3A_parallel.inherit.mt">parallel.inherit.MT</code></td>
<td>
<p>Logical: If TRUE, slave nodes and
processes inherit the <code><a href="ergm.html#topic+set.MT_terms">set.MT_terms()</a></code> setting.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Auxiliary function as user interface for fine-tuning ERGM Goodness-of-Fit
Evaluation.
</p>

<hr>
<h2 id='ddspL-ergmTerm'>Dyadwise shared partners on layers</h2><span id='topic+ddspL-ergmTerm'></span><span id='topic+InitErgmTerm.ddspL'></span><span id='topic+InitErgmTerm.dspL'></span><span id='topic+dspL-ergmTerm'></span>

<h3>Description</h3>

<p>This term adds one network statistic to the model for each element in <code>d</code> where the <code class="reqn">i</code> th such statistic equals the number of dyads in the network with exactly <code>d[i]</code> shared partners. For a directed network, multiple shared partner definitions are possible.
</p>
<p><code>dspL</code> and <code>ddspL</code> are aliases for consistency with <span class="pkg">ergm</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: ddspL(d, type="OTP", Ls.path=NULL, L.in_order=FALSE)

# binary: dspL(d, type="OTP", Ls.path=NULL, L.in_order=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ddspL-ergmTerm_+3A_ls.path">Ls.path</code>, <code id="ddspL-ergmTerm_+3A_l.in_order">L.in_order</code></td>
<td>
<p>a vector of one or two formulas <code>Ls.path</code>
provides the Layer Logic (c.f. Layer Logic section in the
<code><a href="#topic+Layer">Layer()</a></code> documentation) specifications for the ties of the
2-path or the shared partnership. (If only one formula is given
the layers are assumed to be the same.) If <code>L.in_order==TRUE</code> ,
the first tie of the two-path must be the first element of
<code>Ls.path</code> and the second must be the second; otherwise, any
ordering counts, provided there is exactly one of each. (For
types <code>"OSP"</code> and <code>"ISP"</code> , the first tie is considered to be the
one incident on the tail of the base tie.)</p>
</td></tr>
</table>


<h3>Shared partner types</h3>

<p>While there is only one shared partner configuration in the undirected
case, nine distinct configurations are possible for directed graphs, selected
using the <code>type</code> argument. Currently, terms may be defined with respect to
five of these configurations; they are defined here as follows (using
terminology from Butts (2008) and the <code>relevent</code> package):
</p>

<ul>
<li><p> Outgoing Two-path (<code>"OTP"</code>): vertex <code class="reqn">k</code> is an OTP shared partner of ordered
pair <code class="reqn">(i,j)</code> iff <code class="reqn">i \to k \to j</code>. Also known as &quot;transitive
shared partner&quot;.
</p>
</li>
<li><p> Incoming Two-path (<code>"ITP"</code>): vertex <code class="reqn">k</code> is an ITP shared partner of ordered
pair <code class="reqn">(i,j)</code> iff <code class="reqn">j \to k \to i</code>. Also known as &quot;cyclical shared
partner&quot;
</p>
</li>
<li><p> Reciprocated Two-path (<code>"RTP"</code>): vertex <code class="reqn">k</code> is an RTP shared partner of ordered
pair <code class="reqn">(i,j)</code> iff <code class="reqn">i \leftrightarrow k \leftrightarrow j</code>.
</p>
</li>
<li><p> Outgoing Shared Partner (<code>"OSP"</code>): vertex <code class="reqn">k</code> is an OSP shared partner of
ordered pair <code class="reqn">(i,j)</code> iff <code class="reqn">i \to k, j \to k</code>.
</p>
</li>
<li><p> Incoming Shared Partner (<code>"ISP"</code>): vertex <code class="reqn">k</code> is an ISP shared partner of ordered
pair <code class="reqn">(i,j)</code> iff <code class="reqn">k \to i, k \to j</code>.
By default, outgoing two-paths (<code>"OTP"</code>) are calculated. Note that Robins et al. (2009)
define closely related statistics to several of the above, using slightly different terminology.
</p>
</li></ul>



<h3>Note</h3>

<p>This term takes an additional term option (see
<code><a href="ergm.html#topic+ergm-options">options?ergm</a></code>), <code>cache.sp</code>, controlling whether
the implementation will cache the number of shared partners for
each dyad in the network; this is usually enabled by default.
</p>


<h3>See Also</h3>

<p><code><a href="ergm.html#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, layer-aware, undirected, binary</p>


<hr>
<h2 id='degreeL-ergmTerm'>Degree</h2><span id='topic+degreeL-ergmTerm'></span><span id='topic+InitErgmTerm.degreeL'></span>

<h3>Description</h3>

<p>This term adds one
network statistic to the model for each element in <code>d</code> ; the <code class="reqn">i</code> th
such statistic equals the number of nodes in the network of degree
<code>d[i]</code> , i.e. with exactly <code>d[i]</code> edges.
</p>
<p>This term can only be used with undirected networks; for directed networks
see <code>idegree</code> and <code>odegree</code> .
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: degreeL(d, by=NULL, homophily=FALSE, levels=NULL, Ls=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="degreeL-ergmTerm_+3A_d">d</code></td>
<td>
<p>a vector of distinct integers</p>
</td></tr>
<tr><td><code id="degreeL-ergmTerm_+3A_by">by</code></td>
<td>
<p>a character string giving the name of an attribute in the
network's vertex attribute list.</p>
</td></tr>
<tr><td><code id="degreeL-ergmTerm_+3A_homophily">homophily</code></td>
<td>
<p>If this is specified and <code>homophily</code> is <code>TRUE</code> ,
then degrees are calculated using the subnetwork consisting of only
edges whose endpoints have the same value of the <code>by</code> attribute.
If <code>by</code> is specified and
<code>homophily</code> is <code>FALSE</code> (the default), then separate degree
statistics are calculated for nodes having each separate
value of the attribute.</p>
</td></tr>
<tr><td><code id="degreeL-ergmTerm_+3A_ls">Ls</code></td>
<td>
<p>a list (constructed by <code><a href="base.html#topic+list">list()</a></code> or <code><a href="base.html#topic+c">c()</a></code> of one or more Layer Logic specifications (c.f. Layer Logic section in the <code><a href="#topic+Layer">Layer()</a></code> documentation). If specified, degree of a node <code>i</code> is considered to be the number of edges in all layers, combined.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="ergm.html#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>categorical nodal attribute, directed, frequently-used, undirected, binary</p>


<hr>
<h2 id='despL-ergmTerm'>Edgewise shared partners on layers</h2><span id='topic+despL-ergmTerm'></span><span id='topic+InitErgmTerm.despL'></span><span id='topic+InitErgmTerm.espL'></span><span id='topic+espL-ergmTerm'></span>

<h3>Description</h3>

<p>This term adds one network statistic to the model for each element in <code>d</code> where the <code class="reqn">i</code> th such statistic equals the number of edges in the network with exactly <code>d[i]</code> shared partners. For a directed network, multiple shared partner definitions are possible.
</p>
<p><code>espL</code> and <code>despL</code> are aliases for consistency with <span class="pkg">ergm</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: despL(d, type="OTP", L.base=NULL, Ls.path=NULL, L.in_order=FALSE)

# binary: espL(d, type="OTP", L.base=NULL, Ls.path=NULL, L.in_order=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="despL-ergmTerm_+3A_d">d</code></td>
<td>
<p>a vector of distinct integers</p>
</td></tr>
<tr><td><code id="despL-ergmTerm_+3A_type">type</code></td>
<td>
<p>A string indicating the type of shared partner or path to be considered for directed networks: <code>"OTP"</code> (default for directed), <code>"ITP"</code>, <code>"RTP"</code>, <code>"OSP"</code>, and <code>"ISP"</code>; has no effect for undirected. See the section below on Shared partner types for details.</p>
</td></tr>
<tr><td><code id="despL-ergmTerm_+3A_l.base">L.base</code></td>
<td>
<p>the Layer Logic (c.f. Layer Logic section in the
<code><a href="#topic+Layer">Layer()</a></code> documentation) specification for the base</p>
</td></tr>
<tr><td><code id="despL-ergmTerm_+3A_ls.path">Ls.path</code>, <code id="despL-ergmTerm_+3A_l.in_order">L.in_order</code></td>
<td>
<p>a vector of one or two formulas <code>Ls.path</code>
provides the Layer Logic (c.f. Layer Logic section in the
<code><a href="#topic+Layer">Layer()</a></code> documentation) specifications for the ties of the
2-path or the shared partnership. (If only one formula is given
the layers are assumed to be the same.) If <code>L.in_order==TRUE</code> ,
the first tie of the two-path must be the first element of
<code>Ls.path</code> and the second must be the second; otherwise, any
ordering counts, provided there is exactly one of each. (For
types <code>"OSP"</code> and <code>"ISP"</code> , the first tie is considered to be the
one incident on the tail of the base tie.)</p>
</td></tr>
</table>


<h3>Shared partner types</h3>

<p>While there is only one shared partner configuration in the undirected
case, nine distinct configurations are possible for directed graphs, selected
using the <code>type</code> argument. Currently, terms may be defined with respect to
five of these configurations; they are defined here as follows (using
terminology from Butts (2008) and the <code>relevent</code> package):
</p>

<ul>
<li><p> Outgoing Two-path (<code>"OTP"</code>): vertex <code class="reqn">k</code> is an OTP shared partner of ordered
pair <code class="reqn">(i,j)</code> iff <code class="reqn">i \to k \to j</code>. Also known as &quot;transitive
shared partner&quot;.
</p>
</li>
<li><p> Incoming Two-path (<code>"ITP"</code>): vertex <code class="reqn">k</code> is an ITP shared partner of ordered
pair <code class="reqn">(i,j)</code> iff <code class="reqn">j \to k \to i</code>. Also known as &quot;cyclical shared
partner&quot;
</p>
</li>
<li><p> Reciprocated Two-path (<code>"RTP"</code>): vertex <code class="reqn">k</code> is an RTP shared partner of ordered
pair <code class="reqn">(i,j)</code> iff <code class="reqn">i \leftrightarrow k \leftrightarrow j</code>.
</p>
</li>
<li><p> Outgoing Shared Partner (<code>"OSP"</code>): vertex <code class="reqn">k</code> is an OSP shared partner of
ordered pair <code class="reqn">(i,j)</code> iff <code class="reqn">i \to k, j \to k</code>.
</p>
</li>
<li><p> Incoming Shared Partner (<code>"ISP"</code>): vertex <code class="reqn">k</code> is an ISP shared partner of ordered
pair <code class="reqn">(i,j)</code> iff <code class="reqn">k \to i, k \to j</code>.
By default, outgoing two-paths (<code>"OTP"</code>) are calculated. Note that Robins et al. (2009)
define closely related statistics to several of the above, using slightly different terminology.
</p>
</li></ul>



<h3>Note</h3>

<p>This term takes an additional term option (see
<code><a href="ergm.html#topic+ergm-options">options?ergm</a></code>), <code>cache.sp</code>, controlling whether
the implementation will cache the number of shared partners for
each dyad in the network; this is usually enabled by default.
</p>


<h3>See Also</h3>

<p><code><a href="ergm.html#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, layer-aware, undirected, binary</p>


<hr>
<h2 id='dgwdspL-ergmTerm'>Geometrically weighted dyadwise shared partner distribution on layers</h2><span id='topic+dgwdspL-ergmTerm'></span><span id='topic+InitErgmTerm.dgwdspL'></span><span id='topic+InitErgmTerm.gwdspL'></span><span id='topic+gwdspL-ergmTerm'></span>

<h3>Description</h3>

<p>This term adds one network statistic to the model equal to the geometrically weighted dyadwise shared partner distribution with decay parameter. Note that the GWDSP statistic is equal to the sum of GWNSP plus GWESP. For a directed network, multiple shared partner definitions are possible.
</p>
<p><code>gdwdspL</code> and <code>dgwdspL</code> are aliases for consistency with <span class="pkg">ergm</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: dgwdspL(decay, fixed=FALSE, cutoff=30, type="OTP",
#                 Ls.path=NULL, L.in_order=FALSE)

# binary: gwdspL(decay, fixed=FALSE, cutoff=30, type="OTP",
#                Ls.path=NULL, L.in_order=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dgwdspL-ergmTerm_+3A_decay">decay</code></td>
<td>
<p>nonnegative decay parameter for the shared partner or selected directed analogue count; required if <code>fixed=TRUE</code> and ignored with a warning otherwise.</p>
</td></tr>
<tr><td><code id="dgwdspL-ergmTerm_+3A_fixed">fixed</code></td>
<td>
<p>optional argument indicating
whether the <code>decay</code> parameter is fixed at the given value, or is to be fit as a curved
exponential-family model (see Hunter and Handcock, 2006). The
default is <code>FALSE</code> , which means the scale parameter is not
fixed and thus the model is a curved exponential family.</p>
</td></tr>
<tr><td><code id="dgwdspL-ergmTerm_+3A_cutoff">cutoff</code></td>
<td>
<p>This optional argument sets the number of underlying DSP terms
to use in computing the statistics when <code>fixed=FALSE</code>, in order to reduce
the computational burden.  Its default value can also be controlled by the
<code>gw.cutoff</code> term option control parameter. (See <code>?control.ergm</code>.)</p>
</td></tr>
<tr><td><code id="dgwdspL-ergmTerm_+3A_type">type</code></td>
<td>
<p>A string indicating the type of shared partner or path to be considered for directed networks: <code>"OTP"</code> (default for directed), <code>"ITP"</code>, <code>"RTP"</code>, <code>"OSP"</code>, and <code>"ISP"</code>; has no effect for undirected. See the section below on Shared partner types for details.</p>
</td></tr>
<tr><td><code id="dgwdspL-ergmTerm_+3A_ls.path">Ls.path</code>, <code id="dgwdspL-ergmTerm_+3A_l.in_order">L.in_order</code></td>
<td>
<p>a vector of one or two formulas <code>Ls.path</code>
provides the Layer Logic (c.f. Layer Logic section in the
<code><a href="#topic+Layer">Layer()</a></code> documentation) specifications for the ties of the
2-path or the shared partnership. (If only one formula is given
the layers are assumed to be the same.) If <code>L.in_order==TRUE</code> ,
the first tie of the two-path must be the first element of
<code>Ls.path</code> and the second must be the second; otherwise, any
ordering counts, provided there is exactly one of each. (For
types <code>"OSP"</code> and <code>"ISP"</code> , the first tie is considered to be the
one incident on the tail of the base tie.)</p>
</td></tr>
</table>


<h3>Shared partner types</h3>

<p>While there is only one shared partner configuration in the undirected
case, nine distinct configurations are possible for directed graphs, selected
using the <code>type</code> argument. Currently, terms may be defined with respect to
five of these configurations; they are defined here as follows (using
terminology from Butts (2008) and the <code>relevent</code> package):
</p>

<ul>
<li><p> Outgoing Two-path (<code>"OTP"</code>): vertex <code class="reqn">k</code> is an OTP shared partner of ordered
pair <code class="reqn">(i,j)</code> iff <code class="reqn">i \to k \to j</code>. Also known as &quot;transitive
shared partner&quot;.
</p>
</li>
<li><p> Incoming Two-path (<code>"ITP"</code>): vertex <code class="reqn">k</code> is an ITP shared partner of ordered
pair <code class="reqn">(i,j)</code> iff <code class="reqn">j \to k \to i</code>. Also known as &quot;cyclical shared
partner&quot;
</p>
</li>
<li><p> Reciprocated Two-path (<code>"RTP"</code>): vertex <code class="reqn">k</code> is an RTP shared partner of ordered
pair <code class="reqn">(i,j)</code> iff <code class="reqn">i \leftrightarrow k \leftrightarrow j</code>.
</p>
</li>
<li><p> Outgoing Shared Partner (<code>"OSP"</code>): vertex <code class="reqn">k</code> is an OSP shared partner of
ordered pair <code class="reqn">(i,j)</code> iff <code class="reqn">i \to k, j \to k</code>.
</p>
</li>
<li><p> Incoming Shared Partner (<code>"ISP"</code>): vertex <code class="reqn">k</code> is an ISP shared partner of ordered
pair <code class="reqn">(i,j)</code> iff <code class="reqn">k \to i, k \to j</code>.
By default, outgoing two-paths (<code>"OTP"</code>) are calculated. Note that Robins et al. (2009)
define closely related statistics to several of the above, using slightly different terminology.
</p>
</li></ul>



<h3>Note</h3>

<p>This term takes an additional term option (see
<code><a href="ergm.html#topic+ergm-options">options?ergm</a></code>), <code>cache.sp</code>, controlling whether
the implementation will cache the number of shared partners for
each dyad in the network; this is usually enabled by default.
</p>


<h3>See Also</h3>

<p><code><a href="ergm.html#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, layer-aware, undirected, binary</p>


<hr>
<h2 id='dgwespL-ergmTerm'>Geometrically weighted edgewise shared partner distribution on layers</h2><span id='topic+dgwespL-ergmTerm'></span><span id='topic+InitErgmTerm.dgwespL'></span><span id='topic+InitErgmTerm.gwespL'></span><span id='topic+gwespL-ergmTerm'></span>

<h3>Description</h3>

<p>This term adds a statistic equal to the geometrically weighted edgewise (not dyadwise) shared partner distribution with decay parameter. For a directed network, multiple shared partner definitions are possible.
</p>
<p><code>gdwespL</code> and <code>dgwespL</code> are aliases for consistency with <span class="pkg">ergm</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: dgwespL(decay, fixed=FALSE, cutoff=30, type="OTP", L.base=NULL,
#                 Ls.path=NULL, L.in_order=FALSE)

# binary: gwespL(decay, fixed=FALSE, cutoff=30, type="OTP", L.base=NULL,
#                Ls.path=NULL, L.in_order=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dgwespL-ergmTerm_+3A_decay">decay</code></td>
<td>
<p>nonnegative decay parameter for the shared partner or selected directed analogue count; required if <code>fixed=TRUE</code> and ignored with a warning otherwise.</p>
</td></tr>
<tr><td><code id="dgwespL-ergmTerm_+3A_fixed">fixed</code></td>
<td>
<p>optional argument indicating
whether the <code>decay</code> parameter is fixed at the given value, or is to be fit as a curved
exponential-family model (see Hunter and Handcock, 2006). The
default is <code>FALSE</code> , which means the scale parameter is not
fixed and thus the model is a curved exponential family.</p>
</td></tr>
<tr><td><code id="dgwespL-ergmTerm_+3A_cutoff">cutoff</code></td>
<td>
<p>This optional argument sets the number of underlying ESP terms
to use in computing the statistics when <code>fixed=FALSE</code>, in order to reduce
the computational burden.  Its default value can also be controlled by the
<code>gw.cutoff</code> term option control parameter. (See <code>?control.ergm</code>.)</p>
</td></tr>
<tr><td><code id="dgwespL-ergmTerm_+3A_type">type</code></td>
<td>
<p>A string indicating the type of shared partner or path to be considered for directed networks: <code>"OTP"</code> (default for directed), <code>"ITP"</code>, <code>"RTP"</code>, <code>"OSP"</code>, and <code>"ISP"</code>; has no effect for undirected. See the section below on Shared partner types for details.</p>
</td></tr>
<tr><td><code id="dgwespL-ergmTerm_+3A_l.base">L.base</code></td>
<td>
<p>the Layer Logic (c.f. Layer Logic section in the
<code><a href="#topic+Layer">Layer()</a></code> documentation) specification for the base</p>
</td></tr>
<tr><td><code id="dgwespL-ergmTerm_+3A_ls.path">Ls.path</code>, <code id="dgwespL-ergmTerm_+3A_l.in_order">L.in_order</code></td>
<td>
<p>a vector of one or two formulas <code>Ls.path</code>
provides the Layer Logic (c.f. Layer Logic section in the
<code><a href="#topic+Layer">Layer()</a></code> documentation) specifications for the ties of the
2-path or the shared partnership. (If only one formula is given
the layers are assumed to be the same.) If <code>L.in_order==TRUE</code> ,
the first tie of the two-path must be the first element of
<code>Ls.path</code> and the second must be the second; otherwise, any
ordering counts, provided there is exactly one of each. (For
types <code>"OSP"</code> and <code>"ISP"</code> , the first tie is considered to be the
one incident on the tail of the base tie.)</p>
</td></tr>
</table>


<h3>Shared partner types</h3>

<p>While there is only one shared partner configuration in the undirected
case, nine distinct configurations are possible for directed graphs, selected
using the <code>type</code> argument. Currently, terms may be defined with respect to
five of these configurations; they are defined here as follows (using
terminology from Butts (2008) and the <code>relevent</code> package):
</p>

<ul>
<li><p> Outgoing Two-path (<code>"OTP"</code>): vertex <code class="reqn">k</code> is an OTP shared partner of ordered
pair <code class="reqn">(i,j)</code> iff <code class="reqn">i \to k \to j</code>. Also known as &quot;transitive
shared partner&quot;.
</p>
</li>
<li><p> Incoming Two-path (<code>"ITP"</code>): vertex <code class="reqn">k</code> is an ITP shared partner of ordered
pair <code class="reqn">(i,j)</code> iff <code class="reqn">j \to k \to i</code>. Also known as &quot;cyclical shared
partner&quot;
</p>
</li>
<li><p> Reciprocated Two-path (<code>"RTP"</code>): vertex <code class="reqn">k</code> is an RTP shared partner of ordered
pair <code class="reqn">(i,j)</code> iff <code class="reqn">i \leftrightarrow k \leftrightarrow j</code>.
</p>
</li>
<li><p> Outgoing Shared Partner (<code>"OSP"</code>): vertex <code class="reqn">k</code> is an OSP shared partner of
ordered pair <code class="reqn">(i,j)</code> iff <code class="reqn">i \to k, j \to k</code>.
</p>
</li>
<li><p> Incoming Shared Partner (<code>"ISP"</code>): vertex <code class="reqn">k</code> is an ISP shared partner of ordered
pair <code class="reqn">(i,j)</code> iff <code class="reqn">k \to i, k \to j</code>.
By default, outgoing two-paths (<code>"OTP"</code>) are calculated. Note that Robins et al. (2009)
define closely related statistics to several of the above, using slightly different terminology.
</p>
</li></ul>



<h3>Note</h3>

<p>This term takes an additional term option (see
<code><a href="ergm.html#topic+ergm-options">options?ergm</a></code>), <code>cache.sp</code>, controlling whether
the implementation will cache the number of shared partners for
each dyad in the network; this is usually enabled by default.
</p>


<h3>See Also</h3>

<p><code><a href="ergm.html#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, layer-aware, undirected, binary</p>


<hr>
<h2 id='dgwnspL-ergmTerm'>Geometrically weighted non-edgewise shared partner distribution on layers</h2><span id='topic+dgwnspL-ergmTerm'></span><span id='topic+InitErgmTerm.dgwnspL'></span><span id='topic+InitErgmTerm.gwnspL'></span><span id='topic+gwnspL-ergmTerm'></span>

<h3>Description</h3>

<p>This term is just like <code><a href="#topic+gwespL-ergmTerm">gwespL</a></code> and <code><a href="#topic+gwdspL-ergmTerm">gwdspL</a></code> except it adds a statistic equal to the geometrically weighted nonedgewise (that is, over dyads that do not have an edge) shared partner distribution with decay parameter. For a directed network, multiple shared partner definitions are possible.
</p>
<p><code>gdwnspL</code> and <code>dgwnspL</code> are aliases for consistency with <span class="pkg">ergm</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: dgwnspL(decay, fixed=FALSE, cutoff=30, type="OTP", L.base=NULL,
#                 Ls.path=NULL, L.in_order=FALSE)

# binary: gwnspL(decay, fixed=FALSE, cutoff=30, type="OTP", L.base=NULL,
#                Ls.path=NULL, L.in_order=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dgwnspL-ergmTerm_+3A_decay">decay</code></td>
<td>
<p>nonnegative decay parameter for the shared partner or selected directed analogue count; required if <code>fixed=TRUE</code> and ignored with a warning otherwise.</p>
</td></tr>
<tr><td><code id="dgwnspL-ergmTerm_+3A_fixed">fixed</code></td>
<td>
<p>optional argument indicating
whether the <code>decay</code> parameter is fixed at the given value, or is to be fit as a curved
exponential-family model (see Hunter and Handcock, 2006). The
default is <code>FALSE</code> , which means the scale parameter is not
fixed and thus the model is a curved exponential family.</p>
</td></tr>
<tr><td><code id="dgwnspL-ergmTerm_+3A_cutoff">cutoff</code></td>
<td>
<p>This optional argument sets the number of underlying NSP terms
to use in computing the statistics when <code>fixed=FALSE</code>, in order to reduce
the computational burden.  Its default value can also be controlled by the
<code>gw.cutoff</code> term option control parameter. (See <code>?control.ergm</code>.)</p>
</td></tr>
<tr><td><code id="dgwnspL-ergmTerm_+3A_type">type</code></td>
<td>
<p>A string indicating the type of shared partner or path to be considered for directed networks: <code>"OTP"</code> (default for directed), <code>"ITP"</code>, <code>"RTP"</code>, <code>"OSP"</code>, and <code>"ISP"</code>; has no effect for undirected. See the section below on Shared partner types for details.</p>
</td></tr>
<tr><td><code id="dgwnspL-ergmTerm_+3A_l.base">L.base</code></td>
<td>
<p>the Layer Logic (c.f. Layer Logic section in the
<code><a href="#topic+Layer">Layer()</a></code> documentation) specification for the base</p>
</td></tr>
<tr><td><code id="dgwnspL-ergmTerm_+3A_ls.path">Ls.path</code>, <code id="dgwnspL-ergmTerm_+3A_l.in_order">L.in_order</code></td>
<td>
<p>a vector of one or two formulas <code>Ls.path</code>
provides the Layer Logic (c.f. Layer Logic section in the
<code><a href="#topic+Layer">Layer()</a></code> documentation) specifications for the ties of the
2-path or the shared partnership. (If only one formula is given
the layers are assumed to be the same.) If <code>L.in_order==TRUE</code> ,
the first tie of the two-path must be the first element of
<code>Ls.path</code> and the second must be the second; otherwise, any
ordering counts, provided there is exactly one of each. (For
types <code>"OSP"</code> and <code>"ISP"</code> , the first tie is considered to be the
one incident on the tail of the base tie.)</p>
</td></tr>
</table>


<h3>Shared partner types</h3>

<p>While there is only one shared partner configuration in the undirected
case, nine distinct configurations are possible for directed graphs, selected
using the <code>type</code> argument. Currently, terms may be defined with respect to
five of these configurations; they are defined here as follows (using
terminology from Butts (2008) and the <code>relevent</code> package):
</p>

<ul>
<li><p> Outgoing Two-path (<code>"OTP"</code>): vertex <code class="reqn">k</code> is an OTP shared partner of ordered
pair <code class="reqn">(i,j)</code> iff <code class="reqn">i \to k \to j</code>. Also known as &quot;transitive
shared partner&quot;.
</p>
</li>
<li><p> Incoming Two-path (<code>"ITP"</code>): vertex <code class="reqn">k</code> is an ITP shared partner of ordered
pair <code class="reqn">(i,j)</code> iff <code class="reqn">j \to k \to i</code>. Also known as &quot;cyclical shared
partner&quot;
</p>
</li>
<li><p> Reciprocated Two-path (<code>"RTP"</code>): vertex <code class="reqn">k</code> is an RTP shared partner of ordered
pair <code class="reqn">(i,j)</code> iff <code class="reqn">i \leftrightarrow k \leftrightarrow j</code>.
</p>
</li>
<li><p> Outgoing Shared Partner (<code>"OSP"</code>): vertex <code class="reqn">k</code> is an OSP shared partner of
ordered pair <code class="reqn">(i,j)</code> iff <code class="reqn">i \to k, j \to k</code>.
</p>
</li>
<li><p> Incoming Shared Partner (<code>"ISP"</code>): vertex <code class="reqn">k</code> is an ISP shared partner of ordered
pair <code class="reqn">(i,j)</code> iff <code class="reqn">k \to i, k \to j</code>.
By default, outgoing two-paths (<code>"OTP"</code>) are calculated. Note that Robins et al. (2009)
define closely related statistics to several of the above, using slightly different terminology.
</p>
</li></ul>



<h3>Note</h3>

<p>This term takes an additional term option (see
<code><a href="ergm.html#topic+ergm-options">options?ergm</a></code>), <code>cache.sp</code>, controlling whether
the implementation will cache the number of shared partners for
each dyad in the network; this is usually enabled by default.
</p>


<h3>See Also</h3>

<p><code><a href="ergm.html#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, layer-aware, undirected, binary</p>


<hr>
<h2 id='direct.network'>Returns a directed version of an undirected binary network</h2><span id='topic+direct.network'></span>

<h3>Description</h3>

<p>Returns a directed version of an undirected binary network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>direct.network(x, rule = c("both", "upper", "lower"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="direct.network_+3A_x">x</code></td>
<td>
<p>a <code><a href="network.html#topic+network">network</a></code> object.</p>
</td></tr>
<tr><td><code id="direct.network_+3A_rule">rule</code></td>
<td>
<p>a string specifying how the network is to be
constructed.</p>
</td></tr>
</table>

<hr>
<h2 id='dnspL-ergmTerm'>Non-edgewise shared partners and paths on layers</h2><span id='topic+dnspL-ergmTerm'></span><span id='topic+InitErgmTerm.dnspL'></span><span id='topic+InitErgmTerm.nspL'></span><span id='topic+nspL-ergmTerm'></span>

<h3>Description</h3>

<p>This term adds one network statistic to the model for each element in <code>d</code> where the <code class="reqn">i</code> th such statistic equals the number of non-edges in the network with exactly <code>d[i]</code> shared partners. For a directed network, multiple shared partner definitions are possible.
</p>
<p><code>nspL</code> and <code>dnspL</code> are aliases for consistency with <span class="pkg">ergm</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: dnspL(d, type="OTP", L.base=NULL, Ls.path=NULL, L.in_order=FALSE)

# binary: nspL(d, type="OTP", L.base=NULL, Ls.path=NULL, L.in_order=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dnspL-ergmTerm_+3A_d">d</code></td>
<td>
<p>a vector of distinct integers</p>
</td></tr>
<tr><td><code id="dnspL-ergmTerm_+3A_type">type</code></td>
<td>
<p>A string indicating the type of shared partner or path to be considered for directed networks: <code>"OTP"</code> (default for directed), <code>"ITP"</code>, <code>"RTP"</code>, <code>"OSP"</code>, and <code>"ISP"</code>; has no effect for undirected. See the section below on Shared partner types for details.</p>
</td></tr>
<tr><td><code id="dnspL-ergmTerm_+3A_l.base">L.base</code></td>
<td>
<p>the Layer Logic (c.f. Layer Logic section in the
<code><a href="#topic+Layer">Layer()</a></code> documentation) specification for the base</p>
</td></tr>
<tr><td><code id="dnspL-ergmTerm_+3A_ls.path">Ls.path</code>, <code id="dnspL-ergmTerm_+3A_l.in_order">L.in_order</code></td>
<td>
<p>a vector of one or two formulas <code>Ls.path</code>
provides the Layer Logic (c.f. Layer Logic section in the
<code><a href="#topic+Layer">Layer()</a></code> documentation) specifications for the ties of the
2-path or the shared partnership. (If only one formula is given
the layers are assumed to be the same.) If <code>L.in_order==TRUE</code> ,
the first tie of the two-path must be the first element of
<code>Ls.path</code> and the second must be the second; otherwise, any
ordering counts, provided there is exactly one of each. (For
types <code>"OSP"</code> and <code>"ISP"</code> , the first tie is considered to be the
one incident on the tail of the base tie.)</p>
</td></tr>
</table>


<h3>Shared partner types</h3>

<p>While there is only one shared partner configuration in the undirected
case, nine distinct configurations are possible for directed graphs, selected
using the <code>type</code> argument. Currently, terms may be defined with respect to
five of these configurations; they are defined here as follows (using
terminology from Butts (2008) and the <code>relevent</code> package):
</p>

<ul>
<li><p> Outgoing Two-path (<code>"OTP"</code>): vertex <code class="reqn">k</code> is an OTP shared partner of ordered
pair <code class="reqn">(i,j)</code> iff <code class="reqn">i \to k \to j</code>. Also known as &quot;transitive
shared partner&quot;.
</p>
</li>
<li><p> Incoming Two-path (<code>"ITP"</code>): vertex <code class="reqn">k</code> is an ITP shared partner of ordered
pair <code class="reqn">(i,j)</code> iff <code class="reqn">j \to k \to i</code>. Also known as &quot;cyclical shared
partner&quot;
</p>
</li>
<li><p> Reciprocated Two-path (<code>"RTP"</code>): vertex <code class="reqn">k</code> is an RTP shared partner of ordered
pair <code class="reqn">(i,j)</code> iff <code class="reqn">i \leftrightarrow k \leftrightarrow j</code>.
</p>
</li>
<li><p> Outgoing Shared Partner (<code>"OSP"</code>): vertex <code class="reqn">k</code> is an OSP shared partner of
ordered pair <code class="reqn">(i,j)</code> iff <code class="reqn">i \to k, j \to k</code>.
</p>
</li>
<li><p> Incoming Shared Partner (<code>"ISP"</code>): vertex <code class="reqn">k</code> is an ISP shared partner of ordered
pair <code class="reqn">(i,j)</code> iff <code class="reqn">k \to i, k \to j</code>.
By default, outgoing two-paths (<code>"OTP"</code>) are calculated. Note that Robins et al. (2009)
define closely related statistics to several of the above, using slightly different terminology.
</p>
</li></ul>



<h3>Note</h3>

<p>This term takes an additional term option (see
<code><a href="ergm.html#topic+ergm-options">options?ergm</a></code>), <code>cache.sp</code>, controlling whether
the implementation will cache the number of shared partners for
each dyad in the network; this is usually enabled by default.
</p>


<h3>See Also</h3>

<p><code><a href="ergm.html#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, layer-aware, undirected, binary</p>


<hr>
<h2 id='ergm_block_diag_samp_info'>Compute and serialize information needed by the block-diagonal
Metropolis-Hastings samplers.</h2><span id='topic+ergm_block_diag_samp_info'></span>

<h3>Description</h3>

<p>Given a nodal attribute vector specifying the blocks
returns a list containing information needed to efficiently
sample dyads in those blocks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ergm_block_diag_samp_info(nw, a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ergm_block_diag_samp_info_+3A_nw">nw</code></td>
<td>
<p>the network of interest.</p>
</td></tr>
<tr><td><code id="ergm_block_diag_samp_info_+3A_a">a</code></td>
<td>
<p>either a vector (of any mode) whose <code class="reqn">i</code>th element
identifies the block to which vertex <code class="reqn">i</code> belongs. Blocks must
be continguous.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of nonce class <code>ergm_block_diag_samp_info</code> with
the following elements at this time:
</p>

<dl>
<dt><code>nblk</code></dt><dd><p>number of blocks</p>
</dd>
<dt><code>pos</code> (for unipartite), <code>b1pos</code> and <code>b2pos</code> (for
bipartite)</dt><dd><p>vectors of length <code>nblk+1</code> such that
<code>(pos[i]+1):(pos[i+1])</code> are the numbers of the vertices in block
<code>i</code>.</p>
</dd>
<dt><code>cumwt</code></dt><dd><p>vector of length <code>nblk</code> with values such that
generating <code class="reqn">U\sim \mathrm{Uniform}(0,1)</code>
selecting the index of the first element in <code>cumwt</code> that is greater
than <code class="reqn">U</code> will sample from the blocks in proportion to the
number of dyads in the block.</p>
</dd>
</dl>

<p>In addition, an attribute <code>"ndyads"</code> is attached, containing the
total number of dyads in all blocks put together.
</p>

<hr>
<h2 id='ergm_LayerLogic'>Internal representation of Layer Logic</h2><span id='topic+ergm_LayerLogic'></span><span id='topic+toString.ergm_LayerLogic'></span><span id='topic+to_ergm_Cdouble.ergm_LayerLogic'></span>

<h3>Description</h3>

<p>Internal representation of Layer Logic
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ergm_LayerLogic(formula, namemap = NULL)

## S3 method for class 'ergm_LayerLogic'
toString(x, ...)

## S3 method for class 'ergm_LayerLogic'
to_ergm_Cdouble(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ergm_LayerLogic_+3A_formula">formula</code></td>
<td>
<p>A Layer Logic formula.</p>
</td></tr>
<tr><td><code id="ergm_LayerLogic_+3A_namemap">namemap</code></td>
<td>
<p>A character vector giving the names of the layers
referenced, or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="ergm_LayerLogic_+3A_x">x</code></td>
<td>
<p>An <code>ergm_LayerLogic</code> object.</p>
</td></tr>
<tr><td><code id="ergm_LayerLogic_+3A_...">...</code></td>
<td>
<p>Additional arguments, currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A structure with nonce class
<code>c("ergm_LayerLogic",class(formula))</code>, comprising the input
<code>formula</code> and an attribute <code>namemap</code> containing the <code>namemap</code>.
</p>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>toString(ergm_LayerLogic)</code>: A method to generate coefficient names
associated with the Layer Logic.
</p>
</li>
<li> <p><code>to_ergm_Cdouble(ergm_LayerLogic)</code>: A method to encode and serialize the
Layer Logic into a postfix program understood by the C code.
</p>
</li></ul>

<hr>
<h2 id='ergm.multi-package'>ergm.multi: Fit, Simulate and Diagnose Exponential-Family Models for Multiple or Multilayer Networks</h2><span id='topic+ergm.multi'></span><span id='topic+ergm.multi-package'></span>

<h3>Description</h3>

<p>A set of extensions for the 'ergm' package to fit multilayer/multiplex/multirelational networks and samples of multiple networks. 'ergm.multi' is a part of the Statnet suite of packages for network analysis. See Krivitsky, Koehly, and Marcum (2020) <a href="https://doi.org/10.1007/s11336-020-09720-7">doi:10.1007/s11336-020-09720-7</a> and Krivitsky, Coletti, and Hens (2023) <a href="https://doi.org/10.1080/01621459.2023.2242627">doi:10.1080/01621459.2023.2242627</a>.
</p>


<h3>Multilayer network models</h3>

<p>Also known as multiplex,
multirelational, or multivariate networks, in a multilayer network a pair
of actors can have multiple simultaneous relations of different
types. For example, in the <a href="#topic+Lazega">Lazega</a> lawyer data set included with
this package, each pair of lawyers in the firm can have an advice
relationship, a coworking relationship, a friendship
relationship, or any combination thereof. Application of ERGMs to
multilayer networks has a long history
(Pattison and Wasserman 1999; Lazega and Pattison 1999), and a number of <span class="rlang"><b>R</b></span>
packages exist for analysing and estimating them.
</p>
<p><span class="pkg">ergm.multi</span> implements the general approach of
Krivitsky et al. (2020) for specifying
multilayer ERGMs, including Layer Logic and the various
cross-layer specifications. Its features include:
</p>

<dl>
<dt>seamless integration with <code><a href="ergm.html#topic+ergm">ergm()</a></code>:</dt><dd><p>Multilayer
specification is contained entirely in an <code><a href="ergm.html#topic+ergm">ergm()</a></code>-style formula and can be
nested with any other <code><a href="ergm.html#topic+ergm">ergm()</a></code> terms, including dynamic and multi-network.</p>
</dd>
<dt>unlimited layers:</dt><dd><p>The number of layers in the modeled
network is limited only by computing power.</p>
</dd>
<dt>flexibility and simplicity:</dt><dd><p><em>Any</em> valid binary ERGM can be
specified for any layer or a logical combination of layers
using simple term operators.</p>
</dd>
<dt>heterogeneous layers:</dt><dd><p>A network can have directed and
undirected layers, which can be modeled jointly.</p>
</dd>
<dt>multimode/multilevel support (experimental):</dt><dd><p>With some
care, it is possible to specify models for unipartite and
bipartie layers over different subsets of actors, which can be
used to specify multimode models.</p>
</dd>
</dl>

<p>See <code><a href="#topic+Layer">Layer()</a></code> and <code><a href="#topic+L-ergmTerm">ergmTerm?L</a></code> for examples.
</p>


<h3>Multi-network models</h3>

<p>Joint modeling of independent
samples of networks on disjoint sets of actors have a long
history as well (Zijlstra et al. 2006, Slaughter and Koehly 2016, Stewart et al. 2019, and Vega Yon et al. 2021, for example).
<span class="pkg">ergm.multi</span> facilitates
fixed-effect models for samples of networks (possibly
heterogeneous in size and composition), using a multivariate
linear model for each network's ERGM parameters, with
network-level attributes serving as predictors, as formulated by
Slaughter and Koehly (2016) and
Krivitsky et al. (2023).
</p>
<p>Its features include:
</p>

<dl>
<dt>seamless integration with <code><a href="ergm.html#topic+ergm">ergm()</a></code>:</dt><dd><p>Multi-network model
specification is contained entirely in an <code><a href="ergm.html#topic+ergm">ergm()</a></code>-style formula and can be
nested with any other <code><a href="ergm.html#topic+ergm">ergm()</a></code> terms, including dynamic and multilayer.</p>
</dd>
<dt>flexibility and simplicity:</dt><dd><p><em>Any</em> valid binary or valued
ERGM can be specified for the networks, using simple term
operators and the network-level specification with an
<code><a href="stats.html#topic+lm">lm()</a></code>-style formula.</p>
</dd>
</dl>

<p>See <code><a href="#topic+Networks">Networks()</a></code>, <code><a href="#topic+N-ergmTerm">ergmTerm?N</a></code> for specification,
<code><a href="#topic+gofN">gofN()</a></code> for diagnostic facilities, and
<code>vignette("Goeyvaerts_reproduction")</code> for a demonstration.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Pavel N. Krivitsky <a href="mailto:pavel@statnet.org">pavel@statnet.org</a> (<a href="https://orcid.org/0000-0002-9101-3362">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Mark S. Handcock <a href="mailto:handcock@stat.ucla.edu">handcock@stat.ucla.edu</a> [contributor]
</p>
</li>
<li><p> David R. Hunter <a href="mailto:dhunter@stat.psu.edu">dhunter@stat.psu.edu</a> [contributor]
</p>
</li>
<li><p> Chad Klumb <a href="mailto:cklumb@gmail.com">cklumb@gmail.com</a> [contributor]
</p>
</li>
<li><p> Pietro Coletti <a href="mailto:pietro.coletti@uhasselt.be">pietro.coletti@uhasselt.be</a> [contributor]
</p>
</li>
<li><p> Joyce Cheng <a href="mailto:joyce.cheng@student.unsw.edu.au">joyce.cheng@student.unsw.edu.au</a> [contributor]
</p>
</li></ul>



<h3>References</h3>

<p>Krivitsky PN, Coletti P, Hens N (2023).
&ldquo;A Tale of Two Datasets: Representativeness and Generalisability of Inference for Samples of Networks.&rdquo;
<em>Journal of the American Statistical Association</em>, <b>118</b>(544), 2213-2224.
<a href="https://doi.org/10.1080/01621459.2023.2242627">doi:10.1080/01621459.2023.2242627</a>.<br /><br /> Krivitsky PN, Koehly LM, Marcum CS (2020).
&ldquo;Exponential-family Random Graph Models for Multi-layer Networks.&rdquo;
<em>Psychometrika</em>, <b>85</b>(3), 630&ndash;659.
<a href="https://doi.org/10.1007/s11336-020-09720-7">doi:10.1007/s11336-020-09720-7</a>.<br /><br /> Lazega E, Pattison PE (1999).
&ldquo;Multiplexity, Generalized Exchange and Cooperation in Organizations: A Case Study.&rdquo;
<em>Social Networks</em>, <b>21</b>(1), 67&ndash;90.
<a href="https://doi.org/10.1016/S0378-8733%2899%2900002-7">doi:10.1016/S0378-8733(99)00002-7</a>.<br /><br /> Pattison P, Wasserman S (1999).
&ldquo;Logit Models and Logistic Regressions for Social Networks: II. Multivariate Relations.&rdquo;
<em>British Journal of Mathematical and Statistical Psychology</em>, <b>52</b>(2), 169&ndash;193.<br /><br /> Slaughter AJ, Koehly LM (2016).
&ldquo;Multilevel Models for Social Networks: Hierarchical Bayesian Approaches to Exponential Random Graph Modeling.&rdquo;
<em>Social Networks</em>, <b>44</b>, 334&ndash;345.
<a href="https://doi.org/10.1016/j.socnet.2015.11.002">doi:10.1016/j.socnet.2015.11.002</a>.<br /><br /> Stewart J, Schweinberger M, Bojanowski M, Morris M (2019).
&ldquo;Multilevel Network Data Facilitate Statistical Inference for Curved ERGMs with Geometrically Weighted Terms.&rdquo;
<em>Social Networks</em>, <b>59</b>, 98&ndash;119.
<a href="https://doi.org/10.1016/j.socnet.2018.11.003">doi:10.1016/j.socnet.2018.11.003</a>.<br /><br /> Vega Yon GG, Slaughter A, de la Haye K (2021).
&ldquo;Exponential Random Graph Models for Little Networks.&rdquo;
<em>Social Networks</em>, <b>64</b>, 225&ndash;238.
<a href="https://doi.org/10.1016/j.socnet.2020.07.005">doi:10.1016/j.socnet.2020.07.005</a>.<br /><br /> Zijlstra BJH, Van Duijn MAJ, Snijders TAB (2006).
&ldquo;The Multilevel <code class="reqn">p_2</code> Model: A Random Effects Model for the Analysis of Multiple Social Networks.&rdquo;
<em>Methodology</em>, <b>2</b>(1), 42.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://statnet.org">https://statnet.org</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/statnet/ergm.multi/issues">https://github.com/statnet/ergm.multi/issues</a>
</p>
</li></ul>


<hr>
<h2 id='Goeyvaerts'>A sample of within-household contact networks in Flanders and Brussels</h2><span id='topic+Goeyvaerts'></span>

<h3>Description</h3>

<p>This is a list of 318 <code><a href="network.html#topic+network">network</a></code> objects derived from contact
diary data collected by by Goeyvaerts et al. (2018). The
study recruited households in Flanders and Brussels-Capital region
with at least one child 12 or under. The networks are symmetrized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Goeyvaerts)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 318.
</p>


<h3>Nonstandard Network Attributes</h3>


<dl>
<dt><code>included</code></dt><dd><p>(logical) whether the network was included in
Goeyvaerts's analysis. (Two were excluded.)</p>
</dd>
<dt><code>weekday</code></dt><dd><p>(logical) whether the contact diary on which the
network is based was collected on a weekday, as opposed to
weekend.</p>
</dd>
</dl>



<h3>Nonstandard Vertex Attributes</h3>


<dl>
<dt><code>age</code></dt><dd><p>(numeric) the household member's age.</p>
</dd>
<dt><code>gender</code></dt><dd><p>(character) the household member's gender (<code>"F"</code>/<code>"M"</code>).</p>
</dd>
<dt><code>role</code></dt><dd><p>(character) the household member's inferred role (<code>"Father"</code>/<code>"Mother"</code>/<code>"Child"</code>/<code>"Grandmother"</code>).</p>
</dd>
</dl>



<h3>Licenses and Citation</h3>

<p>When publishing results obtained
using this data set, the original authors
(Goeyvaerts et al. 2018) should be cited, along with this
<span class="rlang"><b>R</b></span> package.
</p>


<h3>Source</h3>

<p>The data were collected and by Goeyvaerts et al. (2018) and
curated by Pietro Coletti.
</p>


<h3>References</h3>

<p>Goeyvaerts N, Santermans E, Potter G, Torneri A, Kerckhove KV, Willem L, Aerts M, Beutels P, Hens N (2018).
&ldquo;Household Members Do Not Contact Each Other at Random: Implications for Infectious Disease Modelling.&rdquo;
<em>Proceedings of the Royal Society B: Biological Sciences</em>, <b>285</b>(1893), 20182201.
<a href="https://doi.org/10.1098/rspb.2018.2201">doi:10.1098/rspb.2018.2201</a>.
</p>


<h3>See Also</h3>

<p><code>vignette("Goeyvaerts_reproduction")</code> for a vignette reproducing the Goeyvaerts analysis and performing diagnostics
</p>

<hr>
<h2 id='gofN'>Linear model diagnostics for multinetwork linear models</h2><span id='topic+gofN'></span><span id='topic++5B.gofN'></span><span id='topic+augment.gofN'></span><span id='topic+summary.gofN'></span>

<h3>Description</h3>

<p><code><a href="#topic+gofN">gofN()</a></code> performs a simulation to obtain Pearson residuals for the
multivariate linear model for ERGM parameters, which can then be
used for a variety of diagnostics and diagnostic plots developed by
Krivitsky et al. (2023).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gofN(
  object,
  GOF = NULL,
  subset = TRUE,
  control = control.gofN.ergm(),
  save_stats = FALSE,
  ...
)

## S3 method for class 'gofN'
x[i, j, ..., drop = FALSE]

## S3 method for class 'gofN'
augment(x, ...)

## S3 method for class 'gofN'
summary(object, by = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gofN_+3A_object">object</code></td>
<td>
<p>an <code><a href="ergm.html#topic+ergm">ergm</a></code> object.</p>
</td></tr>
<tr><td><code id="gofN_+3A_gof">GOF</code></td>
<td>
<p>a one-sided <code><a href="ergm.html#topic+ergm">ergm</a></code> formula specifying network
statistics whose goodness of fit to test, or <code><a href="base.html#topic+NULL">NULL</a></code>; if <code>NULL</code>,
uses the original model.</p>
</td></tr>
<tr><td><code id="gofN_+3A_subset">subset</code></td>
<td>
<p>argument for the <code><a href="#topic+N-ergmTerm">N</a></code> term.</p>
</td></tr>
<tr><td><code id="gofN_+3A_control">control</code></td>
<td>
<p>See <code><a href="#topic+control.gofN.ergm">control.gofN.ergm()</a></code>.</p>
</td></tr>
<tr><td><code id="gofN_+3A_save_stats">save_stats</code></td>
<td>
<p>If <code>TRUE</code>, save the simulated network statistics;
defaults to <code>FALSE</code> to save memory and disk space.</p>
</td></tr>
<tr><td><code id="gofN_+3A_...">...</code></td>
<td>
<p>additional arguments to functions (<code><a href="ergm.html#topic+simulate.ergm">simulate.ergm()</a></code>
and <code><a href="ergm.html#topic+summary.ergm_model">summary.ergm_model()</a></code>) for the constructor.</p>
</td></tr>
<tr><td><code id="gofN_+3A_x">x</code></td>
<td>
<p>a <code>gofN</code> object.</p>
</td></tr>
<tr><td><code id="gofN_+3A_i">i</code></td>
<td>
<p>for the indexing operator, index of statistics to be kept in the subset.</p>
</td></tr>
<tr><td><code id="gofN_+3A_j">j</code></td>
<td>
<p>for the indexing operator, index of networks to be kept in the subset.</p>
</td></tr>
<tr><td><code id="gofN_+3A_drop">drop</code></td>
<td>
<p>whether the indexing operator should drop attributes and return simply a list.</p>
</td></tr>
<tr><td><code id="gofN_+3A_by">by</code></td>
<td>
<p>a numeric or character vector, or a formula whose RHS gives an expression in terms of network attributes, used as a grouping variable for summarizing the values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>gofN</code>: a named list containing a list
for every statistic in the specified <code>GOF</code> formula with the
following elements vectors of length equal to the number of
subnetworks:
</p>
<table>
<tr><td><code>observed</code></td>
<td>
<p>For completely observed networks, their value of
the statistic. For partially observed networks, the expected value
of their imputations under the model.</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>Expected value of the statistic under the model.</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>Variance of the statistic under the model.</p>
</td></tr>
<tr><td><code>var.obs</code></td>
<td>
<p>Conditional variance under imputation statistic.</p>
</td></tr>
<tr><td><code>pearson</code></td>
<td>
<p>The Pearson residual computed from the above.</p>
</td></tr>
<tr><td><code>stats</code>, <code>stats.obs</code></td>
<td>
<p>If <code>save_stats</code> control parameter is <code>TRUE</code>, the simulated statistics.</p>
</td></tr>
</table>
<p>In addition, the following <code><a href="base.html#topic+attr">attr</a></code>-style attributes are included:
</p>
<table>
<tr><td><code>nw</code></td>
<td>
<p>The observed multinetwork object.</p>
</td></tr>
<tr><td><code>subset</code></td>
<td>
<p>A logical vector giving the subset of networks that were used.</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>Control parameters passed.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>[</code>: Extract a subset of statistics for which goodness-of-fit had been computed.
</p>
</li>
<li> <p><code>augment(gofN)</code>: a method for constructing a <code><a href="tibble.html#topic+tibble">tibble</a></code> of network attributes augmented with goodness of fit information. Columns include:</p>

<dl>
<dt>network attributes</dt><dd><p>the attributes of each of the networks</p>
</dd>
<dt><code>.stat_name</code></dt><dd><p>name of the simulated statistic</p>
</dd>
<dt><code>.stat_id</code></dt><dd><p>index of the simulated statistic in the <code>gofN</code> object</p>
</dd>
<dt><code>.network_id</code></dt><dd><p>index of the network in the networks for which <code>gofN</code> was run (excluding those not in the subset)</p>
</dd>
<dt><code>.fitted</code></dt><dd><p>predicted value for the statistic</p>
</dd>
<dt><code>.observed</code></dt><dd><p>either the observed (for completely observed networks) or the predicted conditional on observed (for partially observed networks) value of the statistic</p>
</dd>
<dt><code>.pearson</code></dt><dd><p>the standardised Pearson residual</p>
</dd>
<dt><code>.var</code>, <code>.var.obs</code></dt><dd><p>estimated unconditional and average conditional variance of the statistic</p>
</dd>
<dt><code>.weight</code></dt><dd><p>inverse of the variance of the residual</p>
</dd>
</dl>

</li>
<li> <p><code>summary(gofN)</code>: A simple summary function.
</p>
</li></ul>


<h3>References</h3>

<p>Krivitsky PN, Coletti P, Hens N (2023).
&ldquo;A Tale of Two Datasets: Representativeness and Generalisability of Inference for Samples of Networks.&rdquo;
<em>Journal of the American Statistical Association</em>, <b>118</b>(544), 2213-2224.
<a href="https://doi.org/10.1080/01621459.2023.2242627">doi:10.1080/01621459.2023.2242627</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.gofN">plot.gofN()</a></code> and <code><a href="#topic+autoplot.gofN">autoplot.gofN()</a></code> for plotting <code>gofN</code>
objects to make residual plots; <code><a href="ergm.html#topic+gof">ergm::gof()</a></code> for single-network
goodness-of-fit simulations in <a href="https://CRAN.R-project.org/package=ergm"><span class="pkg">ergm</span></a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(samplk)
monks &lt;- Networks(samplk1, samplk2, samplk3,samplk1, samplk2, samplk3,samplk1, samplk2, samplk3)
fit &lt;- ergm(monks~N(~edges+nodematch("group")))
fit.gof &lt;- gofN(fit) # GOF = original model
summary(fit.gof)
plot(fit.gof)
fit.gof &lt;- gofN(fit, GOF=~triangles)
summary(fit.gof)
plot(fit.gof)


samplk1[1,]&lt;-NA
samplk2[,2]&lt;-NA
monks &lt;- Networks(samplk1, samplk2, samplk3,samplk1, samplk2, samplk3,samplk1, samplk2, samplk3)
fit &lt;- ergm(monks~N(~edges+nodematch("group")))
fit.gof &lt;- gofN(fit) # GOF = original model
summary(fit.gof)
plot(fit.gof)
fit.gof &lt;- gofN(fit, GOF=~triangles)
summary(fit.gof)
plot(fit.gof)
plot(fit.gof, against=~log(.fitted)) # Plot against transformed fitted values.


### If 'ggplot2' and 'ggrepel' are installed, illustrate the autoplot() method.
if(require("ggplot2") &amp;&amp; requireNamespace("ggrepel")){
  autoplot(fit.gof)
}

# Default is good enough in this case, but sometimes, we might want to set it higher. E.g.,
## Not run: 
fit.gof &lt;- gofN(fit, GOF=~edges, control=control.gofN.ergm(nsim=400))

## End(Not run)


### If 'generics' is installed, illustrate the augment() method.
if(require("generics")){
  augment(fit.gof)
}

</code></pre>

<hr>
<h2 id='gwb1degreeL-ergmTerm'>Geometrically weighted degree distribution for the first mode in a bipartite (aka two-mode) network</h2><span id='topic+gwb1degreeL-ergmTerm'></span><span id='topic+InitErgmTerm.gwb1degreeL'></span>

<h3>Description</h3>

<p>This term adds one network statistic to the model equal to the weighted
degree distribution with decay controlled by the <code>decay</code> parameter, which should be non-negative,
for nodes in the
first mode of a bipartite network. The first mode of a bipartite network
object is sometimes known as the &quot;actor&quot; mode.
</p>
<p>This term can only be used with undirected bipartite
networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: gwb1degreeL(decay, fixed=FALSE, cutoff=30, levels=NULL, Ls=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gwb1degreeL-ergmTerm_+3A_decay">decay</code></td>
<td>
<p>non-negative model parameter that is the same as theta_s in
equation (14) in Hunter (2007).</p>
</td></tr>
<tr><td><code id="gwb1degreeL-ergmTerm_+3A_fixed">fixed</code></td>
<td>
<p>specify if the value supplied for <code>decay</code> may be fixed (if <code>fixed=TRUE</code> ),
or it may be used as merely the starting value for the estimation
in a curved exponential family model (the default).</p>
</td></tr>
<tr><td><code id="gwb1degreeL-ergmTerm_+3A_attrname">attrname</code></td>
<td>
<p>if specified, then separate degree
statistics are calculated for nodes having each separate
value of the attribute.</p>
</td></tr>
<tr><td><code id="gwb1degreeL-ergmTerm_+3A_cutoff">cutoff</code></td>
<td>
<p>only relevant if <code>fixed=FALSE</code> . In that case it only uses this
number of terms in computing the statistics to reduce the computational
burden. Its default value can also be controlled by the <code>gw.cutoff</code> term option control parameter. (See <code><a href="ergm.html#topic+control.ergm">control.ergm</a></code> .)</p>
</td></tr>
<tr><td><code id="gwb1degreeL-ergmTerm_+3A_levels">levels</code></td>
<td>
<p>a list of layer specifications. If given, degree of a node
<code>i</code> is considered to be the number of edges in all layers,
combined.</p>
</td></tr>
<tr><td><code id="gwb1degreeL-ergmTerm_+3A_ls">Ls</code></td>
<td>
<p>a list (constructed by <code><a href="base.html#topic+list">list()</a></code> or <code><a href="base.html#topic+c">c()</a></code> of one or more Layer Logic specifications (c.f. Layer Logic section in the <code><a href="#topic+Layer">Layer()</a></code> documentation).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="ergm.html#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>bipartite, curved, undirected, binary</p>


<hr>
<h2 id='gwb2degreeL-ergmTerm'>Geometrically weighted degree distribution for the second mode in a bipartite (aka two-mode) network</h2><span id='topic+gwb2degreeL-ergmTerm'></span><span id='topic+InitErgmTerm.gwb2degreeL'></span>

<h3>Description</h3>

<p>This term adds one network statistic to the model equal to the weighted
degree distribution with decay controlled by the which should be non-negative,
for nodes in the
second mode of a bipartite network. The second mode of a bipartite network
object is sometimes known as the &quot;event&quot; mode.
</p>
<p>This term can only be used with undirected bipartite
networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: gwb2degreeL(decay, fixed=FALSE, attrname=NULL, cutoff=30, levels=NULL, Ls=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gwb2degreeL-ergmTerm_+3A_decay">decay</code></td>
<td>
<p>non-negative model parameter that is the same as theta_s in
equation (14) in Hunter (2007).</p>
</td></tr>
<tr><td><code id="gwb2degreeL-ergmTerm_+3A_fixed">fixed</code></td>
<td>
<p>specify if the value supplied for <code>decay</code> may be fixed (if <code>fixed=TRUE</code> ),
or it may be used as merely the starting value for the estimation
in a curved exponential family model (the default).</p>
</td></tr>
<tr><td><code id="gwb2degreeL-ergmTerm_+3A_attrname">attrname</code></td>
<td>
<p>if specified, then separate degree
statistics are calculated for nodes having each separate
value of the attribute.</p>
</td></tr>
<tr><td><code id="gwb2degreeL-ergmTerm_+3A_cutoff">cutoff</code></td>
<td>
<p>only relevant if <code>fixed=FALSE</code> . In that case it only uses this
number of terms in computing the statistics to reduce the computational
burden. Its default value can also be controlled by the <code>gw.cutoff</code> term option control parameter. (See <code><a href="ergm.html#topic+control.ergm">control.ergm</a></code> .)</p>
</td></tr>
<tr><td><code id="gwb2degreeL-ergmTerm_+3A_levels">levels</code></td>
<td>
<p>a list of layer specifications. If given, degree of a node
<code>i</code> is considered to be the number of edges in all layers,
combined.</p>
</td></tr>
<tr><td><code id="gwb2degreeL-ergmTerm_+3A_ls">Ls</code></td>
<td>
<p>a list (constructed by <code><a href="base.html#topic+list">list()</a></code> or <code><a href="base.html#topic+c">c()</a></code> of one or more Layer Logic specifications (c.f. Layer Logic section in the <code><a href="#topic+Layer">Layer()</a></code> documentation).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="ergm.html#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>bipartite, curved, undirected, binary</p>


<hr>
<h2 id='gwdegreeL-ergmTerm'>Geometrically weighted degree distribution</h2><span id='topic+gwdegreeL-ergmTerm'></span><span id='topic+InitErgmTerm.gwdegreeL'></span>

<h3>Description</h3>

<p>This term adds one network statistic to the model equal to the weighted
degree distribution with decay controlled by the <code>decay</code> parameter.
</p>
<p>This term can only be used with undirected networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: gwdegreeL(decay, fixed=FALSE, attrname=NULL, cutoff=30, levels=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gwdegreeL-ergmTerm_+3A_decay">decay</code></td>
<td>
<p>non-negative model parameter that is the same as theta_s in
equation (14) in Hunter (2007).</p>
</td></tr>
<tr><td><code id="gwdegreeL-ergmTerm_+3A_fixed">fixed</code></td>
<td>
<p>specify if the value supplied for <code>decay</code> may be fixed (if <code>fixed=TRUE</code> ),
or it may be used as merely the starting value for the estimation
in a curved exponential family model (the default).</p>
</td></tr>
<tr><td><code id="gwdegreeL-ergmTerm_+3A_attrname">attrname</code></td>
<td>
<p>if specified, then separate degree
statistics are calculated for nodes having each separate
value of the attribute.</p>
</td></tr>
<tr><td><code id="gwdegreeL-ergmTerm_+3A_cutoff">cutoff</code></td>
<td>
<p>only relevant if <code>fixed=FALSE</code> . In that case it only uses this
number of terms in computing the statistics to reduce the computational
burden. Its default value can also be controlled by the <code>gw.cutoff</code> term option control parameter. (See <code><a href="ergm.html#topic+control.ergm">control.ergm</a></code> .)</p>
</td></tr>
<tr><td><code id="gwdegreeL-ergmTerm_+3A_levels">levels</code></td>
<td>
<p>a list of layer specifications. If given, degree of a node
<code>i</code> is considered to be the number of edges in all layers,
combined.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="ergm.html#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>curved, frequently-used, undirected, binary</p>


<hr>
<h2 id='gwidegreeL-ergmTerm'>Geometrically weighted in-degree distribution</h2><span id='topic+gwidegreeL-ergmTerm'></span><span id='topic+InitErgmTerm.gwidegreeL'></span>

<h3>Description</h3>

<p>This term adds one network statistic to the model
equal to the weighted in-degree distribution with decay parameter. This
term can only be used with directed networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: gwidegreeL(decay, fixed=FALSE, attrname=NULL, cutoff=30, levels=NULL, Ls=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gwidegreeL-ergmTerm_+3A_decay">decay</code></td>
<td>
<p>non-negative model parameter that is the same as theta_s in
equation (14) in Hunter (2007).</p>
</td></tr>
<tr><td><code id="gwidegreeL-ergmTerm_+3A_fixed">fixed</code></td>
<td>
<p>specify if the value supplied for <code>decay</code> may be fixed (if <code>fixed=TRUE</code> ),
or it may be used as merely the starting value for the estimation
in a curved exponential family model (the default).</p>
</td></tr>
<tr><td><code id="gwidegreeL-ergmTerm_+3A_attrname">attrname</code></td>
<td>
<p>if specified, then separate degree
statistics are calculated for nodes having each separate
value of the attribute.</p>
</td></tr>
<tr><td><code id="gwidegreeL-ergmTerm_+3A_cutoff">cutoff</code></td>
<td>
<p>only relevant if <code>fixed=FALSE</code> . In that case it only uses this
number of terms in computing the statistics to reduce the computational
burden. Its default value can also be controlled by the <code>gw.cutoff</code> term option control parameter. (See <code><a href="ergm.html#topic+control.ergm">control.ergm</a></code> .)</p>
</td></tr>
<tr><td><code id="gwidegreeL-ergmTerm_+3A_levels">levels</code></td>
<td>
<p>a list of layer specifications. If given, degree of a node
<code>i</code> is considered to be the number of edges in all layers,
combined.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="ergm.html#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>curved, directed, binary</p>


<hr>
<h2 id='gwodegreeL-ergmTerm'>Geometrically weighted out-degree distribution</h2><span id='topic+gwodegreeL-ergmTerm'></span><span id='topic+InitErgmTerm.gwodegreeL'></span>

<h3>Description</h3>

<p>This term adds one network statistic to the model
equal to the weighted out-degree distribution with decay parameter . This
term can only be used with directed networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: gwodegreeL(decay, fixed=FALSE, attrname=NULL, cutoff=30, levels=NULL, Ls=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gwodegreeL-ergmTerm_+3A_decay">decay</code></td>
<td>
<p>non-negative model parameter that is the same as theta_s in
equation (14) in Hunter (2007).</p>
</td></tr>
<tr><td><code id="gwodegreeL-ergmTerm_+3A_fixed">fixed</code></td>
<td>
<p>specify if the value supplied for <code>decay</code> may be fixed (if <code>fixed=TRUE</code> ),
or it may be used as merely the starting value for the estimation
in a curved exponential family model (the default).</p>
</td></tr>
<tr><td><code id="gwodegreeL-ergmTerm_+3A_attrname">attrname</code></td>
<td>
<p>if specified, then separate degree
statistics are calculated for nodes having each separate
value of the attribute.</p>
</td></tr>
<tr><td><code id="gwodegreeL-ergmTerm_+3A_cutoff">cutoff</code></td>
<td>
<p>only relevant if <code>fixed=FALSE</code> . In that case it only uses this
number of terms in computing the statistics to reduce the computational
burden. Its default value can also be controlled by the <code>gw.cutoff</code> term option control parameter. (See <code><a href="ergm.html#topic+control.ergm">control.ergm</a></code> .)</p>
</td></tr>
<tr><td><code id="gwodegreeL-ergmTerm_+3A_levels">levels</code></td>
<td>
<p>a list of layer specifications. If given, degree of a node
<code>i</code> is considered to be the number of edges in all layers,
combined.</p>
</td></tr>
<tr><td><code id="gwodegreeL-ergmTerm_+3A_ls">Ls</code></td>
<td>
<p>either a Layer Logic specification formula (c.f. Layer Logic section in the <code><a href="#topic+Layer">Layer()</a></code> documentation) or a list thereof (constructed by <code><a href="base.html#topic+list">list()</a></code> or <code><a href="base.html#topic+c">c()</a></code>).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="ergm.html#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>curved, directed, binary</p>


<hr>
<h2 id='idegreeL-ergmTerm'>In-degree</h2><span id='topic+idegreeL-ergmTerm'></span><span id='topic+InitErgmTerm.idegreeL'></span>

<h3>Description</h3>

<p>This term adds one network statistic to
the model for each element in <code>d</code> ; the <code class="reqn">i</code> th such statistic equals
the number of nodes in the network of in-degree <code>d[i]</code> , i.e. the number
of nodes with exactly <code>d[i]</code> in-edges.
This term can only be used with directed networks; for undirected networks
see <code>degree</code> .
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: idegreeL(d, by=NULL, homophily=FALSE, levels=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="idegreeL-ergmTerm_+3A_d">d</code></td>
<td>
<p>a vector of distinct integers.</p>
</td></tr>
<tr><td><code id="idegreeL-ergmTerm_+3A_by">by</code></td>
<td>
<p>an optional character string giving the name of an attribute in the
network's vertex attribute list.</p>
</td></tr>
<tr><td><code id="idegreeL-ergmTerm_+3A_homophily">homophily</code></td>
<td>
<p>only applied if by is specified. If set (<code>homophile == TRUE</code>),
then degrees are calculated using the subnetwork consisting of only
edges whose endpoints have the same value of the <code>by</code> attribute.
Otherwise (the default), then separate degree
statistics are calculated for nodes having each separate
value of the attribute.</p>
</td></tr>
<tr><td><code id="idegreeL-ergmTerm_+3A_levels">levels</code></td>
<td>
<p>if <code>by</code> is specified, which levels to consider.</p>
</td></tr>
<tr><td><code id="idegreeL-ergmTerm_+3A_ls">Ls</code></td>
<td>
<p>either a Layer Logic specification formula (c.f. Layer Logic section in the <code><a href="#topic+Layer">Layer()</a></code> documentation) or a list thereof (constructed by <code><a href="base.html#topic+list">list()</a></code> or <code><a href="base.html#topic+c">c()</a></code>). If given, degree of a node</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="ergm.html#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>categorical nodal attribute, directed, frequently-used, binary</p>


<hr>
<h2 id='L-ergmTerm'>Evaluation on layers</h2><span id='topic+L-ergmTerm'></span><span id='topic+InitErgmTerm.L'></span>

<h3>Description</h3>

<p>Evaluates the terms in <code>formula</code> on an observed or
logical layers specified in formula <code>Ls</code> and sums the results
elementwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: L(formula, Ls=~.)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="L-ergmTerm_+3A_formula">formula</code></td>
<td>
<p>a one-sided <code><a href="ergm.html#topic+ergm">ergm()</a></code>-style formula with the terms to be evaluated</p>
</td></tr>
<tr><td><code id="L-ergmTerm_+3A_ls">Ls</code></td>
<td>
<p>either a Layer Logic specification formula (c.f. Layer Logic section in the <code><a href="#topic+Layer">Layer()</a></code> documentation) or a list thereof (constructed by <code><a href="base.html#topic+list">list()</a></code> or <code><a href="base.html#topic+c">c()</a></code>), on which to evaluate <code>formula</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="ergm.html#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>layer-aware, operator, binary</p>


<hr>
<h2 id='Layer'>A multilayer network representation.</h2><span id='topic+Layer'></span>

<h3>Description</h3>

<p>A function for specifying the LHS of a multilayer
(a.k.a. multiplex, a.k.a. multirelational, a.k.a. multivariate)
ERGM in the framework of Krivitsky et al. (2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Layer(..., .symmetric = NULL, .bipartite = NULL, .active = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Layer_+3A_...">...</code></td>
<td>
<p>layer specification, in one of three formats:
</p>

<ol>
<li><p> An (optionally named) list of identically-dimensioned
networks.
</p>
</li>
<li><p> Several networks as (optionally named) arguments.
</p>
</li>
<li><p> A single network, a character vector, and several optional
arguments. Then, the layers are values of the named edge
attributes. If the vector has named elements (e.g.,
<code>c(a="advice", c="collaboration")</code>), the layers will be
renamed accordingly. The optional arguments <code>.symmetric</code> and
<code>.bipartite</code> are then interpreted as described below.
</p>
</li></ol>
</td></tr>
<tr><td><code id="Layer_+3A_.symmetric">.symmetric</code></td>
<td>
<p>If the layer specification is via a single
network with edge attributes and the network is directed, an
optional logical vector to specify which of the layers should be
treated as undirected.</p>
</td></tr>
<tr><td><code id="Layer_+3A_.bipartite">.bipartite</code></td>
<td>
<p>If the layer specification is via a single
network with edge attributes and the network is unipartite, an
optional integer vector to specify which of the layers should be
treated as bipartite and how many <code>b1</code> vertices there are.</p>
</td></tr>
<tr><td><code id="Layer_+3A_.active">.active</code></td>
<td>
<p>A <a href="ergm.html#topic+nodal_attributes">nodal attribute specification</a>
(<code>? nodal_attributes</code>) specifying which nodes on each network
<em>may</em> have ties, or a list with an element for each network. The
list will be recycled up to the number of layers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A network object with layer metadata.
</p>


<h3>Specifying models for multilayer network</h3>

<p>In order to fit a model for multilayer
networks, first use <code><a href="#topic+Layer">Layer</a></code> construct an LHS network that
<code><a href="ergm.html#topic+ergm">ergm()</a></code> will understand as multilayered.
</p>
<p>Used in the formula directly, most, but not all, <span class="pkg">ergm</span> terms will
sum their statistics over the observed layers.
</p>
<p>Some terms are <em>layer-aware</em>, however. By convention, layer-aware
terms have capital <code>L</code> appended to them. For example,
<code><a href="#topic+mutualL-ergmTerm">mutualL</a></code> is a layer-aware generalization of
<code><a href="ergm.html#topic+mutual-ergmTerm">mutual</a></code>. These terms have one or more explicit
(usually optional) layer specification arguments. By convention, an
argument that requires one layer specification is named <code>L=</code> and
one that requires a list of specifications (constructed by <code><a href="base.html#topic+list">list()</a></code>
or <code><a href="base.html#topic+c">c()</a></code>) is named <code>Ls=</code>; and a specification of the form <code>~.</code> is a
placeholder for all observed layers.
</p>
<p>Operator <code><a href="#topic+L-ergmTerm">L(formula, Ls=...)</a></code> can be used to evaluate
arbitrary terms in the <code>formula</code> on specified layers.
</p>
<p>Layer specification documentation follows.
</p>


<h4>Layer Logic</h4>

<p>Each formula's right-hand side describes an observed layer <em>or</em> some
&quot;logical&quot; layer, whose ties are a function of corresponding ties in
observed layers. (Krivitsky et al. 2020)
</p>
<p>The observed layers can be referenced either by name or by number (i.e.,
order in which they were passed to <code><a href="#topic+Layer">Layer</a></code>). When referencing by
number, enclose the number in quotation marks (e.g., &quot;1&quot;) or
backticks (e.g., &ldquo;<code>1</code>&rdquo;).
</p>
<p><a href="base.html#topic+Arithmetic">Arithmetical</a>, <a href="base.html#topic+Comparison">relational</a>,
and <a href="base.html#topic+Logic">logical</a> operators can be used to combine them. All
listed operators are implemented, as well as functions <code><a href="base.html#topic+abs">abs</a></code>,
<code><a href="base.html#topic+round">round</a></code>, and <code><a href="base.html#topic+sign">sign</a></code>. Standard
<a href="base.html#topic+Syntax">operator precedence</a> applies, so use of parentheses is
recommended to ensure the logical expression is what it looks like.
</p>
<p><strong>Important:</strong> For performance reasons, <span class="pkg">ergm.multi</span>'s
Layer Logic implementation uses integer arithmetic. This means, in
particular, that <code>/</code> will round down instead of returning a
fraction (as <code>%/%</code> does in <span class="rlang"><b>R</b></span>), and <code><a href="base.html#topic+round">round()</a></code> function without a
second argument (which can be negative to round to the nearest 10,
100, etc.) is not meaningful and will be ignored.
</p>
<p>For example, if LHS is <code>Layer(A=nwA, B=nwB)</code>, both <code>~`2`</code> and
<code>~B</code> refer to <code>nwB</code>, while <code>A&amp;!B</code> refers to a
&ldquo;logical&rdquo; layer that has ties that are in <code>nwA</code> but not in
<code>nwB</code>.
</p>
<p>Transpose function <code><a href="base.html#topic+t">t</a></code> applied to a directed layer will reverse
the direction of all relations (transposing the sociomatrix). Unlike the
others, it can only be used on an observed layer directly. For example,
<code>~t(`1`)&amp;t(`2`)</code> is valid but <code>~t(`1`&amp;`2`)</code> is not.
</p>
<p>At this time, logical expressions that produce complete graphs from empty
graph inputs (e.g., <code>A==B</code> or <code>!A</code>) are not supported.
</p>



<h4>Summing layers</h4>

<p>Some of the terms that call for a list of layers (i.e., have <code>Ls=</code>
arguments) will sum the statistic over the layers. For example,
<code>Layer(nw1,nw2)~L(~edges, c(~`1`,~(`2`&amp;!`1`)))</code> produces the
number of edges in layer 1 plus the number of edges in layer 2 but
not in layer 1.
</p>
<p>For these formulas, one can specify the layer's weight on its left-handside.
For example, <code>Layer(nw1,nw2)~L(~edges, c(3~`1`,-1~(`2`&amp;!`1`)))</code> will
produce three times the number of edges in layer 1, minus the number of
edges in layer 2 but not in layer 1.
</p>



<h3>Note</h3>

<p>The resulting network will be the &quot;least common denominator&quot;
network: if not all layers have the same bipartedness, all layers
will appear as unipartite to the statistics, and if any are
directed, all will be. However, <a href="ergm.html#topic+ergmTerm">certain operator terms</a>, particularly <code>Symmetrize()</code> and <code>S()</code>, can be
used to construct a bipartite subgraph of a unipartite graph or
change directedness.
</p>


<h3>References</h3>

<p>Krivitsky PN, Koehly LM, Marcum CS (2020).
&ldquo;Exponential-family Random Graph Models for Multi-layer Networks.&rdquo;
<em>Psychometrika</em>, <b>85</b>(3), 630&ndash;659.
<a href="https://doi.org/10.1007/s11336-020-09720-7">doi:10.1007/s11336-020-09720-7</a>.
</p>


<h3>See Also</h3>

<p><a href="ergm.html#topic+ergmTerm">Help on model specification</a> for specific terms.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(florentine)

# Method 1: list of networks
flo &lt;- Layer(list(m = flomarriage, b = flobusiness))
ergm(flo ~ L(~edges, ~m)+L(~edges, ~b))

# Method 2: networks as arguments
flo &lt;- Layer(m = flomarriage, b = flobusiness)
ergm(flo ~ L(~edges, ~m)+L(~edges, ~b))

# Method 3: edge attributes (also illustrating renaming):
flo &lt;- flomarriage | flobusiness
flo[,, names.eval="marriage"] &lt;- as.matrix(flomarriage)
flo[,, names.eval="business"] &lt;- as.matrix(flobusiness)
flo # edge attributes
flo &lt;- Layer(flo, c(m="marriage", b="business"))
ergm(flo ~ L(~edges, ~m)+L(~edges, ~b))

### Specifying modes and mixed bipartitedness

# Suppose we have a two-mode network with 5 nodes on Mode 1 and 15
# on Mode 2, and suppose that we observe two layers, one only among
# actors of Mode 1 and the other bipartite between Modes 1 and 2.

# Construct the two layers' networks:
nw1 &lt;- network.initialize(20, dir=FALSE)
nw12 &lt;- network.initialize(20, dir=FALSE, bipartite=5)
nw1 %v% "mode" &lt;- rep(1:2,c(5,15))

# For testing: the maximal set of edges for each type of network:
nw1[1:5,1:5] &lt;- 1
nw12[1:5,6:20] &lt;- 1

# The .active argument specifies the following:
# * nw1's vertices are only active if their mode=1 (i.e., 1-2, 2-1,
#   and 2-2 can't have edges).
# * nw12's vertices are all active, but the network is bipartite,
#   so constraints will be adjusted automatically.
lnw &lt;- Layer(nw1, nw12, .active=list(~mode==1, ~TRUE))

summary(lnw~
edges+ # 5*4/2+5*15 = 10+75 = 85
L(~edges,~`1`)+ # 5*4/2 = 10
L(~edges,~`2`)+ # 5*15 = 75
L(~edges,~(`1`|`2`))+ # This logical layer has contents of both, so also 85.
L(~edges,~(`1`&amp;`2`)) # There is no overlap between the two layers, so 0.
)

# Layer-aware terms can be used:

nw1[,] &lt;-0
nw1[1,2:3] &lt;- 1
nw1[2,3] &lt;- 1
nw12[,] &lt;- 0
nw12[1,6:7] &lt;- 1
nw12[2,6:7] &lt;- 1

lnw &lt;- Layer(nw1, nw12, .active=list(~mode==1,~TRUE))

summary(lnw~L(~triangles, ~`1`)+ # 1-2-3 triangle.
  L(~triangles, ~`1`|`2`)+ # 1-2-3, 1-2-6, 1-2-7 triangles
  dgwespL(L.base=~`1`, Ls.path=list(~`2`,~`2`)) # 1-2-6 and 1-2-7 only
)

# Because the layers are represented as a block-diagonal matrix,
# this will only count triangles entirely contained within a single
# layer, i.e., 1-2-3:
summary(lnw~triangles)

# If you need to evaluate bipartite-only statistics on the second
# layer, you need to use the S() operator to select the bipartite
# view:
summary(lnw~L(~S(~b1degree(1:3)+b2degree(1:3),1:5~6:20), ~`2`))

</code></pre>

<hr>
<h2 id='Lazega'>A network of advice, collaboration, and friendship in a law firm</h2><span id='topic+Lazega'></span>

<h3>Description</h3>

<p>This dataset contains a <code><a href="network.html#topic+network">network</a></code> of relations of various types
among 71 lawyers (partners and associates) in a New England
(Northeastern US) corporate law firm referred to as &ldquo;SG&amp;R&rdquo;
collected 1988&ndash;1991 by Lazega (2001).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Lazega)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>network</code> of length 5.
</p>


<h3>Details</h3>

<p>All relations are directed.
</p>


<h3>Nonstandard Vertex Attributes</h3>


<dl>
<dt><code>age</code></dt><dd><p>(numeric) the lawyer's age.</p>
</dd>
<dt><code>gender</code></dt><dd><p>(character) the lawyer's gender (<code>"man"</code>/<code>"woman"</code>).</p>
</dd>
<dt><code>office</code></dt><dd><p>(character) in which of the firm's three offices the lawyer is based (<code>"Boston"</code>/<code>"Hartford"</code>/<code>"Providence"</code>).</p>
</dd>
<dt><code>practice</code></dt><dd><p>(character) which area of law the lawyer practices (<code>"corporate"</code>/<code>"litigation"</code>).</p>
</dd>
<dt><code>school</code></dt><dd><p>(character) from which law school the lawyer graduated (<code>"Harvard/Yale"</code>/<code>"UConnecticut"</code>/<code>"other"</code>).</p>
</dd>
<dt><code>seniority</code></dt><dd><p>(numeric) the lawyer's seniority rank in the firm (1 = high).</p>
</dd>
<dt><code>status</code></dt><dd><p>(character) the lawyer's status in the firm (<code>"associate"</code>/<code>"partner"</code>).</p>
</dd>
<dt><code>yrs_frm</code></dt><dd><p>(numeric) the number of years the lawyer has been with the firm.</p>
</dd>
</dl>



<h3>Nonstandard Edge Attributes</h3>

<p>Each directed edge
<code class="reqn">i\rightarrow j</code> has the following attributes:
</p>

<dl>
<dt><code>advice</code></dt><dd><p>(logical) whether <code class="reqn">i</code> has reported receiving advice from <code class="reqn">j</code>. (Note that as defined, advice flows from head of the directed edge to the tail.)</p>
</dd>
<dt><code>coworker</code></dt><dd><p>(logical) whether <code class="reqn">i</code> has reported receiving <code class="reqn">j</code>'s assistance in preparing documents. (Note that as defined, assistance flows from head of the directed edge to the tail.)</p>
</dd>
<dt><code>friendship</code></dt><dd><p>(logical) whether <code class="reqn">i</code> considers <code class="reqn">j</code> a friend outside of work.</p>
</dd>
</dl>



<h3>Licenses and Citation</h3>

<p>When publishing results obtained
using this data set, the original author
(Lazega 2001) should be cited, along with this
<span class="rlang"><b>R</b></span> package.
</p>


<h3>Source</h3>

<p>This version of the dataset was retrieved from the <a href="https://www.stats.ox.ac.uk/~snijders/siena/Lazega_lawyers_data.htm">RSiena web site</a>
and was compiled by Christopher Steven Marcum and Pavel
N. Krivitsky for Krivitsky et al. (2020).
</p>


<h3>References</h3>

<p>Krivitsky PN, Koehly LM, Marcum CS (2020).
&ldquo;Exponential-family Random Graph Models for Multi-layer Networks.&rdquo;
<em>Psychometrika</em>, <b>85</b>(3), 630&ndash;659.
<a href="https://doi.org/10.1007/s11336-020-09720-7">doi:10.1007/s11336-020-09720-7</a>.<br /><br /> Lazega E (2001).
<em>The Collegial Phenomenon: The Social Mechanisms of Cooperation among Peers in a Corporate Law Partnership</em>.
Oxford University Press.
ISBN 9780199242726.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Lazega)
# Construct a multilayer network for ergm(). (See `?Layer` for syntax.)
LLazega &lt;- Layer(Lazega, c("advice", "coworker", "friendship"))
# Specify a layer logic model.
efit &lt;- ergm(LLazega ~ L(~edges + mutual, ~advice) +
                       L(~edges + mutual, ~coworker) +
                       L(~edges + mutual, ~friendship) +
                       L(~edges + mutual, ~advice&amp;coworker) +
                       L(~edges + mutual, ~advice&amp;friendship) +
                       L(~edges + mutual, ~coworker&amp;friendship))
summary(efit)

</code></pre>

<hr>
<h2 id='lm.gofN'>Fit a linear model to the residuals in a gofN object.</h2><span id='topic+lm.gofN'></span>

<h3>Description</h3>

<p>This non-method runs a properly weighted linear model on the raw
residuals of a <code><a href="#topic+gofN">gofN</a></code> simulation for a multi-network ERGM fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lm.gofN(formula, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lm.gofN_+3A_formula">formula</code></td>
<td>
<p>an <code><a href="stats.html#topic+lm">lm</a></code>-style formula. See Details for
interpretation.</p>
</td></tr>
<tr><td><code id="lm.gofN_+3A_data">data</code></td>
<td>
<p>a <code><a href="#topic+gofN">gofN</a></code> object.</p>
</td></tr>
<tr><td><code id="lm.gofN_+3A_...">...</code></td>
<td>
<p>additional arguments to <code><a href="stats.html#topic+lm">lm()</a></code>, excluding <code>weights</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>formula</code>'s RHS is evaluated in an environment
comprising the network statistics used in the <code><a href="#topic+gofN">gofN()</a></code> call
(which refer to the raw residuals for the corresponding
statistic) and the network attributes.
</p>
<p>The LHS is handled in a nonstandard manner, designed to make it
easier to reference the usually lengthy network statistics:
first, it is evaluated in the formula's environment. If the
evaluation is successful and the result is numeric, these numbers
are used as indices of the statistics in the <code><a href="#topic+gofN">gofN</a></code> object to
use on the RHS. If it is a character vector, it is treated as
names of these statistics.
</p>


<h3>Value</h3>

<p>A list of <code><a href="stats.html#topic+lm">lm</a></code> objects, one for each element of the
vector on the LHS.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gofN">gofN()</a></code> and related methods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(samplk)
# Add time indices:
samplk1 %n% "t" &lt;- 1
samplk2 %n% "t" &lt;- 2
samplk3 %n% "t" &lt;- 3

monks &lt;- Networks(samplk1, samplk2, samplk3)

fit &lt;- ergm(monks~N(~edges+nodematch("group")))
fit.gof &lt;- gofN(fit) # GOF = original model

# Is there a time effect we should incorporate?
fit.gof.lm &lt;- lm.gofN((1:2)~t, data=fit.gof)

lapply(fit.gof.lm, summary)

</code></pre>

<hr>
<h2 id='marg_cond_sim'>Calculate gofN()-style Pearson residuals for arbitrary statistics</h2><span id='topic+marg_cond_sim'></span>

<h3>Description</h3>

<p>This function is to be considered experimental. Do NOT rely on
it. It may, eventually, be moved to <code>ergm</code>, perhaps integrated into
the <code>simulate</code> methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marg_cond_sim(
  object,
  nsim = 1,
  obs.twostage = nsim/2,
  GOF = NULL,
  control = control.gofN.ergm(),
  save_stats = FALSE,
  negative_info = c("error", "warning", "message", "ignore"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marg_cond_sim_+3A_object">object</code></td>
<td>
<p>an <code><a href="ergm.html#topic+ergm">ergm</a></code> object.</p>
</td></tr>
<tr><td><code id="marg_cond_sim_+3A_nsim">nsim</code></td>
<td>
<p>number of realizations.</p>
</td></tr>
<tr><td><code id="marg_cond_sim_+3A_obs.twostage">obs.twostage</code>, <code id="marg_cond_sim_+3A_gof">GOF</code>, <code id="marg_cond_sim_+3A_save_stats">save_stats</code></td>
<td>
<p>see <code><a href="#topic+gofN">gofN()</a></code>.</p>
</td></tr>
<tr><td><code id="marg_cond_sim_+3A_control">control</code></td>
<td>
<p>a control list returned by <code><a href="#topic+control.gofN.ergm">control.gofN.ergm()</a></code>; note that <code>nsim</code> and <code>obs.twostage</code> parameters in the control list are ignored in favor of those passed to the function directly.</p>
</td></tr>
<tr><td><code id="marg_cond_sim_+3A_negative_info">negative_info</code></td>
<td>
<p>how to handle the situation in which the constrained variance exceeds the unconstrained: the corresponding action will be taken.</p>
</td></tr>
<tr><td><code id="marg_cond_sim_+3A_...">...</code></td>
<td>
<p>additional arguments to <code><a href="ergm.html#topic+ergm_model">ergm_model()</a></code>, <code><a href="ergm.html#topic+simulate.ergm">simulate.ergm()</a></code>, and <code><a href="ergm.html#topic+summary.ergm_model">summary.ergm_model()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of similar structure as that returned by <code><a href="#topic+gofN">gofN()</a></code>.
</p>

<hr>
<h2 id='mutualL-ergmTerm'>Mutuality</h2><span id='topic+mutualL-ergmTerm'></span><span id='topic+InitErgmTerm.mutualL'></span>

<h3>Description</h3>

<p>In binary ERGMs, equal to the number of
pairs of actors <code class="reqn">i</code> and <code class="reqn">j</code> for which <code class="reqn">(i{\rightarrow}j)</code>
and <code class="reqn">(j{\rightarrow}i)</code> both exist.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: mutualL(same=NULL, diff=FALSE, by=NULL, keep=NULL, Ls=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutualL-ergmTerm_+3A_same">same</code></td>
<td>
<p>optional argument. If passed the name of a vertex attribute,
only mutual pairs that match on the attribute are counted. Only one of <code>same</code>
or <code>by</code> may be used. If both parameters are passed, <code>same</code> takes precedent. This
parameter is affected by <code>diff</code>.</p>
</td></tr>
<tr><td><code id="mutualL-ergmTerm_+3A_diff">diff</code></td>
<td>
<p>separate counts for each unique matching value can be obtained by using
<code>diff=TRUE</code> with <code>same</code>.</p>
</td></tr>
<tr><td><code id="mutualL-ergmTerm_+3A_by">by</code></td>
<td>
<p>each node is counted separately for each mutual pair in which it
occurs and the counts are tabulated by unique values of the attribute if
passed the name of a vertex attribute. This means that the sum of the mutual statistics when <code>by</code> is used
will equal twice the standard mutual statistic. Only one of <code>same</code>
or <code>by</code> may be used. If both parameters are passed, <code>same</code> takes precedent. This
parameter is not affected by <code>diff</code>.</p>
</td></tr>
<tr><td><code id="mutualL-ergmTerm_+3A_keep">keep</code></td>
<td>
<p>a numerical vector to specify which statistics should be kept whenever the <code>mutual</code> term would
ordinarily result in multiple statistics.</p>
</td></tr>
<tr><td><code id="mutualL-ergmTerm_+3A_ls">Ls</code></td>
<td>
<p>a list (constructed by <code><a href="base.html#topic+list">list()</a></code> or <code><a href="base.html#topic+c">c()</a></code> of one or two Layer Logic specifications (c.f. Layer Logic section in the <code><a href="#topic+Layer">Layer()</a></code> documentation). If given, the statistic will count the number of dyads where a tie in <code>Ls[[1]]</code> reciprocates a tie in <code>Ls[[2]]</code> and vice versa. (Note that dyad that has mutual ties in <code>Ls[[1]]</code> and in <code>Ls[[2]]</code> will add 2 to this statistic.) If a formula is given, it is replicated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This term can only be used with directed networks.
</p>


<h3>See Also</h3>

<p><code><a href="ergm.html#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, frequently-used, layer-aware, binary</p>


<hr>
<h2 id='N-ergmTerm'>Evaluation on multiple networks</h2><span id='topic+N-ergmTerm'></span><span id='topic+InitErgmTerm.N'></span><span id='topic+InitWtErgmTerm.N'></span>

<h3>Description</h3>

<p>Evaluates the terms in <code>formula</code> on each of the networks joined
using <code><a href="#topic+Networks">Networks</a></code> function, and returns either a weighted
sum or an <code><a href="stats.html#topic+lm">lm</a></code>-style linear model for the ERGM
coefficients (Krivitsky et al. 2023). Its syntax follows that of <code><a href="stats.html#topic+lm">lm</a></code> closely,
with sensible defaults.
</p>
<p>The default formula (<code>~1</code>) sums the specified network
statistics. If <code>lm</code> refers to any network attributes for which some
networks have missing values, the term will stop with an
error. This can be avoided by pre-filtering with <code>subset</code>, which
controls which networks are affected by the term.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: N(formula, lm=~1, subset=TRUE, weights=1, contrasts=NULL, offset=0, label=NULL,
#           .NetworkID=".NetworkID", .NetworkName=".NetworkName")

# valued: N(formula, lm=~1, subset=TRUE, weights=1, contrasts=NULL, offset=0, label=NULL,
#           .NetworkID=".NetworkID", .NetworkName=".NetworkName")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="N-ergmTerm_+3A_.networkid">.NetworkID</code>, <code id="N-ergmTerm_+3A_.networkname">.NetworkName</code></td>
<td>
<p>Optional strings indicating the
vertex attributes used to distinguish and name the networks;
intended to be used by term developers.</p>
</td></tr>
<tr><td><code id="N-ergmTerm_+3A_formula">formula</code></td>
<td>
<p>a one-sided <code><a href="ergm.html#topic+ergm">ergm()</a></code>-style formula with the terms to be evaluated</p>
</td></tr>
<tr><td><code id="N-ergmTerm_+3A_lm">lm</code></td>
<td>
<p>a one-sided <code><a href="stats.html#topic+lm">lm()</a></code>-style formula whose RHS specifies the network-level predictors for the terms in the <code><a href="ergm.html#topic+ergm">ergm()</a></code> formula <code>formula</code>.</p>
</td></tr>
<tr><td><code id="N-ergmTerm_+3A_subset">subset</code>, <code id="N-ergmTerm_+3A_contrasts">contrasts</code></td>
<td>
<p>see <code><a href="stats.html#topic+lm">lm()</a></code>.</p>
</td></tr>
<tr><td><code id="N-ergmTerm_+3A_offset">offset</code></td>
<td>
<p>A constant, a vector of length equal to the number of networks, or a matrix whose number of rows is the number of networks and whose number of columns is the number of free parameters of the ERGM. It can be specified in <code>lm</code> as well.</p>
</td></tr>
<tr><td><code id="N-ergmTerm_+3A_weights">weights</code></td>
<td>
<p>reserved for future use; attempting to change it will cause an
error: at this time, there is no way to assign sampling weights to
networks.</p>
</td></tr>
<tr><td><code id="N-ergmTerm_+3A_label">label</code></td>
<td>
<p>An optional parameter which will add a label to model
parameters to help identify the term (which may have similar
predictors but, say, a different network subset) in the output
<em>or</em> a function that wraps the names.</p>
</td></tr>
</table>


<h3>Offsets and fixing parameters</h3>

<p>By default, an <code>N(formula, lm)</code> term will add <code class="reqn">p \times q</code> free
parameters, where <code class="reqn">p</code> is the number of free parameters
(possibly curved) of the ERGM specified by <code>formula</code>, and <code class="reqn">q</code>
is the number of parameters specified by the <code>lm</code> formula. That is,
there would be one parameter for each combination of an ERGM
parameter and a linear model parameter, in an ERGM-major order
(i.e., for each ERGM parameter, the linear model parameters will be
enumerated). For example, the term <code>gwesp()</code> has two free
parameters: its coefficient and its decay rate. We can specify a
model in which they depend on <code class="reqn">\log(n)</code> as <code>N(~gwesp, ~log(n))</code>, resulting in the following 4 parameters, with the
intercept for the linear model being implicit:
</p>
<div class="sourceCode"><pre>#&gt; [1] "N(1)~gwesp"            "N(log(n))~gwesp"       "N(1)~gwesp.decay"     
#&gt; [4] "N(log(n))~gwesp.decay"
</pre></div>
<p>If a different linear model is desired for different ERGM terms
(e.g., some are to be affected by network size while others are
not), multiple <code>N()</code> terms can be specified. This covers most such
cases, but not all. For example, suppose that for the above model,
we wish for its coefficient to depend on <code>log(n)</code> but for the decay
parameter not to. In this case, one can use the <code>offset()</code>
decorator with partial offsetting. Then, specifying
<code>offset(N(~gwesp(), ~log(n)), 4)</code>, we get:
</p>
<div class="sourceCode"><pre>#&gt; [1] "N(1)~gwesp"                    "N(log(n))~gwesp"              
#&gt; [3] "N(1)~gwesp.decay"              "offset(N(log(n))~gwesp.decay)"
</pre></div>
<p>Then, setting the corresponding <code>offset.coef = 0</code> will fix the
coefficient of <code>log(n)</code> for the decay parameter at 0, while
allowing a constant decay parameter to be estimated.
</p>


<h3>Note</h3>

<p>Care should be taken to avoid multicollinearity when using
this operator. As with the <code><a href="stats.html#topic+lm">lm()</a></code> function, <code>lm</code> formulas have an
implicit intercept, which can be suppressed by specifying <code>~ 0 + ...</code> or <code>~ -1 + ...</code> on the formula. When <code>lm</code> is given a model
with intercept and a categorical predictor (including a
<code><a href="base.html#topic+logical">logical</a></code> one), it will use the first level (or <code>FALSE</code>) as the
baseline, but if the model is without intercept, it will use all
levels of the first categorical predictor. This is typically what
is wanted in a linear regression, but for the <code>N</code> operator, this
can be problematic if the &quot;intercept&quot; effect is added by a
different term. A workaround is to convert the categorical
predictor to dummy variables before putting it into the <code>lm</code>
formula.
</p>


<h3>References</h3>

<p>Krivitsky PN, Coletti P, Hens N (2023).
&ldquo;A Tale of Two Datasets: Representativeness and Generalisability of Inference for Samples of Networks.&rdquo;
<em>Journal of the American Statistical Association</em>, <b>118</b>(544), 2213-2224.
<a href="https://doi.org/10.1080/01621459.2023.2242627">doi:10.1080/01621459.2023.2242627</a>.
</p>


<h3>See Also</h3>

<p><code><a href="ergm.html#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, operator, undirected, binary, valued</p>

<p><code>vignette("Goeyvaerts_reproduction")</code> for a demonstration.
</p>

<hr>
<h2 id='network_view'>Construct a &quot;view&quot; of a network.</h2><span id='topic+network_view'></span>

<h3>Description</h3>

<p>Returns a network with edges optionally filtered according to a
specified criterion and with edge attributes optionally computed
from other edge attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>network_view(x, ..., .clear = FALSE, .sep = ".")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network_view_+3A_x">x</code></td>
<td>
<p>a <code><a href="network.html#topic+network">network</a></code> object.</p>
</td></tr>
<tr><td><code id="network_view_+3A_...">...</code></td>
<td>
<p>a list of attribute or filtering specifications. See
Details.</p>
</td></tr>
<tr><td><code id="network_view_+3A_.clear">.clear</code></td>
<td>
<p>whether the edge attributes not set by this call
should be deleted.</p>
</td></tr>
<tr><td><code id="network_view_+3A_.sep">.sep</code></td>
<td>
<p>when specifying via a character vector, use this as the
separator for concatenating edge values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Attribute specification arguments have the form
<code style="white-space: pre;">&#8288;&lt;newattrname&gt; = &lt;expr&gt;&#8288;</code>, where <code style="white-space: pre;">&#8288;&lt;newattrname&gt;&#8288;</code> specifies the
name of the new edge attribute (or attribute to be overwritten)
and <code style="white-space: pre;">&#8288;&lt;expr&gt;&#8288;</code> can be one of the following:
</p>

<dl>
<dt>a function</dt><dd><p>The function will be passed two arguments, the
edgelist <code><a href="tibble.html#topic+tibble">tibble</a></code> and the network, and must return a vector of
edge attribute values to be set on the edges in the order
specified.</p>
</dd>
<dt>a formula</dt><dd><p>The expression on the RHS of the formula will be
evaluated with names in it referencing the edge attributes. The
input network may be referenced as <code>.nw</code>. The expression's result
is expected to be a vector of edge attribute values to be set on
the edges in the order specified.</p>
</dd>
<dt>a character vector</dt><dd><p>If of length one, the edge attribute with
that name will simply be copied; if greater than one, the attribute
values will be concatenated wtih the <code>.sep</code> argument as the
separator.</p>
</dd>
<dt>an object enclosed in <code><a href="base.html#topic+I">I()</a></code></dt><dd><p>The object will be used directly
to set the edge attribute.</p>
</dd>
</dl>

<p>Filtering arguments are specified the same way as attribute
arguments, but they must be unnamed arguments (i.e., must be passed
without the <code>=</code>) and must return a logical or numeric vector
suitable for indexing the edge list. Multiple filtering arguments
may be specified, and the edge will be kept if it satisfies
<em>all</em>. If the conjunction of the edge's original states and the
filtering results is ambiguous (i.e., <code>NA</code>), it will be set as
missing.
</p>


<h3>Value</h3>

<p>A <code><a href="network.html#topic+network">network</a></code> object with modified edges and edge attributes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(florentine)
flo &lt;- flomarriage
flo[,,add.edges=TRUE] &lt;- as.matrix(flomarriage) | as.matrix(flobusiness)
flo[,, names.eval="m"] &lt;- as.matrix(flomarriage)==1
flobusiness[3,5] &lt;- NA
flo[,, names.eval="b"] &lt;- as.matrix(flobusiness)==1
flo
(flob &lt;- network_view(flo, "b"))
(flobusiness) # for comparison


(flob &lt;- network_view(flo, ~b&amp;m))
(flobusiness &amp; flomarriage) # for comparison


as.matrix(flob &lt;- network_view(flo, bm=~b+m), attrname="bm")
(as.matrix(flobusiness) + as.matrix(flomarriage)) # for comparison


as.matrix(flob &lt;- network_view(flo, ~b, bm=~b+m), attrname="bm")
as.matrix(flobusiness)*(1+as.matrix(flomarriage)) # for comparison



</code></pre>

<hr>
<h2 id='Networks'>A multinetwork network representation.</h2><span id='topic+Networks'></span>

<h3>Description</h3>

<p>A function for specifying the LHS of a multi-network
(a.k.a. multilevel) ERGM. Typically used in conjunction with the
<code><a href="#topic+N-ergmTerm">N()</a></code> term operator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Networks(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Networks_+3A_...">...</code></td>
<td>
<p>network specification, in one of two formats:
</p>

<ol>
<li><p> An (optionally named) list of networks with same directedness and bipartedness (but possibly different sizes).
</p>
</li>
<li><p> Several networks as (optionally named) arguments.
</p>
</li></ol>
</td></tr>
</table>


<h3>Value</h3>

<p>A network object with multinetwork metadata.
</p>


<h3>See Also</h3>

<p><a href="ergm.html#topic+ergmTerm">Help on model specification</a> for specific terms
</p>
<p><code>vignette("Goeyvaerts_reproduction")</code> for a demonstration
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(samplk)

# Method 1: list of networks
monks &lt;- Networks(list(samplk1, samplk2))
ergm(monks ~ N(~edges))

# Method 2: networks as arguments
monks &lt;- Networks(samplk1, samplk2)
ergm(monks ~ N(~edges))

</code></pre>

<hr>
<h2 id='odegreeL-ergmTerm'>Out-degree</h2><span id='topic+odegreeL-ergmTerm'></span><span id='topic+InitErgmTerm.odegreeL'></span>

<h3>Description</h3>

<p>This term adds one network statistic to
the model for each element in <code>d</code> ; the <code class="reqn">i</code> th such statistic equals
the number of nodes in the network of out-degree <code>d[i]</code> , i.e. the
number of nodes with exactly <code>d[i]</code> out-edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: odegreeL(d, by=NULL, homophily=FALSE, levels=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="odegreeL-ergmTerm_+3A_d">d</code></td>
<td>
<p>a vector of distinct integers</p>
</td></tr>
<tr><td><code id="odegreeL-ergmTerm_+3A_by">by</code></td>
<td>
<p>a character string giving the name of an attribute in the
network's vertex attribute list.</p>
</td></tr>
<tr><td><code id="odegreeL-ergmTerm_+3A_homophily">homophily</code></td>
<td>
<p>If this is specified and <code>homophily</code> is <code>TRUE</code> ,
then degrees are calculated using the subnetwork consisting of only
edges whose endpoints have the same value of the <code>by</code> attribute.
If <code>by</code> is specified and
<code>homophily</code> is <code>FALSE</code> (the default), then separate degree
statistics are calculated for nodes having each separate
value of the attribute.</p>
</td></tr>
<tr><td><code id="odegreeL-ergmTerm_+3A_ls">Ls</code></td>
<td>
<p>either a Layer Logic specification formula (c.f. Layer Logic section in the <code><a href="#topic+Layer">Layer()</a></code> documentation) or a list thereof (constructed by <code><a href="base.html#topic+list">list()</a></code> or <code><a href="base.html#topic+c">c()</a></code>). If given, degree of a node</p>
</td></tr>
<tr><td><code id="odegreeL-ergmTerm_+3A_levels">levels</code></td>
<td>
<p>list of layer specifications</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This term can only be used with directed networks; for undirected networks
see <code>degree</code> .
</p>
<p>If a list of layer specifications is given, degree of a node
<code>i</code> is considered to be the number of edges in all layers,
combined.
</p>


<h3>See Also</h3>

<p><code><a href="ergm.html#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>categorical nodal attribute, directed, frequently-used, binary</p>


<hr>
<h2 id='plot.gofN'>Plotting methods for <code><a href="#topic+gofN">gofN</a></code>, making residual and scale-location plots.</h2><span id='topic+plot.gofN'></span><span id='topic+autoplot.gofN'></span>

<h3>Description</h3>

<p>The <code><a href="graphics.html#topic+plot">plot()</a></code> method uses <span class="rlang"><b>R</b></span> graphics.
</p>
<p>The <code><a href="ggplot2.html#topic+autoplot">ggplot2::autoplot()</a></code> method uses <a href="https://CRAN.R-project.org/package=ggplot2"><span class="pkg">ggplot2</span></a> and <a href="https://CRAN.R-project.org/package=ggrepel"><span class="pkg">ggrepel</span></a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gofN'
plot(
  x,
  against = NULL,
  which = 1:2,
  col = 1,
  pch = 1,
  cex = 1,
  bg = 0,
  ...,
  ask = length(which) &gt; 1 &amp;&amp; dev.interactive(TRUE),
  id.n = 3,
  id.label = NULL,
  main = "{type} for {sQuote(name)}",
  xlab = NULL,
  ylim = NULL,
  cex.id = 0.75
)

## S3 method for class 'gofN'
autoplot(
  x,
  against = .fitted,
  which = 1:2,
  mappings = list(),
  geom_args = list(),
  id.n = 3,
  id.label = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.gofN_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+gofN">gofN</a></code> object.</p>
</td></tr>
<tr><td><code id="plot.gofN_+3A_against">against</code></td>
<td>
<p>what the residuals should be plotted against. Note that different methods use different formats: see Details. Categorical (<code><a href="base.html#topic+factor">factor</a></code> and <code><a href="base.html#topic+ordered">ordered</a></code>) values are visualised using boxplots, with <code><a href="base.html#topic+ordered">ordered</a></code> values also adding a smoothing line like the quantitative. Defaults to the fitted values.</p>
</td></tr>
<tr><td><code id="plot.gofN_+3A_which">which</code></td>
<td>
<p>which to plot (<code>1</code> for residuals plot, <code>2</code> for <code class="reqn">\sqrt{|R_i|}</code> scale plot, and <code>3</code> for normal quantile-quantile plot).</p>
</td></tr>
<tr><td><code id="plot.gofN_+3A_col">col</code>, <code id="plot.gofN_+3A_pch">pch</code>, <code id="plot.gofN_+3A_cex">cex</code>, <code id="plot.gofN_+3A_bg">bg</code></td>
<td>
<p>vector of values (wrapped in <code><a href="base.html#topic+I">I()</a></code>), network attribute, or a formula whose RHS gives an expression in terms of network attributes to plot against.</p>
</td></tr>
<tr><td><code id="plot.gofN_+3A_...">...</code></td>
<td>
<p>additional arguments to <code><a href="graphics.html#topic+plot">plot()</a></code>, <code><a href="stats.html#topic+qqnorm">qqnorm()</a></code>, and <code><a href="stats.html#topic+qqline">qqline()</a></code>, and others.</p>
</td></tr>
<tr><td><code id="plot.gofN_+3A_ask">ask</code></td>
<td>
<p>whether the user should be prompted between the plots.</p>
</td></tr>
<tr><td><code id="plot.gofN_+3A_id.n">id.n</code></td>
<td>
<p>maximum number of extreme points to label explicitly.</p>
</td></tr>
<tr><td><code id="plot.gofN_+3A_id.label">id.label</code></td>
<td>
<p>specification for how extreme points are to be labeled, defaulting to network's index in the combined network.</p>
</td></tr>
<tr><td><code id="plot.gofN_+3A_main">main</code></td>
<td>
<p>a template for the plots' titles; these use <code><a href="glue.html#topic+glue">glue()</a></code>'s templating, with <code>{type}</code> replaced with the type of plot and <code>{name}</code> replaced with the statistic.</p>
</td></tr>
<tr><td><code id="plot.gofN_+3A_xlab">xlab</code></td>
<td>
<p>horizontal axis label; defaults to a character representation of <code>against</code>.</p>
</td></tr>
<tr><td><code id="plot.gofN_+3A_ylim">ylim</code></td>
<td>
<p>vertical range for the plots, interpreted as in <code><a href="graphics.html#topic+plot.default">graphics::plot()</a></code>; can be specified as a list with 3 elements, giving the range for the corresponding plot according to the plot numbers for the <code style="white-space: pre;">&#8288;which=&#8288;</code> argument, and can be used to ensure that, e.g., diagnostic plots for different models are on the same scale.</p>
</td></tr>
<tr><td><code id="plot.gofN_+3A_cex.id">cex.id</code></td>
<td>
<p>scaling factor for characters used to label extreme points; see <code><a href="stats.html#topic+plot.lm">plot.lm()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.gofN_+3A_mappings">mappings</code></td>
<td>
<p>a named list of lists of mappings constructed by <code><a href="ggplot2.html#topic+aes">ggplot2::aes()</a></code> overriding the defaults. See Details below.</p>
</td></tr>
<tr><td><code id="plot.gofN_+3A_geom_args">geom_args</code></td>
<td>
<p>a named list of lists of arguments overriding the defaults for the individual geoms. See Details below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the <code>plot()</code> method, <code>against</code> and <code>id.label</code> can be vectors of values (enclosed in <code><a href="base.html#topic+I">I()</a></code> to be used as is), a character string identifying a network attribute, or a formula whose RHS gives an expression in terms of network attributes to plot against. The <code>against</code> formula may also contain a <code>.fitted</code> variable which will be substituted with the fitted values.
</p>
<p>For <code>autoplot.gofN()</code>, <code>against</code> and <code>id.label</code> are interpreted as
expressions in terms of network attributes and values generated by
<code><a href="#topic+augment.gofN">augment.gofN()</a></code>, included <code>.fitted</code> for the fitted values.
</p>


<h3>Value</h3>

<p><code>autoplot.gofN()</code> returns a list of <code>ggplot</code> objects that
if printed render to diagnostic plots. If there is only one, the
object itself is returned.
</p>


<h3>Customising <code>autoplot.gofN()</code></h3>

<p><code>autoplot.gofN()</code> constructs the plots out of <code><a href="ggplot2.html#topic+ggplot">ggplot2::ggplot()</a></code>,
<code><a href="ggplot2.html#topic+geom_point">ggplot2::geom_point()</a></code> (for numeric <code>against</code>), <code><a href="ggplot2.html#topic+geom_boxplot">ggplot2::geom_boxplot()</a></code> for
categorical or ordinal <code>against</code>), and <code><a href="ggplot2.html#topic+geom_smooth">ggplot2::geom_smooth()</a></code> (for numeric
or ordinal <code>against</code>), and <code><a href="ggrepel.html#topic+geom_text_repel">ggrepel::geom_text_repel()</a></code>. Mappings and
arguments passed through <code>mappings</code> and <code>geom_args</code> override the
respective defaults. They may have elements <code>default</code> (for
<code>ggplot()</code>), <code>point</code> (for <code>geom_point()</code> and <code>geom_boxplot()</code>),
<code>smooth</code> (for <code>geom_smooth</code>), and <code>text</code> (for <code>geom_text_repel()</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gofN">gofN()</a></code> for examples, <code><a href="stats.html#topic+plot.lm">plot.lm()</a></code>, <code><a href="graphics.html#topic+plot.default">graphics::plot()</a></code> for regression diagnostic plots and their parameters.
</p>

<hr>
<h2 id='snctrl'>Statnet Control</h2><span id='topic+snctrl'></span>

<h3>Description</h3>

<p>A utility to facilitate argument completion of control lists, reexported from <code>statnet.common</code>.
</p>


<h3>Currently recognised control parameters</h3>

<p>This list is updated as packages are loaded and unloaded.
</p>


<h4>Package <span class="pkg">ergm</span></h4>

<dl>
<dt><code><a href="ergm.html#topic+control.ergm">control.ergm</a></code></dt><dd><p><code>drop, init, init.method, main.method, force.main, main.hessian,
             checkpoint, resume, MPLE.samplesize, init.MPLE.samplesize,
             MPLE.type, MPLE.maxit, MPLE.nonvar, MPLE.nonident,
             MPLE.nonident.tol, MPLE.covariance.samplesize,
             MPLE.covariance.method, MPLE.covariance.sim.burnin,
             MPLE.covariance.sim.interval, MPLE.constraints.ignore,
             MCMC.prop, MCMC.prop.weights, MCMC.prop.args,
             MCMC.interval, MCMC.burnin, MCMC.samplesize,
             MCMC.effectiveSize, MCMC.effectiveSize.damp,
             MCMC.effectiveSize.maxruns,
             MCMC.effectiveSize.burnin.pval,
             MCMC.effectiveSize.burnin.min,
             MCMC.effectiveSize.burnin.max,
             MCMC.effectiveSize.burnin.nmin,
             MCMC.effectiveSize.burnin.nmax,
             MCMC.effectiveSize.burnin.PC,
             MCMC.effectiveSize.burnin.scl,
             MCMC.effectiveSize.order.max, MCMC.return.stats,
             MCMC.runtime.traceplot, MCMC.maxedges, MCMC.addto.se,
             MCMC.packagenames, SAN.maxit, SAN.nsteps.times, SAN,
             MCMLE.termination, MCMLE.maxit, MCMLE.conv.min.pval,
             MCMLE.confidence, MCMLE.confidence.boost,
             MCMLE.confidence.boost.threshold,
             MCMLE.confidence.boost.lag, MCMLE.NR.maxit,
             MCMLE.NR.reltol, obs.MCMC.mul, obs.MCMC.samplesize.mul,
             obs.MCMC.samplesize, obs.MCMC.effectiveSize,
             obs.MCMC.interval.mul, obs.MCMC.interval,
             obs.MCMC.burnin.mul, obs.MCMC.burnin, obs.MCMC.prop,
             obs.MCMC.prop.weights, obs.MCMC.prop.args,
             obs.MCMC.impute.min_informative,
             obs.MCMC.impute.default_density, MCMLE.min.depfac,
             MCMLE.sampsize.boost.pow, MCMLE.MCMC.precision,
             MCMLE.MCMC.max.ESS.frac, MCMLE.metric, MCMLE.method,
             MCMLE.dampening, MCMLE.dampening.min.ess,
             MCMLE.dampening.level, MCMLE.steplength.margin,
             MCMLE.steplength, MCMLE.steplength.parallel,
             MCMLE.sequential, MCMLE.density.guard.min,
             MCMLE.density.guard, MCMLE.effectiveSize,
             obs.MCMLE.effectiveSize, MCMLE.interval, MCMLE.burnin,
             MCMLE.samplesize.per_theta, MCMLE.samplesize.min,
             MCMLE.samplesize, obs.MCMLE.samplesize.per_theta,
             obs.MCMLE.samplesize.min, obs.MCMLE.samplesize,
             obs.MCMLE.interval, obs.MCMLE.burnin,
             MCMLE.steplength.solver, MCMLE.last.boost,
             MCMLE.steplength.esteq, MCMLE.steplength.miss.sample,
             MCMLE.steplength.min, MCMLE.effectiveSize.interval_drop,
             MCMLE.save_intermediates, MCMLE.nonvar, MCMLE.nonident,
             MCMLE.nonident.tol, SA.phase1_n, SA.initial_gain,
             SA.nsubphases, SA.min_iterations, SA.max_iterations,
             SA.phase3_n, SA.interval, SA.burnin, SA.samplesize,
             CD.samplesize.per_theta, obs.CD.samplesize.per_theta,
             CD.nsteps, CD.multiplicity, CD.nsteps.obs,
             CD.multiplicity.obs, CD.maxit, CD.conv.min.pval,
             CD.NR.maxit, CD.NR.reltol, CD.metric, CD.method,
             CD.dampening, CD.dampening.min.ess, CD.dampening.level,
             CD.steplength.margin, CD.steplength, CD.adaptive.epsilon,
             CD.steplength.esteq, CD.steplength.miss.sample,
             CD.steplength.min, CD.steplength.parallel,
             CD.steplength.solver, loglik, term.options, seed,
             parallel, parallel.type, parallel.version.check,
             parallel.inherit.MT, ...</code></p>
</dd><dt><code><a href="ergm.html#topic+control.ergm.bridge">control.ergm.bridge</a></code></dt><dd><p><code>bridge.nsteps, bridge.target.se, bridge.bidirectional, MCMC.burnin,
                    MCMC.burnin.between, MCMC.interval,
                    MCMC.samplesize, obs.MCMC.burnin,
                    obs.MCMC.burnin.between, obs.MCMC.interval,
                    obs.MCMC.samplesize, MCMC.prop, MCMC.prop.weights,
                    MCMC.prop.args, obs.MCMC.prop,
                    obs.MCMC.prop.weights, obs.MCMC.prop.args,
                    MCMC.maxedges, MCMC.packagenames, term.options,
                    seed, parallel, parallel.type,
                    parallel.version.check, parallel.inherit.MT, ...</code></p>
</dd><dt><code><a href="ergm.html#topic+control.ergm.godfather">control.ergm.godfather</a></code></dt><dd><p><code>term.options</code></p>
</dd><dt><code><a href="ergm.html#topic+control.gof.ergm">control.gof.ergm</a></code></dt><dd><p><code>nsim, MCMC.burnin, MCMC.interval, MCMC.batch, MCMC.prop,
                 MCMC.prop.weights, MCMC.prop.args, MCMC.maxedges,
                 MCMC.packagenames, MCMC.runtime.traceplot,
                 network.output, seed, parallel, parallel.type,
                 parallel.version.check, parallel.inherit.MT</code></p>
</dd><dt><code><a href="ergm.html#topic+control.gof.formula">control.gof.formula</a></code></dt><dd><p><code>nsim, MCMC.burnin, MCMC.interval, MCMC.batch, MCMC.prop,
                    MCMC.prop.weights, MCMC.prop.args, MCMC.maxedges,
                    MCMC.packagenames, MCMC.runtime.traceplot,
                    network.output, seed, parallel, parallel.type,
                    parallel.version.check, parallel.inherit.MT</code></p>
</dd><dt><code><a href="ergm.html#topic+control.logLik.ergm">control.logLik.ergm</a></code></dt><dd><p><code>bridge.nsteps, bridge.target.se, bridge.bidirectional, MCMC.burnin,
                    MCMC.interval, MCMC.samplesize,
                    obs.MCMC.samplesize, obs.MCMC.interval,
                    obs.MCMC.burnin, MCMC.prop, MCMC.prop.weights,
                    MCMC.prop.args, obs.MCMC.prop,
                    obs.MCMC.prop.weights, obs.MCMC.prop.args,
                    MCMC.maxedges, MCMC.packagenames, term.options,
                    seed, parallel, parallel.type,
                    parallel.version.check, parallel.inherit.MT, ...</code></p>
</dd><dt><code><a href="ergm.html#topic+control.san">control.san</a></code></dt><dd><p><code>SAN.maxit, SAN.tau, SAN.invcov, SAN.invcov.diag, SAN.nsteps.alloc,
            SAN.nsteps, SAN.samplesize, SAN.prop, SAN.prop.weights,
            SAN.prop.args, SAN.packagenames, SAN.ignore.finite.offsets,
            term.options, seed, parallel, parallel.type,
            parallel.version.check, parallel.inherit.MT</code></p>
</dd><dt><code><a href="ergm.html#topic+control.simulate">control.simulate</a></code></dt><dd><p><code>MCMC.burnin, MCMC.interval, MCMC.prop, MCMC.prop.weights,
                 MCMC.prop.args, MCMC.batch, MCMC.effectiveSize,
                 MCMC.effectiveSize.damp, MCMC.effectiveSize.maxruns,
                 MCMC.effectiveSize.burnin.pval,
                 MCMC.effectiveSize.burnin.min,
                 MCMC.effectiveSize.burnin.max,
                 MCMC.effectiveSize.burnin.nmin,
                 MCMC.effectiveSize.burnin.nmax,
                 MCMC.effectiveSize.burnin.PC,
                 MCMC.effectiveSize.burnin.scl,
                 MCMC.effectiveSize.order.max, MCMC.maxedges,
                 MCMC.packagenames, MCMC.runtime.traceplot,
                 network.output, term.options, parallel, parallel.type,
                 parallel.version.check, parallel.inherit.MT, ...</code></p>
</dd><dt><code><a href="ergm.html#topic+control.simulate.ergm">control.simulate.ergm</a></code></dt><dd><p><code>MCMC.burnin, MCMC.interval, MCMC.scale, MCMC.prop, MCMC.prop.weights,
                      MCMC.prop.args, MCMC.batch, MCMC.effectiveSize,
                      MCMC.effectiveSize.damp,
                      MCMC.effectiveSize.maxruns,
                      MCMC.effectiveSize.burnin.pval,
                      MCMC.effectiveSize.burnin.min,
                      MCMC.effectiveSize.burnin.max,
                      MCMC.effectiveSize.burnin.nmin,
                      MCMC.effectiveSize.burnin.nmax,
                      MCMC.effectiveSize.burnin.PC,
                      MCMC.effectiveSize.burnin.scl,
                      MCMC.effectiveSize.order.max, MCMC.maxedges,
                      MCMC.packagenames, MCMC.runtime.traceplot,
                      network.output, term.options, parallel,
                      parallel.type, parallel.version.check,
                      parallel.inherit.MT, ...</code></p>
</dd><dt><code><a href="ergm.html#topic+control.simulate.formula">control.simulate.formula</a></code></dt><dd><p><code>MCMC.burnin, MCMC.interval, MCMC.prop, MCMC.prop.weights,
                         MCMC.prop.args, MCMC.batch,
                         MCMC.effectiveSize, MCMC.effectiveSize.damp,
                         MCMC.effectiveSize.maxruns,
                         MCMC.effectiveSize.burnin.pval,
                         MCMC.effectiveSize.burnin.min,
                         MCMC.effectiveSize.burnin.max,
                         MCMC.effectiveSize.burnin.nmin,
                         MCMC.effectiveSize.burnin.nmax,
                         MCMC.effectiveSize.burnin.PC,
                         MCMC.effectiveSize.burnin.scl,
                         MCMC.effectiveSize.order.max, MCMC.maxedges,
                         MCMC.packagenames, MCMC.runtime.traceplot,
                         network.output, term.options, parallel,
                         parallel.type, parallel.version.check,
                         parallel.inherit.MT, ...</code></p>
</dd><dt><code><a href="ergm.html#topic+control.simulate.formula.ergm">control.simulate.formula.ergm</a></code></dt><dd><p><code>MCMC.burnin, MCMC.interval, MCMC.prop, MCMC.prop.weights,
                              MCMC.prop.args, MCMC.batch,
                              MCMC.effectiveSize,
                              MCMC.effectiveSize.damp,
                              MCMC.effectiveSize.maxruns,
                              MCMC.effectiveSize.burnin.pval,
                              MCMC.effectiveSize.burnin.min,
                              MCMC.effectiveSize.burnin.max,
                              MCMC.effectiveSize.burnin.nmin,
                              MCMC.effectiveSize.burnin.nmax,
                              MCMC.effectiveSize.burnin.PC,
                              MCMC.effectiveSize.burnin.scl,
                              MCMC.effectiveSize.order.max,
                              MCMC.maxedges, MCMC.packagenames,
                              MCMC.runtime.traceplot, network.output,
                              term.options, parallel, parallel.type,
                              parallel.version.check,
                              parallel.inherit.MT, ...</code></p>
</dd></dl>


<h4>Package <span class="pkg">ergm.multi</span></h4>

<dl>
<dt><code><a href="#topic+control.gofN">control.gofN</a></code></dt><dd><p><code>nsim, obs.twostage, array.max, simulate, obs.simulate, parallel,
             parallel.type, parallel.version.check, parallel.inherit.MT</code></p>
</dd><dt><code><a href="#topic+control.gofN.ergm">control.gofN.ergm</a></code></dt><dd><p><code>nsim, obs.twostage, array.max, simulate, obs.simulate, parallel,
                  parallel.type, parallel.version.check,
                  parallel.inherit.MT</code></p>
</dd></dl>



<h3>See Also</h3>

<p><code><a href="statnet.common.html#topic+snctrl">statnet.common::snctrl()</a></code>
</p>

<hr>
<h2 id='split.network'>A <code><a href="base.html#topic+split">split()</a></code> method for <code><a href="network.html#topic+network">network::network</a></code> objects.</h2><span id='topic+split.network'></span>

<h3>Description</h3>

<p>Split a network into subnetworks on a factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'network'
split(x, f, drop = FALSE, sep = ".", lex.order = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split.network_+3A_x">x</code></td>
<td>
<p>a <code><a href="network.html#topic+network">network::network</a></code> object.</p>
</td></tr>
<tr><td><code id="split.network_+3A_f">f</code>, <code id="split.network_+3A_drop">drop</code>, <code id="split.network_+3A_sep">sep</code>, <code id="split.network_+3A_lex.order">lex.order</code></td>
<td>
<p>see <code><a href="base.html#topic+split">split()</a></code>; note that <code>f</code> must have length equal to <code>network.size(x)</code>.</p>
</td></tr>
<tr><td><code id="split.network_+3A_...">...</code></td>
<td>
<p>additional arguments, currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="ergm.html#topic+network.list">network.list</a></code> containing the networks. These networks
will inherit all vertex and edge attributes, as well as relevant
network attributes.
</p>


<h3>See Also</h3>

<p><code><a href="network.html#topic+get.inducedSubgraph">network::get.inducedSubgraph()</a></code>
</p>

<hr>
<h2 id='subnetwork_templates'>Obtain empty networks representing constituents of a combined network</h2><span id='topic+subnetwork_templates'></span>

<h3>Description</h3>

<p>This utility uncombines a <code><a href="#topic+combine_networks">combine_networks()</a></code> network using subnetwork cache (which contains only empty networks). It is used primarily by initialisation functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subnetwork_templates(
  nw,
  split.vattr = ".NetworkID",
  names.vattr = ".NetworkName",
  copy.ergmlhs = c("response")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subnetwork_templates_+3A_nw">nw</code>, <code id="subnetwork_templates_+3A_split.vattr">split.vattr</code>, <code id="subnetwork_templates_+3A_names.vattr">names.vattr</code></td>
<td>
<p>see <code><a href="#topic+uncombine_network">uncombine_network()</a></code>.</p>
</td></tr>
<tr><td><code id="subnetwork_templates_+3A_copy.ergmlhs">copy.ergmlhs</code></td>
<td>
<p>a character vector of <code><a href="ergm.html#topic++25ergmlhs+25">%ergmlhs%</a></code> settings that are to be copied into the constituent networks.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code><a href="network.html#topic+network">network</a></code>s.
</p>

<hr>
<h2 id='twostarL-ergmTerm'>Multilayer two-star</h2><span id='topic+twostarL-ergmTerm'></span><span id='topic+InitErgmTerm.twostarL'></span>

<h3>Description</h3>

<p>This term adds one statistic to the model, equal to the number of
cross-layer two-stars or two-paths in
the network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: twostarL(Ls, type, distinct=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="twostarL-ergmTerm_+3A_ls">Ls</code></td>
<td>
<p>a list (constructed by <code><a href="base.html#topic+list">list()</a></code> or <code><a href="base.html#topic+c">c()</a></code> of two Layer Logic specifications (c.f. Layer Logic section in the <code><a href="#topic+Layer">Layer()</a></code> documentation) specifying the layers of interest.</p>
</td></tr>
<tr><td><code id="twostarL-ergmTerm_+3A_type">type</code></td>
<td>
<p>determines what is counted:
</p>

<ol>
<li> <p><em>&quot;any&quot;</em> Number of configurations
<code class="reqn">(i-j), (i-k)</code> , where
<code class="reqn">(i-j)</code> is in logical layer <code>Ls[[1]]</code>
and <code class="reqn">(i-k)</code> is in logical layer <code>Ls[[2]]</code> .
</p>
</li>
<li> <p><em>&quot;out&quot;</em> Number of configurations
<code class="reqn">(i{\rightarrow}j), (i{\rightarrow}k)</code>, where
<code class="reqn">(i{\rightarrow}j)</code> is in logical layer <code>Ls[[1]]</code>
and <code class="reqn">(i{\rightarrow}k)</code> is in logical layer <code>Ls[[2]]</code>.
</p>
</li>
<li> <p><em>&quot;in&quot;</em> Number of configurations
<code class="reqn">(j{\rightarrow}i), (k{\rightarrow}i)</code>, where
<code class="reqn">(j{\rightarrow}i)</code> is in logical layer <code>Ls[[1]]</code>
and <code class="reqn">(k{\rightarrow}i)</code> is in logical layer <code>Ls[[2]]</code>.
</p>
</li>
<li> <p><em>&quot;path&quot;</em> Number of configurations
<code class="reqn">(j{\rightarrow}i), (i{\rightarrow}k)</code>, where
<code class="reqn">(j{\rightarrow}i)</code> is in logical layer <code>Ls[[1]]</code>
and <code class="reqn">(i{\rightarrow}k)</code> is in logical layer <code>Ls[[2]]</code>.
</p>
</li></ol>

<p>At this time, <code>"any"</code> is only supported for undirected networks, and if the network is undirected, <code>type</code> is ignored and <code>"any"</code> is assumed.</p>
</td></tr>
<tr><td><code id="twostarL-ergmTerm_+3A_distinct">distinct</code></td>
<td>
<p>if <code>TRUE</code>, <code class="reqn">j</code> and <code class="reqn">k</code> above are required to
be distinct. That is, the constituent edges may not be coincident or
reciprocal.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="ergm.html#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, layer-aware, undirected, binary</p>


<hr>
<h2 id='uncombine_network'>Split up a network into a list of subgraphs</h2><span id='topic+uncombine_network'></span>

<h3>Description</h3>

<p>Given a network created by <code><a href="#topic+combine_networks">combine_networks()</a></code>, <code><a href="#topic+uncombine_network">uncombine_network()</a></code> returns a list of networks,
preserving attributes that can be preserved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uncombine_network(
  nw,
  split.vattr = nw %n% ".blockID.vattr",
  names.vattr = nw %n% ".blockName.vattr",
  use.subnet.cache = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uncombine_network_+3A_nw">nw</code></td>
<td>
<p>a <code><a href="network.html#topic+network">network::network</a></code> created by <code><a href="#topic+combine_networks">combine_networks()</a></code>.</p>
</td></tr>
<tr><td><code id="uncombine_network_+3A_split.vattr">split.vattr</code></td>
<td>
<p>name of the vertex attribute on which to split,
defaulting to the value of the <code>".blockID.vattr"</code> network
attribute.</p>
</td></tr>
<tr><td><code id="uncombine_network_+3A_names.vattr">names.vattr</code></td>
<td>
<p>optional name of the vertex attribute to use as
network names in the output list, defaulting to the value of the
<code>".blockName.vattr"</code> network attribute.</p>
</td></tr>
<tr><td><code id="uncombine_network_+3A_use.subnet.cache">use.subnet.cache</code></td>
<td>
<p>whether to use subnet cache if available;
this is only safe to do if the network is <em>not</em> used for its
edges but only for its vertex and network attributes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of <code><a href="network.html#topic+network">network::network</a></code>s containing subgraphs on <code>split.vattr</code>. In particular,
</p>

<ul>
<li><p> their basic properties (directedness and bipartednes) are the same as those of the input network;
</p>
</li>
<li><p> vertex attributes are split;
</p>
</li>
<li><p> edge attributes are assigned to their respective edges in
the returned networks.
</p>
</li></ul>

<p>If <code>split.vattr</code> is a vector, only the first element is used and it's &quot;popped&quot;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+split.network">split.network()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(samplk)

o1 &lt;- combine_networks(list(samplk1, samplk2, samplk3))
image(as.matrix(o1))

ol &lt;- uncombine_network(o1)

</code></pre>

<hr>
<h2 id='upper_tri-ergmConstraint'>Only dyads in the upper-triangle of the sociomatrix may be
toggled</h2><span id='topic+upper_tri-ergmConstraint'></span><span id='topic+InitErgmConstraint.upper_tri'></span>

<h3>Description</h3>

<p>For a directed network, only dyads <code class="reqn">(i,j)</code> for
which <code class="reqn">i &lt; j</code> may be toggled. Optional argument <code>attr</code>
controls which subgraphs are thus restricted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># upper_tri(attr = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="upper_tri-ergmConstraint_+3A_attr">attr</code></td>
<td>
<p>a vertex attribute specification (see Specifying Vertex attributes and Levels (<code>?nodal_attributes</code>) for details.)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="ergm.html#topic+ergmConstraint">ergmConstraint</a></code> for index of constraints and hints currently visible to the package.
</p>


<h4>Keywords</h4>

<p>directed, dyad-independent</p>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
