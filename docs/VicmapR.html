<!DOCTYPE html><html><head><title>Help for package VicmapR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {VicmapR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#check_geoserver'><p>Check Geoserver Response</p></a></li>
<li><a href='#collect.vicmap_promise'><p>Return Data</p></a></li>
<li><a href='#convert_layer_name'><p>Convert layer names from old platform naming convention to the new platform naming convention</p></a></li>
<li><a href='#CQL'><p>CQL escaping</p></a></li>
<li><a href='#cql_geom_predicates'><p>CQL Geometry Predicates</p></a></li>
<li><a href='#data_citation'><p>Layer Metadata</p></a></li>
<li><a href='#feature_hits'><p>The Number of Rows of the Promised Data</p></a></li>
<li><a href='#filter'><p>Filter Data</p></a></li>
<li><a href='#geom_col_name'><p>Get Column Information</p></a></li>
<li><a href='#head.vicmap_promise'><p>Return the first n rows of the data</p></a></li>
<li><a href='#listLayers'><p>List Available WFS Layers</p></a></li>
<li><a href='#name_conversions'><p>Name conversions between old and new geoserver</p></a></li>
<li><a href='#print.vicmap_promise'><p>Print a Snapshot of the Data</p></a></li>
<li><a href='#select'><p>Select Columns</p></a></li>
<li><a href='#show_query.vicmap_promise'><p>Show The Query</p></a></li>
<li><a href='#vicmap_options'><p>options</p></a></li>
<li><a href='#vicmap_query'><p>Establish Vicmap Query</p></a></li>
<li><a href='#wfsConnection-class'><p>wfsConnection class</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Access Victorian Spatial Data Through Web File Services (WFS)</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Easily interfaces R to spatial datasets available through 
  the Victorian Government's WFS (Web Feature Service): <a href="https://opendata.maps.vic.gov.au/geoserver/ows?request=GetCapabilities&amp;amp;service=wfs">https://opendata.maps.vic.gov.au/geoserver/ows?request=GetCapabilities&amp;service=wfs</a>, 
  which allows users to read in 'sf' data from these sources. VicmapR uses the lazy querying approach and code developed by Teucher et al. (2021) for the 'bcdata' R package &lt;<a href="https://doi.org/10.21105%2Fjoss.02927">doi:10.21105/joss.02927</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License (== 2.0)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://justincally.github.io/VicmapR/">https://justincally.github.io/VicmapR/</a>,
<a href="https://www.data.vic.gov.au/">https://www.data.vic.gov.au/</a>,
<a href="https://github.com/justincally/VicmapR/">https://github.com/justincally/VicmapR/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/justincally/VicmapR/issues">https://github.com/justincally/VicmapR/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.1.0), covr, rmarkdown</td>
</tr>
<tr>
<td>Imports:</td>
<td>magrittr, httr, sf (&ge; 0.8), dplyr, purrr, methods, cli, DBI,
xml2, glue, dbplyr (&ge; 2.2.0), rlang, curl, rvest, lubridate,
knitr, kableExtra, mapview, leaflet, stringr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GDAL (&gt;= 3.0.0), GEOS (&gt;= 3.4.0), PROJ (&gt;= 7.0.0)</td>
</tr>
<tr>
<td>Collate:</td>
<td>'globals.R' 'build-query.R' 'check_geoserver.R'
'cql-predicates.R' 'cql-translate.R' 'filter.R' 'select.R'
'listFeatures.R' 'polygonFormat.R' 'utils-collect.R'
'utils-classes.R' 'utils-head.R' 'utils-metadata.R'
'utils-options.R' 'utils-pipe.R' 'utils-show_query.R'
'metadata.R' 'convert-layer-names.R' 'data.R'</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-19 13:34:07 UTC; justincally</td>
</tr>
<tr>
<td>Author:</td>
<td>Justin Cally <a href="https://orcid.org/0000-0003-4584-2220"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Rachel Swain [ctb],
  Andy Teucher <a href="https://orcid.org/0000-0002-7840-692X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut] (bcdata author),
  Sam Albers <a href="https://orcid.org/0000-0002-9270-7884"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]
    (bcdata author),
  Stephanie Hazlitt <a href="https://orcid.org/0000-0002-3161-2304"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut] (bcdata author),
  Province of British Columbia [cph] (bcdata copyright)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Justin Cally &lt;justin.g.cally@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-20 17:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling <code>rhs(lhs)</code>.
</p>

<hr>
<h2 id='check_geoserver'>Check Geoserver Response</h2><span id='topic+check_geoserver'></span>

<h3>Description</h3>

<p>VicmapR relies upon a functioning geoserver. If for whatever reason the geoserver is not functioning then the functions
in this package will not work. This function will check the response of the geoserver; erroring out if the connection is down.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_geoserver(timeout = 15, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_geoserver_+3A_timeout">timeout</code></td>
<td>
<p>numeric: the time (in seconds) to wait for the response before timing out (default is 15)</p>
</td></tr>
<tr><td><code id="check_geoserver_+3A_quiet">quiet</code></td>
<td>
<p>logical: whether to silently check the connection and if working, return nothing. If <code>FALSE</code> (default),
the status message will be printed (<a href="httr.html#topic+http_status">http_status</a>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical, TRUE if the geoserver is working
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
try(
check_geoserver()
)

</code></pre>

<hr>
<h2 id='collect.vicmap_promise'>Return Data</h2><span id='topic+collect.vicmap_promise'></span><span id='topic+collect'></span>

<h3>Description</h3>

<p><code>collect()</code> will force the execution of the <code>vicmap_promise</code> query.
In doing so it will return an <code>sf</code> object into memory.
</p>
<p>See <code>dplyr::<a href="dplyr.html#topic+compute">collect</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vicmap_promise'
collect(x, quiet = FALSE, paginate = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collect.vicmap_promise_+3A_x">x</code></td>
<td>
<p>object of class <code>vicmap_promise</code> (likely passed from <code><a href="#topic+vicmap_query">vicmap_query()</a></code>)</p>
</td></tr>
<tr><td><code id="collect.vicmap_promise_+3A_quiet">quiet</code></td>
<td>
<p>logical; whether to suppress the printing of messages and progress</p>
</td></tr>
<tr><td><code id="collect.vicmap_promise_+3A_paginate">paginate</code></td>
<td>
<p>logical; whether to allow pagination of results to extract all records (default is TRUE,
meaning all data will be returned but it will take more time)</p>
</td></tr>
<tr><td><code id="collect.vicmap_promise_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <a href="sf.html#topic+st_read">st_read</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Collecting certain datasets without filters will likely result in a large object being returned. Given
that their is a limit on the number of rows that can be returned from the Vicmap geoserver (70,000) data will be
paginated; which essentially means that multiple queries will be sent with the data bound together at the end. This
process may take a while to run, thus it is recommended to filter large datasets before collection.
</p>


<h3>Value</h3>

<p>sf/tbl_df/tbl/data.frame matching the query parameters
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>vicmap_promise</code>: collect.vicmap_promise
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
try(
vicmap_query(layer = "open-data-platform:hy_watercourse") %&gt;%
head(5) %&gt;%
collect()
)

</code></pre>

<hr>
<h2 id='convert_layer_name'>Convert layer names from old platform naming convention to the new platform naming convention</h2><span id='topic+convert_layer_name'></span>

<h3>Description</h3>

<p>Convert layer names from old platform naming convention to the new platform naming convention
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_layer_name(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_layer_name_+3A_x">x</code></td>
<td>
<p>object of class <code>vicmap_promise</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class <code>vicmap_promise</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
try(
vicmap_query(layer = "datavic:VMHYDRO_WATERCOURSE_DRAIN") 
)

</code></pre>

<hr>
<h2 id='CQL'>CQL escaping</h2><span id='topic+CQL'></span>

<h3>Description</h3>

<p>Write a CQL expression to escape its inputs, and return a CQL/SQL object.
Used when writing filter expressions in <code><a href="#topic+vicmap_query">vicmap_query()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CQL(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CQL_+3A_...">...</code></td>
<td>
<p>Character vectors that will be combined into a single CQL statement.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <a href="https://docs.geoserver.org/stable/en/user/tutorials/cql/cql_tutorial.html">the CQL/ECQL for Geoserver website</a>.
</p>
<p>The code for cql escaping was developed by the bcdata team: <a href="https://bcgov.github.io/bcdata/reference/cql_geom_predicates.html">https://bcgov.github.io/bcdata/reference/cql_geom_predicates.html</a>
</p>


<h3>Value</h3>

<p>An object of class <code>c("CQL", "SQL")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CQL("FOO &gt; 12 &amp; NAME LIKE 'A&amp;'")
</code></pre>

<hr>
<h2 id='cql_geom_predicates'>CQL Geometry Predicates</h2><span id='topic+cql_geom_predicates'></span><span id='topic+EQUALS'></span><span id='topic+DISJOINT'></span><span id='topic+INTERSECTS'></span><span id='topic+TOUCHES'></span><span id='topic+CROSSES'></span><span id='topic+WITHIN'></span><span id='topic+CONTAINS'></span><span id='topic+OVERLAPS'></span><span id='topic+RELATE'></span><span id='topic+BBOX'></span><span id='topic+DWITHIN'></span><span id='topic+BEYOND'></span>

<h3>Description</h3>

<p>Functions to construct a CQL expression to be used
to filter results from <code><a href="#topic+vicmap_query">vicmap_query()</a></code>.
See <a href="https://docs.geoserver.org/stable/en/user/filter/ecql_reference.html#spatial-predicate">the geoserver CQL documentation for details</a>.
The sf object is automatically simplified to a less complex sf object
to reduce the complexity of the Web Service call. Subsequent in-memory
filtering may be needed to achieve exact results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EQUALS(geom)

DISJOINT(geom)

INTERSECTS(geom)

TOUCHES(geom)

CROSSES(geom)

WITHIN(geom)

CONTAINS(geom)

OVERLAPS(geom)

RELATE(geom, pattern)

BBOX(coords, crs = NULL)

DWITHIN(
  geom,
  distance,
  units = c("meters", "feet", "statute miles", "nautical miles", "kilometers")
)

BEYOND(
  geom,
  distance,
  units = c("meters", "feet", "statute miles", "nautical miles", "kilometers")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cql_geom_predicates_+3A_geom">geom</code></td>
<td>
<p>an <code>sf</code>/<code>sfc</code>/<code>sfg</code> or <code>bbox</code> object (from the <code>sf</code> package)</p>
</td></tr>
<tr><td><code id="cql_geom_predicates_+3A_pattern">pattern</code></td>
<td>
<p>spatial relationship specified by a DE-9IM matrix pattern.
A DE-9IM pattern is a string of length 9 specified using the characters
<code style="white-space: pre;">&#8288;*TF012&#8288;</code>. Example: <code>'1*T***T**'</code></p>
</td></tr>
<tr><td><code id="cql_geom_predicates_+3A_coords">coords</code></td>
<td>
<p>the coordinates of the bounding box as four-element numeric
vector <code>c(xmin, ymin, xmax, ymax)</code>, a <code>bbox</code> object from the <code>sf</code>
package (the result of running <code>sf::st_bbox()</code> on an <code>sf</code> object), or
an <code>sf</code> object which then gets converted to a bounding box on the fly.</p>
</td></tr>
<tr><td><code id="cql_geom_predicates_+3A_crs">crs</code></td>
<td>
<p>(Optional) A numeric value or string containing an SRS code. If
<code>coords</code> is a <code>bbox</code> object with non-empty crs, it is taken from that.
(For example, <code>'EPSG:3005'</code> or just <code>3005</code>. The default is to use the CRS of
the queried layer)</p>
</td></tr>
<tr><td><code id="cql_geom_predicates_+3A_distance">distance</code></td>
<td>
<p>numeric value for distance tolerance</p>
</td></tr>
<tr><td><code id="cql_geom_predicates_+3A_units">units</code></td>
<td>
<p>units that distance is specified in. One of
<code>"feet"</code>, <code>"meters"</code>, <code>"statute miles"</code>, <code>"nautical miles"</code>, <code>"kilometers"</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The code for these cql predicates was developed by the bcdata team: <a href="https://bcgov.github.io/bcdata/reference/cql_geom_predicates.html">https://bcgov.github.io/bcdata/reference/cql_geom_predicates.html</a>
</p>


<h3>Value</h3>

<p>a CQL expression to be passed on to the WFS call
</p>

<hr>
<h2 id='data_citation'>Layer Metadata</h2><span id='topic+data_citation'></span><span id='topic+data_dictionary'></span><span id='topic+get_metadata'></span>

<h3>Description</h3>

<p>formatted metadata attributes of a given vicmap layer (<code>vicmap_query(layer)</code>).
Metadata is retrieved from the Vicmap catalogue. <code>data_citation()</code> prints a BibTex style citation for a given record;
similar to <code>base::citation()</code>. <code>data_dictionary()</code> returns a table with names, types and descriptions of the data within the
selected layer (see details). <code>get_metdata()</code> returns a list with three elements, containing metadata, the data dictionary and the url of the
metadata for the record.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_citation(x = NULL, metadataID = NULL)

data_dictionary(x = NULL, metadataID = NULL)

get_metadata(x = NULL, metadataID = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_citation_+3A_x">x</code></td>
<td>
<p>Object of class <code>vicmap_promise</code> (likely passed from <code><a href="#topic+vicmap_query">vicmap_query()</a></code>)</p>
</td></tr>
<tr><td><code id="data_citation_+3A_metadataid">metadataID</code></td>
<td>
<p>character: ID of data (useful if data is not available through WFS)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>citation, data.frame or list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
try(
data_citation(vicmap_query(layer = "datavic:VMHYDRO_WATERCOURSE_DRAIN"))
)


try(
data_dictionary(vicmap_query(layer = "datavic:VMHYDRO_WATERCOURSE_DRAIN"))
)


try(
get_metadata(vicmap_query(layer = "datavic:VMHYDRO_WATERCOURSE_DRAIN"))
)

</code></pre>

<hr>
<h2 id='feature_hits'>The Number of Rows of the Promised Data</h2><span id='topic+feature_hits'></span>

<h3>Description</h3>

<p><code>feature_hits()</code> returns an integer of the number of rows that match the passed query/promise.
This is similar to how <code>nrow()</code> works for a data.frame, however it will evaluate the number of rows to be returned
without having to download the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feature_hits(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="feature_hits_+3A_x">x</code></td>
<td>
<p>object of class <code>vicmap_promise</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
vicmap_query(layer = "open-data-platform:hy_watercourse") %&gt;%
 feature_hits()
 
</code></pre>

<hr>
<h2 id='filter'>Filter Data</h2><span id='topic+filter'></span><span id='topic+filter.vicmap_promise'></span>

<h3>Description</h3>

<p>See <code>dplyr::<a href="dplyr.html#topic+filter">filter</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vicmap_promise'
filter(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_+3A_.data">.data</code></td>
<td>
<p>object of class <code>vicmap_promise</code> (likely passed from <code><a href="#topic+vicmap_query">vicmap_query()</a></code>)</p>
</td></tr>
<tr><td><code id="filter_+3A_...">...</code></td>
<td>
<p>filter statements</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>vicmap_promise</code>, which is a 'promise' of the data that can  be returned if <code>collect()</code> is used
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>vicmap_promise</code>: filter.vicmap_promise
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
try(
vicmap_query(layer = "open-data-platform:hy_watercourse") %&gt;%
 filter(hierarchy == "L", pfi == 8553127)
 )
 
</code></pre>

<hr>
<h2 id='geom_col_name'>Get Column Information</h2><span id='topic+geom_col_name'></span><span id='topic+feature_cols'></span><span id='topic+get_col_df'></span>

<h3>Description</h3>

<p><code>geom_col_name</code> returns a single value for the name of the geometry column for the
WFS layer selected in the <code>vicmap_promise</code> object (e.g. <code>SHAPE</code>). This column will become the <code>geometry</code> column
when using <code>collect()</code>. <code>feature_cols()</code> provides a vector of all column names for the WFS layer selected in the
<code>vicmap_promise</code> object and  <code>get_col_df()</code> returns a data.frame with the column names and their XML schema string
datatypes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_col_name(x)

feature_cols(x)

get_col_df(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_col_name_+3A_x">x</code></td>
<td>
<p>object of class <code>vicmap_promise</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>character/data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Return the name of the geometry column
vicmap_query(layer = "open-data-platform:hy_watercourse") %&gt;% 
  geom_col_name()
 

# Return the column names as a character vector
vicmap_query(layer = "open-data-platform:hy_watercourse") %&gt;% 
  feature_cols()
   

# Return a data.frame of the columns and their XML schema string datatypes
try(
vicmap_query(layer = "open-data-platform:hy_watercourse") %&gt;% 
  get_col_df()
  )
 
</code></pre>

<hr>
<h2 id='head.vicmap_promise'>Return the first n rows of the data</h2><span id='topic+head.vicmap_promise'></span><span id='topic+head'></span>

<h3>Description</h3>

<p>See <code>utils::<a href="utils.html#topic+head">head</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vicmap_promise'
head(x, n = 5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="head.vicmap_promise_+3A_x">x</code></td>
<td>
<p>object of class <code>vicmap_promise</code> (likely passed from <code><a href="#topic+vicmap_query">vicmap_query()</a></code>)</p>
</td></tr>
<tr><td><code id="head.vicmap_promise_+3A_n">n</code></td>
<td>
<p>integer; number of rows to return</p>
</td></tr>
<tr><td><code id="head.vicmap_promise_+3A_...">...</code></td>
<td>
<p>Other parameters possibly used by generic</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>vicmap_promise</code>, which is a 'promise' of the data that can  be returned if <code>collect()</code> is used
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>vicmap_promise</code>: head.vicmap_promise
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
try(
vicmap_query(layer = "open-data-platform:hy_watercourse") %&gt;%
head(50)
)

</code></pre>

<hr>
<h2 id='listLayers'>List Available WFS Layers</h2><span id='topic+listLayers'></span>

<h3>Description</h3>

<p>Lists layers available from the WFS geoserver. This is similar to sending the
WFS request of <code>getFeatureTypes</code>. <code>listLayers()</code> returns a data.frame with the 'Name' and title of the
layers available. The 'Name' is what is used within <code>vicmap_query()</code> while the title provides somewhat of a
description/clarification about the layer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>listLayers(..., abstract = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="listLayers_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <a href="base.html#topic+grep">grep</a>. The <code>pattern</code> argument can be used to search for specific layers with matching names or titles.</p>
</td></tr>
<tr><td><code id="listLayers_+3A_abstract">abstract</code></td>
<td>
<p>Whether to return a column of abstract (and metadata ID), the default is true. Switching to FALSE will provide a data.frame with only 2 columns and may be slightly faster.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame of 2 (abstract = FALSE) or 4 (abstract = TRUE) columns
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
try(
listLayers(pattern = "trees", ignore.case = TRUE)
)

</code></pre>

<hr>
<h2 id='name_conversions'>Name conversions between old and new geoserver</h2><span id='topic+name_conversions'></span>

<h3>Description</h3>

<p>A dataset containing the names of the old and corresponding new data on geoserver, including relevent CQL filters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(name_conversions)
</code></pre>


<h3>Format</h3>

<p>A data frame with 630 rows and 5 variables
</p>


<h3>Details</h3>


<ul>
<li><p> Original_Layer_Name. The name of the original data 'typeNames', without the 'datavic:' prefix
</p>
</li>
<li><p> New_Layer_Name. The new 'typeNames' for the corresponding data stored on the AWS cloud geoserver
</p>
</li>
<li><p> CQL_FILTER. The CQL filter that needs to be applied to the new data to match the old datset
</p>
</li>
<li><p> full_original_name. The full name of the original layer (with prefix)
</p>
</li>
<li><p> full_new_name. The full name of the new data (with prefix to be used when calling the layer with <code>vicmap_query()</code>)
</p>
</li></ul>


<hr>
<h2 id='print.vicmap_promise'>Print a Snapshot of the Data</h2><span id='topic+print.vicmap_promise'></span>

<h3>Description</h3>

<p><code>print()</code> displays a cut of the data (no more than  six rows)
alongside the number of rows and columns that would be returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vicmap_promise'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.vicmap_promise_+3A_x">x</code></td>
<td>
<p>object of class <code>vicmap_promise</code> (likely passed from <code><a href="#topic+vicmap_query">vicmap_query()</a></code>)</p>
</td></tr>
<tr><td><code id="print.vicmap_promise_+3A_...">...</code></td>
<td>
<p>arguments to be passed to <a href="base.html#topic+print">print</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>vicmap_promise (invisible), promise sample printed to console
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
try(
query &lt;- vicmap_query(layer = "open-data-platform:hy_watercourse")
)
try(
print(query)
)

</code></pre>

<hr>
<h2 id='select'>Select Columns</h2><span id='topic+select'></span><span id='topic+select.vicmap_promise'></span>

<h3>Description</h3>

<p>See <code>dplyr::<a href="dplyr.html#topic+select">select</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vicmap_promise'
select(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_+3A_.data">.data</code></td>
<td>
<p>object of class <code>vicmap_promise</code> (likely passed from <code><a href="#topic+vicmap_query">vicmap_query()</a></code>)</p>
</td></tr>
<tr><td><code id="select_+3A_...">...</code></td>
<td>
<p>Other parameters possibly used by generic</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>vicmap_promise</code>, which is a 'promise' of the data that can  be returned if <code>collect()</code> is used
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>vicmap_promise</code>: select.vicmap_promise
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
try(
vicmap_query(layer = "open-data-platform:hy_watercourse") %&gt;%
 select(hierarchy,  pfi)
)

</code></pre>

<hr>
<h2 id='show_query.vicmap_promise'>Show The Query</h2><span id='topic+show_query.vicmap_promise'></span><span id='topic+show_query'></span>

<h3>Description</h3>

<p><code>show_query()</code> summarises the constructed query that has been passed to it by printing details
about the query in a human readable format.
</p>
<p>See <code>dplyr::<a href="dplyr.html#topic+explain">show_query</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vicmap_promise'
show_query(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_query.vicmap_promise_+3A_x">x</code></td>
<td>
<p>Object of class <code>vicmap_promise</code> (likely passed from <code><a href="#topic+vicmap_query">vicmap_query()</a></code>)</p>
</td></tr>
<tr><td><code id="show_query.vicmap_promise_+3A_...">...</code></td>
<td>
<p>Other parameters possibly used by generic</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The printed information consists of three sections:
</p>

<ul>
<li><p><strong>base url</strong> The base url of the query, this can be changed with options(vicmap.base_url = another_url)
</p>
</li>
<li><p><strong>body</strong> Lists the parameters of the WFS query, these can be modified through various functions such as <code>vicmap_query()</code>, <code>filter()</code>, <code>select()</code> and <code>head()</code>
</p>
</li>
<li><p><strong>full query url</strong> The constructed url of the final query to be collected
</p>
</li></ul>



<h3>Value</h3>

<p>object of class <code>vicmap_promise</code> (invisible: query printed to console), which is a 'promise' of the data that can  be returned if <code>collect()</code> is used
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>vicmap_promise</code>: show_query.vicmap_promise
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
try(
vicmap_query(layer = "open-data-platform:hy_watercourse") %&gt;%
head(50) %&gt;%
show_query()
)

</code></pre>

<hr>
<h2 id='vicmap_options'>options</h2><span id='topic+vicmap_options'></span><span id='topic+check_chunk_limit'></span>

<h3>Description</h3>

<p>This function retrieves bcdata specific options that can be set. These options can be set
using <code style="white-space: pre;">&#8288;option({name of the option} = {value of the option})&#8288;</code>. The default options are purposefully
set conservatively to hopefully ensure successful requests. Resetting these options may result in
failed calls to the data catalogue. Options in R are reset every time R is re-started.
</p>
<p><code>vicmap.max_geom_pred_size</code> is the maximum size of an object used for a geometric operation. Objects
that are bigger than this value will be simplified in the request call using sf::st_simplify().
This is done to reduce the size of the query being sent to the WFS geoserver.
</p>
<p><code>vicmap.chunk_limit</code> is an option useful when dealing with very large data sets. When requesting large objects
from the catalogue, the request is broken up into smaller chunks which are then recombined after they've
been downloaded. VicmapR does this all for you but using this option you can set the size of the chunk
requested. On faster internet connections, a bigger chunk limit could be useful while on slower connections,
it is advisable to lower the chunk limit. Chunks must be less than 70000.
</p>
<p><code>vicmap.base_url</code> is the base wfs url used to query the geoserver.
</p>
<p><code>vicmap.backend</code> is the backend software running the geoserver. The data migration in 2022/2023 will change the backend from 'Oracle' to 'AWS'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vicmap_options()

check_chunk_limit()
</code></pre>


<h3>Value</h3>

<p>vicmap_options() returns a <code>data.frame</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vicmap_options()
</code></pre>

<hr>
<h2 id='vicmap_query'>Establish Vicmap Query</h2><span id='topic+vicmap_query'></span>

<h3>Description</h3>

<p>Begin a Vicmap WFS query by selecting a WFS layer. The record must be available as a
Web Feature Service (WFS) layer (listed in <code>listLayers()</code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vicmap_query(layer, CRS = 4283, wfs_version = "2.0.0")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vicmap_query_+3A_layer">layer</code></td>
<td>
<p>vicmap layer to query. Options are listed in <code>listLayers()</code></p>
</td></tr>
<tr><td><code id="vicmap_query_+3A_crs">CRS</code></td>
<td>
<p>Coordinate Reference System (default is 4283)</p>
</td></tr>
<tr><td><code id="vicmap_query_+3A_wfs_version">wfs_version</code></td>
<td>
<p>The current version of WFS is 2.0.0.
GeoServer supports versions 2.0.0, 1.1.0, and 1.0.0.
However in order for filtering to be correctly applied wfs_version must be 2.0.0 (default is 2.0.0)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The returned <code>vicmap_promise</code> object is not data, rather it is a 'promise' of the data that can
be returned if <code>collect()</code> is used; which returns an <code>sf</code> object.
</p>


<h3>Value</h3>

<p>object of class <code>vicmap_promise</code>, which is a 'promise' of the data that can  be returned if <code>collect()</code> is used
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
try(
vicmap_query(layer = "open-data-platform:hy_watercourse")
)

</code></pre>

<hr>
<h2 id='wfsConnection-class'>wfsConnection class</h2><span id='topic+wfsConnection-class'></span><span id='topic+dbQuoteIdentifier+2CwfsConnection+2CANY-method'></span><span id='topic+dbQuoteString+2CwfsConnection+2CANY-method'></span>

<h3>Description</h3>

<p>wfsConnection class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'wfsConnection,ANY'
dbQuoteIdentifier(conn, x)

## S4 method for signature 'wfsConnection,ANY'
dbQuoteString(conn, x)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
