<!DOCTYPE html><html><head><title>Help for package kmc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {kmc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#check_G_mat'>
<p>Check the contraints of KMC</p></a></li>
<li><a href='#kmc.bjtest'>
<p>Calculate the NPMLE with constriants for accelerated failure time model with given coefficients.</p></a></li>
<li><a href='#kmc.clean'>
<p>Perform Data Clean for the kmc Algorithm</p></a></li>
<li><a href='#kmc.solve'>
<p>Calculate NPMLE with constriants for right censored data</p>
</a></li>
<li><a href='#plotkmc2D'>
<p>Plot the contour plot of log-likelihood around the H0 (dim=2).</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Kaplan-Meier Estimator with Constraints for Right Censored Data
&ndash; a Recursive Computational Algorithm</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4-2</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-11-21</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yifan Yang &lt;yfyang.86@hotmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Given constraints for right censored data, we use a recursive computational algorithm to calculate the the "constrained" Kaplan-Meier estimator. The constraint is assumed given in linear estimating equations or mean functions. We also illustrate how this leads to the empirical likelihood ratio test with right censored data and accelerated failure time model with given coefficients. EM algorithm from emplik package is used to get the initial value. The properties and performance of the EM algorithm is discussed in Mai Zhou and Yifan Yang (2015)&lt;<a href="https://doi.org/10.1007%2Fs00180-015-0567-9">doi:10.1007/s00180-015-0567-9</a>&gt; and Mai Zhou and Yifan Yang (2017) &lt;<a href="https://doi.org/10.1002%2Fwics.1400">doi:10.1002/wics.1400</a>&gt;. More applications could be found in Mai Zhou (2015) &lt;<a href="https://doi.org/10.1201%2Fb18598">doi:10.1201/b18598</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/yfyang86/kmc/">https://github.com/yfyang86/kmc/</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5), compiler, rootSolve, emplik</td>
</tr>
<tr>
<td>Suggests:</td>
<td>survival, ggplot2, tidyr, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-22 01:45:11 UTC; yifanyang</td>
</tr>
<tr>
<td>Author:</td>
<td>Yifan Yang [aut, cre, cph],
  Mai Zhou [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-22 08:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='check_G_mat'>
Check the contraints of KMC
</h2><span id='topic+check_G_mat'></span>

<h3>Description</h3>

<p>To derive the empirical likelihood with constraints, we need to make sure there are solutions.
Dines' method is used here to check whether the linear constraintsare proper or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_G_mat(gmat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_G_mat_+3A_gmat">gmat</code></td>
<td>

<p>A p by n. Here p is the number of constraints, n is the number of observations. The matrix is defined in &lt;doi: 10.1201/b18598&gt;.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>flg</code></td>
<td>

<p>A flag:
- 0: not proper
- 1: proper
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yifan Yang(yfyang.86@hotmail.com)
</p>


<h3>References</h3>

<p>Dines, L. L.  (1926). On positive solutions of a system of linear equations 
<em>Annals of Mathematics</em> 
<b>pages</b>  386â€“392
</p>
<p>Zhou, M. and Yang, Y. (2015).
A recursive formula for the Kaplan-Meier estimator with mean constraints and its application to empirical likelihood
<em>Computational Statistics</em>. <b>Online ISSN</b> 1613-9658.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### A Proper Example ####
x &lt;- c( 1, 1.5, 2, 3, 4.2, 5.0, 6.1, 5.3, 4.5, 0.9, 2.1, 4.3) 
d &lt;- c( 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1) 
f1 &lt;-function(x) { x - 3.7} 
f2 &lt;- function(x) {x^2 - 16.5 } 
g &lt;- list(f1, f2)
re = kmc.clean(x, d)
p = length(g)
n = length(re$kmc.time)
gmat&lt;-matrix(0, p, n);
for(i in 1:p){
  gmat[i,] = g[[i]](re$kmc.time)
  }
# You may want to require(Rcpp) on some platforms (such Mac OSX-ARM)
# library(Rcpp)
# check_G_mat(gmat)
</code></pre>

<hr>
<h2 id='kmc.bjtest'>
Calculate the NPMLE with constriants for accelerated failure time model with given coefficients.
</h2><span id='topic+kmc.bjtest'></span>

<h3>Description</h3>

<p>Use the empirical likelihood ratio and Wilks theorem to test if the regression coefficient equals
beta. 
</p>
<p style="text-align: center;"><code class="reqn">El(F)=\prod_{i=1}^{n}(\Delta F(T_i))^{\delta_i}(1-F(T_i))^{1-\delta_i}</code>
</p>

<p>with constraints
</p>
<p style="text-align: center;"><code class="reqn">
	\sum_i g(T_i)\Delta F(T_i)=0,\quad,i=1,2,\ldots
</code>
</p>

<p>Instead of EM algorithm, this function calculates the Kaplan-Meier estimator with mean constraints recursively to test <code class="reqn">H_0:~\beta=\beta_0</code> in the accelerated failure time model:
</p>
<p style="text-align: center;"><code class="reqn">
	\log(T_i) = y_i = x_i\beta^\top + \epsilon_i,
</code>
</p>

<p>where <code class="reqn">\epsilon</code> is distribution free.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kmc.bjtest(y, d, x, beta,init.st="naive")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kmc.bjtest_+3A_y">y</code></td>
<td>

<p>Response variable vector (length n).
</p>
</td></tr>
<tr><td><code id="kmc.bjtest_+3A_d">d</code></td>
<td>

<p>Status vector (length n), 0: right censored; 1 uncensored.
</p>
</td></tr>
<tr><td><code id="kmc.bjtest_+3A_x">x</code></td>
<td>

<p>n by p explanatory variable matrix.
</p>
</td></tr>
<tr><td><code id="kmc.bjtest_+3A_beta">beta</code></td>
<td>

<p>The value of the regression coeffiecnt vector (length p) to be tested.
</p>
</td></tr>
<tr><td><code id="kmc.bjtest_+3A_init.st">init.st</code></td>
<td>

<p>Type of methods to initialize the algorithm. By default, init.st is set to 1/n
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The empirical likelihood is the likelihood of the error term when the coefficients are specified. Model assumptions are the same as requirements of a standard Buckley-James estimator.
</p>


<h3>Value</h3>

<p>a list with the following components:
</p>
<table>
<tr><td><code>prob</code></td>
<td>

<p>the probabilities that max the empirical likelihood under estimating equation.
</p>
</td></tr>
<tr><td><code>logel1</code></td>
<td>

<p>the log empirical likelihood without constraints, i.e. under Kaplan-Merier of residuals'
</p>
</td></tr>
<tr><td><code>logel2</code></td>
<td>

<p>the log empirical likelihood with constraints, i.e. under null hypotheses or estimation equations.</p>
</td></tr>
<tr><td><code>"-2LLR"</code></td>
<td>

<p>the -2 loglikelihood ratio; have approximate chisq distribution under null hypotheses
</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>

<p>an indicator:
</p>
<p>0: fails to converge
</p>
<p>1: converged
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mai Zhou(mai@ms.uky.edu), Yifan Yang(yfyang.86@hotmail.com)
</p>


<h3>References</h3>

<p>Buckley, J. and James, I. (1979). Linear regression with censored data. <em>Biometrika</em>, <b>66</b> 429-36
</p>
<p>Zhou, M., &amp; Li, G. (2008).
Empirical likelihood analysis of the Buckley-James estimator. 
<em>Journal of multivariate analysis</em>, <b>99(4)</b>, 649-664.
</p>
<p>Zhou, M. and Yang, Y. (2015).
A recursive formula for the Kaplan-Meier estimator with mean constraints and its application to empirical likelihood
<em>Computational Statistics</em>. <b>Online ISSN</b> 1613-9658.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotkmc2D">plotkmc2D</a></code>, <code><a href="emplik.html#topic+bjtest">bjtest</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(survival)
stanford5 &lt;- stanford2[!is.na(stanford2$t5), ]
y &lt;- log10(stanford5$time)
d &lt;- stanford5$status
oy &lt;- order(y, -d)
d &lt;- d[oy]
y &lt;- y[oy]
x &lt;- cbind(1, stanford5$age)[oy,]
beta0  &lt;-  c(3.2, -0.015)
ss  &lt;-  kmc.bjtest(y, d, x=x, beta=beta0, init.st="naive")
</code></pre>

<hr>
<h2 id='kmc.clean'>
Perform Data Clean for the kmc Algorithm
</h2><span id='topic+kmc.clean'></span>

<h3>Description</h3>

<p>The kmc.clean function clean the (kmc.time, delta) for the randomized censored data:
</p>
<p>- Reorder the data according to the observed time and status;
</p>
<p>- Clean the (right) censored data point(s) if they happen before the first uncesored data.
</p>
<p>- If there are ties in the data. For the time points contain ties, e.g. </p>
<p style="text-align: center;"><code class="reqn">(T_{i_s}, d_{i_s}), i_s \in S \forall j \in S, T_{j} \equiv T</code>
</p>
<p>, we re-arranged the data in a manner that those with d=1 are ordered ahead of those with d=0. As d=0 indicates the data point is right censored, such procedure is trivial. </p>


<h3>Usage</h3>

<pre><code class='language-R'>kmc.clean(kmc.time, delta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kmc.clean_+3A_kmc.time">kmc.time</code></td>
<td>

<p>Non-negative real vector. The observed time.
</p>
</td></tr>
<tr><td><code id="kmc.clean_+3A_delta">delta</code></td>
<td>

<p>0/1 vector. Censoring status indictator, 0: right censored; 1 uncensored
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>kmc.time</code></td>
<td>

<p>The cleaned observed time.
</p>
</td></tr>
<tr><td><code>delta</code></td>
<td>

<p>The cleaned censoring status indictator, 0: right censored; 1 uncensored
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yifan Yang(yfyang.86@hotmail.com)
</p>


<h3>References</h3>

<p>Zhou, M. and Yang, Y. (2015).
A recursive formula for the Kaplan-Meier estimator with mean constraints and its application to empirical likelihood
<em>Computational Statistics</em>
<b>Online ISSN</b> 1613-9658.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c( 1, 1.5, 2, 3, 4.2, 5.0, 6.1, 5.3, 4.5, 0.9, 2.1, 4.3) 
d &lt;- c( 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1) 
kmc.clean(x, d)
</code></pre>

<hr>
<h2 id='kmc.solve'>
Calculate NPMLE with constriants for right censored data

</h2><span id='topic+kmc.solve'></span>

<h3>Description</h3>

<p>This function calculate the Kaplan-Meier estimator with mean constraints recursively. 
</p>
<p style="text-align: center;"><code class="reqn">El(F)=\prod_{i=1}^{n}(\Delta F(T_i))^{\delta_i}(1-F(T_i))^{1-\delta_i}</code>
</p>

<p>with constraints
</p>
<p style="text-align: center;"><code class="reqn">\sum_i g(T_i)\Delta F(T_i)=0,\quad,i=1,2,...</code>
</p>

<p>It uses Lagrange multiplier directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kmc.solve(x, d, g, em.boost = T, using.num = T, using.Fortran =
                 T, using.C = F, tmp.tag = T, rtol = 1e-09, control =
                 list(nr.it = 20, nr.c = 1, em.it = 3),...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kmc.solve_+3A_x">x</code></td>
<td>

<p>Non-negative real vector. The observed time.
</p>
</td></tr>
<tr><td><code id="kmc.solve_+3A_d">d</code></td>
<td>

<p>0/1 vector. Censoring status indictator, 0: right censored; 1 uncensored
</p>
</td></tr>
<tr><td><code id="kmc.solve_+3A_g">g</code></td>
<td>

<p>list of contraint functions. It should be a list of functions list(f1,f2,...) 
</p>
</td></tr>
<tr><td><code id="kmc.solve_+3A_em.boost">em.boost</code></td>
<td>

<p>A logical value. It determines whether the EM algorithm is used to get the initial value, default=TRUE. See 'Details' for EM control.
</p>
</td></tr>
<tr><td><code id="kmc.solve_+3A_using.num">using.num</code></td>
<td>

<p>A logical value. It determines whether the numeric derivatives is used in iterations, default=TRUE.
</p>
</td></tr>
<tr><td><code id="kmc.solve_+3A_using.fortran">using.Fortran</code></td>
<td>

<p>A logical value. It determines whether Fortran is used in root solving, default=F.
</p>
</td></tr>
<tr><td><code id="kmc.solve_+3A_using.c">using.C</code></td>
<td>

<p>A logical value. It determines whether to use Rcpp in iteraruib, default=T. This option will promote the computational efficiency of the KMC algorithm. Development version works on one constraint only, otherwise it will generate a Error information. It won't work on using.num=F.
</p>
</td></tr>
<tr><td><code id="kmc.solve_+3A_tmp.tag">tmp.tag</code></td>
<td>

<p>Development version needs it, keep it as TRUE.
</p>
</td></tr>
<tr><td><code id="kmc.solve_+3A_rtol">rtol</code></td>
<td>

<p>Tolerance used in rootSolve(multiroot) package, see 'rootSolve::multiroot'.
</p>
</td></tr>
<tr><td><code id="kmc.solve_+3A_control">control</code></td>
<td>

<p>A list. The entry nr.it controls max iterations allowed in N-R algorithm default=20; nr.c is the scaler used in N-R algorithm default=1; em.it is max iteration if use EM algorithm (em.boost) to get the initial value of lambda, default=3.
</p>
</td></tr>
<tr><td><code id="kmc.solve_+3A_...">...</code></td>
<td>

<p>Unspecified yet.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function check_G_mat checks whether the solution space is null or not under the constraint. But due to the computational complexity, it will detect at most two conditions.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>loglik.ha</code></td>
<td>

<p>The log empirical  likelihood without constraints
</p>
</td></tr>
<tr><td><code>loglik.h0</code></td>
<td>

<p>The log empirical likelihood with constraints
</p>
</td></tr>
<tr><td><code>"-2LLR"</code></td>
<td>

<p>The -2 Log empirical likelihood ratio
</p>
</td></tr>
<tr><td><code>phat</code></td>
<td>

<p style="text-align: center;"><code class="reqn">\Delta F(T_i)</code>
</p>

</td></tr>
<tr><td><code>pvalue</code></td>
<td>

<p>The p-value of the test
</p>
</td></tr>
<tr><td><code>df</code></td>
<td>

<p>Degree(s) of freedom. It equals the number of constraints.
</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>

<p>The lambda is the Lagrangian multiplier described in reference.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mai Zhou(mai@ms.uky.edu), Yifan Yang(yfyang.86@hotmail.com)
</p>


<h3>References</h3>

<p>Zhou, M. and Yang, Y. (2015).
A recursive formula for the Kaplan-Meier estimator with mean constraints and its application to empirical likelihood
<em>Computational Statistics</em>
<b>Online ISSN</b> 1613-9658.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotkmc2D">plotkmc2D</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># positive time
x &lt;- c( 1, 1.5, 2, 3, 4.2, 5.0, 6.1, 5.3, 4.5, 0.9, 2.1, 4.3) 
# status censored/uncensored
d &lt;- c( 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1)               

#################
# dim =1
#################

f &lt;- function(x) {x-3.7}                     # \sum f(ti) wi ~ 0 
g &lt;- list(f=f) ;                             #define constraint as a list

kmc.solve(x, d, g) ;                         #using default
kmc.solve(x, d, g, using.C=TRUE) ;           #using Rcpp

#################
# dim =2
#################

myfun5 &lt;- function( x)  { 
 x^2-16.5
} 

g &lt;- list( f1=f,f2=myfun5) ;                 #define constraint as a list

re0 &lt;- kmc.solve(x,d,g);

###################################################
# Print Estimation and other information 
# with option: digits = 5
###################################################

#' Print kmc object
#' 
#' @param x kmc object
#' @param digits minimal number of significant digits, see print.default.
f_print &lt;- function(x, digits = 5){
  cat("\n----------------------------------------------------------------\n")
  cat("A Recursive Formula for the Kaplan-Meier Estimator with Constraint\n")
  cat("Information:\n")
  cat("Number of Constraints:\t", length(x$g), "\n")
  cat("lamda(s):\t", x$lambda,'\n');
  cat("\n----------------------------------------------------------------\n")
  names &lt;- c("Log-likelihood(Ha)", "Log-likelihood(H0)",
  "-2LLR", paste("p-Value(df=", length(x$g), ")",sep = ""))
  re &lt;- matrix(c(x[[1]], x[[2]], x[[3]], 1 - pchisq(x[[3]],
  length(x$g))), nrow = 1)
  colnames(re) &lt;- names
  rownames(re) &lt;- "Est"
  print.default(format(re, digits = digits), print.gap = 2,
                quote = FALSE, df = length(x$g))
  cat("------------------------------------------------------------------\n")
}

f_print(re0)
</code></pre>

<hr>
<h2 id='plotkmc2D'>
Plot the contour plot of log-likelihood around the H0 (dim=2).
</h2><span id='topic+plotkmc2D'></span>

<h3>Description</h3>

<p>Given a kmc object, this function will produce contour plot if there were two constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotkmc2D(resultkmc, flist=list(f1=function(x){x}, f2=function(x){x^2}), 
          range0=c(0.2, 3,20))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotkmc2D_+3A_resultkmc">resultkmc</code></td>
<td>

<p>S3 Object of kmcS3.
</p>
</td></tr>
<tr><td><code id="plotkmc2D_+3A_flist">flist</code></td>
<td>
 
<p>list of two functions,flist=list( f1=function( x )  x  ,f2=function( x )  x^2  )  
</p>
</td></tr> 
<tr><td><code id="plotkmc2D_+3A_range0">range0</code></td>
<td>

<p>A vector that helps to determine the range of the contour plot, i.e (center[1]-range0[1], center[2]-range0[2]) to (center+range0[1], center[2]+range0[2]).
The third parameter defines the number of grids would be used.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>X</code></td>
<td>
<p>x.grid </p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p>y.grid </p>
</td></tr>
<tr><td><code>Z</code></td>
<td>
<p>grid value </p>
</td></tr>   
</table>


<h3>Author(s)</h3>

<p>Yifan Yang(yfyang.86@hotmail.com)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- c( 1, 1.5, 2, 3, 4.2, 5.0, 6.1, 5.3, 4.5, 0.9, 2.1, 4.3) 
d &lt;- c( 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1) 

f&lt;-function( x) { x-3.7} 

myfun5 &lt;- function( x)  { 
 x^2-16.5
} 
# construnct g as a LIST!

g=list( f1=f,f2=myfun5) ; 
kmc.solve( x,d,g) -&gt;re0;

#plotkmc2D(re0) -&gt;ZZ; # run this to generate contour plot
#Advanced PLOT option using ggplot2: not run
#library(reshape2)
#volcano3d &lt;- melt(ZZ$Z)
#names(volcano3d) &lt;- c("x", "y", "z")

#volcano3d$x &lt;- ZZ$X[volcano3d$x];
#volcano3d$y &lt;- ZZ$Y[volcano3d$y];

#### Plot: use ggplot2 ####
#library(ggplot2)
# v &lt;- ggplot(volcano3d, aes(x, y, z=z));
# v + geom_tile(aes(fill = z)) + 
#   stat_contour()+
#   scale_fill_gradientn("Custom Colours",colours=grey.colors(10));

#### Plot: use qplot ####
#qplot(x, y, z = z, data = volcano3d, stat = "contour", geom = "path")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
