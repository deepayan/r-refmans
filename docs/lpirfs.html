<!DOCTYPE html><html lang="en"><head><title>Help for package lpirfs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {lpirfs}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#lpirfs-package'><p>Local Projection Impulse Response Functions</p></a></li>
<li><a href='#ag_data'><p>Data to estimate fiscal multipliers</p></a></li>
<li><a href='#create_lags'><p>Compute a data frame with lagged exogenous variables</p></a></li>
<li><a href='#create_lin_data'><p>Compute data for linear model</p></a></li>
<li><a href='#create_nl_data'><p>Compute data for nonlinear model with instrument variable approach</p></a></li>
<li><a href='#create_panel_data'><p>Prepare data sets for linear and nonlinear panel model</p></a></li>
<li><a href='#get_mat_chol'><p>Compute structural shock matrix via Cholesky decomposition</p></a></li>
<li><a href='#get_resids_ols'><p>Compute residuals from OLS model</p></a></li>
<li><a href='#get_robust_cov_panel'><p>Function to get robust covariance matrix for panel data</p></a></li>
<li><a href='#get_robust_vcxt_panel'><p>Create and returns a function to estimate hc and clustered standard errors for panel data.</p></a></li>
<li><a href='#get_std_err'><p>Compute standard errors by standard OLS or Newey and West</p></a></li>
<li><a href='#get_std_err_tsls'><p>Compute standard errors for 2SLS</p></a></li>
<li><a href='#get_vals_lagcrit'><p>Compute values for lag length criteria</p></a></li>
<li><a href='#get_vals_switching'><p>Compute values of transition function to separate regimes</p></a></li>
<li><a href='#get_var_lagcrit'><p>Computes AICc, AIC and BIC for VAR</p></a></li>
<li><a href='#hp_filter'><p>Decompose a times series via the Hodrick-Prescott filter</p></a></li>
<li><a href='#interest_rules_var_data'><p>Data to estimate the effects of interest rate rules for monetary policy</p></a></li>
<li><a href='#lp_lin'><p>Compute linear impulse responses</p></a></li>
<li><a href='#lp_lin_iv'><p>Compute linear impulse responses with identified shock and/or with 2SLS</p></a></li>
<li><a href='#lp_lin_panel'><p>Compute linear impulse responses with local projections for panel data</p></a></li>
<li><a href='#lp_nl'><p>Compute nonlinear impulse responses</p></a></li>
<li><a href='#lp_nl_iv'><p>Compute nonlinear impulse responses with identified shock</p></a></li>
<li><a href='#lp_nl_panel'><p>Compute nonlinear impulse responses for panel data</p></a></li>
<li><a href='#lpirfs_obj-methods-base'><p>Base methods for lpirfs_obj objects</p></a></li>
<li><a href='#monetary_var_data'><p>Data to estimate a standard monetary VAR</p></a></li>
<li><a href='#newey_west'><p>Compute OLS parameters and robust standard errors based on Newey-West estimator</p></a></li>
<li><a href='#newey_west_pw'><p>Compute Newey-West estimator with prewhitened estimation functions</p></a></li>
<li><a href='#newey_west_tsls'><p>Compute 2SLS parameters and robust standard errors based on Newey-West</p></a></li>
<li><a href='#ols_diagnost'><p>Compute diagnostics for OLS models</p></a></li>
<li><a href='#plot_lin'><p>Compute and display plots of linear impulse responses</p></a></li>
<li><a href='#plot_nl'><p>Compute and display plots of nonlinear impulse responses</p></a></li>
<li><a href='#plot.lpirfs_lin_iv_obj'><p>Base print() function to plot all impulse responses from linear lpirfs object</p></a></li>
<li><a href='#plot.lpirfs_lin_obj'><p>Base print() function to plot all impulse responses from linear lpirfs object</p></a></li>
<li><a href='#plot.lpirfs_lin_panel_obj'><p>Base print() function to plot all impulse responses from linear lpirfs object</p></a></li>
<li><a href='#plot.lpirfs_nl_iv_obj'><p>Base print() function to plot all impulse responses from linear lpirfs object</p></a></li>
<li><a href='#plot.lpirfs_nl_obj'><p>Base print() function to plot all impulse responses from nonlinear lpirfs object</p></a></li>
<li><a href='#plot.lpirfs_nl_panel_obj'><p>Base print() function to plot all impulse responses from linear lpirfs object</p></a></li>
<li><a href='#summary.lpirfs_lin_iv_obj'><p>Summary for nonlinear lpirfs object</p></a></li>
<li><a href='#summary.lpirfs_lin_obj'><p>Summary for linear lpirfs object</p></a></li>
<li><a href='#summary.lpirfs_lin_panel_obj'><p>Summary for nonlinear lpirfs object</p></a></li>
<li><a href='#summary.lpirfs_nl_iv_obj'><p>Summary for nonlinear lpirfs object</p></a></li>
<li><a href='#summary.lpirfs_nl_obj'><p>Summary for nonlinear lpirfs object</p></a></li>
<li><a href='#summary.lpirfs_nl_panel_obj'><p>Summary for nonlinear lpirfs object</p></a></li>
<li><a href='#var_one'><p>Compute VAR to prewhite estimating functions for Newey West estimator.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Local Projections Impulse Response Functions</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.4</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Philipp Adämmer &lt;philipp.adaemmer@uni-greifswald.de&gt;</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/adaemmerp/lpirfs/issues">https://github.com/adaemmerp/lpirfs/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions to estimate and visualize linear as well as nonlinear impulse 
             responses based on local projections by Jordà (2005) &lt;<a href="https://doi.org/10.1257%2F0002828053828518">doi:10.1257/0002828053828518</a>&gt;.
             The methods and the package are explained in detail in Adämmer (2019) &lt;<a href="https://doi.org/10.32614%2FRJ-2019-052">doi:10.32614/RJ-2019-052</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.2)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Imports:</td>
<td>doParallel(&ge; 1.0.15), dplyr(&ge; 1.0.0), foreach(&ge; 1.5.0),
ggplot2(&ge; 3.3.0), gridExtra(&ge; 2.3), lmtest(&ge; 0.9-36), plm(&ge;
2.2-3), sandwich(&ge; 2.5-1), Rcpp(&ge; 1.0.4.6)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), AER(&ge; 1.2-12), readxl, knitr, ggpubr,
rmarkdown, zoo, vars</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-18 13:04:37 UTC; adaemmerp</td>
</tr>
<tr>
<td>Author:</td>
<td>Philipp Adämmer <a href="https://orcid.org/0000-0003-3770-0097"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  James P. LeSage [ctb],
  Mehmet Balcilar [ctb],
  Jon Danielsson [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-18 13:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='lpirfs-package'>Local Projection Impulse Response Functions</h2><span id='topic+lpirfs'></span><span id='topic+lpirfs-package'></span>

<h3>Description</h3>

<p>lpirfs provides functions to estimate and plot linear as well as nonlinear impulse
responses based on local projections by Jordà (2005) &lt;doi:10.1257/0002828053828518&gt;.
The methods and the package are explained in detail in Adämmer (2019) &lt;doi:10.32614/RJ-2019-052&gt;.
Please cite the paper when using the package.
</p>


<h3>Author(s)</h3>

<p>Philipp Adämmer
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li><p> Report bugs at <a href="https://github.com/adaemmerp/lpirfs/issues">https://github.com/adaemmerp/lpirfs/issues</a>
</p>
</li></ul>


<hr>
<h2 id='ag_data'>Data to estimate fiscal multipliers</h2><span id='topic+ag_data'></span>

<h3>Description</h3>

<p>A tibble, containing data to estimate fiscal multipliers.
This data was originally used by Auerbach and Gorodnichenko (2012).
Sarah and Zubairy (2018) use this data to re-evaluate their results with local projections.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ag_data
</code></pre>


<h3>Format</h3>

<p>A tibble with 248 quarterly observations (rows) and 7 variables (columns):
</p>

<dl>
<dt>Year</dt><dd><p>Year of observation.</p>
</dd>
<dt>Quarter</dt><dd><p>Quarter of observation.</p>
</dd>
<dt>Gov</dt><dd><p>Logs of real government (federal, state, and local) purchases (consumption and investment).</p>
</dd>
<dt>Tax</dt><dd><p>Logs of real government receipts of direct and indirect taxes net of transfers to businesses
and individuals.</p>
</dd>
<dt>GDP</dt><dd><p>Logs of real gross domestic product.</p>
</dd>
<dt>GDP_MA</dt><dd><p>7-quarter moving average growth rate of GDP.</p>
</dd>
<dt>Gov_shock_mean</dt><dd><p>Identified government spending shock. For details see Supplementary Appendix of Ramey and Zubairy (2018).</p>
</dd>
</dl>

<p>Sample: 1948:IV - 2008:IV
</p>


<h3>Source</h3>

<p><a href="https://doi.org/10.1086/696277">doi:10.1086/696277</a>
</p>


<h3>References</h3>

<p>Auerbach, A. J., and  Gorodnichenko Y. (2012). &quot;Measuring the Output Responses to Fiscal Policy.&quot;
<em>American Economic Journal: Economic Policy</em>, 4 (2): 1-27.
</p>
<p>Jordà, Ò. (2005) &quot;Estimation and Inference of Impulse Responses by Local Projections.&quot;
<em>American Economic Review</em>, 95 (1): 161-182.
</p>
<p>Ramey, V.A., Zubairy, S. (2018). &quot;Government Spending Multipliers in Good Times
and in Bad: Evidence from US Historical Data.&quot; <em>Journal of Political Economy</em>,
126(2): 850 - 901.
</p>

<hr>
<h2 id='create_lags'>Compute a data frame with lagged exogenous variables</h2><span id='topic+create_lags'></span>

<h3>Description</h3>

<p>Create a <a href="base.html#topic+data.frame">data.frame</a>() with lagged exogenous variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_lags(data, lags)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_lags_+3A_data">data</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">data.frame</a>().</p>
</td></tr>
<tr><td><code id="create_lags_+3A_lags">lags</code></td>
<td>
<p>Integer for the number of lags.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <a href="base.html#topic+data.frame">data.frame</a> with lagged values.
</p>


<h3>Author(s)</h3>

<p>Philipp Adämmer
</p>

<hr>
<h2 id='create_lin_data'>Compute data for linear model</h2><span id='topic+create_lin_data'></span>

<h3>Description</h3>

<p>Function to create data for linear model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_lin_data(specs, endog_data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_lin_data_+3A_specs">specs</code></td>
<td>
<p>A <a href="base.html#topic+list">list</a>(). Inputs are created in <a href="#topic+lp_lin_iv">lp_lin_iv</a>.</p>
</td></tr>
<tr><td><code id="create_lin_data_+3A_endog_data">endog_data</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">data.frame</a> with dependent variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with filled matrices of lagged left (y_lin) and right hand side (x_lin) variables.
</p>


<h3>Author(s)</h3>

<p>Philipp Adämmer
</p>

<hr>
<h2 id='create_nl_data'>Compute data for nonlinear model with instrument variable approach</h2><span id='topic+create_nl_data'></span>

<h3>Description</h3>

<p>Function to create data for nonlinear model with instrument variable approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_nl_data(specs, endog_data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_nl_data_+3A_specs">specs</code></td>
<td>
<p>A <a href="base.html#topic+list">list</a>(). Inputs are created in <a href="#topic+lp_nl_iv">lp_nl_iv</a>.</p>
</td></tr>
<tr><td><code id="create_nl_data_+3A_endog_data">endog_data</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">data.frame</a> with dependent variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with filled matrices of lagged left (y_nl) and right hand side (x_nl) variables.
</p>


<h3>Author(s)</h3>

<p>Philipp Adämmer
</p>

<hr>
<h2 id='create_panel_data'>Prepare data sets for linear and nonlinear panel model</h2><span id='topic+create_panel_data'></span>

<h3>Description</h3>

<p>Function to create panel data for linear and nonlinear model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_panel_data(specs, data_set)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_panel_data_+3A_specs">specs</code></td>
<td>
<p>A list with specifications created in <a href="#topic+lp_lin_panel">lp_lin_panel</a> or <a href="#topic+lp_nl_panel">lp_nl_panel</a>.</p>
</td></tr>
<tr><td><code id="create_panel_data_+3A_data_set">data_set</code></td>
<td>
<p>A data.frame consisting of a panel data set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with prepared endogenous and exogenous data as well as the updated list <em>specs</em>.
</p>

<hr>
<h2 id='get_mat_chol'>Compute structural shock matrix via Cholesky decomposition</h2><span id='topic+get_mat_chol'></span>

<h3>Description</h3>

<p>Compute structural shock matrix via Cholesky decomposition with input variables
created in <a href="#topic+lp_lin">lp_lin</a> or <a href="#topic+lp_nl">lp_nl</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_mat_chol(y_lin, x_lin, endog_data, specs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_mat_chol_+3A_y_lin">y_lin</code></td>
<td>
<p>A matrix with all endogenous variables.</p>
</td></tr>
<tr><td><code id="get_mat_chol_+3A_x_lin">x_lin</code></td>
<td>
<p>A matrix with lagged endogenous variables.</p>
</td></tr>
<tr><td><code id="get_mat_chol_+3A_endog_data">endog_data</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">data.frame</a> with all endogenous variables.</p>
</td></tr>
<tr><td><code id="get_mat_chol_+3A_specs">specs</code></td>
<td>
<p>A list with specifications from <a href="#topic+lp_lin">lp_lin</a> or <a href="#topic+lp_nl">lp_nl</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Shock matrix (d)
</p>


<h3>Author(s)</h3>

<p>Philipp Adämmer
</p>

<hr>
<h2 id='get_resids_ols'>Compute residuals from OLS model</h2><span id='topic+get_resids_ols'></span>

<h3>Description</h3>

<p>Estimate residuals from OLS model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_resids_ols(y_data, x_data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_resids_ols_+3A_y_data">y_data</code></td>
<td>
<p>A vector for the left hand variable.</p>
</td></tr>
<tr><td><code id="get_resids_ols_+3A_x_data">x_data</code></td>
<td>
<p>A matrix with right hand variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with residuals from OLS regression.
</p>


<h3>Author(s)</h3>

<p>Philipp Adämmer
</p>

<hr>
<h2 id='get_robust_cov_panel'>Function to get robust covariance matrix for panel data</h2><span id='topic+get_robust_cov_panel'></span>

<h3>Description</h3>

<p>Function to get robust covariance matrix for panel data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_robust_cov_panel(panel_results, specs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_robust_cov_panel_+3A_panel_results">panel_results</code></td>
<td>
<p>Plm object from estimation</p>
</td></tr>
<tr><td><code id="get_robust_cov_panel_+3A_specs">specs</code></td>
<td>
<p>List with specifications</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object with robust covariance matrix
</p>

<hr>
<h2 id='get_robust_vcxt_panel'>Create and returns a function to estimate hc and clustered standard errors for panel data.</h2><span id='topic+get_robust_vcxt_panel'></span>

<h3>Description</h3>

<p>Create and returns a function to estimate hc and clustered standard errors for panel data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_robust_vcxt_panel(func_name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_robust_vcxt_panel_+3A_func_name">func_name</code></td>
<td>
<p>A character.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function.
</p>


<h3>References</h3>

<p>Croissant, Y., Millo, G. (2017). &quot;Robust Standard Error Estimators for Panel Models: A Unifying Approach.&quot; <em>Journal of Statistical Software</em>, 27(2), 1-43.
<a href="https://doi.org/10.18637/jss.v082.i03">doi:10.18637/jss.v082.i03</a>.
</p>

<hr>
<h2 id='get_std_err'>Compute standard errors by standard OLS or Newey and West</h2><span id='topic+get_std_err'></span>

<h3>Description</h3>

<p>Compute standard errors by standard OLS or Newey and West (1987).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_std_err(yy, xx, lag_nw, k, specs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_std_err_+3A_yy">yy</code></td>
<td>
<p>A matrix with all endogenous variables.</p>
</td></tr>
<tr><td><code id="get_std_err_+3A_xx">xx</code></td>
<td>
<p>A matrix with lagged endogenous variables.</p>
</td></tr>
<tr><td><code id="get_std_err_+3A_lag_nw">lag_nw</code></td>
<td>
<p>Integer. Number of lags for Newey and West</p>
</td></tr>
<tr><td><code id="get_std_err_+3A_k">k</code></td>
<td>
<p>Integer. Value of column to choose from</p>
</td></tr>
<tr><td><code id="get_std_err_+3A_specs">specs</code></td>
<td>
<p>A list with specifications from <a href="#topic+lp_lin">lp_lin</a> or <a href="#topic+lp_nl">lp_nl</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List. First element contains the estimated standard errors, the second element contains the OLS point estimates.
</p>


<h3>Author(s)</h3>

<p>Philipp Adämmer
</p>

<hr>
<h2 id='get_std_err_tsls'>Compute standard errors for 2SLS</h2><span id='topic+get_std_err_tsls'></span>

<h3>Description</h3>

<p>Compute 2SLS standard errors.#'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_std_err_tsls(yy, xx, lag_nw, k, zz, specs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_std_err_tsls_+3A_yy">yy</code></td>
<td>
<p>A matrix with all endogenous variables.</p>
</td></tr>
<tr><td><code id="get_std_err_tsls_+3A_xx">xx</code></td>
<td>
<p>A matrix with lagged endogenous variables.</p>
</td></tr>
<tr><td><code id="get_std_err_tsls_+3A_lag_nw">lag_nw</code></td>
<td>
<p>Integer. Number of lags for Newey and West</p>
</td></tr>
<tr><td><code id="get_std_err_tsls_+3A_k">k</code></td>
<td>
<p>Integer. Value of column to choose from</p>
</td></tr>
<tr><td><code id="get_std_err_tsls_+3A_specs">specs</code></td>
<td>
<p>A list with specifications from <a href="#topic+lp_lin">lp_lin</a> or <a href="#topic+lp_nl">lp_nl</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List. First element contains the estimated standard errors, the second element contains the OLS point estimates.
</p>


<h3>Author(s)</h3>

<p>Philipp Adämmer
</p>

<hr>
<h2 id='get_vals_lagcrit'>Compute values for lag length criteria</h2><span id='topic+get_vals_lagcrit'></span>

<h3>Description</h3>

<p>Compute values for 'AICc', 'AIC', or 'BIC'.
</p>
<p>Schwarz, Gideon E. (1978). &quot;Estimating the dimension of a model&quot;, <em>Annals of Statistics</em>, 6 (2): 461–464.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_vals_lagcrit(y, x, lag_crit, h, k, max_lags, n_obs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_vals_lagcrit_+3A_y">y</code></td>
<td>
<p>List with left (endogenous) variables.</p>
</td></tr>
<tr><td><code id="get_vals_lagcrit_+3A_x">x</code></td>
<td>
<p>List with right (exogenous) variables.</p>
</td></tr>
<tr><td><code id="get_vals_lagcrit_+3A_lag_crit">lag_crit</code></td>
<td>
<p>Integer: 'AICc'= 1, 'AIC' = 2, 'BIC' = 3.</p>
</td></tr>
<tr><td><code id="get_vals_lagcrit_+3A_h">h</code></td>
<td>
<p>Integer.</p>
</td></tr>
<tr><td><code id="get_vals_lagcrit_+3A_k">k</code></td>
<td>
<p>Integer.</p>
</td></tr>
<tr><td><code id="get_vals_lagcrit_+3A_max_lags">max_lags</code></td>
<td>
<p>Integer.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Akaike, H. (1974). &quot;A new look at the statistical model identification&quot;, <em>IEEE Transactions on Automatic Control</em>, 19 (6): 716–723.
</p>

<hr>
<h2 id='get_vals_switching'>Compute values of transition function to separate regimes</h2><span id='topic+get_vals_switching'></span>

<h3>Description</h3>

<p>Computes transition values by using a smooth transition function as
used in Auerbach and Gorodnichenko (2012). The time series used in the transition function
can be detrended via the Hodrick-Prescott filter (see Auerbach and Gorodnichenko, 2013).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_vals_switching(data_set, specs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_vals_switching_+3A_data_set">data_set</code></td>
<td>
<p>A numeric vector or a panel data set, depending on the model to estimate.</p>
</td></tr>
<tr><td><code id="get_vals_switching_+3A_specs">specs</code></td>
<td>
<p>A <a href="base.html#topic+list">list</a> with inputs as in <a href="#topic+lp_nl">lp_nl</a>().</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>fz</code></td>
<td>
<p>A numeric vector with values from the smooth transition function <code class="reqn">F(z_{t-1})</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Philipp Adämmer
</p>


<h3>References</h3>

<p>Auerbach, A. J., and  Gorodnichenko Y. (2012). &quot;Measuring the Output Responses to Fiscal Policy.&quot;
<em>American Economic Journal: Economic Policy</em>, 4 (2): 1-27.
</p>
<p>Auerbach, A. J., and Gorodnichenko Y. (2013). &quot;Fiscal Multipliers in Recession and Expansion.&quot;
<em>NBER Working Paper Series</em>. Nr 17447.
</p>

<hr>
<h2 id='get_var_lagcrit'>Computes AICc, AIC and BIC for VAR</h2><span id='topic+get_var_lagcrit'></span>

<h3>Description</h3>

<p>Computes AICc, AIC and BIC for VAR models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_var_lagcrit(endog_data, specs = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_var_lagcrit_+3A_endog_data">endog_data</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">data.frame</a> with endogenous variables for the VAR</p>
</td></tr>
<tr><td><code id="get_var_lagcrit_+3A_specs">specs</code></td>
<td>
<p>A <a href="base.html#topic+list">list</a> created in <a href="#topic+lp_lin">lp_lin</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with lag length criteria
</p>


<h3>References</h3>

<p>Akaike, H. (1974). &quot;A new look at the statistical model identification&quot;,
<em>IEEE Transactions on Automatic Control</em>, 19 (6): 716–723.
</p>
<p>Hamilton, J. D. (1994). &quot;Time Series Analysis.&quot;
Princeton: Princeton University Press.
</p>
<p>Hurvich, C. M., and Tsai, C.-L. (1989), &quot;Regression and time series model selection in small samples&quot;,
<em>Biometrika</em>, 76(2): 297–307
</p>
<p>Lütkepohl, H. (2005). &quot;New Introduction to Multiple Time Series Analysis.&quot;,
New York: Springer.
</p>
<p>Schwarz, Gideon E. (1978). &quot;Estimating the dimension of a model&quot;,
<em>Annals of Statistics</em>, 6 (2): 461–464.
</p>

<hr>
<h2 id='hp_filter'>Decompose a times series via the Hodrick-Prescott filter</h2><span id='topic+hp_filter'></span>

<h3>Description</h3>

<p>Estimate cyclical and trend component with filter by Hodrick and Prescott (1997).
The function is based on the function <em>hpfilter</em> from the archived <em>mFilter</em>-package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hp_filter(x, lambda)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hp_filter_+3A_x">x</code></td>
<td>
<p>One column matrix with numeric values.</p>
</td></tr>
<tr><td><code id="hp_filter_+3A_lambda">lambda</code></td>
<td>
<p>Numeric value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list. The first element contains the cyclical component and the second element the trend component.
</p>


<h3>Author(s)</h3>

<p>Philipp Adämmer
</p>


<h3>References</h3>

<p>Hodrick, R.J., and Prescott, E. C. (1997). &quot;Postwar U.S. Business Cycles: An Empirical Investigation.&quot;
<em>Journal of Money, Credit and Banking</em>, 29(1), 1-16.
</p>
<p>Ravn, M.O., Uhlig, H. (2002). &quot;On Adjusting the Hodrick-Prescott Filter for the Frequency of Observations.&quot;
<em>Review of Economics and Statistics</em>, 84(2), 371-376.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(lpirfs)


# Decompose the Federal Funds Rate
 data_set     &lt;- as.matrix(interest_rules_var_data$FF)
 hp_results   &lt;- hp_filter(data_set, 1600)

# Extract results and save as data.frame
 hp_cyc    &lt;- as.data.frame(hp_results[[1]])
 hp_trend  &lt;- as.data.frame(hp_results[[2]])

# Make data.frames for plots
 cyc_df     &lt;- data.frame(yy = hp_cyc$V1,   xx = seq(as.Date('1955-01-01'),
                            as.Date('2003-01-01') , "quarter"))
 trend_df   &lt;- data.frame(yy = hp_trend$V1, xx = seq(as.Date('1955-01-01'),
                            as.Date('2003-01-01') , "quarter"))

# Make plots
 library(ggplot2)

# Plot cyclical part
 ggplot(data = cyc_df) +
 geom_line(aes(y = yy, x = xx))

# Plot trend component
 ggplot(trend_df) +
 geom_line(aes(y = yy, x = xx))


</code></pre>

<hr>
<h2 id='interest_rules_var_data'>Data to estimate the effects of interest rate rules for monetary policy</h2><span id='topic+interest_rules_var_data'></span>

<h3>Description</h3>

<p>A tibble, containing data to estimate the effects of interest rate rules for monetary policy.
The data are used by Jordà (2005).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interest_rules_var_data
</code></pre>


<h3>Format</h3>

<p>A tibble with 193 quarterly observations (rows) and 3 variables (columns):
</p>

<dl>
<dt>GDP_gap</dt><dd><p>Percentage difference between real GDP and potential GDP (Congressional Budget Office).</p>
</dd>
<dt>Infl</dt><dd><p>Inflation: Percentage change in the GDP, chain weighted price index at annual rate.</p>
</dd>
<dt>FF</dt><dd><p>Federal funds rate: quarterly average of daily rates.</p>
</dd>
</dl>

<p>Sample: 1955:I - 2003:I
</p>


<h3>Source</h3>

<p><a href="https://www.aeaweb.org/articles?id=10.1257/0002828053828518">https://www.aeaweb.org/articles?id=10.1257/0002828053828518</a>
</p>


<h3>References</h3>

<p>Jordà, Ò. (2005) &quot;Estimation and Inference of Impulse Responses by Local Projections.&quot;
<em>American Economic Review</em>, 95 (1): 161-182.
</p>

<hr>
<h2 id='lp_lin'>Compute linear impulse responses</h2><span id='topic+lp_lin'></span>

<h3>Description</h3>

<p>Compute linear impulse responses with local projections by Jordà (2005).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lp_lin(
  endog_data,
  lags_endog_lin = NULL,
  lags_criterion = NaN,
  max_lags = NaN,
  trend = NULL,
  shock_type = NULL,
  confint = NULL,
  use_nw = TRUE,
  nw_lag = NULL,
  nw_prewhite = FALSE,
  adjust_se = FALSE,
  hor = NULL,
  exog_data = NULL,
  lags_exog = NULL,
  contemp_data = NULL,
  num_cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lp_lin_+3A_endog_data">endog_data</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">data.frame</a>, containing the endogenous variables for the VAR. The Cholesky decomposition is based on the
column order.</p>
</td></tr>
<tr><td><code id="lp_lin_+3A_lags_endog_lin">lags_endog_lin</code></td>
<td>
<p>NaN or integer. NaN if lag length criterion is used. Integer for number of lags for <em>endog_data</em>.</p>
</td></tr>
<tr><td><code id="lp_lin_+3A_lags_criterion">lags_criterion</code></td>
<td>
<p>NaN or character. NaN (default) means that the number of lags
has to be given at <em>lags_endog_lin</em>. The character specifies the lag length criterion ('AICc', 'AIC' or 'BIC').</p>
</td></tr>
<tr><td><code id="lp_lin_+3A_max_lags">max_lags</code></td>
<td>
<p>NaN or integer. Maximum number of lags if <em>lags_criterion</em> is given. NaN (default) otherwise.</p>
</td></tr>
<tr><td><code id="lp_lin_+3A_trend">trend</code></td>
<td>
<p>Integer. No trend =  0 , include trend = 1, include trend and quadratic trend = 2.</p>
</td></tr>
<tr><td><code id="lp_lin_+3A_shock_type">shock_type</code></td>
<td>
<p>Integer. Standard deviation shock = 0, unit shock = 1.</p>
</td></tr>
<tr><td><code id="lp_lin_+3A_confint">confint</code></td>
<td>
<p>Double. Width of confidence bands. 68% = 1; 90% = 1.65; 95% = 1.96.</p>
</td></tr>
<tr><td><code id="lp_lin_+3A_use_nw">use_nw</code></td>
<td>
<p>Boolean. Use Newey-West (1987) standard errors for impulse responses? TRUE (default) or FALSE.</p>
</td></tr>
<tr><td><code id="lp_lin_+3A_nw_lag">nw_lag</code></td>
<td>
<p>Integer. Specifies the maximum lag with positive weight for the Newey-West estimator. If set to NULL (default), the lag increases with
with the number of horizon.</p>
</td></tr>
<tr><td><code id="lp_lin_+3A_nw_prewhite">nw_prewhite</code></td>
<td>
<p>Boolean. Should the estimators be pre-whitened? TRUE or FALSE (default).</p>
</td></tr>
<tr><td><code id="lp_lin_+3A_adjust_se">adjust_se</code></td>
<td>
<p>Boolen. Should a finite sample adjsutment be made to the covariance matrix estimators? TRUE or FALSE (default).</p>
</td></tr>
<tr><td><code id="lp_lin_+3A_hor">hor</code></td>
<td>
<p>Integer. Number of horizons for impulse responses.</p>
</td></tr>
<tr><td><code id="lp_lin_+3A_exog_data">exog_data</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">data.frame</a>, containing exogenous variables for the VAR. The row length has to be the same as <em>endog_data</em>.
Lag lengths for exogenous variables have to be given and will not be determined via a lag length criterion.</p>
</td></tr>
<tr><td><code id="lp_lin_+3A_lags_exog">lags_exog</code></td>
<td>
<p>NULL or Integer. Integer for the number of lags for the exogenous data. The value cannot be 0. If you want to
to include exogenous data with contemporaneous impact use <em>contemp_data</em>.</p>
</td></tr>
<tr><td><code id="lp_lin_+3A_contemp_data">contemp_data</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">data.frame</a>, containing exogenous data with contemporaneous impact. This data will not be lagged.
The row length has to be the same as <em>endog_data</em>.</p>
</td></tr>
<tr><td><code id="lp_lin_+3A_num_cores">num_cores</code></td>
<td>
<p>NULL or Integer. The number of cores to use for the estimation. If NULL, the function will
use the maximum number of cores minus one.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>irf_lin_mean</code></td>
<td>
<p>A three 3D <a href="base.html#topic+array">array</a>, containing all impulse responses for all endogenous variables.
The last dimension denotes the shock variable. The row in each matrix
gives the responses of the <em>ith</em> variable, ordered as in endog_data. The columns denote the horizons.
For example, if <em>results_lin</em> contains the list with results, results_lin$irf_lin_mean[, , 1] returns a KXH matrix,
where K is the number of variables and H the number of horizons. '1' is the shock variable, corresponding to the
first variable in <em>endog_data</em>.</p>
</td></tr>
<tr><td><code>irf_lin_low</code></td>
<td>
<p>A three 3D <a href="base.html#topic+array">array</a> containing all lower confidence bands of the responses,
based on robust standard errors by Newey and West (1987). Properties are equal to irf_lin_mean.</p>
</td></tr>
<tr><td><code>irf_lin_up</code></td>
<td>
<p>A three 3D <a href="base.html#topic+array">array</a> containing all upper confidence bands of the responses,
based on robust standard errors by Newey and West (1987). Properties are equal to <em>irf_lin_mean</em>.</p>
</td></tr>
<tr><td><code>diagnostic_list</code></td>
<td>
<p>A list OLS diagnostics. To see everything you can simply use summary() or results$diagnostic_list. The first entry
the shock variable. The rows of each shown matrix then denotes the endogenous variable that reacts to the shock.</p>
</td></tr>
<tr><td><code>specs</code></td>
<td>
<p>A list with properties of <em>endog_data</em> for the plot function. It also contains
lagged data (y_lin and x_lin) used for the irf estimations, and the selected lag lengths when an information criterion has been used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Philipp Adämmer
</p>


<h3>References</h3>

<p>Akaike, H. (1974). &quot;A new look at the statistical model identification&quot;, <em>IEEE Transactions on Automatic Control</em>, 19 (6): 716–723.
</p>
<p>Hurvich, C. M., and Tsai, C.-L. (1989), &quot;Regression and time series model selection in small samples&quot;,
<em>Biometrika</em>, 76(2): 297–307
</p>
<p>Jordà, Ò. (2005). &quot;Estimation and Inference of Impulse Responses by Local Projections.&quot;
<em>American Economic Review</em>, 95 (1): 161-182.
</p>
<p>Newey, W.K., and West, K.D. (1987). “A Simple, Positive-Definite, Heteroskedasticity and
Autocorrelation Consistent Covariance Matrix.” <em>Econometrica</em>, 55: 703–708.
</p>
<p>Schwarz, Gideon E. (1978). &quot;Estimating the dimension of a model&quot;, <em>Annals of Statistics</em>, 6 (2): 461–464.
</p>


<h3>See Also</h3>

<p><a href="https://adaemmerp.github.io/lpirfs/README_docs.html">https://adaemmerp.github.io/lpirfs/README_docs.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
          ## Example without exogenous variables

# Load package
  library(lpirfs)

# Load (endogenous) data
  endog_data &lt;- interest_rules_var_data

# Estimate linear model
  results_lin &lt;- lp_lin(endog_data,
                             lags_endog_lin = 4,
                             trend          = 0,
                             shock_type     = 1,
                             confint        = 1.96,
                             hor            = 12)

# Show all impule responses
# Compare with Figure 5 in Jordà (2005)
 plot(results_lin)

# Make individual plots
 linear_plots &lt;- plot_lin(results_lin)

# Show single plots
 # * The first element of 'linear_plots' shows the response of the first
 #   variable (GDP_gap) to a shock in the first variable (GDP_gap).
 # * The second element of 'linear_plots' shows the response of the first
 #   variable (GDP_gap) to a shock in the second variable (inflation).
 # * ...

  linear_plots[[1]]
  linear_plots[[2]]


# Show diagnostics. The first element correponds to the first shock variable.
 summary(results_lin)


                      ## Example with exogenous variables ##

# Load (endogenous) data
 endog_data &lt;- interest_rules_var_data

# Create exogenous data and data with contemporaneous impact (for illustration purposes only)
 exog_data    &lt;- endog_data$GDP_gap*endog_data$Infl*endog_data$FF + rnorm(dim(endog_data)[1])
 contemp_data &lt;- endog_data$GDP_gap*endog_data$Infl*endog_data$FF + rnorm(dim(endog_data)[1])

# Exogenous data has to be a data.frame
 exog_data    &lt;- data.frame(xx = exog_data )
 contemp_data &lt;- data.frame(cc =  contemp_data)

# Estimate linear model
  results_lin &lt;- lp_lin(endog_data,
                               lags_endog_lin = 4,
                               trend          = 0,
                               shock_type     = 1,
                               confint        = 1.96,
                               hor            = 12,
                               exog_data      = exog_data,
                               lags_exog      = 4,
                               contemp_data   = contemp_data)

# Show all impulse responses
 plot(results_lin)

# Show diagnostics. The first element correponds to the first shock variable.
 summary(results_lin)

 
</code></pre>

<hr>
<h2 id='lp_lin_iv'>Compute linear impulse responses with identified shock and/or with 2SLS</h2><span id='topic+lp_lin_iv'></span>

<h3>Description</h3>

<p>Compute linear impulse responses with identified shock and/or with 2SLS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lp_lin_iv(
  endog_data,
  shock = NULL,
  cumul_mult = FALSE,
  instr = NULL,
  use_twosls = FALSE,
  instrum = NULL,
  lags_endog_lin = NULL,
  exog_data = NULL,
  lags_exog = NULL,
  contemp_data = NULL,
  lags_criterion = NaN,
  max_lags = NaN,
  trend = NULL,
  confint = NULL,
  use_nw = TRUE,
  nw_lag = NULL,
  nw_prewhite = FALSE,
  adjust_se = FALSE,
  hor = NULL,
  num_cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lp_lin_iv_+3A_endog_data">endog_data</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">data.frame</a>, containing the values of the dependent variable(s).</p>
</td></tr>
<tr><td><code id="lp_lin_iv_+3A_shock">shock</code></td>
<td>
<p>A one column <a href="base.html#topic+data.frame">data.frame</a>, including the variable to shock with. The row length has to be the same as <em>endog_data</em>.
When <em>use_twosls = TRUE</em>, this variable will be approximated/regressed on the instrument variable(s) given in <em>instrum</em>.</p>
</td></tr>
<tr><td><code id="lp_lin_iv_+3A_cumul_mult">cumul_mult</code></td>
<td>
<p>Boolean. Estimate cumulative multipliers? TRUE or FALSE (default). If TRUE, cumulative responses
are estimated via: </p>
<p style="text-align: center;"><code class="reqn">y_{(t+h)} - y_{(t-1)},</code>
</p>
<p> where h = 0,..., H-1.
This option is only available for <em>lags_criterion = NaN</em>.</p>
</td></tr>
<tr><td><code id="lp_lin_iv_+3A_instr">instr</code></td>
<td>
<p>Deprecated input name. Use <em>shock</em> instead. See <em>shock</em> for details.</p>
</td></tr>
<tr><td><code id="lp_lin_iv_+3A_use_twosls">use_twosls</code></td>
<td>
<p>Boolean. Use two stage least squares? TRUE or FALSE (default).</p>
</td></tr>
<tr><td><code id="lp_lin_iv_+3A_instrum">instrum</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">data.frame</a>, containing the instrument(s) to use for 2SLS. This instrument will be used for the
variable in <em>shock</em>.</p>
</td></tr>
<tr><td><code id="lp_lin_iv_+3A_lags_endog_lin">lags_endog_lin</code></td>
<td>
<p>NaN or integer. NaN if lags are chosen by a lag length criterion. Integer for number of lags for <em>endog_data</em>.</p>
</td></tr>
<tr><td><code id="lp_lin_iv_+3A_exog_data">exog_data</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">data.frame</a>, containing exogenous variables. The row length has to be the same as <em>endog_data</em>.
Lag lengths for exogenous variables have to be given and will not be determined via a lag length criterion.</p>
</td></tr>
<tr><td><code id="lp_lin_iv_+3A_lags_exog">lags_exog</code></td>
<td>
<p>NULL or Integer. Integer for the number of lags for the exogenous data. The value cannot be 0. If you want to
to include exogenous data with contemporaneous impact use 'contemp_data'.</p>
</td></tr>
<tr><td><code id="lp_lin_iv_+3A_contemp_data">contemp_data</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">data.frame</a>, containing exogenous data with contemporaneous impact.
The row length has to be the same as <em>endog_data</em>.</p>
</td></tr>
<tr><td><code id="lp_lin_iv_+3A_lags_criterion">lags_criterion</code></td>
<td>
<p>NaN or character. NaN means that the number of lags
will be given at <em>lags_endog_lin</em>. Possible lag length criteria are 'AICc', 'AIC' or 'BIC'.
Note that when <em>use_twosls = TRUE</em>, the lag lengths are chosen based on normal OLS regressions, without using the instruments.</p>
</td></tr>
<tr><td><code id="lp_lin_iv_+3A_max_lags">max_lags</code></td>
<td>
<p>NaN or integer. Maximum number of lags if <em>lags_criterion</em> is a character denoting the lag length criterion. NaN otherwise.</p>
</td></tr>
<tr><td><code id="lp_lin_iv_+3A_trend">trend</code></td>
<td>
<p>Integer. No trend =  0 , include trend = 1, include trend and quadratic trend = 2.</p>
</td></tr>
<tr><td><code id="lp_lin_iv_+3A_confint">confint</code></td>
<td>
<p>Double. Width of confidence bands. 68% = 1; 90% = 1.65; 95% = 1.96.</p>
</td></tr>
<tr><td><code id="lp_lin_iv_+3A_use_nw">use_nw</code></td>
<td>
<p>Boolean. Use Newey-West (1987) standard errors for impulse responses? TRUE (default) or FALSE.</p>
</td></tr>
<tr><td><code id="lp_lin_iv_+3A_nw_lag">nw_lag</code></td>
<td>
<p>Integer. Specifies the maximum lag with positive weight for the Newey-West estimator. If set to NULL (default), the lag increases with
with the number of horizon.</p>
</td></tr>
<tr><td><code id="lp_lin_iv_+3A_nw_prewhite">nw_prewhite</code></td>
<td>
<p>Boolean. Should the estimators be pre-whitened? TRUE of FALSE (default).</p>
</td></tr>
<tr><td><code id="lp_lin_iv_+3A_adjust_se">adjust_se</code></td>
<td>
<p>Boolen. Should a finite sample adjsutment be made to the covariance matrix estimators? TRUE or FALSE (default).</p>
</td></tr>
<tr><td><code id="lp_lin_iv_+3A_hor">hor</code></td>
<td>
<p>Integer. Number of horizons for impulse responses.</p>
</td></tr>
<tr><td><code id="lp_lin_iv_+3A_num_cores">num_cores</code></td>
<td>
<p>NULL or Integer. The number of cores to use for the estimation. If NULL, the function will
use the maximum number of cores minus one.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>irf_lin_mean</code></td>
<td>
<p>A <a href="base.html#topic+matrix">matrix</a>, containing the impulse responses.
The row in each matrix denotes the response of the <em>ith</em>
variable to the shock. The columns are the horizons.</p>
</td></tr>
<tr><td><code>irf_lin_low</code></td>
<td>
<p>A <a href="base.html#topic+matrix">matrix</a>, containing all lower confidence bands of
the impulse responses, based on robust standard errors by Newey and West (1987).
Properties are equal to <em>irf_lin_mean</em>.</p>
</td></tr>
<tr><td><code>irf_lin_up</code></td>
<td>
<p>A <a href="base.html#topic+matrix">matrix</a>, containing all upper confidence bands of
the impulse responses, based on robust standard errors by Newey and West (1987).
Properties are equal to <em>irf_lin_mean</em>.</p>
</td></tr>
<tr><td><code>specs</code></td>
<td>
<p>A list with properties of <em>endog_data</em> for the plot function. It also contains
lagged data (y_lin and x_lin) used for the estimations of the impulse responses, and the selected lag lengths when an information criterion has been used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Philipp Adämmer
</p>


<h3>References</h3>

<p>Akaike, H. (1974). &quot;A new look at the statistical model identification&quot;, <em>IEEE Transactions on Automatic Control</em>, 19 (6): 716–723.
</p>
<p>Auerbach, A. J., and  Gorodnichenko, Y. (2012). &quot;Measuring the Output Responses to Fiscal Policy.&quot;
<em>American Economic Journal: Economic Policy</em>, 4 (2): 1-27.
</p>
<p>Blanchard, O., and Perotti, R. (2002). “An Empirical Characterization of the
Dynamic Effects of Changes in Government Spending and Taxes on Output.” <em>Quarterly
Journal of Economics</em>, 117(4): 1329–1368.
</p>
<p>Hurvich, C. M., and  Tsai, C.-L. (1989), &quot;Regression and time series model selection in small samples&quot;,
<em>Biometrika</em>, 76(2): 297–307
</p>
<p>Jordà, Ò. (2005). &quot;Estimation and Inference of Impulse Responses by Local Projections.&quot;
<em>American Economic Review</em>, 95 (1): 161-182.
</p>
<p>Jordà, Ò, Schularick, M., Taylor, A.M. (2015), &quot;Betting the house&quot;, <em>Journal of International Economics</em>,
96, S2-S18.
</p>
<p>Newey, W.K., and West, K.D. (1987). “A Simple, Positive-Definite, Heteroskedasticity and
Autocorrelation Consistent Covariance Matrix.” <em>Econometrica</em>, 55: 703–708.
</p>
<p>Ramey, V.A., and Zubairy, S. (2018). &quot;Government Spending Multipliers in Good Times
and in Bad: Evidence from US Historical Data.&quot; <em>Journal of Political Economy</em>,
126(2): 850 - 901.
</p>
<p>Schwarz, Gideon E. (1978). &quot;Estimating the dimension of a model&quot;, <em>Annals of Statistics</em>, 6 (2): 461–464.
</p>


<h3>See Also</h3>

<p><a href="https://adaemmerp.github.io/lpirfs/README_docs.html">https://adaemmerp.github.io/lpirfs/README_docs.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# This example replicates a result from the Supplementary Appendix
# by Ramey and Zubairy (2018) (RZ-18)

# Load data
 ag_data       &lt;- ag_data
 sample_start  &lt;- 7
 sample_end    &lt;- dim(ag_data)[1]

# Endogenous data
 endog_data    &lt;- ag_data[sample_start:sample_end,3:5]

# Variable to shock with. Here government spending due to
# Blanchard and Perotti (2002) framework
 shock         &lt;- ag_data[sample_start:sample_end, 3]

# Estimate linear model
 results_lin_iv &lt;- lp_lin_iv(endog_data,
                               lags_endog_lin = 4,
                               shock          = shock,
                               trend          = 0,
                               confint        = 1.96,
                               hor            = 20)

# Show all impulse responses
 plot(results_lin_iv)

# Make and save plots
 iv_lin_plots    &lt;- plot_lin(results_lin_iv)

# * The first element of 'iv_lin_plots' shows the response of the first
#   variable (Gov) to the  shock (Gov).
# * The second element of 'iv_lin_plots' shows the response of the second
#   variable (Tax) to the shock (Gov).
# * ...

# This plot replicates the left plot in the mid-panel of Figure 12 in the
# Supplementary Appendix by RZ-18.
 iv_lin_plots[[1]]


# Show diagnostics. The first element shows the reaction of the first given endogenous variable.
 summary(results_lin_iv)


## Add lags of the identified shock ##

# Endogenous data but now exclude government spending
 endog_data    &lt;- ag_data[sample_start:sample_end, 4:5]

# Variable to shock with (government spending)
 shock         &lt;- ag_data[sample_start:sample_end, 3]

# Add the shock variable to exogenous data
 exog_data     &lt;- shock

# Estimate linear model with lagged shock variable
 results_lin_iv &lt;- lp_lin_iv(endog_data,
                               lags_endog_lin = 4,
                               shock          = shock,
                               exog_data      = exog_data,
                               lags_exog      = 2,
                               trend          = 0,
                               confint        = 1.96,
                               hor            = 20)


# Show all responses
 plot(results_lin_iv)

# Show diagnostics. The first element shows the reaction of the first endogenous variable.
 summary(results_lin_iv)


##############################################################################
#####                         Use 2SLS                               #########
##############################################################################

# Set seed
 set.seed(007)

# Load data
 ag_data       &lt;- ag_data
 sample_start  &lt;- 7
 sample_end    &lt;- dim(ag_data)[1]

# Endogenous data
 endog_data    &lt;- ag_data[sample_start:sample_end,3:5]

# Variable to shock with (government spending)
 shock         &lt;- ag_data[sample_start:sample_end, 3]

# Generate instrument variable that is correlated with government spending
 instrum       &lt;- as.data.frame(0.9*shock$Gov + rnorm(length(shock$Gov), 0, 0.02) )

# Estimate linear model via 2SLS
 results_lin_iv &lt;- lp_lin_iv(endog_data,
                            lags_endog_lin = 4,
                            shock          = shock,
                            instrum        = instrum,
                            use_twosls     = TRUE,
                            trend          = 0,
                            confint        = 1.96,
                            hor            = 20)

# Show all responses
 plot(results_lin_iv)




</code></pre>

<hr>
<h2 id='lp_lin_panel'>Compute linear impulse responses with local projections for panel data</h2><span id='topic+lp_lin_panel'></span>

<h3>Description</h3>

<p>This function estimates impulse responses with local projections
for panel data, either with an
identified shock or by an instrument variable approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lp_lin_panel(
  data_set = NULL,
  data_sample = "Full",
  endog_data = NULL,
  cumul_mult = TRUE,
  shock = NULL,
  diff_shock = TRUE,
  iv_reg = FALSE,
  instrum = NULL,
  panel_model = "within",
  panel_effect = "individual",
  robust_cov = NULL,
  robust_method = NULL,
  robust_type = NULL,
  robust_cluster = NULL,
  robust_maxlag = NULL,
  use_gmm = FALSE,
  gmm_model = "onestep",
  gmm_effect = "twoways",
  gmm_transformation = "d",
  c_exog_data = NULL,
  l_exog_data = NULL,
  lags_exog_data = NaN,
  c_fd_exog_data = NULL,
  l_fd_exog_data = NULL,
  lags_fd_exog_data = NaN,
  confint = NULL,
  hor = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lp_lin_panel_+3A_data_set">data_set</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">data.frame</a>, containing the panel data set. The first column has to be the
variable denoting the cross section. The second column has to be the
variable denoting the time section.</p>
</td></tr>
<tr><td><code id="lp_lin_panel_+3A_data_sample">data_sample</code></td>
<td>
<p>Character or numeric. To use the full sample set value to &quot;Full&quot; (default). To estimate a subset, you have to provide
a sequence of dates. This sequence has to be in the same format as the second column (time-section).</p>
</td></tr>
<tr><td><code id="lp_lin_panel_+3A_endog_data">endog_data</code></td>
<td>
<p>Character. The column name of the endogenous variable. You can only provide one endogenous variable at a time.</p>
</td></tr>
<tr><td><code id="lp_lin_panel_+3A_cumul_mult">cumul_mult</code></td>
<td>
<p>Boolean. Estimate cumulative multipliers? TRUE (default) or FALSE. If TRUE, cumulative responses
are estimated via: </p>
<p style="text-align: center;"><code class="reqn">y_{(t+h)} - y_{(t-1)},</code>
</p>
<p> where h = 0,..., H-1.</p>
</td></tr>
<tr><td><code id="lp_lin_panel_+3A_shock">shock</code></td>
<td>
<p>Character. The column name of the variable to shock with.</p>
</td></tr>
<tr><td><code id="lp_lin_panel_+3A_diff_shock">diff_shock</code></td>
<td>
<p>Boolean. Take first differences of the shock variable? TRUE (default) or FALSE. Note
that when using this option both shock and instrument are used in first differences</p>
</td></tr>
<tr><td><code id="lp_lin_panel_+3A_iv_reg">iv_reg</code></td>
<td>
<p>Boolean. Use instrument variable approach? TRUE or FALSE.</p>
</td></tr>
<tr><td><code id="lp_lin_panel_+3A_instrum">instrum</code></td>
<td>
<p>NULL or Character. The name(s) of the instrument variable(s) if iv_reg = TRUE.</p>
</td></tr>
<tr><td><code id="lp_lin_panel_+3A_panel_model">panel_model</code></td>
<td>
<p>Character. Type of panel model. The default is &quot;within&quot; (fixed effects). Other options are &quot;random&quot;, &quot;ht&quot;,
&quot;between&quot;, &quot;pooling&quot; or &quot;fd&quot;. See vignette of the plm package for details.</p>
</td></tr>
<tr><td><code id="lp_lin_panel_+3A_panel_effect">panel_effect</code></td>
<td>
<p>Character. The effects introduced in the model. Options are &quot;individual&quot; (default), &quot;time&quot;, &quot;twoways&quot;,
or &quot;nested&quot;. See the vignette of the plm-package for details.</p>
</td></tr>
<tr><td><code id="lp_lin_panel_+3A_robust_cov">robust_cov</code></td>
<td>
<p>NULL or Character. The character specifies the method how to estimate robust standard errors: Options are &quot;vcovBK&quot;, &quot;vcovDC&quot;,
&quot;vcovG&quot;, &quot;vcovHC&quot;, &quot;vcovNW&quot;, &quot;vcovSCC&quot;. For these options see vignette of plm package. Another option is &quot;Vcxt&quot;. For details see Miller (2017)
If &quot;use_gmm = TRUE&quot;, this option has to be NULL.</p>
</td></tr>
<tr><td><code id="lp_lin_panel_+3A_robust_method">robust_method</code></td>
<td>
<p>NULL (default) or Character. The character is an option when robust_cov = &quot;vcovHC&quot;. See vignette of the plm package for details.</p>
</td></tr>
<tr><td><code id="lp_lin_panel_+3A_robust_type">robust_type</code></td>
<td>
<p>NULL (default) or Character. The character is an option when robust_cov  = &quot;vcovBK&quot;, &quot;vcovDC&quot;, &quot;vcovHC&quot;, &quot;vcovNW&quot; or &quot;vcovSCC&quot;. See vignette of the plm package for details.</p>
</td></tr>
<tr><td><code id="lp_lin_panel_+3A_robust_cluster">robust_cluster</code></td>
<td>
<p>NULL (default) or Character. The character is an option when robust_cov = &quot;vcovBK&quot;, &quot;vcovG&quot; or &quot;vcovHC&quot;. See vignette of the plm package for details.</p>
</td></tr>
<tr><td><code id="lp_lin_panel_+3A_robust_maxlag">robust_maxlag</code></td>
<td>
<p>NULL (default) or Character. The character is an option when robust_cov  = &quot;vcovNW&quot; or &quot;vcovSCC&quot;. See vignette of the plm package for details.</p>
</td></tr>
<tr><td><code id="lp_lin_panel_+3A_use_gmm">use_gmm</code></td>
<td>
<p>Boolean. Use GMM for estimation? TRUE or FALSE (default). See vignette of plm package for details.
If TRUE, the option &quot;robust_cov&quot; has to be set to NULL.</p>
</td></tr>
<tr><td><code id="lp_lin_panel_+3A_gmm_model">gmm_model</code></td>
<td>
<p>Character. Either &quot;onestep&quot; (default) or &quot;twosteps&quot;. See vignette of the plm package for details.</p>
</td></tr>
<tr><td><code id="lp_lin_panel_+3A_gmm_effect">gmm_effect</code></td>
<td>
<p>Character. The effects introduced in the model: &quot;twoways&quot; (default) or &quot;individual&quot;. See vignette of the plm-package for details.</p>
</td></tr>
<tr><td><code id="lp_lin_panel_+3A_gmm_transformation">gmm_transformation</code></td>
<td>
<p>Character. Either &quot;d&quot; (default) for the &quot;difference GMM&quot; model or &quot;ld&quot; for the &quot;system GMM&quot;.
See vignette of the plm package for details.</p>
</td></tr>
<tr><td><code id="lp_lin_panel_+3A_c_exog_data">c_exog_data</code></td>
<td>
<p>NULL or Character. Name(s) of the exogenous variable(s) with contemporaneous impact.</p>
</td></tr>
<tr><td><code id="lp_lin_panel_+3A_l_exog_data">l_exog_data</code></td>
<td>
<p>NULL or Character. Name(s) of the exogenous variable(s) with lagged impact.</p>
</td></tr>
<tr><td><code id="lp_lin_panel_+3A_lags_exog_data">lags_exog_data</code></td>
<td>
<p>Integer. Lag length for the exogenous variable(s) with lagged impact.</p>
</td></tr>
<tr><td><code id="lp_lin_panel_+3A_c_fd_exog_data">c_fd_exog_data</code></td>
<td>
<p>NULL or Character. Name(s) of the exogenous variable(s) with contemporaneous impact of first differences.</p>
</td></tr>
<tr><td><code id="lp_lin_panel_+3A_l_fd_exog_data">l_fd_exog_data</code></td>
<td>
<p>NULL or Character. Name(s) of exogenous variable(s) with lagged impact of first differences.</p>
</td></tr>
<tr><td><code id="lp_lin_panel_+3A_lags_fd_exog_data">lags_fd_exog_data</code></td>
<td>
<p>NaN or Integer. Number of lags for variable(s) with impact of first differences.</p>
</td></tr>
<tr><td><code id="lp_lin_panel_+3A_confint">confint</code></td>
<td>
<p>Double. Width of confidence bands. 68% = 1; 90% = 1.65; 95% = 1.96.</p>
</td></tr>
<tr><td><code id="lp_lin_panel_+3A_hor">hor</code></td>
<td>
<p>Integer. Number of horizons for impulse responses.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>irf_lin_mean</code></td>
<td>
<p>A <a href="base.html#topic+matrix">matrix</a>, containing the impulse responses.
The columns are the horizons.</p>
</td></tr>
<tr><td><code>irf_lin_low</code></td>
<td>
<p>A <a href="base.html#topic+matrix">matrix</a>, containing all lower confidence bands.
The columns are the horizons.</p>
</td></tr>
<tr><td><code>irf_lin_up</code></td>
<td>
<p>A <a href="base.html#topic+matrix">matrix</a>, containing all upper confidence bands.
The columns are the horizons.</p>
</td></tr>
<tr><td><code>reg_outputs</code></td>
<td>
<p>Full regression output (plm object) for each horizon.</p>
</td></tr>
<tr><td><code>reg_summaries</code></td>
<td>
<p>Summary of regression output for each horizon. In case of robust covariance estimators,
this only includes the t-tests.</p>
</td></tr>
<tr><td><code>xy_data_sets</code></td>
<td>
<p>Data sets with endogenous and exogenous variables for each horizon.</p>
</td></tr>
<tr><td><code>specs</code></td>
<td>
<p>A list with data properties for e.g. the plot function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Philipp Adämmer
</p>


<h3>References</h3>

<p>Croissant, Y., Millo, G. (2008). &quot;Panel Data Econometrics in R: The plm Package.&quot; <em>Journal of Statistical Software</em>, 27(2), 1-43. doi:
10.18637/jss.v027.i02.
</p>
<p>Jordà, Ò. (2005). &quot;Estimation and Inference of Impulse Responses by Local Projections.&quot;
<em>American Economic Review</em>, 95 (1): 161-182.
</p>
<p>Jordà, Ò., Schualrick, M., Taylor, A.M. (2018). &quot;Large and State-Dependent Effects of Quasi-Random Monetary Experiments&quot;,
<em>NBER</em> working paper 23074, <em>FRBSF</em> working paper 2017-02.
</p>
<p>Millo G (2017). “Robust Standard Error Estimators for Panel Models: A Unifying Approach.” <em>Journal of Statistical Software</em>, 82(3), 1-27. doi:
10.18637/jss.v082.i03.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#--- Info
# This example is based on a STATA code that has been provided on
# Òscar Jordà's website (https://sites.google.com/site/oscarjorda/home/local-projections)
# It estimates impulse reponses of the ratio of (mortgage lending/GDP) to a
# +1% change in the short term interest rate

#--- Get data
# Go to the website of the 'The MacroFinance and MacroHistory Lab'
# Download the Excel-Sheet of the 'Jordà-Schularick-Taylor Macrohistory Database':
# URL: https://www.macrohistory.net/database/
# Then uncomment and run the code below...


#--- Code

## Load libraries to download and read excel file from the website
#  library(lpirfs)
#  library(readxl)
#  library(dplyr)
#
# Load JST Macrohistory Database
#  jst_data &lt;- read_excel("JSTdatasetR5.xlsx", sheet = "Data")
#
## Choose years &lt;= 2013. Swap the first two columns so that 'country' is the
## first (cross section) and 'year' the second (time section) column
#   jst_data &lt;- jst_data                     %&gt;%
#               dplyr::filter(year &lt;= 2013)  %&gt;%
#               dplyr::select(country, year, everything())
#
## Prepare variables
#  data_set &lt;- jst_data %&gt;%
#                 mutate(stir     = stir)                         %&gt;%
#                 mutate(mortgdp  = 100*(tmort/gdp))              %&gt;%
#                 mutate(hpreal   = hpnom/cpi)                    %&gt;%
#                 group_by(country)                               %&gt;%
#                 mutate(hpreal   = hpreal/hpreal[year==1990][1]) %&gt;%
#                 mutate(lhpreal  = log(hpreal))                  %&gt;%
#
#                 mutate(lhpy     = lhpreal - log(rgdppc))        %&gt;%
#                 mutate(lhpy     = lhpy - lhpy[year == 1990][1]) %&gt;%
#                 mutate(lhpreal  = 100*lhpreal)                  %&gt;%
#                 mutate(lhpy     = 100*lhpy)                     %&gt;%
#                 ungroup()                                       %&gt;%
#
#                 mutate(lrgdp    = 100*log(rgdppc))              %&gt;%
#                 mutate(lcpi     = 100*log(cpi)) 		            %&gt;%
#                 mutate(lriy     = 100*log(iy*rgdppc))           %&gt;%
#                 mutate(cay      = 100*(ca/gdp))                 %&gt;%
#                 mutate(tnmort   = tloans - tmort)               %&gt;%
#                 mutate(nmortgdp = 100*(tnmort/gdp))             %&gt;%
#                 dplyr::select(country, year, mortgdp, stir, ltrate,
#                               lhpy, lrgdp, lcpi, lriy, cay, nmortgdp)
#
#
## Use data from 1870 to 2013 and exclude observations during WWI and WWII
#   data_sample &lt;-   seq(1870, 2013)[!(seq(1870, 2016) %in%
#                                   c(seq(1914, 1918), seq(1939, 1947)))]
#
## Estimate panel model
# results_panel &lt;-  lp_lin_panel(data_set          = data_set,
#                                 data_sample       = data_sample,
#                                 endog_data        = "mortgdp",
#                                 cumul_mult        = TRUE,
#
#                                 shock             = "stir",
#                                 diff_shock        = TRUE,
#                                 panel_model       = "within",
#                                 panel_effect      = "individual",
#                                 robust_cov        = "vcovSCC",
#
#                                 c_exog_data       = "cay",
#                                 l_exog_data       = "cay",
#                                 lags_exog_data    = 2,
#                                 c_fd_exog_data    = colnames(data_set)[c(seq(4,9),11)],
#                                 l_fd_exog_data    = colnames(data_set)[c(seq(3,9),11)],
#                                 lags_fd_exog_data = 2,
#
#                                 confint           = 1.67,
#                                 hor               = 5)
#
## Plot irfs
#   plot(results_panel)
#
#
## Simulate and add instrument to data_set
#   set.seed(123)
#   data_set   &lt;- data_set %&gt;%
#                 group_by(country) %&gt;%
#                 mutate(instrument = 0.8*stir + rnorm(length(stir), 0, sd(na.omit(stir))/10)) %&gt;%
#                 ungroup()
#
#
## Estimate panel model with iv approach
#  results_panel &lt;-  lp_lin_panel(data_set          = data_set,
#                                 data_sample       = data_sample,
#                                 endog_data        = "mortgdp",
#                                 cumul_mult        = TRUE,
#
#                                 shock             = "stir",
#                                 diff_shock        = TRUE,
#                                 iv_reg            = TRUE,
#                                 instrum           = "instrument",
#                                 panel_model       = "within",
#                                 panel_effect      = "individual",
#                                 robust_cov        = "vcovSCC",
#
#                                 c_exog_data       = "cay",
#                                 l_exog_data       = "cay",
#                                 lags_exog_data    = 2,
#                                 c_fd_exog_data    = colnames(data_set)[c(seq(4,9),11)],
#                                 l_fd_exog_data    = colnames(data_set)[c(seq(3,9),11)],
#                                 lags_fd_exog_data = 2,
#
#                                 confint           = 1.67,
#                                 hor               = 5)
#
## Create and plot irfs
#   plot(results_panel)
#
#
##############################################################################
###                           Use GMM                                      ###
##############################################################################
#
#
## Use a much smaller sample to have fewer T than N
# data_sample &lt;-   seq(2000, 2012)
#
## Estimate panel model with gmm
## This example (please uncomment) gives a warning at each iteration.
## The data set is not well suited for GMM as GMM is based on N-asymptotics
## and the data set only contains 27 countries
#
# results_panel &lt;-  lp_lin_panel(data_set          = data_set,
#                              data_sample        = data_sample,
#                              endog_data         = "mortgdp",
#                              cumul_mult         = TRUE,
#
#                              shock              = "stir",
#                              diff_shock         = TRUE,
#
#                              use_gmm            = TRUE,
#                              gmm_model          = "onestep",
#                              gmm_effect         = "twoways",
#                              gmm_transformation = "ld",
#
#                              l_exog_data        = "mortgdp",
#                              lags_exog_data     = 2,
#                              l_fd_exog_data     = colnames(data_set)[c(4, 6)],
#                              lags_fd_exog_data  = 1,
#
#                              confint            = 1.67,
#                              hor                = 5)
#
# Create and plot irfs
# plot(results_panel)
#



</code></pre>

<hr>
<h2 id='lp_nl'>Compute nonlinear impulse responses</h2><span id='topic+lp_nl'></span>

<h3>Description</h3>

<p>Compute nonlinear impulse responses with local projections by Jordà (2005). The
data can be separated into two states by a smooth transition function as applied in Auerbach and Gorodnichenko (2012),
or by a simple dummy approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lp_nl(
  endog_data,
  lags_endog_lin = NULL,
  lags_endog_nl = NULL,
  lags_criterion = NaN,
  max_lags = NaN,
  trend = NULL,
  shock_type = NULL,
  confint = NULL,
  use_nw = TRUE,
  nw_lag = NULL,
  nw_prewhite = FALSE,
  adjust_se = FALSE,
  hor = NULL,
  switching = NULL,
  lag_switching = TRUE,
  use_logistic = TRUE,
  use_hp = NULL,
  lambda = NULL,
  gamma = NULL,
  exog_data = NULL,
  lags_exog = NULL,
  contemp_data = NULL,
  num_cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lp_nl_+3A_endog_data">endog_data</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">data.frame</a>, containing all endogenous variables for the VAR. The Cholesky decomposition is based on the
column order.</p>
</td></tr>
<tr><td><code id="lp_nl_+3A_lags_endog_lin">lags_endog_lin</code></td>
<td>
<p>NaN or integer. NaN if lag length criterion is used.
Integer for number of lags for linear VAR to identify shock.</p>
</td></tr>
<tr><td><code id="lp_nl_+3A_lags_endog_nl">lags_endog_nl</code></td>
<td>
<p>NaN or integer. Number of lags for nonlinear VAR. NaN if lag length criterion is given.</p>
</td></tr>
<tr><td><code id="lp_nl_+3A_lags_criterion">lags_criterion</code></td>
<td>
<p>NaN or character. NaN (default) means that the number of lags
will be given at <em>lags_endog_nl</em> and <em>lags_endog_lin</em>. The lag length criteria are 'AICc', 'AIC' and 'BIC'.</p>
</td></tr>
<tr><td><code id="lp_nl_+3A_max_lags">max_lags</code></td>
<td>
<p>NaN or integer. Maximum number of lags (if <em>lags_criterion</em> = 'AICc', 'AIC', 'BIC'). NaN (default) otherwise.</p>
</td></tr>
<tr><td><code id="lp_nl_+3A_trend">trend</code></td>
<td>
<p>Integer. Include no trend =  0 , include trend = 1, include trend and quadratic trend = 2.</p>
</td></tr>
<tr><td><code id="lp_nl_+3A_shock_type">shock_type</code></td>
<td>
<p>Integer. Standard deviation shock = 0, unit shock = 1.</p>
</td></tr>
<tr><td><code id="lp_nl_+3A_confint">confint</code></td>
<td>
<p>Double. Width of confidence bands. 68% = 1; 90% = 1.65; 95% = 1.96.</p>
</td></tr>
<tr><td><code id="lp_nl_+3A_use_nw">use_nw</code></td>
<td>
<p>Boolean. Use Newey-West (1987) standard errors for impulse responses? TRUE (default) or FALSE.</p>
</td></tr>
<tr><td><code id="lp_nl_+3A_nw_lag">nw_lag</code></td>
<td>
<p>Integer. Specifies the maximum lag with positive weight for the Newey-West estimator. If set to NULL (default), the lag increases with
with the number of horizon.</p>
</td></tr>
<tr><td><code id="lp_nl_+3A_nw_prewhite">nw_prewhite</code></td>
<td>
<p>Boolean. Should the estimators be pre-whitened? TRUE of FALSE (default).</p>
</td></tr>
<tr><td><code id="lp_nl_+3A_adjust_se">adjust_se</code></td>
<td>
<p>Boolen. Should a finite sample adjsutment be made to the covariance matrix estimators? TRUE or FALSE (default).</p>
</td></tr>
<tr><td><code id="lp_nl_+3A_hor">hor</code></td>
<td>
<p>Integer. Number of horizons for impulse responses.</p>
</td></tr>
<tr><td><code id="lp_nl_+3A_switching">switching</code></td>
<td>
<p>Numeric vector. A column vector with the same length as <em>endog_data</em>. If 'use_logistic = TRUE', this series can either
be decomposed via the Hodrick-Prescott filter (see Auerbach and Gorodnichenko, 2013) or
directly plugged into the following logistic function:
</p>
<p style="text-align: center;"><code class="reqn"> F_{z_t} = \frac{exp(-\gamma z_t)}{1 + exp(-\gamma z_t)}. </code>
</p>

<p>Important: <code>F_{z_t}</code> will be lagged by one and then multiplied with the data.
If the variable shall not be lagged, use 'lag_switching = FALSE': <br />
Regime 1 = (1-<code>F(z_{t-1}))*y_{(t-p)}</code>, <br />
Regime 2 = <code>F(z_{t-1})*y_{(t-p)}</code>.</p>
</td></tr>
<tr><td><code id="lp_nl_+3A_lag_switching">lag_switching</code></td>
<td>
<p>Boolean. Use the first lag of the values of the transition function? TRUE (default) or FALSE.</p>
</td></tr>
<tr><td><code id="lp_nl_+3A_use_logistic">use_logistic</code></td>
<td>
<p>Boolean. Use logistic function to separate states? TRUE (default) or FALSE. If FALSE, the values of the switching variable
have to be binary (0/1).</p>
</td></tr>
<tr><td><code id="lp_nl_+3A_use_hp">use_hp</code></td>
<td>
<p>Boolean. Use HP-filter? TRUE or FALSE.</p>
</td></tr>
<tr><td><code id="lp_nl_+3A_lambda">lambda</code></td>
<td>
<p>Double. Value of <code class="reqn">\lambda</code> for the Hodrick-Prescott filter (if use_hp = TRUE).</p>
</td></tr>
<tr><td><code id="lp_nl_+3A_gamma">gamma</code></td>
<td>
<p>Double. Positive number which is used in the transition function.</p>
</td></tr>
<tr><td><code id="lp_nl_+3A_exog_data">exog_data</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">data.frame</a>, containing exogenous variables for the VAR. The row length has to be the same as <em>endog_data</em>.
Lag lengths for exogenous variables have to be given and will not be determined via a lag length criterion.</p>
</td></tr>
<tr><td><code id="lp_nl_+3A_lags_exog">lags_exog</code></td>
<td>
<p>NULL or Integer. Integer for the number of lags for the exogenous data. The value cannot be 0. If you want to
to include exogenous data with contemporaneous impact use <em>contemp_data</em>.</p>
</td></tr>
<tr><td><code id="lp_nl_+3A_contemp_data">contemp_data</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">data.frame</a>, containing exogenous data with contemporaneous impact. This data will not be lagged.
The row length has to be the same as <em>endog_data</em>.</p>
</td></tr>
<tr><td><code id="lp_nl_+3A_num_cores">num_cores</code></td>
<td>
<p>Integer. The number of cores to use for the estimation. If NULL, the function will
use the maximum number of cores minus one.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>irf_s1_mean</code></td>
<td>
<p>A three-dimensional <code>array</code>, containing all impulse responses for all endogenous variables of the first state.
The last dimension denotes the shock variable. The row in each matrix
denotes the responses of the <em>ith</em> variable, ordered as in <em>endog_data</em>. The columns are the horizons.
For example, if the results are saved in <em>results_nl</em>, <code>results_nl\$irf_s1_mean[, , 1]</code> returns a KxH matrix,
where K is the number of variables and H is the number of horizons. '1' is the shock variable, corresponding to the
variable in the first column of <em>endog_data</em>.</p>
</td></tr>
<tr><td><code>irf_s1_low</code></td>
<td>
<p>A three-dimensional <code>array</code>, containing all lower confidence bands of the impulse responses, based on
robust standard errors by Newey and West (1987). Properties are equal to <em>irf_s1_mean</em>.</p>
</td></tr>
<tr><td><code>irf_s1_up</code></td>
<td>
<p>A three-dimensional <code>array</code>, containing all upper confidence bands of the impulse responses, based on
robust standard errors by Newey and West (1987). Properties are equal to <em>irf_s1_mean</em>.</p>
</td></tr>
<tr><td><code>irf_s2_mean</code></td>
<td>
<p>A three-dimensional <code>array</code>, containing all impulse responses for all endogenous variables of the second state.
The last dimension denotes the shock variable. The row in each matrix
denotes the responses of the <em>ith</em> variable, ordered as in <em>endog_data</em>. The columns denote the horizon.
For example, if the results are saved in <em>results_nl</em>, <code>results_nl\$irf_s2_mean[, , 1]</code> returns a KxH matrix,
where K is the number of variables and H is the number of horizons. '1' is the first shock variable corresponding to the
variable in the first column of <em>endog_data</em>.</p>
</td></tr>
<tr><td><code>irf_s2_low</code></td>
<td>
<p>A three-dimensional <code>array</code>, containing all lower confidence bands of the responses,
based on robust standard errors by Newey and West (1987). Properties are equal to <em>irf_s2_mean</em>.</p>
</td></tr>
<tr><td><code>irf_s2_up</code></td>
<td>
<p>A three-dimensional <code>array</code>, containing all upper confidence bands of the responses, based on
robust standard errors by Newey and West (1987). Properties are equal to <em>irf_s2_mean</em>.</p>
</td></tr>
<tr><td><code>specs</code></td>
<td>
<p>A list with properties of <em>endog_data</em> for the plot function. It also contains
lagged data (<em>y_nl</em> and <em>x_nl</em>) used for the IRF estimations, and the selected lag lengths when an information criterion has been used.</p>
</td></tr>
<tr><td><code>fz</code></td>
<td>
<p>A vector containing the values of the transition function <code>F(z\_{t-1})</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Philipp Adämmer
</p>


<h3>References</h3>

<p>Akaike, H. (1974). &quot;A new look at the statistical model identification&quot;, <em>IEEE Transactions on Automatic Control</em>, 19 (6): 716–723.
</p>
<p>Auerbach, A. J., and  Gorodnichenko Y. (2012). &quot;Measuring the Output Responses to Fiscal Policy.&quot;
<em>American Economic Journal: Economic Policy</em>, 4 (2): 1-27.
</p>
<p>Auerbach, A. J., and Gorodnichenko Y. (2013). &quot;Fiscal Multipliers in Recession and Expansion.&quot;
<em>NBER Working Paper Series</em>. Nr. 17447.
</p>
<p>Hurvich, C. M., and Tsai, C.-L. (1989), &quot;Regression and time series model selection in small samples&quot;,
<em>Biometrika</em>, 76(2): 297–307
</p>
<p>Jordà, Ò. (2005) &quot;Estimation and Inference of Impulse Responses by Local Projections.&quot;
<em>American Economic Review</em>, 95 (1): 161-182.
</p>
<p>Newey, W.K., and West, K.D. (1987). “A Simple, Positive-Definite, Heteroskedasticity and
Autocorrelation Consistent Covariance Matrix.” <em>Econometrica</em>, 55, 703–708.
</p>
<p>Schwarz, Gideon E. (1978). &quot;Estimating the dimension of a model&quot;, <em>Annals of Statistics</em>, 6 (2): 461–464.
</p>
<p>Ravn, M.O., Uhlig, H. (2002). &quot;On Adjusting the Hodrick-Prescott Filter for the Frequency of Observations.&quot;
<em>Review of Economics and Statistics</em>, 84(2), 371-376.
</p>


<h3>See Also</h3>

<p><a href="https://adaemmerp.github.io/lpirfs/README_docs.html">https://adaemmerp.github.io/lpirfs/README_docs.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
                  ## Example without exogenous variables ##

# Load package
  library(lpirfs)
  library(gridExtra)
  library(ggpubr)


# Load (endogenous) data
  endog_data &lt;- interest_rules_var_data

# Choose data for switching variable (here Federal Funds Rate)
# Important: The switching variable does not have to be used within the VAR!
 switching_data &lt;-  endog_data$Infl

# Estimate model and save results
  results_nl    &lt;- lp_nl(endog_data,
                                lags_endog_lin  = 4,
                                lags_endog_nl   = 3,
                                trend           = 0,
                                shock_type      = 1,
                                confint         = 1.96,
                                hor             = 24,
                                switching       = switching_data,
                                use_hp          = TRUE,
                                lambda          = 1600,
                                gamma           = 3)

# Show all plots
 plot(results_nl)

# Make and save all plots
 nl_plots &lt;- plot_nl(results_nl)

# Save plots based on states
 s1_plots &lt;- sapply(nl_plots$gg_s1, ggplotGrob)
 s2_plots &lt;- sapply(nl_plots$gg_s2, ggplotGrob)

# Show first irf of each state
  plot(s1_plots[[1]])
  plot(s2_plots[[1]])

# Show diagnostics. The first element correponds to the first shock variable.
 summary(results_nl)


                     ## Example with exogenous variables ##

# Load (endogenous) data
 endog_data &lt;- interest_rules_var_data

# Choose data for switching variable (here Federal Funds Rate)
# Important: The switching variable does not have to be used within the VAR!
 switching_data &lt;-  endog_data$FF

# Create exogenous data and data with contemporaneous impact (for illustration purposes only)
 exog_data    &lt;- endog_data$GDP_gap*endog_data$Infl*endog_data$FF + rnorm(dim(endog_data)[1])
 contemp_data &lt;- endog_data$GDP_gap*endog_data$Infl*endog_data$FF + rnorm(dim(endog_data)[1])

# Exogenous data has to be a data.frame
 exog_data    &lt;- data.frame(xx  = exog_data)
 contemp_data &lt;- data.frame(cc  = contemp_data)

# Estimate model and save results
 results_nl &lt;- lp_nl(endog_data,
                          lags_endog_lin  = 4,
                          lags_endog_nl   = 3,
                          trend           = 0,
                          shock_type      = 1,
                          confint         = 1.96,
                          hor             = 24,
                          switching       = switching_data,
                          use_hp          = TRUE,
                          lambda          = 1600, # Ravn and Uhlig (2002):
                                                  # Anuual data    = 6.25
                                                  # Quarterly data = 1600
                                                  # Monthly data   = 129 600
                          gamma           = 3,
                          exog_data       = exog_data,
                          lags_exog       = 3)


# Show all plots
 plot(results_nl)


# Show diagnostics. The first element correponds to the first shock variable.
 summary(results_nl)




</code></pre>

<hr>
<h2 id='lp_nl_iv'>Compute nonlinear impulse responses with identified shock</h2><span id='topic+lp_nl_iv'></span>

<h3>Description</h3>

<p>Compute nonlinear impulse responses with local projections and identified shock.
The data can be separated into two states by a smooth transition function as applied in Auerbach and Gorodnichenko (2012),
or by a simple dummy approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lp_nl_iv(
  endog_data,
  lags_endog_nl = NULL,
  shock = NULL,
  cumul_mult = FALSE,
  instr = NULL,
  exog_data = NULL,
  lags_exog = NULL,
  contemp_data = NULL,
  lags_criterion = NaN,
  max_lags = NaN,
  trend = NULL,
  confint = NULL,
  use_nw = TRUE,
  nw_lag = NULL,
  nw_prewhite = FALSE,
  adjust_se = FALSE,
  hor = NULL,
  switching = NULL,
  lag_switching = TRUE,
  use_logistic = TRUE,
  use_hp = NULL,
  lambda = NULL,
  gamma = NULL,
  num_cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lp_nl_iv_+3A_endog_data">endog_data</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">data.frame</a>, containing all endogenous variables for the VAR.</p>
</td></tr>
<tr><td><code id="lp_nl_iv_+3A_lags_endog_nl">lags_endog_nl</code></td>
<td>
<p>NaN or integer. NaN if lags are chosen by a lag length criterion. Integer for number of lags for <em>endog_data</em>.</p>
</td></tr>
<tr><td><code id="lp_nl_iv_+3A_shock">shock</code></td>
<td>
<p>One column <a href="base.html#topic+data.frame">data.frame</a>, including the instrument to shock with.
The row length has to be the same as <em>endog_data</em>.</p>
</td></tr>
<tr><td><code id="lp_nl_iv_+3A_cumul_mult">cumul_mult</code></td>
<td>
<p>Boolean. Estimate cumulative multipliers? TRUE or FALSE (default). If TRUE, cumulative responses
are estimated via: </p>
<p style="text-align: center;"><code class="reqn">y_{(t+h)} - y_{(t-1)},</code>
</p>
<p> where h = 0,..., H-1.
This option is only available for <em>lags_criterion = NaN</em>.</p>
</td></tr>
<tr><td><code id="lp_nl_iv_+3A_instr">instr</code></td>
<td>
<p>Deprecated input name. Use <em>shock</em> instead. See <em>shock</em> for details.</p>
</td></tr>
<tr><td><code id="lp_nl_iv_+3A_exog_data">exog_data</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">data.frame</a>, containing exogenous variables. The row length has to be the same as <em>endog_data</em>.
Lag lengths for exogenous variables have to be given and will not be determined via a lag length criterion.</p>
</td></tr>
<tr><td><code id="lp_nl_iv_+3A_lags_exog">lags_exog</code></td>
<td>
<p>NULL or Integer. Integer for the number of lags for the exogenous data. The value cannot be 0. If you want to
to include exogenous data with contemporaneous impact use <em>contemp_data</em>.</p>
</td></tr>
<tr><td><code id="lp_nl_iv_+3A_contemp_data">contemp_data</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">data.frame</a>, containing exogenous data with contemporaneous impact. This data will not be lagged.
The row length has to be the same as <em>endog_data</em>.</p>
</td></tr>
<tr><td><code id="lp_nl_iv_+3A_lags_criterion">lags_criterion</code></td>
<td>
<p>NaN or character. NaN means that the number of lags
will be given at <em>lags_endog_nl</em>. Possible lag length criteria are 'AICc', 'AIC' or 'BIC'.</p>
</td></tr>
<tr><td><code id="lp_nl_iv_+3A_max_lags">max_lags</code></td>
<td>
<p>NaN or integer. Maximum number of lags (if <em>lags_criterion</em> = 'AICc', 'AIC', 'BIC'). NaN otherwise.</p>
</td></tr>
<tr><td><code id="lp_nl_iv_+3A_trend">trend</code></td>
<td>
<p>Integer. Include no trend =  0 , include trend = 1, include trend and quadratic trend = 2.</p>
</td></tr>
<tr><td><code id="lp_nl_iv_+3A_confint">confint</code></td>
<td>
<p>Double. Width of confidence bands. 68% = 1; 90% = 1.65; 95% = 1.96.</p>
</td></tr>
<tr><td><code id="lp_nl_iv_+3A_use_nw">use_nw</code></td>
<td>
<p>Boolean. Use Newey-West (1987) standard errors for impulse responses? TRUE (default) or FALSE.</p>
</td></tr>
<tr><td><code id="lp_nl_iv_+3A_nw_lag">nw_lag</code></td>
<td>
<p>Integer. Specifies the maximum lag with positive weight for the Newey-West estimator. If set to NULL (default), the lag increases with
with the number of horizon.</p>
</td></tr>
<tr><td><code id="lp_nl_iv_+3A_nw_prewhite">nw_prewhite</code></td>
<td>
<p>Boolean. Should the estimators be pre-whitened? TRUE of FALSE (default).</p>
</td></tr>
<tr><td><code id="lp_nl_iv_+3A_adjust_se">adjust_se</code></td>
<td>
<p>Boolen. Should a finite sample adjsutment be made to the covariance matrix estimators? TRUE or FALSE (default).</p>
</td></tr>
<tr><td><code id="lp_nl_iv_+3A_hor">hor</code></td>
<td>
<p>Integer. Number of horizons for impulse responses.</p>
</td></tr>
<tr><td><code id="lp_nl_iv_+3A_switching">switching</code></td>
<td>
<p>Numeric vector. A column vector with the same length as <em>endog_data</em>. This series can either
be decomposed via the Hodrick-Prescott filter (see Auerbach and Gorodnichenko, 2013) or
directly plugged into the following smooth transition function:
</p>
<p style="text-align: center;"><code class="reqn"> F_{z_t} = \frac{exp(-\gamma z_t)}{1 + exp(-\gamma z_t)}. </code>
</p>

<p>Warning: <code>F\_{z_t}</code> will be lagged by one and then multiplied with the data.
If the variable shall not be lagged, the vector has to be given with a lead of one.
The data for the two regimes are: <br />
Regime 1 = (1-<code>F(z\_{t-1}))*y\_{(t-p)}</code>, <br />
Regime 2 = <code>F(z\_{t-1})*y\_{(t-p)}</code>.</p>
</td></tr>
<tr><td><code id="lp_nl_iv_+3A_lag_switching">lag_switching</code></td>
<td>
<p>Boolean. Use the first lag of the values of the transition function? TRUE (default) or FALSE.</p>
</td></tr>
<tr><td><code id="lp_nl_iv_+3A_use_logistic">use_logistic</code></td>
<td>
<p>Boolean. Use logistic function to separate states? TRUE (default) or FALSE. If FALSE, the values of the switching variable
have to be binary (0/1).</p>
</td></tr>
<tr><td><code id="lp_nl_iv_+3A_use_hp">use_hp</code></td>
<td>
<p>Boolean. Use HP-filter? TRUE or FALSE.</p>
</td></tr>
<tr><td><code id="lp_nl_iv_+3A_lambda">lambda</code></td>
<td>
<p>Double. Value of <code class="reqn">\lambda</code> for the Hodrick-Prescott filter (if use_hp = TRUE).</p>
</td></tr>
<tr><td><code id="lp_nl_iv_+3A_gamma">gamma</code></td>
<td>
<p>Double. Positive number which is used in the transition function.</p>
</td></tr>
<tr><td><code id="lp_nl_iv_+3A_num_cores">num_cores</code></td>
<td>
<p>Integer. The number of cores to use for the estimation. If NULL, the function will
use the maximum number of cores minus one.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>irf_s1_mean</code></td>
<td>
<p>A <a href="base.html#topic+matrix">matrix</a>, containing the impulse responses of the first regime.
The row in each matrix denotes the responses of the <em>ith</em>
variable to the shock. The columns are the horizons.</p>
</td></tr>
<tr><td><code>irf_s1_low</code></td>
<td>
<p>A <a href="base.html#topic+matrix">matrix</a>, containing all lower confidence bands of
the impulse responses, based on robust standard errors by Newey and West (1987).
Properties are equal to <em>irf_s1_mean</em>.</p>
</td></tr>
<tr><td><code>irf_s1_up</code></td>
<td>
<p>A <a href="base.html#topic+matrix">matrix</a>, containing all upper confidence bands of the
impulse responses, based on robust standard errors by Newey and West (1987).
Properties are equal to <em>irf_s1_mean</em>.</p>
</td></tr>
<tr><td><code>irf_s2_mean</code></td>
<td>
<p>A <a href="base.html#topic+matrix">matrix</a>, containing all impulse responses for the second regime.
The row in each matrix denotes the responses of the <em>ith</em> variable to the shock.
The columns denote the horizon.</p>
</td></tr>
<tr><td><code>irf_s2_low</code></td>
<td>
<p>A <a href="base.html#topic+matrix">matrix</a>, containing all lower confidence bands of the responses,
based on robust standard errors by Newey and West (1987). Properties are equal to <em>irf_s2_mean</em>.</p>
</td></tr>
<tr><td><code>irf_s2_up</code></td>
<td>
<p>A <a href="base.html#topic+matrix">matrix</a>, containing all upper confidence bands of the responses, based on
robust standard errors by Newey and West (1987). Properties are equal to <em>irf_s2_mean</em>.</p>
</td></tr>
<tr><td><code>specs</code></td>
<td>
<p>A list with properties of <em>endog_data</em> for the plot function. It also contains
lagged data (y_nl and x_nl) used for the estimations of the impulse responses, and the selected lag lengths when an information criterion has been used.</p>
</td></tr>
<tr><td><code>fz</code></td>
<td>
<p>A vector, containing the values of the transition function <code>F(z\_{t-1})</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Philipp Adämmer
</p>


<h3>References</h3>

<p>Akaike, H. (1974). &quot;A new look at the statistical model identification&quot;, <em>IEEE Transactions on Automatic Control</em>, 19 (6): 716–723.
</p>
<p>Auerbach, A. J., and  Gorodnichenko Y. (2012). &quot;Measuring the Output Responses to Fiscal Policy.&quot;
<em>American Economic Journal: Economic Policy</em>, 4 (2): 1-27.
</p>
<p>Auerbach, A. J., and Gorodnichenko Y. (2013). &quot;Fiscal Multipliers in Recession and Expansion.&quot;
<em>NBER Working Paper Series</em>. Nr 17447.
</p>
<p>Blanchard, O., and Perotti, R. (2002). “An Empirical Characterization of the
Dynamic Effects of Changes in Government Spending and Taxes on Output.” <em>Quarterly
Journal of Economics</em>, 117(4): 1329–1368.
</p>
<p>Hurvich, C. M., and Tsai, C.-L. (1989), &quot;Regression and time series model selection in small samples&quot;,
<em>Biometrika</em>, 76(2): 297–307
</p>
<p>Jordà, Ò. (2005) &quot;Estimation and Inference of Impulse Responses by Local Projections.&quot;
<em>American Economic Review</em>, 95 (1): 161-182.
</p>
<p>Jordà, Ò, Schularick, M., Taylor, A.M. (2015), &quot;Betting the house&quot;, <em>Journal of International Economics</em>,
96, S2-S18.
</p>
<p>Newey, W.K., and West, K.D. (1987). “A Simple, Positive-Definite, Heteroskedasticity and
Autocorrelation Consistent Covariance Matrix.” <em>Econometrica</em>, 55, 703–708.
</p>
<p>Ramey, V.A., and Zubairy, S. (2018). &quot;Government Spending Multipliers in Good Times
and in Bad: Evidence from US Historical Data.&quot; <em>Journal of Political Economy</em>,
126(2): 850 - 901.
</p>
<p>Schwarz, Gideon E. (1978). &quot;Estimating the dimension of a model&quot;, <em>Annals of Statistics</em>, 6 (2): 461–464.
</p>


<h3>See Also</h3>

<p><a href="https://adaemmerp.github.io/lpirfs/README_docs.html">https://adaemmerp.github.io/lpirfs/README_docs.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# This example replicates results from the Supplementary Appendix
# by Ramey and Zubairy (2018) (RZ-18).

# Load and prepare data
 ag_data           &lt;- ag_data
 sample_start      &lt;- 7
 sample_end        &lt;- dim(ag_data)[1]
 endog_data        &lt;- ag_data[sample_start:sample_end, 3:5]

# The shock is estimated by RZ-18
 shock             &lt;- ag_data[sample_start:sample_end, 7]

# Include four lags of the 7-quarter moving average growth rate of GDP
# as exogenous variables (see RZ-18)
 exog_data         &lt;- ag_data[sample_start:sample_end, 6]

# Use the 7-quarter moving average growth rate of GDP as switching variable
# and adjust it to have suffiently long recession periods.
 switching_variable &lt;- ag_data$GDP_MA[sample_start:sample_end] - 0.8

# Estimate local projections
 results_nl_iv &lt;- lp_nl_iv(endog_data,
                           lags_endog_nl     = 3,
                           shock             = shock,
                           exog_data         = exog_data,
                           lags_exog         = 4,
                           trend             = 0,
                           confint           = 1.96,
                           hor               = 20,
                           switching         = switching_variable,
                           use_hp            = FALSE,
                           gamma             = 3)

# Show all impulse responses
plot(results_nl_iv)

# Make and save individual plots
 plots_nl_iv &lt;- plot_nl(results_nl_iv)

# Show single impulse responses
# Compare with red line of left plot (lower panel) in Figure 12 in Supplementary Appendix of RZ-18.
 plot(plots_nl_iv$gg_s1[[1]])
# Compare with blue line of left plot (lower panel) in Figure 12 in Supplementary Appendix of RZ-18.
 plot(plots_nl_iv$gg_s2[[1]])

# Show diagnostics. The first element shows the reaction of the first endogenous variable.
summary(results_nl_iv)


</code></pre>

<hr>
<h2 id='lp_nl_panel'>Compute nonlinear impulse responses for panel data</h2><span id='topic+lp_nl_panel'></span>

<h3>Description</h3>

<p>This function estimates nonlinear impulse responses by using local projections for panel data with an
identified shock. The data can be separated into two states by a smooth transition function as applied
in Auerbach and Gorodnichenko (2012), or by a simple dummy approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lp_nl_panel(
  data_set = NULL,
  data_sample = "Full",
  endog_data = NULL,
  cumul_mult = TRUE,
  shock = NULL,
  diff_shock = TRUE,
  panel_model = "within",
  panel_effect = "individual",
  robust_cov = NULL,
  robust_method = NULL,
  robust_type = NULL,
  robust_cluster = NULL,
  robust_maxlag = NULL,
  use_gmm = FALSE,
  gmm_model = "onestep",
  gmm_effect = "twoways",
  gmm_transformation = "d",
  c_exog_data = NULL,
  l_exog_data = NULL,
  lags_exog_data = NaN,
  c_fd_exog_data = NULL,
  l_fd_exog_data = NULL,
  lags_fd_exog_data = NaN,
  switching = NULL,
  use_logistic = TRUE,
  use_hp = FALSE,
  lag_switching = TRUE,
  lambda = NULL,
  gamma = NULL,
  confint = NULL,
  hor = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lp_nl_panel_+3A_data_set">data_set</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">data.frame</a>, containing the panel data set. The first column has to be the
variable denoting the cross section. The second column has to be the
variable denoting the time section.</p>
</td></tr>
<tr><td><code id="lp_nl_panel_+3A_data_sample">data_sample</code></td>
<td>
<p>Character or numeric. To use the full sample set value to &quot;Full&quot; (default). To estimate a subset, you have to provide
a sequence of dates. This sequence has to be in the same format as the second column (time-section).</p>
</td></tr>
<tr><td><code id="lp_nl_panel_+3A_endog_data">endog_data</code></td>
<td>
<p>Character. The column name of the endogenous variable. You can only provide one endogenous variable at a time.</p>
</td></tr>
<tr><td><code id="lp_nl_panel_+3A_cumul_mult">cumul_mult</code></td>
<td>
<p>Boolean. Estimate cumulative multipliers? TRUE (default) or FALSE. If TRUE, cumulative responses
are estimated via: </p>
<p style="text-align: center;"><code class="reqn">y_{(t+h)} - y_{(t-1)},</code>
</p>
<p> where h = 0,..., H-1.</p>
</td></tr>
<tr><td><code id="lp_nl_panel_+3A_shock">shock</code></td>
<td>
<p>Character. The column name of the variable to shock with.</p>
</td></tr>
<tr><td><code id="lp_nl_panel_+3A_diff_shock">diff_shock</code></td>
<td>
<p>Boolean. Take first differences of the shock variable? TRUE (default) or FALSE. Note
that when using this option both shock and instrument are used in first differences</p>
</td></tr>
<tr><td><code id="lp_nl_panel_+3A_panel_model">panel_model</code></td>
<td>
<p>Character. Type of panel model. The default is &quot;within&quot; (fixed effects). Other options are &quot;random&quot;, &quot;ht&quot;,
&quot;between&quot;, &quot;pooling&quot; or &quot;fd&quot;. See vignette of the plm package for details.</p>
</td></tr>
<tr><td><code id="lp_nl_panel_+3A_panel_effect">panel_effect</code></td>
<td>
<p>Character. The effects introduced in the model. Options are &quot;individual&quot; (default), &quot;time&quot;, &quot;twoways&quot;,
or &quot;nested&quot;. See the vignette of the plm-package for details.</p>
</td></tr>
<tr><td><code id="lp_nl_panel_+3A_robust_cov">robust_cov</code></td>
<td>
<p>NULL or Character. The character specifies the method how to estimate robust standard errors: Options are &quot;vcovBK&quot;, &quot;vcovDC&quot;,
&quot;vcovG&quot;, &quot;vcovHC&quot;, &quot;vcovNW&quot;, &quot;vcovSCC&quot;. For these options see vignette of plm package. Another option is &quot;Vcxt&quot;. For details see Miller (2017)
If &quot;use_gmm = TRUE&quot;, this option has to be NULL.</p>
</td></tr>
<tr><td><code id="lp_nl_panel_+3A_robust_method">robust_method</code></td>
<td>
<p>NULL (default) or Character. The character is an option when robust_cov = &quot;vcovHC&quot;. See vignette of the plm package for details.</p>
</td></tr>
<tr><td><code id="lp_nl_panel_+3A_robust_type">robust_type</code></td>
<td>
<p>NULL (default) or Character. The character is an option when robust_cov  = &quot;vcovBK&quot;, &quot;vcovDC&quot;, &quot;vcovHC&quot;, &quot;vcovNW&quot; or &quot;vcovSCC&quot;. See vignette of the plm package for details.</p>
</td></tr>
<tr><td><code id="lp_nl_panel_+3A_robust_cluster">robust_cluster</code></td>
<td>
<p>NULL (default) or Character. The character is an option when robust_cov = &quot;vcovBK&quot;, &quot;vcovG&quot; or &quot;vcovHC&quot;. See vignette of the plm package for details.</p>
</td></tr>
<tr><td><code id="lp_nl_panel_+3A_robust_maxlag">robust_maxlag</code></td>
<td>
<p>NULL (default) or Character. The character is an option when robust_cov  = &quot;vcovNW&quot; or &quot;vcovSCC&quot;. See vignette of the plm package for details.</p>
</td></tr>
<tr><td><code id="lp_nl_panel_+3A_use_gmm">use_gmm</code></td>
<td>
<p>Boolean. Use GMM for estimation? TRUE or FALSE (default). See vignette of plm package for details.
If TRUE, the option &quot;robust_cov&quot; has to be set to NULL.</p>
</td></tr>
<tr><td><code id="lp_nl_panel_+3A_gmm_model">gmm_model</code></td>
<td>
<p>Character. Either &quot;onestep&quot; (default) or &quot;twosteps&quot;. See vignette of the plm package for details.</p>
</td></tr>
<tr><td><code id="lp_nl_panel_+3A_gmm_effect">gmm_effect</code></td>
<td>
<p>Character. The effects introduced in the model: &quot;twoways&quot; (default) or &quot;individual&quot;. See vignette of the plm-package for details.</p>
</td></tr>
<tr><td><code id="lp_nl_panel_+3A_gmm_transformation">gmm_transformation</code></td>
<td>
<p>Character. Either &quot;d&quot; (default) for the &quot;difference GMM&quot; model or &quot;ld&quot; for the &quot;system GMM&quot;.
See vignette of the plm package for details.</p>
</td></tr>
<tr><td><code id="lp_nl_panel_+3A_c_exog_data">c_exog_data</code></td>
<td>
<p>NULL or Character. Name(s) of the exogenous variable(s) with contemporaneous impact.</p>
</td></tr>
<tr><td><code id="lp_nl_panel_+3A_l_exog_data">l_exog_data</code></td>
<td>
<p>NULL or Character. Name(s) of the exogenous variable(s) with lagged impact.</p>
</td></tr>
<tr><td><code id="lp_nl_panel_+3A_lags_exog_data">lags_exog_data</code></td>
<td>
<p>Integer. Lag length for the exogenous variable(s) with lagged impact.</p>
</td></tr>
<tr><td><code id="lp_nl_panel_+3A_c_fd_exog_data">c_fd_exog_data</code></td>
<td>
<p>NULL or Character. Name(s) of the exogenous variable(s) with contemporaneous impact of first differences.</p>
</td></tr>
<tr><td><code id="lp_nl_panel_+3A_l_fd_exog_data">l_fd_exog_data</code></td>
<td>
<p>NULL or Character. Name(s) of exogenous variable(s) with lagged impact of first differences.</p>
</td></tr>
<tr><td><code id="lp_nl_panel_+3A_lags_fd_exog_data">lags_fd_exog_data</code></td>
<td>
<p>NaN or Integer. Number of lags for variable(s) with impact of first differences.</p>
</td></tr>
<tr><td><code id="lp_nl_panel_+3A_switching">switching</code></td>
<td>
<p>Character. Column name of the switching variable. If &quot;use_logistic = TRUE&quot;, this series can either
be decomposed by the Hodrick-Prescott filter (see Auerbach and Gorodnichenko, 2013) or
directly plugged into the following smooth transition function:
</p>
<p style="text-align: center;"><code class="reqn">F_{z_t} = \frac{exp(-\gamma z_t)}{1 + exp(-\gamma z_t)}.</code>
</p>

<p>The data for the two regimes are lagged by default: <br />
Regime 1 = (1-<code>F(z\_{t-1}))*y\_{(t-p)}</code>, <br />
Regime 2 = <code>F(z\_{t-1})*y\_{(t-p)}</code>.
This option can be suppressed with &quot;lag_switching = FALSE&quot;.</p>
</td></tr>
<tr><td><code id="lp_nl_panel_+3A_use_logistic">use_logistic</code></td>
<td>
<p>Boolean. Use logistic function to separate states? TRUE (default) or FALSE. If FALSE, the values of the switching variable
have to be binary (0/1).</p>
</td></tr>
<tr><td><code id="lp_nl_panel_+3A_use_hp">use_hp</code></td>
<td>
<p>Boolean. Use HP-filter? TRUE or FALSE (default).</p>
</td></tr>
<tr><td><code id="lp_nl_panel_+3A_lag_switching">lag_switching</code></td>
<td>
<p>Boolean. Use the first lag of the values of the transition function? TRUE (default) or FALSE.</p>
</td></tr>
<tr><td><code id="lp_nl_panel_+3A_lambda">lambda</code></td>
<td>
<p>Double. Value of <code class="reqn">\lambda</code> for the Hodrick-Prescott filter (if &quot;use_hp = TRUE&quot;).</p>
</td></tr>
<tr><td><code id="lp_nl_panel_+3A_gamma">gamma</code></td>
<td>
<p>Double. Positive value for <code class="reqn">\gamma</code>, used in the transition function.</p>
</td></tr>
<tr><td><code id="lp_nl_panel_+3A_confint">confint</code></td>
<td>
<p>Double. Width of confidence bands. 68% = 1; 90% = 1.65; 95% = 1.96.</p>
</td></tr>
<tr><td><code id="lp_nl_panel_+3A_hor">hor</code></td>
<td>
<p>Integer. Number of horizons for impulse responses.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>irf_lin_mean</code></td>
<td>
<p>A <a href="base.html#topic+matrix">matrix</a>, containing the impulse responses.
The columns are the horizons.</p>
</td></tr>
<tr><td><code>irf_lin_low</code></td>
<td>
<p>A <a href="base.html#topic+matrix">matrix</a>, containing all lower confidence bands.
The columns are the horizons.</p>
</td></tr>
<tr><td><code>irf_lin_up</code></td>
<td>
<p>A <a href="base.html#topic+matrix">matrix</a>, containing all upper confidence bands.
The columns are the horizons.</p>
</td></tr>
<tr><td><code>reg_outputs</code></td>
<td>
<p>Full regression output (plm object) for each horizon.</p>
</td></tr>
<tr><td><code>reg_summaries</code></td>
<td>
<p>Summary of regression output for each horizon. In case of robust covariance estimators,
this only includes the t-tests.</p>
</td></tr>
<tr><td><code>xy_data_sets</code></td>
<td>
<p>Data sets with endogenous and exogenous variables for each horizon.</p>
</td></tr>
<tr><td><code>specs</code></td>
<td>
<p>A list with data properties for e.g. the plot function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Philipp Adämmer
</p>


<h3>References</h3>

<p>Croissant, Y., Millo, G. (2008). “Panel Data Econometrics in R: The plm Package.” <em>Journal of Statistical Software</em>, 27(2), 1-43. doi:
10.18637/jss.v027.i02.
</p>
<p>Jordà, Ò. (2005). &quot;Estimation and Inference of Impulse Responses by Local Projections.&quot;
<em>American Economic Review</em>, 95 (1): 161-182.
</p>
<p>Jordà, Ò., Schualrick, M., Taylor, A.M. (2018). &quot;Large and State-Dependent Effects of Quasi-Random Monetary Experiments&quot;,
<em>NBER</em> working paper 23074, <em>FRBSF</em> working paper 2017-02.
</p>
<p>Millo, G. (2017). “Robust Standard Error Estimators for Panel Models: A Unifying Approach.” <em>Journal of Statistical Software</em>, 82(3), 1-27. doi:
10.18637/jss.v082.i03.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#--- Info
# This example is based on a STATA code that has been provided on
# Òscar Jordà's website (https://sites.google.com/site/oscarjorda/home/local-projections)
# It estimates impulse reponses of the ratio of (mortgage lending/GDP) to a
# +1% change in the short term interest rate

#--- Get data
# Go to the website of the 'The MacroFinance and MacroHistory Lab'
# Download the Excel-Sheet of the 'Jordà-Schularick-Taylor Macrohistory Database':
# URL: https://www.macrohistory.net/database/
# Then uncomment and run the code below...


#--- Code

## Load libraries to download and read excel file from the website
#  library(lpirfs)
#  library(readxl)
#  library(dplyr)
#
# Load JST Macrohistory Database
#  jst_data &lt;- read_excel("JSTdatasetR5.xlsx", sheet = "Data")
#
## Choose years &lt;= 2013. Swap the first two columns so that 'country' is the
## first (cross section) and 'year' the second (time section) column
#  jst_data &lt;- jst_data                    %&gt;%
#              dplyr::filter(year &lt;= 2013) %&gt;%
#              dplyr::select(country, year, everything())
#
## Prepare variables. This is based on the 'data.do' file
#   data_set &lt;- jst_data %&gt;%
#                mutate(stir     = stir)                         %&gt;%
#                mutate(mortgdp  = 100*(tmort/gdp))              %&gt;%
#                mutate(hpreal   = hpnom/cpi)                    %&gt;%
#                group_by(country)                               %&gt;%
#                mutate(hpreal   = hpreal/hpreal[year==1990][1]) %&gt;%
#                mutate(lhpreal  = log(hpreal))                  %&gt;%
#
#                mutate(lhpy     = lhpreal - log(rgdppc))        %&gt;%
#                mutate(lhpy     = lhpy - lhpy[year == 1990][1]) %&gt;%
#                mutate(lhpreal  = 100*lhpreal)                  %&gt;%
#                mutate(lhpy     = 100*lhpy)                     %&gt;%
#                ungroup()                                       %&gt;%
#
#                mutate(lrgdp    = 100*log(rgdppc))              %&gt;%
#                mutate(lcpi     = 100*log(cpi)) 		            %&gt;%
#                mutate(lriy     = 100*log(iy*rgdppc))           %&gt;%
#                mutate(cay      = 100*(ca/gdp))                 %&gt;%
#                mutate(tnmort   = tloans - tmort)               %&gt;%
#                mutate(nmortgdp = 100*(tnmort/gdp))             %&gt;%
#                dplyr::select(country, year, mortgdp, stir, ltrate, lhpy,
#                              lrgdp, lcpi, lriy, cay, nmortgdp)
#
#
## Use data_sample from 1870 to 2013 and exclude observations from WWI and WWII
#   data_sample &lt;-   seq(1870, 2016)[!(seq(1870, 2016) %in%
#                                   c(seq(1914, 1918),
#                                   seq(1939, 1947)))]
#
## Estimate panel model
# results_panel &lt;-  lp_nl_panel(data_set           = data_set,
#                                data_sample       = data_sample,
#                                endog_data        = "mortgdp",
#                                cumul_mult        = TRUE,
#
#                                shock             = "stir",
#                                diff_shock        = TRUE,
#                                panel_model       = "within",
#                                panel_effect      = "individual",
#                                robust_cov        = "vcovSCC",
#
#                                switching         = "lrgdp",
#                                lag_switching     = TRUE,
#                                use_hp            = TRUE,
#                                lambda            = 6.25,
#                                gamma             = 10,
#
#                                c_exog_data       = "cay",
#                                c_fd_exog_data    = colnames(data_set)[c(seq(4,9),11)],
#                                l_fd_exog_data    = colnames(data_set)[c(seq(3,9),11)],
#                                lags_fd_exog_data = 2,
#
#                                confint           = 1.67,
#                                hor               = 5)
#
## Plot irfs
#  plot(results_panel)
#
#
## Plot values of the transition function for USA between 1950 and 2016
#  library(ggplot2)
#
#  data_set %&gt;%
#     mutate(fz = results_panel$fz$fz) %&gt;%
#     select(country, year, fz)     %&gt;%
#     filter(country == "USA" &amp; year &gt; 1950  &amp; year &lt;= 2016) %&gt;%
#     ggplot()+
#     geom_line(aes(x = year, y = fz)) +
#     scale_x_continuous(breaks = seq(1950, 2016, 5))
#
#
##############################################################################
###                           Use GMM                                      ###
##############################################################################
#
## Use a much smaller sample to have fewer T than N
#  data_sample &lt;-   seq(2000, 2012)
#
#
## Estimate panel model with gmm
## This example (please uncomment) gives a warning at each iteration.
## The data set is not well suited for
## GMM as GMM is based on N-asymptotics and the data set only contains 27 countries
#
# results_panel &lt;-  lp_nl_panel(data_set           = data_set,
#                               data_sample       = data_sample,
#                               endog_data        = "mortgdp",
#                               cumul_mult        = TRUE,
#
#                               shock             = "stir",
#                               diff_shock        = TRUE,
#
#                               use_gmm            = TRUE,
#                               gmm_model          = "onestep",
#                               gmm_effect         = "twoways",
#                               gmm_transformation = "ld",
#
#                               switching         = "lrgdp",
#                               lag_switching     = TRUE,
#                               use_hp            = TRUE,
#                               lambda            = 6.25,
#                               gamma             = 10,
#
#                               l_exog_data       = "mortgdp",
#                               lags_exog_data    = 1,
#
#                               confint           = 1.67,
#                               hor               = 5)
#
## Create and plot irfs
# plot(results_panel)


</code></pre>

<hr>
<h2 id='lpirfs_obj-methods-base'>Base methods for lpirfs_obj objects</h2><span id='topic+lpirfs_obj-methods-base'></span>

<h3>Description</h3>

<p>Base methods for lpirfs_obj objects
</p>

<hr>
<h2 id='monetary_var_data'>Data to estimate a standard monetary VAR</h2><span id='topic+monetary_var_data'></span>

<h3>Description</h3>

<p>A tibble, containing data to estimate a standard monetary VAR.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>monetary_var_data
</code></pre>


<h3>Format</h3>

<p>A tibble with 494 monthly observations (rows) and 6 variables (columns):
</p>

<dl>
<dt>EM</dt><dd><p>Log of non-agricultural payroll employment.</p>
</dd>
<dt>P</dt><dd><p>Log of personal consumption expenditures deflator (1996 = 100).</p>
</dd>
<dt>POCM</dt><dd><p>Annual growth rate of the index of sensitive materials
prices issued by the Conference Board.</p>
</dd>
<dt>FF</dt><dd><p>Federal funds rate.</p>
</dd>
<dt>NBRX</dt><dd><p>Ratio of nonborrowed reserves plus extended credit to total reserves.</p>
</dd>
<dt>M2</dt><dd><p>Annual growth rate of M2 stock.</p>
</dd>
</dl>

<p>Sample: 1960:01 - 2001:02.
</p>


<h3>Source</h3>

<p><a href="https://www.aeaweb.org/articles?id=10.1257/0002828053828518">https://www.aeaweb.org/articles?id=10.1257/0002828053828518</a>
</p>


<h3>References</h3>

<p>Jordà, Ò. (2005) &quot;Estimation and Inference of Impulse Responses by Local Projections.&quot;
<em>American Economic Review</em>, 95 (1): 161-182.
</p>

<hr>
<h2 id='newey_west'>Compute OLS parameters and robust standard errors based on Newey-West estimator</h2><span id='topic+newey_west'></span>

<h3>Description</h3>

<p>Compute OLS parameters and robust standard errors based on Newey and West (1987).
The function is based on the Matlab code by James P. LeSage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newey_west(y, x, h)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="newey_west_+3A_y">y</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
<tr><td><code id="newey_west_+3A_x">x</code></td>
<td>
<p>Numeric matrix.</p>
</td></tr>
<tr><td><code id="newey_west_+3A_h">h</code></td>
<td>
<p>Integer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list. The first element contains the estimated OLS parameters, the second element
the Newey West covariance matrix, the third element the estimated functions, the fourth element
the unscaled covariance matrix and the last element the meat estimator.
</p>


<h3>References</h3>

<p>Newey, W.K., and West, K.D. (1987). “A Simple, Positive-Definite, Heteroskedasticity and
Autocorrelation Consistent Covariance Matrix.” <em>Econometrica</em>, 55, 703–708.
</p>

<hr>
<h2 id='newey_west_pw'>Compute Newey-West estimator with prewhitened estimation functions</h2><span id='topic+newey_west_pw'></span>

<h3>Description</h3>

<p>Compute Newey-West estimator with prewhitened estimation functions.
The function is based on the Matlab code by James P. LeSage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newey_west_pw(hhat_mat, xpxi_mat, D_mat, h)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="newey_west_pw_+3A_hhat_mat">hhat_mat</code></td>
<td>
<p>Matrix.</p>
</td></tr>
<tr><td><code id="newey_west_pw_+3A_xpxi_mat">xpxi_mat</code></td>
<td>
<p>Matrix.</p>
</td></tr>
<tr><td><code id="newey_west_pw_+3A_d_mat">D_mat</code></td>
<td>
<p>Matrix.</p>
</td></tr>
<tr><td><code id="newey_west_pw_+3A_h">h</code></td>
<td>
<p>integer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list. The first element contains the pre-whitened Newey West covariance matrix.
</p>


<h3>References</h3>

<p>Andrews, D.W. and Monahan, J.C. (1992). An improved heteroskedasticity and
autocorrelation consistent covariance matrix estimator. <em>Econometrica</em>, pp.953-966.
</p>
<p>Newey, W.K., and West, K.D. (1987). “A Simple, Positive-Definite, Heteroskedasticity and
Autocorrelation Consistent Covariance Matrix.” <em>Econometrica</em>, 55, 703–708.
</p>

<hr>
<h2 id='newey_west_tsls'>Compute 2SLS parameters and robust standard errors based on Newey-West</h2><span id='topic+newey_west_tsls'></span>

<h3>Description</h3>

<p>Compute 2SLS parameters and robust standard errors based on Newey and West (1987).
Part of the function is based on the Matlab code by James P. LeSage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newey_west_tsls(y, x, z, h)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="newey_west_tsls_+3A_y">y</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
<tr><td><code id="newey_west_tsls_+3A_x">x</code></td>
<td>
<p>Numeric matrix.</p>
</td></tr>
<tr><td><code id="newey_west_tsls_+3A_z">z</code></td>
<td>
<p>Numeric matrix.</p>
</td></tr>
<tr><td><code id="newey_west_tsls_+3A_h">h</code></td>
<td>
<p>Integer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list. The first element contains the estimated 2SLS parameters and the second element
the 2SLS-Newey-West covariance matrix of these parameters.  The third element contains the estimated functions, the fourth element
the unscaled covariance matrix, the fifth element the meat estimator and the last element the ordinary covariance matrix of the
point estimates.
</p>


<h3>References</h3>

<p>Newey, W.K., and West, K.D. (1987). “A Simple, Positive-Definite, Heteroskedasticity and
Autocorrelation Consistent Covariance Matrix.” <em>Econometrica</em>, 55, 703–708.
Wooldridge, J.M. (2002), Econometric Analysis of Cross Section and Panel Data, The MIT Press.
</p>

<hr>
<h2 id='ols_diagnost'>Compute diagnostics for OLS models</h2><span id='topic+ols_diagnost'></span>

<h3>Description</h3>

<p>Compute OLS diagnostics such as R^2, adjusted R^2, AIC, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ols_diagnost(y, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ols_diagnost_+3A_y">y</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
<tr><td><code id="ols_diagnost_+3A_x">x</code></td>
<td>
<p>Numeric matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list:
</p>
<table role = "presentation">
<tr><td><code>beta</code></td>
<td>
<p>Point estimates of OLS regression.</p>
</td></tr>
<tr><td><code>beta_cov</code></td>
<td>
<p>Covariance matrix of point estimates.</p>
</td></tr>
<tr><td><code>R^2</code></td>
<td>
<p>The R^2 statistic from OLS regression. </p>
</td></tr>
<tr><td><code>Adj.R^2</code></td>
<td>
<p>The adjusted R^2 staistic from OLS regression.</p>
</td></tr>
<tr><td><code>F-stat</code></td>
<td>
<p>The computed F-statistic.</p>
</td></tr>
<tr><td><code>df1</code></td>
<td>
<p>First degress of freedom for F-statistic.</p>
</td></tr>
<tr><td><code>df2</code></td>
<td>
<p>Second degrees of freedom for F-staitisc.</p>
</td></tr>
<tr><td><code>AIC_c</code></td>
<td>
<p>The AIC_c criterion by Hurvich and Tsai (1989)</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>The AIC criterion by Akaike (1974)</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>The BIC criterion by Schwarz and Gideon (1978)</p>
</td></tr>
</table>


<h3>References</h3>

<p>Akaike, H. (1974). &quot;A new look at the statistical model identification&quot;, <em>IEEE Transactions on Automatic Control</em>, 19 (6): 716–723.
</p>
<p>Hurvich, C. M., and Tsai, C.-L. (1989). &quot;Regression and time series model selection
in small samples&quot;, Biometrika, 76(2): 297–307,
</p>
<p>Schwarz, G.(1978). &quot;Estimating the dimension of a model&quot;, <em>Annals of Statistics</em>, 6 (2): 461–464.
</p>

<hr>
<h2 id='plot_lin'>Compute and display plots of linear impulse responses</h2><span id='topic+plot_lin'></span>

<h3>Description</h3>

<p>Compute and display linear impulse responses, estimated with <a href="#topic+lp_lin">lp_lin</a>() and <a href="#topic+lp_lin_iv">lp_lin_iv</a>().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_lin(results_lin)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_lin_+3A_results_lin">results_lin</code></td>
<td>
<p>A <a href="base.html#topic+list">list</a> created with <a href="#topic+lp_lin">lp_lin</a>() or <a href="#topic+lp_lin_iv">lp_lin_iv</a>().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with (gg-)plots for linear impulse responses.
</p>


<h3>Author(s)</h3>

<p>Philipp Adämmer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# See examples for lp_lin() and lp_lin_iv().
 
</code></pre>

<hr>
<h2 id='plot_nl'>Compute and display plots of nonlinear impulse responses</h2><span id='topic+plot_nl'></span>

<h3>Description</h3>

<p>Compute and display (nonlinear) impulse responses, estimated with <a href="#topic+lp_nl">lp_nl</a>() and <a href="#topic+lp_nl_iv">lp_nl_iv</a>().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_nl(results_nl)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_nl_+3A_results_nl">results_nl</code></td>
<td>
<p>A <a href="base.html#topic+list">list</a> created with <a href="#topic+lp_nl">lp_nl</a>() or <a href="#topic+lp_nl_iv">lp_nl_iv</a>().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with (gg-)plots for nonlinear impulse responses.
</p>


<h3>Author(s)</h3>

<p>Philipp Adämmer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load package

 # See examples for lp_nl() and lp_nl_iv().

 
</code></pre>

<hr>
<h2 id='plot.lpirfs_lin_iv_obj'>Base print() function to plot all impulse responses from linear lpirfs object</h2><span id='topic+plot.lpirfs_lin_iv_obj'></span>

<h3>Description</h3>

<p>Base print() function to plot all impulse responses from linear lpirfs object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpirfs_lin_iv_obj'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.lpirfs_lin_iv_obj_+3A_x">x</code></td>
<td>
<p>An object of type 'lpirfs_lin_obj</p>
</td></tr>
<tr><td><code id="plot.lpirfs_lin_iv_obj_+3A_...">...</code></td>
<td>
<p>Additional arguments to be consistent with S3 print() function</p>
</td></tr>
</table>

<hr>
<h2 id='plot.lpirfs_lin_obj'>Base print() function to plot all impulse responses from linear lpirfs object</h2><span id='topic+plot.lpirfs_lin_obj'></span>

<h3>Description</h3>

<p>Base print() function to plot all impulse responses from linear lpirfs object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpirfs_lin_obj'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.lpirfs_lin_obj_+3A_x">x</code></td>
<td>
<p>An object of type 'lpirfs_lin_obj</p>
</td></tr>
<tr><td><code id="plot.lpirfs_lin_obj_+3A_...">...</code></td>
<td>
<p>Additional arguments to be consistent with S3 print() function</p>
</td></tr>
</table>

<hr>
<h2 id='plot.lpirfs_lin_panel_obj'>Base print() function to plot all impulse responses from linear lpirfs object</h2><span id='topic+plot.lpirfs_lin_panel_obj'></span>

<h3>Description</h3>

<p>Base print() function to plot all impulse responses from linear lpirfs object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpirfs_lin_panel_obj'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.lpirfs_lin_panel_obj_+3A_x">x</code></td>
<td>
<p>An object of type 'lpirfs_lin_panel_obj'</p>
</td></tr>
<tr><td><code id="plot.lpirfs_lin_panel_obj_+3A_...">...</code></td>
<td>
<p>Additional arguments to be consistent with S3 print() function</p>
</td></tr>
</table>

<hr>
<h2 id='plot.lpirfs_nl_iv_obj'>Base print() function to plot all impulse responses from linear lpirfs object</h2><span id='topic+plot.lpirfs_nl_iv_obj'></span>

<h3>Description</h3>

<p>Base print() function to plot all impulse responses from linear lpirfs object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpirfs_nl_iv_obj'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.lpirfs_nl_iv_obj_+3A_x">x</code></td>
<td>
<p>An object of type 'lpirfs_nl_iv_obj'</p>
</td></tr>
<tr><td><code id="plot.lpirfs_nl_iv_obj_+3A_...">...</code></td>
<td>
<p>Additional arguments to be consistent with S3 print() function</p>
</td></tr>
</table>

<hr>
<h2 id='plot.lpirfs_nl_obj'>Base print() function to plot all impulse responses from nonlinear lpirfs object</h2><span id='topic+plot.lpirfs_nl_obj'></span>

<h3>Description</h3>

<p>Base print() function to plot all impulse responses from nonlinear lpirfs object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpirfs_nl_obj'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.lpirfs_nl_obj_+3A_x">x</code></td>
<td>
<p>An object of type 'lpirfs_nl_obj'</p>
</td></tr>
<tr><td><code id="plot.lpirfs_nl_obj_+3A_...">...</code></td>
<td>
<p>Additional arguments to be consistent with S3 print() function</p>
</td></tr>
</table>

<hr>
<h2 id='plot.lpirfs_nl_panel_obj'>Base print() function to plot all impulse responses from linear lpirfs object</h2><span id='topic+plot.lpirfs_nl_panel_obj'></span>

<h3>Description</h3>

<p>Base print() function to plot all impulse responses from linear lpirfs object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpirfs_nl_panel_obj'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.lpirfs_nl_panel_obj_+3A_x">x</code></td>
<td>
<p>An object of type 'lpirfs_lin_panel_obj'</p>
</td></tr>
<tr><td><code id="plot.lpirfs_nl_panel_obj_+3A_...">...</code></td>
<td>
<p>Additional arguments to be consistent with S3 print() function</p>
</td></tr>
</table>

<hr>
<h2 id='summary.lpirfs_lin_iv_obj'>Summary for nonlinear lpirfs object</h2><span id='topic+summary.lpirfs_lin_iv_obj'></span>

<h3>Description</h3>

<p>Summary for nonlinear lpirfs object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpirfs_lin_iv_obj'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.lpirfs_lin_iv_obj_+3A_object">object</code></td>
<td>
<p>An object of type 'lpirfs_lin_iv_obj'</p>
</td></tr>
<tr><td><code id="summary.lpirfs_lin_iv_obj_+3A_...">...</code></td>
<td>
<p>Additional arguments to be consistent with S3 print() function</p>
</td></tr>
</table>

<hr>
<h2 id='summary.lpirfs_lin_obj'>Summary for linear lpirfs object</h2><span id='topic+summary.lpirfs_lin_obj'></span>

<h3>Description</h3>

<p>Summary for linear lpirfs object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpirfs_lin_obj'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.lpirfs_lin_obj_+3A_object">object</code></td>
<td>
<p>An object of type 'lpirfs_lin_obj'</p>
</td></tr>
<tr><td><code id="summary.lpirfs_lin_obj_+3A_...">...</code></td>
<td>
<p>Additional arguments to be consistent with S3 print() function</p>
</td></tr>
</table>

<hr>
<h2 id='summary.lpirfs_lin_panel_obj'>Summary for nonlinear lpirfs object</h2><span id='topic+summary.lpirfs_lin_panel_obj'></span>

<h3>Description</h3>

<p>Summary for nonlinear lpirfs object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpirfs_lin_panel_obj'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.lpirfs_lin_panel_obj_+3A_object">object</code></td>
<td>
<p>An object of type 'lpirfs_lin_panel_obj'</p>
</td></tr>
<tr><td><code id="summary.lpirfs_lin_panel_obj_+3A_...">...</code></td>
<td>
<p>Additional arguments to be consistent with S3 print() function</p>
</td></tr>
</table>

<hr>
<h2 id='summary.lpirfs_nl_iv_obj'>Summary for nonlinear lpirfs object</h2><span id='topic+summary.lpirfs_nl_iv_obj'></span>

<h3>Description</h3>

<p>Summary for nonlinear lpirfs object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpirfs_nl_iv_obj'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.lpirfs_nl_iv_obj_+3A_object">object</code></td>
<td>
<p>An object of type 'lpirfs_nl_iv_obj'</p>
</td></tr>
<tr><td><code id="summary.lpirfs_nl_iv_obj_+3A_...">...</code></td>
<td>
<p>Additional arguments to be consistent with S3 print() function</p>
</td></tr>
</table>

<hr>
<h2 id='summary.lpirfs_nl_obj'>Summary for nonlinear lpirfs object</h2><span id='topic+summary.lpirfs_nl_obj'></span>

<h3>Description</h3>

<p>Summary for nonlinear lpirfs object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpirfs_nl_obj'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.lpirfs_nl_obj_+3A_object">object</code></td>
<td>
<p>An object of type 'lpirfs_nl_obj'</p>
</td></tr>
<tr><td><code id="summary.lpirfs_nl_obj_+3A_...">...</code></td>
<td>
<p>Additional arguments to be consistent with S3 print() function</p>
</td></tr>
</table>

<hr>
<h2 id='summary.lpirfs_nl_panel_obj'>Summary for nonlinear lpirfs object</h2><span id='topic+summary.lpirfs_nl_panel_obj'></span>

<h3>Description</h3>

<p>Summary for nonlinear lpirfs object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpirfs_nl_panel_obj'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.lpirfs_nl_panel_obj_+3A_object">object</code></td>
<td>
<p>An object of type 'lpirfs_lin_panel_obj'</p>
</td></tr>
<tr><td><code id="summary.lpirfs_nl_panel_obj_+3A_...">...</code></td>
<td>
<p>Additional arguments to be consistent with S3 print() function</p>
</td></tr>
</table>

<hr>
<h2 id='var_one'>Compute VAR to prewhite estimating functions for Newey West estimator.</h2><span id='topic+var_one'></span>

<h3>Description</h3>

<p>Compute Newey-West estimator with prewhitened estimation functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var_one(VAR_Data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="var_one_+3A_var_data">VAR_Data</code></td>
<td>
<p>Matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list. The first element contains the slope parameters of the VAR(1), the sedond element contains
the residuals and the third element the inverted slope parameter matrix.
</p>


<h3>References</h3>

<p>Andrews, D.W. and Monahan, J.C. (1992). An improved heteroskedasticity and
autocorrelation consistent covariance matrix estimator. <em>Econometrica</em>, pp.953-966.
</p>
<p>Newey, W.K., and West, K.D. (1987). “A Simple, Positive-Definite, Heteroskedasticity and
Autocorrelation Consistent Covariance Matrix.” <em>Econometrica</em>, 55, 703–708.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
