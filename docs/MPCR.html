<!DOCTYPE html><html><head><title>Help for package MPCR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MPCR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#01-MPCR'><p>MPCR S4 Class</p></a></li>
<li><a href='#02-MPCRTile'><p>MPCRTile S4 Class</p></a></li>
<li><a href='#03-Converters'><p>Converters</p></a></li>
<li><a href='#04-Arithmetic'><p>Binary arithmetic numeric/MPCR objects.</p></a></li>
<li><a href='#05-Comparison'><p>Binary comparison operators for numeric/MPCR objects.</p></a></li>
<li><a href='#06-Extract-Replace'><p>Extract or replace elements from an MPCR object.</p></a></li>
<li><a href='#07-Dimensions'><p>dimensions</p></a></li>
<li><a href='#08-Copy'><p>copy</p></a></li>
<li><a href='#09-Concatenate'><p>concatenate</p></a></li>
<li><a href='#10-Bind'><p>bind</p></a></li>
<li><a href='#11-Diagonal'><p>diag</p></a></li>
<li><a href='#12-Extremes'><p>Min-Max Functions</p></a></li>
<li><a href='#13-Log'><p>Logarithms and Exponentials</p></a></li>
<li><a href='#14-Mathis'><p>Finite, infinite, and NaNs</p></a></li>
<li><a href='#15-Miscmath'><p>Miscellaneous mathematical functions</p></a></li>
<li><a href='#16-NA's'><p>NA's</p></a></li>
<li><a href='#17-Replicate'><p>replicate</p></a></li>
<li><a href='#18-Round'><p>Rounding functions</p></a></li>
<li><a href='#19-Scale'><p>scale</p></a></li>
<li><a href='#20-Sweep'><p>sweep</p></a></li>
<li><a href='#21-Special Math'><p>Special mathematical functions.</p></a></li>
<li><a href='#22-Trig'><p>Trigonometric functions</p></a></li>
<li><a href='#23-Hyperbolic'><p>Hyperbolic functions</p></a></li>
<li><a href='#24-Transpose'><p>transpose</p></a></li>
<li><a href='#25-Check precision'><p>Metadata functions</p></a></li>
<li><a href='#26-Metadata'><p>Metadata functions</p></a></li>
<li><a href='#27-Print'><p>print</p></a></li>
<li><a href='#28-Cholesky decomposition'><p>cholesky decomposition</p></a></li>
<li><a href='#29-Cholesky inverse'><p>cholesky inverse</p></a></li>
<li><a href='#30-Crossprod'><p>crossprod</p></a></li>
<li><a href='#31-Eigen decomposition'><p>eigen decomposition</p></a></li>
<li><a href='#32-Symmetric'><p>isSymmetric</p></a></li>
<li><a href='#33-Norm'><p>norm</p></a></li>
<li><a href='#34-QR decomposition'><p>QR decomposition</p></a></li>
<li><a href='#35-Reciprocal condition'><p>reciprocal condition</p></a></li>
<li><a href='#36-Solve'><p>solve</p></a></li>
<li><a href='#37-Singular value decomposition'><p>SVD</p></a></li>
<li><a href='#38-Back/Forward solve'><p>Back/Forward solve</p></a></li>
<li><a href='#39-MPCR GEMM'><p>MPCR GEMM  (Matrix-Matrix Multiplication)</p></a></li>
<li><a href='#40-MPCR TRSM'><p>MPCR TRSM  (Triangular Solve)</p></a></li>
<li><a href='#41-MPCRTile GEMM'><p>MPCRTile GEMM  (Matrix-Matrix Multiplication)</p></a></li>
<li><a href='#42-MPCRTile POTRF'><p>MPCRTile Chol  ( Cholesky decomposition )</p></a></li>
<li><a href='#43-MPCRTile TRSM'><p>MPCRTile TRSM  (Triangular Solve)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multi- And Mixed-Precision Computations</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-22</td>
</tr>
<tr>
<td>Author:</td>
<td>David Helmy [aut],
  Sameh Abdulah [cre],
  KAUST King Abdullah University of Science and Technology [fnd, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sameh Abdulah &lt;sameh.abdulah@kaust.edu.sa&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Designed for multi- and mixed-precision computations, accommodating 64-bit and 32-bit data structures. This flexibility enables fast execution across various applications. The package enhances performance by optimizing operations in both precision levels, which is achieved by integrating with high-speed 'BLAS' and 'LAPACK' libraries like 'MKL' and 'OpenBLAS'. Including a 32-bit option caters to applications where high precision is unnecessary, accelerating computational processes whenever feasible. The package also provides support for tile-based algorithms in three linear algebra operations: CHOL(), TRSM(), and GEMM(). The tile-based algorithm splits the matrix into smaller tiles, facilitating parallelization through a predefined Directed Acyclic Graph (DAG) for each operation. Enabling 'OpenMP' enhances the efficiency of these operations, leveraging multi-core parallelism. In this case, 'MPCR' facilitates mixed-precision execution by permitting varying precision levels for different tiles. This approach is advantageous in numerous applications, as it maintains the accuracy of the application while accelerating execution in scenarios where single-precision alone does not significantly affect the accuracy of the application.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, Rcpp (&ge; 1.0.9)</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>CMake (&gt;=3.20) , C++ (&gt;= 11)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>OS_type:</td>
<td>unix</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/stsds/MPCR">https://github.com/stsds/MPCR</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/stsds/MPCR/issues">https://github.com/stsds/MPCR/issues</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-22 08:48:16 UTC; david</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-19 19:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='01-MPCR'>MPCR S4 Class</h2><span id='topic+MPCR'></span><span id='topic+Rcpp_MPCR-class'></span><span id='topic+MPCR.Serialize'></span><span id='topic+MPCR.DeSerialize'></span>

<h3>Description</h3>

<p>MPCR is a multi-precision vector/matrix, that enables the creation of vector/matrix with three different precisions (16-bit (half), 32-bit(single), and 64-bit(double)).
</p>


<h3>Value</h3>

<p>MPCR object (constructor - accessors - methods)
</p>


<h3>Constructor</h3>

<p><code><a href="methods.html#topic+new">new</a></code> Creates a new instance of zero values of the <code>MPCR</code> class.
<code>new(MPCR,size, "precision")</code>
</p>

<dl>
<dt><code>size</code></dt><dd><p>The total number of values for which memory needs to be allocated.</p>
</dd>
<dt><code>precision</code></dt><dd><p>String to indicate the precision of MPCR object (&quot;half&quot;,&quot;single&quot;, or &quot;double&quot;).</p>
</dd>
</dl>



<h3>Accessors</h3>

<p>The following accessors can be used to get the values of the slots:
</p>

<dl>
<dt><code>IsMatrix</code></dt><dd><p>Boolean to indicate whether the MPCR object is a vector or matrix.</p>
</dd>
<dt><code>Size</code></dt><dd><p>Total number of elements inside the object, (row*col) in the case of matrix, and number of elements in the case of vector.</p>
</dd>
<dt><code>Row</code></dt><dd><p>Number of rows.</p>
</dd>
<dt><code>Col</code></dt><dd><p>Number of cols.</p>
</dd>
</dl>



<h3>Methods</h3>

<p>The following methods are available for objects of class <code>MPCR</code>:
</p>


<h4>PrintValues</h4>

<p><code>PrintValues()</code>: Prints all the values stored in the matrix or vector, along with metadata about the object.
</p>



<h4>ToMatrix</h4>

<p><code>ToMatrix(row,col)</code>: Changes the object representation to match the new dimensions, no memory overhead.
</p>



<h4>ToVector</h4>

<p><code>ToVector()</code>: Changes the MPCR matrix to vector, no memory overhead.
</p>



<h3>Examples</h3>

<pre><code class='language-R'>  
    # Example usage of the class and its methods
    library(MPCR)
    MPCR_object &lt;- new(MPCR,50,"single")

    MPCR_object$ToMatrix(5,10)
    MPCR_object$Row       #5
    MPCR_object$Col       #10
    MPCR_object$Size      #50
    MPCR_object$IsMatrix  #TRUE

    MPCR_object$PrintValues()
    MPCR_object$ToVector()

    MPCR_object
  
</code></pre>

<hr>
<h2 id='02-MPCRTile'>MPCRTile S4 Class</h2><span id='topic+MPCRTile'></span><span id='topic+Rcpp_MPCRTile-class'></span><span id='topic+MPCRTile.GetSerializedTile'></span><span id='topic+MPCRTile.GetTile'></span><span id='topic+MPCRTile.UpdateTile'></span>

<h3>Description</h3>

<p>MPCRTile is a data structure for tile matrices with mixed precision, where each tile possesses a specific precision level.
</p>


<h3>Value</h3>

<p>MPCRTile object (constructor - accessors - methods)
</p>


<h3>Constructor</h3>

<p><code><a href="methods.html#topic+new">new</a></code> creates a new instance of Tile-Matrix <code>MPCRTile</code> class.
<br />
<code>new(MPCRTile,rows,cols,rows_per_tile,cols_per_tile,values,precisions)</code>
</p>

<dl>
<dt><code>rows</code></dt><dd><p>Number of rows in the matrix.</p>
</dd>
<dt><code>cols</code></dt><dd><p>Number of cols in the matrix.</p>
</dd>
<dt><code>rows_per_tile</code></dt><dd><p>Number of rows in each tile.</p>
</dd>
<dt><code>cols_per_tile</code></dt><dd><p>Number of cols in each tile.</p>
</dd>
<dt><code>values</code></dt><dd><p>R matrix or vector containing all the values that should be in the matrix.</p>
</dd>
<dt><code>precisions</code></dt><dd><p>R matrix or vector of strings, containing precision type of each tile.</p>
</dd>
</dl>



<h3>Accessors</h3>

<p>The following accessors can be used to get the values of the slots:
</p>

<dl>
<dt><code>Size</code></dt><dd><p>Total number of elements inside the Matrix.</p>
</dd>
<dt><code>Row</code></dt><dd><p>Number of rows.</p>
</dd>
<dt><code>Col</code></dt><dd><p>Number of cols.</p>
</dd>
<dt><code>TileRow</code></dt><dd><p>Number of rows in each tile.</p>
</dd>
<dt><code>TileCol</code></dt><dd><p>Number of cols in each tile.</p>
</dd>
<dt><code>TileSize</code></dt><dd><p>Total number of elements in each tile.</p>
</dd>
</dl>



<h3>Methods</h3>

<p>The following methods are available for objects of class <code>MPCRTile</code>:
</p>


<h4>PrintTile</h4>

<p><br />
<code>PrintTile(tile_row_idx,tile_col_idx)</code>: Prints all the values stored inside a specific tile plus meta-data about the tile.
<br />
</p>

<dl>
<dt><code>tile_row_idx</code></dt><dd><p>Row index of the tile.</p>
</dd>
<dt><code>tile_col_idx</code></dt><dd><p>Col index of the tile.</p>
</dd>
</dl>




<h4>ChangeTilePrecision</h4>

<p><br />
<code>ChangeTilePrecision(tile_row_idx,tile_col_idx,precision)</code>: Change the precision of specific tile, this function will need to copy all the values to cast them to the new precision.
<br />
</p>

<dl>
<dt><code>tile_row_idx</code></dt><dd><p>Row index of the tile.</p>
</dd>
<dt><code>tile_col_idx</code></dt><dd><p>Col index of the tile.</p>
</dd>
<dt><code>precision</code></dt><dd><p>Required new precision as a string.</p>
</dd>
</dl>




<h4>FillSquareTriangle</h4>

<p><br />
<code>FillSquareTriangle(value,upper.tri,precision)</code>: Fills upper or lower triangle
with a given value and precision, new tiles will be created,
replacing the old tiles. <b>Note:</b> The input must be a square matrix
<br />
</p>

<dl>
<dt><code>value</code></dt><dd><p> A value used during matrix filling.</p>
</dd>
<dt><code>upper.tri</code></dt><dd><p>A flag to indicate what triangle to fill. if TRUE, the upper triangle will be filled, otherwise the lower triangle. </p>
</dd>
<dt><code>precision</code></dt><dd><p>The precision of the tiles created during matrix filling, in case it's not a diagonal tile.</p>
</dd>
</dl>




<h4>Sum</h4>

<p><code>Sum()</code>: Get the sum of all elements in all tiles in MPCRTile Matrix.
</p>



<h4>Prod</h4>

<p><code>Prod()</code>: Get the product of all elements in all tiles in MPCRTile Matrix.
</p>



<h3>Examples</h3>

<pre><code class='language-R'>  

  library(MPCR)
    # Example usage of the class and its methods
   a &lt;- matrix(1:36, 6, 6)
   b &lt;- c("double", "double", "single", "double",
          "half", "double", "half", "double",
          "single")

   tile_mat &lt;- new(MPCRTile, 6, 6, 2, 2, a, b)
   tile_mat
   sum &lt;- tile_mat$Sum()
   prod &lt;- tile_mat$Prod()
   tile_mat$PrintTile(1,1)
   tile_mat$ChangeTilePrecision(1,1,"single")

   n_rows &lt;- tile_mat$Row
   n_cols &lt;- tile_mat$Col
   total_size &lt;- tile_mat$Size
   rows_per_tile &lt;- tile_mat$TileRow
   cols_per_tile &lt;- tile_mat$TileCol
  
</code></pre>

<hr>
<h2 id='03-Converters'>Converters</h2><span id='topic+Converters'></span><span id='topic+MPCR.ToNumericVector'></span><span id='topic+MPCR.ToNumericMatrix'></span><span id='topic+as.MPCR'></span>

<h3>Description</h3>

<p>Converters from R to MPCR objects and vice-versa.
</p>


<h3>Value</h3>

<p>An MPCR or R numeric vector/matrix.
</p>


<h3>MPCR Converter</h3>


<p>Convert R object to MPCR object.

</p>


<h4>MPCR converters</h4>

<p><br />
<code>as.MPCR(data,nrow = 0,ncol = 0,precision)</code>: Converts R object to MPCR object.
<br />
</p>

<dl>
<dt><code>data</code></dt><dd><p>R matrix/vector.</p>
</dd>
<dt><code>nrow</code></dt><dd><p>Number of rows of the new MPCR matrix, <b>default = zero</b> which means a vector will be created.</p>
</dd>
<dt><code>ncol</code></dt><dd><p>Number of cols of the new MPCR matrix, <b>default = zero</b> which means a vector will be created.</p>
</dd>
<dt><code>precision</code></dt><dd><p>String indicates the precision of the new MPCR object (half, single, or double).</p>
</dd>
</dl>




<h3>R Converter</h3>


<p>Convert an MPCR object to R object.

</p>


<h4>R vector converter</h4>

<p><br />
<code>MPCR.ToNumericVector(x)</code>: Converts an MPCR object to a numeric R vector.
</p>

<dl>
<dt><code>x</code></dt><dd><p>MPCR object.</p>
</dd>
</dl>




<h4>R matrix converter</h4>

<p><br />
<code>MPCR.ToNumericMatrix(x)</code>: Converts an MPCR object to a numeric R matrix.
</p>

<dl>
<dt><code>x</code></dt><dd><p>MPCR object.</p>
</dd>
</dl>




<h3>Examples</h3>

<pre><code class='language-R'>   # Example usage of the class and its methods
   library(MPCR)
   a &lt;- matrix(1:36, 6, 6)
   MPCR_matrix &lt;- as.MPCR(a,nrow=6,ncol=6,precision="single")
   r_vector &lt;- MPCR.ToNumericVector(MPCR_matrix)
   r_vector
   r_matrix &lt;- MPCR.ToNumericMatrix(MPCR_matrix)
   r_matrix
</code></pre>

<hr>
<h2 id='04-Arithmetic'>Binary arithmetic numeric/MPCR objects.</h2><span id='topic+arithmetic'></span><span id='topic++2B+2CRcpp_MPCR+2CRcpp_MPCR-method'></span><span id='topic+-+2CRcpp_MPCR+2CRcpp_MPCR-method'></span><span id='topic++2A+2CRcpp_MPCR+2CRcpp_MPCR-method'></span><span id='topic++2F+2CRcpp_MPCR+2CRcpp_MPCR-method'></span><span id='topic++5E+2CRcpp_MPCR+2CRcpp_MPCR-method'></span><span id='topic++2B+2CRcpp_MPCR+2CBaseLinAlg-method'></span><span id='topic++2A+2CRcpp_MPCR+2CBaseLinAlg-method'></span><span id='topic+-+2CRcpp_MPCR+2CBaseLinAlg-method'></span><span id='topic++2F+2CRcpp_MPCR+2CBaseLinAlg-method'></span><span id='topic++5E+2CRcpp_MPCR+2CBaseLinAlg-method'></span><span id='topic+MPCR.Add'></span><span id='topic+MPCR.Divide'></span><span id='topic+MPCR.Subtract'></span><span id='topic+MPCR.Multiply'></span><span id='topic+MPCR.Power'></span>

<h3>Description</h3>

<p>Binary arithmetic for numeric/MPCR objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Rcpp_MPCR,Rcpp_MPCR'
e1 + e2

## S4 method for signature 'Rcpp_MPCR,Rcpp_MPCR'
e1 - e2

## S4 method for signature 'Rcpp_MPCR,Rcpp_MPCR'
e1 * e2

## S4 method for signature 'Rcpp_MPCR,Rcpp_MPCR'
e1 / e2

## S4 method for signature 'Rcpp_MPCR,Rcpp_MPCR'
e1 ^ e2

## S4 method for signature 'Rcpp_MPCR,BaseLinAlg'
e1 + e2

## S4 method for signature 'Rcpp_MPCR,BaseLinAlg'
e1 * e2

## S4 method for signature 'Rcpp_MPCR,BaseLinAlg'
e1 - e2

## S4 method for signature 'Rcpp_MPCR,BaseLinAlg'
e1 / e2

## S4 method for signature 'Rcpp_MPCR,BaseLinAlg'
e1 ^ e2

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="04-Arithmetic_+3A_e1">e1</code>, <code id="04-Arithmetic_+3A_e2">e2</code></td>
<td>

<p>Numeric/MPCR objects.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An MPCR object, matching the data type of the highest precision input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MPCR)
s1 &lt;- as.MPCR(1:20,nrow=2,ncol=10,"single")
s2 &lt;- as.MPCR(21:40,nrow=2,ncol=10,"double")

x &lt;- s1 + s2
typeof(x) # A 64-bit precision (double) MPCR matrix.

s3 &lt;- as.MPCR(1:20,nrow=2,ncol=10,"single")
x &lt;- s1 + s3
typeof(x) # A 32-bit precision (single) MPCR matrix.
</code></pre>

<hr>
<h2 id='05-Comparison'>Binary comparison operators for numeric/MPCR objects.</h2><span id='topic+comparison'></span><span id='topic++3C+2CRcpp_MPCR+2CRcpp_MPCR-method'></span><span id='topic++3C+3D+2CRcpp_MPCR+2CRcpp_MPCR-method'></span><span id='topic++3D+3D+2CRcpp_MPCR+2CRcpp_MPCR-method'></span><span id='topic++21+3D+2CRcpp_MPCR+2CRcpp_MPCR-method'></span><span id='topic++3E+2CRcpp_MPCR+2CRcpp_MPCR-method'></span><span id='topic++3E+3D+2CRcpp_MPCR+2CRcpp_MPCR-method'></span><span id='topic++3C+2CRcpp_MPCR+2CBaseLinAlg-method'></span><span id='topic++3C+3D+2CRcpp_MPCR+2CBaseLinAlg-method'></span><span id='topic++3D+3D+2CRcpp_MPCR+2CBaseLinAlg-method'></span><span id='topic++21+3D+2CRcpp_MPCR+2CBaseLinAlg-method'></span><span id='topic++3E+2CRcpp_MPCR+2CBaseLinAlg-method'></span><span id='topic++3E+3D+2CRcpp_MPCR+2CBaseLinAlg-method'></span>

<h3>Description</h3>

<p>Binary comparison operators for numeric/MPCR objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S4 method for signature 'Rcpp_MPCR,Rcpp_MPCR'
e1 &lt; e2

## S4 method for signature 'Rcpp_MPCR,Rcpp_MPCR'
e1 &lt;= e2

## S4 method for signature 'Rcpp_MPCR,Rcpp_MPCR'
e1 == e2

## S4 method for signature 'Rcpp_MPCR,Rcpp_MPCR'
e1 != e2

## S4 method for signature 'Rcpp_MPCR,Rcpp_MPCR'
e1 &gt; e2

## S4 method for signature 'Rcpp_MPCR,Rcpp_MPCR'
e1 &gt;= e2

## S4 method for signature 'Rcpp_MPCR,BaseLinAlg'
e1 &lt; e2

## S4 method for signature 'Rcpp_MPCR,BaseLinAlg'
e1 &lt;= e2

## S4 method for signature 'Rcpp_MPCR,BaseLinAlg'
e1 == e2

## S4 method for signature 'Rcpp_MPCR,BaseLinAlg'
e1 != e2

## S4 method for signature 'Rcpp_MPCR,BaseLinAlg'
e1 &gt; e2

## S4 method for signature 'Rcpp_MPCR,BaseLinAlg'
e1 &gt;= e2


</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="05-Comparison_+3A_e1">e1</code>, <code id="05-Comparison_+3A_e2">e2</code></td>
<td>

<p>Numeric/MPCR objects.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector/matrix of logicals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  library(MPCR)
  s1 &lt;- as.MPCR(1:20,nrow=2,ncol=10,"single")
  s2 &lt;- as.MPCR(21:40,nrow=2,ncol=10,"double")

  x &lt;- s1 &gt; s2

</code></pre>

<hr>
<h2 id='06-Extract-Replace'>Extract or replace elements from an MPCR object.</h2><span id='topic++5B+2CRcpp_MPCR-method'></span><span id='topic++5B+5B+2CRcpp_MPCR-method'></span><span id='topic++5B+3C-+2CRcpp_MPCR-method'></span><span id='topic++5B+5B+3C-+2CRcpp_MPCR-method'></span>

<h3>Description</h3>

<p>Extract or replace elements from an MPCR object using the '[', '[[', '[&lt;-', and '[[&lt;-' operators.
When extracting values, they will be converted to double precision. However, if you update a single object, the double value will be cast down to match the precision.
If the MPCR object is a matrix and you access it using the 'i' index, the operation is assumed to be performed in column-major order, or using 'i' and 'j' index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S4 method for signature 'Rcpp_MPCR'
x[i, j, drop = TRUE]
  ## S4 replacement method for signature 'Rcpp_MPCR'
x[i, j, ...] &lt;- value
  ## S4 method for signature 'Rcpp_MPCR'
x[[i, drop = TRUE]]
  ## S4 replacement method for signature 'Rcpp_MPCR'
x[[i, ...]] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="06-Extract-Replace_+3A_x">x</code></td>
<td>
<p>An MPCR object.</p>
</td></tr>
<tr><td><code id="06-Extract-Replace_+3A_i">i</code></td>
<td>
<p>Row index or indices.</p>
</td></tr>
<tr><td><code id="06-Extract-Replace_+3A_j">j</code></td>
<td>
<p>Column index or indices.</p>
</td></tr>
<tr><td><code id="06-Extract-Replace_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
<tr><td><code id="06-Extract-Replace_+3A_drop">drop</code></td>
<td>
<p>ignored.</p>
</td></tr>
<tr><td><code id="06-Extract-Replace_+3A_value">value</code></td>
<td>
<p>A value to replace the selected elements with.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>  library(MPCR)
    x &lt;-as.MPCR(1:50,precision="single")
    ext &lt;- x[5]
    x[5] &lt;- 0
    x$ToMatrix(5,10)
    x[2,5]
    x[3,5] &lt;- 100

</code></pre>

<hr>
<h2 id='07-Dimensions'>dimensions</h2><span id='topic+dimensions'></span><span id='topic+nrow+2CRcpp_MPCR-method'></span><span id='topic+ncol+2CRcpp_MPCR-method'></span><span id='topic+MPCR.ncol'></span><span id='topic+MPCR.nrow'></span>

<h3>Description</h3>

<p>Returns the number of rows or cols in an MPCR object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Rcpp_MPCR'
nrow(x)

## S4 method for signature 'Rcpp_MPCR'
ncol(x)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="07-Dimensions_+3A_x">x</code></td>
<td>
<p>An MPCR object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of rows/cols in an MPCR object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    library(MPCR)
    x &lt;- as.MPCR(1:16,4,4,"single")
    y &lt;- as.MPCR(1:20,4,5,"double")
    rows_x &lt;- nrow(x)
    cols_y &lt;- ncol(y)
</code></pre>

<hr>
<h2 id='08-Copy'>copy</h2><span id='topic+copy'></span><span id='topic+MPCR.copy'></span><span id='topic+MPCRTile.copy'></span>

<h3>Description</h3>

<p>Functions for copying MPCR objects.
</p>


<h3>Value</h3>

<p>An MPCR copy from the input object.
</p>


<h3>MPCR deep copy</h3>


<p>Create a copy of an MPCR object. Typically, using 'equal' creates a new pointer for the object, resulting in any modifications made to object one affecting object two as well.

</p>


<h4>copy</h4>

<p><br />
<code>MPCR.copy(x)</code>: Create a new copy of an MPCR object.
</p>

<dl>
<dt><code>x</code></dt><dd><p>MPCR object. </p>
</dd>
</dl>



<h3>MPCRTile deep copy</h3>


<p>Create a duplicate of an MPCRTile object. Usually, using 'equal' creates a new pointer for the object, causing any modifications made to object one to affect object two as well.

</p>


<h4>copy</h4>

<p><br />
<code>MPCRTile.copy(x)</code>: Create a new copy of an MPCRTile matrix.
</p>

<dl>
<dt><code>x</code></dt><dd><p>MPCRTile matrix. </p>
</dd>
</dl>




<h3>Examples</h3>

<pre><code class='language-R'>
   library(MPCR)
   # Example usage of the class and its methods
   a &lt;- matrix(1:36, 6, 6)
   MPCR_matrix &lt;- as.MPCR(a,nrow=6,ncol=6,precision="single")

   # Normal equal '=' will create a new pointer of the object, so any change in object A
   # will affect object B
   temp_MPCR_matrix = MPCR_matrix
   temp_MPCR_matrix[2,2] &lt;- 500
   MPCR_matrix[2,2]           #500


   MPCR_matrix_copy &lt;- MPCR.copy(MPCR_matrix)
   MPCR_matrix[2,2] &lt;-100
   MPCR_matrix_copy[2,2] &lt;- 200

   MPCR_matrix[2,2]           #100
   MPCR_matrix_copy[2,2]      #200
</code></pre>

<hr>
<h2 id='09-Concatenate'>concatenate</h2><span id='topic+concatenate'></span><span id='topic+MPCR.Concatenate+2CRcpp_MPCR-method'></span><span id='topic+MPCR.Concatenate'></span>

<h3>Description</h3>

<p><code>c()</code> function for MPCR objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Rcpp_MPCR'
MPCR.Concatenate(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="09-Concatenate_+3A_x">x</code></td>
<td>
<p>List of MPCR objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>MPCR object containing values from all objects in the list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MPCR)
x &lt;- as.MPCR(1:20,precision="single")
y &lt;- as.MPCR(1:20,precision="single")
list &lt;- c(x,y)
new_obj &lt;- MPCR.Concatenate(list)
</code></pre>

<hr>
<h2 id='10-Bind'>bind</h2><span id='topic+MPCR.rbind+2CRcpp_MPCR-method'></span><span id='topic+MPCR.cbind+2CRcpp_MPCR-method'></span><span id='topic+MPCR.rbind'></span><span id='topic+MPCR.cbind'></span>

<h3>Description</h3>

<p><code>rbind()</code> and <code>cbind()</code> for MPCR objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Rcpp_MPCR'
MPCR.rbind(x,y)

## S4 method for signature 'Rcpp_MPCR'
MPCR.cbind(x,y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="10-Bind_+3A_x">x</code></td>
<td>
<p>An MPCR object.</p>
</td></tr>
<tr><td><code id="10-Bind_+3A_y">y</code></td>
<td>
<p>An MPCR object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An MPCR object, matching the data type of the highest precision input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MPCR)
# create 2 MPCR matrix a,b
a &lt;- as.MPCR(1:20,nrow=2,ncol=10,"single")
b &lt;- as.MPCR(21:40,nrow=2,ncol=10,"double")

x &lt;- MPCR.rbind(a,b)
y &lt;- MPCR.cbind(a,b)

</code></pre>

<hr>
<h2 id='11-Diagonal'>diag</h2><span id='topic+diag'></span><span id='topic+MPCR.diag'></span><span id='topic+diag+2CRcpp_MPCR-method'></span>

<h3>Description</h3>

<p>Returns the diagonal of an MPCR matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Rcpp_MPCR'
diag(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="11-Diagonal_+3A_x">x</code></td>
<td>
<p>An MPCR matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An MPCR vector contains the main diagonal of the matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    library(MPCR)
    x &lt;- as.MPCR(1:16,4,4,"single")
    diag_vals &lt;- diag(x)
</code></pre>

<hr>
<h2 id='12-Extremes'>Min-Max Functions</h2><span id='topic+extremes'></span><span id='topic+min+2CRcpp_MPCR-method'></span><span id='topic+max+2CRcpp_MPCR-method'></span><span id='topic+which.min+2CRcpp_MPCR-method'></span><span id='topic+which.max+2CRcpp_MPCR-method'></span><span id='topic+MPCR.min'></span><span id='topic+MPCR.max'></span><span id='topic+MPCR.which.min'></span><span id='topic+MPCR.which.max'></span>

<h3>Description</h3>

<p>Min-Max functions for MPCR objects values and indices, all NA values are disregarded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Rcpp_MPCR'
min(x)

## S4 method for signature 'Rcpp_MPCR'
max(x)

## S4 method for signature 'Rcpp_MPCR'
which.min(x)

## S4 method for signature 'Rcpp_MPCR'
which.max(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="12-Extremes_+3A_x">x</code></td>
<td>

<p>An MPCR object.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Min/max value/index.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  library(MPCR)

  x &lt;- as.MPCR(1:20,precision="double")
  min &lt;-min(x)
  min_idx &lt;-which.min(x)

</code></pre>

<hr>
<h2 id='13-Log'>Logarithms and Exponentials</h2><span id='topic+log'></span><span id='topic+exp+2CRcpp_MPCR-method'></span><span id='topic+expm1+2CRcpp_MPCR-method'></span><span id='topic+log+2CRcpp_MPCR-method'></span><span id='topic+log10+2CRcpp_MPCR-method'></span><span id='topic+log2+2CRcpp_MPCR-method'></span><span id='topic+MPCR.exp'></span><span id='topic+MPCR.expm1'></span><span id='topic+MPCR.log'></span><span id='topic+MPCR.log10'></span><span id='topic+MPCR.log2'></span>

<h3>Description</h3>

<p>exp/log functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Rcpp_MPCR'
exp(x)

## S4 method for signature 'Rcpp_MPCR'
expm1(x)

## S4 method for signature 'Rcpp_MPCR'
log(x, base = 1)

## S4 method for signature 'Rcpp_MPCR'
log10(x)

## S4 method for signature 'Rcpp_MPCR'
log2(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="13-Log_+3A_x">x</code></td>
<td>

<p>An MPCR object.
</p>
</td></tr>
<tr><td><code id="13-Log_+3A_base">base</code></td>
<td>

<p>The logarithm base. If base = 1, exp(1) is assumed, only base 1,2, and 10 available.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An MPCR object of the same dimensions as the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(MPCR)

x &lt;- as.MPCR(1:20,precision="double")
log(x)

</code></pre>

<hr>
<h2 id='14-Mathis'>Finite, infinite, and NaNs</h2><span id='topic+mathis'></span><span id='topic+is.finite+2CRcpp_MPCR-method'></span><span id='topic+is.infinite+2CRcpp_MPCR-method'></span><span id='topic+is.nan+2CRcpp_MPCR-method'></span><span id='topic+MPCR.is.finite'></span><span id='topic+MPCR.is.infinite'></span><span id='topic+MPCR.is.nan'></span>

<h3>Description</h3>

<p>Finite, infinite, and NaNs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Rcpp_MPCR'
is.finite(x)

## S4 method for signature 'Rcpp_MPCR'
is.infinite(x)

## S4 method for signature 'Rcpp_MPCR'
is.nan(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="14-Mathis_+3A_x">x</code></td>
<td>

<p>An MPCR object.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A bool vector/matrix of the same dimensions as the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
  library(MPCR)

  x &lt;- as.MPCR(1:20,precision="double")
  is.nan(sqrt(x))
  
</code></pre>

<hr>
<h2 id='15-Miscmath'>Miscellaneous mathematical functions</h2><span id='topic+miscmath'></span><span id='topic+abs+2CRcpp_MPCR-method'></span><span id='topic+sqrt+2CRcpp_MPCR-method'></span><span id='topic+MPCR.abs'></span><span id='topic+MPCR.sqrt'></span>

<h3>Description</h3>

<p>Miscellaneous mathematical functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Rcpp_MPCR'
abs(x)

## S4 method for signature 'Rcpp_MPCR'
sqrt(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="15-Miscmath_+3A_x">x</code></td>
<td>

<p>An MPCR object.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An MPCR object of the same dimensions as the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(MPCR)

x &lt;- as.MPCR(1:20,precision="double")
sqrt(x)

</code></pre>

<hr>
<h2 id='16-NA+27s'>NA's</h2><span id='topic+NA+27s'></span><span id='topic+MPCR.is.na+2CRcpp_MPCR-method'></span><span id='topic+MPCR.na.exclude+2CRcpp_MPCR-method'></span><span id='topic+MPCR.na.omit+2CRcpp_MPCR-method'></span><span id='topic+MPCR.is.na'></span><span id='topic+MPCR.na.exclude'></span><span id='topic+MPCR.na.omit'></span>

<h3>Description</h3>

<p><code>is.na()</code> ,<code>na.omit()</code>,  and <code>na.exclude()</code> for MPCR objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Rcpp_MPCR'
MPCR.is.na(object,index=-1)
## S4 method for signature 'Rcpp_MPCR'
MPCR.na.exclude(object,value)
## S4 method for signature 'Rcpp_MPCR'
MPCR.na.omit(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="16-NA+2B27s_+3A_object">object</code></td>
<td>
<p>MPCR object.</p>
</td></tr>
<tr><td><code id="16-NA+2B27s_+3A_index">index</code></td>
<td>
<p>If a particular index in the MPCR matrix/vector is specified, it will be checked. If no index is provided, all elements will be checked.</p>
</td></tr>
<tr><td><code id="16-NA+2B27s_+3A_value">value</code></td>
<td>
<p>Value to replace all NAN with.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>MPCR.is.na will return matrix/vector/bool according to input of the function.
<br />
MPCR.na.exclude &amp; MPCR.na.omit will not return anything.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
library(MPCR)
x &lt;- as.MPCR(1:20,precision="single")
x[1] &lt;- NaN
MPCR.is.na(x,index=1) #TRUE
MPCR.na.exclude(x,50)
x[1]  #50

</code></pre>

<hr>
<h2 id='17-Replicate'>replicate</h2><span id='topic+replicate'></span><span id='topic+MPCR.rep'></span><span id='topic+rep+2CRcpp_MPCR-method'></span>

<h3>Description</h3>

<p>Replicates the given input number of times according to count/len , only one should be set at a time, and in case both
values are given, only the len value will have effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Rcpp_MPCR'
rep(x,count=0,len=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="17-Replicate_+3A_x">x</code></td>
<td>
<p>An MPCR object.</p>
</td></tr>
<tr><td><code id="17-Replicate_+3A_count">count</code></td>
<td>
<p>Value to determine how many times the input value will be replicated.</p>
</td></tr>
<tr><td><code id="17-Replicate_+3A_len">len</code></td>
<td>
<p>Value to determine the required output size, the input
will be replicated until it matches the output len size.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>MPCR vector containing the replicated values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
    library(MPCR)
    x &lt;- as.MPCR(1:16,4,4,"single")
    rep_vals_1 &lt;- rep(x,count=2)  #output size will be 16*2
    rep_vals_2 &lt;- rep(x,len=2)  #output size will be 2

</code></pre>

<hr>
<h2 id='18-Round'>Rounding functions</h2><span id='topic+round'></span><span id='topic+ceiling+2CRcpp_MPCR-method'></span><span id='topic+floor+2CRcpp_MPCR-method'></span><span id='topic+trunc+2CRcpp_MPCR-method'></span><span id='topic+round+2CRcpp_MPCR-method'></span><span id='topic+MPCR.ceiling'></span><span id='topic+MPCR.floor'></span><span id='topic+MPCR.trunc'></span><span id='topic+MPCR.round'></span>

<h3>Description</h3>

<p>Rounding functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Rcpp_MPCR'
ceiling(x)

## S4 method for signature 'Rcpp_MPCR'
floor(x)

## S4 method for signature 'Rcpp_MPCR'
trunc(x)

## S4 method for signature 'Rcpp_MPCR'
round(x, digits = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="18-Round_+3A_x">x</code></td>
<td>

<p>An MPCR object.
</p>
</td></tr>
<tr><td><code id="18-Round_+3A_digits">digits</code></td>
<td>

<p>The number of digits to use in rounding.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An MPCR object of the same dimensions as the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
  library(MPCR)

  input &lt;- runif(20,-1,1)
  x &lt;- as.MPCR(input,precision="double")
  floor(x)
  
</code></pre>

<hr>
<h2 id='19-Scale'>scale</h2><span id='topic+scale'></span><span id='topic+MPCR.scale'></span><span id='topic+scale+2CRcpp_MPCR-method'></span>

<h3>Description</h3>

<p>Center or scale an MPCR object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Rcpp_MPCR'
scale(x, center, scale)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="19-Scale_+3A_x">x</code></td>
<td>
<p>An MPCR object.</p>
</td></tr>
<tr><td><code id="19-Scale_+3A_center">center</code>, <code id="19-Scale_+3A_scale">scale</code></td>
<td>
<p>Logical or MPCR objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An MPCR matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
  library(MPCR)
    input &lt;-as.MPCR(1:50,precision="single")
    input$ToMatrix(5, 10)
    temp_center_scale &lt;- as.MPCR(1:10,precision="double")
    z &lt;- scale(x=input, center=FALSE, scale=temp_center_scale)

</code></pre>

<hr>
<h2 id='20-Sweep'>sweep</h2><span id='topic+sweep'></span><span id='topic+MPCR.sweep'></span><span id='topic+sweep+2CRcpp_MPCR-method'></span>

<h3>Description</h3>

<p>Sweep an MPCR vector through an MPCR matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Rcpp_MPCR'
sweep(x,stat,margin,FUN)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="20-Sweep_+3A_x">x</code></td>
<td>
<p>An MPCR object.</p>
</td></tr>
<tr><td><code id="20-Sweep_+3A_stat">stat</code></td>
<td>
<p>MPCR vector containing the value(s) that should be used in the operation.</p>
</td></tr>
<tr><td><code id="20-Sweep_+3A_margin">margin</code></td>
<td>
<p>1 means row; otherwise means column.</p>
</td></tr>
<tr><td><code id="20-Sweep_+3A_fun">FUN</code></td>
<td>
<p>Sweeping function; must be one of <code>"+"</code>, <code>"-"</code>, <code>"*"</code>, <code>"/"</code>, or
<code>"^"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An MPCR matrix of the same type as the highest precision input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(MPCR)
x &lt;- as.MPCR(1:20,10,2,"single")
y &lt;- as.MPCR(1:5,precision="double")
sweep_out &lt;- sweep(x, stat=y, margin=1, FUN="+")
MPCR.is.double(sweep_out)  #TRUE

</code></pre>

<hr>
<h2 id='21-Special+20Math'>Special mathematical functions.</h2><span id='topic+specialmath'></span><span id='topic+gamma+2CRcpp_MPCR-method'></span><span id='topic+lgamma+2CRcpp_MPCR-method'></span><span id='topic+MPCR.gamma'></span><span id='topic+MPCR.lgamma'></span>

<h3>Description</h3>

<p>Special mathematical functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Rcpp_MPCR'
gamma(x)

## S4 method for signature 'Rcpp_MPCR'
lgamma(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="21-Special+2B20Math_+3A_x">x</code></td>
<td>

<p>An MPCR object.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An MPCR object of the same dimensions as the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(MPCR)

x &lt;- as.MPCR(1:20,precision="double")
lgamma(x)

</code></pre>

<hr>
<h2 id='22-Trig'>Trigonometric functions</h2><span id='topic+trig'></span><span id='topic+sin+2CRcpp_MPCR-method'></span><span id='topic+cos+2CRcpp_MPCR-method'></span><span id='topic+tan+2CRcpp_MPCR-method'></span><span id='topic+asin+2CRcpp_MPCR-method'></span><span id='topic+acos+2CRcpp_MPCR-method'></span><span id='topic+atan+2CRcpp_MPCR-method'></span><span id='topic+MPCR.sin'></span><span id='topic+MPCR.cos'></span><span id='topic+MPCR.tan'></span><span id='topic+MPCR.asin'></span><span id='topic+MPCR.acos'></span><span id='topic+MPCR.atan'></span>

<h3>Description</h3>

<p>Basic trig functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Rcpp_MPCR'
sin(x)

## S4 method for signature 'Rcpp_MPCR'
cos(x)

## S4 method for signature 'Rcpp_MPCR'
tan(x)

## S4 method for signature 'Rcpp_MPCR'
asin(x)

## S4 method for signature 'Rcpp_MPCR'
acos(x)

## S4 method for signature 'Rcpp_MPCR'
atan(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="22-Trig_+3A_x">x</code></td>
<td>

<p>An MPCR object.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An MPCR object of the same dimensions as the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(MPCR)

mpcr_matrix &lt;- as.MPCR(1:20,nrow=2,ncol=10,"single")
x &lt;- sin(mpcr_matrix)

</code></pre>

<hr>
<h2 id='23-Hyperbolic'>Hyperbolic functions</h2><span id='topic+hyperbolic'></span><span id='topic+sinh+2CRcpp_MPCR-method'></span><span id='topic+cosh+2CRcpp_MPCR-method'></span><span id='topic+tanh+2CRcpp_MPCR-method'></span><span id='topic+asinh+2CRcpp_MPCR-method'></span><span id='topic+acosh+2CRcpp_MPCR-method'></span><span id='topic+atanh+2CRcpp_MPCR-method'></span><span id='topic+MPCR.sinh'></span><span id='topic+MPCR.cosh'></span><span id='topic+MPCR.tanh'></span><span id='topic+MPCR.asinh'></span><span id='topic+MPCR.acosh'></span><span id='topic+MPCR.atanh'></span>

<h3>Description</h3>

<p>These functions give the obvious hyperbolic functions. They respectively compute the hyperbolic cosine, sine, tangent, and their inverses, arc-cosine, arc-sine, arc-tangent (or 'area cosine', etc).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Rcpp_MPCR'
sinh(x)
## S4 method for signature 'Rcpp_MPCR'
cosh(x)
## S4 method for signature 'Rcpp_MPCR'
tanh(x)
## S4 method for signature 'Rcpp_MPCR'
asinh(x)
## S4 method for signature 'Rcpp_MPCR'
acosh(x)
## S4 method for signature 'Rcpp_MPCR'
atanh(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="23-Hyperbolic_+3A_x">x</code></td>
<td>

<p>An MPCR object.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An MPCR object of the same dimensions as the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
    library(MPCR)

    mpcr_matrix &lt;- as.MPCR(1:20,nrow=2,ncol=10,precision="single")
    x &lt;- sinh(mpcr_matrix)

</code></pre>

<hr>
<h2 id='24-Transpose'>transpose</h2><span id='topic+transpose'></span><span id='topic+MPCR.t'></span><span id='topic+t+2CRcpp_MPCR-method'></span>

<h3>Description</h3>

<p>Transpose an MPCR object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Rcpp_MPCR'
t(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="24-Transpose_+3A_x">x</code></td>
<td>
<p>An MPCR object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An MPCR object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
  library(MPCR)
  a &lt;- matrix(1:20, nrow = 2)
  a_MPCR &lt;- as.MPCR(a,2,10,"double")
  a_MPCR_transpose &lt;- t(a_MPCR)
  
</code></pre>

<hr>
<h2 id='25-Check+20precision'>Metadata functions</h2><span id='topic+Check+20Precision'></span><span id='topic+MPCR.is.single+2CRcpp_MPCR-method'></span><span id='topic+MPCR.is.double+2CRcpp_MPCR-method'></span><span id='topic+MPCR.is.half+2CRcpp_MPCR-method'></span><span id='topic+MPCR.is.float+2CRcpp_MPCR-method'></span><span id='topic+MPCR.is.single'></span><span id='topic+MPCR.is.double'></span><span id='topic+MPCR.is.half'></span><span id='topic+MPCR.is.float'></span>

<h3>Description</h3>

<p>Checks the precision of a given MPCR object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S4 method for signature 'Rcpp_MPCR'
MPCR.is.single(x)
## S4 method for signature 'Rcpp_MPCR'
MPCR.is.half(x)
## S4 method for signature 'Rcpp_MPCR'
MPCR.is.double(x)
## S4 method for signature 'Rcpp_MPCR'
MPCR.is.float(x)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="25-Check+2B20precision_+3A_x">x</code></td>
<td>

<p>An MPCR object.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Boolean indicates the precision of the object according to the used function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  library(MPCR)
  x &lt;- as.MPCR(1:20,precision="double")
  MPCR.is.double(x) #TRUE
  MPCR.is.single(x) #FALSE
</code></pre>

<hr>
<h2 id='26-Metadata'>Metadata functions</h2><span id='topic+metadata'></span><span id='topic+storage.mode+2CRcpp_MPCR-method'></span><span id='topic+typeof+2CRcpp_MPCR-method'></span><span id='topic+MPCR.ChangePrecision+2CRcpp_MPCR-method'></span><span id='topic+MPCR.object.size+2CRcpp_MPCR-method'></span><span id='topic+MPCR.storage.mode'></span><span id='topic+MPCR.typeof'></span><span id='topic+MPCR.ChangePrecision'></span><span id='topic+MPCR.object.size'></span>

<h3>Description</h3>

<p>Metadata functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Rcpp_MPCR'
storage.mode(x)
## S4 method for signature 'Rcpp_MPCR'
typeof(x)
## S4 method for signature 'Rcpp_MPCR'
MPCR.object.size(x)
## S4 method for signature 'Rcpp_MPCR'
MPCR.ChangePrecision(x,precision)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="26-Metadata_+3A_x">x</code></td>
<td>

<p>An MPCR object.
</p>
</td></tr>
<tr><td><code id="26-Metadata_+3A_precision">precision</code></td>
<td>

<p>String with the required precision.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints/change metadata about an MPCR object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  library(MPCR)

  x &lt;- as.MPCR(1:20,precision="double")
  typeof(x)
  MPCR.ChangePrecision(x,"single")
  MPCR.is.single(x) #True

</code></pre>

<hr>
<h2 id='27-Print'>print</h2><span id='topic+print'></span><span id='topic+MPCR.str'></span><span id='topic+print+2CRcpp_MPCR-method'></span><span id='topic+show+2CRcpp_MPCR-method'></span><span id='topic+MPCR.print'></span><span id='topic+MPCR.show'></span>

<h3>Description</h3>

<p>Prints the precision and type of the object, and print will print the meta data of the object without printing the values. Function x$PrintValues() should be used to print the values.&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Rcpp_MPCR'
print(x)

## S4 method for signature 'Rcpp_MPCR'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="27-Print_+3A_x">x</code>, <code id="27-Print_+3A_object">object</code></td>
<td>
<p>An MPCR objects.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints metadata about the object and some values.
</p>


<h3>Value</h3>

<p>A string containing the metadata of the MPCR object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
    library(MPCR)
    x &lt;- as.MPCR(1:16,4,4,"single")
    y &lt;- as.MPCR(1:20,4,5,"double")
    x
    print(y)
    
</code></pre>

<hr>
<h2 id='28-Cholesky+20decomposition'>cholesky decomposition</h2><span id='topic+chol'></span><span id='topic+chol+2CRcpp_MPCR-method'></span><span id='topic+MPCR.chol'></span>

<h3>Description</h3>

<p>Performs the Cholesky factorization of a positive definite MPCR matrix x.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Rcpp_MPCR'
chol(x,upper_triangle=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="28-Cholesky+2B20decomposition_+3A_x">x</code></td>
<td>
<p>An MPCR matrix.</p>
</td></tr>
<tr><td><code id="28-Cholesky+2B20decomposition_+3A_upper_triangle">upper_triangle</code></td>
<td>
<p>Boolean to check on which triangle the cholesky
decomposition should be applied.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An MPCR matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
  library(MPCR)
  x &lt;- as.MPCR(c(1.21, 0.18, 0.13, 0.41, 0.06, 0.23,
                 0.18, 0.64, 0.10, -0.16, 0.23, 0.07,
                 0.13, 0.10, 0.36, -0.10, 0.03, 0.18,
                 0.41, -0.16, -0.10, 1.05, -0.29, -0.08,
                 0.06, 0.23, 0.03, -0.29, 1.71, -0.10,
                 0.23, 0.07, 0.18, -0.08, -0.10, 0.36),6,6,precision="double")
  chol_out &lt;- chol(x)
  
</code></pre>

<hr>
<h2 id='29-Cholesky+20inverse'>cholesky inverse</h2><span id='topic+chol2inv'></span><span id='topic+chol2inv+2CRcpp_MPCR-method'></span><span id='topic+MPCR.chol2inv'></span>

<h3>Description</h3>

<p>Performs the inverse of the original matrix using the Cholesky factorization of an MPCR matrix x.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Rcpp_MPCR'
chol2inv(x, size = NCOL(x))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="29-Cholesky+2B20inverse_+3A_x">x</code></td>
<td>
<p>An MPCR object.</p>
</td></tr>
<tr><td><code id="29-Cholesky+2B20inverse_+3A_size">size</code></td>
<td>
<p>The number of columns to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An MPCR object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
  library(MPCR)
  x &lt;- as.MPCR(c(1.21, 0.18, 0.13, 0.41, 0.06, 0.23,
                 0.18, 0.64, 0.10, -0.16, 0.23, 0.07,
                 0.13, 0.10, 0.36, -0.10, 0.03, 0.18,
                 0.41, -0.16, -0.10, 1.05, -0.29, -0.08,
                 0.06, 0.23, 0.03, -0.29, 1.71, -0.10,
                 0.23, 0.07, 0.18, -0.08, -0.10, 0.36),6,6,precision="single")
  chol_out &lt;- chol(x)
  chol &lt;- chol2inv(chol_out)

</code></pre>

<hr>
<h2 id='30-Crossprod'>crossprod</h2><span id='topic+crossprod'></span><span id='topic+crossprod+2CRcpp_MPCR-method'></span><span id='topic+tcrossprod+2CRcpp_MPCR-method'></span><span id='topic+MPCR.crossprod'></span><span id='topic+MPCR.tcrossprod'></span>

<h3>Description</h3>

<p>Calculates the cross product of two MPCR matrices.
It uses BLAS routine <code>gemm()</code> for <b>A</b> X <b>B</b> operations and <code>syrk()</code>
for <b>A</b> X <b>A^T</b> operations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Rcpp_MPCR'
crossprod(x, y = NULL)

## S4 method for signature 'Rcpp_MPCR'
tcrossprod(x, y = NULL)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="30-Crossprod_+3A_x">x</code></td>
<td>
<p>An MPCR object.</p>
</td></tr>
<tr><td><code id="30-Crossprod_+3A_y">y</code></td>
<td>
<p>Either <code>NULL</code>, or an MPCR matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates cross product of two MPCR matrices performs:
<br />
x %*% y  , t(x) %*% x
<br />
This function uses blas routine <code>gemm()</code> for <b>A</b> X <b>B</b> operations  &amp; <code>syrk()</code> for <b>A</b> X <b>A^T</b> operations.
</p>


<h3>Value</h3>

<p>An MPCR matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    
    library(MPCR)
    x &lt;- as.MPCR(1:16,4,4,"single")
    y &lt;- as.MPCR(1:20,4,5,"double")

    z &lt;- crossprod(x)     # t(x) x
    z &lt;- tcrossprod(x)    # x t(x)
    z &lt;- crossprod(x,y)   # x y
    z &lt;- x %*% y          # x y
    
</code></pre>

<hr>
<h2 id='31-Eigen+20decomposition'>eigen decomposition</h2><span id='topic+eigen'></span><span id='topic+MPCR.eigen'></span><span id='topic+eigen+2CRcpp_MPCR-method'></span>

<h3>Description</h3>

<p>Solves a system of equations or invert an MPCR matrix, using lapack routine <code>syevr()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Rcpp_MPCR'
eigen(x, only.values = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="31-Eigen+2B20decomposition_+3A_x">x</code></td>
<td>
<p>An MPCR object.</p>
</td></tr>
<tr><td><code id="31-Eigen+2B20decomposition_+3A_only.values">only.values</code></td>
<td>
<p>(TRUE/FALSE)?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list contains MPCR objects describing the values and optionally vectors.
</p>

<hr>
<h2 id='32-Symmetric'>isSymmetric</h2><span id='topic+isSymmetric'></span><span id='topic+isSymmetric+2CRcpp_MPCR-method'></span><span id='topic+MPCR.isSymmetric'></span>

<h3>Description</h3>

<p>Check if a given MPCR matrix is symmetric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Rcpp_MPCR'
isSymmetric(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="32-Symmetric_+3A_object">object</code></td>
<td>
<p>An MPCR matrix.</p>
</td></tr>
<tr><td><code id="32-Symmetric_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
library(MPCR)

x &lt;- as.MPCR(1:50,25,2,"Single")
isSymmetric(x)                      #false

</code></pre>

<hr>
<h2 id='33-Norm'>norm</h2><span id='topic+norm'></span><span id='topic+MPCR.norm'></span><span id='topic+norm+2CRcpp_MPCR-method'></span>

<h3>Description</h3>

<p>Compute norm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Rcpp_MPCR'
norm(x, type = "O")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="33-Norm_+3A_x">x</code></td>
<td>
<p>An MPCR object.</p>
</td></tr>
<tr><td><code id="33-Norm_+3A_type">type</code></td>
<td>
<p>&quot;O&quot;-ne, &quot;I&quot;-nfinity, &quot;F&quot;-robenius, &quot;M&quot;-ax modulus, and &quot;1&quot; norms.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An MPCR object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  

library(MPCR)

x &lt;- as.MPCR(1:20,precision="double")
norm(x, type="O")

</code></pre>

<hr>
<h2 id='34-QR+20decomposition'>QR decomposition</h2><span id='topic+qr'></span><span id='topic+qr+2CRcpp_MPCR-method'></span><span id='topic+qr.Q+2CANY-method'></span><span id='topic+qr.R+2CANY-method'></span><span id='topic+MPCR.qr'></span><span id='topic+MPCR.qr.Q'></span><span id='topic+MPCR.qr.R'></span><span id='topic+MPCR.qr.qty'></span><span id='topic+MPCR.qr.qy'></span>

<h3>Description</h3>

<p>QR factorization and related functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Rcpp_MPCR'
qr(x, tol = 1e-07)

## S4 method for signature 'ANY'
qr.Q(qr, complete = FALSE, Dvec)

## S4 method for signature 'ANY'
qr.R(qr, complete = FALSE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="34-QR+2B20decomposition_+3A_x">x</code></td>
<td>
<p>An MPCR matrix.</p>
</td></tr>
<tr><td><code id="34-QR+2B20decomposition_+3A_qr">qr</code></td>
<td>
<p>QR decomposition MPCR object.</p>
</td></tr>
<tr><td><code id="34-QR+2B20decomposition_+3A_tol">tol</code></td>
<td>
<p>The tolerance for determining numerical column rank.</p>
</td></tr>
<tr><td><code id="34-QR+2B20decomposition_+3A_complete">complete</code></td>
<td>
<p>Should the complete or truncated factor be returned?</p>
</td></tr>
<tr><td><code id="34-QR+2B20decomposition_+3A_dvec">Dvec</code></td>
<td>
<p>Vector of diagonals to use when re-constructing Q (<b>default is 1's</b>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The factorization is performed by the LAPACK routine <code>geqp3()</code>. This
should be similar to calling <code>qr()</code> on an ordinary R matrix with the
argument <code>LAPACK=TRUE</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>qr</code></td>
<td>
<p>Output of <code>qr()</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>

library(MPCR)


qr_input &lt;-as.MPCR( c(1, 2, 3, 2, 4, 6, 3, 3, 3),3,3,"single")
qr_out &lt;- qr(qr_input)
qr_out

</code></pre>

<hr>
<h2 id='35-Reciprocal+20condition'>reciprocal condition</h2><span id='topic+rcond'></span><span id='topic+rcond+2CRcpp_MPCR-method'></span><span id='topic+MPCR.rcond'></span>

<h3>Description</h3>

<p>Compute matrix norm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Rcpp_MPCR'
rcond(x, norm = "O", useInv = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="35-Reciprocal+2B20condition_+3A_x">x</code></td>
<td>
<p>An MPCR object.</p>
</td></tr>
<tr><td><code id="35-Reciprocal+2B20condition_+3A_norm">norm</code></td>
<td>
<p>&quot;O&quot;-ne or &quot;I&quot;-nfinity norm.</p>
</td></tr>
<tr><td><code id="35-Reciprocal+2B20condition_+3A_useinv">useInv</code></td>
<td>
<p>TRUE to use the lower triangle only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An MPCR Object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(MPCR)

x &lt;- as.MPCR(1:20,precision="double")
rcond(x)

</code></pre>

<hr>
<h2 id='36-Solve'>solve</h2><span id='topic+solve'></span><span id='topic+MPCR.solve'></span><span id='topic+solve+2CRcpp_MPCR-method'></span>

<h3>Description</h3>

<p>Solve a system of equations or invert an MPCR matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Rcpp_MPCR'
solve(a, b = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="36-Solve_+3A_a">a</code>, <code id="36-Solve_+3A_b">b</code></td>
<td>
<p>An MPCR objects.</p>
</td></tr>
<tr><td><code id="36-Solve_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Solves the equation AX=B .and if B=NULL t(A) will be used.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(MPCR)

x &lt;- as.MPCR(1:20,4,5,"double")
solve(x)

</code></pre>

<hr>
<h2 id='37-Singular+20value+20decomposition'>SVD</h2><span id='topic+svd'></span><span id='topic+La.svd+2CRcpp_MPCR-method'></span><span id='topic+svd+2CRcpp_MPCR-method'></span><span id='topic+MPCR.La.svd'></span><span id='topic+MPCR.svd'></span>

<h3>Description</h3>

<p>SVD factorization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Rcpp_MPCR'
La.svd(x, nu = min(n, p), nv = min(n, p))

## S4 method for signature 'Rcpp_MPCR'
svd(x, nu = min(n, p), nv = min(n, p))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="37-Singular+2B20value+2B20decomposition_+3A_x">x</code></td>
<td>
<p>An MPCR matrix.</p>
</td></tr>
<tr><td><code id="37-Singular+2B20value+2B20decomposition_+3A_nu">nu</code>, <code id="37-Singular+2B20value+2B20decomposition_+3A_nv">nv</code></td>
<td>
<p>The number of left/right singular vectors to return.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The factorization is performed by the LAPACK routine <code>gesdd()</code>.
</p>


<h3>Value</h3>

<p>The SVD decomposition of the MPCR matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(MPCR)
svd_vals &lt;- c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 1, 1, 1)

x &lt;- as.MPCR(svd_vals,9,4,"single")
y &lt;- svd(x)

</code></pre>

<hr>
<h2 id='38-Back+2FForward+20solve'>Back/Forward solve</h2><span id='topic+forwardsolve+2CRcpp_MPCR+2CRcpp_MPCR-method'></span><span id='topic+backsolve+2CRcpp_MPCR+2CRcpp_MPCR-method'></span><span id='topic+MPCR.backsolve'></span><span id='topic+MPCR.forwardsolve'></span>

<h3>Description</h3>

<p>Solves a system of linear equations where the coefficient matrix is upper or lower triangular. The function solves the equation <b><code>A X = B</code></b>, where <code>A</code> is the coefficient matrix, <code>X</code> is the solution vector, and <code>B</code> is the right-hand side vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S4 method for signature 'Rcpp_MPCR,Rcpp_MPCR'
backsolve(r, x, k = ncol(r), upper.tri = TRUE, transpose = FALSE)

 ## S4 method for signature 'Rcpp_MPCR,Rcpp_MPCR'
forwardsolve(l, x, k = ncol(l), upper.tri = FALSE, transpose = FALSE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="38-Back+2B2FForward+2B20solve_+3A_l">l</code></td>
<td>
<p>An MPCR object.</p>
</td></tr>
<tr><td><code id="38-Back+2B2FForward+2B20solve_+3A_r">r</code></td>
<td>
<p>An MPCR object.</p>
</td></tr>
<tr><td><code id="38-Back+2B2FForward+2B20solve_+3A_x">x</code></td>
<td>
<p>An MPCR object whose columns give the right-hand sides for the equations.</p>
</td></tr>
<tr><td><code id="38-Back+2B2FForward+2B20solve_+3A_k">k</code></td>
<td>
<p>The number of columns of r and rows of x to use.</p>
</td></tr>
<tr><td><code id="38-Back+2B2FForward+2B20solve_+3A_upper.tri">upper.tri</code></td>
<td>
<p>logical; if TRUE, the upper triangular part of r is used. Otherwise, the lower one.</p>
</td></tr>
<tr><td><code id="38-Back+2B2FForward+2B20solve_+3A_transpose">transpose</code></td>
<td>
<p>logical; if TRUE, solve  for t( l , r ) %*% output == x.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An MPCR object represents the solution to the system of linear equations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  library(MPCR)
  a &lt;- matrix(c(2, 0, 0, 3), nrow = 2)
  b &lt;- matrix(c(1, 2), nrow = 2)
  a_MPCR &lt;- as.MPCR(a,2,2,"single")
  b_MPCR &lt;- as.MPCR(b,2,1,"double")
  x &lt;- backsolve(a_MPCR, b_MPCR)

</code></pre>

<hr>
<h2 id='39-MPCR+20GEMM'>MPCR GEMM  (Matrix-Matrix Multiplication)</h2><span id='topic+MPCR+20GEMM'></span><span id='topic+MPCR.gemm'></span><span id='topic+MPCR.gemm+2CRcpp_MPCR-method'></span>

<h3>Description</h3>

<p>Performs matrix-matrix multiplication of two given MPCR matrices to performs:
<br />
C = alpha A * B + beta C
<br />
C = alpha A A^T + beta C
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S4 method for signature 'Rcpp_MPCR'
MPCR.gemm(a,b = NULL,c,transpose_a= FALSE,transpose_b=FALSE,alpha=1,beta=0)
   </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="39-MPCR+2B20GEMM_+3A_a">a</code></td>
<td>
<p>An MPCR matrix A.</p>
</td></tr>
<tr><td><code id="39-MPCR+2B20GEMM_+3A_b">b</code></td>
<td>
<p>An MPCR matrix B, if NULL, the function will perform syrk operation from blas.</p>
</td></tr>
<tr><td><code id="39-MPCR+2B20GEMM_+3A_c">c</code></td>
<td>
<p>Input/Output MPCR matrix C.</p>
</td></tr>
<tr><td><code id="39-MPCR+2B20GEMM_+3A_transpose_a">transpose_a</code></td>
<td>
<p>A flag to indicate whether transpose matrix A should be used, if B is NULL and transpose_a =TRUE
<br />
The function will perform the following operation:
<br />
<b>C</b>=<b>alphaA^T</b>X<b>A</b>+<b>betaC</b>.
</p>
</td></tr>
<tr><td><code id="39-MPCR+2B20GEMM_+3A_transpose_b">transpose_b</code></td>
<td>
<p>A flag to indicate whether transpose matrix B should be used.</p>
</td></tr>
<tr><td><code id="39-MPCR+2B20GEMM_+3A_alpha">alpha</code></td>
<td>
<p>Specifies the scalar alpha.</p>
</td></tr>
<tr><td><code id="39-MPCR+2B20GEMM_+3A_beta">beta</code></td>
<td>
<p>Specifies the scalar beta.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An MPCR matrix.
</p>

<hr>
<h2 id='40-MPCR+20TRSM'>MPCR TRSM  (Triangular Solve)</h2><span id='topic+MPCR+20TRSM'></span><span id='topic+MPCR.trsm'></span><span id='topic+MPCR.trsm+2CRcpp_MPCR-method'></span>

<h3>Description</h3>

<p>Solves a triangular matrix equation.
<br />
performs:
<br />
op(A)*X=alpha*B
<br />
X*op(A)=alpha*B
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S4 method for signature 'Rcpp_MPCR'
MPCR.trsm(a,b,upper_triangle,transpose,side = 'L',alpha =1)
   </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="40-MPCR+2B20TRSM_+3A_a">a</code></td>
<td>
<p>MPCR Matrix A.</p>
</td></tr>
<tr><td><code id="40-MPCR+2B20TRSM_+3A_b">b</code></td>
<td>
<p>MPCR Matrix B.</p>
</td></tr>
<tr><td><code id="40-MPCR+2B20TRSM_+3A_upper_triangle">upper_triangle</code></td>
<td>
<p>If the value is TRUE, the referenced part of matrix A corresponds to the upper triangle, with the opposite triangle assumed to contain zeros.</p>
</td></tr>
<tr><td><code id="40-MPCR+2B20TRSM_+3A_transpose">transpose</code></td>
<td>
<p>If TRUE, the transpose of A is used.</p>
</td></tr>
<tr><td><code id="40-MPCR+2B20TRSM_+3A_side">side</code></td>
<td>
<p>'R for Right side, 'L' for Left side.</p>
</td></tr>
<tr><td><code id="40-MPCR+2B20TRSM_+3A_alpha">alpha</code></td>
<td>
<p>Factor used for A, If alpha is zero, A is not accessed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An MPCR Matrix.
</p>

<hr>
<h2 id='41-MPCRTile+20GEMM'>MPCRTile GEMM  (Matrix-Matrix Multiplication)</h2><span id='topic+MPCRTile+20GEMM'></span><span id='topic+MPCRTile.gemm'></span><span id='topic+MPCRTile.gemm+2CRcpp_MPCRTile-method'></span>

<h3>Description</h3>

<p>Tile-based matrix-matrix multiplication of two given MPCR tiled matrices to
<b>perform:</b>
<br />
C = <b>alpha*A</b> X <b>B</b> + <b>beta*C</b>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S4 method for signature 'Rcpp_MPCRTile'
MPCRTile.gemm(a,b,c,transpose_a= FALSE,transpose_b=FALSE,alpha=1,beta=0,num_threads=1)
   </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="41-MPCRTile+2B20GEMM_+3A_a">a</code></td>
<td>
<p>An MPCR tile matrix A.</p>
</td></tr>
<tr><td><code id="41-MPCRTile+2B20GEMM_+3A_b">b</code></td>
<td>
<p>An MPCR tile matrix B.</p>
</td></tr>
<tr><td><code id="41-MPCRTile+2B20GEMM_+3A_c">c</code></td>
<td>
<p>Input/Output MPCR tile matrix C.</p>
</td></tr>
<tr><td><code id="41-MPCRTile+2B20GEMM_+3A_transpose_a">transpose_a</code></td>
<td>
<p>A flag to indicate whether transpose matrix A should be used.</p>
</td></tr>
<tr><td><code id="41-MPCRTile+2B20GEMM_+3A_transpose_b">transpose_b</code></td>
<td>
<p>A flag to indicate whether transpose matrix B should be used.</p>
</td></tr>
<tr><td><code id="41-MPCRTile+2B20GEMM_+3A_alpha">alpha</code></td>
<td>
<p>Specifies the scalar alpha.</p>
</td></tr>
<tr><td><code id="41-MPCRTile+2B20GEMM_+3A_beta">beta</code></td>
<td>
<p>Specifies the scalar beta.</p>
</td></tr>
<tr><td><code id="41-MPCRTile+2B20GEMM_+3A_num_threads">num_threads</code></td>
<td>

<p>An integer to determine number if thread to run using openmp, default = 1 (serial with no parallelization).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An MPCR tile matrix C.
</p>

<hr>
<h2 id='42-MPCRTile+20POTRF'>MPCRTile Chol  ( Cholesky decomposition )</h2><span id='topic+MPCRTile+20Chol'></span><span id='topic+chol+2CRcpp_MPCRTile-method'></span><span id='topic+MPCRTile.chol'></span>

<h3>Description</h3>

<p>Tile-based Cholesky decomposition of a positive definite tile-based symmetric matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S4 method for signature 'Rcpp_MPCRTile'
chol(x, overwrite_input = TRUE, num_threads = 1)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="42-MPCRTile+2B20POTRF_+3A_x">x</code></td>
<td>

<p>An MPCR tile matrix.
</p>
</td></tr>
<tr><td><code id="42-MPCRTile+2B20POTRF_+3A_overwrite_input">overwrite_input</code></td>
<td>

<p>A flag to determine whether to overwrite the input ( TRUE ), or return a new MPCR tile matrix.
</p>
</td></tr>
<tr><td><code id="42-MPCRTile+2B20POTRF_+3A_num_threads">num_threads</code></td>
<td>

<p>An integer to determine number if thread to run using openmp, default = 1 (serial with no parallelization).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An MPCR tile matrix.
</p>

<hr>
<h2 id='43-MPCRTile+20TRSM'>MPCRTile TRSM  (Triangular Solve)</h2><span id='topic+MPCRTile.trsm+2CRcpp_MPCRTile-method'></span><span id='topic+MPCRTile.trsm'></span>

<h3>Description</h3>

<p>Tile-based algorithm to solve a triangular matrix equation for MPCR tiled matrices.
<br />
performs:
<br />
op(A)*X=alpha*B
<br />
X*op(A)=alpha*B
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S4 method for signature 'Rcpp_MPCRTile'
MPCRTile.trsm(a,b,side,upper_triangle,transpose,alpha)
   </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="43-MPCRTile+2B20TRSM_+3A_a">a</code></td>
<td>
<p>An MPCR tile matrix A.</p>
</td></tr>
<tr><td><code id="43-MPCRTile+2B20TRSM_+3A_b">b</code></td>
<td>
<p>An MPCR tile matrix B, X after returning.</p>
</td></tr>
<tr><td><code id="43-MPCRTile+2B20TRSM_+3A_side">side</code></td>
<td>
<p>'R' for right side, 'L' for left side.</p>
</td></tr>
<tr><td><code id="43-MPCRTile+2B20TRSM_+3A_upper_triangle">upper_triangle</code></td>
<td>
<p>What part of the matrix A is referenced (if TRUE upper triangle is referenced), the opposite triangle
being assumed to be zero.</p>
</td></tr>
<tr><td><code id="43-MPCRTile+2B20TRSM_+3A_transpose">transpose</code></td>
<td>
<p>If TRUE, the transpose of A is used.</p>
</td></tr>
<tr><td><code id="43-MPCRTile+2B20TRSM_+3A_alpha">alpha</code></td>
<td>
<p>Factor used for A, If alpha is zero, A is not accessed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An MPCR Tile Matrix B -&gt;(X).
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
