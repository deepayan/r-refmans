<!DOCTYPE html><html lang="en"><head><title>Help for package PAsso</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PAsso}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.rtrunc'><p>Simulate sample from truncated distribution</p></a></li>
<li><a href='#ANES2016'><p>The 2016 ANES Time Series Study with pre-election interview</p></a></li>
<li><a href='#autoplot'><p>Residual-based diagnostic plots</p></a></li>
<li><a href='#df1'><p>Simulated quadratic data</p></a></li>
<li><a href='#diagnostic.plot'><p>Residual-based diagnostic plots</p></a></li>
<li><a href='#generate_residuals_acat'><p>generate_residuals_acat</p></a></li>
<li><a href='#p_adj_cate'><p>p_adj_cate</p></a></li>
<li><a href='#PAsso'><p>Partial association analysis between ordinal responses after adjusting for a set of covariates</p></a></li>
<li><a href='#plot'><p>A matrix of partial regression plots between responses after adjustments</p></a></li>
<li><a href='#plot3D'><p>3-D P-P plot and false color level plot for the inspection of the partial association analysis</p></a></li>
<li><a href='#plot3D_one'><p>plot3D_one</p></a></li>
<li><a href='#print'><p>Print partial association matrix</p></a></li>
<li><a href='#residuals'><p>Extract Model Residuals</p></a></li>
<li><a href='#residualsAcat'><p>This is a function to deal with the vglm object in S4.</p></a></li>
<li><a href='#residualsVGAM'><p>Extract Residuals from models of VGAM</p></a></li>
<li><a href='#summary'><p>Summary of partial association analysis</p></a></li>
<li><a href='#surrogate'><p>Surrogate response</p></a></li>
<li><a href='#test'><p>Hypothesis testing of the partial association coefficients</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Assessing the Partial Association Between Ordinal Variables</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation of the unified framework for assessing partial association 
            between ordinal variables after adjusting for a set of covariates (Dungang Liu, Shaobo 
            Li, Yan Yu and Irini Moustaki (2020), accepted by the Journal of the American 
            Statistical Association). This package provides a set of tools to quantify, visualize, 
            and test partial associations between multiple ordinal variables. It can produce a number
            of $phi$ measures, partial regression plots, 3-D plots, and $p$-values for testing 
            $H_0: phi=0$ or $H_0: phi &lt;= delta$.</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.10</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Xiaorui (Jeremy) Zhu &lt;zhuxiaorui1989@gmail.com&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td>GitHub: <a href="https://github.com/XiaoruiZhu/PAsso">https://github.com/XiaoruiZhu/PAsso</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/XiaoruiZhu/PAsso/issues">https://github.com/XiaoruiZhu/PAsso/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), stats (&ge; 3.5.0), ggplot2 (&ge; 2.2.1), dplyr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>VGAM, copBasic, pcaPP (&ge; 1.9-73), methods, foreach (&ge;
1.4.8), MASS (&ge; 7.3-51.0), GGally, gridExtra, utils (&ge;
3.5.3), progress (&ge; 1.2.0), plotly, copula</td>
</tr>
<tr>
<td>Suggests:</td>
<td>doParallel (&ge; 1.0.11), tidyverse, goftest, faraway, ordinal,
rms, testthat, mgcv, PResiduals, knitr, rmarkdown, truncdist</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-06-18 04:38:48 UTC; Xiaorui</td>
</tr>
<tr>
<td>Author:</td>
<td>Xiaorui (Jeremy) Zhu [aut, cre],
  Shaobo Li [aut],
  Dungang Liu [ctb, aut],
  Yuejie Chen [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-06-18 09:20:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='.rtrunc'>Simulate sample from truncated distribution</h2><span id='topic+.rtrunc'></span>

<h3>Description</h3>

<p>a function to generate truncated distribution. Simulate one random sample from
a standard normal distribution truncated to the left in the middle
.rtrunc(1, spec = &quot;norm&quot;, a = -Inf, b = 0)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.rtrunc(n, spec, a = -Inf, b = Inf, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".rtrunc_+3A_n">n</code></td>
<td>
<p>the number of observations.</p>
</td></tr>
<tr><td><code id=".rtrunc_+3A_spec">spec</code></td>
<td>
<p>a character string to specify the distribution.</p>
</td></tr>
<tr><td><code id=".rtrunc_+3A_a">a</code></td>
<td>
<p>lower bound.</p>
</td></tr>
<tr><td><code id=".rtrunc_+3A_b">b</code></td>
<td>
<p>upper bound.</p>
</td></tr>
<tr><td><code id=".rtrunc_+3A_...">...</code></td>
<td>
<p>any other arguments that can be used for the functions of different distribution
such as &quot;mean&quot;, &quot;sd&quot; for &quot;qnorm()&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector contains n random samples from the truncated distribution &quot;spec&quot;.
</p>

<hr>
<h2 id='ANES2016'>The 2016 ANES Time Series Study with pre-election interview</h2><span id='topic+ANES2016'></span>

<h3>Description</h3>

<p>A subset of 2,188 participants of the 2016 American National Election Time Series Study,
which was to track the enduring social trend and record the political moment of 2016 (DeBell, 2018).
This study consisted of two surveys with same population. The pre-election interview
was during the weeks before the 2016 general election, including 4,271 respondents in
total. The post-election interview is the re-interview during the weeks after the
election, including 3,649 respondents (662 respondents did not complete post-interviews).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ANES2016)
</code></pre>


<h3>Format</h3>

<p>A data frame with 2188 rows and 10 variables.
</p>

<ul>
<li> <p><code>age</code> Respondent's age in years.
</p>
</li>
<li> <p><code>edu.year</code> Respondent's education year, which is mapped from <code>education</code>
level: <code>MS</code>=8, <code>HSdrop</code>=11, <code>HS</code>=12, <code>Coll</code>=14,
<code>CCdeg</code>=15, <code>BAdeg</code>=17, <code>MAdeg</code>=19.
</p>
</li>
<li> <p><code>education</code> Respondent's education level.
</p>
</li>
<li> <p><code>income.num</code> Respondent's family income in thousands: an numerical variable.
It is median value of the range of each <code>income</code> level
</p>
</li>
<li> <p><code>income</code> Respondent's family income level:
</p>
<p>'(01) 01. Under $5,000' = 5,
</p>
<p>'(02) 02. $5,000-$9,999',
</p>
<p>'(03) 03. $10,000-$12,499',
</p>
<p>'(04) 04. $12,500-$14,999',
</p>
<p>'(05) 05. $15,000-$17,499',
</p>
<p>'(06) 06. $17,500-$19,999',
</p>
<p>'(07) 07. $20,000-$22,499',
</p>
<p>'(08) 08. $22,500-$24,999',
</p>
<p>'(09) 09. $25,000-$27,499',
</p>
<p>'(10) 10. $27,500-$29,999',
</p>
<p>'(11) 11. $30,000-$34,999',
</p>
<p>'(12) 12. $35,000-$39,999',
</p>
<p>'(13) 13. $40,000-$44,999',
</p>
<p>'(14) 14. $45,000-$49,999',
</p>
<p>'(15) 15. $50,000-$54,999',
</p>
<p>'(16) 16. $55,000-$59,999',
</p>
<p>'(17) 17. $60,000-$64,999',
</p>
<p>'(18) 18. $65,000-$69,999',
</p>
<p>'(19) 19. $70,000-$74,999',
</p>
<p>'(20) 20. $75,000-$79,999',
</p>
<p>'(21) 21. $80,000-$89,999',
</p>
<p>'(22) 22. $90,000-$99,999',
</p>
<p>'(23) 23. $100,000-$109,999',
</p>
<p>'(24) 24. $110,000-$124,999',
</p>
<p>'(25) 25. $125,000-$149,999',
</p>
<p>'(26) 26. $150,000-$174,999',
</p>
<p>'(27) 27. $175,000-$249,999',
</p>
<p>'(28) 28. $250,000 or more' = 250.
</p>
</li>
<li> <p><code>PID</code> Party identification: a numeric variable with value from 1 to 7
representing strong Democrat, <code>strDem</code> &lt; weak Democrat, <code>weakDem</code> &lt;
independent Democrat, <code>indDem</code> &lt; independent independent <code>indind</code> &lt;
independent Republican, <code>indRep</code> &lt; weak Republican, <code>weakRep</code> &lt;
strong Republican, <code>strRep</code>.
</p>
</li>
<li> <p><code>selfLR</code> The respondent' self-placement about own left-right in 7 ordinal levels
(from extremely liberal to extremely conservative). <code>extLib</code>: extremely liberal, <code>Lib</code>: liberal,
<code>sliLib</code>: slightly liberal, <code>Mod</code>: moderate, <code>sliCon</code>:
slightly conservative, <code>Con</code>: conservative, <code>extCon</code>: extremely
conservative. <code>extLib</code> &lt; <code>Lib</code> &lt; <code>sliLib</code> &lt;
<code>Mod</code> &lt; <code>sliCon</code> &lt; <code>Con</code> &lt; <code>extCon</code>.
</p>
</li>
<li> <p><code>TrumpLR</code> The respondent's opinion about Donald Trump's left-right
placement (same scale as selfLR).
</p>
</li>
<li> <p><code>ClinLR</code> The respondent's opinion about Hilary Clinton's left-right
placement (same scale as selfLR).
</p>
</li>
<li> <p><code>PreVote</code> The respondent's voting preference between
Donald Trump and Hilary Clinton two months preceeding the
November election (Pre-election interview). It is a factor with levels
<code>HillaryClinton</code> and <code>DonaldTrump</code>.
</p>
</li>
<li> <p><code>PreVote.num</code> Recode the PreVote to numeric values,
'HillaryClinton'=0, 'DonaldTrump'=1.
</p>
</li>
<li> <p><code>WeightforPreVote</code> Pre-election weight of a respondent.
</p>
</li></ul>



<h3>Details</h3>

<p>The Pre-election preference is recorded as &quot;PreVote&quot; and the &quot;PreVote.num&quot;
is the numeric of it. Observations with missing values, or &quot;No thought&quot;
responses have been removed. Respondents expressing a voting preference
other than Clinton or Trump have been removed.
</p>


<h3>References</h3>

<p>DeBell, Matthew, Jon A. Krosnick, Katie Gera, David S. Yeager, and Michael P. McDonald.
The turnout gap in surveys: Explanations and solutions. <em>Sociological Methods &amp; Research</em>, 2018.
doi: <a href="https://doi.org/10.1177/0049124118769085">10.1177/0049124118769085</a>
</p>
<p>Enamorado, T., Fifield, B., &amp; Imai, K. (2018). <em>Userâ€™s guide and codebook for the
ANES 2016 time series voter validation supplemental data</em>. Technical Report, American
National Election Studies.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(ANES2016)
</code></pre>

<hr>
<h2 id='autoplot'>Residual-based diagnostic plots</h2><span id='topic+autoplot'></span><span id='topic+autoplot.resid'></span><span id='topic+autoplot.glm'></span><span id='topic+autoplot.clm'></span><span id='topic+autoplot.lrm'></span><span id='topic+autoplot.orm'></span><span id='topic+autoplot.polr'></span><span id='topic+autoplot.vglm'></span>

<h3>Description</h3>

<p>Residual-based diagnostic plots for cumulative link and general
regression models using <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> graphics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'resid'
autoplot(
  object,
  output = c("qq", "fitted", "covariate"),
  x = NULL,
  fit = NULL,
  distribution = qnorm,
  ncol = NULL,
  alpha = 1,
  xlab = NULL,
  color = "#444444",
  shape = 19,
  size = 2,
  qqpoint.color = "#444444",
  qqpoint.shape = 19,
  qqpoint.size = 2,
  qqline.color = "#888888",
  qqline.linetype = "dashed",
  qqline.size = 1,
  smooth = TRUE,
  smooth.color = "red",
  smooth.linetype = 1,
  smooth.size = 1,
  fill = NULL,
  resp_name = NULL,
  ...
)

## S3 method for class 'glm'
autoplot(
  object,
  output = c("qq", "fitted", "covariate"),
  x = NULL,
  fit = NULL,
  distribution = qnorm,
  ncol = NULL,
  alpha = 1,
  xlab = NULL,
  color = "#444444",
  shape = 19,
  size = 2,
  qqpoint.color = "#444444",
  qqpoint.shape = 19,
  qqpoint.size = 2,
  qqline.color = "#888888",
  qqline.linetype = "dashed",
  qqline.size = 1,
  smooth = TRUE,
  smooth.color = "red",
  smooth.linetype = 1,
  smooth.size = 1,
  fill = NULL,
  resp_name = NULL,
  ...
)

## S3 method for class 'clm'
autoplot(
  object,
  output = c("qq", "fitted", "covariate"),
  x = NULL,
  fit = NULL,
  distribution = qnorm,
  ncol = NULL,
  alpha = 1,
  xlab = NULL,
  color = "#444444",
  shape = 19,
  size = 2,
  qqpoint.color = "#444444",
  qqpoint.shape = 19,
  qqpoint.size = 2,
  qqline.color = "#888888",
  qqline.linetype = "dashed",
  qqline.size = 1,
  smooth = TRUE,
  smooth.color = "red",
  smooth.linetype = 1,
  smooth.size = 1,
  fill = NULL,
  resp_name = NULL,
  ...
)

## S3 method for class 'lrm'
autoplot(
  object,
  output = c("qq", "fitted", "covariate"),
  x = NULL,
  fit = NULL,
  distribution = qnorm,
  ncol = NULL,
  alpha = 1,
  xlab = NULL,
  color = "#444444",
  shape = 19,
  size = 2,
  qqpoint.color = "#444444",
  qqpoint.shape = 19,
  qqpoint.size = 2,
  qqline.color = "#888888",
  qqline.linetype = "dashed",
  qqline.size = 1,
  smooth = TRUE,
  smooth.color = "red",
  smooth.linetype = 1,
  smooth.size = 1,
  fill = NULL,
  resp_name = NULL,
  ...
)

## S3 method for class 'orm'
autoplot(
  object,
  output = c("qq", "fitted", "covariate"),
  x = NULL,
  fit = NULL,
  distribution = qnorm,
  ncol = NULL,
  alpha = 1,
  xlab = NULL,
  color = "#444444",
  shape = 19,
  size = 2,
  qqpoint.color = "#444444",
  qqpoint.shape = 19,
  qqpoint.size = 2,
  qqline.color = "#888888",
  qqline.linetype = "dashed",
  qqline.size = 1,
  smooth = TRUE,
  smooth.color = "red",
  smooth.linetype = 1,
  smooth.size = 1,
  fill = NULL,
  resp_name = NULL,
  ...
)

## S3 method for class 'polr'
autoplot(
  object,
  output = c("qq", "fitted", "covariate"),
  x = NULL,
  fit = NULL,
  distribution = qnorm,
  ncol = NULL,
  alpha = 1,
  xlab = NULL,
  color = "#444444",
  shape = 19,
  size = 2,
  qqpoint.color = "#444444",
  qqpoint.shape = 19,
  qqpoint.size = 2,
  qqline.color = "#888888",
  qqline.linetype = "dashed",
  qqline.size = 1,
  smooth = TRUE,
  smooth.color = "red",
  smooth.linetype = 1,
  smooth.size = 1,
  fill = NULL,
  resp_name = NULL,
  ...
)

## S3 method for class 'vglm'
autoplot(
  object,
  output = c("qq", "fitted", "covariate"),
  x = NULL,
  fit = NULL,
  distribution = qnorm,
  ncol = NULL,
  alpha = 1,
  xlab = NULL,
  color = "#444444",
  shape = 19,
  size = 2,
  qqpoint.color = "#444444",
  qqpoint.shape = 19,
  qqpoint.size = 2,
  qqline.color = "#888888",
  qqline.linetype = "dashed",
  qqline.size = 1,
  smooth = TRUE,
  smooth.color = "red",
  smooth.linetype = 1,
  smooth.size = 1,
  fill = NULL,
  resp_name = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="autoplot_+3A_object">object</code></td>
<td>
<p>An object of class <code>sure:resids</code>,
<code><a href="ordinal.html#topic+clm">clm</a></code>,
<code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="rms.html#topic+lrm">lrm</a></code>, <code><a href="rms.html#topic+orm">orm</a></code>,
<code><a href="MASS.html#topic+polr">polr</a></code>, or <code><a href="VGAM.html#topic+vglm">vglm</a></code>.</p>
</td></tr>
<tr><td><code id="autoplot_+3A_output">output</code></td>
<td>
<p>Character string specifying what to plot. Default is <code>"qq"</code>
which produces a quantile-quantile plots of the residuals.</p>
</td></tr>
<tr><td><code id="autoplot_+3A_x">x</code></td>
<td>
<p>A vector giving the covariate values to use for residual-by-
covariate plots (i.e., when <code>output = "covariate"</code>).</p>
</td></tr>
<tr><td><code id="autoplot_+3A_fit">fit</code></td>
<td>
<p>The fitted model from which the residuals were extracted. (Only
required if <code>output = "fitted"</code> and <code>object</code> inherits from class
<code>"resid"</code>.)</p>
</td></tr>
<tr><td><code id="autoplot_+3A_distribution">distribution</code></td>
<td>
<p>Function that computes the quantiles for the reference
distribution to use in the quantile-quantile plot. Default is <code>qnorm</code>
which is only appropriate for models using a probit link function. When
<code>jitter.scale = "probability"</code>, the reference distribution is always
U(-0.5, 0.5). (Only
required if <code>object</code> inherits from class <code>"resid"</code>.)</p>
</td></tr>
<tr><td><code id="autoplot_+3A_ncol">ncol</code></td>
<td>
<p>Integer specifying the number of columns to use for the plot
layout (if requesting multiple plots). Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="autoplot_+3A_alpha">alpha</code></td>
<td>
<p>A single values in the interval [0, 1] controlling the opacity
alpha of the plotted points. Only used when <code>nsim</code> &gt; 1.</p>
</td></tr>
<tr><td><code id="autoplot_+3A_xlab">xlab</code></td>
<td>
<p>Character string giving the text to use for the x-axis label in
residual-by-covariate plots. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="autoplot_+3A_color">color</code></td>
<td>
<p>Character string or integer specifying what color to use for the
points in the residual vs fitted value/covariate plot.
Default is <code>"black"</code>.</p>
</td></tr>
<tr><td><code id="autoplot_+3A_shape">shape</code></td>
<td>
<p>Integer or single character specifying a symbol to be used for
plotting the points in the residual vs fitted value/covariate plot.</p>
</td></tr>
<tr><td><code id="autoplot_+3A_size">size</code></td>
<td>
<p>Numeric value specifying the size to use for the points in the
residual vs fitted value/covariate plot.</p>
</td></tr>
<tr><td><code id="autoplot_+3A_qqpoint.color">qqpoint.color</code></td>
<td>
<p>Character string or integer specifying what color to use
for the points in the quantile-quantile plot.</p>
</td></tr>
<tr><td><code id="autoplot_+3A_qqpoint.shape">qqpoint.shape</code></td>
<td>
<p>Integer or single character specifying a symbol to be
used for plotting the points in the quantile-quantile plot.</p>
</td></tr>
<tr><td><code id="autoplot_+3A_qqpoint.size">qqpoint.size</code></td>
<td>
<p>Numeric value specifying the size to use for the points
in the quantile-quantile plot.</p>
</td></tr>
<tr><td><code id="autoplot_+3A_qqline.color">qqline.color</code></td>
<td>
<p>Character string or integer specifying what color to use
for the points in the quantile-quantile plot.</p>
</td></tr>
<tr><td><code id="autoplot_+3A_qqline.linetype">qqline.linetype</code></td>
<td>
<p>Integer or character string (e.g., <code>"dashed"</code>)
specifying the type of line to use in the quantile-quantile plot.</p>
</td></tr>
<tr><td><code id="autoplot_+3A_qqline.size">qqline.size</code></td>
<td>
<p>Numeric value specifying the thickness of the line in the
quantile-quantile plot.</p>
</td></tr>
<tr><td><code id="autoplot_+3A_smooth">smooth</code></td>
<td>
<p>Logical indicating whether or not too add a nonparametric
smooth to certain plots. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="autoplot_+3A_smooth.color">smooth.color</code></td>
<td>
<p>Character string or integer specifying what color to use
for the nonparametric smooth.</p>
</td></tr>
<tr><td><code id="autoplot_+3A_smooth.linetype">smooth.linetype</code></td>
<td>
<p>Integer or character string (e.g., <code>"dashed"</code>)
specifying the type of line to use for the nonparametric smooth.</p>
</td></tr>
<tr><td><code id="autoplot_+3A_smooth.size">smooth.size</code></td>
<td>
<p>Numeric value specifying the thickness of the line for the
nonparametric smooth.</p>
</td></tr>
<tr><td><code id="autoplot_+3A_fill">fill</code></td>
<td>
<p>Character string or integer specifying the color to use to fill
the boxplots for residual-by-covariate plots when <code>x</code> is of class
<code>"factor"</code>. Default is <code>NULL</code> which colors the boxplots according
to the factor levels.</p>
</td></tr>
<tr><td><code id="autoplot_+3A_resp_name">resp_name</code></td>
<td>
<p>Character string to specify the response name that will be
displayed in the figure.</p>
</td></tr>
<tr><td><code id="autoplot_+3A_...">...</code></td>
<td>
<p>Additional optional arguments to be passed onto <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>"ggplot"</code> object.
</p>
<p>A <code>"ggplot"</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load data
data(df1)
# Fit cumulative link model
fit &lt;- glm(y ~ x + I(x ^ 2), data = df1, family = binomial)
# Construct residual plots
p1 &lt;- ggplot2::autoplot(fit, jitter.scale = "probability", output = "qq")
p2 &lt;- ggplot2::autoplot(fit, output = "covariate", x = df1$x)
p3 &lt;- ggplot2::autoplot(fit, output = "fitted")

</code></pre>

<hr>
<h2 id='df1'>Simulated quadratic data</h2><span id='topic+df1'></span>

<h3>Description</h3>

<p>Data simulated from a probit model with a quadratic trend. The data are
described in Example 2 of Liu and Zhang (2017).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(df1)
</code></pre>


<h3>Format</h3>

<p>A data frame with 2000 rows and 2 variables.
</p>

<ul>
<li> <p><code>x</code> The predictor variable.
</p>
</li>
<li> <p><code>y</code> The response variable; an ordered factor.
</p>
</li></ul>



<h3>References</h3>

<p>Liu, Dungang and Zhang, Heping. Residuals and Diagnostics for Ordinal
Regression Models: A Surrogate Approach. <em>Journal of the American Statistical Association</em>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(df1)
</code></pre>

<hr>
<h2 id='diagnostic.plot'>Residual-based diagnostic plots</h2><span id='topic+diagnostic.plot'></span><span id='topic+diagnostic.plot.default'></span><span id='topic+diagnostic.plot.resid'></span><span id='topic+diagnostic.plot.PAsso'></span><span id='topic+diagnostic.plot.glm'></span><span id='topic+diagnostic.plot.clm'></span><span id='topic+diagnostic.plot.lrm'></span><span id='topic+diagnostic.plot.orm'></span><span id='topic+diagnostic.plot.polr'></span>

<h3>Description</h3>

<p>A set of visualization tools for the diagnostic of the fitted model in
the partial association analysis. It can provides a plot matrix including Q-Q plots,
residual-vs-fitted plots, residual-vs-covariate plots of all the fitted models.
This function also support the direct diagnostic of the cumulative link regression model
in the class of <code><a href="ordinal.html#topic+clm">clm</a></code>, <code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="rms.html#topic+lrm">lrm</a></code>,
<code><a href="rms.html#topic+orm">orm</a></code>, <code><a href="MASS.html#topic+polr">polr</a></code>. Currently, <code><a href="VGAM.html#topic+vglm">vglm</a></code>
is not supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagnostic.plot(object, ...)

## Default S3 method:
diagnostic.plot(object, ...)

## S3 method for class 'resid'
diagnostic.plot(object, output = c("qq", "fitted", "covariate"), ...)

## S3 method for class 'PAsso'
diagnostic.plot(
  object,
  output = c("qq", "fitted", "covariate"),
  model_id = NULL,
  x_name = NULL,
  ...
)

## S3 method for class 'glm'
diagnostic.plot(
  object,
  output = c("qq", "fitted", "covariate"),
  x = NULL,
  fit = NULL,
  distribution = qnorm,
  ncol = NULL,
  alpha = 1,
  xlab = NULL,
  color = "#444444",
  shape = 19,
  size = 2,
  qqpoint.color = "#444444",
  qqpoint.shape = 19,
  qqpoint.size = 2,
  qqline.color = "#888888",
  qqline.linetype = "dashed",
  qqline.size = 1,
  smooth = TRUE,
  smooth.color = "red",
  smooth.linetype = 1,
  smooth.size = 1,
  fill = NULL,
  resp_name = NULL,
  ...
)

## S3 method for class 'clm'
diagnostic.plot(object, output = c("qq", "fitted", "covariate"), ...)

## S3 method for class 'lrm'
diagnostic.plot(object, output = c("qq", "fitted", "covariate"), ...)

## S3 method for class 'orm'
diagnostic.plot(object, output = c("qq", "fitted", "covariate"), ...)

## S3 method for class 'polr'
diagnostic.plot(object, output = c("qq", "fitted", "covariate"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diagnostic.plot_+3A_object">object</code></td>
<td>
<p>The object in the support classes (This function is mainly designed
for <code>PAsso</code>).</p>
</td></tr>
<tr><td><code id="diagnostic.plot_+3A_...">...</code></td>
<td>
<p>Additional optional arguments can be passed onto <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> for drawing
various plots.</p>
</td></tr>
<tr><td><code id="diagnostic.plot_+3A_output">output</code></td>
<td>
<p>A character string specifying what type of output to plot. Default is
<code>"qq"</code> which produces a plot matrix with quantile-quantile plots of the residuals.
<code>"fitted"</code> produces a plot matrix between residuals and all corresponding fitted responses.
<code>"covariates"</code> produces a plot matrix between residuals and corresponding covariate.</p>
</td></tr>
<tr><td><code id="diagnostic.plot_+3A_model_id">model_id</code></td>
<td>
<p>A number refers to the index of the model that needs to be diagnosed. If NULL, all
models will be diagnosed.</p>
</td></tr>
<tr><td><code id="diagnostic.plot_+3A_x_name">x_name</code></td>
<td>
<p>A string refers to the covariate name that needs to be diagnosed. If NULL, all adjustments
will be diagnosed.</p>
</td></tr>
<tr><td><code id="diagnostic.plot_+3A_x">x</code></td>
<td>
<p>A vector giving the covariate values to use for residual-by-
covariate plots (i.e., when <code>output = "covariate"</code>).</p>
</td></tr>
<tr><td><code id="diagnostic.plot_+3A_fit">fit</code></td>
<td>
<p>The fitted model from which the residuals were extracted. (Only
required if <code>output = "fitted"</code> and <code>object</code> inherits from class
<code>"resid"</code>.)</p>
</td></tr>
<tr><td><code id="diagnostic.plot_+3A_distribution">distribution</code></td>
<td>
<p>Function that computes the quantiles for the reference
distribution to use in the quantile-quantile plot. Default is <code>qnorm</code>
which is only appropriate for models using a probit link function. When
<code>jitter.scale = "probability"</code>, the reference distribution is always
U(-0.5, 0.5). (Only
required if <code>object</code> inherits from class <code>"resid"</code>.)</p>
</td></tr>
<tr><td><code id="diagnostic.plot_+3A_ncol">ncol</code></td>
<td>
<p>Integer specifying the number of columns to use for the plot
layout (if requesting multiple plots). Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="diagnostic.plot_+3A_alpha">alpha</code></td>
<td>
<p>A single values in the interval [0, 1] controlling the opacity
alpha of the plotted points. Only used when <code>nsim</code> &gt; 1.</p>
</td></tr>
<tr><td><code id="diagnostic.plot_+3A_xlab">xlab</code></td>
<td>
<p>Character string giving the text to use for the x-axis label in
residual-by-covariate plots. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="diagnostic.plot_+3A_color">color</code></td>
<td>
<p>Character string or integer specifying what color to use for the
points in the residual vs fitted value/covariate plot.
Default is <code>"black"</code>.</p>
</td></tr>
<tr><td><code id="diagnostic.plot_+3A_shape">shape</code></td>
<td>
<p>Integer or single character specifying a symbol to be used for
plotting the points in the residual vs fitted value/covariate plot.</p>
</td></tr>
<tr><td><code id="diagnostic.plot_+3A_size">size</code></td>
<td>
<p>Numeric value specifying the size to use for the points in the
residual vs fitted value/covariate plot.</p>
</td></tr>
<tr><td><code id="diagnostic.plot_+3A_qqpoint.color">qqpoint.color</code></td>
<td>
<p>Character string or integer specifying what color to use
for the points in the quantile-quantile plot.</p>
</td></tr>
<tr><td><code id="diagnostic.plot_+3A_qqpoint.shape">qqpoint.shape</code></td>
<td>
<p>Integer or single character specifying a symbol to be
used for plotting the points in the quantile-quantile plot.</p>
</td></tr>
<tr><td><code id="diagnostic.plot_+3A_qqpoint.size">qqpoint.size</code></td>
<td>
<p>Numeric value specifying the size to use for the points
in the quantile-quantile plot.</p>
</td></tr>
<tr><td><code id="diagnostic.plot_+3A_qqline.color">qqline.color</code></td>
<td>
<p>Character string or integer specifying what color to use
for the points in the quantile-quantile plot.</p>
</td></tr>
<tr><td><code id="diagnostic.plot_+3A_qqline.linetype">qqline.linetype</code></td>
<td>
<p>Integer or character string (e.g., <code>"dashed"</code>)
specifying the type of line to use in the quantile-quantile plot.</p>
</td></tr>
<tr><td><code id="diagnostic.plot_+3A_qqline.size">qqline.size</code></td>
<td>
<p>Numeric value specifying the thickness of the line in the
quantile-quantile plot.</p>
</td></tr>
<tr><td><code id="diagnostic.plot_+3A_smooth">smooth</code></td>
<td>
<p>Logical indicating whether or not too add a nonparametric
smooth to certain plots. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="diagnostic.plot_+3A_smooth.color">smooth.color</code></td>
<td>
<p>Character string or integer specifying what color to use
for the nonparametric smooth.</p>
</td></tr>
<tr><td><code id="diagnostic.plot_+3A_smooth.linetype">smooth.linetype</code></td>
<td>
<p>Integer or character string (e.g., <code>"dashed"</code>)
specifying the type of line to use for the nonparametric smooth.</p>
</td></tr>
<tr><td><code id="diagnostic.plot_+3A_smooth.size">smooth.size</code></td>
<td>
<p>Numeric value specifying the thickness of the line for the
nonparametric smooth.</p>
</td></tr>
<tr><td><code id="diagnostic.plot_+3A_fill">fill</code></td>
<td>
<p>Character string or integer specifying the color to use to fill
the boxplots for residual-by-covariate plots when <code>x</code> is of class
<code>"factor"</code>. Default is <code>NULL</code> which colors the boxplots according
to the factor levels.</p>
</td></tr>
<tr><td><code id="diagnostic.plot_+3A_resp_name">resp_name</code></td>
<td>
<p>Character string to specify the response name that will be
displayed in the figure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>"ggplot"</code> object for supported models. For class &quot;PAsso&quot;, it returns a plot in
<code>"gtable"</code> object that combines diagnostic plots of all responses.
</p>
<p>A &quot;ggplot&quot; object based on the input residuals.
</p>
<p>A &quot;ggplot&quot; object based on the input residuals.
</p>
<p>A plot in &quot;gtable&quot; object that combines diagnostic plots of all responses.
</p>
<p>A &quot;ggplot&quot; object based on the residuals generated from glm object.
</p>
<p>A &quot;ggplot&quot; object based on the residuals generated from clm object.
</p>
<p>A &quot;ggplot&quot; object based on the residuals generated from lrm object.
</p>
<p>A &quot;ggplot&quot; object based on the residuals generated from orm object.
</p>
<p>A &quot;ggplot&quot; object based on the residuals generated from polr object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import data for partial association analysis
data("ANES2016")
ANES2016$PreVote.num &lt;- as.factor(ANES2016$PreVote.num)

PAsso_3v &lt;- PAsso(responses = c("PreVote.num", "PID", "selfLR"),
                  adjustments = c("income.num", "age", "edu.year"),
                  data = ANES2016, uni.model = "probit",
                  method = c("kendall"),
                  resids.type = "surrogate", jitter = "latent")

diag_p1 &lt;- diagnostic.plot(object = PAsso_3v, output = "qq")
diag_p2 &lt;- diagnostic.plot(object = PAsso_3v, output = "fitted")
diag_p3 &lt;- diagnostic.plot(object = PAsso_3v, output = "covariate")

# Simply diagnose a model
# Fit cumulative link models

fit1 &lt;- ordinal::clm(PreVote.num ~ income.num + age + edu.year, data = ANES2016, link = "logit")

# diagnostic.plot
plot_qq_1 &lt;- diagnostic.plot(object = fit1, output = "qq")
plot_fit_1 &lt;- diagnostic.plot(object = fit1, output = "fitted")
plot_cov_1 &lt;- diagnostic.plot(object = fit1, output = "covariate")

</code></pre>

<hr>
<h2 id='generate_residuals_acat'>generate_residuals_acat</h2><span id='topic+generate_residuals_acat'></span>

<h3>Description</h3>

<p>generate_residuals_acat
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_residuals_acat(y, X, alpha, beta, nsim = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_residuals_acat_+3A_y">y</code></td>
<td>
<p>A vector inputs the response variable.</p>
</td></tr>
<tr><td><code id="generate_residuals_acat_+3A_x">X</code></td>
<td>
<p>A data.frame inputs the covariates.</p>
</td></tr>
<tr><td><code id="generate_residuals_acat_+3A_alpha">alpha</code></td>
<td>
<p>A vector provides the estimated intercepts of adjacent categories model. If the response
has k levels, there should be k+1 numbers in this alpha argument with the k-1 estimated intercepts.
The lower bound and upper bound are &quot;-Inf&quot; and &quot;Inf&quot;.</p>
</td></tr>
<tr><td><code id="generate_residuals_acat_+3A_beta">beta</code></td>
<td>
<p>A vector provides the estimated coefficients.</p>
</td></tr>
<tr><td><code id="generate_residuals_acat_+3A_nsim">nsim</code></td>
<td>
<p>A number to specify the replication of residuals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector or a matrix (nsim&gt;1) of residuals for the adjacent categories model.
</p>

<hr>
<h2 id='p_adj_cate'>p_adj_cate</h2><span id='topic+p_adj_cate'></span>

<h3>Description</h3>

<p>p_adj_cate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_adj_cate(Z)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="p_adj_cate_+3A_z">Z</code></td>
<td>
<p>A numerical vector that inputs the latent variable for generating probabilities of adjacent
categories regression model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix (n by level of respones plus 1) of probabilities of the adjacent categories model.
</p>

<hr>
<h2 id='PAsso'>Partial association analysis between ordinal responses after adjusting for a set of covariates</h2><span id='topic+PAsso'></span>

<h3>Description</h3>

<p>This function is mainly designed for conducting the partial association analysis.
It provides two ways of using:
</p>
<p>1. A user-friendly way: only need &quot;responses&quot;, &quot;adjustments&quot;, and
&quot;data&quot;. All the rest of the argument will be setted as default (see Arguments for details of
default).
</p>
<p>2. An advanced way: user can input a list of fitted models by &quot;fitted.models&quot;, then the
&quot;responses&quot; and &quot;adjustments&quot; are not necessary. Supported class of cumulative link models in
<code><a href="ordinal.html#topic+clm">clm</a></code>, <code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="rms.html#topic+lrm">lrm</a></code>,
<code><a href="rms.html#topic+orm">orm</a></code>, <code><a href="MASS.html#topic+polr">polr</a></code>, <code><a href="VGAM.html#topic+vglm">vglm</a></code>, .
</p>
<p>It generates an object that has partial association matrix, marginal association,
and some attributes: &quot;arguments&quot; saves c(association, method, resids.type). &quot;responses&quot;
contains the names of response variables. The attribute &quot;adjustments&quot; contains the names
of covariates. The &quot;summary&quot; function of &quot;PAsso&quot; class of object provides marginal association '
matrix for comparison purpose.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PAsso(
  responses,
  adjustments,
  data,
  uni.model = c("probit", "logit", "acat"),
  models = NULL,
  method = c("kendall", "pearson", "wolfsigma"),
  resids.type = c("surrogate", "sign", "general", "deviance"),
  jitter = c("latent", "uniform"),
  jitter.uniform.scale = c("probability", "response"),
  fitted.models = NULL,
  n_draws = 20,
  association = "partial",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PAsso_+3A_responses">responses</code></td>
<td>
<p>A string vector that specifies response variables. It requires to be equal
or greater than two variables in the data frame.</p>
</td></tr>
<tr><td><code id="PAsso_+3A_adjustments">adjustments</code></td>
<td>
<p>A string vector specifies covariates/confounders that need to
be adjusted.</p>
</td></tr>
<tr><td><code id="PAsso_+3A_data">data</code></td>
<td>
<p>A data.frame including responses and adjustments.</p>
</td></tr>
<tr><td><code id="PAsso_+3A_uni.model">uni.model</code></td>
<td>
<p>A character string specifying the universal model setting for all
responses. Default <code>"logit"</code> refers to cumulative logit model. <code>"probit"</code>
refers to cumulative probit model. <code>"acat"</code> fits an adjacent categories regression model.</p>
</td></tr>
<tr><td><code id="PAsso_+3A_models">models</code></td>
<td>
<p>A string vector contains default link functions of fitting models with
respect to each response variable. If <code>"models"</code> is missing or has any one of the model
unspecified, <code>"uni.model"</code> is used to specify same models for all responses automatically.
But, this argument has higher priority than the <code>"uni.model"</code> as long as the length of
<code>"models"</code> equals to the number of <code>"responses"</code>.</p>
</td></tr>
<tr><td><code id="PAsso_+3A_method">method</code></td>
<td>
<p>A string argument to specify correlation coefficient method.
Three choices <code>c("kendall", "pearson", "wolfsigma")</code>. The default is
<code>"kendall"</code></p>
</td></tr>
<tr><td><code id="PAsso_+3A_resids.type">resids.type</code></td>
<td>
<p>A character string specifying which type of residuals to generate
Current options are <code>"latent"</code> and <code>"uniform"</code>. Default is <code>"latent"</code>.
</p>

<dl>
<dt><code>surrogate</code></dt><dd><p>surrogate residuals (Liu and Zhang, 2017);</p>
</dd>
<dt><code>sign</code></dt><dd><p>sign-based residuals (Li and Shepherd, 2010, 2012);</p>
</dd>
<dt><code>general</code></dt><dd><p>generalized residuals (Franses and Paap, 2001);</p>
</dd>
<dt><code>deviance</code></dt><dd><p>deviance residuals (-2*loglik).</p>
</dd>
</dl>

<p>Although <code>"sign"</code>, <code>"general"</code>, and <code>"deviance"</code> are provided in
this package, these residuals are problematic for partial association analysis
between ordinal response (more discussions see Liu, Dungang, Li, Shaobo, Yu, Yan,
and Moustaki, Irini.(2020))</p>
</td></tr>
<tr><td><code id="PAsso_+3A_jitter">jitter</code></td>
<td>
<p>A character string specifying how to generate surrogate residuals.
Current options are <code>"latent"</code> and <code>"uniform"</code>. Default is <code>"latent"</code>.
</p>

<dl>
<dt><code>latent</code></dt><dd><p>surrogate residuals.</p>
</dd>
<dt><code>uniform</code></dt><dd><p>sign-based residuals.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="PAsso_+3A_jitter.uniform.scale">jitter.uniform.scale</code></td>
<td>
<p>A character string specifying the scale on which to perform
the jittering whenever <code>jitter = "uniform"</code>. More details: <code>PAsso::residuals</code>.</p>
</td></tr>
<tr><td><code id="PAsso_+3A_fitted.models">fitted.models</code></td>
<td>
<p>A list contains all the models (S3 objects) you want to
assess for the partial association between ordinal responses after adjusting
for a set of covariates covariates. All of these models should be applied to the
same dataset, having same covariates, same sample size etc. The models in this
list can be an object of class <code><a href="ordinal.html#topic+clm">clm</a></code>,
<code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="rms.html#topic+lrm">lrm</a></code>, <code><a href="rms.html#topic+orm">orm</a></code>,
<code><a href="MASS.html#topic+polr">polr</a></code>, <code><a href="VGAM.html#topic+vglm">vglm</a></code>.</p>
</td></tr>
<tr><td><code id="PAsso_+3A_n_draws">n_draws</code></td>
<td>
<p>A number to specify draws of surrogate residuls
such that the partial correlation coefficients are calculated repeatedly. The final
correlation coefficients are the average of all partial correlation coefficients.
It is the <code>"nsim"</code> argument in <code>"residuals()"</code> function.</p>
</td></tr>
<tr><td><code id="PAsso_+3A_association">association</code></td>
<td>
<p>An default argument to specify the partial association. Leave this
further development of package such that other association analyses can be embedded.</p>
</td></tr>
<tr><td><code id="PAsso_+3A_...">...</code></td>
<td>
<p>Additional optional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"PAsso"</code> is a list containing at least the following
components. It contains the partial correlation matrix and multiple repeats if
<code>n_draws</code> &gt; 1. This object has &quot;arguments&quot;
attribute saved as c(association, method, resids.type), &quot;responses&quot; attribute, and
&quot;adjustments&quot; attribute.
The list contains:
</p>

<dl>
<dt><code>corr</code></dt><dd><p>The estimated correlation matrix(average of <code>rep_MatCorr</code>)
of partial association after adjusting confounders;</p>
</dd>
<dt><code>rep_corr</code></dt><dd><p>The replications of estimated correlation matrix;</p>
</dd>
<dt><code>rep_SRs</code></dt><dd><p>The replications of surrogate residuals if partial association is applied;</p>
</dd>
<dt><code>fitted.models</code></dt><dd><p>The list stores all fitted.models;</p>
</dd>
<dt><code>data</code></dt><dd><p>The data.frame of original dataset;</p>
</dd>
<dt><code>mods_n</code></dt><dd><p>The sample size of each fitted model;</p>
</dd>
<dt><code>cor_func</code></dt><dd><p>The correlation function after assign different method;</p>
</dd>
<dt><code>Marg_corr</code></dt><dd><p>The marginal association matrix.</p>
</dd>
</dl>



<h3>References</h3>

<p>Liu, D., Li, S., Yu, Y., &amp; Moustaki, I. (2020). Assessing partial association between
ordinal variables: quantification, visualization, and hypothesis testing. <em>Journal
of the American Statistical Association</em>, 1-14. doi: <a href="https://doi.org/10.1080/01621459.2020.1796394">10.1080/01621459.2020.1796394</a>
</p>
<p>Liu, D., &amp; Zhang, H. (2018). Residuals and diagnostics for ordinal regression models:
A surrogate approach. <em>Journal of the American Statistical Association</em>, 113(522), 845-854.
doi: <a href="https://doi.org/10.1080/01621459.2017.1292915">10.1080/01621459.2017.1292915</a>
</p>
<p>Li, C., &amp; Shepherd, B. E. (2010). Test of association between two ordinal variables
while adjusting for covariates. <em>Journal of the American Statistical Association</em>,
105(490), 612-620. doi: <a href="https://doi.org/10.1198/jasa.2010.tm09386">10.1198/jasa.2010.tm09386</a>
</p>
<p>Li, C., &amp; Shepherd, B. E. (2012). A new residual for ordinal outcomes. <em>Biometrika</em>,
99(2), 473-480. doi: <a href="https://doi.org/10.1093/biomet/asr073">10.1093/biomet/asr073</a>
</p>
<p>Franses, P. H., &amp; Paap, R. (2001). <em>Quantitative models in marketing research</em>.
Cambridge University Press. doi: <a href="https://doi.org/10.1017/CBO9780511753794">10.1017/CBO9780511753794</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
###########################################################
# User-friendly way of using
###########################################################
library(MASS)

# Import ANES2016 data in "PAsso"
data(ANES2016)

# User-friendly way of using: Parial association analysis
PAsso_1 &lt;- PAsso(responses = c("PreVote.num", "PID"),
                adjustments = c("income.num", "age", "edu.year"),
                data = ANES2016,
                method = c("kendall"))

print(PAsso_1, digits = 4)
summary(PAsso_1, digits = 4)

###########################################################
# Advanced way of using
###########################################################

fit.vote&lt;- glm(PreVote.num ~ income.num+ age + edu.year, data = ANES2016,
               family = binomial(link = "probit"))
fit.PID&lt;- polr(as.factor(PID) ~ income.num+age+edu.year, data = ANES2016,
               method="probit", Hess = TRUE)

PAsso_adv1 &lt;- PAsso(fitted.models=list(fit.vote, fit.PID),
                    method = c("kendall"),
                    resids.type = "surrogate")

print(PAsso_adv1, digits = 4)
summary(PAsso_adv1, digits = 4)

</code></pre>

<hr>
<h2 id='plot'>A matrix of partial regression plots between responses after adjustments</h2><span id='topic+plot'></span><span id='topic+plot.PAsso'></span>

<h3>Description</h3>

<p>A plot matrix to display the results of partial association analyses.
Upper-triangle contains scatter-plot matrix between each pair of response variables.
Lower-triangle contains the partial correlation coefficients adjusted by covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PAsso'
plot(x, color = "#444444", shape = 19, size = 2, alpha = 0.5, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_+3A_x">x</code></td>
<td>
<p>The object in &quot;PAsso&quot; class that is generated by &quot;PAsso&quot; or &quot;test&quot;.</p>
</td></tr>
<tr><td><code id="plot_+3A_color">color</code></td>
<td>
<p>The color of points.</p>
</td></tr>
<tr><td><code id="plot_+3A_shape">shape</code></td>
<td>
<p>The shapre of points. For more details see the help vignette:
<code>vignette("ggplot2-specs", package = "ggplot2")</code></p>
</td></tr>
<tr><td><code id="plot_+3A_size">size</code></td>
<td>
<p>The size of points. For more details see the help vignette:
<code>vignette("ggplot2-specs", package = "ggplot2")</code></p>
</td></tr>
<tr><td><code id="plot_+3A_alpha">alpha</code></td>
<td>
<p>The value to make the points transparent. For more details see the help vignette:
<code>vignette("ggplot2-specs", package = "ggplot2")</code></p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>
<p>Additional optional arguments to be passed onto.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A pairwise plot matrix reveals the partial association between ordinal variables.
All the plots are based on surrogate residuals generated from <code>"resides"</code> function.
Graphics are designed based on <code><a href="ggplot2.html#topic+ggplot2">ggplot2</a></code> and <code>"GGally"</code>.
</p>


<h3>Value</h3>

<p>A <code>"GGally"</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ANES2016)

summary(ANES2016)

PAsso_2v &lt;- PAsso(responses = c("PreVote.num", "PID"),
                 adjustments = c("income.num", "age", "edu.year"),
                 data = ANES2016)

plot(PAsso_2v)

</code></pre>

<hr>
<h2 id='plot3D'>3-D P-P plot and false color level plot for the inspection of the partial association analysis</h2><span id='topic+plot3D'></span><span id='topic+plot3D.default'></span><span id='topic+plot3D.PAsso'></span>

<h3>Description</h3>

<p>A list of 3-D P-P plots (or false color level plots when <code>type = "contour"</code>)
for the inspection of the partial association analysis. Each plot is either 3-D P-P plot or level plot
from an empirical copula trained from the surrogate residuals of a pair of responses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot3D(object, y1, y2, ...)

## Default S3 method:
plot3D(object, y1, y2, ...)

## S3 method for class 'PAsso'
plot3D(object, y1, y2, type = c("surface3D", "contour"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot3D_+3A_object">object</code></td>
<td>
<p>A PAsso class of object.</p>
</td></tr>
<tr><td><code id="plot3D_+3A_y1">y1</code></td>
<td>
<p>A string to specify the first response for the 3D plot.</p>
</td></tr>
<tr><td><code id="plot3D_+3A_y2">y2</code></td>
<td>
<p>A string to specify the second response for the 3D plot. If either one of the
y1 or y2 is missing. The <code>plot3D</code> will draw 3D plots for all pairs of responses.</p>
</td></tr>
<tr><td><code id="plot3D_+3A_...">...</code></td>
<td>
<p>Additional optional arguments.</p>
</td></tr>
<tr><td><code id="plot3D_+3A_type">type</code></td>
<td>
<p>A character string specifying the trace type (e.g. &quot;surface3D&quot;, &quot;contour&quot;). &quot;contour&quot; creates a
2D contour plot between u and v.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All the plots are based on surrogate residuals generated from <code>"residuals"</code>
function in <code>sure</code>. Graphics are designed based on
PAsso and <code>"plotly"</code>.
</p>


<h3>Value</h3>

<p>If response y1 or y2 is not specified, a list of <code>"plotly"</code> objects includes
all pairs of responses will be returned (with name &quot;response 1 v.s. response 2&quot; etc.). If
responses y1 and y2 are specified, returns a 3D plot as <code>"plotly"</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Did not run this to save time
# data("ANES2016")
# PAsso_3v &lt;- PAsso(responses = c("PreVote.num", "PID", "selfLR"),
#                   adjustments = c("income.num", "age", "edu.year"),
#                   data = ANES2016)

# plot3D(PAsso_3v, y1="PID", y2="selfLR")
# plot3D(PAsso_3v, y1="PID", y2="selfLR", type = "contour")
</code></pre>

<hr>
<h2 id='plot3D_one'>plot3D_one</h2><span id='topic+plot3D_one'></span>

<h3>Description</h3>

<p>plot3D_one
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot3D_one(
  plot_list,
  rep_SRs,
  m,
  n,
  plot_titles,
  type = c("surface3D", "contour")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot3D_one_+3A_plot_list">plot_list</code></td>
<td>
<p>The list to save plots. Each 3D plot is between one pair of covariates.</p>
</td></tr>
<tr><td><code id="plot3D_one_+3A_rep_srs">rep_SRs</code></td>
<td>
<p>The surrogate responses array saved in the PAsso object.</p>
</td></tr>
<tr><td><code id="plot3D_one_+3A_m">m</code></td>
<td>
<p>The index of first covariate. Since the names of covariates are empty, need to input index number.</p>
</td></tr>
<tr><td><code id="plot3D_one_+3A_n">n</code></td>
<td>
<p>The index of second covariate.</p>
</td></tr>
<tr><td><code id="plot3D_one_+3A_plot_titles">plot_titles</code></td>
<td>
<p>The title of the plot.</p>
</td></tr>
<tr><td><code id="plot3D_one_+3A_type">type</code></td>
<td>
<p>A character string specifying the trace type (e.g. &quot;surface3D&quot;, &quot;contour&quot;). &quot;contour&quot; creates a
2D contour plot between u and v.</p>
</td></tr>
</table>

<hr>
<h2 id='print'>Print partial association matrix</h2><span id='topic+print'></span><span id='topic+print.PAsso'></span><span id='topic+print.PAsso.test'></span>

<h3>Description</h3>

<p>Print partial association matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PAsso'
print(x, digits = max(2, getOption("digits") - 2), ...)

## S3 method for class 'PAsso.test'
print(x, digits = max(3L, getOption("digits") - 3L), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print_+3A_x">x</code></td>
<td>
<p>A PAsso object for printing out results.</p>
</td></tr>
<tr><td><code id="print_+3A_digits">digits</code></td>
<td>
<p>A default number to specify decimal digit values.</p>
</td></tr>
<tr><td><code id="print_+3A_...">...</code></td>
<td>
<p>Additional optional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print partial association matrix of a PAsso object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See PAsso for the example.

</code></pre>

<hr>
<h2 id='residuals'>Extract Model Residuals</h2><span id='topic+residuals'></span><span id='topic+residuals.clm'></span><span id='topic+residuals.lrm'></span><span id='topic+residuals.orm'></span><span id='topic+residuals.polr'></span><span id='topic+residuals+2Cvglm-method'></span><span id='topic+residuals+2Cvgam-method'></span><span id='topic+residuals.ord'></span><span id='topic+residuals.PAsso'></span>

<h3>Description</h3>

<p>A generic function to simulate surrogate residuals for cumulative link
regression models using the latent method described in Liu and Zhang (2017).
</p>
<p>It also support the sign-based residuals (Li and Shepherd, 2010), generalized
residuals (Franses and Paap, 2001), and deviance residuals for cumulative link
regression models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'clm'
residuals(
  object,
  type = c("surrogate", "sign", "general", "deviance"),
  jitter = c("latent", "uniform"),
  jitter.uniform.scale = c("probability", "response"),
  nsim = 1L,
  ...
)

## S3 method for class 'lrm'
residuals(
  object,
  type = c("surrogate", "sign", "general", "deviance"),
  jitter = c("latent", "uniform"),
  jitter.uniform.scale = c("probability", "response"),
  nsim = 1L,
  ...
)

## S3 method for class 'orm'
residuals(
  object,
  type = c("surrogate", "sign", "general", "deviance"),
  jitter = c("latent", "uniform"),
  jitter.uniform.scale = c("probability", "response"),
  nsim = 1L,
  ...
)

## S3 method for class 'polr'
residuals(
  object,
  type = c("surrogate", "sign", "general", "deviance"),
  jitter = c("latent", "uniform"),
  jitter.uniform.scale = c("probability", "response"),
  nsim = 1L,
  ...
)

## S4 method for signature 'vglm'
residuals(
  object,
  type = c("surrogate", "sign", "general", "deviance"),
  jitter = c("latent", "uniform"),
  jitter.uniform.scale = c("probability", "response"),
  nsim = 1L,
  ...
)

## S4 method for signature 'vgam'
residuals(
  object,
  type = c("surrogate", "sign", "general", "deviance"),
  jitter = c("latent", "uniform"),
  jitter.uniform.scale = c("probability", "response"),
  nsim = 1L,
  ...
)

## S3 method for class 'ord'
residuals(
  object,
  type = c("surrogate", "sign", "general", "deviance", "pearson", "working",
    "response", "partial"),
  jitter = c("latent", "uniform"),
  jitter.uniform.scale = c("probability", "response"),
  nsim = 1L,
  ...
)

## S3 method for class 'PAsso'
residuals(object, draw_id = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuals_+3A_object">object</code></td>
<td>
<p>An object of class <code>PAsso</code>.</p>
</td></tr>
<tr><td><code id="residuals_+3A_type">type</code></td>
<td>
<p>The type of residuals which should be returned. The alternatives
are: &quot;surrogate&quot; (default), &quot;sign&quot;, &quot;general&quot;, and &quot;deviance&quot;. Can be abbreviated.
</p>

<dl>
<dt><code>surrogate</code></dt><dd><p>surrogate residuals (Liu and Zhang, 2017);</p>
</dd>
<dt><code>sign</code></dt><dd><p>sign-based residuals;</p>
</dd>
<dt><code>general</code></dt><dd><p>generalized residuals (Franses and Paap, 2001);</p>
</dd>
<dt><code>deviance</code></dt><dd><p>deviance residuals (-2*loglik).</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="residuals_+3A_jitter">jitter</code></td>
<td>
<p>When the <code>type = "surrogate"</code>, this argument is a character string
specifying which method to use to generate the surrogate response values. Current
options are <code>"latent"</code> and <code>"uniform"</code>. Default is <code>"latent"</code>.
</p>

<dl>
<dt><code>latent</code></dt><dd><p>latent approach;</p>
</dd>
<dt><code>uniform</code></dt><dd><p>jittering uniform approach.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="residuals_+3A_jitter.uniform.scale">jitter.uniform.scale</code></td>
<td>
<p>When the <code>jitter = "uniform"</code>, this is a character
string specifying the scale on which to perform the jittering whenever
<code>jitter = "uniform"</code>. Current options are <code>"response"</code> and <code>"probability"</code>.
Default is <code>"response"</code>.</p>
</td></tr>
<tr><td><code id="residuals_+3A_nsim">nsim</code></td>
<td>
<p>An integer specifying the number of replicates to use.
Default is <code>1L</code> meaning one simulation only of residuals.</p>
</td></tr>
<tr><td><code id="residuals_+3A_...">...</code></td>
<td>
<p>Additional optional arguments.</p>
</td></tr>
<tr><td><code id="residuals_+3A_draw_id">draw_id</code></td>
<td>
<p>A number refers to the i-th draw of residuals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of class <code>c("numeric", "resids")</code> containing
the simulated surrogate residuals. Additionally, if <code>nsim</code> &gt; 1,
then the result will contain the attributes:
</p>

<dl>
<dt><code>draws</code></dt><dd><p>A matrix with <code>nsim</code> columns, one for each
is a replicate of the surrogate residuals. Note, they correspond
to the original ordering of the data;</p>
</dd>
<dt><code>draws_id</code></dt><dd><p>A matrix  with <code>nsim</code> columns. Each column
contains the observation number each surrogate residuals corresponds to in
<code>draws</code>. (This is used for plotting purposes.)</p>
</dd>
</dl>

<p>A matrix of class <code>c("matrix", "resids")</code> containing
the simulated surrogate residuals used for the partial association
analysis in <code>PAsso</code>. Additionally, if <code>rep_num</code> &gt; 1 in <code>PAsso</code>,
then the result will contain the attributes:
</p>

<dl>
<dt><code>draws</code></dt><dd><p>An array contains all draws of residuals.</p>
</dd>
</dl>



<h3>Note</h3>

<p>Surrogate response values require sampling from a continuous distribution;
consequently, the result will be different with every call to
<code>surrogate</code>. The internal functions used for sampling from truncated
distributions are based on modified versions of
<code><a href="truncdist.html#topic+rtrunc">rtrunc</a></code> and <code><a href="truncdist.html#topic+qtrunc">qtrunc</a></code>.
</p>
<p>For <code>"glm"</code> objects, only the <code>binomial()</code> family is supported.
</p>


<h3>References</h3>

<p>Liu, D., Li, S., Yu, Y., &amp; Moustaki, I. (2020). Assessing partial association between
ordinal variables: quantification, visualization, and hypothesis testing. <em>Journal
of the American Statistical Association</em>, 1-14. doi: <a href="https://doi.org/10.1080/01621459.2020.1796394">10.1080/01621459.2020.1796394</a>
</p>
<p>Liu, D., &amp; Zhang, H. (2018). Residuals and diagnostics for ordinal regression models:
A surrogate approach. <em>Journal of the American Statistical Association</em>, 113(522), 845-854.
doi: <a href="https://doi.org/10.1080/01621459.2017.1292915">10.1080/01621459.2017.1292915</a>
</p>
<p>Li, C., &amp; Shepherd, B. E. (2010). Test of association between two ordinal variables
while adjusting for covariates. <em>Journal of the American Statistical Association</em>,
105(490), 612-620. doi: <a href="https://doi.org/10.1198/jasa.2010.tm09386">10.1198/jasa.2010.tm09386</a>
</p>
<p>Franses, P. H., &amp; Paap, R. (2001). <em>Quantitative models in marketing research</em>.
Cambridge University Press. doi: <a href="https://doi.org/10.1017/CBO9780511753794">10.1017/CBO9780511753794</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate data from a quadratic probit model
set.seed(101)
n &lt;- 2000
x &lt;- runif(n, min = -3, max = 6)
z &lt;- 10 + 3 * x - 1 * x^2 + rnorm(n)
y &lt;- ifelse(z &lt;= 0, yes = 0, no = 1)

# Scatterplot matrix
pairs(~ x + y + z)

# Misspecified mean structure
fm1 &lt;- glm(y ~ x, family = binomial(link = "probit"))
diagnostic.plot(fm1)

# Correctly specified mean structure
fm2 &lt;- glm(y ~ x + I(x ^ 2), family = binomial(link = "probit"))
diagnostic.plot(fm2)

# Load data
data("ANES2016")
PAsso_1 &lt;- PAsso(responses = c("PreVote.num", "PID"),
                 adjustments = c("income.num", "age", "edu.year"),
                 data = ANES2016)

# Compute residuals
res1 &lt;- residuals(PAsso_1)

</code></pre>

<hr>
<h2 id='residualsAcat'>This is a function to deal with the vglm object in S4.</h2><span id='topic+residualsAcat'></span>

<h3>Description</h3>

<p>This is a function to deal with the vglm object in S4.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>residualsAcat(
  object,
  type = c("surrogate", "sign", "general", "deviance"),
  jitter = c("latent", "uniform"),
  jitter.uniform.scale = c("probability", "response"),
  nsim = 1L,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residualsAcat_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="VGAM.html#topic+vglm">vglm</a></code>.</p>
</td></tr>
<tr><td><code id="residualsAcat_+3A_type">type</code></td>
<td>
<p>The type of residuals which should be returned. The alternatives
are: &quot;surrogate&quot; (default), &quot;sign&quot;, &quot;general&quot;, and &quot;deviance&quot;. Can be abbreviated.
</p>

<dl>
<dt><code>surrogate</code></dt><dd><p>surrogate residuals (Liu and Zhang, 2017);</p>
</dd>
<dt><code>sign</code></dt><dd><p>sign-based residuals;</p>
</dd>
<dt><code>general</code></dt><dd><p>generalized residuals (Franses and Paap, 2001);</p>
</dd>
<dt><code>deviance</code></dt><dd><p>deviance residuals (-2*loglik).</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="residualsAcat_+3A_jitter">jitter</code></td>
<td>
<p>A character string specifying which method to use to generate the
surrogate response values. Current options are <code>"latent"</code> and
<code>"uniform"</code>. Default is <code>"latent"</code>.
</p>

<dl>
<dt><code>latent</code></dt><dd><p>latent approach;</p>
</dd>
<dt><code>uniform</code></dt><dd><p>jittering uniform approach.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="residualsAcat_+3A_jitter.uniform.scale">jitter.uniform.scale</code></td>
<td>
<p>A character string specifying the scale on which to perform
the jittering whenever <code>jitter = "uniform"</code>. Current options are
<code>"response"</code> and <code>"probability"</code>. Default is <code>"response"</code>.</p>
</td></tr>
<tr><td><code id="residualsAcat_+3A_nsim">nsim</code></td>
<td>
<p>An integer specifying the number of replicates to use.
Default is <code>1L</code> meaning one simulation only of residuals.</p>
</td></tr>
<tr><td><code id="residualsAcat_+3A_...">...</code></td>
<td>
<p>Additional optional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A &quot;resid&quot; object with attributes. It contains a vector or a matrix (nsim&gt;1) of
residuals for the adjacent categories model.
</p>

<hr>
<h2 id='residualsVGAM'>Extract Residuals from models of VGAM</h2><span id='topic+residualsVGAM'></span>

<h3>Description</h3>

<p>A internal function to simulate surrogate residuals for models fitted by
<code><a href="VGAM.html#topic+vglm">vglm</a></code> and <code><a href="VGAM.html#topic+vglm">vglm</a></code>. Now, this one support <code>"vglm"</code> and
<code>"vgam"</code>, and adjacent categories regression model by <code>"vglm"</code>. This one may
need to update to support more models from VGAM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>residualsVGAM(
  object,
  type = c("surrogate", "sign", "general", "deviance"),
  jitter = c("latent", "uniform"),
  jitter.uniform.scale = c("probability", "response"),
  nsim = 1L,
  ...
)
</code></pre>

<hr>
<h2 id='summary'>Summary of partial association analysis</h2><span id='topic+summary'></span><span id='topic+summary.PAsso'></span>

<h3>Description</h3>

<p>This function summarizes the partial association analysis by
providing partial association matrix, marginal association matrix, and a
matrix of the models' coefficients. The partial correlation coefficient
matrix displays the partial association between each pair of responses
after adjusting the covariates. While the marginal coefficient matrix displays association
before the adjustment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PAsso'
summary(object, digits = max(3L, getOption("digits") - 2L), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary_+3A_object">object</code></td>
<td>
<p>A PAsso object to draw the summarized results, which includes partial association
matrix and a matrix of the models' coefficients.</p>
</td></tr>
<tr><td><code id="summary_+3A_digits">digits</code></td>
<td>
<p>A default number to specify decimal digit values.</p>
</td></tr>
<tr><td><code id="summary_+3A_...">...</code></td>
<td>
<p>Additional optional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For a PAsso object, print its partial association matrix, marginal association
matrix, and a matrix of the models' coefficients.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See PAsso for the example.

</code></pre>

<hr>
<h2 id='surrogate'>Surrogate response</h2><span id='topic+surrogate'></span>

<h3>Description</h3>

<p>Simulate surrogate response values for cumulative link regression models
using the latent method described in Liu and Zhang (2017).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surrogate(
  object,
  method = c("latent", "uniform"),
  jitter.uniform.scale = c("probability", "response"),
  nsim = 1L,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="surrogate_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="ordinal.html#topic+clm">clm</a></code>,
<code><a href="stats.html#topic+glm">glm</a></code> <code><a href="rms.html#topic+lrm">lrm</a></code>, <code><a href="rms.html#topic+orm">orm</a></code>,
<code><a href="MASS.html#topic+polr">polr</a></code>, or <code><a href="VGAM.html#topic+vglm">vglm</a></code>.</p>
</td></tr>
<tr><td><code id="surrogate_+3A_method">method</code></td>
<td>
<p>Character string specifying which method to use to generate the
surrogate response values. Current options are <code>"latent"</code> and
<code>"uniform"</code>. Default is <code>"latent"</code>.</p>
</td></tr>
<tr><td><code id="surrogate_+3A_jitter.uniform.scale">jitter.uniform.scale</code></td>
<td>
<p>Character string specifying the scale on which to perform
the jittering whenever <code>method = "uniform"</code>. Current options are
<code>"response"</code> and <code>"probability"</code>. Default is <code>"response"</code>.</p>
</td></tr>
<tr><td><code id="surrogate_+3A_nsim">nsim</code></td>
<td>
<p>Integer specifying the number of bootstrap replicates to use.
Default is <code>1L</code> meaning no bootstrap samples.</p>
</td></tr>
<tr><td><code id="surrogate_+3A_...">...</code></td>
<td>
<p>Additional optional arguments. (Currently ignored.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of class <code>c("numeric", "surrogate")</code> containing
the simulated surrogate response values. Additionally, if <code>nsim</code> &gt; 1,
then the result will contain the attributes:
</p>

<dl>
<dt><code>boot_reps</code></dt><dd><p>A matrix  with <code>nsim</code> columns, one for each
bootstrap replicate of the surrogate values. Note, these are random and do
not correspond to the original ordering of the data;</p>
</dd>
<dt><code>boot_id</code></dt><dd><p>A matrix  with <code>nsim</code> columns. Each column
contains the observation number each surrogate value corresponds to in
<code>boot_reps</code>. (This is used for plotting purposes.)</p>
</dd>
</dl>



<h3>Note</h3>

<p>Surrogate response values require sampling from a continuous distribution;
consequently, the result will be different with every call to
<code>surrogate</code>. The internal functions used for sampling from truncated
distributions are based on modified versions of
<code>truncdist:rtrunc</code> and <code>truncdist:qtrunc</code>.
</p>
<p>For <code>"glm"</code> objects, only the <code>binomial()</code> family is supported.
</p>


<h3>References</h3>

<p>Liu, D., Li, S., Yu, Y., &amp; Moustaki, I. (2020). Assessing partial association between
ordinal variables: quantification, visualization, and hypothesis testing. <em>Journal
of the American Statistical Association</em>, 1-14. doi: <a href="https://doi.org/10.1080/01621459.2020.1796394">10.1080/01621459.2020.1796394</a>
</p>
<p>Liu, D., &amp; Zhang, H. (2018). Residuals and diagnostics for ordinal regression models:
A surrogate approach. <em>Journal of the American Statistical Association</em>, 113(522), 845-854.
doi: <a href="https://doi.org/10.1080/01621459.2017.1292915">10.1080/01621459.2017.1292915</a>
</p>
<p>Nadarajah, S., &amp; Kotz, S. (2006). R Programs for Truncated Distributions. <em>Journal
of Statistical Software</em>, 16(Code Snippet 2), 1 - 8. doi: <a href="https://doi.org/10.18637/jss.v016.c02">10.18637/jss.v016.c02</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate data from a quadratic probit model
set.seed(101)
n &lt;- 2000
x &lt;- runif(n, min = -3, max = 6)
z &lt;- 10 + 3*x - 1*x^2 + rnorm(n)
y &lt;- ifelse(z &lt;= 0, yes = 0, no = 1)

# Scatterplot matrix
pairs(~ x + y + z)

# Setup for side-by-side plots
par(mfrow = c(1, 2))

# Misspecified mean structure
fm1 &lt;- glm(y ~ x, family = binomial(link = "probit"))
s1 &lt;- surrogate(fm1)
scatter.smooth(x, s1 - fm1$linear.predictors,
               main = "Misspecified model",
               ylab = "Surrogate residual",
               lpars = list(lwd = 3, col = "red2"))
abline(h = 0, lty = 2, col = "blue2")

# Correctly specified mean structure
fm2 &lt;- glm(y ~ x + I(x ^ 2), family = binomial(link = "probit"))
s2 &lt;- surrogate(fm2)
scatter.smooth(x, s2 - fm2$linear.predictors,
               main = "Correctly specified model",
               ylab = "Surrogate residual",
               lpars = list(lwd = 3, col = "red2"))
abline(h = 0, lty = 2, col = "blue2")


dev.off() # reset to defaults once finish

</code></pre>

<hr>
<h2 id='test'>Hypothesis testing of the partial association coefficients</h2><span id='topic+test'></span>

<h3>Description</h3>

<p>This function use bootstrapping to conduct hypothesis testing
for the partial association coefficients. It directly applies onto the &quot;PAsso&quot;
class of object generated by &quot;PAsso&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test(object, bootstrap_rep = 300, H0 = 0, parallel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test_+3A_object">object</code></td>
<td>
<p>An object of &quot;PAsso&quot; class, which is generated by &quot;PAsso&quot; function.</p>
</td></tr>
<tr><td><code id="test_+3A_bootstrap_rep">bootstrap_rep</code></td>
<td>
<p>The number of bootstrap replications. It may be slow.</p>
</td></tr>
<tr><td><code id="test_+3A_h0">H0</code></td>
<td>
<p>null hypothesis of partial correlation coefficient.</p>
</td></tr>
<tr><td><code id="test_+3A_parallel">parallel</code></td>
<td>
<p>logical argument whether conduct parallel for bootstrapping partial association.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Import ANES2016 data in "PAsso"
data(ANES2016)
# Parial association:
PAsso_2v &lt;- PAsso(responses = c("PreVote.num", "PID"),
                adjustments = c("income.num", "age", "edu.year"),
                data = ANES2016)

summary(PAsso_2v, digits=4)

PAsso_2v_test &lt;- test(object = PAsso_2v, bootstrap_rep=20, H0=0, parallel=FALSE)
PAsso_2v_test

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
