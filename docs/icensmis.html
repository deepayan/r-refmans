<!DOCTYPE html><html><head><title>Help for package icensmis</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {icensmis}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bayesmc'><p>Bayesian method for high-dimensional variable selection</p></a></li>
<li><a href='#datasim'><p>Simulate data including multiple outcomes from error-prone diagnostic tests</p>
or self-reports</a></li>
<li><a href='#fitsurv'><p>Fit survival function, used for Bayesian simulation</p></a></li>
<li><a href='#icmis'><p>Maximum likelihood estimation for settings of error-prone diagnostic tests</p>
and self-reported outcomes</a></li>
<li><a href='#icpower'><p>Study design in the presence of error-prone diagnostic tests and</p>
self-reported outcomes</a></li>
<li><a href='#icpower_weibull'><p>Study design in the presence of error-prone diagnostic tests and</p>
self-reported outcomes for Weibull model</a></li>
<li><a href='#icpower.val'><p>Study design in the presence of error-prone diagnostic tests and</p>
self-reported outcomes when sensitivity and specificity are unkonwn and a
validation set is used</a></li>
<li><a href='#icpowerpf'><p>Study design in the presence of interval censored outcomes (assuming perfect</p>
diagnostic tests)</a></li>
<li><a href='#plot_surv'><p>Plot survival function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Study Design and Data Analysis in the Presence of Error-Prone
Diagnostic Tests and Self-Reported Outcomes</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-08-27</td>
</tr>
<tr>
<td>Author:</td>
<td>Xiangdong Gu and Raji Balasubramanian</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Xiangdong Gu &lt;ustcgxd@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>We consider studies in which information from error-prone
    diagnostic tests or self-reports are gathered sequentially to determine the
    occurrence of a silent event. Using a likelihood-based approach
    incorporating the proportional hazards assumption, we provide functions to
    estimate the survival distribution and covariate effects. We also provide 
    functions for power and sample size calculations for this setting.
    Please refer to Xiangdong Gu, Yunsheng Ma, and Raji Balasubramanian (2015) 
    &lt;<a href="https://doi.org/10.1214%2F15-AOAS810">doi:10.1214/15-AOAS810</a>&gt;, Xiangdong Gu and Raji Balasubramanian (2016) 
    &lt;<a href="https://doi.org/10.1002%2Fsim.6962">doi:10.1002/sim.6962</a>&gt;, Xiangdong Gu, Mahlet G Tadesse, Andrea S Foulkes,
    Yunsheng Ma, and Raji Balasubramanian (2020) &lt;<a href="https://doi.org/10.1186%2Fs12911-020-01223-w">doi:10.1186/s12911-020-01223-w</a>&gt;.</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.11.3)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-08-27 01:05:27 UTC; xiangdong</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-09-02 14:50:28 UTC</td>
</tr>
</table>
<hr>
<h2 id='bayesmc'>Bayesian method for high-dimensional variable selection</h2><span id='topic+bayesmc'></span>

<h3>Description</h3>

<p>Bayesian method for high-dimensional variable selection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayesmc(Dm, Xmat, b, om1, om2, niter, psample, initsurv, nreport, fitsurv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bayesmc_+3A_dm">Dm</code></td>
<td>
<p>the D matrix</p>
</td></tr>
<tr><td><code id="bayesmc_+3A_xmat">Xmat</code></td>
<td>
<p>the design matrix</p>
</td></tr>
<tr><td><code id="bayesmc_+3A_b">b</code></td>
<td>
<p>the prior distribution parameter for beta, normal std</p>
</td></tr>
<tr><td><code id="bayesmc_+3A_om1">om1</code></td>
<td>
<p>the prior distribution parameter for omega</p>
</td></tr>
<tr><td><code id="bayesmc_+3A_om2">om2</code></td>
<td>
<p>the piror distribution parameter for omega</p>
</td></tr>
<tr><td><code id="bayesmc_+3A_niter">niter</code></td>
<td>
<p>number of iteration</p>
</td></tr>
<tr><td><code id="bayesmc_+3A_psample">psample</code></td>
<td>
<p>the sampling probability for updading regresson coefficient</p>
</td></tr>
<tr><td><code id="bayesmc_+3A_initsurv">initsurv</code></td>
<td>
<p>initial survival probabilities at end of study</p>
</td></tr>
<tr><td><code id="bayesmc_+3A_nreport">nreport</code></td>
<td>
<p>every how many iterations to output parameters</p>
</td></tr>
<tr><td><code id="bayesmc_+3A_fitsurv">fitsurv</code></td>
<td>
<p>the survival parameters optimization function</p>
</td></tr>
</table>

<hr>
<h2 id='datasim'>Simulate data including multiple outcomes from error-prone diagnostic tests 
or self-reports</h2><span id='topic+datasim'></span>

<h3>Description</h3>

<p>This function simulates a data of N subjects with misclassified 
outcomes, assuming each subject receives a sequence of pre-scheduled tests 
for disease status ascertainment. Each test is subject to error, 
characterized by sensitivity and specificity. An exponential distribution 
is assumed for the time to event of interest. Three kinds of covariate 
settings can be generated: one sample setting, two group setting, and 
continuous covariates setting with each covariate sampled from i.i.d. N(0, 
1). Two missing mechanisms can be assumed, namely MCAR and NTFP. The MCAR 
setting assumes that each test is subject to a constant, independent 
probability of missingness. The NTFP mechanism includes two types of 
missingness - (1) incorporates a constant, independent, probability of 
missing for each test prior to the first positive test result; and (2) all 
test results after first positive are missing. The simulated data is in 
longitudinal form with one row per test time.
</p>
<p>Covariate values, by default, are assumed to be constant. However, this 
function can simulate a special case of time varying covariates. Under time
varying covariates setting, each subject is assumed to have a change time 
point, which is sampled from the visit times. We assume that each subject 
has two sets of covariate values. Before his change time point, the 
covariate values take from the first set, and second set after change time 
point. Thus, each subject's distribution of survival time is two-piece 
exponential distribution with different hazard rates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>datasim(
  N,
  blambda,
  testtimes,
  sensitivity,
  specificity,
  betas = NULL,
  twogroup = NULL,
  pmiss = 0,
  pcensor = 0,
  design = "MCAR",
  negpred = 1,
  time.varying = F
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="datasim_+3A_n">N</code></td>
<td>
<p>total number of subjects to be simulated</p>
</td></tr>
<tr><td><code id="datasim_+3A_blambda">blambda</code></td>
<td>
<p>baseline hazard rate</p>
</td></tr>
<tr><td><code id="datasim_+3A_testtimes">testtimes</code></td>
<td>
<p>a vector of pre-scheduled test times</p>
</td></tr>
<tr><td><code id="datasim_+3A_sensitivity">sensitivity</code></td>
<td>
<p>the sensitivity of test</p>
</td></tr>
<tr><td><code id="datasim_+3A_specificity">specificity</code></td>
<td>
<p>the specificity of test</p>
</td></tr>
<tr><td><code id="datasim_+3A_betas">betas</code></td>
<td>
<p>a vector of regression coefficients of the same length as the 
covariate vector. If betas = NULL then the simulated dataset corresponds to
the one sample setting. If betas != NULL and twogroup != NULL then the 
simulated dataset corresponds to the two group setting, and the first value
of betas is used as the coefficient for the treatment group indicator. If 
betas != NULL and twogroup = NULL, then the covariates are ~ i.i.d. N(0, 
1), and the number of covariates is determined by the length of betas.</p>
</td></tr>
<tr><td><code id="datasim_+3A_twogroup">twogroup</code></td>
<td>
<p>corresponds to the proportion of subjects allocated to the 
baseline (reference) group in the two-group setting. For the two-group 
setting, this variable should be between 0 and 1. For the one sample and 
multiple (&gt;= 2) covariate setting, this variable should be set to NULL. 
That is, when betas !=NULL, set twogroup to equal the proportion of the 
subjects in the baseline group to obtain a simulated dataset corresponding 
to the two-group setting. Else, set twogroup=NULL to obtain either the one 
sample setting (betas=NULL) or continuous covariates (betas !=NULL).</p>
</td></tr>
<tr><td><code id="datasim_+3A_pmiss">pmiss</code></td>
<td>
<p>a value or a vector (must have same length as testtimes) of the 
probabilities of each test being randomly missing at each test time. If 
pmiss is a single value, then each test is assumed to have an identical 
probability of missingness.</p>
</td></tr>
<tr><td><code id="datasim_+3A_pcensor">pcensor</code></td>
<td>
<p>a value or a vector (must have same length as testtimes) of
the interval probabilities of censoring time at each interval, 
assuming censoring process
is independent on other missing mechanisms. If it is the single value, then
we assume same interval probabilities as the value. The sum of pcensor (or 
pcensor * length(testtimes) if it is single value) must be &lt;= 1. For example,
if pcensor = c(0.1, 0.2), then it means the the probabilities of censoring time
in first and second intervals are 0.1, 0.2, and the probability of not being
censored is 0.7.</p>
</td></tr>
<tr><td><code id="datasim_+3A_design">design</code></td>
<td>
<p>missing mechanism: &quot;MCAR&quot; or &quot;NTFP&quot;</p>
</td></tr>
<tr><td><code id="datasim_+3A_negpred">negpred</code></td>
<td>
<p>baseline negative predictive value, i.e. the probability of being 
truely disease free for those who were tested (reported) as disease free at
baseline. If baseline screening test is perfect, then negpred = 1.</p>
</td></tr>
<tr><td><code id="datasim_+3A_time.varying">time.varying</code></td>
<td>
<p>indicator whether fitting a time varying covariate model 
or not</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To simulate the one sample setting data, set betas to be NULL. To 
simulate the two group setting data, set twogroup to equal the proportion 
of the subjects in the baseline group and set betas to equal the 
coefficient corresponding to the treatment group indicator(i.e. beta equals
the log hazard ratio of the two groups). To simulate data with continuous 
i.i.d. N(0, 1) covariates, set twogroup to be NULL and set betas to equal 
the vector of coefficients of the covariates.
</p>


<h3>Value</h3>

<p>simulated longitudinal form data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## One sample setting  
simdata1 &lt;- datasim(N = 1000, blambda = 0.05, testtimes = 1:8, sensitivity = 0.7,
  specificity = 0.98, betas = NULL, twogroup = NULL, pmiss = 0.3, design = "MCAR")

## Two group setting, and the two groups have same sample sizes
simdata2 &lt;- datasim(N = 1000, blambda = 0.05, testtimes = 1:8, sensitivity = 0.7,
  specificity = 0.98, betas = 0.7, twogroup = 0.5, pmiss = 0.3, design = "MCAR")
  
## Three covariates with coefficients 0.5, 0.8, and 1.0
simdata3 &lt;- datasim(N = 1000, blambda = 0.05, testtimes = 1:8, sensitivity = 0.7,
  specificity = 0.98, betas = c(0.5, 0.8, 1.0), twogroup = NULL, pmiss = 0.3,
  design = "MCAR", negpred = 1)

## NTFP missing mechanism
simdata4 &lt;- datasim(N = 1000, blambda = 0.05, testtimes = 1:8, sensitivity = 0.7,
  specificity = 0.98, betas = c(0.5, 0.8, 1.0), twogroup = NULL, pmiss = 0.3,
  design = "NTFP", negpred = 1)	 

## Baseline misclassification
simdata5 &lt;- datasim(N = 2000, blambda = 0.05, testtimes = 1:8, sensitivity = 0.7,
  specificity = 0.98, betas = c(0.5, 0.8, 1.0), twogroup = NULL, pmiss = 0.3, 
  design = "MCAR", negpred = 0.97)  
  
## Time varying covariates
simdata6 &lt;- datasim(N = 1000, blambda = 0.05, testtimes = 1:8, sensitivity = 0.7,
  specificity = 0.98, betas = c(0.5, 0.8, 1.0), twogroup = NULL, pmiss = 0.3,
  design = "MCAR", negpred = 1, time.varying = TRUE)  
  
</code></pre>

<hr>
<h2 id='fitsurv'>Fit survival function, used for Bayesian simulation</h2><span id='topic+fitsurv'></span>

<h3>Description</h3>

<p>Fit survival function, used for Bayesian simulation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitsurv(parm, Dm, eta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitsurv_+3A_parm">parm</code></td>
<td>
<p>the initial parameter value</p>
</td></tr>
<tr><td><code id="fitsurv_+3A_dm">Dm</code></td>
<td>
<p>the D matrix</p>
</td></tr>
<tr><td><code id="fitsurv_+3A_eta">eta</code></td>
<td>
<p>equals to X*bea</p>
</td></tr>
</table>

<hr>
<h2 id='icmis'>Maximum likelihood estimation for settings of error-prone diagnostic tests 
and self-reported outcomes</h2><span id='topic+icmis'></span>

<h3>Description</h3>

<p>This function estimates the baseline survival function evaluated at each test
time in the presence of error-prone diagnostic tests and self-reported 
outcomes. If there are covariates included in the dataset, it also estimates 
their coefficients assuming proportional hazards. The covariate values can be
either time independent or time varying The function can also be used to
incorporate misclassification of disease status at baseline (due to an
error-prone diagnostic procedure).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>icmis(
  subject,
  testtime,
  result,
  data,
  sensitivity,
  specificity,
  formula = NULL,
  negpred = 1,
  time.varying = F,
  betai = NULL,
  initsurv = 0.5,
  param = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="icmis_+3A_subject">subject</code></td>
<td>
<p>variable in data for subject id.</p>
</td></tr>
<tr><td><code id="icmis_+3A_testtime">testtime</code></td>
<td>
<p>variable in data for test time. Assume all test times are 
non-negative. testtime = 0 refers to baseline visit (only used/needed if 
the model is time varying covarites)</p>
</td></tr>
<tr><td><code id="icmis_+3A_result">result</code></td>
<td>
<p>variable in data for test result.</p>
</td></tr>
<tr><td><code id="icmis_+3A_data">data</code></td>
<td>
<p>the data to analyze.</p>
</td></tr>
<tr><td><code id="icmis_+3A_sensitivity">sensitivity</code></td>
<td>
<p>the sensitivity of test.</p>
</td></tr>
<tr><td><code id="icmis_+3A_specificity">specificity</code></td>
<td>
<p>the specificity of test.</p>
</td></tr>
<tr><td><code id="icmis_+3A_formula">formula</code></td>
<td>
<p>a formula to specify what covariates to be included in the 
model. If there is no covariate or one sample setting, set it to NULL. 
Otherwise, input like ~x1 + x2 + factor(x3).</p>
</td></tr>
<tr><td><code id="icmis_+3A_negpred">negpred</code></td>
<td>
<p>baseline negative predictive value, i.e. the probability of 
being truely disease free for those who were tested (reported) as disease 
free at baseline. If baseline screening test is perfect, then negpred = 1.</p>
</td></tr>
<tr><td><code id="icmis_+3A_time.varying">time.varying</code></td>
<td>
<p>indicator whether fitting a time varying covariate model 
or not.</p>
</td></tr>
<tr><td><code id="icmis_+3A_betai">betai</code></td>
<td>
<p>a vector of initial values for the regression coefficients 
corresponding to the vector of covariates. If betai=NULL, then 0s are used 
for the initial values. Otherwise, the length of betai must equal the 
number of covariates.</p>
</td></tr>
<tr><td><code id="icmis_+3A_initsurv">initsurv</code></td>
<td>
<p>initial value for survival function of baseline group in the 
last visit time. It is used to compute initival values for survival 
function at all visit times.</p>
</td></tr>
<tr><td><code id="icmis_+3A_param">param</code></td>
<td>
<p>parameterization for survival function used for optimization, 
taking values 1, 2, or 3. There are 3 parameterizations available. param = 
1: this parameterization uses the change in cumulative incidence in time 
period j for baseline group as parameters, i.e. log(S[j]) - log(S[j+1]). 
param = 2: simply use log of the parameters in param = 1 so that those 
parameters are unbounded. param = 3: the first element is 
log(-log(S[tau_1])) corresponding to log-log transformation of survival 
function at first visit, while other parameters are corresponding to the 
change in log-log of surival function, log(-log(S[j])) - log(-log(S[j-1])).
In most cases, all parameters yield same results , while in some situations
especially when two visit times are estimated to have same survival 
functions, they may differ. Choose the one that works best (check 
likelihood function)</p>
</td></tr>
<tr><td><code id="icmis_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code><a href="stats.html#topic+optim">optim</a></code> function. For 
example, if the optimization does not converge, we can increase maxit in 
the optim function's control argument.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input data should be in longitudinal form with one row per test 
time. Use <code><a href="#topic+datasim">datasim</a></code> to simulate a dataset to see the sample 
data structure. If time varying model is to be fitted, the baseline visit 
must be provided so that the baseline covariate information can be 
extracted. If an error is generated due to the optimization procedure, then
we recommend trying different initial values.
</p>
<p>This likelihood-based approach is a function of the survival function
evaluated at each unique test time in the dataset and the vector of
regression coefficients as model parameters. Therefore, it works best for
situations where there is a limited number of unique test times in the
dataset. If there are a large number of unique test times, one solution is
to group several test times together.
</p>


<h3>Value</h3>

<p>A list of fitting results is returned with log-likelihood, estimated 
coefficiets, estimated survival function, and estimated covariance matrix 
for covariates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## One sample setting
simdata1 &lt;- datasim(N = 1000, blambda = 0.05, testtimes = 1:8,
 sensitivity = 0.7, specificity = 0.98, betas = NULL, 
 twogroup = NULL, pmiss = 0.3, design = "MCAR")
fit1 &lt;- icmis(subject = ID, testtime = testtime, result = result,
 data = simdata1, sensitivity = 0.7, specificity= 0.98, 
 formula = NULL, negpred = 1)	
             			  
## Two group setting, and the two groups have same sample sizes
simdata2 &lt;- datasim(N = 1000, blambda = 0.05, testtimes = 1:8,
 sensitivity = 0.7, specificity = 0.98, betas = 0.7, 
 twogroup = 0.5, pmiss = 0.3, design = "MCAR")					  
fit2 &lt;- icmis(subject = ID, testtime = testtime, result = result,
 data = simdata2, sensitivity = 0.7, specificity= 0.98,
 formula = ~group)
 
## Three covariates with coefficients 0.5, 0.8, and 1.0
simdata3 &lt;- datasim(N = 1000, blambda = 0.05, testtimes = 1:8, 
sensitivity = 0.7, specificity = 0.98, betas = c(0.5, 0.8, 1.0),
 twogroup = NULL, pmiss = 0.3, design = "MCAR", negpred = 1)					  
fit3 &lt;- icmis(subject = ID, testtime = testtime, result = result,
data = simdata3, sensitivity = 0.7, specificity= 0.98, 
formula = ~cov1+cov2+cov3, negpred = 1)
 
## Fit data with NTFP missing mechanism (the fitting is same as MCAR data)
simdata4 &lt;- datasim(N = 1000, blambda = 0.05, testtimes = 1:8,
 sensitivity = 0.7, specificity = 0.98, betas = c(0.5, 0.8, 1.0),
  twogroup = NULL, pmiss = 0.3, design = "NTFP", negpred = 1)
fit4 &lt;- icmis(subject = ID, testtime = testtime, result = result,
 data = simdata4, sensitivity = 0.7, specificity= 0.98,
 formula = ~cov1+cov2+cov3, negpred = 1)
              					  
## Fit data with baseline misclassification
simdata5 &lt;- datasim(N = 2000, blambda = 0.05, testtimes = 1:8,
 sensitivity = 0.7, specificity = 0.98, betas = c(0.5, 0.8, 1.0),
  twogroup = NULL, pmiss = 0.3, design = "MCAR", negpred = 0.97)
fit5 &lt;- icmis(subject = ID, testtime = testtime, result = result,
 data = simdata5, sensitivity = 0.7, specificity= 0.98,
 formula = ~cov1+cov2+cov3, negpred = 0.97)
  
## Fit data with time varying covariates
simdata6 &lt;- datasim(N = 1000, blambda = 0.05, testtimes = 1:8,
 sensitivity = 0.7, specificity = 0.98, betas = c(0.5, 0.8, 1.0),
 twogroup = NULL, pmiss = 0.3, design = "MCAR", negpred = 1,
 time.varying = TRUE)
fit6 &lt;- icmis(subject = ID, testtime = testtime, result = result,
 data = simdata6, sensitivity = 0.7, specificity= 0.98,
 formula = ~cov1+cov2+cov3, negpred = 1, time.varying = TRUE)
</code></pre>

<hr>
<h2 id='icpower'>Study design in the presence of error-prone diagnostic tests and 
self-reported outcomes</h2><span id='topic+icpower'></span>

<h3>Description</h3>

<p>This function calculates the power and sample in the presence of error-prone 
diagnostic tests and self-reported outcomes.  Two missing mechanisms can be 
assumed, namely MCAR and NTFP. The MCAR setting assumes that each test is 
subject to a constant, independent probability of missingness. The NTFP 
mechanism includes two types of missingness - (1) incorporates a constant, 
independent, probability of missing for each test prior to the first positive
test result; and (2) all test results after first positive are missing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>icpower(
  HR,
  sensitivity,
  specificity,
  survivals,
  N = NULL,
  power = NULL,
  rho = 0.5,
  alpha = 0.05,
  pmiss = 0,
  pcensor = 0,
  design = "MCAR",
  negpred = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="icpower_+3A_hr">HR</code></td>
<td>
<p>hazard ratio under the alternative hypothesis.</p>
</td></tr>
<tr><td><code id="icpower_+3A_sensitivity">sensitivity</code></td>
<td>
<p>the sensitivity of test.</p>
</td></tr>
<tr><td><code id="icpower_+3A_specificity">specificity</code></td>
<td>
<p>the specificity of test</p>
</td></tr>
<tr><td><code id="icpower_+3A_survivals">survivals</code></td>
<td>
<p>a vector of survival function at each test time for 
baseline(reference) group. Its length determines the number of tests.</p>
</td></tr>
<tr><td><code id="icpower_+3A_n">N</code></td>
<td>
<p>a vector of sample sizes to calculate corresponding powers. If one 
needs to calculate sample size, then set to NULL.</p>
</td></tr>
<tr><td><code id="icpower_+3A_power">power</code></td>
<td>
<p>a vector of powers to calculate corresponding sample sizes. If 
one needs to calculate power, then set to NULL.</p>
</td></tr>
<tr><td><code id="icpower_+3A_rho">rho</code></td>
<td>
<p>proportion of subjects in baseline(reference) group.</p>
</td></tr>
<tr><td><code id="icpower_+3A_alpha">alpha</code></td>
<td>
<p>type I error.</p>
</td></tr>
<tr><td><code id="icpower_+3A_pmiss">pmiss</code></td>
<td>
<p>a value or a vector (must have same length as survivals) of the 
probabilities of each test being randomly missing at each test time. If 
pmiss is a single value, then each test is assumed to have an identical 
probability of missingness.</p>
</td></tr>
<tr><td><code id="icpower_+3A_pcensor">pcensor</code></td>
<td>
<p>a value or a vector (must have same length as survivals) of
the interval probabilities of censoring time at each interval, 
assuming censoring process
is independent on other missing mechanisms. If it is the single value, then
we assume same interval probabilities as the value. The sum of pcensor (or 
pcensor * length(survivals) if it is single value) must be &lt;= 1. For example,
if pcensor = c(0.1, 0.2), then it means the the probabilities of censoring time
in first and second intervals are 0.1, 0.2, and the probability of not being
censored is 0.7.</p>
</td></tr>
<tr><td><code id="icpower_+3A_design">design</code></td>
<td>
<p>missing mechanism: &quot;MCAR&quot; or &quot;NTFP&quot;.</p>
</td></tr>
<tr><td><code id="icpower_+3A_negpred">negpred</code></td>
<td>
<p>baseline negative predictive value, i.e. the probability of 
being truely disease free for those who were tested (reported) as disease 
free at baseline. If baseline screening test is perfect, then negpred = 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To calculate sample sizes for a vector of powers, set N = NULL. To 
calculate powers for a vector of sample sizes, set power = NULL. One and 
only one of power and N should be specified, and the other set to NULL. 
This function uses an enumeration algorithm to calculate the expected 
Fisher information matrix. The expected Fisher information matrix is used 
to obtain the variance of the coefficient corresponding to the treatment 
group indicator.
</p>


<h3>Value</h3>

 <ul>
<li><p> result: a data frame with calculated sample size and 
power </p>
</li>
<li><p> I1 and I2: calculated unit Fisher information matrices for each
group, which can be used to calculate more values of sample size and power 
for the same design without the need to enumerate again </p>
</li></ul>



<h3>Note</h3>

<p>When diagnostic test is perfect, i.e. sensitivity=1 and 
specificity=1, use <code><a href="#topic+icpowerpf">icpowerpf</a></code> instead to obtain significantly 
improved computational efficiency.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+icpowerpf">icpowerpf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## First specificy survivals. Assume test times are 1:8, with survival function 
## at the end time 0.9  				  
surv &lt;- exp(log(0.9)*(1:8)/8)					  

## Obtain power vs. N					  				
pow1 &lt;- icpower(HR = 2, sensitivity = 0.55, specificity = 0.99, survivals = surv, 
   N = seq(500, 1500, 50), power = NULL, rho = 0.5, alpha = 0.05, 
   pmiss = 0, design = "MCAR", negpred = 1)

plot(pow1$result$N, pow1$result$power, type="l", xlab="N", ylab="power")

## Calculate sample size, assuming desired power is 0.9
pow2 &lt;- icpower(HR = 2, sensitivity = 0.55, specificity = 0.99, survivals = surv,
   N = NULL, power = 0.9, rho = 0.5, alpha = 0.05, pmiss = 0, design = "MCAR",
   negpred = 1)

## When missing test is present with MCAR
pow3 &lt;- icpower(HR = 2, sensitivity = 0.55, specificity = 0.99, survivals = surv,
   N = NULL, power = 0.9, rho = 0.5, alpha = 0.05, pmiss = 0.4, design = "MCAR",
   negpred = 1)

## When missing test is present with NTFP
pow4 &lt;- icpower(HR = 2, sensitivity = 0.55, specificity = 0.99, survivals = surv,
   N = NULL, power = 0.9, rho = 0.5, alpha = 0.05, pmiss = 0.4, design = "NTFP",
   negpred = 1)

## When baseline misclassification is present
pow5 &lt;- icpower(HR = 2, sensitivity = 0.55, specificity = 0.99, survivals = surv,
   N = NULL, power = 0.9, rho = 0.5, alpha = 0.05, pmiss = 0, design = "MCAR",
   negpred = 0.98)		 

## When test is  perfect and no missing test		 
pow6 &lt;- icpower(HR = 2, sensitivity = 1, specificity = 1, survivals = surv,
   N = NULL, power = 0.9, rho = 0.5, alpha = 0.05, pmiss = 0, design = "MCAR",
   negpred = 1)	

## Different missing probabilities at each test time
pow7 &lt;- icpower(HR = 2, sensitivity = 0.55, specificity = 0.99, survivals = surv,
   N = NULL, power = 0.9, rho = 0.5, alpha = 0.05, pmiss = seq(0.1, 0.8, 0.1),
   design = "MCAR")	  
   
</code></pre>

<hr>
<h2 id='icpower_weibull'>Study design in the presence of error-prone diagnostic tests and 
self-reported outcomes for Weibull model</h2><span id='topic+icpower_weibull'></span>

<h3>Description</h3>

<p>This functions works same way as <code><a href="#topic+icpower">icpower</a></code> function 
except that it assumes the survival function follows Weibull
distribution. The scale parameter is assumed to be same for
both treatment and control groups.
This can be used estimate power and sample size for interval
censored data using Weibull model, which is a cpecial case
when both sensitivity and specificity being 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>icpower_weibull(
  HR,
  sensitivity,
  specificity,
  shape,
  scale,
  times,
  N = NULL,
  power = NULL,
  rho = 0.5,
  alpha = 0.05,
  pmiss = 0,
  pcensor = 0,
  design = "MCAR",
  negpred = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="icpower_weibull_+3A_hr">HR</code></td>
<td>
<p>hazard ratio under the alternative hypothesis.</p>
</td></tr>
<tr><td><code id="icpower_weibull_+3A_sensitivity">sensitivity</code></td>
<td>
<p>the sensitivity of test.</p>
</td></tr>
<tr><td><code id="icpower_weibull_+3A_specificity">specificity</code></td>
<td>
<p>the specificity of test</p>
</td></tr>
<tr><td><code id="icpower_weibull_+3A_shape">shape</code></td>
<td>
<p>shape parameter of the Weibull distribution for reference group</p>
</td></tr>
<tr><td><code id="icpower_weibull_+3A_scale">scale</code></td>
<td>
<p>scale parameter of the Weibull distributions. Same for all groups</p>
</td></tr>
<tr><td><code id="icpower_weibull_+3A_times">times</code></td>
<td>
<p>the visit times</p>
</td></tr>
<tr><td><code id="icpower_weibull_+3A_n">N</code></td>
<td>
<p>a vector of sample sizes to calculate corresponding powers. If one 
needs to calculate sample size, then set to NULL.</p>
</td></tr>
<tr><td><code id="icpower_weibull_+3A_power">power</code></td>
<td>
<p>a vector of powers to calculate corresponding sample sizes. If 
one needs to calculate power, then set to NULL.</p>
</td></tr>
<tr><td><code id="icpower_weibull_+3A_rho">rho</code></td>
<td>
<p>proportion of subjects in baseline(reference) group.</p>
</td></tr>
<tr><td><code id="icpower_weibull_+3A_alpha">alpha</code></td>
<td>
<p>type I error.</p>
</td></tr>
<tr><td><code id="icpower_weibull_+3A_pmiss">pmiss</code></td>
<td>
<p>a value or a vector (must have same length as survivals) of the 
probabilities of each test being randomly missing at each test time. If 
pmiss is a single value, then each test is assumed to have an identical 
probability of missingness.</p>
</td></tr>
<tr><td><code id="icpower_weibull_+3A_pcensor">pcensor</code></td>
<td>
<p>a value or a vector (must have same length as testtimes) of
the probability of censoring at each visit, assuming censoring process
is independent on other missing mechanisms.</p>
</td></tr>
<tr><td><code id="icpower_weibull_+3A_design">design</code></td>
<td>
<p>missing mechanism: &quot;MCAR&quot; or &quot;NTFP&quot;.</p>
</td></tr>
<tr><td><code id="icpower_weibull_+3A_negpred">negpred</code></td>
<td>
<p>baseline negative predictive value, i.e. the probability of 
being truely disease free for those who were tested (reported) as disease 
free at baseline. If baseline screening test is perfect, then negpred = 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To calculate sample sizes for a vector of powers, set N = NULL. To 
calculate powers for a vector of sample sizes, set power = NULL. One and 
only one of power and N should be specified, and the other set to NULL. 
This function uses an enumeration algorithm to calculate the expected 
Fisher information matrix. The expected Fisher information matrix is used 
to obtain the variance of the coefficient corresponding to the treatment 
group indicator.
</p>


<h3>Value</h3>

 <ul>
<li><p> result: a data frame with calculated sample size and 
power </p>
</li>
<li><p> I1 and I2: calculated unit Fisher information matrices for each
group, which can be used to calculate more values of sample size and power 
for the same design without the need to enumerate again </p>
</li></ul>



<h3>Note</h3>

<p>When diagnostic test is perfect, i.e. sensitivity=1 and 
specificity=1, use <code><a href="#topic+icpowerpf">icpowerpf</a></code> instead to obtain significantly 
improved computational efficiency.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+icpowerpf">icpowerpf</a></code> <code><a href="#topic+icpower">icpower</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
icpower_weibull(2, 0.75, 0.98, 1, 0.1, 1:8, power = 0.9)$result

# Interval censoring
icpower_weibull(2, 1, 1, 1, 0.1, 1:8, power = 0.9)$result

</code></pre>

<hr>
<h2 id='icpower.val'>Study design in the presence of error-prone diagnostic tests and 
self-reported outcomes when sensitivity and specificity are unkonwn and a 
validation set is used</h2><span id='topic+icpower.val'></span>

<h3>Description</h3>

<p>This function calculates the power and sample size in the presence of 
error-prone diagnostic tests and self-reported outcomes when both sensitivity
and specificity are unknown. In this case, a subject of the subjects receive 
both gold standard test and error-prone test at each non-missing visit. The 
remaining subjects receive only error-prone test. Here, for the validation 
set, NTFP refers to no test after first positive result from the gold 
standard test. Both sensitivity and specificity are treated as unknown 
parameters in this setting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>icpower.val(
  HR,
  sensitivity,
  specificity,
  survivals,
  N = NULL,
  power = NULL,
  rhoval,
  rho = 0.5,
  alpha = 0.05,
  pmiss = 0,
  design = "MCAR",
  designval = "MCAR",
  negpred = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="icpower.val_+3A_hr">HR</code></td>
<td>
<p>hazard ratio under the alternative hypothesis.</p>
</td></tr>
<tr><td><code id="icpower.val_+3A_sensitivity">sensitivity</code></td>
<td>
<p>the sensitivity of test.</p>
</td></tr>
<tr><td><code id="icpower.val_+3A_specificity">specificity</code></td>
<td>
<p>the specificity of test</p>
</td></tr>
<tr><td><code id="icpower.val_+3A_survivals">survivals</code></td>
<td>
<p>a vector of survival function at each test time for 
baseline(reference) group. Its length determines the number of tests.</p>
</td></tr>
<tr><td><code id="icpower.val_+3A_n">N</code></td>
<td>
<p>a vector of sample sizes to calculate corresponding powers. If one 
needs to calculate sample size, then set to NULL.</p>
</td></tr>
<tr><td><code id="icpower.val_+3A_power">power</code></td>
<td>
<p>a vector of powers to calculate corresponding sample sizes. If 
one needs to calculate power, then set to NULL.</p>
</td></tr>
<tr><td><code id="icpower.val_+3A_rhoval">rhoval</code></td>
<td>
<p>proportion of subjects in validation set.</p>
</td></tr>
<tr><td><code id="icpower.val_+3A_rho">rho</code></td>
<td>
<p>proportion of subjects in baseline(reference) group.</p>
</td></tr>
<tr><td><code id="icpower.val_+3A_alpha">alpha</code></td>
<td>
<p>type I error.</p>
</td></tr>
<tr><td><code id="icpower.val_+3A_pmiss">pmiss</code></td>
<td>
<p>a value or a vector (must have same length as survivals) of the 
probabilities of each test being randomly missing at each test time. If 
pmiss is a single value, then each test is assumed to have an identical 
probability of missingness.</p>
</td></tr>
<tr><td><code id="icpower.val_+3A_design">design</code></td>
<td>
<p>missing mechanism: &quot;MCAR&quot; or &quot;NTFP&quot;.</p>
</td></tr>
<tr><td><code id="icpower.val_+3A_designval">designval</code></td>
<td>
<p>missing mechanism of validation set: &quot;MCAR&quot; or &quot;NTFP&quot;.</p>
</td></tr>
<tr><td><code id="icpower.val_+3A_negpred">negpred</code></td>
<td>
<p>baseline negative predictive value, i.e. the probability of 
being truely disease free for those who were tested (reported) as disease 
free at baseline. If baseline screening test is perfect, then negpred = 1.</p>
</td></tr>
</table>


<h3>Value</h3>

 <ul>
<li><p> result: a data frame with calculated sample size and
power </p>
</li>
<li><p> IR1 and IR2: calculated unit Fisher information matrices for each
group in non-validation set </p>
</li>
<li><p> IV1 and IV2: calculated unit Fisher
information matrices for each group in validation set </p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>surv &lt;- exp(log(0.9)*(1:8)/8)
pow &lt;- icpower.val(HR = 2, sensitivity = 0.55, specificity = 0.99, 
   survivals = surv, power = 0.9, rhoval=0.05, design= "NTFP", designval = "NTFP")
pow$result

</code></pre>

<hr>
<h2 id='icpowerpf'>Study design in the presence of interval censored outcomes (assuming perfect
diagnostic tests)</h2><span id='topic+icpowerpf'></span>

<h3>Description</h3>

<p>This function implements power and sample size calculations for interval
censored time-to-event outcomes, when the diagnostic tests are assumed to be
perfect (i.e. sensitivity=1 and specificity=1). This is a special case of the
more general study design function <code><a href="#topic+icpower">icpower</a></code>. However, for the
special case of perfect diagnostic tests, this function can be used with
significantly improved computational efficiency.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>icpowerpf(
  HR,
  survivals,
  N = NULL,
  power = NULL,
  rho = 0.5,
  alpha = 0.05,
  pmiss = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="icpowerpf_+3A_hr">HR</code></td>
<td>
<p>hazard ratio under the alternative hypothesis.</p>
</td></tr>
<tr><td><code id="icpowerpf_+3A_survivals">survivals</code></td>
<td>
<p>a vector of survival function at each test time for 
baseline(reference) group. Its length determines the number of tests.</p>
</td></tr>
<tr><td><code id="icpowerpf_+3A_n">N</code></td>
<td>
<p>a vector of sample sizes to calculate corresponding powers. If one 
needs to calculate sample size, then set to NULL.</p>
</td></tr>
<tr><td><code id="icpowerpf_+3A_power">power</code></td>
<td>
<p>a vector of powers to calculate corresponding sample sizes. If 
one needs to calculate power, then set to NULL.</p>
</td></tr>
<tr><td><code id="icpowerpf_+3A_rho">rho</code></td>
<td>
<p>proportion of subjects in baseline(reference) group.</p>
</td></tr>
<tr><td><code id="icpowerpf_+3A_alpha">alpha</code></td>
<td>
<p>type I error.</p>
</td></tr>
<tr><td><code id="icpowerpf_+3A_pmiss">pmiss</code></td>
<td>
<p>a value or a vector (must have same length as survivals) of the 
probabilities of each test being randomly missing at each test time. If 
pmiss is a single value, then each test is assumed to have an identical 
probability of missingness.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>same form as returned value of <code><a href="#topic+icpower">icpower</a></code>
</p>


<h3>Note</h3>

<p>See <code><a href="#topic+icpower">icpower</a></code> for more details in a general situation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>powpf1 &lt;- icpowerpf(HR =2 , survivals = seq(0.9, 0.1, by=-0.1), N = NULL,
   power = 0.9, pmiss = 0)
   
powpf2 &lt;- icpowerpf(HR =2 , survivals = seq(0.9, 0.1, by=-0.1), N = NULL,
   power = 0.9, pmiss = 0.7)
   
## Different missing probabilities at each test time
powpf3 &lt;- icpowerpf(HR =2 , survivals = seq(0.9, 0.1, -0.1), N = NULL, 
   power = 0.9, pmiss = seq(0.1, .9, 0.1))    
   
</code></pre>

<hr>
<h2 id='plot_surv'>Plot survival function</h2><span id='topic+plot_surv'></span>

<h3>Description</h3>

<p>This function plots survival function with confidence interval 
from model output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_surv(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_surv_+3A_obj">obj</code></td>
<td>
<p>model output object</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
