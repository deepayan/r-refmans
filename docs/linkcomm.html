<!DOCTYPE html><html lang="en"><head><title>Help for package linkcomm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {linkcomm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#linkcomm-package'>
<p>The <code>linkcomm</code> package</p></a></li>
<li><a href='#corLinkcommCentrality'>
<p>Correlation of Community Centrality with Classic Centrality</p></a></li>
<li><a href='#cutDendrogramAt'>
<p>Extract Meta-Communities</p></a></li>
<li><a href='#edge.duplicates'>
<p>Find and Remove Edge Loops and Duplicates</p></a></li>
<li><a href='#get.community.overlaps'>
<p>Find Node Overlaps between Communities</p></a></li>
<li><a href='#get.shared.nodes'>
<p>Get Nodes Shared by Communities</p></a></li>
<li><a href='#getAllNestedComm'>
<p>Find Nested Communities</p></a></li>
<li><a href='#getClusterRelatedness'>
<p>Hierarchichal Clustering of Link Communities</p></a></li>
<li><a href='#getCommunityCentrality'>
<p>Calculate Community Centrality Measures for Nodes</p></a></li>
<li><a href='#getCommunityConnectedness'>
<p>Calculate Community Connectedness or Modularity</p></a></li>
<li><a href='#getCommunityMatrix'>
<p>Construct a Community Membership Matrix</p></a></li>
<li><a href='#getEdgesIn'>
<p>Extract Edge Indices from Communities</p></a></li>
<li><a href='#getLinkCommunities'>
<p>Extract Link Communities from a Network</p></a></li>
<li><a href='#getNestedHierarchies'>
<p>Find Nested Structures in Communities</p></a></li>
<li><a href='#getNodesIn'>
<p>Extract Nodes from Communities</p></a></li>
<li><a href='#getOCG.clusters'>
<p>Generate Overlapping Cluster Generator (OCG) Communities</p></a></li>
<li><a href='#graph.feature'>
<p>Make Node or Edge Graph Features</p></a></li>
<li><a href='#human_pp'><p>Sample Human Protein Interactome</p></a></li>
<li><a href='#integer.edgelist'>
<p>Convert A Network to an Integer Edgelist</p></a></li>
<li><a href='#karate'><p>Social Network in a Karate Club</p></a></li>
<li><a href='#layout.spencer.circle'>
<p>Calculate Node Coordinates for a Spencer Circle</p></a></li>
<li><a href='#lesmiserables'><p>Co-Appearance Network from Les Miserables</p></a></li>
<li><a href='#linkcomm2clustnsee'>
<p>Write a Partition File for Clust&amp;See</p></a></li>
<li><a href='#linkcomm2cytoscape'>
<p>Write an Edge Attribute File for Cytoscape</p></a></li>
<li><a href='#LinkDensities'>
<p>Calculate Link Community Link Densities</p></a></li>
<li><a href='#meta.communities'>
<p>Produce a Set of Meta-Communities</p></a></li>
<li><a href='#newLinkCommsAt'>
<p>User-Defined Link Communities</p></a></li>
<li><a href='#numberEdgesIn'>
<p>Extract Node Community Membership by Edges</p></a></li>
<li><a href='#orderCommunities'>
<p>Order Link Communities According to the Dendrogram</p></a></li>
<li><a href='#plot.linkcomm'>
<p>The <code>linkcomm</code> Plotting Function</p></a></li>
<li><a href='#plot.OCG'>
<p>The <code>OCG</code> Plotting Function</p></a></li>
<li><a href='#plotLinkCommDend'>
<p>Plot a Coloured Dendrogram of Link Communities</p></a></li>
<li><a href='#plotLinkCommGraph'>
<p>Plot a Graph Layout of Link Communities</p></a></li>
<li><a href='#plotLinkCommMembers'>
<p>Plot a Community Membership Matrix for Link Communities</p></a></li>
<li><a href='#plotLinkCommSumm'>
<p>Plot a Summary of the Link Community Algorithm Output</p></a></li>
<li><a href='#plotLinkCommSummComm'>
<p>Plot a Summary of the Link Communities</p></a></li>
<li><a href='#plotOCGraph'>
<p>Plot a Graph Layout of OCG Communities</p></a></li>
<li><a href='#pp_rnapol'><p>Sample Yeast Protein Interactome</p></a></li>
<li><a href='#print.linkcomm'>
<p>Print a Summary of a <code>linkcomm</code> Object</p></a></li>
<li><a href='#print.OCG'>
<p>Print a Summary of an <code>OCG</code> Object</p></a></li>
<li><a href='#read.OCG'>
<p>Read an OCG Partition File into R</p></a></li>
<li><a href='#weighted'><p>Sample Gene Co-Expression Network</p></a></li>
<li><a href='#which.communities'>
<p>Extract Community Membership for Nodes</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools for Generating, Visualizing, and Analysing Link
Communities in Networks</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0-14</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-02-03</td>
</tr>
<tr>
<td>Author:</td>
<td>Alex T. Kalinka &lt;alex.t.kalinka@gmail.com&gt;, with
    contributions from Alain Guenoche</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alex T. Kalinka &lt;alex.t.kalinka@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Link communities reveal the nested and overlapping
    structure in networks, and uncover the key nodes that form connections
    to multiple communities. linkcomm provides a set of tools for
    generating, visualizing, and analysing link communities in networks of
    arbitrary size and type. The linkcomm package also includes tools for
    generating, visualizing, and analysing Overlapping Cluster Generator
    (OCG) communities. Kalinka and Tomancak (2011) &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtr311">doi:10.1093/bioinformatics/btr311</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://alextkalinka.github.io/linkcomm/">https://alextkalinka.github.io/linkcomm/</a>,
<a href="https://github.com/alextkalinka/linkcomm">https://github.com/alextkalinka/linkcomm</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>igraph, RColorBrewer</td>
</tr>
<tr>
<td>Imports:</td>
<td>dynamicTreeCut, grid, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>fastcluster, R.rsp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-02-04 15:54:52 UTC; alexkalinka</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-02-04 16:30:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='linkcomm-package'>
The <code>linkcomm</code> package</h2><span id='topic+linkcomm-package'></span><span id='topic+linkcomm'></span>

<h3>Description</h3>

<p><code>linkcomm</code> provides tools for the generation, visualization, and analysis of link communities in networks of arbitrary size and type.
</p>


<h3>Details</h3>

<p>Link communities reveal the nested and overlapping structure in networks, and uncover the key nodes that form connections to multiple communities. <code>linkcomm</code> provides tools for generating, visualizing, and analysing link communities in networks of arbitrary size and type.
</p>
<p>For a more detailed overview of how to use the package:<br /> <br />
<code>vignette(topic = "linkcomm", package = "linkcomm")</code><br /> <br />
To run an interactive demonstration of <code>linkcomm</code> within <span class="rlang"><b>R</b></span>:<br /> <br />
<code>demo(topic = "linkcomm", package = "linkcomm")</code>
</p>


<h3>Author(s)</h3>

<p>Alex T. Kalinka <a href="mailto:alex.t.kalinka@gmail.com">alex.t.kalinka@gmail.com</a>
</p>


<h3>References</h3>

<p>Ahn, Y.Y., Bagrow, J.P., and Lehmann, S. (2010). Link communities reveal multiscale complexity in networks. <em>Nature</em> <b>466</b>, 761-764.
</p>
<p>Becker, E., Robisson, B., Chapple, C.E., Guenoche, A. and Brun, C. (2012) Multifunctional proteins revealed by overlapping clustering in protein interaction network. <em>Bioinformatics</em> <b>28</b>, 84-90.
</p>
<p>Kalinka, A.T. and Tomancak, P. (2011). linkcomm: an R package for the generation, visualization, and analysis of link communities in networks of arbitrary size and type. <em>Bioinformatics</em> <b>27</b>, 2011-2012.
</p>
<p>Spencer, R. (2010). <a href="http://scaledinnovation.com/analytics/communities/comlinks.html">http://scaledinnovation.com/analytics/communities/comlinks.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getLinkCommunities">getLinkCommunities</a></code>, <code><a href="#topic+getOCG.clusters">getOCG.clusters</a></code>, <code><a href="#topic+plot.linkcomm">plot.linkcomm</a></code>, <code><a href="#topic+pp_rnapol">pp_rnapol</a></code>, <code><a href="#topic+lesmiserables">lesmiserables</a></code>, <code><a href="#topic+karate">karate</a></code>, <code><a href="#topic+weighted">weighted</a></code>, <code>igraph</code>, <code>RColorBrewer</code>, <code><a href="graphics.html#topic+grid">grid</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate graph and extract link communities.
g &lt;- swiss[,3:4]
lc &lt;- getLinkCommunities(g)

## Plot a graph layout of the link communities.
plot(lc, type = "graph")

## Use a Spencer circle layout.
plot(lc, type = "graph", layout = "spencer.circle")

## Calculate a community-based measure of node centrality.
getCommunityCentrality(lc)

## Find nested communities.
getAllNestedComm(lc)

## Uncover the relatedness between communities.
getClusterRelatedness(lc)
</code></pre>

<hr>
<h2 id='corLinkcommCentrality'>
Correlation of Community Centrality with Classic Centrality
</h2><span id='topic+corLinkcommCentrality'></span>

<h3>Description</h3>

<p>This function calculates the correlation between the community centrality and classic centrality measures for a set of nodes in a network, and plots a scatterplot of the relationship together with a fitted straight line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corLinkcommCentrality(x, centrality = "degree", type = "commweight", 
                      method = "spearman", plot = TRUE, pch = 20, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="corLinkcommCentrality_+3A_x">x</code></td>
<td>

<p>An object of class <code>linkcomm</code>.
</p>
</td></tr>
<tr><td><code id="corLinkcommCentrality_+3A_centrality">centrality</code></td>
<td>

<p>A character string naming the classic centrality measure. Can be one of <code>"degree"</code>, <code>"betweenness"</code>, <code>"closeness"</code>, and <code>"constraint"</code>. Defaults to <code>"degree"</code>.
</p>
</td></tr>
<tr><td><code id="corLinkcommCentrality_+3A_type">type</code></td>
<td>

<p>A character string naming the type of community centrality. Can be <code>"commweight"</code> or <code>"commconn"</code>, defaults to <code>"commweight"</code>.
</p>
</td></tr>
<tr><td><code id="corLinkcommCentrality_+3A_method">method</code></td>
<td>

<p>A character string naming the correlation method. Can be one of <code>"spearman"</code>, <code>"pearson"</code>, or <code>"kendall"</code>. Defaults to <code>"spearman"</code>.
</p>
</td></tr>
<tr><td><code id="corLinkcommCentrality_+3A_plot">plot</code></td>
<td>

<p>Logical, whether to plot a scatterplot of the relationship, defaults to TRUE.
</p>
</td></tr>
<tr><td><code id="corLinkcommCentrality_+3A_pch">pch</code></td>
<td>

<p>An integer specifying the plot symbol (see <code><a href="graphics.html#topic+par">par</a></code>). Defaults to 20.
</p>
</td></tr>
<tr><td><code id="corLinkcommCentrality_+3A_...">...</code></td>
<td>

<p>Additional arguments to be passed to <code>plot</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The correlation between community centrality and classic centrality measures, such as degree or betweenness, may reveal discrepancies, thereby indicating that community centrality scores provide a unique reflection of node importance.
</p>


<h3>Value</h3>

<p>A correlation coefficient.
</p>


<h3>Author(s)</h3>

<p>Alex T. Kalinka <a href="mailto:alex.t.kalinka@gmail.com">alex.t.kalinka@gmail.com</a>
</p>


<h3>References</h3>

<p>Kalinka, A.T. and Tomancak, P. (2011). linkcomm: an R package for the generation, visualization, and analysis of link communities in networks of arbitrary size and type. <em>Bioinformatics</em> <b>27</b>, 2011-2012.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getCommunityCentrality">getCommunityCentrality</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate graph and extract link communities.
g &lt;- swiss[,3:4]
lc &lt;- getLinkCommunities(g)

## Correlate community centrality with degree centrality.
corLinkcommCentrality(lc)
</code></pre>

<hr>
<h2 id='cutDendrogramAt'>
Extract Meta-Communities
</h2><span id='topic+cutDendrogramAt'></span>

<h3>Description</h3>

<p>This function extracts meta-communities from a dendrogram of community relatedness based on a user-defined place at which to cut the dendrogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cutDendrogramAt(x, lc = NULL, cutat = NULL, plot = TRUE, col = TRUE, 
                pal = brewer.pal(9, "Set1"), labels = FALSE, plotcut = TRUE, 
                right = TRUE, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cutDendrogramAt_+3A_x">x</code></td>
<td>

<p>An object of class <code>hclust</code>, usually generated by <code>getClusterRelatedness</code>.
</p>
</td></tr>
<tr><td><code id="cutDendrogramAt_+3A_lc">lc</code></td>
<td>

<p>An object of class <code>linkcomm</code>. If included, the resulting plot will display additional information about the clusters. Defaults to NULL.
</p>
</td></tr>
<tr><td><code id="cutDendrogramAt_+3A_cutat">cutat</code></td>
<td>

<p>A numerical value at which to cut the dendrogram.
</p>
</td></tr>
<tr><td><code id="cutDendrogramAt_+3A_plot">plot</code></td>
<td>

<p>Logical, whether to plot the dendrogram and the meta-communities, defaults to TRUE.
</p>
</td></tr>
<tr><td><code id="cutDendrogramAt_+3A_col">col</code></td>
<td>

<p>Logical, whether to colour the meta-communites.
</p>
</td></tr>
<tr><td><code id="cutDendrogramAt_+3A_pal">pal</code></td>
<td>

<p>A character vector describing a colour palette to be used for colouring the meta-communites in the dendrogram plot. Defaults to <code>brewer.pal(9, "Set1")</code>.
</p>
</td></tr>
<tr><td><code id="cutDendrogramAt_+3A_labels">labels</code></td>
<td>

<p>Logical, whether to put labels on the dendrogram. Defaults to FALSE.
</p>
</td></tr>
<tr><td><code id="cutDendrogramAt_+3A_plotcut">plotcut</code></td>
<td>

<p>Logical, whether to display a horizontal line where the dendrogram is cut. Defaults to TRUE.
</p>
</td></tr>
<tr><td><code id="cutDendrogramAt_+3A_right">right</code></td>
<td>

<p>Logical, whether to orient the dendrogram to the right. Defaults to TRUE.
</p>
</td></tr>
<tr><td><code id="cutDendrogramAt_+3A_verbose">verbose</code></td>
<td>

<p>Logical, whether to display the progress of colouring the dendrogram. Defaults to TRUE.
</p>
</td></tr>
<tr><td><code id="cutDendrogramAt_+3A_...">...</code></td>
<td>

<p>Additional arguments to be passed to <code>plot</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Extracting meta-communities allows the user to explore community relatedness and structure at higher levels.
</p>


<h3>Value</h3>

<p>A list of integer vectors, referring to meta-communities of link communities.
</p>


<h3>Author(s)</h3>

<p>Alex T. Kalinka <a href="mailto:alex.t.kalinka@gmail.com">alex.t.kalinka@gmail.com</a>
</p>


<h3>References</h3>

<p>Kalinka, A.T. and Tomancak, P. (2011). linkcomm: an R package for the generation, visualization, and analysis of link communities in networks of arbitrary size and type. <em>Bioinformatics</em> <b>27</b>, 2011-2012.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getClusterRelatedness">getClusterRelatedness</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate graph, extract link communities, and cluster communities.
g &lt;- swiss[,3:4]
lc &lt;- getLinkCommunities(g)
hc &lt;- getClusterRelatedness(lc)

## Cut dendrogram at 1 and extract meta-communities.
cutDendrogramAt(hc, cutat = 1)
</code></pre>

<hr>
<h2 id='edge.duplicates'>
Find and Remove Edge Loops and Duplicates
</h2><span id='topic+edge.duplicates'></span>

<h3>Description</h3>

<p>This function finds and removes loops, edge duplicates, and bi-directional edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edge.duplicates(network, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="edge.duplicates_+3A_network">network</code></td>
<td>

<p>An edge list, which is either a data frame or a character or integer matrix with two columns.
</p>
</td></tr>
<tr><td><code id="edge.duplicates_+3A_verbose">verbose</code></td>
<td>

<p>Logical, whether to display the progress of the function on the screen. Defaults to TRUE.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function removes loops, duplicate and bi-directional edges; the edges that occur closer to the end of the edge list will be removed.
</p>


<h3>Value</h3>

<p>A list with the following elements: <code>edges</code> - a character matrix of the edges in the network with any loops or duplicate edges removed; <code>inds</code> - an integer vector of the edge indices of any loop or duplicate edges in the original network.
</p>


<h3>Author(s)</h3>

<p>Alex T. Kalinka <a href="mailto:alex.t.kalinka@gmail.com">alex.t.kalinka@gmail.com</a>
</p>


<h3>References</h3>

<p>Kalinka, A.T. and Tomancak, P. (2011). linkcomm: an R package for the generation, visualization, and analysis of link communities in networks of arbitrary size and type. <em>Bioinformatics</em> <b>27</b>, 2011-2012.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate graph and remove loops and duplicate edges.
g &lt;- swiss[,3:4]
g.dup &lt;- edge.duplicates(g)

</code></pre>

<hr>
<h2 id='get.community.overlaps'>
Find Node Overlaps between Communities
</h2><span id='topic+get.community.overlaps'></span>

<h3>Description</h3>

<p>This function returns lists of communities that share at least one node with each other.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.community.overlaps(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.community.overlaps_+3A_x">x</code></td>
<td>

<p>An object of class <code>linkcomm</code> or <code>OCG</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of length equal to the number of communities. Each element contains an integer vector giving the community IDs for communities sharing at least one node with each community. NAs indicate that a community shares no nodes with any other communities.
</p>


<h3>Author(s)</h3>

<p>Alex T. Kalinka <a href="mailto:alex.t.kalinka@gmail.com">alex.t.kalinka@gmail.com</a>
</p>


<h3>References</h3>

<p>Kalinka, A.T. and Tomancak, P. (2011). linkcomm: an R package for the generation, visualization, and analysis of link communities in networks of arbitrary size and type. <em>Bioinformatics</em> <b>27</b>, 2011-2012.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate graph and extract link communities.
g &lt;- swiss[,3:4]
lc &lt;- getLinkCommunities(g)

## Get list of overlapping communities.
ov &lt;- get.community.overlaps(lc)
</code></pre>

<hr>
<h2 id='get.shared.nodes'>
Get Nodes Shared by Communities
</h2><span id='topic+get.shared.nodes'></span>

<h3>Description</h3>

<p>This function returns the nodes that are shared by specific sets of communities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.shared.nodes(x, comms)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.shared.nodes_+3A_x">x</code></td>
<td>

<p>An object of class <code>linkcomm</code> or <code>OCG</code>.
</p>
</td></tr>
<tr><td><code id="get.shared.nodes_+3A_comms">comms</code></td>
<td>

<p>An integer vector giving the community IDs for which an intersecting set of shared nodes should be returned.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector giving the shared node names.
</p>


<h3>Author(s)</h3>

<p>Alex T. Kalinka <a href="mailto:alex.t.kalinka@gmail.com">alex.t.kalinka@gmail.com</a>
</p>


<h3>References</h3>

<p>Kalinka, A.T. and Tomancak, P. (2011). linkcomm: an R package for the generation, visualization, and analysis of link communities in networks of arbitrary size and type. <em>Bioinformatics</em> <b>27</b>, 2011-2012.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate graph and extract link communities.
g &lt;- swiss[,3:4]
lc &lt;- getLinkCommunities(g)

## Get shared nodes for communities 1 and 7.
get.shared.nodes(lc, comms = c(1,7))
</code></pre>

<hr>
<h2 id='getAllNestedComm'>
Find Nested Communities
</h2><span id='topic+getAllNestedComm'></span>

<h3>Description</h3>

<p>This function returns communities of nodes that are entirely nested within other larger communities of nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAllNestedComm(x, verbose = FALSE, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getAllNestedComm_+3A_x">x</code></td>
<td>

<p>An object of class <code>linkcomm</code>.
</p>
</td></tr>
<tr><td><code id="getAllNestedComm_+3A_verbose">verbose</code></td>
<td>

<p>Logical, whether to print to the screen a warning that individual community IDs are not clustered in any other communities. Defaults to FALSE.
</p>
</td></tr>
<tr><td><code id="getAllNestedComm_+3A_plot">plot</code></td>
<td>

<p>Logical, whether to plot graphs of the nested communities. Defaults to FALSE.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Nested community structures may reveal interesting relationships among sets of nodes.
</p>


<h3>Value</h3>

<p>A named list of integer vectors; names are integers referring to nested communities, and the integer vectors are the communities that the named community is nested in.
</p>


<h3>Author(s)</h3>

<p>Alex T. Kalinka <a href="mailto:alex.t.kalinka@gmail.com">alex.t.kalinka@gmail.com</a>
</p>


<h3>References</h3>

<p>Kalinka, A.T. and Tomancak, P. (2011). linkcomm: an R package for the generation, visualization, and analysis of link communities in networks of arbitrary size and type. <em>Bioinformatics</em> <b>27</b>, 2011-2012.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getNestedHierarchies">getNestedHierarchies</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate graph and extract link communities.
g &lt;- swiss[,3:4]
lc &lt;- getLinkCommunities(g)

## Find nested communities.
getAllNestedComm(lc)
</code></pre>

<hr>
<h2 id='getClusterRelatedness'>
Hierarchichal Clustering of Link Communities
</h2><span id='topic+getClusterRelatedness'></span>

<h3>Description</h3>

<p>This function hierarchically clusters the link communities themselves and returns an object of class <code>hclust</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getClusterRelatedness(x, clusterids = 1:x$numbers[3], hcmethod = "ward.D", 
        cluster = TRUE, plot = TRUE, cutat = NULL, col = TRUE, 
        pal = brewer.pal(11, "Spectral"), labels = FALSE, plotcut = TRUE, 
        right = TRUE, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getClusterRelatedness_+3A_x">x</code></td>
<td>

<p>An object of class <code>linkcomm</code>.
</p>
</td></tr>
<tr><td><code id="getClusterRelatedness_+3A_clusterids">clusterids</code></td>
<td>

<p>An integer vector of community IDs. Defaults to all communities.
</p>
</td></tr>
<tr><td><code id="getClusterRelatedness_+3A_hcmethod">hcmethod</code></td>
<td>

<p>A character string naming the hierarchical clustering method to use. Can be one of <code>"ward.D"</code>, <code>"ward.D2"</code>, <code>"single"</code>, <code>"complete"</code>, <code>"average"</code>, <code>"mcquitty"</code>, <code>"median"</code>, or <code>"centroid"</code>. Defaults to <code>"ward.D"</code>.
</p>
</td></tr>
<tr><td><code id="getClusterRelatedness_+3A_cluster">cluster</code></td>
<td>

<p>Logical, whether to cluster the communities. If FALSE, the function returns the upper triangular dissimilarity matrix as a vector. Defaults to TRUE.
</p>
</td></tr>
<tr><td><code id="getClusterRelatedness_+3A_plot">plot</code></td>
<td>

<p>Logical, whether to plot the cluster dendrogram.
</p>
</td></tr>
<tr><td><code id="getClusterRelatedness_+3A_cutat">cutat</code></td>
<td>

<p>A numerical value at which to cut the dendrogram. If NULL, the dendrogram is not cut and meta-communities are not returned. Defaults to NULL.
</p>
</td></tr>
<tr><td><code id="getClusterRelatedness_+3A_col">col</code></td>
<td>

<p>Logical, whether to colour the dendrogram. Defaults to TRUE.
</p>
</td></tr>
<tr><td><code id="getClusterRelatedness_+3A_pal">pal</code></td>
<td>

<p>A character vector describing a colour palette to be used for colouring the meta-communites in the dendrogram plot. Defaults to <code>brewer.pal(11, "Spectral")</code>.
</p>
</td></tr>
<tr><td><code id="getClusterRelatedness_+3A_labels">labels</code></td>
<td>

<p>Logical, whether to add labels to the dendrogram plot.
</p>
</td></tr>
<tr><td><code id="getClusterRelatedness_+3A_plotcut">plotcut</code></td>
<td>

<p>Logical, whether to display a horizontal line where the dendrogram is cut. Defaults to TRUE.
</p>
</td></tr>
<tr><td><code id="getClusterRelatedness_+3A_right">right</code></td>
<td>

<p>Logical, whether to orient the dendrogram to the right. Defaults to TRUE.
</p>
</td></tr>
<tr><td><code id="getClusterRelatedness_+3A_verbose">verbose</code></td>
<td>

<p>Logical, whether to display the progress of the calculation on the screen. Defaults to TRUE.
</p>
</td></tr>
<tr><td><code id="getClusterRelatedness_+3A_...">...</code></td>
<td>

<p>Additional arguments to be passed to <code>plot</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Extracting meta-communities allows the user to explore community relatedness and structure at higher levels. Community relatedness is calculated using the Jaccard coefficient and the number of nodes that community i and j share:
</p>
<p style="text-align: center;"><code class="reqn">S(i,j)=\frac{|n_{i}\cap n_{j}|}{|n_{i}\cup n_{j}|}</code>
</p>



<h3>Value</h3>

<p>Either a numerical vector (the upper triangular dissimilarity matrix - if <code>cluster = FALSE</code>), a list of integer vectors (the meta-communities - if <code>cutat</code> is not NULL), or an object of class <code>hclust</code> (if <code>cluster</code> is TRUE and <code>cutat</code> is NULL).
</p>


<h3>Author(s)</h3>

<p>Alex T. Kalinka <a href="mailto:alex.t.kalinka@gmail.com">alex.t.kalinka@gmail.com</a>
</p>


<h3>References</h3>

<p>Kalinka, A.T. and Tomancak, P. (2011). linkcomm: an R package for the generation, visualization, and analysis of link communities in networks of arbitrary size and type. <em>Bioinformatics</em> <b>27</b>, 2011-2012.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+meta.communities">meta.communities</a></code>, <code><a href="#topic+cutDendrogramAt">cutDendrogramAt</a></code>, <code><a href="stats.html#topic+hclust">hclust</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate graph and extract link communities.
g &lt;- swiss[,3:4]
lc &lt;- getLinkCommunities(g)

## Cluster the link communities.
getClusterRelatedness(lc)

## Cluster the link communities, cut the dendrogram, and return the meta-communities.
getClusterRelatedness(lc, cutat = 1)
</code></pre>

<hr>
<h2 id='getCommunityCentrality'>
Calculate Community Centrality Measures for Nodes
</h2><span id='topic+getCommunityCentrality'></span>

<h3>Description</h3>

<p>This function returns community-based node centrality measures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCommunityCentrality(x, nodes = names(x$numclusters), type = "commweight", 
                       normalise = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getCommunityCentrality_+3A_x">x</code></td>
<td>

<p>An object of class <code>linkcomm</code>.
</p>
</td></tr>
<tr><td><code id="getCommunityCentrality_+3A_nodes">nodes</code></td>
<td>

<p>A character vector giving the names of nodes for calculating community centrality scores. Defaults to all nodes.
</p>
</td></tr>
<tr><td><code id="getCommunityCentrality_+3A_type">type</code></td>
<td>

<p>A character string naming the community centrality measure. Can be one of <code>"commweight"</code> or <code>"commconn"</code> (see Details below). Defaults to <code>"commweight"</code>.
</p>
</td></tr>
<tr><td><code id="getCommunityCentrality_+3A_normalise">normalise</code></td>
<td>

<p>Logical, whether to normalise community connectedness for <code>"commconn"</code>. Defaults to TRUE. Will be ignored for <code>"commweight"</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Community-based measures of node centrality provide an alternative to classic measures of node centrality. <code>"commweight"</code> weights each community that a node belongs to by how similar that community is to each of the other communities to which the node also belongs. For node i the community centrality is
</p>
<p style="text-align: center;"><code class="reqn">C_{C}(i)=\sum_{i\in j}^{N}\left(1-\frac{1}{m}\sum_{i\in j\cap k}^{m}S(j,k)\right)</code>
</p>

<p>where the main sum is over the <code class="reqn">N</code> communities to which node <code class="reqn">i</code> belongs, and <code class="reqn">S(j,k)</code> refers to the similarity between community <code class="reqn">j</code> and <code class="reqn">k</code>, calculated as the Jaccard coefficient for the number of shared nodes between each community pair, and this is averaged over the <code class="reqn">m</code> communities paired with community <code class="reqn">j</code> and in which node <code class="reqn">i</code> jointly belongs.
<code>"commconn"</code> weights each community that a node belongs to by how many connections the community forms outside of itself relative to how many connections the community has within itself (the inverse of modularity), so that nodes that belong to more highly connecting communitites will receive a higher community centrality score. For node i the community centrality is
</p>
<p style="text-align: center;"><code class="reqn">C_{C}(i)=\sum_{i\in j}^{N}e_{ij}\frac{\check{e}_{B(j)}}{\check{e}_{W(j)}}</code>
</p>

<p>where <code class="reqn">e_{ij}</code> is the number of edges node i has in community j, <code class="reqn">\check{e}_{B(j)}=\frac{e_{B(j)}}{n_{j}\bar{d}}</code> is the number of edges community j makes outside of itself normalised by the number of nodes in community j multiplied by the average degree in the network, and <code class="reqn">\check{e}_{W(j)}=\frac{e_{W(j)}}{n(n-1)/2}</code> is the number of edges within community j normalised by the total number possible.
</p>


<h3>Value</h3>

<p>A named numerical vector where the names are node names and the numbers are community centrality measures.
</p>


<h3>Author(s)</h3>

<p>Alex T. Kalinka <a href="mailto:alex.t.kalinka@gmail.com">alex.t.kalinka@gmail.com</a>
</p>


<h3>References</h3>

<p>Kalinka, A.T. and Tomancak, P. (2011). linkcomm: an R package for the generation, visualization, and analysis of link communities in networks of arbitrary size and type. <em>Bioinformatics</em> <b>27</b>, 2011-2012.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getCommunityConnectedness">getCommunityConnectedness</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate graph and extract link communities.
g &lt;- swiss[,3:4]
lc &lt;- getLinkCommunities(g)

## Calculate community centrality.
cc &lt;- getCommunityCentrality(lc)
</code></pre>

<hr>
<h2 id='getCommunityConnectedness'>
Calculate Community Connectedness or Modularity
</h2><span id='topic+getCommunityConnectedness'></span>

<h3>Description</h3>

<p>This function returns a measure of how relatively outwardly or inwardly connected a community is.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCommunityConnectedness(x, clusterids = 1:x$numbers[3], conn = "conn", 
                          normalise = TRUE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getCommunityConnectedness_+3A_x">x</code></td>
<td>

<p>An object of class <code>linkcomm</code>.
</p>
</td></tr>
<tr><td><code id="getCommunityConnectedness_+3A_clusterids">clusterids</code></td>
<td>

<p>An integer vector of community IDs. Defaults to all communities.
</p>
</td></tr>
<tr><td><code id="getCommunityConnectedness_+3A_conn">conn</code></td>
<td>

<p>A character string naming the connectedness measure to use. Can be one of <code>"conn"</code> or <code>"mod"</code> (see Details below). Defaults to <code>"conn"</code>.
</p>
</td></tr>
<tr><td><code id="getCommunityConnectedness_+3A_normalise">normalise</code></td>
<td>

<p>Logical, whether to normalise community connectedness measures by the number of nodes in individual communities. Defaults to TRUE.
</p>
</td></tr>
<tr><td><code id="getCommunityConnectedness_+3A_verbose">verbose</code></td>
<td>

<p>Logical, whether to display the progress of the calculation on the screen. Defaults to FALSE.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The connectedness and modularity of different communities indicates whether a particular community is bridging several other communities, or existing as a relatively isolated module. The modularity of community i is
</p>
<p style="text-align: center;"><code class="reqn">M_{i}=\left(\frac{e_{w}(i)}{n_{i}(n_{i}-1)/2}\right).\left(\frac{e_{b}(i)}{n_{i}\hat{d}}\right)^{-1}</code>
</p>

<p>where <code class="reqn">e_{w}(i)</code> is the number of edges within community i, <code class="reqn">e_{b}(i)</code> is the number of edges community i makes to other communities, <code class="reqn">n_{i}</code> is the number of nodes in community i, and <code class="reqn">\hat{d}</code> is the average degree in the network. Community connectedness is the inverse of this value.
</p>


<h3>Value</h3>

<p>A named numerical vector, where the names are community IDs and the numbers are community connectedness or modularity scores.
</p>


<h3>Author(s)</h3>

<p>Alex T. Kalinka <a href="mailto:alex.t.kalinka@gmail.com">alex.t.kalinka@gmail.com</a>
</p>


<h3>References</h3>

<p>Kalinka, A.T. and Tomancak, P. (2011). linkcomm: an R package for the generation, visualization, and analysis of link communities in networks of arbitrary size and type. <em>Bioinformatics</em> <b>27</b>, 2011-2012.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getCommunityCentrality">getCommunityCentrality</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate graph and extract link communities.
g &lt;- swiss[,3:4]
lc &lt;- getLinkCommunities(g)

## Get community connectedness.
cc &lt;- getCommunityConnectedness(lc, normalise = FALSE)
</code></pre>

<hr>
<h2 id='getCommunityMatrix'>
Construct a Community Membership Matrix
</h2><span id='topic+getCommunityMatrix'></span>

<h3>Description</h3>

<p>This function returns a binary matrix with nodes as rows, communities as columns, and unit entries indicating membership in a community.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCommunityMatrix(x, nodes = head(names(x$numclusters), 20))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getCommunityMatrix_+3A_x">x</code></td>
<td>

<p>An object of class <code>linkcomm</code>.
</p>
</td></tr>
<tr><td><code id="getCommunityMatrix_+3A_nodes">nodes</code></td>
<td>

<p>A character vector containing the nodes for the community membership matrix. Defaults to the 20 (or less) nodes that belong to the most communities.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A binary matrix with nodes as rows and communities as columns.
</p>


<h3>Author(s)</h3>

<p>Alex T. Kalinka <a href="mailto:alex.t.kalinka@gmail.com">alex.t.kalinka@gmail.com</a>
</p>


<h3>References</h3>

<p>Kalinka, A.T. and Tomancak, P. (2011). linkcomm: an R package for the generation, visualization, and analysis of link communities in networks of arbitrary size and type. <em>Bioinformatics</em> <b>27</b>, 2011-2012.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.linkcomm">plot.linkcomm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate graph and extract link communities.
g &lt;- swiss[,3:4]
lc &lt;- getLinkCommunities(g)

## Get community membership matrix.
getCommunityMatrix(lc)
</code></pre>

<hr>
<h2 id='getEdgesIn'>
Extract Edge Indices from Communities
</h2><span id='topic+getEdgesIn'></span>

<h3>Description</h3>

<p>This function returns edge indices that belong to certain communities or that are incident upon certain nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getEdgesIn(x, clusterids = 1, nodes = NULL, all = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getEdgesIn_+3A_x">x</code></td>
<td>

<p>An object of class <code>linkcomm</code> or <code>OCG</code>.
</p>
</td></tr>
<tr><td><code id="getEdgesIn_+3A_clusterids">clusterids</code></td>
<td>

<p>An integer vector of community IDs. Defaults to community 1.
</p>
</td></tr>
<tr><td><code id="getEdgesIn_+3A_nodes">nodes</code></td>
<td>

<p>A character vector specifying node(s) for which edge indices should be returned. Overrides <code>clusterids</code>. Defaults to NULL.
</p>
</td></tr>
<tr><td><code id="getEdgesIn_+3A_all">all</code></td>
<td>

<p>Logical, whether the edges for all communities to which the named nodes belong should be returned. Will have an effect only if <code>nodes</code> is not NULL. If FALSE, edges that are directly incident upon the named nodes will be returned. Defaults to FALSE.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector of edge indices.
</p>


<h3>Author(s)</h3>

<p>Alex T. Kalinka <a href="mailto:alex.t.kalinka@gmail.com">alex.t.kalinka@gmail.com</a>
</p>


<h3>References</h3>

<p>Kalinka, A.T. and Tomancak, P. (2011). linkcomm: an R package for the generation, visualization, and analysis of link communities in networks of arbitrary size and type. <em>Bioinformatics</em> <b>27</b>, 2011-2012.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate graph and extract link communities.
g &lt;- swiss[,3:4]
lc &lt;- getLinkCommunities(g)

## Get edges from community 1.
getEdgesIn(lc)
</code></pre>

<hr>
<h2 id='getLinkCommunities'>
Extract Link Communities from a Network
</h2><span id='topic+getLinkCommunities'></span>

<h3>Description</h3>

<p>This function extracts link communities from networks of arbitrary size and type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLinkCommunities(network, hcmethod = "average", use.all.edges = FALSE,
                   edglim = 10^4, directed = FALSE, dirweight = 0.5,
                   bipartite = FALSE, dist = NULL, plot = TRUE, 
                   check.duplicates = TRUE, removetrivial = TRUE, 
                   verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getLinkCommunities_+3A_network">network</code></td>
<td>

<p>An edge list, which is a matrix or data frame with 2 or 3 columns. The first 2 columns contain the nodes that interact with each other, which can be character strings or integer values. The optional third column is a numerical vector of weights for each edge. Can also be a character string naming a file containing an edge list.
</p>
</td></tr>
<tr><td><code id="getLinkCommunities_+3A_hcmethod">hcmethod</code></td>
<td>

<p>A character string naming the hierarchical clustering method to use. Can be one of <code>"ward"</code>, <code>"single"</code>, <code>"complete"</code>, <code>"average"</code>, <code>"mcquitty"</code>, <code>"median"</code>, or <code>"centroid"</code>. Defaults to <code>"average"</code> (if the number of edges is greater than <code>edglim</code> then <code>"single"</code> is used).
</p>
</td></tr>
<tr><td><code id="getLinkCommunities_+3A_use.all.edges">use.all.edges</code></td>
<td>

<p>Logical, indicating whether edge similarities should be calculated for all pairs of edges (TRUE), or only for edge pairs that share a node (FALSE) as in the original Ahn et al. (2010) algorithm. Defaults to FALSE. If TRUE, networks are treated as undirected.
</p>
</td></tr>
<tr><td><code id="getLinkCommunities_+3A_edglim">edglim</code></td>
<td>

<p>An integer value indicating the largest number of edges permissible for the hierarchical clustering to be handled in memory. Above this value the upper triangular dissimilarity matrix will be written to disk and read and written as clustering proceeds until the file size is 0 bytes (see Details below). Defaults to <code class="reqn">10^{4}</code>.
</p>
</td></tr>
<tr><td><code id="getLinkCommunities_+3A_directed">directed</code></td>
<td>

<p>Logical, whether the network is directed. Defaults to FALSE.
</p>
</td></tr>
<tr><td><code id="getLinkCommunities_+3A_dirweight">dirweight</code></td>
<td>

<p>A numerical value between 1 and 0 inclusive indicating the weight that will be attached to edges that share a node but are in the opposite orientation. Defaults to 0.5. Will be ignored if <code>directed</code> = FALSE.
</p>
</td></tr>
<tr><td><code id="getLinkCommunities_+3A_bipartite">bipartite</code></td>
<td>

<p>Logical, whether the input network is bi-partite. See Details for an explanation of how bi-partite networks are handled. Defaults to FALSE.
</p>
</td></tr>
<tr><td><code id="getLinkCommunities_+3A_dist">dist</code></td>
<td>

<p>An object of class <code>"dist"</code> representing a user-defined distance matrix for the network. Note, this must be the lower triangular matrix of an n*n distance matrix, where n is the number of edges in the network (make sure duplicated edges are removed). If NULL, then the distance matrix is calculated by the algorithm. Defaults to NULL.
</p>
</td></tr>
<tr><td><code id="getLinkCommunities_+3A_plot">plot</code></td>
<td>

<p>Logical, whether to plot summary output from the algorithm (dendrogram and partition density plot). Defaults to TRUE. Note, if there are more than 1500 but less than edglim edges then the dendrogram will be plotted without colour and in a separate panel from the partition density to avoid lengthy rendering times; when there are more than edglim edges then only the partition density will be plotted.
</p>
</td></tr>
<tr><td><code id="getLinkCommunities_+3A_check.duplicates">check.duplicates</code></td>
<td>

<p>Logical, whether to check for and remove loops, duplicate edges, and bi-directional edges. Defaults to TRUE. Note, if you wish to avoid this step by setting this parameter to FALSE then you must be certain that there are no duplicate edges in the network.
</p>
</td></tr>
<tr><td><code id="getLinkCommunities_+3A_removetrivial">removetrivial</code></td>
<td>

<p>Logical, whether to remove trivial community clusters that contain 2 edges. Defaults to TRUE.
</p>
</td></tr>
<tr><td><code id="getLinkCommunities_+3A_verbose">verbose</code></td>
<td>

<p>Logical, whether to display the progress of the algorithm on the screen. Defaults to TRUE.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the main algorithm used for extracting link communities from networks of arbitrary size and type. Input networks may be directed, weighted, both directed and weighted, or neither. The algorithm used is the one outlined by Ahn et al. (2010). The similarity between links, <code class="reqn">e_{ik}</code> and <code class="reqn">e_{jk}</code>, that share a node, <code class="reqn">k</code>, is calculated using the Jaccard coefficient
</p>
<p style="text-align: center;"><code class="reqn">S(e_{ik},e_{jk})=\frac{|n_{+}(i)\cap n_{+}(j)|}{|n_{+}(i)\cup n_{+}(j)|}</code>
</p>

<p>where <code class="reqn">n_{+}(i)</code> refers to the first-order node neighbourhood of node <code class="reqn">i</code>, which includes node <code class="reqn">i</code> itself (inclusive neighbour set). After assigning pairwise similarities to all of the links in the network, the links are hierarchically clustered using single-linkage clustering, and the resulting dendrogram is cut at a point that maximises the density of links within the clusters normalising against the maximum and minimum numbers of links possible in each cluster, known as the partition density.
For directed and weighted networks, the Tanimoto coefficient is used for assigning similarity between links
</p>
<p style="text-align: center;"><code class="reqn">S(e_{ik},e_{jk})=\frac{\mathbf{a}_{i}.\mathbf{a}_{j}}{|\mathbf{a}_{i}|^{2}+|\mathbf{a}_{j}|^{2}-\mathbf{a}_{i}.\mathbf{a}_{j}}</code>
</p>

<p>where <code class="reqn">\mathbf{a}_{i}</code> refers to a vector describing the weights of links between node <code class="reqn">i</code> and the nodes in the first-order neighbourhoods of both nodes <code class="reqn">i</code> and <code class="reqn">j</code> (equal to 0 in the event of an absent link). For directed networks, links to nodes shared by both node <code class="reqn">i</code> and <code class="reqn">j</code> are given a user-defined weight below 1 if they are in the opposite orientation.<br /><br /><br />
For bi-partite networks, the set of neighbours (instead of the inclusive neighbour set) is used to count nodes for the edge similarity metric because node <code class="reqn">i</code> and node <code class="reqn">j</code> cannot share an edge in a bi-partite network. The partition density for bi-partite networks is calculated as:
</p>
<p style="text-align: center;"><code class="reqn">D_{c} = \frac{2}{M}\sum_{c}m_{c}\frac{m_{c}+1-n_{c}}{2n_{c0}n_{c1}-2(n_{c}-1)}</code>
</p>

<p>where <code class="reqn">M</code> is the total number of edges, <code class="reqn">m_c</code> is the number of edges in subset <code class="reqn">c</code>, <code class="reqn">n_c</code> is the number of nodes in subset <code class="reqn">c</code>, <code class="reqn">n_{c0}</code> is the number of nodes in partition 0, and <code class="reqn">n_{c1}</code> is the number of nodes in partition 1.
</p>


<h3>Value</h3>

<p>An object of class <code>linkcomm</code>, which is a list containing the following components:
</p>
<table role = "presentation">
<tr><td><code>numbers</code></td>
<td>
<p>An integer vector with the number of edges, nodes, and communities.</p>
</td></tr>
<tr><td><code>hclust</code></td>
<td>
<p>An object of class <code><a href="stats.html#topic+hclust">hclust</a></code>, which contains information about the hierarchical clustering of links.</p>
</td></tr>
<tr><td><code>pdmax</code></td>
<td>
<p>A numerical value indicating the height of the dendrogram at which the partition density is maximised.</p>
</td></tr>
<tr><td><code>pdens</code></td>
<td>
<p>A numerical matrix with 2 columns; the first is the heights at which clusters appear and the second is the partition density.</p>
</td></tr>
<tr><td><code>nodeclusters</code></td>
<td>
<p>A data frame consisting of 2 columns; the first contains node names, and the second contains single community IDs for each node. All communities and their nodes are represented, but not necessarily all nodes.</p>
</td></tr>
<tr><td><code>clusters</code></td>
<td>
<p>A list of integer vectors containing the link IDs that belong to each community. Community IDs are the numerical position of the communities in the list.</p>
</td></tr>
<tr><td><code>edges</code></td>
<td>
<p>A data frame with 3 columns; the first two contain nodes that interact with each other, and the third is an integer vector of community IDs indicating community membership for each link.</p>
</td></tr>
<tr><td><code>numclusters</code></td>
<td>
<p>A named integer vector. Names are node names and integer values are the number of communities to which each node belongs.</p>
</td></tr>
<tr><td><code>clustsizes</code></td>
<td>
<p>A named integer vector. Names are community IDs and integer values indicate the number of nodes that belong in each community.</p>
</td></tr>
<tr><td><code>igraph</code></td>
<td>
<p>An object of class <code>igraph</code>. The network is represented here as an <code>igraph</code> object.</p>
</td></tr>
<tr><td><code>edgelist</code></td>
<td>
<p>A character matrix with 2 columns containing the nodes that interact with each other.</p>
</td></tr>
<tr><td><code>directed</code></td>
<td>
<p>Logical indicating whether the network is directed.</p>
</td></tr>
<tr><td><code>bipartite</code></td>
<td>
<p>Logical indicating whether the network is bi-partite.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>When the number of links is less than <code>edglim</code> the hierarchical clustering will be handled in memory. Above this value the upper triangular dissimilarity matrix will be compressed and written to disk and read and written as clustering proceeds until the file size is 0 bytes using a compiled C++ function. In this case the hierarchical clustering method will always be <code>"single"</code> to enhance performance for large networks. The size of <code>edglim</code> can be modified to suit the computer resources available to the user. As a guide, a network with <code class="reqn">10^{4}</code> links will require <code class="reqn">((10^{4})^{2})*8 = 800</code> MB to be handled in an uncompressed format in the memory.<br /><br /><br />
For directed networks, a pair of bidirectional interactions between two nodes cannot be assigned similarities and the edge that appears lower in the edge list for the network will be discarded.<br /><br /><br />
When <code>use.all.edges</code> is TRUE, the algorithm may be slow as all pairs of edges will be compared (<code class="reqn">n^2</code> comparisons, where <code class="reqn">n</code> is the number of edges).
</p>


<h3>Author(s)</h3>

<p>Alex T. Kalinka <a href="mailto:alex.t.kalinka@gmail.com">alex.t.kalinka@gmail.com</a>
</p>


<h3>References</h3>

<p>Ahn, Y.Y., Bagrow, J.P., and Lehmann, S. (2010). Link communities reveal multiscale complexity in networks. <em>Nature</em> <b>466</b>, 761-764.
</p>
<p>Kalinka, A.T. and Tomancak, P. (2011). linkcomm: an R package for the generation, visualization, and analysis of link communities in networks of arbitrary size and type. <em>Bioinformatics</em> <b>27</b>, 2011-2012.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.linkcomm">plot.linkcomm</a></code>, <code><a href="#topic+newLinkCommsAt">newLinkCommsAt</a></code>, <code><a href="#topic+meta.communities">meta.communities</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate graph and extract link communities.
g &lt;- swiss[,3:4]
lc &lt;- getLinkCommunities(g)

## Extract communities by writing a temporary file to disk.
lc &lt;- getLinkCommunities(g, edglim = 10)

## Use similarities between all pairs of edges.
lc &lt;- getLinkCommunities(g, use.all.edges = TRUE)

## Directed network.
lc &lt;- getLinkCommunities(g, directed = TRUE, dirweight = 0.8)

## Weighted network.
g &lt;- cbind(swiss[,3:4], runif(nrow(swiss[,3:4])))
lc &lt;- getLinkCommunities(g)

## Directed and weighted network.
lc &lt;- getLinkCommunities(g, directed = TRUE, dirweight = 0.8)

</code></pre>

<hr>
<h2 id='getNestedHierarchies'>
Find Nested Structures in Communities
</h2><span id='topic+getNestedHierarchies'></span>

<h3>Description</h3>

<p>This function determines whether a particular community is nested within any other communities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getNestedHierarchies(x, clusid = 1, verbose = TRUE, plot = TRUE, ids = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getNestedHierarchies_+3A_x">x</code></td>
<td>

<p>An object of class <code>linkcomm</code>.
</p>
</td></tr>
<tr><td><code id="getNestedHierarchies_+3A_clusid">clusid</code></td>
<td>

<p>An integer value indicating the community ID whose nesting structure will be tested. Defaults to 1.
</p>
</td></tr>
<tr><td><code id="getNestedHierarchies_+3A_verbose">verbose</code></td>
<td>

<p>Logical, whether to display a warning that a particular community is not nested in any other communities on the screen. Defaults to FALSE.
</p>
</td></tr>
<tr><td><code id="getNestedHierarchies_+3A_plot">plot</code></td>
<td>

<p>Logical, whether to plot a graph layout of the nested community.
</p>
</td></tr>
<tr><td><code id="getNestedHierarchies_+3A_ids">ids</code></td>
<td>

<p>Logical, whether to return only the community IDs that the community is nested in, or the node names also. Defaults to FALSE.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a list of character vectors, each giving the nodes that the community is nested in, or an integer vector of community IDs that the community is nested in.
</p>


<h3>Author(s)</h3>

<p>Alex T. Kalinka <a href="mailto:alex.t.kalinka@gmail.com">alex.t.kalinka@gmail.com</a>
</p>


<h3>References</h3>

<p>Kalinka, A.T. and Tomancak, P. (2011). linkcomm: an R package for the generation, visualization, and analysis of link communities in networks of arbitrary size and type. <em>Bioinformatics</em> <b>27</b>, 2011-2012.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getAllNestedComm">getAllNestedComm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate graph and extract link communities.
g &lt;- swiss[,3:4]
lc &lt;- getLinkCommunities(g)

## Determine if community 1 is nested in any other communities.
getNestedHierarchies(lc, clusid = 1)
</code></pre>

<hr>
<h2 id='getNodesIn'>
Extract Nodes from Communities
</h2><span id='topic+getNodesIn'></span>

<h3>Description</h3>

<p>This function returns node names that belong to sets of communities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getNodesIn(x, clusterids = 1, type = "names")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getNodesIn_+3A_x">x</code></td>
<td>

<p>An object of class <code>linkcomm</code> or <code>OCG</code>.
</p>
</td></tr>
<tr><td><code id="getNodesIn_+3A_clusterids">clusterids</code></td>
<td>

<p>An integer vector of community IDs. Defaults to community 1.
</p>
</td></tr>
<tr><td><code id="getNodesIn_+3A_type">type</code></td>
<td>

<p>A character string specifying how nodes are returned. Can be one of <code>"names"</code> or <code>"indices"</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of node names (if type is <code>"names"</code>) or a numerical vector of node indices (if type is <code>"indices"</code>).
</p>


<h3>Author(s)</h3>

<p>Alex T. Kalinka <a href="mailto:alex.t.kalinka@gmail.com">alex.t.kalinka@gmail.com</a>
</p>


<h3>References</h3>

<p>Kalinka, A.T. and Tomancak, P. (2011). linkcomm: an R package for the generation, visualization, and analysis of link communities in networks of arbitrary size and type. <em>Bioinformatics</em> <b>27</b>, 2011-2012.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate graph and extract link communities.
g &lt;- swiss[,3:4]
lc &lt;- getLinkCommunities(g)

## Get nodes from community 1.
getNodesIn(lc)
</code></pre>

<hr>
<h2 id='getOCG.clusters'>
Generate Overlapping Cluster Generator (OCG) Communities
</h2><span id='topic+getOCG.clusters'></span>

<h3>Description</h3>

<p>This function generates communities based on the OCG algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getOCG.clusters(network, init.class.sys = 3, max.class.card = 0, 
                cent.class.sys = 1, min.class = 2, verbose = TRUE, keep.out = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getOCG.clusters_+3A_network">network</code></td>
<td>

<p>Either a character string naming the file containing the network as an edge list, or a data frame/matrix object containing the edge list.
</p>
</td></tr>
<tr><td><code id="getOCG.clusters_+3A_init.class.sys">init.class.sys</code></td>
<td>

<p>An integer number specifying the Initial Class System: 1 - Maximal Cliques, 2 - Edges, or 3 - Centered Cliques. Defaults to 3.
</p>
</td></tr>
<tr><td><code id="getOCG.clusters_+3A_max.class.card">max.class.card</code></td>
<td>

<p>An integer number specifying the maximum allowed class cardinality. Defaults to 0, which indicates no constraint.
</p>
</td></tr>
<tr><td><code id="getOCG.clusters_+3A_cent.class.sys">cent.class.sys</code></td>
<td>

<p>A binary value indicating the choice of class system for centered cliques: 0 - Final class system, needs the expected minimum number of clusters and the maximum caldinality of the final clusters, or 1 - the class system that maximizes modularity. Defaults to 1.
</p>
</td></tr>
<tr><td><code id="getOCG.clusters_+3A_min.class">min.class</code></td>
<td>

<p>An integer number specifying the minimum number of expected classes. Defaults to 2.
</p>
</td></tr>
<tr><td><code id="getOCG.clusters_+3A_verbose">verbose</code></td>
<td>

<p>Logical, whether to display progress of the algorithm to the screen. Defaults to TRUE.
</p>
</td></tr>
<tr><td><code id="getOCG.clusters_+3A_keep.out">keep.out</code></td>
<td>

<p>Logical, whether to keep the OCG partition intermediate file on disk or not. Defaults to FALSE.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>OCG</code>, which is a list containing the following elements:
</p>
<table role = "presentation">
<tr><td><code>numbers</code></td>
<td>
<p>An integer vector with the number of edges, nodes, and communities.</p>
</td></tr>
<tr><td><code>modularity</code></td>
<td>
<p>An integer number specifying the modularity of the network.</p>
</td></tr>
<tr><td><code>Q</code></td>
<td>
<p>A real number specifying the value of Q generated by the OCG algorithm.</p>
</td></tr>
<tr><td><code>nodeclusters</code></td>
<td>
<p>A data frame consisting of 2 columns; the first contains node names, and the second contains single community IDs for each node. All communities and their nodes are represented, but not necessarily all nodes.</p>
</td></tr>
<tr><td><code>numclusters</code></td>
<td>
<p>A named integer vector. Names are node names and integer values are the number of communities to which each node belongs.</p>
</td></tr>
<tr><td><code>igraph</code></td>
<td>
<p>An object of class <code>igraph</code>. The network is represented here as an <code>igraph</code> object.</p>
</td></tr>
<tr><td><code>edgelist</code></td>
<td>
<p>A character matrix with 2 columns containing the nodes that interact with each other.</p>
</td></tr>
<tr><td><code>clustsizes</code></td>
<td>
<p>A named integer vector. Names are community IDs and integer values indicate the number of nodes that belong in each community.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>For optimal results, the input network must contain at least one connected component (a subgraph in which any two vertices are connected by a path, which is not connected to additional vertices in the supergraph).
</p>


<h3>Author(s)</h3>

<p>Alain Guenoche (main algorithm), and ported into <span class="rlang"><b>R</b></span> by Alex T. Kalinka <a href="mailto:alex.t.kalinka@gmail.com">alex.t.kalinka@gmail.com</a>
</p>


<h3>References</h3>

<p>Becker, E., Robisson, B., Chapple, C.E., Guenoche, A. and Brun, C. (2012) Multifunctional proteins revealed by overlapping clustering in protein interaction network. <em>Bioinformatics</em> <b>28</b>, 84-90.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate graph and extract OCG communities.
g &lt;- swiss[,3:4]
oc &lt;- getOCG.clusters(g)
</code></pre>

<hr>
<h2 id='graph.feature'>
Make Node or Edge Graph Features
</h2><span id='topic+graph.feature'></span>

<h3>Description</h3>

<p>This function returns vectors of node sizes or edge widths for use in <code>plot.linkcomm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.feature(x, type = "nodes", clusterids = 1:length(x$clusters), 
              nodes = NULL, indices, features, default = 15, showall = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph.feature_+3A_x">x</code></td>
<td>

<p>An object of class <code>linkcomm</code>.
</p>
</td></tr>
<tr><td><code id="graph.feature_+3A_type">type</code></td>
<td>

<p>A character string specifying either <code>"nodes"</code> or <code>"edges"</code>.
</p>
</td></tr>
<tr><td><code id="graph.feature_+3A_clusterids">clusterids</code></td>
<td>

<p>An integer vector of community IDs that will be plotted. Defaults to all communities.
</p>
</td></tr>
<tr><td><code id="graph.feature_+3A_nodes">nodes</code></td>
<td>

<p>A character vector specifying node(s) that will be plotted. Overrides <code>clusterids</code>. Defaults to NULL.
</p>
</td></tr>
<tr><td><code id="graph.feature_+3A_indices">indices</code></td>
<td>

<p>An integer vector specifying the indices of the nodes or edges that will be given specific size or width values. See <code><a href="#topic+getNodesIn">getNodesIn</a></code> and <code><a href="#topic+getEdgesIn">getEdgesIn</a></code> for ways to generate these indices. Also see examples in <code>vignette(topic = "linkcomm", package = "linkcomm")</code>.
</p>
</td></tr>
<tr><td><code id="graph.feature_+3A_features">features</code></td>
<td>

<p>An integer vector specifying the node or edge sizes for the nodes or edges that are to be changed. If there is a single value then this will be applied to all nodes or edges specified in <code>indices</code>, otherwise the <code>features</code> vector must be the same length as the <code>indices</code> vector and the values will be matched to each other.
</p>
</td></tr>
<tr><td><code id="graph.feature_+3A_default">default</code></td>
<td>

<p>An integer value specifying the node size or edge width that all nodes or edges not specified by <code>indices</code> will take. Defaults to 15.
</p>
</td></tr>
<tr><td><code id="graph.feature_+3A_showall">showall</code></td>
<td>

<p>Logical, whether edges that don't belong to communities will also be plotted or not. Defaults to FALSE.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named integer vector of node sizes or edge widths. The names will be either node names or edge indices.
</p>


<h3>Author(s)</h3>

<p>Alex T. Kalinka <a href="mailto:alex.t.kalinka@gmail.com">alex.t.kalinka@gmail.com</a>
</p>


<h3>References</h3>

<p>Kalinka, A.T. and Tomancak, P. (2011). linkcomm: an R package for the generation, visualization, and analysis of link communities in networks of arbitrary size and type. <em>Bioinformatics</em> <b>27</b>, 2011-2012.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotLinkCommGraph">plotLinkCommGraph</a></code>, <code><a href="#topic+getNodesIn">getNodesIn</a></code>, <code><a href="#topic+getEdgesIn">getEdgesIn</a></code>, <code>vignette(topic = "linkcomm", package = "linkcomm")</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate graph and extract link communities.
g &lt;- swiss[,3:4]
lc &lt;- getLinkCommunities(g)

## Make node size vector for all nodes that belong to community 1.
graph.feature(lc, indices = getNodesIn(lc, type = "indices"), features = 20, default = 5)

## Make edge width vector for all edges that belong to community 1.
graph.feature(lc, type = "edges", indices = getEdgesIn(lc), features = 5, default = 1)
</code></pre>

<hr>
<h2 id='human_pp'>Sample Human Protein Interactome</h2><span id='topic+human_pp'></span>

<h3>Description</h3>

<p>A set of 864 human proteins involved in 999 interactions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>human_pp
</code></pre>


<h3>Format</h3>

<p>Data frame with 2 columns.</p>


<h3>References</h3>

<p>Becker, E., Robisson, B., Chapple, C.E., Guenoche, A. and Brun, C. (2012) Multifunctional proteins revealed by overlapping clustering in protein interaction network. <em>Bioinformatics</em> <b>28</b>, 84-90.
</p>

<hr>
<h2 id='integer.edgelist'>
Convert A Network to an Integer Edgelist
</h2><span id='topic+integer.edgelist'></span>

<h3>Description</h3>

<p>This function converts a character string edgelist into an integer edgelist.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>integer.edgelist(network)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="integer.edgelist_+3A_network">network</code></td>
<td>

<p>An edge list, which is a matrix or data frame with 2 or 3 columns. The first 2 columns contain the nodes that interact with each other, which can be character strings or integer values. The optional third column is a numerical vector of weights for each edge, which is stripped from the output.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following components:
</p>
<table role = "presentation">
<tr><td><code>edges</code></td>
<td>
<p>A matrix with two columns containing the integer edgelist.</p>
</td></tr>
<tr><td><code>nodes</code></td>
<td>
<p>A named integer vector mapping node integer IDs to their character string equivalents.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alex T. Kalinka <a href="mailto:alex.t.kalinka@gmail.com">alex.t.kalinka@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getLinkCommunities">getLinkCommunities</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate graph and convert into an integer edgelist.
g &lt;- data.frame(letters[1:10],letters[6:15])
gi &lt;- integer.edgelist(g)
</code></pre>

<hr>
<h2 id='karate'>Social Network in a Karate Club</h2><span id='topic+karate'></span>

<h3>Description</h3>

<p>A social network of friendships between 34 members of a karate club at a US university in the 1970s (Zachary 1977).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>karate
</code></pre>


<h3>Format</h3>

<p>Data frame with 2 columns.</p>


<h3>Source</h3>

<p><a href="https://github.com/gephi/gephi/wiki/Datasets">https://github.com/gephi/gephi/wiki/Datasets</a></p>


<h3>References</h3>

<p>Zachary, W. W. (1977). An information flow model for conflict and fission in small groups. <em>Journal of Anthropological Research</em> <b>33</b>, 452-473.
</p>

<hr>
<h2 id='layout.spencer.circle'>
Calculate Node Coordinates for a Spencer Circle
</h2><span id='topic+layout.spencer.circle'></span>

<h3>Description</h3>

<p>This function returns the x-y coordinates for nodes in a Spencer circle together with community anchor positions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout.spencer.circle(x, clusterids = 1:x$numbers[3], verbose = TRUE, 
                      jitter = 0.2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="layout.spencer.circle_+3A_x">x</code></td>
<td>

<p>An object of class <code>linkcomm</code>.
</p>
</td></tr>
<tr><td><code id="layout.spencer.circle_+3A_clusterids">clusterids</code></td>
<td>

<p>An integer vector of community IDs. Defaults to all communities.
</p>
</td></tr>
<tr><td><code id="layout.spencer.circle_+3A_verbose">verbose</code></td>
<td>

<p>Logical, whether to print the progress of the calculation to the screen. Defaults to TRUE.
</p>
</td></tr>
<tr><td><code id="layout.spencer.circle_+3A_jitter">jitter</code></td>
<td>

<p>A positive numerical value specifying the range (negative to positive) of random, uniformly distributed noise that will be added to nodes that have identical x-y coordinates. Defaults to 0.2.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm anchors communities evenly around the circumference of a circle in their dendrogram order (to minimise crossing over of links) and positions nodes within the circle according to how many links they possess in each of the communities (Spencer, 2010). Thus, nodes that have links to a lot of communities will get pushed into the centre of the circle making this method well suited for representing ego networks where one or a small number of nodes belong to multiple communities.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table role = "presentation">
<tr><td><code>nodes</code></td>
<td>
<p>A numerical matrix with nodes as rows and with 2 columns; the first contains the x coordinates and the second the y coordinates.</p>
</td></tr>
<tr><td><code>anchors</code></td>
<td>
<p>A numerical matrix with communities as rows and with 2 columns of x and y coordinates.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alex T. Kalinka <a href="mailto:alex.t.kalinka@gmail.com">alex.t.kalinka@gmail.com</a>
</p>


<h3>References</h3>

<p>Kalinka, A.T. and Tomancak, P. (2011). linkcomm: an R package for the generation, visualization, and analysis of link communities in networks of arbitrary size and type. <em>Bioinformatics</em> <b>27</b>, 2011-2012.
</p>
<p>Spencer, R. (2010). <a href="http://scaledinnovation.com/analytics/communities/comlinks.html">http://scaledinnovation.com/analytics/communities/comlinks.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.linkcomm">plot.linkcomm</a></code>, <code><a href="#topic+plotLinkCommGraph">plotLinkCommGraph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate graph and extract link communities.
g &lt;- swiss[,3:4]
lc &lt;- getLinkCommunities(g)

## Extract x-y coordinates for nodes in a Spencer circle.
layout.spencer.circle(lc)
</code></pre>

<hr>
<h2 id='lesmiserables'>Co-Appearance Network from Les Miserables</h2><span id='topic+lesmiserables'></span>

<h3>Description</h3>

<p>The co-appearance network for Les Miserables (Knuth 1993). Involves 252 interactions among 77 nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lesmiserables
</code></pre>


<h3>Format</h3>

<p>Data frame with 2 columns.</p>


<h3>Source</h3>

<p><a href="https://github.com/gephi/gephi/wiki/Datasets">https://github.com/gephi/gephi/wiki/Datasets</a></p>


<h3>References</h3>

<p>Knuth, D. E. (1993). <em>The Stanford GraphBase: A Platform for Combinatorial Computing</em>, Addison-Wesley, Reading, MA.
</p>

<hr>
<h2 id='linkcomm2clustnsee'>
Write a Partition File for Clust&amp;See
</h2><span id='topic+linkcomm2clustnsee'></span>

<h3>Description</h3>

<p>This function writes out a partition file which can be imported into the Cytoscape plug-in Clust&amp;See.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linkcomm2clustnsee(x, file = "temp.cns", network.name = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="linkcomm2clustnsee_+3A_x">x</code></td>
<td>

<p>An object of class <code>linkcomm</code> or <code>OCG</code>.
</p>
</td></tr>
<tr><td><code id="linkcomm2clustnsee_+3A_file">file</code></td>
<td>

<p>A character string naming a Clust&amp;See partition file (.cns extension). Defaults to <code>"temp.cns"</code>.
</p>
</td></tr>
<tr><td><code id="linkcomm2clustnsee_+3A_network.name">network.name</code></td>
<td>

<p>A character string providing a name for the network. This name must correspond to the file name of the network that will be imported into Cytoscape. If NULL, the object name, <code>x</code>, is used. Defaults to NULL.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Cytoscape is an open source platform for complex-network analysis and visualization, and Clust&amp;See (Spinelli et al. 2013) is a Cytoscape plug-in used for visualizing and manipulating the clusters produced by various network clustering algorithms.
</p>


<h3>Value</h3>

<p>Used for its side-effect of writing a Clust&amp;See partition file to disk.
</p>


<h3>Author(s)</h3>

<p>Alex T. Kalinka <a href="mailto:alex.t.kalinka@gmail.com">alex.t.kalinka@gmail.com</a>
</p>


<h3>References</h3>

<p>Becker, E. et al. (2012) Multifunctional proteins revealed by overlapping clustering in protein interaction network. <em>Bioinformatics</em> <b>28</b>, 84-90.
</p>
<p>Gambette, P. and Guenoche, A. (2011) Bootstrap clustering for graph partitioning. <em>RAIRO-Operations Research</em> <b>45</b>, 339-352.
</p>
<p>Kalinka, A.T. and Tomancak, P. (2011). linkcomm: an R package for the generation, visualization, and analysis of link communities in networks of arbitrary size and type. <em>Bioinformatics</em> <b>27</b>, 2011-2012.
</p>
<p>Shannon, P. et al. (2003) Cytoscape: A software environment for integrated models of biomolecular interaction networks. <em>Genome Research</em> <b>13</b>, 2498-2504.
</p>
<p>Spinelli, L. et al. (2013) Clust&amp;See: a Cytoscape plugin for the identification, visualization, and manipulation of network clusters. <em>BioSystems</em> <b>113</b>, 91-95.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate graph and extract link communities.
g &lt;- swiss[,3:4]
lc &lt;- getLinkCommunities(g)

## Write a partition file to disk.
## Not run: 
linkcomm2clustnsee(lc)

## End(Not run)

</code></pre>

<hr>
<h2 id='linkcomm2cytoscape'>
Write an Edge Attribute File for Cytoscape
</h2><span id='topic+linkcomm2cytoscape'></span>

<h3>Description</h3>

<p>This function writes out an edge attribute file for visualising the link communities in Cytoscape.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linkcomm2cytoscape(x, interaction = "pp", ea = "temp.ea")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="linkcomm2cytoscape_+3A_x">x</code></td>
<td>

<p>An object of class <code>linkcomm</code>.
</p>
</td></tr>
<tr><td><code id="linkcomm2cytoscape_+3A_interaction">interaction</code></td>
<td>

<p>A character string indicating the type of interaction between nodes. Defaults to <code>"pp"</code> for protein-protein interaction.
</p>
</td></tr>
<tr><td><code id="linkcomm2cytoscape_+3A_ea">ea</code></td>
<td>

<p>A character string indicating the file for writing the edge attributes. Defaults to <code>"temp.ea"</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Cytoscape is an open source platform for complex-network analysis and visualization (Shannon et al. 2003).
</p>


<h3>Value</h3>

<p>Used for its side-effect of writing an edge attribute file to disk.
</p>


<h3>Author(s)</h3>

<p>Alex T. Kalinka <a href="mailto:alex.t.kalinka@gmail.com">alex.t.kalinka@gmail.com</a>
</p>


<h3>References</h3>

<p>Kalinka, A.T. and Tomancak, P. (2011). linkcomm: an R package for the generation, visualization, and analysis of link communities in networks of arbitrary size and type. <em>Bioinformatics</em> <b>27</b>, 2011-2012.
</p>
<p>Shannon, P. et al. (2003) Cytoscape: A software environment for integrated models of biomolecular interaction networks. <em>Genome Research</em> <b>13</b>, 2498-2504.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate graph and extract link communities.
g &lt;- swiss[,3:4]
lc &lt;- getLinkCommunities(g)

## Write an edge attribute file to disk.
## Not run: 
linkcomm2cytoscape(lc)

## End(Not run)
</code></pre>

<hr>
<h2 id='LinkDensities'>
Calculate Link Community Link Densities
</h2><span id='topic+LinkDensities'></span>

<h3>Description</h3>

<p>This function calculates link densities for link communities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LinkDensities(x, clusterids = 1:x$numbers[3])
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LinkDensities_+3A_x">x</code></td>
<td>

<p>An object of class <code>linkcomm</code>.
</p>
</td></tr>
<tr><td><code id="LinkDensities_+3A_clusterids">clusterids</code></td>
<td>

<p>An integer vector of community IDs. Defaults to all communities.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The link density of community i is
</p>
<p style="text-align: center;"><code class="reqn">D_{i}=\frac{e_{i}-n_{i}+1}{(n_{i}(n_{i}-1)/2)-n_{i}+1}</code>
</p>

<p>where <code class="reqn">e_{i}</code> is the number of edges in community i and <code class="reqn">n_{i}</code> is the number of nodes in community i.
</p>


<h3>Value</h3>

<p>A named numerical vector, where the names are community IDs and the numbers are link densities.
</p>


<h3>Author(s)</h3>

<p>Alex T. Kalinka <a href="mailto:alex.t.kalinka@gmail.com">alex.t.kalinka@gmail.com</a>
</p>


<h3>References</h3>

<p>Ahn, Y.Y., Bagrow, J.P., and Lehmann, S. (2010). Link communities reveal multiscale complexity in networks. <em>Nature</em> <b>466</b>, 761-764.
</p>
<p>Kalinka, A.T. and Tomancak, P. (2011). linkcomm: an R package for the generation, visualization, and analysis of link communities in networks of arbitrary size and type. <em>Bioinformatics</em> <b>27</b>, 2011-2012.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.linkcomm">plot.linkcomm</a></code>, <code><a href="#topic+plotLinkCommSummComm">plotLinkCommSummComm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate graph and extract link communities.
g &lt;- swiss[,3:4]
lc &lt;- getLinkCommunities(g)

## Calculate link densities.
ld &lt;- LinkDensities(lc)
</code></pre>

<hr>
<h2 id='meta.communities'>
Produce a Set of Meta-Communities
</h2><span id='topic+meta.communities'></span>

<h3>Description</h3>

<p>This function returns meta-communities by hierarchically clustering link communities based on their number of shared nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meta.communities(x, hcmethod = "ward.D", deepSplit = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="meta.communities_+3A_x">x</code></td>
<td>

<p>An object of class <code>linkcomm</code> or <code>OCG</code>.
</p>
</td></tr>
<tr><td><code id="meta.communities_+3A_hcmethod">hcmethod</code></td>
<td>

<p>A character string naming the hierarchical clustering method to use. Can be one of <code>"ward.D"</code>, <code>"ward.D2"</code>, <code>"single"</code>, <code>"complete"</code>, <code>"average"</code>, <code>"mcquitty"</code>, <code>"median"</code>, or <code>"centroid"</code>. Defaults to <code>"ward.D"</code>.
</p>
</td></tr>
<tr><td><code id="meta.communities_+3A_deepsplit">deepSplit</code></td>
<td>

<p>Logical or integer value from 0 to 4 indicating how fine-grained the clusters should be with larger values giving increased cluster structure. Defaults to FALSE.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Extracting meta-communities allows the user to explore community relatedness and structure at higher levels. Community relatedness is calculated using the Jaccard coefficient and the number of nodes that community i and j share:
</p>
<p style="text-align: center;"><code class="reqn">S(i,j)=\frac{|n_{i}\cap n_{j}|}{|n_{i}\cup n_{j}|}</code>
</p>

<p><br />
A hierarchical clustering dendrogram is generated based on the above distance metric and then an algorithm is used to automatically extract clusters (Langfelder et al. 2008). This function works best on large networks with a large number of link communities.
</p>


<h3>Value</h3>

<p>An object of class <code>linkcomm</code>, which is a list containing the following components:
</p>
<table role = "presentation">
<tr><td><code>numbers</code></td>
<td>
<p>An integer vector with the number of edges, nodes, and communities.</p>
</td></tr>
<tr><td><code>hclust</code></td>
<td>
<p>An object of class <code><a href="stats.html#topic+hclust">hclust</a></code>, which contains information about the hierarchical clustering of links.</p>
</td></tr>
<tr><td><code>pdmax</code></td>
<td>
<p>A numerical value indicating the height of the dendrogram at which the partition density is maximised.</p>
</td></tr>
<tr><td><code>pdens</code></td>
<td>
<p>A numerical matrix with 2 columns; the first is the heights at which clusters appear and the second is the partition density.</p>
</td></tr>
<tr><td><code>nodeclusters</code></td>
<td>
<p>A data frame consisting of 2 columns; the first contains node names, and the second contains single community IDs for each node. All communities and their nodes are represented, but not necessarily all nodes.</p>
</td></tr>
<tr><td><code>clusters</code></td>
<td>
<p>A list of integer vectors containing the link IDs that belong to each community. Community IDs are the numerical position of the communities in the list.</p>
</td></tr>
<tr><td><code>edges</code></td>
<td>
<p>A data frame with 3 columns; the first two contain nodes that interact with each other, and the third is an integer vector of community IDs indicating community membership for each link.</p>
</td></tr>
<tr><td><code>numclusters</code></td>
<td>
<p>A named integer vector. Names are node names and integer values are the number of communities to which each node belongs.</p>
</td></tr>
<tr><td><code>clustsizes</code></td>
<td>
<p>A named integer vector. Names are community IDs and integer values indicate the number of nodes that belong in each community.</p>
</td></tr>
<tr><td><code>igraph</code></td>
<td>
<p>An object of class <code>igraph</code>. The network is represented here as an <code>igraph</code> object.</p>
</td></tr>
<tr><td><code>edgelist</code></td>
<td>
<p>A character matrix with 2 columns containing the nodes that interact with each other.</p>
</td></tr>
<tr><td><code>directed</code></td>
<td>
<p>Logical indicating whether the network is directed.</p>
</td></tr>
<tr><td><code>bipartite</code></td>
<td>
<p>Logical indicating whether the network is bi-partite.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alex T. Kalinka <a href="mailto:alex.t.kalinka@gmail.com">alex.t.kalinka@gmail.com</a>
</p>


<h3>References</h3>

<p>Kalinka, A.T. and Tomancak, P. (2011). linkcomm: an R package for the generation, visualization, and analysis of link communities in networks of arbitrary size and type. <em>Bioinformatics</em> <b>27</b>, 2011-2012.
</p>
<p>Langfelder, P., Zhang, B., and Horvath, S. (2008) Defining clusters from a hierarchical cluster tree: the Dynamic Tree Cut package for R. <em>Bioinformatics</em> <b>24</b>, 719-720.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getClusterRelatedness">getClusterRelatedness</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate graph and extract link communities.
g &lt;- swiss[,3:4]
lc &lt;- getLinkCommunities(g)

## Produce meta-communities.
## Not run: mc &lt;- meta.communities(lc)
</code></pre>

<hr>
<h2 id='newLinkCommsAt'>
User-Defined Link Communities
</h2><span id='topic+newLinkCommsAt'></span>

<h3>Description</h3>

<p>This function allows the user to extract link communities by cutting the dendrogram at a specified height.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newLinkCommsAt(x, cutat = 0.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="newLinkCommsAt_+3A_x">x</code></td>
<td>

<p>An object of class <code>linkcomm</code>.
</p>
</td></tr>
<tr><td><code id="newLinkCommsAt_+3A_cutat">cutat</code></td>
<td>

<p>A numerical value indicating the height at which to cut the dendrogram. Defaults to 0.5.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Users may wish to explore the communities formed by cutting the dendrogram higher or lower than the maximum partition density height. After cutting at a new height, the <code>pdmax</code> value in the resulting object will be set to the <code>cutat</code> value used by the user, only to distinguish the new object from the one generated by the link communities algorithm (the global partition density maximum does not change).
</p>


<h3>Value</h3>

<p>An object of class <code>linkcomm</code>, which is a list containing the following components:
</p>
<table role = "presentation">
<tr><td><code>numbers</code></td>
<td>
<p>An integer vector with the number of edges, nodes, and communities.</p>
</td></tr>
<tr><td><code>hclust</code></td>
<td>
<p>An object of class <code><a href="stats.html#topic+hclust">hclust</a></code>, which contains information about the hierarchical clustering of links.</p>
</td></tr>
<tr><td><code>pdmax</code></td>
<td>
<p>A numerical value indicating the height of the dendrogram at which the partition density is maximised.</p>
</td></tr>
<tr><td><code>pdens</code></td>
<td>
<p>A numerical matrix with 2 columns; the first is the heights at which clusters appear and the second is the partition density.</p>
</td></tr>
<tr><td><code>nodeclusters</code></td>
<td>
<p>A data frame consisting of 2 columns; the first contains node names, and the second contains single community IDs for each node. All communities and their nodes are represented, but not necessarily all nodes.</p>
</td></tr>
<tr><td><code>clusters</code></td>
<td>
<p>A list of integer vectors containing the link IDs that belong to each community. Community IDs are the numerical position of the communities in the list.</p>
</td></tr>
<tr><td><code>edges</code></td>
<td>
<p>A data frame with 3 columns; the first two contain nodes that interact with each other, and the third is an integer vector of community IDs indicating community membership for each link.</p>
</td></tr>
<tr><td><code>numclusters</code></td>
<td>
<p>A named integer vector. Names are node names and integer values are the number of communities to which each node belongs.</p>
</td></tr>
<tr><td><code>clustsizes</code></td>
<td>
<p>A named integer vector. Names are community IDs and integer values indicate the number of nodes that belong in each community.</p>
</td></tr>
<tr><td><code>igraph</code></td>
<td>
<p>An object of class <code>igraph</code>. The network is represented here as an <code>igraph</code> object.</p>
</td></tr>
<tr><td><code>edgelist</code></td>
<td>
<p>A character matrix with 2 columns containing the nodes that interact with each other.</p>
</td></tr>
<tr><td><code>directed</code></td>
<td>
<p>Logical indicating whether the network is directed.</p>
</td></tr>
<tr><td><code>bipartite</code></td>
<td>
<p>Logical indicating whether the network is bipartite.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>After cutting at a new height, the <code>pdmax</code> value in the resulting object will be set to the <code>cutat</code> value used by the user, only to distinguish the new object from the one generated by the link communities algorithm (the global partition density maximum does not change).
</p>


<h3>Author(s)</h3>

<p>Alex T. Kalinka <a href="mailto:alex.t.kalinka@gmail.com">alex.t.kalinka@gmail.com</a>
</p>


<h3>References</h3>

<p>Kalinka, A.T. and Tomancak, P. (2011). linkcomm: an R package for the generation, visualization, and analysis of link communities in networks of arbitrary size and type. <em>Bioinformatics</em> <b>27</b>, 2011-2012.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getLinkCommunities">getLinkCommunities</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate graph and extract link communities.
g &lt;- swiss[,3:4]
lc &lt;- getLinkCommunities(g)

## User defined communities.
lc2 &lt;- newLinkCommsAt(lc, cutat = 0.8)
</code></pre>

<hr>
<h2 id='numberEdgesIn'>
Extract Node Community Membership by Edges
</h2><span id='topic+numberEdgesIn'></span>

<h3>Description</h3>

<p>This function returns the number of edges node(s) contain in each community.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>numberEdgesIn(x, clusterids = 1:x$numbers[3], nodes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="numberEdgesIn_+3A_x">x</code></td>
<td>

<p>An object of class <code>linkcomm</code> or <code>OCG</code>.
</p>
</td></tr>
<tr><td><code id="numberEdgesIn_+3A_clusterids">clusterids</code></td>
<td>

<p>An integer vector of community IDs. Defaults to all communities.
</p>
</td></tr>
<tr><td><code id="numberEdgesIn_+3A_nodes">nodes</code></td>
<td>

<p>A character vector specifying node(s) for which edge membership should be returned.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of named integer vectors specifying the number of edges in each community a node belongs in. Names of the integer vectors are community IDs, and names of the list are node names.
</p>


<h3>Author(s)</h3>

<p>Alex T. Kalinka <a href="mailto:alex.t.kalinka@gmail.com">alex.t.kalinka@gmail.com</a>
</p>


<h3>References</h3>

<p>Kalinka, A.T. and Tomancak, P. (2011). linkcomm: an R package for the generation, visualization, and analysis of link communities in networks of arbitrary size and type. <em>Bioinformatics</em> <b>27</b>, 2011-2012.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate graph and extract OCG communities.
g &lt;- swiss[,3:4]
oc &lt;- getOCG.clusters(g)

## Get edges from community 1.
numberEdgesIn(oc, nodes = 1)
</code></pre>

<hr>
<h2 id='orderCommunities'>
Order Link Communities According to the Dendrogram
</h2><span id='topic+orderCommunities'></span>

<h3>Description</h3>

<p>This function returns link communities in the same order as in the hierarchical clustering dendrogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orderCommunities(x, clusterids = 1:x$numbers[3], verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orderCommunities_+3A_x">x</code></td>
<td>

<p>An object of class <code>linkcomm</code>.
</p>
</td></tr>
<tr><td><code id="orderCommunities_+3A_clusterids">clusterids</code></td>
<td>

<p>An integer vector of community IDs. Defaults to all communities.
</p>
</td></tr>
<tr><td><code id="orderCommunities_+3A_verbose">verbose</code></td>
<td>

<p>Logical, whether to print progress of the calculation to the screen. Defaults to TRUE.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Ordering link communities according to the dendrogram can aid in visualization when plotting them as a Spencer circle because it minimses crossing over between links.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table role = "presentation">
<tr><td><code>ordered</code></td>
<td>
<p>A list of integer vectors. These are the ordered communities of links.</p>
</td></tr>
<tr><td><code>clusids</code></td>
<td>
<p>An integer vector of community IDs in their new order.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alex T. Kalinka <a href="mailto:alex.t.kalinka@gmail.com">alex.t.kalinka@gmail.com</a>
</p>


<h3>References</h3>

<p>Kalinka, A.T. and Tomancak, P. (2011). linkcomm: an R package for the generation, visualization, and analysis of link communities in networks of arbitrary size and type. <em>Bioinformatics</em> <b>27</b>, 2011-2012.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.linkcomm">plot.linkcomm</a></code>, <code><a href="#topic+plotLinkCommGraph">plotLinkCommGraph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate graph and extract link communities.
g &lt;- swiss[,3:4]
lc &lt;- getLinkCommunities(g)

## Order communities according to the dendrogram.
orderCommunities(lc)
</code></pre>

<hr>
<h2 id='plot.linkcomm'>
The <code>linkcomm</code> Plotting Function
</h2><span id='topic+plot.linkcomm'></span>

<h3>Description</h3>

<p>This function plots various different <code>linkcomm</code> graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'linkcomm'
plot(x, type = "", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.linkcomm_+3A_x">x</code></td>
<td>

<p>An object of class <code>linkcomm</code>.
</p>
</td></tr>
<tr><td><code id="plot.linkcomm_+3A_type">type</code></td>
<td>

<p>A character string specifying the type of plot. Can be one of <code>"summary"</code>, <code>"members"</code>, <code>"graph"</code>, <code>"commsumm"</code>, and <code>"dend"</code>. See Details below.
</p>
</td></tr>
<tr><td><code id="plot.linkcomm_+3A_...">...</code></td>
<td>

<p>Additional arguments to be passed to <code>plot</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>"summary"</code> plots the dendrogram and partition density plot side-by-side;<br /> <code>"members"</code> plots a community membership matrix;<br /> <code>"graph"</code> plots a graph layout of the network with coloured link communities;<br /> <code>"commsumm"</code> plots a bar graph or pie chart summarising community modularity or connectedness for each community;<br /> <code>"dend"</code> plots a dendrogram with coloured link communities.<br /><br /> See the individual plotting functions for details of arguments that can be passed to <code>plot.linkcomm</code>: <code><a href="#topic+plotLinkCommSumm">plotLinkCommSumm</a></code>, <code><a href="#topic+plotLinkCommMembers">plotLinkCommMembers</a></code>, <code><a href="#topic+plotLinkCommGraph">plotLinkCommGraph</a></code>, <code><a href="#topic+plotLinkCommSummComm">plotLinkCommSummComm</a></code>, and <code><a href="#topic+plotLinkCommDend">plotLinkCommDend</a></code>.
</p>


<h3>Value</h3>

<p>Plots to the current device.
</p>


<h3>Author(s)</h3>

<p>Alex T. Kalinka <a href="mailto:alex.t.kalinka@gmail.com">alex.t.kalinka@gmail.com</a>
</p>


<h3>References</h3>

<p>Kalinka, A.T. and Tomancak, P. (2011). linkcomm: an R package for the generation, visualization, and analysis of link communities in networks of arbitrary size and type. <em>Bioinformatics</em> <b>27</b>, 2011-2012.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotLinkCommSumm">plotLinkCommSumm</a></code>, <code><a href="#topic+plotLinkCommMembers">plotLinkCommMembers</a></code>, <code><a href="#topic+plotLinkCommGraph">plotLinkCommGraph</a></code>, <code><a href="#topic+plotLinkCommSummComm">plotLinkCommSummComm</a></code>, <code><a href="#topic+plotLinkCommDend">plotLinkCommDend</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate graph and extract link communities.
g &lt;- swiss[,3:4]
lc &lt;- getLinkCommunities(g)

## Plot a graph of link communities.
plot(lc, type = "graph")
</code></pre>

<hr>
<h2 id='plot.OCG'>
The <code>OCG</code> Plotting Function
</h2><span id='topic+plot.OCG'></span>

<h3>Description</h3>

<p>This function plots various different <code>OCG</code> graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'OCG'
plot(x, type = "", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.OCG_+3A_x">x</code></td>
<td>

<p>An object of class <code>OCG</code>.
</p>
</td></tr>
<tr><td><code id="plot.OCG_+3A_type">type</code></td>
<td>

<p>A character string specifying the type of plot. Can be one of <code>"members"</code> or <code>"graph"</code>. See Details below.
</p>
</td></tr>
<tr><td><code id="plot.OCG_+3A_...">...</code></td>
<td>

<p>Additional arguments to be passed to <code>plot</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>"members"</code> plots a community membership matrix;<br /> <code>"graph"</code> plots a graph layout of the network with coloured link communities.<br /><br /> See the <code>OCG</code> plotting function for details of arguments that can be passed to <code>plot.OCG</code>: <code><a href="#topic+plotOCGraph">plotOCGraph</a></code>, <code><a href="#topic+plotLinkCommMembers">plotLinkCommMembers</a></code>.
</p>


<h3>Value</h3>

<p>Plots to the current device.
</p>


<h3>Author(s)</h3>

<p>Alex T. Kalinka <a href="mailto:alex.t.kalinka@gmail.com">alex.t.kalinka@gmail.com</a>
</p>


<h3>References</h3>

<p>Kalinka, A.T. and Tomancak, P. (2011). linkcomm: an R package for the generation, visualization, and analysis of link communities in networks of arbitrary size and type. <em>Bioinformatics</em> <b>27</b>, 2011-2012.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotOCGraph">plotOCGraph</a></code>, <code><a href="#topic+plotLinkCommMembers">plotLinkCommMembers</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate graph and extract OCG communities.
g &lt;- swiss[,3:4]
oc &lt;- getOCG.clusters(g)

## Plot a graph of OCG clusters.
plot(oc, type = "graph")
</code></pre>

<hr>
<h2 id='plotLinkCommDend'>
Plot a Coloured Dendrogram of Link Communities
</h2><span id='topic+plotLinkCommDend'></span>

<h3>Description</h3>

<p>This function is called by <code>plot.linkcomm</code> to plot a dendrogram of coloured link communities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotLinkCommDend(x, col = TRUE, pal = brewer.pal(9, "Set1"), 
        height = x$pdmax, right = FALSE, labels = FALSE, plotcut = TRUE, 
        droptrivial = TRUE, leaflab = "none", verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotLinkCommDend_+3A_x">x</code></td>
<td>

<p>An object of class <code>linkcomm</code>.
</p>
</td></tr>
<tr><td><code id="plotLinkCommDend_+3A_col">col</code></td>
<td>

<p>Logical, whether to add community-specific colours. Defaults to TRUE.
</p>
</td></tr>
<tr><td><code id="plotLinkCommDend_+3A_pal">pal</code></td>
<td>

<p>A character vector describing a colour palette to be used for colouring the communites in the dendrogram plot. Defaults to <code>brewer.pal(9, "Set1")</code>.
</p>
</td></tr>
<tr><td><code id="plotLinkCommDend_+3A_height">height</code></td>
<td>

<p>A numerical value specifying the height at which the dendrogram is cut. Defaults to the maximum partition density height.
</p>
</td></tr>
<tr><td><code id="plotLinkCommDend_+3A_right">right</code></td>
<td>

<p>Logical, whether to orient the dendrogram to the right. Defaults to FALSE.
</p>
</td></tr>
<tr><td><code id="plotLinkCommDend_+3A_labels">labels</code></td>
<td>

<p>Logical, whether to include labels in the dendrogram. Defaults to FALSE.
</p>
</td></tr>
<tr><td><code id="plotLinkCommDend_+3A_plotcut">plotcut</code></td>
<td>

<p>Logical, whether to display a horizontal line where the dendrogram is cut. Defaults to TRUE.
</p>
</td></tr>
<tr><td><code id="plotLinkCommDend_+3A_droptrivial">droptrivial</code></td>
<td>

<p>Logical, whether to not colour communities of size 2. Defaults to TRUE.
</p>
</td></tr>
<tr><td><code id="plotLinkCommDend_+3A_leaflab">leaflab</code></td>
<td>

<p>A character string describing the leaf labels on the dendrogram. Can be one of <code>"none"</code>, <code>"perpendicular"</code>, or <code>"textlike"</code>. Defaults to <code>"none"</code>.
</p>
</td></tr>
<tr><td><code id="plotLinkCommDend_+3A_verbose">verbose</code></td>
<td>

<p>Logical, whether to display the progress of colouring the dendrogram on screen. Defaults to TRUE.
</p>
</td></tr>
<tr><td><code id="plotLinkCommDend_+3A_...">...</code></td>
<td>

<p>Additional arguments to be passed to <code>plot</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Here we describe the parameters for plotting coloured dendrograms using:<br />
<code>plot(x, type = "dend")</code>
</p>


<h3>Value</h3>

<p>A dendrogram plot.
</p>


<h3>Author(s)</h3>

<p>Alex T. Kalinka <a href="mailto:alex.t.kalinka@gmail.com">alex.t.kalinka@gmail.com</a>
</p>


<h3>References</h3>

<p>Kalinka, A.T. and Tomancak, P. (2011). linkcomm: an R package for the generation, visualization, and analysis of link communities in networks of arbitrary size and type. <em>Bioinformatics</em> <b>27</b>, 2011-2012.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.linkcomm">plot.linkcomm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate graph and extract link communities.
g &lt;- swiss[,3:4]
lc &lt;- getLinkCommunities(g)

## Plot a coloured dendrogram.
plot(lc, type = "dend")
</code></pre>

<hr>
<h2 id='plotLinkCommGraph'>
Plot a Graph Layout of Link Communities
</h2><span id='topic+plotLinkCommGraph'></span>

<h3>Description</h3>

<p>This function is called by <code>plot.linkcomm</code> to plot a graph layout of the link communities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotLinkCommGraph(x, clusterids = 1:length(x$clusters), nodes = NULL,
        layout = layout.fruchterman.reingold, pal = brewer.pal(7, "Set2"),
        random = TRUE, node.pies = TRUE, pie.local = TRUE, vertex.radius = 0.03,
        scale.vertices = 0.05, edge.color = NULL, vshape = "none", vsize = 15,
        ewidth = 3, margin = 0, vlabel.cex = 0.8, vlabel.color = "black",
        vlabel.family = "Helvetica", vertex.color = "palegoldenrod",
        vlabel = TRUE, col.nonclusters = "black", jitter = 0.2, circle = TRUE,
        printids = TRUE, cid.cex = 1, shownodesin = 0, showall = FALSE,
        verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotLinkCommGraph_+3A_x">x</code></td>
<td>

<p>An object of class <code>linkcomm</code>.
</p>
</td></tr>
<tr><td><code id="plotLinkCommGraph_+3A_clusterids">clusterids</code></td>
<td>

<p>An integer vector of community IDs. Defaults to all communities.
</p>
</td></tr>
<tr><td><code id="plotLinkCommGraph_+3A_nodes">nodes</code></td>
<td>

<p>A character vector naming the nodes to be plotted. If NULL, then community IDs are used instead. Defaults to NULL.
</p>
</td></tr>
<tr><td><code id="plotLinkCommGraph_+3A_layout">layout</code></td>
<td>

<p>A character string or function identifying the layout algorithm to be used for positioning nodes in the graph. Defaults to <code>layout.fruchterman.reingold</code>. See details for alternative layouts.
</p>
</td></tr>
<tr><td><code id="plotLinkCommGraph_+3A_pal">pal</code></td>
<td>

<p>A character vector describing a colour palette to be used for colouring the link communities in the graph. Defaults to <code>brewer.pal(7, "Set2")</code>.
</p>
</td></tr>
<tr><td><code id="plotLinkCommGraph_+3A_random">random</code></td>
<td>

<p>Logical, whether to randomise the link colours. Defaults to TRUE.
</p>
</td></tr>
<tr><td><code id="plotLinkCommGraph_+3A_node.pies">node.pies</code></td>
<td>

<p>Logical, whether to plot node pies showing as a pie chart the fraction of each node's edges which belong to each of its communities. Defaults to TRUE.
</p>
</td></tr>
<tr><td><code id="plotLinkCommGraph_+3A_pie.local">pie.local</code></td>
<td>

<p>Logical, whether to include pie segments for just the communities to which the chosen nodes belong, or for all communities. In the latter case, communities that are not present among the chosen nodes will appear as empty segments in the node pies. Will be ignored if node.pies is FALSE. Defaults to TRUE.
</p>
</td></tr>
<tr><td><code id="plotLinkCommGraph_+3A_vertex.radius">vertex.radius</code></td>
<td>

<p>A real number specifying the vertex radius. Defaults to 0.03. Will be ignored if node.pies is FALSE.
</p>
</td></tr>
<tr><td><code id="plotLinkCommGraph_+3A_scale.vertices">scale.vertices</code></td>
<td>

<p>A real number specifying the fraction of increase in vertex radius for each community membership. If NULL then all vertices are the same size. Defaults to 0.05. Will be ignored if node.pies is FALSE.
</p>
</td></tr>
<tr><td><code id="plotLinkCommGraph_+3A_edge.color">edge.color</code></td>
<td>

<p>A character string specifying the colour of edges. Defaults to <code>"grey"</code>. Will be ignored if node.pies is FALSE.
</p>
</td></tr>
<tr><td><code id="plotLinkCommGraph_+3A_vshape">vshape</code></td>
<td>

<p>A character string specifying the shape of the nodes. Can be one of <code>"none"</code>, <code>"circle"</code>, <code>"square"</code>, <code>"csquare"</code>, <code>"rectangle"</code>, <code>"crectangle"</code>, and <code>"vrectangle"</code>. Defaults to <code>"none"</code>.
</p>
</td></tr>
<tr><td><code id="plotLinkCommGraph_+3A_vsize">vsize</code></td>
<td>

<p>An integer vector of node sizes. If there is a single value this will be used for all nodes. If there are multiple values, it must be the same length as the number of nodes in the network to be visualized. See <code><a href="#topic+graph.feature">graph.feature</a></code> for generating these values. This argument only has an effect when <code>vshape</code> is not set to <code>"none"</code>. Defaults to 15.
</p>
</td></tr>
<tr><td><code id="plotLinkCommGraph_+3A_ewidth">ewidth</code></td>
<td>

<p>An integer vector of edge widths. If there is a single value this will be used for all edges. If there are multiple values, it must be the same length as the number of edges in the network to be visualized. See <code><a href="#topic+graph.feature">graph.feature</a></code> for generating these values. Defaults to 3.
</p>
</td></tr>
<tr><td><code id="plotLinkCommGraph_+3A_margin">margin</code></td>
<td>

<p>A numerical value specifying the amount of empty space around the graph. Negative values will zoom into the graph. Defaults to 0.
</p>
</td></tr>
<tr><td><code id="plotLinkCommGraph_+3A_vlabel.cex">vlabel.cex</code></td>
<td>

<p>A numerical value specifying the size of node labels. Defaults to 0.8.
</p>
</td></tr>
<tr><td><code id="plotLinkCommGraph_+3A_vlabel.color">vlabel.color</code></td>
<td>

<p>A character string specifying the color of node labels. Defaults to <code>"black"</code>.
</p>
</td></tr>
<tr><td><code id="plotLinkCommGraph_+3A_vlabel.family">vlabel.family</code></td>
<td>

<p>A character string specifying the font family for node labels. Defaults to <code>"Helvetica"</code>.
</p>
</td></tr>
<tr><td><code id="plotLinkCommGraph_+3A_vertex.color">vertex.color</code></td>
<td>

<p>A character string specifying the colour of nodes. If this is a character vector then the colours will be recycled. Defaults to <code>"palegoldenrod"</code>.
</p>
</td></tr>
<tr><td><code id="plotLinkCommGraph_+3A_vlabel">vlabel</code></td>
<td>

<p>Logical, whether node labels are to be added. Defaults to TRUE.
</p>
</td></tr>
<tr><td><code id="plotLinkCommGraph_+3A_col.nonclusters">col.nonclusters</code></td>
<td>

<p>A character string specifying the colour of edges that do not belong to any communities. Will only have an effect if <code>showall</code> is TRUE. Defaults to <code>"black"</code>.
</p>
</td></tr>
<tr><td><code id="plotLinkCommGraph_+3A_jitter">jitter</code></td>
<td>

<p>A numerical value specifying the range (negative to positive) of random noise that will be added to nodes that have identical x-y coordinates. Defaults to 0.2. Only used for Spencer circle layouts.
</p>
</td></tr>
<tr><td><code id="plotLinkCommGraph_+3A_circle">circle</code></td>
<td>

<p>Logical, whether to display a circle for a Spencer circle layout. Defaults to TRUE.
</p>
</td></tr>
<tr><td><code id="plotLinkCommGraph_+3A_printids">printids</code></td>
<td>

<p>Logical, whether to display community IDs at their anchor points around the Spencer circle. Defaults to TRUE.
</p>
</td></tr>
<tr><td><code id="plotLinkCommGraph_+3A_cid.cex">cid.cex</code></td>
<td>

<p>A numerical value specifying the size of community IDs around the Spencer circle. Defaults to 1.
</p>
</td></tr>
<tr><td><code id="plotLinkCommGraph_+3A_shownodesin">shownodesin</code></td>
<td>

<p>An integer value specifying the number of communities a node must belong to before it will be displayed. If 0 then all nodes are displayed. Defaults to 0.
</p>
</td></tr>
<tr><td><code id="plotLinkCommGraph_+3A_showall">showall</code></td>
<td>

<p>Logical, whether to display all links in the network regardless of whether they belong to communities or not. Defaults to FALSE.
</p>
</td></tr>
<tr><td><code id="plotLinkCommGraph_+3A_verbose">verbose</code></td>
<td>

<p>Logical, whether to print the progress of the calculation to the screen. Defaults to TRUE.
</p>
</td></tr>
<tr><td><code id="plotLinkCommGraph_+3A_...">...</code></td>
<td>

<p>Additional arguments to be passed to <code>plot</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Here we describe the parameters for plotting link community graphs using:<br />
<code>plot(x, type = "graph", layout = layout)</code><br /><br />
Various graph layouts are available:
</p>

<ol>
<li> <p><code>"spencer.circle"</code>
</p>
</li>
<li> <p><code>layout.random</code>
</p>
</li>
<li> <p><code>layout.circle</code>
</p>
</li>
<li> <p><code>layout.sphere</code>
</p>
</li>
<li> <p><code>layout.fruchterman.reingold</code>
</p>
</li>
<li> <p><code>layout.kamada.kawai</code>
</p>
</li>
<li> <p><code>layout.spring</code>
</p>
</li>
<li> <p><code>layout.reingold.tilford</code>
</p>
</li>
<li> <p><code>layout.fruchterman.reingold.grid</code>
</p>
</li>
<li> <p><code>layout.lgl</code>
</p>
</li>
<li> <p><code>layout.graphopt</code>
</p>
</li>
<li> <p><code>layout.mds</code>
</p>
</li>
<li> <p><code>layout.svd</code>
</p>
</li>
<li> <p><code>layout.norm</code>
</p>
</li></ol>

<p>All of these, except the <code>"spencer.circle"</code>, are described in more detail in the <code>igraph</code> package. The <code>"spencer.circle"</code> is described in <code><a href="#topic+layout.spencer.circle">layout.spencer.circle</a></code>.
</p>


<h3>Value</h3>

<p>A graph plot.
</p>


<h3>Author(s)</h3>

<p>Alex T. Kalinka <a href="mailto:alex.t.kalinka@gmail.com">alex.t.kalinka@gmail.com</a>
</p>


<h3>References</h3>

<p>Kalinka, A.T. and Tomancak, P. (2011). linkcomm: an R package for the generation, visualization, and analysis of link communities in networks of arbitrary size and type. <em>Bioinformatics</em> <b>27</b>, 2011-2012.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.linkcomm">plot.linkcomm</a></code>, <code><a href="#topic+layout.spencer.circle">layout.spencer.circle</a></code>, <code><a href="#topic+graph.feature">graph.feature</a></code>, <code>igraph.plotting</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate graph and extract link communities.
g &lt;- swiss[,3:4]
lc &lt;- getLinkCommunities(g)

## Plot a graph of link communities.
plot(lc, type = "graph")

## Plot a graph of link communities using a Spencer circle layout.
plot(lc, type = "graph", layout = "spencer.circle")
</code></pre>

<hr>
<h2 id='plotLinkCommMembers'>
Plot a Community Membership Matrix for Link Communities
</h2><span id='topic+plotLinkCommMembers'></span>

<h3>Description</h3>

<p>This function is called by <code>plot.linkcomm</code> to plot a community membership matrix for the link communities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotLinkCommMembers(x, nodes = head(names(x$numclusters), 10), 
        pal = brewer.pal(11, "Spectral"), shape = "rect", total = TRUE, 
        fontsize = 11, nspace = 3.5, maxclusters = 20)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotLinkCommMembers_+3A_x">x</code></td>
<td>

<p>An object of class <code>linkcomm</code>.
</p>
</td></tr>
<tr><td><code id="plotLinkCommMembers_+3A_nodes">nodes</code></td>
<td>

<p>A character vector specifying the node names that will be included in the plot. Defaults to the 10 nodes that belong to the most communities.
</p>
</td></tr>
<tr><td><code id="plotLinkCommMembers_+3A_pal">pal</code></td>
<td>

<p>A character vector describing a colour palette to be used for community-specific colouring. Defaults to <code>brewer.pal(11, "Spectral")</code>.
</p>
</td></tr>
<tr><td><code id="plotLinkCommMembers_+3A_shape">shape</code></td>
<td>

<p>A character string specifying the shape of matrix entries. Can be one of <code>"rect"</code> or <code>"circle"</code>. Defaults to <code>"rect"</code>.
</p>
</td></tr>
<tr><td><code id="plotLinkCommMembers_+3A_total">total</code></td>
<td>

<p>Logical, whether to display the number of communities each node belongs to and the number of nodes in each community. Defaults to TRUE.
</p>
</td></tr>
<tr><td><code id="plotLinkCommMembers_+3A_fontsize">fontsize</code></td>
<td>

<p>A numerical value specifying font size for the node names. Defaults to 11.
</p>
</td></tr>
<tr><td><code id="plotLinkCommMembers_+3A_nspace">nspace</code></td>
<td>

<p>A numerical value specifying how much space to leave at the left for fitting in node names. Defaults to 3.5.
</p>
</td></tr>
<tr><td><code id="plotLinkCommMembers_+3A_maxclusters">maxclusters</code></td>
<td>

<p>An integer value specifying the maximum number of communities to display. Defaults to 20.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A community membership matrix plot.
</p>


<h3>Author(s)</h3>

<p>Alex T. Kalinka <a href="mailto:alex.t.kalinka@gmail.com">alex.t.kalinka@gmail.com</a>
</p>


<h3>References</h3>

<p>Kalinka, A.T. and Tomancak, P. (2011). linkcomm: an R package for the generation, visualization, and analysis of link communities in networks of arbitrary size and type. <em>Bioinformatics</em> <b>27</b>, 2011-2012.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.linkcomm">plot.linkcomm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate graph and extract link communities.
g &lt;- swiss[,3:4]
lc &lt;- getLinkCommunities(g)

## Plot a community membership matrix.
plot(lc, type = "members")
</code></pre>

<hr>
<h2 id='plotLinkCommSumm'>
Plot a Summary of the Link Community Algorithm Output
</h2><span id='topic+plotLinkCommSumm'></span>

<h3>Description</h3>

<p>This function is called by <code>plot.linkcomm</code> to plot a summary of the output of the <code>linkcomm</code> algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotLinkCommSumm(x, col = TRUE, pal = brewer.pal(9, "Set1"), right = TRUE, 
                 droptrivial = TRUE, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotLinkCommSumm_+3A_x">x</code></td>
<td>

<p>An object of class <code>linkcomm</code>.
</p>
</td></tr>
<tr><td><code id="plotLinkCommSumm_+3A_col">col</code></td>
<td>

<p>Logical, whether to colour link communities in the dendrogram. Defaults to TRUE.
</p>
</td></tr>
<tr><td><code id="plotLinkCommSumm_+3A_pal">pal</code></td>
<td>

<p>A character vector describing a colour palette to be used for colouring the link community dendrogram. Defaults to <code>brewer.pal(9, "Set1")</code>.
</p>
</td></tr>
<tr><td><code id="plotLinkCommSumm_+3A_right">right</code></td>
<td>

<p>Logical, whether to orient the dendrogram to the right. Defaults to TRUE.
</p>
</td></tr>
<tr><td><code id="plotLinkCommSumm_+3A_droptrivial">droptrivial</code></td>
<td>

<p>Logical, whether to not colour communities of size 2. Defaults to TRUE.
</p>
</td></tr>
<tr><td><code id="plotLinkCommSumm_+3A_...">...</code></td>
<td>

<p>Additional arguments to be passed to <code>plot</code>.
</p>
</td></tr>
<tr><td><code id="plotLinkCommSumm_+3A_verbose">verbose</code></td>
<td>

<p>Logical, whether to display the progress of colouring the dendrogram on the screen. Defaults to TRUE.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Here we describe the parameters for plotting link community summaries using:<br />
<code>plot(x, type = "summary")</code>
</p>


<h3>Value</h3>

<p>A summary plot of the output from the <code>linkcomm</code> algorithm.
</p>


<h3>Author(s)</h3>

<p>Alex T. Kalinka <a href="mailto:alex.t.kalinka@gmail.com">alex.t.kalinka@gmail.com</a>
</p>


<h3>References</h3>

<p>Kalinka, A.T. and Tomancak, P. (2011). linkcomm: an R package for the generation, visualization, and analysis of link communities in networks of arbitrary size and type. <em>Bioinformatics</em> <b>27</b>, 2011-2012.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.linkcomm">plot.linkcomm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate graph and extract link communities.
g &lt;- swiss[,3:4]
lc &lt;- getLinkCommunities(g)

## Plot the modularity of the link communities.
plot(lc, type = "summary")
</code></pre>

<hr>
<h2 id='plotLinkCommSummComm'>
Plot a Summary of the Link Communities
</h2><span id='topic+plotLinkCommSummComm'></span>

<h3>Description</h3>

<p>This function is called by <code>plot.linkcomm</code> to plot either connectedness or modularity of individual link communities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotLinkCommSummComm(x, clusterids = 1:x$numbers[3], summary = "conn", 
        pie = FALSE, col = TRUE, pal = brewer.pal(11, "Spectral"), 
        random = FALSE, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotLinkCommSummComm_+3A_x">x</code></td>
<td>

<p>An object of class <code>linkcomm</code>.
</p>
</td></tr>
<tr><td><code id="plotLinkCommSummComm_+3A_clusterids">clusterids</code></td>
<td>

<p>An integer vector of community IDs. Defaults to all communities.
</p>
</td></tr>
<tr><td><code id="plotLinkCommSummComm_+3A_summary">summary</code></td>
<td>

<p>A character string specifying the community summary. Can be one of <code>"conn"</code>, <code>"mod"</code>, <code>"ld"</code> for connectedness, modularity, and link densities respectively. Defaults to <code>"conn"</code>.
</p>
</td></tr>
<tr><td><code id="plotLinkCommSummComm_+3A_pie">pie</code></td>
<td>

<p>Logical, whether to plot a pie graph. If FALSE, a bar plot is plotted. Defaults to FALSE.
</p>
</td></tr>
<tr><td><code id="plotLinkCommSummComm_+3A_col">col</code></td>
<td>

<p>Logical, whether to colour each community differently. Defaults to TRUE.
</p>
</td></tr>
<tr><td><code id="plotLinkCommSummComm_+3A_pal">pal</code></td>
<td>

<p>A character vector describing a colour palette to be used for colouring the link communities. Defaults to <code>brewer.pal(11, "Spectral")</code>.
</p>
</td></tr>
<tr><td><code id="plotLinkCommSummComm_+3A_random">random</code></td>
<td>

<p>Logical, whether to randomise the link colours. Defaults to FALSE.
</p>
</td></tr>
<tr><td><code id="plotLinkCommSummComm_+3A_verbose">verbose</code></td>
<td>

<p>Logical, whether to print the progress of the calculation to the screen. Defaults to TRUE.
</p>
</td></tr>
<tr><td><code id="plotLinkCommSummComm_+3A_...">...</code></td>
<td>

<p>Additional arguments to be passed to <code>plot</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Here we describe the parameters for plotting link community summaries using:<br />
<code>plot(x, type = "commsumm", type = "mod")</code>
</p>


<h3>Value</h3>

<p>A bar graph or pie chart.
</p>


<h3>Author(s)</h3>

<p>Alex T. Kalinka <a href="mailto:alex.t.kalinka@gmail.com">alex.t.kalinka@gmail.com</a>
</p>


<h3>References</h3>

<p>Kalinka, A.T. and Tomancak, P. (2011). linkcomm: an R package for the generation, visualization, and analysis of link communities in networks of arbitrary size and type. <em>Bioinformatics</em> <b>27</b>, 2011-2012.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.linkcomm">plot.linkcomm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate graph and extract link communities.
g &lt;- swiss[,3:4]
lc &lt;- getLinkCommunities(g)


## Plot the modularity of the link communities.
plot(lc, type = "commsumm", summary = "mod")
</code></pre>

<hr>
<h2 id='plotOCGraph'>
Plot a Graph Layout of OCG Communities
</h2><span id='topic+plotOCGraph'></span>

<h3>Description</h3>

<p>This function is called by <code>plot.OCG</code> to plot a graph layout of the OCG communities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotOCGraph(x, clusterids = 1:x$numbers[3], nodes = NULL, pie.local = TRUE, 
        incident = TRUE, layout = layout.fruchterman.reingold, 
        vertex.radius = 0.03, scale.vertices = 0.05, edge.color = "grey",
        vertex.label.color = "black", vertex.label.cex = 0.8,
        pal = brewer.pal(7,"Set2"), shownodesin = 0, vlabel = TRUE, 
        random = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotOCGraph_+3A_x">x</code></td>
<td>

<p>An object of class <code>OCG</code>.
</p>
</td></tr>
<tr><td><code id="plotOCGraph_+3A_clusterids">clusterids</code></td>
<td>

<p>An integer vector of community IDs. Defaults to all communities.
</p>
</td></tr>
<tr><td><code id="plotOCGraph_+3A_nodes">nodes</code></td>
<td>

<p>A character vector naming the nodes to be plotted. If NULL, then community IDs are used instead. Defaults to NULL.
</p>
</td></tr>
<tr><td><code id="plotOCGraph_+3A_pie.local">pie.local</code></td>
<td>

<p>Logical, whether to include pie segments for just the communities to which the chosen nodes belong, or for all communities. In the latter case, communities that are not present among the chosen nodes will appear as empty segments in the node pies. Defaults to TRUE.
</p>
</td></tr>
<tr><td><code id="plotOCGraph_+3A_incident">incident</code></td>
<td>

<p>Logical, whether to include just the communities of the named node(s), or the community membership of all nodes that interact with the named node(s). Defaults to TRUE.
</p>
</td></tr>
<tr><td><code id="plotOCGraph_+3A_layout">layout</code></td>
<td>

<p>A character string or function identifying the layout algorithm to be used for positioning nodes in the graph. Defaults to <code>layout.fruchterman.reingold</code>. See details for alternative layouts.
</p>
</td></tr>
<tr><td><code id="plotOCGraph_+3A_vertex.radius">vertex.radius</code></td>
<td>

<p>A real number specifying the vertex radius. Defaults to 0.03.
</p>
</td></tr>
<tr><td><code id="plotOCGraph_+3A_scale.vertices">scale.vertices</code></td>
<td>

<p>A real number specifying the fraction of increase in vertex radius for each community membership. If NULL then all vertices are the same size. Defaults to 0.05.
</p>
</td></tr>
<tr><td><code id="plotOCGraph_+3A_edge.color">edge.color</code></td>
<td>

<p>A character string specifying the colour of edges. Defaults to <code>"grey"</code>.
</p>
</td></tr>
<tr><td><code id="plotOCGraph_+3A_vertex.label.color">vertex.label.color</code></td>
<td>

<p>A character string specifying the color of node labels. Defaults to <code>"black"</code>.
</p>
</td></tr>
<tr><td><code id="plotOCGraph_+3A_vertex.label.cex">vertex.label.cex</code></td>
<td>

<p>A numerical value specifying the size of the node labels. Defaults to 0.8.
</p>
</td></tr>
<tr><td><code id="plotOCGraph_+3A_pal">pal</code></td>
<td>

<p>A character vector describing a colour palette to be used for colouring the link communities in the graph. Defaults to <code>brewer.pal(7, "Set2")</code>.
</p>
</td></tr>
<tr><td><code id="plotOCGraph_+3A_shownodesin">shownodesin</code></td>
<td>

<p>An integer value specifying the number of communities a node must belong to before it will be displayed. If 0 then all nodes are displayed. Defaults to 0.
</p>
</td></tr>
<tr><td><code id="plotOCGraph_+3A_vlabel">vlabel</code></td>
<td>

<p>Logical, whether node labels are to be added. Defaults to TRUE.
</p>
</td></tr>
<tr><td><code id="plotOCGraph_+3A_random">random</code></td>
<td>

<p>Logical, whether to randomise the link colours. Defaults to TRUE.
</p>
</td></tr>
<tr><td><code id="plotOCGraph_+3A_...">...</code></td>
<td>

<p>Additional arguments to be passed to <code>plot</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Here we describe the parameters for plotting OCG community graphs using:<br />
<code>plot(x, type = "graph", layout = layout)</code><br /><br />
Various graph layouts are available:
</p>

<ol>
<li> <p><code>layout.random</code>
</p>
</li>
<li> <p><code>layout.circle</code>
</p>
</li>
<li> <p><code>layout.sphere</code>
</p>
</li>
<li> <p><code>layout.fruchterman.reingold</code>
</p>
</li>
<li> <p><code>layout.kamada.kawai</code>
</p>
</li>
<li> <p><code>layout.spring</code>
</p>
</li>
<li> <p><code>layout.reingold.tilford</code>
</p>
</li>
<li> <p><code>layout.fruchterman.reingold.grid</code>
</p>
</li>
<li> <p><code>layout.lgl</code>
</p>
</li>
<li> <p><code>layout.graphopt</code>
</p>
</li>
<li> <p><code>layout.mds</code>
</p>
</li>
<li> <p><code>layout.svd</code>
</p>
</li>
<li> <p><code>layout.norm</code>
</p>
</li></ol>

<p>All of these are described in more detail in the <code>igraph</code> package.
</p>


<h3>Value</h3>

<p>A graph plot.
</p>


<h3>Author(s)</h3>

<p>Alex T. Kalinka <a href="mailto:alex.t.kalinka@gmail.com">alex.t.kalinka@gmail.com</a>
</p>


<h3>References</h3>

<p>Kalinka, A.T. and Tomancak, P. (2011). linkcomm: an R package for the generation, visualization, and analysis of link communities in networks of arbitrary size and type. <em>Bioinformatics</em> <b>27</b>, 2011-2012.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.OCG">plot.OCG</a></code>, <code>igraph.plotting</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate graph and extract OCG communities.
g &lt;- swiss[,3:4]
oc &lt;- getOCG.clusters(g)

## Plot a graph of OCG communities.
plot(oc, type = "graph")
</code></pre>

<hr>
<h2 id='pp_rnapol'>Sample Yeast Protein Interactome</h2><span id='topic+pp_rnapol'></span>

<h3>Description</h3>

<p>A set of 56 yeast proteins involved in 651 interactions related to transcription (Yu et al. 2008).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pp_rnapol
</code></pre>


<h3>Format</h3>

<p>Data frame with 2 columns.</p>


<h3>Source</h3>

<p><a href="http://interactome.dfci.harvard.edu">http://interactome.dfci.harvard.edu</a></p>


<h3>References</h3>

<p>Yu, H., <em>et al</em>. (2008). High-quality binary protein interaction map of the yeast interactome network. <em>Science</em> <b>322</b>, 104-110.
</p>

<hr>
<h2 id='print.linkcomm'>
Print a Summary of a <code>linkcomm</code> Object
</h2><span id='topic+print.linkcomm'></span>

<h3>Description</h3>

<p>This function prints summary statistics for a <code>linkcomm</code> object to the screen.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'linkcomm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.linkcomm_+3A_x">x</code></td>
<td>

<p>An object of class <code>linkcomm</code>.
</p>
</td></tr>
<tr><td><code id="print.linkcomm_+3A_...">...</code></td>
<td>

<p>Further arguments passed to or from other methods.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints summary data to the screen.
</p>


<h3>Author(s)</h3>

<p>Alex T. Kalinka <a href="mailto:alex.t.kalinka@gmail.com">alex.t.kalinka@gmail.com</a>
</p>


<h3>References</h3>

<p>Kalinka, A.T. and Tomancak, P. (2011). linkcomm: an R package for the generation, visualization, and analysis of link communities in networks of arbitrary size and type. <em>Bioinformatics</em> <b>27</b>, 2011-2012.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate graph and extract link communities.
g &lt;- swiss[,3:4]
lc &lt;- getLinkCommunities(g)

## Print summary statistics to the screen.
print(lc)
</code></pre>

<hr>
<h2 id='print.OCG'>
Print a Summary of an <code>OCG</code> Object
</h2><span id='topic+print.OCG'></span>

<h3>Description</h3>

<p>This function prints summary statistics for an <code>OCG</code> object to the screen.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'OCG'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.OCG_+3A_x">x</code></td>
<td>

<p>An object of class <code>OCG</code>.
</p>
</td></tr>
<tr><td><code id="print.OCG_+3A_...">...</code></td>
<td>

<p>Further arguments passed to or from other methods.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints summary data to the screen.
</p>


<h3>Author(s)</h3>

<p>Alex T. Kalinka <a href="mailto:alex.t.kalinka@gmail.com">alex.t.kalinka@gmail.com</a>
</p>


<h3>References</h3>

<p>Kalinka, A.T. and Tomancak, P. (2011). linkcomm: an R package for the generation, visualization, and analysis of link communities in networks of arbitrary size and type. <em>Bioinformatics</em> <b>27</b>, 2011-2012.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate graph and extract OCG communities.
g &lt;- swiss[,3:4]
oc &lt;- getOCG.clusters(g)

## Print summary statistics to the screen.
print(oc)
</code></pre>

<hr>
<h2 id='read.OCG'>
Read an OCG Partition File into R
</h2><span id='topic+read.OCG'></span>

<h3>Description</h3>

<p>This function reads in an OCG partition file and converts it into an OCG object for use in R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.OCG(file, elfile = NULL, verbose = FALSE, keep.out = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.OCG_+3A_file">file</code></td>
<td>

<p>A character string naming the OCG partition file.
</p>
</td></tr>
<tr><td><code id="read.OCG_+3A_elfile">elfile</code></td>
<td>

<p>A character string naming the file containing the network that the OCG partition is based upon.
</p>
</td></tr>
<tr><td><code id="read.OCG_+3A_verbose">verbose</code></td>
<td>

<p>Logical, whether to print progress to the screen. Defaults to FALSE.
</p>
</td></tr>
<tr><td><code id="read.OCG_+3A_keep.out">keep.out</code></td>
<td>

<p>Logical, whether to keep the intermediate files written when reading in the OCG partition. Defaults to FALSE.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>OCG</code>, which is a list containing the following elements:
</p>
<table role = "presentation">
<tr><td><code>numbers</code></td>
<td>
<p>An integer vector with the number of edges, nodes, and communities.</p>
</td></tr>
<tr><td><code>modularity</code></td>
<td>
<p>An integer number specifying the modularity of the network.</p>
</td></tr>
<tr><td><code>Q</code></td>
<td>
<p>A real number specifying the value of Q generated by the OCG algorithm.</p>
</td></tr>
<tr><td><code>nodeclusters</code></td>
<td>
<p>A data frame consisting of 2 columns; the first contains node names, and the second contains single community IDs for each node. All communities and their nodes are represented, but not necessarily all nodes.</p>
</td></tr>
<tr><td><code>numclusters</code></td>
<td>
<p>A named integer vector. Names are node names and integer values are the number of communities to which each node belongs.</p>
</td></tr>
<tr><td><code>igraph</code></td>
<td>
<p>An object of class <code>igraph</code>. The network is represented here as an <code>igraph</code> object.</p>
</td></tr>
<tr><td><code>edgelist</code></td>
<td>
<p>A character matrix with 2 columns containing the nodes that interact with each other.</p>
</td></tr>
<tr><td><code>clustsizes</code></td>
<td>
<p>A named integer vector. Names are community IDs and integer values indicate the number of nodes that belong in each community.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alex T. Kalinka <a href="mailto:alex.t.kalinka@gmail.com">alex.t.kalinka@gmail.com</a>
</p>


<h3>References</h3>

<p>Kalinka, A.T. and Tomancak, P. (2011). linkcomm: an R package for the generation, visualization, and analysis of link communities in networks of arbitrary size and type. <em>Bioinformatics</em> <b>27</b>, 2011-2012.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Read an OCG partition file into R.
## Not run: oc &lt;- read.OCG(file = "OCG_partition.txt", elfile = "network.txt")
</code></pre>

<hr>
<h2 id='weighted'>Sample Gene Co-Expression Network</h2><span id='topic+weighted'></span>

<h3>Description</h3>

<p>A sample of 200 links from a Drosophila gene co-expression network illustrating the input required for a weighted network (Tomancak et al. 2007).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted
</code></pre>


<h3>Format</h3>

<p>Data frame with 3 columns.</p>


<h3>Source</h3>

<p><a href="http://www.fruitfly.org/cgi-bin/ex/insitu.pl">http://www.fruitfly.org/cgi-bin/ex/insitu.pl</a></p>


<h3>References</h3>

<p>Tomancak, P. <em>et al</em>. (2007). Global analysis of patterns of gene expression during <em>Drosophila</em> embryogenesis. <em>Genome Biol</em> <b>8</b>, 145.1-145.34.
</p>

<hr>
<h2 id='which.communities'>
Extract Community Membership for Nodes
</h2><span id='topic+which.communities'></span>

<h3>Description</h3>

<p>This function returns the community IDs of the communities to which one or more nodes belong.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>which.communities(x, nodes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="which.communities_+3A_x">x</code></td>
<td>

<p>An object of class <code>linkcomm</code> or <code>OCG</code>.
</p>
</td></tr>
<tr><td><code id="which.communities_+3A_nodes">nodes</code></td>
<td>

<p>A character vector specifying the nodes.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector of community IDs.
</p>


<h3>Author(s)</h3>

<p>Alex T. Kalinka <a href="mailto:alex.t.kalinka@gmail.com">alex.t.kalinka@gmail.com</a>
</p>


<h3>References</h3>

<p>Kalinka, A.T. and Tomancak, P. (2011). linkcomm: an R package for the generation, visualization, and analysis of link communities in networks of arbitrary size and type. <em>Bioinformatics</em> <b>27</b>, 2011-2012.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate graph and extract OCG communities.
g &lt;- swiss[,3:4]
oc &lt;- getOCG.clusters(g)

## Get edges from community 1.
which.communities(oc, nodes = 1)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
