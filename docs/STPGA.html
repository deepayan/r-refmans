<!DOCTYPE html><html lang="en"><head><title>Help for package STPGA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {STPGA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#STPGA-package'><p>Selection of Training Populations by Genetic Algorithm</p></a></li>
<li><a href='#Amat.pieces'><p>Amat.pieces</p></a></li>
<li><a href='#CRITERIA'><p>Optimality Criteria</p></a></li>
<li><a href='#disttoideal'><p>Calculate the distance of solutions from the 'ideal' solution.</p></a></li>
<li><a href='#GenAlgForSubsetSelection'><p>Genetic algorithm for subset selection</p></a></li>
<li><a href='#GenAlgForSubsetSelectionMO'><p>Genetic algorithm for subset selection no given test with multiple criteria for Multi Objective Optimized Experimantal Design.</p></a></li>
<li><a href='#GenAlgForSubsetSelectionMONoTest'><p>Genetic algorithm for subset selection no given test with multiple criteria for Multi Objective Optimized Experimental Design.</p></a></li>
<li><a href='#GenAlgForSubsetSelectionNoTest'><p>Genetic algorithm for subset selection no given test</p></a></li>
<li><a href='#GenerateCrossesfromElites'><p>Generate crosses from elites</p></a></li>
<li><a href='#makeonecross'><p>Make a cross from two solutions and mutate.</p></a></li>
<li><a href='#WheatData'><p>Adult plant height (estimated genetic values) for 1182 elite wheat lines</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Selection of Training Populations by Genetic Algorithm</td>
</tr>
<tr>
<td>Version:</td>
<td>5.2.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-11-21</td>
</tr>
<tr>
<td>Author:</td>
<td>Deniz Akdemir</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Deniz Akdemir &lt;deniz.akdemir.work@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Combining Predictive Analytics and Experimental Design to Optimize Results. To be utilized to select a test data calibrated training population in high dimensional prediction problems and assumes that the explanatory variables are observed for all of the individuals. Once a "good" training set is identified, the response variable can be obtained only for this set to build a model for predicting the response in the test set. The algorithms in the package can be tweaked to solve some other subset selection problems. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), AlgDesign, scales, scatterplot3d, emoa, grDevices</td>
</tr>
<tr>
<td>Suggests:</td>
<td>R.rsp, EMMREML, quadprog, UsingR, glmnet, leaps, Matrix</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-11-24 16:30:53 UTC; denizakdemir</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-11-24 17:20:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='STPGA-package'>Selection of Training Populations by Genetic Algorithm</h2><span id='topic+STPGA-package'></span><span id='topic+STPGA'></span>

<h3>Description</h3>

<p>This package can be utilized to select a (test data) calibrated training population in high dimensional prediction problems. More specifically, the package contains a genetic algorithm that tries to minimize a design criterion defined for subsets of a certain size selected from a larger set. 
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> STPGA</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 5.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2018-07-20</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The package is  useful for high dimensional prediction problems where per individual cost of observing / analyzing the response variable is high and therefore a small number of training examples is sought or when the candidate set from which the training set must be chosen (is not representative of the test data set). 
</p>
<p>The function &quot;GenAlgForSubsetSelection&quot; uses a simple genetic algorithm to identify a training set of a specified size from a larger set of candidates which minimizes an optimization criterion for a known test set. The function &quot;GenAlgForSubsetSelectionNoTest&quot; tries to identify a training set of a specified size from a larger set of candidates which minimizes an optimization criterion.
</p>


<h3>Author(s)</h3>

<p>Maintainer: Deniz Akdemir &lt;deniz.akdemir.work@gmail.com&gt;
</p>


<h3>References</h3>

<p>References: 
Akdemir, Deniz. &quot;Training population selection for (breeding value) prediction.&quot; arXiv preprint arXiv:1401.7953 (2014).
</p>

<hr>
<h2 id='Amat.pieces'>Amat.pieces</h2><span id='topic+Amat.pieces'></span>

<h3>Description</h3>

<p>This calculates the genomic relationship matrix using the formula in VanRaden (2008)</p>


<h3>Usage</h3>

<pre><code class='language-R'>Amat.pieces(M, pieces=10, mc.cores=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Amat.pieces_+3A_m">M</code></td>
<td>
<p>The matrix of markers rows rorresponding to individuals and columns for markers, the markers scores are coded as -1,0,1 (corresponding to allele counts 0,1,2).</p>
</td></tr>
<tr><td><code id="Amat.pieces_+3A_pieces">pieces</code></td>
<td>
<p>number of chunks to split the markers</p>
</td></tr>
<tr><td><code id="Amat.pieces_+3A_mc.cores">mc.cores</code></td>
<td>
<p>number of cores to use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a genomic relationship matrix.
</p>


<h3>Author(s)</h3>

<p>Deniz Akdemir</p>


<h3>References</h3>

<p>VanRaden, Paul M. &rdquo;Efficient methods to compute genomic predictions.&rdquo; Journal of dairy science 91.11 (2008): 4414-4423.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N=50
nmarkers=500
Markers&lt;-c()
for (i in 1:N){
  Markers&lt;-rbind(Markers,sample(-1:1,nmarkers, replace=TRUE))
}

markereffects&lt;-rep(0,nmarkers)
markereffects[sample(1:nmarkers,nmarkers/2)]&lt;-rnorm(nmarkers/2)
Markers[1:5,1:5]

K=Amat.pieces(Markers, pieces=5) 
K[1:5,1:5]

</code></pre>

<hr>
<h2 id='CRITERIA'>Optimality Criteria</h2><span id='topic+AOPT'></span><span id='topic+CDMAX'></span><span id='topic+CDMAX0'></span><span id='topic+CDMAX2'></span><span id='topic+CDMEAN'></span><span id='topic+CDMEAN0'></span><span id='topic+CDMEAN2'></span><span id='topic+CDMEANMM'></span><span id='topic+DOPT'></span><span id='topic+EOPT'></span><span id='topic+GAUSSMEANMM'></span><span id='topic+GOPTPEV'></span><span id='topic+GOPTPEV2'></span><span id='topic+PEVMAX'></span><span id='topic+PEVMAX0'></span><span id='topic+PEVMAX2'></span><span id='topic+PEVMEAN'></span><span id='topic+PEVMEAN0'></span><span id='topic+PEVMEAN2'></span><span id='topic+PEVMEANMM'></span><span id='topic+dist_to_test'></span><span id='topic+dist_to_test2'></span><span id='topic+neg_dist_in_train'></span><span id='topic+neg_dist_in_train2'></span>

<h3>Description</h3>

<p>These are some default design criteria to be minimized. There is a table in the details section that gives the formula for each design criterion and describes their usage. Note that the inputs for these functions come in 3 syntax flavors, namely Type-X, Type-D and Type-K. Users can define and use their owm design criteria as long as it has the Type-X syntax as shown with the examples.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AOPT(Train, Test, P, lambda = 1e-05, C=NULL)
CDMAX(Train, Test, P, lambda = 1e-05, C=NULL)
CDMAX0(Train, Test, P, lambda = 1e-05, C=NULL)
CDMAX2(Train, Test, P, lambda = 1e-05, C=NULL)
CDMEAN(Train, Test, P, lambda = 1e-05, C=NULL)
CDMEAN0(Train, Test, P, lambda = 1e-05, C=NULL)
CDMEAN2(Train, Test, P, lambda = 1e-05, C=NULL)
CDMEANMM(Train, Test, Kinv,K, lambda = 1e-05, C=NULL, Vg=NULL, Ve=NULL)
DOPT(Train, Test, P, lambda = 1e-05, C=NULL)
EOPT(Train, Test, P, lambda = 1e-05, C=NULL)
GAUSSMEANMM(Train, Test, Kinv, K, lambda = 1e-05, C=NULL, Vg=NULL, Ve=NULL)
GOPTPEV(Train, Test, P, lambda = 1e-05, C=NULL)
GOPTPEV2(Train, Test, P, lambda = 1e-05, C=NULL)
PEVMAX(Train, Test, P, lambda = 1e-05, C=NULL)
PEVMAX0(Train, Test, P, lambda = 1e-05, C=NULL)
PEVMAX2(Train, Test, P, lambda = 1e-05, C=NULL)
PEVMEAN(Train, Test, P, lambda = 1e-05, C=NULL)
PEVMEAN0(Train, Test, P, lambda = 1e-05, C=NULL)
PEVMEAN2(Train, Test, P, lambda = 1e-05, C=NULL)
PEVMEANMM(Train, Test, Kinv,K, lambda = 1e-05, C=NULL, Vg=NULL, Ve=NULL)
dist_to_test(Train, Test, Dst, lambda, C)
dist_to_test2(Train, Test, Dst, lambda, C)
neg_dist_in_train(Train, Test, Dst, lambda, C)
neg_dist_in_train2(Train, Test, Dst, lambda, C)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CRITERIA_+3A_train">Train</code></td>
<td>

<p>vector of identifiers for individuals in the training set
</p>
</td></tr>
<tr><td><code id="CRITERIA_+3A_test">Test</code></td>
<td>

<p>vector of identifiers for individuals in the test set
</p>
</td></tr>
<tr><td><code id="CRITERIA_+3A_p">P</code></td>
<td>
<p> (Only for Type-X)
<code class="reqn">n \times k</code> matrix of the first PCs of the predictor variables. The matrix needs to have union of the identifiers of the candidate and test individuals as rownames.
</p>
</td></tr>
<tr><td><code id="CRITERIA_+3A_dst">Dst</code></td>
<td>
<p> (Only for Type-D)
<code class="reqn">n \times n</code> symmetric distance matrix with row and column names.
</p>
</td></tr>
<tr><td><code id="CRITERIA_+3A_kinv">Kinv</code></td>
<td>
<p> (Only for Type-K)
<code class="reqn">n \times n</code> symmetric matrix (inverse of the relationship matrix K  between n individuals) with row and column names.
</p>
</td></tr>
<tr><td><code id="CRITERIA_+3A_k">K</code></td>
<td>
<p> (Only for Type-K)
<code class="reqn">n \times n</code> symmetric matrix (the relationship matrix K  between n individuals).
</p>
</td></tr>
<tr><td><code id="CRITERIA_+3A_lambda">lambda</code></td>
<td>

<p>scalar shrinkage parameter (<code class="reqn">\lambda&gt;0</code>).
</p>
</td></tr>
<tr><td><code id="CRITERIA_+3A_c">C</code></td>
<td>

<p>Contrast Matrix.
</p>
</td></tr>
<tr><td><code id="CRITERIA_+3A_vg">Vg</code></td>
<td>
<p> (Only for PEVMEANMM)
covariance matrix between traits generated by the relationship K (multi-trait version).
</p>
</td></tr>
<tr><td><code id="CRITERIA_+3A_ve">Ve</code></td>
<td>
<p> (Only for PEVMEANMM)
residual covariance matrix for the traits (multi-trait version). 
</p>
</td></tr>
</table>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
  <strong>criterion name</strong></td><td style="text-align: left;"> <strong>formula</strong> </td><td style="text-align: left;"> <strong>Type</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
 

   AOPT </td><td style="text-align: left;"> <code class="reqn">trace[C(P'_{Train}P_{Train}+lambda*I)^{-1}C']</code> </td><td style="text-align: left;"> X </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;">   </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">

  CDMAX </td><td style="text-align: left;"> <code class="reqn">max[diag(CP_{Test}(P'_{Train}P_{Train}+lambda*I)^{-1}P'_{Test}C')/</code> </td><td style="text-align: left;"> X </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> <code class="reqn">diag(CP_{Test}P'_{Test}C')]</code>   </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">

  CDMAX0 </td><td style="text-align: left;"> <code class="reqn">max[diag(CP_{Train}(P'_{Train}P_{Train}+lambda*I)^{-1}P'_{Train}C')/</code> </td><td style="text-align: left;"> X </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> <code class="reqn">diag(CP_{Train}P'_{Train}C')]</code>   </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   
 CDMAX2 </td><td style="text-align: left;"> <code class="reqn">max[diag(CP_{Test}(P'_{Train}P_{Train}+lambda*I)^{-1}P'_{Train}P_{Train}</code> </td><td style="text-align: left;"> X </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;">  <code class="reqn">(P'_{Train}P_{Train}+lambda*I)^{-1}P'_{Test}C')/diag(CP_{Test}P'_{Test}C')]</code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">

  CDMEAN </td><td style="text-align: left;"> <code class="reqn">mean[diag(CP_{Test}(P'_{Train}P_{Train}+lambda*I)^{-1}P'_{Test}C')/</code> </td><td style="text-align: left;"> X </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> <code class="reqn">diag(CP_{Test}P'_{Test}C')]</code>  </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
    
  CDMEAN0 </td><td style="text-align: left;">  <code class="reqn">mean[diag(CP_{Train}(P'_{Train}P_{Train}+lambda*I)^{-1}P'_{Train}C')/</code> </td><td style="text-align: left;"> X </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> <code class="reqn">diag(CP_{Train}P'_{Train}C')]</code>  </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">

   CDMEAN2 </td><td style="text-align: left;">  <code class="reqn">mean[diag(CP_{Test}(P'_{Train}P_{Train}+lambda*I)^{-1}P'_{Train}P_{Train}</code> </td><td style="text-align: left;"> X </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;">  <code class="reqn">(P'_{Train}P_{Train}+lambda*I)^{-1}P'_{Test}C')/diag(CP_{Test}P'_{Test}C')] </code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">

  CDMEANMM </td><td style="text-align: left;"> <code class="reqn">-mean[diag(CZ_{Test}(K-lambda*(Z_{Train}'MZ_{Train}+\lambda*Kinv)^{-1}Z_{Test}'C')/</code>  </td><td style="text-align: left;"> K </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> <code class="reqn">(diag(CZ_{Test}KZ_{Test}'C'))]</code>   </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">

  DOPT </td><td style="text-align: left;">  <code class="reqn">logdet(C(P'_{Train}P_{Train}+lambda*I))^{-1}C'</code> </td><td style="text-align: left;"> X </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;">   </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">

  EOPT </td><td style="text-align: left;"> <code class="reqn">max(eigenval(C(P'_{Train}P_{Train}+lambda*I))^{-1}C'))</code> </td><td style="text-align: left;"> X </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;">   </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">

   GAUSSMEANMM </td><td style="text-align: left;">   <code class="reqn">-mean(diag(Z_{Test}KZ_{Test}'-</code>  </td><td style="text-align: left;">  K </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> <code class="reqn">Z_{Test}KZ_{Train}'(Z_{Train}KZ_{Train}'+\lambda*I_{ntrain})^{-1}Z_{Train}KZ_{Test}')</code>  </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">

  GOPTPEV </td><td style="text-align: left;"> <code class="reqn">max(eigenval(CP_{Test}(P_{Train}'P_{Train}+\lambda*I_{ntrain})^{-1}P_{Test}'C'))</code> </td><td style="text-align: left;"> X </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;">   </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">

  GOPTPEV2 </td><td style="text-align: left;"> <code class="reqn">mean(eigenval(CP_{Test}(P_{Train}'P_{Train}+\lambda*I_{ntrain})^{-1}P_{Test}'C'))</code> </td><td style="text-align: left;"> X </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;">   </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">

   PEVMAX </td><td style="text-align: left;">   <code class="reqn">max(diag(CP_{Test}(P'_{Train}P_{Train}+lambda*I)^{-1}P'_{Test}C'))</code> </td><td style="text-align: left;"> X </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;">   </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">

  PEVMAX0 </td><td style="text-align: left;">  <code class="reqn">max(diag(CP_{Train}(P'_{Train}P_{Train}+lambda*I)^{-1}P'_{Train}C'))</code> </td><td style="text-align: left;"> X </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;">   </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">

  PEVMAX2 </td><td style="text-align: left;">  <code class="reqn">max[diag(CP_{Test}(P'_{Train}P_{Train}+lambda*I)^{-1}P'_{Train}P_{Train}</code>  </td><td style="text-align: left;"> X </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;">  <code class="reqn">(P'_{Train}P_{Train}+lambda*I)^{-1}P'_{Test}C']</code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">

  PEVMEAN </td><td style="text-align: left;">  <code class="reqn">mean(diag(CP_{Test}(P'_{Train}P_{Train}+lambda*I)^{-1}P'_{Test}C'))</code>  </td><td style="text-align: left;"> X </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;">   </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">


  PEVMEAN0 </td><td style="text-align: left;"> <code class="reqn">mean(diag(CP_{Train}(P'_{Train}P_{Train}+lambda*I)^{-1}P'_{Train}C'))</code> </td><td style="text-align: left;"> X </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;">   </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
  
  PEVMEAN2 </td><td style="text-align: left;"> <code class="reqn">mean[diag(CP_{Test}(P'_{Train}P_{Train}+lambda*I)^{-1}</code> </td><td style="text-align: left;"> X </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;">  <code class="reqn">P'_{Train}P_{Train}(P'_{Train}P_{Train}+lambda*I)^{-1}P'_{Test}C']</code>  </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   
   PEVMEANMM </td><td style="text-align: left;"> <code class="reqn">mean(diag(CZ_{test}(Ztrain'MZtrain+lambda*Kinv)^{-1}Ztest'C')))</code> </td><td style="text-align: left;"> K </td>
</tr>
<tr>
 <td style="text-align: left;">
   dist_to_test </td><td style="text-align: left;"> maximum distance from training set to test set based on Dst  </td><td style="text-align: left;"> D </td>
</tr>
<tr>
 <td style="text-align: left;">
    dist_to_test2 </td><td style="text-align: left;"> mean distance from training set to test set based on Dst  </td><td style="text-align: left;"> D </td>
</tr>
<tr>
 <td style="text-align: left;">
    neg_dist_in_train </td><td style="text-align: left;"> negative of minimum distance between pairs in the training set based on Dst  </td><td style="text-align: left;"> D </td>
</tr>
<tr>
 <td style="text-align: left;">
    neg_dist_in_train2 </td><td style="text-align: left;"> negative of mean distance between distinct pairs in the training set based on Dst  </td><td style="text-align: left;"> D </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;">   </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td>
</tr>

</table>



<h3>Value</h3>

<p>value of the criterion.</p>


<h3>Author(s)</h3>

<p>Deniz Akdemir</p>


<h3>Examples</h3>

<pre><code class='language-R'>	## Not run: 
#Examples to new criterion:
#1- PEVmax
STPGAUSERFUNC&lt;-function(Train,Test, P, lambda=1e-6, C=NULL){
  PTrain&lt;-P[rownames(P)%in%Train,]
  PTest&lt;-P[rownames(P)%in%Test,]
  if (length(Test)==1){PTest=matrix(PTest, nrow=1)}
  if (!is.null(C)){ PTest&lt;-C%*%PTest}
  PEV&lt;-PTest%*%solve(crossprod(PTrain)+lambda*diag(ncol(PTrain)),t(PTrain))
    PEVmax&lt;-max(diag(tcrossprod(PEV)))
  return(PEVmax)
}




######Here is an example of usage
data(iris)
#We will try to estimate petal width from
#variables sepal length and width and petal length.
X&lt;-as.matrix(iris[,1:4])
distX&lt;-as.matrix(dist(X))
rownames(distX)&lt;-colnames(distX)&lt;-rownames(X)&lt;-paste(iris[,5],rep(1:50,3),sep="_" )
#test data 25 iris plants selected at random from the virginica family,
#candidates are the plants in the  setosa and versicolor families.
candidates&lt;-rownames(X)[1:100]
test&lt;-sample(setdiff(rownames(X),candidates), 25)
#want to select 25 examples using the criterion defined in STPGAUSERFUNC
#Increase niterations and npop substantially for better convergence.
ListTrain&lt;-GenAlgForSubsetSelection(P=distX,Candidates=candidates,
Test=test,ntoselect=25,npop=50,
nelite=5, mutprob=.8, niterations=30,
lambda=1e-5, errorstat="STPGAUSERFUNC", plotiters=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='disttoideal'>Calculate the distance of solutions from the 'ideal' solution.</h2><span id='topic+disttoideal'></span>

<h3>Description</h3>

<p>This function calculates the distance of X to the vector of the minimums of columns of X after transforming the variables in X to the interval <code class="reqn">[0,1]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>disttoideal(X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="disttoideal_+3A_x">X</code></td>
<td>

<p>A matrix of the criteria values. One solution each row, columns correspond to the different criteria.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of distances elements corresponding to each row of X</p>


<h3>Author(s)</h3>

<p>Deniz Akdemir</p>

<hr>
<h2 id='GenAlgForSubsetSelection'>Genetic algorithm for subset selection</h2><span id='topic+GenAlgForSubsetSelection'></span>

<h3>Description</h3>

<p>It uses a genetic algorithm to select <code class="reqn">n_{Train}</code> individuals so that optimality criterion is minimum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GenAlgForSubsetSelection(P, Candidates, Test, ntoselect, npop = 100, nelite =
                 5, keepbest = TRUE, tabu = TRUE, tabumemsize = 1, mutprob
                 = 0.8, mutintensity = 1, niterations = 500,
                 minitbefstop = 200, niterreg = 5, lambda = 1e-06,
                 plotiters = FALSE, plottype=1,errorstat = "PEVMEAN2", C = NULL,
                 mc.cores = 1, InitPop = NULL, tolconv = 1e-07, Vg =
                 NULL, Ve = NULL, Fedorov=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GenAlgForSubsetSelection_+3A_p">P</code></td>
<td>

<p>depending on the criterion this is either a numeric data matrix or a symmetric similarity matrix. When it is a data matrix, the union of the identifiers of the candidate (and test) individuals should be put as rownames (and column names in case of a similarity matrix). For methods using the relationships, this is the inverse of the relationship matrix with row and column names as the the identifiers of the candidate (and test) individuals.
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelection_+3A_candidates">Candidates</code></td>
<td>
 
<p>vector of identifiers for the individuals in the candidate set.
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelection_+3A_test">Test</code></td>
<td>

<p>vector of identifiers for the individuals in the test set.
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelection_+3A_ntoselect">ntoselect</code></td>
<td>

<p><code class="reqn">n_{Train}:</code> number of individuals to select in the training set.
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelection_+3A_npop">npop</code></td>
<td>

<p>genetic algorithm parameter, number of solutions at each iteration
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelection_+3A_nelite">nelite</code></td>
<td>

<p>genetic algorithm parameter, number of solutions selected as elite parents which will  generate the next set of solutions. 
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelection_+3A_keepbest">keepbest</code></td>
<td>

<p>genetic algorithm parameter, TRUE or FALSE. If TRUE then the best solution is always kept in the next generation of solutions (elitism). 
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelection_+3A_tabu">tabu</code></td>
<td>

<p>genetic algorithm parameter, TRUE or FALSE. If TRUE then the solutions that are saved in tabu memory will not be retried.</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelection_+3A_tabumemsize">tabumemsize</code></td>
<td>

<p>genetic algorithm parameter, integer&gt;0. Number of generations to hold in tabu memory. 
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelection_+3A_mutprob">mutprob</code></td>
<td>

<p>genetic algorithm parameter, probability of mutation for each generated solution.
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelection_+3A_mutintensity">mutintensity</code></td>
<td>

<p>mean of the poisson variable that is used to decide the number of mutations for each cross. 
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelection_+3A_niterations">niterations</code></td>
<td>

<p>genetic algorithm parameter, number of iterations.  
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelection_+3A_minitbefstop">minitbefstop</code></td>
<td>

<p>genetic algorithm parameter, number of iterations before stopping if no change is observed in criterion value.  
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelection_+3A_niterreg">niterreg</code></td>
<td>

<p>genetic algorithm parameter, number of iterations to use regressions, an integer with minimum value of 1</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelection_+3A_lambda">lambda</code></td>
<td>

<p>scalar shrinkage parameter  (<code class="reqn">\lambda&gt;0</code>).
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelection_+3A_plotiters">plotiters</code></td>
<td>

<p>plot the convergence: TRUE or FALSE. Default is TRUE.
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelection_+3A_plottype">plottype</code></td>
<td>

<p>type of plot, default is 1. possible values 1,2,3.
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelection_+3A_errorstat">errorstat</code></td>
<td>

<p>optimality criterion: One of the optimality criterion. Default is &quot;PEVMEAN&quot;. It is possible to use user defined functions as shown in the examples.
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelection_+3A_mc.cores">mc.cores</code></td>
<td>

<p>number of cores to use.
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelection_+3A_initpop">InitPop</code></td>
<td>

<p>a list of initial solutions
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelection_+3A_tolconv">tolconv</code></td>
<td>

<p>if the algorithm cannot improve the errorstat more than tolconv for the last minitbefstop iterations it will stop.
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelection_+3A_c">C</code></td>
<td>

<p>Contrast Matrix.
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelection_+3A_vg">Vg</code></td>
<td>

<p>covariance matrix between traits generated by the relationship K (only for multi-trait version of PEVMEANMM).
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelection_+3A_ve">Ve</code></td>
<td>

<p>residual covariance matrix for the traits (only for multi-trait version of PEVMEANMM). 
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelection_+3A_fedorov">Fedorov</code></td>
<td>

<p>Whether the Fedorovs exchange algorithm from <code>AlgDesign</code> Package should be used for initial solutions. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of length nelite+1. The first nelite elements of the list are optimized training samples of size <code class="reqn">n_{train}</code> and they are listed in increasing order of the optimization criterion. The last item on the list is a vector that stores the minimum values of the objective function at each iteration. 
</p>


<h3>Note</h3>

<p>The GA does not guarantee convergence to globally optimal solutions and it is highly recommended that the algorithm is replicated to obtain &rdquo;good&rdquo; training samples. 
</p>


<h3>Author(s)</h3>

<p>Deniz Akdemir
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	## Not run: 
####################################
library(EMMREML)
library(STPGA)
data(WheatData)

svdWheat&lt;-svd(Wheat.K, nu=5, nv=5)
PC50WHeat&lt;-Wheat.K%*%svdWheat$v
plot(PC50WHeat[,1],PC50WHeat[,2])
rownames(PC50WHeat)&lt;-rownames(Wheat.K)
DistWheat&lt;-dist(PC50WHeat)
TreeWheat&lt;-hclust(DistWheat)
TreeWheat&lt;-cutree(TreeWheat, k=4)

Test&lt;-rownames(PC50WHeat)[TreeWheat==4]
length(Test)
Candidates&lt;-setdiff(rownames(PC50WHeat), Test)


###instead of using the algorithm directly using a wrapper to 
###implement an for multiple starting points for genetic algorithm.
repeatgenalg&lt;-function(numrepsouter,numrepsinner){
  StartingPopulation2=NULL 
  for (i in 1:numrepsouter){
    print("Rep:")
    print(i)
    StartingPopulation&lt;-lapply(1:numrepsinner, function(x){
    	GenAlgForSubsetSelection(P=PC50WHeat,Candidates=Candidates, 
    	Test=Test, ntoselect=50, InitPop=StartingPopulation2,
 npop=50, nelite=5, mutprob=.5, mutintensity = rpois(1,4),
 niterations=10,minitbefstop=5, tabumemsize = 2,plotiters=TRUE, 
 lambda=1e-9,errorstat="CDMEAN", mc.cores=1)})
    StartingPopulation2&lt;-vector(mode="list", length = numrepsouter*1)
    ij=1
    for (i in 1:numrepsinner){
      for (j in 1:1){
        StartingPopulation2[[ij]]&lt;-StartingPopulation[[i]][[j]]
        ij=ij+1
      }
    }
  }
  ListTrain&lt;-GenAlgForSubsetSelection(P=PC50WHeat,Candidates=Candidates, 
    	Test=Test,ntoselect=50, InitPop=StartingPopulation2,npop=100, 
    	nelite=10, mutprob=.5, mutintensity = 1,niterations=300,
    	minitbefstop=100, tabumemsize = 1,plotiters=T,
    	lambda=1e-9,errorstat="CDMEAN", mc.cores=1)
  return(ListTrain)
}


ListTrain&lt;-repeatgenalg(20, 3)

###test sample
deptestopt&lt;-Wheat.Y[Wheat.Y$id%in%Test,]

##predictions by optimized sample
deptrainopt&lt;-Wheat.Y[(Wheat.Y$id%in%ListTrain[[1]]),]

Ztrain&lt;-model.matrix(~-1+deptrainopt$id)
Ztest&lt;-model.matrix(~-1+deptestopt$id)

modelopt&lt;-emmreml(y=deptrainopt$plant.height,X=matrix(1, nrow=nrow(deptrainopt), ncol=1), 
Z=Ztrain, K=Wheat.K)
predictopt&lt;-Ztest%*%modelopt$uhat

corvecrs&lt;-c()
for (rep in 1:300){
###predictions by a random sample of the same size
  rs&lt;-sample(Candidates, 50)
  
  deptestrs&lt;-Wheat.Y[Wheat.Y$id%in%Test,]
  
  deptrainrs&lt;-Wheat.Y[(Wheat.Y$id%in%rs),]
  
  Ztrain&lt;-model.matrix(~-1+deptrainrs$id)
  Ztest&lt;-model.matrix(~-1+deptestrs$id)
  
  library(EMMREML)
  modelrs&lt;-emmreml(y=deptrainrs$plant.height,X=matrix(1, nrow=nrow(deptrainrs), ncol=1), 
  Z=Ztrain, K=Wheat.K)
  predictrs&lt;-Ztest%*%modelrs$uhat
corvecrs&lt;-c(corvecrs,cor(predictrs, deptestrs$plant.height))

}
mean(corvecrs)
cor(predictopt, deptestopt$plant.height)


plot(PC50WHeat[,1],PC50WHeat[,2], col=rownames(PC50WHeat)%in%ListTrain[[1]]+1,
pch=2*rownames(PC50WHeat)%in%Test+1, xlab="pc1", ylab="pc2")

## End(Not run)


</code></pre>

<hr>
<h2 id='GenAlgForSubsetSelectionMO'>Genetic algorithm for subset selection no given test with multiple criteria for Multi Objective Optimized Experimantal Design.</h2><span id='topic+GenAlgForSubsetSelectionMO'></span>

<h3>Description</h3>

<p>It uses a nondominated selection genetic algorithm to find the solutions on the frontier that optimizes several design criteria at the same time. The test set is taken as the complement of the training individuals. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GenAlgForSubsetSelectionMO(Pcs = NULL, Dist = NULL, Kernel = NULL, Candidates, Test,
                 ntoselect, selectionstats, selectionstatstypes,
                 plotdirections, npopGA = 100, mutprob = 0.8,
                 mutintensity = 1, nitGA = 500, lambda = 1e-06,
                 plotiters = FALSE, mc.cores = 1, InitPop = NULL, C =
                 NULL, axes.labels = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GenAlgForSubsetSelectionMO_+3A_pcs">Pcs</code></td>
<td>

<p>Principal components matrix for the individuals
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelectionMO_+3A_dist">Dist</code></td>
<td>

<p>Distance matrix for the individuals
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelectionMO_+3A_kernel">Kernel</code></td>
<td>

<p>Kernel matrix for the individuals
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelectionMO_+3A_candidates">Candidates</code></td>
<td>
<p>The set of individuals from which the training set is selected.
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelectionMO_+3A_test">Test</code></td>
<td>
<p>The set of individuals for which the predictions based on the model built using the training set are needed. 
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelectionMO_+3A_ntoselect">ntoselect</code></td>
<td>
<p>number of individuals to select in the training set.
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelectionMO_+3A_selectionstats">selectionstats</code></td>
<td>
<p>a vector of design optimization criteria
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelectionMO_+3A_selectionstatstypes">selectionstatstypes</code></td>
<td>
<p>a vector describing the type of optimality criteria used in <code>selectionstats</code>.
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelectionMO_+3A_plotdirections">plotdirections</code></td>
<td>
<p>A vector that is used to change the sign of statistics while plotting. This doesnt effect the optimization.
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelectionMO_+3A_npopga">npopGA</code></td>
<td>

<p>genetic algorithm parameter, number of solutions at each iteration
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelectionMO_+3A_mutprob">mutprob</code></td>
<td>

<p>genetic algorithm parameter, probability of mutation for each generated solution.
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelectionMO_+3A_mutintensity">mutintensity</code></td>
<td>

<p>genetic algorithm parameter, mean of the poisson variable that is used to decide the number of mutations for each cross. 
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelectionMO_+3A_nitga">nitGA</code></td>
<td>

<p>genetic algorithm parameter, number of iterations.  
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelectionMO_+3A_lambda">lambda</code></td>
<td>

<p>scalar shrinkage parameter (<code class="reqn">\lambda&gt;0</code>).
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelectionMO_+3A_plotiters">plotiters</code></td>
<td>

<p>plot the convergence: TRUE or FALSE. Default is TRUE.
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelectionMO_+3A_mc.cores">mc.cores</code></td>
<td>

<p>number of cores to use.
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelectionMO_+3A_initpop">InitPop</code></td>
<td>

<p>a list of initial solutions
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelectionMO_+3A_c">C</code></td>
<td>

<p>Contrast Matrix.
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelectionMO_+3A_axes.labels">axes.labels</code></td>
<td>
<p>Labels for the axes for plotting iterations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of length 2. The first item in the list is the list of solutions found by the algorithm. The second item is a matrix of criteria values for the solutions in the first list. 
</p>


<h3>Author(s)</h3>

<p>Deniz Akdemir
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(STPGA)
library(GenomicMating)

data(WheatData)


Msvd&lt;-svd(scale(Wheat.M, scale=F, center=T), nu=50, nv=50)
Dgeno&lt;-as.matrix(dist(scale(Wheat.M, scale=F, center=T)))^2
P&lt;-Wheat.M%*%Msvd$v
dim(P)
rownames(Dgeno)&lt;-colnames(Dgeno)&lt;-rownames(P)&lt;-rownames(Wheat.M)
test&lt;-sample(rownames(P), 25)
candidates&lt;-setdiff(rownames(P), test)
outnewprog&lt;-GenAlgForSubsetSelectionMO(Pcs=P,Dist=Dgeno,
Candidates=candidates,Test=test,ntoselect=75,
selectionstats=list("DOPT", "neg_dist_in_train2", "dist_to_test2"),
selectionstatstypes=c("Pcs", "Dist", "Dist"),
plotdirections=c(1,1,1),
npopGA=300,  mutprob=1, mutintensity=2,
nitGA=100, plotiters=TRUE, mc.cores=1, InitPop=NULL)

#####Best solution according to ideal solution concept
outnewprog[[1]][[which.min(disttoideal(outnewprog[[2]]))]]

## End(Not run)
</code></pre>

<hr>
<h2 id='GenAlgForSubsetSelectionMONoTest'>Genetic algorithm for subset selection no given test with multiple criteria for Multi Objective Optimized Experimental Design.</h2><span id='topic+GenAlgForSubsetSelectionMONoTest'></span>

<h3>Description</h3>

<p>It uses a nondominated selection genetic algorithm to find the solutions on the frontier that optimizes several design criteria at the same time. The test set is taken as the complement of the training individuals. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GenAlgForSubsetSelectionMONoTest(Pcs = NULL, Dist = NULL, Kernel = NULL, Candidates,
                 ntoselect, selectionstats, selectionstatstypes,
                 plotdirections, npopGA = 100, mutprob = 0.8,
                 mutintensity = 1, nitGA = 500, lambda = 1e-06,
                 plotiters = FALSE, mc.cores = 1, InitPop = NULL, C =
                 NULL, axes.labels = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GenAlgForSubsetSelectionMONoTest_+3A_pcs">Pcs</code></td>
<td>

<p>Principal components matrix for the individuals
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelectionMONoTest_+3A_dist">Dist</code></td>
<td>

<p>Distance matrix for the individuals
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelectionMONoTest_+3A_kernel">Kernel</code></td>
<td>

<p>Kernel matrix for the individuals
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelectionMONoTest_+3A_candidates">Candidates</code></td>
<td>
<p>The set of individuals from which the training set is selected.
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelectionMONoTest_+3A_ntoselect">ntoselect</code></td>
<td>
<p>number of individuals to select in the training set.
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelectionMONoTest_+3A_selectionstats">selectionstats</code></td>
<td>
<p>a vector of design optimization criteria
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelectionMONoTest_+3A_selectionstatstypes">selectionstatstypes</code></td>
<td>
<p>a vector describing the type of optimality criteria used in <code>selectionstats</code>.
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelectionMONoTest_+3A_plotdirections">plotdirections</code></td>
<td>
<p>A vector that is used to change the sign of statistics while plotting. This doesnt effect the optimization.
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelectionMONoTest_+3A_npopga">npopGA</code></td>
<td>

<p>genetic algorithm parameter, number of solutions at each iteration
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelectionMONoTest_+3A_mutprob">mutprob</code></td>
<td>

<p>genetic algorithm parameter, probability of mutation for each generated solution.
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelectionMONoTest_+3A_mutintensity">mutintensity</code></td>
<td>

<p>genetic algorithm parameter, mean of the poisson variable that is used to decide the number of mutations for each cross. 
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelectionMONoTest_+3A_nitga">nitGA</code></td>
<td>

<p>genetic algorithm parameter, number of iterations.  
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelectionMONoTest_+3A_lambda">lambda</code></td>
<td>

<p>scalar shrinkage parameter (<code class="reqn">\lambda&gt;0</code>).
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelectionMONoTest_+3A_plotiters">plotiters</code></td>
<td>

<p>plot the convergence: TRUE or FALSE. Default is TRUE.
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelectionMONoTest_+3A_mc.cores">mc.cores</code></td>
<td>

<p>number of cores to use.
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelectionMONoTest_+3A_initpop">InitPop</code></td>
<td>

<p>a list of initial solutions
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelectionMONoTest_+3A_c">C</code></td>
<td>

<p>Contrast Matrix.
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelectionMONoTest_+3A_axes.labels">axes.labels</code></td>
<td>
<p>Labels for the axes for plotting iterations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of length 2. The first item in the list is the list of solutions found by the algorithm. The second item is a matrix of criteria values for the solutions in the first list. 
</p>


<h3>Author(s)</h3>

<p>Deniz Akdemir
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(STPGA)
library(GenomicMating)

data(WheatData)


Msvd&lt;-svd(scale(Wheat.M, scale=F, center=T), nu=50, nv=50)
Dgeno&lt;-as.matrix(dist(scale(Wheat.M, scale=F, center=T)))^2
P&lt;-Wheat.M%*%Msvd$v
dim(P)
rownames(Dgeno)&lt;-colnames(Dgeno)&lt;-rownames(P)&lt;-rownames(Wheat.M)
test&lt;-sample(rownames(P), 25)
candidates&lt;-setdiff(rownames(P), test)
outnewprog&lt;-GenAlgForSubsetSelectionMONoTest(Pcs=P,Dist=Dgeno,
Candidates=candidates,ntoselect=75, 
selectionstats=list("DOPT", "neg_dist_in_train2", "dist_to_test2"),
selectionstatstypes=c("Pcs", "Dist", "Dist"),
plotdirections=c(1,1,1),npopGA=300,
mutprob=1, mutintensity=2, nitGA=100,
plotiters=TRUE, mc.cores=1, InitPop=NULL)

#####Best solution according to ideal solution concept
outnewprog[[1]][[which.min(disttoideal(outnewprog[[2]]))]]


## End(Not run)
</code></pre>

<hr>
<h2 id='GenAlgForSubsetSelectionNoTest'>Genetic algorithm for subset selection no given test</h2><span id='topic+GenAlgForSubsetSelectionNoTest'></span>

<h3>Description</h3>

<p>It uses a genetic algorithm to select <code class="reqn">n_{Train}</code> individuals so that optimality criterion is minimum. The test set is taken as the complement of the training individuals. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GenAlgForSubsetSelectionNoTest(P, ntoselect, npop = 100, nelite = 5, keepbest = TRUE,
tabu = TRUE, tabumemsize = 1, mutprob=.8, mutintensity = 1,
niterations = 500, minitbefstop = 200, niterreg = 5,
lambda = 1e-06, plotiters = FALSE, plottype=1, errorstat =
 "PEVMEAN2", C = NULL, mc.cores = 1, InitPop = NULL,
 tolconv = 1e-07, Vg = NULL, Ve = NULL, Fedorov=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GenAlgForSubsetSelectionNoTest_+3A_p">P</code></td>
<td>

<p>depending on the criterion this is either a numeric data matrix or a symmetric similarity matrix. When it is a data matrix, the union of the identifiers of the candidate individuals should be put as rownames (and column names in case of a similarity matrix). For methods using the relationships, this is the inverse of the relationship matrix with row and column names as the the identifiers of the candidate individuals.
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelectionNoTest_+3A_ntoselect">ntoselect</code></td>
<td>

<p><code class="reqn">n_{Train}:</code> number of individuals to select in the training set.
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelectionNoTest_+3A_npop">npop</code></td>
<td>

<p>genetic algorithm parameter, number of solutions at each iteration
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelectionNoTest_+3A_nelite">nelite</code></td>
<td>

<p>genetic algorithm parameter, number of solutions selected as elite parents which will  generate the next set of solutions. 
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelectionNoTest_+3A_keepbest">keepbest</code></td>
<td>

<p>genetic algorithm parameter, TRUE or FALSE. If TRUE then the best solution is always kept in the next generation of solutions (elitism). 
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelectionNoTest_+3A_tabu">tabu</code></td>
<td>

<p>genetic algorithm parameter, TRUE or FALSE. If TRUE then the solutions that are saved in tabu memory will not be retried.</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelectionNoTest_+3A_tabumemsize">tabumemsize</code></td>
<td>

<p>genetic algorithm parameter, integer&gt;0. Number of generations to hold in tabu memory. 
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelectionNoTest_+3A_mutprob">mutprob</code></td>
<td>

<p>genetic algorithm parameter, probability of mutation for each generated solution.
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelectionNoTest_+3A_mutintensity">mutintensity</code></td>
<td>

<p>mean of the poisson variable that is used to decide the number of mutations for each cross. 
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelectionNoTest_+3A_niterations">niterations</code></td>
<td>

<p>genetic algorithm parameter, number of iterations.  
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelectionNoTest_+3A_minitbefstop">minitbefstop</code></td>
<td>

<p>genetic algorithm parameter, number of iterations before stopping if no change is observed in criterion value.  
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelectionNoTest_+3A_niterreg">niterreg</code></td>
<td>

<p>genetic algorithm parameter, number of iterations to use regressions, an integer with minimum value of 1</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelectionNoTest_+3A_lambda">lambda</code></td>
<td>

<p>scalar shrinkage parameter (<code class="reqn">\lambda&gt;0</code>).
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelectionNoTest_+3A_plotiters">plotiters</code></td>
<td>

<p>plot the convergence: TRUE or FALSE. Default is TRUE.
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelectionNoTest_+3A_plottype">plottype</code></td>
<td>

<p>type of plot, default is 1. possible values 1,2,3.
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelectionNoTest_+3A_errorstat">errorstat</code></td>
<td>

<p>optimality criterion: One of the optimality criterion. Default is &quot;PEVMEAN&quot;. It is possible to use user defined functions as shown in the examples.
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelectionNoTest_+3A_mc.cores">mc.cores</code></td>
<td>

<p>number of cores to use.
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelectionNoTest_+3A_initpop">InitPop</code></td>
<td>

<p>a list of initial solutions
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelectionNoTest_+3A_tolconv">tolconv</code></td>
<td>

<p>if the algorithm cannot improve the errorstat more than tolconv for the last minitbefstop iterations it will stop.
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelectionNoTest_+3A_c">C</code></td>
<td>

<p>Contrast Matrix.
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelectionNoTest_+3A_vg">Vg</code></td>
<td>

<p>covariance matrix between traits generated by the relationship K (only for multi-trait version of PEVMEANMM).
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelectionNoTest_+3A_ve">Ve</code></td>
<td>

<p>residual covariance matrix for the traits (only for multi-trait version of PEVMEANMM). 
</p>
</td></tr>
<tr><td><code id="GenAlgForSubsetSelectionNoTest_+3A_fedorov">Fedorov</code></td>
<td>

<p>Whether the Fedorovs exchange algorithm from <code>AlgDesign</code> Package should be used for initial solutions. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of length nelite+1. The first nelite elements of the list are optimized training samples of size <code class="reqn">n_{train}</code> and they are listed in increasing order of the optimization criterion. The last item on the list is a vector that stores the minimum values of the objective function at each iteration. 
</p>


<h3>Note</h3>

<p>The GA does not guarantee convergence to globally optimal solutions and it is highly recommended that the algorithm is replicated to obtain &rdquo;good&rdquo; training samples.
</p>


<h3>Author(s)</h3>

<p>Deniz Akdemir
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
###################### Example for three level designs for the 
#second order model in two factors with a square design region
X&lt;-matrix(0,nrow=3^2,ncol=5)
ij=0

for (i in -1:1){
  for (j in -1:1){
    ij=ij+1
    X[ij,]&lt;-c(i,j, i^2,j^2, i*j)
    
  }
}
X&lt;-cbind(1,X)
D&lt;-as.matrix(dist(X))
K&lt;-tcrossprod(X)
rownames(K)&lt;-colnames(K)&lt;-rownames(D)&lt;-colnames(D)&lt;-rownames(X)&lt;-paste("x",1:3^2, sep="")
X
library(STPGA)
ListTrain1&lt;-GenAlgForSubsetSelectionNoTest(P=X,ntoselect=4, InitPop=NULL,
             npop=100, nelite=5, mutprob=.5, mutintensity = 1,
             niterations=200,minitbefstop=20, tabu=F,tabumemsize = 0,plotiters=F,
             lambda=1e-9,errorstat="DOPT", mc.cores=1)
                                                 
                                                 
ListTrain2&lt;-GenAlgForSubsetSelectionNoTest(P=solve(K+1e-6*diag(ncol(K))),ntoselect=4, InitPop=NULL,
            npop=100, nelite=5, mutprob=.5, mutintensity = 1,
            niterations=200,minitbefstop=20, tabu=F,tabumemsize = 0,plotiters=F,
            lambda=1,errorstat="CDMEANMM", mc.cores=1)
                                                 
                                                 
  par(mfrow=c(1,2),mar=c(1,1,1,1))
  labelling1&lt;-rownames(X)%in%ListTrain1[[1]]+1
  plot(X[,2], X[,3], col=labelling1, pch=2*labelling1,cex=2*(labelling1-1),
   xlab="", ylab="", main="DOPT", cex.main=.7,xaxt='n',yaxt='n')
    for (i in -1:1){
  abline(v=i, lty=2)
  abline(h=i,lty=2)
    }
    labelling2&lt;-rownames(X)%in%ListTrain2[[1]]+1
  plot(X[,2], X[,3], col=labelling2, pch=2*labelling2,cex=2*(labelling2-1),
   xlab="", ylab="", main="CDMEANMM", cex.main=.7,xaxt='n',yaxt='n')
    for (i in -1:1){
  abline(v=i, lty=2)
  abline(h=i,lty=2)
    }

########################Dopt design three level designs for the second order 
#model in two factors with a square design region

par(mfrow=c(2,2),mar=c(1,1,1,1))
 for (ntoselect in c(5,6,7,8)){
 	ListTrain&lt;-GenAlgForSubsetSelectionNoTest(P=X,ntoselect=ntoselect, InitPop=NULL,
             npop=10, nelite=3, mutprob=.5, mutintensity = 1,
             niterations=200,minitbefstop=200, tabu=F,tabumemsize = 0,plotiters=F,
             lambda=1e-9,errorstat="DOPT", mc.cores=1)
             
  labelling&lt;-rownames(X)%in%ListTrain[[1]]+1
  plot(as.numeric(X[,2]), as.numeric(X[,3]), col=labelling, pch=2*labelling,cex=2*(labelling-1),
   xlab="", ylab="", main="DOPT", cex.main=.7,xaxt='n',yaxt='n')
    for (i in -1:1){
  abline(v=i, lty=2)
  abline(h=i,lty=2)
    }

}

par(mfrow=c(1,1))


## End(Not run)
</code></pre>

<hr>
<h2 id='GenerateCrossesfromElites'>Generate crosses from elites</h2><span id='topic+GenerateCrossesfromElites'></span>

<h3>Description</h3>

<p>Given a list of elite training sets, list of candidates the function makes npop new solutions by using crossover and mutation operators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GenerateCrossesfromElites(Elites, Candidates, npop, mutprob, mc.cores = 1,
                 mutintensity = 1, memoryfortabu = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GenerateCrossesfromElites_+3A_elites">Elites</code></td>
<td>

<p>a list of elite training sets
</p>
</td></tr>
<tr><td><code id="GenerateCrossesfromElites_+3A_candidates">Candidates</code></td>
<td>

<p>a vector of identifiers of the individuals in the candidate set.
</p>
</td></tr>
<tr><td><code id="GenerateCrossesfromElites_+3A_npop">npop</code></td>
<td>

<p>number of training sets to generate.
</p>
</td></tr>
<tr><td><code id="GenerateCrossesfromElites_+3A_mutprob">mutprob</code></td>
<td>

<p>point mutation probability for each individual generated. Only one mutation per solution is allowed.  
</p>
</td></tr>
<tr><td><code id="GenerateCrossesfromElites_+3A_mc.cores">mc.cores</code></td>
<td>

<p>number of cores to use.
</p>
</td></tr>
<tr><td><code id="GenerateCrossesfromElites_+3A_mutintensity">mutintensity</code></td>
<td>

<p>mean of the poisson variable that is used to decide the number of mutations for each cross. 
</p>
</td></tr>
<tr><td><code id="GenerateCrossesfromElites_+3A_memoryfortabu">memoryfortabu</code></td>
<td>

<p>tabu memory</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of npop training sets.
</p>


<h3>Author(s)</h3>

<p>Deniz Akdemir
</p>

<hr>
<h2 id='makeonecross'>Make a cross from two solutions and mutate. </h2><span id='topic+makeonecross'></span>

<h3>Description</h3>

<p>Given two training sets, identifiers for candidates, this function makes a new solution using crossover and one point mutation with probability mutprob. Only one mutation is allowed. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeonecross(x1, x2, Candidates, mutprob, mutintensity=2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeonecross_+3A_x1">x1</code></td>
<td>

<p>a vector of identifiers selected from the candidate set.
</p>
</td></tr>
<tr><td><code id="makeonecross_+3A_x2">x2</code></td>
<td>

<p>a vector of identifiers selected from the candidate set that has the same length as x1.
</p>
</td></tr>
<tr><td><code id="makeonecross_+3A_candidates">Candidates</code></td>
<td>

<p>vector of identifiers for individuals in the candidate set. 
</p>
</td></tr>
<tr><td><code id="makeonecross_+3A_mutprob">mutprob</code></td>
<td>

<p>point mutation probability for each individual generated. Only one mutation per solution is allowed. 
</p>
</td></tr>
<tr><td><code id="makeonecross_+3A_mutintensity">mutintensity</code></td>
<td>

<p>mean of the poisson variable that is used to decide the number of mutations for each cross. 
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Deniz Akdemir
</p>

<hr>
<h2 id='WheatData'>Adult plant height (estimated genetic values) for 1182 elite wheat lines</h2><span id='topic+WheatData'></span><span id='topic+Wheat.Y'></span><span id='topic+Wheat.M'></span><span id='topic+Wheat.K'></span>

<h3>Description</h3>

<p>Containing the phenotypic observations 'Wheat.Y', markers 'Wheat.M' and genetic relationships 'Wheat.K'. The 4670 markers available for these 200 genotypes were pre-porecessed for missingness and minor ellele frequencies, coded numerically as -1, 0, and 1; the relationship genomic relationship matrix was calculated from these markers.</p>


<h3>Source</h3>

<p>This dataset was obtained from <a href="https://triticeaetoolbox.org/">https://triticeaetoolbox.org/</a>.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
