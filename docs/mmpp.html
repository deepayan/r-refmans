<!DOCTYPE html><html lang="en"><head><title>Help for package mmpp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mmpp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#mmpp-package'><p>A package for Computing Similarity and Distance Metrics for Marked Point Process Data</p></a></li>
<li><a href='#coocmetric'><p>Metrics for Point Process Realizations Based on Co-occurrence</p></a></li>
<li><a href='#fmetric'><p>Compute Filter-based Metrics in a Functional Space Between Marked Point Processes</p></a></li>
<li><a href='#ieimetric'><p>Compute Inter Event Interval-based Metric Between Marked Point Processes</p></a></li>
<li><a href='#iipmetric'><p>Compute Intensity Inner Product Metrics</p></a></li>
<li><a href='#k2d'><p>Convert Kernel Matrix to Distance Matrix</p></a></li>
<li><a href='#Miyagi20030626'><p>The aftershock data of 26th July 2003 earthquake of M6.2 at the northern Miyagi-Ken Japan</p></a></li>
<li><a href='#splitMPP'><p>Split MPP Data by Sliding Time Window</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Various Similarity and Distance Metrics for Marked Point
Processes</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2017-09-29</td>
</tr>
<tr>
<td>Author:</td>
<td>Hideitsu Hino, Ken Takano, Yuki Yoshikawa, and Noboru Murata</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hideitsu Hino &lt;hinohide@cs.tsukuba.ac.jp&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Compute similarities and distances between marked point processes.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-09-29 02:15:12 UTC; hino</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-09-29 04:07:37 UTC</td>
</tr>
</table>
<hr>
<h2 id='mmpp-package'>A package for Computing Similarity and Distance Metrics for Marked Point Process Data</h2><span id='topic+mmpp'></span><span id='topic+mmpp-package'></span>

<h3>Description</h3>

<p>This packages is used to calculate various similarity and distance measures for sample sequences of both simple and marked temporal point processes.
</p>


<h3>Details</h3>

<p>A simple temporal point process (SPP) is an important class of time series, where the sample realization of the process is solely composed of the times at which events occur. Particular examples of point process data are neuronal spike patterns or spike trains, and a large number of distance and similarity metrics for those data have been proposed. A marked point process (MPP) is an extension of a simple temporal point process, in which a certain vector valued mark is associated with each of the temporal points in the SPP. Analysis of MPPs are of practical importance because instances of MPPs include recordings of natural disasters such as earthquakes and tornadoes.
This package implements a number of distance and similarity metrics for SPP, and also extends those metrics for dealing with MPP.
It provides a systematic and unified platform for calculating the similarities and distances between SPP, and support marked point process to offer a platform for performing metric-based analysis of earthquakes, tornados, epidemics, or stock exchange data.
</p>
<p>The package has functions <code>coocmetric</code>, <code>fmetric</code>, <code>ieimetric</code>, and <code>iipmetric</code> for calculating similarity or distance between two sample sequences. A sample dataset <code>Miyagi20030626</code> is included in the package. It offers utility two functions: <code>splitMPP</code>, which splits a sample sequence into a list of partial sequences by using a sliding window, and <code>k2d</code>, which transforms a similarity matrix to a distance matrix and vice versa.
</p>


<h3>Author(s)</h3>

<p>Author: Hideitsu Hino <a href="mailto:hinohide@cs.tsukuba.ac.jp">hinohide@cs.tsukuba.ac.jp</a>, Ken Takano, Yuki Yoshikawa, and Noboru Murata
</p>


<h3>References</h3>

<p>R. Quian Quiroga, T. Kreuz, and P. Grassberger. Event synchronization: a simple and fast method to measure synchronicity and time delay patterns, Physical Review E, Vol. 66(4), 041904, 2002.
</p>
<p>J. D. Hunter and G. Milton. Amplitude and frequency dependence of spike timing: implications for dynamic regulation, Journal of Neurophysiology, Vol. 90, pp. 387-94, 2003.
</p>
<p>M. C. W. van Rossum. A Novel Spike Distance. Neural Computation, Vol. 13(4), pp. 751-763, 2001.
</p>
<p>S. Schreiber, J.M. Fellous, P.H. Tiesinga, and T.J. Sejnowski. A new correlation-based measure of spike timing reliability, Neurocomputing, Vols. 52-54, pp. 925-931, 2003.
</p>
<p>T. Kreuz, J.S. Haas, A. Morelli, H.D.I. Abarbanel, and A. Politi. Measuring spike train synchrony, Journal of Neuroscience Methods, Vol. 165(1), pp. 151-161, 2007.
</p>
<p>A.R.C. Paiva, I. Park, and J.C. Principe. A reproducing kernel Hilbert space framework for spike train signal processing, Neural Computation, Vol. 21(2), pp. 424-449, 2009.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## An example to show that the prediction error of the magnitude based on
## 1-nearest neighbor predictor can be reduced by taking marks into account.
## It will take about 5 minutes if you run this example
## Not run: 
library(mmpp)
data(Miyagi20030626)
## split the original MPP by using 3-hour time window
sMiyagi &lt;- splitMPP(Miyagi20030626,h=60*60*3,scaleMarks=TRUE)$S

## target of the prediction is the maximum magnitude in the window
y &lt;- NULL
for(i in 1:length(sMiyagi)){
  y &lt;- c(y, max(sMiyagi[[i]]$magnitude))
}

y &lt;- y[-1]
sMiyagi[[length(sMiyagi)]] &lt;- NULL

## number of whole partial MPPs splitted by a 3-hour time window
N &lt;- length(sMiyagi)
## training samples are past one week data
Ntr &lt;- 24*7/3
## number of different prediction methods
Nd &lt;- 10

err &lt;- matrix(0, N-Ntr, Nd)
colnames(err) &lt;- c("f SPP","iip SPP","cooc smooth SPP","cooc count SPP","iei SPP",
                   "f MPP","iip MPP","cooc smooth MPP","cooc count MPP","iei MPP")

## predict the max magnitude in the next 3-hour based on the similarity
## between the current partial point process and the 7-days past partial point process
cat("running prediction experiment")
for(t in 1:(N-Ntr)){
  cat(".")
  qid &lt;- Ntr+t
  q &lt;- sMiyagi[[qid]]

  ## simple PP
  ## fmetric with tau=1
  sim2query &lt;- NULL
  for(i in 1:Ntr){
    sim2query &lt;- c(sim2query,fmetric(q$time,sMiyagi[[qid-i]]$time))
  }
  err[t,1] &lt;- abs(y[qid]-y[t:(Ntr+t-1)][which.max(sim2query)])

  ## iipmetric with tau=1
  sim2query &lt;- NULL
  for(i in 1:Ntr){
    sim2query &lt;- c(sim2query,iipmetric(q$time,sMiyagi[[qid-i]]$time))
  }
  err[t,2] &lt;- abs(y[qid]-y[t:(Ntr+t-1)][which.max(sim2query)])

  ## coocmetric (smooth) with tau=1
  sim2query &lt;- NULL
  for(i in 1:Ntr){
    sim2query &lt;- c(sim2query,coocmetric(q$time,sMiyagi[[qid-i]]$time,type="smooth"))
  }
  err[t,3] &lt;- abs(y[qid]-y[t:(Ntr+t-1)][which.max(sim2query)])

  ## coocmetric (count)
  sim2query &lt;- NULL
  for(i in 1:Ntr){
    sim2query &lt;- c(sim2query,coocmetric(q$time,sMiyagi[[qid-i]]$time,type="count"))
  }
  err[t,4] &lt;- abs(y[qid]-y[t:(Ntr+t-1)][which.max(sim2query)])

  ## iei metric
  sim2query &lt;- NULL
  for(i in 1:Ntr){
    sim2query &lt;- c(sim2query,ieimetric(q$time,sMiyagi[[qid-i]]$time))
  }
  err[t,5] &lt;- abs(y[qid]-y[t:(Ntr+t-1)][which.max(sim2query)])

  ## marked PP with latitude, longitude, depth, and magnitude
  ## fmetric with tau=1
  sim2query &lt;- NULL
  for(i in 1:Ntr){
    sim2query &lt;- c(sim2query,fmetric(q,sMiyagi[[qid-i]]))
  }
  err[t,6] &lt;- abs(y[qid]-y[t:(Ntr+t-1)][which.max(sim2query)])

  ## iipmetric with tau=1
  sim2query &lt;- NULL
  for(i in 1:Ntr){
    sim2query &lt;- c(sim2query,iipmetric(q,sMiyagi[[qid-i]]))
  }
  err[t,7] &lt;- abs(y[qid]-y[t:(Ntr+t-1)][which.max(sim2query)])

  ## coocmetric (smooth) with tau=1
  sim2query &lt;- NULL
  for(i in 1:Ntr){
    sim2query &lt;- c(sim2query,coocmetric(q,sMiyagi[[qid-i]],type="smooth"))
  }
  err[t,8] &lt;- abs(y[qid]-y[t:(Ntr+t-1)][which.max(sim2query)])

  ## coocmetric (count)
  sim2query &lt;- NULL
  for(i in 1:Ntr){
    sim2query &lt;- c(sim2query,coocmetric(q,sMiyagi[[qid-i]],type="count"))
  }
  err[t,9] &lt;- abs(y[qid]-y[t:(Ntr+t-1)][which.max(sim2query)])

  ## iei metric
  sim2query &lt;- NULL
  for(i in 1:Ntr){
    sim2query &lt;- c(sim2query,ieimetric(q,sMiyagi[[qid-i]]))
  }
  err[t,10] &lt;- abs(y[qid]-y[t:(Ntr+t-1)][which.max(sim2query)])

}
cat("done\n")
print(colMeans(err))
##f SPP      iip SPP     cooc smooth SPP  cooc count SPP  iei SPP
##0.7002634  0.6839529   0.7263602        0.6632930       0.7905148
##f MPP      iip MPP     cooc smooth MPP  cooc count MPP  iei MPP
##0.6839529  0.6317594   0.6643804        0.6622056       0.7698548

## End(Not run)
</code></pre>

<hr>
<h2 id='coocmetric'>Metrics for Point Process Realizations Based on Co-occurrence</h2><span id='topic+coocmetric'></span>

<h3>Description</h3>

<p>For comparing two SPP realizations, it is natural to count the number of events which can be considered to be co-occurring. There are two metrics for SPP realizations based on the notion of co-occurrence.
The first one proposed by Quian Quiroga et al. (2002) directly counts near-by events. The second counting metric co-occurrence is proposed by Hunter and Milton (2003), which is based on a smoothing function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coocmetric(S1, S2, measure = "sim", type = "count", tau = 1, M = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coocmetric_+3A_s1">S1</code></td>
<td>
<p>marked point process data.</p>
</td></tr>
<tr><td><code id="coocmetric_+3A_s2">S2</code></td>
<td>
<p>marked point process data.</p>
</td></tr>
<tr><td><code id="coocmetric_+3A_measure">measure</code></td>
<td>
<p><code>"sim"</code> for similarity and &quot;dist&quot; for distance. Default <code>"sim"</code>.</p>
</td></tr>
<tr><td><code id="coocmetric_+3A_type">type</code></td>
<td>
<p>if <code>"count"</code>, counting near-by event measure by Quian is computed. If <code>"smooth"</code>, smoothed counting co-occurrence measure by Hunter and Milton is computed. Default <code>"count"</code>.</p>
</td></tr>
<tr><td><code id="coocmetric_+3A_tau">tau</code></td>
<td>
<p>a parameter for filtering function.</p>
</td></tr>
<tr><td><code id="coocmetric_+3A_m">M</code></td>
<td>
<p>a precision matrix for filter of marks, i.e., exp( - r' M r) is used for filtering marks. It should be symmetric and positive semi-definite.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>coocmetric</code> computes co-occurrence base metrics for two point process realizations. This function counts the number of events in S1 which is coincided with those in S2, and vice versa.
</p>


<h3>Value</h3>

<p>Similarity or distance between two inputs (marked) point process S1 and S2.
</p>


<h3>Author(s)</h3>

<p>Hideitsu Hino <a href="mailto:hinohide@cs.tsukuba.ac.jp">hinohide@cs.tsukuba.ac.jp</a>, Ken Takano, Yuki Yoshikawa, and Noboru Murata
</p>


<h3>References</h3>

<p>R. Quian Quiroga, T. Kreuz, and P. Grassberger. Event synchronization: a simple and fast method to measure synchronicity and time delay patterns, Physical Review E, Vol. 66(4), 041904, 2002.
</p>
<p>J. D. Hunter and G. Milton. Amplitude and frequency dependence of spike timing: implications for dynamic regulation, Journal of Neurophysiology, Vol. 90, pp. 387-94, 2003.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## The aftershock data of 26th July 2003 earthquake of M6.2 at the northern Miyagi-Ken Japan.
data(Miyagi20030626)
## time longitude latitude depth magnitude
## split events by 7-hour
sMiyagi &lt;- splitMPP(Miyagi20030626,h=60*60*7,scaleMarks=TRUE)$S
N &lt;- 10
sMat &lt;- matrix(0,N,N)
tau&lt;-0.2
  cat("calculating coocmetric(smooth)...")
 for(i in 1:(N)){
   cat(i," ")
   for(j in i:N){
     S1 &lt;- sMiyagi[[i]]$time;S2 &lt;- sMiyagi[[j]]$time
    sMat[i,j] &lt;- coocmetric(S1,S2,type="smooth",tau=tau,M=diag(1,4))
   }
 }
 sMat &lt;- sMat+t(sMat)
 tmpd &lt;- diag(sMat) &lt;- diag(sMat)/2
 sMat &lt;- sMat/sqrt(outer(tmpd,tmpd))
image(sMat)
</code></pre>

<hr>
<h2 id='fmetric'>Compute Filter-based Metrics in a Functional Space Between Marked Point Processes</h2><span id='topic+fmetric'></span>

<h3>Description</h3>

<p>The most commonly used and intensively studied metrics for spike trains, which is based on the continuation of event sequence to a real valued continuous function using a smoother function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmetric(S1, S2, measure = "sim", h = "laplacian", tau = 1, M = NULL,
  abs.tol = .Machine$double.eps^0.25)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fmetric_+3A_s1">S1</code></td>
<td>
<p>marked point process data.</p>
</td></tr>
<tr><td><code id="fmetric_+3A_s2">S2</code></td>
<td>
<p>marked point process data.</p>
</td></tr>
<tr><td><code id="fmetric_+3A_measure">measure</code></td>
<td>
<p><code>"sim"</code> for similarity and <code>"dist"</code> for distance. Default <code>"sim"</code>.</p>
</td></tr>
<tr><td><code id="fmetric_+3A_h">h</code></td>
<td>
<p>filtering function. Default <code>"laplacian"</code> offers significant computational advantage. A function can be specified here like
<code>h=function(x,tau) exp(-x^2/tau)</code>.
The function should be square integrable and non-negative (not checked in the code).</p>
</td></tr>
<tr><td><code id="fmetric_+3A_tau">tau</code></td>
<td>
<p>parameter for filtering function.</p>
</td></tr>
<tr><td><code id="fmetric_+3A_m">M</code></td>
<td>
<p>a precision matrix for filter of marks, i.e., exp( - r' M r) is used for filtering marks. It should be symmetric and positive semi-definite.</p>
</td></tr>
<tr><td><code id="fmetric_+3A_abs.tol">abs.tol</code></td>
<td>
<p>absolute tolerance for numerical integration.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fmetric</code> computes filter-based measure between MPP realizations. Discrete event timings are transformed into a continuous function by using a kernel smoother, and usual l2 inner product is adopted for defining the similarity between two point process realizations.
</p>


<h3>Value</h3>

<p>Similarity or distance between two inputs (marked) point process S1 and S2.
</p>


<h3>Author(s)</h3>

<p>Hideitsu Hino <a href="mailto:hinohide@cs.tsukuba.ac.jp">hinohide@cs.tsukuba.ac.jp</a>, Ken Takano, Yuki Yoshikawa, and Noboru Murata
</p>


<h3>References</h3>

<p>M. C. W. van Rossum. A Novel Spike Distance. Neural Computation, Vol. 13(4), pp. 751-763, 2001.
</p>
<p>S. Schreiber, J.M. Fellous, P.H. Tiesinga, and T.J. Sejnowski. A new correlation-based measure of spike timing reliability, Neurocomputing, Vols. 52-54, pp. 925-931, 2003.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##The aftershock data of 26th July 2003 earthquake of M6.2 at the northern Miyagi-Ken Japan.
data(Miyagi20030626)
## time longitude latitude depth magnitude
## split events by 7-hour
sMiyagi &lt;- splitMPP(Miyagi20030626,h=60*60*7,scaleMarks=TRUE)$S
N &lt;- 10
tau &lt;- 0.1
sMat &lt;- matrix(0,N,N)
  cat("calculating fmetric with tau ",tau,"...")
 for(i in 1:(N)){
   cat(i," ")
   for(j in i:N){
     S1 &lt;- sMiyagi[[i]]$time;S2 &lt;- sMiyagi[[j]]$time
    sMat[i,j] &lt;- fmetric(S1,S2,tau=tau,M=diag(1,4))
   }
 }
 sMat &lt;- sMat+t(sMat)
 tmpd &lt;- diag(sMat) &lt;- diag(sMat)/2
 sMat &lt;- sMat/sqrt(outer(tmpd,tmpd))
image(sMat)
</code></pre>

<hr>
<h2 id='ieimetric'>Compute Inter Event Interval-based Metric Between Marked Point Processes</h2><span id='topic+ieimetric'></span>

<h3>Description</h3>

<p>This metric considers inter event interval for point processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ieimetric(S1, S2, measure = "sim", M = NULL, window.length = NULL,
  variant = "spike", abs.tol = .Machine$double.eps^0.25)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ieimetric_+3A_s1">S1</code></td>
<td>
<p>marked point process data.</p>
</td></tr>
<tr><td><code id="ieimetric_+3A_s2">S2</code></td>
<td>
<p>marked point process data.</p>
</td></tr>
<tr><td><code id="ieimetric_+3A_measure">measure</code></td>
<td>
<p><code>"sim"</code> for similarity and <code>"dist"</code> for distance. Default <code>"sim"</code>.</p>
</td></tr>
<tr><td><code id="ieimetric_+3A_m">M</code></td>
<td>
<p>a precision matrix for filter of marks, i.e., exp( - r' M r) is used for filtering marks. It should be symmetric and positive semi-definite.</p>
</td></tr>
<tr><td><code id="ieimetric_+3A_window.length">window.length</code></td>
<td>
<p>width of the window used for splitting the original MPP.<br />
If not provided, <code>max(max(S1$time,S2$time) - min(S1$time,S2$time))</code> is used.</p>
</td></tr>
<tr><td><code id="ieimetric_+3A_variant">variant</code></td>
<td>
<p>choose from two variants &quot;spike-weighted&quot; or &quot;time-weighted&quot;.<br /> Default <code>"spike"</code>, which is computationally efficient than <code>"time"</code>. See the reference for details.</p>
</td></tr>
<tr><td><code id="ieimetric_+3A_abs.tol">abs.tol</code></td>
<td>
<p>absolute tolerance for numerical integration.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>iei</code> computes inter event interval-based measure between MPP realizations. iei for simple point process does not have any tuning parameter, which can be a desirable property for data analysis. However, it's computational cost is relatively higher than other metrics.
</p>


<h3>Value</h3>

<p>Similarity or distance between two inputs (marked) point process S1 and S2.
</p>


<h3>Author(s)</h3>

<p>Hideitsu Hino <a href="mailto:hinohide@cs.tsukuba.ac.jp">hinohide@cs.tsukuba.ac.jp</a>, Ken Takano, Yuki Yoshikawa, and Noboru Murata
</p>


<h3>References</h3>

<p>T. Kreuz, J.S. Haas, A. Morelli, H.D.I. Abarbanel, and A. Politi. Measuring spike train synchrony, Journal of Neuroscience Methods, Vol. 165(1), pp. 151-161, 2007.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##The aftershock data of 26th July 2003 earthquake of M6.2 at the northern Miyagi-Ken Japan.
data(Miyagi20030626)
## time longitude latitude depth magnitude
## split events by 7-hour
sMiyagi &lt;- splitMPP(Miyagi20030626,h=60*60*7,scaleMarks=TRUE)$S
N &lt;- 5
sMat &lt;- matrix(0,N,N)
  cat("calculating intensity inner product...")
 for(i in 1:(N)){
   cat(i," ")
   for(j in i:N){
     S1 &lt;- sMiyagi[[i]]$time;S2 &lt;- sMiyagi[[j]]$time
    sMat[i,j] &lt;- ieimetric(S1,S2,M=diag(1,4))
   }
 }
 sMat &lt;- sMat+t(sMat)
 tmpd &lt;- diag(sMat) &lt;- diag(sMat)/2
 sMat &lt;- sMat/sqrt(outer(tmpd,tmpd))
image(sMat)
</code></pre>

<hr>
<h2 id='iipmetric'>Compute Intensity Inner Product Metrics</h2><span id='topic+iipmetric'></span>

<h3>Description</h3>

<p>For the analysis of point process, intensity function plays a central roll. Paiva et al. (2009) proposed to use the intensity function for defining the inner product between point process realizations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iipmetric(S1, S2, measure = "sim", tau = 1, M = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iipmetric_+3A_s1">S1</code></td>
<td>
<p>marked point process data.</p>
</td></tr>
<tr><td><code id="iipmetric_+3A_s2">S2</code></td>
<td>
<p>marked point process data.</p>
</td></tr>
<tr><td><code id="iipmetric_+3A_measure">measure</code></td>
<td>
<p><code>"sim"</code> for similarity and <code>"dist"</code> for distance. Default <code>"sim"</code>.</p>
</td></tr>
<tr><td><code id="iipmetric_+3A_tau">tau</code></td>
<td>
<p>a parameter for filtering function.</p>
</td></tr>
<tr><td><code id="iipmetric_+3A_m">M</code></td>
<td>
<p>a precision matrix for filter of marks, i.e., exp( - r' M r) is used for filtering marks. It should be symmetric and positive semi-definite.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>iipmetric</code> computes intensity inner product metric. Intensity function for the point process realization is estimated by kernel density estimator. This function adopts Gaussian kernels for the sake of computational efficiency.
</p>


<h3>Value</h3>

<p>Similarity or distance between two inputs (marked) point process S1 and S2.
</p>


<h3>Author(s)</h3>

<p>Hideitsu Hino <a href="mailto:hinohide@cs.tsukuba.ac.jp">hinohide@cs.tsukuba.ac.jp</a>, Ken Takano, Yuki Yoshikawa, and Noboru Murata
</p>


<h3>References</h3>

<p>A.R.C. Paiva, I. Park, and J.C. Principe. A reproducing kernel Hilbert space framework for spike train signal processing, Neural Computation, Vol. 21(2), pp. 424-449, 2009.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##The aftershock data of 26th July 2003 earthquake of M6.2 at the northern Miyagi-Ken Japan.
data(Miyagi20030626)
## time longitude latitude depth magnitude
## split events by 7-hour
sMiyagi &lt;- splitMPP(Miyagi20030626,h=60*60*7,scaleMarks=TRUE)$S
N &lt;- 10
tau &lt;- 0.1
sMat &lt;- matrix(0,N,N)
  cat("calculating intensity inner product...")
 for(i in 1:(N)){
   cat(i," ")
   for(j in i:N){
     S1 &lt;- sMiyagi[[i]]$time;S2 &lt;- sMiyagi[[j]]$time
    sMat[i,j] &lt;- iipmetric(S1,S2,tau=tau,M=diag(1,4))
   }
 }
 sMat &lt;- sMat+t(sMat)
 tmpd &lt;- diag(sMat) &lt;- diag(sMat)/2
 sMat &lt;- sMat/sqrt(outer(tmpd,tmpd))
image(sMat)
</code></pre>

<hr>
<h2 id='k2d'>Convert Kernel Matrix to Distance Matrix</h2><span id='topic+k2d'></span>

<h3>Description</h3>

<p><code>k2d</code> provides various methods for converting kernel matrix to distance matrix and vice versa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>k2d(Mat, direction = "k2d", method = "norm", scale = 1, pos = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="k2d_+3A_mat">Mat</code></td>
<td>
<p>matrix, either kernel matrix or distance matrix to be converted.</p>
</td></tr>
<tr><td><code id="k2d_+3A_direction">direction</code></td>
<td>
<p>a character string &quot;k2d&quot; or &quot;d2k&quot;. The latter interpret the Mat as a distance matrix and convert it to a kernel matrix. Default &quot;k2d&quot;.</p>
</td></tr>
<tr><td><code id="k2d_+3A_method">method</code></td>
<td>
<p>a character string to specify how the matrix is converted. &quot;Default &quot;norm&quot;.</p>
</td></tr>
<tr><td><code id="k2d_+3A_scale">scale</code></td>
<td>
<p>a numeric parameter used to scale the matrix. Typically used in exp( - d(x,y)/scale).</p>
</td></tr>
<tr><td><code id="k2d_+3A_pos">pos</code></td>
<td>
<p>logical. If <code>TRUE</code> when <code>direction="d2k"</code>, negative eigenvalues are round to zero to obtain positive semidefinite kernel matrix. Default <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are various ways to convert kernel function values to distance between two points.
Normal-distance (when <code>method="norm"</code>) means a conversion
d_ND(x,y) = sqrt k(x,x) - 2k(x,y) + k(y,y).
</p>
<p>Cauchy-Schwarz-type conversion (<code>method="CS"</code>) is more principled way:
d_CS(x,y) = arccos k^2(x,y)/k(x,x)k(y,y).
</p>
<p>Other two simple ways are
d_exp(x,y) = exp(- k(x,y)/scale),
which is an exponential-type distance (<code>method="exp"</code>), and
d_n(x,y) = 1 - k(x,y)/sqrt k(x,x)k(y,y),
which we call naive (<code>method="naive"</code>).
</p>
<p>For converting distance to kernel (<code>direction="d2k"</code>), it should be noted that we usually have distance between pairs of points only, and distances from &quot;origin&quot; are unknown.
Double-centering (<code>method="DC"</code>) is the most popular and simple way to convert distance to kernel. However, it does not make positive definite kernel in general,
and it sometimes require post-processing, e.g., cutting off negative eigenvalues (<code>pos=TRUE</code>).
Another simple way is exponential map (<code>method="exp"</code>), i.e., k(x,y) = exp( - d(x,y)/scale).
</p>


<h3>Author(s)</h3>

<p>Hideitsu Hino <a href="mailto:hinohide@cs.tsukuba.ac.jp">hinohide@cs.tsukuba.ac.jp</a>, Ken Takano, Yuki Yoshikawa, and Noboru Murata
</p>

<hr>
<h2 id='Miyagi20030626'>The aftershock data of 26th July 2003 earthquake of M6.2 at the northern Miyagi-Ken Japan</h2><span id='topic+Miyagi20030626'></span>

<h3>Description</h3>

<p>A reparameterization of the <code>main2006JUL26</code> data frame from the <code>SAPP</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Miyagi20030626)
</code></pre>


<h3>Format</h3>

<p>A data object with 2305 seismic events.</p>


<h3>Details</h3>

<p>The variables are as follows:
</p>

<ul>
<li><p> time. time in seconds from the main shock.
</p>
</li>
<li><p> longitude. longitude of the seismic center.
</p>
</li>
<li><p> latitude. latitude of the seismic center.
</p>
</li>
<li><p> depth. depth of the seismic center.
</p>
</li>
<li><p> magnitude. magnitude of the earthquake.
</p>
</li></ul>



<h3>Source</h3>

<p><code>SAPP</code> R package available at <a href="https://cran.r-project.org">https://cran.r-project.org</a>
</p>

<hr>
<h2 id='splitMPP'>Split MPP Data by Sliding Time Window</h2><span id='topic+splitMPP'></span>

<h3>Description</h3>

<p>This function splits a point process realization into a list of splitted point process realizations with length <code>h</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitMPP(mppdata, h = 60 * 60 * 48, ol = NULL, TimeOrigin = TRUE,
  scaleMarks = FALSE, scaleWindow = TRUE, MarkCenter = NULL,
  MarkCenterID = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splitMPP_+3A_mppdata">mppdata</code></td>
<td>
<p>marked point process in data.frame composed of &quot;time, mark1, mark2, ...&quot;.</p>
</td></tr>
<tr><td><code id="splitMPP_+3A_h">h</code></td>
<td>
<p>width of the time window. Default is set to h=60*60*48, which is two days when $time is recorded in second. This is suitable for a special seismic data only.</p>
</td></tr>
<tr><td><code id="splitMPP_+3A_ol">ol</code></td>
<td>
<p>length of overlap for the sliding window. Default 0.</p>
</td></tr>
<tr><td><code id="splitMPP_+3A_timeorigin">TimeOrigin</code></td>
<td>
<p>logical. If <code>TRUE</code>, the beginning of the window is assumed to be the origin of time. Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="splitMPP_+3A_scalemarks">scaleMarks</code></td>
<td>
<p>logical. If <code>TRUE</code>, marks (except time) are normalized to have unit variance in whole time series (not in individual windows). Default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="splitMPP_+3A_scalewindow">scaleWindow</code></td>
<td>
<p>logical. If <code>TRUE</code>, time interval (window.length) is normalized to one.</p>
</td></tr>
<tr><td><code id="splitMPP_+3A_markcenter">MarkCenter</code></td>
<td>
<p>vector for specifying the center of the mark. Use when there are relative center point such as the main shock of the earthquake. Default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="splitMPP_+3A_markcenterid">MarkCenterID</code></td>
<td>
<p>vector for specifying the elements of center of the mark.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>splitMPP</code> splits a point process realization into a list of splitted point process realizations with length <code>h</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##The aftershock data of 26th July 2003 earthquake of M6.2 at the northern Miyagi-Ken Japan.
data(Miyagi20030626)
## time longitude latitude depth magnitude
## split events by 5-hours
sMiyagi &lt;- splitMPP(Miyagi20030626,h=60*60*5,scaleMarks=TRUE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
