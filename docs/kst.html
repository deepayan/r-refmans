<!DOCTYPE html><html><head><title>Help for package kst</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {kst}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as.binaryMatrix'><p>Matrix Representation of Knowledge Structures</p></a></li>
<li><a href='#as.famset'><p>Convert a binary matrix to a family of sets</p></a></li>
<li><a href='#as.relation'><p>Surmise Relations of Knowledge Structures</p></a></li>
<li><a href='#closure'><p>Closure of a Knowledge Structure</p></a></li>
<li><a href='#kassess'><p>Assess Individuals</p></a></li>
<li><a href='#katoms'><p>Atoms of Knowledge Structures</p></a></li>
<li><a href='#kbase'><p>base of a Knowledge Space</p></a></li>
<li><a href='#kdomain'><p>Domain of Knowledge Structures or Bases</p></a></li>
<li><a href='#kfringe'><p>Fringes of Knowledge States</p></a></li>
<li><a href='#kneighbourhood'><p>Neighbourhood of Knowledge States</p></a></li>
<li><a href='#knneighbourhood'><p>Neighbourhood of Knowledge States</p></a></li>
<li><a href='#knotions'><p>Notions of Knowledge Structures or Bases</p></a></li>
<li><a href='#kstructure'><p>Knowledge Structure</p></a></li>
<li><a href='#kstructure_is_wellgraded'><p>Well-Gradedness of Knowledge Structures</p></a></li>
<li><a href='#ktrace'><p>Trace of Knowledge Structures</p></a></li>
<li><a href='#kvalidate'><p>Validate Prerequisite Relations or Knowledge Structures</p></a></li>
<li><a href='#lpath'><p>Learning Paths in a Knowledge Structure</p></a></li>
<li><a href='#lpath_is_gradation'><p>Gradation Property of Learning Paths</p></a></li>
<li><a href='#plot'><p>Plot Family of Sets</p></a></li>
<li><a href='#reduction'><p>Reduction of Knowledge Structures</p></a></li>
<li><a href='#space_property'><p>Space Property of a Knowledge Structure</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.5-4</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-10-24</td>
</tr>
<tr>
<td>Title:</td>
<td>Knowledge Space Theory</td>
</tr>
<tr>
<td>Description:</td>
<td>Knowledge space theory by Doignon and Falmagne (1999) 
   &lt;<a href="https://doi.org/10.1007%2F978-3-642-58625-5">doi:10.1007/978-3-642-58625-5</a>&gt; is a set- and order-theoretical
   framework, which proposes mathematical formalisms to operationalize 
   knowledge structures in a particular domain. The 'kst' package provides 
   basic functionalities to generate, handle, and manipulate knowledge 
   structures and knowledge spaces.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0), proxy, relations (&ge; 0.6-7), sets (&ge; 1.0-17)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>Rgraphviz</td>
</tr>
<tr>
<td>Author:</td>
<td>Christina Stahl [aut],
  David Meyer [aut],
  Cord Hockemeyer [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Cord Hockemeyer &lt;cord.hockemeyer@uni-graz.at&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://homepage.uni-graz.at/en/cord.hockemeyer/">https://homepage.uni-graz.at/en/cord.hockemeyer/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-10-24 12:55:44 UTC; cord</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-10-24 13:52:37 UTC</td>
</tr>
</table>
<hr>
<h2 id='as.binaryMatrix'>Matrix Representation of Knowledge Structures</h2><span id='topic+as.binaryMatrix'></span>

<h3>Description</h3>

<p>Computes the matrix representation of a knowledge structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  as.binaryMatrix(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.binaryMatrix_+3A_x">x</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object of class <code><a href="#topic+kstructure">kstructure</a></code> (or
<code><a href="#topic+kspace">kspace</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>as.binaryMatrix</code> takes an arbitrary knowledge structure in set
representation and computes its matrix form.
</p>


<h3>Value</h3>

<p>An <span class="rlang"><b>R</b></span> object of class <code>matrix</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.famset">as.famset</a></code>, <code><a href="#topic+kspace">kspace</a></code>, <code><a href="#topic+kstructure">kstructure</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kst &lt;- kstructure(set(set("a"), set("a","b"), set("a","c"), set("d","e"), 
   set("a","b","d","e"), set("a","c","d","e"), set("a","b","c","d","e")))
as.binaryMatrix(kst)
</code></pre>

<hr>
<h2 id='as.famset'>Convert a binary matrix to a family of sets</h2><span id='topic+as.famset'></span>

<h3>Description</h3>

<p>Create a <code><a href="sets.html#topic+set">set</a></code> of <code>sets</code> from a binary
matrix where each row of the matrix is taken as one set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  as.famset(m, as.letters = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.famset_+3A_m">m</code></td>
<td>
<p>A binary matrix.</p>
</td></tr>
<tr><td><code id="as.famset_+3A_as.letters">as.letters</code></td>
<td>
<p>logical, should the elements of the sets be letters
or numbers?</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>as.famset</code> takes a binary matrix and converts it to a family (i.e.
<code><a href="sets.html#topic+set">set</a></code>) of sets where each row of the matrix represents
one set and a &quot;1&quot; in row i and column j means that element j is contained
in set i.
</p>
<p>If <code>as.letters</code> is <code>TRUE</code> the elements of the sets are letters,
otherwise numbers. However, if the matrix has colnames, these are taken
as names for the elements of the sets taking precedence over the
<code>as.letters</code> parameter.
</p>
<p>If the matrix contains the same row multiple times it is contained only
once in the resulting family of sets.
</p>


<h3>Value</h3>

<p>An <span class="rlang"><b>R</b></span> object of class <code><a href="sets.html#topic+set">set</a></code> containing <code>sets</code>..
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.binaryMatrix">as.binaryMatrix</a></code>, <code><a href="sets.html#topic+set">set</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(c(1, 0, 0, 1, 1, 0), nrow = 2, ncol = 3)
m
as.famset(m)
as.famset(m, as.letters = FALSE)
</code></pre>

<hr>
<h2 id='as.relation'>Surmise Relations of Knowledge Structures</h2><span id='topic+as.relation.kstructure'></span><span id='topic+as.relation.kbase'></span><span id='topic+as.relation.kfamset'></span>

<h3>Description</h3>

<p>Computes the surmise relation of knowledge structures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'kstructure'
as.relation(x, ...)
  ## S3 method for class 'kbase'
as.relation(x, ...)
  ## S3 method for class 'kfamset'
as.relation(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.relation_+3A_x">x</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object of class <code><a href="#topic+kstructure">kstructure</a></code>,
<code><a href="#topic+kbase">kbase</a></code>, or <code><a href="#topic+kfamset">kfamset</a></code>.</p>
</td></tr>
<tr><td><code id="as.relation_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>as.relation</code> takes an arbitrary knowledge structure and computes the
surmise <code><a href="relations.html#topic+relation">relation</a></code> of the corresponding 
quasi-ordinal knowledge space. Antisymmetric (and
transitive) surmise relations may then be plotted as a Hasse diagram.
</p>


<h3>Value</h3>

<p>An <span class="rlang"><b>R</b></span> object of class <code><a href="relations.html#topic+relation">relation</a></code>.
</p>


<h3>References</h3>

<p>Doignon, J.-P., Falmagne, J.-C. (1999) <em>Knowledge Spaces</em>. Heidelberg:
Springer Verlag.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kstructure">kstructure</a></code>, <code><a href="#topic+kbase">kbase</a></code>, <code><a href="#topic+kfamset">kfamset</a></code>,
<code><a href="relations.html#topic+relation">relation</a></code>, <code><a href="relations.html#topic+plot">plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kst &lt;- kstructure(set(set("a"), set("a","b"), set("a","c"), set("d","e"), 
   set("a","b","d","e"), set("a","c","d","e"), set("a","b","c","d","e")))
as.relation(kst)
</code></pre>

<hr>
<h2 id='closure'>Closure of a Knowledge Structure</h2><span id='topic+closure.kstructure'></span><span id='topic+closure.kbase'></span><span id='topic+closure.kfamset'></span>

<h3>Description</h3>

<p>Computes the closure of knowledge structures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'kstructure'
closure(x, operation=c("union", "intersection"),...)
  ## S3 method for class 'kbase'
closure(x, operation=c("union", "intersection"),...)
  ## S3 method for class 'kfamset'
closure(x, operation=c("union", "intersection"),...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="closure_+3A_x">x</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object of class <code><a href="#topic+kstructure">kstructure</a></code>,
<code><a href="#topic+kbase">kbase</a></code>, or <code><a href="#topic+kfamset">kfamset</a></code>.</p>
</td></tr>
<tr><td><code id="closure_+3A_operation">operation</code></td>
<td>
<p>The set operation under which the closure is computed
(&quot;union&quot; or &quot;intersection&quot;).</p>
</td></tr>
<tr><td><code id="closure_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>closure</code> method for objects of class <code><a href="#topic+kstructure">kstructure</a></code>,
<code><a href="#topic+kbase">kbase</a></code>, or <code><a href="#topic+kfamset">kfamset</a></code> performs the closure of a 
knowledge structure, base, or family of sets by computing
the <code>"union"</code>, <code>"intersection"</code>, <code>"complement"</code>, or
symmetric difference of any two knowledge states. <code>"union"</code> is also
used as a basis for the <code><a href="#topic+kspace">kspace</a></code> function.
</p>


<h3>Value</h3>

<p>An <span class="rlang"><b>R</b></span> object of the same class as <code>x</code> where each subset represents
one knowledge state of the resulting knowledge structure.
</p>


<h3>Note</h3>

<p>The implementation of union is more efficient than the one in <code>sets</code>.
</p>


<h3>References</h3>

<p>Doignon, J.-P., Falmagne, J.-C. (1999) <em>Knowledge Spaces</em>. Heidelberg:
Springer Verlag.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kstructure">kstructure</a></code>, <code><a href="#topic+kspace">kspace</a></code>, <code><a href="#topic+kbase">kbase</a></code>, 
<code><a href="#topic+kfamset">kfamset</a></code>, <code><a href="sets.html#topic+closure">closure</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kst &lt;- kstructure(set(set("a"), set("a","b"), set("a","c"), set("d","e"), 
   set("a","b","d","e"), set("a","c","d","e"), set("a","b","c","d","e")))
closure(kst, operation="union")
</code></pre>

<hr>
<h2 id='kassess'>Assess Individuals</h2><span id='topic+kassess'></span>

<h3>Description</h3>

<p>Assigns individuals to their corresponding knowledge states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  kassess(x, rpatterns=NULL, method="deterministic")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kassess_+3A_x">x</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object of class <code><a href="#topic+kstructure">kstructure</a></code>.</p>
</td></tr>
<tr><td><code id="kassess_+3A_rpatterns">rpatterns</code></td>
<td>
<p>A binary data frame or matrix where each row specifies
the response pattern of one individual to the set of domain problems in <code>x</code>.</p>
</td></tr>
<tr><td><code id="kassess_+3A_method">method</code></td>
<td>
<p>The desired assessment method. Currently only
<code>"deterministic"</code> assessment is implemented.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>kassess</code> assigns individuals to their corresponding knowledge state
in a knowledge structure.
</p>
<p>Assessing individuals based on a <code>"deterministic"</code> procedure
starts by determining a domain problem <em>a</em>, which is contained in
approximately half of the available knowledge states. If the individual
being assessed has successfully solved the respective domain problem <em>a</em>,
all knowledge states that do not contain domain problem <em>a</em> are
removed from the set of potential knowledge states of the individual. If,
on the other hand, the individual has not solved the respective domain
problem <em>a</em>, all knowledge states that do contain domain problem <em>a</em>
are removed from the set of potential knowledge states of the individual.
From the remaining knowledge states a domain problem <em>b</em>, which again
is contained in approximately half of the still available knowledge states,
is selected. If the individual has successfully solved the respective
domain problem <em>b</em>, all knowledge states that do not contain domain
problem <em>b</em> are removed from the set of potential knowledge states
of the individual. If, on the other hand, the individual has solved the
respective domain problem <em>b</em>, all knowledge states that do contain
domain problem <em>b</em> are removed from the set of potential knowledge
states of the individual. This procedure is repeated until only one
knowledge state is left. This is the knowledge state the individual is
currently located in.
</p>


<h3>Value</h3>

<p>A list where each element represents the knowledge state of one respondent.
</p>


<h3>References</h3>

<p>Doignon, J.-P., Falmagne, J.-C. (1999) <em>Knowledge Spaces</em>. Heidelberg:
Springer Verlag.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kstructure">kstructure</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># deterministic assessment
kst &lt;- kstructure(set(set("a"), set("a","b"), set("a","c"), set("d","e"), 
   set("a","b","d","e"), set("a","c","d","e"), set("a","b","c","d","e")))
rp &lt;- data.frame(a=c(1,1,0,1,1,1,1,0,0,0),b=c(0,1,0,1,0,1,0,1,0,0),
   c=c(0,0,0,0,1,1,1,0,1,0),d=c(0,0,1,1,1,1,0,0,0,1), e=c(0,0,1,1,1,1,0,0,0,0))
kassess(kst, rpatterns=rp, method="deterministic")
</code></pre>

<hr>
<h2 id='katoms'>Atoms of Knowledge Structures</h2><span id='topic+katoms'></span>

<h3>Description</h3>

<p>Computes atoms of knowledge structures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  katoms(x, items)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="katoms_+3A_x">x</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object of class <code><a href="#topic+kstructure">kstructure</a></code> or 
<code><a href="#topic+kbase">kbase</a></code>.</p>
</td></tr>
<tr><td><code id="katoms_+3A_items">items</code></td>
<td>
<p>A <code><a href="sets.html#topic+set">set</a></code> of items for which atoms are computed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For any item <em>q</em> of the knowledge domain <em>Q</em>, an <em>atom at q</em>
is a minimal knowledge state containing <em>q</em>, where minimal refers to
the fact that the respective knowledge state is not the union of any
other knowledge states.
</p>


<h3>Value</h3>

<p>A list where each element represents the atom(s) of one item specified in
<code>items</code>.
</p>


<h3>References</h3>

<p>Doignon, J.-P., Falmagne, J.-C. (1999) <em>Knowledge Spaces</em>. Heidelberg:
Springer Verlag.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kstructure">kstructure</a></code>, <code><a href="sets.html#topic+set">set</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kst &lt;- kstructure(set(set("a"), set("a","b"), set("a","c"), set("d","e"), 
   set("a","b","d","e"), set("a","c","d","e"), set("a","b","c","d","e")))
katoms(kst, items=set("a","b","c"))
</code></pre>

<hr>
<h2 id='kbase'>base of a Knowledge Space</h2><span id='topic+kbase'></span>

<h3>Description</h3>

<p>Computes the base of a knowledge space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  kbase(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kbase_+3A_x">x</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object of class <code><a href="#topic+kspace">kspace</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <em>base</em> for a knowledge space is a minimal family of knowledge
states spanning the knowledge space, i.e., the base includes the minimal
states sufficient to reconstruct the full knowledge space. A knowledge
structure has a base only if it is a knowledge space.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+kbase">kbase</a></code>, i.e. a <code><a href="sets.html#topic+set">set</a></code> of sets where 
each subset represents one knowledge state of the base.
</p>


<h3>References</h3>

<p>Doignon, J.-P., Falmagne, J.-C. (1999) <em>Knowledge Spaces</em>. Heidelberg:
Springer Verlag.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kspace">kspace</a></code>, <code><a href="#topic+kstructure">kstructure</a></code>, <code><a href="sets.html#topic+set">set</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kst &lt;- kspace(kstructure(set(set("a"), set("a","b"), set("a","c"), set("d","e"), 
   set("a","b","d","e"), set("a","c","d","e"), set("a","b","c","d","e"))))
kbase(kst)
</code></pre>

<hr>
<h2 id='kdomain'>Domain of Knowledge Structures or Bases</h2><span id='topic+kdomain'></span>

<h3>Description</h3>

<p>Computes the domain of knowledge structures or bases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  kdomain(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kdomain_+3A_x">x</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object of class <code><a href="#topic+kstructure">kstructure</a></code>,
<code><a href="#topic+kbase">kbase</a></code>, or <code><a href="#topic+kfamset">kfamset</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <em>domain</em> is a set of questions or items representing a field of
knowledge.
</p>


<h3>Value</h3>

<p>A <code><a href="sets.html#topic+set">set</a></code> of items, each representing one question of the
knowledge domain.
</p>


<h3>References</h3>

<p>Doignon, J.-P., Falmagne, J.-C. (1999) <em>Knowledge Spaces</em>. Heidelberg:
Springer Verlag.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kstructure">kstructure</a></code>, <code><a href="#topic+kbase">kbase</a></code>,
<code><a href="#topic+kfamset">kfamset</a></code>, <code><a href="sets.html#topic+set">set</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kst &lt;- kstructure(set(set("a"), set("a","b"), set("a","c"), set("d","e"), 
   set("a","b","d","e"), set("a","c","d","e"), set("a","b","c","d","e")))
kdomain(kst)
</code></pre>

<hr>
<h2 id='kfringe'>Fringes of Knowledge States</h2><span id='topic+kfringe'></span><span id='topic+kfringe_inner'></span><span id='topic+kfringe_outer'></span>

<h3>Description</h3>

<p>Computes the fringe of a knowledge state.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  kfringe(kst, state)

  kfringe_inner(kst, state)

  kfringe_outer(kst, state)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kfringe_+3A_kst">kst</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object of class <code><a href="#topic+kstructure">kstructure</a></code>.</p>
</td></tr>
<tr><td><code id="kfringe_+3A_state">state</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object of class <code><a href="sets.html#topic+set">set</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The fringe determines the symmetric difference between a given knowledge 
state and its neighbouring states. It is divided into inner and outer fringe.
The inner fringe contains the fringe items which are element of the knowledge 
state. They have probably been recently learned. The outer fringe contains those 
fringe items which are noe element of the knowledge state. For these items,
all prerequisites are fulfilled, i.e. the learner is ready to learn them now.
</p>


<h3>Value</h3>

<p>A set contining the fringe of <code>state</code>. If <code>state</code> is <code>NULL</code> then a
list containing the fringes of all knowledge states is returned.
</p>


<h3>References</h3>

<p>Doignon, J.-P., Falmagne, J.-C. (1999) <em>Knowledge Spaces</em>. Heidelberg:
Springer Verlag.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kneighbourhood">kneighbourhood</a></code>, <code><a href="#topic+kstructure">kstructure</a></code>, <code><a href="sets.html#topic+set">set</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kst &lt;- kstructure(set(set(), set("c"), set("a","b"), set("b","c"), 
   set("c","d"), set("d","e"), set("a","b","c"), set("b","c","d"), 
   set("c","d","e"), set("a","b","c","d"), set("a","b","d","e"), 
   set("b","c","d","e"), set("a","b","c","d","e")))

# fringe
kfringe(kst, set("c","d","e"))
</code></pre>

<hr>
<h2 id='kneighbourhood'>Neighbourhood of Knowledge States</h2><span id='topic+kneighbourhood'></span>

<h3>Description</h3>

<p>Computes the neighbourhood of a knowledge state.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  kneighbourhood(kst, state)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kneighbourhood_+3A_kst">kst</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object of class <code><a href="#topic+kstructure">kstructure</a></code>.</p>
</td></tr>
<tr><td><code id="kneighbourhood_+3A_state">state</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object of class <code><a href="sets.html#topic+set">set</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The neighbourhood of a knowledge state is the set of all those states which
have a symmetric seu difference of 1.
</p>


<h3>Value</h3>

<p>A set of sets containing the neighbourhood  of <code>state</code>
</p>


<h3>References</h3>

<p>Doignon, J.-P., Falmagne, J.-C. (1999) <em>Knowledge Spaces</em>. Heidelberg:
Springer Verlag.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kfringe">kfringe</a></code>, <code><a href="#topic+kstructure">kstructure</a></code>, <code><a href="sets.html#topic+set">set</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kst &lt;- kstructure(set(set(), set("c"), set("a","b"), set("b","c"), 
   set("c","d"), set("d","e"), set("a","b","c"), set("b","c","d"), 
   set("c","d","e"), set("a","b","c","d"), set("a","b","d","e"), 
   set("b","c","d","e"), set("a","b","c","d","e")))

# inner fringe
kneighbourhood(kst, set("c","d","e"))
</code></pre>

<hr>
<h2 id='knneighbourhood'>Neighbourhood of Knowledge States</h2><span id='topic+knneighbourhood'></span>

<h3>Description</h3>

<p>Computes the neighbourhood of a knowledge state.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  knneighbourhood(kst, state, distance)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knneighbourhood_+3A_kst">kst</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object of class <code><a href="#topic+kstructure">kstructure</a></code>.</p>
</td></tr>
<tr><td><code id="knneighbourhood_+3A_state">state</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object of class <code><a href="sets.html#topic+set">set</a></code>.</p>
</td></tr>
<tr><td><code id="knneighbourhood_+3A_distance">distance</code></td>
<td>
<p>An integer specifying the size of the neighbourhood</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The n-neighbourhood of a knowledge state is the set of all those states which
have a symmetric seu difference of not more than n.
</p>


<h3>Value</h3>

<p>A set of sets containing the n-neighbourhood  of <code>state</code>
</p>


<h3>References</h3>

<p>Doignon, J.-P., Falmagne, J.-C. (1999) <em>Knowledge Spaces</em>. Heidelberg:
Springer Verlag.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kneighbourhood">kneighbourhood</a></code>, <code><a href="#topic+kfringe">kfringe</a></code>,
<code><a href="#topic+kstructure">kstructure</a></code>, <code><a href="sets.html#topic+set">set</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kst &lt;- kstructure(set(set(), set("c"), set("a","b"), set("b","c"), 
   set("c","d"), set("d","e"), set("a","b","c"), set("b","c","d"), 
   set("c","d","e"), set("a","b","c","d"), set("a","b","d","e"), 
   set("b","c","d","e"), set("a","b","c","d","e")))

knneighbourhood(kst, set("c","d","e"), 2)
</code></pre>

<hr>
<h2 id='knotions'>Notions of Knowledge Structures or Bases</h2><span id='topic+knotions'></span>

<h3>Description</h3>

<p>Computes notions of knowledge structures or bases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  knotions(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knotions_+3A_x">x</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object of class <code><a href="#topic+kstructure">kstructure</a></code> or
<code><a href="#topic+kbase">kbase</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <em>notion</em> is a set of items always jointly contained in some
knowledge states. Consequently, these items carry the same information
and may therefore be considered equivalent. A knowledge structure where
each notion contains only one item is considered discriminative.
</p>


<h3>Value</h3>

<p>A <code><a href="sets.html#topic+set">set</a></code> of sets, each representing one notion of the
knowledge structure.
</p>


<h3>References</h3>

<p>Doignon, J.-P., Falmagne, J.-C. (1999) <em>Knowledge Spaces</em>. Heidelberg:
Springer Verlag.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reduction.kstructure">reduction.kstructure</a></code>, <code><a href="#topic+kstructure">kstructure</a></code>, <code><a href="sets.html#topic+set">set</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kst &lt;- kstructure(set(set("a"), set("a","b"), set("a","c"), set("d","e"), 
   set("a","b","d","e"), set("a","c","d","e"), set("a","b","c","d","e")))
knotions(kst)
</code></pre>

<hr>
<h2 id='kstructure'>Knowledge Structure</h2><span id='topic+kstructure'></span><span id='topic+kfamset'></span>

<h3>Description</h3>

<p>Creates a knowledge structure from a surmise relation or knowledge states. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  kstructure(x)
  kfamset(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kstructure_+3A_x">x</code></td>
<td>
<p>Either an endorelation (see <code><a href="relations.html#topic+relation">relation</a></code>)
representing a surmise relation, or a <code><a href="sets.html#topic+set">set</a></code> of sets 
each representing one knowledge state.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The most basic assumption of knowledge space theory is that every
knowledge domain can be represented in terms of a set of domain problems
<em>Q</em>. Moreover, knowledge space theory assumes dependencies between
these domain problems in that knowledge of a given domain problem or a
subset of problems may be a prerequisite for knowledge of another, more
difficult or complex domain problem. These prerequisite relations are
realized by <em>surmise relations</em>, which create a quasi-order between
different domain problems. One advantage of these surmise relations is
that they reduce the quantity of all possible solution patterns to a more
manageable amount of <em>knowledge states</em>. Each of these knowledge
states represents the subset of domain problems an individual is capable
of solving. The collection of all knowledge states captures the
organization of the domain and is referred to as <em>knowledge
structure</em>.
</p>
<p><code>kstructure</code> takes an endorelation representing a surmise relation
or a set of sets each representing one knowledge state (e.g., one clause
of a surmise system) and returns the corresponding knowledge structure.
A knowledge structure always contains the empty set and <em>Q</em>.
</p>
<p><code>kfamset</code> does essentially the same but without ensuring that the
empty set and <em>Q</em> are included.
</p>


<h3>Value</h3>

<p>An <span class="rlang"><b>R</b></span> object of class <code>kstructure</code>.
</p>


<h3>Note</h3>

<p>Note that by default the quotes indicate the fact that the items 
are represented by characters. For displaying purposes, these 
quotes may be turned off by setting respective set options (see 
<code><a href="sets.html#topic+options">options</a></code>).
</p>


<h3>References</h3>

<p>Doignon, J.-P., Falmagne, J.-C. (1999) <em>Knowledge Spaces</em>. Heidelberg:
Springer Verlag.
</p>


<h3>See Also</h3>

<p><code><a href="relations.html#topic+relation">relation</a></code>, <code><a href="sets.html#topic+set">set</a></code>, <code><a href="sets.html#topic+options">options</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># An endorelation representing a surmise relation
kst &lt;- endorelation(graph=set(tuple(1,1), tuple(2,2), tuple(3,3),
  tuple(4,4), tuple(2,1), tuple(3,1), tuple(4,1),
  tuple(3,2), tuple(4,2)))
kstructure(kst)
# A set of sets representing knowledge states (e.g., clauses of a surmise system)
kst &lt;- set(set("a"), set("a","b"), set("a","c"), set("d","e"), set("a","b","d","e"), 
   set("a","c","d","e"), set("a","b","c","d","e"))
kstructure(kst)
# Turning off the quotes for displaying purposes
sets_options("quote",FALSE)
kfamset(kst)
</code></pre>

<hr>
<h2 id='kstructure_is_wellgraded'>Well-Gradedness of Knowledge Structures</h2><span id='topic+kstructure_is_wellgraded'></span>

<h3>Description</h3>

<p>Tests for the well-gradedness of knowledge structures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  kstructure_is_wellgraded(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kstructure_is_wellgraded_+3A_x">x</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object of class <code><a href="#topic+kstructure">kstructure</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A knowledge structure is considered <em>well-graded</em> if any two of 
its states are connected by a bounded path, i.e., each knowledge state 
(except the state for the full set of domain problems <em>Q</em>) has at 
least one immediate successor state that comprises the same domain items 
plus exactly one and each knowledge state (except the empty set <em>{}</em>) 
has at least one predecessor state that contains the same domain items 
with the exception of exactly one. 
</p>
<p><code>kstructure_is_wellgraded</code> takes an arbitrary knowledge structure 
and tests for its well-gradedness.
</p>


<h3>Value</h3>

<p>A logical value.
</p>


<h3>References</h3>

<p>Doignon, J.-P., Falmagne, J.-C. (1999) <em>Knowledge Spaces</em>. Heidelberg:
Springer Verlag.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kstructure">kstructure</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kst &lt;- kstructure(set(set(), set("a"), set("b"), set("c"), set("a","b"), 
   set("b","c"), set("a","b","c")))
kstructure_is_wellgraded(kst)

kst &lt;- kstructure(set(set(), set("a"), set("b"), set("c"), set("a","b"), 
   set("a","b","c")))
kstructure_is_wellgraded(kst)
</code></pre>

<hr>
<h2 id='ktrace'>Trace of Knowledge Structures</h2><span id='topic+ktrace'></span>

<h3>Description</h3>

<p>Computes the trace of knowledge structures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ktrace(x, items)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ktrace_+3A_x">x</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object of class <code><a href="#topic+kstructure">kstructure</a></code>.</p>
</td></tr>
<tr><td><code id="ktrace_+3A_items">items</code></td>
<td>
<p>A set of items for which the trace is computed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <em>trace</em> of a knowledge structure <em>K</em> on a set <em>A</em> is the
substructure of the knowledge structure <em>K</em> on the set <em>A</em>, i.e.,
the substructure resulting from restricting the knowledge structure
<em>K</em> to the items specified in <em>A</em>.
</p>


<h3>Value</h3>

<p>An <span class="rlang"><b>R</b></span> object of class <code><a href="#topic+kstructure">kstructure</a></code> where each element
represents one knowledge state of the knowledge structure on the item
specified in <code>items</code>.
</p>


<h3>References</h3>

<p>Doignon, J.-P., Falmagne, J.-C. (1999) <em>Knowledge Spaces</em>. Heidelberg:
Springer Verlag.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kstructure">kstructure</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kst &lt;- kstructure(set(set("a"), set("a","b"), set("a","c"), set("d","e"), 
   set("a","b","d","e"), set("a","c","d","e"), set("a","b","c","d","e")))
ktrace(kst, items=set("c","d","e"))
</code></pre>

<hr>
<h2 id='kvalidate'>Validate Prerequisite Relations or Knowledge Structures</h2><span id='topic+kvalidate'></span>

<h3>Description</h3>

<p>Validates prerequisite relations or knowledge structures
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  kvalidate(x, rpatterns=NULL, method=c("gamma","percent","VC","DI","DA"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kvalidate_+3A_x">x</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object of class <code><a href="#topic+kstructure">kstructure</a></code>.</p>
</td></tr>
<tr><td><code id="kvalidate_+3A_rpatterns">rpatterns</code></td>
<td>
<p>A binary data frame or matrix where each row specifies
the response pattern of one individual to the set of domain problems in x.</p>
</td></tr>
<tr><td><code id="kvalidate_+3A_method">method</code></td>
<td>
<p>The desired validation method (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>kvalidate</code> calculates validity coefficients for prerequisite
relations and knowledge structures.
</p>
<p>The <em><code class="reqn">\gamma</code>-Index</em> (method <code>"gamma"</code>) validates
the prerequisite relation underlying a knowledge structure and assumes
that not every response pattern is represented by a prerequisite relation.
For this purpose it compares the number of response patterns that are
represented by a prerequisite relation (i.e., concordant pairs) with the
number of response patterns that are not represented by a prerequisite
relation (i.e., discordant pairs). Formally, the <code class="reqn">\gamma</code>-Index
is defined as </p>
<p style="text-align: center;"><code class="reqn">\gamma = \frac{N_c - N_d}{N_c + N_d}</code>
</p>

<p>where <code class="reqn">N_c</code> is the number of concordant pairs and <code class="reqn">N_d</code>
the number of discordant pairs. Generally, a positive <code class="reqn">\gamma</code>-value
supports the validity of prerequisite relations.
</p>
<p>The validation method <code>"percent"</code> likewise validates prerequisite
relations and assumes that more difficult or complex domain problems are
solved less frequently than less difficult or complex domain problems.
For this purpose it calculates the relative solution frequency for each
of the domain problems in <em>Q</em>.
</p>
<p>The <em>Violational Coefficient</em> (method <code>"VC"</code>) also validates
prerequisite relations. For this purpose, the number of violations
(i.e., the earlier mentioned discordant pairs) against a prerequisite
relation are calculated. Formally, the VC is defined as
</p>
<p style="text-align: center;"><code class="reqn">VC = \frac{1}{n(|S| - m)} \sum_{x,y} v_{xy}</code>
</p>

<p>where <code class="reqn">n</code> denotes the number of response vectors, <code class="reqn">|S|</code>
refers to the number of pairs in the relation, <code class="reqn">m</code> denotes the number
of items, and <code class="reqn">v_{xy}</code> again refers to the number of discordant
pairs. Generally, a low VC supports the validity of prerequisite relations.
</p>
<p>In contrast to the other three indices, the <em>Discrepancy Index</em> (method
<code>"DI"</code> and the <em>Distance Agreement
Coefficient</em> (method <code>"DA"</code>) validate the resulting knowledge
structure. The Discrepancy Index is the average distance between the response patterns
and the knowledge structure
</p>
<p style="text-align: center;"><code class="reqn">DI = \sum_{r\in R}\min_{K\in\mathcal{K}}d(r,K) \frac{1}{n}</code>
</p>

<p>where <code class="reqn">d</code> is the symmetric set difference. Generally, a lower DI.value indicates
a better fit between a knowledge structure and a set of response patterns.
</p>
<p>The Distance Agreement Coefficient compares the average symmetric distance
between the knowledge structure and respone patterns (referred to as
<em>ddat</em>) to the average symmetric distance between the knowledge
structure and the power set of response patterns (referred to as
<em>dpot</em>). By calculating the ratio of <em>ddat</em> and <em>dpot</em>,
the DA is determined. Generally, a lower DA-value indicates a better fit
between a knowledge structure and a set of response patterns. Please note that 
the <em>ddat</em> value is equal to the <em>DI</em> index. The DA coefficient is insofar 
a further development of the DI index as it takes into account the sizes of
the domain and the knowledge structure and thus makes the DA values better
comparable.
</p>


<h3>Value</h3>

<p>Depending on the desired assessment method, a data frame with results for
each domain problem (method <code>"percent"</code>), or a list
(methods <code>"gamma"</code>, <code>"VC"</code>, <code>"DI"</code> and <code>"DA"</code>) with
the following components:
</p>
<table>
<tr><td><code>gamma</code></td>
<td>
<p>The gamma-value.</p>
</td></tr>
<tr><td><code>nc</code></td>
<td>
<p>Number of concordant pairs.</p>
</td></tr>
<tr><td><code>nd</code></td>
<td>
<p>Number of discordant pairs.</p>
</td></tr>
</table>
<p>for the <code>"gamma"</code> method,
</p>
<table>
<tr><td><code>vc</code></td>
<td>
<p>The VC-value.</p>
</td></tr>
<tr><td><code>nd</code></td>
<td>
<p>Number of discordant pairs.</p>
</td></tr>
</table>
<p>for the <code>"VC"</code> method,
</p>
<table>
<tr><td><code>di</code></td>
<td>
<p>The DI-value.</p>
</td></tr>
<tr><td><code>di_dist</code></td>
<td>
<p>The distance table for DI.</p>
</td></tr>
</table>
<p>for the <code>"DI"</code> method, and
</p>
<table>
<tr><td><code>ddat</code></td>
<td>
<p>The ddat-value.</p>
</td></tr>
<tr><td><code>ddat_dist</code></td>
<td>
<p>The distance table for ddat.</p>
</td></tr>
<tr><td><code>dpot</code></td>
<td>
<p>The dpot-value.</p>
</td></tr>
<tr><td><code>dpot_dist</code></td>
<td>
<p>The distance table for dpot.</p>
</td></tr>
<tr><td><code>DA</code></td>
<td>
<p>The Distance Agreement Coefficient.</p>
</td></tr>
</table>
<p>for the <code>"DA"</code> nethod.
</p>


<h3>References</h3>

<p>Goodman, L. A. &amp; Kruskal, W. H. (1972) Measures of association for
cross classification. <em>Journal of the American Statistical
Association,</em> 67.
</p>
<p>Kambouri, M., Koppen, M., Villano, M., &amp; Falmagne, J.-C. (1994). Knowledge assessment:
Tapping human expertise by the QUERY routine. International <em>Journal of
Human–Computer–Studies, 40,</em> 119–151.
</p>
<p>Schrepp, M. (1999) An empirical test of a process model for letter
series completion problems. In D. Albert &amp; J. Lukas (Eds.),
<em>Knowledge Spaces: Theories, Emprical Research, Applications</em>.
Mahwah, NJ: Lawrence Erlbaum Associates.
</p>
<p>Schrepp, M., Held, T., &amp; Albert, D. (1999) Component-based
construction of surmise relations for chess problems. In D. Albert &amp;
J. Lukas (Eds.), <em>Knowledge Spaces: Theories, Empirical Research,
Applications</em>. Mahwah, NJ: Lawrence Erlbaum Associates.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kstructure">kstructure</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kst &lt;- kstructure(set(set("a"), set("a","b"), set("a","c"), set("d","e"), 
   set("a","b","d","e"), set("a","c","d","e"), set("a","b","c","d","e")))
rp &lt;- data.frame(a=c(1,1,0,1,1,1,1,0,0,0),b=c(0,1,0,1,0,1,0,1,0,0),
   c=c(0,0,0,0,1,1,1,0,1,0),d=c(0,0,1,1,1,1,0,0,0,1), e=c(0,0,1,1,1,1,0,0,0,0))

# Gamma Index
kvalidate(kst, rpatterns=rp, method="gamma")

# Percent
kvalidate(kst, rpatterns=rp, method="percent")

# Violational Coefficient
kvalidate(kst, rpatterns=rp, method="VC")

# Discrepancy Index
kvalidate(kst, rpatterns=rp, method="DI")

# Distance Agreement Coefficient
kvalidate(kst, rpatterns=rp, method="DA")
</code></pre>

<hr>
<h2 id='lpath'>Learning Paths in a Knowledge Structure</h2><span id='topic+lpath'></span>

<h3>Description</h3>

<p>Computes learning paths in a knowledge structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  lpath(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lpath_+3A_x">x</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object of class <code><a href="#topic+kstructure">kstructure</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A learning path in a knowledge structure is a maximal sequence of 
knowledge states, which allows learners to gradually traverse a 
knowledge structure from the empty set <em>{}</em> (or any other 
bottom state) to the full set of domain problems <em>Q</em>. 
Mathematically, it is represented as a set of states.
</p>
<p><code>lpath</code> takes an arbitrary knowledge structure and computes all 
possible learning paths in the respective knowledge structure.
</p>


<h3>Value</h3>

<p>A list where each element represents one learing path.
</p>


<h3>References</h3>

<p>Doignon, J.-P., Falmagne, J.-C. (1999) <em>Knowledge Spaces</em>. Heidelberg:
Springer Verlag.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kstructure">kstructure</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kst &lt;- kstructure(set(set(), set("a"), set("b"), set("a","b"), 
   set("a","d"), set("b","c"), set("a","b","c"), set("a","b","d"), 
   set("b","c","d"), set("a","b","c","d"), set("a","b","c","d","e")))
lpath(kst)
</code></pre>

<hr>
<h2 id='lpath_is_gradation'>Gradation Property of Learning Paths</h2><span id='topic+lpath_is_gradation'></span>

<h3>Description</h3>

<p>Tests for the gradation property of learning paths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  lpath_is_gradation(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lpath_is_gradation_+3A_x">x</code></td>
<td>
<p>A <code>list</code> of learning paths .</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A learning path is considered a <em>gradation</em> if each state in a 
learning path differs from its predecessor and/or successor state by 
a single item/notion.
</p>
<p><code>lpath_is_gradation</code> takes an arbitrary list of learning paths and 
tests for their gradation property.
</p>


<h3>Value</h3>

<p>A <code>list</code> of logical values where each element represents one learning path.
</p>


<h3>References</h3>

<p>Doignon, J.-P., Falmagne, J.-C. (1999) <em>Knowledge Spaces</em>. Heidelberg:
Springer Verlag.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kstructure">kstructure</a></code>, <code><a href="#topic+lpath">lpath</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kst &lt;- kstructure(set(set(), set("c"), set("a","b"), set("b","c"), 
   set("c","d"), set("d","e"), set("a","b","c"), set("b","c","d"), 
   set("c","d","e"), set("a","b","c","d"), set("a","b","d","e"), 
   set("b","c","d","e"), set("a","b","c","d","e")))
lp &lt;- lpath(kst)
lpath_is_gradation(lp)
</code></pre>

<hr>
<h2 id='plot'>Plot Family of Sets</h2><span id='topic+plot.kstructure'></span><span id='topic+plot.kbase'></span><span id='topic+plot.kfamset'></span>

<h3>Description</h3>

<p>Plots a Hasse diagram of a family of sets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'kstructure'
plot(x, ...)
  ## S3 method for class 'kbase'
plot(x, ...)
  ## S3 method for class 'kfamset'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_+3A_x">x</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object of class <code><a href="#topic+kstructure">kstructure</a></code>,
<code><a href="#topic+kbase">kbase</a></code>, or <code><a href="#topic+kfamset">kfamset</a></code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plot</code> takes an arbitrary family of sets and plots a Hasse diagram. 
</p>


<h3>References</h3>

<p>Doignon, J.-P., Falmagne, J.-C. (1999) <em>Knowledge Spaces</em>. Heidelberg:
Springer Verlag.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kstructure">kstructure</a></code>, <code><a href="#topic+kbase">kbase</a></code>, <code><a href="#topic+kfamset">kfamset</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fs &lt;- kfamset(set(set("a"), set("a","b"), set("a","c"), set("d","e"), 
   set("a","b","d","e"), set("a","c","d","e"), set("a","b","c","d","e")))
if(require("Rgraphviz")) {plot(fs)}
</code></pre>

<hr>
<h2 id='reduction'>Reduction of Knowledge Structures</h2><span id='topic+reduction.kstructure'></span><span id='topic+reduction.kfamset'></span>

<h3>Description</h3>

<p>Computes the reduction of knowledge structures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'kstructure'
reduction(x, operation=c("discrimination", "union", "intersection"),...)
  ## S3 method for class 'kfamset'
reduction(x, operation=c("discrimination", "union", "intersection"),...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reduction_+3A_x">x</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object of class <code><a href="#topic+kstructure">kstructure</a></code> or <code><a href="#topic+kfamset">kfamset</a></code>.</p>
</td></tr>
<tr><td><code id="reduction_+3A_operation">operation</code></td>
<td>
<p>The set operation under which the reduction is computed.</p>
</td></tr>
<tr><td><code id="reduction_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>reduction</code> performs the reduction of a knowledge structure by
computing the minimal subset having the same closure as the knowledge
structure. Additionally, it allows for computing the <em>discriminative</em>
reduction of a knowledge structure. Such a discriminative reduction is a
knowledge structure in which each notion contains a single item.
</p>


<h3>Value</h3>

<p>An <span class="rlang"><b>R</b></span> object of the same class as <code>x</code> where each subset represents
one knowledge state of the resulting reduction.
</p>


<h3>References</h3>

<p>Doignon, J.-P., Falmagne, J.-C. (1999) <em>Knowledge Spaces</em>. Heidelberg:
Springer Verlag.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kstructure">kstructure</a></code>, <code><a href="#topic+knotions">knotions</a></code>, <code><a href="sets.html#topic+closure">closure</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kst &lt;- kstructure(set(set("a"), set("a","b"), set("a","c"), set("d","e"), 
   set("a","b","d","e"), set("a","c","d","e"), set("a","b","c","d","e")))
reduction(kst, operation="discrimination")
</code></pre>

<hr>
<h2 id='space_property'>Space Property of a Knowledge Structure</h2><span id='topic+kstructure_is_kspace'></span><span id='topic+kspace'></span>

<h3>Description</h3>

<p>Tests for and converts to knowledge space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  kstructure_is_kspace(x)
  kspace(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="space_property_+3A_x">x</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object of class <code><a href="#topic+kstructure">kstructure</a></code> or (for 
<code>kspace()</code> only) <code><a href="#topic+kbase">kbase</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A knowledge structure is considered a knowledge space if it includes one
state for the empty set {}, one state for the full set of domain
problems <em>Q</em>, and a state for the union of any two knowledge states
(i.e., the closure under union).
</p>
<p><code>kstructure_is_kspace</code> takes an arbitrary knowledge structure and
tests for its space property.
</p>
<p><code>kspace</code> takes an arbitrary knowledge structure, base, or family
of sets and returns the corresponding knowledge space, i.e. its closure
under union.
</p>


<h3>Value</h3>

<p>For <code>kstructure_is_kspace</code> a logical value.
</p>
<p>For <code>kspace</code> an <span class="rlang"><b>R</b></span> object of class <code>kspace</code> where each
subset represents one knowledge state of the knowledge space.
</p>


<h3>References</h3>

<p>Doignon, J.-P., Falmagne, J.-C. (1999) <em>Knowledge Spaces</em>. Heidelberg:
Springer Verlag.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kstructure">kstructure</a></code>, <code><a href="#topic+closure.kstructure">closure.kstructure</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kst &lt;- kstructure(set(set("a"), set("a","b"), set("a","c"), set("d","e"), 
   set("a","b","d","e"), set("a","c","d","e"), set("a","b","c","d","e")))

# test for knowledge space
kstructure_is_kspace(kst)

# convert to knowledge space
kspace(kst)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
