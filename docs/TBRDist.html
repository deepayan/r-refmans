<!DOCTYPE html><html lang="en-GB"><head><title>Help for package TBRDist</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {TBRDist}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.PrepareTrees'><p>Prepare trees for passing to uspr</p></a></li>
<li><a href='#internals'><p>Internal functions</p></a></li>
<li><a href='#TreeRearrangementDistances'><p>Calculate SPR, TBR and Replug distances on unrooted trees</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Rearrangement Distances Between Unrooted Phylogenetic Trees</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Copyright:</td>
<td>Underlying C++ code copyright 2018 Chris Whidden.</td>
</tr>
<tr>
<td>Description:</td>
<td>Fast calculation of the Subtree Prune and Regraft (SPR),
  Tree Bisection and Reconnection (TBR) and Replug distances between 
  unrooted trees, using the algorithms of Whidden and 
  Matsen (2017) &lt;<a href="https://doi.org/10.48550/arXiv.1511.07529">doi:10.48550/arXiv.1511.07529</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://ms609.github.io/TBRDist/">https://ms609.github.io/TBRDist/</a>,
<a href="https://github.com/ms609/TBRDist/">https://github.com/ms609/TBRDist/</a>,
<a href="https://github.com/cwhidden/uspr/">https://github.com/cwhidden/uspr/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ms609/TBRDist/issues/">https://github.com/ms609/TBRDist/issues/</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ape, Rdpack, TreeDist, TreeTools (&ge; 1.1.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>BH, Rcpp</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++11</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>X-schema.org-keywords:</td>
<td>phylogenetics, tree-distance</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-09-17 09:11:58 UTC; ms609</td>
</tr>
<tr>
<td>Author:</td>
<td>Martin R. Smith <a href="https://orcid.org/0000-0001-5660-1727"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Chris Whidden [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Martin R. Smith &lt;martin.smith@durham.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-09-17 10:10:12 UTC</td>
</tr>
</table>
<hr>
<h2 id='.PrepareTrees'>Prepare trees for passing to uspr</h2><span id='topic+.PrepareTrees'></span>

<h3>Description</h3>

<p>Converts trees to Newick strings, as expected by the 'uspr' C++ library.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.PrepareTrees(
  tree1,
  tree2,
  allPairs = FALSE,
  checks = TRUE,
  unroot = FALSE,
  keepLabels = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".PrepareTrees_+3A_keeplabels">keepLabels</code></td>
<td>
<p>Logical specifying whether to pass text labels to distance
calculator.  This is slower, but makes maximum agreement forests easier
to read.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>.PrepareTrees()</code> returns a two-element list, each entry of which is
a character vector listing trees in Newick format.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>

<hr>
<h2 id='internals'>Internal functions</h2><span id='topic+internals'></span><span id='topic+.CatchBadPair'></span><span id='topic+.DistReturn'></span>

<h3>Description</h3>

<p>These helper functions are unlikely to be of day-to-day use, but are
exported in case they are valuable to package developers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.CatchBadPair(i, tree1, tree2)

.DistReturn(ret, tree1, tree2, allPairs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="internals_+3A_i">i</code></td>
<td>
<p>Integer iterating tree pair.</p>
</td></tr>
<tr><td><code id="internals_+3A_tree1">tree1</code>, <code id="internals_+3A_tree2">tree2</code></td>
<td>
<p>Trees of class <code>phylo</code>.</p>
</td></tr>
<tr><td><code id="internals_+3A_ret">ret</code></td>
<td>
<p>A list containing the results of a tree comparison, probably
performed in C.  Each element of the list will correspond to an aspect
of tree distance (e.g. TBR distance, MAF composition).</p>
</td></tr>
<tr><td><code id="internals_+3A_allpairs">allPairs</code></td>
<td>
<p>Logical specifying whether all trees were compared with all
other trees, in which case a structure of class <code>dist</code> will be returned for
numeric entries, and a symmetric matrix (with diagonal marked <code>NA</code>) returned
for non-numeric entries.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>.CatchBadPair()</code> returns <code>integer(0)</code>, but will <code>stop</code> R with an
error message if the labels of <code>tree1</code> and <code>tree2</code> differ in anything but
order.
</p>
<p><code>.DistReturn()</code> returns a structure of class <code>numeric</code>, <code>matrix</code> or
<code>dist</code> containing the distances between each pair of trees.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0001-5660-1727">Martin R. Smith</a>
(<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>

<hr>
<h2 id='TreeRearrangementDistances'>Calculate SPR, TBR and Replug distances on unrooted trees</h2><span id='topic+TreeRearrangementDistances'></span><span id='topic+USPRDist'></span><span id='topic+ReplugDist'></span><span id='topic+TBRDist'></span><span id='topic+MAFInfo'></span>

<h3>Description</h3>

<p>Calculate SPR, TBR and Replug distances on unrooted trees, and the
information content of the maximum agreement forest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>USPRDist(
  tree1,
  tree2 = NULL,
  allPairs = is.null(tree2),
  checks = TRUE,
  useTbrApproxEstimate = TRUE,
  useTbrEstimate = TRUE,
  useReplugEstimate = TRUE
)

ReplugDist(
  tree1,
  tree2 = NULL,
  allPairs = is.null(tree2),
  checks = TRUE,
  maf = FALSE
)

TBRDist(
  tree1,
  tree2 = NULL,
  allPairs = is.null(tree2),
  checks = TRUE,
  maf = FALSE,
  countMafs = FALSE,
  printMafs = FALSE,
  exact = maf,
  approximate = !exact,
  optimize = TRUE,
  protectB = TRUE
)

MAFInfo(tree1, tree2 = tree1, exact = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TreeRearrangementDistances_+3A_tree1">tree1</code>, <code id="TreeRearrangementDistances_+3A_tree2">tree2</code></td>
<td>
<p>Trees of class <code>phylo</code>, or lists thereof.</p>
</td></tr>
<tr><td><code id="TreeRearrangementDistances_+3A_allpairs">allPairs</code></td>
<td>
<p>Logical; if <code>TRUE</code>, compare each tree in <code>tree1</code> with each
tree in <code>tree2</code>; if <code>FALSE</code>, compare each tree in <code>tree1</code> only with the
tree at the corresponding index in <code>tree2</code>.  If <code>tree2</code> is not specified,
each tree in <code>tree1</code> will be compared with each other tree in <code>tree1</code>.</p>
</td></tr>
<tr><td><code id="TreeRearrangementDistances_+3A_checks">checks</code></td>
<td>
<p>Logical specifying whether to check that trees are properly
formatted and labelled.  Specify <code>FALSE</code> at your peril, as improper
input is likely to crash R.</p>
</td></tr>
<tr><td><code id="TreeRearrangementDistances_+3A_usetbrapproxestimate">useTbrApproxEstimate</code>, <code id="TreeRearrangementDistances_+3A_usetbrestimate">useTbrEstimate</code>, <code id="TreeRearrangementDistances_+3A_usereplugestimate">useReplugEstimate</code></td>
<td>
<p>Logical
specifying whether to use approximate TBR distance, TBR distance or Replug
distance to help estimate the SPR distance.</p>
</td></tr>
<tr><td><code id="TreeRearrangementDistances_+3A_maf">maf</code></td>
<td>
<p>Logical specifying whether to report a maximum agreement forest
corresponding to the optimal score.</p>
</td></tr>
<tr><td><code id="TreeRearrangementDistances_+3A_countmafs">countMafs</code></td>
<td>
<p>Logical specifying whether to count the number of maximum
agreement forests found.</p>
</td></tr>
<tr><td><code id="TreeRearrangementDistances_+3A_printmafs">printMafs</code></td>
<td>
<p>Logical specifying whether to print maximum agreement
forests to stdout whilst counting.
Use <code><a href="utils.html#topic+capture.output">capture.output</a></code><code>(TBRDist(tree1, tree2, printMafs = TRUE))</code> to access
these in R.</p>
</td></tr>
<tr><td><code id="TreeRearrangementDistances_+3A_exact">exact</code></td>
<td>
<p>Logical specifying whether to calculate the exact TBR distance.</p>
</td></tr>
<tr><td><code id="TreeRearrangementDistances_+3A_approximate">approximate</code></td>
<td>
<p>Logical specifying whether to calculate the approximate
TBR distance.  By default, is set to the opposite of <code>exact</code>; either
<code>approximate</code> or <code>exact</code> should usually be set to <code>TRUE</code> if a distance is
required.</p>
</td></tr>
<tr><td><code id="TreeRearrangementDistances_+3A_optimize">optimize</code></td>
<td>
<p>Logical specifying whether to use the default optimizations.</p>
</td></tr>
<tr><td><code id="TreeRearrangementDistances_+3A_protectb">protectB</code></td>
<td>
<p>Logical specifying whether to use the 'PROTECT_B'
optimization.
Overrides value inherited from <code>optimize</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that these distances are NP-hard to compute, so the running time of the
algorithms used in this software scale exponentially with the distance
computed.
The version of 'uspr' linked in this package is aimed at trees with up to
50 leaves and uSPR distances up to 14.
</p>
<p>If you are interested in comparing rooted trees in terms of SPR operations,
you should use '<a href="https://github.com/cwhidden/rspr/">rspr</a>' instead.
'rspr' is also much more efficient and can easily handle pairs of binary
rooted trees with 200+ leaves and distances &gt; 50.
rspr is not yet incorporated in this R package; please
<a href="https://github.com/ms609/TBRDist/issues/2/">contact the maintainer</a>
if this would be useful to you.
</p>


<h3>Value</h3>

<p><code>USPRDist()</code> returns a vector of SPR distances between each pair of
unrooted trees.
</p>
<p><code>ReplugDist()</code> returns a vector of Replug distances between each pair
of trees, or (if <code>maf = TRUE</code>) a named list whose second and third elements
list a vector of maximum agreement forests for each pair of trees.
</p>
<p><code>TBRDist()</code> returns a named list, each element of which bears a
vector corresponding to the requested value for each tree pair.  If only the
exact value is requested (<code>exact = TRUE</code>), an unnamed vector of distances is
returned.
</p>
<p><code>MAFInfo()</code> returns the information content of the maximum agreement
forest, in bits.  This is defined as the sum of the phylogenetic information
content of each constituent subtree, plus the entropy of the clusters implied
by the division of the tree into subtrees.  Note that as there is no
guarantee that the most informative MAF will be encountered,
this measure is approximate only.  <code>exact</code> will only serve to guarantee
that a MAF corresponding to the exact TBR distance is among those sampled.
</p>


<h3>Author(s)</h3>

<p>Algorithms implemented by Chris Whidden (<a href="mailto:cwhidden@fredhutch.org">cwhidden@fredhutch.org</a>)
</p>
<p>R wrappers by Martin R. Smith (<a href="mailto:martin.smith@durham.ac.uk">martin.smith@durham.ac.uk</a>)
</p>


<h3>References</h3>

<p>If you use these functions in your research, please cite:
</p>

<ul>
<li><p> Chris Whidden and Frederick A. Matsen IV. Calculating the Unrooted
Subtree-Prune-and-Regraft Distance.
arXiv:<a href="https://arxiv.org/abs/1511.07529">1511.07529</a>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>tree1 &lt;- TreeTools::BalancedTree(6)
tree2 &lt;- TreeTools::PectinateTree(6)

# SPR distance
USPRDist(tree1, tree2)

# Replug distance
ReplugDist(tree1, tree2)
ReplugDist(tree1, tree2, maf = TRUE)

# TBR distance between two trees
TBRDist(tree1, tree2, exact = TRUE)

# Compare a list against one tree, using approximate distances
TBRDist(list(tree1, tree2), tree2, exact = FALSE)

# Compare all pairs in two lists
TBRDist(list(tree1, tree2), list(tree1, tree2, tree2), allPairs = TRUE,
        exact = FALSE)

# Compare each tree in a list against each other
TBRDist(list(one = tree1, two = tree2, twoAgain = tree2))

# Compare each pair in two lists
TBRDist(list(tree1, tree2, tree2),
        list(tree2, tree1, tree2),
        exact = TRUE, approximate = TRUE, countMafs = TRUE)

# Capture maximum agreement forests
mafs &lt;- capture.output(TBRDist(tree1, tree2, approximate = FALSE,
                        printMafs = TRUE))
head(mafs)

MAFInfo(tree1, tree2)
MAFInfo(list(tree2, tree1), list(tree1, tree2))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
