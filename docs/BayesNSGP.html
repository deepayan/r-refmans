<!DOCTYPE html><html><head><title>Help for package BayesNSGP</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BayesNSGP}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#calcQF'><p>Calculate the Gaussian quadratic form for the NNGP approximation</p></a></li>
<li><a href='#calculateAD_ns'><p>Calculate A and D matrices for the NNGP approximation</p></a></li>
<li><a href='#calculateU_ns'><p>Calculate the (sparse) matrix U</p></a></li>
<li><a href='#conditionLatentObs'><p>Assign conditioning sets for the SGV approximation</p></a></li>
<li><a href='#determineNeighbors'><p>Determine the k-nearest neighbors for each spatial coordinate.</p></a></li>
<li><a href='#dmnorm_nngp'><p>Function for the evaluating the NNGP approximate density.</p></a></li>
<li><a href='#dmnorm_sgv'><p>Function for the evaluating the SGV approximate density.</p></a></li>
<li><a href='#inverseEigen'><p>Calculate covariance elements based on eigendecomposition components</p></a></li>
<li><a href='#matern_corr'><p>Calculate a stationary Matern correlation matrix</p></a></li>
<li><a href='#nimble_sparse_chol'><p>nimble_sparse_chol</p></a></li>
<li><a href='#nimble_sparse_crossprod'><p>nimble_sparse_crossprod</p></a></li>
<li><a href='#nimble_sparse_solve'><p>nimble_sparse_solve</p></a></li>
<li><a href='#nimble_sparse_tcrossprod'><p>nimble_sparse_tcrossprod</p></a></li>
<li><a href='#nsCorr'><p>Calculate a nonstationary Matern correlation matrix</p></a></li>
<li><a href='#nsCrosscorr'><p>Calculate a nonstationary Matern cross-correlation matrix</p></a></li>
<li><a href='#nsCrossdist'><p>Calculate coordinate-specific cross-distance matrices</p></a></li>
<li><a href='#nsCrossdist3d'><p>Calculate coordinate-specific cross-distance matrices, only for nearest neighbors</p>
and store in an array</a></li>
<li><a href='#nsDist'><p>Calculate coordinate-specific distance matrices</p></a></li>
<li><a href='#nsDist3d'><p>Calculate coordinate-specific distance matrices, only for nearest neighbors</p>
and store in an array</a></li>
<li><a href='#nsgpModel'><p>NIMBLE code for a generic nonstationary GP model</p></a></li>
<li><a href='#nsgpPredict'><p>Posterior prediction for the NSGP</p></a></li>
<li><a href='#orderCoordinatesMMD'><p>Order coordinates according to a maximum-minimum distance criterion.</p></a></li>
<li><a href='#R_sparse_chol'><p>R_sparse_chol</p></a></li>
<li><a href='#R_sparse_crossprod'><p>nimble_sparse_crossprod</p></a></li>
<li><a href='#R_sparse_solve'><p>nimble_sparse_solve</p></a></li>
<li><a href='#R_sparse_tcrossprod'><p>nimble_sparse_tcrossprod</p></a></li>
<li><a href='#rmnorm_nngp'><p>Function for the evaluating the NNGP approximate density.</p></a></li>
<li><a href='#rmnorm_sgv'><p>Function for the evaluating the SGV approximate density.</p></a></li>
<li><a href='#sgvSetup'><p>One-time setup wrapper function for the SGV approximation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Bayesian Analysis of Non-Stationary Gaussian Process Models</td>
</tr>
<tr>
<td>Description:</td>
<td>Enables off-the-shelf functionality for fully Bayesian, nonstationary Gaussian process modeling. The approach to nonstationary modeling involves a closed-form, convolution-based covariance function with spatially-varying parameters; these parameter processes can be specified either deterministically (using covariates or basis functions) or stochastically (using approximate Gaussian processes). Stationary Gaussian processes are a special case of our methodology, and we furthermore implement approximate Gaussian process inference to account for very large spatial data sets (Finley, et al (2017) &lt;<a href="https://arxiv.org/abs/1702.00434v2">arXiv:1702.00434v2</a>&gt;). Bayesian inference is carried out using Markov chain Monte Carlo methods via the 'nimble' package, and posterior prediction for the Gaussian process at unobserved locations is provided as a post-processing step.</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-01-07</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Daniel Turek &lt;danielturek@gmail.com&gt;</td>
</tr>
<tr>
<td>Author:</td>
<td>Daniel Turek, Mark Risser</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0),nimble</td>
</tr>
<tr>
<td>Imports:</td>
<td>FNN,Matrix,methods,StatMatch</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-01-08 02:29:25 UTC; dturek</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-01-09 01:52:42 UTC</td>
</tr>
</table>
<hr>
<h2 id='calcQF'>Calculate the Gaussian quadratic form for the NNGP approximation</h2><span id='topic+calcQF'></span>

<h3>Description</h3>

<p><code>calcQF</code> calculates the quadratic form in the multivariate Gaussian 
based on the NNGP approximation, for a specific parameter combination. The
quadratic form is <code>t(u)C^{-1}v</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcQF(u, v, AD, nID)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcQF_+3A_u">u</code></td>
<td>
<p>Vector; left product.</p>
</td></tr>
<tr><td><code id="calcQF_+3A_v">v</code></td>
<td>
<p>Vector; right product</p>
</td></tr>
<tr><td><code id="calcQF_+3A_ad">AD</code></td>
<td>
<p>N x (k+1) matrix; the first k columns are the 'A' matrix, and the
last column is the 'D' vector. Represents the Cholesky of <code>C^{-1}</code>.</p>
</td></tr>
<tr><td><code id="calcQF_+3A_nid">nID</code></td>
<td>
<p>N x k matrix of neighbor indices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two components: (1) an N x 2 array containing the 
same spatial coordinates, ordered by MMD, and (2) the same thing, but with 
any NA values removed.
</p>

<hr>
<h2 id='calculateAD_ns'>Calculate A and D matrices for the NNGP approximation</h2><span id='topic+calculateAD_ns'></span>

<h3>Description</h3>

<p><code>calculateAD_ns</code> calculates A and D matrices (the Cholesky of the 
precision matrix) needed for the NNGP approximation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateAD_ns(
  dist1_3d,
  dist2_3d,
  dist12_3d,
  Sigma11,
  Sigma22,
  Sigma12,
  log_sigma_vec,
  log_tau_vec,
  nID,
  N,
  k,
  nu,
  d
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculateAD_ns_+3A_dist1_3d">dist1_3d</code></td>
<td>
<p>N x (k+1) x (k+1) array of distances in the x-coordinate 
direction.</p>
</td></tr>
<tr><td><code id="calculateAD_ns_+3A_dist2_3d">dist2_3d</code></td>
<td>
<p>N x (k+1) x (k+1) array of distances in the y-coordinate 
direction.</p>
</td></tr>
<tr><td><code id="calculateAD_ns_+3A_dist12_3d">dist12_3d</code></td>
<td>
<p>N x (k+1) x (k+1) array of cross-distances.</p>
</td></tr>
<tr><td><code id="calculateAD_ns_+3A_sigma11">Sigma11</code></td>
<td>
<p>N-vector; 1-1 element of the Sigma() process.</p>
</td></tr>
<tr><td><code id="calculateAD_ns_+3A_sigma22">Sigma22</code></td>
<td>
<p>N-vector; 2-2 element of the Sigma() process.</p>
</td></tr>
<tr><td><code id="calculateAD_ns_+3A_sigma12">Sigma12</code></td>
<td>
<p>N-vector; 1-2 element of the Sigma() process.</p>
</td></tr>
<tr><td><code id="calculateAD_ns_+3A_log_sigma_vec">log_sigma_vec</code></td>
<td>
<p>N-vector; process standard deviation values.</p>
</td></tr>
<tr><td><code id="calculateAD_ns_+3A_log_tau_vec">log_tau_vec</code></td>
<td>
<p>N-vector; nugget standard deviation values.</p>
</td></tr>
<tr><td><code id="calculateAD_ns_+3A_nid">nID</code></td>
<td>
<p>N x k matrix of neighbor indices.</p>
</td></tr>
<tr><td><code id="calculateAD_ns_+3A_n">N</code></td>
<td>
<p>Scalar; number of data measurements.</p>
</td></tr>
<tr><td><code id="calculateAD_ns_+3A_k">k</code></td>
<td>
<p>Scalar; number of nearest neighbors.</p>
</td></tr>
<tr><td><code id="calculateAD_ns_+3A_nu">nu</code></td>
<td>
<p>Scalar; Matern smoothness parameter.</p>
</td></tr>
<tr><td><code id="calculateAD_ns_+3A_d">d</code></td>
<td>
<p>Scalar; dimension of the spatial domain.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A N x (k+1) matrix; the first k columns are the 'A' matrix, and the
last column is the 'D' vector.
</p>

<hr>
<h2 id='calculateU_ns'>Calculate the (sparse) matrix U</h2><span id='topic+calculateU_ns'></span>

<h3>Description</h3>

<p><code>calculateU_ns</code> calculates the (sparse) matrix U (i.e., the Cholesky 
of the inverse covariance matrix) using a nonstationary covariance function.
The output only contains non-zero values and is stored as three vectors: 
(1) the row indices, (2) the column indices, and (3) the non-zero values.
NOTE: this code assumes the all inputs correspond to the ORDERED locations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateU_ns(
  dist1_3d,
  dist2_3d,
  dist12_3d,
  Sigma11,
  Sigma22,
  Sigma12,
  log_sigma_vec,
  log_tau_vec,
  nu,
  nID,
  cond_on_y,
  N,
  k,
  d,
  M = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculateU_ns_+3A_dist1_3d">dist1_3d</code></td>
<td>
<p>N x (k+1) x (k+1) array of distances in the x-coordinate 
direction.</p>
</td></tr>
<tr><td><code id="calculateU_ns_+3A_dist2_3d">dist2_3d</code></td>
<td>
<p>N x (k+1) x (k+1) array of distances in the y-coordinate 
direction.</p>
</td></tr>
<tr><td><code id="calculateU_ns_+3A_dist12_3d">dist12_3d</code></td>
<td>
<p>N x (k+1) x (k+1) array of cross-distances.</p>
</td></tr>
<tr><td><code id="calculateU_ns_+3A_sigma11">Sigma11</code></td>
<td>
<p>N-vector; 1-1 element of the Sigma() process.</p>
</td></tr>
<tr><td><code id="calculateU_ns_+3A_sigma22">Sigma22</code></td>
<td>
<p>N-vector; 2-2 element of the Sigma() process.</p>
</td></tr>
<tr><td><code id="calculateU_ns_+3A_sigma12">Sigma12</code></td>
<td>
<p>N-vector; 1-2 element of the Sigma() process.</p>
</td></tr>
<tr><td><code id="calculateU_ns_+3A_log_sigma_vec">log_sigma_vec</code></td>
<td>
<p>N-vector; process standard deviation values.</p>
</td></tr>
<tr><td><code id="calculateU_ns_+3A_log_tau_vec">log_tau_vec</code></td>
<td>
<p>N-vector; nugget standard deviation values.</p>
</td></tr>
<tr><td><code id="calculateU_ns_+3A_nu">nu</code></td>
<td>
<p>Scalar; Matern smoothness parameter.</p>
</td></tr>
<tr><td><code id="calculateU_ns_+3A_nid">nID</code></td>
<td>
<p>N x k matrix of (ordered) neighbor indices.</p>
</td></tr>
<tr><td><code id="calculateU_ns_+3A_cond_on_y">cond_on_y</code></td>
<td>
<p>A matrix indicating whether the conditioning set for each 
(ordered) location is on the latent process (y, <code>1</code>) or the observed 
values (z, <code>0</code>). Calculated in <code>sgvSetup</code>.</p>
</td></tr>
<tr><td><code id="calculateU_ns_+3A_n">N</code></td>
<td>
<p>Scalar; number of data measurements.</p>
</td></tr>
<tr><td><code id="calculateU_ns_+3A_k">k</code></td>
<td>
<p>Scalar; number of nearest neighbors.</p>
</td></tr>
<tr><td><code id="calculateU_ns_+3A_d">d</code></td>
<td>
<p>Scalar; dimension of the spatial domain.</p>
</td></tr>
<tr><td><code id="calculateU_ns_+3A_m">M</code></td>
<td>
<p>Scalar; number of prediction sites.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a sparse matrix representation of the Cholesky of the
precision matrix for a fixed set of covariance parameters.
</p>

<hr>
<h2 id='conditionLatentObs'>Assign conditioning sets for the SGV approximation</h2><span id='topic+conditionLatentObs'></span>

<h3>Description</h3>

<p><code>conditionLatentObs</code> assigns q_y(i) vs q_z(i) following Section 5.1 
in Katzfuss and Guinness (2018). This function only needs to be run once 
per SGV analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conditionLatentObs(nID, coords_ord, N)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conditionLatentObs_+3A_nid">nID</code></td>
<td>
<p>N x k matrix of neighbor indices.</p>
</td></tr>
<tr><td><code id="conditionLatentObs_+3A_coords_ord">coords_ord</code></td>
<td>
<p>N x 2 matrix of locations.</p>
</td></tr>
<tr><td><code id="conditionLatentObs_+3A_n">N</code></td>
<td>
<p>Scalar; number of locations (observed only!).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix indicating whether the conditioning set for each location 
is on the latent process (y, <code>1</code>) or the observed values (z, <code>0</code>).
</p>

<hr>
<h2 id='determineNeighbors'>Determine the k-nearest neighbors for each spatial coordinate.</h2><span id='topic+determineNeighbors'></span>

<h3>Description</h3>

<p><code>determineNeighbors</code> returns an N x k matrix of the nearest neighbors 
for spatial locations coords, with the ith row giving indices of the k nearest 
neighbors to the ith location, which are selected from among the 1,...(i-1) 
other spatial locations. The first row is -1's, since the first location has 
no neighbors. The i=2 through i=(k+1) rows each necessarily contain 1:i.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>determineNeighbors(coords, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="determineNeighbors_+3A_coords">coords</code></td>
<td>
<p>N x 2 array of N 2-dimensional (x,y) spatial coordinates.</p>
</td></tr>
<tr><td><code id="determineNeighbors_+3A_k">k</code></td>
<td>
<p>Scalar; number of neighbors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An N x k matrix of nearest neighbor indices
</p>


<h3>Examples</h3>

<pre><code class='language-R'>coords &lt;- cbind(runif(100), runif(100))
determineNeighbors(coords, 20)

</code></pre>

<hr>
<h2 id='dmnorm_nngp'>Function for the evaluating the NNGP approximate density.</h2><span id='topic+dmnorm_nngp'></span>

<h3>Description</h3>

<p><code>dmnorm_nngp</code> (and <code>rmnorm_nngp</code>) calculate the approximate NNGP
likelihood for a fixed set of parameters (i.e., A and D matrices). Finally,
the distributions must be registered within <code>nimble</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmnorm_nngp(x, mean, AD, nID, N, k, log)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dmnorm_nngp_+3A_x">x</code></td>
<td>
<p>N-vector of data.</p>
</td></tr>
<tr><td><code id="dmnorm_nngp_+3A_mean">mean</code></td>
<td>
<p>N-vector with current values of the mean</p>
</td></tr>
<tr><td><code id="dmnorm_nngp_+3A_ad">AD</code></td>
<td>
<p>N x (k+1) matrix; the first k columns are the 'A' matrix, and the
last column is the 'D' vector.</p>
</td></tr>
<tr><td><code id="dmnorm_nngp_+3A_nid">nID</code></td>
<td>
<p>N x k matrix of neighbor indices.</p>
</td></tr>
<tr><td><code id="dmnorm_nngp_+3A_n">N</code></td>
<td>
<p>Scalar; number of data measurements.</p>
</td></tr>
<tr><td><code id="dmnorm_nngp_+3A_k">k</code></td>
<td>
<p>Scalar; number of nearest neighbors.</p>
</td></tr>
<tr><td><code id="dmnorm_nngp_+3A_log">log</code></td>
<td>
<p>Scalar; should the density be on the log scale (1) or not (0).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The NNGP approximate density.
</p>

<hr>
<h2 id='dmnorm_sgv'>Function for the evaluating the SGV approximate density.</h2><span id='topic+dmnorm_sgv'></span>

<h3>Description</h3>

<p><code>dmnorm_sgv</code> (and <code>rmnorm_sgv</code>) calculate the approximate SGV
likelihood for a fixed set of parameters (i.e., the U matrix). Finally,
the distributions must be registered within <code>nimble</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmnorm_sgv(x, mean, U, N, k, log = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dmnorm_sgv_+3A_x">x</code></td>
<td>
<p>Vector of measurements</p>
</td></tr>
<tr><td><code id="dmnorm_sgv_+3A_mean">mean</code></td>
<td>
<p>Vector of mean valiues</p>
</td></tr>
<tr><td><code id="dmnorm_sgv_+3A_u">U</code></td>
<td>
<p>Matrix of size N x 3; representation of a sparse N x N Cholesky
of the precision matrix. The first two columns contain row and column 
indices, respectively, and the last column is the nonzero elements of the
matrix.</p>
</td></tr>
<tr><td><code id="dmnorm_sgv_+3A_n">N</code></td>
<td>
<p>Number of measurements in x</p>
</td></tr>
<tr><td><code id="dmnorm_sgv_+3A_k">k</code></td>
<td>
<p>Number of neighbors for the SGV approximation.</p>
</td></tr>
<tr><td><code id="dmnorm_sgv_+3A_log">log</code></td>
<td>
<p>Logical; should the density be evaluated on the log scale.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the SGV approximation to the Gaussian likelihood.
</p>

<hr>
<h2 id='inverseEigen'>Calculate covariance elements based on eigendecomposition components</h2><span id='topic+inverseEigen'></span>

<h3>Description</h3>

<p><code>inverseEigen</code> calculates the inverse eigendecomposition &ndash; in other
words, the covariance elements based on the eigenvalues and vectors. For a
2x2 anisotropy (covariance) matrix, we parameterize the three unique values
in terms of the two log eigenvalues and a rotation parameter on the 
rescaled logit. The function is coded as a <code>nimbleFunction</code> (see the 
<code>nimble</code> package) but can also be used as a regular R function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inverseEigen(eigen_comp1, eigen_comp2, eigen_comp3, which_Sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inverseEigen_+3A_eigen_comp1">eigen_comp1</code></td>
<td>
<p>N-vector; contains values of the log of the first
anisotropy eigenvalue for a set of locations.</p>
</td></tr>
<tr><td><code id="inverseEigen_+3A_eigen_comp2">eigen_comp2</code></td>
<td>
<p>N-vector; contains values of the log of the second
anisotropy eigenvalue for a set of locations.</p>
</td></tr>
<tr><td><code id="inverseEigen_+3A_eigen_comp3">eigen_comp3</code></td>
<td>
<p>N-vector; contains values of the rescaled logit of 
the anisotropy rotation for a set of locations.</p>
</td></tr>
<tr><td><code id="inverseEigen_+3A_which_sigma">which_Sigma</code></td>
<td>
<p>Scalar; one of <code>(1,2,3)</code>, corresponding to which
covariance component should be calculated (Sigma11, Sigma22, or Sigma12,
respectively).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of anisotropy values (Sigma11, Sigma22, or Sigma12; depends
on <code>which_Sigma</code>) for the corresponding set of locations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate some eigendecomposition elements (all three are real-valued)
eigen_comp1 &lt;- rnorm(10)
eigen_comp2 &lt;- rnorm(10)
eigen_comp3 &lt;- rnorm(10)
inverseEigen( eigen_comp1, eigen_comp2, eigen_comp3, 2) # Return the Sigma22 values

</code></pre>

<hr>
<h2 id='matern_corr'>Calculate a stationary Matern correlation matrix</h2><span id='topic+matern_corr'></span>

<h3>Description</h3>

<p><code>matern_corr</code> calculates a stationary Matern correlation matrix for a 
fixed set of locations, based on a range and smoothness parameter. This 
function is primarily used for the &quot;npGP&quot; and &quot;approxGP&quot; models. The 
function is coded as a <code>nimbleFunction</code> (see the <code>nimble</code> package) 
but can also be used as a regular R function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matern_corr(dist, rho, nu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matern_corr_+3A_dist">dist</code></td>
<td>
<p>N x N matrix; contains values of pairwise Euclidean distances in 
the x-y plane.</p>
</td></tr>
<tr><td><code id="matern_corr_+3A_rho">rho</code></td>
<td>
<p>Scalar; &quot;range&quot; parameter used to rescale distances</p>
</td></tr>
<tr><td><code id="matern_corr_+3A_nu">nu</code></td>
<td>
<p>Scalar; Matern smoothness parameter. <code>nu = 0.5</code> corresponds 
to the Exponential correlation; <code>nu = Inf</code> corresponds to the Gaussian
correlation function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A correlation matrix for a fixed set of stations and fixed
parameter values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate some coordinates
coords &lt;- cbind(runif(100),runif(100))
nu &lt;- 2
# Calculate distances -- can use nsDist to calculate Euclidean distances
dist_list &lt;- nsDist(coords, isotropic = TRUE)
# Calculate the correlation matrix
corMat &lt;- matern_corr(sqrt(dist_list$dist1_sq), 1, nu)

</code></pre>

<hr>
<h2 id='nimble_sparse_chol'>nimble_sparse_chol</h2><span id='topic+nimble_sparse_chol'></span>

<h3>Description</h3>

<p>nimble_sparse_chol
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nimble_sparse_chol(i, j, x, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nimble_sparse_chol_+3A_i">i</code></td>
<td>
<p>Vector of row indices.</p>
</td></tr>
<tr><td><code id="nimble_sparse_chol_+3A_j">j</code></td>
<td>
<p>Vector of column indices.</p>
</td></tr>
<tr><td><code id="nimble_sparse_chol_+3A_x">x</code></td>
<td>
<p>Vector of values in the matrix.</p>
</td></tr>
<tr><td><code id="nimble_sparse_chol_+3A_n">n</code></td>
<td>
<p>Length of the vector</p>
</td></tr>
</table>

<hr>
<h2 id='nimble_sparse_crossprod'>nimble_sparse_crossprod</h2><span id='topic+nimble_sparse_crossprod'></span>

<h3>Description</h3>

<p>nimble_sparse_crossprod
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nimble_sparse_crossprod(i, j, x, z, n, subset, transp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nimble_sparse_crossprod_+3A_i">i</code></td>
<td>
<p>Vector of row indices.</p>
</td></tr>
<tr><td><code id="nimble_sparse_crossprod_+3A_j">j</code></td>
<td>
<p>Vector of column indices.</p>
</td></tr>
<tr><td><code id="nimble_sparse_crossprod_+3A_x">x</code></td>
<td>
<p>Vector of values in the matrix.</p>
</td></tr>
<tr><td><code id="nimble_sparse_crossprod_+3A_z">z</code></td>
<td>
<p>Vector to calculate the cross-product with.</p>
</td></tr>
<tr><td><code id="nimble_sparse_crossprod_+3A_n">n</code></td>
<td>
<p>Length of the vector</p>
</td></tr>
<tr><td><code id="nimble_sparse_crossprod_+3A_subset">subset</code></td>
<td>
<p>Optional vector of rows to include in the calculation.</p>
</td></tr>
<tr><td><code id="nimble_sparse_crossprod_+3A_transp">transp</code></td>
<td>
<p>Optional indicator of using the transpose</p>
</td></tr>
</table>

<hr>
<h2 id='nimble_sparse_solve'>nimble_sparse_solve</h2><span id='topic+nimble_sparse_solve'></span>

<h3>Description</h3>

<p>nimble_sparse_solve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nimble_sparse_solve(i, j, x, z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nimble_sparse_solve_+3A_i">i</code></td>
<td>
<p>Vector of row indices.</p>
</td></tr>
<tr><td><code id="nimble_sparse_solve_+3A_j">j</code></td>
<td>
<p>Vector of column indices.</p>
</td></tr>
<tr><td><code id="nimble_sparse_solve_+3A_x">x</code></td>
<td>
<p>Vector of values in the matrix.</p>
</td></tr>
<tr><td><code id="nimble_sparse_solve_+3A_z">z</code></td>
<td>
<p>Vector to calculate the cross-product with.</p>
</td></tr>
</table>

<hr>
<h2 id='nimble_sparse_tcrossprod'>nimble_sparse_tcrossprod</h2><span id='topic+nimble_sparse_tcrossprod'></span>

<h3>Description</h3>

<p>nimble_sparse_tcrossprod
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nimble_sparse_tcrossprod(i, j, x, subset)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nimble_sparse_tcrossprod_+3A_i">i</code></td>
<td>
<p>Vector of row indices.</p>
</td></tr>
<tr><td><code id="nimble_sparse_tcrossprod_+3A_j">j</code></td>
<td>
<p>Vector of column indices.</p>
</td></tr>
<tr><td><code id="nimble_sparse_tcrossprod_+3A_x">x</code></td>
<td>
<p>Vector of values in the matrix.</p>
</td></tr>
<tr><td><code id="nimble_sparse_tcrossprod_+3A_subset">subset</code></td>
<td>
<p>Optional vector of rows to include in the calculation.</p>
</td></tr>
</table>

<hr>
<h2 id='nsCorr'>Calculate a nonstationary Matern correlation matrix</h2><span id='topic+nsCorr'></span>

<h3>Description</h3>

<p><code>nsCorr</code> calculates a nonstationary correlation matrix for a 
fixed set of locations, based on vectors of the unique anisotropy 
parameters for each station. Since the correlation function uses a 
spatially-varying Mahalanobis distance, this function requires coordinate-
specific distance matrices (see below). The function is coded as a 
<code>nimbleFunction</code> (see the <code>nimble</code> package) but can also be 
used as a regular R function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nsCorr(dist1_sq, dist2_sq, dist12, Sigma11, Sigma22, Sigma12, nu, d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nsCorr_+3A_dist1_sq">dist1_sq</code></td>
<td>
<p>N x N matrix; contains values of pairwise squared distances
in the x-coordinate.</p>
</td></tr>
<tr><td><code id="nsCorr_+3A_dist2_sq">dist2_sq</code></td>
<td>
<p>N x N matrix; contains values of pairwise squared distances
in the y-coordinate.</p>
</td></tr>
<tr><td><code id="nsCorr_+3A_dist12">dist12</code></td>
<td>
<p>N x N matrix; contains values of pairwise signed cross-
distances between the x- and y-coordinates. The sign of each element is
important; see <code>nsDist</code> function for the details of this calculation.
in the x-coordinate.</p>
</td></tr>
<tr><td><code id="nsCorr_+3A_sigma11">Sigma11</code></td>
<td>
<p>Vector of length N; contains the 1-1 element of the 
anisotropy process for each station.</p>
</td></tr>
<tr><td><code id="nsCorr_+3A_sigma22">Sigma22</code></td>
<td>
<p>Vector of length N; contains the 2-2 element of the 
anisotropy process for each station.</p>
</td></tr>
<tr><td><code id="nsCorr_+3A_sigma12">Sigma12</code></td>
<td>
<p>Vector of length N; contains the 1-2 element of the 
anisotropy process for each station.</p>
</td></tr>
<tr><td><code id="nsCorr_+3A_nu">nu</code></td>
<td>
<p>Scalar; Matern smoothness parameter. <code>nu = 0.5</code> corresponds 
to the Exponential correlation; <code>nu = Inf</code> corresponds to the Gaussian
correlation function.</p>
</td></tr>
<tr><td><code id="nsCorr_+3A_d">d</code></td>
<td>
<p>Scalar; dimension of the spatial coordinates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A correlation matrix for a fixed set of stations and fixed
parameter values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate some coordinates and parameters
coords &lt;- cbind(runif(100),runif(100))
Sigma11 &lt;- rep(1, 100) # Identity anisotropy process
Sigma22 &lt;- rep(1, 100)
Sigma12 &lt;- rep(0, 100)
nu &lt;- 2
# Calculate distances
dist_list &lt;- nsDist(coords)
# Calculate the correlation matrix
corMat &lt;- nsCorr(dist_list$dist1_sq, dist_list$dist2_sq, dist_list$dist12,
                 Sigma11, Sigma22, Sigma12, nu, ncol(coords))

</code></pre>

<hr>
<h2 id='nsCrosscorr'>Calculate a nonstationary Matern cross-correlation matrix</h2><span id='topic+nsCrosscorr'></span>

<h3>Description</h3>

<p><code>nsCrosscorr</code> calculates a nonstationary cross-correlation matrix 
between two fixed sets of locations (a prediction set with M locations, and
the observed set with N locations), based on vectors of the unique anisotropy 
parameters for each station. Since the correlation function uses a 
spatially-varying Mahalanobis distance, this function requires coordinate-
specific distance matrices (see below). The function is coded as a 
<code>nimbleFunction</code> (see the <code>nimble</code> package) but can also be 
used as a regular R function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nsCrosscorr(
  Xdist1_sq,
  Xdist2_sq,
  Xdist12,
  Sigma11,
  Sigma22,
  Sigma12,
  PSigma11,
  PSigma22,
  PSigma12,
  nu,
  d
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nsCrosscorr_+3A_xdist1_sq">Xdist1_sq</code></td>
<td>
<p>M x N matrix; contains values of pairwise squared cross-distances
in the x-coordinate.</p>
</td></tr>
<tr><td><code id="nsCrosscorr_+3A_xdist2_sq">Xdist2_sq</code></td>
<td>
<p>M x N matrix; contains values of pairwise squared cross-distances
in the y-coordinate.</p>
</td></tr>
<tr><td><code id="nsCrosscorr_+3A_xdist12">Xdist12</code></td>
<td>
<p>M x N matrix; contains values of pairwise signed cross/cross-
distances between the x- and y-coordinates. The sign of each element is
important; see <code>nsDist</code> function for the details of this calculation.
in the x-coordinate.</p>
</td></tr>
<tr><td><code id="nsCrosscorr_+3A_sigma11">Sigma11</code></td>
<td>
<p>Vector of length N; contains the 1-1 element of the 
anisotropy process for each observed location.</p>
</td></tr>
<tr><td><code id="nsCrosscorr_+3A_sigma22">Sigma22</code></td>
<td>
<p>Vector of length N; contains the 2-2 element of the 
anisotropy process for each observed location.</p>
</td></tr>
<tr><td><code id="nsCrosscorr_+3A_sigma12">Sigma12</code></td>
<td>
<p>Vector of length N; contains the 1-2 element of the 
anisotropy process for each observed location.</p>
</td></tr>
<tr><td><code id="nsCrosscorr_+3A_psigma11">PSigma11</code></td>
<td>
<p>Vector of length N; contains the 1-1 element of the 
anisotropy process for each prediction location.</p>
</td></tr>
<tr><td><code id="nsCrosscorr_+3A_psigma22">PSigma22</code></td>
<td>
<p>Vector of length N; contains the 2-2 element of the 
anisotropy process for each prediction location.</p>
</td></tr>
<tr><td><code id="nsCrosscorr_+3A_psigma12">PSigma12</code></td>
<td>
<p>Vector of length N; contains the 1-2 element of the 
anisotropy process for each prediction location.</p>
</td></tr>
<tr><td><code id="nsCrosscorr_+3A_nu">nu</code></td>
<td>
<p>Scalar; Matern smoothness parameter. <code>nu = 0.5</code> corresponds 
to the Exponential correlation; <code>nu = Inf</code> corresponds to the Gaussian
correlation function.</p>
</td></tr>
<tr><td><code id="nsCrosscorr_+3A_d">d</code></td>
<td>
<p>Scalar; dimension of the spatial domain.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A M x N cross-correlation matrix for two fixed sets of stations and 
fixed parameter values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate some coordinates and parameters
coords &lt;- cbind(runif(100),runif(100))
Sigma11 &lt;- rep(1, 100) # Identity anisotropy process
Sigma22 &lt;- rep(1, 100)
Sigma12 &lt;- rep(0, 100)
Pcoords &lt;- cbind(runif(200),runif(200))
PSigma11 &lt;- rep(1, 200) # Identity anisotropy process
PSigma22 &lt;- rep(1, 200)
PSigma12 &lt;- rep(0, 200)
nu &lt;- 2
# Calculate distances
Xdist_list &lt;- nsCrossdist(coords, Pcoords)
# Calculate the correlation matrix
XcorMat &lt;- nsCrosscorr(Xdist_list$dist1_sq, Xdist_list$dist2_sq, Xdist_list$dist12,
   Sigma11, Sigma22, Sigma12, PSigma11, PSigma22, PSigma12, nu, ncol(coords))

</code></pre>

<hr>
<h2 id='nsCrossdist'>Calculate coordinate-specific cross-distance matrices</h2><span id='topic+nsCrossdist'></span>

<h3>Description</h3>

<p><code>nsCrossdist</code> calculates coordinate-specific cross distances in x, y,
and x-y for use in the nonstationary cross-correlation calculation. This 
function is useful for calculating posterior predictions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nsCrossdist(coords, Pcoords, scale_factor = NULL, isotropic = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nsCrossdist_+3A_coords">coords</code></td>
<td>
<p>N x 2 matrix; contains x-y coordinates of station (observed)
locations.</p>
</td></tr>
<tr><td><code id="nsCrossdist_+3A_pcoords">Pcoords</code></td>
<td>
<p>M x 2 matrix; contains x-y coordinates of prediction
locations.</p>
</td></tr>
<tr><td><code id="nsCrossdist_+3A_scale_factor">scale_factor</code></td>
<td>
<p>Scalar; optional argument for re-scaling the distances.</p>
</td></tr>
<tr><td><code id="nsCrossdist_+3A_isotropic">isotropic</code></td>
<td>
<p>Logical; indicates whether distances should be calculated
using Euclidean distance (<code>isotropic = TRUE</code>) or using the anisotropic
formulation (<code>isotropic = FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of distances matrices, with the following components:
</p>
<table>
<tr><td><code>dist1_sq</code></td>
<td>
<p>M x N matrix; contains values of pairwise squared cross-
distances in the x-coordinate.</p>
</td></tr>
<tr><td><code>dist2_sq</code></td>
<td>
<p>M x N matrix; contains values of pairwise squared cross-
distances in the y-coordinate.</p>
</td></tr>
<tr><td><code>dist12</code></td>
<td>
<p>M x N matrix; contains values of pairwise signed cross-
distances between the x- and y-coordinates.</p>
</td></tr>
<tr><td><code>scale_factor</code></td>
<td>
<p>Value of the scale factor used to rescale distances.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Generate some coordinates 
coords &lt;- cbind(runif(100),runif(100))
Pcoords &lt;- cbind(runif(200),runif(200))
# Calculate distances
Xdist_list &lt;- nsCrossdist(coords, Pcoords)

</code></pre>

<hr>
<h2 id='nsCrossdist3d'>Calculate coordinate-specific cross-distance matrices, only for nearest neighbors
and store in an array</h2><span id='topic+nsCrossdist3d'></span>

<h3>Description</h3>

<p><code>nsCrossdist3d</code> generates and returns new 3-dimensional arrays containing
the former dist1_sq, dist2_s1, and dist12 matrices, but
only as needed for the k nearest-neighbors of each location.
these 3D matrices (dist1_3d, dist2_3d, and dist12_3d)
are used in the new implementation of calculateAD_ns().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nsCrossdist3d(
  coords,
  predCoords,
  P_nID,
  scale_factor = NULL,
  isotropic = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nsCrossdist3d_+3A_coords">coords</code></td>
<td>
<p>N x d matrix; contains the x-y coordinates of stations.</p>
</td></tr>
<tr><td><code id="nsCrossdist3d_+3A_predcoords">predCoords</code></td>
<td>
<p>M x d matrix</p>
</td></tr>
<tr><td><code id="nsCrossdist3d_+3A_p_nid">P_nID</code></td>
<td>
<p>N x k matrix; contains indices of nearest neighbors.</p>
</td></tr>
<tr><td><code id="nsCrossdist3d_+3A_scale_factor">scale_factor</code></td>
<td>
<p>Scalar; optional argument for re-scaling the distances.</p>
</td></tr>
<tr><td><code id="nsCrossdist3d_+3A_isotropic">isotropic</code></td>
<td>
<p>Logical; indicates whether distances should be calculated
separately for each coordinate dimension (FALSE) or simultaneously for all
coordinate dimensions (TRUE). <code>isotropic = FALSE</code> can only be used for
two-dimensional coordinate systems.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Arrays with nearest neighbor distances in each coordinate 
direction. When the spatial dimension d &gt; 2, dist1_3d contains squared
Euclidean distances, and dist2_3d and dist12_3d are empty.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate some coordinates and neighbors
coords &lt;- cbind(runif(100),runif(100))
predCoords &lt;- cbind(runif(200),runif(200))
P_nID &lt;- FNN::get.knnx(coords, predCoords, k = 10)$nn.index # Prediction NN
# Calculate distances
Pdist &lt;- nsCrossdist3d(coords, predCoords, P_nID)

</code></pre>

<hr>
<h2 id='nsDist'>Calculate coordinate-specific distance matrices</h2><span id='topic+nsDist'></span>

<h3>Description</h3>

<p><code>nsDist</code> calculates x, y, and x-y distances for use in the 
nonstationary correlation calculation. The sign of the cross-distance
is important. The function contains an optional argument for re-scaling
the distances such that the coordinates lie in a square.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nsDist(coords, scale_factor = NULL, isotropic = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nsDist_+3A_coords">coords</code></td>
<td>
<p>N x 2 matrix; contains the x-y coordinates of stations</p>
</td></tr>
<tr><td><code id="nsDist_+3A_scale_factor">scale_factor</code></td>
<td>
<p>Scalar; optional argument for re-scaling the distances.</p>
</td></tr>
<tr><td><code id="nsDist_+3A_isotropic">isotropic</code></td>
<td>
<p>Logical; indicates whether distances should be calculated
separately for each coordinate dimension (FALSE) or simultaneously for all
coordinate dimensions (TRUE). <code>isotropic = TRUE</code> can only be used for
two-dimensional coordinate systems.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of distances matrices, with the following components:
</p>
<table>
<tr><td><code>dist1_sq</code></td>
<td>
<p>N x N matrix; contains values of pairwise squared distances
in the x-coordinate.</p>
</td></tr>
<tr><td><code>dist2_sq</code></td>
<td>
<p>N x N matrix; contains values of pairwise squared distances
in the y-coordinate.</p>
</td></tr>
<tr><td><code>dist12</code></td>
<td>
<p>N x N matrix; contains values of pairwise signed cross-
distances between the x- and y-coordinates.</p>
</td></tr>
<tr><td><code>scale_factor</code></td>
<td>
<p>Value of the scale factor used to rescale distances.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Generate some coordinates
coords &lt;- cbind(runif(100),runif(100))
# Calculate distances
dist_list &lt;- nsDist(coords)
# Use nsDist to calculate Euclidean distances
dist_Euclidean &lt;- sqrt(nsDist(coords, isotropic = TRUE)$dist1_sq)

</code></pre>

<hr>
<h2 id='nsDist3d'>Calculate coordinate-specific distance matrices, only for nearest neighbors
and store in an array</h2><span id='topic+nsDist3d'></span>

<h3>Description</h3>

<p><code>nsDist3d</code> generates and returns new 3-dimensional arrays containing
the former dist1_sq, dist2_sq, and dist12 matrices, but
only as needed for the k nearest-neighbors of each location.
these 3D matrices (dist1_3d, dist2_3d, and dist12_3d)
are used in the new implementation of calculateAD_ns().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nsDist3d(coords, nID, scale_factor = NULL, isotropic = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nsDist3d_+3A_coords">coords</code></td>
<td>
<p>N x 2 matrix; contains the x-y coordinates of stations.</p>
</td></tr>
<tr><td><code id="nsDist3d_+3A_nid">nID</code></td>
<td>
<p>N x k matrix; contains indices of nearest neighbors.</p>
</td></tr>
<tr><td><code id="nsDist3d_+3A_scale_factor">scale_factor</code></td>
<td>
<p>Scalar; optional argument for re-scaling the distances.</p>
</td></tr>
<tr><td><code id="nsDist3d_+3A_isotropic">isotropic</code></td>
<td>
<p>Logical; indicates whether distances should be calculated
separately for each coordinate dimension (FALSE) or simultaneously for all
coordinate dimensions (TRUE). <code>isotropic = TRUE</code> can only be used for
two-dimensional coordinate systems.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Arrays with nearest neighbor distances in each coordinate 
direction.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate some coordinates and neighbors
coords &lt;- cbind(runif(100),runif(100))
nID &lt;- determineNeighbors(coords, 10)
# Calculate distances
nsDist3d(coords, nID)

</code></pre>

<hr>
<h2 id='nsgpModel'>NIMBLE code for a generic nonstationary GP model</h2><span id='topic+nsgpModel'></span>

<h3>Description</h3>

<p>This function sets up and compiles a nimble model for a general 
nonstationary Gaussian process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nsgpModel(
  tau_model = "constant",
  sigma_model = "constant",
  Sigma_model = "constant",
  mu_model = "constant",
  likelihood = "fullGP",
  coords,
  data,
  constants = list(),
  monitorAllSampledNodes = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nsgpModel_+3A_tau_model">tau_model</code></td>
<td>
<p>Character; specifies the model to be used for the log(tau) 
process. Options are <code>"constant"</code> (spatially-constant), 
<code>"logLinReg"</code> (log-linear regression), and <code>"approxGP"</code> 
(approximation to a Gaussian process).</p>
</td></tr>
<tr><td><code id="nsgpModel_+3A_sigma_model">sigma_model</code></td>
<td>
<p>Character; specifies the model to be used for the 
log(sigma) process. See <code>tau_model</code> for options.</p>
</td></tr>
<tr><td><code id="nsgpModel_+3A_sigma_model">Sigma_model</code></td>
<td>
<p>Character; specifies the model to be used for the 
Sigma anisotropy process. Options are <code>"constant"</code> (spatially-constant),
<code>"constantIso"</code> (spatially-constant and isotropic), <code>"covReg"</code> 
(covariance regression), <code>"compReg"</code> (componentwise regression), 
<code>"compRegIso"</code> (isotropic componentwise regression), <code>"npApproxGP"</code>
(nonparameteric regression via an approximation to a stationary Gaussian 
process), and <code>"npApproxGPIso"</code> (isotropic nonparameteric regression 
via an approximation to a stationary Gaussian process)</p>
</td></tr>
<tr><td><code id="nsgpModel_+3A_mu_model">mu_model</code></td>
<td>
<p>Character; specifies the model to be used for the mu mean 
process. Options are <code>"constant"</code> (spatially-constant), <code>"linReg"</code>
(linear regression), and <code>"zero"</code> (a fixed zero-mean).</p>
</td></tr>
<tr><td><code id="nsgpModel_+3A_likelihood">likelihood</code></td>
<td>
<p>Character; specifies the likelihood model. Options are
<code>"fullGP"</code> (the exact Gaussian process likelihood), <code>"NNGP"</code> (the
nearest-neighbor GP for the response approximate likelihood), and <code>"SGV"</code> 
(the sparse general Vecchia approximate likelihood).</p>
</td></tr>
<tr><td><code id="nsgpModel_+3A_coords">coords</code></td>
<td>
<p>N x d matrix of spatial coordinates.</p>
</td></tr>
<tr><td><code id="nsgpModel_+3A_data">data</code></td>
<td>
<p>N-vector; observed vector of the spatial process of interest</p>
</td></tr>
<tr><td><code id="nsgpModel_+3A_constants">constants</code></td>
<td>
<p>A list of constants required to build the model; depends on
the specific parameter process models chosen.</p>
</td></tr>
<tr><td><code id="nsgpModel_+3A_monitorallsamplednodes">monitorAllSampledNodes</code></td>
<td>
<p>Logical; indicates whether all sampled nodes 
should be stored (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="nsgpModel_+3A_...">...</code></td>
<td>
<p>Additional arguments can be passed to the function; for example,
as an alternative to the <code>constants</code> list, items can be passed directly
via this argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>nimbleCode</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate some data: stationary/isotropic
N &lt;- 100
coords &lt;- matrix(runif(2*N), ncol = 2)
alpha_vec &lt;- rep(log(sqrt(1)), N) # Log process SD
delta_vec &lt;- rep(log(sqrt(0.05)), N) # Log nugget SD
Sigma11_vec &lt;- rep(0.4, N) # Kernel matrix element 1,1
Sigma22_vec &lt;- rep(0.4, N) # Kernel matrix element 2,2
Sigma12_vec &lt;- rep(0, N) # Kernel matrix element 1,2
mu_vec &lt;- rep(0, N) # Mean
nu &lt;- 0.5 # Smoothness
dist_list &lt;- nsDist(coords)
Cor_mat &lt;- nsCorr( dist1_sq = dist_list$dist1_sq, dist2_sq = dist_list$dist2_sq, 
                   dist12 = dist_list$dist12, Sigma11 = Sigma11_vec, 
                   Sigma22 = Sigma22_vec, Sigma12 = Sigma12_vec, nu = nu )
Cov_mat &lt;- diag(exp(alpha_vec)) %*% Cor_mat %*% diag(exp(alpha_vec))
D_mat &lt;- diag(exp(delta_vec)^2) 
set.seed(110)
data &lt;- as.numeric(mu_vec + t(chol(Cov_mat + D_mat)) %*% rnorm(N))
# Set up constants
constants &lt;- list( nu = 0.5, Sigma_HP1 = 2 )
# Defaults: tau_model = "constant", sigma_model = "constant", mu_model = "constant",
# and Sigma_model = "constant"
Rmodel &lt;- nsgpModel(likelihood = "fullGP", constants = constants, coords = coords, data = data )

</code></pre>

<hr>
<h2 id='nsgpPredict'>Posterior prediction for the NSGP</h2><span id='topic+nsgpPredict'></span>

<h3>Description</h3>

<p><code>nsgpPredict</code> conducts posterior prediction for MCMC samples generated
using nimble and nsgpModel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nsgpPredict(
  model,
  samples,
  coords.predict,
  predict.process = TRUE,
  constants,
  seed = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nsgpPredict_+3A_model">model</code></td>
<td>
<p>A NSGP nimble object; the output of <code>nsgpModel</code>.</p>
</td></tr>
<tr><td><code id="nsgpPredict_+3A_samples">samples</code></td>
<td>
<p>A matrix of <code>J</code> rows, each is an MCMC sample of the 
parameters corresponding to the specification in <code>nsgpModel</code>.</p>
</td></tr>
<tr><td><code id="nsgpPredict_+3A_coords.predict">coords.predict</code></td>
<td>
<p>M x d matrix of prediction coordinates.</p>
</td></tr>
<tr><td><code id="nsgpPredict_+3A_predict.process">predict.process</code></td>
<td>
<p>Logical; determines whether the prediction corresponds to 
the y(·) process (<code>TRUE</code>) or z(·) (<code>FALSE</code>; this would likely 
only be used for, e.g., cross-validation).</p>
</td></tr>
<tr><td><code id="nsgpPredict_+3A_constants">constants</code></td>
<td>
<p>An optional list of contants to use for prediction; 
alternatively, additional arguments can be passed to the function via the
... argument.</p>
</td></tr>
<tr><td><code id="nsgpPredict_+3A_seed">seed</code></td>
<td>
<p>An optional random seed argument for reproducibility.</p>
</td></tr>
<tr><td><code id="nsgpPredict_+3A_...">...</code></td>
<td>
<p>Additional arguments can be passed to the function; for example,
as an alternative to the <code>constants</code> list, items can be passed directly
via this argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output of the function is a list with two elements: <code>obs</code>,
a matrix of <code>J</code> posterior predictive samples for the N observed 
locations (only for <code>likelihood = "SGV"</code>, which produces predictions 
for the observed locations by default; this element is <code>NULL</code> 
otherwise); and <code>pred</code>, a corresponding matrix of posterior predictive 
samples for the prediction locations. Ordering and neighbor selection
for the prediction coordinates in the SGV likelihood are conducted 
internally, as with <code>nsgpModel</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate some data: stationary/isotropic
N &lt;- 100
coords &lt;- matrix(runif(2*N), ncol = 2)
alpha_vec &lt;- rep(log(sqrt(1)), N) # Log process SD
delta_vec &lt;- rep(log(sqrt(0.05)), N) # Log nugget SD
Sigma11_vec &lt;- rep(0.4, N) # Kernel matrix element 1,1
Sigma22_vec &lt;- rep(0.4, N) # Kernel matrix element 2,2
Sigma12_vec &lt;- rep(0, N) # Kernel matrix element 1,2
mu_vec &lt;- rep(0, N) # Mean
nu &lt;- 0.5 # Smoothness
dist_list &lt;- nsDist(coords)
Cor_mat &lt;- nsCorr( dist1_sq = dist_list$dist1_sq, dist2_sq = dist_list$dist2_sq, 
                   dist12 = dist_list$dist12, Sigma11 = Sigma11_vec, 
                   Sigma22 = Sigma22_vec, Sigma12 = Sigma12_vec, nu = nu )
Cov_mat &lt;- diag(exp(alpha_vec)) %*% Cor_mat %*% diag(exp(alpha_vec))
D_mat &lt;- diag(exp(delta_vec)^2) 
set.seed(110)
data &lt;- as.numeric(mu_vec + t(chol(Cov_mat + D_mat)) %*% rnorm(N))
# Set up constants
constants &lt;- list( nu = 0.5, Sigma_HP1 = 2 )
# Defaults: tau_model = "constant", sigma_model = "constant", mu_model = "constant",
# and Sigma_model = "constant"
Rmodel &lt;- nsgpModel(likelihood = "fullGP", constants = constants, coords = coords, data = data )
conf &lt;- configureMCMC(Rmodel)
Rmcmc &lt;- buildMCMC(conf)
Cmodel &lt;- compileNimble(Rmodel)
Cmcmc &lt;- compileNimble(Rmcmc, project = Rmodel)
samples &lt;- runMCMC(Cmcmc, niter = 200, nburnin = 100)
# Prediction
predCoords &lt;- as.matrix(expand.grid(seq(0,1,l=10),seq(0,1,l=10)))
postpred &lt;- nsgpPredict( model = Rmodel, samples = samples, coords.predict = predCoords )


</code></pre>

<hr>
<h2 id='orderCoordinatesMMD'>Order coordinates according to a maximum-minimum distance criterion.</h2><span id='topic+orderCoordinatesMMD'></span>

<h3>Description</h3>

<p><code>orderCoordinatesMMD</code> orders an array of (x,y) spatial coordinates 
according to the &quot;maximum minimum distance&quot; (MMD), as described in Guinness, 
2018. (Points are selected to maximize their minimum distance to already-
selected points).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orderCoordinatesMMD(coords, exact = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="orderCoordinatesMMD_+3A_coords">coords</code></td>
<td>
<p>N x 2 array of N 2-dimensional (x,y) spatial coordinates.</p>
</td></tr>
<tr><td><code id="orderCoordinatesMMD_+3A_exact">exact</code></td>
<td>
<p>Logical; <code>FALSE</code> uses a fast approximation to MMD ordering 
(and is almost always recommended), while <code>TRUE</code> uses exact MMD 
ordering but is infeasible for large number of locations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of distances matrices, with the following components:
</p>
<table>
<tr><td><code>orderedCoords</code></td>
<td>
<p>N x 2 matrix; contains the ordered spatial coordinates
as <code>coords</code>.</p>
</td></tr>
<tr><td><code>orderedIndicesNoNA</code></td>
<td>
<p>N-vector; contains the ordered indices with any
NA values removed.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>coords &lt;- cbind(runif(100), runif(100))
orderCoordinatesMMD(coords)

</code></pre>

<hr>
<h2 id='R_sparse_chol'>R_sparse_chol</h2><span id='topic+R_sparse_chol'></span>

<h3>Description</h3>

<p>R_sparse_chol
</p>


<h3>Usage</h3>

<pre><code class='language-R'>R_sparse_chol(i, j, x, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="R_sparse_chol_+3A_i">i</code></td>
<td>
<p>Vector of row indices.</p>
</td></tr>
<tr><td><code id="R_sparse_chol_+3A_j">j</code></td>
<td>
<p>Vector of column indices.</p>
</td></tr>
<tr><td><code id="R_sparse_chol_+3A_x">x</code></td>
<td>
<p>Vector of values in the matrix.</p>
</td></tr>
<tr><td><code id="R_sparse_chol_+3A_n">n</code></td>
<td>
<p>Length of the vector</p>
</td></tr>
</table>

<hr>
<h2 id='R_sparse_crossprod'>nimble_sparse_crossprod</h2><span id='topic+R_sparse_crossprod'></span>

<h3>Description</h3>

<p>nimble_sparse_crossprod
</p>


<h3>Usage</h3>

<pre><code class='language-R'>R_sparse_crossprod(i, j, x, z, n, subset = -1, transp = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="R_sparse_crossprod_+3A_i">i</code></td>
<td>
<p>Vector of row indices.</p>
</td></tr>
<tr><td><code id="R_sparse_crossprod_+3A_j">j</code></td>
<td>
<p>Vector of column indices.</p>
</td></tr>
<tr><td><code id="R_sparse_crossprod_+3A_x">x</code></td>
<td>
<p>Vector of values in the matrix.</p>
</td></tr>
<tr><td><code id="R_sparse_crossprod_+3A_z">z</code></td>
<td>
<p>Vector to calculate the cross-product with.</p>
</td></tr>
<tr><td><code id="R_sparse_crossprod_+3A_n">n</code></td>
<td>
<p>Length of the vector</p>
</td></tr>
<tr><td><code id="R_sparse_crossprod_+3A_subset">subset</code></td>
<td>
<p>Optional vector of rows to include in the calculation.</p>
</td></tr>
<tr><td><code id="R_sparse_crossprod_+3A_transp">transp</code></td>
<td>
<p>Optional indicator of using the transpose</p>
</td></tr>
</table>

<hr>
<h2 id='R_sparse_solve'>nimble_sparse_solve</h2><span id='topic+R_sparse_solve'></span>

<h3>Description</h3>

<p>nimble_sparse_solve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>R_sparse_solve(i, j, x, z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="R_sparse_solve_+3A_i">i</code></td>
<td>
<p>Vector of row indices.</p>
</td></tr>
<tr><td><code id="R_sparse_solve_+3A_j">j</code></td>
<td>
<p>Vector of column indices.</p>
</td></tr>
<tr><td><code id="R_sparse_solve_+3A_x">x</code></td>
<td>
<p>Vector of values in the matrix.</p>
</td></tr>
<tr><td><code id="R_sparse_solve_+3A_z">z</code></td>
<td>
<p>Vector to calculate the cross-product with.</p>
</td></tr>
</table>

<hr>
<h2 id='R_sparse_tcrossprod'>nimble_sparse_tcrossprod</h2><span id='topic+R_sparse_tcrossprod'></span>

<h3>Description</h3>

<p>nimble_sparse_tcrossprod
</p>


<h3>Usage</h3>

<pre><code class='language-R'>R_sparse_tcrossprod(i, j, x, subset = -1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="R_sparse_tcrossprod_+3A_i">i</code></td>
<td>
<p>Vector of row indices.</p>
</td></tr>
<tr><td><code id="R_sparse_tcrossprod_+3A_j">j</code></td>
<td>
<p>Vector of column indices.</p>
</td></tr>
<tr><td><code id="R_sparse_tcrossprod_+3A_x">x</code></td>
<td>
<p>Vector of values in the matrix.</p>
</td></tr>
<tr><td><code id="R_sparse_tcrossprod_+3A_subset">subset</code></td>
<td>
<p>Optional vector of rows to include in the calculation.</p>
</td></tr>
</table>

<hr>
<h2 id='rmnorm_nngp'>Function for the evaluating the NNGP approximate density.</h2><span id='topic+rmnorm_nngp'></span>

<h3>Description</h3>

<p><code>dmnorm_nngp</code> (and <code>rmnorm_nngp</code>) calculate the approximate NNGP
likelihood for a fixed set of parameters (i.e., A and D matrices). Finally,
the distributions must be registered within <code>nimble</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmnorm_nngp(n, mean, AD, nID, N, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmnorm_nngp_+3A_n">n</code></td>
<td>
<p>N-vector of data.</p>
</td></tr>
<tr><td><code id="rmnorm_nngp_+3A_mean">mean</code></td>
<td>
<p>N-vector with current values of the mean</p>
</td></tr>
<tr><td><code id="rmnorm_nngp_+3A_ad">AD</code></td>
<td>
<p>N x (k+1) matrix; the first k columns are the 'A' matrix, and the
last column is the 'D' vector.</p>
</td></tr>
<tr><td><code id="rmnorm_nngp_+3A_nid">nID</code></td>
<td>
<p>N x k matrix of neighbor indices.</p>
</td></tr>
<tr><td><code id="rmnorm_nngp_+3A_n">N</code></td>
<td>
<p>Scalar; number of data measurements.</p>
</td></tr>
<tr><td><code id="rmnorm_nngp_+3A_k">k</code></td>
<td>
<p>Scalar; number of nearest neighbors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The NNGP approximate density.
</p>

<hr>
<h2 id='rmnorm_sgv'>Function for the evaluating the SGV approximate density.</h2><span id='topic+rmnorm_sgv'></span>

<h3>Description</h3>

<p><code>dmnorm_sgv</code> (and <code>rmnorm_sgv</code>) calculate the approximate SGV
likelihood for a fixed set of parameters (i.e., the U matrix). Finally,
the distributions must be registered within <code>nimble</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmnorm_sgv(n, mean, U, N, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmnorm_sgv_+3A_n">n</code></td>
<td>
<p>Vector of measurements</p>
</td></tr>
<tr><td><code id="rmnorm_sgv_+3A_mean">mean</code></td>
<td>
<p>Vector of mean valiues</p>
</td></tr>
<tr><td><code id="rmnorm_sgv_+3A_u">U</code></td>
<td>
<p>Matrix of size N x 3; representation of a sparse N x N Cholesky
of the precision matrix. The first two columns contain row and column 
indices, respectively, and the last column is the nonzero elements of the
matrix.</p>
</td></tr>
<tr><td><code id="rmnorm_sgv_+3A_n">N</code></td>
<td>
<p>Number of measurements in x</p>
</td></tr>
<tr><td><code id="rmnorm_sgv_+3A_k">k</code></td>
<td>
<p>Number of neighbors for the SGV approximation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Not applicable.
</p>

<hr>
<h2 id='sgvSetup'>One-time setup wrapper function for the SGV approximation</h2><span id='topic+sgvSetup'></span>

<h3>Description</h3>

<p><code>sgvSetup</code> is a wrapper function that sets up the SGV approximation. 
Three objects are required: (1) ordering the locations, (2) identify nearest
neighbors, and (3) determine the conditioning set. This function only needs
to be run once per SGV analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sgvSetup(
  coords,
  coords_pred = NULL,
  k = 15,
  seed = NULL,
  pred.seed = NULL,
  order_coords = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sgvSetup_+3A_coords">coords</code></td>
<td>
<p>Matrix of observed locations.</p>
</td></tr>
<tr><td><code id="sgvSetup_+3A_coords_pred">coords_pred</code></td>
<td>
<p>Optional matrix of prediction locations.</p>
</td></tr>
<tr><td><code id="sgvSetup_+3A_k">k</code></td>
<td>
<p>Number of neighbors.</p>
</td></tr>
<tr><td><code id="sgvSetup_+3A_seed">seed</code></td>
<td>
<p>Setting the seed for reproducibility of the observed location
ordering</p>
</td></tr>
<tr><td><code id="sgvSetup_+3A_pred.seed">pred.seed</code></td>
<td>
<p>Setting the seed for reproducibility of the prediction 
ordering.</p>
</td></tr>
<tr><td><code id="sgvSetup_+3A_order_coords">order_coords</code></td>
<td>
<p>Logical; should the coordinates be ordered.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>ord</code></td>
<td>
<p>A vector of ordering position for the observed locations.</p>
</td></tr>
<tr><td><code>ord_pred</code></td>
<td>
<p>A vector of ordering position for the prediction 
locations (if <code>coords_pred</code> is provided).</p>
</td></tr>
<tr><td><code>ord_all</code></td>
<td>
<p>A concatenated vector of <code>ord</code> and <code>ord_pred</code>.</p>
</td></tr>
<tr><td><code>coords_ord</code></td>
<td>
<p>A matrix of ordered locations (observed and prediction),
included for convenience.</p>
</td></tr>
<tr><td><code>nID_ord</code></td>
<td>
<p>A matrix of (ordered) neighbor indices.</p>
</td></tr>
<tr><td><code>condition_on_y_ord</code></td>
<td>
<p>A matrix indicating whether the conditioning
set for each (ordered) location is on the latent process (y, <code>1</code>) or
the observed values (z, <code>0</code>).</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
