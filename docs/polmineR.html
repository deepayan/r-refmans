<!DOCTYPE html><html><head><title>Help for package polmineR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {polmineR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#polmineR-package'><p>polmineR-package</p></a></li>
<li><a href='#annotations'><p>Annotation functionality</p></a></li>
<li><a href='#as.markdown'><p>Get markdown-formatted full text of a partition.</p></a></li>
<li><a href='#as.sparseMatrix'><p>Type conversion - get sparseMatrix.</p></a></li>
<li><a href='#as.speeches'><p>Split corpus or partition into speeches.</p></a></li>
<li><a href='#as.TermDocumentMatrix'><p>Generate TermDocumentMatrix / DocumentTermMatrix.</p></a></li>
<li><a href='#as.VCorpus'><p>Get VCorpus.</p></a></li>
<li><a href='#blapply'><p>apply a function over a list or bundle</p></a></li>
<li><a href='#bundle-class'><p>Bundle Class</p></a></li>
<li><a href='#capitalize'><p>Capitalize character vector.</p></a></li>
<li><a href='#chisquare'><p>Perform chisquare-text.</p></a></li>
<li><a href='#context'><p>Analyze context of a node word.</p></a></li>
<li><a href='#context_bundle-class'><p>S4 context_bundle class</p></a></li>
<li><a href='#context-class'><p>Context class.</p></a></li>
<li><a href='#cooccurrences'><p>Get cooccurrence statistics.</p></a></li>
<li><a href='#cooccurrences-class'><p>Cooccurrences class.</p></a></li>
<li><a href='#Cooccurrences-class'><p>Cooccurrences class for corpus/partition.</p></a></li>
<li><a href='#Cooccurrences+2Ccorpus-method'><p>Get all cooccurrences in corpus/partition.</p></a></li>
<li><a href='#corpus-class'><p>Corpus class initialization</p></a></li>
<li><a href='#corpus-methods'><p>Corpus class methods</p></a></li>
<li><a href='#count'><p>Get counts.</p></a></li>
<li><a href='#count_class'><p>Count class.</p></a></li>
<li><a href='#cpos'><p>Get corpus positions for a query or queries.</p></a></li>
<li><a href='#cqp'><p>Tools for CQP queries.</p></a></li>
<li><a href='#decode-method'><p>Decode corpus or subcorpus.</p></a></li>
<li><a href='#dispersion'><p>Dispersion of a query or multiple queries.</p></a></li>
<li><a href='#dotplot'><p>dotplot</p></a></li>
<li><a href='#encoding'><p>Get and set encoding.</p></a></li>
<li><a href='#encodings'><p>Conversion between corpus and native encoding.</p></a></li>
<li><a href='#enrich'><p>Enrich an object.</p></a></li>
<li><a href='#features'><p>Get features by comparison.</p></a></li>
<li><a href='#features-class'><p>Feature selection by comparison.</p></a></li>
<li><a href='#get_template'><p>Get template for formatting full text output.</p></a></li>
<li><a href='#get_token_stream'><p>Get Token Stream.</p></a></li>
<li><a href='#get_type'><p>Get corpus/partition type.</p></a></li>
<li><a href='#highlight-method'><p>Highlight tokens in text output.</p></a></li>
<li><a href='#hits'><p>Get hits for query</p></a></li>
<li><a href='#hits_class'><p>S4 class to represent hits for queries.</p></a></li>
<li><a href='#href-function'><p>Add hypertext reference to html document.</p></a></li>
<li><a href='#html'><p>Generate html from object.</p></a></li>
<li><a href='#is_nested'><p>Check whether s-attributes of corpus are nested</p></a></li>
<li><a href='#kwic'><p>Perform keyword-in-context (KWIC) analysis.</p></a></li>
<li><a href='#kwic-class'><p>S4 kwic class</p></a></li>
<li><a href='#ll'><p>Compute Log-likelihood Statistics.</p></a></li>
<li><a href='#means'><p>calculate means</p></a></li>
<li><a href='#ngrams'><p>Get N-Grams</p></a></li>
<li><a href='#ngrams_class'><p>Ngrams class.</p></a></li>
<li><a href='#noise'><p>detect noise</p></a></li>
<li><a href='#ocpu_exec'><p>Execute code on OpenCPU server</p></a></li>
<li><a href='#p_attributes'><p>Get p-attributes.</p></a></li>
<li><a href='#partition'><p>Initialize a partition.</p></a></li>
<li><a href='#partition_bundle'><p>Generate bundle of partitions.</p></a></li>
<li><a href='#partition_bundle-class'><p>Bundle of partitions (partition_bundle class).</p></a></li>
<li><a href='#partition_class'><p>Partition class and methods.</p></a></li>
<li><a href='#partition_to_string'><p>Decode as String.</p></a></li>
<li><a href='#phrases-class'><p>Manage and use phrases</p></a></li>
<li><a href='#pmi'><p>Calculate Pointwise Mutual Information (PMI).</p></a></li>
<li><a href='#polmineR-defunct'><p>Defunct functionality</p></a></li>
<li><a href='#polmineR-generics'><p>Generic methods defined in the polmineR package</p></a></li>
<li><a href='#ranges'><p>Get ranges for query.</p></a></li>
<li><a href='#ranges-class'><p>Ranges of query matches.</p></a></li>
<li><a href='#read'><p>Display full text.</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#regions'><p>Regions of a CWB corpus.</p></a></li>
<li><a href='#registry_get_name'><p>Evaluate registry file.</p></a></li>
<li><a href='#registry_move'><p>Get registry and data directories.</p></a></li>
<li><a href='#registry_reset'><p>Reset registry directory.</p></a></li>
<li><a href='#renamed'><p>Renamed Functions</p></a></li>
<li><a href='#s_attributes'><p>Get s-attributes.</p></a></li>
<li><a href='#size'><p>Get Number of Tokens.</p></a></li>
<li><a href='#slice'><p>Virtual class slice.</p></a></li>
<li><a href='#subcorpus'><p>The S4 subcorpus class.</p></a></li>
<li><a href='#subcorpus_bundle-class'><p>Bundled subcorpora</p></a></li>
<li><a href='#subset-method'><p>Subsetting corpora and subcorpora</p></a></li>
<li><a href='#t_test'><p>Perform t-test.</p></a></li>
<li><a href='#terms'><p>Get terms in <code>partition</code> or <code>corpus</code>.</p></a></li>
<li><a href='#textstat-class'><p>S4 textstat superclass.</p></a></li>
<li><a href='#tooltips-method'><p>Add tooltips to text output.</p></a></li>
<li><a href='#tree_structure'><p>Show the structure of s-attributes</p></a></li>
<li><a href='#trim'><p>Trim an object.</p></a></li>
<li><a href='#use'><p>Add corpora in R data packages to session registry.</p></a></li>
<li><a href='#view'><p>Inspect object using View().</p></a></li>
<li><a href='#weigh'><p>Apply Weight to Matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Verbs and Nouns for Corpus Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.8.9</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-29</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, data.table (&ge; 1.12.2), fs, slam, Matrix, tm, DT,
xml2, stringi, utils, jsonlite, parallel, pbapply, RcppCWB (&ge;
0.6.2), magrittr, knitr, lifecycle, rlang, cli</td>
</tr>
<tr>
<td>Suggests:</td>
<td>markdown (&ge; 1.5), rmarkdown, htmltools (&ge; 0.4.0),
highlight, sendmailR, shiny, shinythemes, shinyjs, miniUI,
rhandsontable, testthat, tidytext, covr, igraph, NLP, httr,
protolite, curl</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Description:</td>
<td>Package for corpus analysis using the Corpus Workbench 
    ('CWB', <a href="https://cwb.sourceforge.io">https://cwb.sourceforge.io</a>) as an efficient back end for indexing
    and querying large corpora. The package offers functionality to flexibly create
    subcorpora and to carry out basic statistical operations (count, co-occurrences
    etc.). The original full text of documents can be reconstructed and inspected at
    any time. Beyond that, the package is intended to serve as an interface to 
    packages implementing advanced statistical procedures. Respective data structures
    (document-term matrices, term-co-occurrence matrices etc.) can be created based 
    on the indexed corpora.</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/PolMine/polmineR/issues">https://github.com/PolMine/polmineR/issues</a></td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/PolMine/polmineR">https://github.com/PolMine/polmineR</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Collate:</td>
<td>'polmineR.R' 'S4classes.R' 'p_attributes.R' 'textstat.R'
'bundle.R' 'corpus.R' 'count.R' 'partition.R'
'partition_bundle.R' 'ngrams.R' 'features.R' 'context.R'
'TermDocumentMatrix.R' 'annotations.R' 'as.VCorpus.R'
'as.markdown.R' 'kwic.R' 'decode.R' 'cooccurrences.R'
'as.sparseMatrix.R' 'as.speeches.R' 'blapply.R' 'coerce.R'
'hits.R' 'cpos.R' 'dispersion.R' 'dotplot.R' 'encoding.R'
'enrich.R' 'format.R' 'highlight.R' 'href.R' 'html.R' 'info.R'
'means.R' 'noise.R' 'opencpu.R' 'phrases.R'
'polmineR-defunct.R' 'ranges.R' 'regions.R' 'read.R'
'registry.R' 'reindex.R' 'renamed.R' 'restore.R'
's_attributes.R' 'size.R' 'split.R' 'stats.R' 'subset.R'
'templates.R' 'terms.R' 'token_stream.R' 'tooltips.R'
'tree_structure.R' 'trim.R' 'type.R' 'use.R' 'utils.R' 'view.R'
'weigh.R' 'zzz.R'</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-29 21:34:33 UTC; andreasblatte</td>
</tr>
<tr>
<td>Author:</td>
<td>Andreas Blaette <a href="https://orcid.org/0000-0001-8970-8010"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Christoph Leonhardt [ctb],
  Marius Bertram [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andreas Blaette &lt;andreas.blaette@uni-due.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-29 21:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='polmineR-package'>polmineR-package</h2><span id='topic+polmineR-package'></span><span id='topic+polmineR'></span>

<h3>Description</h3>

<p>A library for corpus analysis using the Corpus Workbench (CWB) as an
efficient back end for indexing and querying large corpora.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polmineR()
</code></pre>


<h3>Details</h3>

<p>The package offers functionality to flexibly create partitions and to carry
out basic statistical operations (count, co-occurrences etc.). The original
full text of documents can be reconstructed and inspected at any time. Beyond
that, the package is intended to serve as an interface to packages
implementing advanced statistical procedures. Respective data structures
(document term matrices, term co- occurrence matrices etc.) can be created
based on the indexed corpora.
</p>
<p>A session registry directory (see <code>registry()</code>) combines the registry
files for corpora that may reside in anywhere on the system. Upon loading
'polmineR', the files in the registry directory defined by the
environment variable CORPUS_REGISTRY are copied to the session registry
directory. To see whether the environment variable CORPUS_REGISTRY is set,
use the <code>Sys.getenv()</code>-function. Corpora wrapped in R data packages can be
activated using the function <code>use()</code>.
</p>
<p>The package includes a draft shiny app that can be called using
<code>polmineR()</code>.
</p>


<h3>Package options</h3>


<ul>
<li> <p><em>polmineR.p_attribute</em>: The default positional attribute.
</p>
</li>
<li> <p><em>polmineR.left</em>: Default value for left context.
</p>
</li>
<li> <p><em>polmineR.lineview</em>: A <code>logical</code> value to activate lineview output of
<code>kwic()</code>.
</p>
</li>
<li> <p><em>polmineR.pagelength</em>: Maximum number of lines to show when preparing output
using <code>DT::datatable()</code> (defaults to 10L).
</p>
</li>
<li> <p><em>polmineR.meta</em>: Default metadata (s-attributes) to show.
</p>
</li>
<li> <p><em>polmineR.mc</em>: Whether to use multiple cores.
</p>
</li>
<li> <p><em>polmineR.cores</em>: Number of cores to use. Passed as argument <code>cl</code> into
<code>mclapply()</code>.
</p>
</li>
<li> <p><em>polmineR.browse</em>: Whether to show output in browser.
</p>
</li>
<li> <p><em>polmineR.buttons</em>: A <code>logical</code> value, whether to display buttons when
preparing htmlwidget using <code>DT::datatable()</code>.
</p>
</li>
<li> <p><em>polmineR.specialChars</em>:
</p>
</li>
<li> <p><em>polmineR.cutoff</em>: Maximum number of characters to display when preparing
html output.
</p>
</li>
<li> <p><em>polmineR.mdsub</em>: A list of pairs of character vectors
defining regular expression substitutions applied as part of preprocessing
documents for html display. Intended usage: Remove characters that would be
misinterpreted as markdown formatting instructions.
</p>
</li>
<li> <p><em>polmineR.corpus_registry</em>: The system corpus registry
directory defined by the environment variable CORPUS_REGISTRY before the
polmineR package has been loaded. The polmineR package uses a temporary
registry directory to be able to use corpora stored at multiple
locations in one session. The path to the system corpus registry directory
captures this setting to keep it available if necessary.
</p>
</li>
<li> <p><em>polmineR.shiny</em>: A <code>logical</code> value, whether polmineR is
used in the context of a shiny app. Used to control the apprearance of
progress bars depending on whether shiny app is running, or not.
</p>
</li>
<li> <p><em>polmineR.warn.size</em>: When generating HTML table widgets (e.g.
when preparing kwic output to be displayed in RStudio's Viewe pane), the
function <code>DT::datatable()</code> that is used internally will issue a
warning by default if the object size of the table is greater than 1500000.
The warning adresses a client-server scenario that is not applicable in the
context of a local RStudio session, so you may want to turn it of.
Internally, the warning can be suppressed by setting the option
&quot;DT.warn.size&quot; to <code>FALSE</code>. The polmineR option
&quot;polmineR.warn.size&quot; is processed by functions calling DT::datatable()
to set and reset the value of &quot;DT.warn.size&quot;. Please note: The
formulation of the warning does not match the scenario of a local RStudio
session, but it may still be useful to get a warning when tables are large
and slow to process. Therefore, the default value of the setting is
<code>FALSE</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Andreas Blaette (andreas.blaette@uni-due.de)
</p>


<h3>References</h3>

<p>Jockers, Matthew L. (2014): <em>Text Analysis with R for Students of Literature</em>.
Cham et al: Springer.
</p>
<p>Baker, Paul (2006): <em>Using Corpora in Discourse Analysis</em>. London: continuum.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The REUTERS corpus included in the RcppCWB package is used in examples
use(pkg = "RcppCWB", corpus = "REUTERS") # activate REUTERS corpus
r &lt;- corpus("REUTERS")
if (interactive()) show_info(r)

# The package includes GERMAPARLMINI as sample data
use("polmineR") # activate GERMAPARLMINI
gparl &lt;- corpus("GERMAPARLMINI")
if (interactive()) show_info(gparl)

# Core methods

count("REUTERS", query = "oil")
count("REUTERS", query = c("oil", "barrel"))
count("REUTERS", query = '"Saudi" "Arab.*"', breakdown = TRUE, cqp = TRUE)
dispersion("REUTERS", query = "oil", s_attribute = "id")
k &lt;- kwic("REUTERS", query = "oil")
coocs &lt;- cooccurrences("REUTERS", query = "oil")


# Core methods applied to partition

kuwait &lt;- partition("REUTERS", places = "kuwait", regex = TRUE)
C &lt;- count(kuwait, query = "oil")
D &lt;- dispersion(kuwait, query = "oil", s_attribute = "id")
K &lt;- kwic(kuwait, query = "oil", meta = "id")
CO &lt;- cooccurrences(kuwait, query = "oil")


# Go back to full text

p &lt;- partition("REUTERS", id = 127)
if (interactive()) read(p)
h &lt;- html(p) %&gt;%
  highlight(highlight = list(yellow = "oil"))
if (interactive()) h_highlighted


# Generate term document matrix (not run by default to save time)

pb &lt;- partition_bundle("REUTERS", s_attribute = "id")
cnt &lt;- count(pb, p_attribute = "word")
tdm &lt;- as.TermDocumentMatrix(cnt, col = "count")

</code></pre>

<hr>
<h2 id='annotations'>Annotation functionality</h2><span id='topic+annotations'></span><span id='topic+annotations+2Ckwic-method'></span><span id='topic+annotations+2Ctextstat-method'></span><span id='topic+annotations+3C-'></span><span id='topic+annotations+3C-+2Ckwic+2Clist-method'></span><span id='topic+annotations+3C-+2Ctextstat+2Clist-method'></span><span id='topic+edit+2Ctextstat-method'></span>

<h3>Description</h3>

<p>Objects that contain analytical results (<code>kwic</code> objects, objects
inheriting from the <code>textstat</code> class) can be annotated by creating an
annotation layer using the <code>annotations</code>-method. The augmented object
can be annotated using a shiny gadget by invoking the <code>edit</code>-method on
it. Note that operations are deliberately in-place, to prevent an unwanted
loss of work.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>annotations(x, ...)

## S4 method for signature 'kwic'
annotations(x, i, j, value)

## S4 method for signature 'textstat'
annotations(x, i, j, value)

annotations(x) &lt;- value

## S4 replacement method for signature 'kwic,list'
annotations(x) &lt;- value

## S4 replacement method for signature 'textstat,list'
annotations(x) &lt;- value

## S4 method for signature 'textstat'
edit(name, viewer = shiny::paneViewer(minHeight = 550), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="annotations_+3A_x">x</code></td>
<td>
<p>An object to be annotated, a <code>kwic</code> class object, or an object
inheriting from the <code>textstat</code> class.</p>
</td></tr>
<tr><td><code id="annotations_+3A_...">...</code></td>
<td>
<p>Passed into <code>rhandsontable::rhandsontable</code>, can be used for
settings such as <code>height</code> etc.</p>
</td></tr>
<tr><td><code id="annotations_+3A_i">i</code></td>
<td>
<p>The row number (single <code>integer</code> value) of the
<code>data.table</code> where a new value shall be assigned.</p>
</td></tr>
<tr><td><code id="annotations_+3A_j">j</code></td>
<td>
<p>The column number (single <code>integer</code> value) of the
<code>data.table</code> where a new value shall be assigned.</p>
</td></tr>
<tr><td><code id="annotations_+3A_value">value</code></td>
<td>
<p>A value to assign.</p>
</td></tr>
<tr><td><code id="annotations_+3A_name">name</code></td>
<td>
<p>An S4 object to be annotated.</p>
</td></tr>
<tr><td><code id="annotations_+3A_viewer">viewer</code></td>
<td>
<p>The viewer to use, see <code><a href="shiny.html#topic+viewer">viewer</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>edit</code>-method is designed to be used in a RStudio session. It
generates a shiny gadget (see
<a href="https://shiny.rstudio.com/articles/gadgets.html">https://shiny.rstudio.com/articles/gadgets.html</a>) shown in the viewer
pane of RStudio.
</p>
<p>The <code>edit</code>-method returns the modified input object. Note however that
changes of annotations are deliberately in-place operations: The input object
is changed even if you do not close the gadget &quot;properly&quot; by hitting the
&quot;Done&quot; button and catch the modified object. That may be forgotten easily and
would be painful after the work that may have been invested.
</p>
<p>Consult the examples for the intended workflow.
</p>


<h3>Value</h3>

<p>The modified input object is returned invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>use(pkg = "RcppCWB", corpus = "REUTERS")

a &lt;- 2
# upon initializing a kwic object, there is a minimal labels object
# in the labels slot of the kwic object, which we can get using the
# annotations-method
o &lt;- kwic("REUTERS", query = "oil")
annotations(o) # see the result (a data.table)

# assign new annotations as follows, using the reference semantics of the
# data.table you get by calling the labels-method on an object 
annotations(o) &lt;- list(name = "class", what = factor(x = "a", levels = c("a", "b", "c")))
annotations(o) &lt;- list(name = "description", what = "")
annotations(o) # inspect the result

# assign values; note that is an in-place operation using the reference
# semantics of the data.table
# annotations(o, i = 77, j = 1, value = FALSE)
# annotations(o, i = 78, j = 1, value = FALSE)
annotations(o)

## Not run: 
edit(o)
annotations(o) # to see changes made

# maybe we want additional metadata
enrich(o, s_attributes = "places")
edit(o)
annotations(o)

# to get some extra context
o &lt;- enrich(o, extra = 5L, table = TRUE)
edit(o)

# lineview may be better when you use a lot of extra context
options(polmineR.lineview = TRUE)
o &lt;- kwic("REUTERS", "oil")
o &lt;- enrich(o, extra = 20L)
edit(o)

x &lt;- cooccurrences("REUTERS", query = "oil")
annotations(x) &lt;- list(name = "keep", what = TRUE)
annotations(x) &lt;- list(name = "category", what = factor("a", levels = letters[1:10]))
edit(x)

## End(Not run)
</code></pre>

<hr>
<h2 id='as.markdown'>Get markdown-formatted full text of a partition.</h2><span id='topic+as.markdown'></span><span id='topic+as.markdown+2Cpartition-method'></span><span id='topic+as.markdown+2Csubcorpus-method'></span><span id='topic+as.markdown+2Cplpr_partition-method'></span><span id='topic+as.markdown+2Cplpr_subcorpus-method'></span>

<h3>Description</h3>

<p>The method is the worker behind the <code>read()</code>-method, which will be called
usually to reconstruct the full text of a <code>partition</code> and read it. The
<code>as.markdown()</code>-method can be customized for different classes inheriting
from the <code>partition</code>-class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.markdown(.Object, ...)

## S4 method for signature 'partition'
as.markdown(
  .Object,
  meta = getOption("polmineR.meta"),
  template = get_template(.Object),
  cpos = TRUE,
  cutoff = NULL,
  verbose = FALSE,
  ...
)

## S4 method for signature 'subcorpus'
as.markdown(
  .Object,
  meta = getOption("polmineR.meta"),
  template = get_template(.Object),
  cpos = TRUE,
  cutoff = NULL,
  verbose = FALSE,
  ...
)

## S4 method for signature 'plpr_partition'
as.markdown(
  .Object,
  meta = NULL,
  template = get_template(.Object),
  cpos = FALSE,
  interjections = TRUE,
  cutoff = NULL,
  ...
)

## S4 method for signature 'plpr_subcorpus'
as.markdown(
  .Object,
  meta = NULL,
  template = get_template(.Object),
  cpos = FALSE,
  interjections = TRUE,
  cutoff = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.markdown_+3A_.object">.Object</code></td>
<td>
<p>The object to be converted, a <code>partition</code>, or a class
inheriting from <code>partition</code>, such as <code>plpr_partition</code>.</p>
</td></tr>
<tr><td><code id="as.markdown_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
<tr><td><code id="as.markdown_+3A_meta">meta</code></td>
<td>
<p>The metainformation (s-attributes) to be displayed.</p>
</td></tr>
<tr><td><code id="as.markdown_+3A_template">template</code></td>
<td>
<p>A template for formating output.</p>
</td></tr>
<tr><td><code id="as.markdown_+3A_cpos">cpos</code></td>
<td>
<p>A <code>logical</code> value, whether to add cpos as ids in span elements.</p>
</td></tr>
<tr><td><code id="as.markdown_+3A_cutoff">cutoff</code></td>
<td>
<p>The maximum number of tokens to reconstruct, to avoid that full
text is excessively long.</p>
</td></tr>
<tr><td><code id="as.markdown_+3A_verbose">verbose</code></td>
<td>
<p>A <code>logical</code> value, whether to output messages.</p>
</td></tr>
<tr><td><code id="as.markdown_+3A_interjections">interjections</code></td>
<td>
<p>A <code>logical</code> value, whether to format interjections.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>use(pkg = "RcppCWB", corpus = "REUTERS")

P &lt;- partition("REUTERS", places = "argentina")
as.markdown(P)
as.markdown(P, meta = c("id", "places"))
if (interactive()) read(P, meta = c("id", "places"))
</code></pre>

<hr>
<h2 id='as.sparseMatrix'>Type conversion - get sparseMatrix.</h2><span id='topic+as.sparseMatrix'></span><span id='topic+as.sparseMatrix+2Csimple_triplet_matrix-method'></span><span id='topic+as.sparseMatrix+2CTermDocumentMatrix-method'></span><span id='topic+as.sparseMatrix+2CDocumentTermMatrix-method'></span><span id='topic+as.sparseMatrix+2Cbundle-method'></span>

<h3>Description</h3>

<p>Turn objects into the sparseMatrix as defined in the Matrix package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.sparseMatrix(x, ...)

## S4 method for signature 'simple_triplet_matrix'
as.sparseMatrix(x, ...)

## S4 method for signature 'TermDocumentMatrix'
as.sparseMatrix(x, ...)

## S4 method for signature 'DocumentTermMatrix'
as.sparseMatrix(x, ...)

## S4 method for signature 'bundle'
as.sparseMatrix(x, col, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.sparseMatrix_+3A_x">x</code></td>
<td>
<p>object to convert</p>
</td></tr>
<tr><td><code id="as.sparseMatrix_+3A_...">...</code></td>
<td>
<p>Further arguments that are passed to a call to
<code>sparseMatrix</code>. Can be used, for instance to set <code>giveCsparse</code> to
<code>FALSE</code> to get a <code>dgTMatrix</code>, not a <code>dgCMatrix</code>.</p>
</td></tr>
<tr><td><code id="as.sparseMatrix_+3A_col">col</code></td>
<td>
<p>column name to get values from (if x is a bundle)</p>
</td></tr>
</table>

<hr>
<h2 id='as.speeches'>Split corpus or partition into speeches.</h2><span id='topic+as.speeches'></span><span id='topic+as.speeches+2Cpartition-method'></span><span id='topic+as.speeches+2Csubcorpus-method'></span><span id='topic+as.speeches+2Ccorpus-method'></span><span id='topic+as.speeches+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Split entire corpus or a partition into speeches. The heuristic is to split
the corpus/partition into partitions on day-to-day basis first, using the
s-attribute provided by <code>s_attribute_date</code>. These subcorpora are then
splitted into speeches by speaker name, using s-attribute <code>s_attribute_name</code>.
If there is a gap larger than the number of tokens supplied by argument
<code>gap</code>, contributions of a speaker are assumed to be two seperate speeches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.speeches(.Object, ...)

## S4 method for signature 'partition'
as.speeches(
  .Object,
  s_attribute_date = grep("date", s_attributes(.Object), value = TRUE),
  s_attribute_name = grep("name", s_attributes(.Object), value = TRUE),
  gap = 500,
  mc = FALSE,
  verbose = TRUE,
  progress = TRUE
)

## S4 method for signature 'subcorpus'
as.speeches(
  .Object,
  s_attribute_date = grep("date", s_attributes(.Object), value = TRUE),
  s_attribute_name = grep("name", s_attributes(.Object), value = TRUE),
  gap = 500,
  mc = FALSE,
  verbose = TRUE,
  progress = TRUE
)

## S4 method for signature 'corpus'
as.speeches(
  .Object,
  s_attribute_date = grep("date", s_attributes(.Object), value = TRUE),
  s_attribute_name = grep("name", s_attributes(.Object), value = TRUE),
  gap = 500,
  subset,
  mc = FALSE,
  verbose = TRUE,
  progress = TRUE
)

## S4 method for signature 'character'
as.speeches(
  .Object,
  s_attribute_date = grep("date", s_attributes(.Object), value = TRUE),
  s_attribute_name = grep("name", s_attributes(.Object), value = TRUE),
  gap = 500,
  mc = FALSE,
  verbose = TRUE,
  progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.speeches_+3A_.object">.Object</code></td>
<td>
<p>A <code>partition</code>, or length-one <code>character</code> vector indicating a
CWB corpus.</p>
</td></tr>
<tr><td><code id="as.speeches_+3A_...">...</code></td>
<td>
<p>Further arguments.</p>
</td></tr>
<tr><td><code id="as.speeches_+3A_s_attribute_date">s_attribute_date</code></td>
<td>
<p>A length-one <code>character</code> vector, the s-attribute that
provides the dates of sessions.</p>
</td></tr>
<tr><td><code id="as.speeches_+3A_s_attribute_name">s_attribute_name</code></td>
<td>
<p>A length-one <code>character</code> vector, the s-attribute that
provides the names of speakers.</p>
</td></tr>
<tr><td><code id="as.speeches_+3A_gap">gap</code></td>
<td>
<p>An <code>integer</code> value, the number of tokens between strucs
assumed to make the difference whether a speech has been interrupted (by an
interjection or question), or whether to assume seperate speeches.</p>
</td></tr>
<tr><td><code id="as.speeches_+3A_mc">mc</code></td>
<td>
<p>Whether to use multicore, defaults to <code>FALSE</code>. If <code>progress</code> is
<code>TRUE</code>, argument <code>mc</code> is passed into <code>pblapply</code> as argument <code>cl</code>. If
<code>progress</code> is <code>FALSE</code>, <code>mc</code> is passed into <code>mclapply()</code> as argument
<code>mc.cores</code>.</p>
</td></tr>
<tr><td><code id="as.speeches_+3A_verbose">verbose</code></td>
<td>
<p>A <code>logical</code> value, defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="as.speeches_+3A_progress">progress</code></td>
<td>
<p>A <code>logical</code> value, whether to show progress bar.</p>
</td></tr>
<tr><td><code id="as.speeches_+3A_subset">subset</code></td>
<td>
<p>A <code>logical</code> expression evaluated in a temporary <code>data.table</code>
with columns 'speaker' and 'date' to define a subset of the entire corpus
to be turned into speeches. Usually faster than applying <code>as.speeches()</code> on
a <code>partition</code> or <code>subcorpus</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>partition_bundle</code>, the names of the objects in the bundle are
the speaker name, the date of the speech and an index for the number of the
speech on a given day, concatenated by underscores.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
use("polmineR")
speeches &lt;- as.speeches(
  "GERMAPARLMINI",
  s_attribute_date = "date", s_attribute_name = "speaker"
)
speeches_count &lt;- count(speeches, p_attribute = "word")
tdm &lt;- as.TermDocumentMatrix(speeches_count, col = "count")

bt &lt;- partition("GERMAPARLMINI", date = "2009-10-27")
speeches &lt;- as.speeches(
  bt, 
  s_attribute_name = "speaker",
  s_attribute_date = "date"
)
summary(speeches)

## End(Not run)
## Not run: 
#' sp &lt;- corpus("GERMAPARLMINI") %&gt;%
  as.speeches(s_attribute_name = "speaker", s_attribute_date = "date")

sp &lt;- corpus("GERMAPARLMINI") %&gt;%
  as.speeches(
    s_attribute_name = "speaker",
    s_attribute_date = "date",
    subset = {date == as.Date("2009-11-11")},
    progress = FALSE
  )
  
sp &lt;- corpus("GERMAPARLMINI") %&gt;%
  as.speeches(
    s_attribute_name = "speaker",
    s_attribute_date = "date",
    subset = {date == "2009-11-10" &amp; grepl("Merkel", speaker)},
    progress = FALSE
  )

## End(Not run)

</code></pre>

<hr>
<h2 id='as.TermDocumentMatrix'>Generate TermDocumentMatrix / DocumentTermMatrix.</h2><span id='topic+as.TermDocumentMatrix'></span><span id='topic+as.DocumentTermMatrix'></span><span id='topic+as.TermDocumentMatrix+2Ccharacter-method'></span><span id='topic+as.DocumentTermMatrix+2Ccorpus-method'></span><span id='topic+as.DocumentTermMatrix+2Ccharacter-method'></span><span id='topic+as.TermDocumentMatrix+2Cbundle-method'></span><span id='topic+as.DocumentTermMatrix+2Cbundle-method'></span><span id='topic+as.DocumentTermMatrix+2Cpartition_bundle-method'></span><span id='topic+as.TermDocumentMatrix+2Cpartition_bundle-method'></span><span id='topic+as.TermDocumentMatrix+2Csubcorpus_bundle-method'></span><span id='topic+as.DocumentTermMatrix+2Csubcorpus_bundle-method'></span><span id='topic+as.DocumentTermMatrix+2Ccontext-method'></span><span id='topic+as.TermDocumentMatrix+2Ccontext-method'></span>

<h3>Description</h3>

<p>Methods to generate the classes <code>TermDocumentMatrix</code> or
<code>DocumentTermMatrix</code> as defined in the <code>tm</code> package.  There are
many text mining applications for document-term matrices. A
<code>DocumentTermMatrix</code> is required as input by the <code>topicmodels</code>
package, for instance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.TermDocumentMatrix(x, ...)

as.DocumentTermMatrix(x, ...)

## S4 method for signature 'character'
as.TermDocumentMatrix(x, p_attribute, s_attribute, verbose = TRUE, ...)

## S4 method for signature 'corpus'
as.DocumentTermMatrix(
  x,
  p_attribute,
  s_attribute,
  stoplist = NULL,
  binarize = FALSE,
  verbose = TRUE,
  ...
)

## S4 method for signature 'character'
as.DocumentTermMatrix(x, p_attribute, s_attribute, verbose = TRUE, ...)

## S4 method for signature 'bundle'
as.TermDocumentMatrix(x, col, p_attribute = NULL, verbose = TRUE, ...)

## S4 method for signature 'bundle'
as.DocumentTermMatrix(x, col = NULL, p_attribute = NULL, verbose = TRUE, ...)

## S4 method for signature 'partition_bundle'
as.DocumentTermMatrix(x, p_attribute = NULL, col = NULL, verbose = TRUE, ...)

## S4 method for signature 'partition_bundle'
as.TermDocumentMatrix(x, p_attribute = NULL, col = NULL, verbose = TRUE, ...)

## S4 method for signature 'subcorpus_bundle'
as.TermDocumentMatrix(x, p_attribute = NULL, verbose = TRUE, ...)

## S4 method for signature 'subcorpus_bundle'
as.DocumentTermMatrix(x, p_attribute = NULL, verbose = TRUE, ...)

## S4 method for signature 'partition_bundle'
as.DocumentTermMatrix(x, p_attribute = NULL, col = NULL, verbose = TRUE, ...)

## S4 method for signature 'context'
as.DocumentTermMatrix(x, p_attribute, verbose = TRUE, ...)

## S4 method for signature 'context'
as.TermDocumentMatrix(x, p_attribute, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.TermDocumentMatrix_+3A_x">x</code></td>
<td>
<p>A <code>character</code> vector indicating a corpus, or an object of class
<code>bundle</code>, or inheriting from class <code>bundle</code> (e.g. <code>partition_bundle</code>).</p>
</td></tr>
<tr><td><code id="as.TermDocumentMatrix_+3A_...">...</code></td>
<td>
<p>Definitions of s-attribute used for subsetting the corpus, compare
partition-method.</p>
</td></tr>
<tr><td><code id="as.TermDocumentMatrix_+3A_p_attribute">p_attribute</code></td>
<td>
<p>A p-attribute counting is be based on.</p>
</td></tr>
<tr><td><code id="as.TermDocumentMatrix_+3A_s_attribute">s_attribute</code></td>
<td>
<p>An s-attribute that defines content of columns, or rows.</p>
</td></tr>
<tr><td><code id="as.TermDocumentMatrix_+3A_verbose">verbose</code></td>
<td>
<p>A <code>logial</code> value, whether to output progress messages.</p>
</td></tr>
<tr><td><code id="as.TermDocumentMatrix_+3A_stoplist">stoplist</code></td>
<td>
<p>A <code>character</code> vector of tokens to exclude from the matrix, as
memory efficient way to exclude irrelevant terms early on.</p>
</td></tr>
<tr><td><code id="as.TermDocumentMatrix_+3A_binarize">binarize</code></td>
<td>
<p>A <code>logical</code> value. If <code>TRUE</code>, report occurence of term, not
absoulte count.</p>
</td></tr>
<tr><td><code id="as.TermDocumentMatrix_+3A_col">col</code></td>
<td>
<p>The column of <code>data.table</code> in slot <code>stat</code> (if <code>x</code>
is a <code>bundle</code>) to use of assembling the matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> refers to a corpus (i.e. is a length 1 character vector), a
<code>TermDocumentMatrix</code>, or <code>DocumentTermMatrix</code> will be generated for
subsets of the corpus based on the <code>s_attribute</code> provided. Counts are
performed for the <code>p_attribute</code>. Further parameters provided (passed in
as <code>...</code> are interpreted as s-attributes that define a subset of the
corpus for splitting it according to <code>s_attribute</code>. If struc values for
<code>s_attribute</code> are not unique, the necessary aggregation is performed, slowing
things somewhat down.
</p>
<p>If <code>x</code> is a <code>bundle</code> or a class inheriting from it, the counts or
whatever measure is present in the <code>stat</code> slots (in the column
indicated by <code>col</code>) will be turned into the values of the sparse
matrix that is generated. A special case is the generation of the sparse
matrix based on a <code>partition_bundle</code> that does not yet include counts.
In this case, a <code>p_attribute</code> needs to be provided. Then counting will
be performed, too.
</p>
<p>If <code>x</code> is a <code>partition_bundle</code>, and argument <code>col</code> is
not <code>NULL</code>, as <code>TermDocumentMatrix</code> is generated based on the
column indicated by <code>col</code> of the <code>data.table</code> with counts in the
<code>stat</code> slots of the objects in the bundle. If <code>col</code> is
<code>NULL</code>, the p-attribute indicated by <code>p_attribute</code> is decoded,
and a count is performed to obtain the values of the resulting
<code>TermDocumentMatrix</code>. The same procedure applies to get a
<code>DocumentTermMatrix</code>.
</p>
<p>If <code>x</code> is a <code>subcorpus_bundle</code>, the p-attribute provided
by argument <code>p_attribute</code> is decoded, and a count is performed to
obtain the resulting <code>TermDocumentMatrix</code> or
<code>DocumentTermMatrix</code>.
</p>


<h3>Value</h3>

<p>A <code>TermDocumentMatrix</code>, or a <code>DocumentTermMatrix</code> object.
These classes are defined in the <code>tm</code> package, and inherit from the
<code>simple_triplet_matrix</code>-class defined in the <code>slam</code>-package.
</p>


<h3>Author(s)</h3>

<p>Andreas Blaette
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples not run by default to save time on CRAN test machines

#' use(pkg = "RcppCWB", corpus = "REUTERS")
 
# enriching partition_bundle explicitly 
tdm &lt;- corpus("REUTERS") %&gt;% 
  partition_bundle(s_attribute = "id") %&gt;% 
  enrich(p_attribute = "word") %&gt;%
  as.TermDocumentMatrix(col = "count")
   
# leave the counting to the as.TermDocumentMatrix-method
tdm &lt;- partition_bundle("REUTERS", s_attribute = "id") %&gt;% 
  as.TermDocumentMatrix(p_attribute = "word", verbose = FALSE)
  
# obtain TermDocumentMatrix directly (fastest option)
tdm &lt;- as.TermDocumentMatrix(
  "REUTERS",
  p_attribute = "word",
  s_attribute = "id",
  verbose = FALSE
)

# workflow using split()
dtm &lt;- corpus("REUTERS") %&gt;%
  split(s_attribute = "id") %&gt;%
  as.TermDocumentMatrix(p_attribute = "word")

</code></pre>

<hr>
<h2 id='as.VCorpus'>Get VCorpus.</h2><span id='topic+as.VCorpus'></span><span id='topic+as.VCorpus+2Cpartition_bundle-method'></span><span id='topic+as'></span>

<h3>Description</h3>

<p>Retrieve full text for the subcorpora or<code>partition</code> objects in a
<code>subcorpus_bundle</code> or <code>partition_bundle</code> and generate a
<code>VCorpus</code>-class object from the <code>tm</code>-package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'partition_bundle'
as.VCorpus(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.VCorpus_+3A_x">x</code></td>
<td>
<p>A <code>partition_bundle</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>VCorpus</code> class of the <code>tm</code>-package offers an interface to
access the functionality of the <code>tm</code>-package. Note however that
generating a <code>VCorpus</code> to get a <code>DocumentTermMatrix</code>, or a
<code>TermDocumentMatrix</code> is a highly inefficient detour. Applying the
<code>as.DocumentTermMatrix</code> or <code>as.TermDocumentMatrix</code> methods on a
<code>partition_bundle</code> is the recommended approach.
</p>
<p>If the <code>tm</code>-package has been loaded, the <code>as.VCorpus</code>-method
included in the <code>polmineR</code>-package may become inaccessible. To deal with
this (propable) scenario, it is possible to use a coerce-method
(<code>as(YOUROBJECT, "VCorpus")</code>), see examples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>use(pkg = "RcppCWB", corpus = "REUTERS")

pb &lt;- corpus("REUTERS") %&gt;%
  partition_bundle(s_attribute = "id")
 
vc &lt;- as.VCorpus(pb) # works only, if tm-package has not yet been loaded
vc &lt;- as(pb, "VCorpus") # will work if tm-package has been loaded, too

vc &lt;- corpus("REUTERS") %&gt;%
  split(s_attribute = "id") %&gt;%
  as("VCorpus")
</code></pre>

<hr>
<h2 id='blapply'>apply a function over a list or bundle</h2><span id='topic+blapply'></span><span id='topic+blapply+2Clist-method'></span><span id='topic+blapply+2Cvector-method'></span><span id='topic+blapply+2Cbundle-method'></span>

<h3>Description</h3>

<p>Very similar to lapply, but applicable to bundle-objects, in particular.
The purpose of the method is to supply a uniform und convenient parallel
backend for the polmineR package. In particular, progress bars are supported
(the naming of the method is derived from bla bla).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blapply(x, ...)

## S4 method for signature 'list'
blapply(x, f, mc = TRUE, progress = TRUE, verbose = FALSE, ...)

## S4 method for signature 'vector'
blapply(x, f, mc = FALSE, progress = TRUE, verbose = FALSE, ...)

## S4 method for signature 'bundle'
blapply(x, f, mc = FALSE, progress = TRUE, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blapply_+3A_x">x</code></td>
<td>
<p>a list or a bundle object</p>
</td></tr>
<tr><td><code id="blapply_+3A_...">...</code></td>
<td>
<p>further parameters</p>
</td></tr>
<tr><td><code id="blapply_+3A_f">f</code></td>
<td>
<p>a function that can be applied to each object contained in the
bundle, note that it should swallow the parameters mc, verbose and progress
(use ... to catch these params )</p>
</td></tr>
<tr><td><code id="blapply_+3A_mc">mc</code></td>
<td>
<p>logical, whether to use multicore - if TRUE, the number of cores
will be taken from the polmineR-options</p>
</td></tr>
<tr><td><code id="blapply_+3A_progress">progress</code></td>
<td>
<p>logical, whether to display progress bar</p>
</td></tr>
<tr><td><code id="blapply_+3A_verbose">verbose</code></td>
<td>
<p>logical, whether to print intermediate messages</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>use("polmineR")
bt &lt;- partition("GERMAPARLMINI", date = ".*", regex=TRUE)
speeches &lt;- as.speeches(bt, s_attribute_date = "date", s_attribute_name = "speaker")
foo &lt;- blapply(speeches, function(x, ...) slot(x, "cpos"))
</code></pre>

<hr>
<h2 id='bundle-class'>Bundle Class</h2><span id='topic+bundle-class'></span><span id='topic+bundle'></span><span id='topic++5B+5B+2Cbundle-method'></span><span id='topic++5B+5B+3C-+2Cbundle-method'></span><span id='topic+name+3C-+2Cbundle-method'></span><span id='topic+length+2Cbundle-method'></span><span id='topic+names+2Cbundle-method'></span><span id='topic+names+3C-+2Cbundle+2Cvector-method'></span><span id='topic+unique+2Cbundle-method'></span><span id='topic++2B+2Cbundle+2Cbundle-method'></span><span id='topic++2B+2Cbundle+2Ctextstat-method'></span><span id='topic++5B+2Cbundle+2CANY+2CANY+2CANY-method'></span><span id='topic++24+2Cbundle-method'></span><span id='topic++24+3C-+2Cbundle-method'></span><span id='topic+sample+2Cbundle-method'></span><span id='topic+as.bundle+2Clist-method'></span><span id='topic+as.bundle+2Ctextstat-method'></span><span id='topic+as.data.table.bundle'></span><span id='topic+as.matrix+2Cbundle-method'></span><span id='topic+subset+2Cbundle-method'></span><span id='topic+as.list+2Cbundle-method'></span><span id='topic+as.list.bundle'></span><span id='topic+get_corpus+2Cbundle-method'></span>

<h3>Description</h3>

<p>A <code>bundle</code> is used to combine several objects (<code>partition</code>, <code>context</code>,
<code>features</code>, <code>cooccurrences</code> objects) into one S4 class object. Typically, a
class inheriting from the <code>bundle</code> superclass will be used. When working with
a <code>context_bundle</code>, a <code>features_bundle</code>, a <code>cooccurrences_bundle</code>, or a
<code>context_bundle</code>, a similar set of standard methods is available to perform
transformations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 replacement method for signature 'bundle'
name(x) &lt;- value

## S4 method for signature 'bundle'
length(x)

## S4 method for signature 'bundle'
names(x)

## S4 replacement method for signature 'bundle,vector'
names(x) &lt;- value

## S4 method for signature 'bundle'
unique(x)

## S4 method for signature 'bundle,bundle'
e1 + e2

## S4 method for signature 'bundle,textstat'
e1 + e2

## S4 method for signature 'bundle'
x[[i]]

## S4 method for signature 'bundle,ANY,ANY,ANY'
x[i]

## S4 replacement method for signature 'bundle'
x[[i]] &lt;- value

## S4 method for signature 'bundle'
x$name

## S4 replacement method for signature 'bundle'
x$name &lt;- value

## S4 method for signature 'bundle'
sample(x, size)

## S4 method for signature 'list'
as.bundle(object, ...)

## S4 method for signature 'textstat'
as.bundle(object)

## S3 method for class 'bundle'
as.data.table(x, keep.rownames, col, ...)

## S4 method for signature 'bundle'
as.matrix(x, col)

## S4 method for signature 'bundle'
subset(x, ...)

## S4 method for signature 'bundle'
as.list(x)

## S3 method for class 'bundle'
as.list(x, ...)

## S4 method for signature 'bundle'
get_corpus(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bundle-class_+3A_x">x</code></td>
<td>
<p>a bundle object</p>
</td></tr>
<tr><td><code id="bundle-class_+3A_value">value</code></td>
<td>
<p>character string with a name to be assigned</p>
</td></tr>
<tr><td><code id="bundle-class_+3A_e1">e1</code></td>
<td>
<p>object 1</p>
</td></tr>
<tr><td><code id="bundle-class_+3A_e2">e2</code></td>
<td>
<p>object 2</p>
</td></tr>
<tr><td><code id="bundle-class_+3A_i">i</code></td>
<td>
<p><code>integer</code> or <code>character</code> values for indexing a bundle object.</p>
</td></tr>
<tr><td><code id="bundle-class_+3A_name">name</code></td>
<td>
<p>The name of an object in the <code>bundle</code> object.</p>
</td></tr>
<tr><td><code id="bundle-class_+3A_size">size</code></td>
<td>
<p>number of items to choose to generate a sample</p>
</td></tr>
<tr><td><code id="bundle-class_+3A_object">object</code></td>
<td>
<p>A <code>bundle</code> object.</p>
</td></tr>
<tr><td><code id="bundle-class_+3A_...">...</code></td>
<td>
<p>Further parameters</p>
</td></tr>
<tr><td><code id="bundle-class_+3A_keep.rownames">keep.rownames</code></td>
<td>
<p>Required argument to safeguard consistency with S3
method definition in the <code>data.table</code> package. Unused in this context.</p>
</td></tr>
<tr><td><code id="bundle-class_+3A_col">col</code></td>
<td>
<p>columns of the <code>data.table</code> to use to generate an object.</p>
</td></tr>
</table>


<h3>Slots</h3>


<dl>
<dt><code>corpus</code></dt><dd><p>The CWB corpus the xobjects in the <code>bundle</code> are based on, a
length 1 <code>character</code> vector.</p>
</dd>
<dt><code>objects</code></dt><dd><p>An object of class <code>list</code>.</p>
</dd>
<dt><code>p_attribute</code></dt><dd><p>Object of class <code>character</code>.</p>
</dd>
<dt><code>encoding</code></dt><dd><p>The encoding of the corpus.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Andreas Blaette
</p>


<h3>Examples</h3>

<pre><code class='language-R'>use("RcppCWB", "REUTERS")

# generate bundle with articles in REUTERS corpus
b &lt;- partition_bundle("REUTERS", s_attribute = "id")

# basic operations
length(b)
names(b)
get_corpus(b)
summary(b)

# enrich with count for p-attribute
b &lt;- enrich(b, p_attribute = "word")

# Indexing and accessing bundle objects
reu &lt;- corpus("REUTERS") %&gt;% split(s_attribute = "id")
reu[1:3]
reu[-1]
reu[-(1:10)]
reu["127"]
reu$`127` # alternative access
reu[c("127", "273")]
reu[["127"]] &lt;- NULL
pb &lt;- partition_bundle("GERMAPARLMINI", s_attribute = "party")
pb$"NA" &lt;- NULL # quotation needed if name is "NA"

# Turn bundle into data.table (not tested to save time)

dt &lt;- partition_bundle("REUTERS", s_attribute = "id") %&gt;%
  cooccurrences(query = "oil", cqp = FALSE) %&gt;%
  as.data.table(col = "ll")

</code></pre>

<hr>
<h2 id='capitalize'>Capitalize character vector.</h2><span id='topic+capitalize'></span>

<h3>Description</h3>

<p>Make the first character of the elements of a <code>character</code> vector have upper
case and the rest lower case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>capitalize(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="capitalize_+3A_x">x</code></td>
<td>
<p>A <code>character</code> vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>capitalize()</code> function may be useful when applying lowercased
dictionaries of stoplists, a sentiment dictionary etc. on a CWB corpus that
maintains capitalization (tokens are not lowercased).
</p>
<p>This function is inspired by a method Python offers for string objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>capitalize(c("oil", "corpus", "data"))
</code></pre>

<hr>
<h2 id='chisquare'>Perform chisquare-text.</h2><span id='topic+chisquare'></span><span id='topic+chisquare+2Cfeatures-method'></span><span id='topic+chisquare+2Ccontext-method'></span><span id='topic+chisquare+2Ccooccurrences-method'></span>

<h3>Description</h3>

<p>Perform Chisquare-Test based on a table with counts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chisquare(.Object)

## S4 method for signature 'features'
chisquare(.Object)

## S4 method for signature 'context'
chisquare(.Object)

## S4 method for signature 'cooccurrences'
chisquare(.Object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chisquare_+3A_.object">.Object</code></td>
<td>
<p>A <code>features</code> object, or an object inheriting from it
(<code>context</code>, <code>cooccurrences</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The basis for computing for the chi square test is a contingency table of
observationes, which is prepared for every single token in the corpus. It
reports counts for a token to inspect and all other tokens in a corpus of
interest (coi) and a reference corpus (ref):
</p>

<table>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: center;"> coi   </td><td style="text-align: center;"> ref </td><td style="text-align: center;"> TOTAL</td>
</tr>
<tr>
 <td style="text-align: right;">
count token </td><td style="text-align: center;"> <code class="reqn">o_{11}</code>  </td><td style="text-align: center;"> <code class="reqn">o_{12}</code> </td><td style="text-align: center;"> <code class="reqn">r_{1}</code></td>
</tr>
<tr>
 <td style="text-align: right;">
other tokens </td><td style="text-align: center;"> <code class="reqn">o_{21}</code>    </td><td style="text-align: center;"> <code class="reqn">o_{22}</code> </td><td style="text-align: center;"> <code class="reqn">r_{2}</code></td>
</tr>
<tr>
 <td style="text-align: right;">
TOTAL </td><td style="text-align: center;"> <code class="reqn">c_{1}</code>    </td><td style="text-align: center;"> <code class="reqn">c_{2}</code> </td><td style="text-align: center;"> N</td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>

<p>Based on the contingency table, expected values are calculated for each cell,
as the product of the column and margin sums, divided by the overall number
of tokens (see example). The standard formula for calculating the chi-square
test is computed as follows. </p>
<p style="text-align: center;"><code class="reqn">X^{2} = \sum{\frac{(O_{ij} -
E_{ij})^2}{O_{ij}}}</code>
</p>

<p>Results from the chisquare test are only robust for at least 5 observed
counts in the corpus of interest. Usually, results need to be filtered
accordingly (see examples).
</p>


<h3>Value</h3>

<p>Same class as input object, with enriched table in the
<code>stat</code>-slot.
</p>


<h3>Author(s)</h3>

<p>Andreas Blaette
</p>


<h3>References</h3>

<p>Manning, Christopher D.; Schuetze, Hinrich (1999):
<em>Foundations of Statistical Natural Language Processing</em>. MIT Press:
Cambridge, Mass., pp. 169-172.
</p>
<p>Kilgarriff, A. and Rose, T. (1998): Measures for corpus
similarity and homogeneity. <em>Proc. 3rd Conf. on Empirical Methods in
Natural Language Processing</em>. Granada, Spain, pp 46-52.
</p>


<h3>See Also</h3>

<p>Other statistical methods: 
<code><a href="#topic+ll">ll</a>()</code>,
<code><a href="#topic+pmi">pmi</a>()</code>,
<code><a href="#topic+t_test">t_test</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>use("polmineR")
library(data.table)
m &lt;- partition(
  "GERMAPARLMINI", speaker = "Merkel", interjection = "speech",
  regex = TRUE, p_attribute = "word"
)
f &lt;- features(m, "GERMAPARLMINI", included = TRUE)
f_min &lt;- subset(f, count_coi &gt;= 5)
summary(f_min)

## Not run: 

# A sample do-it-yourself calculation for chisquare:

# (a) prepare matrix with observed values
o &lt;- matrix(data = rep(NA, 4), ncol = 2) 
o[1,1] &lt;- as.data.table(m)[word == "Weg"][["count"]]
o[1,2] &lt;- count("GERMAPARLMINI", query = "Weg")[["count"]] - o[1,1]
o[2,1] &lt;- size(f)[["coi"]] - o[1,1]
o[2,2] &lt;- size(f)[["ref"]] - o[1,2]


# prepare matrix with expected values, calculate margin sums first

r &lt;- rowSums(o)
c &lt;- colSums(o)
N &lt;- sum(o)

e &lt;- matrix(data = rep(NA, 4), ncol = 2) 
e[1,1] &lt;- r[1] * (c[1] / N)
e[1,2] &lt;- r[1] * (c[2] / N)
e[2,1] &lt;- r[2] * (c[1] / N)
e[2,2] &lt;- r[2] * (c[2] / N)


# compute chisquare statistic

y &lt;- matrix(rep(NA, 4), ncol = 2)
for (i in 1:2) for (j in 1:2) y[i,j] &lt;- (o[i,j] - e[i,j])^2 / e[i,j]
chisquare_value &lt;- sum(y)

as(f, "data.table")[word == "Weg"][["chisquare"]]

## End(Not run)
</code></pre>

<hr>
<h2 id='context'>Analyze context of a node word.</h2><span id='topic+context'></span><span id='topic+context+2Cslice-method'></span><span id='topic+as.matrix+2Ccontext_bundle-method'></span><span id='topic+context+2Cpartition-method'></span><span id='topic+context+2Csubcorpus-method'></span><span id='topic+context+2Cmatrix-method'></span><span id='topic+context+2Ccorpus-method'></span><span id='topic+context+2Ccharacter-method'></span><span id='topic+context+2Cpartition_bundle-method'></span><span id='topic+context+2Ccooccurrences-method'></span>

<h3>Description</h3>

<p>Retrieve the word context of a token, optionally checking for boundaries of a
XML region.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>context(.Object, ...)

## S4 method for signature 'slice'
context(
  .Object,
  query,
  cqp = is.cqp,
  check = TRUE,
  left = getOption("polmineR.left"),
  right = getOption("polmineR.right"),
  p_attribute = getOption("polmineR.p_attribute"),
  region = NULL,
  boundary = NULL,
  stoplist = NULL,
  positivelist = NULL,
  regex = FALSE,
  count = TRUE,
  mc = getOption("polmineR.mc"),
  verbose = FALSE,
  progress = TRUE,
  ...
)

## S4 method for signature 'partition'
context(
  .Object,
  query,
  cqp = is.cqp,
  check = TRUE,
  left = getOption("polmineR.left"),
  right = getOption("polmineR.right"),
  p_attribute = getOption("polmineR.p_attribute"),
  region = NULL,
  boundary = NULL,
  stoplist = NULL,
  positivelist = NULL,
  regex = FALSE,
  count = TRUE,
  mc = getOption("polmineR.mc"),
  verbose = FALSE,
  progress = TRUE,
  ...
)

## S4 method for signature 'subcorpus'
context(
  .Object,
  query,
  cqp = is.cqp,
  check = TRUE,
  left = getOption("polmineR.left"),
  right = getOption("polmineR.right"),
  p_attribute = getOption("polmineR.p_attribute"),
  region = NULL,
  boundary = NULL,
  stoplist = NULL,
  positivelist = NULL,
  regex = FALSE,
  count = TRUE,
  mc = getOption("polmineR.mc"),
  verbose = FALSE,
  progress = TRUE,
  ...
)

## S4 method for signature 'matrix'
context(
  .Object,
  corpus,
  registry = Sys.getenv("CORPUS_REGISTRY"),
  left,
  right,
  p_attribute,
  region = NULL,
  boundary = NULL
)

## S4 method for signature 'corpus'
context(
  .Object,
  query,
  cqp = is.cqp,
  p_attribute = getOption("polmineR.p_attribute"),
  region = NULL,
  boundary = NULL,
  left = getOption("polmineR.left"),
  right = getOption("polmineR.right"),
  stoplist = NULL,
  positivelist = NULL,
  regex = FALSE,
  count = TRUE,
  mc = getOption("polmineR.mc"),
  verbose = FALSE,
  progress = TRUE,
  ...
)

## S4 method for signature 'character'
context(
  .Object,
  query,
  cqp = is.cqp,
  p_attribute = getOption("polmineR.p_attribute"),
  region = NULL,
  boundary = NULL,
  left = getOption("polmineR.left"),
  right = getOption("polmineR.right"),
  stoplist = NULL,
  positivelist = NULL,
  regex = FALSE,
  count = TRUE,
  mc = getOption("polmineR.mc"),
  verbose = FALSE,
  progress = TRUE,
  ...
)

## S4 method for signature 'partition_bundle'
context(
  .Object,
  query,
  p_attribute,
  stoplist = NULL,
  positivelist = NULL,
  regex = FALSE,
  verbose = TRUE,
  ...
)

## S4 method for signature 'cooccurrences'
context(.Object, query, check = TRUE, complete = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="context_+3A_.object">.Object</code></td>
<td>
<p>a partition or a partition_bundle object</p>
</td></tr>
<tr><td><code id="context_+3A_...">...</code></td>
<td>
<p>Further parameters.</p>
</td></tr>
<tr><td><code id="context_+3A_query">query</code></td>
<td>
<p>A query, which may by a character vector or a CQP query.</p>
</td></tr>
<tr><td><code id="context_+3A_cqp">cqp</code></td>
<td>
<p>defaults to is.cqp-function, or provide TRUE/FALSE</p>
</td></tr>
<tr><td><code id="context_+3A_check">check</code></td>
<td>
<p>A <code>logical</code> value, whether to check validity of CQP query using
<code>check_cqp_query</code>.</p>
</td></tr>
<tr><td><code id="context_+3A_left">left</code></td>
<td>
<p>A single <code>integer</code> value defining the number of tokens to the
left of the query match to include in the context. Advanced usage: (a) If
<code>left</code> is a length-one <code>character</code> vector stating an s-attribute, the
context will be expanded to the (left) boundary of the region where the
match occurs. (b) If <code>left</code> is a named length-one <code>integer</code> vector, this
value is the number regions of the structural attribute referred to by the
vector's name  to the left of the query match that are included in the
context.</p>
</td></tr>
<tr><td><code id="context_+3A_right">right</code></td>
<td>
<p>A single <code>integer</code> value, a length-one <code>character</code> vector or a
named length-one <code>integer</code> value, with equivalent effects to argument
<code>left</code>.</p>
</td></tr>
<tr><td><code id="context_+3A_p_attribute">p_attribute</code></td>
<td>
<p>The p-attribute of the query.</p>
</td></tr>
<tr><td><code id="context_+3A_region">region</code></td>
<td>
<p>An s-attribute, given by a length-one <code>character</code> vector.
The context of query matches will be expanded to the left and right
boundary of the region where the match is located. If arguments <code>left</code> and
<code>right</code> are &gt; 1, the left and right boundaries of the respective number of
regions will be identified.</p>
</td></tr>
<tr><td><code id="context_+3A_boundary">boundary</code></td>
<td>
<p>If provided, a length-one character vector specifying a
s-attribute. It will be checked that corpus positions do not extend beyond
the region defined by the s-attribute.</p>
</td></tr>
<tr><td><code id="context_+3A_stoplist">stoplist</code></td>
<td>
<p>Exclude match for query if stopword(s) is/are are present in
context. See positivelist for further explanation.</p>
</td></tr>
<tr><td><code id="context_+3A_positivelist">positivelist</code></td>
<td>
<p>A <code>character</code> vector or <code>numeric</code>/<code>integer</code> vector:
include a query hit only if token in positivelist is present. If
positivelist is a <code>character</code> vector, it may include regular expressions
(see parameter regex).</p>
</td></tr>
<tr><td><code id="context_+3A_regex">regex</code></td>
<td>
<p>A <code>logical</code> value, defaults to <code>FALSE</code> - whether <code>stoplist</code>
and/or <code>positivelist</code> are regular expressions.</p>
</td></tr>
<tr><td><code id="context_+3A_count">count</code></td>
<td>
<p>logical</p>
</td></tr>
<tr><td><code id="context_+3A_mc">mc</code></td>
<td>
<p>Whether to use multicore; if <code>NULL</code> (default), the function will get
the value from the options.</p>
</td></tr>
<tr><td><code id="context_+3A_verbose">verbose</code></td>
<td>
<p>Report progress? A <code>logical</code> value, defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="context_+3A_progress">progress</code></td>
<td>
<p>A <code>logical</code> value, whether to show progress bar.</p>
</td></tr>
<tr><td><code id="context_+3A_corpus">corpus</code></td>
<td>
<p>A length-one <code>character</code> vector stating a corpus ID.</p>
</td></tr>
<tr><td><code id="context_+3A_registry">registry</code></td>
<td>
<p>The registry directory with the registry file for <code>corpus</code>.</p>
</td></tr>
<tr><td><code id="context_+3A_complete">complete</code></td>
<td>
<p>enhance completely</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For formulating the query, CPQ syntax may be used (see
examples). Statistical tests available are log-likelihood, t-test, pmi.
</p>
<p>If <code>.Object</code> is a <code>matrix</code>, the <code>context</code>-method will call
<code>RcppCWB::region_matrix_context()</code>, the worker behind the
<code>context()</code>-method.
</p>


<h3>Value</h3>

<p>depending on whether a <code>partition</code> or a <code>partition_bundle</code> serves as
input, the return will be a context object, or a <code>context_bundle</code> object.
Note that the number of objects in the <code>context_bundle</code> may differ from the
number of objects in the input <code>bundle</code> object: <code>NULL</code> objects that result
if no hit is obtained are dropped.
</p>


<h3>Author(s)</h3>

<p>Andreas Blaette
</p>


<h3>Examples</h3>

<pre><code class='language-R'>use("polmineR")
p &lt;- partition("GERMAPARLMINI", interjection = "speech")
y &lt;- context(p, query = "Integration", p_attribute = "word")
y &lt;- context(p, query = "Integration", p_attribute = "word", positivelist = "Bildung")
y &lt;- context(
  p, query = "Integration", p_attribute = "word",
  positivelist = c("[aA]rbeit.*", "Ausbildung"), regex = TRUE
)
</code></pre>

<hr>
<h2 id='context_bundle-class'>S4 context_bundle class</h2><span id='topic+context_bundle-class'></span><span id='topic+show+2Ccontext_bundle-method'></span><span id='topic+summary+2Ccontext_bundle-method'></span><span id='topic++5B+2Ccontext_bundle-method'></span><span id='topic++5B+2Ccontext_bundle+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+5B+2Ccontext_bundle-method'></span>

<h3>Description</h3>

<p>class to organize information of multiple context analyses
</p>


<h3>Slots</h3>


<dl>
<dt><code>objects</code></dt><dd><p>Object of class <code>"list"</code> a list of context objects</p>
</dd>
</dl>


<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p>output of core information</p>
</dd>
<dt>summary</dt><dd><p>core statistical information</p>
</dd>
<dt>[</dt><dd><p>specific cooccurrences</p>
</dd>
<dt>[[</dt><dd><p>specific cooccurrences</p>
</dd>
</dl>


<hr>
<h2 id='context-class'>Context class.</h2><span id='topic+context-class'></span><span id='topic+show+2Ccontext-method'></span><span id='topic++5B+2Ccontext-method'></span><span id='topic++5B+2Ccontext+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+5B+2Ccontext-method'></span><span id='topic+summary+2Ccontext-method'></span><span id='topic+head+2Ccontext-method'></span><span id='topic+as.DataTables+2Ccontext-method'></span><span id='topic+length+2Ccontext-method'></span><span id='topic+p_attributes+2Ccontext-method'></span><span id='topic+count+2Ccontext-method'></span><span id='topic+sample+2Ccontext-method'></span><span id='topic+enrich+2Ccontext-method'></span><span id='topic+as.regions+2Ccontext-method'></span><span id='topic+trim+2Ccontext-method'></span>

<h3>Description</h3>

<p>Class to organize information of context analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'context'
length(x)

## S4 method for signature 'context'
p_attributes(.Object)

## S4 method for signature 'context'
count(.Object)

## S4 method for signature 'context'
sample(x, size)

## S4 method for signature 'context'
enrich(
  .Object,
  s_attribute = NULL,
  p_attribute = NULL,
  decode = FALSE,
  stat = FALSE,
  verbose = TRUE,
  ...
)

## S4 method for signature 'context'
as.regions(x, node = TRUE)

## S4 method for signature 'context'
trim(
  .Object,
  s_attribute = NULL,
  positivelist = NULL,
  p_attribute = p_attributes(.Object),
  regex = FALSE,
  stoplist = NULL,
  fn = NULL,
  verbose = TRUE,
  progress = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="context-class_+3A_x">x</code></td>
<td>
<p>A <code>context</code> object.</p>
</td></tr>
<tr><td><code id="context-class_+3A_.object">.Object</code></td>
<td>
<p>A <code>context</code> object.</p>
</td></tr>
<tr><td><code id="context-class_+3A_size">size</code></td>
<td>
<p>An <code>integer</code> indicating sample size.</p>
</td></tr>
<tr><td><code id="context-class_+3A_s_attribute">s_attribute</code></td>
<td>
<p>The s-attribute(s) to add to <code>data.table</code> in slot <code>cpos</code>.</p>
</td></tr>
<tr><td><code id="context-class_+3A_p_attribute">p_attribute</code></td>
<td>
<p>The p-attribute(s) to add to <code>data.table</code> in slot <code>cpos</code>.</p>
</td></tr>
<tr><td><code id="context-class_+3A_decode">decode</code></td>
<td>
<p>A <code>logical</code> value, whether to convert integer ids to expressive
strings.</p>
</td></tr>
<tr><td><code id="context-class_+3A_stat">stat</code></td>
<td>
<p>A <code>logical</code> value, whether to generate / update slot <code>stat</code> from
the <code>cpos</code> table.</p>
</td></tr>
<tr><td><code id="context-class_+3A_verbose">verbose</code></td>
<td>
<p>A <code>logical</code>, whether to be talkative.</p>
</td></tr>
<tr><td><code id="context-class_+3A_...">...</code></td>
<td>
<p>To maintain backwards compatibility if argument <code>pAttribute</code> is
still used.</p>
</td></tr>
<tr><td><code id="context-class_+3A_node">node</code></td>
<td>
<p>A logical value, whether to include the node (i.e. query matches) in the region matrix
generated when creating a <code>partition</code> from a <code>context</code>-object.</p>
</td></tr>
<tr><td><code id="context-class_+3A_positivelist">positivelist</code></td>
<td>
<p>Tokens that are required to be present to keep a match.</p>
</td></tr>
<tr><td><code id="context-class_+3A_regex">regex</code></td>
<td>
<p>A <code>logical</code> value, whether arguments <code>positivlist</code> / <code>stoplist</code>
are interpreted as regular expressions.</p>
</td></tr>
<tr><td><code id="context-class_+3A_stoplist">stoplist</code></td>
<td>
<p>Tokens that are used to exclude a match.</p>
</td></tr>
<tr><td><code id="context-class_+3A_fn">fn</code></td>
<td>
<p>A function that will be applied on context tables splitted by
match_id.</p>
</td></tr>
<tr><td><code id="context-class_+3A_progress">progress</code></td>
<td>
<p>A <code>logical</code> value, whether to show progress bar</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Objects of the class <code>context</code> include a <code>data.table</code> in the
slot <code>cpos</code>. The <code>data.table</code> will at least include the columns &quot;match_id&quot;,
&quot;cpos&quot; and &quot;position&quot;.
</p>
<p>The <code>length</code>-method will return the number of hits that were achieved.
</p>
<p>The <code>enrich()</code>-method can be used to add additional information to
the <code>data.table</code> in the <code>cpos</code>-slot of a <code>context</code>-object.
</p>


<h3>Slots</h3>


<dl>
<dt><code>query</code></dt><dd><p>The query examined (<code>character</code>).</p>
</dd>
<dt><code>count</code></dt><dd><p>An <code>integer</code> value, the number of hits for the query.</p>
</dd>
<dt><code>partition</code></dt><dd><p>The <code>partition</code> the <code>context</code> object is based on.</p>
</dd>
<dt><code>size_partition</code></dt><dd><p>The size of the partition, a length-one <code>integer</code> vector.</p>
</dd>
<dt><code>left</code></dt><dd><p>A length-one <code>integer</code> value, the number of tokens to the left of the query match.</p>
</dd>
<dt><code>right</code></dt><dd><p>An <code>integer</code> value, the number of tokens to the right of the query match.</p>
</dd>
<dt><code>size</code></dt><dd><p>A length-one <code>integer</code> value, the number of tokens covered by
the <code>context</code>-object, i.e. the number of tokens in the right and left context
of the node as well as query matches.</p>
</dd>
<dt><code>size_match</code></dt><dd><p>A length-one <code>integer</code> value, the number of tokens
matches by the query. Identical with the value in slot <code>count</code> if the query
is <em>not</em> a CQP query.</p>
</dd>
<dt><code>size_coi</code></dt><dd><p>A length-one <code>integer</code> value, the number of tokens in the
right and left context of the node (excluding query matches).</p>
</dd>
<dt><code>size_ref</code></dt><dd><p>A length-one <code>integer</code> value, the number of tokens in the
partition, without tokens matched and the tokens in the left and right
context.</p>
</dd>
<dt><code>boundary</code></dt><dd><p>An s-attribute (<code>character</code>).</p>
</dd>
<dt><code>p_attribute</code></dt><dd><p>The p-attribute of the query (<code>character</code>).</p>
</dd>
<dt><code>corpus</code></dt><dd><p>The CWB corpus used (<code>character</code>).</p>
</dd>
<dt><code>stat</code></dt><dd><p>A <code>data.table</code>, the statistics of the analysis.</p>
</dd>
<dt><code>encoding</code></dt><dd><p>Object of class <code>character</code>, encoding of the corpus.</p>
</dd>
<dt><code>cpos</code></dt><dd><p>A <code>data.table</code>, with the columns match_id, cpos, position, word_id.</p>
</dd>
<dt><code>method</code></dt><dd><p>A <code>character</code>-vector, statistical test used.</p>
</dd>
<dt><code>call</code></dt><dd><p>Object of class <code>character</code>, call that generated the object.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'># Keep matches for 'oil' only if first position to the left is 'crude'
.fn &lt;- function(x) if (x[position == -1L][["word"]] == "crude") x else NULL
crude_oil &lt;- context("REUTERS", "oil") %&gt;%
  enrich(p_attribute = "word", decode = TRUE) %&gt;%
  trim(fn = .fn)
</code></pre>

<hr>
<h2 id='cooccurrences'>Get cooccurrence statistics.</h2><span id='topic+cooccurrences'></span><span id='topic+cooccurrences+2Ccorpus-method'></span><span id='topic+cooccurrences+2Ccharacter-method'></span><span id='topic+cooccurrences+2Cslice-method'></span><span id='topic+cooccurrences+2Cpartition-method'></span><span id='topic+cooccurrences+2Csubcorpus-method'></span><span id='topic+cooccurrences+2Ccontext-method'></span><span id='topic+cooccurrences+2Cpartition_bundle-method'></span><span id='topic+cooccurrences+2CCooccurrences-method'></span><span id='topic+cooccurrences+2Cremote_corpus-method'></span><span id='topic+cooccurrences+2Cremote_subcorpus-method'></span>

<h3>Description</h3>

<p>Get cooccurrence statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cooccurrences(.Object, ...)

## S4 method for signature 'corpus'
cooccurrences(
  .Object,
  query,
  cqp = is.cqp,
  p_attribute = getOption("polmineR.p_attribute"),
  boundary = NULL,
  left = getOption("polmineR.left"),
  right = getOption("polmineR.right"),
  stoplist = NULL,
  positivelist = NULL,
  regex = FALSE,
  keep = NULL,
  cpos = NULL,
  method = "ll",
  mc = getOption("polmineR.mc"),
  verbose = FALSE,
  progress = FALSE,
  ...
)

## S4 method for signature 'character'
cooccurrences(
  .Object,
  query,
  cqp = is.cqp,
  p_attribute = getOption("polmineR.p_attribute"),
  boundary = NULL,
  left = getOption("polmineR.left"),
  right = getOption("polmineR.right"),
  stoplist = NULL,
  positivelist = NULL,
  regex = FALSE,
  keep = NULL,
  cpos = NULL,
  method = "ll",
  mc = getOption("polmineR.mc"),
  verbose = FALSE,
  progress = FALSE,
  ...
)

## S4 method for signature 'slice'
cooccurrences(
  .Object,
  query,
  cqp = is.cqp,
  left = getOption("polmineR.left"),
  right = getOption("polmineR.right"),
  p_attribute = getOption("polmineR.p_attribute"),
  boundary = NULL,
  stoplist = NULL,
  positivelist = NULL,
  keep = NULL,
  method = "ll",
  mc = FALSE,
  progress = TRUE,
  verbose = FALSE,
  ...
)

## S4 method for signature 'partition'
cooccurrences(
  .Object,
  query,
  cqp = is.cqp,
  left = getOption("polmineR.left"),
  right = getOption("polmineR.right"),
  p_attribute = getOption("polmineR.p_attribute"),
  boundary = NULL,
  stoplist = NULL,
  positivelist = NULL,
  keep = NULL,
  method = "ll",
  mc = FALSE,
  progress = TRUE,
  verbose = FALSE,
  ...
)

## S4 method for signature 'subcorpus'
cooccurrences(
  .Object,
  query,
  cqp = is.cqp,
  left = getOption("polmineR.left"),
  right = getOption("polmineR.right"),
  p_attribute = getOption("polmineR.p_attribute"),
  boundary = NULL,
  stoplist = NULL,
  positivelist = NULL,
  keep = NULL,
  method = "ll",
  mc = FALSE,
  progress = TRUE,
  verbose = FALSE,
  ...
)

## S4 method for signature 'context'
cooccurrences(.Object, method = "ll", verbose = FALSE)

## S4 method for signature 'partition_bundle'
cooccurrences(
  .Object,
  query,
  verbose = FALSE,
  mc = getOption("polmineR.mc"),
  ...
)

## S4 method for signature 'Cooccurrences'
cooccurrences(.Object, query)

## S4 method for signature 'remote_corpus'
cooccurrences(.Object, ...)

## S4 method for signature 'remote_subcorpus'
cooccurrences(.Object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cooccurrences_+3A_.object">.Object</code></td>
<td>
<p>A <code>partition</code> object, or a <code>character</code> vector with a CWB corpus.</p>
</td></tr>
<tr><td><code id="cooccurrences_+3A_...">...</code></td>
<td>
<p>Further parameters that will be passed into bigmatrix (applies only of big = TRUE).</p>
</td></tr>
<tr><td><code id="cooccurrences_+3A_query">query</code></td>
<td>
<p>A query, either a character vector to match a token, or a CQP query.</p>
</td></tr>
<tr><td><code id="cooccurrences_+3A_cqp">cqp</code></td>
<td>
<p>Defaults to <code>is.cqp</code>-function, or provide
<code>TRUE</code>/<code>FALSE</code>; relevant only if query is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cooccurrences_+3A_p_attribute">p_attribute</code></td>
<td>
<p>The p-attribute of the tokens/the query.</p>
</td></tr>
<tr><td><code id="cooccurrences_+3A_boundary">boundary</code></td>
<td>
<p>If provided, it will be checked that the corpus positions of
windows do not extend beyond the left and right boundaries of the region
defined by the s-attribute where the match occurs.</p>
</td></tr>
<tr><td><code id="cooccurrences_+3A_left">left</code></td>
<td>
<p>A single <code>integer</code> value defining the number of tokens to the
left of the query match to include in the context. Advanced usage: (a) If
<code>left</code> is a length-one <code>character</code> vector stating an s-attribute, the
context will be expanded to the (left) boundary of the region where the
match occurs. (b) If <code>left</code> is a named length-one <code>integer</code> vector, this
value is the number regions of the structural attribute referred to by the
vector's name  to the left of the query match that are included in the
context.</p>
</td></tr>
<tr><td><code id="cooccurrences_+3A_right">right</code></td>
<td>
<p>A single <code>integer</code> value, a length-one <code>character</code> vector or a
named length-one <code>integer</code> value, with equivalent effects to argument
<code>left</code>.</p>
</td></tr>
<tr><td><code id="cooccurrences_+3A_stoplist">stoplist</code></td>
<td>
<p>Exclude a query hit from analysis if stopword(s) is/are in
context (relevant only if query is not <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="cooccurrences_+3A_positivelist">positivelist</code></td>
<td>
<p>Character vector or numeric vector: include a query hit
only if token in <code>positivelist</code> is present. If <code>positivelist</code> is
a character vector, it is assumed to provide regex expressions (incredibly
long if the list is long) (relevant only if query is nut NULL)</p>
</td></tr>
<tr><td><code id="cooccurrences_+3A_regex">regex</code></td>
<td>
<p>A <code>logical</code> value, whether stoplist/positivelist are
interpreted as regular expressions.</p>
</td></tr>
<tr><td><code id="cooccurrences_+3A_keep">keep</code></td>
<td>
<p>list with tokens to keep</p>
</td></tr>
<tr><td><code id="cooccurrences_+3A_cpos">cpos</code></td>
<td>
<p>integer vector with corpus positions, defaults to NULL - then the
corpus positions for the whole corpus will be used</p>
</td></tr>
<tr><td><code id="cooccurrences_+3A_method">method</code></td>
<td>
<p>The statistical test(s) to use (defaults to &quot;ll&quot;).</p>
</td></tr>
<tr><td><code id="cooccurrences_+3A_mc">mc</code></td>
<td>
<p>whether to use multicore</p>
</td></tr>
<tr><td><code id="cooccurrences_+3A_verbose">verbose</code></td>
<td>
<p>A <code>logical</code> value, whether to be verbose.</p>
</td></tr>
<tr><td><code id="cooccurrences_+3A_progress">progress</code></td>
<td>
<p>A <code>logical</code> value, whether to output progress bar.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a cooccurrences-class object
</p>


<h3>Author(s)</h3>

<p>Andreas Blaette
</p>


<h3>References</h3>

<p>Baker, Paul (2006): <em>Using Corpora in Discourse Analysis</em>. London: continuum, p. 95-120 (ch. 5).
</p>
<p>Manning, Christopher D.; Schuetze, Hinrich (1999): <em>Foundations of Statistical Natural Language
Processing</em>. MIT Press: Cambridge, Mass., pp. 151-189 (ch. 5).
</p>


<h3>See Also</h3>

<p>See the documentation for the <code><a href="#topic+ll">ll</a></code>-method for an
explanation of the computation of the log-likelihood statistic.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>use("polmineR")
use(pkg = "RcppCWB", corpus = "REUTERS")

merkel &lt;- partition("GERMAPARLMINI", interjection = "speech", speaker = ".*Merkel", regex = TRUE)
merkel &lt;- enrich(merkel, p_attribute = "word")
cooc &lt;- cooccurrences(merkel, query = "Deutschland")

# use subset-method to filter results
a &lt;- cooccurrences("REUTERS", query = "oil")
b &lt;- subset(a, !is.na(ll))
c &lt;- subset(b, !word %in% tm::stopwords("en"))
d &lt;- subset(c, count_coi &gt;= 5)
e &lt;- subset(c, ll &gt;= 10.83)
format(e)

# using pipe operator with subset
cooccurrences("REUTERS", query = "oil") %&gt;%
  subset(!is.na(ll)) %&gt;%
  subset(!word %in% tm::stopwords("en")) %&gt;%
  subset(count_coi &gt;= 5) %&gt;%
  subset(ll &gt;= 10.83) %&gt;%
  format()
  
# generate datatables htmlwidget with buttons for export (Excel &amp; more)
# (alternatively use openxlsx::write.xlsx())

interactive_table &lt;- cooccurrences("REUTERS", query = "oil") %&gt;%
  format() %&gt;%
  DT::datatable(
    extensions = "Buttons",
    options = list(dom = 'Btip', buttons = c("excel", "pdf", "csv"))
  )
if (interactive()) show(interactive_table)


# compute cooccurrences for a set of partitions
# (example not run by default to save time on test machines)
## Not run: 
pb &lt;- partition_bundle("GERMAPARLMINI", s_attribute = "speaker")
ps &lt;- count(pb, query = "Deutschland")[Deutschland &gt;= 25][["partition"]]
pb_min &lt;- pb[ps]
y &lt;- cooccurrences(pb_min, query = "Deutschland")
if (interactive()) y[[1]]
if (interactive()) y[[2]]

y2 &lt;- corpus("GERMAPARLMINI") %&gt;%
  subset(speaker %in% c("Hubertus Heil", "Angela Dorothea Merkel")) %&gt;%
  split(s_attribute = "speaker") %&gt;%
  cooccurrences(query = "Deutschland")

## End(Not run)
</code></pre>

<hr>
<h2 id='cooccurrences-class'>Cooccurrences class.</h2><span id='topic+cooccurrences-class'></span><span id='topic+cooccurrences_reshaped-class'></span><span id='topic+cooccurrences_bundle-class'></span><span id='topic+cooccurrences_bundle'></span><span id='topic+show+2Ccooccurrences-method'></span><span id='topic+as.data.frame+2Ccooccurrences_bundle-method'></span><span id='topic+format+2Ccooccurrences-method'></span><span id='topic+view+2Ccooccurrences-method'></span><span id='topic+view+2Ccooccurrences_reshaped-method'></span>

<h3>Description</h3>

<p>S4 class to organize information of context analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'cooccurrences'
show(object)

## S4 method for signature 'cooccurrences_bundle'
as.data.frame(x)

## S4 method for signature 'cooccurrences'
format(x, digits = 2L)

## S4 method for signature 'cooccurrences'
view(.Object)

## S4 method for signature 'cooccurrences_reshaped'
view(.Object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cooccurrences-class_+3A_object">object</code></td>
<td>
<p>object to work with</p>
</td></tr>
<tr><td><code id="cooccurrences-class_+3A_x">x</code></td>
<td>
<p>object to work with</p>
</td></tr>
<tr><td><code id="cooccurrences-class_+3A_digits">digits</code></td>
<td>
<p>Integer indicating the number of decimal places (round) or
significant digits (signif) to be used.</p>
</td></tr>
<tr><td><code id="cooccurrences-class_+3A_.object">.Object</code></td>
<td>
<p>object to work with</p>
</td></tr>
</table>


<h3>Slots</h3>


<dl>
<dt><code>call</code></dt><dd><p>Object of class <code>character</code> the call that generated the object</p>
</dd>
<dt><code>partition</code></dt><dd><p>Object of class <code>character</code> the partition the analysis is based on</p>
</dd>
<dt><code>size_partition</code></dt><dd><p>Object of class <code>integer</code> the size of the partition</p>
</dd>
<dt><code>left</code></dt><dd><p>Object of class <code>integer</code> number of tokens to the left.</p>
</dd>
<dt><code>right</code></dt><dd><p>Object of class <code>integer</code> number of tokens to the right.</p>
</dd>
<dt><code>p_attribute</code></dt><dd><p>Object of class <code>character</code> p-attribute of the query</p>
</dd>
<dt><code>corpus</code></dt><dd><p>Object of class <code>character</code> the CWB corpus used</p>
</dd>
<dt><code>stat</code></dt><dd><p>Object of class <code>data.table</code> statistics of the analysis</p>
</dd>
<dt><code>encoding</code></dt><dd><p>Object of class <code>character</code> encoding of the corpus</p>
</dd>
<dt><code>method</code></dt><dd><p>Object of class <code>character</code> statistical test(s) used</p>
</dd>
</dl>

<hr>
<h2 id='Cooccurrences-class'>Cooccurrences class for corpus/partition.</h2><span id='topic+Cooccurrences-class'></span><span id='topic+as_igraph'></span><span id='topic+as.simple_triplet_matrix+2CCooccurrences-method'></span><span id='topic+as_igraph+2CCooccurrences-method'></span><span id='topic+subset+2CCooccurrences-method'></span><span id='topic+decode+2CCooccurrences-method'></span><span id='topic+kwic+2CCooccurrences-method'></span><span id='topic+as.sparseMatrix+2CCooccurrences-method'></span><span id='topic+enrich+2CCooccurrences-method'></span>

<h3>Description</h3>

<p>The <code>Cooccurrences</code>-class stores the information for all cooccurrences
in a corpus. As this data can be bulky, in-place modifications of the
<code>data.table</code> in the stat-slot of a <code>Cooccurrences</code>-object are used
wherever possible, to avoid copying potentially large objects whenever
possible. The class inherits from the <code>textstat</code>-class, so that methods
for <code>textstat</code>-objects are inherited (see examples).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Cooccurrences'
as.simple_triplet_matrix(x)

## S4 method for signature 'Cooccurrences'
as_igraph(
  x,
  edge_attributes = c("ll", "ab_count", "rank_ll"),
  vertex_attributes = "count",
  as.undirected = TRUE,
  drop = getOption("polmineR.villainChars")
)

## S4 method for signature 'Cooccurrences'
subset(x, ..., by)

## S4 method for signature 'Cooccurrences'
decode(.Object)

## S4 method for signature 'Cooccurrences'
kwic(
  .Object,
  left = getOption("polmineR.left"),
  right = getOption("polmineR.right"),
  verbose = TRUE,
  progress = TRUE
)

## S4 method for signature 'Cooccurrences'
as.sparseMatrix(x, col = "ab_count", ...)

## S4 method for signature 'Cooccurrences'
enrich(.Object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Cooccurrences-class_+3A_x">x</code></td>
<td>
<p>A <code>Cooccurrences</code> class object.</p>
</td></tr>
<tr><td><code id="Cooccurrences-class_+3A_edge_attributes">edge_attributes</code></td>
<td>
<p>Attributes from stat <code>data.table</code> in x to add to edges.</p>
</td></tr>
<tr><td><code id="Cooccurrences-class_+3A_vertex_attributes">vertex_attributes</code></td>
<td>
<p>Vertex attributes to add to nodes.</p>
</td></tr>
<tr><td><code id="Cooccurrences-class_+3A_as.undirected">as.undirected</code></td>
<td>
<p>Logical, whether to return directed or undirected graph.</p>
</td></tr>
<tr><td><code id="Cooccurrences-class_+3A_drop">drop</code></td>
<td>
<p>A character vector indicating names of nodes to drop from
<code>igraph</code> object that is prepared.</p>
</td></tr>
<tr><td><code id="Cooccurrences-class_+3A_...">...</code></td>
<td>
<p>Further arguments passed into a further call of <code>subset</code>.</p>
</td></tr>
<tr><td><code id="Cooccurrences-class_+3A_by">by</code></td>
<td>
<p>A <code>features</code>-class object.</p>
</td></tr>
<tr><td><code id="Cooccurrences-class_+3A_.object">.Object</code></td>
<td>
<p>A <code>Cooccurrences</code>-class object.</p>
</td></tr>
<tr><td><code id="Cooccurrences-class_+3A_left">left</code></td>
<td>
<p>Number of tokens to the left of the node.</p>
</td></tr>
<tr><td><code id="Cooccurrences-class_+3A_right">right</code></td>
<td>
<p>Number of tokens to the right of the node.</p>
</td></tr>
<tr><td><code id="Cooccurrences-class_+3A_verbose">verbose</code></td>
<td>
<p>Logical.</p>
</td></tr>
<tr><td><code id="Cooccurrences-class_+3A_progress">progress</code></td>
<td>
<p>Logical, whether to show progress bar.</p>
</td></tr>
<tr><td><code id="Cooccurrences-class_+3A_col">col</code></td>
<td>
<p>A column to extract.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>as.simple_triplet_matrix</code>-method will transform a
<code>Cooccurrences</code> object into a sparse matrix. For reasons of memory
efficiency, decoding token ids is performed within the method at the
as late as possible. It is NOT necessary that decoded tokens are present
in the table in the <code>Cooccurrences</code> object.
</p>
<p>The <code>as_igraph</code>-method can be used to turn an object of the <code>Cooccurrences</code>-class
into an <code>igraph</code>-object.
</p>
<p>The <code>subset</code> method, as a particular feature, allows a
<code>Coocccurrences</code>-object to be subsetted by a <code>featurs</code>-Object
resulting from a features extraction that compares two Cooccurrences
objects.
</p>
<p>For reasons of memory efficiency, the initial <code>data.table</code> in
the slot <code>stat</code> of a <code>Cooccurrences</code>-object will identify tokens by an
integer id, not by the string of the token. The <code>decode()</code>-method will
replace these integer columns with human-readable character vectors. Due to
the reference logic of the <code>data.table</code> object, this is an in-place
operation, peformed without copying the table. The modified object is
returned invisibly; usually it will not be necessary to catch the return
value.
</p>
<p>The <code>kwic</code>-method will add a column to the <code>data.table</code> in
the <code>stat</code>-slot with the concordances that are behind a statistical
finding, and to the <code>data.table</code> in the <code>stat</code>-slot of the
<code>partition</code> in the slot <code>partition</code>. It is an in-place operation.
</p>
<p>Returns a <code>sparseMatrix</code> based on the counts of term cooccurrences. At this stage,
it is required that decoded tokens are present.
</p>
<p>The <code>enrich()</code>-method will add columns 'a_count' and 'b_count' to
the <code>data.table</code> in the 'stat' slot of the <code>Cooccurrences</code> object. If the
count for the subcorpus/partition from which the cooccurrences are derived
is not yet present, the count is performed first.
</p>


<h3>Slots</h3>


<dl>
<dt><code>left</code></dt><dd><p>Single <code>integer</code> value, number of tokens to the left of the node.</p>
</dd>
<dt><code>right</code></dt><dd><p>Single <code>integer</code> value, number of tokens to the right of the node.</p>
</dd>
<dt><code>p_attribute</code></dt><dd><p>A <code>character</code> vector, the p-attribute(s) the evaluation of the corpus is based on.</p>
</dd>
<dt><code>corpus</code></dt><dd><p>Length-one <code>character</code> vector, the CWB corpus used.</p>
</dd>
<dt><code>stat</code></dt><dd><p>A <code>data.table</code> with the statistical analysis of cooccurrences.</p>
</dd>
<dt><code>encoding</code></dt><dd><p>Length-one <code>character</code> vector, the encoding of the corpus.</p>
</dd>
<dt><code>partition</code></dt><dd><p>The <code>partition</code> that is the basis for computations.</p>
</dd>
<dt><code>window_sizes</code></dt><dd><p>A <code>data.table</code> linking the number of tokens in the
context of a token identified by id.</p>
</dd>
<dt><code>minimized</code></dt><dd><p>Logical, whether the object has been minimized.</p>
</dd>
</dl>


<h3>See Also</h3>

<p>See the documentation of the <code><a href="#topic+Cooccurrences">Cooccurrences</a></code>-method
(including examples) for procedures to get and filter cooccurrence
information. See the documentation for the <code><a href="#topic+textstat-class">textstat-class</a></code>
explaining which methods for this superclass of the
<code>Cooccurrences</code>-class which are available.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# takes too much time on CRAN test machines
use(pkg = "RcppCWB", corpus = "REUTERS")
X &lt;- Cooccurrences("REUTERS", p_attribute = "word", left = 2L, right = 2L)
m &lt;- as.simple_triplet_matrix(X)

## End(Not run)

use(pkg = "RcppCWB", corpus = "REUTERS")

X &lt;- Cooccurrences("REUTERS", p_attribute = "word", left = 5L, right = 5L)
decode(X)
sm &lt;- as.sparseMatrix(X)
stm &lt;- as.simple_triplet_matrix(X)

</code></pre>

<hr>
<h2 id='Cooccurrences+2Ccorpus-method'>Get all cooccurrences in corpus/partition.</h2><span id='topic+Cooccurrences+2Ccorpus-method'></span><span id='topic+Cooccurrences'></span><span id='topic+Cooccurrences+2Ccharacter-method'></span><span id='topic+Cooccurrences+2Cslice-method'></span><span id='topic+Cooccurrences+2Cpartition-method'></span><span id='topic+Cooccurrences+2Csubcorpus-method'></span>

<h3>Description</h3>

<p>Obtain all cooccurrences in a corpus, or a <code>partition</code>. The result is a
<code>Cooccurrences</code>-class object which includes a <code>data.table</code> with
counts of cooccurrences. See the documentation entry for the
<code>Cooccurrences</code>-class for methods to process <code>Cooccurrences</code>-class
objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'corpus'
Cooccurrences(
  .Object,
  p_attribute,
  left,
  right,
  stoplist = NULL,
  mc = getOption("polmineR.mc"),
  verbose = FALSE,
  progress = FALSE
)

## S4 method for signature 'character'
Cooccurrences(
  .Object,
  p_attribute,
  left,
  right,
  stoplist = NULL,
  mc = getOption("polmineR.mc"),
  verbose = FALSE,
  progress = FALSE
)

## S4 method for signature 'slice'
Cooccurrences(
  .Object,
  p_attribute,
  left,
  right,
  stoplist = NULL,
  mc = getOption("polmineR.mc"),
  verbose = FALSE,
  progress = FALSE
)

## S4 method for signature 'partition'
Cooccurrences(
  .Object,
  p_attribute,
  left,
  right,
  stoplist = NULL,
  mc = getOption("polmineR.mc"),
  verbose = FALSE,
  progress = FALSE
)

## S4 method for signature 'subcorpus'
Cooccurrences(
  .Object,
  p_attribute,
  left,
  right,
  stoplist = NULL,
  mc = getOption("polmineR.mc"),
  verbose = FALSE,
  progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Cooccurrences+2B2Ccorpus-method_+3A_.object">.Object</code></td>
<td>
<p>A length-one character vector indicating a corpus, or a
<code>partition</code> object.</p>
</td></tr>
<tr><td><code id="Cooccurrences+2B2Ccorpus-method_+3A_p_attribute">p_attribute</code></td>
<td>
<p>Positional attributes to evaluate.</p>
</td></tr>
<tr><td><code id="Cooccurrences+2B2Ccorpus-method_+3A_left">left</code></td>
<td>
<p>A scalar <code>integer</code> value, size of left context.</p>
</td></tr>
<tr><td><code id="Cooccurrences+2B2Ccorpus-method_+3A_right">right</code></td>
<td>
<p>A scalar <code>integer</code> value, size of right context.</p>
</td></tr>
<tr><td><code id="Cooccurrences+2B2Ccorpus-method_+3A_stoplist">stoplist</code></td>
<td>
<p>Tokens to exclude from the analysis.</p>
</td></tr>
<tr><td><code id="Cooccurrences+2B2Ccorpus-method_+3A_mc">mc</code></td>
<td>
<p>Logical value, whether to use multiple cores.</p>
</td></tr>
<tr><td><code id="Cooccurrences+2B2Ccorpus-method_+3A_verbose">verbose</code></td>
<td>
<p>Logical value, whether to output messages.</p>
</td></tr>
<tr><td><code id="Cooccurrences+2B2Ccorpus-method_+3A_progress">progress</code></td>
<td>
<p>Logical value, whether to display a progress bar.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The implementation uses a <code>data.table</code> to store information and makes
heavy use of the reference logic of the <code>data.table</code> package, to avoid
copying potentially large objects, and to be parsimonious with limited
memory. The behaviour resulting from in-place changes may be uncommon, see
examples.
</p>


<h3>See Also</h3>

<p>To learn about methods available for the object that is returned,
see the documentation of the <code><a href="#topic+Cooccurrences-class">Cooccurrences-class</a></code>. See the
<code><a href="#topic+cooccurrences">cooccurrences</a></code>-method (starting with a lower case c) to get
the cooccurrences for the match for a query, which may also be a CQP query.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# In a first scenario, we get all cooccurrences for the REUTERS corpus,
# excluding stopwords

stopwords &lt;- unname(unlist(
  noise(
    terms("REUTERS", p_attribute = "word"),
    stopwordsLanguage = "en"
    )
  ))
r &lt;- Cooccurrences(
  .Object = "REUTERS", p_attribute = "word",
  left = 5L, right = 5L, stoplist = stopwords
)
ll(r) # note that the table in the stat slot is augmented in-place
decode(r) # in-place modification, again
r &lt;- subset(r, ll &gt; 11.83 &amp; ab_count &gt;= 5)
data.table::setorderv(r@stat, cols = "ll", order = -1L)
head(r, 25)

if (requireNamespace("igraph", quietly = TRUE)){
  r@partition &lt;- enrich(r@partition, p_attribute = "word")
  g &lt;- as_igraph(r, as.undirected = TRUE)
  plot(g)
}

# The next scenario is a cross-check that extracting cooccurrences from
# from a Cooccurrences-class object with all cooccurrences and the result
# for getting cooccurrences for a single object are identical

a &lt;- cooccurrences(r, query = "oil")
a &lt;- data.table::as.data.table(a)

b &lt;- cooccurrences("REUTERS", query = "oil", left = 5, right = 5, p_attribute = "word")
b &lt;- data.table::as.data.table(b)
b &lt;- b[!word %in% stopwords]

all(b[["word"]][1:5] == a[["word"]][1:5]) # needs to be identical!


stopwords &lt;- unlist(noise(
  terms("GERMAPARLMINI", p_attribute = "word"),
  stopwordsLanguage = "german"
  )
)

# We now filter cooccurrences by keeping only the statistically 
# significant cooccurrens, identified by comparison with cooccurrences
# derived from a reference corpus

plpr_partition &lt;- partition(
  "GERMAPARLMINI", date = "2009-11-10", interjection = "speech",
  p_attribute = "word"
)
plpr_cooc &lt;- Cooccurrences(
  plpr_partition, p_attribute = "word",
  left = 3L, right = 3L,
  stoplist = stopwords,
  verbose = TRUE
)
decode(plpr_cooc)
ll(plpr_cooc)

merkel &lt;- partition(
  "GERMAPARLMINI", speaker = "Merkel", date = "2009-11-10", interjection = "speech",
  regex = TRUE,
  p_attribute = "word"
)
merkel_cooc &lt;- Cooccurrences(
  merkel, p_attribute = "word",
  left = 3L, right = 3L,
  stoplist = stopwords, 
  verbose = TRUE
)
decode(merkel_cooc)
ll(merkel_cooc)

merkel_min &lt;- subset(
  merkel_cooc,
  by = subset(features(merkel_cooc, plpr_cooc), rank_ll &lt;= 50)
  )
  
# Esentially the same procedure as in the previous example, but with 
# two positional attributes, so that part-of-speech annotation is 
# used for additional filtering.
   
         
protocol &lt;- partition(
  "GERMAPARLMINI",
  date = "2009-11-10",
  p_attribute = c("word", "pos"),
  interjection = "speech"
)
protocol_cooc &lt;- Cooccurrences(
  protocol,
  p_attribute = c("word", "pos"),
  left = 3L, right = 3L
  )
ll(protocol_cooc)
decode(protocol_cooc)

merkel &lt;- partition(
  "GERMAPARLMINI",
  speaker = "Merkel",
  date = "2009-11-10",
  interjection = "speech",
  regex = TRUE,
  p_attribute = c("word", "pos")
)
merkel_cooc &lt;- Cooccurrences(
  merkel,
  p_attribute = c("word", "pos"),
  left = 3L, right = 3L,
  verbose = TRUE
)
ll(merkel_cooc)
decode(merkel_cooc)

f &lt;- features(merkel_cooc, protocol_cooc)
f &lt;- subset(f, a_pos %in% c("NN", "ADJA"))
f &lt;- subset(f, b_pos %in% c("NN", "ADJA"))
f &lt;- subset(f, c(rep(TRUE, times = 50), rep(FALSE, times = nrow(f) - 50)))

merkel_min &lt;- subset(merkel_cooc, by = f)

if (requireNamespace("igraph", quietly = TRUE)){
  g &lt;- as_igraph(merkel_min, as.undirected = TRUE)
  plot(g)
}


## End(Not run)
</code></pre>

<hr>
<h2 id='corpus-class'>Corpus class initialization</h2><span id='topic+corpus-class'></span><span id='topic+zoom'></span><span id='topic+corpus'></span><span id='topic+get_corpus'></span><span id='topic+remote_corpus'></span><span id='topic+remote_corpus-class'></span><span id='topic+corpus+2Ccharacter-method'></span><span id='topic+corpus+2Cmissing-method'></span>

<h3>Description</h3>

<p>Corpora indexed using the 'Corpus Workbench' ('CWB') offer an efficient data
structure for large, linguistically annotated corpora. The <code>corpus</code>-class
keeps basic information on a CWB corpus. Corresponding to the name of the
class, the <code>corpus</code>-method is the initializer for objects of the <code>corpus</code>
class. A CWB corpus can also be hosted remotely on an
<a href="https://www.opencpu.org">OpenCPU</a> server. The <code>remote_corpus</code> class
(which inherits from the <code>corpus</code> class) will handle respective information.
A (limited) set of polmineR functions and methods can be executed on the
corpus on the remote machine from the local R session by calling them on the
<code>remote_corpus</code> object. Calling the <code>corpus</code>-method without an argument will
return a <code>data.frame</code> with basic information on the corpora that are
available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'character'
corpus(.Object, registry_dir, server = NULL, restricted)

## S4 method for signature 'missing'
corpus()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corpus-class_+3A_.object">.Object</code></td>
<td>
<p>The upper-case ID of a CWB corpus stated by a
length-one <code>character</code> vector.</p>
</td></tr>
<tr><td><code id="corpus-class_+3A_registry_dir">registry_dir</code></td>
<td>
<p>The registry directory with the registry file describing
the corpus (length-one <code>character</code> vector). If missing, the C
representations of loaded corpora will be evaluated to get the registry
directory with the registry file for the corpus.</p>
</td></tr>
<tr><td><code id="corpus-class_+3A_server">server</code></td>
<td>
<p>If <code>NULL</code> (default), the corpus is expected to be present
locally. If provided, the name of an OpenCPU server (can be an IP address)
that hosts a corpus, or several corpora. The <code>corpus</code>-method will then
instantiate a <code>remote_corpus</code> object.</p>
</td></tr>
<tr><td><code id="corpus-class_+3A_restricted">restricted</code></td>
<td>
<p>A <code>logical</code> value, whether access to a remote corpus is
restricted (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calling <code>corpus()</code> will return a <code>data.frame</code> listing the corpora
available locally and described in the active registry directory, and some
basic information on the corpora.
</p>
<p>A <code>corpus</code> object is instantiated by passing a corpus ID as argument
<code>.Object</code>. Following the conventions of the Corpus Workbench (CWB), Corpus
IDs are written in upper case. If <code>.Object</code> includes lower case letters,
the <code>corpus</code> object is instantiated nevertheless, but a warning is issued
to prevent bad practice. If <code>.Object</code> is not a known corpus, the error
message will include a suggestion if there is a potential candidate that
can be identified by <code>agrep</code>.
</p>
<p>A limited set of methods of the <code>polmineR</code> package is exposed to be
executed on a remote OpenCPU server. As a matter of convenience, the
whereabouts of an OpenCPU server hosting a CWB corpus can be stated in an
environment variable &quot;OPENCPU_SERVER&quot;. Environment variables for R sessions
can be set easily in the <code>.Renviron</code> file. A convenient way to do this is
to call <code>usethis::edit_r_environ()</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>corpus</code></dt><dd><p>A length-one <code>character</code> vector, the upper-case ID of a CWB
corpus.</p>
</dd>
<dt><code>registry_dir</code></dt><dd><p>Registry directory with registry file describing the
corpus.</p>
</dd>
<dt><code>data_dir</code></dt><dd><p>The directory where binary files of the indexed corpus reside.</p>
</dd>
<dt><code>info_file</code></dt><dd><p>If available, the info file indicated in the registry file
(typically a file named <code>.info</code> <code>info.md</code> in the data directory), or <code>NA</code>
if not.</p>
</dd>
<dt><code>template</code></dt><dd><p>Full path to the template containing formatting instructions
when showing full text output (<code>fs_path</code> object or <code>NA</code>).</p>
</dd>
<dt><code>type</code></dt><dd><p>If available, the type of the corpus (e.g. &quot;plpr&quot; for a corpus of
plenary protocols), or <code>NA</code>.</p>
</dd>
<dt><code>name</code></dt><dd><p>Full name of the corpus that may be more expressive than
the corpus ID.</p>
</dd>
<dt><code>xml</code></dt><dd><p>Object of class <code>character</code>, whether the xml is &quot;flat&quot; or &quot;nested&quot;.</p>
</dd>
<dt><code>encoding</code></dt><dd><p>The encoding of the corpus, given as a length-one
<code>character</code> vector (usually 'utf8' or 'latin1').</p>
</dd>
<dt><code>size</code></dt><dd><p>Number of tokens (size) of the corpus, a length-one <code>integer</code>
vector.</p>
</dd>
<dt><code>server</code></dt><dd><p>The URL (can be IP address) of the OpenCPU server. The slot is
available only with the <code>remote_corpus</code> class inheriting from the <code>corpus</code>
class.</p>
</dd>
<dt><code>user</code></dt><dd><p>If the corpus on the server requires authentication, the username.</p>
</dd>
<dt><code>password</code></dt><dd><p>If the corpus on the server requires authentication, the
password.</p>
</dd>
</dl>


<h3>See Also</h3>

<p>Methods to extract basic information from a <code>corpus</code> object are
covered by the <code>corpus-methods</code> documentation object. Use the
<code><a href="#topic+s_attributes">s_attributes</a></code> method to get information on structural
attributes. Analytical methods available for <code>corpus</code> objects are
<code><a href="#topic+size">size</a></code>, <code><a href="#topic+count">count</a></code>, <code><a href="#topic+dispersion">dispersion</a></code>,
<code><a href="#topic+kwic">kwic</a></code>, <code><a href="#topic+cooccurrences">cooccurrences</a></code>,
<code><a href="#topic+as.TermDocumentMatrix">as.TermDocumentMatrix</a></code>.
</p>
<p>Other classes to manage corpora: 
<code><a href="#topic+phrases-class">phrases-class</a></code>,
<code><a href="#topic+ranges-class">ranges-class</a></code>,
<code><a href="#topic+regions">regions</a></code>,
<code><a href="#topic+subcorpus">subcorpus</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>use(pkg = "RcppCWB", corpus = "REUTERS")

# get corpora present locally
y &lt;- corpus()

# initialize corpus object
r &lt;- corpus("REUTERS")
r &lt;- corpus ("reuters") # will work, but will result in a warning


# apply core polmineR methods
a &lt;- size(r)
b &lt;- s_attributes(r)
c &lt;- count(r, query = "oil")
d &lt;- dispersion(r, query = "oil", s_attribute = "id")
e &lt;- kwic(r, query = "oil")
f &lt;- cooccurrences(r, query = "oil")

# used corpus initialization in a pipe
y &lt;- corpus("REUTERS") %&gt;% s_attributes()
y &lt;- corpus("REUTERS") %&gt;% count(query = "oil")

# working with a remote corpus
## Not run: 
REUTERS &lt;- corpus("REUTERS", server = Sys.getenv("OPENCPU_SERVER"))
count(REUTERS, query = "oil")
size(REUTERS)
kwic(REUTERS, query = "oil")

GERMAPARL &lt;- corpus("GERMAPARL", server = Sys.getenv("OPENCPU_SERVER"))
s_attributes(GERMAPARL)
size(x = GERMAPARL)
count(GERMAPARL, query = "Integration")
kwic(GERMAPARL, query = "Islam")

p &lt;- partition(GERMAPARL, year = 2000)
s_attributes(p, s_attribute = "year")
size(p)
kwic(p, query = "Islam", meta = "date")

GERMAPARL &lt;- corpus("GERMAPARLMINI", server = Sys.getenv("OPENCPU_SERVER"))
s_attrs &lt;- s_attributes(GERMAPARL, s_attribute = "date")
sc &lt;- subset(GERMAPARL, date == "2009-11-10")

## End(Not run)
</code></pre>

<hr>
<h2 id='corpus-methods'>Corpus class methods</h2><span id='topic+corpus-methods'></span><span id='topic+name+2Ccorpus-method'></span><span id='topic+get_corpus+2Ccorpus-method'></span><span id='topic+show+2Ccorpus-method'></span><span id='topic++24+2Ccorpus-method'></span><span id='topic+get_info+2Ccorpus-method'></span><span id='topic+show_info+2Ccorpus-method'></span>

<h3>Description</h3>

<p>A set of generic methods is available to extract basic information from
objects of the <code>corpus</code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'corpus'
name(x)

## S4 method for signature 'corpus'
get_corpus(x)

## S4 method for signature 'corpus'
show(object)

## S4 method for signature 'corpus'
x$name

## S4 method for signature 'corpus'
get_info(x)

## S4 method for signature 'corpus'
show_info(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corpus-methods_+3A_x">x</code></td>
<td>
<p>An object of class <code>corpus</code>, or inheriting from it.</p>
</td></tr>
<tr><td><code id="corpus-methods_+3A_object">object</code></td>
<td>
<p>An object of class <code>corpus</code>, or inheriting from it.</p>
</td></tr>
<tr><td><code id="corpus-methods_+3A_name">name</code></td>
<td>
<p>A (single) s-attribute.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code>corpus</code> object can have a name, which can be retrieved using
the <code>name</code>-method.
</p>
<p>Use <code>get_corpus()</code>-method to get the corpus ID from the slot
<code>corpus</code> of the <code>corpus</code> object.
</p>
<p>The <code>show()</code>-method will show basic information on the
<code>corpus</code> object.
</p>
<p>Applying the <code>$</code>-method on a corpus will return the values for the
s-attribute stated with argument <code>name</code>.
</p>
<p>Use <code>get_info</code> to get the the content of the info file for the
corpus (usually in the data directory of the corpus) and return it as a
<code>character</code> vector. Returns <code>NULL</code> if there is not info file.
</p>
<p>The <code>show_info</code>-method will get the content of the info
file for a corpus, turn it into an html document, and show the result in
the viewer pane of RStudio. If the filename of the info file ends on &quot;md&quot;,
the document is rendered as markdown.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get/show information on corpora
corpus("REUTERS") %&gt;% get_info()
corpus("REUTERS") %&gt;% show_info()
corpus("GERMAPARLMINI") %&gt;% get_info()
corpus("GERMAPARLMINI") %&gt;% show_info()

use(pkg = "RcppCWB", corpus = "REUTERS")

# show-method
if (interactive()) corpus("REUTERS") %&gt;% show()
if (interactive()) corpus("REUTERS") # show is called implicitly

# get corpus ID
corpus("REUTERS") %&gt;% get_corpus()

# use $ to access corpus properties
use("polmineR")
g &lt;- corpus("GERMAPARLMINI")
g$date
corpus("GERMAPARLMINI")$build_date #
gparl &lt;- corpus("GERMAPARLMINI")
gparl$version %&gt;%
  as.numeric_version()

</code></pre>

<hr>
<h2 id='count'>Get counts.</h2><span id='topic+count'></span><span id='topic+count-method'></span><span id='topic+count+2Cpartition-method'></span><span id='topic+count+2Csubcorpus-method'></span><span id='topic+count+2Cpartition_bundle-method'></span><span id='topic+count+2Csubcorpus_bundle-method'></span><span id='topic+count+2Ccorpus-method'></span><span id='topic+count+2Ccharacter-method'></span><span id='topic+count+2Cvector-method'></span><span id='topic+count+2Cremote_corpus-method'></span><span id='topic+count+2Cremote_subcorpus-method'></span>

<h3>Description</h3>

<p>Count all tokens, or number of occurrences of a query (CQP syntax may be
used), or matches for the query.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count(.Object, ...)

## S4 method for signature 'partition'
count(
  .Object,
  query = NULL,
  cqp = is.cqp,
  check = TRUE,
  breakdown = FALSE,
  decode = TRUE,
  p_attribute = getOption("polmineR.p_attribute"),
  mc = getOption("polmineR.cores"),
  verbose = TRUE,
  progress = FALSE,
  phrases = NULL,
  ...
)

## S4 method for signature 'subcorpus'
count(
  .Object,
  query = NULL,
  cqp = is.cqp,
  check = TRUE,
  breakdown = FALSE,
  decode = TRUE,
  p_attribute = getOption("polmineR.p_attribute"),
  mc = getOption("polmineR.cores"),
  verbose = TRUE,
  progress = FALSE,
  phrases = NULL,
  ...
)

## S4 method for signature 'partition_bundle'
count(
  .Object,
  query = NULL,
  cqp = FALSE,
  p_attribute = getOption("polmineR.p_attribute"),
  phrases = NULL,
  freq = FALSE,
  total = TRUE,
  mc = FALSE,
  progress = FALSE,
  verbose = FALSE,
  ...
)

## S4 method for signature 'subcorpus_bundle'
count(
  .Object,
  query = NULL,
  cqp = FALSE,
  p_attribute = NULL,
  phrases = NULL,
  freq = FALSE,
  total = TRUE,
  mc = FALSE,
  progress = TRUE,
  verbose = FALSE,
  ...
)

## S4 method for signature 'corpus'
count(
  .Object,
  query = NULL,
  cqp = is.cqp,
  check = TRUE,
  p_attribute = getOption("polmineR.p_attribute"),
  breakdown = FALSE,
  sort = FALSE,
  decode = TRUE,
  verbose = TRUE,
  ...
)

## S4 method for signature 'character'
count(
  .Object,
  query = NULL,
  cqp = is.cqp,
  check = TRUE,
  p_attribute = getOption("polmineR.p_attribute"),
  breakdown = FALSE,
  sort = FALSE,
  decode = TRUE,
  verbose = TRUE,
  ...
)

## S4 method for signature 'vector'
count(.Object, corpus, p_attribute, ...)

## S4 method for signature 'remote_corpus'
count(.Object, ...)

## S4 method for signature 'remote_subcorpus'
count(.Object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_+3A_.object">.Object</code></td>
<td>
<p>A <code>partition</code> or <code>partition_bundle</code>, or a length-one
character vector providing the name of a corpus.</p>
</td></tr>
<tr><td><code id="count_+3A_...">...</code></td>
<td>
<p>Further arguments. If <code>.Object</code> is a <code>remote_corpus</code>
object, the three dots (<code>...</code>) are used to pass arguments. Hence, it is
necessary to state the names of all arguments to be passed explicity.</p>
</td></tr>
<tr><td><code id="count_+3A_query">query</code></td>
<td>
<p>A character vector (one or multiple terms), CQP syntax can be
used.</p>
</td></tr>
<tr><td><code id="count_+3A_cqp">cqp</code></td>
<td>
<p>Either logical (<code>TRUE</code> if query is a CQP query), or a
function to check whether query is a CQP query or not (defaults to is.query
auxiliary function).</p>
</td></tr>
<tr><td><code id="count_+3A_check">check</code></td>
<td>
<p>A <code>logical</code> value, whether to check validity of CQP query
using <code>check_cqp_query</code>.</p>
</td></tr>
<tr><td><code id="count_+3A_breakdown">breakdown</code></td>
<td>
<p>Logical, whether to report number of occurrences for
different matches for a query.</p>
</td></tr>
<tr><td><code id="count_+3A_decode">decode</code></td>
<td>
<p>Logical, whether to turn token ids into decoded strings (only
if query is NULL).</p>
</td></tr>
<tr><td><code id="count_+3A_p_attribute">p_attribute</code></td>
<td>
<p>The p-attribute(s) to use.</p>
</td></tr>
<tr><td><code id="count_+3A_mc">mc</code></td>
<td>
<p>Logical, whether to use multicore (defaults to <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="count_+3A_verbose">verbose</code></td>
<td>
<p>Logical, whether to be verbose.</p>
</td></tr>
<tr><td><code id="count_+3A_progress">progress</code></td>
<td>
<p>Logical, whether to show progress bar.</p>
</td></tr>
<tr><td><code id="count_+3A_phrases">phrases</code></td>
<td>
<p>A <code>phrases</code> object. If provided, the denoted regions will
be concatenated as phrases.</p>
</td></tr>
<tr><td><code id="count_+3A_freq">freq</code></td>
<td>
<p>Logical, if <code>FALSE</code>, counts will be reported, if TRUE,
(relative) frequencies are added to table.</p>
</td></tr>
<tr><td><code id="count_+3A_total">total</code></td>
<td>
<p>Defaults to <code>FALSE</code>, if <code>TRUE</code>, the total value of
counts (column named 'TOTAL') will be amended to the <code>data.table</code> that
is returned.</p>
</td></tr>
<tr><td><code id="count_+3A_sort">sort</code></td>
<td>
<p>Logical, whether to sort table with counts (in stat slot).</p>
</td></tr>
<tr><td><code id="count_+3A_corpus">corpus</code></td>
<td>
<p>The name of a CWB corpus.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>.Object</code> is a <code>partiton_bundle</code>, the <code>data.table</code> returned will
have the queries in the columns, and as many rows as there are in the
<code>partition_bundle</code>.
</p>
<p>If <code>.Object</code> is a length-one <code>character</code> vector and <code>query</code> is
<code>NULL</code>, the count is performed for the whole partition.
</p>
<p>If <code>breakdown</code> is <code>TRUE</code> and one query is supplied, the function
returns a frequency breakdown of the results of the query. If several queries
are supplied, frequencies for the individual queries are retrieved.
</p>
<p>Multiple queries can be used for argument <code>query</code>. Some care may be
necessary when summing up the counts for the individual queries. When the
CQP syntax is used, different queries may yield the same match result, so that
the sum of all individual query matches may overestimate the true number of
unique matches. In the case of overlapping matches, a warning message is
issued. Collapsing multiple CQP queries into a single query (separating the
individual queries by &quot;|&quot; and wrapping everything in round brackets) solves
this problem.
</p>


<h3>Value</h3>

<p>A <code>data.table</code> if argument query is used, a <code>count</code>-object,
if query is <code>NULL</code> and <code>.Object</code> is a character vector (referring
to a corpus) or a <code>partition</code>, a <code>count_bundle</code>-object, if <code>.Object</code>
is a <code>partition_bundle</code>.
</p>


<h3>References</h3>

<p>Baker, Paul (2006): <em>Using Corpora in Discourse Analysis</em>. London: continuum, p. 47-69 (ch. 3).
</p>


<h3>See Also</h3>

<p>For a metadata-based breakdown of counts (i.e. tabulation by
s-attributes), see <code><a href="#topic+dispersion">dispersion</a></code>. The <code><a href="#topic+hits">hits</a></code> is the
worker behind the <code>dispersion</code> method and offers a similar, yet more
low-level functionality as compared to the <code>count</code> method. Using the
<code><a href="#topic+hits">hits</a></code> method may be useful to obtain the data required for
flexible cross-tabulations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>use("polmineR")
use(pkg = "RcppCWB", corpus = "REUTERS")

debates &lt;- partition("GERMAPARLMINI", date = ".*", regex=TRUE)
count(debates, query = "Arbeit") # get frequencies for one token
count(debates, c("Arbeit", "Freizeit", "Zukunft")) # get frequencies for multiple tokens
  
count("GERMAPARLMINI", query = c("Migration", "Integration"), p_attribute = "word")

debates &lt;- partition_bundle(
  "GERMAPARLMINI", s_attribute = "date", values = NULL,
  mc = FALSE, verbose = FALSE
)
y &lt;- count(debates, query = "Arbeit", p_attribute = "word")
y &lt;- count(debates, query = c("Arbeit", "Migration", "Zukunft"), p_attribute = "word")
  
count("GERMAPARLMINI", '"Integration.*"', breakdown = TRUE)

P &lt;- partition("GERMAPARLMINI", date = "2009-11-11")
count(P, '"Integration.*"', breakdown = TRUE)

sc &lt;- corpus("GERMAPARLMINI") %&gt;% subset(party == "SPD")
phr &lt;- cpos(sc, query = '"Deutsche.*" "Bundestag.*"', cqp = TRUE) %&gt;%
  as.phrases(corpus = "GERMAPARLMINI", enc = "latin1")
cnt &lt;- count(sc, phrases = phr, p_attribute = "word")

# Multiple queries and overlapping query matches. The first count 
# operation will issue a warning that matches overlap, see the second 
# example for a solution.
corpus("REUTERS") %&gt;%
  count(query = c('".*oil"', '"turmoil"'), cqp = TRUE)
corpus("REUTERS") %&gt;% 
  count(query = '"(.*oil|turmoil)"', cqp =TRUE)
</code></pre>

<hr>
<h2 id='count_class'>Count class.</h2><span id='topic+count_class'></span><span id='topic+count-class'></span><span id='topic+summary+2Ccount-method'></span><span id='topic+count_bundle-class'></span><span id='topic+length+2Ccount-method'></span><span id='topic+hist+2Ccount-method'></span>

<h3>Description</h3>

<p>S4 class to organize counts. The classes <code>polmineR</code> and
<code>ngrams</code> inherit from the class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'count'
summary(object)

## S4 method for signature 'count'
length(x)

## S4 method for signature 'count'
hist(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_class_+3A_object">object</code></td>
<td>
<p>A <code>count</code> object.</p>
</td></tr>
<tr><td><code id="count_class_+3A_x">x</code></td>
<td>
<p>A <code>count</code> object, or a class inheriting from <code>count</code>.</p>
</td></tr>
<tr><td><code id="count_class_+3A_...">...</code></td>
<td>
<p>Further parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>summary</code>-method in combination with a weighed
<code>count</code>-object can be used to perform a dictionary-based sentiment
analysis (see examples).
</p>
<p>The <code>length</code>-method is synonymous with the <code>size</code>-method
and will return the size of the <code>corpus</code> or <code>partition</code> a count
has been derived from.
</p>


<h3>Slots</h3>


<dl>
<dt><code>stat</code></dt><dd><p>Object of class <code>data.table</code>.</p>
</dd>
<dt><code>corpus</code></dt><dd><p>Object of class <code>character</code> the CWB corpus the partition is based on .</p>
</dd>
<dt><code>encoding</code></dt><dd><p>Object of class <code>character</code>, the encoding of the corpus.</p>
</dd>
<dt><code>name</code></dt><dd><p>Object of class <code>character</code>, a name for the object.</p>
</dd>
<dt><code>size</code></dt><dd><p>Object of class <code>integer</code>, the size of the partition or
corpus the count is based upon.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Andreas Blaette
</p>


<h3>See Also</h3>

<p>The <code>count</code>-class inherits from the <code><a href="#topic+textstat-class">textstat-class</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># sample for dictionary-based sentiment analysis
weights &lt;- data.table::data.table(
  word = c("gut", "super", "herrlich", "schlecht", "grob", "mies"),
  weight = c(1,1,1,-1,-1,-1)
)
corp &lt;- corpus("GERMAPARLMINI")
sc &lt;- subset(corp, date == "2009-11-11")
cnt &lt;- count(sc, p_attribute = "word")
cnt &lt;- weigh(cnt, with = weights)
y &lt;- summary(cnt)

# old, partition-based workflow
p &lt;- partition("GERMAPARLMINI", date = "2009-11-11")
p &lt;- enrich(p, p_attribute = "word")
weights &lt;- data.table::data.table(
  word = c("gut", "super", "herrlich", "schlecht", "grob", "mies"),
  weight = c(1,1,1,-1,-1,-1)
)
p &lt;- weigh(p, with = weights)
summary(p)
</code></pre>

<hr>
<h2 id='cpos'>Get corpus positions for a query or queries.</h2><span id='topic+cpos'></span><span id='topic+cpos+2Ccorpus-method'></span><span id='topic+cpos+2Ccharacter-method'></span><span id='topic+cpos+2Cslice-method'></span><span id='topic+cpos+2Cpartition-method'></span><span id='topic+cpos+2Csubcorpus-method'></span><span id='topic+cpos+2Cmatrix-method'></span><span id='topic+cpos+2Chits-method'></span><span id='topic+cpos+2CNULL-method'></span>

<h3>Description</h3>

<p>Get matches for a query in a CQP corpus (subcorpus, partition etc.),
optionally using the CQP syntax of the Corpus Workbench (CWB).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpos(.Object, ...)

## S4 method for signature 'corpus'
cpos(
  .Object,
  query,
  p_attribute = getOption("polmineR.p_attribute"),
  cqp = is.cqp,
  regex = FALSE,
  check = TRUE,
  verbose = TRUE,
  ...
)

## S4 method for signature 'character'
cpos(
  .Object,
  query,
  p_attribute = getOption("polmineR.p_attribute"),
  cqp = is.cqp,
  check = TRUE,
  verbose = TRUE,
  ...
)

## S4 method for signature 'slice'
cpos(
  .Object,
  query,
  cqp = is.cqp,
  check = TRUE,
  p_attribute = getOption("polmineR.p_attribute"),
  verbose = TRUE,
  ...
)

## S4 method for signature 'partition'
cpos(
  .Object,
  query,
  cqp = is.cqp,
  check = TRUE,
  p_attribute = getOption("polmineR.p_attribute"),
  verbose = TRUE,
  ...
)

## S4 method for signature 'subcorpus'
cpos(
  .Object,
  query,
  cqp = is.cqp,
  check = TRUE,
  p_attribute = getOption("polmineR.p_attribute"),
  verbose = TRUE,
  ...
)

## S4 method for signature 'matrix'
cpos(.Object)

## S4 method for signature 'hits'
cpos(.Object)

## S4 method for signature ''NULL''
cpos(.Object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpos_+3A_.object">.Object</code></td>
<td>
<p>A length-one <code>character</code> vector indicating a CWB corpus, or a
<code>corpus</code>, or <code>partition</code> object.</p>
</td></tr>
<tr><td><code id="cpos_+3A_...">...</code></td>
<td>
<p>Used for reasons of backwards compatibility to
process arguments that have been renamed (e.g. <code>pAttribute</code>).</p>
</td></tr>
<tr><td><code id="cpos_+3A_query">query</code></td>
<td>
<p>A <code>character</code> vector providing one or multiple queries (token to
look up, regular expression or CQP query). Token ids (i.e. <code>integer</code>
values) are also accepted. If <code>query</code> is neither a regular expression nor a
CQP query, a sanity check removes accidental leading/trailing whitespace,
issuing a respective warning.</p>
</td></tr>
<tr><td><code id="cpos_+3A_p_attribute">p_attribute</code></td>
<td>
<p>The p-attribute to search. Needs to be stated only if query
is not a CQP query. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cpos_+3A_cqp">cqp</code></td>
<td>
<p>Either logical (<code>TRUE</code> if query is a CQP query), or a function to
check whether query is a CQP query or not (defaults to <code>is.cqp</code> auxiliary
function).</p>
</td></tr>
<tr><td><code id="cpos_+3A_regex">regex</code></td>
<td>
<p>Interpret <code>query</code> as a regular expression.</p>
</td></tr>
<tr><td><code id="cpos_+3A_check">check</code></td>
<td>
<p>A <code>logical</code> value, whether to check validity of CQP query
using <code>check_cqp_query</code>.</p>
</td></tr>
<tr><td><code id="cpos_+3A_verbose">verbose</code></td>
<td>
<p>A <code>logical</code> value, whether to show messages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>cpos()</code>-method returns a two-column <code>matrix</code> with the ranges (start end
end corpus positions of the matches) matched by a query. CQP syntax can be
used. The encoding of the query is adjusted to conform to the encoding of the
CWB corpus. If there are not matches, <code>NULL</code> is returned.
</p>
<p>Previous polmineR versions defined the <code>cpos()</code>-method for <code>matrix</code> and
<code>hits</code> objects to obtain an integer vector with unfolded individual corpus
positions. This usage is deprecated starting with polmineR v0.8.8
</p>


<h3>Value</h3>

<p>A <code>matrix</code> with two columns.  The first column reports the
left/starting corpus positions (cpos) of the hits obtained. The second
column reports the right/ending corpus positions of the respective hit. The
number of rows is the number of hits. If there are no hits, <code>NULL</code> is
returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>use(pkg = "RcppCWB", corpus = "REUTERS")

# look up single tokens
cpos("REUTERS", query = "oil")
corpus("REUTERS") %&gt;% cpos(query = "oil")

corpus("REUTERS") %&gt;%
  subset(grepl("saudi-arabia", places)) %&gt;%
  cpos(query = "oil")
  
partition("REUTERS", places = "saudi-arabia", regex = TRUE) %&gt;%
  cpos(query = "oil")

# use CQP query syntax
cpos("REUTERS", query = '"Saudi" "Arabia"')
corpus("REUTERS") %&gt;% cpos(query = '"Saudi" "Arabia"')
corpus("REUTERS") %&gt;%
  subset(grepl("saudi-arabia", places)) %&gt;%
  cpos(query = '"Saudi" "Arabia"', cqp = TRUE)
partition("REUTERS", places = "saudi-arabia", regex = TRUE) %&gt;%
  cpos(query = '"Saudi" "Arabia"', cqp = TRUE)
</code></pre>

<hr>
<h2 id='cqp'>Tools for CQP queries.</h2><span id='topic+cqp'></span><span id='topic+is.cqp'></span><span id='topic+check_cqp_query'></span><span id='topic+as.cqp'></span>

<h3>Description</h3>

<p>Test whether a character string is a CQP query, or turn a character
vector into CQP queries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.cqp(query)

check_cqp_query(query, warn = TRUE)

as.cqp(
  query,
  normalise.case = FALSE,
  collapse = FALSE,
  check = TRUE,
  warn = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cqp_+3A_query">query</code></td>
<td>
<p>A <code>character</code> vector with at least one CQP query.</p>
</td></tr>
<tr><td><code id="cqp_+3A_warn">warn</code></td>
<td>
<p>A (length-one) <code>logical</code> value, whether to issue a warning if a
query may be buggy.</p>
</td></tr>
<tr><td><code id="cqp_+3A_normalise.case">normalise.case</code></td>
<td>
<p>A <code>logical</code> value, if <code>TRUE</code>, a flag will be
added to the query/queries to omit matching case.</p>
</td></tr>
<tr><td><code id="cqp_+3A_collapse">collapse</code></td>
<td>
<p>A <code>logical</code> value, whether to collapse the queries into one.</p>
</td></tr>
<tr><td><code id="cqp_+3A_check">check</code></td>
<td>
<p>A <code>logical</code> value whether to run <code>check_cqp_query()</code> on queries.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>is.cqp()</code> function guesses whether <code>query</code> is a CQP query
and returns the respective logical value (<code>TRUE</code>/<code>FALSE</code>).
</p>
<p>The <code>as.cqp()</code> function takes a character vector as input and converts it
to a CQP query by putting the individual strings in quotation marks.
</p>
<p>The <code>check_cqp_query</code>-function will check that opening
quotation marks are matched by closing quotation marks, to prevent crashes
of CQP and the R session.
</p>


<h3>Value</h3>

<p><code>is.cqp</code> returns a logical value, <code>as.cqp</code> a character
vector, <code>check_cqp_query</code> a logical value that is <code>TRUE</code> if all
queries are valid, or <code>FALSE</code> if not.
</p>


<h3>References</h3>

<p>CQP Query Language Tutorial
(<a href="https://cwb.sourceforge.io/files/CQP_Tutorial.pdf">https://cwb.sourceforge.io/files/CQP_Tutorial.pdf</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is.cqp("migration") # will return FALSE
is.cqp('"migration"') # will return TRUE
is.cqp('[pos = "ADJA"] "migration"') # will return TRUE

as.cqp("migration")
as.cqp(c("migration", "diversity"))
as.cqp(c("migration", "diversity"), collapse = TRUE)
as.cqp("migration", normalise.case = TRUE)

check_cqp_query('"Integration.*"') # TRUE, the query is ok
check_cqp_query('"Integration.*') # FALSE, closing quotation mark is missing
check_cqp_query("'Integration.*") # FALSE, closing quotation mark is missing
check_cqp_query(c("'Integration.*", '"Integration.*')) # FALSE too
</code></pre>

<hr>
<h2 id='decode-method'>Decode corpus or subcorpus.</h2><span id='topic+decode-method'></span><span id='topic+decode'></span><span id='topic+decode+2Ccorpus-method'></span><span id='topic+decode+2Ccharacter-method'></span><span id='topic+decode+2Cslice-method'></span><span id='topic+decode+2Cpartition-method'></span><span id='topic+decode+2Csubcorpus-method'></span><span id='topic+decode+2Cinteger-method'></span><span id='topic+decode+2Cdata.table-method'></span>

<h3>Description</h3>

<p>Decode <code>corpus</code> or <code>subcorpus</code> and return class specified by argument <code>to</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decode(.Object, ...)

## S4 method for signature 'corpus'
decode(
  .Object,
  to = c("data.table", "Annotation", "AnnotatedPlainTextDocument"),
  p_attributes = NULL,
  s_attributes = NULL,
  mw = NULL,
  stoplist = NULL,
  decode = TRUE,
  verbose = TRUE
)

## S4 method for signature 'character'
decode(
  .Object,
  to = c("data.table", "Annotation"),
  s_attributes = NULL,
  p_attributes = NULL,
  decode = TRUE,
  verbose = TRUE
)

## S4 method for signature 'slice'
decode(
  .Object,
  to = c("data.table", "Annotation", "AnnotatedPlainTextDocument"),
  s_attributes = NULL,
  p_attributes = NULL,
  mw = NULL,
  stoplist = NULL,
  decode = TRUE,
  verbose = TRUE
)

## S4 method for signature 'partition'
decode(
  .Object,
  to = "data.table",
  s_attributes = NULL,
  p_attributes = NULL,
  decode = TRUE,
  verbose = TRUE
)

## S4 method for signature 'subcorpus'
decode(
  .Object,
  to = c("data.table", "Annotation", "AnnotatedPlainTextDocument"),
  s_attributes = NULL,
  p_attributes = NULL,
  mw = NULL,
  stoplist = NULL,
  decode = TRUE,
  verbose = TRUE
)

## S4 method for signature 'integer'
decode(.Object, corpus, p_attributes, boost = NULL)

## S4 method for signature 'data.table'
decode(.Object, corpus, p_attributes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decode-method_+3A_.object">.Object</code></td>
<td>
<p>The <code>corpus</code> or <code>subcorpus</code> to decode.</p>
</td></tr>
<tr><td><code id="decode-method_+3A_...">...</code></td>
<td>
<p>Further arguments.</p>
</td></tr>
<tr><td><code id="decode-method_+3A_to">to</code></td>
<td>
<p>The class of the returned object, stated as a length-one
<code>character</code> vector.</p>
</td></tr>
<tr><td><code id="decode-method_+3A_p_attributes">p_attributes</code></td>
<td>
<p>The positional attributes to decode. If <code>NULL</code> (default),
all positional attributes will be decoded.</p>
</td></tr>
<tr><td><code id="decode-method_+3A_s_attributes">s_attributes</code></td>
<td>
<p>The structural attributes to decode. If <code>NULL</code> (default),
all structural attributes will be decoded.</p>
</td></tr>
<tr><td><code id="decode-method_+3A_mw">mw</code></td>
<td>
<p>A <code>character</code> vector with s-attributes with multiword expressions.
Used only if <code>to</code> is 'AnnotatedPlainTextDocument'.</p>
</td></tr>
<tr><td><code id="decode-method_+3A_stoplist">stoplist</code></td>
<td>
<p>A <code>character</code> vector with terms to be dropped.</p>
</td></tr>
<tr><td><code id="decode-method_+3A_decode">decode</code></td>
<td>
<p>A <code>logical</code> value, whether to decode token ids and struc ids to
character strings. If <code>FALSE</code>, the values of columns for p- and
s-attributes will be <code>integer</code> vectors. If <code>TRUE</code> (default), the respective
columns are <code>character</code> vectors.</p>
</td></tr>
<tr><td><code id="decode-method_+3A_verbose">verbose</code></td>
<td>
<p>A <code>logical</code> value, whether to output progess messages.</p>
</td></tr>
<tr><td><code id="decode-method_+3A_corpus">corpus</code></td>
<td>
<p>A CWB indexed corpus, either a length-one <code>character</code> vector,
or a <code>corpus</code> object.</p>
</td></tr>
<tr><td><code id="decode-method_+3A_boost">boost</code></td>
<td>
<p>A length-one <code>logical</code> value, whether to speed up decoding
a long vector of token ids by directly by reading in the lexion file from
the data directory of a corpus. If <code>NULL</code> (default), the internal
decision rule is that <code>boost</code> will be <code>TRUE</code> if the corpus is
larger than 10 000 000 million tokens and more than 5 percent of the corpus
are to be decoded.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The primary purpose of the method is type conversion. By obtaining the corpus
or subcorpus in the format specified by the argument <code>to</code>, the data can be
processed with tools that do not rely on the Corpus Workbench (CWB).
Supported output formats are <code>data.table</code> (which can be converted to a
<code>data.frame</code> or <code>tibble</code> easily) or an <code>Annotation</code> object as defined in the
package 'NLP'. Another purpose of decoding the corpus can be to rework it,
and to re-import it into the CWB (e.g. using the 'cwbtools'-package).
</p>
<p>An earlier version of the method included an option to decode a single
s-attribute, which is not supported any more. See the <code>s_attribute_decode()</code>
function of the package RcppCWB.
</p>
<p>If <code>.Object</code> is an <code>integer</code> vector, it is assumed to be a
vector of integer ids of p-attributes. The <code>decode</code>-method will
translate token ids to string values as efficiently as possible. The
approach taken will depend on the corpus size and the share of the corpus
that is to be decoded. To decode a large number of integer ids, it is more
efficient to read the lexicon file from the data directory directly and to
index the lexicon with the ids rather than relying on
<code>RcppCWB::cl_id2str</code>. The internal decision rule is to use the lexicon
file when the corpus is larger than 10 000 000 million tokens and more than
5 percent of the corpus are to be decoded. The encoding of the
<code>character</code> vector that is returned will be the coding of the locale
(usually ISO-8859-1 on Windows, and UTF-8 on macOS and Linux machines).
</p>
<p>The <code>decode</code>-method for <code>data.table</code> objects will decode
token ids (column '<code>p-attribute</code>_id'), adding the corresponding string as a
new column. If a column &quot;cpos&quot; with corpus positions is present, ids are
derived for the corpus positions given first. If the <code>data.table</code>
neither has a column &quot;cpos&quot; nor columns with token ids (i.e. colummn name
ending with &quot;_id&quot;), the input <code>data.table</code> is returned unchanged. Note
that columns are added to the <code>data.table</code> in an in-place operation to
handle memory parsimoniously.
</p>


<h3>Value</h3>

<p>The return value will correspond to the class specified by argument
<code>to</code>.
</p>


<h3>See Also</h3>

<p>To decode a structural attribute, you can use the
<code><a href="#topic+s_attributes">s_attributes</a></code>-method, setting argument <code>unique</code> as
<code>FALSE</code> and <code><a href="RcppCWB.html#topic+s_attribute_decode">s_attribute_decode</a></code>. See
<code><a href="#topic+as.VCorpus">as.VCorpus</a></code> to decode a <code>partition_bundle</code> object,
returning a <code>VCorpus</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>use("polmineR")
use(pkg = "RcppCWB", corpus = "REUTERS")

# Decode corpus as data.table
dt &lt;- decode("REUTERS", to = "data.table")

# Decode corpus selectively
dt &lt;- decode(
  "REUTERS",
  to = "data.table",
  p_attributes = "word",
  s_attributes = "id"
)

# Decode a subcorpus
dt &lt;- corpus("REUTERS") %&gt;%
  subset(id %in% c("127", "144")) %&gt;%
  decode(s_attributes = "id", to = "data.table")

# Decode partition
dt &lt;- partition("REUTERS", places = "kuwait", regex = TRUE) %&gt;%
  decode(to = "data.table")

# Previous versions of polmineR offered an option to decode a single
# s-attribute. This is how you could proceed to get a table with metadata.
dt &lt;- partition("REUTERS", places = "kuwait", regex = TRUE) %&gt;% 
  decode(s_attribute = "id", decode = FALSE, to = "data.table")
dt[, "word" := NULL]
dt[,{list(cpos_left = min(.SD[["cpos"]]), cpos_right = max(.SD[["cpos"]]))}, by = "id"]

# Decode subcorpus as Annotation object
## Not run: 
if (requireNamespace("NLP")){
  library(NLP)
  p &lt;- corpus("GERMAPARLMINI") %&gt;%
    subset(date == "2009-11-10" &amp; speaker == "Angela Dorothea Merkel")
  s &lt;- as(p, "String")
  a &lt;- as(p, "Annotation")
  
  # The beauty of having this NLP Annotation object is that you can now use 
  # the different annotators of the openNLP package. Here, just a short scenario
  # how you can have a look at the tokenized words and the sentences.

  words &lt;- s[a[a$type == "word"]]
  sentences &lt;- s[a[a$type == "sentence"]] # does not yet work perfectly for plenary protocols 
  
  doc &lt;- decode(p, to = "AnnotatedPlainTextDocument")
}

## End(Not run)
 
# decode vector of token ids
y &lt;- decode(0:20, corpus = "GERMAPARLMINI", p_attributes = "word")
dt &lt;- data.table::data.table(cpos = cpos("GERMAPARLMINI", query = "Liebe")[,1])
decode(dt, corpus = "GERMAPARLMINI", p_attributes = c("word", "pos"))
y &lt;- dt[, .N, by = c("word", "pos")]
</code></pre>

<hr>
<h2 id='dispersion'>Dispersion of a query or multiple queries.</h2><span id='topic+dispersion'></span><span id='topic+dispersion+2Cpartition-method'></span><span id='topic+dispersion+2Cslice-method'></span><span id='topic+dispersion+2Csubcorpus-method'></span><span id='topic+dispersion+2Ccorpus-method'></span><span id='topic+dispersion+2Ccharacter-method'></span><span id='topic+dispersion+2Chits-method'></span><span id='topic+dispersion+2Cremote_corpus-method'></span><span id='topic+dispersion+2Cremote_subcorpus-method'></span>

<h3>Description</h3>

<p>The method returns a <code>data.table</code> with the number of matches of a query
or multiple queries (optionally frequencies) in a corpus or subcorpus as
partitioned by one or two s-attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dispersion(.Object, ...)

## S4 method for signature 'slice'
dispersion(
  .Object,
  query,
  s_attribute,
  cqp = FALSE,
  p_attribute = getOption("polmineR.p_attribute"),
  freq = FALSE,
  fill = TRUE,
  mc = FALSE,
  progress = FALSE,
  verbose = FALSE,
  ...
)

## S4 method for signature 'partition'
dispersion(
  .Object,
  query,
  s_attribute,
  cqp = FALSE,
  p_attribute = getOption("polmineR.p_attribute"),
  freq = FALSE,
  fill = TRUE,
  mc = FALSE,
  progress = TRUE,
  verbose = FALSE,
  ...
)

## S4 method for signature 'subcorpus'
dispersion(
  .Object,
  query,
  s_attribute,
  cqp = FALSE,
  p_attribute = getOption("polmineR.p_attribute"),
  freq = FALSE,
  fill = FALSE,
  mc = FALSE,
  progress = TRUE,
  verbose = FALSE,
  ...
)

## S4 method for signature 'corpus'
dispersion(
  .Object,
  query,
  s_attribute,
  cqp = is.cqp,
  p_attribute = getOption("polmineR.p_attribute"),
  freq = FALSE,
  fill = TRUE,
  mc = FALSE,
  progress = FALSE,
  verbose = FALSE,
  ...
)

## S4 method for signature 'character'
dispersion(
  .Object,
  query,
  s_attribute,
  cqp = is.cqp,
  p_attribute = getOption("polmineR.p_attribute"),
  freq = FALSE,
  fill = TRUE,
  mc = FALSE,
  progress = TRUE,
  verbose = TRUE,
  ...
)

## S4 method for signature 'hits'
dispersion(
  .Object,
  source,
  s_attribute,
  freq = FALSE,
  fill = TRUE,
  verbose = TRUE,
  ...
)

## S4 method for signature 'remote_corpus'
dispersion(.Object, ...)

## S4 method for signature 'remote_subcorpus'
dispersion(.Object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dispersion_+3A_.object">.Object</code></td>
<td>
<p>A <code>corpus</code>, <code>subcorpus</code> or <code>partition</code> object
or a corpus provided by a character string.</p>
</td></tr>
<tr><td><code id="dispersion_+3A_...">...</code></td>
<td>
<p>Further parameters.</p>
</td></tr>
<tr><td><code id="dispersion_+3A_query">query</code></td>
<td>
<p>A <code>character</code> vector stating one or multiple queries.</p>
</td></tr>
<tr><td><code id="dispersion_+3A_s_attribute">s_attribute</code></td>
<td>
<p>A <code>character</code> vector (length 1 or 2) providing s-attributes.</p>
</td></tr>
<tr><td><code id="dispersion_+3A_cqp">cqp</code></td>
<td>
<p>If <code>logical</code>, whether the query is a CQP query, if it is a
function that is passed in, the function will be applied to the query to
guess whether query is a CQP query</p>
</td></tr>
<tr><td><code id="dispersion_+3A_p_attribute">p_attribute</code></td>
<td>
<p>Length one <code>character</code> vector, the p-attribute that
will be looked up (typically 'word' or 'lemma').</p>
</td></tr>
<tr><td><code id="dispersion_+3A_freq">freq</code></td>
<td>
<p>A <code>logical</code> value, whether to calculate normalized frequencies.</p>
</td></tr>
<tr><td><code id="dispersion_+3A_fill">fill</code></td>
<td>
<p>A <code>logical</code> value, whether to report zero matches. Defaults
to <code>TRUE</code>. But note that if there are few matches and many values of
the s-attribute(s), the resulting data structure is sparse and potentially
bloated.</p>
</td></tr>
<tr><td><code id="dispersion_+3A_mc">mc</code></td>
<td>
<p>A <code>logical</code> value, whether to use multicore.</p>
</td></tr>
<tr><td><code id="dispersion_+3A_progress">progress</code></td>
<td>
<p>A <code>logical</code> value, whether to show progress.</p>
</td></tr>
<tr><td><code id="dispersion_+3A_verbose">verbose</code></td>
<td>
<p>A <code>logical</code> value, whether to be verbose.</p>
</td></tr>
<tr><td><code id="dispersion_+3A_source">source</code></td>
<td>
<p>The source of the evaluation the hits reported in
<code>.Object</code> are based on, a <code>corpus</code>, <code>subcorpus</code> or
<code>partition</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Augmenting the <code>data.table</code> with zeros for subcorpora that do
not yield query matches (argument <code>fill</code> = <code>TRUE</code>) may require
adding many new columns. A respective warning issued by the
<code>data.table</code> package is supplemented an additional explanatory note
of the polmineR package.
</p>


<h3>Value</h3>

<p>A <code>data.table</code>.
</p>
<p>A <code>data.table</code>.
</p>


<h3>Author(s)</h3>

<p>Andreas Blaette
</p>


<h3>See Also</h3>

<p>The worker behind the <code>dispersion</code>-method is the <code>hits</code>-method.
</p>
<p>count
</p>


<h3>Examples</h3>

<pre><code class='language-R'>use("polmineR")
dispersion("GERMAPARLMINI", query = "Integration", s_attribute = "date")

test &lt;- partition("GERMAPARLMINI", date = ".*", p_attribute = NULL, regex = TRUE)
integration &lt;- dispersion(
  test, query = "Integration",
  p_attribute = "word", s_attribute = "date"
)
integration &lt;- dispersion(test, "Integration", s_attribute = c("date", "party"))
integration &lt;- dispersion(test, '"Integration.*"', s_attribute = "date", cqp = TRUE)
</code></pre>

<hr>
<h2 id='dotplot'>dotplot</h2><span id='topic+dotplot'></span><span id='topic+dotplot+2Ctextstat-method'></span><span id='topic+dotplot+2Cfeatures-method'></span><span id='topic+dotplot+2Cfeatures_ngrams-method'></span><span id='topic+dotplot+2Cpartition-method'></span>

<h3>Description</h3>

<p>dotplot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dotplot(.Object, ...)

## S4 method for signature 'textstat'
dotplot(.Object, col, n = 20L, ...)

## S4 method for signature 'features'
dotplot(.Object, col = NULL, n = 20L, ...)

## S4 method for signature 'features_ngrams'
dotplot(.Object, col = NULL, n = 20L, ...)

## S4 method for signature 'partition'
dotplot(.Object, col = "count", n = 20L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dotplot_+3A_.object">.Object</code></td>
<td>
<p>object</p>
</td></tr>
<tr><td><code id="dotplot_+3A_...">...</code></td>
<td>
<p>further arguments that will be passed into the <code>dotchart</code> function</p>
</td></tr>
<tr><td><code id="dotplot_+3A_col">col</code></td>
<td>
<p>column</p>
</td></tr>
<tr><td><code id="dotplot_+3A_n">n</code></td>
<td>
<p>number</p>
</td></tr>
</table>

<hr>
<h2 id='encoding'>Get and set encoding.</h2><span id='topic+encoding'></span><span id='topic+encoding+3C-'></span><span id='topic+encoding+2Cmissing-method'></span><span id='topic+encoding+2Ctextstat-method'></span><span id='topic+encoding+2Cbundle-method'></span><span id='topic+encoding+2Ccharacter-method'></span><span id='topic+encoding+2Ccorpus-method'></span><span id='topic+encoding+2Csubcorpus-method'></span><span id='topic+encoding+2Ccall-method'></span><span id='topic+encoding+2Cquosure-method'></span><span id='topic+encoding+3C-+2Ccall-method'></span><span id='topic+encoding+3C-+2Cquosure-method'></span>

<h3>Description</h3>

<p>Method for <code>textstat</code> objects and classes inheriting from
<code>textstat</code>; if <code>object</code> is a character vector, the encoding of the
corpus is returned. If called without arguments, the session character set is
returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>encoding(object)

encoding(object) &lt;- value

## S4 method for signature 'missing'
encoding(object)

## S4 method for signature 'textstat'
encoding(object)

## S4 method for signature 'bundle'
encoding(object)

## S4 method for signature 'character'
encoding(object)

## S4 method for signature 'corpus'
encoding(object)

## S4 method for signature 'subcorpus'
encoding(object)

## S4 method for signature 'call'
encoding(object)

## S4 method for signature 'quosure'
encoding(object)

## S4 replacement method for signature 'call'
encoding(object) &lt;- value

## S4 replacement method for signature 'quosure'
encoding(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="encoding_+3A_object">object</code></td>
<td>
<p>A <code>textstat</code> or <code>bundle</code> object (or an object
inheriting from these classes), or a length-one <code>character</code> vector
specifying a corpus. If missing, the method will return the session
character set.</p>
</td></tr>
<tr><td><code id="encoding_+3A_value">value</code></td>
<td>
<p>Value to be assigned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>encoding()</code> uses <code>l10n_info()</code> and <code>localeToCharset()</code> (in this
order) to determine the session encoding. If <code>localeToCharset()</code> returns
<code>NA</code>, &quot;UTF-8&quot; is assumed to be the session encoding.
</p>


<h3>Value</h3>

<p>A length-one <code>character</code> vector with an encoding.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get session charset.
encoding()

# Get encoding of a corpus.
encoding("REUTERS")

# Get encoding of a partition.
r &lt;- partition("REUTERS", places = "kuwait", regex = TRUE)
encoding(r)

# Get encoding of another class inheriting from textstat (count).
cnt &lt;- count("REUTERS", p_attribute = "word")
encoding(cnt)

# Get encoding of objects in a bundle.
pb &lt;- partition_bundle("REUTERS", s_attribute = "id")
encoding(pb)
</code></pre>

<hr>
<h2 id='encodings'>Conversion between corpus and native encoding.</h2><span id='topic+encodings'></span><span id='topic+as.utf8'></span><span id='topic+as.nativeEnc'></span><span id='topic+as.corpusEnc'></span>

<h3>Description</h3>

<p>Utility functions to convert the encoding of a <code>character</code> vector
between the native encoding and the encoding of the corpus.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.utf8(x, from)

as.nativeEnc(x, from)

as.corpusEnc(x, from = encoding(), corpusEnc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="encodings_+3A_x">x</code></td>
<td>
<p>A <code>character</code> to be converted.</p>
</td></tr>
<tr><td><code id="encodings_+3A_from">from</code></td>
<td>
<p>A <code>character</code> vector describing the encoding of the input
character vector.</p>
</td></tr>
<tr><td><code id="encodings_+3A_corpusenc">corpusEnc</code></td>
<td>
<p>A <code>character</code> vector describing the target encoding,
i.e. the encoding of the corpus (usually &quot;latin1&quot;, &quot;UTF-8&quot;)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The encoding of a corpus and the encoding of the terminal (the native
encoding) may differ, provoking strange or wrong results if no conversion is
carried out between the potentially differing encodings. The functions
<code>as.nativeEnc()</code> and <code>as.corpusEnc</code> are auxiliary functions to
assist the conversion. The functions <code>as.nativeEnc</code> and <code>as.utf8</code>
deliberately remove the explicit statement of the encoding, to avoid warnings
that may occur with character vector columns in a <code>data.table</code> object.
</p>

<hr>
<h2 id='enrich'>Enrich an object.</h2><span id='topic+enrich'></span><span id='topic+enrich-method'></span>

<h3>Description</h3>

<p>Methods to enrich objects with additional (statistical) information. The
methods are documented with the classes to which they adhere. See the
references in the <code>seealso</code>-section.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enrich(.Object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="enrich_+3A_.object">.Object</code></td>
<td>
<p>a <code>partition</code>, <code>partition_bundle</code> or comp object</p>
</td></tr>
<tr><td><code id="enrich_+3A_...">...</code></td>
<td>
<p>further parameters</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>The enrich method is defined for the following classes:
&quot;partition&quot;, (see <code><a href="#topic+partition_class">partition_class</a></code>),
&quot;partition_bundle&quot; (see <code><a href="#topic+partition_bundle-class">partition_bundle-class</a></code>),
&quot;kwic&quot; (see <code><a href="#topic+kwic-class">kwic-class</a></code>), and
&quot;context&quot; (see <code><a href="#topic+context-class">context-class</a></code>). See the linked documentation
to learn how the enrich method can be applied to respective objects.
</p>

<hr>
<h2 id='features'>Get features by comparison.</h2><span id='topic+features'></span><span id='topic+features+2Cpartition-method'></span><span id='topic+features+2Ccount-method'></span><span id='topic+features+2Cpartition_bundle-method'></span><span id='topic+features+2Ccount_bundle-method'></span><span id='topic+features+2Cngrams-method'></span><span id='topic+features+2CCooccurrences-method'></span>

<h3>Description</h3>

<p>The features of two objects, usually a <code>partition</code> defining a corpus of
interest (coi), and a <code>partition</code> defining a reference corpus (ref) are compared.
The most important purpose is term extraction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>features(x, y, ...)

## S4 method for signature 'partition'
features(x, y, included = FALSE, method = "chisquare", verbose = FALSE)

## S4 method for signature 'count'
features(
  x,
  y,
  by = NULL,
  included = FALSE,
  method = "chisquare",
  verbose = TRUE
)

## S4 method for signature 'partition_bundle'
features(
  x,
  y,
  included = FALSE,
  method = "chisquare",
  verbose = TRUE,
  mc = getOption("polmineR.mc"),
  progress = FALSE
)

## S4 method for signature 'count_bundle'
features(
  x,
  y,
  included = FALSE,
  method = "chisquare",
  verbose = !progress,
  mc = getOption("polmineR.mc"),
  progress = FALSE
)

## S4 method for signature 'ngrams'
features(x, y, included = FALSE, method = "chisquare", verbose = TRUE, ...)

## S4 method for signature 'Cooccurrences'
features(x, y, included = FALSE, method = "ll", verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="features_+3A_x">x</code></td>
<td>
<p>A <code>partition</code> or <code>partition_bundle</code> object.</p>
</td></tr>
<tr><td><code id="features_+3A_y">y</code></td>
<td>
<p>A <code>partition</code> object, it is assumed that the coi is a subcorpus of
ref</p>
</td></tr>
<tr><td><code id="features_+3A_...">...</code></td>
<td>
<p>further parameters</p>
</td></tr>
<tr><td><code id="features_+3A_included">included</code></td>
<td>
<p>TRUE if coi is part of ref, defaults to FALSE</p>
</td></tr>
<tr><td><code id="features_+3A_method">method</code></td>
<td>
<p>the statistical test to apply (chisquare or log likelihood)</p>
</td></tr>
<tr><td><code id="features_+3A_verbose">verbose</code></td>
<td>
<p>A <code>logical</code> value, defaults to TRUE</p>
</td></tr>
<tr><td><code id="features_+3A_by">by</code></td>
<td>
<p>the columns used for merging, if NULL (default), the p-attribute of
x will be used</p>
</td></tr>
<tr><td><code id="features_+3A_mc">mc</code></td>
<td>
<p>logical, whether to use multicore</p>
</td></tr>
<tr><td><code id="features_+3A_progress">progress</code></td>
<td>
<p>logical</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andreas Blaette
</p>


<h3>References</h3>

<p>Baker, Paul (2006): <em>Using Corpora in Discourse Analysis</em>. London: continuum, p. 121-149 (ch. 6).
</p>
<p>Manning, Christopher D.; Schuetze, Hinrich (1999): <em>Foundations of Statistical Natural Language
Processing</em>. MIT Press: Cambridge, Mass., pp. 151-189 (ch. 5).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
use("polmineR")

kauder &lt;- partition(
  "GERMAPARLMINI",
  speaker = "Volker Kauder", interjection = "speech",
  p_attribute = "word"
  )
all &lt;- partition("GERMAPARLMINI", interjection = "speech", p_attribute = "word")

terms_kauder &lt;- features(x = kauder, y = all, included = TRUE)
top100 &lt;- subset(terms_kauder, rank_chisquare &lt;= 100)
head(top100)

# a different way is to compare count objects
kauder_count &lt;- as(kauder, "count")
all_count &lt;- as(all, "count")
terms_kauder &lt;- features(kauder_count, all_count, included = TRUE)
top100 &lt;- subset(terms_kauder, rank_chisquare &lt;= 100)
head(top100)

## End(Not run)

# get matrix with features (dontrun to keep time for examples short)
## Not run: 
use("RcppCWB")
docs &lt;- partition_bundle("REUTERS", s_attribute = "id") %&gt;%
  enrich( p_attribute = "word")
all &lt;- corpus("REUTERS") %&gt;%
  count(p_attribute = "word")
docs_terms &lt;- features(docs[1:5], all, included = TRUE, progress = FALSE)
dtm &lt;- as.DocumentTermMatrix(docs_terms, col = "chisquare", verbose = FALSE)

## End(Not run)
# Get features of objects in a count_bundle
ref &lt;- corpus("GERMAPARLMINI") %&gt;% count(p_attribute = "word")
cois &lt;- corpus("GERMAPARLMINI") %&gt;%
  subset(speaker %in% c("Angela Dorothea Merkel", "Hubertus Heil")) %&gt;%
  split(s_attribute = "speaker") %&gt;%
  count(p_attribute = "word")
y &lt;- features(cois, ref, included = TRUE, method = "chisquare", progress = TRUE)
</code></pre>

<hr>
<h2 id='features-class'>Feature selection by comparison.</h2><span id='topic+features-class'></span><span id='topic+kwic_bundle-class'></span><span id='topic+features_cooccurrences-class'></span><span id='topic+features_ngrams-class'></span><span id='topic+features_bundle-class'></span><span id='topic+summary+2Cfeatures-method'></span><span id='topic+show+2Cfeatures-method'></span><span id='topic+summary+2Cfeatures_bundle-method'></span><span id='topic+format+2Cfeatures-method'></span><span id='topic+view+2Cfeatures-method'></span>

<h3>Description</h3>

<p>The  <code>features</code>-method returns a <code>features</code>-object. Several
<code>features</code>-objects can be combined into a <code>features_bundle</code>-object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'features'
summary(object)

## S4 method for signature 'features'
show(object)

## S4 method for signature 'features_bundle'
summary(object)

## S4 method for signature 'features'
format(x, digits = 2L)

## S4 method for signature 'features'
view(.Object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="features-class_+3A_object">object</code></td>
<td>
<p>A <code>features</code> or <code>features_bundle</code> object.</p>
</td></tr>
<tr><td><code id="features-class_+3A_x">x</code></td>
<td>
<p>A <code>features</code> object.</p>
</td></tr>
<tr><td><code id="features-class_+3A_digits">digits</code></td>
<td>
<p>Integer indicating the number of decimal places (round) or
significant digits (signif) to be used.</p>
</td></tr>
<tr><td><code id="features-class_+3A_.object">.Object</code></td>
<td>
<p>a <code>features</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A set of <code>features</code> objects can be combined into a <code>features_bundle</code>.
Typically, a <code>features_bundle</code> will result from applying the <code>features</code>-method
on a <code>partition_bundle</code>. See the documentation for <code>bundle</code> to learn about
the methods for <code>bundle</code> objects that are available for a <code>features_bundle</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>corpus</code></dt><dd><p>The CWB corpus the features are derived from, a <code>character</code> vector of length 1.</p>
</dd>
<dt><code>p_attribute</code></dt><dd><p>Object of class <code>character</code>.</p>
</dd>
<dt><code>encoding</code></dt><dd><p>Object of class <code>character</code>.</p>
</dd>
<dt><code>corpus</code></dt><dd><p>Object of class <code>character</code>.</p>
</dd>
<dt><code>stat</code></dt><dd><p>Object of class <code>data.frame</code>.</p>
</dd>
<dt><code>size_coi</code></dt><dd><p>Object of class <code>integer</code>.</p>
</dd>
<dt><code>size_ref</code></dt><dd><p>Object of class <code>integer</code>.</p>
</dd>
<dt><code>included</code></dt><dd><p>Object of class <code>logical</code> whether corpus of interest is included in reference corpus</p>
</dd>
<dt><code>method</code></dt><dd><p>Object of class <code>character</code> statisticalTest used</p>
</dd>
<dt><code>call</code></dt><dd><p>Object of class <code>character</code> the call that generated the object</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Andreas Blaette
</p>

<hr>
<h2 id='get_template'>Get template for formatting full text output.</h2><span id='topic+get_template'></span><span id='topic+get_template+2Ccharacter-method'></span><span id='topic+get_template+2Ccorpus-method'></span><span id='topic+get_template+2Csubcorpus-method'></span>

<h3>Description</h3>

<p>Templates are used to format the markdown/html of fulltext. <code>get_template()</code>
loads and parses the content of the JSON template file, if it is found in the
slot &quot;template&quot; of <code>.Object</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_template(.Object, ...)

## S4 method for signature 'character'
get_template(.Object, warn = FALSE)

## S4 method for signature 'corpus'
get_template(.Object, warn = FALSE)

## S4 method for signature 'subcorpus'
get_template(.Object, warn = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_template_+3A_.object">.Object</code></td>
<td>
<p>A <code>corpus</code>, <code>subcorpus</code> or <code>partition</code> object,
or a length-one <code>character</code> vector with a corpus ID.</p>
</td></tr>
<tr><td><code id="get_template_+3A_...">...</code></td>
<td>
<p>Further arguments.</p>
</td></tr>
<tr><td><code id="get_template_+3A_warn">warn</code></td>
<td>
<p>A <code>logical</code> value, whether to issue a warning if template
is not available. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To learn how to write templates, consult the sample files in the folder
&quot;templates&quot; of the installed package - see examples.
</p>


<h3>Value</h3>

<p>If a template is available, a <code>list</code> with the parsed content of the
template file, otherwise <code>NULL</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>use("polmineR")
corpus("GERMAPARLMINI") %&gt;%
  get_template()

# template files included in the package   
template_dir &lt;- system.file(package = "polmineR", "templates")
list.files(template_dir)
</code></pre>

<hr>
<h2 id='get_token_stream'>Get Token Stream.</h2><span id='topic+get_token_stream'></span><span id='topic+get_token_stream+2Cnumeric-method'></span><span id='topic+get_token_stream+2Cmatrix-method'></span><span id='topic+get_token_stream+2Ccorpus-method'></span><span id='topic+get_token_stream+2Ccharacter-method'></span><span id='topic+get_token_stream+2Cslice-method'></span><span id='topic+get_token_stream+2Cpartition-method'></span><span id='topic+get_token_stream+2Csubcorpus-method'></span><span id='topic+get_token_stream+2Cregions-method'></span><span id='topic+get_token_stream+2Cpartition_bundle-method'></span>

<h3>Description</h3>

<p>Auxiliary method to get the fulltext of a corpus, subcorpora etc. Can be used
to export corpus data to other tools.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_token_stream(.Object, ...)

## S4 method for signature 'numeric'
get_token_stream(
  .Object,
  corpus,
  registry = NULL,
  p_attribute,
  subset = NULL,
  boost = NULL,
  encoding = NULL,
  collapse = NULL,
  beautify = TRUE,
  cpos = FALSE,
  cutoff = NULL,
  decode = TRUE,
  ...
)

## S4 method for signature 'matrix'
get_token_stream(.Object, corpus, registry = NULL, split = FALSE, ...)

## S4 method for signature 'corpus'
get_token_stream(.Object, left = NULL, right = NULL, ...)

## S4 method for signature 'character'
get_token_stream(.Object, left = NULL, right = NULL, ...)

## S4 method for signature 'slice'
get_token_stream(.Object, p_attribute, collapse = NULL, cpos = FALSE, ...)

## S4 method for signature 'partition'
get_token_stream(.Object, p_attribute, collapse = NULL, cpos = FALSE, ...)

## S4 method for signature 'subcorpus'
get_token_stream(.Object, p_attribute, collapse = NULL, cpos = FALSE, ...)

## S4 method for signature 'regions'
get_token_stream(
  .Object,
  p_attribute = "word",
  collapse = NULL,
  cpos = FALSE,
  split = FALSE,
  ...
)

## S4 method for signature 'partition_bundle'
get_token_stream(
  .Object,
  p_attribute = "word",
  vocab = NULL,
  phrases = NULL,
  subset = NULL,
  min_length = NULL,
  collapse = NULL,
  cpos = FALSE,
  decode = TRUE,
  beautify = FALSE,
  verbose = TRUE,
  progress = FALSE,
  mc = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_token_stream_+3A_.object">.Object</code></td>
<td>
<p>Input object.</p>
</td></tr>
<tr><td><code id="get_token_stream_+3A_...">...</code></td>
<td>
<p>Arguments that will be be passed into the
<code>get_token_stream</code>-method for a <code>numeric</code> vector, the real worker.</p>
</td></tr>
<tr><td><code id="get_token_stream_+3A_corpus">corpus</code></td>
<td>
<p>A CWB indexed corpus.</p>
</td></tr>
<tr><td><code id="get_token_stream_+3A_registry">registry</code></td>
<td>
<p>Registry directory with registry file describing the corpus.</p>
</td></tr>
<tr><td><code id="get_token_stream_+3A_p_attribute">p_attribute</code></td>
<td>
<p>A <code>character</code> vector, the p-attribute(s) to decode.</p>
</td></tr>
<tr><td><code id="get_token_stream_+3A_subset">subset</code></td>
<td>
<p>An expression applied on p-attributes, using non-standard
evaluation. Note that symbols used in the expression may not be used
internally (e.g. 'stopwords').</p>
</td></tr>
<tr><td><code id="get_token_stream_+3A_boost">boost</code></td>
<td>
<p>A length-one <code>logical</code> value, whether to speed up decoding
a long vector of token ids by directly by reading in the lexion file from
the data directory of a corpus. If <code>NULL</code> (default), the internal
decision rule is that <code>boost</code> will be <code>TRUE</code> if the corpus is
larger than 10 000 000 million tokens and more than 5 percent of the corpus
are to be decoded.</p>
</td></tr>
<tr><td><code id="get_token_stream_+3A_encoding">encoding</code></td>
<td>
<p>If not <code>NULL</code> (default) a length-one <code>character</code> vector
stating an encoding that will be assigned to the (decoded) token stream.</p>
</td></tr>
<tr><td><code id="get_token_stream_+3A_collapse">collapse</code></td>
<td>
<p>If not <code>NULL</code> (default), a length-one <code>character</code> string
passed into <code>paste</code> to collapse character vector into a single string.</p>
</td></tr>
<tr><td><code id="get_token_stream_+3A_beautify">beautify</code></td>
<td>
<p>A (length-one) <code>logical</code> value, whether to adjust whitespace
before and after interpunctation.</p>
</td></tr>
<tr><td><code id="get_token_stream_+3A_cpos">cpos</code></td>
<td>
<p>A <code>logical</code> value, whether to return corpus positions as names of
the tokens.</p>
</td></tr>
<tr><td><code id="get_token_stream_+3A_cutoff">cutoff</code></td>
<td>
<p>Maximum number of tokens to be reconstructed.</p>
</td></tr>
<tr><td><code id="get_token_stream_+3A_decode">decode</code></td>
<td>
<p>A (length-one) <code>logical</code> value, whether to decode token ids to
character strings. Defaults to <code>TRUE</code>, if <code>FALSE</code>, an integer vector with
token ids is returned.</p>
</td></tr>
<tr><td><code id="get_token_stream_+3A_split">split</code></td>
<td>
<p>A <code>logical</code> value, whether to return a <code>character</code> vector (when
<code>split</code> is <code>FALSE</code>, default) or a <code>list</code> of <code>character</code> vectors; each of
these vectors will then represent the tokens of a region defined by a row
in a regions matrix.</p>
</td></tr>
<tr><td><code id="get_token_stream_+3A_left">left</code></td>
<td>
<p>Left corpus position.</p>
</td></tr>
<tr><td><code id="get_token_stream_+3A_right">right</code></td>
<td>
<p>Right corpus position.</p>
</td></tr>
<tr><td><code id="get_token_stream_+3A_vocab">vocab</code></td>
<td>
<p>A <code>character</code> vector with an alternative vocabulary to the one
stored on disk.</p>
</td></tr>
<tr><td><code id="get_token_stream_+3A_phrases">phrases</code></td>
<td>
<p>A <code>phrases</code> object. Defined phrases will be concatenated.</p>
</td></tr>
<tr><td><code id="get_token_stream_+3A_min_length">min_length</code></td>
<td>
<p>If not <code>NULL</code> (default), an <code>integer</code> value with minimum
length of documents required to keep them in the <code>list</code> object that is
returned.</p>
</td></tr>
<tr><td><code id="get_token_stream_+3A_verbose">verbose</code></td>
<td>
<p>A length-one <code>logical</code> value, whether to show messages.</p>
</td></tr>
<tr><td><code id="get_token_stream_+3A_progress">progress</code></td>
<td>
<p>A length-one <code>logical</code> value, whether to show progress bar.</p>
</td></tr>
<tr><td><code id="get_token_stream_+3A_mc">mc</code></td>
<td>
<p>Number of cores to use. If <code>FALSE</code> (default), only one thread will
be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>CWB indexed corpora have a fixed order of tokens which is called the
<em>token stream</em>. Every token is assigned to a unique <em>corpus
position</em>, Subsets of the (entire) token stream defined by a left and a
right corpus position are called <em>regions</em>. The
<code>get_token_stream</code>-method will extract the tokens (for regions) from a
corpus.
</p>
<p>The primary usage of this method is to return the token stream of a
(sub-)corpus as defined by a <code>corpus</code>, <code>subcorpus</code> or <code>partition</code> object.
The methods defined for a <code>numeric</code> vector or a (two-column) <code>matrix</code>
defining regions (i.e. left and right corpus positions in the first and
second column) are the actual workers for this operation.
</p>
<p>The <code>get_token_stream</code> has been introduced so serve as a worker by
higher level methods such as <code>read</code>, <code>html</code>, and <code>as.markdown</code>. It may
however be useful for decoding a corpus so that it can be exported to other
tools.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>use(pkg = "RcppCWB", corpus = "REUTERS")

# Decode first words of REUTERS corpus (first sentence)
get_token_stream(0:20, corpus = "REUTERS", p_attribute = "word")

# Decode first sentence and collapse tokens into single string
get_token_stream(0:20, corpus = "REUTERS", p_attribute = "word", collapse = " ")

# Decode regions defined by two-column integer matrix
region_matrix &lt;- matrix(c(0L,20L,21L,38L), ncol = 2, byrow = TRUE)
get_token_stream(
  region_matrix,
  corpus = "REUTERS",
  p_attribute = "word",
  encoding = "latin1"
)

# Use argument 'beautify' to remove surplus whitespace
## Not run: 
get_token_stream(
  region_matrix,
  corpus = "GERMAPARLMINI",
  p_attribute = "word",
  encoding = "latin1",
  collapse = " ", beautify = TRUE
)

## End(Not run)

# Decode entire corpus (corpus object / specified by corpus ID)
corpus("REUTERS") %&gt;%
  get_token_stream(p_attribute = "word") %&gt;%
  head()

# Decode subcorpus
corpus("REUTERS") %&gt;%
  subset(id == "127") %&gt;%
  get_token_stream(p_attribute = "word") %&gt;%
  head()

# Decode partition_bundle
## Not run: 
pb_tokstr &lt;- corpus("REUTERS") %&gt;%
  split(s_attribute = "id") %&gt;%
  get_token_stream(p_attribute = "word")

## End(Not run)
## Not run: 
# Get token stream for partition_bundle
pb &lt;- partition_bundle("REUTERS", s_attribute = "id")
ts_list &lt;- get_token_stream(pb)

# Use two p-attributes
sp &lt;- corpus("GERMAPARLMINI") %&gt;%
  as.speeches(s_attribute_name = "speaker", s_attribute_date = "date", progress = FALSE)
p2 &lt;- get_token_stream(sp, p_attribute = c("word", "pos"), verbose = FALSE)

# Apply filter
p_sub &lt;- get_token_stream(
  sp, p_attribute = c("word", "pos"),
  subset = {!grepl("(\\$.$|ART)", pos)}
)

# Concatenate phrases and apply filter
queries &lt;- c('"freiheitliche" "Grundordnung"', '"Bundesrepublik" "Deutschland"' )
phr &lt;- corpus("GERMAPARLMINI") %&gt;%
  cpos(query = queries) %&gt;%
  as.phrases(corpus = "GERMAPARLMINI")

kill &lt;- tm::stopwords("de")

ts_phr &lt;- get_token_stream(
  sp,
  p_attribute = c("word", "pos"),
  subset = {!word %in% kill  &amp; !grepl("(\\$.$|ART)", pos)},
  phrases = phr,
  progress = FALSE,
  verbose = FALSE
)

## End(Not run)
</code></pre>

<hr>
<h2 id='get_type'>Get corpus/partition type.</h2><span id='topic+get_type'></span><span id='topic+get_type+2Csubcorpus-method'></span><span id='topic+get_type+2Ccorpus-method'></span><span id='topic+get_type+2Ccharacter-method'></span><span id='topic+get_type+2Cpartition_bundle-method'></span><span id='topic+get_type+2Csubcorpus_bundle-method'></span>

<h3>Description</h3>

<p>To generate fulltext output, different templates can be used with a behavior
that depends on the type of a corpus. <code>get_type</code> will return the type of
corpus if it is a specialized one, or <code>NULL</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_type(.Object)

## S4 method for signature 'corpus'
get_type(.Object)

## S4 method for signature 'character'
get_type(.Object)

## S4 method for signature 'partition_bundle'
get_type(.Object)

## S4 method for signature 'subcorpus_bundle'
get_type(.Object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_type_+3A_.object">.Object</code></td>
<td>
<p>A <code>partition</code>, <code>partition_bundle</code>, <code>Corpus</code> object, or a
length-one character vector indicating a CWB corpus.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When generating a <code>partition</code>, the corpus type will be prefixed to the class
that is generated (separated by underscore). If the corpus type is not
<code>NULL</code>, a class inheriting from the <code>partition</code>-class is instantiated. Note
that at this time, only <code>plpr_partition</code> and <code>press_partition</code> is
implemented.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>use("polmineR")
use(pkg = "RcppCWB", corpus = "REUTERS")

get_type("GERMAPARLMINI")

p &lt;- partition("GERMAPARLMINI", date = "2009-10-28")
get_type(p)
is(p)

pb &lt;- partition_bundle("GERMAPARLMINI", s_attribute = "date")
get_type(pb)

get_type("REUTERS") # returns NULL - no specialized corpus
</code></pre>

<hr>
<h2 id='highlight-method'>Highlight tokens in text output.</h2><span id='topic+highlight-method'></span><span id='topic+highlight'></span><span id='topic+highlight+2Ccharacter-method'></span><span id='topic+highlight+2Chtml-method'></span><span id='topic+highlight+2Ckwic-method'></span>

<h3>Description</h3>

<p>Highlight tokens in fulltext based on exact match, a regular expression or
corpus position in <code>kwic</code> output or <code>html</code> document.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>highlight(.Object, ...)

## S4 method for signature 'character'
highlight(.Object, highlight = list(), regex = FALSE, perl = FALSE, ...)

## S4 method for signature 'html'
highlight(.Object, highlight = list(), regex = FALSE, perl = FALSE, ...)

## S4 method for signature 'kwic'
highlight(
  .Object,
  highlight = list(),
  regex = FALSE,
  perl = TRUE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="highlight-method_+3A_.object">.Object</code></td>
<td>
<p>A <code>html</code>, <code>character</code>, a <code>kwic</code> object.</p>
</td></tr>
<tr><td><code id="highlight-method_+3A_...">...</code></td>
<td>
<p>Terms to be highlighted can be passed in as named <code>character</code>
vectors of terms (or regular expressions); the name needs to be a
valid color name. It is also possible to pass in a <code>matrix</code> with ranges (as
returned by <code>cpos()</code>).</p>
</td></tr>
<tr><td><code id="highlight-method_+3A_highlight">highlight</code></td>
<td>
<p>A character vector, or a list of <code>character</code> or <code>integer</code>
vectors.</p>
</td></tr>
<tr><td><code id="highlight-method_+3A_regex">regex</code></td>
<td>
<p>Logical, whether character vectors are interpreted as regular
expressions.</p>
</td></tr>
<tr><td><code id="highlight-method_+3A_perl">perl</code></td>
<td>
<p>Logical, whether to use perl-style regular expressions for
highlighting when regex is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="highlight-method_+3A_verbose">verbose</code></td>
<td>
<p>Logical, whether to output messages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>highlight</code> is a character vector, the names of the vector are interpreted
as colors. If <code>highlight</code> is a list, the names of the list are considered as
colors. Values can be character values or integer values with token ids.
Colors are inserted into the output html and need to be digestable for the
browser used.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>use("polmineR")
use(pkg = "RcppCWB", corpus = "REUTERS")

P &lt;- partition("REUTERS", places = "argentina")
H &lt;- html(P)
Y &lt;- highlight(H, list(lightgreen = "higher"))
if (interactive()) htmltools::html_print(Y)

# highlight matches for a CQP query
regions &lt;- cpos(P, query = '"prod.*"', cqp = TRUE)
H2 &lt;- highlight(H, highlight = list(yellow = regions))

# the method can be used in pipe
P %&gt;% html() %&gt;% highlight(list(lightgreen = "1986")) -&gt; H
P %&gt;% html() %&gt;% highlight(list(lightgreen = c("1986", "higher"))) -&gt; H
P %&gt;% html() %&gt;% highlight(list(lightgreen = 4020:4023)) -&gt; H

# use highlight for kwic output
K &lt;- kwic("REUTERS", query = "barrel")
K2 &lt;- highlight(K, highlight = list(yellow = c("oil", "price")))

# use character vector for output, not list
K2 &lt;- highlight(
  K,
  highlight = c(
    green = "pric.",
    red = "reduction",
    red = "decrease",
    orange = "dropped"
  ),
  regex = TRUE
)
</code></pre>

<hr>
<h2 id='hits'>Get hits for query</h2><span id='topic+hits'></span><span id='topic+hits+2Ccorpus-method'></span><span id='topic+hits+2Ccharacter-method'></span><span id='topic+hits+2Csubcorpus-method'></span><span id='topic+hits+2Cpartition-method'></span><span id='topic+hits+2Cpartition_bundle-method'></span><span id='topic+hits+2Ccontext-method'></span><span id='topic+hits+2Cremote_corpus-method'></span><span id='topic+hits+2Cremote_subcorpus-method'></span>

<h3>Description</h3>

<p>Get hits for queries, optionally with s-attribute values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hits(.Object, ...)

## S4 method for signature 'corpus'
hits(
  .Object,
  query,
  cqp = FALSE,
  check = TRUE,
  s_attribute,
  p_attribute = "word",
  size = FALSE,
  freq = FALSE,
  decode = TRUE,
  fill = FALSE,
  mc = 1L,
  verbose = TRUE,
  progress = FALSE,
  ...
)

## S4 method for signature 'character'
hits(
  .Object,
  query,
  cqp = FALSE,
  check = TRUE,
  s_attribute,
  p_attribute = "word",
  size = FALSE,
  freq = FALSE,
  decode = TRUE,
  mc = FALSE,
  verbose = TRUE,
  progress = FALSE,
  ...
)

## S4 method for signature 'subcorpus'
hits(
  .Object,
  query,
  cqp = FALSE,
  check = TRUE,
  s_attribute,
  p_attribute = "word",
  size = FALSE,
  freq = FALSE,
  fill = FALSE,
  decode = TRUE,
  mc = FALSE,
  progress = FALSE,
  verbose = TRUE,
  ...
)

## S4 method for signature 'partition'
hits(
  .Object,
  query,
  cqp = FALSE,
  check = TRUE,
  s_attribute,
  p_attribute = "word",
  size = FALSE,
  freq = FALSE,
  fill = FALSE,
  decode = TRUE,
  mc = FALSE,
  progress = FALSE,
  verbose = TRUE
)

## S4 method for signature 'partition_bundle'
hits(
  .Object,
  query,
  cqp = FALSE,
  check = TRUE,
  p_attribute = getOption("polmineR.p_attribute"),
  s_attribute,
  size = TRUE,
  freq = FALSE,
  mc = getOption("polmineR.mc"),
  progress = FALSE,
  verbose = TRUE,
  ...
)

## S4 method for signature 'context'
hits(.Object, s_attribute = NULL, verbose = TRUE, ...)

## S4 method for signature 'remote_corpus'
hits(.Object, ...)

## S4 method for signature 'remote_subcorpus'
hits(.Object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hits_+3A_.object">.Object</code></td>
<td>
<p>A length-one <code>character</code> vector with a corpus ID, a
<code>partition</code> or <code>partition_bundle</code> object</p>
</td></tr>
<tr><td><code id="hits_+3A_...">...</code></td>
<td>
<p>Further arguments (used for backwards compatibility).</p>
</td></tr>
<tr><td><code id="hits_+3A_query">query</code></td>
<td>
<p>A <code>character</code> vector (optionally named, see details) with one or
more queries.</p>
</td></tr>
<tr><td><code id="hits_+3A_cqp">cqp</code></td>
<td>
<p>Either a <code>logical</code> value (<code>TRUE</code> if query is a CQP query), or a
function to check whether <code>query</code> is a CQP query or not.</p>
</td></tr>
<tr><td><code id="hits_+3A_check">check</code></td>
<td>
<p>A <code>logical</code> value, whether to check validity of CQP query using
<code>check_cqp_query</code>.</p>
</td></tr>
<tr><td><code id="hits_+3A_s_attribute">s_attribute</code></td>
<td>
<p>A <code>character</code> vector of s-attributes that will be
used to breakdown counts for matches for query/queries.</p>
</td></tr>
<tr><td><code id="hits_+3A_p_attribute">p_attribute</code></td>
<td>
<p>A <code>character</code> vector stating a p-attribute.</p>
</td></tr>
<tr><td><code id="hits_+3A_size">size</code></td>
<td>
<p>A <code>logical</code> value, whether to report the size of subcorpus.</p>
</td></tr>
<tr><td><code id="hits_+3A_freq">freq</code></td>
<td>
<p>A <code>logcial</code> value, whether to report relative frequencies.</p>
</td></tr>
<tr><td><code id="hits_+3A_decode">decode</code></td>
<td>
<p>A <code>logical</code> value, whether to decode s-attributes. If <code>FALSE</code>,
the <code>integer</code> values of strucs are reported in the table with matches.</p>
</td></tr>
<tr><td><code id="hits_+3A_fill">fill</code></td>
<td>
<p>A <code>logical</code> value, whethet to report counts (optionally
frequencies) for combinations of s-attributes where not matchers occurr.</p>
</td></tr>
<tr><td><code id="hits_+3A_mc">mc</code></td>
<td>
<p>A <code>logical</code> value, whether to use multicore.</p>
</td></tr>
<tr><td><code id="hits_+3A_verbose">verbose</code></td>
<td>
<p>A <code>logical</code> value, whether to output messages.</p>
</td></tr>
<tr><td><code id="hits_+3A_progress">progress</code></td>
<td>
<p>A <code>logical</code> value, whether to show progress bar.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the <code>character</code> vector provided by <code>query</code> is named, these names will be
reported in the <code>data.table</code> that is returned rather than the queries.
</p>
<p>If <code>freq</code> is <code>TRUE</code>, the <code>data.table</code> returned in the DT-slot will
deliberately include the subsets of the <code>partition</code>/<code>corpus</code> with no hits
(query is NA, count is 0).
</p>


<h3>Value</h3>

<p>A <code>hits</code> class object.
</p>


<h3>See Also</h3>

<p>See the documentation of the <code>hits</code> class
(<code><a href="#topic+hits-class">hits-class</a></code>) for details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>use(pkg = "RcppCWB", corpus = "REUTERS")

# get hits for corpus object
y &lt;- corpus("REUTERS") %&gt;% hits(query = "oil")
y &lt;- corpus("REUTERS") %&gt;% hits(query = c("oil", "barrel"))
y &lt;- corpus("REUTERS") %&gt;% hits(query = "oil", s_attribute = "places", freq = TRUE)

# specify corpus by corpus ID
y &lt;- hits("REUTERS", query = "oil")
y &lt;- hits("REUTERS", query = "oil", s_attribute = "places", freq = TRUE)

# get hits for partition
p &lt;- partition("REUTERS", places = "saudi-arabia", regex = TRUE)
y &lt;- hits(p, query = "oil", s_attribute = "id")

# get hits for subcorpus
y &lt;- corpus("REUTERS") %&gt;%
  subset(grep("saudi-arabia", places)) %&gt;%
  hits(query = "oil")
</code></pre>

<hr>
<h2 id='hits_class'>S4 class to represent hits for queries.</h2><span id='topic+hits_class'></span><span id='topic+hits-class'></span><span id='topic+sample+2Chits-method'></span>

<h3>Description</h3>

<p>S4 class to represent hits for queries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'hits'
sample(x, size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hits_class_+3A_x">x</code></td>
<td>
<p>A <code>hits</code> object.</p>
</td></tr>
<tr><td><code id="hits_class_+3A_size">size</code></td>
<td>
<p>A non-negative integer giving the number of items to choose.</p>
</td></tr>
</table>


<h3>Slots</h3>


<dl>
<dt><code>stat</code></dt><dd><p>A <code>data.table</code> with the following columns:
</p>

<dl>
<dt>query</dt><dd><p>The query (optionally using CQP syntax) that evoked
a hit.</p>
</dd>
<dt>count</dt><dd><p>Number of matches in corpus/subcorpus.</p>
</dd>
<dt>freq</dt><dd><p>Relative frequency of matches in corpus/subcorpus (optional,
presence depends on usage of argument <code>freq</code> of the <code>hits</code> method).</p>
</dd>
<dt>size</dt><dd><p>Total number of tokens in corpus/subcorpus (optional, presence
depends on usage of argument <code>size</code> of the <code>hits</code> method).</p>
</dd>
</dl>

<p>If argument <code>s_attribute</code> has been used in the call of the <code>hits</code>
method, the <code>data.table</code> will include additional columns with the
s-attributes. The values in the columns will be the values these s-attributes
assume. Columns <code>count</code>, <code>freq</code> and <code>size</code> will be based on
subcorpora defined by (combinations of) s-attributes.</p>
</dd>
<dt><code>corpus</code></dt><dd><p>A length-one <code>"character"</code> vector, ID of the corpus with
hits for query or queries.</p>
</dd>
<dt><code>query</code></dt><dd><p>Object of class <code>"character"</code>, query or queries for</p>
</dd>
<dt><code>p_attribute</code></dt><dd><p>The p-attribute that has been queried, a length-one
<code>character</code> vector.</p>
</dd>
<dt><code>encoding</code></dt><dd><p>Length-one <code>character</code> vector, the encoding of the
corpus.</p>
</dd>
<dt><code>name</code></dt><dd><p>Length-one <code>characte</code> vector, name of the object.</p>
</dd>
</dl>

<hr>
<h2 id='href-function'>Add hypertext reference to html document.</h2><span id='topic+href-function'></span><span id='topic+href'></span>

<h3>Description</h3>

<p>Add hypertext reference to html document.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>href(x, href, fmt, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="href-function_+3A_x">x</code></td>
<td>
<p>Object of class 'html'.</p>
</td></tr>
<tr><td><code id="href-function_+3A_href">href</code></td>
<td>
<p>A named <code>list</code> with hypertext references that will be inserted as
attribute href of a elements. The names of the list are either colors of
highlighted text that has been generated previously, or corpus positions.</p>
</td></tr>
<tr><td><code id="href-function_+3A_fmt">fmt</code></td>
<td>
<p>A format string with an xpath expression used to look up the node
where the tooltip is inserted. If missing, a heuristic evaluating the names
of the <code>tooltips</code> list decides whether tooltips are inserted based on
highlighting colors or corpus positions.</p>
</td></tr>
<tr><td><code id="href-function_+3A_verbose">verbose</code></td>
<td>
<p>A <code>logical</code> value, whether to show messages.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>use(pkg = "RcppCWB", corpus = "REUTERS")

a &lt;- corpus("REUTERS") %&gt;%
  subset(places = "argentina") %&gt;%
  html() %&gt;%
  highlight(lightgreen = 3997) %&gt;%
  href(href = list("3997" = "https://en.wikipedia.org/wiki/Argentina"))
  
if (interactive()) show(a)
</code></pre>

<hr>
<h2 id='html'>Generate html from object.</h2><span id='topic+html'></span><span id='topic+show+2Chtml-method'></span><span id='topic+html+2Ccharacter-method'></span><span id='topic+html+2Cpartition-method'></span><span id='topic+html+2Csubcorpus-method'></span><span id='topic+html+2Cpartition_bundle-method'></span><span id='topic+html+2Ckwic-method'></span><span id='topic+html+2Cremote_subcorpus-method'></span>

<h3>Description</h3>

<p>Prepare html document to see full text.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>html(object, ...)

## S4 method for signature 'character'
html(object, corpus, height = NULL)

## S4 method for signature 'partition'
html(
  object,
  meta = NULL,
  cpos = TRUE,
  verbose = FALSE,
  cutoff = NULL,
  charoffset = FALSE,
  beautify = TRUE,
  height = NULL,
  ...
)

## S4 method for signature 'subcorpus'
html(
  object,
  meta = NULL,
  cpos = TRUE,
  verbose = FALSE,
  cutoff = NULL,
  charoffset = FALSE,
  beautify = FALSE,
  height = NULL,
  ...
)

## S4 method for signature 'partition_bundle'
html(
  object,
  charoffset = FALSE,
  beautify = TRUE,
  height = NULL,
  progress = TRUE,
  ...
)

## S4 method for signature 'kwic'
html(object, i, s_attribute = NULL, type = NULL, verbose = FALSE)

## S4 method for signature 'remote_subcorpus'
html(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="html_+3A_object">object</code></td>
<td>
<p>The object the fulltext output will be based on.</p>
</td></tr>
<tr><td><code id="html_+3A_...">...</code></td>
<td>
<p>Further parameters that are passed into <code>as.markdown()</code>.</p>
</td></tr>
<tr><td><code id="html_+3A_corpus">corpus</code></td>
<td>
<p>The ID of the corpus, a length-one <code>character</code> vector.</p>
</td></tr>
<tr><td><code id="html_+3A_height">height</code></td>
<td>
<p>A <code>character</code> vector that will be inserted into the html as an
optional height of a scroll box.</p>
</td></tr>
<tr><td><code id="html_+3A_meta">meta</code></td>
<td>
<p>Metadata to include in  output, if <code>NULL</code> (default), the
s-attributes defining a partition will be used.</p>
</td></tr>
<tr><td><code id="html_+3A_cpos">cpos</code></td>
<td>
<p>Length-one <code>logical</code> value, if <code>TRUE</code> (default), all
tokens will be wrapped by elements with id attribute indicating corpus
positions.</p>
</td></tr>
<tr><td><code id="html_+3A_verbose">verbose</code></td>
<td>
<p>Length-one <code>logical</code> value, whether to output progress
messages.</p>
</td></tr>
<tr><td><code id="html_+3A_cutoff">cutoff</code></td>
<td>
<p>An <code>integer</code> value, maximum number of tokens to decode
from token stream, passed into <code>as.markdown()</code>.</p>
</td></tr>
<tr><td><code id="html_+3A_charoffset">charoffset</code></td>
<td>
<p>Length-one <code>logical</code> value, if <code>TRUE</code>, character offset
positions are added to elements embracing tokens.</p>
</td></tr>
<tr><td><code id="html_+3A_beautify">beautify</code></td>
<td>
<p>A <code>logical</code> value, if <code>TRUE</code>, whitespace before
interpunctuation will be removed.</p>
</td></tr>
<tr><td><code id="html_+3A_progress">progress</code></td>
<td>
<p>Length-one <code>logical</code> value, whether to output progress bar.</p>
</td></tr>
<tr><td><code id="html_+3A_i">i</code></td>
<td>
<p>An <code>integer</code> value: If <code>object</code> is a <code>kwic</code>-object,
the index of the concordance for which the fulltext is to be generated.</p>
</td></tr>
<tr><td><code id="html_+3A_s_attribute">s_attribute</code></td>
<td>
<p>Structural attributes that will be used to define the
partition where the match occurred.</p>
</td></tr>
<tr><td><code id="html_+3A_type">type</code></td>
<td>
<p>The partition type.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Substitutions configured by option 'polmineR.mdsub' are applied to
prevent presence of characters that would be misinterpreted as markdown
formatting instructions.
</p>
<p>If param <code style="white-space: pre;">&#8288;charoffset} is &#8288;</code>TRUE&ldquo;, character offset positions will be
added to tags that embrace tokens. This may be useful, if exported html
document is annotated with a tool that stores annotations with character
offset positions.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>html</code> as used in the 'htmltools' package.
Methods such as <code>htmltools::html_print()</code> will be available. The encoding
of the html document will be UTF-8 on all systems (including Windows).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>use(pkg = "RcppCWB", corpus = "REUTERS")

P &lt;- partition("REUTERS", places = "argentina")
H &lt;- html(P)
if (interactive()) H # show full text in viewer pane

# html-method can be used in a pipe
H &lt;- partition("REUTERS", places = "argentina") %&gt;% html()
  
# use html-method to get full text where concordance occurrs
K &lt;- kwic("REUTERS", query = "barrels")
H &lt;- html(K, i = 1, s_attribute = "id")
H &lt;- html(K, i = 2, s_attribute = "id")
for (i in 1L:length(K)) {
  H &lt;- html(K, i = i, s_attribute = "id")
  if (interactive()){
    show(H)
    userinput &lt;- readline("press 'q' to quit or any other key to continue")
    if (userinput == "q") break
  }
}
  
</code></pre>

<hr>
<h2 id='is_nested'>Check whether s-attributes of corpus are nested</h2><span id='topic+is_nested'></span>

<h3>Description</h3>

<p>Simple test whether the attribute size of all s-attributes of a corpus is
identical (flat import XML) or not (nested import XML).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_nested(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_nested_+3A_x">x</code></td>
<td>
<p>A <code>character</code> vector with corpus ID or a <code>corpus</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>logical</code> value: <code>FALSE</code> is data structure is flat and <code>TRUE</code> if
data structure is nested.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>use("polmineR")
use("RcppCWB")
</code></pre>

<hr>
<h2 id='kwic'>Perform keyword-in-context (KWIC) analysis.</h2><span id='topic+kwic'></span><span id='topic+kwic+2Ccontext-method'></span><span id='topic+kwic+2Cslice-method'></span><span id='topic+kwic+2Cpartition-method'></span><span id='topic+kwic+2Csubcorpus-method'></span><span id='topic+kwic+2Ccorpus-method'></span><span id='topic+kwic+2Ccharacter-method'></span><span id='topic+kwic+2Cremote_corpus-method'></span><span id='topic+kwic+2Cremote_partition-method'></span><span id='topic+kwic+2Cremote_subcorpus-method'></span><span id='topic+kwic+2Cpartition_bundle-method'></span><span id='topic+kwic+2Csubcorpus_bundle-method'></span>

<h3>Description</h3>

<p>Get concordances for the matches for a query / perform keyword-in-context
(kwic) analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kwic(.Object, ...)

## S4 method for signature 'context'
kwic(
  .Object,
  s_attributes = getOption("polmineR.meta"),
  cpos = TRUE,
  verbose = FALSE
)

## S4 method for signature 'slice'
kwic(
  .Object,
  query,
  cqp = is.cqp,
  left = getOption("polmineR.left"),
  right = getOption("polmineR.right"),
  s_attributes = getOption("polmineR.meta"),
  region = NULL,
  p_attribute = "word",
  boundary = NULL,
  cpos = TRUE,
  stoplist = NULL,
  positivelist = NULL,
  regex = FALSE,
  verbose = TRUE,
  ...
)

## S4 method for signature 'partition'
kwic(
  .Object,
  query,
  cqp = is.cqp,
  left = getOption("polmineR.left"),
  right = getOption("polmineR.right"),
  s_attributes = getOption("polmineR.meta"),
  p_attribute = "word",
  region = NULL,
  boundary = NULL,
  cpos = TRUE,
  stoplist = NULL,
  positivelist = NULL,
  regex = FALSE,
  verbose = TRUE,
  ...
)

## S4 method for signature 'subcorpus'
kwic(
  .Object,
  query,
  cqp = is.cqp,
  left = getOption("polmineR.left"),
  right = getOption("polmineR.right"),
  s_attributes = getOption("polmineR.meta"),
  p_attribute = "word",
  region = NULL,
  boundary = NULL,
  cpos = TRUE,
  stoplist = NULL,
  positivelist = NULL,
  regex = FALSE,
  verbose = TRUE,
  ...
)

## S4 method for signature 'corpus'
kwic(
  .Object,
  query,
  cqp = is.cqp,
  check = TRUE,
  left = as.integer(getOption("polmineR.left")),
  right = as.integer(getOption("polmineR.right")),
  s_attributes = getOption("polmineR.meta"),
  p_attribute = "word",
  region = NULL,
  boundary = NULL,
  cpos = TRUE,
  stoplist = NULL,
  positivelist = NULL,
  regex = FALSE,
  verbose = TRUE,
  ...
)

## S4 method for signature 'character'
kwic(
  .Object,
  query,
  cqp = is.cqp,
  check = TRUE,
  left = as.integer(getOption("polmineR.left")),
  right = as.integer(getOption("polmineR.right")),
  s_attributes = getOption("polmineR.meta"),
  p_attribute = "word",
  region = NULL,
  boundary = NULL,
  cpos = TRUE,
  stoplist = NULL,
  positivelist = NULL,
  regex = FALSE,
  verbose = TRUE,
  ...
)

## S4 method for signature 'remote_corpus'
kwic(.Object, ...)

## S4 method for signature 'remote_partition'
kwic(.Object, ...)

## S4 method for signature 'remote_subcorpus'
kwic(.Object, ...)

## S4 method for signature 'partition_bundle'
kwic(.Object, ..., verbose = FALSE)

## S4 method for signature 'subcorpus_bundle'
kwic(.Object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kwic_+3A_.object">.Object</code></td>
<td>
<p>A (length-one) <code>character</code> vector with the name of a CWB
corpus, a <code>partition</code> or <code>context</code> object.</p>
</td></tr>
<tr><td><code id="kwic_+3A_...">...</code></td>
<td>
<p>Further arguments, used to ensure backwards compatibility. If
<code>.Object</code> is a <code>remote_corpus</code> of <code>remote_partition</code> object,
the three dots (<code>...</code>) are used to pass arguments. Hence, it is
necessary to state the names of all arguments to be passed explicity.</p>
</td></tr>
<tr><td><code id="kwic_+3A_s_attributes">s_attributes</code></td>
<td>
<p>Structural attributes (s-attributes) to include into
output table as metainformation.</p>
</td></tr>
<tr><td><code id="kwic_+3A_cpos">cpos</code></td>
<td>
<p>Logical, if <code>TRUE</code>, a <code>data.table</code> with the corpus
positions (&quot;cpos&quot;) of the hits and their surrounding context will be
assigned to the slot &quot;cpos&quot; of the <code>kwic</code>-object that is returned.
Defaults to <code>TRUE</code>, as the availability of the cpos-<code>data.table</code>
will often be a prerequisite for further operations on the <code>kwic</code>
object. Omitting the table may however be useful to minimize memory
consumption.</p>
</td></tr>
<tr><td><code id="kwic_+3A_verbose">verbose</code></td>
<td>
<p>A <code>logical</code> value, whether to print messages.</p>
</td></tr>
<tr><td><code id="kwic_+3A_query">query</code></td>
<td>
<p>A query, CQP-syntax can be used.</p>
</td></tr>
<tr><td><code id="kwic_+3A_cqp">cqp</code></td>
<td>
<p>Either a logical value (<code>TRUE</code> if <code>query</code> is a CQP
query), or a function to check whether query is a CQP query or not
(defaults to auxiliary function <code>is.query</code>).</p>
</td></tr>
<tr><td><code id="kwic_+3A_left">left</code></td>
<td>
<p>A single <code>integer</code> value defining the number of tokens to the
left of the query match to include in the context. Advanced usage: (a) If
<code>left</code> is a length-one <code>character</code> vector stating an s-attribute, the
context will be expanded to the (left) boundary of the region where the
match occurs. (b) If <code>left</code> is a named length-one <code>integer</code> vector, this
value is the number regions of the structural attribute referred to by the
vector's name  to the left of the query match that are included in the
context.</p>
</td></tr>
<tr><td><code id="kwic_+3A_right">right</code></td>
<td>
<p>A single <code>integer</code> value, a length-one <code>character</code> vector or a
named length-one <code>integer</code> value, with equivalent effects to argument
<code>left</code>.</p>
</td></tr>
<tr><td><code id="kwic_+3A_region">region</code></td>
<td>
<p>An s-attribute, given by a length-one <code>character</code> vector.
The context of query matches will be expanded to the left and right
boundary of the region where the match is located. If arguments <code>left</code> and
<code>right</code> are &gt; 1, the left and right boundaries of the respective number of
regions will be identified.</p>
</td></tr>
<tr><td><code id="kwic_+3A_p_attribute">p_attribute</code></td>
<td>
<p>The p-attribute, defaults to 'word'.</p>
</td></tr>
<tr><td><code id="kwic_+3A_boundary">boundary</code></td>
<td>
<p>If provided, a length-one character vector stating an
s-attribute that will be used to check the boundaries of the text.</p>
</td></tr>
<tr><td><code id="kwic_+3A_stoplist">stoplist</code></td>
<td>
<p>Terms or ids to prevent a concordance from occurring in
results.</p>
</td></tr>
<tr><td><code id="kwic_+3A_positivelist">positivelist</code></td>
<td>
<p>Terms or ids required for a concordance to occurr in
results</p>
</td></tr>
<tr><td><code id="kwic_+3A_regex">regex</code></td>
<td>
<p>Logical, whether <code>stoplist</code>/<code>positivelist</code> is
interpreted as regular expression.</p>
</td></tr>
<tr><td><code id="kwic_+3A_check">check</code></td>
<td>
<p>A <code>logical</code> value, whether to check validity of CQP query
using <code>check_cqp_query</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method works with a whole CWB corpus defined by a  character vector, and
can be applied on a <code>partition</code>- or a <code>context</code> object.
</p>
<p>If <code>query</code> produces a lot of matches, the <code>DT::datatable()</code> function used to
produce output in the Viewer pane of RStudio may issue a warning. Usually,
this warning is harmless and can be ignored. Use
<code>options("polmineR.warn.size" = FALSE)</code> for turning off this warning.
</p>
<p>If a <code>positivelist</code> is supplied, only those concordances will be kept that
have one of the terms from the <code>positivelist</code> occurr in the context of
the query match. Use argument <code>regex</code> if the positivelist should be
interpreted as regular expressions. Tokens from the positivelist will be
highlighted in the output table.
</p>
<p>If a <code>negativelist</code> is supplied, concordances are removed if any of the
tokens of the <code>negativelist</code> occurrs in the context of the query match.
</p>
<p>Applying the <code>kwic</code>-method on a <code>partition_bundle</code> or
<code>subcorpus_bundle</code> will return a single <code>kwic</code> object that
includes a column 'subcorpus_name' with the name of the <code>subcorpus</code>
(or <code>partition</code>) in the input object where the match for a concordance
occurs.
</p>


<h3>Value</h3>

<p>If there are no matches, or if all (initial) matches are dropped due to the
application of a positivelist, a <code>NULL</code> is returned.
</p>


<h3>References</h3>

<p>Baker, Paul (2006): <em>Using Corpora in Discourse Analysis</em>. London: continuum, pp. 71-93 (ch. 4).
</p>
<p>Jockers, Matthew L. (2014): <em>Text Analysis with R for Students of Literature</em>.
Cham et al: Springer, pp. 73-87 (chs. 8 &amp; 9).
</p>


<h3>See Also</h3>

<p>The return value is a <code><a href="#topic+kwic-class">kwic-class</a></code> object; the
documentation for the class explains the standard generic methods
applicable to <code><a href="#topic+kwic-class">kwic-class</a></code> objects. It is possible to read the
whole text where a query match occurs, see the <code><a href="#topic+read">read</a></code>-method.
To highlight terms in the context of a query match, see the
<code><a href="#topic+highlight">highlight</a></code>-method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>use("polmineR")
use(pkg = "RcppCWB", corpus = "REUTERS")

# basic usage
K &lt;- kwic("GERMAPARLMINI", "Integration")
if (interactive()) show(K)
oil &lt;- corpus("REUTERS") %&gt;% kwic(query = "oil")
if (interactive()) show(oil)
oil &lt;- corpus("REUTERS") %&gt;%
  kwic(query = "oil") %&gt;%
  highlight(yellow = "crude")
if (interactive()) show(oil)

# increase left and right context and display metadata
K &lt;- kwic(
  "GERMAPARLMINI",
  "Integration", left = 20, right = 20,
  s_attributes = c("date", "speaker", "party")
)
if (interactive()) show(K)

# use CQP syntax for matching
K &lt;- kwic(
  "GERMAPARLMINI",
  '"Integration" [] "(Menschen|Migrant.*|Personen)"', cqp = TRUE,
  left = 20, right = 20,
  s_attributes = c("date", "speaker", "party")
)
if (interactive()) show(K)

# check that boundary of region is not transgressed
K &lt;- kwic(
  "GERMAPARLMINI",
  '"Sehr" "geehrte"', cqp = TRUE,
  left = 100, right = 100,
  boundary = "date"
)
if (interactive()) show(K)

# use positivelist and highlight matches in context
K &lt;- kwic("GERMAPARLMINI", query = "Integration", positivelist = "[Ee]urop.*", regex = TRUE)
K &lt;- highlight(K, yellow = "[Ee]urop.*", regex = TRUE)

# Apply kwic on partition_bundle/subcorpus_bundle
gparl_2009_11_10_speeches &lt;- corpus("GERMAPARLMINI") %&gt;%
  subset(date == "2009-11-10") %&gt;%
  as.speeches(
    s_attribute_name = "speaker", s_attribute_date = "date",
    progress = FALSE, verbose = FALSE
  )
k &lt;- kwic(gparl_2009_11_10_speeches, query = "Integration")
</code></pre>

<hr>
<h2 id='kwic-class'>S4 kwic class</h2><span id='topic+kwic-class'></span><span id='topic++5B+2Ckwic+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+2Ckwic-method'></span><span id='topic+get_corpus+2Ckwic-method'></span><span id='topic+count+2Ckwic-method'></span><span id='topic+as.DocumentTermMatrix+2Ckwic-method'></span><span id='topic+as.TermDocumentMatrix+2Ckwic-method'></span><span id='topic+show+2Ckwic-method'></span><span id='topic+knit_print+2Ckwic-method'></span><span id='topic+as.character+2Ckwic-method'></span><span id='topic+subset+2Ckwic-method'></span><span id='topic+as.data.frame+2Ckwic-method'></span><span id='topic+length+2Ckwic-method'></span><span id='topic+sample+2Ckwic-method'></span><span id='topic+merge+2Ckwic_bundle-method'></span><span id='topic+enrich+2Ckwic-method'></span><span id='topic+format+2Ckwic-method'></span><span id='topic+view+2Ckwic-method'></span>

<h3>Description</h3>

<p>S4 class for organizing information for kwic/concordance output. A set of
standard generics (<code>show</code>, <code>as.character</code>, <code>as.data.frame</code>,
<code>length</code>, <code>sample</code>, <code>subset</code>) as well as indexing is implemented to process
kwic class objects (see 'Usage'). See section 'Details' for the
<code>enrich</code>, <code>view</code> and <code>knit_print</code> methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'kwic'
get_corpus(x)

## S4 method for signature 'kwic'
count(.Object, p_attribute = "word")

## S4 method for signature 'kwic'
as.DocumentTermMatrix(x, p_attribute, verbose = TRUE, ...)

## S4 method for signature 'kwic'
as.TermDocumentMatrix(x, p_attribute, verbose = TRUE, ...)

## S4 method for signature 'kwic'
show(object)

## S4 method for signature 'kwic'
knit_print(x, options = knitr::opts_chunk)

## S4 method for signature 'kwic'
as.character(x, fmt = "&lt;i&gt;%s&lt;/i&gt;")

## S4 method for signature 'kwic,ANY,ANY,ANY'
x[i]

## S4 method for signature 'kwic'
subset(x, ...)

## S4 method for signature 'kwic'
as.data.frame(x)

## S4 method for signature 'kwic'
length(x)

## S4 method for signature 'kwic'
sample(x, size)

## S4 method for signature 'kwic_bundle'
merge(x)

## S4 method for signature 'kwic'
enrich(.Object, s_attributes = NULL, extra = NULL, table = FALSE, ...)

## S4 method for signature 'kwic'
format(
  x,
  node_color = "blue",
  align = TRUE,
  extra_color = "grey",
  lineview = getOption("polmineR.lineview")
)

## S4 method for signature 'kwic'
view(.Object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kwic-class_+3A_x">x</code></td>
<td>
<p>A <code>kwic</code> class object.</p>
</td></tr>
<tr><td><code id="kwic-class_+3A_.object">.Object</code></td>
<td>
<p>A <code>kwic</code> class object.</p>
</td></tr>
<tr><td><code id="kwic-class_+3A_p_attribute">p_attribute</code></td>
<td>
<p>A length-one <code>character</code> vector supplying a p-attribute.</p>
</td></tr>
<tr><td><code id="kwic-class_+3A_verbose">verbose</code></td>
<td>
<p>A <code>logical</code> value, whether to output debugging messages.</p>
</td></tr>
<tr><td><code id="kwic-class_+3A_...">...</code></td>
<td>
<p>Used for backwards compatibility.</p>
</td></tr>
<tr><td><code id="kwic-class_+3A_object">object</code></td>
<td>
<p>A <code>kwic</code> class object.</p>
</td></tr>
<tr><td><code id="kwic-class_+3A_options">options</code></td>
<td>
<p>Chunk options.</p>
</td></tr>
<tr><td><code id="kwic-class_+3A_fmt">fmt</code></td>
<td>
<p>A format string passed into <code>sprintf</code> to format the node of a
KWIC display.</p>
</td></tr>
<tr><td><code id="kwic-class_+3A_i">i</code></td>
<td>
<p>Single integer value, the kwic line for which the fulltext shall be
inspected.</p>
</td></tr>
<tr><td><code id="kwic-class_+3A_size">size</code></td>
<td>
<p>An <code>integer</code>, subset size for sampling.</p>
</td></tr>
<tr><td><code id="kwic-class_+3A_s_attributes">s_attributes</code></td>
<td>
<p>Character vector of s-attributes with metainformation.</p>
</td></tr>
<tr><td><code id="kwic-class_+3A_extra">extra</code></td>
<td>
<p>An <code>integer</code> value, number of extra tokens to the left and
to the right of the windows of tokens to the left and right of a query
match that are decoded to be displayed in a kwic output to facilitate
interpretation.</p>
</td></tr>
<tr><td><code id="kwic-class_+3A_table">table</code></td>
<td>
<p>Logical, whether to turn cpos <code>data.table</code> into
<code>data.table</code> in slot <code>stat</code> for output.</p>
</td></tr>
<tr><td><code id="kwic-class_+3A_node_color">node_color</code></td>
<td>
<p>If not <code>NULL</code>, the html color of the node. If
supplied, the node will be wrapped in respective html tags.</p>
</td></tr>
<tr><td><code id="kwic-class_+3A_align">align</code></td>
<td>
<p>A <code>logical</code> value for preparing kwic output. If
<code>TRUE</code>, whether the content of the columns 'left', 'node' and 'right'
will be wrapped in html div elements that will align the output right,
centered and left, respectively.</p>
</td></tr>
<tr><td><code id="kwic-class_+3A_extra_color">extra_color</code></td>
<td>
<p>If extra context has been generated using <code>enrich</code>,
the html color of the additional output (defaults to 'grey').</p>
</td></tr>
<tr><td><code id="kwic-class_+3A_lineview">lineview</code></td>
<td>
<p>A <code>logical</code> value, whether to concatenate left context,
node and right context when preparing kwic output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Applying the <code>count</code>-method on a <code>kwic</code> object will return
a <code>count</code> object with the evaluation of the left and right context of
the match.
</p>
<p>The <code>knit_print()</code> method will be called by knitr to render
<code>kwic</code> objects as a DataTable  <code>htmlwidget</code> when rendering a R
Markdown document as html. It will usually be necessary to explicitly state
&quot;render = knit_print&quot; in the chunk options. The option
<code>polmineR.pagelength</code> controls the number of lines displayed in the
resulting <code>htmlwidget</code>. Note that including htmlwidgets in html documents
requires that pandoc is installed. To avoid an error, a formatted
<code>data.table</code> is returned by <code>knit_print()</code> if pandoc is not
available.
</p>
<p>The <code>as.character</code>-method will return a list of <code>character</code> vectors,
concatenating the columns &quot;left&quot;, &quot;node&quot; and &quot;right&quot; of the <code>data.table</code> in
the <code>stat</code>-slot of the input <code>kwic</code>-class object. Optionally, the node can
be formatted using a format string that is passed into <code>sprintf</code>.
</p>
<p>The <code>subset</code>-method will apply <code>subset</code> to the table in the slot
<code>stat</code>, e.g. for filtering query results based on metadata (i.e.
s-attributes) that need to be present.
</p>
<p>The <code>enrich</code> method is used to generate the actual output for
the kwic method. If param <code>table</code> is <code>TRUE</code>, corpus positions
will be turned into a <code>data.frame</code> with the concordance lines. If
param <code>s_attributes</code> is a character vector with s-attributes, the
respective s-attributes will be added as columns to the table with
concordance lines.
</p>
<p>The <code>format</code>-method will return a <code>data.table</code> that can
serve as input for rendering a <code>htmlwidget</code>, for instance using
<code>DT::datatable</code> or <code>rhandsontable::rhandsontable</code>. It will
include html tags, so ensure that the rendering engine does not obfuscate
the html.
</p>


<h3>Slots</h3>


<dl>
<dt><code>metadata</code></dt><dd><p>A <code>character</code> vector with s-attributes of the metadata
that are to be displayed.</p>
</dd>
<dt><code>p_attribute</code></dt><dd><p>The p-attribute for which the context has been generated.</p>
</dd>
<dt><code>left</code></dt><dd><p>An <code>integer</code> value, words to the left of the query match.</p>
</dd>
<dt><code>right</code></dt><dd><p>An <code>integer</code> value, words to the right of the query match.</p>
</dd>
<dt><code>corpus</code></dt><dd><p>Length-one <code>character</code> vector, the CWB corpus.</p>
</dd>
<dt><code>cpos</code></dt><dd><p>A <code>data.table</code> with the columns &quot;match_id&quot;, &quot;cpos&quot;, &quot;position&quot;,
&quot;word_id&quot;, &quot;word&quot; and &quot;direction&quot;.</p>
</dd>
<dt><code>stat</code></dt><dd><p>A <code>data.table</code>, a table with columns &quot;left&quot;, &quot;node&quot;,
&quot;right&quot;, and metadata, if the object has been enriched.</p>
</dd>
<dt><code>encoding</code></dt><dd><p>A length-one <code>character</code> vector with the encoding of the
corpus.</p>
</dd>
<dt><code>name</code></dt><dd><p>A length-one <code>character</code> vector naming the object.</p>
</dd>
<dt><code>annotation_cols</code></dt><dd><p>A <code>character</code> vector designating the columns of
the <code>data.table</code> in the slot <code>table</code> that are annotations.</p>
</dd>
</dl>


<h3>See Also</h3>

<p>The constructor for generating kwic objects is the
<code><a href="#topic+kwic">kwic</a></code> method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>use("polmineR")
K &lt;- kwic("GERMAPARLMINI", "Integration")
get_corpus(K)
length(K)
K_min &lt;- K[1]
K_min &lt;- K[1:5]

# using kwic_bundle class
queries &lt;- c("oil", "prices", "barrel")
li &lt;- lapply(queries, function(q) kwic("REUTERS", query = q))
kb &lt;- as.bundle(li)

# use count-method on kwic object
coi &lt;- kwic("REUTERS", query = "oil") %&gt;%
  count(p_attribute = "word")

# features vs cooccurrences-method (identical results)
ref &lt;- count("REUTERS", p_attribute = "word") %&gt;%
  subset(word != "oil")
slot(ref, "size") &lt;- slot(ref, "size") - count("REUTERS", "oil")[["count"]]
y_features &lt;- features(coi, ref, method = "ll", included = TRUE)
y_cooc &lt;- cooccurrences("REUTERS", query = "oil")

# extract node and left and right context as character vectors
oil &lt;- kwic("REUTERS", query = "oil")
as.character(oil, fmt = NULL)
as.character(oil) # node wrapped into &lt;i&gt; tag by default
as.character(oil, fmt = "&lt;b&gt;%s&lt;/b&gt;")

# subsetting kwic objects
oil &lt;- corpus("REUTERS") %&gt;%
  kwic(query = "oil") %&gt;%
  subset(grepl("prices", right))
saudi_arabia &lt;- corpus("REUTERS") %&gt;%
  kwic(query = "Arabia") %&gt;%
  subset(grepl("Saudi", left))
int_spd &lt;- corpus("GERMAPARLMINI") %&gt;%
  kwic(query = "Integration") %&gt;%
  enrich(s_attribute = "party") %&gt;%
  subset(grepl("SPD", party))

# turn kwic object into data.frame with html tags
int &lt;- corpus("GERMAPARLMINI") %&gt;%
  kwic(query = "Integration")

as.data.frame(int) # Without further metadata

enrich(int, s_attributes = c("date", "speaker", "party")) %&gt;%
  as.data.frame()
  
# merge bundle of kwic objects into one kwic
reuters &lt;- corpus("REUTERS")
queries &lt;- c('"Saudi" "Arabia"', "oil", '"barrel.*"')
comb &lt;- lapply(queries, function(qu) kwic(reuters, query = qu)) %&gt;%
  as.bundle() %&gt;%
  merge()
 
# enrich kwic object
i &lt;- corpus("GERMAPARLMINI") %&gt;%
  kwic(query = "Integration") %&gt;%
  enrich(s_attributes = c("date", "speaker", "party"))
</code></pre>

<hr>
<h2 id='ll'>Compute Log-likelihood Statistics.</h2><span id='topic+ll'></span><span id='topic+ll+2Cfeatures-method'></span><span id='topic+ll+2Ccontext-method'></span><span id='topic+ll+2Ccooccurrences-method'></span><span id='topic+ll+2CCooccurrences-method'></span>

<h3>Description</h3>

<p>Apply the log-likelihood statistic to detect cooccurrences or keywords.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ll(.Object, ...)

## S4 method for signature 'features'
ll(.Object)

## S4 method for signature 'context'
ll(.Object)

## S4 method for signature 'cooccurrences'
ll(.Object)

## S4 method for signature 'Cooccurrences'
ll(.Object, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ll_+3A_.object">.Object</code></td>
<td>
<p>An object of class <code>cooccurrence</code>, <code>context</code>, or
<code>features</code>.</p>
</td></tr>
<tr><td><code id="ll_+3A_...">...</code></td>
<td>
<p>Further arguments (such as <code>verbose</code>).</p>
</td></tr>
<tr><td><code id="ll_+3A_verbose">verbose</code></td>
<td>
<p>Logical, whether to output messages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The log-likelihood test to detect cooccurrences is a standard approach to
find collocations (Dunning 1993, Evert 2005, 2009).
</p>
<p>(a) The basis for computing for the log-likelihood statistic is a contingency
table of observationes, which is prepared for every single token in the
corpus. It reports counts for a token to inspect and all other tokens in a
corpus of interest (coi) and a reference corpus (ref):
</p>

<table>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: center;"> coi   </td><td style="text-align: center;"> ref </td><td style="text-align: center;"> TOTAL </td>
</tr>
<tr>
 <td style="text-align: right;">
count token </td><td style="text-align: center;"> <code class="reqn">o_{11}</code> </td><td style="text-align: center;"> <code class="reqn">o_{12}</code> </td><td style="text-align: center;"> <code class="reqn">r_{1}</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
other tokens </td><td style="text-align: center;"> <code class="reqn">o_{21}</code> </td><td style="text-align: center;"> <code class="reqn">o_{22}</code> </td><td style="text-align: center;"> <code class="reqn">r_{2}</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
TOTAL </td><td style="text-align: center;"> <code class="reqn">c_{1}</code> </td><td style="text-align: center;"> <code class="reqn">c_{2}</code> </td><td style="text-align: center;"> N
</td>
</tr>

</table>

<p>(b) Based on the contingency table(s) with observed counts, expected values
are calculated for each cell, as the product of the column and margin sums,
divided by the overall number of tokens (see example).
</p>
<p>(c) The standard formula for calculating the log-likelihood test is as
follows.
</p>
<p style="text-align: center;"><code class="reqn">G^{2} = 2 \sum{O_{ij} log(\frac{O_{ij}}{E_{ij}})}</code>
</p>

<p>Note: Before polmineR v0.7.11, a simplification of the formula was used
(Rayson/Garside 2000), which omits the third and fourth term of the previous
formula:
</p>
<p style="text-align: center;"><code class="reqn">ll = 2(o_{11} log (\frac{o_{11}}{E_{11}}) + o_{12} log(\frac{o_{12}}{E_{12}}))</code>
</p>

<p>There is a (small) gain of computational efficiency using this simplified
formula and the result is almost identical with the standard formula; see
however the critical discussion of Ulrike Tabbert (2015: 84ff).
</p>
<p>The implementation in the <code>ll</code>-method uses a vectorized approach of the
computation, which is substantially faster than iterating the rows of a
table, generating individual contingency tables etc. As using the standard
formula is not significantly slower than relying on the simplified formula,
polmineR has moved to the standard computation.
</p>
<p>An inherent difficulty of the log likelihood statistic is that it is not
possible to compute the statistical test value if the number of observed
counts in the reference corpus is 0, i.e. if a term only occurrs exclusively
in the neighborhood of a node word. When filtering out rare words from the
result table, respective <code>NA</code> values will usually disappear.
</p>


<h3>References</h3>

<p>Dunning, Ted (1993): Accurate Methods for the Statistics of
Surprise and Coincidence. <em>Computational Linguistics</em>, Vol. 19, No. 1,
pp. 61-74.
</p>
<p>Rayson, Paul; Garside, Roger (2000): Comparing Corpora using
Frequency Profiling. <em>The Workshop on Comparing Corpora</em>.
<a href="https://aclanthology.org/W00-0901/">https://aclanthology.org/W00-0901/</a>.
</p>
<p>Evert, Stefan (2005): <em>The Statistics of Word Cooccurrences.
Word Pairs and Collocations.</em> URN urn:nbn:de:bsz:93-opus-23714.
<a href="https://elib.uni-stuttgart.de/bitstream/11682/2573/1/Evert2005phd.pdf">https://elib.uni-stuttgart.de/bitstream/11682/2573/1/Evert2005phd.pdf</a>
</p>
<p>Evert, Stefan (2009). Corpora and Collocations. In: A. Ludeling
and M. Kyto (eds.), <em>Corpus Linguistics. An International Handbook</em>. Mouton
de Gruyter, Berlin, pp. 1212-1248 (ch. 58).
</p>
<p>Tabbert, Ulrike (2015): <em>Crime and Corpus. The Linguistic
Representation of Crime in the Press</em>. Amsterdam: Benjamins.
</p>


<h3>See Also</h3>

<p>Other statistical methods: 
<code><a href="#topic+chisquare">chisquare</a>()</code>,
<code><a href="#topic+pmi">pmi</a>()</code>,
<code><a href="#topic+t_test">t_test</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># use ll-method explicitly
oil &lt;- cooccurrences("REUTERS", query = "oil", method = NULL)
oil &lt;- ll(oil)
oil_min &lt;- subset(oil, count_coi &gt;= 3)
if (interactive()) View(format(oil_min))
summary(oil)

# use ll-method on 'Cooccurrences'-object
## Not run: 
R &lt;- Cooccurrences("REUTERS", left = 5L, right = 5L, p_attribute = "word")
ll(R)
decode(R)
summary(R)

## End(Not run)

# use log likelihood test for feature extraction
x &lt;- partition(
  "GERMAPARLMINI", speaker = "Merkel",
  interjection = "speech", regex = TRUE,
  p_attribute = "word"
)
f &lt;- features(x, y = "GERMAPARLMINI", included = TRUE, method = "ll")
f &lt;- features(x, y = "GERMAPARLMINI", included = TRUE, method = NULL)
f &lt;- ll(f)
summary(f)

## Not run: 

# A sample do-it-yourself calculation for log-likelihood:
# Compute ll-value for query "oil", and "prices"

oil &lt;- context("REUTERS", query = "oil", left = 5, right = 5)

# (a) prepare matrix with observed values
o &lt;- matrix(data = rep(NA, 4), ncol = 2) 
o[1,1] &lt;- as(oil, "data.table")[word == "prices"][["count_coi"]]
o[1,2] &lt;- count("REUTERS", query = "prices")[["count"]] - o[1,1]
o[2,1] &lt;- size(oil)[["coi"]] - o[1,1]
o[2,2] &lt;- size(oil)[["ref"]] - o[1,2]


# (b) prepare matrix with expected values, calculate margin sums first
r &lt;- rowSums(o)
c &lt;- colSums(o)
N &lt;- sum(o)

e &lt;- matrix(data = rep(NA, 4), ncol = 2) # matrix with expected values
e[1,1] &lt;- r[1] * (c[1] / N)
e[1,2] &lt;- r[1] * (c[2] / N)
e[2,1] &lt;- r[2] * (c[1] / N)
e[2,2] &lt;- r[2] * (c[2] / N)


# (c) compute log-likelihood value
ll_value &lt;- 2 * (
  o[1,1] * log(o[1,1] / e[1,1]) +
  o[1,2] * log(o[1,2] / e[1,2]) +
  o[2,1] * log(o[2,1] / e[2,1]) +
  o[2,2] * log(o[2,2] / e[2,2])
)

df &lt;- as.data.frame(cooccurrences("REUTERS", query = "oil"))
subset(df, word == "prices")[["ll"]]

## End(Not run)
</code></pre>

<hr>
<h2 id='means'>calculate means</h2><span id='topic+means'></span><span id='topic+means+2CDocumentTermMatrix-method'></span>

<h3>Description</h3>

<p>calculate means
</p>


<h3>Usage</h3>

<pre><code class='language-R'>means(.Object, ...)

## S4 method for signature 'DocumentTermMatrix'
means(.Object, dim = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="means_+3A_.object">.Object</code></td>
<td>
<p>object to work on</p>
</td></tr>
<tr><td><code id="means_+3A_...">...</code></td>
<td>
<p>further parameters
@exportMethod means</p>
</td></tr>
<tr><td><code id="means_+3A_dim">dim</code></td>
<td>
<p>numeric, 1 or 2 whether to work on rows or columns</p>
</td></tr>
</table>

<hr>
<h2 id='ngrams'>Get N-Grams</h2><span id='topic+ngrams'></span><span id='topic+ngrams+2Cpartition-method'></span><span id='topic+ngrams+2Ccharacter-method'></span><span id='topic+ngrams+2Csubcorpus-method'></span><span id='topic+ngrams+2Cdata.table-method'></span><span id='topic+ngrams+2Ccorpus-method'></span><span id='topic+ngrams+2Clist-method'></span><span id='topic+ngrams+2Cpartition_bundle-method'></span>

<h3>Description</h3>

<p>Count n-grams, either of words, or of characters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ngrams(.Object, ...)

## S4 method for signature 'partition'
ngrams(
  .Object,
  n = 2,
  p_attribute = "word",
  char = NULL,
  progress = FALSE,
  mc = 1L,
  ...
)

## S4 method for signature 'character'
ngrams(
  .Object,
  n = 2,
  p_attribute = "word",
  char = NULL,
  progress = FALSE,
  mc = 1L,
  ...
)

## S4 method for signature 'partition'
ngrams(
  .Object,
  n = 2,
  p_attribute = "word",
  char = NULL,
  progress = FALSE,
  mc = 1L,
  ...
)

## S4 method for signature 'subcorpus'
ngrams(
  .Object,
  n = 2,
  p_attribute = "word",
  char = NULL,
  progress = FALSE,
  mc = 1L,
  ...
)

## S4 method for signature 'character'
ngrams(
  .Object,
  n = 2,
  p_attribute = "word",
  char = NULL,
  progress = FALSE,
  mc = 1L,
  ...
)

## S4 method for signature 'data.table'
ngrams(.Object, n = 2L, p_attribute = "word")

## S4 method for signature 'corpus'
ngrams(
  .Object,
  n = 2,
  p_attribute = "word",
  char = NULL,
  progress = FALSE,
  mc = 1L,
  ...
)

## S4 method for signature 'list'
ngrams(
  .Object,
  n = 2,
  char = NULL,
  mc = FALSE,
  verbose = FALSE,
  progress = FALSE,
  ...
)

## S4 method for signature 'partition_bundle'
ngrams(
  .Object,
  n = 2,
  char = NULL,
  vocab = NULL,
  p_attribute = "word",
  mc = FALSE,
  verbose = FALSE,
  progress = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ngrams_+3A_.object">.Object</code></td>
<td>
<p>object of class <code>partition</code></p>
</td></tr>
<tr><td><code id="ngrams_+3A_...">...</code></td>
<td>
<p>Further arguments.</p>
</td></tr>
<tr><td><code id="ngrams_+3A_n">n</code></td>
<td>
<p>Number of tokens (if <code>char</code> is <code>NULL</code>) or characters otherwise.</p>
</td></tr>
<tr><td><code id="ngrams_+3A_p_attribute">p_attribute</code></td>
<td>
<p>the p-attribute to use (can be &gt; 1)</p>
</td></tr>
<tr><td><code id="ngrams_+3A_char">char</code></td>
<td>
<p>If <code>NULL</code>, tokens will be counted, else characters, keeping
only those provided by a character vector</p>
</td></tr>
<tr><td><code id="ngrams_+3A_progress">progress</code></td>
<td>
<p>A <code>logical</code> value.</p>
</td></tr>
<tr><td><code id="ngrams_+3A_mc">mc</code></td>
<td>
<p>A <code>logical</code> value, whether to use multicore, passed into call
to <code>blapply()</code>.</p>
</td></tr>
<tr><td><code id="ngrams_+3A_verbose">verbose</code></td>
<td>
<p>A length-one <code>logical</code> value, whether to show messages.</p>
</td></tr>
<tr><td><code id="ngrams_+3A_vocab">vocab</code></td>
<td>
<p>A <code>character</code> vector with an alternative vocabulary to the one
stored on disk.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>use("polmineR")
P &lt;- partition("GERMAPARLMINI", date = "2009-10-27")
ngrm &lt;- ngrams(P, n = 2, p_attribute = "word", char = NULL)

# a more complex scenario: get most frequent ADJA/NN-combinations
ngrm &lt;- ngrams(P, n = 2, p_attribute = c("word", "pos"), char = NULL)
ngrm2 &lt;- subset(
 ngrm,
 ngrm[["1_pos"]] == "ADJA"  &amp; ngrm[["2_pos"]] == "NN"
 )
ngrm2@stat[, "1_pos" := NULL][, "2_pos" := NULL]
ngrm3 &lt;- sort(ngrm2, by = "count")
head(ngrm3)
use(pkg = "RcppCWB", corpus = "REUTERS")
dt &lt;- decode("REUTERS", p_attribute = "word", s_attribute = character(), to = "data.table")
y &lt;- ngrams(dt, n = 3L, p_attribute = "word")
</code></pre>

<hr>
<h2 id='ngrams_class'>Ngrams class.</h2><span id='topic+ngrams_class'></span><span id='topic+ngrams-class'></span>

<h3>Description</h3>

<p>Ngrams class.
</p>

<hr>
<h2 id='noise'>detect noise</h2><span id='topic+noise'></span><span id='topic+noise+2CDocumentTermMatrix-method'></span><span id='topic+noise+2CTermDocumentMatrix-method'></span><span id='topic+noise+2Ccharacter-method'></span><span id='topic+noise+2Ctextstat-method'></span>

<h3>Description</h3>

<p>detect noise
</p>


<h3>Usage</h3>

<pre><code class='language-R'>noise(.Object, ...)

## S4 method for signature 'DocumentTermMatrix'
noise(
  .Object,
  minTotal = 2,
  minTfIdfMean = 0.005,
  sparse = 0.995,
  stopwordsLanguage = "german",
  minNchar = 2L,
  specialChars = getOption("polmineR.specialChars"),
  numbers = "^[0-9\\.,]+$",
  verbose = TRUE
)

## S4 method for signature 'TermDocumentMatrix'
noise(.Object, ...)

## S4 method for signature 'character'
noise(
  .Object,
  stopwordsLanguage = "german",
  minNchar = 2,
  specialChars = getOption("polmineR.specialChars"),
  numbers = "^[0-9\\.,]+$",
  verbose = TRUE
)

## S4 method for signature 'textstat'
noise(.Object, p_attribute, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="noise_+3A_.object">.Object</code></td>
<td>
<p>An object of class <code>DocumentTermMatrix</code>.</p>
</td></tr>
<tr><td><code id="noise_+3A_...">...</code></td>
<td>
<p>further parameters</p>
</td></tr>
<tr><td><code id="noise_+3A_mintotal">minTotal</code></td>
<td>
<p>minimum colsum (for DocumentTermMatrix) to qualify a term as non-noise</p>
</td></tr>
<tr><td><code id="noise_+3A_mintfidfmean">minTfIdfMean</code></td>
<td>
<p>minimum mean value for tf-idf to qualify a term as non-noise</p>
</td></tr>
<tr><td><code id="noise_+3A_sparse">sparse</code></td>
<td>
<p>Will be passed into <code>tm::removeSparseTerms()</code>.</p>
</td></tr>
<tr><td><code id="noise_+3A_stopwordslanguage">stopwordsLanguage</code></td>
<td>
<p>e.g. &quot;german&quot;, to get stopwords defined in the <code>tm</code> package.</p>
</td></tr>
<tr><td><code id="noise_+3A_minnchar">minNchar</code></td>
<td>
<p>Minimum number of characters to qualify a term as non-noise.</p>
</td></tr>
<tr><td><code id="noise_+3A_specialchars">specialChars</code></td>
<td>
<p>special characters to drop</p>
</td></tr>
<tr><td><code id="noise_+3A_numbers">numbers</code></td>
<td>
<p>regex, to drop numbers</p>
</td></tr>
<tr><td><code id="noise_+3A_verbose">verbose</code></td>
<td>
<p>logical</p>
</td></tr>
<tr><td><code id="noise_+3A_p_attribute">p_attribute</code></td>
<td>
<p>relevant if applied to a textstat object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list
</p>

<hr>
<h2 id='ocpu_exec'>Execute code on OpenCPU server</h2><span id='topic+ocpu_exec'></span><span id='topic+opencpu'></span>

<h3>Description</h3>

<p><code>ocpu_exec</code> will execute a function/method <code>fn</code> on an OpenCPU server
(specified by argument <code>server</code>), using three dots (<code>...</code>) to pass
arguments. It is the worker of methods defined for <code>remote_corpus</code>,
<code>remote_subcorpus</code> and <code>remote_partition</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ocpu_exec(fn, corpus, server, restricted = FALSE, do.call = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ocpu_exec_+3A_fn">fn</code></td>
<td>
<p>Name of the function/method to execute on remote server (length-one
<code>character</code> vector).</p>
</td></tr>
<tr><td><code id="ocpu_exec_+3A_corpus">corpus</code></td>
<td>
<p>A length-one <code>character</code> vector, the id of the corpus to be
queried.</p>
</td></tr>
<tr><td><code id="ocpu_exec_+3A_server">server</code></td>
<td>
<p>The IP/URL of the remote OpenCPU server.</p>
</td></tr>
<tr><td><code id="ocpu_exec_+3A_restricted">restricted</code></td>
<td>
<p>A <code>logical</code> value, whether credentials are required to
access the data.</p>
</td></tr>
<tr><td><code id="ocpu_exec_+3A_do.call">do.call</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the function <code>fn</code> is passed into
a call of <code>do.call</code>, which offers some flexibility.</p>
</td></tr>
<tr><td><code id="ocpu_exec_+3A_...">...</code></td>
<td>
<p>Arguments passed into the method/function call.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Get polmineR version installed on remote server
ocpu_exec(
  fn = "packageVersion",
  server = Sys.getenv("OPENCPU_SERVER"),
  do.call = TRUE,
  pkg = "polmineR"
)

## End(Not run)
</code></pre>

<hr>
<h2 id='p_attributes'>Get p-attributes.</h2><span id='topic+p_attributes'></span><span id='topic+p_attributes+2Ccharacter-method'></span><span id='topic+p_attributes+2Ccorpus-method'></span><span id='topic+p_attributes+2Cslice-method'></span><span id='topic+p_attributes+2Cpartition_bundle-method'></span><span id='topic+p_attributes+2Cremote_corpus-method'></span><span id='topic+p_attributes+2Cremote_partition-method'></span>

<h3>Description</h3>

<p>In a CWB corpus, every token has positional attributes. While s-attributes
cover a range of tokens, every single token in the token stream of a corpus
will have a set of positional attributes (such as part-of-speech, or lemma).
The available p-attributes are returned by the <code>p_attributes</code>-method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_attributes(.Object, ...)

## S4 method for signature 'character'
p_attributes(.Object, p_attribute = NULL)

## S4 method for signature 'corpus'
p_attributes(.Object, p_attribute = NULL)

## S4 method for signature 'slice'
p_attributes(.Object, p_attribute = NULL, decode = TRUE)

## S4 method for signature 'partition_bundle'
p_attributes(.Object, p_attribute = NULL, decode = TRUE)

## S4 method for signature 'remote_corpus'
p_attributes(.Object, ...)

## S4 method for signature 'remote_partition'
p_attributes(.Object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p_attributes_+3A_.object">.Object</code></td>
<td>
<p>A length-one <code>character</code> vector, or a <code>partition</code>
object.</p>
</td></tr>
<tr><td><code id="p_attributes_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>get_token_stream</code>.</p>
</td></tr>
<tr><td><code id="p_attributes_+3A_p_attribute">p_attribute</code></td>
<td>
<p>A p-attribute to decode, provided by a length-one
<code>character</code> vector.</p>
</td></tr>
<tr><td><code id="p_attributes_+3A_decode">decode</code></td>
<td>
<p>A length-one <code>logical</code> value. Whether to return decoded
p-attributes or unique token ids.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>p_attributes</code>-method returns the p-attributes defined for the
corpus the partition is derived from, if argument <code>p_attribute</code> is
<code>NULL</code> (the default). If <code>p_attribute</code> is defined, the unique
values for the p-attribute are returned.
</p>


<h3>References</h3>

<p>Stefan Evert &amp; The OCWB Development Team, CQP Query Language
Tutorial, https://cwb.sourceforge.io/files/CQP_Tutorial.pdf.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>use(pkg = "RcppCWB", corpus = "REUTERS")

p_attributes("REUTERS")
p_attributes("REUTERS", p_attribute = "word")
merkel &lt;- partition("GERMAPARLMINI", speaker = "Merkel", regex = TRUE)
merkel_words &lt;- p_attributes(merkel, "word")
</code></pre>

<hr>
<h2 id='partition'>Initialize a partition.</h2><span id='topic+partition'></span><span id='topic+partition+2Ccorpus-method'></span><span id='topic+partition+2Ccharacter-method'></span><span id='topic+partition+2Cenvironment-method'></span><span id='topic+partition+2Cpartition-method'></span><span id='topic+partition+2Ccontext-method'></span><span id='topic+partition+2Cremote_corpus-method'></span><span id='topic+partition+2Cremote_partition-method'></span>

<h3>Description</h3>

<p>Create a subcorpus and keep it in an object of the <code>partition</code> class. If
defined, counts are performed for the p-attribute defined by the parameter
<code>p_attribute</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partition(.Object, ...)

## S4 method for signature 'corpus'
partition(
  .Object,
  def = NULL,
  name = "",
  encoding = NULL,
  p_attribute = NULL,
  regex = FALSE,
  xml = slot(.Object, "xml"),
  decode = TRUE,
  type = get_type(.Object),
  mc = FALSE,
  verbose = TRUE,
  ...
)

## S4 method for signature 'character'
partition(
  .Object,
  def = NULL,
  name = "",
  encoding = NULL,
  p_attribute = NULL,
  regex = FALSE,
  decode = TRUE,
  type = get_type(.Object),
  mc = FALSE,
  verbose = TRUE,
  ...
)

## S4 method for signature 'environment'
partition(.Object, slots = c("name", "corpus", "size", "p_attribute"))

## S4 method for signature 'partition'
partition(
  .Object,
  def = NULL,
  name = "",
  regex = FALSE,
  p_attribute = NULL,
  decode = TRUE,
  xml = NULL,
  verbose = TRUE,
  mc = FALSE,
  ...
)

## S4 method for signature 'context'
partition(.Object, node = TRUE)

## S4 method for signature 'remote_corpus'
partition(.Object, ...)

## S4 method for signature 'remote_partition'
partition(.Object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partition_+3A_.object">.Object</code></td>
<td>
<p>A length-one character-vector, the CWB corpus to be used.</p>
</td></tr>
<tr><td><code id="partition_+3A_...">...</code></td>
<td>
<p>Arguments to define partition (see examples). If <code>.Object</code> is
a <code>remote_corpus</code> or <code>remote_partition</code> object, the three dots
(<code>...</code>) are used to pass arguments. Hence, it is necessary to state
the names of all arguments to be passed explicity.</p>
</td></tr>
<tr><td><code id="partition_+3A_def">def</code></td>
<td>
<p>A named list of character vectors of s-attribute values, the names
are the s-attributes (see details and examples)</p>
</td></tr>
<tr><td><code id="partition_+3A_name">name</code></td>
<td>
<p>A name for the new <code>partition</code> object, defaults to &quot;&quot;.</p>
</td></tr>
<tr><td><code id="partition_+3A_encoding">encoding</code></td>
<td>
<p>The encoding of the corpus (typically &quot;LATIN1 or &quot;(UTF-8)),
if NULL, the encoding provided in the registry file of the corpus
(charset=&quot;...&quot;) will be used.</p>
</td></tr>
<tr><td><code id="partition_+3A_p_attribute">p_attribute</code></td>
<td>
<p>The p-attribute(s) for which a count is performed.</p>
</td></tr>
<tr><td><code id="partition_+3A_regex">regex</code></td>
<td>
<p>A logical value (defaults to FALSE).</p>
</td></tr>
<tr><td><code id="partition_+3A_xml">xml</code></td>
<td>
<p>Either 'flat' (default) or 'nested'.</p>
</td></tr>
<tr><td><code id="partition_+3A_decode">decode</code></td>
<td>
<p>Logical, whether to turn token ids to strings (set FALSE to
minimize object size / memory consumption) in data.table with counts.</p>
</td></tr>
<tr><td><code id="partition_+3A_type">type</code></td>
<td>
<p>A length-one character vector specifying the type of corpus / partition (e.g. &quot;plpr&quot;)</p>
</td></tr>
<tr><td><code id="partition_+3A_mc">mc</code></td>
<td>
<p>Whether to use multicore (for counting terms).</p>
</td></tr>
<tr><td><code id="partition_+3A_verbose">verbose</code></td>
<td>
<p>Logical, whether to be verbose.</p>
</td></tr>
<tr><td><code id="partition_+3A_slots">slots</code></td>
<td>
<p>Object slots that will be reported columns of <code>data.frame</code>
summarizing <code>partition</code> objects in environment.</p>
</td></tr>
<tr><td><code id="partition_+3A_node">node</code></td>
<td>
<p>A logical value, whether to include the node (i.e. query matches) in the region matrix
generated when creating a <code>partition</code> from a <code>context</code>-object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function sets up a <code>partition</code> object based on s-attribute values.
The s-attributes defining the partition can be passed in as a list, e.g.
<code>list(interjection="speech", year = "2013")</code>, or directly (see
examples).
</p>
<p>The s-attribute values defining the partition may use regular expressions. To
use regular expressions, set the parameter regex to <code>TRUE</code>. Regular
expressions are passed into <code>grep</code>, i.e. the regex syntax used in R
needs to be used (double backlashes etc.). If regex is <code>FALSE</code>, the
length of the character vectors can be &gt; 1, matching s-attributes are
identifies with the operator '%in%'.
</p>
<p>The XML imported into the CWB may be &quot;flat&quot; or &quot;nested&quot;. This needs to be
indicated with the parameter <code>xml</code> (default is &quot;flat&quot;). If you generate
a <code>partition</code> based on a flat XML structure, some performance gain may be
achieved when ordering the s-attributes with decreasingly restrictive
conditions. If you have a nested XML, it is mandatory that the order of the
s-attributes provided reflects the hierarchy of the XML: The top-level
elements need to be positioned at the beginning of the list with the
s-attributes, the the most restrictive elements at the end.
</p>
<p>If <code>p_attribute</code> is not NULL, a count of tokens in the corpus will be
performed and kept in the <code>stat</code>-slot of the partition-object. The
length of the <code>p_attribute</code> character vector may be 1 or more. If two or
more p-attributes are provided, The occurrence of combinations will be
counted. A typical scenario is to combine the p-attributes &quot;word&quot; or &quot;lemma&quot;
and &quot;pos&quot;.
</p>
<p>If <code>.Object</code> is a length-one character vector, a subcorpus/partition
for the corpus defined be <code>.Object</code> is generated.
</p>
<p>If <code>.Object</code> is an environment (typically <code>.GlobalEnv</code>),
the <code>partition</code> objects present in the environment are listed.
</p>
<p>If <code>.Object</code> is a <code>partition</code> object, a subcorpus of the
subcorpus is generated.
</p>


<h3>Value</h3>

<p>An object of the S4 class <code>partition</code>.
</p>


<h3>Author(s)</h3>

<p>Andreas Blaette
</p>


<h3>See Also</h3>

<p>To learn about the methods available for objects of the class
<code>partition</code>, see <code><a href="#topic+partition_class">partition_class</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>use("polmineR")
spd &lt;- partition("GERMAPARLMINI", party = "SPD", interjection = "speech")
kauder &lt;- partition("GERMAPARLMINI", speaker = "Volker Kauder", p_attribute = "word")
merkel &lt;- partition("GERMAPARLMINI", speaker = ".*Merkel", p_attribute = "word", regex = TRUE)
s_attributes(merkel, "date")
s_attributes(merkel, "speaker")
merkel &lt;- partition(
  "GERMAPARLMINI", speaker = "Angela Dorothea Merkel",
  date = "2009-11-10", interjection = "speech", p_attribute = "word"
  )
merkel &lt;- subset(merkel, !word %in% punctuation)
merkel &lt;- subset(merkel, !word %in% tm::stopwords("de"))
   
# a certain defined time segment
days &lt;- seq(
  from = as.Date("2009-10-28"),
  to = as.Date("2009-11-11"),
  by = "1 day"
)
period &lt;- partition("GERMAPARLMINI", date = days)
</code></pre>

<hr>
<h2 id='partition_bundle'>Generate bundle of partitions.</h2><span id='topic+partition_bundle'></span><span id='topic+partition_bundle+2Cpartition-method'></span><span id='topic+partition_bundle+2Ccorpus-method'></span><span id='topic+partition_bundle+2Ccharacter-method'></span><span id='topic+partition_bundle+2Ccontext-method'></span><span id='topic+partition_bundle+2Cpartition_bundle-method'></span>

<h3>Description</h3>

<p>Use <code>partition_bundle</code> to create a <code>partition_bundle</code> object, which
combines a set of <code>partition</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partition_bundle(.Object, ...)

## S4 method for signature 'partition'
partition_bundle(
  .Object,
  s_attribute,
  values = NULL,
  prefix = "",
  mc = getOption("polmineR.mc"),
  verbose = TRUE,
  progress = FALSE,
  type = get_type(.Object),
  ...
)

## S4 method for signature 'corpus'
partition_bundle(
  .Object,
  s_attribute,
  values = NULL,
  prefix = "",
  mc = getOption("polmineR.mc"),
  verbose = TRUE,
  progress = FALSE,
  xml = "flat",
  type = get_type(.Object),
  ...
)

## S4 method for signature 'character'
partition_bundle(
  .Object,
  s_attribute,
  values = NULL,
  prefix = "",
  mc = getOption("polmineR.mc"),
  verbose = TRUE,
  progress = FALSE,
  xml = "flat",
  type = get_type(.Object),
  ...
)

## S4 method for signature 'context'
partition_bundle(
  .Object,
  node = TRUE,
  verbose = TRUE,
  progress = TRUE,
  mc = 1L
)

## S4 method for signature 'partition_bundle'
partition_bundle(
  .Object,
  s_attribute,
  prefix = character(),
  progress = TRUE,
  mc = getOption("polmineR.mc")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partition_bundle_+3A_.object">.Object</code></td>
<td>
<p>A <code>partition</code>, a length-one <code>character</code> vector supplying a CWB corpus, or a <code>partition_bundle</code></p>
</td></tr>
<tr><td><code id="partition_bundle_+3A_...">...</code></td>
<td>
<p>parameters to be passed into partition-method (see respective documentation)</p>
</td></tr>
<tr><td><code id="partition_bundle_+3A_s_attribute">s_attribute</code></td>
<td>
<p>The s-attribute to vary.</p>
</td></tr>
<tr><td><code id="partition_bundle_+3A_values">values</code></td>
<td>
<p>Values the s-attribute provided shall assume.</p>
</td></tr>
<tr><td><code id="partition_bundle_+3A_prefix">prefix</code></td>
<td>
<p>A character vector that will be attached as a prefix to partition names.</p>
</td></tr>
<tr><td><code id="partition_bundle_+3A_mc">mc</code></td>
<td>
<p>Logical, whether to use multicore parallelization.</p>
</td></tr>
<tr><td><code id="partition_bundle_+3A_verbose">verbose</code></td>
<td>
<p>Logical, whether to provide progress information.</p>
</td></tr>
<tr><td><code id="partition_bundle_+3A_progress">progress</code></td>
<td>
<p>Logical, whether to show progress bar.</p>
</td></tr>
<tr><td><code id="partition_bundle_+3A_type">type</code></td>
<td>
<p>The type of <code>partition</code> to generate.</p>
</td></tr>
<tr><td><code id="partition_bundle_+3A_xml">xml</code></td>
<td>
<p>A <code>logical</code> value.</p>
</td></tr>
<tr><td><code id="partition_bundle_+3A_node">node</code></td>
<td>
<p>A logical value, whether to include the node (i.e. query matches) in the region matrix
generated when creating a <code>partition</code> from a <code>context</code>-object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Applying the <code>partition_bundle</code>-method to a <code>partition_bundle</code>-object will iterate
through the <code>partition</code> objects in the <code>object</code>-slot in the <code>partition_bundle</code>, and apply
<code>partition_bundle</code> on each <code>partition</code>, splitting it up by the s-attribute provided by the
argument <code>s_attribute</code>. The return value is a <code>partition_bundle</code>, the names of which will be
the names of the incoming <code>partition_bundle</code> concatenated with the s-attribute values used for splitting.
The argument <code>prefix</code> can be used to achieve a more descriptive name.
</p>


<h3>Value</h3>

<p>S4 class <code>partition_bundle</code>, with list of partition objects in slot 'objects'
</p>


<h3>Author(s)</h3>

<p>Andreas Blaette
</p>


<h3>See Also</h3>

<p><code><a href="#topic+partition">partition</a></code> and <code><a href="#topic+bundle">bundle</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
use("polmineR")
bt2009 &lt;- partition("GERMAPARLMINI", date = "2009-.*", regex = TRUE)
pb &lt;- partition_bundle(bt2009, s_attribute = "date", progress = TRUE)
pb &lt;- enrich(pb, p_attribute = "word")
dtm &lt;- as.DocumentTermMatrix(pb, col = "count")
summary(pb)
pb &lt;- partition_bundle("GERMAPARLMINI", s_attribute = "date")

## End(Not run)
## Not run: 
use("RcppCWB", corpus = "REUTERS")
pb &lt;- corpus("REUTERS") %&gt;%
  context(query = "oil", p_attribute = "word") %&gt;%
  partition_bundle(node = FALSE, verbose = TRUE)

## End(Not run)
# split up objects in partition_bundle by using partition_bundle-method
use("polmineR")
pb &lt;- partition_bundle("GERMAPARLMINI", s_attribute = "date")
pb2 &lt;- partition_bundle(pb, s_attribute = "speaker", progress = FALSE)

summary(pb2)
</code></pre>

<hr>
<h2 id='partition_bundle-class'>Bundle of partitions (partition_bundle class).</h2><span id='topic+partition_bundle-class'></span><span id='topic++5B+2Cpartition_bundle-method'></span><span id='topic++5B+5B+2Cpartition_bundle-method'></span><span id='topic+as.matrix+2Cpartition_bundle-method'></span><span id='topic+merge+2Cpartition_bundle-method'></span><span id='topic++2B+2Cpartition_bundle-method'></span><span id='topic+names+2Cpartition_bundle-method'></span><span id='topic+summary+2Cpartition_bundle-method'></span><span id='topic++2B+2Cpartition_bundle+2CANY-method'></span><span id='topic++5B+2Cpartition_bundle+2CANY+2CANY+2CANY-method'></span><span id='topic++2B+2Cpartition_bundle+2Cpartition-method'></span><span id='topic++2B+2Cpartition_bundle+2Cpartition_bundle-method'></span><span id='topic+as.partition_bundle+2Clist-method'></span><span id='topic+barplot+2Cpartition_bundle-method'></span><span id='topic+show+2Cpartition_bundle-method'></span><span id='topic+partition_bundle+2Cenvironment-method'></span><span id='topic+enrich+2Cpartition_bundle-method'></span><span id='topic+enrich+2Csubcorpus_bundle-method'></span><span id='topic+flatten'></span>

<h3>Description</h3>

<p>Class and methods to manage bundles of partitions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'partition_bundle'
show(object)

## S4 method for signature 'partition_bundle'
summary(object, progress = FALSE)

## S4 method for signature 'partition_bundle'
merge(x, name = "", verbose = FALSE)

## S4 method for signature 'partition_bundle'
barplot(height, ...)

## S4 method for signature 'list'
as.partition_bundle(.Object, ...)

## S4 method for signature 'environment'
partition_bundle(.Object)

## S4 method for signature 'partition_bundle'
enrich(.Object, p_attribute, decode = TRUE, verbose = FALSE)

## S4 method for signature 'subcorpus_bundle'
enrich(.Object, p_attribute, decode = TRUE, verbose = FALSE)

flatten(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partition_bundle-class_+3A_object">object</code></td>
<td>
<p>A <code>partition_bundle</code> object.</p>
</td></tr>
<tr><td><code id="partition_bundle-class_+3A_progress">progress</code></td>
<td>
<p>A <code>logical</code> value, whether to show progress bar.</p>
</td></tr>
<tr><td><code id="partition_bundle-class_+3A_x">x</code></td>
<td>
<p>A <code>partition_bundle</code> object.</p>
</td></tr>
<tr><td><code id="partition_bundle-class_+3A_name">name</code></td>
<td>
<p>the name for the new partition</p>
</td></tr>
<tr><td><code id="partition_bundle-class_+3A_verbose">verbose</code></td>
<td>
<p>A <code>logical</code> value, whether to show progress messages.</p>
</td></tr>
<tr><td><code id="partition_bundle-class_+3A_height">height</code></td>
<td>
<p>height</p>
</td></tr>
<tr><td><code id="partition_bundle-class_+3A_...">...</code></td>
<td>
<p>further parameters</p>
</td></tr>
<tr><td><code id="partition_bundle-class_+3A_.object">.Object</code></td>
<td>
<p>A <code>partition_bundle</code> object.</p>
</td></tr>
<tr><td><code id="partition_bundle-class_+3A_p_attribute">p_attribute</code></td>
<td>
<p>A <code>character</code> vector with p-attribute(s) for counting.</p>
</td></tr>
<tr><td><code id="partition_bundle-class_+3A_decode">decode</code></td>
<td>
<p>A <code>logical</code> value, whether to turn token ids into decoded
strings.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>merge</code>-method aggregates several partitions into one partition. The
prerequisite for this function to work properly is that there are no
overlaps of the different partitions that are to be summarized.
Encodings and the root node need to be identical, too.
</p>
<p>The <code>enrich()</code> method will fill the slot <code>stat</code> of the <code>partition</code>
objects within the bundle with a count for the designated p-attributes. If
<code>.Object</code> is a <code>subcorpus_bundle</code>, the output class will be a
<code>partition_bundle</code>.
</p>


<h3>Value</h3>

<p>An object of the class 'partition. See partition for the
details on the class.
</p>
<p>a <code>partition_bundle</code> object
</p>


<h3>Slots</h3>


<dl>
<dt><code>objects</code></dt><dd><p>Object of class <code>list</code> the partitions making up the bundle</p>
</dd>
<dt><code>corpus</code></dt><dd><p>Object of class <code>character</code> the CWB corpus the partition is based on</p>
</dd>
<dt><code>s_attributes_fixed</code></dt><dd><p>Object of class <code>list</code> fixed s-attributes</p>
</dd>
<dt><code>encoding</code></dt><dd><p>Object of class <code>character</code> encoding of the corpus</p>
</dd>
<dt><code>explanation</code></dt><dd><p>Object of class <code>character</code> an explanation of the partition</p>
</dd>
<dt><code>xml</code></dt><dd><p>Object of class <code>character</code> whether the xml is flat or nested</p>
</dd>
<dt><code>call</code></dt><dd><p>Object of class <code>character</code> the call that generated the <code>partition_bundle</code></p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Andreas Blaette
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# merge partition_bundle into one partition
gparl &lt;- corpus("GERMAPARLMINI") %&gt;%
  split(s_attribute = "date") %&gt;% 
  merge()
use(pkg = "RcppCWB", corpus = "REUTERS")

pb &lt;- partition_bundle("REUTERS", s_attribute = "id")
barplot(pb, las = 2)

sc &lt;- corpus("GERMAPARLMINI") %&gt;%
  subset(date == "2009-11-10") %&gt;%
  split(s_attribute = "speaker") %&gt;%
  barplot(las = 2)
</code></pre>

<hr>
<h2 id='partition_class'>Partition class and methods.</h2><span id='topic+partition_class'></span><span id='topic+partition-class'></span><span id='topic+show+2Cpartition-method'></span><span id='topic++5B+2Cpartition+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+2Cpartition-method'></span><span id='topic+as.partition_bundle'></span><span id='topic+as.partition_bundle+2Cpartition-method'></span><span id='topic+export'></span><span id='topic+export+2Cpartition-method'></span><span id='topic+split'></span><span id='topic+remote_partition-class'></span><span id='topic+plpr_partition-class'></span><span id='topic+press_partition-class'></span><span id='topic+p_attributes+2Cpartition-method'></span><span id='topic+p_attributes+2Csubcorpus-method'></span><span id='topic+is.partition'></span><span id='topic+enrich+2Cpartition-method'></span><span id='topic+as.regions+2Cpartition-method'></span><span id='topic+split+2Cpartition-method'></span>

<h3>Description</h3>

<p>The <code>partition</code> class is used to manage subcorpora. It is an S4 class, and
a set of methods is defined for the class. The class inherits
from the classes <code>count</code> and <code>textstat</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'partition'
p_attributes(.Object, p_attribute = NULL, decode = TRUE)

## S4 method for signature 'subcorpus'
p_attributes(.Object, p_attribute = NULL, decode = TRUE)

is.partition(x)

## S4 method for signature 'partition'
enrich(
  .Object,
  p_attribute = NULL,
  decode = TRUE,
  verbose = TRUE,
  mc = FALSE,
  ...
)

## S4 method for signature 'partition'
as.regions(x)

## S4 method for signature 'partition'
split(x, gap, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partition_class_+3A_.object">.Object</code></td>
<td>
<p>A <code>partition</code> object.</p>
</td></tr>
<tr><td><code id="partition_class_+3A_p_attribute">p_attribute</code></td>
<td>
<p>a p-attribute (for enriching) / performing count.</p>
</td></tr>
<tr><td><code id="partition_class_+3A_decode">decode</code></td>
<td>
<p><code>logical</code> value, whether to decode token ids into strings when performing count</p>
</td></tr>
<tr><td><code id="partition_class_+3A_x">x</code></td>
<td>
<p>A <code>partition</code> object.</p>
</td></tr>
<tr><td><code id="partition_class_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> value, whether to output messages</p>
</td></tr>
<tr><td><code id="partition_class_+3A_mc">mc</code></td>
<td>
<p><code>logical</code> or, if numeric, providing the number of cores</p>
</td></tr>
<tr><td><code id="partition_class_+3A_...">...</code></td>
<td>
<p>further parameters passed into <code>count</code> when calling <code>enrich</code>, and ...</p>
</td></tr>
<tr><td><code id="partition_class_+3A_gap">gap</code></td>
<td>
<p>An integer value specifying the minimum gap between regions for
performing the split.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As <code>partition</code> objects inherit from <code>count</code> and
<code>textstat</code> class, methods available are <code>view</code> to inspect the
table in the <code>stat</code> slot, <code>name</code> and <code style="white-space: pre;">&#8288;name&lt;-&#8288;</code> to
retrieve/set the name of an object, and more.
</p>
<p>The <code>is.partition</code> function returns a <code>logical</code> value
whether <code>x</code> is a <code>partition</code>, or not.
</p>
<p>The <code>enrich</code>-method will add a count of tokens defined by argument
<code>p_attribute</code> to slot <code>stat</code> of the <code>partition</code> object.
</p>
<p>The <code>split()</code>-method will split a partition object into a
<code>partition_bundle</code> if gap between strucs exceeds a minimum number of tokens
specified by <code>gap</code>. Relevant to split up a plenary protocol into speeches.
Note: To speed things up, the returned partitions will not include
frequency lists. The lists can be prepared by applying <code>enrich</code> on the
<code>partition_bundle</code> object that is returned.
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code></dt><dd><p>A name to identify the object (<code>character</code> vector with length 1); useful when multiple
<code>partition</code> objects are combined to a <code>partition_bundle</code>.</p>
</dd>
<dt><code>corpus</code></dt><dd><p>The CWB indexed corpus the partition is derived from (<code>character</code> vector with length 1).</p>
</dd>
<dt><code>encoding</code></dt><dd><p>Encoding of the corpus (<code>character</code> vector with length 1).</p>
</dd>
<dt><code>s_attributes</code></dt><dd><p>A named <code>list</code> with the s-attributes specifying the partition.</p>
</dd>
<dt><code>explanation</code></dt><dd><p>Object of class <code>character</code>, an explanation of the partition.</p>
</dd>
<dt><code>cpos</code></dt><dd><p>A <code>matrix</code> with left and right corpus positions defining regions (two columns).</p>
</dd>
<dt><code>annotations</code></dt><dd><p>Object of class <code>list</code>.</p>
</dd>
<dt><code>size</code></dt><dd><p>Total size of the partition (<code>integer</code> vector, length 1).</p>
</dd>
<dt><code>stat</code></dt><dd><p>An (optional) <code>data.table</code> with counts. If present, speeds up computation of cooccurrences,
as count is already present.</p>
</dd>
<dt><code>metadata</code></dt><dd><p>Object of class <code>data.frame</code>, metadata information.</p>
</dd>
<dt><code>strucs</code></dt><dd><p>Object of class <code>integer</code>, the strucs defining the partition.</p>
</dd>
<dt><code>p_attribute</code></dt><dd><p>Object of class <code>character</code> indicating the p_attribute of the
count in slot <code>stat</code>.</p>
</dd>
<dt><code>xml</code></dt><dd><p>Object of class <code>character</code>, whether the xml is flat or nested.</p>
</dd>
<dt><code>s_attribute_strucs</code></dt><dd><p>Object of class <code>character</code> the base node</p>
</dd>
<dt><code>key</code></dt><dd><p>Experimental, an s-attribute that is used as a key.</p>
</dd>
<dt><code>call</code></dt><dd><p>Object of class <code>character</code> the call that generated the partition</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Andreas Blaette
</p>


<h3>See Also</h3>

<p>The <code>partition</code>-class inherits from the
<code><a href="#topic+textstat-class">textstat-class</a></code>, see respective documentation to learn more.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- partition(
  "GERMAPARLMINI",
  date = "2009-11-11",
  speaker = "Norbert Lammert"
 )
name(p) &lt;- "Norbert Lammert"
pb &lt;- split(p, gap = 500L)
summary(pb)
</code></pre>

<hr>
<h2 id='partition_to_string'>Decode as String.</h2><span id='topic+partition_to_string'></span>

<h3>Description</h3>

<p>Decode as String.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>corpus("REUTERS") %&gt;% 
  subset(id == "127") %&gt;% 
  as("String")
</code></pre>

<hr>
<h2 id='phrases-class'>Manage and use phrases</h2><span id='topic+phrases-class'></span><span id='topic+as.phrases+2Cngrams-method'></span><span id='topic+phrases'></span><span id='topic+as.phrases'></span><span id='topic+as.phrases+2Cmatrix-method'></span><span id='topic+as.character+2Cphrases-method'></span><span id='topic+concatenate_phrases'></span>

<h3>Description</h3>

<p>Class, methods and functionality for processing phrases (lexical
units, lexical items, multi-word expressions) beyond the token level. The
envisaged workflow at this stage is to detect phrases using the
<code>ngrams</code>-method and to generate a <code>phrases</code> class object from the
<code>ngrams</code> object using the <code>as.phrases</code> method. This object can be
passed into a call of <code>count</code>, see examples. Further methods and
functions documented here are used internally, but may be useful.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ngrams'
as.phrases(.Object)

## S4 method for signature 'matrix'
as.phrases(.Object, corpus, enc = encoding(corpus))

## S4 method for signature 'phrases'
as.character(x, p_attribute)

concatenate_phrases(dt, phrases, col)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phrases-class_+3A_.object">.Object</code></td>
<td>
<p>Input object, either a <code>ngrams</code> or a <code>matrix</code> object.</p>
</td></tr>
<tr><td><code id="phrases-class_+3A_corpus">corpus</code></td>
<td>
<p>A length-one <code>character</code> vector, the corpus ID of the corpus
from which regions / the <code>data.table</code> representing a decoded corpus is derived.</p>
</td></tr>
<tr><td><code id="phrases-class_+3A_enc">enc</code></td>
<td>
<p>Encoding of the corpus.</p>
</td></tr>
<tr><td><code id="phrases-class_+3A_x">x</code></td>
<td>
<p>A <code>phrases</code> class object.</p>
</td></tr>
<tr><td><code id="phrases-class_+3A_p_attribute">p_attribute</code></td>
<td>
<p>The positional attribute (p-attribute) to decode.</p>
</td></tr>
<tr><td><code id="phrases-class_+3A_dt">dt</code></td>
<td>
<p>A <code>data.table</code>.</p>
</td></tr>
<tr><td><code id="phrases-class_+3A_phrases">phrases</code></td>
<td>
<p>A <code>phrases</code> class object.</p>
</td></tr>
<tr><td><code id="phrases-class_+3A_col">col</code></td>
<td>
<p>If <code>.Object</code> is a <code>data.table</code>, the column to concatenate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>phrases</code> considers a phrase as sequence as tokens that can
be defined by region, i.e. a left and a right corpus position. This
information is kept in a region matrix in the slot &quot;cpos&quot; of the
<code>phrases</code> class. The <code>phrases</code> class inherits from the
<code><a href="#topic+regions">regions</a></code> class (which inherits from the and the
<code><a href="#topic+corpus">corpus</a></code> class), without adding further slots.
</p>
<p>If <code>.Object</code> is an object of class <code>ngrams</code>, the
<code>as.phrases()</code>-method will interpret the ngrams as CQP queries,
look up the matching corpus positions and return an <code>phrases</code>
object.
</p>
<p>If <code>.Object</code> is a <code>matrix</code>, the <code>as.phrases()</code>-method will
initialize a <code>phrases</code> object. The corpus and the encoding of the corpus
will be assigned to the object.
</p>
<p>Applying the <code>as.character</code>-method on a <code>phrases</code> object
will return the decoded regions, concatenated using an underscore as
seperator.
</p>
<p>The <code>concatenate_phrases</code> function takes a <code>data.table</code>
(argument <code>dt</code>) as input and concatenates phrases in successive rows
into a phrase.
</p>


<h3>See Also</h3>

<p>Other classes to manage corpora: 
<code><a href="#topic+corpus-class">corpus-class</a></code>,
<code><a href="#topic+ranges-class">ranges-class</a></code>,
<code><a href="#topic+regions">regions</a></code>,
<code><a href="#topic+subcorpus">subcorpus</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Workflow to create document-term-matrix with phrases

obs &lt;- corpus("GERMAPARLMINI") %&gt;%
  count(p_attribute = "word")

phrases &lt;- corpus("GERMAPARLMINI") %&gt;%
  ngrams(n = 2L, p_attribute = "word") %&gt;%
  pmi(observed = obs) %&gt;% 
  subset(ngram_count &gt; 5L) %&gt;%
  subset(1:100) %&gt;%
  as.phrases()

dtm &lt;- corpus("GERMAPARLMINI") %&gt;%
  as.speeches(s_attribute_name = "speaker", s_attribute_date = "date", progress = TRUE) %&gt;%
  count(phrases = phrases, p_attribute = "word", progress = TRUE, verbose = TRUE) %&gt;%
  as.DocumentTermMatrix(col = "count", verbose = FALSE)
  
grep("erneuerbaren_Energien", colnames(dtm))
grep("verpasste_Chancen", colnames(dtm))

## End(Not run)
## Not run: 
use(pkg = "RcppCWB", corpus = "REUTERS")

# Derive phrases object from an ngrams object

reuters_phrases &lt;- ngrams("REUTERS", p_attribute = "word", n = 2L) %&gt;%
  pmi(observed = count("REUTERS", p_attribute = "word")) %&gt;%
  subset(ngram_count &gt;= 5L) %&gt;%
  subset(1:25) %&gt;%
  as.phrases()

phr &lt;- as.character(reuters_phrases, p_attribute = "word")

## End(Not run)
# Derive phrases from explicitly stated CQP queries

## Not run: 
cqp_phrase_queries &lt;- c(
  '"oil" "revenue";',
  '"Sheikh" "Aziz";',
  '"Abdul" "Aziz";',
  '"Saudi" "Arabia";',
  '"oil" "markets";'
)
reuters_phrases &lt;- cpos("REUTERS", cqp_phrase_queries, p_attribute = "word") %&gt;%
  as.phrases(corpus = "REUTERS", enc = "latin1")

## End(Not run)
  
# Use the concatenate_phrases() function on a data.table

## Not run: 
#' lexical_units_cqp &lt;- c(
  '"Deutsche.*" "Bundestag.*";',
  '"sozial.*" "Gerechtigkeit";',
  '"Ausschuss" "f.r" "Arbeit" "und" "Soziales";',
  '"soziale.*" "Marktwirtschaft";',
  '"freiheitliche.*" "Grundordnung";'
)

phr &lt;- cpos("GERMAPARLMINI", query = lexical_units_cqp, cqp = TRUE) %&gt;%
  as.phrases(corpus = "GERMAPARLMINI", enc = "word")

dt &lt;- corpus("GERMAPARLMINI") %&gt;%
  decode(p_attribute = "word", s_attribute = character(), to = "data.table") %&gt;%
  concatenate_phrases(phrases = phr, col = "word")
  
dt[word == "Deutschen_Bundestag"]
dt[word == "soziale_Marktwirtschaft"]

## End(Not run)  

</code></pre>

<hr>
<h2 id='pmi'>Calculate Pointwise Mutual Information (PMI).</h2><span id='topic+pmi'></span><span id='topic+pmi+2Ccontext-method'></span><span id='topic+pmi+2CCooccurrences-method'></span><span id='topic+pmi+2Cngrams-method'></span>

<h3>Description</h3>

<p>Calculate Pointwise Mutual Information as an information-theoretic approach
to find collocations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pmi(.Object, ...)

## S4 method for signature 'context'
pmi(.Object)

## S4 method for signature 'Cooccurrences'
pmi(.Object)

## S4 method for signature 'ngrams'
pmi(.Object, observed, p_attribute = p_attributes(.Object)[1])
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pmi_+3A_.object">.Object</code></td>
<td>
<p>An object.</p>
</td></tr>
<tr><td><code id="pmi_+3A_...">...</code></td>
<td>
<p>Arguments methods may require.</p>
</td></tr>
<tr><td><code id="pmi_+3A_observed">observed</code></td>
<td>
<p>A <code>count</code>-object with the numbers of the observed
occurrences of the tokens in the input <code>ngrams</code> object.</p>
</td></tr>
<tr><td><code id="pmi_+3A_p_attribute">p_attribute</code></td>
<td>
<p>The positional attribute which shall be considered. Relevant only
if ngrams have been calculated for more than one p-attribute.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Pointwise mutual information (PMI) is calculated as follows (see
Manning/Schuetze 1999):
</p>
<p style="text-align: center;"><code class="reqn">I(x,y) = log\frac{p(x,y)}{p(x)p(y)}</code>
</p>

<p>The formula is based on maximum likelihood estimates: When we know the number
of observations for token x, <code class="reqn">o_{x}</code>, the number of observations
for token y, <code class="reqn">o_{y}</code> and the size of the corpus N, the
propabilities for the tokens x and y, and for the co-occcurence of x and y
are as follows:
</p>
<p style="text-align: center;"><code class="reqn">p(x) = \frac{o_{x}}{N}</code>
</p>

<p style="text-align: center;"><code class="reqn">p(y) = \frac{o_{y}}{N}</code>
</p>

<p>The term p(x,y) is the number of observed co-occurrences of x and y.
</p>
<p>Note that the computation uses log base 2, not the natural logarithm you find
in examples (e.g. <a href="https://en.wikipedia.org/wiki/Pointwise_mutual_information">https://en.wikipedia.org/wiki/Pointwise_mutual_information</a>).
</p>


<h3>References</h3>

<p>Manning, Christopher D.; Schuetze, Hinrich (1999): <em>Foundations of Statistical Natural Language
Processing</em>. MIT Press: Cambridge, Mass., pp. 178-183.
</p>


<h3>See Also</h3>

<p>Other statistical methods: 
<code><a href="#topic+chisquare">chisquare</a>()</code>,
<code><a href="#topic+ll">ll</a>()</code>,
<code><a href="#topic+t_test">t_test</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- cooccurrences("REUTERS", query = "oil", method = "pmi")
N &lt;- size(y)[["partition"]]
I &lt;- log2((y[["count_coi"]]/N) / ((count(y) / N) * (y[["count_partition"]] / N)))
use("polmineR")
use(pkg = "RcppCWB", corpus = "REUTERS")

dt &lt;- decode(
  "REUTERS",
  p_attribute = "word",
  s_attribute = character(), 
  to = "data.table",
  verbose = FALSE
)
n &lt;- ngrams(dt, n = 2L, p_attribute = "word")
obs &lt;- count("REUTERS", p_attribute = "word")
phrases &lt;- pmi(n, observed = obs)
</code></pre>

<hr>
<h2 id='polmineR-defunct'>Defunct functionality</h2><span id='topic+polmineR-defunct'></span><span id='topic+mail'></span><span id='topic+browse'></span>

<h3>Description</h3>

<p>Methods and functions not in use any more or that have been
superseded by renamed functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mail(...)

browse(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="polmineR-defunct_+3A_...">...</code></td>
<td>
<p>Any arguments that may be passed into the defunct function/method.</p>
</td></tr>
</table>

<hr>
<h2 id='polmineR-generics'>Generic methods defined in the polmineR package</h2><span id='topic+polmineR-generics'></span><span id='topic+get_info'></span><span id='topic+show_info'></span>

<h3>Description</h3>

<p>This documentation object gives an overview over the generic
methods defined in the polmineR package that have no individual man page
but are documented directly with the classes they are defined for.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_info(x)

show_info(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="polmineR-generics_+3A_x">x</code></td>
<td>
<p>An S4 class object.</p>
</td></tr>
</table>

<hr>
<h2 id='ranges'>Get ranges for query.</h2><span id='topic+ranges'></span><span id='topic+ranges+2Ccorpus-method'></span><span id='topic+ranges+2Ccharacter-method'></span><span id='topic+ranges+2Csubcorpus-method'></span><span id='topic+ranges+2Cpartition-method'></span>

<h3>Description</h3>

<p>Get ranges (pairs of left and right corpus positions) for queries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ranges(.Object, ...)

## S4 method for signature 'corpus'
ranges(
  .Object,
  query,
  cqp = FALSE,
  check = TRUE,
  p_attribute = "word",
  verbose = TRUE,
  mc = 1L,
  progress = FALSE
)

## S4 method for signature 'character'
ranges(
  .Object,
  query,
  cqp = FALSE,
  check = TRUE,
  p_attribute = "word",
  verbose = TRUE,
  mc = 1L,
  progress = FALSE
)

## S4 method for signature 'subcorpus'
ranges(
  .Object,
  query,
  cqp = FALSE,
  check = TRUE,
  p_attribute = "word",
  verbose = TRUE,
  mc = 1L,
  progress = FALSE
)

## S4 method for signature 'partition'
ranges(
  .Object,
  query,
  cqp = FALSE,
  check = TRUE,
  p_attribute = "word",
  verbose = TRUE,
  mc = 1L,
  progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ranges_+3A_.object">.Object</code></td>
<td>
<p>A length-one <code>character</code> vector indicating a CWB corpus, or a
<code>corpus</code>, or <code>partition</code> object.</p>
</td></tr>
<tr><td><code id="ranges_+3A_...">...</code></td>
<td>
<p>Used for reasons of backwards compatibility to
process arguments that have been renamed (e.g. <code>pAttribute</code>).</p>
</td></tr>
<tr><td><code id="ranges_+3A_query">query</code></td>
<td>
<p>A <code>character</code> vector providing one or multiple queries (token to
look up, regular expression or CQP query). Token ids (i.e. <code>integer</code>
values) are also accepted. If <code>query</code> is neither a regular expression nor a
CQP query, a sanity check removes accidental leading/trailing whitespace,
issuing a respective warning.</p>
</td></tr>
<tr><td><code id="ranges_+3A_cqp">cqp</code></td>
<td>
<p>Either logical (<code>TRUE</code> if query is a CQP query), or a function to
check whether query is a CQP query or not (defaults to <code>is.cqp</code> auxiliary
function).</p>
</td></tr>
<tr><td><code id="ranges_+3A_check">check</code></td>
<td>
<p>A <code>logical</code> value, whether to check validity of CQP query
using <code>check_cqp_query</code>.</p>
</td></tr>
<tr><td><code id="ranges_+3A_p_attribute">p_attribute</code></td>
<td>
<p>The p-attribute to search. Needs to be stated only if query
is not a CQP query. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="ranges_+3A_verbose">verbose</code></td>
<td>
<p>A <code>logical</code> value, whether to show messages.</p>
</td></tr>
<tr><td><code id="ranges_+3A_mc">mc</code></td>
<td>
<p>If <code>logical</code> value <code>TRUE</code>, the value of
<code>getOption("polmineR.cores")</code> is passed into <code>mclapply</code> or
<code>pblapply</code> as the specification of the number of cores to use. It is
also possible to supply an integer value with the number of cores directly.
Defaults to 1 (no multicore). Relevant only if several queries are to be
processed.</p>
</td></tr>
<tr><td><code id="ranges_+3A_progress">progress</code></td>
<td>
<p>A <code>logical</code> value, whether to show a progess bar when
processing multiple queries.</p>
</td></tr>
</table>

<hr>
<h2 id='ranges-class'>Ranges of query matches.</h2><span id='topic+ranges-class'></span><span id='topic+as.data.table.ranges'></span>

<h3>Description</h3>

<p>S4 class to manage ranges of corpus positions for query matches. The class
inherits from the classes <code>regions</code> and <code>corpus</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ranges'
as.data.table(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ranges-class_+3A_x">x</code></td>
<td>
<p>A <code>ranges</code> class object.</p>
</td></tr>
<tr><td><code id="ranges-class_+3A_...">...</code></td>
<td>
<p>Additional arguments (unused).</p>
</td></tr>
</table>


<h3>Slots</h3>


<dl>
<dt><code>query</code></dt><dd><p>A length-one <code>character</code> string, query used for query
matches.</p>
</dd>
</dl>


<h3>See Also</h3>

<p>Other classes to manage corpora: 
<code><a href="#topic+corpus-class">corpus-class</a></code>,
<code><a href="#topic+phrases-class">phrases-class</a></code>,
<code><a href="#topic+regions">regions</a></code>,
<code><a href="#topic+subcorpus">subcorpus</a></code>
</p>

<hr>
<h2 id='read'>Display full text.</h2><span id='topic+read'></span><span id='topic+read+2Cpartition-method'></span><span id='topic+read+2Csubcorpus-method'></span><span id='topic+read+2Cpartition_bundle-method'></span><span id='topic+read+2Cdata.table-method'></span><span id='topic+read+2Chits-method'></span><span id='topic+read+2Ckwic-method'></span><span id='topic+read+2Cregions-method'></span>

<h3>Description</h3>

<p>Generate text (i.e. html) and display it in the viewer pane of RStudio for
reading it. If called on a <code>partition_bundle</code>-object, skip through the
partitions contained in the bundle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read(.Object, ...)

## S4 method for signature 'partition'
read(
  .Object,
  meta = NULL,
  highlight = list(),
  tooltips = list(),
  href = list(),
  verbose = TRUE,
  cpos = TRUE,
  cutoff = getOption("polmineR.cutoff"),
  template = get_template(.Object),
  ...
)

## S4 method for signature 'subcorpus'
read(
  .Object,
  meta = NULL,
  highlight = list(),
  tooltips = list(),
  href = list(),
  annotation,
  verbose = TRUE,
  cpos = TRUE,
  cutoff = getOption("polmineR.cutoff"),
  template = get_template(.Object),
  ...
)

## S4 method for signature 'partition_bundle'
read(.Object, highlight = list(), cpos = TRUE, ...)

## S4 method for signature 'data.table'
read(.Object, col, partition_bundle, highlight = list(), cpos = FALSE, ...)

## S4 method for signature 'hits'
read(.Object, def, i = NULL, ...)

## S4 method for signature 'kwic'
read(.Object, i = NULL, type)

## S4 method for signature 'regions'
read(.Object, meta = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_+3A_.object">.Object</code></td>
<td>
<p>aAn object to be read (<code>partition</code> or <code>partition_bundle</code>).</p>
</td></tr>
<tr><td><code id="read_+3A_...">...</code></td>
<td>
<p>Further parameters passed into <code>read()</code>.</p>
</td></tr>
<tr><td><code id="read_+3A_meta">meta</code></td>
<td>
<p>a character vector supplying s-attributes for the metainformation
to be printed; if not stated explicitly, session settings will be used</p>
</td></tr>
<tr><td><code id="read_+3A_highlight">highlight</code></td>
<td>
<p>a named list of character vectors (see details)</p>
</td></tr>
<tr><td><code id="read_+3A_tooltips">tooltips</code></td>
<td>
<p>a named list (names are colors, vectors are tooltips)</p>
</td></tr>
<tr><td><code id="read_+3A_href">href</code></td>
<td>
<p>A named <code>list</code> with hypertext references that will be inserted as
attribute href of a elements. The names of the list are either colors of
highlighted text that has been generated previously, or corpus positions.</p>
</td></tr>
<tr><td><code id="read_+3A_verbose">verbose</code></td>
<td>
<p>logical</p>
</td></tr>
<tr><td><code id="read_+3A_cpos">cpos</code></td>
<td>
<p>logical, if <code>TRUE</code>, corpus positions will be assigned (invisibly)
to a cpos tag of a html element surrounding the tokens</p>
</td></tr>
<tr><td><code id="read_+3A_cutoff">cutoff</code></td>
<td>
<p>maximum number of tokens to display</p>
</td></tr>
<tr><td><code id="read_+3A_template">template</code></td>
<td>
<p>template to format output</p>
</td></tr>
<tr><td><code id="read_+3A_annotation">annotation</code></td>
<td>
<p>Object inheriting from <code>subcorpus</code> class. If provided,
<code>highlight</code>, <code>tooltips</code> and <code>href</code> will be taken from the slot 'annotations'
of this object.</p>
</td></tr>
<tr><td><code id="read_+3A_col">col</code></td>
<td>
<p>column of <code>data.table</code> with terms to be highlighted</p>
</td></tr>
<tr><td><code id="read_+3A_partition_bundle">partition_bundle</code></td>
<td>
<p>A <code>partition_bundle</code> object.</p>
</td></tr>
<tr><td><code id="read_+3A_def">def</code></td>
<td>
<p>a named list used to define a partition (names are s-attributes,
vectors are values of s-attributes)</p>
</td></tr>
<tr><td><code id="read_+3A_i">i</code></td>
<td>
<p>If <code>.Object</code> is an object of the classes <code>kwic</code> or <code>hits</code>, the ith
kwic line or hit to derive a partition to be inspected from</p>
</td></tr>
<tr><td><code id="read_+3A_type">type</code></td>
<td>
<p>the partition type, see documentation for <code>partition()</code>-method</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To prepare the html output, the method <code>read()</code> will call <code>html()</code> and
<code>as.markdown()</code> subsequently, the latter method being the actual worker.
Consult these methods to understand how preparing the output works.
</p>
<p>The param <code>highlight()</code> can be used to highlight terms. It is expected to
be a named list of character vectors, the names providing the colors, and the
vectors the terms to be highlighted. To add tooltips, use the param
<code>tooltips</code>.
</p>
<p>The method <code>read()</code> is a high-level function that calls the methods
mentioned before. Results obtained through <code>read()</code> can also be obtained
through combining these methods in a pipe using the package 'magrittr'.
That may offer more flexibility, e.g. to highlight matches for CQP queries.
See examples and the documentation for the different methods to learn more.
</p>


<h3>See Also</h3>

<p>For concordances / a keword-in-context display, see <code><a href="#topic+kwic">kwic</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>use("polmineR")
merkel &lt;- partition("GERMAPARLMINI", date = "2009-11-10", speaker = "Merkel", regex = TRUE)
if (interactive()) read(merkel, meta = c("speaker", "date"))
if (interactive()) read(
  merkel,
  highlight = list(yellow = c("Deutschland", "Bundesrepublik"), lightgreen = "Regierung"),
  meta = c("speaker", "date")
)

## Not run: 
pb &lt;- as.speeches("GERMAPARLMINI", s_attribute_date = "date", s_attribute_name = "speaker")
pb &lt;- pb[[ data.table::as.data.table(summary(pb))[size &gt;= 500][["name"]] ]]
pb &lt;- pb[[ 1:10 ]]
read(pb)

## End(Not run)
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic++25+3E+25'></span><span id='topic+as.data.table'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>data.table</dt><dd><p><code><a href="data.table.html#topic+as.data.table">as.data.table</a></code></p>
</dd>
<dt>magrittr</dt><dd><p><code><a href="magrittr.html#topic+pipe">%&gt;%</a></code></p>
</dd>
</dl>

<hr>
<h2 id='regions'>Regions of a CWB corpus.</h2><span id='topic+regions'></span><span id='topic+regions-class'></span><span id='topic+regions+2Ccorpus-method'></span><span id='topic+regions+2Csubcorpus-method'></span><span id='topic+as.regions'></span><span id='topic+as.data.table.regions'></span>

<h3>Description</h3>

<p>Class to store and process the regions of a corpus. Regions are defined by
start and end corpus positions and correspond to a set of tokens surrounded
by start and end XML tags.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regions(x, s_attribute)

## S4 method for signature 'corpus'
regions(x, s_attribute)

## S4 method for signature 'subcorpus'
regions(x, s_attribute)

as.regions(x, ...)

## S3 method for class 'regions'
as.data.table(x, keep.rownames, values = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regions_+3A_x">x</code></td>
<td>
<p>object of class <code>regions</code></p>
</td></tr>
<tr><td><code id="regions_+3A_s_attribute">s_attribute</code></td>
<td>
<p>An s-attribute denoted by a length-one <code>character</code> vector
for which regions shall be derived.</p>
</td></tr>
<tr><td><code id="regions_+3A_...">...</code></td>
<td>
<p>Further arguments.</p>
</td></tr>
<tr><td><code id="regions_+3A_keep.rownames">keep.rownames</code></td>
<td>
<p>Required argument to safeguard consistency with S3
method definition in the <code>data.table</code> package. Unused in this context.</p>
</td></tr>
<tr><td><code id="regions_+3A_values">values</code></td>
<td>
<p>values to assign to a column that will be added</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>regions</code> class is a minimal representation of regions and does not
include information on the &quot;strucs&quot; (region IDs) that are used internally to
obtain values of s-attributes or information, which combination of conditions
on s-attributes has been used to obtain regions. This is left to the
<code>subcorpus</code> corpus class. Whereas the <code>subcorpus</code> class is associated with
the assumption, that a set of regions is a meaningful sub-unit of a corpus,
the <code>regions</code> class has a focus on the individual sequences of tokens defined
by a structural attribute (such as paragraphs, sentences, named entities).
</p>
<p>Information on regions is maintained in the <code>cpos</code> slot of the <code>regions</code> S4
class: A two-column <code>matrix</code> with begin and end corpus positions (first and
second column, respectively). All other slots are inherited from the <code>corpus</code>
class.
</p>
<p>The understanding of &quot;regions&quot; is modelled on the usage of terms by CWB
developers. As it is put in the
<a href="https://cwb.sourceforge.io/files/CQP_Manual.pdf">CQP Interface and
Query Language Manual</a>: &quot;Matching pairs of XML start and end tags are encoded
as token regions, identified by the corpus positions of the first token
(immediately following the start tag) and the last token (immediately
preceding the end tag) of the region.&quot; (p. 6)
</p>
<p>The <code>as.regions</code>-method coerces objects to a <code>regions</code>-object.
</p>
<p>The <code>as.data.table</code> method returns the matrix with corpus
positions in the slot <code>cpos</code> as a <code>data.table</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>cpos</code></dt><dd><p>A two-column <code>matrix</code> with start and end corpus positions (first
and second column, respectively).</p>
</dd>
</dl>


<h3>See Also</h3>

<p>Other classes to manage corpora: 
<code><a href="#topic+corpus-class">corpus-class</a></code>,
<code><a href="#topic+phrases-class">phrases-class</a></code>,
<code><a href="#topic+ranges-class">ranges-class</a></code>,
<code><a href="#topic+subcorpus">subcorpus</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>use("polmineR")
P &lt;- partition("GERMAPARLMINI", date = "2009-11-12", speaker = "Jens Spahn")
R &lt;- as.regions(P)
use(pkg = "RcppCWB", corpus = "REUTERS")

# Get regions matrix as data.table, without / with values
sc &lt;- corpus("REUTERS") %&gt;% subset(grep("saudi-arabia", places))
regions_dt &lt;- as.data.table(sc)
regions_dt &lt;- as.data.table(
  sc,
  values = s_attributes(sc, "id", unique = FALSE)
)
</code></pre>

<hr>
<h2 id='registry_get_name'>Evaluate registry file.</h2><span id='topic+registry_get_name'></span><span id='topic+registry_get_id'></span><span id='topic+registry_get_home'></span><span id='topic+registry_get_info'></span><span id='topic+registry_get_encoding'></span><span id='topic+registry_get_p_attributes'></span><span id='topic+registry_get_s_attributes'></span><span id='topic+registry_get_properties'></span>

<h3>Description</h3>

<p>Functions to extract information from a registry file describing a corpus.
Several operations could be accomplished with the 'cwb-regedit' tool, the
functions defined here ensure that manipulating the registry is possible
without a full installation of the CWB.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>registry_get_name(corpus, registry = Sys.getenv("CORPUS_REGISTRY"))

registry_get_id(corpus, registry = Sys.getenv("CORPUS_REGISTRY"))

registry_get_home(corpus, registry = Sys.getenv("CORPUS_REGISTRY"))

registry_get_info(corpus, registry = Sys.getenv("CORPUS_REGISTRY"))

registry_get_encoding(corpus, registry = Sys.getenv("CORPUS_REGISTRY"))

registry_get_p_attributes(corpus, registry = Sys.getenv("CORPUS_REGISTRY"))

registry_get_s_attributes(corpus, registry = Sys.getenv("CORPUS_REGISTRY"))

registry_get_properties(corpus, registry = Sys.getenv("CORPUS_REGISTRY"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="registry_get_name_+3A_corpus">corpus</code></td>
<td>
<p>name of the CWB corpus</p>
</td></tr>
<tr><td><code id="registry_get_name_+3A_registry">registry</code></td>
<td>
<p>directory of the registry (defaults to CORPUS_Registry environment variable)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An appendix to the 'Corpus Encoding Tutorial'
(https://cwb.sourceforge.io/files/CWB_Encoding_Tutorial.pdf) includes an
explanation of the registry file format.
</p>
<p><code>registry_get_encoding</code> will parse the registry file for a
corpus and return the encoding that is defined (corpus property &quot;charset&quot;).
If parsing the registry does not yield a result (corpus property &quot;charset&quot;
not defined), the CWB standard encoding (&quot;latin1&quot;) is assigned to prevent
errors. Note that <code>RcppCWB::cl_charset_name</code> is equivalent but is
faster as it uses the internal C representation of a corpus rather than
parsing the registry file.
</p>

<hr>
<h2 id='registry_move'>Get registry and data directories.</h2><span id='topic+registry_move'></span><span id='topic+registry'></span><span id='topic+data_dir'></span>

<h3>Description</h3>

<p>The Corpus Workbench (CWB) uses a registry directory with plain text files
describing corpora in a standardized format. The binary files of a corpus are
stored in a data directory defined in the registry directory. The
<code>registry</code> and <code>data_dir</code> functions return the respective
direcories within a package, if the argument <code>pkg</code> is used, or the
temporary registry and data directory in the per-session temporary directory,
if <code>pkg</code> is <code>NULL</code> (default value).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>registry_move(corpus, registry, registry_new, home_dir_new)

registry(pkg = NULL)

data_dir(pkg = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="registry_move_+3A_corpus">corpus</code></td>
<td>
<p>The ID of the corpus for which the registry file shall be moved.</p>
</td></tr>
<tr><td><code id="registry_move_+3A_registry">registry</code></td>
<td>
<p>The old registry directory.</p>
</td></tr>
<tr><td><code id="registry_move_+3A_registry_new">registry_new</code></td>
<td>
<p>The new registry directory.</p>
</td></tr>
<tr><td><code id="registry_move_+3A_home_dir_new">home_dir_new</code></td>
<td>
<p>The new home directory.</p>
</td></tr>
<tr><td><code id="registry_move_+3A_pkg">pkg</code></td>
<td>
<p>A character string with the name of a single package; if <code>NULL</code> (default),
the temporary registry and data directory is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>registry_move</code> is an auxiliary function to create a copy
of a registry file in the directory specified by the argument
<code>registry_new</code>.
</p>
<p>Upon loading the polmineR package, there is a check whether the
environment variable <code>CORPUS_REGISTRY</code> is defined. In case it is, the
registry files in the directory defined by the <code>CORPUS_REGISTRY</code>
environment variable are copied to the temporary registry directory, which
serves as the central place to store all registry files for all corpora, be
it system corpora, corpora included in R packages, or temporary corpora.
</p>
<p>The Corpus Workbench may have problems to cope with a registry path
that includes registry non-ASCII characters. On Windows, a call to
<code>utils::shortPathName</code> will generate the short MS-DOS path name that
circumvents resulting problems.
</p>
<p>Usage of the temporary registry directory can be suppress by setting
the environment variable POLMINER_USE_TMP_REGISTRY as 'false'. In this
case, the <code>registry</code> function will return the environment variable
CORPUS_REGISTRY unchanged. The <code>data_dir</code> function will return the
&quot;indexed_corpus&quot; directory that is assumed to live in the same parent
directory as the registry directory.
</p>


<h3>Value</h3>

<p>A path to a (registry or data) directory, or NULL, if package does not exist
or is not a package including a corpus.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>registry() # returns temporary registry directory
registry(pkg = "polmineR") # returns registry directory in polmineR-package

data_dir()
data_dir(pkg = "polmineR")
</code></pre>

<hr>
<h2 id='registry_reset'>Reset registry directory.</h2><span id='topic+registry_reset'></span>

<h3>Description</h3>

<p>A utility function to reset the environment variable CORPUS_REGISTRY. That may
be necessary if you want use a CWB corpus that is not stored in the usual
place. In particular, resetting the environment variable is required if you
want to use a corpus delivered in a R package,
</p>


<h3>Usage</h3>

<pre><code class='language-R'>registry_reset(registryDir = registry(), verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="registry_reset_+3A_registrydir">registryDir</code></td>
<td>
<p>path to the registry directory to be used</p>
</td></tr>
<tr><td><code id="registry_reset_+3A_verbose">verbose</code></td>
<td>
<p>logical, whether to be verbose</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Resetting the CORPUS_REGISTRY environment variable is also necessary for the
interface to CWB corpora.
</p>
<p>To get the path to a package that contains a CWB corpus, use
<code>system.file</code> (see examples).
</p>


<h3>Value</h3>

<p>the registry directory used before resetting CORPUS_REGISTRY
</p>


<h3>See Also</h3>

<p>To conveniently reset registry, see <code><a href="#topic+use">use</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- system.file(package = "polmineR", "extdata", "cwb", "registry")
registry_reset(registryDir = x)

## End(Not run)
</code></pre>

<hr>
<h2 id='renamed'>Renamed Functions</h2><span id='topic+renamed'></span><span id='topic+sAttributes'></span><span id='topic+pAttributes'></span><span id='topic+getTokenStream'></span><span id='topic+getTerms'></span><span id='topic+getEncoding'></span><span id='topic+partitionBundle'></span><span id='topic+as.partitionBundle'></span><span id='topic+corpus+2Ctextstat-method'></span><span id='topic+corpus+2Cbundle-method'></span><span id='topic+corpus+2Ckwic-method'></span>

<h3>Description</h3>

<p>These functions have been renamed in order to have a consistent coding style
that follows the snake_case convention. The &quot;old&quot; function still work to
maintain backwards compatiblity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sAttributes(...)

pAttributes(...)

getTokenStream(...)

getTerms(...)

getEncoding(...)

partitionBundle(...)

as.partitionBundle(...)

## S4 method for signature 'textstat'
corpus(.Object)

## S4 method for signature 'bundle'
corpus(.Object)

## S4 method for signature 'kwic'
corpus(.Object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="renamed_+3A_...">...</code></td>
<td>
<p>argument that are passed to the renamed function</p>
</td></tr>
<tr><td><code id="renamed_+3A_.object">.Object</code></td>
<td>
<p>A <code>kwic</code> object.</p>
</td></tr>
</table>

<hr>
<h2 id='s_attributes'>Get s-attributes.</h2><span id='topic+s_attributes'></span><span id='topic+s_attributes+2Ccharacter-method'></span><span id='topic+s_attributes+2Ccorpus-method'></span><span id='topic+s_attributes+2Cslice-method'></span><span id='topic+s_attributes+2Cpartition-method'></span><span id='topic+s_attributes+2Csubcorpus-method'></span><span id='topic+s_attributes+2Ccontext-method'></span><span id='topic+s_attributes+2Cpartition_bundle-method'></span><span id='topic+s_attributes+2Ccall-method'></span><span id='topic+s_attributes+2Cquosure-method'></span><span id='topic+s_attributes+2Cname-method'></span><span id='topic+s_attributes+2Cremote_corpus-method'></span><span id='topic+s_attributes+2Cremote_partition-method'></span><span id='topic+s_attributes+2Cdata.table-method'></span>

<h3>Description</h3>

<p>Structural annotations (s-attributes) of a corpus capture metainformation for
regions of tokens. The <code>s_attributes()</code>-method offers high-level access to
the s-attributes present in a <code>corpus</code> or <code>subcorpus</code>, or the values of
s-attributes in a <code>corpus</code>/<code>partition</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s_attributes(.Object, ...)

## S4 method for signature 'character'
s_attributes(.Object, s_attribute = NULL, unique = TRUE, regex = NULL, ...)

## S4 method for signature 'corpus'
s_attributes(.Object, s_attribute = NULL, unique = TRUE, regex = NULL, ...)

## S4 method for signature 'slice'
s_attributes(.Object, s_attribute = NULL, unique = TRUE, ...)

## S4 method for signature 'partition'
s_attributes(.Object, s_attribute = NULL, unique = TRUE, ...)

## S4 method for signature 'subcorpus'
s_attributes(.Object, s_attribute = NULL, unique = TRUE, ...)

## S4 method for signature 'context'
s_attributes(.Object, s_attribute = NULL)

## S4 method for signature 'partition_bundle'
s_attributes(.Object, s_attribute, unique = TRUE, ...)

## S4 method for signature 'call'
s_attributes(.Object, corpus)

## S4 method for signature 'quosure'
s_attributes(.Object, corpus)

## S4 method for signature 'name'
s_attributes(.Object, corpus)

## S4 method for signature 'remote_corpus'
s_attributes(.Object, ...)

## S4 method for signature 'remote_partition'
s_attributes(.Object, ...)

## S4 method for signature 'data.table'
s_attributes(.Object, corpus, s_attribute, registry)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s_attributes_+3A_.object">.Object</code></td>
<td>
<p>A <code>corpus</code>, <code>subcorpus</code>, <code>partition</code> object, or a <code>call</code>. A
corpus can also be specified by a length-one <code>character</code> vector.</p>
</td></tr>
<tr><td><code id="s_attributes_+3A_...">...</code></td>
<td>
<p>To maintain backward compatibility, if argument <code>sAttribute</code>
(deprecated) is used. If <code>.Object</code> is a <code>remote_corpus</code> or
<code>remote_subcorpus</code> object, the three dots (<code>...</code>) are used to pass
arguments. Hence, it is necessary to state the names of all arguments to be
passed explicity.</p>
</td></tr>
<tr><td><code id="s_attributes_+3A_s_attribute">s_attribute</code></td>
<td>
<p>The name of a specific s-attribute.</p>
</td></tr>
<tr><td><code id="s_attributes_+3A_unique">unique</code></td>
<td>
<p>A <code>logical</code> value, whether to return unique values.</p>
</td></tr>
<tr><td><code id="s_attributes_+3A_regex">regex</code></td>
<td>
<p>A regular expression passed into <code>grep</code> to filter return value
by applying a regex.</p>
</td></tr>
<tr><td><code id="s_attributes_+3A_corpus">corpus</code></td>
<td>
<p>A <code>corpus</code>-object or a length one character vector
denoting a corpus.</p>
</td></tr>
<tr><td><code id="s_attributes_+3A_registry">registry</code></td>
<td>
<p>The registry directory with the registry file defining
<code>corpus</code>. If missing, the registry directory that can be derived using
<code>RcppCWB::corpus_registry_dir()</code> is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Importing XML into the Corpus Workbench (CWB) turns elements and element
attributes into so-called &quot;s-attributes&quot;. There are two basic uses of the
<code>s_attributes()</code>-method: If the argument <code>s_attribute</code> is <code>NULL</code> (default),
the return value is a <code>character</code> vector with all s-attributes present in a
corpus.
</p>
<p>If <code>s_attribute</code> denotes a specific s-attribute (a length-one character
vector), the values of the s-attributes available in the <code>corpus</code>/<code>partition</code>
are returned. if the s-attribute does not have values, <code>NA</code> is returned and a
warning message is issued.
</p>
<p>If argument <code>unique</code> is <code>FALSE</code>, the full sequence of the s_attributes is
returned, which is a useful building block for decoding a corpus.
</p>
<p>If argument <code>s_attributes</code> is a character providing several s-attributes, the
method will return a <code>data.table</code>. If <code>unique</code> is <code>TRUE</code>, all unique
combinations of the s-attributes will be reported by the <code>data.table</code>.
</p>
<p>If the corpus is based on a nested XML structure, the order of items on the
<code>s_attribute</code> vector matters. The method for <code>corpus</code> objects will take the
first s-attribute as the benchmark and assume that further s-attributes are
XML ancestors of the node.
</p>
<p>If <code>.Object</code> is a <code>context</code> object, the s-attribute value for the
first corpus position of every match is returned in a character vector.
If the match is outside a region of the s-attribute, <code>NA</code> is returned.
</p>
<p>If <code>.Object</code> is a <code>call</code> or a <code>quosure</code> (defined in the rlang
package), the <code>s_attributes</code>-method will return a <code>character</code> vector with
the s-attributes occurring in the call. This usage is relevant internally
to implement the <code>subset</code> method to generate a <code>subcorpus</code> using
non-standard evaluation. Usually it will not be relevant in an interactive
session.
</p>


<h3>Value</h3>

<p>A character vector (s-attributes, or values of s-attributes).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>use("polmineR")

s_attributes("GERMAPARLMINI")
s_attributes("GERMAPARLMINI", "date") # dates of plenary meetings
s_attributes("GERMAPARLMINI", s_attribute = c("date", "party"))  
s_attributes(corpus("GERMAPARLMINI"))
p &lt;- partition("GERMAPARLMINI", date = "2009-11-10")
s_attributes(p)
s_attributes(p, "speaker") # get names of speakers

# Get s-attributes occurring in a call
s_attributes(quote(grep("Merkel", speaker)), corpus = "GERMAPARLMINI")
s_attributes(quote(speaker == "Angela Merkel"), corpus = "GERMAPARLMINI")
s_attributes(quote(speaker != "Angela Merkel"), corpus = "GERMAPARLMINI")
s_attributes(
  quote(speaker == "Angela Merkel" &amp; date == "2009-10-28"),
  corpus = "GERMAPARLMINI"
)

# Get s-attributes from quosure
s_attributes(
  rlang::new_quosure(quote(grep("Merkel", speaker))),
  corpus = "GERMAPARLMINI"
)
</code></pre>

<hr>
<h2 id='size'>Get Number of Tokens.</h2><span id='topic+size'></span><span id='topic+size+2Cslice-method'></span><span id='topic+size+2Ccorpus-method'></span><span id='topic+size+2Ccharacter-method'></span><span id='topic+size+2Cpartition-method'></span><span id='topic+size+2Cpartition_bundle-method'></span><span id='topic+size+2CDocumentTermMatrix-method'></span><span id='topic+size+2CTermDocumentMatrix-method'></span><span id='topic+size+2Cfeatures-method'></span><span id='topic+size+2Cremote_corpus-method'></span><span id='topic+size+2Cremote_partition-method'></span>

<h3>Description</h3>

<p>The method will get the number of tokens in a <code>corpus</code>, <code>partition</code> or
<code>subcorpus</code>, split up by an s-attribute if provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>size(x, ...)

## S4 method for signature 'corpus'
size(x, s_attribute = NULL, verbose = TRUE, ...)

## S4 method for signature 'character'
size(x, s_attribute = NULL, verbose = TRUE, ...)

## S4 method for signature 'partition'
size(x, s_attribute = NULL, ...)

## S4 method for signature 'partition_bundle'
size(x)

## S4 method for signature 'DocumentTermMatrix'
size(x)

## S4 method for signature 'TermDocumentMatrix'
size(x)

## S4 method for signature 'features'
size(x)

## S4 method for signature 'remote_corpus'
size(x)

## S4 method for signature 'remote_partition'
size(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="size_+3A_x">x</code></td>
<td>
<p>An object to get size(s) for.</p>
</td></tr>
<tr><td><code id="size_+3A_...">...</code></td>
<td>
<p>Further arguments (used only for backwards compatibility).</p>
</td></tr>
<tr><td><code id="size_+3A_s_attribute">s_attribute</code></td>
<td>
<p>A <code>character</code> vector with s-attributes (one or more).</p>
</td></tr>
<tr><td><code id="size_+3A_verbose">verbose</code></td>
<td>
<p>A <code>logical</code> value, whether to output messages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>One or more s-attributes can be provided to get the dispersion of tokens
across one or more dimensions. If more than one <code>s_attribute</code> is provided and
the structure of s-attributes is nested, ordering attributes according to the
ascending tree structure is advised for performance reasons.
</p>
<p>The <code>size()</code>-method for <code>features</code> objects will return a named list
with the size of the corpus of interest (&quot;coi&quot;), i.e. the number of tokens
in the window, and the reference corpus (&quot;ref&quot;), i.e. the number of tokens
that are not matched by the query and that are outside the window.
</p>


<h3>Value</h3>

<p>If <code>.Object</code> is a corpus (a <code>corpus</code> object or specified by corpus
id), an <code>integer</code> vector if argument <code>s_attribute</code> is <code>NULL</code>, a two-column
<code>data.table</code> otherwise (first column is the s-attribute, second column:
&quot;size&quot;). If <code>.Object</code> is a <code>subcorpus_bundle</code> or a <code>partition_bundle</code>, a
<code>data.table</code> (with columns &quot;name&quot; and &quot;size&quot;).
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+dispersion">dispersion</a></code>-method for counts of hits. The
<code><a href="#topic+hits">hits</a></code> method calls the <code>size</code>-method to get sizes of
subcorpora.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>use("polmineR")
use(pkg = "RcppCWB", corpus = "REUTERS")

# for corpus object
corpus("REUTERS") %&gt;% size()
corpus("REUTERS") %&gt;% size(s_attribute = "id")
corpus("GERMAPARLMINI") %&gt;% size(s_attribute = c("date", "party"))

# for corpus specified by ID
size("GERMAPARLMINI")
size("GERMAPARLMINI", s_attribute = "date")
size("GERMAPARLMINI", s_attribute = c("date", "party"))

# for partition object
P &lt;- partition("GERMAPARLMINI", date = "2009-11-11")
size(P, s_attribute = "speaker")
size(P, s_attribute = "party")
size(P, s_attribute = c("speaker", "party"))

# for subcorpus
sc &lt;- corpus("GERMAPARLMINI") %&gt;% subset(date == "2009-11-11")
size(sc, s_attribute = "speaker")
size(sc, s_attribute = "party")
size(sc, s_attribute = c("speaker", "party"))

# for subcorpus_bundle
subcorpora &lt;- corpus("GERMAPARLMINI") %&gt;% split(s_attribute = "date")
size(subcorpora)
</code></pre>

<hr>
<h2 id='slice'>Virtual class slice.</h2><span id='topic+slice'></span><span id='topic+slice-class'></span><span id='topic+aggregate+2Cslice-method'></span>

<h3>Description</h3>

<p>The classes <code>subcorpus</code> and <code>partition</code> can be used to define
subcorpora. Unlike the <code>subcorpus</code> class, the <code>partition</code> class may
include statistical evaluations. The virtual class <code>slice</code> is a
mechanism to define methods for these classes without making <code>subcorpus</code>
the superclass of <code>partition</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'slice'
aggregate(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slice_+3A_x">x</code></td>
<td>
<p>An object of a class belonging to the virtual class <code>slice</code>, i.e. a
<code>partition</code> or <code>regions</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method <code>aggregate</code> will deflate the matrix in the slot <code>cpos</code>,
i.e. it checks for each new row in the matrix whether it increments the end
of the previous region (by 1), and ensure that the cpos matrix defines
disjoined regions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P &lt;- new(
  "partition",
  cpos = matrix(data = c(1:10, 20:29), ncol = 2, byrow = TRUE),
  stat = data.table::data.table()
)
P2 &lt;- aggregate(P)
P2@cpos
</code></pre>

<hr>
<h2 id='subcorpus'>The S4 subcorpus class.</h2><span id='topic+subcorpus'></span><span id='topic+subcorpus-class'></span><span id='topic+remote_subcorpus-class'></span><span id='topic+summary+2Csubcorpus-method'></span><span id='topic+name+3C-+2Csubcorpus-method'></span><span id='topic+plpr_subcorpus-class'></span><span id='topic+press_subcorpus-class'></span><span id='topic+get_corpus+2Csubcorpus-method'></span><span id='topic+size+2Csubcorpus-method'></span>

<h3>Description</h3>

<p>Class to manage subcorpora derived from a CWB corpus.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'subcorpus'
summary(object)

## S4 replacement method for signature 'subcorpus'
name(x) &lt;- value

## S4 method for signature 'subcorpus'
get_corpus(x)

## S4 method for signature 'subcorpus'
size(x, s_attribute = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subcorpus_+3A_object">object</code></td>
<td>
<p>A <code>subcorpus</code> object.</p>
</td></tr>
<tr><td><code id="subcorpus_+3A_x">x</code></td>
<td>
<p>A <code>subcorpus</code> object.</p>
</td></tr>
<tr><td><code id="subcorpus_+3A_value">value</code></td>
<td>
<p>A <code>character</code> vector to assign as name to slot <code>name</code>
of a <code>subcorpus</code> class object.</p>
</td></tr>
<tr><td><code id="subcorpus_+3A_s_attribute">s_attribute</code></td>
<td>
<p>A <code>character</code> vector with s-attributes (one or more).</p>
</td></tr>
<tr><td><code id="subcorpus_+3A_...">...</code></td>
<td>
<p>Arguments passed into <code>size</code>-method. Used only to maintain
backwards compatibility.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>summary(subcorpus)</code>: Get named list with basic information for
<code>subcorpus</code> object.
</p>
</li>
<li> <p><code>name(subcorpus) &lt;- value</code>: Assign name to a <code>subcorpus</code> object.
</p>
</li>
<li> <p><code>get_corpus(subcorpus)</code>: Get the corpus ID from the <code>subcorpus</code> object.
</p>
</li>
<li> <p><code>size(subcorpus)</code>: Get the size of a <code>subcorpus</code> object from the
respective slot of the object.
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>s_attributes</code></dt><dd><p>A named <code>list</code> with the structural attributes
defining the subcorpus.</p>
</dd>
<dt><code>cpos</code></dt><dd><p>A <code>matrix</code> with left and right corpus positions defining
regions (two column matrix with <code>integer</code> values).</p>
</dd>
<dt><code>annotations</code></dt><dd><p>Object of class <code>list</code>.</p>
</dd>
<dt><code>size</code></dt><dd><p>Total size (number of tokens) of the <code>subcorpus</code> object (a
length-one <code>integer</code> vector). The value is accessible by calling
the <code>size</code>-method on the <code>subcorpus</code>-object (see examples).</p>
</dd>
<dt><code>metadata</code></dt><dd><p>Object of class <code>data.frame</code>, metadata information.</p>
</dd>
<dt><code>strucs</code></dt><dd><p>Object of class <code>integer</code>, the strucs defining the
subcorpus.</p>
</dd>
<dt><code>xml</code></dt><dd><p>Object of class <code>character</code>, whether the xml is &quot;flat&quot; or
&quot;nested&quot;.</p>
</dd>
<dt><code>s_attribute_strucs</code></dt><dd><p>Object of class <code>character</code>, the base node.</p>
</dd>
<dt><code>user</code></dt><dd><p>If the corpus on the server requires authentication, the username.</p>
</dd>
<dt><code>password</code></dt><dd><p>If the corpus on the server requires authentication, the password.</p>
</dd>
</dl>


<h3>See Also</h3>

<p>Most commonly, a <code>subcorpus</code> is derived from a <code>corpus</code> or
a <code>subcorpus</code> using the <code><a href="#topic+subset">subset</a></code> method. See
<code><a href="#topic+size">size</a></code> for detailed documentation on how to use the
<code>size</code>-method. The <code>subcorpus</code> class shares many features with
the <code>partition</code> class, but it is more parsimonious and does not
include information on statistical properties of the subcorpus (i.e. a
count table). In line with this logic, the <code>subcorpus</code> class inherits
from the <code>corpus</code> class, whereas the <code>partition</code> class inherits
from the <code>textstat</code> class.
</p>
<p>Other classes to manage corpora: 
<code><a href="#topic+corpus-class">corpus-class</a></code>,
<code><a href="#topic+phrases-class">phrases-class</a></code>,
<code><a href="#topic+ranges-class">ranges-class</a></code>,
<code><a href="#topic+regions">regions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>use("polmineR")

# basic example 
r &lt;- corpus("REUTERS")
k &lt;- subset(r, grepl("kuwait", places))
name(k) &lt;- "kuwait"
y &lt;- summary(k)
s &lt;- size(k)

# the same with a magrittr pipe
corpus("REUTERS") %&gt;%
  subset(grepl("kuwait", places)) %&gt;%
  summary()
  
# subsetting a subcorpus in a pipe
stone &lt;- corpus("GERMAPARLMINI") %&gt;%
  subset(date == "2009-11-10") %&gt;%
  subset(speaker == "Frank-Walter Steinmeier")

# perform count for subcorpus
n &lt;- corpus("REUTERS") %&gt;% subset(grep("kuwait", places)) %&gt;% count(p_attribute = "word")
n &lt;- corpus("REUTERS") %&gt;% subset(grep("saudi-arabia", places)) %&gt;% count('"Saudi" "Arabia"')
  
# keyword-in-context analysis (kwic)   
k &lt;- corpus("REUTERS") %&gt;% subset(grep("kuwait", places)) %&gt;% kwic("oil")

</code></pre>

<hr>
<h2 id='subcorpus_bundle-class'>Bundled subcorpora</h2><span id='topic+subcorpus_bundle-class'></span><span id='topic+show+2Csubcorpus_bundle-method'></span><span id='topic+merge+2Csubcorpus_bundle-method'></span><span id='topic+merge+2Csubcorpus-method'></span><span id='topic+split+2Csubcorpus-method'></span><span id='topic+split+2Ccorpus-method'></span><span id='topic+split+2Csubcorpus_bundle-method'></span>

<h3>Description</h3>

<p>A <code>subcorpus_bundle</code> object combines a set of
<code>subcorpus</code> objects in a <code>list</code> in the the slot <code>objects</code>.
The class inherits from the <code>partition_bundle</code> and the <code>bundle</code>
class. Typically, a <code>subcorpus_bundle</code> is generated by applying the
<code>split</code>-method on a <code>corpus</code> or <code>subcorpus</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'subcorpus_bundle'
show(object)

## S4 method for signature 'subcorpus_bundle'
merge(x, name = "", verbose = FALSE)

## S4 method for signature 'subcorpus'
merge(x, y, ...)

## S4 method for signature 'subcorpus'
split(
  x,
  s_attribute,
  values,
  prefix = "",
  mc = getOption("polmineR.mc"),
  verbose = TRUE,
  progress = FALSE,
  type = get_type(x)
)

## S4 method for signature 'corpus'
split(
  x,
  s_attribute,
  values,
  prefix = "",
  mc = getOption("polmineR.mc"),
  verbose = TRUE,
  progress = FALSE,
  type = get_type(x),
  xml = "flat"
)

## S4 method for signature 'subcorpus_bundle'
split(
  x,
  s_attribute,
  prefix = "",
  progress = TRUE,
  mc = getOption("polmineR.mc")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subcorpus_bundle-class_+3A_object">object</code></td>
<td>
<p>An object of class <code>subcorpus_bundle</code>.</p>
</td></tr>
<tr><td><code id="subcorpus_bundle-class_+3A_x">x</code></td>
<td>
<p>A <code>corpus</code>, <code>subcorpus</code>, or <code>subcorpus_bundle</code>
object.</p>
</td></tr>
<tr><td><code id="subcorpus_bundle-class_+3A_name">name</code></td>
<td>
<p>The name of the new <code>subcorpus</code> object.</p>
</td></tr>
<tr><td><code id="subcorpus_bundle-class_+3A_verbose">verbose</code></td>
<td>
<p>Logical, whether to provide progress information.</p>
</td></tr>
<tr><td><code id="subcorpus_bundle-class_+3A_y">y</code></td>
<td>
<p>A <code>subcorpus</code> to be merged with <code>x</code>.</p>
</td></tr>
<tr><td><code id="subcorpus_bundle-class_+3A_...">...</code></td>
<td>
<p>Further <code>subcorpus</code> objects to be merged with <code>x</code> and <code>y</code>.</p>
</td></tr>
<tr><td><code id="subcorpus_bundle-class_+3A_s_attribute">s_attribute</code></td>
<td>
<p>The s-attribute to vary.</p>
</td></tr>
<tr><td><code id="subcorpus_bundle-class_+3A_values">values</code></td>
<td>
<p>Either a <code>character</code> vector with values used for splitting, or
a <code>logical</code> value: If <code>TRUE</code>, changes of s-attribute values will be the
basis for generating subcorpora. If <code>FALSE</code>, a new subcorpus is generated
for every struc of the s-attribute. If missing (default), <code>TRUE</code>/<code>FALSE</code> is
assigned depending on whether <code>s-attribute</code> has values, or not.</p>
</td></tr>
<tr><td><code id="subcorpus_bundle-class_+3A_prefix">prefix</code></td>
<td>
<p>A character vector that will be attached as a prefix to partition names.</p>
</td></tr>
<tr><td><code id="subcorpus_bundle-class_+3A_mc">mc</code></td>
<td>
<p>Logical, whether to use multicore parallelization.</p>
</td></tr>
<tr><td><code id="subcorpus_bundle-class_+3A_progress">progress</code></td>
<td>
<p>Logical, whether to show progress bar.</p>
</td></tr>
<tr><td><code id="subcorpus_bundle-class_+3A_type">type</code></td>
<td>
<p>The type of <code>partition</code> to generate.</p>
</td></tr>
<tr><td><code id="subcorpus_bundle-class_+3A_xml">xml</code></td>
<td>
<p>A <code>logical</code> value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Applying the <code>split</code>-method to a <code>subcorpus_bundle</code>-object
will iterate through the subcorpus, and apply <code>split</code> on each
<code>subcorpus</code> object in the bundle, splitting it up by the s-attribute
provided by the argument <code>s_attribute</code>. The return value is a
<code>subcorpus_bundle</code>, the names of which will be the names of the
incoming <code>partition_bundle</code> concatenated with the s-attribute values
used for splitting. The argument <code>prefix</code> can be used to achieve a
more descriptive name.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>corpus("REUTERS") %&gt;% split(s_attribute = "id") %&gt;% summary()

# Merge multiple subcorpus objects
a &lt;- corpus("GERMAPARLMINI") %&gt;% subset(date == "2009-10-27")
b &lt;- corpus("GERMAPARLMINI") %&gt;% subset(date == "2009-10-28")
c &lt;- corpus("GERMAPARLMINI") %&gt;% subset(date == "2009-11-10")
y &lt;- merge(a, b, c)
s_attributes(y, "date")
sc &lt;- subset("GERMAPARLMINI", date == "2009-11-11")
b &lt;- split(sc, s_attribute = "speaker")

p &lt;- partition("GERMAPARLMINI", date = "2009-11-11")
y &lt;- partition_bundle(p, s_attribute = "speaker")
gparl &lt;- corpus("GERMAPARLMINI")
b &lt;- split(gparl, s_attribute = "date")
# split up objects in partition_bundle by using partition_bundle-method
use("polmineR")
y &lt;- corpus("GERMAPARLMINI") %&gt;%
  split(s_attribute = "date") %&gt;%
  split(s_attribute = "speaker")

summary(y)
</code></pre>

<hr>
<h2 id='subset-method'>Subsetting corpora and subcorpora</h2><span id='topic+subset-method'></span><span id='topic+subset'></span><span id='topic+subset+2Ccorpus-method'></span><span id='topic+subset+2Ccharacter-method'></span><span id='topic+subset+2Csubcorpus-method'></span><span id='topic+subset+2Cremote_corpus-method'></span><span id='topic+subset+2Csubcorpus_bundle-method'></span>

<h3>Description</h3>

<p>The structural attributes of a corpus (s-attributes) can be used
to generate subcorpora (i.e. a <code>subcorpus</code> class object) by applying the
<code>subset</code>-method. To obtain a <code>subcorpus</code>, the <code>subset</code>-method can be
applied on a corpus represented by a <code>corpus</code> object, a length-one
<code>character</code> vector (as a shortcut), and on a <code>subcorpus</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'corpus'
subset(x, subset, regex = FALSE, verbose = FALSE, ...)

## S4 method for signature 'character'
subset(x, ...)

## S4 method for signature 'subcorpus'
subset(x, subset, verbose = FALSE, ...)

## S4 method for signature 'remote_corpus'
subset(x, subset)

## S4 method for signature 'subcorpus_bundle'
subset(x, ..., iterate = FALSE, verbose = TRUE, progress = FALSE, mc = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset-method_+3A_x">x</code></td>
<td>
<p>A <code>corpus</code> or <code>subcorpus</code> object. A corpus may also specified by a
length-one <code>character</code> vector.</p>
</td></tr>
<tr><td><code id="subset-method_+3A_subset">subset</code></td>
<td>
<p>A <code>logical</code> expression indicating elements or rows to
keep. The expression may be unevaluated (using <code>quote()</code> or
<code>bquote()</code>).</p>
</td></tr>
<tr><td><code id="subset-method_+3A_regex">regex</code></td>
<td>
<p>A <code>logical</code> value. If <code>TRUE</code>, values for s-attributes
defined using the three dots (...) are interpreted as regular expressions
and passed into a <code>grep</code> call for subsetting a table with the regions
and values of structural attributes. If <code>FALSE</code> (the default), values
for s-attributes must match exactly.</p>
</td></tr>
<tr><td><code id="subset-method_+3A_verbose">verbose</code></td>
<td>
<p>A <code>logical</code> value, whether to show progress messages.</p>
</td></tr>
<tr><td><code id="subset-method_+3A_...">...</code></td>
<td>
<p>An expression that will be used to create a subcorpus from
s-attributes.</p>
</td></tr>
<tr><td><code id="subset-method_+3A_iterate">iterate</code></td>
<td>
<p>A <code>logical</code> value, if <code>TRUE</code>, process very single object of
<code>x</code> individually.</p>
</td></tr>
<tr><td><code id="subset-method_+3A_progress">progress</code></td>
<td>
<p>A <code>logical</code> value, whether to display progress bar.</p>
</td></tr>
<tr><td><code id="subset-method_+3A_mc">mc</code></td>
<td>
<p>An <code>integer</code> value, number of cores to use. If <code>NULL</code> (default),
no multithreading.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default approach for subsetting a <code>subcorpus_bundle</code> is to
temporarily merge objects into a single <code>subcorpus</code>, perform <code>subset()</code>,
and restore <code>subcorpus_bundle</code> by splitting on the s-attribute of the input
<code>subcorpus_bundle</code>. This approach may have unintended results, if <code>x</code> has
been generated using complex criteria. This may be the case for instance,
if <code>x</code> resulted from <code>as.speeches()</code>. In this scenario, set argument
<code>iterate</code> to <code>TRUE</code> to iterate over objects in bundle one-by-one.
</p>


<h3>Value</h3>

<p>A <code>subcorpus</code> object. If the expression provided by argument <code>subset</code>
includes undefined s-attributes, a warning is issued and the return value
is <code>NULL</code>.
</p>


<h3>See Also</h3>

<p>The methods applicable for the <code>subcorpus</code> object resulting from
subsetting a corpus or subcorpus are described in the documentation of the
<code style="white-space: pre;">&#8288;\link{subcorpus-class}&#8288;</code>. Note that the <code>subset</code>-method can also be applied
to <code><a href="#topic+textstat-class">textstat-class</a></code> objects (and objects inheriting from this
class).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>use("polmineR")

# examples for standard and non-standard evaluation
a &lt;- corpus("GERMAPARLMINI")

# subsetting a corpus object using non-standard evaluation
sc &lt;- subset(a, speaker == "Angela Dorothea Merkel")
sc &lt;- subset(a, speaker == "Angela Dorothea Merkel" &amp; date == "2009-10-28")
sc &lt;- subset(a, grepl("Merkel", speaker))
sc &lt;- subset(a, grepl("Merkel", speaker) &amp; date == "2009-10-28")

# subsetting corpus specified by character vector
sc &lt;- subset("GERMAPARLMINI", grepl("Merkel", speaker))
sc &lt;- subset("GERMAPARLMINI", speaker == "Angela Dorothea Merkel")
sc &lt;- subset("GERMAPARLMINI", speaker == "Angela Dorothea Merkel" &amp; date == "2009-10-28")
sc &lt;- subset("GERMAPARLMINI", grepl("Merkel", speaker) &amp; date == "2009-10-28")

# subsetting a corpus using the (old) logic of the partition-method
sc &lt;- subset(a, speaker = "Angela Dorothea Merkel")
sc &lt;- subset(a, speaker = "Angela Dorothea Merkel", date = "2009-10-28")
sc &lt;- subset(a, speaker = "Merkel", regex = TRUE)
sc &lt;- subset(a, speaker = c("Merkel", "Kauder"), regex = TRUE)
sc &lt;- subset(a, speaker = "Merkel", date = "2009-10-28", regex = TRUE)

# providing the value for s-attribute as a variable
who &lt;- "Volker Kauder"
sc &lt;- subset(a, quote(speaker == !!who))

# quoting and quosures necessary when programming against subset
# note how variable who needs to be handled
gparl &lt;- corpus("GERMAPARLMINI")
subcorpora &lt;- lapply(
  c("Angela Dorothea Merkel", "Volker Kauder", "Ronald Pofalla"),
  function(who) subset(gparl, speaker == !!who)
)

# subset a subcorpus_bundle
merkel &lt;- corpus("GERMAPARLMINI") %&gt;%
  split(s_attribute = "protocol_date") %&gt;%
  subset(speaker == "Angela Dorothea Merkel")

# iterate over objects in bundle one by one 
sp &lt;- corpus("GERMAPARLMINI") %&gt;%
  as.speeches(
    s_attribute_name = "speaker",
    s_attribute_date = "protocol_date",
    progress = FALSE
  ) %&gt;%
  subset(interjection == "speech", iterate = TRUE, progress = FALSE)
</code></pre>

<hr>
<h2 id='t_test'>Perform t-test.</h2><span id='topic+t_test'></span><span id='topic+t_test+2Ccontext-method'></span>

<h3>Description</h3>

<p>Compute t-scores to find collocations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>t_test(.Object)

## S4 method for signature 'context'
t_test(.Object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="t_test_+3A_.object">.Object</code></td>
<td>
<p>A <code>context</code> or <code>features</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The calculation of the t-test is based on the formula
</p>
<p style="text-align: center;"><code class="reqn">t = \frac{\overline{x} - \mu}{\sqrt{\frac{s^2}{N}}}</code>
</p>

<p>where <code class="reqn">\mu</code> is the mean of the distribution, x the sample mean,
<code class="reqn">s^2</code> the sample variance, and N the sample size.
</p>
<p>Following Manning and Schuetze (1999), to test whether two tokens (a and b)
are a collocation, the sample mean <code class="reqn">\mu</code> is the number of observed
co-occurrences of a and b divided by corpus size N:
</p>
<p style="text-align: center;"><code class="reqn">\mu = \frac{o_{ab}}{N}</code>
</p>

<p>For the mean of the distribution <code class="reqn">\overline{x}</code>, maximum likelihood estimates
are used. Given that we know the number of observations of token a, <code class="reqn">o_{a}</code>, the
number of observations of b, <code class="reqn">o_{b}</code> and the size of the corpus N, the
propabilities for the tokens a and b, and for the co-occcurence of a and be
are as follows, if independence is assumed:
</p>
<p style="text-align: center;"><code class="reqn">P(a) = \frac{o_{a}}{N}</code>
</p>

<p style="text-align: center;"><code class="reqn">P(b) = \frac{o_{b}}{N}</code>
</p>

<p style="text-align: center;"><code class="reqn">P(ab) = P(a)P(b)</code>
</p>

<p>See the examples for a sample calulation of the t-test, and Evert (2005: 83)
for a critical discussion of the &quot;highly questionable&quot; assumptions when using
the t-test for detecting co-occurrences.
</p>


<h3>References</h3>

<p>Manning, Christopher D.; Schuetze, Hinrich (1999):
<em>Foundations of Statistical Natural Language Processing</em>. MIT Press:
Cambridge, Mass., pp. 163-166.
</p>
<p>Church, Kenneth W. et al. (1991): Using Statistics in Lexical
Analysis. In: Uri Zernik (ed.), <em>Lexical Acquisition</em>. Hillsdale,
NJ:Lawrence Erlbaum, pp. 115-164
<a href="https://doi.org/10.4324/9781315785387-8">doi:10.4324/9781315785387-8</a>
</p>
<p>Evert, Stefan (2005): <em>The Statistics of Word Cooccurrences.
Word Pairs and Collocations.</em> URN urn:nbn:de:bsz:93-opus-23714.
<a href="https://elib.uni-stuttgart.de/bitstream/11682/2573/1/Evert2005phd.pdf">https://elib.uni-stuttgart.de/bitstream/11682/2573/1/Evert2005phd.pdf</a>
</p>


<h3>See Also</h3>

<p>Other statistical methods: 
<code><a href="#topic+chisquare">chisquare</a>()</code>,
<code><a href="#topic+ll">ll</a>()</code>,
<code><a href="#topic+pmi">pmi</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>use("polmineR")
y &lt;- cooccurrences("REUTERS", query = "oil", left = 1L, right = 0L, method = "t_test")
# The critical value (for a = 0.005) is 2.579, so "crude" is a collocation
# of "oil" according to t-test.

# A sample calculation
count_oil &lt;- count("REUTERS", query = "oil")
count_crude &lt;- count("REUTERS", query = "crude")
count_crude_oil &lt;- count("REUTERS", query = '"crude" "oil"', cqp = TRUE)

p_crude &lt;- count_crude$count / size("REUTERS")
p_oil &lt;- count_oil$count / size("REUTERS")
p_crude_oil &lt;- p_crude * p_oil

x &lt;- count_crude_oil$count / size("REUTERS")

t_value &lt;- (x - p_crude_oil) / sqrt(x / size("REUTERS"))
# should be identical with previous result:
as.data.frame(subset(y, word == "crude"))$t_test
</code></pre>

<hr>
<h2 id='terms'>Get terms in <code>partition</code> or <code>corpus</code>.</h2><span id='topic+terms'></span><span id='topic+terms+2Cslice-method'></span><span id='topic+terms+2Cpartition-method'></span><span id='topic+terms+2Csubcorpus-method'></span><span id='topic+terms+2Ccorpus-method'></span><span id='topic+terms+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Get terms in <code>partition</code> or <code>corpus</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'partition'
terms(x, p_attribute, regex = NULL)

## S4 method for signature 'subcorpus'
terms(x, p_attribute, regex = NULL)

## S4 method for signature 'corpus'
terms(x, p_attribute, regex = NULL, robust = FALSE)

## S4 method for signature 'character'
terms(x, p_attribute, regex = NULL, robust = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="terms_+3A_x">x</code></td>
<td>
<p>A <code>corpus</code>, <code>partition</code> or <code>subcorpus</code> object, or a length-one
<code>character</code> with a corpus id.</p>
</td></tr>
<tr><td><code id="terms_+3A_p_attribute">p_attribute</code></td>
<td>
<p>The p-attribute to for which to retrieve results
(length-one <code>character</code> vector).</p>
</td></tr>
<tr><td><code id="terms_+3A_regex">regex</code></td>
<td>
<p>Regular expression(s) to filter results (<code>character</code> vector).</p>
</td></tr>
<tr><td><code id="terms_+3A_robust">robust</code></td>
<td>
<p>A <code>logical</code> value, whether to check for potential failures.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>use(pkg = "RcppCWB", corpus = "REUTERS")

r &lt;- partition("REUTERS", id = "144")
words &lt;- terms(r, "word")
terms(r, p_attribute = "word", regex = ".*il.*")
</code></pre>

<hr>
<h2 id='textstat-class'>S4 textstat superclass.</h2><span id='topic+textstat-class'></span><span id='topic+as.data.frame+2Ctextstat-method'></span><span id='topic+show+2Ctextstat-method'></span><span id='topic+dim+2Ctextstat-method'></span><span id='topic+colnames+2Ctextstat-method'></span><span id='topic+rownames+2Ctextstat-method'></span><span id='topic+names+2Ctextstat-method'></span><span id='topic+as.DataTables+2Ctextstat-method'></span><span id='topic+head+2Ctextstat-method'></span><span id='topic+tail+2Ctextstat-method'></span><span id='topic+nrow+2Ctextstat-method'></span><span id='topic+ncol+2Ctextstat-method'></span><span id='topic+round+2Ctextstat-method'></span><span id='topic+sort+2Ctextstat-method'></span><span id='topic++5B+2Ctextstat+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+5B+2Ctextstat-method'></span><span id='topic+name'></span><span id='topic+name+3C-'></span><span id='topic+name+2Ctextstat-method'></span><span id='topic+name+2Ccharacter-method'></span><span id='topic+name+3C-+2Ctextstat-method'></span><span id='topic+as.bundle'></span><span id='topic++2B+2Ctextstat+2Ctextstat-method'></span><span id='topic+subset+2Ctextstat-method'></span><span id='topic+as.data.table.textstat'></span><span id='topic+p_attributes+2Ctextstat-method'></span><span id='topic+knit_print+2Ctextstat-method'></span><span id='topic+get_corpus+2Ctextstat-method'></span><span id='topic+format+2Ctextstat-method'></span><span id='topic+restore'></span><span id='topic+cp'></span><span id='topic+view+2Ctextstat-method'></span>

<h3>Description</h3>

<p>The <code>textstat</code> S4 class is the superclass for the classes <code>features</code>,
<code>context</code>, and <code>partition</code>. Usually, these subclasses, which are designed to
serve a specified analytical purpose, will be used . Common standard generic
methods such as <code>head</code>, <code>tail</code>, <code>dim</code>, <code>nrow</code>, <code>colnames</code> are defined for the
<code>textstat</code> class and are available for subclasses by inheritence. The core of
<code>textstat</code> and its childs is a <code>data.table</code> in the slot <code>stat</code> for keeping
data on text statistics of a <code>corpus</code>, or a <code>partition</code>. The <code>textstat</code> class
inherits from the <code>corpus</code> class, keeping information on the corpus
available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'textstat'
name(x)

## S4 method for signature 'character'
name(x)

## S4 replacement method for signature 'textstat'
name(x) &lt;- value

## S4 method for signature 'textstat'
round(x, digits = 2L)

## S4 method for signature 'textstat'
sort(x, by, decreasing = TRUE)

as.bundle(object, ...)

## S4 method for signature 'textstat,textstat'
e1 + e2

## S4 method for signature 'textstat'
subset(x, subset)

## S3 method for class 'textstat'
as.data.table(x, ...)

## S4 method for signature 'textstat'
show(object)

## S4 method for signature 'textstat'
p_attributes(.Object)

## S4 method for signature 'textstat'
knit_print(x, options = knitr::opts_chunk, ...)

## S4 method for signature 'textstat'
get_corpus(x)

## S4 method for signature 'textstat'
format(x, digits = 2L)

restore(file)

cp(x)

## S4 method for signature 'textstat'
view(.Object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="textstat-class_+3A_x">x</code></td>
<td>
<p>An object (<code>textstat</code> or class inheriting from <code>textstat</code>).</p>
</td></tr>
<tr><td><code id="textstat-class_+3A_value">value</code></td>
<td>
<p>A <code>character</code> vector to assign as name to slot <code>name</code>
of a <code>textstat</code> class object.</p>
</td></tr>
<tr><td><code id="textstat-class_+3A_digits">digits</code></td>
<td>
<p>Number of digits.</p>
</td></tr>
<tr><td><code id="textstat-class_+3A_by">by</code></td>
<td>
<p>Column that will serve as the key for sorting.</p>
</td></tr>
<tr><td><code id="textstat-class_+3A_decreasing">decreasing</code></td>
<td>
<p>Logical, whether to return decreasing order.</p>
</td></tr>
<tr><td><code id="textstat-class_+3A_object">object</code></td>
<td>
<p>a textstat object</p>
</td></tr>
<tr><td><code id="textstat-class_+3A_...">...</code></td>
<td>
<p>Argument that will be passed into a call of the <code>format</code> method
on the object <code>x</code>.</p>
</td></tr>
<tr><td><code id="textstat-class_+3A_e1">e1</code></td>
<td>
<p>A <code>texstat</code> object.</p>
</td></tr>
<tr><td><code id="textstat-class_+3A_e2">e2</code></td>
<td>
<p>Another <code>texstat</code> object.</p>
</td></tr>
<tr><td><code id="textstat-class_+3A_subset">subset</code></td>
<td>
<p>A logical expression indicating elements or rows to keep.</p>
</td></tr>
<tr><td><code id="textstat-class_+3A_.object">.Object</code></td>
<td>
<p>A <code>textstat</code> object.</p>
</td></tr>
<tr><td><code id="textstat-class_+3A_options">options</code></td>
<td>
<p>Chunk options.</p>
</td></tr>
<tr><td><code id="textstat-class_+3A_file">file</code></td>
<td>
<p>An rds file to restore (filename).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code>head</code>-method will return the first rows of the <code>data.table</code> in
the <code>stat</code>-slot. Use argument <code>n</code> to specify the number of rows.
</p>
<p>A <code>tail</code>-method will return the last rows of the <code>data.table</code> in
the <code>stat</code>-slot. Use argument <code>n</code> to specify the number of rows.
</p>
<p>The methods <code>dim</code>, <code>nrow</code> and <code>ncol</code> will return information
on the dimensions, the number of rows, or the number of columns of the
<code>data.table</code> in the <code>stat</code>-slot, respectively.
</p>
<p>Objects derived from the <code>textstat</code> class can be indexed with simple
square brackets (&quot;[&quot;) to get rows specified by an numeric/integer vector,
and with double square brackets (&quot;[[&quot;) to get specific columns from the
<code>data.table</code> in the slot <code>stat</code>.
</p>
<p>The <code>colnames</code>-method will return the column names of the <code>data-table</code>
in the slot <code>stat</code>.
</p>
<p>The methods <code>as.data.table</code>, and <code>as.data.frame</code> will extract the
<code>data.table</code> in the slot <code>stat</code> as a <code>data.table</code>, or <code>data.frame</code>,
respectively.
</p>
<p><code>textstat</code> objects can have a name, which can be retrieved, and set using
the <code>name</code>-method and <code style="white-space: pre;">&#8288;name&lt;-&#8288;</code>, respectively.
</p>
<p>The <code>round()</code>-method looks up all numeric columns in the
<code>data.table</code> in the <code>stat</code>-slot of the <code>textstat</code> object and
rounds values of these columns to the number of decimal places specified by
argument <code>digits</code>.
</p>
<p>The <code>knit_print</code> method will be called by knitr to render
<code>textstat</code> objects or objects inheriting from the <code>textstat</code> class as a
DataTable  <code>htmlwidget</code> when rendering a R Markdown document as html.
It will usually be necessary to explicitly state &quot;render = knit_print&quot; in
the chunk options. The option <code>polmineR.pagelength</code> controls the number of
lines displayed in the resulting <code>htmlwidget</code>. Note that including
htmlwidgets in html documents requires that pandoc is installed. To avoid
an error, a formatted <code>data.table</code> is returned by <code>knit_print</code> if
pandoc is not available.
</p>
<p>The <code>format()</code>-method returns a pretty-printed and minimized version
of the <code>data.table</code> in the <code>stat</code>-slot of the <code>textstat</code>-object: It will
round all numeric columns to the number of decimal numbers specified by
<code>digits</code>, and drop all columns with token ids. The return value is a
<code>data.table</code>.
</p>
<p>Using the reference semantics of <code>data.table</code> objects (i.e. inplace
modification) has great advantages for  memory efficiency. But there may be
unexpected behavior when reloading an S4 <code>textstat</code> object (including classes
inheriting from <code>textstat</code>) with a <code>data.table</code> in the <code>stat</code> slot. Use
<code>restore</code> to copy the <code>data.table</code> once to have a restored object that works
for inplace operations after saving / reloading it.
</p>
<p>It is not possible to add columns to the <code>data.table</code> in the <code>stat</code>
slot of a <code>textclass</code> object, when the object has been saved and loaded
using <code>save()</code>/<code>load()</code>. This scenario applies for instance, when the
objects of an interactive R session are saved, and loaded when starting the
next interactive R session. The <code>cp()</code> function will create a copy of the
object, including an explicit copy of the <code>data.table</code> in the <code>stat</code> slot.
Inplace modifications of the new object are possible. The function can also
be used to avoid unwanted side effects of modifying an object.
</p>


<h3>Slots</h3>


<dl>
<dt><code>p_attribute</code></dt><dd><p>Object of class <code>character</code>, p-attribute of the query.</p>
</dd>
<dt><code>corpus</code></dt><dd><p>A corpus specified by a length-one <code>character</code> vector.</p>
</dd>
<dt><code>stat</code></dt><dd><p>A <code>data.table</code> with statistical information.</p>
</dd>
<dt><code>name</code></dt><dd><p>The name of the object.</p>
</dd>
<dt><code>annotation_cols</code></dt><dd><p>A <code>character</code> vector, column names of
<code>data.table</code> in slot <code>stat</code> that are annotations.</p>
</dd>
<dt><code>encoding</code></dt><dd><p>A length-one <code>character</code> vector, the encoding of the corpus.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>use(pkg = "polmineR", corpus = "GERMAPARLMINI")
use(pkg = "RcppCWB", corpus = "REUTERS")

P &lt;- partition("GERMAPARLMINI", date = ".*", p_attribute = "word", regex = TRUE)
y &lt;- cooccurrences(P, query = "Arbeit")

# generics defined in the polmineR package
x &lt;- count("REUTERS", p_attribute = "word")
name(x) &lt;- "count_reuters"
name(x)
get_corpus(x)

# Standard generic methods known from data.frames work for objects inheriting
# from the textstat class

head(y)
tail(y)
nrow(y)
ncol(y)
dim(y)
colnames(y)

# Use brackets for indexing 

## Not run: 
y[1:25]
y[,c("word", "ll")]
y[1:25, "word"]
y[1:25][["word"]]
y[which(y[["word"]] %in% c("Arbeit", "Sozial"))]
y[ y[["word"]] %in% c("Arbeit", "Sozial") ]

## End(Not run)
sc &lt;- partition("GERMAPARLMINI", speaker = "Angela Dorothea Merkel")
cnt &lt;- count(sc, p_attribute = c("word", "pos"))
cnt_min &lt;- subset(cnt, pos %in% c("NN", "ADJA"))
cnt_min &lt;- subset(cnt, pos == "NE")
use(pkg = "RcppCWB", corpus = "REUTERS")

# Get statistics in textstat object as data.table
count_dt &lt;- corpus("REUTERS") %&gt;%
  subset(grep("saudi-arabia", places)) %&gt;% 
  count(p_attribute = "word") %&gt;%
  as.data.table()

# textstat objects stored as *.rds files should be loaded using restore().
# Before moving to examples, this is a brief technical dip why this is
# recommended: If we load the *.rds file with readRDS(), the data.table in
# the slot 'stat' will have the pointer '0x0', and the data.table cannot be
# augmented without having been copied previously.

k &lt;- kwic("REUTERS", query = "oil")
kwicfile &lt;- tempfile(fileext = ".rds")
saveRDS(k, file = kwicfile)
problemprone &lt;- readRDS(file = kwicfile)
problemprone@stat[, "newcol" := TRUE]
"newcol" %in% colnames(problemprone@stat) # is FALSE!

attr(problemprone@stat, ".internal.selfref")
identical(attr(problemprone@stat, ".internal.selfref"), new("externalptr"))

# Restore stored S4 object with copy of data.table in 'stat' slot
k &lt;- kwic("REUTERS", query = "oil")
kwicfile &lt;- tempfile(fileext = ".rds")
saveRDS(k, file = kwicfile)

k2 &lt;- restore(kwicfile)
enrich(k2, s_attribute = "id")
"id" %in% colnames(k2) # is TRUE
k &lt;- kwic("REUTERS", query = "oil")
rdata_file &lt;- tempfile(fileext = ".RData")
save(k, file = rdata_file)
rm(k)

load(rdata_file)
k &lt;- cp(k) # now it is possible to columns by reference
enrich(k, s_attribute = "id")
"id" %in% colnames(k)
</code></pre>

<hr>
<h2 id='tooltips-method'>Add tooltips to text output.</h2><span id='topic+tooltips-method'></span><span id='topic+tooltips'></span><span id='topic+tooltips+2Ccharacter-method'></span><span id='topic+tooltips+2Chtml-method'></span><span id='topic+tooltips+2Ckwic-method'></span>

<h3>Description</h3>

<p>Highlight tokens based on exact match, a regular expression or corpus
position in <code>kwic</code> output or html document.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tooltips(.Object, tooltips, ...)

## S4 method for signature 'character'
tooltips(
  .Object,
  tooltips = list(),
  fmt = "//span[@style=\"background-color:%s\"]",
  verbose
)

## S4 method for signature 'html'
tooltips(.Object, tooltips = list(), fmt, verbose = TRUE)

## S4 method for signature 'kwic'
tooltips(.Object, tooltips, regex = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tooltips-method_+3A_.object">.Object</code></td>
<td>
<p>A <code>html</code> or <code>character</code> object with html.</p>
</td></tr>
<tr><td><code id="tooltips-method_+3A_tooltips">tooltips</code></td>
<td>
<p>A named <code>list</code> of character vectors, the names need to
match colors in the list provided to param <code>highlight</code>. The value of
the character vector is the tooltip to be displayed.</p>
</td></tr>
<tr><td><code id="tooltips-method_+3A_...">...</code></td>
<td>
<p>Further arguments are interpreted as assignments of tooltips to
tokens.</p>
</td></tr>
<tr><td><code id="tooltips-method_+3A_fmt">fmt</code></td>
<td>
<p>A format string with an xpath expression used to look up the node
where the tooltip is inserted. If missing, a heuristic evaluating the names
of the <code>tooltips</code> list decides whether tooltips are inserted based on
highlighting colors or corpus positions.</p>
</td></tr>
<tr><td><code id="tooltips-method_+3A_verbose">verbose</code></td>
<td>
<p>A <code>logical</code> value, whether to show messages.</p>
</td></tr>
<tr><td><code id="tooltips-method_+3A_regex">regex</code></td>
<td>
<p>A <code>logical</code> value, whether character vector values of argument
<code>tooltips</code> are interpreted as regular expressions.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>use(pkg = "RcppCWB", corpus = "REUTERS")

a &lt;- partition("REUTERS", places = "argentina")
b &lt;- html(a)
c &lt;- highlight(b, lightgreen = "higher")
d &lt;- tooltips(c, list(lightgreen = "Further information"))
if (interactive()) d

# Using the tooltips-method in a pipe ...
h &lt;- a %&gt;%
  html() %&gt;%
  highlight(yellow = c("barrels", "oil", "gas")) %&gt;%
  tooltips(list(yellow = "energy"))
</code></pre>

<hr>
<h2 id='tree_structure'>Show the structure of s-attributes</h2><span id='topic+tree_structure'></span><span id='topic+tree_structure+2Cxml_node-method'></span><span id='topic+tree_structure+2Cxml_document-method'></span><span id='topic+tree_structure+2Csubcorpus-method'></span><span id='topic+tree_structure+2Ccorpus-method'></span>

<h3>Description</h3>

<p>Show the structure of s-attributes. If <code>x</code> is a <code>subcorpus</code>, the s-attribute
used for corpus subsetting is highlighted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree_structure(x, ...)

## S4 method for signature 'xml_node'
tree_structure(x, s_attribute = NULL, prefix = 0, indent = 3, root = TRUE)

## S4 method for signature 'xml_document'
tree_structure(x, s_attribute = NULL, prefix = 0, indent = 3, root = TRUE)

## S4 method for signature 'subcorpus'
tree_structure(x)

## S4 method for signature 'corpus'
tree_structure(x, s_attribute = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tree_structure_+3A_x">x</code></td>
<td>
<p>Object for which to visualise structure.</p>
</td></tr>
<tr><td><code id="tree_structure_+3A_...">...</code></td>
<td>
<p>Further arguments.</p>
</td></tr>
<tr><td><code id="tree_structure_+3A_s_attribute">s_attribute</code></td>
<td>
<p>Name of the s-attribute used for subsetting, will be
highlighted.</p>
</td></tr>
<tr><td><code id="tree_structure_+3A_prefix">prefix</code></td>
<td>
<p>Number of blank spaces.</p>
</td></tr>
<tr><td><code id="tree_structure_+3A_indent">indent</code></td>
<td>
<p>Number of spaces to indent.</p>
</td></tr>
<tr><td><code id="tree_structure_+3A_root">root</code></td>
<td>
<p>Whether branch is root.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>xml_sample &lt;- system.file(
  package = "GermaParl2",
  "extdata", "cwb", "indexed_corpora",
  "germaparl2mini"
)
if (nchar(xml_sample) &gt; 0L &amp;&amp; interactive()){
  use(pkg = "GermaParl2", corpus = "GERMAPARL2MINI")
  
  corpus("GERMAPARL2MINI") %&gt;%
    tree_structure()
    
  corpus("GERMAPARL2MINI") %&gt;%
    subset(speaker_name == "Konrad Adenauer") %&gt;%
    tree_structure()
 
  corpus("GERMAPARL2MINI") %&gt;%
    subset(speaker_name == "Konrad Adenauer") %&gt;%
    subset(p) %&gt;%
    tree_structure()
  
  corpus("GERMAPARL2MINI") %&gt;%
    subset(ne_type) %&gt;%
    tree_structure()
}
</code></pre>

<hr>
<h2 id='trim'>Trim an object.</h2><span id='topic+trim'></span><span id='topic+trim-method'></span><span id='topic+trim+2CTermDocumentMatrix-method'></span><span id='topic+trim+2CDocumentTermMatrix-method'></span><span id='topic+punctuation'></span>

<h3>Description</h3>

<p>Method to trim and adjust objects by applying thresholds, minimum frequencies
etc. It can be applied to <code>context</code>, <code>features</code>, <code>context</code>, <code>partition</code> and
<code>partition_bundle</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trim(.Object, ...)

## S4 method for signature 'TermDocumentMatrix'
trim(
  .Object,
  terms_to_drop,
  docs_to_keep,
  min_count,
  min_doc_length,
  verbose = TRUE,
  ...
)

## S4 method for signature 'DocumentTermMatrix'
trim(
  .Object,
  terms_to_drop,
  docs_to_keep,
  min_count,
  min_doc_length,
  verbose = TRUE,
  ...
)

punctuation
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trim_+3A_.object">.Object</code></td>
<td>
<p>The object to be trimmed</p>
</td></tr>
<tr><td><code id="trim_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
<tr><td><code id="trim_+3A_terms_to_drop">terms_to_drop</code></td>
<td>
<p>A <code>character</code> vector with terms to exclude from matrix
(terms used as stopwords).</p>
</td></tr>
<tr><td><code id="trim_+3A_docs_to_keep">docs_to_keep</code></td>
<td>
<p>A <code>character</code> vector with documents to keep.</p>
</td></tr>
<tr><td><code id="trim_+3A_min_count">min_count</code></td>
<td>
<p>A <code>numeric</code> value with a minimum value of total term
frequency across documents to exclude rare terms from matrix.</p>
</td></tr>
<tr><td><code id="trim_+3A_min_doc_length">min_doc_length</code></td>
<td>
<p>A <code>numeric</code> value with minimum total of the summed-up
occurrence of tokens in a document. Exclude documents below this value and
filter out short documents. Note that the <code>min_doc_length</code> filter is applied
before filtering for <code>min_count</code> and <code>terms_to_keep</code>, and that these filters
will reduce document lengths.</p>
</td></tr>
<tr><td><code id="trim_+3A_verbose">verbose</code></td>
<td>
<p>A <code>logical</code> value, whether to output progress messages.</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 13.
</p>


<h3>Author(s)</h3>

<p>Andreas Blaette
</p>


<h3>Examples</h3>

<pre><code class='language-R'>use("RcppCWB", corpus = "REUTERS")
dtm &lt;- corpus("REUTERS") %&gt;%
  split(s_attribute = "id") %&gt;%
  as.DocumentTermMatrix(p_attribute = "word", verbose = FALSE)
trim(dtm, min_doc_length = 100)
</code></pre>

<hr>
<h2 id='use'>Add corpora in R data packages to session registry.</h2><span id='topic+use'></span>

<h3>Description</h3>

<p>Use CWB indexed corpora in R data packages by adding registry file to session
registry.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>use(pkg, corpus, lib.loc = .libPaths(), tmp = FALSE, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="use_+3A_pkg">pkg</code></td>
<td>
<p>A package including at least one CWB indexed corpus.</p>
</td></tr>
<tr><td><code id="use_+3A_corpus">corpus</code></td>
<td>
<p>A corpus (or corpora) to be loaded selectively.</p>
</td></tr>
<tr><td><code id="use_+3A_lib.loc">lib.loc</code></td>
<td>
<p>A character vector with path names of <code>R</code> libraries.</p>
</td></tr>
<tr><td><code id="use_+3A_tmp">tmp</code></td>
<td>
<p>A <code>logical</code> value, whether to use a temporary data directory.</p>
</td></tr>
<tr><td><code id="use_+3A_verbose">verbose</code></td>
<td>
<p>Logical, whether to output status messages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pkg</code> is expected to be an installed data package that includes CWB indexed
corpora. The <code>use()</code>-function will add the registry files describing the
corpus (or the corpora) to the session registry directory and adjust the path
pointing to the data in the package.
</p>
<p>The registry files within the package are assumed to be in the subdirectory
'./extdata/cwb/registry' of the installed package. The data directories
for corpora are assumed to be in a subdirectory named after the corpus (lower
case) in the package subdirectory './extdata/cwb/indexed_corpora/'. When
adding a corpus to the registry, templates for formatting fulltext output are
reloaded.
</p>
<p>If the path to the data directory in a package includes a non-ASCII character,
binary data files of the corpora in package are copied to a subdirectory of the
per-session temporary data directory.
</p>


<h3>Value</h3>

<p>A <code>logical</code> value: <code>TRUE</code> if corpus has been loaded successfully, or
<code>FALSE</code>, if any kind of error occurred.
</p>


<h3>See Also</h3>

<p>To get the temporary registry directory, see <code><a href="#topic+registry">registry</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>use("polmineR")
corpus()
</code></pre>

<hr>
<h2 id='view'>Inspect object using View().</h2><span id='topic+view'></span>

<h3>Description</h3>

<p>Inspect object using View().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>view(.Object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="view_+3A_.object">.Object</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="view_+3A_...">...</code></td>
<td>
<p>further parameters</p>
</td></tr>
</table>

<hr>
<h2 id='weigh'>Apply Weight to Matrix</h2><span id='topic+weigh'></span><span id='topic+weigh+2CTermDocumentMatrix-method'></span><span id='topic+weigh+2CDocumentTermMatrix-method'></span><span id='topic+weigh+2Ccount-method'></span><span id='topic+weigh+2Ccount_bundle-method'></span>

<h3>Description</h3>

<p>Apply Weight to Matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weigh(.Object, ...)

## S4 method for signature 'TermDocumentMatrix'
weigh(.Object, method = "tfidf")

## S4 method for signature 'DocumentTermMatrix'
weigh(.Object, method = "tfidf")

## S4 method for signature 'count'
weigh(.Object, with)

## S4 method for signature 'count_bundle'
weigh(.Object, with, progress = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weigh_+3A_.object">.Object</code></td>
<td>
<p>A <code>matrix</code>, or a <code>count</code>-object.</p>
</td></tr>
<tr><td><code id="weigh_+3A_...">...</code></td>
<td>
<p>further parameters</p>
</td></tr>
<tr><td><code id="weigh_+3A_method">method</code></td>
<td>
<p>The kind of weight to apply.</p>
</td></tr>
<tr><td><code id="weigh_+3A_with">with</code></td>
<td>
<p>A <code>data.table</code> used to weigh p-attributes. A column 'weight' with term weights is
required, and columns with the p-attributes of <code>.Object</code> for matching.</p>
</td></tr>
<tr><td><code id="weigh_+3A_progress">progress</code></td>
<td>
<p>Logical, whether to show a progress bar.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(data.table)
if (require("zoo") &amp;&amp; require("devtools")){

# Source in function 'get_sentiws' from a GitHub gist
gist_url &lt;- path(
  "gist.githubusercontent.com",
  "PolMine",
  "70eeb095328070c18bd00ee087272adf",
  "raw",
  "c2eee2f48b11e6d893c19089b444f25b452d2adb",
  "sentiws.R"
 )
  
devtools::source_url(sprintf("https://%s", gist_url))
SentiWS &lt;- get_sentiws()

# Do the statistical word context analysis
use("GermaParl")
options("polmineR.left" = 10L)
options("polmineR.right" = 10L)
df &lt;- context("GERMAPARL", query = "Islam", p_attribute = c("word", "pos")) %&gt;%
  partition_bundle(node = FALSE) %&gt;% 
  set_names(s_attributes(., s_attribute = "date")) %&gt;%
  weigh(with = SentiWS) %&gt;%
  summary()

# Aggregate by year
df[["year"]] &lt;- as.Date(df[["name"]]) %&gt;% format("%Y-01-01")
df_year &lt;- aggregate(df[,c("size", "positive_n", "negative_n")], list(df[["year"]]), sum)
colnames(df_year)[1] &lt;- "year"

# Use shares instead of absolute counts 
df_year$negative_share &lt;- df_year$negative_n / df_year$size
df_year$positive_share &lt;- df_year$positive_n / df_year$size

# Turn it into zoo object, and plot it
Z &lt;- zoo(
  x = df_year[, c("positive_share", "negative_share")],
  order.by = as.Date(df_year[,"year"])
)
plot(
  Z, ylab = "polarity", xlab = "year",
  main = "Word context of 'Islam': Share of positive/negative vocabulary",
  cex = 0.8,
  cex.main = 0.8
)

# Note that we can uses the kwic-method to check for the validity of our findings
words_positive &lt;- SentiWS[weight &gt; 0][["word"]]
words_negative &lt;- SentiWS[weight &lt; 0][["word"]]
kwic("GERMAPARL", query = "Islam", positivelist = c(words_positive, words_negative)) %&gt;%
  highlight(lightgreen = words_positive, orange = words_negative) %&gt;%
  tooltips(setNames(SentiWS[["word"]], SentiWS[["weight"]]))
  
}

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
