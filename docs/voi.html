<!DOCTYPE html><html><head><title>Help for package voi</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {voi}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#all_interactions'><p>Generate a string with all interactions of a certain degree, to be used in a GAM formula</p></a></li>
<li><a href='#check_model_fn'><p>Check that a decision-analytic model function is of the appropriate form.  Detect if it returns net benefit or CEA format</p>
note check_outputs adds a class</a></li>
<li><a href='#check_regression'><p>Check the fit of a regression model used to estimate EVPPI or EVSI</p></a></li>
<li><a href='#chemo_cea'><p>Chemotherapy cost-effectiveness model</p></a></li>
<li><a href='#enbs'><p>Expected net benefit of sampling</p></a></li>
<li><a href='#enbs_opt'><p>Determine the optimum sample size in an analysis of the expected net benefit</p>
of sampling</a></li>
<li><a href='#evpi'><p>Calculate the expected value of perfect information from a decision model</p></a></li>
<li><a href='#evppi'><p>Calculate the expected value of partial perfect information from a decision-analytic model</p></a></li>
<li><a href='#evppi_mc'><p>Traditional two-level Monte Carlo estimator of EVPPI.</p></a></li>
<li><a href='#evppivar'><p>Calculate the expected value of partial perfect information for an estimation problem</p></a></li>
<li><a href='#evsi'><p>Calculate the expected value of sample information from a decision-analytic</p>
model</a></li>
<li><a href='#evsivar'><p>Calculate the expected value of sample information for an estimation problem</p></a></li>
<li><a href='#form_nbarray'><p>Convert either &quot;net benefit&quot; or &quot;cost-effectiveness&quot; forms for</p>
'outputs' to a 3D array  (number of simulations, x number of
willingness-to-pay values, x number of decision options) with one
WTP value when <code>outputs</code> is in &quot;net benefit&quot; form.</a></li>
<li><a href='#import_heemod'><p>Import results of probabilistic analysis from heemod</p></a></li>
<li><a href='#plot.evppi'><p>Plot EVPPI estimates</p></a></li>
<li><a href='#pop_voi'><p>Population expected value of information</p></a></li>
<li><a href='#voi-package'><p>Methods to calculate the Expected Value of Information</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Expected Value of Information</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-27</td>
</tr>
<tr>
<td>Description:</td>
<td>Methods to calculate the expected value of information from a decision-analytic model.  This includes the expected value of perfect information (EVPI), partial perfect information (EVPPI) and sample information (EVSI), and the expected net benefit of sampling (ENBS).  A range of alternative computational methods are provided under the same user interface.  See Jackson et al. (2022) &lt;<a href="https://doi.org/10.1146%2Fannurev-statistics-040120-010730">doi:10.1146/annurev-statistics-040120-010730</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Imports:</td>
<td>mgcv, earth, mvtnorm, progress, dbarts, posterior, ggplot2,
gridExtra, Matrix</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, BCEA, INLA, splancs, sf, knitr, rmarkdown, rjags,
truncnorm, scales, dplyr, heemod</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://chjackson.github.io/voi/">https://chjackson.github.io/voi/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/chjackson/voi/issues">https://github.com/chjackson/voi/issues</a></td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://inla.r-inla-download.org/R/stable/">https://inla.r-inla-download.org/R/stable/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-27 11:49:23 UTC; Chris</td>
</tr>
<tr>
<td>Author:</td>
<td>Christopher Jackson [aut, cre],
  Anna Heath [aut],
  Gianluca Baio [ctb] (Author of code taken from the BCEA package),
  Mark Strong [ctb] (Author of code taken from the SAVI package),
  Kofi Placid Adragni [ctb] (Author of code taken from the ldr package),
  Andrew Raim [ctb] (Author of code taken from the ldr package)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christopher Jackson &lt;chris.jackson@mrc-bsu.cam.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-27 16:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='all_interactions'>Generate a string with all interactions of a certain degree, to be used in a GAM formula</h2><span id='topic+all_interactions'></span>

<h3>Description</h3>

<p>Generate a string with all interactions of a certain degree, to be used in a GAM formula
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_interactions(x, degree = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all_interactions_+3A_x">x</code></td>
<td>
<p>Character vector of variable names</p>
</td></tr>
<tr><td><code id="all_interactions_+3A_degree">degree</code></td>
<td>
<p>Maximum interaction degree</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string looking like the right hand side of a GAM formula with tensor product interactions.
</p>
<p>For example, if <code>x</code> is <code>c("x1","x2","x3")</code>, then <code>all_interactions(x, degree=2)</code> should return
</p>
<p><code>"te(x1,x2) + te(x1,x3) + te(x1,x3)"</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c("x1","x2","x3")
all_interactions(x, 2)

</code></pre>

<hr>
<h2 id='check_model_fn'>Check that a decision-analytic model function is of the appropriate form.  Detect if it returns net benefit or CEA format
note check_outputs adds a class</h2><span id='topic+check_model_fn'></span>

<h3>Description</h3>

<p>Check that a decision-analytic model function is of the appropriate form.  Detect if it returns net benefit or CEA format
note check_outputs adds a class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_model_fn(
  model_fn,
  par_fn,
  mfargs = NULL,
  outputs = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Value</h3>

<p>A modified copy of <code>model_fn</code> with a <code>class</code> attribute indicating whether it is
in net benefit <code>"nb"</code> or cost-effectiveness <code>"cea"</code> format, and an attribute <code>"nopt"</code> giving the
number of decision options.
</p>

<hr>
<h2 id='check_regression'>Check the fit of a regression model used to estimate EVPPI or EVSI</h2><span id='topic+check_regression'></span>

<h3>Description</h3>

<p>Produces diagnostic plots and summaries of regression models used to estimate EVPPI or EVSI,
mainly in order to check that the residuals have mean zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_regression(
  x,
  pars = NULL,
  n = NULL,
  comparison = 1,
  outcome = "costs",
  plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_regression_+3A_x">x</code></td>
<td>
<p>Output from <code><a href="#topic+evppi">evppi</a></code> or <code><a href="#topic+evsi">evsi</a></code>. The argument <code>check=TRUE</code>
must have been used when calling <code>evppi</code> or <code>evsi</code>, to allow the regression model
objects from <code>gam</code> or <code>earth</code> to be preserved.  (This is not done by
default, since these objects can be large.).   <code>attr(x, "models")</code> contains these objects.</p>
</td></tr>
<tr><td><code id="check_regression_+3A_pars">pars</code></td>
<td>
<p>Parameter (or parameter group) whose EVPPI calculation is to be checked.
This should be in the <code>pars</code> component of the object returned by <code><a href="#topic+evppi">evppi</a></code>.
Only relevant if <code>x</code> is the result of an <code><a href="#topic+evppi">evppi</a></code> calculation.  By default,
the first calculation shown in <code>x</code> is checked.</p>
</td></tr>
<tr><td><code id="check_regression_+3A_n">n</code></td>
<td>
<p>Sample size whose EVSI calculation is to be checked.
This should be in the <code>n</code> component of the object returned by <code><a href="#topic+evsi">evsi</a></code>.
Only relevant if <code>x</code> is the result of an <code><a href="#topic+evsi">evsi</a></code> calculation.</p>
</td></tr>
<tr><td><code id="check_regression_+3A_comparison">comparison</code></td>
<td>
<p>Only relevant if there are more than two treatments in the decision model.
Different regression models are then used for the comparisons of different treatments
with the baseline treatment.
<code>comparison</code> is an integer identifying which of these models is checked.</p>
</td></tr>
<tr><td><code id="check_regression_+3A_outcome">outcome</code></td>
<td>
<p><code>"costs"</code> or <code>"effects"</code>.  Only relevant if <code>outputs</code> was
in cost-effectiveness format when
calling <code>evppi</code> or <code>evsi</code>, hence different regressions are used for costs and
effects.  By default, <code>outcome="costs"</code> is used, so that the regression
for costs is checked.</p>
</td></tr>
<tr><td><code id="check_regression_+3A_plot">plot</code></td>
<td>
<p>If <code>FALSE</code>, only numerical statistics are returned, and a plot is not made.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For VoI estimation, the key thing we are looking for is that the residuals
have mean zero, hence that the mean of the model output is represented well by the
regression function of the model input parameters.  It should not matter if the
variance of the residuals is non-constant, or non-normally distributed.
</p>
<p>Models produced with <code>method="gam"</code> are summarised using <code><a href="mgcv.html#topic+gam.check">gam.check</a></code>.
</p>
<p>Models produced <code>method="earth"</code> are summarised using <code>plot.earth</code>.
</p>
<p>For any regression model, if <code>fitted()</code> and <code>residuals()</code> methods are defined for those models,
then a histogram of the residuals and a scatterplot of residuals against fitted values is produced.
</p>


<h3>Value</h3>

<p>Where possible, an appropriate statistic is returned that allows the regression
model to be compared with other regression models implemented using the same <code>method</code>
but with different assumptions.   For <code>method="gam"</code>,
this is Akaike's information criterion (AIC).
For <code>method="earth"</code>, this is the generalised cross-validation statistic
<code>gcv</code>.    Currently not implemented for other methods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pars &lt;- c("p_side_effects_t1", "p_side_effects_t2")
evtest &lt;- evppi(chemo_nb, chemo_pars, pars=pars, check=TRUE)
evtest
check_regression(evtest)

## with no interaction term 
evtest2 &lt;- evppi(chemo_nb, chemo_pars, pars=pars, 
                gam_formula="s(p_side_effects_t1)+s(p_side_effects_t2)",
                check=TRUE)
evtest2
check_regression(evtest2)

## doesn't make much difference to the estimate
## fit is OK in either case

</code></pre>

<hr>
<h2 id='chemo_cea'>Chemotherapy cost-effectiveness model</h2><span id='topic+chemo_cea'></span><span id='topic+chemo_nb'></span><span id='topic+chemo_pars'></span><span id='topic+chemo_cea_501'></span><span id='topic+chemo_constants'></span><span id='topic+chemo_evsi_or'></span><span id='topic+chemo_model'></span><span id='topic+chemo_pars_fn'></span><span id='topic+chemo_model_nb'></span><span id='topic+chemo_model_cea'></span><span id='topic+chemo_model_lor_nb'></span><span id='topic+chemo_model_lor_cea'></span>

<h3>Description</h3>

<p>An artificial health economic decision model with a typical Markov model structure, used for illustrating Value of Information methods.
Functions are provided to generate model parameters and evaluate the model, and samples from probabilistic analysis of the model are
provided as built-in datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chemo_cea

chemo_nb

chemo_pars

chemo_cea_501

chemo_constants

chemo_evsi_or

chemo_pars_fn(n)

chemo_model_nb(
  p_side_effects_t1,
  p_side_effects_t2,
  p_hospitalised_total,
  p_died,
  lambda_home,
  lambda_hosp,
  c_home_care,
  c_hospital,
  c_death,
  u_recovery,
  u_home_care,
  u_hospital,
  rate_longterm
)

chemo_model_cea(
  p_side_effects_t1,
  p_side_effects_t2,
  p_hospitalised_total,
  p_died,
  lambda_home,
  lambda_hosp,
  c_home_care,
  c_hospital,
  c_death,
  u_recovery,
  u_home_care,
  u_hospital,
  rate_longterm
)

chemo_model_lor_nb(
  p_side_effects_t1,
  logor_side_effects,
  p_hospitalised_total,
  p_died,
  lambda_home,
  lambda_hosp,
  c_home_care,
  c_hospital,
  c_death,
  u_recovery,
  u_home_care,
  u_hospital,
  rate_longterm
)

chemo_model_lor_cea(
  p_side_effects_t1,
  logor_side_effects,
  p_hospitalised_total,
  p_died,
  lambda_home,
  lambda_hosp,
  c_home_care,
  c_hospital,
  c_death,
  u_recovery,
  u_home_care,
  u_hospital,
  rate_longterm
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chemo_cea_+3A_n">n</code></td>
<td>
<p>Number of samples to generate from the uncertainty distribution of the parameters in <code>chemo_pars_fn</code>.</p>
</td></tr>
<tr><td><code id="chemo_cea_+3A_p_side_effects_t1">p_side_effects_t1</code></td>
<td>
<p>Probability of side effects under treatment 1</p>
</td></tr>
<tr><td><code id="chemo_cea_+3A_p_side_effects_t2">p_side_effects_t2</code></td>
<td>
<p>Probability of side effects under treatment 2</p>
</td></tr>
<tr><td><code id="chemo_cea_+3A_p_hospitalised_total">p_hospitalised_total</code></td>
<td>
<p>Probability of hospitalisation in the year after receiving treatment</p>
</td></tr>
<tr><td><code id="chemo_cea_+3A_p_died">p_died</code></td>
<td>
<p>Probability of death in the year after receiving treatment</p>
</td></tr>
<tr><td><code id="chemo_cea_+3A_lambda_home">lambda_home</code></td>
<td>
<p>Recovery probability for someone treated at home</p>
</td></tr>
<tr><td><code id="chemo_cea_+3A_lambda_hosp">lambda_hosp</code></td>
<td>
<p>Recovery probability for someone treated in hospital who does not die</p>
</td></tr>
<tr><td><code id="chemo_cea_+3A_c_home_care">c_home_care</code></td>
<td>
<p>Cost of a yearly period under treatment at home</p>
</td></tr>
<tr><td><code id="chemo_cea_+3A_c_hospital">c_hospital</code></td>
<td>
<p>Cost of hospital treatment</p>
</td></tr>
<tr><td><code id="chemo_cea_+3A_c_death">c_death</code></td>
<td>
<p>Cost of death</p>
</td></tr>
<tr><td><code id="chemo_cea_+3A_u_recovery">u_recovery</code></td>
<td>
<p>Utility of a period in the recovery state</p>
</td></tr>
<tr><td><code id="chemo_cea_+3A_u_home_care">u_home_care</code></td>
<td>
<p>Utility of home care state</p>
</td></tr>
<tr><td><code id="chemo_cea_+3A_u_hospital">u_hospital</code></td>
<td>
<p>Utility of hospital state</p>
</td></tr>
<tr><td><code id="chemo_cea_+3A_rate_longterm">rate_longterm</code></td>
<td>
<p>Long term mortality rate</p>
</td></tr>
<tr><td><code id="chemo_cea_+3A_logor_side_effects">logor_side_effects</code></td>
<td>
<p>Log odds ratio of side effects for treatment 2 compared to 1</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 33.
</p>
<p>An object of class <code>evsi</code> (inherits from <code>data.frame</code>) with 15030 rows and 3 columns.
</p>
<p>Samples of 10000 from probabilistic analysis of this model are made available in the package, in the
following data objects:
</p>
<p><code>chemo_pars</code>: Sample from the distributions of the parameters, as a data frame with names as documented above.
</p>
<p><code>chemo_cea</code>: List with components <code>e</code> (sampled effects), <code>c</code> (sampled costs), and <code>k</code> (a set of five
equally-spaced willingess-to-pay values from 10000 to 50000 pounds).   The effects and costs are data frames
with two columns, one for each decision option.
</p>
<p><code>chemo_nb</code>: Data frame with two columns, giving the net monetary benefit for each decision option,
at a willingness-to-pay of 20000 pounds.
</p>
<p><code>chemo_cea_501</code>: List with components <code>e</code> (sampled effects), <code>c</code> (sampled costs), and <code>k</code> (a set of 501
willlingess-to-pay values from 10000 to 50000)  This is provided to facilitate illustrations of plots of
VoI measures against willingness-to-pay.
</p>
<p>The following additional data objects are supplied:
</p>
<p><code>chemo_constants</code> includes various constants required by the code.
</p>
<p><code>chemo_evsi_or</code> is the result of an EVSI analysis to estimate the expected value of a two-arm trial, with a binary outcome, to estimate the log odds ratio of side effects.  This object is a data frame with three columns, giving the sample size per arm (<code>n</code>), willingness-to-pay (<code>k</code>) and the corresponding EVSI (<code>evsi</code>).
</p>


<h3>Details</h3>

<p>For more details, refer to Heath et al. (forthcoming book...)
</p>


<h3>Value</h3>

<p>Two alternative functions are provided to evaluate the decision model for given parameters.
</p>
<p><code>chemo_model_nb</code> returns a vector with elements giving the net monetary benefit for standard of care
and novel treatment, respectively, at a willingness-to-pay of 20,000 pounds per QALY.
</p>
<p><code>chemo_model_cea</code> returns a matrix with:
</p>

<ul>
<li><p> two rows, the first for expected costs and the second for expected effects (QALYs) over the fifty year time horizon, and
</p>
</li>
<li><p> two columns, the first for the &quot;standard of care&quot; decision option, and the second for the novel
treatment.
</p>
</li></ul>

<p><code>chemo_model_lor_nb</code> and <code>chemo_model_lor_cea</code> are the same model, but parameterised in terms of
the probability of side effects for the standard of care <code>p_side_effects_t1</code> and the log odds ratio
of side effects between treatment groups <code>logor_side_effects</code>, rather than in terms of
<code>p_side_effects_t1</code> and <code>p_side_effects_t2</code>
</p>
<p><code>chemo_pars_fn</code> generates a sample from the uncertainty distribution of the parameters in the chemotherapy model . This returns a data frame with parameters matching the arguments of
<code><a href="#topic+chemo_model_nb">chemo_model_nb</a></code>, and the following additional derived parameters:
</p>

<ul>
<li> <p><code>p_side_effects_t2</code>:
</p>
</li>
<li> <p><code>p_hospitalised_total</code>: probability of hospitalisation over the 50 year time horizon
</p>
</li>
<li> <p><code>p_died</code>: probability of death over the time horizon, given hospitalisation
</p>
</li>
<li> <p><code>lambda_home</code>: conditional probability that a patient recovers given they are not hospitalised
</p>
</li>
<li> <p><code>lambda_hosp</code>: conditional probability that a patient in hospital recovers given they do not die
</p>
</li></ul>



<h3>References</h3>

<p>Value of Information for Healthcare Decision Making
(CRC Press, eds. Heath, Kunst and Jackson: forthcoming)
</p>

<hr>
<h2 id='enbs'>Expected net benefit of sampling</h2><span id='topic+enbs'></span>

<h3>Description</h3>

<p>Calculates the expected net benefit of sampling for a typical study to inform
a health economic evaluation, given estimates of the per-person expected
value of sample information, decision population size and study setup and
per-participant costs.   The optimal sample size for each willingness-to-pay,
population size and time horizon is also determined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enbs(
  evsi,
  costs_setup,
  costs_pp,
  pop,
  time,
  dis = 0.035,
  smooth = FALSE,
  smooth_df = NULL,
  pcut = 0.05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="enbs_+3A_evsi">evsi</code></td>
<td>
<p>Data frame giving estimates of the expected value of sample
information, as returned by <code><a href="#topic+evsi">evsi</a></code>.  This may contain
multiple estimates, one for each sample size and willingness to pay.</p>
</td></tr>
<tr><td><code id="enbs_+3A_costs_setup">costs_setup</code></td>
<td>
<p>Setup costs of the study.  This can either be a constant,
or a vector of two elements giving a 95% credible interval (with mean
defined by the midpoint), or a vector of three elements assumed to define
the mean and 95% credible interval.</p>
</td></tr>
<tr><td><code id="enbs_+3A_costs_pp">costs_pp</code></td>
<td>
<p>Per-participant costs of the study, supplied in the same
format as <code>cost_setup</code>.</p>
</td></tr>
<tr><td><code id="enbs_+3A_pop">pop</code></td>
<td>
<p>Size of the population who would be affected by the decision.</p>
</td></tr>
<tr><td><code id="enbs_+3A_time">time</code></td>
<td>
<p>Time horizon over which discounting will be applied.</p>
</td></tr>
<tr><td><code id="enbs_+3A_dis">dis</code></td>
<td>
<p>Discount rate used when converting per-person to population EVSI.</p>
</td></tr>
<tr><td><code id="enbs_+3A_smooth">smooth</code></td>
<td>
<p>If <code>TRUE</code>, then the maximum ENBS is determined after
fitting a nonparametric regression to the data frame <code>x</code>, which
estimates and smooths the ENBS for every integer sample size in the range
of <code>x$n</code>.  The regression is done using the default settings of
<code><a href="mgcv.html#topic+gam">gam</a></code> from the <span class="pkg">mgcv</span> package.
</p>
<p>If this is <code>FALSE</code>, then no smoothing or interpolation is done, and
the maximum is determined by searching over the values supplied in
<code>x</code>.</p>
</td></tr>
<tr><td><code id="enbs_+3A_smooth_df">smooth_df</code></td>
<td>
<p>Basis dimension for the smooth regression. Passed as the
<code>k</code> argument to the <code>s()</code> term in <code><a href="mgcv.html#topic+gam">gam</a></code>.   Defaults to
6, or the number of unique sample sizes minus 1 if this is lower.  Set
to a higher number if you think the smoother does not capture the
relation of ENBS to sample size accurately enough.</p>
</td></tr>
<tr><td><code id="enbs_+3A_pcut">pcut</code></td>
<td>
<p>Cut-off probability which defines a &quot;near-optimal&quot; sample size.
The minimum and maximum sample size for which the ENBS is within
<code>pcut</code> (by default 5%) of its maximum value will be determined.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pop</code>,<code>time</code> and <code>dis</code> may be supplied as vectors
of different lengths.  In that case, the ENBS is calculated for all
possible combinations of the values in these vectors.
</p>


<h3>Value</h3>

<p>Data frame with components <code>enbs</code> giving the ENBS, and
<code>sd</code> giving the corresponding standard deviation.  The rows of the
data frame correspond to the rows of <code>evsi</code>, and any <code>n</code> and
<code>k</code> are inherited from <code>evsi</code>.  Additional columns include:
</p>
<p><code>pce</code>: the probability that the study is cost-effective, i.e. that
the ENBS is positive, obtained from a normal distribution defined by the
estimate and standard deviation.
</p>
<p><code>enbsmax</code>: The maximum ENBS for each willingness-to-pay <code>k</code>.
</p>
<p><code>nmax</code>: The sample size <code>n</code> at which this maximum is achieved.
</p>
<p>A second data frame is returned as the <code>"enbsmax"</code> attribute.
This has one row per willingness-to-pay (<code>k</code>), giving the optimal
ENBS (<code>enbsmax</code>) the optimal sample size (<code>nmax</code>) and an interval
estimate for the optimal sample size (<code>nlower</code> to <code>nupper</code>).
</p>
<p>If <code>pop</code>, <code>time</code> or <code>dis</code> were supplied as vectors
of more than one element, then additional columns will be returned
in these data frames to identify the population, time or discount
rate for each ENBS calculation.  An index <code>ind</code> is also returned
to identify the unique combination that each row refers to.
</p>


<h3>References</h3>

<p>Value of Information for Healthcare Decision Making
(CRC Press, eds. Heath, Kunst and Jackson: forthcoming)
</p>

<hr>
<h2 id='enbs_opt'>Determine the optimum sample size in an analysis of the expected net benefit
of sampling</h2><span id='topic+enbs_opt'></span>

<h3>Description</h3>

<p>The optimum sample size for a given willingness to pay is determined either
by a simple search over the supplied ENBS estimates for different sample
sizes, or by a regression and interpolation method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enbs_opt(x, pcut = 0.05, smooth = FALSE, smooth_df = NULL, keep_preds = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="enbs_opt_+3A_x">x</code></td>
<td>
<p>Data frame containing a set of ENBS estimates for
different sample sizes, which will be optimised over.  Usually
this is for a common willingness-to-pay. The required components
are <code>enbs</code> and <code>n</code>.</p>
</td></tr>
<tr><td><code id="enbs_opt_+3A_pcut">pcut</code></td>
<td>
<p>Cut-off probability which defines a &quot;near-optimal&quot; sample size.
The minimum and maximum sample size for which the ENBS is within
<code>pcut</code> (by default 5%) of its maximum value will be determined.</p>
</td></tr>
<tr><td><code id="enbs_opt_+3A_smooth">smooth</code></td>
<td>
<p>If <code>TRUE</code>, then the maximum ENBS is determined after
fitting a nonparametric regression to the data frame <code>x</code>, which
estimates and smooths the ENBS for every integer sample size in the range
of <code>x$n</code>.  The regression is done using the default settings of
<code><a href="mgcv.html#topic+gam">gam</a></code> from the <span class="pkg">mgcv</span> package.
</p>
<p>If this is <code>FALSE</code>, then no smoothing or interpolation is done, and
the maximum is determined by searching over the values supplied in
<code>x</code>.</p>
</td></tr>
<tr><td><code id="enbs_opt_+3A_smooth_df">smooth_df</code></td>
<td>
<p>Basis dimension for the smooth regression. Passed as the
<code>k</code> argument to the <code>s()</code> term in <code><a href="mgcv.html#topic+gam">gam</a></code>.   Defaults to
6, or the number of unique sample sizes minus 1 if this is lower.  Set
to a higher number if you think the smoother does not capture the
relation of ENBS to sample size accurately enough.</p>
</td></tr>
<tr><td><code id="enbs_opt_+3A_keep_preds">keep_preds</code></td>
<td>
<p>If <code>TRUE</code> and <code>smooth=TRUE</code> then the data frame of
predictions from the smooth regression model is stored in the <code>"preds"</code>
attribute of the result.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with one row, and the following columns:
</p>
<p><code>ind</code>: An integer index identifying, e.g. the willingness to pay and other common characteristics of the ENBS estimates (e.g. incident population size, decision time horizon). This is copied from <code>x$ind</code>.
</p>
<p><code>enbsmax</code>: the maximum ENBS
</p>
<p><code>nmax</code>: the sample size at which this maximum is achieved
</p>
<p><code>nlower</code>: the lowest sample size for which the ENBS is within
</p>
<p><code>pcut</code> (default 5%) of its maximum value
</p>
<p><code>nupper</code>: the corresponding highest ENBS
</p>

<hr>
<h2 id='evpi'>Calculate the expected value of perfect information from a decision model</h2><span id='topic+evpi'></span>

<h3>Description</h3>

<p>Calculate the expected value of perfect information from a decision model using standard Monte Carlo simulation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evpi(outputs, nsim = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evpi_+3A_outputs">outputs</code></td>
<td>
<p>This could take one of two forms
</p>
<p>&quot;net benefit&quot; form: a matrix or data frame of samples from the uncertainty
distribution of the expected net benefit.  The number of rows should equal
the number of samples, and the number of columns should equal the number
of decision options.
</p>
<p>&quot;cost-effectiveness analysis&quot; form: a list with the following named
components:
</p>
<p><code>"c"</code>: a matrix or data frame of samples from the distribution of
costs.  There should be one column for each decision option.
</p>
<p><code>"e"</code>: a matrix or data frame of samples from the distribution of
effects, likewise.
</p>
<p><code>"k"</code>: a vector of willingness-to-pay values.
</p>
<p>Objects of class <code>"bcea"</code>, as created by the <span class="pkg">BCEA</span> package, are in
this &quot;cost-effectiveness analysis&quot; format, therefore they may be supplied as
the <code>outputs</code> argument.
</p>
<p>Users of <span class="pkg">heemod</span> can create an object of this form, given an object
produced by <code>run_psa</code> (<code>obj</code>, say), with <code><a href="#topic+import_heemod_outputs">import_heemod_outputs</a></code>.
</p>
<p>If <code>outputs</code> is a matrix or data frame, it is assumed to be of &quot;net
benefit&quot; form.  Otherwise if it is a list, it is assumed to be of &quot;cost
effectiveness analysis&quot; form.</p>
</td></tr>
<tr><td><code id="evpi_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulations from the decision model to use
for calculating EVPPI.  The first <code>nsim</code> rows of the
objects in <code>inputs</code> and <code>outputs</code> are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The expected value of perfect information, either as a single value, or a data frame indicating the value for each willingness-to-pay.
</p>

<hr>
<h2 id='evppi'>Calculate the expected value of partial perfect information from a decision-analytic model</h2><span id='topic+evppi'></span>

<h3>Description</h3>

<p>Calculate the expected value of partial perfect information from a decision-analytic model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evppi(
  outputs,
  inputs,
  pars = NULL,
  method = NULL,
  se = FALSE,
  B = 1000,
  nsim = NULL,
  verbose = FALSE,
  check = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evppi_+3A_outputs">outputs</code></td>
<td>
<p>This could take one of two forms
</p>
<p>&quot;net benefit&quot; form: a matrix or data frame of samples from the uncertainty
distribution of the expected net benefit.  The number of rows should equal
the number of samples, and the number of columns should equal the number
of decision options.
</p>
<p>&quot;cost-effectiveness analysis&quot; form: a list with the following named
components:
</p>
<p><code>"c"</code>: a matrix or data frame of samples from the distribution of
costs.  There should be one column for each decision option.
</p>
<p><code>"e"</code>: a matrix or data frame of samples from the distribution of
effects, likewise.
</p>
<p><code>"k"</code>: a vector of willingness-to-pay values.
</p>
<p>Objects of class <code>"bcea"</code>, as created by the <span class="pkg">BCEA</span> package, are in
this &quot;cost-effectiveness analysis&quot; format, therefore they may be supplied as
the <code>outputs</code> argument.
</p>
<p>Users of <span class="pkg">heemod</span> can create an object of this form, given an object
produced by <code>run_psa</code> (<code>obj</code>, say), with <code><a href="#topic+import_heemod_outputs">import_heemod_outputs</a></code>.
</p>
<p>If <code>outputs</code> is a matrix or data frame, it is assumed to be of &quot;net
benefit&quot; form.  Otherwise if it is a list, it is assumed to be of &quot;cost
effectiveness analysis&quot; form.</p>
</td></tr>
<tr><td><code id="evppi_+3A_inputs">inputs</code></td>
<td>
<p>Matrix or data frame of samples from the uncertainty
distribution of the input parameters of the decision model.   The number
of columns should equal the number of parameters, and the columns should
be named.    This should have the same number of rows as there are samples
in <code>outputs</code>, and each row of the samples in <code>outputs</code> should
give the model output evaluated at the corresponding parameters.
</p>
<p>Users of <span class="pkg">heemod</span> can create an object of this form, given an object
produced by <code>run_psa</code> (<code>obj</code>, say), with <code><a href="#topic+import_heemod_inputs">import_heemod_inputs</a></code>.</p>
</td></tr>
<tr><td><code id="evppi_+3A_pars">pars</code></td>
<td>
<p>Either a character vector, or a list of character vectors.
</p>
<p>If a character vector is supplied, then a single, joint EVPPI calculation is done with
for the parameters named in this vector.
</p>
<p>If a list of character vectors is supplied,  then multiple EVPPI calculations are
performed, one for each list component defined in the above
vector form.
</p>
<p><code>pars</code> must be specified if <code>inputs</code> is a matrix or data frame.
This should then correspond to particular columns of <code>inputs</code>.    If
<code>inputs</code> is a vector, this is assumed to define the single parameter
of interest, and then <code>pars</code> is not required.</p>
</td></tr>
<tr><td><code id="evppi_+3A_method">method</code></td>
<td>
<p>Character string indicating the calculation method.  If one
string is supplied, this is used for all calculations.  A vector of different strings
can be supplied if a different method is desired for different list components
of <code>pars</code>.
</p>
<p>The default methods are based on nonparametric regression:
</p>
<p><code>"gam"</code> for a generalized additive model implemented in the <code><a href="mgcv.html#topic+gam">gam</a></code>
function from the <span class="pkg">mgcv</span> package.  This is the default method for
calculating the EVPPI of 4 or fewer parameters.
</p>
<p><code>"gp"</code> for a Gaussian process regression, as described by Strong et al.
(2014) and implemented in the <span class="pkg">SAVI</span> package
(<a href="https://github.com/Sheffield-Accelerated-VoI/SAVI">https://github.com/Sheffield-Accelerated-VoI/SAVI</a>).  This is the default method for calculating the EVPPI
of more than 4 parameters.
</p>
<p><code>"inla"</code> for an INLA/SPDE Gaussian process regression method, from
Heath et al. (2016).
</p>
<p><code>"bart"</code> for Bayesian additive regression trees, using the <span class="pkg">dbarts</span> package.
Particularly suited for joint EVPPI of many parameters.
</p>
<p><code>"earth"</code> for a multivariate adaptive regression spline with the
<span class="pkg">earth</span> package (Milborrow, 2019).
</p>
<p><code>"so"</code> for the method of Strong and Oakley (2013).  Only supported
for single parameter EVPPI.
</p>
<p><code>"sal"</code> for the method of Sadatsafavi et al. (2013).  Only supported
for single parameter EVPPI.</p>
</td></tr>
<tr><td><code id="evppi_+3A_se">se</code></td>
<td>
<p>If this is <code>TRUE</code>, calculate a standard error for the EVPPI
if possible.  Currently only supported for methods <code>"gam"</code>, <code>"earth"</code> and
<code>method="bart"</code>.  (In the latter method it is more correctly called
a posterior standard deviation).  These represent uncertainty about the
parameters of the fitted regression model, and will naturally be lower when
more simulations from the decision model are used to fit it.  They do not
represent uncertainty about the structure of the regression model,</p>
</td></tr>
<tr><td><code id="evppi_+3A_b">B</code></td>
<td>
<p>Number of parameter replicates for calculating the standard error.
Only applicable to <code>method="gam"</code>.  For <code>method="bart"</code> the
analogous quantity is the number of MCMC samples, which is controlled by
the <code>ndpost</code> argument to <code><a href="dbarts.html#topic+bart">bart</a></code>, which can be
passed as an argument to <code><a href="#topic+evppi">evppi</a></code>.</p>
</td></tr>
<tr><td><code id="evppi_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulations from the decision model to use
for calculating EVPPI.  The first <code>nsim</code> rows of the
objects in <code>inputs</code> and <code>outputs</code> are used.</p>
</td></tr>
<tr><td><code id="evppi_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, then messages are printed
describing each step of the calculation, if the method supplies
these.  Can be useful to see the progress of slow calculations.</p>
</td></tr>
<tr><td><code id="evppi_+3A_check">check</code></td>
<td>
<p>If <code>TRUE</code>, then extra information about the estimation
is saved inside the object that this function returns.  This currently
only applies to the regression-based methods <code>"gam"</code> and <code>"earth"</code>
where the fitted regression model objects are saved.  This allows use
of the <code><a href="#topic+check_regression">check_regression</a></code> function, which produces some
diagnostic checks of the regression models.</p>
</td></tr>
<tr><td><code id="evppi_+3A_...">...</code></td>
<td>
<p>Other arguments to control specific methods.
</p>
<p>For <code>method="gam"</code>, the following arguments can be supplied:
</p>

<ul>
<li> <p><code>gam_formula</code>: a character string giving the right hand side of the
formula supplied to the <code>gam()</code> function. By default, this is a tensor
product of all the parameters of interest, e.g. if <code>pars =
c("pi","rho")</code>, then <code>gam_formula</code> defaults to <code>t(pi, rho,
bs="cr")</code>.  The option <code>bs="cr"</code> indicates a cubic spline regression
basis, which is more computationally efficient than the default &quot;thin plate&quot;
basis.  If there are four or more parameters of interest, then the
additional argument <code>k=4</code> is supplied to <code>te()</code>, specifying a
four-dimensional basis, which is currently the default in the SAVI package.
</p>
<p>If there are spaces in the variable names in <code>inputs</code>, then these should
be converted to underscores before forming an explicit <code>gam_formula</code>.
</p>
</li></ul>

<p>For <code>method="gp"</code>, the following arguments can be supplied:
</p>

<ul>
<li> <p><code>gp_hyper_n</code>: number of samples to use to estimate the hyperparameters
in the Gaussian process regression method.  By default, this is the minimum
of the following three quantities: 30 times the number of parameters of
interest, 250, and the number of simulations being used for calculating
EVPPI.
</p>
</li>
<li> <p><code>maxSample</code>: Maximum sample size to employ for <code>method="gp"</code>.  Only
increase this from the default 5000 if your computer has sufficent memory to
invert square matrices with this dimension.
</p>
</li></ul>

<p>For <code>method="inla"</code>, the following arguments can be supplied, as described in detail in Baio, Berardi and Heath (2017):
</p>

<ul>
<li> <p><code>int.ord</code> (integer) maximum order of interaction terms to include in
the regression predictor, e.g. if <code>int.ord=k</code> then all k-way
interactions are used.  Currently this applies to both effects and costs.
</p>
</li>
<li> <p><code>cutoff</code> (default 0.3) controls the
density of the points inside the mesh in the spatial part of the mode.
Acceptable values are typically in
the interval (0.1,0.5), with lower values implying more points (and thus
better approximation and greatercomputational time).
</p>
</li>
<li> <p><code>convex.inner</code> (default = -0.4) and <code>convex.outer</code> (default = -0.7)
control the boundaries for the mesh. These should be negative values and can
be decreased (say to -0.7 and -1, respectively) to increase the distance
between the points and the outer boundary, which also increases precision and
computational time.
</p>
</li>
<li> <p><code>robust</code>. if <code>TRUE</code> then INLA will use a t prior distribution for
the coefficients of the linear predictor, rather than the default normal distribution.
</p>
</li>
<li> <p><code>h.value</code> (default=0.00005) controls the accuracy of the INLA
grid-search for the estimation of the hyperparameters. Lower values imply a
more refined search (and hence better accuracy), at the expense of
computational speed.
</p>
</li>
<li> <p><code>plot_inla_mesh</code> (default <code>FALSE</code>) Produce a plot of the mesh.
</p>
</li>
<li> <p><code>max.edge</code>  Largest allowed triangle edge length when constructing the
mesh, passed to <code><a href="INLA.html#topic+inla.mesh.2d">inla.mesh.2d</a></code>.
</p>
</li>
<li> <p><code>pfc_struc</code> Variance structure to pass to <code>pfc</code> in the <span class="pkg">ldr</span>
package for principal fitted components. The default <code>"AIC"</code> selects the
one that fits best given two basis terms.  Change this to, e.g. <code>"iso"</code>,
<code>"aniso"</code> or <code>"unstr"</code> if an &quot;Error in eigen...&quot; is obtained.
</p>
</li></ul>

<p>For any of the nonparametric regression methods:
</p>

<ul>
<li> <p><code>ref</code> The reference decision option used to define the
incremental net benefit, cost or effects before performing
nonparametric regression.  Either an integer column number, or the
name of the column from <code>outputs</code>.
</p>
</li></ul>

<p>For <code>method="so"</code>:
</p>

<ul>
<li> <p><code>n.blocks</code> Number of blocks to split the sample into. Required.
</p>
</li></ul>

<p>For <code>method="sal"</code>:
</p>

<ul>
<li> <p><code>n.seps</code> Number of separators (default 1).
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with a column <code>pars</code>, indicating the parameter(s),
and a column <code>evppi</code>, giving the corresponding EVPPI.
</p>
<p>If <code>outputs</code> is of &quot;cost-effectiveness analysis&quot; form, so that there is
one EVPPI per willingness-to-pay value, then a column <code>k</code> identifies the
willingness-to-pay.
</p>
<p>If standard errors are requested, then the standard errors are returned in
the column <code>se</code>.
</p>


<h3>References</h3>

<p>Strong, M., Oakley, J. E., &amp; Brennan, A. (2014). Estimating multiparameter
partial expected value of perfect information from a probabilistic
sensitivity analysis sample: a nonparametric regression approach. Medical
Decision Making, 34(3), 311-326.
</p>
<p>Heath, A., Manolopoulou, I., &amp; Baio, G. (2016). Estimating the expected
value of partial perfect information in health economic evaluations using
integrated nested Laplace approximation. Statistics in Medicine, 35(23),
4264-4280.
</p>
<p>Baio, G., Berardi, A., &amp; Heath, A. (2017). Bayesian cost-effectiveness
analysis with the R package BCEA. New York: Springer.
</p>
<p>Milborrow, S. (2019) earth: Multivariate Adaptive Regression Splines. R
package version 5.1.2. Derived from mda:mars by Trevor Hastie and Rob
Tibshirani. Uses Alan Miller's Fortran utilities with Thomas Lumley's leaps
wrapper. https://CRAN.R-project.org/package=earth.
</p>
<p>Strong, M., &amp; Oakley, J. E. (2013). An efficient method for computing
single-parameter partial expected value of perfect information. Medical
Decision Making, 33(6), 755-766. Chicago
</p>
<p>Sadatsafavi, M., Bansback, N., Zafari, Z., Najafzadeh, M., &amp; Marra, C.
(2013). Need for speed: an efficient algorithm for calculation of
single-parameter expected value of partial perfect information. Value in
Health, 16(2), 438-448.
</p>

<hr>
<h2 id='evppi_mc'>Traditional two-level Monte Carlo estimator of EVPPI.</h2><span id='topic+evppi_mc'></span>

<h3>Description</h3>

<p>Traditional two-level Monte Carlo estimator of the expected value of partial
perfect information from a decision-analytic model.  Only useful in the
simplest of examples.  For realistically complex examples, the methods
implemented in the <code><a href="#topic+evppi">evppi</a></code> function, based on regression,
will usually be much more computationally efficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evppi_mc(
  model_fn,
  par_fn,
  pars,
  nouter,
  ninner,
  k = NULL,
  mfargs = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evppi_mc_+3A_model_fn">model_fn</code></td>
<td>
<p>A function to evaluate a decision-analytic model at a given
set of parameters. This should have one argument per parameter, and return either:
</p>
<p>(net benefit format) a vector giving the net benefit for each decision
option, or
</p>
<p>(cost-effectiveness analysis format) a matrix or data frame with two rows,
and one column for each decision option.  If the rows have names
<code>"e"</code> and <code>"c"</code> then these are assumed to be the effects and
costs respectively.
</p>
<p>Otherwise, the first row is assumed to be the effects, and the second the
costs.</p>
</td></tr>
<tr><td><code id="evppi_mc_+3A_par_fn">par_fn</code></td>
<td>
<p>A function to generate a random sample of values for the
parameters of <code>model_fn</code>. This should return a matrix or a data frame
with named columns matching the arguments of <code>model_fn</code>.
</p>
<p>If any required arguments to <code>model_fn</code> are not supplied in this
return value, then <code>evppi_mc</code> looks for them in the list supplied as
the <code>mfargs</code> argument.
</p>
<p>If any required arguments are not found in the results of <code>par_fn</code> or
<code>mfargs</code>, and if <code>model_fn</code> defines default values for those
arguments, then those default values are used.
</p>
<p>The first argument of <code>par_fn</code> should be an integer <code>n</code> denoting
the number of random values to draw for each parameter.  The object
returned by <code>par_fn</code> should then have <code>n</code> rows, and one column
for each parameter. If one value is drawn, then <code>par_fn</code> is also
allowed to return a vector, but this should still be named.
</p>
<p>The parameters may be correlated.  If we wish to compute the EVPPI for a
parameter which is correlated with a different parameter q, then <code>par_fn</code>
must have an argument with the name of that parameter.  If that argument
is set to a fixed value, then <code>par_fn</code> should return a sample drawn
conditionally on that value.  If that argument is not supplied, then
<code>par_fn</code> must return a sample drawn from the marginal distribution. See
the vignette for an example.</p>
</td></tr>
<tr><td><code id="evppi_mc_+3A_pars">pars</code></td>
<td>
<p>A character vector giving the parameters of interest, for which
the EVPPI is required.   This should correspond to an explicit argument to
<code>model_fn</code>.
</p>
<p>The parameters of interest are assumed to have uncertainty distributions
that are independent of those of the other parameters.</p>
</td></tr>
<tr><td><code id="evppi_mc_+3A_nouter">nouter</code></td>
<td>
<p>Number of outer samples</p>
</td></tr>
<tr><td><code id="evppi_mc_+3A_ninner">ninner</code></td>
<td>
<p>Number of inner samples</p>
</td></tr>
<tr><td><code id="evppi_mc_+3A_k">k</code></td>
<td>
<p>Vector of willingness-to-pay values.  Only used if
<code>model_fn</code> is in cost-effectiveness analyis format.</p>
</td></tr>
<tr><td><code id="evppi_mc_+3A_mfargs">mfargs</code></td>
<td>
<p>Named list of additional arguments to supply to
<code>model_fn</code>.</p>
</td></tr>
<tr><td><code id="evppi_mc_+3A_verbose">verbose</code></td>
<td>
<p>Set to <code>TRUE</code> to print some additional messages to
help with debugging.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the <a href="https://chjackson.github.io/voi/articles/voi.html#evppimc">package overview / Get Started vignette</a> for an example of using this function.
</p>


<h3>Value</h3>

<p>A data frame with a column <code>pars</code>, indicating the parameter(s),
and a column <code>evppi</code>, giving the corresponding EVPPI.
</p>
<p>If <code>outputs</code> is of &quot;cost-effectiveness analysis&quot; form, so that there is
one EVPPI per willingness-to-pay value, then a column <code>k</code> identifies the
willingness-to-pay.
</p>

<hr>
<h2 id='evppivar'>Calculate the expected value of partial perfect information for an estimation problem</h2><span id='topic+evppivar'></span>

<h3>Description</h3>

<p>Calculate the expected value of partial perfect information for an estimation problem.  This computes the expected reduction in variance in some quantity of interest with perfect information about a parameter or parameters of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evppivar(
  outputs,
  inputs,
  pars = NULL,
  method = NULL,
  nsim = NULL,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evppivar_+3A_outputs">outputs</code></td>
<td>
<p>a vector of values for the quantity of interest, sampled from the uncertainty distribution of this quantity that is induced by the uncertainty about the parameters.   This can also be a data frame with one column.
</p>
<p>Typically this will come from a Monte Carlo sample, where we first sample from the uncertainty distributions of the parameters, and then compute the quantity of interest as a function of the parameters.  It might also be produced by a Markov Chain Monte Carlo sample from the joint distribution of parameters and outputs.</p>
</td></tr>
<tr><td><code id="evppivar_+3A_inputs">inputs</code></td>
<td>
<p>Matrix or data frame of samples from the uncertainty
distribution of the input parameters of the decision model.   The number
of columns should equal the number of parameters, and the columns should
be named.    This should have the same number of rows as there are samples
in <code>outputs</code>, and each row of the samples in <code>outputs</code> should
give the model output evaluated at the corresponding parameters.
</p>
<p>Users of <span class="pkg">heemod</span> can create an object of this form, given an object
produced by <code>run_psa</code> (<code>obj</code>, say), with <code><a href="#topic+import_heemod_inputs">import_heemod_inputs</a></code>.</p>
</td></tr>
<tr><td><code id="evppivar_+3A_pars">pars</code></td>
<td>
<p>Either a character vector, or a list of character vectors.
</p>
<p>If a character vector is supplied, then a single, joint EVPPI calculation is done with
for the parameters named in this vector.
</p>
<p>If a list of character vectors is supplied,  then multiple EVPPI calculations are
performed, one for each list component defined in the above
vector form.
</p>
<p><code>pars</code> must be specified if <code>inputs</code> is a matrix or data frame.
This should then correspond to particular columns of <code>inputs</code>.    If
<code>inputs</code> is a vector, this is assumed to define the single parameter
of interest, and then <code>pars</code> is not required.</p>
</td></tr>
<tr><td><code id="evppivar_+3A_method">method</code></td>
<td>
<p>Character string indicating the calculation method.  If one
string is supplied, this is used for all calculations.  A vector of different strings
can be supplied if a different method is desired for different list components
of <code>pars</code>.
</p>
<p>The default methods are based on nonparametric regression:
</p>
<p><code>"gam"</code> for a generalized additive model implemented in the <code><a href="mgcv.html#topic+gam">gam</a></code>
function from the <span class="pkg">mgcv</span> package.  This is the default method for
calculating the EVPPI of 4 or fewer parameters.
</p>
<p><code>"gp"</code> for a Gaussian process regression, as described by Strong et al.
(2014) and implemented in the <span class="pkg">SAVI</span> package
(<a href="https://github.com/Sheffield-Accelerated-VoI/SAVI">https://github.com/Sheffield-Accelerated-VoI/SAVI</a>).  This is the default method for calculating the EVPPI
of more than 4 parameters.
</p>
<p><code>"inla"</code> for an INLA/SPDE Gaussian process regression method, from
Heath et al. (2016).
</p>
<p><code>"bart"</code> for Bayesian additive regression trees, using the <span class="pkg">dbarts</span> package.
Particularly suited for joint EVPPI of many parameters.
</p>
<p><code>"earth"</code> for a multivariate adaptive regression spline with the
<span class="pkg">earth</span> package (Milborrow, 2019).
</p>
<p><code>"so"</code> for the method of Strong and Oakley (2013).  Only supported
for single parameter EVPPI.
</p>
<p><code>"sal"</code> for the method of Sadatsafavi et al. (2013).  Only supported
for single parameter EVPPI.</p>
</td></tr>
<tr><td><code id="evppivar_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulations from the decision model to use
for calculating EVPPI.  The first <code>nsim</code> rows of the
objects in <code>inputs</code> and <code>outputs</code> are used.</p>
</td></tr>
<tr><td><code id="evppivar_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, then messages are printed
describing each step of the calculation, if the method supplies
these.  Can be useful to see the progress of slow calculations.</p>
</td></tr>
<tr><td><code id="evppivar_+3A_...">...</code></td>
<td>
<p>Other arguments to control specific methods.
</p>
<p>For <code>method="gam"</code>, the following arguments can be supplied:
</p>

<ul>
<li> <p><code>gam_formula</code>: a character string giving the right hand side of the
formula supplied to the <code>gam()</code> function. By default, this is a tensor
product of all the parameters of interest, e.g. if <code>pars =
c("pi","rho")</code>, then <code>gam_formula</code> defaults to <code>t(pi, rho,
bs="cr")</code>.  The option <code>bs="cr"</code> indicates a cubic spline regression
basis, which is more computationally efficient than the default &quot;thin plate&quot;
basis.  If there are four or more parameters of interest, then the
additional argument <code>k=4</code> is supplied to <code>te()</code>, specifying a
four-dimensional basis, which is currently the default in the SAVI package.
</p>
<p>If there are spaces in the variable names in <code>inputs</code>, then these should
be converted to underscores before forming an explicit <code>gam_formula</code>.
</p>
</li></ul>

<p>For <code>method="gp"</code>, the following arguments can be supplied:
</p>

<ul>
<li> <p><code>gp_hyper_n</code>: number of samples to use to estimate the hyperparameters
in the Gaussian process regression method.  By default, this is the minimum
of the following three quantities: 30 times the number of parameters of
interest, 250, and the number of simulations being used for calculating
EVPPI.
</p>
</li>
<li> <p><code>maxSample</code>: Maximum sample size to employ for <code>method="gp"</code>.  Only
increase this from the default 5000 if your computer has sufficent memory to
invert square matrices with this dimension.
</p>
</li></ul>

<p>For <code>method="inla"</code>, the following arguments can be supplied, as described in detail in Baio, Berardi and Heath (2017):
</p>

<ul>
<li> <p><code>int.ord</code> (integer) maximum order of interaction terms to include in
the regression predictor, e.g. if <code>int.ord=k</code> then all k-way
interactions are used.  Currently this applies to both effects and costs.
</p>
</li>
<li> <p><code>cutoff</code> (default 0.3) controls the
density of the points inside the mesh in the spatial part of the mode.
Acceptable values are typically in
the interval (0.1,0.5), with lower values implying more points (and thus
better approximation and greatercomputational time).
</p>
</li>
<li> <p><code>convex.inner</code> (default = -0.4) and <code>convex.outer</code> (default = -0.7)
control the boundaries for the mesh. These should be negative values and can
be decreased (say to -0.7 and -1, respectively) to increase the distance
between the points and the outer boundary, which also increases precision and
computational time.
</p>
</li>
<li> <p><code>robust</code>. if <code>TRUE</code> then INLA will use a t prior distribution for
the coefficients of the linear predictor, rather than the default normal distribution.
</p>
</li>
<li> <p><code>h.value</code> (default=0.00005) controls the accuracy of the INLA
grid-search for the estimation of the hyperparameters. Lower values imply a
more refined search (and hence better accuracy), at the expense of
computational speed.
</p>
</li>
<li> <p><code>plot_inla_mesh</code> (default <code>FALSE</code>) Produce a plot of the mesh.
</p>
</li>
<li> <p><code>max.edge</code>  Largest allowed triangle edge length when constructing the
mesh, passed to <code><a href="INLA.html#topic+inla.mesh.2d">inla.mesh.2d</a></code>.
</p>
</li>
<li> <p><code>pfc_struc</code> Variance structure to pass to <code>pfc</code> in the <span class="pkg">ldr</span>
package for principal fitted components. The default <code>"AIC"</code> selects the
one that fits best given two basis terms.  Change this to, e.g. <code>"iso"</code>,
<code>"aniso"</code> or <code>"unstr"</code> if an &quot;Error in eigen...&quot; is obtained.
</p>
</li></ul>

<p>For any of the nonparametric regression methods:
</p>

<ul>
<li> <p><code>ref</code> The reference decision option used to define the
incremental net benefit, cost or effects before performing
nonparametric regression.  Either an integer column number, or the
name of the column from <code>outputs</code>.
</p>
</li></ul>

<p>For <code>method="so"</code>:
</p>

<ul>
<li> <p><code>n.blocks</code> Number of blocks to split the sample into. Required.
</p>
</li></ul>

<p>For <code>method="sal"</code>:
</p>

<ul>
<li> <p><code>n.seps</code> Number of separators (default 1).
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with a column <code>pars</code>, indicating the parameter(s), and a column <code>evppi</code>, giving the corresponding EVPPI.
</p>


<h3>References</h3>

<p>Jackson, C., Presanis, A., Conti, S., &amp; De Angelis, D. (2019). Value of information:
Sensitivity analysis and research design in Bayesian evidence synthesis.
Journal of the American Statistical Association, 114(528), 1436-1449.
</p>
<p>Jackson, C., Johnson, R., de Nazelle, A., Goel, R., de Sa, T. H.,
Tainio, M., &amp; Woodcock, J. (2021). A guide to value of information
methods for prioritising research in health impact
modelling. Epidemiologic Methods, 10(1).
</p>
<p>Jackson, C. H., Baio, G., Heath, A., Strong, M., Welton, N. J., &amp;
Wilson, E. C. (2022). Value of Information analysis in models to
inform health policy. Annual Review of Statistics and its
Application, 9, 95-118.
</p>

<hr>
<h2 id='evsi'>Calculate the expected value of sample information from a decision-analytic
model</h2><span id='topic+evsi'></span>

<h3>Description</h3>

<p>Calculate the expected value of sample information from a decision-analytic
model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evsi(
  outputs,
  inputs,
  study = NULL,
  datagen_fn = NULL,
  pars = NULL,
  pars_datagen = NULL,
  n = 100,
  aux_pars = NULL,
  method = NULL,
  likelihood = NULL,
  analysis_fn = NULL,
  analysis_args = NULL,
  model_fn = NULL,
  par_fn = NULL,
  Q = 50,
  npreg_method = "gam",
  nsim = NULL,
  verbose = FALSE,
  check = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evsi_+3A_outputs">outputs</code></td>
<td>
<p>This could take one of two forms
</p>
<p>&quot;net benefit&quot; form: a matrix or data frame of samples from the uncertainty
distribution of the expected net benefit.  The number of rows should equal
the number of samples, and the number of columns should equal the number
of decision options.
</p>
<p>&quot;cost-effectiveness analysis&quot; form: a list with the following named
components:
</p>
<p><code>"c"</code>: a matrix or data frame of samples from the distribution of
costs.  There should be one column for each decision option.
</p>
<p><code>"e"</code>: a matrix or data frame of samples from the distribution of
effects, likewise.
</p>
<p><code>"k"</code>: a vector of willingness-to-pay values.
</p>
<p>Objects of class <code>"bcea"</code>, as created by the <span class="pkg">BCEA</span> package, are in
this &quot;cost-effectiveness analysis&quot; format, therefore they may be supplied as
the <code>outputs</code> argument.
</p>
<p>Users of <span class="pkg">heemod</span> can create an object of this form, given an object
produced by <code>run_psa</code> (<code>obj</code>, say), with <code><a href="#topic+import_heemod_outputs">import_heemod_outputs</a></code>.
</p>
<p>If <code>outputs</code> is a matrix or data frame, it is assumed to be of &quot;net
benefit&quot; form.  Otherwise if it is a list, it is assumed to be of &quot;cost
effectiveness analysis&quot; form.</p>
</td></tr>
<tr><td><code id="evsi_+3A_inputs">inputs</code></td>
<td>
<p>Matrix or data frame of samples from the uncertainty
distribution of the input parameters of the decision model.   The number
of columns should equal the number of parameters, and the columns should
be named.    This should have the same number of rows as there are samples
in <code>outputs</code>, and each row of the samples in <code>outputs</code> should
give the model output evaluated at the corresponding parameters.
</p>
<p>Users of <span class="pkg">heemod</span> can create an object of this form, given an object
produced by <code>run_psa</code> (<code>obj</code>, say), with <code><a href="#topic+import_heemod_inputs">import_heemod_inputs</a></code>.</p>
</td></tr>
<tr><td><code id="evsi_+3A_study">study</code></td>
<td>
<p>Name of one of the built-in study types supported by this
package for EVSI calculation.  If this is supplied, then the columns of
<code>inputs</code> that correspond to the parameters governing the study data
should be identified in <code>pars</code>.
</p>
<p>Current built-in studies are
</p>
<p><code>"binary"</code> A study with a binary outcome observed on one sample of
individuals.   Requires one parameter: the probability of the outcome. The
sample size is specifed in the <code>n</code> argument to <code>evsi()</code>, and the
binomially-distributed outcome is named <code>X1</code>.
</p>
<p><code>"trial_binary"</code> Two-arm trial with a binary outcome.   Requires two
parameters: the probability of the outcome in arm 1 and 2 respectively.
The sample size is the same in each arm, specifed in the <code>n</code> argument
to <code>evsi()</code>, and the binomial outcomes are named <code>X1</code> and
<code>X2</code> respectively.
</p>
<p><code>"normal_known"</code> A study of a normally-distributed outcome, with a
known standard deviation, on one sample of individuals.  Likewise the
sample size is specified in the <code>n</code> argument to <code>evsi()</code>.  The
standard deviation defaults to 1, and can be changed by specifying
<code>sd</code> as a component of the <code>aux_pars</code> argument, e.g.
<code>evsi(..., aux_pars=list(sd=2))</code>.
</p>
<p>Either <code>study</code> or <code>datagen_fn</code> should be supplied to
<code>evsi()</code>.
</p>
<p>For the EVSI calculation methods where explicit Bayesian analyses of the
simulated data are performed, the prior parameters for these built-in studies
are supplied in the <code>analysis_args</code> argument to <code>evsi()</code>.  These
assume Beta priors for probabilities, and Normal priors for the mean of a
normal outcome.</p>
</td></tr>
<tr><td><code id="evsi_+3A_datagen_fn">datagen_fn</code></td>
<td>
<p>If the proposed study is not one of the built-in types
supported, it can be specified in this argument as an R function to sample
predicted data from the study.  This function should have the following
specification:
</p>

<ol>
<li><p> the function's first argument should be a data frame of parameter
simulations, with one row per simulation and one column per parameter.
The parameters in this data frame must all be found in <code>inputs</code>,
but need not necessarily be in the same order or include all of them.
</p>
</li>
<li><p> the function should return a data frame.
</p>
</li>
<li><p> the returned data frame should have number of rows equal to the number
of parameter simulations in <code>inputs</code>.
</p>
</li>
<li><p> if <code>inputs</code> is considered as a sample from the posterior, then
<code>datagen_fn(inputs)</code> returns a corresponding sample from the
posterior predictive distribution, which includes two sources of
uncertainty: (a) uncertainty about the parameters and (b) sampling
variation in observed data given fixed parameter values.
</p>
</li>
<li><p> the function can optionally have more than one argument. If so, these
additional arguments should be given default values in the definition of
<code>datagen_fn</code>.  If there is an argument called <code>n</code>, then it is
interpreted as the sample size for the proposed study.
</p>
</li></ol>
</td></tr>
<tr><td><code id="evsi_+3A_pars">pars</code></td>
<td>
<p>Character vector identifying which parameters are learned from the proposed study.
This is required for the moment matching and importance sampling methods,
and these should be columns of <code>inputs</code>.   This is not required for the nonparametric
regression methods.</p>
</td></tr>
<tr><td><code id="evsi_+3A_pars_datagen">pars_datagen</code></td>
<td>
<p>Character vector identifying which columns of <code>inputs</code> are
the parameters required to generate data from the proposed study.
These should be columns of <code>inputs</code>.
</p>
<p>If <code>pars_datagen</code> is not supplied, then it is assumed to be the same as <code>pars</code>.
Note that these can be different.  Even if the study data are generated by a particular parameter,
when analysing the data we could choose to ignore the information that the data provides about
that parameter.</p>
</td></tr>
<tr><td><code id="evsi_+3A_n">n</code></td>
<td>
<p>Sample size of future study, or vector of alternative sample sizes.
This is understood by the built-in study designs.  For studies specified
by the user with <code>datagen_fn</code>, if <code>datagen_fn</code> has an argument
<code>n</code>, then this is interpreted as the sample size.  However if
calling <code>evsi</code> for a user-specified design where
<code>datagen_fn</code> does not have an <code>n</code> argument, then any <code>n</code>
argument supplied to <code>evsi</code> will be ignored.
</p>
<p>Currently this
shortcut is not supported if more than one quantity is required to
describe the sample size, for example, trials with unbalanced arms.  In
that case, you will have to hard-code the required sample sizes into
<code>datagen_fn</code>.
</p>
<p>For the nonparametric regression and importance sampling methods, the
computation is simply repeated for each sample size supplied here.
</p>
<p>The moment matching method uses a regression model to estimate the
dependency of the EVSI on the sample size, hence to enable EVSI to be
calculated efficiently for any number of sample sizes (Heath et al. 2019).</p>
</td></tr>
<tr><td><code id="evsi_+3A_aux_pars">aux_pars</code></td>
<td>
<p>A list of additional fixed arguments to supply to the
function to generate the data, whether that is a built-in study design or user-defined
function supplied in <code>datagen_fn</code>.  For example, <code>evsi(..., aux_pars = list(sd=2))</code> defines the fixed
standard deviation in the <code>"normal_known"</code> model.</p>
</td></tr>
<tr><td><code id="evsi_+3A_method">method</code></td>
<td>
<p>Character string indicating the calculation method.  Defaults to <code>"gam"</code>.
</p>
<p>All the nonparametric regression methods supported for
<code><a href="#topic+evppi">evppi</a></code>, that is <code>"gam","gp","earth","inla"</code>, can also be
used for EVSI calculation by regressing on a summary statistic of the
predicted data (Strong et al 2015).
</p>
<p><code>"is"</code> for importance sampling (Menzies 2016)
</p>
<p><code>"mm"</code> for moment matching (Heath et al 2018)
</p>
<p>Note that the  <code>"is"</code> and <code>"mm"</code> methods are used in conjunction
with nonparametric regression, and the <code>gam_formula</code> argument can be
supplied to <code>evsi</code> to specify this regression - see
<code><a href="#topic+evppi">evppi</a></code> for documentation of this argument.</p>
</td></tr>
<tr><td><code id="evsi_+3A_likelihood">likelihood</code></td>
<td>
<p>Likelihood function, required (and only required) for the
importance sampling method when a study design other than one of the
built-in ones is used.  This should have two arguments, named as follows:
</p>
<p><code>Y</code>: a one-row data frame of predicted data. Columns are defined by different
outcomes in the data, with names matching the names of the data frame returned by
<code>datagen_fn</code>.
</p>
<p><code>inputs</code>. a data frame of simulated parameter values. Columns should correspond
to different variables in <code>inputs</code>.  The column names should all be
found in the names of <code>inputs</code>, though they do not have to be in the same
order, or include everything in <code>inputs</code>. The number or rows should be the same as
the number of rows in <code>inputs</code>.
</p>
<p>The function should return a vector whose length matches the number of
rows of the parameters data frame given as the second argument.   Each
element of the vector gives the likelihood of the corresponding set of
parameters, given the data in the first argument.  An example is given in
the vignette.
</p>
<p>The likelihood can optionally have a <code>n</code> argument, which is interpreted
as the sample size of the study.   If the <code>n</code>
argument to <code>evsi</code> is used then this is passed to the likelihood function.
Conversely any <code>n</code> argument to <code>evsi</code> will be ignored by a likelihood
function that does not have its own <code>n</code> argument.
</p>
<p>Note the definition of the likelihood should agree with the definition of
<code>datagen_fn</code> to define a consistent sampling distribution for the
data. No automatic check is performed for this.</p>
</td></tr>
<tr><td><code id="evsi_+3A_analysis_fn">analysis_fn</code></td>
<td>
<p>Function which fits a Bayesian model to the generated
data.   Required for <code>method="mm"</code> if a study design other than one
of the built-in ones is used.  This should be a function that takes the
following arguments:
</p>
<p><code>data</code>: A data frame with names matching the output of <code>datagen_fn</code>
</p>
<p><code>args</code>: A list with constants required in the Bayesian analysis, e.g.
prior parameters, or options for the analysis, e.g. number of MCMC
simulations. The component of this list called <code>n</code> is assumed to
contain the sample size of the study.
</p>
<p><code>pars</code> Names of the parameters whose posterior is being sampled.
</p>
<p>The function should return a data frame with names matching <code>pars</code>,
containing a sample from the posterior distribution of the parameters
given data supplied through <code>data</code>.
</p>
<p><code>analysis_fn</code> is required to have all three of these arguments, but you do
not need to use any elements of <code>args</code> or <code>pars</code> in the body of
<code>analysis_fn</code>.  Instead, sample sizes, prior parameters, MCMC options and
parameter names can alternatively be hard-coded inside <code>analysis_fn</code>. Passing these
through the function arguments (via the <code>analysis_args</code> argument to
<code>evsi</code>) is only necessary if we want to use the same <code>analysis_fn</code> to
do EVSI calculations with different sample sizes or other settings.</p>
</td></tr>
<tr><td><code id="evsi_+3A_analysis_args">analysis_args</code></td>
<td>
<p>List of arguments required for the Bayesian analysis of
the predicted data, e.g. definitions of the prior and options to control
sampling.  Only used in <code>method="mm"</code>.  This is required if the study
design is one of the built-in ones specified in <code>study</code>.  If a custom
design is specifed through <code>analysis_fn</code>, then any constants needed
in <code>analysis_fn</code> can either be supplied in <code>analysis_args</code>, or hard-coded
in <code>analysis_fn</code> itself.
</p>
<p>For the built-in designs, the lists should have the following named
components. An optional component <code>niter</code> in each case defines the
posterior sample size (default 1000).
</p>
<p><code>study="binary"</code>: <code>a</code> and <code>b</code>: Beta shape parameters
</p>
<p><code>study="trial_binary"</code>: <code>a1</code> and <code>b1</code>: Beta shape parameters for the prior
for the first arm,  <code>a2</code> and <code>b2</code>: Beta shape parameters for the prior for
the second arm.
</p>
<p><code>study="normal_known"</code>: <code>prior_mean</code>, <code>prior_sd</code> (mean and standard deviation
deviation of the Normal prior) and <code>sampling_sd</code> (SD of an individual-level normal
observation, so that the sampling SD of the mean outcome over the study is
<code>sampling_sd/sqrt(n)</code>.</p>
</td></tr>
<tr><td><code id="evsi_+3A_model_fn">model_fn</code></td>
<td>
<p>Function which evaluates the decision-analytic model, given
parameter values.  Required for <code>method="mm"</code>.  See
<code><a href="#topic+evppi_mc">evppi_mc</a></code> for full documentation of the required specification
of this function.</p>
</td></tr>
<tr><td><code id="evsi_+3A_par_fn">par_fn</code></td>
<td>
<p>Function to simulate values from the uncertainty distributions
of parameters needed by the decision-analytic model.  Should take one
argument and return a data frame with one row for each simulated value,
and one column for each parameter.  See <code><a href="#topic+evppi_mc">evppi_mc</a></code> for full
specification.</p>
</td></tr>
<tr><td><code id="evsi_+3A_q">Q</code></td>
<td>
<p>Number of quantiles to use in <code>method="mm"</code>.</p>
</td></tr>
<tr><td><code id="evsi_+3A_npreg_method">npreg_method</code></td>
<td>
<p>Method to use to calculate the EVPPI, for those methods
that require it.  This is passed to <code><a href="#topic+evppi">evppi</a></code> as the
<code>method</code> argument.</p>
</td></tr>
<tr><td><code id="evsi_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulations from the model to use for calculating
EVPPI.  The first <code>nsim</code> rows of the objects in <code>inputs</code> and
<code>outputs</code> are used.</p>
</td></tr>
<tr><td><code id="evsi_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, then messages are printed
describing each step of the calculation, if the method supplies
these.  Can be useful to see the progress of slow calculations.</p>
</td></tr>
<tr><td><code id="evsi_+3A_check">check</code></td>
<td>
<p>If <code>TRUE</code>, then extra information about the estimation
is saved inside the object that this function returns.  This currently
only applies to the regression-based methods <code>"gam"</code> and <code>"earth"</code>
where the fitted regression model objects are saved.  This allows use
of the <code><a href="#topic+check_regression">check_regression</a></code> function, which produces some
diagnostic checks of the regression models.</p>
</td></tr>
<tr><td><code id="evsi_+3A_...">...</code></td>
<td>
<p>Other arguments understood by specific methods, e.g. <code>gam_formula</code>
and other controlling options (see <code><a href="#topic+evppi">evppi</a></code>) can be passed to the
nonparametric regression used inside the moment matching method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the <a href="https://chjackson.github.io/voi/articles/voi.html#evsi">package overview / Get Started vignette</a> for some examples of using this function.
</p>


<h3>Value</h3>

<p>A data frame with a column <code>pars</code>, indicating the
parameter(s), and a column <code>evsi</code>, giving the corresponding
EVPPI.  If the EVSI for multiple sample sizes was requested,
then the sample size is returned in the column <code>n</code>, and if
<code>outputs</code> is of &quot;cost-effectiveness analysis&quot; form, so that
there is one EVPPI per willingness-to-pay value, then a column
<code>k</code> identifies the willingness-to-pay.
</p>


<h3>References</h3>

<p>Strong, M., Oakley, J. E., Brennan, A., &amp; Breeze, P. (2015). Estimating the
expected value of sample information using the probabilistic sensitivity
analysis sample: a fast, nonparametric regression-based method. Medical
Decision Making, 35(5), 570-583.
</p>
<p>Menzies, N. A. (2016). An efficient estimator for the expected value of
sample information. Medical Decision Making, 36(3), 308-320.
</p>
<p>Heath, A., Manolopoulou, I., &amp; Baio, G. (2018). Efficient Monte Carlo
estimation of the expected value of sample information using moment
matching. Medical Decision Making, 38(2), 163-173.
</p>
<p>Heath, A., Manolopoulou, I., &amp; Baio, G. (2019). Estimating the expected
value of sample information across different sample sizes using moment
matching and nonlinear regression. Medical Decision Making, 39(4), 347-359.
</p>

<hr>
<h2 id='evsivar'>Calculate the expected value of sample information for an estimation problem</h2><span id='topic+evsivar'></span>

<h3>Description</h3>

<p>Calculate the expected value of sample information for an estimation problem.  This computes the expected reduction in variance in some quantity of interest from a study of a certain design that informs the parameters of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evsivar(
  outputs,
  inputs,
  study = NULL,
  datagen_fn = NULL,
  pars = NULL,
  n = 100,
  aux_pars = NULL,
  method = NULL,
  nsim = NULL,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evsivar_+3A_outputs">outputs</code></td>
<td>
<p>a vector of values for the quantity of interest, sampled from the uncertainty distribution of this quantity that is induced by the uncertainty about the parameters.</p>
</td></tr>
<tr><td><code id="evsivar_+3A_inputs">inputs</code></td>
<td>
<p>Matrix or data frame of samples from the uncertainty
distribution of the input parameters of the decision model.   The number
of columns should equal the number of parameters, and the columns should
be named.    This should have the same number of rows as there are samples
in <code>outputs</code>, and each row of the samples in <code>outputs</code> should
give the model output evaluated at the corresponding parameters.
</p>
<p>Users of <span class="pkg">heemod</span> can create an object of this form, given an object
produced by <code>run_psa</code> (<code>obj</code>, say), with <code><a href="#topic+import_heemod_inputs">import_heemod_inputs</a></code>.</p>
</td></tr>
<tr><td><code id="evsivar_+3A_study">study</code></td>
<td>
<p>Name of one of the built-in study types supported by this
package for EVSI calculation.  If this is supplied, then the columns of
<code>inputs</code> that correspond to the parameters governing the study data
should be identified in <code>pars</code>.
</p>
<p>Current built-in studies are
</p>
<p><code>"binary"</code> A study with a binary outcome observed on one sample of
individuals.   Requires one parameter: the probability of the outcome. The
sample size is specifed in the <code>n</code> argument to <code>evsi()</code>, and the
binomially-distributed outcome is named <code>X1</code>.
</p>
<p><code>"trial_binary"</code> Two-arm trial with a binary outcome.   Requires two
parameters: the probability of the outcome in arm 1 and 2 respectively.
The sample size is the same in each arm, specifed in the <code>n</code> argument
to <code>evsi()</code>, and the binomial outcomes are named <code>X1</code> and
<code>X2</code> respectively.
</p>
<p><code>"normal_known"</code> A study of a normally-distributed outcome, with a
known standard deviation, on one sample of individuals.  Likewise the
sample size is specified in the <code>n</code> argument to <code>evsi()</code>.  The
standard deviation defaults to 1, and can be changed by specifying
<code>sd</code> as a component of the <code>aux_pars</code> argument, e.g.
<code>evsi(..., aux_pars=list(sd=2))</code>.
</p>
<p>Either <code>study</code> or <code>datagen_fn</code> should be supplied to
<code>evsi()</code>.
</p>
<p>For the EVSI calculation methods where explicit Bayesian analyses of the
simulated data are performed, the prior parameters for these built-in studies
are supplied in the <code>analysis_args</code> argument to <code>evsi()</code>.  These
assume Beta priors for probabilities, and Normal priors for the mean of a
normal outcome.</p>
</td></tr>
<tr><td><code id="evsivar_+3A_datagen_fn">datagen_fn</code></td>
<td>
<p>If the proposed study is not one of the built-in types
supported, it can be specified in this argument as an R function to sample
predicted data from the study.  This function should have the following
specification:
</p>

<ol>
<li><p> the function's first argument should be a data frame of parameter
simulations, with one row per simulation and one column per parameter.
The parameters in this data frame must all be found in <code>inputs</code>,
but need not necessarily be in the same order or include all of them.
</p>
</li>
<li><p> the function should return a data frame.
</p>
</li>
<li><p> the returned data frame should have number of rows equal to the number
of parameter simulations in <code>inputs</code>.
</p>
</li>
<li><p> if <code>inputs</code> is considered as a sample from the posterior, then
<code>datagen_fn(inputs)</code> returns a corresponding sample from the
posterior predictive distribution, which includes two sources of
uncertainty: (a) uncertainty about the parameters and (b) sampling
variation in observed data given fixed parameter values.
</p>
</li>
<li><p> the function can optionally have more than one argument. If so, these
additional arguments should be given default values in the definition of
<code>datagen_fn</code>.  If there is an argument called <code>n</code>, then it is
interpreted as the sample size for the proposed study.
</p>
</li></ol>
</td></tr>
<tr><td><code id="evsivar_+3A_pars">pars</code></td>
<td>
<p>Character vector identifying which parameters are learned from the proposed study.
This is required for the moment matching and importance sampling methods,
and these should be columns of <code>inputs</code>.   This is not required for the nonparametric
regression methods.</p>
</td></tr>
<tr><td><code id="evsivar_+3A_n">n</code></td>
<td>
<p>Sample size of future study, or vector of alternative sample sizes.
This is understood by the built-in study designs.  For studies specified
by the user with <code>datagen_fn</code>, if <code>datagen_fn</code> has an argument
<code>n</code>, then this is interpreted as the sample size.  However if
calling <code>evsi</code> for a user-specified design where
<code>datagen_fn</code> does not have an <code>n</code> argument, then any <code>n</code>
argument supplied to <code>evsi</code> will be ignored.
</p>
<p>Currently this
shortcut is not supported if more than one quantity is required to
describe the sample size, for example, trials with unbalanced arms.  In
that case, you will have to hard-code the required sample sizes into
<code>datagen_fn</code>.
</p>
<p>For the nonparametric regression and importance sampling methods, the
computation is simply repeated for each sample size supplied here.
</p>
<p>The moment matching method uses a regression model to estimate the
dependency of the EVSI on the sample size, hence to enable EVSI to be
calculated efficiently for any number of sample sizes (Heath et al. 2019).</p>
</td></tr>
<tr><td><code id="evsivar_+3A_aux_pars">aux_pars</code></td>
<td>
<p>A list of additional fixed arguments to supply to the
function to generate the data, whether that is a built-in study design or user-defined
function supplied in <code>datagen_fn</code>.  For example, <code>evsi(..., aux_pars = list(sd=2))</code> defines the fixed
standard deviation in the <code>"normal_known"</code> model.</p>
</td></tr>
<tr><td><code id="evsivar_+3A_method">method</code></td>
<td>
<p>See <code><a href="#topic+evsi">evsi</a></code>, only nonparametric regression methods are
currently supported in <code><a href="#topic+evsivar">evsivar</a></code>.</p>
</td></tr>
<tr><td><code id="evsivar_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulations from the model to use for calculating
EVPPI.  The first <code>nsim</code> rows of the objects in <code>inputs</code> and
<code>outputs</code> are used.</p>
</td></tr>
<tr><td><code id="evsivar_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, then messages are printed
describing each step of the calculation, if the method supplies
these.  Can be useful to see the progress of slow calculations.</p>
</td></tr>
<tr><td><code id="evsivar_+3A_...">...</code></td>
<td>
<p>Other arguments understood by specific methods, e.g. <code>gam_formula</code>
and other controlling options (see <code><a href="#topic+evppi">evppi</a></code>) can be passed to the
nonparametric regression used inside the moment matching method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with a column <code>pars</code>, indicating the parameter(s), and a column <code>evsi</code>, giving the corresponding EVSI.  If there are EVSI estimates for multiple sample sizes, the sample size is returned in the column <code>n</code>.
</p>


<h3>References</h3>

<p>Jackson, C., Presanis, A., Conti, S., &amp; De Angelis, D. (2019). Value of information:
Sensitivity analysis and research design in Bayesian evidence synthesis.
Journal of the American Statistical Association, 114(528), 1436-1449.
</p>

<hr>
<h2 id='form_nbarray'>Convert either &quot;net benefit&quot; or &quot;cost-effectiveness&quot; forms for
'outputs' to a 3D array  (number of simulations, x number of
willingness-to-pay values, x number of decision options) with one
WTP value when <code>outputs</code> is in &quot;net benefit&quot; form.</h2><span id='topic+form_nbarray'></span>

<h3>Description</h3>

<p>Convert either &quot;net benefit&quot; or &quot;cost-effectiveness&quot; forms for
'outputs' to a 3D array  (number of simulations, x number of
willingness-to-pay values, x number of decision options) with one
WTP value when <code>outputs</code> is in &quot;net benefit&quot; form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>form_nbarray(outputs)
</code></pre>

<hr>
<h2 id='import_heemod'>Import results of probabilistic analysis from heemod</h2><span id='topic+import_heemod'></span><span id='topic+import_heemod_outputs'></span><span id='topic+import_heemod_inputs'></span>

<h3>Description</h3>

<p><a href="https://CRAN.R-project.org/package=heemod">heemod</a> is a package
for constructing common forms of health economic decision models.
The outputs from probabilistic analysis of these models can be
imported using these functions, to allow Value of Information
measures to be calculated for them using the <span class="pkg">voi</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import_heemod_outputs(obj, k = NULL)

import_heemod_inputs(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="import_heemod_+3A_obj">obj</code></td>
<td>
<p>Object returned by the <code><a href="heemod.html#topic+run_psa">run_psa</a></code>
function in <span class="pkg">heemod</span>, containing samples from probabilistic
analysis of a decision model.</p>
</td></tr>
<tr><td><code id="import_heemod_+3A_k">k</code></td>
<td>
<p>Vector of willingness-to-pay values.  The default is
inherited from the <code><a href="BCEA.html#topic+bcea">bcea</a></code> function from the <span class="pkg">BCEA</span>
package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>import_heemod_outputs</code> produces a list of model
outputs in &quot;cost-effectiveness analysis&quot; format, that can be
supplied as the <code>outputs</code> argument to <code><a href="#topic+evppi">evppi</a></code>
and similar functions in the <span class="pkg">voi</span> package.  Both the
<span class="pkg">heemod</span> and <span class="pkg">BCEA</span> packages need to be installed to use
this.
</p>
<p><code>import_heemod_inputs</code> produces a data frame with samples of
parameter values under uncertainty, that can be supplied as the
<code>inputs</code> argument to <code><a href="#topic+evppi">evppi</a></code> and similar functions
in <span class="pkg">voi</span>.
</p>

<hr>
<h2 id='plot.evppi'>Plot EVPPI estimates</h2><span id='topic+plot.evppi'></span>

<h3>Description</h3>

<p>Plot EVPPI estimates as simple dot or curve plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'evppi'
plot(x, type = NULL, order = FALSE, top = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.evppi_+3A_x">x</code></td>
<td>
<p>Object returned from <code><a href="#topic+evppi">evppi</a></code>.</p>
</td></tr>
<tr><td><code id="plot.evppi_+3A_type">type</code></td>
<td>
<p><code>"dots"</code> for a dot plot of the EVPPI by parameter.  If <code>x</code> includes multiple
willingness-to-pay values for the same parameter, these are shown as multiple dots.
</p>
<p><code>"curves"</code> for a plot of EVPPI against willingness-to-pay, with different
parameters distinguished as different curves.  This is only applicable if there
are multiple willingness-to-pay values included in <code>x</code>.</p>
</td></tr>
<tr><td><code id="plot.evppi_+3A_order">order</code></td>
<td>
<p>For dot plots, order the plot with highest EVPPI values at the top.</p>
</td></tr>
<tr><td><code id="plot.evppi_+3A_top">top</code></td>
<td>
<p>A positive integer. If specified, for example as <code>top=5</code> then only
five parameters are included in the plot, those with the top five maximum EVPPI
values by parameter.</p>
</td></tr>
<tr><td><code id="plot.evppi_+3A_...">...</code></td>
<td>
<p>Other arguments (currently unused).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These plotting functions are intended for quick interactive exploration of
EVPPI results, so they deliberately have limited options for customising them.
</p>
<p>For publication quality graphics, it is advised to use <code>ggplot2</code> by hand
on the data returned by <code>evppi</code>.   Examine the code for <code>plot_evppi_dots</code>
and <code>plot_evppi_curves</code> to see how these plots might be constructed.
</p>


<h3>Value</h3>

<p>A <code>ggplot2</code> object.
</p>

<hr>
<h2 id='pop_voi'>Population expected value of information</h2><span id='topic+pop_voi'></span>

<h3>Description</h3>

<p>Convert per-person expected value of information to the population
expected value of information, given a discount rate over some
time horizon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pop_voi(voi, pop, time, dis = 0.035)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pop_voi_+3A_voi">voi</code></td>
<td>
<p>Vector of estimates of any per-person value of information
measure, e.g. the <code>evsi</code> column of the data frame returned by
<code><a href="#topic+evsi">evsi</a></code> or the correspondingly-named columns of the
data frames returned by <code><a href="#topic+evppi">evppi</a></code> or <code><a href="#topic+evpi">evpi</a></code>.</p>
</td></tr>
<tr><td><code id="pop_voi_+3A_pop">pop</code></td>
<td>
<p>Size of the population who would be affected by the decision.</p>
</td></tr>
<tr><td><code id="pop_voi_+3A_time">time</code></td>
<td>
<p>Time horizon over which discounting will be applied.</p>
</td></tr>
<tr><td><code id="pop_voi_+3A_dis">dis</code></td>
<td>
<p>Discount rate used when converting per-person to population EVSI.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculated as <code>voi*pop/dis*(1 - exp(-dis*time))</code>, or <code>voi*pop</code>
if the discount rate is zero.  This is a continuous-time variant
of the typical discrete-time discounting formula.
</p>
<p>Any arguments may be supplied as vectors, in which case, all
arguments are replicated to the length of the longest argument.
</p>


<h3>Value</h3>

<p>A vector of population VoI estimates.
</p>

<hr>
<h2 id='voi-package'>Methods to calculate the Expected Value of Information</h2><span id='topic+voi-package'></span>

<h3>Description</h3>

<p><code><a href="#topic+evppi">evppi</a></code> calculates the expected value of partial perfect information from a decision-analytic model.  The default, recommended computation methods are based on nonparametric regression.  <code><a href="#topic+evpi">evpi</a></code> is also provided for the expected value of perfect information.
</p>
<p><code><a href="#topic+evsi">evsi</a></code> calculates the expected value of sample information.   Currently this implements the same set of nonparametric regression methods as in <code><a href="#topic+evppi">evppi</a></code>, and methods based on moment matching and importance sampling.  <code><a href="#topic+enbs">enbs</a></code> can then be used to calculate and optimise the expected net benefit of sampling for a simple study with a fixed upfront cost and per-participant costs.
</p>
<p><code><a href="#topic+evppi">evppi</a></code> and <code><a href="#topic+evsi">evsi</a></code> both require a sample of inputs and outputs from a Monte Carlo probabilistic analysis of a decision-analytic model.
</p>
<p>Analogous functions <code><a href="#topic+evppivar">evppivar</a></code> and <code><a href="#topic+evsivar">evsivar</a></code> calculate the EVPPI and EVSI for models used for estimation rather than decision-making.   The value of information is measured by expected reductions in variance of an uncertain model output of interest.
</p>
<p>A pure &quot;brute-force&quot; Monte Carlo method for EVPPI calculation is provided in <code><a href="#topic+evppi_mc">evppi_mc</a></code>, though this is usually computationally impractical.
</p>
<p>The <a href="https://chjackson.github.io/voi/articles/voi.html">package overview / Get Started vignette</a> gives worked examples of the use of all of these functions.
</p>


<h3>References</h3>

<p>Heath, A., Manolopoulou, I., &amp; Baio, G. (2017). A review of methods for analysis of the expected value of information. Medical Decision Making, 37(7), 747-758.
</p>
<p>Heath, A., Kunst, N., Jackson, C., Strong, M., Alarid-Escudero, F., Goldhaber-Fiebert, J. D., Baio, G. Menzies, N.A, Jalal, H. (2020). Calculating the Expected Value of Sample Information in Practice: Considerations from 3 Case Studies. Medical Decision Making, 40(3), 314-326.
</p>
<p>Kunst, N., Wilson, E. C., Glynn, D., Alarid-Escudero, F., Baio, G., Brennan, A., Fairley, M., Glynn, D., Goldhaber-Fiebert, J. D., Jackson, C., Jalal, H., Menzies, N. A., Strong, M., Thom, H., Heath, A. (2020). Computing the Expected Value of Sample Information Efficiently: Practical Guidance and Recommendations for Four Model-Based Methods. Value in Health, 3(6), 734-742.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
