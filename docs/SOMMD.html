<!DOCTYPE html><html lang="en"><head><title>Help for package SOMMD</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SOMMD}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#average.neur.property'><p>Compute average property</p></a></li>
<li><a href='#calc.distances'><p>calc.distances</p></a></li>
<li><a href='#calc.dists'><p>Calculation of Distances</p></a></li>
<li><a href='#cat.trj'><p>Concatenate simulations</p></a></li>
<li><a href='#cluster.pathways'><p>Clustering of Pathways</p></a></li>
<li><a href='#cluster.representatives'><p>Cluster Representatives</p></a></li>
<li><a href='#comp.trans.mat'><p>Compute transition matrix</p></a></li>
<li><a href='#fit.trj'><p>Coordinate superposition</p></a></li>
<li><a href='#map.color'><p>Map the property vector to colours</p></a></li>
<li><a href='#matrix2graph'><p>Convert transition matrix to an igraph object</p></a></li>
<li><a href='#native.cont'><p>Select native contact distances</p></a></li>
<li><a href='#neur.population'><p>Get Neuron Population</p></a></li>
<li><a href='#neur.representatives'><p>Neuron representative</p></a></li>
<li><a href='#print.struct'><p>print.struct</p></a></li>
<li><a href='#print.trj'><p>Print Trajectory</p></a></li>
<li><a href='#read.gro'><p>Read gro file</p></a></li>
<li><a href='#read.struct'><p>Read structure files</p></a></li>
<li><a href='#read.trj'><p>Read trj file</p></a></li>
<li><a href='#remap.data'><p>map data to existing SOM</p></a></li>
<li><a href='#rio_read_xtc'><p>Read xtc trajectory file</p></a></li>
<li><a href='#rio_read_xtc_natoms'><p>Read xtc trajectory file</p></a></li>
<li><a href='#rio_read_xtc_nframes'><p>Read xtc trajectory file</p></a></li>
<li><a href='#rio_read_xtc2xyz'><p>Read xtc trajectory file</p></a></li>
<li><a href='#rio_write_xtc'><p>Write xtc trajectory file</p></a></li>
<li><a href='#silhouette.profile'><p>Silhouette profile</p></a></li>
<li><a href='#silhouette.score'><p>Silhouette score</p></a></li>
<li><a href='#som.add.circles'><p>Add circles to SOM</p></a></li>
<li><a href='#som.add.clusters.legend'><p>Add legend clusters</p></a></li>
<li><a href='#som.add.numbers'><p>Add Neuron Numbering</p></a></li>
<li><a href='#stride.trj'><p>Stride a trj</p></a></li>
<li><a href='#struct2pdb'><p>Convert structure to pdb object</p></a></li>
<li><a href='#summary.struct'><p>Summarizing a structure object</p></a></li>
<li><a href='#summary.trj'><p>Summarizing a trajectory object</p></a></li>
<li><a href='#trace.path'><p>Trace pathway</p></a></li>
<li><a href='#trj2pdb'><p>Extract frame to pdb</p></a></li>
<li><a href='#trj2xyz'><p>Convert Trajectory to xyz</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Self Organising Maps for the Analysis of Molecular Dynamics Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Processes data from Molecular Dynamics simulations using 
    Self Organising Maps. Features include the ability to read different 
    input formats. Trajectories can be analysed to identify groups of important
    frames. Output visualisation can be generated for maps and pathways.
    Methodological details can be found in Motta S et al (2022) 
    &lt;<a href="https://doi.org/10.1021%2Facs.jctc.1c01163">doi:10.1021/acs.jctc.1c01163</a>&gt;.
    I/O functions for xtc format files were implemented using the 'xdrfile'
    library available under open source license. The relevant information can 
    be found in inst/COPYRIGHT.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>bio3d, kohonen, abind, cluster, methods, igraph</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-10-01 07:52:26 UTC; apandini</td>
</tr>
<tr>
<td>Author:</td>
<td>Alessandro Pandini
    <a href="https://orcid.org/0000-0002-4158-233X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cph],
  Stefano Motta <a href="https://orcid.org/0000-0002-0812-6834"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Erik Lindahl [ctb] (Author of xdrfile C library),
  David van der Spoel [ctb] (Author of xdrfile C library)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Stefano Motta &lt;stefano.motta@unimib.it&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-10-02 13:50:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='average.neur.property'>Compute average property</h2><span id='topic+average.neur.property'></span>

<h3>Description</h3>

<p>Function to compute the average value of a property for each neuron.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>average.neur.property(SOM, P)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="average.neur.property_+3A_som">SOM</code></td>
<td>
<p>the SOM object to cluster</p>
</td></tr>
<tr><td><code id="average.neur.property_+3A_p">P</code></td>
<td>
<p>the property for each frame of the simulation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The a vector with the per-neuron average of the property.
</p>


<h3>Author(s)</h3>

<p>Stefano Motta <a href="mailto:stefano.motta@unimib.it">stefano.motta@unimib.it</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Read trajectory
trj &lt;- read.trj(trjfile = system.file("extdata", "HIF2a-MD.xtc", package = "SOMMD"),
  topfile = system.file("extdata", "HIF2a.gro", package = "SOMMD"))
#Read example SOM data
som_model &lt;- readRDS(system.file("extdata", "SOM_HIFa.rds", package = "SOMMD"))
#Compute distance between two atoms in every frame of the simulation
Distance &lt;- apply(trj$coord[c(162,1794),,], 3, dist)
#Compute average property value for each neuron
avg.p &lt;- average.neur.property(som_model, Distance)

</code></pre>

<hr>
<h2 id='calc.distances'>calc.distances</h2><span id='topic+calc.distances'></span>

<h3>Description</h3>

<p>Function to compute distances to be used to train the SOM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc.distances(trj, mol.2 = FALSE, sele = FALSE, atoms = NULL, cap = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc.distances_+3A_trj">trj</code></td>
<td>
<p>contains the trajectory coordinates (array with three dimensions obtained by rioxdr)</p>
</td></tr>
<tr><td><code id="calc.distances_+3A_mol.2">mol.2</code></td>
<td>
<p>contains the atom indexes of the second molecule in case only intermolecular distances should be computed</p>
</td></tr>
<tr><td><code id="calc.distances_+3A_sele">sele</code></td>
<td>
<p>contains the selection of distances coming from the native_contacts function</p>
</td></tr>
<tr><td><code id="calc.distances_+3A_atoms">atoms</code></td>
<td>
<p>contains a list of atoms indexes on which the distances will be computed</p>
</td></tr>
<tr><td><code id="calc.distances_+3A_cap">cap</code></td>
<td>
<p>If a number is given, distances greater than this value are set at the cap value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the set of distances computed for all the frames.
</p>


<h3>Author(s)</h3>

<p>Stefano Motta <a href="mailto:stefano.motta@unimib.it">stefano.motta@unimib.it</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Read reference structure file with native conformation
struct &lt;- read.struct(system.file("extdata", "HIF2a.gro", package = "SOMMD"))
# Read the trajectory
trj &lt;- read.trj(trjfile = system.file("extdata", "HIF2a-MD.xtc", package = "SOMMD"),
  topfile = system.file("extdata", "HIF2a.gro", package = "SOMMD"))
# Select only Cbeta atoms to perform the analysis
sele_atoms &lt;- which(trj$top$elety=="CB")
# Choose only native contacts
sele_dists &lt;- native.cont(struct=struct, distance=1.0, atoms=sele_atoms)
# Compute distances for SOM training.
DIST &lt;- calc.distances(trj, mol.2=FALSE, sele=sele_dists, atoms=sele_atoms)

</code></pre>

<hr>
<h2 id='calc.dists'>Calculation of Distances</h2><span id='topic+calc.dists'></span>

<h3>Description</h3>

<p>Compute the pairwise distance matrix of a given set of coordinates, and only retain to some selected distances
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc.dists(coord, mol.1_id = FALSE, mol.2_id = FALSE, sele = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc.dists_+3A_coord">coord</code></td>
<td>
<p>matrix of N atomic coordinates (N rows, 3 columns)</p>
</td></tr>
<tr><td><code id="calc.dists_+3A_mol.1_id">mol.1_id</code></td>
<td>
<p>vector containing the index of the first molecule for intermolecular distances only</p>
</td></tr>
<tr><td><code id="calc.dists_+3A_mol.2_id">mol.2_id</code></td>
<td>
<p>vector containing the index of the second molecule for intermolecular distances only</p>
</td></tr>
<tr><td><code id="calc.dists_+3A_sele">sele</code></td>
<td>
<p>contains the selection of distances coming from the native_contacts function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix contaning the selected distances for a frame
</p>


<h3>Author(s)</h3>

<p>Stefano Motta<a href="mailto:stefano.motta@unimib.it">stefano.motta@unimib.it</a>
</p>

<hr>
<h2 id='cat.trj'>Concatenate simulations</h2><span id='topic+cat.trj'></span>

<h3>Description</h3>

<p>Function to concatenate two simulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cat.trj(trj1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cat.trj_+3A_trj1">trj1</code></td>
<td>
<p>the first trj file</p>
</td></tr>
<tr><td><code id="cat.trj_+3A_...">...</code></td>
<td>
<p>additional trj files</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A trj object with the simulations concatenated
</p>


<h3>Author(s)</h3>

<p>Stefano Motta <a href="mailto:stefano.motta@unimib.it">stefano.motta@unimib.it</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Read the simulations
trj1 &lt;- read.trj(trjfile = system.file("extdata", "HIF2a-MD.xtc", package = "SOMMD"),
  topfile = system.file("extdata", "HIF2a.gro", package = "SOMMD"))
trj2 &lt;- read.trj(trjfile = system.file("extdata", "HIF2a-MD-2.xtc", package = "SOMMD"),
  topfile = system.file("extdata", "HIF2a.gro", package = "SOMMD"))
# Concatenate the simulations
  trj &lt;- cat.trj(trj1, trj2)

</code></pre>

<hr>
<h2 id='cluster.pathways'>Clustering of Pathways</h2><span id='topic+cluster.pathways'></span>

<h3>Description</h3>

<p>Cluster pathways according to a time dependent or independent scheme
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster.pathways(
  SOM,
  start,
  end,
  time.dep = "independent",
  method = "complete"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cluster.pathways_+3A_som">SOM</code></td>
<td>
<p>a kohonen SOM object.</p>
</td></tr>
<tr><td><code id="cluster.pathways_+3A_start">start</code></td>
<td>
<p>the vector specifying the starting frame of each replicas</p>
</td></tr>
<tr><td><code id="cluster.pathways_+3A_end">end</code></td>
<td>
<p>the vector specifying the ending frame of each replicas</p>
</td></tr>
<tr><td><code id="cluster.pathways_+3A_time.dep">time.dep</code></td>
<td>
<p>choose whether to use time &quot;dependent&quot; or &quot;independent&quot; clustering of pathways</p>
</td></tr>
<tr><td><code id="cluster.pathways_+3A_method">method</code></td>
<td>
<p>the method to be passed to hclust for the clustering</p>
</td></tr>
</table>


<h3>Value</h3>

<p>representatives a vector of frames representatives of each neuron
</p>


<h3>Author(s)</h3>

<p>Stefano Motta<a href="mailto:stefano.motta@unimib.it">stefano.motta@unimib.it</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Read trajectory
trj &lt;- read.trj(trjfile = system.file("extdata", "HIF2a-MD.xtc", package = "SOMMD"),
  topfile = system.file("extdata", "HIF2a.gro", package = "SOMMD"))
#Assign length of the replicas
trj$start &lt;- seq(1, 25, by=5)
trj$end &lt;- seq(5, 25, by=5)
#Read example SOM data
som_model &lt;- readRDS(system.file("extdata", "SOM_HIFa.rds", package = "SOMMD"))
#Cluster Pathways using the time dependent algorithm
clus.paths.tdep &lt;- cluster.pathways(som_model, start=trj$start, end=trj$end,
  time.dep="dependent")
#Cluster Pathways using the time independent algorithm
clus.paths.tindep &lt;- cluster.pathways(som_model,
  start=trj$start, end=trj$end, time.dep="independent")

</code></pre>

<hr>
<h2 id='cluster.representatives'>Cluster Representatives</h2><span id='topic+cluster.representatives'></span>

<h3>Description</h3>

<p>Compute the cluster representatives
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster.representatives(SOM, clusters)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cluster.representatives_+3A_som">SOM</code></td>
<td>
<p>a kohonen SOM object.</p>
</td></tr>
<tr><td><code id="cluster.representatives_+3A_clusters">clusters</code></td>
<td>
<p>a vector of clusters assignment for each neuron, as returned for example by hclust.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of frames representatives of each neuron
</p>


<h3>Author(s)</h3>

<p>Stefano Motta <a href="mailto:stefano.motta@unimib.it">stefano.motta@unimib.it</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Read example SOM data
som_model &lt;- readRDS(system.file("extdata", "SOM_HIFa.rds", package = "SOMMD"))
# Divide the SOM in the selected number of clusters
som_cl &lt;- cutree(hclust(dist(som_model$codes[[1]], method="euclidean"), method="complete"), 4)
#Get representative frames for each cluster
cl_repres &lt;- cluster.representatives(som_model, som_cl)

</code></pre>

<hr>
<h2 id='comp.trans.mat'>Compute transition matrix</h2><span id='topic+comp.trans.mat'></span>

<h3>Description</h3>

<p>Compute the transition matrix starting from a vector of subsequent classifications
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comp.trans.mat(SOM, start = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="comp.trans.mat_+3A_som">SOM</code></td>
<td>
<p>a kohonen object on which transitions between neurons will be computed</p>
</td></tr>
<tr><td><code id="comp.trans.mat_+3A_start">start</code></td>
<td>
<p>a vector containing the start frames of each replica (usually contained in trj$start if replicas were merged with cat_trj)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of pairwise transitions between neurons
</p>


<h3>Author(s)</h3>

<p>Stefano Motta <a href="mailto:stefano.motta@unimib.it">stefano.motta@unimib.it</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Read example SOM data
som_model &lt;- readRDS(system.file("extdata", "SOM_HIFa.rds", package = "SOMMD"))
#Compute transition Matrix
tr_mat &lt;- comp.trans.mat(som_model, start = 1)
</code></pre>

<hr>
<h2 id='fit.trj'>Coordinate superposition</h2><span id='topic+fit.trj'></span>

<h3>Description</h3>

<p>Coordinate superposition with the Kabsch algorithm. This function make use of the bio3d fit.xyz function to align a SOMMD trj object. If ref is not specified, the trj object is aligned to the first frame of the simulation, otherwise it is aligned to the reference input object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit.trj(trj, ref = NULL, trj.inds = NULL, ref.inds = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit.trj_+3A_trj">trj</code></td>
<td>
<p>an object with class trj</p>
</td></tr>
<tr><td><code id="fit.trj_+3A_ref">ref</code></td>
<td>
<p>a struct object read with read.struct() to be used as reference</p>
</td></tr>
<tr><td><code id="fit.trj_+3A_trj.inds">trj.inds</code></td>
<td>
<p>a vector of indices that selects the trj atoms upon which fitting should be based. If not specified all atoms will be used.</p>
</td></tr>
<tr><td><code id="fit.trj_+3A_ref.inds">ref.inds</code></td>
<td>
<p>a vector of indices that selects the ref atoms upon which fitting should be based. If not specified all atoms will be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A trj object aligned
</p>


<h3>Author(s)</h3>

<p>Stefano Motta <a href="mailto:stefano.motta@unimib.it">stefano.motta@unimib.it</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Read trajectory
trj &lt;- read.trj(trjfile = system.file("extdata", "HIF2a-MD.xtc", package = "SOMMD"),
  topfile = system.file("extdata", "HIF2a.gro", package = "SOMMD"))
# Fit a trajectory to the first frame based on alpha carbons:
ca.inds &lt;- which(trj$top$elety=="CA")
trj.fit &lt;- fit.trj(trj, trj.inds=ca.inds)

</code></pre>

<hr>
<h2 id='map.color'>Map the property vector to colours</h2><span id='topic+map.color'></span>

<h3>Description</h3>

<p>Function map a numeric vector of a property to a vector of colors for that property according to that property value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map.color(x, pal, limits = NULL, na.col = "grey")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="map.color_+3A_x">x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code id="map.color_+3A_pal">pal</code></td>
<td>
<p>a color palette</p>
</td></tr>
<tr><td><code id="map.color_+3A_limits">limits</code></td>
<td>
<p>the values of the extremes for the colorscale</p>
</td></tr>
<tr><td><code id="map.color_+3A_na.col">na.col</code></td>
<td>
<p>the color that will be assigned to the na.values of the vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with colors proportional to the values of x
</p>

<hr>
<h2 id='matrix2graph'>Convert transition matrix to an igraph object</h2><span id='topic+matrix2graph'></span>

<h3>Description</h3>

<p>Function to convert a transition matrix to an igraph object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix2graph(trans, SOM, SOM.hc, col.set, diag = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="matrix2graph_+3A_trans">trans</code></td>
<td>
<p>a transition matrix (usually obtained from comp.trans.mat)</p>
</td></tr>
<tr><td><code id="matrix2graph_+3A_som">SOM</code></td>
<td>
<p>a kohonen object that form the network</p>
</td></tr>
<tr><td><code id="matrix2graph_+3A_som.hc">SOM.hc</code></td>
<td>
<p>a vector of cluster assignment for SOM neurons</p>
</td></tr>
<tr><td><code id="matrix2graph_+3A_col.set">col.set</code></td>
<td>
<p>a vector of colors used for the SOM clusters</p>
</td></tr>
<tr><td><code id="matrix2graph_+3A_diag">diag</code></td>
<td>
<p>boolean condition to include diagonal elements</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An igraph object, with SOM properties annotated
</p>


<h3>Author(s)</h3>

<p>Stefano Motta <a href="mailto:stefano.motta@unimib.it">stefano.motta@unimib.it</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Read example SOM data
som_model &lt;- readRDS(system.file("extdata", "SOM_HIFa.rds", package = "SOMMD"))
#Divide the SOM in the selected number of clusters
som_cl &lt;- cutree(hclust(dist(som_model$codes[[1]], method="euclidean"), method="complete"), 4)
#Compute transition matrix
tr_mat &lt;- comp.trans.mat(som_model, start = 1)
#Define a set of colors
colors &lt;- c("#1f78b4", "#33a02c", "#e31a1c", "#ffff88", "#6a3d9a")
#Create graph object
net &lt;- matrix2graph(tr_mat, som_model, som_cl, colors, diag=FALSE)
</code></pre>

<hr>
<h2 id='native.cont'>Select native contact distances</h2><span id='topic+native.cont'></span>

<h3>Description</h3>

<p>Function to select only distances between residues making contacts in reference file or a frame of the simulation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>native.cont(
  struct = NULL,
  trj = NULL,
  trj.frame = 1,
  distance,
  mol.2 = FALSE,
  atoms = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="native.cont_+3A_struct">struct</code></td>
<td>
<p>a struct object read with read.struct() to compute the native.cont</p>
</td></tr>
<tr><td><code id="native.cont_+3A_trj">trj</code></td>
<td>
<p>a trj object to compute the native.cont</p>
</td></tr>
<tr><td><code id="native.cont_+3A_trj.frame">trj.frame</code></td>
<td>
<p>The frame of the trj on which the native.cont are computed</p>
</td></tr>
<tr><td><code id="native.cont_+3A_distance">distance</code></td>
<td>
<p>the distance cut-off</p>
</td></tr>
<tr><td><code id="native.cont_+3A_mol.2">mol.2</code></td>
<td>
<p>can be FALSE (default), use the whole distance matrix, or a vector containing the atomic number of the second molecule (and compute only intermolecular distances)</p>
</td></tr>
<tr><td><code id="native.cont_+3A_atoms">atoms</code></td>
<td>
<p>can be NULL (default), consider all the atoms present in coords, or a vector containing a set of atomic numbers to consider in the calculation (e.g. only CB). atoms can be obtained with the bio3d atom.select function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the index of a subset of selected distances
</p>


<h3>Author(s)</h3>

<p>Stefano Motta <a href="mailto:stefano.motta@unimib.it">stefano.motta@unimib.it</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Read reference structure file with native conformation
struct &lt;- read.struct(system.file("extdata", "HIF2a.gro", package = "SOMMD"))
#Select only Cbeta atoms to perform the analysis
sele_atoms &lt;- which(struct$atom$elety=="CB")
#Choose only native contacts
sele_dists &lt;- native.cont(struct=struct, distance=1.0, atoms=sele_atoms)

</code></pre>

<hr>
<h2 id='neur.population'>Get Neuron Population</h2><span id='topic+neur.population'></span>

<h3>Description</h3>

<p>Function to compute the per-neuron population
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neur.population(SOM, start = 1, end = length(SOM$unit.classif), N = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="neur.population_+3A_som">SOM</code></td>
<td>
<p>the SOM object</p>
</td></tr>
<tr><td><code id="neur.population_+3A_start">start</code></td>
<td>
<p>a vector containing the start frames of each replica (usually contained in trj$start if replicas were merged with cat_trj)</p>
</td></tr>
<tr><td><code id="neur.population_+3A_end">end</code></td>
<td>
<p>a vector containing the end frames of each replica (usually contained in trj$end if replicas were merged with cat_trj)</p>
</td></tr>
<tr><td><code id="neur.population_+3A_n">N</code></td>
<td>
<p>An integer for the portion (replica) of the simulations to be plotted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the per-neuron population
</p>


<h3>Author(s)</h3>

<p>Stefano Motta <a href="mailto:stefano.motta@unimib.it">stefano.motta@unimib.it</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Read example SOM data
som_model &lt;- readRDS(system.file("extdata", "SOM_HIFa.rds", package = "SOMMD"))
pop &lt;- neur.population(som_model)

</code></pre>

<hr>
<h2 id='neur.representatives'>Neuron representative</h2><span id='topic+neur.representatives'></span>

<h3>Description</h3>

<p>Compute the representative frame of each neuron (the closest to the neuron codebook)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neur.representatives(SOM)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="neur.representatives_+3A_som">SOM</code></td>
<td>
<p>a kohonen SOM object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the index of the representative frames for each neuron
</p>


<h3>Author(s)</h3>

<p>Stefano Motta <a href="mailto:stefano.motta@unimib.it">stefano.motta@unimib.it</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Read example SOM data
som_model &lt;- readRDS(system.file("extdata", "SOM_HIFa.rds", package = "SOMMD"))
#Compute representative frame for each neuron
neuron_representatives &lt;- neur.representatives(som_model)
</code></pre>

<hr>
<h2 id='print.struct'>print.struct</h2><span id='topic+print.struct'></span>

<h3>Description</h3>

<p>A short description...
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'struct'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.struct_+3A_x">x</code></td>
<td>
<p>trj object</p>
</td></tr>
<tr><td><code id="print.struct_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to further methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Called for its effect.
</p>


<h3>Author(s)</h3>

<p>Stefano Motta <a href="mailto:stefano.motta@unimib.it">stefano.motta@unimib.it</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Read structure file
struct &lt;- read.struct(system.file("extdata", "HIF2a.gro", package = "SOMMD"))
#Print basic information
print(struct)
</code></pre>

<hr>
<h2 id='print.trj'>Print Trajectory</h2><span id='topic+print.trj'></span>

<h3>Description</h3>

<p>A short description...
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trj'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.trj_+3A_x">x</code></td>
<td>
<p>trj object</p>
</td></tr>
<tr><td><code id="print.trj_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to further methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Called for its effect.
</p>


<h3>Author(s)</h3>

<p>Stefano Motta <a href="mailto:stefano.motta@unimib.it">stefano.motta@unimib.it</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Read trajectory
trj &lt;- read.trj(trjfile = system.file("extdata", "HIF2a-MD.xtc", package = "SOMMD"),
  topfile = system.file("extdata", "HIF2a.gro", package = "SOMMD"))
#Print basic informations
print(trj)
</code></pre>

<hr>
<h2 id='read.gro'>Read gro file</h2><span id='topic+read.gro'></span>

<h3>Description</h3>

<p>Function to read gro files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.gro(file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.gro_+3A_file">file</code></td>
<td>
<p>contains the name and the path to the gro file to be read</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of class &quot;gro&quot; with the following components:
</p>
<table role = "presentation">
<tr><td><code>atom</code></td>
<td>
<p> a data frame containing all atomic coordinate with a row per atom and a column per record type.</p>
</td></tr>
<tr><td><code>xyz</code></td>
<td>
<p> a numeric matrix of class &quot;xyz&quot; containing the atomic coordinate data.</p>
</td></tr>
<tr><td><code>box</code></td>
<td>
<p> a vector of box size.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p> the matched call.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefano Motta <a href="mailto:stefano.motta@unimib.it">stefano.motta@unimib.it</a>
</p>

<hr>
<h2 id='read.struct'>Read structure files</h2><span id='topic+read.struct'></span>

<h3>Description</h3>

<p>Function to read pdb and gro files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.struct(file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.struct_+3A_file">file</code></td>
<td>
<p>contains the name and the path to the pdb or gro file to be read</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of class &quot;struct&quot; with the following components:
</p>
<table role = "presentation">
<tr><td><code>atom</code></td>
<td>
<p> a data frame containing all atomic coordinate with a row per atom and a column per record type.</p>
</td></tr>
<tr><td><code>xyz</code></td>
<td>
<p> a numeric matrix of class &quot;xyz&quot; containing the atomic coordinate data.</p>
</td></tr>
<tr><td><code>box</code></td>
<td>
<p> a vector of box size.</p>
</td></tr>
<tr><td><code>format</code></td>
<td>
<p> The format of the original file </p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p> the matched call.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefano Motta <a href="mailto:stefano.motta@unimib.it">stefano.motta@unimib.it</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Read structure file
struct &lt;- read.struct(system.file("extdata", "HIF2a.gro", package = "SOMMD"))
</code></pre>

<hr>
<h2 id='read.trj'>Read trj file</h2><span id='topic+read.trj'></span>

<h3>Description</h3>

<p>Function to read a trajectory file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.trj(trjfile, topfile)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.trj_+3A_trjfile">trjfile</code></td>
<td>
<p>contains the name and the path to the reference file (pdb or gro files are accepted)</p>
</td></tr>
<tr><td><code id="read.trj_+3A_topfile">topfile</code></td>
<td>
<p>contains the name and the path to the trajectory file (xtc or dcd files are accepted)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of class &quot;trj&quot; with the following components:
</p>
<table role = "presentation">
<tr><td><code>topfile</code></td>
<td>
<p> the input topology file.</p>
</td></tr>
<tr><td><code>topformat</code></td>
<td>
<p> the format of the input topology.</p>
</td></tr>
<tr><td><code>trjfile</code></td>
<td>
<p> the input trajectory file.</p>
</td></tr>
<tr><td><code>trjformat</code></td>
<td>
<p> the format of the input trajectory.</p>
</td></tr>
<tr><td><code>coord</code></td>
<td>
<p> a three dimensional array containing atomic coordinates for all the frames. Dimensions are: Natoms:3:Nframes.</p>
</td></tr>
<tr><td><code>top</code></td>
<td>
<p>  a data.frame containing topological informations with a row per atom and a column per record type (resno, resid, elety, eleno, chain).</p>
</td></tr>
<tr><td><code>start</code></td>
<td>
<p> a vector with the first frame of the simulation. When multiple simulations are concatenated with <code>cat.trj</code> the vector indicates the first frame of each simulation.</p>
</td></tr>
<tr><td><code>end</code></td>
<td>
<p> a vector with the last frame of the simulation. When multiple simulations are concatenated with <code>cat.trj</code> the vector indicates the last frame of each simulation.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p> the matched call.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alessandro Pandini
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Read trajectory
trj &lt;- read.trj(trjfile = system.file("extdata", "HIF2a-MD.xtc", package = "SOMMD"),
  topfile = system.file("extdata", "HIF2a.gro", package = "SOMMD"))
</code></pre>

<hr>
<h2 id='remap.data'>map data to existing SOM</h2><span id='topic+remap.data'></span>

<h3>Description</h3>

<p>Assign new data to a pre-trained SOM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remap.data(SOM, X, add = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remap.data_+3A_som">SOM</code></td>
<td>
<p>a trained SOM</p>
</td></tr>
<tr><td><code id="remap.data_+3A_x">X</code></td>
<td>
<p>a data set with the same number of features of the dataset used to train the SOM</p>
</td></tr>
<tr><td><code id="remap.data_+3A_add">add</code></td>
<td>
<p>whether to append the new data to the ones used to train the SOM</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;kohonen&quot; with the new data mapped
</p>


<h3>Author(s)</h3>

<p>Stefano Motta <a href="mailto:stefano.motta@unimib.it">stefano.motta@unimib.it</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Read example SOM data
som_model &lt;- readRDS(system.file("extdata", "SOM_HIFa.rds", package = "SOMMD"))
#Read a trajectory that was not used to train the som
trj_2 &lt;- read.trj(trjfile = system.file("extdata", "HIF2a-MD-2.xtc", package = "SOMMD"),
  topfile = system.file("extdata", "HIF2a.gro", package = "SOMMD"))
#Read reference structure file
gro &lt;- read.struct(system.file("extdata", "HIF2a.gro", package = "SOMMD"))
#Selection of the same intermolecular distances used to train the SOM
protein.sele &lt;- which(gro$atom$resid!="020")
ligand.sele &lt;- which(gro$atom$resid=="020")
heavy.atoms &lt;- which(startsWith(gro$atom$elety, "H")==FALSE)
sele.dists &lt;- native.cont(struct=gro, distance=0.6, mol.2=ligand.sele, atoms=heavy.atoms)
# Compute distances on new simulations (the same used for SOM training)
dist_2 &lt;- calc.distances(trj_2, mol.2=ligand.sele, sele=sele.dists, atoms=heavy.atoms)
# Map new data on the existing SOM
som_model_2 &lt;- remap.data(SOM=som_model, X=dist_2)
</code></pre>

<hr>
<h2 id='rio_read_xtc'>Read xtc trajectory file</h2><span id='topic+rio_read_xtc'></span>

<h3>Description</h3>

<p>Function to read an xtc trajectory file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rio_read_xtc(xtc_filename)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rio_read_xtc_+3A_xtc_filename">xtc_filename</code></td>
<td>
<p>contains the name and the path to the xtc file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns 3D array of cartesian coordinates
</p>


<h3>Author(s)</h3>

<p>Alessandro Pandini
</p>

<hr>
<h2 id='rio_read_xtc_natoms'>Read xtc trajectory file</h2><span id='topic+rio_read_xtc_natoms'></span>

<h3>Description</h3>

<p>Function to read a xtc trajectory file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rio_read_xtc_natoms(xtc_filename)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rio_read_xtc_natoms_+3A_xtc_filename">xtc_filename</code></td>
<td>
<p>contains the name and the path to the xtc file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns number of atoms in the structure
</p>


<h3>Author(s)</h3>

<p>Alessandro Pandini
</p>

<hr>
<h2 id='rio_read_xtc_nframes'>Read xtc trajectory file</h2><span id='topic+rio_read_xtc_nframes'></span>

<h3>Description</h3>

<p>Function to read an xtc trajectory file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rio_read_xtc_nframes(xtc_filename)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rio_read_xtc_nframes_+3A_xtc_filename">xtc_filename</code></td>
<td>
<p>contains the name and the path to the xtc file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns number of frames in the trajectory
</p>


<h3>Author(s)</h3>

<p>Alessandro Pandini
</p>

<hr>
<h2 id='rio_read_xtc2xyz'>Read xtc trajectory file</h2><span id='topic+rio_read_xtc2xyz'></span>

<h3>Description</h3>

<p>Function to read an xtc trajectory file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rio_read_xtc2xyz(xtc_filename)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rio_read_xtc2xyz_+3A_xtc_filename">xtc_filename</code></td>
<td>
<p>contains the name and the path to the xtc file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns bio3d xyz array of Cartesian coordinates
</p>


<h3>Author(s)</h3>

<p>Alessandro Pandini
</p>

<hr>
<h2 id='rio_write_xtc'>Write xtc trajectory file</h2><span id='topic+rio_write_xtc'></span>

<h3>Description</h3>

<p>Function to write an xtc trajectory file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rio_write_xtc(xtc_filename, trj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rio_write_xtc_+3A_xtc_filename">xtc_filename</code></td>
<td>
<p>contains the name and the path to the xtc file to write</p>
</td></tr>
<tr><td><code id="rio_write_xtc_+3A_trj">trj</code></td>
<td>
<p>trajectory object to save</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns status of write execution
</p>


<h3>Author(s)</h3>

<p>Alessandro Pandini
</p>

<hr>
<h2 id='silhouette.profile'>Silhouette profile</h2><span id='topic+silhouette.profile'></span>

<h3>Description</h3>

<p>Function to compute the silhouette profile for the Nclus cluster of the SOM neurons
</p>


<h3>Usage</h3>

<pre><code class='language-R'>silhouette.profile(
  SOM,
  Nclus,
  dist_clust = "euclidean",
  clust_method = "complete"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="silhouette.profile_+3A_som">SOM</code></td>
<td>
<p>the SOM object to cluster</p>
</td></tr>
<tr><td><code id="silhouette.profile_+3A_nclus">Nclus</code></td>
<td>
<p>the cluster number on which the silhouette profile will be computed</p>
</td></tr>
<tr><td><code id="silhouette.profile_+3A_dist_clust">dist_clust</code></td>
<td>
<p>the metric for the distance calculation</p>
</td></tr>
<tr><td><code id="silhouette.profile_+3A_clust_method">clust_method</code></td>
<td>
<p>the method for the clustering (passed to the hclust function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of silhouette profile computed with the cluster package
</p>


<h3>Author(s)</h3>

<p>Stefano Motta <a href="mailto:stefano.motta@unimib.it">stefano.motta@unimib.it</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Read example SOM data
som_model &lt;- readRDS(system.file("extdata", "SOM_HIFa.rds", package = "SOMMD"))
#Compute the silhouette profile
sil_pro &lt;- silhouette.profile(som_model, Nclus=5, clust_method="complete")

</code></pre>

<hr>
<h2 id='silhouette.score'>Silhouette score</h2><span id='topic+silhouette.score'></span>

<h3>Description</h3>

<p>Function to compute the silhouette score for the clustering of SOM neurons
</p>


<h3>Usage</h3>

<pre><code class='language-R'>silhouette.score(
  SOM,
  dist_clust = "euclidean",
  clust_method = "complete",
  interval = seq(2, 30)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="silhouette.score_+3A_som">SOM</code></td>
<td>
<p>the SOM object to cluster</p>
</td></tr>
<tr><td><code id="silhouette.score_+3A_dist_clust">dist_clust</code></td>
<td>
<p>the metric for the distance calculation</p>
</td></tr>
<tr><td><code id="silhouette.score_+3A_clust_method">clust_method</code></td>
<td>
<p>the method for the clustering (passed to the hclust function</p>
</td></tr>
<tr><td><code id="silhouette.score_+3A_interval">interval</code></td>
<td>
<p>the cluster number on which the silhouette score will be computed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the silhouette scores for all the frames
</p>


<h3>Author(s)</h3>

<p>Stefano Motta <a href="mailto:stefano.motta@unimib.it">stefano.motta@unimib.it</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Read example SOM data
som_model &lt;- readRDS(system.file("extdata", "SOM_HIFa.rds", package = "SOMMD"))
#Compute the silhouette profile
sil_score &lt;- silhouette.score(som_model, clust_method="complete", interval=seq(2,8))

</code></pre>

<hr>
<h2 id='som.add.circles'>Add circles to SOM</h2><span id='topic+som.add.circles'></span>

<h3>Description</h3>

<p>Function to add circles to a SOM plot, with dimension proportional to a selected property
</p>


<h3>Usage</h3>

<pre><code class='language-R'>som.add.circles(SOM, P, scale = 1, col.circles = "white")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="som.add.circles_+3A_som">SOM</code></td>
<td>
<p>the SOM object</p>
</td></tr>
<tr><td><code id="som.add.circles_+3A_p">P</code></td>
<td>
<p>a vector containing the per-neuron property to plot</p>
</td></tr>
<tr><td><code id="som.add.circles_+3A_scale">scale</code></td>
<td>
<p>a number to scale up or down the size of the drawn circles</p>
</td></tr>
<tr><td><code id="som.add.circles_+3A_col.circles">col.circles</code></td>
<td>
<p>the background color of the drawn circles</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Called for its effect.
</p>


<h3>Author(s)</h3>

<p>Stefano Motta <a href="mailto:stefano.motta@unimib.it">stefano.motta@unimib.it</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Read example SOM data
som_model &lt;- readRDS(system.file("extdata", "SOM_HIFa.rds", package = "SOMMD"))
# Compute per neuron population
pop &lt;- neur.population(som_model)
#Plot the som
plot(som_model, type = "count", bgcol=c("red", "blue", "yellow", "green"), shape='straight')
# Add circles to the SOM plot
som.add.circles(som_model, pop, scale=0.9)

</code></pre>

<hr>
<h2 id='som.add.clusters.legend'>Add legend clusters</h2><span id='topic+som.add.clusters.legend'></span>

<h3>Description</h3>

<p>Function to apply a legend of clusters to a SOM map image
</p>


<h3>Usage</h3>

<pre><code class='language-R'>som.add.clusters.legend(Nclus, color.scale)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="som.add.clusters.legend_+3A_nclus">Nclus</code></td>
<td>
<p>the number of clusters to which put the legent</p>
</td></tr>
<tr><td><code id="som.add.clusters.legend_+3A_color.scale">color.scale</code></td>
<td>
<p>the color scale used for the image</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Called for its effect.
</p>


<h3>Author(s)</h3>

<p>Stefano Motta <a href="mailto:stefano.motta@unimib.it">stefano.motta@unimib.it</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Read example SOM data
som_model &lt;- readRDS(system.file("extdata", "SOM_HIFa.rds", package = "SOMMD"))
#Divide the SOM in the selected number of clusters
som_cl &lt;- cutree(hclust(dist(som_model$codes[[1]], method="euclidean"), method="complete"), 4)
#Define a set of colors
colors &lt;- c("#1f78b4", "#33a02c", "#e31a1c", "#ffff88", "#6a3d9a") 
#Plot the som with neurons colored according to clusters
plot(som_model, type = "mapping", bgcol=colors[som_cl], col=rgb(0,0,0,0), shape='straight', main="")
kohonen::add.cluster.boundaries(som_model, som_cl, lwd=5)
#Add legend to the plot
som.add.clusters.legend(Nclus=4, color.scale=colors)

</code></pre>

<hr>
<h2 id='som.add.numbers'>Add Neuron Numbering</h2><span id='topic+som.add.numbers'></span>

<h3>Description</h3>

<p>Add the neuron numbering scheme to the SOM plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>som.add.numbers(SOM, scale = 1, col = "black")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="som.add.numbers_+3A_som">SOM</code></td>
<td>
<p>the SOM object</p>
</td></tr>
<tr><td><code id="som.add.numbers_+3A_scale">scale</code></td>
<td>
<p>a number to scale up or down the size of the text</p>
</td></tr>
<tr><td><code id="som.add.numbers_+3A_col">col</code></td>
<td>
<p>the color of the text</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Called for its effect.
</p>


<h3>Author(s)</h3>

<p>Stefano Motta <a href="mailto:stefano.motta@unimib.it">stefano.motta@unimib.it</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Read example SOM data
som_model &lt;- readRDS(system.file("extdata", "SOM_HIFa.rds", package = "SOMMD"))
#Plot the som
plot(som_model, type = "count", bgcol=c("red", "blue", "yellow", "green"), shape='straight')
#Add neuron numbers on the som
som.add.numbers(som_model, scale=0.5, col="black")

</code></pre>

<hr>
<h2 id='stride.trj'>Stride a trj</h2><span id='topic+stride.trj'></span>

<h3>Description</h3>

<p>Apply a stride to the frame of a trj object to reduce the number of frames
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stride.trj(trj, stride)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stride.trj_+3A_trj">trj</code></td>
<td>
<p>a trj object.</p>
</td></tr>
<tr><td><code id="stride.trj_+3A_stride">stride</code></td>
<td>
<p>the stride to apply to the trajectory</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class trj with a frame every <code>stride</code>
</p>


<h3>Author(s)</h3>

<p>Stefano Motta <a href="mailto:stefano.motta@unimib.it">stefano.motta@unimib.it</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Read the simulation
trj &lt;- read.trj(trjfile = system.file("extdata", "HIF2a-MD.xtc", package = "SOMMD"),
  topfile = system.file("extdata", "HIF2a.gro", package = "SOMMD"))
# keep a frame every 2 frame
trj_strd &lt;- stride.trj(trj, 2)

</code></pre>

<hr>
<h2 id='struct2pdb'>Convert structure to pdb object</h2><span id='topic+struct2pdb'></span>

<h3>Description</h3>

<p>Convert a struct object into a pdb obtect
</p>


<h3>Usage</h3>

<pre><code class='language-R'>struct2pdb(struct)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="struct2pdb_+3A_struct">struct</code></td>
<td>
<p>contains the struct object to convert</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object with class &quot;pdb&quot;
</p>
<p>An object of class &quot;pdb&quot;
</p>


<h3>Author(s)</h3>

<p>Stefano Motta <a href="mailto:stefano.motta@unimib.it">stefano.motta@unimib.it</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Read structure file 
struct &lt;- read.struct(system.file("extdata", "HIF2a.gro", package = "SOMMD"))
#Convert structure to pdb object
pdb &lt;- struct2pdb(struct)

</code></pre>

<hr>
<h2 id='summary.struct'>Summarizing a structure object</h2><span id='topic+summary.struct'></span>

<h3>Description</h3>

<p>summary method for class struct
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'struct'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.struct_+3A_object">object</code></td>
<td>
<p>struct object</p>
</td></tr>
<tr><td><code id="summary.struct_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to further methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Called for its effect.
</p>


<h3>Author(s)</h3>

<p>Stefano Motta <a href="mailto:stefano.motta@unimib.it">stefano.motta@unimib.it</a>
</p>

<hr>
<h2 id='summary.trj'>Summarizing a trajectory object</h2><span id='topic+summary.trj'></span>

<h3>Description</h3>

<p>summary method for class trj
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trj'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.trj_+3A_object">object</code></td>
<td>
<p>trajectory object</p>
</td></tr>
<tr><td><code id="summary.trj_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to further methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Called for its effect.
</p>


<h3>Author(s)</h3>

<p>Stefano Motta <a href="mailto:stefano.motta@unimib.it">stefano.motta@unimib.it</a>
</p>

<hr>
<h2 id='trace.path'>Trace pathway</h2><span id='topic+trace.path'></span>

<h3>Description</h3>

<p>Function trace pathway sampled on the SOM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trace.path(
  SOM,
  start = 1,
  end = length(SOM$unit.classif),
  N = 1,
  draw.stride = 1,
  pts.scale = 1,
  lwd.scale = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trace.path_+3A_som">SOM</code></td>
<td>
<p>the SOM object</p>
</td></tr>
<tr><td><code id="trace.path_+3A_start">start</code></td>
<td>
<p>a vector containing the start frames of each replica (usually contained in trj$start if replicas were merged with cat_trj)</p>
</td></tr>
<tr><td><code id="trace.path_+3A_end">end</code></td>
<td>
<p>a vector containing the end frames of each replica (usually contained in trj$end if replicas were merged with cat_trj)</p>
</td></tr>
<tr><td><code id="trace.path_+3A_n">N</code></td>
<td>
<p>The portion of simulation that one want to plot</p>
</td></tr>
<tr><td><code id="trace.path_+3A_draw.stride">draw.stride</code></td>
<td>
<p>used to plot the pathways with a stride (useful for very complex pathways)</p>
</td></tr>
<tr><td><code id="trace.path_+3A_pts.scale">pts.scale</code></td>
<td>
<p>a number to scale up or down the size of the circles</p>
</td></tr>
<tr><td><code id="trace.path_+3A_lwd.scale">lwd.scale</code></td>
<td>
<p>a number to scale up or down the size of the lines</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Called for its effect.
</p>


<h3>Author(s)</h3>

<p>Stefano Motta <a href="mailto:stefano.motta@unimib.it">stefano.motta@unimib.it</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Read the trajectory
trj &lt;- read.trj(trjfile = system.file("extdata", "HIF2a-MD.xtc", package = "SOMMD"),
  topfile = system.file("extdata", "HIF2a.gro", package = "SOMMD"))
#Read example SOM data
som_model &lt;- readRDS(system.file("extdata", "SOM_HIFa.rds", package = "SOMMD"))
#trace pathway sampled on the SOM
trace.path(som_model, start=trj$start, end=trj$end, N=1, pts.scale=0.5)

</code></pre>

<hr>
<h2 id='trj2pdb'>Extract frame to pdb</h2><span id='topic+trj2pdb'></span>

<h3>Description</h3>

<p>Extract a trj frame to a pdb object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trj2pdb(trj, frame, filename)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trj2pdb_+3A_trj">trj</code></td>
<td>
<p>a trj object.</p>
</td></tr>
<tr><td><code id="trj2pdb_+3A_frame">frame</code></td>
<td>
<p>the frame to extract.</p>
</td></tr>
<tr><td><code id="trj2pdb_+3A_filename">filename</code></td>
<td>
<p>for the output pdb file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a pdb object of the selected frame
</p>
<p>Called for its effect.
</p>


<h3>Author(s)</h3>

<p>Stefano Motta <a href="mailto:stefano.motta@unimib.it">stefano.motta@unimib.it</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Read the trajectory
trj &lt;- read.trj(trjfile = system.file("extdata", "HIF2a-MD.xtc", package = "SOMMD"),
  topfile = system.file("extdata", "HIF2a.gro", package = "SOMMD"))
# Write the pdb file for a specific frame
trj2pdb(trj = trj, frame=5, filename = tempfile(fileext = '.pdb' ))


</code></pre>

<hr>
<h2 id='trj2xyz'>Convert Trajectory to xyz</h2><span id='topic+trj2xyz'></span>

<h3>Description</h3>

<p>Convert the trj coordinates 3D-array in a 2D matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trj2xyz(trj, inds = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trj2xyz_+3A_trj">trj</code></td>
<td>
<p>an object with class trj</p>
</td></tr>
<tr><td><code id="trj2xyz_+3A_inds">inds</code></td>
<td>
<p>indices for the output coordinates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a xyz matrix with frames on rows and coordinates as columns
</p>


<h3>Author(s)</h3>

<p>Stefano Motta <a href="mailto:stefano.motta@unimib.it">stefano.motta@unimib.it</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Read trajectory
trj &lt;- read.trj(trjfile = system.file("extdata", "HIF2a-MD.xtc", package = "SOMMD"),
  topfile = system.file("extdata", "HIF2a.gro", package = "SOMMD"))
trj2xyz(trj)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
