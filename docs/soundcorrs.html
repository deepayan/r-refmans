<!DOCTYPE html><html><head><title>Help for package soundcorrs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {soundcorrs}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%.%'><p>Compose two functions. Haskell-inspired syntactic sugar.</p></a></li>
<li><a href='#%hasPrefix%'><p>Check if a string starts with another string.</p></a></li>
<li><a href='#%hasSuffix%'><p>Check if a string ends in another string.</p></a></li>
<li><a href='#%nin%'><p>The inverse of %in%.</p></a></li>
<li><a href='#addSeparators'><p>Intersperse a vector of strings with a character or string.</p></a></li>
<li><a href='#allCooccs'><p>Generate all co-occurrence contingency tables for a dataset.</p></a></li>
<li><a href='#allPairs'><p>Produce a list of all sound correspondences and all pairs in which they are attested.</p></a></li>
<li><a href='#applyChanges'><p>Apply a series of sound changes to a series of words.</p></a></li>
<li><a href='#binTable'><p>Sum all rows and all columns in a table, except for the selected ones.</p></a></li>
<li><a href='#cbind.soundcorrs'><p>Attach one or more columns to a <code>soundcorrs</code> object.</p></a></li>
<li><a href='#char2value'><p>Information that the <code>char2value()</code> function is obsolete.</p></a></li>
<li><a href='#checkCount'><p>Check if the <code>count</code> argument is correct.</p></a></li>
<li><a href='#checkUnit'><p>Check if the <code>unit</code> argument is correct.</p></a></li>
<li><a href='#collapse'><p>Paste and collapse.</p></a></li>
<li><a href='#coocc'><p>Generate a contingency table of co-occurrences of sound correspondences with themselves, or with metadata.</p></a></li>
<li><a href='#expandMeta'><p>Expand custom metacharacters to regular expressions.</p></a></li>
<li><a href='#findExamples'><p>Find all pairs/triples/... with corresponding sequences of sounds.</p></a></li>
<li><a href='#findPairs'><p>A convenience wrapper around <code>findExamples</code>.</p></a></li>
<li><a href='#findSegments'><p>Information that the <code>findSegments</code> function is obsolete.</p></a></li>
<li><a href='#fitTable'><p>Fit multiple models to multiple datasets.</p></a></li>
<li><a href='#formatter.html'><p>A formatter for <code>allPairs</code>. This one formats to HTML.</p></a></li>
<li><a href='#formatter.latex'><p>A formatter for <code>allPairs</code>. This one formats to LaTeX.</p></a></li>
<li><a href='#formatter.none'><p>A formatter for <code>allPairs</code>. This one does practically no formatting at all.</p></a></li>
<li><a href='#highlight'><p>Highlight differences between strings.</p></a></li>
<li><a href='#lapplyTest'><p>Apply a function to a list.</p></a></li>
<li><a href='#list.depth'><p>Measure the depth of a nested list.</p></a></li>
<li><a href='#list.transpose'><p>Transpose a nested list.</p></a></li>
<li><a href='#loadSampleDataset'><p>Load one of <code>soundcorrs</code>' sample datasets.</p></a></li>
<li><a href='#long2wide'><p>Convert from the long format (single entry per row) to the wide format (multiple entries per row).</p></a></li>
<li><a href='#merge.soundcorrs'><p>Merge two or more <code>soundcorrs</code> objects.</p></a></li>
<li><a href='#multiFit'><p>Fit multiple models to one dataset.</p></a></li>
<li><a href='#ngrams'><p>N-grams and their frequencies.</p></a></li>
<li><a href='#ngrams.scOne'><p>Information that the <code>scOne</code> class is obsolete.</p></a></li>
<li><a href='#path2name'><p>Extract file name from path string.</p></a></li>
<li><a href='#print.df.findExamples'><p>Pretty printing for the result of <code>findExamples</code>.</p></a></li>
<li><a href='#print.list.applyChanges'><p>Pretty printing for the result of <code>applyChanges</code>.</p></a></li>
<li><a href='#print.scOne'><p>Information that the <code>scOne</code> class is obsolete.</p></a></li>
<li><a href='#print.soundchange'><p>A more reasonable display of a <code>soundchange</code> object.</p></a></li>
<li><a href='#print.soundcorrs'><p>A more reasonable display of a <code>soundcorrs</code> object.</p></a></li>
<li><a href='#print.transcription'><p>A more reasonable display of a <code>transcription</code> object.</p></a></li>
<li><a href='#print.tree.applyChanges'><p>Pretty printing for part of the result of <code>applyChanges</code>.</p></a></li>
<li><a href='#read.scOne'><p>Information that the <code>scOne</code> class is obsolete.</p></a></li>
<li><a href='#read.soundcorrs'><p>Read data for a single language from a tsv file.</p></a></li>
<li><a href='#read.transcription'><p>Read transcription from a tsv file.</p></a></li>
<li><a href='#revChar'><p>Rev (reverse the order) for character strings.</p></a></li>
<li><a href='#scOne'><p>Information that the <code>scOne</code> class is obsolete.</p></a></li>
<li><a href='#server'><p>The main server for the UI.</p></a></li>
<li><a href='#soundchange'><p>Constructor function for the <code>soundchange</code> class.</p></a></li>
<li><a href='#soundcorrs'><p>Constructor function for the <code>soundcorrs</code> class.</p></a></li>
<li><a href='#soundcorrsGUI'><p>GUI for <code>soundcorrs</code>.</p></a></li>
<li><a href='#subset.soundcorrs'><p>Return a subset of sound correspondences data which meets a condition.</p></a></li>
<li><a href='#summary.list.lapplyTest'><p>A quick summary of the result of <code>lapplyTest</code>.</p></a></li>
<li><a href='#summary.list.multiFit'><p>A comparison of the results produced by <code>fitTable</code> or <code>multiFit</code>.</p></a></li>
<li><a href='#summary.soundcorrs'><p>Generate a segment-to-segment contingency table for two languages.</p></a></li>
<li><a href='#tabAbs2Rel'><p>Convert a table from absolute to relative values.</p></a></li>
<li><a href='#transcription'><p>Constructor function for the <code>transcription</code> class.</p></a></li>
<li><a href='#ui'><p>The UI for navigation bar.</p></a></li>
<li><a href='#ui.data'><p>The UI for the Data page.</p></a></li>
<li><a href='#ui.examples'><p>The UI for the Examples page.</p></a></li>
<li><a href='#ui.soundchanges'><p>The UI for the Sound changes page.</p></a></li>
<li><a href='#ui.start'><p>The UI for the Start page.</p></a></li>
<li><a href='#ui.tables'><p>The UI for the Tables changes page.</p></a></li>
<li><a href='#vec2df.hist'><p>A vector to data frame converter for <code>fitTable</code>. This one makes a histogram, and returns a data frame with midpoints and counts.</p></a></li>
<li><a href='#vec2df.id'><p>A vector to data frame converter for <code>fitTable</code>. This one only does the necessary minimum.</p></a></li>
<li><a href='#vec2df.rank'><p>A vector to data frame converter for <code>fitTable</code>. This one orders data by rank.</p></a></li>
<li><a href='#wide2long'><p>Convert from the wide format (multiple entries per row) to the long format (single entry per row).</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Semi-Automatic Analysis of Sound Correspondences</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.0</td>
</tr>
<tr>
<td>Description:</td>
<td>A set of tools that can be used in computer-aided analysis of
    sound correspondences between languages, plus several helper functions.
    Analytic functions range from purely qualitative analysis, through
    statistic methods yielding qualitative results, to an entirely
    quantitative approach.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr (&ge; 1.21), rmarkdown (&ge; 1.11), shiny (&ge; 1.2.0),
shinyjqui (&ge; 0.3.3)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-11-16 11:34:13 UTC; kamil</td>
</tr>
<tr>
<td>Author:</td>
<td>Kamil Stachowski [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kamil Stachowski &lt;kamil.stachowski@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-11-16 12:30:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25.+25'>Compose two functions. Haskell-inspired syntactic sugar.</h2><span id='topic++25.+25'></span>

<h3>Description</h3>

<p>Function composition, acts like <code>.</code> in Haskell, only limited to two functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f %.% g
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25.+2B25_+3A_f">f</code></td>
<td>
<p>[function] The outer function.</p>
</td></tr>
<tr><td><code id="+2B25.+2B25_+3A_g">g</code></td>
<td>
<p>[function] The inner function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[function] Function composed of <code>f</code> and <code>g</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(x) x+1
g &lt;- function(x) x*2
lapply (1:3, soundcorrs:::'%.%' (f,g))
</code></pre>

<hr>
<h2 id='+25hasPrefix+25'>Check if a string starts with another string.</h2><span id='topic++25hasPrefix+25'></span>

<h3>Description</h3>

<p>Within <code>soundcorrs</code>, primarily intended to extract rows and columns from contingency tables. Other than that, of general applicability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %hasPrefix% prefix
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25hasPrefix+2B25_+3A_x">x</code></td>
<td>
<p>[character] The string or strings in which to look.</p>
</td></tr>
<tr><td><code id="+2B25hasPrefix+2B25_+3A_prefix">prefix</code></td>
<td>
<p>[character] The string to look for. May be a regular expression.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Contingency tables, such as produced by <code><a href="#topic+coocc">coocc</a></code> and <code><a href="base.html#topic+summary">summary</a></code>, can get quite sizeable and therefore difficult to read with larger datasets. Since both their column and row names are composed from individual segments connected by an underscore (<code>"_"</code>), <code>%hasPrefix%</code> offers an easy way to select the interesting bit of the table by the first segment.
</p>


<h3>Value</h3>

<p>[logical] <code>TRUE</code> iff <code>x</code> begins with <code>prefix</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic++25hasSuffix+25">%hasSuffix%</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>"loans.tsv" %hasPrefix% "loans"
c("abc","bbc","cbc") %hasPrefix% "[bc]"
</code></pre>

<hr>
<h2 id='+25hasSuffix+25'>Check if a string ends in another string.</h2><span id='topic++25hasSuffix+25'></span>

<h3>Description</h3>

<p>Within <code>soundcorrs</code>, primarily intended to extract rows and columns from contingency tables. Other than that, of general applicability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %hasSuffix% suffix
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25hasSuffix+2B25_+3A_x">x</code></td>
<td>
<p>[character] The string or strings in which to look.</p>
</td></tr>
<tr><td><code id="+2B25hasSuffix+2B25_+3A_suffix">suffix</code></td>
<td>
<p>[character] The string to look for. May be a regular expression.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Contingency tables, such as produced by <code><a href="#topic+coocc">coocc</a></code> and <code><a href="base.html#topic+summary">summary</a></code>, can get quite sizeable and therefore difficult to read with larger datasets. Since both their column and row names are composed from individual segments connected by an underscore (<code>"_"</code>), <code>%hasSuffix%</code> offers an easy way to select the interesting bit of the table by the last segment.
</p>


<h3>Value</h3>

<p>[logical] <code>TRUE</code> iff <code>x</code> ends with <code>suffix</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic++25hasPrefix+25">%hasPrefix%</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>"loans.tsv" %hasSuffix% ".tsv"
c("aba","abb","abc") %hasSuffix% "[bc]"
</code></pre>

<hr>
<h2 id='+25nin+25'>The inverse of %in%.</h2><span id='topic++25nin+25'></span>

<h3>Description</h3>

<p>The inverse (negation) of %in%.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %nin% y
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25nin+2B25_+3A_x">x</code></td>
<td>
<p>The needle.</p>
</td></tr>
<tr><td><code id="+2B25nin+2B25_+3A_y">y</code></td>
<td>
<p>The haystack.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[logical] <code>TRUE</code> iff <code>x</code> is not an element of <code>y</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (soundcorrs:::'%nin%' (1,c(1))) print("What sorcery is this?")
</code></pre>

<hr>
<h2 id='addSeparators'>Intersperse a vector of strings with a character or string.</h2><span id='topic+addSeparators'></span>

<h3>Description</h3>

<p>Primarily intended to insert separators into a column of words, to facilitate manual segmentation and aligning.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addSeparators(x, separator = "|")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addSeparators_+3A_x">x</code></td>
<td>
<p>[character vector] The strings to be interspersed.</p>
</td></tr>
<tr><td><code id="addSeparators_+3A_separator">separator</code></td>
<td>
<p>[character] The string with which to intersperse. Defaults to <code>"|"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Preparation of data for <code><a href="#topic+soundcorrs">soundcorrs</a></code> consists of segmentation and alignment. Segmentation can proceed on phoneme-by-phoneme, morpheme-by-morpheme, or any other basis; the only constraint is that each word in a pair/triple/... of words must contain the same number of segments. Segments are indicated by separators, by default the character <code>"|"</code>. The action of inserting separators, potentially between every two letters, in a large dataset, can become time consuming. <code>addSeparators</code> automates at least this part of the process.
</p>


<h3>Value</h3>

<p>[character vector] A vector of interspersed strings.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>addSeparators (c("word","mot","focal"), ".")
</code></pre>

<hr>
<h2 id='allCooccs'>Generate all co-occurrence contingency tables for a dataset.</h2><span id='topic+allCooccs'></span>

<h3>Description</h3>

<p>Generate all correspondence-to-correspondence or correspondence-to-metadata contingnecy tables for a dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allCooccs(data, column, count, unit, bin)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="allCooccs_+3A_data">data</code></td>
<td>
<p>[soundcorrs] The dataset from which to draw frequencies. Only datasets with two languages are supported.</p>
</td></tr>
<tr><td><code id="allCooccs_+3A_column">column</code></td>
<td>
<p>[character] Name of the column with metadata. If <code>NULL</code>, sound correspondences are cross-tabulated with themselves. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="allCooccs_+3A_count">count</code></td>
<td>
<p>[character] Report the absolute number of times or words, or relative to how many times or in how many words the given segments co-occur in L1 or L2. Accepted values are <code>"a(bs(olute))"</code> and <code>"r(el(ative))"</code>. Defaults to &quot;a&quot;.</p>
</td></tr>
<tr><td><code id="allCooccs_+3A_unit">unit</code></td>
<td>
<p>[character] Count how many times a correspondence occurs or in how many words it occurs. Accepted values are <code>"o(cc(ur(ence(s))))"</code> and <code>"w(or(d(s)))"</code>. Defaults to <code>"w"</code>.</p>
</td></tr>
<tr><td><code id="allCooccs_+3A_bin">bin</code></td>
<td>
<p>[logical] Whether to bin tables before applying <code>fun</code> to them. Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A contingency table such as produced by <code><a href="#topic+coocc">coocc</a></code> may be insightful but more often than not statistical tests cannot be applied directly to it, or at least they would not produce meaningful results. This function splits such a table into blocks such that each block only contains the correspondences of a single segment. The resulting slices, additionally binned or not (cf. <code><a href="#topic+binTable">binTable</a></code>), can be then passed to <code><a href="#topic+lapplyTest">lapplyTest</a></code> for a near-automatic application of a test.
</p>


<h3>Value</h3>

<p>[list] A list of tables.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coocc">coocc</a></code>, <code><a href="#topic+binTable">binTable</a></code>, <code><a href="#topic+lapplyTest">lapplyTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dataset &lt;- loadSampleDataset ("data-abc")
allCooccs (dataset)
allCooccs (dataset, "DIALECT.L2", unit="o")
</code></pre>

<hr>
<h2 id='allPairs'>Produce a list of all sound correspondences and all pairs in which they are attested.</h2><span id='topic+allPairs'></span>

<h3>Description</h3>

<p>Take all segment-to-segment correspondences in the dataset, and produce for each a section composed of a title, a contingency table of all renderings of the given segment, and subsections listing all word pairs in which the given rendering is attested, all nicely formatted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allPairs(data, file, count, unit, direction, cols, formatter, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="allPairs_+3A_data">data</code></td>
<td>
<p>[character] The dataset. Only datasets with two languages are supported.</p>
</td></tr>
<tr><td><code id="allPairs_+3A_file">file</code></td>
<td>
<p>[character] Name of the file to write the formatted list to. If <code>NULL</code>, the output will be printed to the screen. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="allPairs_+3A_count">count</code></td>
<td>
<p>[character] Report the absolute number of times or words, or relative to how many times or in how many words the given segments co-occur in L1 or L2. Accepted values are <code>"a(bs(olute))"</code> and <code>"r(el(ative))"</code>. Defaults to &quot;a&quot;.</p>
</td></tr>
<tr><td><code id="allPairs_+3A_unit">unit</code></td>
<td>
<p>[character] Count how many times a correspondence occurs or in how many words it occurs. Accepted values are <code>"o(cc(ur(ence(s))))"</code> and <code>"w(or(d(s)))"</code>. Defaults to <code>"w"</code>.</p>
</td></tr>
<tr><td><code id="allPairs_+3A_direction">direction</code></td>
<td>
<p>[integer] If <code>1</code>, correspondences are in the order Language1 &gt; Language2 (&quot;x yields y&quot;). If <code>2</code>, the order is Language2 &lt; Language1 (&quot;y originates from x&quot;). Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="allPairs_+3A_cols">cols</code></td>
<td>
<p>[character vector] Which columns of the dataset to print. Can be a vector of names, <code>"aligned"</code> (the two columns with segmented, aligned words), or <code>"all"</code> (all columns). Defaults to <code>"aligned"</code>.</p>
</td></tr>
<tr><td><code id="allPairs_+3A_formatter">formatter</code></td>
<td>
<p>[function] The function to which to pass unformatted data. Available formatters are: <code>formatter.none</code>, <code>formatter.html</code>, and <code>formatter.latex</code>. Defaults to <code>formatter.none</code>.</p>
</td></tr>
<tr><td><code id="allPairs_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>formatter</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+summary.soundcorrs">summary.soundcorrs</a></code> can produce a table of all segment-to-segment correspondences in a dataset, and <code><a href="#topic+findExamples">findExamples</a></code> and <code><a href="#topic+findPairs">findPairs</a></code> can find all the pairs of words which realize those correspondences, but combining their outputs is a time-consuming, and unnecessary manual labour. The same, or at least a very similar result can be produced automatically by this function. Its output is divided into sections, each comprised of the appropriate slice of the contingency table, and a list of all the examples which are relevant for the given correspondence. The output can be raw, or formatted as LaTeX or HTML, and it is not too difficult to write one's own, custom formatting function.
</p>


<h3>Value</h3>

<p>[character] A formatted list of of all segment-to-segment correspondences and all pairs in which they are attested.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+findPairs">findPairs</a></code>, <code><a href="#topic+summary.soundcorrs">summary.soundcorrs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dataset &lt;- loadSampleDataset ("data-abc")
allPairs (dataset)
allPairs (dataset, formatter=formatter.latex, cols=c("ORTHOGRAPHY.L1", "ORTHOGRAPHY.L2"))
</code></pre>

<hr>
<h2 id='applyChanges'>Apply a series of sound changes to a series of words.</h2><span id='topic+applyChanges'></span>

<h3>Description</h3>

<p>Apply a list of <code><a href="#topic+soundchange">soundchange</a></code>'s to a series of words, possibly with additional metadata, and possibly compare the results to a prediction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>applyChanges(data, changes, source, target, meta, highlight)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="applyChanges_+3A_data">data</code></td>
<td>
<p>[soundcorrs] A <code><a href="#topic+soundcorrs">soundcorrs</a></code> object.</p>
</td></tr>
<tr><td><code id="applyChanges_+3A_changes">changes</code></td>
<td>
<p>[soundchange] The list of <code><a href="#topic+soundchange">soundchange</a></code>'s to apply.</p>
</td></tr>
<tr><td><code id="applyChanges_+3A_source">source</code></td>
<td>
<p>[character] Name of the column containing words to which to apply <code><a href="#topic+soundchange">soundchange</a></code>'s.</p>
</td></tr>
<tr><td><code id="applyChanges_+3A_target">target</code></td>
<td>
<p>[character] Name of the column containing words to which to compare the results. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="applyChanges_+3A_meta">meta</code></td>
<td>
<p>[character] Name of the column containing metadata to be passed to <code><a href="#topic+soundchange">soundchange</a></code> functions alongside words. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="applyChanges_+3A_highlight">highlight</code></td>
<td>
<p>[character] Highlight the differences between the intermediate forms in <code>$tree</code>, as well as between the results in <code>$end</code> and <code>target</code>? Can be <code>NULL</code> (do not highlight), <code>"console"</code> (highlight for the console), or <code>"HTML"</code> (highlight for a web browser). Defaults to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functions in <code><a href="#topic+soundchange">soundchange</a></code> objects are allowed to return more than one value, which makes manual application of a series of changes highly inconvenient and prone to errors. This function automates the process, while keeping track of all the intermediate forms. It returns the result in three formats: only the final shapes; their comparison to the shapes given under the <code>target</code> argument; and a tree with all the steps along the way. By default, only the final shapes are printed. All the three formats are accessible as elements of a named list: <code>$end</code>, <code>$match</code>, and <code>$tree</code>, respectively.
</p>
<p>Note that the application of sound changes does not require the data to be segmented and aligned. If sound changes are the only goal of the project, these two time-consuming steps can be safely omitted.
</p>


<h3>Value</h3>

<p>[list.applyChanges] A list with three fields: <code>$end</code>, a named list with the final results; <code>$match</code>, a named list with one of three values: <code>0</code> when none of the final results matches the <code>target</code>, <code>0.5</code> when at least one of the final results matches the <code>target</code>, or <code>1</code> when all the final results match the <code>target</code>; lastly <code>$tree</code>, a list tracing all the intermediate forms.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.list.applyChanges">print.list.applyChanges</a></code>, <code><a href="#topic+print.tree.applyChanges">print.tree.applyChanges</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># prepare sample data
dataset &lt;- loadSampleDataset ("data-capitals")
changes &lt;- list (loadSampleDataset("change-dl2l"), loadSampleDataset("change-rhotacism"))
# apply the changes
applyChanges (dataset, changes, "ORTHOGRAPHY.German")
applyChanges (dataset, changes, "ORTHOGRAPHY.German")$tree
applyChanges (dataset, changes, "ORTHOGRAPHY.German", "ORTHOGRAPHY.Polish", highlight="console")
</code></pre>

<hr>
<h2 id='binTable'>Sum all rows and all columns in a table, except for the selected ones.</h2><span id='topic+binTable'></span>

<h3>Description</h3>

<p>Useful for when the data are scarce and <code><a href="stats.html#topic+chisq.test">chisq.test</a></code> returns a warning, or when a more specific analysis of the data is required.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binTable(x, row, col)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binTable_+3A_x">x</code></td>
<td>
<p>[data.frame/matrix/table] Table to be binned.</p>
</td></tr>
<tr><td><code id="binTable_+3A_row">row</code></td>
<td>
<p>[integer/vector] The rows to not be binned.</p>
</td></tr>
<tr><td><code id="binTable_+3A_col">col</code></td>
<td>
<p>[integer/vector] The columns to not be binned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When working with sparse data, the absolute values in a table are sometimes too low to allow for the use of various statistical tests, or the features too numerous for the result of a statistical test to be clearly interpretable. In such cases, a solution may be found in binning, i.e. in combining all the rows or columns into one, with the exception of select few. For example, a 10x10 table may be thus reduced to a 2x2 or a 2x3 one. The values are magnified while the number of features is reduced.
</p>


<h3>Value</h3>

<p>[table] Table with some of its data binned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtx &lt;- matrix (1:16, nrow=4, dimnames=list(paste0("r",1:4),paste0("c",1:4)))
binTable (mtx, 1, 1)
binTable (mtx, 1, c(1,3))
</code></pre>

<hr>
<h2 id='cbind.soundcorrs'>Attach one or more columns to a <code><a href="#topic+soundcorrs">soundcorrs</a></code> object.</h2><span id='topic+cbind.soundcorrs'></span>

<h3>Description</h3>

<p>Attach one or more columns to a <code><a href="#topic+soundcorrs">soundcorrs</a></code> object. Note that sound correspondences attached with this function will not be usable as such.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'soundcorrs'
cbind(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cbind.soundcorrs_+3A_data">data</code></td>
<td>
<p>[soundcorrs] The <code><a href="#topic+soundcorrs">soundcorrs</a></code> object.</p>
</td></tr>
<tr><td><code id="cbind.soundcorrs_+3A_...">...</code></td>
<td>
<p>Objects to be attached.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Once a data frame is enclosed in a <code><a href="#topic+soundcorrs">soundcorrs</a></code> object, it is recommended that it not be manually altered in any way. <code>cbind.soundcorrs</code> provides a safe way of adding a column to it.
</p>


<h3>Value</h3>

<p>[soundcorrs] The original <code><a href="#topic+soundcorrs">soundcorrs</a></code> object with the columns attached.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dataset &lt;- loadSampleDataset ("data-ie")
cbind (dataset, ID=1:nrow(dataset$data))
cbind (dataset, FAMILY="Indo-European")
</code></pre>

<hr>
<h2 id='char2value'>Information that the <code>char2value()</code> function is obsolete.</h2><span id='topic+char2value'></span>

<h3>Description</h3>

<p>Since version 0.2.0 it is no longer available. If you need its functionality, please contact kamil.stachowski@gmail.com
</p>


<h3>Usage</h3>

<pre><code class='language-R'>char2value(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="char2value_+3A_...">...</code></td>
<td>
<p>Ignored, only for compatibility.</p>
</td></tr>
</table>

<hr>
<h2 id='checkCount'>Check if the <code>count</code> argument is correct.</h2><span id='topic+checkCount'></span>

<h3>Description</h3>

<p>Makes sure the <code>count</code> argument has one of the many available values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkCount(count)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkCount_+3A_count">count</code></td>
<td>
<p>[character] The string to check.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functions which produce contingency tables, <code><a href="#topic+coocc">coocc</a></code> and <code><a href="base.html#topic+summary">summary</a></code>, have an argument <code>count</code> which can take as many as six different values which all point to just two unique behaviours. <code>checkCount</code> reduces this multitude to just the two meaningful values. It also throws an error if <code>count</code> is none of the six possibilities.
</p>


<h3>Value</h3>

<p>[character] Either <code>"a"</code> or <code>"r"</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+checkUnit">checkUnit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>soundcorrs:::checkCount ("abs")
soundcorrs:::checkCount ("absolute")
</code></pre>

<hr>
<h2 id='checkUnit'>Check if the <code>unit</code> argument is correct.</h2><span id='topic+checkUnit'></span>

<h3>Description</h3>

<p>Makes sure the <code>unit</code> argument has one of the many available values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkUnit(unit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkUnit_+3A_unit">unit</code></td>
<td>
<p>[character] The string to check.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functions which produce contingency tables, <code><a href="#topic+coocc">coocc</a></code> and <code><a href="base.html#topic+summary">summary</a></code>, have an argument <code>count</code> which can take as many as eight different values which all point to just two unique behaviours. <code>checkCount</code> reduces this multitude to just the two meaningful values. It also throws an error if <code>count</code> is none of the eight possibilities.
</p>


<h3>Value</h3>

<p>[character] Either <code>"o"</code> or <code>"w"</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+checkCount">checkCount</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>soundcorrs:::checkUnit ("occ")
soundcorrs:::checkUnit ("occurrence")
</code></pre>

<hr>
<h2 id='collapse'>Paste and collapse.</h2><span id='topic+collapse'></span>

<h3>Description</h3>

<p>Concatenate strings, possibly interspersing them with another string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapse(..., inter = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collapse_+3A_...">...</code></td>
<td>
<p>Objects to be pasted and collapsed.</p>
</td></tr>
<tr><td><code id="collapse_+3A_inter">inter</code></td>
<td>
<p>[character] String with which to intersperse the result. Defaults to an empty string.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>paste0(..., collapse="")</code> takes a little more space than <code>collapse(...)</code>, though if the result is to be interspersed with something, the difference becomes merely one character: <code>paste0(..., collapse="_")</code> vs <code>collapse(..., inter="_")</code>.
</p>


<h3>Value</h3>

<p>[character] The collapsed string.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tmp &lt;- c ("i", "am", "a", "sample", "vector")
identical (soundcorrs:::collapse(tmp), paste0(tmp,collapse=""))
</code></pre>

<hr>
<h2 id='coocc'>Generate a contingency table of co-occurrences of sound correspondences with themselves, or with metadata.</h2><span id='topic+coocc'></span>

<h3>Description</h3>

<p>Take all segment-to-segment correspondences in a dataset, and cross-tabulate them with themselves or with metadata taken from a separate column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coocc(data, column, count, unit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coocc_+3A_data">data</code></td>
<td>
<p>[soundcorrs] The dataset from which to draw frequencies. Only datasets with two languages are supported.</p>
</td></tr>
<tr><td><code id="coocc_+3A_column">column</code></td>
<td>
<p>[character] Name of the column with metadata. If <code>NULL</code>, sound correspondences are cross-tabulated with themselves. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="coocc_+3A_count">count</code></td>
<td>
<p>[character] Report the absolute number of times or words, or relative to how many times or in how many words the given segments co-occur in L1 or L2. Accepted values are <code>"a(bs(olute))"</code> and <code>"r(el(ative))"</code>. Defaults to &quot;a&quot;.</p>
</td></tr>
<tr><td><code id="coocc_+3A_unit">unit</code></td>
<td>
<p>[character] Count how many times a correspondence occurs or in how many words it occurs. Accepted values are <code>"o(cc(ur(ence(s))))"</code> and <code>"w(or(d(s)))"</code>. Defaults to <code>"w"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A set of segmented and aligned word pairs/triples/..., such as one held in a <code><a href="#topic+soundcorrs">soundcorrs</a></code> object, can be turned into a contingency table in more than one way. This function creates a table which details how often various sound correspondences co-occur in one word. Both rows and columns are named in the same way: L1 phoneme + underscore (&quot;_&quot;) + L2 phoneme. The values in the table can be absolute or relative, and they can represent the number of times the given correspondence co-occurs, or the number of words in which it co-occurs. For example, in the pair German koala : French koala, the correspondence G a : Fr a (<code>"a_a"</code>) co-occurs twice: the correspondence of the first two a's co-occurs with the correspondence of the second two a's, and vice versa. When the numbers are relative, they add up to 1 in blocks where each block is an intersection of rows and columns whose names begin with the same segment, i.e. those which refer to the correspondences of the same segment. In the relative view, empty cells appear when the given correspondence never co-occurs, and therefore its relative frequency is 0 divided by 0.
</p>


<h3>Value</h3>

<p>[table] The contingency table. The values represent how often the given correspondence co-occurs in the same word with the other correspondence or with the piece of metadata (cf. <code><a href="base.html#topic+summary">summary</a></code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.soundcorrs">summary.soundcorrs</a></code>, <code><a href="#topic+allCooccs">allCooccs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dataset &lt;- loadSampleDataset ("data-abc")
coocc (dataset)
coocc (dataset, "DIALECT.L2")
round (coocc(dataset,"DIALECT.L2",count="r"), digits=3)
</code></pre>

<hr>
<h2 id='expandMeta'>Expand custom metacharacters to regular expressions.</h2><span id='topic+expandMeta'></span>

<h3>Description</h3>

<p>Turn characters defined in a <code><a href="#topic+transcription">transcription</a></code> as metacharacters into the corresponding regular expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expandMeta(data, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expandMeta_+3A_data">data</code></td>
<td>
<p>[transcription] The <code><a href="#topic+transcription">transcription</a></code> to use.</p>
</td></tr>
<tr><td><code id="expandMeta_+3A_x">x</code></td>
<td>
<p>[character] A single string that contains metacharacters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[character] The string with metacharacters expanded.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+transcription">transcription</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dataset &lt;- loadSampleDataset ("data-abc")
expandMeta (dataset$trans[[1]], "aN")
expandMeta (dataset$trans[[1]], "[+vow,-high]")
</code></pre>

<hr>
<h2 id='findExamples'>Find all pairs/triples/... with corresponding sequences of sounds.</h2><span id='topic+findExamples'></span>

<h3>Description</h3>

<p>Sift the dataset for word pairs/triples/... such that the first word in the first languages contains the first sequence, the one in the second language the second sequence, and so on.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findExamples(
  data,
  ...,
  distance.start,
  distance.end,
  na.value,
  zeros,
  cols,
  perl
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findExamples_+3A_data">data</code></td>
<td>
<p>[soundcorrs] The dataset in which to look.</p>
</td></tr>
<tr><td><code id="findExamples_+3A_...">...</code></td>
<td>
<p>[character] Sequences for which to look. May be regular expressions as defined in R, or in the <code><a href="#topic+transcription">transcription</a></code>. If an empty string, anything will be considered a match.</p>
</td></tr>
<tr><td><code id="findExamples_+3A_distance.start">distance.start</code></td>
<td>
<p>[integer] The allowed distance between segments where the sound sequences begin. A negative value means alignment of the beginning of sequences will not be checked. Defaults to -1.</p>
</td></tr>
<tr><td><code id="findExamples_+3A_distance.end">distance.end</code></td>
<td>
<p>[integer] The allowed distance between segments where the sound sequences end. A negative value means alignment of the end of sequences will not be checked. Defaults to -1.</p>
</td></tr>
<tr><td><code id="findExamples_+3A_na.value">na.value</code></td>
<td>
<p>[numeric] Treat <code>NA</code>'s as matches (<code>0</code>) or non-matches (<code>-1</code>)? Note that an empty string query takes precedence over <code>na.value</code>, that is even whan <code>na.value</code> is set to <code>-1</code>, <code>NA</code>'s will show up in the results when the query is an empty string. Defaults to <code>0</code>.</p>
</td></tr>
<tr><td><code id="findExamples_+3A_zeros">zeros</code></td>
<td>
<p>[logical] Take linguistic zeros into account? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="findExamples_+3A_cols">cols</code></td>
<td>
<p>[character vector] Which columns of the dataset to return as the result. Can be a vector of names, <code>"aligned"</code> (the two columns with segmented, aligned words), or <code>"all"</code> (all columns). Defaults to <code>"aligned"</code>.</p>
</td></tr>
<tr><td><code id="findExamples_+3A_perl">perl</code></td>
<td>
<p>[logical] Use Perl-compatible regular expressions? Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>One of the more time-consuming tasks, when working with sound correspondences, is looking for specific examples which realize the given correspondence. <code>findExamples</code> can fully automate this process. It has several arguments that can help fine-tune the search, of which perhaps the most important are <code>distance.start</code> and <code>distance.end</code>. It should be noted that their default values (<code>-1</code> for both) mean that <code>findExamples</code> will find every such pair/triple/... of words, that the first word contains the first query, the second word the second query, etc. &ndash; regardless of whether these segments do in fact correspond to each other in the alignment. This is intentional, and stems from the assumption that in this case, false positives are generally less harmful, and most of all easier to spot than false negatives.
</p>
<p><code>findExamples</code> accepts regular expressions in queries, both such as are available in pure R, and such as have been defined in the <code><a href="#topic+transcription">transcription</a></code>, in both notations accepted by <code><a href="#topic+expandMeta">expandMeta</a></code>. It is highly recommended that the user acquaints him or herself with the concept, as it is in it that the true power of <code>findExamples</code> lies.
</p>


<h3>Value</h3>

<p>[df.findExamples] A list with two fields: <code>$data</code>, a data frame with found examples; and <code>$which</code>, a logical vector showing which rows of <code>data</code> are considered matches.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+findPairs">findPairs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># In the examples below, non-ASCII characters had to be escaped for technical reasons.
# In the actual usage, Unicode is supported under BSD, Linux, and macOS.

# prepare sample dataset
dataset &lt;- loadSampleDataset ("data-capitals")
# find examples which have "a" in all three languages
findExamples (dataset, "a", "a", "a")
# find examples where German has schwa, and Polish and Spanish have a Vr sequence
findExamples (dataset, "\u0259", "Vr", "Vr")
# as above, but the schwa and the two vowels must be in the same segment
findExamples (dataset, "\u0259", "V(?=r)", "V(?=r)", distance.start=0, distance.end=0, perl=TRUE)
# find examples where German has a-umlaut, Polish has a or e, and Spanish has any sound at all
findExamples (dataset, "\u00E4", "[ae]", "")
# find examples where German has a linguistic zero while Polish and Spanish do not
findExamples (dataset, "-", "[^-]", "[^-]", zeros=TRUE)
# find examples where German has schwa, and Polish and Spanish have a
findExamples (dataset, "\u0259", "a", "a", distance.start=-1, distance.end=-1)
# as above, but the schwa and the two a's must be in the same segment
findExamples (dataset, "\u0259", "a", "a", distance.start=0, distance.end=0)
</code></pre>

<hr>
<h2 id='findPairs'>A convenience wrapper around <code><a href="#topic+findExamples">findExamples</a></code>.</h2><span id='topic+findPairs'></span>

<h3>Description</h3>

<p>Sift the dataset for word pairs such that the first word contains <code>x</code> and the second word contains <code>y</code> in the corresponding segment or segments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findPairs(data, x, y, exact, cols)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findPairs_+3A_data">data</code></td>
<td>
<p>[soundcorrs] The dataset in which to look. Only datasets with two languages are supported.</p>
</td></tr>
<tr><td><code id="findPairs_+3A_x">x</code></td>
<td>
<p>[character] The sequence to find in language1. May be a regular expression. If an empty string, anything will be considered a match.</p>
</td></tr>
<tr><td><code id="findPairs_+3A_y">y</code></td>
<td>
<p>[character] The sequence to find in language2. May be a regular expression. If an empty string, anything will be considered a match.</p>
</td></tr>
<tr><td><code id="findPairs_+3A_exact">exact</code></td>
<td>
<p>[numeric] If 0 or <code>FALSE</code>, <code>distance.start</code>=<code>distance.end</code>=-1, <code>na.value</code>=0, and <code>zeros</code>=<code>FALSE</code>. If 0.5, <code>distance.start</code>=<code>distance.end</code>=1, <code>na.value</code>=0, and <code>zeros</code>=<code>FALSE</code>. If 1 or <code>TRUE</code>, <code>distance.start</code>=<code>distance.end</code>=0, <code>na.value</code>=-1, and <code>zeros</code>=<code>TRUE</code>. Defaults to 0.</p>
</td></tr>
<tr><td><code id="findPairs_+3A_cols">cols</code></td>
<td>
<p>[character vector] Which columns of the dataset to return as the result. Can be a vector of names, <code>"aligned"</code> (the two columns with segmented, aligned words), or <code>"all"</code> (all columns). Defaults to <code>"aligned"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probably the most common usage of <code><a href="#topic+findExamples">findExamples</a></code> is with datasets containing pairs of words. This function is a simple wrapper around <code><a href="#topic+findExamples">findExamples</a></code> which hopes to facilitate its use in this most common case. Instead of the five arguments that <code><a href="#topic+findExamples">findExamples</a></code> requires, this function only takes two. It is, of course, at the cost of control but should a more fine-tuned search be required, <code><a href="#topic+findExamples">findExamples</a></code> can always still be used instead of <code>findPairs</code>.
</p>
<p>The default is the inexact mode (<code>exact</code> set to <code>0</code> or <code>FALSE</code>). It corresponds to <code>distance.start</code> and <code>distance.end</code> being both set to <code>-1</code>, <code>na.value</code> being set to <code>0</code>, and <code>zeros</code> being set to <code>FALSE</code>, which are also the default settings in <code>findExamples()</code>. The risk here are false positives. In my experience, however, those are rare, and because they are displayed, the user has a chance to spot them.
</p>
<p>The opposite is the exact mode (<code>exact</code> set to 1 or <code>TRUE</code>), which corresponds to <code>distance.start</code> and <code>distance.end</code> being both set to <code>0</code>, <code>na.value</code> being set to <code>-1</code>, and <code>zeros</code> to <code>TRUE</code>. The risk are false negatives, in my experience both much more common than false positives in the inexact mode, and effectively impossible to spot as they are simply not displayed.
</p>
<p>A middle ground is the semi-exact mode (<code>exact</code> set to 0.5), where <code>distance.start</code> and <code>distance.end</code> are both set to <code>1</code>, <code>na.value</code> is set to <code>0</code>, and <code>zeros</code> to <code>FALSE</code>. It decreases the risk of false positives while increasing only a little the risk of false negatives.
</p>


<h3>Value</h3>

<p>[df.findExamples] A subset of the dataset, containing only the pairs with corresponding sequences. Warning: pairs with multiple occurrences of such sequences are only included once.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+findExamples">findExamples</a></code>, <code><a href="#topic+allPairs">allPairs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># In the examples below, non-ASCII characters had to be escaped for technical reasons.
# In the actual usage, Unicode is supported under BSD, Linux, and macOS.

# prepare sample dataset
dataset &lt;- loadSampleDataset ("data-ie")
# run findPairs
findPairs (dataset, "a", "a")
findPairs (dataset, "e", "f", exact=0)
findPairs (dataset, "e", "f", exact=0.5)
findPairs (dataset, "e", "f", exact=1)
</code></pre>

<hr>
<h2 id='findSegments'>Information that the <code>findSegments</code> function is obsolete.</h2><span id='topic+findSegments'></span>

<h3>Description</h3>

<p>Since version 0.2.0 it is no longer available. If you need its functionality, please contact kamil.stachowski@gmail.com
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findSegments(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findSegments_+3A_...">...</code></td>
<td>
<p>Ignored, only for compatibility.</p>
</td></tr>
</table>

<hr>
<h2 id='fitTable'>Fit multiple models to multiple datasets.</h2><span id='topic+fitTable'></span>

<h3>Description</h3>

<p>Apply <code><a href="#topic+multiFit">multiFit</a></code> to all rows or all columns of a table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitTable(models, data, margin, conv = vec2df.id, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitTable_+3A_models">models</code></td>
<td>
<p>[list] A list of models to fit <code>data</code> to. Each element must be a list with at least two named fields: <code>formula</code> which contains the formula, and <code>start</code> which is a list of lists of starting estimates. Regarding the formula, the converter functions (<code>fun</code>, below) use &quot;X&quot; and &quot;Y&quot; for column names.</p>
</td></tr>
<tr><td><code id="fitTable_+3A_data">data</code></td>
<td>
<p>[matrix/table] The data to fit <code>models</code> to.</p>
</td></tr>
<tr><td><code id="fitTable_+3A_margin">margin</code></td>
<td>
<p>[integer] As in <code><a href="base.html#topic+apply">apply</a></code>: the subscripts which the fitting function (cf. <code><a href="#topic+multiFit">multiFit</a></code>) will be applied over. Accepted values are: <code>1</code> for rows, and <code>2</code> for columns.</p>
</td></tr>
<tr><td><code id="fitTable_+3A_conv">conv</code></td>
<td>
<p>[function] Function that converts vectors into data frames to which <code>models</code> will be fitted. Available functions are: <code>vec2df.id</code>, <code>vec2df.hist</code>, and <code>vec2df.rank</code>. Defaults to <code>vec2df.id</code>.</p>
</td></tr>
<tr><td><code id="fitTable_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+multiFit">multiFit</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Finding the right model and the right starting estimates for a model is often a time consuming process, very inconvenient to do manually. This function automates it as much as possible. It takes a list of models and starting estimates, as well as a list of datasets, and fits all the models to all the datasets. If any of the fits results in an error or a warning, the message is saved and can be inspected in the output, but it does not halt the process. <code>fitTable</code> is an extension of <code><a href="#topic+multiFit">multiFit</a></code> which fits multiple models to a single dataset.
</p>


<h3>Value</h3>

<p>[list.multiFit] A list of results returned by the fitting function (cf. <code><a href="#topic+multiFit">multiFit</a></code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+multiFit">multiFit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dataset &lt;- loadSampleDataset ("data-abc")
models &lt;- list (
"model A" = list (
	formula = "Y ~ a/X",
	start = list (list(a=1))),
"model B" = list (
	formula = "Y ~ a/(1+exp(1)^X)",
	start = list (list(a=1)))
)
fitTable (models, summary(dataset), 1, vec2df.rank)
</code></pre>

<hr>
<h2 id='formatter.html'>A formatter for <code><a href="#topic+allPairs">allPairs</a></code>. This one formats to HTML.</h2><span id='topic+formatter.html'></span>

<h3>Description</h3>

<p>A formatter for <code><a href="#topic+allPairs">allPairs</a></code>. This one formats to HTML.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formatter.html(what, x, direction = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formatter.html_+3A_what">what</code></td>
<td>
<p>[character] What type of data is <code>x</code>.</p>
</td></tr>
<tr><td><code id="formatter.html_+3A_x">x</code></td>
<td>
<p>The object to be formatted.</p>
</td></tr>
<tr><td><code id="formatter.html_+3A_direction">direction</code></td>
<td>
<p>[integer] If 1, correspondences are in the order Language1 &gt; Language2 (&quot;x yields y&quot;). If 2, the order is Language2 &lt; Language1 (&quot;y originates from x&quot;). Defaults to 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[character] Formatted x.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># prepare sample dataset
fTrans &lt;- system.file ("extdata", "trans-common.tsv", package="soundcorrs")
fData &lt;- system.file ("extdata", "data-capitals.tsv", package="soundcorrs")
tmp.ger &lt;- read.soundcorrs (fData, "German", "ALIGNED.German", fTrans)
tmp.pol &lt;- read.soundcorrs (fData, "Polish", "ALIGNED.Polish", fTrans)
dataset &lt;- merge (tmp.ger, tmp.pol)
# run allPairs
allPairs (dataset, unit="o", formatter=formatter.html)
</code></pre>

<hr>
<h2 id='formatter.latex'>A formatter for <code><a href="#topic+allPairs">allPairs</a></code>. This one formats to LaTeX.</h2><span id='topic+formatter.latex'></span>

<h3>Description</h3>

<p>A formatter for <code><a href="#topic+allPairs">allPairs</a></code>. This one formats to LaTeX.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formatter.latex(what, x, direction = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formatter.latex_+3A_what">what</code></td>
<td>
<p>[character] What type of data is <code>x</code>.</p>
</td></tr>
<tr><td><code id="formatter.latex_+3A_x">x</code></td>
<td>
<p>The object to be formatted.</p>
</td></tr>
<tr><td><code id="formatter.latex_+3A_direction">direction</code></td>
<td>
<p>[integer] If 1, correspondences are in the order Language1 &gt; Language2 (&quot;x yields y&quot;). If 2, the order is Language2 &lt; Language1 (&quot;y originates from x&quot;). Defaults to 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[character] Formatted x.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># prepare sample dataset
fTrans &lt;- system.file ("extdata", "trans-common.tsv", package="soundcorrs")
fData &lt;- system.file ("extdata", "data-capitals.tsv", package="soundcorrs")
tmp.ger &lt;- read.soundcorrs (fData, "German", "ALIGNED.German", fTrans)
tmp.pol &lt;- read.soundcorrs (fData, "Polish", "ALIGNED.Polish", fTrans)
dataset &lt;- merge (tmp.ger, tmp.pol)
# run allPairs
allPairs (dataset, unit="o", formatter=formatter.latex)
</code></pre>

<hr>
<h2 id='formatter.none'>A formatter for <code><a href="#topic+allPairs">allPairs</a></code>. This one does practically no formatting at all.</h2><span id='topic+formatter.none'></span>

<h3>Description</h3>

<p>A formatter for <code><a href="#topic+allPairs">allPairs</a></code>. This one does practically no formatting at all.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formatter.none(what, x, direction = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formatter.none_+3A_what">what</code></td>
<td>
<p>[character] What type of data is <code>x</code>.</p>
</td></tr>
<tr><td><code id="formatter.none_+3A_x">x</code></td>
<td>
<p>The object to be formatted.</p>
</td></tr>
<tr><td><code id="formatter.none_+3A_direction">direction</code></td>
<td>
<p>[integer] If 1, correspondences are in the order Language1 &gt; Language2 (&quot;x yields y&quot;). If 2, the order is Language2 &lt; Language1 (&quot;y originates from x&quot;). Defaults to 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[character] Formatted x.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># prepare sample dataset
fTrans &lt;- system.file ("extdata", "trans-common.tsv", package="soundcorrs")
fData &lt;- system.file ("extdata", "data-capitals.tsv", package="soundcorrs")
tmp.ger &lt;- read.soundcorrs (fData, "German", "ALIGNED.German", fTrans)
tmp.pol &lt;- read.soundcorrs (fData, "Polish", "ALIGNED.Polish", fTrans)
dataset &lt;- merge (tmp.ger, tmp.pol)
# run allPairs
allPairs (dataset, unit="o", formatter=formatter.none)
</code></pre>

<hr>
<h2 id='highlight'>Highlight differences between strings.</h2><span id='topic+highlight'></span>

<h3>Description</h3>

<p>Add a prefix and a suffix to all the substrings that are different between a vector of source strings, and a target string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>highlight(source, target, affixes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="highlight_+3A_source">source</code></td>
<td>
<p>[character] A vector of strings to be highlighted.</p>
</td></tr>
<tr><td><code id="highlight_+3A_target">target</code></td>
<td>
<p>[character] A string to which <code>source</code> strings are to be compared.</p>
</td></tr>
<tr><td><code id="highlight_+3A_affixes">affixes</code></td>
<td>
<p>[character] A vector of two strings: the first to be prepended to highlighted bits, and the second to be appended to them.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The effect is similar to Unix <code>diff</code>, only all the differences are highlighted in the same colour, and a <code>"_"</code> is inerted where characters are missing. To save on speed, the function does not check the arguments are correct, etc.
</p>


<h3>Value</h3>

<p>[character] The highlighted strings.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cat (soundcorrs:::highlight (c("kitten","mitten"), "sitting", c("\u001b[31m","\u001b[0m")))
</code></pre>

<hr>
<h2 id='lapplyTest'>Apply a function to a list.</h2><span id='topic+lapplyTest'></span>

<h3>Description</h3>

<p>Takes a list and applies to each of its elements a function, returning a list of outputs. Primary intended for tests of independence on a list of contingency tables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lapplyTest(x, fun = chisq.test, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lapplyTest_+3A_x">x</code></td>
<td>
<p>[list] The list to which to apply <code>fun</code>.</p>
</td></tr>
<tr><td><code id="lapplyTest_+3A_fun">fun</code></td>
<td>
<p>[function] The function which to apply to <code>data</code>. Must return an object containing an element named <code>p.value</code>. Defaults to <code><a href="stats.html#topic+chisq.test">chisq.test</a></code>.</p>
</td></tr>
<tr><td><code id="lapplyTest_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>fun</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When applying a function to a list, any iteration that results in an error, breaks the whole loop. This is not always the most convenient behaviour, in particular when the function is a statistical test and the error is to do with sparse data in one of the tables in the list. <code>lapplyTest</code> is a wrapper around <code>base::lapply</code> which only differs from the original in its treatment of errors. It saves the message associated with the error or warning, but then continues to the next iteration rather than quitting the loop altogether.
</p>


<h3>Value</h3>

<p>[list.lapplyTest] A list of outputs of <code>fun</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.list.lapplyTest">summary.list.lapplyTest</a></code>, <code><a href="#topic+allCooccs">allCooccs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dataset &lt;- loadSampleDataset ("data-abc")
lapplyTest (allCooccs(dataset))
lapplyTest (allCooccs(dataset), fisher.test, simulate.p.value=TRUE)
</code></pre>

<hr>
<h2 id='list.depth'>Measure the depth of a nested list.</h2><span id='topic+list.depth'></span>

<h3>Description</h3>

<p>Check how many levels of nesting there are in a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.depth(x, d = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.depth_+3A_x">x</code></td>
<td>
<p>[list] The list whose depth is to be gauged.</p>
</td></tr>
<tr><td><code id="list.depth_+3A_d">d</code></td>
<td>
<p>[integer] A technical variable, not supposed to be defined by the user. Defaults to <code>0</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Checks how many times a list is nested. The function is recursive, but to save on execution time it doesn't have an elegant wrapper around it and has the argument <code>d</code> which collects the result, and which the user is supposed not to tinker with.
</p>


<h3>Value</h3>

<p>[integer] The depth of <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>soundcorrs:::list.depth (list (1))
soundcorrs:::list.depth (list (list (1, list(2))))
</code></pre>

<hr>
<h2 id='list.transpose'>Transpose a nested list.</h2><span id='topic+list.transpose'></span>

<h3>Description</h3>

<p>Taken from https://rdrr.io/cran/stackoverflow/src/R/tlist.R. I prefer to copy a short bit of code than to add a dependency.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.transpose(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.transpose_+3A_x">x</code></td>
<td>
<p>[list] The list to be transposed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>R's <code><a href="base.html#topic+t">t</a></code> function does not have a method for lists. This pretty little piece of code is effectively that. Say you have a list with three sublists, each containg a vector of ten elements. The three sublists are languages, and the ten elements are words in those languages. Functions from the <code><a href="base.html#topic+apply">apply</a></code> family only let you loop through languages and with each iteration you have access to all the words from the given language, but only from that language. <code>list.transpose</code> turns such a list into a list of ten sublists, each containing a vector with three elements &ndash; so you can loop through words, and have in each iteration access to word nr 1 from all three languages, then word nr 2, and so on.
</p>


<h3>Value</h3>

<p>[list] The transposed list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>soundcorrs:::list.transpose (list (1:3, 4:6, 7:9))
</code></pre>

<hr>
<h2 id='loadSampleDataset'>Load one of <code><a href="#topic+soundcorrs">soundcorrs</a></code>' sample datasets.</h2><span id='topic+loadSampleDataset'></span>

<h3>Description</h3>

<p>Retrieve and return one the sample datasets included in <code><a href="#topic+soundcorrs">soundcorrs</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadSampleDataset(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loadSampleDataset_+3A_x">x</code></td>
<td>
<p>[character] Name of the dataset to load. Available sets are: <code><a href="#topic+soundchange">soundchange</a></code>'s: <code>change-dl2l</code>, <code>change-palatalization</code>, <code>change-rhotacism</code>; <code><a href="#topic+soundcorrs">soundcorrs</a></code>'s: <code>data-abc</code>, <code>data-capitals</code>, <code>data-ie</code>; and <code><a href="#topic+transcription">transcription</a></code>'s: <code>trans-common</code>, <code>trans-ipa</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>R does not allow non-ASCII characters in preloaded datasets, and linguistic datasets can hardly fit within ASCII. Unicode is, however, allowed in raw data files. They cannot be automatically loaded when <code><a href="#topic+soundcorrs">soundcorrs</a></code> is attached because staged install makes it impossible to use <code><a href="base.html#topic+system.file">system.file</a></code> in this manner, and they cannot be included as a Unicode-escaped output of <code><a href="base.html#topic+dput">dput</a></code> because Windows does not know how to convert this to its native encoding. This function makes the process of loading as painless as possible.
</p>


<h3>Value</h3>

<p>[soundchange/soundcorrs/transcription] The selected sample dataset.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>loadSampleDataset ("data-abc")
loadSampleDataset ("trans-ipa")
loadSampleDataset ("change-palatalization")
</code></pre>

<hr>
<h2 id='long2wide'>Convert from the long format (single entry per row) to the wide format (multiple entries per row).</h2><span id='topic+long2wide'></span>

<h3>Description</h3>

<p>Takes a data frame of word pairs/triples/..., each stored in multiple rows, and returns a data frame with the same words but each pair/triple/... stored in one row. WARNING: in the original data frame, entries from all languages must be in the same order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>long2wide(data, col.lang = "LANGUAGE", skip = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="long2wide_+3A_data">data</code></td>
<td>
<p>[data.frame] The dataset to be converted.</p>
</td></tr>
<tr><td><code id="long2wide_+3A_col.lang">col.lang</code></td>
<td>
<p>[character] Name of the column with language names. Defaults to <code>"LANGUAGE"</code>.</p>
</td></tr>
<tr><td><code id="long2wide_+3A_skip">skip</code></td>
<td>
<p>[character vector] Names of columns to not convert. Defaults to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Data for <code><a href="#topic+soundcorrs">soundcorrs</a></code> can be prepared in one of two formats: the 'long format' and the 'wide format'. In the 'long format', each row contains only a single word and metadata associated with it. In the 'wide format', each row contains the entire pair/triple/... of words, and all the metadata associated with them. The 'long format' is convenient for making sure that all the words in a pair/triple/... have the same number of segments, but it cannot be read directly by <code><a href="#topic+soundcorrs">soundcorrs</a></code>. <code>long2wide</code> and <code><a href="#topic+wide2long">wide2long</a></code> convert between the two formats.
</p>


<h3>Value</h3>

<p>[data.frame] A data frame in the wide format (multiple entries per row).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wide2long">wide2long</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># path to sample data in the "long format"
fName &lt;- system.file ("extdata", "data-abc.tsv", package="soundcorrs")
long &lt;- read.table (fName, header=TRUE)
wide &lt;- long2wide (long, skip=c("ID"))
</code></pre>

<hr>
<h2 id='merge.soundcorrs'>Merge two or more <code><a href="#topic+soundcorrs">soundcorrs</a></code> objects.</h2><span id='topic+merge.soundcorrs'></span>

<h3>Description</h3>

<p>Take multiple <code><a href="#topic+soundcorrs">soundcorrs</a></code> objects and combine them into one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'soundcorrs'
merge(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge.soundcorrs_+3A_...">...</code></td>
<td>
<p>[soundcorrs] Objects to be merged.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Data can be turned into a <code><a href="#topic+soundcorrs">soundcorrs</a></code> object using either <code><a href="#topic+read.soundcorrs">read.soundcorrs</a></code> or, the less preferred method, the raw <code><a href="#topic+soundcorrs">soundcorrs</a></code> constructor. However, both can only produce <code><a href="#topic+soundcorrs">soundcorrs</a></code> objects with only the data for a single language in them, whereas the typical usage of the <code>soundcorrs</code> package would require it to hold data for several languages simultaneously. This function can be used to safely combine multiple <code><a href="#topic+soundcorrs">soundcorrs</a></code> objects into one. The individual objects can all hold data for one or more languages, the only requirement being that the data from the different languages are compatible with each other, i.e. that they have the same number of words, and each word has the same number of segments as its counterparts in the pair/triple/.... An error will be also thrown if two or more of the datasets contain a column with the same name and different content, or when they contain two or more rows with identical content.
</p>


<h3>Value</h3>

<p>[soundcorrs] The single, merged object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># path to sample data in the "wide format"
fNameData &lt;- system.file ("extdata", "data-capitals.tsv", package="soundcorrs")
# path to a sample transcription
fNameTrans &lt;- system.file ("extdata", "trans-common.tsv", package="soundcorrs")
ger &lt;- read.soundcorrs (fNameData, "German", "ALIGNED.German", fNameTrans)
pol &lt;- read.soundcorrs (fNameData, "Polish", "ALIGNED.Polish", fNameTrans)
merge (ger, pol)
</code></pre>

<hr>
<h2 id='multiFit'>Fit multiple models to one dataset.</h2><span id='topic+multiFit'></span>

<h3>Description</h3>

<p>Apply a fitting function, with multiple models and multiple starting estimates, to one dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiFit(models, data, fun = nls, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiFit_+3A_models">models</code></td>
<td>
<p>[list] A list of models to fit <code>data</code> to. Each element must be a list with at least two named fields: <code>formula</code> which contains the formula, and <code>start</code> which is a list of lists of starting estimates.</p>
</td></tr>
<tr><td><code id="multiFit_+3A_data">data</code></td>
<td>
<p>[numeric data.frame/list] A list of vectors to fit <code>models</code> to.</p>
</td></tr>
<tr><td><code id="multiFit_+3A_fun">fun</code></td>
<td>
<p>[function] The function to use for fitting. Defaults to <code>nls</code>.</p>
</td></tr>
<tr><td><code id="multiFit_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>fun</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Finding the right model and the right starting estimates for a model is often a time consuming process, very inconvenient to do manually. This function automates it as much as possible. It takes a list of models and starting estimates, and fits them to data not stopping whenever an error occurs or a warning is issued. Error and warning messages are saved and can be inspected in the output, they just do not halt the process. <code>multiFit</code> has an extension in the form of <code><a href="#topic+fitTable">fitTable</a></code> which applies multiple models to multiple datasets.
</p>


<h3>Value</h3>

<p>[list.multiFit] A list of results returned by <code>fun</code> or, if it ended with an error, <code>NULL</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitTable">fitTable</a></code>, <code><a href="#topic+summary.list.multiFit">summary.list.multiFit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed (27)
dataset &lt;- data.frame (X=1:10, Y=(1:10)^2+runif(10,-10,10))
models &lt;- list (
"model A" = list (
	formula = "Y ~ X^a",
	start = list (list(a=100), list(a=1))),
"model B" = list (
	formula = "Y ~ a*(X+b)",
	start = list (list(a=1,b=1)))
)
multiFit (models, dataset)
</code></pre>

<hr>
<h2 id='ngrams'>N-grams and their frequencies.</h2><span id='topic+ngrams'></span>

<h3>Description</h3>

<p>Find n-grams of specified length and return them as a list, or their counts as a table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ngrams(x, n = 1, borders = c("", ""), rm = "", as.table = T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ngrams_+3A_x">x</code></td>
<td>
<p>[character vector] Words to be cut into n-grams.</p>
</td></tr>
<tr><td><code id="ngrams_+3A_n">n</code></td>
<td>
<p>[integer] The length of n-grams to look for. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="ngrams_+3A_borders">borders</code></td>
<td>
<p>[character] Characters to prepend and append to every word. Must be a vector of exactly two character strings. Defaults to <code>c("","")</code>.</p>
</td></tr>
<tr><td><code id="ngrams_+3A_rm">rm</code></td>
<td>
<p>[character] Characters to be removed from <code>x</code> before cutting into n-grams. May be a regular expression, f.ex. &quot;[-\|]&quot; will capture the default symbol for linguistics zeros as well as the default segment separators. Empty string denotes nothing to replace. Defaults to empty string.</p>
</td></tr>
<tr><td><code id="ngrams_+3A_as.table">as.table</code></td>
<td>
<p>[logical] Return the result as a table? Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Data processed with <code><a href="#topic+soundcorrs">soundcorrs</a></code> are generally expected to be segmented and aligned, and both segmentation and alignment are recommended to be performed manually. This is a laborious process, but it is feasible when segments represent morphemes or phonemes. Should segments represent n-grams, however, the fully manual approach would have been very time consuming and prone to errors.
</p>


<h3>Value</h3>

<p>[table] Table with counts of n-grams.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dataset &lt;- loadSampleDataset ("data-capitals")
ngrams(dataset$data[,"ALIGNED.German"], n=2)
ngrams(dataset$data[,"ALIGNED.German"], n=3, as.table=FALSE)
ngrams(dataset$data[,"ALIGNED.German"], n=4, rm="[-\\|]", as.table=FALSE)
ngrams(dataset$data[,"ALIGNED.German"], n=5, borders=c("&gt;","&lt;"), rm="[-\\|]", as.table=FALSE)
</code></pre>

<hr>
<h2 id='ngrams.scOne'>Information that the <code>scOne</code> class is obsolete.</h2><span id='topic+ngrams.scOne'></span>

<h3>Description</h3>

<p>Since version 0.2.0 it has been replaced with the <code><a href="#topic+soundcorrs">soundcorrs</a></code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ngrams.scOne(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ngrams.scOne_+3A_...">...</code></td>
<td>
<p>Ignored, only for compatibilty.</p>
</td></tr>
</table>

<hr>
<h2 id='path2name'>Extract file name from path string.</h2><span id='topic+path2name'></span>

<h3>Description</h3>

<p>Convert a path to file to just its name, without the path or the extension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>path2name(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="path2name_+3A_x">x</code></td>
<td>
<p>[character] Path to a file.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A combination of <code><a href="base.html#topic+basename">basename</a></code> to strip the path, and <code>tools::file_path_sans_ext</code> to strip the extension.
</p>


<h3>Value</h3>

<p>[character] The name of the file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sapply (list.files("~",full.names=TRUE), soundcorrs:::path2name)
</code></pre>

<hr>
<h2 id='print.df.findExamples'>Pretty printing for the result of <code><a href="#topic+findExamples">findExamples</a></code>.</h2><span id='topic+print.df.findExamples'></span>

<h3>Description</h3>

<p>Pretty printing for the result of <code><a href="#topic+findExamples">findExamples</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'df.findExamples'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.df.findExamples_+3A_x">x</code></td>
<td>
<p>[df.findExamples] The output of <code><a href="#topic+findExamples">findExamples</a></code>.</p>
</td></tr>
<tr><td><code id="print.df.findExamples_+3A_...">...</code></td>
<td>
<p>Unused; only for consistency with <code><a href="base.html#topic+print">print</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output of <code><a href="#topic+findExamples">findExamples</a></code> is a list, potentially a very long one, and difficult to read. To make it easier to digest, this function only prints the <code>$data</code> element, i.e. the found matches.
</p>


<h3>Value</h3>

<p>[df.findExamples] The same object that was given as <code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+findExamples">findExamples</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dataset &lt;- loadSampleDataset ("data-capitals")
findExamples (dataset, "a", "a", "a", cols="all")
</code></pre>

<hr>
<h2 id='print.list.applyChanges'>Pretty printing for the result of <code><a href="#topic+applyChanges">applyChanges</a></code>.</h2><span id='topic+print.list.applyChanges'></span>

<h3>Description</h3>

<p>Pretty printing for the result of <code><a href="#topic+applyChanges">applyChanges</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'list.applyChanges'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.list.applyChanges_+3A_x">x</code></td>
<td>
<p>[list.applyChanges] The output of <code><a href="#topic+applyChanges">applyChanges</a></code>.</p>
</td></tr>
<tr><td><code id="print.list.applyChanges_+3A_...">...</code></td>
<td>
<p>Unused; only for consistency with <code><a href="base.html#topic+print">print</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output of <code><a href="#topic+applyChanges">applyChanges</a></code> is a list, potentially a very long one, and difficult to read. To make it easier to digest, this function only prints the <code>$end</code> element, i.e. the final shapes produced by the application of all of the sound changes.
</p>


<h3>Value</h3>

<p>[list.applyChanges] The same object that was given as <code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+applyChanges">applyChanges</a></code>, <code><a href="#topic+print.tree.applyChanges">print.tree.applyChanges</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># prepare sample data
dataset &lt;- loadSampleDataset ("data-capitals")
changes &lt;- list (loadSampleDataset("change-dl2l"), loadSampleDataset("change-rhotacism"))
# apply the changes
applyChanges (dataset, changes, "ORTHOGRAPHY.German")
applyChanges (dataset, changes, "ORTHOGRAPHY.German", "ORTHOGRAPHY.Polish", highlight="console")
</code></pre>

<hr>
<h2 id='print.scOne'>Information that the <code>scOne</code> class is obsolete.</h2><span id='topic+print.scOne'></span>

<h3>Description</h3>

<p>Since version 0.2.0 it has been replaced with the <code><a href="#topic+soundcorrs">soundcorrs</a></code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scOne'
print(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.scOne_+3A_...">...</code></td>
<td>
<p>Ignored, only for compatibilty.</p>
</td></tr>
</table>

<hr>
<h2 id='print.soundchange'>A more reasonable display of a <code><a href="#topic+soundchange">soundchange</a></code> object.</h2><span id='topic+print.soundchange'></span>

<h3>Description</h3>

<p>A more reasonable display of a <code><a href="#topic+soundchange">soundchange</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'soundchange'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.soundchange_+3A_x">x</code></td>
<td>
<p>[soundchange] The <code><a href="#topic+soundchange">soundchange</a></code> object.</p>
</td></tr>
<tr><td><code id="print.soundchange_+3A_...">...</code></td>
<td>
<p>Unused; only for consistency with <code><a href="base.html#topic+print">print</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The structure of a <code><a href="#topic+soundchange">soundchange</a></code> object is probably not too dificult to read for a human, but this does not mean it cannot be presented in a slightly more convenient form.
</p>


<h3>Value</h3>

<p>[soundchange] The same object that was given as <code>x</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+soundchange">soundchange</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># prepare sample transcription
trans &lt;- loadSampleDataset ("trans-common")
# run print.soundchange
a2b &lt;- soundchange ("a &gt; b", "sample change", trans,
"This is a very simple sample sound change whereby \"a\" is turned into \"b\".")
a2b
</code></pre>

<hr>
<h2 id='print.soundcorrs'>A more reasonable display of a <code><a href="#topic+soundcorrs">soundcorrs</a></code> object.</h2><span id='topic+print.soundcorrs'></span>

<h3>Description</h3>

<p>A more reasonable display of a <code><a href="#topic+soundcorrs">soundcorrs</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'soundcorrs'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.soundcorrs_+3A_x">x</code></td>
<td>
<p>[soundcorrs] The <code><a href="#topic+soundcorrs">soundcorrs</a></code> object.</p>
</td></tr>
<tr><td><code id="print.soundcorrs_+3A_...">...</code></td>
<td>
<p>Unused; only for consistency with <code><a href="base.html#topic+print">print</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code><a href="#topic+soundcorrs">soundcorrs</a></code> may be quite large and therefore difficult to digest for a human. This function reduces it to a brief, easy to understand summary.
</p>


<h3>Value</h3>

<p>[soundcorrs] The same object that was given as <code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+soundcorrs">soundcorrs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dataset &lt;- loadSampleDataset ("data-abc")
dataset
</code></pre>

<hr>
<h2 id='print.transcription'>A more reasonable display of a <code><a href="#topic+transcription">transcription</a></code> object.</h2><span id='topic+print.transcription'></span>

<h3>Description</h3>

<p>A more reasonable display of a <code><a href="#topic+transcription">transcription</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'transcription'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.transcription_+3A_x">x</code></td>
<td>
<p>[transcription] The <code><a href="#topic+transcription">transcription</a></code> object.</p>
</td></tr>
<tr><td><code id="print.transcription_+3A_...">...</code></td>
<td>
<p>Unused; only for consistency with <code><a href="base.html#topic+print">print</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code><a href="#topic+transcription">transcription</a></code> object may be quite large and therefore difficult to digest for a human. This function reduces it to a brief, easy to understand summary.
</p>


<h3>Value</h3>

<p>[transcription] The same object that was given as <code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+transcription">transcription</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># path to a sample transcription
fName &lt;- system.file ("extdata", "trans-common.tsv", package="soundcorrs")
read.transcription (fName)
</code></pre>

<hr>
<h2 id='print.tree.applyChanges'>Pretty printing for part of the result of <code><a href="#topic+applyChanges">applyChanges</a></code>.</h2><span id='topic+print.tree.applyChanges'></span>

<h3>Description</h3>

<p>Pretty printing for part of the result of <code><a href="#topic+applyChanges">applyChanges</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tree.applyChanges'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.tree.applyChanges_+3A_x">x</code></td>
<td>
<p>[tree.applyChanges] The <code>tree</code> element in the output of <code><a href="#topic+applyChanges">applyChanges</a></code>.</p>
</td></tr>
<tr><td><code id="print.tree.applyChanges_+3A_...">...</code></td>
<td>
<p>Unused; only for consistency with <code><a href="base.html#topic+print">print</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>One of the elements in the output of <code><a href="#topic+applyChanges">applyChanges</a></code> is a tree. It is represented as a nested list, potentially a very deeply nested and a very long list which would have been all but impossible to digest for a human. This function prints it as a structure that more resembles a tree, very similar to the output of <code><a href="utils.html#topic+str">str</a></code>.
</p>


<h3>Value</h3>

<p>[tree.applyChanges] The same object that was given as <code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+applyChanges">applyChanges</a></code>, <code><a href="#topic+print.list.applyChanges">print.list.applyChanges</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># prepare sample data
dataset &lt;- loadSampleDataset ("data-capitals")
changes &lt;- list (loadSampleDataset("change-dl2l"), loadSampleDataset("change-rhotacism"))
# apply the changes
applyChanges (dataset, changes, "ORTHOGRAPHY.German")$tree
</code></pre>

<hr>
<h2 id='read.scOne'>Information that the <code>scOne</code> class is obsolete.</h2><span id='topic+read.scOne'></span>

<h3>Description</h3>

<p>Since version 0.2.0 it has been replaced with the <code><a href="#topic+soundcorrs">soundcorrs</a></code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.scOne(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.scOne_+3A_...">...</code></td>
<td>
<p>Ignored, only for compatibilty.</p>
</td></tr>
</table>

<hr>
<h2 id='read.soundcorrs'>Read data for a single language from a tsv file.</h2><span id='topic+read.soundcorrs'></span>

<h3>Description</h3>

<p>Read the data for one language, from a file in the wide format, and combine it with metadata into a <code><a href="#topic+soundcorrs">soundcorrs</a></code> object. To obtain a <code>soundcorrs</code> object containing data for multiple languages, see <code><a href="#topic+merge.soundcorrs">merge.soundcorrs</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.soundcorrs(file, name, col.aligned, transcription, separator = "\\|")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.soundcorrs_+3A_file">file</code></td>
<td>
<p>[character] Path to the data file in the wide format.</p>
</td></tr>
<tr><td><code id="read.soundcorrs_+3A_name">name</code></td>
<td>
<p>[character] Name of the language.</p>
</td></tr>
<tr><td><code id="read.soundcorrs_+3A_col.aligned">col.aligned</code></td>
<td>
<p>[character] Name of the column with the aligned words.</p>
</td></tr>
<tr><td><code id="read.soundcorrs_+3A_transcription">transcription</code></td>
<td>
<p>[character] Path to the file with the transcription.</p>
</td></tr>
<tr><td><code id="read.soundcorrs_+3A_separator">separator</code></td>
<td>
<p>[character] String used to separate segments in <code>col.aligned</code>. Defaults to <code>"\|"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The constructor for the <code><a href="#topic+soundcorrs">soundcorrs</a></code> class requires a data frame and a <code><a href="#topic+transcription">transcription</a></code> object which means that the user would need to first read both from a file, and only then pass them to the constructor. This function saves these two steps. In addition, it attaches the name of the file to the object, which allows for easier identification later. It is recommended to use <code>read.soundcorrs</code> instead of the raw <code><a href="#topic+soundcorrs">soundcorrs</a></code> constructor whenever possible.
</p>


<h3>Value</h3>

<p>[soundcorrs] An object containing the data and metadata for one language.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+soundcorrs">soundcorrs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># path to sample data in the "wide format"
fNameData &lt;- system.file ("extdata", "data-ie.tsv", package="soundcorrs")
# path to a sample transcription
fNameTrans &lt;- system.file ("extdata", "trans-common.tsv", package="soundcorrs")
ger &lt;- read.soundcorrs (fNameData, "Latin", "LATIN", fNameTrans)
</code></pre>

<hr>
<h2 id='read.transcription'>Read transcription from a tsv file.</h2><span id='topic+read.transcription'></span>

<h3>Description</h3>

<p>Read a table from file and create a <code><a href="#topic+transcription">transcription</a></code> object out of it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.transcription(
  file,
  col.grapheme = "GRAPHEME",
  col.meta = "META",
  col.value = "VALUE"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.transcription_+3A_file">file</code></td>
<td>
<p>[character] Path to the data file.</p>
</td></tr>
<tr><td><code id="read.transcription_+3A_col.grapheme">col.grapheme</code></td>
<td>
<p>[character] Name of the column with graphemes. Defaults to <code>"GRAPHEME"</code>.</p>
</td></tr>
<tr><td><code id="read.transcription_+3A_col.meta">col.meta</code></td>
<td>
<p>[character] Name of the column with the coverage of metacharacters. If empty string or NA, the column will be generated automatically. Defaults to <code>"META"</code>.</p>
</td></tr>
<tr><td><code id="read.transcription_+3A_col.value">col.value</code></td>
<td>
<p>[character] Name of the column with values of graphemes. Defaults to <code>"VALUE"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The constructor for the <code><a href="#topic+transcription">transcription</a></code> class requires a data frame which means that the user would need to first read it from a file, and only then pass it to the constructor. This function saves this one step. In addition, it attaches the name of the file to the object, which allows for easier identification later. It is recommended to use <code>read.transcription</code> instead of the raw <code><a href="#topic+transcription">transcription</a></code> constructor whenever possible.
</p>


<h3>Value</h3>

<p>[transcription] A transcription object containing the read transcription.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+transcription">transcription</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># path to a sample transcription
fName &lt;- system.file ("extdata", "trans-common.tsv", package="soundcorrs")
read.transcription (fName)
</code></pre>

<hr>
<h2 id='revChar'>Rev (reverse the order) for character strings.</h2><span id='topic+revChar'></span>

<h3>Description</h3>

<p>Like <code>rev</code> in Haskell when applied to a string. When applied to a vector of strings, reverses each string but maintains their order. That's why it's not called &quot;rev.character&quot;: to avoid having to use <code><a href="base.html#topic+rev.default">rev.default</a></code> everywhere else.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>revChar(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="revChar_+3A_x">x</code></td>
<td>
<p>[character] String or a vector of strings to be reversed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[character] Reversed string or a vector of reversed strings in the original order.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>soundcorrs:::revChar (c("kayak", "madam", "racecar"))
</code></pre>

<hr>
<h2 id='scOne'>Information that the <code>scOne</code> class is obsolete.</h2><span id='topic+scOne'></span>

<h3>Description</h3>

<p>Since version 0.2.0 it has been replaced with the <code><a href="#topic+soundcorrs">soundcorrs</a></code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scOne(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scOne_+3A_...">...</code></td>
<td>
<p>Ignored, only for compatibilty.</p>
</td></tr>
</table>

<hr>
<h2 id='server'>The main server for the UI.</h2><span id='topic+server'></span>

<h3>Description</h3>

<p>Can't be split into separate bits as neatly as the UI, so the entire server is one function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>server(input, output, session)
</code></pre>

<hr>
<h2 id='soundchange'>Constructor function for the <code>soundchange</code> class.</h2><span id='topic+soundchange'></span>

<h3>Description</h3>

<p>Either takes a sound change, translates it to a function, and wraps that into a <code>soundchange</code> object, or takes a function and wraps it into a <code>soundchange</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>soundchange(x, name, transcription, desc = NULL, perl = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="soundchange_+3A_x">x</code></td>
<td>
<p>[character/function] Either a sound change, or a function that takes as arguments a character string named <code>x</code> and an object named <code>meta</code>, and returns a vector of character strings.</p>
</td></tr>
<tr><td><code id="soundchange_+3A_name">name</code></td>
<td>
<p>[character] Name of the sound change. Length limit is not enforced, but it is recommended to not exceed 30 characters.</p>
</td></tr>
<tr><td><code id="soundchange_+3A_transcription">transcription</code></td>
<td>
<p>[transcription] The <code><a href="#topic+transcription">transcription</a></code> used in the notation of the sound change.</p>
</td></tr>
<tr><td><code id="soundchange_+3A_desc">desc</code></td>
<td>
<p>[character] A description of the change. May be as short or as long as needed. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="soundchange_+3A_perl">perl</code></td>
<td>
<p>[logical] Use Perl-compatible regular expressions? This argument is only used when <code>x</code> is a character string. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code>soundchange</code> object is basically a sound change function with some metadata: name, description, and associated transcription. The sound change function can be a simple substitution using <code><a href="base.html#topic+gsub">gsub</a></code>, or as complex as required. It must take two arguments: <code>x</code> which is a single character string to which the change is to be applied, and <code>meta</code> which can be any object that holds additional metadata; <code>meta</code> can also be <code>NULL</code>. The return value of a sound change function must be a vector of character strings. The ability to output multiple strings is primarily intended for reconstruction, and it is not recommended that it be used to fit multiple changes into a single function. Example: in language L, &quot;*a&quot; and &quot;*e&quot; merged to &quot;a&quot;, and simultaneously *o, *u &gt; o. Regardless of whether our functions depart from the current state and reconstruct proto-forms, or the opposite, two functions should be defined: one for the a-e merger, and one for the o-u merger. The difference between them will be that with a progressive change, each function will return only one value (&quot;[ae] &gt; a&quot;) whereas in a regressive one it will return two (&quot;a &gt; a, e&quot;).
</p>
<p>When the sound change is given as a simple character string, rather than a complete function, the string must contain exactly one &quot;&gt;&quot; or &quot;&lt;&quot; sign. Spaces around it are ignored. The string may take full advantage of regular expressions, both the ones available in pure R, and custom ones defined by the user and accepted by <code><a href="#topic+expandMeta">expandMeta</a></code>. Backreferences may be of particular usefulness. In short, any part of the 'find' string that is enclosed in brackets, is also available in the 'replace' string as <code>"\\1"</code>, <code>"\\2"</code>, etc. For example, if k's followed by e or i all change into s's, this process cannot be encoded as simply *<code>"k[ei] &gt; s"</code> because this would result in the e/i being deleted. The correct notation would be <code>"k([ei]) &gt; s\\1"</code>. However, see the caveat below.
</p>
<p>Warning! When the META column is missing from the transcription and generated automatically, the alternatives are listed using round- rather than square-bracket notation, i.e. as <code>"(x|y)"</code> rather than <code>"[xy]"</code>. This is necessary because some graphemes may be longer than one character, but a side effect of this is that when a user-defined metacharacter (&quot;wild-card&quot;) is used in the 'find' part of the sound change string (the part before <code>"&lt;"</code>), it adds a set of round brackets to that part of the string. In turn, this means that backreferences in the 'replace' part of the sound change string must either be shifted accordingly, or round brackets around metacharacters in the 'find' part omitted. For example, if intervocalic s is to be replaced with r, the sound change string should be <code>"VsV &gt; \\1r\\2"</code> rather than *<code>"(V)s(V) &gt; \\1r\\2"</code> because <code>"V"</code> itself is already translated to <code>"(a|ä|e|…"</code>.
</p>
<p>Note that sound changes and their application do not require the data to be segmented and aligned. If sound changes are the only goal of the project, these two time-consuming steps can be safely omitted.
</p>


<h3>Value</h3>

<p>[soundchange] An object containing the provided data.
</p>


<h3>Fields</h3>


<dl>
<dt><code>fun</code></dt><dd><p>[function] The sound change function.</p>
</dd>
<dt><code>desc</code></dt><dd><p>[character] A description of the change. May be <code>NULL</code>.</p>
</dd>
<dt><code>name</code></dt><dd><p>[character] The name of the change.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+print.soundchange">print.soundchange</a></code>, <code><a href="#topic+applyChanges">applyChanges</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># prepare sample transcription
trans &lt;- loadSampleDataset ("trans-common")
# run soundchange
a2b &lt;- soundchange ("a &gt; b", "sample change", trans)
a2b &lt;- soundchange ("b &lt; a", "sample change", trans)
a2b &lt;- soundchange (function(x,meta) gsub("a","b",x), "sample change", trans)
</code></pre>

<hr>
<h2 id='soundcorrs'>Constructor function for the <code>soundcorrs</code> class.</h2><span id='topic+soundcorrs'></span>

<h3>Description</h3>

<p>Take a data frame and turn it into a <code>soundcorrs</code> object containing data for one language. To obtain a <code>soundcorrs</code> object containing data for multiple languages, see <code><a href="#topic+merge.soundcorrs">merge.soundcorrs</a></code>. In the normal workflow, the user should have no need to call this constructor other than through <code><a href="#topic+read.soundcorrs">read.soundcorrs</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>soundcorrs(data, name, col.aligned, transcription, separator = "\\|")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="soundcorrs_+3A_data">data</code></td>
<td>
<p>[data.frame] Data for one language.</p>
</td></tr>
<tr><td><code id="soundcorrs_+3A_name">name</code></td>
<td>
<p>[character] Name of the language.</p>
</td></tr>
<tr><td><code id="soundcorrs_+3A_col.aligned">col.aligned</code></td>
<td>
<p>[character] Name of the column with the aligned words.</p>
</td></tr>
<tr><td><code id="soundcorrs_+3A_transcription">transcription</code></td>
<td>
<p>[transcription] The <code><a href="#topic+transcription">transcription</a></code> for the given language.</p>
</td></tr>
<tr><td><code id="soundcorrs_+3A_separator">separator</code></td>
<td>
<p>[character] String used to separate segments in <code>col.aligned</code>. Defaults to <code>"\|"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>soundcorrs</code> is the fundamental class of the entire soundcorrs package, and it is required for most tasks that the package promises to make easier and faster than manual labour. A <code>soundcorrs</code> object is a list containing the original data frame, some metadata (names of languages, names of columns, transcriptions), as well as transformations of the original data for faster processing in <code><a href="#topic+findExamples">findExamples</a></code> and other functions (words exploded into individual segments, with segment separators removed, etc.). The basic unit in <code>soundcorrs</code> is a pair/triple/... of words, each of which is assigned to a specific language.
</p>
<p>This constructor function is not really intended for the end user. Whenever possible, <code><a href="#topic+read.soundcorrs">read.soundcorrs</a></code> should be used instead. Regardless of the function used, two pieces of information are required for each word: the language it comes from, and its segmented and aligned form. Segmentation means that the word is cut into parts which can represent phonemes, morphemes, or anything else (the default separator is a vertical bar, <code>"|"</code>). A word with no separators in it is considered one big segment, and in fact, for <code><a href="#topic+soundchange">soundchange</a></code>'s this is enough. Alignment means that each word in a pair/triple/... has the same number of segments, and that those segments are in the corresponding places. Often, one of the words in a pair/triple/... will naturally have fewer segments than the others; in such cases, a filler character, 'linguistic zero' needs to be used (<code>"-"</code> is a good choice); for example, to align the Spanish and Swedish names for 'Stockholm', a total of three such 'empty' segments is required: e|s|t|o|k|-|o|l|m|o : -|s|t|o|k|k|o|l|m|-. Linguistic zero must be defined in the <code><a href="#topic+transcription">transcription</a></code>.
</p>
<p>Typically, a <code>soundcorrs</code> object will be used to hold an entire list of pairs/triples/... of words from various languages. However, both this constructor function and <code><a href="#topic+read.soundcorrs">read.soundcorrs</a></code> can only read data from one language at a time. This is because each language requires relatively many pieces of metadata (name, column names, transcription), and if all of this information for multiple languages were to be passed as arguments to one function, the call would very quickly become illegible. Multiple <code><a href="#topic+soundcorrs">soundcorrs</a></code> objects can be merged into one using <code><a href="#topic+merge.soundcorrs">merge.soundcorrs</a></code>.
</p>
<p>Three sample datasets are available: <code>data-abc</code>, <code>data-capitals</code>, and <code>data-ie</code>; they can be loaded with the help of <code><a href="#topic+loadSampleDataset">loadSampleDataset</a></code>.
</p>


<h3>Value</h3>

<p>[soundcorrs] An object containing the provided data and metadata for one language.
</p>


<h3>Fields</h3>


<dl>
<dt><code>cols</code></dt><dd><p>[character list] Names of important columns.</p>
</dd>
<dt><code>data</code></dt><dd><p>[data.frame] The original data.</p>
</dd>
<dt><code>names</code></dt><dd><p>[character] Name of the language.</p>
</dd>
<dt><code>segms</code></dt><dd><p>[character list] Words exploded into segments. With linguistic zeros preserved (<code>$z</code>) or removed (<code>$nz</code>).</p>
</dd>
<dt><code>segpos</code></dt><dd><p>[integer list] A lookup list to check which character belongs to which segment. Counted with linguistic zeros preserved (<code>$z</code>) and removed (<code>$nz</code>).</p>
</dd>
<dt><code>separators</code></dt><dd><p>[character] The strings used as segment separator in <code>cols$aligned</code>.</p>
</dd>
<dt><code>trans</code></dt><dd><p>[transcription] The transcription.</p>
</dd>
<dt><code>words</code></dt><dd><p>[character list] Words obtained by removing separators from the <code>cols$aligned</code> columns. With linguistic zeros (<code>$z</code>) or without them (<code>$nz</code>).</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'># prepare sample transcription
trans &lt;- loadSampleDataset ("trans-common")
# read sample data in the "wide format"
fNameData &lt;- system.file ("extdata", "data-capitals.tsv", package="soundcorrs")
readData &lt;- read.table (fNameData, header=TRUE)
# make out of them a soundcorrs object
ger &lt;- soundcorrs (readData, "German", "ALIGNED.German", trans)
pol &lt;- soundcorrs (readData, "Polish", "ALIGNED.Polish", trans)
spa &lt;- soundcorrs (readData, "Spanish", "ALIGNED.Spanish", trans)
dataset &lt;- merge (ger, pol, spa)
</code></pre>

<hr>
<h2 id='soundcorrsGUI'>GUI for <code><a href="#topic+soundcorrs">soundcorrs</a></code>.</h2><span id='topic+soundcorrsGUI'></span>

<h3>Description</h3>

<p>A graphic user interface for the <code><a href="#topic+soundcorrs">soundcorrs</a></code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>soundcorrsGUI()
</code></pre>


<h3>Details</h3>

<p>The console version of <code><a href="#topic+soundcorrs">soundcorrs</a></code> is flexible and offers a wide range of possibilities but it also requires a degree of experience with R and programming in general. This object provides an interface to <code><a href="#topic+soundcorrs">soundcorrs</a></code> which removes a considerable part of this requirement, though it is at the cost of flexibility and power.
</p>
<p>When running the app from the console, press ctrl-c to quit the server.
</p>


<h3>Value</h3>

<p>[shiny.appobj] A <code>shiny</code> app object. To run the app, print it or pass it to <code>shiny::runApp</code>.
</p>

<hr>
<h2 id='subset.soundcorrs'>Return a subset of sound correspondences data which meets a condition.</h2><span id='topic+subset.soundcorrs'></span>

<h3>Description</h3>

<p>Reduce a <code><a href="#topic+soundcorrs">soundcorrs</a></code> object to just those word pairs/triples/... which meet a certain condition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'soundcorrs'
subset(x, condition, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset.soundcorrs_+3A_x">x</code></td>
<td>
<p>[soundcorrs] The dataset to be subsetted.</p>
</td></tr>
<tr><td><code id="subset.soundcorrs_+3A_condition">condition</code></td>
<td>
<p>[logical] The condition the subsetted data must meet.</p>
</td></tr>
<tr><td><code id="subset.soundcorrs_+3A_...">...</code></td>
<td>
<p>Unused; only for consistency with <code><a href="base.html#topic+subset">subset</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Once a data frame is enclosed in a <code><a href="#topic+soundcorrs">soundcorrs</a></code> object, it is recommended that it not be manually altered in any way. <code>subset.soundcorrs</code> provides a safe way of subsetting it.
</p>


<h3>Value</h3>

<p>[soundcorrs] A soundcorrs object containing the subsetted dataset.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># In the examples below, non-ASCII characters had to be escaped for technical reasons.
# In actual usage, all soundcorrs functions accept characters from beyond ASCII.

dataset &lt;- loadSampleDataset ("data-capitals")
subset (dataset, OFFICIAL.LANGUAGE=="German")
subset (dataset, grepl("German",OFFICIAL.LANGUAGE))
subset (dataset, findExamples(dataset, "\u00E4", "e", "")$which)  # a-diaeresis
</code></pre>

<hr>
<h2 id='summary.list.lapplyTest'>A quick summary of the result of <code><a href="#topic+lapplyTest">lapplyTest</a></code>.</h2><span id='topic+summary.list.lapplyTest'></span>

<h3>Description</h3>

<p>Take the output of <code><a href="#topic+lapplyTest">lapplyTest</a></code>, and extract from it only the noteworthy results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'list.lapplyTest'
summary(object, p.value = 0.05, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.list.lapplyTest_+3A_object">object</code></td>
<td>
<p>[list.lapplyTest] The output of <code><a href="#topic+lapplyTest">lapplyTest</a></code>.</p>
</td></tr>
<tr><td><code id="summary.list.lapplyTest_+3A_p.value">p.value</code></td>
<td>
<p>[double] Results above this value will not be reported. Defaults to 0.05.</p>
</td></tr>
<tr><td><code id="summary.list.lapplyTest_+3A_...">...</code></td>
<td>
<p>Unused; only for consistency with <code><a href="base.html#topic+summary">summary</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output of <code><a href="#topic+lapplyTest">lapplyTest</a></code> may be difficult to digest for a human. This function selects from it only the results that are of particular interest, and presents them in an easy to read form.
</p>


<h3>Value</h3>

<p>A more human-friendly digest.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lapplyTest">lapplyTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dataset &lt;- loadSampleDataset ("data-abc")
lapplyTest (allCooccs(dataset))
</code></pre>

<hr>
<h2 id='summary.list.multiFit'>A comparison of the results produced by <code><a href="#topic+fitTable">fitTable</a></code> or <code><a href="#topic+multiFit">multiFit</a></code>.</h2><span id='topic+summary.list.multiFit'></span>

<h3>Description</h3>

<p>Take the output of <code><a href="#topic+fitTable">fitTable</a></code> or <code><a href="#topic+multiFit">multiFit</a></code>, extract a specific metric from the fits, and present them in the form of a table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'list.multiFit'
summary(object, metric = "rss", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.list.multiFit_+3A_object">object</code></td>
<td>
<p>[list.multiFit] The output of <code><a href="#topic+fitTable">fitTable</a></code> or <code><a href="#topic+multiFit">multiFit</a></code>.</p>
</td></tr>
<tr><td><code id="summary.list.multiFit_+3A_metric">metric</code></td>
<td>
<p>[character] The metric to extract from <code>object</code>. Available metrics are: &quot;aic&quot;, &quot;bic&quot;, &quot;rss&quot;, and &quot;sigma&quot;. Defaults to &quot;rss&quot;.</p>
</td></tr>
<tr><td><code id="summary.list.multiFit_+3A_...">...</code></td>
<td>
<p>Unused; only for consistency with <code><a href="base.html#topic+summary">summary</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output of <code><a href="#topic+multiFit">multiFit</a></code> may be difficult to digest for a human. This function selects from it only the results that are of particular interest, and presents them in an easy to read form.
</p>


<h3>Value</h3>

<p>A more human-friendly digest.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+multiFit">multiFit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed (27)
dataset &lt;- data.frame (X=1:10, Y=(1:10)^2+runif(10,-10,10))
models &lt;- list (
"model A" = list (
	formula = "Y ~ X^a",
	start = list (list(a=100), list(a=1))),
"model B" = list (
	formula = "Y ~ a*(X+b)",
	start = list (list(a=1,b=1)))
)
summary (multiFit(models,dataset))
summary (fitTable(models,as.matrix(dataset),1,vec2df.rank), "sigma")
</code></pre>

<hr>
<h2 id='summary.soundcorrs'>Generate a segment-to-segment contingency table for two languages.</h2><span id='topic+summary.soundcorrs'></span>

<h3>Description</h3>

<p>Produce a contingency table detailing all segment-to-segment correspondences in a dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'soundcorrs'
summary(object, count = "a", unit = "w", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.soundcorrs_+3A_object">object</code></td>
<td>
<p>[soundcorrs] The dataset from which to draw frequencies. Only datasets with two languages are supported.</p>
</td></tr>
<tr><td><code id="summary.soundcorrs_+3A_count">count</code></td>
<td>
<p>[character] Report either the absolute or the relative numbers?. Accepted values are <code>"a(bs(olute))"</code> and <code>"r(el(ative))"</code>. Defaults to &quot;a&quot;.</p>
</td></tr>
<tr><td><code id="summary.soundcorrs_+3A_unit">unit</code></td>
<td>
<p>[character] Count how many times a correspondence occurs or in how many words it occurs? Accepted values are <code>"o(cc(ur(ence(s))))"</code> and <code>"w(or(d(s)))"</code>. Defaults to <code>"w"</code>.</p>
</td></tr>
<tr><td><code id="summary.soundcorrs_+3A_...">...</code></td>
<td>
<p>Unused; only for consistency with <code>base::<a href="base.html#topic+summary">summary</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A set of segmented and aligned word pairs/triples/..., such as one held in a <code><a href="#topic+soundcorrs">soundcorrs</a></code> object, can be turned into a contingency table in more than one way. Perhaps the simplest option is to see how often various segments from one language correspond to various segments from another language, which is the kind of table this function produces. Correspondences can be reported in absolute or relative numbers, and can represent the number of times the given correspondence occurs, or in how many words it occurs (the same correspondence can occur more than once in a single pair/triple/... of words, e.g. in German koala : French koala, the correspondence G a : Fr a occurs twice). When the numbers are relative, each row in the table adds up to 1. In theory, <code>summary.soundcorrs</code> can support a <code><a href="#topic+soundcorrs">soundcorrs</a></code> objects with any number of languages in it, but the legibility of the output drops very quickly when that number exceeds two.
</p>


<h3>Value</h3>

<p>[table] The contingency table. The values represent how often the given segments correspond to each other, not how often they co-occur in the same word (cf. <code><a href="#topic+coocc">coocc</a></code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coocc">coocc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dataset &lt;- loadSampleDataset ("data-ie")
summary (dataset)
round (summary(dataset,count="r"), digits=3)
summary (dataset, unit="o")
</code></pre>

<hr>
<h2 id='tabAbs2Rel'>Convert a table from absolute to relative values.</h2><span id='topic+tabAbs2Rel'></span>

<h3>Description</h3>

<p>Cross-tabulating sound correspondences with themselves may be misleading if the values are absolute, as it may well be that some segments simply do co-occur frequently, while others only rarely. The conversion is done in blocks: rows with the same prefix vs cols with the same prefix (if <code>column = NULL</code>) or vs all columns (if <code>column</code> is a string).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tabAbs2Rel(tab, column)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tabAbs2Rel_+3A_tab">tab</code></td>
<td>
<p>[table] The contingency table with sound correspondences.</p>
</td></tr>
<tr><td><code id="tabAbs2Rel_+3A_column">column</code></td>
<td>
<p>[character] Do columns contain the same data as rows (<code>NULL</code>) or some other data (a string)?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functions that produce contingency tables, <code><a href="#topic+coocc">coocc</a></code> and <code><a href="base.html#topic+summary">summary</a></code>, return a result in absolute numbers, but sometimes the relative perspective may be more useful. This function converts from absolute to relative, but it does so in blocks where each block is an intersection of all the columns and the all rows whose names begin with the same prefix. 'Prefix' in this case is whatever comes before an underscore (<code>"_"</code>), because <code><a href="#topic+coocc">coocc</a></code> and others use underscore to connect names of columns and rows.
</p>


<h3>Value</h3>

<p>[table] The converted table.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dataset &lt;- loadSampleDataset ("data-abc")
soundcorrs:::tabAbs2Rel (coocc(dataset,unit="o"), NULL)
</code></pre>

<hr>
<h2 id='transcription'>Constructor function for the <code>transcription</code> class.</h2><span id='topic+transcription'></span>

<h3>Description</h3>

<p>Take a data frame containing transcription and turn it into a <code>transcription</code> object, as required by the <code><a href="#topic+soundcorrs">soundcorrs</a></code> constructor function. In the normal workflow, the user should have no need to call this function other than through <code><a href="#topic+read.transcription">read.transcription</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transcription(
  data,
  col.grapheme = "GRAPHEME",
  col.meta = "META",
  col.value = "VALUE"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transcription_+3A_data">data</code></td>
<td>
<p>[data.frame] Data frame containing the transcription and its meaning.</p>
</td></tr>
<tr><td><code id="transcription_+3A_col.grapheme">col.grapheme</code></td>
<td>
<p>[character] Name of the column with graphemes. Defaults to <code>"GRAPHEME"</code>.</p>
</td></tr>
<tr><td><code id="transcription_+3A_col.meta">col.meta</code></td>
<td>
<p>[character] Name of the column with the coverage of metacharacters. If empty string or <code>NA</code>, the column will be generated automatically. Defaults to <code>"META"</code>.</p>
</td></tr>
<tr><td><code id="transcription_+3A_col.value">col.value</code></td>
<td>
<p>[character] Name of the column with values of graphemes. Defaults to <code>"VALUE"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The primary reason why transcription needs to be defined, are regular expressions. R has a powerful system of regular expressions but they are general, not designed specifically for use in linguistics. Linguistics has its own convention of regular expressions, or rather two conventions, and to emulate them, it is necessary for <code><a href="#topic+soundcorrs">soundcorrs</a></code> to know the linguistic value of individual graphemes. One convention is the traditional, 'European' one where typically single characters represent entire classes of sounds, e.g. &quot;C&quot; stands for 'any consonant', &quot;A&quot; for 'any back vowel', etc. The other convention is the 'binary', 'American' notation where instead of using single characters, one lists all the distinctive features, e.g. &quot;[+cons]&quot; or &quot;[+vowel,+back]&quot;. Having the values of graphemes encoded in a <code>transcription</code> object, <code><a href="#topic+expandMeta">expandMeta</a></code> is able to translate these two notations into regular expressions that R can understand.
</p>
<p>This constructor function is not really intended for the end user. Whenever possible, <code><a href="#topic+read.transcription">read.transcription</a></code> should be used instead. Regardless of the function used, a data frame with two columns is required in order to create a <code>transcription</code> object: one column for the graphemes, and one for their values. It is probably not necessary, but nevertheless recommended, just to be on the safe side, that graphemes be single characters. (This also excludes combining diacritical marks.) Values must be separated by commas, without spaces. Typically, they will be phonetic features, but in principle they can be anything. A transcription may also have a third column that holds the string that the given grapheme is going to be turned into by <code><a href="#topic+expandMeta">expandMeta</a></code>. Regular graphemes should be simply repeated in this column, whereas metacharacters (such as &quot;C&quot; or &quot;A&quot; mentioned above) should be expanded into all the graphemes they represent, separated by a bar (&quot;|&quot;), and enclosed in brackets, e.g. &quot;(a|o|u)&quot;. If the third column is missing, this function will generate it automatically. Note, however, that the generation is based on the value column, and any grapheme whose value is a subset of the value of another grapheme, will be considered a metacharacter. For example, if &quot;p&quot; is defined as &quot;cons,stop,blab&quot;, and &quot;b&quot; as &quot;cons,stop,blab,voiced&quot;, &quot;p&quot; will be considered a metacharacter for both &quot;p&quot; and &quot;b&quot;, and translated into &quot;(p|b)&quot; by <code><a href="#topic+expandMeta">expandMeta</a></code>.
</p>
<p>Graphemes cannot contain in them characters reserved for regular expressions: . + * ^ \ $ ? | ( ) [ ] { }, and they also cannot contain in them characters defined as metacharacters in the transcription. For example, if &quot;A&quot; is defined as &quot;vowel,back&quot;, and therefore represents all the back vowels in the transcription, a regular grapheme &quot;A:&quot; is forbidden. A metacharacter &quot;A:&quot;, on the other hand, is permitted (e.g. for 'any long back vowel'), though it is recommended that such overlapping metacharacters be avoided as much as possible.
</p>
<p>Lastly, a transcription must contain so-called linguistic zero. This is a character which signifies an empty segment in a word, a segment which has been only added in order to align the segments in all the words in a pair/triple/.... For example, English passport has two phonemes fewer than Spanish pasaporte id., so in order for the two words to be aligned, the English one needs two filler segments:p|a|s|-|p|o|r|t|- : p|a|s|a|p|o|r|t|e. To designate a character as linguistic zero in a transcription, its value must be <code>"NULL"</code>.
</p>
<p>Two sample transcriptions are available: <code>trans-common</code>, <code>trans-ipa</code>; they can be loaded with the help of <code><a href="#topic+loadSampleDataset">loadSampleDataset</a></code>.
</p>


<h3>Value</h3>

<p>[transcription] An object containing the provided data.
</p>


<h3>Fields</h3>


<dl>
<dt><code>data</code></dt><dd><p>[data.frame] The original data frame.</p>
</dd>
<dt><code>cols</code></dt><dd><p>[character list] Names of the important columns in the data frame.</p>
</dd>
<dt><code>meta</code></dt><dd><p>[character] A vector of character strings which act as metacharacters in regular expressions. Mostly useful to speed up <code><a href="#topic+expandMeta">expandMeta</a></code>.</p>
</dd>
<dt><code>values</code></dt><dd><p>[character] A named list with values of individual graphemes exploded into vectors.</p>
</dd>
<dt><code>zero</code></dt><dd><p>[character] A regular expression to catch linguistic zeros.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code>link{expandMeta}</code>, <code><a href="#topic+print.transcription">print.transcription</a></code>, <code><a href="#topic+read.transcription">read.transcription</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># path to a sample transcription
fName &lt;- system.file ("extdata", "trans-common.tsv", package="soundcorrs")
fut &lt;- transcription (read.table(fName,header=TRUE))
</code></pre>

<hr>
<h2 id='ui'>The UI for navigation bar.</h2><span id='topic+ui'></span>

<h3>Description</h3>

<p>The UI for the navigation bar at the top of the screen, and simultaneously for the entire app.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ui()
</code></pre>

<hr>
<h2 id='ui.data'>The UI for the Data page.</h2><span id='topic+ui.data'></span>

<h3>Description</h3>

<p>The UI for the data loading page.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ui.data()
</code></pre>

<hr>
<h2 id='ui.examples'>The UI for the Examples page.</h2><span id='topic+ui.examples'></span>

<h3>Description</h3>

<p>The UI for the examples-search page.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ui.examples()
</code></pre>

<hr>
<h2 id='ui.soundchanges'>The UI for the Sound changes page.</h2><span id='topic+ui.soundchanges'></span>

<h3>Description</h3>

<p>The UI for the sound change application page.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ui.soundchanges()
</code></pre>

<hr>
<h2 id='ui.start'>The UI for the Start page.</h2><span id='topic+ui.start'></span>

<h3>Description</h3>

<p>The UI for the starting page.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ui.start()
</code></pre>

<hr>
<h2 id='ui.tables'>The UI for the Tables changes page.</h2><span id='topic+ui.tables'></span>

<h3>Description</h3>

<p>The UI for the contingency tables page.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ui.tables()
</code></pre>

<hr>
<h2 id='vec2df.hist'>A vector to data frame converter for <code><a href="#topic+fitTable">fitTable</a></code>. This one makes a histogram, and returns a data frame with midpoints and counts.</h2><span id='topic+vec2df.hist'></span>

<h3>Description</h3>

<p>A vector to data frame converter for <code><a href="#topic+fitTable">fitTable</a></code>. This one makes a histogram, and returns a data frame with midpoints and counts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec2df.hist(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec2df.hist_+3A_data">data</code></td>
<td>
<p>[numeric vector] The data to be converted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[data.frame] Converted <code>data</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># prepare sample dataset
fTrans &lt;- system.file ("extdata", "trans-common.tsv", package="soundcorrs")
fData &lt;- system.file ("extdata", "data-capitals.tsv", package="soundcorrs")
tmp.ger &lt;- read.soundcorrs (fData, "German", "ALIGNED.German", fTrans)
tmp.pol &lt;- read.soundcorrs (fData, "Polish", "ALIGNED.Polish", fTrans)
dataset &lt;- merge (tmp.ger, tmp.pol)
# prepare and run fitTable
models &lt;- list (
	"model A" = list (
		formula = "Y ~ a/X",
		start = list (list(a=1))),
	"model B" = list (
		formula = "Y ~ a/(1+exp(1)^X)",
		start = list (list(a=1)))
)
fitTable (models, summary(dataset), 1, vec2df.hist)
</code></pre>

<hr>
<h2 id='vec2df.id'>A vector to data frame converter for <code><a href="#topic+fitTable">fitTable</a></code>. This one only does the necessary minimum.</h2><span id='topic+vec2df.id'></span>

<h3>Description</h3>

<p>A vector to data frame converter for <code><a href="#topic+fitTable">fitTable</a></code>. This one only does the necessary minimum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec2df.id(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec2df.id_+3A_data">data</code></td>
<td>
<p>[numeric vector] The data to be converted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[data.frame] Converted <code>data</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># prepare sample dataset
fTrans &lt;- system.file ("extdata", "trans-common.tsv", package="soundcorrs")
fData &lt;- system.file ("extdata", "data-capitals.tsv", package="soundcorrs")
tmp.ger &lt;- read.soundcorrs (fData, "German", "ALIGNED.German", fTrans)
tmp.pol &lt;- read.soundcorrs (fData, "Polish", "ALIGNED.Polish", fTrans)
dataset &lt;- merge (tmp.ger, tmp.pol)
# prepare and run fitTable
models &lt;- list (
	"model A" = list (
		formula = "Y ~ a/X",
		start = list (list(a=1))),
	"model B" = list (
		formula = "Y ~ a/(1+exp(1)^X)",
		start = list (list(a=1)))
)
fitTable (models, summary(dataset), 1, vec2df.id)
</code></pre>

<hr>
<h2 id='vec2df.rank'>A vector to data frame converter for <code><a href="#topic+fitTable">fitTable</a></code>. This one orders data by rank.</h2><span id='topic+vec2df.rank'></span>

<h3>Description</h3>

<p>A vector to data frame converter for <code><a href="#topic+fitTable">fitTable</a></code>. This one orders data by rank.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec2df.rank(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec2df.rank_+3A_data">data</code></td>
<td>
<p>[numeric vector] The data to be converted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[data.frame] Converted <code>data</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># prepare sample dataset
fTrans &lt;- system.file ("extdata", "trans-common.tsv", package="soundcorrs")
fData &lt;- system.file ("extdata", "data-capitals.tsv", package="soundcorrs")
tmp.ger &lt;- read.soundcorrs (fData, "German", "ALIGNED.German", fTrans)
tmp.pol &lt;- read.soundcorrs (fData, "Polish", "ALIGNED.Polish", fTrans)
dataset &lt;- merge (tmp.ger, tmp.pol)
# prepare and run fitTable
models &lt;- list (
	"model A" = list (
		formula = "Y ~ a/X",
		start = list (list(a=1))),
	"model B" = list (
		formula = "Y ~ a/(1+exp(1)^X)",
		start = list (list(a=1)))
)
fitTable (models, summary(dataset), 1, vec2df.rank)
</code></pre>

<hr>
<h2 id='wide2long'>Convert from the wide format (multiple entries per row) to the long format (single entry per row).</h2><span id='topic+wide2long'></span>

<h3>Description</h3>

<p>Takes a data frame of word pairs/triples/..., each stored in a single row, and returns a data frame with the same pairs/triples/... but with each word stored in its own row.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wide2long(data, suffixes, col.lang = "LANGUAGE", strip = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wide2long_+3A_data">data</code></td>
<td>
<p>[data.frame] The dataset to be converted.</p>
</td></tr>
<tr><td><code id="wide2long_+3A_suffixes">suffixes</code></td>
<td>
<p>[character vector] Suffixes used to differentiate column names; in the output, those will be used as language names.</p>
</td></tr>
<tr><td><code id="wide2long_+3A_col.lang">col.lang</code></td>
<td>
<p>[character] Name of the column in which language names are to be stored. Defaults to <code>"LANGUAGE"</code>.</p>
</td></tr>
<tr><td><code id="wide2long_+3A_strip">strip</code></td>
<td>
<p>[integer] The number of characters to strip from the beginning of suffixes when they are turned into language names. Defaults to 0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Data for <code><a href="#topic+soundcorrs">soundcorrs</a></code> can be prepared in one of two formats: the 'long format' and the 'wide format'. In the 'long format', each row contains only a single word and metadata associated with it. In the 'wide format', each row contains the entire pair/triple/... of words, and all the metadata associated with them. The 'long format' is convenient for making sure that all the words in a pair/triple/... have the same number of segments, but it cannot be read directly by <code><a href="#topic+soundcorrs">soundcorrs</a></code>. <code><a href="#topic+long2wide">long2wide</a></code> and <code>wide2long</code> convert between the two formats.
</p>


<h3>Value</h3>

<p>[data.frame] A data frame in the long format (single entry per row).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+long2wide">long2wide</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># path to sample data in the "wide format"
fName &lt;- system.file ("extdata", "data-capitals.tsv", package="soundcorrs")
wide &lt;- read.table (fName, header=TRUE)
long &lt;- wide2long (wide, c(".German",".Polish",".Spanish"), strip=1)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
