<!DOCTYPE html><html lang="en"><head><title>Help for package MSclassifR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MSclassifR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CitrobacterRKImetadata'><p>Metadata of mass spectra corresponding to the bacterial species <em>Citrobacter</em> sp. from  The Robert Koch-Institute (RKI) database of microbial MALDI-TOF mass spectra</p></a></li>
<li><a href='#CitrobacterRKIspectra'><p>Mass spectra corresponding to the bacterial species <em>Citrobacter</em> sp. from  The Robert Koch-Institute (RKI) database of microbial MALDI-TOF mass spectra</p></a></li>
<li><a href='#LogReg'><p>Estimation of a multinomial regression to predict the category to which a mass spectrum belongs</p></a></li>
<li><a href='#MSclassifR'>
<p>Automated classification of mass spectra</p></a></li>
<li><a href='#PeakDetection'><p>Detection of peaks in <code>MassSpectrum</code> objects.</p></a></li>
<li><a href='#PlotSpectra'><p>Plot mass spectra with detected peaks</p></a></li>
<li><a href='#PredictFastClass'><p>Prediction of the category to which a mass spectrum belongs using linear regressions of mass spectra.</p></a></li>
<li><a href='#PredictLogReg'><p>Prediction of the category to which a mass spectrum belongs from a multinomial logistic regression model</p></a></li>
<li><a href='#SelectionVar'><p>Variable selection using random forests, logistic regression methods or sparse partial least squares discriminant analysis (sPLS-DA).</p></a></li>
<li><a href='#SelectionVarStat'><p>Variable selection using multiple statistical tests.</p></a></li>
<li><a href='#SignalProcessing'><p>Function performing post acquisition signal processing</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Automated Classification of Mass Spectra</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.3</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alexandre Godmer &lt;alexandre.godmer@aphp.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to classify mass spectra in known categories, and to determine discriminant mass-over-charge values. It includes easy-to-use functions for pre-processing mass spectra, functions to determine discriminant mass-over-charge values (m/z) from a library of mass spectra corresponding to different categories, and functions to predict the category (species, phenotypes, etc.) associated to a mass spectrum from a list of selected mass-over-charge values. Three vignettes illustrating how to use the functions of this package from real data sets are also available online to help users: <a href="https://agodmer.github.io/MSclassifR_examples/Vignettes/Vignettemsclassifr_Ecrobiav3.html">https://agodmer.github.io/MSclassifR_examples/Vignettes/Vignettemsclassifr_Ecrobiav3.html</a>, <a href="https://agodmer.github.io/MSclassifR_examples/Vignettes/Vignettemsclassifr_Klebsiellav3.html">https://agodmer.github.io/MSclassifR_examples/Vignettes/Vignettemsclassifr_Klebsiellav3.html</a> and <a href="https://agodmer.github.io/MSclassifR_examples/Vignettes/Vignettemsclassifr_DAv3.html">https://agodmer.github.io/MSclassifR_examples/Vignettes/Vignettemsclassifr_DAv3.html</a>.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/agodmer/MSclassifR_examples">https://github.com/agodmer/MSclassifR_examples</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0), cp4p, caret, statmod, MALDIquant, MALDIrppa,</td>
</tr>
<tr>
<td>Imports:</td>
<td>e1071, MALDIquantForeign, mixOmics, reshape2, ggplot2, nnet,
dplyr, fuzzyjoin, VSURF, metap, xgboost, glmnet,
performanceEstimation, mltools, mclust, UBL, stats, limma, car,
vita, randomForest</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown,</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-09 08:20:01 UTC; qgiaigia</td>
</tr>
<tr>
<td>Author:</td>
<td>Alexandre Godmer [aut, cre],
  Quentin Giai Gianetto [aut],
  Karen Druart [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-09 09:00:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='CitrobacterRKImetadata'>Metadata of mass spectra corresponding to the bacterial species <em>Citrobacter</em> sp. from  The Robert Koch-Institute (RKI) database of microbial MALDI-TOF mass spectra</h2><span id='topic+CitrobacterRKImetadata'></span>

<h3>Description</h3>

<p>Metadada of the <code><a href="#topic+CitrobacterRKIspectra">CitrobacterRKIspectra</a></code> list of mass spectra.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("CitrobacterRKImetadata", package = "MSclassifR")
</code></pre>


<h3>Format</h3>

<p>A data frame with 14 rows (each corresponding to a mass spectrum), and five columns that contain (in order): the strain name, the species name, the spot, a sample number and the name of the strain associated with the spot.
</p>


<h3>Details</h3>

<p>The Robert Koch-Institute (RKI) database of microbial MALDI-TOF mass spectra contains raw mass spectra. Only mass spectra of the <em>Citrobacter</em> bacterial species were collected. Metadata were manually reported from raw data.
</p>


<h3>Source</h3>

<p>The raw data were downloaded from this link : <a href="https://zenodo.org/record/163517#.YIkWiNZuJCp">https://zenodo.org/record/163517#.YIkWiNZuJCp</a>. The dataset focuses only on mass spectra from <em>Citrobacter</em>.
</p>


<h3>References</h3>

<p>Lasch, Peter, Stammler, Maren, &amp; Schneider, Andy. (2018). Version 3 (20181130) of the MALDI-TOF Mass Spectrometry Database for Identification and Classification of Highly Pathogenic Microorganisms from the Robert Koch-Institute (RKI) [Data set]. Zenodo.doi: <a href="https://doi.org/10.5281/zenodo.163517">10.5281/zenodo.163517</a>
</p>

<hr>
<h2 id='CitrobacterRKIspectra'>Mass spectra corresponding to the bacterial species <em>Citrobacter</em> sp. from  The Robert Koch-Institute (RKI) database of microbial MALDI-TOF mass spectra</h2><span id='topic+CitrobacterRKIspectra'></span>

<h3>Description</h3>

<p>Mass spectra of the <code><a href="#topic+CitrobacterRKIspectra">CitrobacterRKIspectra</a></code> dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("CitrobacterRKIspectra", package = "MSclassifR")

#####
#Plotting the first mass spectrum
#library("MSclassifR")
#PlotSpectra(SpectralData=CitrobacterRKIspectra[[1]],absx = "ALL", Peaks = NULL, 
#            Peaks2 = NULL, col_spec = 1, col_peak = 2, shape_peak = 3,
#            col_peak2 = 2, shape_peak2 = 2)
</code></pre>


<h3>Format</h3>

<p>A list that contains 14 objects of class S4 corresponding each to a each mass spectrum.
</p>


<h3>Details</h3>

<p>The Robert Koch-Institute (RKI) database of microbial MALDI-TOF mass spectra contains raw mass spectra. Only mass spectra of the <em>Citrobacter</em> bacterial species were collected.
</p>


<h3>Source</h3>

<p>The raw data were downloaded from this link : <a href="https://zenodo.org/record/163517#.YIkWiNZuJCp">https://zenodo.org/record/163517#.YIkWiNZuJCp</a>. The dataset focuses only on mass spectra from <em>Citrobacter</em>.
</p>


<h3>References</h3>

<p>Lasch, Peter, Stammler, Maren, &amp; Schneider, Andy. (2018). Version 3 (20181130) of the MALDI-TOF Mass Spectrometry Database for Identification and Classification of Highly Pathogenic Microorganisms from the Robert Koch-Institute (RKI) [Data set]. Zenodo.doi: <a href="https://doi.org/10.5281/zenodo.163517">10.5281/zenodo.163517</a>
</p>

<hr>
<h2 id='LogReg'>Estimation of a multinomial regression to predict the category to which a mass spectrum belongs</h2><span id='topic+LogReg'></span>

<h3>Description</h3>

<p>This function estimates a multinomial regression using cross-validation to predict the category (species, phenotypes...) to which a mass spectrum belongs from a set of shortlisted mass-over-charge values corresponding to discriminant peaks. Two main kinds of models can be estimated: linear or nonlinear (with neural networks, random forests, support vector machines with linear kernel, or eXtreme Gradient Boosting). Hyperparameters are randomly searched, except for the eXtreme Gradient Boosting where a grid search is performed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LogReg(X,
       moz,
       Y,
       number = 2,
       repeats = 2,
       Metric = c("Kappa", "Accuracy", "F1", "AdjRankIndex", "MatthewsCorrelation"),
       kind="linear",
       Sampling = c("no", "up", "down", "smote"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LogReg_+3A_x">X</code></td>
<td>
<p><code>matrix</code> corresponding to a library of mass spectra. Each row of <code>X</code> is the intensities of a mass spectrum measured on the <code>moz</code> values. The columns should be represented by mass-over-charge values.</p>
</td></tr>
<tr><td><code id="LogReg_+3A_moz">moz</code></td>
<td>
<p><code>vector</code> with shortlisted mass-over-charge values.</p>
</td></tr>
<tr><td><code id="LogReg_+3A_y">Y</code></td>
<td>
<p><code>factor</code> with a length equal to the number of rows in <code>X</code> and containing the categories of each mass spectrum in <code>X</code>.</p>
</td></tr>
<tr><td><code id="LogReg_+3A_number">number</code></td>
<td>
<p><code>integer</code> corresponding to the number of folds or number of resampling iterations. See arguments of the <code>trainControl</code> function of the <code>caret</code> R package.</p>
</td></tr>
<tr><td><code id="LogReg_+3A_metric">Metric</code></td>
<td>
<p>a <code>character</code> indicating metric to select the optimal model. The possibles metrics are the <code>"Kappa"</code> coefficient,<code>"Accuracy"</code>, the <code>"F1"</code> score, <code>"AdjRankIndex"</code> for the Adjusted Rand Index or <code>"MatthewsCorrelation"</code> for the Matthews Correlation Coefficient.</p>
</td></tr>
<tr><td><code id="LogReg_+3A_repeats">repeats</code></td>
<td>
<p><code>integer</code> corresponding to the number of complete sets of folds to compute. See <code>trainControl</code> function of the <code>caret</code> R package for more details.</p>
</td></tr>
<tr><td><code id="LogReg_+3A_kind">kind</code></td>
<td>
<p>If <code>kind="nnet"</code>, then a nonlinear multinomial logistic regression is estimated via neural networks. If <code>kind="rf"</code>, then it is estimated via random forests. If <code>kind="svm"</code>, then it is estimated via support vector machines with linear kernel. If <code>kind="xgb"</code>, then it is estimated via eXtreme gradient boosting. Else a linear multinomial logistic regression is performed (by default).</p>
</td></tr>
<tr><td><code id="LogReg_+3A_sampling">Sampling</code></td>
<td>
<p>a <code>character</code> indicating an optional subsampling method to handle imbalanced datasets: subsampling methods are either <code>"no"</code> (no subsampling), <code>"up"</code>, <code>"down"</code> or <code>"smote"</code>. <code>"no"</code> by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function estimates a model from a library of mass spectra for which we already know the category to which they belong (ex.: species, etc). This model can next be used to predict the category of a new coming spectrum for which the category is unknown (see <code><a href="#topic+PredictLogReg">PredictLogReg</a></code>).
</p>
<p>The estimation is performed using the <code>train</code> function of the <code>caret</code> R package. For each kind of model, random parameters are tested to find a model according to the best <code>metric</code>. The formulas for the <code>metric</code> are as follows:
</p>
<p style="text-align: center;"><code class="reqn">Accuracy = Number Of Correct Predictions/Total Number Of Predictions</code>
</p>

<p style="text-align: center;"><code class="reqn">Kappa coefficient = (Observed Agreement-Chance Agreement)/(1-Chance Agreement)</code>
</p>

<p style="text-align: center;"><code class="reqn">F1 = True Positive/(True Positive + 1/2 (False Positive + False Negative))</code>
</p>

<p>The adjusted Rand index (<code>"AdjRankIndex"</code>) is defined as the corrected-for-chance version of the Rand index which allows comparing two groups (see <code>mclust</code> package and <code>adjustedRandIndex()</code> function for more details). The Matthews correlation coefficient (<code>"MatthewsCorrelation"</code>) is estimated using <code>mcc</code> function in the <code>mltools</code> R package.
</p>
<p>The <code>Sampling</code> methods available for imbalanced data are: <code>"up"</code> to the up-sampling method which consists of random sampling (with replacement) so that the minority class is the same size as the majority class; <code>"down"</code> to the down-sampling method which consists of random sampling (without replacement) of the majority class so that their class frequencies match the minority class; <code>"smote"</code> to the Synthetic Minority Over sampling Technique (SMOTE) algorithm for data augmentation which consists of creating new data from minority class using the K Nearest Neighbor algorithm.
</p>


<h3>Value</h3>

<p>Returns a <code>list</code> with four items:
</p>
<table role = "presentation">
<tr><td><code>train_mod</code></td>
<td>
<p>a <code>list</code> corresponding to the output of the train function of the <code>caret</code> R package containing the multinomial regression model estimated using repeated cross-validation.</p>
</td></tr>
<tr><td><code>conf_mat</code></td>
<td>
<p>a confusion matrix containing percentages classes of predicted categories in function of actual categories, resulting from repeated cross-validation.</p>
</td></tr>
<tr><td><code>stats_global</code></td>
<td>
<p>a <code>data frame</code> containing the mean and standard deviation values of the &quot;Accuracy&quot;&quot; and &quot;Kappa&quot; parameters computed for each cross-validation.</p>
</td></tr>
<tr><td><code>boxplot</code></td>
<td>
<p>a <code>ggplot</code> object (see <code>ggplot2</code> R package). This is a graphical representation of the <code>Metric</code> parameters of <code>stats_global</code> using boxplots.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Kuhn, M. (2008). Building predictive models in R using the caret package. Journal of statistical software, 28(1), 1-26.
</p>
<p>L. Hubert and P. Arabie (1985) Comparing Partitions, Journal of the Classification, 2, pp. 193-218.
</p>
<p>Scrucca L, Fop M, Murphy TB, Raftery AE (2016). mclust 5: clustering, classification and density estimation using Gaussian finite mixture models. The R Journal.
</p>
<p>Nitesh V. Chawla, Kevin W. Bowyer, Lawrence O. Hall, and W. Philip Kegelmeyer. 2002. SMOTE: synthetic minority over-sampling technique. J. Artif. Int. Res. 16, 1.
</p>
<p>Matthews, B. W. (1975). &quot;Comparison of the predicted and observed secondary structure of T4 phage lysozyme&quot;. Biochimica et Biophysica Acta (BBA) - Protein Structure. PMID 1180967.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library("MSclassifR")
library("MALDIquant")

###############################################################################
## 1. Pre-processing of mass spectra

# load mass spectra and their metadata
data("CitrobacterRKIspectra","CitrobacterRKImetadata", package = "MSclassifR")
# standard pre-processing of mass spectra
spectra &lt;- SignalProcessing(CitrobacterRKIspectra)
# detection of peaks in pre-processed mass spectra
peaks &lt;- MSclassifR::PeakDetection(x = spectra, averageMassSpec=FALSE)
# matrix with intensities of peaks arranged in rows (each column is a mass-over-charge value)
IntMat &lt;- MALDIquant::intensityMatrix(peaks)
rownames(IntMat) &lt;- paste(CitrobacterRKImetadata$Strain_name_spot)
# remove missing values in the matrix
IntMat[is.na(IntMat)] &lt;- 0
# normalize peaks according to the maximum intensity value for each mass spectrum
IntMat &lt;- apply(IntMat,1,function(x) x/(max(x)))
# transpose the matrix for statistical analysis
X &lt;- t(IntMat)
# define the known categories of mass spectra for the classification
Y &lt;- factor(CitrobacterRKImetadata$Species)

###############################################################################
## 2. Selection of discriminant mass-over-charge values using RFERF
# with 5 to 10 variables, 
# up sampling method and 
# trained with the Accuracy coefficient metric

a &lt;- MSclassifR::SelectionVar(X,
                              Y,
                              MethodSelection = c("RFERF"),
                              MethodValidation = c("cv"),
                              PreProcessing = c("center","scale","nzv","corr"),
                              NumberCV = 2,
                              Metric = "Accuracy",
                              Sizes = c(2:5),
                              Sampling = "up")

sel_moz=a$sel_moz

###############################################################################
## 3. Perform LogReg from shortlisted discriminant mass-over-charge values

# linear multinomial regression 
# without sampling mehod 
# and trained with the Kappa coefficient metric

model_lm=MSclassifR::LogReg(X=X,
                            moz=sel_moz,
                            Y=factor(Y),
                            number=2,
                            repeats=2,
                            Metric = "Kappa")
# Estimated model:
model_lm

# nonlinear multinomial regression using neural networks 
# with up-sampling method and 
# trained with the Kappa coefficient metric

model_nn=MSclassifR::LogReg(X=X,
                            moz=sel_moz,
                            Y=factor(Y),
                            number=2,
                            repeats=2,
                            kind="nnet",
                            Metric = "Kappa",
                            Sampling = "up")
# Estimated model:
model_nn

# nonlinear multinomial regression using random forests 
# without down-sampling method and 
# trained with the Kappa coefficient metric

model_rf=MSclassifR::LogReg(X=X,
                            moz=sel_moz,
                            Y=factor(Y),
                            number=2,
                            repeats=2,
                            kind="rf",
                            Metric = "Kappa",
                            Sampling = "down")

# Estimated model:
model_rf

# nonlinear multinomial regression using xgboost 
# with down-sampling method and 
# trained with the Kappa coefficient metric

model_xgb=MSclassifR::LogReg(X=X,
                             moz=sel_moz,
                             Y=factor(Y),
                             number=2,
                             repeats=2,
                             kind="xgb",
                             Metric = "Kappa",
                             Sampling = "down")
# Estimated model:
model_xgb

# nonlinear multinomial regression using svm 
# with down-sampling method and 
# trained with the Kappa coefficient metric

model_svm=MSclassifR::LogReg(X=X,
                             moz=sel_moz,
                             Y=factor(Y),
                             number=2,
                             repeats=2,
                             kind="svm",
                             Metric = "Kappa",
                             Sampling = "down")
# Estimated model:
model_svm

##########
# Of note, step 3 can be performed several times 
# to find optimal models 
# because of random hyperparameter search

###############################################################################
## 4. Select best models in term of average Kappa and saving it for reuse

Kappa_model=c(model_lm$stats_global[1,2],model_nn$stats_global[1,2],
              model_rf$stats_global[1,2],model_xgb$stats_global[1,2],model_svm$stats_global[1,2])
names(Kappa_model)=c("lm","nn","rf","xgb","svm")
#Best models in term of accuracy
Kappa_model[which(Kappa_model==max(Kappa_model))]

#save best models for reuse
#models=list(model_lm$train_mod,model_nn$train_mod,model_rf$train_mod,
#model_xgb$train_mod,model_svm$train_mod)
#models_best=models[which(Kappa_model==max(Kappa_model))]
#for (i in 1:length(models_best)){
#save(models_best[[i]], file = paste0("model_best_",i,".rda",collapse="")
#}

#load a saved model
#load("model_best_1.rda")

###############################################################################
## 5. Try other metrics to select the best model

# linear multinomial regression 
# with up-sampling method and 
# trained with the Adjusted Rank index metric

model_lm=MSclassifR::LogReg(X=X,
                            moz=sel_moz,
                            Y=factor(Y),
                            number=2,
                            repeats=3,
                            Metric = "AdjRankIndex",
                            Sampling = "up")



</code></pre>

<hr>
<h2 id='MSclassifR'>
Automated classification of mass spectra
</h2><span id='topic+MSclassifR'></span>

<h3>Description</h3>

<p>This package provides R functions to classify mass spectra in known categories, and to determine discriminant mass-over-charge values. It was developed with the aim of identifying very similar species or phenotypes of bacteria from  mass spectra obtained by Matrix Assisted Laser Desorption Ionisation - Time Of Flight Mass Spectrometry (MALDI-TOF MS). However, the different functions of this package can also be used to classify other categories associated to mass spectra; or from mass spectra obtained with other mass spectrometry techniques. It includes easy-to-use functions for pre-processing mass spectra, functions to determine discriminant mass-over-charge values (m/z) from a library of mass spectra corresponding to different categories, and functions to predict the category (species, phenotypes, etc.) associated to a mass spectrum from a list of selected mass-over-charge values.
</p>


<h3>Value</h3>

<p>No return value. Package description.</p>


<h3>Author(s)</h3>

<p>Alexandre Godmer, Quentin Giai Gianetto
</p>

<hr>
<h2 id='PeakDetection'>Detection of peaks in <code>MassSpectrum</code> objects.</h2><span id='topic+PeakDetection'></span>

<h3>Description</h3>

<p>This function performs a data analysis pipeline to pre-process mass spectra. It provides average intensities and detects peaks using functions of R packages <code>MALDIquant</code> and <code>MALDIrppa</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PeakDetection(x,
              averageMassSpec = TRUE,
              labels = NULL,
              averageMassSpectraMethod = "median",
              SNRdetection = 3,
              binPeaks = TRUE,
              PeakDetectionMethod = "MAD",
              halfWindowSizeDetection = 11,
              AlignMethod = "strict",
              Tolerance = 0.002,
              ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PeakDetection_+3A_x">x</code></td>
<td>
<p>a <code>list</code> of <code>MassSpectrum</code> objects (see <code>MALDIquant</code> R package).</p>
</td></tr>
<tr><td><code id="PeakDetection_+3A_averagemassspec">averageMassSpec</code></td>
<td>
<p>a <code>logical</code> value indicating whether it is necessary to group the spectra according to the arguments <code>labels</code> and  <code>averageMassSpectraMethod</code>. It is fixed to <code>"TRUE"</code> by default.</p>
</td></tr>
<tr><td><code id="PeakDetection_+3A_labels">labels</code></td>
<td>
<p>a <code>list</code> of <code>factor</code> objects to do groupwise averaging.</p>
</td></tr>
<tr><td><code id="PeakDetection_+3A_averagemassspectramethod">averageMassSpectraMethod</code></td>
<td>
<p>a <code>character</code> indicating the method used to average mass spectra according to labels. It is fixed to <code>"median"</code> by default.This function can be replaced by another mathematical function such as <code>"mean"</code>. See <code>averageMassSpectra</code> of <code>MALDIquant</code> R package.</p>
</td></tr>
<tr><td><code id="PeakDetection_+3A_peakdetectionmethod">PeakDetectionMethod</code></td>
<td>
<p>a <code>character</code> indicating the noise estimation method. It uses <code>"MAD"</code> method for <code>list</code> of <code>MassSpectrum</code> objects. This noise estimation method estimation method can be remplaced <code>"SuperSmoother"</code>. See <code>estimateNoise-methods</code> of the <code>MALDIquant</code> R package for details.</p>
</td></tr>
<tr><td><code id="PeakDetection_+3A_snrdetection">SNRdetection</code></td>
<td>
<p>a <code>numeric</code> value indicating the signal-to-noise ratio used to detect peaks (by default = <code>3</code>). See <code>detectPeaks-methods</code> of the <code>MALDIquant</code> R package for details.</p>
</td></tr>
<tr><td><code id="PeakDetection_+3A_binpeaks">binPeaks</code></td>
<td>
<p>a <code>logical</code> value indicating the peaks are aligned in discrete bins. It is fixed to <code>"TRUE"</code> by default. See <code>binPeaks</code> of the <code>MALDIquant</code> R package for details.</p>
</td></tr>
<tr><td><code id="PeakDetection_+3A_halfwindowsizedetection">halfWindowSizeDetection</code></td>
<td>
<p>a <code>numeric</code> value half window size to detect peaks (by default = <code>11</code>). See <code>detectPeaks-methods</code> of the <code>MALDIquant</code> R package for details.</p>
</td></tr>
<tr><td><code id="PeakDetection_+3A_alignmethod">AlignMethod</code></td>
<td>
<p>a <code>character</code> indicating the method used to equalize masses for similar peaks. The <code>"strict"</code> method is used by default corresponding to a unique peak per bin from the same sample. This method can be remplaced by <code>"relaxed"</code> corresponding to multiple peaks per bin from the same sample. See <code>binPeaks</code> of the <code>MALDIquant</code> R package for more details.</p>
</td></tr>
<tr><td><code id="PeakDetection_+3A_tolerance">Tolerance</code></td>
<td>
<p>a <code>numeric</code> value corresponding to the maximal deviation in peak masses to be considered as identical in ppm (by default = <code>0.002</code>). See <code>determineWarpingFunctions</code> of the <code>MALDIquant</code> R package for details.</p>
</td></tr>
<tr><td><code id="PeakDetection_+3A_...">...</code></td>
<td>
<p>other arguments from <code>MALDIquant</code> and <code>MALDIrppa</code> packages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>PeakDetection</code> function provides an analysis pipeline for <code>MassSpectrum</code> objects including peaks detection and binning.
</p>
<p>All the methods used for <code>PeakDetection</code> functions are selected from <code>MALDIquant</code> and <code>MALDIrppa</code> packages.
</p>


<h3>Value</h3>

<p>Returns a list of <code>MassPeaks</code> objects (see <code>MALDIquant</code> R package) for each mass spectrum in <code>x</code>.</p>


<h3>References</h3>

<p>Gibb S, Strimmer K. MALDIquant: a versatile R package for the analysis of mass spectrometry data. Bioinformatics. 2012 Sep 1;28(17):2270-1. doi: <a href="https://doi.org/10.1093/bioinformatics/bts447">10.1093/bioinformatics/bts447</a>. Epub 2012 Jul 12. PMID: 22796955.
</p>
<p>Javier Palarea-Albaladejo, Kevin Mclean, Frank Wright, David G E Smith, MALDIrppa: quality control and robust analysis for mass spectrometry data, Bioinformatics, Volume 34, Issue 3, 01 February 2018, Pages 522 - 523, doi: <a href="https://doi.org/10.1093/bioinformatics/btx628">10.1093/bioinformatics/btx628</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("MALDIquant")
library("MSclassifR")


## Load mass spectra and metadata
data("CitrobacterRKIspectra", "CitrobacterRKImetadata", package = "MSclassifR")

## Pre-processing of mass spectra
spectra &lt;- SignalProcessing(CitrobacterRKIspectra)

## Detection of peaks in pre-processed mass spectra
peaks &lt;- PeakDetection(x = spectra,
                       averageMassSpec = FALSE,
                       labels = CitrobacterRKImetadata$Strain_name_spot,
                       averageMassSpectraMethod = "median",
                       SNRdetection = 3,
                       binPeaks = TRUE,
                       halfWindowSizeDetection = 11,
                       AlignFrequency = 0.20,
                       AlignMethod = "strict",
                       Tolerance = 0.002)

# Plot peaks on a pre-processed mass spectrum
PlotSpectra(SpectralData=spectra[[1]],Peaks=peaks[[1]],col_spec="blue",col_peak="black")
</code></pre>

<hr>
<h2 id='PlotSpectra'>Plot mass spectra with detected peaks</h2><span id='topic+PlotSpectra'></span>

<h3>Description</h3>

<p>This function performs a plot of a <code>AbstractMassObject</code> object (see the <code>MALDIquant</code> R package). It can be used to highlight peaks in a mass spectrum.</p>


<h3>Usage</h3>

<pre><code class='language-R'>
PlotSpectra(SpectralData, absx="ALL", Peaks=NULL, Peaks2=NULL, col_spec=1, 
            col_peak=2, shape_peak=3, col_peak2=2, shape_peak2=2)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PlotSpectra_+3A_spectraldata">SpectralData</code></td>
<td>
<p><code>MassSpectrum</code> object of S4 class (see <code>MALDIquant</code> R package).</p>
</td></tr>
<tr><td><code id="PlotSpectra_+3A_absx">absx</code></td>
<td>
<p><code>vector</code> indicating lower and upper bounds for the mass-over-charge values to plot.</p>
</td></tr>
<tr><td><code id="PlotSpectra_+3A_peaks">Peaks</code></td>
<td>
<p><code>MassPeaks</code> object (see <code>MALDIquant</code> R package). If NULL, peaks are not highlighted.</p>
</td></tr>
<tr><td><code id="PlotSpectra_+3A_peaks2">Peaks2</code></td>
<td>
<p>numeric <code>vector</code> of mass-over-charge values to plot on the mass spectrum.</p>
</td></tr>
<tr><td><code id="PlotSpectra_+3A_col_spec">col_spec</code></td>
<td>
<p>color of the mass spectrum.</p>
</td></tr>
<tr><td><code id="PlotSpectra_+3A_col_peak">col_peak</code></td>
<td>
<p>color of the peak points corresponding to <code>Peaks</code>.</p>
</td></tr>
<tr><td><code id="PlotSpectra_+3A_shape_peak">shape_peak</code></td>
<td>
<p>shape of the peak points corresponding to <code>Peaks</code>.</p>
</td></tr>
<tr><td><code id="PlotSpectra_+3A_col_peak2">col_peak2</code></td>
<td>
<p>color of the peak points corresponding to <code>Peaks2</code>.</p>
</td></tr>
<tr><td><code id="PlotSpectra_+3A_shape_peak2">shape_peak2</code></td>
<td>
<p>Shape of the peak points corresponding to <code>Peaks2</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> object (see <code>ggplot2</code> R package). Mass-over-charge values are in x-axis and intensities in y-axis.</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library("MSclassifR")

# Load mass spectra
data("CitrobacterRKIspectra", package = "MSclassifR")
# Plot raw mass spectrum
PlotSpectra(SpectralData = CitrobacterRKIspectra[[1]])
# standard pre-processing of mass spectra
spectra &lt;- SignalProcessing(CitrobacterRKIspectra)
# Plot pre-processed mass spectrum
PlotSpectra(SpectralData=spectra[[1]])
# detection of peaks in pre-processed mass spectra
peaks &lt;- PeakDetection(x = spectra, averageMassSpec=FALSE)
# Plot peaks on pre-processed mass spectrum
PlotSpectra(SpectralData=spectra[[1]],Peaks=peaks[[1]],col_spec="blue",col_peak="black")

</code></pre>

<hr>
<h2 id='PredictFastClass'>Prediction of the category to which a mass spectrum belongs using linear regressions of mass spectra.</h2><span id='topic+PredictFastClass'></span>

<h3>Description</h3>

<p>For each mass peak in a list of mass peaks, a linear regression is performed between the mass spectrum and mass spectra corresponding to a category. This is performed for each category and associated to an Akaike Information Criterium.  Next, the AIC are used to determine the belonging of a mass spectrum to a category. It also provides a probability that the mass spectrum does not belong to any of the input categories.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PredictFastClass(peaks, 
                 mod_peaks,
                 Y_mod_peaks,
                 moz="ALL",
                 tolerance = 6,
                 toleranceStep = 2,
                 normalizeFun = TRUE,
                 noMatch = 0)  
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PredictFastClass_+3A_peaks">peaks</code></td>
<td>
<p>a list of <code>MassPeaks</code> objects (see <code>MALDIquant</code> R package).</p>
</td></tr>
<tr><td><code id="PredictFastClass_+3A_mod_peaks">mod_peaks</code></td>
<td>
<p>an intensity matrix corresponding to mass spectra for which the category is known. Each column is a mass-over-charge value, each row corresponds to a mass spectrum.</p>
</td></tr>
<tr><td><code id="PredictFastClass_+3A_y_mod_peaks">Y_mod_peaks</code></td>
<td>
<p>a <code>factor</code> with a length equal to the number of mass spectra in <code>mod_peaks</code> and containing the categories of each mass spectrum in <code>mod_peaks</code>.</p>
</td></tr>
<tr><td><code id="PredictFastClass_+3A_moz">moz</code></td>
<td>
<p>a <code>vector</code> with the set of shortlisted mass-over-charge values that corresponds to mass-over-charge values in the columns of <code>mod_peaks</code>. By default, all the mass-over-charge values in <code>mod_peaks</code> are used.</p>
</td></tr>
<tr><td><code id="PredictFastClass_+3A_tolerance">tolerance</code></td>
<td>
<p>a <code>numeric</code> value of accepted tolerance to match peaks to the set of shortlisted mass-over-charge values. It is fixed to 6 Da by default.</p>
</td></tr>
<tr><td><code id="PredictFastClass_+3A_tolerancestep">toleranceStep</code></td>
<td>
<p>a <code>numeric</code> value added to the <code>tolerance</code> parameter to match peaks to the set of shortlisted mass-over-charge values. It is fixed to 2 Da by default.</p>
</td></tr>
<tr><td><code id="PredictFastClass_+3A_normalizefun">normalizeFun</code></td>
<td>
<p>a <code>logical</code> value, if <code>TRUE</code> (default) the maximum intensity will be equal to 1, the other intensities will be expressed in ratio to this maximum.</p>
</td></tr>
<tr><td><code id="PredictFastClass_+3A_nomatch">noMatch</code></td>
<td>
<p>a <code>numeric</code> value used to replace intensity values if there is no match detected between peaks and the set of shortlisted mass-over-charge values <code>moz</code>. It is fixed to 0 by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>dataframe</code> containing AIC criteria by category for each mass spectrum in <code>peaks</code>. The AIC criterion should be minimal for the most probable category. The <code>pred_cat</code> column is the predicted category for each mass spectrum in <code>peaks</code>. The <code>p_not_in_DB</code> is the minimal p-value of several Fisher tests testing if all the linear coefficients associated to mass spectra of a category are null. It can be interpreted as a p-value that the mass spectrum is not present in the input database.</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library("MSclassifR")
library("MALDIquant")

# load mass spectra and their metadata
data("CitrobacterRKIspectra","CitrobacterRKImetadata", package = "MSclassifR")
# standard pre-processing of mass spectra
spectra &lt;- SignalProcessing(CitrobacterRKIspectra)
# detection of peaks in pre-processed mass spectra
peaks &lt;- peaks &lt;- MSclassifR::PeakDetection(x = spectra, averageMassSpec=FALSE)
# matrix with intensities of peaks arranged in rows (each column is a mass-over-charge value)
IntMat &lt;- MALDIquant::intensityMatrix(peaks)
rownames(IntMat) &lt;- paste(CitrobacterRKImetadata$Strain_name_spot)
# remove missing values in the matrix
IntMat[is.na(IntMat)] &lt;- 0
# normalize peaks according to the maximum intensity value for each mass spectrum
IntMat &lt;- apply(IntMat,1,function(x) x/(max(x)))
# transpose the matrix for statistical analysis
X &lt;- t(IntMat)
# define the known categories of mass spectra for the classification
Y &lt;- factor(CitrobacterRKImetadata$Species)

#Predict species without peak selection using a tolerance of 1 Da
res = PredictFastClass(peaks=peaks[1:5],
                       mod_peaks=X,
                       Y_mod_peaks=Y,
                       tolerance = 1)

#comparing predicted categories (species) and the truth
cbind(res$pred_cat,as.character(Y[1:5]))

# The method can be applied after a peak selection step
a &lt;- SelectionVar(X,
                  Y,
                  MethodSelection = c("RFERF"),
                  MethodValidation = c("cv"),
                  PreProcessing = c("center","scale","nzv","corr"),
                  NumberCV = 2,
                  Metric = "Kappa",
                  Sizes = c(20:40),
                  Sampling = "up")

#Predict species from selected peaks using a tolerance of 1 Da
res = PredictFastClass(peaks=peaks[1:5],
                       moz = a$sel_moz,
                       mod_peaks=X,
                       Y_mod_peaks=Y, tolerance = 1)

#comparing predicted categories (species) and the truth
cbind(res$pred_cat,as.character(Y[1:5]))


</code></pre>

<hr>
<h2 id='PredictLogReg'>Prediction of the category to which a mass spectrum belongs from a multinomial logistic regression model</h2><span id='topic+PredictLogReg'></span>

<h3>Description</h3>

<p>This function predicts the category (species, phenotypes...) to which a mass spectrum belongs from a set of shortlisted mass-over-charge values of interest and a short-listed multinomial logistic regression model (see <code><a href="#topic+LogReg">LogReg</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PredictLogReg(peaks,
              model,
              moz,
              tolerance = 6,
              toleranceStep = 2,
              normalizeFun = TRUE,
              noMatch=0,
              Reference = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PredictLogReg_+3A_peaks">peaks</code></td>
<td>
<p>a list of <code>MassPeaks</code> objects (see <code>MALDIquant</code> R package).</p>
</td></tr>
<tr><td><code id="PredictLogReg_+3A_model">model</code></td>
<td>
<p>a model or a list of models estimated from a set of shortlisted mass-over-charge values (output of the <code><a href="#topic+LogReg">LogReg</a></code> function).</p>
</td></tr>
<tr><td><code id="PredictLogReg_+3A_moz">moz</code></td>
<td>
<p>a <code>vector</code> with the set of shortlisted mass-over-charge values used to estimate the model <code>Model</code>.</p>
</td></tr>
<tr><td><code id="PredictLogReg_+3A_tolerance">tolerance</code></td>
<td>
<p>a <code>numeric</code> value of accepted tolerance to match peaks to the set of shortlisted mass-over-charge values. It is fixed to 6 Da by default.</p>
</td></tr>
<tr><td><code id="PredictLogReg_+3A_tolerancestep">toleranceStep</code></td>
<td>
<p>a <code>numeric</code> value added to the <code>tolerance</code> parameter to match peaks to the set of shortlisted mass-over-charge values. It is fixed to 2 Da by default.</p>
</td></tr>
<tr><td><code id="PredictLogReg_+3A_normalizefun">normalizeFun</code></td>
<td>
<p>a <code>logical</code> value, if <code>TRUE</code> (default) the maximum intensity will be equal to 1, the other intensities will be expressed in ratio to this maximum.</p>
</td></tr>
<tr><td><code id="PredictLogReg_+3A_nomatch">noMatch</code></td>
<td>
<p>a <code>numeric</code> value used to replace intensity values if there is no match detected between peaks and the set of shortlisted mass-over-charge values <code>moz</code>. It is fixed to 0 by default.</p>
</td></tr>
<tr><td><code id="PredictLogReg_+3A_reference">Reference</code></td>
<td>
<p>a <code>factor</code> with a length equal to the number of rows in <code>X</code> and containing the categories of each mass spectrum in <code>X</code>. <code>"NULL"</code> by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>PredictLogReg</code> function allows predicting the membership of a mass spectrum to a category from a multinomial regression model. The mass spectrum from the <code>peaks</code> object will be matched to the discriminant mass-over-chage (m/z) values (<code>sel_moz</code> object from the <code>SelectionVar</code> or <code>SelectionVarStat</code> functions)  with a tolerance between 2 m/z and defined by the <code>tolerance</code> parameter (by default this value is 6 Da). If a repetition of a same m/z occurs in the selection, only the m/z that is closest in mass peaks (<code>moz</code>) is used. When no match, intensity values are replaced by the <code>noMatch</code> argument. If no m/z values from <code>peaks</code> object matched with the m/z in the object <code>moz</code>, the tolerance will be increased according to a numeric value defined in the <code>toleranceStep</code> parameter and a warning will be notified. Note that it is possible to not perform the <code>SelectionVar</code> function prior to the <code>PredictLogReg</code> function, and to replace the argument <code>moz</code> by all the m/z values present in a mass spectrum.</p>


<h3>Value</h3>

<p>Returns a <code>dataframe</code> containing probabilities of membership by category for each mass spectrum in <code>peaks</code>. The method used is provided in the <code>method</code> column. The <code>comb_fisher</code> method is the result of the Fisher's method when merging probabilities of membership of used prediction models.The <code>max_vote</code> method is the result of the maximum voting from used prediction models.
</p>
<p>If the <code>Reference</code> parameter is not null, the function returns:
</p>
<table role = "presentation">
<tr><td><code>Confusion.Matrix</code></td>
<td>
<p>a <code>list</code> of confusion matrix (cross-tabulation with associated statitics) corresponding to the output of the <code>confusionMatrix</code> function of the <code>caret</code> R package.</p>
</td></tr>
<tr><td><code>Gobal.stat</code></td>
<td>
<p>a <code>data.frame</code> with three columns corresponding to the value (<code>value</code> column) of a statistic parameter (<code>Statistic.parameter</code> column) from a method used (<code>model</code> column) obtained with the <code>LogReg</code> function. See <code>LogReg</code> function for the Statistic.parameter column.</p>
</td></tr>
<tr><td><code>Details.stat</code></td>
<td>
<p>a <code>data.frame</code> with four columns corresponding to the same as <code>Gobal.stat</code> dataframe with the class concerned for estimated statistic parameter (class column). All statistic parameters are extracted from the output of the <code>confusionMatrix</code> function of the <code>caret</code> R package.</p>
</td></tr>
<tr><td><code>Correct.ClassificationFreq</code></td>
<td>
<p>a <code>data.frame</code> with predicted class (Prediction column) from a method (Model column) and the reference of the categories of each mass spectrum (Reference column). The <code>Freq</code> column indicates the number of times the category was correctly predicted by the method.</p>
</td></tr>
<tr><td><code>Incorrect.ClassificationFreq</code></td>
<td>
<p>a <code>data.frame</code> with predicted class (Prediction column) from a method (<code>Model</code> column) and the reference of the categories of each mass spectrum (<code>Reference</code> column). The <code>Freq</code> column indicates the number of times the category was not correctly predicted by the method. </p>
</td></tr>
</table>


<h3>References</h3>

<p>Kuhn, M. (2008). Building predictive models in R using the caret package. Journal of statistical software, 28(1), 1-26.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library("MSclassifR")
library("MALDIquant")

###############################################################################
## 1. Pre-processing of mass spectra

# load mass spectra and their metadata
data("CitrobacterRKIspectra","CitrobacterRKImetadata", package = "MSclassifR")
# standard pre-processing of mass spectra
spectra &lt;- SignalProcessing(CitrobacterRKIspectra)
# detection of peaks in pre-processed mass spectra
peaks &lt;- MSclassifR::PeakDetection(x = spectra, averageMassSpec=FALSE)
# matrix with intensities of peaks arranged in rows (each column is a mass-over-charge value)
IntMat &lt;- MALDIquant::intensityMatrix(peaks)
rownames(IntMat) &lt;- paste(CitrobacterRKImetadata$Strain_name_spot)
# remove missing values in the matrix
IntMat[is.na(IntMat)] &lt;- 0
# normalize peaks according to the maximum intensity value for each mass spectrum
IntMat &lt;- apply(IntMat,1,function(x) x/(max(x)))
# transpose the matrix for statistical analysis
X &lt;- t(IntMat)
# define the known categories of mass spectra for the classification
Y &lt;- factor(CitrobacterRKImetadata$Species)

###############################################################################
## 2. Selection of discriminant mass-over-charge values using RFERF
# with 5 to 10 variables,
# without sampling method and trained
# with the Accuracy coefficient metric

a &lt;- MSclassifR::SelectionVar(X,
                              Y,
                              MethodSelection = c("RFERF"),
                              MethodValidation = c("cv"),
                              PreProcessing = c("center","scale","nzv","corr"),
                              NumberCV = 2,
                              Metric = "Kappa",
                              Sizes = c(5:10))

sel_moz=a$sel_moz

###############################################################################
## 3. Perform LogReg from shortlisted discriminant mass-over-charge values

# linear multinomial regression
# without sampling mehod and
# trained with the Kappa coefficient metric

model_lm=MSclassifR::LogReg(X=X,
                            moz=sel_moz,
                            Y=factor(Y),
                            number=2,
                            repeats=2,
                            Metric = "Kappa")
# Estimated model:
model_lm

# nonlinear multinomial regression using neural networks
# with up-sampling method and
# trained with the Kappa coefficient metric

model_nn=MSclassifR::LogReg(X=X,
                            moz=sel_moz,
                            Y=factor(Y),
                            number=2,
                            repeats=2,
                            kind="nnet",
                            Metric = "Kappa",
                            Sampling = "up")
# Estimated model:
model_nn

# nonlinear multinomial regression using random forests
# without down-sampling method and
# trained with the Kappa coefficient metric

model_rf=MSclassifR::LogReg(X=X,
                            moz=sel_moz,
                            Y=factor(Y),
                            number=2,
                            repeats=2,
                            kind="rf",
                            Metric = "Kappa",
                            Sampling = "down")

# Estimated model:
model_rf

# nonlinear multinomial regression using xgboost
# with down-sampling method and
# trained with the Kappa coefficient metric

model_xgb=MSclassifR::LogReg(X=X,
                             moz=sel_moz,
                             Y=factor(Y),
                             number=2,
                             repeats=2,
                             kind="xgb",
                             Metric = "Kappa",
                             Sampling = "down")
# Estimated model:
model_xgb

# nonlinear multinomial regression using svm
# with down-sampling method and
# trained with the Kappa coefficient metric

model_svm=MSclassifR::LogReg(X=X,
                             moz=sel_moz,
                             Y=factor(Y),
                             number=2,
                             repeats=2,
                             kind="svm",
                             Metric = "Kappa",
                             Sampling = "down")
# Estimated model:
model_svm

# Of note, you can also load a model already saved
# (see example in LogReg function) for the next step
###############################################################################
## 4. Probabilities of belonging to each category for the mass spectra
## and associated statitics

# Collect all the estimated models in a list

Models &lt;- list(model_lm$train_mod,
               model_nn$train_mod,
               model_rf$train_mod,
               model_xgb$train_mod,
               model_svm$train_mod)

# Predict classes of mass spectra with 6 Da of tolerance for matching peaks.
prob_cat=MSclassifR::PredictLogReg(peaks = peaks[c(1:5)],
                                   model = Models,
                                   moz = sel_moz,
                                   tolerance = 6,
                                   Reference = Y[c(1:5)])

################################################################################
## 5. Example of meta-classifiers based on several random forest models
## to optimize a Kappa value using the SMOTE method for imbalanced datasets.
## -&gt; a merge of the prediction probabilities using the Fisher's method
## leads generally to robust prediction models.

#Selecting peaks with mda method
a=SelectionVar(X,Y,MethodSelection="mda",Ntree=5*ncol(X))
sel_moz=a$sel_moz

#Building 4 Random Forest models
models=NULL;nbm=4;
for (i in 1:nbm){
  model_rf=MSclassifR::LogReg(X=X,
                             moz=sel_moz,
                             Y=factor(Y),
                             number=5,
                             repeats=5,
                             kind="rf",
                             Metric = "Kappa",
                             Sampling = "smote")
  models &lt;- c(models,list(model_rf$train_mod))
}

#Combining their prediction probabilities
prob_cat=MSclassifR::PredictLogReg(peaks = peaks,model = models,moz = sel_moz,
tolerance = 6,Reference = Y)


</code></pre>

<hr>
<h2 id='SelectionVar'>Variable selection using random forests, logistic regression methods or sparse partial least squares discriminant analysis (sPLS-DA).</h2><span id='topic+SelectionVar'></span>

<h3>Description</h3>

<p>This function performs variable selection (i.e. selection of discriminant mass-over-charge values) using either recursive feature elimination (RFE) algorithm with Random Forest, or logistic regression model, or sparse partial least squares discriminant analysis (sPLS-DA) or methods based on the distribution of variable importances of random forests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SelectionVar(X,
             Y,
             MethodSelection = c("RFERF", "RFEGlmnet", "VSURF", "sPLSDA", "mda", "cvp"), 
             MethodValidation = c("cv", "repeatedcv", "LOOCV"),
             PreProcessing = c("center", "scale", "nzv", "corr"), 
             Metric = c("Kappa", "Accuracy"), Sampling = c("no", "up","down", "smote"),
             NumberCV = NULL,
             RepeatsCV = NULL, 
             Sizes,
             Ntree = 1000,
             ncores = 2,
             threshold = 0.01,
             ncomp.max = 10,
             nbf=0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SelectionVar_+3A_x">X</code></td>
<td>
<p>a numeric <code>matrix</code> corresponding to a library of mass spectra. Each row of <code>X</code> is the intensities of a mass spectrum measured on mass-over-charge values. The columns are assumed to be mass-over-charge values.</p>
</td></tr>
<tr><td><code id="SelectionVar_+3A_y">Y</code></td>
<td>
<p>a <code>factor</code> with a length equal to the number of rows in <code>X</code> and containing the categories of each mass spectrum in <code>X</code>.</p>
</td></tr>
<tr><td><code id="SelectionVar_+3A_methodselection">MethodSelection</code></td>
<td>
<p>a <code>character</code> indicating the method used for variables selection. Six methods are available: (1) <code>"RFERF"</code> for recursive feature elimination (RFE) coupled with random forests (see <code>rfe</code> in the <code>caret</code> R package); (2) <code>"RFEGlmnet"</code> for RFE with coupled with logistic regression; (3) <code>"VSURF"</code> for a method using random forests (see <code>VSURF</code> in the <code>VSURF</code> R package); (4) <code>"sPLSDA"</code> for a method based on sparse partial least squares discriminant analysis (see <code>splsda</code> in the <code>mixOmics</code>); (5) <code>"mda"</code> for a method selecting variables from the distribution of the &quot;mean decrease in accuracy&quot; variables importances of a random forest (see <code>importance</code> function in the <code>randomForest</code> R package); (6) <code>"cvp"</code> for a method selecting variables from the distribution of the cross-validated  permutation variables importances of a random forest (see <code>CVPVI</code> function in the <code>vita</code> R package). Additional explanations are available in the Details section.</p>
</td></tr>
<tr><td><code id="SelectionVar_+3A_methodvalidation">MethodValidation</code></td>
<td>
<p>a <code>character</code> indicating the resampling method:<code>"cv"</code> for cross-validation; <code>"repeatedcv"</code> for repeated cross-validation; and <code>"LOOCV"</code> for leave-one-out cross-validation. Only used for the <code>"RFERF"</code>, <code>"RFEGlmnet"</code> and <code>"sPLSDA"</code> methods.</p>
</td></tr>
<tr><td><code id="SelectionVar_+3A_numbercv">NumberCV</code></td>
<td>
<p>a <code>numeric</code> value indicating the number of K-folds for cross-validation. Only used for the <code>"RFERF"</code>, <code>"RFEGlmnet"</code>, <code>"sPLSDA"</code> and <code>"cvp"</code> methods.</p>
</td></tr>
<tr><td><code id="SelectionVar_+3A_repeatscv">RepeatsCV</code></td>
<td>
<p>a <code>numeric</code> value indication the number of repeat(s) for K-folds for cross-validation or repeated cross-validation. Only used for the <code>"RFERF"</code>, <code>"RFEGlmnet"</code> and <code>"sPLSDA"</code> methods.</p>
</td></tr>
<tr><td><code id="SelectionVar_+3A_preprocessing">PreProcessing</code></td>
<td>
<p>a <code>vector</code> indicating the method(s) used to pre-process the mass spectra in <code>X</code>: centering (<code>"center"</code>), scaling (<code>"scale"</code>), eliminating near zero variance predictors (<code>"nzv"</code>), or correlated predictors (<code>"corr"</code>). Only used for the <code>"RFERF"</code>, <code>"RFEGlmnet"</code> and <code>"sPLSDA"</code> methods.</p>
</td></tr>
<tr><td><code id="SelectionVar_+3A_metric">Metric</code></td>
<td>
<p>a <code>character</code> indicating the metric used to select the optimal model for the RFE algorithms. Possible metrics are the <code>"Kappa"</code> coefficient or the <code>"Accuracy"</code>. This argument is not used for the <code>"VSURF"</code>, <code>"cvp"</code>, <code>"mda"</code> and the <code>"sPLSDA"</code> methods of <code>MethodSelection</code>. See details of the <code>"SelectionVar"</code> function.</p>
</td></tr>
<tr><td><code id="SelectionVar_+3A_sampling">Sampling</code></td>
<td>
<p>a <code>character</code> indicating an optional subsampling method to handle imbalanced datasets: subsampling methods are either <code>"no"</code> (no subsampling), <code>"up"</code>, <code>"down"</code> or <code>"smote"</code>. <code>"no"</code> by default.</p>
</td></tr>
<tr><td><code id="SelectionVar_+3A_sizes">Sizes</code></td>
<td>
<p>a numeric <code>vector</code> indicating the number of variables to select. Only used for the <code>"RFERF"</code>, <code>"RFEGlmnet"</code> and <code>"sPLSDA"</code> methods. For the <code>"RFERF"</code> and <code>"RFEGlmnet"</code> methods, the final number of selected variables is the one giving the highest average <code>"Metric"</code> (<code>"Accuracy"</code> or <code>"Kappa"</code>) on the folds used for cross-validation. It is thus bounded by <code>NumberCV*max(Sizes)</code>. For the <code>"sPLSDA"</code> method, <code>Sizes</code> corresponds to the number of variables to test from the <code>X</code> dataset when estimating the sparse PLS-DA model (see <code>test.keepX</code> argument in the <code>mixOmics</code> R package).</p>
</td></tr>
<tr><td><code id="SelectionVar_+3A_ntree">Ntree</code></td>
<td>
<p>a <code>numeric</code> value indicating the number of trees in random forests, only used if <code>MethodSelection</code> = <code>"VSURF"</code> or <code>"mda"</code> or <code>"cvp"</code>. Note we advise to select a number highly superior to the total number of variables for a robust selection (to not miss some features in the subspaces used to build trees). It is 1000 by default.</p>
</td></tr>
<tr><td><code id="SelectionVar_+3A_ncores">ncores</code></td>
<td>
<p>a <code>positive integer</code> only used for the <code>cvp</code> method. The number of cores to use, i.e. at most how many child processes will be run simultaneously. Must be at least one, and parallelization requires at least two cores. If <code>ncores=0</code>, then the half of CPU cores on the current host are used.</p>
</td></tr>
<tr><td><code id="SelectionVar_+3A_ncomp.max">ncomp.max</code></td>
<td>
<p>a <code>positive integer</code> indicating the maximum number of components that can be included in the sPLS-DA model (10 by default).</p>
</td></tr>
<tr><td><code id="SelectionVar_+3A_threshold">threshold</code></td>
<td>
<p>a <code>numeric</code> value corresponding to a threshold used for the optimal selection of the number of components included in the sPLS-DA model (0.01 by default). When the number of components increases and the balanced classification error rate (BER) does not change anymore, we keep the minimal number where the BER reaches a plateau (i.e. when <code>BER(N)-BER(N+1)&lt;threshold</code>, we keep <code>N</code>). If a plateau is not reached, <code>ncomp.max</code> components are selected.</p>
</td></tr>
<tr><td><code id="SelectionVar_+3A_nbf">nbf</code></td>
<td>
<p>a <code>numeric</code> value corresponding to a number of simulated non discriminant features. This is used to improve the robustness of the estimation of the distribution of the variable importances for non discriminant features. Only used for the <code>"mda"</code> and <code>"cvp"</code> methods. 0 by default: no additional non discriminant feature is created.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The selection of variables can be carried out with two different objectives: either to find a minimum number of variables allowing to obtain the highest possible accuracy (or Kappa coefficient), which involves the possible elimination of variables correlated between them (i.e. not bringing any additional predictive power with respect to some other variables); or to find all the variables in the dataset with a potential predictive power (&quot;discriminant&quot; variables).
</p>
<p>The <code>VSURF</code> method attempts to accomplish only the first objective. 
The <code>mda</code> and <code>cvp</code> methods attempt to accomplish the second objective, as do the methods available in the <code>SelectionVarStat</code> function of our <code>MSclassifR</code> R package.
The <code>RFERF</code>, <code>RFEGlmnet</code> and <code>sPLSDA</code> methods take as input a number of variables to be selected(<code>Sizes</code> argument), and can therefore be used with both objectives.
</p>
<p>Within the framework of the second objective, either the <code>mda</code> or <code>cvp</code> methods can be used to estimate a number of discriminant variables from the importances of variables. The <code>SelectionVarStat</code> function can also be used to estimate this number from distributions of p-values. Of note, be sure that the <code>Ntree</code> argument is high enough to get a robust estimation with the <code>mda</code> or <code>cvp</code> methods.
</p>
<p>The <code>"RFEGlmnet"</code> and <code>"RFERF"</code> methods are based on recursive feature elimination and can either optimize the kappa coefficient or the accuracy as metrics when selecting variables.
</p>
<p>The <code>"sPLSDA"</code> method selects variables from the ones kept in latent components of the sparse PLS-DA model using an automatic choice of the number of components (when the balanced classification error rate (BER) reaches a plateau - see argument <code>threshold</code>).
</p>
<p>The <code>"mda"</code> and <code>"cvp"</code> methods use the distribution of variable importances to estimate the number of discriminant features (mass-over-charge values). Briefly, the distribution of variable importances for useless (not discriminant) features is firstly estimated from negative importance variables by the method proposed in section 2.6 of Janitza et al.(2018). Next, the following mixture model is assumed:
<code class="reqn">F(x)=\pi\times F_u(x)+(1-\pi)\times F_d(x)</code>
where <code class="reqn">F</code> is the empirical cumulative distribution of variable importances of all the features, <code class="reqn">F_u</code> the one of the useless features, <code class="reqn">F_d</code> the one of the discriminative features, and <code class="reqn">\pi</code> is the proportion of useless features in the dataset. 
From the estimated distribution of useless features, we can estimate quantile values <code class="reqn">x_q</code> and compute <code class="reqn">\epsilon_q=min(F(x_q)/q;1)</code> for each quantile <code class="reqn">q</code>. The minimum of the <code class="reqn">\epsilon_q</code> corresponds to the estimated proportion of useless features in the dataset, what allows estimating the number of discriminant features by <code class="reqn">N_d=floor(N\times (1 - \pi))</code> where N is the total number of features. Next, the <code class="reqn">N_d</code> features with the highest variable importances are selected.
</p>
<p>The <code>"VSURF"</code> and <code>"sPLSDA"</code> methods use the minimum mean out-of-bag (OOB) and balanced classification error rate (BER) metrics respectively. 
</p>
<p>For <code>Sampling</code> methods available for unbalanced data: <code>"up"</code> corresponds to the up-sampling method which consists of random sampling (with replacement) so that the minority class is the same size as the majority class; <code>"down"</code> corresponds to the down-sampling method randomly which consists of random sampling (without replacement) of the majority class so that their class frequencies match the minority class; <code>"smote"</code> corresponds to the Synthetic Minority Over sampling Technique (SMOTE) specific algorithm for data augmentation which consist of creates new data from minority class using the K Nearest Neighbor algorithm.
</p>
<p>See <code>rfe</code> in the <code>caret</code> R package, <code>VSURF</code> in the <code>VSURF</code> R package, <code>splsda</code> in the <code>mixOmics</code> R package, <code>importance</code> function in the <code>randomForest</code> R package, and <code>CVPVI</code> function in the <code>vita</code> R package for more details.
</p>


<h3>Value</h3>

<p>A list composed of:
</p>
<table role = "presentation">
<tr><td><code>sel_moz</code></td>
<td>
<p>a <code>vector</code> with discriminant mass-over-chage values.</p>
</td></tr>
</table>
<p>For the <code>"RFERF"</code> and <code>"RFEGlmnet"</code> methods, it also returns the results of the <code>rfe</code> function of the <code>caret</code> R package.
</p>
<p>For the <code>"VSURF"</code> method, it also returns the results of the results of the <code>VSURF</code> function of the <code>VSURF</code> R package. 
</p>
<p>For the <code>"sPLSDA"</code> method, it also returns the following items:
</p>
<table role = "presentation">
<tr><td><code>Raw_data</code></td>
<td>
<p>a horizontal bar plot and  containing the contribution of features on each component.</p>
</td></tr>
<tr><td><code>selected_variables</code></td>
<td>
<p><code>data frame</code> with uniques features (selected variables to keep and containing the contribution of features in order to class samples).See <code>plotLoadings</code> in the <code>mixOmics</code> R package for details.</p>
</td></tr>
</table>
<p>For the <code>"mda"</code> and <code>"cvp"</code> methods, it also returns the following items:
</p>
<table role = "presentation">
<tr><td><code>nb_to_sel</code></td>
<td>
<p>a numeric value corresponding to an estimated number of mass-over-chage values where the intensities are significantly different between categories (see details).</p>
</td></tr>
<tr><td><code>imp_sel</code></td>
<td>
<p>a vector containing the variable importances for the selected features.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Kuhn, Max. (2012). The caret Package. Journal of Statistical Software. 28.
</p>
<p>Genuer, Robin, Jean-Michel Poggi and Christine Tuleau-Malot. VSURF : An R Package for Variable Selection Using Random Forests. R J. 7 (2015): 19.
</p>
<p>Friedman J, Hastie T, Tibshirani R (2010). Regularization Paths for Generalized Linear Models via Coordinate Descent. Journal of Statistical Software, 33(1), 1-22.
</p>
<p>Kim-Anh Le Cao, Florian Rohart, Ignacio Gonzalez, Sebastien Dejean with key contributors Benoit Gautier, Francois, Bartolo, contributions from Pierre Monget, Jeff Coquery, FangZou Yao and Benoit Liquet. (2016). mixOmics: Omics. Data Integration Project. R package version 6.1.1. <a href="https://CRAN.R-project.org/package=mixOmics">https://CRAN.R-project.org/package=mixOmics</a>
</p>
<p>Nitesh V. Chawla, Kevin W. Bowyer, Lawrence O. Hall, and W. Philip Kegelmeyer. 2002. SMOTE: synthetic minority over-sampling technique. J. Artif. Int. Res. 16, 1 (January 2002), 321357.
</p>
<p>Branco P, Ribeiro R, Torgo L (2016). UBL: an R Package for Utility-Based Learning. CoRR, abs/1604.08079. 
</p>
<p>Janitza, S., Celik, E., Boulesteix, A. L. (2018). A computationally fast variable importance test for random forests for high-dimensional data. Advances in Data Analysis and Classification, 12, 885-915.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


library("MSclassifR")
library("MALDIquant")

###############################################################################
## 1. Pre-processing of mass spectra

# load mass spectra and their metadata
data("CitrobacterRKIspectra","CitrobacterRKImetadata", package = "MSclassifR")
# standard pre-processing of mass spectra
spectra &lt;- MSclassifR::SignalProcessing(CitrobacterRKIspectra)
# detection of peaks in pre-processed mass spectra
peaks &lt;- MSclassifR::PeakDetection(x = spectra, averageMassSpec=FALSE)
# matrix with intensities of peaks arranged in rows (each column is a mass-over-charge value)
IntMat &lt;- MALDIquant::intensityMatrix(peaks)
rownames(IntMat) &lt;- paste(CitrobacterRKImetadata$Strain_name_spot)
# remove missing values in the matrix
IntMat[is.na(IntMat)] &lt;- 0
# normalize peaks according to the maximum intensity value for each mass spectrum
IntMat &lt;- apply(IntMat,1,function(x) x/(max(x)))
# transpose the matrix for statistical analysis
X &lt;- t(IntMat)
# define the known categories of mass spectra for the classification
Y &lt;- factor(CitrobacterRKImetadata$Species)

###############################################################################
## 2. Perform variables selection using SelectionVar with RFE and random forest 
# with 5 to 10 variables, 
# up sampling method and trained with the Kappa coefficient metric
a &lt;- SelectionVar(X,
                  Y,
                  MethodSelection = c("RFERF"),
                  MethodValidation = c("cv"),
                  PreProcessing = c("center","scale","nzv","corr"),
                  NumberCV = 2,
                  Metric = "Kappa",
                  Sizes = c(5:10),
                  Sampling = "up")

# Plotting peaks on the first pre-processed mass spectrum and highlighting the 
# discriminant mass-over-charge values with red lines
PlotSpectra(SpectralData=spectra[[1]],Peaks=peaks[[1]],
            Peaks2=a$sel_moz,col_spec="blue",col_peak="black")

###############################################################################
## 3. Perform variables selection using SelectionVar with VSURF 
# This function can last a few minutes
b &lt;- SelectionVar(X, Y, MethodSelection = c("VSURF"))
summary(b$result)

###############################################################################
## 4. Perform variables selection using SelectionVar with "mda" or "cvp"
# option 1: Using mean decrease in accuracy  
# with no sampling method
c &lt;- SelectionVar(X,Y,MethodSelection="mda",Ntree=10*ncol(X)) 

# Estimation of the number of peaks to discriminate species
c$nb_to_sel

# Discriminant mass-over-charge values 
c$sel_moz

# Plotting peaks on the first pre-processed mass spectrum and highlighting the 
# discriminant mass-over-charge values with red lines
PlotSpectra(SpectralData=spectra[[1]],Peaks=peaks[[1]],
            Peaks2=c$sel_moz,col_spec="blue",col_peak="black")

# option 2: Using cross-validated permutation variable importance measures (more "time-consuming")       
# with no sampling method
d &lt;- SelectionVar(X,Y,MethodSelection="cvp",NumberCV=2,ncores=2,Ntree=1000)

# Estimation of the number of peaks to discriminate species
d$nb_to_sel

# Discriminant mass-over-charge values 
d$sel_moz

# Plotting peaks on the first pre-processed mass spectrum and highlighting the 
# discriminant mass-over-charge values with red lines
PlotSpectra(SpectralData=spectra[[1]],Peaks=peaks[[1]],
            Peaks2=d$sel_moz,col_spec="blue",col_peak="black")

# Mass-over charge values found with both methods ("mda" and "cvp")
intersect(c$sel_moz,d$sel_moz)




</code></pre>

<hr>
<h2 id='SelectionVarStat'>Variable selection using multiple statistical tests.</h2><span id='topic+SelectionVarStat'></span>

<h3>Description</h3>

<p>This function performs a statistical test for each mass-over-charge value to determine which are discriminants between categories. Using the distribution of resulting multiple p-values, it determines an expected number of discriminant features, and adjusted p-values that can be used to control a false discovery rate threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
SelectionVarStat(X,
                 Y,
                 stat.test = "Limma",
                 pi0.method="abh",
                 fdr=0.05,
                 Sampling = c("no", "up","down", "smote"))

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SelectionVarStat_+3A_x">X</code></td>
<td>
<p>a <code>numeric</code> matrix corresponding to a library of mass spectra. Rows of <code>X</code> are the intensities of a mass spectrum measured on mass-over-charge values. The columns are mass-over-charge values.</p>
</td></tr>
<tr><td><code id="SelectionVarStat_+3A_y">Y</code></td>
<td>
<p>a <code>factor</code> with a length equal to the number of rows in <code>X</code> and containing the categories of each mass spectrum in <code>X</code>.</p>
</td></tr>
<tr><td><code id="SelectionVarStat_+3A_stat.test">stat.test</code></td>
<td>
<p>a <code>character</code> among <code>"anova"</code>, <code>"kruskal"</code>, or <code>"Limma"</code> (default). It corresponds to the test used to know if the intensity measured at a mass-over-charge value is significantly different between categories. <code>"anova"</code> is for a classical ANOVA Fisher test, <code>"kruskal"</code> is for the Kruskal-Wallis test, <code>"Limma"</code> is for an ANOVA Fisher test using the <code>limma</code> R package.</p>
</td></tr>
<tr><td><code id="SelectionVarStat_+3A_pi0.method">pi0.method</code></td>
<td>
<p>a <code>character</code> among <code>"abh"</code>, <code>"st.spline"</code>, <code>"st.boot"</code>, <code>"langaas"</code>, <code>"histo"</code>, <code>"pounds"</code>, <code>"jiang"</code>, <code>"slim"</code>. It corresponds to statistical methods used to estimate the proportion of true null hypotheses among the set of tested mass-over-charge values. See the <code>estim.pi0</code> function of the R package <code>cp4p</code> for details.</p>
</td></tr>
<tr><td><code id="SelectionVarStat_+3A_fdr">fdr</code></td>
<td>
<p>a <code>numeric</code> value corresponding to False Discovery Rate threshold used to determine the differential mass-over-charge values. 0.05 by default.</p>
</td></tr>
<tr><td><code id="SelectionVarStat_+3A_sampling">Sampling</code></td>
<td>
<p>a <code>character</code> indicating an optional subsampling method to handle imbalanced datasets: subsampling methods are either <code>"no"</code> (no subsampling), <code>"up"</code>, <code>"down"</code> or <code>"smote"</code>. <code>"no"</code> by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>SelectionVarStat</code> function allows performing &quot;quick&quot; classification of mass-over-charge values. It tries to find all the mass-over-charge values (or the number of mass-over-charge values) that are discriminant between categories. This can conduct to select &quot;correlated&quot; mass-over-charge values (i.e. associated to intensities evolving similarly between categories). By default, multiple moderated t-tests using the <code>limma</code> R package (bayesian regularization of variances) are performed and the p-values are corrected using an adaptive Benjamini and Hochberg procedure to control the false discovery rate. Different ways to estimate the proportion of true null hypotheses (object <code>pi0</code> returned by the function - see the  <code>cp4p</code> R package for details) can be used for the adaptive Benjamini-Hochberg procedure (&quot;<code>abh</code>&quot; by defaut).</p>


<h3>Value</h3>

<p>A list composed of:
</p>
<table role = "presentation">
<tr><td><code>nb_to_sel</code></td>
<td>
<p>a <code>numeric</code> value corresponding to an estimation of the optimal number of mass-over-charge values to discriminate between different groups.</p>
</td></tr>
<tr><td><code>sel_moz</code></td>
<td>
<p>a <code>vector</code> with selected discriminant mass-over-charge values.</p>
</td></tr>
<tr><td><code>ap</code></td>
<td>
<p>a <code>list</code> composed of <code>pi0</code> the proportion of non-discriminant mass-over-charge values, and <code>adjp</code> a matrix of raw p-values and corresponding ajusted p-values for all the mass-over-charge values that have been tested.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Gianetto, Quentin &amp; Combes, Florence &amp; Ramus, Claire &amp; Bruley, Christophe &amp; Coute, Yohann &amp; Burger, Thomas. (2015). Technical Brief Calibration Plot for Proteomics (CP4P): A graphical tool to visually check the assumptions underlying FDR control in quantitative experiments. Proteomics. 16. 10.1002/pmic.201500189. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library("MSclassifR")
library("MALDIquant")

###############################################################################
## 1. Pre-processing of mass spectra

# load mass spectra and their metadata
data("CitrobacterRKIspectra","CitrobacterRKImetadata", package = "MSclassifR")
# standard pre-processing of mass spectra
spectra &lt;- MSclassifR::SignalProcessing(CitrobacterRKIspectra)
# detection of peaks in pre-processed mass spectra
peaks &lt;- MSclassifR::PeakDetection(x = spectra, labels = CitrobacterRKImetadata$Strain_name_spot)
# matrix with intensities of peaks arranged in rows (each column is a mass-over-charge value)
IntMat &lt;- MALDIquant::intensityMatrix(peaks)
rownames(IntMat) &lt;- paste(CitrobacterRKImetadata$Strain_name_spot)
# remove missing values in the matrix
IntMat[is.na(IntMat)] &lt;- 0
# normalize peaks according to the maximum intensity value for each mass spectrum
IntMat &lt;- apply(IntMat,1,function(x) x/(max(x)))
# transpose the matrix for statistical analysis
X &lt;- t(IntMat)
# define the known categories of mass spectra for the classification
Y &lt;- factor(CitrobacterRKImetadata$Species)

###############################################################################
## 2. Estimate the optimal number of peaks to discriminate the different species

OptiPeaks &lt;- SelectionVarStat(X,
                              Y,
                              stat.test = "Limma",
                              pi0.method="abh",
                              fdr=0.05,
                              Sampling="smote")
             
## Estimation of the optimal number of peaks to discriminate species (from the pi0 parameter)
OptiPeaks$nb_to_sel

## discriminant mass-over-chage values estimated using a 5 per cent false discovery rate
OptiPeaks$sel_moz

## p-values and adjusted p-values estimated for all the tested mass-over-charge values
OptiPeaks$ap$adjp


</code></pre>

<hr>
<h2 id='SignalProcessing'>Function performing post acquisition signal processing</h2><span id='topic+SignalProcessing'></span>

<h3>Description</h3>

<p>This function performs post acquisition signal processing for <code>list</code> of <code>MassSpectrum</code> objects using commonly used methods : transform intensities (&quot;sqrt&quot;), smoothing (&quot;Wavelet&quot;), remove baseline (&quot;SNIP&quot;), calibrate intensities (&quot;TIC&quot;) and align spectra. Methods used are selected from the <code>MALDIquant</code> and <code>MALDIrppa</code> R packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
SignalProcessing(x,
                 transformIntensity_method = "sqrt",
                 smoothing_method = "Wavelet",
                 removeBaseline_method = "SNIP",
                 removeBaseline_iterations = 25,
                 calibrateIntensity_method = "TIC",
                 alignSpectra_NoiseMethod = "MAD",
                 alignSpectra_method = "lowess",
                 alignSpectra_halfWs = 11,
                 alignSpectra_SN = 3,
                 tolerance_align = 0.002,
                 referenceSpectra = NULL,
                 minFrequency= 0.5,
                 binPeaks_method = "strict",
                 keepReferenceSpectra = FALSE,
                 ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SignalProcessing_+3A_x">x</code></td>
<td>
<p>a <code>list</code> of <code>MassSpectrum</code> objects (see <code>MALDIquant</code> R package).</p>
</td></tr>
<tr><td><code id="SignalProcessing_+3A_transformintensity_method">transformIntensity_method</code></td>
<td>
<p>a <code>character</code> indicating the method used to transform intensities: <code>"sqrt"</code> by default. This function can be replaced by another mathematical function such as <code>"log"</code>.</p>
</td></tr>
<tr><td><code id="SignalProcessing_+3A_smoothing_method">smoothing_method</code></td>
<td>
<p>a <code>character</code> indicating the smoothing methods used. By default, it performs undecimated <code>Wavelet</code> transform (UDWT) for <code>list</code> of <code>MassSpectrum</code> objects. This Smoothing method can be remplaced by <code>"SavitzkyGolay"</code> or <code>"MovingAverage"</code>. See <code>wavSmoothing</code> in the <code>MALDIrppa</code> R package for details.</p>
</td></tr>
<tr><td><code id="SignalProcessing_+3A_removebaseline_method">removeBaseline_method</code></td>
<td>
<p>a <code>character</code> indicating the method used to remove baseline. It uses <code>"SNIP"</code> method for <code>list</code> of <code>MassSpectrum</code> objects. This baseline estimation method can be remplaced <code>"TopHat"</code>, <code>"ConvexHull"</code> or <code>"median"</code>. See <code>removeBaseline-methods</code> of the <code>MALDIquant</code> R package for details.</p>
</td></tr>
<tr><td><code id="SignalProcessing_+3A_removebaseline_iterations">removeBaseline_iterations</code></td>
<td>
<p>a <code>numeric</code> value indicting the number of iterations to remove baseline (by default = <code>25</code>). See <code>removeBaseline-methods</code> of the <code>MALDIquant</code> R package for details.</p>
</td></tr>
<tr><td><code id="SignalProcessing_+3A_calibrateintensity_method">calibrateIntensity_method</code></td>
<td>
<p>a <code>character</code> indicating the intensities calibration method used (<code>"TIC"</code> method by default).  This calibration method can be remplaced by <code>"PQN"</code> or &quot;median&quot;.See <code>calibrateIntensity-methods</code> of the <code>MALDIquant</code> R package for details.</p>
</td></tr>
<tr><td><code id="SignalProcessing_+3A_alignspectra_noisemethod">alignSpectra_NoiseMethod</code></td>
<td>
<p>a <code>character</code> indicating the noise estimation method. It uses <code>"MAD"</code> method for <code>list</code> of <code>MassSpectrum</code> objects. This noise estimation method estimation method can be remplaced <code>"SuperSmoother"</code>. See <code>estimateNoise-methods</code> of the <code>MALDIquant</code> R package for details.</p>
</td></tr>
<tr><td><code id="SignalProcessing_+3A_alignspectra_method">alignSpectra_method</code></td>
<td>
<p>a <code>character</code> indicating the warping method. It uses <code>"lowess"</code> method for <code>list</code> of <code>MassSpectrum</code> objects. This warping method method can be remplaced <code>"linear"</code>, <code>"quadratic"</code> or <code>"cubic"</code> . See <code>determineWarpingFunctions</code> of the <code>MALDIquant</code> R package for details.</p>
</td></tr>
<tr><td><code id="SignalProcessing_+3A_alignspectra_halfws">alignSpectra_halfWs</code></td>
<td>
<p>a <code>numeric</code> value half window size to detect peaks (by default = <code>11</code>). See <code>detectPeaks-methods</code> of the <code>MALDIquant</code> R package for details.</p>
</td></tr>
<tr><td><code id="SignalProcessing_+3A_alignspectra_sn">alignSpectra_SN</code></td>
<td>
<p>a <code>numeric</code> value indicating the signal-to-noise ratio used to detect peaks (by default = <code>3</code>). See <code>detectPeaks-methods</code> of the <code>MALDIquant</code> R package for details.</p>
</td></tr>
<tr><td><code id="SignalProcessing_+3A_tolerance_align">tolerance_align</code></td>
<td>
<p>a <code>numeric</code> value indicating a maximal relative deviation of a peak position (mass) to be considered as identical in ppm (by default = <code>0.002</code>). See <code>determineWarpingFunctions</code> of the <code>MALDIquant</code> R package for details.</p>
</td></tr>
<tr><td><code id="SignalProcessing_+3A_referencespectra">referenceSpectra</code></td>
<td>
<p>a <code>MassPeaks</code> reference spectrum for alignment of the sample(s). If this reference spectrum is not provided, a reference spectrum is created using the <code>minFrequency</code> and <code>binPeaks_method</code> arguments. See <code>referencePeaks</code> of the <code>MALDIquant</code> R package for details.</p>
</td></tr>
<tr><td><code id="SignalProcessing_+3A_minfrequency">minFrequency</code></td>
<td>
<p>a <code>numeric</code> minimum frequency for each peak over all analyzed spectra (by default = <code>0.5</code>) for the creation of the reference spectrum. See <code>referencePeaks</code> of the <code>MALDIquant</code> R package for details.</p>
</td></tr>
<tr><td><code id="SignalProcessing_+3A_binpeaks_method">binPeaks_method</code></td>
<td>
<p>a <code>character</code> indicating the method used to equalize masses for similar peaks for the creation of the reference spectrum. The <code>"strict"</code> method is used by default corresponding to a unique peak per bin from the same sample. This method can be remplaced by <code>"relaxed"</code> corresponding to multiple peaks per bin from the same sample. See <code>binPeaks</code> of the <code>MALDIquant</code> R package for more details.</p>
</td></tr>
<tr><td><code id="SignalProcessing_+3A_keepreferencespectra">keepReferenceSpectra</code></td>
<td>
<p>a <code>logical</code> value indicating if the created reference spectrum is returned by the function (<code>FALSE</code>, default).</p>
</td></tr>
<tr><td><code id="SignalProcessing_+3A_...">...</code></td>
<td>
<p>other arguments from <code>MALDIrppa</code> packages for the <code>wavSmoothing</code> function such as <code>n.levels</code> (corresponding to the depth of the decomposiion for the wavelet function). See <code>wavSmoothing</code> of the <code>MALDIrppa</code> R package for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>SignalProcessing</code> function provides an analysis pipeline for <code>MassSpectrum</code> objects including intensity transformation, smoothing, removing baseline.
</p>
<p>The <code>Wavelet</code> method relies on the <code>wavShrink</code> function of the <code>wmtsa</code> package and its dependencies (now archived by CRAN). The original C code by William Constantine and Keith L. Davidson, in turn including copyrighted routines by Insightful Corp., has been revised and included into <code>MALDIrppa</code> for the method to work.
</p>
<p>All the methods used for <code>SignalProcessing</code> functions are selected from <code>MALDIquant</code> and <code>MALDIrppa</code> packages.
</p>


<h3>Value</h3>

<p>A list of modified <code>MassSpectrum</code> objects (see <code>MALDIquant</code> R package) according to chosen arguments. If the argument <code>referenceSpectra</code> is not completed and the argument <code>keepReferenceSpectra</code> is <code>TRUE</code>, a list containing the <code>MassSpectrum</code> objects modified named <code>"spectra"</code> and the created reference spectrum named <code>"RefS"</code> is returned.</p>


<h3>References</h3>

<p>Gibb S, Strimmer K. MALDIquant: a versatile R package for the analysis of mass spectrometry data. Bioinformatics. 2012 Sep 1;28(17):2270-1. doi: <a href="https://doi.org/10.1093/bioinformatics/bts447">10.1093/bioinformatics/bts447</a>. Epub 2012 Jul 12. PMID: 22796955.
</p>
<p>Javier Palarea-Albaladejo, Kevin Mclean, Frank Wright, David G E Smith, MALDIrppa: quality control and robust analysis for mass spectrometry data, Bioinformatics, Volume 34, Issue 3, 01 February 2018, Pages 522 - 523, doi: <a href="https://doi.org/10.1093/bioinformatics/btx628">10.1093/bioinformatics/btx628</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library("MALDIquant")
library("MSclassifR")

## Load mass spectra
data("CitrobacterRKIspectra", package = "MSclassifR")

# plot first unprocessed mass spectrum
PlotSpectra(SpectralData=CitrobacterRKIspectra[[1]], col_spec="blue")

## spectral treatment
spectra &lt;- SignalProcessing(CitrobacterRKIspectra,
                            transformIntensity_method = "sqrt",
                            smoothing_method = "Wavelet",
                            removeBaseline_method = "SNIP",
                            removeBaseline_iterations = 25,
                            calibrateIntensity_method = "TIC",
                            alignSpectra_Method = "MAD",
                            alignSpectra_halfWs = 11,
                            alignSpectra_SN = 3,
                            tolerance_align = 0.002)


# plot first processed mass spectrum
PlotSpectra(SpectralData=spectra[[1]], col_spec="blue")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
