<!DOCTYPE html><html lang="en"><head><title>Help for package MJMbamlss</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MJMbamlss}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#attach_wfpc'><p>Attach Weighted Functional Principal Components to the Data</p></a></li>
<li><a href='#fpca'><p>Functional principal components analysis by smoothed covariance</p></a></li>
<li><a href='#MFPCA_cov'><p>Function to calculate the multivariate FPCA for a given covariance matrix and</p>
univariate basis functions</a></li>
<li><a href='#mjm_bamlss'><p>Family for Flexible Multivariate Joint Model</p></a></li>
<li><a href='#MJM_predict'><p>Prediction of MJM model</p></a></li>
<li><a href='#pbc_subset'><p>PBC Subset</p></a></li>
<li><a href='#Predict.matrix.unc_pcre.random.effect'><p>mgcv-style constructor for prediction of PC-basis functional random effects</p></a></li>
<li><a href='#preproc_MFPCA'><p>Preprocessing step to create MFPCA object</p></a></li>
<li><a href='#sim_bamlss_predict'><p>Simulation Helper Function - Predict the Results for bamlss-Models</p></a></li>
<li><a href='#sim_jmb_predict'><p>Simulation Helper Function - Predict the Results for JMbayes-Models</p></a></li>
<li><a href='#sim_jmbamlss_eval'><p>Simulation Helper Function - Evaluate the Simulation for JMbamlss Setting</p></a></li>
<li><a href='#sim_jmbayes_eval'><p>Simulation Helper Function - Evaluate the Simulation for JMbayes Setting</p></a></li>
<li><a href='#simMultiJM'><p>New Simulation Function For Multivariate JMs Based On FPCs</p></a></li>
<li><a href='#smooth.construct.unc_pcre.smooth.spec'><p>mgcv-style constructor for PC-basis functional random effects (no constraint)</p></a></li>
<li><a href='#survint_C'><p>Survival Integral</p></a></li>
<li><a href='#varbinq'><p>Flexible Joint Models for Multivariate Longitudinal and Time-to-Event Data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multivariate Joint Models with 'bamlss'</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Multivariate joint models of longitudinal and time-to-event data based on functional principal components implemented with 'bamlss'. Implementation for Volkmann, Umlauf, Greven (2023) &lt;<a href="https://doi.org/10.48550/arXiv.2311.06409">doi:10.48550/arXiv.2311.06409</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5), mgcv, bamlss</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, funData, statmod, mvtnorm, zoo, coda, gamm4, Matrix,
refund, utils, fdapace, sparseFLMM, MFPCA, foreach</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), splines, tidyverse</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-27 15:29:07 UTC; alex</td>
</tr>
<tr>
<td>Author:</td>
<td>Nikolaus Umlauf <a href="https://orcid.org/0000-0003-2160-9803"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Alexander Volkmann [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alexander Volkmann &lt;alexander.volkmann@hu-berlin.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-27 17:30:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='attach_wfpc'>Attach Weighted Functional Principal Components to the Data</h2><span id='topic+attach_wfpc'></span>

<h3>Description</h3>

<p>Attach Weighted Functional Principal Components to the Data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>attach_wfpc(
  mfpca,
  data,
  n = NULL,
  obstime = "obstime",
  marker = "marker",
  eval_weight = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="attach_wfpc_+3A_mfpca">mfpca</code></td>
<td>
<p>MFPCA object from which to extract the weighted FPCS.</p>
</td></tr>
<tr><td><code id="attach_wfpc_+3A_data">data</code></td>
<td>
<p>Data set to which the weighted FPCS are to be attached.</p>
</td></tr>
<tr><td><code id="attach_wfpc_+3A_n">n</code></td>
<td>
<p>Number of FPCs to attach. Defaults to NULL which corresponds to all
FPCs in mfpc.</p>
</td></tr>
<tr><td><code id="attach_wfpc_+3A_obstime">obstime</code></td>
<td>
<p>Name of the time variable in data set at which points to
evaluate.</p>
</td></tr>
<tr><td><code id="attach_wfpc_+3A_marker">marker</code></td>
<td>
<p>Name of the marker variable in the data set which separates the
data.</p>
</td></tr>
<tr><td><code id="attach_wfpc_+3A_eval_weight">eval_weight</code></td>
<td>
<p>Weight the FPC by the square root of its eigenvalue (then
variance comparable throughout all FPCs). Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data set supplied as argument <code>data</code> with additional columns
corresponding to the evaluations of the MFPC basis.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Small example based on subset of PBC data
data(pbc_subset)

# Estimate MFPC basis and attach to data
mfpca &lt;- preproc_MFPCA(pbc_subset, uni_mean = paste0(
    "logy ~ 1 + sex + drug + s(obstime, k = 5, bs = 'ps') + ",
    "s(age, k = 5, bs = 'ps')"),
    pve_uni = 0.99, nbasis = 5, weights = TRUE, save_uniFPCA = TRUE)
pbc_subset &lt;- attach_wfpc(mfpca, pbc_subset, n = 2)
</code></pre>

<hr>
<h2 id='fpca'>Functional principal components analysis by smoothed covariance</h2><span id='topic+fpca'></span>

<h3>Description</h3>

<p>Decomposes functional observations using functional principal components
analysis. A mixed model framework is used to estimate scores and obtain
variance estimates. This function is a slightly adapted copy of the
<code><a href="refund.html#topic+fpca.sc">fpca.sc</a></code> function in package <code>refund</code>
(version 0.1-30).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fpca(
  Y = NULL,
  ydata = NULL,
  Y.pred = NULL,
  argvals = NULL,
  argvals_obs = FALSE,
  argvals_pred = seq(0, 1, by = 0.01),
  random.int = FALSE,
  nbasis = 10,
  nbasis_cov = nbasis,
  bs_cov = "symm",
  pve = 0.99,
  npc = NULL,
  useSymm = FALSE,
  makePD = FALSE,
  center = TRUE,
  cov.est.method = 1,
  integration = "trapezoidal"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fpca_+3A_y">Y</code>, <code id="fpca_+3A_ydata">ydata</code></td>
<td>
<p>the user must supply either <code>Y</code>, a matrix of functions
observed on a regular grid, or a data frame <code>ydata</code> representing
irregularly observed functions. See Details.</p>
</td></tr>
<tr><td><code id="fpca_+3A_y.pred">Y.pred</code></td>
<td>
<p>if desired, a matrix of functions to be approximated using
the FPC decomposition.</p>
</td></tr>
<tr><td><code id="fpca_+3A_argvals">argvals</code></td>
<td>
<p>the argument values of the function evaluations in <code>Y</code>,
defaults to a equidistant grid from 0 to 1.</p>
</td></tr>
<tr><td><code id="fpca_+3A_argvals_obs">argvals_obs</code></td>
<td>
<p>Should the timepoints of the original observations be
used to evaluate the FPCs. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="fpca_+3A_argvals_pred">argvals_pred</code></td>
<td>
<p>Vector of timepoints on which to evaluate the FPCs.
Defaults to a sequence from 0 to 1.</p>
</td></tr>
<tr><td><code id="fpca_+3A_random.int">random.int</code></td>
<td>
<p>If <code>TRUE</code>, the mean is estimated by
<code><a href="gamm4.html#topic+gamm4">gamm4</a></code> with random intercepts. If <code>FALSE</code> (the
default), the mean is estimated by <code><a href="mgcv.html#topic+gam">gam</a></code> treating all the
data as independent.</p>
</td></tr>
<tr><td><code id="fpca_+3A_nbasis">nbasis</code></td>
<td>
<p>number of B-spline basis functions used for estimation of the
mean function.</p>
</td></tr>
<tr><td><code id="fpca_+3A_nbasis_cov">nbasis_cov</code></td>
<td>
<p>number of basis functions used for the bivariate
smoothing of the covariance surface.</p>
</td></tr>
<tr><td><code id="fpca_+3A_bs_cov">bs_cov</code></td>
<td>
<p>type of spline for the bivariate smoothing of the covariance
surface. Default is symmetric fast covariance smoothing proposed by
Cederbaum.</p>
</td></tr>
<tr><td><code id="fpca_+3A_pve">pve</code></td>
<td>
<p>proportion of variance explained: used to choose the number of
principal components.</p>
</td></tr>
<tr><td><code id="fpca_+3A_npc">npc</code></td>
<td>
<p>prespecified value for the number of principal components (if
given, this overrides <code>pve</code>).</p>
</td></tr>
<tr><td><code id="fpca_+3A_usesymm">useSymm</code></td>
<td>
<p>logical, indicating whether to smooth only the upper
triangular part of the naive covariance (when <code>cov.est.method==2</code>).
This can save computation time for large data sets, and allows for
covariance surfaces that are very peaked on the diagonal.</p>
</td></tr>
<tr><td><code id="fpca_+3A_makepd">makePD</code></td>
<td>
<p>logical: should positive definiteness be enforced for the
covariance surface estimate?</p>
</td></tr>
<tr><td><code id="fpca_+3A_center">center</code></td>
<td>
<p>logical: should an estimated mean function be subtracted from
<code>Y</code>? Set to <code>FALSE</code> if you have already demeaned the data using
your favorite mean function estimate.</p>
</td></tr>
<tr><td><code id="fpca_+3A_cov.est.method">cov.est.method</code></td>
<td>
<p>covariance estimation method. If set to <code>1</code>
(the default), a one-step method that applies a bivariate smooth to the
<code class="reqn">y(s_1)y(s_2)</code> values. This can be very slow. If set to <code>2</code>, a two-step
method that obtains a naive covariance estimate which is then smoothed.</p>
</td></tr>
<tr><td><code id="fpca_+3A_integration">integration</code></td>
<td>
<p>quadrature method for numerical integration; only
<code>'trapezoidal'</code> is currently supported.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes a FPC decomposition for a set of observed curves,
which may be sparsely observed and/or measured with error. A mixed model
framework is used to estimate curve-specific scores and variances.
</p>
<p>FPCA via kernel smoothing of the covariance function, with the diagonal
treated separately, was proposed in Staniswalis and Lee (1998) and much
extended by Yao et al. (2005), who introduced the 'PACE' method.
<code>fpca.sc</code> uses penalized splines to smooth the covariance function, as
developed by Di et al. (2009) and Goldsmith et al. (2013). This
implementation uses REML and Cederbaum et al. (2018) for smoothing the
covariance function.
</p>
<p>The functional data must be supplied as either </p>
 <ul>
<li><p> an <code class="reqn">n
\times d</code> matrix <code>Y</code>, each row of which is one functional observation,
with missing values allowed; or </p>
</li>
<li><p> a data frame <code>ydata</code>, with
columns <code>'.id'</code> (which curve the point belongs to, say <code class="reqn">i</code>),
<code>'.index'</code> (function argument such as time point <code class="reqn">t</code>), and
<code>'.value'</code> (observed function value <code class="reqn">Y_i(t)</code>).</p>
</li></ul>



<h3>Value</h3>

<p>An object of class <code>fpca</code> containing:
</p>
<table role = "presentation">
<tr><td><code>Yhat</code></td>
<td>
<p>FPC approximation (projection onto leading components)
of <code>Y.pred</code> if specified, or else of <code>Y</code>.</p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p>the observed data</p>
</td></tr><tr><td><code>scores</code></td>
<td>
<p><code class="reqn">n
\times npc</code> matrix of estimated FPC scores.</p>
</td></tr> <tr><td><code>mu</code></td>
<td>
<p>estimated mean
function (or a vector of zeroes if <code>center==FALSE</code>).</p>
</td></tr> <tr><td><code>efunctions</code></td>
<td>
<p><code class="reqn">d \times npc</code> matrix of estimated eigenfunctions of the functional
covariance, i.e., the FPC basis functions.</p>
</td></tr> <tr><td><code>evalues</code></td>
<td>
<p>estimated
eigenvalues of the covariance operator, i.e., variances of FPC scores.</p>
</td></tr>
<tr><td><code>npc</code></td>
<td>
<p>number of FPCs: either the supplied <code>npc</code>, or the minimum
number of basis functions needed to explain proportion <code>pve</code> of the
variance in the observed curves.</p>
</td></tr> <tr><td><code>argvals</code></td>
<td>
<p>argument values of
eigenfunction evaluations</p>
</td></tr> <tr><td><code>sigma2</code></td>
<td>
<p>estimated measurement error
variance.</p>
</td></tr> <tr><td><code>diag.var</code></td>
<td>
<p>diagonal elements of the covariance matrices for
each estimated curve.</p>
</td></tr> <tr><td><code>VarMats</code></td>
<td>
<p>a list containing the estimated
covariance matrices for each curve in <code>Y</code>.</p>
</td></tr> <tr><td><code>crit.val</code></td>
<td>
<p>estimated
critical values for constructing simultaneous confidence intervals.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jeff Goldsmith <a href="mailto:jeff.goldsmith@columbia.edu">jeff.goldsmith@columbia.edu</a>, Sonja Greven
<a href="mailto:sonja.greven@stat.uni-muenchen.de">sonja.greven@stat.uni-muenchen.de</a>, Lan Huo
<a href="mailto:Lan.Huo@nyumc.org">Lan.Huo@nyumc.org</a>, Lei Huang <a href="mailto:huangracer@gmail.com">huangracer@gmail.com</a>, and
Philip Reiss <a href="mailto:phil.reiss@nyumc.org">phil.reiss@nyumc.org</a>, Alexander Volkmann
</p>


<h3>References</h3>

<p>Cederbaum, J. Scheipl, F. and Greven, S. (2018). Fast symmetric
additive covariance smoothing. <em>Computational Statistics &amp; Data
Analysis</em>, 120, 25&ndash;41.
</p>
<p>Di, C., Crainiceanu, C., Caffo, B., and Punjabi, N. (2009).
Multilevel functional principal component analysis. <em>Annals of Applied
Statistics</em>, 3, 458&ndash;488.
</p>
<p>Goldsmith, J., Greven, S., and Crainiceanu, C. (2013). Corrected confidence
bands for functional data using principal components. <em>Biometrics</em>,
69(1), 41&ndash;51.
</p>
<p>Staniswalis, J. G., and Lee, J. J. (1998). Nonparametric regression
analysis of longitudinal data. <em>Journal of the American Statistical
Association</em>, 93, 1403&ndash;1418.
</p>
<p>Yao, F., Mueller, H.-G., and Wang, J.-L. (2005). Functional data analysis
for sparse longitudinal data. <em>Journal of the American Statistical
Association</em>, 100, 577&ndash;590.
</p>

<hr>
<h2 id='MFPCA_cov'>Function to calculate the multivariate FPCA for a given covariance matrix and
univariate basis functions</h2><span id='topic+MFPCA_cov'></span>

<h3>Description</h3>

<p>Function to calculate the multivariate FPCA for a given covariance matrix and
univariate basis functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MFPCA_cov(cov, basis_funs, scores = NULL, weights = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MFPCA_cov_+3A_cov">cov</code></td>
<td>
<p>Covariance matrix of the basis functions coefficients.</p>
</td></tr>
<tr><td><code id="MFPCA_cov_+3A_basis_funs">basis_funs</code></td>
<td>
<p>List with basis functions on each dimension. The basis
functions are funData objects</p>
</td></tr>
<tr><td><code id="MFPCA_cov_+3A_scores">scores</code></td>
<td>
<p>Matrix (n rows, B columns) containing the basis functions
coefficients. Defaults to NULL which does not calculate the multivariate
scores.</p>
</td></tr>
<tr><td><code id="MFPCA_cov_+3A_weights">weights</code></td>
<td>
<p>Vector of weights, defaults to 1 for each element</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List mimicking an <code>MFPCAfit</code> object containing the following
components:
</p>

<dl>
<dt>values</dt><dd><p>A vector of eigenvalues.</p>
</dd>
<dt>functions</dt><dd><p>A <code>multiFunData</code> object containing the multivariate
functional principal components.</p>
</dd>
<dt>scores</dt><dd><p>A matrix containing the scores (if applicable).</p>
</dd>
<dt>vectors</dt><dd><p>A matrix representing the eigenvectors associated with the
combined univaraite score vectors.</p>
</dd>
<dt>normFactors</dt><dd><p>The normalizing factors used for calculating the
multivariate eigenfunctions and scores.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>library(funData)
# Covariance matrix for the data generation in simulation scenario I
auto &lt;- matrix(c(0.08, -0.07, -0.07, 0.9), ncol = 2)
cross &lt;- matrix(rep(0.03, 4), ncol = 2)
cor &lt;- matrix(c(0, 1, 0.75, 0.5, 0, 0,
                1, 0, 1, 0.75, 0.5, 0,
                0.75, 1, 0, 1, 0.75, 0.5,
                0.5, 0.75, 1, 0, 1, 0.75,
                0, 0.5, 0.75, 1, 0, 1,
                0, 0, 0.5, 0.75, 1, 0),
               ncol = 6)
cov &lt;- kronecker(cor, cross) + kronecker(diag(c(1, 1.2, 1.4, 1.6, 1.8, 2)),
                                         auto)
# Basis functions on each dimension
seq1 &lt;- seq(0, 1, by = 0.01)
b_funs &lt;- rep(list(funData(argvals = seq1,
              X = matrix(c(rep(1, length(seq1)), seq1),
              byrow = TRUE, ncol = length(seq1)))), 6)
# Prepare objects for the model on different data sets
mfpca_tru &lt;- MFPCA_cov(cov = cov, basis_funs = b_funs)
</code></pre>

<hr>
<h2 id='mjm_bamlss'>Family for Flexible Multivariate Joint Model</h2><span id='topic+mjm_bamlss'></span>

<h3>Description</h3>

<p>This function specifies the different predictors and link functions as well
as the corresponding transform/updating/sampling functions as well as the
predict function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mjm_bamlss(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mjm_bamlss_+3A_...">...</code></td>
<td>
<p>All arguments are actually hard coded as needed by the
implementation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Family object to fit a flexible additive joint model for multivariate
longitudinal and survival data under a Bayesian approach using multivariate
functional principal components as presented in Volkmann, Umlauf, Greven
(2023).
</p>


<h3>Value</h3>

<p>An object of class <code>family.bamlss</code>.
</p>


<h3>References</h3>

<p>Volkmann, A., Umlauf, N., Greven, S. (2023). Flexible joint
models for multivariate longitudinal and time-to-event data using
multivariate functional principal components. &lt;arXiv:2311.06409&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mgcv)
library(bamlss)
data(pbc_subset)
mfpca &lt;- preproc_MFPCA(pbc_subset, uni_mean = paste0(
  "logy ~ 1 + sex + drug + s(obstime, k = 5, bs = 'ps') + ",
  "s(age, k = 5, bs = 'ps')"),
  pve_uni = 0.99, nbasis = 5, weights = TRUE, save_uniFPCA = TRUE)
pbc_subset &lt;- attach_wfpc(mfpca, pbc_subset, n = 2)
mfpca_list &lt;- list(
  list(functions = funData::extractObs(mfpca$functions, 1),
       values = mfpca$values[1]),
  list(functions = funData::extractObs(mfpca$functions, 2),
       values = mfpca$values[2]))

# Model formula
f &lt;- list(
  Surv2(survtime, event, obs = logy) ~ -1 +
    s(survtime, k = 5, bs = "ps", xt = list("scale" = FALSE)),
  gamma ~ 1 + sex + drug + s(age, k = 5, bs = 'ps'),
  mu ~ -1 + marker + sex:marker + drug:marker +
    s(obstime, by = marker, xt = list("scale" = FALSE), k = 5, bs = "ps") +
    s(age, by = marker, xt = list("scale" = FALSE), k = 5, bs = "ps") +
    s(id, fpc.1, bs = "unc_pcre",
      xt = list("mfpc" = mfpca_list[[1]], scale = "FALSE")) +
    s(id, fpc.2, bs = "unc_pcre",
      xt = list("mfpc" = mfpca_list[[2]], scale = "FALSE")),
  sigma ~ -1 + marker,
  alpha ~ -1 + marker
)

# Model fit
b &lt;- bamlss(f, family = mjm_bamlss, data = pbc_subset,
            timevar = "obstime", maxit = 15, n.iter = 15, burnin = 2,
            thin = 2)
</code></pre>

<hr>
<h2 id='MJM_predict'>Prediction of MJM model</h2><span id='topic+MJM_predict'></span>

<h3>Description</h3>

<p>Note: Writing a predict function is a bit tricky.
For longitudinal prediction, if subject specific predictions are wanted, then
the PCRE terms must be attached to newdata and already evaluated.
If the model uses standardized survival matrices, the different linear
predictors should be predicted using different data sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MJM_predict(
  object,
  newdata,
  type = c("link", "parameter", "probabilities", "cumhaz"),
  dt,
  id,
  FUN = function(x) {
     mean(x, na.rm = TRUE)
 },
  subdivisions = 7,
  cores = NULL,
  chunks = 1,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MJM_predict_+3A_object">object</code></td>
<td>
<p>bamlss-model object to be predicted.</p>
</td></tr>
<tr><td><code id="MJM_predict_+3A_newdata">newdata</code></td>
<td>
<p>Dataset for which to create predictions. Not needed for
conditional survival probabilities.</p>
</td></tr>
<tr><td><code id="MJM_predict_+3A_type">type</code></td>
<td>
<p>Character string indicating which type of predictions to compute.
<code>link</code> returns estimates for all predictors with the respective link
functions applied, <code>"parameter"</code> returns the estimates for all
pedictors, <code>"probabilities"</code> returns the survival probabilities
conditional on the survival up to the last longitudinal measurement, and
<code>"cumhaz"</code> return the cumulative hazard up to the survival time or for
a time window after the last longitudinal measurement. If <code>type</code> is
set to <code>"loglik"</code>, the log-likelihood of the joint model is returned.
Note that types <code>"probabilities"</code> and <code>"cumhaz"</code> are not yet
implemented.</p>
</td></tr>
<tr><td><code id="MJM_predict_+3A_dt">dt</code></td>
<td>
<p>The time window after the last observed measurement for which
predictions should be computed.</p>
</td></tr>
<tr><td><code id="MJM_predict_+3A_id">id</code></td>
<td>
<p>Integer or character, that specifies the individual for which the
plot should be created.</p>
</td></tr>
<tr><td><code id="MJM_predict_+3A_fun">FUN</code></td>
<td>
<p>A function that should be applied on the samples of predictors or
parameters, depending on argument <code>type</code>.</p>
</td></tr>
<tr><td><code id="MJM_predict_+3A_subdivisions">subdivisions</code></td>
<td>
<p>Number of Gaussian quadrature points for survival
integral calculation.</p>
</td></tr>
<tr><td><code id="MJM_predict_+3A_cores">cores</code></td>
<td>
<p>Specifies the number of cores that should be used for
prediction. Note that this functionality is based on the
<code><a href="parallel.html#topic+parallel">parallel</a></code> package.</p>
</td></tr>
<tr><td><code id="MJM_predict_+3A_chunks">chunks</code></td>
<td>
<p>Should computations be split into <code>chunks</code>? Prediction is
then processed sequentially.</p>
</td></tr>
<tr><td><code id="MJM_predict_+3A_verbose">verbose</code></td>
<td>
<p>Print information during runtime of the algorithm.</p>
</td></tr>
<tr><td><code id="MJM_predict_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>

<hr>
<h2 id='pbc_subset'>PBC Subset</h2><span id='topic+pbc_subset'></span>

<h3>Description</h3>

<p>A subset of the pbc data provided by package <code>JMbayes2</code> used only to
illustrate the functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pbc_subset
</code></pre>


<h3>Format</h3>

<p>## 'pbc_subset'
A data frame with 336 observations and 10 columns:
</p>

<dl>
<dt>id</dt><dd><p>Subject id.</p>
</dd>
<dt>survtime</dt><dd><p>Survival time of composite endpoint.</p>
</dd>
<dt>event</dt><dd><p>Composite endpoint.</p>
</dd>
<dt>sex</dt><dd><p>Male or female.</p>
</dd>
<dt>drug</dt><dd><p>Placebo or D-penicil.</p>
</dd>
<dt>age</dt><dd><p>Age.</p>
</dd>
<dt>marker</dt><dd><p>Name of longitudinal biomarker (albumin, SerBilir, serChol,
SGOT)</p>
</dd>
<dt>obstime</dt><dd><p>Longitudinal time.</p>
</dd>
<dt>y</dt><dd><p>Longitudinal outcome value.</p>
</dd>
<dt>logy</dt><dd><p>Log-transformed longitudinal outcome value.</p>
</dd>
</dl>



<h3>Source</h3>

<p>&lt;https://cran.r-project.org/web/packages/JMbayes2/index.html&gt;
</p>

<hr>
<h2 id='Predict.matrix.unc_pcre.random.effect'>mgcv-style constructor for prediction of PC-basis functional random effects</h2><span id='topic+Predict.matrix.unc_pcre.random.effect'></span>

<h3>Description</h3>

<p>This predictor function uses time-information saved in the object. This is
handled within the bamlss-transform function, so this function is not
exported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'unc_pcre.random.effect'
Predict.matrix(object, data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Predict.matrix.unc_pcre.random.effect_+3A_object">object</code></td>
<td>
<p>a smooth specification object, see
<code><a href="mgcv.html#topic+smooth.construct">smooth.construct</a></code></p>
</td></tr>
<tr><td><code id="Predict.matrix.unc_pcre.random.effect_+3A_data">data</code></td>
<td>
<p>see <code><a href="mgcv.html#topic+smooth.construct">smooth.construct</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>design matrix for PC-based functional random effects
</p>


<h3>Author(s)</h3>

<p>Alexander Volkmann, adapted from 'Predict.matrix.pcre.random.effect
by F. Scheipl (adapted from 'Predict.matrix.random.effect' by S.N. Wood).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pbc_subset)
mfpca &lt;- preproc_MFPCA(pbc_subset, uni_mean = paste0(
  "logy ~ 1 + sex + drug + s(obstime, k = 5, bs = 'ps') + ",
  "s(age, k = 5, bs = 'ps')"),
  pve_uni = 0.99, nbasis = 5, weights = TRUE, save_uniFPCA = TRUE)
pbc_subset &lt;- attach_wfpc(mfpca, pbc_subset, n = 2)
mfpca_list &lt;- list(
  list(functions = funData::extractObs(mfpca$functions, 1),
       values = mfpca$values[1]),
  list(functions = funData::extractObs(mfpca$functions, 2),
       values = mfpca$values[2]))
sm &lt;- smoothCon(s(id, fpc.1, bs = "unc_pcre",
      xt = list("mfpc" = mfpca_list[[1]], scale = "FALSE")), pbc_subset)[[1]]
sm$timevar &lt;- "obstime"
sm$term &lt;- c(sm$term, "obstime")
pm &lt;- PredictMat(sm, pbc_subset, n = 4*nrow(pbc_subset))
</code></pre>

<hr>
<h2 id='preproc_MFPCA'>Preprocessing step to create MFPCA object</h2><span id='topic+preproc_MFPCA'></span>

<h3>Description</h3>

<p>This function takes the data und uses the residuals of marker-specific
additive models to estimate the covariance structure for a MFPCA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preproc_MFPCA(
  data,
  uni_mean = "y ~ s(obstime) + s(x2)",
  time = "obstime",
  id = "id",
  marker = "marker",
  M = NULL,
  weights = FALSE,
  remove_obs = NULL,
  method = c("fpca", "fpca.sc", "FPCA", "PACE"),
  nbasis = 10,
  nbasis_cov = nbasis,
  bs_cov = "symm",
  npc = NULL,
  fve_uni = 0.99,
  pve_uni = 0.99,
  fit = FALSE,
  max_time = NULL,
  save_uniFPCA = FALSE,
  save_uniGAM = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="preproc_MFPCA_+3A_data">data</code></td>
<td>
<p>Data.frame such as returned by function simMultiJM.</p>
</td></tr>
<tr><td><code id="preproc_MFPCA_+3A_uni_mean">uni_mean</code></td>
<td>
<p>String to crate a formula for the univariate addtive models.</p>
</td></tr>
<tr><td><code id="preproc_MFPCA_+3A_time">time</code></td>
<td>
<p>String giving the name of the longitudinal time variable.</p>
</td></tr>
<tr><td><code id="preproc_MFPCA_+3A_id">id</code></td>
<td>
<p>String giving the name of the identifier.</p>
</td></tr>
<tr><td><code id="preproc_MFPCA_+3A_marker">marker</code></td>
<td>
<p>String giving the name of the longitudinal marker variable.</p>
</td></tr>
<tr><td><code id="preproc_MFPCA_+3A_m">M</code></td>
<td>
<p>Number of mFPCs to compute in the MFPCA. If not supplied, it
defaults to the maximum number of computable mFPCs.</p>
</td></tr>
<tr><td><code id="preproc_MFPCA_+3A_weights">weights</code></td>
<td>
<p>TRUE if inverse sum of univariate eigenvals should be used as
weights in the scalar product of the MFPCA. Defaults to FALSE (weights 1).</p>
</td></tr>
<tr><td><code id="preproc_MFPCA_+3A_remove_obs">remove_obs</code></td>
<td>
<p>Minimal number of observations per individual and marker to
be included in the FPC estimation. Defaults to NULL (all observations). Not
removing observations can lead to problems if the univariate variance
estimate is negative and has to be truncated, then the scores for IDs with
few observations cannot be estimated.</p>
</td></tr>
<tr><td><code id="preproc_MFPCA_+3A_method">method</code></td>
<td>
<p>Which package to use for the univariate FPCA. Either function
adapted function 'fpca', 'FPCA' from package <code>fdapace</code>, 'fpca.sc' from
package <code>refund</code>, or function 'PACE' from package <code>MFPCA</code>.</p>
</td></tr>
<tr><td><code id="preproc_MFPCA_+3A_nbasis">nbasis</code></td>
<td>
<p>Number of B-spline basis functions for mean estimate for
methods fpca, fpca.sc, PACE. For fpca.sc, PACE also bivariate smoothing of
covariance estimate.</p>
</td></tr>
<tr><td><code id="preproc_MFPCA_+3A_nbasis_cov">nbasis_cov</code></td>
<td>
<p>Number of basis functions used for the bivariate
smoothing of the covariance surface for method fpca.</p>
</td></tr>
<tr><td><code id="preproc_MFPCA_+3A_bs_cov">bs_cov</code></td>
<td>
<p>Type of spline for the bivariate smoothing of the covariance
surface for method fpca. Default is symmetric fast covariance smoothing
proposed by Cederbaum.</p>
</td></tr>
<tr><td><code id="preproc_MFPCA_+3A_npc">npc</code></td>
<td>
<p>Number of univariate principal components to use in fpca.sc, PACE.</p>
</td></tr>
<tr><td><code id="preproc_MFPCA_+3A_fve_uni">fve_uni</code></td>
<td>
<p>Fraction of univariate variance explained for method FPCA.</p>
</td></tr>
<tr><td><code id="preproc_MFPCA_+3A_pve_uni">pve_uni</code></td>
<td>
<p>Proportion of univariate variance explained for methods
fpca, fpca.sc, PACE.</p>
</td></tr>
<tr><td><code id="preproc_MFPCA_+3A_fit">fit</code></td>
<td>
<p>MFPCA argument to return a truncated KL fit to the data. Defaults
to FALSE.</p>
</td></tr>
<tr><td><code id="preproc_MFPCA_+3A_max_time">max_time</code></td>
<td>
<p>If supplied, forces the evaluation of the MFPCs up to maxtime.
Only implemented for method = 'fpca'.</p>
</td></tr>
<tr><td><code id="preproc_MFPCA_+3A_save_unifpca">save_uniFPCA</code></td>
<td>
<p>TRUE to attach list of univariate FPCAs as attribute to
output. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="preproc_MFPCA_+3A_save_unigam">save_uniGAM</code></td>
<td>
<p>TRUE to attach list of univariate additive models used to
calculate the residuals. Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>MFPCAfit</code> with additional attributes
depending on the arguments <code>save_uniFPCA</code>, <code>save_uniGAM</code>,
<code>fit</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pbc_subset)
mfpca &lt;- preproc_MFPCA(pbc_subset, uni_mean = paste0(
    "logy ~ 1 + sex + drug + s(obstime, k = 10, bs = 'ps') + ",
    "s(age, k = 10, bs = 'ps')"),
    pve_uni = 0.99, nbasis = 5, weights = TRUE, save_uniFPCA = TRUE)
</code></pre>

<hr>
<h2 id='sim_bamlss_predict'>Simulation Helper Function - Predict the Results for bamlss-Models</h2><span id='topic+sim_bamlss_predict'></span>

<h3>Description</h3>

<p>This function takes all the models listed in a folder and predicts the fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_bamlss_predict(m, wd, model_wd, data_wd, rds = TRUE, old = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_bamlss_predict_+3A_m">m</code></td>
<td>
<p>Vector containing all the file names of the models.</p>
</td></tr>
<tr><td><code id="sim_bamlss_predict_+3A_wd">wd</code></td>
<td>
<p>Path to simulations folder.</p>
</td></tr>
<tr><td><code id="sim_bamlss_predict_+3A_model_wd">model_wd</code></td>
<td>
<p>Simulation setting folder where the models are saved.</p>
</td></tr>
<tr><td><code id="sim_bamlss_predict_+3A_data_wd">data_wd</code></td>
<td>
<p>Simulation data folder.</p>
</td></tr>
<tr><td><code id="sim_bamlss_predict_+3A_rds">rds</code></td>
<td>
<p>Objects are saved as .rds files (for backwards compatibility when
.Rdata files were used). Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="sim_bamlss_predict_+3A_old">old</code></td>
<td>
<p>Simulated data sets before Version 0.0.3 (samples need to be adapted
for standardized survival matrices). Defaults to FALSE.</p>
</td></tr>
</table>

<hr>
<h2 id='sim_jmb_predict'>Simulation Helper Function - Predict the Results for JMbayes-Models</h2><span id='topic+sim_jmb_predict'></span>

<h3>Description</h3>

<p>This function takes all the models listed in a folder and predicts the fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_jmb_predict(m, wd, model_wd, data_wd, rds = TRUE, gamma_timeconst = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_jmb_predict_+3A_m">m</code></td>
<td>
<p>Vector containing all the file names of the models.</p>
</td></tr>
<tr><td><code id="sim_jmb_predict_+3A_wd">wd</code></td>
<td>
<p>Path to simulations folder.</p>
</td></tr>
<tr><td><code id="sim_jmb_predict_+3A_model_wd">model_wd</code></td>
<td>
<p>Simulation setting folder where the models are saved.</p>
</td></tr>
<tr><td><code id="sim_jmb_predict_+3A_data_wd">data_wd</code></td>
<td>
<p>Simulation data folder.</p>
</td></tr>
<tr><td><code id="sim_jmb_predict_+3A_rds">rds</code></td>
<td>
<p>Objects are saved as .rds files (for backwards compatibility when
.Rdata files were used). Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="sim_jmb_predict_+3A_gamma_timeconst">gamma_timeconst</code></td>
<td>
<p>Only implemented for timeconstant gamma predictors. If
FALSE a warning message is returned.</p>
</td></tr>
</table>

<hr>
<h2 id='sim_jmbamlss_eval'>Simulation Helper Function - Evaluate the Simulation for JMbamlss Setting</h2><span id='topic+sim_jmbamlss_eval'></span>

<h3>Description</h3>

<p>This function evaluates the results for a given folder of JMbamlss model
fits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_jmbamlss_eval(wd, model_wd, data_wd, name, rds = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_jmbamlss_eval_+3A_wd">wd</code></td>
<td>
<p>Path to simulations folder.</p>
</td></tr>
<tr><td><code id="sim_jmbamlss_eval_+3A_model_wd">model_wd</code></td>
<td>
<p>Simulation setting folder where the models are saved.</p>
</td></tr>
<tr><td><code id="sim_jmbamlss_eval_+3A_data_wd">data_wd</code></td>
<td>
<p>Simulation data folder.</p>
</td></tr>
<tr><td><code id="sim_jmbamlss_eval_+3A_name">name</code></td>
<td>
<p>Name for description of the simulation setting.</p>
</td></tr>
<tr><td><code id="sim_jmbamlss_eval_+3A_rds">rds</code></td>
<td>
<p>Objects are saved as .rds files (for backwards compatibility when
.Rdata files were used). Defaults to TRUE.</p>
</td></tr>
</table>

<hr>
<h2 id='sim_jmbayes_eval'>Simulation Helper Function - Evaluate the Simulation for JMbayes Setting</h2><span id='topic+sim_jmbayes_eval'></span>

<h3>Description</h3>

<p>This function evaluates the results for a given folder of JMbayes model
fits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_jmbayes_eval(wd, model_wd, data_wd, name, rds = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_jmbayes_eval_+3A_wd">wd</code></td>
<td>
<p>Path to simulations folder.</p>
</td></tr>
<tr><td><code id="sim_jmbayes_eval_+3A_model_wd">model_wd</code></td>
<td>
<p>Simulation setting folder where the models are saved.</p>
</td></tr>
<tr><td><code id="sim_jmbayes_eval_+3A_data_wd">data_wd</code></td>
<td>
<p>Simulation data folder.</p>
</td></tr>
<tr><td><code id="sim_jmbayes_eval_+3A_name">name</code></td>
<td>
<p>Name for description of the simulation setting.</p>
</td></tr>
<tr><td><code id="sim_jmbayes_eval_+3A_rds">rds</code></td>
<td>
<p>Objects are saved as .rds files (for backwards compatibility when
.Rdata files were used). Defaults to TRUE.</p>
</td></tr>
</table>

<hr>
<h2 id='simMultiJM'>New Simulation Function For Multivariate JMs Based On FPCs</h2><span id='topic+simMultiJM'></span>

<h3>Description</h3>

<p>Adapt the structure given by simJM function in bamlss.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simMultiJM(
  nsub = 300,
  times = seq(0, 120, 1),
  probmiss = 0.75,
  max_obs = length(times),
  maxfac = 1.5,
  nmark = 2,
  long_assoc = c("FPC", "splines", "param"),
  M = 6,
  FPC_bases = NULL,
  FPC_evals = NULL,
  mfpc_args = list(type = "split", eFunType = "Poly", ignoreDeg = NULL, eValType =
    "linear", eValScale = 1),
  re_cov_mat = NULL,
  ncovar = 2,
  lambda = function(t, x) {
     1.4 * log((t + 10)/1000)
 },
  gamma = function(x) {
     -1.5 + 0.3 * x[, 1]
 },
  alpha = rep(list(function(t, x) {
     0.3 + 0 * t
 }), nmark),
  mu = rep(list(function(t, x) {
     1.25 + 0.6 * sin(x[, 2]) + (-0.01) * t
 }), nmark),
  sigma = function(t, x) {
     0.3 + 0 * t + I(x$marker == "m2") * 0.2
 },
  tmax = NULL,
  seed = NULL,
  full = FALSE,
  file = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simMultiJM_+3A_nsub">nsub</code></td>
<td>
<p>Number of subjects.</p>
</td></tr>
<tr><td><code id="simMultiJM_+3A_times">times</code></td>
<td>
<p>Vector of time points.</p>
</td></tr>
<tr><td><code id="simMultiJM_+3A_probmiss">probmiss</code></td>
<td>
<p>Probability of missingness.</p>
</td></tr>
<tr><td><code id="simMultiJM_+3A_max_obs">max_obs</code></td>
<td>
<p>Maximal number of observations per individual and marker.
Defaults to no upper limit.</p>
</td></tr>
<tr><td><code id="simMultiJM_+3A_maxfac">maxfac</code></td>
<td>
<p>Factor changing the uniform censoring interval.</p>
</td></tr>
<tr><td><code id="simMultiJM_+3A_nmark">nmark</code></td>
<td>
<p>Number of markers.</p>
</td></tr>
<tr><td><code id="simMultiJM_+3A_long_assoc">long_assoc</code></td>
<td>
<p>Longitudinal association between the markers (Defaults to
&quot;FPC&quot;). If &quot;splines&quot; or &quot;param&quot;, then specify the normal covariance matrix
with argument 're_cov_mat' and include the random effects in argument mu.
If &quot;FPC&quot;, then principal components are used to model the association
structure.</p>
</td></tr>
<tr><td><code id="simMultiJM_+3A_m">M</code></td>
<td>
<p>Number of principal components.</p>
</td></tr>
<tr><td><code id="simMultiJM_+3A_fpc_bases">FPC_bases</code></td>
<td>
<p>FunData object. If supplied, use the contained FPC as basis
for the association structure.</p>
</td></tr>
<tr><td><code id="simMultiJM_+3A_fpc_evals">FPC_evals</code></td>
<td>
<p>Vector of eigenvalues. If supplied, use the provided
eigenvalues for the association structure.</p>
</td></tr>
<tr><td><code id="simMultiJM_+3A_mfpc_args">mfpc_args</code></td>
<td>
<p>List containing the named arguments &quot;type&quot;, &quot;eFunType&quot;,
&quot;ignoreDeg&quot;, &quot;eValType&quot; of function simMultiFunData and &quot;eValScale&quot; for
scaling the eigenvalues.</p>
</td></tr>
<tr><td><code id="simMultiJM_+3A_re_cov_mat">re_cov_mat</code></td>
<td>
<p>If supplied, a covariance matrix to use for drawing the
random effects needed for the association structure.</p>
</td></tr>
<tr><td><code id="simMultiJM_+3A_ncovar">ncovar</code></td>
<td>
<p>Number of covariates.</p>
</td></tr>
<tr><td><code id="simMultiJM_+3A_lambda">lambda</code></td>
<td>
<p>Additive predictor of time-varying survival covariates.</p>
</td></tr>
<tr><td><code id="simMultiJM_+3A_gamma">gamma</code></td>
<td>
<p>Additive predictor of time-constant survival covariates.</p>
</td></tr>
<tr><td><code id="simMultiJM_+3A_alpha">alpha</code></td>
<td>
<p>List of length nmark containing the additive predictors of the
association.</p>
</td></tr>
<tr><td><code id="simMultiJM_+3A_mu">mu</code></td>
<td>
<p>List of length nmark containing the additive predictors of the
longitudinal part.</p>
</td></tr>
<tr><td><code id="simMultiJM_+3A_sigma">sigma</code></td>
<td>
<p>Additive predictor of the variance.</p>
</td></tr>
<tr><td><code id="simMultiJM_+3A_tmax">tmax</code></td>
<td>
<p>Maximal time point of observations.</p>
</td></tr>
<tr><td><code id="simMultiJM_+3A_seed">seed</code></td>
<td>
<p>Seed for reproducibility.</p>
</td></tr>
<tr><td><code id="simMultiJM_+3A_full">full</code></td>
<td>
<p>Create a wide-format data.frame and a short one containing only
survival info.</p>
</td></tr>
<tr><td><code id="simMultiJM_+3A_file">file</code></td>
<td>
<p>Name of the data file the generated data set should be stored
into (e.g., &quot;simdata.RData&quot;) or NULL if the dataset should directly be
returned in R.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>full = TRUE</code> a list of four <code>data.frames</code> is returned:
</p>

<dl>
<dt>data</dt><dd><p>Simulated dataset in long format including all longitudinal
and survival covariates.</p>
</dd>
<dt>data_full</dt><dd><p>Simulated dataset on a grid of fixed time points.</p>
</dd>
<dt>data_hypo</dt><dd><p>Simulated dataset on a grid of fixed time points with
hypothetical longitudinal outcomes after the event.</p>
</dd>
<dt>fpc_base</dt><dd><p>If applicable, include the FPC basis used for simulation.</p>
</dd>
<dt>data_short</dt><dd><p>Convenience output containing only one observation per
subject for easy access to event-times.</p>
</dd>
</dl>

<p>For <code>full = FALSE</code> only the first dataset is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Number of individuals
n &lt;- 15
# Covariance matrix for the data generation
auto &lt;- matrix(c(0.08, -0.07, -0.07, 0.9), ncol = 2)
cross &lt;- matrix(rep(0.03, 4), ncol = 2)
cor &lt;- matrix(c(0, 1, 0.75, 0.5, 0, 0,
                1, 0, 1, 0.75, 0.5, 0,
                0.75, 1, 0, 1, 0.75, 0.5,
                0.5, 0.75, 1, 0, 1, 0.75,
                0, 0.5, 0.75, 1, 0, 1,
                0, 0, 0.5, 0.75, 1, 0),
              ncol = 6)
cov &lt;- kronecker(cor, cross) +
    kronecker(diag(c(1, 1.2, 1.4, 1.6, 1.8, 2)), auto)

# Simulate the data
d_rirs &lt;- simMultiJM(
  nsub = n, times = seq(0, 1, by = 0.01), max_obs = 15, probmiss = 0.75,
  maxfac = 1.75, nmark = 6, long_assoc = "param", M = NULL, FPC_bases = NULL,
  FPC_evals = NULL, mfpc_args = NULL, re_cov_mat = cov, ncovar = 2,
  lambda = function(t, x) {1.37 * t^(0.37)},
  gamma = function(x) {-1.5 + 0.48*x[, 3]},
  alpha = list(function(t, x) {1.5 + 0*t}, function(t, x) {0.6 + 0*t},
               function(t, x) {0.3 + 0*t}, function(t, x) {-0.3 + 0*t},
               function(t, x) {-0.6 + 0*t}, function(t, x) {-1.5 + 0*t}),
  mu = list(function(t, x, r){
    0 + 0.2*t - 0.25*x[, 3] - 0.05*t*x[, 3] + r[, 1] + r[, 2]*t
  }, function(t, x, r){
    0 + 0.2*t - 0.25*x[, 3] - 0.05*t*x[, 3] + r[, 3] + r[, 4]*t
  }, function(t, x, r){
    0 + 0.2*t - 0.25*x[, 3] - 0.05*t*x[, 3] + r[, 5] + r[, 6]*t
  }, function(t, x, r){
    0 + 0.2*t - 0.25*x[, 3] - 0.05*t*x[, 3] + r[, 7] + r[, 8]*t
  }, function(t, x, r){
    0 + 0.2*t - 0.25*x[, 3] - 0.05*t*x[, 3] + r[, 9] + r[, 10]*t
  }, function(t, x, r){
    0 + 0.2*t - 0.25*x[, 3] - 0.05*t*x[, 3] + r[, 11] + r[, 12]*t
  }),
  sigma = function(t, x) {log(0.06) + 0*t}, tmax = NULL, seed = NULL,
  full = TRUE, file = NULL)
</code></pre>

<hr>
<h2 id='smooth.construct.unc_pcre.smooth.spec'>mgcv-style constructor for PC-basis functional random effects (no constraint)</h2><span id='topic+smooth.construct.unc_pcre.smooth.spec'></span>

<h3>Description</h3>

<p>Sets up design matrix for functional random effects based on the PC scores
of the covariance operator of the random effect process. Note that there is
no constraint on the smoother.
See <code><a href="mgcv.html#topic+smooth.construct.re.smooth.spec">smooth.construct.re.smooth.spec</a></code> for more details on
<code>mgcv</code>-style smoother specification
and <code><a href="refund.html#topic+smooth.construct.pcre.smooth.spec">smooth.construct.pcre.smooth.spec</a></code> for the
corresponding <code>refund</code> implementation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'unc_pcre.smooth.spec'
smooth.construct(object, data, knots, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smooth.construct.unc_pcre.smooth.spec_+3A_object">object</code></td>
<td>
<p>a smooth specification object, see
<code><a href="mgcv.html#topic+smooth.construct">smooth.construct</a></code></p>
</td></tr>
<tr><td><code id="smooth.construct.unc_pcre.smooth.spec_+3A_data">data</code></td>
<td>
<p>see <code><a href="mgcv.html#topic+smooth.construct">smooth.construct</a></code>.</p>
</td></tr>
<tr><td><code id="smooth.construct.unc_pcre.smooth.spec_+3A_knots">knots</code></td>
<td>
<p>see <code><a href="mgcv.html#topic+smooth.construct">smooth.construct</a></code>.</p>
</td></tr>
<tr><td><code id="smooth.construct.unc_pcre.smooth.spec_+3A_...">...</code></td>
<td>
<p>see <code><a href="bamlss.html#topic+smooth.construct">smooth.construct</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an internal function as the corresponding smooth object and its
predict method is primarily used within the bamlss call.
</p>


<h3>Value</h3>

<p>An object of class <code>"random.effect"</code>. See
<code><a href="mgcv.html#topic+smooth.construct">smooth.construct</a></code>
for the elements that this object will contain.
</p>


<h3>Author(s)</h3>

<p>Alexander Volkmann; adapted from 'pcre' constructor by F. Scheipl
(adapted from 're' constructor by S.N. Wood).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pbc_subset)
mfpca &lt;- preproc_MFPCA(pbc_subset, uni_mean = paste0(
  "logy ~ 1 + sex + drug + s(obstime, k = 5, bs = 'ps') + ",
  "s(age, k = 5, bs = 'ps')"),
  pve_uni = 0.99, nbasis = 5, weights = TRUE, save_uniFPCA = TRUE)
pbc_subset &lt;- attach_wfpc(mfpca, pbc_subset, n = 2)
mfpca_list &lt;- list(
  list(functions = funData::extractObs(mfpca$functions, 1),
       values = mfpca$values[1]),
  list(functions = funData::extractObs(mfpca$functions, 2),
       values = mfpca$values[2]))
sm &lt;- smoothCon(s(id, fpc.1, bs = "unc_pcre",
      xt = list("mfpc" = mfpca_list[[1]], scale = "FALSE")), pbc_subset)
</code></pre>

<hr>
<h2 id='survint_C'>Survival Integral</h2><span id='topic+survint_C'></span>

<h3>Description</h3>

<p>This function is a wrapper function for calculating the survival integral in
C needed in the calculation of the score vector and Hessian.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survint_C(
  pred = c("lambda", "gamma", "long", "fpc_re"),
  pre_fac,
  pre_vec = NULL,
  omega,
  int_fac = NULL,
  int_vec = NULL,
  weights,
  survtime
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="survint_C_+3A_pred">pred</code></td>
<td>
<p>String to define for which predictor the survival integral is
calculated.</p>
</td></tr>
<tr><td><code id="survint_C_+3A_pre_fac">pre_fac</code></td>
<td>
<p>Vector serving as factor before the survival integral.
Corresponds to the gamma predictor.</p>
</td></tr>
<tr><td><code id="survint_C_+3A_pre_vec">pre_vec</code></td>
<td>
<p>Matrix serving as row vectors before the survival integral.
Only needed if pred = &quot;gamma&quot;.</p>
</td></tr>
<tr><td><code id="survint_C_+3A_omega">omega</code></td>
<td>
<p>Vector serving as additive predictor placeholder within the
survival integral. Present for all pred.</p>
</td></tr>
<tr><td><code id="survint_C_+3A_int_fac">int_fac</code></td>
<td>
<p>Vector serving as factor within the survival integral. Only
needed for the longitudinal predictors.</p>
</td></tr>
<tr><td><code id="survint_C_+3A_int_vec">int_vec</code></td>
<td>
<p>Matrix serving as row vectors within the survival integral.
NULL only if pred = &quot;gamma&quot;.</p>
</td></tr>
<tr><td><code id="survint_C_+3A_weights">weights</code></td>
<td>
<p>Vector containing the Gaussian integration weights.</p>
</td></tr>
<tr><td><code id="survint_C_+3A_survtime">survtime</code></td>
<td>
<p>Vector containing the survival times for weighting of the
integral.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The survival integral has a similar structure for the different model
predictors. It is always a sum over all individuals, followed by the
multiplication with a pre-integral factor (pre_fac). For the gamma predictor
a pre-integral vector is next. Then, the integral itself consists of a
weighted sum (weights) of gauss-quadrature integration points weighted by
the survival time of the individuals (survtime). Inside the integral, the
current additive predictor (omega) is multiplied with an in-integral vector
(int_vec), except for predictor gamma. All longitudinal predictors
addtitionally include an in-integration factor (int_fac).
</p>
<p>The difference between predictors &quot;long&quot; and &quot;fpc_re&quot; is that the latter
makes efficient use of the block structure of the design matrix for
unconstrained functional principal component random effects. The outputs
also differ as the Hessian for &quot;fpc_re&quot; is a diagonal matrix, so only the
diagonal elements are returned.
</p>

<hr>
<h2 id='varbinq'>Flexible Joint Models for Multivariate Longitudinal and Time-to-Event Data</h2><span id='topic+varbinq'></span>

<h3>Description</h3>

<p>This package contains all functions and implementations of the corresponding
paper by Volkmann, Umlauf, Greven: &quot;Flexible joint models for multivariate
longitudinal and time-to-event data using multivariate functional principal
components&quot;. Code to reproduce the simulation and analysis as well as
additional information on the model fitting process are contained in
the &quot;inst&quot; folder.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
