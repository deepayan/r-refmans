<!DOCTYPE html><html><head><title>Help for package nanonext</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {nanonext}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#nanonext-package'><p>nanonext: NNG (Nanomsg Next Gen) Lightweight Messaging Library</p></a></li>
<li><a href='#.context'><p>Technical Utility: Open Context</p></a></li>
<li><a href='#.unresolved'><p>Technical Utility: Query if an Aio is Unresolved</p></a></li>
<li><a href='#+25~+26gt+3B+25'><p>Signal Forwarder</p></a></li>
<li><a href='#as.promise.ncurlAio'><p>Make ncurl Promise</p></a></li>
<li><a href='#call_aio'><p>Call the Value of an Asynchronous Aio Operation</p></a></li>
<li><a href='#close.nanoContext'><p>Close Connection</p></a></li>
<li><a href='#collect_aio'><p>Collect Data of an Aio or List of Aios</p></a></li>
<li><a href='#context'><p>Open Context</p></a></li>
<li><a href='#cv'><p>Condition Variables</p></a></li>
<li><a href='#dial'><p>Dial an Address from a Socket</p></a></li>
<li><a href='#is_aio'><p>Validators</p></a></li>
<li><a href='#is_error_value'><p>Error Validators</p></a></li>
<li><a href='#listen'><p>Listen to an Address from a Socket</p></a></li>
<li><a href='#lock'><p>Lock / Unlock a Socket</p></a></li>
<li><a href='#mclock'><p>Clock Utility</p></a></li>
<li><a href='#messenger'><p>Messenger</p></a></li>
<li><a href='#msleep'><p>Sleep Utility</p></a></li>
<li><a href='#nano'><p>Create Nano Object</p></a></li>
<li><a href='#ncurl'><p>ncurl</p></a></li>
<li><a href='#ncurl_aio'><p>ncurl Async</p></a></li>
<li><a href='#ncurl_session'><p>ncurl Session</p></a></li>
<li><a href='#next_config'><p>Configure Next Mode</p></a></li>
<li><a href='#nng_error'><p>Translate Error Codes</p></a></li>
<li><a href='#nng_version'><p>NNG Library Version</p></a></li>
<li><a href='#opt'><p>Get and Set Options for a Socket, Context, Stream, Listener or Dialer</p></a></li>
<li><a href='#parse_url'><p>Parse URL</p></a></li>
<li><a href='#pipe_notify'><p>Pipe Notify</p></a></li>
<li><a href='#protocols'><p>Protocols [Documentation]</p></a></li>
<li><a href='#random'><p>Random Data Generation</p></a></li>
<li><a href='#reap'><p>Reap</p></a></li>
<li><a href='#recv'><p>Receive</p></a></li>
<li><a href='#recv_aio'><p>Receive Async</p></a></li>
<li><a href='#reply'><p>Reply over Context (RPC Server for Req/Rep Protocol)</p></a></li>
<li><a href='#request'><p>Request over Context (RPC Client for Req/Rep Protocol)</p></a></li>
<li><a href='#send'><p>Send</p></a></li>
<li><a href='#send_aio'><p>Send Async</p></a></li>
<li><a href='#set_promise_context'><p>Set Promise Context</p></a></li>
<li><a href='#socket'><p>Open Socket</p></a></li>
<li><a href='#start'><p>Start Listener/Dialer</p></a></li>
<li><a href='#stat'><p>Get Statistic for a Socket, Listener or Dialer</p></a></li>
<li><a href='#status_code'><p>Translate HTTP Status Codes</p></a></li>
<li><a href='#stop_aio'><p>Stop Asynchronous Aio Operation</p></a></li>
<li><a href='#stream'><p>Open Stream</p></a></li>
<li><a href='#subscribe'><p>Subscribe / Unsubscribe Topic</p></a></li>
<li><a href='#survey_time'><p>Set Survey Time</p></a></li>
<li><a href='#tls_config'><p>Create TLS Configuration</p></a></li>
<li><a href='#transports'><p>Transports [Documentation]</p></a></li>
<li><a href='#unresolved'><p>Query if an Aio is Unresolved</p></a></li>
<li><a href='#write_cert'><p>Generate Self-Signed Certificate and Key</p></a></li>
<li><a href='#zzz'><p>Internal Package Function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>NNG (Nanomsg Next Gen) Lightweight Messaging Library</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>R binding for NNG (Nanomsg Next Gen), a successor to ZeroMQ. NNG is
    a socket library implementing 'Scalability Protocols', a reliable,
    high-performance standard for common communications patterns including
    publish/subscribe, request/reply and service discovery, over in-process,
    IPC, TCP, WebSocket and secure TLS transports. As its own threaded
    concurrency framework, provides a toolkit for asynchronous programming and
    distributed computing, with intuitive 'aio' objects which resolve
    automatically upon completion of asynchronous operations, and
    synchronisation primitives allowing R to wait upon events signalled by
    concurrent threads.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/shikokuchuo/nanonext/issues">https://github.com/shikokuchuo/nanonext/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://shikokuchuo.net/nanonext/">https://shikokuchuo.net/nanonext/</a>,
<a href="https://github.com/shikokuchuo/nanonext/">https://github.com/shikokuchuo/nanonext/</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>'libnng' &gt;= 1.6 and 'libmbedtls' &gt;= 2.5, or 'cmake'
and 'xz' to compile NNG and/or Mbed TLS included in package
sources</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>Enhances:</td>
<td>promises</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, later, markdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-23 20:35:41 UTC; cg334</td>
</tr>
<tr>
<td>Author:</td>
<td>Charlie Gao <a href="https://orcid.org/0000-0002-0750-061X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Hibiki AI Limited [cph],
  R Consortium [fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Charlie Gao &lt;charlie.gao@shikokuchuo.net&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-23 22:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='nanonext-package'>nanonext: NNG (Nanomsg Next Gen) Lightweight Messaging Library</h2><span id='topic+nanonext'></span><span id='topic+nanonext-package'></span>

<h3>Description</h3>

<p>R binding for NNG (Nanomsg Next Gen), a successor to ZeroMQ. NNG is a socket
library implementing &lsquo;Scalability Protocols&rsquo;, a reliable,
high-performance standard for common communications patterns including
publish/subscribe, request/reply and service discovery, over in-process,
IPC, TCP, WebSocket and secure TLS transports. As its own threaded
concurrency framework, provides a toolkit for asynchronous programming
and distributed computing, with intuitive &lsquo;aio&rsquo; objects which
resolve automatically upon completion of asynchronous operations, and
synchronisation primitives allowing R to wait upon events signalled by
concurrent threads.
</p>


<h3>Usage notes</h3>

<p><span class="pkg">nanonext</span> offers 2 equivalent interfaces: a functional interface,
and an object-oriented interface.
</p>
<p>The primary object in the functional interface is the Socket. Use
<code><a href="#topic+socket">socket</a></code> to create a socket and dial or listen at an address.
The socket is then passed as the first argument of subsequent actions
such as <code>send()</code> or <code>recv()</code>.
</p>
<p>The primary object in the object-oriented interface is the nano object.
Use <code><a href="#topic+nano">nano</a></code> to create a nano object which encapsulates a
Socket and Dialer/Listener. Methods such as <code>$send()</code> or
<code>$recv()</code> can then be accessed directly from the object.
</p>


<h3>Documentation</h3>

<p>Guide to the implemented protocols for sockets: <a href="#topic+protocols">protocols</a>
</p>
<p>Guide to the supported transports for dialers and listeners:
<a href="#topic+transports">transports</a>
</p>
<p>Guide to the options that can be inspected and set using: <a href="#topic+opt">opt</a> /
<a href="#topic+opt+3C-">opt&lt;-</a>
</p>


<h3>Reference Manual</h3>

<p><code>vignette("nanonext", package = "nanonext")</code>
</p>


<h3>Conceptual overview</h3>

<p>NNG presents a socket view of networking. A socket implements precisely
one protocol, such as &lsquo;bus&rsquo;, etc.
</p>
<p>Each socket can be used to send and receive messages (if the protocol
supports it, and implements the appropriate protocol semantics). For
example, the &lsquo;sub&rsquo; protocol automatically filters incoming
messages to discard topics that have not been subscribed.
</p>
<p>NNG sockets are message-oriented, and messages are either delivered
wholly, or not at all. Partial delivery is not possible. Furthermore, NNG
does not provide any other delivery or ordering guarantees: messages may
be dropped or reordered (some protocols, such as &lsquo;req&rsquo; may offer
stronger guarantees by performing their own retry and validation schemes).
</p>
<p>Each socket can have zero, one, or many endpoints, which are either
listeners or dialers (a given socket may use listeners, dialers, or
both). These endpoints provide access to underlying transports, such as
TCP, etc.
</p>
<p>Each endpoint is associated with a URL, which is a service address.
For dialers, this is the service address that is contacted, whereas for
listeners this is where new connections will be accepted.
</p>


<h3>Links</h3>

<p>NNG: <a href="https://nng.nanomsg.org/">https://nng.nanomsg.org/</a> <br />
Mbed TLS: <a href="https://www.trustedfirmware.org/projects/mbed-tls/">https://www.trustedfirmware.org/projects/mbed-tls/</a>
</p>


<h3>Author(s)</h3>

<p>Charlie Gao <a href="mailto:charlie.gao@shikokuchuo.net">charlie.gao@shikokuchuo.net</a>
(<a href="https://orcid.org/0000-0002-0750-061X">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://shikokuchuo.net/nanonext/">https://shikokuchuo.net/nanonext/</a>
</p>
</li>
<li> <p><a href="https://github.com/shikokuchuo/nanonext/">https://github.com/shikokuchuo/nanonext/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/shikokuchuo/nanonext/issues">https://github.com/shikokuchuo/nanonext/issues</a>
</p>
</li></ul>


<hr>
<h2 id='.context'>Technical Utility: Open Context</h2><span id='topic+.context'></span>

<h3>Description</h3>

<p>Open a new Context to be used with a Socket. This function is a performance
variant of <code><a href="#topic+context">context</a></code>, designed to wrap a socket in a function
argument when calling <code><a href="#topic+request">request</a></code> or <code><a href="#topic+reply">reply</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.context(socket)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".context_+3A_socket">socket</code></td>
<td>
<p>a Socket.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>External pointers created by this function are unclassed, hence
methods for contexts such as <code><a href="#topic+close">close</a></code> will not work (use
<code><a href="#topic+reap">reap</a></code> instead). Otherwise they function identically to a
Context when passed to all messaging functions.
</p>


<h3>Value</h3>

<p>An external pointer.
</p>

<hr>
<h2 id='.unresolved'>Technical Utility: Query if an Aio is Unresolved</h2><span id='topic+.unresolved'></span>

<h3>Description</h3>

<p>Query whether an Aio or list of Aios remains unresolved. This is an
experimental technical utility version of <code><a href="#topic+unresolved">unresolved</a></code> not
intended for ordinary use. Provides a method of querying the busy status
of an Aio without altering its state in any way i.e. not attempting to
retrieve the result or message.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.unresolved(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".unresolved_+3A_x">x</code></td>
<td>
<p>an Aio or list of Aios (objects of class &lsquo;sendAio&rsquo;,
&lsquo;recvAio&rsquo; or &lsquo;ncurlAio&rsquo;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>.unresolved()</code> is not intended to be used for &lsquo;recvAio&rsquo;
returned by a signalling function, in which case <code><a href="#topic+unresolved">unresolved</a></code>
must be used in all cases.
</p>


<h3>Value</h3>

<p>Logical TRUE if &lsquo;aio&rsquo; is an unresolved Aio or else FALSE, or
if &lsquo;aio&rsquo; is a list, the integer number of unresolved Aios in the
list.
</p>

<hr>
<h2 id='+25~+26gt+3B+25'>Signal Forwarder</h2><span id='topic++25~+3E+25'></span>

<h3>Description</h3>

<p>Forwards signals from one &lsquo;conditionVariable&rsquo; to another.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv %~&gt;% cv2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25~+2B26gt+2B3B+2B25_+3A_cv">cv</code></td>
<td>
<p>a &lsquo;conditionVariable&rsquo; object, from which to forward the
signal.</p>
</td></tr>
<tr><td><code id="+2B25~+2B26gt+2B3B+2B25_+3A_cv2">cv2</code></td>
<td>
<p>a &lsquo;conditionVariable&rsquo; object, to which the signal is
forwarded.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The condition value of &lsquo;cv&rsquo; is initially reset to zero when
this operator returns. Only one forwarder can be active on a &lsquo;cv&rsquo;
at any given time, and assigning a new forwarding target cancels any
currently existing forwarding.
</p>
<p>Changes in the condition value of &lsquo;cv&rsquo; are forwarded to
&lsquo;cv2&rsquo;, but only on each occassion &lsquo;cv&rsquo; is signalled. This
means that waiting on &lsquo;cv&rsquo; will cause a temporary divergence
between the actual condition value of &lsquo;cv&rsquo; and that recorded at
&lsquo;cv2&rsquo;, until the next time &lsquo;cv&rsquo; is signalled.
</p>


<h3>Value</h3>

<p>Invisibly, &lsquo;cv2&rsquo;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cva &lt;- cv(); cvb &lt;- cv(); cv1 &lt;- cv(); cv2 &lt;- cv()

cva %~&gt;% cv1 %~&gt;% cv2
cvb %~&gt;% cv2

cv_signal(cva)
cv_signal(cvb)
cv_value(cv1)
cv_value(cv2)

</code></pre>

<hr>
<h2 id='as.promise.ncurlAio'>Make ncurl Promise</h2><span id='topic+as.promise.ncurlAio'></span>

<h3>Description</h3>

<p>Creates a &lsquo;promise&rsquo; from an &lsquo;ncurlAio&rsquo; object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ncurlAio'
as.promise(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.promise.ncurlAio_+3A_x">x</code></td>
<td>
<p>an object of class &lsquo;ncurlAio&rsquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is an S3 method for the generic <code>as.promise</code> for
class &lsquo;ncurlAio&rsquo;.
</p>
<p>Requires the <span class="pkg">promises</span> package.
</p>
<p>Allows an &lsquo;ncurlAio&rsquo; to be used with the promise pipe
<code>%...&gt;%</code>, which schedules a function to run upon resolution of the
Aio.
</p>


<h3>Value</h3>

<p>A &lsquo;promise&rsquo; object.
</p>

<hr>
<h2 id='call_aio'>Call the Value of an Asynchronous Aio Operation</h2><span id='topic+call_aio'></span><span id='topic+call_aio_'></span>

<h3>Description</h3>

<p><code>call_aio</code> retrieves the value of an asynchronous Aio operation, waiting
for the operation to complete if still in progress. For a list of Aios,
waits for all asynchronous operations to complete before returning.
</p>
<p><code>call_aio_</code> is a variant that allows user interrupts, suitable for
interactive use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>call_aio(x)

call_aio_(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="call_aio_+3A_x">x</code></td>
<td>
<p>an Aio or list of Aios (objects of class &lsquo;sendAio&rsquo;,
&lsquo;recvAio&rsquo; or &lsquo;ncurlAio&rsquo;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a &lsquo;recvAio&rsquo;, the received value may be retrieved at
<code>$data</code>.
</p>
<p>For a &lsquo;sendAio&rsquo;, the send result may be retrieved at
<code>$result</code>. This will be zero on success, or else an integer error
code.
</p>
<p>To access the values directly, use for example on a &lsquo;recvAio&rsquo;
<code>x</code>: <code>call_aio(x)$data</code>.
</p>
<p>For a &lsquo;recvAio&rsquo;, if an error occurred in unserialization or
conversion of the message data to the specified mode, a raw vector will
be returned instead to allow recovery (accompanied by a warning).
</p>
<p>Note: this function operates silently and does not error even if
&lsquo;aio&rsquo; is not an active Aio or list of Aios, always returning
invisibly the passed object.
</p>


<h3>Value</h3>

<p>The passed object (invisibly).
</p>


<h3>Alternatively</h3>

<p>Aio values may be accessed directly at <code>$result</code> for a
&lsquo;sendAio&rsquo;, and <code>$data</code> for a &lsquo;recvAio&rsquo;. If the Aio
operation is yet to complete, an &lsquo;unresolved&rsquo; logical NA will be
returned. Once complete, the resolved value will be returned instead.
</p>
<p><code><a href="#topic+unresolved">unresolved</a></code> may also be used, which returns TRUE only if an
Aio or Aio value has yet to resolve and FALSE otherwise. This is suitable
for use in control flow statements such as <code>while</code> or <code>if</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s1 &lt;- socket("pair", listen = "inproc://nanonext")
s2 &lt;- socket("pair", dial = "inproc://nanonext")

res &lt;- send_aio(s1, data.frame(a = 1, b = 2), timeout = 100)
res
call_aio(res)
res$result

msg &lt;- recv_aio(s2, timeout = 100)
msg
call_aio_(msg)$data

close(s1)
close(s2)

</code></pre>

<hr>
<h2 id='close.nanoContext'>Close Connection</h2><span id='topic+close.nanoContext'></span><span id='topic+close.nanoDialer'></span><span id='topic+close.nanoListener'></span><span id='topic+close.ncurlSession'></span><span id='topic+close'></span><span id='topic+close.nanoSocket'></span><span id='topic+close.nanoStream'></span>

<h3>Description</h3>

<p>Close Connection on a Socket, Context, Dialer, Listener, Stream, or ncurl
Session.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nanoContext'
close(con, ...)

## S3 method for class 'nanoDialer'
close(con, ...)

## S3 method for class 'nanoListener'
close(con, ...)

## S3 method for class 'ncurlSession'
close(con, ...)

## S3 method for class 'nanoSocket'
close(con, ...)

## S3 method for class 'nanoStream'
close(con, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="close.nanoContext_+3A_con">con</code></td>
<td>
<p>a Socket, Context, Dialer, Listener, Stream, or 'ncurlSession'.</p>
</td></tr>
<tr><td><code id="close.nanoContext_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Closing an object explicitly frees its resources. An object can also
be removed directly in which case its resources are freed when the object
is garbage collected.
</p>
<p>Closing a Socket associated with a Context also closes the Context.
</p>
<p>Dialers and Listeners are implicitly closed when the Socket they are
associated with is closed.
</p>
<p>Closing a Socket or a Context: messages that have been submitted for
sending may be flushed or delivered, depending upon the transport. Closing
the Socket while data is in transmission will likely lead to loss of that
data. There is no automatic linger or flush to ensure that the Socket
send buffers have completely transmitted.
</p>
<p>Closing a Stream: if any send or receive operations are pending, they
will be terminated and any new operations will fail after the connection
is closed.
</p>


<h3>Value</h3>

<p>Invisibly, an integer exit code (zero on success).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reap">reap</a></code>
</p>

<hr>
<h2 id='collect_aio'>Collect Data of an Aio or List of Aios</h2><span id='topic+collect_aio'></span><span id='topic+collect_aio_'></span>

<h3>Description</h3>

<p><code>collect_aio</code> collects the data of an Aio or list of Aios, waiting for
resolution if still in progress.
</p>
<p><code>collect_aio_</code> is a variant that allows user interrupts, suitable for
interactive use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collect_aio(x)

collect_aio_(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collect_aio_+3A_x">x</code></td>
<td>
<p>an Aio or list of Aios (objects of class &lsquo;sendAio&rsquo;,
&lsquo;recvAio&rsquo; or &lsquo;ncurlAio&rsquo;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will wait for the asynchronous operation(s) to
complete if still in progress (blocking).
</p>
<p>Using <code>x[]</code> on an Aio <code>x</code> is equivalent to the
user-interruptible <code>collect_aio_(x)</code>.
</p>


<h3>Value</h3>

<p>Depending on the type of &lsquo;x&rsquo; supplied, an object or list of
objects (the same length as &lsquo;x&rsquo;, preserving names).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s1 &lt;- socket("pair", listen = "inproc://nanonext")
s2 &lt;- socket("pair", dial = "inproc://nanonext")

res &lt;- send_aio(s1, data.frame(a = 1, b = 2), timeout = 100)
collect_aio(res)

msg &lt;- recv_aio(s2, timeout = 100)
collect_aio_(msg)

msg[]

close(s1)
close(s2)

</code></pre>

<hr>
<h2 id='context'>Open Context</h2><span id='topic+context'></span>

<h3>Description</h3>

<p>Open a new Context to be used with a Socket. The purpose of a Context is to
permit applications to share a single socket, with its underlying dialers
and listeners, while still benefiting from separate state tracking.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>context(socket)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="context_+3A_socket">socket</code></td>
<td>
<p>a Socket.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Contexts allow the independent and concurrent use of stateful
operations using the same socket. For example, two different contexts
created on a rep socket can each receive requests, and send replies to
them, without any regard to or interference with each other.
</p>
<p>Only the following protocols support creation of contexts: req, rep, sub
(in a pub/sub pattern), surveyor, respondent.
</p>
<p>To send and receive over a context use <code><a href="#topic+send">send</a></code> and
<code><a href="#topic+recv">recv</a></code> or their async counterparts <code><a href="#topic+send_aio">send_aio</a></code> and
<code><a href="#topic+recv_aio">recv_aio</a></code>.
</p>
<p>For nano objects, use the <code>$context_open()</code> method, which will
attach a new context at <code>$context</code>. See <code><a href="#topic+nano">nano</a></code>.
</p>


<h3>Value</h3>

<p>A Context (object of class &lsquo;nanoContext&rsquo; and &lsquo;nano&rsquo;).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+request">request</a></code> and <code><a href="#topic+reply">reply</a></code> for use with contexts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- socket("req", listen = "inproc://nanonext")
ctx &lt;- context(s)
ctx
close(ctx)
close(s)

n &lt;- nano("req", listen = "inproc://nanonext")
n$context_open()
n$context
n$context_open()
n$context
n$context_close()
n$close()

</code></pre>

<hr>
<h2 id='cv'>Condition Variables</h2><span id='topic+cv'></span><span id='topic+wait'></span><span id='topic+wait_'></span><span id='topic+until'></span><span id='topic+until_'></span><span id='topic+cv_value'></span><span id='topic+cv_reset'></span><span id='topic+cv_signal'></span>

<h3>Description</h3>

<p><code>cv</code> creates a new condition variable (protected by a mutex internal to
the object).
</p>
<p><code>wait</code> waits on a condition being signalled by completion of an
asynchronous receive or pipe event. <br /> <code>wait_</code> is a variant that
allows user interrupts, suitable for interactive use.
</p>
<p><code>until</code> waits until a future time on a condition being signalled by
completion of an asynchronous receive or pipe event. <br /> <code>until_</code> is
a variant that allows user interrupts, suitable for interactive use.
</p>
<p><code>cv_value</code> inspects the internal value of a condition variable.
</p>
<p><code>cv_reset</code> resets the internal value and flag of a condition variable.
</p>
<p><code>cv_signal</code> signals a condition variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv()

wait(cv)

wait_(cv)

until(cv, msec)

until_(cv, msec)

cv_value(cv)

cv_reset(cv)

cv_signal(cv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv_+3A_cv">cv</code></td>
<td>
<p>a &lsquo;conditionVariable&rsquo; object.</p>
</td></tr>
<tr><td><code id="cv_+3A_msec">msec</code></td>
<td>
<p>maximum time in milliseconds to wait for the condition variable
to be signalled.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Pass the &lsquo;conditionVariable&rsquo; to the asynchronous receive
functions <code><a href="#topic+recv_aio">recv_aio</a></code> or <code><a href="#topic+request">request</a></code>. Alternatively,
to be notified of a pipe event, pass it to <code><a href="#topic+pipe_notify">pipe_notify</a></code>.
</p>
<p>Completion of the receive or pipe event, which happens asynchronously and
independently of the main R thread, will signal the condition variable by
incrementing it by 1.
</p>
<p>This will cause the R execution thread waiting on the condition variable
using <code>wait</code> or <code>until</code> to wake and continue.
</p>
<p>For argument &lsquo;msec&rsquo;, non-integer values will be coerced to
integer. Non-numeric input will be ignored and return immediately.
</p>


<h3>Value</h3>

<p>For <strong>cv</strong>: a &lsquo;conditionVariable&rsquo; object.
</p>
<p>For <strong>wait</strong>: (invisibly) logical TRUE, or else FALSE if a flag has
been set.
</p>
<p>For <strong>until</strong>: (invisibly) logical TRUE if signalled, or else FALSE
if the timeout was reached.
</p>
<p>For <strong>cv_value</strong>: integer value of the condition variable.
</p>
<p>For <strong>cv_reset</strong> and <strong>cv_signal</strong>: zero (invisibly).
</p>


<h3>Condition</h3>

<p>The condition internal to this &lsquo;conditionVariable&rsquo; maintains a
state (value). Each signal increments the value by 1. Each time
<code>wait</code> or <code>until</code> returns (apart from due to timeout), the
value is decremented by 1.
</p>
<p>The internal condition may be inspected at any time using <code>cv_value</code>
and reset using <code>cv_reset</code>. This affords a high degree of
flexibility in designing complex concurrent applications.
</p>


<h3>Flag</h3>

<p>The condition variable also contains a flag that certain signalling
functions such as <code><a href="#topic+pipe_notify">pipe_notify</a></code> can set. When this flag has
been set, all subsequent <code>wait</code> calls will return logical FALSE
instead of TRUE.
</p>
<p>Note that the flag is not automatically reset, but may be reset manually
using <code>cv_reset</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cv &lt;- cv()

## Not run: 
wait(cv) # would block until the cv is signalled
wait_(cv) # would block until the cv is signalled or interrupted

## End(Not run)

until(cv, 10L)
until_(cv, 10L)

cv_value(cv)

cv_reset(cv)

cv_value(cv)
cv_signal(cv)
cv_value(cv)

</code></pre>

<hr>
<h2 id='dial'>Dial an Address from a Socket</h2><span id='topic+dial'></span>

<h3>Description</h3>

<p>Creates a new Dialer and binds it to a Socket.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dial(
  socket,
  url = "inproc://nanonext",
  tls = NULL,
  autostart = TRUE,
  error = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dial_+3A_socket">socket</code></td>
<td>
<p>a Socket.</p>
</td></tr>
<tr><td><code id="dial_+3A_url">url</code></td>
<td>
<p>[default 'inproc://nanonext'] a URL to dial, specifying the
transport and address as a character string e.g. 'inproc://anyvalue' or
'tcp://127.0.0.1:5555' (see <a href="#topic+transports">transports</a>).</p>
</td></tr>
<tr><td><code id="dial_+3A_tls">tls</code></td>
<td>
<p>[default NULL] for secure tls+tcp:// or wss:// connections only,
provide a TLS configuration object created by <code><a href="#topic+tls_config">tls_config</a></code>.</p>
</td></tr>
<tr><td><code id="dial_+3A_autostart">autostart</code></td>
<td>
<p>[default TRUE] whether to start the dialer (by default
asynchronously). Set to NA to start synchronously - this is less
resilient if a connection is not immediately possible, but avoids subtle
errors from attempting to use the socket before an asynchronous dial has
completed. Set to FALSE if setting configuration options on the dialer as
it is not generally possible to change these once started.</p>
</td></tr>
<tr><td><code id="dial_+3A_error">error</code></td>
<td>
<p>[default FALSE] behaviour on error: if FALSE, returns an integer
exit code accompanied by a warning, or, if TRUE, generates an error and
halts execution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To view all Dialers bound to a socket use <code>$dialer</code> on the
socket, which returns a list of Dialer objects. To access any individual
Dialer (e.g. to set options on it), index into the list e.g.
<code>$dialer[[1]]</code> to return the first Dialer.
</p>
<p>A Dialer is an external pointer to a dialer object, which creates a
single outgoing connection at a time. If the connection is broken, or
fails, the dialer object will automatically attempt to reconnect, and
will keep doing so until the dialer or socket is destroyed.
</p>


<h3>Value</h3>

<p>Invisibly, an integer exit code (zero on success). A new Dialer
(object of class &lsquo;nanoDialer&rsquo; and &lsquo;nano&rsquo;) is created and
bound to the Socket if successful.
</p>


<h3>Further details</h3>

<p>Dialers and Listeners are always associated with a single socket. A
given socket may have multiple Listeners and/or multiple Dialers.
</p>
<p>The client/server relationship described by dialer/listener is completely
orthogonal to any similar relationship in the protocols. For example, a
rep socket may use a dialer to connect to a listener on an req socket.
This orthogonality can lead to innovative solutions to otherwise
challenging communications problems.
</p>
<p>Any configuration options on the dialer/listener should be set by
<code><a href="#topic+opt+3C-">opt&lt;-</a></code> before starting the dialer/listener with
<code><a href="#topic+start">start</a></code>.
</p>
<p>Dialers/Listeners may be destroyed by <code><a href="#topic+close">close</a></code>. They are also
closed when their associated socket is closed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>socket &lt;- socket("rep")
dial(socket, url = "tcp://127.0.0.1:6545", autostart = FALSE)
socket$dialer
start(socket$dialer[[1]])
socket$dialer
close(socket$dialer[[1]])
close(socket)

nano &lt;- nano("bus")
nano$dial(url = "tcp://127.0.0.1:6546", autostart = FALSE)
nano$dialer
nano$dialer_start()
nano$dialer
close(nano$dialer[[1]])
nano$close()

</code></pre>

<hr>
<h2 id='is_aio'>Validators</h2><span id='topic+is_aio'></span><span id='topic+is_nano'></span>

<h3>Description</h3>

<p>Validator functions for object types created by {nanonext}.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_aio(x)

is_nano(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_aio_+3A_x">x</code></td>
<td>
<p>an object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Is the object an Aio (inheriting from class &lsquo;sendAio&rsquo; or
&lsquo;recvAio&rsquo;).
</p>
<p>Is the object an object inheriting from class &lsquo;nano&rsquo; i.e. a
nanoSocket, nanoContext, nanoStream, nanoListener, nanoDialer, or nano
Object.
</p>


<h3>Value</h3>

<p>Logical value TRUE or FALSE.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sock &lt;- socket(listen = "inproc://isaio")
r &lt;- recv_aio(sock)
s &lt;- send_aio(sock, "test")
is_aio(r)
is_aio(s)
close(sock)

s &lt;- socket()
is_nano(s)
n &lt;- nano()
is_nano(n)
close(s)
n$close()

</code></pre>

<hr>
<h2 id='is_error_value'>Error Validators</h2><span id='topic+is_error_value'></span><span id='topic+is_nul_byte'></span>

<h3>Description</h3>

<p>Validator functions for error value types created by <span class="pkg">nanonext</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_error_value(x)

is_nul_byte(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_error_value_+3A_x">x</code></td>
<td>
<p>an object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Is the object an error value generated by the package. All
non-success integer return values are classed &lsquo;errorValue&rsquo; to be
distinguishable from integer message values. Includes error values
returned after a timeout etc.
</p>
<p>Is the object a nul byte.
</p>


<h3>Value</h3>

<p>Logical value TRUE or FALSE.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- socket()
r &lt;- recv_aio(s, timeout = 10)
call_aio(r)$data
close(s)
r$data == 5L
is_error_value(r$data)
is_error_value(5L)

is_nul_byte(as.raw(0L))
is_nul_byte(raw(length = 1L))
is_nul_byte(writeBin("", con = raw()))
is_nul_byte(0L)
is_nul_byte(NULL)
is_nul_byte(NA)

</code></pre>

<hr>
<h2 id='listen'>Listen to an Address from a Socket</h2><span id='topic+listen'></span>

<h3>Description</h3>

<p>Creates a new Listener and binds it to a Socket.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>listen(
  socket,
  url = "inproc://nanonext",
  tls = NULL,
  autostart = TRUE,
  error = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="listen_+3A_socket">socket</code></td>
<td>
<p>a Socket.</p>
</td></tr>
<tr><td><code id="listen_+3A_url">url</code></td>
<td>
<p>[default 'inproc://nanonext'] a URL to dial, specifying the
transport and address as a character string e.g. 'inproc://anyvalue' or
'tcp://127.0.0.1:5555' (see <a href="#topic+transports">transports</a>).</p>
</td></tr>
<tr><td><code id="listen_+3A_tls">tls</code></td>
<td>
<p>[default NULL] for secure tls+tcp:// or wss:// connections only,
provide a TLS configuration object created by <code><a href="#topic+tls_config">tls_config</a></code>.</p>
</td></tr>
<tr><td><code id="listen_+3A_autostart">autostart</code></td>
<td>
<p>[default TRUE] whether to start the listener. Set to FALSE
if setting configuration options on the listener as it is not generally
possible to change these once started.</p>
</td></tr>
<tr><td><code id="listen_+3A_error">error</code></td>
<td>
<p>[default FALSE] behaviour on error: if FALSE, returns an integer
exit code accompanied by a warning, or, if TRUE, generates an error and
halts execution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To view all Listeners bound to a socket use <code>$listener</code> on the
socket, which returns a list of Listener objects. To access any
individual Listener (e.g. to set options on it), index into the list e.g.
<code>$listener[[1]]</code> to return the first Listener.
</p>
<p>A listener is an external pointer to a listener object, which accepts
incoming connections. A given listener object may have many connections
at the same time, much like an HTTP server can have many connections to
multiple clients simultaneously.
</p>


<h3>Value</h3>

<p>Invisibly, an integer exit code (zero on success). A new Listener
(object of class &lsquo;nanoListener&rsquo; and &lsquo;nano&rsquo;) is created and
bound to the Socket if successful.
</p>


<h3>Further details</h3>

<p>Dialers and Listeners are always associated with a single socket. A
given socket may have multiple Listeners and/or multiple Dialers.
</p>
<p>The client/server relationship described by dialer/listener is completely
orthogonal to any similar relationship in the protocols. For example, a
rep socket may use a dialer to connect to a listener on an req socket.
This orthogonality can lead to innovative solutions to otherwise
challenging communications problems.
</p>
<p>Any configuration options on the dialer/listener should be set by
<code><a href="#topic+opt+3C-">opt&lt;-</a></code> before starting the dialer/listener with
<code><a href="#topic+start">start</a></code>.
</p>
<p>Dialers/Listeners may be destroyed by <code><a href="#topic+close">close</a></code>. They are also
closed when their associated socket is closed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>socket &lt;- socket("req")
listen(socket, url = "tcp://127.0.0.1:6547", autostart = FALSE)
socket$listener
start(socket$listener[[1]])
socket$listener
close(socket$listener[[1]])
close(socket)

nano &lt;- nano("bus")
nano$listen(url = "tcp://127.0.0.1:6548", autostart = FALSE)
nano$listener
nano$listener_start()
nano$listener
close(nano$listener[[1]])
nano$close()

</code></pre>

<hr>
<h2 id='lock'>Lock / Unlock a Socket</h2><span id='topic+lock'></span><span id='topic+unlock'></span>

<h3>Description</h3>

<p>Prevents further pipe connections from being established at a Socket. If a
socket is locked, new pipe connections are closed before they can be
added to the socket.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lock(socket, cv = NULL)

unlock(socket)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lock_+3A_socket">socket</code></td>
<td>
<p>a Socket.</p>
</td></tr>
<tr><td><code id="lock_+3A_cv">cv</code></td>
<td>
<p>(optional) a &lsquo;conditionVariable&rsquo;. If supplied, the socket is
locked only whilst the condition variable is an odd value. This is
designed to allow an initial connection, as well as subsequent
re-connections after a connection has ended, if the conditon variable is
also registered with <code><a href="#topic+pipe_notify">pipe_notify</a></code> for both add and remove
pipe events.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly, zero on success (will otherwise error).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- socket("bus", listen = "inproc://nanolock")
s1 &lt;- socket("bus", dial = "inproc://nanolock")
lock(s)
s2 &lt;- socket("bus", dial = "inproc://nanolock")

send(s, "test")
recv(s1)
recv(s2)

unlock(s)
s3 &lt;- socket("bus", dial = "inproc://nanolock")
send(s, "test")
recv(s1)
recv(s3)

close(s)
close(s1)
close(s2)
close(s3)

</code></pre>

<hr>
<h2 id='mclock'>Clock Utility</h2><span id='topic+mclock'></span>

<h3>Description</h3>

<p>Provides the number of elapsed milliseconds since an arbitrary reference time
in the past. The reference time will be the same for a given session, but
may differ between sessions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mclock()
</code></pre>


<h3>Details</h3>

<p>A convenience function for building concurrent applications. The
resolution of the clock depends on the underlying system timing facilities
and may not be particularly fine-grained. This utility should however be
faster than using <code>Sys.time()</code>.
</p>


<h3>Value</h3>

<p>A double.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>time &lt;- mclock(); msleep(100); mclock() - time

</code></pre>

<hr>
<h2 id='messenger'>Messenger</h2><span id='topic+messenger'></span>

<h3>Description</h3>

<p>Multi-threaded, console-based, 2-way instant messaging system with
authentication, based on NNG scalability protocols.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>messenger(url, auth = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="messenger_+3A_url">url</code></td>
<td>
<p>a URL to connect to, specifying the transport and address as
a character string e.g. 'tcp://127.0.0.1:5555' (see <a href="#topic+transports">transports</a>).</p>
</td></tr>
<tr><td><code id="messenger_+3A_auth">auth</code></td>
<td>
<p>[default NULL] an R object (possessed by both parties) which
serves as a pre-shared key on which to authenticate the communication.
Note: the object is never sent, only a random subset of its md5 hash
after serialization.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisible NULL.
</p>


<h3>Usage</h3>

<p>Type outgoing messages and hit return to send.
</p>
<p>The timestamps of outgoing messages are prefixed by <code>&gt;</code> and that of
incoming messages by <code>&lt;</code>.
</p>
<p><code>:q</code> is the command to quit.
</p>
<p>Both parties must supply the same argument for &lsquo;auth&rsquo;, otherwise
the party trying to connect will receive an &lsquo;authentication error&rsquo;
and be immediately disconnected.
</p>


<h3>Note</h3>

<p>The authentication protocol is an experimental proof of concept which
is not secure, and should not be used for critical applications.
</p>

<hr>
<h2 id='msleep'>Sleep Utility</h2><span id='topic+msleep'></span>

<h3>Description</h3>

<p>Sleep function. May block for longer than requested, with the actual wait
time determined by the capabilities of the underlying system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msleep(time)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="msleep_+3A_time">time</code></td>
<td>
<p>integer number of milliseconds to block the caller.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Non-integer values for &lsquo;time&rsquo; are coerced to integer.
Negative, logical and other non-numeric values are ignored, causing the
function to return immediately.
</p>
<p>Note that unlike <code><a href="base.html#topic+Sys.sleep">Sys.sleep</a></code>, this function is not
user-interruptible by sending SIGINT e.g. with ctrl + c.
</p>


<h3>Value</h3>

<p>Invisible NULL.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>time &lt;- mclock(); msleep(100); mclock() - time

</code></pre>

<hr>
<h2 id='nano'>Create Nano Object</h2><span id='topic+nano'></span>

<h3>Description</h3>

<p>Create a nano object, encapsulating a Socket, Dialers/Listeners and
associated methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nano(
  protocol = c("bus", "pair", "push", "pull", "pub", "sub", "req", "rep", "surveyor",
    "respondent"),
  dial = NULL,
  listen = NULL,
  tls = NULL,
  autostart = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nano_+3A_protocol">protocol</code></td>
<td>
<p>[default 'bus'] choose protocol - &lsquo;bus&rsquo;, &lsquo;pair&rsquo;,
&lsquo;push&rsquo;, &lsquo;pull&rsquo;, &lsquo;pub&rsquo;, &lsquo;sub&rsquo;, &lsquo;req&rsquo;,
&lsquo;rep&rsquo;, &lsquo;surveyor&rsquo;, or &lsquo;respondent&rsquo; - see
<a href="#topic+protocols">protocols</a>.</p>
</td></tr>
<tr><td><code id="nano_+3A_dial">dial</code></td>
<td>
<p>(optional) a URL to dial, specifying the transport and address as
a character string e.g. 'inproc://anyvalue' or 'tcp://127.0.0.1:5555'
(see <a href="#topic+transports">transports</a>).</p>
</td></tr>
<tr><td><code id="nano_+3A_listen">listen</code></td>
<td>
<p>(optional) a URL to listen at, specifying the transport and
address as a character string e.g. 'inproc://anyvalue' or
'tcp://127.0.0.1:5555' (see <a href="#topic+transports">transports</a>).</p>
</td></tr>
<tr><td><code id="nano_+3A_tls">tls</code></td>
<td>
<p>[default NULL] for secure tls+tcp:// or wss:// connections only,
provide a TLS configuration object created by <code><a href="#topic+tls_config">tls_config</a></code>.</p>
</td></tr>
<tr><td><code id="nano_+3A_autostart">autostart</code></td>
<td>
<p>[default TRUE] whether to start the dialer/listener. Set to
FALSE if setting configuration options on the dialer/listener as it is
not generally possible to change these once started. For dialers only:
set to NA to start synchronously - this is less resilient if a
connection is not immediately possible, but avoids subtle errors from
attempting to use the socket before an asynchronous dial has completed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function encapsulates a Socket, Dialer and/or Listener, and its
associated methods.
</p>
<p>The Socket may be accessed by <code>$socket</code>, and the Dialer or
Listener by <code>$dialer[[1]]</code> or <code>$listener[[1]]</code> respectively.
</p>
<p>The object's methods may be accessed by <code>$</code> e.g. <code>$send()</code> or
<code>$recv()</code>. These methods mirror their functional equivalents, with
the same arguments and defaults, apart from that the first argument of the
functional equivalent is mapped to the object's encapsulated socket (or
context, if active) and does not need to be supplied.
</p>
<p>More complex network topologies may be created by binding further
dialers or listeners using the object's <code>$dial()</code> and <code>$listen()</code>
methods. The new dialer/listener will be attached to the object e.g. if
the object already has a dialer, then at <code>$dialer[[2]]</code> etc.
</p>
<p>Note that <code>$dialer_opt()</code> and <code>$listener_opt()</code> methods
will be available once dialers/listeners are attached to the object.
These methods get or apply settings for all dialers or listeners equally.
To get or apply settings for individual dialers/listeners, access them
directly via <code>$dialer[[2]]</code> or <code>$listener[[2]]</code> etc.
</p>
<p>The methods <code>$opt()</code>, and also <code>$dialer_opt()</code> or
<code>$listener_opt()</code> as may be applicable, will get the requested option
if a single argument 'name' is provided, and will set the value for the
option if both arguments 'name' and 'value' are provided.
</p>
<p>For Dialers or Listeners not automatically started, the
<code>$dialer_start()</code> or  <code>$listener_start()</code> methods will be
available. These act on the most recently created Dialer or Listener
respectively.
</p>
<p>For applicable protocols, new contexts may be created by using the
<code>$context_open()</code> method. This will attach a new context at
<code>$context</code> as well as a <code>$context_close()</code> method. While a
context is active, all object methods use the context rather than the
socket. A new context may be created by calling <code>$context_open()</code>,
which will replace any existing context. It is only necessary to use
<code>$context_close()</code> to close the existing context and revert to using
the socket.
</p>


<h3>Value</h3>

<p>A nano object of class &lsquo;nanoObject&rsquo;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nano &lt;- nano("bus", listen = "inproc://nanonext")
nano
nano$socket
nano$listener[[1]]

nano$opt("send-timeout", 1500)
nano$opt("send-timeout")

nano$listen(url = "inproc://nanonextgen")
nano$listener

nano1 &lt;- nano("bus", dial = "inproc://nanonext")
nano$send("example test", mode = "raw")
nano1$recv("character")

nano$close()
nano1$close()

</code></pre>

<hr>
<h2 id='ncurl'>ncurl</h2><span id='topic+ncurl'></span>

<h3>Description</h3>

<p>nano cURL - a minimalist http(s) client.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ncurl(
  url,
  convert = TRUE,
  follow = FALSE,
  method = NULL,
  headers = NULL,
  data = NULL,
  response = NULL,
  timeout = NULL,
  tls = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ncurl_+3A_url">url</code></td>
<td>
<p>the URL address.</p>
</td></tr>
<tr><td><code id="ncurl_+3A_convert">convert</code></td>
<td>
<p>[default TRUE] logical value whether to attempt conversion of
the received raw bytes to a character vector. Set to FALSE if downloading
non-text data.</p>
</td></tr>
<tr><td><code id="ncurl_+3A_follow">follow</code></td>
<td>
<p>[default FALSE] logical value whether to automatically follow
redirects (not applicable for async requests). If FALSE, the redirect
address is returned as response header 'Location'.</p>
</td></tr>
<tr><td><code id="ncurl_+3A_method">method</code></td>
<td>
<p>(optional) the HTTP method (defaults to 'GET' if not specified).</p>
</td></tr>
<tr><td><code id="ncurl_+3A_headers">headers</code></td>
<td>
<p>(optional) a named character vector specifying the HTTP
request headers, for example: <br />
<code>c(Authorization = "Bearer APIKEY", `Content-Type` = "text/plain")</code>
<br /> A non-character or non-named vector will be ignored.</p>
</td></tr>
<tr><td><code id="ncurl_+3A_data">data</code></td>
<td>
<p>(optional) character request data to be submitted.</p>
</td></tr>
<tr><td><code id="ncurl_+3A_response">response</code></td>
<td>
<p>(optional) a character vector specifying the response headers
to return e.g. <code>c("date", "server")</code>. These are case-insensitive and
will return NULL if not present. A non-character vector will be ignored.</p>
</td></tr>
<tr><td><code id="ncurl_+3A_timeout">timeout</code></td>
<td>
<p>(optional) integer value in milliseconds after which the
transaction times out if not yet complete.</p>
</td></tr>
<tr><td><code id="ncurl_+3A_tls">tls</code></td>
<td>
<p>(optional) applicable to secure HTTPS sites only, a client TLS
Configuration object created by <code><a href="#topic+tls_config">tls_config</a></code>. If missing or
NULL, certificates are not validated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named list of 3 elements:
</p>

<ul>
<li> <p><code>$status</code> - integer HTTP repsonse status code (200 - OK).
Use <code><a href="#topic+status_code">status_code</a></code> for a translation of the meaning.
</p>
</li>
<li> <p><code>$headers</code> - named list of response headers supplied in
'response', or NULL otherwise. If the status code is within the 300
range, i.e. a redirect, the response header 'Location' is automatically
appended to return the redirect address.
</p>
</li>
<li> <p><code>$data</code> - the response body, as a character string if
'convert' = TRUE (may be further parsed as html, json, xml etc. as
required), or a raw byte vector if FALSE (use <code><a href="base.html#topic+writeBin">writeBin</a></code> to
save as a file).
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+ncurl_aio">ncurl_aio</a></code> for asynchronous http requests;
<code><a href="#topic+ncurl_session">ncurl_session</a></code> for persistent connections.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ncurl("https://postman-echo.com/get",
       convert = FALSE,
       response = c("date", "content-type"),
       timeout = 1200L)
ncurl("https://postman-echo.com/put",
      method = "PUT",
      headers = c(Authorization = "Bearer APIKEY"),
      data = "hello world",
      timeout = 1500L)
ncurl("https://postman-echo.com/post",
      method = "POST",
      headers = c(`Content-Type` = "application/json"),
      data = '{"key":"value"}',
      timeout = 1500L)

</code></pre>

<hr>
<h2 id='ncurl_aio'>ncurl Async</h2><span id='topic+ncurl_aio'></span>

<h3>Description</h3>

<p>nano cURL - a minimalist http(s) client - async edition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ncurl_aio(
  url,
  convert = TRUE,
  method = NULL,
  headers = NULL,
  data = NULL,
  response = NULL,
  timeout = NULL,
  tls = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ncurl_aio_+3A_url">url</code></td>
<td>
<p>the URL address.</p>
</td></tr>
<tr><td><code id="ncurl_aio_+3A_convert">convert</code></td>
<td>
<p>[default TRUE] logical value whether to attempt conversion of
the received raw bytes to a character vector. Set to FALSE if downloading
non-text data.</p>
</td></tr>
<tr><td><code id="ncurl_aio_+3A_method">method</code></td>
<td>
<p>(optional) the HTTP method (defaults to 'GET' if not specified).</p>
</td></tr>
<tr><td><code id="ncurl_aio_+3A_headers">headers</code></td>
<td>
<p>(optional) a named character vector specifying the HTTP
request headers, for example: <br />
<code>c(Authorization = "Bearer APIKEY", `Content-Type` = "text/plain")</code>
<br /> A non-character or non-named vector will be ignored.</p>
</td></tr>
<tr><td><code id="ncurl_aio_+3A_data">data</code></td>
<td>
<p>(optional) character request data to be submitted.</p>
</td></tr>
<tr><td><code id="ncurl_aio_+3A_response">response</code></td>
<td>
<p>(optional) a character vector specifying the response headers
to return e.g. <code>c("date", "server")</code>. These are case-insensitive and
will return NULL if not present. A non-character vector will be ignored.</p>
</td></tr>
<tr><td><code id="ncurl_aio_+3A_timeout">timeout</code></td>
<td>
<p>(optional) integer value in milliseconds after which the
transaction times out if not yet complete.</p>
</td></tr>
<tr><td><code id="ncurl_aio_+3A_tls">tls</code></td>
<td>
<p>(optional) applicable to secure HTTPS sites only, a client TLS
Configuration object created by <code><a href="#topic+tls_config">tls_config</a></code>. If missing or
NULL, certificates are not validated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An 'ncurlAio' (object of class 'ncurlAio' and 'recvAio') (invisibly).
The following elements may be accessed:
</p>

<ul>
<li> <p><code>$status</code> - integer HTTP repsonse status code (200 - OK).
Use <code><a href="#topic+status_code">status_code</a></code> for a translation of the meaning.
</p>
</li>
<li> <p><code>$headers</code> - named list of response headers supplied in
'response', or NULL otherwise. If the status code is within the 300
range, i.e. a redirect, the response header 'Location' is automatically
appended to return the redirect address.
</p>
</li>
<li> <p><code>$data</code> - the response body, as a character string if
'convert' = TRUE (may be further parsed as html, json, xml etc. as
required), or a raw byte vector if FALSE (use <code><a href="base.html#topic+writeBin">writeBin</a></code> to
save as a file).
</p>
</li></ul>



<h3>Promises</h3>

<p>&lsquo;ncurlAio&rsquo; may be used anywhere that accepts a &lsquo;promise&rsquo;
from the <a href="https://CRAN.R-project.org/package=promises"><span class="pkg">promises</span></a> package through the included
<code>as.promise</code> method.
</p>
<p>The promises created are completely event-driven and non-polling.
</p>
<p>If a status code of 200 (OK) is returned then the promise is resolved
with the reponse body, otherwise it is rejected with a translation of the
status code or &lsquo;errorValue&rsquo; as the case may be.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ncurl_session">ncurl_session</a></code> for persistent connections.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nc &lt;- ncurl_aio("https://www.r-project.org/",
                response = c("date", "server"),
                timeout = 2000L)
call_aio(nc)
nc$status
nc$headers
nc$data

if (interactive() &amp;&amp; requireNamespace("promises", quietly = TRUE)) {

p &lt;- as.promise(nc)
print(p)

p2 &lt;- ncurl_aio("https://postman-echo.com/get") %...&gt;% cat
is.promise(p2)

}

</code></pre>

<hr>
<h2 id='ncurl_session'>ncurl Session</h2><span id='topic+ncurl_session'></span><span id='topic+transact'></span>

<h3>Description</h3>

<p>nano cURL - a minimalist http(s) client. A session encapsulates a connection,
along with all related parameters, and may be used to return data
multiple times by repeatedly calling <code>transact</code>, which transacts
once over the connection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ncurl_session(
  url,
  convert = TRUE,
  method = NULL,
  headers = NULL,
  data = NULL,
  response = NULL,
  timeout = NULL,
  tls = NULL
)

transact(session)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ncurl_session_+3A_url">url</code></td>
<td>
<p>the URL address.</p>
</td></tr>
<tr><td><code id="ncurl_session_+3A_convert">convert</code></td>
<td>
<p>[default TRUE] logical value whether to attempt conversion of
the received raw bytes to a character vector. Set to FALSE if downloading
non-text data.</p>
</td></tr>
<tr><td><code id="ncurl_session_+3A_method">method</code></td>
<td>
<p>(optional) the HTTP method (defaults to 'GET' if not specified).</p>
</td></tr>
<tr><td><code id="ncurl_session_+3A_headers">headers</code></td>
<td>
<p>(optional) a named character vector specifying the HTTP
request headers, for example: <br />
<code>c(Authorization = "Bearer APIKEY", `Content-Type` = "text/plain")</code>
<br /> A non-character or non-named vector will be ignored.</p>
</td></tr>
<tr><td><code id="ncurl_session_+3A_data">data</code></td>
<td>
<p>(optional) character request data to be submitted.</p>
</td></tr>
<tr><td><code id="ncurl_session_+3A_response">response</code></td>
<td>
<p>(optional) a character vector specifying the response headers
to return e.g. <code>c("date", "server")</code>. These are case-insensitive and
will return NULL if not present. A non-character vector will be ignored.</p>
</td></tr>
<tr><td><code id="ncurl_session_+3A_timeout">timeout</code></td>
<td>
<p>(optional) integer value in milliseconds after which the
connection and subsequent transact attempts time out.</p>
</td></tr>
<tr><td><code id="ncurl_session_+3A_tls">tls</code></td>
<td>
<p>(optional) applicable to secure HTTPS sites only, a client TLS
Configuration object created by <code><a href="#topic+tls_config">tls_config</a></code>. If missing or
NULL, certificates are not validated.</p>
</td></tr>
<tr><td><code id="ncurl_session_+3A_session">session</code></td>
<td>
<p>an 'ncurlSession' object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>ncurl_session</code>: an 'ncurlSession' object if successful, or
else an 'errorValue'.
</p>
<p>For <code>transact</code>: a named list of 3 elements:
</p>

<ul>
<li> <p><code>$status</code> - integer HTTP repsonse status code (200 - OK).
Use <code><a href="#topic+status_code">status_code</a></code> for a translation of the meaning.
</p>
</li>
<li> <p><code>$headers</code> - named list of response headers (if specified in
the session), or NULL otherwise. If the status code is within the 300
range, i.e. a redirect, the response header 'Location' is automatically
appended to return the redirect address.
</p>
</li>
<li> <p><code>$data</code> - the response body as a character string (if
'convert = TRUE' was specified for the session), which may be further
parsed as html, json, xml etc. as required, or else a raw byte vector,
which may be saved as a file using <code><a href="base.html#topic+writeBin">writeBin</a></code>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+ncurl_aio">ncurl_aio</a></code> for asynchronous http requests.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- ncurl_session("https://www.r-project.org/", response = "date", timeout = 2000L)
s
if (!is_error_value(s)) transact(s)
if (!is_error_value(s)) close(s)

</code></pre>

<hr>
<h2 id='next_config'>Configure Next Mode</h2><span id='topic+next_config'></span>

<h3>Description</h3>

<p>Configures send mode &lsquo;next&rsquo; by registering functions for custom
serialization and unserialization of non-system reference objects,
allowing these to be sent and received between different R sessions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>next_config(refhook = list(), class = "", vec = FALSE, mark = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="next_config_+3A_refhook">refhook</code></td>
<td>
<p><strong>either</strong> a list or pairlist of two functions: the
signature for the first must accept a reference object inheriting from
&lsquo;class&rsquo; (or a list of such objects) and return a raw vector, and
the second must accept a raw vector and return reference objects (or a
list of such objects), <br /> <strong>or else</strong> NULL to reset.</p>
</td></tr>
<tr><td><code id="next_config_+3A_class">class</code></td>
<td>
<p>[default &quot;&quot;] a character string representing the class of object
that these serialization function will be applied to, e.g.
&lsquo;ArrowTabular&rsquo; or &lsquo;torch_tensor&rsquo;.</p>
</td></tr>
<tr><td><code id="next_config_+3A_vec">vec</code></td>
<td>
<p>[default FALSE] the serialization functions accept and return
reference object individually e.g. <code>arrow::write_to_raw</code> and
<code>arrow::read_ipc_stream</code>. If TRUE, the serialization functions are
vectorized and accept and return a list of reference objects, e.g.
<code>torch::torch_serialize</code> and <code>torch::torch_load</code>.</p>
</td></tr>
<tr><td><code id="next_config_+3A_mark">mark</code></td>
<td>
<p>[default FALSE] (for advanced use only) logical value, whether to
mark serialized data with a special bit.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calling this function without any arguments returns the pairlist of
currently-registered &lsquo;refhook&rsquo; functions (and resets &lsquo;mark&rsquo;
to FALSE).
</p>


<h3>Value</h3>

<p>A pairlist comprising the currently-registered &lsquo;refhook&rsquo;
functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- next_config(refhook = list(function(x) serialize(x, NULL), unserialize))
next_config()
next_config(g, mark = TRUE)

next_config(NULL)
next_config()

</code></pre>

<hr>
<h2 id='nng_error'>Translate Error Codes</h2><span id='topic+nng_error'></span>

<h3>Description</h3>

<p>Translate integer exit codes generated by the NNG library. All package
functions return an integer exit code on error rather than the expected
return value. These are classed &lsquo;errorValue&rsquo; and may be checked by
<code><a href="#topic+is_error_value">is_error_value</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nng_error(xc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nng_error_+3A_xc">xc</code></td>
<td>
<p>integer exit code to translate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string comprising the error code and error message
separated by &lsquo; | &rsquo;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nng_error(1L)

</code></pre>

<hr>
<h2 id='nng_version'>NNG Library Version</h2><span id='topic+nng_version'></span>

<h3>Description</h3>

<p>Returns the versions of the &lsquo;libnng&rsquo; and &lsquo;libmbedtls&rsquo; libraries
used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nng_version()
</code></pre>


<h3>Value</h3>

<p>A character vector of length 2.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nng_version()

</code></pre>

<hr>
<h2 id='opt'>Get and Set Options for a Socket, Context, Stream, Listener or Dialer</h2><span id='topic+opt'></span><span id='topic+opt+3C-'></span>

<h3>Description</h3>

<p>Get and set the value of options for a Socket, Context, Stream, Listener or
Dialer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opt(object, name)

opt(object, name) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opt_+3A_object">object</code></td>
<td>
<p>a Socket, Context, Stream, Listener or Dialer.</p>
</td></tr>
<tr><td><code id="opt_+3A_name">name</code></td>
<td>
<p>name of option, e.g. 'recv-buffer', as a character string. See
below options details.</p>
</td></tr>
<tr><td><code id="opt_+3A_value">value</code></td>
<td>
<p>value of option. Supply character type for 'string' options,
integer or double for 'int', 'duration', 'size' and 'uint64', and logical
for 'bool'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: once a dialer or listener has started, it is not generally
possible to change its configuration. Hence create the dialer or listener
with 'autostart = FALSE' if configuration needs to be set.
</p>
<p>To get or set options on a Listener or Dialer attached to a Socket or
nano object, pass in the objects directly via for example
<code>$listener[[1]]</code> for the first Listener.
</p>
<p>Some options are only meaningful or supported in certain contexts; for
example there is no single meaningful address for a socket, since sockets
can have multiple dialers and endpoints associated with them.
</p>
<p>For an authoritative guide please refer to the online documentation for
the NNG library at <a href="https://nng.nanomsg.org/man/">https://nng.nanomsg.org/man/</a>.
</p>


<h3>Value</h3>

<p>The value of the option (logical for type 'bool', integer for 'int',
'duration' and 'size', character for 'string', and double for 'uint64').
</p>


<h3>Global Options</h3>


<ul>
<li><p> 'reconnect-time-min' [type 'ms']
</p>
<p>This is the minimum amount of time (milliseconds) to wait before
attempting to establish a connection after a previous attempt has
failed. This can be set on a socket, but it can also be overridden on
an individual dialer. The option is irrelevant for listeners.
</p>
</li>
<li><p> 'reconnect-time-max' [type 'ms']
</p>
<p>This is the maximum amount of time (milliseconds) to wait before
attempting to establish a connection after a previous attempt has
failed. If this is non-zero, then the time between successive
connection attempts will start at the value of 'reconnect-time-min',
and grow exponentially, until it reaches this value. If this value is
zero, then no exponential back-off between connection attempts is done,
and each attempt will wait the time specified by 'reconnect-time-min'.
This can be set on a socket, but it can also be overridden on an
individual dialer. The option is irrelevant for listeners.
</p>
</li>
<li><p> 'recv-size-max' [type 'size']
</p>
<p>This is the maximum message size that the will be accepted from a
remote peer. If a peer attempts to send a message larger than this,
then the message will be discarded. If the value of this is zero, then
no limit on message sizes is enforced. This option exists to prevent
certain kinds of denial-of-service attacks, where a malicious agent
can claim to want to send an extraordinarily large message, without
sending any data. This option can be set for the socket, but may be
overridden for on a per-dialer or per-listener basis.
NOTE: Applications on hostile networks should set this to a non-zero
value to prevent denial-of-service attacks.
NOTE: Some transports may have further message size restrictions.
</p>
</li>
<li><p> 'recv-buffer' [type 'int']
</p>
<p>This is the depth of the sockets receive buffer as a number of
messages. Messages received by a transport may be buffered until the
application has accepted them for delivery. This value must be an
integer between 0 and 8192, inclusive. NOTE: Not all protocols support
buffering received messages. For example req can only deal with a
single reply at a time.
</p>
</li>
<li><p> 'recv-timeout' [type 'ms']
</p>
<p>This is the socket receive timeout in milliseconds. When no message is
available for receiving at the socket for this period of time, receive
operations will fail with a return value of 5L ('timed out').
</p>
</li>
<li><p> 'send-buffer' [type 'int']
</p>
<p>This is the depth of the socket send buffer as a number of messages.
Messages sent by an application may be buffered by the socket until a
transport is ready to accept them for delivery. This value must be an
integer between 0 and 8192, inclusive.
NOTE: Not all protocols support buffering sent messages; generally
multicast protocols like pub will simply discard messages when they
cannot be delivered immediately.
</p>
</li>
<li><p> 'send-timeout' [type 'ms']
</p>
<p>This is the socket send timeout in milliseconds. When a message cannot
be queued for delivery by the socket for this period of time (such as
if send buffers are full), the operation will fail with a return value
of 5L ('timed out').
</p>
</li>
<li><p> 'socket-name' [type 'string']
</p>
<p>This is the socket name. By default this is a string corresponding to
the value of the socket. The string must fit within 64-bytes, including
the terminating NUL byte. The value is intended for application use,
and is not used for anything in the library itself.
</p>
</li>
<li><p> 'url' [type 'string']
</p>
<p>This read-only option is used on a listener or dialer to obtain the
URL with which it was configured.
</p>
</li></ul>



<h3>Protocol-specific Options</h3>


<ul>
<li><p> 'req:resend-time' [type 'ms']
</p>
<p>(Request protocol) When a new request is started, a timer of this
duration is also started. If no reply is received before this timer
expires, then the request will be resent. (Requests are also
automatically resent if the peer to whom the original request was sent
disconnects, or if a peer becomes available while the requester is
waiting for an available peer.)
</p>
</li>
<li><p> 'sub:subscribe' [type 'string']
</p>
<p>(Subscribe protocol) This option registers a topic that the subscriber
is interested in. Each incoming message is checked against the list of
subscribed topics. If the body begins with the entire set of bytes in
the topic, then the message is accepted. If no topic matches, then the
message is discarded. To receive all messages, set the topic to NULL.
</p>
</li>
<li><p> 'sub:unsubscribe' [type 'string']
</p>
<p>(Subscribe protocol) This option removes a topic from the subscription
list. Note that if the topic was not previously subscribed to with
'sub:subscribe' then an 'entry not found' error will result.
</p>
</li>
<li><p> 'sub:prefnew' [type 'bool']
</p>
<p>(Subscribe protocol) This option specifies the behavior of the
subscriber when the queue is full. When TRUE (the default), the
subscriber will make room in the queue by removing the oldest message.
When FALSE, the subscriber will reject messages if the message queue
does not have room.
</p>
</li>
<li><p> 'surveyor:survey-time' [type 'ms']
</p>
<p>(Surveyor protocol) Duration of surveys. When a new survey is started,
a timer of this duration is also started. Any responses arriving after
this time will be discarded. Attempts to receive after the timer expires
with no other surveys started will result in an 'incorrect state' error.
Attempts to receive when this timer expires will result in a 'timed
out' error.
</p>
</li></ul>



<h3>Transport-specific Options</h3>


<ul>
<li><p> 'ipc:permissions' [type 'int']
</p>
<p>(IPC transport) This option may be applied to a listener to configure
the permissions that are used on the UNIX domain socket created by that
listener. This property is only supported on POSIX systems. The value
is of type int, representing the normal permission bits on a file, such
as 0600 (typically meaning read-write to the owner, and no permissions
for anyone else.) The default is system-specific, most often 0644.
</p>
</li>
<li><p> 'tcp-nodelay' [type 'bool']
</p>
<p>(TCP transport) This option is used to disable (or enable) the use of
Nagle's algorithm for TCP connections. When TRUE (the default),
messages are sent immediately by the underlying TCP stream without
waiting to gather more data. When FALSE, Nagles algorithm is enabled,
and the TCP stream may wait briefly in an attempt to coalesce messages.
Nagles algorithm is useful on low-bandwidth connections to reduce
overhead, but it comes at a cost to latency. When used on a dialer or
a listener, the value affects how newly created connections will be
configured.
</p>
</li>
<li><p> 'tcp-keepalive' [type 'bool']
</p>
<p>(TCP transport) This option is used to enable the sending of keep-alive
messages on the underlying TCP stream. This option is FALSE by default.
When enabled, if no messages are seen for a period of time, then a zero
length TCP message is sent with the ACK flag set in an attempt to tickle
some traffic from the peer. If none is still seen (after some
platform-specific number of retries and timeouts), then the remote peer
is presumed dead, and the connection is closed. When used on a dialer
or a listener, the value affects how newly created connections will be
configured. This option has two purposes. First, it can be used to
detect dead peers on an otherwise quiescent network. Second, it can be
used to keep connection table entries in NAT and other middleware from
expiring due to lack of activity.
</p>
</li>
<li><p> 'tcp-bound-port' [type 'int']
</p>
<p>(TCP transport) Local TCP port number. This is used on a listener, and
is intended to be used after starting the listener in combination with
a wildcard (0) local port. This determines the actual ephemeral port
that was selected and bound. The value is provided as an integer, but
only the low order 16 bits will be set, and is in native byte order for
convenience.
</p>
</li>
<li><p> 'ws:request-headers' [type 'string']
</p>
<p>(WebSocket transport) Concatenation of multiple lines terminated by
CRLF sequences, that can be used to add further headers to the HTTP
request sent when connecting. This option can be set on dialers, and
must be done before the transport is started.
</p>
</li>
<li><p> 'ws:response-headers' [type 'string']
</p>
<p>(WebSocket transport) Concatenation of multiple lines terminated by
CRLF sequences, that can be used to add further headers to the HTTP
response sent when connecting. This option can be set on listeners,
and must be done before the transport is started.
</p>
</li>
<li><p> 'ws:request-uri' [type 'string']
</p>
<p>(WebSocket transport) For obtaining the URI sent by the client. This
can be useful when a handler supports an entire directory tree.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- socket("pair")
opt(s, "send-buffer")
close(s)

s &lt;- socket("req")
ctx &lt;- context(s)
opt(ctx, "send-timeout")
close(ctx)
close(s)

s &lt;- socket("pair", dial = "inproc://nanonext", autostart = FALSE)
opt(s$dialer[[1]], "reconnect-time-min")
close(s)

s &lt;- socket("pair", listen = "inproc://nanonext", autostart = FALSE)
opt(s$listener[[1]], "recv-size-max")
close(s)

s &lt;- socket("pair")
opt(s, "recv-timeout") &lt;- 2000
close(s)

s &lt;- socket("req")
ctx &lt;- context(s)
opt(ctx, "send-timeout") &lt;- 2000
close(ctx)
close(s)

s &lt;- socket("pair", dial = "inproc://nanonext", autostart = FALSE)
opt(s$dialer[[1]], "reconnect-time-min") &lt;- 2000
start(s$dialer[[1]])
close(s)

s &lt;- socket("pair", listen = "inproc://nanonext", autostart = FALSE)
opt(s$listener[[1]], "recv-size-max") &lt;- 1024
start(s$listener[[1]])
close(s)

</code></pre>

<hr>
<h2 id='parse_url'>Parse URL</h2><span id='topic+parse_url'></span>

<h3>Description</h3>

<p>Parses a character string containing an RFC 3986 compliant URL as per NNG.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_url(url)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_url_+3A_url">url</code></td>
<td>
<p>character string containing a URL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named character vector of length 10, comprising:
</p>

<ul>
<li> <p><code>rawurl</code> - the unparsed URL string.
</p>
</li>
<li> <p><code>scheme</code> - the URL scheme, such as &quot;http&quot; or &quot;inproc&quot;
(always lower case).
</p>
</li>
<li> <p><code>userinfo</code> - the username and password if supplied in the
URL string.
</p>
</li>
<li> <p><code>host</code> - the full host part of the URL, including the port
if present (separated by a colon).
</p>
</li>
<li> <p><code>hostname</code> - the name of the host.
</p>
</li>
<li> <p><code>port</code> - the port (if not specified, the default port if
defined by the scheme).
</p>
</li>
<li> <p><code>path</code> - the path, typically used with HTTP or WebSocket.
</p>
</li>
<li> <p><code>query</code> - the query info (typically following ? in the URL).
</p>
</li>
<li> <p><code>fragment</code> - used for specifying an anchor, the part after #
in a URL.
</p>
</li>
<li> <p><code>requri</code> - the full Request-URI (path[?query][#fragment]).
</p>
</li></ul>

<p>Values that cannot be determined are represented by an empty string
<code>''</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parse_url("https://user:password@w3.org:8080/type/path?q=info#intro")
parse_url("tcp://192.168.0.2:5555")

</code></pre>

<hr>
<h2 id='pipe_notify'>Pipe Notify</h2><span id='topic+pipe_notify'></span>

<h3>Description</h3>

<p>Signals a &lsquo;conditionVariable&rsquo; whenever pipes (individual connections)
are added or removed at a socket.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pipe_notify(socket, cv, cv2 = NULL, add = FALSE, remove = FALSE, flag = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pipe_notify_+3A_socket">socket</code></td>
<td>
<p>a Socket.</p>
</td></tr>
<tr><td><code id="pipe_notify_+3A_cv">cv</code></td>
<td>
<p>a &lsquo;conditionVariable&rsquo; to signal, or NULL to cancel a
previously set signal.</p>
</td></tr>
<tr><td><code id="pipe_notify_+3A_cv2">cv2</code></td>
<td>
<p>[default NULL] optionally, if specified, a second
&lsquo;conditionVariable&rsquo; to signal. Note that this cv is signalled
sequentially after the first condition variable.</p>
</td></tr>
<tr><td><code id="pipe_notify_+3A_add">add</code></td>
<td>
<p>[default FALSE] logical value whether to signal (or cancel signal)
when a pipe is added.</p>
</td></tr>
<tr><td><code id="pipe_notify_+3A_remove">remove</code></td>
<td>
<p>[default FALSE] logical value whether to signal (or cancel
signal) when a pipe is removed.</p>
</td></tr>
<tr><td><code id="pipe_notify_+3A_flag">flag</code></td>
<td>
<p>[default FALSE] logical value whether to also set a flag in the
&lsquo;conditionVariable&rsquo;. This can help distinguish between different
types of signal, and causes any subsequent <code><a href="#topic+wait">wait</a></code> to return
FALSE instead of TRUE. If a signal from the <span class="pkg">tools</span> package, e.g.
<code>tools::SIGINT</code>, or an equivalent integer value is supplied, this
sets a flag and additionally raises this signal upon the flag being set.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For add: this event occurs after the pipe is fully added to the
socket. Prior to this time, it is not possible to communicate over the
pipe with the socket.
</p>
<p>For remove: this event occurs after the pipe has been removed from the
socket. The underlying transport may be closed at this point, and it is
not possible to communicate using this pipe.
</p>


<h3>Value</h3>

<p>Invisibly, zero on success (will otherwise error).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- socket(listen = "inproc://nanopipe")
cv &lt;- cv()
cv2 &lt;- cv()

pipe_notify(s, cv, cv2, add = TRUE, remove = TRUE, flag = TRUE)
cv_value(cv)
cv_value(cv2)

s1 &lt;- socket(dial = "inproc://nanopipe")
cv_value(cv)
cv_value(cv2)
reap(s1)
cv_value(cv)
cv_value(cv2)

pipe_notify(s, NULL, add = TRUE, remove = TRUE)
s1 &lt;- socket(dial = "inproc://nanopipe")
cv_value(cv)
cv_value(cv2)
reap(s1)

(wait(cv))
(wait(cv2))

close(s)

</code></pre>

<hr>
<h2 id='protocols'>Protocols [Documentation]</h2><span id='topic+protocols'></span>

<h3>Description</h3>

<p>Protocols implemented by <span class="pkg">nanonext</span>.
</p>
<p>For an authoritative guide please refer to the online documentation for
the NNG library at <a href="https://nng.nanomsg.org/man/">https://nng.nanomsg.org/man/</a>.
</p>


<h3>Bus (mesh networks)</h3>

<p>[protocol, bus] The bus protocol is useful for routing applications or
for building mesh networks where every peer is connected to every other
peer.
</p>
<p>In this protocol, each message sent by a node is sent to every one
of its directly-connected peers. This protocol may be used to send and
receive messages. Sending messages will attempt to deliver to each
directly connected peer. Indirectly-connected peers will not receive
messages. When using this protocol to build mesh networks, it is
therefore important that a fully-connected mesh network be constructed.
</p>
<p>All message delivery in this pattern is best-effort, which means that
peers may not receive messages. Furthermore, delivery may occur to some,
all, or none of the directly connected peers (messages are not delivered
when peer nodes are unable to receive). Hence, send operations will never
block; instead if the message cannot be delivered for any reason it is
discarded.
</p>


<h3>Pair (two-way radio)</h3>

<p>[protocol, pair] The pair protocol implements a peer-to-peer pattern,
where relationships between peers are one-to-one. Only one peer may be
connected to another peer at a time, but both may send and receive
messages freely.
</p>
<p>Normally, this pattern will block when attempting to send a message
if no peer is able to receive the message.
</p>


<h3>Push/Pull (one-way pipeline)</h3>

<p>In the pipeline pattern, pushers distribute messages to pullers, hence
useful for solving producer/consumer problems.
</p>
<p>If multiple peers are connected, the pattern attempts to distribute
fairly. Each message sent by a pusher will be sent to one of its peer
pullers, chosen in a round-robin fashion. This property makes this
pattern useful in load-balancing scenarios.
</p>
<p>[protocol, push] The push protocol is one half of a pipeline pattern. The
other side is the pull protocol.
</p>
<p>[protocol, pull] The pull protocol is one half of a pipeline pattern. The
other half is the push protocol.
</p>


<h3>Publisher/Subscriber (topics &amp; broadcast)</h3>

<p>In a publisher/subscriber pattern, a publisher sends data, which is
broadcast to all subscribers. The subscriber only see the data to which
they have subscribed.
</p>
<p>[protocol, pub] The pub protocol is one half of a publisher/subscriber
pattern. This protocol may be used to send messages, but is unable to
receive them.
</p>
<p>[protocol, sub] The sub protocol is one half of a publisher/subscriber
pattern. This protocol may be used to receive messages, but is unable to
send them.
</p>


<h3>Request/Reply (RPC)</h3>

<p>In a request/reply pattern, a requester sends a message to one replier,
who is expected to reply with a single answer. This is used for
synchronous communications, for example remote procedure calls (RPCs).
</p>
<p>The request is resent automatically if no reply arrives, until a reply is
received or the request times out.
</p>
<p>[protocol, req] The req protocol is one half of a request/reply pattern.
This socket may be used to send messages (requests), and then to receive
replies. Generally a reply can only be received after sending a request.
</p>
<p>[protocol, rep] The rep protocol is one half of a request/reply pattern.
This socket may be used to receive messages (requests), and then to send
replies. Generally a reply can only be sent after receiving a request.
</p>


<h3>Surveyor/Respondent (voting &amp; service discovery)</h3>

<p>In a survey pattern, a surveyor sends a survey, which is broadcast to all
peer respondents. The respondents then have a chance to reply (but are
not obliged). The survey itself is a timed event, so that responses
received after the survey has finished are discarded.
</p>
<p>[protocol, surveyor] The surveyor protocol is one half of a survey
pattern. This protocol may be used to send messages (surveys), and then
to receive replies. A reply can only be received after sending a survey.
A surveyor can normally expect to receive at most one reply from each
responder (messages may be duplicated in some topologies, so there is no
guarantee of this).
</p>
<p>[protocol, respondent] The respondent protocol is one half of a survey
pattern. This protocol may be used to receive messages, and then to send
replies. A reply can only be sent after receiving a survey, and generally
the reply will be sent to the surveyor from which the last survey was
received.
</p>

<hr>
<h2 id='random'>Random Data Generation</h2><span id='topic+random'></span>

<h3>Description</h3>

<p>Strictly not for use in statistical analysis. Non-reproducible and with
unknown statistical properties. Provides an alternative source of
randomness from the Mbed TLS library for purposes such as cryptographic
key generation. Mbed TLS uses a block-cipher in counter mode operation,
as defined in NIST SP800-90A: <em>Recommendation for Random Number
Generation Using Deterministic Random Bit Generators</em>. The implementation
uses AES-256 as the underlying block cipher, with a derivation function,
and an entropy collector combining entropy from multiple sources
including at least one strong entropy source.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random(n = 1L, convert = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random_+3A_n">n</code></td>
<td>
<p>[default 1L] integer random bytes to generate (from 0 to 1024).</p>
</td></tr>
<tr><td><code id="random_+3A_convert">convert</code></td>
<td>
<p>[default TRUE] logical FALSE to return a raw vector, or TRUE
to return the hex representation of the bytes as a character string.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If &lsquo;n&rsquo; is non-integer, it will be coerced to integer; if a
vector, only the first element will be used.
</p>


<h3>Value</h3>

<p>A length &lsquo;n&rsquo; raw vector, or length one vector of &lsquo;2n&rsquo;
random characters, depending on the value of &lsquo;convert&rsquo; supplied.
</p>


<h3>Note</h3>

<p>Results obtained are independent of and do not alter the state of R's
own pseudo-random number generators.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>random()
random(8L)
random(n = 8L, convert = FALSE)

</code></pre>

<hr>
<h2 id='reap'>Reap</h2><span id='topic+reap'></span>

<h3>Description</h3>

<p>An alternative to <code>close</code> for Sockets, Contexts, Listeners and Dialers
avoiding S3 method dispatch.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reap(con)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reap_+3A_con">con</code></td>
<td>
<p>a Socket, Context, Listener or Dialer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>May be used on unclassed external pointers e.g. those created by
<code><a href="#topic+.context">.context</a></code>. Returns silently and does not warn or error, nor
does it update the state of object attributes.
</p>


<h3>Value</h3>

<p>An integer exit code (zero on success).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+close">close</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- socket("req")
listen(s)
dial(s)
ctx &lt;- .context(s)

reap(ctx)
reap(s[["dialer"]][[1]])
reap(s[["listener"]][[1]])
reap(s)
reap(s)

</code></pre>

<hr>
<h2 id='recv'>Receive</h2><span id='topic+recv'></span>

<h3>Description</h3>

<p>Receive data over a connection (Socket, Context or Stream).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recv(
  con,
  mode = c("serial", "character", "complex", "double", "integer", "logical", "numeric",
    "raw", "string"),
  block = NULL,
  n = 65536L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recv_+3A_con">con</code></td>
<td>
<p>a Socket, Context or Stream.</p>
</td></tr>
<tr><td><code id="recv_+3A_mode">mode</code></td>
<td>
<p>[default 'serial'] character value or integer equivalent - one of
&lsquo;serial&rsquo; (1L), &lsquo;character&rsquo; (2L), &lsquo;complex&rsquo; (3L),
&lsquo;double&rsquo; (4L), &lsquo;integer&rsquo; (5L), &lsquo;logical&rsquo; (6L),
&lsquo;numeric&rsquo; (7L), &lsquo;raw&rsquo; (8L), or &lsquo;string&rsquo; (9L). The
default &lsquo;serial&rsquo; means a serialised R object; for the other modes,
received bytes are converted into the respective mode. &lsquo;string&rsquo; is
a faster option for length one character vectors. For Streams,
&lsquo;serial&rsquo; is not an option and the default is &lsquo;character&rsquo;.</p>
</td></tr>
<tr><td><code id="recv_+3A_block">block</code></td>
<td>
<p>[default NULL] which applies the connection default (see section
&lsquo;Blocking&rsquo; below). Specify logical TRUE to block until successful
or FALSE to return immediately even if unsuccessful (e.g. if no
connection is available), or else an integer value specifying the maximum
time to block in milliseconds, after which the operation will time out.</p>
</td></tr>
<tr><td><code id="recv_+3A_n">n</code></td>
<td>
<p>[default 65536L] applicable to Streams only, the maximum number of
bytes to receive. Can be an over-estimate, but note that a buffer of this
size is reserved.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In case of an error, an integer &lsquo;errorValue&rsquo; is returned (to
be distiguishable from an integer message value). This can be verified
using <code><a href="#topic+is_error_value">is_error_value</a></code>.
</p>
<p>If an error occurred in unserialization or conversion of the message data
to the specified mode, a raw vector will be returned instead to allow
recovery (accompanied by a warning).
</p>


<h3>Value</h3>

<p>The received data in the &lsquo;mode&rsquo; specified.
</p>


<h3>Blocking</h3>

<p>For Sockets and Contexts: the default behaviour is non-blocking with
<code>block = FALSE</code>. This will return immediately with an error if no
messages are available.
</p>
<p>For Streams: the default behaviour is blocking with <code>block = TRUE</code>.
This will wait until a message is received. Set a timeout to ensure that
the function returns under all scenarios. As the underlying
implementation uses an asynchronous receive with a wait, it is
recommended to set a small positive value for <code>block</code> rather than
FALSE.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+recv_aio">recv_aio</a></code> for asynchronous receive.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s1 &lt;- socket("pair", listen = "inproc://nanonext")
s2 &lt;- socket("pair", dial = "inproc://nanonext")

send(s1, data.frame(a = 1, b = 2))
res &lt;- recv(s2)
res
send(s1, data.frame(a = 1, b = 2))
recv(s2)

send(s1, c(1.1, 2.2, 3.3), mode = "raw")
res &lt;- recv(s2, mode = "double", block = 100)
res
send(s1, "example message", mode = "raw")
recv(s2, mode = "character")

close(s1)
close(s2)

req &lt;- socket("req", listen = "inproc://nanonext")
rep &lt;- socket("rep", dial = "inproc://nanonext")

ctxq &lt;- context(req)
ctxp &lt;- context(rep)
send(ctxq, data.frame(a = 1, b = 2), block = 100)
recv(ctxp, block = 100)

send(ctxq, c(1.1, 2.2, 3.3), mode = "raw", block = 100)
recv(ctxp, mode = "double", block = 100)

close(req)
close(rep)

</code></pre>

<hr>
<h2 id='recv_aio'>Receive Async</h2><span id='topic+recv_aio'></span>

<h3>Description</h3>

<p>Receive data asynchronously over a connection (Socket, Context or Stream).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recv_aio(
  con,
  mode = c("serial", "character", "complex", "double", "integer", "logical", "numeric",
    "raw", "string"),
  timeout = NULL,
  cv = NULL,
  n = 65536L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recv_aio_+3A_con">con</code></td>
<td>
<p>a Socket, Context or Stream.</p>
</td></tr>
<tr><td><code id="recv_aio_+3A_mode">mode</code></td>
<td>
<p>[default 'serial'] character value or integer equivalent - one of
&lsquo;serial&rsquo; (1L), &lsquo;character&rsquo; (2L), &lsquo;complex&rsquo; (3L),
&lsquo;double&rsquo; (4L), &lsquo;integer&rsquo; (5L), &lsquo;logical&rsquo; (6L),
&lsquo;numeric&rsquo; (7L), &lsquo;raw&rsquo; (8L), or &lsquo;string&rsquo; (9L). The
default &lsquo;serial&rsquo; means a serialised R object; for the other modes,
received bytes are converted into the respective mode. &lsquo;string&rsquo; is
a faster option for length one character vectors. For Streams,
&lsquo;serial&rsquo; is not an option and the default is &lsquo;character&rsquo;.</p>
</td></tr>
<tr><td><code id="recv_aio_+3A_timeout">timeout</code></td>
<td>
<p>[default NULL] integer value in milliseconds or NULL, which
applies a socket-specific default, usually the same as no timeout.</p>
</td></tr>
<tr><td><code id="recv_aio_+3A_cv">cv</code></td>
<td>
<p>(optional) a &lsquo;conditionVariable&rsquo; to signal when the async
receive is complete.</p>
</td></tr>
<tr><td><code id="recv_aio_+3A_n">n</code></td>
<td>
<p>[default 65536L] applicable to Streams only, the maximum number of
bytes to receive. Can be an over-estimate, but note that a buffer of this
size is reserved.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Async receive is always non-blocking and returns a &lsquo;recvAio&rsquo;
immediately.
</p>
<p>For a &lsquo;recvAio&rsquo;, the received message is available at <code>$data</code>.
An &lsquo;unresolved&rsquo; logical NA is returned if the async operation is
yet to complete.
</p>
<p>To wait for the async operation to complete and retrieve the received
message, use <code><a href="#topic+call_aio">call_aio</a></code> on the returned &lsquo;recvAio&rsquo;
object.
</p>
<p>Alternatively, to stop the async operation, use <code><a href="#topic+stop_aio">stop_aio</a></code>.
</p>
<p>In case of an error, an integer &lsquo;errorValue&rsquo; is returned (to be
distiguishable from an integer message value). This can be checked using
<code><a href="#topic+is_error_value">is_error_value</a></code>.
</p>
<p>If an error occurred in unserialization or conversion of the message data
to the specified mode, a raw vector will be returned instead to allow
recovery (accompanied by a warning).
</p>


<h3>Value</h3>

<p>A &lsquo;recvAio&rsquo; (object of class &lsquo;recvAio&rsquo;) (invisibly).
</p>


<h3>Signalling</h3>

<p>By supplying a &lsquo;conditionVariable&rsquo;, when the receive is complete,
the &lsquo;conditionVariable&rsquo; is signalled by incrementing its value by
1. This happens asynchronously and independently of the R execution
thread.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s1 &lt;- socket("pair", listen = "inproc://nanonext")
s2 &lt;- socket("pair", dial = "inproc://nanonext")

res &lt;- send_aio(s1, data.frame(a = 1, b = 2), timeout = 100)
msg &lt;- recv_aio(s2, timeout = 100)
msg
msg$data

res &lt;- send_aio(s1, c(1.1, 2.2, 3.3), mode = "raw", timeout = 100)
msg &lt;- recv_aio(s2, mode = "double", timeout = 100)
msg
msg$data

res &lt;- send_aio(s1, "example message", mode = "raw", timeout = 100)
msg &lt;- recv_aio(s2, mode = "character", timeout = 100)
call_aio(msg)
msg$data

close(s1)
close(s2)

# Signalling a condition variable

s1 &lt;- socket("pair", listen = "tcp://127.0.0.1:6546")
cv &lt;- cv()
msg &lt;- recv_aio(s1, timeout = 100, cv = cv)
until(cv, 10L)
msg$data
close(s1)

# in another process in parallel
s2 &lt;- socket("pair", dial = "tcp://127.0.0.1:6546")
res &lt;- send_aio(s2, c(1.1, 2.2, 3.3), mode = "raw", timeout = 100)
close(s2)

</code></pre>

<hr>
<h2 id='reply'>Reply over Context (RPC Server for Req/Rep Protocol)</h2><span id='topic+reply'></span>

<h3>Description</h3>

<p>Implements an executor/server for the rep node of the req/rep protocol.
Awaits data, applies an arbitrary specified function, and returns the
result to the caller/client.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reply(
  context,
  execute,
  recv_mode = c("serial", "character", "complex", "double", "integer", "logical",
    "numeric", "raw"),
  send_mode = c("serial", "raw", "next"),
  timeout = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reply_+3A_context">context</code></td>
<td>
<p>a Context.</p>
</td></tr>
<tr><td><code id="reply_+3A_execute">execute</code></td>
<td>
<p>a function which takes the received (converted) data as its
first argument. Can be an anonymous function of the form
<code>function(x) do(x)</code>. Additional arguments can also be passed in
through &lsquo;...&rsquo;.</p>
</td></tr>
<tr><td><code id="reply_+3A_recv_mode">recv_mode</code></td>
<td>
<p>[default 'serial'] character value or integer equivalent -
one of &lsquo;serial&rsquo; (1L), &lsquo;character&rsquo; (2L), &lsquo;complex&rsquo;
(3L), &lsquo;double&rsquo; (4L), &lsquo;integer&rsquo; (5L), &lsquo;logical&rsquo; (6L),
&lsquo;numeric&rsquo; (7L), &lsquo;raw&rsquo; (8L), or &lsquo;string&rsquo; (9L). The
default &lsquo;serial&rsquo; means a serialised R object; for the other
modes, received bytes are converted into the respective mode.
&lsquo;string&rsquo; is a faster option for length one character vectors.</p>
</td></tr>
<tr><td><code id="reply_+3A_send_mode">send_mode</code></td>
<td>
<p>[default 'serial'] character value or integer equivalent -
one of &lsquo;serial&rsquo; (1L) to send serialised R objects, &lsquo;raw&rsquo;
(2L) to send atomic vectors of any type as a raw byte vector, or
&lsquo;next&rsquo; (3L) - see &lsquo;Send Modes&rsquo; section below.</p>
</td></tr>
<tr><td><code id="reply_+3A_timeout">timeout</code></td>
<td>
<p>[default NULL] integer value in milliseconds or NULL, which
applies a socket-specific default, usually the same as no timeout. Note
that this applies to receiving the request. The total elapsed time would
also include performing 'execute' on the received data. The timeout then
also applies to sending the result (in the event that the requestor has
become unavailable since sending the request).</p>
</td></tr>
<tr><td><code id="reply_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the function specified by 'execute'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Receive will block while awaiting a message to arrive and is usually
the desired behaviour. Set a timeout to allow the function to return
if no data is forthcoming.
</p>
<p>In the event of an error in either processing the messages or in
evaluation of the function with respect to the data, a nul byte <code>00</code>
(or serialized nul byte) will be sent in reply to the client to signal an
error. This is to be distinguishable from a possible return value.
<code><a href="#topic+is_nul_byte">is_nul_byte</a></code> can be used to test for a nul byte.
</p>


<h3>Value</h3>

<p>Integer exit code (zero on success).
</p>


<h3>Send Modes</h3>

<p>The default mode &lsquo;serial&rsquo; sends serialised R objects to ensure
perfect reproducibility within R. When receiving, the corresponding mode
&lsquo;serial&rsquo; should be used.
</p>
<p>Mode &lsquo;raw&rsquo; sends atomic vectors of any type as a raw byte vector,
and must be used when interfacing with external applications or raw
system sockets, where R serialization is not in use. When receiving, the
mode corresponding to the vector sent should be used.
</p>
<p>Mode &lsquo;next&rsquo; sends serialised R objects, with native extensions
enabled by <code><a href="#topic+next_config">next_config</a></code>. This configures custom
serialization and unserialization functions for reference objects. When
receiving, mode &lsquo;serial&rsquo; should be used as &lsquo;next&rsquo; sends are
fully compatible.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>req &lt;- socket("req", listen = "tcp://127.0.0.1:6546")
rep &lt;- socket("rep", dial = "tcp://127.0.0.1:6546")

ctxq &lt;- context(req)
ctxp &lt;- context(rep)

send(ctxq, 2022, block = 100)
reply(ctxp, execute = function(x) x + 1, send_mode = "raw", timeout = 100)
recv(ctxq, mode = "double", block = 100)

send(ctxq, 100, mode = "raw", block = 100)
reply(ctxp, recv_mode = "double", execute = log, base = 10, timeout = 100)
recv(ctxq, block = 100)

close(req)
close(rep)

</code></pre>

<hr>
<h2 id='request'>Request over Context (RPC Client for Req/Rep Protocol)</h2><span id='topic+request'></span>

<h3>Description</h3>

<p>Implements a caller/client for the req node of the req/rep protocol. Sends
data to the rep node (executor/server) and returns an Aio, which can be
called for the value when required.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>request(
  context,
  data,
  send_mode = c("serial", "raw", "next"),
  recv_mode = c("serial", "character", "complex", "double", "integer", "logical",
    "numeric", "raw", "string"),
  timeout = NULL,
  cv = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="request_+3A_context">context</code></td>
<td>
<p>a Context.</p>
</td></tr>
<tr><td><code id="request_+3A_data">data</code></td>
<td>
<p>an object (if send_mode = &lsquo;raw&rsquo;, a vector).</p>
</td></tr>
<tr><td><code id="request_+3A_send_mode">send_mode</code></td>
<td>
<p>[default 'serial'] character value or integer equivalent -
one of &lsquo;serial&rsquo; (1L) to send serialised R objects, &lsquo;raw&rsquo;
(2L) to send atomic vectors of any type as a raw byte vector, or
&lsquo;next&rsquo; (3L) - see &lsquo;Send Modes&rsquo; section below.</p>
</td></tr>
<tr><td><code id="request_+3A_recv_mode">recv_mode</code></td>
<td>
<p>[default 'serial'] character value or integer equivalent -
one of &lsquo;serial&rsquo; (1L), &lsquo;character&rsquo; (2L), &lsquo;complex&rsquo;
(3L), &lsquo;double&rsquo; (4L), &lsquo;integer&rsquo; (5L), &lsquo;logical&rsquo; (6L),
&lsquo;numeric&rsquo; (7L), &lsquo;raw&rsquo; (8L), or &lsquo;string&rsquo; (9L). The
default &lsquo;serial&rsquo; means a serialised R object; for the other
modes, received bytes are converted into the respective mode.
&lsquo;string&rsquo; is a faster option for length one character vectors.</p>
</td></tr>
<tr><td><code id="request_+3A_timeout">timeout</code></td>
<td>
<p>[default NULL] integer value in milliseconds or NULL, which
applies a socket-specific default, usually the same as no timeout.</p>
</td></tr>
<tr><td><code id="request_+3A_cv">cv</code></td>
<td>
<p>(optional) a &lsquo;conditionVariable&rsquo; to signal when the async
receive is complete, or NULL. If any other value is supplied, this will
cause the pipe connection to be dropped when the async receive is
complete.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sending the request and receiving the result are both performed
async, hence the function will return immediately with a &lsquo;recvAio&rsquo;
object. Access the return value at <code>$data</code>.
</p>
<p>This is designed so that the process on the server can run concurrently
without blocking the client.
</p>
<p>Optionally use <code><a href="#topic+call_aio">call_aio</a></code> on the &lsquo;recvAio&rsquo; to call
(and wait for) the result.
</p>
<p>If an error occured in the server process, a nul byte <code>00</code> will be
received. This allows an error to be easily distinguished from a NULL
return value. <code><a href="#topic+is_nul_byte">is_nul_byte</a></code> can be used to test for a nul
byte.
</p>
<p>It is recommended to use a new context for each request to ensure
consistent state tracking. For safety, the context used for the request
is closed when all references to the returned &lsquo;recvAio&rsquo; are
removed and the object is garbage collected.
</p>


<h3>Value</h3>

<p>A &lsquo;recvAio&rsquo; (object of class &lsquo;mirai&rsquo; and
&lsquo;recvAio&rsquo;) (invisibly).
</p>


<h3>Send Modes</h3>

<p>The default mode &lsquo;serial&rsquo; sends serialised R objects to ensure
perfect reproducibility within R. When receiving, the corresponding mode
&lsquo;serial&rsquo; should be used.
</p>
<p>Mode &lsquo;raw&rsquo; sends atomic vectors of any type as a raw byte vector,
and must be used when interfacing with external applications or raw
system sockets, where R serialization is not in use. When receiving, the
mode corresponding to the vector sent should be used.
</p>
<p>Mode &lsquo;next&rsquo; sends serialised R objects, with native extensions
enabled by <code><a href="#topic+next_config">next_config</a></code>. This configures custom
serialization and unserialization functions for reference objects. When
receiving, mode &lsquo;serial&rsquo; should be used as &lsquo;next&rsquo; sends are
fully compatible.
</p>


<h3>Signalling</h3>

<p>By supplying a &lsquo;conditionVariable&rsquo;, when the receive is complete,
the &lsquo;conditionVariable&rsquo; is signalled by incrementing its value by
1. This happens asynchronously and independently of the R execution
thread.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# works if req and rep are running in parallel in different processes

req &lt;- socket("req", listen = "tcp://127.0.0.1:6546")
rep &lt;- socket("rep", dial = "tcp://127.0.0.1:6546")

reply(.context(rep), execute = function(x) x + 1, timeout = 50)
aio &lt;- request(.context(req), data = 2022)
aio$data

close(req)
close(rep)

# Signalling a condition variable

req &lt;- socket("req", listen = "tcp://127.0.0.1:6546")
ctxq &lt;- context(req)
cv &lt;- cv()
aio &lt;- request(ctxq, data = 2022, cv = cv)
until(cv, 10L)
close(req)

# The following should be run in another process
rep &lt;- socket("rep", dial = "tcp://127.0.0.1:6546")
ctxp &lt;- context(rep)
reply(ctxp, execute = function(x) x + 1)
close(rep)


## End(Not run)

</code></pre>

<hr>
<h2 id='send'>Send</h2><span id='topic+send'></span>

<h3>Description</h3>

<p>Send data over a connection (Socket, Context or Stream).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>send(con, data, mode = c("serial", "raw", "next"), block = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="send_+3A_con">con</code></td>
<td>
<p>a Socket, Context or Stream.</p>
</td></tr>
<tr><td><code id="send_+3A_data">data</code></td>
<td>
<p>an object (a vector, if mode = &lsquo;raw&rsquo;).</p>
</td></tr>
<tr><td><code id="send_+3A_mode">mode</code></td>
<td>
<p>[default 'serial'] character value or integer equivalent - one of
&lsquo;serial&rsquo; (1L) to send serialised R objects, &lsquo;raw&rsquo; (2L) to
send atomic vectors of any type as a raw byte vector, or &lsquo;next&rsquo;
(3L) - see &lsquo;Send Modes&rsquo; section below. For Streams, &lsquo;raw&rsquo;
is the only option and this argument is ignored.</p>
</td></tr>
<tr><td><code id="send_+3A_block">block</code></td>
<td>
<p>[default NULL] which applies the connection default (see section
&lsquo;Blocking&rsquo; below). Specify logical TRUE to block until successful
or FALSE to return immediately even if unsuccessful (e.g. if no
connection is available), or else an integer value specifying the maximum
time to block in milliseconds, after which the operation will time out.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Integer exit code (zero on success).
</p>


<h3>Blocking</h3>

<p>For Sockets and Contexts: the default behaviour is non-blocking with
<code>block = FALSE</code>. This will return immediately with an error if the
message could not be queued for sending. Certain protocol / transport
combinations may limit the number of messages that can be queued if they
have yet to be received.
</p>
<p>For Streams: the default behaviour is blocking with <code>block = TRUE</code>.
This will wait until the send has completed. Set a timeout to ensure that
the function returns under all scenarios. As the underlying
implementation uses an asynchronous send with a wait, it is recommended
to set a small positive value for <code>block</code> rather than FALSE.
</p>


<h3>Send Modes</h3>

<p>The default mode &lsquo;serial&rsquo; sends serialised R objects to ensure
perfect reproducibility within R. When receiving, the corresponding mode
&lsquo;serial&rsquo; should be used.
</p>
<p>Mode &lsquo;raw&rsquo; sends atomic vectors of any type as a raw byte vector,
and must be used when interfacing with external applications or raw
system sockets, where R serialization is not in use. When receiving, the
mode corresponding to the vector sent should be used.
</p>
<p>Mode &lsquo;next&rsquo; sends serialised R objects, with native extensions
enabled by <code><a href="#topic+next_config">next_config</a></code>. This configures custom
serialization and unserialization functions for reference objects. When
receiving, mode &lsquo;serial&rsquo; should be used as &lsquo;next&rsquo; sends are
fully compatible.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+send_aio">send_aio</a></code> for asynchronous send.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pub &lt;- socket("pub", dial = "inproc://nanonext")

send(pub, data.frame(a = 1, b = 2))
send(pub, c(10.1, 20.2, 30.3), mode = "raw", block = 100)

close(pub)

req &lt;- socket("req", listen = "inproc://nanonext")
rep &lt;- socket("rep", dial = "inproc://nanonext")

ctx &lt;- context(req)
send(ctx, data.frame(a = 1, b = 2), block = 100)

msg &lt;- recv_aio(rep, timeout = 100)
send(ctx, c(1.1, 2.2, 3.3), mode = "raw", block = 100)

close(req)
close(rep)

</code></pre>

<hr>
<h2 id='send_aio'>Send Async</h2><span id='topic+send_aio'></span>

<h3>Description</h3>

<p>Send data asynchronously over a connection (Socket, Context or Stream).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>send_aio(con, data, mode = c("serial", "raw", "next"), timeout = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="send_aio_+3A_con">con</code></td>
<td>
<p>a Socket, Context or Stream.</p>
</td></tr>
<tr><td><code id="send_aio_+3A_data">data</code></td>
<td>
<p>an object (a vector, if mode = &lsquo;raw&rsquo;).</p>
</td></tr>
<tr><td><code id="send_aio_+3A_mode">mode</code></td>
<td>
<p>[default 'serial'] character value or integer equivalent - one of
&lsquo;serial&rsquo; (1L) to send serialised R objects, &lsquo;raw&rsquo; (2L) to
send atomic vectors of any type as a raw byte vector, or &lsquo;next&rsquo;
(3L) - see &lsquo;Send Modes&rsquo; section below. For Streams, &lsquo;raw&rsquo;
is the only option and this argument is ignored.</p>
</td></tr>
<tr><td><code id="send_aio_+3A_timeout">timeout</code></td>
<td>
<p>[default NULL] integer value in milliseconds or NULL, which
applies a socket-specific default, usually the same as no timeout.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Async send is always non-blocking and returns a &lsquo;sendAio&rsquo;
immediately.
</p>
<p>For a &lsquo;sendAio&rsquo;, the send result is available at <code>$result</code>.
An &lsquo;unresolved&rsquo; logical NA is returned if the async operation is
yet to complete. The resolved value will be zero on success, or else an
integer error code.
</p>
<p>To wait for and check the result of the send operation, use
<code><a href="#topic+call_aio">call_aio</a></code> on the returned &lsquo;sendAio&rsquo; object.
</p>
<p>Alternatively, to stop the async operation, use <code><a href="#topic+stop_aio">stop_aio</a></code>.
</p>


<h3>Value</h3>

<p>A &lsquo;sendAio&rsquo; (object of class &lsquo;sendAio&rsquo;) (invisibly).
</p>


<h3>Send Modes</h3>

<p>The default mode &lsquo;serial&rsquo; sends serialised R objects to ensure
perfect reproducibility within R. When receiving, the corresponding mode
&lsquo;serial&rsquo; should be used.
</p>
<p>Mode &lsquo;raw&rsquo; sends atomic vectors of any type as a raw byte vector,
and must be used when interfacing with external applications or raw
system sockets, where R serialization is not in use. When receiving, the
mode corresponding to the vector sent should be used.
</p>
<p>Mode &lsquo;next&rsquo; sends serialised R objects, with native extensions
enabled by <code><a href="#topic+next_config">next_config</a></code>. This configures custom
serialization and unserialization functions for reference objects. When
receiving, mode &lsquo;serial&rsquo; should be used as &lsquo;next&rsquo; sends are
fully compatible.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pub &lt;- socket("pub", dial = "inproc://nanonext")

res &lt;- send_aio(pub, data.frame(a = 1, b = 2), timeout = 100)
res
res$result

res &lt;- send_aio(pub, "example message", mode = "raw", timeout = 100)
call_aio(res)$result

close(pub)

</code></pre>

<hr>
<h2 id='set_promise_context'>Set Promise Context</h2><span id='topic+set_promise_context'></span>

<h3>Description</h3>

<p>If called from an appropriate context, creates an event-driven promise that
will resolve asynchronously when the request is complete.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_promise_context(x, ctx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_promise_context_+3A_x">x</code></td>
<td>
<p>a 'recvAio' object returned by <code><a href="#topic+request">request</a></code>.</p>
</td></tr>
<tr><td><code id="set_promise_context_+3A_ctx">ctx</code></td>
<td>
<p>the context environment.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The object passed as &lsquo;x&rsquo; is returned regardless of whether
the promise context was set successfully or not. If successful,
&lsquo;x&rsquo; is modified in place with the promise context.
</p>


<h3>Value</h3>

<p>The object &lsquo;x&rsquo;.
</p>

<hr>
<h2 id='socket'>Open Socket</h2><span id='topic+socket'></span>

<h3>Description</h3>

<p>Open a Socket implementing &lsquo;protocol&rsquo;, and optionally dial (establish
an outgoing connection) or listen (accept an incoming connection) at an
address.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>socket(
  protocol = c("bus", "pair", "push", "pull", "pub", "sub", "req", "rep", "surveyor",
    "respondent"),
  dial = NULL,
  listen = NULL,
  tls = NULL,
  autostart = TRUE,
  raw = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="socket_+3A_protocol">protocol</code></td>
<td>
<p>[default 'bus'] choose protocol - &lsquo;bus&rsquo;, &lsquo;pair&rsquo;,
&lsquo;push&rsquo;, &lsquo;pull&rsquo;, &lsquo;pub&rsquo;, &lsquo;sub&rsquo;, &lsquo;req&rsquo;,
&lsquo;rep&rsquo;, &lsquo;surveyor&rsquo;, or &lsquo;respondent&rsquo; - see
<a href="#topic+protocols">protocols</a>.</p>
</td></tr>
<tr><td><code id="socket_+3A_dial">dial</code></td>
<td>
<p>(optional) a URL to dial, specifying the transport and address as
a character string e.g. 'inproc://anyvalue' or 'tcp://127.0.0.1:5555'
(see <a href="#topic+transports">transports</a>).</p>
</td></tr>
<tr><td><code id="socket_+3A_listen">listen</code></td>
<td>
<p>(optional) a URL to listen at, specifying the transport and
address as a character string e.g. 'inproc://anyvalue' or
'tcp://127.0.0.1:5555' (see <a href="#topic+transports">transports</a>).</p>
</td></tr>
<tr><td><code id="socket_+3A_tls">tls</code></td>
<td>
<p>[default NULL] for secure tls+tcp:// or wss:// connections only,
provide a TLS configuration object created by <code><a href="#topic+tls_config">tls_config</a></code>.</p>
</td></tr>
<tr><td><code id="socket_+3A_autostart">autostart</code></td>
<td>
<p>[default TRUE] whether to start the dialer/listener. Set to
FALSE if setting configuration options on the dialer/listener as it is
not generally possible to change these once started. For dialers only:
set to NA to start synchronously - this is less resilient if a
connection is not immediately possible, but avoids subtle errors from
attempting to use the socket before an asynchronous dial has completed.</p>
</td></tr>
<tr><td><code id="socket_+3A_raw">raw</code></td>
<td>
<p>[default FALSE] whether to open raw mode sockets. Note: not for
general use - do not enable unless you have a specific need (refer to NNG
documentation).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NNG presents a socket view of networking. The sockets are
constructed using protocol-specific functions, as a given socket
implements precisely one protocol.
</p>
<p>Each socket may be used to send and receive messages (if the protocol
supports it, and implements the appropriate protocol semantics). For
example, sub sockets automatically filter incoming messages to discard
those for topics that have not been subscribed.
</p>
<p>This function (optionally) binds a single Dialer and/or Listener to a
Socket. More complex network topologies may be created by binding further
Dialers/Listeners to the Socket as required using <code><a href="#topic+dial">dial</a></code> and
<code><a href="#topic+listen">listen</a></code>.
</p>
<p>New contexts may also be created using <code><a href="#topic+context">context</a></code> if the
protocol supports it.
</p>


<h3>Value</h3>

<p>A Socket (object of class &lsquo;nanoSocket&rsquo; and &lsquo;nano&rsquo;).
</p>


<h3>Protocols</h3>

<p>The following Scalability Protocols (communication patterns) are
implemented:
</p>

<ul>
<li><p> Bus (mesh networks) - protocol: 'bus'
</p>
</li>
<li><p> Pair (two-way radio) - protocol: 'pair'
</p>
</li>
<li><p> Pipeline (one-way pipe) - protocol: 'push', 'pull'
</p>
</li>
<li><p> Publisher/Subscriber (topics &amp; broadcast) - protocol: 'pub', 'sub'
</p>
</li>
<li><p> Request/Reply (RPC) - protocol: 'req', 'rep'
</p>
</li>
<li><p> Survey (voting &amp; service discovery) - protocol: 'surveyor',
'respondent'
</p>
</li></ul>

<p>Please see <a href="#topic+protocols">protocols</a> for further documentation.
</p>


<h3>Transports</h3>

<p>The following communications transports may be used:
</p>

<ul>
<li><p> Inproc (in-process) - url: 'inproc://'
</p>
</li>
<li><p> IPC (inter-process communications) - url: 'ipc://' (or
'abstract://' on Linux)
</p>
</li>
<li><p> TCP and TLS over TCP - url: 'tcp://' and 'tls+tcp://'
</p>
</li>
<li><p> WebSocket and TLS over WebSocket - url: 'ws://' and 'wss://'
</p>
</li></ul>

<p>Please see <a href="#topic+transports">transports</a> for further documentation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- socket(protocol = "req", listen = "inproc://nanosocket")
s
s1 &lt;- socket(protocol = "rep", dial = "inproc://nanosocket")
s1

send(s, "hello world!")
recv(s1)

close(s1)
close(s)

</code></pre>

<hr>
<h2 id='start'>Start Listener/Dialer</h2><span id='topic+start'></span><span id='topic+start.nanoListener'></span><span id='topic+start.nanoDialer'></span>

<h3>Description</h3>

<p>Start a Listener/Dialer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nanoListener'
start(x, ...)

## S3 method for class 'nanoDialer'
start(x, async = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="start_+3A_x">x</code></td>
<td>
<p>a Listener or Dialer.</p>
</td></tr>
<tr><td><code id="start_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
<tr><td><code id="start_+3A_async">async</code></td>
<td>
<p>[default TRUE] (applicable to Dialers only) logical flag whether
the connection attempt, including any name resolution, is to be made
asynchronously. This behaviour is more resilient, but also generally
makes diagnosing failures somewhat more difficult. If FALSE, failure,
such as if the connection is refused, will be returned immediately, and
no further action will be taken.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly, an integer exit code (zero on success).
</p>

<hr>
<h2 id='stat'>Get Statistic for a Socket, Listener or Dialer</h2><span id='topic+stat'></span>

<h3>Description</h3>

<p>Obtain value of a statistic for a Socket, Listener or Dialer. This function
exposes the stats interface of NNG.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat(object, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_+3A_object">object</code></td>
<td>
<p>a Socket, Listener or Dialer.</p>
</td></tr>
<tr><td><code id="stat_+3A_name">name</code></td>
<td>
<p>character name of statistic to return.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: the values of individual statistics are guaranteed to be
atomic, but due to the way statistics are collected there may be
discrepancies between them at times. For example, statistics counting
bytes and messages received may not reflect the same number of messages,
depending on when the snapshot is taken. This potential inconsistency
arises as a result of optimisations to minimise the impact of statistics
on actual operations.
</p>


<h3>Value</h3>

<p>The value of the statistic (character or double depending on the type
of statistic requested) if available, or else NULL.
</p>


<h3>Stats</h3>

<p>The following stats may be requested for a Socket:
</p>

<ul>
<li><p> 'id' - numeric id of the socket.
</p>
</li>
<li><p> 'name' - character socket name.
</p>
</li>
<li><p> 'protocol' - character protocol type e.g. 'bus'.
</p>
</li>
<li><p> 'pipes' - numeric number of pipes (active connections).
</p>
</li>
<li><p> 'dialers' - numeric number of listeners attached to the socket.
</p>
</li>
<li><p> 'listeners' - numeric number of dialers attached to the socket.
</p>
</li></ul>

<p>The following stats may be requested for a Listener / Dialer:
</p>

<ul>
<li><p> 'id' - numeric id of the listener / dialer.
</p>
</li>
<li><p> 'socket' - numeric id of the socket of the listener / dialer.
</p>
</li>
<li><p> 'url' - character URL address.
</p>
</li>
<li><p> 'pipes' - numeric number of pipes (active connections).
</p>
</li></ul>

<p>The following additional stats may be requested for a Listener:
</p>

<ul>
<li><p> 'accept' - numeric total number of connection attempts, whether
successful or not.
</p>
</li>
<li><p> 'reject' - numeric total number of rejected connection attempts
e.g. due to incompatible protocols.
</p>
</li></ul>

<p>The following additional stats may be requested for a Dialer:
</p>

<ul>
<li><p> 'connect' - numeric total number of connection attempts, whether
successful or not.
</p>
</li>
<li><p> 'reject' - numeric total number of rejected connection attempts
e.g. due to incompatible protocols.
</p>
</li>
<li><p> 'refused' - numeric total number of refused connections e.g. when
starting synchronously with no listener on the other side.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- socket("bus", listen = "inproc://stats")
stat(s, "pipes")

s1 &lt;- socket("bus", dial = "inproc://stats")
stat(s, "pipes")

close(s1)
stat(s, "pipes")

close(s)

</code></pre>

<hr>
<h2 id='status_code'>Translate HTTP Status Codes</h2><span id='topic+status_code'></span>

<h3>Description</h3>

<p>Provides an explanation for HTTP response status codes (in the range 100 to
599). If the status code is not defined as per RFC 9110,
&lsquo;Non-standard Response&rsquo; is returned, which may be a custom code
used by the server.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>status_code(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="status_code_+3A_x">x</code></td>
<td>
<p>numeric HTTP status code to translate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector comprising the status code and explanation
separated by &lsquo; | &rsquo;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>status_code(200)
status_code(404)

</code></pre>

<hr>
<h2 id='stop_aio'>Stop Asynchronous Aio Operation</h2><span id='topic+stop_aio'></span>

<h3>Description</h3>

<p>Stop an asynchronous Aio operation, or a list of Aio operations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_aio(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_aio_+3A_x">x</code></td>
<td>
<p>an Aio or list of Aios (objects of class &lsquo;sendAio&rsquo;,
&lsquo;recvAio&rsquo; or &lsquo;ncurlAio&rsquo;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Stops the asynchronous I/O operation associated with &lsquo;aio&rsquo; by
aborting, and then waits for it to complete or to be completely aborted,
and for the callback associated with the &lsquo;aio&rsquo; to have completed
executing. If successful, the &lsquo;aio&rsquo; will resolve to an
&lsquo;errorValue&rsquo; 20 (Operation canceled).
</p>
<p>Note this function operates silently and does not error even if
&lsquo;aio&rsquo; is not an active Aio, always returning invisible NULL.
</p>


<h3>Value</h3>

<p>Invisible NULL.
</p>

<hr>
<h2 id='stream'>Open Stream</h2><span id='topic+stream'></span>

<h3>Description</h3>

<p>Open a Stream by either dialing (establishing an outgoing connection) or
listening (accepting an incoming connection) at an address. This is a
low-level interface intended for communicating with non-NNG
endpoints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stream(dial = NULL, listen = NULL, textframes = FALSE, tls = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stream_+3A_dial">dial</code></td>
<td>
<p>a URL to dial, specifying the transport and address as a character
string e.g. 'ipc:///tmp/anyvalue' or 'tcp://127.0.0.1:5555'
(not all transports are supported).</p>
</td></tr>
<tr><td><code id="stream_+3A_listen">listen</code></td>
<td>
<p>a URL to listen at, specifying the transport and address as a
character string e.g. 'ipc:///tmp/anyvalue' or 'tcp://127.0.0.1:5555'
(not all transports are supported).</p>
</td></tr>
<tr><td><code id="stream_+3A_textframes">textframes</code></td>
<td>
<p>[default FALSE] applicable to the websocket transport only,
enables sending and receiving of TEXT frames (ignored otherwise).</p>
</td></tr>
<tr><td><code id="stream_+3A_tls">tls</code></td>
<td>
<p>(optional) applicable to secure websockets only, a client or
server TLS configuration object created by <code><a href="#topic+tls_config">tls_config</a></code>. If
missing or NULL, certificates are not validated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A Stream is used for raw byte stream connections. Byte streams are
reliable in that data will not be delivered out of order, or with portions
missing.
</p>
<p>Can be used to dial a (secure) websocket address starting 'ws://' or
'wss://'. It is often the case that 'textframes' needs to be set to TRUE.
</p>
<p>Specify only one of 'dial' or 'listen'. If both are specified, 'listen'
will be ignored.
</p>


<h3>Value</h3>

<p>A Stream (object of class &lsquo;nanoStream&rsquo; and &lsquo;nano&rsquo;).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will succeed only if there is an open connection at the address:
s &lt;- tryCatch(stream(dial = "tcp://127.0.0.1:5555"), error = identity)
s

</code></pre>

<hr>
<h2 id='subscribe'>Subscribe / Unsubscribe Topic</h2><span id='topic+subscribe'></span><span id='topic+unsubscribe'></span>

<h3>Description</h3>

<p>For a socket or context using the sub protocol in a publisher/subscriber
pattern. Set a topic to subscribe to, or remove a topic from the
subscription list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subscribe(con, topic = NULL)

unsubscribe(con, topic = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subscribe_+3A_con">con</code></td>
<td>
<p>a Socket or Context using the 'sub' protocol.</p>
</td></tr>
<tr><td><code id="subscribe_+3A_topic">topic</code></td>
<td>
<p>[default NULL] an atomic type or NULL. The default NULL
subscribes to all topics / unsubscribes from all topics (if all topics
were previously subscribed).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To use pub/sub the publisher must:
</p>

<ul>
<li><p> specify <code>mode = 'raw'</code> when sending.
</p>
</li>
<li><p> ensure the sent vector starts with the topic.
</p>
</li></ul>

<p>The subscriber should then receive specifying the correct mode.
</p>


<h3>Value</h3>

<p>Invisibly, the passed Socket or Context.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pub &lt;- socket("pub", listen = "inproc://nanonext")
sub &lt;- socket("sub", dial = "inproc://nanonext")

subscribe(sub, "examples")

send(pub, c("examples", "this is an example"), mode = "raw")
recv(sub, "character")
send(pub, "examples will also be received", mode = "raw")
recv(sub, "character")
send(pub, c("other", "this other topic will not be received"), mode = "raw")
recv(sub, "character")
unsubscribe(sub, "examples")
send(pub, c("examples", "this example is no longer received"), mode = "raw")
recv(sub, "character")

subscribe(sub, 2)
send(pub, c(2, 10, 10, 20), mode = "raw")
recv(sub, "double")
unsubscribe(sub, 2)
send(pub, c(2, 10, 10, 20), mode = "raw")
recv(sub, "double")

close(pub)
close(sub)

</code></pre>

<hr>
<h2 id='survey_time'>Set Survey Time</h2><span id='topic+survey_time'></span>

<h3>Description</h3>

<p>For a socket or context using the surveyor protocol in a surveyor/respondent
pattern. Set the survey timeout in milliseconds (remains valid for all
subsequent surveys). Messages received by the surveyor after the timer
has ended are discarded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survey_time(con, value = 1000L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="survey_time_+3A_con">con</code></td>
<td>
<p>a Socket or Context using the 'surveyor' protocol.</p>
</td></tr>
<tr><td><code id="survey_time_+3A_value">value</code></td>
<td>
<p>[default 1000L] integer survey timeout in milliseconds.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>After using this function, to start a new survey, the surveyor must:
</p>

<ul>
<li><p> send a message.
</p>
</li>
<li><p> switch to receiving responses.
</p>
</li></ul>

<p>To respond to a survey, the respondent must:
</p>

<ul>
<li><p> receive the survey message.
</p>
</li>
<li><p> send a reply using <code><a href="#topic+send_aio">send_aio</a></code> before the survey has
timed out (a reply can only be sent after receiving a survey).
</p>
</li></ul>



<h3>Value</h3>

<p>Invisibly, the passed Socket or Context.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sur &lt;- socket("surveyor", listen = "inproc://nanonext")
res &lt;- socket("respondent", dial = "inproc://nanonext")

survey_time(sur, 1000)

send(sur, "reply to this survey")
aio &lt;- recv_aio(sur)

recv(res)
s &lt;- send_aio(res, "replied")

call_aio(aio)$data

close(sur)
close(res)

</code></pre>

<hr>
<h2 id='tls_config'>Create TLS Configuration</h2><span id='topic+tls_config'></span>

<h3>Description</h3>

<p>Create a TLS configuration object to be used for secure connections. Specify
&lsquo;client&rsquo; to create a client configuration or &lsquo;server&rsquo; to
create a server configuration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tls_config(client = NULL, server = NULL, pass = NULL, auth = is.null(server))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tls_config_+3A_client">client</code></td>
<td>
<p><strong>either</strong> the character path to a file containing X.509
certificate(s) in PEM format, comprising the certificate authority
certificate chain (and revocation list if present), used to validate
certificates presented by peers,<br />
<strong>or</strong> a length 2 character vector comprising [i] the certificate
authority certificate chain and [ii] the certificate revocation list, or
empty string <code>''</code> if not applicable.</p>
</td></tr>
<tr><td><code id="tls_config_+3A_server">server</code></td>
<td>
<p><strong>either</strong> the character path to a file containing
the PEM-encoded TLS certificate and associated private key (may contain
additional certificates leading to a validation chain, with the leaf
certificate first),<br />
<strong>or</strong> a length 2 character vector comprising [i] the TLS certificate
(optionally certificate chain) and [ii] the associated private key.</p>
</td></tr>
<tr><td><code id="tls_config_+3A_pass">pass</code></td>
<td>
<p>(optional) required only if the secret key supplied to 'server'
is encrypted with a password. For security, consider providing through a
function that returns this value, rather than directly.</p>
</td></tr>
<tr><td><code id="tls_config_+3A_auth">auth</code></td>
<td>
<p>logical value whether to require authentication - by default TRUE
for client and FALSE for server configurations. If TRUE, the session is
only allowed to proceed if the peer has presented a certificate and it
has been validated. If FALSE, authentication is optional, whereby a
certificate is validated if presented by the peer, but the session
allowed to proceed otherwise. If neither 'client' nor 'server' are
supplied, then no authentication is performed and this argument has no
effect.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Specify one of &lsquo;client&rsquo; or &lsquo;server&rsquo; only, or neither
(in which case an empty client configuration is created), as a
configuration can only be of one type.
</p>
<p>For creating client configurations for public internet usage, root CA
ceritficates may usually be found at
&lsquo;<span class="file">/etc/ssl/certs/ca-certificates.crt</span>&rsquo; on Linux systems. Otherwise,
root CA certificates in PEM format are available at the Common CA
Database site run by Mozilla: <a href="https://www.ccadb.org/resources">https://www.ccadb.org/resources</a>
(select the Server Authentication SSL/TLS certificates text file).
<em>This link is not endorsed; use at your own risk.</em>
</p>


<h3>Value</h3>

<p>A &lsquo;tlsConfig&rsquo; object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tls &lt;- tls_config()
tls
ncurl("https://www.r-project.org/", timeout = 1000L, tls = tls)

</code></pre>

<hr>
<h2 id='transports'>Transports [Documentation]</h2><span id='topic+transports'></span>

<h3>Description</h3>

<p>Transports supported by <span class="pkg">nanonext</span>.
</p>
<p>For an authoritative guide please refer to the online documentation for
the NNG library at <a href="https://nng.nanomsg.org/man/">https://nng.nanomsg.org/man/</a>.
</p>


<h3>Inproc</h3>

<p>The inproc transport provides communication support between sockets
within the same process. This may be used as an alternative to slower
transports when data must be moved within the same process. This
transport tries hard to avoid copying data, and thus is very light-weight.
</p>
<p>[<strong>URI, inproc://</strong>] This transport uses URIs using the scheme
inproc://, followed by an arbitrary string of text, terminated by a NUL
byte. inproc://nanonext is a valid example URL.
</p>

<ul>
<li><p> Multiple URIs can be used within the same application, and they
will not interfere with one another.
</p>
</li>
<li><p> Two applications may also use the same URI without interfering with
each other, and they will be unable to communicate with each other using
that URI.
</p>
</li></ul>



<h3>IPC</h3>

<p>The IPC transport provides communication support between sockets
within different processes on the same host. For POSIX platforms, this is
implemented using UNIX domain sockets. For Windows, this is implemented
using Windows Named Pipes. Other platforms may have different
implementation strategies.
</p>
<p><em>Traditional Names</em>
</p>
<p>[<strong>URI, ipc://</strong>] This transport uses URIs using the scheme ipc://,
followed by a path name in the file system where the socket or named pipe
should be created.
</p>

<ul>
<li><p> On POSIX platforms, the path is taken literally, and is relative to
the current directory, unless it begins with /, in which case it is
relative to the root directory. For example, ipc://nanonext refers to the
name nanonext in the current directory, whereas ipc:///tmp/nanonext
refers to nanonext located in /tmp.
</p>
</li>
<li><p> On Windows, all names are prefixed by \.\ pipe\ and do not reside
in the normal file system - the required prefix is added automatically
by NNG, so a URL of the form ipc://nanonext is fine.
</p>
</li></ul>

<p><em>UNIX Aliases</em>
</p>
<p>[<strong>URI, unix://</strong>] The unix:// scheme is an alias for ipc:// and can
be used inter-changeably, but only on POSIX systems. The purpose of this
scheme is to support a future transport making use of AF_UNIX on Windows
systems, at which time it will be necessary to discriminate between the
Named Pipes and the AF_UNIX based transports.
</p>
<p><em>Abstract Names</em>
</p>
<p>[<strong>URI, abstract://</strong>] On Linux, this transport also can support
abstract sockets. Abstract sockets use a URI-encoded name after the
scheme, which allows arbitrary values to be conveyed in the path,
including embedded NUL bytes. abstract://nanonext is a valid example URL.
</p>

<ul>
<li><p> Abstract sockets do not have any representation in the file system,
and are automatically freed by the system when no longer in use. Abstract
sockets ignore socket permissions, but it is still possible to determine
the credentials of the peer.
</p>
</li></ul>



<h3>TCP/IP</h3>

<p>The TCP transport provides communication support between sockets
across a TCP/IP network. Both IPv4 and IPv6 are supported when supported
by the underlying platform.
</p>
<p>[<strong>URI, tcp://</strong>] This transport uses URIs using the scheme tcp://,
followed by an IP address or hostname, followed by a colon and finally
a TCP port number. For example, to contact port 80 on the localhost
either of the following URIs could be used: tcp://127.0.0.1:80 or
tcp://localhost:80.
</p>

<ul>
<li><p> A URI may be restricted to IPv6 using the scheme tcp6://, and may
be restricted to IPv4 using the scheme tcp4://
</p>
</li>
<li><p> Note: Specifying tcp6:// may not prevent IPv4 hosts from being used
with IPv4-in-IPv6 addresses, particularly when using a wildcard hostname
with listeners. The details of this varies across operating systems.
</p>
</li>
<li><p> Note: both tcp6:// and tcp4:// are specific to NNG, and might not
be understood by other implementations.
</p>
</li>
<li><p> It is recommended to use either numeric IP addresses, or names that
are specific to either IPv4 or IPv6 to prevent confusion and surprises.
</p>
</li>
<li><p> When specifying IPv6 addresses, the address must be enclosed in
square brackets ([]) to avoid confusion with the final colon separating
the port. For example, the same port 80 on the IPv6 loopback address
(::1) would be specified as tcp://[::1]:80.
</p>
</li>
<li><p> The special value of 0 (INADDR_ANY) can be used for a listener to
indicate that it should listen on all interfaces on the host. A
shorthand for this form is to either omit the address, or specify the
asterisk (*) character. For example, the following three URIs are all
equivalent, and could be used to listen to port 9999 on the host:
(1) tcp://0.0.0.0:9999 (2) tcp://*:9999 (3) tcp://:9999
</p>
</li></ul>



<h3>TLS</h3>

<p>The TLS transport provides communication support between peers across a
TCP/IP network using TLS v1.2 on top of TCP. Both IPv4 and IPv6 are
supported when supported by the underlying platform.
</p>
<p>[<strong>URI, tls+tcp://</strong>] This transport uses URIs using the scheme
tls+tcp://, followed by an IP address or hostname, followed by a colon
and finally a TCP port number. For example, to contact port 4433 on the
localhost either of the following URIs could be used:
tls+tcp://127.0.0.1:4433 or tls+tcp://localhost:4433.
</p>

<ul>
<li><p> A URI may be restricted to IPv6 using the scheme tls+tcp6://, or
IPv4 using the scheme tls+tcp4://.
</p>
</li></ul>



<h3>WebSocket</h3>

<p>The ws and wss transport provides communication support between peers
across a TCP/IP network using WebSockets. Both IPv4 and IPv6 are
supported when supported by the underlying platform.
</p>
<p>[<strong>URI, ws://</strong>] This transport uses URIs using the scheme ws://,
followed by an IP address or hostname, optionally followed by a colon and
a TCP port number, optionally followed by a path. (If no port number is
specified then port 80 is assumed. If no path is specified then a path of
/ is assumed.) For example, the URI ws://localhost/app/pubsub would use
port 80 on localhost, with the path /app/pubsub.
</p>
<p>[<strong>URI, wss://</strong>] Secure WebSockets use the scheme wss://, and the
default TCP port number of 443. Otherwise the format is the same as for
regular WebSockets.
</p>

<ul>
<li><p> A URI may be restricted to IPv6 using the scheme ws6:// or wss6://,
or IPv4 using the scheme ws4:// or wss4://.
</p>
</li>
<li><p> When specifying IPv6 addresses, the address must be enclosed in
square brackets ([]) to avoid confusion with the final colon separating
the port. For example, the same path and port on the IPv6 loopback
address (::1) would be specified as ws://[::1]/app/pubsub.
</p>
</li>
<li><p> Note: The value specified as the host, if any, will also be used in
the Host: HTTP header during HTTP negotiation.
</p>
</li>
<li><p> To listen to all ports on the system, the host name may be elided
from the URL on the listener. This will wind up listening to all
interfaces on the system, with possible caveats for IPv4 and IPv6
depending on what the underlying system supports. (On most modern systems
it will map to the special IPv6 address ::, and both IPv4 and IPv6
connections will be permitted, with IPv4 addresses mapped to IPv6
addresses.)
</p>
</li>
<li><p> This transport makes use of shared HTTP server instances,
permitting multiple sockets or listeners to be configured with the same
hostname and port. When creating a new listener, it is registered with an
existing HTTP server instance if one can be found. Note that the matching
algorithm is somewhat simple, using only a string based hostname or IP
address and port to match. Therefore it is recommended to use only IP
addresses or the empty string as the hostname in listener URLs.
</p>
</li>
<li><p> All sharing of server instances is only typically possible within
the same process.
</p>
</li>
<li><p> The server may also be used by other things (for example to serve
static content), in the same process.
</p>
</li></ul>



<h3>BSD Socket (experimental)</h3>

<p>The socket transport provides communication support between peers across
arbitrary BSD sockets, such as those created with socketpair.
</p>
<p>[<strong>URI, socket://</strong>] This transport uses the URL socket://, without
further qualification.
</p>
<p>This transport only supports listeners. The socket file descriptor is
passed to the listener using the 'socket:fd' option (as an integer).
Setting this option (which is write-only and can be set multiple times)
will cause the listener to create a pipe backed by the file descriptor.
</p>

<hr>
<h2 id='unresolved'>Query if an Aio is Unresolved</h2><span id='topic+unresolved'></span>

<h3>Description</h3>

<p>Query whether an Aio, Aio value or list of Aios remains unresolved. Unlike
<code><a href="#topic+call_aio">call_aio</a></code>, this function does not wait for completion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unresolved(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unresolved_+3A_x">x</code></td>
<td>
<p>an Aio or list of Aios (objects of class &lsquo;sendAio&rsquo;,
&lsquo;recvAio&rsquo; or &lsquo;ncurlAio&rsquo;), or Aio value stored at
<code>$result</code> or <code>$data</code> etc.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suitable for use in control flow statements such as <code>while</code> or
<code>if</code>.
</p>
<p>Note: querying resolution may cause a previously unresolved Aio to
resolve.
</p>


<h3>Value</h3>

<p>Logical TRUE if &lsquo;aio&rsquo; is an unresolved Aio or Aio value or the
list of Aios contains at least one unresolved Aio, or FALSE otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s1 &lt;- socket("pair", listen = "inproc://nanonext")
aio &lt;- send_aio(s1, "test", timeout = 100)

while (unresolved(aio)) {
  # do stuff before checking resolution again
  cat("unresolved\n")
  msleep(20)
}

unresolved(aio)

close(s1)

</code></pre>

<hr>
<h2 id='write_cert'>Generate Self-Signed Certificate and Key</h2><span id='topic+write_cert'></span>

<h3>Description</h3>

<p>Generate self-signed x509 certificate and 4096 bit RSA private/public key
pair for use with authenticated, encrypted TLS communications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_cert(cn = "localhost", valid = "20301231235959")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_cert_+3A_cn">cn</code></td>
<td>
<p>[default 'localhost'] character issuer common name (CN) for the
certificate. This can be either a hostname or an IP address, but must
match the actual server URL as client authentication will depend on it.</p>
</td></tr>
<tr><td><code id="write_cert_+3A_valid">valid</code></td>
<td>
<p>[default '20301231235959'] character &lsquo;not after&rsquo;
date-time in &lsquo;yyyymmddhhmmss&rsquo; format. The certificate is not valid
after this time.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For interactive sessions only, a status message is printed at the
start of key / certificate generation and also when complete.
</p>


<h3>Value</h3>

<p>A list of length 2, comprising <code>$server</code> and <code>$client</code>.
These may be passed directly to the relevant argument of
<code><a href="#topic+tls_config">tls_config</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (interactive()) {
# Only run examples in interactive R sessions

cert &lt;- write_cert(cn = "127.0.0.1")
ser &lt;- tls_config(server = cert$server)
cli &lt;- tls_config(client = cert$client)

s &lt;- socket(listen = "tls+tcp://127.0.0.1:5555", tls = ser)
s1 &lt;- socket(dial = "tls+tcp://127.0.0.1:5555", tls = cli)

# secure TLS connection established

close(s1)
close(s)

cert

}

</code></pre>

<hr>
<h2 id='zzz'>Internal Package Function</h2><span id='topic+zzz'></span>

<h3>Description</h3>

<p>Only present for cleaning up after running examples and tests. Do not attempt
to run the examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zzz()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>if (Sys.info()[["sysname"]] == "Linux") {
  rm(list = ls())
  gc()
  Sys.sleep(1L)
  .Call(nanonext:::rnng_fini)
}

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
