<!DOCTYPE html><html><head><title>Help for package coxsei</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {coxsei}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#coxsei-package'>
<p>Fit a Cox-type self-exciting intensity model (CoxSEI) to right-censored</p>
counting process data</a></li>
<li><a href='#coxsei'>
<p>CoxSEI model</p></a></li>
<li><a href='#coxseiest'>

<p>Function to estimate the parametric part of the Cox (proportional</p>
intensity) self-exciting point process (CoxSEI) model</a></li>
<li><a href='#coxseiexp'>

<p>CoxSEI model with exponential function</p></a></li>
<li><a href='#coxseifit.ex'>

<p>CoxSEI model with exponential function</p></a></li>
<li><a href='#coxseiInt'>

<p>Calculate the estimator of the cumulative baseline intensity function</p>
in the CoxSEI model.</a></li>
<li><a href='#coxseisim'>

<p>A function to simulate a CoxSEI process conditional on specified</p>
covariate values</a></li>
<li><a href='#CumInt'>

<p>Cumulative intensity function</p></a></li>
<li><a href='#dat'>

<p>A simulated data set from a CoxSEI model</p></a></li>
<li><a href='#Dens'>

<p>Density function</p></a></li>
<li><a href='#Dist'>

<p>Distribution function</p></a></li>
<li><a href='#Quant'>

<p>Quantile function</p></a></li>
<li><a href='#RND'>

<p>Random number generator</p></a></li>
<li><a href='#Surv'>

<p>Survival function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fitting a CoxSEI Model</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-02-08</td>
</tr>
<tr>
<td>Author:</td>
<td>Feng Chen &lt;feng.chen@unsw.edu.au&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Feng Chen &lt;feng.chen@unsw.edu.au&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Fit a CoxSEI (Cox type Self-Exciting Intensity) model to right-censored counting process data.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-02-08 06:42:42 UTC; z3243864</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-02-08 07:00:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='coxsei-package'>
Fit a Cox-type self-exciting intensity model (CoxSEI) to right-censored
counting process data
</h2><span id='topic+coxsei-package'></span>

<h3>Description</h3>

<p>Fit the CoxSEI model using the partial likelihood method.
</p>


<h3>Details</h3>

<p>To use the package, the data needs to be prepared into a data frame
containing a column named <code>Y</code> for observed event times in ascending
order of each individual process, a column named <code>delta</code> indicating
if the event is 'death' (1) or 'censoring' (0), a column named
<code>id</code> indicating the process id of each event time, and one or more
columns giving the value of any covariate variable at the observed event
times of each process. Then call the <code>coxseiest</code> function or the
identical but much faster <code>coxseiest2</code> function to estimate the
parametric part of the model and then the <code>coxseiInt</code> function to
estimate the cumulative baseline intensity function.
</p>


<h3>Author(s)</h3>

<p>Feng Chen &lt;feng.chen@unsw.edu.au&gt;
</p>
<p>Maintainer: Feng Chen &lt;feng.chen@unsw.edu.au&gt;
</p>


<h3>References</h3>

<p>Feng Chen and Kani Chen. (2014). Modeling Event Clustering Using the m-Memory
Cox-Type
Self-Exciting Intensity Model. International Journal of Statistics and
Probability. 3(3): 126-137. doi:10.5539/ijsp.v3n3p126  URL:
http://dx.doi.org/10.5539/ijsp.v3n3p126
</p>
<p>Feng Chen and Kani Chen. (2014). Case-cohort analysis of clusters of
recurrent events. 20(1): 1-15. doi: 10.1007/s10985-013-9275-3
</p>


<h3>See Also</h3>

<p><code><a href="boot.html#topic+survival">survival</a></code>
</p>

<hr>
<h2 id='coxsei'>
CoxSEI model
</h2><span id='topic+coxsei'></span><span id='topic+coxsei.default'></span><span id='topic+print.coxsei'></span><span id='topic+plot.coxsei'></span><span id='topic+summary.coxsei'></span><span id='topic+print.summary.coxsei'></span>

<h3>Description</h3>


<p>Fit a CoxSEI model to counting process data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coxsei(x,...)
## Default S3 method:
coxsei(x,y,delta,id,par.init,m=2,mit=1000,tr=TRUE,
       method="L-BFGS-B",lower=c(rep(-Inf,ncol(x)),-Inf,0),
       upper=rep(Inf,ncol(x) + 2),...)
## S3 method for class 'coxsei'
print(x,...)
## S3 method for class 'coxsei'
plot(x,...)
## S3 method for class 'coxsei'
summary(object,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coxsei_+3A_x">x</code></td>
<td>
<p>a covariate matrix, or an object of class <code>coxsei</code></p>
</td></tr>
<tr><td><code id="coxsei_+3A_y">y</code></td>
<td>
<p>a vector of observed times</p>
</td></tr>
<tr><td><code id="coxsei_+3A_delta">delta</code></td>
<td>

<p>a vector of event indicators: 1=event, 0=censoring

</p>
</td></tr>
<tr><td><code id="coxsei_+3A_id">id</code></td>
<td>


<p>the individual/group id to which the event/censoring time
correspond 
</p>
</td></tr>
<tr><td><code id="coxsei_+3A_par.init">par.init</code></td>
<td>


<p>initial parameter guess to start the iteration
</p>
</td></tr>
<tr><td><code id="coxsei_+3A_m">m</code></td>
<td>


<p>lag parameter as in m-dependence
</p>
</td></tr>
<tr><td><code id="coxsei_+3A_mit">mit</code></td>
<td>


<p>max number of iteration
</p>
</td></tr>
<tr><td><code id="coxsei_+3A_tr">tr</code></td>
<td>


<p>whether to trace the optimization or not
</p>
</td></tr>
<tr><td><code id="coxsei_+3A_method">method</code></td>
<td>


<p>method used in optimization
</p>
</td></tr>
<tr><td><code id="coxsei_+3A_lower">lower</code></td>
<td>

<p>the lower bound of the parameter space if the L-BFGS-B
method of optimization is used.
</p>
</td></tr>
<tr><td><code id="coxsei_+3A_upper">upper</code></td>
<td>

<p>the upper bound of the paramter space if the L-BFGS-B methodof
optimaization is used.
</p>
</td></tr>
<tr><td><code id="coxsei_+3A_...">...</code></td>
<td>
<p>further arguments to plot.stepfun</p>
</td></tr>
<tr><td><code id="coxsei_+3A_object">object</code></td>
<td>
<p>an object of the class coxsei</p>
</td></tr>
</table>


<h3>Value</h3>






<p>an object of class <code>coxsei</code>, basically a list of the following
components
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>a numeric vector of coefficients</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>the variance-covariance matrix</p>
</td></tr>
<tr><td><code>zval</code></td>
<td>
<p>the vector of z-value of the Wald test statistic</p>
</td></tr>
<tr><td><code>pval</code></td>
<td>
<p>the vector of p-values</p>
</td></tr>
<tr><td><code>details.par</code></td>
<td>
<p>a list returned by the<code>optim</code> routine</p>
</td></tr>
<tr><td><code>cintfn</code></td>
<td>
<p>a step function as the estimated cumulative baseline
intensity function</p>
</td></tr>
<tr><td><code>cintvar</code></td>
<td>
<p>a step function as the variance of the cumulative
baseline intensity function estimator</p>
</td></tr>
<tr><td><code>details.cint</code></td>
<td>
<p>a list containing more details about the <code>cint</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>


<p>Feng Chen &lt;feng.chen@unsw.edu.au&gt;
</p>


<h3>References</h3>

<p>Feng Chen and Kani Chen. (2014). Modeling Event Clustering Using the m-Memory
Cox-Type
Self-Exciting Intensity Model. International Journal of Statistics and
Probability. 3(3): 126-137. doi:10.5539/ijsp.v3n3p126  URL:
http://dx.doi.org/10.5539/ijsp.v3n3p126
</p>
<p>Feng Chen and Kani Chen. (2014). Case-cohort analysis of clusters of
recurrent events. 20(1): 1-15. doi: 10.1007/s10985-013-9275-3
</p>


<h3>See Also</h3>


<p><code><a href="#topic+coxseifit.ex">coxseifit.ex</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dat,package="coxsei")
acoxsei &lt;- coxsei(dat[,3:5],dat[,1],dat[,2],dat[,6],
                  c(0.2*1:3,log(0.07),log(10)))
summary(acoxsei)
plot(acoxsei,do.points=FALSE)
</code></pre>

<hr>
<h2 id='coxseiest'>

Function to estimate the parametric part of the Cox (proportional
intensity) self-exciting point process (CoxSEI) model
</h2><span id='topic+coxseiest'></span><span id='topic+coxseiest2'></span><span id='topic+coxseiest3'></span>

<h3>Description</h3>

<p>Estimate the parametric part of the CoxSEI model using (conditionally)
right-censored counting process data. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coxseiest(dat, par.init, m = 2, mit = 1000, tr = TRUE,
          method = "L-BFGS-B", lower=c(rep(-Inf,ncol(dat)-3),-Inf,0),
          upper=rep(Inf,ncol(dat)-3 + 2),
          gfun = function(x, pa) {
           ifelse(x &lt;= 0, rep(0, length(x)), pa[1] * exp(-pa[2] * x))
          })
coxseiest2(dat, par.init, m = 2, mit = 1000, tr = TRUE,
           method = "L-BFGS-B", lower=c(rep(-Inf,ncol(dat)-3),-Inf,0),
           upper=rep(Inf,ncol(dat)-3 + 2),
           gfun = function(x, pa) {
             ifelse(x &lt;= 0, rep(0, length(x)), pa[1] * exp(-pa[2] * x))
           })
coxseiest3(dat, par.init, m = 2, mit = 1000, tr = TRUE,
           method = "L-BFGS-B", lower=c(rep(-Inf,ncol(dat)-3),-Inf,0),
           upper=rep(Inf,ncol(dat)-3 + 2))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coxseiest_+3A_dat">dat</code></td>
<td>


<p>a data frame with columns <code>Y</code> containing the censored
event times of each individual process arranged in ascending order
with the last time always being the the censoring time, <code>delta</code>
containing the event time indicator with value indicator an event
time and 0 a censoring time, <code>id</code> specifying the id (process
number) of each event time recorded, and the others giving the value
of the associated covariate process at the corresponding event
times. 
</p>
</td></tr>
<tr><td><code id="coxseiest_+3A_par.init">par.init</code></td>
<td>


<p>init guess of the value of the parameters to start the optimization
iteration with.
</p>
</td></tr>
<tr><td><code id="coxseiest_+3A_m">m</code></td>
<td>


<p>order of &quot;autoregression&quot; of the excitation term.
</p>
</td></tr>
<tr><td><code id="coxseiest_+3A_mit">mit</code></td>
<td>


<p>maximum number of iteration in the optimization routine
</p>
</td></tr>
<tr><td><code id="coxseiest_+3A_tr">tr</code></td>
<td>


<p>if set to <code>TRUE</code>, print some summary information while the
optimization routine is running.
</p>
</td></tr>
<tr><td><code id="coxseiest_+3A_method">method</code></td>
<td>


<p>method of optimization
</p>
</td></tr>
<tr><td><code id="coxseiest_+3A_lower">lower</code></td>
<td>

<p>vector of lower boundary values of the parameter space
</p>
</td></tr>
<tr><td><code id="coxseiest_+3A_upper">upper</code></td>
<td>

<p>vector of upper boundary of the parameter space
</p>
</td></tr>  
<tr><td><code id="coxseiest_+3A_gfun">gfun</code></td>
<td>


<p>the excitation function. Defaults to the exponential decay function 
</p>
<p style="text-align: center;"><code class="reqn">g(t;\gamma)=\gamma_1 \gamma_2 e^{-\gamma_2 t}</code>
</p>

</td></tr>
</table>


<h3>Details</h3>


<p><code>coxseiest</code> uses only R code; <code>coxseiest2</code> uses external C
code, and is expected to be 3~4 times fasters than the former;
<code>coxseiest3</code> assumes the excitation function is the exponential
function as defaulted by the former two, and hardwares it in the C
side of the code, and therefore is much faster than the former two
when the exponential excitation function is desired. 
</p>


<h3>Value</h3>

<p>A list as that returned by the call to the optimizer routine. For
instance, 
</p>
<table>
<tr><td><code>par</code></td>
<td>
<p>gives the estimate of the parameters</p>
</td></tr>
<tr><td><code>hessian</code></td>
<td>
<p>gives the inverse of the estimate of the
variance-covariance matrix</p>
</td></tr> 
</table>


<h3>Note</h3>


<p>the excitation function has to contain exactly two parameters; a
feature that does not seem desiable and might change later.
</p>


<h3>Author(s)</h3>


<p>Feng Chen &lt;feng.chen@unsw.edu.au&gt;
</p>


<h3>References</h3>


<p>Feng Chen and Kani Chen. (2014). Modeling Event Clustering Using the m-Memory
Cox-Type
Self-Exciting Intensity Model. International Journal of Statistics and
Probability. 3(3): 126-137. doi:10.5539/ijsp.v3n3p126  URL:
http://dx.doi.org/10.5539/ijsp.v3n3p126
</p>
<p>Feng Chen and Kani Chen. (2014). Case-cohort analysis of clusters of
recurrent events. 20(1): 1-15. doi: 10.1007/s10985-013-9275-3
</p>


<h3>See Also</h3>


<p>See <code><a href="stats.html#topic+optim">optim</a></code> for the components of the returned value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("dat")
## this takes over 15 minutes
##est0 &lt;- coxseiest(dat,par.init=c(0.2,0.4,0.6,0.6,5))
## this one takes about 4 minutes
##est1 &lt;- coxseiest2(dat,par.init=c(0.2,0.4,0.6,0.6,5))
## this one takes about 10 seconds
est2 &lt;- coxseiest3(dat,par.init=c(0.2,0.4,0.6,0.6,5))
</code></pre>

<hr>
<h2 id='coxseiexp'>

CoxSEI model with exponential function
</h2><span id='topic+coxseiexp'></span>

<h3>Description</h3>


<p>fit CoxSEI model using an exponential excitation function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coxseiexp(Y, delta, id, Z, par.init, m = 2, mit = 1000, tr = TRUE,
          method = "L-BFGS-B",lower=c(rep(-Inf,ncol(Z)),-Inf,0),
          upper=rep(Inf,ncol(Z) + 2),...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coxseiexp_+3A_y">Y</code></td>
<td>


<p>the observed times (including censoring times)
</p>
</td></tr>
<tr><td><code id="coxseiexp_+3A_delta">delta</code></td>
<td>


<p>indicator of event: 1=event, 0=censoring
</p>
</td></tr>
<tr><td><code id="coxseiexp_+3A_id">id</code></td>
<td>


<p>the id of the individual/group the event/censoring corresponds to
</p>
</td></tr>
<tr><td><code id="coxseiexp_+3A_z">Z</code></td>
<td>


<p>covariate matrix
</p>
</td></tr>
<tr><td><code id="coxseiexp_+3A_par.init">par.init</code></td>
<td>


<p>initial parameter value to start the iteration
</p>
</td></tr>
<tr><td><code id="coxseiexp_+3A_m">m</code></td>
<td>


<p>the lag parameter as in M-dependence
</p>
</td></tr>
<tr><td><code id="coxseiexp_+3A_mit">mit</code></td>
<td>


<p>maximum number of iteration allowed in maximizing the loag partial
likelihood 
</p>
</td></tr>
<tr><td><code id="coxseiexp_+3A_tr">tr</code></td>
<td>


<p>should the optimization process be 'tr'aced
</p>
</td></tr>
<tr><td><code id="coxseiexp_+3A_method">method</code></td>
<td>


<p>method of optimization; defaults to &quot;L-BFGS-B&quot;
</p>
</td></tr>
<tr><td><code id="coxseiexp_+3A_lower">lower</code></td>
<td>

<p>vector of lower boundary values of the parameter space
</p>
</td></tr>
<tr><td><code id="coxseiexp_+3A_upper">upper</code></td>
<td>

<p>vector of upper boundary of the parameter space
</p>
</td></tr>
<tr><td><code id="coxseiexp_+3A_...">...</code></td>
<td>

<p>other arguments to be passed to the optimization routine
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class &quot;coxsei&quot;, basically a list with components
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>a named vector of coefficients </p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>a symmetric matrix which is supposed to be positive definite
when m&gt;0, or with the (np-2)x(np-2) major submatrix positive definite
when m=0</p>
</td></tr>
</table>


<h3>Author(s)</h3>


<p>Feng Chen &lt;feng.chen@unsw.edu.au&gt;
</p>

<hr>
<h2 id='coxseifit.ex'>

CoxSEI model with exponential function
</h2><span id='topic+coxseifit.ex'></span>

<h3>Description</h3>


<p>Fit a CoxSEI model with exponential function to right censored
counting process data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coxseifit.ex(dat, par.init, m = 2, mit = 1000, tr = TRUE,
             method = "L-BFGS-B",lower=c(rep(-Inf,ncol(dat)-3),-Inf,0),
             upper=rep(Inf,ncol(dat)-3 + 2),...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coxseifit.ex_+3A_dat">dat</code></td>
<td>


<p>The data
</p>
</td></tr>
<tr><td><code id="coxseifit.ex_+3A_par.init">par.init</code></td>
<td>


<p>initial value of the regression coefficients and coefficients in the
excitation function
</p>
</td></tr>
<tr><td><code id="coxseifit.ex_+3A_m">m</code></td>
<td>


<p>the lag parameter (the m-dependence parameter)
</p>
</td></tr>
<tr><td><code id="coxseifit.ex_+3A_mit">mit</code></td>
<td>


<p>maximum number of iterations allowed in the optimizer
</p>
</td></tr>
<tr><td><code id="coxseifit.ex_+3A_tr">tr</code></td>
<td>


<p>whether to trace the optimization or not
</p>
</td></tr>
<tr><td><code id="coxseifit.ex_+3A_method">method</code></td>
<td>


<p>the method of optimization used by the <code>optim</code> routine
</p>
</td></tr>
<tr><td><code id="coxseifit.ex_+3A_lower">lower</code></td>
<td>

<p>vector of lower boundary values of the parameter space
</p>
</td></tr>
<tr><td><code id="coxseifit.ex_+3A_upper">upper</code></td>
<td>

<p>vector of upper boundary of the parameter space
</p>
</td></tr>
<tr><td><code id="coxseifit.ex_+3A_...">...</code></td>
<td>

<p>other arguments to be passed to the optimization routine
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of some components with kind of self-evident meanings by their name
</p>


<h3>Author(s)</h3>


<p>Feng Chen &lt;feng.chen@unsw.edu.au&gt;
</p>


<h3>See Also</h3>


<p><code><a href="#topic+coxseiest">coxseiest</a></code>, <code><a href="#topic+coxseiInt">coxseiInt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("dat")
csfit &lt;- coxseifit.ex(dat,c(1:3*0.2,0.7,10))
coef(csfit)
plot(csfit$cintfn,do.points=FALSE)
</code></pre>

<hr>
<h2 id='coxseiInt'>

Calculate the estimator of the cumulative baseline intensity function
in the CoxSEI model.
</h2><span id='topic+coxseiInt'></span>

<h3>Description</h3>


<p>It takes the paramter of the parametric part (or its theorized value)
and calculate the values of the estimator at the jump times; it also
gives the values of the estimator for the variance of the intensity
estimator. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coxseiInt(dat, parest, hessian=NULL, vcovmat=solve(hessian), m = 2,
          gfun = function(x, pa) {
            ifelse(x &lt;= 0, 0, pa[1] * pa[2] * exp(-pa[2] * x))
          },
          gfungrd = function(x, pa){
            if(length(x)==0)return(matrix(0,2,0));
            rbind(pa[2]*exp(-pa[2]*x),
                  pa[1]*exp(-pa[2]*x)*(1-pa[2]*x)
                 )
          })
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coxseiInt_+3A_dat">dat</code></td>
<td>


<p>a data frame containing the right-censored counting process data 
</p>
</td></tr>
<tr><td><code id="coxseiInt_+3A_parest">parest</code></td>
<td>


<p>the estimate of parameter of the parametric part of the CoxSEI model
</p>
</td></tr>
<tr><td><code id="coxseiInt_+3A_hessian">hessian</code></td>
<td>

<p>the hessian matrix returned by the optimization procedure in the
estimation of the parametric part based on partial likelihood
</p>
</td></tr>
<tr><td><code id="coxseiInt_+3A_vcovmat">vcovmat</code></td>
<td>

<p>the variance-covariance matrix of the estimator of the the
parametric components; defaulted to the inverse of the hessian
matrix
</p>
</td></tr>    
<tr><td><code id="coxseiInt_+3A_m">m</code></td>
<td>


<p>autoregressive order in the excitation part of the intensity
</p>
</td></tr>
<tr><td><code id="coxseiInt_+3A_gfun">gfun</code></td>
<td>


<p>the excitation function; defaults to the exponential decay function
</p>
</td></tr>
<tr><td><code id="coxseiInt_+3A_gfungrd">gfungrd</code></td>
<td>

<p>derivative/gradient function of the excitation function
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list giving the jump times and values at these of the estimator of the
cumulative baseline intensity function.
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p> the ordered death/event times</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p> the value of the estimator of the intensity function at the
observed death/event times</p>
</td></tr>
<tr><td><code>varest</code></td>
<td>
<p> the value of the estimator of the variance of the
estimator of the intensity function, at the jump times
</p>
</td></tr>
</table>
<p>The step function can be obtained using <code>stepfun</code>, and plotted by setting
<code>type="s"</code> in the <code>plot</code> function.
</p>


<h3>Note</h3>


<p>Currently doesn't compute the standard error or variance estimator of
the baseline cumulative intensity estimator. 
</p>


<h3>Author(s)</h3>


<p>Feng Chen &lt;feng.chen@unsw.edu.au&gt;  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("dat")
est &lt;- coxseiest3(dat,c(0.2,0.4,0.6,log(0.06),log(5)))
pe &lt;- est$par; pe[4:5] &lt;- exp(pe[4:5]);
ve &lt;- diag(pe) %*% solve(est$hessian, diag(pe));
cintest &lt;- coxseiInt(dat,pe,vcovmat=ve)
plot(cintest,type="s")
</code></pre>

<hr>
<h2 id='coxseisim'>

A function to simulate a CoxSEI process conditional on specified
covariate values 
</h2><span id='topic+coxseisim'></span>

<h3>Description</h3>


<p>simulate the sample path of the CoxSEI model with given covariate
process values, and excitation function and order of autodependence in
the excitation term.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coxseisim(parreg, parg, lmd0 = function(tt) (1 + 0.5 * cos(2 * pi *
tt)),
          g = function(x, parg) {
                 ifelse(x &lt;= 0, 0, parg[1] * parg[2] * exp(-parg[2] * x))
              },
          censor = 1, m = 2, trace=TRUE,
          Z = function(x) matrix(0, length(x), length(parreg))
         )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coxseisim_+3A_parreg">parreg</code></td>
<td>

<p>the regression parameter
</p>
</td></tr>
<tr><td><code id="coxseisim_+3A_parg">parg</code></td>
<td>


<p>parameters of the excitation function
</p>
</td></tr>
<tr><td><code id="coxseisim_+3A_lmd0">lmd0</code></td>
<td>


<p>the baseline intensity function
</p>
</td></tr>
<tr><td><code id="coxseisim_+3A_g">g</code></td>
<td>


<p>the excitation function
</p>
</td></tr>
<tr><td><code id="coxseisim_+3A_censor">censor</code></td>
<td>


<p>the censoring time
</p>
</td></tr>
<tr><td><code id="coxseisim_+3A_m">m</code></td>
<td>


<p>order of autoregression in the excitation component of the intensity
process 
</p>
</td></tr>
<tr><td><code id="coxseisim_+3A_trace">trace</code></td>
<td>

<p>whether to trace the data generation process; defaults to <code>TRUE</code>
</p>
</td></tr>
<tr><td><code id="coxseisim_+3A_z">Z</code></td>
<td>


<p>a function to calculate the covariate values at a specified event time
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with provided covariate values and the censoring time, and
the generated event times. 
</p>


<h3>Author(s)</h3>


<p>Feng Chen &lt;feng.chen@unsw.edu.au&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    n.smp &lt;- 100;
    z &lt;- matrix(NA,n.smp,3)
    for(i in 1:n.smp)
    z[i,] &lt;- round(c(runif(1,0.5,1.5),runif(1,1.5,2.5),rbinom(1,1,0.5)),2)
    dat &lt;- coxseisim(1:3*0.2,c(0.07,10),censor=rlnorm(1,0,0.1),m=2,
    Z=function(x)matrix(z[1,],length(x),3,byrow=TRUE))
    dat$id &lt;- 1;
    for(i in 2:n.smp){
      dattmp &lt;- coxseisim(1:3*0.2,c(0.07,10),censor=rlnorm(1,0,0.1),m=2,
      Z=function(x)matrix(z[i,],length(x),3,byrow=TRUE))
      dattmp$id &lt;- i;
      dat &lt;- rbind(dat,dattmp)
    }

</code></pre>

<hr>
<h2 id='CumInt'>

Cumulative intensity function
</h2><span id='topic+CumInt'></span>

<h3>Description</h3>


<p>Calculate the cumulative/integrated hazard/intensity function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CumInt(x, int, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CumInt_+3A_x">x</code></td>
<td>


<p>the value at which to calculate the cumulative function value
</p>
</td></tr>
<tr><td><code id="CumInt_+3A_int">int</code></td>
<td>


<p>the intensity/hazard rate function. Has to be vectorized.
</p>
</td></tr>
<tr><td><code id="CumInt_+3A_...">...</code></td>
<td>


<p>the arguments to be passed in to control the behavior of the
underlying <code>integrate</code> function. 
</p>
</td></tr>
</table>


<h3>Details</h3>


<p>Relies on the numerical integration routine of R.
</p>


<h3>Value</h3>

<p>The value(s) of the cumulative hazard function at the specified
<code>x</code> value(s).
</p>


<h3>Warning</h3>

<p>The validity of the user supplied intensity function is not checked.   
</p>


<h3>Note</h3>


<p>Not intended to be called by the user directly.
</p>


<h3>Author(s)</h3>


<p>Feng Chen &lt;feng.chen@unsw.edu.au&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
curve(CumInt(x,int=function(y)1*( y&gt;=0 &amp; y&lt;2)+3*(y&gt;=2 &amp; y&lt;3)+1*(y&gt;=3)),
      0,5,xlab="t",ylab="H(t) of a piece-wise constant hazard fun h(t)")   
</code></pre>

<hr>
<h2 id='dat'>

A simulated data set from a CoxSEI model
</h2><span id='topic+dat'></span>

<h3>Description</h3>


<p>Simulated from a CoxSEI model with an exponential excitation function
and an AR order 2 for the self-excitation effects. Generated using the
following code:
<code>
    set.seed(1);
    n.smp &lt;- 50;
    z &lt;- matrix(NA,n.smp,3);
    for(i in 1:n.smp)
    z[i,] &lt;- round(c(runif(1,0.5,1.5),runif(1,1.5,2.5),rbinom(1,1,0.5)),2);
    dat &lt;- coxseisim(1:3*0.2,c(0.07,10),censor=rlnorm(1,0,0.1),m=2,
    Z=function(x)matrix(z[1,],length(x),3,byrow=T));
    dat$id &lt;- 1;
    for(i in 2:n.smp){
      dattmp &lt;- coxseisim(1:3*0.2,c(0.07,10),censor=rlnorm(1,0,0.1),m=2,
      Z=function(x)matrix(z[i,],length(x),3,byrow=T))
      dattmp$id &lt;- i;
      dat &lt;- rbind(dat,dattmp)
    }
  </code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dat)</code></pre>


<h3>Format</h3>

<p>A data frame with 307 observations on the following 6 variables.
</p>

<dl>
<dt><code>Y</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>delta</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Z.1</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Z.2</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Z.3</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>id</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(dat)
## maybe str(dat) ; plot(dat) ...
</code></pre>

<hr>
<h2 id='Dens'>

Density function
</h2><span id='topic+Dens'></span>

<h3>Description</h3>


<p>Evaluate the density function corresponding to the specified
intensity/hazard function <code>int</code>.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dens(x, int, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dens_+3A_x">x</code></td>
<td>


<p>the value at which to evaluate the density function
</p>
</td></tr>
<tr><td><code id="Dens_+3A_int">int</code></td>
<td>


<p>the intensity/hazard function. Has to be vectorized.
</p>
</td></tr>
<tr><td><code id="Dens_+3A_...">...</code></td>
<td>

<p>other arguments to be passed to the underlying integrator 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numerical value or vector giving the value(s) of the density function
</p>


<h3>Note</h3>


<p>Relies on R's <code>integrate</code> function
</p>


<h3>Author(s)</h3>


<p>Feng Chen &lt;feng.chen@unsw.edu.au&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1); dat &lt;- RND(1000,int=function(x)3*x^2)
hist(dat,freq=FALSE); curve(Dens(x,int=function(x)3*x^2),add=TRUE)
</code></pre>

<hr>
<h2 id='Dist'>

Distribution function
</h2><span id='topic+Dist'></span>

<h3>Description</h3>


<p>Calculate the value at <code>x</code> of the distribution function associated with
the intensity/hazard function probived through <code>int</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dist(x, int, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dist_+3A_x">x</code></td>
<td>


<p>the value to evaluate the distribution function at.
</p>
</td></tr>
<tr><td><code id="Dist_+3A_int">int</code></td>
<td>


<p>vectorized function specifying the intensity/hazard function
</p>
</td></tr>
<tr><td><code id="Dist_+3A_...">...</code></td>
<td>


<p>arguments to be passed to the <code>integrate</code> function
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number between 0 and 1 inclusive, that gives the value of the
distribution function at the specified <code>x</code> value.
</p>


<h3>Author(s)</h3>


<p>Feng Chen &lt;feng.chen@unsw.edu.au&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>curve(Dist(x,int=function(x)3*x^2),0,5)
curve(pweibull(x,shape=3),0,5,add=TRUE,col=3,lty=3)
</code></pre>

<hr>
<h2 id='Quant'>

Quantile function
</h2><span id='topic+Quant'></span>

<h3>Description</h3>


<p>calculates the value of the quantile function (inverse of the
distribution function) of the survival variable with given
intensity/hazard function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Quant(p, int, tolerance = .Machine$double.eps, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Quant_+3A_p">p</code></td>
<td>


<p>the (probability) values to calculate the quantiles at
</p>
</td></tr>
<tr><td><code id="Quant_+3A_int">int</code></td>
<td>


<p>the intensity/hazard function. Has to be vectorized.
</p>
</td></tr>
<tr><td><code id="Quant_+3A_tolerance">tolerance</code></td>
<td>


<p>tolerated numerical error in inverting the distribution function. 
</p>
</td></tr>
<tr><td><code id="Quant_+3A_...">...</code></td>
<td>


<p>arguments to be passed to <code>CumInt</code> (eventually to <code>integrate</code>)
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numerical value or vector giving the values of the quantile function
at <code>x</code>
</p>


<h3>Author(s)</h3>


<p>Feng Chen &lt;feng.chen@unsw.edu.au&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>curve(Quant(x,int=function(x)3*x^2),from=1e-3,to=1 - 1e-3)
curve(qweibull(x,shape=3),col=3,lty=3,add=TRUE)
</code></pre>

<hr>
<h2 id='RND'>

Random number generator
</h2><span id='topic+RND'></span>

<h3>Description</h3>


<p>RND takes a vectorized positive R function defined on positive reals
and returns a vector of <code>n</code> values of the random variable
(survival time) with the specifed function as its hazard/intensity
rate function. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RND(n, int, tol = .Machine$double.eps^0.5, epsabs = 1e-10, epsrel =
1e-10, limit = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RND_+3A_n">n</code></td>
<td>


<p>number of observations.
</p>
</td></tr>
<tr><td><code id="RND_+3A_int">int</code></td>
<td>


<p>hazard rate function of the survival variable, or the intensity
function of the one-event point process counting the number (0 or
1) of deaths by following a sample of the surviving suject.
</p>
</td></tr>
<tr><td><code id="RND_+3A_tol">tol</code></td>
<td>


<p>tolerance of the numerical error in calculating the inverse of the
cumulative distribution function of the survival variable. Defaults
to the square root of the machine epsilon.
</p>
</td></tr>
<tr><td><code id="RND_+3A_epsabs">epsabs</code></td>
<td>

<p>maximum absolute error to be tolerated by the integrator.
</p>
</td></tr>
<tr><td><code id="RND_+3A_epsrel">epsrel</code></td>
<td>

<p>maximum relative error to be tolerated by the integrator.
</p>
</td></tr>
<tr><td><code id="RND_+3A_limit">limit</code></td>
<td>

<p>maximum number of iterations permitted by the integrator.
</p>
</td></tr>
</table>


<h3>Value</h3>






<p>a vector of <code>n</code> observations of the survival variable with the
supplied intensity/hazard function.
</p>


<h3>Author(s)</h3>


<p>Feng Chen &lt;feng.chen@unsw.edu.au&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
dat &lt;- RND(100,int=function(x)x^2)
ks.test(dat,pweibull,shape=3) # p-value = 0.6058
qqplot(dat,rweibull(100,shape=3))  
</code></pre>

<hr>
<h2 id='Surv'>

Survival function
</h2><span id='topic+Surv'></span>

<h3>Description</h3>


<p>Evaluate the survival function corresponding to the given
intensity/hazard function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Surv(x, int, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Surv_+3A_x">x</code></td>
<td>


<p>value to calculate the value of the survival function for
</p>
</td></tr>
<tr><td><code id="Surv_+3A_int">int</code></td>
<td>


<p>the intensity/hazard function
</p>
</td></tr>
<tr><td><code id="Surv_+3A_...">...</code></td>
<td>


<p>further arguments to be passed to <code>CumInt</code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numerical value or vector giving the value(s) of the survival
function at <code>x</code>
</p>


<h3>Author(s)</h3>


<p>Feng Chen &lt;feng.chen@unsw.edu.au&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>curve(Surv(x, int=function(x)3*x^2), from=0, to=5)
curve(pweibull(x,shape=3,lower=FALSE), add=TRUE, col=2, lty=3)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
