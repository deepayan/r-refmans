<!DOCTYPE html><html><head><title>Help for package assertr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {assertr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#assert'><p>Raises error if predicate is FALSE in any columns selected</p></a></li>
<li><a href='#assert_rows'><p>Raises error if predicate is FALSE for any row after applying</p>
row reduction function</a></li>
<li><a href='#assertr'><p>assertr: Assertive programming for R analysis pipeline.</p></a></li>
<li><a href='#chaining_functions'><p>Chaining functions</p></a></li>
<li><a href='#col_concat'><p>Concatenate all columns of each row in data frame into a string</p></a></li>
<li><a href='#duplicates_across_cols'><p>Checks if row contains at least one value duplicated in its column</p></a></li>
<li><a href='#generate_id'><p>Generates random ID string</p></a></li>
<li><a href='#has_all_names'><p>Returns TRUE if data.frame or list has specified names</p></a></li>
<li><a href='#has_class'><p>Returns TRUE if data.frame columns have a specified class</p></a></li>
<li><a href='#has_only_names'><p>Returns TRUE if data.frame or list has only the specified names</p></a></li>
<li><a href='#in_set'><p>Returns TRUE if value in set</p></a></li>
<li><a href='#insist'><p>Raises error if dynamically created predicate is FALSE in any columns</p>
selected</a></li>
<li><a href='#insist_rows'><p>Raises error if dynamically created predicate is FALSE for any row</p>
after applying row reduction function</a></li>
<li><a href='#is_uniq'><p>Returns TRUE where no elements appear more than once</p></a></li>
<li><a href='#maha_dist'><p>Computes mahalanobis distance for each row of data frame</p></a></li>
<li><a href='#not_na'><p>Returns TRUE if value is not NA</p></a></li>
<li><a href='#num_row_NAs'><p>Counts number of NAs in each row</p></a></li>
<li><a href='#print.assertr_assert_error'><p>Printing assertr's assert errors</p></a></li>
<li><a href='#print.assertr_defect'><p>Printing assertr's defect</p></a></li>
<li><a href='#print.assertr_success'><p>Printing assertr's success</p></a></li>
<li><a href='#print.assertr_verify_error'><p>Printing assertr's verify errors</p></a></li>
<li><a href='#success_and_error_functions'><p>Success and error functions</p></a></li>
<li><a href='#summary.assertr_assert_error'><p>Summarizing assertr's assert errors</p></a></li>
<li><a href='#summary.assertr_verify_error'><p>Summarizing assertr's verify errors</p></a></li>
<li><a href='#verify'><p>Raises error if expression is FALSE anywhere</p></a></li>
<li><a href='#within_bounds'><p>Creates bounds checking predicate</p></a></li>
<li><a href='#within_n_mads'><p>Return a function to create robust z-score checking predicate</p></a></li>
<li><a href='#within_n_sds'><p>Return a function to create z-score checking predicate</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Assertive Programming for R Analysis Pipelines</td>
</tr>
<tr>
<td>Version:</td>
<td>3.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functionality to assert conditions
    that have to be met so that errors in data used in
    analysis pipelines can fail quickly. Similar to
    'stopifnot()' but more powerful, friendly, and easier
    for use in pipelines.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://docs.ropensci.org/assertr/">https://docs.ropensci.org/assertr/</a> (website)
<a href="https://github.com/ropensci/assertr">https://github.com/ropensci/assertr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ropensci/assertr/issues">https://github.com/ropensci/assertr/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr (&ge; 0.7.0), MASS, methods, stats, utils, rlang (&ge;
0.3.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, testthat (&ge; 3.0.0), magrittr, rmarkdown, tibble, covr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-22 23:34:48 UTC; tony</td>
</tr>
<tr>
<td>Author:</td>
<td>Tony Fischetti [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tony Fischetti &lt;tony.fischetti@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-23 00:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='assert'>Raises error if predicate is FALSE in any columns selected</h2><span id='topic+assert'></span>

<h3>Description</h3>

<p>Meant for use in a data analysis pipeline, this function will
just return the data it's supplied if there are no FALSEs
when the predicate is applied to every element of the columns
indicated. If any element in any of the columns, when applied
to the predicate, is FALSE, then this function will raise an
error, effectively terminating the pipeline early.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assert(
  data,
  predicate,
  ...,
  success_fun = success_continue,
  error_fun = error_stop,
  skip_chain_opts = FALSE,
  obligatory = FALSE,
  defect_fun = defect_append,
  description = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assert_+3A_data">data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="assert_+3A_predicate">predicate</code></td>
<td>
<p>A function that returns FALSE when violated</p>
</td></tr>
<tr><td><code id="assert_+3A_...">...</code></td>
<td>
<p>Comma separated list of unquoted expressions.
Uses dplyr's <code>select</code> to select
columns from data.</p>
</td></tr>
<tr><td><code id="assert_+3A_success_fun">success_fun</code></td>
<td>
<p>Function to call if assertion passes. Defaults to
returning <code>data</code>.</p>
</td></tr>
<tr><td><code id="assert_+3A_error_fun">error_fun</code></td>
<td>
<p>Function to call if assertion fails. Defaults to printing
a summary of all errors.</p>
</td></tr>
<tr><td><code id="assert_+3A_skip_chain_opts">skip_chain_opts</code></td>
<td>
<p>If TRUE, <code>success_fun</code> and <code>error_fun</code>
are used even if assertion is called within a chain.</p>
</td></tr>
<tr><td><code id="assert_+3A_obligatory">obligatory</code></td>
<td>
<p>If TRUE and assertion failed the data is marked as defective.
For defective data, all the following rules are handled by
<code>defect_fun</code> function.</p>
</td></tr>
<tr><td><code id="assert_+3A_defect_fun">defect_fun</code></td>
<td>
<p>Function to call when data is defective. Defaults to skipping
assertion and storing info about it in special attribute.</p>
</td></tr>
<tr><td><code id="assert_+3A_description">description</code></td>
<td>
<p>Custom description of the rule. Is stored in result
reports and data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For examples of possible choices for the <code>success_fun</code> and
<code>error_fun</code> parameters, run <code>help("success_and_error_functions")</code>
</p>


<h3>Value</h3>

<p>By default, the <code>data</code> is returned if predicate assertion
is TRUE and and error is thrown if not. If a non-default
<code>success_fun</code> or <code>error_fun</code> is used, the return
values of these function will be returned.
</p>


<h3>Note</h3>

<p>See <code>vignette("assertr")</code> for how to use this in context
</p>


<h3>See Also</h3>

<p><code><a href="#topic+verify">verify</a></code> <code><a href="#topic+insist">insist</a></code>
<code><a href="#topic+assert_rows">assert_rows</a></code> <code><a href="#topic+insist_rows">insist_rows</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# returns mtcars
assert(mtcars, not_na, vs)

# return mtcars
assert(mtcars, not_na, mpg:carb)

library(magrittr)                    # for piping operator

mtcars %&gt;%
  assert(in_set(c(0,1)), vs)
  # anything here will run

## Not run: 
mtcars %&gt;%
  assert(in_set(c(1, 2, 3, 4, 6)), carb)
  # the assertion is untrue so
  # nothing here will run
## End(Not run)

</code></pre>

<hr>
<h2 id='assert_rows'>Raises error if predicate is FALSE for any row after applying
row reduction function</h2><span id='topic+assert_rows'></span>

<h3>Description</h3>

<p>Meant for use in a data analysis pipeline, this function applies a
function to a data frame that reduces each row to a single value. Then,
a predicate function is applied to each of the row reduction values. If
any of these predicate applications yield FALSE, this function will raise
an error, effectively terminating the pipeline early. If there are no
FALSEs, this function will just return the data that it was supplied for
further use in later parts of the pipeline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assert_rows(
  data,
  row_reduction_fn,
  predicate,
  ...,
  success_fun = success_continue,
  error_fun = error_stop,
  skip_chain_opts = FALSE,
  obligatory = FALSE,
  defect_fun = defect_append,
  description = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assert_rows_+3A_data">data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="assert_rows_+3A_row_reduction_fn">row_reduction_fn</code></td>
<td>
<p>A function that returns a value for each row of
the provided data frame</p>
</td></tr>
<tr><td><code id="assert_rows_+3A_predicate">predicate</code></td>
<td>
<p>A function that returns FALSE when violated</p>
</td></tr>
<tr><td><code id="assert_rows_+3A_...">...</code></td>
<td>
<p>Comma separated list of unquoted expressions.
Uses dplyr's <code>select</code> to select
columns from data.</p>
</td></tr>
<tr><td><code id="assert_rows_+3A_success_fun">success_fun</code></td>
<td>
<p>Function to call if assertion passes. Defaults to
returning <code>data</code>.</p>
</td></tr>
<tr><td><code id="assert_rows_+3A_error_fun">error_fun</code></td>
<td>
<p>Function to call if assertion fails. Defaults to printing
a summary of all errors.</p>
</td></tr>
<tr><td><code id="assert_rows_+3A_skip_chain_opts">skip_chain_opts</code></td>
<td>
<p>If TRUE, <code>success_fun</code> and <code>error_fun</code>
are used even if assertion is called within a chain.</p>
</td></tr>
<tr><td><code id="assert_rows_+3A_obligatory">obligatory</code></td>
<td>
<p>If TRUE and assertion failed the data is marked as defective.
For defective data, all the following rules are handled by
<code>defect_fun</code> function.</p>
</td></tr>
<tr><td><code id="assert_rows_+3A_defect_fun">defect_fun</code></td>
<td>
<p>Function to call when data is defective. Defaults to skipping
assertion and storing info about it in special attribute.</p>
</td></tr>
<tr><td><code id="assert_rows_+3A_description">description</code></td>
<td>
<p>Custom description of the rule. Is stored in result
reports and data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For examples of possible choices for the <code>success_fun</code> and
<code>error_fun</code> parameters, run <code>help("success_and_error_functions")</code>
</p>


<h3>Value</h3>

<p>By default, the <code>data</code> is returned if predicate assertion
is TRUE and and error is thrown if not. If a non-default
<code>success_fun</code> or <code>error_fun</code> is used, the return
values of these function will be returned.
</p>


<h3>Note</h3>

<p>See <code>vignette("assertr")</code> for how to use this in context
</p>


<h3>See Also</h3>

<p><code><a href="#topic+insist_rows">insist_rows</a></code> <code><a href="#topic+assert">assert</a></code>
<code><a href="#topic+verify">verify</a></code> <code><a href="#topic+insist">insist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# returns mtcars
assert_rows(mtcars, num_row_NAs, within_bounds(0,2), mpg:carb)

library(magrittr)                    # for piping operator

mtcars %&gt;%
  assert_rows(rowSums, within_bounds(0,2), vs:am)
  # anything here will run

## Not run: 
mtcars %&gt;%
  assert_rows(rowSums, within_bounds(0,1), vs:am)
  # the assertion is untrue so
  # nothing here will run
## End(Not run)

</code></pre>

<hr>
<h2 id='assertr'>assertr: Assertive programming for R analysis pipeline.</h2><span id='topic+assertr'></span><span id='topic+assertr-package'></span>

<h3>Description</h3>

<p>The assertr package supplies a suite of functions designed to verify
assumptions about data early in an analysis pipeline.
See the assertr vignette or the documentation for more information <br />
&gt; <code>vignette("assertr")</code>
</p>


<h3>Details</h3>

<p>You may also want to read the documentation for the functions that
<code>assertr</code> provides:
</p>

<ul>
<li> <p><code><a href="#topic+assert">assert</a></code>
</p>
</li>
<li> <p><code><a href="#topic+verify">verify</a></code>
</p>
</li>
<li> <p><code><a href="#topic+insist">insist</a></code>
</p>
</li>
<li> <p><code><a href="#topic+assert_rows">assert_rows</a></code>
</p>
</li>
<li> <p><code><a href="#topic+insist_rows">insist_rows</a></code>
</p>
</li>
<li> <p><code><a href="#topic+not_na">not_na</a></code>
</p>
</li>
<li> <p><code><a href="#topic+in_set">in_set</a></code>
</p>
</li>
<li> <p><code><a href="#topic+has_all_names">has_all_names</a></code>
</p>
</li>
<li> <p><code><a href="#topic+is_uniq">is_uniq</a></code>
</p>
</li>
<li> <p><code><a href="#topic+num_row_NAs">num_row_NAs</a></code>
</p>
</li>
<li> <p><code><a href="#topic+maha_dist">maha_dist</a></code>
</p>
</li>
<li> <p><code><a href="#topic+col_concat">col_concat</a></code>
</p>
</li>
<li> <p><code><a href="#topic+within_bounds">within_bounds</a></code>
</p>
</li>
<li> <p><code><a href="#topic+within_n_sds">within_n_sds</a></code>
</p>
</li>
<li> <p><code><a href="#topic+within_n_mads">within_n_mads</a></code>
</p>
</li>
<li> <p><code><a href="#topic+success_and_error_functions">success_and_error_functions</a></code>
</p>
</li>
<li> <p><code><a href="#topic+chaining_functions">chaining_functions</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)     # for the piping operator
library(dplyr)

# this confirms that
#   - that the dataset contains more than 10 observations
#   - that the column for 'miles per gallon' (mpg) is a positive number
#   - that the column for 'miles per gallon' (mpg) does not contain a datum
#     that is outside 4 standard deviations from its mean, and
#   - that the am and vs columns (automatic/manual and v/straight engine,
#     respectively) contain 0s and 1s only
#   - each row contains at most 2 NAs
#   - each row's mahalanobis distance is within 10 median absolute deviations of
#     all the distance (for outlier detection)

mtcars %&gt;%
  verify(nrow(.) &gt; 10) %&gt;%
  verify(mpg &gt; 0) %&gt;%
  insist(within_n_sds(4), mpg) %&gt;%
  assert(in_set(0,1), am, vs) %&gt;%
  assert_rows(num_row_NAs, within_bounds(0,2), everything()) %&gt;%
  insist_rows(maha_dist, within_n_mads(10), everything()) %&gt;%
  group_by(cyl) %&gt;%
  summarise(avg.mpg=mean(mpg))


</code></pre>

<hr>
<h2 id='chaining_functions'>Chaining functions</h2><span id='topic+chaining_functions'></span><span id='topic+chain_start'></span><span id='topic+chain_end'></span>

<h3>Description</h3>

<p>These functions are for starting and ending a sequence of assertr
assertions and overriding the default behavior of assertr halting
execution on the first error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chain_start(data, store_success = FALSE)

chain_end(data, success_fun = success_continue, error_fun = error_report)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chaining_functions_+3A_data">data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="chaining_functions_+3A_store_success">store_success</code></td>
<td>
<p>If TRUE each successful assertion is stored in chain.</p>
</td></tr>
<tr><td><code id="chaining_functions_+3A_success_fun">success_fun</code></td>
<td>
<p>Function to call if assertion passes. Defaults to
returning <code>data</code>.</p>
</td></tr>
<tr><td><code id="chaining_functions_+3A_error_fun">error_fun</code></td>
<td>
<p>Function to call if assertion fails. Defaults to printing
a summary of all errors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more information, read the relevant section in this package's
vignette using, <code>vignette("assertr")</code>
</p>
<p>For examples of possible choices for the <code>success_fun</code> and
<code>error_fun</code> parameters, run <code>help("success_and_error_functions")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)

mtcars %&gt;%
  chain_start() %&gt;%
  verify(nrow(mtcars) &gt; 10) %&gt;%
  verify(mpg &gt; 0) %&gt;%
  insist(within_n_sds(4), mpg) %&gt;%
  assert(in_set(0,1), am, vs) %&gt;%
  chain_end()
</code></pre>

<hr>
<h2 id='col_concat'>Concatenate all columns of each row in data frame into a string</h2><span id='topic+col_concat'></span>

<h3>Description</h3>

<p>This function will return a vector, with the same length as the number
of rows of the provided data frame. Each element of the vector will be
it's corresponding row with all of its values (one for each column)
&quot;pasted&quot; together in a string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col_concat(data, sep = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="col_concat_+3A_data">data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="col_concat_+3A_sep">sep</code></td>
<td>
<p>A string to separate the columns with (default: &quot;&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of rows concatenated into strings
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+paste">paste</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
col_concat(mtcars)

library(magrittr)            # for piping operator

# you can use "assert_rows", "is_uniq", and this function to
# check if joint duplicates (across different columns) appear
# in a data frame
## Not run: 
mtcars %&gt;%
  assert_rows(col_concat, is_uniq, mpg, hp)
  # fails because the first two rows are jointly duplicates
  # on these two columns

## End(Not run)

mtcars %&gt;%
  assert_rows(col_concat, is_uniq, mpg, hp, wt) # ok

</code></pre>

<hr>
<h2 id='duplicates_across_cols'>Checks if row contains at least one value duplicated in its column</h2><span id='topic+duplicates_across_cols'></span>

<h3>Description</h3>

<p>This function will return a vector, with the same length as the number
of rows of the provided data frame. Each element of the vector will be
logical value that states if any value from the row was duplicated in
its column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>duplicates_across_cols(data, allow.na = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="duplicates_across_cols_+3A_data">data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="duplicates_across_cols_+3A_allow.na">allow.na</code></td>
<td>
<p>TRUE if we allow NAs in data. Default FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+paste">paste</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
df &lt;- data.frame(v1 = c(1, 1, 2, 3), v2 = c(4, 5, 5, 6))
duplicates_across_cols(df)

library(magrittr)            # for piping operator

# you can use "assert_rows", "in_set", and this function to
# check if specified variables set and all subsets are keys for the data.

correct_df &lt;- data.frame(id = 1:5, sub_id = letters[1:5], work_id = LETTERS[1:5])
correct_df %&gt;%
  assert_rows(duplicates_across_cols, in_set(FALSE), id, sub_id, work_id)
  # passes because each subset of correct_df variables is key

## Not run: 
incorrect_df &lt;- data.frame(id = 1:5, sub_id = letters[1:5], age = c(10, 20, 20, 15, 30))
incorrect_df %&gt;%
  assert_rows(duplicates_across_cols, in_set(FALSE), id, sub_id, age)
  # fails because age is not key of the data (age == 20 is placed twice)

## End(Not run)

</code></pre>

<hr>
<h2 id='generate_id'>Generates random ID string</h2><span id='topic+generate_id'></span>

<h3>Description</h3>

<p>This is used to generate id for each assertion error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_id()
</code></pre>


<h3>Details</h3>

<p>For single assertion that checks multiple columns, each error log
is stored as a separate element. We provide the ID to allow
detecting which errors come from the same assertion.
</p>

<hr>
<h2 id='has_all_names'>Returns TRUE if data.frame or list has specified names</h2><span id='topic+has_all_names'></span>

<h3>Description</h3>

<p>This function checks parent frame environment for existence of names.
This is meant to be used with &lsquo;assertr'&rsquo;s 'verify' function to check
for the existence of specific column names in a 'data.frame' that is
piped to 'verify'. It can also work on a non-'data.frame' list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_all_names(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="has_all_names_+3A_...">...</code></td>
<td>
<p>A arbitrary amount of quoted names to check for</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if all names exist, FALSE if not
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+exists">exists</a></code>
</p>
<p>Other Name verification: 
<code><a href="#topic+has_only_names">has_only_names</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
verify(mtcars, has_all_names("mpg", "wt", "qsec"))

library(magrittr)   # for pipe operator

## Not run: 
mtcars %&gt;%
  verify(has_all_names("mpgg"))  # fails

## End(Not run)

mpgg &lt;- "something"

mtcars %&gt;%
  verify(exists("mpgg"))   # passes but big mistake

## Not run: 
mtcars %&gt;%
  verify(has_all_names("mpgg")) # correctly fails

## End(Not run)

</code></pre>

<hr>
<h2 id='has_class'>Returns TRUE if data.frame columns have a specified class</h2><span id='topic+has_class'></span>

<h3>Description</h3>

<p>This is meant to be used with &lsquo;assertr'&rsquo;s 'verify' function to check
for the existence of a specific column class in a 'data.frame' that is
piped to 'verify'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_class(..., class)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="has_class_+3A_...">...</code></td>
<td>
<p>An arbitrary amount of quoted column names to check for</p>
</td></tr>
<tr><td><code id="has_class_+3A_class">class</code></td>
<td>
<p>Expected class for chosen columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if all classes are correct, FALSE if not
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
verify(mtcars, has_class("mpg", "wt", class = "numeric"))

library(magrittr)   # for pipe operator

## Not run: 
mtcars %&gt;%
  verify(has_class("mpg", class = "character"))  # fails

## End(Not run)

</code></pre>

<hr>
<h2 id='has_only_names'>Returns TRUE if data.frame or list has only the specified names</h2><span id='topic+has_only_names'></span>

<h3>Description</h3>

<p>This function checks parent frame environment for a specific set of names; if
more columns are present than those specified, an error is raised.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_only_names(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="has_only_names_+3A_...">...</code></td>
<td>
<p>A arbitrary amount of quoted names to check for</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is meant to be used with &lsquo;assertr'&rsquo;s 'verify' function to check
for the existence of specific column names in a 'data.frame' that is
piped to 'verify'. It can also work on a non-'data.frame' list.
</p>


<h3>Value</h3>

<p>TRUE is all names exist, FALSE if not
</p>


<h3>See Also</h3>

<p>Other Name verification: 
<code><a href="#topic+has_all_names">has_all_names</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# The last two columns names are switched in order, but all column names are
# present, so it passes.
verify(
  mtcars,
  has_only_names(c(
    "mpg", "cyl", "disp", "hp", "drat", "wt", "qsec", "vs", "am",
    "carb", "gear"
  ))
)

# More than one set of character strings can be provided.
verify(
  mtcars,
  has_only_names(
    c("mpg", "cyl", "disp", "hp", "drat", "wt", "qsec", "vs", "am"),
    c("carb", "gear")
  )
)

## Not run: 
# The some columns are missing, so it fails.
verify(mtcars, has_only_names("mpg"))

## End(Not run)
</code></pre>

<hr>
<h2 id='in_set'>Returns TRUE if value in set</h2><span id='topic+in_set'></span>

<h3>Description</h3>

<p>This function returns a predicate function that will take a single
value and return TRUE if the value is a member of the set of objects
supplied. This doesn't actually check the membership of anything&ndash;it
only returns a function that actually does the checking when called
with a value. This is a convenience function meant to return a
predicate function to be used in an <code><a href="#topic+assertr">assertr</a></code> assertion.
You can use the 'inverse' flag (default FALSE) to check if the
arguments are NOT in the set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>in_set(..., allow.na = TRUE, inverse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="in_set_+3A_...">...</code></td>
<td>
<p>objects that make up the set</p>
</td></tr>
<tr><td><code id="in_set_+3A_allow.na">allow.na</code></td>
<td>
<p>A logical indicating whether NAs (including NaNs)
should be permitted (default TRUE)</p>
</td></tr>
<tr><td><code id="in_set_+3A_inverse">inverse</code></td>
<td>
<p>A logical indicating whether it should test
if arguments are NOT in the set</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function that takes one value and returns TRUE
if the value is in the set defined by the
arguments supplied by <code>in_set</code> and FALSE
otherwise
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic++25in+25">%in%</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>predicate &lt;- in_set(3,4)
predicate(4)

## is equivalent to

in_set(3,4)(3)

# inverting the function works thusly...
in_set(3, 4, inverse=TRUE)(c(5, 2, 3))
# TRUE TRUE FALSE

# the remainder of division by 2 is always 0 or 1
rem &lt;- 10 %% 2
in_set(0,1)(rem)

## this is meant to be used as a predicate in an assert statement
assert(mtcars, in_set(3,4,5), gear)

## or in a pipeline, like this was meant for

library(magrittr)

mtcars %&gt;%
  assert(in_set(3,4,5), gear) %&gt;%
  assert(in_set(0,1), vs, am)

</code></pre>

<hr>
<h2 id='insist'>Raises error if dynamically created predicate is FALSE in any columns
selected</h2><span id='topic+insist'></span>

<h3>Description</h3>

<p>Meant for use in a data analysis pipeline, this function applies a predicate
generating function to each of the columns indicated. It will then use these
predicates to check every element of those columns. If any of these
predicate applications yield FALSE, this function will raise an error,
effectively terminating the pipeline early. If there are no FALSES, this
function will just return the data that it was supplied for further use in
later parts of the pipeline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>insist(
  data,
  predicate_generator,
  ...,
  success_fun = success_continue,
  error_fun = error_stop,
  skip_chain_opts = FALSE,
  obligatory = FALSE,
  defect_fun = defect_append,
  description = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="insist_+3A_data">data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="insist_+3A_predicate_generator">predicate_generator</code></td>
<td>
<p>A function that is applied
to each of the column vectors selected. This will produce,
for every column, a true predicate function to be applied to
every element in the column vectors selected</p>
</td></tr>
<tr><td><code id="insist_+3A_...">...</code></td>
<td>
<p>Comma separated list of unquoted expressions.
Uses dplyr's <code>select</code> to select
columns from data.</p>
</td></tr>
<tr><td><code id="insist_+3A_success_fun">success_fun</code></td>
<td>
<p>Function to call if assertion passes. Defaults to
returning <code>data</code>.</p>
</td></tr>
<tr><td><code id="insist_+3A_error_fun">error_fun</code></td>
<td>
<p>Function to call if assertion fails. Defaults to printing
a summary of all errors.</p>
</td></tr>
<tr><td><code id="insist_+3A_skip_chain_opts">skip_chain_opts</code></td>
<td>
<p>If TRUE, <code>success_fun</code> and <code>error_fun</code>
are used even if assertion is called within a chain.</p>
</td></tr>
<tr><td><code id="insist_+3A_obligatory">obligatory</code></td>
<td>
<p>If TRUE and assertion failed the data is marked as defective.
For defective data, all the following rules are handled by
<code>defect_fun</code> function.</p>
</td></tr>
<tr><td><code id="insist_+3A_defect_fun">defect_fun</code></td>
<td>
<p>Function to call when data is defective. Defaults to skipping
assertion and storing info about it in special attribute.</p>
</td></tr>
<tr><td><code id="insist_+3A_description">description</code></td>
<td>
<p>Custom description of the rule. Is stored in result
reports and data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For examples of possible choices for the <code>success_fun</code> and
<code>error_fun</code> parameters, run <code>help("success_and_error_functions")</code>
</p>


<h3>Value</h3>

<p>By default, the <code>data</code> is returned if dynamically created
predicate assertion is TRUE and and error is thrown if not. If a
non-default <code>success_fun</code> or <code>error_fun</code> is used, the
return values of these function will be returned.
</p>


<h3>Note</h3>

<p>See <code>vignette("assertr")</code> for how to use this in context
</p>


<h3>See Also</h3>

<p><code><a href="#topic+assert">assert</a></code> <code><a href="#topic+verify">verify</a></code> <code><a href="#topic+insist_rows">insist_rows</a></code>
<code><a href="#topic+assert_rows">assert_rows</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
insist(iris, within_n_sds(3), Sepal.Length)   # returns iris

library(magrittr)

iris %&gt;%
  insist(within_n_sds(4), Sepal.Length:Petal.Width)
  # anything here will run

## Not run: 
iris %&gt;%
  insist(within_n_sds(3), Sepal.Length:Petal.Width)
  # datum at index 16 of 'Sepal.Width' vector is (4.4)
  # is outside 3 standard deviations from the mean of Sepal.Width.
  # The check fails, raises a fatal error, and the pipeline
  # is terminated so nothing after this statement will run
## End(Not run)

</code></pre>

<hr>
<h2 id='insist_rows'>Raises error if dynamically created predicate is FALSE for any row
after applying row reduction function</h2><span id='topic+insist_rows'></span>

<h3>Description</h3>

<p>Meant for use in a data analysis pipeline, this function applies a
function to a data frame that reduces each row to a single value. Then,
a predicate generating function is applied to row reduction values. It will
then use these predicates to check each of the row reduction values. If any
of these predicate applications yield FALSE, this function will raise
an error, effectively terminating the pipeline early. If there are no
FALSEs, this function will just return the data that it was supplied for
further use in later parts of the pipeline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>insist_rows(
  data,
  row_reduction_fn,
  predicate_generator,
  ...,
  success_fun = success_continue,
  error_fun = error_stop,
  skip_chain_opts = FALSE,
  obligatory = FALSE,
  defect_fun = defect_append,
  description = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="insist_rows_+3A_data">data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="insist_rows_+3A_row_reduction_fn">row_reduction_fn</code></td>
<td>
<p>A function that returns a value for each row of
the provided data frame</p>
</td></tr>
<tr><td><code id="insist_rows_+3A_predicate_generator">predicate_generator</code></td>
<td>
<p>A function that is applied to the results of
the row reduction function. This will produce,
a true predicate function to be applied to every
element in the vector that the row reduction
function returns.</p>
</td></tr>
<tr><td><code id="insist_rows_+3A_...">...</code></td>
<td>
<p>Comma separated list of unquoted expressions.
Uses dplyr's <code>select</code> to select
columns from data.</p>
</td></tr>
<tr><td><code id="insist_rows_+3A_success_fun">success_fun</code></td>
<td>
<p>Function to call if assertion passes. Defaults to
returning <code>data</code>.</p>
</td></tr>
<tr><td><code id="insist_rows_+3A_error_fun">error_fun</code></td>
<td>
<p>Function to call if assertion fails. Defaults to printing
a summary of all errors.</p>
</td></tr>
<tr><td><code id="insist_rows_+3A_skip_chain_opts">skip_chain_opts</code></td>
<td>
<p>If TRUE, <code>success_fun</code> and <code>error_fun</code>
are used even if assertion is called within a chain.</p>
</td></tr>
<tr><td><code id="insist_rows_+3A_obligatory">obligatory</code></td>
<td>
<p>If TRUE and assertion failed the data is marked as defective.
For defective data, all the following rules are handled by
<code>defect_fun</code> function.</p>
</td></tr>
<tr><td><code id="insist_rows_+3A_defect_fun">defect_fun</code></td>
<td>
<p>Function to call when data is defective. Defaults to skipping
assertion and storing info about it in special attribute.</p>
</td></tr>
<tr><td><code id="insist_rows_+3A_description">description</code></td>
<td>
<p>Custom description of the rule. Is stored in result
reports and data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For examples of possible choices for the <code>success_fun</code> and
<code>error_fun</code> parameters, run <code>help("success_and_error_functions")</code>
</p>


<h3>Value</h3>

<p>By default, the <code>data</code> is returned if dynamically created
predicate assertion is TRUE and and error is thrown if not. If a
non-default <code>success_fun</code> or <code>error_fun</code> is used, the
return values of these function will be returned.
</p>


<h3>Note</h3>

<p>See <code>vignette("assertr")</code> for how to use this in context
</p>


<h3>See Also</h3>

<p><code><a href="#topic+insist">insist</a></code> <code><a href="#topic+assert_rows">assert_rows</a></code>
<code><a href="#topic+assert">assert</a></code> <code><a href="#topic+verify">verify</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# returns mtcars
insist_rows(mtcars, maha_dist, within_n_mads(30), mpg:carb)

library(magrittr)                    # for piping operator

mtcars %&gt;%
  insist_rows(maha_dist, within_n_mads(10), vs:am)
  # anything here will run

## Not run: 
mtcars %&gt;%
  insist_rows(maha_dist, within_n_mads(1), everything())
  # the assertion is untrue so
  # nothing here will run
## End(Not run)

</code></pre>

<hr>
<h2 id='is_uniq'>Returns TRUE where no elements appear more than once</h2><span id='topic+is_uniq'></span>

<h3>Description</h3>

<p>This function is meant to take only a vector. It relies heavily on
the <code><a href="base.html#topic+duplicated">duplicated</a></code> function where it can be thought of as
the inverse. Where this function differs, though&ndash;besides being only
meant for one vector or column&ndash;is that it marks the first occurrence
of a duplicated value as &quot;non unique&quot;, as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_uniq(..., allow.na = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_uniq_+3A_...">...</code></td>
<td>
<p>One or more vectors to check for unique combinations of elements</p>
</td></tr>
<tr><td><code id="is_uniq_+3A_allow.na">allow.na</code></td>
<td>
<p>A logical indicating whether NAs should be preserved
as missing values in the return value (FALSE) or
if they should be treated just like any other value
(TRUE) (default is FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the same length where the corresponding element
is TRUE if the element only appears once in the vector and
FALSE otherwise
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+duplicated">duplicated</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
is_uniq(1:10)
is_uniq(c(1,1,2,3), c(1,2,2,3))

## Not run: 
# returns FALSE where a "5" appears
is_uniq(c(1:10, 5))

## End(Not run)

library(magrittr)

## Not run: 
# this fails 4 times
mtcars %&gt;% assert(is_uniq, qsec)

## End(Not run)

# to use the version of this function that allows NAs in `assert`,
# you can use a lambda/anonymous function like so:

mtcars %&gt;%
  assert(function(x){is_uniq(x, allow.na=TRUE)}, qsec)

</code></pre>

<hr>
<h2 id='maha_dist'>Computes mahalanobis distance for each row of data frame</h2><span id='topic+maha_dist'></span>

<h3>Description</h3>

<p>This function will return a vector, with the same length as the number
of rows of the provided data frame, corresponding to the average
mahalanobis distances of each row from the whole data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maha_dist(data, keep.NA = TRUE, robust = FALSE, stringsAsFactors = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maha_dist_+3A_data">data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="maha_dist_+3A_keep.na">keep.NA</code></td>
<td>
<p>Ensure that every row with missing data remains NA in
the output? TRUE by default.</p>
</td></tr>
<tr><td><code id="maha_dist_+3A_robust">robust</code></td>
<td>
<p>Attempt to compute mahalanobis distance based on
robust covariance matrix? FALSE by default</p>
</td></tr>
<tr><td><code id="maha_dist_+3A_stringsasfactors">stringsAsFactors</code></td>
<td>
<p>Convert non-factor string columns into factors?
FALSE by default</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is useful for finding anomalous observations, row-wise.
</p>
<p>It will convert any categorical variables in the data frame into numerics
as long as they are factors. For example, in order for a character
column to be used as a component in the distance calculations, it must
either be a factor, or converted to a factor by using the
<code>stringsAsFactors</code> parameter.
</p>


<h3>Value</h3>

<p>A vector of observation-wise mahalanobis distances.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+insist_rows">insist_rows</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
maha_dist(mtcars)

maha_dist(iris, robust=TRUE)


library(magrittr)            # for piping operator
library(dplyr)               # for "everything()" function

# using every column from mtcars, compute mahalanobis distance
# for each observation, and ensure that each distance is within 10
# median absolute deviations from the median
mtcars %&gt;%
  insist_rows(maha_dist, within_n_mads(10), everything())
  ## anything here will run

</code></pre>

<hr>
<h2 id='not_na'>Returns TRUE if value is not NA</h2><span id='topic+not_na'></span>

<h3>Description</h3>

<p>This is the inverse of <code><a href="base.html#topic+is.na">is.na</a></code>. This is a convenience
function meant to be used as a predicate in an <code><a href="#topic+assertr">assertr</a></code>
assertion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>not_na(x, allow.NaN = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="not_na_+3A_x">x</code></td>
<td>
<p>A R object that supports <a href="Matrix.html#topic+is.na">is.na</a> an <a href="Matrix.html#topic+is.nan">is.nan</a></p>
</td></tr>
<tr><td><code id="not_na_+3A_allow.nan">allow.NaN</code></td>
<td>
<p>A logical indicating whether NaNs should be allowed
(default FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the same length that is TRUE when the element is
not NA and FALSE otherwise
</p>


<h3>See Also</h3>

<p><code><a href="Matrix.html#topic+is.na">is.na</a></code> <code><a href="Matrix.html#topic+is.nan">is.nan</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>not_na(NA)
not_na(2.8)
not_na("tree")
not_na(c(1, 2, NA, 4))

</code></pre>

<hr>
<h2 id='num_row_NAs'>Counts number of NAs in each row</h2><span id='topic+num_row_NAs'></span>

<h3>Description</h3>

<p>This function will return a vector, with the same length as the number
of rows of the provided data frame, corresponding to the number of missing
values in each row
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num_row_NAs(data, allow.NaN = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="num_row_NAs_+3A_data">data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="num_row_NAs_+3A_allow.nan">allow.NaN</code></td>
<td>
<p>Treat NaN like NA (by counting it). FALSE by default</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of number of missing values in each row
</p>


<h3>See Also</h3>

<p><code><a href="Matrix.html#topic+is.na">is.na</a></code> <code><a href="Matrix.html#topic+is.nan">is.nan</a></code> <code><a href="#topic+not_na">not_na</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
num_row_NAs(mtcars)


library(magrittr)            # for piping operator
library(dplyr)               # for "everything()" function

# using every column from mtcars, make sure there are at most
# 2 NAs in each row. If there are any more than two, error out
mtcars %&gt;%
  assert_rows(num_row_NAs, within_bounds(0,2), everything())
  ## anything here will run

</code></pre>

<hr>
<h2 id='print.assertr_assert_error'>Printing assertr's assert errors</h2><span id='topic+print.assertr_assert_error'></span>

<h3>Description</h3>

<p>'print' method for class &quot;assertr_assert_error&quot;
This prints the error message and the entire two-column
'data.frame' holding the indexes and values of the offending
data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'assertr_assert_error'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.assertr_assert_error_+3A_x">x</code></td>
<td>
<p>An assertr_assert_error object</p>
</td></tr>
<tr><td><code id="print.assertr_assert_error_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+summary.assertr_assert_error">summary.assertr_assert_error</a></code>
</p>

<hr>
<h2 id='print.assertr_defect'>Printing assertr's defect</h2><span id='topic+print.assertr_defect'></span>

<h3>Description</h3>

<p>'print' method for class &quot;assertr_defect&quot;
This prints the defect message along with columns that were checked.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'assertr_defect'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.assertr_defect_+3A_x">x</code></td>
<td>
<p>An assertr_defect object</p>
</td></tr>
<tr><td><code id="print.assertr_defect_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods</p>
</td></tr>
</table>

<hr>
<h2 id='print.assertr_success'>Printing assertr's success</h2><span id='topic+print.assertr_success'></span>

<h3>Description</h3>

<p>'print' method for class &quot;assertr_success&quot;
This prints the success message along with columns that were checked.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'assertr_success'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.assertr_success_+3A_x">x</code></td>
<td>
<p>An assertr_success object</p>
</td></tr>
<tr><td><code id="print.assertr_success_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods</p>
</td></tr>
</table>

<hr>
<h2 id='print.assertr_verify_error'>Printing assertr's verify errors</h2><span id='topic+print.assertr_verify_error'></span>

<h3>Description</h3>

<p>'summary' method for class &quot;assertr_verify_error&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'assertr_verify_error'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.assertr_verify_error_+3A_x">x</code></td>
<td>
<p>An assertr_verify_error object.</p>
</td></tr>
<tr><td><code id="print.assertr_verify_error_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+summary.assertr_verify_error">summary.assertr_verify_error</a></code>
</p>

<hr>
<h2 id='success_and_error_functions'>Success and error functions</h2><span id='topic+success_and_error_functions'></span><span id='topic+success_logical'></span><span id='topic+success_continue'></span><span id='topic+success_append'></span><span id='topic+success_report'></span><span id='topic+success_df_return'></span><span id='topic+error_stop'></span><span id='topic+just_warn'></span><span id='topic+error_report'></span><span id='topic+warn_report'></span><span id='topic+error_append'></span><span id='topic+warning_append'></span><span id='topic+error_return'></span><span id='topic+error_df_return'></span><span id='topic+error_logical'></span><span id='topic+defect_append'></span><span id='topic+defect_report'></span><span id='topic+defect_df_return'></span>

<h3>Description</h3>

<p>The behavior of functions like <code>assert</code>, <code>assert_rows</code>,
<code>insist</code>, <code>insist_rows</code>, <code>verify</code> when the assertion
passes or fails is configurable via the <code>success_fun</code>
and <code>error_fun</code> parameters, respectively.
The <code>success_fun</code> parameter takes a function that takes
the data passed to the assertion function as a parameter. You can
write your own success handler function, but there are a few
provided by this package:
</p>

<ul>
<li> <p><code>success_continue</code> - just returns the data that was
passed into the assertion function
</p>
</li>
<li> <p><code>success_logical</code> - returns TRUE
</p>
</li>
<li> <p><code>success_append</code> - returns the data that was
passed into the assertion function
but also stores basic information about
verification result
</p>
</li>
<li> <p><code>success_report</code> - When success results are stored, and each
verification ended up with success prints
summary of all successful validations
</p>
</li>
<li> <p><code>success_df_return</code> - When success results are stored, and each
verification ended up with success prints
data.frame with verification results
</p>
</li></ul>

<p>The <code>error_fun</code> parameter takes a function that takes
the data passed to the assertion function as a parameter. You can
write your own error handler function, but there are a few
provided by this package:
</p>

<ul>
<li> <p><code>error_stop</code> - Prints a summary of the errors and
halts execution.
</p>
</li>
<li> <p><code>error_report</code> - Prints all the information available
about the errors in a &quot;tidy&quot;
<code>data.frame</code> (including information
such as the name of the predicate used,
the offending value, etc...) and halts
execution.
</p>
</li>
<li> <p><code>error_append</code> - Attaches the errors to a special
attribute of <code>data</code> and returns the data. This is chiefly
to allow assertr errors to be accumulated in a pipeline so that
all assertions can have a chance to be checked and so that all
the errors can be displayed at the end of the chain.
</p>
</li>
<li> <p><code>error_return</code> - Returns the raw object containing all
the errors
</p>
</li>
<li> <p><code>error_df_return</code> - Returns a &quot;tidy&quot; <code>data.frame</code>
containing all the errors, including informations such as
the name of the predicate used, the offending value, etc...
</p>
</li>
<li> <p><code>error_logical</code> - returns FALSE
</p>
</li>
<li> <p><code>just_warn</code> - Prints a summary of the errors but does
not halt execution, it just issues a warning.
</p>
</li>
<li> <p><code>warn_report</code> - Prints all the information available
about the errors but does not halt execution, it just issues a warning.
</p>
</li>
<li> <p><code>defect_report</code> - For single rule and defective data it displays
short info about skipping current assertion. For <code>chain_end</code> sums
up all skipped rules for defective data.
</p>
</li>
<li> <p><code>defect_df_return</code> - For single rule and defective data it returns
info data.frame about skipping current assertion. For <code>chain_end</code>
returns all skipped rules info data.frame for defective data.
</p>
</li></ul>

<p>You may find the third type of data verification result. In a scenario
when validation rule was obligatory (obligatory = TRUE) in order to execute the
following ones we may want to skip them and register that fact.
In order to do this there are three callbacks reacting to defective
data:
</p>

<ul>
<li> <p><code>defect_report</code> - For single rule and defective data it displays
short info about skipping current assertion.
</p>
</li>
<li> <p><code>defect_df_return</code> - For single rule and defective data it returns
info data.frame about skipping current assertion.
</p>
</li>
<li> <p><code>defect_append</code> - Appends info about skipped rule due to data
defect into one of data attributes. Rules skipped on defective data, or its summary, can
be returned with proper error_fun callback in <code>chain_end</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>success_logical(data, ...)

success_continue(data, ...)

success_append(data, ...)

success_report(data, ...)

success_df_return(data, ...)

error_stop(errors, data = NULL, warn = FALSE, ...)

just_warn(errors, data = NULL)

error_report(errors, data = NULL, warn = FALSE, ...)

warn_report(errors, data = NULL)

error_append(errors, data = NULL)

warning_append(errors, data = NULL)

error_return(errors, data = NULL)

error_df_return(errors, data = NULL)

error_logical(errors, data = NULL, ...)

defect_append(errors, data, ...)

defect_report(errors, data, ...)

defect_df_return(errors, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="success_and_error_functions_+3A_data">data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="success_and_error_functions_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods</p>
</td></tr>
<tr><td><code id="success_and_error_functions_+3A_errors">errors</code></td>
<td>
<p>A list of objects of class <code>assertr_errors</code></p>
</td></tr>
<tr><td><code id="success_and_error_functions_+3A_warn">warn</code></td>
<td>
<p>If TRUE, assertr will issue a warning instead of an error</p>
</td></tr>
</table>

<hr>
<h2 id='summary.assertr_assert_error'>Summarizing assertr's assert errors</h2><span id='topic+summary.assertr_assert_error'></span>

<h3>Description</h3>

<p>'summary' method for class &quot;assertr_assert_error&quot;
This prints the error message and the first five
rows of the two-column 'data.frame' holding the
indexes and values of the offending data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'assertr_assert_error'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.assertr_assert_error_+3A_object">object</code></td>
<td>
<p>An assertr_assert_error object</p>
</td></tr>
<tr><td><code id="summary.assertr_assert_error_+3A_...">...</code></td>
<td>
<p>Additional arguments affecting the summary produced</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+print.assertr_assert_error">print.assertr_assert_error</a></code>
</p>

<hr>
<h2 id='summary.assertr_verify_error'>Summarizing assertr's verify errors</h2><span id='topic+summary.assertr_verify_error'></span>

<h3>Description</h3>

<p>'summary' method for class &quot;assertr_verify_error&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'assertr_verify_error'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.assertr_verify_error_+3A_object">object</code></td>
<td>
<p>An assertr_verify_error object</p>
</td></tr>
<tr><td><code id="summary.assertr_verify_error_+3A_...">...</code></td>
<td>
<p>Additional arguments affecting the summary produced</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+print.assertr_verify_error">print.assertr_verify_error</a></code>
</p>

<hr>
<h2 id='verify'>Raises error if expression is FALSE anywhere</h2><span id='topic+verify'></span>

<h3>Description</h3>

<p>Meant for use in a data analysis pipeline, this function will
just return the data it's supplied if all the logicals in the
expression supplied are TRUE. If at least one is FALSE, this
function will raise a error, effectively terminating the pipeline
early
</p>


<h3>Usage</h3>

<pre><code class='language-R'>verify(
  data,
  expr,
  success_fun = success_continue,
  error_fun = error_stop,
  skip_chain_opts = FALSE,
  obligatory = FALSE,
  defect_fun = defect_append,
  description = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="verify_+3A_data">data</code></td>
<td>
<p>A data frame, list, or environment</p>
</td></tr>
<tr><td><code id="verify_+3A_expr">expr</code></td>
<td>
<p>A logical expression</p>
</td></tr>
<tr><td><code id="verify_+3A_success_fun">success_fun</code></td>
<td>
<p>Function to call if assertion passes. Defaults to
returning <code>data</code>.</p>
</td></tr>
<tr><td><code id="verify_+3A_error_fun">error_fun</code></td>
<td>
<p>Function to call if assertion fails. Defaults to printing
a summary of all errors.</p>
</td></tr>
<tr><td><code id="verify_+3A_skip_chain_opts">skip_chain_opts</code></td>
<td>
<p>If TRUE, <code>success_fun</code> and <code>error_fun</code>
are used even if assertion is called within a chain.</p>
</td></tr>
<tr><td><code id="verify_+3A_obligatory">obligatory</code></td>
<td>
<p>If TRUE and assertion failed the data is marked as defective.
For defective data, all the following rules are handled by
<code>defect_fun</code> function.</p>
</td></tr>
<tr><td><code id="verify_+3A_defect_fun">defect_fun</code></td>
<td>
<p>Function to call when data is defective. Defaults to skipping
assertion and storing info about it in special attribute.</p>
</td></tr>
<tr><td><code id="verify_+3A_description">description</code></td>
<td>
<p>Custom description of the rule. Is stored in result
reports and data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For examples of possible choices for the <code>success_fun</code> and
<code>error_fun</code> parameters, run <code>help("success_and_error_functions")</code>
</p>


<h3>Value</h3>

<p>By default, the <code>data</code> is returned if predicate assertion
is TRUE and and error is thrown if not. If a non-default
<code>success_fun</code> or <code>error_fun</code> is used, the return
values of these function will be returned.
</p>


<h3>Note</h3>

<p>See <code>vignette("assertr")</code> for how to use this in context
</p>


<h3>See Also</h3>

<p><code><a href="#topic+assert">assert</a></code> <code><a href="#topic+insist">insist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
verify(mtcars, drat &gt; 2)     # returns mtcars
## Not run: 
verify(mtcars, drat &gt; 3)     # produces error
## End(Not run)


library(magrittr)            # for piping operator

## Not run: 
mtcars %&gt;%
  verify(drat &gt; 3) %&gt;%
  # anything here will not run
## End(Not run)

mtcars %&gt;%
  verify(nrow(mtcars) &gt; 2)
  # anything here will run

alist &lt;- list(a=c(1,2,3), b=c(4,5,6))
verify(alist, length(a) &gt; 2)
verify(alist, length(a) &gt; 2 &amp;&amp; length(b) &gt; 2)
verify(alist, a &gt; 0 &amp; b &gt; 2)

## Not run: 
alist %&gt;%
  verify(alist, length(a) &gt; 5)
  # nothing here will run
## End(Not run)


</code></pre>

<hr>
<h2 id='within_bounds'>Creates bounds checking predicate</h2><span id='topic+within_bounds'></span>

<h3>Description</h3>

<p>This function returns a predicate function that will take a numeric value
or vector and return TRUE if the value(s) is/are within the bounds set.
This does not actually check the bounds of anything&ndash;it only returns
a function that actually does the checking when called with a number.
This is a convenience function meant to return a predicate function to
be used in an <code><a href="#topic+assertr">assertr</a></code> assertion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>within_bounds(
  lower.bound,
  upper.bound,
  include.lower = TRUE,
  include.upper = TRUE,
  allow.na = TRUE,
  check.class = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="within_bounds_+3A_lower.bound">lower.bound</code></td>
<td>
<p>The lowest permitted value</p>
</td></tr>
<tr><td><code id="within_bounds_+3A_upper.bound">upper.bound</code></td>
<td>
<p>The upper permitted value</p>
</td></tr>
<tr><td><code id="within_bounds_+3A_include.lower">include.lower</code></td>
<td>
<p>A logical indicating whether lower bound
should be inclusive (default TRUE)</p>
</td></tr>
<tr><td><code id="within_bounds_+3A_include.upper">include.upper</code></td>
<td>
<p>A logical indicating whether upprt bound
should be inclusive (default TRUE)</p>
</td></tr>
<tr><td><code id="within_bounds_+3A_allow.na">allow.na</code></td>
<td>
<p>A logical indicating whether NAs (including NaNs)
should be permitted (default TRUE)</p>
</td></tr>
<tr><td><code id="within_bounds_+3A_check.class">check.class</code></td>
<td>
<p>Should the class of the <code>lower.bound</code>,
<code>upper_bound</code>, and the input to the returned function be checked
to be numeric or of the same class?  If <code>FALSE</code>, the comparison
may have unexpected results.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function that takes numeric value or numeric vactor and returns
TRUE if the value(s) is/are within the bounds defined by the
arguments supplied by <code>within_bounds</code> and FALSE
otherwise
</p>


<h3>Examples</h3>

<pre><code class='language-R'>predicate &lt;- within_bounds(3,4)
predicate(pi)

## is equivalent to

within_bounds(3,4)(pi)

# a correlation coefficient must always be between 0 and 1
coeff &lt;- cor.test(c(1,2,3), c(.5, 2.4, 4))[["estimate"]]
within_bounds(0,1)(coeff)

## check for positive number
positivep &lt;- within_bounds(0, Inf, include.lower=FALSE)

## this is meant to be used as a predicate in an assert statement
assert(mtcars, within_bounds(4,8), cyl)

## or in a pipeline

library(magrittr)

mtcars %&gt;%
  assert(within_bounds(4,8), cyl)

</code></pre>

<hr>
<h2 id='within_n_mads'>Return a function to create robust z-score checking predicate</h2><span id='topic+within_n_mads'></span>

<h3>Description</h3>

<p>This function takes one argument, the number of median absolute
deviations within which to accept a particular data point. This is
generally more useful than its sister function <code><a href="#topic+within_n_sds">within_n_sds</a></code>
because it is more robust to the presence of outliers. It is therefore
better suited to identify potentially erroneous data points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>within_n_mads(n, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="within_n_mads_+3A_n">n</code></td>
<td>
<p>The number of median absolute deviations from the median
within which to accept a datum</p>
</td></tr>
<tr><td><code id="within_n_mads_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code><a href="#topic+within_bounds">within_bounds</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>As an example, if '2' is passed into this function, this will return
a function that takes a vector and figures out the bounds of two
median absolute deviations (MADs) from the median. That function will then
return a <code><a href="#topic+within_bounds">within_bounds</a></code> function that can then be applied
to a single datum. If the datum is within two MADs of the median of the
vector given to the function returned by this function, it will return TRUE.
If not, FALSE.
</p>
<p>This function isn't meant to be used on its own, although it can. Rather,
this function is meant to be used with the <code><a href="#topic+insist">insist</a></code> function to
search for potentially erroneous data points in a data set.
</p>


<h3>Value</h3>

<p>A function that takes a vector and returns a
<code><a href="#topic+within_bounds">within_bounds</a></code> predicate based on the MAD
of that vector.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+within_n_sds">within_n_sds</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test.vector &lt;- rnorm(100, mean=100, sd=20)

within.one.mad &lt;- within_n_mads(1)
custom.bounds.checker &lt;- within.one.mad(test.vector)
custom.bounds.checker(105)     # returns TRUE
custom.bounds.checker(40)      # returns FALSE

# same as
within_n_mads(1)(test.vector)(40)    # returns FALSE

within_n_mads(2)(test.vector)(as.numeric(NA))  # returns TRUE
# because, by default, within_bounds() will accept
# NA values. If we want to reject NAs, we have to
# provide extra arguments to this function
within_n_mads(2, allow.na=FALSE)(test.vector)(as.numeric(NA))  # returns FALSE

# or in a pipeline, like this was meant for

library(magrittr)

iris %&gt;%
  insist(within_n_mads(5), Sepal.Length)

</code></pre>

<hr>
<h2 id='within_n_sds'>Return a function to create z-score checking predicate</h2><span id='topic+within_n_sds'></span>

<h3>Description</h3>

<p>This function takes one argument, the number of standard deviations
within which to accept a particular data point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>within_n_sds(n, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="within_n_sds_+3A_n">n</code></td>
<td>
<p>The number of standard deviations from the mean
within which to accept a datum</p>
</td></tr>
<tr><td><code id="within_n_sds_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code><a href="#topic+within_bounds">within_bounds</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>As an example, if '2' is passed into this function, this will return
a function that takes a vector and figures out the bounds of two
standard deviations from the mean. That function will then return
a <code><a href="#topic+within_bounds">within_bounds</a></code> function that can then be applied
to a single datum. If the datum is within two standard deviations of
the mean of the vector given to the function returned by this function,
it will return TRUE. If not, FALSE.
</p>
<p>This function isn't meant to be used on its own, although it can. Rather,
this function is meant to be used with the <code><a href="#topic+insist">insist</a></code> function to
search for potentially erroneous data points in a data set.
</p>


<h3>Value</h3>

<p>A function that takes a vector and returns a
<code><a href="#topic+within_bounds">within_bounds</a></code> predicate based on the standard deviation
of that vector.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+within_n_mads">within_n_mads</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test.vector &lt;- rnorm(100, mean=100, sd=20)

within.one.sd &lt;- within_n_sds(1)
custom.bounds.checker &lt;- within.one.sd(test.vector)
custom.bounds.checker(105)     # returns TRUE
custom.bounds.checker(40)      # returns FALSE

# same as
within_n_sds(1)(test.vector)(40)    # returns FALSE

within_n_sds(2)(test.vector)(as.numeric(NA))  # returns TRUE
# because, by default, within_bounds() will accept
# NA values. If we want to reject NAs, we have to
# provide extra arguments to this function
within_n_sds(2, allow.na=FALSE)(test.vector)(as.numeric(NA))  # returns FALSE

# or in a pipeline, like this was meant for

library(magrittr)

iris %&gt;%
  insist(within_n_sds(5), Sepal.Length)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
