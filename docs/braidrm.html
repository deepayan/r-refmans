<!DOCTYPE html><html lang="en"><head><title>Help for package braidrm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {braidrm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#additiveExample'><p>Example Additive Surface</p></a></li>
<li><a href='#antagonisticExample'><p>Example Antagonistic Surface</p></a></li>
<li><a href='#braidrm'><p>BRAID Response Surface Fitting</p></a></li>
<li><a href='#calcBraidBootstrap'><p>BRAID Parameter Confidence Intervals</p></a></li>
<li><a href='#calcBraidConfInt'><p>Generic BRAID confidence intervals</p></a></li>
<li><a href='#coactiveExample'><p>Example Coactive Surface</p></a></li>
<li><a href='#deviationSurface'><p>Non-interacting Reference Surfaces</p></a></li>
<li><a href='#estimateCombinationIndices'><p>Combination Index</p></a></li>
<li><a href='#estimateIAE'><p>BRAID Response Surface Combined Potency</p></a></li>
<li><a href='#evalBraidModel'><p>Evaluate the BRAID response surface model</p></a></li>
<li><a href='#evalFlippedBraidModel'><p>Evaluate Flipped BRAID Surfaces</p></a></li>
<li><a href='#evalMusycModel'><p>Evaluate MuSyC Response Surfaces</p></a></li>
<li><a href='#evalUrsaModel'><p>Evaluate URSA response surface model</p></a></li>
<li><a href='#findBestBraid'><p>Select Best BRAID Response Fit</p></a></li>
<li><a href='#fitBraidFlipped'><p>Fit Flipped BRAID Surfaces</p></a></li>
<li><a href='#fitMusycModel'><p>MuSyC Response Surface Fitting</p></a></li>
<li><a href='#fitUrsaModel'><p>URSA Response Surface Fitting</p></a></li>
<li><a href='#incompleteExample'><p>Example Partial or Incomplete Surface</p></a></li>
<li><a href='#invertBraidModel'><p>Invert a BRAID Response Surface Model</p></a></li>
<li><a href='#invertFlippedBraidModel'><p>Invert Flipped BRAID Surfaces</p></a></li>
<li><a href='#kappaPrior'><p>Braid kappa Bayesian Prior</p></a></li>
<li><a href='#oppositionalExample'><p>Example Oppositional Surface</p></a></li>
<li><a href='#protectiveExample'><p>Example Protective Surface</p></a></li>
<li><a href='#synergisticExample'><p>Example Synergistic Surface</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Fitting Combined Action with the BRAID Response Surface Model</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains functions for evaluating, analyzing, and fitting combined
    action dose response surfaces with the Bivariate Response to Additive
    Interacting Doses (BRAID) model of combined action, along with tools for
    implementing other combination analysis methods, including Bliss independence,
    combination index, and additional response surface methods.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>rmarkdown</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.10)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Suggests:</td>
<td>braidReports (&ge; 1.0.0), knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Imports:</td>
<td>basicdrm, stats</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-26 15:34:15 UTC; ntwarog</td>
</tr>
<tr>
<td>Author:</td>
<td>Anang Shelat [aut],
  Nathaniel R. Twarog [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nathaniel R. Twarog &lt;nathaniel.twarog@stjude.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-26 21:00:41 UTC</td>
</tr>
</table>
<hr>
<h2 id='additiveExample'>Example Additive Surface</h2><span id='topic+additiveExample'></span>

<h3>Description</h3>

<p>A synthetically generated response surface using a additive parameter vector.
The surface was generated with IDMA of 1, IDMB of 1, na of 3, nb of 3,
kappa of 0, E0 of 0, EfA of 1, EfB of 1, and Ef of 1. Every pair of
concentrations is sampled once, with concentrations of 0 and a seven-point
two-fold dilution from 0.125 to 8. &quot;Measurements&quot; were sampled from a
normal noise distribution around ground truth values with a standard
deviation of 0.07.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>additiveExample
</code></pre>


<h3>Format</h3>

<p>A data frame with 64 rows and 4 columns
</p>

<dl>
<dt>concA</dt><dd><p>The concentration of drug A</p>
</dd>
<dt>concB</dt><dd><p>The concentration of drug B</p>
</dd>
<dt>truth</dt><dd><p>The true response surface value at the given dose pair</p>
</dd>
<dt>measure</dt><dd><p>The sampled noisy measurement of the response surface at
the given dose pair</p>
</dd>
</dl>


<hr>
<h2 id='antagonisticExample'>Example Antagonistic Surface</h2><span id='topic+antagonisticExample'></span>

<h3>Description</h3>

<p>A synthetically generated response surface using a antagonistic parameter vector.
The surface was generated with IDMA of 1, IDMB of 1, na of 3, nb of 3,
kappa of -1, E0 of 0, EfA of 1, EfB of 1, and Ef of 1. Every pair of
concentrations is sampled once, with concentrations of 0 and a seven-point
two-fold dilution from 0.125 to 8. &quot;Measurements&quot; were sampled from a
normal noise distribution around ground truth values with a standard
deviation of 0.07.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>antagonisticExample
</code></pre>


<h3>Format</h3>

<p>A data frame with 64 rows and 4 columns
</p>

<dl>
<dt>concA</dt><dd><p>The concentration of drug A</p>
</dd>
<dt>concB</dt><dd><p>The concentration of drug B</p>
</dd>
<dt>truth</dt><dd><p>The true response surface value at the given dose pair</p>
</dd>
<dt>measure</dt><dd><p>The sampled noisy measurement of the response surface at
the given dose pair</p>
</dd>
</dl>


<hr>
<h2 id='braidrm'>BRAID Response Surface Fitting</h2><span id='topic+braidrm'></span><span id='topic+summary.braidrm'></span><span id='topic+print.summary.braidrm'></span><span id='topic+print.braidrm'></span><span id='topic+braidrm.formula'></span><span id='topic+braidrm.default'></span>

<h3>Description</h3>

<p>Fits a BRAID response surface model to data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>braidrm(
  formula,
  data,
  model = "kappa2",
  links = NULL,
  weights = NULL,
  start = NULL,
  direction = 0,
  lower = NULL,
  upper = NULL,
  prior = "moderate",
  getCIs = TRUE
)

## S3 method for class 'braidrm'
summary(object, ...)

## S3 method for class 'summary.braidrm'
print(x, ...)

## S3 method for class 'braidrm'
print(x, ...)

## S3 method for class 'formula'
braidrm(
  formula,
  data,
  model = "kappa2",
  links = NULL,
  weights = NULL,
  start = NULL,
  direction = 0,
  lower = NULL,
  upper = NULL,
  prior = "moderate",
  getCIs = TRUE
)

## Default S3 method:
braidrm(
  formula,
  data,
  model = "kappa2",
  links = NULL,
  weights = NULL,
  start = NULL,
  direction = 0,
  lower = NULL,
  upper = NULL,
  prior = "moderate",
  getCIs = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="braidrm_+3A_formula">formula</code></td>
<td>
<p>Either an object of class <code>formula</code> such as would be provided
to a modeling function like <code><a href="stats.html#topic+lm">stats::lm()</a></code>, or a width-2 numeric array vector
of concentration pairs (including 0 or Inf).  A formula should specify a
single output as a function of two inputs, eg. <code>activity ~ conc1 + conc2</code>.</p>
</td></tr>
<tr><td><code id="braidrm_+3A_data">data</code></td>
<td>
<p>If <code>forumula</code> is a symbolic formula, a data frame containing the
specified values. If <code>formula</code> is a numeric array of concentrations, a
numeric vector of response values, the same length as the number of rows of
<code>formula</code>.</p>
</td></tr>
<tr><td><code id="braidrm_+3A_model">model</code>, <code id="braidrm_+3A_links">links</code></td>
<td>
<p>Parameters <code>model</code> and <code>links</code> are used to specify which
variant of the BRAID model is fit to data.  Model may be one of the
following character strings: &quot;kappa1&quot;, &quot;kappa2&quot;, or &quot;kappa3&quot; (see Details),
or a subset of the numbers 1 through 9 specifying which of the nine BRAID
response surface parameters is allowed to vary when fitting.  <code>links</code> allows
the user to further specify constraints on the three BRAID maximal effect
parameters (see Details for more).  If <code>model</code> is one of the supported
character strings, the parameter <code>links</code> will be ignored.</p>
</td></tr>
<tr><td><code id="braidrm_+3A_weights">weights</code></td>
<td>
<p>A vector of weights (between 0 and 1) the same length as
the data which determines the weight with which each measurement
will impact the the sum of squared errors.  Weights will be multiplied by
errors <em>before</em> squaring.  If <code>NULL</code> (the default) all weights will be set
to 1. Can be a numeric vector, or the name of a column in <code>data</code> if <code>formula</code>
is a symbolic formula</p>
</td></tr>
<tr><td><code id="braidrm_+3A_start">start</code></td>
<td>
<p>A BRAID parameter vector specifying the first guess where the
non-linear optimization should begin.  May be a length 7, 8, or 9 vector,
though a full length vector is always preferable.  If <code>NULL</code> (the default),
it will be estimated from the data.</p>
</td></tr>
<tr><td><code id="braidrm_+3A_direction">direction</code></td>
<td>
<p>Determines the possible directionality of the BRAID
model.  If 0 (the default) no additional constraints are placed on the
parameters.  If greater than 0, the fitting will require that the maximal
effects are all <em>greater</em> than or equal to the minimal effect.  If less
than 0, the fitting will require that all maximal effect is <em>less</em> than or
equal to the minimal effect.</p>
</td></tr>
<tr><td><code id="braidrm_+3A_lower">lower</code></td>
<td>
<p>A numeric vector of lower bounds on the fitted parameter values.
May be the same length as the number of fitted parameters, or a full,
length-9 vector. Missing or unspecified lower bounds may be included as <code>NA</code>
or <code>Inf</code>; if unspecified, lower bounds on the first five parameters (IDMA,
IDMB, na, nb, and kappa) will be automatically estimated from the data.
Bounds on the minimal and maximal effect parameters however (E0, EfA, EfB,
and Ef) will be assumed to be infinite unless specified.  A value of <code>NULL</code>,
the default, will be treated as all lower parameter bounds being
unspecified.</p>
</td></tr>
<tr><td><code id="braidrm_+3A_upper">upper</code></td>
<td>
<p>A numeric vector of upper bounds on the fitted parameter values.
Used in the same way as <code>lower</code>.</p>
</td></tr>
<tr><td><code id="braidrm_+3A_prior">prior</code></td>
<td>
<p>A character string specifying the desired Bayesian prior term
for kappa, or an object of class <code>kappaPrior</code> genererated by the function
<code><a href="#topic+kappaPrior">kappaPrior()</a></code>.  Allowed strings are &quot;mild&quot;, &quot;moderate&quot; (the default),
&quot;high&quot;, or &quot;none&quot;.  If a string is given, the kappa prior object will be
estimated from the data using an initial ten-parameter fit to approximate
measurement noise.</p>
</td></tr>
<tr><td><code id="braidrm_+3A_getcis">getCIs</code></td>
<td>
<p>Should bootstrapped confidence intervals be estimated and
added to the BRAID fit object. Default value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="braidrm_+3A_object">object</code></td>
<td>
<p>An object of class <code>braidrm</code> to be summarized</p>
</td></tr>
<tr><td><code id="braidrm_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="braidrm_+3A_x">x</code></td>
<td>
<p>An object of class <code>braidrm</code> or <code>summary.braidrm</code> to be printed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>One of the hairiest and most confusing aspects of fitting a combined
response surface model is handling the relationships between maximal effects.
Unlike a simple dose response model such as those fit in <code>basicdrm</code> in which
all parameters can be treated as fairly independent, response surface models
are often considered with constraints that cannot be expressed as simply one
parameter being fixed a particular value.  Many response surface models
assume that the two drugs in combination (and the overall combination) share
a single common maximal effect; others might assume that the maximal effects
of the two drugs should differ but that the overall maximal effect must be
equal to one of these; still others may wish to fit with no constraints on
maximal effect at all beyond guaranteeing that they lie above a fixed
minimal effect.  All these approaches are valid, and creating a functional
interface to support them all is a challenge. The parameters given here
represent our best effort to balance ease-of-use with flexibility.
</p>
<p>The primary interface for model selection and customization is the paired
paramters <code>model</code> and <code>links</code>.  For the first six parameters of the BRAID
surface, <code>model</code> is the only relevant control, and operates much as it would
in any fitting function.  If a given parameter (say IDMB) is included in
<code>model</code> (as index 2) then it will vary freely within the provided bounds to
best fit the data.  If it is not, the value will be fixed at the value given
in <code>start</code> (or if <code>start</code> is <code>NULL</code>, estimated from the data), and will
remain fixed at that value in the best fit surface.
</p>
<p>Parameters EfA, EfB, and Ef (the maximal effect parameters) require slightly
more care. Relationships between these values is represented by the <code>links</code>
parameter, which can take on one of the following five values:
</p>

<ul>
<li><p> &quot;AB&quot;: Indicating that the overall Ef parameter is the driver, both EfA and
EfB are constrained to be equal to Ef, whatever its value.  Can be used
when indices 7 and 8 (EfA and EfB) are absent from <code>model</code>, but index 9 (Ef)
is present
</p>
</li>
<li><p> &quot;F&quot;: Indicating instead that the individual parameters EfA and EfB are
the drivers, and EfA is constrained to be equal to larger magnitude of the
two. Can be used when indices 7 and 8 are present <code>model</code>, but index 9 is
absent
</p>
</li>
<li><p> &quot;A&quot;: Specifies that the overall maximal effect is equal to that of the
first trug (and consequentially that the effect of drug A must be of greater
or equal magnitude to that of drug B).  Can be used when index 7 is
absent in <code>model</code> and index 9 is present; index 8 may be present or absent
</p>
</li>
<li><p> &quot;B&quot;: Specifies that the overall maximal effect is equal to that of the
second drug.  Can be used when index 8 is  absent in <code>model</code> and index 9 is
present; index 7 may be present or absent
</p>
</li>
<li><p> &quot;&quot; (the empty string): Indicates no equality between maximal effects.
Parameters that are present in <code>model</code> vary freely in fitting, those that
are absent are fixed at constant values.
</p>
</li></ul>

<p>For example, if the maximal effects <em>should</em> be fit, but should be
constrained to be all equal, then it is the parameter Ef that varies freely
in the fitting; the fact that EfA and EfB are always equal to this value is
represented by setting the <code>links</code> parameter to &quot;AB&quot;.  Contrast this with the
(admittedly much less common) scenario in which the <code>links</code> parameter is set
to the empty string &quot;&quot;, representing no link between maximal effects. In this
case the parameter Ef will indeed vary freely in the fitting, but EfA and
EfB will instead always be held at the constant initial values in the
starting parameter vector.  On the other hand, if we were to assume that the
two individual maximum effect parameters can vary independently, but that
the overall maximal effect should be equal to the larger of the two, then
indices 7 and 8 (representing EfA and EfB) would be included in <code>model</code>;
index 9 (representing Ef) would be excluded, and the <code>links</code> parameter would
be set to &quot;F&quot; indicating that Ef is tied to the larger of the two.
</p>
<p>Note also that the default value for <code>links</code> is <em>not</em> the empty string, but
instead <code>NULL</code>.  By default the value of <code>links</code> will be guessed from the
model vector, based on the scenarios that we have encountered most often.
If <code>model</code> inclues Ef (index 9) but not EfA or EfB (indices 7 and 8), <code>links</code>
is assumed to be &quot;F&quot;; if EfA and EfB are present but not Ef, <code>links</code> is set
to &quot;AB&quot;. In the vast majority of cases, you will not need to specify this
parameter yourself.  This is especially true when <code>model</code> is specified with
one of the model strings, in which any provided value for <code>links</code> will be
discarded and replaced witht the following preset models:
</p>

<ul>
<li><p> kappa1: Model vector includes (1, 2, 3, 4, 5, 6, 9) and <code>links</code> is set to
&quot;AB&quot;
</p>
</li>
<li><p> kappa2: Model vector includes (1, 2, 3, 4, 5, 6, 7, 8) and <code>links</code> is set
to &quot;F&quot;
</p>
</li>
<li><p> kappa3: Model vector includes (1, 2, 3, 4, 5, 6, 7, 8, 9) and <code>links</code> is
set to the empty string
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class <code>braidrm</code> containing the following elements:
</p>

<ul>
<li> <p><code>concs</code>: A width-two array of the concentration pairs fit by the model
</p>
</li>
<li> <p><code>act</code>: A vector of responses fit by the model
</p>
</li>
<li> <p><code>weights</code>: The vector of weights (the same length as <code>act</code>) specifying
the relative weight of each measurement
</p>
</li>
<li> <p><code>coefficients</code>: A full length-9 named BRAID parameter vector representing
the best fit BRAID surface for the data
</p>
</li>
<li> <p><code>fitted.values</code>: A vector of responses (the same length of <code>act</code>) given by
the best fit response surface as a function of the concentrations in <code>concs</code>
</p>
</li>
<li> <p><code>residuals</code>: The fitting errors of the best fit model, equal to the
<code>fitted.values</code> subtracted from <code>act</code>
<code>scenario</code>: A character string specifying one of 32 distinct fitting
scenarios determined from the parameters <code>model</code>, <code>links</code>, and <code>start</code>. Used
in bootstrapping confidence intervals
</p>
</li>
<li> <p><code>model</code>: The model vector (a subset of values between 1 and 9) specifying
which BRAID parameters were varying freely in the fit
</p>
</li>
<li> <p><code>start</code>: The length-9 starting BRAID parameter vector used in non-linear
optimization
</p>
</li>
<li> <p><code>direction</code>: Like the input parameter, a value of -1, 0, or 1 specifying
the constraint on the directionality of the fitted surface
</p>
</li>
<li> <p><code>pbounds</code>: A 2-by-k array of values specifying the lower and upper bounds
of all varying parameters (where k is the number of free parameters).
</p>
</li>
<li> <p><code>kweight</code>: A numeric value summarizing the relative Bayesian influence of
the BRAID parameter kappa on optimized objective function.
</p>
</li></ul>

<p>Fit objects with bootstrapped confidence intervals include several additional
elements derived from that; see <code><a href="#topic+calcBraidBootstrap">calcBraidBootstrap()</a></code> for details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bfit1 &lt;- braidrm(measure ~ concA + concB, additiveExample)
summary(bfit1)

bfit2 &lt;- braidrm(measure ~ concA + concB, synergisticExample,
                 model = c(1,2,3,4,5,6,9),
                 lower = c(NA,NA,NA,NA,NA,0,0),
                 prior = "none",
                 getCIs = FALSE)
summary(bfit2)
</code></pre>

<hr>
<h2 id='calcBraidBootstrap'>BRAID Parameter Confidence Intervals</h2><span id='topic+calcBraidBootstrap'></span>

<h3>Description</h3>

<p>Uses residuals-based bootstrapping to estimate confidence intervals on a
BRAID fit's response surface parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcBraidBootstrap(bfit, ciLevs = c(0.025, 0.975), numBoot = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calcBraidBootstrap_+3A_bfit">bfit</code></td>
<td>
<p>A BRAID fit object of class <code>braidrm</code>.  If this object already
has bootstrapped coefficients, a warning will be given, and they will be
overwritten</p>
</td></tr>
<tr><td><code id="calcBraidBootstrap_+3A_cilevs">ciLevs</code></td>
<td>
<p>The lower and upper quantiles at which the confidence intervals
should be estimated.  Default is 0.025 and 0.975, producing 95% confidence
intervals</p>
</td></tr>
<tr><td><code id="calcBraidBootstrap_+3A_numboot">numBoot</code></td>
<td>
<p>The number of bootstrapped coefficient values to estimate.
Defaults to a  number large enough that at least 10 measurement should lie
outside the estimated interval; but held to a minimum value of 100 and a
maximum value of 1000.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>braidrm</code> but with three additional elements:
</p>

<ul>
<li> <p><code>ciLevs</code>: The two quantiles at which the confidence intervals are set
</p>
</li>
<li> <p><code>ciCoefs</code>: An array of bootstrapped coefficients.  The number of rows is
the number of <em>successful</em> bootstrapped fits; there is one column for each
the nine BRAID parameters
</p>
</li>
<li> <p><code>ciMat</code>: An array of confidence intervals on the fitted parameters. The
rows correspond to the <em>free</em> parameters included in the fit, and are named
for those parameters; the firt column contains the lower bound of the
confidence intervals, the second column the upper bound.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>bfit &lt;- braidrm(measure ~ concA + concB, synergisticExample, getCIs = FALSE)
summary(bfit)

bfit_ci &lt;- calcBraidBootstrap(bfit)
summary(bfit_ci)
</code></pre>

<hr>
<h2 id='calcBraidConfInt'>Generic BRAID confidence intervals</h2><span id='topic+calcBraidConfInt'></span>

<h3>Description</h3>

<p>Generates confidence intervals on derived BRAID response surface values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcBraidConfInt(bfit, parfunc, civals = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calcBraidConfInt_+3A_bfit">bfit</code></td>
<td>
<p>A BRAID fit object of class <code>braidrm</code> which contains a full set
of bootstrapped response surface coefficients</p>
</td></tr>
<tr><td><code id="calcBraidConfInt_+3A_parfunc">parfunc</code></td>
<td>
<p>A function that takes a full-length BRAID parameter vector as
an input and gives a single numeric value or numeric vector as an output. If
the function produces a vector, it must produce the same length vector for
all inputs</p>
</td></tr>
<tr><td><code id="calcBraidConfInt_+3A_civals">civals</code></td>
<td>
<p>If given, the lower and upper quantile values at which the
confidence intervals are set.  Defaults to the <code>ciLevs</code> parameter of the
bootstrapped BRAID fit</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In come cases, it is desirable to estimate a confidence interval on a value
derived from or dependent on a BRAID surface model that is not a parameter of
the model itself. For example, one might want a confidence interval on a
given index of achievable efficacy value, or the predicted effect at a
certain set of dose pairs. This function replicates confidence interval
calculations on any such derive values
</p>


<h3>Value</h3>

<p>An n-by-3 array, where n is the length of the output produced by
<code>parfunc</code>.  The first column is the lower bound of the confidence interval;
the second column is the derived value for the best fit coefficients; and the
third column is the upper bound of the confidence intervals. Note that is
possible for the lower bound of the confidence interval to lie above the
central value, or for the upper bound to lie below it; though this is only
likely to occur in the case of a poorly determined fit.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bfit &lt;- braidrm(measure ~ concA + concB, synergisticExample, getCIs=TRUE)

calcBraidConfInt(bfit, function(p) evalBraidModel(10, 10, p))
calcBraidConfInt(bfit, function(p) estimateIAE(p, c(0.5, 0.9), c(10, 10)))
</code></pre>

<hr>
<h2 id='coactiveExample'>Example Coactive Surface</h2><span id='topic+coactiveExample'></span>

<h3>Description</h3>

<p>A synthetically generated response surface using a flipped &quot;coactive&quot;
parameter vector. The surface was generated with IDMA of 0.5, IDMB of 0.5, na
of 3, nb of 3, kappa of 0, E0 of 0, EfA of 0, EfB of 0, and Ef of 1;
the surface was flipped along both drug axes (so <code>flip</code> was set to &quot;both&quot;).
Every pair of concentrations is sampled once, with concentrations of 0 and a
seven-point two-fold dilution from 0.125 to 8. &quot;Measurements&quot; were sampled
from a normal noise distribution around ground truth values with a standard
deviation of 0.07.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coactiveExample
</code></pre>


<h3>Format</h3>

<p>A data frame with 64 rows and 4 columns
</p>

<dl>
<dt>concA</dt><dd><p>The concentration of drug A</p>
</dd>
<dt>concB</dt><dd><p>The concentration of drug B</p>
</dd>
<dt>truth</dt><dd><p>The true response surface value at the given dose pair</p>
</dd>
<dt>measure</dt><dd><p>The sampled noisy measurement of the response surface at
the given dose pair</p>
</dd>
</dl>


<hr>
<h2 id='deviationSurface'>Non-interacting Reference Surfaces</h2><span id='topic+deviationSurface'></span><span id='topic+referenceSurface'></span><span id='topic+blissDeviation'></span><span id='topic+blissReference'></span><span id='topic+hsaDeviation'></span><span id='topic+hsaReference'></span><span id='topic+loeweDeviation'></span><span id='topic+loeweReference'></span><span id='topic+zipDeviation'></span><span id='topic+zipReference'></span><span id='topic+zipSmoothed'></span>

<h3>Description</h3>

<p>Estimate the best fitting non-interacting reference surface according to
multiple methods, including Loewe, Bliss, and HSA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deviationSurface(concs, act, method = "Bliss", ...)

referenceSurface(concs, act, method = "Bliss", ...)

blissDeviation(concs, act, range, clip = "none")

blissReference(concs, act, range, clip = "none")

hsaDeviation(concs, act, increasing)

hsaReference(concs, act, increasing)

loeweDeviation(concs, act, weights = NULL, limits = c(NA, NA))

loeweReference(concs, act, weights = NULL, limits = c(NA, NA))

zipDeviation(concs, act, range, weights = NULL, limits = c(NA, NA))

zipReference(concs, act, range, weights = NULL, limits = c(NA, NA))

zipSmoothed(concs, act, range, weights = NULL, limits = c(NA, NA))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deviationSurface_+3A_concs">concs</code></td>
<td>
<p>A width-two array of concentrations representing all measured
dose pairs</p>
</td></tr>
<tr><td><code id="deviationSurface_+3A_act">act</code></td>
<td>
<p>A vector of measured activity or effect values</p>
</td></tr>
<tr><td><code id="deviationSurface_+3A_method">method</code></td>
<td>
<p>A string specifying which model of non-interaction should be
used; possible values are &quot;Bliss&quot; (the default), &quot;HSA&quot;, &quot;Loewe&quot;, and &quot;ZIP&quot;</p>
</td></tr>
<tr><td><code id="deviationSurface_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to the method-specific
deviation or reference surface functions</p>
</td></tr>
<tr><td><code id="deviationSurface_+3A_range">range</code></td>
<td>
<p>For Bliss calculations, the range of effects assumed by Bliss
independence; a  two-element numeric vector containing the minimal effect
and the maximal effect, in that order. For ZIP calculations, the initial
estimate of the minimal and maximal effects used in fitting the individual
dose response curves.</p>
</td></tr>
<tr><td><code id="deviationSurface_+3A_clip">clip</code></td>
<td>
<p>Clipping method for Bliss reference and deviation calculations.
Possible values are &quot;pre&quot;, &quot;post&quot;, and &quot;none&quot;.  See details for specifics.</p>
</td></tr>
<tr><td><code id="deviationSurface_+3A_increasing">increasing</code></td>
<td>
<p>For HSA calculations, is the effect increasing (TRUE)
meaning the &quot;highest&quot; single agent activity is numerically greater; or
decreasing (FALSE), meaning the &quot;highest&quot; single agent activity is
numerically lower. The latter may be appropriate when the modeled response is
target growth or survival.</p>
</td></tr>
<tr><td><code id="deviationSurface_+3A_weights">weights</code></td>
<td>
<p>A vector of weights (between 0 and 1) the same length as
the data which determines the weight with which each measurement
will impact the the sum of squared errors.  Weights will be multiplied by
errors <em>before</em> squaring.  If <code>NULL</code> (the default) all weights will be set
to 1. Can be a numeric vector, or the name of a column in <code>data</code> if <code>formula</code>
is a symbolic formula</p>
</td></tr>
<tr><td><code id="deviationSurface_+3A_limits">limits</code></td>
<td>
<p>For Loewe and ZIP calculations, the fixed values of the
minimal and maximal effects of the drugs and the combination. By default,
both values are set to <code>NA</code>; any value set to <code>NA</code> will fit from the data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This collection of functions can be used to implement a family of combination
analysis methods known as &quot;deviation&quot; methods.  The details of the methods
differ, but the core strategy is common to all of them: estimate what a given
response measurement <em>would be</em> based on individual behaviors and some model
of non-interaction, and use the deviation of the measured response from that
expected response as a measure of the degree of synergy or antagonism.
</p>
<p>Bliss independence is the most widely used of these, and can be described as
the assumption that any response represents a fraction of the target
population being unaffected, and that a combined response corresponds to the
product of these fractions for both drugs (Bliss, 1939). It is extremely simple to
calculate, and relies on the intuitive model of probabilisticalyly independent
events. Because it treats responses as a scaled representation of
probabilities, it requires that all values be expressed relative to two
limiting values: the response seen when <strong>all</strong> targets are unaffected (the
minimal effect) and the response seen when <strong>none</strong> of the targets remain
unaffected (the maximal effect).  For a Bliss independent surface to be
estimated, these two values must be provided, using the parameter <code>range</code>.
Further, because values outside of this range would represent proportions
above 1 or below 0, most Bliss calculations involve some adjustment of the
data to ensure they always lie within the specified range.  The Bliss
functions support two ways of doing this to generate a reference surface:
&quot;pre&quot; will clip all values to the range immediately; &quot;post&quot; will clip all
calculated responses to the given range after they have been combined. A
third option, &quot;none&quot;, performs no clipping at all, and allows for proportions
outside of the 0 to 1 range.
</p>
<p>The highest-single-agent, or HSA model, is even simpler than Bliss. The
effect of a combined pair of doses is simply the &quot;greater&quot; of the individual
effects produced by the two drugs at those levels.  The word &quot;greater&quot; is
placed in quotes here as taking the larger response value is only appropriate
when a numerically larger measurement corresponds to greater activity. For
survival or growth inhibition studies, the reverse may be true; the parameter
<code>increasing</code> allows the user to specify this directionality.
</p>
<p>Loewe additivity is one of the oldest models of non-interaction, and the
inspiration for BRAID additivity (Loewe and Muischnek, 1926).  According to
Loewe additivity, the combined response to a pair of doses the the effect
such that the two  individual doses represent complementary fractions of the
individual doses of both drugs that produce the same effect in isolation. It
is considered the gold standard of non-interaction by many researchers, but =
has several significant pragmatic disadvantages.  It requires that the full
dose response behavior of both drugs is known, and that they produce an
identical range of effects.  The <code>loeweReference</code> and <code>loeweDeviation</code>
functions perform basic dose response fitting with the additional constraint
of matching minimal and maximal effects, either fixed by the <code>limits</code>
parameter or estimated directly from the data.
</p>
<p>The zero-interaction potency, or ZIP, model is a variant of Bliss
independence that uses smoothing to give more robust values (Wooten <em>et al.</em>
2015). The reference surface is calculated by fitting the dose response of
the individual drugs and then combining them using Bliss independence; the
method then adds additional robustness and smooths the measured surface
itself by fitting each constant-dose set of data points as its own dose
response curve, constrained to match the other drug's effect when the first
drug is zero.  Fitting these partial dose-response curves in either
direction produces a smoothed version of the original measurements (which
can be accessed directly using the function <code>zipSmoothed</code>), from which the
reference surface is subtracted to get the deviation (or &quot;delta&quot;) surface.
</p>


<h3>Value</h3>

<p>For the deviation functions (<code>deviationSurface</code>, <code>blissDeviation</code>,
<code>hsaDeviation</code>, <code>loeweDeviation</code>, and <code>zipDeviation</code>), a vector of values
the same length as <code>act</code> and/or <code>concs</code> representing the deviation of the
measurement from the specified reference surface.  For the reference
functions (<code>referenceSurface</code>, <code>blissReference</code>, <code>hsaReference</code>,
<code>loeweReference</code>, and <code>zipReferences</code>), a vector of values the same length
as <code>act</code> and/or <code>concs</code> containing the appropriate non-interacting reference
surface itself.  For <code>zipSmoothed</code>, the smoothed measurement surface given
by ZIP's dose-response-based smoothing method (see Details).
</p>


<h3>References</h3>

<p>Bliss, Chester I. 1939. “The Toxicity of Poisons Applied Jointly 1.”
<em>Annals of Applied Biology</em> <strong>26</strong> (3): 585–615.
</p>
<p>Loewe, S, and H Muischnek. 1926. “Uber Kombinationswirkungen.”
Naunyn. Schmiedebergs. Arch. Pharmacol. 114: 313–26.
</p>
<p>Yadav, Bhagwan, Krister Wennerberg, Tero Aittokallio, and Jing Tang. 2015.
“Searching for Drug Synergy in Complex Dose–Response Landscapes Using an
Interaction Potency Model.”
<em>Computational and Structural Biotechnology Journal</em> <strong>13</strong>: 504–13.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>surface &lt;- additiveExample
concs1 &lt;- cbind(surface$concA,surface$concB)
act1 &lt;- surface$measure

sum(deviationSurface(concs1,act1,"Bliss",range=c(0,1)))
sum(deviationSurface(concs1,act1,"Loewe"))
surface$hsa &lt;- hsaReference(concs1,act1,increasing=TRUE)

surface &lt;- synergisticExample
concs2 &lt;- cbind(surface$concA,surface$concB)
act2 &lt;- surface$measure

sum(deviationSurface(concs2,act2,"ZIP",range=c(0,1)))
sum(deviationSurface(concs2,act2,"Loewe"))
surface$smooth &lt;- zipSmoothed(concs2,act2,range=c(0,1))
</code></pre>

<hr>
<h2 id='estimateCombinationIndices'>Combination Index</h2><span id='topic+estimateCombinationIndices'></span><span id='topic+estimateCombinationIndex'></span><span id='topic+estimateChouIndices'></span><span id='topic+estimateChouIndex'></span>

<h3>Description</h3>

<p>Estimates the combination index using the median effet method of Chou and
Talalay (1984) or the more robust method of non-linear optimization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateCombinationIndices(
  concs,
  act,
  level,
  weights = NULL,
  limits = c(NA, NA)
)

estimateCombinationIndex(dr1, dr2, drc, ratio, level, limits = c(NA, NA))

estimateChouIndices(concs, act, level, range, excess = "clip")

estimateChouIndex(dr1, dr2, drc, ratio, level, range, excess = "clip")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimateCombinationIndices_+3A_concs">concs</code></td>
<td>
<p>A width-two array of concentrations representing all measured
dose pairs</p>
</td></tr>
<tr><td><code id="estimateCombinationIndices_+3A_act">act</code></td>
<td>
<p>A vector of measured activity or effect values</p>
</td></tr>
<tr><td><code id="estimateCombinationIndices_+3A_level">level</code></td>
<td>
<p>A numeric vector of one or more effect levels at which to
estimate the combination index</p>
</td></tr>
<tr><td><code id="estimateCombinationIndices_+3A_weights">weights</code></td>
<td>
<p>A vector of weights (between 0 and 1) the same length as
the data which determines the weight with which each measurement
will impact the the sum of squared errors.  Weights will be multiplied by
errors <em>before</em> squaring.  If <code>NULL</code> (the default) all weights will be set
to 1. Can be a numeric vector, or the name of a column in <code>data</code> if <code>formula</code>
is a symbolic formula</p>
</td></tr>
<tr><td><code id="estimateCombinationIndices_+3A_limits">limits</code></td>
<td>
<p>The fixed values of the minimal and maximal effects of the
drugs and the combination. By default, both values are set to <code>NA</code>; any
value set to <code>NA</code> will fit from the data.</p>
</td></tr>
<tr><td><code id="estimateCombinationIndices_+3A_dr1">dr1</code></td>
<td>
<p>A data frame with two columns, <code>conc</code> and <code>act</code> reflecting the
dose response behavior of the first drug alone</p>
</td></tr>
<tr><td><code id="estimateCombinationIndices_+3A_dr2">dr2</code></td>
<td>
<p>A data frame with two columns, <code>conc</code> and <code>act</code> reflecting the
dose response behavior of the second drug alone</p>
</td></tr>
<tr><td><code id="estimateCombinationIndices_+3A_drc">drc</code></td>
<td>
<p>A data frame with two columns, <code>conc</code> and <code>act</code> reflecting the
dose response behavior of a constant ratio combination; <code>conc</code> should be the
combined concentrations of the two drugs</p>
</td></tr>
<tr><td><code id="estimateCombinationIndices_+3A_ratio">ratio</code></td>
<td>
<p>The ratio of the two drugs in the constant ratio combination
(dose A to dose B)</p>
</td></tr>
<tr><td><code id="estimateCombinationIndices_+3A_range">range</code></td>
<td>
<p>The range of effects assumed by the median effect model; a
two-element numeric vector containing the minimal effect and the maximal
effect, in that order.</p>
</td></tr>
<tr><td><code id="estimateCombinationIndices_+3A_excess">excess</code></td>
<td>
<p>For <code>estimateChouIndices</code> and <code>estimateChouIndex</code>, what should
be done with values outside the expected range.  If &quot;clip&quot; (the default),
values will be clipped to 0.1% and 99.9% of the expected range; if &quot;drop&quot;,
values outside the range will be dropped</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The combination index is a peculiar method, as it does not produce values
corresponding to each measurement (as the deviation methods do), nor does it
produce a value shared by the entire surface (as response surface methods
do).  It instead, produces a value associated with a particular effect level
and a particular <em>dose ratio</em>.  This makes implementing the method
consistently for a wide range of possible data sources quite tricky;
nevertheless, we have attempted to do so here.  In brief, the combination
index method involves fitting the dose response of both individual drugs and
and a constant ratio combination of the drugs (treated as a virtual third
drug).  It the compares the potency of the constant-ratio combination
(estimated a particular effect level) with the expected potency according to
Loewe additivity, and returns the degree to which the combination is <em>more</em>
potent (with a combination index less than 1) or <em>less</em> potent (with a
combination greater than one) than expected by additivity.  This method is
also in turns known as the sum of fractional inhibitory coefficients (FICs),
observed-over-expected, or originally as Berenbaum's interaction index.
</p>
<p>Because the method was originally built for three distinct sets of dose
response measurements, we have included the <code>estimateCombinationIndex</code> and
<code>estimateChouIndex</code> functions which operate on three separate data frames.
However, in most cases, it will be easier to use the
<code>estimateCombinationIndices</code> and <code>estimateChouIndices</code> functions, which
operate on an array of concentrations and a vector of responses, just like
the numerous other functions in this package, and generate a set of
combination index values with level and ratio information  included.
</p>
<p>The only difference between the <code style="white-space: pre;">&#8288;estimateCombination*&#8288;</code> and <code style="white-space: pre;">&#8288;estimateChou*&#8288;</code>
functions is the way in which they perform dose response fitting.
The <code style="white-space: pre;">&#8288;estimateCombination*&#8288;</code> functions use non-linear least squares
optimization (based on the package <code>basicdrm</code>) to estimate dose-response
parameters.  The <code style="white-space: pre;">&#8288;estimateChou*&#8288;</code> functions use the median-effect method
described by Chou and Talalay in their 1984 paper, which linearized all
measurements and performs linear regression.  We <em>do not</em> recommend using
these methods, as they are much less reliable than the non-linear
optimization approach and extremely susceptible to noise at extreme values.
</p>


<h3>Value</h3>

<p>For <code>estimateCombinationIndices</code> and <code>estimateChouIndices</code>, a data
frame with the following columns:
</p>

<ul>
<li> <p><code>ratio</code>: The ratio of doses (dose A to dose B) along which the index
was estimated
</p>
</li>
<li> <p><code>level</code>: The effect level at which the index was estimated
</p>
</li>
<li> <p><code>ci</code>: The estimated combination index at that dose ratio and effect level
</p>
</li></ul>

<p>Combination index estimates will be included for all provided effect levels
and all dose ratios present. For <code>estimateCombinationIndex</code> and
<code>estimateChouIndex</code>, a vector of estimated combinatoin indices the same
length as <code>level</code>.
</p>


<h3>References</h3>

<p>Berenbaum, MC. 1978. “A Method for Testing for Synergy with Any Number of
Agents.” <em>Journal of Infectious Diseases</em> <strong>137</strong> (2): 122–30.
</p>
<p>Berenbaum, MC. 1989. “What Is Synergy.” <em>Pharmacol Rev</em> <strong>41</strong>: 93–141.
</p>
<p>Chou, Ting-Chao, and Paul Talalay. 1984. “Quantitative Analysis of
Dose-Effect Relationships: The Combined Effects of Multiple Drugs or Enzyme
Inhibitors.” <em>Advances in Enzyme Regulation</em> <strong>22</strong>: 27–55.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>surface &lt;- synergisticExample
concs1 &lt;- cbind(surface$concA, surface$concB)
act1 &lt;- surface$measure

estimateCombinationIndices(concs1,act1,c(0.5))

dr1 &lt;- surface[surface$concB==0, c("concA","measure")]
names(dr1) &lt;- c("conc","act")
dr2 &lt;- surface[surface$concA==0, c("concB","measure")]
names(dr2) &lt;- c("conc","act")
drc &lt;- surface[surface$concA==surface$concB,]
drc$conc &lt;- drc$concA+drc$concB
drc &lt;- drc[,c("conc","measure")]
names(drc) &lt;- c("conc","act")

estimateChouIndex(dr1,dr2,drc,ratio=1,
                  level=c(0.5,0.9,0.99),
                  range=c(0,1))
</code></pre>

<hr>
<h2 id='estimateIAE'>BRAID Response Surface Combined Potency</h2><span id='topic+estimateIAE'></span><span id='topic+estimateIAE.braidrm'></span><span id='topic+estimateIAE.braidrmflip'></span><span id='topic+estimateIAE.default'></span><span id='topic+estimateFlippedIAE'></span>

<h3>Description</h3>

<p>Estimates the BRAID index of achievable efficacy (or IAE) for a given
response surface
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateIAE(bpar, levels, limits, lowerLimits = c(0, 0))

## S3 method for class 'braidrm'
estimateIAE(bpar, levels, limits, lowerLimits = c(0, 0))

## S3 method for class 'braidrmflip'
estimateIAE(bpar, levels, limits, lowerLimits = c(0, 0))

## Default S3 method:
estimateIAE(bpar, levels, limits, lowerLimits = c(0, 0))

estimateFlippedIAE(bpar, flip, levels, limits, lowerLimits = c(0, 0))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimateIAE_+3A_bpar">bpar</code></td>
<td>
<p>The response surface to be evaluated.  Can be a numeric vector
(which will be treated as a standard BRAID parameter vector), a BRAID fit
object of class <code>braidrm</code>, or a flipped BRAID fit object of class
<code>braidrmflip</code></p>
</td></tr>
<tr><td><code id="estimateIAE_+3A_levels">levels</code></td>
<td>
<p>The effect level or levels at which the index is to be
estimated</p>
</td></tr>
<tr><td><code id="estimateIAE_+3A_limits">limits</code></td>
<td>
<p>The upper concentration limits beneath which the IAE is to be
estimated.  Could be known toxicity thresholds, limits on pharmacokinetic
availability, or simply a convenient and consistent reference concentration</p>
</td></tr>
<tr><td><code id="estimateIAE_+3A_lowerlimits">lowerLimits</code></td>
<td>
<p>By default, the IAE is calculated by comparing the area
of dose space below which a given effect level is not reached with the total
achievable dose space specified by <code>limits</code>.  However, in some cases, it is
not desirable to allow the sub-threshold area to become infinitesimally
small. If lowerLimits is included, doses that lie below both lower limits
will always be included in the sub-threshold area, placing an effective upper
bound on possible IAE values</p>
</td></tr>
<tr><td><code id="estimateIAE_+3A_flip">flip</code></td>
<td>
<p>String specifying the direction or directions of the surface's
flip.  Must be one of &quot;A&quot;, &quot;B&quot;, or &quot;both&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The index of achievable efficacy is an aggregate measure of combined potency,
and a useful first pass for quantifying the efficacy of a given response
surface.  Formally, it is equal to the area of achievable dose pairs divided
by the area of achievable doses below which a desired effect level is not
reached (then passed through a square root to give a more dimensionless
result).  If the surface is more potent, the area of sub-threshold achievable
doses is smaller, and the IAE is larger.  If the surface is less efficacious,
the doses at which a desired effect is reach will be larger, the
sub-threshold area will increase, and the IAE will decrease.  By default, the
IAE can range from 1 to infinity, but upper bounds can be placed by setting
the values in <code>lowerLimits</code> to concentrations above 0.  For convenience, the
function takes BRAID parameter vectors, <code>braidrm</code> fit objects, and
<code>braidrmflip</code> flipped BRAID fit objects.  However, flipped BRAID response
surface parameters cannot be passed to the function as is, so the function
<code>estimateFlippedIAE</code> is also included specifically for flipped parameter
vectors.
</p>


<h3>Value</h3>

<p>A numeric vector, the same length as <code>levels</code> with the estimated
index of achievable efficacy (IAE) values for each of those levels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
estimateIAE(c(1,1,3,3,0,0,100),c(50,90),c(5,5))

bfit &lt;- braidrm(measure ~ concA + concB, synergisticExample, getCIs = FALSE)
estimateIAE(bfit, c(0,0.25,0.5,0.75,1), c(10,1), lowerLimits=c(0.01,0.01))
</code></pre>

<hr>
<h2 id='evalBraidModel'>Evaluate the BRAID response surface model</h2><span id='topic+evalBraidModel'></span>

<h3>Description</h3>

<p>Evaluate the BRAID response surface model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evalBraidModel(DA, DB, bpar, calcderivs = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="evalBraidModel_+3A_da">DA</code></td>
<td>
<p>A vector of concentrations of drug A in a combination (values 0
and <code>Inf</code> are permitted). Must be length 1 or the same length as <code>DB</code>.</p>
</td></tr>
<tr><td><code id="evalBraidModel_+3A_db">DB</code></td>
<td>
<p>A vector of concentrations of drug B in a combination (values 0
and <code>Inf</code> are permitted). Must be length 1 or the same length as <code>DA</code>.</p>
</td></tr>
<tr><td><code id="evalBraidModel_+3A_bpar">bpar</code></td>
<td>
<p>A BRAID response surface parameter vector (see Details)</p>
</td></tr>
<tr><td><code id="evalBraidModel_+3A_calcderivs">calcderivs</code></td>
<td>
<p>Primarily used by fitting functions for non-linear
optimization.  If <code>FALSE</code> (the default), the function returns a vector of
response values; if <code>TRUE</code>, it returns a list including the partial
derivatives of the BRAID parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The BRAID response model is, in total, described by nine response surface
parameters.  A BRAID parameter vector should uniquely determine all these
values. They are
</p>

<ul>
<li><p> IDMA: The dose of median effect of drug A, also called the EC50
</p>
</li>
<li><p> IDMB: The dose of median effect of drug B
</p>
</li>
<li><p> na: The Hill slope, or sigmoidicity, of drug A
</p>
</li>
<li><p> nb: The Hill slope of drug B
</p>
</li>
<li><p> kappa: The BRAID interaction parameter, indicating additivity (kappa = 0),
antagonism (2 &lt; kappa &lt; 0), or synergy (kappa &gt; 0)
</p>
</li>
<li><p> E0: The minimal effect, the effect observed when neither drug is present
</p>
</li>
<li><p> EfA: The maximal effect of drug A, the effect theoretically observed when
drug B is absent and drug A is present at infinite concentration
</p>
</li>
<li><p> EfB: The maximal effect of drug B,
</p>
</li>
<li><p> Ef: The maximal effect of the combination, theoretically observed when
both drugs are present at infinite concentration. It may be (but often is
not) further from E0 than either EfA or EfB.
</p>
</li></ul>

<p>In many cases, however, it is easier to specify only some of the final three
parameters.  <a href="#topic+braidrm">braidrm</a> functions therefore support BRAID parameter vectors
of length 7 (in which the sixth and seventh values are assumed to be E0 and
Ef, and EfA and EfB are assumed to be equal to Ef), length 8 (in which the
seventh and eighth values are EfA and EfB, and Ef is assumed to be equal to
whichever of these two values is further from E0), or the full length 9
parameter vector.
</p>


<h3>Value</h3>

<p>If <code>calcderivs</code> is <code>FALSE</code>, a numeric vector the same length as <code>DA</code>
and/or <code>DB</code> with the predicted BRAID response surface values.  If
<code>calcderivs</code> is <code>TRUE</code>, a list with two elements: <code>value</code>, containing the
response surface values, and <code>derivatives</code>, a matrix with as many rows as
<code>value</code> has elements, and nine columns containing the partial derivatives of
the response surface with respect to the nine BRAID response surface
parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>concentrations &lt;- c(0, 2^(-3:3))
surface &lt;- data.frame(
    concA = rep(concentrations,each=length(concentrations)),
    concB = rep(concentrations,times=length(concentrations))
)

surface$additive &lt;- evalBraidModel(
    surface$concA,
    surface$concB,
    c(1, 1, 3, 3, 0, 0, 100, 100, 100)
)

surface$synergy &lt;- evalBraidModel(
    surface$concA,
    surface$concB,
    c(1, 1, 3, 3, 2, 0, 80, 90)
)

surface$antagonism &lt;- evalBraidModel(
    surface$concA,
    surface$concB,
    c(1, 1, 3, 3, -1, 0, 100)
)

head(surface)
</code></pre>

<hr>
<h2 id='evalFlippedBraidModel'>Evaluate Flipped BRAID Surfaces</h2><span id='topic+evalFlippedBraidModel'></span>

<h3>Description</h3>

<p>Evaluate Flipped BRAID Surfaces
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evalFlippedBraidModel(DA, DB, bpar, flip)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="evalFlippedBraidModel_+3A_da">DA</code></td>
<td>
<p>A vector of concentrations of drug A in a combination (values 0
and <code>Inf</code> are permitted). Must be length 1 or the same length as <code>DB</code>.</p>
</td></tr>
<tr><td><code id="evalFlippedBraidModel_+3A_db">DB</code></td>
<td>
<p>A vector of concentrations of drug B in a combination (values 0
and <code>Inf</code> are permitted). Must be length 1 or the same length as <code>DA</code>.</p>
</td></tr>
<tr><td><code id="evalFlippedBraidModel_+3A_bpar">bpar</code></td>
<td>
<p>Flipped-BRAID parameter of the flipped response surface. See
details for more information on specifying atypical surfaces</p>
</td></tr>
<tr><td><code id="evalFlippedBraidModel_+3A_flip">flip</code></td>
<td>
<p>String specifying the direction or directions of the surface's
flip.  Must be one of &quot;A&quot;, &quot;B&quot;, or &quot;both&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>While the BRAID model generates a fairly versatile range of combined
behaviors, the traditional model is still strictly constrained in certain
respects.  Response surfaces must exhibit a change in response to both drugs
and this change must be in the same direction.  Furthermore, the model is
only suited to surfaces in which the change resulting from single drugs is
larger than the additional effect of the combination.  However, modifying
the model equation by inverting one or both of the slope parameters can
produce a set of qualitatively distinct &quot;flipped&quot; surfaces, allowing the
model to produce a much wider range of behaviors.  For example, flipping the
model along the axis representing drug A can produce a surface in which drug
B has no effect in isolation, but attenuates or eliminates the effect of
drug A, a pattern we call a &quot;protective&quot; surface.  See <code><a href="#topic+fitBraidFlipped">fitBraidFlipped()</a></code>
for the possible range of surfaces.
</p>
<p>An important note: a flipped BRAID surface, like a traditional BRAID surface,
is represented by a parameter vector of up to 9 values.  While these
functions will attempt to fill a 7- or 8- value parameter factor to a full
9-element vector, it is strongly recommended that you specify the response
surface with the full 9-element vector, as the precise ordering with which
implicit values are arranged can be extremely confusing.  Note also that
flipped parameter vectors, regardless of the underlying mathematical
representation, should always be specified in the same order as in a
traditional vector.  So in a full 9-element vector:
</p>

<ul>
<li><p> Parameter 6 (E0) should always specify the expected effect when both drugs
are absent
</p>
</li>
<li><p> Parameter 7 (EfA) should always specify the expected effect at high
concentrations of drug A when drug B is absent
</p>
</li>
<li><p> Parameter 8 (EfB) should always specify the expected effect at high
concentrations of drug B when drug A is absent
</p>
</li>
<li><p> Parameter 9 (Ef) should always specify the expected effect when both drugs
are present at high concentrations
</p>
</li></ul>



<h3>Value</h3>

<p>A numeric vector the same length as <code>DA</code>  and/or <code>DB</code> with the
predicted flipped BRAID response surface values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>concentrations &lt;- c(0, 2^(-3:3))
surface &lt;- data.frame(
    concA = rep(concentrations,each=length(concentrations)),
    concB = rep(concentrations,times=length(concentrations))
)

surface$protective &lt;- evalFlippedBraidModel(
    surface$concA,
    surface$concB,
    c(1, 1, 3, 3, 0, 0, 100, 0, 10),
    flip="A"
)
surface$coactive &lt;- evalFlippedBraidModel(
    surface$concA,
    surface$concB,
    c(1, 1, 3, 3, 0, 0, 0, 0, 100),
    flip="both"
)

head(surface)
</code></pre>

<hr>
<h2 id='evalMusycModel'>Evaluate MuSyC Response Surfaces</h2><span id='topic+evalMusycModel'></span>

<h3>Description</h3>

<p>Evaluates the Mulitdimensional Synergy of Combinations (MuSyC) model of
combined action for the given values and parameters (Wooten <em>et al.</em> 2021).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evalMusycModel(DA, DB, mupar, calcderivs = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="evalMusycModel_+3A_da">DA</code></td>
<td>
<p>A vector of concentrations of drug A in a combination (values 0
and <code>Inf</code> are permitted). Must be length 1 or the same length as <code>DB</code>.</p>
</td></tr>
<tr><td><code id="evalMusycModel_+3A_db">DB</code></td>
<td>
<p>A vector of concentrations of drug B in a combination (values 0
and <code>Inf</code> are permitted). Must be length 1 or the same length as <code>DA</code>.</p>
</td></tr>
<tr><td><code id="evalMusycModel_+3A_mupar">mupar</code></td>
<td>
<p>A MuSyC response surface parameter vector; may be length 8, 10,
or 12 (see details for specifics of MuSyC parameters)</p>
</td></tr>
<tr><td><code id="evalMusycModel_+3A_calcderivs">calcderivs</code></td>
<td>
<p>Primarily used by fitting functions for non-linear
optimization.  If <code>FALSE</code> (the default), the function returns a vector of
response values; if <code>TRUE</code>, it returns a list including the partial
derivatives of the BRAID parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The multi-dimensional synergy of combinatoins, or MySyC, model is a
parametric response surface model introduced by Wooten et al. in 2021.  The
method models the effect of combination by simulating occupancy in four
compartments in which compounds are affected or unaffected by either drug.
The full MuSyC model can be specified by a total of twelve parameters:
</p>

<ul>
<li> <p><code>IDMA</code>: dose of median effect of first drug
</p>
</li>
<li> <p><code>IDMB</code>: dose of median effect of second drug
</p>
</li>
<li> <p><code>na</code>: Hill slope of first drug
</p>
</li>
<li> <p><code>nb</code>: Hill slope of second drug
</p>
</li>
<li> <p><code>alpha12</code>: factor by which first drug potentiates the second
</p>
</li>
<li> <p><code>alpha21</code>: factor by which second drug potentiates the first
</p>
</li>
<li> <p><code>gamma12</code>: factor by which first drug increases second drug's Hill slope
</p>
</li>
<li> <p><code>gamma21</code>: factor by which second drug increases first drug's Hill slope
</p>
</li>
<li> <p><code>E0</code> - the observed effect when unaffected by either drug
</p>
</li>
<li> <p><code>EfA</code> - the observed effect when affected by drug 1 but not drug 2
</p>
</li>
<li> <p><code>EfB</code> - the observed effect when affected by drug 2 but not drug 1
</p>
</li>
<li> <p><code>Ef</code> - the observed effect when affected by both drugs
</p>
</li></ul>

<p>In practice, <code>gamma12</code> and <code>gamma21</code> are rarely used, so a ten-element
parameter vector specifies the other 10 values and assumes that <code>gamma12</code>
and <code>gamma21</code> are both equal to 1.  In some cases it is even useful to
specify a MuSyC surface with no interaction at all with an eight-element
vector, in which case <code>alpha12</code>, <code>alpha21</code>, <code>gamma12</code>, and <code>gamma21</code> are all
set equal to 1.
</p>


<h3>Value</h3>

<p>If <code>calcderivs</code> is <code>FALSE</code>, a numeric vector the same length as <code>DA</code>
and/or <code>DB</code> with the predicted MuSyC response surface values.  If
<code>calcderivs</code> is <code>TRUE</code>, a list with two elements: <code>value</code>, containing the
response surface values, and <code>derivatives</code>, a matrix with as many rows as
<code>value</code> has elements, and all columns containing the partial derivatives of
the response surface with respect to the fitted MuSyC response surface
parameters
</p>


<h3>References</h3>

<p>Wooten, David J, Christian T Meyer, Alexander LR Lubbock, Vito Quaranta,
and Carlos F Lopez. 2021. “MuSyC Is a Consensus Framework That Unifies
Multi-Drug Synergy Metrics for Combinatorial Drug Discovery.”
<em>Nature Communications</em> <strong>12</strong> (1): 4607.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>efficacyPar &lt;- c(
    1, 1, 3, 3,
                      # Omitted shape synergy parameters assume to be 1
    0, 100, 100, 125  # Elevated Ef indicates efficacy synergy
)
potencyPar &lt;- c(
    1, 1, 3, 3,
    10, 15,           # alphas above 1 indicate potency synergy
    0, 100, 100, 100  # No efficacy synergy
)

concentrations &lt;- c(0, 2^(-3:3))
surface &lt;- data.frame(
    concA = rep(concentrations,each=length(concentrations)),
    concB = rep(concentrations,times=length(concentrations))
)
surface$efficacy &lt;- evalMusycModel(surface$concA, surface$concB, efficacyPar)
surface$potency  &lt;- evalMusycModel(surface$concA, surface$concB, potencyPar)

head(surface)
</code></pre>

<hr>
<h2 id='evalUrsaModel'>Evaluate URSA response surface model</h2><span id='topic+evalUrsaModel'></span>

<h3>Description</h3>

<p>Numerically estimates the universal response surface approach (URSA) model
for the given data and parameters (Greco, Park, and Rustum 1990).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evalUrsaModel(DA, DB, upar)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="evalUrsaModel_+3A_da">DA</code></td>
<td>
<p>A vector of concentrations of drug A in a combination (values 0
and <code>Inf</code> are permitted). Must be length 1 or the same length as <code>DB</code>.</p>
</td></tr>
<tr><td><code id="evalUrsaModel_+3A_db">DB</code></td>
<td>
<p>A vector of concentrations of drug B in a combination (values 0
and <code>Inf</code> are permitted). Must be length 1 or the same length as <code>DA</code>.</p>
</td></tr>
<tr><td><code id="evalUrsaModel_+3A_upar">upar</code></td>
<td>
<p>A length seven URSA response surface parameter vector (see
Details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The URSA model is described by the following seven values
</p>

<ul>
<li><p> IDMA: The dose of median effect of drug A, also called the EC50
</p>
</li>
<li><p> IDMB: The dose of median effect of drug B
</p>
</li>
<li><p> na: The Hill slope, or sigmoidicity, of drug A
</p>
</li>
<li><p> nb: The Hill slope of drug B
</p>
</li>
<li><p> alpha: The URSA interaction parameter, indicating additivity (alpha = 0),
antagonism (alpha &lt; 0), or synergy (alpha &gt; 0)
</p>
</li>
<li><p> E0: The minimal effect, the effect observed when neither drug is present
</p>
</li>
<li><p> Ef: The maximal effect of the drugs, theoretically observed when
either drug is present at infinite concentration
</p>
</li></ul>



<h3>Value</h3>

<p>A numeric vector the same length as <code>DA</code>
and/or <code>DB</code> with the predicted URSA response surface values.
</p>


<h3>References</h3>

<p>Greco, William R, Hyoung Sook Park, and Youcef M Rustum. 1990.
“Application of a New Approach for the Quantitation of Drug Synergism to
the Combination of Cis-Diamminedichloroplatinum and
1-b-d-Arabinofuranosylcytosine.” <em>Cancer Research</em> <strong>50</strong> (17): 5318–27.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>concentrations &lt;- c(0, 2^(-3:3))
surface &lt;- data.frame(
    concA = rep(concentrations,each=length(concentrations)),
    concB = rep(concentrations,times=length(concentrations))
)

surface$uadditive &lt;- evalUrsaModel(
    surface$concA,
    surface$concB,
    c(1, 1, 3, 3, 0, 0, 100)
)

surface$usynergy &lt;- evalUrsaModel(
    surface$concA,
    surface$concB,
    c(1, 1, 3, 3, 5, 0, 80)
)

surface$uantagonism &lt;- evalUrsaModel(
    surface$concA,
    surface$concB,
    c(1, 1, 3, 3, -0.5, 0, 100)
)

head(surface)
</code></pre>

<hr>
<h2 id='findBestBraid'>Select Best BRAID Response Fit</h2><span id='topic+findBestBraid'></span><span id='topic+findBestBraid.formula'></span><span id='topic+findBestBraid.default'></span>

<h3>Description</h3>

<p>Picks the most parsimonious BRAID fit from a standard set of commonly used
variants
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findBestBraid(
  formula,
  data,
  defaults,
  extended = FALSE,
  weights = NULL,
  start = NULL,
  direction = 0,
  lower = NULL,
  upper = NULL,
  prior = "moderate",
  getCIs = TRUE,
  useBIC = TRUE
)

## S3 method for class 'formula'
findBestBraid(
  formula,
  data,
  defaults,
  extended = FALSE,
  weights = NULL,
  start = NULL,
  direction = 0,
  lower = NULL,
  upper = NULL,
  prior = "moderate",
  getCIs = TRUE,
  useBIC = TRUE
)

## Default S3 method:
findBestBraid(
  formula,
  data,
  defaults,
  extended = FALSE,
  weights = NULL,
  start = NULL,
  direction = 0,
  lower = NULL,
  upper = NULL,
  prior = "moderate",
  getCIs = TRUE,
  useBIC = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="findBestBraid_+3A_formula">formula</code></td>
<td>
<p>Either an object of class <code>formula</code> such as would be provided
to a modeling function like <code><a href="stats.html#topic+lm">stats::lm()</a></code>, or a width-2 numeric array vector
of concentration pairs (including 0 or Inf).  A formula should specify a
single output as a function of two inputs, eg. <code>activity ~ conc1 + conc2</code>.</p>
</td></tr>
<tr><td><code id="findBestBraid_+3A_data">data</code></td>
<td>
<p>If <code>forumula</code> is a symbolic formula, a data frame containing the
specified values. If <code>formula</code> is a numeric array of concentrations, a
numeric vector of response values, the same length as the number of rows of
<code>formula</code>.</p>
</td></tr>
<tr><td><code id="findBestBraid_+3A_defaults">defaults</code></td>
<td>
<p>Default minimal and maximal effect values used to fix effect
parameters during model selection.</p>
</td></tr>
<tr><td><code id="findBestBraid_+3A_extended">extended</code></td>
<td>
<p>Should models with an additional freely varying Ef parameter
be included.  If <code>FALSE</code> (the default), ten models in which the maximal
effect parameter Ef is constrained to be equal to one or more of the two
individual maximal effect parameters will be tested; if <code>TRUE</code>, an additional
two models in which Ef varies freely will be included.</p>
</td></tr>
<tr><td><code id="findBestBraid_+3A_weights">weights</code></td>
<td>
<p>A vector of weights (between 0 and 1) the same length as
the data which determines the weight with which each measurement
will impact the the sum of squared errors.  Weights will be multiplied by
errors <em>before</em> squaring.  If <code>NULL</code> (the default) all weights will be set
to 1. Can be a numeric vector, or the name of a column in <code>data</code> if <code>formula</code>
is a symbolic formula</p>
</td></tr>
<tr><td><code id="findBestBraid_+3A_start">start</code></td>
<td>
<p>A BRAID parameter vector specifying the first guess where the
non-linear optimization should begin.  May be a length 7, 8, or 9 vector,
though a full length vector is always preferable.  If <code>NULL</code> (the default),
it will be estimated from the data.</p>
</td></tr>
<tr><td><code id="findBestBraid_+3A_direction">direction</code></td>
<td>
<p>Determines the possible directionality of the BRAID
model.  If 0 (the default) no additional constraints are placed on the
parameters.  If greater than 0, the fitting will require that the maximal
effects are all <em>greater</em> than or equal to the minimal effect.  If less
than 0, the fitting will require that all maximal effect is <em>less</em> than or
equal to the minimal effect.</p>
</td></tr>
<tr><td><code id="findBestBraid_+3A_lower">lower</code></td>
<td>
<p>A numeric vector of lower bounds on the fitted parameter values.
May be the same length as the number of fitted parameters, or a full,
length-9 vector. Missing or unspecified lower bounds may be included as <code>NA</code>
or <code>Inf</code>; if unspecified, lower bounds on the first five parameters (IDMA,
IDMB, na, nb, and kappa) will be automatically estimated from the data.
Bounds on the minimal and maximal effect parameters however (E0, EfA, EfB,
and Ef) will be assumed to be infinite unless specified.  A value of <code>NULL</code>,
the default, will be treated as all lower parameter bounds being
unspecified.</p>
</td></tr>
<tr><td><code id="findBestBraid_+3A_upper">upper</code></td>
<td>
<p>A numeric vector of upper bounds on the fitted parameter values.
Used in the same way as <code>lower</code>.</p>
</td></tr>
<tr><td><code id="findBestBraid_+3A_prior">prior</code></td>
<td>
<p>A character string specifying the desired Bayesian prior term
for kappa, or an object of class <code>kappaPrior</code> genererated by the function
<code><a href="#topic+kappaPrior">kappaPrior()</a></code>.  Allowed strings are &quot;mild&quot;, &quot;moderate&quot; (the default),
&quot;high&quot;, or &quot;none&quot;.  If a string is given, the kappa prior object will be
estimated from the data using an initial ten-parameter fit to approximate
measurement noise.</p>
</td></tr>
<tr><td><code id="findBestBraid_+3A_getcis">getCIs</code></td>
<td>
<p>Should bootstrapped confidence intervals be estimated and
added to the BRAID fit object. Default value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="findBestBraid_+3A_usebic">useBIC</code></td>
<td>
<p>If <code>TRUE</code> (the default), the best (read: most parsimonious)
model will be selected from all tested models using the Bayesian information
criterion (Schwarz 1978).  If <code>FALSE</code> the function will follow the convention
of earlier versions of the <code>braidrm</code> package and use the Akaike information
criterion (Akaike 1974).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When fitting real experimental data, it is not uncommon for a measured
surface to contain such incomplete or noisy data that many of the parameters
are highly underdetermined.  Unfortunately, in such cases, non-linear
optimization can often resort to wildly implausible values to explain small
variations in the data. To address this, this function runs multiple BRAID
response fits, including some in which the minimal and maximal effect
parameters are constrained to reasonable default values, to test if
additional free parameters offer sufficiently improved fits to be included.
</p>
<p>When the parameter <code>extended</code> is set to <code>FALSE</code>, the function runs ten BRAID
scenarios: five in which the minimal effect parameter is allowed to vary
freely, and five in which it is fixed at the first default value.  The five
tested models in each set represent five distinct configurations of the
maximal effect parameters:
</p>

<ul>
<li><p> Both maximal effects are fixed the same value (the second default)
</p>
</li>
<li><p> Maximal effect EfA (and when it is larger, Ef) varies freely, but effect
EfB is fixed at the second default
</p>
</li>
<li><p> Maximal effect EfB (and when it is larger, Ef) varies freely, but effect
EfA is fixed at the second default
</p>
</li>
<li><p> The maximal effect Ef varies freely, and both EfA and EfB are constrained
to be equal to it
</p>
</li>
<li><p> The maximal effects EfA and EfB both vary freely, and Ef is constrained to
be equal to the larger of the two
</p>
</li></ul>

<p>When <code>extended</code> is <code>TRUE</code>, two additional models (one with E0 fixed and one
in which it varies freely) are included, in which all three maximal effect
parameters are allowed to vary freely and independently.
</p>


<h3>Value</h3>

<p>An object of class <code>braidrm</code>.  It will contain all the fields of a
standard <code>braidrm</code> object, and also an additional field, <code>allfits</code>
containing a summary of the best fit model from each of the 10 or 12
candidate models tested.
</p>


<h3>References</h3>

<p>Akaike, Hirotugu. 1974. “A New Look at the Statistical Model Identification.”
<em>IEEE Transactions on Automatic Control</em> <strong>19</strong> (6): 716–23.
</p>
<p>Schwarz, Gideon. 1978. “Estimating the Dimension of a Model.”
<em>The Annals of Statistics</em>, 461–64.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bfit1 &lt;- findBestBraid(measure ~ concA + concB, additiveExample,
                       defaults=c(0,1))
summary(bfit1)
length(bfit1$allfits)

bfit2 &lt;- findBestBraid(measure ~ concA + concB, additiveExample,
                       defaults=c(0,2), extended=TRUE, getCIs = FALSE)
summary(bfit2)
length(bfit2$allfits)
</code></pre>

<hr>
<h2 id='fitBraidFlipped'>Fit Flipped BRAID Surfaces</h2><span id='topic+fitBraidFlipped'></span><span id='topic+fitProtectiveBraid_A'></span><span id='topic+fitProtectiveBraid_B'></span><span id='topic+fitOppositionalBraid_A'></span><span id='topic+fitOppositionalBraid_B'></span><span id='topic+fitCoactiveBraid_pure'></span><span id='topic+fitCoactiveBraid_partial'></span>

<h3>Description</h3>

<p>Functions to fit protective, oppoistional and coactive BRAID surfaces, and
more specific flipped surfaces if necessary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitBraidFlipped(formula, data, flip, model, links = NULL, ...)

fitProtectiveBraid_A(formula, data, ...)

fitProtectiveBraid_B(formula, data, ...)

fitOppositionalBraid_A(formula, data, ...)

fitOppositionalBraid_B(formula, data, ...)

fitCoactiveBraid_pure(formula, data, ...)

fitCoactiveBraid_partial(formula, data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitBraidFlipped_+3A_formula">formula</code></td>
<td>
<p>Either an object of class <code>formula</code> such as would be provided
to a modeling function like <code><a href="stats.html#topic+lm">stats::lm()</a></code>, or a width-2 numeric array vector
of concentration pairs (including 0 or Inf).  A formula should specify a
single output as a function of two inputs, eg. <code>activity ~ conc1 + conc2</code>.</p>
</td></tr>
<tr><td><code id="fitBraidFlipped_+3A_data">data</code></td>
<td>
<p>If <code>forumula</code> is a symbolic formula, a data frame containing the
specified values. If <code>formula</code> is a numeric array of concentrations, a
numeric vector of response values, the same length as the number of rows of
<code>formula</code>.</p>
</td></tr>
<tr><td><code id="fitBraidFlipped_+3A_flip">flip</code></td>
<td>
<p>String specifying the direction or directions of the surface's
flip.  Must be one of &quot;A&quot;, &quot;B&quot;, or &quot;both&quot;.</p>
</td></tr>
<tr><td><code id="fitBraidFlipped_+3A_model">model</code>, <code id="fitBraidFlipped_+3A_links">links</code></td>
<td>
<p>Parameters <code>model</code> and <code>links</code> are used to specify which
variant of the BRAID model is fit to data.  Model may be one of the
following character strings: &quot;kappa1&quot;, &quot;kappa2&quot;, or &quot;kappa3&quot; (see Details),
or a subset of the numbers 1 through 9 specifying which of the nine BRAID
response surface parameters is allowed to vary when fitting.  <code>links</code> allows
the user to further specify constraints on the three BRAID maximal effect
parameters (see Details for more).  If <code>model</code> is one of the supported
character strings, the parameter <code>links</code> will be ignored.</p>
</td></tr>
<tr><td><code id="fitBraidFlipped_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to <code>braidrm</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Though <code>fitBraidFlipped</code> offers the option of fitting any flipped BRAID
surface model specified by <code>flip</code>, this is not recommended, as the interplay
between flipping paramteers and parameter constraints becomes very confusing
very quickly.  In nearly all cases, it is preferable to use one of the
pre-defined flipped fitting functions.
</p>
<p><code>fitProtectiveBraid_A</code> and <code>fitProtectiveBraid_B</code> fit &quot;protective&quot; surfaces
in which one drug has no effect in isolation, but attenuates or eliminates
the effect of the other.  <code>fitProtectiveBraid_A</code> generates a surface in which
drug A is active and is attenuated by drug B; <code>fitProtectiveBraid_B</code>
generates the reverse.
</p>
<p><code>fitOppositinalBraid_A</code> and <code>fitOppositionalBraid_B</code> produce &quot;oppositional&quot;
surfaces in which a second drug produces an effect that is in the opposite
direction to the first drug, but which is then overwhelmed by the effect of
the first drug at higher concentrations.  <code>fitProtectiveBraid_A</code> generates a
surface in which the maximal effect of drug A dominates a high concentrations,
<code>fitProtectiveBraid_B</code> generates the reverse.  Note that the <code>A</code> and <code>B</code> in
the function names specify which compound's effect is dominant, not the
direction of the underlying flip; in actuality the surfaces generated by
<code>fitProtectiveBraid_A</code> are produced by flipping along the <code>B</code> axis.
</p>
<p><code>fitCoactiveBraid_pure</code> and <code>fitCoactiveBraid_partial</code> produce &quot;coactive&quot;
surfaces, in which both drugs have no or minimal effect in isolation, but
produce a pronounced effect when both are present.  <code>fitCoactiveBraid_pure</code>
generates surfaces in which both drugs have no effect at all in isolation;
<code>fitCoactiveBraid_partial</code> generates surfaces in which either drug may have
a smaller partial effect in isolation.
</p>


<h3>Value</h3>

<p>A fit object of class <code>braidrmflip</code>.  This structure contains the
exact same elements as an object of class <code>braidrm</code> (see <code><a href="#topic+braidrm">braidrm()</a></code> for
details) along with one additional element: <code>flip</code>, a character value
specifying the direction that the surface is flipped.  The object's
<code>coefficients</code> and <code>flip</code> fields can be used to evaluate and invert the best
fit response surface using <code><a href="#topic+evalFlippedBraidModel">evalFlippedBraidModel()</a></code> and
<code><a href="#topic+invertFlippedBraidModel">invertFlippedBraidModel()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fbfit1 &lt;- fitProtectiveBraid_A(measure ~ concA + concB,
                               protectiveExample, getCIs=FALSE)
coef(fbfit1)

fbfit2 &lt;- fitOppositionalBraid_A(measure ~ concA + concB,
                                 oppositionalExample, getCIs=FALSE)
coef(fbfit2)

fbfit3 &lt;- fitCoactiveBraid_pure(measure ~ concA + concB,
                                coactiveExample, getCIs=FALSE)
coef(fbfit3)
</code></pre>

<hr>
<h2 id='fitMusycModel'>MuSyC Response Surface Fitting</h2><span id='topic+fitMusycModel'></span><span id='topic+fitMusycModel.formula'></span><span id='topic+fitMusycModel.default'></span>

<h3>Description</h3>

<p>Fits the Multidimensional Synergy of Combinations (MuSyC) model of combined
action to the given data (Wooten <em>et al.</em> 2021).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitMusycModel(
  formula,
  data,
  variant = "standard",
  weights = NULL,
  direction = 0,
  lower = NULL,
  upper = NULL
)

## S3 method for class 'formula'
fitMusycModel(
  formula,
  data,
  variant = "standard",
  weights = NULL,
  direction = 0,
  lower = NULL,
  upper = NULL
)

## Default S3 method:
fitMusycModel(
  formula,
  data,
  variant = "standard",
  weights = NULL,
  direction = 0,
  lower = NULL,
  upper = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitMusycModel_+3A_formula">formula</code></td>
<td>
<p>Either an object of class <code>formula</code> such as would be provided
to a modeling function like <code><a href="stats.html#topic+lm">stats::lm()</a></code>, or a width-2 numeric array vector
of concentration pairs (including 0 or Inf).  A formula should specify a
single output as a function of two inputs, eg. <code>activity ~ conc1 + conc2</code>.</p>
</td></tr>
<tr><td><code id="fitMusycModel_+3A_data">data</code></td>
<td>
<p>If <code>forumula</code> is a symbolic formula, a data frame containing the
specified values. If <code>formula</code> is a numeric array of concentrations, a
numeric vector of response values, the same length as the number of rows of
<code>formula</code>.</p>
</td></tr>
<tr><td><code id="fitMusycModel_+3A_variant">variant</code></td>
<td>
<p>String specifying which variant of the MuSyC model is to be
fit to the data.  If &quot;standard&quot; (the default), all MuSyC parameters except
<code>gamma12</code> and <code>gamma21</code> will be fit (these will be fixed at 1).  If
&quot;independent&quot;, the four individual dose-response parameters (<code>IDMA</code>, <code>IDMB</code>,
<code>na</code>, and <code>nb</code>) and the four maximal effect parameters (<code>E0</code>, <code>EfA</code>, <code>EfB</code>
and <code>Ef</code>) will be fit, while the four interaction parameters (<code>alpha12</code>,
<code>alpha21</code>, <code>gamma12</code>, and <code>gamma12</code>) will all be fixed at 1.  If &quot;full&quot;, the
full twelve-parameter MuSyC vector will be fit.</p>
</td></tr>
<tr><td><code id="fitMusycModel_+3A_weights">weights</code></td>
<td>
<p>An optional vector of weights the same length as <code>act</code>.  If
<code>NULL</code> (the default), will be set to 1 for all measurements</p>
</td></tr>
<tr><td><code id="fitMusycModel_+3A_direction">direction</code></td>
<td>
<p>Determines the possible directionality of the BRAID
model.  If 0 (the default) no additional constraints are placed on the
parameters.  If greater than 0, the fitting will require that the maximal
effects are all <em>greater</em> than or equal to the minimal effect.  If less
than 0, the fitting will require that all maximal effect is <em>less</em> than or
equal to the minimal effect.</p>
</td></tr>
<tr><td><code id="fitMusycModel_+3A_lower">lower</code></td>
<td>
<p>An optional set of lower bounds on the fitted MuSyC response
parameters.  Any values set to NA will be filled with default calculated
bounds. May be length 4 (will be treated as a set of lower bounds on the
minimal and maximal effect parameters only), length 8 (will be treated as
lower bounds on the four individual dose response parameters and the four
minimal and maximla effect parameters), the same length as the space of
parameters being optimized (8 for &quot;independent&quot;, 10 for &quot;standard&quot;, or 12
for &quot;full&quot;), or length 12.</p>
</td></tr>
<tr><td><code id="fitMusycModel_+3A_upper">upper</code></td>
<td>
<p>An optional set of lower bounds on the fitted MuSyC response
parameters.  Behaves the same as <code>lower</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>braidAltFit</code> with the following values:
</p>

<ul>
<li> <p><code>concs</code>: The array of concentrations passed to the functions
</p>
</li>
<li> <p><code>act</code>: The vector of measurements associated with the given dose pairs
</p>
</li>
<li> <p><code>weights</code>: The vector of weights for the given measurements, set to 1 for
all measurements by default
</p>
</li>
<li> <p><code>method</code>: Specifying the alternate surface model being used (in this case
&quot;MuSyC&quot;)
</p>
</li>
<li> <p><code>variant</code>: A string specifying which MuSyC variant was fit: &quot;independent&quot;,
&quot;standard&quot;, or &quot;full&quot;
</p>
</li>
<li> <p><code>coefficients</code>: A parameter vector of the appropriate length for <code>variant</code>
specifying the best fit response surface
</p>
</li>
<li> <p><code>fitted.values</code>: The predicted response surface value for the given dose
pairs and best-fit response surface
</p>
</li>
<li> <p><code>residuals</code>: The difference between the predicted and measured values for
the given dose pairs, always equal to &quot;measured minus predicted&quot;
</p>
</li>
<li> <p><code>direction</code>: The direction value passed to the function
</p>
</li>
<li> <p><code>pbounds</code>': A 2-by-k array of bounds on the MuSyC parameters used in the
parameter optimization
</p>
</li></ul>



<h3>References</h3>

<p>Wooten, David J, Christian T Meyer, Alexander LR Lubbock, Vito Quaranta,
and Carlos F Lopez. 2021. “MuSyC Is a Consensus Framework That Unifies
Multi-Drug Synergy Metrics for Combinatorial Drug Discovery.”
<em>Nature Communications</em> <strong>12</strong> (1): 4607.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mfit1 &lt;- fitMusycModel(measure ~ concA + concB, synergisticExample)
coef(mfit1)

mfit2 &lt;- fitMusycModel(measure ~ concA + concB, oppositionalExample,
                       variant = "independent")
coef(mfit2)
</code></pre>

<hr>
<h2 id='fitUrsaModel'>URSA Response Surface Fitting</h2><span id='topic+fitUrsaModel'></span><span id='topic+fitUrsaModel.formula'></span><span id='topic+fitUrsaModel.default'></span>

<h3>Description</h3>

<p>Fits the universal response surface approach (URSA) model to the given
data (Greco, Park, and Rustum 1990)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitUrsaModel(
  formula,
  data,
  weights = NULL,
  direction = 0,
  lower = NULL,
  upper = NULL
)

## S3 method for class 'formula'
fitUrsaModel(
  formula,
  data,
  weights = NULL,
  direction = 0,
  lower = NULL,
  upper = NULL
)

## Default S3 method:
fitUrsaModel(
  formula,
  data,
  weights = NULL,
  direction = 0,
  lower = NULL,
  upper = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitUrsaModel_+3A_formula">formula</code></td>
<td>
<p>Either an object of class <code>formula</code> such as would be provided
to a modeling function like <code><a href="stats.html#topic+lm">stats::lm()</a></code>, or a width-2 numeric array vector
of concentration pairs (including 0 or Inf).  A formula should specify a
single output as a function of two inputs, eg. <code>activity ~ conc1 + conc2</code>.</p>
</td></tr>
<tr><td><code id="fitUrsaModel_+3A_data">data</code></td>
<td>
<p>If <code>forumula</code> is a symbolic formula, a data frame containing the
specified values. If <code>formula</code> is a numeric array of concentrations, a
numeric vector of response values, the same length as the number of rows of
<code>formula</code>.</p>
</td></tr>
<tr><td><code id="fitUrsaModel_+3A_weights">weights</code></td>
<td>
<p>A vector of weights (between 0 and 1) the same length as
the data which determines the weight with which each measurement
will impact the the sum of squared errors.  Weights will be multiplied by
errors <em>before</em> squaring.  If <code>NULL</code> (the default) all weights will be set
to 1. Can be a numeric vector, or the name of a column in <code>data</code> if <code>formula</code>
is a symbolic formula</p>
</td></tr>
<tr><td><code id="fitUrsaModel_+3A_direction">direction</code></td>
<td>
<p>Determines the possible directionality of the BRAID
model.  If 0 (the default) no additional constraints are placed on the
parameters.  If greater than 0, the fitting will require that the maximal
effects are all <em>greater</em> than or equal to the minimal effect.  If less
than 0, the fitting will require that all maximal effect is <em>less</em> than or
equal to the minimal effect.</p>
</td></tr>
<tr><td><code id="fitUrsaModel_+3A_lower">lower</code></td>
<td>
<p>An optional set of lower bounds on the seven URSA response
parameters.  Any values set to NA will be filled with default calculated
bounds.</p>
</td></tr>
<tr><td><code id="fitUrsaModel_+3A_upper">upper</code></td>
<td>
<p>An optional set of upper bounds on the seven URSA response
parameters.  Any values set to NA will be filled with default calculated
bounds.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>braidAltFit</code> with the following values:
</p>

<ul>
<li> <p><code>concs</code>: The array of concentrations passed to the functions
</p>
</li>
<li> <p><code>act</code>: The vector of measurements associated with the given dose pairs
</p>
</li>
<li> <p><code>weights</code>: The vector of weights for the given measurements, set to 1 for
all measurements by default
</p>
</li>
<li> <p><code>method</code>: Specifying the alternate surface model being used (in this case
&quot;URSA&quot;)
</p>
</li>
<li> <p><code>coefficients</code>: A length-seven parameter vector specifying the URSA
response surface
</p>
</li>
<li> <p><code>fitted.values</code>: The predicted response surface value for the given dose
pairs and best-fit response surface
</p>
</li>
<li> <p><code>residuals</code>: The difference between the predicted and measured values for
the given dose pairs, always equal to &quot;measured minus predicted&quot;
</p>
</li>
<li> <p><code>direction</code>: The direction value passed to the function
</p>
</li>
<li> <p><code>pbounds</code>': A 2-by-7 array of bounds on the URSA parameters used in the
parameter optimization
</p>
</li></ul>



<h3>References</h3>

<p>Greco, William R, Hyoung Sook Park, and Youcef M Rustum. 1990.
“Application of a New Approach for the Quantitation of Drug Synergism to
the Combination of Cis-Diamminedichloroplatinum and
1-b-d-Arabinofuranosylcytosine.” <em>Cancer Research</em> <strong>50</strong> (17): 5318–27.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ufit1 &lt;- fitUrsaModel(measure ~ concA + concB, additiveExample)
coef(ufit1)

ufit2 &lt;- fitUrsaModel(measure ~ concA + concB, synergisticExample,
                      direction = 1, lower=c(NA, NA, NA, NA, NA, 0, 0))
coef(ufit2)
</code></pre>

<hr>
<h2 id='incompleteExample'>Example Partial or Incomplete Surface</h2><span id='topic+incompleteExample'></span>

<h3>Description</h3>

<p>A synthetically generated response surface using parameter vector describing
a surface with one only barely detectable effect. The surface was generated
with IDMA of 1, IDMB of 100, na of 3, nb of 3, kappa of 0, E0 of 0, EfA of 1,
EfB of 0.1, and Ef of 1. Every pair of concentrations is sampled once, with
concentrations of 0 and a seven-point two-fold dilution from 0.125 to 8.
&quot;Measurements&quot; were sampled from a normal noise distribution around ground
truth values with a standard deviation of 0.07.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>incompleteExample
</code></pre>


<h3>Format</h3>

<p>A data frame with 64 rows and 4 columns
</p>

<dl>
<dt>concA</dt><dd><p>The concentration of drug A</p>
</dd>
<dt>concB</dt><dd><p>The concentration of drug B</p>
</dd>
<dt>truth</dt><dd><p>The true response surface value at the given dose pair</p>
</dd>
<dt>measure</dt><dd><p>The sampled noisy measurement of the response surface at
the given dose pair</p>
</dd>
</dl>


<hr>
<h2 id='invertBraidModel'>Invert a BRAID Response Surface Model</h2><span id='topic+invertBraidModel'></span><span id='topic+invertBraidModel_A'></span><span id='topic+invertBraidModel_B'></span>

<h3>Description</h3>

<p>Given a particular effect and one of the doses in a combined action response
surface, this function calculates the other dose that will produce the
desired effect.  Used in the estimation of the IAE (see <code><a href="#topic+estimateIAE">estimateIAE()</a></code>) but
also useful for calculating something like the IC50 of one drug in the
presence of various doses of the other. <code>invertBraidModelA</code> and
<code>invertBraidModelB</code> are convenience wrapper functions that set <code>DA</code> or <code>DB</code>
to <code>NULL</code> to estimate the necessary concentrations of drug A and drug B
respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invertBraidModel(
  DA = NULL,
  DB = NULL,
  effect,
  bpar,
  invalidNA = FALSE,
  lowerBound = FALSE
)

invertBraidModel_A(DB, effect, bpar, invalidNA = FALSE, lowerBound = FALSE)

invertBraidModel_B(DA, effect, bpar, invalidNA = FALSE, lowerBound = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="invertBraidModel_+3A_da">DA</code></td>
<td>
<p>If not <code>NULL</code>, a vector of doses of drug A. Must be length 1 or
the same length as <code>effect</code>.  Only one of <code>DA</code> and <code>DB</code> may be not null.</p>
</td></tr>
<tr><td><code id="invertBraidModel_+3A_db">DB</code></td>
<td>
<p>If not <code>NULL</code>, a vector of doses of drug B. Must be length 1 or
the same length as <code>effect</code>.  Only one of <code>DA</code> and <code>DB</code> may be not null.</p>
</td></tr>
<tr><td><code id="invertBraidModel_+3A_effect">effect</code></td>
<td>
<p>A vector of desired effect values to be reached.  Must be
length 1 or the same length as whichever of <code>DA</code> or <code>DB</code> is not null.</p>
</td></tr>
<tr><td><code id="invertBraidModel_+3A_bpar">bpar</code></td>
<td>
<p>A BRAID response surface parameter vector (see
<code><a href="#topic+evalBraidModel">evalBraidModel()</a></code> for details)</p>
</td></tr>
<tr><td><code id="invertBraidModel_+3A_invalidna">invalidNA</code></td>
<td>
<p>Specifies what to do with values that are outside the range
of the given BRAID model or doses.  If <code>FALSE</code> (the default), values &quot;below&quot;
the given range will be set to zero, and values &quot;above&quot; the given range will
be set to Inf.  If <code>TRUE</code>, all invalid values will be set to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="invertBraidModel_+3A_lowerbound">lowerBound</code></td>
<td>
<p>Primarily used by <code><a href="#topic+estimateIAE">estimateIAE()</a></code>.  If set to TRUE, will
return the lowest non-negative dose that produces an effect no greater than
the specified effect, rather than the highest</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of concentrations the same length as either <code>DA</code> or <code>DB</code>
(whichever is not <code>NULL</code>) and/or <code>effect</code>, representing the concentration of
the other drug producing the specified effect in combination with the given
dose of the provided drug
</p>


<h3>Examples</h3>

<pre><code class='language-R'>baseIC &lt;- invertBraidModel_A(
    DB=0,
    effect=seq(10,90,by=10),
    bpar=c(1, 1, 3, 3, 2, 0, 100, 100, 100)
)

potentiatedIC &lt;- invertBraidModel_A(
    DB=1,
    effect=seq(10,90,by=10),
    bpar=c(1, 1, 3, 3, 2, 0, 100, 100, 100)
)
</code></pre>

<hr>
<h2 id='invertFlippedBraidModel'>Invert Flipped BRAID Surfaces</h2><span id='topic+invertFlippedBraidModel'></span><span id='topic+invertFlippedBraidModel_A'></span><span id='topic+invertFlippedBraidModel_B'></span>

<h3>Description</h3>

<p>Given a particular effect and one of the doses in a flipped combined action
response surface, this function calculates the other dose that will produce
the desired effect.<code>invertFlippedBraidModelA</code> and
<code>invertFlippedBraidModelB</code> are convenience wrapper functions that set <code>DA</code>
or <code>DB</code> to <code>NULL</code> to estimate the necessary concentrations of drug A and
drug B respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invertFlippedBraidModel(
  DA = NULL,
  DB = NULL,
  effect,
  bpar,
  flip,
  invalidNA = FALSE,
  lowerBound = FALSE
)

invertFlippedBraidModel_A(
  DB,
  effect,
  bpar,
  flip,
  invalidNA = FALSE,
  lowerBound = FALSE
)

invertFlippedBraidModel_B(
  DA,
  effect,
  bpar,
  flip,
  invalidNA = FALSE,
  lowerBound = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="invertFlippedBraidModel_+3A_da">DA</code></td>
<td>
<p>If not <code>NULL</code>, a vector of doses of drug A. Must be length 1 or
the same length as <code>effect</code>.  Only one of <code>DA</code> and <code>DB</code> may be not null.</p>
</td></tr>
<tr><td><code id="invertFlippedBraidModel_+3A_db">DB</code></td>
<td>
<p>If not <code>NULL</code>, a vector of doses of drug B. Must be length 1 or
the same length as <code>effect</code>.  Only one of <code>DA</code> and <code>DB</code> may be not null.</p>
</td></tr>
<tr><td><code id="invertFlippedBraidModel_+3A_effect">effect</code></td>
<td>
<p>A vector of desired effect values to be reached.  Must be
length 1 or the same length as whichever of <code>DA</code> or <code>DB</code> is not null.</p>
</td></tr>
<tr><td><code id="invertFlippedBraidModel_+3A_bpar">bpar</code></td>
<td>
<p>Flipped-BRAID parameter of the flipped response surface. See
<code><a href="#topic+evalFlippedBraidModel">evalFlippedBraidModel()</a></code> for more information on specifying atypical
surfaces</p>
</td></tr>
<tr><td><code id="invertFlippedBraidModel_+3A_flip">flip</code></td>
<td>
<p>String specifying the direction or directions of the surface's
flip.  Must be one of &quot;A&quot;, &quot;B&quot;, or &quot;both&quot;.</p>
</td></tr>
<tr><td><code id="invertFlippedBraidModel_+3A_invalidna">invalidNA</code></td>
<td>
<p>Specifies what to do with values that are outside the range
of the given BRAID model or doses.  If <code>FALSE</code> (the default), values &quot;below&quot;
the given range will be set to zero, and values &quot;above&quot; the given range will
be set to Inf.  If <code>TRUE</code>, all invalid values will be set to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="invertFlippedBraidModel_+3A_lowerbound">lowerBound</code></td>
<td>
<p>Primarily used by <code><a href="#topic+estimateIAE">estimateIAE()</a></code>.  If set to TRUE, will
return the lowest non-negative dose that produces an effect no greater than
the specified effect, rather than the highest</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of concentrations the same length as either <code>DA</code> or <code>DB</code>
(whichever is not <code>NULL</code>) and/or <code>effect</code>, representing the concentration of
the other drug producing the specified effect in combination with the given
dose of the provided drug
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fbfit &lt;- fitProtectiveBraid_A(measure ~ concA + concB,
                              protectiveExample, getCIs=FALSE)

invertFlippedBraidModel_A(DB=0, effect=0.5, coef(fbfit), fbfit$flip)
invertFlippedBraidModel_A(DB=0.75, effect=0.5, coef(fbfit), fbfit$flip)
</code></pre>

<hr>
<h2 id='kappaPrior'>Braid kappa Bayesian Prior</h2><span id='topic+kappaPrior'></span>

<h3>Description</h3>

<p>Generates a Bayesian prior object on the BRAID parameter kappa to stabilize
parameter fitting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kappaPrior(spread, strength = "moderate")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kappaPrior_+3A_spread">spread</code></td>
<td>
<p>Rough estimate of the standard deviation of measurement noise
or errors expected in a given data set.  Commonly used values are standard
deviation of negative/positive controls or root mean squared error of a
preliminary surface fit.</p>
</td></tr>
<tr><td><code id="kappaPrior_+3A_strength">strength</code></td>
<td>
<p>String indicating the influence of the BRAID prior on the
resulting fit.  Must be one of &quot;mild&quot;, &quot;moderate&quot; (the default), &quot;high&quot;, or
&quot;none&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>kappaPrior</code> containing two numeric elements,
<code>spread</code>, and <code>strength</code>.  Used in BRAID fitting functions to stabilize
the parameter kappa
</p>


<h3>Examples</h3>

<pre><code class='language-R'>prior &lt;- kappaPrior(0.05,"mild")

bfit &lt;- braidrm(measure ~ concA + concB, incompleteExample,
                prior=prior, getCIs=FALSE)
summary(bfit)
</code></pre>

<hr>
<h2 id='oppositionalExample'>Example Oppositional Surface</h2><span id='topic+oppositionalExample'></span>

<h3>Description</h3>

<p>A synthetically generated response surface using a flipped &quot;oppositional&quot;
parameter vector. The surface was generated with IDMA of 1, IDMB of 1, na
of 3, nb of 3, kappa of -0.5, E0 of 0, EfA of 1, EfB of -0.5, and Ef of 1;
the surface was flipped along the drug B axis (so <code>flip</code> was set to &quot;B&quot;).
Every pair of concentrations is sampled once, with concentrations of 0 and a
seven-point two-fold dilution from 0.125 to 8. &quot;Measurements&quot; were sampled
from a normal noise distribution around ground truth values with a standard
deviation of 0.07.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oppositionalExample
</code></pre>


<h3>Format</h3>

<p>A data frame with 64 rows and 4 columns
</p>

<dl>
<dt>concA</dt><dd><p>The concentration of drug A</p>
</dd>
<dt>concB</dt><dd><p>The concentration of drug B</p>
</dd>
<dt>truth</dt><dd><p>The true response surface value at the given dose pair</p>
</dd>
<dt>measure</dt><dd><p>The sampled noisy measurement of the response surface at
the given dose pair</p>
</dd>
</dl>


<hr>
<h2 id='protectiveExample'>Example Protective Surface</h2><span id='topic+protectiveExample'></span>

<h3>Description</h3>

<p>A synthetically generated response surface using a flipped &quot;protective&quot;
parameter vector. The surface was generated with IDMA of 0.5, IDMB of 2, na
of 3, nb of 3, kappa of 2, E0 of 0, EfA of 1, EfB of 0, and Ef of 0; the
surface was flipped along the drug A axis (so <code>flip</code> was set to &quot;A&quot;). Every
pair of concentrations is sampled once, with concentrations of 0 and a
seven-point two-fold dilution from 0.125 to 8. &quot;Measurements&quot; were sampled
from a normal noise distribution around ground truth values with a standard
deviation of 0.07.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>protectiveExample
</code></pre>


<h3>Format</h3>

<p>A data frame with 64 rows and 4 columns
</p>

<dl>
<dt>concA</dt><dd><p>The concentration of drug A</p>
</dd>
<dt>concB</dt><dd><p>The concentration of drug B</p>
</dd>
<dt>truth</dt><dd><p>The true response surface value at the given dose pair</p>
</dd>
<dt>measure</dt><dd><p>The sampled noisy measurement of the response surface at
the given dose pair</p>
</dd>
</dl>


<hr>
<h2 id='synergisticExample'>Example Synergistic Surface</h2><span id='topic+synergisticExample'></span>

<h3>Description</h3>

<p>A synthetically generated response surface using a synergistic parameter vector.
The surface was generated with IDMA of 1, IDMB of 1, na of 3, nb of 3,
kappa of 2, E0 of 0, EfA of 1, EfB of 1, and Ef of 1. Every pair of
concentrations is sampled once, with concentrations of 0 and a seven-point
two-fold dilution from 0.125 to 8. &quot;Measurements&quot; were sampled from a
normal noise distribution around ground truth values with a standard
deviation of 0.07.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>synergisticExample
</code></pre>


<h3>Format</h3>

<p>A data frame with 64 rows and 4 columns
</p>

<dl>
<dt>concA</dt><dd><p>The concentration of drug A</p>
</dd>
<dt>concB</dt><dd><p>The concentration of drug B</p>
</dd>
<dt>truth</dt><dd><p>The true response surface value at the given dose pair</p>
</dd>
<dt>measure</dt><dd><p>The sampled noisy measurement of the response surface at
the given dose pair</p>
</dd>
</dl>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
