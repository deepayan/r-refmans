<!DOCTYPE html><html lang="en"><head><title>Help for package TGS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {TGS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#TGS-package'><p>TGS: A package for Rapid Reconstruction of Time-Varying Gene Regulatory</p>
Networks</a></li>
<li><a href='#LearnTgs'><p>Implement the TGS Algorithm</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Title:</td>
<td>Rapid Reconstruction of Time-Varying Gene Regulatory Networks</td>
</tr>
<tr>
<td>Description:</td>
<td>Rapid advancements in high-throughput gene sequencing
    technologies have resulted in genome-scale time-series datasets. 
    Uncovering the underlying temporal sequence of gene regulatory events 
    in the form of time-varying gene regulatory networks demands 
    accurate and computationally efficient algorithms. Such an
    algorithm is 'TGS'. It is proposed in Saptarshi Pyne, Alok Ranjan 
    Kumar, and Ashish Anand. Rapid reconstruction of time-varying 
    gene regulatory networks. IEEE/ACM Transactions on Computational 
    Biology and Bioinformatics, 17(1):278{291, Jan-Feb 2020. The TGS 
    algorithm is shown to consume only 29 minutes for a microarray 
    dataset with 4028 genes. This package provides an implementation 
    of the TGS algorithm and its variants.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>biocViews:</td>
<td>NetworkInference, GraphAndNetwork, Network, GeneExpression,
Microarray, SystemsBiology, Software</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.biorxiv.org/content/early/2018/06/14/272484">https://www.biorxiv.org/content/early/2018/06/14/272484</a>,
<a href="https://github.com/sap01/TGS">https://github.com/sap01/TGS</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/sap01/TGS/issues">https://github.com/sap01/TGS/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>rjson, bnstruct, ggm, foreach, doParallel, minet (&ge; 3.38.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>R.rsp, testthat (&ge; 2.1.0), knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-05-07 11:38:49 UTC; Sap</td>
</tr>
<tr>
<td>Author:</td>
<td>Saptarshi Pyne <a href="https://orcid.org/0000-0001-9710-6749"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Manan Gupta [aut],
  Alok Kumar [aut],
  Ashish Anand <a href="https://orcid.org/0000-0002-0024-3358"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Saptarshi Pyne &lt;saptarshipyne01@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-05-07 13:00:21 UTC</td>
</tr>
</table>
<hr>
<h2 id='TGS-package'>TGS: A package for Rapid Reconstruction of Time-Varying Gene Regulatory
Networks</h2><span id='topic+TGS-package'></span><span id='topic+TGS'></span>

<h3>Description</h3>

<p>The <code>TGS</code> package provides an implementation of the TGS algorithm
and its variants. This algorithm reconstructs time-varying gene
regulatory networks from time-series gene expression datasets. For
algorithmic details, please see: Saptarshi Pyne, Alok Ranjan Kumar,
and Ashish Anand. Rapid reconstruction of time-varying gene
regulatory networks. IEEE/ACM Transactions on Computational Biology
and Bioinformatics, 17(1):278&ndash;291, Jan&ndash;Feb 2020.
</p>


<h3>The <code>LearnTgs</code> function</h3>

<p>Please call <code>TGS::LearnTgs()</code> to invoke the TGS algorithm. See
the manual for the required parameters.
</p>

<hr>
<h2 id='LearnTgs'>Implement the TGS Algorithm</h2><span id='topic+LearnTgs'></span>

<h3>Description</h3>

<p>The TGS algorithm takes a time-series gene expression dataset as input. It
analyses the data and reconstructs the underlying temporal sequence of gene
regulatory events. The reconstructed output is given in the form of
time-varying gene regulatory networks (GRNs). The TGS algorithm is extremely
time-efficient and hence suitable for processing large datasets with hundreds
to thousands of genes. More details about the algorithm can be found at
Saptarshi Pyne, Alok Ranjan Kumar, and Ashish Anand. Rapid reconstruction of
time-varying gene regulatory networks. IEEE/ACM Transactions on Computational
Biology and Bioinformatics, 17(1):278&ndash;291, Jan&ndash;Feb 2020.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LearnTgs(
  isfile = 0,
  json.file = "",
  input.dirname = "",
  input.data.filename = "",
  num.timepts = 2,
  true.net.filename = "",
  input.wt.data.filename = "",
  is.discrete = TRUE,
  num.discr.levels = 2,
  discr.algo = "",
  mi.estimator = "mi.pca.cmi",
  apply.aracne = FALSE,
  clr.algo = "CLR",
  max.fanin = 14,
  allow.self.loop = TRUE,
  scoring.func = "BIC",
  output.dirname = ""
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LearnTgs_+3A_isfile">isfile</code></td>
<td>
<p>Numeric. 1 or 0. 1 if input arguments are given in a json file.
Otherwise, 0.</p>
</td></tr>
<tr><td><code id="LearnTgs_+3A_json.file">json.file</code></td>
<td>
<p>Character string. Absolute path to the JSON file if
<code>isfile = 1</code>.</p>
</td></tr>
<tr><td><code id="LearnTgs_+3A_input.dirname">input.dirname</code></td>
<td>
<p>Character string. Absolute path to the directory where
input files are kept. By default, the current working directory.</p>
</td></tr>
<tr><td><code id="LearnTgs_+3A_input.data.filename">input.data.filename</code></td>
<td>
<p>Character string. Name of the file containing the
input data. It can either be a '.tsv' file or an '.RData' file. </p>

<ul>
<li><p> If it is a '.tsv' file, the first column should have the time point
IDs. The only exception is the (1, 1)-th cell. This cell should be reserved
for the column header. The column header can be anything, such as - 'Time'.
The first row, excluding the (1, 1)-th cell, must have the gene names. The
rest of the cells should contain the corresponding value. For example, the
cell with row ID 't1' and column ID 'G2' would represent the expression
value of gene 'G2' at time point 't1'.
</p>
</li>
<li><p> If it is an '.RData' file, the underlying object should be a matrix
named 'input.data'. In 'input.data', the row names must represent the time
point IDs. On the other hand, the column names must represent the gene
names. Therefore, the (i, j)-th cell of the matrix contains the expression
value of the j-th gene at the i-th time point. </p>
</li></ul>

<p>For both '.tsv' and '.RData' input, multiple rows with the same time point
ID represent multiple replicates at the same time point. In other words,
these rows belong to the same time point in different time series. The time
points belonging to the same time series must be together and in ascending
order. An exemplary dataset with three genes {G1, G2, G3}, two time points
{t1, t2} and two time series is shown below.
</p>

<table>
<tr>
 <td style="text-align: right;"> <strong>Time</strong> </td><td style="text-align: right;"> <strong>G1</strong> </td><td style="text-align: right;"> <strong>G2</strong> </td><td style="text-align: right;">
 <strong>G3</strong> </td>
</tr>
<tr>
 <td style="text-align: right;"> t1 </td><td style="text-align: right;"> 0.8272480342 </td><td style="text-align: right;"> 0.7257430901 </td><td style="text-align: right;"> 0.3894130418 </td>
</tr>
<tr>
 <td style="text-align: right;">
 t2 </td><td style="text-align: right;"> 0.6542518342 </td><td style="text-align: right;"> 0.6470658823 </td><td style="text-align: right;"> 0.5088904888 </td>
</tr>
<tr>
 <td style="text-align: right;"> t1 </td><td style="text-align: right;">
 0.3519554463 </td><td style="text-align: right;"> 0.3551279726 </td><td style="text-align: right;"> 0.3207993604 </td>
</tr>
<tr>
 <td style="text-align: right;"> t2 </td><td style="text-align: right;"> 0.4871730974
 </td><td style="text-align: right;"> 0.3706990326 </td><td style="text-align: right;"> 0.447523615 </td>
</tr>

</table>
</td></tr>
<tr><td><code id="LearnTgs_+3A_num.timepts">num.timepts</code></td>
<td>
<p>Numeric. Positive integer greater than 1. Number of
distinct time points.</p>
</td></tr>
<tr><td><code id="LearnTgs_+3A_true.net.filename">true.net.filename</code></td>
<td>
<p>Character string. Name of the file containing the
true network. In case it is non-empty, the name should refer to an '.RData'
file. The '.RData' file must have an object named 'true.net.adj.matrix'. The
object can either be a matrix or a list. </p>
 <ul>
<li><p> If the object is a
matrix, then it represents the true summary GRN. The row names and column
names should be the gene names. Each cell can contain a value of 1 or 0. If
the (i, j)-th cell contains 1, then there exists an edge from the i-th gene
to the j-th gene. Otherwise, the edge does not exist. An example with three
genes {G1, G2, G3} is given below. </p>

<table>
<tr>
 <td style="text-align: right;"> </td><td style="text-align: right;"> <strong>G1</strong> </td><td style="text-align: right;">
 <strong>G2</strong> </td><td style="text-align: right;"> <strong>G3</strong> </td>
</tr>
<tr>
 <td style="text-align: right;"> <strong>G1</strong> </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 0 </td>
</tr>
<tr>
 <td style="text-align: right;">
 <strong>G2</strong> </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 0 </td>
</tr>
<tr>
 <td style="text-align: right;"> <strong>G3</strong> </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 0 </td><td style="text-align: right;"> 0 </td>
</tr>

</table>

</li>
<li><p> If the object is a list, then it represents the true time-varying
GRNs. The length of the list must be equal to the number of time intervals,
which is <code>(num.timepts - 1)</code>. Each element in the list should be a
matrix. The p-th matrix represents the true GRN corresponding to the p-th
time interval. The row names and column names should be the gene names. Each
cell can contain a value of 1 or 0. If the (i, j)-th cell contains 1, then
there exists an edge from the i-th gene to the j-th gene. Otherwise, the
edge does not exist. </p>
</li></ul>
</td></tr>
<tr><td><code id="LearnTgs_+3A_input.wt.data.filename">input.wt.data.filename</code></td>
<td>
<p>Character string. Name of the file containing
the Wild Type expressions of the genes. If non-empty, then must be a '.tsv'
file. The first row should contain the names of the genes. Only exception is
the (1, 1)-th cell which should be empty. The second row should have the
wild type expressions. Therefore, the (2, j)-th cell must contain the wild
type expression of the j-th gene. Again the only exception is the (2, 1)-th
cell which should be empty. An example with three genes {G1, G2, G3} is
given below.
</p>

<table>
<tr>
 <td style="text-align: right;"> &lt;empty&gt; </td><td style="text-align: right;"> <strong>G1</strong> </td><td style="text-align: right;"> <strong>G2</strong> </td><td style="text-align: right;"> <strong>G3</strong>
 </td>
</tr>
<tr>
 <td style="text-align: right;"> &lt;empty&gt;  </td><td style="text-align: right;"> 0.5298713 </td><td style="text-align: right;"> 0.5174261 </td><td style="text-align: right;"> 0.8181522 </td>
</tr>

</table>
</td></tr>
<tr><td><code id="LearnTgs_+3A_is.discrete">is.discrete</code></td>
<td>
<p>Logical. TRUE or FALSE. TRUE if the input data is discrete.
Otherwise, FALSE.</p>
</td></tr>
<tr><td><code id="LearnTgs_+3A_num.discr.levels">num.discr.levels</code></td>
<td>
<p>Numeric. Positive integer greater than 1. Number of
discrete levels that each gene has (if the input data is discrete) or each
gene should have (if the input data needs to be discretised).</p>
</td></tr>
<tr><td><code id="LearnTgs_+3A_discr.algo">discr.algo</code></td>
<td>
<p>Character string. Name of the discretisation algorithm to be
used when the input data needs to be discretised. The available algorithms
are &ndash; 'discretizeData.2L.Tesla' and 'discretizeData.2L.wt.l'. If you
choose algorithm 'discretizeData.2L.wt.l', please provide the wild type
data using argument <code>input.wt.data.filename</code>.</p>
</td></tr>
<tr><td><code id="LearnTgs_+3A_mi.estimator">mi.estimator</code></td>
<td>
<p>Character string. Name of the algorithm for estimating
mutual informations. There is only one algorithm available at this moment.
It is 'mi.pca.cmi'.</p>
</td></tr>
<tr><td><code id="LearnTgs_+3A_apply.aracne">apply.aracne</code></td>
<td>
<p>Logical. TRUE or FALSE. TRUE if you wish to apply ARACNE
for refining the mutual information matrix. Otherwise, FALSE.</p>
</td></tr>
<tr><td><code id="LearnTgs_+3A_clr.algo">clr.algo</code></td>
<td>
<p>Character string. Name of the context likelihood relatedness
(CLR) algorithm to use. The available algorithms are &ndash; 'CLR', 'CLR2',
'CLR2.1', 'CLR3' and 'spearman'.</p>
</td></tr>
<tr><td><code id="LearnTgs_+3A_max.fanin">max.fanin</code></td>
<td>
<p>Numeric. Positive integer. Maximum number of regulators each
gene can have.</p>
</td></tr>
<tr><td><code id="LearnTgs_+3A_allow.self.loop">allow.self.loop</code></td>
<td>
<p>Logical. TRUE or FALSE. TRUE if you wish to allow self
loops. Otherwise, FALSE.</p>
</td></tr>
<tr><td><code id="LearnTgs_+3A_scoring.func">scoring.func</code></td>
<td>
<p>Character string. Name of the scoring function to use. At
this moment, the only available option is 'BIC'.</p>
</td></tr>
<tr><td><code id="LearnTgs_+3A_output.dirname">output.dirname</code></td>
<td>
<p>Character string. File path to a directory where output
files are to be saved. There are three options. <em>Option 1:</em> It can be
the absolute path to an existing directory. <em>Option 2:</em> It can also be
the absolute path to a non-existing directory. In this case, the directory
will be created. <em>Option 3 (default):</em> If provided an empty string,
then it will be the current working directory.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function does not return any values. Instead, it outputs a set of
files and saves them under the directory specified by <code>output.dirname</code>.
The output files are described in Section 'Value'.
</p>


<h3>Value</h3>

 <dl>
<dt>input.data.discr.RData</dt><dd><p> Discretised version of the
input data. This file is created only if the input data is not discretised
as specified by input argument 'is.discrete'. </p>
</dd>
<dt>mut.info.matrix.RData</dt><dd><p> Mutual information matrix of the given genes.
This RData file contains a matrix named 'mut.info.matrix'. The (i, j)-th
cell of the matrix represents the mutual information between the i-th and
j-th genes. This is a symmetric matrix. </p>
</dd>
<dt>mi.net.adj.matrix.wt.RData</dt><dd><p> Weighted Mutual information network of
the given genes. This RData file contains a matrix named
'mi.net.adj.matrix.wt'. The (i, j)-th cell of the matrix represents the
weight of the edge from the i-th gene to the j-th gene. The edge weight is a
non-negative real number. </p>
</dd>
<dt>mi.net.adj.matrix.RData</dt><dd><p> Unweighted Mutual information network of the
given genes. This RData file contains a matrix named 'mi.net.adj.matrix'.
Each cell of the matrix contains a value of 1 or 0. If the (i, j)-th cell
contains 1, then there exists an edge from the i-th gene to the j-th gene.
Otherwise, the edge does not exist. </p>
</dd>
<dt>unrolled.DBN.adj.matrix.list.RData</dt><dd><p> Reconstructed time-varying GRNs.
This RData file contains a list named 'unrolled.DBN.adj.matrix.list'. The
length of the list is equal to the total number of time intervals, which is
<code>(num.timepts - 1)</code>. Each element in the list is a network adjacency
matrix. The p-th element in the list represents the adjacency matrix of the
GRN corresponding to the p-th time interval. In this adjacency matrix, each
cell contains a value of 1 or 0. If the (i, j)-th cell contains 1, then
there exists a directed edge from the i-th gene to the j-th gene. Otherwise,
the edge does not exist. </p>
</dd>
<dt>di.net.adj.matrix.RData</dt><dd><p> Rolled GRN. This RData file contains a
matrix named 'di.net.adj.matrix'. Each cell in the matrix contains a value
of 1 or 0. If the (i, j)-th cell contains 1, then there exists an edge from
the i-th gene to the j-th gene. Otherwise, the edge does not exist. </p>
</dd>
<dt>net.sif</dt><dd><p> Rolled GRN in the SIF format compatible with Cytoscape. </p>
</dd>
<dt>Result.RData</dt><dd><p> Correctness metrics. This file is created only if true
network is given through input argument 'true.net.filename'. Inside this
RData file, there is a matrix named 'Result'. The columns represent the
correctness metrics, such as - TP (number of true positive predictions) and
FP (number of false positive predictions). The rows depend upon the nature
of the true network. If the true network is time-varying GRNs, then the
number of rows is equal to the number of time intervals. In that case, the
p-th row contains the correctness metrics of the reconstructed GRN
corresponding to the p-th time interval. On the other hand, if the true
network is a summary GRN, then there exists only one row. This row
represents the correctness metrics of the rolled GRN. </p>
</dd>
<dt>output.txt</dt><dd><p> Console output. </p>
</dd>
<dt>sessionInfo.txt</dt><dd><p> R session information. </p>
</dd> </dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  TGS::LearnTgs(
  isfile = 0,
  json.file = '',
  input.dirname = 'C:/GitHub/TGS/inst/extdata',
  input.data.filename = 'InSilicoSize10-Yeast1-trajectories.tsv',
  num.timepts = 21,
  true.net.filename = 'DREAM3GoldStandard_InSilicoSize10_Yeast1_TrueNet.RData',
  input.wt.data.filename = 'InSilicoSize10-Yeast1-null-mutants.tsv',
  is.discrete = FALSE,
  num.discr.levels = 2,
  discr.algo = 'discretizeData.2L.wt.l',
  mi.estimator = 'mi.pca.cmi',
  apply.aracne = FALSE,
  clr.algo = 'CLR',
  max.fanin = 14,
  allow.self.loop = FALSE,
  scoring.func = 'BIC',
  output.dirname = 'C:/GitHub/TGS/inst/extdata/Output_Ds10n')

  TGS::LearnTgs(
  isfile = 0,
  json.file = '',
  input.dirname = 'C:/GitHub/TGS/inst/extdata',
  input.data.filename = 'edi-data-10n.tsv',
  num.timepts = 21,
  true.net.filename = 'edi.net.10.adj.mx.RData',
  input.wt.data.filename = '',
  is.discrete = FALSE,
  num.discr.levels = 2,
  discr.algo = 'discretizeData.2L.Tesla',
  mi.estimator = 'mi.pca.cmi',
  apply.aracne = FALSE,
  clr.algo = 'CLR',
  max.fanin = 14,
  allow.self.loop = TRUE,
  scoring.func = 'BIC',
  output.dirname = 'C:/GitHub/TGS/inst/extdata/Output_Ed10n')

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
