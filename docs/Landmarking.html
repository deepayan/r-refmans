<!DOCTYPE html><html><head><title>Help for package Landmarking</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Landmarking}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_cv_number'><p>Assign a k-fold cross-validation number</p></a></li>
<li><a href='#data_repeat_outcomes'><p>Simulated repeat measurement and time-to-event data</p></a></li>
<li><a href='#fit_LME_landmark'><p>Fit a landmarking model using a linear mixed effects (LME) model for the longitudinal submodel</p></a></li>
<li><a href='#fit_LME_longitudinal'><p>Fit a landmarking model using a linear mixed effects (LME) model for the longitudinal submodel</p></a></li>
<li><a href='#fit_LOCF_landmark'><p>Fit a landmark model using a last observation carried forward (LOCF) method for the longitudinal data</p></a></li>
<li><a href='#fit_LOCF_longitudinal'><p>Find the last observation carried forward (LOCF) values for covariates in a dataset</p></a></li>
<li><a href='#fit_survival_model'><p>Fit a survival sub-model</p></a></li>
<li><a href='#get_model_assessment'><p>Compute C-index and Brier score</p></a></li>
<li><a href='#mixoutsamp'><p>Calculate point estimates from a linear mixed effects (LME) model for new data</p></a></li>
<li><a href='#plot.landmark'><p>Create a calibration plot</p></a></li>
<li><a href='#predict.landmark'><p>Predict the risk of an event for a new individual using the landmark model</p></a></li>
<li><a href='#return_ids_with_LOCF'><p>Select individuals in a dataset with a last observation carried forward (LOCF) at a landmark time</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Analysis using Landmark Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>The landmark approach allows survival predictions to be
	updated dynamically as new measurements from an individual are recorded.
	The idea is to set predefined time points, known as "landmark times",
	and form a model at each landmark time using only the individuals in the
	risk set. This package allows the longitudinal data to be modelled
	either using the last observation carried forward or linear mixed
	effects modelling. There is also the option to model competing risks,
	either through cause-specific Cox regression or Fine-Gray regression.
	To find out more about the methods in this package, please see 
	<a href="https://isobelbarrott.github.io/Landmarking/articles/Landmarking">https://isobelbarrott.github.io/Landmarking/articles/Landmarking</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LazyDataCompression:</td>
<td>bzip2</td>
</tr>
<tr>
<td>Imports:</td>
<td>nlme, riskRegression, dplyr, pec, methods, prodlim, stats,
survival, mstate, ggplot2,</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), knitr, rmarkdown, JM</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/isobelbarrott/Landmarking/">https://github.com/isobelbarrott/Landmarking/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/isobelbarrott/Landmarking/issues">https://github.com/isobelbarrott/Landmarking/issues</a></td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-02-15 13:25:27 UTC; Isobel</td>
</tr>
<tr>
<td>Author:</td>
<td>Isobel Barrott [aut, cre],
  Jessica Barrett [aut],
  Ruth Keogh [ctb],
  Michael Sweeting [ctb],
  David Stevens [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Isobel Barrott &lt;isobel.barrott@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-02-15 20:00:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_cv_number'>Assign a k-fold cross-validation number</h2><span id='topic+add_cv_number'></span>

<h3>Description</h3>

<p>Randomly assigns a k-fold cross-validation number to each individual in a dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_cv_number(data_long, individual_id, k, seed = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_cv_number_+3A_data_long">data_long</code></td>
<td>
<p>Data frame in long format i.e. there may be more than one row per individual</p>
</td></tr>
<tr><td><code id="add_cv_number_+3A_individual_id">individual_id</code></td>
<td>
<p>Character string specifying the column name in <code>data_long</code> which contains the individual identifiers</p>
</td></tr>
<tr><td><code id="add_cv_number_+3A_k">k</code></td>
<td>
<p>Integer specifying the number of folds for cross-validation.
An alternative to setting parameter <code>cross_validation_df</code> for performing cross-validation; if both are missing no cross-validation is used.</p>
</td></tr>
<tr><td><code id="add_cv_number_+3A_seed">seed</code></td>
<td>
<p>The value of the seed (default is 1)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function randomly divides the <code>n</code> individual IDs
into <code>k</code> groups, each with <code>n/k</code> members (or as close to this number as possible).
</p>


<h3>Value</h3>

<p>Data frame <code>data_long</code> updated to contain a new column <code>cross_validation_number</code>
indicating the fold to which the individual has been assigned.
</p>


<h3>Author(s)</h3>

<p>Isobel Barrott <a href="mailto:isobel.barrott@gmail.com">isobel.barrott@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(data_repeat_outcomes)
data_repeat_outcomes &lt;- add_cv_number(data_long = data_repeat_outcomes,
                                      individual_id = "id",
                                      k = 10)
</code></pre>

<hr>
<h2 id='data_repeat_outcomes'>Simulated repeat measurement and time-to-event data</h2><span id='topic+data_repeat_outcomes'></span>

<h3>Description</h3>

<p>A simulated dataset which is a combination of longitudinal (repeat measurement) data and
time-to-event data.This dataset contains simulated data
from 3000 patients.
</p>
<p>The longitudinal (repeat measurement) data is formed using an LME model,
whose parameters were based on CVD risk assessments
recorded at primary care practices in New Zealand.
</p>
<p>A LME model was fitted to this dataset and values of <code>sbp_stnd</code>
and <code>tchdl_stnd</code> were estimated at landmark age 60. These values (along with the other baseline covariates)
were used to simulate time-to-event data from a
cause specific model with parameters based on CVD events of patients
at primary care practices in New Zealand.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_repeat_outcomes
</code></pre>


<h3>Format</h3>

<p>A dataset with 9048 rows and 14 columns:
</p>

<dl>
<dt>id</dt><dd><p>Patient ID</p>
</dd>
<dt>smoking</dt><dd><p>Smoking status, 0 indicates the patient has never smoked, 1 indicates the patient has quit smoking, and 2 indicates the patient is a current smoker</p>
</dd>
<dt>diabetes</dt><dd><p>Diabetes status, 0 indicates the patient is not diagnosed with diabetes, and 1 indicates the patient is diagnosed with diabetes</p>
</dd>
<dt>ethnicity</dt><dd><p>Ethnicity, one of five ethnicities</p>
</dd>
<dt>deprivation</dt><dd><p>Deprivation score, quintiles</p>
</dd>
<dt>index</dt><dd><p>An index indicating assessment number for a patient</p>
</dd>
<dt>sbp_stnd</dt><dd><p>Standardised systolic blood pressure</p>
</dd>
<dt>tchdl_stnd</dt><dd><p>Standardised total cholesterol to HDL ratio</p>
</dd>
<dt>end_of_study_age</dt><dd><p>Age that individual left the study, either the age at event (CVD or death) or age at end of study (1st Jan 2010)</p>
</dd>
<dt>response_time_tchdl_stnd</dt><dd><p>Age that total cholesterol to HDL ratio was recorded</p>
</dd>
<dt>response_time_sbp_stnd</dt><dd><p>Age that systolic blood pressure was recorded, this is the same as the date that the fixed measures were recorded</p>
</dd>
<dt>start_time</dt><dd><p>Age the individual entered follow-up</p>
</dd>
<dt>event_status</dt><dd><p>Event status, 0 indicates censoring, 1 indicates CVD event, and 2 indicates death from other causes</p>
</dd>
<dt>event_time</dt><dd><p>Event time</p>
</dd>
</dl>


<hr>
<h2 id='fit_LME_landmark'>Fit a landmarking model using a linear mixed effects (LME) model for the longitudinal submodel</h2><span id='topic+fit_LME_landmark'></span>

<h3>Description</h3>

<p>This function performs the two-stage landmarking analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_LME_landmark(
  data_long,
  x_L,
  x_hor,
  fixed_effects,
  random_effects,
  fixed_effects_time,
  random_effects_time,
  individual_id,
  k,
  cross_validation_df,
  random_slope_in_LME = TRUE,
  random_slope_as_covariate = TRUE,
  standardise_time = FALSE,
  lme_control = nlme::lmeControl(),
  event_time,
  event_status,
  survival_submodel = c("standard_cox", "cause_specific", "fine_gray"),
  b
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_LME_landmark_+3A_data_long">data_long</code></td>
<td>
<p>Data frame or list of data frames each corresponding to a landmark age <code>x_L</code> (each element of the list must be named the value of <code>x_L</code> it corresponds to).
Each data frame contains repeat measurements data and time-to-event data in long format.</p>
</td></tr>
<tr><td><code id="fit_LME_landmark_+3A_x_l">x_L</code></td>
<td>
<p>Numeric specifying the landmark time(s)</p>
</td></tr>
<tr><td><code id="fit_LME_landmark_+3A_x_hor">x_hor</code></td>
<td>
<p>Numeric specifying the horizon time(s)</p>
</td></tr>
<tr><td><code id="fit_LME_landmark_+3A_fixed_effects">fixed_effects</code></td>
<td>
<p>Vector of character strings specifying the column names in <code>data_long</code>
which correspond to the fixed effects</p>
</td></tr>
<tr><td><code id="fit_LME_landmark_+3A_random_effects">random_effects</code></td>
<td>
<p>Vector of character strings specifying the column names in <code>data_long</code>
which correspond to the random effects</p>
</td></tr>
<tr><td><code id="fit_LME_landmark_+3A_fixed_effects_time">fixed_effects_time</code></td>
<td>
<p>Character string specifying the column name in <code>data_long</code>
which contains the time at which the fixed effects were recorded</p>
</td></tr>
<tr><td><code id="fit_LME_landmark_+3A_random_effects_time">random_effects_time</code></td>
<td>
<p>Vector of character strings specifying the column names in <code>data_long</code>
which contain the times at which repeat measures were recorded. This should either be length 1 or
the same length as <code>random_effects</code>. In the latter case the order of elements must correspond to the
order of elements in <code>random_effects</code>.</p>
</td></tr>
<tr><td><code id="fit_LME_landmark_+3A_individual_id">individual_id</code></td>
<td>
<p>Character string specifying the column name in <code>data_long</code> which contains the individual identifiers</p>
</td></tr>
<tr><td><code id="fit_LME_landmark_+3A_k">k</code></td>
<td>
<p>Integer specifying the number of folds for cross-validation.
An alternative to setting parameter <code>cross_validation_df</code> for performing cross-validation; if both are missing no cross-validation is used.</p>
</td></tr>
<tr><td><code id="fit_LME_landmark_+3A_cross_validation_df">cross_validation_df</code></td>
<td>
<p>List of data frames containing the cross-validation fold each individual is assigned to. Each data frame in the list should be
named according to the landmark time <code>x_L</code> that they correspond. Each data frame should contain the columns <code>individual_id</code> and a column <code>cross_validation_number</code>
which contains the cross-validation fold of the individual. An alternative to setting parameter <code>k</code> for performing cross-validation;
if both are missing no cross-validation is used.</p>
</td></tr>
<tr><td><code id="fit_LME_landmark_+3A_random_slope_in_lme">random_slope_in_LME</code></td>
<td>
<p>Boolean indicating whether to include a random slope in the LME model</p>
</td></tr>
<tr><td><code id="fit_LME_landmark_+3A_random_slope_as_covariate">random_slope_as_covariate</code></td>
<td>
<p>Boolean indicating whether to include the random slope estimate from the LME model
as a covariate in the survival submodel.</p>
</td></tr>
<tr><td><code id="fit_LME_landmark_+3A_standardise_time">standardise_time</code></td>
<td>
<p>Boolean indicating whether to standardise the time variables (<code>fixed_effects_time</code> and <code>random_effects_time</code>) by subtracting the mean
and dividing by the standard deviation (see Details section for more information)</p>
</td></tr>
<tr><td><code id="fit_LME_landmark_+3A_lme_control">lme_control</code></td>
<td>
<p>Object created using <code>nlme::lmeControl()</code>, which will be passed to the <code>control</code> argument of the <code>lme</code>
function</p>
</td></tr>
<tr><td><code id="fit_LME_landmark_+3A_event_time">event_time</code></td>
<td>
<p>Character string specifying the column name in <code>data_long</code>
which contains the event time</p>
</td></tr>
<tr><td><code id="fit_LME_landmark_+3A_event_status">event_status</code></td>
<td>
<p>Character string specifying the column name in <code>data_long</code>
which contains the event status (where 0=censoring, 1=event of interest, if there are competing events these are labelled
2 or above).</p>
</td></tr>
<tr><td><code id="fit_LME_landmark_+3A_survival_submodel">survival_submodel</code></td>
<td>
<p>Character string specifying which survival submodel to
use. Three options: the standard Cox model i.e. no competing risks (<code>"standard_cox"</code>),
the cause-specific regression model (<code>"cause_specific"</code>), or the Fine Gray
regression model (<code>"fine_gray"</code>)</p>
</td></tr>
<tr><td><code id="fit_LME_landmark_+3A_b">b</code></td>
<td>
<p>Integer specifying the number of bootstrap samples to take when calcluating standard error of c-index and Brier score</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Firstly, this function selects the individuals in the risk set at the landmark time <code>x_L</code>.
Specifically, the individuals in the risk set are those that have entered the study before the landmark age
(there is at least one observation for each of the <code>fixed_effects</code> and<code>random_effects</code> on or before <code>x_L</code>) and
exited the study on after the landmark age (<code>event_time</code>
is greater than <code>x_L</code>).
</p>
<p>Secondly, if the option to use cross validation
is selected (using either parameter <code>k</code> or <code>cross_validation_df</code>), then an extra column <code>cross_validation_number</code> is added with the
cross-validation folds. If parameter <code>k</code> is used, then the function <code>add_cv_number</code>
randomly assigns these folds. For more details on this function see <code>?add_cv_number</code>.
If the parameter <code>cross_validation_df</code> is used, then the folds specified in this data frame are added.
If cross-validation is not selected then the landmark model is
fit to the entire group of individuals in the risk set (this is both the training and test dataset).
</p>
<p>Thirdly, the landmark model is then fit to each of the training data. There are two parts to fitting the landmark model: using the longitudinal data and using the survival data.
Using the longitudinal data is the first stage and is performed using <code>fit_LME_longitudinal</code>. See <code>?fit_LME_longitudinal</code> more for information about this function.
Using the survival data is the second stage and is performed using <code>fit_survival_model</code>. See <code>?fit_survival_model</code> more for information about this function.
</p>
<p>Fourthly, the performance of the model is then assessed on the set of predictions
from the entire set of individuals in the risk set by calculating Brier score and C-index.
This is performed using <code>get_model_assessment</code>. See <code>?get_model_assessment</code> more for information about this function.
</p>


<h3>Value</h3>

<p>List containing containing information about the landmark model at each of the landmark times.
Each element of this list is named the corresponding landmark time, and is itself a list containing elements:
<code>data</code>, <code>model_longitudinal</code>, <code>model_LME</code>, <code>model_LME_standardise_time</code>, <code>model_survival</code>, and <code>prediction_error</code>.
</p>
<p><code>data</code> has one row for each individual in the risk set at <code>x_L</code> and
contains the value of the <code>fixed_effects</code> using the LOCF approach and predicted values of the
<code>random_effects</code> using the LME model at the landmark time <code>x_L</code>. It also includes the predicted
probability that the event of interest has occurred by time <code>x_hor</code>, labelled as <code>"event_prediction"</code>.
There is one row for each individual.
</p>
<p><code>model_longitudinal</code> indicates that the longitudinal approach is LME.
</p>
<p><code>model_LME</code> contains the output from
the <code>lme</code> function from package <code>nlme</code>. For a model using cross-validation,
<code>model_LME</code> contains a list of outputs with each
element in the list corresponds to a different cross-validation fold.
<code>prediction_error</code> contains a list indicating the c-index and Brier score at time <code>x_hor</code> and their standard errors if parameter <code>b</code> is used.
For more information on how the prediction error is calculated
please see <code>?get_model_assessment</code> which is the function used to do this within <code>fit_LME_landmark</code>.
</p>
<p><code>model_LME_standardise_time</code> contains a list of two objects <code>mean_response_time</code> and <code>sd_response_time</code> if the parameter <code>standardise_time=TRUE</code> is used. This
is the mean and standard deviation use to normalise times when fitting the LME model.
</p>
<p><code>model_survival</code> contains the outputs from
the survival submodel functions, including the estimated parameters of the model. For a model using cross-validation,
<code>model_survival</code> will contain a list of outputs with each
element in the list corresponding to a different cross-validation fold.
<code>model_survival</code> contains the outputs from the function used to fit the survival submodel, including the estimated parameters of the model.
For a model using cross-validation, <code>model_survival</code> contains a list of outputs with each
element in the list corresponding to a different cross-validation fold. For more information on how the survival model is fitted
please see <code>?fit_survival_model</code> which is the function used to do this within <code>fit_LME_landmark</code>.
</p>
<p><code>prediction_error</code> contains a list indicating the c-index and Brier score at time <code>x_hor</code> and their standard errors if parameter <code>b</code> is used.
</p>


<h3>Author(s)</h3>

<p>Isobel Barrott <a href="mailto:isobel.barrott@gmail.com">isobel.barrott@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(Landmarking)
data(data_repeat_outcomes)
data_model_landmark_LME &lt;-
  fit_LME_landmark(
    data_long = data_repeat_outcomes,
    x_L = c(60, 61),
    x_hor = c(65, 66),
    k = 10,
    fixed_effects = c("ethnicity", "smoking", "diabetes"),
    fixed_effects_time = "response_time_sbp_stnd",
    random_effects = c("sbp_stnd", "tchdl_stnd"),
    random_effects_time = c("response_time_sbp_stnd", "response_time_tchdl_stnd"),
    individual_id = "id",
    standardise_time = TRUE,
    lme_control = nlme::lmeControl(maxIter = 100, msMaxIter = 100),
    event_time = "event_time",
    event_status = "event_status",
    survival_submodel = "cause_specific"
  )

</code></pre>

<hr>
<h2 id='fit_LME_longitudinal'>Fit a landmarking model using a linear mixed effects (LME) model for the longitudinal submodel</h2><span id='topic+fit_LME_longitudinal'></span>

<h3>Description</h3>

<p>This function is a helper function for <code>fit_LME_landmark</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_LME_longitudinal(
  data_long,
  x_L,
  fixed_effects,
  random_effects,
  fixed_effects_time,
  random_effects_time,
  standardise_time = FALSE,
  random_slope_in_LME = TRUE,
  random_slope_as_covariate = FALSE,
  cv_name = NA,
  individual_id,
  lme_control = nlme::lmeControl()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_LME_longitudinal_+3A_data_long">data_long</code></td>
<td>
<p>Data frame containing repeat measurement data and time-to-event data in long format.</p>
</td></tr>
<tr><td><code id="fit_LME_longitudinal_+3A_x_l">x_L</code></td>
<td>
<p>Numeric specifying the landmark time(s)</p>
</td></tr>
<tr><td><code id="fit_LME_longitudinal_+3A_fixed_effects">fixed_effects</code></td>
<td>
<p>Vector of character strings specifying the column names in <code>data_long</code>
which correspond to the fixed effects</p>
</td></tr>
<tr><td><code id="fit_LME_longitudinal_+3A_random_effects">random_effects</code></td>
<td>
<p>Vector of character strings specifying the column names in <code>data_long</code>
which correspond to the random effects</p>
</td></tr>
<tr><td><code id="fit_LME_longitudinal_+3A_fixed_effects_time">fixed_effects_time</code></td>
<td>
<p>Character string specifying the column name in <code>data_long</code>
which contains the time at which the fixed effects were recorded</p>
</td></tr>
<tr><td><code id="fit_LME_longitudinal_+3A_random_effects_time">random_effects_time</code></td>
<td>
<p>Vector of character strings specifying the column names in <code>data_long</code>
which contain the times at which repeat measures were recorded. This should either be length 1 or
the same length as <code>random_effects</code>. In the latter case the order of elements must correspond to the
order of elements in <code>random_effects</code>.</p>
</td></tr>
<tr><td><code id="fit_LME_longitudinal_+3A_standardise_time">standardise_time</code></td>
<td>
<p>Boolean indicating whether to standardise the time variable by subtracting the mean
and dividing by the standard deviation (see Details section for more information)</p>
</td></tr>
<tr><td><code id="fit_LME_longitudinal_+3A_random_slope_in_lme">random_slope_in_LME</code></td>
<td>
<p>Boolean indicating whether to include a random slope in the LME model</p>
</td></tr>
<tr><td><code id="fit_LME_longitudinal_+3A_random_slope_as_covariate">random_slope_as_covariate</code></td>
<td>
<p>Boolean indicating whether to include the random slope estimate from the LME model
as a covariate in the survival submodel.</p>
</td></tr>
<tr><td><code id="fit_LME_longitudinal_+3A_cv_name">cv_name</code></td>
<td>
<p>Character string specifying the column name in <code>data_long</code> that indicates cross-validation fold</p>
</td></tr>
<tr><td><code id="fit_LME_longitudinal_+3A_individual_id">individual_id</code></td>
<td>
<p>Character string specifying the column name in <code>data_long</code> which contains the individual identifiers</p>
</td></tr>
<tr><td><code id="fit_LME_longitudinal_+3A_lme_control">lme_control</code></td>
<td>
<p>Object created using <code>nlme::lmeControl()</code>, which will be passed to the <code>control</code> argument of the <code>lme</code> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For an individual <code class="reqn">i</code>, the LME model can be written as
</p>
<p style="text-align: center;"><code class="reqn">Y_i = X_i \beta + Z_i U_i + \epsilon_i</code>
</p>

<p>where
</p>

<ul>
<li> <p><code class="reqn">Y_i</code> is the vector of outcomes at different time points for the individual
</p>
</li>
<li> <p><code class="reqn">X_i</code> is the matrix of covariates for the fixed effects at these time points
</p>
</li>
<li> <p><code class="reqn">\beta</code> is the vector of coefficients for the fixed effects
</p>
</li>
<li> <p><code class="reqn">Z_i</code> is the matrix of covariates for the random effects
</p>
</li>
<li> <p><code class="reqn">U_i</code> is the matrix of coefficients for the random effects
</p>
</li>
<li> <p><code class="reqn">\epsilon_i</code> is the error term, typically from N(0, <code class="reqn">\sigma</code>)
</p>
</li></ul>

<p>By using an LME model to fit repeat measures data we can allow measurements from the same individuals to be
more similar than measurements from different individuals. This is done through the random intercept and/or
random slope.
</p>
<p>Extending this model to the case where there are multiple random effects, denoted <code class="reqn">k</code>, we have
</p>
<p style="text-align: center;"><code class="reqn">Y_{ik} = X_{ik} \beta_k + Z_{ik} U_{ik} + \epsilon_{ik}</code>
</p>

<p>Using this model we can allow a certain covariance structure within the random effects term <code class="reqn">U_{ik}</code>, for example a sample from the
multivariate normal (MVN) distribution <code class="reqn">MVN(0,\Sigma_u)</code>. This covariance structure means the value of one random effects variable informs about the
value of the other random effects variables, leading to more accurate predictions and allowing there to be missing data in the
random effects variables.
</p>
<p>The function <code>fit_LME_landmark</code> uses a unstructured covariance for the random effects when fitting the LME model (i.e. no constraints are imposed on the values).
To fit the LME model the function <code>lme</code> from the package <code>nlme</code> is used.
The fixed effects are calculated as the LOCF for the variables <code>fixed_effects</code> at the landmark age <code>x_L</code> and the random effects
are those stated in <code>random_effects</code> and at times <code>random_effects_time</code>.  The random intercept is always included in the LME model.
Additionally, the random slope can be included in the LME model using the parameter <code>random_slope_in_LME=TRUE</code>. The model is used to predict the
values of the random effects at the landmark time <code>x_L</code>,
and these are used as predictors in the survival model along with the LOCF values of the fixed effects.
Additionally, the estimated value of the random slope can
be included as predictors in the survival model using the parameter <code>random_slope_as_covariate=TRUE</code>.
</p>
<p>It is important to distinguish between the validation set and the development set for fitting the LME model. The development set includes
all the repeat measurements (including those after the landmark age <code>x_L</code>). Conversely, the validation set only includes
the repeat measurements recorded up until and including the landmark age <code>x_L</code>.
</p>
<p>There is an important consideration about fitting the linear mixed effects model. As the variable <code>random_effects_time</code>
gets further from 0, the random effects coefficients get closer to 0. This causes computational issues
as the elements in the covariance matrix of the random effects, <code class="reqn">\Sigma_u</code>, are constrained to
be greater than 0. Using parameter <code>standard_time=TRUE</code> can prevent this issue by standardising the
time variables to ensure that the <code>random_effects_time</code> values are not too close to 0.
</p>
<p>The LOCF values for the fixed effects and the prediction of the random effects at the landmark age
are used as the covariates for the survival submodel, in addition to the estimated random slopes
if option <code>random_effects_as_covariate</code> is selected.
</p>


<h3>Value</h3>

<p>List containing elements:
<code>data_longitudinal</code>, <code>model_longitudinal</code>, <code>model_LME</code>, and <code>model_LME_standardise_time</code>.
</p>
<p><code>data_longitudinal</code> has one row for each individual in the risk set at <code>x_L</code> and
contains the value of the covariates at the landmark time <code>x_L</code> of the <code>fixed_effects</code> using the LOCF model and
<code>random_effects</code> using the LME model.
</p>
<p><code>model_longitudinal</code> indicates that the LME approach is used.
</p>
<p><code>model_LME</code> contains the output from
the <code>lme</code> function from package <code>nlme</code>. For a model using cross-validation,
<code>model_LME</code> contains a list of outputs with each
element in the list corresponds to a different cross-validation fold.
</p>
<p><code>model_LME_standardise_time</code> contains a list of two objects <code>mean_response_time</code> and <code>sd_response_time</code> if the parameter <code>standardise_time=TRUE</code> is used. This
is the mean and standard deviation used to normalise times when fitting the LME model.
</p>

<hr>
<h2 id='fit_LOCF_landmark'>Fit a landmark model using a last observation carried forward (LOCF) method for the longitudinal data</h2><span id='topic+fit_LOCF_landmark'></span>

<h3>Description</h3>

<p>This function performs the two-stage landmarking analysis. In the first stage, the longitudinal submodel is fitted using the LOCF method and in the
second stage the survival submodel is fitted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_LOCF_landmark(
  data_long,
  x_L,
  x_hor,
  covariates,
  covariates_time,
  k,
  cross_validation_df,
  individual_id,
  event_time,
  event_status,
  survival_submodel = c("standard_cox", "cause_specific", "fine_gray"),
  b
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_LOCF_landmark_+3A_data_long">data_long</code></td>
<td>
<p>Data frame or list of data frames each corresponding to a landmark age <code>x_L</code> (each element of the list must be named the value of <code>x_L</code> it corresponds to).
Each data frame contains repeat measurements data and time-to-event data in long format.</p>
</td></tr>
<tr><td><code id="fit_LOCF_landmark_+3A_x_l">x_L</code></td>
<td>
<p>Numeric specifying the landmark time(s)</p>
</td></tr>
<tr><td><code id="fit_LOCF_landmark_+3A_x_hor">x_hor</code></td>
<td>
<p>Numeric specifying the horizon time(s)</p>
</td></tr>
<tr><td><code id="fit_LOCF_landmark_+3A_covariates">covariates</code></td>
<td>
<p>Vector of character strings specifying the column names in <code>data_long</code>
which correspond to the covariates</p>
</td></tr>
<tr><td><code id="fit_LOCF_landmark_+3A_covariates_time">covariates_time</code></td>
<td>
<p>Vector of character strings specifying the column names in <code>data_long</code>
which contain the times at which <code>covariates</code> were recorded. This should either be length 1 or
the same length as <code>covariates</code>. In the latter case the order of elements must correspond to the
order of elements in <code>covariates</code>.</p>
</td></tr>
<tr><td><code id="fit_LOCF_landmark_+3A_k">k</code></td>
<td>
<p>Integer specifying the number of folds for cross-validation. An alternative to setting parameter <code>cross_validation_df</code> for performing cross-validation;
if both are missing no cross-validation is used.</p>
</td></tr>
<tr><td><code id="fit_LOCF_landmark_+3A_cross_validation_df">cross_validation_df</code></td>
<td>
<p>List of data frames containing the cross-validation fold each individual is assigned to. Each data frame in the list should be
named according to the landmark time <code>x_L</code> that they correspond. Each data frame should contain the columns <code>individual_id</code> and a column <code>cross_validation_number</code>
which contains the cross-validation fold of the individual. An alternative to setting parameter <code>k</code> for performing cross-validation;
if both are missing no cross-validation is used.</p>
</td></tr>
<tr><td><code id="fit_LOCF_landmark_+3A_individual_id">individual_id</code></td>
<td>
<p>Character string specifying the column name in <code>data_long</code> which contains the individual identifiers</p>
</td></tr>
<tr><td><code id="fit_LOCF_landmark_+3A_event_time">event_time</code></td>
<td>
<p>Character string specifying the column name in <code>data_long</code>
which contains the event time</p>
</td></tr>
<tr><td><code id="fit_LOCF_landmark_+3A_event_status">event_status</code></td>
<td>
<p>Character string specifying the column name in <code>data_long</code>
which contains the event status (where 0=censoring, 1=event of interest, if there are competing events these are labelled
2 or above).</p>
</td></tr>
<tr><td><code id="fit_LOCF_landmark_+3A_survival_submodel">survival_submodel</code></td>
<td>
<p>Character string specifying which survival submodel to
use. Three options: the standard Cox model i.e. no competing risks (<code>"standard_cox"</code>),
the cause-specific regression model (<code>"cause_specific"</code>), or the Fine Gray
regression model (<code>"fine_gray"</code>)</p>
</td></tr>
<tr><td><code id="fit_LOCF_landmark_+3A_b">b</code></td>
<td>
<p>Integer specifying the number of bootstrap samples to take when calcluating standard error of c-index and Brier score</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Firstly, this function selects the individuals in the risk set at the landmark time <code>x_L</code>.
Specifically, the individuals in the risk set are those that have entered the study before the landmark age
(there is at least one observation for each of the <code>covariates</code> on or before <code>x_L</code>) and
exited the study on after the landmark age (<code>event_time</code>
is greater than <code>x_L</code>).
</p>
<p>Secondly, if the option to use cross validation
is selected (using either parameter <code>k</code> or <code>cross_validation_df</code>), then an extra column <code>cross_validation_number</code> is added with the
cross-validation folds. If parameter <code>k</code> is used, then the function <code>add_cv_number</code>
randomly assigns these folds. For more details on this function see <code>?add_cv_number</code>.
If the parameter <code>cross_validation_df</code> is used, then the folds specified in this data frame are added.
If cross-validation is not selected then the landmark model is
fit to the entire group of individuals in the risk set (this is both the training and test dataset).
</p>
<p>Thirdly, the landmark model is then fit to each of the training data. There are two parts to fitting the landmark model: using the longitudinal data and using the survival data.
Using the longitudinal data is the first stage and is performed using <code>fit_LOCF_longitudinal</code>. See <code>?fit_LOCF_longitudinal</code> more for information about this function.
Using the survival data is the second stage and is performed using <code>fit_survival_model</code>. See <code>?fit_survival_model</code> more for information about this function.
</p>
<p>Fourthly, the performance of the model is then assessed on the set of predictions
from the entire set of individuals in the risk set by calculating Brier score and C-index.
This is performed using <code>get_model_assessment</code>. See <code>?get_model_assessment</code> more for information about this function.
</p>


<h3>Value</h3>

<p>List containing containing information about the landmark model at each of the landmark times.
Each element of this list is named the corresponding landmark time, and is itself a list containing elements:
<code>data</code>, <code>model_longitudinal</code>, <code>model_survival</code>, and <code>prediction_error</code>.
</p>
<p><code>data</code>  has one row for each individual in the risk set at <code>x_L</code> and
contains the value of the <code>covariates</code> at the landmark time <code>x_L</code> using the LOCF approach. It also includes the predicted
probability that the event of interest has occurred by time <code>x_hor</code>, labelled as <code>"event_prediction"</code>.
There is one row for each individual.
</p>
<p><code>model_longitudinal</code> indicates that the longitudinal approach is LOCF.
</p>
<p><code>model_survival</code> contains the outputs from the function used to fit the survival submodel, including the estimated parameters of the model.
For a model using cross-validation, <code>model_survival</code> contains a list of outputs with each
element in the list corresponding to a different cross-validation fold. For more information on how the survival model is fitted
please see <code>?fit_survival_model</code> which is a function used within <code>fit_LOCF_landmark</code>.
</p>
<p><code>prediction_error</code> contains a list indicating the c-index and Brier score at time <code>x_hor</code> and their standard errors if parameter <code>b</code> is used.
For more information on how the prediction error is calculated
please see <code>?get_model_assessment</code> which is the function used to do this within <code>fit_LOCF_landmark</code>.
</p>


<h3>Author(s)</h3>

<p>Isobel Barrott <a href="mailto:isobel.barrott@gmail.com">isobel.barrott@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(Landmarking)
data(data_repeat_outcomes)
data_model_landmark_LOCF &lt;-
   fit_LOCF_landmark(
     data_long = data_repeat_outcomes,
     x_L = c(60, 61),
     x_hor = c(65, 66),
     covariates =
       c("ethnicity", "smoking", "diabetes", "sbp_stnd", "tchdl_stnd"),
     covariates_time =
       c(rep("response_time_sbp_stnd", 4), "response_time_tchdl_stnd"),
     k = 10,
     individual_id = "id",
     event_time = "event_time",
     event_status = "event_status",
     survival_submodel = "cause_specific"
   )
</code></pre>

<hr>
<h2 id='fit_LOCF_longitudinal'>Find the last observation carried forward (LOCF) values for covariates in a dataset</h2><span id='topic+fit_LOCF_longitudinal'></span>

<h3>Description</h3>

<p>This function is a helper function for <code>fit_LOCF_landmark</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_LOCF_longitudinal(
  data_long,
  x_L,
  covariates,
  covariates_time,
  cv_name = NA,
  individual_id
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_LOCF_longitudinal_+3A_data_long">data_long</code></td>
<td>
<p>Data frame in long format i.e. there may be more than one row per individual</p>
</td></tr>
<tr><td><code id="fit_LOCF_longitudinal_+3A_x_l">x_L</code></td>
<td>
<p>Numeric specifying the landmark time(s)</p>
</td></tr>
<tr><td><code id="fit_LOCF_longitudinal_+3A_covariates">covariates</code></td>
<td>
<p>Vector of character strings specifying the column names in <code>data_long</code>
which correspond to the covariates</p>
</td></tr>
<tr><td><code id="fit_LOCF_longitudinal_+3A_covariates_time">covariates_time</code></td>
<td>
<p>Vector of character strings specifying the column names in <code>data_long</code>
which contain the times at which <code>covariates</code> were recorded. This should either be length 1 or
the same length as <code>covariates</code>. In the latter case the order of elements must correspond to the
order of elements in <code>covariates</code>.</p>
</td></tr>
<tr><td><code id="fit_LOCF_longitudinal_+3A_cv_name">cv_name</code></td>
<td>
<p>Character string specifying the column name in <code>data_long</code> that indicates cross-validation fold</p>
</td></tr>
<tr><td><code id="fit_LOCF_longitudinal_+3A_individual_id">individual_id</code></td>
<td>
<p>Character string specifying the column name in <code>data_long</code> which contains the individual identifiers</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function extracts the LOCF value for each of the <code>covariates</code> in <code>data_long</code> up to (and including) time <code>x_L</code>.
</p>


<h3>Value</h3>

<p>List containing <code>data_longitudinal</code>, <code>model_longitudinal</code>, and <code>call</code>.
</p>
<p><code>data_longitudinal</code> has one row for each individual in <code>data_long</code> and
contains the LOCF value of <code>covariates</code> at the landmark time <code>x_L</code>.
</p>
<p><code>model_longitudinal</code> indicates that the LOCF approach is used.
</p>
<p><code>call</code> contains the call of the function.
</p>


<h3>Author(s)</h3>

<p>Isobel Barrott <a href="mailto:isobel.barrott@gmail.com">isobel.barrott@gmail.com</a>
</p>

<hr>
<h2 id='fit_survival_model'>Fit a survival sub-model</h2><span id='topic+fit_survival_model'></span>

<h3>Description</h3>

<p>This function is a helper function for <code>fit_LOCF_landmark_model</code> and <code>fit_LME_landmark_model</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_survival_model(
  data,
  individual_id,
  cv_name = NA,
  covariates,
  event_time,
  event_status,
  survival_submodel = c("standard_cox", "cause_specific", "fine_gray"),
  x_hor
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_survival_model_+3A_data">data</code></td>
<td>
<p>Data frame containing covariates and time-to-event data, one row for each individual.</p>
</td></tr>
<tr><td><code id="fit_survival_model_+3A_individual_id">individual_id</code></td>
<td>
<p>Character string specifying the column name in <code>data</code> which contains the individual identifiers</p>
</td></tr>
<tr><td><code id="fit_survival_model_+3A_cv_name">cv_name</code></td>
<td>
<p>Character string specifying the column name in <code>data</code> that indicates cross-validation fold. If no cross-validation is needed, set this parameter to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="fit_survival_model_+3A_covariates">covariates</code></td>
<td>
<p>Vector of character strings specifying the column names in <code>data_long</code>
which correspond to the covariates</p>
</td></tr>
<tr><td><code id="fit_survival_model_+3A_event_time">event_time</code></td>
<td>
<p>Character string specifying the column name in <code>data</code> which contains the event time</p>
</td></tr>
<tr><td><code id="fit_survival_model_+3A_event_status">event_status</code></td>
<td>
<p>Character string specifying the column name in <code>data</code> which contains the event status (where 0=censoring, 1=event of interest, if there are competing events these are labelled 2 or above). Events at time x_hor should be labelled censored.</p>
</td></tr>
<tr><td><code id="fit_survival_model_+3A_survival_submodel">survival_submodel</code></td>
<td>
<p>Character string specifying which survival submodel to
use. Three options: the standard Cox model i.e. no competing risks (<code>"standard_cox"</code>),
the cause-specific regression model (<code>"cause_specific"</code>), or the Fine Gray
regression model (<code>"fine_gray"</code>)</p>
</td></tr>
<tr><td><code id="fit_survival_model_+3A_x_hor">x_hor</code></td>
<td>
<p>Numeric specifying the horizon time(s)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the survival submodel, there are three choices of model:
</p>

<ul>
<li><p> the standard Cox model, this is a wrapper function for <code>coxph</code> from the package <code>survival</code>
</p>
</li>
<li><p> the cause-specific model, this is a wrapper function for <code>CSC</code> from package <code>riskRegression</code>
</p>
</li>
<li><p> the Fine Gray model, this is a wrapper function for <code>FGR</code> from package <code>riskRegression</code>
</p>
</li></ul>

<p>The latter two models estimate the probability of the event of interest in the presence of competing events.
</p>
<p>For both the c-index and Brier score calculations, inverse probability censoring weighting (IPCW) is used to create weights which account for the occurrence of censoring. The censoring model assumes for this function is the Kaplan Meier model, i.e. censoring occurs independently of covariates.
</p>


<h3>Value</h3>

<p>List containing <code>data_survival</code> and <code>model_survival</code>
</p>
<p><code>data_survival</code> contains the predicted risk of event by the horizon time <code>x_hor</code>.
</p>
<p><code>model_survival</code> contains the outputs from the function used to fit the survival submodel, including the estimated parameters of the model.
For a model using cross-validation, <code>model_survival</code> contains a list of outputs with each
element in the list corresponding to a different cross-validation fold.
</p>


<h3>Author(s)</h3>

<p>Isobel Barrott <a href="mailto:isobel.barrott@gmail.com">isobel.barrott@gmail.com</a>
</p>

<hr>
<h2 id='get_model_assessment'>Compute C-index and Brier score</h2><span id='topic+get_model_assessment'></span>

<h3>Description</h3>

<p>Performs model assessment by computing the C-index and Brier score at time <code>x_hor</code>. There is the option
to calculate their standard errors using bootstraping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_model_assessment(
  data,
  individual_id,
  event_prediction,
  event_status,
  event_time,
  x_hor,
  b
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_model_assessment_+3A_data">data</code></td>
<td>
<p>Data frame containing survival outcomes and the event predictions from the model,
there should be one row for each individual</p>
</td></tr>
<tr><td><code id="get_model_assessment_+3A_individual_id">individual_id</code></td>
<td>
<p>Character string specifying the column name in <code>data</code> which contains the individual identifiers</p>
</td></tr>
<tr><td><code id="get_model_assessment_+3A_event_prediction">event_prediction</code></td>
<td>
<p>Character string specifying the column name in <code>data</code> containing the predicted probability of the event of interest</p>
</td></tr>
<tr><td><code id="get_model_assessment_+3A_event_status">event_status</code></td>
<td>
<p>Character string specifying the column name in <code>data</code> which contains the event status (where 0=censoring, 1=event of interest, if there are competing events these are labelled 2 or above). Events at time <code>x_hor</code> should be labelled censored.</p>
</td></tr>
<tr><td><code id="get_model_assessment_+3A_event_time">event_time</code></td>
<td>
<p>Character string specifying the column name in <code>data</code> which contains the event time.</p>
</td></tr>
<tr><td><code id="get_model_assessment_+3A_x_hor">x_hor</code></td>
<td>
<p>Numeric specifying the horizon time(s)</p>
</td></tr>
<tr><td><code id="get_model_assessment_+3A_b">b</code></td>
<td>
<p>Integer specifying the number of bootstrap samples to take when calcluating standard error of c-index and Brier score</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are two factors in assessing the performance of a prediction model; its
discrimination and its calibration. The c-index is a commonly used metric which assesses
discrimination, this refers to the ability of the model to separate individuals into
those that will have an event and those that will not. The c-index at a horizon time <code>x_hor</code>
looks at the pairs of individuals where one individual has the event at a time T and the other has not had the event at time T.
It is calculated as the proportion of these pairs where their relative risk prediction agrees with the
actual outcomes for the two individuals. This is extended to the competing risks case
by comparing individuals where one had the event of interest at time T and the other individual either
did not experience the event before this time T or experienced a competing event.
</p>
<p>The Brier score gives an indication of the calibration of a model (and its discrimination to an extent), this refers to the agreement between the risk prediction and
the outcome. The Brier score is calculated as the average mean squared error of the predicted risk and the event outcome (where
an event is 1 and not experiencing the event is 0). This is extended to the competing risks case by including the competing risk events as
not experiencing the event.
</p>
<p>For both the c-index and Brier score calculations, inverse probability censoring weighting (IPCW) is used to create weights
which account for the occurence of censoring. The censoring model assumes for this function is the Kaplan Meier model, i.e. censoring occurs
independently of covariates.
</p>
<p>The c-index is calculated using the <code>cindex</code> function in package <code>pec</code>. The Brier score is calculated using
<code>pec</code> function in package <code>pec</code>.
</p>


<h3>Value</h3>

<p>List containing C-index, Brier score and their standard errors
</p>


<h3>Author(s)</h3>

<p>Isobel Barrott <a href="mailto:isobel.barrott@gmail.com">isobel.barrott@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(Landmarking)
data(data_repeat_outcomes)
data_model_landmark_LOCF &lt;-
  fit_LOCF_landmark(
    data_long = data_repeat_outcomes,
    x_L = c(60, 61),
    x_hor = c(65, 66),
    covariates =
      c("ethnicity", "smoking", "diabetes", "sbp_stnd", "tchdl_stnd"),
    covariates_time =
      c(rep("response_time_sbp_stnd", 4), "response_time_tchdl_stnd"),
    k = 10,
    individual_id = "id",
    event_time = "event_time",
    event_status = "event_status",
    survival_submodel = "cause_specific"
  )
get_model_assessment(data = data_model_landmark_LOCF[["60"]]$data,
  individual_id = "id",
  event_prediction = "event_prediction",
  event_status = "event_status",
  event_time = "event_time",
  x_hor = 65,
  b = 10)
## End(Not run)
</code></pre>

<hr>
<h2 id='mixoutsamp'>Calculate point estimates from a linear mixed effects (LME) model for new data</h2><span id='topic+mixoutsamp'></span>

<h3>Description</h3>

<p>This function allows the user to make out-of-sample predictions from an LME model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixoutsamp(model, newdata)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mixoutsamp_+3A_model">model</code></td>
<td>
<p>Object of class <code>lme</code> containing the fitted LME model</p>
</td></tr>
<tr><td><code id="mixoutsamp_+3A_newdata">newdata</code></td>
<td>
<p>Data frame containing data for which to make predictions.
The response variable should be set to NA for the rows of the data the user wishes to make predictions for.
The columns in the data should have the same names as those used to fit the model.
The variables should also be of the same type as in the data used to fit the mixed model (numeric, factor etc).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing <code>preddata</code> and <code>random</code>. Data frame <code>preddata</code> is a version of <code>newdata</code> updated to contain columns corresponding to the fixed effects values (<code>fixed</code>),
random effects values (<code>random</code>), and fitted values (<code>fitted</code>).
Data frame <code>random</code> contains the values of random effects components for each individual.
</p>


<h3>Author(s)</h3>

<p>This code was originally written by Ruth Keogh (London School of Hygiene and Tropical Medicine) which can be viewed at
github.com/ruthkeogh/landmark_CF. There have been further contributions from Jessica Barrett (MRC Biostatistics Unit, University of Cambridge),
David Stevens (University of Liverpool), and Mike Sweeting (University of Leicester).
</p>

<hr>
<h2 id='plot.landmark'>Create a calibration plot</h2><span id='topic+plot.landmark'></span>

<h3>Description</h3>

<p>Creates a calibration plot for the landmark model fitted by <code>fit_LME_landmark_model</code> or <code>fit_LOCF_landmark_model</code>.
This function plots the observed frequencies of the event of interest against the predicted probabilities of the event of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'landmark'
plot(x, x_L, n, x_lims, y_lims, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.landmark_+3A_x">x</code></td>
<td>
<p>Object inheriting the class <code>landmark</code>, this should be the output from either <code>fit_LME_landmark_model</code> or <code>fit_LOCF_landmark_model</code>. It should contain a list
of landmark models corresponding to different landmark times <code>x_L</code>.</p>
</td></tr>
<tr><td><code id="plot.landmark_+3A_x_l">x_L</code></td>
<td>
<p>Numeric specifying the landmark time. This indicates which landmark model in <code>x</code> to use.</p>
</td></tr>
<tr><td><code id="plot.landmark_+3A_n">n</code></td>
<td>
<p>Numeric specifying the number of bins to use.</p>
</td></tr>
<tr><td><code id="plot.landmark_+3A_x_lims">x_lims</code></td>
<td>
<p>Vector of length 2 specifying the limits of the x axes</p>
</td></tr>
<tr><td><code id="plot.landmark_+3A_y_lims">y_lims</code></td>
<td>
<p>Vector of length 2 specifying the limits of the y axes</p>
</td></tr>
<tr><td><code id="plot.landmark_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>ggplot2::labs</code> to modify axis, legend, and plot labels</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function bins the predicted probabilities of the event of interest into <code>n</code> bins. The event of interest is the event with
<code>event_status=1</code> when fitting the landmark model. For each of the <code>n</code> sets of individuals, the Aalen-Johansen estimator is fit to that set
and used to calculate the risk of an event at the horizon time. The predictions (from the landmark model) and the observed frequencies
(from the Aalen-Johansen estimator) are plotted against each other. For a perfect prediction model, the points will be plotted along the y=x line.
</p>


<h3>Value</h3>

<p>Calibration plot showing the value of predicted probabilities against observed frequencies, with a <code>y=x</code> line.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(Landmarking)
data(data_repeat_outcomes)
data_model_landmark_LOCF &lt;-
  fit_LOCF_landmark(
    data_long = data_repeat_outcomes,
    x_L = c(60, 61),
    x_hor = c(65, 66),
    covariates =
      c("ethnicity", "smoking", "diabetes", "sbp_stnd", "tchdl_stnd"),
    covariates_time =
      c(rep("response_time_sbp_stnd", 4), "response_time_tchdl_stnd"),
    k = 10,
    individual_id = "id",
    event_time = "event_time",
    event_status = "event_status",
    survival_submodel = "cause_specific"
  )
 plot(x=data_model_landmark_LOCF,x_L=60,n=5)
 plot(x=data_model_landmark_LOCF,x_L=61,n=5)
</code></pre>

<hr>
<h2 id='predict.landmark'>Predict the risk of an event for a new individual using the landmark model</h2><span id='topic+predict.landmark'></span>

<h3>Description</h3>

<p>This function predicts the risk of an event for new data using the landmark model fitted by <code>fit_LME_landmark</code> or <code>fit_LOCF_landmark</code>.
The 'event' is defined as event for which <code>event_status</code> is 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'landmark'
predict(object, x_L, x_hor, newdata, cv_fold = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.landmark_+3A_object">object</code></td>
<td>
<p>Object inheriting the class <code>landmark</code>, this should be the output from either <code>fit_LME_landmark</code> or <code>fit_LOCF_landmark</code>. It should contain a list
of landmark models corresponding to different landmark times <code>x_L</code>.</p>
</td></tr>
<tr><td><code id="predict.landmark_+3A_x_l">x_L</code></td>
<td>
<p>Numeric specifying the landmark time. This indicates which landmark model in <code>object</code> to use.</p>
</td></tr>
<tr><td><code id="predict.landmark_+3A_x_hor">x_hor</code></td>
<td>
<p>Numeric specifying the horizon time. The function assesses the risk of event before this time.</p>
</td></tr>
<tr><td><code id="predict.landmark_+3A_newdata">newdata</code></td>
<td>
<p>Data frame containing new data to return the risk prediction of the event of interest. The data should be in in long format
and the columns must contain the covariates and time variables that are used to fit the model.
For the LME model this the variables <code>fixed_effects</code>, <code>random_effects</code>, <code>fixed_effects_time</code>, and
<code>random_effects_time</code>. For the LOCF model this is <code>covariates</code> and <code>covariates_time</code>.</p>
</td></tr>
<tr><td><code id="predict.landmark_+3A_cv_fold">cv_fold</code></td>
<td>
<p>If cross validation is used to fit <code>fit_LME_landmark</code> or <code>fit_LOCF_landmark</code>, then the cross validation fold to use when making risk predictions needs to be specified.</p>
</td></tr>
<tr><td><code id="predict.landmark_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code>riskRegression::predictRisk</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame <code>newdata</code> updated to contained a new column <code>event_prediction</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(Landmarking)
data(data_repeat_outcomes)
data_model_landmark_LOCF &lt;-
  fit_LOCF_landmark(
    data_long = data_repeat_outcomes,
    x_L = c(60, 61),
    x_hor = c(65, 66),
    covariates =
      c("ethnicity", "smoking", "diabetes", "sbp_stnd", "tchdl_stnd"),
    covariates_time =
      c(rep("response_time_sbp_stnd", 4), "response_time_tchdl_stnd"),
    k = 10,
    individual_id = "id",
    event_time = "event_time",
    event_status = "event_status",
    survival_submodel = "cause_specific"
  )
 newdata &lt;-
   rbind(
     data.frame(
       id = c(3001, 3001, 3001),
       response_time_sbp_stnd = c(57, 58, 59),
       smoking = c(0, 0, 0),
       diabetes = c(0, 0, 0),
       ethnicity = c("Indian", "Indian", "Indian"),
       sbp_stnd = c(0.45, 0.87, 0.85),
       tchdl_stnd = c(-0.7, 0.24, 0.3),
       response_time_tchdl_stnd = c(57, 58, 59)
     )
   )
 predict(object=data_model_landmark_LOCF,x_L=60,x_hor=62,newdata=newdata,cv_fold=1)
</code></pre>

<hr>
<h2 id='return_ids_with_LOCF'>Select individuals in a dataset with a last observation carried forward (LOCF) at a landmark time</h2><span id='topic+return_ids_with_LOCF'></span>

<h3>Description</h3>

<p>To fit the LOCF model, all individuals must have at least one
non-<code>NA</code> entry by landmark time <code>x_L</code> for all covariates.
This function selects these individuals and removes the other rows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>return_ids_with_LOCF(
  data_long,
  individual_id,
  x_L,
  covariates,
  covariates_time
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="return_ids_with_LOCF_+3A_data_long">data_long</code></td>
<td>
<p>Data frame with repeated measurements data in long format</p>
</td></tr>
<tr><td><code id="return_ids_with_LOCF_+3A_individual_id">individual_id</code></td>
<td>
<p>Character string specifying the column name in <code>data_long</code> which contains the individual identifiers</p>
</td></tr>
<tr><td><code id="return_ids_with_LOCF_+3A_x_l">x_L</code></td>
<td>
<p>Numeric specifying the landmark time(s)</p>
</td></tr>
<tr><td><code id="return_ids_with_LOCF_+3A_covariates">covariates</code></td>
<td>
<p>Vector of character strings specifying the column names in <code>data_long</code>
which correspond to the covariates</p>
</td></tr>
<tr><td><code id="return_ids_with_LOCF_+3A_covariates_time">covariates_time</code></td>
<td>
<p>Vector of character strings specifying the column names in <code>data_long</code>
which contain the times at which <code>covariates</code> were recorded. This should either be length 1 or
the same length as <code>covariates</code>. In the latter case the order of elements must correspond to the
order of elements in <code>covariates</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Individuals have a LOCF if there is a non-<code>NA</code> entry for each of the covariates in
<code>covariates</code> up until (not including) time <code>x_L</code>.
</p>


<h3>Value</h3>

<p>List of data frames which correspond to each landmark time <code>x_L</code>.
Each data frame is an updated version of <code>data_long</code> which contains only rows
of individuals with a LOCF at age <code>x_L</code>, other rows are removed.
</p>


<h3>Author(s)</h3>

<p>Isobel Barrott <a href="mailto:isobel.barrott@gmail.com">isobel.barrott@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(Landmarking)
data(data_repeat_outcomes)
data_repeat_outcomes &lt;-
  return_ids_with_LOCF(
    data_long = data_repeat_outcomes,
    individual_id = "id",
    covariates =
      c("ethnicity", "smoking", "diabetes", "sbp_stnd", "tchdl_stnd"),
    covariates_time =
      c(rep("response_time_sbp_stnd", 4), "response_time_tchdl_stnd"),
    x_L = c(60,61)
  )
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
