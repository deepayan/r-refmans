<!DOCTYPE html><html><head><title>Help for package SAMtool</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SAMtool}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Assessment-class'><p>Class-<code>Assessment</code></p></a></li>
<li><a href='#cDD'><p>Continuous Delay-differential assessment model</p></a></li>
<li><a href='#check_RCMdata'><p>Rapid Conditioning Model (RCM)</p></a></li>
<li><a href='#compare_models'><p>Compare output from several assessment models</p></a></li>
<li><a href='#DD_TMB'><p>Delay - Difference Stock Assessment in TMB</p></a></li>
<li><a href='#diagnostic'><p>Diagnostic of assessments in MSE: did Assess models converge during MSE?</p></a></li>
<li><a href='#getinds'><p>Characterize posterior predictive data</p></a></li>
<li><a href='#HCR_escapement'><p>Fixed escapement harvest control rule</p></a></li>
<li><a href='#HCR_FB'><p>A Harvest Control Rule using B/BMSY and F/FMSY to adjust TAC or TAE.</p></a></li>
<li><a href='#HCR_fixedF'><p>Simple fixed F harvest control rule</p></a></li>
<li><a href='#HCR_MSY'><p>Harvest control rule to fish at some fraction of maximum sustainable yield</p></a></li>
<li><a href='#HCR_ramp'><p>Linearly ramped harvest control rules</p></a></li>
<li><a href='#HCR_segment'><p>Segmented harvest control rules</p></a></li>
<li><a href='#HCRlin'><p>Generic linear harvest control rule based on biomass</p></a></li>
<li><a href='#mahplot'><p>Plot statistical power of the indicator with increasing time blocks</p></a></li>
<li><a href='#make_interim_MP'><p>Make a custom management procedure (MP)</p></a></li>
<li><a href='#Model-based-MP'><p>Model-based management procedures</p></a></li>
<li><a href='#pcod'><p>Pacific cod in Area 5ABCD (Hecate Strait and Queen Charlotte Sound), British Columbia, Canada</p></a></li>
<li><a href='#plot_betavar'><p>Plots a beta variable</p></a></li>
<li><a href='#plot_composition'><p>Plot composition data</p></a></li>
<li><a href='#plot_crosscorr'><p>Produce a cross-correlation plot of the derived data arising from getinds(MSE_object)</p></a></li>
<li><a href='#plot_lognormalvar'><p>Plots a lognormal variable</p></a></li>
<li><a href='#plot_residuals'><p>Plot residuals</p></a></li>
<li><a href='#plot_SR'><p>Plot stock-recruitment function</p></a></li>
<li><a href='#plot_steepness'><p>Plots probability distribution function of stock-recruit steepness</p></a></li>
<li><a href='#plot_timeseries'><p>Plot time series of data</p></a></li>
<li><a href='#plot.Assessment'><p>Plot Assessment object</p></a></li>
<li><a href='#plot.prof'><p>Plot profile object</p></a></li>
<li><a href='#plot.RCModel'><p>Plot RCM scope output</p></a></li>
<li><a href='#plot.retro'><p>Methods for retro object</p></a></li>
<li><a href='#posterior'><p>Sample posterior of TMB models in SAMtool</p></a></li>
<li><a href='#PRBcalc'><p>Calculate mahalanobis distance (null and alternative MSEs) and statistical power for all MPs in an MSE</p></a></li>
<li><a href='#prelim_AM'><p>Preliminary Assessments in MSE</p></a></li>
<li><a href='#Probs'><p>Calculates mahalanobis distance and rejection of the Null operating model</p></a></li>
<li><a href='#prof-class'><p>Class-<code>prof</code></p></a></li>
<li><a href='#profile,Assessment-method'><p>Profile likelihood of assessment models</p></a></li>
<li><a href='#project-class'><p>Class-<code>project</code></p></a></li>
<li><a href='#projection'><p>Projections for assessment models</p></a></li>
<li><a href='#RCM_assess'><p>The rapid conditioning model as an assessment function</p></a></li>
<li><a href='#RCM2MOM'><p>Convert RCM to a multi-fleet operating model (MOM)</p></a></li>
<li><a href='#RCMdata-class'><p>Class-<code>RCMdata</code></p></a></li>
<li><a href='#RCModel-class'><p>Class-<code>RCModel</code></p></a></li>
<li><a href='#retro-class'><p>Class-<code>retro</code></p></a></li>
<li><a href='#retrospective'><p>Retrospective analysis of assessment models</p></a></li>
<li><a href='#retrospective_AM'><p>retrospective_AM (retrospective of Assessment model in MSE)</p></a></li>
<li><a href='#SAMtool-package'><p>Stock Assessment Methods Toolkit</p></a></li>
<li><a href='#SCA'><p>Statistical catch-at-age (SCA) model</p></a></li>
<li><a href='#SCA_CAL'><p>Age-structured model using fishery length composition</p></a></li>
<li><a href='#SCA_DDM'><p>SCA models with time-varying natural mortality</p></a></li>
<li><a href='#SCA_RWM'><p>SCA with random walk in M</p></a></li>
<li><a href='#Shortcut'><p>Assessment emulator as a shortcut to model fitting in closed-loop simulation</p></a></li>
<li><a href='#sim-class'><p>Class-<code>sim</code></p></a></li>
<li><a href='#simulate'><p>Generate simulated data from TMB models in SAMtool</p></a></li>
<li><a href='#SP'><p>Surplus production model with FMSY and MSY as leading parameters</p></a></li>
<li><a href='#SP_production'><p>Find the production parameter based on depletion that produces MSY</p></a></li>
<li><a href='#SSS'><p>Simple Stock Synthesis</p></a></li>
<li><a href='#summary.Assessment'><p>Summary of Assessment object</p></a></li>
<li><a href='#swordfish'><p>North Atlantic Swordfish dataset</p></a></li>
<li><a href='#TAC_MSY'><p>Calculate MSY-based TAC from Assessment object</p></a></li>
<li><a href='#userguide'><p>Get the SAMtool vignettes</p></a></li>
<li><a href='#VPA'><p>Virtual population analysis (VPA)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Stock Assessment Methods Toolkit</td>
</tr>
<tr>
<td>Version:</td>
<td>1.6.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-12</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Quang Huynh &lt;quang@bluematterscience.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Simulation tools for closed-loop simulation are provided for the 'MSEtool' operating model to inform data-rich fisheries. 
  'SAMtool' provides a conditioning model, assessment models of varying complexity with standardized reporting, 
  model-based management procedures, and diagnostic tools for evaluating assessments inside closed-loop simulation.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), MSEtool (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>TMB (&ge; 1.9.0), abind, dplyr, gplots, graphics, methods,
pbapply, rmarkdown, snowfall, stats, utils, vars</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>TMB, RcppEigen</td>
</tr>
<tr>
<td>Suggests:</td>
<td>caret, corpcor, covr, extraDistr, ggplot2, Gmisc, knitr,
mvtnorm, numDeriv, reshape2, shiny, testthat, tmbstan, usethis</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://openmse.com">https://openmse.com</a>, <a href="https://samtool.openmse.com">https://samtool.openmse.com</a>,
<a href="https://github.com/Blue-Matter/SAMtool">https://github.com/Blue-Matter/SAMtool</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Blue-Matter/SAMtool/issues">https://github.com/Blue-Matter/SAMtool/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-15 01:42:20 UTC; qhuynh</td>
</tr>
<tr>
<td>Author:</td>
<td>Quang Huynh [aut, cre],
  Tom Carruthers [aut],
  Adrian Hordyk [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-15 20:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='Assessment-class'>Class-<code>Assessment</code></h2><span id='topic+Assessment-class'></span><span id='topic+Assessment'></span>

<h3>Description</h3>

<p>An S4 class that contains assessment output. Created from a function of class <code>Assess</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>Model</code></dt><dd><p>Name of the assessment model.</p>
</dd>
<dt><code>Name</code></dt><dd><p>Name of Data object.</p>
</dd>
<dt><code>conv</code></dt><dd><p>Logical. Whether the assessment model converged (defined by whether TMB returned a
positive-definite covariance matrix for the model).</p>
</dd>
<dt><code>UMSY</code></dt><dd><p>Estimate of exploitation at maximum sustainable yield.</p>
</dd>
<dt><code>FMSY</code></dt><dd><p>Estimate of instantaneous fishing mortality rate at maximum sustainable yield.</p>
</dd>
<dt><code>MSY</code></dt><dd><p>Estimate of maximum sustainable yield.</p>
</dd>
<dt><code>BMSY</code></dt><dd><p>Biomass at maximum sustainable yield.</p>
</dd>
<dt><code>SSBMSY</code></dt><dd><p>Spawning stock biomass at maximum sustainable yield.</p>
</dd>
<dt><code>VBMSY</code></dt><dd><p>Vulnerable biomass at maximum sustainable yield.</p>
</dd>
<dt><code>B0</code></dt><dd><p>Biomass at unfished equilibrium.</p>
</dd>
<dt><code>R0</code></dt><dd><p>Recruitment at unfished equilibrium.</p>
</dd>
<dt><code>N0</code></dt><dd><p>Abundance at unfished equilibrium.</p>
</dd>
<dt><code>SSB0</code></dt><dd><p>Spawning stock biomass at unfished equilibrium.</p>
</dd>
<dt><code>VB0</code></dt><dd><p>Vulnerable biomass at unfished equilibrium.</p>
</dd>
<dt><code>h</code></dt><dd><p>Steepness.</p>
</dd>
<dt><code>U</code></dt><dd><p>Time series of exploitation.</p>
</dd>
<dt><code>U_UMSY</code></dt><dd><p>Time series of relative exploitation.</p>
</dd>
<dt><code>FMort</code></dt><dd><p>Time series of instantaneous fishing mortality.</p>
</dd>
<dt><code>F_FMSY</code></dt><dd><p>Time series of fishing mortality relative to MSY.</p>
</dd>
<dt><code>B</code></dt><dd><p>Time series of biomass.</p>
</dd>
<dt><code>B_BMSY</code></dt><dd><p>Time series of biomass relative to MSY.</p>
</dd>
<dt><code>B_B0</code></dt><dd><p>Time series of depletion.</p>
</dd>
<dt><code>SSB</code></dt><dd><p>Time series of spawning stock biomass.</p>
</dd>
<dt><code>SSB_SSBMSY</code></dt><dd><p>Time series of spawning stock biomass relative to MSY.</p>
</dd>
<dt><code>SSB_SSB0</code></dt><dd><p>Time series of spawning stock depletion.</p>
</dd>
<dt><code>VB</code></dt><dd><p>Time series of vulnerable biomass.</p>
</dd>
<dt><code>VB_VBMSY</code></dt><dd><p>Time series of vulnerable biomass relative to MSY.</p>
</dd>
<dt><code>VB_VB0</code></dt><dd><p>Time series of vulnerable biomass depletion.</p>
</dd>
<dt><code>R</code></dt><dd><p>Time series of recruitment.</p>
</dd>
<dt><code>N</code></dt><dd><p>Time series of population abundance.</p>
</dd>
<dt><code>N_at_age</code></dt><dd><p>Time series of numbers-at-age matrix.</p>
</dd>
<dt><code>Selectivity</code></dt><dd><p>Selectivity-at-age matrix.</p>
</dd>
<dt><code>Obs_Catch</code></dt><dd><p>Observed catch.</p>
</dd>
<dt><code>Obs_Index</code></dt><dd><p>Observed index.</p>
</dd>
<dt><code>Obs_C_at_age</code></dt><dd><p>Observed catch-at-age matrix.</p>
</dd>
<dt><code>Catch</code></dt><dd><p>Predicted catch.</p>
</dd>
<dt><code>Index</code></dt><dd><p>Predicted index.</p>
</dd>
<dt><code>C_at_age</code></dt><dd><p>Predicted catch-at-age matrix.</p>
</dd>
<dt><code>Dev</code></dt><dd><p>A vector of estimated deviation parameters.</p>
</dd>
<dt><code>Dev_type</code></dt><dd><p>A description of the deviation parameters, e.g. &quot;log recruitment deviations&quot;.</p>
</dd>
<dt><code>NLL</code></dt><dd><p>Negative log-likelihood. A vector for the total likelihood, integrated across random effects if applicable, components,
and penalty term (applied when <code>U &gt; 0.975</code> in any year).</p>
</dd>
<dt><code>SE_UMSY</code></dt><dd><p>Standard error of UMSY estimate.</p>
</dd>
<dt><code>SE_FMSY</code></dt><dd><p>Standard error of FMSY estimate.</p>
</dd>
<dt><code>SE_MSY</code></dt><dd><p>Standard error of MSY estimate.</p>
</dd>
<dt><code>SE_U_UMSY</code></dt><dd><p>Standard error of U/UMSY.</p>
</dd>
<dt><code>SE_F_FMSY</code></dt><dd><p>Standard error of F/FMSY.</p>
</dd>
<dt><code>SE_B_BMSY</code></dt><dd><p>Standard error of B/BMSY.</p>
</dd>
<dt><code>SE_B_B0</code></dt><dd><p>Standard error of B/B0.</p>
</dd>
<dt><code>SE_SSB_SSBMSY</code></dt><dd><p>Standard error of SSB/SSBMSY.</p>
</dd>
<dt><code>SE_SSB_SSB0</code></dt><dd><p>Standard error of SSB/SSB0.</p>
</dd>
<dt><code>SE_VB_VBMSY</code></dt><dd><p>Standard error of VB/VBMSY.</p>
</dd>
<dt><code>SE_VB_VB0</code></dt><dd><p>Standard error of VB/VB0.</p>
</dd>
<dt><code>SE_Dev</code></dt><dd><p>A vector of standard errors of the deviation parameters.</p>
</dd>
<dt><code>info</code></dt><dd><p>A list containing the data and starting values of estimated parameters
for the assessment.</p>
</dd>
<dt><code>forecast</code></dt><dd><p>A list containing components for forecasting:
</p>

<ul>
<li> <p><code>per_recruit</code> A data frame of SPR (spawning potential ratio) and YPR (yield-per-recruit), calculated for
a range of exploitation rate of 0 - 0.99 or instantaneous F from 0 - 2.5 FMSY.
</p>
</li>
<li> <p><code>catch_eq</code> A function that calculates the catch for the next year (after the model terminal year) when an
apical F is provided.
</p>
</li></ul>
</dd>
<dt><code>obj</code></dt><dd><p>A list with components returned from <code><a href="TMB.html#topic+MakeADFun">TMB::MakeADFun()</a></code>.</p>
</dd>
<dt><code>opt</code></dt><dd><p>A list with components from calling <code><a href="stats.html#topic+nlminb">stats::nlminb()</a></code> to <code>obj</code>.</p>
</dd>
<dt><code>SD</code></dt><dd><p>A list (class sdreport) with parameter estimates and their standard errors, obtained from
<code><a href="TMB.html#topic+sdreport">TMB::sdreport()</a></code>.</p>
</dd>
<dt><code>TMB_report</code></dt><dd><p>A list of model output reported from the TMB executable, i.e. <code>obj$report()</code>, and derived quantities (e.g. MSY).</p>
</dd>
<dt><code>dependencies</code></dt><dd><p>A character string of data types required for the assessment.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Q. Huynh
</p>


<h3>See Also</h3>

<p><a href="#topic+plot.Assessment">plot.Assessment</a> <a href="#topic+summary.Assessment">summary.Assessment</a> <a href="#topic+retrospective">retrospective</a> <a href="#topic+profile">profile</a> <a href="#topic+make_MP">make_MP</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
output &lt;- DD_TMB(Data = MSEtool::SimulatedData)
class(output)

</code></pre>

<hr>
<h2 id='cDD'>Continuous Delay-differential assessment model</h2><span id='topic+cDD'></span><span id='topic+cDD_SS'></span>

<h3>Description</h3>

<p>A catch and index-based assessment model. Compared to the discrete delay-difference (annual time-step in production and fishing), the
delay-differential model (cDD) is based on continuous recruitment and fishing mortality within a time-step. The continuous model works
much better for populations with high turnover (e.g. high F or M, continuous reproduction). This model is conditioned on catch and fits
to the observed index. In the state-space version (cDD_SS), recruitment deviations from the stock-recruit relationship are estimated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cDD(
  x = 1,
  Data,
  AddInd = "B",
  SR = c("BH", "Ricker"),
  rescale = "mean1",
  MW = FALSE,
  start = NULL,
  prior = list(),
  fix_h = TRUE,
  dep = 1,
  LWT = list(),
  n_itF = 5L,
  silent = TRUE,
  opt_hess = FALSE,
  n_restart = ifelse(opt_hess, 0, 1),
  control = list(iter.max = 5000, eval.max = 10000),
  ...
)

cDD_SS(
  x = 1,
  Data,
  AddInd = "B",
  SR = c("BH", "Ricker"),
  rescale = "mean1",
  MW = FALSE,
  start = NULL,
  prior = list(),
  fix_h = TRUE,
  fix_sigma = FALSE,
  fix_tau = TRUE,
  dep = 1,
  LWT = list(),
  n_itF = 5L,
  integrate = FALSE,
  silent = TRUE,
  opt_hess = FALSE,
  n_restart = ifelse(opt_hess, 0, 1),
  control = list(iter.max = 5000, eval.max = 10000),
  inner.control = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cDD_+3A_x">x</code></td>
<td>
<p>An index for the objects in <code>Data</code> when running in closed loop simulation.
Otherwise, equals to 1 when running an assessment.</p>
</td></tr>
<tr><td><code id="cDD_+3A_data">Data</code></td>
<td>
<p>An object of class Data.</p>
</td></tr>
<tr><td><code id="cDD_+3A_addind">AddInd</code></td>
<td>
<p>A vector of integers or character strings indicating the indices to be used in the model. Integers assign the index to
the corresponding index in Data@AddInd, &quot;B&quot; (or 0) represents total biomass in Data@Ind, &quot;VB&quot; represents vulnerable biomass in
Data@VInd, and &quot;SSB&quot; represents spawning stock biomass in Data@SpInd.</p>
</td></tr>
<tr><td><code id="cDD_+3A_sr">SR</code></td>
<td>
<p>Stock-recruit function (either <code>"BH"</code> for Beverton-Holt or <code>"Ricker"</code>).</p>
</td></tr>
<tr><td><code id="cDD_+3A_rescale">rescale</code></td>
<td>
<p>A multiplicative factor that rescales the catch in the assessment model, which
can improve convergence. By default, <code>"mean1"</code> scales the catch so that time series mean is 1, otherwise a numeric.
Output is re-converted back to original units.</p>
</td></tr>
<tr><td><code id="cDD_+3A_mw">MW</code></td>
<td>
<p>Logical, whether to fit to mean weight. In closed-loop simulation, mean weight will be grabbed from <code>Data@Misc[[x]]$MW</code>,
otherwise calculated from <code>Data@CAL</code>.</p>
</td></tr>
<tr><td><code id="cDD_+3A_start">start</code></td>
<td>
<p>Optional list of starting values. Entries can be expressions that are evaluated in the function. See details.</p>
</td></tr>
<tr><td><code id="cDD_+3A_prior">prior</code></td>
<td>
<p>A named list for the parameters of any priors to be added to the model. See below.</p>
</td></tr>
<tr><td><code id="cDD_+3A_fix_h">fix_h</code></td>
<td>
<p>Logical, whether to fix steepness to value in <code>Data@steep</code> in the assessment model.</p>
</td></tr>
<tr><td><code id="cDD_+3A_dep">dep</code></td>
<td>
<p>The initial depletion in the first year of the model. A tight prior is placed on the model objective function
to estimate the equilibrium fishing mortality corresponding to the initial depletion. Due to this tight prior, this F
should not be considered to be an independent model parameter. Set to zero to eliminate this prior.</p>
</td></tr>
<tr><td><code id="cDD_+3A_lwt">LWT</code></td>
<td>
<p>A named list of likelihood weights. For <code>LWT$Index</code>, a vector of likelihood weights for each survey, while
for <code>LWT$MW</code> a numeric.</p>
</td></tr>
<tr><td><code id="cDD_+3A_n_itf">n_itF</code></td>
<td>
<p>Integer, the number of iterations to solve F conditional on the observed catch.</p>
</td></tr>
<tr><td><code id="cDD_+3A_silent">silent</code></td>
<td>
<p>Logical, passed to <code><a href="TMB.html#topic+MakeADFun">TMB::MakeADFun()</a></code>, whether TMB
will print trace information during optimization. Used for diagnostics for model convergence.</p>
</td></tr>
<tr><td><code id="cDD_+3A_opt_hess">opt_hess</code></td>
<td>
<p>Logical, whether the hessian function will be passed to <code><a href="stats.html#topic+nlminb">stats::nlminb()</a></code> during optimization
(this generally reduces the number of iterations to convergence, but is memory and time intensive and does not guarantee an increase
in convergence rate). Ignored if <code>integrate = TRUE</code>.</p>
</td></tr>
<tr><td><code id="cDD_+3A_n_restart">n_restart</code></td>
<td>
<p>The number of restarts (calls to <code><a href="stats.html#topic+nlminb">stats::nlminb()</a></code>) in the optimization procedure, so long as the model
hasn't converged. The optimization continues from the parameters from the previous (re)start.</p>
</td></tr>
<tr><td><code id="cDD_+3A_control">control</code></td>
<td>
<p>A named list of parameters regarding optimization to be passed to
<code><a href="stats.html#topic+nlminb">stats::nlminb()</a></code>.</p>
</td></tr>
<tr><td><code id="cDD_+3A_...">...</code></td>
<td>
<p>Additional arguments (not currently used).</p>
</td></tr>
<tr><td><code id="cDD_+3A_fix_sigma">fix_sigma</code></td>
<td>
<p>Logical, whether the standard deviation of the index is fixed. If <code>TRUE</code>,
sigma is fixed to value provided in <code>start</code> (if provided), otherwise, value based on <code>Data@CV_Ind</code>.</p>
</td></tr>
<tr><td><code id="cDD_+3A_fix_tau">fix_tau</code></td>
<td>
<p>Logical, the standard deviation of the recruitment deviations is fixed. If <code>TRUE</code>,
tau is fixed to value provided in <code>start</code> (if provided), otherwise, equal to 1.</p>
</td></tr>
<tr><td><code id="cDD_+3A_integrate">integrate</code></td>
<td>
<p>Logical, whether the likelihood of the model integrates over the likelihood
of the recruitment deviations (thus, treating it as a state-space variable). Otherwise, recruitment deviations are penalized parameters.</p>
</td></tr>
<tr><td><code id="cDD_+3A_inner.control">inner.control</code></td>
<td>
<p>A named list of arguments for optimization of the random effects, which
is passed on to <code><a href="TMB.html#topic+newton">TMB::newton()</a></code> via <code><a href="TMB.html#topic+MakeADFun">TMB::MakeADFun()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>start</code> (optional), a named list of starting values of estimates can be provided for:
</p>

<ul>
<li> <p><code>R0</code> Unfished recruitment. Otherwise, <code>Data@OM$R0[x]</code> is used in closed-loop, and 400% of mean catch otherwise.
</p>
</li>
<li> <p><code>h</code> Steepness. Otherwise, <code>Data@steep[x]</code> is used, or 0.9 if empty.
</p>
</li>
<li> <p><code>Kappa</code> Delay-differential Kappa parameter. Otherwise, calculated from biological parameters in the Data object.
</p>
</li>
<li> <p><code>F_equilibrium</code> Equilibrium fishing mortality leading into first year of the model (to determine initial depletion). By default, 0.
</p>
</li>
<li> <p><code>tau</code> Lognormal SD of the recruitment deviations (process error) for <code>DD_SS</code>. By default, <code>Data@sigmaR[x]</code>.
</p>
</li>
<li> <p><code>sigma</code> Lognormal SD of the index (observation error). By default, <code>Data@CV_Ind[x]</code>. Not
used if multiple indices are used.
</p>
</li>
<li> <p><code>sigma_W</code> Lognormal SD of the mean weight (observation error). By default, 0.1.
</p>
</li></ul>

<p>Multiple indices are supported in the model. Data@Ind, Data@VInd, and Data@SpInd are all assumed to be biomass-based.
For Data@AddInd, Data@I_units are used to identify a biomass vs. abundance-based index.
</p>


<h3>Value</h3>

<p>An object of <a href="#topic+Assessment-class">Assessment</a> containing objects and output
from TMB.
</p>


<h3>Priors</h3>

<p>The following priors can be added as a named list, e.g., <code style="white-space: pre;">&#8288;prior = list(M = c(0.25, 0.15), h = c(0.7, 0.1)&#8288;</code>.
For each parameter below, provide a vector of values as described:
</p>

<ul>
<li> <p><code>R0</code> - A vector of length 3. The first value indicates the distribution of the prior: <code>1</code> for lognormal, <code>2</code> for uniform
on <code>log(R0)</code>, <code>3</code> for uniform on R0. If lognormal, the second and third values are the prior mean (in normal space) and SD (in log space).
Otherwise, the second and third values are the lower and upper bounds of the uniform distribution (values in normal space).
</p>
</li>
<li> <p><code>h</code> - A vector of length 2 for the prior mean and SD, both in normal space. Beverton-Holt steepness uses a beta distribution,
while Ricker steepness uses a normal distribution.
</p>
</li>
<li> <p><code>M</code> - A vector of length 2 for the prior mean (in normal space) and SD (in log space). Lognormal prior.
</p>
</li>
<li> <p><code>q</code> - A matrix for nsurvey rows and 2 columns. The first column is the prior mean (in normal space) and the second column
for the SD (in log space). Use <code>NA</code> in rows corresponding to indices without priors.
</p>
</li></ul>

<p>See online documentation for more details.
</p>


<h3>Online Documentation</h3>

<p>Model description and equations are available on the openMSE
<a href="https://openmse.com/features-assessment-models/1-dd/">website</a>.
</p>


<h3>Required Data</h3>


<ul>
<li> <p><code>cDD</code>: Cat, Ind, Mort, L50, vbK, vbLinf, vbt0, wla, wlb, MaxAge
</p>
</li>
<li> <p><code>cDD_SS</code>: Cat, Ind, Mort, L50, vbK, vbLinf, vbt0, wla, wlb, MaxAge
</p>
</li></ul>



<h3>Optional Data</h3>


<ul>
<li> <p><code>cDD</code>: steep
</p>
</li>
<li> <p><code>cDD_SS</code>: steep, CV_Ind, sigmaR
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Q. Huynh
</p>


<h3>References</h3>

<p>Hilborn, R., and Walters, C., 1992. Quantitative Fisheries Stock Assessment: Choice,
Dynamics and Uncertainty. Chapman and Hall, New York.
</p>


<h3>See Also</h3>

<p><a href="#topic+DD_TMB">DD_TMB</a> <a href="#topic+plot.Assessment">plot.Assessment</a> <a href="#topic+summary.Assessment">summary.Assessment</a> <a href="#topic+retrospective">retrospective</a> <a href="#topic+profile">profile</a> <a href="#topic+make_MP">make_MP</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### Observation-error delay difference model
res &lt;- cDD(Data = MSEtool::Red_snapper)

### State-space version
### Also set recruitment variability SD = 0.6 (since fix_tau = TRUE)
res &lt;- cDD_SS(Data = MSEtool::Red_snapper, start = list(tau = 0.6))

summary(res@SD) # Parameter estimates
</code></pre>

<hr>
<h2 id='check_RCMdata'>Rapid Conditioning Model (RCM)</h2><span id='topic+check_RCMdata'></span><span id='topic+RCM'></span><span id='topic+RCM+2COM+2Clist-method'></span><span id='topic+RCM+2COM+2CData-method'></span><span id='topic+RCM+2COM+2CRCMdata-method'></span>

<h3>Description</h3>

<p>Intended for conditioning operating models for MSEtool. For data-limited stocks, this function can generate a range of potential depletion scenarios inferred from sparse data.
From a historical time series of total catch or effort, and potentially age/length compositions and multiple indices of abundance, the RCM returns a range of values for depletion, selectivity,
unfished recruitment (R0), historical fishing effort, and recruitment deviations for the operating model. This is done by sampling life history parameters
provided by the user and fitting a statistical catch-at-age model (with the predicted catch equal to the observed catch).
Alternatively one can do a single model fit and sample the covariance matrix to generate an operating model with uncertainty based on the model fit.
Either a full catch (conditioned on catch) or effort (conditioned on effort) time series is needed but missing data (as NAs) are allowed for all other data types.
<code>check_RCMdata</code> evaluates whether the inputs in the S4 RCMdata object are correctly formatted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_RCMdata(RCMdata, OM, condition = "catch", silent = FALSE)

RCM(OM, data, ...)

## S4 method for signature 'OM,RCMdata'
RCM(
  OM,
  data,
  condition = "catch",
  selectivity = "logistic",
  s_selectivity = NULL,
  LWT = list(),
  comp_like = c("multinomial", "lognormal", "mvlogistic", "dirmult1", "dirmult2"),
  prior = list(),
  max_F = 3,
  cores = 1L,
  integrate = FALSE,
  mean_fit = FALSE,
  drop_nonconv = FALSE,
  drop_highF = FALSE,
  control = list(iter.max = 2e+05, eval.max = 4e+05),
  start = list(),
  map = list(),
  silent = FALSE,
  ...
)

## S4 method for signature 'OM,list'
RCM(
  OM,
  data,
  condition = "catch",
  selectivity = "logistic",
  s_selectivity = NULL,
  LWT = list(),
  comp_like = c("multinomial", "lognormal", "mvlogistic", "dirmult1", "dirmult2"),
  ESS = c(30, 30),
  prior = list(),
  max_F = 3,
  cores = 1L,
  integrate = FALSE,
  mean_fit = FALSE,
  drop_nonconv = FALSE,
  drop_highF = FALSE,
  control = list(iter.max = 2e+05, eval.max = 4e+05),
  start = list(),
  map = list(),
  silent = FALSE,
  ...
)

## S4 method for signature 'OM,Data'
RCM(
  OM,
  data,
  condition = "catch",
  selectivity = "logistic",
  s_selectivity = NULL,
  LWT = list(),
  comp_like = c("multinomial", "lognormal", "mvlogistic", "dirmult1", "dirmult2"),
  ESS = c(30, 30),
  prior = list(),
  max_F = 3,
  cores = 1L,
  integrate = FALSE,
  mean_fit = FALSE,
  drop_nonconv = FALSE,
  drop_highF = FALSE,
  control = list(iter.max = 2e+05, eval.max = 4e+05),
  start = list(),
  map = list(),
  silent = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_RCMdata_+3A_rcmdata">RCMdata</code></td>
<td>
<p>An <a href="#topic+RCMdata-class">RCMdata</a> object.</p>
</td></tr>
<tr><td><code id="check_RCMdata_+3A_om">OM</code></td>
<td>
<p>An object of class OM that specifies natural mortality (M), growth (Linf, K, t0, a, b), stock-recruitment relationship,
steepness, maturity parameters (L50 and L50_95), standard deviation of recruitment variability (Perr), as well as index uncertainty (Iobs).</p>
</td></tr>
<tr><td><code id="check_RCMdata_+3A_condition">condition</code></td>
<td>
<p>String to indicate whether the RCM is conditioned on &quot;catch&quot; (where F are estimated parameters), &quot;catch2&quot; (where F is solved internally using Newton's method),
or &quot;effort&quot; (F is proportional to an index series in <code>data@Ehist</code>. Can be fleet specific, in which case some combination of &quot;catch&quot; and &quot;effort&quot; are permissible.</p>
</td></tr>
<tr><td><code id="check_RCMdata_+3A_silent">silent</code></td>
<td>
<p>Logical to indicate whether informative messages will be reported to console.</p>
</td></tr>
<tr><td><code id="check_RCMdata_+3A_data">data</code></td>
<td>
<p>Data inputs formatted in a <a href="#topic+RCMdata-class">RCMdata</a> (preferred) or Data object.
Use of a list is deprecated. See Data section below.</p>
</td></tr>
<tr><td><code id="check_RCMdata_+3A_...">...</code></td>
<td>
<p>Other arguments to pass in for starting values of parameters and fixing parameters. See details.</p>
</td></tr>
<tr><td><code id="check_RCMdata_+3A_selectivity">selectivity</code></td>
<td>
<p>A character vector of length nfleet to indicate <code>"logistic_length"</code>, <code>"dome_length"</code>, <code>"logistic_age"</code>, <code>"dome_age"</code>, or <code>"free"</code> selectivity for each fleet in <code>Chist</code>.
If there is time-varying selectivity, this is a character vector of length nsel_block (see Data section below). &quot;free&quot; indicates independent selectivity parameters for each age,
and additional modifications for fixing selectivity parameters will likely be needed. See Additional arguments section.</p>
</td></tr>
<tr><td><code id="check_RCMdata_+3A_s_selectivity">s_selectivity</code></td>
<td>
<p>A vector of length nsurvey to indicate the selectivity of the corresponding columns in <code>data$Index</code>. Use <code>"B"</code> for
total biomass, or <code>"SSB"</code> for spawning biomass (by default, &quot;B&quot; is used). Use numbers if the survey selectivity follows a fleet (corresponding to the columns in data$Chist, e.g., 1 = first fleet/column and so on).
If the survey selectivity is otherwise independent of anything else in the model, use <code>"logistic_length"</code>, <code>"dome_length"</code>, <code>"logistic_age"</code>, <code>"dome_age"</code>, or <code>"free"</code> to specify the functional form of selectivity, and
see Additional arguments section for setup of survey selectivity parameters and Articles section for more information.</p>
</td></tr>
<tr><td><code id="check_RCMdata_+3A_lwt">LWT</code></td>
<td>
<p>A named list of likelihood weights for the RCM. See below.</p>
</td></tr>
<tr><td><code id="check_RCMdata_+3A_comp_like">comp_like</code></td>
<td>
<p>A string indicating the statistical distribution for the composition data, either <code>"multinomial"</code> (default), <code>"lognormal"</code>, <code>"mvlogistic"</code> (multivariate logistic),
<code>"dirmult1"</code> (Dirichlet multinomial, linear version), or <code>"dirmult2"</code> (saturating version; see Thorson et al. 2017).</p>
</td></tr>
<tr><td><code id="check_RCMdata_+3A_prior">prior</code></td>
<td>
<p>A named list for the parameters of any priors to be added to the model. See below.</p>
</td></tr>
<tr><td><code id="check_RCMdata_+3A_max_f">max_F</code></td>
<td>
<p>The maximum F for any fleet in the scoping model (higher F's in the model are penalized in the objective function). This argument will also update <code>OM@maxF</code>. See also <code>drop_highF</code>.</p>
</td></tr>
<tr><td><code id="check_RCMdata_+3A_cores">cores</code></td>
<td>
<p>Integer for the number of CPU cores (set greater than 1 for parallel processing).</p>
</td></tr>
<tr><td><code id="check_RCMdata_+3A_integrate">integrate</code></td>
<td>
<p>Logical, whether to treat recruitment deviations as penalized parameters in the likelihood (FALSE) or random effects to be marginalized out of the likelihood (TRUE).</p>
</td></tr>
<tr><td><code id="check_RCMdata_+3A_mean_fit">mean_fit</code></td>
<td>
<p>Logical, whether to run an additional with mean values of life history parameters from the OM.</p>
</td></tr>
<tr><td><code id="check_RCMdata_+3A_drop_nonconv">drop_nonconv</code></td>
<td>
<p>Logical, whether to drop non-converged fits of the RCM, including fits where F = NA.</p>
</td></tr>
<tr><td><code id="check_RCMdata_+3A_drop_highf">drop_highF</code></td>
<td>
<p>Logical, whether to drop fits of the RCM where F = <code>max_F</code>.</p>
</td></tr>
<tr><td><code id="check_RCMdata_+3A_control">control</code></td>
<td>
<p>A named list of arguments (e.g, max. iterations, etc.) for optimization, to be passed to the control argument of <code><a href="stats.html#topic+nlminb">stats::nlminb()</a></code>.</p>
</td></tr>
<tr><td><code id="check_RCMdata_+3A_start">start</code></td>
<td>
<p>A list of starting values for the TMB model. See details.</p>
</td></tr>
<tr><td><code id="check_RCMdata_+3A_map">map</code></td>
<td>
<p>A list of <code>map</code> argument to TMB models to override defaults. See <a href="TMB.html#topic+MakeADFun">MakeADFun</a> and details.</p>
</td></tr>
<tr><td><code id="check_RCMdata_+3A_ess">ESS</code></td>
<td>
<p>A vector of length two. A shortcut method to setting the maximum multinomial sample size of the age and length compositions.
Not used when data are provided in a <a href="#topic+RCMdata-class">RCMdata</a> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fleet selectivity is fixed to values sampled from <code>OM</code> if no age or length compositions are provided.
</p>
<p>Survey selectivity is estimable only if <code>IAA</code> or <code>IAL</code> is provided. Otherwise, the selectivity should
be mirrored to a fleet (vulnerable biomass selectivity) or indexed to total or spawning biomass (see <code>s_selectivity</code>).
</p>
<p>Parameters that were used in the fitting model are placed in the <code>RCM@OM@cpars</code> list.
</p>
<p>If the operating model <code>OM</code> uses time-varying growth or M, then those trends will be used in the RCM as well.
Non-stationary productivity creates ambiguity in the calculation and interpretation of depletion and MSY reference points.
</p>
<p>The easiest way to turn off time-varying growth/M is by setting: <code>OM@Msd &lt;- OM@Linfsd &lt;- OM@Ksd &lt;- c(0, 0)</code>.
</p>
<p>To play with alternative fits by excluding indices, for example, or other optional data, set the corresponding likelihood weight to zero. The model will still generate the inferred
index but the data won't enter the likelihood. See section on likelihood weights.
</p>


<h3>Value</h3>

<p>An object of class <a href="#topic+RCModel-class">RCModel</a> (see link for description of output).
</p>
<p><code>check_RCMdata</code> returns a list of updated RCMdata object, OM, and StockPars and FleetPars from the Hist object generated
from the OM.
</p>


<h3>Priors</h3>

<p>The following priors can be added as a named list, e.g., <code style="white-space: pre;">&#8288;prior = list(M = c(0.25, 0.15), h = c(0.7, 0.1)&#8288;</code>.
For each parameter below, provide a vector of values as described:
</p>

<dl>
<dt><code>R0</code></dt><dd><p>A vector of length 3. The first value indicates the distribution of the prior: <code>1</code> for lognormal, <code>2</code> for uniform
on <code>log(R0)</code>, <code>3</code> for uniform on R0. If lognormal, the second and third values are the prior mean (in normal space) and SD (in log space).
Otherwise, the second and third values are the lower and upper bounds of the uniform distribution (values in normal space).</p>
</dd>
<dt><code>h</code></dt><dd><p>A vector of length 2 for the prior mean and SD, both in normal space. Beverton-Holt steepness uses a beta distribution,
while Ricker steepness uses a normal distribution.</p>
</dd>
<dt><code>M</code></dt><dd><p>A vector of length 2 for the prior mean (in normal space) and SD (in log space). Lognormal prior.</p>
</dd>
<dt><code>q</code></dt><dd><p>A matrix for nsurvey rows and 2 columns. The first column is the prior mean (in normal space) and the second column
for the SD (in log space). Use <code>NA</code> in rows corresponding to indices without priors.</p>
</dd>
</dl>

<p>See online documentation for more details.
</p>


<h3>Online Documentation</h3>

<p>Several articles are available for RCM:
</p>

<ul>
<li> <p><a href="https://openmse.com/tutorial-rcm/">General overview of approach</a>
</p>
</li>
<li> <p><a href="https://openmse.com/tutorial-rcm-eq/">Mathematical description</a>
</p>
</li>
<li> <p><a href="https://openmse.com/tutorial-rcm-select/">Setup of selectivity settings and index catchability</a> (useful for more data-rich cases)
</p>
</li>
<li> <p><a href="https://openmse.com/features-assessment-models/5-priors/">Description of priors</a>
</p>
</li></ul>



<h3>Data</h3>

<p>One of indices, age compositions, or length compositions should be provided in addition to the historical catch or effort. Not all arguments
are needed to run the model (some have defaults, while others are ignored if not applicable depending on the data provided).
</p>
<p>The <code>data</code> variable can be an object of class <a href="#topic+RCMdata-class">RCMdata</a>. See help file for description of inputs.
</p>
<p>Alternatively, the <code>data</code> input can be a Data S4 object which will retrieve data from the following slots:
</p>

<dl>
<dt><code>Data@Cat</code></dt><dd><p>catch series (single fleet with the Data S4 object)</p>
</dd>
<dt><code>Data@Effort</code></dt><dd><p>effort series</p>
</dd>
<dt><code>Data@CAA</code></dt><dd><p>fishery age composition</p>
</dd>
<dt><code>Data@CAL</code>, <code>Data@CAL_mids</code></dt><dd><p>fishery length composition and corresponding length bins</p>
</dd>
<dt><code>Data@Ind</code>, <code>Data@SpInd</code>, <code>Data@VInd</code>, <code>Data@AddInd</code></dt><dd><p>indices of abundance</p>
</dd>
<dt><code>Data@CV_Ind</code>, <code>Data@CV_SpInd</code>, <code>Data@CV_VInd</code>, <code>Data@CV_AddInd</code></dt><dd><p>annual coefficients of variation for the corresponding indices
of abundance. CVs will be converted to lognormal standard deviations.</p>
</dd>
<dt><code>Data@ML</code></dt><dd><p>fishery mean lengths</p>
</dd>
<dt><code>Data@AddIndV</code>, <code>Data@AddIndType</code>, <code>Data@AddIunits</code></dt><dd><p>Additional information for indices in <code>Data@AddInd</code>:
selectivity and units (i.e., biomass or abundance).</p>
</dd>
</dl>

<p>There is no slot in the Data S4 object for the equilibrium catch/effort. These can be passed directly in the function call, i.e., <code>RCM(OM, Data, C_eq = C_eq, ...)</code>.
</p>


<h3>Data list</h3>

<p>Use of a list is deprecated. For backwards compatibility, here is the list of supported entries:
</p>

<dl>
<dt><code>Chist</code></dt><dd><p>A vector of historical catch, should be of length OM@nyears. If there are multiple fleets: a matrix of <code>OM@nyears</code> rows and <code>nfleet</code> columns.
Ideally, the first year of the catch series represents unfished conditions (see also <code>C_eq</code>).</p>
</dd>
<dt><code>C_sd</code></dt><dd><p>A vector or matrix of standard deviations (lognormal distribution) for the catches in <code>Chist</code>.
If not provided, the default is 0.01. Only used if <code>condition = "catch"</code>.</p>
</dd>
<dt><code>Ehist</code></dt><dd><p>A vector of historical effort, should be of length <code>OM@nyears</code> (see also <code>E_eq</code>).</p>
</dd>
<dt><code>Index</code></dt><dd><p>A vector of values of an index (of length <code>OM@nyears</code>). If there are multiple indices: a matrix of historical indices of abundances, with rows
indexing years and columns indexing the index.</p>
</dd>
<dt><code>I_sd</code></dt><dd><p>A vector or matrix of standard deviations (lognormal distribution) for the indices corresponding to the entries in <code>Index</code>.
If not provided, this function will use values from <code>OM@Iobs</code>.</p>
</dd>
<dt><code>I_type</code></dt><dd><p>Obsolete as of version 2.0. See <code>s_selectivity</code> argument.</p>
</dd>
<dt><code>CAA</code></dt><dd><p>Fishery age composition matrix with <code>nyears</code> rows and <code>OM@maxage+1</code> columns. If multiple fleets: an array with dimension:
<code style="white-space: pre;">&#8288;nyears, OM@maxage, and nfleet&#8288;</code>.</p>
</dd>
<dt><code>CAL</code></dt><dd><p>Fishery length composition matrix with nyears rows and columns indexing the length bin. If multiple fleets:
an array with dimension: <code style="white-space: pre;">&#8288;nyears, length bins, and nfleet&#8288;</code>.</p>
</dd>
<dt><code>MS</code></dt><dd><p>A vector of fishery mean size (MS, either mean length or mean weight) observations (length <code>OM@nyears</code>),
or if multiple fleets: matrix of dimension: <code style="white-space: pre;">&#8288;nyears, nfleet&#8288;</code>.
Generally, mean lengths should not be used if <code>CAL</code> is also provided, unless mean length and length comps are independently sampled.</p>
</dd>
<dt><code>MS_type</code></dt><dd><p>A character (either <code>"length"</code> (default) or <code>"weight"</code>) to denote the type of mean size data.</p>
</dd>
<dt><code>MS_cv</code></dt><dd><p>The coefficient of variation of the observed mean size. If there are multiple fleets, a vector of length <code>nfleet</code>.
Default is 0.2.</p>
</dd>
<dt><code>s_CAA</code></dt><dd><p>Survey age composition data, an array of dimension <code style="white-space: pre;">&#8288;nyears, maxage+1, nsurvey&#8288;</code>.</p>
</dd>
<dt><code>s_CAL</code></dt><dd><p>Survey length composition data, an array of dimension <code style="white-space: pre;">&#8288;nyears, length(length_bin), nsurvey&#8288;</code>.</p>
</dd>
<dt><code>length_bin</code></dt><dd><p>A vector for the midpoints of the length bins for <code>CAL</code> and <code>s_CAL</code>. All bin widths should be equal in size.</p>
</dd>
<dt><code>C_eq</code></dt><dd><p>A numeric vector of length <code>nfleet</code> for the equilibrium catch for each fleet in <code>Chist</code> prior to the first year of the operating model.
Zero (default) implies unfished conditions in year one. Otherwise, this is used to estimate depletion in the first year of the data. Alternatively,
if one has a full CAA matrix, one could instead estimate &quot;artificial&quot; rec devs to generate the initial numbers-at-age (and hence initial
depletion) in the first year of the model (see additional arguments).</p>
</dd>
<dt><code>C_eq_sd</code></dt><dd><p>A vector of standard deviations (lognormal distribution) for the equilibrium catches in <code>C_eq</code>.
If not provided, the default is 0.01. Only used if <code>condition = "catch"</code>.</p>
</dd>
<dt><code>E_eq</code></dt><dd><p>The equilibrium effort for each fleet in <code>Ehist</code> prior to the first year of the operating model.
Zero (default) implies unfished conditions in year one. Otherwise, this is used to estimate depletion in the first year of the data.</p>
</dd>
<dt><code>abs_I</code></dt><dd><p>Optional, an integer vector to indicate which indices are in absolute magnitude. Use 1 to set <code>q = 1</code>,
otherwise use 0 to estimate q.</p>
</dd>
<dt><code>I_units</code></dt><dd><p>Optional, an integer vector to indicate whether indices are biomass based (1) or abundance-based (0).
By default, all are biomass-based.</p>
</dd>
<dt><code>age_error</code></dt><dd><p>Optional, a square matrix of maxage + 1 rows and columns to specify ageing error. The aa-th column
assigns a proportion of the true age in the a-th row to observed age. Thus, all rows should sum to 1.
Default is an identity matrix (no ageing error).</p>
</dd>
<dt><code>sel_block</code></dt><dd><p>Optional, for time-varying fleet selectivity (in time blocks), a integer matrix of <code>nyears</code> rows and <code>nfleet</code> columns
to assigns a selectivity function to a fleet for certain years.</p>
</dd>
</dl>



<h3>Additional arguments</h3>

<p>For <code>RCM</code>, additional arguments can be passed to the model via <code>...</code>:
</p>

<dl>
<dt><code>plusgroup</code></dt><dd><p>Logical for whether the maximum age is a plusgroup or not. By default, TRUE.</p>
</dd>
<dt><code>fix_dome</code></dt><dd><p>Logical for whether the dome selectivity parameter for fleets is fixed. Used primarily for backwards compatibility,
this is overridden by the <code>map</code> argument.</p>
</dd>
<dt><code>resample</code></dt><dd><p>Logical, whether the OM conditioning parameters (recruitment, fishing mortality, SSB, selectivity, etc.) are obtained by sampling the Hessian matrix from
a single model fit. By default FALSE. This feature requires identical biological parameters among simulations.</p>
</dd>
</dl>



<h3>start</h3>

<p>Starting values can be specified in a named list for the following:
</p>

<dl>
<dt><code>vul_par</code></dt><dd><p>A matrix of 3 rows and nfleet columns for starting values for fleet selectivity. The three rows correspond
to LFS (length of full selectivity), L5 (length of 5 percent selectivity), and Vmaxlen (selectivity at length Linf). By default,
the starting values are values from the OM object. If any <code>selectivity = "free"</code>, then this matrix needs to be of <code>maxage+1</code> rows where
the row specifies the selectivity at age. See Articles section.</p>
</dd>
<dt><code>ivul_par</code></dt><dd><p>A matrix of 3 rows and nsurvey columns for starting values for fleet selectivity. Same setup as <code>vul_par</code>. Values in the column are ignored
if <code>s_selectivity</code> is mapped to a fishing fleet (add NA placeholders in that case).
If any <code>s_selectivity = "free"</code>, then this matrix needs to be of <code>maxage+1</code> rows where
the row specifies the selectivity at age.</p>
</dd>
<dt><code>log_rec_dev</code></dt><dd><p>A numeric vector of length <code>nyears</code> for the starting values of the log-recruitment deviations.</p>
</dd>
<dt><code>log_early_rec_dev</code></dt><dd><p>A numeric vector of length <code>OM@maxage</code> for the starting values of the recruitment deviations controlling the abundance-at-age in the first year of the model.</p>
</dd>
<dt><code>q</code></dt><dd><p>A numeric vector of length nsurvey for index catchability. See <a href="https://openmse.com/tutorial-rcm-select/">online article</a> for more information.</p>
</dd>
</dl>



<h3>map</h3>

<p>Parameters can be fixed with the map argument (also a named list, corresponding to the start list). Each
vector or matrix in the map argument will be the same dimension as in the start entry. If an entry is <code>NA</code>, the corresponding parameter is fixed in the model to the starting
value. Otherwise, an integer for each independent parameter, i.e., shared or mirrored parameters get the same integer entry.
</p>

<dl>
<dt><code>vul_par</code></dt><dd><p>An integer matrix of the same dimension as <code>start$vul_par</code>. By default, selectivity is fixed if there are no age or length composition for that fleet
or survey, otherwise estimated. Unused cells in the <code>start$vul_par</code> matrix should be given NA in the map matrix.</p>
</dd>
<dt><code>ivul_par</code></dt><dd><p>The map argument for the survey selectivity parameters (same dimension as <code>start$ivul_par</code>). Placeholder parameters should have a map value of NA.</p>
</dd>
<dt><code>log_early_rec_dev</code></dt><dd><p>A vector of length <code>OM@maxage</code> that indexes which recruitment deviates for the cohorts in the first year of the model are fixed (using NA) or estimated (a separate integer).
By default, no deviates are estimated (all are NA).</p>
</dd>
<dt><code>log_rec_dev</code></dt><dd><p>A vector of length <code>OM@nyears</code> that indexes which recruitment deviates are fixed (using NA) or estimated (a separate integer).
By default, all these deviates are estimated.</p>
</dd>
<dt><code>q</code></dt><dd><p>A vector of length <code>nsurvey</code> for index catchability. q should be an estimated parameter when sharing across surveys (perhaps with differing selectivity). Otherwise, it is solved analytically
where individual parameters are independent of other indices. Use <code>RCMdata@abs_I</code> for fixing the catchability to 1. See <a href="https://openmse.com/tutorial-rcm-select/">online article</a> for more information.</p>
</dd>
</dl>



<h3>Likelihood weights</h3>

<p><code>LWT</code> is an optional named list containing the likelihood weights (values &gt;= 0) with the possible options:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;Chist, CAA, CAL, MS, C_eq&#8288;</code>: A vector of length nfleet for each.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;Index, IAA, IAL&#8288;</code>: A vector of length nsurvey for each.
</p>
</li></ul>

<p>By default, all likelihood weights are equal to one if not specified by the user.
</p>
<p>Annual multinomial sample sizes for the age and length comps can now be provided directly in the
<a href="#topic+RCMdata-class">RCMdata</a> object. For a list or Data object, use the <code>ESS</code> argument.
</p>


<h3>Author(s)</h3>

<p>Q. Huynh
</p>


<h3>References</h3>

<p>Thorson et al. 2017. Model-based estimates of effective sample size in stock assessment models using the Dirichlet-multinomial distribution.
Fish. Res. 192:84-93. <a href="https://doi.org/10.1016/j.fishres.2016.06.005">doi:10.1016/j.fishres.2016.06.005</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+plot.RCModel">plot.RCModel</a> <a href="#topic+RCModel-class">RCModel</a> <a href="#topic+compare_RCM">compare_RCM</a> <a href="#topic+pcod">pcod</a> <a href="#topic+RCM2MOM">RCM2MOM</a> <a href="#topic+posterior">posterior</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
# An example that conditions a Pacific cod operating model. There are 48 simulations, 
# where values of natural mortality and steepness are sampled from distributions. 
# The model is fitted with priors on the index catchability. Maturity and selectivity 
# are knife-edge at the age of 2 years. See online tutorial for more information.

data(pcod) 
mat_ogive &lt;- pcod$OM@cpars$Mat_age[1, , 1]
out &lt;- RCM(OM = pcod$OM, data = pcod$data, 
           condition = "catch", mean_fit = TRUE,
           selectivity = "free", s_selectivity = rep("SSB", ncol(pcod$data@Index)),
           start = list(vul_par = matrix(mat_ogive, length(mat_ogive), 1)),
           map = list(vul_par = matrix(NA, length(mat_ogive), 1),
                      log_early_rec_dev = rep(1, pcod$OM@maxage)),
           prior = pcod$prior)
plot(out, s_name = colnames(pcod$data@Index))

# Alternative OM with age-3 maturity and selectivity instead.
out_age3 &lt;- local({
  pcod$OM@cpars$Mat_age[, 2, ] &lt;- 0
  mat_ogive_age3 &lt;- pcod$OM@cpars$Mat_age[1, , 1]
  RCM(OM = pcod$OM, data = pcod$data, 
      condition = "catch", mean_fit = TRUE,
      selectivity = "free", s_selectivity = rep("SSB", ncol(pcod$data@Index)),
      start = list(vul_par = matrix(mat_ogive_age3, length(mat_ogive_age3), 1)),
      map = list(vul_par = matrix(NA, length(mat_ogive_age3), 1),   
                 log_early_rec_dev = rep(1, pcod$OM@maxage)),
      prior = pcod$prior)
})
  
compare_RCM(out, out_age3, scenario = list(names = c("Age-2 maturity", "Age-3 maturity")),
            s_name = colnames(pcod$data@Index))
             
Hist &lt;- runMSE(out@OM, Hist = TRUE)            
 

</code></pre>

<hr>
<h2 id='compare_models'>Compare output from several assessment models</h2><span id='topic+compare_models'></span>

<h3>Description</h3>

<p>Plot biomass, recruitment, and fishing mortality time series from several . This function can be used to compare outputs among
different assessment models from the same Data object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_models(..., label = NULL, color = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_models_+3A_...">...</code></td>
<td>
<p>Objects of class <a href="#topic+Assessment-class">Assessment</a>.</p>
</td></tr>
<tr><td><code id="compare_models_+3A_label">label</code></td>
<td>
<p>A character vector of the models for the legend.</p>
</td></tr>
<tr><td><code id="compare_models_+3A_color">color</code></td>
<td>
<p>A vector of colors for each assessment model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A set of figures of biomass, recruitment, and fishing mortality estimates among the models.
</p>


<h3>Author(s)</h3>

<p>Q. Huynh
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- cDD_SS(x = 3, Data = MSEtool::SimulatedData)
res2 &lt;- SCA(x = 3, Data = MSEtool::SimulatedData)
res3 &lt;- SP(x = 3, Data = MSEtool::SimulatedData)

compare_models(res, res2, res3)
</code></pre>

<hr>
<h2 id='DD_TMB'>Delay - Difference Stock Assessment in TMB</h2><span id='topic+DD_TMB'></span><span id='topic+DD_SS'></span>

<h3>Description</h3>

<p>A simple delay-difference assessment model using a
time-series of catches and a relative abundance index and coded in TMB. The model
can be conditioned on either (1) effort and estimates predicted catch or (2) catch and estimates a predicted index.
In the state-space version <code>DD_SS</code>, recruitment deviations from the stock-recruit relationship are estimated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DD_TMB(
  x = 1,
  Data,
  condition = c("catch", "effort"),
  AddInd = "B",
  SR = c("BH", "Ricker"),
  rescale = "mean1",
  MW = FALSE,
  start = NULL,
  prior = list(),
  fix_h = TRUE,
  dep = 1,
  LWT = list(),
  n_itF = 3L,
  silent = TRUE,
  opt_hess = FALSE,
  n_restart = ifelse(opt_hess, 0, 1),
  control = list(iter.max = 5000, eval.max = 10000),
  ...
)

DD_SS(
  x = 1,
  Data,
  condition = c("catch", "effort"),
  AddInd = "B",
  SR = c("BH", "Ricker"),
  rescale = "mean1",
  MW = FALSE,
  start = NULL,
  prior = list(),
  fix_h = TRUE,
  fix_sd = FALSE,
  fix_tau = TRUE,
  dep = 1,
  LWT = list(),
  n_itF = 3L,
  integrate = FALSE,
  silent = TRUE,
  opt_hess = FALSE,
  n_restart = ifelse(opt_hess, 0, 1),
  control = list(iter.max = 5000, eval.max = 10000),
  inner.control = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DD_TMB_+3A_x">x</code></td>
<td>
<p>An index for the objects in <code>Data</code> when running in closed loop simulation.
Otherwise, equals to 1 when running an assessment.</p>
</td></tr>
<tr><td><code id="DD_TMB_+3A_data">Data</code></td>
<td>
<p>An object of class Data.</p>
</td></tr>
<tr><td><code id="DD_TMB_+3A_condition">condition</code></td>
<td>
<p>A string to indicate whether to condition the model on catch or effort (ratio of catch and index).</p>
</td></tr>
<tr><td><code id="DD_TMB_+3A_addind">AddInd</code></td>
<td>
<p>A vector of integers or character strings indicating the indices to be used in the model. Integers assign the index to
the corresponding index in Data@AddInd, &quot;B&quot; (or 0) represents total biomass in Data@Ind, &quot;VB&quot; represents vulnerable biomass in
Data@VInd, and &quot;SSB&quot; represents spawning stock biomass in Data@SpInd.</p>
</td></tr>
<tr><td><code id="DD_TMB_+3A_sr">SR</code></td>
<td>
<p>Stock-recruit function (either <code>"BH"</code> for Beverton-Holt or <code>"Ricker"</code>).</p>
</td></tr>
<tr><td><code id="DD_TMB_+3A_rescale">rescale</code></td>
<td>
<p>A multiplicative factor that rescales the catch in the assessment model, which
can improve convergence. By default, <code>"mean1"</code> scales the catch so that time series mean is 1, otherwise a numeric.
Output is re-converted back to original units.</p>
</td></tr>
<tr><td><code id="DD_TMB_+3A_mw">MW</code></td>
<td>
<p>Logical, whether to fit to mean weight. In closed-loop simulation, mean weight will be grabbed from <code>Data@Misc[[x]]$MW</code>,
otherwise calculated from <code>Data@CAL</code>.</p>
</td></tr>
<tr><td><code id="DD_TMB_+3A_start">start</code></td>
<td>
<p>Optional list of starting values. Entries can be expressions that are evaluated in the function. See details.</p>
</td></tr>
<tr><td><code id="DD_TMB_+3A_prior">prior</code></td>
<td>
<p>A named list for the parameters of any priors to be added to the model. See below.</p>
</td></tr>
<tr><td><code id="DD_TMB_+3A_fix_h">fix_h</code></td>
<td>
<p>Logical, whether to fix steepness to value in <code>Data@steep</code> in the assessment model.
Automatically false if a prior is used.</p>
</td></tr>
<tr><td><code id="DD_TMB_+3A_dep">dep</code></td>
<td>
<p>The initial depletion in the first year of the model. A tight prior is placed on the model objective function
to estimate the equilibrium fishing mortality rate that corresponds to the initial depletion. Due to this tight prior, this F
should not be considered to be an independent model parameter. Set to zero to eliminate this prior.</p>
</td></tr>
<tr><td><code id="DD_TMB_+3A_lwt">LWT</code></td>
<td>
<p>A named list of likelihood weights. For <code>LWT$Index</code>, a vector of likelihood weights for each survey, while
for <code>LWT$MW</code> a numeric.</p>
</td></tr>
<tr><td><code id="DD_TMB_+3A_n_itf">n_itF</code></td>
<td>
<p>Integer, the number of iterations to solve F within an annual time step when conditioning on catch.</p>
</td></tr>
<tr><td><code id="DD_TMB_+3A_silent">silent</code></td>
<td>
<p>Logical, passed to <code><a href="TMB.html#topic+MakeADFun">TMB::MakeADFun()</a></code>, whether TMB
will print trace information during optimization. Used for diagnostics for model convergence.</p>
</td></tr>
<tr><td><code id="DD_TMB_+3A_opt_hess">opt_hess</code></td>
<td>
<p>Logical, whether the hessian function will be passed to <code><a href="stats.html#topic+nlminb">stats::nlminb()</a></code> during optimization
(this generally reduces the number of iterations to convergence, but is memory and time intensive and does not guarantee an increase
in convergence rate). Ignored if <code>integrate = TRUE</code>.</p>
</td></tr>
<tr><td><code id="DD_TMB_+3A_n_restart">n_restart</code></td>
<td>
<p>The number of restarts (calls to <code><a href="stats.html#topic+nlminb">stats::nlminb()</a></code>) in the optimization procedure, so long as the model
hasn't converged. The optimization continues from the parameters from the previous (re)start.</p>
</td></tr>
<tr><td><code id="DD_TMB_+3A_control">control</code></td>
<td>
<p>A named list of parameters regarding optimization to be passed to
<code><a href="stats.html#topic+nlminb">stats::nlminb()</a></code>.</p>
</td></tr>
<tr><td><code id="DD_TMB_+3A_...">...</code></td>
<td>
<p>Additional arguments (not currently used).</p>
</td></tr>
<tr><td><code id="DD_TMB_+3A_fix_sd">fix_sd</code></td>
<td>
<p>Logical, whether the standard deviation of the data in the likelihood (index for conditioning on catch or
catch for conditioning on effort). If <code>TRUE</code>, the SD is fixed to value provided in <code>start</code> (if provided), otherwise,
value based on either <code>Data@CV_Cat</code> or <code>Data@CV_Ind</code>.</p>
</td></tr>
<tr><td><code id="DD_TMB_+3A_fix_tau">fix_tau</code></td>
<td>
<p>Logical, the standard deviation of the recruitment deviations is fixed. If <code>TRUE</code>,
tau is fixed to value provided in <code>start</code> (if provided), otherwise, equal to 1.</p>
</td></tr>
<tr><td><code id="DD_TMB_+3A_integrate">integrate</code></td>
<td>
<p>Logical, whether the likelihood of the model integrates over the likelihood
of the recruitment deviations (thus, treating it as a random effects/state-space variable).
Otherwise, recruitment deviations are penalized parameters.</p>
</td></tr>
<tr><td><code id="DD_TMB_+3A_inner.control">inner.control</code></td>
<td>
<p>A named list of arguments for optimization of the random effects, which
is passed on to <code><a href="TMB.html#topic+newton">TMB::newton()</a></code> via <code><a href="TMB.html#topic+MakeADFun">TMB::MakeADFun()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>start</code> (optional), a named list of starting values of estimates can be provided for:
</p>

<ul>
<li> <p><code>R0</code> Unfished recruitment. Otherwise, <code>Data@OM$R0[x]</code> is used in closed-loop, and 400% of mean catch otherwise.
</p>
</li>
<li> <p><code>h</code> Steepness. Otherwise, <code>Data@steep[x]</code> is used, or 0.9 if empty.
</p>
</li>
<li> <p><code>M</code> Natural mortality. Otherwise, <code>Data@Mort[x]</code> is used.
</p>
</li>
<li> <p><code>k</code> Age of knife-edge maturity. By default, the age of 50% maturity calculated from the slots in the Data object.
</p>
</li>
<li> <p><code>Rho</code> Delay-difference rho parameter. Otherwise, calculated from biological parameters in the Data object.
</p>
</li>
<li> <p><code>Alpha</code> Delay-difference alpha parameter. Otherwise, calculated from biological parameters in the Data object.
</p>
</li>
<li> <p><code>q_effort</code> Scalar coefficient when conditioning on effort (to scale to F). Otherwise, 1 is the default.
</p>
</li>
<li> <p><code>F_equilibrium</code> Equilibrium fishing mortality rate leading into first year of the model (to determine initial depletion). By default, 0.
</p>
</li>
<li> <p><code>omega</code> Lognormal SD of the catch (observation error) when conditioning on effort. By default, <code>Data@CV_Cat[x]</code>.
</p>
</li>
<li> <p><code>tau</code> Lognormal SD of the recruitment deviations (process error) for <code>DD_SS</code>. By default, <code>Data@sigmaR[x]</code>.
</p>
</li>
<li> <p><code>sigma</code> Lognormal SD of the index (observation error) when conditioning on catch. By default, <code>Data@CV_Ind[x]</code>. Not
used if multiple indices are used.
</p>
</li>
<li> <p><code>sigma_W</code> Lognormal SD of the mean weight (observation error). By default, 0.1.
</p>
</li></ul>

<p>Multiple indices are supported in the model. Data@Ind, Data@VInd, and Data@SpInd are all assumed to be biomass-based.
For Data@AddInd, Data@I_units are used to identify a biomass vs. abundance-based index.
</p>
<p>Similar to many other assessment
models, the model depends on assumptions such as stationary productivity and
proportionality between the abundance index and real abundance.
Unsurprisingly the extent to which these assumptions are
violated tends to be the biggest driver of performance for this method.
</p>


<h3>Value</h3>

<p>An object of <a href="#topic+Assessment-class">Assessment</a> containing objects and output from TMB.
</p>


<h3>Priors</h3>

<p>The following priors can be added as a named list, e.g., <code style="white-space: pre;">&#8288;prior = list(M = c(0.25, 0.15), h = c(0.7, 0.1)&#8288;</code>.
For each parameter below, provide a vector of values as described:
</p>

<ul>
<li> <p><code>R0</code> - A vector of length 3. The first value indicates the distribution of the prior: <code>1</code> for lognormal, <code>2</code> for uniform
on <code>log(R0)</code>, <code>3</code> for uniform on R0. If lognormal, the second and third values are the prior mean (in normal space) and SD (in log space).
Otherwise, the second and third values are the lower and upper bounds of the uniform distribution (values in normal space).
</p>
</li>
<li> <p><code>h</code> - A vector of length 2 for the prior mean and SD, both in normal space. Beverton-Holt steepness uses a beta distribution,
while Ricker steepness uses a normal distribution.
</p>
</li>
<li> <p><code>M</code> - A vector of length 2 for the prior mean (in normal space) and SD (in log space). Lognormal prior.
</p>
</li>
<li> <p><code>q</code> - A matrix for nsurvey rows and 2 columns. The first column is the prior mean (in normal space) and the second column
for the SD (in log space). Use <code>NA</code> in rows corresponding to indices without priors.
</p>
</li></ul>

<p>See online documentation for more details.
</p>


<h3>Online Documentation</h3>

<p>Model description and equations are available on the openMSE
<a href="https://openmse.com/features-assessment-models/1-dd/">website</a>.
</p>


<h3>Required Data</h3>


<ul>
<li> <p><code>DD_TMB</code>: Cat, Ind, Mort, L50, vbK, vbLinf, vbt0, wla, wlb, MaxAge
</p>
</li>
<li> <p><code>DD_SS</code>: Cat, Ind, Mort, L50, vbK, vbLinf, vbt0, wla, wlb, MaxAge
</p>
</li></ul>



<h3>Optional Data</h3>


<ul>
<li> <p><code>DD_TMB</code>: steep
</p>
</li>
<li> <p><code>DD_SS</code>: steep, CV_Cat
</p>
</li></ul>



<h3>Author(s)</h3>

<p>T. Carruthers &amp; Z. Siders. Zach Siders coded the TMB function.
</p>


<h3>References</h3>

<p>Carruthers, T, Walters, C.J,, and McAllister, M.K. 2012. Evaluating methods that classify
fisheries stock status using only fisheries catch data. Fisheries Research 119-120:66-79.
</p>
<p>Hilborn, R., and Walters, C., 1992. Quantitative Fisheries Stock Assessment: Choice,
Dynamics and Uncertainty. Chapman and Hall, New York.
</p>


<h3>See Also</h3>

<p><a href="#topic+plot.Assessment">plot.Assessment</a> <a href="#topic+summary.Assessment">summary.Assessment</a> <a href="#topic+retrospective">retrospective</a> <a href="#topic+profile">profile</a> <a href="#topic+make_MP">make_MP</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#### Observation-error delay difference model
res &lt;- DD_TMB(x = 3, Data = MSEtool::SimulatedData)

# Provide starting values
start &lt;- list(h = 0.95)
res &lt;- DD_TMB(x = 3, Data = MSEtool::SimulatedData, start = start)

summary(res@SD) # Parameter estimates

### State-space version
### Set recruitment variability SD = 0.3 (since fix_tau = TRUE)
res &lt;- DD_SS(x = 3, Data = MSEtool::SimulatedData, start = list(tau = 0.3))

</code></pre>

<hr>
<h2 id='diagnostic'>Diagnostic of assessments in MSE: did Assess models converge during MSE?</h2><span id='topic+diagnostic'></span><span id='topic+diagnostic_AM'></span>

<h3>Description</h3>

<p>Diagnostic check for convergence of Assess models during closed-loop simulation. Use when the MP was
created with <a href="#topic+make_MP">make_MP</a> with argument <code>diagnostic = "min"</code> or <code>"full"</code>.
This function summarizes and plots the diagnostic information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagnostic(MSE, MP, gradient_threshold = 0.1, figure = TRUE)

diagnostic_AM(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagnostic_+3A_mse">MSE</code></td>
<td>
<p>An object of class MSE created by <code><a href="MSEtool.html#topic+runMSE">MSEtool::runMSE()</a></code>.</p>
</td></tr>
<tr><td><code id="diagnostic_+3A_mp">MP</code></td>
<td>
<p>Optional, a character vector of MPs that use assessment models.</p>
</td></tr>
<tr><td><code id="diagnostic_+3A_gradient_threshold">gradient_threshold</code></td>
<td>
<p>The maximum magnitude (absolute value) desired for the gradient of the likelihood.</p>
</td></tr>
<tr><td><code id="diagnostic_+3A_figure">figure</code></td>
<td>
<p>Logical, whether a figure will be drawn.</p>
</td></tr>
<tr><td><code id="diagnostic_+3A_...">...</code></td>
<td>
<p>Arguments to pass to <code>diagnostic</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with diagnostic performance of assessment models in the MSE. If <code>figure = TRUE</code>,
a set of figures: traffic light (red/green) plots indicating whether the model converged (defined if a positive-definite
Hessian matrix was obtained), the optimizer reached pre-specified iteration limits (as passed to <code><a href="stats.html#topic+nlminb">stats::nlminb()</a></code>),
and the maximum gradient of the likelihood in each assessment run. Also includes the number of optimization iterations
function evaluations reported by <code><a href="stats.html#topic+nlminb">stats::nlminb()</a></code> for each application of the assessment model.
</p>


<h3>Author(s)</h3>

<p>Q. Huynh
</p>


<h3>See Also</h3>

<p><a href="#topic+retrospective_AM">retrospective_AM</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
OM &lt;- MSEtool::testOM; OM@proyears &lt;- 20
myMSE &lt;- runMSE(OM, MPs = "SCA_4010")
diagnostic(myMSE)

# How to get all the reporting
library(dplyr)
conv_statistics &lt;- lapply(1:myMSE@nMPs, function(m) {
  lapply(1:myMSE@nsim, function(x) {
    myMSE@PPD[[m]]@Misc[[x]]$diagnostic %&gt;%
      mutate(MP = myMSE@MPs[m], Simulation = x)
 }) %&gt;% bind_rows()
}) %&gt;% bind_rows()

</code></pre>

<hr>
<h2 id='getinds'>Characterize posterior predictive data</h2><span id='topic+getinds'></span>

<h3>Description</h3>

<p>Characterize posterior predictive data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getinds(
  PPD,
  styr,
  res = 6,
  tsd = c("Cat", "Cat", "Cat", "Ind", "ML"),
  stat = c("slp", "AAV", "mu", "slp", "slp")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getinds_+3A_ppd">PPD</code></td>
<td>
<p>An object of class Data stored in the Misc slot of an MSE object following a call of <code>runMSE(PPD = TRUE)</code>.</p>
</td></tr>
<tr><td><code id="getinds_+3A_styr">styr</code></td>
<td>
<p>Positive integer, the starting year for calculation of quantities</p>
</td></tr>
<tr><td><code id="getinds_+3A_res">res</code></td>
<td>
<p>Positive integer, the temporal resolution (chunks - normally years) over which to calculate quantities</p>
</td></tr>
<tr><td><code id="getinds_+3A_tsd">tsd</code></td>
<td>
<p>Character vector of names of types of data: Cat = catch, Ind = relative abundance index, ML = mean length in catches</p>
</td></tr>
<tr><td><code id="getinds_+3A_stat">stat</code></td>
<td>
<p>Character vector of types of quantity to be calculated: slp = slope(log(x)), AAV = average annual variability, mu = mean(log(x))</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 3D array of results (type of data/stat (e.g. mean catches),time period (chunk), simulation)
</p>


<h3>Author(s)</h3>

<p>T. Carruthers
</p>


<h3>References</h3>

<p>Carruthers and Hordyk 2018
</p>

<hr>
<h2 id='HCR_escapement'>Fixed escapement harvest control rule</h2><span id='topic+HCR_escapement'></span>

<h3>Description</h3>

<p>A simple control rule that allows fishing when the operational control point (OCP) is above some threshold.
By default, this function sets the TAC at F = 100% FMSY when spawning depletion &gt; 0.1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HCR_escapement(
  Assessment,
  reps = 1,
  OCP_type = "SSB_SSB0",
  OCP_threshold = 0.2,
  Ftarget_type = "FMSY",
  relF_max = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HCR_escapement_+3A_assessment">Assessment</code></td>
<td>
<p>An object of class <a href="#topic+Assessment-class">Assessment</a> with estimates of
FMSY or UMSY and vulnerable biomass in terminal year.</p>
</td></tr>
<tr><td><code id="HCR_escapement_+3A_reps">reps</code></td>
<td>
<p>The number of stochastic samples of the TAC recommendation.</p>
</td></tr>
<tr><td><code id="HCR_escapement_+3A_ocp_type">OCP_type</code></td>
<td>
<p>The type of operational control points (OCPs) for the harvest control rule used to determine
whether there is fishing. By default, use (<code>"SSB_SSB0"</code> for spawning depletion. Other biomass OCPs include <code>"SSB_SSBMSY"</code> for spawning biomass relative to MSY and
<code>"SSB_dSSB0"</code>, for dynamic depletion (dynamic SSB0 is the historical reconstructed biomass with F = 0).
For F-based OCPs, the terminal year fishing mortality relative F01 or Fmax (using yield-per-recruit) or F-SPR% (see <code>SPR_OCP</code> argument) can be used.</p>
</td></tr>
<tr><td><code id="HCR_escapement_+3A_ocp_threshold">OCP_threshold</code></td>
<td>
<p>The value of the OCP above which fishing can occur.</p>
</td></tr>
<tr><td><code id="HCR_escapement_+3A_ftarget_type">Ftarget_type</code></td>
<td>
<p>The type of F used for the target fishing mortality rate.</p>
</td></tr>
<tr><td><code id="HCR_escapement_+3A_relf_max">relF_max</code></td>
<td>
<p>The relative value of Ftarget if <code>OCP &gt; OCP_treshold</code>.</p>
</td></tr>
<tr><td><code id="HCR_escapement_+3A_...">...</code></td>
<td>
<p>Miscellaneous arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The catch advice is calculated using the catch equation of the corresponding
assessment. See <code>Assessment@forecast$catch_eq</code>, a function that returns the catch advice for a specified <code>Ftarget</code>.
</p>


<h3>Value</h3>

<p>An object of class Rec with the TAC recommendation.
</p>


<h3>Author(s)</h3>

<p>Q. Huynh
</p>


<h3>References</h3>

<p>Deroba, J.J. and Bence, J.R. 2008. A review of harvest policies: Understanding relative
performance of control rules. Fisheries Research 94:210-223.
</p>


<h3>See Also</h3>

<p><a href="#topic+make_MP">make_MP</a> <a href="#topic+HCR_ramp">HCR_ramp</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create an MP to run in closed-loop MSE (fishes at FMSY when B/B0 &gt; 0.2)
SP_escapement &lt;- make_MP(SP, HCR_escapement)

# The MP which fishes at 75% of FMSY
SP_escapement75 &lt;- make_MP(SP, HCR_escapement, relF_max = 0.75)

# The MP which fishes at FMSY when BMSY &gt; 0.5
SP_BMSY_escapement &lt;- make_MP(SP, HCR_escapement, OCP_type = "SSB_SSBMSY", 
                              OCP_threshold = 0.5, relF_max = 1)


myOM &lt;- MSEtool::runMSE(MSEtool::testOM, MPs = c("FMSYref", "SP_escapement", "SP_BMSY_escapement"))

</code></pre>

<hr>
<h2 id='HCR_FB'>A Harvest Control Rule using B/BMSY and F/FMSY to adjust TAC or TAE.</h2><span id='topic+HCR_FB'></span>

<h3>Description</h3>

<p>A Harvest Control Rule using B/BMSY and F/FMSY to adjust TAC or TAE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HCR_FB(Brel, Frel, Bpow = 2, Bgrad = 1, Fpow = 1, Fgrad = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HCR_FB_+3A_brel">Brel</code></td>
<td>
<p>improper fraction: an estimate of Biomass relative to BMSY</p>
</td></tr>
<tr><td><code id="HCR_FB_+3A_frel">Frel</code></td>
<td>
<p>improper fraction: an estimate of Fishing mortality rate relative to FMSY</p>
</td></tr>
<tr><td><code id="HCR_FB_+3A_bpow">Bpow</code></td>
<td>
<p>non-negative real number: controls the shape of the biomass adjustment, when zero there is no adjustment</p>
</td></tr>
<tr><td><code id="HCR_FB_+3A_bgrad">Bgrad</code></td>
<td>
<p>non-negative real number: controls the gradient of the biomass adjustment</p>
</td></tr>
<tr><td><code id="HCR_FB_+3A_fpow">Fpow</code></td>
<td>
<p>non-negative real number: controls the adjustment speed relative to F/FMSY. When set to 1, next recommendation is FMSY. When less than 1 next recommendation is between current F and FMSY.</p>
</td></tr>
<tr><td><code id="HCR_FB_+3A_fgrad">Fgrad</code></td>
<td>
<p>improper fraction: target Fishing rate relative to FMSY</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a TAC or TAE adjustment factor.
</p>


<h3>Author(s)</h3>

<p>T. Carruthers
</p>


<h3>References</h3>

<p>Made up for this package
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- 100
Frel &lt;- seq(1/2, 2, length.out = res)
Brel &lt;- seq(0.05, 2, length.out=res)
adj &lt;- array(HCR_FB(Brel[rep(1:res, res)], Frel[rep(1:res, each = res)],
                    Bpow = 2, Bgrad = 1, Fpow = 1, Fgrad = 0.75), c(res, res))
contour(Brel, Frel, adj, nlevels = 20, xlab = "B/BMSY", ylab = "F/FMSY",
        main = "FBsurface TAC adjustment factor")
abline(h = 1, col = 'red', lty = 2)
abline(v = 1, col = 'red', lty = 2)
legend('topright', c("Bpow = 2", "Bgrad = 1", "Fpow = 1", "Fgrad = 0.75"), text.col = 'blue')
</code></pre>

<hr>
<h2 id='HCR_fixedF'>Simple fixed F harvest control rule</h2><span id='topic+HCR_fixedF'></span>

<h3>Description</h3>

<p>A simple control rule that explicitly specifies the target apical F independent of any model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HCR_fixedF(Assessment, reps = 1, Ftarget = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HCR_fixedF_+3A_assessment">Assessment</code></td>
<td>
<p>An object of class <a href="#topic+Assessment-class">Assessment</a> with estimates of next year's abundance or biomass.</p>
</td></tr>
<tr><td><code id="HCR_fixedF_+3A_reps">reps</code></td>
<td>
<p>The number of replicates of the TAC recommendation (not used).</p>
</td></tr>
<tr><td><code id="HCR_fixedF_+3A_ftarget">Ftarget</code></td>
<td>
<p>The value of F.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The catch advice is calculated using the catch equation of the corresponding
assessment. See <code>Assessment@forecast$catch_eq</code>, a function that returns the catch advice for a specified <code>Ftarget</code>.
</p>


<h3>Value</h3>

<p>An object of class Rec with the TAC recommendation.
</p>


<h3>Author(s)</h3>

<p>Q. Huynh
</p>


<h3>See Also</h3>

<p><a href="#topic+make_MP">make_MP</a> <a href="#topic+HCR_ramp">HCR_ramp</a>#'
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create an MP to run in closed-loop MSE (fishes at F = 0.2)
F0.2 &lt;- make_MP(SP, HCR_fixedF, Ftarget = 0.2)


myOM &lt;- MSEtool::runMSE(MSEtool::testOM, MPs = c("FMSYref", "F0.2"))

</code></pre>

<hr>
<h2 id='HCR_MSY'>Harvest control rule to fish at some fraction of maximum sustainable yield</h2><span id='topic+HCR_MSY'></span>

<h3>Description</h3>

<p>A simple control rule that specifies the total allowable catch (TAC) as a function of the abundance of the first
projection year and some fraction of FMSY/UMSY.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HCR_MSY(Assessment, reps = 1, MSY_frac = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HCR_MSY_+3A_assessment">Assessment</code></td>
<td>
<p>An object of class <a href="#topic+Assessment-class">Assessment</a> with estimates of
FMSY or UMSY and vulnerable biomass in terminal year.</p>
</td></tr>
<tr><td><code id="HCR_MSY_+3A_reps">reps</code></td>
<td>
<p>The number of stochastic samples of the TAC recommendation.</p>
</td></tr>
<tr><td><code id="HCR_MSY_+3A_msy_frac">MSY_frac</code></td>
<td>
<p>The fraction of FMSY or UMSY for calculating the TAC (e.g. MSY_frac = 0.75 fishes at 75% of FMSY).</p>
</td></tr>
<tr><td><code id="HCR_MSY_+3A_...">...</code></td>
<td>
<p>Miscellaneous arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The catch advice is calculated using the catch equation of the corresponding
assessment. See <code>Assessment@forecast$catch_eq</code>, a function that returns the catch advice for a specified <code>Ftarget</code>.
</p>


<h3>Value</h3>

<p>An object of class Rec with the TAC recommendation.
</p>


<h3>Author(s)</h3>

<p>Q. Huynh
</p>


<h3>References</h3>

<p>Punt, A. E, Dorn, M. W., and Haltuch, M. A. 2008. Evaluation of threshold management strategies
for groundfish off the U.S. West Coast. Fisheries Research 94:251-266.
</p>


<h3>See Also</h3>

<p><a href="#topic+make_MP">make_MP</a> <a href="#topic+HCR_ramp">HCR_ramp</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create an MP to run in closed-loop MSE (fishes at UMSY)
SPMSY &lt;- make_MP(SP, HCR_MSY)

# The MP which fishes at 75% of FMSY
SP75MSY &lt;- make_MP(SP, HCR_MSY, MSY_frac = 0.75)


myOM &lt;- MSEtool::runMSE(MSEtool::testOM, MPs = c("FMSYref", "SPMSY", "SP75MSY"))

</code></pre>

<hr>
<h2 id='HCR_ramp'>Linearly ramped harvest control rules</h2><span id='topic+HCR_ramp'></span><span id='topic+HCR40_10'></span><span id='topic+HCR60_20'></span><span id='topic+HCR80_40MSY'></span>

<h3>Description</h3>

<p>An output control rule with a ramp that reduces the target F (used for the TAC recommendation) linearly
as a function of an operational control point (OCP) such as spawning depletion or spawning biomass. The reduction in F is linear when the OCP
is between the target OCP (TOCP) and the limit OCP (LOCP). The target F is maximized at or above the TOCP. Below the LOCP,
the target F is minimized. For example, the TOCP and LOCP for 40% and 10% spawning depletion, respectively, in the 40-10 control rule.
Ftarget is FMSY above the TOCP and zero below the LOCP. This type of control rule can generalized with more control points (&gt;2) in <a href="#topic+HCR_segment">HCR_segment</a>.
Class HCR objects are typically used with function <a href="#topic+make_MP">make_MP</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HCR_ramp(
  Assessment,
  reps = 1,
  OCP_type = c("SSB_SSB0", "SSB_SSBMSY", "SSB_dSSB0", "F_FMSY", "F_F01", "F_FSPR"),
  Ftarget_type = c("FMSY", "F01", "Fmax", "FSPR", "abs"),
  LOCP = 0.1,
  TOCP = 0.4,
  relF_min = 0,
  relF_max = 1,
  SPR_OCP = 0.4,
  SPR_targ = 0.4,
  ...
)

HCR40_10(Assessment, reps = 1, Ftarget_type = "FMSY", SPR_targ = 0.4, ...)

HCR60_20(Assessment, reps = 1, Ftarget_type = "FMSY", SPR_targ = 0.4, ...)

HCR80_40MSY(Assessment, reps = 1, Ftarget_type = "FMSY", SPR_targ = 0.4, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HCR_ramp_+3A_assessment">Assessment</code></td>
<td>
<p>An object of class <a href="#topic+Assessment-class">Assessment</a> with estimates of
FMSY or UMSY, vulnerable biomass, and spawning biomass depletion in terminal year.</p>
</td></tr>
<tr><td><code id="HCR_ramp_+3A_reps">reps</code></td>
<td>
<p>The number of stochastic samples of the TAC recommendation.</p>
</td></tr>
<tr><td><code id="HCR_ramp_+3A_ocp_type">OCP_type</code></td>
<td>
<p>The type of operational control points (OCPs) for the harvest control rule used to determine the reduction in F.
See below.</p>
</td></tr>
<tr><td><code id="HCR_ramp_+3A_ftarget_type">Ftarget_type</code></td>
<td>
<p>The type of F used for the target fishing mortality rate. See below.</p>
</td></tr>
<tr><td><code id="HCR_ramp_+3A_locp">LOCP</code></td>
<td>
<p>Numeric, the limit value for the OCP in the HCR.</p>
</td></tr>
<tr><td><code id="HCR_ramp_+3A_tocp">TOCP</code></td>
<td>
<p>Numeric, the target value for the OCP in the HCR.</p>
</td></tr>
<tr><td><code id="HCR_ramp_+3A_relf_min">relF_min</code></td>
<td>
<p>The relative value of Ftarget (i.e., as a proportion) if <code>OCP &lt; LOCP</code>.</p>
</td></tr>
<tr><td><code id="HCR_ramp_+3A_relf_max">relF_max</code></td>
<td>
<p>The relative value of Ftarget if <code>OCP &gt; TOCP</code>.</p>
</td></tr>
<tr><td><code id="HCR_ramp_+3A_spr_ocp">SPR_OCP</code></td>
<td>
<p>The value of spawning potential ratio for the OCP if <code>OCP_type = "F_FSPR"</code>. By default, 0.4 (F40%).</p>
</td></tr>
<tr><td><code id="HCR_ramp_+3A_spr_targ">SPR_targ</code></td>
<td>
<p>The target value of spawning potential ratio if <code>Ftarget_type = "FSPR"</code>. By default, 0.4 (F40%).</p>
</td></tr>
<tr><td><code id="HCR_ramp_+3A_...">...</code></td>
<td>
<p>Miscellaneous arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The catch advice is calculated using the catch equation of the corresponding
assessment. See <code>Assessment@forecast$catch_eq</code>, a function that returns the catch advice for a specified <code>Ftarget</code>.
</p>
<p><em>Operational control points (OCP_type)</em>
</p>
<p>The following are the available options for harvest control rule inputs, and the source of those values
in the <a href="#topic+Assessment-class">Assessment</a> object:
</p>

<ul>
<li> <p><strong>Default</strong> <code>"SSB_SSB0"</code>: Spawning depletion. Uses the last value in  <code>Assessment@SSB_SSB0</code> vector.
</p>
</li>
<li> <p><code>"SSB_SSBMSY"</code>: Spawning biomass relative to MSY. Uses the last value in <code>Assessment@SSB_SSBMSY</code> vector.
</p>
</li>
<li> <p><code>"SSB_dSSB0"</code>: Dynamic depletion (SSB relative to the historical reconstructed biomass with F = 0). Uses the last value in
<code>Assessment@SSB/Assessment@TMB_report$dynamic_SSB0</code>.
</p>
</li>
<li> <p><code>"F_FMSY"</code>: Fishing mortality relative to MSY. Uses the last value in <code>Assessment@F_FMSY</code>.
</p>
</li>
<li> <p><code>"F_F01"</code>: Fishing mortality relative to F_0.1 (yield per recruit), calculated from the data frame in
<code>Assessment@forecast[["per_recruit"]]</code>.
</p>
</li>
<li> <p><code>"F_FSPR"</code>: Fishing mortality relative to F_SPR% (the F that produces the spawning potential ratio specified in
<code>"SPR_OCP"</code>, calculated from the data frame in <code>Assessment@forecast[["per_recruit"]]</code>.
</p>
</li></ul>

<p><em>Fishing mortality target (Ftarget_type)</em>
</p>
<p>The type of F for which the corresponding catch is calculated in the HCR is specified here. The source of those values
in the <a href="#topic+Assessment-class">Assessment</a> object is specified:
</p>

<ul>
<li> <p><strong>Default</strong> <code>"FMSY"</code>: Fishing mortality relative to MSY. Uses the value in <code>Assessment@FMSY</code>.
</p>
</li>
<li> <p><code>"F01"</code>: Fishing mortality relative to F_0.1 (yield per recruit), calculated from the data frame in
<code>Assessment@forecast[["per_recruit"]]</code>.
</p>
</li>
<li> <p><code>"Fmax"</code>: Fishing mortality relative to F_max (maximizing yield per recruit), calculated from the data frame in
<code>Assessment@forecast[["per_recruit"]]</code>.
</p>
</li>
<li> <p><code>"FSPR"</code>: Fishing mortality relative to F_SPR% (the F that produces the spawning potential ratio specified in
<code>"SPR_targ"</code>, calculated from data frame in <code>Assessment@forecast[["per_recruit"]]</code>.
</p>
</li>
<li> <p><code>"abs"</code>: Fishing mortality is independent of any model output and is explicitly specified in <code>relF</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class Rec with the TAC recommendation.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>HCR_ramp()</code>: Generic ramped-HCR function where user specifies OCP and corresponding limit and target
points, as well as minimum and maximum relative F target.
</p>
</li>
<li> <p><code>HCR40_10()</code>: Common U.S. west coast control rule (LOCP and TOCP of 0.1 and 0.4 spawning depletion,
respectively)
</p>
</li>
<li> <p><code>HCR60_20()</code>: More conservative than <code>HCR40_10</code>, with LOCP and TOCP of 0.2 and 0.6
spawning depletion, respectively).
</p>
</li>
<li> <p><code>HCR80_40MSY()</code>: 0.8 and 0.4 SSBMSY as the LOCP and TOCP, respectively.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Q. Huynh &amp; T. Carruthers
</p>


<h3>References</h3>

<p>Deroba, J.J. and Bence, J.R. 2008. A review of harvest policies: Understanding relative
performance of control rules. Fisheries Research 94:210-223.
</p>
<p>Edwards, C.T.T. and Dankel, D.J. (eds.). 2016. Management Science in Fisheries: an introduction
to simulation methods. Routledge, New York, NY. 460 pp.
</p>
<p>Punt, A. E, Dorn, M. W., and Haltuch, M. A. 2008. Evaluation of threshold management strategies
for groundfish off the U.S. West Coast. Fisheries Research 94:251-266.
</p>
<p>Restrepo, V.R. and Power, J.E. 1999. Precautionary control rules in US fisheries
management: specification and performance. ICES Journal of Marine Science 56:846-852.
</p>


<h3>See Also</h3>

<p><a href="#topic+HCR_segment">HCR_segment</a> <a href="#topic+HCR_MSY">HCR_MSY</a> <a href="#topic+HCRlin">HCRlin</a> <a href="#topic+make_MP">make_MP</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 40-10 linear ramp
Brel &lt;- seq(0, 1, length.out = 200)
plot(Brel, HCRlin(Brel, 0.1, 0.4), 
    xlab = expression("Operational control point: Estimated"~SSB/SSB[0]),
    ylab = expression(F[target]~~": proportion of"~~F[MSY]), 
    main = "40-10 harvest control rule", type = "l")
abline(v = c(0.1, 0.4), col = "red", lty = 2)

# create a 40-10 MP to run in closed-loop MSE
DD_40_10 &lt;- make_MP(DD_TMB, HCR40_10)

# Alternatively,
DD_40_10 &lt;- make_MP(DD_TMB, HCR_ramp, OCP_type = "SSB_SSB0", LOCP = 0.1, TOCP = 0.4)

# An SCA with LOCP and TOCP at 0.4 and 0.8, respectively, of SSB/SSBMSY
SCA_80_40 &lt;- make_MP(SCA, HCR_ramp, OCP_type = "SSB_SSBMSY", LOCP = 0.4, TOCP = 0.8)

# A conservative HCR that fishes at 75% of FMSY at B &gt; 80% BMSY but only reduces F
# to 10% of FMSY if B &lt; 40% BMSY.
SCA_conservative &lt;- make_MP(SCA, HCR_ramp, OCP_type = "SSB_SSBMSY", LOCP = 0.4, TOCP = 0.8, 
relF_min = 0.1, relF_max = 0.75)

# Figure of this conservative HCR
Brel &lt;- seq(0, 1, length.out = 200)
Frel &lt;- HCRlin(Brel, 0.4, 0.8, 0.1, 0.75)
plot(Brel, Frel, 
    xlab = expression("Operational control point: Estimated"~SSB/SSB[MSY]),
    ylab = expression(F[target]~":"~~F/F[MSY]), 
    ylim = c(0, 1), type = "l")
abline(v = c(0.4, 0.8), col = "red", lty = 2)

# A harvest control rule as a function of BMSY, with F independent of model output, 
# i.e., specify F in relF argument (here maximum F of 0.1)
SCA_80_40 &lt;- make_MP(SCA, HCR_ramp, OCP_type = "SSB_SSBMSY", LOCP = 0.4, TOCP = 0.8, 
                     relF_min = 0, relF_max = 0.1)

</code></pre>

<hr>
<h2 id='HCR_segment'>Segmented harvest control rules</h2><span id='topic+HCR_segment'></span>

<h3>Description</h3>

<p>A linear segmented output control rule where the target F (used for the TAC recommendation)
is a function of an operational control point (OCP) such as spawning depletion or spawning biomass.
The segments of the HCR are specified by arguments <code>OCP</code> and <code>relF</code>. Beyond the range of <code>OCP</code>, the response will be flat.
<a href="#topic+HCR_ramp">HCR_ramp</a> uses <code>HCR_segment</code> with two control points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HCR_segment(
  Assessment,
  reps = 1,
  OCP_type = c("SSB_SSB0", "SSB_SSBMSY", "SSB_dSSB0", "F_FMSY", "F_F01", "F_FSPR"),
  Ftarget_type = c("FMSY", "F01", "Fmax", "FSPR", "abs"),
  OCP = c(0.1, 0.4),
  relF = c(0, 1),
  SPR_OCP,
  SPR_targ,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HCR_segment_+3A_assessment">Assessment</code></td>
<td>
<p>An object of class <a href="#topic+Assessment-class">Assessment</a> with estimates of
FMSY or UMSY, vulnerable biomass, and spawning biomass depletion in terminal year.</p>
</td></tr>
<tr><td><code id="HCR_segment_+3A_reps">reps</code></td>
<td>
<p>The number of stochastic samples of the TAC recommendation.</p>
</td></tr>
<tr><td><code id="HCR_segment_+3A_ocp_type">OCP_type</code></td>
<td>
<p>The type of operational control points (OCPs) for the harvest control rule used to determine the reduction in F.
See below.</p>
</td></tr>
<tr><td><code id="HCR_segment_+3A_ftarget_type">Ftarget_type</code></td>
<td>
<p>The type of F used for the target fishing mortality rate. See below.</p>
</td></tr>
<tr><td><code id="HCR_segment_+3A_ocp">OCP</code></td>
<td>
<p>Numeric vector of operational control points for the HCR (in increasing order).</p>
</td></tr>
<tr><td><code id="HCR_segment_+3A_relf">relF</code></td>
<td>
<p>Numeric vector of Ftarget corresponding to the values in <code>OCP</code>.</p>
</td></tr>
<tr><td><code id="HCR_segment_+3A_spr_ocp">SPR_OCP</code></td>
<td>
<p>The value of spawning potential ratio for the OCP if <code>OCP_type = "F_FSPR"</code>. By default, 0.4 (F40%).</p>
</td></tr>
<tr><td><code id="HCR_segment_+3A_spr_targ">SPR_targ</code></td>
<td>
<p>The target value of spawning potential ratio if <code>Ftarget_type = "FSPR"</code>. By default, 0.4 (F40%).</p>
</td></tr>
<tr><td><code id="HCR_segment_+3A_...">...</code></td>
<td>
<p>Miscellaneous arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The catch advice is calculated using the catch equation of the corresponding
assessment. See <code>Assessment@forecast$catch_eq</code>, a function that returns the catch advice for a specified <code>Ftarget</code>.
</p>
<p><em>Operational control points (OCP_type)</em>
</p>
<p>The following are the available options for harvest control rule inputs, and the source of those values
in the <a href="#topic+Assessment-class">Assessment</a> object:
</p>

<ul>
<li> <p><strong>Default</strong> <code>"SSB_SSB0"</code>: Spawning depletion. Uses the last value in  <code>Assessment@SSB_SSB0</code> vector.
</p>
</li>
<li> <p><code>"SSB_SSBMSY"</code>: Spawning biomass relative to MSY. Uses the last value in <code>Assessment@SSB_SSBMSY</code> vector.
</p>
</li>
<li> <p><code>"SSB_dSSB0"</code>: Dynamic depletion (SSB relative to the historical reconstructed biomass with F = 0). Uses the last value in
<code>Assessment@SSB/Assessment@TMB_report$dynamic_SSB0</code>.
</p>
</li>
<li> <p><code>"F_FMSY"</code>: Fishing mortality relative to MSY. Uses the last value in <code>Assessment@F_FMSY</code>.
</p>
</li>
<li> <p><code>"F_F01"</code>: Fishing mortality relative to F_0.1 (yield per recruit), calculated from the data frame in
<code>Assessment@forecast[["per_recruit"]]</code>.
</p>
</li>
<li> <p><code>"F_FSPR"</code>: Fishing mortality relative to F_SPR% (the F that produces the spawning potential ratio specified in
<code>"SPR_OCP"</code>, calculated from the data frame in <code>Assessment@forecast[["per_recruit"]]</code>.
</p>
</li></ul>

<p><em>Fishing mortality target (Ftarget_type)</em>
</p>
<p>The type of F for which the corresponding catch is calculated in the HCR is specified here. The source of those values
in the <a href="#topic+Assessment-class">Assessment</a> object is specified:
</p>

<ul>
<li> <p><strong>Default</strong> <code>"FMSY"</code>: Fishing mortality relative to MSY. Uses the value in <code>Assessment@FMSY</code>.
</p>
</li>
<li> <p><code>"F01"</code>: Fishing mortality relative to F_0.1 (yield per recruit), calculated from the data frame in
<code>Assessment@forecast[["per_recruit"]]</code>.
</p>
</li>
<li> <p><code>"Fmax"</code>: Fishing mortality relative to F_max (maximizing yield per recruit), calculated from the data frame in
<code>Assessment@forecast[["per_recruit"]]</code>.
</p>
</li>
<li> <p><code>"FSPR"</code>: Fishing mortality relative to F_SPR% (the F that produces the spawning potential ratio specified in
<code>"SPR_targ"</code>, calculated from data frame in <code>Assessment@forecast[["per_recruit"]]</code>.
</p>
</li>
<li> <p><code>"abs"</code>: Fishing mortality is independent of any model output and is explicitly specified in <code>relF</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class Rec with the TAC recommendation.
</p>


<h3>Author(s)</h3>

<p>Q. Huynh
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This is an MP with a 40-10 harvest control rule (using FMSY)
DD_40_10 &lt;- make_MP(DD_TMB, HCR_segment, OCP_type = "SSB_SSB0", OCP = c(0.1, 0.4), relF = c(0, 1)) 
#' 
# This is an MP with a 40-10 harvest control rule with a maximum F of 0.1
DD_40_10 &lt;- make_MP(DD_TMB, HCR_segment, OCP_type = "SSB_SSB0", 
                    Ftarget_type = "abs", OCP = c(0.1, 0.4), relF = c(0, 0.1)) 
</code></pre>

<hr>
<h2 id='HCRlin'>Generic linear harvest control rule based on biomass</h2><span id='topic+HCRlin'></span>

<h3>Description</h3>

<p>A general function used by <a href="#topic+HCR_ramp">HCR_ramp</a> that adjusts the output (e.g., F) by a linear ramp based on
the value of the OCP relative to target and limit values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HCRlin(OCP_val, LOCP, TOCP, relF_min = 0, relF_max = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HCRlin_+3A_ocp_val">OCP_val</code></td>
<td>
<p>The value of the operational control point (OCP).</p>
</td></tr>
<tr><td><code id="HCRlin_+3A_locp">LOCP</code></td>
<td>
<p>Numeric, the limit value for the OCP in the HCR.</p>
</td></tr>
<tr><td><code id="HCRlin_+3A_tocp">TOCP</code></td>
<td>
<p>Numeric, the target value for the OCP in the HCR.</p>
</td></tr>
<tr><td><code id="HCRlin_+3A_relf_min">relF_min</code></td>
<td>
<p>The relative maximum value (e.g. a multiple of FMSY) if <code>OCP &lt; LOCP</code>.</p>
</td></tr>
<tr><td><code id="HCRlin_+3A_relf_max">relF_max</code></td>
<td>
<p>The relative maximum value (e.g. a multiple of FMSY) if <code>OCP &gt; TOCP</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric adjustment factor.
</p>


<h3>Author(s)</h3>

<p>T. Carruthers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#40-10 linear ramp
Brel &lt;- seq(0, 1, length.out = 200)
plot(Brel, HCRlin(Brel, 0.1, 0.4), xlab = "Estimated B/B0", ylab = "Relative change in F",
     main = "A 40-10 harvest control rule", type = 'l', col = 'blue')
abline(v = c(0.1,0.4), col = 'red', lty = 2)
</code></pre>

<hr>
<h2 id='mahplot'>Plot statistical power of the indicator with increasing time blocks</h2><span id='topic+mahplot'></span>

<h3>Description</h3>

<p>Plot statistical power of the indicator with increasing time blocks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mahplot(outlist, res = 6, maxups = 5, MPs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mahplot_+3A_outlist">outlist</code></td>
<td>
<p>A list object produced by the function <a href="#topic+PRBcalc">PRBcalc</a></p>
</td></tr>
<tr><td><code id="mahplot_+3A_res">res</code></td>
<td>
<p>Integer, the resolution (time blocking) for the calculation of PPD</p>
</td></tr>
<tr><td><code id="mahplot_+3A_maxups">maxups</code></td>
<td>
<p>Integer, the maximum number of update time blocks to plot</p>
</td></tr>
<tr><td><code id="mahplot_+3A_mps">MPs</code></td>
<td>
<p>Character vector of MP names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Density plots of Mahalanobis distance.
</p>


<h3>Author(s)</h3>

<p>T. Carruthers
</p>


<h3>References</h3>

<p>Carruthers and Hordyk 2018
</p>

<hr>
<h2 id='make_interim_MP'>Make a custom management procedure (MP)</h2><span id='topic+make_interim_MP'></span><span id='topic+make_projection_MP'></span><span id='topic+make_MP'></span>

<h3>Description</h3>

<p>Function operator that creates a management procedure (MP) by combining an assessment model (function of class <code>Assess</code>) with
a harvest control rule (function of class <code>HCR</code>). The resulting function can then be tested in closed-loop simulation via
<code><a href="MSEtool.html#topic+runMSE">MSEtool::runMSE()</a></code>.
</p>

<ul>
<li><p> Use <code>make_MP</code> to specify constant TAC between assessments; the frequency of
assessments is specified in <code>OM@interval</code>.
</p>
</li>
<li><p> Use <code>make_projection_MP</code> to set catches according to a schedule set by projections,
specify assessment frequency in argument <code>assessment_interval</code> and ensure that <code>OM@interval &lt;- 1</code>.
</p>
</li>
<li><p> Use <code>make_interim_MP</code> to use an interim procedure to adjust the TAC between
assessments using an index (Huynh et al. 2020), with the frequency of assessments specified in argument <code>assessment_interval</code> when
making the MP; ensure that <code>OM@interval &lt;- 1</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>make_interim_MP(
  .Assess = "SCA",
  .HCR = "HCR_MSY",
  AddInd = "VB",
  assessment_interval = 5,
  type = c("buffer", "mean", "loess", "none"),
  type_par = NULL,
  diagnostic = c("min", "full", "none"),
  ...
)

make_projection_MP(
  .Assess = "SCA",
  .HCR = "HCR_MSY",
  assessment_interval = 5,
  Ftarget = expression(Assessment@FMSY),
  proj_args = list(process_error = 1, p_sim = 1),
  diagnostic = c("min", "full", "none"),
  ...
)

make_MP(.Assess, .HCR, diagnostic = c("min", "full", "none"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_interim_MP_+3A_.assess">.Assess</code></td>
<td>
<p>Assessment model, a function of class <code>Assess</code>.</p>
</td></tr>
<tr><td><code id="make_interim_MP_+3A_.hcr">.HCR</code></td>
<td>
<p>Harvest control rule, a function of class <code>HCR</code>. Currently not used in projection MPs.</p>
</td></tr>
<tr><td><code id="make_interim_MP_+3A_addind">AddInd</code></td>
<td>
<p>A vector of integers or character strings indicating the indices to be used in the assessment model.
Integers assign the index to the corresponding index in Data@AddInd, &quot;B&quot; (or 0) represents total biomass in Data@Ind,
&quot;VB&quot; represents vulnerable biomass in Data@VInd, and &quot;SSB&quot; represents spawning stock biomass in Data@SpInd. For the interim
procedure, the function will use the first index in <code>AddInd</code>.</p>
</td></tr>
<tr><td><code id="make_interim_MP_+3A_assessment_interval">assessment_interval</code></td>
<td>
<p>The time interval for when the assessment model is applied (number of years). In all other years, the
interim procedure is applied.</p>
</td></tr>
<tr><td><code id="make_interim_MP_+3A_type">type</code></td>
<td>
<p>How the index is used to calculate the TAC in the interim procedure. See details.</p>
</td></tr>
<tr><td><code id="make_interim_MP_+3A_type_par">type_par</code></td>
<td>
<p>A control parameter for the interim procedure. See details.</p>
</td></tr>
<tr><td><code id="make_interim_MP_+3A_diagnostic">diagnostic</code></td>
<td>
<p>A character string describing if any additional diagnostic information from the
assessment models will be collected during the closed-loop simulation. <code>"min"</code> (minimal) will collect information
on convergence (default) and <code>"full"</code> will also collect the model estimates of biomass and F generated by <code>.Assess</code>.
<code>"none"</code> skips this step.</p>
</td></tr>
<tr><td><code id="make_interim_MP_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>.Assess</code> and <code>.HCR</code>.</p>
</td></tr>
<tr><td><code id="make_interim_MP_+3A_ftarget">Ftarget</code></td>
<td>
<p>An expression that the MP will evaluate to identify the F used in the projection. See <a href="#topic+projection">projection</a> and example.</p>
</td></tr>
<tr><td><code id="make_interim_MP_+3A_proj_args">proj_args</code></td>
<td>
<p>Additional arguments for <a href="#topic+projection">projection</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>make_interim_MP</code> creates an MP that runs the interim procedure (updating the TAC according to index observations in between periodic
assessment intervals. <strong>Always ensure to set:</strong> <code>OM@interval &lt;- 1</code>. The assessment frequency is specified in argument
<code>assessment_interval</code>.
</p>
<p>In the year when the assessment is applied, the TAC is set by fitting the model and then running the harvest control rule. Between assessments,
the TAC is updated as
</p>
<p style="text-align: center;"><code class="reqn">
\textrm{TAC}_{y+1} = C_{\textrm{ref}} (I_y + b \times s)/(I_{\textrm{ref}} + b \times s)
</code>
</p>

<p>where <code>Cref</code> is the TAC calculated from the most recent assessment, <code>Iref</code> is the value of the index when <code>Cref</code> was calculated
(see Equations 6 and 7 of Huynh et al. 2020). The value of <code>I_y</code> depends on <code>type</code>, with <code>b</code> and <code>s</code> equal zero unless
<code>type = "buffer"</code>:
</p>

<ul>
<li> <p><code>"buffer"</code> - <code>I_y</code> is the most recent index with <code>b</code> is specifed by <code>type_par</code> (default = 1), and <code>s</code> is
the standard deviation of index residuals from the most recent assessment.
</p>
</li>
<li> <p><code>"mean"</code> - <code>I_y</code> is the mean value of the index over the most recent <code>type_par</code> years (default = 3).
</p>
</li>
<li> <p><code>"loess"</code> - <code>I_y</code> is the most recent index predicted by a <a href="stats.html#topic+loess">loess</a> smoother applied over the entire time series of the index.
Use <code>type_par</code> to adjust the <code>span</code> parameter (default = 0.75).
</p>
</li>
<li> <p><code>"none"</code> - <code>I_y</code> is the most recent index. Index values are not adjusted in the interim procedure.
</p>
</li></ul>



<h3>Value</h3>

<p>A function of class <code>MP</code>.
</p>


<h3>References</h3>

<p>Huynh et al. 2020. The interim management procedure approach for assessed stocks: Responsive management advice and lower assessment
frequency. Fish Fish. 21:663679. <a href="https://doi.org/10.1111/faf.12453">doi:10.1111/faf.12453</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+HCR_ramp">HCR_ramp</a> <a href="#topic+HCR_MSY">HCR_MSY</a> <a href="#topic+diagnostic">diagnostic</a> <a href="#topic+retrospective_AM">retrospective_AM</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Interim MPs
MP_buffer_5 &lt;- make_interim_MP(assessment_interval = 5)
MP_buffer_10 &lt;- make_interim_MP(assessment_interval = 10)
OM &lt;- MSEtool::testOM
OM@interval &lt;- 1

MSE &lt;- MSEtool::runMSE(OM, MPs = c("MP_buffer_5", "MP_buffer_10")) 

# A statistical catch-at-age model with a 40-10 control rule
SCA_40_10 &lt;- make_MP(SCA, HCR40_10)

# An SCA that will produce convergence diagnostics
SCA_40_10 &lt;- make_MP(SCA, HCR40_10, diagnostic = "min")

# MP with an SCA that uses a Ricker stock-recruit function.
SCA_Ricker &lt;- make_MP(SCA, HCR_MSY, SR = "Ricker")
show(SCA_Ricker)


# TAC is calculated annually from triennial assessments with projections between
# assessments with F = 0.75 FMSY
# Projections by default assume no process error.
OM &lt;- MSEtool::testOM
OM@interval &lt;- 1
pMP &lt;- make_projection_MP(SCA, assessment_interval = 3, 
                          Ftarget = expression(0.75 * Assessment@FMSY),
                          proj_args = list(process_error = 1))


</code></pre>

<hr>
<h2 id='Model-based-MP'>Model-based management procedures</h2><span id='topic+Model-based-MP'></span><span id='topic+MP'></span><span id='topic+Data-rich-MP'></span><span id='topic+SCA_MSY'></span><span id='topic+SCA_75MSY'></span><span id='topic+SCA_4010'></span><span id='topic+DDSS_MSY'></span><span id='topic+DDSS_75MSY'></span><span id='topic+DDSS_4010'></span><span id='topic+SP_MSY'></span><span id='topic+SP_75MSY'></span><span id='topic+SP_4010'></span><span id='topic+SSS_MSY'></span><span id='topic+SSS_75MSY'></span><span id='topic+SSS_4010'></span>

<h3>Description</h3>

<p>A suite of model-based management procedures (MPs) included in the package. Additional MPs,
with specific model configurations (e.g., stock-recruit function or fixing certain parameters) or alternative
ramped harvest control rules can be created with <a href="#topic+make_MP">make_MP</a> and the available Assess and HCR objects with constant
TAC between assessment years.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SCA_MSY(x, Data, reps = 1, diagnostic = "min")

SCA_75MSY(x, Data, reps = 1, diagnostic = "min")

SCA_4010(x, Data, reps = 1, diagnostic = "min")

DDSS_MSY(x, Data, reps = 1, diagnostic = "min")

DDSS_75MSY(x, Data, reps = 1, diagnostic = "min")

DDSS_4010(x, Data, reps = 1, diagnostic = "min")

SP_MSY(x, Data, reps = 1, diagnostic = "min")

SP_75MSY(x, Data, reps = 1, diagnostic = "min")

SP_4010(x, Data, reps = 1, diagnostic = "min")

SSS_MSY(x, Data, reps = 1, diagnostic = "min")

SSS_75MSY(x, Data, reps = 1, diagnostic = "min")

SSS_4010(x, Data, reps = 1, diagnostic = "min")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Model-based-MP_+3A_x">x</code></td>
<td>
<p>A position in the Data object.</p>
</td></tr>
<tr><td><code id="Model-based-MP_+3A_data">Data</code></td>
<td>
<p>An object of class Data</p>
</td></tr>
<tr><td><code id="Model-based-MP_+3A_reps">reps</code></td>
<td>
<p>Numeric, the number of stochastic replicates for the management advice.</p>
</td></tr>
<tr><td><code id="Model-based-MP_+3A_diagnostic">diagnostic</code></td>
<td>
<p>Character string describing the assessment diagnostic to save, see <a href="#topic+make_MP">make_MP</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class Rec which contains the management recommendation.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>SCA_MSY()</code>: A statistical catch-at-age model with a TAC recommendation based on fishing at FMSY,
and default arguments for configuring <a href="#topic+SCA">SCA</a>.
</p>
</li>
<li> <p><code>SCA_75MSY()</code>: An SCA with a TAC recommendation based on fishing at 75% of FMSY.
</p>
</li>
<li> <p><code>SCA_4010()</code>: An SCA with a 40-10 control rule.
</p>
</li>
<li> <p><code>DDSS_MSY()</code>: A state-space delay difference model with a TAC recommendation based on fishing at FMSY,
and default arguments for configuring <a href="#topic+DD_SS">DD_SS</a>.
</p>
</li>
<li> <p><code>DDSS_75MSY()</code>: A state-space delay difference model with a TAC recommendation based on fishing at 75% of FMSY.
</p>
</li>
<li> <p><code>DDSS_4010()</code>: A state-space delay difference model with a 40-10 control rule.
</p>
</li>
<li> <p><code>SP_MSY()</code>: A surplus production model with a TAC recommendation based on fishing at FMSY,
and default arguments for configuring <a href="#topic+SP">SP</a>.
</p>
</li>
<li> <p><code>SP_75MSY()</code>: A surplus production model with a TAC recommendation based on fishing at 75% of FMSY.
</p>
</li>
<li> <p><code>SP_4010()</code>: A surplus production model with a 40-10 control rule.
</p>
</li>
<li> <p><code>SSS_MSY()</code>: Simple stock synthesis (terminal depletion fixed to 0.4 in <a href="#topic+SSS">SSS</a>) with a TAC recommendation based on fishing at FMSY.
</p>
</li>
<li> <p><code>SSS_75MSY()</code>: Simple stock synthesis (terminal depletion fixed to 0.4) with with a TAC recommendation based on fishing at 75% FMSY.
</p>
</li>
<li> <p><code>SSS_4010()</code>: Simple stock synthesis (terminal depletion fixed to 0.4) with a 40-10 control rule.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>MSEtool::avail("MP", package = "SAMtool")


myMSE &lt;- MSEtool::runMSE(MSEtool::testOM, MPs = c("FMSYref", "SCA_4010"))

</code></pre>

<hr>
<h2 id='pcod'>Pacific cod in Area 5ABCD (Hecate Strait and Queen Charlotte Sound), British Columbia, Canada</h2><span id='topic+pcod'></span>

<h3>Description</h3>

<p>A list containing an operating model, data set, and priors for updating the operating model
using the conditioning model <a href="#topic+RCM">RCM</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcod
</code></pre>


<h3>Format</h3>

<p>A list containing an object of class OM, <a href="#topic+RCMdata-class">RCMdata</a>, and a list of priors
for index catchability.
</p>


<h3>References</h3>

<p>Forrest, R.E., Anderson, S.C., Grandin, C.J., and Starr, P.J. 2020. Assessment of Pacific Cod (Gadus macrocephalus)
for Hecate Strait and Queen Charlotte Sound (Area 5ABCD), and West Coast Vancouver Island (Area 3CD) in 2018.
DFO Can. Sci. Advis. Sec. Res. Doc. 2020/070. v + 215 p.
</p>
<p>DFO. 2021. Status Update of Pacifc Cod (Gadus macrocephalus) for West Coast Vancouver Island (Area 3CD),
and Hecate Strait and Queen Charlotte Sound (Area 5ABCD) in 2020. DFO Can. Sci. Advis. Sec. Sci. Resp. 2021/002.
</p>


<h3>See Also</h3>

<p><a href="#topic+RCM">RCM</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pcod)

</code></pre>

<hr>
<h2 id='plot_betavar'>Plots a beta variable</h2><span id='topic+plot_betavar'></span>

<h3>Description</h3>

<p>Plots the probability distribution function of a beta variable from the
mean and standard deviation in either transformed (logit) or untransformed space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_betavar(m, sd, label = NULL, is_logit = FALSE, color = "black")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_betavar_+3A_m">m</code></td>
<td>
<p>A vector of means of the distribution.</p>
</td></tr>
<tr><td><code id="plot_betavar_+3A_sd">sd</code></td>
<td>
<p>A vector of standard deviations of the distribution.</p>
</td></tr>
<tr><td><code id="plot_betavar_+3A_label">label</code></td>
<td>
<p>Name of the variable to be used as x-axis label.</p>
</td></tr>
<tr><td><code id="plot_betavar_+3A_is_logit">is_logit</code></td>
<td>
<p>Logical that indicates whether the means and standard deviations are in
logit (TRUE) or normal (FALSE) space.</p>
</td></tr>
<tr><td><code id="plot_betavar_+3A_color">color</code></td>
<td>
<p>A vector of colors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the probability distribution function. Vertical dotted line
indicates mean of distribution. This function can plot multiple curves when multiple means
and standard deviations are provided.
</p>


<h3>Author(s)</h3>

<p>Q. Huynh
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_lognormalvar">plot_lognormalvar()</a></code> <code><a href="#topic+plot_steepness">plot_steepness()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mu &lt;- 0.5
stddev &lt;- 0.1
plot_betavar(mu, stddev) # mean of plot should be 0.5

#logit parameters
mu &lt;- 0
stddev &lt;- 0.1
plot_betavar(mu, stddev, is_logit = TRUE) # mean of plot should be 0.5
</code></pre>

<hr>
<h2 id='plot_composition'>Plot composition data</h2><span id='topic+plot_composition'></span>

<h3>Description</h3>

<p>Plots annual length or age composition data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_composition(
  Year = 1:nrow(obs),
  obs,
  fit = NULL,
  plot_type = c("annual", "bubble_data", "bubble_residuals", "mean", "heat_residuals",
    "hist_residuals"),
  N = rowSums(obs),
  CAL_bins = NULL,
  ages = NULL,
  ind = 1:nrow(obs),
  annual_ylab = "Frequency",
  annual_yscale = c("proportions", "raw"),
  bubble_adj = 1.5,
  bubble_color = c("#99999999", "white"),
  fit_linewidth = 3,
  fit_color = "red"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_composition_+3A_year">Year</code></td>
<td>
<p>A vector of years.</p>
</td></tr>
<tr><td><code id="plot_composition_+3A_obs">obs</code></td>
<td>
<p>A matrix of either length or age composition data. For lengths, rows and columns
should index years and length bin, respectively. For ages, rows and columns should index
years and age, respectively.</p>
</td></tr>
<tr><td><code id="plot_composition_+3A_fit">fit</code></td>
<td>
<p>A matrix of predicted length or age composition from an assessment model.
Same dimensions as obs.</p>
</td></tr>
<tr><td><code id="plot_composition_+3A_plot_type">plot_type</code></td>
<td>
<p>Indicates which plots to create. Options include annual distributions,
bubble plot of the data, and bubble plot of the Pearson residuals, and annual means.</p>
</td></tr>
<tr><td><code id="plot_composition_+3A_n">N</code></td>
<td>
<p>Annual sample sizes. Vector of length <code>nrow(obs)</code>.</p>
</td></tr>
<tr><td><code id="plot_composition_+3A_cal_bins">CAL_bins</code></td>
<td>
<p>A vector of lengths corresponding to the columns in <code>obs</code>.
and <code>fit</code>. Ignored for age data.</p>
</td></tr>
<tr><td><code id="plot_composition_+3A_ages">ages</code></td>
<td>
<p>An optional vector of ages corresponding to the columns in <code>obs</code>.</p>
</td></tr>
<tr><td><code id="plot_composition_+3A_ind">ind</code></td>
<td>
<p>A numeric vector for plotting a subset of rows (which indexes year) of <code>obs</code> and <code>fit</code>.</p>
</td></tr>
<tr><td><code id="plot_composition_+3A_annual_ylab">annual_ylab</code></td>
<td>
<p>Character string for y-axis label when <code>plot_type = "annual"</code>.</p>
</td></tr>
<tr><td><code id="plot_composition_+3A_annual_yscale">annual_yscale</code></td>
<td>
<p>For annual composition plots (<code>plot_type = "annual"</code>), whether the raw values
(&quot;raw&quot;) or frequencies (&quot;proportions&quot;) are plotted.</p>
</td></tr>
<tr><td><code id="plot_composition_+3A_bubble_adj">bubble_adj</code></td>
<td>
<p>Numeric, for adjusting the relative size of bubbles in bubble plots
(larger number = larger bubbles).</p>
</td></tr>
<tr><td><code id="plot_composition_+3A_bubble_color">bubble_color</code></td>
<td>
<p>Colors for negative and positive residuals, respectively, for bubble plots.</p>
</td></tr>
<tr><td><code id="plot_composition_+3A_fit_linewidth">fit_linewidth</code></td>
<td>
<p>Argument <code>lwd</code> for fitted line.</p>
</td></tr>
<tr><td><code id="plot_composition_+3A_fit_color">fit_color</code></td>
<td>
<p>Color of fitted line.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plots depending on <code>plot_type</code>. Invisibly returns a matrix or list of values that were plotted.
</p>


<h3>Author(s)</h3>

<p>Q. Huynh
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot_composition(obs = SimulatedData@CAA[1, 1:16, ])
plot_composition(
  obs = SimulatedData@CAA[1, , ], 
  plot_type = "bubble_data", 
  ages = 0:SimulatedData@MaxAge
)
                 
SCA_fit &lt;- SCA(x = 2, Data = SimulatedData)
plot_composition(
  obs = SimulatedData@CAA[1, , ], fit = SCA_fit@C_at_age,
  plot_type = "mean", ages = 0:SimulatedData@MaxAge
)

plot_composition(
  obs = SimulatedData@CAA[1, 1:16, ], fit = SCA_fit@C_at_age[1:16, ],
  plot_type = "annual", ages = 0:SimulatedData@MaxAge
)

plot_composition(
  obs = SimulatedData@CAA[1, , ], fit = SCA_fit@C_at_age,
  plot_type = "bubble_residuals", ages = 0:SimulatedData@MaxAge
)

plot_composition(
  obs = SimulatedData@CAA[1, , ], fit = SCA_fit@C_at_age,
  plot_type = "heat_residuals", ages = 0:SimulatedData@MaxAge
)

plot_composition(
  obs = SimulatedData@CAA[1, , ], fit = SCA_fit@C_at_age,
  plot_type = "hist_residuals", ages = 0:SimulatedData@MaxAge
)

</code></pre>

<hr>
<h2 id='plot_crosscorr'>Produce a cross-correlation plot of the derived data arising from getinds(MSE_object)</h2><span id='topic+plot_crosscorr'></span>

<h3>Description</h3>

<p>Produce a cross-correlation plot of the derived data arising from getinds(MSE_object)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_crosscorr(
  indPPD,
  indData,
  pp = 1,
  dnam = c("CS", "CV", "CM", "IS", "MLS"),
  res = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_crosscorr_+3A_indppd">indPPD</code></td>
<td>
<p>A 3D array of results arising from running getind on an MSE of the Null operating model (type of data/stat (e.g. mean catches),time period (chunk), simulation)</p>
</td></tr>
<tr><td><code id="plot_crosscorr_+3A_inddata">indData</code></td>
<td>
<p>A 3D array of results arising from running getind on an MSE of the Alternative operating model (type of data/stat (e.g. mean catches),time period (chunk), simulation)</p>
</td></tr>
<tr><td><code id="plot_crosscorr_+3A_pp">pp</code></td>
<td>
<p>Positive integer, the number of time chunks (blocks of years normally, second dimension of indPPD and indData) to produce the plot for.</p>
</td></tr>
<tr><td><code id="plot_crosscorr_+3A_dnam">dnam</code></td>
<td>
<p>A character vector of names of the data for plotting purposes (as long as dimension 1 of indPPD and indData).</p>
</td></tr>
<tr><td><code id="plot_crosscorr_+3A_res">res</code></td>
<td>
<p>The size of the temporal blocking that created indPPD and indData - this is just used for labelling purposes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cross-correlation plot (ndata-1) x (ndata-1)
</p>


<h3>Author(s)</h3>

<p>T. Carruthers
</p>


<h3>References</h3>

<p>Carruthers and Hordyk 2018
</p>

<hr>
<h2 id='plot_lognormalvar'>Plots a lognormal variable</h2><span id='topic+plot_lognormalvar'></span>

<h3>Description</h3>

<p>Plots the probability distribution function of a lognormal variable from the
mean and standard deviation in either transformed (normal) or untransformed space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_lognormalvar(m, sd, label = NULL, logtransform = FALSE, color = "black")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_lognormalvar_+3A_m">m</code></td>
<td>
<p>A vector of means of the distribution.</p>
</td></tr>
<tr><td><code id="plot_lognormalvar_+3A_sd">sd</code></td>
<td>
<p>A vector of standard deviations of the distribution.</p>
</td></tr>
<tr><td><code id="plot_lognormalvar_+3A_label">label</code></td>
<td>
<p>Name of the variable to be used as x-axis label.</p>
</td></tr>
<tr><td><code id="plot_lognormalvar_+3A_logtransform">logtransform</code></td>
<td>
<p>Indicates whether the mean and standard deviation are in
lognormal (TRUE) or normal (FALSE) space.</p>
</td></tr>
<tr><td><code id="plot_lognormalvar_+3A_color">color</code></td>
<td>
<p>A vector of colors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the probability distribution function. Vertical dotted line
indicates mean of distribution. This function can plot multiple curves when multiple means
and standard deviations are provided.
</p>


<h3>Author(s)</h3>

<p>Q. Huynh
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_betavar">plot_betavar()</a></code> <code><a href="#topic+plot_steepness">plot_steepness()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mu &lt;- 0.5
stddev &lt;- 0.1
plot_lognormalvar(mu, stddev) # mean of plot should be 0.5

#logtransformed parameters
mu &lt;- 0
stddev &lt;- 0.1
plot_lognormalvar(mu, stddev, logtransform = TRUE) # mean of plot should be 1
</code></pre>

<hr>
<h2 id='plot_residuals'>Plot residuals</h2><span id='topic+plot_residuals'></span>

<h3>Description</h3>

<p>Plots figure of residuals (or any time series with predicted mean of zero).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_residuals(
  Year,
  res,
  res_sd = NULL,
  res_sd_CI = 0.95,
  res_upper = NULL,
  res_lower = NULL,
  res_ind_blue = NULL,
  draw_zero = TRUE,
  zero_linetype = 2,
  label = "Residual"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_residuals_+3A_year">Year</code></td>
<td>
<p>A vector of years for the data.</p>
</td></tr>
<tr><td><code id="plot_residuals_+3A_res">res</code></td>
<td>
<p>A vector of residuals.</p>
</td></tr>
<tr><td><code id="plot_residuals_+3A_res_sd">res_sd</code></td>
<td>
<p>A vector of year specific standard deviation for <code>res</code>.</p>
</td></tr>
<tr><td><code id="plot_residuals_+3A_res_sd_ci">res_sd_CI</code></td>
<td>
<p>The confidence interval for the error bars based for <code>res_sd</code>.</p>
</td></tr>
<tr><td><code id="plot_residuals_+3A_res_upper">res_upper</code></td>
<td>
<p>A vector of year-specific upper bounds for the error bars of the residual (in lieu of argument <code>res_CV</code>).</p>
</td></tr>
<tr><td><code id="plot_residuals_+3A_res_lower">res_lower</code></td>
<td>
<p>A vector of year-specific lower bounds for the error bars of the residual (in lieu of argument <code>res_CV</code>).</p>
</td></tr>
<tr><td><code id="plot_residuals_+3A_res_ind_blue">res_ind_blue</code></td>
<td>
<p>Indices of <code>obs</code> for which the plotted residuals and error bars will be blue.</p>
</td></tr>
<tr><td><code id="plot_residuals_+3A_draw_zero">draw_zero</code></td>
<td>
<p>Indicates whether a horizontal line should be drawn at zero.</p>
</td></tr>
<tr><td><code id="plot_residuals_+3A_zero_linetype">zero_linetype</code></td>
<td>
<p>Passes argument <code>lty</code> (e.g. solid line = 1, dotted = 2) to <code>draw_zero</code>.</p>
</td></tr>
<tr><td><code id="plot_residuals_+3A_label">label</code></td>
<td>
<p>Character string that describes the data to label the y-axis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of model residuals by year (optionally, with error bars).
</p>


<h3>Author(s)</h3>

<p>Q. Huynh
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_timeseries">plot_timeseries()</a></code>
</p>

<hr>
<h2 id='plot_SR'>Plot stock-recruitment function</h2><span id='topic+plot_SR'></span>

<h3>Description</h3>

<p>Plot stock-recruitment (with recruitment deviations if estimated).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_SR(
  Spawners,
  expectedR,
  R0 = NULL,
  S0 = NULL,
  rec_dev = NULL,
  trajectory = FALSE,
  y_zoom = NULL,
  ylab = "Recruitment"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_SR_+3A_spawners">Spawners</code></td>
<td>
<p>A vector of the number of the spawners (x-axis).</p>
</td></tr>
<tr><td><code id="plot_SR_+3A_expectedr">expectedR</code></td>
<td>
<p>A vector of the expected recruitment (from the
stock-recruit function) corresponding to values of <code>Spawners</code>.</p>
</td></tr>
<tr><td><code id="plot_SR_+3A_r0">R0</code></td>
<td>
<p>Virgin recruitment.</p>
</td></tr>
<tr><td><code id="plot_SR_+3A_s0">S0</code></td>
<td>
<p>Virgin spawners.</p>
</td></tr>
<tr><td><code id="plot_SR_+3A_rec_dev">rec_dev</code></td>
<td>
<p>If recruitment deviations are estimated, a vector of estimated recruitment
(in normal space) corresponding to values of <code>Spawners</code>.</p>
</td></tr>
<tr><td><code id="plot_SR_+3A_trajectory">trajectory</code></td>
<td>
<p>Indicates whether arrows will be drawn showing the trajectory of
spawners and recruitment deviations over time.</p>
</td></tr>
<tr><td><code id="plot_SR_+3A_y_zoom">y_zoom</code></td>
<td>
<p>If recruitment deviations are plotted, the y-axis limit relative to
maximum expected recruitment <code>expectedR</code>. If <code>NULL</code>, all recruitment values are plotted.</p>
</td></tr>
<tr><td><code id="plot_SR_+3A_ylab">ylab</code></td>
<td>
<p>Character string for label on y-axis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A stock-recruit plot
</p>


<h3>Author(s)</h3>

<p>Q. Huynh
</p>

<hr>
<h2 id='plot_steepness'>Plots probability distribution function of stock-recruit steepness</h2><span id='topic+plot_steepness'></span>

<h3>Description</h3>

<p>Plots the probability distribution function of steepness from the
mean and standard deviation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_steepness(
  m,
  sd,
  is_transform = FALSE,
  SR = c("BH", "Ricker"),
  color = "black"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_steepness_+3A_m">m</code></td>
<td>
<p>The mean of the distribution (vectorized).</p>
</td></tr>
<tr><td><code id="plot_steepness_+3A_sd">sd</code></td>
<td>
<p>The standard deviation of the distribution (vectorized).</p>
</td></tr>
<tr><td><code id="plot_steepness_+3A_is_transform">is_transform</code></td>
<td>
<p>Logical, whether the mean and standard deviation are in normal space
(FALSE) or transformed space.</p>
</td></tr>
<tr><td><code id="plot_steepness_+3A_sr">SR</code></td>
<td>
<p>The stock recruitment relationship (determines the range and, if relevant, transformation of
steepness).</p>
</td></tr>
<tr><td><code id="plot_steepness_+3A_color">color</code></td>
<td>
<p>A vector of colors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the probability distribution function. Vertical dotted line
indicates mean of distribution.
</p>


<h3>Note</h3>

<p>The function samples from a beta distribution with parameters alpha and beta
that are converted from the mean and standard deviation. Then, the distribution is
transformed from 0 - 1 to 0.2 - 1.
</p>


<h3>Author(s)</h3>

<p>Q. Huynh
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_lognormalvar">plot_lognormalvar()</a></code> <code><a href="#topic+plot_betavar">plot_betavar()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mu &lt;- 0.8
stddev &lt;- 0.1
plot_steepness(mu, stddev)
</code></pre>

<hr>
<h2 id='plot_timeseries'>Plot time series of data</h2><span id='topic+plot_timeseries'></span>

<h3>Description</h3>

<p>Plot time series of observed (with lognormally-distributed error bars) vs.
predicted data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_timeseries(
  Year,
  obs,
  fit = NULL,
  obs_CV = NULL,
  obs_CV_CI = 0.95,
  obs_upper = NULL,
  obs_lower = NULL,
  obs_ind_blue = NULL,
  fit_linewidth = 3,
  fit_color = "red",
  label = "Observed data"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_timeseries_+3A_year">Year</code></td>
<td>
<p>A vector of years for the data.</p>
</td></tr>
<tr><td><code id="plot_timeseries_+3A_obs">obs</code></td>
<td>
<p>A vector of observed data.</p>
</td></tr>
<tr><td><code id="plot_timeseries_+3A_fit">fit</code></td>
<td>
<p>A vector of predicted data (e.g., from an assessment model).</p>
</td></tr>
<tr><td><code id="plot_timeseries_+3A_obs_cv">obs_CV</code></td>
<td>
<p>A vector of year-specific coefficient of variation in the observed data.</p>
</td></tr>
<tr><td><code id="plot_timeseries_+3A_obs_cv_ci">obs_CV_CI</code></td>
<td>
<p>The confidence interval for the error bars based for <code>obs_CV</code>.</p>
</td></tr>
<tr><td><code id="plot_timeseries_+3A_obs_upper">obs_upper</code></td>
<td>
<p>A vector of year-specific upper bounds for the error bars of the observed data (in lieu of argument <code>obs_CV</code>).</p>
</td></tr>
<tr><td><code id="plot_timeseries_+3A_obs_lower">obs_lower</code></td>
<td>
<p>A vector of year-specific lower bounds for the error bars of the observed data (in lieu of argument <code>obs_CV</code>).</p>
</td></tr>
<tr><td><code id="plot_timeseries_+3A_obs_ind_blue">obs_ind_blue</code></td>
<td>
<p>Indices of <code>obs</code> for which the plotted points and error bars will be blue.</p>
</td></tr>
<tr><td><code id="plot_timeseries_+3A_fit_linewidth">fit_linewidth</code></td>
<td>
<p>Argument <code>lwd</code> for fitted line.</p>
</td></tr>
<tr><td><code id="plot_timeseries_+3A_fit_color">fit_color</code></td>
<td>
<p>Color of fitted line.</p>
</td></tr>
<tr><td><code id="plot_timeseries_+3A_label">label</code></td>
<td>
<p>Character string that describes the data to label the y-axis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of annual observed data and predicted values from a model.
</p>


<h3>Author(s)</h3>

<p>Q. Huynh
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_residuals">plot_residuals()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Red_snapper)
plot_timeseries(Red_snapper@Year, Red_snapper@Cat[1, ],
obs_CV = Red_snapper@CV_Cat, label = "Catch")
</code></pre>

<hr>
<h2 id='plot.Assessment'>Plot Assessment object</h2><span id='topic+plot.Assessment'></span><span id='topic+plot+2CAssessment+2Cmissing-method'></span><span id='topic+plot+2CAssessment+2Cretro-method'></span>

<h3>Description</h3>

<p>Produces HTML file (via markdown) figures of parameter estimates and output from an <a href="#topic+Assessment-class">Assessment</a> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Assessment,missing'
plot(
  x,
  filename = paste0("report_", x@Model),
  dir = tempdir(),
  ret_yr = 0L,
  open_file = TRUE,
  quiet = TRUE,
  render_args = list(),
  ...
)

## S4 method for signature 'Assessment,retro'
plot(
  x,
  y,
  filename = paste0("report_", x@Model),
  dir = tempdir(),
  open_file = TRUE,
  quiet = TRUE,
  render_args = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.Assessment_+3A_x">x</code></td>
<td>
<p>An object of class <a href="#topic+Assessment-class">Assessment</a>.</p>
</td></tr>
<tr><td><code id="plot.Assessment_+3A_filename">filename</code></td>
<td>
<p>Character string for the name of the markdown and HTML files.</p>
</td></tr>
<tr><td><code id="plot.Assessment_+3A_dir">dir</code></td>
<td>
<p>The directory in which the markdown and HTML files will be saved.</p>
</td></tr>
<tr><td><code id="plot.Assessment_+3A_ret_yr">ret_yr</code></td>
<td>
<p>If greater than zero, then a retrospective analysis will be performed and results will be reported. The integer here corresponds
to the number of peels (the maximum number of terminal years for which the data are removed).</p>
</td></tr>
<tr><td><code id="plot.Assessment_+3A_open_file">open_file</code></td>
<td>
<p>Logical, whether the HTML document is opened after it is rendered.</p>
</td></tr>
<tr><td><code id="plot.Assessment_+3A_quiet">quiet</code></td>
<td>
<p>Logical, whether to silence the markdown rendering function.</p>
</td></tr>
<tr><td><code id="plot.Assessment_+3A_render_args">render_args</code></td>
<td>
<p>Arguments to pass to <a href="rmarkdown.html#topic+render">render</a>.</p>
</td></tr>
<tr><td><code id="plot.Assessment_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
<tr><td><code id="plot.Assessment_+3A_y">y</code></td>
<td>
<p>An object of class <a href="#topic+retro-class">retro</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns invisibly the output from <a href="rmarkdown.html#topic+render">render</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+retrospective">retrospective</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>output &lt;- DD_TMB(Data = Simulation_1)


plot(output)

</code></pre>

<hr>
<h2 id='plot.prof'>Plot profile object</h2><span id='topic+plot.prof'></span><span id='topic+plot+2Cprof+2Cmissing-method'></span>

<h3>Description</h3>

<p>Generates a profile plot generated by <a href="#topic+profile">profile</a>. If a two-parameter profile is performed, then a contour
plot of the likelihood surface is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'prof,missing'
plot(x, contour_levels = 20, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.prof_+3A_x">x</code></td>
<td>
<p>An object of class <a href="#topic+prof-class">prof</a> returned by <a href="#topic+profile">profile</a>.</p>
</td></tr>
<tr><td><code id="plot.prof_+3A_contour_levels">contour_levels</code></td>
<td>
<p>Integer, passed to <code>nlevels</code> argument of <a href="graphics.html#topic+contour">contour</a>.</p>
</td></tr>
<tr><td><code id="plot.prof_+3A_...">...</code></td>
<td>
<p>Miscellaneous. Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A likelihood profile plot, either a one-dimensional line plot or a two-dimensional contour plot.
</p>


<h3>Author(s)</h3>

<p>Q. Huynh
</p>

<hr>
<h2 id='plot.RCModel'>Plot RCM scope output</h2><span id='topic+plot.RCModel'></span><span id='topic+plot+2CRCModel+2Cmissing-method'></span><span id='topic+compare_RCM'></span>

<h3>Description</h3>

<p>Produces HTML file (via markdown) figures of parameter estimates and output from an <a href="#topic+Assessment-class">Assessment</a> object.
Plots histograms of operating model parameters that are updated by the RCM scoping function, as well as diagnostic plots
for the fits to the RCM for each simulation. <code>compare_RCM</code> plots a short report that compares output from multiple RCM objects,
assuming the same model structure, i.e., identical matrix and array dimensions among models, but different data weightings, data omissions, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'RCModel,missing'
plot(
  x,
  compare = FALSE,
  filename = "RCM",
  dir = tempdir(),
  sims = 1:x@OM@nsim,
  Year = NULL,
  f_name = NULL,
  s_name = NULL,
  MSY_ref = c(0.5, 1),
  bubble_adj = 1.5,
  scenario = list(),
  title = NULL,
  open_file = TRUE,
  quiet = TRUE,
  render_args,
  ...
)

compare_RCM(
  ...,
  compare = FALSE,
  filename = "compare_RCM",
  dir = tempdir(),
  Year = NULL,
  f_name = NULL,
  s_name = NULL,
  MSY_ref = c(0.5, 1),
  bubble_adj = 1.5,
  scenario = list(),
  title = NULL,
  open_file = TRUE,
  quiet = TRUE,
  render_args
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.RCModel_+3A_x">x</code></td>
<td>
<p>An object of class <a href="#topic+RCModel-class">RCModel</a> (output from <a href="#topic+RCM">RCM</a>).</p>
</td></tr>
<tr><td><code id="plot.RCModel_+3A_compare">compare</code></td>
<td>
<p>Logical, if TRUE, the function will run <code>runMSE</code> to compare the historical period of the operating model
and the RCM output.</p>
</td></tr>
<tr><td><code id="plot.RCModel_+3A_filename">filename</code></td>
<td>
<p>Character string for the name of the markdown and HTML files.</p>
</td></tr>
<tr><td><code id="plot.RCModel_+3A_dir">dir</code></td>
<td>
<p>The directory in which the markdown and HTML files will be saved.</p>
</td></tr>
<tr><td><code id="plot.RCModel_+3A_sims">sims</code></td>
<td>
<p>A logical vector of length <code>x@OM@nsim</code> or a numeric vector indicating which simulations to keep.</p>
</td></tr>
<tr><td><code id="plot.RCModel_+3A_year">Year</code></td>
<td>
<p>Optional, a vector of years for the historical period for plotting.</p>
</td></tr>
<tr><td><code id="plot.RCModel_+3A_f_name">f_name</code></td>
<td>
<p>Character vector for fleet names.</p>
</td></tr>
<tr><td><code id="plot.RCModel_+3A_s_name">s_name</code></td>
<td>
<p>Character vector for survey names.</p>
</td></tr>
<tr><td><code id="plot.RCModel_+3A_msy_ref">MSY_ref</code></td>
<td>
<p>A numeric vector for reference horizontal lines for B/BMSY plots.</p>
</td></tr>
<tr><td><code id="plot.RCModel_+3A_bubble_adj">bubble_adj</code></td>
<td>
<p>A number to adjust the size of bubble plots (for residuals of age and length comps).</p>
</td></tr>
<tr><td><code id="plot.RCModel_+3A_scenario">scenario</code></td>
<td>
<p>Optional, a named list to label each simulation in the RCM for plotting, e.g.:
<code>list(names = c("low M", "high M"), col = c("blue", "red"))</code>.</p>
</td></tr>
<tr><td><code id="plot.RCModel_+3A_title">title</code></td>
<td>
<p>Optional character string for an alternative title for the markdown report.</p>
</td></tr>
<tr><td><code id="plot.RCModel_+3A_open_file">open_file</code></td>
<td>
<p>Logical, whether the HTML document is opened after it is rendered.</p>
</td></tr>
<tr><td><code id="plot.RCModel_+3A_quiet">quiet</code></td>
<td>
<p>Logical, whether to silence the markdown rendering function.</p>
</td></tr>
<tr><td><code id="plot.RCModel_+3A_render_args">render_args</code></td>
<td>
<p>A list of other arguments to pass to <a href="rmarkdown.html#topic+render">render</a>.</p>
</td></tr>
<tr><td><code id="plot.RCModel_+3A_...">...</code></td>
<td>
<p>For <code>compare_RCM</code>, multiple RCM objects for comparison.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns invisibly the output from <a href="rmarkdown.html#topic+render">render</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+RCModel-class">RCModel</a> <a href="#topic+RCM">RCM</a>
</p>

<hr>
<h2 id='plot.retro'>Methods for retro object</h2><span id='topic+plot.retro'></span><span id='topic+plot+2Cretro+2Cmissing-method'></span><span id='topic+summary+2Cretro-method'></span><span id='topic+summary.retro'></span>

<h3>Description</h3>

<p>plot and summary functions for retro object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'retro,missing'
plot(x, color = NULL)

## S4 method for signature 'retro'
summary(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.retro_+3A_x">x</code></td>
<td>
<p>An object of class <a href="#topic+retro-class">retro</a>.</p>
</td></tr>
<tr><td><code id="plot.retro_+3A_color">color</code></td>
<td>
<p>An optional character vector of colors for plotting.</p>
</td></tr>
<tr><td><code id="plot.retro_+3A_object">object</code></td>
<td>
<p>An object of class <a href="#topic+retro-class">retro</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A series of plots showing retrospective patterns in fishing mortality, spawning biomass, recruitment, etc.
</p>


<h3>Author(s)</h3>

<p>Q. Huynh
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
res &lt;- SP(Data = swordfish)
ret &lt;- retrospective(res, figure = FALSE)

summary(ret)
plot(ret)

</code></pre>

<hr>
<h2 id='posterior'>Sample posterior of TMB models in SAMtool</h2><span id='topic+posterior'></span><span id='topic+posterior+2CRCModel-method'></span><span id='topic+posterior.RCModel'></span><span id='topic+posterior+2CAssessment-method'></span><span id='topic+posterior.Assessment'></span><span id='topic+RCMstan'></span>

<h3>Description</h3>

<p>A convenient wrapper function (<code>posterior</code>) to sample the posterior using MCMC in rstan
and returns a <code>stanfit</code> object for diagnostics. Use <code>RCMstan</code> to update the RCM and the enclosed operating model
with MCMC samples..
</p>


<h3>Usage</h3>

<pre><code class='language-R'>posterior(x, ...)

## S4 method for signature 'RCModel'
posterior(
  x,
  priors_only = FALSE,
  laplace = FALSE,
  chains = 2,
  iter = 2000,
  warmup = floor(iter/2),
  thin = 5,
  seed = 34,
  init = "last.par.best",
  cores = chains,
  ...
)

## S4 method for signature 'Assessment'
posterior(x, priors_only = FALSE, ...)

RCMstan(RCModel, stanfit, sim, cores = 1, silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posterior_+3A_x">x</code></td>
<td>
<p>An object of class <a href="#topic+Assessment-class">Assessment</a> or <a href="#topic+RCModel-class">RCModel</a>.</p>
</td></tr>
<tr><td><code id="posterior_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code>rstan::sampling</code> via <code>tmbstan::tmbstan</code>.</p>
</td></tr>
<tr><td><code id="posterior_+3A_priors_only">priors_only</code></td>
<td>
<p>Logical, whether to set the likelihood to zero and sample the priors only.</p>
</td></tr>
<tr><td><code id="posterior_+3A_laplace">laplace</code></td>
<td>
<p>Logical, whether to do the Laplace approximation for random parameters.</p>
</td></tr>
<tr><td><code id="posterior_+3A_chains">chains</code></td>
<td>
<p>The numer of MCMC chains.</p>
</td></tr>
<tr><td><code id="posterior_+3A_iter">iter</code></td>
<td>
<p>The number of iterations for each chain, including warmup.</p>
</td></tr>
<tr><td><code id="posterior_+3A_warmup">warmup</code></td>
<td>
<p>The number of burnin iterations</p>
</td></tr>
<tr><td><code id="posterior_+3A_thin">thin</code></td>
<td>
<p>The frequency at which iterations are kept (e.g., <code>5</code> saves every fifth iteration)</p>
</td></tr>
<tr><td><code id="posterior_+3A_seed">seed</code></td>
<td>
<p>Seed for random number generator during the MCMC.</p>
</td></tr>
<tr><td><code id="posterior_+3A_init">init</code></td>
<td>
<p>The initial values of parameters for starting the MCMC chain. See <code>tmbstan::tmbstan</code>.</p>
</td></tr>
<tr><td><code id="posterior_+3A_cores">cores</code></td>
<td>
<p>The number of cores for running in parallel, e.g., one core per MCMC chain. Used in <code>RCMstan</code>
for reconstructing the population.</p>
</td></tr>
<tr><td><code id="posterior_+3A_rcmodel">RCModel</code></td>
<td>
<p>An object of class <code>RCModel</code></p>
</td></tr>
<tr><td><code id="posterior_+3A_stanfit">stanfit</code></td>
<td>
<p>An object of class <code>stanfit</code> returned by <code>posterior</code>.</p>
</td></tr>
<tr><td><code id="posterior_+3A_sim">sim</code></td>
<td>
<p>A matrix of <code>RCModel@OM@nsim</code> rows and 2 columns that specifies the samples used to update the
operating model. The first column specifies the chain and the second columns specifies the MCMC iteration.</p>
</td></tr>
<tr><td><code id="posterior_+3A_silent">silent</code></td>
<td>
<p>Logical to indicate if progress messages should be printed to console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>posterior</code> returns an object of class <code>stanfit</code>. See <code>class?stanfit</code>.
</p>
<p><code>RCMstan</code> returns an updated <code>RCModel</code>.
</p>


<h3>Online Documentation</h3>

<p>A vignette on the steps to run the MCMC is available on the openMSE
<a href="https://openmse.com/tutorial-rcm/4-case-study-mcmc/">website</a>.
</p>


<h3>Author(s)</h3>

<p>Q. Huynh
</p>

<hr>
<h2 id='PRBcalc'>Calculate mahalanobis distance (null and alternative MSEs) and statistical power for all MPs in an MSE</h2><span id='topic+PRBcalc'></span>

<h3>Description</h3>

<p>Calculate mahalanobis distance (null and alternative MSEs) and statistical power for all MPs in an MSE
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PRBcalc(
  MSE_null,
  MSE_alt,
  tsd = c("Cat", "Cat", "Cat", "Ind", "ML"),
  stat = c("slp", "AAV", "mu", "slp", "slp"),
  dnam = c("C_S", "C_V", "C_M", "I_S", "ML_S"),
  res = 6,
  alpha = 0.05,
  plotCC = FALSE,
  removedat = FALSE,
  removethresh = 0.025
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PRBcalc_+3A_mse_null">MSE_null</code></td>
<td>
<p>An object of class MSE representing the null hypothesis</p>
</td></tr>
<tr><td><code id="PRBcalc_+3A_mse_alt">MSE_alt</code></td>
<td>
<p>An object of class MSE representing the alternative hypothesis</p>
</td></tr>
<tr><td><code id="PRBcalc_+3A_tsd">tsd</code></td>
<td>
<p>Character string of data types: Cat = catch, Ind = relative abundance index, ML = mean length in catches</p>
</td></tr>
<tr><td><code id="PRBcalc_+3A_stat">stat</code></td>
<td>
<p>Character string defining the quantity to be calculated for each data type, slp = slope(log(x)), AAV = average annual variability, mu = mean(log(x))</p>
</td></tr>
<tr><td><code id="PRBcalc_+3A_dnam">dnam</code></td>
<td>
<p>Character string of names for the quantities calculated</p>
</td></tr>
<tr><td><code id="PRBcalc_+3A_res">res</code></td>
<td>
<p>Integer, the resolution (time blocking) for the calculation of PPD</p>
</td></tr>
<tr><td><code id="PRBcalc_+3A_alpha">alpha</code></td>
<td>
<p>Probability of incorrectly rejecting the null operating model when it is valid</p>
</td></tr>
<tr><td><code id="PRBcalc_+3A_plotcc">plotCC</code></td>
<td>
<p>Logical, should the PPD cross correlations be plotted?</p>
</td></tr>
<tr><td><code id="PRBcalc_+3A_removedat">removedat</code></td>
<td>
<p>Logical, should data not contributing to the mahalanobis distance be removed?</p>
</td></tr>
<tr><td><code id="PRBcalc_+3A_removethresh">removethresh</code></td>
<td>
<p>Positive fraction: the cumulative percentage of removed data (removedat=TRUE) that contribute to the mahalanobis distance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object with two hierarchies of indexing, first by MP, second has two positions as described in <a href="#topic+Probs">Probs</a>: (1) mahalanobis distance, (2) a matrix of type 1 error
(first row) and statistical power (second row), by time block.
</p>


<h3>Author(s)</h3>

<p>T. Carruthers
</p>


<h3>References</h3>

<p>Carruthers, T.R, and Hordyk, A.R. In press. Using management strategy evaluation to establish indicators of changing fisheries.
Canadian Journal of Fisheries and Aquatic Science.
</p>

<hr>
<h2 id='prelim_AM'>Preliminary Assessments in MSE</h2><span id='topic+prelim_AM'></span>

<h3>Description</h3>

<p>Evaluates the likely performance of Assessment models in the operating model. This function will
apply the assessment model for Data generated during the historical period of the MSE, and report
the convergence rate for the model and total time elapsed in running the assessments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prelim_AM(x, Assess, ncpus = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prelim_AM_+3A_x">x</code></td>
<td>
<p>Either a <code>Hist</code>, <code>Data</code> or <code>OM</code> object.</p>
</td></tr>
<tr><td><code id="prelim_AM_+3A_assess">Assess</code></td>
<td>
<p>An Assess function of class <code>Assess</code>.</p>
</td></tr>
<tr><td><code id="prelim_AM_+3A_ncpus">ncpus</code></td>
<td>
<p>Numeric, the number of CPUs to run the Assessment model (will run in parallel if greater than 1).</p>
</td></tr>
<tr><td><code id="prelim_AM_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code>Assess</code>, e.g., model configurations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns invisibly a list of <a href="#topic+Assessment-class">Assessment</a> objects of length <code>OM@nsim</code>. Messages via console.
</p>


<h3>Author(s)</h3>

<p>Q. Huynh
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
prelim_AM(MSEtool::SimulatedData, SP)

</code></pre>

<hr>
<h2 id='Probs'>Calculates mahalanobis distance and rejection of the Null operating model</h2><span id='topic+Probs'></span>

<h3>Description</h3>

<p>Calculates mahalanobis distance and rejection of the Null operating model, used by wrapping function <a href="#topic+PRBcalc">PRBcalc</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Probs(indPPD, indData, alpha = 0.05, removedat = FALSE, removethresh = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Probs_+3A_indppd">indPPD</code></td>
<td>
<p>A 3D array of results arising from running getind on an MSE of the Null operating model (type of data/stat (e.g. mean catches),time period (chunk), simulation)</p>
</td></tr>
<tr><td><code id="Probs_+3A_inddata">indData</code></td>
<td>
<p>A 3D array of results arising from running getind on an MSE of the Alternative operating model (type of data/stat (e.g. mean catches),time period (chunk), simulation)</p>
</td></tr>
<tr><td><code id="Probs_+3A_alpha">alpha</code></td>
<td>
<p>Positive fraction: rate of type I error, alpha</p>
</td></tr>
<tr><td><code id="Probs_+3A_removedat">removedat</code></td>
<td>
<p>Logical, should data not contributing to the mahalanobis distance be removed?</p>
</td></tr>
<tr><td><code id="Probs_+3A_removethresh">removethresh</code></td>
<td>
<p>Positive fraction: the cumulative percentage of removed data (removedat=TRUE) that contribute to the mahalanobis distance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object.
Position 1 is an array of the mahalanobis distances. Dimension 1 is length 2 for the Null OM (indPPD) and the alternative OM (indData).
Dimension 2 is the time block (same length as indPPD dim 2). Dimension 3 is the simulation number (same length at indPPD dim 3.),
Position 2 is a matrix (2 rows, ntimeblock columns) which is (row 1) alpha: the rate of false positives, and row 2 the power (1-beta) the rate of true positives
</p>


<h3>Author(s)</h3>

<p>T. Carruthers
</p>


<h3>References</h3>

<p>Carruthers and Hordyk 2018
</p>

<hr>
<h2 id='prof-class'>Class-<code>prof</code></h2><span id='topic+prof-class'></span><span id='topic+prof'></span>

<h3>Description</h3>

<p>An S4 class that contains output from <a href="#topic+profile">profile</a>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>Model</code></dt><dd><p>Name of the assessment model.</p>
</dd>
<dt><code>Name</code></dt><dd><p>Name of Data object.</p>
</dd>
<dt><code>Par</code></dt><dd><p>Character vector of parameters that were profiled.</p>
</dd>
<dt><code>MLE</code></dt><dd><p>Numeric vector of the estimated values of the parameters (corresponding to <code>Par</code>) from the assessment.</p>
</dd>
<dt><code>grid</code></dt><dd><p>A data.frame of the change in negative log-likelihood (<code>nll</code>) based on the profile of the parameters.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Q. Huynh
</p>


<h3>See Also</h3>

<p><a href="#topic+plot.prof">plot.prof</a> <a href="#topic+profile">profile</a>
</p>

<hr>
<h2 id='profile+2CAssessment-method'>Profile likelihood of assessment models</h2><span id='topic+profile+2CAssessment-method'></span><span id='topic+profile'></span><span id='topic+profile+2CRCModel-method'></span>

<h3>Description</h3>

<p>Profile the likelihood for parameters of assessment models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Assessment'
profile(fitted, figure = TRUE, ...)

## S4 method for signature 'RCModel'
profile(fitted, figure = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="profile+2B2CAssessment-method_+3A_fitted">fitted</code>, <code id="profile+2B2CAssessment-method_+3A_assessment">Assessment</code></td>
<td>
<p>An object of class <a href="#topic+Assessment-class">Assessment</a>.</p>
</td></tr>
<tr><td><code id="profile+2B2CAssessment-method_+3A_figure">figure</code></td>
<td>
<p>Logical, indicates whether a figure will be plotted.</p>
</td></tr>
<tr><td><code id="profile+2B2CAssessment-method_+3A_...">...</code></td>
<td>
<p>A sequence of values of the parameter(s) for the profile. See details and example below.
See details for name of arguments to be passed on.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the following assessment models, possible sequence of values for profiling are:
</p>

<ul>
<li><p> DD_TMB and DD_SS: <code>R0</code> and <code>h</code>
</p>
</li>
<li><p> SP and SP_SS: <code>FMSY</code> and <code>MSY</code>
</p>
</li>
<li><p> DD and cDD_SS: <code>R0</code> and <code>h</code>
</p>
</li>
<li><p> SCA and SCA_Pope: <code>R0</code> and <code>h</code>
</p>
</li>
<li><p> SCA2: <code>meanR</code>
</p>
</li>
<li><p> VPA: <code>F_term</code>
</p>
</li>
<li><p> SSS: <code>R0</code>
</p>
</li></ul>

<p>For RCM: <code>D</code> (spawning biomass depletion), <code>R0</code>, and <code>h</code> are used. If the Mesnil-Rochet stock-recruit function
is used, can also profile <code>MRRmax</code> and <code>MRgamma</code>.
</p>


<h3>Value</h3>

<p>An object of class <a href="#topic+prof-class">prof</a> that contains a data frame of negative log-likelihood values from the profile and, optionally,
a figure of the likelihood surface.
</p>


<h3>Author(s)</h3>

<p>Q. Huynh
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
output &lt;- SCA(Data = MSEtool::SimulatedData)

# Profile R0 only
pro &lt;- profile(output, R0 = seq(1000, 2000, 50))

# Profile both R0 and steepness
pro &lt;- profile(output, R0 = seq(1000, 2000, 100), h = seq(0.8, 0.95, 0.025))

# Ensure your grid is of proper resolution. A grid that is too coarse
# will likely distort the shape of the likelihood surface.

</code></pre>

<hr>
<h2 id='project-class'>Class-<code>project</code></h2><span id='topic+project-class'></span><span id='topic+project'></span>

<h3>Description</h3>

<p>An S4 class for the output from <a href="#topic+projection">projection</a>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>Model</code></dt><dd><p>Name of the assessment model.</p>
</dd>
<dt><code>Name</code></dt><dd><p>Name of Data object.</p>
</dd>
<dt><code>FMort</code></dt><dd><p>A matrix of fishing mortality over <code>p_sim</code> rows and <code>p_years</code> columns.</p>
</dd>
<dt><code>B</code></dt><dd><p>An matrix of biomass with <code>p_sim</code> rows and <code>p_years</code> columns.</p>
</dd>
<dt><code>SSB</code></dt><dd><p>A matrix of spawning biomass with <code>p_sim</code> rows and <code>p_years</code> columns.</p>
</dd>
<dt><code>VB</code></dt><dd><p>A matrix of vulnerable biomass with <code>p_sim</code> rows and <code>p_years</code> columns.</p>
</dd>
<dt><code>R</code></dt><dd><p>A matrix of recruitment over <code>p_sim</code> rows and <code>p_years</code> columns.</p>
</dd>
<dt><code>N</code></dt><dd><p>A matrix of abundance over <code>p_sim</code> rows and <code>p_years</code> columns.</p>
</dd>
<dt><code>Catch</code></dt><dd><p>A matrix of simulated observed catch over <code>p_sim</code> rows and <code>p_years</code> columns.</p>
</dd>
<dt><code>Index</code></dt><dd><p>An array of simulated observed index of dimension <code>c(p_sim, p_years, nsurvey)</code>.</p>
</dd>
<dt><code>C_at_age</code></dt><dd><p>An array for catch-at-age with dimension <code>c(p_sim, p_years, n_age)</code>.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Q. Huynh
</p>


<h3>See Also</h3>

<p><a href="#topic+projection">projection</a>
</p>

<hr>
<h2 id='projection'>Projections for assessment models</h2><span id='topic+projection'></span>

<h3>Description</h3>

<p>This function takes an assessment model and runs a stochastic projection based on future F or catch.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>projection(
  Assessment,
  constrain = c("F", "Catch"),
  Ftarget,
  Catch,
  p_years = 50,
  p_sim = 200,
  obs_error,
  process_error,
  max_F = 3,
  seed = 499
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="projection_+3A_assessment">Assessment</code></td>
<td>
<p>An object of class <a href="#topic+Assessment-class">Assessment</a>.</p>
</td></tr>
<tr><td><code id="projection_+3A_constrain">constrain</code></td>
<td>
<p>Whether to project on future F or catch. By default, projects on F.</p>
</td></tr>
<tr><td><code id="projection_+3A_ftarget">Ftarget</code></td>
<td>
<p>The projection F, either of length 1 for constant F for the entirety of the projection or length p_years.</p>
</td></tr>
<tr><td><code id="projection_+3A_catch">Catch</code></td>
<td>
<p>The projection catch, either of length 1 for constant catch for the entirety of the projection or length p_years.</p>
</td></tr>
<tr><td><code id="projection_+3A_p_years">p_years</code></td>
<td>
<p>Integer for the number of projection years.</p>
</td></tr>
<tr><td><code id="projection_+3A_p_sim">p_sim</code></td>
<td>
<p>Integer for the number of simulations for the projection.</p>
</td></tr>
<tr><td><code id="projection_+3A_obs_error">obs_error</code></td>
<td>
<p>A list of length two. In the first entry, a vector of length nsurvey giving the standard deviations of each future index,
or alternatively an array of dimension p_sim, p_years, and nsurvey giving the deviates. The second entry is
the standard deviation of the projected catch. Alternatively, a matrix of
simulation and year-specific error structure for the catch (p_sim rows and p_year columns; a matrix of ones indicates perfect data).</p>
</td></tr>
<tr><td><code id="projection_+3A_process_error">process_error</code></td>
<td>
<p>Numeric, standard deviation for process error (e.g., recruitment or biomass deviates). If <code>NULL</code>,
uses values from assessment model. Alternatively, a matrix of simulation and year-specific recruitment deviates (p_sim rows and p_year columns,
a matrix of ones indicates no recruitment deviates).</p>
</td></tr>
<tr><td><code id="projection_+3A_max_f">max_F</code></td>
<td>
<p>The maximum allowable F if the projection is constrained on catch.</p>
</td></tr>
<tr><td><code id="projection_+3A_seed">seed</code></td>
<td>
<p>An integer to set the seed for the sampling observation and process error deviates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <a href="#topic+project-class">project</a> that contains future predicted values of F, catch, biomass, recruitment, etc.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
myAssess &lt;- SP(Data = swordfish)
do_projection &lt;- projection(myAssess, Ftarget = myAssess@FMSY)

</code></pre>

<hr>
<h2 id='RCM_assess'>The rapid conditioning model as an assessment function</h2><span id='topic+RCM_assess'></span>

<h3>Description</h3>

<p>In beta testing. A function that uses RCM as an assessment function for use in MPs. More function arguments will be added
to tinker with model settings and data inputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RCM_assess(
  x = 1,
  Data,
  AddInd = "B",
  SR = c("BH", "Ricker"),
  selectivity = c("logistic", "dome"),
  CAA_multiplier = 50,
  prior = list(),
  LWT = list(),
  StockPars = "Data",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RCM_assess_+3A_x">x</code></td>
<td>
<p>A position in the Data object (by default, equal to one for assessments).</p>
</td></tr>
<tr><td><code id="RCM_assess_+3A_data">Data</code></td>
<td>
<p>An object of class Data</p>
</td></tr>
<tr><td><code id="RCM_assess_+3A_addind">AddInd</code></td>
<td>
<p>A vector of integers or character strings indicating the indices to be used in the model. Integers assign the index to
the corresponding index in Data@AddInd, &quot;B&quot; (or 0) represents total biomass in Data@Ind, &quot;VB&quot; represents vulnerable biomass in
Data@VInd, and &quot;SSB&quot; represents spawning stock biomass in Data@SpInd. Vulnerability to the survey is fixed in the model.</p>
</td></tr>
<tr><td><code id="RCM_assess_+3A_sr">SR</code></td>
<td>
<p>Stock-recruit function (either <code>"BH"</code> for Beverton-Holt or <code>"Ricker"</code>).</p>
</td></tr>
<tr><td><code id="RCM_assess_+3A_selectivity">selectivity</code></td>
<td>
<p>Whether to model &quot;logistic&quot; or &quot;dome&quot; selectivity for the fishery.</p>
</td></tr>
<tr><td><code id="RCM_assess_+3A_caa_multiplier">CAA_multiplier</code></td>
<td>
<p>Numeric for data weighting of catch-at-age matrix. If greater than 1, then this is the maximum multinomial sample size
in any year. If less than one, then the multinomial sample size is this fraction of the sample size.</p>
</td></tr>
<tr><td><code id="RCM_assess_+3A_prior">prior</code></td>
<td>
<p>A named list for the parameters of any priors to be added to the model. See documentation in <a href="#topic+SCA">SCA</a>.</p>
</td></tr>
<tr><td><code id="RCM_assess_+3A_lwt">LWT</code></td>
<td>
<p>A named list (Index, CAA, Catch) of likelihood weights for the data components. For the index, a vector of length survey. For
CAL and Catch, a single value.</p>
</td></tr>
<tr><td><code id="RCM_assess_+3A_stockpars">StockPars</code></td>
<td>
<p>Either a string (&quot;Data&quot; or &quot;OM&quot;) to indicate whether to grab biological parameters from the Data object,
or operating model. Alternatively, a named list to provide custom parameters for the assessment.</p>
</td></tr>
<tr><td><code id="RCM_assess_+3A_...">...</code></td>
<td>
<p>Additional arguments (to be added).</p>
</td></tr>
</table>


<h3>Data</h3>

<p>Currently uses catch, CAA, and indices of abundance in the corresponding slots in the Data object.
</p>


<h3>StockPars</h3>

<p>Biological parameters can be used from the (1) Data object, (2) operating model, or (3) provided directly in the
<code>StockPars</code> argument.
</p>
<p>Options 2 and 3 allow for time-varying growth, maturity, and natural mortality. Natural mortality can also be age-varying.
</p>
<p><code>StockPars</code> can be a named list of parameters used to provide inputs to the assessment model:
</p>

<ul>
<li> <p><code>Wt_age</code> - annual weight at age, array <code style="white-space: pre;">&#8288;[sim, ages, year]&#8288;</code>
</p>
</li>
<li> <p><code>Mat_age</code> - annual maturity at age, array <code style="white-space: pre;">&#8288;[sim, ages, year]&#8288;</code>
</p>
</li>
<li> <p><code>hs</code> - Stock-recruit steepness, vector of length <code style="white-space: pre;">&#8288;[sim]&#8288;</code>
</p>
</li>
<li> <p><code>M_ageArray</code> - annual natural mortality, array <code style="white-space: pre;">&#8288;[sim, ages, year]&#8288;</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'> 
r &lt;- RCM_assess(Data = SimulatedData)
myMP &lt;- make_MP(RCM_assess, HCR_MSY)
myMP(x = 1, Data = SimulatedData)
</code></pre>

<hr>
<h2 id='RCM2MOM'>Convert RCM to a multi-fleet operating model (MOM)</h2><span id='topic+RCM2MOM'></span>

<h3>Description</h3>

<p>The RCM (Rapid Conditioning Model) returns a single-fleet operating model, implying constant effort among fleets for projections.
Here, we convert the single-fleet OM to a multi-fleet OM, preserving the multiple fleet structure used in the conditioning model
for projections. This allows for testing management procedures that explicitly specify fleet allocation in the management advice.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RCM2MOM(RCModel)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RCM2MOM_+3A_rcmodel">RCModel</code></td>
<td>
<p>Output from <a href="#topic+RCM">RCM</a>, a class <a href="#topic+RCModel-class">RCModel</a> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A class MOM object.
</p>


<h3>Author(s)</h3>

<p>Q. Huynh
</p>

<hr>
<h2 id='RCMdata-class'>Class-<code>RCMdata</code></h2><span id='topic+RCMdata-class'></span><span id='topic+RCMdata'></span>

<h3>Description</h3>

<p>An S4 class for the data inputs into <a href="#topic+RCM">RCM</a>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>Chist</code></dt><dd><p>Either a vector of historical catch, should be of length <code>OM@nyears</code>, or if there are multiple fleets,
a matrix of <code>OM@nyears</code> rows and <code>nfleet</code> columns.
Ideally, the first year of the catch series represents unfished conditions (see also slot <code>C_eq</code>).</p>
</dd>
<dt><code>C_sd</code></dt><dd><p>Same dimension as <code>Chist</code>. Lognormal distribution standard deviations (by year and fleet) for the catches in <code>Chist</code>.
If not provided, the default is 0.01. Not used if <code>RCM(condition = "catch2")</code>.</p>
</dd>
<dt><code>Ehist</code></dt><dd><p>A vector of historical effort, should be of length <code>OM@nyears</code>, or if there are multiple fleets:
a matrix of <code>OM@nyears</code> rows and <code>nfleet</code> columns. See also slot <code>E_eq</code>).</p>
</dd>
<dt><code>CAA</code></dt><dd><p>Fishery age composition matrix with <code>nyears</code> rows and <code>OM@maxage+1</code> columns, or if multiple fleets:
an array with dimension: <code style="white-space: pre;">&#8288;nyears, OM@maxage+1, nfleet&#8288;</code>. Enter <code>NA</code> for years without any data.
Raw numbers will be converted to annual proportions (see slot <code>CAA_ESS</code> for sample sizes).</p>
</dd>
<dt><code>CAA_ESS</code></dt><dd><p>Annual sample size (for the multinomial distribution) of the fishery age comps.
A vector of length <code>OM@nyears</code>, or if there are multiple fleets: a matrix of <code>OM@nyears</code> rows and <code>nfleet</code> columns.
Enter zero for years without observations.
An annual cap to the ESS, e.g., 50, can be calculated with something like: <code>pmin(apply(CAA, c(1, 3), sum, na.rm = TRUE), 50)</code>.
By default,</p>
</dd>
<dt><code>CAL</code></dt><dd><p>Fishery length composition matrix with <code>nyears</code> rows and <code>n_bin</code> columns (indexing the length bin), or
if multiple fleets: an array with dimension: <code style="white-space: pre;">&#8288;nyears, n_bin, nfleets&#8288;</code>. Enter <code>NA</code> for years without any data.
Raw numbers will be converted to annual proportions (see slot <code>CAL_ESS</code> for sample sizes).</p>
</dd>
<dt><code>CAL_ESS</code></dt><dd><p>Annual sample size (for the multinomial distribution) of the fishery length comps.
Same dimension as <code>CAA_ESS</code>.</p>
</dd>
<dt><code>length_bin</code></dt><dd>
<ul>
<li><p> A vector (length <code>n_bin</code>) for the midpoints of the length bins for <code>CAL</code> and <code>IAL</code>, as well as the population model, if all bin widths are equal in size.
If length bins are unequal in width, then provide a vector of the boundaries of the length bins (vector of length <code>n_bin + 1</code>).
</p>
</li></ul>
</dd>
<dt><code>MS</code></dt><dd><p>Mean mean size (either mean length or mean weight) observations from the fishery. Same dimension as <code>Chist</code>.
Generally, mean lengths should not be used alongside <code>CAL</code>, unless mean length and length comps are independently sampled.</p>
</dd>
<dt><code>MS_type</code></dt><dd><p>A character (either <code>"length"</code> (default) or <code>"weight"</code>) to denote the type of mean size data.</p>
</dd>
<dt><code>MS_cv</code></dt><dd><p>The coefficient of variation of the observed mean size. If there are multiple fleets, a vector of length <code>nfleet</code>.
Default is 0.2.</p>
</dd>
<dt><code>Index</code></dt><dd><p>Index of abundance. Enter <code>NA</code> for missing values. A vector length <code>OM@nyears</code>, or if there are multiple surveys:
a matrix of <code>OM@nyears</code> rows and <code>nsurvey</code> columns.</p>
</dd>
<dt><code>I_sd</code></dt><dd><p>A vector or matrix of standard deviations (lognormal distribution) for the indices corresponding to the entries in <code>Index</code>.
Same dimension as <code>Index</code>. If not provided, this function will use values from <code>OM@Iobs</code>.</p>
</dd>
<dt><code>IAA</code></dt><dd><p>Index age composition data, an array of dimension <code style="white-space: pre;">&#8288;nyears, maxage+1, nsurvey&#8288;</code>.
Raw numbers will be converted to annual proportions (see <code>IAA_ESS</code> for sample sizes).</p>
</dd>
<dt><code>IAA_ESS</code></dt><dd><p>Annual sample size (for the multinomial distribution) of the index age comps.
A vector of length <code>OM@nyears</code>. If there are multiple indices: a matrix of <code>OM@nyears</code> rows and <code>nsurvey</code> columns.</p>
</dd>
<dt><code>IAL</code></dt><dd><p>Index length composition data, an array of dimension <code style="white-space: pre;">&#8288;nyears, n_bin, nsurvey&#8288;</code>.
Raw numbers will be converted to annual proportions (see slot <code>IAL_ESS</code> to enter sample sizes).</p>
</dd>
<dt><code>IAL_ESS</code></dt><dd><p>Annual sample size (for the multinomial distribution) of the index length comps.
Same dimension as <code>IAA_ESS</code>.</p>
</dd>
<dt><code>C_eq</code></dt><dd><p>Vector of length <code>nfleet</code> for the equilibrium catch for each fleet in <code>Chist</code> prior to the first year of the operating model.
Zero (default) implies unfished conditions in year one. Otherwise, this is used to estimate depletion in the first year of the data. Alternatively,
if one has a full CAA matrix, one could instead estimate &quot;artificial&quot; rec devs to generate the initial numbers-at-age (and hence initial depletion)
in the first year of the model (see additional arguments in <a href="#topic+RCM">RCM</a>).</p>
</dd>
<dt><code>C_eq_sd</code></dt><dd>
<ul>
<li><p> A vector of standard deviations (lognormal distribution) for the equilibrium catches in <code>C_eq</code>.
Same dimension as <code>C_eq</code>. If not provided, the default is 0.01. Only used if <code>RCM(condition = "catch")</code>.
</p>
</li></ul>
</dd>
<dt><code>E_eq</code></dt><dd><p>The equilibrium effort for each fleet in <code>Ehist</code> prior to the first year of the operating model.
Zero (default) implies unfished conditions in year one. Otherwise, this is used to estimate depletion in the first year of the data.</p>
</dd>
<dt><code>abs_I</code></dt><dd><p>An integer vector length <code>nsurvey</code> to indicate which indices are in absolute magnitude. Use <code>1</code> to set <code>q = 1</code>,
otherwise use 0 (default) to estimate q.</p>
</dd>
<dt><code>I_units</code></dt><dd><p>An integer vector to indicate whether indices are biomass based (1) or abundance-based (0). By default, all are biomass-based.</p>
</dd>
<dt><code>age_error</code></dt><dd><p>A square matrix of <code>maxage + 1</code> rows and columns to specify ageing error. The <code>aa</code>-th column assigns a proportion of animals of
true age <code>aa</code> to observed age <code>a</code> in the <code>a</code>-th row. Thus, all rows should sum to 1. Default is an identity matrix (no ageing error).</p>
</dd>
<dt><code>sel_block</code></dt><dd><p>For time-varying fleet selectivity (in time blocks), a integer matrix of <code>nyears</code> rows and <code>nfleet</code> columns to assign a selectivity
function to a fleet for certain years. By default, constant selectivity for each individual fleet.
See the <a href="https://openmse.com/tutorial-rcm-select/">selectivity</a> article for more details.</p>
</dd>
<dt><code>Misc</code></dt><dd><p>A list of miscellaneous inputs. Used internally.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Q. Huynh
</p>


<h3>See Also</h3>

<p><a href="#topic+RCM">RCM</a>
</p>

<hr>
<h2 id='RCModel-class'>Class-<code>RCModel</code></h2><span id='topic+RCModel-class'></span><span id='topic+RCModel'></span>

<h3>Description</h3>

<p>An S4 class for the output from <a href="#topic+RCM">RCM</a>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>OM</code></dt><dd><p>An updated operating model, class OM.</p>
</dd>
<dt><code>SSB</code></dt><dd><p>A matrix of estimated spawning biomass with <code>OM@nsim</code> rows and <code>OM@nyears+1</code> columns.</p>
</dd>
<dt><code>NAA</code></dt><dd><p>An array for the predicted numbers at age with dimension <code>OM@nsim</code>, <code>OM@nyears+1</code>, and <code>OM@maxage+1</code>.</p>
</dd>
<dt><code>CAA</code></dt><dd><p>An array for the predicted catch at age with dimension <code>OM@nsim</code>, <code>OM@nyears</code>, <code>OM@maxage</code>, and nfleet.</p>
</dd>
<dt><code>CAL</code></dt><dd><p>An array for the predicted catch at length with dimension <code>OM@nsim</code>, <code>OM@nyears</code>, length bins, and nfleet.</p>
</dd>
<dt><code>conv</code></dt><dd><p>A logical vector of length <code>OM@nsim</code> indicating convergence of the RCM in the i-th simulation.</p>
</dd>
<dt><code>Misc</code></dt><dd><p>A list of length <code>OM@nsim</code> with more output from the fitted RCM. Within each simulation, a named list containing items of interest include:
</p>

<ul>
<li><p> B - total biomass - vector of length nyears+1
</p>
</li>
<li><p> EPR0 - annual unfished spawners per recruit - vector of length nyears
</p>
</li>
<li><p> ageM - age of 50% maturity - integer
</p>
</li>
<li><p> EPR0_SR - unfished spawners per recruit for the stock-recruit relationship (mean EPR0 over the first <code>ageM</code> years) - numeric
</p>
</li>
<li><p> R0 - unfished recruitment for the stock-recruit relationship - numeric
</p>
</li>
<li><p> h - steepness for the stock-recruit relationship - numeric
</p>
</li>
<li><p> Arec - stock-recruit alpha parameter - numeric
</p>
</li>
<li><p> Brec - stock-recruit beta parameter - numeric
</p>
</li>
<li><p> E0_SR - unfished spawning biomass for the stock-recruit relationship (product of EPR0_SR and R0) - numeric
</p>
</li>
<li><p> CR_SR - compensation ratio, the product of Arec and EPR0_SR - numeric
</p>
</li>
<li><p> E0 - annual unfished spawning biomass (intersection of stock-recruit relationship and unfished spawners per recruit) - vector of length nyears
</p>
</li>
<li><p> R0_annual - annual unfished recruitment (annual ratio of E0 and EPR0) - vector of length nyears
</p>
</li>
<li><p> h_annual - annual steepness (calculated from EPR0 and Arec) - vector of length nyears
</p>
</li>
<li><p> CR - annual compensation ratio, the product of alpha and annual unfished spawners per recruit (EPR0) - vector of length nyears
</p>
</li>
<li><p> R - recruitment - vector of length nyears+1
</p>
</li>
<li><p> R_early - recruitment for the cohorts in first year of the model - vector n_age-1 (where n_age = maxage + 1)
</p>
</li>
<li><p> VB - vulnerable biomass - matrix of nyears x nfleet
</p>
</li>
<li><p> N - abundance at age - matrix of nyears+1 x n_age
</p>
</li>
<li><p> F - apical fishing mortality - matrix of nyears x nfleet
</p>
</li>
<li><p> F_at_age - fishing mortality at age - matrix of nyears x n_age
</p>
</li>
<li><p> F_equilibrium - equilibrium fishing mortality prior to first year - vector of length nfleet
</p>
</li>
<li><p> M - natural mortality - matrix of nyears x n_age
</p>
</li>
<li><p> Z - total mortality - matrix of nyears x n_age
</p>
</li>
<li><p> q - index catchability - vector of length nsurvey
</p>
</li>
<li><p> ivul - index selectivity at age - array of dim nyears+1, n_age, nsurvey
</p>
</li>
<li><p> ivul_len - corresponding index selectivity at length - matrix of nbins x nsurvey
</p>
</li>
<li><p> Ipred - predicted index values - matrix of nyears x nsurvey
</p>
</li>
<li><p> IAApred - predicted index catch at age - array of dim nyears, n_age, nsurvey
</p>
</li>
<li><p> vul - fleet selectivity at age - array of dim nyears+1, n_age, nfleet (or nsel_block)
</p>
</li>
<li><p> vul_len - corresponding fleet selectivity at length - matrix of nbins x nfleet (or nsel_block)
</p>
</li>
<li><p> IALpred - predicted index catch at length - array of dim nyears, nbins, nsurvey
</p>
</li>
<li><p> MLpred - predicted mean length - matrix of nyears x nfleet
</p>
</li>
<li><p> MWpred - predicted mean weight - matrix of nyears x nfleet
</p>
</li>
<li><p> CAApred - predicted catch at age - array of nyears, n_age, nfleet
</p>
</li>
<li><p> CALpred - predicted catch at length - array of nyears, nbins, nfleet
</p>
</li>
<li><p> Cpred - predicted catch in weight - matrix of nyears x nfleet
</p>
</li>
<li><p> CN - predicted catch in numbers - matrix of nyears x nfleet
</p>
</li>
<li><p> dynamic_SSB0 - the dynamic unfished spawning biomass calcaluated by projecting the historical model with zero catches - vector of length nyears+1
</p>
</li>
<li><p> SPR_eq - equilibrium spawning potential ratio calculated from annual F-at-age - vector of length nyears
</p>
</li>
<li><p> SPR_dyn - dynamic (transitional) spawning potential ratio calculated from cumulative survival of cohorts - vector of length nyears
</p>
</li>
<li><p> nll - total objective function of the model - numeric
</p>
</li>
<li><p> nll_fleet - objective function values for each annual data point(s) from fleets - array of nyears x nfleet x 5 (for Catch, equilibrium catch, CAA, CAL, and mean size)
</p>
</li>
<li><p> nll_index - objective function values for each annual data point(s) in the index - array of nyears x nsurvey x 3 (for Index, IAA, and IAL)
</p>
</li>
<li><p> prior - penalty value added to the objective function from priors - numeric
</p>
</li>
<li><p> penalty - additional penalty values added to the objective function due to high F - numeric
</p>
</li>
<li><p> conv - whether the model converged (whether a positive-definite Hessian was obtained) - logical
</p>
</li></ul>
</dd>
<dt><code>mean_fit</code></dt><dd><p>A list of output from fit to mean values of life history parameters in the operating model. The named list consists of:
</p>

<ul>
<li><p> obj - a list with components returned from <code><a href="TMB.html#topic+MakeADFun">TMB::MakeADFun()</a></code>.
</p>
</li>
<li><p> opt - a list with components from calling <code><a href="stats.html#topic+nlminb">stats::nlminb()</a></code> to <code>obj</code>.
</p>
</li>
<li><p> SD - a list (class sdreport) with parameter estimates and their standard errors, obtained from
<code><a href="TMB.html#topic+sdreport">TMB::sdreport()</a></code>.
</p>
</li>
<li><p> report - a list of model output reported from the TMB executable, i.e. <code>obj$report()</code>. See Misc.
</p>
</li></ul>
</dd>
<dt><code>data</code></dt><dd><p>A <a href="#topic+RCMdata-class">RCMdata</a> object containing data inputs for the RCM.</p>
</dd>
<dt><code>config</code></dt><dd><p>A list describing configuration of the RCM:
</p>

<ul>
<li><p> drop_sim - a vector of simulations that were dropped for the output
</p>
</li></ul>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Q. Huynh
</p>


<h3>See Also</h3>

<p><a href="#topic+plot.RCModel">plot.RCModel</a> <a href="#topic+RCM">RCM</a>
</p>

<hr>
<h2 id='retro-class'>Class-<code>retro</code></h2><span id='topic+retro-class'></span><span id='topic+retro'></span>

<h3>Description</h3>

<p>An S4 class that contains output from <a href="#topic+retrospective">retrospective</a>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>Model</code></dt><dd><p>Name of the assessment model.</p>
</dd>
<dt><code>Name</code></dt><dd><p>Name of Data object.</p>
</dd>
<dt><code>TS_var</code></dt><dd><p>Character vector of time series variables, e.g. recruitment, biomass, from the assessment.</p>
</dd>
<dt><code>TS</code></dt><dd><p>An array of time series assessment output of dimension, indexed by: peel (the number of terminal years removed from the base assessment),
years, and variables (corresponding to <code>TS_var</code>).</p>
</dd>
<dt><code>Est_var</code></dt><dd><p>Character vector of estimated parameters, e.g. R0, steepness, in the assessment.</p>
</dd>
<dt><code>Est</code></dt><dd><p>An array for estimated parameters of dimension, indexed by: peel, variables (corresponding to <code>Est_var</code>), and
value (length 2 for estimate and standard error).</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Q. Huynh
</p>


<h3>See Also</h3>

<p><a href="#topic+plot.retro">plot.retro</a> <a href="#topic+summary.retro">summary.retro</a> <a href="#topic+plot.Assessment">plot.Assessment</a>
</p>

<hr>
<h2 id='retrospective'>Retrospective analysis of assessment models</h2><span id='topic+retrospective'></span><span id='topic+retrospective+2CAssessment-method'></span><span id='topic+retrospective+2CRCModel-method'></span>

<h3>Description</h3>

<p>Perform a retrospective analysis, successive removals of most recent years of data to evaluate resulting
parameter estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>retrospective(x, ...)

## S4 method for signature 'Assessment'
retrospective(x, nyr = 5, figure = TRUE)

## S4 method for signature 'RCModel'
retrospective(x, nyr = 5, figure = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="retrospective_+3A_x">x</code></td>
<td>
<p>An S4 object of class <a href="#topic+Assessment-class">Assessment</a> or <a href="#topic+RCModel-class">RCModel</a>.</p>
</td></tr>
<tr><td><code id="retrospective_+3A_...">...</code></td>
<td>
<p>More arguments.</p>
</td></tr>
<tr><td><code id="retrospective_+3A_nyr">nyr</code></td>
<td>
<p>The maximum number of years to remove for the retrospective analysis.</p>
</td></tr>
<tr><td><code id="retrospective_+3A_figure">figure</code></td>
<td>
<p>Indicates whether plots will be drawn.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with an array of model output and of model estimates from
the retrospective analysis.
</p>
<p>Figures showing the time series of biomass and exploitation and parameter estimates
with successive number of years removed. For a variety of time series output (SSB, recruitment, etc.) and
estimates (R0, steepness, etc.), also returns a matrix of Mohn's rho (Mohn 1999).
</p>


<h3>Author(s)</h3>

<p>Q. Huynh
</p>


<h3>References</h3>

<p>Mohn, R. 1999. The retrospective problem in sequential population analysis: an investigation using cod fishery
and simulated data. ICES Journal of Marine Science 56:473-488.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
output &lt;- SP(Data = swordfish)
get_retro &lt;- retrospective(output, nyr = 5, figure = FALSE)

</code></pre>

<hr>
<h2 id='retrospective_AM'>retrospective_AM (retrospective of Assessment model in MSE)</h2><span id='topic+retrospective_AM'></span>

<h3>Description</h3>

<p>Plots the true retrospective of an assessment model during the closed-loop simulation. A series of time series estimates of SSB, F, and VB
are plotted over the course of the MSE are plotted against the operating model (true) values (in black).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>retrospective_AM(MSE, MP, sim = 1, plot_legend = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="retrospective_AM_+3A_mse">MSE</code></td>
<td>
<p>An object of class MSE.</p>
</td></tr>
<tr><td><code id="retrospective_AM_+3A_mp">MP</code></td>
<td>
<p>Character. The name of the management procedure created by <code><a href="#topic+make_MP">make_MP()</a></code> containing the assessment model.</p>
</td></tr>
<tr><td><code id="retrospective_AM_+3A_sim">sim</code></td>
<td>
<p>Integer between 1 and MSE@nsim. The simulation number for which the retrospectives will be plotted.</p>
</td></tr>
<tr><td><code id="retrospective_AM_+3A_plot_legend">plot_legend</code></td>
<td>
<p>Logical. Whether to plot legend to reference year of assessment in the MSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For assessment models that utilize annual exploitation rates (u), the instantaneous fishing mortality rates
are obtained as F = -log(1 - u).
</p>


<h3>Value</h3>

<p>A series of figures for SSB, depletion, fishing mortality, and vulnerable biomass (VB) estimated in the MP
over the course of the closed-loop simulation against the values generated in the operating model (both historical
and projected).
</p>


<h3>Note</h3>

<p>This function only plots retrospectives from a single simulation in the MSE. Results from one figure
may not be indicative of general assessment behavior and performance overall.
</p>


<h3>Author(s)</h3>

<p>Q. Huynh
</p>


<h3>See Also</h3>

<p><a href="#topic+diagnostic">diagnostic</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
SP_40_10 &lt;- make_MP(SP, HCR_MSY, diagnostic = "full")
OM &lt;- MSEtool::testOM; OM@proyears &lt;- 20
myMSE &lt;- MSEtool::runMSE(OM = OM, MPs = "SP_40_10")
retrospective_AM(myMSE, MP = "SP_40_10", sim = 1)

# How to get all the estimates
library(dplyr)
assess_estimates &lt;- lapply(1:myMSE@nMPs, function(m) {
  lapply(1:myMSE@nsim, function(x) {
    myMSE@PPD[[m]]@Misc[[x]]$Assessment_report %&gt;% 
      mutate(MP = myMSE@MPs[m], Simulation = x)
  }) %&gt;% bind_rows()
}) %&gt;% bind_rows()

</code></pre>

<hr>
<h2 id='SAMtool-package'>Stock Assessment Methods Toolkit</h2><span id='topic+SAMtool-package'></span><span id='topic+SAMtool'></span>

<h3>Description</h3>

<p>Simulation tools for closed-loop simulation are provided for the 'MSEtool' operating model to inform data-rich fisheries.
SAMtool provides an OM conditioning model, assessment models of varying complexity with standardized reporting, diagnostic tools for evaluating
assessments within closed-loop simulation, and helper functions for building more complex operating models and model-based management procedures.
</p>


<h3>How to use SAMtool</h3>

<p>The main features of SAMtool are the assessment models and the ability to make model-based management procedures by combining
assessment models with harvest control rules. Such MPs can be used and tested in management strategy evaluation
with MSEtool operating models. An overview of these features is available
on the <a href="https://openmse.com/features-assessment-models/">openMSE</a> website.
</p>
<p>The <code><a href="#topic+RCM">RCM()</a></code> (Rapid Conditioning Model) can be used to condition operating models from real data.
</p>
<p>The following articles are available on the openMSE website:
</p>

<ul>
<li> <p><a href="https://openmse.com/features-assessment-models/">Description of assessment models</a>
</p>
</li>
<li> <p><a href="https://openmse.com/tutorial-rcm/">General overview of RCM</a>
</p>
</li></ul>

<p>The function documentation can be viewed <a href="https://samtool.openmse.com/reference/index.html">online</a>.
</p>


<h3>Author(s)</h3>

<p>Quang Huynh <a href="mailto:quang@bluematterscience.com">quang@bluematterscience.com</a>
</p>
<p>Tom Carruthers <a href="mailto:tom@bluematterscience.com">tom@bluematterscience.com</a>
</p>
<p>Adrian Hordyk <a href="mailto:adrian@bluematterscience.com">adrian@bluematterscience.com</a>
</p>


<h3>References</h3>

<p>Carruthers, T.R., Punt, A.E., Walters, C.J., MacCall, A.,
McAllister, M.K., Dick, E.J., Cope, J. 2014. Evaluating methods for setting
catch limits in data-limited fisheries. Fisheries Research. 153: 48-68.
</p>
<p>Carruthers, T.R., Kell, L.T., Butterworth, D.S., Maunder, M.N., Geromont,
H.F., Walters, C., McAllister, M.K., Hillary, R., Levontin, P., Kitakado,
T., Davies, C.R. Performance review of simple management procedures. ICES
Journal of Marine Science. 73: 464-482.
</p>

<hr>
<h2 id='SCA'>Statistical catch-at-age (SCA) model</h2><span id='topic+SCA'></span><span id='topic+SCA2'></span><span id='topic+SCA_Pope'></span>

<h3>Description</h3>

<p>A generic statistical catch-at-age model (single fleet, single season) that uses catch, index, and catch-at-age composition
data. <code>SCA</code> parameterizes R0 and steepness as leading productivity parameters in the assessment model. Recruitment is estimated
as deviations from the resulting stock-recruit relationship. In <code>SCA2</code>, the mean recruitment in the time series is estimated and
recruitment deviations around this mean are estimated as penalized parameters (<code>SR = "none"</code>, similar to Cadigan 2016). The standard deviation is set high
so that the recruitment is almost like free parameters. Unfished and MSY reference points are not estimated, it is recommended to use yield per recruit
or spawning potential ratio in harvest control rules. <code>SCA_Pope</code> is a variant of <code>SCA</code> that fixes the expected catch to the observed
catch, and Pope's approximation is used to calculate the annual exploitation rate (U; i.e., <code>catch_eq = "Pope"</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SCA(
  x = 1,
  Data,
  AddInd = "B",
  SR = c("BH", "Ricker", "none"),
  vulnerability = c("logistic", "dome"),
  catch_eq = c("Baranov", "Pope"),
  CAA_dist = c("multinomial", "lognormal"),
  CAA_multiplier = 50,
  rescale = "mean1",
  max_age = Data@MaxAge,
  start = NULL,
  prior = list(),
  fix_h = TRUE,
  fix_F_equilibrium = TRUE,
  fix_omega = TRUE,
  fix_tau = TRUE,
  LWT = list(),
  early_dev = c("comp_onegen", "comp", "all"),
  late_dev = "comp50",
  integrate = FALSE,
  silent = TRUE,
  opt_hess = FALSE,
  n_restart = ifelse(opt_hess, 0, 1),
  control = list(iter.max = 2e+05, eval.max = 4e+05),
  inner.control = list(),
  ...
)

SCA2(
  x = 1,
  Data,
  AddInd = "B",
  vulnerability = c("logistic", "dome"),
  CAA_dist = c("multinomial", "lognormal"),
  CAA_multiplier = 50,
  rescale = "mean1",
  max_age = Data@MaxAge,
  start = NULL,
  prior = list(),
  fix_h = TRUE,
  fix_F_equilibrium = TRUE,
  fix_omega = TRUE,
  fix_tau = TRUE,
  LWT = list(),
  common_dev = "comp50",
  integrate = FALSE,
  silent = TRUE,
  opt_hess = FALSE,
  n_restart = ifelse(opt_hess, 0, 1),
  control = list(iter.max = 2e+05, eval.max = 4e+05),
  inner.control = list(),
  ...
)

SCA_Pope(
  x = 1,
  Data,
  AddInd = "B",
  SR = c("BH", "Ricker", "none"),
  vulnerability = c("logistic", "dome"),
  CAA_dist = c("multinomial", "lognormal"),
  CAA_multiplier = 50,
  rescale = "mean1",
  max_age = Data@MaxAge,
  start = NULL,
  prior = list(),
  fix_h = TRUE,
  fix_U_equilibrium = TRUE,
  fix_tau = TRUE,
  LWT = list(),
  early_dev = c("comp_onegen", "comp", "all"),
  late_dev = "comp50",
  integrate = FALSE,
  silent = TRUE,
  opt_hess = FALSE,
  n_restart = ifelse(opt_hess, 0, 1),
  control = list(iter.max = 2e+05, eval.max = 4e+05),
  inner.control = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SCA_+3A_x">x</code></td>
<td>
<p>A position in the Data object (by default, equal to one for assessments).</p>
</td></tr>
<tr><td><code id="SCA_+3A_data">Data</code></td>
<td>
<p>An object of class Data</p>
</td></tr>
<tr><td><code id="SCA_+3A_addind">AddInd</code></td>
<td>
<p>A vector of integers or character strings indicating the indices to be used in the model. Integers assign the index to
the corresponding index in Data@AddInd, &quot;B&quot; (or 0) represents total biomass in Data@Ind, &quot;VB&quot; represents vulnerable biomass in
Data@VInd, and &quot;SSB&quot; represents spawning stock biomass in Data@SpInd. Vulnerability to the survey is fixed in the model.</p>
</td></tr>
<tr><td><code id="SCA_+3A_sr">SR</code></td>
<td>
<p>Stock-recruit function (either <code>"BH"</code> for Beverton-Holt, <code>"Ricker"</code>, or <code>"none"</code> for constant mean recruitment).</p>
</td></tr>
<tr><td><code id="SCA_+3A_vulnerability">vulnerability</code></td>
<td>
<p>Whether estimated vulnerability is <code>"logistic"</code> or <code>"dome"</code> (double-normal).
See details for parameterization.</p>
</td></tr>
<tr><td><code id="SCA_+3A_catch_eq">catch_eq</code></td>
<td>
<p>Whether to use the Baranov equation or Pope's approximation to calculate the predicted catch at age in the model.</p>
</td></tr>
<tr><td><code id="SCA_+3A_caa_dist">CAA_dist</code></td>
<td>
<p>Whether a multinomial or lognormal distribution is used for likelihood of the catch-at-age matrix. See details.</p>
</td></tr>
<tr><td><code id="SCA_+3A_caa_multiplier">CAA_multiplier</code></td>
<td>
<p>Numeric for data weighting of catch-at-age matrix if <code>CAA_hist = "multinomial"</code>. Otherwise ignored. See details.</p>
</td></tr>
<tr><td><code id="SCA_+3A_rescale">rescale</code></td>
<td>
<p>A multiplicative factor that rescales the catch in the assessment model, which
can improve convergence. By default, <code>"mean1"</code> scales the catch so that time series mean is 1, otherwise a numeric.
Output is re-converted back to original units.</p>
</td></tr>
<tr><td><code id="SCA_+3A_max_age">max_age</code></td>
<td>
<p>Integer, the maximum age (plus-group) in the model.</p>
</td></tr>
<tr><td><code id="SCA_+3A_start">start</code></td>
<td>
<p>Optional list of starting values. Entries can be expressions that are evaluated in the function. See details.</p>
</td></tr>
<tr><td><code id="SCA_+3A_prior">prior</code></td>
<td>
<p>A named list for the parameters of any priors to be added to the model. See below.</p>
</td></tr>
<tr><td><code id="SCA_+3A_fix_h">fix_h</code></td>
<td>
<p>Logical, whether to fix steepness to value in <code>Data@steep</code> in the model for <code>SCA</code>. This only affects
calculation of reference points for <code>SCA2</code>.</p>
</td></tr>
<tr><td><code id="SCA_+3A_fix_f_equilibrium">fix_F_equilibrium</code></td>
<td>
<p>Logical, whether the equilibrium fishing mortality prior to the first year of the model
is estimated. If <code>TRUE</code>, <code>F_equilibrium</code> is fixed to value provided in <code>start</code> (if provided),
otherwise, equal to zero (assumes unfished conditions).</p>
</td></tr>
<tr><td><code id="SCA_+3A_fix_omega">fix_omega</code></td>
<td>
<p>Logical, whether the standard deviation of the catch is fixed. If <code>TRUE</code>,
omega is fixed to value provided in <code>start</code> (if provided), otherwise, value based on <code>Data@CV_Cat</code>.</p>
</td></tr>
<tr><td><code id="SCA_+3A_fix_tau">fix_tau</code></td>
<td>
<p>Logical, the standard deviation of the recruitment deviations is fixed. If <code>TRUE</code>,
tau is fixed to value provided in <code>start</code> (if provided), otherwise, value based on <code>Data@sigmaR</code>.</p>
</td></tr>
<tr><td><code id="SCA_+3A_lwt">LWT</code></td>
<td>
<p>A named list (Index, CAA, Catch) of likelihood weights for the data components. For the index, a vector of length survey. For
CAL and Catch, a single value.</p>
</td></tr>
<tr><td><code id="SCA_+3A_early_dev">early_dev</code></td>
<td>
<p>Numeric or character string describing the years for which recruitment deviations are estimated in <code>SCA</code>. By default,
equal to <code>"comp_onegen"</code>, where rec devs are estimated one full generation prior to the first year when catch-at-age (CAA) data are available.
With <code>"comp"</code>, rec devs are estimated starting in the first year with CAA. With <code>"all"</code>, rec devs start at the beginning of the model.
If numeric, the number of years after the first year of the model for which to start estimating rec devs. Use negative numbers for years prior to the first year.</p>
</td></tr>
<tr><td><code id="SCA_+3A_late_dev">late_dev</code></td>
<td>
<p>Typically, a numeric for the number of most recent years in which recruitment deviations will
not be estimated in <code>SCA</code> (recruitment in these years will be based on the mean predicted by stock-recruit relationship).
By default, <code>"comp50"</code> uses the number of ages (smaller than the mode)
for which the catch-at-age matrix has less than half the abundance than that at the mode.</p>
</td></tr>
<tr><td><code id="SCA_+3A_integrate">integrate</code></td>
<td>
<p>Logical, whether the likelihood of the model integrates over the likelihood
of the recruitment deviations (thus, treating it as a random effects/state-space variable).
Otherwise, recruitment deviations are penalized parameters.</p>
</td></tr>
<tr><td><code id="SCA_+3A_silent">silent</code></td>
<td>
<p>Logical, passed to <code><a href="TMB.html#topic+MakeADFun">TMB::MakeADFun()</a></code>, whether TMB
will print trace information during optimization. Used for diagnostics for model convergence.</p>
</td></tr>
<tr><td><code id="SCA_+3A_opt_hess">opt_hess</code></td>
<td>
<p>Logical, whether the hessian function will be passed to <code><a href="stats.html#topic+nlminb">stats::nlminb()</a></code> during optimization
(this generally reduces the number of iterations to convergence, but is memory and time intensive and does not guarantee an increase
in convergence rate). Ignored if <code>integrate = TRUE</code>.</p>
</td></tr>
<tr><td><code id="SCA_+3A_n_restart">n_restart</code></td>
<td>
<p>The number of restarts (calls to <code><a href="stats.html#topic+nlminb">stats::nlminb()</a></code>) in the optimization procedure, so long as the model
hasn't converged. The optimization continues from the parameters from the previous (re)start.</p>
</td></tr>
<tr><td><code id="SCA_+3A_control">control</code></td>
<td>
<p>A named list of arguments for optimization to be passed to
<code><a href="stats.html#topic+nlminb">stats::nlminb()</a></code>.</p>
</td></tr>
<tr><td><code id="SCA_+3A_inner.control">inner.control</code></td>
<td>
<p>A named list of arguments for optimization of the random effects, which
is passed on to <code><a href="TMB.html#topic+newton">TMB::newton()</a></code>.</p>
</td></tr>
<tr><td><code id="SCA_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed.</p>
</td></tr>
<tr><td><code id="SCA_+3A_common_dev">common_dev</code></td>
<td>
<p>Typically, a numeric for the number of most recent years in which a common recruitment deviation will
be estimated (in <code>SCA2</code>, uninformative years will have a recruitment closer to the mean, which can be very misleading,
especially near the end of the time series). By default, <code>"comp50"</code> uses the number of ages (smaller than the mode)
for which the catch-at-age matrix has less than half the abundance than that at the mode.</p>
</td></tr>
<tr><td><code id="SCA_+3A_fix_u_equilibrium">fix_U_equilibrium</code></td>
<td>
<p>Logical, same as <code>fix_F_equilibrium</code> for <code>SCA_Pope</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The basic data inputs are catch (by weight), index (by weight/biomass), and catch-at-age matrix (by numbers).
</p>
<p>With <code>catch_eq = "Baranov"</code> (default in SCA and SCA2), annual F's are estimated parameters assuming continuous fishing over the year, while
an annual exploitation rate from pulse fishing in the middle of the year is estimated in <code>SCA_Pope</code> or <code>SCA(catch_eq = "Pope")</code>.
</p>
<p>The annual sample sizes of the catch-at-age matrix is provided to the model (used in the likelihood for catch-at-age assuming
a multinomial distribution) and is manipulated via argument <code>CAA_multiplier</code>. This argument is
interpreted in two different ways depending on the value provided. If <code>CAA_multiplier &gt; 1</code>, then this value will cap the annual sample sizes
to that number. If <code>CAA_multiplier &lt;= 1</code>, then all the annual samples sizes will be re-scaled by that number, e.g. <code>CAA_multiplier = 0.1</code>
multiplies the sample size to 10% of the original number. By default, sample sizes are capped at 50.
</p>
<p>Alternatively, a lognormal distribution with inverse proportion variance can be used for the catch at age (Punt and Kennedy, 1994, as
cited by Maunder 2011).
</p>
<p>For <code>start</code> (optional), a named list of starting values of estimates can be provided for:
</p>

<ul>
<li> <p><code>R0</code> Unfished recruitment, except when <code>SR = "none"</code> where it is mean recruitment.
By default, 150% <code>Data@OM$R0[x]</code> is used as the start value in closed-loop simulation, and 400% of mean catch otherwise.
</p>
</li>
<li> <p><code>h</code> Steepness. Otherwise, <code>Data@steep[x]</code> is used, or 0.9 if empty.
</p>
</li>
<li> <p><code>M</code> Natural mortality. Otherwise, <code>Data@Mort[x]</code> is used.
</p>
</li>
<li> <p><code>vul_par</code> Vulnerability parameters, see next paragraph.
</p>
</li>
<li> <p><code>F</code> A vector of length <code>nyears</code> for year-specific fishing mortality.
</p>
</li>
<li> <p><code>F_equilibrium</code> Equilibrium fishing mortality leading into first year of the model (to determine initial depletion). By default, 0.
</p>
</li>
<li> <p><code>U_equilibrium</code> Same as F_equilibrium when <code>catch_eq = "Pope"</code>. By default, 0.
</p>
</li>
<li> <p><code>omega</code> Lognormal SD of the catch (observation error) when <code>catch_eq = "Baranov"</code>. By default, <code>Data@CV_Cat[x]</code>.
</p>
</li>
<li> <p><code>tau</code> Lognormal SD of the recruitment deviations (process error). By default, <code>Data@sigmaR[x]</code>.
</p>
</li></ul>

<p>Vulnerability can be specified to be either logistic or dome. If logistic, then the parameter
vector <code>vul_par</code> is of length 2:
</p>

<ul>
<li> <p><code>vul_par[1]</code> corresponds to <code>a_95</code>, the age of 95% vulnerability. <code>a_95</code> is a transformed parameter via logit transformation to constrain <code>a_95</code> to less than 75%
of the maximum age: <code>a_95 = 0.75 * max_age * plogis(x[1])</code>, where <code>x</code> is the estimated vector.
</p>
</li>
<li> <p><code>vul_par[2]</code> corresponds to <code>a_50</code>, the age of 50% vulnerability. Estimated as an offset, i.e., <code>a_50 = a_95 - exp(x[2])</code>.
</p>
</li></ul>

<p>With dome vulnerability, a double Gaussian parameterization is used, where <code>vul_par</code>
is an estimated vector of length 4:
</p>

<ul>
<li> <p><code>vul_par[1]</code> corresponds to  <code>a_asc</code>, the first age of full vulnerability for the ascending limb. In the model, <code>a_asc</code> is estimated via logit transformation
to constrain <code>a_95</code> to less than 75% of the maximum age: <code>a_asc = 0.75 * maxage * plogis(x[1])</code>, where <code>x</code> is the estimated vector.
</p>
</li>
<li> <p><code>vul_par[2]</code> corresponds to <code>a_50</code>, the age of 50% vulnerability for the ascending limb. Estimated as an offset, i.e.,
<code>a_50 = a_asc - exp(x[2])</code>.
</p>
</li>
<li> <p><code>vul_par[3]</code> corresponds to <code>a_des</code>, the last age of full vulnerability (where the descending limb starts). Generated via logit transformation
to constrain between <code>a_asc</code> and <code>max_age</code>, i.e., <code>a_des = (max_age - a_asc) * plogis(x[3]) + a_asc</code>. By default, fixed to a small value so that the dome is effectively
a three-parameter function.
</p>
</li>
<li> <p><code>vul_par[4]</code> corresponds to <code>vul_max</code>, the vulnerability at the maximum age. Estimated in logit space: <code>vul_max = plogis(x[4])</code>.
</p>
</li></ul>

<p>Vague priors of <code>vul_par[1] ~ N(0, sd = 3)</code>, <code>vul_par[2] ~ N(0, 3)</code>, <code>vul_par[3] ~ Beta(1.01, 1.01)</code> are used to aid convergence when parameters may not be well estimated,
for example, when vulnerability &gt;&gt; 0.5 for the youngest age class.
</p>


<h3>Value</h3>

<p>An object of class <a href="#topic+Assessment-class">Assessment</a>.
</p>


<h3>Priors</h3>

<p>The following priors can be added as a named list, e.g., <code style="white-space: pre;">&#8288;prior = list(M = c(0.25, 0.15), h = c(0.7, 0.1)&#8288;</code>.
For each parameter below, provide a vector of values as described:
</p>

<ul>
<li> <p><code>R0</code> - A vector of length 3. The first value indicates the distribution of the prior: <code>1</code> for lognormal, <code>2</code> for uniform
on <code>log(R0)</code>, <code>3</code> for uniform on R0. If lognormal, the second and third values are the prior mean (in normal space) and SD (in log space).
Otherwise, the second and third values are the lower and upper bounds of the uniform distribution (values in normal space).
</p>
</li>
<li> <p><code>h</code> - A vector of length 2 for the prior mean and SD, both in normal space. Beverton-Holt steepness uses a beta distribution,
while Ricker steepness uses a normal distribution.
</p>
</li>
<li> <p><code>M</code> - A vector of length 2 for the prior mean (in normal space) and SD (in log space). Lognormal prior.
</p>
</li>
<li> <p><code>q</code> - A matrix for nsurvey rows and 2 columns. The first column is the prior mean (in normal space) and the second column
for the SD (in log space). Use <code>NA</code> in rows corresponding to indices without priors.
</p>
</li></ul>

<p>See online documentation for more details.
</p>


<h3>Online Documentation</h3>

<p>Model description and equations are available on the openMSE
<a href="https://openmse.com/features-assessment-models/2-sca/">website</a>.
</p>


<h3>Required Data</h3>


<ul>
<li> <p><code>SCA</code>, <code>SCA_Pope</code>, and <code>SCA_Pope</code>: Cat, Ind, Mort, L50, L95, CAA, vbK, vbLinf, vbt0, wla, wlb, MaxAge
</p>
</li></ul>



<h3>Optional Data</h3>


<ul>
<li> <p><code>SCA</code>: Rec, steep, sigmaR, CV_Ind, CV_Cat
</p>
</li>
<li> <p><code>SC2</code>: Rec, steep, CV_Ind, CV_Cat
</p>
</li>
<li> <p><code>SCA_Pope</code>: Rec, steep, sigmaR, CV_Ind
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Q. Huynh
</p>


<h3>References</h3>

<p>Cadigan, N.G. 2016. A state-space stock assessment model for northern cod, including under-reported catches and
variable natural mortality rates. Canadian Journal of Fisheries and Aquatic Science 72:296-308.
</p>
<p>Maunder, M.N. 2011. Review and evaluation of likelihood functions for composition data in
stock-assessment models: Estimating the effective sample size. Fisheries Research 209:311-319.
</p>
<p>Punt, A.E. and Kennedy, R.B. 1997. Population modelling of Tasmanian rock lobster, Jasus edwardsii, resources. Marine and Freshwater
Research 48:967-980.
</p>


<h3>See Also</h3>

<p><a href="#topic+plot.Assessment">plot.Assessment</a> <a href="#topic+summary.Assessment">summary.Assessment</a> <a href="#topic+retrospective">retrospective</a> <a href="#topic+profile">profile</a> <a href="#topic+make_MP">make_MP</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- SCA(Data = MSEtool::SimulatedData)
res2 &lt;- SCA2(Data = MSEtool::SimulatedData)

# Downweight the index
res3 &lt;- SCA(Data = MSEtool::SimulatedData, LWT = list(Index = 0.1, CAA = 1))

compare_models(res, res2)
</code></pre>

<hr>
<h2 id='SCA_CAL'>Age-structured model using fishery length composition</h2><span id='topic+SCA_CAL'></span>

<h3>Description</h3>

<p>A single-fleet assessment that fits to catch, indices of abundance, and fishery length compositions. See <a href="#topic+SCA">SCA</a> for all details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SCA_CAL(
  x = 1,
  Data,
  AddInd = "B",
  SR = c("BH", "Ricker", "none"),
  vulnerability = c("logistic", "dome"),
  catch_eq = c("Baranov", "Pope"),
  CAL_dist = c("multinomial", "lognormal"),
  CAL_multiplier = 50,
  rescale = "mean1",
  max_age = Data@MaxAge,
  start = NULL,
  prior = list(),
  fix_h = TRUE,
  fix_F_equilibrium = TRUE,
  fix_omega = TRUE,
  fix_tau = TRUE,
  LWT = list(),
  early_dev = c("comp_onegen", "comp", "all"),
  late_dev = "comp50",
  integrate = FALSE,
  silent = TRUE,
  opt_hess = FALSE,
  n_restart = ifelse(opt_hess, 0, 1),
  control = list(iter.max = 2e+05, eval.max = 4e+05),
  inner.control = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SCA_CAL_+3A_x">x</code></td>
<td>
<p>A position in the Data object (by default, equal to one for assessments).</p>
</td></tr>
<tr><td><code id="SCA_CAL_+3A_data">Data</code></td>
<td>
<p>An object of class Data</p>
</td></tr>
<tr><td><code id="SCA_CAL_+3A_addind">AddInd</code></td>
<td>
<p>A vector of integers or character strings indicating the indices to be used in the model. Integers assign the index to
the corresponding index in Data@AddInd, &quot;B&quot; (or 0) represents total biomass in Data@Ind, &quot;VB&quot; represents vulnerable biomass in
Data@VInd, and &quot;SSB&quot; represents spawning stock biomass in Data@SpInd. Vulnerability to the survey is fixed in the model.</p>
</td></tr>
<tr><td><code id="SCA_CAL_+3A_sr">SR</code></td>
<td>
<p>Stock-recruit function (either <code>"BH"</code> for Beverton-Holt, <code>"Ricker"</code>, or <code>"none"</code> for constant mean recruitment).</p>
</td></tr>
<tr><td><code id="SCA_CAL_+3A_vulnerability">vulnerability</code></td>
<td>
<p>Whether estimated vulnerability is <code>"logistic"</code> or <code>"dome"</code> (double-normal).
See details for parameterization.</p>
</td></tr>
<tr><td><code id="SCA_CAL_+3A_catch_eq">catch_eq</code></td>
<td>
<p>Whether to use the Baranov equation or Pope's approximation to calculate the predicted catch at age in the model.</p>
</td></tr>
<tr><td><code id="SCA_CAL_+3A_cal_dist">CAL_dist</code></td>
<td>
<p>Character, the statistical distribution for the likelihood of the catch-at-length.</p>
</td></tr>
<tr><td><code id="SCA_CAL_+3A_cal_multiplier">CAL_multiplier</code></td>
<td>
<p>Numeric for data weighting of catch-at-length matrix if <code>CAL_hist = "multinomial"</code>. A value smaller than one
rescales annual sample sizes to this fraction of the original sample size. Values greater than one generates a cap of the annual sample
size to this value.</p>
</td></tr>
<tr><td><code id="SCA_CAL_+3A_rescale">rescale</code></td>
<td>
<p>A multiplicative factor that rescales the catch in the assessment model, which
can improve convergence. By default, <code>"mean1"</code> scales the catch so that time series mean is 1, otherwise a numeric.
Output is re-converted back to original units.</p>
</td></tr>
<tr><td><code id="SCA_CAL_+3A_max_age">max_age</code></td>
<td>
<p>Integer, the maximum age (plus-group) in the model.</p>
</td></tr>
<tr><td><code id="SCA_CAL_+3A_start">start</code></td>
<td>
<p>Optional list of starting values. Entries can be expressions that are evaluated in the function. See details.</p>
</td></tr>
<tr><td><code id="SCA_CAL_+3A_prior">prior</code></td>
<td>
<p>A named list for the parameters of any priors to be added to the model. See below.</p>
</td></tr>
<tr><td><code id="SCA_CAL_+3A_fix_h">fix_h</code></td>
<td>
<p>Logical, whether to fix steepness to value in <code>Data@steep</code> in the model for <code>SCA</code>. This only affects
calculation of reference points for <code>SCA2</code>.</p>
</td></tr>
<tr><td><code id="SCA_CAL_+3A_fix_f_equilibrium">fix_F_equilibrium</code></td>
<td>
<p>Logical, whether the equilibrium fishing mortality prior to the first year of the model
is estimated. If <code>TRUE</code>, <code>F_equilibrium</code> is fixed to value provided in <code>start</code> (if provided),
otherwise, equal to zero (assumes unfished conditions).</p>
</td></tr>
<tr><td><code id="SCA_CAL_+3A_fix_omega">fix_omega</code></td>
<td>
<p>Logical, whether the standard deviation of the catch is fixed. If <code>TRUE</code>,
omega is fixed to value provided in <code>start</code> (if provided), otherwise, value based on <code>Data@CV_Cat</code>.</p>
</td></tr>
<tr><td><code id="SCA_CAL_+3A_fix_tau">fix_tau</code></td>
<td>
<p>Logical, the standard deviation of the recruitment deviations is fixed. If <code>TRUE</code>,
tau is fixed to value provided in <code>start</code> (if provided), otherwise, value based on <code>Data@sigmaR</code>.</p>
</td></tr>
<tr><td><code id="SCA_CAL_+3A_lwt">LWT</code></td>
<td>
<p>A named list (Index, CAA, Catch) of likelihood weights for the data components. For the index, a vector of length survey. For
CAL and Catch, a single value.</p>
</td></tr>
<tr><td><code id="SCA_CAL_+3A_early_dev">early_dev</code></td>
<td>
<p>Numeric or character string describing the years for which recruitment deviations are estimated in <code>SCA</code>. By default,
equal to <code>"comp_onegen"</code>, where rec devs are estimated one full generation prior to the first year when catch-at-age (CAA) data are available.
With <code>"comp"</code>, rec devs are estimated starting in the first year with CAA. With <code>"all"</code>, rec devs start at the beginning of the model.
If numeric, the number of years after the first year of the model for which to start estimating rec devs. Use negative numbers for years prior to the first year.</p>
</td></tr>
<tr><td><code id="SCA_CAL_+3A_late_dev">late_dev</code></td>
<td>
<p>Typically, a numeric for the number of most recent years in which recruitment deviations will
not be estimated in <code>SCA</code> (recruitment in these years will be based on the mean predicted by stock-recruit relationship).
By default, <code>"comp50"</code> uses the number of ages (smaller than the mode)
for which the catch-at-age matrix has less than half the abundance than that at the mode.</p>
</td></tr>
<tr><td><code id="SCA_CAL_+3A_integrate">integrate</code></td>
<td>
<p>Logical, whether the likelihood of the model integrates over the likelihood
of the recruitment deviations (thus, treating it as a random effects/state-space variable).
Otherwise, recruitment deviations are penalized parameters.</p>
</td></tr>
<tr><td><code id="SCA_CAL_+3A_silent">silent</code></td>
<td>
<p>Logical, passed to <code><a href="TMB.html#topic+MakeADFun">TMB::MakeADFun()</a></code>, whether TMB
will print trace information during optimization. Used for diagnostics for model convergence.</p>
</td></tr>
<tr><td><code id="SCA_CAL_+3A_opt_hess">opt_hess</code></td>
<td>
<p>Logical, whether the hessian function will be passed to <code><a href="stats.html#topic+nlminb">stats::nlminb()</a></code> during optimization
(this generally reduces the number of iterations to convergence, but is memory and time intensive and does not guarantee an increase
in convergence rate). Ignored if <code>integrate = TRUE</code>.</p>
</td></tr>
<tr><td><code id="SCA_CAL_+3A_n_restart">n_restart</code></td>
<td>
<p>The number of restarts (calls to <code><a href="stats.html#topic+nlminb">stats::nlminb()</a></code>) in the optimization procedure, so long as the model
hasn't converged. The optimization continues from the parameters from the previous (re)start.</p>
</td></tr>
<tr><td><code id="SCA_CAL_+3A_control">control</code></td>
<td>
<p>A named list of arguments for optimization to be passed to
<code><a href="stats.html#topic+nlminb">stats::nlminb()</a></code>.</p>
</td></tr>
<tr><td><code id="SCA_CAL_+3A_inner.control">inner.control</code></td>
<td>
<p>A named list of arguments for optimization of the random effects, which
is passed on to <code><a href="TMB.html#topic+newton">TMB::newton()</a></code>.</p>
</td></tr>
<tr><td><code id="SCA_CAL_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed.</p>
</td></tr>
</table>


<h3>Online Documentation</h3>

<p>Model description and equations are available on the openMSE
<a href="https://openmse.com/features-assessment-models/2-sca/">website</a>.
</p>


<h3>Author(s)</h3>

<p>Q. Huynh
</p>

<hr>
<h2 id='SCA_DDM'>SCA models with time-varying natural mortality</h2><span id='topic+SCA_DDM'></span>

<h3>Description</h3>

<p>A modification of <code>SCA</code> that incorporates density-dependent effects on M based on biomass depletion (Forrest et al. 2018).
Set the bounds of M in the <code>M_bounds</code> argument, a length-2 vector where the first entry is M0, the M as B/B0 &gt;= 1,
and the second entry is M1, the M as B/B0 approaches zero. Note that M0 can be greater than M1 (compensatory)
or M0 can be less than M1 (depensatory).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SCA_DDM(
  x = 1,
  Data,
  AddInd = "B",
  SR = c("BH", "Ricker", "none"),
  vulnerability = c("logistic", "dome"),
  catch_eq = c("Baranov", "Pope"),
  CAA_dist = c("multinomial", "lognormal"),
  CAA_multiplier = 50,
  rescale = "mean1",
  max_age = Data@MaxAge,
  start = NULL,
  prior = list(),
  fix_h = TRUE,
  fix_F_equilibrium = TRUE,
  fix_omega = TRUE,
  fix_tau = TRUE,
  LWT = list(),
  early_dev = c("comp_onegen", "comp", "all"),
  late_dev = "comp50",
  M_bounds = NULL,
  integrate = FALSE,
  silent = TRUE,
  opt_hess = FALSE,
  n_restart = ifelse(opt_hess, 0, 1),
  control = list(iter.max = 2e+05, eval.max = 4e+05),
  inner.control = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SCA_DDM_+3A_x">x</code></td>
<td>
<p>A position in the Data object (by default, equal to one for assessments).</p>
</td></tr>
<tr><td><code id="SCA_DDM_+3A_data">Data</code></td>
<td>
<p>An object of class Data</p>
</td></tr>
<tr><td><code id="SCA_DDM_+3A_addind">AddInd</code></td>
<td>
<p>A vector of integers or character strings indicating the indices to be used in the model. Integers assign the index to
the corresponding index in Data@AddInd, &quot;B&quot; (or 0) represents total biomass in Data@Ind, &quot;VB&quot; represents vulnerable biomass in
Data@VInd, and &quot;SSB&quot; represents spawning stock biomass in Data@SpInd. Vulnerability to the survey is fixed in the model.</p>
</td></tr>
<tr><td><code id="SCA_DDM_+3A_sr">SR</code></td>
<td>
<p>Stock-recruit function (either <code>"BH"</code> for Beverton-Holt, <code>"Ricker"</code>, or <code>"none"</code> for constant mean recruitment).</p>
</td></tr>
<tr><td><code id="SCA_DDM_+3A_vulnerability">vulnerability</code></td>
<td>
<p>Whether estimated vulnerability is <code>"logistic"</code> or <code>"dome"</code> (double-normal).
See details for parameterization.</p>
</td></tr>
<tr><td><code id="SCA_DDM_+3A_catch_eq">catch_eq</code></td>
<td>
<p>Whether to use the Baranov equation or Pope's approximation to calculate the predicted catch at age in the model.</p>
</td></tr>
<tr><td><code id="SCA_DDM_+3A_caa_dist">CAA_dist</code></td>
<td>
<p>Whether a multinomial or lognormal distribution is used for likelihood of the catch-at-age matrix. See details.</p>
</td></tr>
<tr><td><code id="SCA_DDM_+3A_caa_multiplier">CAA_multiplier</code></td>
<td>
<p>Numeric for data weighting of catch-at-age matrix if <code>CAA_hist = "multinomial"</code>. Otherwise ignored. See details.</p>
</td></tr>
<tr><td><code id="SCA_DDM_+3A_rescale">rescale</code></td>
<td>
<p>A multiplicative factor that rescales the catch in the assessment model, which
can improve convergence. By default, <code>"mean1"</code> scales the catch so that time series mean is 1, otherwise a numeric.
Output is re-converted back to original units.</p>
</td></tr>
<tr><td><code id="SCA_DDM_+3A_max_age">max_age</code></td>
<td>
<p>Integer, the maximum age (plus-group) in the model.</p>
</td></tr>
<tr><td><code id="SCA_DDM_+3A_start">start</code></td>
<td>
<p>Optional list of starting values. Entries can be expressions that are evaluated in the function. See details.</p>
</td></tr>
<tr><td><code id="SCA_DDM_+3A_prior">prior</code></td>
<td>
<p>A named list for the parameters of any priors to be added to the model. See below.</p>
</td></tr>
<tr><td><code id="SCA_DDM_+3A_fix_h">fix_h</code></td>
<td>
<p>Logical, whether to fix steepness to value in <code>Data@steep</code> in the model for <code>SCA</code>. This only affects
calculation of reference points for <code>SCA2</code>.</p>
</td></tr>
<tr><td><code id="SCA_DDM_+3A_fix_f_equilibrium">fix_F_equilibrium</code></td>
<td>
<p>Logical, whether the equilibrium fishing mortality prior to the first year of the model
is estimated. If <code>TRUE</code>, <code>F_equilibrium</code> is fixed to value provided in <code>start</code> (if provided),
otherwise, equal to zero (assumes unfished conditions).</p>
</td></tr>
<tr><td><code id="SCA_DDM_+3A_fix_omega">fix_omega</code></td>
<td>
<p>Logical, whether the standard deviation of the catch is fixed. If <code>TRUE</code>,
omega is fixed to value provided in <code>start</code> (if provided), otherwise, value based on <code>Data@CV_Cat</code>.</p>
</td></tr>
<tr><td><code id="SCA_DDM_+3A_fix_tau">fix_tau</code></td>
<td>
<p>Logical, the standard deviation of the recruitment deviations is fixed. If <code>TRUE</code>,
tau is fixed to value provided in <code>start</code> (if provided), otherwise, value based on <code>Data@sigmaR</code>.</p>
</td></tr>
<tr><td><code id="SCA_DDM_+3A_lwt">LWT</code></td>
<td>
<p>A named list (Index, CAA, Catch) of likelihood weights for the data components. For the index, a vector of length survey. For
CAL and Catch, a single value.</p>
</td></tr>
<tr><td><code id="SCA_DDM_+3A_early_dev">early_dev</code></td>
<td>
<p>Numeric or character string describing the years for which recruitment deviations are estimated in <code>SCA</code>. By default,
equal to <code>"comp_onegen"</code>, where rec devs are estimated one full generation prior to the first year when catch-at-age (CAA) data are available.
With <code>"comp"</code>, rec devs are estimated starting in the first year with CAA. With <code>"all"</code>, rec devs start at the beginning of the model.
If numeric, the number of years after the first year of the model for which to start estimating rec devs. Use negative numbers for years prior to the first year.</p>
</td></tr>
<tr><td><code id="SCA_DDM_+3A_late_dev">late_dev</code></td>
<td>
<p>Typically, a numeric for the number of most recent years in which recruitment deviations will
not be estimated in <code>SCA</code> (recruitment in these years will be based on the mean predicted by stock-recruit relationship).
By default, <code>"comp50"</code> uses the number of ages (smaller than the mode)
for which the catch-at-age matrix has less than half the abundance than that at the mode.</p>
</td></tr>
<tr><td><code id="SCA_DDM_+3A_m_bounds">M_bounds</code></td>
<td>
<p>A numeric vector of length 2 to indicate the M as B/B0 approaches zero and one, respectively.
By default, set to 75% and 125%, respectively, of <code>Data@Mort[x]</code>.</p>
</td></tr>
<tr><td><code id="SCA_DDM_+3A_integrate">integrate</code></td>
<td>
<p>Logical, whether the likelihood of the model integrates over the likelihood
of the recruitment deviations (thus, treating it as a random effects/state-space variable).
Otherwise, recruitment deviations are penalized parameters.</p>
</td></tr>
<tr><td><code id="SCA_DDM_+3A_silent">silent</code></td>
<td>
<p>Logical, passed to <code><a href="TMB.html#topic+MakeADFun">TMB::MakeADFun()</a></code>, whether TMB
will print trace information during optimization. Used for diagnostics for model convergence.</p>
</td></tr>
<tr><td><code id="SCA_DDM_+3A_opt_hess">opt_hess</code></td>
<td>
<p>Logical, whether the hessian function will be passed to <code><a href="stats.html#topic+nlminb">stats::nlminb()</a></code> during optimization
(this generally reduces the number of iterations to convergence, but is memory and time intensive and does not guarantee an increase
in convergence rate). Ignored if <code>integrate = TRUE</code>.</p>
</td></tr>
<tr><td><code id="SCA_DDM_+3A_n_restart">n_restart</code></td>
<td>
<p>The number of restarts (calls to <code><a href="stats.html#topic+nlminb">stats::nlminb()</a></code>) in the optimization procedure, so long as the model
hasn't converged. The optimization continues from the parameters from the previous (re)start.</p>
</td></tr>
<tr><td><code id="SCA_DDM_+3A_control">control</code></td>
<td>
<p>A named list of arguments for optimization to be passed to
<code><a href="stats.html#topic+nlminb">stats::nlminb()</a></code>.</p>
</td></tr>
<tr><td><code id="SCA_DDM_+3A_inner.control">inner.control</code></td>
<td>
<p>A named list of arguments for optimization of the random effects, which
is passed on to <code><a href="TMB.html#topic+newton">TMB::newton()</a></code>.</p>
</td></tr>
<tr><td><code id="SCA_DDM_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <a href="#topic+SCA">SCA</a> for more information on all arguments.
</p>


<h3>Value</h3>

<p>An object of class <a href="#topic+Assessment-class">Assessment</a>.
</p>


<h3>Online Documentation</h3>

<p>Model description and equations are available on the openMSE
<a href="https://openmse.com/features-assessment-models/2-sca/">website</a>.
</p>


<h3>Author(s)</h3>

<p>Q. Huynh
</p>


<h3>References</h3>

<p>Forrest, R.E., Holt, K.R., and Kronlund, A.R. 2018. Performance of alternative harvest control rules for two Pacific groundfish
stocks with uncertain natural mortality: Bias, robustness and trade-offs. Fisheries Research 2016: 259-286.
</p>


<h3>See Also</h3>

<p><a href="#topic+SCA">SCA</a> <a href="#topic+SCA_RWM">SCA_RWM</a> <a href="#topic+plot.Assessment">plot.Assessment</a> <a href="#topic+summary.Assessment">summary.Assessment</a> <a href="#topic+retrospective">retrospective</a> <a href="#topic+profile">profile</a> <a href="#topic+make_MP">make_MP</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- SCA_DDM(Data = MSEtool::SimulatedData)

</code></pre>

<hr>
<h2 id='SCA_RWM'>SCA with random walk in M</h2><span id='topic+SCA_RWM'></span>

<h3>Description</h3>

<p><code>SCA_RWM</code> is a modification of <a href="#topic+SCA">SCA</a> that incorporates a random walk in M in logit space (constant with age).
Set the variance (<code>start$tau_M</code>) to a small value (0.001) in order to fix M for all years, which is functionally equivalent to <a href="#topic+SCA">SCA</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SCA_RWM(
  x = 1,
  Data,
  AddInd = "B",
  SR = c("BH", "Ricker", "none"),
  vulnerability = c("logistic", "dome"),
  catch_eq = c("Baranov", "Pope"),
  CAA_dist = c("multinomial", "lognormal"),
  CAA_multiplier = 50,
  rescale = "mean1",
  max_age = Data@MaxAge,
  start = NULL,
  prior = list(),
  fix_h = TRUE,
  fix_F_equilibrium = TRUE,
  fix_omega = TRUE,
  fix_tau = TRUE,
  LWT = list(),
  early_dev = c("comp_onegen", "comp", "all"),
  late_dev = "comp50",
  refyear = expression(length(Data@Year)),
  M_bounds = NULL,
  integrate = FALSE,
  silent = TRUE,
  opt_hess = FALSE,
  n_restart = ifelse(opt_hess, 0, 1),
  control = list(iter.max = 2e+05, eval.max = 4e+05),
  inner.control = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SCA_RWM_+3A_x">x</code></td>
<td>
<p>A position in the Data object (by default, equal to one for assessments).</p>
</td></tr>
<tr><td><code id="SCA_RWM_+3A_data">Data</code></td>
<td>
<p>An object of class Data</p>
</td></tr>
<tr><td><code id="SCA_RWM_+3A_addind">AddInd</code></td>
<td>
<p>A vector of integers or character strings indicating the indices to be used in the model. Integers assign the index to
the corresponding index in Data@AddInd, &quot;B&quot; (or 0) represents total biomass in Data@Ind, &quot;VB&quot; represents vulnerable biomass in
Data@VInd, and &quot;SSB&quot; represents spawning stock biomass in Data@SpInd. Vulnerability to the survey is fixed in the model.</p>
</td></tr>
<tr><td><code id="SCA_RWM_+3A_sr">SR</code></td>
<td>
<p>Stock-recruit function (either <code>"BH"</code> for Beverton-Holt, <code>"Ricker"</code>, or <code>"none"</code> for constant mean recruitment).</p>
</td></tr>
<tr><td><code id="SCA_RWM_+3A_vulnerability">vulnerability</code></td>
<td>
<p>Whether estimated vulnerability is <code>"logistic"</code> or <code>"dome"</code> (double-normal).
See details for parameterization.</p>
</td></tr>
<tr><td><code id="SCA_RWM_+3A_catch_eq">catch_eq</code></td>
<td>
<p>Whether to use the Baranov equation or Pope's approximation to calculate the predicted catch at age in the model.</p>
</td></tr>
<tr><td><code id="SCA_RWM_+3A_caa_dist">CAA_dist</code></td>
<td>
<p>Whether a multinomial or lognormal distribution is used for likelihood of the catch-at-age matrix. See details.</p>
</td></tr>
<tr><td><code id="SCA_RWM_+3A_caa_multiplier">CAA_multiplier</code></td>
<td>
<p>Numeric for data weighting of catch-at-age matrix if <code>CAA_hist = "multinomial"</code>. Otherwise ignored. See details.</p>
</td></tr>
<tr><td><code id="SCA_RWM_+3A_rescale">rescale</code></td>
<td>
<p>A multiplicative factor that rescales the catch in the assessment model, which
can improve convergence. By default, <code>"mean1"</code> scales the catch so that time series mean is 1, otherwise a numeric.
Output is re-converted back to original units.</p>
</td></tr>
<tr><td><code id="SCA_RWM_+3A_max_age">max_age</code></td>
<td>
<p>Integer, the maximum age (plus-group) in the model.</p>
</td></tr>
<tr><td><code id="SCA_RWM_+3A_start">start</code></td>
<td>
<p>Optional list of starting values. Entries can be expressions that are evaluated in the function. See details.</p>
</td></tr>
<tr><td><code id="SCA_RWM_+3A_prior">prior</code></td>
<td>
<p>A named list for the parameters of any priors to be added to the model. See below.</p>
</td></tr>
<tr><td><code id="SCA_RWM_+3A_fix_h">fix_h</code></td>
<td>
<p>Logical, whether to fix steepness to value in <code>Data@steep</code> in the model for <code>SCA</code>. This only affects
calculation of reference points for <code>SCA2</code>.</p>
</td></tr>
<tr><td><code id="SCA_RWM_+3A_fix_f_equilibrium">fix_F_equilibrium</code></td>
<td>
<p>Logical, whether the equilibrium fishing mortality prior to the first year of the model
is estimated. If <code>TRUE</code>, <code>F_equilibrium</code> is fixed to value provided in <code>start</code> (if provided),
otherwise, equal to zero (assumes unfished conditions).</p>
</td></tr>
<tr><td><code id="SCA_RWM_+3A_fix_omega">fix_omega</code></td>
<td>
<p>Logical, whether the standard deviation of the catch is fixed. If <code>TRUE</code>,
omega is fixed to value provided in <code>start</code> (if provided), otherwise, value based on <code>Data@CV_Cat</code>.</p>
</td></tr>
<tr><td><code id="SCA_RWM_+3A_fix_tau">fix_tau</code></td>
<td>
<p>Logical, the standard deviation of the recruitment deviations is fixed. If <code>TRUE</code>,
tau is fixed to value provided in <code>start</code> (if provided), otherwise, value based on <code>Data@sigmaR</code>.</p>
</td></tr>
<tr><td><code id="SCA_RWM_+3A_lwt">LWT</code></td>
<td>
<p>A named list (Index, CAA, Catch) of likelihood weights for the data components. For the index, a vector of length survey. For
CAL and Catch, a single value.</p>
</td></tr>
<tr><td><code id="SCA_RWM_+3A_early_dev">early_dev</code></td>
<td>
<p>Numeric or character string describing the years for which recruitment deviations are estimated in <code>SCA</code>. By default,
equal to <code>"comp_onegen"</code>, where rec devs are estimated one full generation prior to the first year when catch-at-age (CAA) data are available.
With <code>"comp"</code>, rec devs are estimated starting in the first year with CAA. With <code>"all"</code>, rec devs start at the beginning of the model.
If numeric, the number of years after the first year of the model for which to start estimating rec devs. Use negative numbers for years prior to the first year.</p>
</td></tr>
<tr><td><code id="SCA_RWM_+3A_late_dev">late_dev</code></td>
<td>
<p>Typically, a numeric for the number of most recent years in which recruitment deviations will
not be estimated in <code>SCA</code> (recruitment in these years will be based on the mean predicted by stock-recruit relationship).
By default, <code>"comp50"</code> uses the number of ages (smaller than the mode)
for which the catch-at-age matrix has less than half the abundance than that at the mode.</p>
</td></tr>
<tr><td><code id="SCA_RWM_+3A_refyear">refyear</code></td>
<td>
<p>An expression for the year for which M is used to report MSY and unfished reference points. By default, terminal year. If multiple
years are provided, then the mean M over the specified time period is used.</p>
</td></tr>
<tr><td><code id="SCA_RWM_+3A_m_bounds">M_bounds</code></td>
<td>
<p>A numeric vector of length 2 to indicate the minimum and maximum M in the random walk as a proportion of the starting M
(<code>start$M</code>). The default min and max are 75% and 125%, respectively.</p>
</td></tr>
<tr><td><code id="SCA_RWM_+3A_integrate">integrate</code></td>
<td>
<p>Logical, whether the likelihood of the model integrates over the likelihood
of the recruitment deviations (thus, treating it as a random effects/state-space variable).
Otherwise, recruitment deviations are penalized parameters.</p>
</td></tr>
<tr><td><code id="SCA_RWM_+3A_silent">silent</code></td>
<td>
<p>Logical, passed to <code><a href="TMB.html#topic+MakeADFun">TMB::MakeADFun()</a></code>, whether TMB
will print trace information during optimization. Used for diagnostics for model convergence.</p>
</td></tr>
<tr><td><code id="SCA_RWM_+3A_opt_hess">opt_hess</code></td>
<td>
<p>Logical, whether the hessian function will be passed to <code><a href="stats.html#topic+nlminb">stats::nlminb()</a></code> during optimization
(this generally reduces the number of iterations to convergence, but is memory and time intensive and does not guarantee an increase
in convergence rate). Ignored if <code>integrate = TRUE</code>.</p>
</td></tr>
<tr><td><code id="SCA_RWM_+3A_n_restart">n_restart</code></td>
<td>
<p>The number of restarts (calls to <code><a href="stats.html#topic+nlminb">stats::nlminb()</a></code>) in the optimization procedure, so long as the model
hasn't converged. The optimization continues from the parameters from the previous (re)start.</p>
</td></tr>
<tr><td><code id="SCA_RWM_+3A_control">control</code></td>
<td>
<p>A named list of arguments for optimization to be passed to
<code><a href="stats.html#topic+nlminb">stats::nlminb()</a></code>.</p>
</td></tr>
<tr><td><code id="SCA_RWM_+3A_inner.control">inner.control</code></td>
<td>
<p>A named list of arguments for optimization of the random effects, which
is passed on to <code><a href="TMB.html#topic+newton">TMB::newton()</a></code>.</p>
</td></tr>
<tr><td><code id="SCA_RWM_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model estimates year-specific M (constant with age) as a random walk in logit space, bounded by
a proportion of <code>start$M</code> (specified in <code>M_bounds</code>).
</p>
<p>The starting value for the first year M (start$M) is <code>Data@Mort[x]</code> and is fixed, unless a prior is provided (<code>prior$M</code>).
The fixed SD of the random walk (<code>tau_M</code>) is 0.05, by default.
</p>
<p>Steepness and unfished recruitment in the estimation model, along with unfished reference points, correspond to spawners per recruit using the first year M.
With argument <code>refyear</code>, new unfished reference points and steepness values are calculated. See examples.
</p>
<p>Alternative values can be provided in the start list (see examples):
</p>

<ul>
<li> <p><code>R0</code> Unfished recruitment, except when <code>SR = "none"</code> where it is mean recruitment.
By default, 150% <code>Data@OM$R0[x]</code> is used as the start value in closed-loop simulation, and 400\
</p>
</li>
<li> <p><code>h</code> Steepness. Otherwise, <code>Data@steep[x]</code> is used, or 0.9 if empty.
</p>
</li>
<li> <p><code>M</code> Natural mortality in the first year. Otherwise, <code>Data@Mort[x]</code> is used.
</p>
</li>
<li> <p><code>vul_par</code> Vulnerability parameters, see next paragraph.
</p>
</li>
<li> <p><code>F</code> A vector of length nyears for year-specific fishing mortality.
</p>
</li>
<li> <p><code>F_equilibrium</code> Equilibrium fishing mortality leading into first year of the model (to determine initial depletion). By default, 0.
</p>
</li>
<li> <p><code>omega</code> Lognormal SD of the catch (observation error) when <code>catch_eq = "Baranov"</code>. By default, <code>Data@CV_Cat[x]</code>.
</p>
</li>
<li> <p><code>tau</code> Lognormal SD of the recruitment deviations (process error). By default, <code>Data@sigmaR[x]</code>.
</p>
</li>
<li> <p><code>tau_M</code> The fixed SD of the random walk in M. By default, 0.05.
</p>
</li></ul>

<p>See <a href="#topic+SCA">SCA</a> for all other information about the structure and setup of the model.
</p>
<p>The SCA builds in a stock-recruit relationship into the model. Annual unfished and MSY reference points are
calculated and reported in TMB_report of the <a href="#topic+Assessment-class">Assessment</a> object.
</p>


<h3>Value</h3>

<p>An object of class <a href="#topic+Assessment-class">Assessment</a>.
</p>


<h3>Online Documentation</h3>

<p>Model description and equations are available on the openMSE
<a href="https://openmse.com/features-assessment-models/2-sca/">website</a>.
</p>


<h3>Author(s)</h3>

<p>Q. Huynh
</p>


<h3>See Also</h3>

<p><a href="#topic+SCA">SCA</a> <a href="#topic+SCA_DDM">SCA_DDM</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- SCA_RWM(Data = MSEtool::SimulatedData, start = list(M_start = 0.4, tau_M = 0.05))
res2 &lt;- SCA(Data = MSEtool::SimulatedData)
res3 &lt;- SCA_RWM(Data = MSEtool::SimulatedData, start = list(M_start = 0.4, tau_M = 0.001))

# Use mean M in most recent 5 years for reporting reference points 
res_5r &lt;- SCA_RWM(Data = MSEtool::SimulatedData, 
                  refyear = expression(seq(length(Data@Year) - 4, length(Data@Year))),
                  start = list(M_start = 0.4, tau_M = 0.001))
res_5r@SSB0 # SSB0 reported (see also res_5r@TMB_report$new_E0)
res_5r@TMB_report$E0 # SSB0 of Year 1 M


compare_models(res, res2, res3)

</code></pre>

<hr>
<h2 id='Shortcut'>Assessment emulator as a shortcut to model fitting in closed-loop simulation</h2><span id='topic+Shortcut'></span><span id='topic+Perfect'></span><span id='topic+Shortcut2'></span>

<h3>Description</h3>

<p>Functions (class Assessment) that emulate a stock assessment by sampling the operating model biomass, abundance, and
fishing mortality (with observation error, autocorrelation, and bias) instead of fitting a model. This output can then
be passed onto a harvest control rule (HCR function). <code>Shortcut</code> is the base function that samples the OM with an error
distribution. <code>Shortcut2</code>, the more preferable option, fits <a href="#topic+SCA">SCA</a> in the last historical year of the operating
model, estimates the error parameters using a vector autoregressive model of the residuals, and then generates model &quot;estimates&quot;
using <a href="vars.html#topic+predict">predict.varest</a>. <code>Perfect</code> assumes no error in the assessment model and is useful for comparing the behavior of
different harvest control rules. To utilize the shortcut method in closed-loop simulation, use <a href="#topic+make_MP">make_MP</a> with these functions as
the Assessment model. <strong>N.B. the functions do not work with</strong> <code>runMSE(parallel = TRUE)</code> for MSEtool v3.4.0 and earlier.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Shortcut(
  x = 1,
  Data,
  method = c("B", "N", "RF"),
  B_err = c(0.3, 0.7, 1),
  N_err = c(0.3, 0.7, 1),
  R_err = c(0.3, 0.7, 1),
  F_err = c(0.3, 0.7, 1),
  VAR_model,
  ...
)

Shortcut2(
  x,
  Data,
  method = "N",
  SCA_args = list(),
  VAR_args = list(type = "none"),
  ...
)

Perfect(x, Data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Shortcut_+3A_x">x</code></td>
<td>
<p>An index for the objects in <code>Data</code> when running in <a href="MSEtool.html#topic+runMSE">runMSE</a>.
Otherwise, equals to 1 When running an assessment interactively.</p>
</td></tr>
<tr><td><code id="Shortcut_+3A_data">Data</code></td>
<td>
<p>An object of class Data.</p>
</td></tr>
<tr><td><code id="Shortcut_+3A_method">method</code></td>
<td>
<p>Indicates where the error in the OM is located. For &quot;B&quot;, OM biomass is directly sampled with error.
For &quot;N&quot;, OM abundance-at-age is sampled and biomass subsequently calculated. For &quot;RF&quot;, recruitment and F are
sampled to calculate abundance and biomass. There is no error in biological parameters for &quot;N&quot; and &quot;RF&quot;. By default,
&quot;B&quot; is used for <code>Shortcut</code> and &quot;N&quot; for <code>Shortcut2</code>.</p>
</td></tr>
<tr><td><code id="Shortcut_+3A_b_err">B_err</code></td>
<td>
<p>If <code>method = "B"</code>, a vector of length three that specifies the standard deviation (in logspace),
autocorrelation, and bias (1 = unbiased) for biomass.</p>
</td></tr>
<tr><td><code id="Shortcut_+3A_n_err">N_err</code></td>
<td>
<p>Same as B_err, but for abundance when <code>method = "N"</code>.</p>
</td></tr>
<tr><td><code id="Shortcut_+3A_r_err">R_err</code></td>
<td>
<p>Same as B_err, but for recruitment when <code>method = "RF"</code>.</p>
</td></tr>
<tr><td><code id="Shortcut_+3A_f_err">F_err</code></td>
<td>
<p>Same as B_err. Always used regardless of <code>method</code> to report F and selectivity for HCR.</p>
</td></tr>
<tr><td><code id="Shortcut_+3A_var_model">VAR_model</code></td>
<td>
<p>An object returned by <a href="vars.html#topic+VAR">VAR</a> to generate emulated assessment error. Used by <code>Shortcut2</code>.</p>
</td></tr>
<tr><td><code id="Shortcut_+3A_...">...</code></td>
<td>
<p>Other arguments (not currently used).</p>
</td></tr>
<tr><td><code id="Shortcut_+3A_sca_args">SCA_args</code></td>
<td>
<p>Additional arguments to pass to <a href="#topic+SCA">SCA</a>. Currently, arguments <code>SR</code> and <code>vulnerability</code>
are obtained from the operating model.</p>
</td></tr>
<tr><td><code id="Shortcut_+3A_var_args">VAR_args</code></td>
<td>
<p>Additional arguments to pass to <a href="vars.html#topic+VAR">VAR</a>. By default, argument <code>type = "none"</code>
(stationary time series with mean zero is assumed).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently there is no error in FMSY (frequently the target F in the HCR).
</p>
<p>See Wiedenmann et al. (2015) for guidance on the magnitude of error for the shortcut emulator.
</p>


<h3>Value</h3>

<p>An object of class <a href="#topic+Assessment-class">Assessment</a>.
</p>


<h3>Author(s)</h3>

<p>Q. Huynh
</p>


<h3>References</h3>

<p>Wiedenmann, J., Wilberg, M.J., Sylvia, A., and Miller, T.J. 2015. Autocorrelated error in stock assessment
estimates: Implications for management strategy evaluation. Fisheries Research 172: 325-334.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Shortcut_4010 &lt;- make_MP(Shortcut, HCR40_10) 
Shortcut_Nerr &lt;- make_MP(Shortcut, HCR40_10, method = "N", N_err = c(0.1, 0.1, 1)) # Highly precise!

# Fits SCA first and then emulate it in the projection period 
Shortcut2_4010 &lt;- make_MP(Shortcut2, HCR40_10) 


# Compare the shortcut method vs. fitting an SCA model with a 40-10 control rule
MSE &lt;- runMSE(testOM, MPs = c("Shortcut_4010", "SCA_4010"))


# Compare the performance of three HCRs
Perfect_4010 &lt;- make_MP(Perfect, HCR40_10)
Perfect_6020 &lt;- make_MP(Perfect, HCR60_20)
Perfect_8040MSY &lt;- make_MP(Perfect, HCR_ramp, OCP_type = "SSB_SSBMSY", TOCP = 0.8, LOCP = 0.4)


MSE &lt;- runMSE(testOM, MPs = c("Perfect_4010", "Perfect_6020", "Perfect_8040MSY"))

</code></pre>

<hr>
<h2 id='sim-class'>Class-<code>sim</code></h2><span id='topic+sim-class'></span><span id='topic+sim'></span>

<h3>Description</h3>

<p>An S4 class that contains output from <a href="#topic+simulate">simulate</a>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>Model</code></dt><dd><p>Name of the assessment model.</p>
</dd>
<dt><code>data</code></dt><dd><p>List of data from the assessment.</p>
</dd>
<dt><code>data_sim</code></dt><dd><p>List of simulated data values. Each value returns an array.</p>
</dd>
<dt><code>process_sim</code></dt><dd><p>List of simulated process error.</p>
</dd>
<dt><code>est</code></dt><dd><p>Estimates from the original model fit.</p>
</dd>
<dt><code>est_sim</code></dt><dd><p>Estimates from the simulated data.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Q. Huynh
</p>

<hr>
<h2 id='simulate'>Generate simulated data from TMB models in SAMtool</h2><span id='topic+simulate'></span><span id='topic+simulate+2CAssessment-method'></span><span id='topic+simulate.Assessment'></span><span id='topic+simulate+2CRCModel-method'></span><span id='topic+simulate.RCModel'></span>

<h3>Description</h3>

<p>A convenient wrapper function (<code>simulate</code>) to simulate data (and process error) from the likelihood function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate(object, ...)

## S4 method for signature 'Assessment'
simulate(
  object,
  nsim = 1,
  seed = NULL,
  process_error = FALSE,
  refit = FALSE,
  cores = 1,
  ...
)

## S4 method for signature 'RCModel'
simulate(
  object,
  nsim = 1,
  seed = NULL,
  process_error = FALSE,
  refit = FALSE,
  cores = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_+3A_object">object</code></td>
<td>
<p>An object of class <a href="#topic+Assessment-class">Assessment</a> or <a href="#topic+RCModel-class">RCModel</a> containing the fitted model.</p>
</td></tr>
<tr><td><code id="simulate_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
<tr><td><code id="simulate_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulations</p>
</td></tr>
<tr><td><code id="simulate_+3A_seed">seed</code></td>
<td>
<p>Used for the random number generator</p>
</td></tr>
<tr><td><code id="simulate_+3A_process_error">process_error</code></td>
<td>
<p>Logical, indicates if process error is re-sampled in the simulation.</p>
</td></tr>
<tr><td><code id="simulate_+3A_refit">refit</code></td>
<td>
<p>Logical, whether to re-fit the model for each simulated dataset.</p>
</td></tr>
<tr><td><code id="simulate_+3A_cores">cores</code></td>
<td>
<p>The number of CPUs for parallel processing for model re-fitting if <code>refit = TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Process error, e.g., recruitment deviations, will be re-sampled in the simulation.
</p>


<h3>Value</h3>

<p>A <a href="#topic+sim-class">sim</a> object returning the original data, simulated data, original parameters, parameters estimated
from simulated data, and process error used to simulate data.
then a nested list of model output (<code>opt</code>, <code>SD</code>, and <code>report</code>).
</p>


<h3>Author(s)</h3>

<p>Q. Huynh
</p>

<hr>
<h2 id='SP'>Surplus production model with FMSY and MSY as leading parameters</h2><span id='topic+SP'></span><span id='topic+SP_SS'></span><span id='topic+SP_Fox'></span>

<h3>Description</h3>

<p>A surplus production model that uses only a time-series of catches and a relative abundance index
and coded in TMB. The base model, <code>SP</code>, is conditioned on catch and estimates a predicted index.
Continuous surplus production and fishing is modeled with sub-annual time steps which should approximate
the behavior of ASPIC (Prager 1994). The Fox model, <code>SP_Fox</code>, fixes BMSY/K = 0.37 (1/e).
The state-space version, <code>SP_SS</code> estimates annual deviates in biomass. An option allows for setting a
prior for the intrinsic rate of increase.
The function for the <code>spict</code> model (Pedersen and Berg, 2016) is available in <a href="MSEtool.html#topic+MSEextra">MSEextra</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SP(
  x = 1,
  Data,
  AddInd = "B",
  rescale = "mean1",
  start = NULL,
  prior = list(),
  fix_dep = TRUE,
  fix_n = TRUE,
  LWT = NULL,
  n_seas = 4L,
  n_itF = 3L,
  Euler_Lotka = 0L,
  SR_type = c("BH", "Ricker"),
  silent = TRUE,
  opt_hess = FALSE,
  n_restart = ifelse(opt_hess, 0, 1),
  control = list(iter.max = 5000, eval.max = 10000),
  ...
)

SP_SS(
  x = 1,
  Data,
  AddInd = "B",
  rescale = "mean1",
  start = NULL,
  prior = list(),
  fix_dep = TRUE,
  fix_n = TRUE,
  fix_sigma = TRUE,
  fix_tau = TRUE,
  LWT = NULL,
  early_dev = c("all", "index"),
  n_seas = 4L,
  n_itF = 3L,
  Euler_Lotka = 0L,
  SR_type = c("BH", "Ricker"),
  integrate = FALSE,
  silent = TRUE,
  opt_hess = FALSE,
  n_restart = ifelse(opt_hess, 0, 1),
  control = list(iter.max = 5000, eval.max = 10000),
  inner.control = list(),
  ...
)

SP_Fox(x = 1, Data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SP_+3A_x">x</code></td>
<td>
<p>An index for the objects in <code>Data</code> when running in <a href="MSEtool.html#topic+runMSE">runMSE</a>.
Otherwise, equals to 1 When running an assessment interactively.</p>
</td></tr>
<tr><td><code id="SP_+3A_data">Data</code></td>
<td>
<p>An object of class Data.</p>
</td></tr>
<tr><td><code id="SP_+3A_addind">AddInd</code></td>
<td>
<p>A vector of integers or character strings indicating the indices to be used in the model. Integers assign the index to
the corresponding index in Data@AddInd, &quot;B&quot; (or 0) represents total biomass in Data@Ind, &quot;VB&quot; represents vulnerable biomass in
Data@VInd, and &quot;SSB&quot; represents spawning stock biomass in Data@SpInd.</p>
</td></tr>
<tr><td><code id="SP_+3A_rescale">rescale</code></td>
<td>
<p>A multiplicative factor that rescales the catch in the assessment model, which
can improve convergence. By default, <code>"mean1"</code> scales the catch so that time series mean is 1, otherwise a numeric.
Output is re-converted back to original units.</p>
</td></tr>
<tr><td><code id="SP_+3A_start">start</code></td>
<td>
<p>Optional list of starting values. Entries can be expressions that are evaluated in the function. See details.</p>
</td></tr>
<tr><td><code id="SP_+3A_prior">prior</code></td>
<td>
<p>A named list for the parameters of any priors to be added to the model. See details.</p>
</td></tr>
<tr><td><code id="SP_+3A_fix_dep">fix_dep</code></td>
<td>
<p>Logical, whether to fix the initial depletion (ratio of biomass to carrying capacity in the
first year of the model). If <code>TRUE</code>, uses the value in <code>start</code>, otherwise equal to 1
(unfished conditions).</p>
</td></tr>
<tr><td><code id="SP_+3A_fix_n">fix_n</code></td>
<td>
<p>Logical, whether to fix the exponent of the production function. If <code>TRUE</code>,
uses the value in <code>start</code>, otherwise equal to <code>n = 2</code>, where the biomass at MSY
is half of carrying capacity.</p>
</td></tr>
<tr><td><code id="SP_+3A_lwt">LWT</code></td>
<td>
<p>A vector of likelihood weights for each survey.</p>
</td></tr>
<tr><td><code id="SP_+3A_n_seas">n_seas</code></td>
<td>
<p>Integer, the number of seasons in the model for calculating continuous surplus production.</p>
</td></tr>
<tr><td><code id="SP_+3A_n_itf">n_itF</code></td>
<td>
<p>Integer, the number of iterations to solve F conditional on the observed catch given multiple seasons within an annual time step.
Ignored if <code>n_seas</code> = 1.</p>
</td></tr>
<tr><td><code id="SP_+3A_euler_lotka">Euler_Lotka</code></td>
<td>
<p>Integer. If greater than zero, the function will calculate a prior for the intrinsic rate of increase to use in the estimation model
(in lieu of an explicit prior in argument <code>prior</code>). The value of this argument specifies the number of stochastic samples used to calculate the prior SD.
See section on priors below.</p>
</td></tr>
<tr><td><code id="SP_+3A_sr_type">SR_type</code></td>
<td>
<p>If <code>use_r_prior = TRUE</code>, the stock-recruit relationship used to calculate the stock-recruit alpha parameter from
steepness and unfished spawners-per-recruit. Used to develop the r prior.</p>
</td></tr>
<tr><td><code id="SP_+3A_silent">silent</code></td>
<td>
<p>Logical, passed to <code><a href="TMB.html#topic+MakeADFun">TMB::MakeADFun()</a></code>, whether TMB
will print trace information during optimization. Used for diagnostics for model convergence.</p>
</td></tr>
<tr><td><code id="SP_+3A_opt_hess">opt_hess</code></td>
<td>
<p>Logical, whether the hessian function will be passed to <code><a href="stats.html#topic+nlminb">stats::nlminb()</a></code> during optimization
(this generally reduces the number of iterations to convergence, but is memory and time intensive and does not guarantee an increase
in convergence rate). Ignored if <code>integrate = TRUE</code>.</p>
</td></tr>
<tr><td><code id="SP_+3A_n_restart">n_restart</code></td>
<td>
<p>The number of restarts (calls to <code><a href="stats.html#topic+nlminb">stats::nlminb()</a></code>) in the optimization procedure, so long as the model
hasn't converged. The optimization continues from the parameters from the previous (re)start.</p>
</td></tr>
<tr><td><code id="SP_+3A_control">control</code></td>
<td>
<p>A named list of parameters regarding optimization to be passed to
<code><a href="stats.html#topic+nlminb">stats::nlminb()</a></code>.</p>
</td></tr>
<tr><td><code id="SP_+3A_...">...</code></td>
<td>
<p>For <code>SP_Fox</code>, additional arguments to pass to <code>SP</code>.</p>
</td></tr>
<tr><td><code id="SP_+3A_fix_sigma">fix_sigma</code></td>
<td>
<p>Logical, whether the standard deviation of the index is fixed. If <code>TRUE</code>,
sigma is fixed to value provided in <code>start</code> (if provided), otherwise, value based on <code>Data@CV_Ind</code>.</p>
</td></tr>
<tr><td><code id="SP_+3A_fix_tau">fix_tau</code></td>
<td>
<p>Logical, the standard deviation of the biomass deviations is fixed. If <code>TRUE</code>,
tau is fixed to value provided in <code>start</code> (if provided), otherwise, equal to 0.1.</p>
</td></tr>
<tr><td><code id="SP_+3A_early_dev">early_dev</code></td>
<td>
<p>Character string describing the years for which biomass deviations are estimated in <code>SP_SS</code>.
By default, deviations are estimated in each year of the model (<code>"all"</code>), while deviations could also be estimated
once index data are available (<code>"index"</code>).</p>
</td></tr>
<tr><td><code id="SP_+3A_integrate">integrate</code></td>
<td>
<p>Logical, whether the likelihood of the model integrates over the likelihood
of the biomass deviations (thus, treating it as a state-space variable).</p>
</td></tr>
<tr><td><code id="SP_+3A_inner.control">inner.control</code></td>
<td>
<p>A named list of arguments for optimization of the random effects, which
is passed on to <a href="TMB.html#topic+newton">newton</a> via <code><a href="TMB.html#topic+MakeADFun">TMB::MakeADFun()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>start</code> (optional), a named list of starting values of estimates can be provided for:
</p>

<ul>
<li> <p><code>MSY</code> Maximum sustainable yield.. Otherwise, 300% of mean catch by default.
</p>
</li>
<li> <p><code>FMSY</code> Steepness. Otherwise, <code>Data@Mort[x]</code> or 0.2 is used.
</p>
</li>
<li> <p><code>dep</code> Initial depletion (B/B0) in the first year of the model. By default, 1.
</p>
</li>
<li> <p><code>n</code> The production function exponent that determines BMSY/B0. By default, 2 so that BMSY/B0 = 0.5.
</p>
</li>
<li> <p><code>sigma</code> Lognormal SD of the index (observation error). By default, 0.05. Not
used with multiple indices.
</p>
</li>
<li> <p><code>tau</code> Lognormal SD of the biomass deviations (process error) in <code>SP_SS</code>. By default, 0.1.
</p>
</li></ul>

<p>Multiple indices are supported in the model.
</p>
<p>Tip: to create the Fox model (Fox 1970), just fix n = 1. See example.
</p>


<h3>Value</h3>

<p>An object of <a href="#topic+Assessment-class">Assessment</a> containing objects and output from TMB.
</p>


<h3>Priors</h3>

<p>The following priors can be added as a named list, e.g., prior = list(r = c(0.25, 0.15), MSY = c(50, 0.1). For each parameter below, provide a vector of values as described:
</p>

<ul>
<li> <p><code>r</code> - A vector of length 2 for the lognormal prior mean (normal space) and SD (lognormal space).
</p>
</li>
<li> <p><code>MSY</code> - A vector of length 2 for the lognormal prior mean (normal space) and SD (lognormal space).
</p>
</li></ul>

<p>In lieu of an explicit r prior provided by the user, set argument <code>Euler_Lotka = TRUE</code> to calculate the prior mean and SD using
the Euler-Lotka method (Equation 15a of McAllister et al. 2001).
The Euler-Lotka method is modified to multiply the left-hand side of equation 15a by the alpha parameter of the
stock-recruit relationship (Stanley et al. 2009). Natural mortality and steepness are sampled in order to generate
a prior distribution for r. See <code>vignette("Surplus_production")</code> for more details.
</p>


<h3>Online Documentation</h3>

<p>Model description and equations are available on the openMSE
<a href="https://openmse.com/features-assessment-models/3-sp/">website</a>.
</p>


<h3>Required Data</h3>


<ul>
<li> <p><code>SP</code>: Cat, Ind
</p>
</li>
<li> <p><code>SP_SS</code>: Cat, Ind
</p>
</li></ul>



<h3>Optional Data</h3>

<p><code>SP_SS</code>: CV_Ind
</p>


<h3>Note</h3>

<p>The model uses the Fletcher (1978) formulation and is parameterized with FMSY and MSY as
leading parameters. The default conditions assume unfished conditions in the first year of the time series
and a symmetric production function (n = 2).
</p>


<h3>Author(s)</h3>

<p>Q. Huynh
</p>


<h3>References</h3>

<p>Fletcher, R. I. 1978. On the restructuring of the Pella-Tomlinson system. Fishery Bulletin 76:515:521.
</p>
<p>Fox, W.W. 1970. An exponential surplus-yield model for optimizing exploited fish populations. Transactions of the American Fisheries Society 99:80-88.
</p>
<p>McAllister, M.K., Pikitch, E.K., and Babcock, E.A. 2001. Using demographic methods to construct Bayesian priors
for the intrinsic rate of increase in the Schaefer model and implications for stock rebuilding. Can. J. Fish.
Aquat. Sci. 58: 1871-1890.
</p>
<p>Pedersen, M. W. and Berg, C. W. 2017. A stochastic surplus production model in continuous time. Fish and Fisheries. 18:226-243.
</p>
<p>Pella, J. J. and Tomlinson, P. K. 1969. A generalized stock production model. Inter-Am. Trop. Tuna Comm., Bull. 13:419-496.
</p>
<p>Prager, M. H. 1994. A suite of extensions to a nonequilibrium surplus-production model. Fishery Bulletin 92:374-389.
</p>
<p>Stanley, R.D., M. McAllister, P. Starr and N. Olsen. 2009. Stock assessment for bocaccio (Sebastes
paucispinis) in British Columbia waters. DFO Can. Sci. Advis. Sec. Res. Doc. 2009/055. xiv + 200 p.
</p>


<h3>See Also</h3>

<p><a href="#topic+SP_production">SP_production</a> <a href="#topic+plot.Assessment">plot.Assessment</a> <a href="#topic+summary.Assessment">summary.Assessment</a> <a href="#topic+retrospective">retrospective</a> <a href="#topic+profile">profile</a> <a href="#topic+make_MP">make_MP</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(swordfish)

#### Observation-error surplus production model
res &lt;- SP(Data = swordfish)

# Provide starting values, assume B/K = 0.875 in first year of model
# and symmetrical production curve (n = 2)
start &lt;- list(dep = 0.875, n = 2)
res &lt;- SP(Data = swordfish, start = start)


plot(res)
profile(res, FMSY = seq(0.1, 0.4, 0.01))
retrospective(res)


#### State-space version
res_SS &lt;- SP_SS(Data = swordfish, start = list(dep = 0.875, sigma = 0.1, tau = 0.1))


plot(res_SS)


#### Fox model
res_Fox &lt;- SP(Data = swordfish, start = list(n = 1), fix_n = TRUE)
res_Fox2 &lt;- SP_Fox(Data = swordfish)

#### SP with r prior calculated internally (100 stochastic samples to get prior SD)
res_prior &lt;- SP(Data = SimulatedData, Euler_Lotka = 100)

#### Pass an r prior to the model with mean = 0.35, lognormal sd = 0.10
res_prior2 &lt;- SP(Data = SimulatedData, prior = list(r = c(0.35, 0.10)))

#### Pass MSY prior to the model with mean = 1500, lognormal sd = 0.05
res_prior3 &lt;- SP(Data = SimulatedData, prior = list(MSY = c(1500, 0.05)))
</code></pre>

<hr>
<h2 id='SP_production'>Find the production parameter based on depletion that produces MSY</h2><span id='topic+SP_production'></span>

<h3>Description</h3>

<p>For surplus production models, this function returns the production exponent n corresponding
to BMSY/K (Fletcher 1978).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SP_production(depletion, figure = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SP_production_+3A_depletion">depletion</code></td>
<td>
<p>The hypothesized depletion that produces MSY.</p>
</td></tr>
<tr><td><code id="SP_production_+3A_figure">figure</code></td>
<td>
<p>Local, plots figure of production function as a function of depletion (B/K)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The production function exponent n (numeric).
</p>


<h3>Note</h3>

<p>May be useful for parameterizing <code>n</code> in <a href="#topic+SP">SP</a> and <a href="#topic+SP_SS">SP_SS</a>.
</p>


<h3>Author(s)</h3>

<p>Q. Huynh
</p>


<h3>References</h3>

<p>Fletcher, R. I. 1978. On the restructuring of the Pella-Tomlinson system. Fishery Bulletin 76:515:521.
</p>


<h3>See Also</h3>

<p><a href="#topic+SP">SP</a> <a href="#topic+SP_SS">SP_SS</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SP_production(0.5)
SP_production(0.5)
</code></pre>

<hr>
<h2 id='SSS'>Simple Stock Synthesis</h2><span id='topic+SSS'></span>

<h3>Description</h3>

<p>A simple age-structured model (<a href="#topic+SCA_Pope">SCA_Pope</a>) fitted to a time series of catch going back to unfished conditions.
Terminal depletion (ratio of current total biomass to unfished biomass) is by default fixed to 0.4. Selectivity is fixed
to the maturity ogive, although it can be overridden with the start argument. The sole parameter estimated is
R0 (unfished recruitment), with no process error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SSS(
  x = 1,
  Data,
  dep = 0.4,
  SR = c("BH", "Ricker"),
  rescale = "mean1",
  start = NULL,
  prior = list(),
  silent = TRUE,
  opt_hess = FALSE,
  n_restart = ifelse(opt_hess, 0, 1),
  control = list(iter.max = 2e+05, eval.max = 4e+05),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SSS_+3A_x">x</code></td>
<td>
<p>A position in the Data object (by default, equal to one for assessments).</p>
</td></tr>
<tr><td><code id="SSS_+3A_data">Data</code></td>
<td>
<p>An object of class Data</p>
</td></tr>
<tr><td><code id="SSS_+3A_dep">dep</code></td>
<td>
<p>Depletion value to use in the model. Can be an expression that will be evaluated inside the function.</p>
</td></tr>
<tr><td><code id="SSS_+3A_sr">SR</code></td>
<td>
<p>Stock-recruit function (either <code>"BH"</code> for Beverton-Holt or <code>"Ricker"</code>).</p>
</td></tr>
<tr><td><code id="SSS_+3A_rescale">rescale</code></td>
<td>
<p>A multiplicative factor that rescales the catch in the assessment model, which
can improve convergence. By default, <code>"mean1"</code> scales the catch so that time series mean is 1, otherwise a numeric.
Output is re-converted back to original units.</p>
</td></tr>
<tr><td><code id="SSS_+3A_start">start</code></td>
<td>
<p>Optional named list of starting values. Entries can be expressions that are evaluated in the function:
</p>

<ul>
<li> <p><code>R0</code> Unfished recruitment
</p>
</li>
<li> <p><code>vul_par</code> A length-two vector for the age of 95% and 50% fleet selectivity. Fixed to maturity otherwise.
</p>
</li></ul>
</td></tr>
<tr><td><code id="SSS_+3A_prior">prior</code></td>
<td>
<p>A named list for the parameters of any priors to be added to the model. See details in <code>SCA_Pope</code>.</p>
</td></tr>
<tr><td><code id="SSS_+3A_silent">silent</code></td>
<td>
<p>Logical, passed to <code><a href="TMB.html#topic+MakeADFun">TMB::MakeADFun()</a></code>, whether TMB
will print trace information during optimization. Used for diagnostics for model convergence.</p>
</td></tr>
<tr><td><code id="SSS_+3A_opt_hess">opt_hess</code></td>
<td>
<p>Logical, whether the hessian function will be passed to <code><a href="stats.html#topic+nlminb">stats::nlminb()</a></code> during optimization
(this generally reduces the number of iterations to convergence, but is memory and time intensive and does not guarantee an increase
in convergence rate).</p>
</td></tr>
<tr><td><code id="SSS_+3A_n_restart">n_restart</code></td>
<td>
<p>The number of restarts (calls to <code><a href="stats.html#topic+nlminb">stats::nlminb()</a></code>) in the optimization procedure, so long as the model
hasn't converged. The optimization continues from the parameters from the previous (re)start.</p>
</td></tr>
<tr><td><code id="SSS_+3A_control">control</code></td>
<td>
<p>A named list of arguments for optimization to be passed to <code><a href="stats.html#topic+nlminb">stats::nlminb()</a></code>.</p>
</td></tr>
<tr><td><code id="SSS_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed (not currently used).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In SAMtool, SSS is an implementation of <a href="#topic+SCA_Pope">SCA_Pope</a> with fixed final depletion
(in terms of total biomass, not spawning biomass) assumption.
</p>


<h3>Value</h3>

<p>An object of class <a href="#topic+Assessment-class">Assessment</a>.
</p>


<h3>Author(s)</h3>

<p>Q. Huynh
</p>


<h3>References</h3>

<p>Cope, J.M. 2013. Implementing a statistical catch-at-age model (Stock Synthesis) as a tool for
deriving overfishing limits in data-limited situations. Fisheries Research 142:3-14.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- SSS(Data = Red_snapper)

SSS_MP &lt;- make_MP(SSS, HCR40_10, dep = 0.3) # Always assume depletion = 0.3
</code></pre>

<hr>
<h2 id='summary.Assessment'>Summary of Assessment object</h2><span id='topic+summary.Assessment'></span><span id='topic+summary+2CAssessment-method'></span>

<h3>Description</h3>

<p>Returns a summary of parameter estimates and output from an <a href="#topic+Assessment-class">Assessment</a> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Assessment'
summary(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.Assessment_+3A_object">object</code></td>
<td>
<p>An object of class <a href="#topic+Assessment-class">Assessment</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>output &lt;- DD_TMB(Data = MSEtool::SimulatedData)
summary(output)
</code></pre>

<hr>
<h2 id='swordfish'>North Atlantic Swordfish dataset</h2><span id='topic+swordfish'></span>

<h3>Description</h3>

<p>An S4 object containing catch and index time series for North Atlantic swordfish.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swordfish
</code></pre>


<h3>Format</h3>

<p>An object of class Data.
</p>


<h3>Source</h3>

<p>ASPIC Software at https://www.mhprager.com/aspic.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(swordfish)

</code></pre>

<hr>
<h2 id='TAC_MSY'>Calculate MSY-based TAC from Assessment object</h2><span id='topic+TAC_MSY'></span><span id='topic+calculate_TAC'></span>

<h3>Description</h3>

<p>A function to calculate the total allowable catch (TAC). Based on the MSY (maximum
sustainable yield) principle, the TAC is the product of
either UMSY or FMSY and the available biomass, i.e. vulnerable biomass, in terminal year.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TAC_MSY(Assessment, reps, MSY_frac = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TAC_MSY_+3A_assessment">Assessment</code></td>
<td>
<p>An Assessment object with estimates of UMSY or FMSY and
terminal year vulnerable biomass.</p>
</td></tr>
<tr><td><code id="TAC_MSY_+3A_reps">reps</code></td>
<td>
<p>The number of stochastic draws of UMSY or FMSY.</p>
</td></tr>
<tr><td><code id="TAC_MSY_+3A_msy_frac">MSY_frac</code></td>
<td>
<p>The fraction of FMSY or UMSY for calculating the TAC (e.g. MSY_frac = 0.75 fishes at 75% of FMSY).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length <code>reps</code> of stochastic samples of TAC recommendation. Returns NA's
if missing either UMSY/FMSY or vulnerable biomass.
</p>


<h3>Note</h3>

<p><code>calculate_TAC</code> is deprecated as of version 1.2 in favor of <code>TAC_MSY</code> because
the latter has a more informative name.
</p>


<h3>See Also</h3>

<p><a href="#topic+HCR_MSY">HCR_MSY</a> <a href="#topic+HCR40_10">HCR40_10</a> <a href="#topic+HCR60_20">HCR60_20</a>
</p>

<hr>
<h2 id='userguide'>Get the SAMtool vignettes</h2><span id='topic+userguide'></span>

<h3>Description</h3>

<p>A convenient function to open a web browser with the openMSE documentation vignettes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>userguide()
</code></pre>


<h3>Value</h3>

<p>Displays a browser webpage to the openMSE website.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>userguide()

</code></pre>

<hr>
<h2 id='VPA'>Virtual population analysis (VPA)</h2><span id='topic+VPA'></span>

<h3>Description</h3>

<p>A VPA model that back-calculates abundance-at-age assuming that the catch-at-age is known without error and tuned to an index.
The population dynamics equations are primarily drawn from VPA-2BOX (Porch 2018). MSY reference points and per-recruit quantities
are then calculated from the VPA output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VPA(
  x = 1,
  Data,
  AddInd = "B",
  expanded = FALSE,
  SR = c("BH", "Ricker"),
  vulnerability = c("logistic", "dome", "free"),
  start = list(),
  fix_h = TRUE,
  fix_Fratio = TRUE,
  fix_Fterm = FALSE,
  LWT = NULL,
  shrinkage = list(),
  n_itF = 5L,
  min_age = "auto",
  max_age = "auto",
  refpt = list(),
  silent = TRUE,
  opt_hess = FALSE,
  n_restart = ifelse(opt_hess, 0, 1),
  control = list(iter.max = 2e+05, eval.max = 4e+05),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VPA_+3A_x">x</code></td>
<td>
<p>A position in the Data object (by default, equal to one for assessments).</p>
</td></tr>
<tr><td><code id="VPA_+3A_data">Data</code></td>
<td>
<p>An object of class Data</p>
</td></tr>
<tr><td><code id="VPA_+3A_addind">AddInd</code></td>
<td>
<p>A vector of integers or character strings indicating the indices to be used in the model. Integers assign the index to
the corresponding index in Data@AddInd, &quot;B&quot; (or 0) represents total biomass in Data@Ind, &quot;VB&quot; represents vulnerable biomass in
Data@VInd, and &quot;SSB&quot; represents spawning stock biomass in Data@SpInd.</p>
</td></tr>
<tr><td><code id="VPA_+3A_expanded">expanded</code></td>
<td>
<p>Whether the catch at age in <code>Data</code> has been expanded. If <code>FALSE</code>, then the catch in weight
should be provided in <code>Data@Cat</code> so that the function can calculate annual expansion factors.</p>
</td></tr>
<tr><td><code id="VPA_+3A_sr">SR</code></td>
<td>
<p>Stock-recruit function (either <code>"BH"</code> for Beverton-Holt or <code>"Ricker"</code>) for calculating MSY reference points.</p>
</td></tr>
<tr><td><code id="VPA_+3A_vulnerability">vulnerability</code></td>
<td>
<p>Whether the terminal year vulnerability is <code>"logistic"</code> or <code>"dome"</code> (double-normal). If <code>"free"</code>,
independent F's are calculated in the terminal year (subject to the assumed ratio of F of the plus-group to the previous age class).
See details for parameterization.</p>
</td></tr>
<tr><td><code id="VPA_+3A_start">start</code></td>
<td>
<p>Optional list of starting values. Entries can be expressions that are evaluated in the function. See details.</p>
</td></tr>
<tr><td><code id="VPA_+3A_fix_h">fix_h</code></td>
<td>
<p>Logical, whether to fix steepness to value in <code>Data@steep</code>. This only affects
calculation of MSY and unfished reference points.</p>
</td></tr>
<tr><td><code id="VPA_+3A_fix_fratio">fix_Fratio</code></td>
<td>
<p>Logical, whether the ratio of F of the plus-group to the previous age class is fixed in the model.</p>
</td></tr>
<tr><td><code id="VPA_+3A_fix_fterm">fix_Fterm</code></td>
<td>
<p>Logical, whether to fix the value of the terminal F.</p>
</td></tr>
<tr><td><code id="VPA_+3A_lwt">LWT</code></td>
<td>
<p>A vector of likelihood weights for each survey.</p>
</td></tr>
<tr><td><code id="VPA_+3A_shrinkage">shrinkage</code></td>
<td>
<p>A named list of up to length 2 to constrain parameters:
</p>

<ul>
<li> <p><code>vul</code> - a length two vector that constrains the vulnerability-at-age in the most recent years. The first number
is the number of years in which vulnerability will be constrained (as a random walk in log space), the second number is the standard deviation of the random walk.
The default
</p>
</li>
<li> <p><code>R</code> - a length two vector that constrains the recruitment estimates in the most recent years. The first number
is the number of years in which recruitment will be constrained (as a random walk in log space), the second number is the standard deviation of the random walk.
</p>
</li></ul>
</td></tr>
<tr><td><code id="VPA_+3A_n_itf">n_itF</code></td>
<td>
<p>The number of iterations for solving F in the model (via Newton's method).</p>
</td></tr>
<tr><td><code id="VPA_+3A_min_age">min_age</code></td>
<td>
<p>An integer to specify the smallest age class in the VPA. By default, the youngest age with non-zero CAA in the terminal year is used.</p>
</td></tr>
<tr><td><code id="VPA_+3A_max_age">max_age</code></td>
<td>
<p>An integer to specify the oldest age class in the VPA. By default, the oldest age with non-zero CAA for all years is used.</p>
</td></tr>
<tr><td><code id="VPA_+3A_refpt">refpt</code></td>
<td>
<p>A named list of how many years to average parameters for calculating reference points, yield per recruit, and spawning potential ratio:
</p>

<ul>
<li> <p><code>vul</code> An integer for the number of most recent years to average the vulnerability schedule (default is 3).
</p>
</li>
<li> <p><code>R</code> A length two for the quantile used to calculate recruitment in the year following the terminal year and the number of years
from which that quantile is used, i.e., <code>c(0.5, 5)</code> is the default that calculates median recruitment from the most recent 5 years of the model.
</p>
</li></ul>
</td></tr>
<tr><td><code id="VPA_+3A_silent">silent</code></td>
<td>
<p>Logical, passed to <code><a href="TMB.html#topic+MakeADFun">TMB::MakeADFun()</a></code>, whether TMB
will print trace information during optimization. Used for diagnostics for model convergence.</p>
</td></tr>
<tr><td><code id="VPA_+3A_opt_hess">opt_hess</code></td>
<td>
<p>Logical, whether the hessian function will be passed to <code><a href="stats.html#topic+nlminb">stats::nlminb()</a></code> during optimization
(this generally reduces the number of iterations to convergence, but is memory and time intensive and does not guarantee an increase
in convergence rate). Ignored if <code>integrate = TRUE</code>.</p>
</td></tr>
<tr><td><code id="VPA_+3A_n_restart">n_restart</code></td>
<td>
<p>The number of restarts (calls to <code><a href="stats.html#topic+nlminb">stats::nlminb()</a></code>) in the optimization procedure, so long as the model
hasn't converged. The optimization continues from the parameters from the previous (re)start.</p>
</td></tr>
<tr><td><code id="VPA_+3A_control">control</code></td>
<td>
<p>A named list of arguments for optimization to be passed to
<code><a href="stats.html#topic+nlminb">stats::nlminb()</a></code>.</p>
</td></tr>
<tr><td><code id="VPA_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The VPA is initialized by estimating the terminal F-at-age. Parameter <code>Fterm</code> is the apical terminal F if
a functional form for vulnerability is used in the terminal year, i.e., when <code>vulnerability = "logistic"</code> or <code>"free"</code>.
If the terminal F-at-age are otherwise independent parameters,
<code>Fterm</code> is the F for the reference age which is half the maximum age. Once terminal-year abundance is
estimated, the abundance in historical years can be back-calculated. The oldest age group is a plus-group, and requires
an assumption regarding the ratio of F's between the plus-group and the next youngest age class. The F-ratio can
be fixed (default) or estimated.
</p>
<p>For <code>start</code> (optional), a named list of starting values of estimates can be provided for:
</p>

<ul>
<li> <p><code>Fterm</code> The terminal year fishing mortality. This is the apical F when <code>vulnerability = "logistic"</code> or <code>"free"</code>.
</p>
</li>
<li> <p><code>Fratio</code> The ratio of F in the plus-group to the next youngest age. If not provided, a value of 1 is used.
</p>
</li>
<li> <p><code>vul_par</code> Vulnerability parameters in the terminal year. This will be of length 2 vector for <code>"logistic"</code> or length 4 for
<code>"dome"</code>, see <a href="#topic+SCA">SCA</a> for further documentation on parameterization. For option <code>"free"</code>, this will be a vector of length
A-2 where A is the number of age classes in the model. To estimate parameters, vulnerability is initially set to one at half the max age
(and subsequently re-calculated relative to the maximum F experienced in that year). Vulnerability in the plus-group is also constrained
by the Fratio.
</p>
</li></ul>

<p>MSY and depletion reference points are calculated by fitting the stock recruit relationship to the recruitment and SSB estimates. Per-recruit
quantities are also calculated, which may be used in harvest control rules.
</p>


<h3>Value</h3>

<p>An object of class <a href="#topic+Assessment-class">Assessment</a>. The F vector is the apical fishing mortality experienced by any
age class in a given year.
</p>


<h3>Additional considerations</h3>

<p>The VPA tends to be finicky to implement straight out of the box. For example, zeros in plusgroup age in the catch-at-age
model will crash the model, as well as if the catch-at-age values are close to zero. The model sets F-at-age to 1e-4
if any catch-at-age value &lt; 1e-4.
</p>
<p>It is recommended to do some preliminary fits with the VPA before running simulations en masse. See example below.
</p>
<p>Shrinkage, penalty functions that stabilize model estimates of recruitment and selectivity year-over-year near
the end of the time series, alters the behavior of the model. This is something to tinker with in your initial
model fits, and worth evaluating in closed-loop simulation.
</p>


<h3>Online Documentation</h3>

<p>Model description and equations are available on the openMSE
<a href="https://openmse.com/features-assessment-models/4-vpa/">website</a>.
</p>


<h3>References</h3>

<p>Porch, C.E. 2018. VPA-2BOX 4.01 User Guide. NOAA Tech. Memo. NMFS-SEFSC-726. 67 pp.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
OM &lt;- MSEtool::testOM

# Simulate logistic normal age comps with CV = 0.1
# (set CAA_ESS &lt; 1, which is interpreted as a CV)
OM@CAA_ESS &lt;- c(0.1, 0.1) 
Hist &lt;- MSEtool::Simulate(OM, silent = TRUE)

# VPA max age is 15 (Hist@Data@MaxAge)
m &lt;- VPA(x = 2, Data = Hist@Data, vulnerability = "dome")

# Use age-9 as the VPA max age instead
m9 &lt;- VPA(x = 2, Data = Hist@Data, vulnerability = "dome", max_age = 9)

compare_models(m, m9)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
