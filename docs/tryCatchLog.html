<!DOCTYPE html><html><head><title>Help for package tryCatchLog</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tryCatchLog}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#append.to.last.tryCatchLog.result'><p>Appends a new log entry to the stored logging output of the last call to <code>tryCatchLog</code> or <code>tryLog</code></p></a></li>
<li><a href='#build.log.entry'><p>Creates a log entry as a single <code>data.frame</code> row containing all relevant logging information in columns</p></a></li>
<li><a href='#build.log.output'><p>Creates a single string suited as logging output</p></a></li>
<li><a href='#determine.platform.NewLine'><p>Determines the operating system specific new line character(s)</p></a></li>
<li><a href='#get.pretty.call.stack'><p>Pretty formatted call stack enriched with the source file names and row numbers</p></a></li>
<li><a href='#get.pretty.option.value'><p>gets the current value of an option as key/value string</p></a></li>
<li><a href='#get.pretty.tryCatchLog.options'><p>Gets the current option values of all options supported by the 'tryCatchLog' package</p></a></li>
<li><a href='#is.duplicated.log.entry'><p>Check if a new log entry would be a duplicate of on an already existing log entry</p></a></li>
<li><a href='#is.package.available'><p>Checks if a package is installed and can be loaded</p></a></li>
<li><a href='#is.windows'><p>Determines if R is running on a Windows operating system</p></a></li>
<li><a href='#last.tryCatchLog.result'><p>Gets the logging result of the last call to <code>tryCatchLog</code> or <code>tryLog</code></p></a></li>
<li><a href='#limitedLabelsCompact'><p>Convert a call stack into a list of printable strings</p></a></li>
<li><a href='#log2console'><p>Prints a time-stamped log message to the console incl. the severity level</p></a></li>
<li><a href='#platform.NewLine'><p>Gets the operating system specific new line character(s)</p></a></li>
<li><a href='#reset.last.tryCatchLog.result'><p>Resets the stored logging output of the last call to <code>tryCatchLog</code> or <code>tryLog</code> to an empty list</p></a></li>
<li><a href='#set.logging.functions'><p>Sets the logging functions that shall be used by <code>tryCatchLog</code> for the different severity levels</p></a></li>
<li><a href='#tryCatchLog'><p>Try an expression with condition logging and error handling</p></a></li>
<li><a href='#tryLog'><p>Try an expression with condition logging and error recovery</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Advanced 'tryCatch()' and 'try()' Functions</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Advanced tryCatch() and try() functions for better error handling
             (logging, stack trace with source code references and support for post-mortem analysis via dump files).</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/aryoda/tryCatchLog">https://github.com/aryoda/tryCatchLog</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/aryoda/tryCatchLog/issues">https://github.com/aryoda/tryCatchLog/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>futile.logger, testthat, knitr, rmarkdown, covr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-10-24 21:40:43 UTC; juergen</td>
</tr>
<tr>
<td>Author:</td>
<td>Juergen Altfeld [aut, cre, cph],
  Charles Epaillard [ctb],
  Brandon Bertelsen [ctb],
  Valerian Wrobel [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Juergen Altfeld &lt;jaltfeld@altfeld-im.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-10-25 07:10:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='append.to.last.tryCatchLog.result'>Appends a new log entry to the stored logging output of the last call to <code>tryCatchLog</code> or <code>tryLog</code></h2><span id='topic+append.to.last.tryCatchLog.result'></span>

<h3>Description</h3>

<p>You can get the last logging output by calling <code><a href="#topic+last.tryCatchLog.result">last.tryCatchLog.result</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>append.to.last.tryCatchLog.result(new.log.entry)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="append.to.last.tryCatchLog.result_+3A_new.log.entry">new.log.entry</code></td>
<td>
<p>the new log entry (a <code>data.frame</code> created with <code>link{build.log.entry}</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>THIS FUNCTION IS USED ONLY PACKAGE INTERNALLY!
</p>


<h3>Value</h3>

<p>the complete logging result of the last call to <code>tryCatchLog</code> or <code>tryLog</code> as <code>data.frame</code>
</p>


<h3>Note</h3>

<p>THIS IS A PACKAGE INTERNAL FUNCTION AND THEREFORE NOT EXPORTED.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+last.tryCatchLog.result">last.tryCatchLog.result</a></code>,
<code><a href="#topic+reset.last.tryCatchLog.result">reset.last.tryCatchLog.result</a></code>,
</p>

<hr>
<h2 id='build.log.entry'>Creates a log entry as a single <code>data.frame</code> row containing all relevant logging information in columns</h2><span id='topic+build.log.entry'></span>

<h3>Description</h3>

<p>The serverity level should correspond to the condition class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build.log.entry(
  timestamp,
  severity,
  msg.text,
  execution.context.msg,
  call.stack,
  dump.file.name,
  omit.call.stack.items = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build.log.entry_+3A_timestamp">timestamp</code></td>
<td>
<p>logging timestamp as <code><a href="base.html#topic+POSIXct">POSIXct</a></code> (normally by calling <code><a href="base.html#topic+Sys.time">Sys.time</a></code>)</p>
</td></tr>
<tr><td><code id="build.log.entry_+3A_severity">severity</code></td>
<td>
<p>severity level of the log entry ((ERROR, WARN, INFO etc.)</p>
</td></tr>
<tr><td><code id="build.log.entry_+3A_msg.text">msg.text</code></td>
<td>
<p>Logging message (e. g. error message)</p>
</td></tr>
<tr><td><code id="build.log.entry_+3A_execution.context.msg">execution.context.msg</code></td>
<td>
<p>a text identifier (eg. the PID or a variable value) that will be appended to msg.text
for catched conditions. Must be a character or an error is thrown.</p>
</td></tr>
<tr><td><code id="build.log.entry_+3A_call.stack">call.stack</code></td>
<td>
<p>a call stack created by <code><a href="base.html#topic+sys.calls">sys.calls</a></code></p>
</td></tr>
<tr><td><code id="build.log.entry_+3A_dump.file.name">dump.file.name</code></td>
<td>
<p>name of the created dump file (leave empty if the <code><a href="#topic+tryCatchLog">tryCatchLog</a></code>
argument <code>write.error.dump.file</code> is <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="build.log.entry_+3A_omit.call.stack.items">omit.call.stack.items</code></td>
<td>
<p>the number of stack trace items to ignore (= last x calls) in
the passed <code>call.stack</code> since they are caused by using <code>tryCatchLog</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>tryCatchLog.log.entry</code> and <code><a href="base.html#topic+data.frame">data.frame</a></code> and the following columns:
</p>

<ol>
<li><p>timestamp   - creation date and time of the logging entry
</p>
</li>
<li><p>severity    - the serverity level of the log entry (ERROR, WARN, INFO etc.)
</p>
</li>
<li><p>msg.text    - the message text of the log entry
</p>
</li>
<li><p>compact.stack.trace - the short stack trace containing only entries with source code
references down to line of code that has thrown the condition
</p>
</li>
<li><p>full.stack.trace    - the full stack trace with all calls down to the line of code that
has thrown the condition (including calls to R internal functions
and other functions even when the source code in not available).
</p>
</li>
<li><p>dump.file.name      - name of the created dump file (if any)
</p>
</li></ol>



<h3>Note</h3>

<p>THIS IS A PACKAGE INTERNAL FUNCTION AND THEREFORE NOT EXPORTED.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+last.tryCatchLog.result">last.tryCatchLog.result</a></code>
<code><a href="#topic+build.log.output">build.log.output</a></code>
</p>

<hr>
<h2 id='build.log.output'>Creates a single string suited as logging output</h2><span id='topic+build.log.output'></span>

<h3>Description</h3>

<p>To view the formatted output print the logging output in a console use <code><a href="base.html#topic+cat">cat</a></code>
(instead of printing the output with <code><a href="base.html#topic+print">print</a></code> which shows the newline escape codes).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build.log.output(
  log.results,
  include.full.call.stack = getOption("tryCatchLog.include.full.call.stack", TRUE),
  include.compact.call.stack = getOption("tryCatchLog.include.compact.call.stack",
    TRUE),
  include.severity = TRUE,
  include.timestamp = FALSE,
  use.platform.newline = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build.log.output_+3A_log.results">log.results</code></td>
<td>
<p>A <code>data.frame</code> and member of the class <code>tryCatchLog.log.entry</code>
with log entry rows as returned by <code><a href="#topic+last.tryCatchLog.result">last.tryCatchLog.result</a></code>
containing the logging information to be prepared for the logging output.</p>
</td></tr>
<tr><td><code id="build.log.output_+3A_include.full.call.stack">include.full.call.stack</code></td>
<td>
<p>Flag of type <code><a href="base.html#topic+logical">logical</a></code>:
Shall the full call stack be included in the log output? Since the full
call stack may be very long and the compact call stack has enough details
normally the full call stack can be omitted by passing <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="build.log.output_+3A_include.compact.call.stack">include.compact.call.stack</code></td>
<td>
<p>Flag of type <code><a href="base.html#topic+logical">logical</a></code>:
Shall the compact call stack (including only calls with source code references)
be included in the log output? Note: If you ommit both the full and compact
call stacks the message text will be output without call stacks.</p>
</td></tr>
<tr><td><code id="build.log.output_+3A_include.severity">include.severity</code></td>
<td>
<p><code>logical</code> switch if the severity level (e. g. ERROR) shall be
included in the output</p>
</td></tr>
<tr><td><code id="build.log.output_+3A_include.timestamp">include.timestamp</code></td>
<td>
<p><code>logical</code> switch if the timestamp of the catched condition shall be
included in the output</p>
</td></tr>
<tr><td><code id="build.log.output_+3A_use.platform.newline">use.platform.newline</code></td>
<td>
<p><code>logical</code>: If <code>TRUE</code> the line breaks (&quot;newline&quot;) will be
inserted according to the current operationg system (Windows: CR+LF,
else: CR). If <code>FALSE</code> R's usual <code>\n</code> esacpe character will be inserted
and it is left to the client to convert this later into the operation-system-specific
characters. This argument is rarely required (except e. g. if you want to
write the return value into a database table column on Windows).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ready to use logging output with stack trace
(as <code>character</code>)
</p>


<h3>Note</h3>

<p>The logged call stack details (compact, full or both) can be configured globally
using the options <code>tryCatchLog.include.full.call.stack</code>
and <code>tryCatchLog.include.compact.call.stack</code>.
</p>
<p>The result of the package internal function <code><a href="#topic+build.log.entry">build.log.entry</a></code>
can be passed as <code>log.results</code> argument.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+last.tryCatchLog.result">last.tryCatchLog.result</a></code>
<code><a href="#topic+build.log.entry">build.log.entry</a></code>
</p>

<hr>
<h2 id='determine.platform.NewLine'>Determines the operating system specific new line character(s)</h2><span id='topic+determine.platform.NewLine'></span>

<h3>Description</h3>

<p>CR + LF on Windows, else only LF...
</p>


<h3>Usage</h3>

<pre><code class='language-R'>determine.platform.NewLine()
</code></pre>


<h3>Details</h3>

<p>This function is pendant to Microsoft's .Net &quot;Environment.NewLine&quot;.
</p>


<h3>Value</h3>

<p>the new line character(s) for the current operating system
</p>


<h3>Note</h3>

<p>THIS IS A PACKAGE INTERNAL FUNCTION AND THEREFORE NOT EXPORTED.
</p>


<h3>References</h3>

<p><a href="https://stackoverflow.com/questions/47478498/build-string-with-os-specific-newline-characters-crlf-lf-cr-to-write-it-into">https://stackoverflow.com/questions/47478498/build-string-with-os-specific-newline-characters-crlf-lf-cr-to-write-it-into</a>
</p>

<hr>
<h2 id='get.pretty.call.stack'>Pretty formatted call stack enriched with the source file names and row numbers</h2><span id='topic+get.pretty.call.stack'></span>

<h3>Description</h3>

<p>Enriches the current call stack with the source file names and row numbers
to track the location of thrown conditions and generates a prettily formatted list
of strings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.pretty.call.stack(call.stack, omit.last.items = 0, compact = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.pretty.call.stack_+3A_call.stack">call.stack</code></td>
<td>
<p>Call stack object created by <code><a href="base.html#topic+sys.calls">sys.calls</a></code></p>
</td></tr>
<tr><td><code id="get.pretty.call.stack_+3A_omit.last.items">omit.last.items</code></td>
<td>
<p>Number of call stack items to drop from the end of the full stack trace</p>
</td></tr>
<tr><td><code id="get.pretty.call.stack_+3A_compact">compact</code></td>
<td>
<p>TRUE will return only call stack items that have a source code reference (FALSE all)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>How to read the call stack:
</p>

<ol>
<li><p> Call stack items consist of:<br />
<code>&lt;call stack item number&gt; [&lt;file name&gt;#&lt;row number&gt;:] &lt;expression executed by this code line&gt;</code>
</p>
</li>
<li><p> The last call stack items with a file name and row number points to the source code line causing the error.
</p>
</li>
<li><p> Ignore all call stack items that do not start with a file name and row number (R internal calls only)
</p>
</li></ol>

<p>You should only call this function from within <code><a href="base.html#topic+withCallingHandlers">withCallingHandlers</a></code>, NOT from within <code><a href="base.html#topic+tryCatch">tryCatch</a></code>
since tryCatch unwinds the call stack to the tryCatch position and the source of the condition cannot be identified anymore.
</p>


<h3>Value</h3>

<p>The call stack (<code><a href="base.html#topic+sys.calls">sys.calls</a></code>) without the last number of function calls (given by &quot;omit.last.items&quot;)
to remove irrelevant calls caused e. g. by exception handler (<code><a href="base.html#topic+withCallingHandlers">withCallingHandlers</a></code>)
or restarts (of warnings).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tryCatchLog">tryCatchLog</a></code>, <code><a href="#topic+tryLog">tryLog</a></code>, <code><a href="#topic+limitedLabelsCompact">limitedLabelsCompact</a></code>
</p>

<hr>
<h2 id='get.pretty.option.value'>gets the current value of an option as key/value string</h2><span id='topic+get.pretty.option.value'></span>

<h3>Description</h3>

<p>The data type is also indicated if an option is set (since a wrong data type may cause problems).
If an option is not set &quot;(not set)&quot; is shown as value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.pretty.option.value(option.name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.pretty.option.value_+3A_option.name">option.name</code></td>
<td>
<p>Name of the option (as character)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>THIS IS AN INTERNAL PRIVATE FUNCTION OF THE PACKAGE.
</p>


<h3>Value</h3>

<p>The option as key/value string in one line
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get.pretty.tryCatchLog.options">get.pretty.tryCatchLog.options</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
tryCatchLog:::get.pretty.option.value("warn")
# [1] "Option warn = 0 (double)" 
## End(Not run)
</code></pre>

<hr>
<h2 id='get.pretty.tryCatchLog.options'>Gets the current option values of all options supported by the 'tryCatchLog' package</h2><span id='topic+get.pretty.tryCatchLog.options'></span>

<h3>Description</h3>

<p>This is a convenience function whose result can be used e. g. to log the current settings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.pretty.tryCatchLog.options()
</code></pre>


<h3>Details</h3>

<p>If an option is not set the string &quot;(not set)&quot; is shown as value.
</p>
<p>The data type is also indicated if an option is set (since a wrong data type may cause problems).
</p>


<h3>Value</h3>

<p>The current option settings as string (one per line as key/value pair), e. g.
</p>
<pre>
Option tryCatchLog.write.error.dump.file = FALSE (logical)
Option tryCatchLog.write.error.folder = . (character)
Option tryCatchLog.silent.warnings = FALSE (logical)
Option tryCatchLog.silent.messages = (not set)
</pre>


<h3>Examples</h3>

<pre><code class='language-R'>cat(get.pretty.tryCatchLog.options())  # "cat" does apply new line escape characters

</code></pre>

<hr>
<h2 id='is.duplicated.log.entry'>Check if a new log entry would be a duplicate of on an already existing log entry</h2><span id='topic+is.duplicated.log.entry'></span>

<h3>Description</h3>

<p>The <code>log.entry</code> is checked against the existing log entries from
<code><a href="#topic+last.tryCatchLog.result">last.tryCatchLog.result</a></code> using the following columns:
</p>

<ol>
<li><p>msg.text
</p>
</li>
<li><p>full.stack.trace
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>is.duplicated.log.entry(log.entry)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.duplicated.log.entry_+3A_log.entry">log.entry</code></td>
<td>
<p>A <code>data.frame</code> with the new log entry (exactly one row)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if the <code>log.entry</code> is a duplicate, else <code>FALSE</code>
</p>


<h3>Note</h3>

<p>Required function to fix issue #18
(<a href="https://github.com/aryoda/tryCatchLog/issues/18">https://github.com/aryoda/tryCatchLog/issues/18</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+last.tryCatchLog.result">last.tryCatchLog.result</a></code>,
<code><a href="#topic+build.log.entry">build.log.entry</a></code>
</p>

<hr>
<h2 id='is.package.available'>Checks if a package is installed and can be loaded</h2><span id='topic+is.package.available'></span>

<h3>Description</h3>

<p>Use this function to check for optional package dependencies
within this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.package.available(package.name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.package.available_+3A_package.name">package.name</code></td>
<td>
<p>Name of the package (as string)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a package-internal function!
</p>
<p>See section ‘Good practice’ in '?.onAttach'.
</p>


<h3>Value</h3>

<p><code>TRUE</code> if the packages is installed, otherwise <code>FALSE</code>
</p>
<p>http://r-pkgs.had.co.nz/description.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tryCatchLog:::is.package.available("tryCatchLog")  # must be TRUE :-)

</code></pre>

<hr>
<h2 id='is.windows'>Determines if R is running on a Windows operating system</h2><span id='topic+is.windows'></span>

<h3>Description</h3>

<p>Throws a warning if an indication for Windows OS were found but the Windows OS cannot be recognized for sure
(via a second different check).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.windows()
</code></pre>


<h3>Value</h3>

<p><code>TRUE</code> of running on a Windows OS else <code>FALSE</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is.windows()
</code></pre>

<hr>
<h2 id='last.tryCatchLog.result'>Gets the logging result of the last call to <code>tryCatchLog</code> or <code>tryLog</code></h2><span id='topic+last.tryCatchLog.result'></span>

<h3>Description</h3>

<p>This funktion makes the logging results of all thrown conditions of the last <code>tryCatchLog</code> or <code>tryLog</code> call
available in a structured form (<code>data.frame</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>last.tryCatchLog.result()
</code></pre>


<h3>Details</h3>

<p>The typical use case is to get and store the log output not only in a log file but
also in another place that is not supported by the logging framework, e. g. in
a data base table of your application or displaying it in a GUI (user interface).
</p>
<p>Another use case is to review the last log output on the console during debugging.
</p>


<h3>Value</h3>

<p>the logging result of the last call to <code><a href="#topic+tryCatchLog">tryCatchLog</a></code> or <code><a href="#topic+tryLog">tryLog</a></code>
as <code><a href="base.html#topic+data.frame">data.frame</a></code> comprised of one row per logged condition with these columns:
</p>

<ol>
<li><p>timestamp   - creation date and time of the logging entry
</p>
</li>
<li><p>severity    - the serverity level of the log entry (ERROR, WARN, INFO etc.)
</p>
</li>
<li><p>msg.text    - the message text of the log entry
</p>
</li>
<li><p>execution.context.msg - text identifier (eg. the PID or a variable value)
as passed as argument to <code><a href="#topic+tryCatchLog">tryCatchLog</a></code> or <code><a href="#topic+tryLog">tryLog</a></code>
to make it easier to identify the runtime state that caused
a condition esp. in parallel execution scenarios
</p>
</li>
<li><p>compact.stack.trace   - the short stack trace containing only entries with source code
references down to line of code that has thrown the condition
</p>
</li>
<li><p>full.stack.trace      - the full stack trace with all calls down to the line of code that
has thrown the condition (including calls to R internal functions
and other functions even when the source code in not available).
</p>
</li>
<li><p>dump.file.name        - name of the created dump file (if any)
</p>
</li></ol>

<p>If no condition is logged at all an empty <code>data.table</code> is returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tryCatchLog">tryCatchLog</a></code>,
<code><a href="#topic+tryLog">tryLog</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>last.tryCatchLog.result()

</code></pre>

<hr>
<h2 id='limitedLabelsCompact'>Convert a call stack into a list of printable strings</h2><span id='topic+limitedLabelsCompact'></span>

<h3>Description</h3>

<p>Converts a call stack into a list of printable strings (&quot;labels&quot;) with a limited length per call.
If source code references are available they are also printed in the stack trace using this notation:
<code>&lt;file name&gt;#&lt;line number&gt;: executed R expression (call)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>limitedLabelsCompact(
  value,
  compact = FALSE,
  maxwidth = getOption("width") - 5L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="limitedLabelsCompact_+3A_value">value</code></td>
<td>
<p>a list of calls (&quot;call.stack&quot;) generated by <code><a href="base.html#topic+sys.calls">sys.calls</a></code></p>
</td></tr>
<tr><td><code id="limitedLabelsCompact_+3A_compact">compact</code></td>
<td>
<p>if TRUE only calls that contain a source code reference (attribute &quot;srcref&quot;) are returned
(plus always the first call); if FALSE all calls will be returned.</p>
</td></tr>
<tr><td><code id="limitedLabelsCompact_+3A_maxwidth">maxwidth</code></td>
<td>
<p>Maximum number of characters per call in the return value (longer strings will be cutted).
Must be between 40 and 2000 (until version 1.2.2: 1000)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default the maximum number of source code rows that are printed per call in the full stack trace
is 10. You can change this via the option <code>tryCatchLog.max.lines.per.call</code> (see example).
</p>
<p>R does track source code references only if you set the option &quot;keep.source&quot; to TRUE via
<code>options(keep.source = TRUE)</code>. Without this option this function cannot enrich source code references.
If you use <code>Rscript</code> to start a non-interactive R script as batch job you
have to set this option since it is FALSE by default. You can add this option to your
<a href="base.html#topic+.Rprofile">.Rprofile</a> file or use a startup R script that sets this option and sources your
actual R script then.
</p>
<p>This function is based on the undocumented <code><a href="utils.html#topic+limitedLabels">limitedLabels</a></code> function of the base package.
The source code can be viewed by entering <code>limitedLabels</code> in the R console.
The attributes required to add source file names and line numbers to the calls (srcref and srcfile)
and how they are created internally are explained in this article:
<a href="https://journal.r-project.org/archive/2010-2/RJournal_2010-2_Murdoch.pdf">https://journal.r-project.org/archive/2010-2/RJournal_2010-2_Murdoch.pdf</a>
</p>


<h3>Value</h3>

<p>A list of strings (one for each call).
If <code>compact</code> is <code>TRUE</code> at the last call is returned even if it does not contain
a source code reference.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+sys.calls">sys.calls</a></code>, <code><a href="#topic+tryCatchLog">tryCatchLog</a></code>, <code><a href="#topic+get.pretty.call.stack">get.pretty.call.stack</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>options(tryCatchLog.max.lines.per.call = 30)
limitedLabelsCompact(sys.calls(), TRUE)
</code></pre>

<hr>
<h2 id='log2console'>Prints a time-stamped log message to the console incl. the severity level</h2><span id='topic+log2console'></span>

<h3>Description</h3>

<p>This is a package-internal function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log2console(severity.level, msg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="log2console_+3A_severity.level">severity.level</code></td>
<td>
<p>String containing the severity level
(<code>ERROR</code>, <code>WARN</code> or <code>INFO</code>) of the message</p>
</td></tr>
<tr><td><code id="log2console_+3A_msg">msg</code></td>
<td>
<p>The message to be printed (as character).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The log message as it was printed to the console.
<code>NA</code> is printed as empty string.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tryCatchLog:::log2console("WARN", "this is my last warning")

</code></pre>

<hr>
<h2 id='platform.NewLine'>Gets the operating system specific new line character(s)</h2><span id='topic+platform.NewLine'></span>

<h3>Description</h3>

<p>CR + LF on Windows, else only LF...
</p>


<h3>Usage</h3>

<pre><code class='language-R'>platform.NewLine()
</code></pre>


<h3>Details</h3>

<p>The newline character(s) are determined once at package loading time.
</p>


<h3>Value</h3>

<p>the new line character(s) for the current operating system
</p>


<h3>Examples</h3>

<pre><code class='language-R'>platform.NewLine()
</code></pre>

<hr>
<h2 id='reset.last.tryCatchLog.result'>Resets the stored logging output of the last call to <code>tryCatchLog</code> or <code>tryLog</code> to an empty list</h2><span id='topic+reset.last.tryCatchLog.result'></span>

<h3>Description</h3>

<p>You can get the last logging output by calling <code><a href="#topic+last.tryCatchLog.result">last.tryCatchLog.result</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reset.last.tryCatchLog.result()
</code></pre>


<h3>Value</h3>

<p>invisible: TRUE
</p>


<h3>Note</h3>

<p>THIS IS A PACKAGE INTERNAL FUNCTION AND THEREFORE NOT EXPORTED.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+last.tryCatchLog.result">last.tryCatchLog.result</a></code>,
<code><a href="#topic+append.to.last.tryCatchLog.result">append.to.last.tryCatchLog.result</a></code>,
</p>

<hr>
<h2 id='set.logging.functions'>Sets the logging functions that shall be used by <code>tryCatchLog</code> for the different severity levels</h2><span id='topic+set.logging.functions'></span>

<h3>Description</h3>

<p>The logging functions must have at least one parameter: The logging message (as character)
which must be the first argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.logging.functions(
  error.log.func = function(msg) tryCatchLog:::log2console("ERROR", msg),
  warn.log.func = function(msg) tryCatchLog:::log2console("WARN", msg),
  info.log.func = function(msg) tryCatchLog:::log2console("INFO", msg)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set.logging.functions_+3A_error.log.func">error.log.func</code></td>
<td>
<p>The logging function for errors</p>
</td></tr>
<tr><td><code id="set.logging.functions_+3A_warn.log.func">warn.log.func</code></td>
<td>
<p>The logging function for warning</p>
</td></tr>
<tr><td><code id="set.logging.functions_+3A_info.log.func">info.log.func</code></td>
<td>
<p>The error function for messages</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default logging functions are internal functions without any dependencies to other
logging packages. They use the same logging output format as <span class="pkg">futile.logger</span> version 1.4.3.
</p>
<p>If you want to disable any logging output you should use a decent logging framework
which allows to set the logging threshold (e. g. futile.logger's <code><a href="futile.logger.html#topic+flog.threshold">flog.threshold</a></code>).
</p>
<p>The package-internal default logging functions are only a minimal implementation
and are not meant to replace a decent logging framework.
</p>


<h3>Value</h3>

<p>Nothing
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tryCatchLog">tryCatchLog</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># To disable any logging you could use "empty" functions
set.logging.functions( error.log.func = function(msg) invisible(),
                       warn.log.func  = function(msg) invisible(),
                       info.log.func  = function(msg) invisible())

</code></pre>

<hr>
<h2 id='tryCatchLog'>Try an expression with condition logging and error handling</h2><span id='topic+tryCatchLog'></span>

<h3>Description</h3>

<p>This function evaluates an expression passed in the <code>expr</code> parameter,
logs all conditions and executes the condition handlers passed in <code>...</code> (if any).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tryCatchLog(
  expr,
  ...,
  execution.context.msg = "",
  finally = NULL,
  write.error.dump.file = getOption("tryCatchLog.write.error.dump.file", FALSE),
  write.error.dump.folder = getOption("tryCatchLog.write.error.dump.folder", "."),
  silent.warnings = getOption("tryCatchLog.silent.warnings", FALSE),
  silent.messages = getOption("tryCatchLog.silent.messages", FALSE),
  include.full.call.stack = getOption("tryCatchLog.include.full.call.stack", TRUE),
  include.compact.call.stack = getOption("tryCatchLog.include.compact.call.stack",
    TRUE),
  logged.conditions = getOption("tryCatchLog.logged.conditions", NULL)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tryCatchLog_+3A_expr">expr</code></td>
<td>
<p>R expression to be evaluated</p>
</td></tr>
<tr><td><code id="tryCatchLog_+3A_...">...</code></td>
<td>
<p>condition handler functions (as in <code><a href="base.html#topic+tryCatch">tryCatch</a></code>).
The following condition names are mainly used in R:
<code>error</code>, <code>warning</code>, <code>message</code> and <code>interrupt</code>.
A handler for user-defined conditions can be established for the
generic <code>condition</code> super class.
All condition handlers are passed to <code><a href="base.html#topic+tryCatch">tryCatch</a></code> as is
(no filtering, wrapping or changing of semantics).</p>
</td></tr>
<tr><td><code id="tryCatchLog_+3A_execution.context.msg">execution.context.msg</code></td>
<td>
<p>a text identifier (eg. the PID or a variable value) that will be added to msg.text
for catched conditions. This makes it easier to identify the runtime state that caused
a condition esp. in parallel execution scenarios.
The value must be of length 1 and will be coerced to character.
Expressions are not allowed.
The added output has the form: <code>{execution.context.msg: your_value}</code></p>
</td></tr>
<tr><td><code id="tryCatchLog_+3A_finally">finally</code></td>
<td>
<p>expression to be evaluated at the end (after executing the expressiond
and calling the matching handler).</p>
</td></tr>
<tr><td><code id="tryCatchLog_+3A_write.error.dump.file">write.error.dump.file</code></td>
<td>
<p><code>TRUE</code>: Saves a dump of the workspace and the call stack named
<code>dump_&lt;YYYYMMDD&gt;_at_&lt;HHMMSS.sss&gt;_PID_&lt;process id&gt;.rda</code>.
This dump file name pattern shall ensure unique file names in parallel processing scenarios.</p>
</td></tr>
<tr><td><code id="tryCatchLog_+3A_write.error.dump.folder">write.error.dump.folder</code></td>
<td>
<p><code>path</code>: Saves the dump of the workspace in a specific folder instead of the working directory</p>
</td></tr>
<tr><td><code id="tryCatchLog_+3A_silent.warnings">silent.warnings</code></td>
<td>
<p><code>TRUE</code>: Warnings are logged only, but not propagated to the caller.<br />
<code>FALSE</code>: Warnings are logged and treated according to the global
setting in <code><a href="base.html#topic+getOption">getOption</a>("warn")</code>. See also <code><a href="base.html#topic+warning">warning</a></code>.</p>
</td></tr>
<tr><td><code id="tryCatchLog_+3A_silent.messages">silent.messages</code></td>
<td>
<p><code>TRUE</code>: Messages are logged, but not propagated to the caller.<br />
<code>FALSE</code>: Messages are logged and propagated to the caller.</p>
</td></tr>
<tr><td><code id="tryCatchLog_+3A_include.full.call.stack">include.full.call.stack</code></td>
<td>
<p>Flag of type <code><a href="base.html#topic+logical">logical</a></code>:
Shall the full call stack be included in the log output? Since the full
call stack may be very long and the compact call stack has enough details
normally the full call stack can be omitted by passing <code>FALSE</code>.
The default value can be changed globally by setting the option <code>tryCatchLog.include.full.call.stack</code>.
The full call stack can always be found via <code><a href="#topic+last.tryCatchLog.result">last.tryCatchLog.result</a></code>.</p>
</td></tr>
<tr><td><code id="tryCatchLog_+3A_include.compact.call.stack">include.compact.call.stack</code></td>
<td>
<p>Flag of type <code><a href="base.html#topic+logical">logical</a></code>:
Shall the compact call stack (including only calls with source code references)
be included in the log output? Note: If you ommit both the full and compact
call stacks the message text will be output without call stacks.
The default value can be changed globally by setting the option <code>tryCatchLog.include.compact.call.stack</code>.
The compact call stack can always be found via <code><a href="#topic+last.tryCatchLog.result">last.tryCatchLog.result</a></code>.</p>
</td></tr>
<tr><td><code id="tryCatchLog_+3A_logged.conditions">logged.conditions</code></td>
<td>
<p><code>NULL</code>: Conditions are not logged.<br />
<code>vector of strings</code>: Only conditions whose class name is contained in this vector are logged.<br />
<code>NA</code>: All conditions are logged.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>finally</code> expression is then always evaluated at the end.
</p>
<p>Condition handlers work as in base R's <code><a href="base.html#topic+tryCatch">tryCatch</a></code>.
</p>
<p>Conditions are also logged including the function call stack
with file names and line numbers (if available).
</p>
<p>By default the maximum number of source code rows that are printed per call in the full stack trace
is 10. You can change this via the option <code>tryCatchLog.max.lines.per.call</code> (see example).
</p>
<p>This function shall overcome some drawbacks of the standard <code><a href="base.html#topic+tryCatch">tryCatch</a></code> function.<br />
For more details see <a href="https://github.com/aryoda/tryCatchLog">https://github.com/aryoda/tryCatchLog</a>.
</p>
<p>If the package <span class="pkg">futile.logger</span> is installed it will be used for writing logging output,
otherwise an internal basic logging output function is used.
</p>
<p>Before you call <code>tryCatchLog</code> for the first time you should initialize
the logging framework you are using (e. g.<span class="pkg">futile.logger</span> to control
the log output (log to console or file etc.):
</p>
<pre>  library(futile.logger)
  flog.appender(appender.file("my_app.log"))
  flog.threshold(INFO)    # TRACE, DEBUG, INFO, WARN, ERROR, FATAL</pre>
<p>If you are using the <span class="pkg">futile.logger</span> package <code>tryCatchLog</code> calls
these log functions for the different R conditions to log them:
</p>

<ol>
<li><p> error     -&gt; <code><a href="futile.logger.html#topic+flog.error">flog.error</a></code>
</p>
</li>
<li><p> warning   -&gt; <code><a href="futile.logger.html#topic+flog.warn">flog.warn</a></code>
</p>
</li>
<li><p> message   -&gt; <code><a href="futile.logger.html#topic+flog.info">flog.info</a></code>
</p>
</li>
<li><p> interrupt -&gt; <code><a href="futile.logger.html#topic+flog.info">flog.info</a></code>
</p>
</li></ol>

<p><strong>'tryCatchLog' does log all conditions (incl. user-defined conditions).</strong>
</p>
<p>Since the interrupt condition does not have an error message attribute <code>tryCatchLog</code>
uses &quot;User-requested interrupt&quot; as message in the logs.
</p>
<p>The log contains the call stack with the file names and line numbers (if available).
</p>
<p>R does track source code references of scripts only if you set the option <code>keep.source</code> to TRUE via
<code>options(keep.source = TRUE)</code>. Without this option this function cannot enrich source code references.
</p>
<p>If you use <code>Rscript</code> to start a non-interactive R script as batch job you
have to set this option since it is FALSE by default. You can add this option to your
<a href="base.html#topic+.Rprofile">.Rprofile</a> file or use a startup R script that sets this option and sources your
actual R script then.
</p>
<p>By default, most packages are built without source reference information.
Setting the environment variable <code>R_KEEP_PKG_SOURCE=yes</code> before installing a source package
will tell R to keep the source references. You can also use <code>options(keep.source.pkgs = TRUE)</code>
before you install a package.
</p>
<p>Setting the parameter <code>tryCatchLog.write.error.dump.file</code> to TRUE allows a post-mortem analysis of the program state
that led to the error. The dump contains the workspace and in the variable &quot;last.dump&quot;
the call stack (<code><a href="base.html#topic+sys.frames">sys.frames</a></code>). This feature is very helpful for non-interactive R scripts (&quot;batches&quot;).
</p>
<p>Setting the parameter <code>tryCatchLog.write.error.dump.folder</code> to a specific path allows to save the dump in a specific folder.
If not set, the dump will be saved in the working directory.
</p>
<p>To start a post-mortem analysis after an error open a new R session and enter:
<code>load("dump_20161016_164050.rda")   # replace the dump file name with your real file name
            debugger(last.dump)</code>
</p>
<p>Note that the dump does <b>not</b> contain the loaded packages when the dump file was created
and a dump loaded into memory does therefore <b>not</b> use exactly the same search path.
This means:
</p>

<ol>
<li><p>the program state is not exactly reproducible if objects are stored within a package namespace
</p>
</li>
<li><p>you cannot step through your source code in a reproducible way after loading the image
if your source code calls functions of non-default packages
</p>
</li></ol>



<h3>Value</h3>

<p>the value of the expression passed in as parameter &quot;expr&quot;
</p>


<h3>Best practices</h3>

<p>To <b>avoid that too many dump files filling your disk space</b> you should omit the <code>write.error.dump.file</code>
parameter and instead set its default value using the option <code>tryCatchLog.write.error.dump.file</code> in your
<a href="base.html#topic+.Rprofile">.Rprofile</a> file instead (or in a startup R script that sources your actual script).
In case of an error (that you can reproduce) you set the option to <code>TRUE</code> and re-run your script.
Then you are able to examine the program state that led to the error by debugging the saved dump file.
</p>
<p>To see the <b>source code references (source file names and line numbers)</b> in the stack traces you must
set this option before executing your code:<br />
<code>options(keep.source = TRUE)</code>
</p>
<p>You can <b>execute your code as batch with <code><a href="utils.html#topic+Rscript">Rscript</a></code> using this shell script command</b>:<br />
<code>Rscript -e "options(keep.source = TRUE); source('my_main_function.R')"</code>
</p>


<h3>References</h3>

<p><a href="http://adv-r.had.co.nz/beyond-exception-handling.html">http://adv-r.had.co.nz/beyond-exception-handling.html</a><br />
<a href="https://stackoverflow.com/questions/39964040/r-catch-errors-and-continue-execution-after-logging-the-stacktrace-no-tracebac">https://stackoverflow.com/questions/39964040/r-catch-errors-and-continue-execution-after-logging-the-stacktrace-no-tracebac</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tryLog">tryLog</a></code>, <code><a href="utils.html#topic+limitedLabels">limitedLabels</a></code>, <code><a href="#topic+get.pretty.call.stack">get.pretty.call.stack</a></code>,
<code><a href="#topic+last.tryCatchLog.result">last.tryCatchLog.result</a></code>, <code><a href="#topic+set.logging.functions">set.logging.functions</a></code>,
<code><a href="base.html#topic+tryCatch">tryCatch</a></code>, <code><a href="base.html#topic+withCallingHandlers">withCallingHandlers</a></code>, <code><a href="base.html#topic+signalCondition">signalCondition</a></code>,
<code><a href="base.html#topic+getOption">getOption</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tryCatchLog(log(-1))   # logs a warning (logarithm of a negative number is not possible)
tryLog(log(-1), execution.context.msg = Sys.getpid())

# set and unset an option
options("tryCatchLog.write.error.dump.folder" = "my_log")
options("tryCatchLog.write.error.dump.folder" = NULL)

options(tryCatchLog.max.lines.per.call = 30)

## Not run: 
# Use case for "execution.context.msg" argument: Loops and parallel execution
library(foreach)       # support parallel execution (requires an parallel execution plan)
options(tryCatchLog.include.full.call.stack = FALSE) # reduce the ouput for demo purposes
res &lt;- foreach(i = 1:12) %dopar% {
         tryCatchLog(log(10 - i), execution.context.msg = i)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='tryLog'>Try an expression with condition logging and error recovery</h2><span id='topic+tryLog'></span>

<h3>Description</h3>

<p><code>tryLog</code> is implemented by calling <code><a href="#topic+tryCatchLog">tryCatchLog</a></code>
and traps any errors that occur during the evaluation of an expression without stopping the execution
of the script (similar to <code><a href="base.html#topic+try">try</a></code>). Errors, warnings and messages are logged.
In contrast to <code><a href="#topic+tryCatchLog">tryCatchLog</a></code> it returns but does not stop in case of an error and therefore does
not have the <code>error</code> and <code>finally</code> parameters to pass in custom handler functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tryLog(
  expr,
  write.error.dump.file = getOption("tryCatchLog.write.error.dump.file", FALSE),
  write.error.dump.folder = getOption("tryCatchLog.write.error.dump.folder", "."),
  silent.warnings = getOption("tryCatchLog.silent.warnings", FALSE),
  silent.messages = getOption("tryCatchLog.silent.messages", FALSE),
  include.full.call.stack = getOption("tryCatchLog.include.full.call.stack", TRUE),
  include.compact.call.stack = getOption("tryCatchLog.include.compact.call.stack",
    TRUE),
  logged.conditions = getOption("tryCatchLog.logged.conditions", NULL),
  execution.context.msg = ""
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tryLog_+3A_expr">expr</code></td>
<td>
<p>R expression to be evaluated</p>
</td></tr>
<tr><td><code id="tryLog_+3A_write.error.dump.file">write.error.dump.file</code></td>
<td>
<p><code>TRUE</code>: Saves a dump of the workspace and the call stack named
<code>dump_&lt;YYYYMMDD&gt;_at_&lt;HHMMSS.sss&gt;_PID_&lt;process id&gt;.rda</code>.
This dump file name pattern shall ensure unique file names in parallel processing scenarios.</p>
</td></tr>
<tr><td><code id="tryLog_+3A_write.error.dump.folder">write.error.dump.folder</code></td>
<td>
<p><code>path</code>: Saves the dump of the workspace in a specific folder instead of the working directory</p>
</td></tr>
<tr><td><code id="tryLog_+3A_silent.warnings">silent.warnings</code></td>
<td>
<p><code>TRUE</code>: Warnings are logged only, but not propagated to the caller.<br />
<code>FALSE</code>: Warnings are logged and treated according to the global
setting in <code><a href="base.html#topic+getOption">getOption</a>("warn")</code>. See also <code><a href="base.html#topic+warning">warning</a></code>.</p>
</td></tr>
<tr><td><code id="tryLog_+3A_silent.messages">silent.messages</code></td>
<td>
<p><code>TRUE</code>: Messages are logged, but not propagated to the caller.<br />
<code>FALSE</code>: Messages are logged and propagated to the caller.</p>
</td></tr>
<tr><td><code id="tryLog_+3A_include.full.call.stack">include.full.call.stack</code></td>
<td>
<p>Flag of type <code><a href="base.html#topic+logical">logical</a></code>:
Shall the full call stack be included in the log output? Since the full
call stack may be very long and the compact call stack has enough details
normally the full call stack can be omitted by passing <code>FALSE</code>.
The default value can be changed globally by setting the option <code>tryCatchLog.include.full.call.stack</code>.
The full call stack can always be found via <code><a href="#topic+last.tryCatchLog.result">last.tryCatchLog.result</a></code>.</p>
</td></tr>
<tr><td><code id="tryLog_+3A_include.compact.call.stack">include.compact.call.stack</code></td>
<td>
<p>Flag of type <code><a href="base.html#topic+logical">logical</a></code>:
Shall the compact call stack (including only calls with source code references)
be included in the log output? Note: If you ommit both the full and compact
call stacks the message text will be output without call stacks.
The default value can be changed globally by setting the option <code>tryCatchLog.include.compact.call.stack</code>.
The compact call stack can always be found via <code><a href="#topic+last.tryCatchLog.result">last.tryCatchLog.result</a></code>.</p>
</td></tr>
<tr><td><code id="tryLog_+3A_logged.conditions">logged.conditions</code></td>
<td>
<p><code>NULL</code>: Conditions are not logged.<br />
<code>vector of strings</code>: Only conditions whose class name is contained in this vector are logged.<br />
<code>NA</code>: All conditions are logged.</p>
</td></tr>
<tr><td><code id="tryLog_+3A_execution.context.msg">execution.context.msg</code></td>
<td>
<p>a text identifier (eg. the PID or a variable value) that will be added to msg.text
for catched conditions. This makes it easier to identify the runtime state that caused
a condition esp. in parallel execution scenarios.
The value must be of length 1 and will be coerced to character.
Expressions are not allowed.
The added output has the form: <code>{execution.context.msg: your_value}</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tryLog</code> is implemented using <code><a href="#topic+tryCatchLog">tryCatchLog</a></code>. If you need need more flexibility for
catching and handling errors use the latter.
Error messages are never printed to the <code><a href="base.html#topic+stderr">stderr</a></code> connection but logged only.
</p>


<h3>Value</h3>

<p>The value of the expression (if <code>expr</code> is evaluated without an error.<br />
In case of an error: An invisible object of the class <code>"try-error"</code> containing the error message
and error condition as the <code>"condition"</code> attribute.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tryCatchLog">tryCatchLog</a></code>,
<code><a href="#topic+last.tryCatchLog.result">last.tryCatchLog.result</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tryLog(log(-1))   # logs a warning (logarithm of a negative number is not possible)
tryLog(log("a"))  # logs an error
tryCatchLog(log(-1), execution.context.msg = Sys.getpid())
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
