<!DOCTYPE html><html lang="en"><head><title>Help for package cape</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cape}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bin_curve'><p>Bins a single scan curve into peaks automatically</p></a></li>
<li><a href='#bin_vector'><p>Snap continuous values to a grid</p></a></li>
<li><a href='#calc_delta_errors'><p>Error propagation</p></a></li>
<li><a href='#calc_emp_p'><p>Calculate empirical p-values</p></a></li>
<li><a href='#calc_m'><p>Calculate m</p></a></li>
<li><a href='#calc_p'><p>Calculate P Values for Interactions Based on Permutations</p></a></li>
<li><a href='#Cape-class'><p>The CAPE data object</p></a></li>
<li><a href='#cape2mpp'><p>Converts a <code>read_population</code> object to a multi-parent object</p></a></li>
<li><a href='#center_std'><p>This function mean centers and standardizes a vector</p></a></li>
<li><a href='#check_bad_markers'><p>Checks for unused markers</p></a></li>
<li><a href='#check_communities'><p>Check community assignments</p></a></li>
<li><a href='#check_geno'><p>Check to see if the any markers in the supplied</p>
genotype matrix is one of the covariates.</a></li>
<li><a href='#check_underscore'><p>Checks for underscores in marker names</p></a></li>
<li><a href='#chunkV'><p>Bins a vector into chunks</p></a></li>
<li><a href='#colors_from_values'><p>Retrieve colors based on numeric values</p></a></li>
<li><a href='#compare_markers'><p>Removes markers from data_obj that are not present in the geno_obj</p></a></li>
<li><a href='#consec_pairs'><p>Generate a matrix of consecutive elements</p></a></li>
<li><a href='#delete_underscore'><p>Delete underscores from marker names</p></a></li>
<li><a href='#direct_influence'><p>Calculate the significance of direct influences of variant pairs on phenotypes</p></a></li>
<li><a href='#draw_pie'><p>Draw a pie chart</p></a></li>
<li><a href='#error_prop'><p>Estimate Errors of Regression Coefficients</p></a></li>
<li><a href='#exp_color_fun'><p>Exponential color function</p></a></li>
<li><a href='#flatten_array'><p>Drop the 3rd dimension of an array using a summary</p>
function, e.g., min max, mean</a></li>
<li><a href='#genome_wide_threshold_1D'><p>Calculate a genome-wide significance threshold for the single-variant scan</p></a></li>
<li><a href='#get_allele_colors'><p>Get DO colors</p></a></li>
<li><a href='#get_block_allele'><p>Get allele assignments for linkage blocks</p></a></li>
<li><a href='#get_circle'><p>Generate coordinates for a circle</p></a></li>
<li><a href='#get_col_num'><p>Find column numbers using column names</p></a></li>
<li><a href='#get_color'><p>get a hex color string</p></a></li>
<li><a href='#get_color2'><p>Generate color ramp</p></a></li>
<li><a href='#get_concent_circ'><p>Generate list of concentric circles</p></a></li>
<li><a href='#get_covar'><p>Get covariate information</p></a></li>
<li><a href='#get_eigentraits'><p>Calculate eigentraits</p></a></li>
<li><a href='#get_geno'><p>Gets the geno object</p></a></li>
<li><a href='#get_geno_dim'><p>Returns which dimensions the individual, locus, and</p>
alleles are in in the genotype object.</a></li>
<li><a href='#get_geno_with_covar'><p>Return the genotype matrix with covariates</p>
added.</a></li>
<li><a href='#get_interaction_error'><p>Get error bars for interaction plot</p></a></li>
<li><a href='#get_layout_mat'><p>Get the best layout matrix for a given number of panes per page.</p></a></li>
<li><a href='#get_line'><p>Get line coordinates</p></a></li>
<li><a href='#get_linearly_independent'><p>Check selected markers for linear independence.</p></a></li>
<li><a href='#get_marker_chr'><p>Get chromosome numbers for markers</p></a></li>
<li><a href='#get_marker_covar'><p>Get genotype or covariate values</p></a></li>
<li><a href='#get_marker_idx'><p>Get original indices for markers</p></a></li>
<li><a href='#get_marker_location'><p>Get marker genomic position</p></a></li>
<li><a href='#get_marker_name'><p>Get marker names</p></a></li>
<li><a href='#get_marker_num'><p>Get numbers for markers</p></a></li>
<li><a href='#get_network'><p>Convert the final results to an adjacency</p>
matrix.</a></li>
<li><a href='#get_pairs_for_pairscan'><p>Select marker pairs for pairscan</p></a></li>
<li><a href='#get_pheno'><p>Get the phenotype matrix</p></a></li>
<li><a href='#get_stats_multiallele'><p>Perform linear regression on multi-allele markers.</p></a></li>
<li><a href='#hist_pheno'><p>Plot trait histograms</p></a></li>
<li><a href='#image_with_text'><p>Plot a heatmap</p></a></li>
<li><a href='#impute_missing_geno'><p>Impute missing genotype data using k nearest neighbors</p></a></li>
<li><a href='#kin_adjust'><p>Corrects genotypes, phenotypes, and covariates</p>
for kinship.</a></li>
<li><a href='#kinship'><p>Calculate the kinship matrix</p></a></li>
<li><a href='#linkage_blocks_network'><p>Identify linkage blocks</p></a></li>
<li><a href='#load_input_and_run_cape'><p>Loads input and run CAPE</p></a></li>
<li><a href='#marker2covar'><p>Creates a covariate from a genetic marker</p></a></li>
<li><a href='#my_image_plot'><p>Generate a Heatmap-type image</p></a></li>
<li><a href='#norm_pheno'><p>Mean-center and normalize phenotypes</p></a></li>
<li><a href='#one_pairscan_parallel'><p>This is an internal function to run a single pairscan</p>
It is used both to do the actual pairscan
(<code>pairscan_kin</code> and <code>pairscan_noKin</code>),
as well as to do the permutations of the pairscan
<code>pairscan_null</code>).</a></li>
<li><a href='#one_singlescanDO'><p>Performs marker regression</p></a></li>
<li><a href='#pair_matrix'><p>Get all pairs of elements in a vector</p></a></li>
<li><a href='#pairscan'><p>This function performs the pairwise scan on all markers.</p></a></li>
<li><a href='#pairscan_kin'><p>Run the pairscan with a kinship correction</p></a></li>
<li><a href='#pairscan_noKin'><p>Perform pairscan without a kinship correction</p></a></li>
<li><a href='#pairscan_null'><p>Generate a null distribution for the pairscan.</p></a></li>
<li><a href='#pairscan_null_kin'><p>Generates a null distribution for the pairscan</p></a></li>
<li><a href='#pheatmap_generate_breaks'><p>pheatmap generate breaks found at this link</p>
https://cran.r-project.org/package=pheatmap</a></li>
<li><a href='#pheatmap_scale_colours'><p>pheatmap scale colours found at this link</p>
https://cran.r-project.org/package=pheatmap</a></li>
<li><a href='#pheno2covar'><p>Create a covariate from a trait</p></a></li>
<li><a href='#plink2cape'><p>Convert plink2 files to cape format</p></a></li>
<li><a href='#plot_bars'><p>Plot phenotypic effect for two markers as a bar plot</p></a></li>
<li><a href='#plot_effects'><p>Plot Interaction Effects</p></a></li>
<li><a href='#plot_full_network'><p>Plot the final epistatic network in a traditional network view.</p></a></li>
<li><a href='#plot_int_heat'><p>Plot phenotypic effects for two markers as a heat map</p></a></li>
<li><a href='#plot_lines'><p>Plot interaction plot for traits and genetic markers</p></a></li>
<li><a href='#plot_network'><p>Plots cape results as a circular network</p></a></li>
<li><a href='#plot_pairscan'><p>Plot the result of the pairwise scan</p></a></li>
<li><a href='#plot_pheno_cor'><p>Plot trait pairs against each other</p></a></li>
<li><a href='#plot_points'><p>Plot phenotypic effect for two markers as points</p></a></li>
<li><a href='#plot_singlescan'><p>Plot results of single-locus scans</p></a></li>
<li><a href='#plot_svd'><p>Plots eigentraits</p></a></li>
<li><a href='#plot_trait_circ'><p>Plot concentric trait circles</p></a></li>
<li><a href='#plot_variant_influences'><p>Plot cape coefficients</p></a></li>
<li><a href='#qnorm_pheno'><p>Plot trait distributions</p></a></li>
<li><a href='#qtl2_to_cape'><p>Convert qtl2 object to cape format</p></a></li>
<li><a href='#read_parameters'><p>Read the parameter file, add missing entries</p></a></li>
<li><a href='#read_population'><p>Reads in data in the R/qtl csv format</p></a></li>
<li><a href='#remove_ind'><p>Remove individuals</p></a></li>
<li><a href='#remove_kin_ind'><p>Removes individuals from the kinship object to match the cape.obj</p></a></li>
<li><a href='#remove_markers'><p>Removes genetic markers</p></a></li>
<li><a href='#remove_missing_genotype_data'><p>Removes individuals and/or markers with missing data</p></a></li>
<li><a href='#remove_unused_markers'><p>Take out markers not used in cape</p></a></li>
<li><a href='#report_progress'><p>Report Progress of a Process</p></a></li>
<li><a href='#rotate_mat'><p>Orients a matrix for proper display in a plot</p></a></li>
<li><a href='#run_cape'><p>Runs CAPE</p></a></li>
<li><a href='#rz_transform'><p>Rank Z normalize</p></a></li>
<li><a href='#segment_region'><p>Divide a region into equal parts.</p></a></li>
<li><a href='#select_eigentraits'><p>Assign selected eigentraits in the Cape object</p></a></li>
<li><a href='#select_markers_for_pairscan'><p>Select markers for the pairwise scan.</p></a></li>
<li><a href='#select_pheno'><p>This function selects the phenotypes in a Cape object</p></a></li>
<li><a href='#singlescan'><p>Runs marker regression on each individual genetic marker</p></a></li>
<li><a href='#sort_by_then_by'><p>Sort a table by a list of columns</p></a></li>
<li><a href='#write_population'><p>Save the cross data in R/qtl CSV format</p></a></li>
<li><a href='#write_variant_influences'><p>Write significant cape interactions to a csv file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Combined Analysis of Pleiotropy and Epistasis for Diversity
Outbred Mice</td>
</tr>
<tr>
<td>Version:</td>
<td>3.1.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Combined Analysis of Pleiotropy and Epistasis infers predictive 
    networks between genetic variants and phenotypes. It can be used with 
    standard two-parent populations as well as multi-parent populations, such 
    as the Diversity Outbred (DO) mice, Collaborative Cross (CC) mice, or the 
    multi-parent advanced generation intercross (MAGIC) population of Arabidopsis
    thaliana. It uses complementary information of pleiotropic gene variants across
    different phenotypes to resolve models of epistatic interactions between alleles. 
    To do this, cape reparametrizes main effect and interaction coefficients from
    pairwise variant regressions into directed influence parameters. These
    parameters describe how alleles influence each other, in terms of suppression 
    and enhancement, as well as how gene variants influence phenotypes. All of the 
    final interactions are reported as directed interactions between pairs of 
    parental alleles. For detailed descriptions of the methods used in this package 
    please see the following references.
    Carter, G. W., Hays, M., Sherman, A. &amp; Galitski, T. (2012) &lt;<a href="https://doi.org/10.1371%2Fjournal.pgen.1003010">doi:10.1371/journal.pgen.1003010</a>&gt;.
    Tyler, A. L., Lu, W., Hendrick, J. J., Philip, V. M. &amp; Carter, G. W. (2013) &lt;<a href="https://doi.org/10.1371%2Fjournal.pcbi.1003270">doi:10.1371/journal.pcbi.1003270</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.3.2), knitr (&ge; 1.29), rmarkdown, parallel</td>
</tr>
<tr>
<td>Imports:</td>
<td>abind, caTools, corpcor, doParallel, evd, foreach, here,
igraph, Matrix, pheatmap, pracma, propagate, qtl, qtl2,
qtl2convert, R6 (&ge; 2.4.1), RColorBrewer (&ge; 1.1-2), regress
(&ge; 1.3-21), shape (&ge; 1.4.5), stats, tools, utils, yaml (&ge;
2.2.1)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-08 15:16:03 UTC; atyler</td>
</tr>
<tr>
<td>Author:</td>
<td>Anna Tyler [aut, cre],
  Jake Emerson [aut],
  Baha El Kassaby [aut],
  Ann Wells [aut],
  Georgi Kolishovski [aut],
  Vivek Philip [aut],
  Gregory Carter [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Anna Tyler &lt;anna.tyler@jax.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-09 11:00:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='bin_curve'>Bins a single scan curve into peaks automatically</h2><span id='topic+bin_curve'></span>

<h3>Description</h3>

<p>This is an internal function used to select markers
for the pair scan based on single scan results. The 
algorithm first finds the difference between all 
runs of all positive and all negative values.
It smooths the curve and identifies peaks exceeding
the threshold defined by amp_min.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bin_curve(the_curve, plot_peaks = FALSE, window_size = NULL, amp_min = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bin_curve_+3A_the_curve">the_curve</code></td>
<td>
<p>vector representing the curve to be binned into peaks</p>
</td></tr>
<tr><td><code id="bin_curve_+3A_plot_peaks">plot_peaks</code></td>
<td>
<p>default = FALSE</p>
</td></tr>
<tr><td><code id="bin_curve_+3A_window_size">window_size</code></td>
<td>
<p>A numeric value setting how many markers 
should be included in each window. If NULL, the window size is
set to the maximum number of consecutive rises or falls in the 
curve</p>
</td></tr>
<tr><td><code id="bin_curve_+3A_amp_min">amp_min</code></td>
<td>
<p>A numeric value indicating the minimum magnitude
of a peak. All peaks below this magnitude will be removed. If 
NULL amp_min is set to the sd of the curve/2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list with the following elements:
bins: a vector the same length as the input curve identifying which
peak each position was assigned to. 
smoothed_curve: A vector defining the smoothed curve
window_size: The input window_size or the calculated window_size if 
window_size was NULL
amp_min: the input amp_min or calculated amp_min if amp_min was NULL
</p>

<hr>
<h2 id='bin_vector'>Snap continuous values to a grid</h2><span id='topic+bin_vector'></span>

<h3>Description</h3>

<p>This function bins a continuously valued vector
based on user-defined bins.
It is useful for binning continuously valued genotypes.
Each value in the matrix gets shifted to the nearest
provided in the argument bins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bin_vector(vectorX, bins = seq(0, 1, 0.5))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bin_vector_+3A_vectorx">vectorX</code></td>
<td>
<p>A vector of numeric values to bin</p>
</td></tr>
<tr><td><code id="bin_vector_+3A_bins">bins</code></td>
<td>
<p>A vector of values to snap the values in vectorX to.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector the same length as vectorX in which 
each value in vectorX has been sent to the nearest value
in bins. For example, if bins is c(0, 0.5, 1), and vectorX
contains a 0.49. That 0.49 value will be sent to 0.5.
The returned vector contains only the values specified in bins.
</p>

<hr>
<h2 id='calc_delta_errors'>Error propagation</h2><span id='topic+calc_delta_errors'></span>

<h3>Description</h3>

<p>This function performs error propagation on 
coefficients and standard errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_delta_errors(markers, beta_m, se, beta_cov)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_delta_errors_+3A_markers">markers</code></td>
<td>
<p>The marker names being tested</p>
</td></tr>
<tr><td><code id="calc_delta_errors_+3A_beta_m">beta_m</code></td>
<td>
<p>The main-effects coefficient matrix for 
the pairwise regression of the given pair.</p>
</td></tr>
<tr><td><code id="calc_delta_errors_+3A_se">se</code></td>
<td>
<p>The standard errors for the marker pair.</p>
</td></tr>
<tr><td><code id="calc_delta_errors_+3A_beta_cov">beta_cov</code></td>
<td>
<p>The model covariance matrix from the 
pairwise regression</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the error propagated coefficients and 
standard errors for m12 and m21
</p>

<hr>
<h2 id='calc_emp_p'>Calculate empirical p-values</h2><span id='topic+calc_emp_p'></span>

<h3>Description</h3>

<p>This function uses ecdf to calculate empirical p values
given a null distribution and an observed distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_emp_p(obs_dist, null_dist)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_emp_p_+3A_obs_dist">obs_dist</code></td>
<td>
<p>The observed distribution</p>
</td></tr>
<tr><td><code id="calc_emp_p_+3A_null_dist">null_dist</code></td>
<td>
<p>The null distribution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An empirical p value for each observed value
</p>

<hr>
<h2 id='calc_m'>Calculate m</h2><span id='topic+calc_m'></span>

<h3>Description</h3>

<p>This function performs the reparameterization
step originally described in
Carter, G. W., Hays, M., Sherman, A. &amp; Galitski, T. 
Use of pleiotropy to model genetic interactions in a 
population. PLoS Genet. 8, e1003010 (2012).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_m(markers, beta_m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_m_+3A_markers">markers</code></td>
<td>
<p>A vector of length two holding the
names of the markers being tested.</p>
</td></tr>
<tr><td><code id="calc_m_+3A_beta_m">beta_m</code></td>
<td>
<p>The matrix of beta values from the 
pairwise linear regression testing the interaction
between the markers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a matrix with one 
row holding the m12 and m21 values as described 
in Carter et al. 2012
</p>

<hr>
<h2 id='calc_p'>Calculate P Values for Interactions Based on Permutations</h2><span id='topic+calc_p'></span>

<h3>Description</h3>

<p>Calculate P Values for Interactions Based on Permutations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_p(
  data_obj,
  pval_correction = c("holm", "hochberg", "hommel", "bonferroni", "BH", "BY", "fdr",
    "none")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_p_+3A_data_obj">data_obj</code></td>
<td>
<p>A <code><a href="#topic+Cape">Cape</a></code> data object</p>
</td></tr>
<tr><td><code id="calc_p_+3A_pval_correction">pval_correction</code></td>
<td>
<p>One of &quot;holm&quot;, &quot;fdr&quot;, &quot;lfdr&quot; or &quot;none&quot;, indicating 
whether the p value correction method used should be the Holm step-down procedure, 
false discovery rate, local false discovery, or no correction rate respectively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The data object is returned with a new table called var_to_var_p_val.
This table is the same as var_to_var_influences, but with p value and adjusted
p value columns appended.
</p>

<hr>
<h2 id='Cape-class'>The CAPE data object</h2><span id='topic+Cape-class'></span><span id='topic+Cape'></span>

<h3>Description</h3>

<p>The CAPE data object
</p>
<p>The CAPE data object
</p>


<h3>Details</h3>

<p>Class <code>Cape</code> defines a CAPE analysis object.
</p>


<h3>Slots</h3>


<dl>
<dt><code>parameter_file</code></dt><dd><p>string, full path to YAML file with initialization
parameters</p>
</dd>
<dt><code>yaml_parameters</code></dt><dd><p>string representing YAML CAPE parameters. See the
vignette for more descriptions of individual parameter settings.</p>
</dd>
<dt><code>results_path</code></dt><dd><p>string, full path to directory for storing results
(optional, a directory will be created if one is not specified)</p>
</dd>
<dt><code>save_results</code></dt><dd><p>Whether to save cape results. Defaults to FALSE.</p>
</dd>
<dt><code>use_saved_results</code></dt><dd><p>Whether to use existing results from a 
previous run. This can save time if re-running an analysis, but
can lead to problems if the old run and new run have competing settings.
If errors arise, and use_saved_results is set to TRUE, try setting it 
to FALSE, or deleting previous results.</p>
</dd>
<dt><code>pheno</code></dt><dd><p>A matrix containing the traits to be analyzed. Traits are in
columns and individuals are in rows.</p>
</dd>
<dt><code>chromosome</code></dt><dd><p>A vector the same length as the number of markers indicating
which chromosome each marker lives on.</p>
</dd>
<dt><code>marker_num</code></dt><dd><p>A vector the same length as the number of markers indicating
the index of each marker</p>
</dd>
<dt><code>marker_location</code></dt><dd><p>A vector the same length as the number of markers indicating
the genomic position of each marker. The positions are primarily used for plotting
and can be in base pairs, centiMorgans, or dummy variables.</p>
</dd>
<dt><code>marker_selection_method</code></dt><dd><p>A string indicating how markers should be 
selected for the pairscan. Options are &quot;top_effects&quot; or &quot;from_list.&quot;
If &quot;top_effects,&quot; markers are selected using main effect sizes. 
If &quot;from_list&quot; markers are specified using a vector of marker names. 
See <code><a href="#topic+select_markers_for_pairscan">select_markers_for_pairscan</a></code>.</p>
</dd>
<dt><code>geno_names</code></dt><dd><p>The dimnames of the genotype array. The genotype array is a three-dimensional
array in which rows are individuals, columns are alleles, and the third dimension houses
the markers. Genotypes are pulled for analysis using <code><a href="#topic+get_geno">get_geno</a></code> based on
geno_names. Only the individuals, alleles, and markers listed in geno_names are
taken from the genotype matrix. Functions that remove markers and individuals from
analysis always operate on geno_names in addition to other relevant slots.
The names of geno_names must be &quot;mouse&quot;, &quot;allele&quot;, &quot;locus.&quot;</p>
</dd>
<dt><code>geno</code></dt><dd><p>A three dimensional array holding genotypes for each animal for each allele
at each marker. The genotypes are continuously valued probabilities ranging from 0 to 1. 
The dimnames of geno must be &quot;mouse&quot;, &quot;allele&quot;, and &quot;locus,&quot; even if the individuals are
not mice.</p>
</dd>
<dt><code>geno_for_pairscan</code></dt><dd><p>A two-dimensional matrix holding the genotypes that will be analyzed
in the pairscan. Alleles are in columns and individuals are in rows. As in the geno array, 
values are continuous probabilities ranging from 0 to 1.</p>
</dd>
<dt><code>peak_density</code></dt><dd><p>The density parameter for <code><a href="#topic+select_markers_for_pairscan">select_markers_for_pairscan</a></code>.
Determines how densely markers under an individual effect size peak are selected 
for the pairscan if marker_selection_method is TRUE. Defaults to 0.5.</p>
</dd>
<dt><code>window_size</code></dt><dd><p>The window size used by <code><a href="#topic+select_markers_for_pairscan">select_markers_for_pairscan</a></code>.
It specifies how many markers are used to smooth effect size curves for automatic peak
identification. If set to NULL, window_size is determined automatically. Used when 
marker_selection_method is TRUE.</p>
</dd>
<dt><code>tolerance</code></dt><dd><p>The wiggle room afforded to <code><a href="#topic+select_markers_for_pairscan">select_markers_for_pairscan</a></code> in 
finding a target number of markers. If num_alleles_in_pairscan is 100 and the tolerance 
is 5, the algorithm will stop when it identifies anywhere between 95 and 105 markers 
for the pairscan.</p>
</dd>
<dt><code>ref_allele</code></dt><dd><p>A string of length 1 indicating which allele to use as the reference allele.
In two-parent crosses, this is usually allele A. In DO/CC populations, we recommend using
B as the reference allele. B is the allele from the C57Bl6/J mouse, which is often used as
a reference strain.</p>
</dd>
<dt><code>alpha</code></dt><dd><p>The significance level for calculating effect size thresholds in the 
<code><a href="#topic+singlescan">singlescan</a></code>. If singlescan_perm is 0, this parameter is ignored.</p>
</dd>
<dt><code>covar_table</code></dt><dd><p>A matrix of covariates with covariates in columns and individuals
in rows. Must be numeric.</p>
</dd>
<dt><code>num_alleles_in_pairscan</code></dt><dd><p>The number of alleles to test in the pairwise scan. 
Because Cape is computationally intensive, we usually need to test only a subset
of available markers in the pairscan, particularly if the kinship correction is
being used.</p>
</dd>
<dt><code>max_pair_cor</code></dt><dd><p>the maximum Pearson correlation between two markers. If their
correlation exceeds this value, they will not be tested against each other in the
pairscan. This threshold is set to prevent false positive arising from testing
highly correlated markers. If this value is set to NULL, min_per_genotype must
be specified.</p>
</dd>
<dt><code>min_per_genotype</code></dt><dd><p>minimum The minimum number of individuals allowable per
genotype combination in the pair scan. If for a given marker pair, one of the 
genotype combinations is underrepresented, the marker pair is not tested. If 
this value is NULL, max_pair_cor must be specified.</p>
</dd>
<dt><code>pairscan_null_size</code></dt><dd><p>The total size of the null distribution.
This is DIFFERENT than the number of permutations to run. Each permutation
generates n choose 2 elements for the pairscan. So for example, a permutation
that tests 100 pairs of markers will generate a null distribution of size 4950.
This process is repeated until the total null size is reached. If the null size
is set to 5000, two permutations of 100 markers would be done to get to a null
distribution size of 5000.</p>
</dd>
<dt><code>p_covar</code></dt><dd><p>A vector of strings specifying the names of covariates derived
from traits. See <code><a href="#topic+pheno2covar">pheno2covar</a></code>.</p>
</dd>
<dt><code>g_covar</code></dt><dd><p>A vector of strings specifying the names of covariates derived 
from genetic markers. See <code><a href="#topic+marker2covar">marker2covar</a></code>.</p>
</dd>
<dt><code>p_covar_table</code></dt><dd><p>A matrix holding the individual values for each
trait-derived covariate. 
See <code><a href="#topic+pheno2covar">pheno2covar</a></code>.</p>
</dd>
<dt><code>g_covar_table</code></dt><dd><p>A matrix holding the individual values for each 
marker-derived covariate. See <code><a href="#topic+marker2covar">marker2covar</a></code>.</p>
</dd>
<dt><code>model_family</code></dt><dd><p>Indicates the model family of the phenotypes
This can be either &quot;gaussian&quot; or &quot;binomial&quot;. If this argument
is length 1, all phenotypes will be assigned to the same
family. Phenotypes can be assigned different model families by
providing a vector of the same length as the number of phenotypes,
indicating how each phenotype should be modeled. See <code><a href="#topic+singlescan">singlescan</a></code>.</p>
</dd>
<dt><code>scan_what</code></dt><dd><p>A string indicating whether &quot;eigentraits&quot;, &quot;normalized_traits&quot;, or 
&quot;raw_traits&quot; should be analyzed. See <code><a href="#topic+get_pheno">get_pheno</a></code>.</p>
</dd>
<dt><code>ET</code></dt><dd><p>A matrix holding the eigentraits to be analyzed.</p>
</dd>
<dt><code>singular_values</code></dt><dd><p>Added by <code><a href="#topic+get_eigentraits">get_eigentraits</a></code>. A vector holding 
the singular values from the singular
value decomposition of the trait matrix. They are used in rotating the 
final direct influences back to trait space from eigentrait space. See
<code><a href="#topic+get_eigentraits">get_eigentraits</a></code> and <code><a href="#topic+direct_influence">direct_influence</a></code>.</p>
</dd>
<dt><code>right_singular_vectors</code></dt><dd><p>Added by <code><a href="#topic+get_eigentraits">get_eigentraits</a></code>. A matrix 
containing the right singular vectors from the singular
value decomposition of the trait matrix. They are used in rotating the 
final direct influences back to trait space from eigentrait space. See
<code><a href="#topic+get_eigentraits">get_eigentraits</a></code> and <code><a href="#topic+direct_influence">direct_influence</a></code>.</p>
</dd>
<dt><code>traits_scaled</code></dt><dd><p>Whether the traits should be mean-centered and standardized
before analyzing.</p>
</dd>
<dt><code>traits_normalized</code></dt><dd><p>Whether the traits should be rank Z normalized before
analyzing.</p>
</dd>
<dt><code>var_to_var_influences_perm</code></dt><dd><p>added in <code><a href="#topic+error_prop">error_prop</a></code> 
The list of results from the error propagation of permuted coefficients.</p>
</dd>
<dt><code>var_to_var_influences</code></dt><dd><p>added in <code><a href="#topic+error_prop">error_prop</a></code> 
The list of results from the error propagation of coefficients.</p>
</dd>
<dt><code>pval_correction</code></dt><dd><p>Options are &quot;holm&quot;, &quot;hochberg&quot;, &quot;hommel&quot;, &quot;bonferroni&quot;, &quot;BH&quot;, &quot;BY&quot;,&quot;fdr&quot;, &quot;none&quot;</p>
</dd>
<dt><code>linkage_blocks_collapsed</code></dt><dd><p>A list containing assignments of markers to linkage blocks 
calculated by <code><a href="#topic+linkage_blocks_network">linkage_blocks_network</a></code> and <code><a href="#topic+plot_network">plot_network</a></code>.
In this list there can be multiple markers assigned to a single linkage block.</p>
</dd>
<dt><code>linkage_blocks_full</code></dt><dd><p>A list containing assignments of markers to linkage blocks 
when no linkage blocks are calculated. In this list there can only be one marker
per &quot;linkage block&quot;. See <code><a href="#topic+linkage_blocks_network">linkage_blocks_network</a></code> and <code><a href="#topic+plot_network">plot_network</a></code>.</p>
</dd>
<dt><code>var_to_var_p_val</code></dt><dd><p>The final table of cape interaction results calculated by <code><a href="#topic+error_prop">error_prop</a></code>.</p>
</dd>
<dt><code>max_var_to_pheno_influence</code></dt><dd><p>The final table of cape direct influences of markers to traits
calculated by <code><a href="#topic+direct_influence">direct_influence</a></code>.</p>
</dd>
<dt><code>collapsed_net</code></dt><dd><p>An adjacency matrix holding significant cape interactions between
linkage blocks. See <code><a href="#topic+plot_network">plot_network</a></code> and <code><a href="#topic+get_network">get_network</a></code>.</p>
</dd>
<dt><code>full_net</code></dt><dd><p>An adjacency matrix holding significant cape interactions between
individual markers. See <code><a href="#topic+plot_network">plot_network</a></code> and <code><a href="#topic+get_network">get_network</a></code>.</p>
</dd>
<dt><code>use_kinship</code></dt><dd><p>Whether to use a kinship correction in the analysis.</p>
</dd>
<dt><code>kinship_type</code></dt><dd><p>Which type of kinship matrix to use. Either &quot;overall&quot; 
for the overall kinship matrix or &quot;ltco&quot; for leave-two-chromosomes-out.</p>
</dd>
<dt><code>transform_to_phenospace</code></dt><dd><p>whether to transform to phenospace or not.</p>
</dd>
</dl>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>parameter_file</code></dt><dd><p>full path to YAML file with initialization parameters.</p>
</dd>
<dt><code>yaml_parameters</code></dt><dd><p>string representing YAML CAPE parameters. See the vignette for more descriptions 
of individual parameter settings.</p>
</dd>
<dt><code>results_path</code></dt><dd><p>string, full path to directory for storing results (optional, a directory will be 
created if one is not specified).</p>
</dd>
<dt><code>save_results</code></dt><dd><p>Whether to save cape results. Defaults to FALSE.</p>
</dd>
<dt><code>use_saved_results</code></dt><dd><p>Whether to use existing results from a previous run. This can save time if 
re-running an analysis, but can lead to problems if the old run and new run have competing settings.
If errors arise, and use_saved_results is set to TRUE, try setting it to FALSE, or deleting previous results.</p>
</dd>
<dt><code>pheno</code></dt><dd><p>A matrix containing the traits to be analyzed. Traits are in columns and individuals are in rows.</p>
</dd>
<dt><code>chromosome</code></dt><dd><p>A vector the same length as the number of markers indicating which chromosome each marker lives on.</p>
</dd>
<dt><code>marker_num</code></dt><dd><p>A vector the same length as the number of markers indicating the index of each marker.</p>
</dd>
<dt><code>marker_location</code></dt><dd><p>A vector the same length as the number of markers indicating the genomic position of each marker.
The positions are primarily used for plotting and can be in base pairs, centiMorgans, or dummy variables.</p>
</dd>
<dt><code>geno_names</code></dt><dd><p>The dimnames of the genotype array. The genotype array is a three-dimensional array in which rows 
are individuals, columns are alleles, and the third dimension houses the markers. Genotypes are pulled for analysis 
using <code><a href="#topic+get_geno">get_geno</a></code> based on geno_names. Only the individuals, alleles, and markers listed in geno_names are
taken from the genotype matrix. Functions that remove markers and individuals from analysis always operate on geno_names 
in addition to other relevant slots. The names of geno_names must be &quot;mouse&quot;, &quot;allele&quot;, &quot;locus.&quot;</p>
</dd>
<dt><code>geno</code></dt><dd><p>A three dimensional array holding genotypes for each animal for each allele at each marker. The genotypes
are continuously valued probabilities ranging from 0 to 1. The dimnames of geno must be &quot;mouse&quot;, &quot;allele&quot;, and &quot;locus,&quot;
even if the individuals are not mice.</p>
</dd>
<dt><code>peak_density</code></dt><dd><p>The density parameter for 
<code><a href="#topic+select_markers_for_pairscan">select_markers_for_pairscan</a></code>.  Determines how densely
markers under an individual effect size peak are selected for the 
pairscan if marker_selection_method is TRUE.
Defaults to 0.5.</p>
</dd>
<dt><code>window_size</code></dt><dd><p>The window size used by 
<code><a href="#topic+select_markers_for_pairscan">select_markers_for_pairscan</a></code>. It specifies how many markers
are used to smooth effect size curves for automatic peak identification. If set to NULL, window_size is determined
automatically. Used when marker_selection_method is TRUE.</p>
</dd>
<dt><code>tolerance</code></dt><dd><p>The wiggle room afforded to <code><a href="#topic+select_markers_for_pairscan">select_markers_for_pairscan</a></code> in finding a target number
of markers. If num_alleles_in_pairscan is 100 and the tolerance is 5, the algorithm will stop when it identifies
anywhere between 95 and 105 markers for the pairscan.</p>
</dd>
<dt><code>ref_allele</code></dt><dd><p>A string of length 1 indicating which allele to use as the reference allele. In two-parent crosses,
this is usually allele A. In DO/CC populations, we recommend using B as the reference allele. B is the allele from
the C57Bl6/J mouse, which is often used as a reference strain.</p>
</dd>
<dt><code>alpha</code></dt><dd><p>The significance level for calculating effect size thresholds in the <code><a href="#topic+singlescan">singlescan</a></code>.
If singlescan_perm is 0, this parameter is ignored.</p>
</dd>
<dt><code>covar_table</code></dt><dd><p>A matrix of covariates with covariates in columns and individuals in rows. Must be numeric.</p>
</dd>
<dt><code>num_alleles_in_pairscan</code></dt><dd><p>The number of alleles to test in the pairwise scan. Because Cape is computationally
intensive, we usually need to test only a subset of available markers in the pairscan, particularly if the kinship
correction is being used.</p>
</dd>
<dt><code>max_pair_cor</code></dt><dd><p>The maximum Pearson correlation between two markers. If their correlation exceeds this value,
they will not be tested against each other in the pairscan. This threshold is set to prevent false positive arising
from testing highly correlated markers. If this value is set to NULL, min_per_genotype must be specified.</p>
</dd>
<dt><code>min_per_genotype</code></dt><dd><p>minimum The minimum number of individuals allowable per genotype combination in the pair scan.
If for a given marker pair, one of the genotype combinations is underrepresented, the marker pair is not tested.
If this value is NULL, max_pair_cor must be specified.</p>
</dd>
<dt><code>pairscan_null_size</code></dt><dd><p>The total size of the null distribution. This is DIFFERENT than the number of permutations
to run. Each permutation generates n choose 2 elements for the pairscan. So for example, a permutation that tests 100
pairs of markers will generate a null distribution of size 4950. This process is repeated until the total null size
is reached. If the null size is set to 5000, two permutations of 100 markers would be done to get to a null
distribution size of 5000.</p>
</dd>
<dt><code>p_covar</code></dt><dd><p>A vector of strings specifying the names of covariates derived from traits. See <code><a href="#topic+pheno2covar">pheno2covar</a></code>.</p>
</dd>
<dt><code>g_covar</code></dt><dd><p>A vector of strings specifying the names of covariates derived from genetic markers.
See <code><a href="#topic+marker2covar">marker2covar</a></code>.</p>
</dd>
<dt><code>p_covar_table</code></dt><dd><p>A matrix holding the individual values for each trait-derived covariate. See <code><a href="#topic+pheno2covar">pheno2covar</a></code>.</p>
</dd>
<dt><code>g_covar_table</code></dt><dd><p>A matrix holding the individual values for each marker-derived covariate. See <code><a href="#topic+marker2covar">marker2covar</a></code>.</p>
</dd>
<dt><code>model_family</code></dt><dd><p>Indicates the model family of the phenotypes. This can be either &quot;gaussian&quot; or &quot;binomial&quot;.
If this argument is length 1, all phenotypes will be assigned to the same family. Phenotypes can be assigned
different model families by providing a vector of the same length as the number of phenotypes, indicating how
each phenotype should be modeled. See <code><a href="#topic+singlescan">singlescan</a></code>.</p>
</dd>
<dt><code>scan_what</code></dt><dd><p>A string indicating whether &quot;eigentraits&quot;, &quot;normalized_traits&quot;, or &quot;raw_traits&quot; should be analyzed.
See <code><a href="#topic+get_pheno">get_pheno</a></code>.</p>
</dd>
<dt><code>ET</code></dt><dd><p>A matrix holding the eigentraits to be analyzed.</p>
</dd>
<dt><code>singular_values</code></dt><dd><p>Added by <code><a href="#topic+get_eigentraits">get_eigentraits</a></code>. A vector holding the singular values from the singular
value decomposition of the trait matrix. They are used in rotating the final direct influences back to trait space
from eigentrait space. See <code><a href="#topic+get_eigentraits">get_eigentraits</a></code> and <code><a href="#topic+direct_influence">direct_influence</a></code>.</p>
</dd>
<dt><code>right_singular_vectors</code></dt><dd><p>Added by <code><a href="#topic+get_eigentraits">get_eigentraits</a></code>. A matrix containing the right singular vectors
from the singular value decomposition of the trait matrix. They are used in rotating the final direct influences
back to trait space from eigentrait space. See <code><a href="#topic+get_eigentraits">get_eigentraits</a></code> and <code><a href="#topic+direct_influence">direct_influence</a></code>.</p>
</dd>
<dt><code>traits_scaled</code></dt><dd><p>Whether the traits should be mean-centered and standardized before analyzing.</p>
</dd>
<dt><code>traits_normalized</code></dt><dd><p>Whether the traits should be rank Z normalized before analyzing.</p>
</dd>
<dt><code>var_to_var_influences_perm</code></dt><dd><p>added in <code><a href="#topic+error_prop">error_prop</a></code>. The list of results from the error propagation
of permuted coefficients.</p>
</dd>
<dt><code>var_to_var_influences</code></dt><dd><p>added in <code><a href="#topic+error_prop">error_prop</a></code>. The list of results from the error propagation of coefficients.</p>
</dd>
<dt><code>pval_correction</code></dt><dd><p>Options are &quot;holm&quot;, &quot;hochberg&quot;, &quot;hommel&quot;, &quot;bonferroni&quot;, &quot;BH&quot;, &quot;BY&quot;,&quot;fdr&quot;, &quot;none&quot;.</p>
</dd>
<dt><code>var_to_var_p_val</code></dt><dd><p>The final table of cape interaction results calculated by <code><a href="#topic+error_prop">error_prop</a></code>.</p>
</dd>
<dt><code>max_var_to_pheno_influence</code></dt><dd><p>The final table of cape direct influences of markers to traits calculated
by <code><a href="#topic+direct_influence">direct_influence</a></code>.</p>
</dd>
<dt><code>full_net</code></dt><dd><p>An adjacency matrix holding significant cape interactions between individual markers. See
<code><a href="#topic+plot_network">plot_network</a></code> and <code><a href="#topic+get_network">get_network</a></code>.</p>
</dd>
<dt><code>use_kinship</code></dt><dd><p>Whether to use a kinship correction in the analysis.</p>
</dd>
<dt><code>kinship_type</code></dt><dd><p>which type of kinship matrix to use</p>
</dd>
<dt><code>transform_to_phenospace</code></dt><dd><p>whether to transform to phenospace or not.</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>geno_for_pairscan</code></dt><dd><p>geno for pairscan</p>
</dd>
<dt><code>marker_selection_method</code></dt><dd><p>marker selection method</p>
</dd>
<dt><code>linkage_blocks_collapsed</code></dt><dd><p>linkage blocks collapsed</p>
</dd>
<dt><code>linkage_blocks_full</code></dt><dd><p>linkage blocks full</p>
</dd>
<dt><code>collapsed_net</code></dt><dd><p>collapsed net</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Cape-assign_parameters"><code>Cape$assign_parameters()</code></a>
</p>
</li>
<li> <p><a href="#method-Cape-check_inputs"><code>Cape$check_inputs()</code></a>
</p>
</li>
<li> <p><a href="#method-Cape-check_geno_names"><code>Cape$check_geno_names()</code></a>
</p>
</li>
<li> <p><a href="#method-Cape-new"><code>Cape$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Cape-plotSVD"><code>Cape$plotSVD()</code></a>
</p>
</li>
<li> <p><a href="#method-Cape-plotSinglescan"><code>Cape$plotSinglescan()</code></a>
</p>
</li>
<li> <p><a href="#method-Cape-plotPairscan"><code>Cape$plotPairscan()</code></a>
</p>
</li>
<li> <p><a href="#method-Cape-plotVariantInfluences"><code>Cape$plotVariantInfluences()</code></a>
</p>
</li>
<li> <p><a href="#method-Cape-plotNetwork"><code>Cape$plotNetwork()</code></a>
</p>
</li>
<li> <p><a href="#method-Cape-plotFullNetwork"><code>Cape$plotFullNetwork()</code></a>
</p>
</li>
<li> <p><a href="#method-Cape-writeVariantInfluences"><code>Cape$writeVariantInfluences()</code></a>
</p>
</li>
<li> <p><a href="#method-Cape-set_pheno"><code>Cape$set_pheno()</code></a>
</p>
</li>
<li> <p><a href="#method-Cape-set_geno"><code>Cape$set_geno()</code></a>
</p>
</li>
<li> <p><a href="#method-Cape-create_covar_table"><code>Cape$create_covar_table()</code></a>
</p>
</li>
<li> <p><a href="#method-Cape-save_rds"><code>Cape$save_rds()</code></a>
</p>
</li>
<li> <p><a href="#method-Cape-read_rds"><code>Cape$read_rds()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Cape-assign_parameters"></a>



<h4>Method <code>assign_parameters()</code></h4>

<p>Assigns variables from the parameter file to attributes in the Cape object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Cape$assign_parameters()</pre></div>


<hr>
<a id="method-Cape-check_inputs"></a>



<h4>Method <code>check_inputs()</code></h4>

<p>Checks the dimensionality of inputs and its consistency.
</p>


<h5>Usage</h5>

<div class="r"><pre>Cape$check_inputs()</pre></div>


<hr>
<a id="method-Cape-check_geno_names"></a>



<h4>Method <code>check_geno_names()</code></h4>

<p>Checks genotype names.
</p>


<h5>Usage</h5>

<div class="r"><pre>Cape$check_geno_names()</pre></div>


<hr>
<a id="method-Cape-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialization method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Cape$new(
  parameter_file = NULL,
  yaml_parameters = NULL,
  results_path = NULL,
  save_results = FALSE,
  use_saved_results = TRUE,
  pheno = NULL,
  chromosome = NULL,
  marker_num = NULL,
  marker_location = NULL,
  geno_names = NULL,
  geno = NULL,
  .geno_for_pairscan = NULL,
  peak_density = NULL,
  window_size = NULL,
  tolerance = NULL,
  ref_allele = NULL,
  alpha = NULL,
  covar_table = NULL,
  num_alleles_in_pairscan = NULL,
  max_pair_cor = NULL,
  min_per_genotype = NULL,
  pairscan_null_size = NULL,
  p_covar = NULL,
  g_covar = NULL,
  p_covar_table = NULL,
  g_covar_table = NULL,
  model_family = NULL,
  scan_what = NULL,
  ET = NULL,
  singular_values = NULL,
  right_singular_vectors = NULL,
  traits_scaled = NULL,
  traits_normalized = NULL,
  var_to_var_influences_perm = NULL,
  var_to_var_influences = NULL,
  pval_correction = NULL,
  var_to_var_p_val = NULL,
  max_var_to_pheno_influence = NULL,
  full_net = NULL,
  use_kinship = NULL,
  kinship_type = NULL,
  transform_to_phenospace = NULL,
  plot_pdf = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>parameter_file</code></dt><dd><p>string, full path to YAML file with initialization
parameters</p>
</dd>
<dt><code>yaml_parameters</code></dt><dd><p>string representing YAML CAPE parameters. See the
vignette for more descriptions of individual parameter settings.</p>
</dd>
<dt><code>results_path</code></dt><dd><p>string, full path to directory for storing results
(optional, a directory will be created if one is not specified)</p>
</dd>
<dt><code>save_results</code></dt><dd><p>Whether to save cape results. Defaults to TRUE.</p>
</dd>
<dt><code>use_saved_results</code></dt><dd><p>Whether to use existing results from a 
previous run. This can save time if re-running an analysis, but
can lead to problems if the old run and new run have competing settings.
If errors arise, and use_saved_results is set to TRUE, try setting it 
to FALSE, or deleting previous results.</p>
</dd>
<dt><code>pheno</code></dt><dd><p>A matrix containing the traits to be analyzed. Traits are in
columns and individuals are in rows.</p>
</dd>
<dt><code>chromosome</code></dt><dd><p>A vector the same length as the number of markers indicating
which chromosome each marker lives on.</p>
</dd>
<dt><code>marker_num</code></dt><dd><p>A vector the same length as the number of markers indicating
the index of each marker</p>
</dd>
<dt><code>marker_location</code></dt><dd><p>A vector the same length as the number of markers indicating
the genomic position of each marker. The positions are primarily used for plotting
and can be in base pairs, centiMorgans, or dummy variables.</p>
</dd>
<dt><code>geno_names</code></dt><dd><p>The dimnames of the genotype array. The genotype array is a three-dimensional
array in which rows are individuals, columns are alleles, and the third dimension houses
the markers. Genotypes are pulled for analysis using <code><a href="#topic+get_geno">get_geno</a></code> based on
geno_names. Only the individuals, alleles, and markers listed in geno_names are
taken from the genotype matrix. Functions that remove markers and individuals from
analysis always operate on geno_names in addition to other relevant slots.
The names of geno_names must be &quot;mouse&quot;, &quot;allele&quot;, &quot;locus.&quot;</p>
</dd>
<dt><code>geno</code></dt><dd><p>A three dimensional array holding genotypes for each animal for each allele
at each marker. The genotypes are continuously valued probabilities ranging from 0 to 1. 
The dimnames of geno must be &quot;mouse&quot;, &quot;allele&quot;, and &quot;locus,&quot; even if the individuals are
not mice.</p>
</dd>
<dt><code>.geno_for_pairscan</code></dt><dd><p>A two-dimensional matrix holding the genotypes that will be analyzed
in the pairscan. Alleles are in columns and individuals are in rows. As in the geno array, 
values are continuous probabilities ranging from 0 to 1.</p>
</dd>
<dt><code>peak_density</code></dt><dd><p>The density parameter for <code><a href="#topic+select_markers_for_pairscan">select_markers_for_pairscan</a></code>.
Determines how densely markers under an individual effect size peak are selected 
for the pairscan if marker_selection_method is TRUE. Defaults to 0.5.</p>
</dd>
<dt><code>window_size</code></dt><dd><p>The window size used by <code><a href="#topic+select_markers_for_pairscan">select_markers_for_pairscan</a></code>.
It specifies how many markers are used to smooth effect size curves for automatic peak
identification. If set to NULL, window_size is determined automatically. Used when 
marker_selection_method is TRUE.</p>
</dd>
<dt><code>tolerance</code></dt><dd><p>The wiggle room afforded to <code><a href="#topic+select_markers_for_pairscan">select_markers_for_pairscan</a></code> in 
finding a target number of markers. If num_alleles_in_pairscan is 100 and the tolerance 
is 5, the algorithm will stop when it identifies anywhere between 95 and 105 markers 
for the pairscan.</p>
</dd>
<dt><code>ref_allele</code></dt><dd><p>A string of length 1 indicating which allele to use as the reference allele.
In two-parent crosses, this is usually allele A. In DO/CC populations, we recommend using
B as the reference allele. B is the allele from the C57Bl6/J mouse, which is often used as
a reference strain.</p>
</dd>
<dt><code>alpha</code></dt><dd><p>The significance level for calculating effect size thresholds in the 
<code><a href="#topic+singlescan">singlescan</a></code>. If singlescan_perm is 0, this parameter is ignored.</p>
</dd>
<dt><code>covar_table</code></dt><dd><p>A matrix of covariates with covariates in columns and individuals
in rows. Must be numeric.</p>
</dd>
<dt><code>num_alleles_in_pairscan</code></dt><dd><p>The number of alleles to test in the pairwise scan. 
Because Cape is computationally intensive, we usually need to test only a subset
of available markers in the pairscan, particularly if the kinship correction is
being used.</p>
</dd>
<dt><code>max_pair_cor</code></dt><dd><p>the maximum Pearson correlation between two markers. If their
correlation exceeds this value, they will not be tested against each other in the
pairscan. This threshold is set to prevent false positive arising from testing
highly correlated markers. If this value is set to NULL, min_per_genotype must
be specified.</p>
</dd>
<dt><code>min_per_genotype</code></dt><dd><p>minimum The minimum number of individuals allowable per
genotype combination in the pair scan. If for a given marker pair, one of the 
genotype combinations is underrepresented, the marker pair is not tested. If 
this value is NULL, max_pair_cor must be specified.</p>
</dd>
<dt><code>pairscan_null_size</code></dt><dd><p>The total size of the null distribution.
This is DIFFERENT than the number of permutations to run. Each permutation
generates n choose 2 elements for the pairscan. So for example, a permutation
that tests 100 pairs of markers will generate a null distribution of size 4950.
This process is repeated until the total null size is reached. If the null size
is set to 5000, two permutations of 100 markers would be done to get to a null
distribution size of 5000.</p>
</dd>
<dt><code>p_covar</code></dt><dd><p>A vector of strings specifying the names of covariates derived
from traits. See <code><a href="#topic+pheno2covar">pheno2covar</a></code>.</p>
</dd>
<dt><code>g_covar</code></dt><dd><p>A vector of strings specifying the names of covariates derived 
from genetic markers. See <code><a href="#topic+marker2covar">marker2covar</a></code>.</p>
</dd>
<dt><code>p_covar_table</code></dt><dd><p>A matrix holding the individual values for each
trait-derived covariate. See <code><a href="#topic+pheno2covar">pheno2covar</a></code>.</p>
</dd>
<dt><code>g_covar_table</code></dt><dd><p>A matrix holding the individual values for each 
marker-derived covariate. See <code><a href="#topic+marker2covar">marker2covar</a></code>.</p>
</dd>
<dt><code>model_family</code></dt><dd><p>Indicates the model family of the phenotypes
This can be either &quot;gaussian&quot; or &quot;binomial&quot;. If this argument
is length 1, all phenotypes will be assigned to the same
family. Phenotypes can be assigned different model families by
providing a vector of the same length as the number of phenotypes,
indicating how each phenotype should be modeled. See <code><a href="#topic+singlescan">singlescan</a></code>.</p>
</dd>
<dt><code>scan_what</code></dt><dd><p>A string indicating whether &quot;eigentraits&quot;, &quot;normalized_traits&quot;, or 
&quot;raw_traits&quot; should be analyzed. See <code><a href="#topic+get_pheno">get_pheno</a></code>.</p>
</dd>
<dt><code>ET</code></dt><dd><p>A matrix holding the eigentraits to be analyzed.</p>
</dd>
<dt><code>singular_values</code></dt><dd><p>Added by <code><a href="#topic+get_eigentraits">get_eigentraits</a></code>. A vector holding 
the singular values from the singular
value decomposition of the trait matrix. They are used in rotating the 
final direct influences back to trait space from eigentrait space. See
<code><a href="#topic+get_eigentraits">get_eigentraits</a></code> and <code><a href="#topic+direct_influence">direct_influence</a></code>.</p>
</dd>
<dt><code>right_singular_vectors</code></dt><dd><p>Added by <code><a href="#topic+get_eigentraits">get_eigentraits</a></code>. A matrix 
containing the right singular vectors from the singular
value decomposition of the trait matrix. They are used in rotating the 
final direct influences back to trait space from eigentrait space. See
<code><a href="#topic+get_eigentraits">get_eigentraits</a></code> and <code><a href="#topic+direct_influence">direct_influence</a></code>.</p>
</dd>
<dt><code>traits_scaled</code></dt><dd><p>Whether the traits should be mean-centered and standardized
before analyzing.</p>
</dd>
<dt><code>traits_normalized</code></dt><dd><p>Whether the traits should be rank Z normalized before
analyzing.</p>
</dd>
<dt><code>var_to_var_influences_perm</code></dt><dd><p>added in <code><a href="#topic+error_prop">error_prop</a></code> 
The list of results from the error propagation of permuted coefficients.</p>
</dd>
<dt><code>var_to_var_influences</code></dt><dd><p>added in <code><a href="#topic+error_prop">error_prop</a></code> 
The list of results from the error propagation of coefficients.</p>
</dd>
<dt><code>pval_correction</code></dt><dd><p>Options are &quot;holm&quot;, &quot;hochberg&quot;, &quot;hommel&quot;, &quot;bonferroni&quot;, &quot;BH&quot;, &quot;BY&quot;,&quot;fdr&quot;, &quot;none&quot;</p>
</dd>
<dt><code>var_to_var_p_val</code></dt><dd><p>The final table of cape interaction results calculated by <code><a href="#topic+error_prop">error_prop</a></code>.</p>
</dd>
<dt><code>max_var_to_pheno_influence</code></dt><dd><p>The final table of cape direct influences of markers to traits
calculated by <code><a href="#topic+direct_influence">direct_influence</a></code>.</p>
</dd>
<dt><code>full_net</code></dt><dd><p>An adjacency matrix holding significant cape interactions between
individual markers. See <code><a href="#topic+plot_network">plot_network</a></code> and <code><a href="#topic+get_network">get_network</a></code>.</p>
</dd>
<dt><code>use_kinship</code></dt><dd><p>Whether to use a kinship correction in the analysis.</p>
</dd>
<dt><code>kinship_type</code></dt><dd><p>Which type of kinship matrix to use. Either &quot;overall&quot; or &quot;ltco.&quot;</p>
</dd>
<dt><code>transform_to_phenospace</code></dt><dd><p>whether to transform to phenospace or not.</p>
</dd>
<dt><code>plot_pdf</code></dt><dd><p>logical. If TRUE, results are generated as pdf</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Cape-plotSVD"></a>



<h4>Method <code>plotSVD()</code></h4>

<p>Plot Eigentraits
</p>


<h5>Usage</h5>

<div class="r"><pre>Cape$plotSVD(filename)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>filename</code></dt><dd><p>filename of result plot</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Cape-plotSinglescan"></a>



<h4>Method <code>plotSinglescan()</code></h4>

<p>Plot results of single-locus scans
</p>


<h5>Usage</h5>

<div class="r"><pre>Cape$plotSinglescan(
  filename,
  singlescan_obj,
  width = 20,
  height = 6,
  units = "in",
  res = 300,
  standardized = TRUE,
  allele_labels = NULL,
  alpha = alpha,
  include_covars = TRUE,
  line_type = "l",
  pch = 16,
  cex = 0.5,
  lwd = 3,
  traits = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>filename</code></dt><dd><p>filename of result plot.</p>
</dd>
<dt><code>singlescan_obj</code></dt><dd><p>a singlescan object from <code><a href="#topic+singlescan">singlescan</a></code></p>
</dd>
<dt><code>width</code></dt><dd><p>width of result plot, default is 20.</p>
</dd>
<dt><code>height</code></dt><dd><p>height of result plot, default is 6.</p>
</dd>
<dt><code>units</code></dt><dd><p>units of result plot, default is &quot;in&quot;.</p>
</dd>
<dt><code>res</code></dt><dd><p>resolution of result plot, default is 300.</p>
</dd>
<dt><code>standardized</code></dt><dd><p>If TRUE t statistics are plotted. If FALSE, effect sizes are plotted, default is TRUE</p>
</dd>
<dt><code>allele_labels</code></dt><dd><p>A vector of labels for the alleles if different that those
stored in the data_object.</p>
</dd>
<dt><code>alpha</code></dt><dd><p>the alpha significance level. Lines for significance values will only
be plotted if n_perm &gt; 0 when <code><a href="#topic+singlescan">singlescan</a></code> was run. And only alpha values
specified in <code><a href="#topic+singlescan">singlescan</a></code> can be plotted.</p>
</dd>
<dt><code>include_covars</code></dt><dd><p>Whether to include covariates in the plot.</p>
</dd>
<dt><code>line_type</code></dt><dd><p>as defined in plot</p>
</dd>
<dt><code>pch</code></dt><dd><p>see the &quot;points()&quot; R function. Default is 16 (a point).</p>
</dd>
<dt><code>cex</code></dt><dd><p>see the &quot;points()&quot; R function. Default is 0.5.</p>
</dd>
<dt><code>lwd</code></dt><dd><p>line width, default is 3.</p>
</dd>
<dt><code>traits</code></dt><dd><p>a vector of trait names to plot. Defaults to all traits.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Cape-plotPairscan"></a>



<h4>Method <code>plotPairscan()</code></h4>

<p>Plot the result of the pairwise scan
</p>


<h5>Usage</h5>

<div class="r"><pre>Cape$plotPairscan(
  filename,
  pairscan_obj,
  phenotype = NULL,
  show_marker_labels = TRUE,
  show_alleles = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>filename</code></dt><dd><p>filename of result plot.</p>
</dd>
<dt><code>pairscan_obj</code></dt><dd><p>a pairscan object from <code><a href="#topic+pairscan">pairscan</a></code></p>
</dd>
<dt><code>phenotype</code></dt><dd><p>The names of the phenotypes to be plotted. If NULL, all phenotypes are plotted.</p>
</dd>
<dt><code>show_marker_labels</code></dt><dd><p>If TRUE marker labels are plotted along the axes. If FALSE, they are omitted.</p>
</dd>
<dt><code>show_alleles</code></dt><dd><p>If TRUE, the allele of each marker is indicated by color.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Cape-plotVariantInfluences"></a>



<h4>Method <code>plotVariantInfluences()</code></h4>

<p>Plot cape coefficients
</p>


<h5>Usage</h5>

<div class="r"><pre>Cape$plotVariantInfluences(
  filename,
  width = 10,
  height = 7,
  p_or_q = p_or_q,
  standardize = FALSE,
  not_tested_col = "lightgray",
  covar_width = NULL,
  pheno_width = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>filename</code></dt><dd><p>filename of result plot.</p>
</dd>
<dt><code>width</code></dt><dd><p>width of result plot, default is 10.</p>
</dd>
<dt><code>height</code></dt><dd><p>height of result plot, default is 7.</p>
</dd>
<dt><code>p_or_q</code></dt><dd><p>A threshold indicating the maximum p value (or q value if FDR was used) of significant 
interactions and main effects.</p>
</dd>
<dt><code>standardize</code></dt><dd><p>Whether to plot effect sizes (FALSE) or standardized effect sizes (TRUE), 
default is TRUE.</p>
</dd>
<dt><code>not_tested_col</code></dt><dd><p>The color to use for marker pairs not tested. Takes the same values as 
pos_col and neg_col, default is &quot;lightgray&quot;.</p>
</dd>
<dt><code>covar_width</code></dt><dd><p>See pheno_width. This is the same effect for covariates.</p>
</dd>
<dt><code>pheno_width</code></dt><dd><p>Each marker and trait gets one column in the matrix. If there are many markers, 
this makes the effects on the traits difficult  to see. pheno_width increases the number of columns
given to the phenotypes. For example, if pheno_width = 11, the phenotypes will be shown 11 times wider
than individual markers.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Cape-plotNetwork"></a>



<h4>Method <code>plotNetwork()</code></h4>

<p>Plots cape results as a circular network
</p>


<h5>Usage</h5>

<div class="r"><pre>Cape$plotNetwork(
  filename,
  label_gap = 10,
  label_cex = 1.5,
  show_alleles = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>filename</code></dt><dd><p>filename of result plot.</p>
</dd>
<dt><code>label_gap</code></dt><dd><p>A numeric value indicating the size of the gap the chromosomes and their labels, 
default is 10.</p>
</dd>
<dt><code>label_cex</code></dt><dd><p>A numeric value indicating the size of the labels, default is 1.5.</p>
</dd>
<dt><code>show_alleles</code></dt><dd><p>TRUE show the alleles, FALSE does not show alleles. Default is FALSE.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Cape-plotFullNetwork"></a>



<h4>Method <code>plotFullNetwork()</code></h4>

<p>Plot the final epistatic network in a traditional network view.
</p>


<h5>Usage</h5>

<div class="r"><pre>Cape$plotFullNetwork(
  filename,
  zoom = 1.2,
  node_radius = 0.3,
  label_nodes = TRUE,
  label_offset = 0.4,
  label_cex = 0.5,
  bg_col = "lightgray",
  arrow_length = 0.1,
  layout_matrix = "layout_with_kk",
  legend_position = "topright",
  edge_lwd = 1,
  legend_radius = 2,
  legend_cex = 0.7,
  xshift = -1
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>filename</code></dt><dd><p>filename of result plot.</p>
</dd>
<dt><code>zoom</code></dt><dd><p>Allows the user to zoom in and out on the image if the network is either 
running off the edges of the plot or too small in the middle of the plot, default is 1.2.</p>
</dd>
<dt><code>node_radius</code></dt><dd><p>The size of the pie chart for each node, default is 0.3.</p>
</dd>
<dt><code>label_nodes</code></dt><dd><p>A logical value indicating whether the nodes should be labeled.
Users may want to remove labels for large networks, default is TRUE.</p>
</dd>
<dt><code>label_offset</code></dt><dd><p>The amount by which to offset the node labels from the center of
the nodes, default is 0.4.</p>
</dd>
<dt><code>label_cex</code></dt><dd><p>The size of the node labels, default is 0.5.</p>
</dd>
<dt><code>bg_col</code></dt><dd><p>The color to be used in pie charts for non-significant main effects.
Takes the same values as pos_col, default is &quot;lightgray&quot;.</p>
</dd>
<dt><code>arrow_length</code></dt><dd><p>The length of the head of the arrow, default is 0.1.</p>
</dd>
<dt><code>layout_matrix</code></dt><dd><p>Users have the option of providing their own layout matrix for the
network. This should be a two column matrix indicating the x and y coordinates of each 
node in the network, default is &quot;layout_with_kk&quot;.</p>
</dd>
<dt><code>legend_position</code></dt><dd><p>The position of the legend on the plot, default is &quot;topright&quot;.</p>
</dd>
<dt><code>edge_lwd</code></dt><dd><p>The thickness of the arrows showing the interactions, default is 1.</p>
</dd>
<dt><code>legend_radius</code></dt><dd><p>The size of the legend indicating which pie piece corresponds to which
traits, default is 2.</p>
</dd>
<dt><code>legend_cex</code></dt><dd><p>The size of the labels in the legend, default is 0.7.</p>
</dd>
<dt><code>xshift</code></dt><dd><p>A constant by which to shift the x values of all nodes in the network,
default is -1.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Cape-writeVariantInfluences"></a>



<h4>Method <code>writeVariantInfluences()</code></h4>

<p>Write significant cape interactions to a csv file.
</p>


<h5>Usage</h5>

<div class="r"><pre>Cape$writeVariantInfluences(
  filename,
  p_or_q = 0.05,
  include_main_effects = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>filename</code></dt><dd><p>filename of csv file</p>
</dd>
<dt><code>p_or_q</code></dt><dd><p>A threshold indicating the maximum adjusted p value considered 
significant. If an FDR method has been used to correct for multiple testing, 
this value specifies the maximum q value considered significant, default is 0.05.</p>
</dd>
<dt><code>include_main_effects</code></dt><dd><p>Whether to include main effects (TRUE) or only
interaction effects (FALSE) in the output table, default is TRUE.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Cape-set_pheno"></a>



<h4>Method <code>set_pheno()</code></h4>

<p>Set phenotype
</p>


<h5>Usage</h5>

<div class="r"><pre>Cape$set_pheno(val)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>val</code></dt><dd><p>phenotype value.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Cape-set_geno"></a>



<h4>Method <code>set_geno()</code></h4>

<p>Set genotype
</p>


<h5>Usage</h5>

<div class="r"><pre>Cape$set_geno(val)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>val</code></dt><dd><p>genotype value.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Cape-create_covar_table"></a>



<h4>Method <code>create_covar_table()</code></h4>

<p>Create covariate table
</p>


<h5>Usage</h5>

<div class="r"><pre>Cape$create_covar_table(value)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>value</code></dt><dd><p>covariate values</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Cape-save_rds"></a>



<h4>Method <code>save_rds()</code></h4>

<p>Save to RDS file
</p>


<h5>Usage</h5>

<div class="r"><pre>Cape$save_rds(object, filename)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>object</code></dt><dd><p>data to be saved.</p>
</dd>
<dt><code>filename</code></dt><dd><p>filename of result RDS file.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Cape-read_rds"></a>



<h4>Method <code>read_rds()</code></h4>

<p>Read RDS file
</p>


<h5>Usage</h5>

<div class="r"><pre>Cape$read_rds(filename)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>filename</code></dt><dd><p>RDS filename to be read.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
param_file &lt;- "cape_parameters.yml"
results_path = "."
cape_obj &lt;- read_population("cross.csv")
combined_obj &lt;- cape2mpp(cape_obj)
pheno_obj &lt;- combined_obj$data_obj
geno_obj &lt;- combined_obj$geno_obj

data_obj &lt;- Cape$new(parameter_file = param_file,
results_path = results_path, pheno = pheno_obj$pheno, chromosome = pheno_obj$chromosome, 
marker_num = pheno_obj$marker_num, marker_location = pheno_obj$marker_location, 
geno_names = pheno_obj$geno_names, geno = geno_obj)

## End(Not run)

</code></pre>

<hr>
<h2 id='cape2mpp'>Converts a <code><a href="#topic+read_population">read_population</a></code> object to a multi-parent object</h2><span id='topic+cape2mpp'></span>

<h3>Description</h3>

<p>This function converts an object formatted for cape 1.0
to an object formatted for cape 2.0
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cape2mpp(data_obj, geno_obj = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cape2mpp_+3A_data_obj">data_obj</code></td>
<td>
<p>a data_obj formatted for cape 1.0</p>
</td></tr>
<tr><td><code id="cape2mpp_+3A_geno_obj">geno_obj</code></td>
<td>
<p>a genotype object. If geno_obj is NULL
the genotype object is generated from data_obj$geno.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list with two objects:
<code>list("data_obj" = data_obj, "geno_obj" = geno_obj)</code>
These two objects must be separated again to run through 
cape.
</p>

<hr>
<h2 id='center_std'>This function mean centers and standardizes a vector</h2><span id='topic+center_std'></span>

<h3>Description</h3>

<p>This function mean centers and standardizes a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>center_std(v)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="center_std_+3A_v">v</code></td>
<td>
<p>The vector to be mean-centered and standardized</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A mean-centered and standardized vector
</p>

<hr>
<h2 id='check_bad_markers'>Checks for unused markers</h2><span id='topic+check_bad_markers'></span>

<h3>Description</h3>

<p>This function checks for markers that aren't used
in cape. For example, markers on sex chromosomes,
or mitochondrial markers. It also removes any 
markers that are invariant across all individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_bad_markers(data_obj, geno_obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_bad_markers_+3A_data_obj">data_obj</code></td>
<td>
<p>a <code><a href="#topic+Cape">Cape</a></code> object</p>
</td></tr>
<tr><td><code id="check_bad_markers_+3A_geno_obj">geno_obj</code></td>
<td>
<p>a genotype object</p>
</td></tr>
</table>

<hr>
<h2 id='check_communities'>Check community assignments</h2><span id='topic+check_communities'></span>

<h3>Description</h3>

<p>This function checks community assignments
and makes sure that communities are not 
split up along the chromosome
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_communities(comm)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_communities_+3A_comm">comm</code></td>
<td>
<p>community from <code>fastgreedy.community</code></p>
</td></tr>
</table>

<hr>
<h2 id='check_geno'>Check to see if the any markers in the supplied
genotype matrix is one of the covariates.</h2><span id='topic+check_geno'></span>

<h3>Description</h3>

<p>Check to see if the any markers in the supplied
genotype matrix is one of the covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_geno(genotype, covar_table)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_geno_+3A_genotype">genotype</code></td>
<td>
<p>The vector of genotype values for
a single marker</p>
</td></tr>
<tr><td><code id="check_geno_+3A_covar_table">covar_table</code></td>
<td>
<p>The table of covariates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>covariates indices that match the genotype
</p>

<hr>
<h2 id='check_underscore'>Checks for underscores in marker names</h2><span id='topic+check_underscore'></span>

<h3>Description</h3>

<p>This function looks for underscores in 
marker names. Beause cape uses underscores
to separate marker from allele names, we
cannot have any in the marker names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_underscore(data_obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_underscore_+3A_data_obj">data_obj</code></td>
<td>
<p>a <code><a href="#topic+Cape">Cape</a></code> object</p>
</td></tr>
</table>

<hr>
<h2 id='chunkV'>Bins a vector into chunks</h2><span id='topic+chunkV'></span>

<h3>Description</h3>

<p>This function is used to chunk a vector into 
bins. It is primarily used to divide jobs 
sent to a certain number of parallel clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chunkV(V, num_chunks)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chunkV_+3A_v">V</code></td>
<td>
<p>The vector to be divided into chunks</p>
</td></tr>
<tr><td><code id="chunkV_+3A_num_chunks">num_chunks</code></td>
<td>
<p>The number of chunks in which
to bin the vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list of length 
num_chunks. Each element in the list contains
the elements of the vector that were assigned 
to that bin.
</p>

<hr>
<h2 id='colors_from_values'>Retrieve colors based on numeric values</h2><span id='topic+colors_from_values'></span>

<h3>Description</h3>

<p>This function gets colors for numeric values
It can use one the function <code><a href="#topic+get_color">get_color</a></code>,
which accepts any of c(&quot;green&quot;, &quot;purple&quot;, &quot;orange&quot;, 
&quot;blue&quot;, &quot;brown&quot;, &quot;gray&quot;), or it can use pheatmap
colors.
The colors can be split into multiple classes based
on split_points. For example positive and negative 
numbers can each be plotted on their own scale, by 
setting split_at_vals to TRUE and setting split_points
to 0. split_points can be a vector defining multiple 
value classes for different colors. By default, the
different classes use the col_scale colors in order.
Specific colors for classes can be set using the 
col_scale argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colors_from_values(
  vals,
  split_at_vals = FALSE,
  split_points = 0,
  col_scale = c("green", "purple", "orange", "blue", "brown", "gray"),
  light_dark = "f",
  grad_dir = c("high", "low", "middle", "ends"),
  color_fun = c("linear", "exponential"),
  exp_steepness = 1,
  global_color_scale = FALSE,
  global_min = NULL,
  global_max = NULL,
  use_pheatmap_colors = FALSE,
  na_col = "lightgray"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="colors_from_values_+3A_vals">vals</code></td>
<td>
<p>A vector of numerical values for which to
retrieve colors.</p>
</td></tr>
<tr><td><code id="colors_from_values_+3A_split_at_vals">split_at_vals</code></td>
<td>
<p>A logical value indicating whether
the numbers should be broken into classes with different 
colors.</p>
</td></tr>
<tr><td><code id="colors_from_values_+3A_split_points">split_points</code></td>
<td>
<p>If split_at_vals is TRUE, split_points
is used to define multiple classes of numbers. For example,
if split_points is 0, negative numbers will be assigned one
class of colors, and positive numbers will be assigned another.</p>
</td></tr>
<tr><td><code id="colors_from_values_+3A_col_scale">col_scale</code></td>
<td>
<p>One of c(&quot;green&quot;, &quot;purple&quot;, &quot;orange&quot;, &quot;blue&quot;, 
&quot;brown&quot;, &quot;gray&quot;) to indicate the color scale to be used. Defaults
to gray.</p>
</td></tr>
<tr><td><code id="colors_from_values_+3A_light_dark">light_dark</code></td>
<td>
<p>One of &quot;l&quot;, &quot;d&quot;, or &quot;f&quot; indicating whether
the colors used should be light (&quot;l&quot;), dark (&quot;d&quot;), or from
across the full spectrum (&quot;f&quot;).</p>
</td></tr>
<tr><td><code id="colors_from_values_+3A_grad_dir">grad_dir</code></td>
<td>
<p>A string specifying how the color gradient 
should be applied. If &quot;high&quot; higher values are given darker
colors. If &quot;low&quot;, lower values are given darker colors.
If &quot;middle&quot; values in the middle of the spectrum are 
given darker colors, and if &quot;end&quot; values at the ends
of the spectrum are given darker colors.</p>
</td></tr>
<tr><td><code id="colors_from_values_+3A_color_fun">color_fun</code></td>
<td>
<p>Either &quot;linear&quot; or &quot;exponential&quot; indicating
how the colors should transition from light to dark across
values.</p>
</td></tr>
<tr><td><code id="colors_from_values_+3A_exp_steepness">exp_steepness</code></td>
<td>
<p>If color_fun is &quot;exponential,&quot; exp_steepness
indicates how quickly the colors should transition from light 
to dark.</p>
</td></tr>
<tr><td><code id="colors_from_values_+3A_global_color_scale">global_color_scale</code></td>
<td>
<p>Whether to impose a global minimum
and maximum to the colors, or to use the values themselves to 
determine the top and bottom of the color scale.</p>
</td></tr>
<tr><td><code id="colors_from_values_+3A_global_min">global_min</code></td>
<td>
<p>If global_color_scale is TRUE, the minimum
value that should be assigned a color.</p>
</td></tr>
<tr><td><code id="colors_from_values_+3A_global_max">global_max</code></td>
<td>
<p>If global_color_scale is TRUE, the maximum
value that should be assigned a color.</p>
</td></tr>
<tr><td><code id="colors_from_values_+3A_use_pheatmap_colors">use_pheatmap_colors</code></td>
<td>
<p>If TRUE, all other color parameters
are ignored, and colors like those used in the R package
pheatmap are used instead.</p>
</td></tr>
<tr><td><code id="colors_from_values_+3A_na_col">na_col</code></td>
<td>
<p>The color to use for missing values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of colors assigned to the number is vals is returned.
</p>


<h3>References</h3>

<p>Raivo Kolde (2019). pheatmap: Pretty Heatmaps. 
R package version 1.0.12. https://CRAN.R-project.org/package=pheatmap
</p>

<hr>
<h2 id='compare_markers'>Removes markers from data_obj that are not present in the geno_obj</h2><span id='topic+compare_markers'></span>

<h3>Description</h3>

<p>Removes markers from data_obj that are not present in the geno_obj
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_markers(data_obj, geno_obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compare_markers_+3A_data_obj">data_obj</code></td>
<td>
<p>a <code><a href="#topic+Cape">Cape</a></code> object</p>
</td></tr>
<tr><td><code id="compare_markers_+3A_geno_obj">geno_obj</code></td>
<td>
<p>a genotype object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The data_obj is returned, and any markers that were
not present in geno_obj are removed from data_obj$geno_names
</p>

<hr>
<h2 id='consec_pairs'>Generate a matrix of consecutive elements</h2><span id='topic+consec_pairs'></span>

<h3>Description</h3>

<p>Given a vector, this function generates a two-column
matrix in which each row contains an element and its
consecutive neighbor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>consec_pairs(elements)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="consec_pairs_+3A_elements">elements</code></td>
<td>
<p>a vector of elements</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with two columns. The first column
is identical to elements with the last element taken
off. And second column holds the next consecutive 
element.
</p>

<hr>
<h2 id='delete_underscore'>Delete underscores from marker names</h2><span id='topic+delete_underscore'></span>

<h3>Description</h3>

<p>Because cape uses underscores to separate marker names
from alleles, we need to delete any underscores that 
were present in the original marker names. This function
does that.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete_underscore(data_obj, geno_obj = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="delete_underscore_+3A_data_obj">data_obj</code></td>
<td>
<p>a <code><a href="#topic+Cape">Cape</a></code> object</p>
</td></tr>
<tr><td><code id="delete_underscore_+3A_geno_obj">geno_obj</code></td>
<td>
<p>a genotype object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>lists containing <code>data_obj</code> and <code>geno_obj</code>
with underscores removed from <code>data_obj$geno_names</code>
and <code>dimnames(geno_obj)</code>. These two elements must be
entered separately into <code><a href="#topic+run_cape">run_cape</a></code>.
</p>

<hr>
<h2 id='direct_influence'>Calculate the significance of direct influences of variant pairs on phenotypes</h2><span id='topic+direct_influence'></span>

<h3>Description</h3>

<p>This function rotates the variant-to-eigentrait effects back to variant-to-phenotype 
effects. It multiplies the <code class="reqn">\beta</code>-coefficient matrices of each variant (i) and each 
phenotype (j) (<code class="reqn">\beta_{i}^{j}</code>) by the singular value matrices (<code class="reqn">V \cdot W^{T}</code>) 
obtained from the singular value decomposition performed in <code><a href="#topic+get_eigentraits">get_eigentraits</a></code>. 
<code class="reqn">\beta_{i}^{j} = V \cdot W^{T}</code>. It also uses the permutation data from the pairwise 
scan (<code><a href="#topic+pairscan">pairscan</a></code>) to calculate an empirical p value for the influence of each 
marker pair on each phenotype. The empirical p values are then adjusted for multiple 
testing using Holm's step-down procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>direct_influence(
  data_obj,
  pairscan_obj,
  transform_to_phenospace = TRUE,
  pval_correction = c("holm", "hochberg", "hommel", "bonferroni", "BH", "BY", "fdr",
    "none"),
  perm_data = NULL,
  save_permutations = FALSE,
  n_cores = 4,
  path = ".",
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="direct_influence_+3A_data_obj">data_obj</code></td>
<td>
<p>a <code><a href="#topic+Cape">Cape</a></code> object</p>
</td></tr>
<tr><td><code id="direct_influence_+3A_pairscan_obj">pairscan_obj</code></td>
<td>
<p>a pairscan object</p>
</td></tr>
<tr><td><code id="direct_influence_+3A_transform_to_phenospace">transform_to_phenospace</code></td>
<td>
<p>A logical value. If TRUE, the influence of each marker on 
each eigentrait is transformed to the influence of each marker on each of the original 
phenotypes. If FALSE, no transformation is made. If the pair scan was done on eigentraits, 
the influence of each marker on each eigentrait is calculated. If the pair scan was done 
on raw phenotypes, the influence of each marker on each phenotype is calculated. The 
default behavior is to transform variant influences on eigentraits to variant influences 
on phenotypes.</p>
</td></tr>
<tr><td><code id="direct_influence_+3A_pval_correction">pval_correction</code></td>
<td>
<p>One of &quot;holm&quot;, &quot;hochberg&quot;, &quot;hommel&quot;, &quot;bonferroni&quot;, &quot;BH&quot;, &quot;BY&quot;, &quot;fdr&quot;, &quot;none&quot;, 
indicating whether the p value correction method used should be the Holm step-down procedure, 
false discovery rate or local false discovery rate respectively.</p>
</td></tr>
<tr><td><code id="direct_influence_+3A_perm_data">perm_data</code></td>
<td>
<p>The permutation data generated by <code><a href="#topic+pairscan">pairscan</a></code>.</p>
</td></tr>
<tr><td><code id="direct_influence_+3A_save_permutations">save_permutations</code></td>
<td>
<p>A logical value indicating whether the data from permutations should be 
saved. Saving the permutations requires more memory but can be helpful in diagnostics. If 
save_permutations is TRUE all permutation data are saved in an object called &quot;permutation.data.RDS&quot;.</p>
</td></tr>
<tr><td><code id="direct_influence_+3A_n_cores">n_cores</code></td>
<td>
<p>The number of cores to use if using parallel computing</p>
</td></tr>
<tr><td><code id="direct_influence_+3A_path">path</code></td>
<td>
<p>The path in which to write output data</p>
</td></tr>
<tr><td><code id="direct_influence_+3A_verbose">verbose</code></td>
<td>
<p>A logical value indicating whether to write progress to standard out.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns data_obj with an additional list called 
max_var_to_pheno_influence. This list has one element for each trait. 
Each element is a table with eight columns: 
marker: the marker name
conditioning_marker: the marker whose effect was conditioned on to achieve the
maximum main effect of marker.   
coef: the direct influence coefficient.
se: the standard error of the direct influence coefficient 
t_stat: the t statistic for the direct influence coefficient
|t_stat|: the absolute value of the t statistic
emp_p: the empirical p value of the direct influence coefficient
p_adjusted: the adjusted p value of the direct influence coefficient.
</p>

<hr>
<h2 id='draw_pie'>Draw a pie chart</h2><span id='topic+draw_pie'></span>

<h3>Description</h3>

<p>Draw a pie graph evenly divided into polygons
each colored according to the specified colors (cols)
The center of the pie chart is at coordinates x, y
and the radius is defined by rad
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_pie(
  x = 0.5,
  y = 0.5,
  radius = 1,
  cols = c("red", "green"),
  border_col = "black",
  node_border_lwd = 1,
  labels = NULL,
  edges = 200,
  label_cex = 1,
  xlim = NULL,
  ylim = NULL,
  add = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="draw_pie_+3A_x">x</code></td>
<td>
<p>the x coordinate for the center of the pie chart</p>
</td></tr>
<tr><td><code id="draw_pie_+3A_y">y</code></td>
<td>
<p>the y coordinate for the center of the pie chart</p>
</td></tr>
<tr><td><code id="draw_pie_+3A_radius">radius</code></td>
<td>
<p>The radius of the pie chart</p>
</td></tr>
<tr><td><code id="draw_pie_+3A_cols">cols</code></td>
<td>
<p>A vector of colors in any format specifying the colors 
of the sections of the pie chart. The number of colors determines
the number of sections in the pie.</p>
</td></tr>
<tr><td><code id="draw_pie_+3A_border_col">border_col</code></td>
<td>
<p>The color of the border of the pie chart. Use NA
to omit the border.</p>
</td></tr>
<tr><td><code id="draw_pie_+3A_node_border_lwd">node_border_lwd</code></td>
<td>
<p>The thickness of the border line</p>
</td></tr>
<tr><td><code id="draw_pie_+3A_labels">labels</code></td>
<td>
<p>A vector of character values giving labels for the 
sections of the pie.</p>
</td></tr>
<tr><td><code id="draw_pie_+3A_edges">edges</code></td>
<td>
<p>The default value is 200, which generates a circle.
Reducing this number will result in other shapes that may or may
not produce meaningful graphs depending on the number of pie sections.</p>
</td></tr>
<tr><td><code id="draw_pie_+3A_label_cex">label_cex</code></td>
<td>
<p>A numeric value giving the size of the label text.</p>
</td></tr>
<tr><td><code id="draw_pie_+3A_xlim">xlim</code></td>
<td>
<p>A vector of length two giving the xlim of the plot if 
add is FALSE</p>
</td></tr>
<tr><td><code id="draw_pie_+3A_ylim">ylim</code></td>
<td>
<p>A vector of length two giving the ylim of the plot if 
add is FALSE</p>
</td></tr>
<tr><td><code id="draw_pie_+3A_add">add</code></td>
<td>
<p>A logical value indicating whether the pie should be 
added to an existing plot (TRUE) or drawn on a new plot (FALSE).</p>
</td></tr>
</table>

<hr>
<h2 id='error_prop'>Estimate Errors of Regression Coefficients</h2><span id='topic+error_prop'></span>

<h3>Description</h3>

<p>This function uses error propagation formulas for 
quantities computed from regression coefficients to 
estimate the error for all regression coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>error_prop(
  data_obj,
  pairscan_obj,
  perm = FALSE,
  verbose = FALSE,
  run_parallel = FALSE,
  n_cores = 4,
  just_m = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="error_prop_+3A_data_obj">data_obj</code></td>
<td>
<p>a <code><a href="#topic+Cape">Cape</a></code> object</p>
</td></tr>
<tr><td><code id="error_prop_+3A_pairscan_obj">pairscan_obj</code></td>
<td>
<p>a pairscan object from <code><a href="#topic+pairscan">pairscan</a></code></p>
</td></tr>
<tr><td><code id="error_prop_+3A_perm">perm</code></td>
<td>
<p>A logical value to indicate whether error propagation should be 
performed on the test statistics (FALSE) or the permuted test statistics (TRUE).</p>
</td></tr>
<tr><td><code id="error_prop_+3A_verbose">verbose</code></td>
<td>
<p>A logical value to indicate whether the progress of the function 
should be printed to the screen.</p>
</td></tr>
<tr><td><code id="error_prop_+3A_run_parallel">run_parallel</code></td>
<td>
<p>boolean, default = FALSE</p>
</td></tr>
<tr><td><code id="error_prop_+3A_n_cores">n_cores</code></td>
<td>
<p>The number of cores to use if run_parallel is TRUE, default = 4</p>
</td></tr>
<tr><td><code id="error_prop_+3A_just_m">just_m</code></td>
<td>
<p>If TRUE only the m12 and m21 values are calculated. If FALSE, the
default, the standard deviations are also calculated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns the data object with a new list element: var_to_var_influences 
if perm is set to FALSE and var_to_var_influences_perm if perm is set to TRUE. These tables 
include the errors calculated for the marker1 to marker2 (m21) influences as well as the
marker2 to marker1 (m12) influences. These results are used by <code><a href="#topic+calc_p">calc_p</a></code> to
calculate empirical p values.
</p>

<hr>
<h2 id='exp_color_fun'>Exponential color function</h2><span id='topic+exp_color_fun'></span>

<h3>Description</h3>

<p>This function maps colors onto an exponential
function for use in colors_from_values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exp_color_fun(x_min, x_max, steepness = 1, num_cols = 256)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="exp_color_fun_+3A_x_min">x_min</code></td>
<td>
<p>The minimum value assigned to a color</p>
</td></tr>
<tr><td><code id="exp_color_fun_+3A_x_max">x_max</code></td>
<td>
<p>The maximum value assigned to a color</p>
</td></tr>
<tr><td><code id="exp_color_fun_+3A_steepness">steepness</code></td>
<td>
<p>The steepness of the exponential function</p>
</td></tr>
<tr><td><code id="exp_color_fun_+3A_num_cols">num_cols</code></td>
<td>
<p>The number of colors to generate in the ramp</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector with x_min:x_max remapped onto an 
exponential curve.
</p>

<hr>
<h2 id='flatten_array'>Drop the 3rd dimension of an array using a summary 
function, e.g., min max, mean</h2><span id='topic+flatten_array'></span>

<h3>Description</h3>

<p>This function takes in a 3D array of values, effects or t_stats, etc.
and returns a 2D matrix in which each entry contains a single value
representing all corresponding entries in the 3rd dimension. This
number is determined by the function specified by the user. It could be min,
max, mean, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flatten_array(arrayX, margin1, margin2, slice_fun)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flatten_array_+3A_arrayx">arrayX</code></td>
<td>
<p>3D array of values, effects or t_stats, etc.</p>
</td></tr>
<tr><td><code id="flatten_array_+3A_margin1">margin1</code></td>
<td>
<p>dimension that will end up as the columns of the final matrix</p>
</td></tr>
<tr><td><code id="flatten_array_+3A_margin2">margin2</code></td>
<td>
<p>dimension that will end up as the rows of the final matrix</p>
</td></tr>
<tr><td><code id="flatten_array_+3A_slice_fun">slice_fun</code></td>
<td>
<p>summary function. The function by which to summarize 
the remaining dimension e.g., <code>function(x) mean(x, na.rm = TRUE)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 2D matrix summarizing the input array
</p>

<hr>
<h2 id='genome_wide_threshold_1D'>Calculate a genome-wide significance threshold for the single-variant scan</h2><span id='topic+genome_wide_threshold_1D'></span>

<h3>Description</h3>

<p>This function uses permutation testing to calculate a genome-wide significance
threshold for the single-variant scan. Two user-defined thresholds are 
calculated: the lower threshold (higher alpha) can be used to determine which 
variants will be used in the pairwise scan. The higher threshold (lower alpha) 
is used to determine which variants are used as covariates in the pairwise scan. 
In each permutation, the phenotype or eigentrait is shuffled and all markers 
are retested with the permuted phenotype. The regression coefficients are 
collected from each permutation and the extreme value distribution is used to 
determine thresholds for the user-defined alpha values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genome_wide_threshold_1D(
  data_obj,
  geno_obj,
  n_perm = 100,
  scan_what = c("eigentraits", "raw_traits"),
  ref_allele = NULL,
  alpha = c(0.01, 0.05),
  model_family,
  run_parallel = FALSE,
  n_cores = 4,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genome_wide_threshold_1D_+3A_data_obj">data_obj</code></td>
<td>
<p>a <code><a href="#topic+Cape">Cape</a></code> object</p>
</td></tr>
<tr><td><code id="genome_wide_threshold_1D_+3A_geno_obj">geno_obj</code></td>
<td>
<p>a genotype object.</p>
</td></tr>
<tr><td><code id="genome_wide_threshold_1D_+3A_n_perm">n_perm</code></td>
<td>
<p>The number of permutations to perform. The default is 100.</p>
</td></tr>
<tr><td><code id="genome_wide_threshold_1D_+3A_scan_what">scan_what</code></td>
<td>
<p>A character value that uniquely specifies whether the 
eigentraits or phenotypes should be scanned. Options are &quot;eigentraits&quot;
or &quot;raw_traits&quot;.</p>
</td></tr>
<tr><td><code id="genome_wide_threshold_1D_+3A_ref_allele">ref_allele</code></td>
<td>
<p><code><a href="#topic+Cape">Cape</a></code> requires that one of the alleles 
in the population be selected as a reference allele. The effects of all 
alleles are then reported as the effects relative to the reference allele. 
In the DO population B represents the C57BL/6J (B6) mouse. Because this strain is 
considered the standard strain, the default reference allele is B. 
If another allele has a positive effect, it means that it increases the given 
phenotype relative to that in the B6 mouse. Any other allele can be selected 
as the reference allele simply by specifying it with this argument.</p>
</td></tr>
<tr><td><code id="genome_wide_threshold_1D_+3A_alpha">alpha</code></td>
<td>
<p>The alpha value(s) used to calculate significance levels. This should
be a vector of any length of numerical values between 0 and 1. The default is
a vector of length two: c(0.01, 0.05).</p>
</td></tr>
<tr><td><code id="genome_wide_threshold_1D_+3A_model_family">model_family</code></td>
<td>
<p>Indicates the model family of the phenotypes. This can be 
either &quot;gaussian&quot; or &quot;binomial&quot;.</p>
</td></tr>
<tr><td><code id="genome_wide_threshold_1D_+3A_run_parallel">run_parallel</code></td>
<td>
<p>A logical value indicating whether the process should
be run in parallel. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="genome_wide_threshold_1D_+3A_n_cores">n_cores</code></td>
<td>
<p>integer number of cores to use if running in parallel</p>
</td></tr>
<tr><td><code id="genome_wide_threshold_1D_+3A_verbose">verbose</code></td>
<td>
<p>A logical value indicating whether to print progress to the screen.
Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector the same length as alpha indicating the
thresholds for each value of alpha.
</p>

<hr>
<h2 id='get_allele_colors'>Get DO colors</h2><span id='topic+get_allele_colors'></span>

<h3>Description</h3>

<p>This function returns the official DO allele colors.
as described here:
<a href="http://www.csbio.unc.edu/CCstatus/index.py?run=AvailableLines.information">http://www.csbio.unc.edu/CCstatus/index.py?run=AvailableLines.information</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_allele_colors(color_scheme = c("DO/CC", "other"), alleles = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_allele_colors_+3A_color_scheme">color_scheme</code></td>
<td>
<p>&quot;DO/CC&quot; or &quot;other&quot; The default is &quot;DO/CC&quot;
If set to &quot;other&quot;, colors unrelated to the DO/CC are used.</p>
</td></tr>
<tr><td><code id="get_allele_colors_+3A_alleles">alleles</code></td>
<td>
<p>an vector af alleles in the set &quot;AJ&quot;, &quot;B6&quot;, &quot;129&quot;, 
&quot;NOD&quot;, &quot;NZO&quot;, &quot;CAST&quot;, &quot;PWK&quot;, &quot;WSB&quot;. This argument can be used to 
retrieve colors only for a subset of alleles.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table with three columns corresponding to strain names,
strain nicknames, and the assigned color values.
</p>

<hr>
<h2 id='get_block_allele'>Get allele assignments for linkage blocks</h2><span id='topic+get_block_allele'></span>

<h3>Description</h3>

<p>This is an internal function used by <code><a href="#topic+plot_full_network">plot_full_network</a></code>
to retrieve the allele names contained in linkage blocks for 
plotting using the appropriate colors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_block_allele(data_obj, block_name, collapsed_net)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_block_allele_+3A_data_obj">data_obj</code></td>
<td>
<p>The cape object</p>
</td></tr>
<tr><td><code id="get_block_allele_+3A_block_name">block_name</code></td>
<td>
<p>The name of the linkage block as defined
by the name of the list called linkage_blocks_full or 
linkage_blocks_collapsed</p>
</td></tr>
<tr><td><code id="get_block_allele_+3A_collapsed_net">collapsed_net</code></td>
<td>
<p>A logical value indicating whether the 
block names to be used are from linkage_blocks_collapsed (TRUE)
or linkage_blocks_full (FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the alleles contained in the linkage block
</p>

<hr>
<h2 id='get_circle'>Generate coordinates for a circle</h2><span id='topic+get_circle'></span>

<h3>Description</h3>

<p>Given x,y coordinates and a radius, this function
generates points on the circumference of the circle.
This function is used by plot_network to plot cape
results in a circular layout.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_circle(radius, center_x = 1, center_y = 1, dens = 5e-04)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_circle_+3A_radius">radius</code></td>
<td>
<p>A numeric value giving the radius of the
circle</p>
</td></tr>
<tr><td><code id="get_circle_+3A_center_x">center_x</code></td>
<td>
<p>The x coordinate for the center of the circle</p>
</td></tr>
<tr><td><code id="get_circle_+3A_center_y">center_y</code></td>
<td>
<p>The y coordinate for the center of the circle</p>
</td></tr>
<tr><td><code id="get_circle_+3A_dens">dens</code></td>
<td>
<p>A numeric value controlling how many points are returned.
Smaller values will return more points along the circumference of the
circle</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list with two elements x and y.
These are the x and y coordinates of the circle. Plotted against
each other they will plot a circle.
</p>

<hr>
<h2 id='get_col_num'>Find column numbers using column names</h2><span id='topic+get_col_num'></span>

<h3>Description</h3>

<p>This is an internal function to find the
column numbers of phenotypes when names
are put in instead of column numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_col_num(data_mat, col_which = NULL, dim_which = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_col_num_+3A_data_mat">data_mat</code></td>
<td>
<p>a matrix with column names</p>
</td></tr>
<tr><td><code id="get_col_num_+3A_col_which">col_which</code></td>
<td>
<p>a character string indicating which column should be identified
If col_which is numeric the number is returned.</p>
</td></tr>
<tr><td><code id="get_col_num_+3A_dim_which">dim_which</code></td>
<td>
<p>A number indicating whether the algorithm should look
in rows (1) or columns (2) for the name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value indicating the column number corresponding
to the name given by col_which. If col_which was a number, col_which
is returned.
</p>

<hr>
<h2 id='get_color'>get a hex color string</h2><span id='topic+get_color'></span>

<h3>Description</h3>

<p>This internal function stores colors for plotting.
Given a color name (&quot;green&quot;, &quot;purple&quot;, &quot;red&quot;, &quot;orange&quot;, 
&quot;blue&quot;, &quot;brown&quot;, &quot;yellow&quot;, &quot;gray&quot;)
and a darkness: &quot;l&quot; for light colors, &quot;d&quot; for dark colors 
and &quot;f&quot; for the full light/dark spectrum
this function returns the corresponding ramp of colors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_color(
  col_name = c("green", "purple", "red", "orange", "blue", "brown", "yellow", "gray"),
  light_dark = c("f", "l", "d")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_color_+3A_col_name">col_name</code></td>
<td>
<p>string color name. Must be one of &quot;green&quot;, 
&quot;purple&quot;, &quot;red&quot;, &quot;orange&quot;, &quot;blue&quot;, &quot;brown&quot;, &quot;yellow&quot;, &quot;gray&quot;</p>
</td></tr>
<tr><td><code id="get_color_+3A_light_dark">light_dark</code></td>
<td>
<p>character value. One of (&quot;f&quot;, &quot;l&quot;, &quot;d&quot;).
&quot;l&quot; indicates light colors, &quot;d&quot; indicates dark colors, and &quot;f&quot;
indicates colors ranging from light to dark.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of length four containing the hex colors 
indicated by the parameters
</p>

<hr>
<h2 id='get_color2'>Generate color ramp</h2><span id='topic+get_color2'></span>

<h3>Description</h3>

<p>This function generates color ramps based on an input
color. The colors will range from two shades lighter
to two shades darker than the original color, based 
on the color gap specified
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_color2(col_name, col_gap = 10, test_plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_color2_+3A_col_name">col_name</code></td>
<td>
<p>A string indicating a color for the ramp</p>
</td></tr>
<tr><td><code id="get_color2_+3A_col_gap">col_gap</code></td>
<td>
<p>A number indicating the size of the gap
between colors</p>
</td></tr>
<tr><td><code id="get_color2_+3A_test_plot">test_plot</code></td>
<td>
<p>Whether to plot colors returned by the function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of colors forming a color ramp based on the 
input name and numeric gap.
</p>

<hr>
<h2 id='get_concent_circ'>Generate list of concentric circles</h2><span id='topic+get_concent_circ'></span>

<h3>Description</h3>

<p>This is an internal function used by <code><a href="#topic+plot_network">plot_network</a></code>
and calling get_circle to generate concentric circles starting
at a specified radius and with a specified gap between them.
These circles are used for plotting traits and chromosomes
in concentric circle plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_concent_circ(list_names, start_rad = 1.05, gap_rad = 0.05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_concent_circ_+3A_list_names">list_names</code></td>
<td>
<p>A character vector indicating labels for each circle
There will be one circle generated for each element in list_names.</p>
</td></tr>
<tr><td><code id="get_concent_circ_+3A_start_rad">start_rad</code></td>
<td>
<p>The radius for the innermost circle.</p>
</td></tr>
<tr><td><code id="get_concent_circ_+3A_gap_rad">gap_rad</code></td>
<td>
<p>The amount of space between each circle.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of x,y coordinates as generated
by the function <code><a href="#topic+get_circle">get_circle</a></code> and named with 
list_names
</p>

<hr>
<h2 id='get_covar'>Get covariate information</h2><span id='topic+get_covar'></span>

<h3>Description</h3>

<p>This function returns information about the covariates
specified for the cape run.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_covar(data_obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_covar_+3A_data_obj">data_obj</code></td>
<td>
<p>a <code><a href="#topic+Cape">Cape</a></code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with the following elements:
covar_names: a character vector holding the names of the covariates  
covar_type: a character vector indicating whether each covariate
derived from the phenotype matrix (&quot;p&quot;) or the genotype matrix (&quot;g&quot;)
covar_loc: A numeric vector indicating the locations of each covariate
covar_table: A matrix holding the individual values for each covariate.
</p>

<hr>
<h2 id='get_eigentraits'>Calculate eigentraits</h2><span id='topic+get_eigentraits'></span>

<h3>Description</h3>

<p>This function uses singular value decomposition
(SVD) to calculate eigentraits from the phenotype 
matrix in the cape data object. It
adds the eigentrait matrix to the data object
along with the singular values and the right
singular vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_eigentraits(data_obj, scale_pheno = TRUE, normalize_pheno = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_eigentraits_+3A_data_obj">data_obj</code></td>
<td>
<p>a <code><a href="#topic+Cape">Cape</a></code> object</p>
</td></tr>
<tr><td><code id="get_eigentraits_+3A_scale_pheno">scale_pheno</code></td>
<td>
<p>A logical value indicating whether to 
mean-center and standardize the traits.</p>
</td></tr>
<tr><td><code id="get_eigentraits_+3A_normalize_pheno">normalize_pheno</code></td>
<td>
<p>A logical value indicating whether to 
rankZ normalize the phenotypes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If scale_pheno is TRUE, the phenotypes are 
mean-centered and standardized before running
the svd.
</p>
<p>Because we use SVD in this step, there can be
no missing values in the phenotype matrix. Any individuals
with missing values are removed with a message.
</p>


<h3>Value</h3>

<p>Returns the data object with the eigentraits,
singular values, and right singular vectors added.
</p>

<hr>
<h2 id='get_geno'>Gets the geno object</h2><span id='topic+get_geno'></span>

<h3>Description</h3>

<p>This is an internal function returns the 
genotype matrix for scanning as defined by 
the markers and individuals specified in
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_geno(data_obj, geno_obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_geno_+3A_data_obj">data_obj</code></td>
<td>
<p>a <code><a href="#topic+Cape">Cape</a></code> object</p>
</td></tr>
<tr><td><code id="get_geno_+3A_geno_obj">geno_obj</code></td>
<td>
<p>a genotype object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the genotype array matching 
the markers and individuals specified in 
data_obj$geno_names
</p>

<hr>
<h2 id='get_geno_dim'>Returns which dimensions the individual, locus, and
alleles are in in the genotype object.</h2><span id='topic+get_geno_dim'></span>

<h3>Description</h3>

<p>This is an internal function that returns the 
locations of genotype dimensions from the genotype
object. It is a relic from when DOQTL put loci in the
second dimension and alleles in the third, while R/qtl2
put loci in the third dimension and alleles in the second.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_geno_dim()
</code></pre>


<h3>Value</h3>

<p>Returns a vector of three named elements identifying
which dimension the individual (mouse), allele, and loci are in.
</p>

<hr>
<h2 id='get_geno_with_covar'>Return the genotype matrix with covariates 
added.</h2><span id='topic+get_geno_with_covar'></span>

<h3>Description</h3>

<p>For pairwise testing, cape appends the covariates
to the genotype matrix. This function performs
that task.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_geno_with_covar(
  data_obj,
  geno_obj = NULL,
  g_covar = TRUE,
  p_covar = TRUE,
  for_pairscan = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_geno_with_covar_+3A_data_obj">data_obj</code></td>
<td>
<p>The cape object. See <code><a href="#topic+Cape">Cape</a></code>.</p>
</td></tr>
<tr><td><code id="get_geno_with_covar_+3A_geno_obj">geno_obj</code></td>
<td>
<p>A genotype object.</p>
</td></tr>
<tr><td><code id="get_geno_with_covar_+3A_g_covar">g_covar</code></td>
<td>
<p>A logical value indicating whether to append
genotype-derived covariates to the final matrix. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="get_geno_with_covar_+3A_p_covar">p_covar</code></td>
<td>
<p>A logical value indicating whether to append
phenotype-derived covariates to the final matrix. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="get_geno_with_covar_+3A_for_pairscan">for_pairscan</code></td>
<td>
<p>If TRUE, the function returns the genotype matrix 
already designated for the pairscan. Otherwise it returns the full
genotype matrix as specified by data_obj$geno_names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a genotype matrix with covariates appended.
</p>

<hr>
<h2 id='get_interaction_error'>Get error bars for interaction plot</h2><span id='topic+get_interaction_error'></span>

<h3>Description</h3>

<p>This function gets error bars for an interaction plot
it takes in the x, y, and trace factor of the interaction
plot and returns a vector indicating how much should
default error type is standard error
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_interaction_error(x, y, trace, error_type = c("sd", "se"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_interaction_error_+3A_x">x</code></td>
<td>
<p>The vector whose levels will form the x axis</p>
</td></tr>
<tr><td><code id="get_interaction_error_+3A_y">y</code></td>
<td>
<p>The vector whose levels will form the y axis, 
the response vector i.e.</p>
</td></tr>
<tr><td><code id="get_interaction_error_+3A_trace">trace</code></td>
<td>
<p>Another vector whose levels will form the traces</p>
</td></tr>
<tr><td><code id="get_interaction_error_+3A_error_type">error_type</code></td>
<td>
<p>Either &quot;sd&quot; for standard deviation, or
&quot;se&quot; for standard error.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list with two elements. The first element
called &quot;means&quot; contains the mean y values for the combinations 
of the x and trace variables. The second element, called &quot;se&quot;
or &quot;sd&quot; depending on error_type contains the errors for the 
same combinations.
</p>

<hr>
<h2 id='get_layout_mat'>Get the best layout matrix for a given number of panes per page.</h2><span id='topic+get_layout_mat'></span>

<h3>Description</h3>

<p>This function is for automatically deciding how to lay out multiple
images per page. It takes as an argument the number of images the user
wants on a single page and returns the most square matrix possible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_layout_mat(num_panes, type = c("landscape", "upright"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_layout_mat_+3A_num_panes">num_panes</code></td>
<td>
<p>The number of images to plot per page.</p>
</td></tr>
<tr><td><code id="get_layout_mat_+3A_type">type</code></td>
<td>
<p>A character vector specifying whether the layout matrix 
should have more columns than rows (&quot;landscape&quot;), or more rows than 
columns (&quot;upright&quot;), if the resulting matrix is not square.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A layout matrix with positions for each element in num_panes
and zeros filling the rest of the rectangle where nothing will be plotted.
</p>

<hr>
<h2 id='get_line'>Get line coordinates</h2><span id='topic+get_line'></span>

<h3>Description</h3>

<p>This function generates points along a line
whose coordinates are user-defined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_line(x0, y0, x1, y1, dens = 5e-04)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_line_+3A_x0">x0</code></td>
<td>
<p>The x coordinate of the starting point
for the line</p>
</td></tr>
<tr><td><code id="get_line_+3A_y0">y0</code></td>
<td>
<p>The y coordinate of the starting point
for the line</p>
</td></tr>
<tr><td><code id="get_line_+3A_x1">x1</code></td>
<td>
<p>The x coordinate of the ending point
for the line</p>
</td></tr>
<tr><td><code id="get_line_+3A_y1">y1</code></td>
<td>
<p>The y coordinate of the ending point
for the line</p>
</td></tr>
<tr><td><code id="get_line_+3A_dens">dens</code></td>
<td>
<p>A numerical value indicating the density
of points to define along the line. Small values lead
to more densely calculated points.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two elements, x and y. These 
elements hold the x and y coordinates respectively 
for drawing the line.
</p>

<hr>
<h2 id='get_linearly_independent'>Check selected markers for linear independence.</h2><span id='topic+get_linearly_independent'></span>

<h3>Description</h3>

<p>This function checks a marker matrix selected by
<code><a href="#topic+select_markers_for_pairscan">select_markers_for_pairscan</a></code> for linear
independence by checking the correlation between
pairs of markers. If any are perfectly correlated,
only one marker from the block of perfect correlation
is kept.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_linearly_independent(data_obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_linearly_independent_+3A_data_obj">data_obj</code></td>
<td>
<p>a <code><a href="#topic+Cape">Cape</a></code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list with two elements.
independent_markers: A matrix of the markers that are 
linearly independent. 
rejected_markers: A vector indicating which markers were
removed for violating linear independence.
</p>

<hr>
<h2 id='get_marker_chr'>Get chromosome numbers for markers</h2><span id='topic+get_marker_chr'></span>

<h3>Description</h3>

<p>Given a vector of marker names or numbers, this 
function returns the chromosome on which each 
marker lives.Covariates are assigned to chromosome 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_marker_chr(data_obj, markers, character_names = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_marker_chr_+3A_data_obj">data_obj</code></td>
<td>
<p>a <code><a href="#topic+Cape">Cape</a></code> object</p>
</td></tr>
<tr><td><code id="get_marker_chr_+3A_markers">markers</code></td>
<td>
<p>A vector of marker names</p>
</td></tr>
<tr><td><code id="get_marker_chr_+3A_character_names">character_names</code></td>
<td>
<p>A logical value indicating whether
the marker names are characters (TRUE) or numbers (FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector the same length as the input markers vector
indicating which chromosome each marker in markers lives on.
</p>

<hr>
<h2 id='get_marker_covar'>Get genotype or covariate values</h2><span id='topic+get_marker_covar'></span>

<h3>Description</h3>

<p>In some cape results plotting functions
either marker genotypes or covariates can
be used for plotting effects on traits. 
However markers and covariates are stored in
different places so it can be annoying to 
retrieve their values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_marker_covar(data_obj, geno_obj, marker_covar_names)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_marker_covar_+3A_data_obj">data_obj</code></td>
<td>
<p>A <code><a href="#topic+Cape">Cape</a></code> object</p>
</td></tr>
<tr><td><code id="get_marker_covar_+3A_geno_obj">geno_obj</code></td>
<td>
<p>A genotype object</p>
</td></tr>
<tr><td><code id="get_marker_covar_+3A_marker_covar_names">marker_covar_names</code></td>
<td>
<p>A vector of strings 
which can contain marker names with alleles appended
or covariate names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function looks both in the genotype
matrix and in covariate tables to find those
values.
</p>


<h3>Value</h3>

<p>This function returns a matrix with individuals
in rows and markers/covariates in columns.
</p>

<hr>
<h2 id='get_marker_idx'>Get original indices for markers</h2><span id='topic+get_marker_idx'></span>

<h3>Description</h3>

<p>Given a vector of marker names or numbers, this 
function returns the indices in the genotype 
matrix for each marker.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_marker_idx(data_obj, markers)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_marker_idx_+3A_data_obj">data_obj</code></td>
<td>
<p>a <code><a href="#topic+Cape">Cape</a></code> object</p>
</td></tr>
<tr><td><code id="get_marker_idx_+3A_markers">markers</code></td>
<td>
<p>A vector of marker names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector the same length as the input markers vector
indicating the index of each marker
</p>

<hr>
<h2 id='get_marker_location'>Get marker genomic position</h2><span id='topic+get_marker_location'></span>

<h3>Description</h3>

<p>Given a vector of marker names or numbers, this 
function returns the genomic coordinates for
each marker, not including the chromosome number,
which is retrieved using <code><a href="#topic+get_marker_chr">get_marker_chr</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_marker_location(data_obj, markers)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_marker_location_+3A_data_obj">data_obj</code></td>
<td>
<p>a <code><a href="#topic+Cape">Cape</a></code> object</p>
</td></tr>
<tr><td><code id="get_marker_location_+3A_markers">markers</code></td>
<td>
<p>A vector of marker names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector the same length as the input markers vector
indicating the genomic coordinate of each marker.
</p>

<hr>
<h2 id='get_marker_name'>Get marker names</h2><span id='topic+get_marker_name'></span>

<h3>Description</h3>

<p>Given a vector of marker numbers, this function 
returns the name of each marker.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_marker_name(data_obj, markers)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_marker_name_+3A_data_obj">data_obj</code></td>
<td>
<p>a <code><a href="#topic+Cape">Cape</a></code> object</p>
</td></tr>
<tr><td><code id="get_marker_name_+3A_markers">markers</code></td>
<td>
<p>A vector of marker numbers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector the same length as the input 
markers vector indicating the name of each marker
</p>

<hr>
<h2 id='get_marker_num'>Get numbers for markers</h2><span id='topic+get_marker_num'></span>

<h3>Description</h3>

<p>Given a vector of marker names or numbers, this 
function returns the numeric index of each marker.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_marker_num(data_obj, markers)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_marker_num_+3A_data_obj">data_obj</code></td>
<td>
<p>a <code><a href="#topic+Cape">Cape</a></code> object</p>
</td></tr>
<tr><td><code id="get_marker_num_+3A_markers">markers</code></td>
<td>
<p>A vector of marker names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector the same length as the input markers vector
indicating the number of each chromosome.
</p>

<hr>
<h2 id='get_network'>Convert the final results to an adjacency 
matrix.</h2><span id='topic+get_network'></span>

<h3>Description</h3>

<p>This function converts the significant cape 
interactions to an adjacency matrix, which 
is then used by <code><a href="#topic+plot_network">plot_network</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_network(
  data_obj,
  geno_obj,
  p_or_q = 0.05,
  min_std_effect = 0,
  standardize = FALSE,
  collapse_linked_markers = TRUE,
  threshold_power = 1,
  verbose = FALSE,
  plot_linkage_blocks = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_network_+3A_data_obj">data_obj</code></td>
<td>
<p>a <code><a href="#topic+Cape">Cape</a></code> object</p>
</td></tr>
<tr><td><code id="get_network_+3A_geno_obj">geno_obj</code></td>
<td>
<p>a genotype object</p>
</td></tr>
<tr><td><code id="get_network_+3A_p_or_q">p_or_q</code></td>
<td>
<p>A threshold indicating the maximum adjusted p value considered 
significant. If an fdr method has been used to correct for multiple testing, 
this value specifies the maximum q value considered significant.</p>
</td></tr>
<tr><td><code id="get_network_+3A_min_std_effect">min_std_effect</code></td>
<td>
<p>This numerical value offers an additional filtering
method. If specified, only interactions with standardized effect sizes greater
then the min_std_effect will be returned.</p>
</td></tr>
<tr><td><code id="get_network_+3A_standardize">standardize</code></td>
<td>
<p>A logical value indicating whether the values returned in
the adjacency matrix should be effect sizes (FALSE) or standardized effect
sizes (TRUE). Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="get_network_+3A_collapse_linked_markers">collapse_linked_markers</code></td>
<td>
<p>A logical value. If TRUE markers are combined 
into linkage blocks based on correlation. If FALSE, each marker is treated as 
an independent observation.</p>
</td></tr>
<tr><td><code id="get_network_+3A_threshold_power">threshold_power</code></td>
<td>
<p>A numerical value indicating the power to which to 
raise the marker correlation matrix. This parameter is used in 
<code><a href="#topic+linkage_blocks_network">linkage_blocks_network</a></code> to determine soft thresholding
in determining linkage block structure. 
Larger values result in more splitting of linkage blocks. Smaller values 
result in less splitting. The default value of 1 uses the unmodified
correlation matrix to determine linkage block structure.</p>
</td></tr>
<tr><td><code id="get_network_+3A_verbose">verbose</code></td>
<td>
<p>A logical value indicating whether to print algorithm progress
to standard out.</p>
</td></tr>
<tr><td><code id="get_network_+3A_plot_linkage_blocks">plot_linkage_blocks</code></td>
<td>
<p>A logical value indicating whether to plot heatmaps
showing the marker correlation structure and where the linkage block boundaries
were drawn.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns the data object with an adjacency matrix defining
the final cape network based on the above parameters. The network is put into 
the slot collapsed_net if collapse_linked_markers is set to TRUE, and full_net
if collapse_linked_markers is set to FALSE. <code><a href="#topic+run_cape">run_cape</a></code> automatically
requests both networks be generated.
</p>

<hr>
<h2 id='get_pairs_for_pairscan'>Select marker pairs for pairscan</h2><span id='topic+get_pairs_for_pairscan'></span>

<h3>Description</h3>

<p>This function selects which marker pairs can be tested in the pair scan.
Even if all markers are linearly independent, some marker pairs may have
insufficient recombination between them to populate all genotype
combinations. Marker pairs for which genotype combinations have insufficient
numbers of individuals are not tested. This function determines which marker
pairs have sufficient representation in all genotype combinations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_pairs_for_pairscan(
  gene,
  covar_names = NULL,
  max_pair_cor = NULL,
  min_per_genotype = NULL,
  run_parallel = FALSE,
  n_cores = 4,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_pairs_for_pairscan_+3A_gene">gene</code></td>
<td>
<p>A two dimensional genotype matrix with rows containing 
individuals and columns containing markers. Each entry is a value between
0 and 1 indicating the genotype of each individual at each marker.</p>
</td></tr>
<tr><td><code id="get_pairs_for_pairscan_+3A_covar_names">covar_names</code></td>
<td>
<p>A character vector indicating which covariates should
be tested.</p>
</td></tr>
<tr><td><code id="get_pairs_for_pairscan_+3A_max_pair_cor">max_pair_cor</code></td>
<td>
<p>A numeric value between 0 and 1 indicating the maximum
Pearson correlation that two markers are allowed. If the correlation
between a pair of markers exceeds this threshold, the pair is not tested.
If this value is set to NULL, min_per_genotype must have a numeric value.</p>
</td></tr>
<tr><td><code id="get_pairs_for_pairscan_+3A_min_per_genotype">min_per_genotype</code></td>
<td>
<p>The minimum number of individuals allowable per 
genotype. If for a given marker pair, one of the genotypes is 
underrepresented, the marker pair is not tested. If this value is NULL,
max_pair_cor must have a numeric value.</p>
</td></tr>
<tr><td><code id="get_pairs_for_pairscan_+3A_run_parallel">run_parallel</code></td>
<td>
<p>A logical value indicating whether multiple 
processors should be used.</p>
</td></tr>
<tr><td><code id="get_pairs_for_pairscan_+3A_n_cores">n_cores</code></td>
<td>
<p>The number of cores to be used if run_parallel is TRUE</p>
</td></tr>
<tr><td><code id="get_pairs_for_pairscan_+3A_verbose">verbose</code></td>
<td>
<p>A logical value. If TRUE, the script prints a message to the
screen to indicate that it is running. If FALSE, no message is printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>One and only one of min_per_genotype or max_pair_cor should be specified.
We recommend that if you have continuous genotype probabilities, you use max_pair_cor.
If both values are specified, this function will preferentially use max_pair_cor.
</p>


<h3>Value</h3>

<p>This function returns a two-column matrix of marker pairs. This
matrix is then used as an argument in <code><a href="#topic+one_pairscan_parallel">one_pairscan_parallel</a></code>, 
<code><a href="#topic+pairscan_null_kin">pairscan_null_kin</a></code>, <code><a href="#topic+pairscan_null">pairscan_null</a></code> and 
<code><a href="#topic+pairscan">pairscan</a></code> to specify which marker pairs should be tested.
</p>

<hr>
<h2 id='get_pheno'>Get the phenotype matrix</h2><span id='topic+get_pheno'></span>

<h3>Description</h3>

<p>This function can return a number of different trait matrices
depending on the arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_pheno(
  data_obj,
  scan_what = c("eigentraits", "normalized_traits", "raw_traits"),
  covar = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_pheno_+3A_data_obj">data_obj</code></td>
<td>
<p>a <code><a href="#topic+Cape">Cape</a></code> object</p>
</td></tr>
<tr><td><code id="get_pheno_+3A_scan_what">scan_what</code></td>
<td>
<p>A character string. One of &quot;eigentraits&quot;, &quot;normalized.trait&quot;,
or &quot;raw_traits.&quot; If &quot;eigentraits&quot; the function returns the eigentraits matrix.
If &quot;normalized_traits&quot; the function returns the trait matrix after mean-centering
and normalizing. If &quot;raw.trait&quot; the function returns the trait matrix before 
mean-centering and normalization were applied.</p>
</td></tr>
<tr><td><code id="get_pheno_+3A_covar">covar</code></td>
<td>
<p>A character value indicating which, if any, covariates the traits
should be adjusted for. If covariates are specified, the function fits a linear
model to specify the traits with the covariates and returns the matrix of residuals
(i.e. the traits after adjusting for the covariates).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix in which each column is a trait, and each row is an individual.
The values correspond to the argument settings described above.
</p>

<hr>
<h2 id='get_stats_multiallele'>Perform linear regression on multi-allele markers.</h2><span id='topic+get_stats_multiallele'></span>

<h3>Description</h3>

<p>This function performs the multi-allele version of 
linear regression. It is used in <code><a href="#topic+singlescan">singlescan</a></code>
and <code><a href="#topic+one_singlescanDO">one_singlescanDO</a></code>. It performs marker-by-marker
linear regressions for each trait and adjusts for covariates.
It collects parameters from the linear models and returns
for downstream use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_stats_multiallele(phenotype, genotype, covar_table, ph_family, ref_col)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_stats_multiallele_+3A_phenotype">phenotype</code></td>
<td>
<p>A phenotype vector</p>
</td></tr>
<tr><td><code id="get_stats_multiallele_+3A_genotype">genotype</code></td>
<td>
<p>genotypes of the marker being tested. 
If this is a vector, it will be converted into a one-column 
matrix. If it is a matrix, each column represents an allele,
and each row represents an individual.</p>
</td></tr>
<tr><td><code id="get_stats_multiallele_+3A_covar_table">covar_table</code></td>
<td>
<p>The covariate matrix, with each covariate
in a column, and each individual in a row.</p>
</td></tr>
<tr><td><code id="get_stats_multiallele_+3A_ph_family">ph_family</code></td>
<td>
<p>a character string for a description of the 
error distribution. Can be either &quot;gaussian&quot; or &quot;binomial&quot;</p>
</td></tr>
<tr><td><code id="get_stats_multiallele_+3A_ref_col">ref_col</code></td>
<td>
<p>The column belonging to the reference allele.
The reference allele is removed from the genotype matrix so
that the matrix is linearly independent. There are only n-1
degrees of freedom in the genotype matrix, where n is the number
of alleles.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with &quot;stats&quot;, &quot;pval&quot;, &quot;score&quot;
stats is a matrix holding the t statistics and slopes (beta coefficients)
from the linear model.
pval holds the p value for the marker overall
and score holds the test statistic for the marker overall.
</p>

<hr>
<h2 id='hist_pheno'>Plot trait histograms</h2><span id='topic+hist_pheno'></span>

<h3>Description</h3>

<p>This function plots histograms of the traits held in 
the pheno slot of the data object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hist_pheno(data_obj, pheno_which = NULL, pheno_labels = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hist_pheno_+3A_data_obj">data_obj</code></td>
<td>
<p>A <code><a href="#topic+Cape">Cape</a></code> object</p>
</td></tr>
<tr><td><code id="hist_pheno_+3A_pheno_which">pheno_which</code></td>
<td>
<p>A vector of strings indicating which 
traits to plot. Defaults to all traits.</p>
</td></tr>
<tr><td><code id="hist_pheno_+3A_pheno_labels">pheno_labels</code></td>
<td>
<p>A vector of strings providing alternate
names for the traits in the plot if the names in the data object
are not good for plotting</p>
</td></tr>
</table>

<hr>
<h2 id='image_with_text'>Plot a heatmap</h2><span id='topic+image_with_text'></span>

<h3>Description</h3>

<p>Plot a heatmap
</p>


<h3>Usage</h3>

<pre><code class='language-R'>image_with_text(
  mat,
  xlab = "",
  ylab = "",
  main = NULL,
  main_shift = 0.12,
  col_names = colnames(mat),
  row_names = rownames(mat),
  row_text_adj = 1,
  row_text_shift = 0,
  row_text_rotation = 0,
  col_text_rotation = 90,
  col_text_adj = 1,
  col_text_shift = 0,
  show_text = TRUE,
  cex = 0.5,
  col_text_cex = 1,
  row_text_cex = 1,
  main_cex = 1,
  split_at_vals = FALSE,
  split_points = 0,
  col_scale = "gray",
  color_spread = 50,
  light_dark = "f",
  class_mat = NULL,
  grad_dir = c("high", "low", "middle", "ends"),
  color_fun = c("linear", "exponential"),
  exp_steepness = 1,
  global_color_scale = FALSE,
  global_min = NULL,
  global_max = NULL,
  sig_digs = 3,
  use_pheatmap_colors = FALSE,
  na_col = "lightgray",
  gridlines = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="image_with_text_+3A_mat">mat</code></td>
<td>
<p>A numeric matrix to plot as a heat map</p>
</td></tr>
<tr><td><code id="image_with_text_+3A_xlab">xlab</code></td>
<td>
<p>A string label for the x axis</p>
</td></tr>
<tr><td><code id="image_with_text_+3A_ylab">ylab</code></td>
<td>
<p>A string label for the y axis</p>
</td></tr>
<tr><td><code id="image_with_text_+3A_main">main</code></td>
<td>
<p>A title for the plot</p>
</td></tr>
<tr><td><code id="image_with_text_+3A_main_shift">main_shift</code></td>
<td>
<p>A numeric value to shift the title
along the y axis.</p>
</td></tr>
<tr><td><code id="image_with_text_+3A_col_names">col_names</code></td>
<td>
<p>A vector of strings indicating names
for the columns of the matrix. Defaults to existing column
names.</p>
</td></tr>
<tr><td><code id="image_with_text_+3A_row_names">row_names</code></td>
<td>
<p>A vector of strings indicating names
for the rows of the matrix. Defaults to existing row
names.</p>
</td></tr>
<tr><td><code id="image_with_text_+3A_row_text_adj">row_text_adj</code></td>
<td>
<p>adjustment value for row text indicating
the centering. See <code><a href="graphics.html#topic+text">text</a></code>.</p>
</td></tr>
<tr><td><code id="image_with_text_+3A_row_text_shift">row_text_shift</code></td>
<td>
<p>numeric value for shifting the row labels
toward or away from the matrix.</p>
</td></tr>
<tr><td><code id="image_with_text_+3A_row_text_rotation">row_text_rotation</code></td>
<td>
<p>Rotation value in degrees for the row labels</p>
</td></tr>
<tr><td><code id="image_with_text_+3A_col_text_rotation">col_text_rotation</code></td>
<td>
<p>Rotation value in degrees for the column labels</p>
</td></tr>
<tr><td><code id="image_with_text_+3A_col_text_adj">col_text_adj</code></td>
<td>
<p>adjustment value for column text indicating
the centering. See <code><a href="graphics.html#topic+text">text</a></code>.</p>
</td></tr>
<tr><td><code id="image_with_text_+3A_col_text_shift">col_text_shift</code></td>
<td>
<p>numeric value for shifting the column labels
toward or away from the matrix.</p>
</td></tr>
<tr><td><code id="image_with_text_+3A_show_text">show_text</code></td>
<td>
<p>Whether to write the numerical value of each cell 
in the plot.</p>
</td></tr>
<tr><td><code id="image_with_text_+3A_cex">cex</code></td>
<td>
<p>The size of the text when show_text is TRUE</p>
</td></tr>
<tr><td><code id="image_with_text_+3A_col_text_cex">col_text_cex</code></td>
<td>
<p>The size of the column labels</p>
</td></tr>
<tr><td><code id="image_with_text_+3A_row_text_cex">row_text_cex</code></td>
<td>
<p>The size of the row labels</p>
</td></tr>
<tr><td><code id="image_with_text_+3A_main_cex">main_cex</code></td>
<td>
<p>The size of the title of the plot</p>
</td></tr>
<tr><td><code id="image_with_text_+3A_split_at_vals">split_at_vals</code></td>
<td>
<p>Whether to split the values into
different color classes</p>
</td></tr>
<tr><td><code id="image_with_text_+3A_split_points">split_points</code></td>
<td>
<p>If split_at_vals is TRUE, split_points
determines the boundaries of the classes. For example, if
split_points is 0, negative and positive numbers will be 
assigned to different color classes.</p>
</td></tr>
<tr><td><code id="image_with_text_+3A_col_scale">col_scale</code></td>
<td>
<p>One of c(&quot;green&quot;, &quot;purple&quot;, &quot;orange&quot;, &quot;blue&quot;, 
&quot;brown&quot;, &quot;gray&quot;) to indicate the color scale to be used. Defaults
to gray.</p>
</td></tr>
<tr><td><code id="image_with_text_+3A_color_spread">color_spread</code></td>
<td>
<p>A numerical value used as input to 
<code><a href="#topic+get_color2">get_color2</a></code> indicating the numeric distance
between colors in a ramp. Smaller values produce a smaller
difference between adjacent colors in the ramp.</p>
</td></tr>
<tr><td><code id="image_with_text_+3A_light_dark">light_dark</code></td>
<td>
<p>One of &quot;l&quot;, &quot;d&quot;, or &quot;f&quot; indicating whether
the colors used should be light (&quot;l&quot;), dark (&quot;d&quot;), or from
across the full spectrum (&quot;f&quot;).</p>
</td></tr>
<tr><td><code id="image_with_text_+3A_class_mat">class_mat</code></td>
<td>
<p>An optional numeric matrix defining the color 
classes of each cell in the matrix. If omitted this is calculated
by the function.</p>
</td></tr>
<tr><td><code id="image_with_text_+3A_grad_dir">grad_dir</code></td>
<td>
<p>A string specifying how the color gradient 
should be applied. If &quot;high&quot; higher values are given darker
colors. If &quot;low&quot;, lower values are given darker colors.
If &quot;middle&quot; values in the middle of the spectrum are 
given darker colors, and if &quot;end&quot; values at the ends
of the spectrum are given darker colors.</p>
</td></tr>
<tr><td><code id="image_with_text_+3A_color_fun">color_fun</code></td>
<td>
<p>Either &quot;linear&quot; or &quot;exponential&quot; indicating
how the colors should transition from light to dark across
values.</p>
</td></tr>
<tr><td><code id="image_with_text_+3A_exp_steepness">exp_steepness</code></td>
<td>
<p>If color_fun is &quot;exponential,&quot; exp_steepness
indicates how quickly the colors should transition from light 
to dark.</p>
</td></tr>
<tr><td><code id="image_with_text_+3A_global_color_scale">global_color_scale</code></td>
<td>
<p>Whether to impose a global minimum
and maximum to the colors, or to use the values themselves to 
determine the top and bottom of the color scale.</p>
</td></tr>
<tr><td><code id="image_with_text_+3A_global_min">global_min</code></td>
<td>
<p>If global_color_scale is TRUE, the minimum
value that should be assigned a color.</p>
</td></tr>
<tr><td><code id="image_with_text_+3A_global_max">global_max</code></td>
<td>
<p>If global_color_scale is TRUE, the maximum
value that should be assigned a color.</p>
</td></tr>
<tr><td><code id="image_with_text_+3A_sig_digs">sig_digs</code></td>
<td>
<p>The number of significant figures to use
from the input matrix. Helpful primarily when show_text is TRUE.</p>
</td></tr>
<tr><td><code id="image_with_text_+3A_use_pheatmap_colors">use_pheatmap_colors</code></td>
<td>
<p>If TRUE, all other color parameters
are ignored, and colors like those used in the R package
pheatmap are used instead.</p>
</td></tr>
<tr><td><code id="image_with_text_+3A_na_col">na_col</code></td>
<td>
<p>The color to use for missing values.</p>
</td></tr>
<tr><td><code id="image_with_text_+3A_gridlines">gridlines</code></td>
<td>
<p>Whether to plot gridlines on the matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='impute_missing_geno'>Impute missing genotype data using k nearest neighbors</h2><span id='topic+impute_missing_geno'></span>

<h3>Description</h3>

<p>This function uses k nearest neighbors to impute missing genotype data
on a per chromosome basis. If missing genotypes remain after imputations
the user can prioritize whether to remove individuals, markers, or whichever
has fewer missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impute_missing_geno(
  data_obj,
  geno_obj = NULL,
  k = 10,
  ind_missing_thresh = 0,
  marker_missing_thresh = 0,
  prioritize = c("fewer", "ind", "marker"),
  max_region_size = NULL,
  min_region_size = NULL,
  run_parallel = FALSE,
  verbose = FALSE,
  n_cores = 2
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="impute_missing_geno_+3A_data_obj">data_obj</code></td>
<td>
<p>a <code><a href="#topic+Cape">Cape</a></code> object</p>
</td></tr>
<tr><td><code id="impute_missing_geno_+3A_geno_obj">geno_obj</code></td>
<td>
<p>a genotype object</p>
</td></tr>
<tr><td><code id="impute_missing_geno_+3A_k">k</code></td>
<td>
<p>The number of nearest neighbors to use to impute missing data. Defaults to 10.</p>
</td></tr>
<tr><td><code id="impute_missing_geno_+3A_ind_missing_thresh">ind_missing_thresh</code></td>
<td>
<p>percent A percentage of acceptable missing data. After imputation
if an individual is missing more data than the percent specified, it will be removed.</p>
</td></tr>
<tr><td><code id="impute_missing_geno_+3A_marker_missing_thresh">marker_missing_thresh</code></td>
<td>
<p>A percentage of acceptable missing data. After imputation
if a marker is missing more data than the percent specified, it will be removed.</p>
</td></tr>
<tr><td><code id="impute_missing_geno_+3A_prioritize">prioritize</code></td>
<td>
<p>How to prioritize removal of rows and columns with missing data.
&quot;ind&quot; = remove individuals with missing data exceeding the threshold before 
considering markers to remove.
&quot;marker&quot; = remove markers with missing data exceeding the threshold before
considering individuals to remove.
&quot;fewer&quot; = Determine how much data will be removed by prioritizing individuals
or markers. Remove data in whichever order removes the least amount of data.</p>
</td></tr>
<tr><td><code id="impute_missing_geno_+3A_max_region_size">max_region_size</code></td>
<td>
<p>maximum number of markers to be used in calculating individual similarity.
Defaults to the minimum chromosome size.</p>
</td></tr>
<tr><td><code id="impute_missing_geno_+3A_min_region_size">min_region_size</code></td>
<td>
<p>minimum number of markers to be used in calculating individual similarity
Defaults to the maximum chromosome size.</p>
</td></tr>
<tr><td><code id="impute_missing_geno_+3A_run_parallel">run_parallel</code></td>
<td>
<p>A logical value indicating whether to run the process in parallel</p>
</td></tr>
<tr><td><code id="impute_missing_geno_+3A_verbose">verbose</code></td>
<td>
<p>A logical value indicating whether to print progress to the screen.</p>
</td></tr>
<tr><td><code id="impute_missing_geno_+3A_n_cores">n_cores</code></td>
<td>
<p>integer number of available CPU cores to use for parallel processing</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is run by <code><a href="#topic+run_cape">run_cape</a></code> and runs automatically if
a kinship correction is specified and there are missing values in the 
genotype object.
</p>
<p>The prioritize parameter can be a bit confusing. If after imputation,
there is one marker for which all data are missing, it makes sense to remove that
one marker rather than all individuals with missing data, since all individuals
would be removed. Similarly, if there is one individual with massive amounts of 
missing data, it makes sense to remove that individual, rather than all markers
that individual is missing. We recommend always using the default &quot;fewer&quot; option 
here unless you know for certain that you want to prioritize individuals or markers 
for removal.
There is no need to specify max_region_size or min_region_size, but advanced
users may want to specify them. There is a trade-off between the time it takes 
to calculate a distance matrix for a large matrix and the time it takes to slide 
through the genome imputing markers. This function does not yet support imputation 
of covariates.
If individuals are genotyped very densely, the user may want to specify max_region_size
to be smaller than the maximum chromosome size to speed calculation of similarity matrices.
</p>


<h3>Value</h3>

<p>This function returns a list that includes both the data_obj and geno_obj
These objects must then be separated again to continue through the cape analysis.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
combined_obj &lt;- impute_missing_geno(data_obj, geno_obj)
new_data_obj &lt;- combined_obj$data_obj
noew_geno_obj &lt;- combined_obj$geno_obj

## End(Not run)

</code></pre>

<hr>
<h2 id='kin_adjust'>Corrects genotypes, phenotypes, and covariates
for kinship.</h2><span id='topic+kin_adjust'></span>

<h3>Description</h3>

<p>This function uses linear mixed models to adjust the
genotype matrix, phenotype matrix, and covariate matrix
for kinship based on the kinship matrix calculated 
by <code><a href="#topic+kinship">kinship</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kin_adjust(
  kin_obj,
  geno,
  chr1 = NULL,
  chr2 = NULL,
  phenoV = NULL,
  covarV = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kin_adjust_+3A_kin_obj">kin_obj</code></td>
<td>
<p>The kinship object calculated by <code><a href="#topic+kinship">kinship</a></code></p>
</td></tr>
<tr><td><code id="kin_adjust_+3A_geno">geno</code></td>
<td>
<p>a genotype object.</p>
</td></tr>
<tr><td><code id="kin_adjust_+3A_chr1">chr1</code></td>
<td>
<p>The first of two chromosomes to leave out of the calculation, if any.</p>
</td></tr>
<tr><td><code id="kin_adjust_+3A_chr2">chr2</code></td>
<td>
<p>The second of two chromosomes to leave out of the calculation, if any.</p>
</td></tr>
<tr><td><code id="kin_adjust_+3A_phenov">phenoV</code></td>
<td>
<p>The phenotype vector</p>
</td></tr>
<tr><td><code id="kin_adjust_+3A_covarv">covarV</code></td>
<td>
<p>The covariate vector or matrix</p>
</td></tr>
<tr><td><code id="kin_adjust_+3A_verbose">verbose</code></td>
<td>
<p>A logical value indicating whether to print progress to the screen</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If using leave-one-chromosome-out (LOCO), chr1 and chr2 should have the same value.
If chr1 and chr2 are different, both specified, leave-two-chromosomes-out (LTCO) will be
used. After testing LTCO, we do not recommend using this method. We instead recommend 
always using the overall kinship correction. In this case, both chr1 and chr2 should
be NULL, their default values.
</p>


<h3>Value</h3>

<p>This function returns a list with the corrected phenotype,
genotypes, and covariates. These are used in <code><a href="#topic+singlescan">singlescan</a></code>
and <code><a href="#topic+pairscan_kin">pairscan_kin</a></code>.
</p>

<hr>
<h2 id='kinship'>Calculate the kinship matrix</h2><span id='topic+kinship'></span>

<h3>Description</h3>

<p>This function produces a realized relationship matrix 
(kinship matrix) for use in adjusting for the effect 
of inbred relatedness. We use the R/qtl2 function
calc_kinship.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kinship(
  data_obj,
  geno_obj,
  type = c("overall"),
  n_cores = 4,
  pop = c("MPP", "2PP", "RIL"),
  results_path = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kinship_+3A_data_obj">data_obj</code></td>
<td>
<p>a <code><a href="#topic+Cape">Cape</a></code> object</p>
</td></tr>
<tr><td><code id="kinship_+3A_geno_obj">geno_obj</code></td>
<td>
<p>a genotype object</p>
</td></tr>
<tr><td><code id="kinship_+3A_type">type</code></td>
<td>
<p>type of  kinship correction. Default is overall.</p>
</td></tr>
<tr><td><code id="kinship_+3A_n_cores">n_cores</code></td>
<td>
<p>The number of cores. Defaults to 4.</p>
</td></tr>
<tr><td><code id="kinship_+3A_pop">pop</code></td>
<td>
<p>population type, &quot;MPP&quot; (multi-parental population), 
&quot;2PP&quot; (2 parents), &quot;RIL&quot; (recombinant inbred line)</p>
</td></tr>
<tr><td><code id="kinship_+3A_results_path">results_path</code></td>
<td>
<p>Optional path to where temporary files will be saved. 
If NULL, the path is taken from data_obj$results_path.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Broman KW, Gatti DM, Simecek P, Furlotte NA, Prins P, 
Sen , Yandell BS, Churchill GA (2018) R/qtl2: software
for mapping quantitative trait loci with high-dimensional 
data and multi-parent populations. Genetics
211:495-502 doi:10.1534/genetics.118.301595
</p>
<p>This uses the function probs_doqtl_to_qtl2 
from qtl2convert:
Karl W Broman (2019). qtl2convert: Convert Data 
among R/qtl2, R/qtl, and DOQTL. 
<a href="https://kbroman.org/qtl2/">https://kbroman.org/qtl2/</a>,
<a href="https://github.com/rqtl/qtl2convert/">https://github.com/rqtl/qtl2convert/</a>.
And genoprob_to_alleleprob from qtl2.
</p>


<h3>Value</h3>

<p>This function returns an n by n matrix, where 
n is the number of individuals in the test population. 
The entries of the matrix represent the level of relatedness
between pairs of individuals. For more information see
Kang, H. M. et al. Efficient control of population 
structure in model organism association mapping. Genetics 
178, 17091723 (2008).
</p>

<hr>
<h2 id='linkage_blocks_network'>Identify linkage blocks</h2><span id='topic+linkage_blocks_network'></span>

<h3>Description</h3>

<p>This function identifies linkage blocks among markers
using pairwise correlation between genotypes. 
The algorithm clusters adjacent, correlated markers
using the fastgreedy community detection algorithm from 
R/igraph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linkage_blocks_network(
  data_obj,
  geno_obj,
  collapse_linked_markers = TRUE,
  threshold_power = 1,
  plot_blocks = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="linkage_blocks_network_+3A_data_obj">data_obj</code></td>
<td>
<p>a <code><a href="#topic+Cape">Cape</a></code> object</p>
</td></tr>
<tr><td><code id="linkage_blocks_network_+3A_geno_obj">geno_obj</code></td>
<td>
<p>a genotype object</p>
</td></tr>
<tr><td><code id="linkage_blocks_network_+3A_collapse_linked_markers">collapse_linked_markers</code></td>
<td>
<p>A logical value. If TRUE markers are combined 
into linkage blocks based on correlation. If FALSE, each marker is treated as 
an independent observation.</p>
</td></tr>
<tr><td><code id="linkage_blocks_network_+3A_threshold_power">threshold_power</code></td>
<td>
<p>A soft threshold power. The marker
correlation matrix is raised to this power to increase or
decrease the number of linkage blocks detected. Increasing 
the power makes more linkage blocks, and decreasing the power
makes fewer linkage blocks. The default power is 1, which uses
the correlation matrix as is.</p>
</td></tr>
<tr><td><code id="linkage_blocks_network_+3A_plot_blocks">plot_blocks</code></td>
<td>
<p>logical. If TRUE, the marker correlation 
matrices are plotted and the boundaries of the blocks are shown.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Csardi G, Nepusz T: The igraph software package for 
complex network research, InterJournal, Complex Systems
1695. 2006. https://igraph.org
</p>
<p>The correlation network can be optionally soft thresholded
to increase or decrease resolution.
</p>


<h3>Value</h3>

<p>The data object is returned with a new list called
linkage_blocks_collapsed if collapse_linked_markers is TRUE 
and linkage_blocks_full if collapse_linked_markers is FALSE
Each element of the list is one linkage block and contains
a vector naming the markers in that block. Blocks are named
with a chromosome number and an index.
</p>

<hr>
<h2 id='load_input_and_run_cape'>Loads input and run CAPE</h2><span id='topic+load_input_and_run_cape'></span>

<h3>Description</h3>

<p>This function loads the input file path and runs cape
It is used to run CAPE from a non R script (python)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_input_and_run_cape(
  input_file = NULL,
  yaml_params = NULL,
  results_path = NULL,
  run_parallel = FALSE,
  results_file = "cross.RDS",
  p_or_q = 0.05,
  n_cores = 4,
  initialize_only = FALSE,
  verbose = TRUE,
  param_file = NULL,
  create_report = FALSE,
  qtl_id_col = NULL,
  qtl_na_strings = "-"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="load_input_and_run_cape_+3A_input_file">input_file</code></td>
<td>
<p>data input to be loaded</p>
</td></tr>
<tr><td><code id="load_input_and_run_cape_+3A_yaml_params">yaml_params</code></td>
<td>
<p>a parameter set up in the form of a YAML string</p>
</td></tr>
<tr><td><code id="load_input_and_run_cape_+3A_results_path">results_path</code></td>
<td>
<p>path to the results</p>
</td></tr>
<tr><td><code id="load_input_and_run_cape_+3A_run_parallel">run_parallel</code></td>
<td>
<p>boolean, if TRUE runs certain parts of the code as parallel blocks</p>
</td></tr>
<tr><td><code id="load_input_and_run_cape_+3A_results_file">results_file</code></td>
<td>
<p>the name of the saved data_obj RDS file. The base name is used as the base name for all saved RDS files.</p>
</td></tr>
<tr><td><code id="load_input_and_run_cape_+3A_p_or_q">p_or_q</code></td>
<td>
<p>A threshold indicating the maximum adjusted p value considered</p>
</td></tr>
<tr><td><code id="load_input_and_run_cape_+3A_n_cores">n_cores</code></td>
<td>
<p>integer, default is 4</p>
</td></tr>
<tr><td><code id="load_input_and_run_cape_+3A_initialize_only">initialize_only</code></td>
<td>
<p>boolean, default: FALSE</p>
</td></tr>
<tr><td><code id="load_input_and_run_cape_+3A_verbose">verbose</code></td>
<td>
<p>boolean, output goes to stdout</p>
</td></tr>
<tr><td><code id="load_input_and_run_cape_+3A_param_file">param_file</code></td>
<td>
<p>path to yml parameter file for running cape</p>
</td></tr>
<tr><td><code id="load_input_and_run_cape_+3A_create_report">create_report</code></td>
<td>
<p>boolean, if true we create the corresponding HTML report page</p>
</td></tr>
<tr><td><code id="load_input_and_run_cape_+3A_qtl_id_col">qtl_id_col</code></td>
<td>
<p>argument for read_population, an optional column number for individual IDs</p>
</td></tr>
<tr><td><code id="load_input_and_run_cape_+3A_qtl_na_strings">qtl_na_strings</code></td>
<td>
<p>argument for read_population, an optional string for missing values</p>
</td></tr>
</table>

<hr>
<h2 id='marker2covar'>Creates a covariate from a genetic marker</h2><span id='topic+marker2covar'></span>

<h3>Description</h3>

<p>Occasionally, researchers may want to condition 
marker effects on another genetic marker. For example,
the HLA locus in humans has very strong effects on 
immune phenotypes, and can swamp smaller effects from
other markers. It can be helpful to condition on markers
in the HLA region to find genetic modifiers of these 
markers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marker2covar(
  data_obj,
  geno_obj,
  singlescan_obj = NULL,
  covar_thresh = NULL,
  markers = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="marker2covar_+3A_data_obj">data_obj</code></td>
<td>
<p>a <code><a href="#topic+Cape">Cape</a></code> object</p>
</td></tr>
<tr><td><code id="marker2covar_+3A_geno_obj">geno_obj</code></td>
<td>
<p>a genotype object</p>
</td></tr>
<tr><td><code id="marker2covar_+3A_singlescan_obj">singlescan_obj</code></td>
<td>
<p>It is possible to automatically identify
markers to use as covariates based on their large main effects.
If this is desired, a singlescan object is required.</p>
</td></tr>
<tr><td><code id="marker2covar_+3A_covar_thresh">covar_thresh</code></td>
<td>
<p>If designating markers as covariates based
on their main effect size is desired, the covar_thresh indicates
the main effect size above which a marker is designated as a 
covariate.</p>
</td></tr>
<tr><td><code id="marker2covar_+3A_markers">markers</code></td>
<td>
<p>Marker covariates can also be designated manually.
markers takes in a vector of marker names or numbers and assigns
the designated markers as covariates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns the data object with additional 
information specifying which markers are to be used as covariates.
this information can be retrieved with <code><a href="#topic+get_covar">get_covar</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_covar">get_covar</a></code>
</p>

<hr>
<h2 id='my_image_plot'>Generate a Heatmap-type image</h2><span id='topic+my_image_plot'></span>

<h3>Description</h3>

<p>This internal function generates heatmap-type
images for functions like <code><a href="#topic+plot_svd">plot_svd</a></code>
<code><a href="#topic+plot_pairscan">plot_pairscan</a></code>, and <code><a href="#topic+plot_variant_influences">plot_variant_influences</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>my_image_plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="my_image_plot_+3A_x">x</code></td>
<td>
<p>Matrix to be plotted</p>
</td></tr>
<tr><td><code id="my_image_plot_+3A_...">...</code></td>
<td>
<p>possible parameters are main, xlab, ylab, mark_coords,
mark_col, show_labels, chromosome_coordinates, chr_names, chr_labels,
show_pheno_labels, extra_col_mat,allele_cols</p>
</td></tr>
</table>

<hr>
<h2 id='norm_pheno'>Mean-center and normalize phenotypes</h2><span id='topic+norm_pheno'></span>

<h3>Description</h3>

<p>This function is a wrapper for mean-centering
normalizing and standardizing the trait matrix.
in a data_obj.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm_pheno(data_obj, mean_center = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="norm_pheno_+3A_data_obj">data_obj</code></td>
<td>
<p>a <code><a href="#topic+Cape">Cape</a></code> object
mean_center a logical value indicating whether the
traits should be mean centered. If FALSE, the traits
are only normalized.</p>
</td></tr>
<tr><td><code id="norm_pheno_+3A_mean_center">mean_center</code></td>
<td>
<p>mean center</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the data object is returned. The pheno slot of
the data object will have normalized and/or mean-centered
traits. The function also preserves the original trait matrix
in a slot called raw_pheno.
</p>

<hr>
<h2 id='one_pairscan_parallel'>This is an internal function to run a single pairscan
It is used both to do the actual pairscan 
(<code><a href="#topic+pairscan_kin">pairscan_kin</a></code> and <code><a href="#topic+pairscan_noKin">pairscan_noKin</a></code>), 
as well as to do the permutations of the pairscan
<code><a href="#topic+pairscan_null">pairscan_null</a></code>).</h2><span id='topic+one_pairscan_parallel'></span>

<h3>Description</h3>

<p>This is an internal function to run a single pairscan
It is used both to do the actual pairscan 
(<code><a href="#topic+pairscan_kin">pairscan_kin</a></code> and <code><a href="#topic+pairscan_noKin">pairscan_noKin</a></code>), 
as well as to do the permutations of the pairscan
<code><a href="#topic+pairscan_null">pairscan_null</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>one_pairscan_parallel(
  data_obj,
  phenotype_vector,
  genotype_matrix,
  int = NULL,
  covar_vector = NULL,
  paired_markers,
  n_perm = 0,
  run_parallel = FALSE,
  verbose = FALSE,
  n_cores = 4
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="one_pairscan_parallel_+3A_data_obj">data_obj</code></td>
<td>
<p>a <code><a href="#topic+Cape">Cape</a></code> object</p>
</td></tr>
<tr><td><code id="one_pairscan_parallel_+3A_phenotype_vector">phenotype_vector</code></td>
<td>
<p>A vector of trait values</p>
</td></tr>
<tr><td><code id="one_pairscan_parallel_+3A_genotype_matrix">genotype_matrix</code></td>
<td>
<p>A matrix of genotypes for markers to
be tested</p>
</td></tr>
<tr><td><code id="one_pairscan_parallel_+3A_int">int</code></td>
<td>
<p>the interaction term added to the linear model
when the kinship correction is being used. This term is
calculated in <code><a href="#topic+pairscan_kin">pairscan_kin</a></code>.</p>
</td></tr>
<tr><td><code id="one_pairscan_parallel_+3A_covar_vector">covar_vector</code></td>
<td>
<p>a vector or matrix of covariates to
be used.</p>
</td></tr>
<tr><td><code id="one_pairscan_parallel_+3A_paired_markers">paired_markers</code></td>
<td>
<p>a two-column matrix indicating which
marker pairs should be tested. The pairs are assigned in
<code><a href="#topic+pairscan">pairscan</a></code> by <code><a href="#topic+get_pairs_for_pairscan">get_pairs_for_pairscan</a></code>.
They are checked for pairwise correlations before being sent
to the pairscan.</p>
</td></tr>
<tr><td><code id="one_pairscan_parallel_+3A_n_perm">n_perm</code></td>
<td>
<p>the number of permutations to be performed.</p>
</td></tr>
<tr><td><code id="one_pairscan_parallel_+3A_run_parallel">run_parallel</code></td>
<td>
<p>a logical value indicating whether to 
use parallel computing</p>
</td></tr>
<tr><td><code id="one_pairscan_parallel_+3A_verbose">verbose</code></td>
<td>
<p>a logical value indicating whether progress should
be printed to the screen.</p>
</td></tr>
<tr><td><code id="one_pairscan_parallel_+3A_n_cores">n_cores</code></td>
<td>
<p>the number of CPUs to use if run_parallel is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list with two slots: 
pairscan_results and pairscan_perm
Each of these elements is also a list containing effect
sizes, standard errors, and covariance matrices for the
pairwise tests.
</p>

<hr>
<h2 id='one_singlescanDO'>Performs marker regression</h2><span id='topic+one_singlescanDO'></span>

<h3>Description</h3>

<p>This is an internal function called by <code><a href="#topic+pairscan_null">pairscan_null</a></code>
when generating the null distribution for significance testing. 
To perform permutations, we permute trait values, and then re-do
the singlescan, marker selection, and the pair scan on the permuted
data. This function performs the singlescan on the permuted data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>one_singlescanDO(
  phenotype_vector,
  genotype_mat,
  model_family,
  ref_allele = "A",
  covar_table = NULL,
  run_parallel = FALSE,
  n_cores = 4
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="one_singlescanDO_+3A_phenotype_vector">phenotype_vector</code></td>
<td>
<p>A vector of phenotype values, one entry for each individual.</p>
</td></tr>
<tr><td><code id="one_singlescanDO_+3A_genotype_mat">genotype_mat</code></td>
<td>
<p>A matrix of genotype values with individuals in rows and markers 
in columns. Matrix entries contain the probability of the reference allele at each 
position for each individual.</p>
</td></tr>
<tr><td><code id="one_singlescanDO_+3A_model_family">model_family</code></td>
<td>
<p>Indicates the model family of the phenotypes. This can be 
either &quot;gaussian&quot; or &quot;binomial&quot;.</p>
</td></tr>
<tr><td><code id="one_singlescanDO_+3A_ref_allele">ref_allele</code></td>
<td>
<p>the reference allele from the Cape data_obj</p>
</td></tr>
<tr><td><code id="one_singlescanDO_+3A_covar_table">covar_table</code></td>
<td>
<p>A matrix of covariates with one row per individual.</p>
</td></tr>
<tr><td><code id="one_singlescanDO_+3A_run_parallel">run_parallel</code></td>
<td>
<p>A logical value indicating whether multiple 
processors should be used</p>
</td></tr>
<tr><td><code id="one_singlescanDO_+3A_n_cores">n_cores</code></td>
<td>
<p>The number of processors to use if run_parallel is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns the t_statistics for all linear models 
testing the effects of each marker on the phenotype.
</p>

<hr>
<h2 id='pair_matrix'>Get all pairs of elements in a vector</h2><span id='topic+pair_matrix'></span>

<h3>Description</h3>

<p>This function makes a matrix with two columns 
listing all pairwise combinations of the elements
of the input vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pair_matrix(elements, ordered = FALSE, self_pairs = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pair_matrix_+3A_elements">elements</code></td>
<td>
<p>a vector containing elements from 
which to draw all possible pairs. Can be numeric or 
strings</p>
</td></tr>
<tr><td><code id="pair_matrix_+3A_ordered">ordered</code></td>
<td>
<p>A logical value indicating whether the order of the
pairs is important. If TRUE both a,b and b,a will be returned.
If FALSE, only a,b will be returned.</p>
</td></tr>
<tr><td><code id="pair_matrix_+3A_self_pairs">self_pairs</code></td>
<td>
<p>A logical value indicating whether self pairs
should be included. If TRUE, a,a will be returned. Otherwise it
will be excluded.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A two-column matrix containing pairs of entries in elements.
</p>

<hr>
<h2 id='pairscan'>This function performs the pairwise scan on all markers.</h2><span id='topic+pairscan'></span>

<h3>Description</h3>

<p>This function performs the pairwise regression on all selected marker pairs.
The phenotypes used can be either eigentraits or raw phenotypes. Permutation
testing is also performed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairscan(
  data_obj,
  geno_obj = NULL,
  scan_what = c("eigentraits", "raw_traits"),
  pairscan_null_size = NULL,
  max_pair_cor = NULL,
  min_per_genotype = NULL,
  kin_obj = NULL,
  num_pairs_limit = 1e+06,
  num_perm_limit = 1e+07,
  overwrite_alert = TRUE,
  run_parallel = FALSE,
  n_cores = 4,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pairscan_+3A_data_obj">data_obj</code></td>
<td>
<p>a <code><a href="#topic+Cape">Cape</a></code> object</p>
</td></tr>
<tr><td><code id="pairscan_+3A_geno_obj">geno_obj</code></td>
<td>
<p>a genotype object</p>
</td></tr>
<tr><td><code id="pairscan_+3A_scan_what">scan_what</code></td>
<td>
<p>A character string uniquely identifying whether eigentraits
or raw traits should be scanned. Options are &quot;eigentraits&quot;, &quot;raw_traits&quot;</p>
</td></tr>
<tr><td><code id="pairscan_+3A_pairscan_null_size">pairscan_null_size</code></td>
<td>
<p>The total size of the null distribution.
This is DIFFERENT than the number of permutations to run. Each permutation
generates n choose 2 elements for the pairscan. So for example, a permutation
that tests 100 pairs of markers will generate a null distribution of size 4950.
This process is repeated until the total null size is reached. If the null size
is set to 5000, two permutations of 100 markers would be done to get to a null
distribution size of 5000.</p>
</td></tr>
<tr><td><code id="pairscan_+3A_max_pair_cor">max_pair_cor</code></td>
<td>
<p>A numeric value between 0 and 1 indicating the maximum
Pearson correlation that two markers are allowed. If the correlation
between a pair of markers exceeds this threshold, the pair is not tested.
If this value is set to NULL, min_per_genotype must have a numeric value.</p>
</td></tr>
<tr><td><code id="pairscan_+3A_min_per_genotype">min_per_genotype</code></td>
<td>
<p>The minimum number of individuals allowable per
genotype combination. If for a given marker pair, one of the genotype combinations is
underrepresented, the marker pair is not tested. If this value is NULL,
max_pair_cor must have a numeric value.</p>
</td></tr>
<tr><td><code id="pairscan_+3A_kin_obj">kin_obj</code></td>
<td>
<p>a kinship object calculated by <code><a href="#topic+kinship">kinship</a></code>.</p>
</td></tr>
<tr><td><code id="pairscan_+3A_num_pairs_limit">num_pairs_limit</code></td>
<td>
<p>A number indicating the maximum number of pairs to
scan. If the number of pairs exceeds this threshold, the function asks for
confirmation before proceeding with the pairwise scan.</p>
</td></tr>
<tr><td><code id="pairscan_+3A_num_perm_limit">num_perm_limit</code></td>
<td>
<p>A number indicating the maximum number of total
permutations that will be performed. If the number of total permutations
exceeds this threshold, the function asks for confirmation before
proceeding with the pairwise scan.</p>
</td></tr>
<tr><td><code id="pairscan_+3A_overwrite_alert">overwrite_alert</code></td>
<td>
<p>If TRUE raises a warning to users not to overwrite 
their data object with a singlescan object. A warning necessary after a 
new version of cape began separating results from different functions into
different results objects</p>
</td></tr>
<tr><td><code id="pairscan_+3A_run_parallel">run_parallel</code></td>
<td>
<p>Whether to run the analysis on parallel CPUs</p>
</td></tr>
<tr><td><code id="pairscan_+3A_n_cores">n_cores</code></td>
<td>
<p>The number of CPUs to use if run_parallel is TRUE</p>
</td></tr>
<tr><td><code id="pairscan_+3A_verbose">verbose</code></td>
<td>
<p>Whether to write progress to the screen</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Not all marker pairs are necessarily tested. Before markers are
tested for interaction, they are checked for several conditions. Pairs are
discarded if (1) at least one of the markers is on the X chromosome, or (2)
there are fewer than min_per_genotype individuals in any of the genotype
combinations.
</p>


<h3>Value</h3>

<p>This function returns an object assigned to pairscan_obj in 
<code><a href="#topic+run_cape">run_cape</a></code>.
</p>
<p>The results object is a list of five elements:
ref_allele: The allele used as the reference for the tests.
max_pair_cor: The maximum pairwise correlation between marker pairs
pairscan_results: A list with one element per trait. The element for
each trait is a list of the following three elements:
pairscan_effects: the effect sizes from the linear models
pairscan_se: the standard errors from the linear models
model_covariance: the model covariance from the linear models.
pairscan_perm: The same structure as pairscan_results, but for the
permuted data.
pairs_tested_perm: A matrix of the marker pairs used in the permutation
tests.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+select_markers_for_pairscan">select_markers_for_pairscan</a></code>, <code><a href="#topic+plot_pairscan">plot_pairscan</a></code>
</p>

<hr>
<h2 id='pairscan_kin'>Run the pairscan with a kinship correction</h2><span id='topic+pairscan_kin'></span>

<h3>Description</h3>

<p>This function is called by <code><a href="#topic+pairscan">pairscan</a></code>
when a kinship correction is requested. It adjusts 
each variable according to the kinship matrix using
<code><a href="#topic+kin_adjust">kin_adjust</a></code> and then fits linear
pairwise models to the adjusted data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairscan_kin(
  data_obj,
  geno_obj,
  scan_what,
  marker_pairs,
  kin_obj,
  verbose = FALSE,
  run_parallel = FALSE,
  n_cores = 2
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pairscan_kin_+3A_data_obj">data_obj</code></td>
<td>
<p>a <code><a href="#topic+Cape">Cape</a></code> object</p>
</td></tr>
<tr><td><code id="pairscan_kin_+3A_geno_obj">geno_obj</code></td>
<td>
<p>a genotype object</p>
</td></tr>
<tr><td><code id="pairscan_kin_+3A_scan_what">scan_what</code></td>
<td>
<p>A character string uniquely identifying whether eigentraits
or raw traits should be scanned. Options are &quot;eigentraits&quot;, &quot;raw_traits&quot;</p>
</td></tr>
<tr><td><code id="pairscan_kin_+3A_marker_pairs">marker_pairs</code></td>
<td>
<p>A two-column matrix containing the marker pairs
to be tested.</p>
</td></tr>
<tr><td><code id="pairscan_kin_+3A_kin_obj">kin_obj</code></td>
<td>
<p>a kinship object</p>
</td></tr>
<tr><td><code id="pairscan_kin_+3A_verbose">verbose</code></td>
<td>
<p>A logical value indicating whether to 
print progress to the screen</p>
</td></tr>
<tr><td><code id="pairscan_kin_+3A_run_parallel">run_parallel</code></td>
<td>
<p>A logical value indicating 
whether parallel processing should be used</p>
</td></tr>
<tr><td><code id="pairscan_kin_+3A_n_cores">n_cores</code></td>
<td>
<p>The number of cores to be used if run_parallel is TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list with three elements. 
The elements contain the marker pair effect sizes, the marker
pair standard errors, and the covariance matrix for each test.
The output is then further processed by <code><a href="#topic+pairscan">pairscan</a></code>.
</p>

<hr>
<h2 id='pairscan_noKin'>Perform pairscan without a kinship correction</h2><span id='topic+pairscan_noKin'></span>

<h3>Description</h3>

<p>This internal function is called by <code><a href="#topic+pairscan">pairscan</a></code>
when no kinship correction is requested. It can be
compared to <code><a href="#topic+pairscan_kin">pairscan_kin</a></code>. 
It fits pairwise linear models to estimate the effects of 
marker pairs on each trait.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairscan_noKin(
  data_obj,
  pheno_mat,
  geno_mat,
  covar_table,
  marker_pairs,
  n_perm,
  verbose = FALSE,
  run_parallel = FALSE,
  n_cores = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pairscan_noKin_+3A_data_obj">data_obj</code></td>
<td>
<p>a <code><a href="#topic+Cape">Cape</a></code> object</p>
</td></tr>
<tr><td><code id="pairscan_noKin_+3A_pheno_mat">pheno_mat</code></td>
<td>
<p>The matrix of trait values with individuals in rows
and traits in columns.</p>
</td></tr>
<tr><td><code id="pairscan_noKin_+3A_geno_mat">geno_mat</code></td>
<td>
<p>The matrix of genotypes to be tested</p>
</td></tr>
<tr><td><code id="pairscan_noKin_+3A_covar_table">covar_table</code></td>
<td>
<p>The matrix of covariates with individuals in rows.</p>
</td></tr>
<tr><td><code id="pairscan_noKin_+3A_marker_pairs">marker_pairs</code></td>
<td>
<p>A two-column matrix containing the marker pairs
to be tested.</p>
</td></tr>
<tr><td><code id="pairscan_noKin_+3A_n_perm">n_perm</code></td>
<td>
<p>The number of permutations to be run</p>
</td></tr>
<tr><td><code id="pairscan_noKin_+3A_verbose">verbose</code></td>
<td>
<p>A logical value indicating whether to 
print progress to the screen</p>
</td></tr>
<tr><td><code id="pairscan_noKin_+3A_run_parallel">run_parallel</code></td>
<td>
<p>A logical value indicating 
whether parallel processing should be used</p>
</td></tr>
<tr><td><code id="pairscan_noKin_+3A_n_cores">n_cores</code></td>
<td>
<p>The number of cores to be used if run_parallel is TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function calls <code><a href="#topic+one_pairscan_parallel">one_pairscan_parallel</a></code> and
returns results for each trait as an element in a list.
</p>

<hr>
<h2 id='pairscan_null'>Generate a null distribution for the pairscan.</h2><span id='topic+pairscan_null'></span>

<h3>Description</h3>

<p>This script generates a null distribution
for the pairscan. For each permutation,
it runs a single scan and selects the top
N markers. It then uses these markers to
perform a permutation of the pairscan.
the null distribution generated here uses
a fixed number of the TOP ranking markers
from the permuted single scan
we need to update it to use select_markers_for_pairscan
if marker_selection_method is netwas, you need to provide
a list of genes from the netWAS analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairscan_null(
  data_obj,
  geno_obj = NULL,
  scan_what = c("eigentraits", "raw_traits"),
  pairscan_null_size = NULL,
  max_pair_cor = NULL,
  min_per_geno = NULL,
  model_family = "gaussian",
  marker_selection_method = c("top_effects", "uniform", "effects_dist", "by_gene"),
  run_parallel = FALSE,
  n_cores = 4,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pairscan_null_+3A_data_obj">data_obj</code></td>
<td>
<p>a <code><a href="#topic+Cape">Cape</a></code> object</p>
</td></tr>
<tr><td><code id="pairscan_null_+3A_geno_obj">geno_obj</code></td>
<td>
<p>a genotype object</p>
</td></tr>
<tr><td><code id="pairscan_null_+3A_scan_what">scan_what</code></td>
<td>
<p>A character string uniquely identifying whether eigentraits
or raw traits should be scanned. Options are &quot;eigentraits&quot;, &quot;raw_traits&quot;</p>
</td></tr>
<tr><td><code id="pairscan_null_+3A_pairscan_null_size">pairscan_null_size</code></td>
<td>
<p>The total size of the null distribution.
This is DIFFERENT than the number of permutations to run. Each permutation
generates n choose 2 elements for the pairscan. So for example, a permutation
that tests 100 pairs of markers will generate a null distribution of size 4950.
This process is repeated until the total null size is reached. If the null size
is set to 5000, two permutations of 100 markers would be done to get to a null
distribution size of 5000.</p>
</td></tr>
<tr><td><code id="pairscan_null_+3A_max_pair_cor">max_pair_cor</code></td>
<td>
<p>A numeric value between 0 and 1 indicating the maximum
Pearson correlation that two markers are allowed. If the correlation
between a pair of markers exceeds this threshold, the pair is not tested.
If this value is set to NULL, min_per_genotype must have a numeric value.</p>
</td></tr>
<tr><td><code id="pairscan_null_+3A_min_per_geno">min_per_geno</code></td>
<td>
<p>The minimum number of individuals allowable per
genotype. If for a given marker pair, one of the genotypes is
underrepresented, the marker pair is not tested. If this value is NULL,
max_pair_cor must have a numeric value.</p>
</td></tr>
<tr><td><code id="pairscan_null_+3A_model_family">model_family</code></td>
<td>
<p>Indicates the model family of the phenotypes. This can be 
either &quot;gaussian&quot; or &quot;binomial&quot;.</p>
</td></tr>
<tr><td><code id="pairscan_null_+3A_marker_selection_method">marker_selection_method</code></td>
<td>
<p>options are &quot;top_effects&quot;, &quot;uniform&quot;, &quot;effects_dist&quot;, &quot;by_gene&quot;</p>
</td></tr>
<tr><td><code id="pairscan_null_+3A_run_parallel">run_parallel</code></td>
<td>
<p>Whether to run the analysis on multiple CPUs</p>
</td></tr>
<tr><td><code id="pairscan_null_+3A_n_cores">n_cores</code></td>
<td>
<p>The number of CPUs to use if run_parallel is TRUE</p>
</td></tr>
<tr><td><code id="pairscan_null_+3A_verbose">verbose</code></td>
<td>
<p>Whether to write progress to the screen</p>
</td></tr>
</table>

<hr>
<h2 id='pairscan_null_kin'>Generates a null distribution for the pairscan</h2><span id='topic+pairscan_null_kin'></span>

<h3>Description</h3>

<p>This function generates a null distribution
for the pairscan. For each permutation,
it runs a single scan and selects markers
in the same manner as for the true test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairscan_null_kin(
  data_obj,
  geno_obj = NULL,
  kin_obj = NULL,
  scan_what = c("eigentraits", "raw_traits"),
  pairscan_null_size = NULL,
  max_pair_cor = NULL,
  min_per_geno = NULL,
  model_family = "gaussian",
  marker_selection_method = c("top_effects", "uniform", "effects_dist", "by_gene"),
  run_parallel = FALSE,
  n_cores = 4,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pairscan_null_kin_+3A_data_obj">data_obj</code></td>
<td>
<p>a <code><a href="#topic+Cape">Cape</a></code> object</p>
</td></tr>
<tr><td><code id="pairscan_null_kin_+3A_geno_obj">geno_obj</code></td>
<td>
<p>a genotype object</p>
</td></tr>
<tr><td><code id="pairscan_null_kin_+3A_kin_obj">kin_obj</code></td>
<td>
<p>a kinship object</p>
</td></tr>
<tr><td><code id="pairscan_null_kin_+3A_scan_what">scan_what</code></td>
<td>
<p>A character string uniquely identifying whether eigentraits
or raw traits should be scanned. Options are &quot;eigentraits&quot;, &quot;raw_traits&quot;</p>
</td></tr>
<tr><td><code id="pairscan_null_kin_+3A_pairscan_null_size">pairscan_null_size</code></td>
<td>
<p>The total size of the null distribution.
This is DIFFERENT than the number of permutations to run. Each permutation
generates n choose 2 elements for the pairscan. So for example, a permutation
that tests 100 pairs of markers will generate a null distribution of size 4950.
This process is repeated until the total null size is reached. If the null size
is set to 5000, two permutations of 100 markers would be done to get to a null
distribution size of 5000.</p>
</td></tr>
<tr><td><code id="pairscan_null_kin_+3A_max_pair_cor">max_pair_cor</code></td>
<td>
<p>A numeric value between 0 and 1 indicating the maximum
Pearson correlation that two markers are allowed. If the correlation
between a pair of markers exceeds this threshold, the pair is not tested.
If this value is set to NULL, min_per_genotype must have a numeric value.</p>
</td></tr>
<tr><td><code id="pairscan_null_kin_+3A_min_per_geno">min_per_geno</code></td>
<td>
<p>The minimum number of individuals allowable per
genotype. If for a given marker pair, one of the genotypes is
underrepresented, the marker pair is not tested. If this value is NULL,
max_pair_cor must have a numeric value.</p>
</td></tr>
<tr><td><code id="pairscan_null_kin_+3A_model_family">model_family</code></td>
<td>
<p>Indicates the model family of the phenotypes. This can be 
either &quot;gaussian&quot; or &quot;binomial&quot;.</p>
</td></tr>
<tr><td><code id="pairscan_null_kin_+3A_marker_selection_method">marker_selection_method</code></td>
<td>
<p>options are &quot;top_effects&quot;, &quot;uniform&quot;, &quot;effects_dist&quot;, &quot;by_gene&quot;</p>
</td></tr>
<tr><td><code id="pairscan_null_kin_+3A_run_parallel">run_parallel</code></td>
<td>
<p>Whether to run the analysis on multiple CPUs.</p>
</td></tr>
<tr><td><code id="pairscan_null_kin_+3A_n_cores">n_cores</code></td>
<td>
<p>The number of CPUs to use if run_parallel is TRUE.</p>
</td></tr>
<tr><td><code id="pairscan_null_kin_+3A_verbose">verbose</code></td>
<td>
<p>Whether to print progress to the screen. Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list with two elements, one containing
the results of the permutations, and the other containing the markers
that were tested in the individual permutations.
</p>

<hr>
<h2 id='pheatmap_generate_breaks'>pheatmap generate breaks found at this link
https://cran.r-project.org/package=pheatmap</h2><span id='topic+pheatmap_generate_breaks'></span>

<h3>Description</h3>

<p>This function is internal to 'pheatmap' and not exported, but 
our code depends on it. We added it here till it becomes exported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pheatmap_generate_breaks(x, n, center = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pheatmap_generate_breaks_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="pheatmap_generate_breaks_+3A_n">n</code></td>
<td>
<p>number of breaks</p>
</td></tr>
<tr><td><code id="pheatmap_generate_breaks_+3A_center">center</code></td>
<td>
<p>logical defaults to False</p>
</td></tr>
</table>

<hr>
<h2 id='pheatmap_scale_colours'>pheatmap scale colours found at this link
https://cran.r-project.org/package=pheatmap</h2><span id='topic+pheatmap_scale_colours'></span>

<h3>Description</h3>

<p>This function is internal to 'pheatmap' and not exported, but 
our code depends on it. We added it here till it becomes exported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pheatmap_scale_colours(mat, col = rainbow(10), breaks = NA, na_col)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pheatmap_scale_colours_+3A_mat">mat</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="pheatmap_scale_colours_+3A_col">col</code></td>
<td>
<p>color palette default set to rainbow(10)</p>
</td></tr>
<tr><td><code id="pheatmap_scale_colours_+3A_breaks">breaks</code></td>
<td>
<p>number of breaks</p>
</td></tr>
<tr><td><code id="pheatmap_scale_colours_+3A_na_col">na_col</code></td>
<td>
<p>color for na values</p>
</td></tr>
</table>

<hr>
<h2 id='pheno2covar'>Create a covariate from a trait</h2><span id='topic+pheno2covar'></span>

<h3>Description</h3>

<p>This function takes a variable from the phenotype matrix
for example, diet treatment or sex and converts it to
a covariate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pheno2covar(data_obj, pheno_which)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pheno2covar_+3A_data_obj">data_obj</code></td>
<td>
<p>a <code><a href="#topic+Cape">Cape</a></code> object</p>
</td></tr>
<tr><td><code id="pheno2covar_+3A_pheno_which">pheno_which</code></td>
<td>
<p>vector of trait names to be used as covariates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the data object with the specified traits removed
from the phenotype matrix and transferred where they will be used
as covariates. Information about assigned covariates can be retrieved
with <code><a href="#topic+get_covar">get_covar</a></code>.
</p>

<hr>
<h2 id='plink2cape'>Convert plink2 files to cape format</h2><span id='topic+plink2cape'></span>

<h3>Description</h3>

<p>Convert plink2 files to cape format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plink2cape(
  ped = "test.ped",
  map = "test.map",
  pheno = "test.pheno",
  out = "out.csv",
  missing_genotype = "0",
  no_fid = FALSE,
  no_parents = FALSE,
  no_sex = FALSE,
  no_pheno = FALSE,
  verbose = FALSE,
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plink2cape_+3A_ped">ped</code></td>
<td>
<p>full path to the ped file</p>
</td></tr>
<tr><td><code id="plink2cape_+3A_map">map</code></td>
<td>
<p>full path to the map file</p>
</td></tr>
<tr><td><code id="plink2cape_+3A_pheno">pheno</code></td>
<td>
<p>full path to the pheno file</p>
</td></tr>
<tr><td><code id="plink2cape_+3A_out">out</code></td>
<td>
<p>full path to the output file</p>
</td></tr>
<tr><td><code id="plink2cape_+3A_missing_genotype">missing_genotype</code></td>
<td>
<p>default is &quot;0&quot;</p>
</td></tr>
<tr><td><code id="plink2cape_+3A_no_fid">no_fid</code></td>
<td>
<p>boolean, default is FALSE</p>
</td></tr>
<tr><td><code id="plink2cape_+3A_no_parents">no_parents</code></td>
<td>
<p>boolean, default is FALSE</p>
</td></tr>
<tr><td><code id="plink2cape_+3A_no_sex">no_sex</code></td>
<td>
<p>boolean, default is FALSE</p>
</td></tr>
<tr><td><code id="plink2cape_+3A_no_pheno">no_pheno</code></td>
<td>
<p>boolean, default is FALSE</p>
</td></tr>
<tr><td><code id="plink2cape_+3A_verbose">verbose</code></td>
<td>
<p>boolean, default is FALSE, gives some happy little progress messages</p>
</td></tr>
<tr><td><code id="plink2cape_+3A_overwrite">overwrite</code></td>
<td>
<p>boolean, default is FALSE, will only remove the existing file if this is set to TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For further information about PLINK and its file formats,
see <a href="https://zzz.bwh.harvard.edu/plink/">https://zzz.bwh.harvard.edu/plink/</a>
</p>


<h3>Value</h3>

<p>A list with two elements: data_obj and geno_obj
These objects are formatted for use in cape and must then
be separated to use in <code><a href="#topic+run_cape">run_cape</a></code>.
</p>


<h3>References</h3>

<p>Purcell S, Neale B, Todd-Brown K, Thomas L, Ferreira MAR, 
Bender D, Maller J, Sklar P, de Bakker PIW, Daly MJ &amp; Sham PC (2007) 
PLINK: a toolset for whole-genome association and population-based 
linkage analysis. American Journal of Human Genetics, 81.
</p>

<hr>
<h2 id='plot_bars'>Plot phenotypic effect for two markers as a bar plot</h2><span id='topic+plot_bars'></span>

<h3>Description</h3>

<p>This internal function is called by 
<code><a href="#topic+plot_effects">plot_effects</a></code> to generate a 
bar plot showing mean trait values for all
combinations of genotypes for two markers.
This function also indicates the predicted
additive effects of the two markers with 
a dashed line, as well as the error of the
predicted additive effect with an orange box.
The true effect of the marker combination is
shown with a gray bar. 
The effects can centered on the reference
allele to better show relative effects of 
each allele and allele combination.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_bars(
  phenoV,
  marker1_vals,
  marker2_vals,
  pheno_name,
  marker1_label,
  marker2_label,
  ymin = NULL,
  ymax = NULL,
  error_bars,
  ref_centered
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_bars_+3A_phenov">phenoV</code></td>
<td>
<p>A vector of trait values</p>
</td></tr>
<tr><td><code id="plot_bars_+3A_marker1_vals">marker1_vals</code></td>
<td>
<p>A vector of genotype values 
for marker1</p>
</td></tr>
<tr><td><code id="plot_bars_+3A_marker2_vals">marker2_vals</code></td>
<td>
<p>A vector of genotype values
for marker2.</p>
</td></tr>
<tr><td><code id="plot_bars_+3A_pheno_name">pheno_name</code></td>
<td>
<p>A string indicating the name of
the trait being plotted.</p>
</td></tr>
<tr><td><code id="plot_bars_+3A_marker1_label">marker1_label</code></td>
<td>
<p>A string indicating the name
of marker1</p>
</td></tr>
<tr><td><code id="plot_bars_+3A_marker2_label">marker2_label</code></td>
<td>
<p>A string indicating the name
of marker2</p>
</td></tr>
<tr><td><code id="plot_bars_+3A_ymin">ymin</code></td>
<td>
<p>A numeric value indicating the minimum 
y value for the plot. If NULL, it will be calculated
based on phenoV and error bars.</p>
</td></tr>
<tr><td><code id="plot_bars_+3A_ymax">ymax</code></td>
<td>
<p>A numeric value indicating the maximum
y value for the plot. If NULL, it will be calculated
based on phenoV and error bars.</p>
</td></tr>
<tr><td><code id="plot_bars_+3A_error_bars">error_bars</code></td>
<td>
<p>A string indicating the type of error
bars to draw. Can be &quot;sd&quot; for standard deviation, &quot;se&quot;
for standard error, or &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="plot_bars_+3A_ref_centered">ref_centered</code></td>
<td>
<p>Whether to center the effects
on the reference genotype.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='plot_effects'>Plot Interaction Effects</h2><span id='topic+plot_effects'></span>

<h3>Description</h3>

<p>This function plots phenotypic effects of 
individual cape interactions. It serves as
a wrapper for the functions <code><a href="#topic+plot_lines">plot_lines</a></code>
<code><a href="#topic+plot_bars">plot_bars</a></code> <code><a href="#topic+plot_points">plot_points</a></code>,
and <code><a href="#topic+plot_int_heat">plot_int_heat</a></code>. Each of those functions
plots individual cape interactions in different forms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_effects(
  data_obj,
  geno_obj,
  marker1,
  marker2 = NULL,
  pheno_type = "normalized",
  plot_type = c("l", "p", "b", "h"),
  error_bars = "none",
  ymin = NULL,
  ymax = NULL,
  covar = NULL,
  marker1_label = NULL,
  marker2_label = NULL,
  bin_continuous_genotypes = TRUE,
  ref_centered = TRUE,
  gen_model1 = "Additive",
  gen_model2 = "Additive",
  bins_marker1 = 50,
  bins_marker2 = 50
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_effects_+3A_data_obj">data_obj</code></td>
<td>
<p>A <code><a href="#topic+Cape">Cape</a></code> object</p>
</td></tr>
<tr><td><code id="plot_effects_+3A_geno_obj">geno_obj</code></td>
<td>
<p>A genotype object</p>
</td></tr>
<tr><td><code id="plot_effects_+3A_marker1">marker1</code></td>
<td>
<p>A string indicating the name 
of the source marker in the interaction. This can
also be the name of a covariate.</p>
</td></tr>
<tr><td><code id="plot_effects_+3A_marker2">marker2</code></td>
<td>
<p>Another string indicating the name 
of the source marker in the interaction. This can
also be the name of a covariate. Optional.</p>
</td></tr>
<tr><td><code id="plot_effects_+3A_pheno_type">pheno_type</code></td>
<td>
<p>One of &quot;eigentraits&quot;, 
&quot;normalized_traits&quot;, or &quot;raw_traits&quot;, indicating which
traits to plot.</p>
</td></tr>
<tr><td><code id="plot_effects_+3A_plot_type">plot_type</code></td>
<td>
<p>A letter referring to the desired style 
of the plot. The choices are the following: &quot;l&quot; - line plots,
&quot;p&quot; = points, &quot;b&quot; - bar plots, &quot;h&quot; - heat map.</p>
</td></tr>
<tr><td><code id="plot_effects_+3A_error_bars">error_bars</code></td>
<td>
<p>The type of error bars to plot. Choices
are &quot;none&quot; (the default), &quot;se&quot; for standard error, or 
&quot;sd&quot; for standard deviation.</p>
</td></tr>
<tr><td><code id="plot_effects_+3A_ymin">ymin</code></td>
<td>
<p>A minimum value for the y axes across all plots.
If NULL, each y axis will be determined independently</p>
</td></tr>
<tr><td><code id="plot_effects_+3A_ymax">ymax</code></td>
<td>
<p>A maximum value for the y axes across all plots.
If NULL, each y axis will be dertermined independently</p>
</td></tr>
<tr><td><code id="plot_effects_+3A_covar">covar</code></td>
<td>
<p>A vector of strings indicating which covariates,
if any, the traits should be adjusted for. If NULL, the 
covariates specified in the data_obj are used as default.
To prevent adjusting for covariates, use &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="plot_effects_+3A_marker1_label">marker1_label</code></td>
<td>
<p>A string to use as the label for marker1
If NULL, the string used for marker1 will be used.</p>
</td></tr>
<tr><td><code id="plot_effects_+3A_marker2_label">marker2_label</code></td>
<td>
<p>A string to use as the label for marker2
If NULL, the string used for marker2 will be used.</p>
</td></tr>
<tr><td><code id="plot_effects_+3A_bin_continuous_genotypes">bin_continuous_genotypes</code></td>
<td>
<p>If TRUE, genotypes (and covariate)
values will be binned into 0, 0.5, and 1 values. This 
reduces the number of bins that traits need to be divided 
into, especially if there are only one or two individuals
with a 0.49 genotype, for example. Binning may not be
desirable when using the heatmap.</p>
</td></tr>
<tr><td><code id="plot_effects_+3A_ref_centered">ref_centered</code></td>
<td>
<p>A logical value indicating whether 
to center the values on the reference allele. Defaults 
to TRUE.</p>
</td></tr>
<tr><td><code id="plot_effects_+3A_gen_model1">gen_model1</code></td>
<td>
<p>One of &quot;Additive&quot;, &quot;Dominant&quot;, or &quot;Recessive&quot;
indicating how the genotype should be coded for the first 
marker. If Additive,
genotypes are coded as 0 for homozygous reference allele,
1 for homozygous alternate allele, and 0.5 for heterozygous.
If Dominant, any allele probability greater than 0.5 is 
set to 1. If recessive, any allele probability less than
or equal to 0.5 is set to 0. In other words, for the 
dominant coding, heterozygotes are grouped with the 
homozygous alternate genotypes: 0 vs. (0.5,1). This shows
the effect of having any dose of the alternate allele. With
a recessive coding, heterozygotes are grouped with the
homozygous reference genotypes: (0, 0.5) vs. 1. This shows
the effect of having two copies of the alternate allele 
vs. having fewer than two copies.</p>
</td></tr>
<tr><td><code id="plot_effects_+3A_gen_model2">gen_model2</code></td>
<td>
<p>The same as gen_model1, but for the second 
marker.</p>
</td></tr>
<tr><td><code id="plot_effects_+3A_bins_marker1">bins_marker1</code></td>
<td>
<p>Only used for heatmap plotting. The 
number of bins for marker1 if it is a continuously valued 
marker or covariate. The bins are used to fit a linear 
model and predict outcomes for a 2D grid of marker1 and
marker2 values. This argument can also be a vector of
bin values for binning at specific values.</p>
</td></tr>
<tr><td><code id="plot_effects_+3A_bins_marker2">bins_marker2</code></td>
<td>
<p>The same as bins_marker1, but for
marker2.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &quot;h&quot; option calls <code><a href="#topic+plot_int_heat">plot_int_heat</a></code>, which
fits linear models to each trait and both markers specified.
It uses those models to predict phenotype values along continuously
valued genotype bins and plots the predicted values as a heatmap.
</p>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='plot_full_network'>Plot the final epistatic network in a traditional network view.</h2><span id='topic+plot_full_network'></span>

<h3>Description</h3>

<p>This function plots the final results in a layout different to
both <code><a href="#topic+plot_variant_influences">plot_variant_influences</a></code> and <code><a href="#topic+plot_network">plot_network</a></code>. 
In this view, the network is plotted with a traditional network layout. 
The genomic position information in <code><a href="#topic+plot_network">plot_network</a></code> is lost, but 
in this view it is easier to see the structure of the overall network 
in terms of hubs and peripheral nodes. In this view, each node is plotted 
as a pie-chart, and the main effects of the node are indicated as 
positive, negative, or not-significant (gray). Significant 
interactions are shown arrows between 
nodes and colored based on whether they are positive or negative interactions. 
Colors for positive and negative main effects and interactions are specified
in the arguments. The function <code><a href="#topic+get_network">get_network</a></code> must be run before plotting 
the network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_full_network(
  data_obj,
  p_or_q = 0.05,
  collapsed_net = TRUE,
  main = NULL,
  color_scheme = c("DO/CC", "other"),
  pos_col = "brown",
  neg_col = "blue",
  bg_col = "gray",
  light_dark = "f",
  node_border_lwd = 1,
  layout_matrix = NULL,
  zoom = 1,
  xshift = 0,
  yshift = 0,
  node_radius = 1,
  label_nodes = TRUE,
  label_offset = 0,
  label_cex = 1,
  legend_radius = 1,
  legend_cex = 1,
  legend_position = "topleft",
  arrow_offset = node_radius,
  arrow_length = 0.2,
  edge_lwd = 2
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_full_network_+3A_data_obj">data_obj</code></td>
<td>
<p>A <code><a href="#topic+Cape">Cape</a></code> object</p>
</td></tr>
<tr><td><code id="plot_full_network_+3A_p_or_q">p_or_q</code></td>
<td>
<p>The maximum p value (or q value if FDR was used) for significant 
main effects and interactions.</p>
</td></tr>
<tr><td><code id="plot_full_network_+3A_collapsed_net">collapsed_net</code></td>
<td>
<p>A logical value indicating whether to show the network
condensed into linkage blocks (TRUE) or each individual marker (FALSE)</p>
</td></tr>
<tr><td><code id="plot_full_network_+3A_main">main</code></td>
<td>
<p>A title for the plot</p>
</td></tr>
<tr><td><code id="plot_full_network_+3A_color_scheme">color_scheme</code></td>
<td>
<p>either &quot;DO/CC&quot; or &quot;other&quot;. &quot;DO/CC&quot; uses the official &quot;DO/CC&quot;
colors for the DO/CC alleles  
<a href="http://www.csbio.unc.edu/CCstatus/index.py?run=AvailableLines.information">http://www.csbio.unc.edu/CCstatus/index.py?run=AvailableLines.information</a>
&quot;other&quot; uses an unrelated color palette for multiple alleles.</p>
</td></tr>
<tr><td><code id="plot_full_network_+3A_pos_col">pos_col</code></td>
<td>
<p>The color to use for positive main effects and interactions
must be one of &quot;green&quot;, &quot;purple&quot;, &quot;red&quot;, &quot;orange&quot;, &quot;blue&quot;, &quot;brown&quot;, &quot;yellow&quot;, &quot;gray&quot;
see <code><a href="#topic+get_color">get_color</a></code></p>
</td></tr>
<tr><td><code id="plot_full_network_+3A_neg_col">neg_col</code></td>
<td>
<p>The color to use for negative main effects and interactions
takes the same values as pos_col.</p>
</td></tr>
<tr><td><code id="plot_full_network_+3A_bg_col">bg_col</code></td>
<td>
<p>The color to be used in pie charts for non-significant main effects.
Takes the same values as pos_col</p>
</td></tr>
<tr><td><code id="plot_full_network_+3A_light_dark">light_dark</code></td>
<td>
<p>Indicates whether pos_col, neg_col, and bg_col should be selected
from light colors (&quot;l&quot;), dark colors (&quot;d&quot;) or the full spectrum from light to dark (&quot;f&quot;)</p>
</td></tr>
<tr><td><code id="plot_full_network_+3A_node_border_lwd">node_border_lwd</code></td>
<td>
<p>The thickness of the lines around the pie charts</p>
</td></tr>
<tr><td><code id="plot_full_network_+3A_layout_matrix">layout_matrix</code></td>
<td>
<p>Users have the option of providing their own layout matrix for the
network. This should be a two column matrix indicating the x and y coordinates of each 
node in the network.</p>
</td></tr>
<tr><td><code id="plot_full_network_+3A_zoom">zoom</code></td>
<td>
<p>Allows the user to zoom in and out on the image if the network is either 
running off the edges of the plot or too small in the middle of the plot.</p>
</td></tr>
<tr><td><code id="plot_full_network_+3A_xshift">xshift</code></td>
<td>
<p>A constant by which to shift the x values of all nodes in the network.</p>
</td></tr>
<tr><td><code id="plot_full_network_+3A_yshift">yshift</code></td>
<td>
<p>A constant by which to shift the y values of all nodes in the network.</p>
</td></tr>
<tr><td><code id="plot_full_network_+3A_node_radius">node_radius</code></td>
<td>
<p>The size of the pie chart for each node.</p>
</td></tr>
<tr><td><code id="plot_full_network_+3A_label_nodes">label_nodes</code></td>
<td>
<p>A logical value indicating whether the nodes should be labeled.
Users may want to remove labels for large networks.</p>
</td></tr>
<tr><td><code id="plot_full_network_+3A_label_offset">label_offset</code></td>
<td>
<p>The amount by which to offset the node labels from the center of
the nodes.</p>
</td></tr>
<tr><td><code id="plot_full_network_+3A_label_cex">label_cex</code></td>
<td>
<p>The size of the node labels</p>
</td></tr>
<tr><td><code id="plot_full_network_+3A_legend_radius">legend_radius</code></td>
<td>
<p>The size of the legend indicating which pie piece corresponds to which
traits.</p>
</td></tr>
<tr><td><code id="plot_full_network_+3A_legend_cex">legend_cex</code></td>
<td>
<p>The size of the labels in the legend.</p>
</td></tr>
<tr><td><code id="plot_full_network_+3A_legend_position">legend_position</code></td>
<td>
<p>The position of the legend on the plot</p>
</td></tr>
<tr><td><code id="plot_full_network_+3A_arrow_offset">arrow_offset</code></td>
<td>
<p>The distance from the center of the node to the arrow head.</p>
</td></tr>
<tr><td><code id="plot_full_network_+3A_arrow_length">arrow_length</code></td>
<td>
<p>The length of the head of the arrow</p>
</td></tr>
<tr><td><code id="plot_full_network_+3A_edge_lwd">edge_lwd</code></td>
<td>
<p>The thickness of the arrows showing the interactions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For most networks, the default options will be fine, but there is a lot of room
for modification if changes are desired
</p>


<h3>Value</h3>

<p>This function invisibly returns a list of length two. The first element
contains the igraph network object. The second contains the layout matrix for the
network. This can be passed in as an argument (&quot;layout_matrix&quot;) which provides more
control to the user in the layout. Other network layouts from igraph can also be passed 
in here.
</p>


<h3>References</h3>

<p>Csardi G, Nepusz T: The igraph software package for complex network 
research, InterJournal, Complex Systems 1695. 2006. <a href="https://igraph.org/">https://igraph.org/</a>
</p>

<hr>
<h2 id='plot_int_heat'>Plot phenotypic effects for two markers as a heat map</h2><span id='topic+plot_int_heat'></span>

<h3>Description</h3>

<p>This internal function is called by 
<code><a href="#topic+plot_effects">plot_effects</a></code> to generate a 
heat map showing the effects of genotype on
phenotype. This function fits linear models
to the markers and traits. It then uses
these models to predict trait values at 
different genotype combinations in a 2D 
grid. It plots these predicted values in
a heat map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_int_heat(
  phenoV,
  marker1_vals,
  marker2_vals,
  pheno_name = NULL,
  marker1_label = NULL,
  marker2_label = NULL,
  bins1 = 50,
  bins2 = 50
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_int_heat_+3A_phenov">phenoV</code></td>
<td>
<p>A vector of trait values</p>
</td></tr>
<tr><td><code id="plot_int_heat_+3A_marker1_vals">marker1_vals</code></td>
<td>
<p>A vector of genotype values 
for marker1</p>
</td></tr>
<tr><td><code id="plot_int_heat_+3A_marker2_vals">marker2_vals</code></td>
<td>
<p>A vector of genotype values
for marker2.</p>
</td></tr>
<tr><td><code id="plot_int_heat_+3A_pheno_name">pheno_name</code></td>
<td>
<p>A string indicating the name of
the trait being plotted.</p>
</td></tr>
<tr><td><code id="plot_int_heat_+3A_marker1_label">marker1_label</code></td>
<td>
<p>A string indicating the name
of marker1</p>
</td></tr>
<tr><td><code id="plot_int_heat_+3A_marker2_label">marker2_label</code></td>
<td>
<p>A string indicating the name
of marker2</p>
</td></tr>
<tr><td><code id="plot_int_heat_+3A_bins1">bins1</code></td>
<td>
<p>The number of bins for marker1 over 
which to predict values of the trait. This can also 
be a vector specifying those bins.</p>
</td></tr>
<tr><td><code id="plot_int_heat_+3A_bins2">bins2</code></td>
<td>
<p>The number of bins for marker2 over 
which to predict values of the trait. This can also 
be a vector specifying those bins.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='plot_lines'>Plot interaction plot for traits and genetic markers</h2><span id='topic+plot_lines'></span>

<h3>Description</h3>

<p>This internal function is called by plot.effects
to generate an interaction plot for two markers
relating to a trait. If marker2_vals is NULL,
the function instead shows the main effect for
marker1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_lines(
  phenoV,
  marker1_vals,
  marker2_vals = NULL,
  pheno_name,
  marker1_label,
  marker2_label,
  ymin = NULL,
  ymax = NULL,
  error_bars
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_lines_+3A_phenov">phenoV</code></td>
<td>
<p>A vector of trait values</p>
</td></tr>
<tr><td><code id="plot_lines_+3A_marker1_vals">marker1_vals</code></td>
<td>
<p>A vector of genotype values 
for marker1</p>
</td></tr>
<tr><td><code id="plot_lines_+3A_marker2_vals">marker2_vals</code></td>
<td>
<p>A vector of genotype values
for marker2.</p>
</td></tr>
<tr><td><code id="plot_lines_+3A_pheno_name">pheno_name</code></td>
<td>
<p>A string indicating the name of
the trait being plotted.</p>
</td></tr>
<tr><td><code id="plot_lines_+3A_marker1_label">marker1_label</code></td>
<td>
<p>A string indicating the name
of marker1</p>
</td></tr>
<tr><td><code id="plot_lines_+3A_marker2_label">marker2_label</code></td>
<td>
<p>A string indicating the name
of marker2</p>
</td></tr>
<tr><td><code id="plot_lines_+3A_ymin">ymin</code></td>
<td>
<p>A numeric value indicating the minimum 
y value for the plot. If NULL, it will be calculated
based on phenoV and error bars.</p>
</td></tr>
<tr><td><code id="plot_lines_+3A_ymax">ymax</code></td>
<td>
<p>A numeric value indicating the maximum
y value for the plot. If NULL, it will be calculated
based on phenoV and error bars.</p>
</td></tr>
<tr><td><code id="plot_lines_+3A_error_bars">error_bars</code></td>
<td>
<p>A string indicating the type of error
bars to draw. Can be &quot;sd&quot; for standard deviation, &quot;se&quot;
for standard error, or &quot;none&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='plot_network'>Plots cape results as a circular network</h2><span id='topic+plot_network'></span>

<h3>Description</h3>

<p>This script plots cape results in a circular network.
The chromosomes are arranged in a circle. Main effects
are shown in concentric circles around the chromosomes,
with each trait in its own circle. Main effects can 
either be colored as negative or positive, or with parental
allele colors for multi-parent populations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_network(
  data_obj,
  marker_pairs = NULL,
  collapsed_net = TRUE,
  trait = NULL,
  trait_labels = NULL,
  color_scheme = c("DO/CC", "other"),
  main_lwd = 4,
  inter_lwd = 3,
  label_cex = 1.5,
  percent_bend = 15,
  chr_gap = 1,
  label_gap = 5,
  positive_col = "brown",
  negative_col = "blue",
  show_alleles = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_network_+3A_data_obj">data_obj</code></td>
<td>
<p>a <code><a href="#topic+Cape">Cape</a></code> object</p>
</td></tr>
<tr><td><code id="plot_network_+3A_marker_pairs">marker_pairs</code></td>
<td>
<p>a two-column matrix identifying which marker pairs should be plotted.
This is particularly useful if the network is very dense. The default value, NULL, plots
all marker pairs.</p>
</td></tr>
<tr><td><code id="plot_network_+3A_collapsed_net">collapsed_net</code></td>
<td>
<p>A logical value indicating whether to plot all individual SNPs
or linkage blocks calculated by <code><a href="#topic+linkage_blocks_network">linkage_blocks_network</a></code>.</p>
</td></tr>
<tr><td><code id="plot_network_+3A_trait">trait</code></td>
<td>
<p>A character vector indicating which traits to plot. The default NULL
value plots all traits.</p>
</td></tr>
<tr><td><code id="plot_network_+3A_trait_labels">trait_labels</code></td>
<td>
<p>A character vector indicating the names of the traits in case
the names from the data object are not great for plotting.</p>
</td></tr>
<tr><td><code id="plot_network_+3A_color_scheme">color_scheme</code></td>
<td>
<p>A character value of either &quot;DO/CC&quot; or other indicating the 
color scheme of main effects. If &quot;DO/CC&quot; allele effects can be plotted with the
DO/CC colors.</p>
</td></tr>
<tr><td><code id="plot_network_+3A_main_lwd">main_lwd</code></td>
<td>
<p>A numeric value indicating the line width for the main effect lines</p>
</td></tr>
<tr><td><code id="plot_network_+3A_inter_lwd">inter_lwd</code></td>
<td>
<p>A numeric value indicating the line width for the interaction lines</p>
</td></tr>
<tr><td><code id="plot_network_+3A_label_cex">label_cex</code></td>
<td>
<p>A numeric value indicating the size of the labels</p>
</td></tr>
<tr><td><code id="plot_network_+3A_percent_bend">percent_bend</code></td>
<td>
<p>A numeric value indicating the amount that the arrows for the
interaction effects should be bent. A value of 0 will plot straight lines.</p>
</td></tr>
<tr><td><code id="plot_network_+3A_chr_gap">chr_gap</code></td>
<td>
<p>A numeric value indicating the size of the gap plotted between chromosomes.</p>
</td></tr>
<tr><td><code id="plot_network_+3A_label_gap">label_gap</code></td>
<td>
<p>A numeric value indicating the size of the gap the chromosomes and their labels.</p>
</td></tr>
<tr><td><code id="plot_network_+3A_positive_col">positive_col</code></td>
<td>
<p>One of c(&quot;green&quot;, &quot;purple&quot;, &quot;red&quot;, &quot;orange&quot;, &quot;blue&quot;, &quot;brown&quot;, &quot;yellow&quot;, &quot;gray&quot;)
indicating the color for positive interactions.</p>
</td></tr>
<tr><td><code id="plot_network_+3A_negative_col">negative_col</code></td>
<td>
<p>One of c(&quot;green&quot;, &quot;purple&quot;, &quot;red&quot;, &quot;orange&quot;, &quot;blue&quot;, &quot;brown&quot;, &quot;yellow&quot;, &quot;gray&quot;)
indicating the color for negative interactions.
show_alleles A logical value indicating whether to color main effects by their allele values (TRUE)
or by whether they are positive or negative (FALSE)</p>
</td></tr>
<tr><td><code id="plot_network_+3A_show_alleles">show_alleles</code></td>
<td>
<p>boolean, default is TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Interaction effects are shown as arrows linking chromosomal
positions. They are colored based on whether they are positive
or negative.
</p>

<hr>
<h2 id='plot_pairscan'>Plot the result of the pairwise scan</h2><span id='topic+plot_pairscan'></span>

<h3>Description</h3>

<p>This function plots the results of the pairwise scan.
It plots a matrix of the the interactions between all 
pairs of markers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_pairscan(
  data_obj,
  pairscan_obj,
  phenotype = NULL,
  standardized = FALSE,
  show_marker_labels = FALSE,
  show_chr = TRUE,
  label_chr = TRUE,
  show_alleles = TRUE,
  allele_labels = NULL,
  pos_col = "brown",
  neg_col = "blue",
  color_scheme = c("DO/CC", "other"),
  pdf_label = "Pairscan.Regression.pdf"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_pairscan_+3A_data_obj">data_obj</code></td>
<td>
<p>a <code><a href="#topic+Cape">Cape</a></code> object</p>
</td></tr>
<tr><td><code id="plot_pairscan_+3A_pairscan_obj">pairscan_obj</code></td>
<td>
<p>a pairscan object from <code><a href="#topic+pairscan">pairscan</a></code></p>
</td></tr>
<tr><td><code id="plot_pairscan_+3A_phenotype">phenotype</code></td>
<td>
<p>The names of the phenotypes to be plotted. If NULL,
all phenotypes are plotted.</p>
</td></tr>
<tr><td><code id="plot_pairscan_+3A_standardized">standardized</code></td>
<td>
<p>If TRUE, the standardized effects are plotted.
IF FALSE, the effect sizes are plotted.</p>
</td></tr>
<tr><td><code id="plot_pairscan_+3A_show_marker_labels">show_marker_labels</code></td>
<td>
<p>If TRUE marker labels are plotted along the
axes. If FALSE, they are omitted.</p>
</td></tr>
<tr><td><code id="plot_pairscan_+3A_show_chr">show_chr</code></td>
<td>
<p>If TRUE, the chromosome boundaries are shown</p>
</td></tr>
<tr><td><code id="plot_pairscan_+3A_label_chr">label_chr</code></td>
<td>
<p>If TRUE, the chromosomes are labeled</p>
</td></tr>
<tr><td><code id="plot_pairscan_+3A_show_alleles">show_alleles</code></td>
<td>
<p>If TRUE, the allele of each marker is indicated by color.</p>
</td></tr>
<tr><td><code id="plot_pairscan_+3A_allele_labels">allele_labels</code></td>
<td>
<p>Labels for the alleles if other than those stored in the
data object.</p>
</td></tr>
<tr><td><code id="plot_pairscan_+3A_pos_col">pos_col</code></td>
<td>
<p>The color to use for positive main effects and interactions
must be one of &quot;green&quot;, &quot;purple&quot;, &quot;red&quot;, &quot;orange&quot;, &quot;blue&quot;, &quot;brown&quot;, &quot;yellow&quot;, &quot;gray&quot;
see <code><a href="#topic+get_color">get_color</a></code></p>
</td></tr>
<tr><td><code id="plot_pairscan_+3A_neg_col">neg_col</code></td>
<td>
<p>The color to use for negative main effects and interactions
takes the same values as pos_col.</p>
</td></tr>
<tr><td><code id="plot_pairscan_+3A_color_scheme">color_scheme</code></td>
<td>
<p>either &quot;DO/CC&quot; or &quot;other&quot;. &quot;DO/CC&quot; uses the official &quot;DO/CC&quot;
colors for the DO/CC alleles  
<a href="http://www.csbio.unc.edu/CCstatus/index.py?run=AvailableLines.information">http://www.csbio.unc.edu/CCstatus/index.py?run=AvailableLines.information</a>
&quot;other&quot; uses an unrelated color palette for multiple alleles.</p>
</td></tr>
<tr><td><code id="plot_pairscan_+3A_pdf_label">pdf_label</code></td>
<td>
<p>Label for the resulting file. Defaults to &quot;Pairscan.Regression.pdf&quot;
if plotting to pdf, &quot;Pairscan.Regression.jpg&quot; otherwise.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plots to a pdf
</p>

<hr>
<h2 id='plot_pheno_cor'>Plot trait pairs against each other</h2><span id='topic+plot_pheno_cor'></span>

<h3>Description</h3>

<p>This function plots pairs of traits against each other
to visualize the correlations between traits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_pheno_cor(
  data_obj,
  pheno_which = NULL,
  color_by = NULL,
  group_labels = NULL,
  text_cex = 1,
  pheno_labels = NULL,
  pt_cex = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_pheno_cor_+3A_data_obj">data_obj</code></td>
<td>
<p>a <code><a href="#topic+Cape">Cape</a></code> object</p>
</td></tr>
<tr><td><code id="plot_pheno_cor_+3A_pheno_which">pheno_which</code></td>
<td>
<p>A vector of trait names to plot. The default is to plot all traits.</p>
</td></tr>
<tr><td><code id="plot_pheno_cor_+3A_color_by">color_by</code></td>
<td>
<p>A character string indicating a value to color the traits by, for example sex or treatment.
It must be one of the covariates. See <code><a href="#topic+pheno2covar">pheno2covar</a></code>.</p>
</td></tr>
<tr><td><code id="plot_pheno_cor_+3A_group_labels">group_labels</code></td>
<td>
<p>A vector of names for the legend indicating the groups for the colored dots.</p>
</td></tr>
<tr><td><code id="plot_pheno_cor_+3A_text_cex">text_cex</code></td>
<td>
<p>A numeric value indicating the size of the text</p>
</td></tr>
<tr><td><code id="plot_pheno_cor_+3A_pheno_labels">pheno_labels</code></td>
<td>
<p>A vector of names for traits to appear in the plot in case the column names are not very pretty.</p>
</td></tr>
<tr><td><code id="plot_pheno_cor_+3A_pt_cex">pt_cex</code></td>
<td>
<p>A numeric value indicating the size of the points.</p>
</td></tr>
</table>

<hr>
<h2 id='plot_points'>Plot phenotypic effect for two markers as points</h2><span id='topic+plot_points'></span>

<h3>Description</h3>

<p>This internal function is called by 
<code><a href="#topic+plot_effects">plot_effects</a></code> to generate a 
plot showing trait the effects of genotype
on phenotype. If marker2_vals is NULL, this
plot shows the main effect of marker1. 
Otherwise it shows effects of the two alleles
together. 
In this plot all individual values are plotted
as points using color to separate the genotype
combinations. The means for each group are indicated
by line segments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_points(
  phenoV,
  marker1_vals,
  marker2_vals,
  pheno_name,
  marker1_label,
  marker2_label,
  ymin = NULL,
  ymax = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_points_+3A_phenov">phenoV</code></td>
<td>
<p>A vector of trait values</p>
</td></tr>
<tr><td><code id="plot_points_+3A_marker1_vals">marker1_vals</code></td>
<td>
<p>A vector of genotype values 
for marker1</p>
</td></tr>
<tr><td><code id="plot_points_+3A_marker2_vals">marker2_vals</code></td>
<td>
<p>A vector of genotype values
for marker2.</p>
</td></tr>
<tr><td><code id="plot_points_+3A_pheno_name">pheno_name</code></td>
<td>
<p>A string indicating the name of
the trait being plotted.</p>
</td></tr>
<tr><td><code id="plot_points_+3A_marker1_label">marker1_label</code></td>
<td>
<p>A string indicating the name
of marker1</p>
</td></tr>
<tr><td><code id="plot_points_+3A_marker2_label">marker2_label</code></td>
<td>
<p>A string indicating the name
of marker2</p>
</td></tr>
<tr><td><code id="plot_points_+3A_ymin">ymin</code></td>
<td>
<p>A numeric value indicating the minimum 
y value for the plot. If NULL, it will be calculated
based on phenoV and error bars.</p>
</td></tr>
<tr><td><code id="plot_points_+3A_ymax">ymax</code></td>
<td>
<p>A numeric value indicating the maximum
y value for the plot. If NULL, it will be calculated
based on phenoV and error bars.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='plot_singlescan'>Plot results of single-locus scans</h2><span id='topic+plot_singlescan'></span>

<h3>Description</h3>

<p>This function plots the results of <code><a href="#topic+singlescan">singlescan</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_singlescan(
  data_obj,
  singlescan_obj,
  chr = NULL,
  traits = NULL,
  alpha = c(0.01, 0.05),
  standardized = TRUE,
  color_scheme = c("DO/CC", "other"),
  allele_labels = NULL,
  include_covars = TRUE,
  show_selected = FALSE,
  line_type = "l",
  lwd = 1,
  pch = 16,
  cex = 1,
  covar_label_size = 0.7
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_singlescan_+3A_data_obj">data_obj</code></td>
<td>
<p>a <code><a href="#topic+Cape">Cape</a></code> object</p>
</td></tr>
<tr><td><code id="plot_singlescan_+3A_singlescan_obj">singlescan_obj</code></td>
<td>
<p>a singlescan object from <code><a href="#topic+singlescan">singlescan</a></code></p>
</td></tr>
<tr><td><code id="plot_singlescan_+3A_chr">chr</code></td>
<td>
<p>a vector of chromosome names to include in the plot. Defaults to all chromosomes.</p>
</td></tr>
<tr><td><code id="plot_singlescan_+3A_traits">traits</code></td>
<td>
<p>a vector of trait names to plot. Defaults to all traits.</p>
</td></tr>
<tr><td><code id="plot_singlescan_+3A_alpha">alpha</code></td>
<td>
<p>the alpha significance level. Lines for significance values will only
be plotted if n_perm &gt; 0 when <code><a href="#topic+singlescan">singlescan</a></code> was run. And only alpha values
specified in <code><a href="#topic+singlescan">singlescan</a></code> can be plotted.</p>
</td></tr>
<tr><td><code id="plot_singlescan_+3A_standardized">standardized</code></td>
<td>
<p>If TRUE t statistics are plotted. If FALSE, effect sizes are plotted.</p>
</td></tr>
<tr><td><code id="plot_singlescan_+3A_color_scheme">color_scheme</code></td>
<td>
<p>A character value of either &quot;DO/CC&quot; or other indicating the 
color scheme of main effects. If &quot;DO/CC&quot; allele effects can be plotted with the
DO/CC colors.</p>
</td></tr>
<tr><td><code id="plot_singlescan_+3A_allele_labels">allele_labels</code></td>
<td>
<p>A vector of labels for the alleles if different than those
stored in the data_object.</p>
</td></tr>
<tr><td><code id="plot_singlescan_+3A_include_covars">include_covars</code></td>
<td>
<p>Whether to include covariates in the plot.</p>
</td></tr>
<tr><td><code id="plot_singlescan_+3A_show_selected">show_selected</code></td>
<td>
<p>If TRUE will indicate which markers were selected for the pairscan.
In order for these to be plotted, <code><a href="#topic+select_markers_for_pairscan">select_markers_for_pairscan</a></code> must be run first.</p>
</td></tr>
<tr><td><code id="plot_singlescan_+3A_line_type">line_type</code></td>
<td>
<p>as defined in plot</p>
</td></tr>
<tr><td><code id="plot_singlescan_+3A_lwd">lwd</code></td>
<td>
<p>line width, default is 1</p>
</td></tr>
<tr><td><code id="plot_singlescan_+3A_pch">pch</code></td>
<td>
<p>see the &quot;points()&quot; R function. Default is 16 (a point).</p>
</td></tr>
<tr><td><code id="plot_singlescan_+3A_cex">cex</code></td>
<td>
<p>see the &quot;points()&quot; R function. Default is 1.</p>
</td></tr>
<tr><td><code id="plot_singlescan_+3A_covar_label_size">covar_label_size</code></td>
<td>
<p>default is 0.7</p>
</td></tr>
</table>

<hr>
<h2 id='plot_svd'>Plots eigentraits</h2><span id='topic+plot_svd'></span>

<h3>Description</h3>

<p>This function plots the results of the singular value
decomposition (SVD) on the phenotypes. Gray bars indicate
the amount of phenotypic variance accounted for by each
eigentrait.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_svd(
  data_obj,
  orientation = c("vertical", "horizontal"),
  neg_col = "blue",
  pos_col = "brown",
  light_dark = "f",
  pheno_labels = NULL,
  cex_barplot_axis = 1.7,
  cex_barplot_labels = 2,
  cex_barplot_title = 1.7,
  main = "Eigentrait Contributions to Phenotypes",
  cex_main = 2,
  main_x = 0.5,
  main_y = 0.5,
  cex_ET = 1.7,
  ET_label_x = 0.5,
  ET_label_y = 0.5,
  pheno_label_pos = 0.5,
  cex_pheno = 1.7,
  pheno_srt = 90,
  percent_total_variance_x = 0.5,
  percent_total_variance_y = 0.5,
  cex_color_scale = 1,
  cex_var_accounted = 2,
  var_accounted_x = 0,
  var_accounted_y = 0,
  show_var_accounted = FALSE,
  just_selected_et = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_svd_+3A_data_obj">data_obj</code></td>
<td>
<p>a <code><a href="#topic+Cape">Cape</a></code> object</p>
</td></tr>
<tr><td><code id="plot_svd_+3A_orientation">orientation</code></td>
<td>
<p>string, (&quot;vertical&quot;, &quot;horizontal&quot;)</p>
</td></tr>
<tr><td><code id="plot_svd_+3A_neg_col">neg_col</code></td>
<td>
<p>The color to use for negative main effects and interactions
takes the same values as pos_col.</p>
</td></tr>
<tr><td><code id="plot_svd_+3A_pos_col">pos_col</code></td>
<td>
<p>The color to use for positive main effects and interactions
must be one of &quot;green&quot;, &quot;purple&quot;, &quot;red&quot;, &quot;orange&quot;, &quot;blue&quot;, &quot;brown&quot;, &quot;yellow&quot;, &quot;gray&quot;
see <code><a href="#topic+get_color">get_color</a></code></p>
</td></tr>
<tr><td><code id="plot_svd_+3A_light_dark">light_dark</code></td>
<td>
<p>Indicates whether pos_col, neg_col, and bg_col should be selected
from light colors (&quot;l&quot;), dark colors (&quot;d&quot;) or the full spectrum from light to dark (&quot;f&quot;)</p>
</td></tr>
<tr><td><code id="plot_svd_+3A_pheno_labels">pheno_labels</code></td>
<td>
<p>Vector of phenotype names if other than what is stored in the
data object</p>
</td></tr>
<tr><td><code id="plot_svd_+3A_cex_barplot_axis">cex_barplot_axis</code></td>
<td>
<p>Size of axis for the bar plot</p>
</td></tr>
<tr><td><code id="plot_svd_+3A_cex_barplot_labels">cex_barplot_labels</code></td>
<td>
<p>Size of labels for the bar plot</p>
</td></tr>
<tr><td><code id="plot_svd_+3A_cex_barplot_title">cex_barplot_title</code></td>
<td>
<p>Size of the barplot title</p>
</td></tr>
<tr><td><code id="plot_svd_+3A_main">main</code></td>
<td>
<p>Title for the plot. Defaults to &quot;Eigentrait Contributions to Phenotypes&quot;</p>
</td></tr>
<tr><td><code id="plot_svd_+3A_cex_main">cex_main</code></td>
<td>
<p>Size of the overall title</p>
</td></tr>
<tr><td><code id="plot_svd_+3A_main_x">main_x</code></td>
<td>
<p>x shift for the overall title</p>
</td></tr>
<tr><td><code id="plot_svd_+3A_main_y">main_y</code></td>
<td>
<p>y shift for the overall title</p>
</td></tr>
<tr><td><code id="plot_svd_+3A_cex_et">cex_ET</code></td>
<td>
<p>Size of the eigentrait labels</p>
</td></tr>
<tr><td><code id="plot_svd_+3A_et_label_x">ET_label_x</code></td>
<td>
<p>x shift for the eigentrait labels</p>
</td></tr>
<tr><td><code id="plot_svd_+3A_et_label_y">ET_label_y</code></td>
<td>
<p>y shift for the eigentrait labels</p>
</td></tr>
<tr><td><code id="plot_svd_+3A_pheno_label_pos">pheno_label_pos</code></td>
<td>
<p>x shift for the trait labels</p>
</td></tr>
<tr><td><code id="plot_svd_+3A_cex_pheno">cex_pheno</code></td>
<td>
<p>size of the trait labels</p>
</td></tr>
<tr><td><code id="plot_svd_+3A_pheno_srt">pheno_srt</code></td>
<td>
<p>Rotation factor for the trait labels</p>
</td></tr>
<tr><td><code id="plot_svd_+3A_percent_total_variance_x">percent_total_variance_x</code></td>
<td>
<p>x shift for the percent total variance labels</p>
</td></tr>
<tr><td><code id="plot_svd_+3A_percent_total_variance_y">percent_total_variance_y</code></td>
<td>
<p>y shift for the percent total variance labels</p>
</td></tr>
<tr><td><code id="plot_svd_+3A_cex_color_scale">cex_color_scale</code></td>
<td>
<p>label size for the color scal</p>
</td></tr>
<tr><td><code id="plot_svd_+3A_cex_var_accounted">cex_var_accounted</code></td>
<td>
<p>size for the variance accounted for labels</p>
</td></tr>
<tr><td><code id="plot_svd_+3A_var_accounted_x">var_accounted_x</code></td>
<td>
<p>x shift for the variance accounted axis label</p>
</td></tr>
<tr><td><code id="plot_svd_+3A_var_accounted_y">var_accounted_y</code></td>
<td>
<p>x shift for the variance accounted axis label</p>
</td></tr>
<tr><td><code id="plot_svd_+3A_show_var_accounted">show_var_accounted</code></td>
<td>
<p>logical</p>
</td></tr>
<tr><td><code id="plot_svd_+3A_just_selected_et">just_selected_et</code></td>
<td>
<p>logical</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Below the bars is a heatmap indicating how each trait 
contributes to each eigentrait. Colors can be adjusted
to suit preferences.
</p>


<h3>Value</h3>

<p><code>list("data_obj" = data_obj, "geno_obj" = geno_obj)</code>
</p>

<hr>
<h2 id='plot_trait_circ'>Plot concentric trait circles</h2><span id='topic+plot_trait_circ'></span>

<h3>Description</h3>

<p>This internal function is called by <code><a href="#topic+plot_network">plot_network</a></code>
It plots one circle for each trait in the data object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_trait_circ(trait_circ, label_gap, plot_dim, main_lwd)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_trait_circ_+3A_trait_circ">trait_circ</code></td>
<td>
<p>A list with one element for each cirlce giving
the coordinates of the points to plot for each circle.</p>
</td></tr>
<tr><td><code id="plot_trait_circ_+3A_label_gap">label_gap</code></td>
<td>
<p>The amount of space to leave between the circles
and their labels</p>
</td></tr>
<tr><td><code id="plot_trait_circ_+3A_plot_dim">plot_dim</code></td>
<td>
<p>the dimensions of the plot</p>
</td></tr>
<tr><td><code id="plot_trait_circ_+3A_main_lwd">main_lwd</code></td>
<td>
<p>The line thickness for the circles</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='plot_variant_influences'>Plot cape coefficients</h2><span id='topic+plot_variant_influences'></span>

<h3>Description</h3>

<p>This function plots the the cape coefficients between
pairs of markers as a heat map.
The interactions are shown in the main part of the heatmap
while the main effects are shown on the right hand side.
Directed interactions are read from the y axis to the x axis.
For example an interaction from marker1 to marker2 will be shown
in the row corresponding to marker1 and the column corresponding
to marker2. 
Similarly, if marker1 has a main effect on any traits, these
will be shown in the row for marker1 and the trait columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_variant_influences(
  data_obj,
  p_or_q = 0.05,
  min_std_effect = 0,
  plot_all_vals = FALSE,
  standardize = FALSE,
  color_scheme = c("DO/CC", "other"),
  pos_col = "brown",
  neg_col = "blue",
  not_tested_col = "lightgray",
  show_marker_labels = FALSE,
  show_chr = TRUE,
  label_chr = TRUE,
  show_alleles = TRUE,
  scale_effects = c("log10", "sqrt", "none"),
  pheno_width = NULL,
  covar_width = NULL,
  covar_labels = NULL,
  phenotype_labels = NULL,
  show_not_tested = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_variant_influences_+3A_data_obj">data_obj</code></td>
<td>
<p>a <code><a href="#topic+Cape">Cape</a></code> object</p>
</td></tr>
<tr><td><code id="plot_variant_influences_+3A_p_or_q">p_or_q</code></td>
<td>
<p>A threshold indicating the maximum p value (or q value
if FDR was used) of significant interactions and main effects</p>
</td></tr>
<tr><td><code id="plot_variant_influences_+3A_min_std_effect">min_std_effect</code></td>
<td>
<p>An optional filter. The plot will exclude
all pairs with standardized effects below the number set here.</p>
</td></tr>
<tr><td><code id="plot_variant_influences_+3A_plot_all_vals">plot_all_vals</code></td>
<td>
<p>If TRUE will plot all values regardless of 
significant</p>
</td></tr>
<tr><td><code id="plot_variant_influences_+3A_standardize">standardize</code></td>
<td>
<p>Whether to plot effect sizes (FALSE) or standardized
effect sizes (TRUE)</p>
</td></tr>
<tr><td><code id="plot_variant_influences_+3A_color_scheme">color_scheme</code></td>
<td>
<p>A character value of either &quot;DO/CC&quot; or other indicating the 
color scheme of main effects. If &quot;DO/CC&quot; allele effects can be plotted with the
DO/CC colors.</p>
</td></tr>
<tr><td><code id="plot_variant_influences_+3A_pos_col">pos_col</code></td>
<td>
<p>The color to use for positive main effects and interactions
must be one of &quot;green&quot;, &quot;purple&quot;, &quot;red&quot;, &quot;orange&quot;, &quot;blue&quot;, &quot;brown&quot;, &quot;yellow&quot;, &quot;gray&quot;
see <code><a href="#topic+get_color">get_color</a></code></p>
</td></tr>
<tr><td><code id="plot_variant_influences_+3A_neg_col">neg_col</code></td>
<td>
<p>The color to use for negative main effects and interactions
takes the same values as pos_col.</p>
</td></tr>
<tr><td><code id="plot_variant_influences_+3A_not_tested_col">not_tested_col</code></td>
<td>
<p>The color to use for marker pairs not tested. Takes
the same values as pos_col and neg_col</p>
</td></tr>
<tr><td><code id="plot_variant_influences_+3A_show_marker_labels">show_marker_labels</code></td>
<td>
<p>Whether to write the marker labels on the plot</p>
</td></tr>
<tr><td><code id="plot_variant_influences_+3A_show_chr">show_chr</code></td>
<td>
<p>Whether to show chromosome boundaries</p>
</td></tr>
<tr><td><code id="plot_variant_influences_+3A_label_chr">label_chr</code></td>
<td>
<p>Whether to label chromosomes if plotted</p>
</td></tr>
<tr><td><code id="plot_variant_influences_+3A_show_alleles">show_alleles</code></td>
<td>
<p>If TRUE, the allele of each marker is indicated by color.</p>
</td></tr>
<tr><td><code id="plot_variant_influences_+3A_scale_effects">scale_effects</code></td>
<td>
<p>One of &quot;log10&quot;, &quot;sqrt&quot;, &quot;none.&quot; If some effects are
very large, scaling them can help show contrasts between smaller values.
The default is no scaling.</p>
</td></tr>
<tr><td><code id="plot_variant_influences_+3A_pheno_width">pheno_width</code></td>
<td>
<p>Each marker and trait gets one column in the matrix. 
If there are many markers, this makes the effects on the traits difficult 
to see. pheno_width increases the number of columns given to the phenotypes.
For example, if pheno_width = 11, the phenotypes will be shown 11 times wider
than individual markers.</p>
</td></tr>
<tr><td><code id="plot_variant_influences_+3A_covar_width">covar_width</code></td>
<td>
<p>See pheno_width. This is the same effect for covariates.</p>
</td></tr>
<tr><td><code id="plot_variant_influences_+3A_covar_labels">covar_labels</code></td>
<td>
<p>Labels for covariates if different from those stored in 
the data object.</p>
</td></tr>
<tr><td><code id="plot_variant_influences_+3A_phenotype_labels">phenotype_labels</code></td>
<td>
<p>Labels for traits if different from those stored in 
the data object</p>
</td></tr>
<tr><td><code id="plot_variant_influences_+3A_show_not_tested">show_not_tested</code></td>
<td>
<p>Whether to color the marker pairs that were not
tested. If FALSE, they will not be colored in.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function invisibly returns the variant influences matrix.
shown in the heat map.
</p>

<hr>
<h2 id='qnorm_pheno'>Plot trait distributions</h2><span id='topic+qnorm_pheno'></span>

<h3>Description</h3>

<p>This function plots the quantiles of each trait
against quantiles of a theoretical normal distribution.
This provides a way to check whether traits are normally
distributed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qnorm_pheno(data_obj, pheno_which = NULL, pheno_labels = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qnorm_pheno_+3A_data_obj">data_obj</code></td>
<td>
<p>a <code><a href="#topic+Cape">Cape</a></code> object</p>
</td></tr>
<tr><td><code id="qnorm_pheno_+3A_pheno_which">pheno_which</code></td>
<td>
<p>A vector of trait names to plot. The default is to plot all traits.</p>
</td></tr>
<tr><td><code id="qnorm_pheno_+3A_pheno_labels">pheno_labels</code></td>
<td>
<p>A vector of names for traits to appear in the plot in case the column names are not very pretty.</p>
</td></tr>
</table>

<hr>
<h2 id='qtl2_to_cape'>Convert qtl2 object to cape format</h2><span id='topic+qtl2_to_cape'></span>

<h3>Description</h3>

<p>This function converts a data object constructed by qtl2 using the read_cross()
function to cape format. It returns a list in which the first element is the
cape data object, and the second element is the cape genotype object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qtl2_to_cape(cross, genoprobs = NULL, map = NULL, covar = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qtl2_to_cape_+3A_cross">cross</code></td>
<td>
<p>a cross object created by the R/qtl2 function read_cross()</p>
</td></tr>
<tr><td><code id="qtl2_to_cape_+3A_genoprobs">genoprobs</code></td>
<td>
<p>an optional argument for providing previously calculated genoprobs.
if this parameter is missing, genoprobs are calculated by qtl_to_cape.</p>
</td></tr>
<tr><td><code id="qtl2_to_cape_+3A_map">map</code></td>
<td>
<p>The qtl2 map. This can be omitted if the map is included in the cross 
object as either pmap or gmap. By default the physical map (pmap) is used. 
If it is missing, the genetic map is used. A provided map will be used 
preferentially over a map included in the cross object.</p>
</td></tr>
<tr><td><code id="qtl2_to_cape_+3A_covar">covar</code></td>
<td>
<p>Optional matrix of any covariates to be included in the analysis.</p>
</td></tr>
<tr><td><code id="qtl2_to_cape_+3A_verbose">verbose</code></td>
<td>
<p>A logical value indicating whether to print progress to the screen.
Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list of two elements. The first element is a cape data
object. The second element is a cape genotype object.
</p>


<h3>References</h3>

<p>Carter, G. W., Hays, M., Sherman, A., &amp; Galitski, T. (2012). Use
of pleiotropy to model genetic interactions in a population. PLoS genetics,
8(10), e1003010. doi:10.1371/journal.pgen.1003010
</p>
<p>Broman, Karl W., Daniel M. Gatti, Petr Simecek, Nicholas A. Furlotte, 
Pjotr Prins, aunak Sen, Brian S. Yandell, and Gary A. Churchill. &quot;R/qtl2: software 
for mapping quantitative trait loci with high-dimensional data and multiparent populations.&quot; 
Genetics 211, no. 2 (2019): 495-502.
</p>

<hr>
<h2 id='read_parameters'>Read the parameter file, add missing entries</h2><span id='topic+read_parameters'></span>

<h3>Description</h3>

<p>This function returns reads in the YAML file
and checks for any parameters that might not
be included. This may not matter for the given
run, but it's handy to be able to check for 
any and all potential variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_parameters(filename = "cape.parameters.yml", yaml_parameters = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_parameters_+3A_filename">filename</code></td>
<td>
<p>full path to the .yml file holding CAPE parameters (is not needed if yaml_parameters is provided)</p>
</td></tr>
<tr><td><code id="read_parameters_+3A_yaml_parameters">yaml_parameters</code></td>
<td>
<p>yaml string holding CAPE parameters (can be NULL)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a named list with all possible options
</p>

<hr>
<h2 id='read_population'>Reads in data in the R/qtl csv format</h2><span id='topic+read_population'></span>

<h3>Description</h3>

<p>This function reads in a data file in the r/qtl format
It converts letter genotypes to numbers if required.
It parses the data into a data object.
if filename is left empty, the script will ask the
use to choose a file.
phenotypes can be specified with a vector of column 
numbers or character strings. For each phenotype
specified with a name, the script will find its location.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_population(
  filename = NULL,
  pheno_col = NULL,
  geno_col = NULL,
  id_col = NULL,
  delim = ",",
  na_strings = "-",
  check_chr_order = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_population_+3A_filename">filename</code></td>
<td>
<p>The name of the file to read in</p>
</td></tr>
<tr><td><code id="read_population_+3A_pheno_col">pheno_col</code></td>
<td>
<p>Column numbers of desired traits. The default
behavior is to read in all traits.</p>
</td></tr>
<tr><td><code id="read_population_+3A_geno_col">geno_col</code></td>
<td>
<p>Column numbers of desired markers. The default
behavior is to read in all markers.</p>
</td></tr>
<tr><td><code id="read_population_+3A_id_col">id_col</code></td>
<td>
<p>The column number of an ID column. This is helpful to
specify if the individual IDs are strings. Strings are only
allowed in the ID column. All other trait data must be numeric.</p>
</td></tr>
<tr><td><code id="read_population_+3A_delim">delim</code></td>
<td>
<p>column delimiter for the file, default is &quot;,&quot;</p>
</td></tr>
<tr><td><code id="read_population_+3A_na_strings">na_strings</code></td>
<td>
<p>a character string indicating how NA values are specified, default is &quot;-&quot;</p>
</td></tr>
<tr><td><code id="read_population_+3A_check_chr_order">check_chr_order</code></td>
<td>
<p>boolean, default is TRUE</p>
</td></tr>
<tr><td><code id="read_population_+3A_verbose">verbose</code></td>
<td>
<p>A  logical value indicating whether to print progress 
and cross information to the screen. Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a cape object in a former cape format.
It must be updated using <code><a href="#topic+cape2mpp">cape2mpp</a></code>
</p>


<h3>References</h3>

<p>Broman et al. (2003) R/qtl: QTL mapping in experimental crosses. 
Bioinformatics 19:889-890 doi:10.1093/bioinformatics/btg112
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
cape_obj &lt;- read_population("cross.csv")
combined_obj &lt;- cape2mpp(cape_obj)
data_obj &lt;- combined_obj$data_obj
geno_obj &lt;- combined_obj$geno_obj

## End(Not run)

</code></pre>

<hr>
<h2 id='remove_ind'>Remove individuals</h2><span id='topic+remove_ind'></span>

<h3>Description</h3>

<p>Remove individuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_ind(data_obj, ind_to_remove = NULL, names_to_remove = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remove_ind_+3A_data_obj">data_obj</code></td>
<td>
<p>a <code><a href="#topic+Cape">Cape</a></code> object</p>
</td></tr>
<tr><td><code id="remove_ind_+3A_ind_to_remove">ind_to_remove</code></td>
<td>
<p>Indices of individuals to remove</p>
</td></tr>
<tr><td><code id="remove_ind_+3A_names_to_remove">names_to_remove</code></td>
<td>
<p>Names of individuals to remove
Only one of ind_to_remove or names_to_remove should be specified.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an updated cape data object with specified individuals removed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#remove males
covar_info &lt;- get_covar(data_obj)
male_idx &lt;- which(covar_info$covar_table[,"sex"] == 1)
data_obj &lt;- remove_ind(data_obj, ind_to_remove = male_idx)

## End(Not run)

</code></pre>

<hr>
<h2 id='remove_kin_ind'>Removes individuals from the kinship object to match the cape.obj</h2><span id='topic+remove_kin_ind'></span>

<h3>Description</h3>

<p>Removes individuals from the kinship object to match the cape.obj
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_kin_ind(data_obj, kin_obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remove_kin_ind_+3A_data_obj">data_obj</code></td>
<td>
<p>a <code><a href="#topic+Cape">Cape</a></code> object</p>
</td></tr>
<tr><td><code id="remove_kin_ind_+3A_kin_obj">kin_obj</code></td>
<td>
<p>a kinship object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>updated kinship object
</p>

<hr>
<h2 id='remove_markers'>Removes genetic markers</h2><span id='topic+remove_markers'></span>

<h3>Description</h3>

<p>Removes genetic markers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_markers(data_obj, markers_to_remove)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remove_markers_+3A_data_obj">data_obj</code></td>
<td>
<p>a <code><a href="#topic+Cape">Cape</a></code> object</p>
</td></tr>
<tr><td><code id="remove_markers_+3A_markers_to_remove">markers_to_remove</code></td>
<td>
<p>A vector of marker names to be removed.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#remove markers on chromosome 1
marker_idx &lt;- which(data_obj$chromosome == 1)
data_obj &lt;- remove_markers(data_obj, marker_idx)

## End(Not run)

</code></pre>

<hr>
<h2 id='remove_missing_genotype_data'>Removes individuals and/or markers with missing data</h2><span id='topic+remove_missing_genotype_data'></span>

<h3>Description</h3>

<p>Because there an be no missing data when calculating
the kinship correction, we need a way to remove either
individuals or markers with missing data. We also need
a way to calculate which of these options will remove the
least amount of data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_missing_genotype_data(
  data_obj,
  geno_obj = NULL,
  ind_missing_thresh = 0,
  marker_missing_thresh = 0,
  prioritize = c("fewer", "ind", "marker")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remove_missing_genotype_data_+3A_data_obj">data_obj</code></td>
<td>
<p>a <code><a href="#topic+Cape">Cape</a></code> object</p>
</td></tr>
<tr><td><code id="remove_missing_genotype_data_+3A_geno_obj">geno_obj</code></td>
<td>
<p>a genotype object</p>
</td></tr>
<tr><td><code id="remove_missing_genotype_data_+3A_ind_missing_thresh">ind_missing_thresh</code></td>
<td>
<p>Allowable amount of missing information for an individual. 
If 10
default, all individuals with any missing data at all will be removed.</p>
</td></tr>
<tr><td><code id="remove_missing_genotype_data_+3A_marker_missing_thresh">marker_missing_thresh</code></td>
<td>
<p>Allowable amount of missing information for a marker. 
If 10
default, all markers with any missing data at all will be removed.</p>
</td></tr>
<tr><td><code id="remove_missing_genotype_data_+3A_prioritize">prioritize</code></td>
<td>
<p>the basis prioritization is one of 
&quot;fewer&quot; = calculate whether removing individuals or markers 
will remove fewer data points, and start with that.
&quot;ind&quot; = remove individuals with missing data before considering 
markers with missing data.
&quot;marker&quot; = remove markers with missing data before considering individuals.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For example, if there is one marker with no data at all,
we would rather remove that one marker, than all individuals
with missing data. Alternatively, if there is one individual
with very sparse genotyping, we would prefer to remove that 
single individual, rather than all markers with missing data.
</p>
<p>This function provides a way to calculate whether individuals
or markers should be prioritized when removing data. It then
removes those individuals or markers.
</p>


<h3>Value</h3>

<p>The cape object is returned with individuals and markers removed. After this step,
the function <code><a href="#topic+get_geno">get_geno</a></code> should return an array with no missing data if ind_missing_thresh
and marker_missing_thresh are both 0. If these numbers are higher, no individual or marker will
be missing more than the set percentage of data.
</p>
<p>details All missing genotype data must either be imputed or removed if using the kinship correction.
Running <code><a href="#topic+impute_missing_geno">impute_missing_geno</a></code> prior to running <code><a href="#topic+remove_missing_genotype_data">remove_missing_genotype_data</a></code>
ensures that the least possible amount of data are removed before running cape. In some cases, there
will be missing genotype data even after running <code><a href="#topic+impute_missing_geno">impute_missing_geno</a></code>, in which case,
<code>remove_missing_genotype_data</code> still needs to be run. 
The function <code><a href="#topic+run_cape">run_cape</a></code> automatically runs these steps when <code>use_kinship</code>
is set to TRUE.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_geno">get_geno</a></code>, <code><a href="#topic+impute_missing_geno">impute_missing_geno</a></code>, <code><a href="#topic+run_cape">run_cape</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#remove entries with more than 10\
#removal of markers
data_obj &lt;- remove_missing_genotype_data(data_obj, geno_obj, 
marker_missing_thresh = 10, ind_missing_thresh = 10,
prioritize = "marker")

#remove markers with more than 5\
#more than 50\
#missing data, prioritizing removal of individuals.
data_obj &lt;- remove_missing_genotype_data(data_obj, geno_obj, 
ind_missing_thresh = 10, marker_missing_thresh = 50,
prioritize = "ind")

#remove entries witn any missing data prioritizing whichever 
#method removes the least amount of data
data_obj &lt;- remove_missing_genotype_data(data_obj, geno_obj)


## End(Not run)

</code></pre>

<hr>
<h2 id='remove_unused_markers'>Take out markers not used in cape</h2><span id='topic+remove_unused_markers'></span>

<h3>Description</h3>

<p>This function removes any markers that are not
used in cape. This includes markers on the sex 
chromosomes, mitochondrial markers, and any 
invariant markers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_unused_markers(data_obj, geno_obj, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remove_unused_markers_+3A_data_obj">data_obj</code></td>
<td>
<p>a <code><a href="#topic+Cape">Cape</a></code> object</p>
</td></tr>
<tr><td><code id="remove_unused_markers_+3A_geno_obj">geno_obj</code></td>
<td>
<p>a genotype object</p>
</td></tr>
<tr><td><code id="remove_unused_markers_+3A_verbose">verbose</code></td>
<td>
<p>A logical value indicating whether to print progress 
to the screen. Default is FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an updated <code><a href="#topic+Cape">Cape</a></code> object (data_obj)
</p>

<hr>
<h2 id='report_progress'>Report Progress of a Process</h2><span id='topic+report_progress'></span>

<h3>Description</h3>

<p>This function prints out the percent progress in a process
given the current iteration the total number of iterations
and the percentage at which a progress report is wanted.
It only works on loops in which the index is explicitly incremented
in the code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>report_progress(
  current,
  total,
  percent_text = 10,
  percent_dot = 2,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="report_progress_+3A_current">current</code></td>
<td>
<p>The current index being processed</p>
</td></tr>
<tr><td><code id="report_progress_+3A_total">total</code></td>
<td>
<p>The total number of indices that will be processed</p>
</td></tr>
<tr><td><code id="report_progress_+3A_percent_text">percent_text</code></td>
<td>
<p>The percent progress at which the percent should
be printed to the screen.</p>
</td></tr>
<tr><td><code id="report_progress_+3A_percent_dot">percent_dot</code></td>
<td>
<p>The percent progress at which a dot should be printed
to the screen</p>
</td></tr>
<tr><td><code id="report_progress_+3A_verbose">verbose</code></td>
<td>
<p>A logical value indicating whether to report progress to 
the screen. Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None. Prints output to the screen.
</p>

<hr>
<h2 id='rotate_mat'>Orients a matrix for proper display in a plot</h2><span id='topic+rotate_mat'></span>

<h3>Description</h3>

<p>This function reassembles a matrix 
so that when we use image to plot, 
the matrix appears in the image in 
the same orientation in which it
is printed to the screen
are in rows and the phenotypes in columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotate_mat(mat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rotate_mat_+3A_mat">mat</code></td>
<td>
<p>a matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matrix &quot;mat&quot; rotated 90 degrees.
</p>

<hr>
<h2 id='run_cape'>Runs CAPE</h2><span id='topic+run_cape'></span>

<h3>Description</h3>

<p>This function takes in a data object and genotype object that
have been formatted for cape, as well as a string identifying
a parameter file. It runs cape on the data using the parameters
specified in the file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_cape(
  pheno_obj,
  geno_obj,
  results_file = "cross.RDS",
  p_or_q = 0.05,
  n_cores = 4,
  initialize_only = FALSE,
  verbose = TRUE,
  run_parallel = FALSE,
  param_file = NULL,
  yaml_params = NULL,
  results_path = NULL,
  plot_pdf = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="run_cape_+3A_pheno_obj">pheno_obj</code></td>
<td>
<p>the cape object holding the phenotype data returned by</p>
</td></tr>
<tr><td><code id="run_cape_+3A_geno_obj">geno_obj</code></td>
<td>
<p>the genotype object</p>
</td></tr>
<tr><td><code id="run_cape_+3A_results_file">results_file</code></td>
<td>
<p>the name of the saved data_obj RDS file. The base 
name is used as the base name for all saved RDS files.</p>
</td></tr>
<tr><td><code id="run_cape_+3A_p_or_q">p_or_q</code></td>
<td>
<p>A threshold indicating the maximum adjusted p value 
considered significant. Or, if FDR p value correction is used, the
the maximum q value considered significant.</p>
</td></tr>
<tr><td><code id="run_cape_+3A_n_cores">n_cores</code></td>
<td>
<p>The number of CPUs to use if run_parallel is set to TRUE</p>
</td></tr>
<tr><td><code id="run_cape_+3A_initialize_only">initialize_only</code></td>
<td>
<p>If TRUE, cape will not be run. Instead an initialized
data object will be returned. This data object will contain normalized and mean-centered
trait values, and eigentraits, and will have covariates specified. However, the 
singlescan, pairscan, etc. will not be run.</p>
</td></tr>
<tr><td><code id="run_cape_+3A_verbose">verbose</code></td>
<td>
<p>Whether progress should be printed to the screen</p>
</td></tr>
<tr><td><code id="run_cape_+3A_run_parallel">run_parallel</code></td>
<td>
<p>boolean, if TRUE runs certain parts of the code as parallel blocks</p>
</td></tr>
<tr><td><code id="run_cape_+3A_param_file">param_file</code></td>
<td>
<p>yaml full path to the parameter file</p>
</td></tr>
<tr><td><code id="run_cape_+3A_yaml_params">yaml_params</code></td>
<td>
<p>yaml string containing the parameters. Either the param_file or 
yaml_params can be null.</p>
</td></tr>
<tr><td><code id="run_cape_+3A_results_path">results_path</code></td>
<td>
<p>path that results should be written to.</p>
</td></tr>
<tr><td><code id="run_cape_+3A_plot_pdf">plot_pdf</code></td>
<td>
<p>boolean, TRUE by default. If FALSE no pdf will be generated by the analysis.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function assumes you already have all required libraries 
and functions loaded.
</p>


<h3>Value</h3>

<p>This function invisibly returns the data object with all final 
data included. In addition, data saved to the data_obj$results_path directory
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
final_data_obj &lt;- run_cape(pheno_obj, geno_obj)

## End(Not run)

</code></pre>

<hr>
<h2 id='rz_transform'>Rank Z normalize</h2><span id='topic+rz_transform'></span>

<h3>Description</h3>

<p>Rank Z normalize data in a vector. We rank the data in 
x, divide by n-1, and return the quantiles of the normal
distribution using qnorm. This transformation is also 
called an inverse normal transformation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rz_transform(x, jitter = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rz_transform_+3A_x">x</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id="rz_transform_+3A_jitter">jitter</code></td>
<td>
<p>boolean, default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numeric vector with a normal distribution
</p>

<hr>
<h2 id='segment_region'>Divide a region into equal parts.</h2><span id='topic+segment_region'></span>

<h3>Description</h3>

<p>This is an internal function used to segment regions 
for plotting. It returns n evenly spaced points in a given
region. The points can be aligned to the ends of 
the interval, or centered in the interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segment_region(
  region_min,
  region_max,
  num_points,
  alignment = c("center", "ends")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="segment_region_+3A_region_min">region_min</code></td>
<td>
<p>A numerical value indicating the minimum value of the region.</p>
</td></tr>
<tr><td><code id="segment_region_+3A_region_max">region_max</code></td>
<td>
<p>A numerical value indicating the maximum value of the region.</p>
</td></tr>
<tr><td><code id="segment_region_+3A_num_points">num_points</code></td>
<td>
<p>The number of points to place in the region.</p>
</td></tr>
<tr><td><code id="segment_region_+3A_alignment">alignment</code></td>
<td>
<p>A character element indicating whether the points should be 
centered within the region or whether they should extend to the ends of the region.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns n points spaced evenly across the defined region
</p>

<hr>
<h2 id='select_eigentraits'>Assign selected eigentraits in the Cape object</h2><span id='topic+select_eigentraits'></span>

<h3>Description</h3>

<p>This function is used to identify which eigentraits
will be analyzed in the Cape run. After eigentrait 
decomposition of n traits, there will be n eigentraits.
If there are more than two eigentraits, the user may
wish to analyze a subset of them. This function specifies
which of the eigentraits will be analyzed by Cape. It does
this by subsetting the ET matrix to only those eigentraits
specified. The traits not selected are deleted from the object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_eigentraits(data_obj, traits_which = c(1, 2))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="select_eigentraits_+3A_data_obj">data_obj</code></td>
<td>
<p>a <code><a href="#topic+Cape">Cape</a></code> object</p>
</td></tr>
<tr><td><code id="select_eigentraits_+3A_traits_which">traits_which</code></td>
<td>
<p>A vector of integers, of at least length two
specifying which eigentraits should be analyzed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>updated <code><a href="#topic+Cape">Cape</a></code> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_svd">plot_svd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data_obj &lt;- selecct_eigentraits(data_obj, traits_which = 1:3)

## End(Not run)

</code></pre>

<hr>
<h2 id='select_markers_for_pairscan'>Select markers for the pairwise scan.</h2><span id='topic+select_markers_for_pairscan'></span>

<h3>Description</h3>

<p>This function selects markers for the pairwise scan.
Beause Cape is computationally intensive, pairscans 
should not be run on large numbers of markers. 
As a rule of thumb, 1500 markers in a population of 
500 individuals takes about 24 hours to run without the
kinship correction. The kinship correction increases the
time of the analysis, and users may wish to reduce the number
of markers scanned even further to accommodate the extra
computational burden of the kinship correction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_markers_for_pairscan(
  data_obj,
  singlescan_obj,
  geno_obj,
  specific_markers = NULL,
  num_alleles = 50,
  peak_density = 0.5,
  window_size = NULL,
  tolerance = 5,
  plot_peaks = FALSE,
  verbose = FALSE,
  pdf_filename = "Peak.Plots.pdf"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="select_markers_for_pairscan_+3A_data_obj">data_obj</code></td>
<td>
<p>a <code><a href="#topic+Cape">Cape</a></code> object</p>
</td></tr>
<tr><td><code id="select_markers_for_pairscan_+3A_singlescan_obj">singlescan_obj</code></td>
<td>
<p>a singlescan object from <code><a href="#topic+singlescan">singlescan</a></code>.</p>
</td></tr>
<tr><td><code id="select_markers_for_pairscan_+3A_geno_obj">geno_obj</code></td>
<td>
<p>a genotype object</p>
</td></tr>
<tr><td><code id="select_markers_for_pairscan_+3A_specific_markers">specific_markers</code></td>
<td>
<p>A vector of marker names specifying which
markers should be selected. If NULL, the function uses main effect
size to select markers.</p>
</td></tr>
<tr><td><code id="select_markers_for_pairscan_+3A_num_alleles">num_alleles</code></td>
<td>
<p>The target number of markers to select if using
main effect size</p>
</td></tr>
<tr><td><code id="select_markers_for_pairscan_+3A_peak_density">peak_density</code></td>
<td>
<p>The fraction of markers to select under each 
peak exceeding the current threshold. Should be set higher for populations
with low LD. And should be set lower for populations with high LD. Defaults 
to 0.5, corresponding to 50% of markers selected under each peak.</p>
</td></tr>
<tr><td><code id="select_markers_for_pairscan_+3A_window_size">window_size</code></td>
<td>
<p>The number of markers to use in a smoothing window when
calculating main effect peaks. If NULL, the window size is selected automatically
based on the number of markers with consecutive rises and falls of main effect
size.</p>
</td></tr>
<tr><td><code id="select_markers_for_pairscan_+3A_tolerance">tolerance</code></td>
<td>
<p>The allowable deviation from the target marker number in
number of markers. For example, If you ask the function to select 100 markers,
an set the tolerance to 5, the algorithm will stop when it has selected between
95 and 105 markers.</p>
</td></tr>
<tr><td><code id="select_markers_for_pairscan_+3A_plot_peaks">plot_peaks</code></td>
<td>
<p>Whether to plot the singlescan peaks identified by <code><a href="#topic+bin_curve">bin_curve</a></code>.
This can be helpful in determining whether the window_size and peak_density parameters 
are optimal for the population.</p>
</td></tr>
<tr><td><code id="select_markers_for_pairscan_+3A_verbose">verbose</code></td>
<td>
<p>Whether progress should be printed to the screen</p>
</td></tr>
<tr><td><code id="select_markers_for_pairscan_+3A_pdf_filename">pdf_filename</code></td>
<td>
<p>If plot_peaks is TRUE, this argument specifies the filename
to which the peaks are plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can select markers either from a pre-defined list
input as the argument <code>specific_markers</code>, or can select
markers based on their main effect size.
</p>
<p>To select markers based on main effect size, this function 
first identifies effect score peaks using an automated
peak detection algorithm. It finds the peaks rising 
above a starting threshold and samples markers within each
peak based on the user-defined sampling density <code>peak_density</code>.
Setting <code>peak_density</code> to 0.5 will result in 50% of the markers
in a given peak being sampled uniformly at random. Sampling
reduces the redundancy among linked markers tested in the pairscan.
If LD is relatively low in the population, this density can be
increased to 1 to include all markers under a peak. If LD is high,
the density can be decreased to reduce redundancy further. 
</p>
<p>The algorithm compares the number of markers sampled to the target
defined by the user in the argument <code>num_alleles</code>. If fewer
than the target have been selected, the threshold is lowered, and 
the process is repeated until the target number of alleles have
been selected (plus or minus the number set in <code>tolerance</code>).
</p>
<p>If the number of target alleles exceeds the number of markers
genotyped, all alleles will be selected automatically.
</p>


<h3>Value</h3>

<p>Returns the <code><a href="#topic+Cape">Cape</a></code> object with a new matrix called
<code>geno_for_pairscan</code> containing the genotypes of the selected markers
for each individual.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bin_curve">bin_curve</a></code>, <code><a href="#topic+singlescan">singlescan</a></code>
</p>

<hr>
<h2 id='select_pheno'>This function selects the phenotypes in a Cape object</h2><span id='topic+select_pheno'></span>

<h3>Description</h3>

<p>Updates the pheno object to include only 'pheno_which' columns.
Optionally scale and/or normalize traits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_pheno(
  data_obj,
  pheno_which,
  min_entries = 5,
  scale_pheno = FALSE,
  rank_norm_pheno = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="select_pheno_+3A_data_obj">data_obj</code></td>
<td>
<p>a <code><a href="#topic+Cape">Cape</a></code> object</p>
</td></tr>
<tr><td><code id="select_pheno_+3A_pheno_which">pheno_which</code></td>
<td>
<p>vector of names from the parameters YAML file.
This vector should include both traits and covariates. The covariates
are assigned after trait selection.</p>
</td></tr>
<tr><td><code id="select_pheno_+3A_min_entries">min_entries</code></td>
<td>
<p>minimum number of data entries the phenotype needs 
to have for it to be included. If any trait has fewer than min_entries,
It will be removed with a warning.</p>
</td></tr>
<tr><td><code id="select_pheno_+3A_scale_pheno">scale_pheno</code></td>
<td>
<p>if TRUE then phenotypes are mean-centered and standardized</p>
</td></tr>
<tr><td><code id="select_pheno_+3A_rank_norm_pheno">rank_norm_pheno</code></td>
<td>
<p>if TRUE then phenotypes are rank Z normalized</p>
</td></tr>
</table>


<h3>Value</h3>

<p>updated <code><a href="#topic+Cape">Cape</a></code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data_obj &lt;- select_pheno(data_obj, pheno_which = c("BW_24", "INS_24", "log_GLU_24"))

## End(Not run)

</code></pre>

<hr>
<h2 id='singlescan'>Runs marker regression on each individual genetic marker</h2><span id='topic+singlescan'></span>

<h3>Description</h3>

<p>This function performs marker regression to associate
individual markers with traits (or eigentraits).
If n_perm is greater than 0, permutations are run to 
determine effect size thresholds for the alpha values
provided. The default alpha values are 0.05 and 0.01.
Covariates are specified in the cape parameter file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>singlescan(
  data_obj,
  geno_obj,
  kin_obj = NULL,
  n_perm = 0,
  alpha = c(0.01, 0.05),
  model_family = "gaussian",
  run_parallel = FALSE,
  n_cores = 4,
  verbose = FALSE,
  overwrite_alert = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="singlescan_+3A_data_obj">data_obj</code></td>
<td>
<p>a <code><a href="#topic+Cape">Cape</a></code> object</p>
</td></tr>
<tr><td><code id="singlescan_+3A_geno_obj">geno_obj</code></td>
<td>
<p>a genotype object.</p>
</td></tr>
<tr><td><code id="singlescan_+3A_kin_obj">kin_obj</code></td>
<td>
<p>a kinship object. If NULL, the kinship correction is not performed.</p>
</td></tr>
<tr><td><code id="singlescan_+3A_n_perm">n_perm</code></td>
<td>
<p>integer number of permutations. Permutation results are only
used in <code><a href="#topic+plot_singlescan">plot_singlescan</a></code>. They are not used for any other piece
of the Cape analysis and may be safely omitted. The default number of permutations
is 0.</p>
</td></tr>
<tr><td><code id="singlescan_+3A_alpha">alpha</code></td>
<td>
<p>significance level if permutations are being run. If permutations are
run effect size thresholds for each alpha level are cacluated using the extreme value
distribution.</p>
</td></tr>
<tr><td><code id="singlescan_+3A_model_family">model_family</code></td>
<td>
<p>A vector indicating the model family of the phenotypes. This can 
be either &quot;gaussian&quot; or &quot;binomial.&quot; If length 1, all phenotypes will be assigned to the 
same family. Phenotypes can be assigned different model families by
providing a vector of the same length as the number of phenotypes,
indicating how each phenotype should be modeled.</p>
</td></tr>
<tr><td><code id="singlescan_+3A_run_parallel">run_parallel</code></td>
<td>
<p>Whether to run on parallel CPUs</p>
</td></tr>
<tr><td><code id="singlescan_+3A_n_cores">n_cores</code></td>
<td>
<p>The number of CPUs to use if run_parallel is TRUE</p>
</td></tr>
<tr><td><code id="singlescan_+3A_verbose">verbose</code></td>
<td>
<p>Whether to print progress to the screen</p>
</td></tr>
<tr><td><code id="singlescan_+3A_overwrite_alert">overwrite_alert</code></td>
<td>
<p>Used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>model_family indicates the model family of the phenotypes
This can be either &quot;gaussian&quot; or &quot;binomial&quot;. If this argument
is length 1, all phenotypes will be assigned to the same
family. Phenotypes can be assigned different model families by
providing a vector of the same length as the number of phenotypes,
indicating how each phenotype should be modeled.
</p>


<h3>Value</h3>

<p>Returns a list of the singlescan results. The list is
of length seven, and has the following elements: 
alpha: The alpha values set in the argument alpha
alpha_thresh: The calculated effect size thresholds at each alpha if permutations are run.
ref_allele: The allele used as the reference allele
singlescan_effects: The effect sizes (beta coefficients) from the single-locus linear models
singlescan_t_stats: The t statistics from the single-locus linear models
locus.p_vals: Marker-level p values
locus_score_scores: Marker-level test statistics.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_singlescan">plot_singlescan</a></code>
</p>

<hr>
<h2 id='sort_by_then_by'>Sort a table by a list of columns</h2><span id='topic+sort_by_then_by'></span>

<h3>Description</h3>

<p>This internal function sorts a table first by one column,
and then by a second column.
Columns can contain numeric values or string values. These
are specified for each column by col_type.
The values of the second column are sorted by successive 
values in the first column.
if return order is TRUE, the function returns the order of
each column instead of the ordered table. To order the original
table, sort first by the order in the first column of the order
matrix and then by the offer in the second colum of the order
matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sort_by_then_by(
  tableX,
  sort_cols = c(1, 2),
  col_type = c("c", "n"),
  decreasing = FALSE,
  return_order = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sort_by_then_by_+3A_tablex">tableX</code></td>
<td>
<p>a matrix</p>
</td></tr>
<tr><td><code id="sort_by_then_by_+3A_sort_cols">sort_cols</code></td>
<td>
<p>A vector of length two, indicating which
columns in the matrix to sort by, and in which order. To
sort first by column 1 and then by column 2, sort_cols should
be c(1,2).</p>
</td></tr>
<tr><td><code id="sort_by_then_by_+3A_col_type">col_type</code></td>
<td>
<p>A vector of length two indicating whether each
column contains character values (&quot;c&quot;) or numeric values (&quot;n&quot;).
Specified in the same order as sort_cols.</p>
</td></tr>
<tr><td><code id="sort_by_then_by_+3A_decreasing">decreasing</code></td>
<td>
<p>Whether values should be sorted in decreasing order</p>
</td></tr>
<tr><td><code id="sort_by_then_by_+3A_return_order">return_order</code></td>
<td>
<p>Whether to return the sorted table (FALSE) or to 
return the order used to sort the table (TRUE). Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If return_order is FALSE, this function returns tableX sorted by sort_cols.
If return_order is TRUE, this function returns a two-column matrix indicating the order in which
to put tableX to sort it by sort_cols. To sort a table to match the order, order first by the
first column and then by the second column.
</p>

<hr>
<h2 id='write_population'>Save the cross data in R/qtl CSV format</h2><span id='topic+write_population'></span>

<h3>Description</h3>

<p>This function writes out a cape object
in a csv format readable both by <code><a href="#topic+read_population">read_population</a></code>
in Cape or by read.cross in R/qtl.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_population(
  data_obj,
  geno_obj,
  ref_allele = "A",
  na = NA,
  filename = "capeData.csv"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write_population_+3A_data_obj">data_obj</code></td>
<td>
<p>a <code><a href="#topic+Cape">Cape</a></code> object</p>
</td></tr>
<tr><td><code id="write_population_+3A_geno_obj">geno_obj</code></td>
<td>
<p>a genotype object</p>
</td></tr>
<tr><td><code id="write_population_+3A_ref_allele">ref_allele</code></td>
<td>
<p>a character, e.g., &quot;A&quot;, that represents the reference allele in the data object</p>
</td></tr>
<tr><td><code id="write_population_+3A_na">na</code></td>
<td>
<p>either NA or a character used to represent a missing data value in the output</p>
</td></tr>
<tr><td><code id="write_population_+3A_filename">filename</code></td>
<td>
<p>absolute or relative path to the output file's destination</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Writes a file to the destination path
</p>


<h3>References</h3>

<p>Broman et al. (2003) R/qtl: QTL mapping in experimental crosses. 
Bioinformatics 19:889-890 doi:10.1093/bioinformatics/btg112
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
write_population(data_obj, geno_obj)

## End(Not run)

</code></pre>

<hr>
<h2 id='write_variant_influences'>Write significant cape interactions to a csv file</h2><span id='topic+write_variant_influences'></span>

<h3>Description</h3>

<p>This function takes in the final data object and 
writes the variant influences that are at or below 
the specified significance level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_variant_influences(
  data_obj,
  p_or_q = 0.05,
  include_main_effects = TRUE,
  filename = "Variant.Influences.csv",
  delim = ",",
  mark_covar = FALSE,
  write_file = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write_variant_influences_+3A_data_obj">data_obj</code></td>
<td>
<p>a <code><a href="#topic+Cape">Cape</a></code> object</p>
</td></tr>
<tr><td><code id="write_variant_influences_+3A_p_or_q">p_or_q</code></td>
<td>
<p>A threshold indicating the maximum adjusted p value considered 
significant. If an FDR method has been used to correct for multiple testing, 
this value specifies the maximum q value considered significant.</p>
</td></tr>
<tr><td><code id="write_variant_influences_+3A_include_main_effects">include_main_effects</code></td>
<td>
<p>Whether to include main effects (TRUE) or only
interaction effects (FALSE) in the output table.</p>
</td></tr>
<tr><td><code id="write_variant_influences_+3A_filename">filename</code></td>
<td>
<p>A character vector specifying the name of the file.</p>
</td></tr>
<tr><td><code id="write_variant_influences_+3A_delim">delim</code></td>
<td>
<p>A character string indicating the delimiter in the data file. 
The default indicates a comma-separated file (&quot;,&quot;).</p>
</td></tr>
<tr><td><code id="write_variant_influences_+3A_mark_covar">mark_covar</code></td>
<td>
<p>A logical value. If TRUE, an asterisk is appended the 
names of markers used as covariates in the pair scan.</p>
</td></tr>
<tr><td><code id="write_variant_influences_+3A_write_file">write_file</code></td>
<td>
<p>A logical value indicating whether the table should be 
written to a file or simply returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The columns of the output file are the following:
Source: The marker that is the source of the directed interaction
Chr: The chromosome on which the source marker lives
Position: The genomic position of the source marker
Target: If the effect is an interaction, this column 
lists the marker that is the target of the directed interaction.
If the effect is a main effect, this column lists the 
trait that is the target of the main effect.
Chr: The chromosome on which the target marker lives.
If the effect is a main effect, this is listed as 0.
Position: The genomic position of the target marker. If
the effect is a main effect, this is listed as 1.
Conditioning: If the effect is a main effect, this column identifies
the marker on which the main effect marker was conditioned when
it had it's largest main effect.
Chr: If the effect is a main effect, this column lists the chromosome
on which the conditioning marker lives
Position: If the effect is a main effect, this column lists the
genomic position of the conditioning marker.
Effect: The effect size of the effect, either main effect or interaction.
SE: The standard error of the effect, either main effect or interaction.
|Effect|/SE: The standardized effect
P_empirical: The empirical p value calculated from permutations
p_adjusted: The p value adjusted by the method specified in the parameter file.
</p>


<h3>Value</h3>

<p>If write_file is TRUE, this function writes the results table
to a file and invisibly returns the table. If write_file is FALSE, the
function returns the results table without writing to file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
inf_table &lt;- write_variant_influences(data_obj)

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
