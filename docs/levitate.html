<!DOCTYPE html><html><head><title>Help for package levitate</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {levitate}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#default-params'><p>Default parameters inherited by other documentation</p></a></li>
<li><a href='#hotel_rooms'><p>Hotel room listings</p></a></li>
<li><a href='#internal-functions'><p>Internal functions</p></a></li>
<li><a href='#lev_best_match'><p>Get the best matched string from a list of candidates</p></a></li>
<li><a href='#lev_distance'><p>String distance metrics</p></a></li>
<li><a href='#lev_partial_ratio'><p>Ratio of the best-matching substring</p></a></li>
<li><a href='#lev_ratio'><p>String similarity ratio</p></a></li>
<li><a href='#lev_score_multiple'><p>Score multiple candidate strings against a single input</p></a></li>
<li><a href='#lev_simplify_matrix'><p>Simplify a matrix</p></a></li>
<li><a href='#lev_token_set_ratio'><p>Matching based on common tokens</p></a></li>
<li><a href='#lev_token_sort_ratio'><p>Ordered token matching</p></a></li>
<li><a href='#lev_weighted_token_ratio'><p>Weighted token similarity measure</p></a></li>
<li><a href='#lev_weighted_token_set_ratio'><p>Weighted version of <code>lev_token_set_ratio()</code></p></a></li>
<li><a href='#lev_weighted_token_sort_ratio'><p>Weighted version of lev_token_sort_ratio()</p></a></li>
<li><a href='#str_all_substrings'><p>Find all substrings of a given length</p></a></li>
<li><a href='#str_token_sort'><p>Tokenise and sort a string</p></a></li>
<li><a href='#str_tokenise'><p>Tokenise a string</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fuzzy String Comparison</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides string similarity calculations inspired by the
    Python 'thefuzz' package. Compare strings by edit distance, similarity
    ratio, best matching substring, ordered token matching and set-based
    token matching. A range of edit distance measures are available thanks
    to the 'stringdist' package.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/lewinfox/levitate/">https://github.com/lewinfox/levitate/</a>,
<a href="https://www.lewinfox.com/levitate/">https://www.lewinfox.com/levitate/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/lewinfox/levitate/issues">https://github.com/lewinfox/levitate/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>rlang, stringdist</td>
</tr>
<tr>
<td>Suggests:</td>
<td>glue, knitr, pkgdown, rmarkdown, styler, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-30 23:43:43 UTC; lewin</td>
</tr>
<tr>
<td>Author:</td>
<td>Lewin Appleton-Fox [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Lewin Appleton-Fox &lt;lewin.a.f@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-01 00:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='default-params'>Default parameters inherited by other documentation</h2><span id='topic+default-params'></span>

<h3>Description</h3>

<p>Default parameters inherited by other documentation
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="default-params_+3A_a">a</code>, <code id="default-params_+3A_b">b</code></td>
<td>
<p>The input strings</p>
</td></tr>
<tr><td><code id="default-params_+3A_pairwise">pairwise</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, only the pairwise distances between <code>a</code> and <code>b</code> will be
computed, rather than the combinations of all elements.</p>
</td></tr>
<tr><td><code id="default-params_+3A_usenames">useNames</code></td>
<td>
<p>Boolean. Use input vectors as row and column names?</p>
</td></tr>
<tr><td><code id="default-params_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code><a href="stringdist.html#topic+stringdist">stringdist::stringdistmatrix()</a></code> or
<code><a href="stringdist.html#topic+stringsim">stringdist::stringsimmatrix()</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="stringdist.html#topic+stringdist">stringdist::stringdist()</a></code>, <code><a href="stringdist.html#topic+stringsim">stringdist::stringsim()</a></code> for details on the underlying
functions and the additional options available.
</p>

<hr>
<h2 id='hotel_rooms'>Hotel room listings</h2><span id='topic+hotel_rooms'></span>

<h3>Description</h3>

<p>The dataset contains 85 descriptions of the same hotel rooms from
Expedia and Booking.com.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hotel_rooms
</code></pre>


<h3>Format</h3>

<p>A data frame with the following columns:
</p>

<dl>
<dt>expedia</dt><dd><p>The title of the room's listing on expedia.com</p>
</dd>
<dt>booking</dt><dd><p>The title of the room's listing on booking.com</p>
</dd>
</dl>



<h3>Source</h3>

<p>Based on a dataset compiled by <a href="https://github.com/susanli2016">Susan Li</a>.
</p>

<hr>
<h2 id='internal-functions'>Internal functions</h2><span id='topic+internal-functions'></span><span id='topic+internal_lev_token_set_ratio'></span><span id='topic+internal_lev_partial_ratio'></span>

<h3>Description</h3>

<p><code><a href="#topic+lev_partial_ratio">lev_partial_ratio()</a></code> and <code><a href="#topic+lev_token_set_ratio">lev_token_set_ratio()</a></code> are hard to vectorise in one go, so in the
interests of lazy thinking these &quot;internal&quot; versions contain the logic to operate on
single-length inputs, and the calling functions just <code><a href="base.html#topic+apply">apply()</a></code> them as needed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>internal_lev_token_set_ratio(a, b, pairwise = TRUE, useNames = !pairwise, ...)

internal_lev_partial_ratio(a, b, pairwise = TRUE, useNames = !pairwise, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="internal-functions_+3A_a">a</code>, <code id="internal-functions_+3A_b">b</code></td>
<td>
<p>The input strings. For these &quot;internal&quot; functions these must be length 1</p>
</td></tr>
<tr><td><code id="internal-functions_+3A_pairwise">pairwise</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, only the pairwise distances between <code>a</code> and <code>b</code> will be
computed, rather than the combinations of all elements.</p>
</td></tr>
<tr><td><code id="internal-functions_+3A_usenames">useNames</code></td>
<td>
<p>Boolean. Use input vectors as row and column names?</p>
</td></tr>
<tr><td><code id="internal-functions_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code><a href="stringdist.html#topic+stringdist">stringdist::stringdistmatrix()</a></code> or
<code><a href="stringdist.html#topic+stringsim">stringdist::stringsimmatrix()</a></code>.</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>internal_lev_token_set_ratio()</code>: See <code><a href="#topic+lev_token_set_ratio">lev_token_set_ratio()</a></code>.
</p>
</li>
<li> <p><code>internal_lev_partial_ratio()</code>: See <code><a href="#topic+lev_partial_ratio">lev_partial_ratio()</a></code>.
</p>
</li></ul>

<hr>
<h2 id='lev_best_match'>Get the best matched string from a list of candidates</h2><span id='topic+lev_best_match'></span>

<h3>Description</h3>

<p>Given an <code>input</code> string and multiple <code>candidates</code>, return the candidate with the best score as
calculated by <code>.fn</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lev_best_match(input, candidates, .fn = lev_ratio, ..., decreasing = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lev_best_match_+3A_input">input</code></td>
<td>
<p>A single string</p>
</td></tr>
<tr><td><code id="lev_best_match_+3A_candidates">candidates</code></td>
<td>
<p>One or more candidate strings to score</p>
</td></tr>
<tr><td><code id="lev_best_match_+3A_.fn">.fn</code></td>
<td>
<p>The scoring function to use, as a string or function object. Defaults to
<code><a href="#topic+lev_ratio">lev_ratio()</a></code>.</p>
</td></tr>
<tr><td><code id="lev_best_match_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code>.fn</code>.</p>
</td></tr>
<tr><td><code id="lev_best_match_+3A_decreasing">decreasing</code></td>
<td>
<p>If <code>TRUE</code> (the default), the candidate with the highest score is ranked first.
If using a comparison <code>.fn</code> that computes <em>distance</em> rather than similarity, or if you want the
worst match to be returned first, set this to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lev_score_multiple">lev_score_multiple()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lev_best_match("bilbo", c("frodo", "gandalf", "legolas"))
</code></pre>

<hr>
<h2 id='lev_distance'>String distance metrics</h2><span id='topic+lev_distance'></span>

<h3>Description</h3>

<p>Uses <code><a href="stringdist.html#topic+stringdist">stringdist::stringdistmatrix()</a></code> to compute a range of
<a href="stringdist.html#topic+stringdist-metrics">string distance metrics</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lev_distance(a, b, pairwise = TRUE, useNames = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lev_distance_+3A_a">a</code>, <code id="lev_distance_+3A_b">b</code></td>
<td>
<p>The input strings</p>
</td></tr>
<tr><td><code id="lev_distance_+3A_pairwise">pairwise</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, only the pairwise distances between <code>a</code> and <code>b</code> will be
computed, rather than the combinations of all elements.</p>
</td></tr>
<tr><td><code id="lev_distance_+3A_usenames">useNames</code></td>
<td>
<p>Boolean. Use input vectors as row and column names?</p>
</td></tr>
<tr><td><code id="lev_distance_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code><a href="stringdist.html#topic+stringdist">stringdist::stringdistmatrix()</a></code> or
<code><a href="stringdist.html#topic+stringsim">stringdist::stringsimmatrix()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric scalar, vector or matrix depending on the length of the inputs. See &quot;Details&quot;.
</p>


<h3>Details</h3>

<p>This is a thin wrapper around <code><a href="stringdist.html#topic+stringdist">stringdist::stringdistmatrix()</a></code> and mainly exists to coerce the
output into the simplest possible format (via <code><a href="#topic+lev_simplify_matrix">lev_simplify_matrix()</a></code>).
</p>
<p>The function will return the simplest possible data structure permitted by the length of the
inputs <code>a</code> and <code>b</code>. This will be a scalar if <code>a</code> and <code>b</code> are length 1, a vector if either (but
not both) is length &gt; 1, and a matrix otherwise.
</p>


<h3>Other options</h3>

<p>In addition to <code>useNames</code> <code><a href="stringdist.html#topic+stringdist">stringdist::stringdistmatrix()</a></code> provides a range of options to control
the matching, which can be passed using <code>...</code>. Refer to the <code>stringdist</code> documentation for more
information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lev_distance("Bilbo", "Frodo")

lev_distance("Bilbo", c("Frodo", "Merry"))

lev_distance("Bilbo", c("Frodo", "Merry"), useNames = FALSE)

lev_distance(c("Bilbo", "Gandalf"), c("Frodo", "Merry"))
</code></pre>

<hr>
<h2 id='lev_partial_ratio'>Ratio of the best-matching substring</h2><span id='topic+lev_partial_ratio'></span>

<h3>Description</h3>

<p>Find the best <code>lev_ratio()</code> between substrings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lev_partial_ratio(a, b, pairwise = TRUE, useNames = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lev_partial_ratio_+3A_a">a</code>, <code id="lev_partial_ratio_+3A_b">b</code></td>
<td>
<p>The input strings</p>
</td></tr>
<tr><td><code id="lev_partial_ratio_+3A_pairwise">pairwise</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, only the pairwise distances between <code>a</code> and <code>b</code> will be
computed, rather than the combinations of all elements.</p>
</td></tr>
<tr><td><code id="lev_partial_ratio_+3A_usenames">useNames</code></td>
<td>
<p>Boolean. Use input vectors as row and column names?</p>
</td></tr>
<tr><td><code id="lev_partial_ratio_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code><a href="stringdist.html#topic+stringdist">stringdist::stringdistmatrix()</a></code> or
<code><a href="stringdist.html#topic+stringsim">stringdist::stringsimmatrix()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric scalar, vector or matrix depending on the length of the inputs.
</p>


<h3>Details</h3>

<p>If string <code>a</code> has length <code>len_a</code> and is shorter than string <code>b</code>, this function finds the highest
<code><a href="#topic+lev_ratio">lev_ratio()</a></code> of all the <code>len_a</code>-long substrings of <code>b</code> (and vice versa).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lev_ratio("Bruce Springsteen", "Bruce Springsteen and the E Street Band")

# Here the two "Bruce Springsteen" strings will match perfectly.
lev_partial_ratio("Bruce Springsteen", "Bruce Springsteen and the E Street Band")
</code></pre>

<hr>
<h2 id='lev_ratio'>String similarity ratio</h2><span id='topic+lev_ratio'></span>

<h3>Description</h3>

<p>String similarity ratio
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lev_ratio(a, b, pairwise = TRUE, useNames = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lev_ratio_+3A_a">a</code>, <code id="lev_ratio_+3A_b">b</code></td>
<td>
<p>The input strings</p>
</td></tr>
<tr><td><code id="lev_ratio_+3A_pairwise">pairwise</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, only the pairwise distances between <code>a</code> and <code>b</code> will be
computed, rather than the combinations of all elements.</p>
</td></tr>
<tr><td><code id="lev_ratio_+3A_usenames">useNames</code></td>
<td>
<p>Boolean. Use input vectors as row and column names?</p>
</td></tr>
<tr><td><code id="lev_ratio_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code><a href="stringdist.html#topic+stringdist">stringdist::stringdistmatrix()</a></code> or
<code><a href="stringdist.html#topic+stringsim">stringdist::stringsimmatrix()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric scalar, vector or matrix depending on the length of the inputs.
</p>


<h3>Details</h3>

<p>This is a thin wrapper around <code><a href="stringdist.html#topic+stringsim">stringdist::stringsimmatrix()</a></code> and mainly exists to coerce the
output into the simplest possible format (via <code><a href="#topic+lev_simplify_matrix">lev_simplify_matrix()</a></code>).
</p>
<p>The function will return the simplest possible data structure permitted by the length of the
inputs <code>a</code> and <code>b</code>. This will be a scalar if <code>a</code> and <code>b</code> are length 1, a vector if either (but
not both) is length &gt; 1, and a matrix otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lev_ratio("Bilbo", "Frodo")

lev_ratio("Bilbo", c("Frodo", "Merry"))

lev_ratio("Bilbo", c("Frodo", "Merry"), useNames = FALSE)

lev_ratio(c("Bilbo", "Gandalf"), c("Frodo", "Merry"))
</code></pre>

<hr>
<h2 id='lev_score_multiple'>Score multiple candidate strings against a single input</h2><span id='topic+lev_score_multiple'></span>

<h3>Description</h3>

<p>Given a single <code>input</code> string and multiple <code>candidates</code>, compute scores for each candidate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lev_score_multiple(input, candidates, .fn = lev_ratio, ..., decreasing = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lev_score_multiple_+3A_input">input</code></td>
<td>
<p>A single string</p>
</td></tr>
<tr><td><code id="lev_score_multiple_+3A_candidates">candidates</code></td>
<td>
<p>One or more candidate strings to score</p>
</td></tr>
<tr><td><code id="lev_score_multiple_+3A_.fn">.fn</code></td>
<td>
<p>The scoring function to use, as a string or function object. Defaults to
<code><a href="#topic+lev_ratio">lev_ratio()</a></code>.</p>
</td></tr>
<tr><td><code id="lev_score_multiple_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code>.fn</code>.</p>
</td></tr>
<tr><td><code id="lev_score_multiple_+3A_decreasing">decreasing</code></td>
<td>
<p>If <code>TRUE</code> (the default), the candidate with the highest score is ranked first.
If using a comparison <code>.fn</code> that computes <em>distance</em> rather than similarity, or if you want the
worst match to be returned first, set this to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list where the keys are <code>candidates</code> and the values are the scores. The list is sorted
according to the <code>decreasing</code> parameter, so by default higher scores are first.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lev_best_match">lev_best_match()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lev_score_multiple("bilbo", c("frodo", "gandalf", "legolas"))
</code></pre>

<hr>
<h2 id='lev_simplify_matrix'>Simplify a matrix</h2><span id='topic+lev_simplify_matrix'></span>

<h3>Description</h3>

<p>Given an input matrix, try and simplify it to a scalar or vector. This requires that one or both
of the dimensions are 1. If the matrix has <code><a href="base.html#topic+dimnames">dimnames()</a></code> and the output has more than one item,
name the elements according to the longest dimname.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lev_simplify_matrix(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lev_simplify_matrix_+3A_m">m</code></td>
<td>
<p>A matrix. If <code>m</code> is not a matrix it is returned unchanged.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar, vector or matrix as described above.
</p>

<hr>
<h2 id='lev_token_set_ratio'>Matching based on common tokens</h2><span id='topic+lev_token_set_ratio'></span>

<h3>Description</h3>

<p>Compare stings based on shared tokens.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lev_token_set_ratio(a, b, pairwise = TRUE, useNames = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lev_token_set_ratio_+3A_a">a</code>, <code id="lev_token_set_ratio_+3A_b">b</code></td>
<td>
<p>The input strings</p>
</td></tr>
<tr><td><code id="lev_token_set_ratio_+3A_pairwise">pairwise</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, only the pairwise distances between <code>a</code> and <code>b</code> will be
computed, rather than the combinations of all elements.</p>
</td></tr>
<tr><td><code id="lev_token_set_ratio_+3A_usenames">useNames</code></td>
<td>
<p>Boolean. Use input vectors as row and column names?</p>
</td></tr>
<tr><td><code id="lev_token_set_ratio_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code><a href="stringdist.html#topic+stringdist">stringdist::stringdistmatrix()</a></code> or
<code><a href="stringdist.html#topic+stringsim">stringdist::stringsimmatrix()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric scalar, vector or matrix depending on the length of the inputs.
</p>


<h3>Details</h3>

<p>Similar to <code><a href="#topic+lev_token_sort_ratio">lev_token_sort_ratio()</a></code> this function breaks the input down into tokens. It then
identifies any common tokens between strings and creates three new strings:
</p>
<div class="sourceCode"><pre>x &lt;- {common_tokens}
y &lt;- {common_tokens}{remaining_unique_tokens_from_string_a}
z &lt;- {common_tokens}{remaining_unique_tokens_from_string_b}
</pre></div>
<p>and performs three pairwise <code><a href="#topic+lev_ratio">lev_ratio()</a></code> calculations between them (<code>x</code> vs <code>y</code>, <code>y</code> vs <code>z</code> and
<code>x</code> vs <code>z</code>). The highest of those three ratios is returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lev_token_sort_ratio">lev_token_sort_ratio()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- "the quick brown fox jumps over the lazy dog"
y &lt;- "my lazy dog was jumped over by a quick brown fox"

lev_ratio(x, y)

lev_token_sort_ratio(x, y)

lev_token_set_ratio(x, y)
</code></pre>

<hr>
<h2 id='lev_token_sort_ratio'>Ordered token matching</h2><span id='topic+lev_token_sort_ratio'></span>

<h3>Description</h3>

<p>Compares strings by tokenising them, sorting the tokens alphabetically and then computing the
<code><a href="#topic+lev_ratio">lev_ratio()</a></code> of the result. This means that the order of words is irrelevant which can be
helpful in some circumstances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lev_token_sort_ratio(a, b, pairwise = TRUE, useNames = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lev_token_sort_ratio_+3A_a">a</code>, <code id="lev_token_sort_ratio_+3A_b">b</code></td>
<td>
<p>The input strings</p>
</td></tr>
<tr><td><code id="lev_token_sort_ratio_+3A_pairwise">pairwise</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, only the pairwise distances between <code>a</code> and <code>b</code> will be
computed, rather than the combinations of all elements.</p>
</td></tr>
<tr><td><code id="lev_token_sort_ratio_+3A_usenames">useNames</code></td>
<td>
<p>Boolean. Use input vectors as row and column names?</p>
</td></tr>
<tr><td><code id="lev_token_sort_ratio_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code><a href="stringdist.html#topic+stringdist">stringdist::stringdistmatrix()</a></code> or
<code><a href="stringdist.html#topic+stringsim">stringdist::stringsimmatrix()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric scalar, vector or matrix depending on the length of the inputs.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lev_token_set_ratio">lev_token_set_ratio()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- "Episode IV - Star Wars: A New Hope"
y &lt;- "Star Wars Episode IV - New Hope"

# Because the order of words is different the simple approach gives a low match ratio.
lev_ratio(x, y)

# The sorted token approach ignores word order.
lev_token_sort_ratio(x, y)
</code></pre>

<hr>
<h2 id='lev_weighted_token_ratio'>Weighted token similarity measure</h2><span id='topic+lev_weighted_token_ratio'></span>

<h3>Description</h3>

<p>Computes similarity but allows you to assign weights to specific tokens. This is useful, for
example, when you have a frequently-occurring string that doesn't contain useful information. See
examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lev_weighted_token_ratio(a, b, weights = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lev_weighted_token_ratio_+3A_a">a</code>, <code id="lev_weighted_token_ratio_+3A_b">b</code></td>
<td>
<p>The input strings</p>
</td></tr>
<tr><td><code id="lev_weighted_token_ratio_+3A_weights">weights</code></td>
<td>
<p>List of token weights. For example, <code>weights = list(foo = 0.9, bar = 0.1)</code>. Any
tokens omitted from <code>weights</code> will be given a weight of 1.</p>
</td></tr>
<tr><td><code id="lev_weighted_token_ratio_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code><a href="stringdist.html#topic+stringdist">stringdist::stringdistmatrix()</a></code> or
<code><a href="stringdist.html#topic+stringsim">stringdist::stringsimmatrix()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A float
</p>


<h3>Details</h3>

<p>The algorithm used here is as follows:
</p>

<ul>
<li><p> Tokenise the input strings
</p>
</li>
<li><p> Compute the edit distance between each pair of tokens
</p>
</li>
<li><p> Compute the maximum edit distance between each pair of tokens
</p>
</li>
<li><p> Apply any weights from the <code>weights</code> argument
</p>
</li>
<li><p> Return <code>1 - (sum(weighted_edit_distances) / sum(weighted_max_edit_distance))</code>
</p>
</li></ul>



<h3>See Also</h3>

<p>Other weighted token functions: 
<code><a href="#topic+lev_weighted_token_set_ratio">lev_weighted_token_set_ratio</a>()</code>,
<code><a href="#topic+lev_weighted_token_sort_ratio">lev_weighted_token_sort_ratio</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lev_weighted_token_ratio("jim ltd", "tim ltd")

lev_weighted_token_ratio("tim ltd", "jim ltd", weights = list(ltd = 0.1))
</code></pre>

<hr>
<h2 id='lev_weighted_token_set_ratio'>Weighted version of <code>lev_token_set_ratio()</code></h2><span id='topic+lev_weighted_token_set_ratio'></span>

<h3>Description</h3>

<p>Weighted version of <code>lev_token_set_ratio()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lev_weighted_token_set_ratio(a, b, weights = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lev_weighted_token_set_ratio_+3A_a">a</code>, <code id="lev_weighted_token_set_ratio_+3A_b">b</code></td>
<td>
<p>The input strings</p>
</td></tr>
<tr><td><code id="lev_weighted_token_set_ratio_+3A_weights">weights</code></td>
<td>
<p>List of token weights. For example, <code>weights = list(foo = 0.9, bar = 0.1)</code>. Any
tokens omitted from <code>weights</code> will be given a weight of 1.</p>
</td></tr>
<tr><td><code id="lev_weighted_token_set_ratio_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code><a href="stringdist.html#topic+stringdist">stringdist::stringdistmatrix()</a></code> or
<code><a href="stringdist.html#topic+stringsim">stringdist::stringsimmatrix()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Float
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lev_token_set_ratio">lev_token_set_ratio()</a></code>
</p>
<p>Other weighted token functions: 
<code><a href="#topic+lev_weighted_token_ratio">lev_weighted_token_ratio</a>()</code>,
<code><a href="#topic+lev_weighted_token_sort_ratio">lev_weighted_token_sort_ratio</a>()</code>
</p>

<hr>
<h2 id='lev_weighted_token_sort_ratio'>Weighted version of lev_token_sort_ratio()</h2><span id='topic+lev_weighted_token_sort_ratio'></span>

<h3>Description</h3>

<p>This function tokenises inputs, sorts tokens and computes similarities for each pair of tokens.
Similarity scores are weighted based on the <code>weights</code> argument, and a total similarity score is
returned in the same manner as <code><a href="#topic+lev_weighted_token_ratio">lev_weighted_token_ratio()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lev_weighted_token_sort_ratio(a, b, weights = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lev_weighted_token_sort_ratio_+3A_a">a</code>, <code id="lev_weighted_token_sort_ratio_+3A_b">b</code></td>
<td>
<p>The input strings</p>
</td></tr>
<tr><td><code id="lev_weighted_token_sort_ratio_+3A_weights">weights</code></td>
<td>
<p>List of token weights. For example, <code>weights = list(foo = 0.9, bar = 0.1)</code>. Any
tokens omitted from <code>weights</code> will be given a weight of 1.</p>
</td></tr>
<tr><td><code id="lev_weighted_token_sort_ratio_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code><a href="stringdist.html#topic+stringdist">stringdist::stringdistmatrix()</a></code> or
<code><a href="stringdist.html#topic+stringsim">stringdist::stringsimmatrix()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Float
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lev_token_sort_ratio">lev_token_sort_ratio()</a></code>
</p>
<p>Other weighted token functions: 
<code><a href="#topic+lev_weighted_token_ratio">lev_weighted_token_ratio</a>()</code>,
<code><a href="#topic+lev_weighted_token_set_ratio">lev_weighted_token_set_ratio</a>()</code>
</p>

<hr>
<h2 id='str_all_substrings'>Find all substrings of a given length</h2><span id='topic+str_all_substrings'></span>

<h3>Description</h3>

<p>Find all substrings of a given length
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_all_substrings(x, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_all_substrings_+3A_x">x</code></td>
<td>
<p>The input string. Non-character inputs will be coerced with <code><a href="base.html#topic+as.character">as.character()</a></code>.</p>
</td></tr>
<tr><td><code id="str_all_substrings_+3A_n">n</code></td>
<td>
<p>The length of the desired substrings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector containing all the length <code>n</code> substrings of <code>x</code>. If <code>x</code> has length &gt;
then a list is returned containing an entry for each input element.
</p>

<hr>
<h2 id='str_token_sort'>Tokenise and sort a string</h2><span id='topic+str_token_sort'></span>

<h3>Description</h3>

<p>Given an input string, tokenise it (using <code><a href="#topic+str_tokenise">str_tokenise()</a></code>), sort the tokens alphabetically and
return the result as a single space-separated string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_token_sort(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_token_sort_+3A_x">x</code></td>
<td>
<p>The input string. Non-character inputs will be coerced with <code><a href="base.html#topic+as.character">as.character()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector the same length as <code>x</code> containing the sorted tokens.
</p>

<hr>
<h2 id='str_tokenise'>Tokenise a string</h2><span id='topic+str_tokenise'></span>

<h3>Description</h3>

<p>Splits an input string into tokens. A wrapper for <code><a href="base.html#topic+strsplit">strsplit()</a></code> with a predefined split regex of
<code style="white-space: pre;">&#8288;[^[:alnum:]]&#8288;</code>, i.e. anything except <code style="white-space: pre;">&#8288;[a-zA-Z0-9]&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_tokenise(x, split = "[^[:alnum:]]+")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_tokenise_+3A_x">x</code></td>
<td>
<p>The input string. Non-character inputs will be coerced with <code><a href="base.html#topic+as.character">as.character()</a></code>.</p>
</td></tr>
<tr><td><code id="str_tokenise_+3A_split">split</code></td>
<td>
<p>The regular expression to split on. See <code><a href="base.html#topic+strsplit">strsplit()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing one character vector for each element of <code>x</code>.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
