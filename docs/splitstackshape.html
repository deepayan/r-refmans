<!DOCTYPE html><html><head><title>Help for package splitstackshape</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {splitstackshape}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#charMat'><p>Create a Binary Matrix from a List of Character Values</p></a></li>
<li><a href='#concat.split'><p>Split Concatenated Cells in a Dataset</p></a></li>
<li><a href='#concat.split.compact'><p>Split Concatenated Cells into a Condensed Format</p></a></li>
<li><a href='#concat.split.expanded'><p>Split Concatenated Values into their Corresponding Column Position</p></a></li>
<li><a href='#concat.split.list'><p>Split Concatenated Cells into a List Format</p></a></li>
<li><a href='#concat.split.multiple'><p>Split Concatenated Cells and Optionally Reshape the Output</p></a></li>
<li><a href='#concat.test'><p>Example Dataset with Concatenated Cells</p></a></li>
<li><a href='#cSplit'><p>Split Concatenated Values into Separate Values</p></a></li>
<li><a href='#expandRows'><p>Expand the Rows of a Dataset</p></a></li>
<li><a href='#FacsToChars'><p>Convert All Factor Columns to Character Columns</p></a></li>
<li><a href='#getanID'><p>Add an &quot;id&quot; Variable to a Dataset</p></a></li>
<li><a href='#listCol_l'><p>Unlist a Column Stored as a List</p></a></li>
<li><a href='#listCol_w'><p>Flatten a Column Stored as a List</p></a></li>
<li><a href='#merged.stack'><p>Take a List of Stacked data.tables and Merge Them</p></a></li>
<li><a href='#Names'><p>Dataset Names as a Character Vector, Always</p></a></li>
<li><a href='#NoSep'><p>Split Basic Alphanumeric Strings Which Have No Separators</p></a></li>
<li><a href='#numMat'><p>Create a Numeric Matrix from a List of Values</p></a></li>
<li><a href='#othernames'><p>Extract All Names From a Dataset Other Than the Ones Listed</p></a></li>
<li><a href='#read.concat'><p>Read Concatenated Character Vectors Into a data.frame</p></a></li>
<li><a href='#Reshape'><p>Reshape Wide Data Into a Semi-long Form</p></a></li>
<li><a href='#splitstackshape-package'><p>splitstackshape</p></a></li>
<li><a href='#Stacked'><p>Stack Columns from a Wide Form to a Long Form</p></a></li>
<li><a href='#stratified'><p>Take a Stratified Sample From a Dataset</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Stack and Reshape Datasets After Splitting Concatenated Values</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.8</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-04-21</td>
</tr>
<tr>
<td>Author:</td>
<td>Ananda Mahto</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ananda Mahto &lt;mrdwab@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Online data collection tools like Google Forms often export
    multiple-response questions with data concatenated in cells. The
    concat.split (cSplit) family of functions splits such data into separate 
    cells. The package also includes functions to stack groups of columns and 
    to reshape wide data, even when the data are "unbalanced"&mdash;something 
    which reshape (from base R) does not handle, and which melt and dcast from 
    reshape2 do not easily handle.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table (&ge; 1.9.4)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://github.com/mrdwab/splitstackshape">http://github.com/mrdwab/splitstackshape</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="http://github.com/mrdwab/splitstackshape/issues">http://github.com/mrdwab/splitstackshape/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, testthat</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-04-21 19:38:22 UTC; mrdwab</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-04-21 20:00:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='charMat'>Create a Binary Matrix from a List of Character Values</h2><span id='topic+charMat'></span>

<h3>Description</h3>

<p>Create a binary matrix from a list of character values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>charMat(listOfValues, fill = NA, mode = "binary")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="charMat_+3A_listofvalues">listOfValues</code></td>
<td>
<p>A <code>list</code> of input values to be inserted in a matrix.</p>
</td></tr>
<tr><td><code id="charMat_+3A_fill">fill</code></td>
<td>
<p>The initializing fill value for the empty matrix.</p>
</td></tr>
<tr><td><code id="charMat_+3A_mode">mode</code></td>
<td>
<p>Either <code>"binary"</code> or <code>"value"</code>. Defaults to <code>"binary"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is primarily a helper function for the <code><a href="#topic+concat.split">concat.split()</a></code> function when
creating the &quot;expanded&quot; structure. The input is anticipated to be a <code>list</code> of
values obtained using <code><a href="base.html#topic+strsplit">base::strsplit()</a></code>.
</p>


<h3>Value</h3>

<p>A <code>matrix</code>.
</p>


<h3>Author(s)</h3>

<p>Ananda Mahto
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+strsplit">base::strsplit()</a></code>, <code><a href="#topic+numMat">numMat()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
invec &lt;- c("rock,electro","electro","rock,jazz")
A &lt;- strsplit(invec, ",")
splitstackshape:::charMat(A)
splitstackshape:::charMat(A, 0)
splitstackshape:::charMat(A, mode = "value")

</code></pre>

<hr>
<h2 id='concat.split'>Split Concatenated Cells in a Dataset</h2><span id='topic+concat.split'></span>

<h3>Description</h3>

<p>The <code>concat.split</code> function takes a column with multiple values, splits
the values into a <code>list</code> or into separate columns, and returns a new
<code>data.frame</code> or <code>data.table</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>concat.split(data, split.col, sep = ",", structure = "compact",
  mode = NULL, type = NULL, drop = FALSE, fixed = FALSE,
  fill = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="concat.split_+3A_data">data</code></td>
<td>
<p>The source <code>data.frame</code> or <code>data.table</code>.</p>
</td></tr>
<tr><td><code id="concat.split_+3A_split.col">split.col</code></td>
<td>
<p>The variable that needs to be split; can be specified
either by the column number or the variable name.</p>
</td></tr>
<tr><td><code id="concat.split_+3A_sep">sep</code></td>
<td>
<p>The character separating each value (defaults to <code>","</code>).</p>
</td></tr>
<tr><td><code id="concat.split_+3A_structure">structure</code></td>
<td>
<p>Can be either <code>"compact"</code>, <code>"expanded"</code>, or <code>list</code>. Defaults
to <code>"compact"</code>. See Details.</p>
</td></tr>
<tr><td><code id="concat.split_+3A_mode">mode</code></td>
<td>
<p>Can be either <code>"binary"</code> or <code>"value"</code> (where <code>"binary"</code> is default
and it recodes values to 1 or <code>NA</code>, like Boolean data, but without assuming 0
when data is not available). This setting only applies when
<code>structure = "expanded"</code>; a warning message will be issued if used with other
structures.</p>
</td></tr>
<tr><td><code id="concat.split_+3A_type">type</code></td>
<td>
<p>Can be either <code>"numeric"</code> or <code>"character"</code> (where <code>"numeric"</code> is
default).  This setting only applies when <code>structure = "expanded"</code>; a warning
message will be issued if used with other structures.</p>
</td></tr>
<tr><td><code id="concat.split_+3A_drop">drop</code></td>
<td>
<p>Logical (whether to remove the original variable from the output
or not). Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="concat.split_+3A_fixed">fixed</code></td>
<td>
<p>Is the input for the <code>sep</code> value <em>fixed</em>, or a <em>regular
expression</em>? See Details.</p>
</td></tr>
<tr><td><code id="concat.split_+3A_fill">fill</code></td>
<td>
<p>The &quot;fill&quot; value for missing values when <code>structure = "expanded"</code>.
Defaults to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="concat.split_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code><a href="#topic+cSplit">cSplit()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><em>structure</em>
</p>

<ul>
<li> <p><code>"compact"</code> creates as many columns as the maximum length of the resulting
split. This is the most useful general-case application of this function.
</p>
</li>
<li><p> When the input is numeric, <code>"expanded"</code> creates as many columns as the
maximum value of the input data. This is most useful when converting to
<code>mode = "binary"</code>.
</p>
</li>
<li> <p><code>"list"</code> creates a single new column that is structurally a <code>list</code> within a
<code>data.frame</code> or <code>data.table</code>.
</p>
</li></ul>

<p><em>fixed</em>
</p>

<ul>
<li><p> When <code>structure = "expanded"</code> or <code>structure = "list"</code>, it is possible to
supply a a regular expression containing the characters to split on. For
example, to split on <code>","</code>, <code>";"</code>, or <code>"|"</code>, you can set <code>sep = ",|;|\|"</code> or
<code>sep = "[,;|]"</code>, and <code>fixed = FALSE</code> to split on any of those characters.
</p>
</li></ul>



<h3>Note</h3>

<p>This is more of a &quot;legacy&quot; or &quot;convenience&quot; wrapper function encompassing
the features available in the separated functions of <code><a href="#topic+cSplit">cSplit()</a></code>, <code><a href="#topic+cSplit_l">cSplit_l()</a></code>,
and <code><a href="#topic+cSplit_e">cSplit_e()</a></code>.
</p>


<h3>Author(s)</h3>

<p>Ananda Mahto
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cSplit">cSplit()</a></code>, <code><a href="#topic+cSplit_l">cSplit_l()</a></code>, <code><a href="#topic+cSplit_e">cSplit_e()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Load some data
temp &lt;- head(concat.test)

# Split up the second column, selecting by column number
concat.split(temp, 2)

# ... or by name, and drop the offensive first column
concat.split(temp, "Likes", drop = TRUE)

# The "Hates" column uses a different separator
concat.split(temp, "Hates", sep = ";", drop = TRUE)

## Not run: 
# You'll get a warning here, when trying to retain the original values
concat.split(temp, 2, mode = "value", drop = TRUE)

## End(Not run)

# Try again. Notice the differing number of resulting columns
concat.split(temp, 2, structure = "expanded",
mode = "value", type = "numeric", drop = TRUE)

# Let's try splitting some strings... Same syntax
concat.split(temp, 3, drop = TRUE)

# Strings can also be split to binary representations
concat.split(temp, 3, structure = "expanded",
type = "character", fill = 0, drop = TRUE)

# Split up the "Likes column" into a list variable; retain original column
head(concat.split(concat.test, 2, structure = "list", drop = FALSE))

# View the structure of the output to verify
# that the new column is a list; note the
# difference between "Likes" and "Likes_list".
str(concat.split(temp, 2, structure = "list", drop = FALSE))

</code></pre>

<hr>
<h2 id='concat.split.compact'>Split Concatenated Cells into a Condensed Format</h2><span id='topic+concat.split.compact'></span>

<h3>Description</h3>

<p>The default splitting method for <code>concat.split</code>. Formerly based on
<code><a href="#topic+read.concat">read.concat()</a></code> but presently a simple wrapper around <code><a href="#topic+cSplit">cSplit()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>concat.split.compact(data, split.col, sep = ",", drop = FALSE,
  fixed = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="concat.split.compact_+3A_data">data</code></td>
<td>
<p>The input <code>data.frame</code> or <code>data.table</code>.</p>
</td></tr>
<tr><td><code id="concat.split.compact_+3A_split.col">split.col</code></td>
<td>
<p>The column that need to be split.</p>
</td></tr>
<tr><td><code id="concat.split.compact_+3A_sep">sep</code></td>
<td>
<p>The character separating each value.</p>
</td></tr>
<tr><td><code id="concat.split.compact_+3A_drop">drop</code></td>
<td>
<p>Logical. Should the original variable be dropped? Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="concat.split.compact_+3A_fixed">fixed</code></td>
<td>
<p>Logical. Should the split character be treated as a fixed
pattern (<code>TRUE</code>) or a regular expression (<code>FALSE</code>)? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="concat.split.compact_+3A_...">...</code></td>
<td>
<p>optional arguments to pass to <code>cSplit</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.table</code>.
</p>


<h3>Note</h3>

<p>THIS FUNCTION IS DEPRECATED AND WILL BE REMOVED FROM LATER VERSIONS OF
&quot;SPLITSTACKSHAPE&quot;. It no longer does anything different from <code><a href="#topic+cSplit">cSplit()</a></code>. It is
recommended that you transition your code to the <code>cSplit</code> function instead.
</p>


<h3>Author(s)</h3>

<p>Ananda Mahto
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.concat">read.concat()</a></code>, <code><a href="#topic+cSplit">cSplit()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
temp &lt;- head(concat.test)
concat.split.compact(temp, "Likes")
concat.split.compact(temp, 4, ";")

## Extra arguments to cSplit
concat.split.compact(temp, "Siblings", drop = TRUE, stripWhite = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='concat.split.expanded'>Split Concatenated Values into their Corresponding Column Position</h2><span id='topic+concat.split.expanded'></span><span id='topic+cSplit_e'></span>

<h3>Description</h3>

<p>&quot;Expand&quot; concatenated numeric or character values to their relevant position
in a <code>data.frame</code> or <code>data.table</code> or create a binary representation of such data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cSplit_e(data, split.col, sep = ",", mode = NULL, type = "numeric",
  drop = FALSE, fixed = TRUE, fill = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="concat.split.expanded_+3A_data">data</code></td>
<td>
<p>The source <code>data.frame</code> or <code>data.table</code>.</p>
</td></tr>
<tr><td><code id="concat.split.expanded_+3A_split.col">split.col</code></td>
<td>
<p>The variable that needs to be split (either name or index
position).</p>
</td></tr>
<tr><td><code id="concat.split.expanded_+3A_sep">sep</code></td>
<td>
<p>The character separating each value. Can also be a regular
expression.</p>
</td></tr>
<tr><td><code id="concat.split.expanded_+3A_mode">mode</code></td>
<td>
<p>Can be either <code>"binary"</code> (where presence of a number in a given
column is converted to &quot;1&quot;) or <code>"value"</code> (where the value is retained and not
recoded to &quot;1&quot;). Defaults to <code>"binary"</code>.</p>
</td></tr>
<tr><td><code id="concat.split.expanded_+3A_type">type</code></td>
<td>
<p>Can be either <code>"numeric"</code> (where the items being split are
integers) or <code>"character"</code> (where the items being split are character
strings). Defaults to <code>"numeric"</code>.</p>
</td></tr>
<tr><td><code id="concat.split.expanded_+3A_drop">drop</code></td>
<td>
<p>Logical. Should the original variable be dropped? Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="concat.split.expanded_+3A_fixed">fixed</code></td>
<td>
<p>Used for <code><a href="base.html#topic+strsplit">base::strsplit()</a></code> for allowing regular expressions to
be used.</p>
</td></tr>
<tr><td><code id="concat.split.expanded_+3A_fill">fill</code></td>
<td>
<p>Desired &quot;fill&quot; value. Defaults to <code>NA</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> or <code>data.table</code> depending on the source input.
</p>


<h3>Author(s)</h3>

<p>Ananda Mahto
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cSplit">cSplit()</a></code>, <code><a href="#topic+cSplit_l">cSplit_l()</a></code>, <code><a href="#topic+numMat">numMat()</a></code>, <code><a href="#topic+charMat">charMat()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
temp &lt;- head(concat.test)
cSplit_e(temp, "Likes")
cSplit_e(temp, 4, ";", fill = 0)
 
## The old function name still works
concat.split.expanded(temp, "Likes")
concat.split.expanded(temp, 4, ";", fill = 0)
concat.split.expanded(temp, 4, ";", mode = "value", drop = TRUE)
concat.split.expanded(temp, "Siblings", type = "character", drop = TRUE)

</code></pre>

<hr>
<h2 id='concat.split.list'>Split Concatenated Cells into a List Format</h2><span id='topic+concat.split.list'></span><span id='topic+cSplit_l'></span>

<h3>Description</h3>

<p>Takes a column in a <code>data.frame</code> or <code>data.table</code> with multiple values, splits
the values into a <code>list</code>, and returns a new <code>data.frame</code> or <code>data.table</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cSplit_l(data, split.col, sep = ",", drop = FALSE, fixed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="concat.split.list_+3A_data">data</code></td>
<td>
<p>The source <code>data.frame</code> or <code>data.table</code>.</p>
</td></tr>
<tr><td><code id="concat.split.list_+3A_split.col">split.col</code></td>
<td>
<p>The variable that needs to be split (either name or index
position).</p>
</td></tr>
<tr><td><code id="concat.split.list_+3A_sep">sep</code></td>
<td>
<p>The character separating each value. Can also be a regular expression.</p>
</td></tr>
<tr><td><code id="concat.split.list_+3A_drop">drop</code></td>
<td>
<p>Logical. Should the original variable be dropped? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="concat.split.list_+3A_fixed">fixed</code></td>
<td>
<p>Used for <code><a href="base.html#topic+strsplit">base::strsplit()</a></code> for allowing regular expressions to
be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> or <code>data.table</code> with the concatenated column split and
added as a <code>list</code>.
</p>


<h3>Author(s)</h3>

<p>Ananda Mahto
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cSplit">cSplit()</a></code>, <code><a href="#topic+cSplit_e">cSplit_e()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
temp &lt;- head(concat.test)
str(cSplit_l(temp, "Likes"))
cSplit_l(temp, 4, ";")

## The old function name still works
str(concat.split.list(temp, "Likes"))
concat.split.list(temp, 4, ";")
concat.split.list(temp, 4, ";", drop = TRUE)

</code></pre>

<hr>
<h2 id='concat.split.multiple'>Split Concatenated Cells and Optionally Reshape the Output</h2><span id='topic+concat.split.multiple'></span>

<h3>Description</h3>

<p>This is a wrapper for the <code><a href="#topic+cSplit">cSplit()</a></code> function to maintain backwards
compatibility with earlier versions of the &quot;splitstackshape&quot; package. It
allows the user to split multiple columns at once and optionally convert the
results into a &quot;long&quot; format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>concat.split.multiple(data, split.cols, seps = ",", direction = "wide",
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="concat.split.multiple_+3A_data">data</code></td>
<td>
<p>The source <code>data.frame</code> or <code>data.table</code>.</p>
</td></tr>
<tr><td><code id="concat.split.multiple_+3A_split.cols">split.cols</code></td>
<td>
<p>A vector of columns that need to be split.</p>
</td></tr>
<tr><td><code id="concat.split.multiple_+3A_seps">seps</code></td>
<td>
<p>A vector of the separator character used in each column. If all
columns use the same character, you can enter that single character.</p>
</td></tr>
<tr><td><code id="concat.split.multiple_+3A_direction">direction</code></td>
<td>
<p>The desired form of the resulting <code>data.frame</code> or <code>data.table</code>,
either <code>"wide"</code> or <code>"long"</code>.  Defaults to <code>"wide"</code>.</p>
</td></tr>
<tr><td><code id="concat.split.multiple_+3A_...">...</code></td>
<td>
<p>Other arguments to <code><a href="#topic+cSplit">cSplit()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.table</code>.
</p>


<h3>Author(s)</h3>

<p>Ananda Mahto
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cSplit">cSplit()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
temp &lt;- head(concat.test)
concat.split.multiple(temp, split.cols = c("Likes", "Hates", "Siblings"),
                      seps = c(",", ";", ","))
concat.split.multiple(temp, split.cols = c("Likes", "Siblings"),
                      seps = ",", direction = "long")

## End(Not run)

</code></pre>

<hr>
<h2 id='concat.test'>Example Dataset with Concatenated Cells</h2><span id='topic+concat.test'></span>

<h3>Description</h3>

<p>This is a sample dataset to demonstrate the different features of the
<code><a href="#topic+concat.split">concat.split()</a></code> family of functions.
</p>


<h3>Format</h3>

<p>A <code>data.frame</code> in which many columns contain concatenated cells.</p>

<hr>
<h2 id='cSplit'>Split Concatenated Values into Separate Values</h2><span id='topic+cSplit'></span>

<h3>Description</h3>

<p>The <code>cSplit</code> function is designed to quickly and conveniently split
concatenated data into separate values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cSplit(indt, splitCols, sep = ",", direction = "wide", fixed = TRUE,
  drop = TRUE, stripWhite = TRUE, makeEqual = NULL,
  type.convert = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cSplit_+3A_indt">indt</code></td>
<td>
<p>The input <code>data.frame</code> or <code>data.table</code>.</p>
</td></tr>
<tr><td><code id="cSplit_+3A_splitcols">splitCols</code></td>
<td>
<p>The column or columns that need to be split.</p>
</td></tr>
<tr><td><code id="cSplit_+3A_sep">sep</code></td>
<td>
<p>The values that serve as a delimiter <em>within</em> each column. This
can be a single value if all columns have the same delimiter, or a vector of
values <em>in the same order as the delimiters in each of the <code>splitCols</code></em>.</p>
</td></tr>
<tr><td><code id="cSplit_+3A_direction">direction</code></td>
<td>
<p>The desired direction of the results, either <code>"wide"</code>
or <code>"long"</code>.</p>
</td></tr>
<tr><td><code id="cSplit_+3A_fixed">fixed</code></td>
<td>
<p>Logical. Should the split character be treated as a fixed
pattern (<code>TRUE</code>) or a regular expression (<code>FALSE</code>)? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="cSplit_+3A_drop">drop</code></td>
<td>
<p>Logical. Should the original concatenated column be dropped?
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="cSplit_+3A_stripwhite">stripWhite</code></td>
<td>
<p>Logical. If there is whitespace around the delimiter in
the concatenated columns, should it be stripped prior to splitting? Defaults
to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="cSplit_+3A_makeequal">makeEqual</code></td>
<td>
<p>Logical. Should all groups be made to be the same length?
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="cSplit_+3A_type.convert">type.convert</code></td>
<td>
<p>Logical. Should <code><a href="utils.html#topic+type.convert">utils::type.convert()</a></code> be used to convert
the result of each column? This would add a little to the execution time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.table</code> with the values split into new columns or rows.
</p>


<h3>Note</h3>

<p>The <code>cSplit</code> function replaces most of the earlier <code>concat.split*</code>
functions. The earlier functions remain for compatibility purposes, but now
they are essentially wrappers for the <code>cSplit</code> function.
</p>


<h3>Author(s)</h3>

<p>Ananda Mahto
</p>


<h3>See Also</h3>

<p><code><a href="#topic+concat.split">concat.split()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Sample data
temp &lt;- head(concat.test)

## Split the "Likes" column
cSplit(temp, "Likes")

## Split the "Likes" and "Hates" columns --
##   they have different delimiters...
cSplit(temp, c("Likes", "Hates"), c(",", ";"))

## Split "Siblings" into a long form...
cSplit(temp, "Siblings", ",", direction = "long")

## Split "Siblings" into a long form, not removing whitespace
cSplit(temp, "Siblings", ",", direction = "long", stripWhite = FALSE)

## Split a vector
y &lt;- c("a_b_c", "a_b", "c_a_b")
cSplit(data.frame(y), "y", "_")

</code></pre>

<hr>
<h2 id='expandRows'>Expand the Rows of a Dataset</h2><span id='topic+expandRows'></span>

<h3>Description</h3>

<p>Expands (replicates) the rows of a <code>data.frame</code> or <code>data.table</code>, either by a
fixed number, a specified vector, or a value contained in one of the columns
in the source <code>data.frame</code> or <code>data.table</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expandRows(dataset, count, count.is.col = TRUE, drop = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expandRows_+3A_dataset">dataset</code></td>
<td>
<p>The input <code>data.frame</code> or <code>data.table</code>.</p>
</td></tr>
<tr><td><code id="expandRows_+3A_count">count</code></td>
<td>
<p>The numeric vector of counts OR the column from the
dataset that contains the count data. If <code>count</code> is a single
digit, it is assumed that all rows should be repeated by this amount.</p>
</td></tr>
<tr><td><code id="expandRows_+3A_count.is.col">count.is.col</code></td>
<td>
<p>Logical. Is the <code>count</code> value a column from the
input dataset? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="expandRows_+3A_drop">drop</code></td>
<td>
<p>Logical. If <code>count.is.col = TRUE</code>, should the &quot;count&quot;
column be dropped from the result? Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> or <code>data.table</code>, depending on the input.
</p>


<h3>Author(s)</h3>

<p>Ananda Mahto
</p>


<h3>References</h3>

<p><a href="http://stackoverflow.com/a/19519828/1270695">http://stackoverflow.com/a/19519828/1270695</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mydf &lt;- data.frame(x = c("a", "b", "q"), 
                   y = c("c", "d", "r"), 
                   count = c(2, 5, 3))
library(data.table)
DT &lt;- as.data.table(mydf)
mydf
expandRows(mydf, "count")
expandRows(DT, "count", drop = FALSE)
expandRows(mydf, count = 3) ## This takes values from the third column!
expandRows(mydf, count = 3, count.is.col = FALSE)
expandRows(mydf, count = c(1, 5, 9), count.is.col = FALSE)
expandRows(DT, count = c(1, 5, 9), count.is.col = FALSE)

</code></pre>

<hr>
<h2 id='FacsToChars'>Convert All Factor Columns to Character Columns</h2><span id='topic+FacsToChars'></span>

<h3>Description</h3>

<p>Sometimes, we forget to use the <code>stringsAsFactors</code> argument when using
<code><a href="utils.html#topic+read.table">utils::read.table()</a></code> and related functions. By default, R converts character
columns to factors. Instead of re-reading the data, the <code>FacsToChars</code>
function will identify which columns are currently factors, and convert them
all to characters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FacsToChars(mydf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FacsToChars_+3A_mydf">mydf</code></td>
<td>
<p>The name of your <code>data.frame</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ananda Mahto
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+read.table">utils::read.table()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Some example data
dat &lt;- data.frame(title = c("title1", "title2", "title3"),
         author = c("author1", "author2", "author3"),
         customerID = c(1, 2, 1))

str(dat) # current structure
dat2 &lt;- splitstackshape:::FacsToChars(dat)
str(dat2) # Your new object
str(dat)  # Original object is unaffected

</code></pre>

<hr>
<h2 id='getanID'>Add an &quot;id&quot; Variable to a Dataset</h2><span id='topic+getanID'></span>

<h3>Description</h3>

<p>Many functions will not work properly if there are duplicated ID variables
in a dataset. This function is a convenience function for <code>.N</code> from the
&quot;data.table&quot; package to create an <code>.id</code> variable that when used in conjunction
with the existing ID variables, should be unique.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getanID(data, id.vars = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getanID_+3A_data">data</code></td>
<td>
<p>The input <code>data.frame</code> or <code>data.table</code>.</p>
</td></tr>
<tr><td><code id="getanID_+3A_id.vars">id.vars</code></td>
<td>
<p>The variables that should be treated as ID variables. Defaults
to <code>NULL</code>, at which point all variables are used to create the new ID variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input dataset (as a <code>data.table</code>) if ID variables are unique, or
the input dataset with a new column named <code>.id</code>.
</p>


<h3>Author(s)</h3>

<p>Ananda Mahto
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mydf &lt;- data.frame(IDA = c("a", "a", "a", "b", "b"),
                   IDB = c(1, 1, 1, 1, 1), values = 1:5)
mydf
getanID(mydf, c("IDA", "IDB"))

mydf &lt;- data.frame(IDA = c("a", "a", "a", "b", "b"),
                   IDB = c(1, 2, 1, 1, 2), values = 1:5)
mydf
getanID(mydf, 1:2)



</code></pre>

<hr>
<h2 id='listCol_l'>Unlist a Column Stored as a List</h2><span id='topic+listCol_l'></span>

<h3>Description</h3>

<p>Unlists a column stored as a <code>list</code> into a long form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>listCol_l(inDT, listcol, drop = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="listCol_l_+3A_indt">inDT</code></td>
<td>
<p>The input dataset.</p>
</td></tr>
<tr><td><code id="listCol_l_+3A_listcol">listcol</code></td>
<td>
<p>The name of the column stored as a <code>list</code>.</p>
</td></tr>
<tr><td><code id="listCol_l_+3A_drop">drop</code></td>
<td>
<p>Logical. Should the original column be dropped? Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.table</code>.
</p>


<h3>Author(s)</h3>

<p>Ananda Mahto
</p>


<h3>See Also</h3>

<p><code><a href="#topic+listCol_w">listCol_w</a></code> to flatten a <code>list</code> column into a &quot;wide&quot; format.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dat &lt;- data.frame(A = 1:3, B = I(list(c(1, 2), c(1, 3, 5), c(4))))
listCol_l(dat, "B")

</code></pre>

<hr>
<h2 id='listCol_w'>Flatten a Column Stored as a List</h2><span id='topic+listCol_w'></span>

<h3>Description</h3>

<p>Flattens a column stored as a <code>list</code> into a wide form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>listCol_w(inDT, listcol, drop = TRUE, fill = NA_character_)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="listCol_w_+3A_indt">inDT</code></td>
<td>
<p>The input dataset.</p>
</td></tr>
<tr><td><code id="listCol_w_+3A_listcol">listcol</code></td>
<td>
<p>The name of the column stored as a <code>list</code>.</p>
</td></tr>
<tr><td><code id="listCol_w_+3A_drop">drop</code></td>
<td>
<p>Logical. Should the original column be dropped? Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="listCol_w_+3A_fill">fill</code></td>
<td>
<p>The desired fill value. Defaults to <code>NA_character_</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.table</code>.
</p>


<h3>Author(s)</h3>

<p>Ananda Mahto
</p>


<h3>See Also</h3>

<p><code><a href="#topic+listCol_l">listCol_l</a></code> to unlist a <code>list</code> column into a &quot;long&quot; format.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dat &lt;- data.frame(A = 1:3, B = I(list(c(1, 2), c(1, 3, 5), c(4))))
listCol_w(dat, "B")

</code></pre>

<hr>
<h2 id='merged.stack'>Take a List of Stacked data.tables and Merge Them</h2><span id='topic+merged.stack'></span>

<h3>Description</h3>

<p>A wrapper around the <code><a href="#topic+Stacked">Stacked</a></code> function to
<code><a href="data.table.html#topic+merge">merge</a></code> the resulting <code>list</code> into a
single <code>data.table</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merged.stack(data, id.vars = NULL, var.stubs, sep, keep.all = TRUE,
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merged.stack_+3A_data">data</code></td>
<td>
<p>The input <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="merged.stack_+3A_id.vars">id.vars</code></td>
<td>
<p>The columns to be used as &quot;ID&quot; variables. Defaults to <code>NULL</code>, at which point, all names which are not identified as variable groups are used as the identifiers.</p>
</td></tr>
<tr><td><code id="merged.stack_+3A_var.stubs">var.stubs</code></td>
<td>
<p>The prefixes of the variable groups.</p>
</td></tr>
<tr><td><code id="merged.stack_+3A_sep">sep</code></td>
<td>
<p>The character that separates the &quot;variable name&quot; from the &quot;times&quot;
in the source <code>data.frame</code>. Alternatively, can be set to
<code>"var.stubs"</code> (in quotes) if you do not have a value for <code>sep</code>.</p>
</td></tr>
<tr><td><code id="merged.stack_+3A_keep.all">keep.all</code></td>
<td>
<p>Logical. Should all the variables in the source
<code>data.frame</code> be kept (<code>keep.all = TRUE</code>) or only those which
comprise the <code>id.vars</code> and split data from the <code>var.stubs</code>
(<code>keep.all = FALSE</code>).</p>
</td></tr>
<tr><td><code id="merged.stack_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed on to <code><a href="#topic+Stacked">Stacked</a></code> (for example, <code>keep.rownames</code> to retain the rownames of the input dataset, or <code>atStart</code>, in case <code>sep = "var.stubs"</code> is specified).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A merged <code>data.table</code>.
</p>


<h3>Note</h3>

<p>The <code>keyed</code> argument to <code><a href="#topic+Stacked">Stacked</a></code> has been hard-
coded to <code>TRUE</code> to make <code>merge</code> work.
</p>


<h3>Author(s)</h3>

<p>Ananda Mahto
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Stacked">Stacked</a></code>, <code><a href="#topic+Reshape">Reshape</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
mydf &lt;- data.frame(id_1 = 1:6, id_2 = c("A", "B"),
                   varA.1 = sample(letters, 6),
                   varA.2 = sample(letters, 6),
                   varA.3 = sample(letters, 6),
                   varB.2 = sample(10, 6),
                   varB.3 = sample(10, 6),
                   varC.3 = rnorm(6))
mydf
merged.stack(mydf, var.stubs = c("varA", "varB", "varC"), sep = ".")



</code></pre>

<hr>
<h2 id='Names'>Dataset Names as a Character Vector, Always</h2><span id='topic+Names'></span>

<h3>Description</h3>

<p>A convenience function using either character vectors or numeric vectors to
specify a subset of <code>names</code> of a <code>data.frame</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Names(data, invec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Names_+3A_data">data</code></td>
<td>
<p>The input <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="Names_+3A_invec">invec</code></td>
<td>
<p>The <code>names</code> you want.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of the desired names.
</p>


<h3>Author(s)</h3>

<p>Ananda Mahto
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mydf &lt;- data.frame(a = 1:2, b = 3:4, c = 5:6)
splitstackshape:::Names(mydf, c("a", "c"))
splitstackshape:::Names(mydf, c(1, 3))

</code></pre>

<hr>
<h2 id='NoSep'>Split Basic Alphanumeric Strings Which Have No Separators</h2><span id='topic+NoSep'></span>

<h3>Description</h3>

<p>Used to split strings like &quot;Abc8&quot; into &quot;Abc&quot; and &quot;8&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NoSep(data, charfirst = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NoSep_+3A_data">data</code></td>
<td>
<p>The vector of strings to be split.</p>
</td></tr>
<tr><td><code id="NoSep_+3A_charfirst">charfirst</code></td>
<td>
<p>Is the string constructed with characters at the start or
numbers? Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with two columns, <code>.var</code> and <code>.time_1</code>.
</p>


<h3>Note</h3>

<p>This is a helper function for the <code><a href="#topic+Stacked">Stacked()</a></code> and <code><a href="#topic+Reshape">Reshape()</a></code> functions.
</p>


<h3>Author(s)</h3>

<p>Ananda Mahto
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+strsplit">base::strsplit()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- paste0("Var", LETTERS[1:3], 1:3)
splitstackshape:::NoSep(x)

y &lt;- paste0(1:3, "Var", LETTERS[1:3])
splitstackshape:::NoSep(y, charfirst = FALSE)

</code></pre>

<hr>
<h2 id='numMat'>Create a Numeric Matrix from a List of Values</h2><span id='topic+numMat'></span>

<h3>Description</h3>

<p>Create a numeric matrix from a list of values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>numMat(listOfValues, fill = NA, mode = "binary")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="numMat_+3A_listofvalues">listOfValues</code></td>
<td>
<p>A <code>list</code> of input values to be inserted in a matrix.</p>
</td></tr>
<tr><td><code id="numMat_+3A_fill">fill</code></td>
<td>
<p>The initializing fill value for the empty matrix.</p>
</td></tr>
<tr><td><code id="numMat_+3A_mode">mode</code></td>
<td>
<p>Either <code>"binary"</code> or <code>"value"</code>. Defaults to <code>"binary"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is primarily a helper function for the <code><a href="#topic+concat.split">concat.split()</a></code> function when
creating the &quot;expanded&quot; structure. The input is anticipated to be a <code>list</code> of
values obtained using <code><a href="base.html#topic+strsplit">base::strsplit()</a></code>.
</p>


<h3>Value</h3>

<p>A <code>matrix</code>.
</p>


<h3>Author(s)</h3>

<p>Ananda Mahto
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+strsplit">base::strsplit()</a></code>, <code><a href="#topic+charMat">charMat()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
invec &lt;- c("1,2,4,5,6", "1,2,4,5,6", "1,2,4,5,6",
           "1,2,4,5,6", "-1,1,2,5,6", "1,2,5,6")
A &lt;- strsplit(invec, ",")
splitstackshape:::numMat(A)
splitstackshape:::numMat(A, fill = 0)
splitstackshape:::numMat(A, mode = "value")

</code></pre>

<hr>
<h2 id='othernames'>Extract All Names From a Dataset Other Than the Ones Listed</h2><span id='topic+othernames'></span>

<h3>Description</h3>

<p>A convenience function for <code>setdiff(names(data), -some_vector_of_names-)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>othernames(data, toremove)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="othernames_+3A_data">data</code></td>
<td>
<p>The input <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="othernames_+3A_toremove">toremove</code></td>
<td>
<p>The <code>names</code> you want to exclude.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of the remaining names.
</p>


<h3>Author(s)</h3>

<p>Ananda Mahto
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+setdiff">base::setdiff()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mydf &lt;- data.frame(a = 1:2, b = 3:4, c = 5:6)
splitstackshape:::othernames(mydf, "a")

</code></pre>

<hr>
<h2 id='read.concat'>Read Concatenated Character Vectors Into a data.frame</h2><span id='topic+read.concat'></span>

<h3>Description</h3>

<p>Originally a helper function for the <code><a href="#topic+concat.split.compact">concat.split.compact()</a></code> function. This
function has now been effectively replaced by <code><a href="#topic+cSplit">cSplit()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.concat(data, col.prefix, sep, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.concat_+3A_data">data</code></td>
<td>
<p>The input data.</p>
</td></tr>
<tr><td><code id="read.concat_+3A_col.prefix">col.prefix</code></td>
<td>
<p>The desired column prefix for the output <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="read.concat_+3A_sep">sep</code></td>
<td>
<p>The character that acts as a delimiter.</p>
</td></tr>
<tr><td><code id="read.concat_+3A_...">...</code></td>
<td>
<p>Other arguments to pass to <code><a href="utils.html#topic+read.table">utils::read.table()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code>.
</p>


<h3>Author(s)</h3>

<p>Ananda Mahto
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+read.table">utils::read.table()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
vec &lt;- c("a,b", "c,d,e", "f, g", "h, i, j,k")
splitstackshape:::read.concat(vec, "var", ",")

## More than 5 lines the same
## `read.table` would fail with this
vec &lt;- c("12,51,34,17", "84,28,17,10", "11,43,28,15",
"80,26,17,91", "10,41,25,13", "97,35,23,12,13")
splitstackshape:::read.concat(vec, "var", ",")

</code></pre>

<hr>
<h2 id='Reshape'>Reshape Wide Data Into a Semi-long Form</h2><span id='topic+Reshape'></span>

<h3>Description</h3>

<p>The <code><a href="stats.html#topic+reshape">stats::reshape()</a></code> function in base R is very handy when you want a
semi-long (or semi-wide) <code>data.frame</code>. However, base R's <code>reshape</code> has
problems is with &quot;unbalanced&quot; panel data, for instance data where one
variable was measured at three points in time, and another only twice.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Reshape(data, id.vars = NULL, var.stubs, sep = ".", rm.rownames, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Reshape_+3A_data">data</code></td>
<td>
<p>The source <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="Reshape_+3A_id.vars">id.vars</code></td>
<td>
<p>The variables that serve as unique identifiers. Defaults to
<code>NULL</code>, at which point, all names which are not identified as variable groups
are used as the identifiers.</p>
</td></tr>
<tr><td><code id="Reshape_+3A_var.stubs">var.stubs</code></td>
<td>
<p>The prefixes of the variable groups.</p>
</td></tr>
<tr><td><code id="Reshape_+3A_sep">sep</code></td>
<td>
<p>The character that separates the &quot;variable name&quot; from the &quot;times&quot;
in the wide <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="Reshape_+3A_rm.rownames">rm.rownames</code></td>
<td>
<p>Ignored as <code>data.table</code>s do not have rownames anyway.</p>
</td></tr>
<tr><td><code id="Reshape_+3A_...">...</code></td>
<td>
<p>Further arguments to <code><a href="#topic+NoSep">NoSep()</a></code> in case the separator is of a
different form.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function was written to overcome that limitation of dealing with
unbalanced data, but is also appropriate for basic wide-to-long reshaping
tasks.
</p>
<p>Related functions like <code><a href="utils.html#topic+stack">utils::stack()</a></code> in base R and <code><a href="reshape2.html#topic+melt">reshape2::melt()</a></code> in
&quot;reshape2&quot; are also very handy when you want a &quot;long&quot; reshaping of data, but
they result in a very long structuring of your data, not the &quot;semi-wide&quot;
format that <code>reshape</code> produces. <code><a href="data.table.html#topic+melt">data.table::melt()</a></code> can produce output like
<code>reshape</code>, but it also expects an equal number of measurements for each
variable.
</p>


<h3>Value</h3>

<p>A &quot;long&quot; <code>data.table</code> of the reshaped data that retains the
attributes added by base R's <code>reshape</code> function.
</p>


<h3>Author(s)</h3>

<p>Ananda Mahto
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Stacked">Stacked()</a></code>, <code><a href="utils.html#topic+stack">utils::stack()</a></code>, <code><a href="stats.html#topic+reshape">stats::reshape()</a></code>,
<code><a href="reshape2.html#topic+melt">reshape2::melt()</a></code>, <code><a href="data.table.html#topic+melt">data.table::melt()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
mydf &lt;- data.frame(id_1 = 1:6, id_2 = c("A", "B"), varA.1 = sample(letters, 6),
                 varA.2 = sample(letters, 6), varA.3 = sample(letters, 6),
                 varB.2 = sample(10, 6), varB.3 = sample(10, 6),
                 varC.3 = rnorm(6))
mydf

## Note that these data are unbalanced
## reshape() will not work
## Not run: 
reshape(mydf, direction = "long", idvar=1:2, varying=3:ncol(mydf))

## End(Not run)

## The Reshape() function can handle such scenarios

Reshape(mydf, id.vars = c("id_1", "id_2"),
       var.stubs = c("varA", "varB", "varC"))

</code></pre>

<hr>
<h2 id='splitstackshape-package'>splitstackshape</h2><span id='topic+splitstackshape-package'></span><span id='topic+splitstackshape'></span>

<h3>Description</h3>

<p>Stack and Reshape Datasets After Splitting Concatenated Values
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;"> Package: </td><td style="text-align: left;"> splitstackshape</td>
</tr>
<tr>
 <td style="text-align: left;"> Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.4.8</td>
</tr>
<tr>
 <td style="text-align: left;"> Date: </td><td style="text-align: left;"> 2019-04-21</td>
</tr>
<tr>
 <td style="text-align: left;"> License: </td><td style="text-align: left;"> GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>

<p>Online data collection tools like Google Forms often export multiple-response
questions with data concatenated in cells. The <code><a href="#topic+concat.split">concat.split()</a></code> family of
functions splits such data into separate cells. The package also includes
functions to <em>stack</em> groups of columns and to <em>reshape</em> wide data, even when
the data are &quot;unbalanced&quot;&mdash;something which <code><a href="stats.html#topic+reshape">stats::reshape()</a></code> does not handle,
and which <code><a href="reshape2.html#topic+melt">reshape2::melt()</a></code> and <code><a href="reshape2.html#topic+dcast">reshape2::dcast()</a></code> from <em>reshape2</em> do not
easily handle.
</p>


<h3>Author(s)</h3>

<p>Ananda Mahto
</p>
<p>Maintainer: Ananda Mahto <a href="mailto:mrdwab@gmail.com">mrdwab@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## concat.split
head(cSplit(concat.test, "Likes", drop = TRUE))

## Reshape
set.seed(1)
mydf &lt;- data.frame(id_1 = 1:6, id_2 = c("A", "B"), varA.1 = sample(letters, 6),
                   varA.2 = sample(letters, 6), varA.3 = sample(letters, 6),
                   varB.2 = sample(10, 6), varB.3 = sample(10, 6), 
                   varC.3 = rnorm(6))
mydf
Reshape(mydf, id.vars = c("id_1", "id_2"),
        var.stubs = c("varA", "varB", "varC"))

## Stacked
Stacked(data = mydf, id.vars = c("id_1", "id_2"),
        var.stubs = c("varA", "varB", "varC"),
        sep = ".")
## Not run: 
## Processing times
set.seed(1)
Nrow &lt;- 1000000
Ncol &lt;- 10
mybigdf &lt;- cbind(id = 1:Nrow, as.data.frame(matrix(rnorm(Nrow*Ncol),
                                                   nrow=Nrow)))
head(mybigdf)
dim(mybigdf)
tail(mybigdf)
A &lt;- names(mybigdf)
names(mybigdf) &lt;- c("id", paste("varA", 1:3, sep = "_"),
                    paste("varB", 1:4, sep = "_"),
                    paste("varC", 1:3, sep = "_"))
system.time({
   O1 &lt;- Reshape(mybigdf, id.vars = "id",
   var.stubs = c("varA", "varB", "varC"), sep = "_")
   O1 &lt;- O1[order(O1$id, O1$time), ]
})
system.time({
   O2 &lt;- merged.stack(mybigdf, id.vars="id",
   var.stubs=c("varA", "varB", "varC"), sep = "_")
})
system.time({
   O3 &lt;- Stacked(mybigdf, id.vars="id",
   var.stubs=c("varA", "varB", "varC"), sep = "_")
})
DT &lt;- data.table(mybigdf)
system.time({
   O4 &lt;- merged.stack(DT, id.vars="id",
   var.stubs=c("varA", "varB", "varC"), sep = "_")
})

## End(Not run)

</code></pre>

<hr>
<h2 id='Stacked'>Stack Columns from a Wide Form to a Long Form</h2><span id='topic+Stacked'></span>

<h3>Description</h3>

<p>A function to conveniently stack groups of wide columns into a long form
which can then be <code><a href="data.table.html#topic+merge">merge</a></code>d together.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Stacked(data, id.vars = NULL, var.stubs, sep, keep.all = TRUE,
  keyed = TRUE, keep.rownames = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Stacked_+3A_data">data</code></td>
<td>
<p>The source <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="Stacked_+3A_id.vars">id.vars</code></td>
<td>
<p>The variables that serve as unique identifiers. Defaults to <code>NULL</code>, at which point, all names which are not identified as variable groups are used as the identifiers.</p>
</td></tr>
<tr><td><code id="Stacked_+3A_var.stubs">var.stubs</code></td>
<td>
<p>The prefixes of the variable groups.</p>
</td></tr>
<tr><td><code id="Stacked_+3A_sep">sep</code></td>
<td>
<p>The character that separates the &quot;variable name&quot; from the &quot;times&quot;
in the wide <code>data.frame</code>. Alternatively, can be set to
<code>"var.stubs"</code> (in quotes) if you do not have a value for <code>sep</code>.</p>
</td></tr>
<tr><td><code id="Stacked_+3A_keep.all">keep.all</code></td>
<td>
<p>Logical. Should all the variables from the source
<code>data.frame</code> be kept (<code>keep.all = TRUE</code>) or should the resulting
<code><a href="data.table.html#topic+data.table">data.table</a></code> comprise only columns for
the <code>id.vars</code>, <code>var.stubs</code>, and &quot;times&quot; (<code>keep.all = FALSE</code>).
Other variables are <em>recycled</em> to appropriate length. For this to work,
both <code>id.vars</code> and <code>var.stubs</code> must be specified.</p>
</td></tr>
<tr><td><code id="Stacked_+3A_keyed">keyed</code></td>
<td>
<p>Logical. Should the <code>Stacked</code> function automatically set
the <code>key</code> for the resulting <code>data.table</code>s. If <code>TRUE</code>
(default) the <code>key</code> is set to the <code>id.vars</code> and the &quot;time&quot;
variables that are created by <code>Stacked</code>.</p>
</td></tr>
<tr><td><code id="Stacked_+3A_keep.rownames">keep.rownames</code></td>
<td>
<p>Logical. Should rownames be kept when converting the input to a <code>data.table</code>? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="Stacked_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed on when <code>sep = "var.stubs"</code> (specifically, <code>atStart</code>: A logical argument to indicate whether the stubs come at the start or at the end of the variable names).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> of <code>data.table</code>s with one <code>data.table</code> for
each &quot;var.stub&quot;. The <code><a href="data.table.html#topic+key">key</a></code> is set to the
<code>id.vars</code> and <code>.time_#</code> vars.
</p>


<h3>Note</h3>

<p>This is the function internally called by <code><a href="#topic+merged.stack">merged.stack</a></code>.
</p>


<h3>Author(s)</h3>

<p>Ananda Mahto
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+stack">stack</a></code>, <code><a href="reshape2.html#topic+melt">melt</a></code> from
&quot;reshape2&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
mydf &lt;- data.frame(id_1 = 1:6, id_2 = c("A", "B"),
                   varA.1 = sample(letters, 6),
                   varA.2 = sample(letters, 6),
                   varA.3 = sample(letters, 6),
                   varB.2 = sample(10, 6),
                   varB.3 = sample(10, 6),
                   varC.3 = rnorm(6))
mydf
Stacked(data = mydf, var.stubs = c("varA", "varB", "varC"), sep = ".")



</code></pre>

<hr>
<h2 id='stratified'>Take a Stratified Sample From a Dataset</h2><span id='topic+stratified'></span>

<h3>Description</h3>

<p>The <code>stratified</code> function samples from a <code>data.table</code> in which one or more
columns can be used as a &quot;stratification&quot; or &quot;grouping&quot; variable. The result
is a new <code>data.table</code> with the specified number of samples from each group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stratified(indt, group, size, select = NULL, replace = FALSE,
  keep.rownames = FALSE, bothSets = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stratified_+3A_indt">indt</code></td>
<td>
<p>The input <code>data.table</code>.</p>
</td></tr>
<tr><td><code id="stratified_+3A_group">group</code></td>
<td>
<p>The column or columns that should be used to create the groups.
Can be a character vector of column names (recommended) or a numeric vector
of column positions. Generally, if you are using more than one variable to
create your &quot;strata&quot;, you should list them in the order of <em>slowest</em> varying
to <em>quickest</em> varying. This can be a vector of names or column indexes.</p>
</td></tr>
<tr><td><code id="stratified_+3A_size">size</code></td>
<td>
<p>The desired sample size.
</p>

<ul>
<li><p> If <code>size</code> is a value between <code>0</code> and <code>1</code> expressed as a decimal, size is
set to be proportional to the number of observations per group.
</p>
</li>
<li><p> If <code>size</code> is a single positive integer, it will be assumed that you want
the same number of samples from each group.
</p>
</li>
<li><p> If <code>size</code> is a named vector, the function will check to see whether the
length of the vector matches the number of groups and that the names match
the group names.
</p>
</li></ul>
</td></tr>
<tr><td><code id="stratified_+3A_select">select</code></td>
<td>
<p>A named list containing levels from the <code>"group"</code> variables in
which you are interested. The list names must be present as variable names
for the input dataset.</p>
</td></tr>
<tr><td><code id="stratified_+3A_replace">replace</code></td>
<td>
<p>Logical. Should sampling be with replacement? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="stratified_+3A_keep.rownames">keep.rownames</code></td>
<td>
<p>Logical. If the input is a <code>data.frame</code> with <code>rownames</code>,
<code>as.data.table</code> would normally drop the rownames. If <code>TRUE</code>, the rownames
would be retained in a column named <code>rn</code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="stratified_+3A_bothsets">bothSets</code></td>
<td>
<p>Logical. Should both the sampled and non-sampled sets be
returned as a <code>list</code>? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="stratified_+3A_...">...</code></td>
<td>
<p>Optional arguments to <code><a href="base.html#topic+sample">base::sample()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>bothSets = TRUE</code>, a <code>list</code> of two <code>data.tables</code>; otherwise, a <code>data.table</code>.
</p>


<h3>Note</h3>

<p><em>Slightly different sizes than requested</em>: Because of how computers
deal with floating-point arithmetic, and because R uses a &quot;round to even&quot;
approach, the size per strata that results when specifying a proportionate
sample may be one sample higher or lower per strata than you might have expected.
</p>


<h3>Author(s)</h3>

<p>Ananda Mahto
</p>


<h3>See Also</h3>

<p><code><a href="sampling.html#topic+strata">sampling::strata()</a></code> from the &quot;strata&quot; package; <code><a href="dplyr.html#topic+sample_n">dplyr::sample_n()</a></code>
and <code><a href="dplyr.html#topic+sample_frac">dplyr::sample_frac()</a></code> from &quot;dplyr&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate a sample data.frame to play with
set.seed(1)
DF &lt;- data.frame(
  ID = 1:100,
  A = sample(c("AA", "BB", "CC", "DD", "EE"), 100, replace = TRUE),
  B = rnorm(100), C = abs(round(rnorm(100), digits=1)),
  D = sample(c("CA", "NY", "TX"), 100, replace = TRUE),
  E = sample(c("M", "F"), 100, replace = TRUE))

# Take a 10% sample from all -A- groups in DF
stratified(DF, "A", .1)

# Take a 10% sample from only "AA" and "BB" groups from -A- in DF
stratified(DF, "A", .1, select = list(A = c("AA", "BB")))

# Take 5 samples from all -D- groups in DF, specified by column number
stratified(DF, group = 5, size = 5)

# Use a two-column strata: -E- and -D-
stratified(DF, c("E", "D"), size = .15)

# Use a two-column strata (-E- and -D-) but only use cases where -E- == "M"
stratified(DF, c("E", "D"), .15, select = list(E = "M"))

## As above, but where -E- == "M" and -D- == "CA" or "TX"
stratified(DF, c("E", "D"), .15, select = list(E = "M", D = c("CA", "TX")))

# Use a three-column strata: -E-, -D-, and -A-
stratified(DF, c("E", "D", "A"), size = 2)

## Not run: 
# The following will produce errors
stratified(DF, "D", c(5, 3))
stratified(DF, "D", c(5, 3, 2))

## End(Not run)

# Sizes using a named vector
stratified(DF, "D", c(CA = 5, NY = 3, TX = 2))

# Works with multiple groups as well
stratified(DF, c("D", "E"), 
           c("NY F" = 2, "NY M" = 3, "TX F" = 1, "TX M" = 1,
             "CA F" = 5, "CA M" = 1))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
