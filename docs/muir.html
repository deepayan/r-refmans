<!DOCTYPE html><html><head><title>Help for package muir</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {muir}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#build_tree'><p>Build dynamic tree using DiagrammeR and muir-generated data frame</p></a></li>
<li><a href='#muir'><p>Explore Datasets with Trees</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Exploring Data with Tree Data Structures</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>A simple tool allowing users to easily and dynamically explore or document a data set using a tree structure.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/alforj/muir">https://github.com/alforj/muir</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/alforj/muir/issues">https://github.com/alforj/muir/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.2)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>DiagrammeR (&ge; 0.6), dplyr (&ge; 0.4.1), stringr (&ge; 0.6.2)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>htmlwidgets (&ge; 0.3.2)</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2015-05-02 14:32:36 UTC; alforj</td>
</tr>
<tr>
<td>Author:</td>
<td>Justin Alford [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Justin Alford &lt;justin.alford@gmail.com&gt;</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2015-05-02 16:46:05</td>
</tr>
</table>
<hr>
<h2 id='build_tree'>Build dynamic tree using DiagrammeR and muir-generated data frame</h2><span id='topic+build_tree'></span>

<h3>Description</h3>

<p>This function allows users to easily and dynamically explore or document a
dataset using a tree structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_tree(data, tree.dir = "LR", tree.height = NULL, tree.width = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_tree_+3A_data">data</code></td>
<td>
<p>A muir-generated data frame to be processed into a tree using DiagrammeR</p>
</td></tr>
<tr><td><code id="build_tree_+3A_tree.dir">tree.dir</code></td>
<td>
<p>Direction of tree graph. Use either &quot;LR&quot; for left-to-right,
&quot;RL&quot; for right-to left, &quot;TB&quot; for top-to-bottom, or &quot;BT&quot; for bottom-to-top.</p>
</td></tr>
<tr><td><code id="build_tree_+3A_tree.height">tree.height</code></td>
<td>
<p>Control tree height to zoom in/out on nodes. Defaults to NULL</p>
</td></tr>
<tr><td><code id="build_tree_+3A_tree.width">tree.width</code></td>
<td>
<p>Control tree width to zoom in/out on nodes. Defaults to NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>htmlwidget</code> (via DiagrammeR)that will
intelligently print itself into HTML in a variety of contexts
including the R console, within R Markdown documents,
and within Shiny output bindings.
</p>

<hr>
<h2 id='muir'>Explore Datasets with Trees</h2><span id='topic+muir'></span>

<h3>Description</h3>

<p>This function allows users to easily and dynamically explore or document a
data.frame using a tree data structure. Columns of interest in the data.frame can
be provided to the function, as well as critieria for how they should be represented
in discrete nodes, to generate a data tree representing those columns and filters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>muir(data, node.levels, node.limit = 3, level.criteria = NULL,
  label.vals = NULL, tree.dir = "LR", show.percent = TRUE,
  num.precision = 2, show.empty.child = FALSE, tree.height = -1,
  tree.width = -1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="muir_+3A_data">data</code></td>
<td>
<p>A data.frame to be explored using trees</p>
</td></tr>
<tr><td><code id="muir_+3A_node.levels">node.levels</code></td>
<td>
<p>A character vector of columns from <code>data</code> that will be used to
construct the tree that are provided in the order that they should appear in the tree levels.
</p>
<p>For each column, the user can add a suffix to the columnn name to indicate whether to generate
nodes for all distinct values of the column in the date.frame, a specific number of values
(i.e., the &quot;Top (n)&quot; values), and whether or not to aggregate remaining values into a separate
&quot;Other&quot; node, or to use user-provided filter criteria for the column as provided in
the <code>level.criteria</code> parameter. This does mean that the column names cannot have a &quot;:&quot;
and must be replaced in the data.frame before being passed in to <code>muir</code> as
the <code>data</code> param.
</p>
<p>Values can be provided as &quot;colname&quot;, &quot;colname:*&quot;, &quot;colname:3&quot;, &quot;colname:+&quot;,
or &quot;colname:*+&quot;. The separator character &quot;:&quot; and the special characters in the suffix that
follow (as outlined below) indicate which approach to take for each column.
</p>

<ul>
<li><p> Providing just the column name itself (e.g, &quot;hp&quot;) will return results
based on the operators and values provided in the <code>level.criteria</code> parameter
for that column name. See <code>level.criteria</code> for more details.
</p>
</li>
<li><p> Providing the column name with an &quot;:*&quot;  suffix (e.g., &quot;hp:*&quot;) will return a node for
all distinct values for that column up to the limit imposed by the <code>node.limit</code> value.
If the number of distinct values is greater than the <code>node.limit</code>, only the top &quot;n&quot;
values (based on number of occurences) will be returned.
</p>
</li>
<li><p> Providing the column name with an &quot;:<code>n</code>&quot; suffix (e.g., &quot;hp:3&quot;), where
<code>n</code> = a positive integer, will return a node for all distinct values for
that column up to the limit imposed by the integer provided in <code>n</code>.
If the number of distinct values is greater than the value provided in <code>n</code>,
only the top &quot;n&quot; values (based on number of occurences) will be returned.
</p>
</li>
<li><p> Providing the column name ending with an &quot;:+&quot; suffix (e.g., &quot;hp:+&quot;) will return all the
values provided in the <code>level.criteria</code> parameter for that column plus an extra node
titled &quot;Other&quot; for that column that aggregates all the remaining values not included
in the filter criteria provided in <code>level.criteria</code> for that column.
</p>
</li>
<li><p> Providing a column name ending with both symbols (e.g., &quot;hp:*+&quot;, &quot;hp:3+&quot;) in the suffix
will return a node for all distinct values for that column up to the limit imposed by either
the <code>node.limit</code> or the <code>n</code> value plus an additional &quot;Other&quot; node aggregating
any remaining values beyond the <code>node.limit</code> or <code>n</code>, if applicable.
If the number of distinct values is &lt;= the <code>node.limit</code> or <code>n</code> then the &quot;Other&quot;
node will not be created.
</p>
</li></ul>
</td></tr>
<tr><td><code id="muir_+3A_node.limit">node.limit</code></td>
<td>
<p>Numeric value. When providing a column in <code>node.levels</code> with an &quot;:*&quot; suffix,
the <code>node.limit</code> will limit how many distinct values to actually process to prevent
run-away queries and unreadable trees. The limit defaults to 3 (not including an additional
4th if requesting to provide an &quot;Other&quot; node as well with a &quot;:*+&quot; suffix). If the
number of distinct values for the column is greater than the <code>node.limit</code>, the tree
will include the Top &quot;X&quot; values based on count, where &quot;X&quot; = <code>node.limit</code>. If the
<code>node.limit</code> is greater than the number of distinct values for the column, it will
be ignored.</p>
</td></tr>
<tr><td><code id="muir_+3A_level.criteria">level.criteria</code></td>
<td>
<p>A data.frame consisting of 4 character columns containing
column names (matching &ndash; without suffixes &ndash; the columns in <code>node.levels</code> that will
use the criteria in <code>level.criteria</code> to determine the filters used for each node),
an operator or boolean function (e.g., &quot;==&quot;,&quot;&gt;&quot;, &quot;is.na&quot;, &quot;is.null&quot;), a value,
and a corresponding node title for the node displaying that criteria.
</p>
<p>E.g.,&quot;wt, &quot;&gt;=&quot;, &quot;4000&quot;, &quot;Heavy Cars&quot;</p>
</td></tr>
<tr><td><code id="muir_+3A_label.vals">label.vals</code></td>
<td>
<p>Character vector of additional values to include in the node provided as a
character vector. The values must take the form of dplyr <code>summarise</code> functions
(as characters) and include the columns the functions should be run against (e.g.,
&quot;min(hp)&quot;, &quot;mean(hp)&quot;, etc.). If no custom suffix is added, the summary function itself
will be used as the label. Similar to <code>node.levels</code> a custom suffix can be added
using &quot;:&quot; to print a more meaningful label (e.g., &quot;mean(hp):Avg HP&quot;). In this example,
the label printed in the node will be &quot;Avg HP:&quot;, otherwise it would be mean_hp (note
that the parens &quot;(&quot; and &quot;)&quot; are removed to be rendered in HTML without error). As with
<code>node.levels</code>, the column name itself cannot have a &quot;:&quot; and must be replaced in
the data.frame before being passed in to <code>muir</code> as the <code>data</code> param.</p>
</td></tr>
<tr><td><code id="muir_+3A_tree.dir">tree.dir</code></td>
<td>
<p>Character. The direction the tree graph should be rendered. Defaults to &quot;LR&quot;
</p>

<ol>
<li><p> Use &quot;LR&quot; for left-to-right
</p>
</li>
<li><p> Use &quot;RL&quot; for right-to left
</p>
</li>
<li><p> Use &quot;TB&quot; for top-to-bottom
</p>
</li>
<li><p> User &quot;BT&quot; for bottom-to-top
</p>
</li></ol>
</td></tr>
<tr><td><code id="muir_+3A_show.percent">show.percent</code></td>
<td>
<p>Logical. Should nodes show the percent of records represented by
that node compared to the total number of records in <code>data.</code> Defaults to TRUE</p>
</td></tr>
<tr><td><code id="muir_+3A_num.precision">num.precision</code></td>
<td>
<p>Number of digits to print numeric label values out to</p>
</td></tr>
<tr><td><code id="muir_+3A_show.empty.child">show.empty.child</code></td>
<td>
<p>Logical. Show a balanced tree with children nodes that are all
empty or stop expanding the tree once there is a parent node that is empty.
Defaults to FALSE &ndash; don't show empty children nodes</p>
</td></tr>
<tr><td><code id="muir_+3A_tree.height">tree.height</code></td>
<td>
<p>Numeric. Control tree height to zoom in/out on nodes. Passed to DiagrammeR
as <code>height</code> param. Defaults to -1, which appears to optimize the tree size
for viewing (still researching why exactly that works! :-))</p>
</td></tr>
<tr><td><code id="muir_+3A_tree.width">tree.width</code></td>
<td>
<p>Numberic. Control tree width to zoom in/out on nodes. Passed to DiagrammeR
as <code>width</code> param. Defaults to -1, which appears to best optimize the tree size
for viewing (still researching why exactly that works! :-))</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>htmlwidget</code> (via DiagrammeR) that will
intelligently print itself into HTML in a variety of contexts
including the R console, within R Markdown documents,
and within Shiny output bindings.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Load in the 'mtcars' dataset
data(mtcars)

# Basic exploration - show all values
mtTree &lt;- muir(data = mtcars, node.levels = c("cyl:*", "carb:*"))
mtTree

# Basic exploration - show all values overriding default node.limit
mtTree &lt;- muir(data = mtcars, node.levels = c("cyl:*", "carb:*"), node.limit = 5)
mtTree

# Show all values overriding default node.limit differently for each column
mtTree &lt;- muir(data = mtcars, node.levels = c("cyl:2", "carb:5"))
mtTree

# Show all values overriding default node.limit for each column
# and aggregating all distinct values above the node.limit into a
# separate "Other" column to collect remaining values

# Top 2 occurring 'carb' values will be returned in their own nodes,
# remaining values/counts will be aggregated into a separate "Other" node
mtTree &lt;- muir(data = mtcars, node.levels = c("cyl:2", "carb:2+"))
mtTree

# Add additional calculations to each node output (dplyr::summarise functions)
mtTree &lt;- muir(data = mtcars, node.levels = c("cyl:2", "carb:2+"),
label.vals = c("min(wt)", "max(wt)"))
mtTree

# Make new label values more reader-friendly
mtTree &lt;- muir(data = mtcars, node.levels = c("cyl:2", "carb:2+"),
label.vals = c("min(wt):Min Weight", "max(wt):Max Weight"))
mtTree

# Instead of just returning top counts for columns provided in \code{node.levels},
# provide custom filter criteria and custom node titles in \code{label.vals}
# (criteria could also be read in from a csv file as a data.frame)
criteria &lt;- data.frame(col = c("cyl", "cyl", "carb"),
oper = c("&lt;", "&gt;=", "=="),
val = c(4, 4, 2),
title = c("Less Than 4 Cylinders", "4 or More Cylinders", "2 Carburetors"))

mtTree &lt;- muir(data = mtcars, node.levels = c("cyl", "carb"),
level.criteria = criteria,
label.vals = c("min(wt):Min Weight", "max(wt):Max Weight"))
mtTree

# Use same criteria but show all other values for the column where NOT
# EQUAL to the combination of the filters provided for that column (e.g., for cyl
# where !(cyl &lt; 4 | cyl &gt;= 4) in an "Other" node
mtTree &lt;- muir(data = mtcars, node.levels = c("cyl:+", "carb:+"),
level.criteria = criteria,
label.vals = c("min(wt):Min Weight", "max(wt):Max Weight"))
mtTree

# Show empty child nodes (balanced tree)
mtTree &lt;- muir(data = mtcars, node.levels = c("cyl:+", "carb:+"),
level.criteria = criteria,
label.vals = c("min(wt):Min Weight", "max(wt):Max Weight"),
show.empty.child = TRUE)
mtTree

# Save tree to HTML file with \code{htmlwidgets} package to working directory
mtTree &lt;- muir(data = mtcars, node.levels = c("cyl:2", "carb:2+"))
htmlwidgets::saveWidget(mtTree, "mtTree.html")

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
