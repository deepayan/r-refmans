<!DOCTYPE html><html><head><title>Help for package PCBS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PCBS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#addRanks'><p>Add ranks to eigenvector scores.</p></a></li>
<li><a href='#CheckOvercompression'><p>Check if DMR calling seed number is ovcompressed.</p></a></li>
<li><a href='#checkRank'><p>Check rank cut-off values manually.</p></a></li>
<li><a href='#chromDict'><p>Convert a rank object into a chromDict.</p></a></li>
<li><a href='#DefineBestPC'><p>Identify your best principle component.</p></a></li>
<li><a href='#eigen'><p>Simulated WGBS data for PCBS vignettes</p></a></li>
<li><a href='#get_all_DMRs'>
<p>Nested DMR calling function within Get_Novel_DMRs()</p></a></li>
<li><a href='#Get_Novel_DMRs'><p>Call DMRs from WGBS data.</p></a></li>
<li><a href='#getPCRanks'><p>Get CpG eigenvector scores from a principle component.</p></a></li>
<li><a href='#getRegionScores'><p>Calculated methylation significance in a set of regions.</p></a></li>
<li><a href='#lin'>
<p>Find y value of linear regression given x.</p></a></li>
<li><a href='#lmIntx'>
<p>PC-Intersect nested function.</p></a></li>
<li><a href='#multiple_metagenes'><p>Plot multiple metagene data objects on a single plot.</p></a></li>
<li><a href='#Ol_Reliable'>
<p>PCBS ggplot theme.</p></a></li>
<li><a href='#oneSeed'>
<p>Nested DMR calling function within within get_all_DMRs(), Get_Novel_DMRs()</p></a></li>
<li><a href='#plot_metagene'><p>Generate a metagene plot from raw metagene data.</p></a></li>
<li><a href='#rankDist'><p>Identify the best rank cut-off for significant CpGs.</p></a></li>
<li><a href='#score_metagene'><p>Make a metagene from PC Scores.</p></a></li>
<li><a href='#se'><p>Standard error of a vector.</p></a></li>
<li><a href='#tilt'>
<p>Component of PCBS ggplot theme.</p></a></li>
<li><a href='#trimDMR'>
<p>Nested DMR calling function within within Get_Novel_DMRs()</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Principle Component BiSulfite</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>A system for fast, accurate, and flexible whole genome bisulfite sequencing (WGBS) data analysis of two-condition comparisons. Principle Component BiSulfite, 'PCBS', assigns methylated loci eigenvector values from the treatment-delineating principal component in lieu of running millions of pairwise statistical tests, which dramatically increases analysis flexibility and reduces computational requirements. Methods: <a href="https://katlande.github.io/PCBS/articles/Differential_Methylation.html">https://katlande.github.io/PCBS/articles/Differential_Methylation.html</a>. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/katlande/PCBS">https://github.com/katlande/PCBS</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/katlande/PCBS/issues">https://github.com/katlande/PCBS/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2, tibble, ggrepel, dplyr, data.table</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-22 17:45:12 UTC; kathrynlande</td>
</tr>
<tr>
<td>Author:</td>
<td>Kathryn Lande [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kathryn Lande &lt;kathryn.lande@mail.mcgill.ca&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-23 09:00:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='addRanks'>Add ranks to eigenvector scores.</h2><span id='topic+addRanks'></span>

<h3>Description</h3>

<p>Defines the best principle component to use for downstream analysis.</p>


<h3>Usage</h3>

<pre><code class='language-R'>addRanks(ranks)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addRanks_+3A_ranks">ranks</code></td>
<td>
<p>getPCRanks output data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input <code>data.frame</code> with rank order and absolute rank order columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ranks &lt;- getPCRanks(eigen, IDs = c("trt", "ctl"))
ranks &lt;- addRanks(ranks)
</code></pre>

<hr>
<h2 id='CheckOvercompression'>Check if DMR calling seed number is ovcompressed.</h2><span id='topic+CheckOvercompression'></span>

<h3>Description</h3>

<p>Identifies if seed number to use for DMR calling causes overcompression.</p>


<h3>Usage</h3>

<pre><code class='language-R'>CheckOvercompression(ranks, CpG_cutoff, values, max.dmr.size, return.plot)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CheckOvercompression_+3A_ranks">ranks</code></td>
<td>
<p>Rank data frame from getPCRanks.</p>
</td></tr>
<tr><td><code id="CheckOvercompression_+3A_cpg_cutoff">CpG_cutoff</code></td>
<td>
<p>NULL or numeric. If NULL, seed numbers tested will be input of the values argument. If numeric, seed numbers tested will be CpG_cutoff*values argument. Recommended to us rankDist estimate if not null</p>
</td></tr>
<tr><td><code id="CheckOvercompression_+3A_values">values</code></td>
<td>
<p>Numeric vector, either seed numbers to test if CpG_cutoff=NULL or multipliers if CpG_cutoff is numeric</p>
</td></tr>
<tr><td><code id="CheckOvercompression_+3A_max.dmr.size">max.dmr.size</code></td>
<td>
<p>Automatic=5000. Maximum DMR expansion size in downstream analysis. Note: pipeline is optimized for 5000bp max DMR size, it is not recommended to play with this value.</p>
</td></tr>
<tr><td><code id="CheckOvercompression_+3A_return.plot">return.plot</code></td>
<td>
<p>T/F, whether to return a plot or a numeric representing the best seed number for downstream analysis</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>return.plot=T</code>, a <code>grob</code> plotting input seed number vs. compressed seed number is returned. Otherwise, a <code>numeric</code> is returned containing the largest tested input value without detectable overcompression.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ranks &lt;- getPCRanks(eigen, IDs = c("trt", "ctl"), PC = 1)
CheckOvercompression(ranks, 980)
</code></pre>

<hr>
<h2 id='checkRank'>Check rank cut-off values manually.</h2><span id='topic+checkRank'></span>

<h3>Description</h3>

<p>Plots a score vs. rank plot with a manually chosen rank cut-off for manual k selection.</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkRank(ranks, cutoff)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkRank_+3A_ranks">ranks</code></td>
<td>
<p>getPCRanks output data frame</p>
</td></tr>
<tr><td><code id="checkRank_+3A_cutoff">cutoff</code></td>
<td>
<p>integer, rank value to check</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>grob</code> plotting the input <code>cutoff</code> on a plot of absolute eigenvector score vs. absolute rank order.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ranks &lt;- getPCRanks(eigen, IDs = c("trt", "ctl"), PC = 1)
test_50 &lt;- checkRank(ranks, 50) # set cut-off to 50
test_500 &lt;- checkRank(ranks, 500) # set cut-off to 500
</code></pre>

<hr>
<h2 id='chromDict'>Convert a rank object into a chromDict.</h2><span id='topic+chromDict'></span>

<h3>Description</h3>

<p>Internal to many functions; creates a chromDict for faster computing times. chromDict can be run separately to speed up functions run iteratively.
A chromDict is a list of chromosome-specific data.tables generated from ranks.</p>


<h3>Usage</h3>

<pre><code class='language-R'>chromDict(ranks)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chromDict_+3A_ranks">ranks</code></td>
<td>
<p>getPCRanks output data frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of <code>data.tables</code> for each chromosome, for faster analysis. Used internall by many PCBS functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ranks &lt;- getPCRanks(eigen, IDs = c("trt", "ctl"), PC = 1)
chromDictObj &lt;- chromDict(ranks)
</code></pre>

<hr>
<h2 id='DefineBestPC'>Identify your best principle component.</h2><span id='topic+DefineBestPC'></span>

<h3>Description</h3>

<p>Defines the best principle component to use for downstream analysis.</p>


<h3>Usage</h3>

<pre><code class='language-R'>DefineBestPC(mat, IDs, filter_thresh, return.plot)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DefineBestPC_+3A_mat">mat</code></td>
<td>
<p>Bismark2Matrix.R output file, or data frame object</p>
</td></tr>
<tr><td><code id="DefineBestPC_+3A_ids">IDs</code></td>
<td>
<p>A character vector of IDs containing the common names for compared conditions. E.g., for samples trt1, trt2 vs. ctl1, ctl2, IDs=c(&quot;trt&quot;, &quot;ctl&quot;)</p>
</td></tr>
<tr><td><code id="DefineBestPC_+3A_filter_thresh">filter_thresh</code></td>
<td>
<p>A coverage threshold for filtering, where CpG coverage of all samples must be larger than this value</p>
</td></tr>
<tr><td><code id="DefineBestPC_+3A_return.plot">return.plot</code></td>
<td>
<p>T/F, whether to return a PCA plot or a numeric representing the best principle component for downstream analysis</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>return.plot=T</code>, a <code>grob</code> plotting a PCA of percent methylation of all samples is returned. Otherwise, a <code>numeric</code> representing the best principal component to use for PCBS analysis is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DefineBestPC(eigen, IDs = c("trt", "ctl"))
</code></pre>

<hr>
<h2 id='eigen'>Simulated WGBS data for PCBS vignettes</h2><span id='topic+eigen'></span>

<h3>Description</h3>

<p>simulated WGBS data with added DMRs and DMLs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eigen
</code></pre>


<h3>Format</h3>

<p>A data frame with 50000 observations on the following 13 variables.
</p>

<dl>
<dt><code>cpgID</code></dt><dd><p>a character vector, chrom:locus</p>
</dd>
<dt><code>trt1_PercMeth</code></dt><dd><p>a numeric vector, percent methylated of sample trt1</p>
</dd>
<dt><code>trt1_nCpG</code></dt><dd><p>a numeric vector, depth of sample trt1</p>
</dd>
<dt><code>trt2_PercMeth</code></dt><dd><p>a numeric vector, percent methylated of sample trt2</p>
</dd>
<dt><code>trt2_nCpG</code></dt><dd><p>a numeric vector, depth of sample trt2</p>
</dd>
<dt><code>trt3_PercMeth</code></dt><dd><p>a numeric vector, percent methylated of sample trt3</p>
</dd>
<dt><code>trt3_nCpG</code></dt><dd><p>a numeric vector, depth of sample trt3</p>
</dd>
<dt><code>ctl1_PercMeth</code></dt><dd><p>a numeric vector, percent methylated of sample ctl1</p>
</dd>
<dt><code>ctl1_nCpG</code></dt><dd><p>a numeric vector, depth of sample ctl1</p>
</dd>
<dt><code>ctl2_PercMeth</code></dt><dd><p>a numeric vector, percent methylated of sample ctl2</p>
</dd>
<dt><code>ctl2_nCpG</code></dt><dd><p>a numeric vector, depth of sample ctl2</p>
</dd>
<dt><code>ctl3_PercMeth</code></dt><dd><p>a numeric vector, percent methylated of sample ctl3</p>
</dd>
<dt><code>ctl3_nCpG</code></dt><dd><p>a numeric vector, depth of sample ctl3</p>
</dd>
</dl>



<h3>Source</h3>

<p>generated through simulation
</p>

<hr>
<h2 id='get_all_DMRs'>
Nested DMR calling function within Get_Novel_DMRs()
</h2><span id='topic+get_all_DMRs'></span>

<h3>Description</h3>

<p>Expands DMRs from collapsed seeds iteratively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_all_DMRs(chromDictObj, seeds, res=40, max.dmr.size=3000, min.dmr.cpgs=10,
min.absZscore, null)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_all_DMRs_+3A_chromdictobj">chromDictObj</code></td>
<td>
<p>chromDict() output.</p>
</td></tr>
<tr><td><code id="get_all_DMRs_+3A_seeds">seeds</code></td>
<td>
<p>compressed seeds</p>
</td></tr>
<tr><td><code id="get_all_DMRs_+3A_res">res</code></td>
<td>
<p>Get_Novel_DMRs arg DMR_resolution</p>
</td></tr>
<tr><td><code id="get_all_DMRs_+3A_max.dmr.size">max.dmr.size</code></td>
<td>
<p>Get_Novel_DMRs arg QueryLimit</p>
</td></tr>
<tr><td><code id="get_all_DMRs_+3A_min.dmr.cpgs">min.dmr.cpgs</code></td>
<td>
<p>Get_Novel_DMRs arg minCpGs</p>
</td></tr>
<tr><td><code id="get_all_DMRs_+3A_min.abszscore">min.absZscore</code></td>
<td>
<p>Get_Novel_DMRs arg minZ</p>
</td></tr>
<tr><td><code id="get_all_DMRs_+3A_null">null</code></td>
<td>
<p>null distribution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>list</code> with two indicies, representing intermediate DMR calls within the <code>Get_Novel_DMRs()</code> function and a <code>list</code> of background regions..</p>

<hr>
<h2 id='Get_Novel_DMRs'>Call DMRs from WGBS data.</h2><span id='topic+Get_Novel_DMRs'></span>

<h3>Description</h3>

<p>DMR Calling.</p>


<h3>Usage</h3>

<pre><code class='language-R'>Get_Novel_DMRs(ranks, nSeeds, chromDictObj, DMR_resolution, 
QueryLimit, minCpGs, minZ, perms)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Get_Novel_DMRs_+3A_ranks">ranks</code></td>
<td>
<p>Rank data frame from getPCRanks.</p>
</td></tr>
<tr><td><code id="Get_Novel_DMRs_+3A_nseeds">nSeeds</code></td>
<td>
<p>Integer, number of input seeds for DMR expansion.</p>
</td></tr>
<tr><td><code id="Get_Novel_DMRs_+3A_chromdictobj">chromDictObj</code></td>
<td>
<p>chromDict() output. If null, chromDict() is run internally.</p>
</td></tr>
<tr><td><code id="Get_Novel_DMRs_+3A_dmr_resolution">DMR_resolution</code></td>
<td>
<p>Automatic=NULL. Integer, number of bases to increase the DMR by with each expansion. If NULL, QueryLimit/25.</p>
</td></tr>
<tr><td><code id="Get_Novel_DMRs_+3A_querylimit">QueryLimit</code></td>
<td>
<p>Automatic=5000. Maximum DMR expansion size (bp)</p>
</td></tr>
<tr><td><code id="Get_Novel_DMRs_+3A_mincpgs">minCpGs</code></td>
<td>
<p>Automatic=15. Minimum CpGs in a DMR region, regions with fewer CpGs will be discarded.</p>
</td></tr>
<tr><td><code id="Get_Novel_DMRs_+3A_minz">minZ</code></td>
<td>
<p>Automatic=1. Absolute Z score threshold for DMR calling; internal value. Not recommended to play with this setting.</p>
</td></tr>
<tr><td><code id="Get_Novel_DMRs_+3A_perms">perms</code></td>
<td>
<p>Automatic=1000. Number of permutations to use when defining the null distribution. Increasing this value largely influences computational time with minimal return</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>data.frame</code> of all novel DMRs.</p>


<h3>Examples</h3>

<pre><code class='language-R'>ranks &lt;- getPCRanks(eigen, IDs = c("trt", "ctl"), PC = 1)
DMRs &lt;- Get_Novel_DMRs(ranks, 2940, minCpGs=10)
</code></pre>

<hr>
<h2 id='getPCRanks'>Get CpG eigenvector scores from a principle component.</h2><span id='topic+getPCRanks'></span>

<h3>Description</h3>

<p>Returns eigenvector scores for input CpG sites.</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPCRanks(mat, IDs, PC, filter_thresh)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPCRanks_+3A_mat">mat</code></td>
<td>
<p>Bismark2Matrix.R output file, or data frame object</p>
</td></tr>
<tr><td><code id="getPCRanks_+3A_ids">IDs</code></td>
<td>
<p>A character vector of IDs containing the common names for compared conditions. E.g., for samples trt1 &amp; trt2 vs. ctl1 &amp; ctl2, IDs=c(&quot;trt1&quot;, &quot;ctl&quot;)</p>
</td></tr>
<tr><td><code id="getPCRanks_+3A_pc">PC</code></td>
<td>
<p>Integer, which principle component to use. Use to DefineBestPC if unsure.</p>
</td></tr>
<tr><td><code id="getPCRanks_+3A_filter_thresh">filter_thresh</code></td>
<td>
<p>Integer, a coverage threshold for filtering, where CpG coverage of all samples must be larger than this value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>data.frame</code> of eigenvector scores for all loci.</p>


<h3>Examples</h3>

<pre><code class='language-R'>ranks &lt;- getPCRanks(eigen, IDs = c("trt", "ctl"), PC = 1)
</code></pre>

<hr>
<h2 id='getRegionScores'>Calculated methylation significance in a set of regions.</h2><span id='topic+getRegionScores'></span>

<h3>Description</h3>

<p>Returns p-values and Z-scores for CpGs in a set of regions, compared to a local null background distribution.</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRegionScores(ranks, regions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getRegionScores_+3A_ranks">ranks</code></td>
<td>
<p>getPCRanks output data.frame</p>
</td></tr>
<tr><td><code id="getRegionScores_+3A_regions">regions</code></td>
<td>
<p>A three-column dataframe containing a set of regions to test. Columns = chrom, start, end.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>data.frame</code> with significance scores for all input regions.</p>


<h3>Examples</h3>

<pre><code class='language-R'>ranks &lt;- getPCRanks(eigen, IDs = c("trt", "ctl"), PC = 1)
DMLs &lt;- addRanks(ranks)

# data.frame of regions to test:
regions &lt;- data.frame(chr=c("chr3", "chr3", "chr1"),
                      s=c(4920450, 3961576, 300000),
                      e=c(4923267, 3963805, 302900),
                      ID=c("Hypo-DMR", "partial Hyper-DMR", "random"))
                
getRegionScores(DMLs, regions)
</code></pre>

<hr>
<h2 id='lin'>
Find y value of linear regression given x.
</h2><span id='topic+lin'></span>

<h3>Description</h3>

<p>Find y value of linear regression given x.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lin(x, l)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lin_+3A_x">x</code></td>
<td>
<p>x coordinate</p>
</td></tr>
<tr><td><code id="lin_+3A_l">l</code></td>
<td>
<p>linear model of lm()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a column <code>numeric</code> representing the y coordinate at the input <code>x</code> of the linear model <code>l</code>.
</p>

<hr>
<h2 id='lmIntx'>
PC-Intersect nested function.
</h2><span id='topic+lmIntx'></span>

<h3>Description</h3>

<p>Finds the intersection point of two linear regression models, lm().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmIntx(fit1, fit2, rnd=2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lmIntx_+3A_fit1">fit1</code></td>
<td>
<p>lm() model 1</p>
</td></tr>
<tr><td><code id="lmIntx_+3A_fit2">fit2</code></td>
<td>
<p>lm() model 2</p>
</td></tr>
<tr><td><code id="lmIntx_+3A_rnd">rnd</code></td>
<td>
<p>number of significant figures</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a 2 column <code>data.frame</code> of one row, containing the x and y coordinates of the intersection point of the input models.
</p>

<hr>
<h2 id='multiple_metagenes'>Plot multiple metagene data objects on a single plot.</h2><span id='topic+multiple_metagenes'></span>

<h3>Description</h3>

<p>Plots multiple metagene object using the raw data generated by score_metagene().</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiple_metagenes(data_list, set_names, title, xaxis, yaxis, legend.title, col, se_alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiple_metagenes_+3A_data_list">data_list</code></td>
<td>
<p>List of score_metagene() raw data output</p>
</td></tr>
<tr><td><code id="multiple_metagenes_+3A_set_names">set_names</code></td>
<td>
<p>Character vector of names for score_metagene() object</p>
</td></tr>
<tr><td><code id="multiple_metagenes_+3A_title">title</code></td>
<td>
<p>Output plot title</p>
</td></tr>
<tr><td><code id="multiple_metagenes_+3A_xaxis">xaxis</code></td>
<td>
<p>Output plot x-axis title</p>
</td></tr>
<tr><td><code id="multiple_metagenes_+3A_yaxis">yaxis</code></td>
<td>
<p>Output plot y-axis title</p>
</td></tr>
<tr><td><code id="multiple_metagenes_+3A_legend.title">legend.title</code></td>
<td>
<p>T/F, whether to show legend title</p>
</td></tr>
<tr><td><code id="multiple_metagenes_+3A_col">col</code></td>
<td>
<p>Vector of colours to use for lines</p>
</td></tr>
<tr><td><code id="multiple_metagenes_+3A_se_alpha">se_alpha</code></td>
<td>
<p>0-1, alpha value for standard error shading</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>grob</code> containing a plot of the input metagene data.</p>


<h3>Examples</h3>

<pre><code class='language-R'>ranks &lt;- getPCRanks(eigen, IDs = c("trt", "ctl"), PC = 1)
DMRs &lt;- Get_Novel_DMRs(ranks, 2940, minCpGs=10)

# Select all significantly hypomethylated DMRs:
hypo_DMRs &lt;- DMRs[DMRs$FDR &lt;= 0.05 &amp; DMRs$DMR_Zscore &lt; 0,] 
# Select all significantly hypermethylated DMRs:
hyper_DMRs &lt;- DMRs[DMRs$FDR &lt;= 0.05 &amp; DMRs$DMR_Zscore &gt; 0,]

# select chrom, start, and end of all hyper DMRs
regions_hypo &lt;- hypo_DMRs[c(1:3)] 
regions_hyper &lt;- hyper_DMRs[c(1:3)] 

# return.data = T returns raw data instead of a plot:
hyper_metagene &lt;- score_metagene(ranks, regions_hyper, return.data = TRUE)
hypo_metagene &lt;- score_metagene(ranks, regions_hypo, return.data = TRUE)

# The multiple_metagenes function plots multiple metagenes 
# using a list of raw data objects from score_metagene().
multiple_metagenes(data_list = list(hyper_metagene, hypo_metagene),
set_names = c("Hyper DMRs", "Hypo DMRs"),
title="Metagenes of DMR Regions", legend.title = FALSE)
</code></pre>

<hr>
<h2 id='Ol_Reliable'>
PCBS ggplot theme.
</h2><span id='topic+Ol_Reliable'></span>

<h3>Description</h3>

<p>Custom theme for ggplot used by all PCBS output figures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ol_Reliable()
</code></pre>


<h3>Value</h3>

<p>Theme for ggplot objects used by PCBS.</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(A=c(1,2,3), B=c(1,2,3))

ggplot2::ggplot(df, ggplot2::aes(x=A, y=B))+
ggplot2::geom_point()+
Ol_Reliable()

</code></pre>

<hr>
<h2 id='oneSeed'>
Nested DMR calling function within within get_all_DMRs(), Get_Novel_DMRs()
</h2><span id='topic+oneSeed'></span>

<h3>Description</h3>

<p>Expands one DMR from a single point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oneSeed(chroms, seed, resolution, max.size, mincpgs, null_list, Zlim=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oneSeed_+3A_chroms">chroms</code></td>
<td>
<p>chromDict() output.</p>
</td></tr>
<tr><td><code id="oneSeed_+3A_seed">seed</code></td>
<td>
<p>seed value input</p>
</td></tr>
<tr><td><code id="oneSeed_+3A_resolution">resolution</code></td>
<td>
<p>Get_Novel_DMRs arg DMR_resolution</p>
</td></tr>
<tr><td><code id="oneSeed_+3A_max.size">max.size</code></td>
<td>
<p>Get_Novel_DMRs arg QueryLimit</p>
</td></tr>
<tr><td><code id="oneSeed_+3A_mincpgs">mincpgs</code></td>
<td>
<p>Get_Novel_DMRs arg minCpGs</p>
</td></tr>
<tr><td><code id="oneSeed_+3A_null_list">null_list</code></td>
<td>
<p>get_all_DMRs arg null</p>
</td></tr>
<tr><td><code id="oneSeed_+3A_zlim">Zlim</code></td>
<td>
<p>Get_Novel_DMRs arg minZ</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a <code>list</code> of two indices, containing a <code>data.frame</code> with the output from a single compressed seed expansion and a <code>data.frame</code> of locus information around the seed expansion, intended for use within the <code>Get_Novel_DMRs()</code> function.</p>

<hr>
<h2 id='plot_metagene'>Generate a metagene plot from raw metagene data.</h2><span id='topic+plot_metagene'></span>

<h3>Description</h3>

<p>Plots a metagene object using the raw data generated by score_metagene().</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_metagene(data, title, xaxis, yaxis, linecol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_metagene_+3A_data">data</code></td>
<td>
<p>list, score_metagene() raw data output</p>
</td></tr>
<tr><td><code id="plot_metagene_+3A_title">title</code></td>
<td>
<p>Output plot title</p>
</td></tr>
<tr><td><code id="plot_metagene_+3A_xaxis">xaxis</code></td>
<td>
<p>Output plot x-axis title</p>
</td></tr>
<tr><td><code id="plot_metagene_+3A_yaxis">yaxis</code></td>
<td>
<p>Output plot y-axis title</p>
</td></tr>
<tr><td><code id="plot_metagene_+3A_linecol">linecol</code></td>
<td>
<p>Colour for line, auto=&quot;red&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>grob</code> containing a plot of the input metagene data.</p>


<h3>Examples</h3>

<pre><code class='language-R'>ranks &lt;- getPCRanks(eigen, IDs = c("trt", "ctl"), PC = 1)
DMRs &lt;- Get_Novel_DMRs(ranks, 2940, minCpGs=10)

# Select all significantly hypomethylated DMRs:
hypo_DMRs &lt;- DMRs[DMRs$FDR &lt;= 0.05 &amp; DMRs$DMR_Zscore &lt; 0,] 

# select chrom, start, and end of all hyper DMRs
regions_hypo &lt;- hypo_DMRs[c(1:3)] 

# return.data = T returns raw data instead of a plot:
hypo_metagene &lt;- score_metagene(ranks, regions_hypo, return.data = TRUE)

plot_metagene(hypo_metagene)
</code></pre>

<hr>
<h2 id='rankDist'>Identify the best rank cut-off for significant CpGs.</h2><span id='topic+rankDist'></span>

<h3>Description</h3>

<p>Automated rank cut-off estimator for input CpGs.</p>


<h3>Usage</h3>

<pre><code class='language-R'>rankDist(ranks, draw_intersects, noise_perc, mode, return.plot)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rankDist_+3A_ranks">ranks</code></td>
<td>
<p>getPCRanks output data frame.</p>
</td></tr>
<tr><td><code id="rankDist_+3A_draw_intersects">draw_intersects</code></td>
<td>
<p>T/F whether to draw intersect lines if return.plot=T</p>
</td></tr>
<tr><td><code id="rankDist_+3A_noise_perc">noise_perc</code></td>
<td>
<p>Automatic=0.5, numeric between 0 and 1. Fraction of ranks to use to model the background noise. Not recommended to play with this value. Increasing/decreasing returns a looser/stricter threshold, respectively.</p>
</td></tr>
<tr><td><code id="rankDist_+3A_mode">mode</code></td>
<td>
<p>&quot;intersect&quot; or &quot;strict&quot;, determine cut-off with &quot;intersect&quot; or &quot;strict&quot; method. &quot;Strict&quot; is recommended for sets with lower variability</p>
</td></tr>
<tr><td><code id="rankDist_+3A_return.plot">return.plot</code></td>
<td>
<p>T/F, whether to return a plot or a numeric</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>return.plot=T</code>, a <code>grob</code> plotting the estimated <code>cutoff</code> on a plot of absolute eigenvector score vs. absolute rank order is returned. Otherwise, a <code>numeric</code> of the estimated cut-off is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ranks &lt;- getPCRanks(eigen, IDs = c("trt", "ctl"), PC = 1)
rankDist(ranks, mode="intersect")
</code></pre>

<hr>
<h2 id='score_metagene'>Make a metagene from PC Scores.</h2><span id='topic+score_metagene'></span>

<h3>Description</h3>

<p>Uses mean binned PC scores across a set of regions to draw a metagene.</p>


<h3>Usage</h3>

<pre><code class='language-R'>score_metagene(ranks, regions, bin, title, xaxis, yaxis, 
chromDictObj, return.data, linecol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="score_metagene_+3A_ranks">ranks</code></td>
<td>
<p>getPCRanks output data.frame</p>
</td></tr>
<tr><td><code id="score_metagene_+3A_regions">regions</code></td>
<td>
<p>A three-column data.frame containing a set of regions to test. Columns = chrom, start, end.</p>
</td></tr>
<tr><td><code id="score_metagene_+3A_bin">bin</code></td>
<td>
<p>integer, number of bins to use in metagenes. Default=100.</p>
</td></tr>
<tr><td><code id="score_metagene_+3A_title">title</code></td>
<td>
<p>Output plot title</p>
</td></tr>
<tr><td><code id="score_metagene_+3A_xaxis">xaxis</code></td>
<td>
<p>Output plot x-axis title</p>
</td></tr>
<tr><td><code id="score_metagene_+3A_yaxis">yaxis</code></td>
<td>
<p>Output plot y-axis title</p>
</td></tr>
<tr><td><code id="score_metagene_+3A_chromdictobj">chromDictObj</code></td>
<td>
<p>Optional chromDictObject made from chromDict(), runs internally if set to NULL (default). Scripts that run this function multiple times will be sped up by setting this option.</p>
</td></tr>
<tr><td><code id="score_metagene_+3A_return.data">return.data</code></td>
<td>
<p>T/F, whether to return a plot, or data that can be run with plot_metagene() or multiple_metagenes().</p>
</td></tr>
<tr><td><code id="score_metagene_+3A_linecol">linecol</code></td>
<td>
<p>Colour for line, auto=&quot;red&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>return.data=F</code>, returns a <code>grob</code> containing a metagene plot. Otherwise, returns a <code>list</code> of two <code>data.frames</code> containing metagene and metagene standard error plotting information.</p>


<h3>Examples</h3>

<pre><code class='language-R'>ranks &lt;- getPCRanks(eigen, IDs = c("trt", "ctl"), PC = 1)
DMRs &lt;- Get_Novel_DMRs(ranks, 2940, minCpGs=10)

# select chrom, start, and end of all hyper DMRs:
hyper_DMRs &lt;- DMRs[DMRs$FDR &lt;= 0.05 &amp; DMRs$DMR_Zscore &gt; 0,]
regions_hyper &lt;- hyper_DMRs[c(1:3)] 
score_metagene(ranks, regions_hyper)
</code></pre>

<hr>
<h2 id='se'>Standard error of a vector.</h2><span id='topic+se'></span>

<h3>Description</h3>

<p>Takes the standard error of a vector.</p>


<h3>Usage</h3>

<pre><code class='language-R'>se(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="se_+3A_x">x</code></td>
<td>
<p>numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>numeric</code>, representing the standard error of the input vector.</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sample(1:100, 20)
se(x)
</code></pre>

<hr>
<h2 id='tilt'>
Component of PCBS ggplot theme.
</h2><span id='topic+tilt'></span>

<h3>Description</h3>

<p>Wrapper to title x-axis text in ggplot objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tilt()
</code></pre>


<h3>Value</h3>

<p>Theme for ggplot objects that cleanly rotates x-axis text.</p>

<hr>
<h2 id='trimDMR'>
Nested DMR calling function within within Get_Novel_DMRs()
</h2><span id='topic+trimDMR'></span>

<h3>Description</h3>

<p>Trims the edges off of DMR expansions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trimDMR(df, region, min.dmr.cpgs, max.dmr.size, null_summary, null_values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trimDMR_+3A_df">df</code></td>
<td>
<p>DMR expansion output dataframe.</p>
</td></tr>
<tr><td><code id="trimDMR_+3A_region">region</code></td>
<td>
<p>get_all_DMRs() region output</p>
</td></tr>
<tr><td><code id="trimDMR_+3A_min.dmr.cpgs">min.dmr.cpgs</code></td>
<td>
<p>Get_Novel_DMRs arg minCpGs</p>
</td></tr>
<tr><td><code id="trimDMR_+3A_max.dmr.size">max.dmr.size</code></td>
<td>
<p>Get_Novel_DMRs arg QueryLimit</p>
</td></tr>
<tr><td><code id="trimDMR_+3A_null_summary">null_summary</code></td>
<td>
<p>null distribution conrtainer</p>
</td></tr>
<tr><td><code id="trimDMR_+3A_null_values">null_values</code></td>
<td>
<p>null distribution conrtainer</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>data.frame</code> of all trimmed DMRs for use within the <code>Get_Novel_DMRs()</code> function.</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
