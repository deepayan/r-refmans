<!DOCTYPE html><html><head><title>Help for package HospitalNetwork</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {HospitalNetwork}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adjust_overlapping_stays'><p>Check and fix overlapping admissions.</p></a></li>
<li><a href='#all_admissions_summary'><p>Summary statistics on entire database</p></a></li>
<li><a href='#checkBase'><p>General check function</p></a></li>
<li><a href='#checkFormat'><p>Check database format</p></a></li>
<li><a href='#create_fake_subjectDB'><p>Create a fake subject database</p></a></li>
<li><a href='#create_fake_subjectDB_clustered'><p>Create a fake subject database with clustering</p></a></li>
<li><a href='#create_subject_stay'><p>Create a fake subject stay</p></a></li>
<li><a href='#edgelist_from_base'><p>Compute the edgelist of a network from a database of movements records.</p></a></li>
<li><a href='#get_betweenness'><p>Compute the betweenness centrality</p></a></li>
<li><a href='#get_closeness'><p>Compute closeness</p></a></li>
<li><a href='#get_clusters'><p>Compute the clusters</p></a></li>
<li><a href='#get_degree'><p>Compute the degree of each nodes in the network</p></a></li>
<li><a href='#get_hubs_bycluster'><p>Function computing hub scores of nodes by group</p></a></li>
<li><a href='#get_hubs_global'><p>Function computing hub scores for each node. If bycluster = TRUE, hub scores are computed by cluster</p></a></li>
<li><a href='#get_matrix_bycluster'><p>Function returning matrices of transfers within each by clusters</p></a></li>
<li><a href='#get_metrics'><p>Compute network metrics</p></a></li>
<li><a href='#HospiNet'><p>Class providing the HospiNet object with its methods</p></a></li>
<li><a href='#hospinet_from_subject_database'><p>Create HospiNet object from subject database</p></a></li>
<li><a href='#matrix_from_base'><p>Compute the adjacency matrix of a network from a database of movements records.</p></a></li>
<li><a href='#matrix_from_edgelist'><p>Compute the adjacency matrix of a network from its edgelist</p></a></li>
<li><a href='#per_facility_summary'><p>Function that extracts summary statistics from entire database</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Building Networks of Hospitals Through Patients Transfers</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Set of tools to help interested researchers to build hospital networks 
  from data on hospitalized patients transferred between hospitals. Methods provided 
  have been used in Donker T, Wallinga J, Grundmann H. (2010) &lt;<a href="https://doi.org/10.1371%2Fjournal.pcbi.1000715">doi:10.1371/journal.pcbi.1000715</a>&gt;, 
  and Nekkab N, Crépey P, Astagneau P, Opatowski L, Temime L. (2020) &lt;<a href="https://doi.org/10.1038%2Fs41598-020-71212-6">doi:10.1038/s41598-020-71212-6</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://pascalcrepey.github.io/HospitalNetwork/">https://pascalcrepey.github.io/HospitalNetwork/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/PascalCrepey/HospitalNetwork/issues">https://github.com/PascalCrepey/HospitalNetwork/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>checkmate, igraph, lubridate, R6, ggplot2, ggraph</td>
</tr>
<tr>
<td>Depends:</td>
<td>data.table</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 2.1.0), shiny, shinyWidgets,
shinydashboard, DT, shinyalert, shinyjs, vdiffr, pander, glue,
golem, htmltools</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-02-25 14:28:38 UTC; pascalcrepey</td>
</tr>
<tr>
<td>Author:</td>
<td>Pascal Crépey [aut, cre, cph],
  Tjibbe Donker [aut],
  Clément Massonnaud [aut],
  Michael Lydeamore [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Pascal Crépey &lt;pascal.crepey@ehesp.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-02-27 08:22:43 UTC</td>
</tr>
</table>
<hr>
<h2 id='adjust_overlapping_stays'>Check and fix overlapping admissions.</h2><span id='topic+adjust_overlapping_stays'></span>

<h3>Description</h3>

<p>This function checks if a discharge (n) is not later than the next (n+1) admission.
If this is the case, it sets the date of discharge n to date of discharge n+1, and creates an extra record running from discharge n+1 to discharge n.
If the length of stay of this record is negative, it removes it.
It is possible that one pass of this algorithm doesn't clear all overlapping admissions (e.g. when one admission overlaps with more than one other admission), it is therefore iterated until no overlapping admissions are found.
Returns the corrected database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjust_overlapping_stays(
  report,
  maxIteration = 25,
  verbose = FALSE,
  retainAuxData = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjust_overlapping_stays_+3A_report">report</code></td>
<td>
<p>(list).
A list containing the base and in which will be stored reporting variables.
The base is a patient discharge database, in the form of a data.table. The data.table should have at least the following columns:
sID: subjectID (character)
fID: facilityID (character)
Adate: admission date (POSIXct, but character can be converted to POSIXct)
Ddate: discharge date (POSIXct, but character can be converted to POSIXct)</p>
</td></tr>
<tr><td><code id="adjust_overlapping_stays_+3A_maxiteration">maxIteration</code></td>
<td>
<p>(integer) the maximum number of times the function will try and remove overlapping admissions.</p>
</td></tr>
<tr><td><code id="adjust_overlapping_stays_+3A_verbose">verbose</code></td>
<td>
<p>(boolean) print diagnostic messages. Default is FALSE.</p>
</td></tr>
<tr><td><code id="adjust_overlapping_stays_+3A_retainauxdata">retainAuxData</code></td>
<td>
<p>(boolean) allow retaining additional data provided in the database. Default is TRUE.</p>
</td></tr>
<tr><td><code id="adjust_overlapping_stays_+3A_...">...</code></td>
<td>
<p>other parameters passed on to internal functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The corrected database as data.table.
</p>

<hr>
<h2 id='all_admissions_summary'>Summary statistics on entire database</h2><span id='topic+all_admissions_summary'></span>

<h3>Description</h3>

<p>Function that extracts summary statistics from entire database
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_admissions_summary(base, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all_admissions_summary_+3A_base">base</code></td>
<td>
<p>(data.table).
A subject discharge database, in the form of a data.table. The data.table should have at least the following columns:
sID: subjectID (character)
fID: facilityID (character)
Adate: admission date (date)
Ddate: discharge date (date)</p>
</td></tr>
<tr><td><code id="all_admissions_summary_+3A_verbose">verbose</code></td>
<td>
<p>(boolean) print diagnostic messages. Default is TRUE.</p>
</td></tr>
<tr><td><code id="all_admissions_summary_+3A_...">...</code></td>
<td>
<p>other parameters passed on to internal functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of summary statistics:
-   meanLOS: The mean length of stay, in days
-   meanTBA: The mean time between admissions, in days
-   totalAdmissions: Total number of admissions (i.e. number of records in the database)
-   numSubjects: Number of unique subjects
-   numFacilities: Number of unique facilities
-   LOSdistribution: Distribution of length of stay
-   TBAdistribution: Distribution of time between admissions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mydb &lt;- create_fake_subjectDB(n_subjects = 100, n_facilities = 10)
myBase &lt;- checkBase(mydb)
all_admissions_summary(myBase)
</code></pre>

<hr>
<h2 id='checkBase'>General check function</h2><span id='topic+checkBase'></span>

<h3>Description</h3>

<p>Function that performs various checks to ensure the database is correctly formatted, and adjusts overlapping patient records.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkBase(
  base,
  convertDates = FALSE,
  dateFormat = NULL,
  deleteMissing = NULL,
  deleteErrors = NULL,
  subjectID = "sID",
  facilityID = "fID",
  disDate = "Ddate",
  admDate = "Adate",
  maxIteration = 25,
  retainAuxData = TRUE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkBase_+3A_base">base</code></td>
<td>
<p>(data.table).
A patient discharge database, in the form of a data.table. The data.table should have at least the following columns:
sID: patientID (character)
fID: facilityID (character)
Adate: admission date (POSIXct, but character can be converted to POSIXct)
Ddate: discharge date (POSIXct, but character can be converted to POSIXct)</p>
</td></tr>
<tr><td><code id="checkBase_+3A_convertdates">convertDates</code></td>
<td>
<p>(boolean) indicating if dates need to be converted to POSIXct if they are not</p>
</td></tr>
<tr><td><code id="checkBase_+3A_dateformat">dateFormat</code></td>
<td>
<p>(character) giving the input format of the date character string (e.g. &quot;ymd&quot; for dates like &quot;2019-10-30&quot;)
See <code><a href="lubridate.html#topic+parse_date_time">parse_date_time</a></code> for more information on the format.</p>
</td></tr>
<tr><td><code id="checkBase_+3A_deletemissing">deleteMissing</code></td>
<td>
<p>(character) How to handle records that contain a missing value in at least one of the four mandatory variables:
NULL (default): do not delete. Stops the function with an error message.
&quot;record&quot;: deletes just the incorrect record.
&quot;patient&quot;: deletes all records of each patient with one or more incorrect records.</p>
</td></tr>
<tr><td><code id="checkBase_+3A_deleteerrors">deleteErrors</code></td>
<td>
<p>(character) How incorrect records should be deleted:
&quot;record&quot; deletes just the incorrect record
&quot;patient&quot; deletes all records of each patient with one or more incorrect records.</p>
</td></tr>
<tr><td><code id="checkBase_+3A_subjectid">subjectID</code></td>
<td>
<p>(character) the columns name containing the subject ID. Default is &quot;sID&quot;</p>
</td></tr>
<tr><td><code id="checkBase_+3A_facilityid">facilityID</code></td>
<td>
<p>(character) the columns name containing the facility ID. Default is &quot;fID&quot;</p>
</td></tr>
<tr><td><code id="checkBase_+3A_disdate">disDate</code></td>
<td>
<p>(character) the columns name containing the discharge date. Default is &quot;Ddate&quot;</p>
</td></tr>
<tr><td><code id="checkBase_+3A_admdate">admDate</code></td>
<td>
<p>(character) the columns name containing the admission date. Default is &quot;Adate&quot;</p>
</td></tr>
<tr><td><code id="checkBase_+3A_maxiteration">maxIteration</code></td>
<td>
<p>(integer) the maximum number of times the function will try and remove overlapping admissions</p>
</td></tr>
<tr><td><code id="checkBase_+3A_retainauxdata">retainAuxData</code></td>
<td>
<p>(boolean) allow retaining additional data provided in the database. Default is TRUE.</p>
</td></tr>
<tr><td><code id="checkBase_+3A_verbose">verbose</code></td>
<td>
<p>(boolean) print diagnostic messages. Default is TRUE.</p>
</td></tr>
<tr><td><code id="checkBase_+3A_...">...</code></td>
<td>
<p>other parameters passed on to internal functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The adjusted database as a data.table with a new class attribute &quot;hospinet.base&quot; and an attribute &quot;report&quot; containing information related to the quality of the database.
</p>


<h3>See Also</h3>

<p><code><a href="lubridate.html#topic+parse_date_time">parse_date_time</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## create a "fake and custom" data base
mydb = create_fake_subjectDB(n_subjects = 100, n_facilities = 100)
setnames(mydb, 1:4, c("myPatientId", "myHealthCareCenterID", "DateOfAdmission", "DateOfDischarge"))
mydb[,DateOfAdmission:= as.character(DateOfAdmission)]
mydb[,DateOfDischarge:= as.character(DateOfDischarge)]

head(mydb)
#   myPatientId myHealthCareCenterID DateOfAdmission DateOfDischarge
#1:        s001                 f078      2019-01-26      2019-02-01
#2:        s002                 f053      2019-01-18      2019-01-21
#3:        s002                 f049      2019-02-25      2019-03-05
#4:        s002                 f033      2019-04-17      2019-04-21
#5:        s003                 f045      2019-02-02      2019-02-04
#6:        s003                 f087      2019-03-12      2019-03-19

str(mydb)
#Classes ‘data.table’ and 'data.frame':	262 obs. of  4 variables:
# $ myPatientId         : chr  "s001" "s002" "s002" "s002" ...
# $ myHealthCareCenterID: chr  "f078" "f053" "f049" "f033" ...
# $ DateOfAdmission     : chr  "2019-01-26" "2019-01-18" "2019-02-25" "2019-04-17" ...
# $ DateOfDischarge     : chr  "2019-02-01" "2019-01-21" "2019-03-05" "2019-04-21" ...
#- attr(*, ".internal.selfref")=&lt;externalptr&gt; 

my_checked_db = checkBase(mydb, 
     subjectID = "myPatientId", 
     facilityID = "myHealthCareCenterID", 
     disDate = "DateOfDischarge",
     admDate = "DateOfAdmission", 
     convertDates = TRUE, 
     dateFormat = "ymd")

#Converting Adate, Ddate to Date format
#Checking for missing values...
#Checking for duplicated records...
#Removed 0 duplicates
#Done.

head(my_checked_db)
#    sID  fID      Adate      Ddate
#1: s001 f078 2019-01-26 2019-02-01
#2: s002 f053 2019-01-18 2019-01-21
#3: s002 f049 2019-02-25 2019-03-05
#4: s002 f033 2019-04-17 2019-04-21
#5: s003 f045 2019-02-02 2019-02-04
#6: s003 f087 2019-03-12 2019-03-19
str(my_checked_db)
#Classes ‘hospinet.base’, ‘data.table’ and 'data.frame':	262 obs. of  4 variables:
#$ sID  : chr  "s001" "s002" "s002" "s002" ...
#$ fID  : chr  "f078" "f053" "f049" "f033" ...
#$ Adate: POSIXct, format: "2019-01-26" "2019-01-18" "2019-02-25" "2019-04-17" ...
#$ Ddate: POSIXct, format: "2019-02-01" "2019-01-21" "2019-03-05" "2019-04-21" ...
# ...

## Show the quality report
attr(my_checked_db, "report")
</code></pre>

<hr>
<h2 id='checkFormat'>Check database format</h2><span id='topic+checkFormat'></span>

<h3>Description</h3>

<p>Function that performs various generic checks to ensure that the database has the correct format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkFormat(report, convertDates = FALSE, dateFormat = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkFormat_+3A_report">report</code></td>
<td>
<p>(list).
A list containing the base and in which will be stored reporting variables.
The base is a patient discharge database, in the form of a data.table. The data.table should have at least the following columns:
sID: subjectID (character)
fID: facilityID (character)
Adate: admission date (POSIXct, but character can be converted to POSIXct)
Ddate: discharge date (POSIXct, but character can be converted to POSIXct)</p>
</td></tr>
<tr><td><code id="checkFormat_+3A_convertdates">convertDates</code></td>
<td>
<p>(boolean) TRUE/FALSE: whether the dates should converted. Default is TRUE.</p>
</td></tr>
<tr><td><code id="checkFormat_+3A_dateformat">dateFormat</code></td>
<td>
<p>(boolean) The format of date as a character string (e.g. %y%m%d for 20190524, or %d-%m-%y for 24-05-2019).</p>
</td></tr>
<tr><td><code id="checkFormat_+3A_verbose">verbose</code></td>
<td>
<p>(boolean) print diagnostic messages. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns either an error message, or the database (modified if need be).
</p>

<hr>
<h2 id='create_fake_subjectDB'>Create a fake subject database</h2><span id='topic+create_fake_subjectDB'></span>

<h3>Description</h3>

<p>Create a fake subject database
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_fake_subjectDB(
  n_subjects = 100,
  n_facilities = 10,
  avg_n_stays = 3,
  days_since_discharge = NULL,
  length_of_stay = NULL,
  start_id_subjects = 1,
  start_id_facilities = 1,
  with_errors = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_fake_subjectDB_+3A_n_subjects">n_subjects</code></td>
<td>
<p>the number of different subjects in the database</p>
</td></tr>
<tr><td><code id="create_fake_subjectDB_+3A_n_facilities">n_facilities</code></td>
<td>
<p>the number of facility present in the database</p>
</td></tr>
<tr><td><code id="create_fake_subjectDB_+3A_avg_n_stays">avg_n_stays</code></td>
<td>
<p>the average number of stays per subject</p>
</td></tr>
<tr><td><code id="create_fake_subjectDB_+3A_days_since_discharge">days_since_discharge</code></td>
<td>
<p>the number of days between a discharge date and an admission date (default: max(0, rnorm(1, mean = 30, sd = 10)))</p>
</td></tr>
<tr><td><code id="create_fake_subjectDB_+3A_length_of_stay">length_of_stay</code></td>
<td>
<p>the length of stay (default: max(1, rnorm(1, mean = 5, sd = 3) )</p>
</td></tr>
<tr><td><code id="create_fake_subjectDB_+3A_start_id_subjects">start_id_subjects</code>, <code id="create_fake_subjectDB_+3A_start_id_facilities">start_id_facilities</code></td>
<td>
<p>change starting ids (used for clustered network)</p>
</td></tr>
<tr><td><code id="create_fake_subjectDB_+3A_with_errors">with_errors</code></td>
<td>
<p>(boolean) introduce or not random errors in the database. Default to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.table containing all subjects stays
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mydb &lt;- create_fake_subjectDB(n_subjects = 100, n_facilities = 10)
mydb
</code></pre>

<hr>
<h2 id='create_fake_subjectDB_clustered'>Create a fake subject database with clustering</h2><span id='topic+create_fake_subjectDB_clustered'></span>

<h3>Description</h3>

<p>Create a fake subject database with clustering
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_fake_subjectDB_clustered(
  n_subjects = 50,
  n_facilities = 10,
  avg_n_stays = 3,
  days_since_discharge = NULL,
  length_of_stay = NULL,
  n_clusters = 3
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_fake_subjectDB_clustered_+3A_n_subjects">n_subjects</code></td>
<td>
<p>the number of different subjects in the database</p>
</td></tr>
<tr><td><code id="create_fake_subjectDB_clustered_+3A_n_facilities">n_facilities</code></td>
<td>
<p>the number of facility present in the database</p>
</td></tr>
<tr><td><code id="create_fake_subjectDB_clustered_+3A_avg_n_stays">avg_n_stays</code></td>
<td>
<p>the average number of stays per subject</p>
</td></tr>
<tr><td><code id="create_fake_subjectDB_clustered_+3A_days_since_discharge">days_since_discharge</code></td>
<td>
<p>the number of days between a discharge date and an admission date (default: max(0, rnorm(1, mean = 30, sd = 10)))</p>
</td></tr>
<tr><td><code id="create_fake_subjectDB_clustered_+3A_length_of_stay">length_of_stay</code></td>
<td>
<p>the length of stay (default: max(1, rnorm(1, mean = 5, sd = 3) )</p>
</td></tr>
<tr><td><code id="create_fake_subjectDB_clustered_+3A_n_clusters">n_clusters</code></td>
<td>
<p>the number of cluster in the network</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.table containing all subjects stays
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mydb &lt;- create_fake_subjectDB_clustered(n_subjects = 100, n_facilities = 10)
mydb
</code></pre>

<hr>
<h2 id='create_subject_stay'>Create a fake subject stay</h2><span id='topic+create_subject_stay'></span>

<h3>Description</h3>

<p>create_subject_stay is an internal function used by create_fake_subjectDB.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_subject_stay(
  sID,
  fID,
  last_discharge_date = NULL,
  days_since_discharge = NULL,
  length_of_stay = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_subject_stay_+3A_sid">sID</code></td>
<td>
<p>the subject ID</p>
</td></tr>
<tr><td><code id="create_subject_stay_+3A_fid">fID</code></td>
<td>
<p>the facility ID</p>
</td></tr>
<tr><td><code id="create_subject_stay_+3A_last_discharge_date">last_discharge_date</code></td>
<td>
<p>the last discharge date</p>
</td></tr>
<tr><td><code id="create_subject_stay_+3A_days_since_discharge">days_since_discharge</code></td>
<td>
<p>the number of days since last discharge (default: max(0, rnorm(1, mean = 30, sd = 10)))</p>
</td></tr>
<tr><td><code id="create_subject_stay_+3A_length_of_stay">length_of_stay</code></td>
<td>
<p>the length of stay (default: max(1, rnorm(1, mean = 5, sd = 3))</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a one row data.table corresponding to the subject stay.
</p>

<hr>
<h2 id='edgelist_from_base'>Compute the edgelist of a network from a database of movements records.</h2><span id='topic+edgelist_from_base'></span>

<h3>Description</h3>

<p>This function computes the edgelist of a network of facilities across
which subjects can be transferred. The edgelist is computed from a database that
contains the records of the subjects' stays in the facilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edgelist_from_base(
  base,
  window_threshold = 365,
  count_option = "successive",
  prob_params = c(0.0036, 1/365, 0.128),
  condition = "dates",
  noloops = TRUE,
  nmoves_threshold = NULL,
  flag_vars = NULL,
  flag_values = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edgelist_from_base_+3A_base">base</code></td>
<td>
<p>(data.table) A database of records of stays of subjects in
facilities. The table should have at least the following columns:
</p>
 <ul>
<li><p><b>subjectID</b> (character) unique subject identifier
</p>
</li>
<li><p><b>facilityID</b> (character) unique facility identifier
</p>
</li>
<li><p><b>admDate</b> (POSIXct) date of admission in the facility
</p>
</li>
<li><p><b>disDate</b> (POSIXct) date of discharge of the facility </p>
</li></ul>
</td></tr>
<tr><td><code id="edgelist_from_base_+3A_window_threshold">window_threshold</code></td>
<td>
<p>(integer) A number of days. If two stays of a subject
at two facilities occurred within this window, this constitutes a
connection between the two facilities (given that potential other
conditions are met).</p>
</td></tr>
<tr><td><code id="edgelist_from_base_+3A_count_option">count_option</code></td>
<td>
<p>(character) How to count connections. Options are
&quot;successive&quot;, &quot;probability&quot; or &quot;all&quot;. See details.</p>
</td></tr>
<tr><td><code id="edgelist_from_base_+3A_prob_params">prob_params</code></td>
<td>
<p>(vector of numeric) Three numerical values to calculate
the probability that a movement causes an introduction from hospital A
to hospital B. See Donker T, Wallinga J, Grundmann H. (2010) &lt;doi:10.1371/journal.pcbi.1000715&gt; for more details.
For use with count_option=&quot;probability&quot;.
prob_params[1] is the rate of acquisition in hospital A (related to LOS
in hospital A). Default: 0.0036
prob_params[2] is the rate of loss of colonisation (related to time
between admissions). Default: 1/365
prob_params[4] is the rate of transmission to other patients in hospital
B (related to LOS in hospital B). Default: 0.128</p>
</td></tr>
<tr><td><code id="edgelist_from_base_+3A_condition">condition</code></td>
<td>
<p>(character) Condition(s) used to decide what constitutes a
connection. Can be &quot;dates&quot;, &quot;flags&quot;, or &quot;both&quot;. See details.</p>
</td></tr>
<tr><td><code id="edgelist_from_base_+3A_noloops">noloops</code></td>
<td>
<p>(boolean). Should transfers within the same nodes (loops) be
kept or set to 0. Defaults to TRUE, removing loops (setting matrix
diagonal to 0).</p>
</td></tr>
<tr><td><code id="edgelist_from_base_+3A_nmoves_threshold">nmoves_threshold</code></td>
<td>
<p>(numeric) A threshold for the minimum number of
subject transfer between two facilities. Set to NULL to deactivate,
default to NULL.</p>
</td></tr>
<tr><td><code id="edgelist_from_base_+3A_flag_vars">flag_vars</code></td>
<td>
<p>(list) Additional variables that can help flag a transfer,
besides the dates of admission and discharge. Must be a named list of two
character vectors which are the names of the columns that can flag a
transfer: the column that can flag a potential origin, and the column
that can flag a potential target. The list must be named with &quot;origin&quot;
and &quot;transfer&quot;. Eg: list(&quot;origin&quot; = &quot;var1&quot;, &quot;target&quot; = &quot;var2&quot;). See
details.</p>
</td></tr>
<tr><td><code id="edgelist_from_base_+3A_flag_values">flag_values</code></td>
<td>
<p>(list) A named list of two character vectors which contain
the values of the variables in flag_var that are matched to flag a
potential transfer. The list must be named with &quot;origin&quot; and
&quot;transfer&quot;. The character vectors might be of length greater than
one. Eg: list(&quot;origin&quot; = c(&quot;value1&quot;, &quot;value2&quot;), &quot;target&quot; = c(&quot;value2&quot;,
&quot;value2&quot;)). The values in 'origin' and 'target' are the values that flag
a potential origin of a transfer, or a potential target,
respectively. See details.</p>
</td></tr>
<tr><td><code id="edgelist_from_base_+3A_verbose">verbose</code></td>
<td>
<p>TRUE to print computation steps</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The edgelist contains the information on the connections between
nodes of the network, that is the movements of subjects between
facilities. The edgelist can be in two different formats: long or
aggregated. In long format, each row corresponds to a single movement
between two facilities, therefore only two columns are needed, one
containing the origin facilities of a movement, the other containing the
target facilities. In aggregated format, the edgelist is aggregated by
unique pairs of origin-target facilities.
</p>


<h3>Value</h3>

<p>A list of two data.tables, which are the edgelists. One in long
format (el_long), and one aggregated by pair of nodes (el_aggr).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+matrix_from_edgelist">matrix_from_edgelist</a></code>, <code><a href="#topic+matrix_from_base">matrix_from_base</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mydb &lt;- create_fake_subjectDB(n_subjects = 100, n_facilities = 10)
myBase &lt;- checkBase(mydb)
edgelist_from_base(myBase)
</code></pre>

<hr>
<h2 id='get_betweenness'>Compute the betweenness centrality</h2><span id='topic+get_betweenness'></span>

<h3>Description</h3>

<p>Compute the betweenness centrality
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_betweenness(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_betweenness_+3A_graph">graph</code></td>
<td>
<p>an igraph object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.table containing the centrality measure
</p>

<hr>
<h2 id='get_closeness'>Compute closeness</h2><span id='topic+get_closeness'></span>

<h3>Description</h3>

<p>Compute one or several closeness measure for facility networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_closeness(graph, modes = "total")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_closeness_+3A_graph">graph</code></td>
<td>
<p>an igraph object</p>
</td></tr>
<tr><td><code id="get_closeness_+3A_modes">modes</code></td>
<td>
<p>option passed on to igraph::closeness : &quot;out&quot;, &quot;in&quot;, &quot;all&quot;, &quot;total&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.table containing the closeness measure
</p>


<h3>See Also</h3>

<p><code><a href="igraph.html#topic+closeness">closeness</a></code>
</p>

<hr>
<h2 id='get_clusters'>Compute the clusters</h2><span id='topic+get_clusters'></span>

<h3>Description</h3>

<p>Compute the clusters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_clusters(graph, algos, undirected, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_clusters_+3A_graph">graph</code></td>
<td>
<p>an igraph object</p>
</td></tr>
<tr><td><code id="get_clusters_+3A_algos">algos</code></td>
<td>
<p>the type of algorithm, single argument describing a cluster function from the igraph package</p>
</td></tr>
<tr><td><code id="get_clusters_+3A_undirected">undirected</code></td>
<td>
<p>either &quot;mutual&quot; or &quot;arbitrary&quot;</p>
</td></tr>
<tr><td><code id="get_clusters_+3A_...">...</code></td>
<td>
<p>other arguments to be passed on to the algorithm</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.table
</p>

<hr>
<h2 id='get_degree'>Compute the degree of each nodes in the network</h2><span id='topic+get_degree'></span>

<h3>Description</h3>

<p>Compute the degree of each nodes in the network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_degree(graph, modes = c("in", "out", "total"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_degree_+3A_graph">graph</code></td>
<td>
<p>an igraph object</p>
</td></tr>
<tr><td><code id="get_degree_+3A_modes">modes</code></td>
<td>
<p>the type of degree: &quot;in&quot;, &quot;out&quot;, &quot;total&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.table of nodes degree
</p>

<hr>
<h2 id='get_hubs_bycluster'>Function computing hub scores of nodes by group</h2><span id='topic+get_hubs_bycluster'></span>

<h3>Description</h3>

<p>Function computing hub scores of nodes by group
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_hubs_bycluster(graphs, name, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_hubs_bycluster_+3A_graphs">graphs</code></td>
<td>
<p>A list of igraph graphs, one for each group within which the hub scores will be computed</p>
</td></tr>
<tr><td><code id="get_hubs_bycluster_+3A_name">name</code></td>
<td>
<p>[character (1)] The name of grouping variable (used only for naming the column of the DT)</p>
</td></tr>
<tr><td><code id="get_hubs_bycluster_+3A_...">...</code></td>
<td>
<p>Optional arguments to be passed to igraph function 'hub_score()'</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="igraph.html#topic+hub_score">hub_score</a></code>
</p>

<hr>
<h2 id='get_hubs_global'>Function computing hub scores for each node. If bycluster = TRUE, hub scores are computed by cluster</h2><span id='topic+get_hubs_global'></span>

<h3>Description</h3>

<p>Function computing hub scores for each node. If bycluster = TRUE, hub scores are computed by cluster
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_hubs_global(graph, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_hubs_global_+3A_graph">graph</code></td>
<td>
<p>An igraph graph</p>
</td></tr>
<tr><td><code id="get_hubs_global_+3A_...">...</code></td>
<td>
<p>other arguments to be passed to igraph function hub_score()</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="igraph.html#topic+hub_score">hub_score</a></code>
</p>

<hr>
<h2 id='get_matrix_bycluster'>Function returning matrices of transfers within each by clusters</h2><span id='topic+get_matrix_bycluster'></span>

<h3>Description</h3>

<p>Function returning matrices of transfers within each by clusters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_matrix_bycluster(mat, DT, clusters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_matrix_bycluster_+3A_mat">mat</code></td>
<td>
<p>The adjacency matrix of the network</p>
</td></tr>
<tr><td><code id="get_matrix_bycluster_+3A_dt">DT</code></td>
<td>
<p>A data table with at least a column 'node' and a factor column identifying the node's cluster</p>
</td></tr>
<tr><td><code id="get_matrix_bycluster_+3A_clusters">clusters</code></td>
<td>
<p>A unique character vector of the name of the column identifying the nodes' clusters</p>
</td></tr>
</table>

<hr>
<h2 id='get_metrics'>Compute network metrics</h2><span id='topic+get_metrics'></span>

<h3>Description</h3>

<p>Function computing different network analysis metrics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_metrics(
  network,
  mode = "directed",
  weighted = TRUE,
  transfers = TRUE,
  metrics = c("degree", "closeness", "clusters", "betweenness"),
  clusters = c("cluster_fast_greedy", "cluster_infomap"),
  hubs = "all_clusters",
  options = list(degree = list(modes = c("in", "out", "total")), closeness = list(modes =
    "total"), betweenness = list(), cluster_fast_greedy = list(undirected = "collapse"),
    cluster_infomap = list(undirected = "collapse"), clusters = list(algos =
    c("cluster_fast_greedy", "cluster_infomap"), undirected = "collapse"))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_metrics_+3A_network">network</code></td>
<td>
<p>the network to analyze. Must be an igraph, HospiNet or a square adjacency matrix (n*n).</p>
</td></tr>
<tr><td><code id="get_metrics_+3A_mode">mode</code></td>
<td>
<p>either &quot;directed&quot; or &quot;undirected&quot; network measures</p>
</td></tr>
<tr><td><code id="get_metrics_+3A_weighted">weighted</code></td>
<td>
<p>TRUE if the network is weighted</p>
</td></tr>
<tr><td><code id="get_metrics_+3A_transfers">transfers</code></td>
<td>
<p>TRUE if metrics specific to subject transfers must be computed</p>
</td></tr>
<tr><td><code id="get_metrics_+3A_metrics">metrics</code></td>
<td>
<p>list of the metrics to compute</p>
</td></tr>
<tr><td><code id="get_metrics_+3A_clusters">clusters</code></td>
<td>
<p>choose between cluster algorithm: cluster_fast_greedy or cluster_infomap</p>
</td></tr>
<tr><td><code id="get_metrics_+3A_hubs">hubs</code></td>
<td>
<p>choose between getting hubs from &quot;all_clusters&quot; or &quot;global&quot;</p>
</td></tr>
<tr><td><code id="get_metrics_+3A_options">options</code></td>
<td>
<p>named list of options to be passed to the igraph functions</p>
</td></tr>
</table>

<hr>
<h2 id='HospiNet'>Class providing the HospiNet object with its methods</h2><span id='topic+HospiNet'></span>

<h3>Description</h3>

<p>Class providing the HospiNet object with its methods
</p>
<p>Class providing the HospiNet object with its methods
</p>


<h3>Format</h3>

<p><code><a href="R6.html#topic+R6Class">R6Class</a></code> object.
</p>


<h3>Value</h3>

<p>Object of <code><a href="R6.html#topic+R6Class">R6Class</a></code> with methods for accessing facility networks.
</p>


<h3>Methods</h3>


<dl>
<dt><code>new(edgelist,
window_threshold,
nmoves_threshold,
noloops)</code></dt><dd><p>This method is used to create an object of this class with <code>edgelist</code> as the necessary information to create the network.
The other arguments <code>window_threshold</code>, <code>nmoves_threshold</code>, and <code>noloops</code> are specific to the <code>edgelist</code> and need to be provided.
For ease of use, it is preferable to use the function <code><a href="#topic+hospinet_from_subject_database">hospinet_from_subject_database</a></code></p>
</dd>
<dt><code>print()</code></dt><dd><p>This method prints basic information about the object.</p>
</dd>
<dt><code>plot(type = "matrix")</code></dt><dd><p>This method plots the network matrix by default.
The argument <code>type</code> can take the following values:
</p>

<dl>
<dt>matrix</dt><dd><p>plot the network matrix,</p>
</dd>
<dt>clustered_matrix</dt><dd><p>identify and plot cluster(s) in the matrix using the infomap algorithm (from igraph),</p>
</dd>
<dt>degree</dt><dd><p>plot the histogram of the number of neighbors by facility,</p>
</dd>
<dt>circular_network</dt><dd><p>plot the network by clusters using a &quot;spaghetti-like&quot; layout. Only works when there are at least 2 clusters.</p>
</dd>
</dl>

</dd>
</dl>



<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>edgelist</code></dt><dd><p>(data.table) the list of edges (origin, target) and their associated number of movements (N) (read-only)</p>
</dd>
<dt><code>edgelist_long</code></dt><dd><p>(data.table) edgelist with additional information (read-only)</p>
</dd>
<dt><code>matrix</code></dt><dd><p>(matrix) the transfer matrix (active binding, read-only)</p>
</dd>
<dt><code>igraph</code></dt><dd><p>(igraph) the igraph object corresponding to the network (active binding, read-only)</p>
</dd>
<dt><code>n_facilities</code></dt><dd><p>the number of facilities in the network (read-only)</p>
</dd>
<dt><code>n_movements</code></dt><dd><p>the total number of subject movements in the network (read-only)</p>
</dd>
<dt><code>window_threshold</code></dt><dd><p>the window threshold used to compute the network (read-only)</p>
</dd>
<dt><code>nmoves_threshold</code></dt><dd><p>the nmoves threshold used to compute the network (read-only)</p>
</dd>
<dt><code>noloops</code></dt><dd><p>TRUE if loops have been removed (read-only)</p>
</dd>
<dt><code>hist_degrees</code></dt><dd><p>histogram data of the number of connections per facility</p>
</dd>
<dt><code>LOSPerHosp</code></dt><dd><p>the mean length of stay for each facility (read-only)</p>
</dd>
<dt><code>admissionsPerHosp</code></dt><dd><p>the number of admissions to each facility (read-only)</p>
</dd>
<dt><code>subjectsPerHosp</code></dt><dd><p>the number of unique subjects admitted to each facility (read-only)</p>
</dd>
<dt><code>degrees</code></dt><dd><p>number of connections for each facilities (total, in, and out)(read-only)</p>
</dd>
<dt><code>closenesss</code></dt><dd><p>the closeness centrality of each facility (read-only)</p>
</dd>
<dt><code>betweennesss</code></dt><dd><p>the betweenness centrality of each facility (read-only)</p>
</dd>
<dt><code>cluster_infomap</code></dt><dd><p>the assigned community for each facility, based on the infomap algorithm (read-only)</p>
</dd>
<dt><code>cluster_fast_greedy</code></dt><dd><p>the assigned community for each facility, based on the greedy modularity optimization algorithm (read-only)</p>
</dd>
<dt><code>hubs_global</code></dt><dd><p>Kleinberg's hub centrality scores, based on the entire network (read-only)</p>
</dd>
<dt><code>hubs_infomap</code></dt><dd><p>same as hubs_global, but computed per community based on the infomap algorithm (read-only)</p>
</dd>
<dt><code>hubs_fast_greedy</code></dt><dd><p>same as hubs_global, but computed per community based on the infomap algorithm (read-only)</p>
</dd>
<dt><code>metricsTable</code></dt><dd><p>(data.table) all of the above metrics for each facility (read-only)</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-HospiNet-new"><code>HospiNet$new()</code></a>
</p>
</li>
<li> <p><a href="#method-HospiNet-print"><code>HospiNet$print()</code></a>
</p>
</li>
<li> <p><a href="#method-HospiNet-plot"><code>HospiNet$plot()</code></a>
</p>
</li>
<li> <p><a href="#method-HospiNet-clone"><code>HospiNet$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-HospiNet-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new HospiNet object.
</p>


<h5>Usage</h5>

<div class="r"><pre>HospiNet$new(
  edgelist,
  edgelist_long,
  window_threshold,
  nmoves_threshold,
  noloops,
  prob_params,
  fsummary = NULL,
  create_MetricsTable = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>edgelist</code></dt><dd><p>Short format edgelist</p>
</dd>
<dt><code>edgelist_long</code></dt><dd><p>Long format edgelist</p>
</dd>
<dt><code>window_threshold</code></dt><dd><p>The window threshold used to compute the network</p>
</dd>
<dt><code>nmoves_threshold</code></dt><dd><p>The nmoves threshold used to compute the network</p>
</dd>
<dt><code>noloops</code></dt><dd><p>TRUE if loops have been removed</p>
</dd>
<dt><code>prob_params</code></dt><dd><p>Currently unused</p>
</dd>
<dt><code>fsummary</code></dt><dd><p>A pre-built data.table with the LOSPerHosp, subjectsPerHosp
and admissionsPerHosp that don't need to be recomputed.</p>
</dd>
<dt><code>create_MetricsTable</code></dt><dd><p>all of the metrics for each facility</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new 'HospiNet' object
</p>


<hr>
<a id="method-HospiNet-print"></a>



<h4>Method <code>print()</code></h4>

<p>Prints a basic description of the number of facilities and movements of
a HospiNet object.
</p>


<h5>Usage</h5>

<div class="r"><pre>HospiNet$print()</pre></div>



<h5>Returns</h5>

<p>NULL
</p>


<hr>
<a id="method-HospiNet-plot"></a>



<h4>Method <code>plot()</code></h4>

<p>Plots various representations of the HospiNet network
</p>


<h5>Usage</h5>

<div class="r"><pre>HospiNet$plot(type = "matrix", ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>type</code></dt><dd><p>One of &quot;matrix&quot;, &quot;degree&quot;, &quot;clustered_matrix&quot;, &quot;circular network&quot;
Choose what you would like to plot - the connectivity matrix, degree
distribution, the clusters, or the network in a circle.</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional arguments to be provided. Only supported for &lsquo;type == &rsquo;circular_network''.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a 'ggplot2' object
</p>


<hr>
<a id="method-HospiNet-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>HospiNet$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>mydbsmall &lt;- create_fake_subjectDB(n_subjects = 100, n_facilities = 10)

hn &lt;- hospinet_from_subject_database(
  base = checkBase(mydbsmall),
  window_threshold = 10,
  count_option = "successive",
  condition = "dates"
)

hn

plot(hn)
plot(hn, type = "clustered_matrix")
</code></pre>

<hr>
<h2 id='hospinet_from_subject_database'>Create HospiNet object from subject database</h2><span id='topic+hospinet_from_subject_database'></span>

<h3>Description</h3>

<p>This function creates a HospiNet object from the database containing subjects stays.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hospinet_from_subject_database(
  base,
  window_threshold = 365,
  count_option = "successive",
  condition = "dates",
  prob_params = c(0.0036, 1/365, 0.128),
  noloops = TRUE,
  nmoves_threshold = NULL,
  flag_vars = NULL,
  flag_values = NULL,
  create_MetricsTable = TRUE,
  verbose = FALSE,
  shinySession = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hospinet_from_subject_database_+3A_base">base</code></td>
<td>
<p>(hospinet.base) A database of records of stays of subjects in
facilities. This can be obtained using the function <code><a href="#topic+checkBase">checkBase</a></code>.</p>
</td></tr>
<tr><td><code id="hospinet_from_subject_database_+3A_window_threshold">window_threshold</code></td>
<td>
<p>(numeric)
A threshold for the number of days between discharge and admission to be counted as a transfer. Set to 0 for same day transfer, default is 365 days.</p>
</td></tr>
<tr><td><code id="hospinet_from_subject_database_+3A_count_option">count_option</code></td>
<td>
<p>(character) TODO. Default is &quot;successive&quot;.</p>
</td></tr>
<tr><td><code id="hospinet_from_subject_database_+3A_condition">condition</code></td>
<td>
<p>(character) TODO. Default is &quot;dates&quot;.</p>
</td></tr>
<tr><td><code id="hospinet_from_subject_database_+3A_prob_params">prob_params</code></td>
<td>
<p>(vector of numeric) Three numerical values to calculate
the probability that a movement causes an introduction from hospital A
to hospital B. See Donker T, Wallinga J, Grundmann H. (2010) &lt;doi:10.1371/journal.pcbi.1000715&gt; for more details.
prob_params[1] is the rate of acquisition in hospital A (related to LOS
in hospital A). Default: 0.0036
prob_params[2] is the rate of loss of colonisation (related to time
between admissions). Default: 1/365
prob_params[4] is the rate of transmission to other patients in hospital
B (related to LOS in hospital B). Default: 0.128</p>
</td></tr>
<tr><td><code id="hospinet_from_subject_database_+3A_noloops">noloops</code></td>
<td>
<p>(boolean).
Should transfers within the same nodes (loops) be kept or set to 0. Defaults to TRUE, removing loops (setting matrix diagonal to 0).</p>
</td></tr>
<tr><td><code id="hospinet_from_subject_database_+3A_nmoves_threshold">nmoves_threshold</code></td>
<td>
<p>(numeric)
A threshold for the minimum number of subject transfer between two facilities. Set to NULL to deactivate, default to NULL.</p>
</td></tr>
<tr><td><code id="hospinet_from_subject_database_+3A_flag_vars">flag_vars</code></td>
<td>
<p>(list) Additional variables that can help flag a transfer,
besides the dates of admission and discharge. Must be a named list of two
character vectors which are the names of the columns that can flag a
transfer: the column that can flag a potential origin, and the column
that can flag a potential target. The list must be named with &quot;origin&quot;
and &quot;transfer&quot;. Eg: list(&quot;origin&quot; = &quot;var1&quot;, &quot;target&quot; = &quot;var2&quot;). See
details.</p>
</td></tr>
<tr><td><code id="hospinet_from_subject_database_+3A_flag_values">flag_values</code></td>
<td>
<p>(list) A named list of two character vectors which contain
the values of the variables in flag_var that are matched to flag a
potential transfer. The list must be named with &quot;origin&quot; and
&quot;transfer&quot;. The character vectors might be of length greater than
one. Eg: list(&quot;origin&quot; = c(&quot;value1&quot;, &quot;value2&quot;), &quot;target&quot; = c(&quot;value2&quot;,
&quot;value2&quot;)). The values in 'origin' and 'target' are the values that flag
a potential origin of a transfer, or a potential target,
respectively. See details.</p>
</td></tr>
<tr><td><code id="hospinet_from_subject_database_+3A_create_metricstable">create_MetricsTable</code></td>
<td>
<p>(boolean)
Should the metrics table be created along with the network. Setting to FALSE will speed up the results. Default is TRUE.</p>
</td></tr>
<tr><td><code id="hospinet_from_subject_database_+3A_verbose">verbose</code></td>
<td>
<p>TRUE to print computation steps</p>
</td></tr>
<tr><td><code id="hospinet_from_subject_database_+3A_shinysession">shinySession</code></td>
<td>
<p>(NULL) internal variable to deal with the progress bar</p>
</td></tr>
<tr><td><code id="hospinet_from_subject_database_+3A_...">...</code></td>
<td>
<p>Additional parameters to be sent to checkBase in case the database has not been checked yet.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will build a HospiNet object from a line-listed
subject database. The HospiNet object has all of the functions stored as
active bindings which can be accessed in the usual way. For more info, see
<code><a href="#topic+HospiNet">HospiNet</a></code>.
Note that the subject database will need to be run through <code><a href="#topic+checkBase">checkBase</a></code>
before going into this function.
</p>


<h3>Value</h3>

<p>The function returns a HospiNet object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+HospiNet">HospiNet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mydb &lt;- create_fake_subjectDB(n_subjects = 100, n_facilities = 10)
myBase &lt;- checkBase(mydb)
hospinet_from_subject_database(myBase)
</code></pre>

<hr>
<h2 id='matrix_from_base'>Compute the adjacency matrix of a network from a database of movements records.</h2><span id='topic+matrix_from_base'></span>

<h3>Description</h3>

<p>This function computes the adjacency matrix of a network of facilities across
which subjects can be transferred. The matrix is computed from a database that
contains the records of the subjects' stays in the facilities. This function
is a simple wrapper around the two functions
<code><a href="#topic+edgelist_from_base">edgelist_from_base</a></code>, which computes the edgelist of the network
from the database, and <code><a href="#topic+matrix_from_edgelist">matrix_from_edgelist</a></code>, which converts the
edgelist into the adjacency matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix_from_base(
  base,
  window_threshold = 365,
  count_option = "successive",
  prob_params = c(0.0036, 1/365, 0.128),
  condition = "dates",
  noloops = TRUE,
  nmoves_threshold = NULL,
  flag_vars = NULL,
  flag_values = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix_from_base_+3A_base">base</code></td>
<td>
<p>(data.table) A database of records of stays of subjects in
facilities. The table should have at least the following columns:
</p>
 <ul>
<li><p><b>subjectID</b> (character) unique subject identifier
</p>
</li>
<li><p><b>facilityID</b> (character) unique facility identifier
</p>
</li>
<li><p><b>admDate</b> (POSIXct) date of admission in the facility
</p>
</li>
<li><p><b>disDate</b> (POSIXct) date of discharge of the facility </p>
</li></ul>
</td></tr>
<tr><td><code id="matrix_from_base_+3A_window_threshold">window_threshold</code></td>
<td>
<p>(integer) A number of days. If two stays of a subject
at two facilities occurred within this window, this constitutes a
connection between the two facilities (given that potential other
conditions are met).</p>
</td></tr>
<tr><td><code id="matrix_from_base_+3A_count_option">count_option</code></td>
<td>
<p>(character) How to count connections. Options are
&quot;successive&quot;, &quot;probability&quot; or &quot;all&quot;. See details.</p>
</td></tr>
<tr><td><code id="matrix_from_base_+3A_prob_params">prob_params</code></td>
<td>
<p>(vector of numeric) Three numerical values to calculate
the probability that a movement causes an introduction from hospital A
to hospital B. See Donker T, Wallinga J, Grundmann H. (2010) &lt;doi:10.1371/journal.pcbi.1000715&gt; for more details.
For use with count_option=&quot;probability&quot;.
prob_params[1] is the rate of acquisition in hospital A (related to LOS
in hospital A). Default: 0.0036
prob_params[2] is the rate of loss of colonisation (related to time
between admissions). Default: 1/365
prob_params[4] is the rate of transmission to other patients in hospital
B (related to LOS in hospital B). Default: 0.128</p>
</td></tr>
<tr><td><code id="matrix_from_base_+3A_condition">condition</code></td>
<td>
<p>(character) Condition(s) used to decide what constitutes a
connection. Can be &quot;dates&quot;, &quot;flags&quot;, or &quot;both&quot;. See details.</p>
</td></tr>
<tr><td><code id="matrix_from_base_+3A_noloops">noloops</code></td>
<td>
<p>(boolean). Should transfers within the same nodes (loops) be
kept or set to 0. Defaults to TRUE, removing loops (setting matrix
diagonal to 0).</p>
</td></tr>
<tr><td><code id="matrix_from_base_+3A_nmoves_threshold">nmoves_threshold</code></td>
<td>
<p>(numeric) A threshold for the minimum number of
subject transfer between two facilities. Set to NULL to deactivate,
default to NULL.</p>
</td></tr>
<tr><td><code id="matrix_from_base_+3A_flag_vars">flag_vars</code></td>
<td>
<p>(list) Additional variables that can help flag a transfer,
besides the dates of admission and discharge. Must be a named list of two
character vectors which are the names of the columns that can flag a
transfer: the column that can flag a potential origin, and the column
that can flag a potential target. The list must be named with &quot;origin&quot;
and &quot;transfer&quot;. Eg: list(&quot;origin&quot; = &quot;var1&quot;, &quot;target&quot; = &quot;var2&quot;). See
details.</p>
</td></tr>
<tr><td><code id="matrix_from_base_+3A_flag_values">flag_values</code></td>
<td>
<p>(list) A named list of two character vectors which contain
the values of the variables in flag_var that are matched to flag a
potential transfer. The list must be named with &quot;origin&quot; and
&quot;transfer&quot;. The character vectors might be of length greater than
one. Eg: list(&quot;origin&quot; = c(&quot;value1&quot;, &quot;value2&quot;), &quot;target&quot; = c(&quot;value2&quot;,
&quot;value2&quot;)). The values in 'origin' and 'target' are the values that flag
a potential origin of a transfer, or a potential target,
respectively. See details.</p>
</td></tr>
<tr><td><code id="matrix_from_base_+3A_verbose">verbose</code></td>
<td>
<p>TRUE to print computation steps</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The edgelist contains the information on the connections between
nodes of the network, that is the movements of subjects between
facilities. The edgelist can be in two different formats: long or
aggregated. In long format, each row corresponds to a single movement
between two facilities, therefore only two columns are needed, one
containing the origin facilities of a movement, the other containing the
target facilities. In aggregated format, the edgelist is aggregated by
unique pairs of origin-target facilities. Thus, each row corresponds to a
unique connection between two facilities, and the table contains an
additional variable which is the count of the number of movements
recorded for the pair. If the edgelist is provided in long format, it
will be aggregated to compute the matrix.
</p>


<h3>Value</h3>

<p>A square matrix, the adjacency matrix of the network.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+edgelist_from_base">edgelist_from_base</a></code>, <code><a href="#topic+matrix_from_edgelist">matrix_from_edgelist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mydb &lt;- create_fake_subjectDB(n_subjects = 100, n_facilities = 10)
myBase &lt;- checkBase(mydb)
matrix_from_base(myBase)
</code></pre>

<hr>
<h2 id='matrix_from_edgelist'>Compute the adjacency matrix of a network from its edgelist</h2><span id='topic+matrix_from_edgelist'></span>

<h3>Description</h3>

<p>Compute the adjacency matrix of a network from its edgelist
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix_from_edgelist(
  edgelist,
  origin_name = "origin",
  target_name = "target",
  count,
  format_long = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix_from_edgelist_+3A_edgelist">edgelist</code></td>
<td>
<p>(data.table) A table containing the edges (or links) of the
network, i.e. representing the movements of subjects between
facilities. Either in long format with at least two columns (origin and
target facilities of a link), each row corresponding to a single
movement, or aggregated by unique pairs of origin/target, therefore with
an additional variable for movements count (default). See details.</p>
</td></tr>
<tr><td><code id="matrix_from_edgelist_+3A_origin_name">origin_name</code></td>
<td>
<p>(character) Column of the origin facilities of the links.</p>
</td></tr>
<tr><td><code id="matrix_from_edgelist_+3A_target_name">target_name</code></td>
<td>
<p>(character) Column of the target facilities of the links.</p>
</td></tr>
<tr><td><code id="matrix_from_edgelist_+3A_count">count</code></td>
<td>
<p>(character) Column of the counts of movements by unique pair of
facilities.</p>
</td></tr>
<tr><td><code id="matrix_from_edgelist_+3A_format_long">format_long</code></td>
<td>
<p>(logical) Whether the edgelist is in long format, with
each row corresponding to a single movement. If TRUE, the edgelist will
be aggregated by unique pairs of facilities to compute the matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The edgelist contains the information on the connections between
nodes of the network, that is the movements of subjects between
facilities. The edgelist can be in two different formats: long or
aggregated. In long format, each row corresponds to a single movement
between two facilities, therefore only two columns are needed, one
containing the origin facilities of a movement, the other containing the
target facilities. In aggregated format, the edgelist is aggregated by
unique pairs of origin-target facilities. Thus, each row corresponds to a
unique connection between two facilities, and the table contains an
additional variable which is the count of the number of movements
recorded for the pair. If the edgelist is provided in long format, it
will be aggregated to compute the matrix.
</p>


<h3>Value</h3>

<p>A square numeric matrix, the adjacency matrix of the network.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+edgelist_from_base">edgelist_from_base</a></code>, <code><a href="#topic+matrix_from_base">matrix_from_base</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mydb &lt;- create_fake_subjectDB(n_subjects = 100, n_facilities = 10)
myBase &lt;- checkBase(mydb)
hospinet &lt;- hospinet_from_subject_database(myBase)
matrix_from_edgelist(hospinet$edgelist, count = "N")
</code></pre>

<hr>
<h2 id='per_facility_summary'>Function that extracts summary statistics from entire database</h2><span id='topic+per_facility_summary'></span>

<h3>Description</h3>

<p>Function that extracts summary statistics from entire database
</p>


<h3>Usage</h3>

<pre><code class='language-R'>per_facility_summary(base, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="per_facility_summary_+3A_base">base</code></td>
<td>
<p>(data.table).
A subject discharge database, in the form of a data.table. The data.table should have at least the following columns:
sID: subjectID (character)
fID: facilityID (character)
Adate: admission date (date)
Ddate: discharge date (date)</p>
</td></tr>
<tr><td><code id="per_facility_summary_+3A_verbose">verbose</code></td>
<td>
<p>(boolean) print diagnostic messages. Default is TRUE.</p>
</td></tr>
<tr><td><code id="per_facility_summary_+3A_...">...</code></td>
<td>
<p>other parameters passed on to internal functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data table with one row per facility, showing mean LOS, number of subjects, and number of admissions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mydb &lt;- create_fake_subjectDB(n_subjects = 100, n_facilities = 10)
myBase &lt;- checkBase(mydb)
per_facility_summary(myBase)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
