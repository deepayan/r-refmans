<!DOCTYPE html><html lang="en"><head><title>Help for package nimbleSMC</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {nimbleSMC}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#buildAuxiliaryFilter'><p>Create an auxiliary particle filter algorithm to estimate log-likelihood.</p></a></li>
<li><a href='#buildBootstrapFilter'><p>Create a bootstrap particle filter algorithm to estimate log-likelihood.</p></a></li>
<li><a href='#buildEnsembleKF'><p>Create an Ensemble Kalman filter algorithm to sample from latent states.</p></a></li>
<li><a href='#buildIteratedFilter2'><p>Create an IF2 algorithm.</p></a></li>
<li><a href='#buildLiuWestFilter'><p>Create a Liu and West particle filter algorithm.</p></a></li>
<li><a href='#SMCsamplers'><p>Particle Filtering MCMC Sampling Algorithms</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Sequential Monte Carlo Methods for 'nimble'</td>
</tr>
<tr>
<td>Description:</td>
<td>Includes five particle filtering algorithms for use with state space
    models in the 'nimble' system: 'Auxiliary', 'Bootstrap', 'Ensemble Kalman filter',
    'Iterated Filtering 2', and 'Liu-West', as described in Michaud et al. (2021),
    &lt;<a href="https://doi.org/10.18637%2Fjss.v100.i03">doi:10.18637/jss.v100.i03</a>&gt;. A full User Manual is available at
    <a href="https://r-nimble.org">https://r-nimble.org</a>.     </td>
</tr>
<tr>
<td>Version:</td>
<td>0.11.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-06-14</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christopher Paciorek &lt;paciorek@stat.berkeley.edu&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-3-Clause">BSD_3_clause</a> + file LICENSE | <a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: BSD_3_clause + file LICENSE | GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Copyright:</td>
<td>See COPYRIGHTS file.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.2), nimble (&ge; 1.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://r-nimble.org">https://r-nimble.org</a>, <a href="https://github.com/nimble-dev/nimbleSMC">https://github.com/nimble-dev/nimbleSMC</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Collate:</td>
<td>AuxiliaryFilter.R BootstrapFilter.R EnKFilter.R IF2Filter.R
LiuWestFilter.R MCMCSamplers.R resamplers.R utils.R zzz.R</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-14 15:24:28 UTC; paciorek</td>
</tr>
<tr>
<td>Author:</td>
<td>Nick Michaud [aut],
  Perry de Valpine [aut],
  Christopher Paciorek [aut, cre],
  Daniel Turek [aut],
  Benjamin R. Goldstein [ctb] (packaging contributions),
  Dao Nguyen [ctb] (contributions to the IF2 code),
  The Regents of the University of California [cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-14 15:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='buildAuxiliaryFilter'>Create an auxiliary particle filter algorithm to estimate log-likelihood.</h2><span id='topic+buildAuxiliaryFilter'></span>

<h3>Description</h3>

<p>Create an auxiliary particle filter algorithm for a given NIMBLE state space model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildAuxiliaryFilter(model, nodes, control = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="buildAuxiliaryFilter_+3A_model">model</code></td>
<td>
<p>A NIMBLE model object, typically representing a state space model or a hidden Markov model.</p>
</td></tr>
<tr><td><code id="buildAuxiliaryFilter_+3A_nodes">nodes</code></td>
<td>
<p>A character vector specifying the stochastic latent model nodes 
over which the particle filter will stochastically integrate to
estimate the log-likelihood function.  All provided nodes must be stochastic.
Can be one of three forms: a variable name, in which case all elements in the variable
are taken to be latent (e.g., 'x'); an indexed variable, in which case all indexed elements are taken
to be latent (e.g., 'x[1:100]' or 'x[1:100, 1:2]'); or a vector of multiple nodes, one per time point,
in increasing time order (e.g., c(&quot;x[1:2, 1]&quot;, &quot;x[1:2, 2]&quot;, &quot;x[1:2, 3]&quot;, &quot;x[1:2, 4]&quot;)).</p>
</td></tr>
<tr><td><code id="buildAuxiliaryFilter_+3A_control">control</code></td>
<td>
<p>A list specifying different control options for the particle filter.  Options are described in the details section below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each of the <code>control()</code> list options are described in detail here:
</p>

<dl>
<dt>lookahead</dt><dd><p>The lookahead function used to calculate auxiliary weights.  Can choose between <code>'mean'</code> and <code>'simulate'</code>.
Defaults to <code>'simulate'</code>.</p>
</dd>
<dt>resamplingMethod</dt><dd><p>The type of resampling algorithm to be used within the particle filter.  Can choose between <code>'default'</code> (which uses NIMBLE's <code>rankSample()</code> function), <code>'systematic'</code>, <code>'stratified'</code>, <code>'residual'</code>, and <code>'multinomial'</code>.  Defaults to <code>'default'</code>. Resampling methods other than <code>'default'</code> are currently experimental.</p>
</dd>
<dt>saveAll</dt><dd><p>Indicates whether to save state samples for all time points (<code>TRUE</code>), or only for the most recent time point (<code>FALSE</code>)</p>
</dd>
<dt>smoothing</dt><dd><p>Decides whether to save smoothed estimates of latent states, i.e., samples from f(x[1:t]|y[1:t]) if <code>smoothing = TRUE</code>, or instead to save filtered samples from f(x[t]|y[1:t]) if <code>smoothing = FALSE</code>. <code>smoothing = TRUE</code> only works if <code>saveAll = TRUE</code>.</p>
</dd>
<dt>timeIndex</dt><dd><p>An integer used to manually specify which dimension of the latent state variable indexes time. This need only be set if the number of time points is less than or equal to the size of the latent state at each time point.</p>
</dd>
<dt>initModel</dt><dd><p>A logical value indicating whether to initialize the model before running the filtering algorithm.  Defaults to TRUE.</p>
</dd>
</dl>

<p>The auxiliary particle filter modifies the bootstrap filter (<code><a href="#topic+buildBootstrapFilter">buildBootstrapFilter</a></code>)
by adding a lookahead step to the algorithm: before propagating particles from one time
point to the next via the transition equation, the auxiliary filter calculates a weight
for each pre-propogated particle by predicting how well the particle will agree with the
next data point.  These pre-weights are used to conduct an initial resampling step before
propagation. 
</p>
<p>The resulting specialized particle filter algorthm will accept a
single integer argument (<code>m</code>, default 10,000), which specifies the number
of random \'particles\' to use for estimating the log-likelihood.  The algorithm 
returns the estimated log-likelihood value, and saves
unequally weighted samples from the posterior distribution of the latent
states in the <code>mvWSamples</code> modelValues object, with corresponding logged weights in <code>mvWSamples['wts',]</code>.
An equally weighted sample from the posterior can be found in the <code>mvEWsamp</code> modelValues object.  
</p>
<p>The auxiliary particle filter uses a lookahead function to select promising particles before propagation.  This function can eithre be the expected
value of the latent state at the next time point (<code>lookahead = 'mean'</code>) or a simulation from the distribution of the latent state at the next time point (<code>lookahead = 'simulate'</code>), conditioned on the current particle.
</p>
<p>@section <code>returnESS()</code> Method:
Calling the <code>returnESS()</code> method of an auxiliary particle filter after that filter has been <code>run()</code> for a given model will return a vector of ESS (effective
sample size) values, one value for each time point.
</p>


<h3>Author(s)</h3>

<p>Nicholas Michaud
</p>


<h3>References</h3>

<p>Pitt, M.K., and Shephard, N. (1999). Filtering via simulation: Auxiliary particle filters. <em>Journal of the American Statistical Association</em> 94(446): 590-599.
</p>


<h3>See Also</h3>

<p>Other particle filtering methods: 
<code><a href="#topic+buildBootstrapFilter">buildBootstrapFilter</a></code>,
<code><a href="#topic+buildEnsembleKF">buildEnsembleKF</a></code>,
<code><a href="#topic+buildIteratedFilter2">buildIteratedFilter2</a>()</code>,
<code><a href="#topic+buildLiuWestFilter">buildLiuWestFilter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## For illustration only.
exampleCode &lt;- nimbleCode({
  x0 ~ dnorm(0, var = 1)
  x[1] ~ dnorm(.8 * x0, var = 1)
  y[1] ~ dnorm(x[1], var = .5)
  for(t in 2:10){
    x[t] ~ dnorm(.8 * x[t-1], var = 1)
    y[t] ~ dnorm(x[t], var = .5)
  }
})

model &lt;- nimbleModel(code = exampleCode, data = list(y = rnorm(10)),
                     inits = list(x0 = 0, x = rnorm(10)))
my_AuxF &lt;- buildAuxiliaryFilter(model, 'x',
                control = list(saveAll = TRUE, lookahead = 'mean'))
## Now compile and run, e.g.,
## Cmodel &lt;- compileNimble(model)
## Cmy_AuxF &lt;- compileNimble(my_AuxF, project = model)
## logLik &lt;- Cmy_AuxF$run(m = 1000)
## ESS &lt;- Cmy_AuxF$returnESS()
## aux_X &lt;- as.matrix(Cmy_AuxF$mvEWSamples, 'x')
</code></pre>

<hr>
<h2 id='buildBootstrapFilter'>Create a bootstrap particle filter algorithm to estimate log-likelihood.</h2><span id='topic+buildBootstrapFilter'></span>

<h3>Description</h3>

<p>Create a bootstrap particle filter algorithm for a given NIMBLE state space model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildBootstrapFilter(model, nodes, control = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="buildBootstrapFilter_+3A_model">model</code></td>
<td>
<p>A nimble model object, typically representing a state 
space model or a hidden Markov model.</p>
</td></tr>
<tr><td><code id="buildBootstrapFilter_+3A_nodes">nodes</code></td>
<td>
<p>A character vector specifying the stochastic latent model nodes 
over which the particle filter will stochastically integrate to
estimate the log-likelihood function.  All provided nodes must be stochastic.
Can be one of three forms: a variable name, in which case all elements in the variable
are taken to be latent (e.g., 'x'); an indexed variable, in which case all indexed elements are taken
to be latent (e.g., 'x[1:100]' or 'x[1:100, 1:2]'); or a vector of multiple nodes, one per time point,
in increasing time order (e.g., c(&quot;x[1:2, 1]&quot;, &quot;x[1:2, 2]&quot;, &quot;x[1:2, 3]&quot;, &quot;x[1:2, 4]&quot;)).</p>
</td></tr>
<tr><td><code id="buildBootstrapFilter_+3A_control">control</code></td>
<td>
<p>A list specifying different control options for the particle filter.  Options are described in the details section below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each of the <code>control()</code> list options are described in detail here:
</p>

<dl>
<dt>thresh</dt><dd><p> A number between 0 and 1 specifying when to resample: the resampling step will occur when the
effective sample size is less than <code>thresh</code> times the number of particles. Defaults to 0.8. Note that at the last time step, resampling will always occur so that the <code>mvEWsamples</code> <code>modelValues</code> contains equally-weighted samples.</p>
</dd>
<dt>resamplingMethod</dt><dd><p>The type of resampling algorithm to be used within the particle filter. Can choose between <code>'default'</code> (which uses NIMBLE's <code>rankSample()</code> function),  <code>'systematic'</code>, <code>'stratified'</code>, <code>'residual'</code>, and <code>'multinomial'</code>.  Defaults to <code>'default'</code>.  Resampling methods other than <code>'default'</code> are currently experimental.</p>
</dd>
<dt>saveAll</dt><dd><p>Indicates whether to save state samples for all time points (TRUE), or only for the most recent time point (FALSE)</p>
</dd>
<dt>smoothing</dt><dd><p>Decides whether to save smoothed estimates of latent states, i.e., samples from f(x[1:t]|y[1:t]) if <code>smoothing = TRUE</code>, or instead to save filtered samples from f(x[t]|y[1:t]) if <code>smoothing = FALSE</code>.  <code>smoothing = TRUE</code> only works if <code>saveAll = TRUE</code>.</p>
</dd>
<dt>timeIndex</dt><dd><p>An integer used to manually specify which dimension of the latent state variable indexes time.  
Only needs to be set if the number of time points is less than or equal to the size of the latent state at each time point.</p>
</dd>
<dt>initModel</dt><dd><p>A logical value indicating whether to initialize the model before running the filtering algorithm.  Defaults to TRUE.</p>
</dd>
</dl>

<p>The bootstrap filter starts by generating a sample of estimates from the 
prior distribution of the latent states of a state space model.  At each time point, these particles are propagated forward 
by the model's transition equation.  Each particle is then given a weight 
proportional to the value of the observation equation given that particle. 
The weights are used to draw an equally-weighted sample of the particles at this time point.
The algorithm then proceeds
to the next time point.  Neither the transition nor the observation equations are required to 
be normal for the bootstrap filter to work.   
</p>
<p>The resulting specialized particle filter algorthm will accept a
single integer argument (<code>m</code>, default 10,000), which specifies the number
of random \'particles\' to use for estimating the log-likelihood.  The algorithm 
returns the estimated log-likelihood value, and saves
unequally weighted samples from the posterior distribution of the latent
states in the <code>mvWSamples</code> modelValues object, with corresponding logged weights in <code>mvWSamples['wts',]</code>.
An equally weighted sample from the posterior can be found in the <code>mvEWSamples</code> <code>modelValues</code> object.
</p>
<p>Note that if the <code>thresh</code> argument is set to a value less than 1, resampling may not take place at every time point.  
At time points for which resampling did not take place, <code>mvEWSamples</code> will not contain equally weighted samples.
To ensure equally weighted samples in the case that <code>thresh &lt; 1</code>, we recommend resampling from <code>mvWSamples</code> at each time point 
after the filter has been run, rather than using <code>mvEWSamples</code>.
</p>


<h3><code>returnESS()</code> Method</h3>

<p>Calling the <code>returnESS()</code> method of a bootstrap filter after that filter has been <code>run()</code> for a given model will return a vector of ESS (effective
sample size) values, one value for each time point.
</p>


<h3>Author(s)</h3>

<p>Daniel Turek and Nicholas Michaud
</p>


<h3>References</h3>

<p>Gordon, N.J., D.J. Salmond, and A.F.M. Smith. (1993). Novel approach to nonlinear/non-Gaussian Bayesian state estimation. <em>IEEE Proceedings F (Radar and Signal Processing)</em>. Vol. 140. No. 2. IET Digital Library, 1993.
</p>


<h3>See Also</h3>

<p>Other particle filtering methods: 
<code><a href="#topic+buildAuxiliaryFilter">buildAuxiliaryFilter</a></code>,
<code><a href="#topic+buildEnsembleKF">buildEnsembleKF</a></code>,
<code><a href="#topic+buildIteratedFilter2">buildIteratedFilter2</a>()</code>,
<code><a href="#topic+buildLiuWestFilter">buildLiuWestFilter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## For illustration only.
exampleCode &lt;- nimbleCode({
  x0 ~ dnorm(0, var = 1)
  x[1] ~ dnorm(.8 * x0, var = 1)
  y[1] ~ dnorm(x[1], var = .5)
  for(t in 2:10){
    x[t] ~ dnorm(.8 * x[t-1], var = 1)
    y[t] ~ dnorm(x[t], var = .5)
  }
})

model &lt;- nimbleModel(code = exampleCode, data = list(y = rnorm(10)),
                     inits = list(x0 = 0, x = rnorm(10)))
my_BootF &lt;- buildBootstrapFilter(model, 'x',
                control = list(saveAll = TRUE, thresh = 1))
## Now compile and run, e.g.,
## Cmodel &lt;- compileNimble(model)
## Cmy_BootF &lt;- compileNimble(my_BootF, project = model)
## logLik &lt;- Cmy_BootF$run(m = 1000)
## ESS &lt;- Cmy_BootF$returnESS()
## boot_X &lt;- as.matrix(Cmy_BootF$mvEWSamples, 'x')
</code></pre>

<hr>
<h2 id='buildEnsembleKF'>Create an Ensemble Kalman filter algorithm to sample from latent states.</h2><span id='topic+buildEnsembleKF'></span>

<h3>Description</h3>

<p>Create an Ensemble Kalman filter algorithm for a given NIMBLE state space model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildEnsembleKF(model, nodes, control = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="buildEnsembleKF_+3A_model">model</code></td>
<td>
<p>A NIMBLE model object, typically representing a state space model or a hidden Markov model</p>
</td></tr>
<tr><td><code id="buildEnsembleKF_+3A_nodes">nodes</code></td>
<td>
<p>A character vector specifying the stochastic latent model nodes 
the Ensemble Kalman Filter will estimate. All provided nodes must be stochastic.
Can be one of three forms: a variable name, in which case all elements in the variable
are taken to be latent (e.g., 'x'); an indexed variable, in which case all indexed elements are taken
to be latent (e.g., 'x[1:100]' or 'x[1:100, 1:2]'); or a vector of multiple nodes, one per time point,
in increasing time order (e.g., c(&quot;x[1:2, 1]&quot;, &quot;x[1:2, 2]&quot;, &quot;x[1:2, 3]&quot;, &quot;x[1:2, 4]&quot;)).</p>
</td></tr>
<tr><td><code id="buildEnsembleKF_+3A_control">control</code></td>
<td>
<p>A list specifying different control options for the particle filter.  Options are described in the details section below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>control()</code> list option is described in detail below:
</p>

<dl>
<dt>saveAll</dt><dd><p>Indicates whether to save state samples for all time points (TRUE), or only for the most recent time point (FALSE)</p>
</dd>
<dt>timeIndex</dt><dd><p>An integer used to manually specify which dimension of the latent state variable indexes time.  
Only needs to be set if the number of time points is less than or equal to the size of the latent state at each time point.</p>
</dd>
<dt>initModel</dt><dd><p>A logical value indicating whether to initialize the model before running the filtering algorithm.  Defaults to TRUE.</p>
</dd>
</dl>

<p>Runs an Ensemble Kalman filter to estimate a latent state given observations at each time point.  The ensemble Kalman filter
is a Monte Carlo approximation to a Kalman filter that can be used when the model's transition euqations do not follow a normal distribution.  
Latent states (x[t]) and observations (y[t]) can be scalars or vectors at each time point, 
and sizes of observations can vary from time point to time point.
In the BUGS model, the observations (y[t]) must be equal to some (possibly nonlinear) deterministic function
of the latent state (x[t]) plus an additive error term.  Currently only normal and multivariate normal
error terms are supported.
The transition from x[t] to x[t+1] does not have to be normal or linear.  Output from the posterior distribution of the latent
states is stored in <code>mvSamples</code>.
</p>


<h3>Author(s)</h3>

<p>Nicholas Michaud
</p>


<h3>References</h3>

<p>Houtekamer, P.L., and H.L. Mitchell. (1998). Data assimilation using an ensemble Kalman filter technique. <em>Monthly Weather Review</em>, 126(3), 796-811.
</p>


<h3>See Also</h3>

<p>Other particle filtering methods: 
<code><a href="#topic+buildAuxiliaryFilter">buildAuxiliaryFilter</a></code>,
<code><a href="#topic+buildBootstrapFilter">buildBootstrapFilter</a></code>,
<code><a href="#topic+buildIteratedFilter2">buildIteratedFilter2</a>()</code>,
<code><a href="#topic+buildLiuWestFilter">buildLiuWestFilter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## For illustration only.
exampleCode &lt;- nimbleCode({
  x0 ~ dnorm(0, var = 1)
  x[1] ~ dnorm(.8 * x0, var = 1)
  y[1] ~ dnorm(x[1], var = .5)
  for(t in 2:10){
    x[t] ~ dnorm(.8 * x[t-1], var = 1)
    y[t] ~ dnorm(x[t], var = .5)
  }
})

model &lt;- nimbleModel(code = exampleCode, data = list(y = rnorm(10)),
                     inits = list(x0 = 0, x = rnorm(10)))
my_enKF &lt;- buildEnsembleKF(model, 'x',
                control = list(saveAll = TRUE, thresh = 1))
## Now compile and run, e.g.,
## Cmodel &lt;- compileNimble(model)
## Cmy_enKF &lt;- compileNimble(my_enKF, project = model)
## Cmy_enKF$run(m = 1000)
## enKF_X &lt;- as.matrix(Cmy_enKF$mvSamples, 'x')
</code></pre>

<hr>
<h2 id='buildIteratedFilter2'>Create an IF2 algorithm.</h2><span id='topic+buildIteratedFilter2'></span>

<h3>Description</h3>

<p>Create an IF2 algorithm for a given NIMBLE state space model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildIteratedFilter2(
  model,
  nodes,
  params = NULL,
  baselineNode = NULL,
  control = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="buildIteratedFilter2_+3A_model">model</code></td>
<td>
<p>A NIMBLE model object, typically representing a state 
space model or a hidden Markov model.</p>
</td></tr>
<tr><td><code id="buildIteratedFilter2_+3A_nodes">nodes</code></td>
<td>
<p>A character vector specifying the stochastic latent model nodes 
over which the particle filter will stochastically integrate to
estimate the log-likelihood function.  All provided nodes must be stochastic.
Can be one of three forms: a variable name, in which case all elements in the variable
are taken to be latent (e.g., 'x'); an indexed variable, in which case all indexed elements are taken
to be latent (e.g., 'x[1:100]' or 'x[1:100, 1:2]'); or a vector of multiple nodes, one per time point,
in increasing time order (e.g., c(&quot;x[1:2, 1]&quot;, &quot;x[1:2, 2]&quot;, &quot;x[1:2, 3]&quot;, &quot;x[1:2, 4]&quot;)).</p>
</td></tr>
<tr><td><code id="buildIteratedFilter2_+3A_params">params</code></td>
<td>
<p>A character vector specifying the top-level parameters to obtain maximum likelihood estimates of. 
If unspecified, parameter nodes are specified as all stochastic top level nodes which
are not in the set of latent nodes specified in <code>nodes</code>.</p>
</td></tr>
<tr><td><code id="buildIteratedFilter2_+3A_baselinenode">baselineNode</code></td>
<td>
<p>A character vector specifying the node that is the latent node at the &quot;0th&quot; time step. The first node in <code>nodes</code> should depend on this baseline, but <code>baselineNode</code> should have no data depending on it. If <code>NULL</code> (the default), any initial state is taken to be fixed at the values present in the model at the time the algorithm is run.</p>
</td></tr>
<tr><td><code id="buildIteratedFilter2_+3A_control">control</code></td>
<td>
<p>A list specifying different control options for the IF2 algorithm.  Options are described in the &lsquo;details&rsquo; section below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each of the <code>control()</code> list options are described in detail below:
</p>

<dl>
<dt>sigma</dt><dd><p>A vector specifying a non-negative perturbation magnitude for each element of the <code>params</code> argument.  Defaults to a vector of 1's.</p>
</dd>
<dt>initParamSigma</dt><dd><p>An optional vector specifying a vector of standard deviations to use when simulating an initial particle swarm centered on the initial value of the parameters. Defaults to <code>sigma</code>.</p>
</dd>
<dt>inits</dt><dd><p>A vector specifying an initial value for each element of the <code>params</code> argument.  Defaults to the parameter values in the model at the time the model is built.</p>
</dd>
<dt>timeIndex</dt><dd><p>An integer used to manually specify which dimension of the latent state variable indexes time.  
Only needs to be set if the number of time points is less than or equal to the size of the latent state at each time point.</p>
</dd>
<dt>initModel</dt><dd><p>A logical value indicating whether to initialize the model before running the filtering algorithm.  Defaults to <code>TRUE</code>.</p>
</dd>
</dl>

<p>The IF2 agorithm uses iterated filtering to estimate maximum likelihood values for top-level parameters for a state space model.  
</p>
<p>The resulting specialized IF2 algorithm will accept the following arguments:
</p>

<dl>
<dt>m</dt><dd><p>A single integer specifying the number of particles to use for each run of the filter. </p>
</dd>
<dt>n</dt><dd><p>A single integer specifying the number of overall filter iterations to run. </p>
</dd>
<dt>alpha</dt><dd><p>A double specifying the cooling factor to use for the IF2 algorithm. </p>
</dd>
</dl>

<p>The <code>run</code> fuction will return a vector with the estimated MLE.  Additionally, once the specialized algorithm has been run, it can be continued for additional iterations by calling the <code>continueRun</code> method.
</p>


<h3>Reparameterization</h3>

<p>The IF2 algorithm perturbs the parameters using a normal distribution, which may not be optimal for parameters whose support is not the whole real line, such as variance parameters, which are restricted to be positive. We recommend that users reparameterize the model in advance, e.g., writing variances and standard deviations on the log scale and probabilities on the logit scale. This requires specifying priors directly on the transformed parameters.
</p>


<h3>Parameter prior distributions</h3>

<p>While NIMBLE's IF2 algorithm requires prior distributions on the parameters, the IF2 algorithm produces maximum likelihood estimates and does not directly use those prior distributions. We require the prior distributions to be stated only so that we can automatically determine which model nodes are the parameters. The IF2 algorithm also makes use of any bounds on the parameters.
</p>


<h3>Diagnostics and information stored in the algorithm object</h3>

<p>The IF2 algorithm stores the estimated MLEs, one from each iteration, in <code>estimates</code>. It also stores standard deviation of the particles from each iteration, one per parameter, in <code>estSD</code>. Finally it stores the estimated log-likelihood at the estimated MLE from each iteration in <code>logLik</code>.
</p>


<h3>Author(s)</h3>

<p>Nicholas Michaud, Dao Nguyen, and Christopher Paciorek
</p>


<h3>References</h3>

<p>Ionides, E.L., D. Nguyen, Y. Atchadé, S. Stoev, and A.A. King (2015). Inference for dynamic and latent variable models via iterated, perturbed Bayes maps. <em>Proceedings of the National Academy of Sciences</em>, 112(3), 719-724.
</p>


<h3>See Also</h3>

<p>Other particle filtering methods: 
<code><a href="#topic+buildAuxiliaryFilter">buildAuxiliaryFilter</a></code>,
<code><a href="#topic+buildBootstrapFilter">buildBootstrapFilter</a></code>,
<code><a href="#topic+buildEnsembleKF">buildEnsembleKF</a></code>,
<code><a href="#topic+buildLiuWestFilter">buildLiuWestFilter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## For illustration only.
exampleCode &lt;- nimbleCode({
  x0 ~ dnorm(0, var = 1)
  x[1] ~ dnorm(.8 * x0, var = 1)
  y[1] ~ dnorm(x[1], var = .5)
  for(t in 2:10){
    x[t] ~ dnorm(.8 * x[t-1], sd = sigma_x)
    y[t] ~ dnorm(x[t], var = .5)
  }
  sigma_x ~ dunif(0, 10)
})

model &lt;- nimbleModel(code = exampleCode, data = list(y = rnorm(10)),
                     inits = list(x0 = 0, x = rnorm(10), sigma_x = 1))
my_IF2 &lt;- buildIteratedFilter2(model, 'x', params = 'sigma_x')
## Now compile and run, e.g.,
## Cmodel &lt;- compileNimble(model)
## Cmy_IF2 &lt;- compileNimble(my_IF2, project = model)
## MLE estimate of a top level parameter named sigma_x:
## sigma_x_MLE &lt;- Cmy_IF2$run(m = 10000, n = 50, alpha = 0.2)
## visualize progression of the estimated log-likelihood
## ts.plot(Cmy_IF2$logLik)
## Continue running algorithm for more precise estimate:
## sigma_x_MLE &lt;- Cmy_IF2$continueRun(n = 50, alpha = 0.2)
</code></pre>

<hr>
<h2 id='buildLiuWestFilter'>Create a Liu and West particle filter algorithm.</h2><span id='topic+buildLiuWestFilter'></span>

<h3>Description</h3>

<p>Create a Liu and West particle filter algorithm for a given NIMBLE state space model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildLiuWestFilter(model, nodes, params = NULL, control = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="buildLiuWestFilter_+3A_model">model</code></td>
<td>
<p>A NIMBLE model object, typically representing a state 
space model or a hidden Markov model</p>
</td></tr>
<tr><td><code id="buildLiuWestFilter_+3A_nodes">nodes</code></td>
<td>
<p>A character vector specifying the stochastic latent model nodes 
over which the particle filter will stochastically integrate to
estimate the log-likelihood function.  All provided nodes must be stochastic.
Can be one of three forms: a variable name, in which case all elements in the variable
are taken to be latent (e.g., 'x'); an indexed variable, in which case all indexed elements are taken
to be latent (e.g., 'x[1:100]' or 'x[1:100, 1:2]'); or a vector of multiple nodes, one per time point,
in increasing time order (e.g., c(&quot;x[1:2, 1]&quot;, &quot;x[1:2, 2]&quot;, &quot;x[1:2, 3]&quot;, &quot;x[1:2, 4]&quot;)).</p>
</td></tr>
<tr><td><code id="buildLiuWestFilter_+3A_params">params</code></td>
<td>
<p>A character vector specifying the top-level parameters to estimate the posterior distribution of. 
If unspecified, parameter nodes are specified as all stochastic top level nodes which
are not in the set of latent nodes specified in <code>nodes</code>.</p>
</td></tr>
<tr><td><code id="buildLiuWestFilter_+3A_control">control</code></td>
<td>
<p>A list specifying different control options for the particle filter.  Options are described in the details section below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each of the <code>control()</code> list options are described in detail below:
</p>

<dl>
<dt>d</dt><dd><p>A discount factor for the Liu-West filter.  Should be close to,
but not above, 1.</p>
</dd>
<dt>saveAll</dt><dd><p>Indicates whether to save state samples for all time points (TRUE), or only for the most recent time point (FALSE)</p>
</dd>
<dt>timeIndex</dt><dd><p>An integer used to manually specify which dimension of the latent state variable indexes time.  
Only needs to be set if the number of time points is less than or equal to the size of the latent state at each time point.</p>
</dd>
<dt>initModel</dt><dd><p>A logical value indicating whether to initialize the model before running the filtering algorithm.  Defaults to TRUE.</p>
</dd>
</dl>

<p>The Liu and West filter samples from the posterior 
distribution of both the latent states and top-level parameters for a state space model.  
Each particle in the Liu and West filter contains values not only for latent states, 
but also for top level parameters.  Latent states are propogated via an auxiliary step, 
as in the auxiliary particle filter (<code><a href="#topic+buildAuxiliaryFilter">buildAuxiliaryFilter</a></code>).
Top-level parameters are propagated from one 
time point to the next through a smoothed kernel density based on previous particle values.  
</p>
<p>The resulting specialized particle filter algorthm will accept a
single integer argument (<code>m</code>, default 10,000), which specifies the number
of random \'particles\' to use for sampling from the posterior distributions.  The algorithm  saves
unequally weighted samples from the posterior distribution of the latent
states and top-level parameters in <code>mvWSamples</code>, with corresponding logged weights in <code>mvWSamples['wts',]</code>.
An equally weighted sample from the posterior can be found in <code>mvEWSamples</code>. 
</p>
<p>Note that if <code>saveAll=TRUE</code>, the top-level parameter samples given in the <code>mvWSamples</code> output will correspond to the weights from the final time point.
</p>


<h3>Author(s)</h3>

<p>Nicholas Michaud
</p>


<h3>References</h3>

<p>Liu, J., and M. West. (2001). Combined parameter and state estimation in simulation-based filtering. <em>Sequential Monte Carlo methods in practice</em>. Springer New York, pages 197-223.
</p>


<h3>See Also</h3>

<p>Other particle filtering methods: 
<code><a href="#topic+buildAuxiliaryFilter">buildAuxiliaryFilter</a></code>,
<code><a href="#topic+buildBootstrapFilter">buildBootstrapFilter</a></code>,
<code><a href="#topic+buildEnsembleKF">buildEnsembleKF</a></code>,
<code><a href="#topic+buildIteratedFilter2">buildIteratedFilter2</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## For illustration only.
exampleCode &lt;- nimbleCode({
  x0 ~ dnorm(0, var = 1)
  x[1] ~ dnorm(.8 * x0, var = 1)
  y[1] ~ dnorm(x[1], var = .5)
  for(t in 2:10){
    x[t] ~ dnorm(.8 * x[t-1], sd = sigma_x)
    y[t] ~ dnorm(x[t], var = .5)
  }
  sigma_x ~ dunif(0, 10)
})

model &lt;- nimbleModel(code = exampleCode, data = list(y = rnorm(10)),
                     inits = list(x0 = 0, x = rnorm(10), sigma_x = 1))
my_LWF &lt;- buildLiuWestFilter(model, 'x', params = 'sigma_x')
## Now compile and run, e.g.,
## Cmodel &lt;- compileNimble(model)
## Cmy_LWF &lt;- compileNimble(my_LWF, project = model)
## Cmy_LWF$run(m = 1000)
## lw_X &lt;- as.matrix(Cmy_LWF$mvEWSamples, 'x')
##  samples from posterior of top level parameter
## lw_sigma_x &lt;- as.matrix(Cmy_LWF$mvEWSamples, 'sigma_x')
</code></pre>

<hr>
<h2 id='SMCsamplers'>Particle Filtering MCMC Sampling Algorithms</h2><span id='topic+SMCsamplers'></span><span id='topic+sampler_RW_PF'></span><span id='topic+samplers'></span><span id='topic+sampler'></span><span id='topic+RW_PF'></span><span id='topic+RW_PF_block'></span><span id='topic+sampler_RW_PF_block'></span>

<h3>Description</h3>

<p>Details of the particle filtering MCMC sampling algorithms provided in nimbleSMC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampler_RW_PF(model, mvSaved, target, control)

sampler_RW_PF_block(model, mvSaved, target, control)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SMCsamplers_+3A_model">model</code></td>
<td>
<p>(uncompiled) model on which the MCMC is to be run</p>
</td></tr>
<tr><td><code id="SMCsamplers_+3A_mvsaved">mvSaved</code></td>
<td>
<p><code>modelValues</code> object to be used to store MCMC samples</p>
</td></tr>
<tr><td><code id="SMCsamplers_+3A_target">target</code></td>
<td>
<p>node(s) on which the sampler will be used</p>
</td></tr>
<tr><td><code id="SMCsamplers_+3A_control">control</code></td>
<td>
<p>named list that controls the precise behavior of the sampler, with elements specific to <code>samplertype</code>.  The default values for control list are specified in the setup code of each sampling algorithm.  Descriptions of each sampling algorithm, and the possible customizations for each sampler (using the <code>control</code> argument) appear below.</p>
</td></tr>
</table>


<h3>RW_PF sampler</h3>

<p>The particle filter sampler allows the user to perform particle MCMC (PMCMC) (Andrieu et al., 2010), primarily for state-space or hidden Markov models of time-series data. This method uses Metropolis-Hastings samplers for top-level parameters but uses the likelihood approximation of a particle filter (sequential Monte Carlo) to integrate over latent nodes in the time-series.  The <code>RW_PF</code> sampler uses an adaptive Metropolis-Hastings algorithm with a univariate normal proposal distribution for a scalar parameter.  Note that samples of the latent states can be retained as well, but the top-level parameter being sampled must be a scalar.   A bootstrap, auxiliary, or user defined particle filter can be used to integrate over latent states.
</p>
<p>For more information about user-defined samplers within a PMCMC sampler, see the NIMBLE User Manual.
</p>
<p>The <code>RW_PF</code> sampler accepts the following control list elements:
</p>

<ul>
<li><p> adaptive. A logical argument, specifying whether the sampler should adapt the scale (proposal standard deviation) throughout the course of MCMC execution to achieve a theoretically desirable acceptance rate. (default = TRUE)
</p>
</li>
<li><p> adaptInterval. The interval on which to perform adaptation.  Every adaptInterval MCMC iterations (prior to thinning), the RW sampler will perform its adaptation procedure.  This updates the scale variable, based upon the sampler's achieved acceptance rate over the past adaptInterval iterations. (default = 200)
</p>
</li>
<li><p> scale. The initial value of the normal proposal standard deviation.  If <code>adaptive = FALSE</code>, scale will never change. (default = 1)
</p>
</li>
<li><p> pfNparticles.  The number of particles to use in the approximation to the log likelihood of the data (default = 1000).
</p>
</li>
<li><p> latents.  Character vector specifying the nodes that are latent states over which the particle filter will operate to approximate the log-likelihood function.
</p>
</li>
<li><p> pfType.  Character argument specifying the type of particle filter that should be used for likelihood approximation.  Choose from <code>"bootstrap"</code> and <code>"auxiliary"</code>.  Defaults to <code>"bootstrap"</code>.
</p>
</li>
<li><p> pfControl.  A control list that is passed to the particle filter function.  For details on control lists for bootstrap or auxiliary particle filters, see <code><a href="#topic+buildBootstrapFilter">buildBootstrapFilter</a></code> or <code><a href="#topic+buildAuxiliaryFilter">buildAuxiliaryFilter</a></code> respectively.  Additionally, this can be used to pass custom arguments into a user-defined particle filter.
</p>
</li>
<li><p> pfOptimizeNparticles.  A logical argument, specifying whether to use an experimental procedure to automatically determine the optimal number of particles to use, based on Pitt and Shephard (2011).  This will override any value of <code>pfNparticles</code> specified above.
</p>
</li>
<li><p> pf.  A user-defined particle filter object, if a bootstrap or auxiliary particle filter is not adequate.
</p>
</li></ul>



<h3>RW_PF_block sampler</h3>

<p>The particle filter block sampler allows the user to perform particle MCMC (PMCMC) (Andrieu et al., 2010) for multiple parameters jointly, primarily for state-space or hidden Markov models of time-series data.  This method uses Metropolis-Hastings block samplers for top-level parameters but uses the likelihood approximation of a particle filter (sequential Monte Carlo) to integrate over latent nodes in the time-series.  The <code>RW_PF</code> sampler uses an adaptive Metropolis-Hastings algorithm with a multivariate normal proposal distribution.  Note that samples of the latent states can be retained as well, but the top-level parameter being sampled must be a scalar.   A bootstrap, auxiliary, or user defined particle filter can be used to integrate over latent states.
</p>
<p>For more information about user-defined samplers within a PMCMC sampler, see the NIMBLE User Manual.
</p>
<p>The <code>RW_PF_block</code> sampler accepts the following control list elements:
</p>

<ul>
<li><p> adaptive. A logical argument, specifying whether the sampler should adapt the proposal covariance throughout the course of MCMC execution. (default = TRUE)
</p>
</li>
<li><p> adaptScaleOnly. A logical argument, specifying whether adaptation should be done only for <code>scale</code> (TRUE) or also for <code>provCov</code> (FALSE).  This argument is only relevant when <code>adaptive = TRUE</code>.  When <code>adaptScaleOnly = FALSE</code>, both <code>scale</code> and <code>propCov</code> undergo adaptation; the sampler tunes the scaling to achieve a theoretically good acceptance rate, and the proposal covariance to mimic that of the empirical samples.  When <code>adaptScaleOnly = TRUE</code>, only the proposal scale is adapted. (default = FALSE)
</p>
</li>
<li><p> adaptInterval. The interval on which to perform adaptation. (default = 200)
</p>
</li>
<li><p> scale. The initial value of the scalar multiplier for <code>propCov</code>.  If <code>adaptive = FALSE</code>, <code>scale</code> will never change. (default = 1)
</p>
</li>
<li><p> adaptFactorExponent. Exponent controling the rate of decay of the scale adaptation factor.  See Shaby and Wells, 2011, for details. (default = 0.8)
</p>
</li>
<li><p> propCov. The initial covariance matrix for the multivariate normal proposal distribution.  This element may be equal to the <code>'identity'</code>, in which case the identity matrix of the appropriate dimension will be used for the initial proposal covariance matrix. (default is <code>'identity'</code>)
</p>
</li>
<li><p> pfNparticles.  The number of particles to use in the approximation to the log likelihood of the data (default = 1000).
</p>
</li>
<li><p> latents.  Character vector specifying the nodes that are latent states over which the particle filter will operate to approximate the log-likelihood function.
</p>
</li>
<li><p> pfType.  Character argument specifying the type of particle filter that should be used for likelihood approximation.  Choose from <code>"bootstrap"</code> and <code>"auxiliary"</code>.  Defaults to <code>"bootstrap"</code>.
</p>
</li>
<li><p> pfControl.  A control list that is passed to the particle filter function.  For details on control lists for bootstrap or auxiliary particle filters, see <code><a href="#topic+buildBootstrapFilter">buildBootstrapFilter</a></code> or <code><a href="#topic+buildAuxiliaryFilter">buildAuxiliaryFilter</a></code> respectively.  Additionally, this can be used to pass custom arguments into a user defined particle filter.
</p>
</li>
<li><p> pfOptimizeNparticles.  A logical argument, specifying whether to automatically determine the optimal number of particles to use, based on Pitt and Shephard (2011).  This will override any value of <code>pfNparticles</code> specified above.
</p>
</li>
<li><p> pf.  A user-defined particle filter object, if a bootstrap or auxiliary particle filter is not adequate.
</p>
</li></ul>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
