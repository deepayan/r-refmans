<!DOCTYPE html><html lang="en"><head><title>Help for package polymatching</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {polymatching}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#polymatching'><p>Polymatching: Matching in Designs with Multiple Treatment Groups</p></a></li>
<li><a href='#balance'><p>Evaluating the Balance of Covariates After Matching</p></a></li>
<li><a href='#plotBalance'><p>Summary Plot of Balance in Covariates</p></a></li>
<li><a href='#polymatch'><p>Polymatching</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Matching Algorithm for Designs with Multiple Groups</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Includes functions implementing the conditionally optimal matching algorithm, 
    which can be used to generate matched samples in designs with multiple groups. The algorithm
    is described in Nattino, Song and Lu (2022) &lt;<a href="https://doi.org/10.1016%2Fj.csda.2021.107364">doi:10.1016/j.csda.2021.107364</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>optmatch, ggplot2, gridExtra, tidyr, utils, stats, dplyr,
magrittr, rlang, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>VGAM, knitr, rmarkdown</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-07 09:28:17 UTC; GNattino</td>
</tr>
<tr>
<td>Author:</td>
<td>Giovanni Nattino [aut, cre],
  Bo Lu [aut],
  Chi Song [aut],
  Henry Xiang [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Giovanni Nattino &lt;giovanni.nattino@marionegri.it&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-07 18:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='polymatching'>Polymatching: Matching in Designs with Multiple Treatment Groups</h2><span id='topic+polymatching-package'></span><span id='topic+polymatching'></span>

<h3>Description</h3>

<p>The package implements the conditionally optimal matching algorithm, which can be used to generate
matched samples in designs with multiple treatment groups.
</p>


<h3>Details</h3>

<p>Currently, the algorithm can be applied to datasets with up to 10 groups and generates
matched samples with one subject per group. The package provides functions to generate the matched
sample and to evaluate the balance in key covariates.
</p>


<h3>Generating the Matched Sample</h3>

<p>The function implementing the matching algorithm is <code><a href="#topic+polymatch">polymatch</a></code>. The algorithm is iterative and
needs a matched sample with one subject per group as starting point. This matched sample can be
automatically generated by <code><a href="#topic+polymatch">polymatch</a></code> or can be provided by the user. The algorithm iteratively
explores possible reductions in the total distance of the matched sample.
</p>


<h3>Evaluating Balance in Covariates</h3>

<p>Balance in key covariates can be evaluated with the function <code><a href="#topic+balance">balance</a></code>. Given a
matched sample and a set of covariates of interest, the function computes
the standardized differences and the ratio of the variances for each pair of treatment groups
in the study design. For 3, 4, 5 and 6 groups, there are
3, 6, 10 and 15 pairs of groups and the balance is evaluated before and after matching.
The result of <code><a href="#topic+balance">balance</a></code> can be graphically represented with <code><a href="#topic+plotBalance">plotBalance</a></code>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Giovanni Nattino <a href="mailto:giovanni.nattino@marionegri.it">giovanni.nattino@marionegri.it</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Bo Lu
</p>
</li>
<li><p> Chi Song
</p>
</li>
<li><p> Henry Xiang
</p>
</li></ul>


<hr>
<h2 id='balance'>Evaluating the Balance of Covariates After Matching</h2><span id='topic+balance'></span>

<h3>Description</h3>

<p>The function <code>balance</code> computes the standardized mean differences and the ratio of the variances among treatment groups,
before and after matching. The function computes the two measures of balance for each pair of treatment groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>balance(
  formulaBalance,
  match_id,
  data,
  weights_before = NULL,
  weights_after = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="balance_+3A_formulabalance">formulaBalance</code></td>
<td>
<p>Formula with form <code>group ~ x_1 + ... + x_p</code>. <code>group</code> is the variable
identifying the treatment groups/exposures. The balance is evaluated for the covariates <code>x_1</code>,...,<code>x_p</code>.
Numeric and integer variables are treated as continuous. Factor variables are treated as categorical.
Factor variables with two levels are treated as binary.</p>
</td></tr>
<tr><td><code id="balance_+3A_match_id">match_id</code></td>
<td>
<p>Vector identifying the matched sets&mdash;matched units must have the same identifier. It is generated by
<code><a href="#topic+polymatch">polymatch</a></code>.</p>
</td></tr>
<tr><td><code id="balance_+3A_data">data</code></td>
<td>
<p>The <code>data.frame</code> object with the data.</p>
</td></tr>
<tr><td><code id="balance_+3A_weights_before">weights_before</code></td>
<td>
<p>Optional vector of weights of the observations to be considered in the unmatched dataset. To compute the
unweighted standardized mean differences, set <code>weights_before</code> to NULL (default).</p>
</td></tr>
<tr><td><code id="balance_+3A_weights_after">weights_after</code></td>
<td>
<p>Vector of weights for the matched dataset. Set it to NULL (default) to compute the
unweighted standardized mean differences.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> containing the standardized differences and ratios of the variances (only for continuous
variables) for each pair of treatment groups. A graphical representation of the results can be generated with
<code><a href="#topic+plotBalance">plotBalance</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+polymatch">polymatch</a></code> to generate matched samples and <code><a href="#topic+plotBalance">plotBalance</a></code> to
graphically represent the indicators of balance.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Generate a datasets with group indicator and four variables:
#- var1, continuous, sampled from normal distributions;
#- var2, continuous, sampled from beta distributions;
#- var3, categorical with 4 levels;
#- var4, binary.
set.seed(1234567)
dat &lt;- data.frame(group = c(rep("A",10),rep("B",20),rep("C",30)),
               var1 = c(rnorm(10,mean=0,sd=1),
                        rnorm(20,mean=1,sd=2),
                        rnorm(30,mean=-1,sd=2)),
               var2 = c(rbeta(10,shape1=1,shape2=1),
                        rbeta(20,shape1=2,shape2=1),
                        rbeta(30,shape1=1,shape2=2)),
               var3 = factor(c(rbinom(10,size=3,prob=.4),
                               rbinom(20,size=3,prob=.5),
                               rbinom(30,size=3,prob=.3))),
               var4 = factor(c(rbinom(10,size=1,prob=.5),
                               rbinom(20,size=1,prob=.3),
                               rbinom(30,size=1,prob=.7))))

#Match on propensity score
#-------------------------

#With multiple groups, need a multinomial model for the PS
library(VGAM)
psModel &lt;- vglm(group ~ var1 + var2 + var3 + var4,
                family=multinomial, data=dat)
#Estimated logits - 2 for each unit: log(P(group=A)/P(group=C)), log(P(group=B)/P(group=C))
logitPS &lt;- predict(psModel, type = "link")
dat$logit_AvsC &lt;- logitPS[,1]
dat$logit_BvsC &lt;- logitPS[,2]

#Match on logits of PS
resultPs &lt;- polymatch(group ~ logit_AvsC + logit_BvsC, data = dat,
                    distance = "euclidean")
dat$match_id_ps &lt;- resultPs$match_id

#Evaluate balance in covariates
tabBalancePs &lt;- balance(group ~ var1 + var2 + var3 + var4,
                        match_id = dat$match_id_ps, data = dat)
tabBalancePs

#You can also represent the standardized mean differences with 'plotBalance'
#plotBalance(tabBalancePs, ratioVariances = TRUE)

</code></pre>

<hr>
<h2 id='plotBalance'>Summary Plot of Balance in Covariates</h2><span id='topic+plotBalance'></span>

<h3>Description</h3>

<p>The function generates a plot summarizing the balance of the covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotBalance(dataBalance, ratioVariances = FALSE, boxplots = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotBalance_+3A_databalance">dataBalance</code></td>
<td>
<p>the output of <code><a href="#topic+balance">balance</a></code>.</p>
</td></tr>
<tr><td><code id="plotBalance_+3A_ratiovariances">ratioVariances</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, the generated plot contains two panels:
one for the standardized differences and one for the ratios of the variances. If <code>FALSE</code>
(the default), only the standardized differences are represented.</p>
</td></tr>
<tr><td><code id="plotBalance_+3A_boxplots">boxplots</code></td>
<td>
<p>Boolean. If <code>TRUE</code> (default), boxplots are added to the plot, to show the
distribution of the standardized differences and ratios of the variances.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If at least one of the covariates is continuous and <code>ratioVariances=TRUE</code>,
the function generates a plot with two panels: one for the
standardized differences and one for the ratio of the variances (only for the continous variables).
If either all the covariates are categorical/binary or <code>ratioVariances=FALSE</code> (or both),
only the plot with the standardized differences is generated.
The function also returns a list with the <code>ggplot2</code> objects corresponding to the generated plot(s).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+polymatch">polymatch</a></code> to generate matched samples and <code><a href="#topic+balance">balance</a></code> to compute
the indicators of balance.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#See examples of function 'balance'

</code></pre>

<hr>
<h2 id='polymatch'>Polymatching</h2><span id='topic+polymatch'></span>

<h3>Description</h3>

<p><code>polymatch</code> generates matched samples in designs with up to 10 groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polymatch(
  formulaMatch,
  start = "small.to.large",
  data,
  distance = "euclidean",
  exactMatch = NULL,
  vectorK = NULL,
  iterate = TRUE,
  niter_max = 50,
  withinGroupDist = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="polymatch_+3A_formulamatch">formulaMatch</code></td>
<td>
<p>Formula with form <code>group ~ x_1 + ... + x_p</code>, where <code>group</code> is the name of the variable
identifying the treatment groups/exposures and <code>x_1</code>,...,<code>x_p</code> are the matching variables.</p>
</td></tr>
<tr><td><code id="polymatch_+3A_start">start</code></td>
<td>
<p>An object specifying the starting point of the iterative algorithm. Three types of input are accepted:
</p>

<ul>
<li> <p><code>start="small.to.large"</code> (default): the starting matched set is generated by matching groups
from the smallest to the largest.
</p>
</li>
<li><p> Users can specify the order to be used to match groups for the starting sample.
For example, if there are four groups with labels &quot;A&quot;,&quot;B&quot;,&quot;C&quot; and &quot;D&quot;, <code>start="D-B-A-C"</code> generates the starting sample
by matching groups &quot;D&quot; and &quot;B&quot;, then units from &quot;A&quot; to the &quot;D&quot;-&quot;B&quot;pairs, then units from &quot;C&quot; to the &quot;D&quot;-&quot;B&quot;-&quot;A&quot; triplets.
</p>
</li>
<li><p> Users can provide the starting matched set and the algorithm will explore possible reductions in the total
distance. In this case, <code>start</code> must be a vector with the IDs of the matched sets, i.e.,
a vector with length equal to the number of rows of <code>data</code> where
matched subjects are flagged with the same value and non-matched subjects have value <code>NA</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="polymatch_+3A_data">data</code></td>
<td>
<p>The <code>data.frame</code> object with the data.</p>
</td></tr>
<tr><td><code id="polymatch_+3A_distance">distance</code></td>
<td>
<p>String specifying whether the distance between pairs of observations should be computed with the
Euclidean (<code>"euclidean"</code>, default) or Mahalanobis (<code>"mahalanobis"</code>) distance. See section 'Details' for further information.</p>
</td></tr>
<tr><td><code id="polymatch_+3A_exactmatch">exactMatch</code></td>
<td>
<p>Formula with form <code>~ z_1 + ... + z_k</code>, where <code>z_1</code>,...,<code>z_k</code> must
be factor variables. Subjects are exactly matched on <code>z_1</code>,...,<code>z_k</code>, i.e., matched
within levels of these variables.</p>
</td></tr>
<tr><td><code id="polymatch_+3A_vectork">vectorK</code></td>
<td>
<p>A named vector with the number of subjects from each group in each matched set. The names of the vector must be 
the labels of the groups, i.e., the levels of the variable identifying the treatment groups/exposures. 
For example, in case of four groups with labels &quot;A&quot;,&quot;B&quot;,&quot;C&quot; and &quot;D&quot; and assuming that the desired design is 1:2:3:3 
(1 subject from A, 2 from B, 3 from C and 3 from D in each matched set), the parameter should be set to
<code>vectorK =  c("A" = 1, "B" = 2, "C" = 3, "D" = 3)</code>. By default, the generated matched design includes 1 subject per group in each
matched set, i.e, a 1:1: ... :1 matched design.</p>
</td></tr>
<tr><td><code id="polymatch_+3A_iterate">iterate</code></td>
<td>
<p>Boolean specifying whether iterations should be done (<code>iterate=TRUE</code>, default) or not (<code>iterate=FALSE</code>).</p>
</td></tr>
<tr><td><code id="polymatch_+3A_niter_max">niter_max</code></td>
<td>
<p>Maximum number of iterations. Default is 50.</p>
</td></tr>
<tr><td><code id="polymatch_+3A_withingroupdist">withinGroupDist</code></td>
<td>
<p>Boolean specifying whether the distances within the same treatment/exposure group should be considered in the 
total distance. For example, in a 1:2:3 matched design among the groups A, B and C, the parameters controls whether the distance 
between the two subjects in B and the three pairwise distances among the subjects in C should be counted in the total distance. 
The default value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="polymatch_+3A_verbose">verbose</code></td>
<td>
<p>Boolean: should text be printed in the console? Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function implements the conditionally optimal matching algorithm, which iteratively uses
two-group optimal matching steps to generate matched samples with small total distance. In the current implementation,
it is possible to generate matched samples with multiple subjects per group, with the matching ratio being 
specified by the <code>vectorK</code> parameter.
</p>
<p>The steps of the algorithm are described with the following example. Consider a 4-group design with
groups labels &quot;A&quot;, &quot;B&quot;, &quot;C&quot; and &quot;D&quot; and a 1:1:1:1 matching ratio. The algorithm requires a set of quadruplets as starting point. 
The argument <code>start</code> defines the approach to be used to
generate such a starting point. <code>polymatch</code> generates the starting point by sequentially using optimal two-group matching.
In the default setting (<code>start="small.to.large"</code>), the steps are:
</p>

<ol>
<li><p> optimally match the two smallest groups;
</p>
</li>
<li><p> optimally match the third smallest group to the pairs generated in the first step;
</p>
</li>
<li><p> optimally match the last group to the triplets generated in the second step.
</p>
</li></ol>

<p>Notably, we can use the optimal two-group algorithm in steps 2) and 3) because they are
two-dimensional problems: the elements of one group on one hand, fixed matched sets on the other hand. The order of the
groups to be considered when generating the starting point can be user-specified (e.g., <code>start="D-B-A-C"</code>).
In alternative, the user can provide a matched set that will be used as starting point.
</p>
<p>Given the starting matched set, the algorithm iteratively explores possible reductions in the total distance (if <code>iterate="TRUE"</code>),
by sequentially relaxing the connection to each group and rematching units of that group. In our example:
</p>

<ol>
<li><p> rematch &quot;B-C-D&quot; triplets within the starting quadruplets to units in group &quot;A&quot;;
</p>
</li>
<li><p> rematch &quot;A-C-D&quot; triplets within the starting quadruplets to units in group &quot;B&quot;;
</p>
</li>
<li><p> rematch &quot;A-B-D&quot; triplets within the starting quadruplets to units in group &quot;C&quot;;
</p>
</li>
<li><p> rematch &quot;A-B-C&quot; triplets within the starting quadruplets to units in group &quot;D&quot;.
</p>
</li></ol>

<p>If none of the sets of quadruplets generated in 1)-4) has smaller total distance than the starting point, the algorihm stops.
Otherwise, the set of quadruplets with smallest distance is seleceted and the process iterated, until no reduction in the total
distance is found or the number of maximum iterations is reached (<code>niter_max=50</code> by default).
</p>
<p>The total distance is defined as the sum of all the within-matched-set distances. The within-matched-set distance is defined as the
sum of the pairwise distances between pairs of units in the matched set. The type of distance is specified with the <code>distance</code>
argument. The current implementation supports Euclidean (<code>distance="euclidean"</code>) and Mahalanobis (<code>distance="mahalanobis"</code>)
distances. In particular, for the Mahalanobis distance, the covariance matrix is defined only once on the full dataset.
</p>


<h3>Value</h3>

<p>A list containing the following components:
</p>

<dl>
<dt>match_id</dt><dd><p>A numeric vector identifying the matched sets&mdash;matched units have the same identifier.</p>
</dd>
<dt>total_distance</dt><dd><p>Total distance of the returned matched sample.</p>
</dd>
<dt>total_distance_start</dt><dd><p>Total distance at the starting point.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+balance">balance</a></code> and <code><a href="#topic+plotBalance">plotBalance</a></code> to summarize the
balance in the covariates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Generate a datasets with group indicator and four variables:
#- var1, continuous, sampled from normal distributions;
#- var2, continuous, sampled from beta distributions;
#- var3, categorical with 4 levels;
#- var4, binary.
set.seed(1234567)
dat &lt;- data.frame(group = c(rep("A",10),rep("B",20),rep("C",30)),
               var1 = c(rnorm(10,mean=0,sd=1),
                        rnorm(20,mean=1,sd=2),
                        rnorm(30,mean=-1,sd=2)),
               var2 = c(rbeta(10,shape1=1,shape2=1),
                        rbeta(20,shape1=2,shape2=1),
                        rbeta(30,shape1=1,shape2=2)),
               var3 = factor(c(rbinom(10,size=3,prob=.4),
                               rbinom(20,size=3,prob=.5),
                               rbinom(30,size=3,prob=.3))),
               var4 = factor(c(rbinom(10,size=1,prob=.5),
                               rbinom(20,size=1,prob=.3),
                               rbinom(30,size=1,prob=.7))))

#Match on propensity score
#-------------------------

#With multiple groups, need a multinomial model for the PS
library(VGAM)
psModel &lt;- vglm(group ~ var1 + var2 + var3 + var4,
                family=multinomial, data=dat)
#Estimated logits - 2 for each unit: log(P(group=A)/P(group=C)), log(P(group=B)/P(group=C))
logitPS &lt;- predict(psModel, type = "link")
dat$logit_AvsC &lt;- logitPS[,1]
dat$logit_BvsC &lt;- logitPS[,2]

#Match on logits of PS
resultPs &lt;- polymatch(group ~ logit_AvsC + logit_BvsC, data = dat,
                    distance = "euclidean")
dat$match_id_ps &lt;- resultPs$match_id


#Match on covariates
#--------------------


#Match on continuous covariates with exact match on categorical/binary variables
resultCov &lt;- polymatch(group ~ var1 + var2, data = dat,
                        distance = "mahalanobis",
                        exactMatch = ~var3+var4)
dat$match_id_cov &lt;- resultCov$match_id

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
