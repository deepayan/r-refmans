<!DOCTYPE html><html lang="en"><head><title>Help for package icmstate</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {icmstate}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#icmstate-package'><p>icmstate</p></a></li>
<li><a href='#ageqb'><p>Check if event time is larger/equal than other event time</p></a></li>
<li><a href='#agreaterb'><p>Check if event time is larger than other event time</p></a></li>
<li><a href='#ainB'><p>Check if event time is contained within half-open interval</p></a></li>
<li><a href='#Aintersectb'><p>Check if half-open intervals intersect with event times</p></a></li>
<li><a href='#Alargerb'><p>Check if closed interval is contained in half-open infinite interval</p></a></li>
<li><a href='#AsubsetB'><p>Check if closed interval is contained in other closed interval</p></a></li>
<li><a href='#binary_search_larger'><p>Binary search - Larger</p></a></li>
<li><a href='#binary_search_larger_equal'><p>Binary search - Larger or equal to</p></a></li>
<li><a href='#ChapKolm_fwd_mat'><p>Function to use</p></a></li>
<li><a href='#direct_from_observed_intervals'><p>Translate observed transition intervals into direct transition intervals</p></a></li>
<li><a href='#EM_multinomial'><p>Helper function for npmsm()</p></a></li>
<li><a href='#EM_poisson'><p>Helper function for npmsm()</p></a></li>
<li><a href='#EM_solver'><p>EM solver for extended illness-death model (Frydman 1995)</p></a></li>
<li><a href='#estimate_support_msm'><p>Estimate the support of a general Markov interval-censored Multi-state model without</p>
loops.</a></li>
<li><a href='#evalstep'><p>Sample from a markov chain multi state model with exactly observed transition times</p></a></li>
<li><a href='#existenceNPMLE'><p>Check existence of NPMLE</p></a></li>
<li><a href='#get_trans_intervals'><p>Get transition intervals from specified data</p></a></li>
<li><a href='#graphfromIntervals'><p>Construct Graph from censoring/truncation intervals</p></a></li>
<li><a href='#interpol_msfit'><p>Given a <code>msfit</code> object, linearly interpolate the cumulative hazard</p>
taking into account the support sets for <code>msfit</code> objects.</a></li>
<li><a href='#msm_frydman'><p>Determine NPMLE for Multi State illness death Markov model using Frydman (1995)</p></a></li>
<li><a href='#npmsm'><p>NPMLE for general multi-state model with interval censored transitions</p></a></li>
<li><a href='#plot_probtrans'><p>Plot the transition probabilities for a fitted <code>npmsm</code> model</p></a></li>
<li><a href='#plot_surv'><p>Plot the transition specific survival probabilities for a fitted <code>npmsm</code> model</p></a></li>
<li><a href='#plot.npmsm'><p>Plot a &quot;npmsm&quot; object</p></a></li>
<li><a href='#print.npmsm'><p>Print a &quot;npmsm&quot; object</p></a></li>
<li><a href='#probtrans_weib'><p>Determine transition probabilities for a multi-state model with Weibull</p>
hazards for the transitions.</a></li>
<li><a href='#prod_lambda_G_base'><p>Calculate the product of intensities over interval decided by</p>
failure times</a></li>
<li><a href='#remove_redundant_observations'><p>Remove redundant observations from supplied data frame</p></a></li>
<li><a href='#sim_id_weib'><p>Simulate panel data from an illness-death model with Weibull transition hazards</p></a></li>
<li><a href='#sim_weibmsm'><p>Simulate multiple trajectories from an interval-censored multi-state model</p>
with Weibull transition intensities</a></li>
<li><a href='#support_from_direct_intervals'><p>Estimate support of multiple transitions given direct transition intervals</p></a></li>
<li><a href='#support_frydman'><p>Find support for Illness-death model. Only</p>
applicable to Frydman (1995) setting!!</a></li>
<li><a href='#support_npmsm'><p>Numerically find the support of the transitions from a converged npmsm algorithm</p></a></li>
<li><a href='#supportHudgens'><p>Determine the support of the NPMLE for interval censored data.</p></a></li>
<li><a href='#transprob.msm'><p>Wrapper for the <code>probtrans</code> function</p></a></li>
<li><a href='#visualise_data'><p>Visualise data for illness-death model, only applicable to Frydman(1995) setting.</p></a></li>
<li><a href='#visualise_msm'><p>Visualise multi-state data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Interval Censored Multi-State Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Daniel Gomon &lt;dgstatsoft@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Allows for the non-parametric estimation of transition intensities in interval-censored
    multi-state models using the approach of Gomon and Putter (2024) &lt;<a href="https://doi.org/10.48550%2FarXiv.2409.07176">doi:10.48550/arXiv.2409.07176</a>&gt; or 
    Gu et al. (2023) &lt;<a href="https://doi.org/10.1093%2Fbiomet%2Fasad073">doi:10.1093/biomet/asad073</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, mstate, prodlim, igraph (&ge; 1.3.0), checkmate, ggplot2,
deSolve, msm</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), icenReg, profvis, survival, knitr,
rmarkdown, bookdown, latex2exp</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-08 10:22:56 UTC; Daniel</td>
</tr>
<tr>
<td>Author:</td>
<td>Daniel Gomon <a href="https://orcid.org/0000-0001-9011-3743"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Hein Putter <a href="https://orcid.org/0000-0001-5395-1422"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-08 23:20:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='icmstate-package'>icmstate</h2><span id='topic+icmstate'></span><span id='topic+icmstate-package'></span>

<h3>Description</h3>

<p>Non-parametric estimation of transition intensities in 
interval-censored multi-state models
</p>


<h3>Details</h3>

<p>Allows for the estimation of transition intensities in interval-censored
multi-state models using the approach of Gomon and Putter (2024) (Multinomial likelihood) or 
Gu et al. (2023) (Poisson likelihood).
</p>


<h3>Author(s)</h3>

<p>Maintainer: Daniel Gomon &lt;dgstatsoft@gmail.com&gt; [aut, cre] <br />
Hein Putter [aut]
</p>


<h3>References</h3>

<p>Y. Gu, D. Zeng, G. Heiss, and D. Y. Lin, 
Maximum likelihood estimation for semiparametric regression models with 
interval-censored multistate data, Biometrika, Nov. 2023, doi:10.1093/biomet/asad073
</p>
<p>D. Gomon and H. Putter, 
Non-parametric estimation of transition intensities in interval censored Markov multi-state models without loops,
arXiv, 2024, doi:10.48550/arXiv.2409.07176
</p>

<hr>
<h2 id='ageqb'>Check if event time is larger/equal than other event time</h2><span id='topic+ageqb'></span>

<h3>Description</h3>

<p>Function which takes as input a vector a with event times 
and a vector b with event times and checks whether each entry in a is 
larger or equal than the entries in b.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ageqb(a, b)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ageqb_+3A_a">a</code></td>
<td>
<p>Vector of event times</p>
</td></tr>
<tr><td><code id="ageqb_+3A_b">b</code></td>
<td>
<p>Vector of event times</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of size (length(a) * length(b)) with binary values indicating 
whether the event times in a are larger than the event times in b
</p>

<hr>
<h2 id='agreaterb'>Check if event time is larger than other event time</h2><span id='topic+agreaterb'></span>

<h3>Description</h3>

<p>Function which takes as input a vector a with event times 
and a vector b with event times and checks whether each entry in a is 
larger  than the entries in b.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>agreaterb(a, b)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="agreaterb_+3A_a">a</code></td>
<td>
<p>Vector of event times</p>
</td></tr>
<tr><td><code id="agreaterb_+3A_b">b</code></td>
<td>
<p>Vector of event times</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of size (length(a) * length(b)) with binary values indicating 
whether the event times in a are larger than the event times in b
</p>

<hr>
<h2 id='ainB'>Check if event time is contained within half-open interval</h2><span id='topic+ainB'></span>

<h3>Description</h3>

<p>Function which takes as input a vector a with event times 
and a 2 column matrix B representing half-open intervals (l, R] and checks whether 
each event time is contained in each half-open interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ainB(a, B)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ainB_+3A_a">a</code></td>
<td>
<p>Vector of event times</p>
</td></tr>
<tr><td><code id="ainB_+3A_b">B</code></td>
<td>
<p>Two column matrix containing intervals</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of size (length(a) * nrow(B)) with binary values indicating 
whether the event times in a are contained in the intervals of B
</p>

<hr>
<h2 id='Aintersectb'>Check if half-open intervals intersect with event times</h2><span id='topic+Aintersectb'></span>

<h3>Description</h3>

<p>Function which takes as input a 2 column matrix of half-open 
intervals and a vector of event times and returns the event times that 
intersect with the half-open intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Aintersectb(A, b, A.left.open = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Aintersectb_+3A_a">A</code></td>
<td>
<p>Two column matrix containing intervals</p>
</td></tr>
<tr><td><code id="Aintersectb_+3A_b">b</code></td>
<td>
<p>Vector of event times</p>
</td></tr>
<tr><td><code id="Aintersectb_+3A_a.left.open">A.left.open</code></td>
<td>
<p>Are the intervals in A open on the left side? Default = FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector of event times from b that intersect with A.
</p>

<hr>
<h2 id='Alargerb'>Check if closed interval is contained in half-open infinite interval</h2><span id='topic+Alargerb'></span>

<h3>Description</h3>

<p>Function which takes as input a matrix with 2 columns and a 
vector indicating left points of intervals [b, Infinity)
and checks whether each interval in the matrix is contained within 
the corresponding interval derived from b.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Alargerb(A, b)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Alargerb_+3A_a">A</code></td>
<td>
<p>Two column matrix containing intervals to be checked for being 
contained in b</p>
</td></tr>
<tr><td><code id="Alargerb_+3A_b">b</code></td>
<td>
<p>Vector indicating left point in corresponding [b, Infinity) interval</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of size (nrow(A) * length(b)) with binary values indicating 
whether the intervals in A are contained in the ones induced by b
</p>

<hr>
<h2 id='AsubsetB'>Check if closed interval is contained in other closed interval</h2><span id='topic+AsubsetB'></span>

<h3>Description</h3>

<p>Function which takes as input two matrices with 2 columns each 
and checks whether each interval in the first matrix is contained within 
each interval in the second matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AsubsetB(A, B, B.left.open = FALSE, B.right.open = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AsubsetB_+3A_a">A</code></td>
<td>
<p>Two column matrix containing intervals to be checked for being 
contained in B</p>
</td></tr>
<tr><td><code id="AsubsetB_+3A_b">B</code></td>
<td>
<p>Two column matrix containing intervals possibly overlapping 
the intervals in A</p>
</td></tr>
<tr><td><code id="AsubsetB_+3A_b.left.open">B.left.open</code></td>
<td>
<p>Are the intervals in B left-open?</p>
</td></tr>
<tr><td><code id="AsubsetB_+3A_b.right.open">B.right.open</code></td>
<td>
<p>Are the intervals in B right-open?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of size (nrow(A) * nrow(B)) with binary values indicating 
whether the intervals in A are contained in B
</p>

<hr>
<h2 id='binary_search_larger'>Binary search - Larger</h2><span id='topic+binary_search_larger'></span>

<h3>Description</h3>

<p>Find index of first value larger than x in a sorted array
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binary_search_larger(v, data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="binary_search_larger_+3A_v">v</code></td>
<td>
<p>- sorted vector instance</p>
</td></tr>
<tr><td><code id="binary_search_larger_+3A_data">data</code></td>
<td>
<p>- value to search</p>
</td></tr>
</table>


<h3>Value</h3>

<p>index of first value larger than data -1, -1 otherwise
</p>

<hr>
<h2 id='binary_search_larger_equal'>Binary search - Larger or equal to</h2><span id='topic+binary_search_larger_equal'></span>

<h3>Description</h3>

<p>Find index of first value larger or equal to x in a sorted array
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binary_search_larger_equal(v, data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="binary_search_larger_equal_+3A_v">v</code></td>
<td>
<p>- sorted vector instance</p>
</td></tr>
<tr><td><code id="binary_search_larger_equal_+3A_data">data</code></td>
<td>
<p>- value to search</p>
</td></tr>
</table>


<h3>Value</h3>

<p>index of first value larger or equal than data, -1 otherwise
</p>

<hr>
<h2 id='ChapKolm_fwd_mat'>Function to use</h2><span id='topic+ChapKolm_fwd_mat'></span>

<h3>Description</h3>

<p>Function to use
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ChapKolm_fwd_mat(t, state, parameters, transMat)
</code></pre>

<hr>
<h2 id='direct_from_observed_intervals'>Translate observed transition intervals into direct transition intervals</h2><span id='topic+direct_from_observed_intervals'></span>

<h3>Description</h3>

<p>Given observed transition intervals, determine the &quot;worst&quot; (least informative) possible 
direct transition intervals that could have occurred to form this sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>direct_from_observed_intervals(observed_intervals, tmat, gd)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="direct_from_observed_intervals_+3A_observed_intervals">observed_intervals</code></td>
<td>
<p>Output from <code><a href="#topic+get_trans_intervals">get_trans_intervals</a></code>.</p>
</td></tr>
<tr><td><code id="direct_from_observed_intervals_+3A_tmat">tmat</code></td>
<td>
<p>A transition matrix as created by <code>transMat</code></p>
</td></tr>
<tr><td><code id="direct_from_observed_intervals_+3A_gd">gd</code></td>
<td>
<p>A <code>data.frame</code> with the following named columns
</p>

<dl>
<dt><code>id</code>:</dt><dd><p>Subject idenitifier;</p>
</dd>
<dt><code>state</code>:</dt><dd><p>State at which the subject is observed at <code>time</code>;</p>
</dd>
<dt><code>time</code>:</dt><dd><p>Time at which the subject is observed;</p>
</dd>
</dl>
<p> The true transition time between states is then interval censored between the times.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with the following named columns
</p>

<dl>
<dt><code>entry_time</code>:</dt><dd><p>Time of entry into &quot;from&quot; state;</p>
</dd>
<dt><code>time_from</code>:</dt><dd><p>Last time subject(id) was seen in state &quot;from&quot;;</p>
</dd>
<dt><code>time_to</code>:</dt><dd><p>First time subject(id) was seen in state &quot;to&quot;;</p>
</dd>
<dt><code>from</code>:</dt><dd><p>State from which a transition was observed;</p>
</dd>
<dt><code>to</code>:</dt><dd><p>State to which the transition was observed;</p>
</dd>
<dt><code>id</code>:</dt><dd><p>Subject identifier;</p>
</dd>
</dl>
<p> For right-censored observations, entry_time denotes the first time
seen in the censored state, time_from the last time seen in the censored state,
time_to is <code>Inf</code>, from the censored state and to is <code>NA</code>.
</p>

<hr>
<h2 id='EM_multinomial'>Helper function for npmsm()</h2><span id='topic+EM_multinomial'></span>

<h3>Description</h3>

<p>For a general Markov chain multi-state model with interval censored 
transitions calculate the NPMLE using an EM algorithm with multinomial approach
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EM_multinomial(
  gd,
  tmat,
  tmat2,
  inits,
  beta_params,
  support_manual,
  exact,
  maxit,
  tol,
  conv_crit,
  manual,
  verbose,
  newmet,
  include_inf,
  checkMLE,
  checkMLE_tol,
  prob_tol,
  remove_bins,
  init_int = init_int,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EM_multinomial_+3A_gd">gd</code></td>
<td>
<p>A <code>data.frame</code> with the following named columns
</p>

<dl>
<dt><code>id</code>:</dt><dd><p>Subject idenitifier;</p>
</dd>
<dt><code>state</code>:</dt><dd><p>State at which the subject is observed at <code>time</code>;</p>
</dd>
<dt><code>time</code>:</dt><dd><p>Time at which the subject is observed;</p>
</dd>
</dl>
<p> The true transition time between states is then interval censored between the times.</p>
</td></tr>
<tr><td><code id="EM_multinomial_+3A_tmat">tmat</code></td>
<td>
<p>A transition matrix as created by <code>transMat</code></p>
</td></tr>
<tr><td><code id="EM_multinomial_+3A_inits">inits</code></td>
<td>
<p>Which distribution should be used to generate the initial estimates 
of the intensities in the EM algorithm. One of c(&quot;equalprob&quot;, &quot;unif&quot;, &quot;beta&quot;), 
with &quot;equalprob&quot; assigning 1/K to each intensity, with K the number of distinct 
observation times (<code>length(unique(gd[, "time"]))</code>). For &quot;unif&quot;, each 
intensity is sampled from the Unif[0,1] 
distribution and for &quot;beta&quot; each intensity is sampled from the Beta(a, b) distribution. 
If &quot;beta&quot; is chosen, the argument <code>beta_params</code> must be specified as a 
vector of length 2 containing the parameters of the beta distribution.
Default = &quot;equalprob&quot;.</p>
</td></tr>
<tr><td><code id="EM_multinomial_+3A_beta_params">beta_params</code></td>
<td>
<p>A vector of length 2 specifying the beta distribution parameters 
for initial distribution generation. First entry will be used as <code>shape1</code>
and second entry as <code>shape2</code>. See <code>help(rbeta)</code>. Only used if <code>inits = "beta"</code>.</p>
</td></tr>
<tr><td><code id="EM_multinomial_+3A_support_manual">support_manual</code></td>
<td>
<p>Used for specifying a manual support region for the transitions.
A list of length the number of transitions in <code>tmat</code>, 
each list element containing a data frame with 2 named columns L and R indicating the 
left and right values of the support intervals. When specified, all intensities 
outside of these intervals will be set to zero for the corresponding transitions.
Intensities set to zero cannot be changed by the EM algorithm. Will use inits = &quot;equalprob&quot;.</p>
</td></tr>
<tr><td><code id="EM_multinomial_+3A_exact">exact</code></td>
<td>
<p>Numeric vector indicating to which states transitions are observed at exact times.
Must coincide with the column number in <code>tmat</code>.</p>
</td></tr>
<tr><td><code id="EM_multinomial_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations.</p>
</td></tr>
<tr><td><code id="EM_multinomial_+3A_tol">tol</code></td>
<td>
<p>Tolerance of the procedure.</p>
</td></tr>
<tr><td><code id="EM_multinomial_+3A_conv_crit">conv_crit</code></td>
<td>
<p>Convergence criterion. Stops procedure when the difference 
in the chosen quantity between two consecutive iterations is smaller 
than the tolerance level <code>tol</code>. One of the following:
</p>

<dl>
<dt>&quot;haz&quot;</dt><dd><p>Stop when change in maximum estimated intensities (hazards) <code> &lt; tol</code>.</p>
</dd>
<dt>&quot;prob&quot;</dt><dd><p>Stop when change in estimated probabilities <code> &lt; tol</code>.</p>
</dd>
<dt>&quot;lik&quot;</dt><dd><p>Stop when change in observed-data likelihood <code> &lt; tol</code>.</p>
</dd>
</dl>
<p> Default is &quot;haz&quot;. The options &quot;haz&quot; and &quot;lik&quot; can be compared across different
<code>method</code>s, but &quot;prob&quot; is dependent on the chosen <code>method</code>. Most 
conservative (requiring most iterations) is &quot;prob&quot;, followed by &quot;haz&quot; and finally &quot;lik&quot;.</p>
</td></tr>
<tr><td><code id="EM_multinomial_+3A_manual">manual</code></td>
<td>
<p>Manually specify starting transition intensities?</p>
</td></tr>
<tr><td><code id="EM_multinomial_+3A_verbose">verbose</code></td>
<td>
<p>Should iteration messages be printed? Default is FALSE</p>
</td></tr>
<tr><td><code id="EM_multinomial_+3A_newmet">newmet</code></td>
<td>
<p>Should contributions after last observation time also be used 
in the likelihood? Default is FALSE.</p>
</td></tr>
<tr><td><code id="EM_multinomial_+3A_include_inf">include_inf</code></td>
<td>
<p>Should an additional bin from the largest observed time to 
infinity be included in the algorithm? Default is FALSE.</p>
</td></tr>
<tr><td><code id="EM_multinomial_+3A_checkmle">checkMLE</code></td>
<td>
<p>Should a check be performed whether the estimate has converged 
towards a true Maximum Likelihood Estimate? Default is TRUE.</p>
</td></tr>
<tr><td><code id="EM_multinomial_+3A_checkmle_tol">checkMLE_tol</code></td>
<td>
<p>Tolerance for checking whether the estimate has converged to MLE.
Whenever an estimated transition intensity is smaller than the tolerance, it is assumed 
to be zero.</p>
</td></tr>
<tr><td><code id="EM_multinomial_+3A_prob_tol">prob_tol</code></td>
<td>
<p>If an estimated probability is smaller than <code>prob_tol</code>, 
it will be set to zero during estimation. Default value is <code>tol/10</code>.</p>
</td></tr>
<tr><td><code id="EM_multinomial_+3A_remove_bins">remove_bins</code></td>
<td>
<p>Should a bin be removed during the algorithm if all
estimated intensities are zero for a single bin? Can improve 
computation speed for large data sets. Note that zero means the estimated intensities 
are smaller than <code>prob_tol</code>. Default is FALSE.</p>
</td></tr>
<tr><td><code id="EM_multinomial_+3A_init_int">init_int</code></td>
<td>
<p>A vector of length 2, with the first entry indicating what 
percentage of mass should be distributed over (second entry) what percentage 
of all first bins. Default is c(0, 0), in which case the argument is ignored.
This argument has no practical uses and only exists for demonstration purposes 
in the related article.</p>
</td></tr>
<tr><td><code id="EM_multinomial_+3A_...">...</code></td>
<td>
<p>Not used yet</p>
</td></tr>
</table>


<h3>References</h3>

<p>Michael G. Hudgens, On Nonparametric Maximum Likelihood Estimation with 
Interval Censoring and Left Truncation, Journal of the Royal Statistical Society 
Series B: Statistical Methodology, Volume 67, Issue 4, September 2005, Pages 573-587,
<a href="https://doi.org/10.1111/j.1467-9868.2005.00516.x">doi:10.1111/j.1467-9868.2005.00516.x</a>
</p>

<hr>
<h2 id='EM_poisson'>Helper function for npmsm()</h2><span id='topic+EM_poisson'></span>

<h3>Description</h3>

<p>For a general Markov chain multi-state model with interval censored 
transitions calculate the NPMLE using an EM algorithm with Poisson latent variable approach
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EM_poisson(
  gd,
  tmat,
  tmat2,
  inits,
  beta_params,
  support_manual,
  exact,
  maxit,
  tol,
  conv_crit,
  manual,
  verbose,
  newmet,
  include_inf,
  checkMLE,
  checkMLE_tol,
  prob_tol,
  remove_bins,
  init_int = init_int,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EM_poisson_+3A_gd">gd</code></td>
<td>
<p>A <code>data.frame</code> with the following named columns
</p>

<dl>
<dt><code>id</code>:</dt><dd><p>Subject idenitifier;</p>
</dd>
<dt><code>state</code>:</dt><dd><p>State at which the subject is observed at <code>time</code>;</p>
</dd>
<dt><code>time</code>:</dt><dd><p>Time at which the subject is observed;</p>
</dd>
</dl>
<p> The true transition time between states is then interval censored between the times.</p>
</td></tr>
<tr><td><code id="EM_poisson_+3A_tmat">tmat</code></td>
<td>
<p>A transition matrix as created by <code>transMat</code></p>
</td></tr>
<tr><td><code id="EM_poisson_+3A_inits">inits</code></td>
<td>
<p>Which distribution should be used to generate the initial estimates 
of the intensities in the EM algorithm. One of c(&quot;equalprob&quot;, &quot;unif&quot;, &quot;beta&quot;), 
with &quot;equalprob&quot; assigning 1/K to each intensity, with K the number of distinct 
observation times (<code>length(unique(gd[, "time"]))</code>). For &quot;unif&quot;, each 
intensity is sampled from the Unif[0,1] 
distribution and for &quot;beta&quot; each intensity is sampled from the Beta(a, b) distribution. 
If &quot;beta&quot; is chosen, the argument <code>beta_params</code> must be specified as a 
vector of length 2 containing the parameters of the beta distribution.
Default = &quot;equalprob&quot;.</p>
</td></tr>
<tr><td><code id="EM_poisson_+3A_beta_params">beta_params</code></td>
<td>
<p>A vector of length 2 specifying the beta distribution parameters 
for initial distribution generation. First entry will be used as <code>shape1</code>
and second entry as <code>shape2</code>. See <code>help(rbeta)</code>. Only used if <code>inits = "beta"</code>.</p>
</td></tr>
<tr><td><code id="EM_poisson_+3A_support_manual">support_manual</code></td>
<td>
<p>Used for specifying a manual support region for the transitions.
A list of length the number of transitions in <code>tmat</code>, 
each list element containing a data frame with 2 named columns L and R indicating the 
left and right values of the support intervals. When specified, all intensities 
outside of these intervals will be set to zero for the corresponding transitions.
Intensities set to zero cannot be changed by the EM algorithm. Will use inits = &quot;equalprob&quot;.</p>
</td></tr>
<tr><td><code id="EM_poisson_+3A_exact">exact</code></td>
<td>
<p>Numeric vector indicating to which states transitions are observed at exact times.
Must coincide with the column number in <code>tmat</code>.</p>
</td></tr>
<tr><td><code id="EM_poisson_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations.</p>
</td></tr>
<tr><td><code id="EM_poisson_+3A_tol">tol</code></td>
<td>
<p>Tolerance of the procedure.</p>
</td></tr>
<tr><td><code id="EM_poisson_+3A_conv_crit">conv_crit</code></td>
<td>
<p>Convergence criterion. Stops procedure when the difference 
in the chosen quantity between two consecutive iterations is smaller 
than the tolerance level <code>tol</code>. One of the following:
</p>

<dl>
<dt>&quot;haz&quot;</dt><dd><p>Stop when change in maximum estimated intensities (hazards) <code> &lt; tol</code>.</p>
</dd>
<dt>&quot;prob&quot;</dt><dd><p>Stop when change in estimated probabilities <code> &lt; tol</code>.</p>
</dd>
<dt>&quot;lik&quot;</dt><dd><p>Stop when change in observed-data likelihood <code> &lt; tol</code>.</p>
</dd>
</dl>
<p> Default is &quot;haz&quot;. The options &quot;haz&quot; and &quot;lik&quot; can be compared across different
<code>method</code>s, but &quot;prob&quot; is dependent on the chosen <code>method</code>. Most 
conservative (requiring most iterations) is &quot;prob&quot;, followed by &quot;haz&quot; and finally &quot;lik&quot;.</p>
</td></tr>
<tr><td><code id="EM_poisson_+3A_manual">manual</code></td>
<td>
<p>Manually specify starting transition intensities?</p>
</td></tr>
<tr><td><code id="EM_poisson_+3A_verbose">verbose</code></td>
<td>
<p>Should iteration messages be printed? Default is FALSE</p>
</td></tr>
<tr><td><code id="EM_poisson_+3A_newmet">newmet</code></td>
<td>
<p>Should contributions after last observation time also be used 
in the likelihood? Default is FALSE.</p>
</td></tr>
<tr><td><code id="EM_poisson_+3A_include_inf">include_inf</code></td>
<td>
<p>Should an additional bin from the largest observed time to 
infinity be included in the algorithm? Default is FALSE.</p>
</td></tr>
<tr><td><code id="EM_poisson_+3A_checkmle">checkMLE</code></td>
<td>
<p>Should a check be performed whether the estimate has converged 
towards a true Maximum Likelihood Estimate? Default is TRUE.</p>
</td></tr>
<tr><td><code id="EM_poisson_+3A_checkmle_tol">checkMLE_tol</code></td>
<td>
<p>Tolerance for checking whether the estimate has converged to MLE.
Whenever an estimated transition intensity is smaller than the tolerance, it is assumed 
to be zero.</p>
</td></tr>
<tr><td><code id="EM_poisson_+3A_prob_tol">prob_tol</code></td>
<td>
<p>If an estimated probability is smaller than <code>prob_tol</code>, 
it will be set to zero during estimation. Default value is <code>tol/10</code>.</p>
</td></tr>
<tr><td><code id="EM_poisson_+3A_remove_bins">remove_bins</code></td>
<td>
<p>Should a bin be removed during the algorithm if all
estimated intensities are zero for a single bin? Can improve 
computation speed for large data sets. Note that zero means the estimated intensities 
are smaller than <code>prob_tol</code>. Default is FALSE.</p>
</td></tr>
<tr><td><code id="EM_poisson_+3A_init_int">init_int</code></td>
<td>
<p>A vector of length 2, with the first entry indicating what 
percentage of mass should be distributed over (second entry) what percentage 
of all first bins. Default is c(0, 0), in which case the argument is ignored.
This argument has no practical uses and only exists for demonstration purposes 
in the related article.</p>
</td></tr>
<tr><td><code id="EM_poisson_+3A_...">...</code></td>
<td>
<p>Not used yet.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Y. Gu, D. Zeng, G. Heiss, and D. Y. Lin, 
Maximum likelihood estimation for semiparametric regression models with 
interval-censored multistate data, Biometrika, Nov. 2023, <a href="https://doi.org/10.1093/biomet/asad073">doi:10.1093/biomet/asad073</a>
</p>

<hr>
<h2 id='EM_solver'>EM solver for extended illness-death model (Frydman 1995)</h2><span id='topic+EM_solver'></span>

<h3>Description</h3>

<p>Solves for the cdf and transition intensities using the EM 
algorithm described in Frydman (1995).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EM_solver(data_idx, supportMSM, z, lambda, tol = 1e-08)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EM_solver_+3A_data_idx">data_idx</code></td>
<td>
<p>List containing data, outputted from <code><a href="#topic+msm_frydman">msm_frydman</a></code></p>
</td></tr>
<tr><td><code id="EM_solver_+3A_supportmsm">supportMSM</code></td>
<td>
<p>List containing data on the support of the 1-&gt;2 transition,
output from supportMSM()</p>
</td></tr>
<tr><td><code id="EM_solver_+3A_z">z</code></td>
<td>
<p>Initial values for <code class="reqn">F_{12}</code> and <code class="reqn">F_{13}</code>, used to initiate the EM alg.</p>
</td></tr>
<tr><td><code id="EM_solver_+3A_lambda">lambda</code></td>
<td>
<p>Initial values for <code class="reqn">\Lambda_{23}</code>, used to initiate the EM alg.</p>
</td></tr>
<tr><td><code id="EM_solver_+3A_tol">tol</code></td>
<td>
<p>Tolerance of the EM algorithm. When the change in sum(abs(z)) and 
sum(abs(lambda)) no longer exceeds tol, the algorithm stops.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>beta: Indicator whether Q subset A
mu: Value used in the EM algorithm, see Frydman (1995) and Notes.
I_Q_in_Lm_tn_star: Indicator whether Q is in [L_m, t_n^*]
gamma: Value used in the EM algorithm, see Frydman (1995) and Notes.
alpha: Indicator whether Q subset [s_j, Infinity)
mu_overline: Value used in the EM algorithm, see Frydman (1995) and Notes.
lambda: Intensity for the 2-&gt;3 transition
z: Mass assigned to the 1-&gt;2 and 1-&gt;3 transitions
iter: Number of iterations required for convergence
</p>


<h3>References</h3>

<p>Frydman, H. (1995). Nonparametric Estimation of a Markov 
'Illness-Death' Process from Interval- Censored Observations, with 
Application to Diabetes Survival Data. Biometrika, 82(4), 773-789. 
<a href="https://doi.org/10.2307/2337344">doi:10.2307/2337344</a>
</p>

<hr>
<h2 id='estimate_support_msm'>Estimate the support of a general Markov interval-censored Multi-state model without 
loops.</h2><span id='topic+estimate_support_msm'></span>

<h3>Description</h3>

<p>Given a realisation of a multi-state model, estimate the support 
of the different transitions possible in that MSM. The estimation is performed 
by viewing each possible state in a competing risks setting and applying the 
result of Hudgens (2001) to determine the support and left-truncation 
intervals and Hudgens (2005) to check whether a solution is possible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_support_msm(gd, tmat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimate_support_msm_+3A_gd">gd</code></td>
<td>
<p>A <code>data.frame</code> with the following named columns
</p>

<dl>
<dt><code>id</code>:</dt><dd><p>Subject idenitifier;</p>
</dd>
<dt><code>state</code>:</dt><dd><p>State at which the subject is observed at <code>time</code>;</p>
</dd>
<dt><code>time</code>:</dt><dd><p>Time at which the subject is observed;</p>
</dd>
</dl>
<p> The true transition time between states is then interval censored between the times.</p>
</td></tr>
<tr><td><code id="estimate_support_msm_+3A_tmat">tmat</code></td>
<td>
<p>A transition matrix as created by <code>transMat</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>TODO
</p>


<h3>References</h3>

<p>Michael G. Hudgens, On Nonparametric Maximum Likelihood Estimation with 
Interval Censoring and Left Truncation, Journal of the Royal Statistical Society 
Series B: Statistical Methodology, Volume 67, Issue 4, September 2005, Pages 573-587,
<a href="https://doi.org/10.1111/j.1467-9868.2005.00516.x">doi:10.1111/j.1467-9868.2005.00516.x</a>
</p>
<p>M. G. Hudgens, G. A. Satten, and I. M. Longini, 
Nonparametric Maximum Likelihood Estimation for Competing Risks Survival Data
Subject to Interval Censoring and Truncation, Biometrics, vol. 57, no. 1, 
Pages 74-80, March 2001, <a href="https://doi.org/10.1111/j.0006-341x.2001.00074.x">doi:10.1111/j.0006-341x.2001.00074.x</a>
</p>

<hr>
<h2 id='evalstep'>Sample from a markov chain multi state model with exactly observed transition times</h2><span id='topic+evalstep'></span>

<h3>Description</h3>

<p>Given a markov chain multi state model with exactly observed transition times,
sample from this chain at the observation times, giving interval censored observations (panel data).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evalstep(time, stepf, newtime, subst = -Inf, to.data.frame = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="evalstep_+3A_time">time</code></td>
<td>
<p>Times at which a transition occurs</p>
</td></tr>
<tr><td><code id="evalstep_+3A_stepf">stepf</code></td>
<td>
<p>States at which the chain is in at <code>time</code>s</p>
</td></tr>
<tr><td><code id="evalstep_+3A_newtime">newtime</code></td>
<td>
<p>Observation times of the chain, to create observed states</p>
</td></tr>
<tr><td><code id="evalstep_+3A_subst">subst</code></td>
<td>
<p>State to return if observation time is before first transition time. Default = -Inf.</p>
</td></tr>
<tr><td><code id="evalstep_+3A_to.data.frame">to.data.frame</code></td>
<td>
<p>Should the result be returned as a <code>data.frame</code>?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric <code>vector</code> or <code>data.frame</code> (if <code>to.data.frame = TRUE</code>)
containing either the observed states or  the named columns <code>newtime</code> and 
<code>res</code>, representing the observation times and observed states.
</p>


<h3>Author(s)</h3>

<p>Hein Putter
</p>


<h3>Examples</h3>

<pre><code class='language-R'>obs_states &lt;- evalstep(time = seq(0, 20, 2), stepf = sample(1:9, 11, replace = TRUE),
                newtime = c(-1, 1, 7, 9, 19))
obs_states
</code></pre>

<hr>
<h2 id='existenceNPMLE'>Check existence of NPMLE</h2><span id='topic+existenceNPMLE'></span>

<h3>Description</h3>

<p>Using Theorem 1 from Hudgens (2005) we can check whether an 
NPMLE exists. This procedure is implemented in this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>existenceNPMLE(intervals, supportdf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="existenceNPMLE_+3A_intervals">intervals</code></td>
<td>
<p>A data.frame with 4 columns containing half-open intervals (left open, right closed)
and an indicator whether the interval results from a censored transition
or truncation:
</p>

<dl>
<dt><code>L</code>:</dt><dd><p>Left side of interval;</p>
</dd>
<dt><code>R</code>:</dt><dd><p>Right side of interval;</p>
</dd>
<dt><code>cens</code>:</dt><dd><p>Indicator whether interval resulted from censoring or truncation
(1 = censoring, 0 = truncation);</p>
</dd>
<dt><code>id</code>:</dt><dd><p>(required) Identifier for the observation this interval belongs to (numeric/integer);</p>
</dd>
</dl>
<p> Note that the truncation intervals need to be in the form (N, Inf] with N a numeric value.</p>
</td></tr>
<tr><td><code id="existenceNPMLE_+3A_supportdf">supportdf</code></td>
<td>
<p>A data from containing 2 columns indicating the support intervals:
</p>

<dl>
<dt><code>L</code>:</dt><dd><p>Left side of interval;</p>
</dd>
<dt><code>R</code>:</dt><dd><p>Right side of interval;</p>
</dd>
</dl>
</td></tr>
</table>

<hr>
<h2 id='get_trans_intervals'>Get transition intervals from specified data</h2><span id='topic+get_trans_intervals'></span>

<h3>Description</h3>

<p>Given a sample from a multi-state model, summarize the transitions 
that have been observed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_trans_intervals(gd, tmat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_trans_intervals_+3A_gd">gd</code></td>
<td>
<p>A <code>data.frame</code> with the following named columns
</p>

<dl>
<dt><code>id</code>:</dt><dd><p>Subject idenitifier;</p>
</dd>
<dt><code>state</code>:</dt><dd><p>State at which the subject is observed at <code>time</code>;</p>
</dd>
<dt><code>time</code>:</dt><dd><p>Time at which the subject is observed;</p>
</dd>
</dl>
<p> The true transition time between states is then interval censored between the times.</p>
</td></tr>
<tr><td><code id="get_trans_intervals_+3A_tmat">tmat</code></td>
<td>
<p>A transition matrix as created by <code>transMat</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with the following named columns
</p>

<dl>
<dt><code>entry_time</code>:</dt><dd><p>Time of entry into &quot;from&quot; state;</p>
</dd>
<dt><code>time_from</code>:</dt><dd><p>Last time subject(id) was seen in state &quot;from&quot;;</p>
</dd>
<dt><code>time_to</code>:</dt><dd><p>First time subject(id) was seen in state &quot;to&quot;;</p>
</dd>
<dt><code>from</code>:</dt><dd><p>State from which a transition was observed;</p>
</dd>
<dt><code>to</code>:</dt><dd><p>State to which the transition was observed;</p>
</dd>
<dt><code>id</code>:</dt><dd><p>Subject identifier;</p>
</dd>
</dl>
<p> For right-censored observations, entry_time denotes the first time
seen in the censored state, time_from the last time seen in the censored state,
time_to is <code>Inf</code>, from the censored state and to is <code>NA</code>.
</p>

<hr>
<h2 id='graphfromIntervals'>Construct Graph from censoring/truncation intervals</h2><span id='topic+graphfromIntervals'></span>

<h3>Description</h3>

<p>Given intervals, construct a graph containing vertices 
representing these intervals and edges between the vertices if the intervals 
intersect. See Hudgens (2005).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graphfromIntervals(intervals)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graphfromIntervals_+3A_intervals">intervals</code></td>
<td>
<p>A data.frame with 3 columns containing half-open intervals (left open, right closed)
and an indicator whether the interval results from a censored transition
or truncation:
#'</p>

<dl>
<dt><code>L</code>:</dt><dd><p>Left side of interval;</p>
</dd>
<dt><code>R</code>:</dt><dd><p>Right side of interval;</p>
</dd>
<dt><code>cens</code>:</dt><dd><p>Indicator whether interval resulted from censoring or truncation
(1 = censoring, 0 = truncation);</p>
</dd>
</dl>
<p> Note that the truncation intervals need to be in the form (N, Inf] with N a numeric value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an <code>'igraph'</code> object containing the graph with vertices 
representing the intervals and edges between the vertices if the intervals 
intersect. The vertices will be named accordingly, starting with a 'T' when 
representing a truncation interval and 'C' when representing a censoring 
interval.
</p>


<h3>References</h3>

<p>Michael G. Hudgens, On Nonparametric Maximum Likelihood Estimation with 
Interval Censoring and Left Truncation, Journal of the Royal Statistical Society 
Series B: Statistical Methodology, Volume 67, Issue 4, September 2005, Pages 573-587,
<a href="https://doi.org/10.1111/j.1467-9868.2005.00516.x">doi:10.1111/j.1467-9868.2005.00516.x</a>
</p>

<hr>
<h2 id='interpol_msfit'>Given a <code>msfit</code> object, linearly interpolate the cumulative hazard 
taking into account the support sets for <code>msfit</code> objects.</h2><span id='topic+interpol_msfit'></span>

<h3>Description</h3>

<p>After using this function, use probtrans to get interpolated 
transition probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interpol_msfit(msfit, times)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interpol_msfit_+3A_msfit">msfit</code></td>
<td>
<p>A <code>msfit</code> object.</p>
</td></tr>
<tr><td><code id="interpol_msfit_+3A_times">times</code></td>
<td>
<p>Times at which to interpolate the <code>msfit</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>msfit</code> object containing the interpolated hazards
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mstate)
tmat &lt;- trans.illdeath()
times &lt;- seq(0, 5, 0.1)
ms_fit &lt;- list(Haz = data.frame(time = rep(times, 3),
                                Haz = c(replicate(3, cumsum(runif(length(times), 0, 0.02)))),
                                trans = rep(1:3, each = length(times))),
               trans = tmat)
class(ms_fit) &lt;- "msfit"

ms_fit_interpolated &lt;- interpol_msfit(ms_fit, seq(0, 5, 0.01))

</code></pre>

<hr>
<h2 id='msm_frydman'>Determine NPMLE for Multi State illness death Markov model using Frydman (1995)</h2><span id='topic+msm_frydman'></span>

<h3>Description</h3>

<p>Determine NPMLE for Multi State illness death Markov model using Frydman (1995)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msm_frydman(data, tol = 1e-08)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="msm_frydman_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> containing the columns named:
</p>

<dl>
<dt><code>delta</code>:</dt><dd><p>Did a transition from 1 -&gt; 2 occur? (binary: 0 = no, 1 = yes); 
In the left-truncated case, delta = 2 indicates initially observed in state 2.</p>
</dd>
<dt><code>Delta</code>:</dt><dd><p>Was the transition to state 3 observed? (binary: 0 = no, 1 = yes);</p>
</dd>
<dt><code>L</code>:</dt><dd><p>Left timepoint of interval censored transition to state 2 (numeric);</p>
</dd>
<dt><code>R</code>:</dt><dd><p>Right timepoint of interval censored transition to state 2 (numeric);</p>
</dd>
<dt><code>time</code>:</dt><dd><p>Time of event (transition to 3) or right-censoring in state 2 (numeric);</p>
</dd>
<dt><code>trunc</code>:</dt><dd><p>(optional) Left-truncation time (numeric); Only used for entries with delta = 2.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="msm_frydman_+3A_tol">tol</code></td>
<td>
<p>Tolerance of the EM algorithm. Algorithm will stop when the absolute difference 
between current mass estimates and new estimates is smaller than the tolerance</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For an illness death model (1 = healthy, 2 = ill, 3 = dead) estimate 
the NPMLE in the following form:
</p>

<dl>
<dt><code>F12</code>:</dt><dd><p>Cumulative distribution function of 1-&gt;2 transition;</p>
</dd>
<dt><code>F13</code>:</dt><dd><p>Cumulative distribution function of 1-&gt;3 transition;</p>
</dd>
<dt><code>Lambda23</code>:</dt><dd><p>Cumulative intensity of 2-&gt;3 transition;</p>
</dd>
</dl>



<h3>Value</h3>

<p>A list with the following entries:
</p>

<dl>
<dt><code>data_idx</code>: </dt><dd><p>A list containing the data used for the fit (<code>matdata</code>),
the indices for which group a subject belongs to (<code>GroupX_idx</code>), some computational 
parameters (see Frydman(1995)) and the unique failure times of the 2-&gt;3 and 1-&gt;3
transitions respectively in <code>t_n_star</code> and <code>e_k_star</code>;</p>
</dd>
<dt><code>supportMSM</code>: </dt><dd><p>A list containing all transition intervals in <code>A</code> and
the theoretical support intervals in <code>Q_mat</code>;</p>
</dd>
<dt><code>z_lambda</code>: </dt><dd><p>Computational quantities, see Frydman(1995);</p>
</dd>
<dt><code>cdf</code>: </dt><dd><p>A list of functions that allow to recover the cdf for 
the 1-&gt;3 (<code>F13</code>) and 1-&gt;2 (<code>F12</code>) transition and the cumulative hazard 
for the 2-&gt;3 (<code>Lambda23</code>) transition.;</p>
</dd>
</dl>



<h3>References</h3>

<p>Frydman, H. (1995). Nonparametric Estimation of a Markov 
'Illness-Death' Process from Interval- Censored Observations, with 
Application to Diabetes Survival Data. Biometrika, 82(4), 773-789. 
<a href="https://doi.org/10.2307/2337344">doi:10.2307/2337344</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- data.frame(delta = c(0, 0, 1, 1), Delta = c(0, 1, 0, 1),
                   L = c(NA, NA, 1, 1.5), R = c(NA, 3, 2, 3),
                   time = c(4, 5, 6, 7))

mod_frydman &lt;- msm_frydman(data)
visualise_data(data, mod_frydman)


</code></pre>

<hr>
<h2 id='npmsm'>NPMLE for general multi-state model with interval censored transitions</h2><span id='topic+npmsm'></span>

<h3>Description</h3>

<p>For a general Markov chain multi-state model with interval censored 
transitions calculate the NPMLE of the transition intensities. The estimates 
are returned as an <code><a href="mstate.html#topic+msfit">msfit</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>npmsm(
  gd,
  tmat,
  method = c("multinomial", "poisson"),
  inits = c("equalprob", "homogeneous", "unif", "beta"),
  beta_params,
  support_manual,
  exact,
  maxit = 100,
  tol = 1e-04,
  conv_crit = c("haz", "prob", "lik"),
  verbose = FALSE,
  manual = FALSE,
  newmet = FALSE,
  include_inf = FALSE,
  checkMLE = TRUE,
  checkMLE_tol = 1e-04,
  prob_tol = tol/10,
  remove_redundant = TRUE,
  remove_bins = FALSE,
  estimateSupport = FALSE,
  init_int = c(0, 0),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="npmsm_+3A_gd">gd</code></td>
<td>
<p>A <code>data.frame</code> with the following named columns
</p>

<dl>
<dt><code>id</code>:</dt><dd><p>Subject idenitifier;</p>
</dd>
<dt><code>state</code>:</dt><dd><p>State at which the subject is observed at <code>time</code>;</p>
</dd>
<dt><code>time</code>:</dt><dd><p>Time at which the subject is observed;</p>
</dd>
</dl>
<p> The true transition time between states is then interval censored between the times.</p>
</td></tr>
<tr><td><code id="npmsm_+3A_tmat">tmat</code></td>
<td>
<p>A transition matrix as created by <code><a href="mstate.html#topic+transMat">transMat</a></code></p>
</td></tr>
<tr><td><code id="npmsm_+3A_method">method</code></td>
<td>
<p>Which method should be used for the EM algorithm. Choices are 
<code>c("multinomial", "poisson")</code>, with multinomial the default. Multinomial 
will use the EM algorithm described in Gomon and Putter (2024) and Poisson
will use the EM algorithm described in Gu et al. (2023).</p>
</td></tr>
<tr><td><code id="npmsm_+3A_inits">inits</code></td>
<td>
<p>Which distribution should be used to generate the initial estimates 
of the intensities in the EM algorithm. One of c(&quot;equalprob&quot;, &quot;unif&quot;, &quot;beta&quot;), 
with &quot;equalprob&quot; assigning 1/K to each intensity, with K the number of distinct 
observation times (<code>length(unique(gd[, "time"]))</code>). For &quot;unif&quot;, each 
intensity is sampled from the Unif[0,1] 
distribution and for &quot;beta&quot; each intensity is sampled from the Beta(a, b) distribution. 
If &quot;beta&quot; is chosen, the argument <code>beta_params</code> must be specified as a 
vector of length 2 containing the parameters of the beta distribution.
Default = &quot;equalprob&quot;.</p>
</td></tr>
<tr><td><code id="npmsm_+3A_beta_params">beta_params</code></td>
<td>
<p>A vector of length 2 specifying the beta distribution parameters 
for initial distribution generation. First entry will be used as <code>shape1</code>
and second entry as <code>shape2</code>. See <code>help(rbeta)</code>. Only used if <code>inits = "beta"</code>.</p>
</td></tr>
<tr><td><code id="npmsm_+3A_support_manual">support_manual</code></td>
<td>
<p>Used for specifying a manual support region for the transitions.
A list of length the number of transitions in <code>tmat</code>, 
each list element containing a data frame with 2 named columns L and R indicating the 
left and right values of the support intervals. When specified, all intensities 
outside of these intervals will be set to zero for the corresponding transitions.
Intensities set to zero cannot be changed by the EM algorithm. Will use inits = &quot;equalprob&quot;.</p>
</td></tr>
<tr><td><code id="npmsm_+3A_exact">exact</code></td>
<td>
<p>Numeric vector indicating to which states transitions are observed at exact times.
Must coincide with the column number in <code>tmat</code>.</p>
</td></tr>
<tr><td><code id="npmsm_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations. Default = 100.</p>
</td></tr>
<tr><td><code id="npmsm_+3A_tol">tol</code></td>
<td>
<p>Tolerance of the convergence procedure. A change in the value of 
<code>conv_crit</code> in an iteration of less than <code>tol</code> will make the procedure stop.</p>
</td></tr>
<tr><td><code id="npmsm_+3A_conv_crit">conv_crit</code></td>
<td>
<p>Convergence criterion. Stops procedure when the difference 
in the chosen quantity between two consecutive iterations is smaller 
than the tolerance level <code>tol</code>. One of the following:
</p>

<dl>
<dt>&quot;haz&quot;</dt><dd><p>Stop when change in maximum estimated intensities (hazards) <code> &lt; tol</code>.</p>
</dd>
<dt>&quot;prob&quot;</dt><dd><p>Stop when change in estimated probabilities <code> &lt; tol</code>.</p>
</dd>
<dt>&quot;lik&quot;</dt><dd><p>Stop when change in observed-data likelihood <code> &lt; tol</code>.</p>
</dd>
</dl>
<p> Default is &quot;haz&quot;. The options &quot;haz&quot; and &quot;lik&quot; can be compared across different
<code>method</code>s, but &quot;prob&quot; is dependent on the chosen <code>method</code>. Most 
conservative (requiring most iterations) is &quot;prob&quot;, followed by &quot;haz&quot; and finally &quot;lik&quot;.</p>
</td></tr>
<tr><td><code id="npmsm_+3A_verbose">verbose</code></td>
<td>
<p>Should iteration messages be printed? Default is FALSE</p>
</td></tr>
<tr><td><code id="npmsm_+3A_manual">manual</code></td>
<td>
<p>Manually specify starting transition intensities? If <code>TRUE</code>,
the transition intensity for each bin for each transition must be entered manually.
DO NOT USE for large data sets, and in general it is not adviced to use this.</p>
</td></tr>
<tr><td><code id="npmsm_+3A_newmet">newmet</code></td>
<td>
<p>Should contributions after last observation time also be used 
in the likelihood? Default is FALSE.</p>
</td></tr>
<tr><td><code id="npmsm_+3A_include_inf">include_inf</code></td>
<td>
<p>Should an additional bin from the largest observed time to 
infinity be included in the algorithm? Default is FALSE.</p>
</td></tr>
<tr><td><code id="npmsm_+3A_checkmle">checkMLE</code></td>
<td>
<p>Should a check be performed whether the estimate has converged 
towards a true Maximum Likelihood Estimate? This is done by comparing 
the reduced gradient to the value of <code>checkMLE_tol</code>. Default is TRUE.</p>
</td></tr>
<tr><td><code id="npmsm_+3A_checkmle_tol">checkMLE_tol</code></td>
<td>
<p>Tolerance for checking whether the estimate has converged to MLE.
Whenever an estimated transition intensity is smaller than <code>prob_tol</code>, it is assumed 
to be zero and its reduced gradient is not considered for determining whether 
the NPMLE has been reached. Default = <code>1e-4</code>.</p>
</td></tr>
<tr><td><code id="npmsm_+3A_prob_tol">prob_tol</code></td>
<td>
<p>If an estimated probability is smaller than <code>prob_tol</code>, 
it will be set to zero during estimation. Default value is <code>tol/10</code>.</p>
</td></tr>
<tr><td><code id="npmsm_+3A_remove_redundant">remove_redundant</code></td>
<td>
<p>Should redundant observations be removed before running 
the algorithm? An observation is redundant when the same state has been observed 
more than 3 times consecutively, or if it is a repeat observation of an 
absorbing state. Default is TRUE.</p>
</td></tr>
<tr><td><code id="npmsm_+3A_remove_bins">remove_bins</code></td>
<td>
<p>Should a bin be removed during the algorithm if all
estimated intensities are zero for a single bin? Can improve 
computation speed for large data sets. Note that zero means the estimated intensities 
are smaller than <code>prob_tol</code>. Default is FALSE.</p>
</td></tr>
<tr><td><code id="npmsm_+3A_estimatesupport">estimateSupport</code></td>
<td>
<p>Should the support of the transitions be estimated using 
the result of Hudgens (2005)? Currently produces incorrect support sets - 
DO NOT USE. Default = <code>FALSE</code></p>
</td></tr>
<tr><td><code id="npmsm_+3A_init_int">init_int</code></td>
<td>
<p>A vector of length 2, with the first entry indicating what 
percentage of mass should be distributed over (second entry) what percentage 
of all first bins. Default is c(0, 0), in which case the argument is ignored.
This argument has no practical uses and only exists for demonstration purposes 
in the related article.</p>
</td></tr>
<tr><td><code id="npmsm_+3A_...">...</code></td>
<td>
<p>Further arguments to <code><a href="#topic+estimate_support_msm">estimate_support_msm</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Denote the unique observation times in the data as <code class="reqn">0 = \tau_0, \tau_1, \ldots, \tau_K</code>
Let <code class="reqn">g, h \in H</code> denote the possible states in the model and <code class="reqn">X(t)</code> the state of the process at time t.
</p>
<p>Then this function can be used to estimate the transition intensities 
<code class="reqn">\alpha_{gh}^k = \alpha_{gh}(\tau_k)</code>. 
</p>
<p>Having obtained these estimated, it is possible to recover the transition probabilities 
<code class="reqn">\mathbf{P}(X(t) = h | X(s) = g)</code> for <code class="reqn">t &gt; s</code> using 
the <code><a href="#topic+transprob">transprob</a></code> functions.
</p>


<h3>Value</h3>

<p>A list with the following entries:
</p>

<dl>
<dt><code>A</code>: </dt><dd><p>A list of class <code><a href="mstate.html#topic+msfit">msfit</a></code> containing 
the cumulative intensities for each transition and the transition matrix used;</p>
</dd>
<dt><code>Ainit</code>: </dt><dd><p>Initial intensities, in an object of class <code><a href="mstate.html#topic+msfit">msfit</a></code>;</p>
</dd>
<dt><code>gd</code>: </dt><dd><p>Data used for the estimation procedure;</p>
</dd>
<dt><code>ll</code>: </dt><dd><p>Log-likelihood value of the procedure at the last iteration;</p>
</dd>
<dt><code>delta</code>: </dt><dd><p>Change in log-likelihood value at the last iteration;</p>
</dd>
<dt><code>it</code>: </dt><dd><p>Number of iterations of the procedure;</p>
</dd>
<dt><code>taus</code>: </dt><dd><p>Unique time points of the data, the cumulative intensity
only makes jumps at these time points.;</p>
</dd>
<dt><code>tmat</code>: </dt><dd><p>The transition matrix used, see <code><a href="mstate.html#topic+transMat">transMat</a></code>;</p>
</dd>
<dt><code>tmat2</code>: </dt><dd><p>A summary of the transitions in the model, see <code><a href="mstate.html#topic+to.trans2">to.trans2</a></code>;</p>
</dd>
<dt><code>ll_history</code>: </dt><dd><p>The log-likelihood value at every iteration of the procedure;</p>
</dd>
<dt><code>KKT_violated</code>: </dt><dd><p>How often were KKT conditions violated during
maximisation of the likelihood? In other words, how often did we hit the optimization 
boundary during the procedure?;</p>
</dd>
<dt><code>min_time</code>: </dt><dd><p>The smallest time of an observation in the used data. 
Note that the smallest time in the data is used as zero reference;</p>
</dd>
<dt><code>reduced_gradient</code>: </dt><dd><p>The reduced gradient at the last iteration.
Rows indicate the transitions and columns the unique observation times;</p>
</dd>
<dt><code>isMLE</code>: </dt><dd><p>Has the procedure converged to the NPMLE? Checked 
using <code>checkMLE_tol</code>;</p>
</dd>
<dt><code>langrangemultiplier</code>: </dt><dd><p>The lagrange multipliers at the last iteration;</p>
</dd>
<dt><code>aghmat</code>: </dt><dd><p>A matrix representation of the transition intensities in <code>A</code>.
Rows represent transitions and columns unique observation times;</p>
</dd>
<dt><code>Ygk</code>: </dt><dd><p>The summed at-risk indicator for all subjects in the data at the last iteration.
Rows represent transitions and columns unique observation times;</p>
</dd>
<dt><code>Dmk</code>: </dt><dd><p>The summed probability of making a transition for all subjects at the last iteration.
Rows represent transitions and columns unique observation times;</p>
</dd>
<dt><code>method</code>: </dt><dd><p>Method used for the optimization procedure;</p>
</dd>
<dt><code>maxit</code>: </dt><dd><p>Maximum number of allowed iterations;</p>
</dd>
<dt><code>tol</code>: </dt><dd><p>Tolerance of the convergence procedure;</p>
</dd>
<dt><code>conv_crit</code>: </dt><dd><p>Convergence criterion of the procedure;</p>
</dd>
<dt><code>checkMLE</code>: </dt><dd><p>Was the reduced gradient checked at the last iteration to determine convergence?;</p>
</dd>
<dt><code>checkMLE_tol</code>: </dt><dd><p>The tolerance of the checkMLE procedure;</p>
</dd>
<dt><code>prob_tol</code>: </dt><dd><p>Tolerance for probabilities to be set to zero;</p>
</dd>
<dt><code>remove_redundant</code>: </dt><dd><p>Were redundant observations removed before performing the procedure?;</p>
</dd>
</dl>



<h3>References</h3>

<p>D. Gomon and H. Putter, Non-parametric estimation of transition intensities 
in interval censored Markov multi-state models without loops,
arXiv, 2024, <a href="https://doi.org/10.48550/arXiv.2409.07176">doi:10.48550/arXiv.2409.07176</a>
</p>
<p>Y. Gu, D. Zeng, G. Heiss, and D. Y. Lin, 
Maximum likelihood estimation for semiparametric regression models with 
interval-censored multistate data, Biometrika, Nov. 2023, <a href="https://doi.org/10.1093/biomet/asad073">doi:10.1093/biomet/asad073</a>
</p>
<p>Michael G. Hudgens, On Nonparametric Maximum Likelihood Estimation with 
Interval Censoring and Left Truncation, Journal of the Royal Statistical Society 
Series B: Statistical Methodology, Volume 67, Issue 4, September 2005, Pages 573-587,
<a href="https://doi.org/10.1111/j.1467-9868.2005.00516.x">doi:10.1111/j.1467-9868.2005.00516.x</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+transprob">transprob</a></code> for calculating transition probabilities,
<code><a href="#topic+plot.npmsm">plot.npmsm</a></code> for plotting the cumulative intensities, 
<code><a href="#topic+print.npmsm">print.npmsm</a></code> for printing some output summaries,
<code><a href="#topic+visualise_msm">visualise_msm</a></code> for visualising data,
<code><a href="mstate.html#topic+msfit">msfit</a></code> for details on the output object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create transition matrix using mstate functionality: illness-death
if(require(mstate)){
  tmat &lt;- mstate::trans.illdeath()
}

#Write a function for evaluation times: observe at 0 and uniform inter-observation times.
eval_times &lt;- function(n_obs, stop_time){
  cumsum( c( 0,  runif( n_obs-1, 0, 2*(stop_time-4)/(n_obs-1) ) ) )
}

#Use built_in function to simulate illness-death data
#from Weibull distributions for each transition
sim_dat &lt;- sim_id_weib(n = 50, n_obs = 6, stop_time = 15, eval_times = eval_times,
start_state = "stable", shape = c(0.5, 0.5, 2), scale = c(5, 10, 10/gamma(1.5)))

tmat &lt;- mstate::trans.illdeath()

#Fit the model using method = "multinomial"
mod_fit &lt;- npmsm(gd = sim_dat, tmat = tmat, tol = 1e-2)

#Plot the cumulative intensities for each transition
plot(mod_fit)

</code></pre>

<hr>
<h2 id='plot_probtrans'>Plot the transition probabilities for a fitted <code>npmsm</code> model</h2><span id='topic+plot_probtrans'></span>

<h3>Description</h3>

<p>For a fitted <code>npmsm</code> model plot the transition probabilities
from a certain state for all possible (direct and indirect) transitions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_probtrans(
  npmsmlist,
  from = NULL,
  to = NULL,
  transitions = NULL,
  landmark,
  interpolate = TRUE,
  facet = TRUE,
  times_interpol = NULL,
  c.legend = TRUE,
  c.names = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_probtrans_+3A_npmsmlist">npmsmlist</code></td>
<td>
<p>An &quot;npmsm&quot; object or a list containing multiple &quot;npmsm&quot; objects</p>
</td></tr>
<tr><td><code id="plot_probtrans_+3A_from">from</code></td>
<td>
<p>A numeric value indicating the state from which we consider the 
transition probabilities. Default is NULL, meaning we consider transition probabilities 
from all states from which a direct transition is possible.</p>
</td></tr>
<tr><td><code id="plot_probtrans_+3A_to">to</code></td>
<td>
<p>A numeric vector indicating to which states we consider the transition 
probabilities. Only states that can be reached from the <code>"from"</code> state are considered.</p>
</td></tr>
<tr><td><code id="plot_probtrans_+3A_transitions">transitions</code></td>
<td>
<p>A numeric vector indicating which transitions to consider (plot). 
Can only be used if <code>"from"</code> is not specified, as it only works for direct transitions.</p>
</td></tr>
<tr><td><code id="plot_probtrans_+3A_landmark">landmark</code></td>
<td>
<p>A landmark time indicating from which time on survival should be determined.
If missing, the smallest between the time in the first &quot;npmsm&quot; object or 0 will be used.</p>
</td></tr>
<tr><td><code id="plot_probtrans_+3A_interpolate">interpolate</code></td>
<td>
<p>Should the cumulative hazard be linearly interpolated before 
determining transition probabilities? Default is TRUE.</p>
</td></tr>
<tr><td><code id="plot_probtrans_+3A_facet">facet</code></td>
<td>
<p>Should the resulting plot be faceted (one panel per transition)? 
Default is TRUE.</p>
</td></tr>
<tr><td><code id="plot_probtrans_+3A_times_interpol">times_interpol</code></td>
<td>
<p>At which times should the cumulative hazard be interpolated?
Only necessary to specify if interpolate = TRUE.</p>
</td></tr>
<tr><td><code id="plot_probtrans_+3A_c.legend">c.legend</code></td>
<td>
<p>Should legend be displayed for colour (different entries in 
<code>npmsmlist</code>)? Default is TRUE.</p>
</td></tr>
<tr><td><code id="plot_probtrans_+3A_c.names">c.names</code></td>
<td>
<p>A character vector indicating the names to display in the legend.
These names should represent the entries in <code>npmsmlist.</code>. Default = <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot will be produced in the plotting window. When assigning  
the output to an object, the underlying data frame used for plotting 
and a <code>'ggplot'</code> object will be returned in a list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(mstate)
require(ggplot2)
#Generate from an illness-death model with exponential transitions with 
#rates 1/2, 1/10 and 1 for 10 subjects over a time grid.
gd &lt;- sim_weibmsm(tmat = trans.illdeath(), shape = c(1,1,1),
                  scale = c(2, 10, 1), n_subj = 10, obs_pars = c(2, 0.5, 20), 
                  startprobs = c(0.9, 0.1, 0))
#Fit 2 models: 1 with at most 4 iterations and 1 with at most 20
mod1 &lt;- npmsm(gd, trans.illdeath(), maxit = 4)
mod2 &lt;- npmsm(gd, trans.illdeath(), maxit = 20)

#Plot the transition probabilities from state 1, without interpolating 
#the cumulative hazard for the npmsm runs with max 4 and 20 iterations.
plot_probtrans(list(mod1, mod2), from = 1, interpolate = FALSE,
               c.names = c("4 iterations", "20 iterations"))


</code></pre>

<hr>
<h2 id='plot_surv'>Plot the transition specific survival probabilities for a fitted <code>npmsm</code> model</h2><span id='topic+plot_surv'></span>

<h3>Description</h3>

<p>For a fitted <code>npmsm</code> model plot the transition specific 
survival probabilities. These are given by the product integral of the hazard 
increments estimated for a single transition. This is equivalent to a Kaplan-Meier 
estimator ignoring the existence of all other transitions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_surv(npmsmlist, landmark, support = FALSE, sup_cutoff = 1e-08)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_surv_+3A_npmsmlist">npmsmlist</code></td>
<td>
<p>An &quot;npmsm&quot; object or a list containing multiple &quot;npmsm&quot; objects</p>
</td></tr>
<tr><td><code id="plot_surv_+3A_landmark">landmark</code></td>
<td>
<p>A landmark time indicating from which time on survival should be determined.
If missing, the smallest time in the first &quot;npmsm&quot; object will be used.</p>
</td></tr>
<tr><td><code id="plot_surv_+3A_support">support</code></td>
<td>
<p>Should the support regions be displayed as rectangles?</p>
</td></tr>
<tr><td><code id="plot_surv_+3A_sup_cutoff">sup_cutoff</code></td>
<td>
<p>Cutoff to be used for determining the support intervals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot will be produced in the plotting window. When assigning  
the output to an object, the underlying data frame used for plotting 
and a <code>'ggplot'</code> object will be returned in a list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(mstate)
require(ggplot2)
#Generate from an illness-death model with exponential transitions with 
#rates 1/2, 1/10 and 1 for 10 subjects over a time grid.
gd &lt;- sim_weibmsm(tmat = trans.illdeath(), shape = c(1,1,1),
                  scale = c(2, 10, 1), n_subj = 10, obs_pars = c(2, 0.5, 20), 
                  startprobs = c(0.9, 0.1, 0))
mod1 &lt;- npmsm(gd, trans.illdeath(), maxit = 4)
mod2 &lt;- npmsm(gd, trans.illdeath(), maxit = 20)

#Plot the transition specific Kaplan-Meier estimators and their numerically 
#determined support sets.
plot_surv(list(mod1, mod2), support = TRUE)


</code></pre>

<hr>
<h2 id='plot.npmsm'>Plot a &quot;npmsm&quot; object</h2><span id='topic+plot.npmsm'></span>

<h3>Description</h3>

<p>Plot the cumulative intensities of a <code>'npmsm'</code> objects.
A wrapper for <code><a href="mstate.html#topic+plot.msfit">plot.msfit</a></code> from the
<code><a href="mstate.html#topic+mstate">mstate</a></code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'npmsm'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.npmsm_+3A_x">x</code></td>
<td>
<p>An object of class <code>"npmsm"</code></p>
</td></tr>
<tr><td><code id="plot.npmsm_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code><a href="mstate.html#topic+msfit">msfit</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot will be produced in the plotting window
</p>

<hr>
<h2 id='print.npmsm'>Print a &quot;npmsm&quot; object</h2><span id='topic+print.npmsm'></span>

<h3>Description</h3>

<p>Print some details of a <code><a href="#topic+npmsm">npmsm</a></code> fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'npmsm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.npmsm_+3A_x">x</code></td>
<td>
<p>An object of class <code>"npmsm"</code></p>
</td></tr>
<tr><td><code id="print.npmsm_+3A_...">...</code></td>
<td>
<p>Additional arguments to print</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A summary of the fitted model will be displayed in the console
</p>

<hr>
<h2 id='probtrans_weib'>Determine transition probabilities for a multi-state model with Weibull
hazards for the transitions.</h2><span id='topic+probtrans_weib'></span>

<h3>Description</h3>

<p>Determine transition probabilities for a multi-state model with Weibull
hazards for the transitions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>probtrans_weib(transMat, times, shapes, scales, type = c("prodint", "ODE"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="probtrans_weib_+3A_transmat">transMat</code></td>
<td>
<p>A transition matrix as generated by <code>mstate::transMat</code>
describing the possible transitions for the multi-state model.</p>
</td></tr>
<tr><td><code id="probtrans_weib_+3A_times">times</code></td>
<td>
<p>The times at which the transition probabilities should be 
determined. Will always determine the probabilities forward in time starting 
from <code>min(times)</code>.</p>
</td></tr>
<tr><td><code id="probtrans_weib_+3A_shapes">shapes</code></td>
<td>
<p>The Weibull shapes corresponding to the numbered transitions 
in <code>transMat</code>. See <code>?pweibull</code> for more info.</p>
</td></tr>
<tr><td><code id="probtrans_weib_+3A_scales">scales</code></td>
<td>
<p>The Weibull scales corresponding to the numbered transitions 
in <code>transMat</code>. See <code>?pweibull</code> for more info.</p>
</td></tr>
<tr><td><code id="probtrans_weib_+3A_type">type</code></td>
<td>
<p>Should the transition probabilities be determined using 
product integration <code>"prodint"</code> or by solving the Kolmogorov forward ordinary differential 
equation <code>"ODE"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object containing the &quot;true&quot; transition probabilities for the 
specified Weibull hazards.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Illness-death model
tmat &lt;- mstate::trans.illdeath()
IDM &lt;- probtrans_weib(tmat, seq(0, 15, 0.01), shapes = c(0.5, 0.5, 2), 
                      scales = c(5, 10, 10/gamma(1.5)), type = "prodint")
IDM2 &lt;- probtrans_weib(tmat, seq(0, 15, 0.01), shapes = c(0.5, 0.5, 2), 
                       scales = c(5, 10, 10/gamma(1.5)), type = "ODE")
plot(IDM)
plot(IDM2)

#Extended illness-death model
tmat &lt;- mstate::transMat(list(c(2, 3), c(4), c(), c()))
IDM &lt;- probtrans_weib(tmat, seq(0, 15, 0.01), shapes = c(0.5, 0.5, 2), 
                      scales = c(5, 10, 10/gamma(1.5)), type = "prodint")
IDM2 &lt;- probtrans_weib(tmat, seq(0, 15, 0.01), shapes = c(0.5, 0.5, 2), 
                       scales = c(5, 10, 10/gamma(1.5)), type = "ODE")
plot(IDM)
plot(IDM2)


</code></pre>

<hr>
<h2 id='prod_lambda_G_base'>Calculate the product of intensities over interval decided by 
failure times</h2><span id='topic+prod_lambda_G_base'></span>

<h3>Description</h3>

<p>This function calculates <code class="reqn">\prod_{\lambda}</code> G as defined in 
Frydman (1995), with <code class="reqn">t_n</code> the failure times. Note that length(t_n) must be 
equal to length(lambda)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prod_lambda_G_base(lambda, t_n, Q, A)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prod_lambda_G_base_+3A_lambda">lambda</code></td>
<td>
<p>Intensities of the 2-&gt;3 transition</p>
</td></tr>
<tr><td><code id="prod_lambda_G_base_+3A_t_n">t_n</code></td>
<td>
<p>Unique failure times, same length as lambda</p>
</td></tr>
<tr><td><code id="prod_lambda_G_base_+3A_q">Q</code></td>
<td>
<p>Matrix (2 column) containing support intervals as rows</p>
</td></tr>
<tr><td><code id="prod_lambda_G_base_+3A_a">A</code></td>
<td>
<p>Matrix (2 column) containing censoring intervals as rows</p>
</td></tr>
</table>

<hr>
<h2 id='remove_redundant_observations'>Remove redundant observations from supplied data frame</h2><span id='topic+remove_redundant_observations'></span>

<h3>Description</h3>

<p>Remove redundant observed states from a supplied data frame. 
Observations are redundant either when we observe an absorbing state multiple 
times (as we cannot leave an absorbing state), or 
when a transient state is observed multiple times between transitions (as 
we cannot have loops, therefore no extra information is provided when 
we observe a transient state multiple times).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_redundant_observations(gd, tmat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remove_redundant_observations_+3A_gd">gd</code></td>
<td>
<p>A <code>data.frame</code> with the following named columns
</p>

<dl>
<dt><code>id</code>:</dt><dd><p>Subject idenitifier;</p>
</dd>
<dt><code>state</code>:</dt><dd><p>State at which the subject is observed at <code>time</code>;</p>
</dd>
<dt><code>time</code>:</dt><dd><p>Time at which the subject is observed;</p>
</dd>
</dl>
<p> The true transition time between states is then interval censored between the times.</p>
</td></tr>
<tr><td><code id="remove_redundant_observations_+3A_tmat">tmat</code></td>
<td>
<p>A transition matrix as created by <code>transMat</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> containing the information contained in  the 
input <code>data.frame</code> <code>gd</code>,
but without redundant observations. Depending on whether <code>tmat</code> was 
specified the function may remove more observations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#We simulate some data
#Function to generate evaluation times: at 0 and uniform inter-observation
eval_times &lt;- function(n_obs, stop_time){
 cumsum( c( 0,  runif( n_obs-1, 0, 2*(stop_time-4)/(n_obs-1) ) ) )
}

#Simulate illness-death model data with Weibull transitions
sim_dat &lt;- sim_id_weib(n = 20, n_obs = 6, stop_time = 15, eval_times = eval_times,
                       start_state = "stable", shape = c(0.5, 0.5, 2), 
                       scale = c(5, 10, 10/gamma(1.5)))
visualise_msm(sim_dat)
require(mstate)
sim_dat_clean &lt;- remove_redundant_observations(sim_dat, trans.illdeath())
visualise_msm(sim_dat_clean)

</code></pre>

<hr>
<h2 id='sim_id_weib'>Simulate panel data from an illness-death model with Weibull transition hazards</h2><span id='topic+sim_id_weib'></span>

<h3>Description</h3>

<p>An illness-death model has 3 transitions:
</p>

<dl>
<dt><code>1</code>:</dt><dd><p>State 1 (Healthy) to State 2 (Illness);</p>
</dd>
<dt><code>2</code>:</dt><dd><p>State 1 (Healthy) to State 3 (Death);</p>
</dd>
<dt><code>3</code>:</dt><dd><p>State 2 (Illness) to State 3 (Death);</p>
</dd>
</dl>

<p>Using this function, it is possible to simulate data from an illness-death 
model with Weibull transition intensities. Requires the use of an external 
(self-written) function to generate observation times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_id_weib(
  n,
  n_obs,
  stop_time,
  eval_times,
  start_state = c("stable", "equalprob"),
  shape,
  scale,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_id_weib_+3A_n">n</code></td>
<td>
<p>Number of subjects to generate paths for.</p>
</td></tr>
<tr><td><code id="sim_id_weib_+3A_n_obs">n_obs</code></td>
<td>
<p>Number of observations in time period for each subject.</p>
</td></tr>
<tr><td><code id="sim_id_weib_+3A_stop_time">stop_time</code></td>
<td>
<p>Largest time at which the model is considered.</p>
</td></tr>
<tr><td><code id="sim_id_weib_+3A_eval_times">eval_times</code></td>
<td>
<p>A function which returns the evaluation times for a subject.
Must have as arguments at least <code>n_obs</code> and <code>stop_time</code>.</p>
</td></tr>
<tr><td><code id="sim_id_weib_+3A_start_state">start_state</code></td>
<td>
<p>In which states can subjects start? Either everyone starts 
in state 1 (&quot;stable&quot;) or equal probability to start in state 1 or 2 (&quot;equalprob&quot;).</p>
</td></tr>
<tr><td><code id="sim_id_weib_+3A_shape">shape</code></td>
<td>
<p>Vector of shape parameters for the 3 transitions. See <code><a href="stats.html#topic+rweibull">rweibull</a></code>.
The first entry will be used for the first transition and so on.</p>
</td></tr>
<tr><td><code id="sim_id_weib_+3A_scale">scale</code></td>
<td>
<p>Vector of scale parameters for the 3 transitions. See <code><a href="stats.html#topic+rweibull">rweibull</a></code>
The first entry will be used for the first transition and so on.</p>
</td></tr>
<tr><td><code id="sim_id_weib_+3A_...">...</code></td>
<td>
<p>Further parameters to <code>eval_times</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Taking <code>shape = 1</code> we get an exponential distribution with rate
<code>1/scale</code>
</p>


<h3>Value</h3>

<p>Panel data in the form of a <code>data.frame</code> with 3 named columns
id, time and state. These represent the subject identifier, the observation
time and the state at the 
observation time.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Function to generate evaluation times: at 0 and uniform inter-observation
eval_times &lt;- function(n_obs, stop_time){
  cumsum( c( 0,  runif( n_obs-1, 0, 2*(stop_time-4)/(n_obs-1) ) ) )
}

#Simulate illness-death model data with Weibull transitions
sim_dat &lt;- sim_id_weib(n = 20, n_obs = 6, stop_time = 15, eval_times = eval_times,
start_state = "stable", shape = c(0.5, 0.5, 2), scale = c(5, 10, 10/gamma(1.5)))

visualise_msm(sim_dat)

</code></pre>

<hr>
<h2 id='sim_weibmsm'>Simulate multiple trajectories from an interval-censored multi-state model
with Weibull transition intensities</h2><span id='topic+sim_weibmsm'></span>

<h3>Description</h3>

<p>Simulate multiple trajectories from a multi-state model quantified
by a transition matrix, with interval-censored transitions and Weibull 
distributed transition intensities. Allows for Weibull censoring in each of 
the states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_weibmsm(
  data,
  tmat,
  startprobs,
  exact,
  shape,
  scale,
  censshape,
  censscale,
  n_subj,
  obs_pars,
  true_trajec = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_weibmsm_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> or <code>matrix</code> with named columns <code>time</code> 
and <code>id</code>, representing the observation times and corresponding subject id(entifier).</p>
</td></tr>
<tr><td><code id="sim_weibmsm_+3A_tmat">tmat</code></td>
<td>
<p>A transition matrix as created by <code><a href="mstate.html#topic+transMat">transMat</a></code>, 
with H rows and H columns indicating the states. The total number of possible 
transitions will be indicated by M.</p>
</td></tr>
<tr><td><code id="sim_weibmsm_+3A_startprobs">startprobs</code></td>
<td>
<p>A numeric vector of length H indicating the probability of 
each subject to start in any of the possible states. Must sum to 1. By default,
all subjects will start in state 1.</p>
</td></tr>
<tr><td><code id="sim_weibmsm_+3A_exact">exact</code></td>
<td>
<p>A numeric vector indicating which states are exactly observed. 
The transition time to exact states will be observed at exact times, regardless 
of the times in <code>obstimes</code>. No exact states if missing.</p>
</td></tr>
<tr><td><code id="sim_weibmsm_+3A_shape">shape</code></td>
<td>
<p>A numeric vector of length M indicating the shape of the Weibull 
transition intensity for the corresponding transition in <code>tmat</code>. See 
<code>help(dweibull)</code>.</p>
</td></tr>
<tr><td><code id="sim_weibmsm_+3A_scale">scale</code></td>
<td>
<p>A numeric vector of length M indicating the scale of the Weibull 
transition intensity for the corresponding transition in <code>tmat</code>. See 
<code>help(dweibull)</code>.</p>
</td></tr>
<tr><td><code id="sim_weibmsm_+3A_censshape">censshape</code></td>
<td>
<p>A numeric vector of length H indicating the Weibull 
censoring shape in each of the states. If no censoring is required in some states, 
set corresponding entries to <code>NA</code>. If left missing, 
no censoring is applied. See details.</p>
</td></tr>
<tr><td><code id="sim_weibmsm_+3A_censscale">censscale</code></td>
<td>
<p>A numeric vector of length H indicating the Weibull censoring 
scale in each of the states. If no censoring is required in some states, 
set corresponding entries to <code>NA</code>. If left missing, no censoring is applied.
See details.</p>
</td></tr>
<tr><td><code id="sim_weibmsm_+3A_n_subj">n_subj</code></td>
<td>
<p>(Optional) Instead of specifying <code>data</code>, specify the number 
of subjects to generate trajectories for. Requires <code>obs_pars</code>  to
also be specified.</p>
</td></tr>
<tr><td><code id="sim_weibmsm_+3A_obs_pars">obs_pars</code></td>
<td>
<p>(Optional) A numeric vector of length 3 specifying what the 
time is between planned assessments, what the uniform deviation from this 
time is at the visits and the maximum visit time. 
Specifying <code>obs_pars = c(2, 0.5, 20)</code> will generate 
a grid of observation times (0, 2, 4, ..., 20) with a uniform[-0.5, 0.5] random 
variable added to each observation time, and cut-off at the end-points 0 and 20.
The observation times may not overlap, 
so the first argument must be at least twice as large as the second.</p>
</td></tr>
<tr><td><code id="sim_weibmsm_+3A_true_trajec">true_trajec</code></td>
<td>
<p>Should the true (right-censored) trajectory be returned for
the subjects as well? Default = <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Taking <code>(cens)shape</code> to be 1 for all transitions, we obtain exponential 
(censoring)/transitions with rate 1/<code>(cens)scale</code>.
</p>
<p>If right-censoring parameters are specified, a right-censoring time is generated in 
each of the visited states. If the subject is right-censored, we assume the subject 
is no longer observed at later <code>obstimes</code>. Due to the interval-censored 
nature of the generation process, it may therefore appear as if the subject 
was right-censored in an earlier state.
</p>
<p>Suppose a subject arrives in state g at time s. If we wish to generate 
a survival time from that state according to a Weibull intensity in a clock forward 
model, we can use the inverse transform of the conditional Weibull intensity.
More specifically, letting <code class="reqn">a</code> denote the shape and <code class="reqn">\sigma</code> denote the scale, 
the conditional survival function for <code class="reqn">t &gt; s</code> is given by
</p>
<p style="text-align: center;"><code class="reqn">S(t|s) = \mathbf{P}(T \geq t | T \geq s) = \exp(\left( \frac{s}{\sigma} \right)^a - \left( \frac{t}{\sigma} \right)^a)</code>
</p>

<p>The corresponding cumulative intensity is then given by:
</p>
<p style="text-align: center;"><code class="reqn">A(t|s) = -\log(S(t|s)) = \left( \frac{t}{\sigma} \right)^a - \left( \frac{s}{\sigma} \right)^a</code>
</p>

<p>And the inverse cumulative intensity is then:
</p>
<p style="text-align: center;"><code class="reqn">A^{-1}(t|s) = \sigma \sqrt[a]{t + \left( \frac{s}{\sigma} \right)^a}</code>
</p>

<p>A conditional survival time is then generated by:
</p>
<p style="text-align: center;"><code class="reqn">T|s = A^{-1}(-\log(U)|s)</code>
</p>

<p>with <code class="reqn">U</code> a sample from the standard uniform distribution.
If we additionally have covariates (or frailties), the <code class="reqn">-\log(U)</code>
above should be replaced by <code class="reqn">\frac{-\log(U)}{\exp(\beta X)}</code>
with <code class="reqn">\beta</code> and <code class="reqn">X</code> the coefficients and covariates respectively.
</p>


<h3>Value</h3>

<p>A <code>matrix</code> with 3 columns <code>time</code>, <code>state</code> and <code>id</code>, indicating 
the observation time, the corresponding state and subject identifier. If 
<code>true_trajec = TRUE</code>, a <code>list</code> with the matrix described above and a matrix 
representing the underlying right-censored trajectory.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(mstate)
require(ggplot2)
#Generate from an illness-death model with exponential transitions with 
#rates 1/2, 1/10 and 1 for 10 subjects over a time grid.
gd &lt;- sim_weibmsm(tmat = trans.illdeath(), shape = c(1,1,1),
                  scale = c(2, 10, 1), n_subj = 10, obs_pars = c(2, 0.5, 20), 
                  startprobs = c(0.9, 0.1, 0), true_trajec = TRUE)

#Observed trajectories
visualise_msm(gd$observed)
#True trajectories
visualise_msm(gd$true)


#Can supply data-frame with specified observation times
obs_df &lt;- data.frame(time = c(0, 1, 3, 5, 0.5, 6, 9),
                     id = c(1, 1, 1, 1, 2, 2, 2))
gd &lt;- sim_weibmsm(data = obs_df, tmat = trans.illdeath(), shape = c(1, 1, 1),
                  scale = c(2, 10, 1))
visualise_msm(gd)
</code></pre>

<hr>
<h2 id='support_from_direct_intervals'>Estimate support of multiple transitions given direct transition intervals</h2><span id='topic+support_from_direct_intervals'></span>

<h3>Description</h3>

<p>Given only direct transition intervals, determine the support
for each transition separately using Hudgens(2001) result. Each state is
considered from a competing-risks viewpoint. Hudgens(2005) result is applied 
to see if the NPMLE for any of the transitions does not exist.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>support_from_direct_intervals(direct_intervals, tmat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="support_from_direct_intervals_+3A_direct_intervals">direct_intervals</code></td>
<td>
<p>Output from <code><a href="#topic+direct_from_observed_intervals">direct_from_observed_intervals</a></code>.</p>
</td></tr>
<tr><td><code id="support_from_direct_intervals_+3A_tmat">tmat</code></td>
<td>
<p>A transition matrix as created by <code>transMat</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the estimated support sets for each possible transition
in <code>tmat</code>.
</p>

<hr>
<h2 id='support_frydman'>Find support for Illness-death model. Only 
applicable to Frydman (1995) setting!!</h2><span id='topic+support_frydman'></span>

<h3>Description</h3>

<p>Find support for Illness-death model. Only 
applicable to Frydman (1995) setting!!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>support_frydman(data_idx)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="support_frydman_+3A_data_idx">data_idx</code></td>
<td>
<p>List containing all the necessary data, output from the 
<code><a href="#topic+msm_frydman">msm_frydman</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Finds the support sets Q for the interval censored transition
1 -&gt; 2. The transitions 2-&gt;3 and 1-&gt;3 are exactly observed in this setting, 
therefore do not require determination of the support.
</p>


<h3>Value</h3>

<p>A: Matrix containing the intervals indicating when the transitions 
were censored.
unique_L_times: Union of failure times in Group 4 and censoring times in 
Group 1.
L_tilde: Left intervals for constructing the Q intervals
R_tilde: Right intervals for constructing the Q intervals
Q_mat: Matrix containing the support set for the 1-&gt;2 transition
I: number of intervals in the support set Q.
</p>


<h3>References</h3>

<p>Frydman, H. (1995). Nonparametric Estimation of a Markov 
'Illness-Death' Process from Interval- Censored Observations, with 
Application to Diabetes Survival Data. Biometrika, 82(4), 773-789. 
<a href="https://doi.org/10.2307/2337344">doi:10.2307/2337344</a>
</p>

<hr>
<h2 id='support_npmsm'>Numerically find the support of the transitions from a converged npmsm algorithm</h2><span id='topic+support_npmsm'></span>

<h3>Description</h3>

<p>For each transition in <code>tmat</code>, determine all consecutive 
bins with non-zero (higher than <code>cutoff</code>) transition intensities.
These then determine the numerical support of the transition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>support_npmsm(npmsm, cutoff = 1e-08)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="support_npmsm_+3A_npmsm">npmsm</code></td>
<td>
<p>Output from <code><a href="#topic+npmsm">npmsm</a></code> function or an <code><a href="mstate.html#topic+msfit">msfit</a></code> object.</p>
</td></tr>
<tr><td><code id="support_npmsm_+3A_cutoff">cutoff</code></td>
<td>
<p>Above which value is a mass in a bin considered to be non-zero? 
Default = 1e-8. Note that this is independent of bin size, so can be tricky!!</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing a list for each transition. Each transition 
specific list contains the support intervals for that transition in a matrix 
with 3 named columns L, R and dA, indicating the left/right-endpoints of the 
support intervals and the change in the estimated intensities over this 
support interval.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(mstate)
require(ggplot2)
#Generate from an illness-death model with exponential transitions with 
#rates 1/2, 1/10 and 1 for 10 subjects over a time grid.
gd &lt;- sim_weibmsm(tmat = trans.illdeath(), shape = c(1,1,1),
                  scale = c(2, 10, 1), n_subj = 10, obs_pars = c(2, 0.5, 20), 
                  startprobs = c(0.9, 0.1, 0))
#Fit 2 models: 1 with at most 4 iterations and 1 with at most 20
mod1 &lt;- npmsm(gd, trans.illdeath(), maxit = 4)

#Determine support numerically:
mod1_supp &lt;- support_npmsm(mod1)
mod1_supp[[1]]
</code></pre>

<hr>
<h2 id='supportHudgens'>Determine the support of the NPMLE for interval censored data.</h2><span id='topic+supportHudgens'></span>

<h3>Description</h3>

<p>Given censoring/truncation intervals, find the maxcliques and determine
the support of the interval censored problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>supportHudgens(intervals, reduction = TRUE, existence = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="supportHudgens_+3A_intervals">intervals</code></td>
<td>
<p>A data.frame with 3 columns containing half-open intervals (left open, right closed)
and an indicator whether the interval results from a censored transition
or truncation:
</p>

<dl>
<dt><code>L</code>:</dt><dd><p>Left side of interval;</p>
</dd>
<dt><code>R</code>:</dt><dd><p>Right side of interval;</p>
</dd>
<dt><code>cens</code>:</dt><dd><p>Indicator whether interval resulted from interval censoring or left truncation
(1 = censoring, 0 = truncation);</p>
</dd>
<dt><code>id</code>:</dt><dd><p>(optional) Identifier for the observation this interval belongs to (numeric/integer).
Only required if existence = TRUE;</p>
</dd>
</dl>
<p> Note that the truncation intervals need to be in the form (N, Inf] with N a numeric value.</p>
</td></tr>
<tr><td><code id="supportHudgens_+3A_reduction">reduction</code></td>
<td>
<p>Should the support be reduced using Lemma 3 from Hudgens (2005)? This 
requires checking an extra condition. Default is TRUE.</p>
</td></tr>
<tr><td><code id="supportHudgens_+3A_existence">existence</code></td>
<td>
<p>Should the existence of the NPMLE be checked using Theorem 1/Lemma 4 from 
Hudgens (2005)? Requires <code>id</code> to be present in <code>intervals</code>. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>graph</code>: An <code>igraph</code> object representing the censoring/truncation intervals
</p>
</li>
<li> <p><code>support</code>: Support estimated from the censoring intervals
</p>
</li>
<li> <p><code>dir_graph</code>: A directed <code>igraph</code> object used to determine whether the NPMLE
exists in the presence of left-truncation.
</p>
</li>
<li> <p><code>exist_mle</code>: Logical output indicating whether the NPMLE exists.
</p>
</li></ul>



<h3>References</h3>

<p>Michael G. Hudgens, On Nonparametric Maximum Likelihood Estimation with 
Interval Censoring and Left Truncation, Journal of the Royal Statistical Society 
Series B: Statistical Methodology, Volume 67, Issue 4, September 2005, Pages 573-587,
<a href="https://doi.org/10.1111/j.1467-9868.2005.00516.x">doi:10.1111/j.1467-9868.2005.00516.x</a>
</p>

<hr>
<h2 id='transprob.msm'>Wrapper for the <code><a href="mstate.html#topic+probtrans">probtrans</a></code> function</h2><span id='topic+transprob.msm'></span><span id='topic+transprob.npmsm'></span><span id='topic+transprob.msfit'></span><span id='topic+transprob'></span>

<h3>Description</h3>

<p>For <code>'msm'</code> objects: determine transition probabilities
(as in <code><a href="mstate.html#topic+probtrans">probtrans</a></code>)  from an 
<code><a href="msm.html#topic+msm">msm</a></code> object. Currently only direction = &quot;forward&quot; is supported.
</p>
<p>For <code>'npmsm'</code> objects: Determine transition probabilities for an <code>'npmsm'</code> object 
using the <code><a href="mstate.html#topic+probtrans">probtrans</a></code> function.
</p>
<p>For <code>'msfit'</code> objects: Wrapper for <code><a href="mstate.html#topic+probtrans">probtrans</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'msm'
transprob(object, predt, times, ...)

## S3 method for class 'npmsm'
transprob(object, ...)

## S3 method for class 'msfit'
transprob(object, ...)

transprob(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transprob.msm_+3A_object">object</code></td>
<td>
<p>Object of compatible class</p>
</td></tr>
<tr><td><code id="transprob.msm_+3A_predt">predt</code></td>
<td>
<p>A positive number indicating the prediction time. This is 
the time at which the prediction is made. If missing, smallest time of 
<code>times</code> is chosen.</p>
</td></tr>
<tr><td><code id="transprob.msm_+3A_times">times</code></td>
<td>
<p>A vector of times at which the transition probabilities should 
be determined.</p>
</td></tr>
<tr><td><code id="transprob.msm_+3A_...">...</code></td>
<td>
<p>Further arguments to <code><a href="mstate.html#topic+probtrans">probtrans</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Can be used for objects of class 'npmsm', 'msm' and 'msfit'
</p>


<h3>Value</h3>

<p>A <code>probtrans</code> object containing the estimated transition probabilities.
</p>

<hr>
<h2 id='visualise_data'>Visualise data for illness-death model, only applicable to Frydman(1995) setting.</h2><span id='topic+visualise_data'></span>

<h3>Description</h3>

<p>Visualise data for illness-death model, only applicable to Frydman(1995) setting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>visualise_data(data, msmFrydman)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="visualise_data_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> containing the columns named:
</p>

<dl>
<dt><code>delta</code>:</dt><dd><p>Did a transition from 1 -&gt; 2 occur? (binary: 0 = no, 1 = yes); 
In the left-truncated case, delta = 2 indicates initially observed in state 2.</p>
</dd>
<dt><code>Delta</code>:</dt><dd><p>Was the transition to state 3 observed? (binary: 0 = no, 1 = yes);</p>
</dd>
<dt><code>L</code>:</dt><dd><p>Left timepoint of interval censored transition to state 2 (numeric);</p>
</dd>
<dt><code>R</code>:</dt><dd><p>Right timepoint of interval censored transition to state 2 (numeric);</p>
</dd>
<dt><code>time</code>:</dt><dd><p>Time of event (transition to 3) or right-censoring in state 2 (numeric);</p>
</dd>
<dt><code>trunc</code>:</dt><dd><p>(optional) Left-truncation time (numeric); Only used for entries with delta = 2.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="visualise_data_+3A_msmfrydman">msmFrydman</code></td>
<td>
<p>A fitted model from <code><a href="#topic+msm_frydman">msm_frydman</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a visualisation of illness-death data, with the transition 
from healthy to illness interval-censored and the other two transitions 
observed exactly or right-censored. If <code>msmFrydman</code> is specified, the 
support intervals from the fit are additionally plotted at the top of the 
data visualisation.
</p>


<h3>References</h3>

<p>Frydman, H. (1995). Nonparametric Estimation of a Markov 
'Illness-Death' Process from Interval- Censored Observations, with 
Application to Diabetes Survival Data. Biometrika, 82(4), 773-789. 
<a href="https://doi.org/10.2307/2337344">doi:10.2307/2337344</a>
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+msm_frydman">msm_frydman</a></code> for fitting a model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- data.frame(delta = c(0, 0, 1, 1), Delta = c(0, 1, 0, 1),
                   L = c(NA, NA, 1, 1.5), R = c(NA, 3, 2, 3),
                   time = c(4, 5, 6, 7))

mod_frydman &lt;- msm_frydman(data)
visualise_data(data, mod_frydman)

</code></pre>

<hr>
<h2 id='visualise_msm'>Visualise multi-state data</h2><span id='topic+visualise_msm'></span>

<h3>Description</h3>

<p>Produce a plot with the y-axis representing subjects in the data and the 
x-axis representing the time at which states have been observed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>visualise_msm(gd, npmsm, tmat, neat = TRUE, cutoff)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="visualise_msm_+3A_gd">gd</code></td>
<td>
<p>A <code>data.frame</code> containing the following named columns:
</p>

<dl>
<dt><code>id</code>:</dt><dd><p>Identifier of subject;</p>
</dd>
<dt><code>state</code>:</dt><dd><p>state of subject at <code>time</code>;</p>
</dd>
<dt><code>time</code>:</dt><dd><p>time at which subject is observed;</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="visualise_msm_+3A_npmsm">npmsm</code></td>
<td>
<p>Output from <code><a href="#topic+npmsm">npmsm</a></code> function</p>
</td></tr>
<tr><td><code id="visualise_msm_+3A_tmat">tmat</code></td>
<td>
<p>A transition matrix as created by <code>transMat</code></p>
</td></tr>
<tr><td><code id="visualise_msm_+3A_neat">neat</code></td>
<td>
<p>Boolean indicating whether redundant observations should be 
removed in the plot. Default is TRUE</p>
</td></tr>
<tr><td><code id="visualise_msm_+3A_cutoff">cutoff</code></td>
<td>
<p>cutoff value for numerically determining the support using
<code><a href="#topic+support_npmsm">support_npmsm</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot will be produced in the plotting window.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Write a function for evaluation times: observe at 0 and uniform inter-observation times.
eval_times &lt;- function(n_obs, stop_time){
  cumsum( c( runif(1, 0, 0.5),  runif( n_obs-1, 0, 2*(stop_time-4)/(n_obs-1) ) ) )
}
#Use built_in function to simulate illness-death data
#from Weibull distributions for each transition
sim_dat &lt;- sim_id_weib(n = 50, n_obs = 6, stop_time = 15, eval_times = eval_times,
                      start_state = "stable", shape = c(0.5, 0.5, 2), 
                      scale = c(5, 10, 10/gamma(1.5)))

#Visualise the data
visualise_msm(sim_dat)                       

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
