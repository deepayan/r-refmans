<!DOCTYPE html><html><head><title>Help for package statnet.common</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {statnet.common}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#all_identical'><p>Test if all items in a vector or a list are identical.</p></a></li>
<li><a href='#as.control.list'><p>Convert to a control list.</p></a></li>
<li><a href='#attr'><p>A wrapper for base::attr which defaults to exact matching.</p></a></li>
<li><a href='#check.control.class'><p>Ensure that the class of the control list is one of those that can</p>
be used by the calling function</a></li>
<li><a href='#compress_rows'><p>A generic function to compress a row-weighted table</p></a></li>
<li><a href='#compress_rows.data.frame'><p>&quot;Compress&quot; a data frame.</p></a></li>
<li><a href='#control.list.accessor'><p>Named element accessor for ergm control lists</p></a></li>
<li><a href='#control.remap'><p>Overwrite control parameters of one configuration with another.</p></a></li>
<li><a href='#default_options'><p>Set <code>options()</code> according to a named list, skipping those already</p>
set.</a></li>
<li><a href='#deInf'><p>Truncate values of high magnitude in a vector.</p></a></li>
<li><a href='#deprecation-utilities'><p>Utilities to help with deprecating functions.</p></a></li>
<li><a href='#despace'><p>A one-line function to strip whitespace from its argument.</p></a></li>
<li><a href='#diff.control.list'><p>Identify and the differences between two control lists.</p></a></li>
<li><a href='#empty_env'><p>Replace an object's environment with a simple, static environment.</p></a></li>
<li><a href='#ERRVL'><p>Return the first argument passed (out of any number) that is not a</p>
<code>try-error</code> (result of <code>try</code> encountering an error.</a></li>
<li><a href='#fixed.pval'><p>Format a p-value in fixed notation.</p></a></li>
<li><a href='#forkTimeout'><p>Evaluate an <span class="rlang"><b>R</b></span> expression with a hard time limit by forking a process</p></a></li>
<li><a href='#formula.utilities'><p>Functions for Querying, Validating and Extracting from Formulas</p></a></li>
<li><a href='#handle.controls'><p>Handle standard <code style="white-space: pre;">&#8288;control.*()&#8288;</code> function semantics.</p></a></li>
<li><a href='#is.SPD'><p>Test if the object is a matrix that is symmetric and positive definite</p></a></li>
<li><a href='#locate_function'><p>Locate a function with a given name and return it and its environment.</p></a></li>
<li><a href='#logspace.utils'><p>Utilities for performing calculations on logarithmic scale.</p></a></li>
<li><a href='#mcmc-utilities'><p>Utility operations for <code>mcmc.list</code> objects</p></a></li>
<li><a href='#message_print'><p><code>print</code> objects to the <code>message</code> output.</p></a></li>
<li><a href='#NVL'><p>Convenience functions for handling <code>NULL</code> objects.</p></a></li>
<li><a href='#once'><p>Evaluate a function once for a given input.</p></a></li>
<li><a href='#opttest'><p>Optionally test code depending on environment variable.</p></a></li>
<li><a href='#order'><p>Implement the <code>sort</code> and <code>order</code> methods for</p>
<code>data.frame</code> and <code>matrix</code>, sorting it in
lexicographic order.</a></li>
<li><a href='#paste.and'><p>Concatenates the elements of a vector (optionaly enclosing them in quotation</p>
marks or parentheses) adding appropriate punctuation and conjunctions.</a></li>
<li><a href='#persistEval'><p>Evaluate an expression, restarting on error</p></a></li>
<li><a href='#print.control.list'><p>Pretty print the control list</p></a></li>
<li><a href='#set.control.class'><p>Set the class of the control list</p></a></li>
<li><a href='#simplify_simple'><p>Convert a list to an atomic vector if it consists solely of atomic elements of length 1.</p></a></li>
<li><a href='#snctrl'><p>Statnet Control</p></a></li>
<li><a href='#snctrl_names'><p>Helper functions used by packages to facilitate <code>snctrl</code> updating.</p></a></li>
<li><a href='#split.array'><p>A <code>split()</code> method for <code>array</code> and <code>matrix</code> types on a margin.</p></a></li>
<li><a href='#ssolve'><p>Wrappers around matrix algebra functions that pre-<em>s</em>cale their</p>
arguments</a></li>
<li><a href='#statnet.cite'><p><code>CITATION</code> file utilities for Statnet packages (DEPRECATED)</p></a></li>
<li><a href='#statnetStartupMessage'><p>Construct a &quot;standard&quot; startup message to be printed when the package is</p>
loaded.</a></li>
<li><a href='#sweep_cols.matrix'><p>Suptract a elements of a vector from respective columns of a matrix</p></a></li>
<li><a href='#term_list'><p>A helper class for list of terms in an formula</p></a></li>
<li><a href='#trim_env'><p>Make a copy of an environment with just the selected objects.</p></a></li>
<li><a href='#ult'><p>Extract or replace the <em>ult</em>imate (last) element of a vector or a list, or an element counting from the end.</p></a></li>
<li><a href='#unused_dots_warning'><p>An error handler for <code>rlang::check_dots_used()</code> that issues a</p>
warning that only lists argument names.</a></li>
<li><a href='#unwhich'><p>Construct a logical vector with <code>TRUE</code> in specified positions.</p></a></li>
<li><a href='#vector.namesmatch'><p>reorder vector v into order determined by matching the names of its elements</p>
to a vector of names</a></li>
<li><a href='#Welford'><p>A Welford accumulator for sample mean and variance</p></a></li>
<li><a href='#wmatrix'><p>A data matrix with row weights</p></a></li>
<li><a href='#wmatrix_weights'><p>Set or extract weighted matrix row weights</p></a></li>
<li><a href='#xTAx'><p>Common quadratic forms</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>4.9.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-05-24</td>
</tr>
<tr>
<td>Title:</td>
<td>Common R Scripts and Utilities Used by the Statnet Project
Software</td>
</tr>
<tr>
<td>Description:</td>
<td>Non-statistical utilities used by the software developed by the Statnet Project. They may also be of use to others.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils, methods, coda, parallel, tools</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/statnet/statnet.common/issues">https://github.com/statnet/statnet.common/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://statnet.org">https://statnet.org</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, rlang (&ge; 1.1.1), MASS, Matrix</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-05-24 06:07:22 UTC; pavel</td>
</tr>
<tr>
<td>Author:</td>
<td>Pavel N. Krivitsky
    <a href="https://orcid.org/0000-0002-9101-3362"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]
    (University of New South Wales),
  Skye Bender-deMoll [ctb],
  Chad Klumb [ctb] (University of Washington)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Pavel N. Krivitsky &lt;pavel@statnet.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-05-24 16:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='all_identical'>Test if all items in a vector or a list are identical.</h2><span id='topic+all_identical'></span>

<h3>Description</h3>

<p>Test if all items in a vector or a list are identical.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_identical(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all_identical_+3A_x">x</code></td>
<td>
<p>a vector or a list</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if all elements of <code>x</code> are identical to each other.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+identical">identical</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
stopifnot(!all_identical(1:3))

stopifnot(all_identical(list("a", "a", "a")))
</code></pre>

<hr>
<h2 id='as.control.list'>Convert to a control list.</h2><span id='topic+as.control.list'></span><span id='topic+as.control.list.control.list'></span><span id='topic+as.control.list.list'></span>

<h3>Description</h3>

<p>Convert to a control list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.control.list(x, ...)

## S3 method for class 'control.list'
as.control.list(x, ...)

## S3 method for class 'list'
as.control.list(x, FUN = NULL, unflat = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.control.list_+3A_x">x</code></td>
<td>
<p>An object, usually a <code><a href="base.html#topic+list">list</a></code>, to be converted to a
control list.</p>
</td></tr>
<tr><td><code id="as.control.list_+3A_...">...</code></td>
<td>
<p>Additional arguments to methods.</p>
</td></tr>
<tr><td><code id="as.control.list_+3A_fun">FUN</code></td>
<td>
<p>Either a <code style="white-space: pre;">&#8288;control.*()&#8288;</code> function or its name or suffix
(to which <code>"control."</code> will be prepended); defaults to taking the
nearest (in the call traceback) function that does not begin with
<code>"as.control.list"</code>, and prepending <code>"control."</code> to it. (This is
typically the function that called <code>as.control.list()</code> in the
first place.)</p>
</td></tr>
<tr><td><code id="as.control.list_+3A_unflat">unflat</code></td>
<td>
<p>Logical, indicating whether an attempt should be made
to detect whether some of the arguments are appropriate for a
lower-level control function and pass them down.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>control.list</code> object.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>as.control.list(control.list)</code>: Idempotent method for control lists.
</p>
</li>
<li> <p><code>as.control.list(list)</code>: The method for plain lists, which runs
them through <code>FUN</code>.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>myfun &lt;- function(..., control=control.myfun()){
  as.control.list(control)
}
control.myfun &lt;- function(a=1, b=a+1){
  list(a=a,b=b)
}

myfun()
myfun(control = list(a=2))
myfun2 &lt;- function(..., control=control.myfun2()){
  as.control.list(control)
}
control.myfun2 &lt;- function(c=3, d=c+2, myfun=control.myfun()){
  list(c=c,d=d,myfun=myfun)
}

myfun2()
# Argument to control.myfun() (i.e., a) gets passed to it, and a
# warning is issued for unused argument e.
myfun2(control = list(c=3, a=2, e=3))
</code></pre>

<hr>
<h2 id='attr'>A wrapper for base::attr which defaults to exact matching.</h2><span id='topic+attr'></span>

<h3>Description</h3>

<p>A wrapper for base::attr which defaults to exact matching.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>attr(x, which, exact = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="attr_+3A_x">x</code>, <code id="attr_+3A_which">which</code>, <code id="attr_+3A_exact">exact</code></td>
<td>
<p>as in <code>base::attr</code>, but with <code>exact</code>
defaulting to <code>TRUE</code> in this implementation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>as in <code>base::attr</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- list()
attr(x, "name") &lt;- 10

base::attr(x, "n")

stopifnot(is.null(attr(x, "n")))

base::attr(x, "n", exact = TRUE)
</code></pre>

<hr>
<h2 id='check.control.class'>Ensure that the class of the control list is one of those that can
be used by the calling function</h2><span id='topic+check.control.class'></span>

<h3>Description</h3>

<p>This function converts an ordinary <code>list</code> into a control list (if
needed) and checks that the control list passed is appropriate for
the function to be controlled.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.control.class(
  OKnames = as.character(ult(sys.calls(), 2)[[1L]]),
  myname = as.character(ult(sys.calls(), 2)[[1L]]),
  control = get("control", pos = parent.frame())
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check.control.class_+3A_oknames">OKnames</code></td>
<td>
<p>List of control function names which are acceptable.</p>
</td></tr>
<tr><td><code id="check.control.class_+3A_myname">myname</code></td>
<td>
<p>Name of the calling function (used in the error
message).</p>
</td></tr>
<tr><td><code id="check.control.class_+3A_control">control</code></td>
<td>
<p>The control list or a list to be converted to a
control list using <code>control.myname()</code>. Defaults to the
<code>control</code> variable in the calling function. See Details for
detailed behavior.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>check.control.class()</code> performs the check by looking up
the class of the <code>control</code> argument (defaulting to the <code>control</code>
variable in the calling function) and checking if it matches a
list of acceptable given by <code>OKnames</code>.
</p>
<p>Before performing any checks, the <code>control</code> argument (including
the default) will be converted to a control list by calling
<code><a href="#topic+as.control.list">as.control.list()</a></code> on it with the first element of <code>OKnames</code> to
construct the control function.
</p>
<p>If <code>control</code> is missing, it will be assumed that the user wants
to modify it in place, and a variable with that name in the
parent environment will be overwritten.
</p>


<h3>Value</h3>

<p>A valid control list for the function in which it is to be
used. If <code>control</code> argument is missing, it will also overwrite
the variable <code>control</code> in the calling environment with it.
</p>


<h3>Note</h3>

<p>In earlier versions, <code>OKnames</code> and <code>myname</code> were
autodetected. This capability has been deprecated and results in
a warning issued once per session. They now need to be set
explicitly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set.control.class">set.control.class()</a></code>, <code><a href="#topic+print.control.list">print.control.list()</a></code>, <code><a href="#topic+as.control.list">as.control.list()</a></code>
</p>

<hr>
<h2 id='compress_rows'>A generic function to compress a row-weighted table</h2><span id='topic+compress_rows'></span><span id='topic+decompress_rows'></span>

<h3>Description</h3>

<p>Compress a matrix or a data frame with duplicated rows, updating row weights
to reflect frequencies, or reverse the process, reconstructing a matrix like
the one compressed (subject to permutation of rows and weights not adding up
to an integer).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compress_rows(x, ...)

decompress_rows(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compress_rows_+3A_x">x</code></td>
<td>
<p>a weighted matrix or data frame.</p>
</td></tr>
<tr><td><code id="compress_rows_+3A_...">...</code></td>
<td>
<p>extra arguments for methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>compress_rows</code> A weighted matrix or data frame of the same
type with duplicated rows removed and weights updated appropriately.
</p>

<hr>
<h2 id='compress_rows.data.frame'>&quot;Compress&quot; a data frame.</h2><span id='topic+compress_rows.data.frame'></span><span id='topic+decompress_rows.compressed_rows_df'></span>

<h3>Description</h3>

<p><code>compress_rows.data.frame</code> &quot;compresses&quot; a data frame, returning unique rows
and a tally of the number of times each row is repeated, as well as a
permutation vector that can reconstruct the original data frame.
<code>decompress_rows.compressed_rows_df</code> reconstructs the original data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.frame'
compress_rows(x, ...)

## S3 method for class 'compressed_rows_df'
decompress_rows(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compress_rows.data.frame_+3A_x">x</code></td>
<td>
<p>For <code>compress_rows.data.frame</code> a <code><a href="base.html#topic+data.frame">data.frame</a></code> to be
compressed. For <code>decompress_rows.compress_rows_df</code> a <code><a href="base.html#topic+list">list</a></code> as
returned by <code>compress_rows.data.frame</code>.</p>
</td></tr>
<tr><td><code id="compress_rows.data.frame_+3A_...">...</code></td>
<td>
<p>Additional arguments, currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>compress_rows.data.frame</code>, a <code><a href="base.html#topic+list">list</a></code> with three
elements: </p>
<table>
<tr><td><code>rows</code></td>
<td>
<p>Unique rows of <code>x</code></p>
</td></tr> <tr><td><code>frequencies</code></td>
<td>
<p>A vector
of the same length as the number or rows, giving the number of times the
corresponding row is repeated </p>
</td></tr> <tr><td><code>ordering</code></td>
<td>
<p>A vector such that if
<code>c</code> is the compressed data frame, <code>c$rows[c$ordering,,drop=FALSE]</code>
equals the original data frame, except for row names</p>
</td></tr> <tr><td><code>rownames</code></td>
<td>
<p>Row
names of <code>x</code></p>
</td></tr>
</table>
<p>For <code>decompress_rows.compressed_rows_df</code>, the original data frame.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+data.frame">data.frame</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
(x &lt;- data.frame(V1=sample.int(3,30,replace=TRUE),
                 V2=sample.int(2,30,replace=TRUE),
                 V3=sample.int(4,30,replace=TRUE)))

(c &lt;- compress_rows(x))

stopifnot(all(decompress_rows(c)==x))

</code></pre>

<hr>
<h2 id='control.list.accessor'>Named element accessor for ergm control lists</h2><span id='topic+control.list.accessor'></span><span id='topic++24.control.list'></span>

<h3>Description</h3>

<p>Utility method that overrides the standard &lsquo;$&rsquo; list accessor to disable
partial matching for ergm <code>control.list</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'control.list'
object$name
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="control.list.accessor_+3A_object">object</code></td>
<td>
<p>list-coearceable object with elements to be searched</p>
</td></tr>
<tr><td><code id="control.list.accessor_+3A_name">name</code></td>
<td>
<p>literal character name of list element to search for and return</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Executes <code><a href="base.html#topic+getElement">getElement</a></code> instead of <code><a href="base.html#topic++24">$</a></code> so
that element names must match exactly to be returned and partially matching
names will not return the wrong object.
</p>


<h3>Value</h3>

<p>Returns the named list element exactly matching <code>name</code>, or
<code>NULL</code> if no matching elements found
</p>


<h3>Author(s)</h3>

<p>Pavel N. Krivitsky
</p>


<h3>See Also</h3>

<p>see <code><a href="base.html#topic+getElement">getElement</a></code>
</p>

<hr>
<h2 id='control.remap'>Overwrite control parameters of one configuration with another.</h2><span id='topic+control.remap'></span>

<h3>Description</h3>

<p>Given a <code>control.list</code>, and two prefixes, <code>from</code> and <code>to</code>,
overwrite the elements starting with <code>to</code> with the corresponding
elements starting with <code>from</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>control.remap(control, from, to)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="control.remap_+3A_control">control</code></td>
<td>
<p>An object of class <code>control.list</code>.</p>
</td></tr>
<tr><td><code id="control.remap_+3A_from">from</code></td>
<td>
<p>Prefix of the source of control parameters.</p>
</td></tr>
<tr><td><code id="control.remap_+3A_to">to</code></td>
<td>
<p>Prefix of the destination of control parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>control.list</code> object.
</p>


<h3>Author(s)</h3>

<p>Pavel N. Krivitsky
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.control.list">print.control.list</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
(l &lt;- set.control.class("test", list(a.x=1, a.y=2)))
control.remap(l, "a", "b")

</code></pre>

<hr>
<h2 id='default_options'>Set <code><a href="base.html#topic+options">options()</a></code> according to a named list, skipping those already
set.</h2><span id='topic+default_options'></span>

<h3>Description</h3>

<p>This function can be useful for setting default options, which do
not override options set elsewhere.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default_options(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="default_options_+3A_...">...</code></td>
<td>
<p>see <code><a href="base.html#topic+options">options()</a></code>: either a list of <code>name=value</code> pairs or
a single unnamed argument giving a named list of options to set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The return value is same as that of <code><a href="base.html#topic+options">options()</a></code> (omitting
options already set).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>options(onesetting=1)

default_options(onesetting=2, anothersetting=3)
stopifnot(getOption("onesetting")==1) # Still 1.
stopifnot(getOption("anothersetting")==3)

default_options(list(yetanothersetting=5, anothersetting=4))
stopifnot(getOption("anothersetting")==3) # Still 3.
stopifnot(getOption("yetanothersetting")==5)
</code></pre>

<hr>
<h2 id='deInf'>Truncate values of high magnitude in a vector.</h2><span id='topic+deInf'></span>

<h3>Description</h3>

<p>Truncate values of high magnitude in a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deInf(x, replace = 1/.Machine$double.eps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deInf_+3A_x">x</code></td>
<td>
<p>a numeric or integer vector.</p>
</td></tr>
<tr><td><code id="deInf_+3A_replace">replace</code></td>
<td>
<p>a number or a string <code>"maxint"</code> or <code>"intmax"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>x</code> with elements whose magnitudes exceed <code>replace</code>
replaced replaced by <code>replace</code> (or its negation). If <code>replace</code> is
<code>"maxint"</code> or <code>"intmax"</code>, <code>.Machine$integer.max</code> is used instead.
</p>
<p><code>NA</code> and <code>NAN</code> values are preserved.
</p>

<hr>
<h2 id='deprecation-utilities'>Utilities to help with deprecating functions.</h2><span id='topic+deprecation-utilities'></span><span id='topic+.Deprecate_once'></span><span id='topic+.Deprecate_method'></span>

<h3>Description</h3>

<p><code>.Deprecate_once</code> calls <code><a href="base.html#topic+.Deprecated">.Deprecated()</a></code>, passing all its arguments
through, but only the first time it's called.
</p>
<p><code>.Deprecate_method</code> calls
<code><a href="base.html#topic+.Deprecated">.Deprecated()</a></code>, but only if a method has been called by name,
i.e., <code><var>METHOD</var>.<var>CLASS</var></code>. Like <code>.Deprecate_once</code> it
only issues a warning the first time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.Deprecate_once(...)

.Deprecate_method(generic, class)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deprecation-utilities_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="base.html#topic+.Deprecated">.Deprecated()</a></code>.</p>
</td></tr>
<tr><td><code id="deprecation-utilities_+3A_generic">generic</code>, <code id="deprecation-utilities_+3A_class">class</code></td>
<td>
<p>strings giving the generic function name and
class name of the function to be deprecated.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
options(warn=1) # Print warning immediately after the call.
f &lt;- function(){
   .Deprecate_once("new_f")
}
f() # Deprecation warning
f() # No deprecation warning

## End(Not run)
## Not run: 
options(warn=1) # Print warning immediately after the call.
summary.packageDescription &lt;- function(object, ...){
   .Deprecate_method("summary", "packageDescription")
   invisible(object)
}

summary(packageDescription("statnet.common")) # No warning.
summary.packageDescription(packageDescription("statnet.common")) # Warning.
summary.packageDescription(packageDescription("statnet.common")) # No warning.

## End(Not run)
</code></pre>

<hr>
<h2 id='despace'>A one-line function to strip whitespace from its argument.</h2><span id='topic+despace'></span>

<h3>Description</h3>

<p>A one-line function to strip whitespace from its argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>despace(s)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="despace_+3A_s">s</code></td>
<td>
<p>a character vector.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>stopifnot(despace("\n \t  ")=="")
</code></pre>

<hr>
<h2 id='diff.control.list'>Identify and the differences between two control lists.</h2><span id='topic+diff.control.list'></span><span id='topic+print.diff.control.list'></span>

<h3>Description</h3>

<p>Identify and the differences between two control lists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'control.list'
diff(x, y = eval(call(class(x)[[1L]])), ignore.environment = TRUE, ...)

## S3 method for class 'diff.control.list'
print(x, ..., indent = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diff.control.list_+3A_x">x</code></td>
<td>
<p>a <code>control.list</code></p>
</td></tr>
<tr><td><code id="diff.control.list_+3A_y">y</code></td>
<td>
<p>a reference <code>control.list</code>; defaults to the default
settings for <code>x</code>.</p>
</td></tr>
<tr><td><code id="diff.control.list_+3A_ignore.environment">ignore.environment</code></td>
<td>
<p>whether environment for
environment-bearing parameters (such as formulas and functions)
should be considered when comparing.</p>
</td></tr>
<tr><td><code id="diff.control.list_+3A_...">...</code></td>
<td>
<p>Additional arguments to methods.</p>
</td></tr>
<tr><td><code id="diff.control.list_+3A_indent">indent</code></td>
<td>
<p>an argument for recursive calls, to facilitate
indentation of nested lists.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>diff.control.list</code>: a named list with
an element for each non-identical setting. The element is either
itself a <code>diff.control.list</code> (if the setting is a control list)
or a named list with elements <code>x</code> and <code>y</code>, containing <code>x</code>'s and
<code>y</code>'s values of the parameter for that setting.
</p>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>print(diff.control.list)</code>: A print method.
</p>
</li></ul>

<hr>
<h2 id='empty_env'>Replace an object's environment with a simple, static environment.</h2><span id='topic+empty_env'></span><span id='topic+base_env'></span>

<h3>Description</h3>

<p>Replace an object's environment with a simple, static environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>empty_env(object)

base_env(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="empty_env_+3A_object">object</code></td>
<td>
<p>An object with the <code style="white-space: pre;">&#8288;environment()&lt;-&#8288;</code> method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same type as <code>object</code>, with updated environment.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- y~x
environment(f) # GlobalEnv

environment(empty_env(f)) # EmptyEnv



environment(base_env(f)) # base package environment


</code></pre>

<hr>
<h2 id='ERRVL'>Return the first argument passed (out of any number) that is not a
<code>try-error</code> (result of <code><a href="base.html#topic+try">try</a></code> encountering an error.</h2><span id='topic+ERRVL'></span>

<h3>Description</h3>

<p>This function is inspired by <code><a href="#topic+NVL">NVL</a></code>, and simply returns the first
argument that is not a <code>try-error</code>, raising an error if all arguments
are <code>try-error</code>s.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ERRVL(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ERRVL_+3A_...">...</code></td>
<td>
<p>Expressions to be tested; usually outputs of
<code><a href="base.html#topic+try">try</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The first argument that is not a <code>try-error</code>. Stops
with an error if all are.
</p>


<h3>Note</h3>

<p>This function uses lazy evaluation, so, for example <code>ERRVL(1, stop("Error!"))</code> will never evaluate the <code><a href="base.html#topic+stop">stop</a></code> call and will
not produce an error, whereas <code>ERRVL(try(solve(0)), stop("Error!"))</code> would.
</p>
<p>In addition, all expressions after the first may contain a <code>.</code>,
which is substituted with the <code>try-error</code> object returned by the
previous expression.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+try">try</a></code>, <code><a href="base.html#topic+inherits">inherits</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
print(ERRVL(1,2,3)) # 1
print(ERRVL(try(solve(0)),2,3)) # 2
print(ERRVL(1, stop("Error!"))) # No error

## Not run: 
# Error:
print(ERRVL(try(solve(0), silent=TRUE),
            stop("Error!")))

# Error with an elaborate message:
print(ERRVL(try(solve(0), silent=TRUE),
            stop("Stopped with an error: ", .)))

## End(Not run)
</code></pre>

<hr>
<h2 id='fixed.pval'>Format a p-value in fixed notation.</h2><span id='topic+fixed.pval'></span>

<h3>Description</h3>

<p>This is a thin wrapper around <code><a href="base.html#topic+format.pval">format.pval()</a></code> that guarantees fixed
(not scientific) notation, links (by default) the <code>eps</code> argument to
the <code>digits</code> argument and vice versa, and sets <code>nsmall</code> to equal
<code>digits</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixed.pval(
  pv,
  digits = max(1, getOption("digits") - 2),
  eps = 10^-digits,
  na.form = "NA",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixed.pval_+3A_pv">pv</code>, <code id="fixed.pval_+3A_digits">digits</code>, <code id="fixed.pval_+3A_eps">eps</code>, <code id="fixed.pval_+3A_na.form">na.form</code>, <code id="fixed.pval_+3A_...">...</code></td>
<td>
<p>see <code><a href="base.html#topic+format.pval">format.pval()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pvs &lt;- 10^((0:-12)/2)

# Jointly:
fpf &lt;- fixed.pval(pvs, digits = 3)
fpf
format.pval(pvs, digits = 3) # compare

# Individually:
fpf &lt;- sapply(pvs, fixed.pval, digits = 3)
fpf
sapply(pvs, format.pval, digits = 3) # compare

# Control eps:
fpf &lt;- sapply(pvs, fixed.pval, eps = 1e-3)
fpf

</code></pre>

<hr>
<h2 id='forkTimeout'>Evaluate an <span class="rlang"><b>R</b></span> expression with a hard time limit by forking a process</h2><span id='topic+forkTimeout'></span>

<h3>Description</h3>

<p>This function uses
<code><a href="parallel.html#topic+mcparallel">parallel::mcparallel()</a></code>,
</p>
<p>so the time limit is not
enforced on Windows. However, unlike functions using <code><a href="base.html#topic+setTimeLimit">setTimeLimit()</a></code>, the time
limit is enforced even on native code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forkTimeout(
  expr,
  timeout,
  unsupported = c("warning", "error", "message", "silent"),
  onTimeout = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forkTimeout_+3A_expr">expr</code></td>
<td>
<p>expression to be evaluated.</p>
</td></tr>
<tr><td><code id="forkTimeout_+3A_timeout">timeout</code></td>
<td>
<p>number of seconds to wait for the expression to
evaluate.</p>
</td></tr>
<tr><td><code id="forkTimeout_+3A_unsupported">unsupported</code></td>
<td>
<p>a character vector of length 1 specifying how to
handle a platform that does not support
<code><a href="parallel.html#topic+mcparallel">parallel::mcparallel()</a></code>,
</p>

<dl>
<dt><code>"warning"</code> or <code>"message"</code></dt><dd><p>Issue a warning or a message,
respectively, then evaluate the expression without the time limit
enforced.</p>
</dd>
<dt><code>"error"</code></dt><dd><p>Stop with an error.</p>
</dd>
<dt><code>"silent"</code></dt><dd><p>Evaluate the expression without the time limit
enforced, without any notice.</p>
</dd>
</dl>
<p> Partial matching is used.</p>
</td></tr>
<tr><td><code id="forkTimeout_+3A_ontimeout">onTimeout</code></td>
<td>
<p>Value to be returned on time-out.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Result of evaluating <code>expr</code> if completed, <code>onTimeout</code>
otherwise.
</p>


<h3>Note</h3>

<p><code>onTimeout</code> can itself be an expression, so it is, for
example, possible to stop with an error by passing
<code>onTimeout=stop()</code>.
</p>
<p>Note that this function is not completely transparent:
side-effects may behave in unexpected ways. In particular, RNG
state will not be updated.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
forkTimeout({Sys.sleep(1); TRUE}, 2) # TRUE
forkTimeout({Sys.sleep(1); TRUE}, 0.5) # NULL (except on Windows)
</code></pre>

<hr>
<h2 id='formula.utilities'>Functions for Querying, Validating and Extracting from Formulas</h2><span id='topic+formula.utilities'></span><span id='topic+append_rhs.formula'></span><span id='topic+append.rhs.formula'></span><span id='topic+filter_rhs.formula'></span><span id='topic+nonsimp_update.formula'></span><span id='topic+nonsimp.update.formula'></span><span id='topic+term.list.formula'></span><span id='topic+list_summands.call'></span><span id='topic+list_rhs.formula'></span><span id='topic+eval_lhs.formula'></span>

<h3>Description</h3>

<p>A suite of utilities for handling model formulas of the style used in Statnet packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>append_rhs.formula(
  object = NULL,
  newterms,
  keep.onesided = FALSE,
  env = if (is.null(object)) NULL else environment(object)
)

append.rhs.formula(object, newterms, keep.onesided = FALSE)

filter_rhs.formula(object, f, ...)

nonsimp_update.formula(object, new, ..., from.new = FALSE)

nonsimp.update.formula(object, new, ..., from.new = FALSE)

term.list.formula(rhs, sign = +1)

list_summands.call(object)

list_rhs.formula(object)

eval_lhs.formula(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formula.utilities_+3A_object">object</code></td>
<td>
<p>formula object to be updated or evaluated</p>
</td></tr>
<tr><td><code id="formula.utilities_+3A_newterms">newterms</code></td>
<td>
<p>a <code><a href="#topic+term_list">term_list</a></code> object, or any list of terms (names
or calls) to append to the formula, or a formula whose RHS terms
will be used; its <code>"sign"</code> attribute vector can give the sign of
each term (<code>+1</code> or <code>-1</code>), and its <code>"env"</code> attribute
vector will be used to set its environment, with the first
available being used and subsequent ones producing a warning.</p>
</td></tr>
<tr><td><code id="formula.utilities_+3A_keep.onesided">keep.onesided</code></td>
<td>
<p>if the initial formula is one-sided, keep it
whether to keep it one-sided or whether to make the initial
formula the new LHS</p>
</td></tr>
<tr><td><code id="formula.utilities_+3A_env">env</code></td>
<td>
<p>an environment for the new formula, if <code>object</code> is
<code>NULL</code></p>
</td></tr>
<tr><td><code id="formula.utilities_+3A_f">f</code></td>
<td>
<p>a function whose first argument is the term and whose
additional arguments are forwarded from <code>...</code> that returns either
<code>TRUE</code> or <code>FALSE</code>, for whether that term should be kept.</p>
</td></tr>
<tr><td><code id="formula.utilities_+3A_...">...</code></td>
<td>
<p>Additional arguments. Currently unused.</p>
</td></tr>
<tr><td><code id="formula.utilities_+3A_new">new</code></td>
<td>
<p>new formula to be used in updating</p>
</td></tr>
<tr><td><code id="formula.utilities_+3A_from.new">from.new</code></td>
<td>
<p>logical or character vector of variable names. controls how
environment of formula gets updated.</p>
</td></tr>
<tr><td><code id="formula.utilities_+3A_rhs">rhs</code>, <code id="formula.utilities_+3A_sign">sign</code></td>
<td>
<p>Arguments to the deprecated <code>term.list.formula</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>append_rhs.formula</code> each return an updated formula
object; if <code>object</code> is <code>NULL</code> (the default), a one-sided formula
containing only the terms in <code>newterms</code> will be returned.
</p>
<p><code>nonsimp_update.formula</code> each return an
updated formula object
</p>
<p><code>list_summands.call</code> returns an object of type
<code><a href="#topic+term_list">term_list</a></code>; its <code>"env"</code> attribute is set to a list of
<code>NULL</code>s, however.
</p>
<p><code>list_rhs.formula</code> returns an object of type <code><a href="#topic+term_list">term_list</a></code>.
</p>
<p><code>eval_lhs.formula</code> an object of whatever type the LHS evaluates to.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>append_rhs.formula()</code>: <code>append_rhs.formula</code> appends a list of terms to the RHS of a
formula. If the formula is one-sided, the RHS becomes the LHS, if
<code>keep.onesided==FALSE</code> (the default).
</p>
</li>
<li> <p><code>append.rhs.formula()</code>: <code>append.rhs.formula</code> has been renamed to <code>append_rhs.formula</code>.
</p>
</li>
<li> <p><code>filter_rhs.formula()</code>: <code>filter_rhs.formula</code> filters through the terms in the RHS of a
formula, returning a formula without the terms for which function
<code>f(term, ...)</code> is <code>FALSE</code>. Terms inside another term (e.g.,
parentheses or an operator other than + or -) will be unaffected.
</p>
</li>
<li> <p><code>nonsimp_update.formula()</code>: <code>nonsimp_update.formula</code> is a reimplementation of
<code><a href="stats.html#topic+update.formula">update.formula</a></code> that does not simplify.  Note that the
resulting formula's environment is set as follows. If
<code>from.new==FALSE</code>, it is set to that of object. Otherwise, a new
sub-environment of object, containing, in addition, variables in new listed
in from.new (if a character vector) or all of new (if TRUE).
</p>
</li>
<li> <p><code>nonsimp.update.formula()</code>: <code>nonsimp.update.formula</code> has been renamed to <code>nonsimp_update.formula</code>.
</p>
</li>
<li> <p><code>term.list.formula()</code>: <code>term.list.formula</code> is an older version of <code>list_rhs.formula</code> that required the RHS call, rather than the formula itself.
</p>
</li>
<li> <p><code>list_summands.call()</code>: <code>list_summands.call</code>, given an unevaluated call or expression
containing the sum of one or more terms, returns an object of class <code><a href="#topic+term_list">term_list</a></code> with the
terms being summed, handling <code>+</code> and <code>-</code> operators and
parentheses, and keeping track of whether a term has a plus or a
minus sign.
</p>
</li>
<li> <p><code>list_rhs.formula()</code>: <code>list_rhs.formula</code> returns an object of type <code><a href="#topic+term_list">term_list</a></code>,
containing terms in a given formula, handling <code>+</code> and <code>-</code>
operators and parentheses, and keeping track of whether a term has
a plus or a minus sign.
</p>
</li>
<li> <p><code>eval_lhs.formula()</code>: <code>eval_lhs.formula</code> extracts the LHS of a formula, evaluates it in the formula's environment, and returns the result.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
## append_rhs.formula

(f1 &lt;- append_rhs.formula(y~x,list(as.name("z1"),as.name("z2"))))
(f2 &lt;- append_rhs.formula(~y,list(as.name("z"))))
(f3 &lt;- append_rhs.formula(~y+x,structure(list(as.name("z")),sign=-1)))
(f4 &lt;- append_rhs.formula(~y,list(as.name("z")),TRUE))
(f5 &lt;- append_rhs.formula(y~x,~z1-z2))
(f6 &lt;- append_rhs.formula(NULL,list(as.name("z"))))
(f7 &lt;- append_rhs.formula(NULL,structure(list(as.name("z")),sign=-1)))

fe &lt;- ~z2+z3
environment(fe) &lt;- new.env()
(f8 &lt;- append_rhs.formula(NULL, fe)) # OK
(f9 &lt;- append_rhs.formula(y~x, fe)) # Warning
(f10 &lt;- append_rhs.formula(y~x, fe, env=NULL)) # No warning, environment from fe.
(f11 &lt;- append_rhs.formula(fe, ~z1)) # Warning, environment from fe



## filter_rhs.formula
(f1 &lt;- filter_rhs.formula(~a-b+c, `!=`, "a"))
(f2 &lt;- filter_rhs.formula(~-a+b-c, `!=`, "a"))
(f3 &lt;- filter_rhs.formula(~a-b+c, `!=`, "b"))
(f4 &lt;- filter_rhs.formula(~-a+b-c, `!=`, "b"))
(f5 &lt;- filter_rhs.formula(~a-b+c, `!=`, "c"))
(f6 &lt;- filter_rhs.formula(~-a+b-c, `!=`, "c"))
(f7 &lt;- filter_rhs.formula(~c-a+b-c(a),
                          function(x) (if(is.call(x)) x[[1]] else x)!="c"))




stopifnot(identical(list_rhs.formula(a~b),
          structure(alist(b), sign=1, env=list(globalenv()), class="term_list")))
stopifnot(identical(list_rhs.formula(~b),
          structure(alist(b), sign=1, env=list(globalenv()), class="term_list")))
stopifnot(identical(list_rhs.formula(~b+NULL),
          structure(alist(b, NULL),
                    sign=c(1,1), env=rep(list(globalenv()), 2), class="term_list")))
stopifnot(identical(list_rhs.formula(~-b+NULL),
          structure(alist(b, NULL),
                    sign=c(-1,1), env=rep(list(globalenv()), 2), class="term_list")))
stopifnot(identical(list_rhs.formula(~+b-NULL),
          structure(alist(b, NULL),
                    sign=c(1,-1), env=rep(list(globalenv()), 2), class="term_list")))
stopifnot(identical(list_rhs.formula(~+b-(NULL+c)),
          structure(alist(b, NULL, c),
                    sign=c(1,-1,-1), env=rep(list(globalenv()), 3), class="term_list")))

## eval_lhs.formula

(result &lt;- eval_lhs.formula((2+2)~1))

stopifnot(identical(result,4))
</code></pre>

<hr>
<h2 id='handle.controls'>Handle standard <code style="white-space: pre;">&#8288;control.*()&#8288;</code> function semantics.</h2><span id='topic+handle.controls'></span>

<h3>Description</h3>

<p>This function takes the arguments of its caller (whose name should
be passed explicitly), plus any <code>...</code> arguments and produces a
control list based on the standard semantics of <code style="white-space: pre;">&#8288;control.*()&#8288;</code>
functions, including handling deprecated arguments, identifying
undefined arguments, and handling arguments that should be passed
through <code><a href="base.html#topic+match.arg">match.arg()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handle.controls(myname, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="handle.controls_+3A_myname">myname</code></td>
<td>
<p>the name of the calling function.</p>
</td></tr>
<tr><td><code id="handle.controls_+3A_...">...</code></td>
<td>
<p>the <code>...</code> argument of the control function, if present.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function behaves based on the information it acquires from the calling function. Specifically,
</p>

<ul>
<li><p> The values of formal arguments (except <code>...</code>, if present) are
taken from the environment of the calling function and stored in
the list.
</p>
</li>
<li><p> If the calling function has a <code>...</code> argument <em>and</em> defines an
<code>old.controls</code> variable in its environment, then it remaps the
names in <code>...</code> to their new names based on <code>old.controls</code>. In
addition, if the value is a list with two elements, <code>action</code> and
<code>message</code>, the standard deprecation message will have <code>message</code>
appended to it and then be called with <code>action()</code>.
</p>
</li>
<li><p> If the calling function has a <code>match.arg.pars</code> in its
environment, the arguments in that list are processed through
<code><a href="base.html#topic+match.arg">match.arg()</a></code>.
</p>
</li></ul>



<h3>Value</h3>

<p>a list with formal arguments of the calling function.
</p>

<hr>
<h2 id='is.SPD'>Test if the object is a matrix that is symmetric and positive definite</h2><span id='topic+is.SPD'></span>

<h3>Description</h3>

<p>Test if the object is a matrix that is symmetric and positive definite
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.SPD(x, tol = .Machine$double.eps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.SPD_+3A_x">x</code></td>
<td>
<p>the object to be tested.</p>
</td></tr>
<tr><td><code id="is.SPD_+3A_tol">tol</code></td>
<td>
<p>the tolerance for the reciprocal condition number.</p>
</td></tr>
</table>

<hr>
<h2 id='locate_function'>Locate a function with a given name and return it and its environment.</h2><span id='topic+locate_function'></span><span id='topic+locate_prefixed_function'></span>

<h3>Description</h3>

<p>These functions first search the given environment, then search all
loaded environments, including those where the function is not
exported. If found, they return an unambiguous reference to the
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locate_function(name, env = globalenv(), ...)

locate_prefixed_function(
  name,
  prefix,
  errname,
  env = globalenv(),
  ...,
  call. = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="locate_function_+3A_name">name</code></td>
<td>
<p>a character string giving the function's name.</p>
</td></tr>
<tr><td><code id="locate_function_+3A_env">env</code></td>
<td>
<p>an <code><a href="base.html#topic+environment">environment</a></code> where it should search first.</p>
</td></tr>
<tr><td><code id="locate_function_+3A_...">...</code></td>
<td>
<p>additional arguments to the warning and error warning messages. See Details.</p>
</td></tr>
<tr><td><code id="locate_function_+3A_prefix">prefix</code></td>
<td>
<p>a character string giving the prefix, so the
searched-for function is <code>prefix.name</code>.</p>
</td></tr>
<tr><td><code id="locate_function_+3A_errname">errname</code></td>
<td>
<p>a character string; if given, if the function is not
found an error is raised, with <code>errname</code> prepended to the error
message.</p>
</td></tr>
<tr><td><code id="locate_function_+3A_call.">call.</code></td>
<td>
<p>a logical, whether the call
(<code>locate_prefixed_function</code>) should be a part of the error
message; defaults to <code>FALSE</code> (which is different from <code><a href="base.html#topic+stop">stop()</a></code>'s
default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the initial search fails, a search using
<code><a href="utils.html#topic+getAnywhere">getAnywhere()</a></code> is attempted, with exported (&quot;visible&quot;) functions
with the specified name preferred over those that are not. When
multiple equally qualified functions are available, a warning is
printed and an arbitrary one is returned.
</p>
<p>Because <code><a href="utils.html#topic+getAnywhere">getAnywhere()</a></code> can be slow, past searches are cached.
</p>


<h3>Value</h3>

<p>If the function is found, an unevaluated call of the form
<code>ENVNAME:::FUNNAME</code>, which can then be used to call the function
even if it is unexported. If the environment does not have a
name, or is <code>GlobalEnv</code>, only <code>FUNNAME</code> is returned. Otherwise,
<code>NULL</code> is returned.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>locate_function()</code>: a low-level function returning the
reference to the function named <code>name</code>, or <code>NULL</code> if not found.
</p>
</li>
<li> <p><code>locate_prefixed_function()</code>: a helper function that searches for a
function of the form <code>prefix.name</code> and produces an informative
error message if not found.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
# Locate a random function in base.
locate_function(".row_names_info")

</code></pre>

<hr>
<h2 id='logspace.utils'>Utilities for performing calculations on logarithmic scale.</h2><span id='topic+logspace.utils'></span><span id='topic+log_sum_exp'></span><span id='topic+log_mean_exp'></span><span id='topic+lweighted.mean'></span><span id='topic+lweighted.var'></span><span id='topic+lweighted.cov'></span>

<h3>Description</h3>

<p>A small suite of functions to compute sums, means, and weighted means on
logarithmic scale, minimizing loss of precision.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_sum_exp(logx, use_ldouble = FALSE)

log_mean_exp(logx, use_ldouble = FALSE)

lweighted.mean(x, logw)

lweighted.var(x, logw)

lweighted.cov(x, y, logw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logspace.utils_+3A_logx">logx</code></td>
<td>
<p>Numeric vector of <code class="reqn">\log(x)</code>, the natural logarithms of the
values to be summed or averaged.</p>
</td></tr>
<tr><td><code id="logspace.utils_+3A_use_ldouble">use_ldouble</code></td>
<td>
<p>Whether to use <code>long double</code> precision in the
calculation. If <code>TRUE</code>, 's C built-in <code>logspace_sum()</code> is used. If
<code>FALSE</code>, the package's own implementation based on it is used, using
<code>double</code> precision, which is (on most systems) several times faster, at
the cost of precision.</p>
</td></tr>
<tr><td><code id="logspace.utils_+3A_x">x</code>, <code id="logspace.utils_+3A_y">y</code></td>
<td>
<p>Numeric vectors or matrices of <code class="reqn">x</code> and <code class="reqn">y</code>, the (raw) values
to be summed, averaged, or whose variances and covariances are to
be calculated.</p>
</td></tr>
<tr><td><code id="logspace.utils_+3A_logw">logw</code></td>
<td>
<p>Numeric vector of <code class="reqn">\log(w)</code>, the natural logarithms of the
weights.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The functions return the equivalents of the R expressions given below,
but faster and with less loss of precision.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>log_sum_exp()</code>: <code>log(sum(exp(logx)))</code>
</p>
</li>
<li> <p><code>log_mean_exp()</code>: <code>log(mean(exp(logx)))</code>
</p>
</li>
<li> <p><code>lweighted.mean()</code>: weighted mean of <code>x</code>:
<code>sum(x*exp(logw))/sum(exp(logw))</code> for <code>x</code> scalar and
<code>colSums(x*exp(logw))/sum(exp(logw))</code> for <code>x</code> matrix
</p>
</li>
<li> <p><code>lweighted.var()</code>: weighted variance of <code>x</code>: <code>crossprod(x-lweighted.mean(x,logw)*exp(logw/2))/sum(exp(logw))</code>
</p>
</li>
<li> <p><code>lweighted.cov()</code>: weighted covariance between <code>x</code> and <code>y</code>: <code>crossprod(x-lweighted.mean(x,logw)*exp(logw/2), y-lweighted.mean(y,logw)*exp(logw/2))/sum(exp(logw))</code>
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Pavel N. Krivitsky
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(1000)
stopifnot(all.equal(log_sum_exp(x), log(sum(exp(x))), check.attributes=FALSE))
stopifnot(all.equal(log_mean_exp(x), log(mean(exp(x))), check.attributes=FALSE))

logw &lt;- rnorm(1000)
stopifnot(all.equal(m &lt;- sum(x*exp(logw))/sum(exp(logw)),lweighted.mean(x, logw)))
stopifnot(all.equal(sum((x-m)^2*exp(logw))/sum(exp(logw)),
                    lweighted.var(x, logw), check.attributes=FALSE))

x &lt;- cbind(x, rnorm(1000))
stopifnot(all.equal(mx &lt;- colSums(x*exp(logw))/sum(exp(logw)),
                    lweighted.mean(x, logw), check.attributes=FALSE))
stopifnot(all.equal(crossprod(t(t(x)-mx)*exp(logw/2))/sum(exp(logw)),
                    lweighted.var(x, logw), check.attributes=FALSE))


y &lt;- cbind(x, rnorm(1000))
my &lt;- colSums(y*exp(logw))/sum(exp(logw))
stopifnot(all.equal(crossprod(t(t(x)-mx)*exp(logw/2), t(t(y)-my)*exp(logw/2))/sum(exp(logw)),
                    lweighted.cov(x, y, logw), check.attributes=FALSE))
stopifnot(all.equal(crossprod(t(t(y)-my)*exp(logw/2), t(t(x)-mx)*exp(logw/2))/sum(exp(logw)),
                    lweighted.cov(y, x, logw), check.attributes=FALSE))
</code></pre>

<hr>
<h2 id='mcmc-utilities'>Utility operations for <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> objects</h2><span id='topic+mcmc-utilities'></span><span id='topic+colMeans.mcmc.list'></span><span id='topic+sweep.mcmc.list'></span><span id='topic+lapply.mcmc.list'></span>

<h3>Description</h3>

<p><code>colMeans.mcmc.list</code> is a &quot;method&quot; for (non-generic) <code><a href="Matrix.html#topic+colMeans">colMeans</a></code> applicable to <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> objects.
</p>
<p><code>sweep.mcmc.list</code> is a &quot;method&quot; for (non-generic)
<code><a href="base.html#topic+sweep">sweep</a></code> applicable to <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> objects.
</p>
<p><code>lapply.mcmc.list</code> is a &quot;method&quot; for (non-generic)
<code><a href="base.html#topic+lapply">lapply</a></code> applicable to <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colMeans.mcmc.list(x, ...)

sweep.mcmc.list(x, STATS, FUN = "-", check.margin = TRUE, ...)

lapply.mcmc.list(X, FUN, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmc-utilities_+3A_x">x</code></td>
<td>
<p>a <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> object.</p>
</td></tr>
<tr><td><code id="mcmc-utilities_+3A_...">...</code></td>
<td>
<p>additional arguments to <code><a href="Matrix.html#topic+colMeans">colMeans</a></code> or
<code><a href="base.html#topic+sweep">sweep</a></code>.</p>
</td></tr>
<tr><td><code id="mcmc-utilities_+3A_stats">STATS</code>, <code id="mcmc-utilities_+3A_fun">FUN</code>, <code id="mcmc-utilities_+3A_check.margin">check.margin</code></td>
<td>
<p>See help for <code><a href="base.html#topic+sweep">sweep</a></code>.</p>
</td></tr>
<tr><td><code id="mcmc-utilities_+3A_x">X</code></td>
<td>
<p>An <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>colMeans.mcmc</code> returns a vector with length equal to
the number of mcmc chains in <code>x</code> with the mean value for
each chain.
</p>
<p><code>sweep.mcmc.list</code> returns an appropriately modified
version of <code>x</code>
</p>
<p><code>lapply.mcmc.list</code> returns an <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> each of
whose chains had been passed through <code>FUN</code>.
</p>


<h3>See Also</h3>

<p><code><a href="Matrix.html#topic+colMeans">colMeans</a></code>, <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code>
</p>
<p><code><a href="base.html#topic+sweep">sweep</a></code>
</p>
<p><code><a href="base.html#topic+lapply">lapply</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(line, package="coda")
summary(line) # coda
colMeans.mcmc.list(line) # "Method"

data(line, package="coda")
colMeans.mcmc.list(line)-1:3
colMeans.mcmc.list(sweep.mcmc.list(line, 1:3))

data(line, package="coda")
colMeans.mcmc.list(line)[c(2,3,1)]
colMeans.mcmc.list(lapply.mcmc.list(line, `[`,,c(2,3,1)))

</code></pre>

<hr>
<h2 id='message_print'><code><a href="base.html#topic+print">print</a></code> objects to the <code><a href="base.html#topic+message">message</a></code> output.</h2><span id='topic+message_print'></span>

<h3>Description</h3>

<p>A thin wrapper around <code><a href="base.html#topic+print">print</a></code> that captures its output and prints
it as a <code><a href="base.html#topic+message">message</a></code>, usually to STDERR.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>message_print(..., messageArgs = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="message_print_+3A_...">...</code></td>
<td>
<p>arguments to <code><a href="base.html#topic+print">print</a></code>.</p>
</td></tr>
<tr><td><code id="message_print_+3A_messageargs">messageArgs</code></td>
<td>
<p>a list of arguments to be passed directly to <code><a href="base.html#topic+message">message</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>cat(1:5)

print(1:5)
message_print(1:5) # Looks the same (though may be in a different color on some frontends).

suppressMessages(print(1:5)) # Still prints
suppressMessages(message_print(1:5)) # Silenced
</code></pre>

<hr>
<h2 id='NVL'>Convenience functions for handling <code><a href="base.html#topic+NULL">NULL</a></code> objects.</h2><span id='topic+NVL'></span><span id='topic+NVL2'></span><span id='topic+NVL3'></span><span id='topic+EVL'></span><span id='topic+EVL2'></span><span id='topic+EVL3'></span><span id='topic+NVL+3C-'></span><span id='topic+EVL+3C-'></span>

<h3>Description</h3>

<p>Convenience functions for handling <code><a href="base.html#topic+NULL">NULL</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NVL(...)

NVL2(test, notnull, null = NULL)

NVL3(test, notnull, null = NULL)

EVL(...)

EVL2(test, notnull, null = NULL)

EVL3(test, notnull, null = NULL)

NVL(x) &lt;- value

EVL(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NVL_+3A_...">...</code>, <code id="NVL_+3A_test">test</code></td>
<td>
<p>expressions to be tested.</p>
</td></tr>
<tr><td><code id="NVL_+3A_notnull">notnull</code></td>
<td>
<p>expression to be returned if <code>test</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="NVL_+3A_null">null</code></td>
<td>
<p>expression to be returned if <code>test</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="NVL_+3A_x">x</code></td>
<td>
<p>an object to be overwritten if <code><a href="base.html#topic+NULL">NULL</a></code>.</p>
</td></tr>
<tr><td><code id="NVL_+3A_value">value</code></td>
<td>
<p>new value for <code>x</code>.</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>NVL()</code>: Inspired by SQL function <code>NVL</code>, returns the first argument
that is not <code>NULL</code>, or <code>NULL</code> if all arguments are
<code>NULL</code>.
</p>
</li>
<li> <p><code>NVL2()</code>: Inspired by Oracle SQL function <code>NVL2</code>, returns the second argument
if the first argument is not <code>NULL</code> and the third argument if the
first argument is <code>NULL</code>. The third argument defaults to <code>NULL</code>, so
<code>NVL2(a, b)</code> can serve as shorthand for <code>(if(!is.null(a)) b)</code>.
</p>
</li>
<li> <p><code>NVL3()</code>: Inspired by Oracle SQL <code>NVL2</code> function and <code>magittr</code> <code>%&gt;%</code>
operator, behaves as <code>NVL2</code> but <code>.</code>s in the second argument are
substituted with the first argument.
</p>
</li>
<li> <p><code>EVL()</code>: As <code>NVL</code>, but for any objects of length 0 (<em>E</em>mpty) rather than just <code>NULL</code>. Note that if no non-zero-length arguments are given, <code>NULL</code> is returned.
</p>
</li>
<li> <p><code>EVL2()</code>: As <code>NVL2</code>, but for any objects of length 0 (<em>E</em>mpty) rather than just <code>NULL</code>.
</p>
</li>
<li> <p><code>EVL3()</code>: As <code>NVL3</code>, but for any objects of length 0 (<em>E</em>mpty) rather than just <code>NULL</code>.
</p>
</li>
<li> <p><code>NVL(x) &lt;- value</code>: Assigning to <code>NVL</code> overwrites its first argument if that argument
is <code><a href="base.html#topic+NULL">NULL</a></code>. Note that it will <em>always</em> return the right-hand-side
of the assignment (<code>value</code>), regardless of what <code>x</code> is.
</p>
</li>
<li> <p><code>EVL(x) &lt;- value</code>: As assignment to <code>NVL</code>, but for any objects of length 0 (<em>E</em>mpty) rather than just <code>NULL</code>.
</p>
</li></ul>


<h3>Note</h3>

<p>Whenever possible, these functions use lazy evaluation, so,
for example <code>NVL(1, stop("Error!"))</code> will never evaluate the
<code><a href="base.html#topic+stop">stop</a></code> call and will not produce an error, whereas <code>NVL(NULL, stop("Error!"))</code> would.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+NULL">NULL</a></code>, <code><a href="base.html#topic+is.null">is.null</a></code>, <code><a href="base.html#topic+if">if</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- NULL

a # NULL
NVL(a,0) # 0

b &lt;- 1

b # 1
NVL(b,0) # 1

# Here, object x does not exist, but since b is not NULL, x is
# never evaluated, so the statement finishes.
NVL(b,x) # 1

# Also,
NVL(NULL,1,0) # 1
NVL(NULL,0,1) # 0
NVL(NULL,NULL,0) # 0
NVL(NULL,NULL,NULL) # NULL

NVL2(a, "not null!", "null!") # "null!"
NVL2(b, "not null!", "null!") # "not null!"

NVL3(a, "not null!", "null!") # "null!"
NVL3(b, .+1, "null!") # 2

NVL(NULL*2, 1) # numeric(0) is not NULL
EVL(NULL*2, 1) # 1


NVL(a) &lt;- 2
a # 2
NVL(b) &lt;- 2
b # still 1
</code></pre>

<hr>
<h2 id='once'>Evaluate a function once for a given input.</h2><span id='topic+once'></span>

<h3>Description</h3>

<p>This is a <code>purrr</code>-style adverb that checks if a given function has
already been called with a given configuration of arguments and
skips it if it has.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>once(f, expire_after = Inf, max_entries = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="once_+3A_f">f</code></td>
<td>
<p>A function to modify.</p>
</td></tr>
<tr><td><code id="once_+3A_expire_after">expire_after</code></td>
<td>
<p>The number of seconds since it was added to the
database before a particular configuration is &quot;forgotten&quot;. This
can be used to periodically remind the user without overwhelming
them.</p>
</td></tr>
<tr><td><code id="once_+3A_max_entries">max_entries</code></td>
<td>
<p>The number of distinct configurations to
remember. If not <code>Inf</code>, <em>earliest-inserted</em> configurations will
be removed from the database when capacity is exceeded. (This
exact behavior may change in the future.)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each modified function instance returned by <code>once()</code>
maintains a database of previous argument configurations. They
are not in any way compressed, so this database may grow over
time. Thus, this wrapper should be used with caution if arguments
are large objects. This may be replaced with hashing in the
future. In the meantime, you may want to set the <code>max_entries</code>
argument to be safe.
</p>
<p>Different instances of a modified function do not share
databases, even if the function is the same. This means that if
you, say, modify a function within another function, the modified
function will call once per call to the outer function. Modified
functions defined at package level count as the same &quot;instance&quot;,
however. See example.
</p>


<h3>Note</h3>

<p>Because the function needs to test whether a particular
configuration of arguments have already been used, do not rely on
lazy evaluation behaviour.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>msg &lt;- once(message)
msg("abc") # Prints.
msg("abc") # Silent.

msg &lt;- once(message) # Starts over.
msg("abc") # Prints.

f &lt;- function(){
  innermsg  &lt;- once(message)
  innermsg("efg") # Prints once per call to f().
  innermsg("efg") # Silent.
  msg("abcd") # Prints only the first time f() is called.
  msg("abcd") # Silent.
}
f() # Prints "efg" and "abcd".
f() # Prints only "efg".

msg3 &lt;- once(message, max_entries=3)
msg3("a") # 1 remembered.
msg3("a") # Silent.
msg3("b") # 2 remembered.
msg3("a") # Silent.
msg3("c") # 3 remembered.
msg3("a") # Silent.
msg3("d") # "a" forgotten.
msg3("a") # Printed.

msg2s &lt;- once(message, expire_after=2)
msg2s("abc") # Prints.
msg2s("abc") # Silent.
Sys.sleep(1)
msg2s("abc") # Silent after 1 sec.
Sys.sleep(1.1)
msg2s("abc") # Prints after 2.1 sec.

</code></pre>

<hr>
<h2 id='opttest'>Optionally test code depending on environment variable.</h2><span id='topic+opttest'></span>

<h3>Description</h3>

<p>A convenience wrapper to run code based on whether an environment variable
is defined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opttest(
  expr,
  testname = NULL,
  testvar = "ENABLE_statnet_TESTS",
  yesvals = c("y", "yes", "t", "true", "1"),
  lowercase = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opttest_+3A_expr">expr</code></td>
<td>
<p>An expression to be evaluated only if <code>testvar</code> is set to a
non-empty value.</p>
</td></tr>
<tr><td><code id="opttest_+3A_testname">testname</code></td>
<td>
<p>Optional name of the test. If given, and the test is
skipped, will print a message to that end, including the name of the test,
and instructions on how to enable it.</p>
</td></tr>
<tr><td><code id="opttest_+3A_testvar">testvar</code></td>
<td>
<p>Environment variable name. If set to one of the
<code>yesvals</code>, <code>expr</code> is run. Otherwise, an optional message is
printed.</p>
</td></tr>
<tr><td><code id="opttest_+3A_yesvals">yesvals</code></td>
<td>
<p>A character vector of strings considered affirmative values
for <code>testvar</code>.</p>
</td></tr>
<tr><td><code id="opttest_+3A_lowercase">lowercase</code></td>
<td>
<p>Whether to convert the value of <code>testvar</code> to lower
case before comparing it to <code>yesvals</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='order'>Implement the <code><a href="base.html#topic+sort">sort</a></code> and <code><a href="#topic+order">order</a></code> methods for
<code><a href="base.html#topic+data.frame">data.frame</a></code> and <code><a href="base.html#topic+matrix">matrix</a></code>, sorting it in
lexicographic order.</h2><span id='topic+order'></span><span id='topic+order.default'></span><span id='topic+order.data.frame'></span><span id='topic+order.matrix'></span><span id='topic+sort.data.frame'></span>

<h3>Description</h3>

<p>These function return a data frame sorted in lexcographic order or a
permutation that will rearrange it into lexicographic order: first by the
first column, ties broken by the second, remaining ties by the third, etc..
</p>


<h3>Usage</h3>

<pre><code class='language-R'>order(..., na.last = TRUE, decreasing = FALSE)

## Default S3 method:
order(..., na.last = TRUE, decreasing = FALSE)

## S3 method for class 'data.frame'
order(..., na.last = TRUE, decreasing = FALSE)

## S3 method for class 'matrix'
order(..., na.last = TRUE, decreasing = FALSE)

## S3 method for class 'data.frame'
sort(x, decreasing = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="order_+3A_...">...</code></td>
<td>
<p>Ignored for <code>sort</code>. For <code>order</code>, first argument is
the data frame to be ordered. (This is needed for compatibility with
<code><a href="base.html#topic+order">order</a></code>.)</p>
</td></tr>
<tr><td><code id="order_+3A_na.last">na.last</code></td>
<td>
<p>See <code><a href="base.html#topic+order">order</a></code> documentation.</p>
</td></tr>
<tr><td><code id="order_+3A_decreasing">decreasing</code></td>
<td>
<p>Whether to sort in decreasing order.</p>
</td></tr>
<tr><td><code id="order_+3A_x">x</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> to sort.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>sort</code>, a data frame, sorted lexicographically. For
<code>order</code>, a permutation <code>I</code> (of a vector <code>1:nrow(x)</code>) such
that <code>x[I,,drop=FALSE]</code> equals <code>x</code> ordered lexicographically.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+data.frame">data.frame</a></code>, <code><a href="base.html#topic+sort">sort</a></code>, <code><a href="#topic+order">order</a></code>,
<code><a href="base.html#topic+matrix">matrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(iris)

head(iris)

head(order(iris))

head(sort(iris))

stopifnot(identical(sort(iris),iris[order(iris),]))
</code></pre>

<hr>
<h2 id='paste.and'>Concatenates the elements of a vector (optionaly enclosing them in quotation
marks or parentheses) adding appropriate punctuation and conjunctions.</h2><span id='topic+paste.and'></span>

<h3>Description</h3>

<p>A vector <code>x</code> becomes &quot;<code>x[1]</code>&quot;, &quot;<code>x[1]</code> and <code>x[2]</code>&quot;, or
&quot;<code>x[1]</code>, <code>x[2]</code>, and <code>x[3]</code>&quot;, depending on the langth of
<code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paste.and(x, oq = "", cq = "", con = "and")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="paste.and_+3A_x">x</code></td>
<td>
<p>A vector.</p>
</td></tr>
<tr><td><code id="paste.and_+3A_oq">oq</code></td>
<td>
<p>Opening quotation symbol. (Defaults to none.)</p>
</td></tr>
<tr><td><code id="paste.and_+3A_cq">cq</code></td>
<td>
<p>Closing quotation symbol. (Defaults to none.)</p>
</td></tr>
<tr><td><code id="paste.and_+3A_con">con</code></td>
<td>
<p>Conjunction to be used if <code>length(x)&gt;1</code>. (Defaults to &quot;and&quot;.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string with the output.
</p>


<h3>See Also</h3>

<p>paste, cat
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
print(paste.and(c()))

print(paste.and(1))

print(paste.and(1:2))

print(paste.and(1:3))

print(paste.and(1:4,con='or'))
</code></pre>

<hr>
<h2 id='persistEval'>Evaluate an expression, restarting on error</h2><span id='topic+persistEval'></span><span id='topic+persistEvalQ'></span>

<h3>Description</h3>

<p>A pair of functions paralleling <code><a href="base.html#topic+eval">eval()</a></code> and <code><a href="base.html#topic+evalq">evalq()</a></code> that make
multiple attempts at evaluating an expression, retrying on error up
to a specified number of attempts, and optionally evaluating
another expression before restarting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>persistEval(
  expr,
  retries = NVL(getOption("eval.retries"), 5),
  beforeRetry,
  envir = parent.frame(),
  enclos = if (is.list(envir) || is.pairlist(envir)) parent.frame() else baseenv(),
  verbose = FALSE
)

persistEvalQ(
  expr,
  retries = NVL(getOption("eval.retries"), 5),
  beforeRetry,
  envir = parent.frame(),
  enclos = if (is.list(envir) || is.pairlist(envir)) parent.frame() else baseenv(),
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="persistEval_+3A_expr">expr</code></td>
<td>
<p>an expression to be retried; note the difference
between <code><a href="base.html#topic+eval">eval()</a></code> and <code><a href="base.html#topic+evalq">evalq()</a></code>.</p>
</td></tr>
<tr><td><code id="persistEval_+3A_retries">retries</code></td>
<td>
<p>number of retries to make; defaults to
<code>"eval.retries"</code> option, or 5.</p>
</td></tr>
<tr><td><code id="persistEval_+3A_beforeretry">beforeRetry</code></td>
<td>
<p>if given, an expression that will be evaluated
before each retry if the initial attempt fails; it is evaluated
in the same environment and with the same quoting semantics as
<code>expr</code>, but its errors are not handled.</p>
</td></tr>
<tr><td><code id="persistEval_+3A_envir">envir</code>, <code id="persistEval_+3A_enclos">enclos</code></td>
<td>
<p>see <code><a href="base.html#topic+eval">eval()</a></code>.</p>
</td></tr>
<tr><td><code id="persistEval_+3A_verbose">verbose</code></td>
<td>
<p>Whether to output retries.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Results of evaluating <code>expr</code>, including side-effects such
as variable assignments, if successful in <code>retries</code> retries.
</p>


<h3>Note</h3>

<p>If <code>expr</code> returns a <code>"try-error"</code> object (returned by
<code><a href="base.html#topic+try">try()</a></code>), it will be treated as an error. This behavior may
change in the future.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 0
persistEvalQ({if((x&lt;-x+1)&lt;3) stop("x &lt; 3") else x},
             beforeRetry = {cat("Will try incrementing...\n")})

x &lt;- 0
e &lt;- quote(if((x&lt;-x+1)&lt;3) stop("x &lt; 3") else x)
persistEval(e,
            beforeRetry = quote(cat("Will try incrementing...\n")))
</code></pre>

<hr>
<h2 id='print.control.list'>Pretty print the control list</h2><span id='topic+print.control.list'></span>

<h3>Description</h3>

<p>This function prints the control list, including what it can control and the
elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'control.list'
print(x, ..., indent = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.control.list_+3A_x">x</code></td>
<td>
<p>A list generated by a <code>control.*</code> function.</p>
</td></tr>
<tr><td><code id="print.control.list_+3A_...">...</code></td>
<td>
<p>Additional argument to print methods for individual settings.</p>
</td></tr>
<tr><td><code id="print.control.list_+3A_indent">indent</code></td>
<td>
<p>an argument for recursive calls, to facilitate indentation of nested lists.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+check.control.class">check.control.class</a></code>, <code><a href="#topic+set.control.class">set.control.class</a></code>
</p>

<hr>
<h2 id='set.control.class'>Set the class of the control list</h2><span id='topic+set.control.class'></span>

<h3>Description</h3>

<p>This function sets the class of the control list, with the default being the
name of the calling function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.control.class(
  myname = as.character(ult(sys.calls(), 2)[[1L]]),
  control = get("control", pos = parent.frame())
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set.control.class_+3A_myname">myname</code></td>
<td>
<p>Name of the class to set.</p>
</td></tr>
<tr><td><code id="set.control.class_+3A_control">control</code></td>
<td>
<p>Control list. Defaults to the <code>control</code> variable in the
calling function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The control list with class set.
</p>


<h3>Note</h3>

<p>In earlier versions, <code>OKnames</code> and <code>myname</code> were autodetected. This capability has been deprecated and results in a warning issued once per session. They now need to be set explicitly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+check.control.class">check.control.class()</a></code>, <code><a href="#topic+print.control.list">print.control.list()</a></code>
</p>

<hr>
<h2 id='simplify_simple'>Convert a list to an atomic vector if it consists solely of atomic elements of length 1.</h2><span id='topic+simplify_simple'></span>

<h3>Description</h3>

<p>This behaviour is not dissimilar to that of <code><a href="base.html#topic+simplify2array">simplify2array()</a></code>, but
it offers more robust handling of empty or NULL elements and never
promotes to a matrix or an array, making it suitable to be a column
of a <code><a href="base.html#topic+data.frame">data.frame</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simplify_simple(
  x,
  toNA = c("null", "empty", "keep"),
  empty = c("keep", "unlist"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simplify_simple_+3A_x">x</code></td>
<td>
<p>an R <code><a href="base.html#topic+list">list</a></code> to be simplified.</p>
</td></tr>
<tr><td><code id="simplify_simple_+3A_tona">toNA</code></td>
<td>
<p>a character string indicating whether <code>NULL</code> entries
(if <code>"null"</code>) or 0-length entries including <code>NULL</code> (if <code>"empty"</code>)
should be replaced with <code>NA</code>s before attempting conversion;
specifying <code>keep</code> or <code>FALSE</code> leaves them alone (typically
preventing conversion).</p>
</td></tr>
<tr><td><code id="simplify_simple_+3A_empty">empty</code></td>
<td>
<p>a character string indicating how empty lists should
be handled: either <code>"keep"</code>, in which case they are unchanged or
<code>"unlist"</code>, in which cases they are unlisted (typically to
<code>NULL</code>).</p>
</td></tr>
<tr><td><code id="simplify_simple_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="base.html#topic+unlist">unlist()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an atomic vector or a list of the same length as <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
(x &lt;- as.list(1:5))
stopifnot(identical(simplify_simple(x), 1:5))

x[3] &lt;- list(NULL) # Put a NULL in place of 3.
x
stopifnot(identical(simplify_simple(x, FALSE), x)) # Can't be simplified without replacing the NULL.

stopifnot(identical(simplify_simple(x), c(1L,2L,NA,4L,5L))) # NULL replaced by NA and simplified.

x[[3]] &lt;- integer(0)
x
stopifnot(identical(simplify_simple(x), x)) # A 0-length vector is not replaced by default,
stopifnot(identical(simplify_simple(x, "empty"), c(1L,2L,NA,4L,5L))) # but can be.

(x &lt;- lapply(1:5, function(i) c(i,i+1L))) # Elements are vectors of equal length.
simplify2array(x) # simplify2array() creates a matrix,
stopifnot(identical(simplify_simple(x), x)) # but simplify_simple() returns a list.

</code></pre>

<hr>
<h2 id='snctrl'>Statnet Control</h2><span id='topic+snctrl'></span>

<h3>Description</h3>

<p>A utility to facilitate argument completion of control lists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snctrl(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="snctrl_+3A_...">...</code></td>
<td>
<p>The parameter list is updated dynamically as packages
are loaded and unloaded. Their current list is given below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In and of itself, <code>snctrl</code> copies its named arguments into a
list. However, its argument list is updated dynamically as packages
are loaded, as are those of its reexports from other packages. This
is done using an API provided by helper functions. (See <code>API?snctrl</code>.)
</p>


<h3>Currently recognised control parameters</h3>

<p>This list is updated as packages are loaded and unloaded.
</p>



<h3>Note</h3>

<p>You may see messages along the lines of
</p>
<div class="sourceCode"><pre>The following object is masked from 'package:PKG':
snctrl
</pre></div>
<p>when loading packages. They are benign.
</p>

<hr>
<h2 id='snctrl_names'>Helper functions used by packages to facilitate <code><a href="#topic+snctrl">snctrl</a></code> updating.</h2><span id='topic+snctrl_names'></span><span id='topic+snctrl-API'></span><span id='topic+update_snctrl'></span><span id='topic+collate_controls'></span><span id='topic+UPDATE_MY_SCTRL_EXPR'></span><span id='topic+COLLATE_ALL_MY_CONTROLS_EXPR'></span>

<h3>Description</h3>

<p>Helper functions used by packages to facilitate <code><a href="#topic+snctrl">snctrl</a></code> updating.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snctrl_names()

update_snctrl(myname, arglists = NULL, callback = NULL)

collate_controls(x = NULL, ...)

UPDATE_MY_SCTRL_EXPR

COLLATE_ALL_MY_CONTROLS_EXPR
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="snctrl_names_+3A_myname">myname</code></td>
<td>
<p>Name of the package defining the arguments.</p>
</td></tr>
<tr><td><code id="snctrl_names_+3A_arglists">arglists</code></td>
<td>
<p>A named list of argument name-default pairs. If the
list is not named, it is first passed through
<code><a href="#topic+collate_controls">collate_controls()</a></code>.</p>
</td></tr>
<tr><td><code id="snctrl_names_+3A_callback">callback</code></td>
<td>
<p>A function with no arguments that updates the
packages own copy of <code><a href="#topic+snctrl">snctrl()</a></code>.</p>
</td></tr>
<tr><td><code id="snctrl_names_+3A_x">x</code></td>
<td>
<p>Either a function, a list of functions, or an
environment. If <code>x</code> is an environment, all functions starting
with dQuote(<code>control.</code>) are obtained.</p>
</td></tr>
<tr><td><code id="snctrl_names_+3A_...">...</code></td>
<td>
<p>Additional functions or lists of functions.</p>
</td></tr>
</table>


<h3>Format</h3>

<p><code>UPDATE_MY_SCTRL_EXPR</code> is a quoted expression meant to be passed directly to <code><a href="base.html#topic+eval">eval()</a></code>.
</p>
<p><code>COLLATE_ALL_MY_CONTROLS_EXPR</code> is a quoted expression meant to be passed directly to <code><a href="base.html#topic+eval">eval()</a></code>.
</p>


<h3>Value</h3>

<p><code>update_snctrl()</code> has no return value and is used for its side-effects.
</p>
<p><code>collate_controls()</code> returns the combined list of name-default pairs of each function.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>snctrl_names()</code>: Typeset the currently defined list of
argument names by package and control function.
</p>
</li>
<li> <p><code>update_snctrl()</code>: Typically called from <code><a href="base.html#topic+.onLoad">.onLoad()</a></code>, Update the
argument list of <code><a href="#topic+snctrl">snctrl()</a></code> to include additional argument names
associated with the package, and set a callback for the package
to update its own copy.
</p>
</li>
<li> <p><code>collate_controls()</code>: Obtain and concatenate the argument lists of
specified functions or all functions starting with dQuote(<code>control.</code>) in
the environment.
</p>
</li>
<li> <p><code>UPDATE_MY_SCTRL_EXPR</code>: A stored expression that, if evaluated, will
create a callback function <code>update_my_snctrl()</code> that will update
the client package's copy of <code><a href="#topic+snctrl">snctrl()</a></code>.
</p>
</li>
<li> <p><code>COLLATE_ALL_MY_CONTROLS_EXPR</code>: A stored expression that, if evaluated on
loading, will add arguments of the package's <code style="white-space: pre;">&#8288;control.*()&#8288;</code>
functions to <code><a href="#topic+snctrl">snctrl()</a></code> and set the callback.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# In the client package (outside any function):
eval(UPDATE_MY_SCTRL_EXPR)

## End(Not run)
## Not run: 
# In the client package:
.onLoad &lt;- function(libame, pkgname){
  # ... other code ...
  eval(statnet.common::COLLATE_ALL_MY_CONTROLS_EXPR)
  # ... other code ...
}

## End(Not run)
</code></pre>

<hr>
<h2 id='split.array'>A <code><a href="base.html#topic+split">split()</a></code> method for <code><a href="base.html#topic+array">array</a></code> and <code><a href="base.html#topic+matrix">matrix</a></code> types on a margin.</h2><span id='topic+split.array'></span><span id='topic+split.matrix'></span>

<h3>Description</h3>

<p>These methods split an <code><a href="base.html#topic+array">array</a></code> and <code><a href="base.html#topic+matrix">matrix</a></code> into a list of
arrays or matrices with the same number of dimensions
according to the specified margin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'array'
split(x, f, drop = FALSE, margin = NULL, ...)

## S3 method for class 'matrix'
split(x, f, drop = FALSE, margin = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split.array_+3A_x">x</code></td>
<td>
<p>A <code><a href="base.html#topic+matrix">matrix</a></code> or an <code><a href="base.html#topic+array">array</a></code>.</p>
</td></tr>
<tr><td><code id="split.array_+3A_f">f</code>, <code id="split.array_+3A_drop">drop</code></td>
<td>
<p>See help for <code><a href="base.html#topic+split">split()</a></code>. Note that <code>drop</code> here is
<em>not</em> for array dimensions: these are always preserved.</p>
</td></tr>
<tr><td><code id="split.array_+3A_margin">margin</code></td>
<td>
<p>Which margin of the array to split along. <code>NULL</code>
splits as <code><a href="base.html#topic+split.default">split.default</a></code>, dropping dimensions.</p>
</td></tr>
<tr><td><code id="split.array_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code><a href="base.html#topic+split">split()</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- diag(5)
f &lt;- rep(1:2, c(2,3))
split(x, f, margin=1) # Split rows.
split(x, f, margin=2) # Split columns.

# This is similar to how data frames are split:
stopifnot(identical(split(x, f, margin=1),
          lapply(lapply(split(as.data.frame(x), f), as.matrix), unname)))

</code></pre>

<hr>
<h2 id='ssolve'>Wrappers around matrix algebra functions that pre-<em>s</em>cale their
arguments</h2><span id='topic+ssolve'></span><span id='topic+sginv'></span><span id='topic+srcond'></span><span id='topic+snearPD'></span><span id='topic+xTAx_ssolve'></span><span id='topic+xTAx_qrssolve'></span><span id='topic+sandwich_ssolve'></span>

<h3>Description</h3>

<p>Covariance matrices of variables with very different orders of
magnitude can have very large ratios between their greatest and
their least eigenvalues, causing them to appear to the algorithms
to be near-singular when they are actually very much SPD. These
functions first scale the matrix's rows and/or columns by its
diagonal elements and then undo the scaling on the result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssolve(a, b, ..., snnd = TRUE)

sginv(X, ..., snnd = TRUE)

srcond(x, ..., snnd = TRUE)

snearPD(x, ...)

xTAx_ssolve(x, A, ...)

xTAx_qrssolve(x, A, tol = 1e-07, ...)

sandwich_ssolve(A, B, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ssolve_+3A_snnd">snnd</code></td>
<td>
<p>assume that the matrix is symmetric non-negative
definite (SNND). If it's &quot;obvious&quot; that it's not (e.g., negative
diagonal elements), an error is raised.</p>
</td></tr>
<tr><td><code id="ssolve_+3A_x">x</code>, <code id="ssolve_+3A_a">a</code>, <code id="ssolve_+3A_b">b</code>, <code id="ssolve_+3A_x">X</code>, <code id="ssolve_+3A_a">A</code>, <code id="ssolve_+3A_b">B</code>, <code id="ssolve_+3A_tol">tol</code>, <code id="ssolve_+3A_...">...</code></td>
<td>
<p>corresponding arguments of the wrapped functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ssolve()</code>, <code>sginv()</code>, and <code>snearPD()</code> wrap <code><a href="Matrix.html#topic+solve">solve()</a></code>,
<code><a href="MASS.html#topic+ginv">MASS::ginv()</a></code>, and <code><a href="Matrix.html#topic+nearPD">Matrix::nearPD()</a></code>, respectively. <code>srcond()</code>
returns the reciprocal condition number of <code><a href="Matrix.html#topic+rcond">rcond()</a></code> net of the
above scaling. <code>xTAx_ssolve</code>, <code>xTAx_qrssolve</code>, and
<code>sandwich_ssolve</code> wrap the corresponding <span class="pkg">statnet.common</span>
functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(2, sd=c(1,1e12))
x &lt;- c(x, sum(x))
A &lt;- matrix(c(1, 0, 1,
              0, 1e24, 1e24,
              1, 1e24, 1e24), 3, 3)
stopifnot(all.equal(
  xTAx_qrssolve(x,A),
  structure(drop(x%*%sginv(A)%*%x), rank = 2L, nullity = 1L)
))

x &lt;- rnorm(2, sd=c(1,1e12))
x &lt;- c(x, rnorm(1, sd=1e12))
A &lt;- matrix(c(1, 0, 1,
              0, 1e24, 1e24,
              1, 1e24, 1e24), 3, 3)

stopifnot(try(xTAx_qrssolve(x,A), silent=TRUE) ==
  "Error in xTAx_qrssolve(x, A) : x is not in the span of A\n")

</code></pre>

<hr>
<h2 id='statnet.cite'><code>CITATION</code> file utilities for Statnet packages (DEPRECATED)</h2><span id='topic+statnet.cite'></span><span id='topic+statnet.cite.head'></span><span id='topic+statnet.cite.foot'></span><span id='topic+statnet.cite.pkg'></span>

<h3>Description</h3>

<p>These functions automate citation generation for Statnet Project
packages. They no longer appear to work with CRAN and are thus
deprecated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>statnet.cite.head(pkg)

statnet.cite.foot(pkg)

statnet.cite.pkg(pkg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="statnet.cite_+3A_pkg">pkg</code></td>
<td>
<p>Name of the package whose citation is being generated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>statnet.cite.head</code> and <code>statnet.cite.foot</code>, an object
of type <code>citationHeader</code> and <code>citationFooter</code>, respectively,
understood by the <code><a href="utils.html#topic+citation">citation</a></code> function, with package name
substituted into the template.
</p>
<p>For <code>statnet.cite.pkg</code>, an object of class <code><a href="utils.html#topic+bibentry">bibentry</a></code>
containing a 'software manual' citation for the package constructed from the
current version and author information in the <code>DESCRIPTION</code> and a
template.
</p>


<h3>See Also</h3>

<p>citation, citHeader, citFooter, bibentry
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
statnet.cite.head("statnet.common")

statnet.cite.pkg("statnet.common")

statnet.cite.foot("statnet.common")

## End(Not run)
</code></pre>

<hr>
<h2 id='statnetStartupMessage'>Construct a &quot;standard&quot; startup message to be printed when the package is
loaded.</h2><span id='topic+statnetStartupMessage'></span>

<h3>Description</h3>

<p>This function uses information returned by <code><a href="utils.html#topic+packageDescription">packageDescription()</a></code>
to construct a standard package startup message according to the
policy of the Statnet Project.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>statnetStartupMessage(pkgname, friends = c(), nofriends = c())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="statnetStartupMessage_+3A_pkgname">pkgname</code></td>
<td>
<p>Name of the package whose information is used.</p>
</td></tr>
<tr><td><code id="statnetStartupMessage_+3A_friends">friends</code>, <code id="statnetStartupMessage_+3A_nofriends">nofriends</code></td>
<td>
<p>No longer used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string containing the startup message, to be passed to the
<code><a href="base.html#topic+packageStartupMessage">packageStartupMessage()</a></code> call or <code>NULL</code>, if policy
prescribes printing default startup message. (Thus, if
<code><a href="#topic+statnetStartupMessage">statnetStartupMessage()</a></code> returns <code>NULL</code>, the calling package should
not call <code><a href="base.html#topic+packageStartupMessage">packageStartupMessage()</a></code> at all.)
</p>


<h3>Note</h3>

<p>Earlier versions of this function printed a more expansive
message. This may change again as the Statnet Project policy
evolves.
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+packageDescription">packageDescription()</a></code>, <code><a href="base.html#topic+packageStartupMessage">packageStartupMessage()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
.onAttach &lt;- function(lib, pkg){
  sm &lt;- statnetStartupMessage("ergm")
  if(!is.null(sm)) packageStartupMessage(sm)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='sweep_cols.matrix'>Suptract a elements of a vector from respective columns of a matrix</h2><span id='topic+sweep_cols.matrix'></span>

<h3>Description</h3>

<p>An optimized function equivalent to <code>sweep(x, 2, STATS)</code> for a matrix
<code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sweep_cols.matrix(x, STATS, disable_checks = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sweep_cols.matrix_+3A_x">x</code></td>
<td>
<p>a numeric matrix;</p>
</td></tr>
<tr><td><code id="sweep_cols.matrix_+3A_stats">STATS</code></td>
<td>
<p>a numeric vector whose length equals to the number of columns
of <code>x</code>.</p>
</td></tr>
<tr><td><code id="sweep_cols.matrix_+3A_disable_checks">disable_checks</code></td>
<td>
<p>if <code>TRUE</code>, do not check that <code>x</code> is a
numeric matrix and its number of columns matches the length of <code>STATS</code>;
set in production code for a significant speed-up.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of the same attributes as <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- matrix(runif(1000), ncol=4)
s &lt;- 1:4

stopifnot(all.equal(sweep_cols.matrix(x, s), sweep(x, 2, s)))

</code></pre>

<hr>
<h2 id='term_list'>A helper class for list of terms in an formula</h2><span id='topic+term_list'></span><span id='topic+as.term_list'></span><span id='topic+as.term_list.term_list'></span><span id='topic+as.term_list.default'></span><span id='topic+c.term_list'></span><span id='topic++5B.term_list'></span><span id='topic+print.term_list'></span>

<h3>Description</h3>

<p>Typically generated by <code><a href="#topic+list_rhs.formula">list_rhs.formula()</a></code>, it contains, in
addition to a list of <code><a href="base.html#topic+call">call()</a></code> or similar objects, attributes
<code>"sign"</code> and <code>"env"</code>, containing, respectively a vector of
signs that the terms had in the original formula and a list of
environments of the formula from which the term has been
extracted. Indexing and concatenation methods preserve these.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>term_list(x, sign = +1, env = NULL)

as.term_list(x, ...)

## S3 method for class 'term_list'
as.term_list(x, ...)

## Default S3 method:
as.term_list(x, sign = +1, env = NULL, ...)

## S3 method for class 'term_list'
c(x, ...)

## S3 method for class 'term_list'
x[i, ...]

## S3 method for class 'term_list'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="term_list_+3A_x">x</code></td>
<td>
<p>a list of terms or a term; a <code>term_list</code></p>
</td></tr>
<tr><td><code id="term_list_+3A_sign">sign</code></td>
<td>
<p>a vector specifying the signs associated with each term (<code>-1</code> and <code>+1</code>)</p>
</td></tr>
<tr><td><code id="term_list_+3A_env">env</code></td>
<td>
<p>a list specifying the environments, or NULL</p>
</td></tr>
<tr><td><code id="term_list_+3A_...">...</code></td>
<td>
<p>additional arguments to methods</p>
</td></tr>
<tr><td><code id="term_list_+3A_i">i</code></td>
<td>
<p>list index</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+list_rhs.formula">list_rhs.formula()</a></code>, <code><a href="#topic+list_summands.call">list_summands.call()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
e1 &lt;- new.env()
f1 &lt;- a~b+c
environment(f1) &lt;- e1
f2 &lt;- ~-NULL+1

(l1 &lt;- list_rhs.formula(f1))
(l2 &lt;- list_rhs.formula(f2))

(l &lt;- c(l1,l2))


(l &lt;- c(l2[1], l1[2], l1[1], l1[1], l2[2]))


</code></pre>

<hr>
<h2 id='trim_env'>Make a copy of an environment with just the selected objects.</h2><span id='topic+trim_env'></span><span id='topic+trim_env.environment'></span><span id='topic+trim_env.default'></span>

<h3>Description</h3>

<p>Make a copy of an environment with just the selected objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trim_env(object, keep = NULL, ...)

## S3 method for class 'environment'
trim_env(object, keep = NULL, ...)

## Default S3 method:
trim_env(object, keep = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trim_env_+3A_object">object</code></td>
<td>
<p>An <code><a href="base.html#topic+environment">environment</a></code> or an object with
<code><a href="base.html#topic+environment">environment()</a></code> and <code style="white-space: pre;">&#8288;environment()&lt;-&#8288;</code> methods.</p>
</td></tr>
<tr><td><code id="trim_env_+3A_keep">keep</code></td>
<td>
<p>A character vector giving names of variables in the
environment (including its ancestors) to copy over, defaulting to
dropping all. Variables that cannot be resolved are silently
ignored.</p>
</td></tr>
<tr><td><code id="trim_env_+3A_...">...</code></td>
<td>
<p>Additional arguments, passed on to lower-level methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same type as <code>object</code>, with updated environment.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>trim_env(environment)</code>: A method for environment objects.
</p>
</li>
<li> <p><code>trim_env(default)</code>: Default method, for objects such as <code><a href="stats.html#topic+formula">formula</a></code> and <code><a href="base.html#topic+function">function</a></code> that have <code><a href="base.html#topic+environment">environment()</a></code> and <code style="white-space: pre;">&#8288;environment()&lt;-&#8288;</code> methods.
</p>
</li></ul>

<hr>
<h2 id='ult'>Extract or replace the <em>ult</em>imate (last) element of a vector or a list, or an element counting from the end.</h2><span id='topic+ult'></span><span id='topic+ult+3C-'></span>

<h3>Description</h3>

<p>Extract or replace the <em>ult</em>imate (last) element of a vector or a list, or an element counting from the end.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ult(x, i = 1L)

ult(x, i = 1L) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ult_+3A_x">x</code></td>
<td>
<p>a vector or a list.</p>
</td></tr>
<tr><td><code id="ult_+3A_i">i</code></td>
<td>
<p>index from the end of the list to extract or replace (where 1 is the last element, 2 is the penultimate element, etc.).</p>
</td></tr>
<tr><td><code id="ult_+3A_value">value</code></td>
<td>
<p>Replacement value for the <code>i</code>th element from the end.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An element of <code>x</code>.
</p>


<h3>Note</h3>

<p>Due to the way in which assigning to a function is
implemented in R, <code>ult(x) &lt;- e</code> may be less efficient than
<code>x[[length(x)]] &lt;- e</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:5
(last &lt;- ult(x))
(penultimate &lt;- ult(x, 2)) # 2nd last.



(ult(x) &lt;- 6)
(ult(x, 2) &lt;- 7) # 2nd last.
x



</code></pre>

<hr>
<h2 id='unused_dots_warning'>An error handler for <code><a href="rlang.html#topic+check_dots_used">rlang::check_dots_used()</a></code> that issues a
warning that only lists argument names.</h2><span id='topic+unused_dots_warning'></span>

<h3>Description</h3>

<p>This handler parses the error message produced by
<code><a href="rlang.html#topic+check_dots_used">rlang::check_dots_used()</a></code>, extracting the names of the unused
arguments, and formats them into a more gentle warning message. It
relies on <a href="https://CRAN.R-project.org/package=rlang"><span class="pkg">rlang</span></a> maintaining its current format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unused_dots_warning(e)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unused_dots_warning_+3A_e">e</code></td>
<td>
<p>a <a href="base.html#topic+condition">condition</a> object, typically not passed by
the end-user; see example below.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>


g &lt;- function(b=NULL, ...){
  invisible(force(b))
}

f &lt;- function(...){
  rlang::check_dots_used(error = unused_dots_warning)
  g(...)
}

f() # OK
f(b=2) # OK
f(a=1, b=2, c=3) # Warning about a and c but not about b


</code></pre>

<hr>
<h2 id='unwhich'>Construct a logical vector with <code>TRUE</code> in specified positions.</h2><span id='topic+unwhich'></span>

<h3>Description</h3>

<p>This function is basically an inverse of <code><a href="base.html#topic+which">which</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unwhich(which, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unwhich_+3A_which">which</code></td>
<td>
<p>a numeric vector of indices to set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="unwhich_+3A_n">n</code></td>
<td>
<p>total length of the output vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector of length <code>n</code> whose elements listed in
<code>which</code> are set to <code>TRUE</code>, and whose other elements are set to
<code>FALSE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- as.logical(rbinom(10,1,0.5))
stopifnot(all(x == unwhich(which(x), 10)))
</code></pre>

<hr>
<h2 id='vector.namesmatch'>reorder vector v into order determined by matching the names of its elements
to a vector of names</h2><span id='topic+vector.namesmatch'></span>

<h3>Description</h3>

<p>A helper function to reorder vector <code>v</code> (if named) into order specified
by matching its names to the argument <code>names</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vector.namesmatch(v, names, errname = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vector.namesmatch_+3A_v">v</code></td>
<td>
<p>a vector (or list) with named elements, to be reorderd</p>
</td></tr>
<tr><td><code id="vector.namesmatch_+3A_names">names</code></td>
<td>
<p>a character vector of element names, corresponding to names of
<code>v</code>, specificying desired orering of <code>v</code></p>
</td></tr>
<tr><td><code id="vector.namesmatch_+3A_errname">errname</code></td>
<td>
<p>optional, name to be reported in any error messages. default
to <code>deparse(substitute(v))</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>does some checking of appropriateness of arguments, and reorders v by
matching its names to character vector <code>names</code>
</p>


<h3>Value</h3>

<p>returns <code>v</code>, with elements reordered
</p>


<h3>Note</h3>

<p>earlier versions of this function did not order as advertiased
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
test&lt;-list(c=1,b=2,a=3)
vector.namesmatch(test,names=c('a','c','b'))
</code></pre>

<hr>
<h2 id='Welford'>A Welford accumulator for sample mean and variance</h2><span id='topic+Welford'></span><span id='topic+update.Welford'></span>

<h3>Description</h3>

<p>A simple class for keeping track of the running mean and the sum of squared deviations from the mean for a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Welford(dn, means, vars)

## S3 method for class 'Welford'
update(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Welford_+3A_dn">dn</code>, <code id="Welford_+3A_means">means</code>, <code id="Welford_+3A_vars">vars</code></td>
<td>
<p>initialization of the Welford object: if <code>means</code>
and <code>vars</code> are given, they are treated as the running means and
variances, and <code>dn</code> is their associated sample size, and if not,
<code>dn</code> is the dimension of the vector (with sample size 0).</p>
</td></tr>
<tr><td><code id="Welford_+3A_object">object</code></td>
<td>
<p>a <code>Welford</code> object.</p>
</td></tr>
<tr><td><code id="Welford_+3A_newdata">newdata</code></td>
<td>
<p>either a numeric vector of length <code>d</code>, a numeric
matrix with <code>d</code> columns for a group update, or another <code>Welford</code>
object with the same <code>d</code>.</p>
</td></tr>
<tr><td><code id="Welford_+3A_...">...</code></td>
<td>
<p>additional arguments to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of type <code>Welford</code>: a list with four elements:
</p>

<ol>
<li> <p><code>n</code>: Running number of observations
</p>
</li>
<li> <p><code>means</code>: Running mean for each variable
</p>
</li>
<li> <p><code>SSDs</code>: Running sum of squared deviations from the mean for each variable
</p>
</li>
<li> <p><code>vars</code>: Running variance of each variable
</p>
</li></ol>



<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>update(Welford)</code>: Update a <code>Welford</code> object with new
data.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
X &lt;- matrix(rnorm(200), 20, 10)
w0 &lt;- Welford(10)

w &lt;- update(w0, X)
stopifnot(isTRUE(all.equal(w$means, colMeans(X))))
stopifnot(isTRUE(all.equal(w$vars, apply(X,2,var))))

w &lt;- update(w0, X[1:12,])
w &lt;- update(w, X[13:20,])
stopifnot(isTRUE(all.equal(w$means, colMeans(X))))
stopifnot(isTRUE(all.equal(w$vars, apply(X,2,var))))

w &lt;- Welford(12, colMeans(X[1:12,]), apply(X[1:12,], 2, var))
w &lt;- update(w, X[13:20,])
stopifnot(isTRUE(all.equal(w$means, colMeans(X))))
stopifnot(isTRUE(all.equal(w$vars, apply(X,2,var))))

</code></pre>

<hr>
<h2 id='wmatrix'>A data matrix with row weights</h2><span id='topic+wmatrix'></span><span id='topic+logwmatrix'></span><span id='topic+linwmatrix'></span><span id='topic+is.wmatrix'></span><span id='topic+is.logwmatrix'></span><span id='topic+is.linwmatrix'></span><span id='topic+as.linwmatrix'></span><span id='topic+as.logwmatrix'></span><span id='topic+as.linwmatrix.linwmatrix'></span><span id='topic+as.linwmatrix.logwmatrix'></span><span id='topic+as.logwmatrix.logwmatrix'></span><span id='topic+as.logwmatrix.linwmatrix'></span><span id='topic+as.linwmatrix.matrix'></span><span id='topic+as.logwmatrix.matrix'></span><span id='topic+print.wmatrix'></span><span id='topic+print.logwmatrix'></span><span id='topic+print.linwmatrix'></span><span id='topic+compress_rows.logwmatrix'></span><span id='topic+compress_rows.linwmatrix'></span><span id='topic+decompress_rows.wmatrix'></span><span id='topic++5B.wmatrix'></span><span id='topic++5B+3C-.wmatrix'></span>

<h3>Description</h3>

<p>A representation of a numeric matrix with row weights, represented
on either linear (<code>linwmatrix</code>) or logarithmic (<code>logwmatrix</code>)
scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logwmatrix(
  data = NA,
  nrow = 1,
  ncol = 1,
  byrow = FALSE,
  dimnames = NULL,
  w = NULL
)

linwmatrix(
  data = NA,
  nrow = 1,
  ncol = 1,
  byrow = FALSE,
  dimnames = NULL,
  w = NULL
)

is.wmatrix(x)

is.logwmatrix(x)

is.linwmatrix(x)

as.linwmatrix(x, ...)

as.logwmatrix(x, ...)

## S3 method for class 'linwmatrix'
as.linwmatrix(x, ...)

## S3 method for class 'logwmatrix'
as.linwmatrix(x, ...)

## S3 method for class 'logwmatrix'
as.logwmatrix(x, ...)

## S3 method for class 'linwmatrix'
as.logwmatrix(x, ...)

## S3 method for class 'matrix'
as.linwmatrix(x, w = NULL, ...)

## S3 method for class 'matrix'
as.logwmatrix(x, w = NULL, ...)

## S3 method for class 'wmatrix'
print(x, ...)

## S3 method for class 'logwmatrix'
print(x, ...)

## S3 method for class 'linwmatrix'
print(x, ...)

## S3 method for class 'logwmatrix'
compress_rows(x, ...)

## S3 method for class 'linwmatrix'
compress_rows(x, ...)

## S3 method for class 'wmatrix'
decompress_rows(x, target.nrows = NULL, ...)

## S3 method for class 'wmatrix'
x[i, j, ..., drop = FALSE]

## S3 replacement method for class 'wmatrix'
x[i, j, ...] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wmatrix_+3A_data">data</code>, <code id="wmatrix_+3A_nrow">nrow</code>, <code id="wmatrix_+3A_ncol">ncol</code>, <code id="wmatrix_+3A_byrow">byrow</code>, <code id="wmatrix_+3A_dimnames">dimnames</code></td>
<td>
<p>passed to <code><a href="base.html#topic+matrix">matrix</a></code>.</p>
</td></tr>
<tr><td><code id="wmatrix_+3A_w">w</code></td>
<td>
<p>row weights on the appropriate scale.</p>
</td></tr>
<tr><td><code id="wmatrix_+3A_x">x</code></td>
<td>
<p>an object to be coerced or tested.</p>
</td></tr>
<tr><td><code id="wmatrix_+3A_...">...</code></td>
<td>
<p>extra arguments, currently unused.</p>
</td></tr>
<tr><td><code id="wmatrix_+3A_target.nrows">target.nrows</code></td>
<td>
<p>the approximate number of rows the uncompressed matrix
should have; if not achievable exactly while respecting proportionality, a
matrix with a slightly different number of rows will be constructed.</p>
</td></tr>
<tr><td><code id="wmatrix_+3A_i">i</code>, <code id="wmatrix_+3A_j">j</code>, <code id="wmatrix_+3A_value">value</code></td>
<td>
<p>rows and columns and values for extraction or
replacement; as <code><a href="base.html#topic+matrix">matrix</a></code>.</p>
</td></tr>
<tr><td><code id="wmatrix_+3A_drop">drop</code></td>
<td>
<p>Used for consistency with the generic. Ignored, and
always treated as <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>linwmatrix</code>/<code>logwmatrix</code> and <code>wmatrix</code>,
which is a <code><a href="base.html#topic+matrix">matrix</a></code> but also has an attribute <code>w</code> containing
row weights on the linear or the natural-log-transformed scale.
</p>


<h3>Note</h3>

<p>Note that <code>wmatrix</code> itself is an &quot;abstract&quot; class: you cannot
instantiate it.
</p>
<p>Note that at this time, <code>wmatrix</code> is designed as, first and
foremost, as class for storing compressed data matrices, so most
methods that operate on matrices may not handle the weights
correctly and may even cause them to be lost.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rowweights">rowweights</a></code>, <code><a href="#topic+lrowweights">lrowweights</a></code>, <code><a href="#topic+compress_rows">compress_rows</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(m &lt;- matrix(1:3, 2, 3, byrow=TRUE))
(m &lt;- rbind(m, 3*m, 2*m, m))
(mlog &lt;- as.logwmatrix(m))
(mlin &lt;- as.linwmatrix(m))
(cmlog &lt;- compress_rows(mlog))
(cmlin &lt;- compress_rows(mlin))

stopifnot(all.equal(as.linwmatrix(cmlog),cmlin))

cmlog[2,] &lt;- 1:3
(cmlog &lt;- compress_rows(cmlog))
stopifnot(sum(rowweights(cmlog))==nrow(m))

(m3 &lt;- matrix(c(1:3,(1:3)*2,(1:3)*3), 3, 3, byrow=TRUE))
(rowweights(m3) &lt;- c(4, 2, 2))

stopifnot(all.equal(compress_rows(as.logwmatrix(m)), as.logwmatrix(m3),check.attributes=FALSE))
stopifnot(all.equal(rowweights(compress_rows(as.logwmatrix(m))),
                    rowweights(as.logwmatrix(m3)),check.attributes=FALSE))
</code></pre>

<hr>
<h2 id='wmatrix_weights'>Set or extract weighted matrix row weights</h2><span id='topic+wmatrix_weights'></span><span id='topic+rowweights'></span><span id='topic+rowweights.linwmatrix'></span><span id='topic+rowweights.logwmatrix'></span><span id='topic+lrowweights'></span><span id='topic+lrowweights.logwmatrix'></span><span id='topic+lrowweights.linwmatrix'></span><span id='topic+rowweights+3C-'></span><span id='topic+rowweights+3C-.linwmatrix'></span><span id='topic+rowweights+3C-.logwmatrix'></span><span id='topic+lrowweights+3C-'></span><span id='topic+lrowweights+3C-.linwmatrix'></span><span id='topic+lrowweights+3C-.logwmatrix'></span><span id='topic+rowweights+3C-.matrix'></span><span id='topic+lrowweights+3C-.matrix'></span>

<h3>Description</h3>

<p>Set or extract weighted matrix row weights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowweights(x, ...)

## S3 method for class 'linwmatrix'
rowweights(x, ...)

## S3 method for class 'logwmatrix'
rowweights(x, ...)

lrowweights(x, ...)

## S3 method for class 'logwmatrix'
lrowweights(x, ...)

## S3 method for class 'linwmatrix'
lrowweights(x, ...)

rowweights(x, ...) &lt;- value

## S3 replacement method for class 'linwmatrix'
rowweights(x, update = TRUE, ...) &lt;- value

## S3 replacement method for class 'logwmatrix'
rowweights(x, update = TRUE, ...) &lt;- value

lrowweights(x, ...) &lt;- value

## S3 replacement method for class 'linwmatrix'
lrowweights(x, update = TRUE, ...) &lt;- value

## S3 replacement method for class 'logwmatrix'
lrowweights(x, update = TRUE, ...) &lt;- value

## S3 replacement method for class 'matrix'
rowweights(x, ...) &lt;- value

## S3 replacement method for class 'matrix'
lrowweights(x, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wmatrix_weights_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+linwmatrix">linwmatrix</a></code>, a <code><a href="#topic+logwmatrix">logwmatrix</a></code>, or a <code><a href="base.html#topic+matrix">matrix</a></code>; a
<code><a href="base.html#topic+matrix">matrix</a></code> is coerced to a weighted matrix of an appropriate
type.</p>
</td></tr>
<tr><td><code id="wmatrix_weights_+3A_...">...</code></td>
<td>
<p>extra arguments for methods.</p>
</td></tr>
<tr><td><code id="wmatrix_weights_+3A_value">value</code></td>
<td>
<p>weights to set, on the appropriate scale.</p>
</td></tr>
<tr><td><code id="wmatrix_weights_+3A_update">update</code></td>
<td>
<p>if <code>TRUE</code> (the default), the old weights are updated
with the new weights (i.e., corresponding weights are multiplied
on linear scale or added on on log scale); otherwise, they are
overwritten.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For the accessor functions, the row weights or the row
log-weights; otherwise, a weighted matrix with modified
weights. The type of weight (linear or logarithmic) is converted
to the required type and the type of weighting of the matrix is
preserved.
</p>

<hr>
<h2 id='xTAx'>Common quadratic forms</h2><span id='topic+xTAx'></span><span id='topic+xAxT'></span><span id='topic+xTAx_solve'></span><span id='topic+xTAx_qrsolve'></span><span id='topic+sandwich_solve'></span>

<h3>Description</h3>

<p>Common quadratic forms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xTAx(x, A)

xAxT(x, A)

xTAx_solve(x, A, ...)

xTAx_qrsolve(x, A, tol = 1e-07, ...)

sandwich_solve(A, B, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xTAx_+3A_x">x</code></td>
<td>
<p>a vector</p>
</td></tr>
<tr><td><code id="xTAx_+3A_a">A</code></td>
<td>
<p>a square matrix</p>
</td></tr>
<tr><td><code id="xTAx_+3A_...">...</code></td>
<td>
<p>additional arguments to subroutines</p>
</td></tr>
<tr><td><code id="xTAx_+3A_tol">tol</code></td>
<td>
<p>tolerance argument passed to the relevant subroutine</p>
</td></tr>
<tr><td><code id="xTAx_+3A_b">B</code></td>
<td>
<p>a square matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are somewhat inspired by emulator::quad.form.inv()
and others.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>xTAx()</code>: Evaluate <code class="reqn">x'Ax</code> for vector <code class="reqn">x</code> and square
matrix <code class="reqn">A</code>.
</p>
</li>
<li> <p><code>xAxT()</code>: Evaluate <code class="reqn">xAx'</code> for vector <code class="reqn">x</code> and square
matrix <code class="reqn">A</code>.
</p>
</li>
<li> <p><code>xTAx_solve()</code>: Evaluate <code class="reqn">x'A^{-1}x</code> for vector <code class="reqn">x</code> and
invertible matrix <code class="reqn">A</code> using <code><a href="Matrix.html#topic+solve">solve()</a></code>.
</p>
</li>
<li> <p><code>xTAx_qrsolve()</code>: Evaluate <code class="reqn">x'A^{-1}x</code> for vector <code class="reqn">x</code> and
matrix <code class="reqn">A</code> using QR decomposition and confirming that <code class="reqn">x</code>
is in the span of <code class="reqn">A</code> if <code class="reqn">A</code> is singular; returns <code>rank</code>
and <code>nullity</code> as attributes just in case subsequent calculations
(e.g., hypothesis test degrees of freedom) are affected.
</p>
</li>
<li> <p><code>sandwich_solve()</code>: Evaluate <code class="reqn">A^{-1}B(A')^{-1}</code> for <code class="reqn">B</code> a
square matrix and <code class="reqn">A</code> invertible.
</p>
</li></ul>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
