<!DOCTYPE html><html lang="en-Us"><head><title>Help for package rineq</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rineq}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ci'><p>Calculates different type of concentration indexes</p></a></li>
<li><a href='#confint.hci'><p>Confidence intervals for <code>hci</code> objects</p></a></li>
<li><a href='#contribution'><p>Function to decompose the Relative Concentration Index into its components</p></a></li>
<li><a href='#correct_sign'><p>Corrects negative values in the health variable</p></a></li>
<li><a href='#decomposition'><p>Decomposition analysis</p></a></li>
<li><a href='#housing'><p>Artificial example data on housing conditions</p></a></li>
<li><a href='#plot.decomposition'><p>Plots a barplot of the contribution percentages in a <code>decomposition</code> object. Sets custom plot margins and uses the graphical parameters <code>xlim</code>, <code>horiz</code>, <code>las</code> and <code>xlab</code> which therefore cannot be customized</p></a></li>
<li><a href='#plot.hci'><p>Plots the concentration curve for an <code>hci</code> object.</p></a></li>
<li><a href='#print.decomposition'><p>Print function for <code>decomposition</code> objects.</p></a></li>
<li><a href='#print.hci'><p>Prints an <code>hci</code> object.</p></a></li>
<li><a href='#rank_gwt'><p>Generalized weighted ranking function</p></a></li>
<li><a href='#rank_wt'><p>Calculates the weighted rank</p></a></li>
<li><a href='#summary.decomposition'><p>Prints and returns a summary for a <code>decomposition</code> object.</p></a></li>
<li><a href='#summary.hci'><p>Prints the a summary of the concentration index object <code>hci</code></p></a></li>
<li><a href='#var_wt'><p>Calculates the weighted variance</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Concentration Index and Decomposition for Health Inequalities</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-01-10</td>
</tr>
<tr>
<td>Description:</td>
<td>Relative, generalized, and Erreygers corrected concentration index; plot Lorenz curves; and decompose health
    inequalities into contributing factors. The package currently works with (generalized) linear models, survival models, complex survey models, and marginal effects probit models.
    originally forked by Brecht Devleesschauwer from the 'decomp' package  (no longer on CRAN), 'rineq' is now maintained by Kaspar Walter Meili. Compared to the earlier 'rineq' version on 'github' by Brecht Devleesschauwer (<a href="https://github.com/brechtdv/rineq">https://github.com/brechtdv/rineq</a>), the regression tree functionality has been removed.
    Improvements compared to earlier versions include improved plotting of decomposition and concentration, added functionality to calculate the concentration index with different methods, calculation of robust standard errors, and support for the decomposition analysis using marginal effects probit regression models. The development version is available at <a href="https://github.com/kdevkdev/rineq">https://github.com/kdevkdev/rineq</a>.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, graphics</td>
</tr>
<tr>
<td>Suggests:</td>
<td>sandwich, lmtest, mfx, survey, survival</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-Us</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/kdevkdev/rineq">https://github.com/kdevkdev/rineq</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/kdevkdev/rineq/issues">https://github.com/kdevkdev/rineq/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-10 14:11:03 UTC; kaspar</td>
</tr>
<tr>
<td>Author:</td>
<td>Brecht Devleesschauwer [aut, cph],
  Saveria Willimès [aut, cph],
  Carine Van Malderen [aut, cph],
  Peter Konings [aut, cph],
  Niko Speybroeck [aut, cph],
  Kaspar Meili <a href="https://orcid.org/0000-0002-9889-4406"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kaspar Meili &lt;meilikaspar@yahoo.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-13 17:30:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='ci'>Calculates different type of concentration indexes</h2><span id='topic+ci'></span>

<h3>Description</h3>

<p>This function calculates the relative concentration index (Kakwani et al.), the generalized concentration index (Clarke et al., 2002), the Wagstaff index for bounded variables (Owen et al. 2016), and the concentration index with Erreygers' correction (Erreygers et al., 2009).  It returns an object of class <code>hci</code> for which confidence intervals, summaries and plots are defined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci(
  ineqvar,
  outcome,
  weights = NULL,
  type = c("CI", "CIg", "CIc", "CIw"),
  method = c("linreg_delta", "linreg_convenience", "cov_convenience", "direct"),
  df_correction = TRUE,
  robust_se = FALSE,
  rse_type = "HC3",
  rank_function = rineq::rank_wt
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ci_+3A_ineqvar">ineqvar</code></td>
<td>
<p>Used for ranking, usually relates to the socioeconomic position, for example income.</p>
</td></tr>
<tr><td><code id="ci_+3A_outcome">outcome</code></td>
<td>
<p>The variable in which the inequality should be measures, for example health.</p>
</td></tr>
<tr><td><code id="ci_+3A_weights">weights</code></td>
<td>
<p>Optional, used to weigh the observations. Defaults to equal weights for all observations.</p>
</td></tr>
<tr><td><code id="ci_+3A_type">type</code></td>
<td>
<p>Character, the type of concentration index to be calculated: relative concentration index (<code>CI</code>, default), generalized concentration index (<code>CIg</code>), concentration index with Erreygers Correction <code>CIc</code>, or Wagstaff concentration index suitable for bounded and binary outcomes <code>CIw</code></p>
</td></tr>
<tr><td><code id="ci_+3A_method">method</code></td>
<td>
<p>Character, defines the calculation method. One of:
</p>

<ul>
<li> <p><code>linreg_delta</code>: Based on linear regression without transforming the left hand side variable. Computes correct standard errors that take into account the sampling variability of the estimate of the mean (O’Donnell et al. 2008, Owen et al. 2016)
</p>
</li>
<li> <p><code>linreg_convenience</code>): Based on simpler regression with transformed left hand side variable. Standard errors do not take into account the sampling variability of the estimate of the mean(O’Donnell et al. 2008, Owen et al. 2016)
</p>
</li>
<li> <p><code>cov_convenience</code>: Based on covariance. Equivalent to <code>linreg_convenience</code> (O’Donnell et al. 2008, Owen et al. 2016)
</p>
</li>
<li> <p><code>direct</code>: Using direct formula, standard errors do no take weighting appropriately into account  (O’Donnell et al. 2008, Kakwani et al. 1997)
</p>
</li></ul>
</td></tr>
<tr><td><code id="ci_+3A_df_correction">df_correction</code></td>
<td>
<p>If <code>TRUE</code> (default), calculates the concentration index based on the population variance (derived from the sample variance).</p>
</td></tr>
<tr><td><code id="ci_+3A_robust_se">robust_se</code></td>
<td>
<p>Uses robust standard errors if <code>TRUE</code>. Only available for the <code style="white-space: pre;">&#8288;linreg_*&#8288;</code> type methods. Requires the <code>sandwich</code> package.</p>
</td></tr>
<tr><td><code id="ci_+3A_rse_type">rse_type</code></td>
<td>
<p>Character, type argument for the <code>vcovHC()</code>. <code>HC3</code>' is suggested as default, set to <code>HC1</code> for Stata compatibility. See <code>?sandwich::vcovHC()</code> for options.</p>
</td></tr>
<tr><td><code id="ci_+3A_rank_function">rank_function</code></td>
<td>
<p>Function to calculate the weighted rank of <code>ineqvar</code>. Takes two arguments: the variable that holds the rank order information, and the weights for the ranks. <code>rineq</code> currently provides two, <code>rank_wt</code> (default, corresponds to code provided in the World Bank report by O’Donnell et al.,2008) and <code>rank_gwt</code> (generalized handling of ties as also used by the Stata Conindex command, initially published by van Ourti, (2004)).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An  S3 object of class <code>hci</code>. Contains:
</p>

<ul>
<li> <p><code>concentration_index</code> The concentration index
</p>
</li>
<li> <p><code>type</code> The type
</p>
</li>
<li> <p><code>method</code> The method used for calculation
</p>
</li>
<li> <p><code>variance</code> The variance,used for calculation of confidence intervals
</p>
</li>
<li> <p><code>fractional_rank</code> Computed fractional rank <code>NA</code>
</p>
</li>
<li> <p><code>outcome</code> Outcome after removing <code>NA</code>
</p>
</li>
<li> <p><code>call</code> Call signature
</p>
</li>
<li> <p><code>n</code> Number of observations after removing <code>NA</code>
</p>
</li>
<li> <p><code>robust_se</code> Were robust standard errors calculated?
</p>
</li>
<li> <p><code>rse_type</code> Type of robust standard errors.
</p>
</li>
<li> <p><code>df_correction</code> Do the degrees of freedom correspond to a sample?
</p>
</li></ul>



<h3>References</h3>

<p>Clarke, P. M., Gerdtham, U. G., Johannesson, M., Bingefors, K., &amp; Smith, L. (2002). On the measurement of relative and absolute income-related health inequality. Social Science &amp; Medicine, 55(11), 1923-1928
</p>
<p>Erreygers, G. (2009). Correcting the concentration index. Journal of health economics, 28(2), 504-515
</p>
<p>Kakwani, N., Wagstaff, A., &amp; Van Doorslaer, E. (1997). Socioeconomic inequalities in health: measurement, computation, and statistical inference. Journal of econometrics, 77(1), 87-103.
</p>
<p>O'Donnel, O., O'Neill S., Van Ourti T., &amp; Walsh B. (2016). Conindex: Estimation of Concentration Indices. The Stata Journal, 16(1): 112-138.
</p>
<p>O’Donnell, O., Van Doorslaer, E. , Wagstaff, A., Lindelow, M., 2008. Analyzing Health Equity Using Household Survey Data: A Guide to Techniques and Their Implementation, World Bank Publications. The World Bank.
</p>
<p>van Ourti, T., 2004. Measuring horizontal inequity in Belgian health care using a Gaussian random effects two part count data model. Health Economics, 13: 705–724.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Direct
data(housing)
ci.bmi &lt;- ci(ineqvar = housing$income, outcome = housing$bmi, method = "direct")
summary(ci.bmi)

# retrieve value
ci.bmi$concentration_index

# obtain confidence intervals
confint(ci.bmi, level = 0.95) 
plot(ci.bmi)

# Wagstaff type with binary outcome and robust standard errors 
# that should correspond to Stata (depends on 'sandwich'):
ci.bmi.b &lt;- ci(housing$income, housing$high.bmi, type = "CIw", robust_se = TRUE, 
   rse_type = "HC1")

</code></pre>

<hr>
<h2 id='confint.hci'>Confidence intervals for <code>hci</code> objects</h2><span id='topic+confint.hci'></span>

<h3>Description</h3>

<p>Confidence intervals for <code>hci</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hci'
confint(object, parm = NULL, level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="confint.hci_+3A_object">object</code></td>
<td>
<p>An object of class <code>hci</code></p>
</td></tr>
<tr><td><code id="confint.hci_+3A_parm">parm</code></td>
<td>
<p>Unused</p>
</td></tr>
<tr><td><code id="confint.hci_+3A_level">level</code></td>
<td>
<p>Confidence interval level defaults to <code>0.95</code></p>
</td></tr>
<tr><td><code id="confint.hci_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A confidence interval in a numeric vector of length 2
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(housing)
ci.bmi &lt;- ci(ineqvar = housing$income, outcome = housing$bmi, method = "direct")
confint(ci.bmi)

</code></pre>

<hr>
<h2 id='contribution'>Function to decompose the Relative Concentration Index into its components</h2><span id='topic+contribution'></span>

<h3>Description</h3>

<p>Currently compatible with <code>lm</code>, <code>glm</code> logit and probit, <code>svyglm</code>, <code>coxph</code> and <code>mfx</code> marginal effects probit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contribution(object, ranker, correction = TRUE, type = "CI", intercept = "exclude")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="contribution_+3A_object">object</code></td>
<td>
<p>The model result object. class <code>coxph</code>, <code>glm</code>, <code>lm</code> or <code>svyglm</code>, <code>probitmfx</code>, <code>logitmfx</code>; the outcome should be the health variable and the predictors the components.</p>
</td></tr>
<tr><td><code id="contribution_+3A_ranker">ranker</code></td>
<td>
<p>Ranking variable with the same length as the outcome.</p>
</td></tr>
<tr><td><code id="contribution_+3A_correction">correction</code></td>
<td>
<p>A logical indicating whether the global and partial confidence should be corrected for negative values using imputation.</p>
</td></tr>
<tr><td><code id="contribution_+3A_type">type</code></td>
<td>
<p>Character, concentration index type that the decomposition should be applied to. Defaults to <code>CI</code>. Use <code>CIw</code> for binary outcomes.</p>
</td></tr>
<tr><td><code id="contribution_+3A_intercept">intercept</code></td>
<td>
<p>Character, one of <code>exclude</code> or <code>include</code>, defaults to <code>exclude</code>. If <code>exclude</code>, the intercept coefficient will not included in the decomposition analysis, if set to <code>include</code>, it will be included.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions decompose the Relative Concentration Index into its components using a (generalized) linear model, optionally using a survey design, or a Cox Proportional Hazards model. Print, summary and plot methods have been defined for the results.
</p>
<p>If <code>correction</code> is <code>TRUE</code> negative values of components or outcome are corrected using <code><a href="#topic+correct_sign">correct_sign()</a></code> with option <code>shift = FALSE</code>.
</p>
<p>For non-linear models the decomposition needs to rely on a linear approximations of the effects. There are different approaches. One is to work on the scale of the <code>glm</code> coefficients and calculate the concentration index based on the predicted outcome. (Konings et al., 2010, Speybroeck et al., 2010). Another approach is to use marginal effects as beta coefficients and the original outcome (O'Donnel et al. 2008).
</p>
<p>This function supports both. For <code>glm</code>, <code>coxph</code>, and <code>svyglm</code> models, the first approach is used. The second approach is implemented for model objects of type <code>probitmfx</code> and <code>logitmfx</code> from the 'mfx' package. See examples.
</p>
<p>Per default, the intercept in models is excluded, but this can be changed by setting the the <code>intercept</code> argument to <code>include</code>, but this may conceptually make less sense and is more appropriate if the model does not contain an intercept.
</p>
<p>Use <code><a href="#topic+decomposition">decomposition()</a></code> function directly to manually specify coefficients, outcomes, and model matrices for arbitrary models.
</p>
<p>NOTE: Be careful with automatically omitted rows in models. Only models with data with ordinary indexes are supported (starting from 1, sequentially increasing by increments of 1). For the case were rows with <code>NA</code> are automatically omitted by the model function, the used indices are guessed based on the row names of the model matrix and then used for accessing the <code>ranker</code> variable. However, this may lead to issues if the row names do not correspond to ordinary integer indexes. For example, if a model such as lm uses the default <code>na.omit</code> action and removes rows, the data in the model might not be consistent with the <code>ranker</code> vector anymore.
</p>


<h3>Value</h3>

<p>An object of class <code>decomposition</code> containing the following components:
</p>

<ul>
<li> <p><code>betas</code> A numeric vector containing regression coefficients
</p>
</li>
<li> <p><code>partial_cis</code> A numeric vector containing partial confidence intervals
</p>
</li>
<li> <p><code>confints</code> A numeric vector containing 95\
</p>
</li>
<li> <p><code>averages</code> Weighted averages of every variable in the model
</p>
</li>
<li> <p><code>ci_contribution</code> Confidence intervals for contributions
</p>
</li>
<li> <p><code>overall_ci</code> Confidence intervals for the concentration index
</p>
</li>
<li> <p><code>corrected_coefficients</code> Corrected coefficients using  <code><a href="#topic+correct_sign">correct_sign()</a></code> if, requested <code>FALSE</code> otherwise
</p>
</li>
<li> <p><code>outcome_corrected</code> Corrected outcome  <code><a href="#topic+correct_sign">correct_sign()</a></code> if requested, <code>FALSE</code> otherwise
</p>
</li>
<li> <p><code>rows</code> Rownames of used rows in the model
</p>
</li></ul>



<h3>Warning</h3>

<p><code>ranker</code> should be chosen with care. Ideally, it is a variable from the same dataframe as the other variables. If not, redefine the row names in the model.
</p>


<h3>Author(s)</h3>

<p>Peter Konings
</p>


<h3>References</h3>

<p>Konings, P., Harper, S., Lynch, J., Hosseinpoor, A.R., Berkvens, D., Lorant, V., Geckova, A., Speybroeck, N., 2010. Analysis of socioeconomic health inequalities using the concentration index. Int J Public Health 55, 71–74. https://doi.org/10.1007/s00038-009-0078-y
</p>
<p>Speybroeck, N., Konings, P., Lynch, J., Harper, S., Berkvens, D., Lorant, V., Geckova, A., Hosseinpoor, A.R., 2010. Decomposing socioeconomic health inequalities. Int J Public Health 55, 347–351. https://doi.org/10.1007/s00038-009-0105-z
</p>
<p>O’Donnell, O., Doorslaer, E. van, Wagstaff, A., Lindelow, M., 2008. Analyzing Health Equity Using Household Survey Data: A Guide to Techniques and Their Implementation, World Bank Publications. The World Bank.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(housing)

## Linear regression direct decomposition
fit.lm &lt;- lm(bmi ~ sex + tenure + place + age,data = housing)
       
# decompose relative concentration index
contrib.lm &lt;- contribution(fit.lm, housing$income) 
summary(contrib.lm)
plot(contrib.lm, decreasing = FALSE, horiz = TRUE)

    
# GLM: Decomposition based on predicted outcome
fit.logit &lt;-glm(high.bmi ~ sex + tenure + place + age, data = housing)

contrib.logit &lt;- contribution(fit.logit, housing$income) 
summary(contrib.logit)
plot(contrib.logit, decreasing = FALSE,horiz = TRUE)


# GLM probit: Decomposition based on predicted outcome
fit.probit &lt;-glm(high.bmi ~ sex + tenure + place + age, data = housing, 
                family = binomial(link = probit))

# binary, set type to 'CIw'
contrib.probit &lt;- contribution(fit.probit, housing$income, type = "CIw") 
summary(contrib.probit)
plot(contrib.probit, decreasing = FALSE,horiz = TRUE)


# Marginal effects probit using package 'mfx': Decomposition based on predicted outcome
fit.mfx &lt;-mfx::probitmfx(high.bmi ~ sex + tenure + place + age, data = housing)

contrib.mfx &lt;- contribution(fit.mfx, housing$income, type = "CIw") 
summary(contrib.mfx, type="CIw")
plot(contrib.mfx, decreasing = FALSE, horiz = TRUE)


# package survey svy 
des = survey::svydesign(~1, data= housing, weights = rep(1, NROW(housing)))
fit.svy = survey::svyglm(bmi ~ tenure+height+weight, design = des)
contrib.svy = contribution(fit.svy, housing$income)


# adapted from the `coxph` example in survival package 
testcph &lt;- data.frame(time = c(4,3,1,1,2,2,3), 
              status = c(1,1,1,0,1,1,0), 
              x      = c(0,2,1,1,1,0,0), 
              sex    = c(0,0,0,0,1,1,1),
              income = c(100,50, 20, 20, 50, 60,100))
              
# Fit a stratified model 
fit.coxph = survival::coxph(Surv(time, status) ~ x + strata(sex), testcph) 
contrib.coxph = contribution(fit.coxph, testcph$income) 


</code></pre>

<hr>
<h2 id='correct_sign'>Corrects negative values in the health variable</h2><span id='topic+correct_sign'></span><span id='topic+corrected_value'></span><span id='topic+is_corrected'></span>

<h3>Description</h3>

<p>The Relative Concentration Index is not bonded between <code class="reqn">[-1,1]</code> if the health variable contains both negative and positive values. This function corrects for this either by imputing a value of 0 for all negative values or by subtracting the minimum value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correct_sign(x, shift = TRUE)

corrected_value(x)

is_corrected(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="correct_sign_+3A_x">x</code></td>
<td>
<p>A numeric vector, typically representing health.</p>
</td></tr>
<tr><td><code id="correct_sign_+3A_shift">shift</code></td>
<td>
<p>If <code>FALSE</code> (the default), 0 is imputed for all negative values in <code>x</code>. If <code>TRUE</code> the minimum value of <code>x</code> is subtracted from it.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>correct_sign()</code> returns a list with 2 components:
</p>

<ul>
<li> <p><code>corrected</code>: corrected version of <code>x</code>
</p>
</li>
<li> <p><code>modified</code>:  logical, <code>TRUE</code> when any of the elements of <code>x</code> have been changed
</p>
</li></ul>

<p><code>corrected_value()</code>: returns the corrected value if passed the result of 'correct_sign().
</p>
<p><code>is_corrected()</code>: returns <code>TRUE</code> if a modifications was made and <code>FALSE</code> otherwise.  Takes as argument the result of <code>correct_sign()</code>,
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>corrected_value()</code>: Return the corrected value
</p>
</li>
<li> <p><code>is_corrected()</code>: Check if the sign was corrected
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Peter Konings
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("housing")

# standardize &amp; normalize bmi, will introduce negative values
housing$bmi.std &lt;- (housing$bmi - mean(housing$bmi))/ sd(housing$bmi)

housing$bmi.std.shifted &lt;- corrected_value(correct_sign(housing$bmi.std, shift = TRUE))
housing$bmi.std.imputed &lt;- corrected_value(correct_sign(housing$bmi.std, shift = FALSE))

## compare the effect of both methods
plot(density(housing$bmi.std, na.rm = TRUE))
points(density(housing$bmi.std.shifted, na.rm = TRUE), col = 'blue')
points(density(housing$bmi.std.imputed, na.rm = TRUE), col = 'green')

</code></pre>

<hr>
<h2 id='decomposition'>Decomposition analysis</h2><span id='topic+decomposition'></span>

<h3>Description</h3>

<p>Used by the wrapper <code><a href="#topic+contribution">contribution()</a></code> but can be used manually. Calculates the decomposition for a given regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decomposition(outcome, betas, mm, ranker, wt, correction, citype = "CI")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="decomposition_+3A_outcome">outcome</code></td>
<td>
<p>Outcome variable</p>
</td></tr>
<tr><td><code id="decomposition_+3A_betas">betas</code></td>
<td>
<p>Beta coefficients from regression.</p>
</td></tr>
<tr><td><code id="decomposition_+3A_mm">mm</code></td>
<td>
<p>Model matrix from regression</p>
</td></tr>
<tr><td><code id="decomposition_+3A_ranker">ranker</code></td>
<td>
<p>Ranking variable</p>
</td></tr>
<tr><td><code id="decomposition_+3A_wt">wt</code></td>
<td>
<p>Weights</p>
</td></tr>
<tr><td><code id="decomposition_+3A_correction">correction</code></td>
<td>
<p>Apply sign correction?</p>
</td></tr>
<tr><td><code id="decomposition_+3A_citype">citype</code></td>
<td>
<p>Character, CI type to be calculated, defaults to <code>CI</code>. Use <code>CIw</code> for binary outcomes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NOTE: Only models with data with ordinary indexes are supported (starting from 1, sequentially increasing by increments of 1). For the case were rows with <code>NA</code> are automatically omitted by the model function, the used indices are guessed based on the row names of the model matrix and then used for accessing the <code>ranker</code> variable. However, this may lead to issues if the row names do not correspond to ordinary integer indexes.
</p>


<h3>Value</h3>

<p>S3 object of class decomposition
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit.lm = lm(mtcars$mpg ~ mtcars$cyl)
decomp = decomposition(mtcars$mpg, coefficients(fit.lm), fit.lm$model, 
                       mtcars$hp, wt = rep(1, nrow(mtcars)), correction = FALSE) 
summary(decomp)

</code></pre>

<hr>
<h2 id='housing'>Artificial example data on housing conditions</h2><span id='topic+housing'></span>

<h3>Description</h3>

<p>Microdata with a permissive license that includes continuous data on health and income is hard to come by. In stead of real data, the package thus includes an imaginary dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(housing)
</code></pre>


<h3>Format</h3>

<p><code>data.frame</code> object.
</p>
<p>Variable list:
</p>

<dl>
<dt>id</dt><dd><p>unique identifier per person</p>
</dd>
<dt>sex</dt><dd><p>female or male</p>
</dd>
<dt>age</dt><dd><p>integer, from 20 to 94</p>
</dd>
<dt>tenure</dt><dd><p>categorical. One of homeless, irregular, own_apartment, own_house, or rent</p>
</dd>
<dt>height</dt><dd><p>height in cm </p>
</dd>
<dt>weight</dt><dd><p>weight in kg</p>
</dd>
<dt>bmi</dt><dd><p>weight/(height/100)^2</p>
</dd>
<dt>income</dt><dd><p>continuous, imaginary currency without unit</p>
</dd>
</dl>



<h3>Source</h3>

<p>Artificially generated by the package authors
</p>

<hr>
<h2 id='plot.decomposition'>Plots a barplot of the contribution percentages in a <code>decomposition</code> object. Sets custom plot margins and uses the graphical parameters <code>xlim</code>, <code>horiz</code>, <code>las</code> and <code>xlab</code> which therefore cannot be customized</h2><span id='topic+plot.decomposition'></span>

<h3>Description</h3>

<p>Plots a barplot of the contribution percentages in a <code>decomposition</code> object. Sets custom plot margins and uses the graphical parameters <code>xlim</code>, <code>horiz</code>, <code>las</code> and <code>xlab</code> which therefore cannot be customized
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'decomposition'
plot(x, decreasing = TRUE, horiz = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.decomposition_+3A_x">x</code></td>
<td>
<p>Object returned from decomposition function</p>
</td></tr>
<tr><td><code id="plot.decomposition_+3A_decreasing">decreasing</code></td>
<td>
<p>Whether to sort contributions decreasing or not</p>
</td></tr>
<tr><td><code id="plot.decomposition_+3A_horiz">horiz</code></td>
<td>
<p>If the barplots should be printed horizontally or vertically</p>
</td></tr>
<tr><td><code id="plot.decomposition_+3A_...">...</code></td>
<td>
<p>Graphical parameter passed on to <code>base::barplot()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns <code>x</code> as the function is called for side effects (plotting).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(housing)
# Linear regression &amp; decompose 
fit.lm &lt;- lm(bmi ~ sex + tenure + place + age,data = housing)
contrib.lm &lt;- contribution(fit.lm, housing$income)

# plot horizontally, in increasing order
plot(contrib.lm, decreasing = FALSE, horiz = TRUE)
</code></pre>

<hr>
<h2 id='plot.hci'>Plots the concentration curve for an <code>hci</code> object.</h2><span id='topic+plot.hci'></span>

<h3>Description</h3>

<p>Plots the concentration curve for an <code>hci</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hci'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.hci_+3A_x">x</code></td>
<td>
<p>Object with of <code>hci</code></p>
</td></tr>
<tr><td><code id="plot.hci_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>base::plot()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns <code>x</code> as the function is called for side effects (plotting).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(housing)
ci.bmi &lt;- ci(ineqvar = housing$income, outcome = housing$bmi, method = "direct")
plot(ci.bmi)
 
</code></pre>

<hr>
<h2 id='print.decomposition'>Print function for <code>decomposition</code> objects.</h2><span id='topic+print.decomposition'></span>

<h3>Description</h3>

<p>Print function for <code>decomposition</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'decomposition'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.decomposition_+3A_x">x</code></td>
<td>
<p>Object of type <code>decomposition</code></p>
</td></tr>
<tr><td><code id="print.decomposition_+3A_...">...</code></td>
<td>
<p>Currently unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns <code>x</code> as the function is called for side effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(housing)
# Linear regression &amp;  decompose 
fit.lm &lt;- lm(bmi ~ sex + tenure + place + age,data = housing)
contrib.lm &lt;- contribution(fit.lm, housing$income)

# print
print(contrib.lm)
</code></pre>

<hr>
<h2 id='print.hci'>Prints an <code>hci</code> object.</h2><span id='topic+print.hci'></span>

<h3>Description</h3>

<p>Prints an <code>hci</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hci'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.hci_+3A_x">x</code></td>
<td>
<p>Object of type <code>hci</code></p>
</td></tr>
<tr><td><code id="print.hci_+3A_...">...</code></td>
<td>
<p>Currently unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns <code>x</code> as the function is called for side effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(housing)
ci.bmi &lt;- ci(ineqvar = housing$income, outcome = housing$bmi, method = "direct")
print(ci.bmi)

</code></pre>

<hr>
<h2 id='rank_gwt'>Generalized weighted ranking function</h2><span id='topic+rank_gwt'></span>

<h3>Description</h3>

<p>In the case of ties, the ordinary <code>rank_wt()</code> function uses the order in the original data.
This is the same approach as in the Stata code provided by O’Donnell et al. (2008) in the original World Bank publication,
but depends on the arbitrary initial order in the data
The Stat conindex code however uses uses the generalized weighted rank implementation published by van Ourti (2004). For Stata compatibility use <code>rank_gwt()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rank_gwt(x, wt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rank_gwt_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="rank_gwt_+3A_wt">wt</code></td>
<td>
<p>weights</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The formula notation in van Ourti (2004) seems to rely on absolute an absolute deduction of 1 unit of monetary income value. This only works
in the integer case. Instead, this this implementation uses the next lowest <code>x</code> value, respectively the next lowest rank, to calculate the
proportion of the inequality variable up to the respective value
</p>


<h3>Value</h3>

<p>A numeric vector containing weighted fractional ranks of the elements of <code>x</code>.
</p>


<h3>References</h3>

<p>van Ourti, T., 2004. Measuring horizontal inequity in Belgian health care using a Gaussian random effects two part count data model. Health Economics, 13: 705–724.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sample(1:10, size = 10, replace = TRUE)
x.weight &lt;- seq(0, 1, length.out = 10)
rank_gwt(x, wt = x.weight)
</code></pre>

<hr>
<h2 id='rank_wt'>Calculates the weighted rank</h2><span id='topic+rank_wt'></span>

<h3>Description</h3>

<p>Calculates the weighted rank
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rank_wt(x, wt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rank_wt_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="rank_wt_+3A_wt">wt</code></td>
<td>
<p>weights</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector containing weighted fractional ranks of the elements of <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Peter Konings
</p>


<h3>References</h3>

<p>Kakwani <em>et al</em>., 1997.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sample(1:10, size = 10, replace = TRUE)
x.weight &lt;- seq(0, 1, length.out = 10)
rank_wt(x, wt = x.weight)
</code></pre>

<hr>
<h2 id='summary.decomposition'>Prints and returns a summary for a <code>decomposition</code> object.</h2><span id='topic+summary.decomposition'></span>

<h3>Description</h3>

<p>Prints and returns a summary for a <code>decomposition</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'decomposition'
summary(object, digits = getOption("digits"), addcoefs = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.decomposition_+3A_object">object</code></td>
<td>
<p>Result of a decomposition analysis, of class <code>decomposition</code></p>
</td></tr>
<tr><td><code id="summary.decomposition_+3A_digits">digits</code></td>
<td>
<p>Number of digits, defaults to R <code>digits</code> option</p>
</td></tr>
<tr><td><code id="summary.decomposition_+3A_addcoefs">addcoefs</code></td>
<td>
<p>Whether or not to add coefficients (defaults to <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="summary.decomposition_+3A_...">...</code></td>
<td>
<p>Additional parameters, currently unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame frame with columns for the absolute and relative contribution, elasticity, concentration index including confidence intervals,
and whether correction was applied. If specified using <code>addcoefs</code>, the coefficients are included as the first column.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(housing)
# Linear regression &amp; decompose 
fit.lm &lt;- lm(bmi ~ sex + tenure + place + age,data = housing)
contrib.lm &lt;- contribution(fit.lm, housing$income)

# print
print(contrib.lm)
</code></pre>

<hr>
<h2 id='summary.hci'>Prints the a summary of the concentration index object <code>hci</code></h2><span id='topic+summary.hci'></span>

<h3>Description</h3>

<p>Prints the a summary of the concentration index object <code>hci</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hci'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.hci_+3A_object">object</code></td>
<td>
<p>Object of type <code>hci</code></p>
</td></tr>
<tr><td><code id="summary.hci_+3A_...">...</code></td>
<td>
<p>Currently unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No returns value. Directly prints to the standard output connection.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(housing)
ci.bmi &lt;- ci(ineqvar = housing$income, outcome = housing$bmi, method = "direct")
summary(ci.bmi)

</code></pre>

<hr>
<h2 id='var_wt'>Calculates the weighted variance</h2><span id='topic+var_wt'></span>

<h3>Description</h3>

<p>Calculates the weighted variance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var_wt(x, wt, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="var_wt_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="var_wt_+3A_wt">wt</code></td>
<td>
<p>weights</p>
</td></tr>
<tr><td><code id="var_wt_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>TRUE</code>, indices where <code>x</code> is NA will be removed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector containing weighted variance of the elements of <code>x</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sample(1:10, size = 10, replace = TRUE)
x.weight &lt;- seq(0, 1, length.out = 10)
var_wt(x, wt = x.weight)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
