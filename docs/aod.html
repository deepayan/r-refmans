<!DOCTYPE html><html><head><title>Help for package aod</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {aod}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aic-class'><p>Representation of Objects of Formal Class &quot;aic&quot;</p></a></li>
<li><a href='#AIC-methods'><p>Akaike Information Criteria</p></a></li>
<li><a href='#anova-methods'><p>Likelihood-Ratio Tests for Nested ML Models</p></a></li>
<li><a href='#antibio'><p>Antibiotics against Shipping Fever in Calves</p></a></li>
<li><a href='#aod-pkg'><p>Analysis of Overdispersed Data</p></a></li>
<li><a href='#betabin'><p>Beta-Binomial Model for Proportions</p></a></li>
<li><a href='#coef-methods'><p>Methods for Function &quot;coef&quot; in Package &quot;aod&quot;</p></a></li>
<li><a href='#cohorts'><p>Age, Period and Cohort Effects for Vital Rates</p></a></li>
<li><a href='#deviance-methods'><p>Methods for Function &quot;deviance&quot; in Package &quot;aod&quot;</p></a></li>
<li><a href='#df.residual-methods'><p>Methods for Function &quot;df.residual&quot; in Package &quot;aod&quot;</p></a></li>
<li><a href='#dja'><p> Mortality of Djallonke Lambs in Senegal</p></a></li>
<li><a href='#donner'><p>Test of Proportion Homogeneity using Donner's Adjustment</p></a></li>
<li><a href='#drs-class'><p>Representation of Objects of Formal Class &quot;drs&quot;</p></a></li>
<li><a href='#fitted-methods'><p>Methods for Function &quot;fitted&quot; in Package &quot;aod&quot;</p></a></li>
<li><a href='#glimML-class'><p>Representation of Models of Formal Class &quot;glimML&quot;</p></a></li>
<li><a href='#glimQL-class'><p>Representation of Models of Formal Class &quot;glimQL&quot;</p></a></li>
<li><a href='#iccbin'><p>Intra-Cluster Correlation for Binomial Data</p></a></li>
<li><a href='#iccbin-class'><p>Representation of Objects of Formal Class &quot;iccbin&quot;</p></a></li>
<li><a href='#invlink'><p>Transformation from the Link Scale to the Observation Scale</p></a></li>
<li><a href='#link'><p>Transformation from the Observation Scale to the Link Scale</p></a></li>
<li><a href='#lizards'><p>A Comparison of Site Preferences of Two Species of Lizard</p></a></li>
<li><a href='#logLik-methods'><p>Methods for Functions &quot;logLik&quot; in Package &quot;aod&quot;</p></a></li>
<li><a href='#mice'><p> Pregnant Female Mice Experiment</p></a></li>
<li><a href='#negbin'><p>Negative-Binomial Model for Counts</p></a></li>
<li><a href='#orob1'><p> Germination Data</p></a></li>
<li><a href='#orob2'><p> Germination Data</p></a></li>
<li><a href='#predict-methods'><p>Methods for Function &quot;predict&quot; in Package &quot;aod&quot;</p></a></li>
<li><a href='#quasibin'><p>Quasi-Likelihood Model for Proportions</p></a></li>
<li><a href='#quasipois'><p>Quasi-Likelihood Model for Counts</p></a></li>
<li><a href='#rabbits'><p> Rabbits Foetuses Survival Experiment</p></a></li>
<li><a href='#raoscott'><p>Test of Proportion Homogeneity using Rao and Scott's Adjustment</p></a></li>
<li><a href='#rats'><p> Rats Diet Experiment</p></a></li>
<li><a href='#residuals-methods'><p>Residuals for Maximum-Likelihood and Quasi-Likelihood Models</p></a></li>
<li><a href='#salmonella'><p>Salmonella Reverse Mutagenicity Assay</p></a></li>
<li><a href='#splitbin'><p>Split Grouped Data Into Individual Data</p></a></li>
<li><a href='#summary,aic-method'><p>Akaike Information Statistics</p></a></li>
<li><a href='#summary.glimML-class'><p>Summary of Objects of Class &quot;summary.glimML&quot;</p></a></li>
<li><a href='#varbin'><p>Mean, Variance and Confidence Interval of a Proportion</p></a></li>
<li><a href='#varbin-class'><p>Representation of Objects of Formal Class &quot;varbin&quot;</p></a></li>
<li><a href='#vcov-methods'><p>Methods for Function &quot;vcov&quot; in Package &quot;aod&quot;</p></a></li>
<li><a href='#wald.test'><p>Wald Test for Model Coefficients</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.3.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2012-04-10</td>
</tr>
<tr>
<td>Title:</td>
<td>Analysis of Overdispersed Data</td>
</tr>
<tr>
<td>Author:</td>
<td>Matthieu Lesnoff &lt;matthieu.lesnoff@cirad.fr&gt; and Renaud
        Lancelot &lt;renaud.lancelot@cirad.fr&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Renaud Lancelot &lt;renaud.lancelot@cirad.fr&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), methods, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS, boot, lme4</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a set of functions to analyse
        overdispersed counts or proportions. Most of the methods are
        already available elsewhere but are scattered in different
        packages. The proposed functions should be considered as
        complements to more sophisticated methods such as generalized
        estimating equations (GEE) or generalized linear mixed effect
        models (GLMM).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://cran.r-project.org/package=aod">https://cran.r-project.org/package=aod</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-11 19:52:10 UTC; hornik</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-13 17:27:45 UTC</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
</table>
<hr>
<h2 id='aic-class'>Representation of Objects of Formal Class &quot;aic&quot;</h2><span id='topic+aic-class'></span>

<h3>Description</h3>

<p>Representation of the output of function <code>AIC</code>.</p>


<h3>Slots</h3>



<dl>
<dt>istats</dt><dd><p>A data frame with 3 columns describing the models indicated by the row names:
</p>

<dl>
<dt><b>df</b></dt><dd><p>number of parameters in the model</p>
</dd></dl>
<p>,
</p>
<dl>
<dt><b>AIC</b></dt><dd><p>Akaike information criterion for the model (see <code><a href="#topic+AIC">AIC</a></code>)</p>
</dd></dl>
<p>,
</p>
<dl>
<dt><b>AICc</b></dt><dd><p>small-sample corrected Akaike information criterion for the model (see <code><a href="#topic+AIC">AIC</a></code>).</p>
</dd>
</dl>

</dd>
</dl>



<h3>Methods</h3>



<dl>
<dt>summary</dt><dd><p><code>signature(object = "aic")</code></p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "aic")</code></p>
</dd>
</dl>


<hr>
<h2 id='AIC-methods'>Akaike Information Criteria</h2><span id='topic+AIC+2CglimML-method'></span>

<h3>Description</h3>

<p>Extracts the Akaike information criterion (AIC) and the corrected AIC (AICc) from fitted models of formal 
class &ldquo;glimML&rdquo; and possibly computes derived statistics.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'glimML'
AIC(object, ..., k = 2)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AIC-methods_+3A_object">object</code></td>
<td>
<p>fitted model of formal class &ldquo;glimML&rdquo; (functions <code>betabin</code> or <code>negbin</code>).</p>
</td></tr>
<tr><td><code id="AIC-methods_+3A_...">...</code></td>
<td>
<p>optional list of fitted models separated by commas.</p>
</td></tr>
<tr><td><code id="AIC-methods_+3A_k">k</code></td>
<td>
<p>numeric scalar, with a default value set to 2, thus providing the regular AIC.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code class="reqn">AIC = -2~\mbox{log-likelihood} + 2*n_{par}</code>, where <code class="reqn">n_{par}</code>
represents the number of parameters in the fitted model.<br />
<code class="reqn">AICc = AIC + 2 * n_{par} * (n_{par} + 1) / (n_{obs} - n_{par} + 1)</code>,
where <code class="reqn">n_{obs}</code> is the number of observations used to compute the log-likelihood. It should be used when the number 
of fitted parameters is large compared to sample size, i.e., when  <code class="reqn">n_{obs} / n_{par} &lt; 40</code> (Hurvich and Tsai, 1995).
</p>


<h3>Methods</h3>


<dl>
<dt>glimML</dt><dd><p>Extracts the AIC and AICc from models of formal class &ldquo;glimML&rdquo;, fitted by functions 
<code>betabin</code> and <code>negbin</code>.</p>
</dd>
</dl>



<h3>References</h3>

<p>Burnham, K.P., Anderson, D.R., 2002. <em>Model selection and multimodel inference: a practical
information-theoretic approach</em>. New-York, Springer-Verlag, 496 p.<br />
Hurvich, C.M., Tsai, C.-L., 1995. <em>Model selection for extended quasi-likelihood models in small samples</em>. 
Biometrics, 51 (3): 1077-1084.</p>


<h3>See Also</h3>

<p>Examples in <code><a href="#topic+betabin">betabin</a></code> and see <code><a href="stats.html#topic+AIC">AIC</a></code> in package <span class="pkg">stats</span>.</p>

<hr>
<h2 id='anova-methods'>Likelihood-Ratio Tests for Nested ML Models</h2><span id='topic+anova+2CglimML-method'></span><span id='topic+anova.glimML-class'></span><span id='topic+show+2Canova.glimML-method'></span>

<h3>Description</h3>

<p>Performs likelihood-ratio tests on nested models. Currently, one method was implemented
for beta-binomial models (<code>betabin</code>) or negative-binomial models (<code>negbin</code>).</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S4 method for signature 'glimML'
anova(object, ...)
  </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anova-methods_+3A_object">object</code></td>
<td>
<p>Fitted model of class &ldquo;glimML&rdquo;.</p>
</td></tr>
<tr><td><code id="anova-methods_+3A_...">...</code></td>
<td>
<p>Further models to be tested or arguments passed to the <code>print</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>anova</code> method for models of formal class &ldquo;glimML&rdquo; needs at least 2 nested models of the 
same type (either beta-binomial or negative-binomial models: they cannot be mixed). The quantity of interest is 
the deviance difference between the compared models: it is a log-likelihood ratio statistic. Under the null 
hypothesis that 2 nested models fit the data equally well, the deviance difference has an approximate 
<code class="reqn">\chi^2</code> distribution with degrees of freedom = the difference in the number of parameters between 
the compared models (Mc Cullagh and Nelder, 1989).</p>


<h3>Value</h3>

<p>An object of formal class &ldquo;anova.glimML&rdquo; with 3 slots:
</p>
<table>
<tr><td><code>models</code></td>
<td>
<p>A vector of character strings with each component giving the name of the models and the formulas for 
the fixed and random effects.</p>
</td></tr>
<tr><td><code>anova.table</code></td>
<td>
<p>A data frame containing the results. Row names correspond to the models.
</p>

<table>
<tr>
 <td style="text-align: left;">
      logL        </td><td style="text-align: left;"> numeric   </td><td style="text-align: left;"> maximized log-likelihood</td>
</tr>
<tr>
 <td style="text-align: left;">
      k           </td><td style="text-align: left;"> numeric   </td><td style="text-align: left;"> number of parameters in the model</td>
</tr>
<tr>
 <td style="text-align: left;">
      AIC         </td><td style="text-align: left;"> numeric   </td><td style="text-align: left;"> Akaike information criterion for the model</td>
</tr>
<tr>
 <td style="text-align: left;">
      AICc        </td><td style="text-align: left;"> numeric   </td><td style="text-align: left;"> Corrected Akaike information criterion for the model</td>
</tr>
<tr>
 <td style="text-align: left;">
      BIC         </td><td style="text-align: left;"> numeric   </td><td style="text-align: left;"> Bayesian information criterion the model</td>
</tr>
<tr>
 <td style="text-align: left;">
      Resid. dev. </td><td style="text-align: left;"> numeric   </td><td style="text-align: left;"> Residual deviance</td>
</tr>
<tr>
 <td style="text-align: left;">
      Resid. Df   </td><td style="text-align: left;"> numeric   </td><td style="text-align: left;"> df of the residuals</td>
</tr>
<tr>
 <td style="text-align: left;">
      Test        </td><td style="text-align: left;"> character </td><td style="text-align: left;"> Nested models which are tested</td>
</tr>
<tr>
 <td style="text-align: left;">
      Deviance    </td><td style="text-align: left;"> numeric   </td><td style="text-align: left;"> Deviance difference between the 2 models</td>
</tr>
<tr>
 <td style="text-align: left;">
      Df          </td><td style="text-align: left;"> numeric   </td><td style="text-align: left;"> df associated with deviance difference</td>
</tr>
<tr>
 <td style="text-align: left;">
      P(&gt; Chi2)   </td><td style="text-align: left;"> numeric   </td><td style="text-align: left;"> P value associated with H0.
      </td>
</tr>

</table>

</td></tr>
<tr><td><code>type</code></td>
<td>
<p>A character chain indicating the kind of fitted model: &ldquo;BB&rdquo; for beta-binomial, or &ldquo;NB&rdquo; for 
negative-binomial model.</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>The comparison between 2 or more models will only be valid if they are fitted to the same data set.</p>


<h3>References</h3>

<p>McCullagh, P., Nelder, J.A., 1989. <em>Generalized linear models</em>. London, Chapman &amp; Hall, 511 p.<br /> 
See Appendix C. Likelihood ratio statistics, p. 476-478.</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+anova.glm">anova.glm</a></code>, <code><a href="#topic+AIC">AIC</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(orob2)
  # likelihood ratio test for the effect of root
  fm1 &lt;- betabin(cbind(y, n - y) ~ seed, ~ 1, data = orob2)
  fm2 &lt;- betabin(cbind(y, n - y) ~ seed + root, ~ 1, data = orob2)
  anova(fm1, fm2)
  </code></pre>

<hr>
<h2 id='antibio'>Antibiotics against Shipping Fever in Calves</h2><span id='topic+antibio'></span>

<h3>Description</h3>

<p>Hypothetical drug trial to compare the effect of four antibiotics against Shipping fever in calves 
(Shoukri and Pause, 1999, Table 3.11).</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(antibio)</code></pre>


<h3>Format</h3>

<p>A data frame with 24 observations on the following 3 variables.
</p>

<dl>
<dt>treatment</dt><dd><p>A factor with levels <code>1</code>, <code>2</code>, <code>3</code> and <code>4</code></p>
</dd>
<dt>n</dt><dd><p>A numeric vector: the number of treated animals within a two-week period.</p>
</dd>
<dt>y</dt><dd><p>A numeric vector: the number of deaths at the end of the two weeks.</p>
</dd>
</dl>



<h3>References</h3>

<p>Shoukri, M.M., Pause, C.A., 1999, 2nd ed. <em>Statistical methods for health sciences</em>. CRC Press, London.</p>

<hr>
<h2 id='aod-pkg'>Analysis of Overdispersed Data</h2><span id='topic+aod-pkg'></span><span id='topic+aod'></span>

<h3>Description</h3>

<p>This package provides a set of functions to analyse overdispersed counts or proportions. Most of the methods are
already available elsewhere but are scattered in different packages. The proposed functions should be considered as
complements to more sophisticated methods such as generalized estimating equations (GEE) or generalized linear mixed effect
models (GLMM).
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
    Package: </td><td style="text-align: left;"> aod</td>
</tr>
<tr>
 <td style="text-align: left;">
    Version: </td><td style="text-align: left;"> 1.1-32</td>
</tr>
<tr>
 <td style="text-align: left;">
    Date: </td><td style="text-align: left;"> 2010-04-02</td>
</tr>
<tr>
 <td style="text-align: left;">
    Depends: </td><td style="text-align: left;"> R (&gt;= 2.0.0), methods, stats</td>
</tr>
<tr>
 <td style="text-align: left;">
    Suggests: </td><td style="text-align: left;"> MASS, nlme, boot</td>
</tr>
<tr>
 <td style="text-align: left;">
    License: </td><td style="text-align: left;"> GPL version 2 or newer</td>
</tr>
<tr>
 <td style="text-align: left;">
    URL: </td><td style="text-align: left;"> http://cran.r-project.org/package=aod</td>
</tr>
<tr>
 <td style="text-align: left;">
    LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
    LazyData: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p>Index :
</p>

<table>
<tr>
 <td style="text-align: left;">
  AIC-methods          </td><td style="text-align: left;"> Akaike Information Criteria</td>
</tr>
<tr>
 <td style="text-align: left;">
  aic-class            </td><td style="text-align: left;"> Representation of Objects of Formal Class &ldquo;aic&rdquo;</td>
</tr>
<tr>
 <td style="text-align: left;">
  anova-method         </td><td style="text-align: left;"> Likelihood-Ratio Tests for Nested ML Models</td>
</tr>
<tr>
 <td style="text-align: left;">
  antibio              </td><td style="text-align: left;"> Antibiotics against Shipping Fever in Calves</td>
</tr>
<tr>
 <td style="text-align: left;">
  betabin              </td><td style="text-align: left;"> Beta-Binomial Model for Proportions</td>
</tr>
<tr>
 <td style="text-align: left;">
  coef-methods         </td><td style="text-align: left;"> Methods for Function &ldquo;coef&rdquo; in Package <span class="pkg">aod</span></td>
</tr>
<tr>
 <td style="text-align: left;">
  cohorts              </td><td style="text-align: left;"> Data set: Age, Period and Cohort Effects for Vital Rates</td>
</tr>
<tr>
 <td style="text-align: left;">
  deviance-methods     </td><td style="text-align: left;"> Methods for Function <code>deviance</code> in Package <span class="pkg">aod</span></td>
</tr>
<tr>
 <td style="text-align: left;">
  df.residual-methods  </td><td style="text-align: left;"> Methods for Function <code>df.residual</code> in Package <span class="pkg">aod</span></td>
</tr>
<tr>
 <td style="text-align: left;">
  dja                  </td><td style="text-align: left;"> Mortality of Djallonke Lambs in Senegal</td>
</tr>
<tr>
 <td style="text-align: left;">
  donner               </td><td style="text-align: left;"> Test of Proportion Homogeneity using Donner's Adjustment</td>
</tr>
<tr>
 <td style="text-align: left;">
  drs-class            </td><td style="text-align: left;"> Representation of Objects of Formal Class &ldquo;drs&rdquo;</td>
</tr>
<tr>
 <td style="text-align: left;">
  fitted-methods       </td><td style="text-align: left;"> Methods for Function <code>fitted</code> in Package <span class="pkg">aod</span></td>
</tr>
<tr>
 <td style="text-align: left;">
  glimML-class         </td><td style="text-align: left;"> Representation of Models of Formal Class &ldquo;glimML&rdquo;</td>
</tr>
<tr>
 <td style="text-align: left;">
  glimQL-class         </td><td style="text-align: left;"> Representation of Models of Formal Class &ldquo;glimQL&rdquo;</td>
</tr>
<tr>
 <td style="text-align: left;">
  icc                  </td><td style="text-align: left;"> Intra-Cluster Correlation</td>
</tr>
<tr>
 <td style="text-align: left;">
  icc-class            </td><td style="text-align: left;"> Representation of Objects of Formal Class &ldquo;icc&rdquo;</td>
</tr>
<tr>
 <td style="text-align: left;">
  invlink              </td><td style="text-align: left;"> Transformation from the Link Scale to the Observation Scale</td>
</tr>
<tr>
 <td style="text-align: left;">
  link                 </td><td style="text-align: left;"> Transformation from the Observation Scale to the Link Scale</td>
</tr>
<tr>
 <td style="text-align: left;">
  lizards              </td><td style="text-align: left;"> A Comparison of Site Preferences of Two Species of Lizard</td>
</tr>
<tr>
 <td style="text-align: left;">
  logLik-methods       </td><td style="text-align: left;"> Methods for Functions &ldquo;logLik&rdquo; in Package <span class="pkg">aod</span></td>
</tr>
<tr>
 <td style="text-align: left;">
  mice                 </td><td style="text-align: left;"> Pregnant Female Mice Experiment</td>
</tr>
<tr>
 <td style="text-align: left;">
  negbin               </td><td style="text-align: left;"> Negative-Binomial Model for Counts</td>
</tr>
<tr>
 <td style="text-align: left;">
  orob1                </td><td style="text-align: left;"> Germination Data</td>
</tr>
<tr>
 <td style="text-align: left;">
  orob2                </td><td style="text-align: left;"> Germination Data</td>
</tr>
<tr>
 <td style="text-align: left;">
  predict-methods      </td><td style="text-align: left;"> Methods for Function &ldquo;predict&rdquo; in Package <span class="pkg">aod</span></td>
</tr>
<tr>
 <td style="text-align: left;">
  quasibin             </td><td style="text-align: left;"> Quasi-Likelihood Model for Proportions</td>
</tr>
<tr>
 <td style="text-align: left;">
  quasipois            </td><td style="text-align: left;"> Quasi-Likelihood Model for Counts</td>
</tr>
<tr>
 <td style="text-align: left;">
  rabbits              </td><td style="text-align: left;"> Rabbits Foetuses Survival Experiment</td>
</tr>
<tr>
 <td style="text-align: left;">
  raoscott             </td><td style="text-align: left;"> Test of Proportion Homogeneity using Rao and Scott's Adjustment</td>
</tr>
<tr>
 <td style="text-align: left;">
  rats                 </td><td style="text-align: left;"> Rats Diet Experiment</td>
</tr>
<tr>
 <td style="text-align: left;">
  residuals-methods    </td><td style="text-align: left;"> Residuals for Maximum-Likelihood and Quasi-Likelihood Models</td>
</tr>
<tr>
 <td style="text-align: left;">
  salmonella           </td><td style="text-align: left;"> Salmonella Reverse Mutagenicity Assay</td>
</tr>
<tr>
 <td style="text-align: left;">
  splitbin             </td><td style="text-align: left;"> Splits Binomial Data into Bernoulli Data</td>
</tr>
<tr>
 <td style="text-align: left;">
  summary,aic-method   </td><td style="text-align: left;"> Akaike Information Statistics</td>
</tr>
<tr>
 <td style="text-align: left;">
  summary.glimML-class </td><td style="text-align: left;"> Summary of Objects of Class &ldquo;summary.glimML&rdquo;</td>
</tr>
<tr>
 <td style="text-align: left;">
  varbin               </td><td style="text-align: left;"> Mean, Variance and Confidence Interval of a Proportion</td>
</tr>
<tr>
 <td style="text-align: left;">
  varbin-class         </td><td style="text-align: left;"> Representation of Objects of Formal Class &ldquo;varbin&rdquo;</td>
</tr>
<tr>
 <td style="text-align: left;">
  vcov-methods         </td><td style="text-align: left;"> Methods for Function &ldquo;vcov&rdquo; in Package <span class="pkg">aod</span></td>
</tr>
<tr>
 <td style="text-align: left;">
  wald.test            </td><td style="text-align: left;"> Wald Test for Model Coefficients</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Matthieu Lesnoff &lt;matthieu.lesnoff@cirad.fr&gt; and Renaud Lancelot &lt;renaud.lancelot@cirad.fr&gt;<br />
Maintainer: Renaud Lancelot
</p>

<hr>
<h2 id='betabin'>Beta-Binomial Model for Proportions</h2><span id='topic+betabin'></span>

<h3>Description</h3>

<p>Fits a beta-binomial generalized linear model accounting for overdispersion in clustered binomial data <code class="reqn">(n, y)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  betabin(formula, random, data, link = c("logit", "cloglog"), phi.ini = NULL,
          warnings = FALSE, na.action = na.omit, fixpar = list(),
          hessian = TRUE, control = list(maxit = 2000), ...)
  </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="betabin_+3A_formula">formula</code></td>
<td>
<p>A formula for the fixed effects <code>b</code>. The left-hand side of the formula must be of the form
<code>cbind(y, n - y)</code> where the modelled probability is <code>y/n</code>.</p>
</td></tr>
<tr><td><code id="betabin_+3A_random">random</code></td>
<td>
<p>A right-hand formula for the overdispersion parameter(s) <code class="reqn">\phi</code>.</p>
</td></tr>
<tr><td><code id="betabin_+3A_link">link</code></td>
<td>
<p>The link function for the mean <code class="reqn">p</code>: &ldquo;logit&rdquo; or &ldquo;cloglog&rdquo;.</p>
</td></tr>
<tr><td><code id="betabin_+3A_data">data</code></td>
<td>
<p>A data frame containing the response (<code>n</code> and <code>y</code>) and explanatory variable(s).</p>
</td></tr>
<tr><td><code id="betabin_+3A_phi.ini">phi.ini</code></td>
<td>
<p>Initial values for the overdispersion parameter(s) <code class="reqn">\phi</code>. Default to 0.1.</p>
</td></tr>
<tr><td><code id="betabin_+3A_warnings">warnings</code></td>
<td>
<p>Logical to control the printing of warnings occurring during log-likelihood maximization. 
Default to <code>FALSE</code> (no printing).</p>
</td></tr>
<tr><td><code id="betabin_+3A_na.action">na.action</code></td>
<td>
<p>A function name: which action should be taken in the case of missing value(s).</p>
</td></tr>
<tr><td><code id="betabin_+3A_fixpar">fixpar</code></td>
<td>
<p>A list with 2 components (scalars or vectors) of the same size, indicating which parameters are 
fixed (i.e., not optimized) in the global parameter vector <code class="reqn">(b, \phi)</code> and the corresponding fixed values.<br />
For example, <code>fixpar = list(c(4, 5), c(0, 0))</code> means that 4th and 5th parameters of the model are set to 0.</p>
</td></tr>
<tr><td><code id="betabin_+3A_hessian">hessian</code></td>
<td>
<p>A logical. When set to <code>FALSE</code>, the hessian and the variances-covariances matrices of the 
parameters are not computed.</p>
</td></tr>
<tr><td><code id="betabin_+3A_control">control</code></td>
<td>
<p>A list to control the optimization parameters. See <code><a href="stats.html#topic+optim">optim</a></code>. By default, set the maximum number of iterations to 2000.</p>
</td></tr>
<tr><td><code id="betabin_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a given cluster <code class="reqn">(n, y)</code>, the model is:
</p>
<p style="text-align: center;"><code class="reqn">y~|~\lambda \sim Binomial(n,~\lambda)</code>
</p>

<p>with <code class="reqn">\lambda</code> following a Beta distribution <code class="reqn">Beta(a1,~a2)</code>.<br />
If <code class="reqn">B</code> denotes the beta function, then:
</p>
<p style="text-align: center;"><code class="reqn">P(\lambda) = \frac{\lambda^{a1~-~1} * (1~-~\lambda)^{a2 - 1}}{B(a1,~a2)}</code>
</p>

<p style="text-align: center;"><code class="reqn">E[\lambda] = \frac{a1}{a1 + a2}</code>
</p>

<p style="text-align: center;"><code class="reqn">Var[\lambda] = \frac{a1 * a2}{(a1 + a2 + 1) * (a1 + a2)^2}</code>
</p>

<p>The marginal beta-binomial distribution is:
</p>
<p style="text-align: center;"><code class="reqn">P(y) = \frac{C(n,~y) * B(a1 + y, a2 + n - y)}{B(a1,~a2)}</code>
</p>

<p>The function uses the parameterization <code class="reqn">p = \frac{a1}{a1 + a2} = h(X b) = h(\eta)</code> and <code class="reqn">\phi = \frac{1}{a1 + a2 + 1}</code>, 
where <code class="reqn">h</code> is the inverse of the link function (logit or complementary log-log), <code class="reqn">X</code> is a design-matrix, <code class="reqn">b</code> 
is a vector of fixed effects, <code class="reqn">\eta = X b</code> is the linear predictor and <code class="reqn">\phi</code> is the overdispersion
parameter (i.e., the intracluster correlation coefficient, which is here restricted to be positive).<br />
The marginal mean and variance are:
</p>
<p style="text-align: center;"><code class="reqn">E[y] = n * p</code>
</p>

<p style="text-align: center;"><code class="reqn">Var[y] = n * p * (1 - p) * [1 + (n - 1) * \phi]</code>
</p>

<p>The parameters <code class="reqn">b</code> and <code class="reqn">\phi</code> are estimated by maximizing the log-likelihood of the marginal model (using the
function <code>optim</code>). Several explanatory variables are allowed in <code class="reqn">b</code>, only one in <code class="reqn">\phi</code>.
</p>


<h3>Value</h3>

<p>An object of formal class &ldquo;glimML&rdquo;: see <code><a href="#topic+glimML-class">glimML-class</a></code> for details.
</p>


<h3>Author(s)</h3>

<p>Matthieu Lesnoff <a href="mailto:matthieu.lesnoff@cirad.fr">matthieu.lesnoff@cirad.fr</a>, Renaud Lancelot <a href="mailto:renaud.lancelot@cirad.fr">renaud.lancelot@cirad.fr</a>
</p>


<h3>References</h3>

<p>Crowder, M.J., 1978. <em>Beta-binomial anova for proportions</em>. Appl. Statist. 27, 34-37.<br />
Griffiths, D.A., 1973. <em>Maximum likelihood estimation for the beta-binomial distribution and an application
to the household distribution of the total number of cases of disease</em>. Biometrics 29, 637-648.<br />
Prentice, R.L., 1986. <em>Binary regression using an extended beta-binomial distribution, with discussion of
correlation induced by covariate measurement errors</em>. J.A.S.A. 81, 321-327.<br />
Williams, D.A., 1975. <em>The analysis of binary responses from toxicological experiments involving
reproduction and teratogenicity</em>. Biometrics 31, 949-952.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+glimML-class">glimML-class</a></code>, <code><a href="stats.html#topic+glm">glm</a></code> and <code><a href="stats.html#topic+optim">optim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(orob2)
  fm1 &lt;- betabin(cbind(y, n - y) ~ seed, ~ 1, data = orob2)
  fm2 &lt;- betabin(cbind(y, n - y) ~ seed + root, ~ 1, data = orob2)
  fm3 &lt;- betabin(cbind(y, n - y) ~ seed * root, ~ 1, data = orob2)
  # show the model
  fm1; fm2; fm3
  # AIC
  AIC(fm1, fm2, fm3)
  summary(AIC(fm1, fm2, fm3), which = "AICc")
  # Wald test for root effect
  wald.test(b = coef(fm3), Sigma = vcov(fm3), Terms = 3:4)
  # likelihood ratio test for root effect
  anova(fm1, fm3)
  # model predictions
  New &lt;- expand.grid(seed = levels(orob2$seed),
                     root = levels(orob2$root))
  data.frame(New, predict(fm3, New, se = TRUE, type = "response"))
  # Djallonke sheep data
  data(dja)
  betabin(cbind(y, n - y) ~ group, ~ 1, dja)
  # heterogeneous phi
  betabin(cbind(y, n - y) ~ group, ~ group, dja,
          control = list(maxit = 1000))
  # phi fixed to zero in group TREAT
   betabin(cbind(y, n - y) ~ group, ~ group, dja,
    fixpar = list(4, 0))
  # glim without overdispersion
  summary(glm(cbind(y, n - y) ~ group,
    family = binomial, data = dja))
  # phi fixed to zero in both groups
  betabin(cbind(y, n - y) ~ group, ~ group, dja,
    fixpar = list(c(3, 4), c(0, 0))) 
  </code></pre>

<hr>
<h2 id='coef-methods'>Methods for Function &quot;coef&quot; in Package &quot;aod&quot;</h2><span id='topic+coef+2CglimML-method'></span><span id='topic+coef+2CglimQL-method'></span>

<h3>Description</h3>

<p>Extract the fixed-effect coefficients from fitted objects.</p>


<h3>Methods</h3>


<dl>
<dt>ANY</dt><dd><p>Generic function: see <code><a href="stats.html#topic+coef">coef</a></code>.</p>
</dd>
<dt>glimML</dt><dd><p>Extract the estimated fixed-effect coefficients from objects of formal class &ldquo;glimML&rdquo;. 
Presently, these objects are generated by functions <code>betabin</code> and <code>negbin</code>.</p>
</dd> 
<dt>glimQL</dt><dd><p>Extract the estimated fixed-effect coefficients from objects of formal class &ldquo;glimQL&rdquo;. 
Presently, these objects are generated by functions <code>quasibin</code> and <code>quasipois</code>.</p>
</dd> 
</dl>

<hr>
<h2 id='cohorts'>Age, Period and Cohort Effects for Vital Rates</h2><span id='topic+cohorts'></span>

<h3>Description</h3>

<p>Number of prostate cancer deaths and midperiod population for nonwhites in the USA by age and period.
The cohort index <code class="reqn">k</code> is related to age and period indices (<code class="reqn">i</code> and <code class="reqn">j</code>, respectively) by <code class="reqn">k = j + I - i</code>, 
where <code class="reqn">I = max(i)</code> (Holford, 1983, Table 2).</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cohorts)</code></pre>


<h3>Format</h3>

<p>A data frame with 49 observations on the following 4 variables.
</p>

<dl>
<dt>period</dt><dd><p>A factor with levels <code>1935-</code>, <code>1940-</code>, ..., <code>1965-</code>.</p>
</dd>
<dt>age</dt><dd><p>A factor with levels <code>50-</code>, <code>55-</code>, ..., <code>80-</code>.</p>
</dd>
<dt>y</dt><dd><p>Numeric: the number of prostate cancer deaths.</p>
</dd>
<dt>n</dt><dd><p>Numeric: the midperiod population size.</p>
</dd>
</dl>



<h3>References</h3>

<p>Holford, T.R., 1983. <em>The estimation of age, period and cohort effects for vital rates</em>. Biometrics 39, 311-324.
</p>

<hr>
<h2 id='deviance-methods'>Methods for Function &quot;deviance&quot; in Package &quot;aod&quot;</h2><span id='topic+deviance+2CglimML-method'></span>

<h3>Description</h3>

<p>Extracts the deviance fitted models.</p>


<h3>Methods</h3>


<dl>
<dt>ANY</dt><dd><p>Generic function: see <code><a href="stats.html#topic+deviance">deviance</a></code>.</p>
</dd>
<dt>glimML</dt><dd><p>Extracts the deviance from models fitted by <code>betabin</code> or <code>negbin</code>.</p>
</dd>
</dl>

<hr>
<h2 id='df.residual-methods'>Methods for Function &quot;df.residual&quot; in Package &quot;aod&quot;</h2><span id='topic+df.residual+2CglimML-method'></span><span id='topic+df.residual+2CglimQL-method'></span>

<h3>Description</h3>

<p>Computes the number of degrees of freedom of the residuals from fitted objects.</p>


<h3>Methods</h3>


<dl>
<dt>ANY</dt><dd><p>Generic function: see <code><a href="stats.html#topic+df.residual">df.residual</a></code>.</p>
</dd>
<dt>glimML</dt><dd><p>Computes the df of residuals for models fitted by <code>betabin</code> or <code>negbin</code>.</p>
</dd>
<dt>glimQL</dt><dd><p>Computes the df of residuals for models fitted by <code>quasibin</code> or <code>quasipois</code>.</p>
</dd>
</dl>

<hr>
<h2 id='dja'> Mortality of Djallonke Lambs in Senegal </h2><span id='topic+dja'></span>

<h3>Description</h3>

<p>Field trial to assess the effect of ewes deworming (prevention of gastro-intestinal parasitism) on the mortality
of their offspring (age &lt; 1 year). This data set is extracted from a large database on small ruminants production
and health in Senegal (Lancelot et al., 1998). Data were collected in a sample of herds in Kolda (Upper Casamance,
Senegal) during a multi-site survey (Faugère et al., 1992). See also the references below for a presentation of the
follow-up survey (Faugère and Faugère, 1986) and a description of the farming systems (Faugère et al., 1990).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dja)</code></pre>


<h3>Format</h3>

<p>A data frame with 21 observations on the following 4 variables.
</p>

<dl>
<dt>group</dt><dd><p>a factor with 2 levels: <code>CTRL</code> and <code>TREAT</code>, indicating the treatment.</p>
</dd>
<dt>village</dt><dd><p>a factor indicating the village of the herd.</p>
</dd>
<dt>herd</dt><dd><p>a factor indicating the herd.</p>
</dd>
<dt>n</dt><dd><p>a numeric vector: the number of animals exposed to mortality.</p>
</dd>
<dt>trisk</dt><dd><p>a numeric vector: the exposition time to mortality (in year).</p>
</dd>
<dt>y</dt><dd><p>a numeric vector: the number of deaths.</p>
</dd>
</dl>



<h3>References</h3>

<p>Faugère, O., Faugère, B., 1986. <em>Suivi de troupeaux et contrôle des performances individuelles des petits
ruminants en milieu traditionnel africain. Aspects méthodologiques.</em> Rev. Elev. Méd. vét. Pays trop., 39 (1): 29-40.<br />
Faugère, O., Dockès, A.-C., Perrot, C., Faugère, B., 1990. <em>L'élevage traditionnel des petits ruminants
au Sénégal. I. Pratiques de conduite et d'exploitation des animaux chez les éleveurs de la région de Kolda.</em> Revue
Elev. Méd. vét. Pays trop. 43: 249-259.<br />
Faugère, O., Tillard, E., Faugère, B., 1992. <em>Prophylaxie chez les petits ruminants au Sénégal : régionalisation
d'une politique nationale de protection sanitaire</em>. In: B. Rey, S. H. B. Lebbie, L. Reynolds (Ed.), First biennial
conference of the African Small Ruminant Research Network, ILCA, 1990, ILRAD, Nairobi, pp. 307-314.<br />
Lancelot, R., Faye, B., Juanès, X., Ndiaye, M., Pérochon, L., Tillard, E., 1998. <em>La base de données BAOBAB:
un outil pour modéliser la production et la santé des petits ruminants dans les systèmes d'élevage traditionnels
au Sénégal.</em> Revue Elev. Méd. vét. Pays trop., 51 (2): 135-146.<br />
</p>

<hr>
<h2 id='donner'>Test of Proportion Homogeneity using Donner's Adjustment</h2><span id='topic+donner'></span><span id='topic+show+2Cdonner-class'></span>

<h3>Description</h3>

<p>Tests the homogeneity of proportions between <code class="reqn">I</code> groups (H0: <code class="reqn">p_1 = p_2 = ... = p_I</code> ) from clustered
binomial data <code class="reqn">(n, y)</code> using the adjusted <code class="reqn">\chi^2</code> statistic proposed by Donner (1989).</p>


<h3>Usage</h3>

<pre><code class='language-R'>donner(formula = NULL, response = NULL,
       weights = NULL, group = NULL, data, C = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="donner_+3A_formula">formula</code></td>
<td>
<p>An optional formula where the left-hand side is either a matrix of the form <code>cbind(y, n-y)</code>, where 
the modelled probability is <code>y/n</code>, or a vector of proportions to be modelled (<code>y/n</code>). In both cases, the 
right-hand side must specify a single grouping variable. When the left-hand side of the formula is a vector of 
proportions, the argument <code>weight</code> must be used to indicate the denominators of the proportions.</p>
</td></tr>
<tr><td><code id="donner_+3A_response">response</code></td>
<td>
<p>An optional argument indicating either a matrix of the form <code>cbind(y, n-y)</code>, where the modelled 
probability is <code>y/n</code>, or a vector of proportions to be modelled (<code>y/n</code>).</p>
</td></tr>
<tr><td><code id="donner_+3A_weights">weights</code></td>
<td>
<p>An optional argument used when the left-hand side of <code>formula</code> or <code>response</code> is a vector 
of proportions: <code>weight</code> is the denominator of the proportion.</p>
</td></tr>
<tr><td><code id="donner_+3A_group">group</code></td>
<td>
<p>An optional argument only used when <code>response</code> is used. In this case, this argument is a factor 
indicating a grouping variable.</p>
</td></tr>
<tr><td><code id="donner_+3A_data">data</code></td>
<td>
<p>A data frame containing the response (<code>n</code> and <code>y</code>) and the grouping variable.</p>
</td></tr>
<tr><td><code id="donner_+3A_c">C</code></td>
<td>
<p>If not NULL, a numerical vector of <code class="reqn">I</code> cluster correction factors.</p>
</td></tr></table>


<h3>Details</h3>

<p>The <code class="reqn">\chi^2</code> statistic is adjusted with the correction factor <code class="reqn">C_i</code>
computed in each group <code class="reqn">i</code>. The test statistic is given by:
</p>
<p style="text-align: center;"><code class="reqn">X^2 = \sum_{i}\frac{(y_i - n_i * p)^2}{C_i * n_i * p * (1 - p)}</code>
</p>

<p>where <code class="reqn">C_i = 1 + (nA_i - 1) * \rho</code>, <code class="reqn">nA_i</code> is a scalar depending on the cluster sizes,
and <code class="reqn">rho</code> is the ANOVA estimate of the intra-cluster correlation, assumed common
across groups (see Donner, 1989 or Donner et al., 1994). The statistic is compared to a <code class="reqn">\chi^2</code>
distribution with <code class="reqn">I - 1</code> degrees of freedom. Fixed correction factors can be specified
with the argument <code>C</code>.
</p>


<h3>Value</h3>

<p>An object of formal class &ldquo;drs&rdquo;: see <code><a href="#topic+drs-class">drs-class</a></code> for details. The slot <code>tab</code>
provides the proportion of successes and the correction factor for each group.
</p>


<h3>Author(s)</h3>

<p>Matthieu Lesnoff <a href="mailto:matthieu.lesnoff@cirad.fr">matthieu.lesnoff@cirad.fr</a>, Renaud Lancelot <a href="mailto:renaud.lancelot@cirad.fr">renaud.lancelot@cirad.fr</a></p>


<h3>References</h3>

<p>Donner, A., 1989. <em>Statistical methods in ophthalmology: an adjusted chi-squared approach</em>. Biometrics 45, 605-611.<br />
Donner, A., 1993. <em>The comparison of proportions in the presence of litter effects</em>. Prev. Vet. Med. 18, 17-26.<br />
Donner, A., Eliasziw, M., Klar, N., 1994. <em>A comparison of methods for testing homogeneity of proportions in 
teratologic studies</em>. Stat. Med. 13, 1253-1264.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+chisq.test">chisq.test</a></code>, <code><a href="#topic+raoscott">raoscott</a></code>, <code><a href="#topic+drs-class">drs-class</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(rats)
  donner(formula = cbind(y, n - y) ~ group, data = rats)
  donner(formula = y/n ~ group, weights = n, data = rats)
  donner(response = cbind(y, n - y), group = group, data = rats)
  donner(response = y/n, weights = n, group = group, data = rats)
  # standard test
  donner(cbind(y, n - y) ~ group, data = rats, C = c(1, 1))
  data(antibio)
  donner(cbind(y, n - y) ~ treatment, data = antibio)
  </code></pre>

<hr>
<h2 id='drs-class'>Representation of Objects of Formal Class &quot;drs&quot;</h2><span id='topic+drs-class'></span><span id='topic+show+2Cdrs-method'></span>

<h3>Description</h3>

<p>Representation of the output of functions <code>donner</code> and <code>raoscott</code>.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("drs", ...)</code> or, more commonly, 
via the <code>donner</code> or <code>raoscott</code> functions.</p>


<h3>Slots</h3>



<dl>
<dt><code>CALL</code></dt><dd><p>The call of the function.</p>
</dd>
<dt><code>tab</code></dt><dd><p>A data frame containing test information. The content of the data frame depends on the type 
of the function which generated it.</p>
</dd>
<dt><code>rho</code></dt><dd><p>The ANOVA estimate of the intra-cluster correlation (function <code>donner</code>).</p>
</dd>
<dt><code>X2</code></dt><dd><p>The adjusted <code class="reqn">\chi^2</code> statistic.</p>
</dd>
</dl>



<h3>Methods</h3>



<dl>
<dt>donner</dt><dd><p><code>signature(object = "drs")</code>: see <code><a href="#topic+donner">donner</a></code>.</p>
</dd>
<dt>raoscott</dt><dd><p><code>signature(object = "drs")</code>: see <code><a href="#topic+raoscott">raoscott</a></code>.</p>
</dd>
</dl>


<hr>
<h2 id='fitted-methods'>Methods for Function &quot;fitted&quot; in Package &quot;aod&quot;</h2><span id='topic+fitted+2CglimML-method'></span><span id='topic+fitted+2CglimQL-method'></span>

<h3>Description</h3>

<p>Extracts the fitted values from models.</p>


<h3>Methods</h3>


<dl>
<dt>ANY</dt><dd><p>Generic function: see <code><a href="stats.html#topic+fitted">fitted</a></code>.</p>
</dd>
<dt>glimML</dt><dd><p>Extract the fitted values from models of formal class &ldquo;glimML&rdquo;, presently generated 
by functions <code>betabin</code> and <code>negbin</code>.</p>
</dd> 
<dt>glimQL</dt><dd><p>Extract the fitted values from models of formal class &ldquo;glimQL&rdquo;, presently generated 
by functions <code>quasibin</code> and <code>quasibin</code>.</p>
</dd> 
</dl>

<hr>
<h2 id='glimML-class'>Representation of Models of Formal Class &quot;glimML&quot;</h2><span id='topic+glimML-class'></span><span id='topic+show+2CglimML-method'></span>

<h3>Description</h3>

<p>Representation of models of formal class &quot;glimML&quot; fitted by maximum-likelihood method.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("glimML", ...)</code> or, 
more commonly, via the functions <code>betabin</code> or <code>negbin</code>.</p>


<h3>Slots</h3>


<dl>
<dt><code>CALL</code></dt><dd><p>The call of the function.</p>
</dd>
<dt><code>link</code></dt><dd><p>The link function used to transform the mean: &ldquo;logit&rdquo;, &ldquo;cloglog&rdquo; or &ldquo;log&rdquo;.</p>
</dd>
<dt><code>method</code></dt><dd><p>The type of fitted model: &ldquo;BB&rdquo; for beta-binomial and &ldquo;NB&rdquo; for negative-binomial models.</p>
</dd>
<dt><code>formula</code></dt><dd><p>The formula used to model the mean.</p>
</dd>
<dt><code>random</code></dt><dd><p>The formula used to model the overdispersion parameter <code class="reqn">\phi</code>.</p>
</dd>
<dt><code>data</code></dt><dd><p>Data set to which model was fitted. Different from the original data in case of missing value(s).</p>
</dd>
<dt><code>param</code></dt><dd><p>The vector of the ML estimated parameters <code class="reqn">b</code> and <code class="reqn">\phi</code>.</p>
</dd>
<dt><code>varparam</code></dt><dd><p>The variance-covariance matrix of the ML estimated parameters <code class="reqn">b</code> and <code class="reqn">\phi</code>.</p>
</dd>
<dt><code>fixed.param</code></dt><dd><p>The vector of the ML estimated fixed-effect parameters <code class="reqn">b</code>.</p>
</dd>
<dt><code>random.param</code></dt><dd><p>The vector of the ML estimated random-effect (correlation) parameters <code class="reqn">\phi</code>.</p>
</dd>
<dt><code>logL</code></dt><dd><p>The log-likelihood of the fitted model.</p>
</dd>
<dt><code>logL.max</code></dt><dd><p>The log-likelihood of the maximal model (data).</p>
</dd>
<dt><code>dev</code></dt><dd><p>The deviance of the model, i.e., <code>- 2 * (logL - logL.max)</code>.</p>
</dd>
<dt><code>df.residual</code></dt><dd><p>The residual degrees of freedom of the fitted model.</p>
</dd>
<dt><code>nbpar</code></dt><dd><p>The number of <b>estimated</b> parameters, i.e., nbpar = total number of parameters - number 
of fixed parameters. See argument <code>fixpar</code> in <code><a href="#topic+betabin">betabin</a></code> or <code><a href="#topic+negbin">negbin</a></code>.</p>
</dd>
<dt><code>iterations</code></dt><dd><p>The number of iterations performed in <code>optim</code>.</p>
</dd>
<dt><code>code</code></dt><dd><p>An integer (returned by <code>optim</code>) indicating why the optimization process terminated.
</p>

<dl>
<dt>1</dt><dd><p>Relative gradient is close to 0, current iterate is probably solution.</p>
</dd>
<dt>2</dt><dd><p>Successive iterates within tolerance, current iterate is probably solution.</p>
</dd>
<dt>3</dt><dd><p>Last global step failed to locate a point lower than estimate. Either estimate is an approximate 
local minimum of the function or <code>steptol</code> is too small.</p>
</dd>
<dt>4</dt><dd><p>Iteration limit exceeded.</p>
</dd>
<dt>5</dt><dd><p>Maximum step size <code>stepmax</code> exceeded 5 consecutive times. Either the function is unbounded below, 
becomes asymptotic to a finite value from above in some direction or <code>stepmax</code> is too small.</p>
</dd>
</dl>

</dd>
<dt><code>msg</code></dt><dd><p>Message returned by <code>optim</code>.</p>
</dd>
<dt><code>singular.hessian</code></dt><dd><p>Logical: true when fitting provided a singular hessian, indicating an overparamaterized model.</p>
</dd>
<dt><code>param.ini</code></dt><dd><p>The initial values provided to the ML algorithm.</p>
</dd>
<dt><code>na.action</code></dt><dd><p>A function defining the action taken when missing values are encountered.</p>
</dd>
</dl>


<hr>
<h2 id='glimQL-class'>Representation of Models of Formal Class &quot;glimQL&quot;</h2><span id='topic+glimQL-class'></span><span id='topic+show+2CglimQL-method'></span>

<h3>Description</h3>

<p>Representation of models of formal class &quot;glimQL&quot; fitted by quasi-likelihood method.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("glimQL", ...)</code> or, 
more commonly, via the <code>quasibin</code> or <code>quasipois</code> functions.</p>


<h3>Slots</h3>


<dl>
<dt><code>CALL</code></dt><dd><p>The call of the function.</p>
</dd>
<dt><code>fm</code></dt><dd><p>A fitted model of class &ldquo;glm&rdquo;.</p>
</dd>
<dt><code>phi</code></dt><dd><p>The overdispersion parameter.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "glimQL")</code>: Main results of &ldquo;glimQL&rdquo; models.</p>
</dd>
</dl>


<hr>
<h2 id='iccbin'>Intra-Cluster Correlation for Binomial Data</h2><span id='topic+iccbin'></span><span id='topic+show+2Ciccbin-method'></span>

<h3>Description</h3>

<p>This function calculates point estimates of the intraclass correlation <code class="reqn">\rho</code>
from clustered binomial data <code class="reqn">{(n_1, y_1), (n_2, y_2), ..., (n_K, y_K)}</code> (with <code class="reqn">K</code> the number of clusters),
using a 1-way random effect model. Three estimates, following methods referred to as &ldquo;A&rdquo;, &ldquo;B&rdquo; and &ldquo;C&rdquo;
in Goldstein et al. (2002), can be obtained.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iccbin(n, y, data, method = c("A", "B", "C"), nAGQ = 1, M = 1000)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iccbin_+3A_n">n</code></td>
<td>
<p>Vector of the denominators of the proportions.</p>
</td></tr>
<tr><td><code id="iccbin_+3A_y">y</code></td>
<td>
<p>Vector of the numerators of the proportions.</p>
</td></tr>
<tr><td><code id="iccbin_+3A_data">data</code></td>
<td>
<p>A data frame containing the variables n and y.</p>
</td></tr>
<tr><td><code id="iccbin_+3A_method">method</code></td>
<td>
<p>A character (&ldquo;A&rdquo;, &ldquo;B&rdquo; or &ldquo;C&rdquo;) defining the calculation method. See Details.</p>
</td></tr>
<tr><td><code id="iccbin_+3A_nagq">nAGQ</code></td>
<td>
<p>Same as in function <code>glmer</code> of package
<span class="pkg">lme4</span>. Only for methods &ldquo;A&rdquo; and &ldquo;B&rdquo;. Default to 1.</p>
</td></tr>
<tr><td><code id="iccbin_+3A_m">M</code></td>
<td>
<p>Number of Monte Carlo (MC) replicates used in method &ldquo;B&rdquo;. Default to 1000.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Before computations, the clustered data are split into binary (0/1) observations <code class="reqn">y_{ij}</code> (obs. <code class="reqn">j</code> in cluster
<code class="reqn">i</code>).
The calculation methods are described in Goldstein et al. (2002).
Methods &quot;A&quot; and &quot;B&quot; assume a 1-way generalized linear mixed model,
and method &quot;C&quot; a 1-way linear mixed model.<br />
For &quot;A&quot; and &quot;B&quot;, function <code>iccbin</code> uses the logistic binomial-Gaussian model:
</p>
<p style="text-align: center;"><code class="reqn">y_{ij} | p_{ij} \sim Bernoulli(p_{ij}),</code>
</p>

<p style="text-align: center;"><code class="reqn">logit(p_{ij}) = b_0 + u_i,</code>
</p>

<p>where <code class="reqn">b_0</code> is a constant and <code class="reqn">u_i</code> a cluster random effect with <code class="reqn">u_i \sim N(0, s^2_u)</code>.
The ML estimate of the variance component <code class="reqn">s^2_u</code> is calculated with the function <code>glmer</code> of package <span class="pkg">lme4</span>.
The intra-class correlation <code class="reqn">\rho = Corr[y_{ij}, y_{ij'}]</code> is then calculated with a first-order model linearization
around <code class="reqn">E[u_i]=0</code> in method &ldquo;A&rdquo;, and with Monte Carlo simulations in method &ldquo;B&rdquo;.<br />
For &ldquo;C&rdquo;, function <code>iccbin</code> provides the common ANOVA (moments) estimate of <code class="reqn">\rho</code>.
For details, see for instance Donner (1986), Searle et al. (1992) or Ukoumunne (2002).
</p>


<h3>Value</h3>

<p>An object of formal class &ldquo;iccbin&rdquo;, with 3 slots:
</p>
<table>
<tr><td><code>CALL</code></td>
<td>
<p>The call of the function.</p>
</td></tr>
<tr><td><code>features</code></td>
<td>
<p>A character vector summarizing the main features of the method used.</p>
</td></tr>
<tr><td><code>rho</code></td>
<td>
<p>The point estimate of the intraclass correlation <code class="reqn">\rho</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matthieu Lesnoff <a href="mailto:matthieu.lesnoff@cirad.fr">matthieu.lesnoff@cirad.fr</a>, Renaud Lancelot <a href="mailto:renaud.lancelot@cirad.fr">renaud.lancelot@cirad.fr</a></p>


<h3>References</h3>

<p>Donner A., 1986, <em>A review of inference procedures for the intraclass correlation coefficient in the one-way random
effects model</em>. International Statistical Review 54, 67-82.<br />
Searle, S.R., Casella, G., McCulloch, C.E., 1992. <em>Variance components</em>. Wiley, New York.<br />
Ukoumunne, O. C., 2002. <em>A comparison of confidence interval methods for the intraclass
correlation coefficient in cluster randomized trials</em>. Statistics in Medicine 21, 3757-3774.<br />
Golstein, H., Browne, H., Rasbash, J., 2002. <em>Partitioning variation in multilevel models</em>.
Understanding Statistics 1(4), 223-231.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+iccbin-class">iccbin-class</a></code>, <code><a href="lme4.html#topic+glmer">glmer</a></code><br /></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(rats)
tmp &lt;- rats[rats$group == "TREAT", ]
# A: glmm (model linearization)
iccbin(n, y, data = tmp, method = "A")
iccbin(n, y, data = tmp, method = "A", nAGQ = 10)
# B: glmm (Monte Carlo)
iccbin(n, y, data = tmp, method = "B")
iccbin(n, y, data = tmp, method = "B", nAGQ = 10, M = 1500)
# C: lmm (ANOVA moments)
iccbin(n, y, data = tmp, method = "C")

  ## Not run: 
  # Example of confidence interval calculation with nonparametric bootstrap
  require(boot)
  foo &lt;- function(X, ind) {
    n &lt;- X$n[ind]
    y &lt;- X$y[ind]
    X &lt;- data.frame(n = n, y = y)
    iccbin(n = n, y = y, data = X, method = "C")@rho[1]
    }
  res &lt;- boot(data = tmp[, c("n", "y")], statistic = foo, R = 500, sim = "ordinary", stype = "i")
  res
  boot.ci(res, conf = 0.95, type = "basic")
  
## End(Not run)

</code></pre>

<hr>
<h2 id='iccbin-class'>Representation of Objects of Formal Class &quot;iccbin&quot;</h2><span id='topic+iccbin-class'></span>

<h3>Description</h3>

<p>Representation of the output of function <code>iccbin</code>.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("iccbin", ...)</code> or, more commonly,
via the function <code>iccbin</code>.</p>


<h3>Slots</h3>


<dl>
<dt><code>CALL</code></dt><dd><p>The call of the function.</p>
</dd>
<dt><code>features</code></dt><dd><p>A character vector summarizing the main features of the method used.</p>
</dd>
<dt><code>rho</code></dt><dd><p>A numeric scalar giving the intra-cluster correlation.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>icc</dt><dd><p><code>signature(object = "iccbin")</code>: see <code><a href="#topic+iccbin">iccbin</a></code>.</p>
</dd>
</dl>


<hr>
<h2 id='invlink'>Transformation from the Link Scale to the Observation Scale</h2><span id='topic+invlink'></span>

<h3>Description</h3>

<p>The function transforms a variable from the link scale to the observation scale: probability or count.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  invlink(x, type = c("cloglog", "log", "logit"))
  </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invlink_+3A_x">x</code></td>
<td>
<p>A vector of real numbers.</p>
</td></tr>
<tr><td><code id="invlink_+3A_type">type</code></td>
<td>
<p>A character string. Legal values are &ldquo;cloglog&rdquo;, &ldquo;log&rdquo; and &ldquo;logit&rdquo;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code class="reqn">anti-logit(x) = exp(x) / (1 + exp(x))</code><br />
<code class="reqn">anti-cloglog(x) = 1 - exp(-exp(x))</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+link">link</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- seq(-5, 5, length = 100)
  plot(x, invlink(x, type = "logit"),
       type = "l", lwd = 2, ylab = "Probability")
  lines(x, invlink(x, type = "cloglog"), lty = 2, lwd = 2)
  grid(col = "black")
  legend(-5, 1, legend = c("alogit(x)", "acloglog(x)"),
         lty = c(1, 2), bg = "white")
  </code></pre>

<hr>
<h2 id='link'>Transformation from the Observation Scale to the Link Scale</h2><span id='topic+link'></span>

<h3>Description</h3>

<p>The function transforms a variable from the observation scale (probability or count) to the link scale.</p>


<h3>Usage</h3>

<pre><code class='language-R'>link(x, type = c("cloglog", "log", "logit"))</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="link_+3A_x">x</code></td>
<td>
<p>A vector of real numbers.</p>
</td></tr>
<tr><td><code id="link_+3A_type">type</code></td>
<td>
<p>A character string. Legal values are &ldquo;cloglog&rdquo;, &ldquo;log&rdquo; and &ldquo;logit&rdquo;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code class="reqn">logit(x) = log(x / (1 - x))</code><br />
<code class="reqn">cloglog(x) = log(-log(1 - x ))</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+invlink">invlink</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- seq(.001, .999, length = 100)
  plot(x, link(x, type = "logit"),
       type = "l", lwd = 2, ylab = "link(proba.)")
  lines(x, link(x, type = "cloglog"), lty = 2, lwd = 2)
  grid(col = "black")
  legend(0, 6, legend = c("logit(x)", "cloglog(x)"),
         lty = c(1, 2), bg = "white")
  </code></pre>

<hr>
<h2 id='lizards'>A Comparison of Site Preferences of Two Species of Lizard</h2><span id='topic+lizards'></span>

<h3>Description</h3>

<p>&ldquo;These data describe the daytime habits of two species of lizards, <em>grahami</em> and <em>opalinus</em>. 
They were collected by observing occupied sites or perches and recording the appropriate description, namely 
species involved, time of the day, height and diameter of the perch and whether the site was sunny or shaded. 
Time of the day is recorded as early, mid-day or late.&rdquo; (McCullagh and Nelder, 1989, p.129).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(lizards)</code></pre>


<h3>Format</h3>

<p>A data frame with 24 observations on the following 6 variables.
</p>

<dl>
<dt>Site</dt><dd><p>A factor with levels <code>Sun</code> and <code>Shade</code>.</p>
</dd>
<dt>Diameter</dt><dd><p>A factor with levels <code>D &lt;= 2</code> and <code>D &gt; 2</code> (inches). </p>
</dd>
<dt>Height</dt><dd><p>A factor with levels <code>H &lt; 5</code> and <code>H &gt;= 5</code> (feet).</p>
</dd>
<dt>Time</dt><dd><p>A factor with levels <code>Early</code>, <code>Mid-day</code> and <code>Late</code>.</p>
</dd>
<dt>grahami</dt><dd><p>A numeric vector giving the observed sample size for <em>grahami</em> lizards.</p>
</dd>
<dt>opalinus</dt><dd><p>A numeric vector giving the observed sample size for <em>opalinus</em> lizards.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data were originally published in Fienberg (1970).</p>


<h3>Source</h3>

<p>McCullagh, P., Nelder, J.A., 1989. <em>Generalized linear models</em>. London, Chapman &amp; Hall, 511 p.</p>


<h3>References</h3>

<p>Fienberg, S.E., 1970. <em>The analysis of multidimensional contingency tables</em>. Ecology 51: 419-433.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lizards)</code></pre>

<hr>
<h2 id='logLik-methods'>Methods for Functions &quot;logLik&quot; in Package &quot;aod&quot;</h2><span id='topic+logLik+2CglimML-method'></span>

<h3>Description</h3>

<p>Extracts the maximized log-likelihood from fitted models of formal class &ldquo;glimML&rdquo;.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'glimML'
logLik(object, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik-methods_+3A_object">object</code></td>
<td>
<p>A fitted model of formal class &ldquo;glimML&rdquo; (functions <code>betabin</code> or <code>negbin</code>).</p>
</td></tr>
<tr><td><code id="logLik-methods_+3A_...">...</code></td>
<td>
<p>Other arguments passed to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric scalar with 2 attributes: &ldquo;df&rdquo; (number of parameters in the model) and &ldquo;nobs&rdquo;
(number of observations = degrees of freedom of the residuals + number of parameters in the model).
</p>


<h3>Methods</h3>


<dl>
<dt>ANY</dt><dd><p>Generic function: see <code><a href="stats.html#topic+logLik">logLik</a></code>.</p>
</dd>
<dt>glimML</dt><dd><p>Extract the maximized log-likelihood from models of formal class &ldquo;glimML&rdquo;, fitted by functions 
<code>betabin</code> and <code>negbin</code>.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+logLik">logLik</a></code> in package <span class="pkg">stats</span>.</p>

<hr>
<h2 id='mice'> Pregnant Female Mice Experiment </h2><span id='topic+mice'></span>

<h3>Description</h3>

<p>Unpublished laboratory data on the proportion of affected foetuses in two groups (control and treatment) of 10 
pregnant female mice (Kupper and Haseman, 1978, p. 75).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mice)</code></pre>


<h3>Format</h3>

<p>A data frame with 20 observations on the following 3 variables.
</p>

<dl>
<dt>group</dt><dd><p>a factor with levels <code>CTRL</code> and <code>TREAT</code></p>
</dd>
<dt>n</dt><dd><p>a numeric vector: the total number of foetuses.</p>
</dd>
<dt>y</dt><dd><p>a numeric vector: the number of affected foetuses.</p>
</dd>
</dl>



<h3>References</h3>

<p>Kupper, L.L., Haseman, J.K., 1978. <em>The use of a correlated binomial model for the analysis of a certain 
toxicological experiments.</em> Biometrics 34, 69-76.
</p>

<hr>
<h2 id='negbin'>Negative-Binomial Model for Counts</h2><span id='topic+negbin'></span>

<h3>Description</h3>

<p>The function fits a negative-binomial log linear model accounting for overdispersion in counts <code class="reqn">y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  negbin(formula, random, data, phi.ini = NULL, warnings = FALSE, 
         na.action = na.omit, fixpar = list(),
         hessian = TRUE, control = list(maxit = 2000), ...)
  </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="negbin_+3A_formula">formula</code></td>
<td>
<p>A formula for the fixed effects. The left-hand side of the formula must be the counts <code>y</code> i.e., 
positive integers (<code>y &gt;= 0</code>). The right-hand side can involve an offset term.</p>
</td></tr>
<tr><td><code id="negbin_+3A_random">random</code></td>
<td>
<p>A right-hand formula for the overdispersion parameter(s) <code class="reqn">\phi</code>.</p>
</td></tr>
<tr><td><code id="negbin_+3A_data">data</code></td>
<td>
<p>A data frame containing the response (<code>y</code>) and explanatory variable(s).</p>
</td></tr>
<tr><td><code id="negbin_+3A_phi.ini">phi.ini</code></td>
<td>
<p>Initial values for the overdispersion parameter(s) <code class="reqn">\phi</code>. Default to 0.1.</p>
</td></tr>
<tr><td><code id="negbin_+3A_warnings">warnings</code></td>
<td>
<p>Logical to control printing of warnings occurring during log-likelihood maximization. Default to 
FALSE (no printing).</p>
</td></tr>
<tr><td><code id="negbin_+3A_na.action">na.action</code></td>
<td>
<p>A function name. Indicates which action should be taken in the case of missing value(s).</p>
</td></tr>
<tr><td><code id="negbin_+3A_fixpar">fixpar</code></td>
<td>
<p>A list with 2 components (scalars or vectors) of the same size, indicating which parameters are 
fixed (i.e., not optimized) in the global parameter vector <code class="reqn">(b, \phi)</code> and the corresponding fixed values.<br />
For example, <code>fixpar = list(c(4, 5), c(0, 0))</code> means that 4th and 5th parameters of the model are set to 0.</p>
</td></tr>
<tr><td><code id="negbin_+3A_hessian">hessian</code></td>
<td>
<p>A logical. When set to <code>FALSE</code>, the hessian and the variances-covariances matrices of the 
parameters are not computed.</p>
</td></tr>
<tr><td><code id="negbin_+3A_control">control</code></td>
<td>
<p>A list to control the optimization parameters. See <code><a href="stats.html#topic+optim">optim</a></code>. By default, set the maximum number of iterations to 2000.</p>
</td></tr>
<tr><td><code id="negbin_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a given count <code class="reqn">y</code>, the model is:
</p>
<p style="text-align: center;"><code class="reqn">y~|~\lambda \sim Poisson(~\lambda)</code>
</p>

<p>with <code class="reqn">\lambda</code> following a Gamma distribution <code class="reqn">Gamma(r,~\theta)</code>.<br />
If <code class="reqn">G</code> denote the gamma function, then:
</p>
<p style="text-align: center;"><code class="reqn">P(\lambda) = r^{-\theta} * \lambda^{\theta - 1} * \frac{exp(-\frac{\lambda}{r})}{G(\theta)}</code>
</p>

<p style="text-align: center;"><code class="reqn">E[\lambda] = \theta * r</code>
</p>

<p style="text-align: center;"><code class="reqn">Var[\lambda] = \theta * r^2</code>
</p>

<p>The marginal negative-binomial distribution is:
</p>
<p style="text-align: center;"><code class="reqn">P(y) = G(y + \theta) * \left(\frac{1}{1 + r}\right)^\theta * \frac{(\frac{r}{1 + r})^y}{y! * G(\theta)} </code>
</p>

<p>The function uses the parameterization <code class="reqn">\mu = \theta * r = exp(X b) = exp(\eta)</code> and <code class="reqn">\phi = 1 / \theta</code>, 
where <code class="reqn">X</code> is a design-matrix, <code class="reqn">b</code> is a vector of fixed effects, <code class="reqn">\eta = X b</code> is the linear predictor and 
<code class="reqn">\phi</code> the overdispersion parameter.<br />
The marginal mean and variance are:
</p>
<p style="text-align: center;"><code class="reqn">E[y] = \mu</code>
</p>

<p style="text-align: center;"><code class="reqn">Var[y] = \mu + \phi * \mu^2</code>
</p>

<p>The parameters <code class="reqn">b</code> and <code class="reqn">\phi</code> are estimated by maximizing the log-likelihood of the marginal model (using the 
function <code>optim()</code>). Several explanatory variables are allowed in <code class="reqn">b</code>. Only one is allowed in <code class="reqn">\phi</code>.<br />
An offset can be specified in the <code>formula</code> argument to model rates <code class="reqn">y/T</code>. The offset and the marginal mean
are <code class="reqn">log(T)</code> and <code class="reqn">\mu = exp(log(T) + \eta)</code>, respectively.
</p>


<h3>Value</h3>

<p>An object of formal class &ldquo;glimML&rdquo;: see <code><a href="#topic+glimML-class">glimML-class</a></code> for details.
</p>


<h3>Author(s)</h3>

<p>Matthieu Lesnoff <a href="mailto:matthieu.lesnoff@cirad.fr">matthieu.lesnoff@cirad.fr</a>, Renaud Lancelot <a href="mailto:renaud.lancelot@cirad.fr">renaud.lancelot@cirad.fr</a>
</p>


<h3>References</h3>

<p>Lawless, J.F., 1987. <em>Negative binomial and mixed Poisson regression</em>.
The Canadian Journal of Statistics, 15(3): 209-225.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+glimML-class">glimML-class</a></code>, <code><a href="stats.html#topic+glm">glm</a></code> and <code><a href="stats.html#topic+optim">optim</a></code>,<br />
<code><a href="MASS.html#topic+glm.nb">glm.nb</a></code> in the recommended package <span class="pkg">MASS</span>,<br />
<code>gnlr</code> in package <span class="pkg">gnlm</span> available at <a href="https://www.commanster.eu/rcode.html">https://www.commanster.eu/rcode.html</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # without offset
  data(salmonella)
  negbin(y ~ log(dose + 10) + dose, ~ 1, salmonella)
  library(MASS) # function glm.nb in MASS
  fm.nb &lt;- glm.nb(y ~ log(dose + 10) + dose,
                  link = log, data = salmonella)
  coef(fm.nb)
  1 / fm.nb$theta # theta = 1 / phi
  c(logLik(fm.nb), AIC(fm.nb))
  # with offset
  data(dja)
  negbin(y ~ group + offset(log(trisk)), ~ group, dja)
  # phi fixed to zero in group TREAT
  negbin(y ~ group + offset(log(trisk)), ~ group, dja,
    fixpar = list(4, 0))
  # glim without overdispersion
  summary(glm(y ~ group + offset(log(trisk)),
    family = poisson, data = dja))
  # phi fixed to zero in both groups
  negbin(y ~ group + offset(log(trisk)), ~ group, dja,
    fixpar = list(c(3, 4), c(0, 0))) 
  </code></pre>

<hr>
<h2 id='orob1'> Germination Data </h2><span id='topic+orob1'></span>

<h3>Description</h3>

<p>[Data describing the germination] &ldquo;for seed <em>Orobanche cernua</em> cultivated in three dilutions of a bean 
root extract. The mean proportions of the three sets are 0.142, 0.872 and 0.842, and the overall mean is 0.614.&rdquo;
(Crowder, 1978, Table 1). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(orob1)</code></pre>


<h3>Format</h3>

<p>A data frame with 16 observations on the following 3 variables.
</p>

<dl>
<dt>dilution</dt><dd><p>a factor with 3 levels: <code>1/1</code>, <code>1/25</code> and <code>1/625</code></p>
</dd></dl>
<p>.
</p>
<dl>
<dt>n</dt><dd><p>a numeric vector: the number of seeds exposed to germination.</p>
</dd>
<dt>y</dt><dd><p>a numeric vector: the number of seeds which actually germinated.</p>
</dd>
</dl>



<h3>References</h3>

<p>Crowder, M.J., 1978. <em>Beta-binomial anova for proportions</em>. Appl. Statist. 27, 34-37.
</p>

<hr>
<h2 id='orob2'> Germination Data </h2><span id='topic+orob2'></span>

<h3>Description</h3>

<p>&ldquo;A 2 x 2 factorial experiment comparing 2 types of seed and 2 root extracts. There are 5 or 6 replicates in each 
of the 4 treatment groups, and each replicate comprises a number of seeds varying between 4 and 81. The response 
variable is the proportion of seeds germinating in each replicate.&rdquo; (Crowder, 1978, Table 3).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(orob2)</code></pre>


<h3>Format</h3>

<p>A data frame with 21 observations on the following 4 variables.
</p>

<dl>
<dt>seed</dt><dd><p>a factor with 2 levels: <code>O73</code> and <code>O75</code>.</p>
</dd>
<dt>root</dt><dd><p>a factor with 2 levels <code>BEAN</code> and <code>CUCUMBER</code>.</p>
</dd>
<dt>n</dt><dd><p>a numeric vector: the number of seeds exposed to germination.</p>
</dd>
<dt>y</dt><dd><p>a numeric vector: the number of seeds which actually germinated.</p>
</dd>
</dl>



<h3>References</h3>

<p>Crowder, M.J., 1978. <em>Beta-binomial anova for proportions</em>. Appl. Statist. 27, 34-37.
</p>

<hr>
<h2 id='predict-methods'>Methods for Function &quot;predict&quot; in Package &quot;aod&quot;</h2><span id='topic+predict-methods'></span><span id='topic+predict+2CglimML-method'></span><span id='topic+predict+2CglimQL-method'></span>

<h3>Description</h3>

<p>&ldquo;predict&rdquo; methods for fitted models generated by functions in package <span class="pkg">aod</span>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S4 method for signature 'glimML'
predict(object, newdata = NULL, 
    type = c("response", "link"), se.fit = FALSE, ...)
  ## S4 method for signature 'glimQL'
predict(object, newdata = NULL, 
    type = c("response", "link"), se.fit = FALSE, ...)
  </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict-methods_+3A_object">object</code></td>
<td>
<p>A fitted model of formal class &ldquo;glimML&rdquo; (functions <code>betabin</code> or <code>negbin</code>) or 
&ldquo;glimQL&rdquo; (functions <code>quasibin</code> or <code>quasipois</code>).</p>
</td></tr>
<tr><td><code id="predict-methods_+3A_newdata">newdata</code></td>
<td>
<p>A data.frame providing all the explanatory variables necessary for predictions.</p>
</td></tr>
<tr><td><code id="predict-methods_+3A_type">type</code></td>
<td>
<p>A character string indicating the scale on which predictions are made: either &ldquo;response&rdquo; for 
predictions on the observation scale, or &ldquo;link&rdquo; for predictions on the scale of the link.</p>
</td></tr>
<tr><td><code id="predict-methods_+3A_se.fit">se.fit</code></td>
<td>
<p>A logical scalar indicating whether pointwise standard errors should be computed for the predictions.</p>
</td></tr>
<tr><td><code id="predict-methods_+3A_...">...</code></td>
<td>
<p>Other arguments passed to methods.</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>glimML</dt><dd><p>Compute predictions for models of formal class &ldquo;glimML&rdquo;, presently generated 
by functions <code><a href="#topic+betabin">betabin</a></code> and <code><a href="#topic+negbin">negbin</a></code>. See the examples for these functions.</p>
</dd> 
<dt>glimQL</dt><dd><p>Compute predictions for models of formal class &ldquo;glimQL&rdquo;, presently generated by the
functions <code><a href="#topic+quasibin">quasibin</a></code> and <code><a href="#topic+quasibin">quasibin</a></code>. See the examples for these functions.</p>
</dd> 
</dl>



<h3>See Also</h3>

<p><code><a href="stats.html#topic+predict.glm">predict.glm</a></code></p>

<hr>
<h2 id='quasibin'>Quasi-Likelihood Model for Proportions</h2><span id='topic+quasibin'></span>

<h3>Description</h3>

<p>The function fits the generalized linear model &ldquo;II&rdquo; proposed by Williams (1982) accounting 
for overdispersion in clustered binomial data <code class="reqn">(n, y)</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>quasibin(formula, data, link = c("logit", "cloglog"), phi = NULL, tol =  0.001)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quasibin_+3A_formula">formula</code></td>
<td>
<p>A formula for the fixed effects. The left-hand side of the formula must be of the form 
<code>cbind(y, n - y)</code> where the modelled probability is <code>y/n</code>.</p>
</td></tr>
<tr><td><code id="quasibin_+3A_link">link</code></td>
<td>
<p>The link function for the mean <code class="reqn">p</code>: &ldquo;logit&rdquo; or &ldquo;cloglog&rdquo;.</p>
</td></tr>
<tr><td><code id="quasibin_+3A_data">data</code></td>
<td>
<p>A data frame containing the response (<code>n</code> and <code>y</code>) and explanatory variable(s).</p>
</td></tr>
<tr><td><code id="quasibin_+3A_phi">phi</code></td>
<td>
<p>When <code>phi</code> is NULL (the default), the overdispersion parameter <code class="reqn">\phi</code> is estimated from the data. 
Otherwise, its value is considered as fixed.</p>
</td></tr>
<tr><td><code id="quasibin_+3A_tol">tol</code></td>
<td>
<p>A positive scalar (default to 0.001). The algorithm stops at iteration <code class="reqn">r + 1</code> when the condition
<code class="reqn">\chi{^2}[r+1] - \chi{^2}[r] &lt;= tol</code> is met by the <code class="reqn">\chi^2</code> statistics .</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a given cluster <code class="reqn">(n, y)</code>, the model is:
</p>
<p style="text-align: center;"><code class="reqn">y~|~\lambda \sim Binomial(n,~\lambda)</code>
</p>

<p>with <code class="reqn">\lambda</code> a random variable of mean <code class="reqn">E[\lambda] = p</code>
and variance <code class="reqn">Var[\lambda] = \phi * p * (1 - p)</code>.<br />
The marginal mean and variance are:
</p>
<p style="text-align: center;"><code class="reqn">E[y] = p</code>
</p>

<p style="text-align: center;"><code class="reqn">Var[y] = p * (1 - p) * [1 + (n - 1) * \phi]</code>
</p>

<p>The overdispersion parameter <code class="reqn">\phi</code> corresponds to the intra-cluster correlation coefficient,
which is here restricted to be positive.<br />
The function uses the function <code>glm</code> and the parameterization: <code class="reqn">p = h(X b) = h(\eta)</code>, where <code class="reqn">h</code> is the
inverse of a given link function, <code class="reqn">X</code> is a design-matrix, <code class="reqn">b</code> is a vector of fixed effects and <code class="reqn">\eta = X b</code>
is the linear predictor. <br />
The estimate of <code class="reqn">b</code> maximizes the quasi log-likelihood of the marginal model.
The parameter <code class="reqn">\phi</code> is estimated with the moment method or can be set to a constant
(a regular <em>glim</em> is fitted when <code class="reqn">\phi</code> is set to zero). The literature recommends to estimate <code class="reqn">\phi</code>
from the saturated model. Several explanatory variables are allowed in <code class="reqn">b</code>. None is allowed in <code class="reqn">\phi</code>.
</p>


<h3>Value</h3>

<p>An object of formal class &ldquo;glimQL&rdquo;: see <code><a href="#topic+glimQL-class">glimQL-class</a></code> for details.</p>


<h3>Author(s)</h3>

<p>Matthieu Lesnoff <a href="mailto:matthieu.lesnoff@cirad.fr">matthieu.lesnoff@cirad.fr</a>, Renaud Lancelot <a href="mailto:renaud.lancelot@cirad.fr">renaud.lancelot@cirad.fr</a> </p>


<h3>References</h3>

<p>Moore, D.F., 1987, <em>Modelling the extraneous variance in the presence of extra-binomial variation</em>. 
Appl. Statist. 36, 8-14.<br />
Williams, D.A., 1982, <em>Extra-binomial variation in logistic linear models</em>. Appl. Statist. 31, 144-148.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="geepack.html#topic+geese">geese</a></code> in the contributed package <span class="pkg">geepack</span>, 
<code><a href="dispmod.html#topic+glm.binomial.disp">glm.binomial.disp</a></code> in the contributed package <span class="pkg">dispmod</span>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(orob2) 
  fm1 &lt;- glm(cbind(y, n - y) ~ seed * root,
             family = binomial, data = orob2)
  fm2 &lt;- quasibin(cbind(y, n - y) ~ seed * root,
                  data = orob2, phi = 0)
  fm3 &lt;- quasibin(cbind(y, n - y) ~ seed * root,
                  data = orob2)
  rbind(fm1 = coef(fm1), fm2 = coef(fm2), fm3 = coef(fm3))
  # show the model
  fm3
  # dispersion parameter and goodness-of-fit statistic
  c(phi = fm3@phi, 
    X2 = sum(residuals(fm3, type = "pearson")^2))
  # model predictions
  predfm1 &lt;- predict(fm1, type = "response", se = TRUE)
  predfm3 &lt;- predict(fm3, type = "response", se = TRUE)
  New &lt;- expand.grid(seed = levels(orob2$seed),
                     root = levels(orob2$root))
  predict(fm3, New, se = TRUE, type = "response")
  data.frame(orob2, p1 = predfm1$fit, 
                    se.p1 = predfm1$se.fit,
                    p3 = predfm3$fit,
                    se.p3 = predfm3$se.fit)
  fm4 &lt;- quasibin(cbind(y, n - y) ~ seed + root,
                  data = orob2, phi = fm3@phi)
  # Pearson's chi-squared goodness-of-fit statistic
  # compare with fm3's X2
  sum(residuals(fm4, type = "pearson")^2)
  </code></pre>

<hr>
<h2 id='quasipois'>Quasi-Likelihood Model for Counts</h2><span id='topic+quasipois'></span>

<h3>Description</h3>

<p>The function fits the log linear model (&ldquo;Procedure II&rdquo;) proposed by Breslow (1984) accounting for 
overdispersion in counts <code class="reqn">y</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>quasipois(formula, data, phi = NULL, tol = 0.001)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quasipois_+3A_formula">formula</code></td>
<td>
<p>A formula for the fixed effects. The left-hand side of the formula must be the counts <code>y</code> i.e.,
positive integers (<code>y &gt;= 0</code>). The right-hand side can involve an offset term.</p>
</td></tr>
<tr><td><code id="quasipois_+3A_data">data</code></td>
<td>
<p>A data frame containing the response (<code>y</code>) and explanatory variable(s).</p>
</td></tr>
<tr><td><code id="quasipois_+3A_phi">phi</code></td>
<td>
<p>When <code>phi</code> is NULL (the default), the overdispersion parameter <code class="reqn">\phi</code> is estimated from the data.
Otherwise, its value is considered as fixed.</p>
</td></tr>
<tr><td><code id="quasipois_+3A_tol">tol</code></td>
<td>
<p>A positive scalar (default to 0.001). The algorithm stops at iteration <code class="reqn">r + 1</code> when the condition
<code class="reqn">\chi{^2}[r+1] - \chi{^2}[r] &lt;= tol</code> is met by the <code class="reqn">\chi^2</code> statistics .</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a given count <code class="reqn">y</code>, the model is:
</p>
<p style="text-align: center;"><code class="reqn">y~|~\lambda \sim Poisson(~\lambda)</code>
</p>

<p>with <code class="reqn">\lambda</code> a random variable of mean <code class="reqn">E[\lambda] = \mu</code>
and variance <code class="reqn">Var[\lambda] = \phi * \mu^2</code>.<br />
The marginal mean and variance are:
</p>
<p style="text-align: center;"><code class="reqn">E[y] = \mu</code>
</p>

<p style="text-align: center;"><code class="reqn">Var[y] = \mu + \phi * \mu^2</code>
</p>

<p>The function uses the function <code>glm</code> and the parameterization: <code class="reqn">\mu = exp(X b) = exp(\eta)</code>, where <code class="reqn">X</code> 
is a design-matrix, <code class="reqn">b</code> is a vector of fixed effects and <code class="reqn">\eta = X b</code> is the linear predictor. <br />
The estimate of <code class="reqn">b</code> maximizes the quasi log-likelihood of the marginal model.
The parameter <code class="reqn">\phi</code> is estimated with the moment method or can be set to a constant
(a regular <em>glim</em> is fitted when <code class="reqn">\phi</code> is set to 0). The literature recommends to estimate <code class="reqn">\phi</code>
with the saturated model. Several explanatory variables are allowed in <code class="reqn">b</code>. None is allowed in <code class="reqn">\phi</code>.<br />
An offset can be specified in the argument <code>formula</code> to model rates <code class="reqn">y/T</code> (see examples). The offset and the
marginal mean are <code class="reqn">log(T)</code> and <code class="reqn">\mu = exp(log(T) + \eta)</code>, respectively.
</p>


<h3>Value</h3>

<p>An object of formal class &ldquo;glimQL&rdquo;: see <code><a href="#topic+glimQL-class">glimQL-class</a></code> for details.</p>


<h3>Author(s)</h3>

<p>Matthieu Lesnoff <a href="mailto:matthieu.lesnoff@cirad.fr">matthieu.lesnoff@cirad.fr</a>, Renaud Lancelot <a href="mailto:renaud.lancelot@cirad.fr">renaud.lancelot@cirad.fr</a></p>


<h3>References</h3>

<p>Breslow, N.E., 1984. <em>Extra-Poisson variation in log-linear models</em>. Appl. Statist. 33, 38-44.<br />
Moore, D.F., Tsiatis, A., 1991. <em>Robust estimation of the variance in moment methods for extra-binomial
and extra-poisson variation</em>. Biometrics 47, 383-401.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="MASS.html#topic+negative.binomial">negative.binomial</a></code> in the recommended package <span class="pkg">MASS</span>, 
<code><a href="geepack.html#topic+geese">geese</a></code> in the contributed package <span class="pkg">geepack</span>, 
<code><a href="dispmod.html#topic+glm.poisson.disp">glm.poisson.disp</a></code> in the contributed package <span class="pkg">dispmod</span>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # without offset
  data(salmonella)
  quasipois(y ~ log(dose + 10) + dose,
            data = salmonella)
  quasipois(y ~ log(dose + 10) + dose, 
            data = salmonella, phi = 0.07180449)
  summary(glm(y ~ log(dose + 10) + dose,
          family = poisson, data = salmonella))
  quasipois(y ~ log(dose + 10) + dose,
          data = salmonella, phi = 0)
  # with offset
  data(cohorts)
  i &lt;- cohorts$age ; levels(i) &lt;- 1:7
  j &lt;- cohorts$period ; levels(j) &lt;- 1:7
  i &lt;- as.numeric(i); j &lt;- as.numeric(j)
  cohorts$cohort &lt;- j + max(i) - i
  cohorts$cohort &lt;- as.factor(1850 + 5 * cohorts$cohort)
  fm1 &lt;- quasipois(y ~ age + period + cohort + offset(log(n)),
                   data = cohorts)
  fm1
  quasipois(y ~ age + cohort + offset(log(n)),
            data = cohorts, phi = fm1@phi)
  </code></pre>

<hr>
<h2 id='rabbits'> Rabbits Foetuses Survival Experiment </h2><span id='topic+rabbits'></span>

<h3>Description</h3>

<p>Experimental data for analyzing the effect of an increasing dose of a compound on the proportion of live foetuses 
affected. Four treatment-groups were considered: control &ldquo;C&rdquo;, low dose &ldquo;L&rdquo;, medium dose &ldquo;M&rdquo; 
and high dose &ldquo;H&rdquo;. The animal species used in the experiment was banded Dutch rabbit (Paul, 1982, Table 1).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(rabbits)</code></pre>


<h3>Format</h3>

<p>A data frame with 84 observations on the following 3 variables.
</p>

<dl>
<dt>group</dt><dd><p>a factor with levels <code>C</code>, <code>H</code>, <code>L</code> and <code>M</code></p>
</dd>
<dt>n</dt><dd><p>a numeric vector: the total number of foetuses.</p>
</dd>
<dt>y</dt><dd><p>a numeric vector: the number of affected foetuses.</p>
</dd>
</dl>



<h3>References</h3>

<p>Paul, S.R., 1982. <em>Analysis of proportions of affected foetuses in teratological experiments.</em> 
Biometrics 38, 361-370.
</p>

<hr>
<h2 id='raoscott'>Test of Proportion Homogeneity using Rao and Scott's Adjustment</h2><span id='topic+raoscott'></span><span id='topic+show+2Craoscott-class'></span>

<h3>Description</h3>

<p>Tests the homogeneity of proportions between <code class="reqn">I</code> groups (H0: <code class="reqn">p_1 = p_2 = ... = p_I</code> ) from clustered binomial 
data <code class="reqn">(n, y)</code> using the adjusted <code class="reqn">\chi^2</code> statistic proposed by Rao and Scott (1993).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raoscott(formula = NULL, response = NULL, weights = NULL, 
              group = NULL, data, pooled = FALSE, deff = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raoscott_+3A_formula">formula</code></td>
<td>
<p>An optional formula where the left-hand side is either a matrix of the form <code>cbind(y, n-y)</code>,
where the modelled probability is <code>y/n</code>, or a vector of proportions to be modelled (<code>y/n</code>). 
In both cases, the right-hand side must specify a single grouping variable. When the left-hand side of the formula 
is a vector of proportions, the argument <code>weight</code> must be used to indicate the denominators of the 
proportions.</p>
</td></tr>
<tr><td><code id="raoscott_+3A_response">response</code></td>
<td>
<p>An optional argument: either a matrix of the form <code>cbind(y, n-y)</code>, where the modelled probability 
is <code>y/n</code>, or a vector of proportions to be modelled (<code>y/n</code>).</p>
</td></tr>
<tr><td><code id="raoscott_+3A_weights">weights</code></td>
<td>
<p>An optional argument used when the left-hand side of <code>formula</code> or <code>response</code> is a vector
of proportions: <code>weight</code> is the denominator of the proportions.</p>
</td></tr>
<tr><td><code id="raoscott_+3A_group">group</code></td>
<td>
<p>An optional argument only used when <code>response</code> is used. In this case, this argument is a factor 
indicating a grouping variable.</p>
</td></tr>
<tr><td><code id="raoscott_+3A_data">data</code></td>
<td>
<p>A data frame containing the response (<code>n</code> and <code>y</code>) and the grouping variable.</p>
</td></tr>
<tr><td><code id="raoscott_+3A_pooled">pooled</code></td>
<td>
<p>Logical indicating if a pooled design effect is estimated over the <code class="reqn">I</code> groups.</p>
</td></tr>
<tr><td><code id="raoscott_+3A_deff">deff</code></td>
<td>
<p>A numerical vector of <code class="reqn">I</code> design effects.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method is based on the concepts of design effect and effective sample size.<br /><br />
The design effect in each group <code class="reqn">i</code> is estimated by <code class="reqn">deff_i = vratio_i / vbin_i</code>, where <code class="reqn">vratio_i</code> is 
the variance of the ratio estimate of the probability in group <code class="reqn">i</code> (Cochran, 1999, p. 32 and p. 66)
and <code class="reqn">vbin_i</code> is the standard binomial variance. A pooled design effect (i.e., over the <code class="reqn">I</code> groups)
is estimated if argument <code>pooled = TRUE</code> (see Rao and Scott, 1993, Eq. 6). Fixed design effects can be specified
with the argument <code>deff</code>.<br />
The <code class="reqn">deff_i</code> are used  to compute the effective sample sizes <code class="reqn">nadj_i = n_i / deff_i</code>, the effective numbers
of successes <code class="reqn">yadj_i = y_i / deff_i</code> in each group <code class="reqn">i</code>, and the overall effective proportion 
<code class="reqn">padj = \sum_{i} yadj_i / \sum_{i} deff_i</code>.
The test statistic is obtained by substituting these quantities in the usual <code class="reqn">\chi^2</code> statistic,
yielding:
</p>
<p style="text-align: center;"><code class="reqn">X^2 = \sum_{i}\frac{(yadj_i - nadj_i * padj)^2}{nadj_i * padj * (1 - padj)}</code>
</p>

<p>which is compared to a <code class="reqn">\chi^2</code> distribution with <code class="reqn">I - 1</code> degrees of freedom.
</p>


<h3>Value</h3>

<p>An object of formal class &ldquo;drs&rdquo;: see <code><a href="#topic+drs-class">drs-class</a></code> for details. The slot <code>tab</code>
provides the proportion of successes, the variances of the proportion and the design effect for each group.
</p>


<h3>Author(s)</h3>

<p>Matthieu Lesnoff <a href="mailto:matthieu.lesnoff@cirad.fr">matthieu.lesnoff@cirad.fr</a>, Renaud Lancelot <a href="mailto:renaud.lancelot@cirad.fr">renaud.lancelot@cirad.fr</a></p>


<h3>References</h3>

<p>Cochran, W.G., 1999, 2nd ed. <em>Sampling techniques</em>. John Wiley &amp; Sons, New York.<br />
Rao, J.N.K., Scott, A.J., 1992. <em>A simple method for the analysis of clustered binary data</em>.
Biometrics 48, 577-585.
</p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+chisq.test">chisq.test</a></code>, <code><a href="#topic+donner">donner</a></code>, <code><a href="#topic+iccbin">iccbin</a></code>, <code><a href="#topic+drs-class">drs-class</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(rats)
  # deff by group
  raoscott(cbind(y, n - y) ~ group, data = rats)
  raoscott(y/n ~ group, weights = n, data = rats)
  raoscott(response = cbind(y, n - y), group = group, data = rats)
  raoscott(response = y/n, weights = n, group = group, data = rats)
  # pooled deff
  raoscott(cbind(y, n - y) ~ group, data = rats, pooled = TRUE)
  # standard test
  raoscott(cbind(y, n - y) ~ group, data = rats, deff = c(1, 1))
  data(antibio)
  raoscott(cbind(y, n - y) ~ treatment, data = antibio)
  </code></pre>

<hr>
<h2 id='rats'> Rats Diet Experiment </h2><span id='topic+rats'></span>

<h3>Description</h3>

<p>&ldquo;Weil (1970) in Table 1 gives the results from an experiment comprising two treatments. One group of 
16 pregnant female rats was fed a control diet during pregnancy and lactation, the diet of a second group of 16 pregnant 
females was treated with a chemical. For each litter the number <code class="reqn">n</code> of pups alive at 4 days and the number <code class="reqn">x</code> 
of pups that survived the 21 day lactation period were recorded.&rdquo; (Williams, 1975, p. 951).</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(rats)</code></pre>


<h3>Format</h3>

<p>A data frame with 32 observations on the following 3 variables.
</p>

<dl>
<dt>group</dt><dd><p>A factor with levels <code>CTRL</code> and <code>TREAT</code></p>
</dd>
<dt>n</dt><dd><p>A numeric vector: the number of pups alive at 4 days.</p>
</dd>
<dt>y</dt><dd><p>A numeric vector: the number of pups that survived the 21 day lactation.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Williams, D.A., 1975. <em>The analysis of binary responses from toxicological experiments
involving reproduction and teratogenicity</em>. Biometrics 31, 949-952.
</p>


<h3>References</h3>

<p>Weil, C.S., 1970. <em>Selection of the valid number of sampling units and a consideration of their combination 
in toxicological studies involving reproduction, teratogenesis or carcinogenesis</em>. Fd. Cosmet. Toxicol. 8, 177-182.
</p>

<hr>
<h2 id='residuals-methods'>Residuals for Maximum-Likelihood and Quasi-Likelihood Models</h2><span id='topic+residuals+2CglimML-method'></span><span id='topic+residuals+2CglimQL-method'></span>

<h3>Description</h3>

<p>Residuals of models fitted with functions <code>betabin</code> and <code>negbin</code> (formal class &ldquo;glimML&rdquo;), or 
<code>quasibin</code> and <code>quasipois</code> (formal class &ldquo;glimQL&rdquo;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S4 method for signature 'glimML'
residuals(object, type = c("pearson", "response"), ...)
  ## S4 method for signature 'glimQL'
residuals(object, type = c("pearson", "response"), ...)
  </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals-methods_+3A_object">object</code></td>
<td>
<p>Fitted model of formal class &ldquo;glimML&rdquo; or &ldquo;glimQL&rdquo;.</p>
</td></tr>
<tr><td><code id="residuals-methods_+3A_type">type</code></td>
<td>
<p>Character string for the type of residual: &ldquo;pearson&rdquo; (default) or &ldquo;response&rdquo;.</p>
</td></tr>
<tr><td><code id="residuals-methods_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to the function, such as <code>na.action</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For models fitted with <code>betabin</code> or <code>quasibin</code>, Pearson's residuals are computed as:
</p>
<p style="text-align: center;"><code class="reqn">\frac{y - n * \hat{p}}{\sqrt{n * \hat{p} * (1 - \hat{p}) * (1 + (n - 1) * \hat{\phi})}}</code>
</p>

<p>where <code class="reqn">y</code> and <code class="reqn">n</code> are respectively the numerator and the denominator of the response, <code class="reqn">\hat{p}</code> 
is the fitted probability and <code class="reqn">\hat{\phi}</code> is the fitted overdispersion parameter. When <code class="reqn">n = 0</code>, the 
residual is set to 0. Response residuals are computed as <code class="reqn">y/n - \hat{p}</code>.<br />
For models fitted with <code>negbin</code> or <code>quasipois</code>, Pearson's residuals are computed as:
</p>
<p style="text-align: center;"><code class="reqn">\frac{y - \hat{y}}{\sqrt{\hat{y} + \hat{\phi} * \hat{y}^2}}</code>
</p>

<p>where <code class="reqn">y</code> and <code class="reqn">\hat{y}</code> are the observed and fitted counts, respectively. Response residuals are 
computed as <code class="reqn">y - \hat{y}</code>.
</p>


<h3>Value</h3>

<p>A numeric vector of residuals.</p>


<h3>Author(s)</h3>

<p>Matthieu Lesnoff <a href="mailto:matthieu.lesnoff@cirad.fr">matthieu.lesnoff@cirad.fr</a>, Renaud Lancelot <a href="mailto:renaud.lancelot@cirad.fr">renaud.lancelot@cirad.fr</a></p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+residuals.glm">residuals.glm</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(orob2)
  fm &lt;- betabin(cbind(y, n - y) ~ seed, ~ 1,
                 link = "logit", data = orob2)
  #Pearson's chi-squared goodness-of-fit statistic
  sum(residuals(fm, type = "pearson")^2)
  </code></pre>

<hr>
<h2 id='salmonella'>Salmonella Reverse Mutagenicity Assay</h2><span id='topic+salmonella'></span>

<h3>Description</h3>

<p>&ldquo;Data for our third example were compiled by Margolin et al. (1981) from an Ames <em>Salmonella</em>
reverse mutagenicity assay. Table 1 shows the number of revertant colonies observed on each of 3 replicate 
plates tested at each of 6 dose levels of quinoline.&rdquo; (Breslow, 1984, Table 1).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(salmonella)</code></pre>


<h3>Format</h3>

<p>A data frame with 18 observations on the following 2 variables.
</p>

<dl>
<dt>dose</dt><dd><p>a numeric vector: the dose level of quinoline (microgram per plate).</p>
</dd>
<dt>y</dt><dd><p>a numeric vector: the number of revertant colonies of TA98 <em>Salmonella</em>.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Breslow, N.E., 1984. <em>Extra-Poisson variation in log-linear models</em>. Applied Statistics 33(1), 38-44.
</p>


<h3>References</h3>

<p>Margolin, B.H., Kaplan, N., Zeiger, E., 1981. <em>Statistical analysis of the Ames Salmonella/microsome test</em>.
Proc. Natl Acad. Sci. USA 76, 3779-3783.
</p>

<hr>
<h2 id='splitbin'>Split Grouped Data Into Individual Data</h2><span id='topic+splitbin'></span>

<h3>Description</h3>

<p>The function splits grouped data and optional covariates into individual data.
Two types of grouped data are managed by <code>splitbin</code>:
</p>

<ul>
<li><p> Grouped data with weights;
</p>
</li>
<li><p> Grouped data of form <code>cbind(success, failure)</code>.
</p>
</li></ul>

<p>When weights, successes or failures involve non-integer numbers, these numbers are rounded before splitting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  splitbin(formula, data, id = "idbin")
  </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splitbin_+3A_formula">formula</code></td>
<td>
<p>A formula. The left-hand side represents grouped data.
The right-hand side defines the covariates. See examples for syntax.</p>
</td></tr>
<tr><td><code id="splitbin_+3A_data">data</code></td>
<td>
<p>A data frame where all the variables described in <code>formula</code> are found.</p>
</td></tr>
<tr><td><code id="splitbin_+3A_id">id</code></td>
<td>
<p>An optional character string naming the identifier (= grouping factor). Default to &ldquo;idbin&rdquo;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame built according to the formula and function used in the call.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Grouped data with weights
mydata &lt;- data.frame(
    success = c(0, 1, 0, 1),
    f1 = c("A", "A", "B", "B"),
    f2 = c("C", "D", "C", "D"),
    n = c(4, 2, 1, 3)
    )
mydata
splitbin(formula = n ~ f1, data = mydata)$tab
splitbin(formula = n ~ f1 + f2 + success , data = mydata)$tab

# Grouped data of form "cbind(success, failure)"
mydata &lt;- data.frame(
    success = c(4, 1),
    failure = c(1, 2),
    f1 = c("A", "B"),
    f2 = c("C", "D")
    )
mydata$n &lt;- mydata$success + mydata$failure
mydata
splitbin(formula = cbind(success, failure) ~ 1, data = mydata)$tab
splitbin(formula = cbind(success, failure) ~ f1 + f2, data = mydata)$tab
splitbin(formula = cbind(success, n - success) ~ f1 + f2, data = mydata)$tab
splitbin(formula = cbind(success, n - 0.5 * failure - success) ~ f1 + f2,
         data = mydata)$tab
</code></pre>

<hr>
<h2 id='summary+2Caic-method'>Akaike Information Statistics</h2><span id='topic+summary+2Caic-method'></span><span id='topic+show+2Caic-method'></span>

<h3>Description</h3>

<p>Computes Akaike difference and Akaike weights from an object of formal class &ldquo;aic&rdquo;.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S4 method for signature 'aic'
summary(object, which = c("AIC", "AICc"))
  </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary+2B2Caic-method_+3A_object">object</code></td>
<td>
<p>An object of formal class &ldquo;aic&rdquo;.</p>
</td></tr>
<tr><td><code id="summary+2B2Caic-method_+3A_which">which</code></td>
<td>
<p>A character string indicating which information criterion is selected to compute Akaike difference and
Akaike weights: either &ldquo;AIC&rdquo; or &ldquo;AICc&rdquo;.</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>summary</dt><dd><p>The models are ordered according to AIC or AICc and 3 statistics are computed:
</p>
<p>- the <em>Akaike difference</em> <code class="reqn">\Delta</code>: the change in AIC (or AICc) between successive (ordered) models,
</p>
<p>- the <em>Akaike weight</em> <code class="reqn">W</code>: when <code class="reqn">r</code> models are compared, 
<code class="reqn">W = e^{-0.5 * \Delta} / \sum_r{e^{-\frac{1}{2} * \Delta}}</code>,
</p>
<p>- the <em>cumulative Akaike weight</em> <code class="reqn">cum.W</code>: the Akaike weights sum to 1 for the <code class="reqn">r</code> models which 
are compared.
</p>
</dd>
</dl>



<h3>References</h3>

<p>Burnham, K.P., Anderson, D.R., 2002. <em>Model selection and multimodel inference: a practical
information-theoretic approach</em>. New-York, Springer-Verlag, 496 p.<br />
Hurvich, C.M., Tsai, C.-L., 1995. <em>Model selection for extended quasi-likelihood models in small samples</em>.
Biometrics, 51 (3): 1077-1084.
</p>


<h3>See Also</h3>

<p>Examples in <code><a href="#topic+betabin">betabin</a></code> and <code><a href="stats.html#topic+AIC">AIC</a></code> in package <span class="pkg">stats</span>.</p>

<hr>
<h2 id='summary.glimML-class'>Summary of Objects of Class &quot;summary.glimML&quot;</h2><span id='topic+summary.glimML-class'></span><span id='topic+show+2CglimML-class'></span><span id='topic+summary+2CglimML-method'></span><span id='topic+show+2Csummary.glimML-method'></span>

<h3>Description</h3>

<p>Summary of a model of formal class &ldquo;glimML&rdquo; fitted by <code>betabin</code> or <code>negbin</code>.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("summary.glimML", ...)</code> or, 
more commonly, via the <code>summary</code> or <code>show</code> method for objects of formal class &ldquo;glimML&rdquo;.</p>


<h3>Slots</h3>


<dl>
<dt><code>object</code></dt><dd><p>An object of formal class &ldquo;glimML&rdquo;.</p>
</dd>
<dt><code>Coef</code></dt><dd><p>A data frame containing the estimates, standard error, z and P values for the 
fixed-effect coefficients which were <em>estimated</em> by the fitting function.</p>
</dd>
<dt><code>FixedCoef</code></dt><dd><p>A data frame containing the values of the fixed-effect coefficients which were <em>set</em> 
to a fixed value.</p>
</dd>
<dt><code>Phi</code></dt><dd><p>A data frame containing the estimates, standard error, z and P values for the overdispersion 
coefficients which were <em>estimated</em> by the fitting function. Because the overdispersion 
coefficients are <code class="reqn">&gt; 0</code>, P values correspond to unilateral tests.</p>
</dd>
<dt><code>FixedPhi</code></dt><dd><p>A data frame containing the values of the overdispersion coefficients which were <em>set</em> 
to a fixed value.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "summary.glimML")</code></p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "glimML")</code></p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "glimML")</code></p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>  data(orob2)
  fm1 &lt;- betabin(cbind(y, n - y) ~ seed, ~ 1, data = orob2)
  # show objects of class "glimML"
  fm1
  # summary for objects of class "glimML"
  res &lt;- summary(fm1)
  res@Coef
  # show objects of class "summary.glimML"
  res
  </code></pre>

<hr>
<h2 id='varbin'>Mean, Variance and Confidence Interval of a Proportion</h2><span id='topic+varbin'></span><span id='topic+show+2Cvarbin-class'></span>

<h3>Description</h3>

<p>This function computes the mean and variance of a proportion from clustered binomial data <code class="reqn">(n, y)</code>, using various 
methods. Confidence intervals are computed using a normal approximation, which might be inappropriate when the 
proportion is close to 0 or 1.</p>


<h3>Usage</h3>

<pre><code class='language-R'>varbin(n, y, data, alpha = 0.05, R = 5000)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varbin_+3A_n">n</code></td>
<td>
<p>The denominator of the proportion.</p>
</td></tr>
<tr><td><code id="varbin_+3A_y">y</code></td>
<td>
<p>The numerator of the proportion.</p>
</td></tr>
<tr><td><code id="varbin_+3A_data">data</code></td>
<td>
<p>A data frame containing the data.</p>
</td></tr>
<tr><td><code id="varbin_+3A_alpha">alpha</code></td>
<td>
<p>The significance level for the confidence intervals. Default to 0.05, providing 95% CI's.</p>
</td></tr>
<tr><td><code id="varbin_+3A_r">R</code></td>
<td>
<p>The number of bootstrap replicates to compute the bootstrap mean and variance.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Five methods are used for the estimations. Let us
consider <code class="reqn">N</code> clusters of sizes <code class="reqn">n_1, \ldots, n_N</code> with observed responses (counts) <code class="reqn">y_1, \ldots, y_N</code>.
We note <code class="reqn">p_i = y_i / n_i</code> the observed proportions <code class="reqn">(i = 1, \ldots, N)</code>. An underlying assumption is that the
theoretical proportion is homogeneous across the clusters.
</p>
<p><b>Binomial method:</b> the proportion and its variance are estimated as <code class="reqn">p = \frac{\sum_{i} y_i}{\sum_{i} n_i}</code> and <code class="reqn">\frac{p * (1 - p)}{\sum_{i} n_i - 1}</code>, respectively.
</p>
<p><b>Ratio method:</b> the one-stage cluster sampling formula is used to estimate the variance of the ratio estimate
(see Cochran, 1999, p. 32 and p. 66). The proportion is estimated as above (<code class="reqn">p</code>).
</p>
<p><b>Arithmetic method:</b> the proportion is estimated as <code class="reqn">p_A = \frac{1}{N}\sum_{i}\frac{y_i}{n_i}</code>, with estimated variance <code class="reqn">\frac{\sum_{i}(p_i - p_A)^2}{N * (N - 1)}</code>.
</p>
<p><b>Jackknife method:</b> the proportion <code class="reqn">p_J</code> is the arithmetic mean of the pseudovalues <code class="reqn">pv_i</code>, with estimated
variance <code class="reqn">\frac{\sum_{i}(pv_i - p_J)^2}{N * (N - 1)}</code>
(Gladen, 1977, Paul, 1982).
</p>
<p><b>Bootstrap method:</b> <code class="reqn">R</code> samples of size <code class="reqn">N</code> are drawn with equal probability from the initial sample
<code class="reqn">(p_1, \ldots , p_N)</code> (Efron and Tibshirani, 1993). The bootstrap estimate <code class="reqn">p_B</code> and its estimated variance 
are the arithmetic mean and the empirical variance (computed with denominator <code class="reqn">R - 1</code>) of the <code class="reqn">R</code> binomial 
estimates, respectively.
</p>


<h3>Value</h3>

<p>An object of formal class &ldquo;varbin&rdquo;, with 5 slots:
</p>
<table>
<tr><td><code>CALL</code></td>
<td>
<p>The call of the function.</p>
</td></tr>
<tr><td><code>tab</code></td>
<td>
<p>A 4-column data frame giving for each estimation method the mean, variance, upper and lower limits
of the <code class="reqn">(1 - \alpha)</code> confidence interval.</p>
</td></tr>
<tr><td><code>boot</code></td>
<td>
<p>A numeric vector containing the R bootstrap replicates of the proportion. Might be used to compute other
kinds of CI's for the proportion.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>The significance level used to compute the <code class="reqn">(1 - \alpha)</code> confidence intervals.</p>
</td></tr>
<tr><td><code>features</code></td>
<td>
<p>A numeric vector with 3 components summarizing the main features of the data: <code>N</code> = number 
of clusters, <code>n</code> = number of subjects, <code>y</code> = number of cases.</p>
</td></tr>
</table>
<p>The &ldquo;show&rdquo; method displays the slot <code>tab</code> described above, substituting the standard error to the variance.
</p>


<h3>Author(s)</h3>

<p>Matthieu Lesnoff <a href="mailto:matthieu.lesnoff@cirad.fr">matthieu.lesnoff@cirad.fr</a>, Renaud Lancelot <a href="mailto:renaud.lancelot@cirad.fr">renaud.lancelot@cirad.fr</a></p>


<h3>References</h3>

<p>Cochran, W.G., 1999, 3th ed. <em>Sampling techniques</em>. Wiley, New York.<br />
Efron, B., Tibshirani, R., 1993. <em>An introduction to the bootstrap</em>. Chapman and Hall, London.<br />
Gladen, B., 1977. <em>The use of the jackknife to estimate proportions from toxicological data in the presence 
of litter effects</em>. JASA 74(366), 278-283.<br />
Paul, S.R., 1982. <em>Analysis of proportions of affected foetuses in teratological experiments</em>. 
Biometrics 38, 361-370.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+varbin-class">varbin-class</a></code>, <code><a href="boot.html#topic+boot">boot</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(rabbits)
  varbin(n, y, rabbits[rabbits$group == "M", ])
  by(rabbits,
     list(group = rabbits$group),
     function(x) varbin(n = n, y = y, data = x, R = 1000))
  </code></pre>

<hr>
<h2 id='varbin-class'>Representation of Objects of Formal Class &quot;varbin&quot;</h2><span id='topic+varbin-class'></span><span id='topic+show+2Cvarbin-method'></span>

<h3>Description</h3>

<p>Representation of the output of function <code>varbin</code> used to estimate proportions and their variance 
under various distribution assumptions.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("varbin", ...)</code> or, more commonly,
via the function <code>varbin</code>.</p>


<h3>Slots</h3>


<dl>
<dt><code>CALL</code></dt><dd><p>The call of the function.</p>
</dd>
<dt><code>tab</code></dt><dd><p>A data frame containing the estimates, their variance and the confidence limits.</p>
</dd>
<dt><code>pboot</code></dt><dd><p>A numeric vector containing the bootstrap replicates.</p>
</dd>
<dt><code>alpha</code></dt><dd><p>The <code class="reqn">\alpha</code> level to compute confidence intervals.</p>
</dd>
<dt><code>features</code></dt><dd><p>A named numeric vector summarizing the design.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>varbin</dt><dd><p><code>signature(object = "varbin")</code>: see <code><a href="#topic+varbin">varbin</a></code>.</p>
</dd>
</dl>


<hr>
<h2 id='vcov-methods'>Methods for Function &quot;vcov&quot; in Package &quot;aod&quot;</h2><span id='topic+vcov+2CglimML-method'></span><span id='topic+vcov+2CglimQL-method'></span><span id='topic+geese-class'></span><span id='topic+geeglm-class'></span><span id='topic+vcov+2Cgeese-method'></span><span id='topic+vcov+2Cgeeglm-method'></span>

<h3>Description</h3>

<p>Extract the approximate var-cov matrix of estimated coefficients from fitted models.</p>


<h3>Methods</h3>


<dl>
<dt>ANY</dt><dd><p>Generic function: see <code><a href="stats.html#topic+vcov">vcov</a></code>.</p>
</dd>
<dt>glimML</dt><dd><p>Extract the var-cov matrix of estimated coefficients for fitted models of formal class &ldquo;glimML&rdquo;.</p>
</dd>
<dt>glimQL</dt><dd><p>Extract the var-cov matrix of estimated coefficients for fitted models of formal class &ldquo;glimQL&rdquo;.</p>
</dd>
<dt>geese</dt><dd><p>Extract the var-cov matrix of estimated coefficients for fitted models of class &ldquo;geese&rdquo; 
(contributed package <span class="pkg">geepack</span>).</p>
</dd>
<dt>geeglm</dt><dd><p>Extract the var-cov matrix of estimated coefficients for fitted objects of class &ldquo;geeglm&rdquo; 
(contributed package <span class="pkg">geepack</span>).</p>
</dd>
</dl>

<hr>
<h2 id='wald.test'>Wald Test for Model Coefficients</h2><span id='topic+wald.test'></span><span id='topic+print.wald.test'></span>

<h3>Description</h3>

<p>Computes a Wald <code class="reqn">\chi^2</code> test for 1 or more coefficients, given their variance-covariance matrix.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  wald.test(Sigma, b, Terms = NULL, L = NULL, H0 = NULL,  
            df = NULL, verbose = FALSE)
  ## S3 method for class 'wald.test'
print(x, digits = 2, ...)
  </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wald.test_+3A_sigma">Sigma</code></td>
<td>

<p>A var-cov matrix, usually extracted from one of the fitting functions (e.g., <code>lm</code>, <code>glm</code>, ...).
</p>
</td></tr>
<tr><td><code id="wald.test_+3A_b">b</code></td>
<td>

<p>A vector of coefficients with var-cov matrix <code>Sigma</code>. These coefficients are usually extracted from 
one of the fitting functions available in <span class="rlang"><b>R</b></span> (e.g., <code>lm</code>, <code>glm</code>,...).
</p>
</td></tr>
<tr><td><code id="wald.test_+3A_terms">Terms</code></td>
<td>

<p>An optional integer vector specifying which coefficients should be <em>jointly</em> tested, using a Wald 
<code class="reqn">\chi^2</code> or <code class="reqn">F</code> test. Its elements correspond to the columns or rows of the var-cov 
matrix given in <code>Sigma</code>. Default is <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="wald.test_+3A_l">L</code></td>
<td>

<p>An optional matrix conformable to <code>b</code>, such as its product with <code>b</code> i.e., <code>L %*% b</code> 
gives the linear combinations of the coefficients to be tested. Default is <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="wald.test_+3A_h0">H0</code></td>
<td>

<p>A numeric vector giving the null hypothesis for the test. It must be as long as <code>Terms</code> or 
must have the same number of columns as <code>L</code>. Default to 0 for all the coefficients to be tested.
</p>
</td></tr>
<tr><td><code id="wald.test_+3A_df">df</code></td>
<td>

<p>A numeric vector giving the degrees of freedom to be used in an <code class="reqn">F</code> test, i.e. the degrees of freedom 
of the residuals of the model from which <code>b</code> and <code>Sigma</code> were fitted. Default to NULL, for no 
<code class="reqn">F</code> test. See the section <b>Details</b> for more information.
</p>
</td></tr>
<tr><td><code id="wald.test_+3A_verbose">verbose</code></td>
<td>

<p>A logical scalar controlling the amount of output information. The default is <code>FALSE</code>, providing minimum output.
</p>
</td></tr>
<tr><td><code id="wald.test_+3A_x">x</code></td>
<td>

<p>Object of class &ldquo;wald.test&rdquo;
</p>
</td></tr>
<tr><td><code id="wald.test_+3A_digits">digits</code></td>
<td>

<p>Number of decimal places for displaying test results. Default to 2.
</p>
</td></tr>
<tr><td><code id="wald.test_+3A_...">...</code></td>
<td>

<p>Additional arguments to <code>print</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The key assumption is that the coefficients asymptotically follow a (multivariate) normal distribution with mean = 
model coefficients and variance = their var-cov matrix.<br />
One (and only one) of <code>Terms</code> or <code>L</code> must be given. When <code>L</code> is given, it must have the same number of 
columns as the length of <code>b</code>, and the same number of rows as the number of linear combinations of coefficients. 
When <code>df</code> is given, the <code class="reqn">\chi^2</code> Wald statistic is divided by <code>m</code> = the number of 
linear combinations of coefficients to be tested (i.e., <code>length(Terms)</code> or <code>nrow(L)</code>). Under the null 
hypothesis <code>H0</code>, this new statistic follows an <code class="reqn">F(m, df)</code> distribution.
</p>


<h3>Value</h3>

<p>An object of class <code>wald.test</code>, printed with <code>print.wald.test</code>.
</p>


<h3>References</h3>

<p>Diggle, P.J., Liang, K.-Y., Zeger, S.L., 1994. Analysis of longitudinal data. Oxford, Clarendon Press, 253 p.<br />
Draper, N.R., Smith, H., 1998. Applied Regression Analysis. New York, John Wiley &amp; Sons, Inc., 706 p.
</p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+vcov">vcov</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(orob2)
  fm &lt;- quasibin(cbind(y, n - y) ~ seed * root, data = orob2)
  # Wald test for the effect of root
  wald.test(b = coef(fm), Sigma = vcov(fm), Terms = 3:4)
  </code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
