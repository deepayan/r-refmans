<!DOCTYPE html><html><head><title>Help for package BET</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BET}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BEAST'><p>Binary Expansion Adaptive Symmetry Test</p></a></li>
<li><a href='#BEAST.null.simu'>
<p>BEAST Null Distribution</p></a></li>
<li><a href='#BET_package'><p>Binary Expansion Testing</p></a></li>
<li><a href='#bet.plot'><p>Plotting Binary Expansion Testing (2-dimensions)</p></a></li>
<li><a href='#cell.counts'>
<p>Counts the amount of points in each cell after binary expansion.</p></a></li>
<li><a href='#get.signs'>
<p>Signs of Colors of all Points for all Interactions</p></a></li>
<li><a href='#MaxBET'><p>Binary Expansion Testing at a Certain Depth</p></a></li>
<li><a href='#MaxBETs'><p>Binary Expansion Testing up to a Certain Depth</p></a></li>
<li><a href='#star'><p>Coordinates of Brightest Stars in the Night Sky</p></a></li>
<li><a href='#symm'>
<p>Symmetry Statistics for all Interactions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Binary Expansion Testing</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Description:</td>
<td>Nonparametric detection of nonuniformity and dependence with Binary Expansion Testing (BET). See Kai Zhang (2019) BET on Independence, Journal of the American Statistical Association, 114:528, 1620-1637, &lt;<a href="https://doi.org/10.1080%2F01621459.2018.1537921">doi:10.1080/01621459.2018.1537921</a>&gt;, Kai Zhang, Zhigen Zhai, and Wen Zhou. (2021). BEAUTY Powered BEAST, &lt;<a href="https://arxiv.org/abs/2103.00674">arXiv:2103.00674</a>&gt;  and Wan Zhang, Zhigen Zhao, Michael Baiocchi, Yao Li, Kai Zhang. SorBET: A Fast and Powerful Algorithm to Test Dependence of Variables, Techinical report, 2023.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.3)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-20 18:25:44 UTC; zhangwan</td>
</tr>
<tr>
<td>Author:</td>
<td>Wan Zhang [aut, cre],
  Zhigen Zhao [aut],
  Michael Baiocchi [aut],
  Kai Zhang [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Wan Zhang &lt;wanz63@live.unc.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-21 01:20:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='BEAST'>Binary Expansion Adaptive Symmetry Test</h2><span id='topic+BEAST'></span>

<h3>Description</h3>

<p><code>BEAST</code> (Binary Expansion Adaptive Symmetry Test) is used for nonparametric detection of nonuniformity or dependence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BEAST(
  X,
  dep,
  subsample.percent = 1/2,
  B = 100,
  unif.margin = FALSE,
  lambda = NULL,
  index = list(c(1:ncol(X))),
  method = "p",
  num = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BEAST_+3A_x">X</code></td>
<td>
<p>a matrix to be tested.</p>
</td></tr>
<tr><td><code id="BEAST_+3A_dep">dep</code></td>
<td>
<p>depth of the binary expansion for the <code>BEAST</code>.</p>
</td></tr>
<tr><td><code id="BEAST_+3A_subsample.percent">subsample.percent</code></td>
<td>
<p>sample size for subsampling.</p>
</td></tr>
<tr><td><code id="BEAST_+3A_b">B</code></td>
<td>
<p>times of subsampling.</p>
</td></tr>
<tr><td><code id="BEAST_+3A_unif.margin">unif.margin</code></td>
<td>
<p>logicals. If <code>TRUE</code> the marginal distribution is known to be Uniform[0,1]. Default is <code>FALSE</code>, and empirical cdf transformation will be applied to each marginal distribution.</p>
</td></tr>
<tr><td><code id="BEAST_+3A_lambda">lambda</code></td>
<td>
<p>tuning parameter for soft-thresholding, default to be <code class="reqn">sqrt(log(2^(p * dep)) / (8*n))</code>.</p>
</td></tr>
<tr><td><code id="BEAST_+3A_index">index</code></td>
<td>

<p>a list of indices. If provided, test the independence among two or more groups of variables. For example, <code>index = list(c(1,2), c(3)))</code> refers to test the independence between <code class="reqn">(X_1, X_2)</code> and <code class="reqn">X_3</code>. Default to be <code>list(c(1:p))</code> to test if the data follow the multivariate uniform distribution over [0,1]^p, where <code>p = ncol(X)</code>.
</p>
</td></tr>
<tr><td><code id="BEAST_+3A_method">method</code></td>
<td>

<p>If <code>"p"</code>, then compute null distribution with permutations. If <code>"s"</code>, then compute null distribution with simulations. If <code>"stat"</code>, only return interaction and BEAST Statistic.
</p>
</td></tr>
<tr><td><code id="BEAST_+3A_num">num</code></td>
<td>

<p>number of permutations if method == &quot;p&quot; (default to be 100), or simulations if method == &quot;s&quot; (default to be 1000).
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>Interaction</code></td>
<td>
<p>the most frequent interaction among all subsamples.</p>
</td></tr>
<tr><td><code>BEAST.Statistic</code></td>
<td>
<p>BEAST statistic.</p>
</td></tr>
<tr><td><code>Null.Distribution</code></td>
<td>
<p>simulated null distribution.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>simulated p-value.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Elapsed times 7.73 secs
## Measured in R 4.0.2, 32 bit, on a processor 3.3 GHz 6-Core Intel Core i5 under MacOS, 2021/9/8
## Not run: 
x1 = runif(128)
x2 = runif(128)
y = sin(4*pi*(x1 + x2)) + 0.8*rnorm(128)
##test independence between (x1, x2) and y
BEAST(cbind(x1, x2, y), 3, index = list(c(1,2), c(3)))
##test mutual independence among x1, x2 and y
BEAST(cbind(x1, x2, y), 3, index = list(1, 2, 3))

##test bivariate uniformity
x1 = rbeta(128, 2, 4)
x2 = rbeta(128, 2, 4)
BEAST(cbind(x1, x2), 3)
##test multivariate uniformity
x1 = rbeta(128, 2, 4)
x2 = rbeta(128, 2, 4)
x3 = rbeta(128, 2, 4)
BEAST(cbind(x1, x2, x3), 3)

##with a known simulation
BEAST.null &lt;- BEAST.null.simu(128, 3, 3,index = list(c(1,2), c(3)))
x1 = runif(128)
x2 = runif(128)
y = sin(4*pi*(x1 + x2)) + 0.8*rnorm(128)
BEAST.stat = BEAST(cbind(x1, x2, y), 3, index = list(c(1,2), c(3)),
    method = "stat")$BEAST.Statistic
mean(BEAST.stat&lt;BEAST.null)  # p-value

## End(Not run)
</code></pre>

<hr>
<h2 id='BEAST.null.simu'>
BEAST Null Distribution
</h2><span id='topic+BEAST.null.simu'></span>

<h3>Description</h3>

<p><code>BEAST.null.simu</code> gives a vector of the null distribution of the BEAST statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BEAST.null.simu(
  n,
  p,
  dep,
  subsample.percent = 1/2,
  B = 100,
  lambda = NULL,
  index = list(c(1:p)),
  method = "p",
  num = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BEAST.null.simu_+3A_n">n</code></td>
<td>
<p>sample size.</p>
</td></tr>
<tr><td><code id="BEAST.null.simu_+3A_p">p</code></td>
<td>
<p>dimension.</p>
</td></tr>
<tr><td><code id="BEAST.null.simu_+3A_dep">dep</code></td>
<td>
<p>depth of the binary expansion.</p>
</td></tr>
<tr><td><code id="BEAST.null.simu_+3A_subsample.percent">subsample.percent</code></td>
<td>
<p>sample size for subsampling.</p>
</td></tr>
<tr><td><code id="BEAST.null.simu_+3A_b">B</code></td>
<td>
<p>times of subsampling.</p>
</td></tr>
<tr><td><code id="BEAST.null.simu_+3A_lambda">lambda</code></td>
<td>
<p>tuning parameter for soft-thresholding, default to be <code class="reqn">sqrt(log(2^(p * dep)) / (8*n))</code>.</p>
</td></tr>
<tr><td><code id="BEAST.null.simu_+3A_index">index</code></td>
<td>

<p>a list of indices. If provided, test the independence among two or more groups of variables. For example, <code>index = list(c(1,2), c(3)))</code> refers to test the independence between <code class="reqn">(X_1, X_2)</code> and <code class="reqn">X_3</code>. Default to be <code>list(c(1:p))</code> to test if the data follow the uniform distribution over [0,1]^p, where <code>p = ncol(X)</code>.
</p>
</td></tr>
<tr><td><code id="BEAST.null.simu_+3A_method">method</code></td>
<td>

<p>If <code>"p"</code>, then compute null distribution with permutations. If <code>"s"</code>, then compute null distribution with simulations.
</p>
</td></tr>
<tr><td><code id="BEAST.null.simu_+3A_num">num</code></td>
<td>

<p>number of permutations if method == &quot;p&quot; (default to be 100), or simulations if method == &quot;s&quot; (default to be 1000).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>BEAST.null.simu</code> returns a vector of length <code>num.permutations</code> that simulates the null distribution of the BEAST for given sample size n, dimension p, and depth D
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Elapsed times 2.4 secs
## Measured in R 4.0.2, 32 bit, on a processor 3.3 GHz 6-Core Intel Core i5 under MacOS, 2021/5/30.
## Not run: BEAST.null.simu(128, 2, 3)

## power study example
## Elapsed times 36.8 secs
## Measured in R 4.0.2, 32 bit, on a processor 3.3 GHz 6-Core Intel Core i5 under MacOS, 2021/5/30.
## Not run: 
nperm = 100
nsim = 1000
BEAST.res = rep(0, nsim)
## simulate null distribution: only need once
BEAST.null.dist = BEAST.null.simu(128, 3, 3, index = list(c(1,2), c(3)), num = nperm)
for(i in 1:nsim){
  x1 = runif(128)
  x2 = runif(128)
  y = sin(4*pi*(x1 + x2)) + 0.8*rnorm(128)
  BEAST.stat = BEAST(cbind(x1, x2, y), 3, index = list(c(1,2), c(3)),
    method = "stat")$BEAST.Statistic
  BEAST.pvalue = sum(BEAST.null.dist &gt;= BEAST.stat) / nperm
  BEAST.res[i] = BEAST.pvalue
}
## compute power
level = 0.1
power = mean(BEAST.res &lt; level)


## End(Not run)


</code></pre>

<hr>
<h2 id='BET_package'>Binary Expansion Testing</h2><span id='topic+BET-package'></span>

<h3>Description</h3>

<p>The <code>BET</code> package provides functions for nonparametric detection of nonuniformity and dependence with Binary Expansion Testing (BET).
</p>


<h3>BET functions</h3>

<p><code><a href="#topic+MaxBET">MaxBET</a></code>
<code><a href="#topic+symm">symm</a></code>
<code><a href="#topic+get.signs">get.signs</a></code>
<code><a href="#topic+cell.counts">cell.counts</a></code>
<code><a href="#topic+bet.plot">bet.plot</a></code>
<code><a href="#topic+MaxBETs">MaxBETs</a></code>
<code><a href="#topic+BEAST">BEAST</a></code>
<code><a href="#topic+BEAST.null.simu">BEAST.null.simu</a></code>
</p>


<h3>Reference(s)</h3>

<p>Kai Zhang (2019) BET on Independence, Journal of the American Statistical Association, 114:528, 1620-1637, doi: <a href="https://doi.org/10.1080/01621459.2018.1537921">10.1080/01621459.2018.1537921</a>,
Kai Zhang, Zhigen Zhao, and Wen Zhou (2021). BEAUTY Powered BEAST, &lt;arXiv:2103.00674&gt; and
Wan Zhang, Zhigen Zhao, Michael Baiocchi, Yao Li, Kai Zhang. SorBET: A Fast and Powerful Algorithm to Test Dependence of Variables. Techinical report, 2023.
</p>

<hr>
<h2 id='bet.plot'>Plotting Binary Expansion Testing (2-dimensions)</h2><span id='topic+bet.plot'></span>

<h3>Description</h3>

<p><code>bet.plot</code> shows the cross interaction of the strongest asymmetry, which the BET returns with the rejection of independence null.
This function only works for the test on two variables, that is, <code>X</code> can only have two columns.
There are <code class="reqn">2^{2dep} - 1</code> nontrivial binary variables in the <code class="reqn">\sigma</code>-field and <code class="reqn">(2^dep - 1)^2</code> of them are cross interactions, whose positive regions are in plotted in white and whose negative regions are plotted in blue.
<code>plot.bet</code> shows the cross interaction where the difference of number of observations in the positive and negative region is largest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'plot'
bet(X, dep, unif.margin = FALSE, cex=0.5, index = list(c(1:ncol(X))), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bet.plot_+3A_x">X</code></td>
<td>
<p>a matrix with two columns.</p>
</td></tr>
<tr><td><code id="bet.plot_+3A_dep">dep</code></td>
<td>
<p>depth of BET.</p>
</td></tr>
<tr><td><code id="bet.plot_+3A_unif.margin">unif.margin</code></td>
<td>

<p>logicals. If <code>TRUE</code> the marginal distribution is known to be Uniform[0,1]. Default is <code>FALSE</code>, and empirical cdf transformation will be applied to each marginal distribution.
</p>
</td></tr>
<tr><td><code id="bet.plot_+3A_cex">cex</code></td>
<td>
<p>number indicating the amount by which plotting text and symbols should be scaled relative to the default.</p>
</td></tr>
<tr><td><code id="bet.plot_+3A_index">index</code></td>
<td>

<p>a list of indices. If provided, test the independence among two or more groups of variables. For example, <code>index = list(c(1,2))</code> refers to test data uniformity, <code>index = list(1, 2)</code> refers to test independence between <code class="reqn">X_1</code> and <code class="reqn">X_2</code>. Default to be <code>list(c(1:p))</code>, where <code>p = ncol(X)</code>, then test data uniformity.
</p>
</td></tr>
<tr><td><code id="bet.plot_+3A_...">...</code></td>
<td>
<p>graphical parameters to plot</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>v &lt;- runif(128, -pi, pi)
X1 &lt;- cos(v) + 2.5 * rnorm(128, 0, 1/20)
X2 &lt;- sin(v) + 2.5 * rnorm(128, 0, 1/20)
bet.plot(cbind(X1, X2), 3, index = list(1,2))
</code></pre>

<hr>
<h2 id='cell.counts'>
Counts the amount of points in each cell after binary expansion.
</h2><span id='topic+cell.counts'></span>

<h3>Description</h3>

<p><code>cell.counts</code> returns the amount of data points in each cell getting from binary expansion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cell.counts(X, dep, unif.margin = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cell.counts_+3A_x">X</code></td>
<td>

<p>a matrix to be tested.
</p>
</td></tr>
<tr><td><code id="cell.counts_+3A_dep">dep</code></td>
<td>

<p>depth of the marginal binary expansions.
</p>
</td></tr>
<tr><td><code id="cell.counts_+3A_unif.margin">unif.margin</code></td>
<td>

<p>logicals. If <code>TRUE</code> the data has been uniformed based on empirical cumulative distribution function. Default to be <code>FALSE</code> and the function uniforms the data.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result is a dataframe with 2 rows and <code class="reqn">2^(p*dep)</code> columns, where <code class="reqn">p</code> is the number of columns of <code>X</code>. The first column is the binary index, the second column is the amount of data points.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>v &lt;- runif(128, -pi, pi)
X1 &lt;- cos(v) + 2.5 * rnorm(128, 0, 1/20)
X2 &lt;- sin(v) + 2.5 * rnorm(128, 0, 1/20)
cell.counts(cbind(X1, X2), 3)
</code></pre>

<hr>
<h2 id='get.signs'>
Signs of Colors of all Points for all Interactions
</h2><span id='topic+get.signs'></span>

<h3>Description</h3>

<p><code>get.signs</code> returns all the signs of colors for each point under all interactions up to depth <code>d</code> in marginal binary expansions for the tests <code>BET</code> and <code>BETs</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.signs(X, dep, unif.margin = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.signs_+3A_x">X</code></td>
<td>

<p>a matrix to be tested.
</p>
</td></tr>
<tr><td><code id="get.signs_+3A_dep">dep</code></td>
<td>

<p>depth of the marginal binary expansions.
</p>
</td></tr>
<tr><td><code id="get.signs_+3A_unif.margin">unif.margin</code></td>
<td>

<p>logicals. If <code>TRUE</code> the data has been uniformed based on empirical cumulative distribution function. Default to be <code>FALSE</code> and the function uniforms the data.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result is a dataframe with <code class="reqn">n</code> rows and <code class="reqn">2^(p*dep)</code> columns, where <code class="reqn">p</code> is the number of columns of <code>X</code> and <code class="reqn">n</code> is the number of rows of <code>X</code>. The values of <code class="reqn">1</code> or <code class="reqn">-1</code> stand for the sign of color, while the marginal interactions return <code class="reqn">0</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>v &lt;- runif(128, -pi, pi)
X1 &lt;- cos(v) + 2.5 * rnorm(128, 0, 1/20)
X2 &lt;- sin(v) + 2.5 * rnorm(128, 0, 1/20)
get.signs(cbind(X1, X2), 3)
</code></pre>

<hr>
<h2 id='MaxBET'>Binary Expansion Testing at a Certain Depth</h2><span id='topic+MaxBET'></span>

<h3>Description</h3>

<p><code>MaxBET</code> stands for Binary Expansion Testing. It is used for nonparametric detection of nonuniformity or dependence. It can be used to test whether a column vector is [0, 1]-uniformly distributed. It can also be used to detect dependence between columns of a matrix <code>X</code>, if <code>X</code> has more than one column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MaxBET(
  X,
  dep,
  unif.margin = FALSE,
  asymptotic = TRUE,
  plot = FALSE,
  index = list(c(1:ncol(X)))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MaxBET_+3A_x">X</code></td>
<td>
<p>a matrix to be tested. When <code>X</code> has only one column, <code>BET</code> will test whether <code>X</code> is [0, 1]-uniformly distributed (an error will be given if data is out of range [0, 1]). When <code>X</code> has two or more columns, <code>BET</code> tests the independence among those column vectors.</p>
</td></tr>
<tr><td><code id="MaxBET_+3A_dep">dep</code></td>
<td>
<p>depth of the binary expansion for the <code>BET</code>. </p>
</td></tr>
<tr><td><code id="MaxBET_+3A_unif.margin">unif.margin</code></td>
<td>

<p>logicals. If <code>TRUE</code> the marginal distribution is known to be Uniform[0,1]. Default is <code>FALSE</code>, and empirical cdf transformation will be applied to each marginal distribution.
</p>
</td></tr>
<tr><td><code id="MaxBET_+3A_asymptotic">asymptotic</code></td>
<td>

<p>logicals. If <code>TRUE</code> the p-value is computed by asymptotic distribution. Default to be <code>TRUE</code>. Ignored if <code>X</code> has three or more columns.
</p>
</td></tr>
<tr><td><code id="MaxBET_+3A_plot">plot</code></td>
<td>

<p>logicals. If <code>TRUE</code>, make the plot of cross interaction of the strongest asymmetry. Default to be <code>FALSE</code>. This option only works for X with two columns.
</p>
</td></tr>
<tr><td><code id="MaxBET_+3A_index">index</code></td>
<td>

<p>a list of indices. If provided, test the independence among two or more groups of variables. For example, <code>index = list(c(1,2), c(3)))</code> refers to test the independence between <code class="reqn">(X_1, X_2)</code> and <code class="reqn">X_3</code>. Default to be <code>list(c(1:p))</code>, where <code>p = ncol(X)</code>, then test data uniformity.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>MaxBET</code> tests the independence or uniformity by considering the maximal magnitude of the symmetry statistics in the <code class="reqn">sigma</code>-field generated from marginal binary expansions at the depth <code>d</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>Interaction</code></td>
<td>
<p>a dataframe with <code class="reqn">p</code> columns, where <code class="reqn">p</code> is the number of columns of <code>X</code>. It displays the interactions where the extreme symmetry statistics happens. For each column in <code>X</code>, we use a binary index to indicate binary variables involved in the extreme symmetry statistic.</p>
</td></tr>
<tr><td><code>Extreme.Asymmetry</code></td>
<td>
<p>the extreme asymmetry statistics.</p>
</td></tr>
<tr><td><code>p.value.bonf</code></td>
<td>
<p>p-value of the test with Bonferroni adjustment.</p>
</td></tr>
<tr><td><code>z.statistic</code></td>
<td>
<p>normal approximation of the test statistic.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>##test mutual independence
v &lt;- runif(128, -pi, pi)
X1 &lt;- cos(v) + 2.5 * rnorm(128, 0, 1/20)
X2 &lt;- sin(v) + 2.5 * rnorm(128, 0, 1/20)
MaxBET(cbind(X1, X2), 3, asymptotic = FALSE, index = list(1,2))

##test independence between (x1, x2) and y
x1 = runif(128)
x2 = runif(128)
y = sin(4*pi*(x1 + x2)) + 0.4*rnorm(128)
MaxBET(cbind(x1, x2, y), 3, index = list(c(1,2), c(3)))

##test uniformity
x1 = rbeta(128, 2, 4)
x2 = rbeta(128, 2, 4)
x3 = rbeta(128, 2, 4)
MaxBET(cbind(x1, x2, x3), 3)
</code></pre>

<hr>
<h2 id='MaxBETs'>Binary Expansion Testing up to a Certain Depth</h2><span id='topic+MaxBETs'></span>

<h3>Description</h3>

<p><code>MaxBETs</code> is used for nonparametric dependence detection.
Extended from <code>BET</code>, for a chosen maximal depth <code>d.max</code>, <code>MaxBETs</code> does a sequential test up to <code>d.max</code> and avoids overlapping symmetry statistics in different depths,
for all <code class="reqn">2 \le d \le d.max</code>. The adjustment is done by multiplying the number of interactions which are in the <code class="reqn">\sigma</code>-field generated by marginal binary expansions at depth <code class="reqn">d</code> but not in that at depth <code class="reqn">d-1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MaxBETs(
  X,
  d.max = 4,
  unif.margin = FALSE,
  asymptotic = TRUE,
  plot = FALSE,
  index = list(c(1:ncol(X)))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MaxBETs_+3A_x">X</code></td>
<td>
<p>a matrix to be tested. When <code>X</code> has only one column, <code>BETs</code> will test whether <code>X</code> is [0, 1]-uniformly distributed (an error will be given if data is out of range [0, 1]). When <code>X</code> has two or more columns, <code>BETs</code> tests the independence among those column vectors.</p>
</td></tr>
<tr><td><code id="MaxBETs_+3A_d.max">d.max</code></td>
<td>
<p>the maximal depth of the binary expansion for <code>BETs</code>.</p>
</td></tr>
<tr><td><code id="MaxBETs_+3A_unif.margin">unif.margin</code></td>
<td>

<p>logicals. If <code>TRUE</code> the marginal distribution is known to be Uniform[0,1]. Default is <code>FALSE</code>, and empirical cdf transformation will be applied to each marginal distribution.
</p>
</td></tr>
<tr><td><code id="MaxBETs_+3A_asymptotic">asymptotic</code></td>
<td>

<p>logicals. If <code>TRUE</code> the p-value is computed by asymptotic distribution. Default to be <code>TRUE</code>. Ignored if <code>X</code> has three or more columns.
</p>
</td></tr>
<tr><td><code id="MaxBETs_+3A_plot">plot</code></td>
<td>

<p>logicals. If <code>TRUE</code>, make the plot of cross interaction of the strongest asymmetry. Default to be <code>FALSE</code>. This option only works for X with two columns.
</p>
</td></tr>
<tr><td><code id="MaxBETs_+3A_index">index</code></td>
<td>

<p>a list of indices. If provided, test the independence among two or more groups of variables, for example, <code class="reqn">(X_1, X_2)</code> and <code class="reqn">X_3</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>bet.s.pvalue.bonf</code></td>
<td>
<p>the overall p-value on the test.</p>
</td></tr>
<tr><td><code>bet.s.index</code></td>
<td>
<p>the interaction that the p-value is minimal.</p>
</td></tr>
<tr><td><code>bet.s.zstatistic</code></td>
<td>
<p>normal approximation of the test statistic.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>##test mutual independence
v &lt;- runif(128, -pi, pi)
X1 &lt;- cos(v) + 2.5 * rnorm(128, 0, 1/20)
X2 &lt;- sin(v) + 2.5 * rnorm(128, 0, 1/20)
MaxBETs(cbind(X1, X2), 3, asymptotic = FALSE, index = list(1,2))

##test independence between (x1, x2) and y
x1 = runif(128)
x2 = runif(128)
y = sin(4*pi*(x1 + x2)) + 0.4*rnorm(128)
MaxBETs(cbind(x1, x2, y), 3, index = list(c(1,2), c(3)))

##test uniformity
x1 = rbeta(128, 2, 4)
x2 = rbeta(128, 2, 4)
x3 = rbeta(128, 2, 4)
MaxBETs(cbind(x1, x2, x3), 3)
</code></pre>

<hr>
<h2 id='star'>Coordinates of Brightest Stars in the Night Sky</h2><span id='topic+star'></span>

<h3>Description</h3>

<p>This data set collects the galactic coordinates of the 256 brightest stars in the night sky (Perryman et al. 1997). We consider the longitude (<code>x</code>) and sine latitude (<code>y</code>) here.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(star)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 256 rows and 2 columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(star)
MaxBETs(cbind(star$x.raw, star$y.raw), asymptotic = FALSE, plot = TRUE, index = list(1,2))
</code></pre>

<hr>
<h2 id='symm'>
Symmetry Statistics for all Interactions
</h2><span id='topic+symm'></span>

<h3>Description</h3>

<p><code>symm</code> returns all the symmetry statistics up to depth <code>d</code> in marginal binary expansions for the tests <code>BET</code> and <code>BETs</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>symm(
  X,
  dep,
  unif.margin = FALSE,
  print.sample.size = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="symm_+3A_x">X</code></td>
<td>

<p>a matrix to be tested.
</p>
</td></tr>
<tr><td><code id="symm_+3A_dep">dep</code></td>
<td>

<p>depth of the marginal binary expansions.
</p>
</td></tr>
<tr><td><code id="symm_+3A_unif.margin">unif.margin</code></td>
<td>

<p>logicals. If <code>TRUE</code> the data has been uniformed based on empirical cumulative distribution function. Default to be <code>FALSE</code> and the function uniforms the data.
</p>
</td></tr>
<tr><td><code id="symm_+3A_print.sample.size">print.sample.size</code></td>
<td>

<p>logicals. If <code>TRUE</code> print the sample size. Default to be <code>TRUE</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result is a dataframe with <code class="reqn">(p+2)</code> columns, where <code class="reqn">p</code> is the number of columns of <code>X</code>. The first column gives the binary index for all variables, the next <code class="reqn">p</code> columns displays all the interactions of respective variables, the last column of <code>Statistics</code> gives the respective symmetry statistic.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>v &lt;- runif(128, -pi, pi)
X1 &lt;- cos(v) + 2.5 * rnorm(128, 0, 1/20)
X2 &lt;- sin(v) + 2.5 * rnorm(128, 0, 1/20)
symm(cbind(X1, X2), 3)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
