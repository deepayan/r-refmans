<!DOCTYPE html><html><head><title>Help for package XRJulia</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {XRJulia}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#asServerObjectMethods'><p>Julia methods for asServerObject()</p></a></li>
<li><a href='#findJulia'><p>Find a Julia Executable</p></a></li>
<li><a href='#from_Julia-class'><p>Class for General Julia Composite Type Objects</p></a></li>
<li><a href='#functions'><p>Function Versions of Methods for Julia Interface evaluators.</p></a></li>
<li><a href='#juliaClassDef'><p>Information about a Julia Class</p></a></li>
<li><a href='#JuliaFunction-class'><p>Proxy Objects in R for Julia Functions</p></a></li>
<li><a href='#JuliaInterface-class'><p>An Interface to Julia</p></a></li>
<li><a href='#JuliaObject-class'><p>Proxy Objects in R for Julia Objects</p></a></li>
<li><a href='#juliaOptions'><p>Get and/or Set Internal Option Parameters in the Julia Evaluator</p></a></li>
<li><a href='#juliaVersion'><p>Get or test the Julia Version information</p></a></li>
<li><a href='#largeVectors'><p>Internal Computations for Large Vectors</p></a></li>
<li><a href='#noScalar'><p>Send a Non-scalar Version of an Object</p></a></li>
<li><a href='#proxyJuliaObjects'><p>Proxy Objects in R for Julia Objects</p></a></li>
<li><a href='#RJulia'><p>An Evaluator for the Julia Interface.</p></a></li>
<li><a href='#setJuliaClass'><p>Define a Proxy Julia Class (Composite Type)</p></a></li>
<li><a href='#XRjulia-package'>
<p>Structured Interface to Julia</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Structured Interface to Julia</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-05-01</td>
</tr>
<tr>
<td>Author:</td>
<td>John M. Chambers</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>John Chambers &lt;jmc@r-project.org&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A Julia interface structured according to the general
	     form described in package 'XR' and in the book "Extending R".</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, XR</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>Julia, v 1.0 or later</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-05-05 18:57:04 UTC; jmc</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-05-05 19:10:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='asServerObjectMethods'>Julia methods for asServerObject()</h2><span id='topic+asServerObjectMethods'></span><span id='topic+asServerObject+2CANY+2CJuliaObject-method'></span><span id='topic+asServerObject+2Carray+2CJuliaObject-method'></span><span id='topic+asServerObject+2Clist+2CJuliaObject-method'></span>

<h3>Description</h3>

<p>The default method for JuliaObject is modelled on the overall default
method in XR.
</p>
<p>For arrays, the method uses the reshape() function in Julia to create a suitable multi-way array.
</p>
<p>For &quot;plain&quot; lists, the method produces the Julia expression for a list or a dictionary;
with other attributes, uses the .RClass form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ANY,JuliaObject'
asServerObject(object, prototype)

## S4 method for signature 'array,JuliaObject'
asServerObject(object, prototype)

## S4 method for signature 'list,JuliaObject'
asServerObject(object, prototype)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asServerObjectMethods_+3A_object">object</code></td>
<td>
<p>The <span class="rlang"><b>R</b></span> object.</p>
</td></tr>
<tr><td><code id="asServerObjectMethods_+3A_prototype">prototype</code></td>
<td>
<p>The proxy for a prototype of the Julia object, supplied by the evaluator.</p>
</td></tr>
</table>

<hr>
<h2 id='findJulia'>Find a Julia Executable</h2><span id='topic+findJulia'></span>

<h3>Description</h3>

<p>This function looks for an executable Julia application in the local operating system.  The location can be prespecified by
setting environment variable <code>JULIA_BIN</code>; otherwise, the function looks in various conventional locations
and if that doesn't work, runs a shell command to look for <code>julia</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findJulia(test = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findJulia_+3A_test">test</code></td>
<td>
<p>Should the function test for the existence of the application.  Default <code>FALSE</code>. Calling with
<code>TRUE</code> is useful to bullet-proof examples or tests for the absence of Julia. If the test search succeeds,
the location is saved in environment variable <code>JULIA_BIN</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The location as a character string, unless <code>test</code> is <code>TRUE</code>, in which case success or failure
is returned, and the location found (or the empty string) is saved as the environment variable.
Note that in this case, <code>FALSE</code> is returned if the Julia package <code>JSON</code> has not been added.
</p>
<p>If <code>test</code> is <code>FALSE</code>, failure to find a Julia
in the current system is an error.
</p>


<h3>On Mac OS X</h3>

<p>Installing Julia in the usual way does not put the command line version in a
standard location, but instead in a folder under <code>/Applications</code>.
Assuming one wants to have Julia available from the command line,
creating a symbolic link to it in <code>/usr/local/bin</code> is a standard approach.
If the current version of Julia is <code>0.6</code>:
</p>
<p><code>sudo ln -s /Applications/Julia-0.6.app/Contents/Resources/julia/bin/julia /usr/local/bin/julia</code>
</p>
<p>If for some reason you did not want this to be available,  set the shell variable
<code>JULIA_BIN</code> to the first file in the command, the one in <code>/Applications</code>.
</p>

<hr>
<h2 id='from_Julia-class'>Class for General Julia Composite Type Objects</h2><span id='topic+from_Julia-class'></span>

<h3>Description</h3>

<p>The Julia side of the interface will return a general object from a composite type as an R
object of class &quot;from_Julia.  its Julia fields (converted to R objects) can be accessed by the <code>$</code>
operator.
</p>


<h3>Slots</h3>


<dl>
<dt><code>serverClass</code></dt><dd><p>the Julia type.</p>
</dd>
<dt><code>module</code></dt><dd><p>the Julia module, or &quot;&quot;</p>
</dd>
<dt><code>fields</code></dt><dd><p>the converted versioin of the Julia fields; these are accessed by the <code>$</code> operator.</p>
</dd>
</dl>

<hr>
<h2 id='functions'>Function Versions of Methods for Julia Interface evaluators.</h2><span id='topic+functions'></span><span id='topic+juliaSource'></span><span id='topic+juliaAddToPath'></span><span id='topic+juliaUsing'></span><span id='topic+juliaImport'></span><span id='topic+juliaSend'></span><span id='topic+juliaGet'></span><span id='topic+juliaPrint'></span><span id='topic+juliaEval'></span><span id='topic+juliaCommand'></span><span id='topic+juliaCall'></span><span id='topic+juliaSerialize'></span><span id='topic+juliaUnserialize'></span><span id='topic+juliaName'></span>

<h3>Description</h3>

<p>Function Versions of Methods for Julia Interface evaluators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>juliaSource(..., evaluator = RJulia())

juliaAddToPath(directory = "julia",
  package = utils::packageName(topenv(parent.frame())), pos = NA,
  evaluator = RJulia(.makeNew = FALSE), where = topenv(parent.frame()))

juliaUsing(module, evaluator)

juliaImport(..., evaluator)

juliaSend(object, evaluator = XR::getInterface(.JuliaInterfaceClass))

juliaGet(object, evaluator = XR::getInterface(.JuliaInterfaceClass))

juliaPrint(object, ..., evaluator = XRJulia::RJulia())

juliaEval(expr, ..., evaluator = XR::getInterface(.JuliaInterfaceClass))

juliaCommand(expr, ...,
  evaluator = XR::getInterface(.JuliaInterfaceClass))

juliaCall(expr, ..., evaluator = XR::getInterface(.JuliaInterfaceClass))

juliaSerialize(object, file, append = FALSE,
  evaluator = XR::getInterface(.JuliaInterfaceClass))

juliaUnserialize(file, all = FALSE,
  evaluator = XR::getInterface(.JuliaInterfaceClass))

juliaName(object)

juliaImport(..., evaluator)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="functions_+3A_...">...</code></td>
<td>
<p>arguments to the corresponding method for an evaluator object.</p>
</td></tr>
<tr><td><code id="functions_+3A_evaluator">evaluator</code></td>
<td>
<p>The evaluator object to use.  By default, and usually, the current evaluator
is used, and one is started if none has been.  But see the note under <code>juliaImport</code> for the load actions created in special cases.</p>
</td></tr>
<tr><td><code id="functions_+3A_directory">directory</code></td>
<td>
<p>the directory to add, defaults to &quot;julia&quot;</p>
</td></tr>
<tr><td><code id="functions_+3A_package">package</code>, <code id="functions_+3A_pos">pos</code></td>
<td>
<p>arguments to the method, usually omitted.</p>
</td></tr>
<tr><td><code id="functions_+3A_where">where</code></td>
<td>
<p>for the load action, omitted if called from a package source file.
Otherwise, must be the environment in which a load action can take place.</p>
</td></tr>
<tr><td><code id="functions_+3A_module">module</code></td>
<td>
<p>String identifying a Julia module.</p>
</td></tr>
<tr><td><code id="functions_+3A_object">object</code></td>
<td>
<p>A proxy in R for a Julia object.</p>
</td></tr>
<tr><td><code id="functions_+3A_expr">expr</code></td>
<td>
<p>A string that should be legal when parsed and evaluated in Julia.</p>
</td></tr>
<tr><td><code id="functions_+3A_file">file</code>, <code id="functions_+3A_append">append</code>, <code id="functions_+3A_all">all</code></td>
<td>
<p>Arguments to the evalutor's serialize and unserialize methods. See the reference,
Chapter 10.</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>juliaSource</code>: evaluate the file of Julia source.
</p>
</li>
<li> <p><code>juliaAddToPath</code>: adds the directory specified to the search path for Julia modules.
If called from the source directory of a package during installation, sets up
a load action for that package.  If you want to add the path to all
evaluators in <em>this</em> session, call the function before creating an evaluator.
Otherwise, the action applies only to the specified evaluator or,
by default, to the current evaluator.
</p>
</li>
<li> <p><code>juliaUsing</code>: the &quot;using&quot; form of Julia imports:  the module is imported with all exports exposed.
</p>
</li>
<li> <p><code>juliaImport</code>: adds the module information specified to the modules imported for future Julia evaluator objects.
</p>
<p>Add the module to the table of imports for Julia evaluators, and import it to the current evaluator
if there is one.
If called from the source directory of a package during installation, both <code>juliaImport</code>
and <code>juliaAddToPath()</code> set up
a load action for that package.  The functional versions, not the methods themselves, should
be called from package source files to ensure that the load actions are created.
Note that calling either function before any evaluator has been generated
will install that call as a setup action for all XRJulia evaluators.
</p>
</li>
<li> <p><code>juliaSend</code>: sends the <code>object</code> to Julia, converting it via methods for
<code><a href="XR.html#topic+asServerObject">asServerObject</a></code> and returns a proxy for the converted object.
</p>
</li>
<li> <p><code>juliaGet</code>: converts the proxy object that is its argument to an <span class="rlang"><b>R</b></span> object.
</p>
</li>
<li> <p><code>juliaPrint</code>: Print an object in Julia.  Either one object or several arguments as would
be given to the Eval() method.
</p>
</li>
<li> <p><code>juliaEval</code>: evaluates the <code>expr</code> string subsituting the arguments.  See the corresponding evaluator
method for details.
</p>
</li>
<li> <p><code>juliaCommand</code>: evaluates the <code>expr</code> string subsituting the arguments; used for a command that is not
an expression.
</p>
</li>
<li> <p><code>juliaCall</code>: call the function in Julia, with arguments given; expr is the string name of the function
</p>
</li>
<li> <p><code>juliaSerialize</code>: serialize the <code>object</code> in Julia
</p>
</li>
<li> <p><code>juliaUnserialize</code>: unserialize the file in Julia
</p>
</li>
<li> <p><code>juliaName</code>: return the name by which this proxy object was assigned in Julia
</p>
</li>
<li> <p><code>juliaImport</code>: Import a Julia module or add a directory to the Julia Search Path
If called from the source directory of a package during installation, both <code>juliaImport</code>
and <code>juliaAddToPath()</code> also set up
a load action for that package.  The functional versions, not the methods themselves, should
be called from package source files to ensure that the load actions are created.
</p>
</li></ul>

<hr>
<h2 id='juliaClassDef'>Information about a Julia Class</h2><span id='topic+juliaClassDef'></span>

<h3>Description</h3>

<p>The Julia class definition information is computed, and converted to R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>juliaClassDef(Class, module = "", ..., .ev = RJulia())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="juliaClassDef_+3A_class">Class</code>, <code id="juliaClassDef_+3A_module">module</code></td>
<td>
<p>Strings identifying the Julia composite type and optionally, the module containing it.</p>
</td></tr>
<tr><td><code id="juliaClassDef_+3A_...">...</code>, <code id="juliaClassDef_+3A_.ev">.ev</code></td>
<td>
<p>Don't supply these, <code>.ev</code> defaults to the current Julia interface evaluator.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the Julia definition of the specified class, optionally from the module.
</p>

<hr>
<h2 id='JuliaFunction-class'>Proxy Objects in R for Julia Functions</h2><span id='topic+JuliaFunction'></span><span id='topic+JuliaFunction-class'></span><span id='topic+initialize+2CJuliaFunction-method'></span>

<h3>Description</h3>

<p>A class and generator function for proxies in R for Julia functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>JuliaFunction(...)

## S4 method for signature 'JuliaFunction'
initialize(name, module = "", evaluator =
RJulia(, ...))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="JuliaFunction-class_+3A_name">name</code>, <code id="JuliaFunction-class_+3A_module">module</code></td>
<td>
<p>The name and module of the Julia function.</p>
</td></tr>
<tr><td><code id="JuliaFunction-class_+3A_evaluator">evaluator</code></td>
<td>
<p>The evaluator object to use.  By default, and usually, the current evaluator
is used, and one is started if none has been.</p>
</td></tr>
<tr><td><code id="JuliaFunction-class_+3A_...">...</code></td>
<td>
<p>For <code>RJulia</code>, the arguments as interpreted by the
initialize method, so typically <code>name</code> and optionally
<code>module</code>.  Remaining arguments are passed along to the next method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object from this class is an R function that is a proxy for a function in Julia. Calls to the R function evaluate
a call to the Julia function.  The arguments in the call are converted to equivalent Julia objects;
these typically include proxy objects for results previously computed through the XRJulia interface.
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code></dt><dd><p>the name of the server language function</p>
</dd>
<dt><code>module</code></dt><dd><p>the name of the module, if that needs to be imported</p>
</dd>
<dt><code>evaluatorClass</code></dt><dd><p>the class for the evaluator, by default and usually, <code><a href="#topic+JuliaInterface">JuliaInterface</a></code></p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>  if(findJulia(test = TRUE) ) {
    ## even so, the Julia may not be valid
    ## so we catch any errors in the example, mainly to keep CRAN quiet
    tryCatch( {set.seed(228)
      x &lt;- matrix(rnorm(1000),20,5)
      xm &lt;- juliaSend(x)
      juliaCommand("using LinearAlgebra")
      svdJ &lt;- JuliaFunction("svd")
      sxm &lt;- svdJ(xm)
      sxm
    }, error = function(e) message("Julia Example error: " ,e$message))}
</code></pre>

<hr>
<h2 id='JuliaInterface-class'>An Interface to Julia</h2><span id='topic+JuliaInterface-class'></span><span id='topic+JuliaInterface'></span>

<h3>Description</h3>

<p>The JuliaInterface class provides an evaluator for computations in Julia, following the structure
in the XR  package.  Proxy functions and classes allow use of the interface with no explicit
reference to the evaluator.  The function <code>RJulia()</code> returns an evaluator object.
</p>


<h3>Fields</h3>


<dl>
<dt><code>host</code></dt><dd><p>The remote host, as a character string.  By default this will be the local host, and initializing the evalutor
will set the field to &quot;localhost&quot;.</p>
</dd>
<dt><code>port</code></dt><dd><p>The port number for commuicating to Julia from this evalutor.
By default, the port is set by adding the evaluator number-1 to a base port number.
By default the base port is randomly chosen at package load time (this strategy may change).
</p>
<p>The port may be controlled in two ways.  If you know a good range or set of ports, it will
be preferrable to supply unique port values (integer) in the initialization call.
A less direct way is set the R option &quot;JuliaBasePort&quot;, which will then be used as the base port.
Since evaluator numbers are used to increment the port, the call to <code><a href="base.html#topic+options">options</a></code> should normally come before 
initializing the first Julia evaluator.</p>
</dd>
<dt><code>julia_bin</code></dt><dd><p>The location for an executable version of the Julia interpreter.  By default, this assumes there is a file named <code>"julia"</code>
on the command-line  search path.  If Julia is not usable from the command line or if you want to run with a different version, supply
the executable file name as this argument.  It is also possible to set the location for all evaluators by setting the shell variable
<code>JULIA_BIN</code> to this location <em>before</em> starting R.</p>
</dd>
<dt><code>connection</code></dt><dd><p>The connection object through which commands are sent to Julia.  Normally will be created by the initialization
of the evaluator.  Should only be supplied as a currently
open socket on which to communicate with the Julia interpreter.</p>
</dd>
<dt><code>serverWrapup</code></dt><dd><p>a vector of actions for the ServerEval to take after evaluation.  Used to clean up after special operations,
such as sending large objects to Julia.</p>
</dd>
<dt><code>largeObject</code></dt><dd><p>Vectors with length bigger than this will be handled specially.  See <a href="#topic+largeVectors">largeVectors</a>.  Default currently 1000.  To change this, call <code><a href="#topic+juliaOptions">juliaOptions</a>()</code>
to set option <code>largeObject</code>.</p>
</dd>
<dt><code>fileBase</code></dt><dd><p>a pattern for file names that the evaluator will use in Julia for various data transfer
and other purposes.  The evaluator appends &quot;_1&quot;, &quot;_2&quot;, etc.  To change this, call <code><a href="#topic+juliaOptions">juliaOptions</a>()</code>
to set option <code>fileBase</code>.  It is initiaized to an R tempfile with pattern <code>"Julia"</code>.</p>
</dd>
</dl>


<h3>Methods</h3>


<dl>
<dt><code>Import(module, ...)</code></dt><dd><p>Import the module.  The &quot;Interface&quot; method assumes a command &quot;import&quot; in the server
language and does not handle any extra arguments (e.g., for importing specific members).</p>
</dd>
<dt><code>initialize(...)</code></dt><dd><p>initializes the evaluator in a language-independent sense.</p>
</dd>
<dt><code>ProxyClassName(serverClass)</code></dt><dd><p>If there is a proxy class defined corresponding to this serverClass, return the name
of that class (typically pasted with the server langauge, separated by underscore).  If no
such class is defined, return NA.</p>
</dd>
<dt><code>ServerClassDef(Class, module, ...)</code></dt><dd><p>Individual interface packages will define this to return a named list or other object such that value$fields and value$methods are the server fields and methods, character vectors
of names or named objects whose elements give further information.  This default version
returns NULL, indicating that no metadata is available.</p>
</dd>
<dt><code>ServerEval(expr, key, get)</code></dt><dd><p>Must be defined by the server language interface: evaluates 'expr'(a text string).
If 'key' is an empty string, 'expr' is treated as a directive, with no defined value.
Otherwise, 'key' is a non-empty string, and the server
object should be assigned with this name. The value returned is the R result, which may
be an AssignedProxy() object. If 'get' is TRUE or the value judged simple enough,
it will be converted to an ordinary R object instead.</p>
</dd>
<dt><code>ServerRemove(key)</code></dt><dd><p>Should be defined by the server language interface:
The reference previously created for 'key' should be removed.
What happens has no effect on the client side; the intent is to potentially recover memory.</p>
</dd>
<dt><code>ServerTask(task, expr, key = "", get = NA)</code></dt><dd><p>Call the task operation in the Julia code for the interface; the arguments must
be the simple strings or logical value expected.</p>
</dd>
<dt><code>Source(filename)</code></dt><dd><p>Parse and evaluate the contents of the file.  This method is likely to be overriden for particular langauges
with a directive to include the contents of the file.  The 'XR' version reads the file and processes the entire contents
as a single string, newlines inserted between lines of the file.</p>
</dd>
<dt><code>Using(...)</code></dt><dd><p>The Julia &quot;using&quot; form of importing.  Arguments are module names.  All the exported
members of these modules will then be available, without prefix.</p>
</dd>
</dl>

<hr>
<h2 id='JuliaObject-class'>Proxy Objects in R for Julia Objects</h2><span id='topic+JuliaObject-class'></span><span id='topic+JuliaObject'></span>

<h3>Description</h3>

<p>This is a class for all proxy objects from a Julia class with an R proxy class definition.
Objects will normally be from a subclass of this class, for the specific Julia class.
</p>


<h3>Details</h3>

<p>Proxy objects returned from the Julia interface will be promoted to objects
from a specific R proxy class for their Julia class, if such a class has been defined.
</p>

<hr>
<h2 id='juliaOptions'>Get and/or Set Internal Option Parameters in the Julia Evaluator</h2><span id='topic+juliaOptions'></span>

<h3>Description</h3>

<p>The Julia code for an evaluator maintains a dictionary, <code>RJuliaParams</code>, of named parameters used to control
various evaluation details.  These and any other desired options can be queried and/or set by calls to <code>juliaOptions</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>juliaOptions(..., .ev = XRJulia::RJulia())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="juliaOptions_+3A_...">...</code></td>
<td>
<p>arguments to the corresponding method for an evaluator object.</p>
</td></tr>
<tr><td><code id="juliaOptions_+3A_.ev">.ev</code></td>
<td>
<p>The evaluator object to use.  By default, and usually, the current evaluator.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function behaves essentially like the <code><a href="base.html#topic+options">options</a>()</code> function in R itself, returning a list of the current entries
corresponding to unnamed character arguments and setting the parameters named to the value in the corresponding named argument
to <code>juliaOptions</code>.
If no parameter corresponding to a name has been set, requesting the corresponding returned value is <code>nothing</code>, <code>NULL</code> in R.
</p>


<h3>Value</h3>

<p>A named list of those parameters requested (as unnamed character string arguments).  If none, an empty list.
Note that options are always returned converted to R, not as proxyies.
</p>

<hr>
<h2 id='juliaVersion'>Get or test the Julia Version information</h2><span id='topic+juliaVersion'></span>

<h3>Description</h3>

<p>The Julia constant structure <code>VERSION</code> is returned.
If <code>test</code> is <code>TRUE</code>, only returns a logical testing whether
this version is compatible with <code>XRJulia</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>juliaVersion(test = FALSE, .ev = RJulia())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="juliaVersion_+3A_test">test</code></td>
<td>
<p>If <code>TRUE</code>, tests compatibility
(currently that the major number is at least <code>1</code>). Default <code>FALSE</code></p>
</td></tr>
<tr><td><code id="juliaVersion_+3A_.ev">.ev</code></td>
<td>
<p>The evaluator object to use.  By default, and usually, the current evaluator.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with the
members of the Julia object, the usually relevant ones being <code>"major"</code>, <code>"minor"</code> and 
<code>"patch"</code>. <code>test=TRUE</code> overrides as described.
</p>

<hr>
<h2 id='largeVectors'>Internal Computations for Large Vectors</h2><span id='topic+largeVectors'></span>

<h3>Description</h3>

<p>Internal Computations for Large Vectors
</p>


<h3>Sending Large Vectors between R and Julia</h3>

<p>Large vectors will be slow to transfer as JSON, and may fail in Julia.  Internal computations have
been added to transfer vectors of types real, integer, logical and character by more direct
computations when they are large.  The computations and their implementation are
described here.
</p>
<p>R and Julia both have the concept of numeric (floating point) and integer arrays whose elements have a consistent type and both implement
these (following Fortran) as contiguous blocks in memory, augmented by length or dimension information.
They also both have a mechanism for arrays of character strings, class <code>"character"</code> in R and array type
<code>Array{String, 1}</code> in Julia.
Julia has arrays for boolean data; R stores the corresponding <code>logical</code> as integers.
</p>
<p>JSON has no such concepts, so interface evaluators using the standard JSON form provided by 'XR' must send such data as a JSON list.  This will
become inefficient for very large data from these classes.  Users have reported failure by Julia to
parse the corresponding JSON.
</p>
<p>The 'XRJulia' package (as of version 0.7.9) implements special code to send vectors to Julia, by
writing an intermediate file that Julia reads.  The actual text sent to Julia is a call to the
relevant Julia function.  The code is triggered within the methods for the <code>asServerObject</code>
function, so vectors should be transferred this way whether on their own or as part of a larger structure,
such as an array or the column of a data frame.
</p>
<p>Similarly, large arrays to be retrieved in R by the <code>Get()</code> method or the optional argument <code>.get = TRUE</code>
will be written to an intermediate file by Julia and read by R.
</p>
<p>As vectors become large, direct transfer becomes <em>much</em> faster.  On a not-very-powerful laptop,
vectors of length <code>10^7</code> transfer in an elapsed time of a few seconds.  Character vectors are slightly
slower than numeric, as explained below, but in all cases it would be hard to do much computation with
the data that did not swamp the cost of transfer.  That said, as always it's more sensible to transfer
data once and then use the corresponding proxy object in later calls.
</p>


<h3>Details</h3>

<p>For all vectors, the method uses binary writes and reads, which are defined
in both R and Julia.  No special computationss are needed for numeric, integer, complex and raw.
For these, the R binary representation corresponds to array types in Julia.
The special pseudo-value <code>NA</code> is defined for vectors in R, but no corresponding concept exists
in Julia.  For numeric and complex vectors, the floating-point pattern <code>NaN</code> is used.
For all other vectors, a warning is issued and either a numeric object or a special character string is used instead.
</p>
<p>For logicals, the internal representation in R uses integers.
The Julia code when data is sent from R casts the integer array to a boolean array.
On the return side, the Julia boolean array is converted to integer before writing.
</p>
<p>Character vectors take a little more work, partly because of a weirdness in binary writes
for string arrays in Julia.  Where R character vectors can be written in binary form and then read
back in, writing a <code>String</code> array in Julia omits the end-of-string character,
effectively writing a single string, from which the array cannot
be recovered.  Communicating the entire vector to Julia requires
that the Julia side uses this information to split the single string resulting from the R binary write
by matching the end-of-string character explicitly
For sending back to R, the Julia code
appends an end-of-string character to each string before writing the array to a file.  This produces the
R format for a binary read of a character vector.
</p>
<p>Two fields in the evaluator object control details.
A large object is defined as a vector of length greater than the integer field <code>largeObject</code>.
Julia creates intermediate files for sending large arrays to R by appending sequenctial numbers to a
character field <code>fileBase</code>.  By default, <code>largeObject</code> and  <code>fileBase</code> is obtained from
<code><a href="base.html#topic+tempfile">tempfile</a>()</code> with pattern <code>"Julia"</code>. Note that all the files are removed at the end of
the evaluation of the expression sending or getting the relevant objects.
</p>
<p>Since these fields must be known to the Julia evaluator, they should <em>not</em> be set directly&mdash;this will
have no effect.  Instead call the function <code><a href="#topic+juliaOptions">juliaOptions</a>()</code> with these parameter names.
</p>

<hr>
<h2 id='noScalar'>Send a Non-scalar Version of an Object</h2><span id='topic+noScalar'></span>

<h3>Description</h3>

<p>Ensures that an object is interpreted as a vector (array) when sent to the server language.
The default strategy is to send length-1 vectors as scalars.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>noScalar(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="noScalar_+3A_object">object</code></td>
<td>
<p>A vector object.  Calling with a non-vector is an error.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the object, but with the S4 bit turned on.
Relies on the convention that XR interfaces leave S4 objects
as vectors, not scalars, even when they are of length 1
</p>


<h3>References</h3>

<p>Chambers, John M. (2016)
<em>Extending R</em>,
Chapman &amp; Hall/CRC.
( Chapter 12, discussing this package, is included in the package: <a href="../doc/Chapter_XR.pdf">../doc/Chapter_XR.pdf</a>.)
</p>

<hr>
<h2 id='proxyJuliaObjects'>Proxy Objects in R for Julia Objects</h2><span id='topic+proxyJuliaObjects'></span>

<h3>Description</h3>

<p>Proxy Objects in R for Julia Objects
</p>

<hr>
<h2 id='RJulia'>An Evaluator for the Julia Interface.</h2><span id='topic+RJulia'></span>

<h3>Description</h3>

<p>Returns an evaluator for the Julia interface.  Starts one on the first call, or if arguments are provided;
providing argument <code>.makeNew = TRUE</code> will force a new evaluator.  Otherwise, the current evaluator is
returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RJulia(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RJulia_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="XR.html#topic+getInterface">getInterface</a>()</code> but none usually required.
See <code><a href="#topic+JuliaInterface">JuliaInterface</a></code> for details of the evaluator.</p>
</td></tr>
</table>

<hr>
<h2 id='setJuliaClass'>Define a Proxy Julia Class (Composite Type)</h2><span id='topic+setJuliaClass'></span>

<h3>Description</h3>

<p>Given the name and optionally the module for a Julia composite type, defines an R proxy
class with the same fields as the Julia type.  By default, uses metadata from Julia to
find the fields.  If the call supplies the desired field names explicitly, metadata is
not used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setJuliaClass(juliaType, module = "", fields = character(),
  where = topenv(parent.frame()), proxyObjectClass = "JuliaObject",
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setJuliaClass_+3A_juliatype">juliaType</code>, <code id="setJuliaClass_+3A_module">module</code></td>
<td>
<p>Strings identifying the composite type and optionally the module containing it. In normal use,
metadata from Julia is used to find the definition of the type.</p>
</td></tr>
<tr><td><code id="setJuliaClass_+3A_fields">fields</code>, <code id="setJuliaClass_+3A_where">where</code>, <code id="setJuliaClass_+3A_proxyobjectclass">proxyObjectClass</code>, <code id="setJuliaClass_+3A_...">...</code></td>
<td>
<p>Overriding arguments that should not be used by direct calls from package source code.</p>
</td></tr>
</table>

<hr>
<h2 id='XRjulia-package'>
Structured Interface to Julia
</h2><span id='topic+XRjulia-package'></span><span id='topic+XRjulia'></span>

<h3>Description</h3>

<p>A Julia interface structured according to the general
form described in package XR and the book &quot;Extending R&quot;.
</p>


<h3>Author(s)</h3>

<p>John Chambers
</p>
<p>Maintainer: John Chambers &lt;jmc@stat.stanford.edu&gt;
</p>


<h3>References</h3>

<p>Chambers, John M.
<em>Extending R</em> Chapman &amp; Hall/CRC 2016.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
