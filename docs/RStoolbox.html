<!DOCTYPE html><html><head><title>Help for package RStoolbox</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RStoolbox}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#classifyQA'><p>Classify Landsat QA bands</p></a></li>
<li><a href='#cloudMask'><p>Simple Cloud Detection</p></a></li>
<li><a href='#cloudShadowMask'><p>Cloud Shadow Masking for Flat Terrain</p></a></li>
<li><a href='#coregisterImages'><p>Image to Image Co-Registration based on Mutual Information</p></a></li>
<li><a href='#decodeQA'><p>Decode QA flags to bit-words</p></a></li>
<li><a href='#encodeQA'><p>Encode QA Conditions to Integers</p></a></li>
<li><a href='#estimateHaze'><p>Estimate Image Haze for Dark Object Subtraction (DOS)</p></a></li>
<li><a href='#fCover'><p>Fractional Cover Analysis</p></a></li>
<li><a href='#fortifySpatRaster'><p>Fortify method for classes from the terra package.</p></a></li>
<li><a href='#getMeta'><p>Extract bandwise information from ImageMetaData</p></a></li>
<li><a href='#getValidation'><p>Extract validation results from superClass objects</p></a></li>
<li><a href='#ggR'><p>Plot RasterLayers in ggplot with greyscale</p></a></li>
<li><a href='#ggRGB'><p>Create ggplot2 Raster Plots with RGB from 3 RasterLayers</p></a></li>
<li><a href='#histMatch'><p>Image to Image Contrast Matching</p></a></li>
<li><a href='#ImageMetaData'><p>ImageMetaData Class</p></a></li>
<li><a href='#lsat'><p>Landsat 5TM Example Data</p></a></li>
<li><a href='#mesma'><p>Multiple Endmember Spectral Mixture Analysis (Spectral Unmixing)</p></a></li>
<li><a href='#normImage'><p>Normalize Raster Images: Center and Scale</p></a></li>
<li><a href='#oneHotEncode'><p>One-hot encode a raster or vector</p></a></li>
<li><a href='#panSharpen'><p>Pan Sharpen Imagery / Image Fusion</p></a></li>
<li><a href='#pifMatch'><p>Pseudo-Invariant Features based Image Matching</p></a></li>
<li><a href='#predict.unsuperClass'><p>Predict a raster map based on a unsuperClass model fit.</p></a></li>
<li><a href='#radCor'><p>Radiometric Calibration and Correction</p></a></li>
<li><a href='#rasterCVA'><p>Change Vector Analysis</p></a></li>
<li><a href='#rasterEntropy'><p>Multi-layer Pixel Entropy</p></a></li>
<li><a href='#rasterPCA'><p>Principal Component Analysis for Rasters</p></a></li>
<li><a href='#readEE'><p>Tidy import tool for EarthExplorer .csv export files</p></a></li>
<li><a href='#readMeta'><p>Read Landsat MTL metadata files</p></a></li>
<li><a href='#readSLI'><p>Read ENVI spectral libraries</p></a></li>
<li><a href='#rescaleImage'><p>Linear Image Rescaling</p></a></li>
<li><a href='#rlogo'><p>Rlogo as SpatRaster</p></a></li>
<li><a href='#rsOpts'><p>Set global options for RStoolbox</p></a></li>
<li><a href='#RStoolbox'><p>RStoolbox: A Collection of Remote Sensing Tools</p></a></li>
<li><a href='#sam'><p>Spectral Angle Mapper</p></a></li>
<li><a href='#saveRSTBX'><p>Save and Read RStoolbox Classification Results</p></a></li>
<li><a href='#spectralIndices'><p>Spectral Indices</p></a></li>
<li><a href='#srtm'><p>SRTM Digital Elevation Model</p></a></li>
<li><a href='#stackMeta'><p>Import separate Landsat files into single stack</p></a></li>
<li><a href='#superClass'><p>Supervised Classification</p></a></li>
<li><a href='#tasseledCap'><p>Tasseled Cap Transformation</p></a></li>
<li><a href='#topCor'><p>Topographic Illumination Correction</p></a></li>
<li><a href='#unsuperClass'><p>Unsupervised Classification</p></a></li>
<li><a href='#validateMap'><p>Map accuracy assessment</p></a></li>
<li><a href='#writeSLI'><p>Write ENVI spectral libraries</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Remote Sensing Data Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Toolbox for remote sensing image processing and analysis such as
    calculating spectral indexes, principal component transformation, unsupervised
    and supervised classification or fractional cover analyses.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://bleutner.github.io/RStoolbox/">https://bleutner.github.io/RStoolbox/</a>,
<a href="https://github.com/bleutner/RStoolbox">https://github.com/bleutner/RStoolbox</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/bleutner/RStoolbox/issues">https://github.com/bleutner/RStoolbox/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>caret (&ge; 6.0-79), sf, terra, XML, dplyr, ggplot2, tidyr,
reshape2, lifecycle, exactextractr, Rcpp, methods, magrittr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>randomForest, kernlab, e1071, gridExtra, pls, testthat</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-17 03:30:17 UTC; Konstantin</td>
</tr>
<tr>
<td>Author:</td>
<td>Benjamin Leutner <a href="https://orcid.org/0000-0002-6893-2002"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Ned Horning [aut],
  Jakob Schwalb-Willmann
    <a href="https://orcid.org/0000-0003-2665-1509"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Robert J. Hijmans <a href="https://orcid.org/0000-0001-5872-2872"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Konstantin Mueller
    <a href="https://orcid.org/0000-0001-6540-3124"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Konstantin Mueller &lt;konstantinfinn.mueller@gmx.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-17 18:52:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling 'rhs(lhs)'.
</p>

<hr>
<h2 id='classifyQA'>Classify Landsat QA bands</h2><span id='topic+classifyQA'></span>

<h3>Description</h3>

<p>extracts five classes from QA band: background, cloud, cirrus, snow and water.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classifyQA(
  img,
  type = c("background", "cloud", "cirrus", "snow", "water"),
  confLayers = FALSE,
  sensor = "OLI",
  legacy = "collection1",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="classifyQA_+3A_img">img</code></td>
<td>
<p>RasterLayer or SpatRaster. Landsat 8 OLI QA band.</p>
</td></tr>
<tr><td><code id="classifyQA_+3A_type">type</code></td>
<td>
<p>Character. Classes which should be returned. One or more of c(&quot;background&quot;, &quot;cloud&quot;, &quot;cirrus&quot;,&quot;snow&quot;, &quot;water&quot;).</p>
</td></tr>
<tr><td><code id="classifyQA_+3A_conflayers">confLayers</code></td>
<td>
<p>Logical. Return one layer per class classified by confidence levels, i.e. cloud:low, cloud:med, cloud:high.</p>
</td></tr>
<tr><td><code id="classifyQA_+3A_sensor">sensor</code></td>
<td>
<p>Sensor to encode. Options: <code>c("OLI", "TIRS", "ETM+", "TM", "MSS")</code>.</p>
</td></tr>
<tr><td><code id="classifyQA_+3A_legacy">legacy</code></td>
<td>
<p>Encoding systematic Options: <code>c("collection1", "pre_collection")</code>. Default is &quot;collection1&quot; for the Landsat Collection 1 8-bit quality designations. Use &quot;pre_collection&quot; for imagery downloaded before the Collection 1 quality designations were introduced</p>
</td></tr>
<tr><td><code id="classifyQA_+3A_...">...</code></td>
<td>
<p>further arguments passed to <a href="terra.html#topic+writeRaster">writeRaster</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default each class is queried for *high* confidence. See <a href="#topic+encodeQA">encodeQA</a> for details. To return the different confidence levels per condition use <code>confLayers=TRUE</code>.
This approach corresponds to the way LandsatLook Quality Images are produced by the USGS.
</p>


<h3>Value</h3>

<p>Returns a SpatRaster with maximal five classes:
</p>

<table>
<tr>
 <td style="text-align: right;">
class </td><td style="text-align: right;"> value </td>
</tr>
<tr>
 <td style="text-align: right;">
background </td><td style="text-align: right;"> 1L </td>
</tr>
<tr>
 <td style="text-align: right;"> 
cloud  </td><td style="text-align: right;"> 2L </td>
</tr>
<tr>
 <td style="text-align: right;">
cirrus </td><td style="text-align: right;"> 3L </td>
</tr>
<tr>
 <td style="text-align: right;">
snow   </td><td style="text-align: right;"> 4L </td>
</tr>
<tr>
 <td style="text-align: right;">
water  </td><td style="text-align: right;"> 5L </td>
</tr>
<tr>
 <td style="text-align: right;"> 
</td>
</tr>

</table>

<p>Values outside of these classes are returned as NA.
If <code>confLayers = TRUE</code> then a RasterStack with one layer per condition (except 'background') is returned, whereby each layer contains the confidence level of the condition.
</p>

<table>
<tr>
 <td style="text-align: right;">
Confidence </td><td style="text-align: right;"> value </td>
</tr>
<tr>
 <td style="text-align: right;">
low    </td><td style="text-align: right;"> 1L </td>
</tr>
<tr>
 <td style="text-align: right;">
med    </td><td style="text-align: right;"> 2L </td>
</tr>
<tr>
 <td style="text-align: right;">
high   </td><td style="text-align: right;"> 3L </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>



<h3>See Also</h3>

<p><a href="#topic+encodeQA">encodeQA</a> <a href="#topic+decodeQA">decodeQA</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)
qa &lt;- rast(ncol = 100, nrow=100, val = sample(1:2^14,  10000))

## QA classes
qacs &lt;- classifyQA(img = qa)
## Confidence levels
qacs_conf &lt;- classifyQA(img = qa, confLayers = TRUE)
</code></pre>

<hr>
<h2 id='cloudMask'>Simple Cloud Detection</h2><span id='topic+cloudMask'></span>

<h3>Description</h3>

<p>Developed for use with Landsat data <code>cloudMask</code> relies on the distinctive difference between the blue (or any other short-wave band) 
and thermal band for semi-automated creation of a cloud mask. Since it relies on thermal information it doesn't work well for sensors without
thermal bands.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cloudMask(
  x,
  threshold = 0.2,
  blue = "B1_sre",
  tir = "B6_sre",
  buffer = NULL,
  plot = FALSE,
  verbose
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cloudMask_+3A_x">x</code></td>
<td>
<p>RasterBrick or RasterStack or SpatRaster with reflectance and brightness temperature OR the mask of a previous run of <code>cloudMask</code> with <code>returnDiffLayer=TRUE</code>.</p>
</td></tr>
<tr><td><code id="cloudMask_+3A_threshold">threshold</code></td>
<td>
<p>Numeric. cloud detection threshold. If not provided it will be guessed. Everything *below* this threshold will be considered a cloud pixel (unless it is removed by filtering afterwards).</p>
</td></tr>
<tr><td><code id="cloudMask_+3A_blue">blue</code></td>
<td>
<p>Character or integer. Bandname or number for the blue band</p>
</td></tr>
<tr><td><code id="cloudMask_+3A_tir">tir</code></td>
<td>
<p>Character or integer. Bandname or number for the thermal band</p>
</td></tr>
<tr><td><code id="cloudMask_+3A_buffer">buffer</code></td>
<td>
<p>Integer. Number of pixels to use as a buffer that will be added to the identified cloud centers.</p>
</td></tr>
<tr><td><code id="cloudMask_+3A_plot">plot</code></td>
<td>
<p>Logical. Plots of the cloud mask for all sub-steps (sanitizing etc.) Helpful to find proper parametrization.</p>
</td></tr>
<tr><td><code id="cloudMask_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Print messages or suppress.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a SpatRaster with two layers: CMASK contains the binary cloud mask (1 = cloud, NA = not-cloud) and NDTCI contains the cloud index.
</p>


<h3>Note</h3>

<p>Typically clouds are cold in the thermal region and have high reflectance in short wavelengths (blue). By calculating a normalized difference index between the two bands and thresholding a rough cloud mask can be obtained.
Before calculating the spectral cloud index (let's call it Normalized Difference Thermal Cloud Index (NDTCI)) the thermal band will be matched to the same value range as the blue band. Therefore, it doesn't matter whether you
provide DN, radiance or brightness temperature.
</p>
<p>This approach to cloud masking is very simplistic. And aims only at rough removal of potentially clouded areas. Nevertheless, it is able to provide satisfactory results. 
More sophisticated approaches, including cloud cast shadow detection can be found elsewhere, e.g. <a href="https://code.google.com/archive/p/fmask">fmask</a>.
</p>
<p>It can make sense to find a suitable threshold on a cropped version of the scene. Also make sure you make use of the <code>returnDiffLayer</code> argument to save yourself one processing step.
Buffering should be seen as final polishing, i.e. as long as the pure cloud centers are not detected properly, you might want to turn it off. since it takes some time to calculate.
Once your mask detects obvious cloud pixels properly re-enable buffering for fine tuning if desired. Finally, once a suitable threshold is established re-run cloudMask on the whole scene with this threshold and go get a coffee.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cloudShadowMask">cloudShadowMask</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
## Import Landsat example subset
## We have two tiny clouds in the east
ggRGB(lsat, stretch = "lin")

## Calculate cloud index
cldmsk    &lt;- cloudMask(lsat, blue = 1, tir = 6)
ggR(cldmsk, 2, geom_raster = TRUE) 

## Define threshold (re-use the previously calculated index)
## Everything above the threshold is masked
## In addition we apply a region-growing around the core cloud pixels
cldmsk_final &lt;- cloudMask(cldmsk, threshold = 0.1, buffer = 5) 

## Plot cloudmask 
ggRGB(lsat, stretch = "lin") +
   ggR(cldmsk_final[[1]], ggLayer = TRUE, forceCat = TRUE, geom_raster = TRUE) +
   scale_fill_manual(values = c("red"), na.value = NA)

#' ## Estimate cloud shadow displacement
## Interactively (click on cloud pixels and the corresponding shadow pixels)
## Not run:  shadow &lt;- cloudShadowMask(lsat, cldmsk_final, nc = 2) 

## Non-interactively. Pre-defined shadow displacement estimate (shiftEstimate)
shadow &lt;- cloudShadowMask(lsat, cldmsk_final, shiftEstimate = c(-16,-6))

## Plot
csmask &lt;- terra::merge(cldmsk_final[[1]], shadow)
ggRGB(lsat, stretch = "lin") +
        ggR(csmask, ggLayer = TRUE, forceCat = TRUE, geom_raster = TRUE) +
        scale_fill_manual(values = c("blue", "yellow"), 
        labels = c("shadow", "cloud"), na.value = NA)

</code></pre>

<hr>
<h2 id='cloudShadowMask'>Cloud Shadow Masking for Flat Terrain</h2><span id='topic+cloudShadowMask'></span>

<h3>Description</h3>

<p>Intended for interactive use, <code>cloudShadowMask</code> will ask the user to select a few 
corresponding cloud/cloudShadow pixels which will be used to estimate coordinates 
for a linear cloudmask shift.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cloudShadowMask(
  img,
  cm,
  nc = 5,
  shiftEstimate = NULL,
  preciseShift = NULL,
  quantile = 0.2,
  returnShift = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cloudShadowMask_+3A_img">img</code></td>
<td>
<p>SpatRaster containing the scene</p>
</td></tr>
<tr><td><code id="cloudShadowMask_+3A_cm">cm</code></td>
<td>
<p>SpatRaster. Cloud mask (typically the result of <code><a href="#topic+cloudMask">cloudMask</a></code>)</p>
</td></tr>
<tr><td><code id="cloudShadowMask_+3A_nc">nc</code></td>
<td>
<p>Integer. Number of control points. A few points (default) are fine because the final shift is estimated by <a href="#topic+coregisterImages">coregisterImages</a>.</p>
</td></tr>
<tr><td><code id="cloudShadowMask_+3A_shiftestimate">shiftEstimate</code></td>
<td>
<p>NULL or numeric vector of length two (x,y). Estimated displacement of shadows in map units. If <code>NULL</code>, the user will be asked to select control points interactively.</p>
</td></tr>
<tr><td><code id="cloudShadowMask_+3A_preciseshift">preciseShift</code></td>
<td>
<p>NULL or numeric vector of length two (x,y). Use this if cloud/cloud-shadow displacement is already known, e.g. from a previous run of <code>cloudShadowMask</code>.</p>
</td></tr>
<tr><td><code id="cloudShadowMask_+3A_quantile">quantile</code></td>
<td>
<p>Numeric (between 0 and 1). Quantile threshold used for image co-registration. By default the 20% quantile of the total intensity (sum) of the image is used as potential shadow mask.</p>
</td></tr>
<tr><td><code id="cloudShadowMask_+3A_returnshift">returnShift</code></td>
<td>
<p>Logical. Return a numeric vector containing the shift parameters. Useful if you estimate parameters on a subset of the image.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a very simplistic approach to cloud shadow masking (simple shift of the cloud mask). It is not image based and accuracy will suffer from clouds at different altitudes. However, just as cloudMask
this is a quick and easy to use tool for Landsat data if you're just working on a few scenes and don't have fMask or CDR data at hand. Although for some test scenes
it does perform surprisingly well.
</p>


<h3>Value</h3>

<p>Returns a RasterLayer with the cloud shadow mask (0 = shadow, NA = not-shadow).
</p>


<h3>See Also</h3>

<p><a href="#topic+cloudMask">cloudMask</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
## Import Landsat example subset
## We have two tiny clouds in the east
ggRGB(lsat, stretch = "lin")

## Calculate cloud index
cldmsk    &lt;- cloudMask(lsat, blue = 1, tir = 6)
ggR(cldmsk, 2, geom_raster = TRUE) 

## Define threshold (re-use the previously calculated index)
## Everything above the threshold is masked
## In addition we apply a region-growing around the core cloud pixels
cldmsk_final &lt;- cloudMask(cldmsk, threshold = 0.1, buffer = 5) 

## Plot cloudmask 
ggRGB(lsat, stretch = "lin") +
   ggR(cldmsk_final[[1]], ggLayer = TRUE, forceCat = TRUE, geom_raster = TRUE) +
   scale_fill_manual(values = c("red"), na.value = NA)

#' ## Estimate cloud shadow displacement
## Interactively (click on cloud pixels and the corresponding shadow pixels)
## Not run:  shadow &lt;- cloudShadowMask(lsat, cldmsk_final, nc = 2) 

## Non-interactively. Pre-defined shadow displacement estimate (shiftEstimate)
shadow &lt;- cloudShadowMask(lsat, cldmsk_final, shiftEstimate = c(-16,-6))

## Plot
csmask &lt;- terra::merge(cldmsk_final[[1]], shadow)
ggRGB(lsat, stretch = "lin") +
        ggR(csmask, ggLayer = TRUE, forceCat = TRUE, geom_raster = TRUE) +
        scale_fill_manual(values = c("blue", "yellow"), 
        labels = c("shadow", "cloud"), na.value = NA)

</code></pre>

<hr>
<h2 id='coregisterImages'>Image to Image Co-Registration based on Mutual Information</h2><span id='topic+coregisterImages'></span>

<h3>Description</h3>

<p>Shifts an image to match a reference image. Matching is based on maximum
mutual information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coregisterImages(
  img,
  ref,
  shift = 3,
  shiftInc = 1,
  nSamples = 100,
  reportStats = FALSE,
  verbose,
  nBins = 100,
  master = deprecated(),
  slave = deprecated(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coregisterImages_+3A_img">img</code></td>
<td>
<p>SpatRaster or SpatRaster. Image to shift to match reference image. <code>img</code> and <code>ref</code> must have equal numbers of bands.</p>
</td></tr>
<tr><td><code id="coregisterImages_+3A_ref">ref</code></td>
<td>
<p>SpatRaster or SpatRaster. Reference image. <code>img</code> and <code>ref</code> must have equal numbers of bands.</p>
</td></tr>
<tr><td><code id="coregisterImages_+3A_shift">shift</code></td>
<td>
<p>Numeric or matrix. If numeric, then shift is the maximal absolute radius (in pixels of <code>img</code> resolution) which <code>img</code> is shifted (<code>seq(-shift, shift, by=shiftInc)</code>). 
If shift is a matrix it must have two columns (x shift and y shift), then only these shift values will be tested.</p>
</td></tr>
<tr><td><code id="coregisterImages_+3A_shiftinc">shiftInc</code></td>
<td>
<p>Numeric. Shift increment (in pixels, but not restricted to integer). Ignored if <code>shift</code> is a matrix.</p>
</td></tr>
<tr><td><code id="coregisterImages_+3A_nsamples">nSamples</code></td>
<td>
<p>Integer. Number of samples to calculate mutual information.</p>
</td></tr>
<tr><td><code id="coregisterImages_+3A_reportstats">reportStats</code></td>
<td>
<p>Logical. If <code>FALSE</code> it will return only the shifted images. Otherwise it will return the shifted image in a list containing stats such as mutual information per shift and joint histograms.</p>
</td></tr>
<tr><td><code id="coregisterImages_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Print status messages. Overrides global RStoolbox.verbose option.</p>
</td></tr>
<tr><td><code id="coregisterImages_+3A_nbins">nBins</code></td>
<td>
<p>Integer. Number of bins to calculate joint histogram.</p>
</td></tr>
<tr><td><code id="coregisterImages_+3A_master">master</code></td>
<td>
<p>DEPRECATED! Argument was renamed. Please use <code>ref</code> from now on.</p>
</td></tr>
<tr><td><code id="coregisterImages_+3A_slave">slave</code></td>
<td>
<p>DEPRECATED! Argument was renamed. Please use <code>img</code> from now on.</p>
</td></tr>
<tr><td><code id="coregisterImages_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="terra.html#topic+writeRaster">writeRaster</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently only a simple linear x - y shift is considered and tested. No higher order shifts (e.g. rotation, non-linear transformation) are performed. This means that your imagery
should already be properly geometrically corrected.
</p>
<p><a href="https://en.wikipedia.org/wiki/Mutual_information">Mutual information</a> is a similarity metric originating from information theory.
Roughly speaking, the higher the mutual information of two data-sets, the higher is their shared information content, i.e. their similarity.
When two images are exactly co-registered their mutual information is maximal. By trying different image shifts, we aim to find the best overlap which maximises the mutual information.
</p>


<h3>Value</h3>

<p><code>reportStats=FALSE</code> returns a SpatRaster (x-y shifted image).
<code>reportStats=TRUE</code> returns a list containing a data.frame with mutual information per shift ($MI), the shift of maximum MI ($bestShift),
the joint histograms per shift in a list ($jointHist) and the shifted image ($coregImg).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)
library(ggplot2)
library(reshape2)
reference &lt;- rlogo
## Shift reference 2 pixels to the right and 3 up
missreg &lt;- shift(reference,  2,  3)

## Compare shift
p &lt;- ggR(reference, sat = 1, alpha = .5) 
p + ggR(missreg, sat = 1, hue = .5, alpha = 0.5, ggLayer=TRUE) 

## Coregister images (and report statistics)
coreg &lt;- coregisterImages(missreg, ref = reference,
                         nSamples = 500, reportStats = TRUE)

## Plot mutual information per shift
ggplot(coreg$MI) + geom_raster(aes(x,y,fill=mi))

## Plot joint histograms per shift (x/y shift in facet labels)
 
df &lt;- melt(coreg$jointHist)   
df$L1 &lt;- factor(df$L1, levels = names(coreg$jointHist))
df[df$value == 0, "value"] &lt;- NA ## don't display p = 0
ggplot(df) + geom_raster(aes(x = Var2, y = Var1,fill=value)) + facet_wrap(~L1) + 
       scale_fill_gradientn(name = "p", colours =  heat.colors(10), na.value = NA)

## Compare correction
ggR(reference, sat = 1, alpha = .5) +
  ggR(coreg$coregImg, sat = 1, hue = .5, alpha = 0.5, ggLayer=TRUE) 
</code></pre>

<hr>
<h2 id='decodeQA'>Decode QA flags to bit-words</h2><span id='topic+decodeQA'></span>

<h3>Description</h3>

<p>Intended for use with Landsat 16-bit QA bands. Decodes pixel quality flags from integer to bit-words.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decodeQA(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decodeQA_+3A_x">x</code></td>
<td>
<p>Integer (16bit)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the decoded QA values from an integer
</p>


<h3>See Also</h3>

<p><a href="#topic+encodeQA">encodeQA</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>decodeQA(53248)
</code></pre>

<hr>
<h2 id='encodeQA'>Encode QA Conditions to Integers</h2><span id='topic+encodeQA'></span>

<h3>Description</h3>

<p>Intended for use with Landsat 16-bit QA bands. Converts pixel quality flags from human readable to integer, which can then be used to 
subset a QA image. Please be aware of the default settings which differ for different parameters. 
Depending on, which <code>sensor</code> and <code>legacy</code> is selected, some quality parameters are not used, since the sequences of available bitwise quality designations differ per sensor and collection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>encodeQA(
  fill = "no",
  terrainOcclusion = "no",
  radSaturation = "na",
  cloudMask = "all",
  cloud = "all",
  cloudShadow = "all",
  snow = "all",
  cirrus = "all",
  droppedPixel = "no",
  water = "all",
  droppedFrame = "no",
  sensor = "OLI",
  legacy = "collection1"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="encodeQA_+3A_fill">fill</code></td>
<td>
<p>Designated fill. Options: <code>c("yes", "no", "all")</code>.</p>
</td></tr>
<tr><td><code id="encodeQA_+3A_terrainocclusion">terrainOcclusion</code></td>
<td>
<p>Terrain induced occlusion. Options: <code>c("yes", "no", "all")</code>.</p>
</td></tr>
<tr><td><code id="encodeQA_+3A_radsaturation">radSaturation</code></td>
<td>
<p>Number of bands that contain radiometric saturation. Options: <code>c("na", "low", "med", "high", "all")</code> for no bands, 1-2 bands, 3-4 bands, 5 or more bands contain saturation.</p>
</td></tr>
<tr><td><code id="encodeQA_+3A_cloudmask">cloudMask</code></td>
<td>
<p>Cloud mask. Options: <code>c("yes", "no", "all")</code>.</p>
</td></tr>
<tr><td><code id="encodeQA_+3A_cloud">cloud</code></td>
<td>
<p>Cloud confidence. Options: <code>c("na", "low", "med", "high", "all")</code>.</p>
</td></tr>
<tr><td><code id="encodeQA_+3A_cloudshadow">cloudShadow</code></td>
<td>
<p>Cloud shadow confidence. Options: <code>c("yes", "no", "all")</code>.</p>
</td></tr>
<tr><td><code id="encodeQA_+3A_snow">snow</code></td>
<td>
<p>Snow / ice confidence.  Options: <code>c("na", "low", "med", "high", "all")</code>.</p>
</td></tr>
<tr><td><code id="encodeQA_+3A_cirrus">cirrus</code></td>
<td>
<p>Cirrus confidence.  Options: <code>c("na", "low", "med", "high", "all")</code>.</p>
</td></tr>
<tr><td><code id="encodeQA_+3A_droppedpixel">droppedPixel</code></td>
<td>
<p>Dropped pixel. Options: <code>c("yes", "no", "all")</code>.</p>
</td></tr>
<tr><td><code id="encodeQA_+3A_water">water</code></td>
<td>
<p>Water confidence. Options: <code>c("na", "low", "med", "high", "all")</code>.</p>
</td></tr>
<tr><td><code id="encodeQA_+3A_droppedframe">droppedFrame</code></td>
<td>
<p>Dropped frame. Options: <code>c("yes", "no", "all")</code>.</p>
</td></tr>
<tr><td><code id="encodeQA_+3A_sensor">sensor</code></td>
<td>
<p>Sensor to encode. Options: <code>c("OLI", "TIRS", "ETM+", "TM", "MSS")</code>.</p>
</td></tr>
<tr><td><code id="encodeQA_+3A_legacy">legacy</code></td>
<td>
<p>Encoding systematic Options: <code>c("collection1", "pre_collection")</code>. Default is &quot;collection1&quot; for the Landsat Collection 1 8-bit quality designations. Use &quot;pre_collection&quot; for imagery downloaded before the Collection 1 quality designations were introduced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the Integer value for the QA values
</p>


<h3>Note</h3>

<p>Only currently populated bits are available as arguments.
</p>


<h3>References</h3>

<p><a href="https://www.usgs.gov/landsat-missions/landsat-collection-1-level-1-quality-assessment-band">https://www.usgs.gov/landsat-missions/landsat-collection-1-level-1-quality-assessment-band</a> for Collection 1 quality designations (<code>legacy = "collection1"</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>encodeQA(snow = "low", cirrus = c("med", "high"), cloud = "high")
</code></pre>

<hr>
<h2 id='estimateHaze'>Estimate Image Haze for Dark Object Subtraction (DOS)</h2><span id='topic+estimateHaze'></span>

<h3>Description</h3>

<p>estimates the digital number (DN) pixel value of *dark* objects for the visible wavelength range.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateHaze(
  x,
  hazeBands,
  darkProp = 0.01,
  maxSlope = TRUE,
  plot = FALSE,
  returnTables = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateHaze_+3A_x">x</code></td>
<td>
<p>RasterLayer or SpatRaster or a previous result from <code>estimateHaze</code> with <code>returnTables = TRUE</code> from which to estimate haze</p>
</td></tr>
<tr><td><code id="estimateHaze_+3A_hazebands">hazeBands</code></td>
<td>
<p>Integer or Character. Band number or bandname from which to estimate atmospheric haze (optional if x contains only one layer)</p>
</td></tr>
<tr><td><code id="estimateHaze_+3A_darkprop">darkProp</code></td>
<td>
<p>Numeric. Proportion of pixels estimated to be dark.</p>
</td></tr>
<tr><td><code id="estimateHaze_+3A_maxslope">maxSlope</code></td>
<td>
<p>Logical. Use <code>darkProp</code> only as an upper boundary and search for the DN of maximum slope in the histogram below this value.</p>
</td></tr>
<tr><td><code id="estimateHaze_+3A_plot">plot</code></td>
<td>
<p>Logical. Option to display histograms and haze values</p>
</td></tr>
<tr><td><code id="estimateHaze_+3A_returntables">returnTables</code></td>
<td>
<p>Logical. Option to return the frequency table per layer. Only takes effect if x is a SpatRaster. If x is a result of estimateHaze tables will always be returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is assumed that any radiation originating from *dark* pixels is due to atmospheric haze and
not the reflectance of the surface itself (the surface is dark, i.e. it has a reflectance close to zero).
Hence, the haze values are estimates of path radiance, which can be subtracted in a dark object subtraction (DOS) procedure (see <code><a href="#topic+radCor">radCor</a></code>)
</p>
<p>Atmospheric haze affects almost exclusively the visible wavelength range. Therefore, typically, you'd only want to estimate haze in blue, green and red bands, occasionally also in the nir band.
</p>


<h3>Value</h3>

<p>If returnTables is FALSE (default). Then a vector of length(hazeBands) containing the estimated haze DNs will be returned.
If returnTables is TRUE a list with two components will be returned. The list element 'SHV' contains the haze values, while 'table'
contains another list with the sampled frequency tables. The latter can be re-used to try different darkProp thresholds without having to sample
the raster again.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Estimate haze for blue, green and red band
haze &lt;- estimateHaze(lsat, hazeBands = 1:3, plot = FALSE)
haze

## Find threshold interactively
#### Return the frequency tables for re-use
#### avoids having to sample the Raster again and again
haze &lt;- estimateHaze(lsat, hazeBands = 1:3, returnTables = TRUE)
## Use frequency table instead of lsat and fiddle with
haze &lt;- estimateHaze(haze, hazeBands = 1:3, darkProp = .1, plot = FALSE)
haze$SHV
</code></pre>

<hr>
<h2 id='fCover'>Fractional Cover Analysis</h2><span id='topic+fCover'></span>

<h3>Description</h3>

<p>fCover takes a classified high resolution image, e.g. vegetation and non-vegetation based on Landsat and calculates cover fractions for
pixels of a coarser resolution, e.g. MODIS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fCover(
  classImage,
  predImage,
  nSamples = 1000,
  classes = 1,
  maxNA = 0,
  clamp = TRUE,
  model = "rf",
  tuneLength = 3,
  trControl = trainControl(method = "cv"),
  method = deprecated(),
  filename = NULL,
  overwrite = FALSE,
  verbose,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fCover_+3A_classimage">classImage</code></td>
<td>
<p>high resolution RasterLayer or SpatRaster containing a landcover classification, e.g. as obtained by <a href="#topic+superClass">superClass</a>.</p>
</td></tr>
<tr><td><code id="fCover_+3A_predimage">predImage</code></td>
<td>
<p>coarse resolution RasterLayer or SpatRaster for which fractional cover will be estimated.</p>
</td></tr>
<tr><td><code id="fCover_+3A_nsamples">nSamples</code></td>
<td>
<p>Integer. Number of pixels to sample from predImage to train the regression model</p>
</td></tr>
<tr><td><code id="fCover_+3A_classes">classes</code></td>
<td>
<p>Integer. Classes for which fractional cover should be estimated (one or more).</p>
</td></tr>
<tr><td><code id="fCover_+3A_maxna">maxNA</code></td>
<td>
<p>Numeric. Maximal proportion of NAs allowed in training pixels.</p>
</td></tr>
<tr><td><code id="fCover_+3A_clamp">clamp</code></td>
<td>
<p>Logical. Enforce results to stay within [0,1] interval. Values &lt;0 are reset to 0 and values &gt;1 to 1.</p>
</td></tr>
<tr><td><code id="fCover_+3A_model">model</code></td>
<td>
<p>Character. Which model to fit for image regression. See <a href="caret.html#topic+train">train</a> for options. Defaults to randomForest ('rf')</p>
</td></tr>
<tr><td><code id="fCover_+3A_tunelength">tuneLength</code></td>
<td>
<p>Integer. Number of levels for each tuning parameters that should be generated by train. See Details and <code><a href="caret.html#topic+train">train</a></code>.</p>
</td></tr>
<tr><td><code id="fCover_+3A_trcontrol">trControl</code></td>
<td>
<p><code><a href="caret.html#topic+trainControl">trainControl</a></code> object, specifying resampling, validation etc.</p>
</td></tr>
<tr><td><code id="fCover_+3A_method">method</code></td>
<td>
<p>DEPREACTED! in favor of <code>trControl=trainControl(method="cv")</code> Resampling method for parameter tuning. Defaults to 10 fold cross-validation. See <code><a href="caret.html#topic+trainControl">trainControl</a></code> for options.</p>
</td></tr>
<tr><td><code id="fCover_+3A_filename">filename</code></td>
<td>
<p>Character. Filename of the output raster file (optional).</p>
</td></tr>
<tr><td><code id="fCover_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical. if <code>TRUE</code>, <code>filename</code> will be overwritten.</p>
</td></tr>
<tr><td><code id="fCover_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Print progress information.</p>
</td></tr>
<tr><td><code id="fCover_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to  <code><a href="terra.html#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>fCover gets the pixel values in a high resolution classified image that correspond to 
randomly selected moderate resolution pixels and then calculates the percent of 
the classified image pixels that represent your cover type of interest. In other words, if 
your high resolution image has a pixel size of 1m and your moderate resolution image has a 
pixel size of 30m the sampling process would take a block of 900 of the 1m resolution pixels 
that correspond to a single 30m pixel and calculate the percentage of the 1m pixels that 
are forest. For example, if there were 600 forest pixels and 300 non-forest pixels the value 
given for the output pixel would be 0.67 since 67
</p>
<p>fCover relies on the train() function from the caret package which provides access to a huge number of classifiers.
Please see the available options at <a href="caret.html#topic+train">train</a>. The default classifier (randomForest) we chose has been shown
to provide very good results in image regression and hence it is recomended you start with this one. If you choose a different
classifier, make sure it can run in regression mode.
</p>
<p>Many models require tuning of certain parameters. Again, this is handled by <a href="caret.html#topic+train">train</a> from the caret package.
With the tuneLength argument you can specify how many different values of each tuning parameter should be tested. The Random Forest
algorithm for example can be tuned by varying the mtry parameter. Hence, by specifying tuneLength = 10, ten different levels
of mtry will be tested in a cross-validation scheme and the best-performing value will be chosen for the final model.
</p>
<p>If the total no-data values for a block of high resolution pixels is greater than maxNA then 
it will not be included in the training data set since there is too much missing data to provide 
a reliable cover percentage. If the no-data proporton is less then maxNA the no-data pixels are removed 
from the total number of pixels when calculating the percent cover.
</p>


<h3>Value</h3>

<p>Returns a list with two elements: models contains the fitted models evaluated in tenfold cross-validation (caret train objects); 
fCover contains a SpatRaster with a fractional cover layer for each requested class.
</p>


<h3>See Also</h3>

<p><a href="#topic+superClass">superClass</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(terra)
library(caret)
## Create fake input images
agg.level &lt;- 9
modis &lt;- terra::aggregate(rlogo, agg.level)

## Perform an exemplary classification
lc      &lt;- unsuperClass(rlogo, nClass=2)

## Calculate the true cover, which is of course only possible in this example, 
## because the fake corse resolution imagery is exactly res(rlogo)*9
trueCover &lt;- terra::aggregate(lc$map, agg.level, 
                   fun = function(x, ...){sum(x == 1, ...)/sum(!is.na(x))})

## Run with randomForest and support vector machine (radial basis kernel)
## Of course the SVM is handicapped in this example,
## due to poor tuning (tuneLength)
par(mfrow=c(2,3))
for(model in c("rf", "svmRadial")){
   fc &lt;- fCover(
           classImage = lc$map ,
           predImage = modis,
           classes=1,
           trControl = trainControl(method = "cv", number = 3),
           model=model,
           nSample = 50,
           tuneLength=2
   )           
   
   ## How close is it to the truth?
   compare.rf &lt;- trueCover - fc$map
   plot(fc$map, main = paste("Fractional Cover: Class 1\nModel:", model))
   plot(compare.rf, main = "Diffence\n true vs. predicted")
   plot(trueCover[],fc$map[],  xlim = c(0,1), ylim =c(0,1),
           xlab = "True Cover", ylab = "Predicted Cover" )
   abline(coef=c(0,1))
   rmse &lt;- sqrt(global(compare.rf^2, "sum", na.rm = TRUE))/ncell(compare.rf)
   r2 &lt;- cor(trueCover[], fc$map[], "complete.obs")
   text(0.9,0.1, adj=1, labels = 
        paste(c("RMSE:","\nR2:"), round(unlist(c(rmse, r2)),3), collapse=""))
}

## Reset par
par(mfrow=c(1,1))

</code></pre>

<hr>
<h2 id='fortifySpatRaster'>Fortify method for classes from the terra package.</h2><span id='topic+fortifySpatRaster'></span>

<h3>Description</h3>

<p>Fortify method for classes from the terra package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fortifySpatRaster(x, maxpixels = 50000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fortifySpatRaster_+3A_x">x</code></td>
<td>
<p><code>SpatRaster</code> object to convert into a dataframe.</p>
</td></tr>
<tr><td><code id="fortifySpatRaster_+3A_maxpixels">maxpixels</code></td>
<td>
<p>Integer. Maximum number of pixels to sample</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data.frame with coordinates (x,y) and corresponding raster values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r_df &lt;- fortifySpatRaster(rlogo)
head(r_df)
</code></pre>

<hr>
<h2 id='getMeta'>Extract bandwise information from ImageMetaData</h2><span id='topic+getMeta'></span>

<h3>Description</h3>

<p>This is an accessor function to quickly access information stored in ImageMetaData, e.g. scale factor per band.
Intended for use with imagery which was imported using stackMeta. Will return parameters using the actual band order in img.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMeta(img, metaData, what)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMeta_+3A_img">img</code></td>
<td>
<p>SpatRaster or character vector with band names.</p>
</td></tr>
<tr><td><code id="getMeta_+3A_metadata">metaData</code></td>
<td>
<p>ImageMetaData or path to meta data file.</p>
</td></tr>
<tr><td><code id="getMeta_+3A_what">what</code></td>
<td>
<p>Character. Parameter to extract. Either data descriptors, or conversion parameters (see Details for options)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Possible metadata parameters (<code>what</code> argument):
</p>
<p>Data descriptors
</p>

<table>
<tr>
 <td style="text-align: left;">
'FILES' </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
'QUANTITY' </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
'CATEGORY' </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
'NA_VALUE' </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
'SATURATE_VALUE' </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;"> 
'SCALE_FACTOR' </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
'DATA_TYPE' </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
'SPATIAL_RESOLUTION' </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Conversion parameters
</p>

<table>
<tr>
 <td style="text-align: left;">
'CALRAD' </td><td style="text-align: left;"> Conversion parameters from DN to radiance </td>
</tr>
<tr>
 <td style="text-align: left;">
'CALBT' </td><td style="text-align: left;"> Conversion parameters from radiance to brightness temperature </td>
</tr>
<tr>
 <td style="text-align: left;">
'CALREF' </td><td style="text-align: left;"> Conversion parameters from DN to reflectance (Landsat 8 only) </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>If <code>what</code> is one of <code>c('CALRAD', 'CALBT', 'CALREF')</code> a data.frame is returned with bands in rows (order corresponding to <code>img</code> band order). 
Otherwise a named numeric vector with the corresponding parameter is returned (layernames as names).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Import example data
mtlFile  &lt;- system.file("external/landsat/LT52240631988227CUB02_MTL.txt", package="RStoolbox")
meta &lt;- readMeta(mtlFile)
lsat_t &lt;- stackMeta(mtlFile)

## Get integer scale factors
getMeta(lsat_t, metaData = meta, what = "SCALE_FACTOR")

## Conversion factors for brightness temperature
getMeta("B6_dn", metaData = meta, what = "CALBT")

## Conversion factors to top-of-atmosphere radiance
## Band order not corresponding to metaData order
getMeta(lsat_t[[5:1]], metaData = meta, what = "CALRAD")

## Get integer scale factors
getMeta(lsat_t, metaData = meta, what = "SCALE_FACTOR")

## Get file basenames
getMeta(lsat_t, metaData = meta, what = "FILES")

</code></pre>

<hr>
<h2 id='getValidation'>Extract validation results from superClass objects</h2><span id='topic+getValidation'></span>

<h3>Description</h3>

<p>Extract validation results from superClass objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getValidation(x, from = "testset", metrics = "overall")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getValidation_+3A_x">x</code></td>
<td>
<p>superClass object or caret::confusionMatrix</p>
</td></tr>
<tr><td><code id="getValidation_+3A_from">from</code></td>
<td>
<p>Character. 'testset' extracts the results from independent validation with testset. 'cv' extracts cross-validation results.</p>
</td></tr>
<tr><td><code id="getValidation_+3A_metrics">metrics</code></td>
<td>
<p>Character. Only relevant in classification mode (ignored for regression models). 
Select 'overall' for overall accuracy metrics, 'classwise' for classwise metrics, 
'confmat' for the confusion matrix itself and 'caret' to return the whole caret::confusionMatrix object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data.frame with validation results. 
If metrics = 'confmat' or 'caret' will return a table or the full caret::confusionMatrix object, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(pls)
## Fit classifier (splitting training into 70\% training data, 30\% validation data)
train &lt;- readRDS(system.file("external/trainingPoints.rds", package="RStoolbox"))
SC   &lt;- superClass(rlogo, trainData = train, responseCol = "class",
                    model="pls", trainPartition = 0.7)
## Independent testset-validation
getValidation(SC)
getValidation(SC, metrics = "classwise")
## Cross-validation based 
getValidation(SC, from = "cv")
</code></pre>

<hr>
<h2 id='ggR'>Plot RasterLayers in ggplot with greyscale</h2><span id='topic+ggR'></span>

<h3>Description</h3>

<p>Plot single layer imagery in grey-scale. Can be used with a SpatRaster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggR(
  img,
  layer = 1,
  maxpixels = 5e+05,
  alpha = 1,
  hue = 1,
  sat = 0,
  stretch = "none",
  quantiles = c(0.02, 0.98),
  ext = NULL,
  coord_equal = TRUE,
  ggLayer = FALSE,
  ggObj = TRUE,
  geom_raster = FALSE,
  forceCat = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggR_+3A_img">img</code></td>
<td>
<p>raster</p>
</td></tr>
<tr><td><code id="ggR_+3A_layer">layer</code></td>
<td>
<p>Character or numeric. Layername or number. Can be more than one layer, in which case each layer is plotted in a subplot.</p>
</td></tr>
<tr><td><code id="ggR_+3A_maxpixels">maxpixels</code></td>
<td>
<p>Integer. Maximal number of pixels to sample.</p>
</td></tr>
<tr><td><code id="ggR_+3A_alpha">alpha</code></td>
<td>
<p>Numeric. Transparency (0-1).</p>
</td></tr>
<tr><td><code id="ggR_+3A_hue">hue</code></td>
<td>
<p>Numeric. Hue value for color calculation [0,1] (see <code><a href="grDevices.html#topic+hsv">hsv</a></code>). Change if you need anything else than greyscale. Only effective if <code>sat &gt; 0</code>.</p>
</td></tr>
<tr><td><code id="ggR_+3A_sat">sat</code></td>
<td>
<p>Numeric. Saturation value for color calculation [0,1] (see <code><a href="grDevices.html#topic+hsv">hsv</a></code>). Change if you need anything else than greyscale.</p>
</td></tr>
<tr><td><code id="ggR_+3A_stretch">stretch</code></td>
<td>
<p>Character. Either 'none', 'lin', 'hist', 'sqrt' or 'log' for no stretch, linear, histogram, square-root or logarithmic stretch.</p>
</td></tr>
<tr><td><code id="ggR_+3A_quantiles">quantiles</code></td>
<td>
<p>Numeric vector with two elements. Min and max quantiles to stretch to. Defaults to 2% stretch, i.e. c(0.02,0.98).</p>
</td></tr>
<tr><td><code id="ggR_+3A_ext">ext</code></td>
<td>
<p>Extent object to crop the image</p>
</td></tr>
<tr><td><code id="ggR_+3A_coord_equal">coord_equal</code></td>
<td>
<p>Logical. Force addition of coord_equal, i.e. aspect ratio of 1:1. Typically useful for remote sensing data (depending on your projection), hence it defaults to TRUE.
Note however, that this does not apply if (<code>ggLayer=FALSE</code>).</p>
</td></tr>
<tr><td><code id="ggR_+3A_gglayer">ggLayer</code></td>
<td>
<p>Logical. Return only a ggplot layer which must be added to an existing ggplot. If <code>FALSE</code> s stand-alone ggplot will be returned.</p>
</td></tr>
<tr><td><code id="ggR_+3A_ggobj">ggObj</code></td>
<td>
<p>Logical. Return a stand-alone ggplot object (TRUE) or just the data.frame with values and colors</p>
</td></tr>
<tr><td><code id="ggR_+3A_geom_raster">geom_raster</code></td>
<td>
<p>Logical. If <code>FALSE</code> uses annotation_raster (good to keep aestetic mappings free). If <code>TRUE</code> uses <code>geom_raster</code> (and <code>aes(fill)</code>). See Details.</p>
</td></tr>
<tr><td><code id="ggR_+3A_forcecat">forceCat</code></td>
<td>
<p>Logical. If <code>TRUE</code> the raster values will be forced to be categorical (will be converted to factor if needed).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>img</code> contains factor values and <code>annotation=TRUE</code>, the raster values will automatically be converted
to numeric in order to proceed with the brightness calculation.
</p>
<p>The geom_raster argument switches from the default use of annotation_raster to geom_raster. The difference between the two is that geom_raster performs
a meaningful mapping from pixel values to fill colour, while annotation_raster is simply adding a picture to your plot. In practice this means that whenever you 
need a legend for your raster you should use <code>geom_raster = TRUE</code>. This also allows you to specify and modify the fill scale manually. 
The advantage of using annotation_raster (<code>geom_raster = TRUE</code>) is that you can still use the scale_fill* for another variable. For example you could add polygons and 
map a value to their fill colour. For more details on the theory behind aestetic mapping have a look at the <a href="https://CRAN.R-project.org/package=ggplot2/ggplot2.pdf">ggplot2</a> manuals.
</p>


<h3>Value</h3>


<table>
<tr>
 <td style="text-align: left;">
 <code>ggObj = TRUE</code>:   </td><td style="text-align: left;"> ggplot2 plot </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>ggLayer = TRUE</code>: </td><td style="text-align: left;"> ggplot2 layer to be combined with an existing ggplot2 </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>ggObj = FALSE</code>:  </td><td style="text-align: left;"> data.frame in long format suitable for plotting with ggplot2, 
                         includes the pixel values and the calculated colors  </td>
</tr>
<tr>
 <td style="text-align: left;">  
</td>
</tr>

</table>



<h3>See Also</h3>

<p><a href="#topic+ggRGB">ggRGB</a>, <a href="#topic+fortifySpatRaster">fortifySpatRaster</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
library(terra)

## Simple grey scale annotation
ggR(rlogo)

## With linear stretch contrast enhancement
ggR(rlogo, stretch = "lin", quantiles = c(0.1,0.9))

## ggplot with geom_raster instead of annotation_raster
## and default scale_fill*
ggR(rlogo, geom_raster = TRUE)

## with different scale
ggR(rlogo, geom_raster = TRUE) +
        scale_fill_gradientn(name = "mojo", colours = rainbow(10)) +
        ggtitle("**Funkadelic**")

## Plot multiple layers

ggR(lsat, 1:6, geom_raster=TRUE, stretch = "lin") +
    scale_fill_gradientn(colors=grey.colors(100), guide = "none") +
    theme(axis.text = element_text(size=5),
          axis.text.y = element_text(angle=90),
          axis.title=element_blank())

## Don't plot, just return a data.frame
df &lt;- ggR(rlogo, ggObj = FALSE)
head(df, n = 3)

## Layermode (ggLayer=TRUE)
data &lt;- data.frame(x = c(0, 0:100,100), y = c(0,sin(seq(0,2*pi,pi/50))*10+20, 0))
ggplot(data, aes(x, y)) +  ggR(rlogo, geom_raster= FALSE, ggLayer = TRUE) +
       geom_polygon(aes(x, y), fill = "blue", alpha = 0.4) +
       coord_equal(ylim=c(0,75))

## Categorical data 
## In this case you probably want to use geom_raster=TRUE 
## in order to perform aestetic mapping (i.e. a meaningful legend)
rc   &lt;- rlogo
rc[] &lt;- cut(rlogo[[1]][], seq(0,300, 50))
ggR(rc, geom_raster = TRUE)

## Legend cusomization etc. ...
ggR(rc, geom_raster = TRUE) + scale_fill_continuous(labels=paste("Class", 1:6))

## Creating a nicely looking DEM with hillshade background
terr &lt;- terrain(srtm, c("slope", "aspect"))
hill &lt;- shade(terr[["slope"]], terr[["aspect"]])
ggR(hill)

ggR(hill) + 
   ggR(srtm, geom_raster = TRUE, ggLayer = TRUE, alpha = 0.3) +
   scale_fill_gradientn(colours = terrain.colors(100), name = "elevation")
</code></pre>

<hr>
<h2 id='ggRGB'>Create ggplot2 Raster Plots with RGB from 3 RasterLayers</h2><span id='topic+ggRGB'></span>

<h3>Description</h3>

<p>Calculates RGB color composite raster for plotting with ggplot2. Optional values for clipping and and stretching can be used to enhance the imagery.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggRGB(
  img,
  r = 3,
  g = 2,
  b = 1,
  scale,
  maxpixels = 5e+05,
  stretch = "none",
  ext = NULL,
  limits = NULL,
  clipValues = "limits",
  quantiles = c(0.02, 0.98),
  ggObj = TRUE,
  ggLayer = FALSE,
  alpha = 1,
  coord_equal = TRUE,
  geom_raster = FALSE,
  nullValue = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggRGB_+3A_img">img</code></td>
<td>
<p>RasterStack or RasterBrick</p>
</td></tr>
<tr><td><code id="ggRGB_+3A_r">r</code></td>
<td>
<p>Integer or character. Red layer in x. Can be set to <code>NULL</code>, in which case the red channel will be set to zero.</p>
</td></tr>
<tr><td><code id="ggRGB_+3A_g">g</code></td>
<td>
<p>Integer or character. Green layer in x. Can be set to <code>NULL</code>, in which case the green channel will be set to zero.</p>
</td></tr>
<tr><td><code id="ggRGB_+3A_b">b</code></td>
<td>
<p>Integer or character. Blue layer in x. Can be set to <code>NULL</code>, in which case the blue channel will be set to zero.</p>
</td></tr>
<tr><td><code id="ggRGB_+3A_scale">scale</code></td>
<td>
<p>Numeric. Maximum possible pixel value (optional). Defaults to 255 or to the maximum value of x if that is larger than 255</p>
</td></tr>
<tr><td><code id="ggRGB_+3A_maxpixels">maxpixels</code></td>
<td>
<p>Integer. Maximal number of pixels used for plotting.</p>
</td></tr>
<tr><td><code id="ggRGB_+3A_stretch">stretch</code></td>
<td>
<p>Character. Either 'none', 'lin', 'hist', 'sqrt' or 'log' for no stretch, linear, histogram, square-root or logarithmic stretch.</p>
</td></tr>
<tr><td><code id="ggRGB_+3A_ext">ext</code></td>
<td>
<p>Extent or SpatExtent object to crop the image</p>
</td></tr>
<tr><td><code id="ggRGB_+3A_limits">limits</code></td>
<td>
<p>Vector or matrix. Can be used to reduce the range of values. Either a vector of two values for all bands (c(min, max))
or a 3x2 matrix with min and max values (columns) for each layer (rows).</p>
</td></tr>
<tr><td><code id="ggRGB_+3A_clipvalues">clipValues</code></td>
<td>
<p>Matrix, numeric vector, string or NA. Values to reset out of range (out of <code>limits</code>) values to. 
By default ('limits') values are reset to <code>limits</code>. A single value (e.g. NA) will be recycled to all lower/higher clippings,
A vector of length two (c(min,max)) can be used to specify lower and higher replace values, applied to all bands. 
A two column matrix (typically with three rows) can be used to fully control lower and upper clipping values differently for each band.</p>
</td></tr>
<tr><td><code id="ggRGB_+3A_quantiles">quantiles</code></td>
<td>
<p>Numeric vector with two elements. Min and max quantiles to stretch. Defaults to 2% stretch, i.e. c(0.02,0.98).</p>
</td></tr>
<tr><td><code id="ggRGB_+3A_ggobj">ggObj</code></td>
<td>
<p>Logical. If <code>TRUE</code> a ggplot2 object is returned. If <code>FALSE</code> a data.frame with coordinates and color will be returned.</p>
</td></tr>
<tr><td><code id="ggRGB_+3A_gglayer">ggLayer</code></td>
<td>
<p>Logical. If <code>TRUE</code> a ggplot2 layer is returned. This is useful if you want to add it to an existing ggplot2 object.
Note that if <code>TRUE</code> &amp; <code>annotate = FALSE</code> you have to add a scale_fill_identity() manually in your call to ggplot().</p>
</td></tr>
<tr><td><code id="ggRGB_+3A_alpha">alpha</code></td>
<td>
<p>Numeric. Transparency (0-1).</p>
</td></tr>
<tr><td><code id="ggRGB_+3A_coord_equal">coord_equal</code></td>
<td>
<p>Logical. Force addition of coord_equal, i.e. aspect ratio of 1:1. Typically useful for remote sensing data (depending on your projection), hence it defaults to TRUE.
Note howver, that this does not apply if (<code>ggLayer=FALSE</code>).</p>
</td></tr>
<tr><td><code id="ggRGB_+3A_geom_raster">geom_raster</code></td>
<td>
<p>Logical. If <code>FALSE</code> annotation_raster is used, otherwise geom_raster()+scale_fill_identity is used.
Note that you can't use scale_fill* in addition to the latter, because it already requires scale_fill_identity().</p>
</td></tr>
<tr><td><code id="ggRGB_+3A_nullvalue">nullValue</code></td>
<td>
<p>Numeric. Intensity value used for NULL layers in color compositing. E.g. set g=NULL and fix green value at 0.5 (defaults to 0).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functionality is based on <code><a href="terra.html#topic+plotRGB">plotRGB</a></code> from the raster package.
</p>


<h3>Value</h3>


<table>
<tr>
 <td style="text-align: left;">
 <code>ggObj = TRUE</code>:   </td><td style="text-align: left;"> ggplot2 plot </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>ggLayer = TRUE</code>: </td><td style="text-align: left;"> ggplot2 layer to be combined with an existing ggplot2 </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>ggObj = FALSE</code>:  </td><td style="text-align: left;"> data.frame in long format suitable for plotting with ggplot2, includes the pixel values and the calculated colors </td>
</tr>
<tr>
 <td style="text-align: left;">  
</td>
</tr>

</table>



<h3>See Also</h3>

<p><a href="#topic+ggR">ggR</a>, <a href="#topic+fortifySpatRaster">fortifySpatRaster</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
library(ggplot2)

ggRGB(rlogo, r=1, g=2, b=3)

## Define minMax ranges
ggRGB(rlogo, r=1,g=2, b=3, limits = matrix(c(100,150,10,200,50,255),  ncol = 2, by = TRUE))

## Perform stong linear contrast stretch
ggRGB(rlogo, r = 1, g = 2, b = 3,stretch = "lin", quantiles = c(0.2, 0.8))

## Use only two layers for color calculation
ggRGB(rlogo, r = 1, g = 2, b = NULL)

## Return only data.frame
df &lt;- ggRGB(rlogo, ggObj = FALSE)
head(df)

## Use in layer-mode, e.g. to add to another plot
wave &lt;- data.frame(x = c(0, 0:100,100), y = c(0,sin(seq(0,2*pi,pi/50))*10+20, 0))
p &lt;- ggplot(wave, aes(x, y)) 
p + ggRGB(rlogo, ggLayer = TRUE) +
       geom_polygon(aes(x, y), fill = "blue", alpha = 0.4) +
       coord_equal(ylim=c(0,75))
</code></pre>

<hr>
<h2 id='histMatch'>Image to Image Contrast Matching</h2><span id='topic+histMatch'></span>

<h3>Description</h3>

<p>Performs image to image contrast adjustments based on histogram matching using empirical cumulative
distribution functions from both images.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>histMatch(
  x,
  ref,
  xmask = NULL,
  refmask = NULL,
  nSamples = 1e+05,
  intersectOnly = TRUE,
  paired = TRUE,
  forceInteger = FALSE,
  returnFunctions = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="histMatch_+3A_x">x</code></td>
<td>
<p>RasterLayer or SpatRaster. Source raster which is to be modified.</p>
</td></tr>
<tr><td><code id="histMatch_+3A_ref">ref</code></td>
<td>
<p>RasterLayer or SpatRaster. Reference raster, to which x will be matched.</p>
</td></tr>
<tr><td><code id="histMatch_+3A_xmask">xmask</code></td>
<td>
<p>RasterLayer or SpatRaster. Mask layer for <code>x</code> to exclude pixels which might distort the histogram, i.e. are not present in <code>ref</code>. Any NA pixel in <code>xmask</code> will be ignored (<code>maskvalue = NA</code>).</p>
</td></tr>
<tr><td><code id="histMatch_+3A_refmask">refmask</code></td>
<td>
<p>RasterLayer or SpatRaster. Mask layer for <code>ref</code>. Any NA pixel in <code>refmask</code> will be ignored (<code>maskvalue = NA</code>).</p>
</td></tr>
<tr><td><code id="histMatch_+3A_nsamples">nSamples</code></td>
<td>
<p>Integer. Number of random samples from each image to build the histograms.</p>
</td></tr>
<tr><td><code id="histMatch_+3A_intersectonly">intersectOnly</code></td>
<td>
<p>Logical. If <code>TRUE</code> sampling will only take place in the overlap extent of the two rasters. Otherwise the full rasters will be used for sampling.</p>
</td></tr>
<tr><td><code id="histMatch_+3A_paired">paired</code></td>
<td>
<p>Logical. If <code>TRUE</code> the corresponding pixels will be used in the overlap.</p>
</td></tr>
<tr><td><code id="histMatch_+3A_forceinteger">forceInteger</code></td>
<td>
<p>Logical. Force integer output.</p>
</td></tr>
<tr><td><code id="histMatch_+3A_returnfunctions">returnFunctions</code></td>
<td>
<p>Logical. If <code>TRUE</code> the matching functions will be returned instead of applying them to <code>x</code>.</p>
</td></tr>
<tr><td><code id="histMatch_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <a href="terra.html#topic+writeRaster">writeRaster</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A SpatRaster of <code>x</code> adjusted to the histogram of <code>ref</code>. If <code>returnFunctions  = TRUE</code> a list of functions (one for each layer) will be returned instead.
</p>


<h3>Note</h3>

<p><code>x</code> and <code>ref</code> must have the same number of layers.
</p>


<h3>References</h3>

<p>Richards and Jia: Remote Sensing Digital Image Analysis. Springer, Berlin, Heidelberg, Germany, 439pp.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
library(terra)
## Original image a (+1 to prevent log(0))
img_a &lt;-  rlogo + 1
## Degraded image b
img_b &lt;- log(img_a)
## Cut-off half the image (just for better display)
img_b[, 1:50] &lt;- NA

## Compare Images before histMatching
ggRGB(img_a,1,2,3)+
        ggRGB(img_b, 1,2,3, ggLayer = TRUE, stretch = "lin", q = 0:1) +
        geom_vline(aes(xintercept = 50))+
        ggtitle("Img_a vs. Img_b")

## Do histogram matching
img_b_matched &lt;- histMatch(img_b, img_a)

## Compare Images after histMatching
ggRGB(img_a, 1, 2, 3)+
        ggRGB(img_b_matched, 1, 2, 3, ggLayer = TRUE, stretch = "lin", q = 0:1) +
        geom_vline(aes(xintercept = 50))+
        ggtitle("Img_a vs. Img_b_matched")

## Histogram comparison
opar &lt;- par(mfrow = c(1, 3), no.readonly = TRUE)
img_a[,1:50] &lt;- NA
redLayers &lt;- c(img_a, img_b, img_b_matched)[[c(1,4,7)]]
names(redLayers) &lt;- c("img_a", "img_b", "img_b_matched")

hist(redLayers) 
## Reset par 
par(opar)
</code></pre>

<hr>
<h2 id='ImageMetaData'>ImageMetaData Class</h2><span id='topic+ImageMetaData'></span>

<h3>Description</h3>

<p>ImageMetaData Class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ImageMetaData(
  file = NA,
  format = NA,
  sat = NA,
  sen = NA,
  scene = NA,
  colNum = NA,
  colTier = NA,
  proj = NA,
  date = NA,
  pdate = NA,
  path = NA,
  row = NA,
  az = NA,
  selv = NA,
  esd = NA,
  files = NA,
  bands = NA,
  quant = NA,
  cat = NA,
  na = NA,
  vsat = NA,
  scal = NA,
  dtyp = NA,
  calrad = NA,
  calref = NA,
  calbt = NA,
  radRes = NA,
  spatRes = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ImageMetaData_+3A_file">file</code></td>
<td>
<p>Character. Metadata file</p>
</td></tr>
<tr><td><code id="ImageMetaData_+3A_format">format</code></td>
<td>
<p>Character. Metadata format, e.g. xml, mtl</p>
</td></tr>
<tr><td><code id="ImageMetaData_+3A_sat">sat</code></td>
<td>
<p>Character. Satellite platform</p>
</td></tr>
<tr><td><code id="ImageMetaData_+3A_sen">sen</code></td>
<td>
<p>Character. Sensor</p>
</td></tr>
<tr><td><code id="ImageMetaData_+3A_scene">scene</code></td>
<td>
<p>Character. Scene_ID</p>
</td></tr>
<tr><td><code id="ImageMetaData_+3A_colnum">colNum</code></td>
<td>
<p>Character Collection number</p>
</td></tr>
<tr><td><code id="ImageMetaData_+3A_coltier">colTier</code></td>
<td>
<p>Character Collection tier</p>
</td></tr>
<tr><td><code id="ImageMetaData_+3A_proj">proj</code></td>
<td>
<p>CRS. Projection.</p>
</td></tr>
<tr><td><code id="ImageMetaData_+3A_date">date</code></td>
<td>
<p>POSIXct. Aquisition date.</p>
</td></tr>
<tr><td><code id="ImageMetaData_+3A_pdate">pdate</code></td>
<td>
<p>POSIXct. Processing date.</p>
</td></tr>
<tr><td><code id="ImageMetaData_+3A_path">path</code></td>
<td>
<p>Integer. Path.</p>
</td></tr>
<tr><td><code id="ImageMetaData_+3A_row">row</code></td>
<td>
<p>Integer. Row.</p>
</td></tr>
<tr><td><code id="ImageMetaData_+3A_az">az</code></td>
<td>
<p>Numeric. Sun azimuth</p>
</td></tr>
<tr><td><code id="ImageMetaData_+3A_selv">selv</code></td>
<td>
<p>Numeric. Sun elevation</p>
</td></tr>
<tr><td><code id="ImageMetaData_+3A_esd">esd</code></td>
<td>
<p>Numeric. Earth-sun distance</p>
</td></tr>
<tr><td><code id="ImageMetaData_+3A_files">files</code></td>
<td>
<p>Character vector. Files containing the data, e.g. tiff files</p>
</td></tr>
<tr><td><code id="ImageMetaData_+3A_bands">bands</code></td>
<td>
<p>Character vector. Band names</p>
</td></tr>
<tr><td><code id="ImageMetaData_+3A_quant">quant</code></td>
<td>
<p>Character vector. Quantity, one of c(&quot;dn&quot;, &quot;tra&quot;, &quot;tre&quot;, &quot;sre&quot;, &quot;bt&quot;, &quot;idx&quot;, &quot;angle&quot;)</p>
</td></tr>
<tr><td><code id="ImageMetaData_+3A_cat">cat</code></td>
<td>
<p>Character vector. Category, e.g. c(&quot;image&quot;, &quot;pan&quot;, &quot;index&quot;, &quot;qa&quot;, &quot;aux&quot;)</p>
</td></tr>
<tr><td><code id="ImageMetaData_+3A_na">na</code></td>
<td>
<p>Numeric vector. No-data value per band</p>
</td></tr>
<tr><td><code id="ImageMetaData_+3A_vsat">vsat</code></td>
<td>
<p>Numeric vector. Saturation value per band</p>
</td></tr>
<tr><td><code id="ImageMetaData_+3A_scal">scal</code></td>
<td>
<p>Numeric vector. Scale factor per band. e.g. if data was scaled to 1000*reflectance for integer conversion.</p>
</td></tr>
<tr><td><code id="ImageMetaData_+3A_dtyp">dtyp</code></td>
<td>
<p>Character vector. Data type per band.</p>
</td></tr>
<tr><td><code id="ImageMetaData_+3A_calrad">calrad</code></td>
<td>
<p>data.frame. Calibration coefficients for dn-&gt;radiance conversion. Must have columns 'gain' and 'offset'. Rows named according to <code>bands</code>.</p>
</td></tr>
<tr><td><code id="ImageMetaData_+3A_calref">calref</code></td>
<td>
<p>data.frame. Calibration coefficients for dn-&gt;reflectance conversion. Must have columns 'gain' and 'offset'. Rows named according to <code>bands</code>.</p>
</td></tr>
<tr><td><code id="ImageMetaData_+3A_calbt">calbt</code></td>
<td>
<p>data.frame. Calibration coefficients for dn-&gt;brightness temperature conversion. Must have columns 'K1' and 'K2'. Rows named according to <code>bands</code>.</p>
</td></tr>
<tr><td><code id="ImageMetaData_+3A_radres">radRes</code></td>
<td>
<p>Numeric vector. Radiometric resolution per band.</p>
</td></tr>
<tr><td><code id="ImageMetaData_+3A_spatres">spatRes</code></td>
<td>
<p>Numeric vector. Spatial resolution per band.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a structured, fully customizable meta-data table of a file
</p>

<hr>
<h2 id='lsat'>Landsat 5TM Example Data</h2><span id='topic+lsat'></span>

<h3>Description</h3>

<p>Subset of Landsat 5 TM Scene: LT52240631988227CUB02
Contains all seven bands in DN format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsat
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>ggRGB(lsat, stretch = "lin")
</code></pre>

<hr>
<h2 id='mesma'>Multiple Endmember Spectral Mixture Analysis (Spectral Unmixing)</h2><span id='topic+mesma'></span>

<h3>Description</h3>

<p><code>mesma</code> performs a multiple endmember spectral mixture analysis on a multiband raster image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mesma(img, em, method = "NNLS", iterate = 400, tolerance = 1e-08, ..., verbose)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mesma_+3A_img">img</code></td>
<td>
<p>RasterLayer or RasterBrick or SpatRaster. Remote sensing imagery (usually hyperspectral).</p>
</td></tr>
<tr><td><code id="mesma_+3A_em">em</code></td>
<td>
<p>Matrix or data.frame with spectral endmembers. Rows represent a single endmember of a class, columns represent the spectral bands (i.e. columns correspond to number of bands in <code>img</code>). Number of rows needs to be &gt; 1.</p>
</td></tr>
<tr><td><code id="mesma_+3A_method">method</code></td>
<td>
<p>Character. Select an unmixing method. Currently, only &quot;NNLS&quot; is implemented. Default is &quot;NNLS&quot;.
</p>

<ul>
<li> <p><code>NNLS:</code> applies a non-negative least squares (NNLS) regression which is using a sequential coordinate-wise algorithm (SCA) based on Franc et al. (2005).
</p>
</li></ul>
</td></tr>
<tr><td><code id="mesma_+3A_iterate">iterate</code></td>
<td>
<p>Integer. Set maximum iteration per pixel. Processing time could increase the more iterations are made possible. Default is 400.</p>
</td></tr>
<tr><td><code id="mesma_+3A_tolerance">tolerance</code></td>
<td>
<p>Numeric. Tolerance limit representing a nearly zero minimal number. Default is 1e-8.</p>
</td></tr>
<tr><td><code id="mesma_+3A_...">...</code></td>
<td>
<p>further arguments passed to <a href="terra.html#topic+writeRaster">writeRaster</a>.</p>
</td></tr>
<tr><td><code id="mesma_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Prints progress messages during execution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster. The object will contain one band per endmember, with each value representing the estimated presence probability of the endmember per pixel (0 to 1), and an RMSE band.
</p>


<h3>Note</h3>

<p>Depending on <code>iterate</code> and <code>tolerance</code> settings, the sum of estimated presence probabilites per pixel varies around 1.
</p>


<h3>Author(s)</h3>

<p>Jakob Schwalb-Willmann
</p>


<h3>References</h3>

<p>Franc, V., Hlav, V., &amp; Navara, M. (2005). Sequential coordinate-wise algorithm for the non-negative least squares problem. In: International Conference on Computer Analysis of Images and Patterns (pp. 407-414). Berlin, Heidelberg.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#load packages
library(terra)
library(RStoolbox)


#make up some endmember spectra: water and land
em_names &lt;- c("water", "land")
pts &lt;- data.frame(class=em_names, cell = c(47916,5294))
em &lt;- lsat[pts$cell]
rownames(em) &lt;- em_names

#unmix the image for water and land
probs &lt;- mesma(lsat, em, method = "NNLS")

#take a look
terra::hist(probs$water)
terra::plot(probs$water, col = c("white","blue"))
terra::hist(probs$land)
terra::plot(probs$land, col = c("white","brown"))

</code></pre>

<hr>
<h2 id='normImage'>Normalize Raster Images: Center and Scale</h2><span id='topic+normImage'></span>

<h3>Description</h3>

<p>For each pixel subtracts the mean of the raster layer and optionally divide by its standard deviation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normImage(img, norm = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normImage_+3A_img">img</code></td>
<td>
<p>SpatRaster. Image to transform. Transformation will be performed separately for each layer.</p>
</td></tr>
<tr><td><code id="normImage_+3A_norm">norm</code></td>
<td>
<p>Logical. Perform normalization (scaling) in addition to centering, i.e. divide by standard deviation.</p>
</td></tr>
<tr><td><code id="normImage_+3A_...">...</code></td>
<td>
<p>further arguments passed to <a href="terra.html#topic+writeRaster">writeRaster</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a SpatRaster with the same number layers as input layers with each layer being centered and optionally normalized.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)
## Load example data

## Normalization: Center and Scale
rlogo_center_norm &lt;- normImage(rlogo)
hist(rlogo_center_norm)

## Centering
rlogo_center &lt;- normImage(rlogo, norm = FALSE)
</code></pre>

<hr>
<h2 id='oneHotEncode'>One-hot encode a raster or vector</h2><span id='topic+oneHotEncode'></span>

<h3>Description</h3>

<p>Splits a categorical raster layer (or a vector) into a multilayer raster (or matrix).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oneHotEncode(img, classes, background = 0, foreground = 1, na.rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oneHotEncode_+3A_img">img</code></td>
<td>
<p>RasterLayer or SpatRaster or integer/numeric vector containing multiple classes</p>
</td></tr>
<tr><td><code id="oneHotEncode_+3A_classes">classes</code></td>
<td>
<p>integer: vector of classes which should be extracted</p>
</td></tr>
<tr><td><code id="oneHotEncode_+3A_background">background</code></td>
<td>
<p>integer: background value (default = 0)</p>
</td></tr>
<tr><td><code id="oneHotEncode_+3A_foreground">foreground</code></td>
<td>
<p>integer: foreground value (default = 1)</p>
</td></tr>
<tr><td><code id="oneHotEncode_+3A_na.rm">na.rm</code></td>
<td>
<p>logical: if <code>TRUE</code>, <code>NA</code>s will be coerced to the <code>background</code> value.</p>
</td></tr>
<tr><td><code id="oneHotEncode_+3A_...">...</code></td>
<td>
<p>further arguments passed to <a href="terra.html#topic+writeRaster">writeRaster</a>. Ignored if img is not a SpatRaster, but a numeric/integer vector or matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A SpatRaster with as many layers as there are classes.
Pixels matching the class of interest are set to 1, backround values by default are set to 0 (see background argument)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sc &lt;- unsuperClass(rlogo, nClasses = 3)

## one-hot encode 
sc_oneHot &lt;- oneHotEncode(sc$map, classes = c(1,2,3))

## check results
sc_oneHot

</code></pre>

<hr>
<h2 id='panSharpen'>Pan Sharpen Imagery / Image Fusion</h2><span id='topic+panSharpen'></span>

<h3>Description</h3>

<p>provides different methods for pan sharpening a coarse resolution (typically multispectral) image with 
a higher reolution panchromatic image. Values of the pan-chromatic and multispectral images must be of the same scale, (e.g. from 0:1, or all DNs from 0:255)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panSharpen(img, pan, r, g, b, pc = 1, method = "brovey", norm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="panSharpen_+3A_img">img</code></td>
<td>
<p>RasterLayer or SpatRaster. Coarse resolution multispectral image</p>
</td></tr>
<tr><td><code id="panSharpen_+3A_pan">pan</code></td>
<td>
<p>RasterLayer or SpatRaster. High resolution image, typically panchromatic.</p>
</td></tr>
<tr><td><code id="panSharpen_+3A_r">r</code></td>
<td>
<p>Character or Integer. Red band in <code>img</code>. Only relevant if <code>method!='pca'</code></p>
</td></tr>
<tr><td><code id="panSharpen_+3A_g">g</code></td>
<td>
<p>Character or Integer. Green band in <code>img</code>. Only relevant if <code>method!='pca'</code></p>
</td></tr>
<tr><td><code id="panSharpen_+3A_b">b</code></td>
<td>
<p>Character or Integer. Blue band in <code>img</code>. Only relevant if <code>method!='pca'</code></p>
</td></tr>
<tr><td><code id="panSharpen_+3A_pc">pc</code></td>
<td>
<p>Integer. Only relevant if <code>method = 'pca'</code>. Which principal component to replace. Usually this should be the first component (default). Only if the first component is dominated by something else than brightness it might be worth a try to use the second component.</p>
</td></tr>
<tr><td><code id="panSharpen_+3A_method">method</code></td>
<td>
<p>Character. Choose method from c(&quot;pca&quot;, &quot;ihs&quot;, &quot;brovey&quot;).</p>
</td></tr>
<tr><td><code id="panSharpen_+3A_norm">norm</code></td>
<td>
<p>Logical.  Rescale pan image to match the 1st PC component. Only relevant if <code>method = 'pca'</code>. If <code>TRUE</code> only min and max are matched to the 1st PC. If <code>FALSE</code> pan will be histogram matched to the 1st PC.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Pan sharpening options:
</p>
 
<ul>
<li><p><code>method='pca'</code>: Performs a pca using <a href="#topic+rasterPCA">rasterPCA</a>. The first component is then swapped for the pan band an the PCA is rotated backwards.
</p>
</li>
<li><p><code>method='ihs'</code>: Performs a color space transform to Intensity-Hue-Saturation space, swaps intensity for the histogram matched pan and does the backwards transformation.
</p>
</li>
<li><p><code>method='brovey'</code>: Performs Brovey reweighting. Pan and img must be at the same value scale (e.g. 0:1, or 0:255) otherwise you'll end up with psychodelic colors.
</p>
</li></ul>



<h3>Value</h3>

<p>pan-sharpened SpatRaster
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)
library(ggplot2)

## Fake panchromatic image (30m resolution covering
## the visible range (integral from blue to red))
pan       &lt;- sum(lsat[[1:3]])
ggR(pan, stretch = "lin") 

## Fake coarse resolution image (150m spatial resolution)
lowResImg &lt;- aggregate(lsat, 5)


## Brovey pan sharpening
lowResImg_pan &lt;- panSharpen(lowResImg, pan, r = 3, g = 2, b = 1, method = "brovey")
lowResImg_pan
## Plot 
ggRGB(lowResImg, stretch = "lin") + ggtitle("Original")
ggRGB(lowResImg_pan, stretch="lin") + ggtitle("Pansharpened (Brovey)")
    
</code></pre>

<hr>
<h2 id='pifMatch'>Pseudo-Invariant Features based Image Matching</h2><span id='topic+pifMatch'></span>

<h3>Description</h3>

<p>Match one scene to another based on linear regression of pseudo-invariant features (PIF).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pifMatch(
  img,
  ref,
  method = "cor",
  quantile = 0.95,
  returnPifMap = TRUE,
  returnSimMap = TRUE,
  returnModels = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pifMatch_+3A_img">img</code></td>
<td>
<p>RasterStack or RasterBrick or SpatRaster. Image to be adjusted.</p>
</td></tr>
<tr><td><code id="pifMatch_+3A_ref">ref</code></td>
<td>
<p>RasterStack or RasterBrick or SpatRaster. Reference image.</p>
</td></tr>
<tr><td><code id="pifMatch_+3A_method">method</code></td>
<td>
<p>Method to calculate pixel similarity. Options: euclidean distance ('ed'), spectral angle ('sam') or pearson correlation coefficient ('cor').</p>
</td></tr>
<tr><td><code id="pifMatch_+3A_quantile">quantile</code></td>
<td>
<p>Numeric. Threshold quantile used to identify PIFs</p>
</td></tr>
<tr><td><code id="pifMatch_+3A_returnpifmap">returnPifMap</code></td>
<td>
<p>Logical. Return a binary raster map ot pixels which were identified as pesudo-invariant features.</p>
</td></tr>
<tr><td><code id="pifMatch_+3A_returnsimmap">returnSimMap</code></td>
<td>
<p>Logical. Return the similarity map as well</p>
</td></tr>
<tr><td><code id="pifMatch_+3A_returnmodels">returnModels</code></td>
<td>
<p>Logical. Return the linear models along with the adjusted image.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function consists of three main steps:
First, it calculates pixel-wise similarity between the two rasters and identifies pseudo-invariant pixels based on 
a similarity threshold. 
In the second step the values of the pseudo-invariant pixels are regressed against each other in a linear model for each layer.
Finally the linear models are applied to all pixels in the <code>img</code>, thereby matching it to the reference scene.
</p>
<p>Pixel-wise similarity can be calculated using one of three methods: euclidean distance (<code>method = "ed"</code>), spectral angle (<code>"sam"</code>) or pearsons correlation coefficient (<code>"cor"</code>).
The threshold is defined as a similarity quantile. Setting <code>quantile=0.95</code> will select all pixels with a similarity above the 95% quantile as pseudo-invariant features.
</p>
<p>Model fitting is performed with simple linear models (<code><a href="stats.html#topic+lm">lm</a></code>); fitting one model per layer.
</p>


<h3>Value</h3>

<p>Returns a List with the adjusted image and intermediate products (if requested). 
</p>

<ul>
<li> <p><code>img</code>: the adjusted image
</p>
</li>
<li> <p><code>simMap</code>: pixel-wise similarity map (if <code>returnSimMap = TRUE</code>)
</p>
</li>
<li> <p><code>pifMap</code>: binary map of pixels selected as pseudo-invariant features (if <code>returnPifMap = TRUE</code>) 
</p>
</li>
<li> <p><code>models</code>: list of linear models; one per layer (if <code>returnModels = TRUE</code>)                          
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(terra)


## Create fake example data
## In practice this would be an image from another acquisition date
lsat_b &lt;- log(lsat)

## Run pifMatch and return similarity layer, invariant features mask and models
lsat_b_adj &lt;- pifMatch(lsat_b, lsat, returnPifMap = TRUE,
                         returnSimMap = TRUE, returnModels = TRUE)

## Pixelwise similarity
ggR(lsat_b_adj$simMap, geom_raster = TRUE)

## Pesudo invariant feature mask 
ggR(lsat_b_adj$pifMap)

## Histograms of changes
par(mfrow=c(1,3))
hist(lsat_b[[1]], main = "lsat_b")
hist(lsat[[1]], main = "reference")
hist(lsat_b_adj$img[[1]], main = "lsat_b adjusted")

## Model summary for first band
summary(lsat_b_adj$models[[1]])

</code></pre>

<hr>
<h2 id='predict.unsuperClass'>Predict a raster map based on a unsuperClass model fit.</h2><span id='topic+predict.unsuperClass'></span>

<h3>Description</h3>

<p>applies a kmeans cluster model to all pixels of a raster.
Useful if you want to apply a kmeans model of scene A to scene B.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'unsuperClass'
predict(object, img, output = "classes", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.unsuperClass_+3A_object">object</code></td>
<td>
<p>unsuperClass object</p>
</td></tr>
<tr><td><code id="predict.unsuperClass_+3A_img">img</code></td>
<td>
<p>Raster object. Layernames must correspond to layernames used to train the superClass model, i.e. layernames in the original raster image.</p>
</td></tr>
<tr><td><code id="predict.unsuperClass_+3A_output">output</code></td>
<td>
<p>Character. Either 'classes' (kmeans class; default) or 'distances' (euclidean distance to each cluster center).</p>
</td></tr>
<tr><td><code id="predict.unsuperClass_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <a href="terra.html#topic+writeRaster">writeRaster</a>, e.g. filename</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a raster with the K-means distances base on your object passed in the arguments.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load training data

## Perform unsupervised classification
uc  &lt;- unsuperClass(rlogo, nClasses = 10)

## Apply the model to another raster
map &lt;- predict(uc, rlogo)
</code></pre>

<hr>
<h2 id='radCor'>Radiometric Calibration and Correction</h2><span id='topic+radCor'></span>

<h3>Description</h3>

<p>Implements several different methods for radiometric calibration and correction of Landsat data.
You can either specify a metadata file, or supply all neccesary values manually. 
With proper parametrization apref and sdos should work for other sensors as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>radCor(
  img,
  metaData,
  method = "apref",
  bandSet = "full",
  hazeValues,
  hazeBands,
  atmosphere,
  darkProp = 0.01,
  clamp = TRUE,
  verbose
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="radCor_+3A_img">img</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="radCor_+3A_metadata">metaData</code></td>
<td>
<p>object of class ImageMetaData or a path to the meta data (MTL) file.</p>
</td></tr>
<tr><td><code id="radCor_+3A_method">method</code></td>
<td>
<p>Radiometric conversion/correction method to be used. There are currently four methods available (see Details):
&quot;rad&quot;, &quot;apref&quot;, &quot;sdos&quot;, &quot;dos&quot;, &quot;costz&quot;.</p>
</td></tr>
<tr><td><code id="radCor_+3A_bandset">bandSet</code></td>
<td>
<p>Numeric or character. original Landsat band numbers or names in the form of (&quot;B1&quot;, &quot;B2&quot; etc). If set to 'full' all bands in the solar (optical) region will be processed.</p>
</td></tr>
<tr><td><code id="radCor_+3A_hazevalues">hazeValues</code></td>
<td>
<p>Numeric. Either a vector with dark DNs per <code>hazeBand</code> (method = 'sdos'); possibly estimated using <a href="#topic+estimateHaze">estimateHaze</a>. 
Or the 'starting haze value' (DN) for the relative scattering models in <code>method = 'dos' or 'costz'</code>. If not provided, hazeValues will be estimated in an automated fashion for all <code>hazeBands</code>. 
Argument only applies to methods 'sdos', 'dos' and 'costz'.</p>
</td></tr>
<tr><td><code id="radCor_+3A_hazebands">hazeBands</code></td>
<td>
<p>Character or integer. Bands corresponding to <code>hazeValues</code> (method = 'sdos') or band to select starting haze value from ('dos' or 'costz').</p>
</td></tr>
<tr><td><code id="radCor_+3A_atmosphere">atmosphere</code></td>
<td>
<p>Character. Atmospheric characteristics. Will be estimated if not expicilty provided. Must be one of <code>"veryClear", "clear", "moderate", "hazy"</code> or <code>"veryHazy"</code>.</p>
</td></tr>
<tr><td><code id="radCor_+3A_darkprop">darkProp</code></td>
<td>
<p>Numeric. Estimated proportion of dark pixels in the scene. Used only for automatic guessing of hazeValues (typically one would choose 1 or 2%).</p>
</td></tr>
<tr><td><code id="radCor_+3A_clamp">clamp</code></td>
<td>
<p>Logical. Enforce valid value range. By default reflectance will be forced to stay within [0,1] and radiance &gt;= 0 by replacing invalid values with the correspinding boundary, e.g. -0.1 will become 0.</p>
</td></tr>
<tr><td><code id="radCor_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Print status information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The atmospheric correction methods (sdos, dos and costz) apply to the optical (solar) region of the spectrum and do not affect the thermal band.
</p>
<p>Dark object subtraction approaches rely on the estimation of atmospheric haze based on *dark* pixels. Dark pixels are assumed to have zero reflectance, hence the name.
It is then assumed further that any radiation originating from such *dark* pixels is due to atmospheric haze and 
not the reflectance of the surface itself.
</p>
<p>The folloiwing <code>methods</code> are available:  
</p>

<table>
<tr>
 <td style="text-align: left;">
rad   </td><td style="text-align: left;"> Radiance </td>
</tr>
<tr>
 <td style="text-align: left;">
apref </td><td style="text-align: left;"> Apparent reflectance (top-of-atmosphere reflectance) </td>
</tr>
<tr>
 <td style="text-align: left;">
dos   </td><td style="text-align: left;"> Dark object subtratction following Chavez (1989) </td>
</tr>
<tr>
 <td style="text-align: left;">
costz </td><td style="text-align: left;"> Dark object subtraction following Chavez (1996) </td>
</tr>
<tr>
 <td style="text-align: left;">
sdos  </td><td style="text-align: left;"> Simple dark object subtraction. Classical DOS, Lhaze must be estimated for each band separately. 
</td>
</tr>

</table>

<p>If either &quot;dos&quot; or &quot;costz&quot;  are selected, radCor will use the atmospheric haze decay model described by Chavez (1989).
Depending on the <code>atmosphere</code> the following coefficients are used:
</p>

<table>
<tr>
 <td style="text-align: left;">
veryClear </td><td style="text-align: left;"> <code class="reqn">\lambda^{-4.0}</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
clear     </td><td style="text-align: left;"> <code class="reqn">\lambda^{-2.0}</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
moderate  </td><td style="text-align: left;"> <code class="reqn">\lambda^{-1.0}</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
hazy      </td><td style="text-align: left;"> <code class="reqn">\lambda^{-0.7}</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
veryHazy  </td><td style="text-align: left;"> <code class="reqn">\lambda^{-0.5}</code> 
</td>
</tr>

</table>

<p>For Landsat 8, no values for extra-terrestrial irradiation (esun) are provided by NASA. These are, however, neccessary for DOS-based approaches. 
Therefore, these values were derived from a standard reference spectrum published by Thuillier et al. (2003) using the Landsat 8 OLI spectral response functions
(for details, see <a href="http://bleutner.github.io/RStoolbox/r/2016/01/26/estimating-landsat-8-esun-values">http://bleutner.github.io/RStoolbox/r/2016/01/26/estimating-landsat-8-esun-values</a>).  
</p>
<p>The implemented sun-earth distances neglect the earth's eccentricity. Instead we use a 100 year daily average (1979-2070).
</p>


<h3>Value</h3>

<p>SpatRaster with top-of-atmosphere radiance (<code class="reqn">W/(m^2 * srad * \mu m)</code>), at-satellite brightness temperature (K),
top-of-atmosphere reflectance (unitless) corrected for the sun angle or at-surface reflectance (unitless).
</p>


<h3>Note</h3>

<p>This was originally a fork of randcorr() function in the landsat package. This version works on SpatRasters and hence is suitable for large rasters.
</p>


<h3>References</h3>

<p>S. Goslee (2011): Analyzing Remote Sensing Data in R: The landsat Package. Journal of Statistical Software 43(4).
</p>
<p>G. Thuillier et al. (2003)  THE SOLAR SPECTRAL IRRADIANCE FROM 200 TO 2400 nm AS MEASURED BY THE SOLSPEC SPECTROMETER FROM THE ATLAS AND EURECA MISSIONS. Solar Physics 214(1): 1-22 (
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)
## Import meta-data and bands based on MTL file
mtlFile  &lt;- system.file("external/landsat/LT52240631988227CUB02_MTL.txt", package="RStoolbox")
metaData &lt;- readMeta(mtlFile)
lsat_t &lt;- stackMeta(mtlFile)


## Convert DN to top of atmosphere reflectance and brightness temperature
lsat_ref &lt;- radCor(lsat_t, metaData = metaData, method = "apref")

## Correct DN to at-surface-reflecatance with DOS (Chavez decay model)
lsat_sref &lt;- radCor(lsat_t, metaData = metaData)

## Correct DN to at-surface-reflecatance with simple DOS 
## Automatic haze estimation
hazeDN    &lt;- estimateHaze(lsat_t, hazeBands = 1:4, darkProp = 0.01, plot = FALSE)
lsat_sref &lt;- radCor(lsat_t, metaData = metaData, method = "sdos",
                     hazeValues = hazeDN, hazeBands = 1:4)
</code></pre>

<hr>
<h2 id='rasterCVA'>Change Vector Analysis</h2><span id='topic+rasterCVA'></span>

<h3>Description</h3>

<p>Calculates angle and magnitude of change vectors. 
Dimensionality is limited to two bands per image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rasterCVA(x, y, tmf = NULL, nct = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rasterCVA_+3A_x">x</code></td>
<td>
<p>RasterBrick or RasterStack or SpatRaster with two layers. This will be the reference/origin for the change calculations. Both rasters (y and y) need to correspond to each other, i.e. same resolution, extent and origin.</p>
</td></tr>
<tr><td><code id="rasterCVA_+3A_y">y</code></td>
<td>
<p>RasterBrick or RasterStack or SpatRaster with two layers. Both rasters (y and y) need to correspond to each other, i.e. same resolution, extent and origin.</p>
</td></tr>
<tr><td><code id="rasterCVA_+3A_tmf">tmf</code></td>
<td>
<p>Numeric. Threshold median factor (optional). Used to calculate a threshold magnitude for which pixels are considered stable, i.e. no change. Calculated as <code>tmf * mean(magnitude[magnitude &gt; 0])</code>.</p>
</td></tr>
<tr><td><code id="rasterCVA_+3A_nct">nct</code></td>
<td>
<p>Numeric. No-change threshold (optional). Alternative to <code>tmf</code>. Sets an absolute threshold. Change magnitudes below <code>nct</code> are considered stable and set to NA.</p>
</td></tr>
<tr><td><code id="rasterCVA_+3A_...">...</code></td>
<td>
<p>further arguments passed to writeRaster</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Change Vector Analysis (CVA) is used to identify spectral changes between two identical scenes which were acquired at different times. 
CVA is limited to two bands per image. For each pixel it calculates the change vector in the two-dimensional spectral space. 
For example for a given pixel in image A and B for the red and nir band the change vector is calculated for the coordinate pairs: (red_A | nir_A) and (red_B | nir_B).
</p>
<p>The coordinate system is defined by the order of the input bands: the first band defines the x-axis and the second band the y-axis, respectively.
Angles are returned *in degree* beginning with 0 degrees pointing 'north', i.e. the y-axis, i.e. the second band.
</p>


<h3>Value</h3>

<p>Returns a SpatRaster with two layers: change vector angle and change vector magnitude
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)
pca &lt;- rasterPCA(lsat)$map

## Do change vector analysis
cva &lt;- rasterCVA(pca[[1:2]], pca[[3:4]])
cva
</code></pre>

<hr>
<h2 id='rasterEntropy'>Multi-layer Pixel Entropy</h2><span id='topic+rasterEntropy'></span>

<h3>Description</h3>

<p>Shannon entropy is calculated for each pixel based on it's layer values.
To be used with categorical / integer valued rasters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rasterEntropy(img, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rasterEntropy_+3A_img">img</code></td>
<td>
<p>RasterStack or RasterBrick or SpatRaster</p>
</td></tr>
<tr><td><code id="rasterEntropy_+3A_...">...</code></td>
<td>
<p>additional arguments passed to writeRaster</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Entropy is calculated as -sum(p log(p)); p being the class frequency per pixel.
</p>


<h3>Value</h3>

<p>SpatRaster &quot;entropy&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>re &lt;- rasterEntropy(rlogo)
ggR(re, geom_raster = TRUE)
</code></pre>

<hr>
<h2 id='rasterPCA'>Principal Component Analysis for Rasters</h2><span id='topic+rasterPCA'></span>

<h3>Description</h3>

<p>Calculates R-mode PCA for RasterBricks or RasterStacks and returns a RasterBrick with multiple layers of PCA scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rasterPCA(
  img,
  nSamples = NULL,
  nComp = nlyr(img),
  spca = FALSE,
  maskCheck = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rasterPCA_+3A_img">img</code></td>
<td>
<p>RasterLayer or SpatRaster.</p>
</td></tr>
<tr><td><code id="rasterPCA_+3A_nsamples">nSamples</code></td>
<td>
<p>Integer or NULL. Number of pixels to sample for PCA fitting. If NULL, all pixels will be used.</p>
</td></tr>
<tr><td><code id="rasterPCA_+3A_ncomp">nComp</code></td>
<td>
<p>Integer. Number of PCA components to return.</p>
</td></tr>
<tr><td><code id="rasterPCA_+3A_spca">spca</code></td>
<td>
<p>Logical. If <code>TRUE</code>, perform standardized PCA. Corresponds to centered and scaled input image. This is usually beneficial for equal weighting of all layers. (<code>FALSE</code> by default)</p>
</td></tr>
<tr><td><code id="rasterPCA_+3A_maskcheck">maskCheck</code></td>
<td>
<p>Logical. Masks all pixels which have at least one NA (default TRUE is reccomended but introduces a slow-down, see Details when it is wise to disable maskCheck). 
Takes effect only if nSamples is NULL.</p>
</td></tr>
<tr><td><code id="rasterPCA_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <a href="terra.html#topic+writeRaster">writeRaster</a>, e.g. filename.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internally rasterPCA relies on the use of <a href="stats.html#topic+princomp">princomp</a> (R-mode PCA). If nSamples is given the PCA will be calculated
based on a random sample of pixels and then predicted for the full raster. If nSamples is NULL then the covariance matrix will be calculated
first and will then be used to calculate princomp and predict the full raster. The latter is more precise, since it considers all pixels,
however, it may be slower than calculating the PCA only on a subset of pixels. 
</p>
<p>Pixels with missing values in one or more bands will be set to NA. The built-in check for such pixels can lead to a slow-down of rasterPCA.
However, if you make sure or know beforehand that all pixels have either only valid values or only NAs throughout all layers you can disable this check
by setting maskCheck=FALSE which speeds up the computation.
</p>
<p>Standardised PCA (SPCA) can be useful if imagery or bands of different dynamic ranges are combined. SPC uses the correlation matrix instead of the covariance matrix, which
has the same effect as using normalised bands of unit variance.
</p>


<h3>Value</h3>

<p>Returns a named list containing the PCA model object ($model) and a SpatRaster with the principal component layers ($object).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
library(reshape2)
ggRGB(rlogo, 1,2,3)

## Run PCA
set.seed(25)
rpc &lt;- rasterPCA(rlogo)
rpc

## Model parameters:
summary(rpc$model)
loadings(rpc$model)

ggRGB(rpc$map,1,2,3, stretch="lin", q=0)
if(require(gridExtra)){
  plots &lt;- lapply(1:3, function(x) ggR(rpc$map, x, geom_raster = TRUE))
  grid.arrange(plots[[1]],plots[[2]], plots[[3]], ncol=2)
}
</code></pre>

<hr>
<h2 id='readEE'>Tidy import tool for EarthExplorer .csv export files</h2><span id='topic+readEE'></span>

<h3>Description</h3>

<p>Imports and tidies CSV files exported from EarthExplorer into data.frames and annotates missing fields.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readEE(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readEE_+3A_x">x</code></td>
<td>
<p>Character, Character or list. One or more paths to EarthExplorer export files.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <a href="https://earthexplorer.usgs.gov/">EarthExplorer</a> CSV file can be produced from the search results page. Above the results click on 'export results' and select 'comma (,) delimited'.
</p>
<p>Note that only a subset of columns is imported which was deemed interesting. Please contact the maintainer if you think an omited column should be included.
</p>


<h3>Value</h3>

<p>data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
ee &lt;- readEE(system.file("external/EarthExplorer_LS8.txt", package = "RStoolbox"))

## Scenes with cloud cover &lt; 20%
ee[ee$Cloud.Cover &lt; 20,]

## Available time-series
ggplot(ee) + 
     geom_segment(aes(x = Date, xend = Date, y = 0, yend = 100 - Cloud.Cover, 
     col = as.factor(Year))) +
        scale_y_continuous(name = "Scene quality (% clear sky)")

</code></pre>

<hr>
<h2 id='readMeta'>Read Landsat MTL metadata files</h2><span id='topic+readMeta'></span>

<h3>Description</h3>

<p>Reads metadata and deals with legacy versions of Landsat metadata files and where possible adds missing information (radiometric gain and offset, earth-sun distance).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readMeta(file, raw = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readMeta_+3A_file">file</code></td>
<td>
<p>path to Landsat MTL file (...MTL.txt)</p>
</td></tr>
<tr><td><code id="readMeta_+3A_raw">raw</code></td>
<td>
<p>Logical. If <code>TRUE</code> the full raw metadata will be returned as a list. if <code>FALSE</code> (the default) all important metadata are homogenized into a standard format (ImageMetaData) and some information is added.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class ImageMetaData
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example metadata file (MTL)
mtlFile  &lt;- system.file("external/landsat/LT52240631988227CUB02_MTL.txt", package="RStoolbox")

## Read metadata
metaData &lt;- readMeta(mtlFile)

## Summary
summary(metaData)

</code></pre>

<hr>
<h2 id='readSLI'>Read ENVI spectral libraries</h2><span id='topic+readSLI'></span>

<h3>Description</h3>

<p>read/write support for ENVI spectral libraries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readSLI(path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readSLI_+3A_path">path</code></td>
<td>
<p>Path to spectral library file with ending .sli.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>ENVI spectral libraries consist of a binary data file (.sli) and a corresponding header (.hdr, or .sli.hdr) file.
</p>


<h3>Value</h3>

<p>The spectral libraries are read into a data.frame. The first column contains the wavelengths and the remaining columns contain the spectra.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+writeSLI">writeSLI</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Example data
sliFile &lt;- system.file("external/vegSpec.sli", package="RStoolbox")
sliTmpFile &lt;- paste0(tempdir(),"/vegetationSpectra.sli") 

## Read spectral library
sli &lt;- readSLI(sliFile)
head(sli)
plot(sli[,1:2], col = "orange", type = "l")
lines(sli[,c(1,3)], col = "green")
 
## Write to binary spectral library
writeSLI(sli, path = sliTmpFile)
</code></pre>

<hr>
<h2 id='rescaleImage'>Linear Image Rescaling</h2><span id='topic+rescaleImage'></span>

<h3>Description</h3>

<p>performs linear shifts of value ranges either to match min/max of another image (<code>y</code>)
or to any other min and max value (<code>ymin</code> and <code>ymax</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rescaleImage(x, y, xmin, xmax, ymin, ymax, forceMinMax = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rescaleImage_+3A_x">x</code></td>
<td>
<p>patRaster or numeric vector. Image to normalise.</p>
</td></tr>
<tr><td><code id="rescaleImage_+3A_y">y</code></td>
<td>
<p>SpatRaster or numeric vector. Reference image. Optional. Used to extract min and max values if ymin or ymax are missing.</p>
</td></tr>
<tr><td><code id="rescaleImage_+3A_xmin">xmin</code></td>
<td>
<p>Numeric. Min value of x. Either a single value or one value per layer in x. If xmin is not provided it will be extracted from x.</p>
</td></tr>
<tr><td><code id="rescaleImage_+3A_xmax">xmax</code></td>
<td>
<p>Numeric. Max value of x. Either a single value or one value per layer in x. If xmax is not provided it will be extracted from x.</p>
</td></tr>
<tr><td><code id="rescaleImage_+3A_ymin">ymin</code></td>
<td>
<p>Numeric. Min value of y. Either a single value or one value per layer in x. If ymin is not provided it will be extracted from y.</p>
</td></tr>
<tr><td><code id="rescaleImage_+3A_ymax">ymax</code></td>
<td>
<p>Numeric. Max value of y. Either a single value or one value per layer in x. If ymax is not provided it will be extracted from y.</p>
</td></tr>
<tr><td><code id="rescaleImage_+3A_forceminmax">forceMinMax</code></td>
<td>
<p>Logical. Forces update of min and max data slots in x or y.</p>
</td></tr>
<tr><td><code id="rescaleImage_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="terra.html#topic+writeRaster">terra::writeRaster()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Providing <code>xmin</code> and <code>xmax</code> values manually can be useful if the raster contains a variable of a known, fixed value range,
e.g. NDVI from -1 to 1 but the actual pixel values don't encompass this entire range.
By providing <code>xmin = -1</code> and <code>xmax = 1</code> the values can be rescaled to any other range,
e.g. 1 to 100 while comparability to other rescaled NDVI scenes is retained.
</p>


<h3>Value</h3>

<p>Returns a SpatRaster of the same dimensions as the input raster <code>x</code> but shifted and stretched to the new limits.
</p>


<h3>See Also</h3>

<p><a href="#topic+histMatch">histMatch</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lsat2 &lt;- lsat - 1000
lsat2

## Rescale lsat2 to match original lsat value range
lsat2_rescaled &lt;- rescaleImage(lsat2, lsat)
lsat2_rescaled

## Rescale lsat to value range [0,1]
lsat2_unity &lt;- rescaleImage(lsat2, ymin = 0, ymax = 1)
lsat2_unity
</code></pre>

<hr>
<h2 id='rlogo'>Rlogo as SpatRaster</h2><span id='topic+rlogo'></span>

<h3>Description</h3>

<p>Tiny example of raster data used to run examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rlogo
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>ggRGB(rlogo,r = 1,g = 2,b = 3)
</code></pre>

<hr>
<h2 id='rsOpts'>Set global options for RStoolbox</h2><span id='topic+rsOpts'></span>

<h3>Description</h3>

<p>shortcut to options(RStoolbox.*)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsOpts(verbose)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsOpts_+3A_verbose">verbose</code></td>
<td>
<p>Logical. If <code>TRUE</code> many functions will print status messages about the current processing step. By default verbose mode is disabled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return, just a setter for the verbosiness of the RStoolbox package
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rsOpts(verbose=TRUE)

</code></pre>

<hr>
<h2 id='RStoolbox'>RStoolbox: A Collection of Remote Sensing Tools</h2><span id='topic+RStoolbox'></span>

<h3>Description</h3>

<p>The RStoolbox package provides a set of functions which simplify performing standard remote sensing tasks in R.
</p>


<h3>Data Import and Export</h3>


<ul>
<li> <p><code><a href="#topic+readMeta">readMeta</a></code>:  import Landsat metadata from MTL or XML files
</p>
</li>
<li> <p><code><a href="#topic+stackMeta">stackMeta</a></code>: load Landsat bands based on metadata
</p>
</li>
<li> <p><code><a href="#topic+readSLI">readSLI</a> &amp; <a href="#topic+writeSLI">writeSLI</a></code>: read and write ENVI spectral libraries
</p>
</li>
<li> <p><code><a href="#topic+saveRSTBX">saveRSTBX</a> &amp; <a href="#topic+readRSTBX">readRSTBX</a></code>: save and re-import RStoolbox classification objects (model and map)
</p>
</li>
<li> <p><code><a href="#topic+readEE">readEE</a></code>: import and tidy EarthExplorer search results
</p>
</li></ul>



<h3>Data Pre-Processing</h3>


<ul>
<li> <p><code><a href="#topic+radCor">radCor</a></code>: radiometric conversions and corrections. Primarily, yet not exclusively, intended for Landsat data processing. DN to radiance to reflectance conversion as well as DOS approaches
</p>
</li>
<li> <p><code><a href="#topic+topCor">topCor</a></code>: topographic illumination correction
</p>
</li>
<li> <p><code><a href="#topic+cloudMask">cloudMask</a> &amp; <a href="#topic+cloudShadowMask">cloudShadowMask</a></code>: mask clouds and cloud shadows in Landsat or other imagery which comes with a thermal band
</p>
</li>
<li> <p><code><a href="#topic+classifyQA">classifyQA</a></code>: extract layers from Landsat 8 QA bands, e.g. cloud confidence
</p>
</li>
<li> <p><code><a href="#topic+rescaleImage">rescaleImage</a></code>: rescale image to match min/max from another image or a specified min/max range
</p>
</li>
<li> <p><code><a href="#topic+normImage">normImage</a></code>: normalize imagery by centering and scaling
</p>
</li>
<li> <p><code><a href="#topic+histMatch">histMatch</a></code>: matches the histograms of two scenes
</p>
</li>
<li> <p><code><a href="#topic+coregisterImages">coregisterImages</a></code>: co-register images based on mutual information
</p>
</li>
<li> <p><code><a href="#topic+panSharpen">panSharpen</a></code>: sharpen a coarse resolution image with a high resolution image (typically panchromatic)
</p>
</li></ul>



<h3>Data Analysis</h3>


<ul>
<li> <p><code><a href="#topic+spectralIndices">spectralIndices</a></code>: calculate a set of predefined multispectral indices like NDVI
</p>
</li>
<li> <p><code><a href="#topic+tasseledCap">tasseledCap</a></code>: tasseled cap transformation
</p>
</li>
<li> <p><code><a href="#topic+sam">sam</a></code>: spectral angle mapper
</p>
</li>
<li> <p><code><a href="#topic+rasterPCA">rasterPCA</a></code>: principal components transform for raster data
</p>
</li>
<li> <p><code><a href="#topic+rasterCVA">rasterCVA</a></code>: change vector analysis
</p>
</li>
<li> <p><code><a href="#topic+unsuperClass">unsuperClass</a></code>: unsupervised classification
</p>
</li>
<li> <p><code><a href="#topic+superClass">superClass</a></code>: supervised classification
</p>
</li>
<li> <p><code><a href="#topic+fCover">fCover</a></code>: fractional cover of coarse resolution imagery based on high resolution classification
</p>
</li></ul>



<h3>Data Display</h3>


<ul>
<li> <p><code><a href="#topic+ggR">ggR</a></code>: single raster layer plotting with ggplot2
</p>
</li>
<li> <p><code><a href="#topic+ggRGB">ggRGB</a></code>: efficient plotting of remote sensing imagery in RGB with ggplot2
</p>
</li></ul>


<hr>
<h2 id='sam'>Spectral Angle Mapper</h2><span id='topic+sam'></span>

<h3>Description</h3>

<p>Calculates the angle in spectral space between pixels and a set of reference spectra (endmembers) for image classification based on spectral similarity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sam(img, em, angles = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sam_+3A_img">img</code></td>
<td>
<p>RasterBrick or RasterStack or SpatRaster. Remote sensing imagery.</p>
</td></tr>
<tr><td><code id="sam_+3A_em">em</code></td>
<td>
<p>Matrix or data.frame with endmembers. Each row should contain the endmember spectrum of a class, i.e. columns correspond to bands in <code>img</code>. It is reccomended to set the rownames to class names.</p>
</td></tr>
<tr><td><code id="sam_+3A_angles">angles</code></td>
<td>
<p>Logical. If <code>TRUE</code> a RasterBrick containing each one layer per endmember will be returned containing the spectral angles.</p>
</td></tr>
<tr><td><code id="sam_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code><a href="terra.html#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each pixel the spectral angle mapper calculates the angle between the vector defined by the pixel values and each endmember vector. The result of this is
one raster layer for each endmember containing the spectral angle. The smaller the spectral angle the more similar a pixel is to a given endmember class.
In a second step one can the go ahead an enforce thresholds of maximum angles or simply classify each pixel to the most similar endmember.
</p>


<h3>Value</h3>

<p>SpatRaster
If <code>angles = FALSE</code> a single Layer will be returned in which each pixel is assigned to the closest endmember class (integer pixel values correspond to row order of <code>em</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)
library(ggplot2)

## Sample endmember spectra
## First location is water, second is open agricultural vegetation
pts &lt;- data.frame(x = c(624720, 627480), y = c(-414690, -411090))
endmembers &lt;- extract(lsat, pts)
rownames(endmembers) &lt;- c("water", "vegetation")

## Calculate spectral angles
lsat_sam &lt;- sam(lsat, endmembers, angles = TRUE)
plot(lsat_sam)

## Classify based on minimum angle
lsat_sam &lt;- sam(lsat, endmembers, angles = FALSE)

ggR(lsat_sam, forceCat = TRUE, geom_raster=TRUE) +
             scale_fill_manual(values = c("blue", "green"), labels = c("water", "vegetation"))
</code></pre>

<hr>
<h2 id='saveRSTBX'>Save and Read RStoolbox Classification Results</h2><span id='topic+saveRSTBX'></span><span id='topic+readRSTBX'></span>

<h3>Description</h3>

<p>Saves objects of classes unsuperClass, superClass, rasterPCA and fCover to
file. Useful to archive the fitted models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saveRSTBX(x, filename, format = "raster", ...)

readRSTBX(filename)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saveRSTBX_+3A_x">x</code></td>
<td>
<p>RStoolbox object of classes c(&quot;fCover&quot;, &quot;rasterPCA&quot;, &quot;superClass&quot;, &quot;unsuperClass&quot;)</p>
</td></tr>
<tr><td><code id="saveRSTBX_+3A_filename">filename</code></td>
<td>
<p>Character. Path and filename. Any file extension will be ignored.</p>
</td></tr>
<tr><td><code id="saveRSTBX_+3A_format">format</code></td>
<td>
<p>Character. Driver to use for the raster file</p>
</td></tr>
<tr><td><code id="saveRSTBX_+3A_...">...</code></td>
<td>
<p>further arguments passed to writeRaster</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output of writeRSTBX will be at least two files written to disk:
a) an .rds file containing the object itself and 
b) the raster file (depending on the driver you choose this can be more than two files).
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>saveRSTBX()</code>: Save RStoolbox object to file
</p>
</li>
<li> <p><code>readRSTBX()</code>: Read files saved with saveRSTBX
</p>
</li></ul>


<h3>Note</h3>

<p>All files must be kept in the same directory to read the full object back into R
by means of readRSTBX. You can move them to another location but you'll have to move *all* of them 
(just like you would with Shapefiles). In case the raster file(s) is missing, readRSTBX will still
return the object but the raster will be missing.
</p>
<p>writeRSTBX and readRSTBX are convenience wrappers around saveRDS, readRDS. This means 
you can read all files created this way also with base functionality as long as you don't move your files.
This is because x$map is a SpatRaster object and hence contains only a static link to the file on disk.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
input &lt;- rlogo
## Create filename
file  &lt;- paste0(tempdir(), "/test", runif(1))
## Run PCA
rpc   &lt;- rasterPCA(input, nSample = 100)
## Save object
saveRSTBX(rpc, filename=file)
## Which files were written?
list.files(tempdir(), pattern = basename(file))
## Re-read files
re_rpc &lt;- readRSTBX(file)
## Remove files
file.remove(list.files(tempdir(), pattern = basename(file), full = TRUE))

## End(Not run)
</code></pre>

<hr>
<h2 id='spectralIndices'>Spectral Indices</h2><span id='topic+spectralIndices'></span>

<h3>Description</h3>

<p>Calculate a suite of multispectral indices such as NDVI, SAVI etc. in an efficient way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spectralIndices(
  img,
  blue = NULL,
  green = NULL,
  red = NULL,
  nir = NULL,
  redEdge1 = NULL,
  redEdge2 = NULL,
  redEdge3 = NULL,
  swir1 = NULL,
  swir2 = NULL,
  swir3 = NULL,
  scaleFactor = 1,
  skipRefCheck = FALSE,
  indices = NULL,
  index = NULL,
  maskLayer = NULL,
  maskValue = 1,
  coefs = list(L = 0.5, G = 2.5, L_evi = 1, C1 = 6, C2 = 7.5, s = 1, swir2ccc = NULL,
    swir2coc = NULL),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spectralIndices_+3A_img">img</code></td>
<td>
<p>SpatRaster, Typically remote sensing imagery, which is to be classified.</p>
</td></tr>
<tr><td><code id="spectralIndices_+3A_blue">blue</code></td>
<td>
<p>Character or integer. Blue band.</p>
</td></tr>
<tr><td><code id="spectralIndices_+3A_green">green</code></td>
<td>
<p>Character or integer. Green band.</p>
</td></tr>
<tr><td><code id="spectralIndices_+3A_red">red</code></td>
<td>
<p>Character or integer. Red band.</p>
</td></tr>
<tr><td><code id="spectralIndices_+3A_nir">nir</code></td>
<td>
<p>Character or integer. Near-infrared band (700-1100nm).</p>
</td></tr>
<tr><td><code id="spectralIndices_+3A_rededge1">redEdge1</code></td>
<td>
<p>Character or integer. Red-edge band (705nm)</p>
</td></tr>
<tr><td><code id="spectralIndices_+3A_rededge2">redEdge2</code></td>
<td>
<p>Character or integer. Red-edge band (740nm)</p>
</td></tr>
<tr><td><code id="spectralIndices_+3A_rededge3">redEdge3</code></td>
<td>
<p>Character or integer. Red-edge band (783nm)</p>
</td></tr>
<tr><td><code id="spectralIndices_+3A_swir1">swir1</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="spectralIndices_+3A_swir2">swir2</code></td>
<td>
<p>Character or integer. Short-wave-infrared band (1400-1800nm).</p>
</td></tr>
<tr><td><code id="spectralIndices_+3A_swir3">swir3</code></td>
<td>
<p>Character or integer. Short-wave-infrared band (2000-2500nm).</p>
</td></tr>
<tr><td><code id="spectralIndices_+3A_scalefactor">scaleFactor</code></td>
<td>
<p>Numeric. Scale factor for the conversion of scaled reflectances to [0,1] value range (applied as reflectance/scaleFactor) Neccesary for calculating EVI/EVI2 with scaled reflectance values.</p>
</td></tr>
<tr><td><code id="spectralIndices_+3A_skiprefcheck">skipRefCheck</code></td>
<td>
<p>Logical. When EVI/EVI2 is to be calculated there is a rough heuristic check, whether the data are inside [0,1]+/-0.5 (after applying a potential <code>scaleFactor</code>).
If there are invalid reflectances, e.g. clouds with reflectance &gt; 1 this check will result in a false positive and skip EVI calculation. Use this argument to skip this check in such cases *iff* you are sure the data and scaleFactor are valid.</p>
</td></tr>
<tr><td><code id="spectralIndices_+3A_indices">indices</code></td>
<td>
<p>Character. One or more spectral indices to calculate (see Details). By default (NULL) all implemented indices given the spectral bands which are provided will be calculated.</p>
</td></tr>
<tr><td><code id="spectralIndices_+3A_index">index</code></td>
<td>
<p>Character. Alias for <code>indices</code>.</p>
</td></tr>
<tr><td><code id="spectralIndices_+3A_masklayer">maskLayer</code></td>
<td>
<p>RasterLayer or SpatRaster containing a mask, e.g. clouds, for which pixels are set to NA. Alternatively a layername or -number can be provided if the mask is part of <code>img</code>.</p>
</td></tr>
<tr><td><code id="spectralIndices_+3A_maskvalue">maskValue</code></td>
<td>
<p>Integer. Pixel value in <code>maskLayer</code> which should be masked in output, i.e. will be set to <code>NA</code> in all calculated indices.</p>
</td></tr>
<tr><td><code id="spectralIndices_+3A_coefs">coefs</code></td>
<td>
<p>List of coefficients (see Details).</p>
</td></tr>
<tr><td><code id="spectralIndices_+3A_...">...</code></td>
<td>
<p>further arguments such as filename etc. passed to <a href="terra.html#topic+writeRaster">writeRaster</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>spectralIndices</code> calculates all indices in one go in C++,  which is more efficient than calculating each index separately (for large rasters).
By default all indices which can be calculated given the specified indices will be calculated. If you don't want all indices, use the <code>indices</code> argument to specify exactly which indices are to be calculated.
See the table bellow for index names and required bands.
</p>
<p>Index values outside the valid value ranges (if such a range exists) will be set to NA. For example a pixel with NDVI &gt; 1 will be set to NA.
</p>

<table>
<tr>
 <td style="text-align: left;"> <strong> Index </strong> </td><td style="text-align: left;"> <strong> Description </strong> </td><td style="text-align: left;"> <strong> Source </strong> </td><td style="text-align: left;"> <strong> Bands </strong> </td><td style="text-align: left;"> <strong> Formula </strong> </td>
</tr>
<tr>
 <td style="text-align: left;"> CLG </td><td style="text-align: left;"> Green-band Chlorophyll Index </td><td style="text-align: left;"> Gitelson2003 </td><td style="text-align: left;"> <code>redEdge3, green</code> </td><td style="text-align: left;"> <code class="reqn">redEdge3/green - 1</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> CLRE </td><td style="text-align: left;"> Red-edge-band Chlorophyll Index </td><td style="text-align: left;"> Gitelson2003 </td><td style="text-align: left;"> <code>redEdge3, redEdge1</code> </td><td style="text-align: left;"> <code class="reqn">redEdge3/redEdge1 - 1</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> CTVI </td><td style="text-align: left;"> Corrected Transformed Vegetation Index </td><td style="text-align: left;"> Perry1984 </td><td style="text-align: left;"> <code>red, nir</code> </td><td style="text-align: left;"> <code class="reqn">(NDVI + 0.5)/sqrt(abs(NDVI + 0.5))</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> DVI </td><td style="text-align: left;"> Difference Vegetation Index </td><td style="text-align: left;"> Richardson1977 </td><td style="text-align: left;"> <code>red, nir</code> </td><td style="text-align: left;"> <code class="reqn">s * nir - red</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> EVI </td><td style="text-align: left;"> Enhanced Vegetation Index </td><td style="text-align: left;"> Huete1999 </td><td style="text-align: left;"> <code>red, nir, blue</code> </td><td style="text-align: left;"> <code class="reqn">G * ((nir - red)/(nir + C1 * red - C2 * blue + L_evi))</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> EVI2 </td><td style="text-align: left;"> Two-band Enhanced Vegetation Index </td><td style="text-align: left;"> Jiang 2008 </td><td style="text-align: left;"> <code>red, nir</code> </td><td style="text-align: left;"> <code class="reqn">G * (nir - red)/(nir + 2.4 * red + 1)</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> GEMI </td><td style="text-align: left;"> Global Environmental Monitoring Index </td><td style="text-align: left;"> Pinty1992 </td><td style="text-align: left;"> <code>red, nir</code> </td><td style="text-align: left;"> <code class="reqn">(((nir^2 - red^2) * 2 + (nir * 1.5) + (red * 0.5))/(nir + red + 0.5)) * (1 - ((((nir^2 - red^2) * 2 + (nir * 1.5) + (red * 0.5))/(nir + red + 0.5)) * 0.25)) - ((red - 0.125)/(1 - red))</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> GNDVI </td><td style="text-align: left;"> Green Normalised Difference Vegetation Index </td><td style="text-align: left;"> Gitelson1998 </td><td style="text-align: left;"> <code>green, nir</code> </td><td style="text-align: left;"> <code class="reqn">(nir - green)/(nir + green)</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> KNDVI </td><td style="text-align: left;"> Kernel Normalised Difference Vegetation Index </td><td style="text-align: left;"> Camps-Valls2021 </td><td style="text-align: left;"> <code>red, nir</code> </td><td style="text-align: left;"> <code class="reqn">tanh(((nir - red)/(nir + red)))^2</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> MCARI </td><td style="text-align: left;"> Modified Chlorophyll Absorption Ratio Index </td><td style="text-align: left;"> Daughtery2000 </td><td style="text-align: left;"> <code>green, red, redEdge1</code> </td><td style="text-align: left;"> <code class="reqn">((redEdge1 - red) - (redEdge1 - green)) * (redEdge1/red)</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> MNDWI </td><td style="text-align: left;"> Modified Normalised Difference Water Index </td><td style="text-align: left;"> Xu2006 </td><td style="text-align: left;"> <code>green, swir2</code> </td><td style="text-align: left;"> <code class="reqn">(green - swir2)/(green + swir2)</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> MSAVI </td><td style="text-align: left;"> Modified Soil Adjusted Vegetation Index </td><td style="text-align: left;"> Qi1994 </td><td style="text-align: left;"> <code>red, nir</code> </td><td style="text-align: left;"> <code class="reqn">nir + 0.5 - (0.5 * sqrt((2 * nir + 1)^2 - 8 * (nir - (2 * red))))</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> MSAVI2 </td><td style="text-align: left;"> Modified Soil Adjusted Vegetation Index 2 </td><td style="text-align: left;"> Qi1994 </td><td style="text-align: left;"> <code>red, nir</code> </td><td style="text-align: left;"> <code class="reqn">(2 * (nir + 1) - sqrt((2 * nir + 1)^2 - 8 * (nir - red)))/2</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> MTCI </td><td style="text-align: left;"> MERIS Terrestrial Chlorophyll Index </td><td style="text-align: left;"> DashAndCurran2004 </td><td style="text-align: left;"> <code>red, redEdge1, redEdge2</code> </td><td style="text-align: left;"> <code class="reqn">(redEdge2 - redEdge1)/(redEdge1 - red)</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> NBRI </td><td style="text-align: left;"> Normalised Burn Ratio Index </td><td style="text-align: left;"> Garcia1991 </td><td style="text-align: left;"> <code>nir, swir3</code> </td><td style="text-align: left;"> <code class="reqn">(nir - swir3)/(nir + swir3)</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> NDREI1 </td><td style="text-align: left;"> Normalised Difference Red Edge Index 1 </td><td style="text-align: left;"> GitelsonAndMerzlyak1994 </td><td style="text-align: left;"> <code>redEdge2, redEdge1</code> </td><td style="text-align: left;"> <code class="reqn">(redEdge2 - redEdge1)/(redEdge2 + redEdge1)</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> NDREI2 </td><td style="text-align: left;"> Normalised Difference Red Edge Index 2 </td><td style="text-align: left;"> Barnes2000 </td><td style="text-align: left;"> <code>redEdge3, redEdge1</code> </td><td style="text-align: left;"> <code class="reqn">(redEdge3 - redEdge1)/(redEdge3 + redEdge1)</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> NDVI </td><td style="text-align: left;"> Normalised Difference Vegetation Index </td><td style="text-align: left;"> Rouse1974 </td><td style="text-align: left;"> <code>red, nir</code> </td><td style="text-align: left;"> <code class="reqn">(nir - red)/(nir + red)</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> NDVIC </td><td style="text-align: left;"> Corrected Normalised Difference Vegetation Index </td><td style="text-align: left;"> Nemani1993 </td><td style="text-align: left;"> <code>red, nir, swir2</code> </td><td style="text-align: left;"> <code class="reqn">(nir - red)/(nir + red) * (1 - ((swir2 - swir2ccc)/(swir2coc - swir2ccc)))</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> NDWI </td><td style="text-align: left;"> Normalised Difference Water Index </td><td style="text-align: left;"> McFeeters1996 </td><td style="text-align: left;"> <code>green, nir</code> </td><td style="text-align: left;"> <code class="reqn">(green - nir)/(green + nir)</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> NDWI2 </td><td style="text-align: left;"> Normalised Difference Water Index </td><td style="text-align: left;"> Gao1996 </td><td style="text-align: left;"> <code>nir, swir2</code> </td><td style="text-align: left;"> <code class="reqn">(nir - swir2)/(nir + swir2)</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> NRVI </td><td style="text-align: left;"> Normalised Ratio Vegetation Index </td><td style="text-align: left;"> Baret1991 </td><td style="text-align: left;"> <code>red, nir</code> </td><td style="text-align: left;"> <code class="reqn">(red/nir - 1)/(red/nir + 1)</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> REIP </td><td style="text-align: left;"> Red Edge Inflection Point </td><td style="text-align: left;"> GuyotAndBarnet1988 </td><td style="text-align: left;"> <code>red, redEdge1, redEdge2, redEdge3</code> </td><td style="text-align: left;"> <code class="reqn">0.705 + 0.35 * ((red + redEdge3)/(2 - redEdge1))/(redEdge2 - redEdge1)</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> RVI </td><td style="text-align: left;"> Ratio Vegetation Index </td><td style="text-align: left;">  </td><td style="text-align: left;"> <code>red, nir</code> </td><td style="text-align: left;"> <code class="reqn">red/nir</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> SATVI </td><td style="text-align: left;"> Soil Adjusted Total Vegetation Index </td><td style="text-align: left;"> Marsett2006 </td><td style="text-align: left;"> <code>red, swir2, swir3</code> </td><td style="text-align: left;"> <code class="reqn">(swir2 - red)/(swir2 + red + L) * (1 + L) - (swir3/2)</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> SAVI </td><td style="text-align: left;"> Soil Adjusted Vegetation Index </td><td style="text-align: left;"> Huete1988 </td><td style="text-align: left;"> <code>red, nir</code> </td><td style="text-align: left;"> <code class="reqn">(nir - red) * (1 + L)/(nir + red + L)</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> SLAVI </td><td style="text-align: left;"> Specific Leaf Area Vegetation Index </td><td style="text-align: left;"> Lymburger2000 </td><td style="text-align: left;"> <code>red, nir, swir2</code> </td><td style="text-align: left;"> <code class="reqn">nir/(red + swir2)</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> SR </td><td style="text-align: left;"> Simple Ratio Vegetation Index </td><td style="text-align: left;"> Birth1968 </td><td style="text-align: left;"> <code>red, nir</code> </td><td style="text-align: left;"> <code class="reqn">nir/red</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> TTVI </td><td style="text-align: left;"> Thiam's Transformed Vegetation Index </td><td style="text-align: left;"> Thiam1997 </td><td style="text-align: left;"> <code>red, nir</code> </td><td style="text-align: left;"> <code class="reqn">sqrt(abs((nir - red)/(nir + red) + 0.5))</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> TVI </td><td style="text-align: left;"> Transformed Vegetation Index </td><td style="text-align: left;"> Deering1975 </td><td style="text-align: left;"> <code>red, nir</code> </td><td style="text-align: left;"> <code class="reqn">sqrt((nir - red)/(nir + red) + 0.5)</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> WDVI </td><td style="text-align: left;"> Weighted Difference Vegetation Index </td><td style="text-align: left;"> Richardson1977 </td><td style="text-align: left;"> <code>red, nir</code> </td><td style="text-align: left;"> <code class="reqn">nir - s * red</code> </td>
</tr>

</table>

<p>Some indices require additional parameters, such as the slope of the soil line which are specified via a list to the <code>coefs</code> argument. 
Although the defaults are sensible values, values like the soil brightnes factor <code>L</code> for SAVI should be adapted depending on the characteristics of the scene.
The coefficients are:
</p>

<table>
<tr>
 <td style="text-align: left;">
<strong>Coefficient</strong> </td><td style="text-align: left;"> <strong>Description</strong> </td><td style="text-align: left;"> <strong>Affected Indices</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>s</code> </td><td style="text-align: left;"> slope of the soil line </td><td style="text-align: left;"> DVI, WDVI </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>L_evi, C1, C2, G</code> </td><td style="text-align: left;"> various </td><td style="text-align: left;"> EVI </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>L</code> </td><td style="text-align: left;"> soil brightness factor </td><td style="text-align: left;"> SAVI, SATVI </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>swir2ccc</code> </td><td style="text-align: left;"> minimum swir2 value (completely closed forest canopy) </td><td style="text-align: left;"> NDVIC </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>swir2coc</code> </td><td style="text-align: left;"> maximum swir2 value (completely open canopy) </td><td style="text-align: left;"> NDVIC </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The wavelength band names are defined following Schowengertd 2007, p10. 
The last column shows exemplarily which Landsat 5 TM bands correspond to which wavelength range definition.
</p>

<table>
<tr>
 <td style="text-align: left;"> <strong> Band </strong> </td><td style="text-align: left;"> <strong> Description </strong> </td><td style="text-align: left;"> <strong> Wavl_min </strong> </td><td style="text-align: left;"> <strong> Wavl_max </strong> </td><td style="text-align: left;"> <strong> Landsat5_Band </strong> </td><td style="text-align: left;"> <strong> Sentinel2_Band </strong> </td>
</tr>
<tr>
 <td style="text-align: left;"> vis </td><td style="text-align: left;"> visible </td><td style="text-align: left;">   400 </td><td style="text-align: left;">    680 </td><td style="text-align: left;"> 1,2,3 </td><td style="text-align: left;"> 2,3,4 </td>
</tr>
<tr>
 <td style="text-align: left;"> red-edge1 </td><td style="text-align: left;"> red-edge1 </td><td style="text-align: left;">   680 </td><td style="text-align: left;">    720 </td><td style="text-align: left;"> - </td><td style="text-align: left;"> 5 </td>
</tr>
<tr>
 <td style="text-align: left;"> red-edge2 </td><td style="text-align: left;"> red-edge2 </td><td style="text-align: left;">   720 </td><td style="text-align: left;">    760 </td><td style="text-align: left;"> - </td><td style="text-align: left;"> 6 </td>
</tr>
<tr>
 <td style="text-align: left;"> red-edge3 </td><td style="text-align: left;"> red-edge3 </td><td style="text-align: left;">   760 </td><td style="text-align: left;">    800 </td><td style="text-align: left;"> - </td><td style="text-align: left;"> 7 </td>
</tr>
<tr>
 <td style="text-align: left;"> nir </td><td style="text-align: left;"> near infra-red </td><td style="text-align: left;">   800 </td><td style="text-align: left;">   1100 </td><td style="text-align: left;"> 4 </td><td style="text-align: left;"> 8/8a </td>
</tr>
<tr>
 <td style="text-align: left;"> swir1 </td><td style="text-align: left;"> short-wave infra-red </td><td style="text-align: left;">  1100 </td><td style="text-align: left;">   1351 </td><td style="text-align: left;"> - </td><td style="text-align: left;"> 9,10 </td>
</tr>
<tr>
 <td style="text-align: left;"> swir2 </td><td style="text-align: left;"> short-wave infra-red </td><td style="text-align: left;">  1400 </td><td style="text-align: left;">   1800 </td><td style="text-align: left;"> 5 </td><td style="text-align: left;"> 11 </td>
</tr>
<tr>
 <td style="text-align: left;"> swir3 </td><td style="text-align: left;"> short-wave infra-red </td><td style="text-align: left;">  2000 </td><td style="text-align: left;">   2500 </td><td style="text-align: left;"> 7 </td><td style="text-align: left;"> 12 </td>
</tr>
<tr>
 <td style="text-align: left;"> mir1 </td><td style="text-align: left;"> mid-wave infra-red </td><td style="text-align: left;">  3000 </td><td style="text-align: left;">   4000 </td><td style="text-align: left;"> - </td><td style="text-align: left;"> - </td>
</tr>
<tr>
 <td style="text-align: left;"> mir2 </td><td style="text-align: left;"> mid-wave infra-red </td><td style="text-align: left;"> 45000 </td><td style="text-align: left;">   5000 </td><td style="text-align: left;"> - </td><td style="text-align: left;"> - </td>
</tr>
<tr>
 <td style="text-align: left;"> tir1 </td><td style="text-align: left;"> thermal infra-red </td><td style="text-align: left;">  8000 </td><td style="text-align: left;">   9500 </td><td style="text-align: left;"> - </td><td style="text-align: left;"> - </td>
</tr>
<tr>
 <td style="text-align: left;"> tir2 </td><td style="text-align: left;"> thermal infra-red </td><td style="text-align: left;"> 10000 </td><td style="text-align: left;"> 140000 </td><td style="text-align: left;"> 6 </td><td style="text-align: left;"> - </td>
</tr>

</table>



<h3>Value</h3>

<p>SpatRaster
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
library(terra)

## Calculate NDVI
ndvi &lt;- spectralIndices(lsat, red = "B3_dn", nir = "B4_dn", indices = "NDVI")
ndvi
ggR(ndvi, geom_raster = TRUE) +
        scale_fill_gradientn(colours = c("black", "white")) 

 
## Calculate all possible indices, given the provided bands 
## Convert DNs to reflectance (required to calculate EVI and EVI2)
mtlFile  &lt;- system.file("external/landsat/LT52240631988227CUB02_MTL.txt", package="RStoolbox")
lsat_ref &lt;- radCor(lsat, mtlFile, method = "apref")

SI &lt;- spectralIndices(lsat_ref, red = "B3_tre", nir = "B4_tre")
plot(SI)

</code></pre>

<hr>
<h2 id='srtm'>SRTM Digital Elevation Model</h2><span id='topic+srtm'></span>

<h3>Description</h3>

<p>DEM for the Landsat example area taken from SRTM v3 tile: s04_w050_1arc_v3.tif
</p>


<h3>Usage</h3>

<pre><code class='language-R'>srtm
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>ggR(srtm)
</code></pre>

<hr>
<h2 id='stackMeta'>Import separate Landsat files into single stack</h2><span id='topic+stackMeta'></span>

<h3>Description</h3>

<p>Reads Landsat MTL or XML metadata files and loads single Landsat Tiffs into a rasterStack.
Be aware that by default stackMeta() does NOT import panchromatic bands nor thermal bands with resolutions != 30m.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stackMeta(file, quantity = "all", category = "image", allResolutions = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stackMeta_+3A_file">file</code></td>
<td>
<p>Character. Path to Landsat MTL metadata (*_MTL.txt) file or an Landsat CDR xml metadata file (*.xml).</p>
</td></tr>
<tr><td><code id="stackMeta_+3A_quantity">quantity</code></td>
<td>
<p>Character vector. Which quantity should be returned. Options: digital numbers ('dn'), top of atmosphere reflectance ('tre'), at surface reflectance ('sre'), brightness temperature ('bt'), spectral index ('index'), all quantities ('all').</p>
</td></tr>
<tr><td><code id="stackMeta_+3A_category">category</code></td>
<td>
<p>Character vector. Which category of data to return. Options 'image': image data, 'pan': panchromatic image, 'index': multiband indices, 'qa' quality flag bands, 'all': all categories.</p>
</td></tr>
<tr><td><code id="stackMeta_+3A_allresolutions">allResolutions</code></td>
<td>
<p>Logical. if <code>TRUE</code> a list will be returned with length = unique spatial resolutions.
This argument was introduced to maintain backward compatibility and will be switched to TRUE in an upcoming release. Please base all new code on terra.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns one single SpatRaster comprising all requested bands.
If <code>allResolutions = TRUE</code> *and* there are different resolution layers (e.g. a 15m panchromatic band along wit 30m imagery) a list of RasterStacks will be returned.
</p>


<h3>Note</h3>

<p>Be aware that by default stackMeta() does NOT import panchromatic bands nor thermal bands with resolutions != 30m. Use the allResolutions argument to import all layers.
Note that nowadays the USGS uses cubic convolution to resample the TIR bands to 30m resolution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example metadata file (MTL)
mtlFile  &lt;- system.file("external/landsat/LT52240631988227CUB02_MTL.txt", package="RStoolbox")

## Read metadata
metaData &lt;- readMeta(mtlFile)
summary(metaData)

## Load rasters based on metadata file
lsat     &lt;- stackMeta(mtlFile)
lsat
</code></pre>

<hr>
<h2 id='superClass'>Supervised Classification</h2><span id='topic+superClass'></span>

<h3>Description</h3>

<p>Supervised classification both for classification and regression mode based on vector training data (points or polygons).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>superClass(
  img,
  trainData,
  valData = NULL,
  responseCol = NULL,
  nSamples = 1000,
  nSamplesV = 1000,
  polygonBasedCV = FALSE,
  trainPartition = NULL,
  model = "rf",
  tuneLength = 3,
  kfold = 5,
  minDist = 2,
  mode = "classification",
  predict = TRUE,
  predType = "raw",
  filename = NULL,
  verbose,
  overwrite = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="superClass_+3A_img">img</code></td>
<td>
<p>SpatRaster. Typically remote sensing imagery, which is to be classified.</p>
</td></tr>
<tr><td><code id="superClass_+3A_traindata">trainData</code></td>
<td>
<p>sf or sp spatial vector data containing the training locations (POINTs,or POLYGONs).</p>
</td></tr>
<tr><td><code id="superClass_+3A_valdata">valData</code></td>
<td>
<p>Ssf or sp spatial vector data containing the validation locations (POINTs,or POLYGONs) (optional).</p>
</td></tr>
<tr><td><code id="superClass_+3A_responsecol">responseCol</code></td>
<td>
<p>Character or integer giving the column in <code>trainData</code>, which contains the response variable. Can be omitted, when <code>trainData</code> has only one column.</p>
</td></tr>
<tr><td><code id="superClass_+3A_nsamples">nSamples</code></td>
<td>
<p>Integer. Number of samples per land cover class. If <code>NULL</code> all pixels covered by training polygons are used (memory intensive!). Ignored if trainData consists of POINTs.</p>
</td></tr>
<tr><td><code id="superClass_+3A_nsamplesv">nSamplesV</code></td>
<td>
<p>Integer. Number of validation samples per land cover class. If <code>NULL</code> all pixels covered by validation polygons are used (memory intensive!). Ignored if valData consists of POINTs.</p>
</td></tr>
<tr><td><code id="superClass_+3A_polygonbasedcv">polygonBasedCV</code></td>
<td>
<p>Logical. If <code>TRUE</code> model tuning during cross-validation is conducted on a per-polygon basis. Use this to deal with overfitting issues. Does not affect training data supplied as SpatialPointsDataFrames.</p>
</td></tr>
<tr><td><code id="superClass_+3A_trainpartition">trainPartition</code></td>
<td>
<p>Numeric. Partition (polygon based) of <code>trainData</code> that goes into the training data set between zero and one. Ignored if <code>valData</code> is provided.</p>
</td></tr>
<tr><td><code id="superClass_+3A_model">model</code></td>
<td>
<p>Character. Which model to use. See <a href="caret.html#topic+train">train</a> for options. Defaults to randomForest ('rf'). In addition to the standard caret models, a maximum likelihood classification is available via <code>model = 'mlc'</code>.</p>
</td></tr>
<tr><td><code id="superClass_+3A_tunelength">tuneLength</code></td>
<td>
<p>Integer. Number of levels for each tuning parameter (see <a href="caret.html#topic+train">train</a> for details).</p>
</td></tr>
<tr><td><code id="superClass_+3A_kfold">kfold</code></td>
<td>
<p>Integer. Number of cross-validation resamples during model tuning.</p>
</td></tr>
<tr><td><code id="superClass_+3A_mindist">minDist</code></td>
<td>
<p>Numeric. Minumum distance between training and validation data,
e.g. <code>minDist=1</code> clips validation polygons to ensure a minimal distance of one pixel (pixel size according to <code>img</code>) to the next training polygon. 
Requires all data to carry valid projection information.</p>
</td></tr>
<tr><td><code id="superClass_+3A_mode">mode</code></td>
<td>
<p>Character. Model type: 'regression' or 'classification'.</p>
</td></tr>
<tr><td><code id="superClass_+3A_predict">predict</code></td>
<td>
<p>Logical. Produce a map (TRUE, default) or only fit and validate the model (FALSE).</p>
</td></tr>
<tr><td><code id="superClass_+3A_predtype">predType</code></td>
<td>
<p>Character. Type of the final output raster. Either &quot;raw&quot; for class predictions or &quot;prob&quot; for class probabilities. Class probabilities are not available for all classification models (<a href="caret.html#topic+predict.train">predict.train</a>).</p>
</td></tr>
<tr><td><code id="superClass_+3A_filename">filename</code></td>
<td>
<p>Path to output file (optional). If <code>NULL</code>, standard raster handling will apply, i.e. storage either in memory or in the raster temp directory.</p>
</td></tr>
<tr><td><code id="superClass_+3A_verbose">verbose</code></td>
<td>
<p>Logical. prints progress and statistics during execution</p>
</td></tr>
<tr><td><code id="superClass_+3A_overwrite">overwrite</code></td>
<td>
<p>logical. Overwrite spatial prediction raster if it already exists.</p>
</td></tr>
<tr><td><code id="superClass_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code><a href="caret.html#topic+train">train</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>SuperClass performs the following steps:
</p>

<ol>
<li><p> Ensure non-overlap between training and validation data. This is neccesary to avoid biased performance estimates.
A minimum distance (<code>minDist</code>) in pixels can be provided to enforce a given distance between training and validation data.
</p>
</li>
<li><p> Sample training coordinates. If <code>trainData</code> (and <code>valData</code> if present) are polygons <code>superClass</code> will calculate the area per polygon and sample
<code>nSamples</code> locations per class within these polygons. The number of samples per individual polygon scales with the polygon area, i.e. the bigger the polygon, the more samples.
</p>
</li>
<li><p> Split training/validation      
If <code>valData</code> was provided (reccomended) the samples from these polygons will be held-out and not used for model fitting but only for validation. 
If <code>trainPartition</code> is provided the trainingPolygons will be divided into training polygons and validation polygons.
</p>
</li>
<li><p> Extract raster data
The predictor values on the sample pixels are extracted from <code>img</code>
</p>
</li>
<li><p> Fit the model. Using caret::train on the sampled training data the <code>model</code> will be fit, 
including parameter tuning (<code>tuneLength</code>) in <code>kfold</code> cross-validation. <code>polygonBasedCV=TRUE</code> will define cross-validation folds based on polygons (reccomended)
otherwise it will be performed on a per-pixel basis.
</p>
</li>
<li><p> Predict the classes of all pixels in <code>img</code> based on the final model.
</p>
</li>
<li><p> Validate the model with the independent validation data.
</p>
</li></ol>



<h3>Value</h3>

<p>A superClass object (effectively a list) containing:
</p>

<ol>
<li><p> $model: the fitted model
</p>
</li>
<li><p> $modelFit: model fit statistics
</p>
</li>
<li><p> $training: indexes of samples used for training
</p>
</li>
<li><p> $validation: list of
</p>

<ol>
<li><p> $performance: performance estimates based on independent validation (confusion matrix etc.)
</p>
</li>
<li><p> $validationSamples: actual pixel coordinates plus reference and predicted values used for validation
</p>
</li>
<li><p> $validationGeometry: validation polygpns (clipped with mindist to training geometries)
</p>
</li></ol>

</li>
<li><p> $map: the predicted raster
</p>
</li>
<li><p> $classMapping: a data.frame containing an integer &lt;-&gt; label mapping
</p>
</li></ol>



<h3>See Also</h3>

<p><code><a href="caret.html#topic+train">train</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(caret)
library(randomForest)
library(e1071)
library(terra)
train &lt;- readRDS(system.file("external/trainingPoints.rds", package="RStoolbox"))

## Plot training data
olpar &lt;- par(no.readonly = TRUE) # back-up par
par(mfrow=c(1,2))
colors &lt;- c("yellow", "green", "deeppink")
plotRGB(rlogo)
plot(train, add = TRUE, col =  colors[train$class], pch = 19)

## Fit classifier (splitting training into 70\% training data, 30\% validation data)
SC       &lt;- superClass(rlogo, trainData = train, responseCol = "class",
model = "rf", tuneLength = 1, trainPartition = 0.7)
SC

## Plots
plot(SC$map, col = colors, legend = FALSE, axes = FALSE, box = FALSE)
legend(1,1, legend = levels(train$class), fill = colors , title = "Classes", 
horiz = TRUE,  bty = "n")
par(olpar) # reset par
</code></pre>

<hr>
<h2 id='tasseledCap'>Tasseled Cap Transformation</h2><span id='topic+tasseledCap'></span>

<h3>Description</h3>

<p>Calculates brightness, greenness and wetness from multispectral imagery.
Currently implemented Landsat 4 TM, Landsat 5 TM, Landsat 7ETM+, Landsat 8 OLI, MODIS, QuickBird, Spot5 and RapidEye.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tasseledCap(img, sat, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tasseledCap_+3A_img">img</code></td>
<td>
<p>RasterBrick or RasterStack or SpatRaster. Input image. Band order must correspond to sensor specifications (see Details and Examples)</p>
</td></tr>
<tr><td><code id="tasseledCap_+3A_sat">sat</code></td>
<td>
<p>Character. Sensor; one of: c(&quot;Landsat4TM&quot;, &quot;Landsat5TM&quot;, &quot;Landsat7ETM&quot;, &quot;Landsat8OLI&quot;, &quot;MODIS&quot;, &quot;QuickBird&quot;, &quot;Spot5&quot;, &quot;RapidEye&quot;). Case is irrelevant.</p>
</td></tr>
<tr><td><code id="tasseledCap_+3A_...">...</code></td>
<td>
<p>Further arguments passed to writeRaster.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently implemented: Landsat 4 TM, Landsat 5 TM, Landsat 7ETM+, Landsat 8 OLI, MODIS, QuickBird, Spot5, RapdiEye.
Input data must be in top of atmosphere reflectance.
Moreover, bands must be provided in ascending order as listed in the table below. 
Irrelevant bands, such as Landsat Thermal Bands or QuickBird/Spot5 Panchromatic Bands must be omitted.
Required bands are:
</p>

<table>
<tr>
 <td style="text-align: right;">
 sat </td><td style="text-align: right;"> bands </td><td style="text-align: right;"> coefficients </td><td style="text-align: left;"> data unit</td>
</tr>
<tr>
 <td style="text-align: right;">
 Landsat4TM </td><td style="text-align: right;"> 1,2,3,4,5,7 </td><td style="text-align: right;"> Crist 1985 </td><td style="text-align: left;"> reflectance </td>
</tr>
<tr>
 <td style="text-align: right;">
 Landsat5TM  </td><td style="text-align: right;"> 1,2,3,4,5,7 </td><td style="text-align: right;"> Crist 1985 </td><td style="text-align: left;"> reflectance </td>
</tr>
<tr>
 <td style="text-align: right;">
 Landsat7ETM </td><td style="text-align: right;"> 1,2,3,4,5,7 </td><td style="text-align: right;"> Huang 2002 </td><td style="text-align: left;"> reflectance </td>
</tr>
<tr>
 <td style="text-align: right;">
 Landsat8OLI </td><td style="text-align: right;"> 2,3,4,5,6,7 </td><td style="text-align: right;"> Baig 2014 </td><td style="text-align: left;"> reflectance </td>
</tr>
<tr>
 <td style="text-align: right;">
 MODIS </td><td style="text-align: right;"> 1,2,3,4,5,6,7 </td><td style="text-align: right;"> Lobser 2007 </td><td style="text-align: left;"> reflectance </td>
</tr>
<tr>
 <td style="text-align: right;">
 QuickBird </td><td style="text-align: right;"> 2,3,4,5 </td><td style="text-align: right;"> Yarbrough 2005 </td><td style="text-align: left;"> reflectance </td>
</tr>
<tr>
 <td style="text-align: right;">
 Spot5 </td><td style="text-align: right;"> 2,3,4,5 </td><td style="text-align: right;"> Ivtis 2008 </td><td style="text-align: left;"> reflectance </td>
</tr>
<tr>
 <td style="text-align: right;">
 RapidEye </td><td style="text-align: right;">  1,2,3,4,5 </td><td style="text-align: right;"> Schoenert 2014 </td><td style="text-align: left;"> reflectance </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>Returns a SpatRaster with the thee bands: brigthness, greenness, and (soil) wetness.
</p>


<h3>References</h3>

<p>Crist (1985) &quot;A TM Tasseled Cap Equivalent Transformation for Reflectance Factor Data.&quot; Remote Sensing of Environment 17 (3): 301-306
</p>
<p>Huang et al. (2002) &quot;Derivation of a Tasselled Cap Transformation Based on Landsat 7 At-Satellite Reflectance.&quot; International Journal of Remote Sensing 23 (8): 1741-1748
</p>
<p>Baig et al. (2014) &quot;Derivation of a Tasselled Cap Transformation Based on Landsat 8 At-Satellite Reflectance.&quot; Remote Sensing Letters 5 (5): 423-431.
</p>
<p>Lobser et al. (2007) &quot;MODIS Tasselled Cap: Land Cover Characteristics Expressed through Transformed MODIS Data.&quot; International Journal of Remote Sensing 28 (22): 5079-5101.
</p>
<p>Yarbrough et al. (2005) &quot;QuickBird 2 tasseled cap transform coefficients: a comparison of derivation methods.&quot; Pecora 16 Global Priorities in Land Remote Sensing: 23-27.
</p>
<p>Ivits et al. (2008) &quot;Orthogonal transformation of segmented SPOT5 images.&quot; Photogrammetric Engineering &amp; Remote Sensing 74 (11): 1351-1364.
</p>
<p>Schoenert et al. (2014) &quot;Derivation of tasseled cap coefficients for RapidEye data.&quot; Earth Resources and Environmental Remote Sensing/GIS Applications V (9245): 92450Qs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)

## Run tasseled cap (exclude thermal band 6)
lsat_tc &lt;- tasseledCap(lsat[[c(1:5,7)]], sat = "Landsat5TM")
lsat_tc
plot(lsat_tc)
</code></pre>

<hr>
<h2 id='topCor'>Topographic Illumination Correction</h2><span id='topic+topCor'></span>

<h3>Description</h3>

<p>account and correct for changes in illumination due to terrain elevation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>topCor(
  img,
  dem,
  metaData,
  solarAngles = c(),
  method = "C",
  stratImg = NULL,
  nStrat = 5,
  illu,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="topCor_+3A_img">img</code></td>
<td>
<p>SpatRaster. Imagery to correct</p>
</td></tr>
<tr><td><code id="topCor_+3A_dem">dem</code></td>
<td>
<p>SpatRaster. Either a digital elevation model as a RasterLayer or a RasterStack/Brick with pre-calculated slope and aspect (see <a href="terra.html#topic+terrain">terrain</a>) in which case the layers must be named 'slope' and 'aspect'.
Must have the same dimensions as <code>img</code>.</p>
</td></tr>
<tr><td><code id="topCor_+3A_metadata">metaData</code></td>
<td>
<p>Character, ImageMetaData. Either a path to a Landsat meta-data file (MTL) or an ImageMetaData object (see <a href="#topic+readMeta">readMeta</a>)</p>
</td></tr>
<tr><td><code id="topCor_+3A_solarangles">solarAngles</code></td>
<td>
<p>Numeric vector containing sun azimuth and sun zenith (in radians and in that order). Not needed if metaData is provided</p>
</td></tr>
<tr><td><code id="topCor_+3A_method">method</code></td>
<td>
<p>Character. One of c(&quot;cos&quot;, &quot;avgcos&quot;, &quot;minnaert&quot;, &quot;C&quot;, &quot;stat&quot;, &quot;illu&quot;). Choosing 'illu' will return only the local illumination map.</p>
</td></tr>
<tr><td><code id="topCor_+3A_stratimg">stratImg</code></td>
<td>
<p>RasterLayer or SpatRaster to define strata, e.g. NDVI. Or the string 'slope' in which case stratification will be on <code>nStrat</code> slope classes. Only relevant if <code>method = 'minnaert'</code>.</p>
</td></tr>
<tr><td><code id="topCor_+3A_nstrat">nStrat</code></td>
<td>
<p>Integer. Number of bins or quantiles to stratify by. If a bin has less than 50 samples it will be merged with the next bin. Only relevant if <code>method = 'minnaert'</code>.</p>
</td></tr>
<tr><td><code id="topCor_+3A_illu">illu</code></td>
<td>
<p>SpatRaster. Optional pre-calculated ilumination map. Run topCor with method=&quot;illu&quot; to calculate an ilumination map</p>
</td></tr>
<tr><td><code id="topCor_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="terra.html#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For detailed discussion of the various approaches please see Riano et al. (2003).
</p>
<p>The minnaert correction can be stratified for different landcover characteristics. If <code>stratImg = 'slope'</code> the analysis is stratified by the slope, 
i.e. the slope values are divided into <code>nStrat</code> classes and the correction coefficient k is calculated and applied separately for each slope class.
An alternative could be to stratify by a vegetation index in which case an additional raster layer has to be provided via the <code>stratImg</code> argument.
</p>


<h3>Value</h3>

<p>SpatRaster
</p>


<h3>References</h3>

<p>Riano et al. (2003) Assessment of different topographic correction in Landsat-TM data for mapping vegetation types. IEEE Transactions on Geoscience and Remote Sensing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load example data
metaData &lt;- system.file("external/landsat/LT52240631988227CUB02_MTL.txt", package="RStoolbox")
metaData &lt;- readMeta(metaData)

## Minnaert correction, solar angles from metaData
lsat_minnaert &lt;- topCor(lsat, dem = srtm, metaData = metaData, method = "minnaert")

## C correction, solar angles provided manually
lsat_C &lt;- topCor(lsat, dem = srtm, solarAngles = c(1.081533, 0.7023922), method = "C")

</code></pre>

<hr>
<h2 id='unsuperClass'>Unsupervised Classification</h2><span id='topic+unsuperClass'></span>

<h3>Description</h3>

<p>Unsupervised clustering of SpatRaster data using kmeans clustering
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unsuperClass(
  img,
  nSamples = 10000,
  nClasses = 5,
  nStarts = 25,
  nIter = 100,
  norm = FALSE,
  clusterMap = TRUE,
  algorithm = "Hartigan-Wong",
  output = "classes",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unsuperClass_+3A_img">img</code></td>
<td>
<p>SpatRaster.</p>
</td></tr>
<tr><td><code id="unsuperClass_+3A_nsamples">nSamples</code></td>
<td>
<p>Integer. Number of random samples to draw to fit cluster map. Only relevant if clusterMap = TRUE.</p>
</td></tr>
<tr><td><code id="unsuperClass_+3A_nclasses">nClasses</code></td>
<td>
<p>Integer. Number of classes.</p>
</td></tr>
<tr><td><code id="unsuperClass_+3A_nstarts">nStarts</code></td>
<td>
<p>Integer. Number of random starts for kmeans algorithm.</p>
</td></tr>
<tr><td><code id="unsuperClass_+3A_niter">nIter</code></td>
<td>
<p>Integer. Maximal number of iterations allowed.</p>
</td></tr>
<tr><td><code id="unsuperClass_+3A_norm">norm</code></td>
<td>
<p>Logical. If <code>TRUE</code> will normalize img first using <a href="#topic+normImage">normImage</a>. Normalizing is beneficial if your predictors have different scales.</p>
</td></tr>
<tr><td><code id="unsuperClass_+3A_clustermap">clusterMap</code></td>
<td>
<p>Logical. Fit kmeans model to a random subset of the img (see Details).</p>
</td></tr>
<tr><td><code id="unsuperClass_+3A_algorithm">algorithm</code></td>
<td>
<p>Character. <a href="stats.html#topic+kmeans">kmeans</a> algorithm. One of c(&quot;Hartigan-Wong&quot;, &quot;Lloyd&quot;, &quot;MacQueen&quot;)</p>
</td></tr>
<tr><td><code id="unsuperClass_+3A_output">output</code></td>
<td>
<p>Character. Either 'classes' (kmeans class; default) or 'distances' (euclidean distance to each cluster center).</p>
</td></tr>
<tr><td><code id="unsuperClass_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <a href="terra.html#topic+writeRaster">writeRaster</a>, e.g. filename</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Clustering is done using <code><a href="stats.html#topic+kmeans">kmeans</a></code>. This can be done for all pixels of the image (<code>clusterMap=FALSE</code>), however this can be slow and is
not memory safe. Therefore if you have large raster data (&gt; memory), as is typically the case with remote sensing imagery it is advisable to choose clusterMap=TRUE (the default).
This means that a kmeans cluster model is calculated based on a random subset of pixels (<code>nSamples</code>). Then the distance of *all* pixels to the cluster centers 
is calculated in a stepwise fashion using <code><a href="terra.html#topic+predict">predict</a></code>. Class assignment is based on minimum euclidean distance to the cluster centers.
</p>
<p>The solution of the kmeans algorithm often depends on the initial configuration of class centers which is chosen randomly. 
Therefore, kmeans is usually run with multiple random starting configurations in order to find a convergent solution from different starting configurations.
The <code>nStarts</code> argument allows to specify how many random starts are conducted.
</p>


<h3>Value</h3>

<p>Returns an RStoolbox::unsuperClass object, which is a list containing the kmeans model ($model) and the raster map ($map).
For output = &quot;classes&quot;, $map contains a SpatRaster with discrete classes (kmeans clusters); for output = &quot;distances&quot; $map contains
a SpatRaster, with 'nClasses' layers, where each layer maps the euclidean distance to the corresponding class centroid.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(terra)
input &lt;- rlogo

## Plot 
olpar &lt;- par(no.readonly = TRUE) # back-up par
par(mfrow=c(1,2))
plotRGB(input)

## Run classification
set.seed(25)
unC &lt;- unsuperClass(input, nSamples = 100, nClasses = 5, nStarts = 5)
unC

## Plots
colors &lt;- rainbow(5)
plot(unC$map, col = colors, legend = FALSE, axes = FALSE, box = FALSE)
legend(1,1, legend = paste0("C",1:5), fill = colors, title = "Classes", horiz = TRUE,  bty = "n")

## Return the distance of each pixel to each class centroid
unC &lt;- unsuperClass(input, nSamples = 100, nClasses = 3, output = "distances")
unC

ggR(unC$map, 1:3, geom_raster = TRUE)

par(olpar) # reset par

## End(Not run)
</code></pre>

<hr>
<h2 id='validateMap'>Map accuracy assessment</h2><span id='topic+validateMap'></span>

<h3>Description</h3>

<p>validate a map from a classification or regression model. This can be useful to update the accuracy assessment after filtering, e.g. for a minimum mapping unit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validateMap(
  map,
  valData,
  responseCol,
  nSamplesV = 500,
  mode = "classification",
  classMapping = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validateMap_+3A_map">map</code></td>
<td>
<p>RasterLayer or SpatRaster. The classified map.</p>
</td></tr>
<tr><td><code id="validateMap_+3A_valdata">valData</code></td>
<td>
<p>sf object with validation data (POLYGONs or POINTs).</p>
</td></tr>
<tr><td><code id="validateMap_+3A_responsecol">responseCol</code></td>
<td>
<p>Character. Column containing the validation data in attribute table of <code>valData</code>.</p>
</td></tr>
<tr><td><code id="validateMap_+3A_nsamplesv">nSamplesV</code></td>
<td>
<p>Integer. Number of pixels to sample for validation (only applies to polygons).</p>
</td></tr>
<tr><td><code id="validateMap_+3A_mode">mode</code></td>
<td>
<p>Character. Either 'classification' or 'regression'.</p>
</td></tr>
<tr><td><code id="validateMap_+3A_classmapping">classMapping</code></td>
<td>
<p>optional data.frame with columns <code>'class'</code> and <code>'classID'</code> defining the mapping from raster integers to class names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a structured list includng the preformance and confusion-matrix of your then validated input data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(caret)
library(terra)

## Training data
poly     &lt;- readRDS(system.file("external/trainingPolygons.rds", package="RStoolbox"))

## Split training data in training and validation set (50%-50%)
splitIn   &lt;- createDataPartition(poly$class, p = .5)[[1]]
train &lt;- poly[splitIn,]
val   &lt;- poly[-splitIn,]

## Classify (deliberately poorly)
sc &lt;- superClass(lsat, trainData = train, responseCol = "class", nSamples = 50, model = "mlc")

## Polish map with majority filter

polishedMap &lt;- focal(sc$map, matrix(1,3,3), fun = modal) 

## Validation
## Before filtering
val0 &lt;- validateMap(sc$map, valData = val, responseCol = "class",
                            classMapping = sc$classMapping)
## After filtering
val1 &lt;- validateMap(polishedMap, valData = val, responseCol = "class",
                             classMapping = sc$classMapping)
</code></pre>

<hr>
<h2 id='writeSLI'>Write ENVI spectral libraries</h2><span id='topic+writeSLI'></span>

<h3>Description</h3>

<p>Writes binary ENVI spectral library files (sli) with accompanying header (.sli.hdr) files OR ASCII spectral library files in ENVI format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeSLI(
  x,
  path,
  wavl.units = "Micrometers",
  scaleF = 1,
  mode = "bin",
  endian = .Platform$endian
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeSLI_+3A_x">x</code></td>
<td>
<p>data.frame with first column containing wavelengths and all other columns containing spectra.</p>
</td></tr>
<tr><td><code id="writeSLI_+3A_path">path</code></td>
<td>
<p>path to spectral library file to be created.</p>
</td></tr>
<tr><td><code id="writeSLI_+3A_wavl.units">wavl.units</code></td>
<td>
<p>wavelength units. Defaults to Micrometers. Nanometers is another typical option.</p>
</td></tr>
<tr><td><code id="writeSLI_+3A_scalef">scaleF</code></td>
<td>
<p>optional reflectance scaling factor. Defaults to 1.</p>
</td></tr>
<tr><td><code id="writeSLI_+3A_mode">mode</code></td>
<td>
<p>character string specifying output file type. Must be one of <code>"bin"</code> for binary .sli files or <code>"ASCII"</code> for ASCII ENVI plot files.</p>
</td></tr>
<tr><td><code id="writeSLI_+3A_endian">endian</code></td>
<td>
<p>character. Optional. By default the endian is determined based on the platform, but can be forced manually by setting it to either &quot;little&quot; or &quot;big&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>ENVI spectral libraries with ending .sli are binary arrays with spectra saved in rows.
</p>


<h3>Value</h3>

<p>Does not return anything, write the SLI file directly to your drive for where your specified your path parameter
</p>


<h3>See Also</h3>

<p><code><a href="#topic+readSLI">readSLI</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Example data
sliFile &lt;- system.file("external/vegSpec.sli", package="RStoolbox")
sliTmpFile &lt;- paste0(tempdir(),"/vegetationSpectra.sli") 

## Read spectral library
sli &lt;- readSLI(sliFile)
head(sli)
plot(sli[,1:2], col = "orange", type = "l")
lines(sli[,c(1,3)], col = "green")
 
## Write to binary spectral library
writeSLI(sli, path = sliTmpFile)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
