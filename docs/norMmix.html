<!DOCTYPE html><html lang="en"><head><title>Help for package norMmix</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {norMmix}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#clr1'><p>Centered Log Ratio Transformation and Inverse</p></a></li>
<li><a href='#dfnMm'><p>Number of Free Parameters of Multivariate Normal Mixture Models</p></a></li>
<li><a href='#dnorMmix'><p>Density from Multivariate Normal Mixture Distribution</p></a></li>
<li><a href='#ellipsePts'><p>Compute Points on Bivariate Gaussian Confidence Ellipse</p></a></li>
<li><a href='#ldl'><p>LDL' Cholesky Decomposition</p></a></li>
<li><a href='#llmvtnorm'><p>Log-Likelihood of Multivariate Normal Mixture Relying on <code>mvtnorm::dmvnorm</code></p></a></li>
<li><a href='#llnorMmix'><p>Log-likelihood of parameter vector given data</p></a></li>
<li><a href='#MarronWand'><p>Marron-Wand-like Specific Multivariate Normal Mixture 'norMmix' Objects</p></a></li>
<li><a href='#nMm2par'><p>Multivariate Normal Mixture Model to parameter for MLE</p></a></li>
<li><a href='#nor1toMmix'><p>Cast nor1mix object as norMmix.</p></a></li>
<li><a href='#norMmix'><p>Constructor for Multivariate Normal Mixture Objects</p></a></li>
<li><a href='#norMmixMLE'><p>Maximum Likelihood Estimation for Multivariate Normal Mixtures</p></a></li>
<li><a href='#npar'><p>Degrees of freedom of (Fitted) Multivariate Normal Mixtures</p></a></li>
<li><a href='#par2nMm'><p>Transform Parameter Vector to Multivariate Normal Mixture</p></a></li>
<li><a href='#plot.norMmix'><p>Plot Method for &quot;norMmix&quot; Objects</p></a></li>
<li><a href='#rnorMmix'><p>Random Sample from Multivariate Normal Mixture Distribution</p></a></li>
<li><a href='#sllnorMmix'><p>Simple wrapper for Log-Likelihood Function or Multivariate Normal Mixture</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.2-0</td>
</tr>
<tr>
<td>Title:</td>
<td>Direct MLE for Multivariate Normal Mixture Distributions</td>
</tr>
<tr>
<td>Description:</td>
<td>Multivariate Normal (i.e. Gaussian) Mixture Models (S3) Classes.
    Fitting models to data using 'MLE' (maximum likelihood estimation) for
    multivariate normal mixtures via smart parametrization using the 'LDL'
    (Cholesky) decomposition, see McLachlan and Peel (2000, ISBN:9780471006268),
    Celeux and Govaert (1995) &lt;<a href="https://doi.org/10.1016%2F0031-3203%2894%2900125-6">doi:10.1016/0031-3203(94)00125-6</a>&gt;.</td>
</tr>
<tr>
<td>Imports:</td>
<td>cluster, MASS, mvtnorm, mclust, sfsmisc</td>
</tr>
<tr>
<td>Suggests:</td>
<td>nor1mix, Matrix, testthat (&ge; 2.1.0), knitr, rmarkdown</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-07 21:12:47 UTC; trn</td>
</tr>
<tr>
<td>Author:</td>
<td>Nicolas Trutmann [aut, cre],
  Martin Maechler <a href="https://orcid.org/0000-0002-8685-9910"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, ths] (based on 'nor1mix')</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nicolas Trutmann &lt;nicolas.trutmann@gmx.ch&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-09 06:40:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='clr1'>Centered Log Ratio Transformation and Inverse</h2><span id='topic+clr1'></span><span id='topic+clr1inv'></span>

<h3>Description</h3>


<p>The centered log ratio transformation is Maechler's solution to allowing
unconstrained mixture weights optimization.
</p>
<p>It has been inspired by Aitchison's <b>c</b>entered <b>l</b>og <b>r</b>atio,
see also CRAN package <a href="https://CRAN.R-project.org/package=compositions"><span class="pkg">compositions</span></a>' <code><a href="compositions.html#topic+clr">clr</a>()</code>, and typically
other references on modelling proportions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clr1(w)
clr1inv(lp)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clr1_+3A_w">w</code></td>
<td>
<p>numeric vector of length <code class="reqn">k</code>, say, of mixture weights, i.e.,
non-negative and summing to one.</p>
</td></tr>
<tr><td><code id="clr1_+3A_lp">lp</code></td>
<td>
<p>numeric vector of length <code class="reqn">k-1</code> clr-transformed weights.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Aitchison's clr transformation is slightly different, as it does
<em>not</em> drop one coordinate, as we do.  Hence the extra &lsquo;1&rsquo; in
the name of our version.
</p>


<h3>Value</h3>

<p>a numeric vector of length <code class="reqn">k-1</code> or <code class="reqn">k</code>, see above.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>References</h3>

<p>Aitchison, J., 1986.
<em>The Statistical Analysis of Compositional Data</em>
Monographs on Statistics and Applied Probability. Chapman &amp; Hall Ltd., London (UK).
</p>
<p>More in the CRAN package <a href="https://CRAN.R-project.org/package=compositions"><span class="pkg">compositions</span></a> vignette
&lsquo;<span class="file">UsingCompositions.pdf</span>&rsquo; 
</p>


<h3>See Also</h3>

<p>The first implementation of these was in <a href="https://CRAN.R-project.org/package=nor1mix"><span class="pkg">nor1mix</span></a>, June 2019, in its
<code><a href="nor1mix.html#topic+par2norMix">par2norMix</a>()</code> and
<code><a href="nor1mix.html#topic+nM2par">nM2par</a>()</code> functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Apart from error checking and very large number cases, the R implementation is simply
..clr1 &lt;- function (w) {
  ln &lt;- log(w)
  ln[-1L] - mean(ln)
}

## and its inverse
..clr1inv &lt;- function(lp) {
  p1 &lt;- exp(c(-sum(lp), lp))
  p1/sum(p1)
}

lp &lt;- clr1( (1:3)/6 )
clr1inv(lp)
stopifnot(all.equal(clr1inv(lp), (1:3)/6))

for(n in 1:100) {
   k &lt;- 2 + rpois(1, 3) # #{components}
   lp &lt;- rnorm(k-1) # arbitrary unconstrained
   ## clr1() and clr1inv() are inverses :
   stopifnot(all.equal(lp, clr1(clr1inv(lp))))
}

wM &lt;- clr1inv(c(720,720,720))
w2 &lt;- clr1inv(c(720,718,717))
stopifnot(is.finite(wM), all.equal(wM, c(0, 1/3, 1/3, 1/3))
        , is.finite(w2), all.equal(w2, c(0, 0.84379473, 0.1141952, 0.042010066))
         )
</code></pre>

<hr>
<h2 id='dfnMm'>Number of Free Parameters of Multivariate Normal Mixture Models</h2><span id='topic+dfnMm'></span>

<h3>Description</h3>

<p><code><a href="#topic+npar">npar</a>()</code> returns an integer (vector, if <code>p</code> or <code>k</code> is)
with the number of free parameters of the corresponding model, which is
also the <code><a href="base.html#topic+length">length</a>(.)</code> of the parameter vector in our
parametrization, see <code><a href="#topic+nMm2par">nMm2par</a>()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dfnMm(k, p, model = c("EII","VII","EEI","VEI","EVI",
	               "VVI","EEE","VEE","EVV","VVV"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dfnMm_+3A_k">k</code></td>
<td>
<p>number of mixture components</p>
</td></tr>
<tr><td><code id="dfnMm_+3A_p">p</code></td>
<td>
<p>dimension of data space, i.e., number of variables (aka &ldquo;features&rdquo;).</p>
</td></tr>
<tr><td><code id="dfnMm_+3A_model">model</code></td>
<td>
<p>a <code><a href="base.html#topic+character">character</a></code> string.  One of the 10 models
above, see also &lsquo;Description&rsquo;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer. degrees of freedom of a model with specified dimensions, components and model type.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(m &lt;- eval(formals(dfnMm)$model)) # list of 10 models w/ differing Sigma
# A nice table for a given 'p'  and all models, all k in 1:8
sapply(m, dfnMm, k=setNames(,1:8), p = 20)
</code></pre>

<hr>
<h2 id='dnorMmix'>Density from Multivariate Normal Mixture Distribution</h2><span id='topic+dnorMmix'></span>

<h3>Description</h3>

<p>Calculates the probability density function of the multivariate normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dnorMmix(x, nMm)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dnorMmix_+3A_x">x</code></td>
<td>
<p>a vector or matrix of multivariate observations</p>
</td></tr>
<tr><td><code id="dnorMmix_+3A_nmm">nMm</code></td>
<td>
<p>a <code>"<a href="#topic+norMmix">norMmix</a>"</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the density of <code>nMm</code> at point <code>x</code>. Iterates over components of the
mixture and returns weighted sum of <code><a href="mvtnorm.html#topic+dmvnorm">dmvnorm</a></code>.
</p>


<h3>Author(s)</h3>

<p>Nicolas Trutmann</p>


<h3>See Also</h3>

<p><code><a href="#topic+rnorMmix">rnorMmix</a></code>
</p>

<hr>
<h2 id='ellipsePts'>Compute Points on Bivariate Gaussian Confidence Ellipse</h2><span id='topic+ellipsePts'></span>

<h3>Description</h3>

<p>From 2-dimensional mean vector <code>mu</code><code class="reqn">= \mu</code> and 2x2 covariance matrix
<code>sigma</code><code class="reqn">= \Sigma</code>, compute <code>npoints</code> equi-angular points on
the <code>1-alpha</code><code class="reqn"> = 1-\alpha</code> confidence ellipse of bivariate
Gaussian (normal) distribution <code class="reqn">\mathcal{N}_2(\mu,\Sigma)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ellipsePts(mu, sigma, npoints, alpha = 0.05, r = sqrt(qchisq(1 - alpha, df = 2)))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ellipsePts_+3A_mu">mu</code></td>
<td>
<p>mean vector (<code><a href="base.html#topic+numeric">numeric</a></code> of length 2).</p>
</td></tr>
<tr><td><code id="ellipsePts_+3A_sigma">sigma</code></td>
<td>
<p>2x2 <code><a href="base.html#topic+matrix">matrix</a></code>, the covariance matrix.</p>
</td></tr>
<tr><td><code id="ellipsePts_+3A_npoints">npoints</code></td>
<td>
<p>integer specifying the number of points to be computed.</p>
</td></tr>
<tr><td><code id="ellipsePts_+3A_alpha">alpha</code></td>
<td>
<p>confidence level such that the ellipse should contain
1-alpha of the mass.</p>
</td></tr>
<tr><td><code id="ellipsePts_+3A_r">r</code></td>
<td>
<p>radius of the ellipse, typically computed from <code>alpha</code>, via
the default value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric matrix of dimension <code>npoints x 2</code>, containing the
x-y-coordinates of the ellipse points.
</p>


<h3>Note</h3>

<p>This has been inspired by package <a href="https://CRAN.R-project.org/package=mixtools"><span class="pkg">mixtools</span></a>'s <code><a href="mixtools.html#topic+ellipse">ellipse</a>()</code>
function.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>Examples</h3>

<pre><code class='language-R'>xy &lt;- ellipsePts(c(10, 100), sigma = cbind(c(4, 7), c(7, 28)),  npoints = 20)
plot(xy, type = "b", col=2, cex=2,
     main="ellipsePts(mu = (10,100), sigma, npoints = 20)")
points(10, 100, col=3, cex=3, pch=3)
text  (10, 100, col=3, expression(mu == "mu"), adj=c(-.1, -.1))

stopifnot(is.matrix(xy), dim(xy) == c(20, 2))
</code></pre>

<hr>
<h2 id='ldl'>LDL' Cholesky Decomposition</h2><span id='topic+ldl'></span>

<h3>Description</h3>

<p>Simple (but not too simple) <span class="rlang"><b>R</b></span> implementation of the (square root free)
<code class="reqn">LDL'</code> Choleksy decomposition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ldl(m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ldl_+3A_m">m</code></td>
<td>
<p>positive semi-definite square matrix, say of dimension <code class="reqn">n
      \times n</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="base.html#topic+list">list</a></code> with two components
</p>
<table role = "presentation">
<tr><td><code>L</code></td>
<td>
<p>a lower triangular matrix with diagonal entries 1.</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>numeric vector, the <em>diagonal</em>
<code class="reqn">d_{1,1},d_{2,2},\dots,d_{n,n}</code> of the diagonal matrix <code class="reqn">D</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="base.html#topic+chol">chol</a>()</code> in base <span class="rlang"><b>R</b></span>, or also a &ldquo;generalized LDL&rdquo;
decomposition, the Bunch-Kaufman, <code><a href="Matrix.html#topic+BunchKaufman">BunchKaufman</a>()</code>
in (&lsquo;Recommended&rsquo;) package <a href="https://CRAN.R-project.org/package=Matrix"><span class="pkg">Matrix</span></a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(L &lt;- rbind(c(1,0,0), c(3,1,0), c(-4,5,1)))
D &lt;- c(4,1,9)
FF &lt;- L %*% diag(D) %*% t(L)
FF
LL &lt;- ldl(FF)
stopifnot(all.equal(L, LL$L),
          all.equal(D, LL$D))

## rank deficient :
FF0 &lt;- L %*% diag(c(4,0,9)) %*% t(L)
((L0 &lt;- ldl(FF0))) #  !! now fixed with the  if(Di == 0) test
## With the "trick", it works:
stopifnot(all.equal(FF0,
                    L0$L %*% diag(L0$D) %*% t(L0$L)))
## [hint: the LDL' is no longer unique when the matrix is singular]

system.time(for(i in 1:10000) ldl(FF) ) # ~ 0.2 sec

(L &lt;- rbind(c( 1, 0, 0, 0),
            c( 3, 1, 0, 0),
            c(-4, 5, 1, 0),
            c(-2,20,-7, 1)))
D &lt;- c(4,1, 9, 0.5)
F4 &lt;- L %*% diag(D) %*% t(L)
F4
L4 &lt;- ldl(F4)
stopifnot(all.equal(L, L4$L),
          all.equal(D, L4$D))

system.time(for(i in 1:10000) ldl(F4) ) # ~ 0.16 sec

## rank deficient :
F4.0 &lt;- L %*% diag(c(4,1,9,0)) %*% t(L)
((L0 &lt;- ldl(F4.0)))
stopifnot(all.equal(F4.0,
                    L0$L %*% diag(L0$D) %*% t(L0$L)))

F4_0 &lt;- L %*% diag(c(4,1,0,9)) %*% t(L)
((L0 &lt;- ldl(F4_0)))
stopifnot(all.equal(F4_0,
                    L0$L %*% diag(L0$D) %*% t(L0$L)))

## Large
mkLDL &lt;- function(n, rF = function(n) sample.int(n), rFD = function(n) 1+ abs(rF(n))) {
    L &lt;- diag(nrow=n)
    L[lower.tri(L)] &lt;- rF(n*(n-1)/2)
    list(L = L, D = rFD(n))
}

(LD &lt;- mkLDL(17))

chkLDL &lt;- function(n, ..., verbose=FALSE, tol = 1e-14) {
    LD &lt;- mkLDL(n, ...)
    if(verbose) cat(sprintf("n=%3d ", n))
    n &lt;- length(D &lt;- LD$D)
    L &lt;- LD$L
    M &lt;- L %*% diag(D) %*% t(L)
    r &lt;- ldl(M)
    stopifnot(exprs = {
        all.equal(M,
                  r$L %*% diag(r$D) %*% t(r$L), tol=tol)
        all.equal(L, r$L, tol=tol)
        all.equal(D, r$D, tol=tol)
    })
    if(verbose) cat("[ok]\n")
    invisible(list(LD = LD, M = M, ldl = r))
}

(chkLDL(7))


N &lt;- 99 ## test  N  random cases
set.seed(101)
for(i in 1:N) {
    cat(sprintf("i=%3d, ",i))
    chkLDL(rpois(1, lambda = 20), verbose=TRUE)
}



system.time(chkLDL( 500)) # 0.62

try( ## this almost never "works":
    system.time(
        chkLDL( 500, rF = rnorm, rFD = function(n) 10 + runif(n))
    ) # 0.64
)
system.time(chkLDL( 600)) # 1.09
## .. then it grows quickly for (on nb-mm4)
## for n = 1000  it typically *fails*: The matrix M  is typically very ill conditioned
## does not depend much on the RNG ?


"==&gt; much better conditioned L and hence M : "
set.seed(120)
L &lt;- as(Matrix::tril(toeplitz(exp(-(0:999)/50))), "matrix")
dimnames(L) &lt;- NULL
D &lt;- 10 + runif(nrow(L))
M &lt;- L %*% diag(D) %*% t(L)
rcond(L) # 0.010006 !
rcond(M) # 9.4956e-5
if(FALSE) # ~ 4-5 sec
   system.time(r &lt;- ldl(M))
</code></pre>

<hr>
<h2 id='llmvtnorm'>Log-Likelihood of Multivariate Normal Mixture Relying on <code>mvtnorm::dmvnorm</code></h2><span id='topic+llmvtnorm'></span>

<h3>Description</h3>

<p>Compute the log-likelihood of a multivariate normal mixture, by calling
<code><a href="mvtnorm.html#topic+dmvnorm">dmvnorm</a>()</code> (from package <a href="https://CRAN.R-project.org/package=mvtnorm"><span class="pkg">mvtnorm</span></a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>llmvtnorm(par, x, k,
          model = c("EII", "VII", "EEI", "VEI", "EVI",
                    "VVI", "EEE", "VEE", "EVV", "VVV"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="llmvtnorm_+3A_par">par</code></td>
<td>
<p>parameter vector as calculated by nMm2par</p>
</td></tr>
<tr><td><code id="llmvtnorm_+3A_x">x</code></td>
<td>
<p>numeric data <code><a href="base.html#topic+matrix">matrix</a></code> (of dimension <code class="reqn">n \times p</code>).</p>
</td></tr>
<tr><td><code id="llmvtnorm_+3A_k">k</code></td>
<td>
<p>number of mixture components.</p>
</td></tr>
<tr><td><code id="llmvtnorm_+3A_model">model</code></td>
<td>
<p>assumed model of the distribution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the log-likelihood (a number) of the specified model for the data
(<code class="reqn">n</code> observations) <code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="mvtnorm.html#topic+dmvnorm">dmvnorm</a>()</code> from package <a href="https://CRAN.R-project.org/package=mvtnorm"><span class="pkg">mvtnorm</span></a>.  Our own
function, returning the same: <code><a href="#topic+llnorMmix">llnorMmix</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1); x &lt;- rnorMmix(50, MW29)
para &lt;- nMm2par(MW29, model=MW29$model)

llmvtnorm(para, x, 2, model=MW29$model)
# [1] -236.2295
</code></pre>

<hr>
<h2 id='llnorMmix'>Log-likelihood of parameter vector given data</h2><span id='topic+llnorMmix'></span>

<h3>Description</h3>

<p>Calculates log-likelihood of a dataset, tx, given a normal mixture model as
specified by a parameter vector.
A parameter vector can be obtained by applying <code><a href="#topic+nMm2par">nMm2par</a></code> to a
<code><a href="#topic+norMmix">norMmix</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>llnorMmix(par, tx, k,
          model = c("EII", "VII", "EEI", "VEI", "EVI",
                    "VVI", "EEE", "VEE", "EVV", "VVV"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="llnorMmix_+3A_par">par</code></td>
<td>
<p>parameter vector</p>
</td></tr>
<tr><td><code id="llnorMmix_+3A_tx">tx</code></td>
<td>
<p><em>Transposed</em> numeric data matrix, i.e. <code>tx := t(x)</code>
is of dimension <code class="reqn">p \times n</code>; its rows are variables and
columns are observations.</p>
</td></tr>
<tr><td><code id="llnorMmix_+3A_k">k</code></td>
<td>
<p>number of mixture components.</p>
</td></tr>
<tr><td><code id="llnorMmix_+3A_model">model</code></td>
<td>
<p>assumed distribution model of normal mixture</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the log-likelihood (a number) of the specified model for the data
(<code class="reqn">n</code> observations) <code>x</code>.
</p>


<h3>See Also</h3>

<p>Our alternative function <code><a href="#topic+llmvtnorm">llmvtnorm</a>()</code> (which is based on
<code><a href="mvtnorm.html#topic+dmvnorm">dmvnorm</a>()</code> from package <a href="https://CRAN.R-project.org/package=mvtnorm"><span class="pkg">mvtnorm</span></a>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1); tx &lt;- t(rnorMmix(50, MW29))
para &lt;- nMm2par(MW29, model=MW29$model)

llnorMmix(para, tx, 2, model=MW29$model)
# [1] -236.2295
</code></pre>

<hr>
<h2 id='MarronWand'>Marron-Wand-like Specific Multivariate Normal Mixture 'norMmix' Objects</h2><span id='topic+MarronWand'></span><span id='topic+MW21'></span><span id='topic+MW22'></span><span id='topic+MW23'></span><span id='topic+MW24'></span><span id='topic+MW25'></span><span id='topic+MW26'></span><span id='topic+MW27'></span><span id='topic+MW28'></span><span id='topic+MW29'></span><span id='topic+MW210'></span><span id='topic+MW211'></span><span id='topic+MW212'></span><span id='topic+MW213'></span><span id='topic+MW214'></span><span id='topic+MW215'></span><span id='topic+MW31'></span><span id='topic+MW32'></span><span id='topic+MW33'></span><span id='topic+MW34'></span><span id='topic+MW51'></span>

<h3>Description</h3>

<p>Nicolas Trutmann constructed multivariate versions from most of the
univariate (i.e., one-dimensional) &quot;Marron-Wand&quot; densities as defined in
CRAN package <a href="https://CRAN.R-project.org/package=nor1mix"><span class="pkg">nor1mix</span></a>, see <code><a href="nor1mix.html#topic+MarronWand">MarronWand</a></code> (in
that package).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## 2-dim examples:
MW21   # Gaussian
MW22   # Skewed
MW23   # Str Skew
MW24   # Kurtotic
MW25   # Outlier
MW26   # Bimodal
MW27   # Separated (bimodal)
MW28   # Asymmetric Bimodal
MW29   # Trimodal
MW210  # Claw
MW211  # Double Claw
MW212  # Asymmetric Claw
MW213  # Asymm. Double Claw
MW214  # Smooth   Comb
MW215  # Trimodal

## 3-dim :
MW31
MW32
MW33
MW34

## 5 - dim:
MW51    # Gaussian
</code></pre>


<h3>Value</h3>

<p>A normal mixture model. The first digit of the number in the variable name encodes the dimension
of the mixture; the following digits merely enumerate models, with some correlation to the
complexity of the model.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler for 1D; Nicolas Trutmann for 2-D, 3-D and 5-D.</p>


<h3>References</h3>

<p>Marron, S. and Wand, M. (1992)
Exact Mean Integrated Squared Error;
<em>Annals of Statistcs</em> <b>20</b>, 712&ndash;736;
<a href="https://doi.org/10.1214/aos/1176348653">doi:10.1214/aos/1176348653</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>MW210
plot(MW214, main = "plot( MW214 )")

plot(MW51, main = paste("plot( MW51 );  name:", attr(MW51, "name")))
</code></pre>

<hr>
<h2 id='nMm2par'>Multivariate Normal Mixture Model to parameter for MLE</h2><span id='topic+nMm2par'></span>

<h3>Description</h3>

<p>From a <code>"<a href="#topic+norMmix">norMmix</a>"</code>(-like) object, return the numeric
parameter vector in our MLE parametrization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  nMm2par(obj,
        model = c("EII", "VII", "EEI", "VEI", "EVI",
                  "VVI", "EEE", "VEE", "EVV", "VVV"),
        meanFUN = mean.default,
        checkX = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nMm2par_+3A_obj">obj</code></td>
<td>
<p>a <code><a href="base.html#topic+list">list</a></code> containing </p>

<dl>
<dt><code>sig</code>:</dt><dd><p>covariance matrix array,</p>
</dd>
<dt><code>mu</code>:</dt><dd><p>mean vector matrix,</p>
</dd>
<dt><code>w</code>:</dt><dd><p>= weights,</p>
</dd>
<dt><code>k</code>:</dt><dd><p>= number of components,</p>
</dd>
<dt><code>p</code>:</dt><dd><p>= dimension</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="nMm2par_+3A_model">model</code></td>
<td>
<p>a <code><a href="base.html#topic+character">character</a></code> string specifying the (Sigma)
model, one of those listed above.</p>
</td></tr>
<tr><td><code id="nMm2par_+3A_meanfun">meanFUN</code></td>
<td>
<p>a <code><a href="base.html#topic+function">function</a></code> to compute a mean (of variances typically).</p>
</td></tr>
<tr><td><code id="nMm2par_+3A_checkx">checkX</code></td>
<td>
<p>a boolean. check for positive definiteness of covariance matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This transformation forms a vector from the parameters of a normal
mixture. These consist of weights, means and covariance matrices.
</p>
<p>Covariance matrices are given as D and L from the LDLt decomposition
</p>


<h3>Value</h3>

<p>vector containing encoded parameters of the mixture.
first, the centered log ratio of the weights, then the means, and then the model specific encoding
of the covariances.
</p>


<h3>See Also</h3>

<p>the <em>inverse</em> function of <code><a href="#topic+nMm2par">nMm2par</a>()</code> is <code><a href="#topic+par2nMm">par2nMm</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- MW24
nMm2par(A, model = A$model)
# [1] -0.3465736  0.0000000  0.0000000  0.0000000  0.0000000  0.0000000
# [7] -2.3025851

## All MW* models in {norMmix} pkg:
pkg &lt;- "package:norMmix"
lMW &lt;- mget(ls(pattern = "^MW", pkg), envir=as.environment(pkg))
lM.par &lt;- lapply(lMW, nMm2par)
## but these *do* differ  ___ FIXME __ 
modMW &lt;- vapply(lMW, `[[`, "model", FUN.VALUE = "XYZ")
cbind(modMW, lengths(lM.par),  npar = sapply(lMW, npar))[order(modMW),]
</code></pre>

<hr>
<h2 id='nor1toMmix'>Cast nor1mix object as norMmix.</h2><span id='topic+nor1toMmix'></span>

<h3>Description</h3>

<p>Cast nor1mix object as norMmix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nor1toMmix(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nor1toMmix_+3A_object">object</code></td>
<td>
<p>A nor1mix mixture model to be coerced to norMmix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This package was designed to extend the <code>nor1mix</code> package to the case of
multivariate mixture models. Therefore we include a utility function to cast
1-dimensional mixtures as defined in <a href="https://CRAN.R-project.org/package=nor1mix"><span class="pkg">nor1mix</span></a> to <code><a href="#topic+norMmix">norMmix</a></code>.
</p>


<h3>Value</h3>

<p>A <code>norMmix</code> object if the appropriate S3method has been implemented.
</p>

<hr>
<h2 id='norMmix'>Constructor for Multivariate Normal Mixture Objects</h2><span id='topic+norMmix'></span>

<h3>Description</h3>

<p><code>norMmix</code> creates a multivariate normal (aka Gaussian) mixture
object, conceptually a mixture of <code class="reqn">k</code> multivariate
(<code class="reqn">p</code>-dimensional) Gaussians
<code class="reqn">\mathcal{N}(\mu_j, \Sigma_j)</code>, for <code class="reqn">j=1, \dots, k</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norMmix(mu, Sigma = NULL, weight = rep(1/k, k), name = NULL,
        model = c("EII", "VII", "EEI", "VEI", "EVI",
                  "VVI", "EEE", "VEE", "EVV", "VVV"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="norMmix_+3A_mu">mu</code></td>
<td>
<p>matrix of means, or a vector in which case <code class="reqn">k = 1</code> is
assumed.  Otherwise use <code><a href="base.html#topic+as.matrix">as.matrix</a>(mu)</code>.</p>
</td></tr>
<tr><td><code id="norMmix_+3A_sigma">Sigma</code></td>
<td>
<p>NULL, number, numeric, vector (length = k), matrix (dim = p x k), or
array (p x p x k). See details.
</p>
</td></tr>
<tr><td><code id="norMmix_+3A_weight">weight</code></td>
<td>
<p>weights of mixture model components</p>
</td></tr>
<tr><td><code id="norMmix_+3A_name">name</code></td>
<td>
<p>gives the option of naming mixture</p>
</td></tr>
<tr><td><code id="norMmix_+3A_model">model</code></td>
<td>
<p>see &lsquo;Details&rsquo;</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>model</code> must be specified by one of the (currently 10)
<code><a href="base.html#topic+character">character</a></code> strings shown in the default.
(In a future version, <code>model</code> may become <em>optional</em>).
</p>
<p><code>norMmix</code> as a few nifty ways of constructing simpler matrices from
smaller givens. This happens according to the dimension of the given
value for the Sigma argument:
</p>

<dl>
<dt>0.</dt><dd><p>for a single value <code>d</code> or <code>NULL</code>, <code>norMmix()</code> assumes
all covariance matrices to be diagonal with entries <code>d</code> or <code>1</code>, respectively. </p>
</dd>
<dt>1.</dt><dd><p>for a vector <code>v</code>, <code>norMmix</code> assumes all matrices to
be diagonal with the i-th matrix having diagonal entries <code>v[i]</code>.</p>
</dd>
<dt>2.</dt><dd><p>for a matrix <code>m</code>, <code>norMmix</code> assumes all matrices to
be diagonal with diagonal vector <code>m[,i]</code>, i.e., it goes by
columns.</p>
</dd>
<dt>3.</dt><dd><p>an array is assumed to be the covariance matrices, given
explicitly.</p>
</dd>
</dl>

<p>FIXME ... give &quot;all&quot; the details ... (from Bachelor's thesis ???)


</p>


<h3>Value</h3>

<p>currently, a <code><a href="base.html#topic+list">list</a></code> of class <code>"norMmix"</code>, with
a <code>name</code> attribute and components
</p>
<table role = "presentation">
<tr><td><code>model</code></td>
<td>
<p>three-letter <code><a href="base.html#topic+character">character</a></code> string, specifying the
Sigma-parametrization</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>(p x k) matrix of component means <code>mu[,j]</code>,
<code class="reqn">j=1,\dots,k</code>.</p>
</td></tr>
<tr><td><code>Sigma</code></td>
<td>
<p>(p x p x k) array of component Covariance matrices
<code>Sigma[,,j]</code>.</p>
</td></tr>
<tr><td><code>weight</code></td>
<td>
<p>p-vector of mixture probability weights;
non-negative, summing to one: <code><a href="base.html#topic+sum">sum</a>(weight) == 1</code>.</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>integer, the number of components</p>
</td></tr>
<tr><td><code>dim</code></td>
<td>
<p>integer, the dimension <code class="reqn">p</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nicolas Trutmann</p>


<h3>References</h3>

<p>__ TODO __
</p>


<h3>See Also</h3>

<p><code><a href="#topic+norMmixMLE">norMmixMLE</a>()</code> to fit such mixture models to data (an <code class="reqn">n
    \times p</code> matrix).
</p>
<p>&ldquo;Marron-Wand&rdquo;-like examples (for testing, etc), such as
<code><a href="#topic+MW21">MW21</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Some of the "MW" objects : % --&gt; ../R/zmarrwandnMm.R

# very simple 2d:
M21 &lt;- norMmix(mu = cbind(c(0,0)), # 2 x 1 ==&gt; k=2, p=1
               Sigma = 1, model = "EII")
stopifnot(identical(M21, # even simpler, Sigma = default :
                    norMmix(mu = cbind(c(0,0)), model = "EII")))

m2.2 &lt;- norMmix(mu = cbind(c(0, 0), c(5, 0)), Sigma = c(1, 10),
                weight = c(7,1)/8, model = "VEI")

m22 &lt;- norMmix(
    name = "one component rotated",
    mu = cbind( c(0,0) ),
    Sigma = array(c(55,9, 9,3), dim = c(2,2, 1)),
    model = "EVV")
stopifnot( all.equal(MW22, m22) )

m213 &lt;- norMmix(
    name = "#13 test VVV",
    weight = c(0.5, 0.5),
    mu = cbind( c(0,0), c(30,30) ),
    Sigma = array(c( 1,3,3,11, 3,6,6,13 ), dim=c(2,2, 2)),
    model = "VVV")
stopifnot( all.equal(MW213, m213) )
str(m213)

m34 &lt;- norMmix(
    name = "#4 3d VEI",
    weight = c(0.1, 0.9),
    mu = matrix(rep(0,6), 3,2),
    Sigma = array(c(diag(1:3), 0.2*diag(3:1)), c(3,3, 2)),
    model = "VVI" )
stopifnot( all.equal(MW34, m34) )


</code></pre>

<hr>
<h2 id='norMmixMLE'>Maximum Likelihood Estimation for Multivariate Normal Mixtures</h2><span id='topic+norMmixMLE'></span><span id='topic+claraInit'></span><span id='topic+mclVVVinit'></span><span id='topic+ssClara2kL'></span>

<h3>Description</h3>

<p>Direct Maximum Likelihood Estimation (MLE) for multivariate normal
mixture models <code>"<a href="#topic+norMmix">norMmix</a>"</code>.  Starting from a
<code><a href="cluster.html#topic+clara">clara</a></code> (package <a href="https://CRAN.R-project.org/package=cluster"><span class="pkg">cluster</span></a>) clustering plus
one M-step by default, or alternatively from the default start of (package)
<a href="https://CRAN.R-project.org/package=mclust"><span class="pkg">mclust</span></a>, perform direct likelihood maximization via <code><a href="stats.html#topic+optim">optim</a>()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norMmixMLE(x, k,
           model = c("EII", "VII", "EEI", "VEI", "EVI",
                     "VVI", "EEE", "VEE", "EVV", "VVV"),
           initFUN = claraInit,
           ll = c("nmm", "mvt"),
           keep.optr = TRUE, keep.data = keep.optr,
           method = "BFGS", maxit = 100, trace = 2,
           optREPORT = 10, reltol = sqrt(.Machine$double.eps),
 	   ...)

claraInit(x, k, samples = 128,
          sampsize = ssClara2kL, trace)
mclVVVinit(x, k, ...)

ssClara2kL(n, k, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="norMmixMLE_+3A_x">x</code></td>
<td>
<p>numeric [n x p] matrix</p>
</td></tr>
<tr><td><code id="norMmixMLE_+3A_k">k</code></td>
<td>
<p>positive number of components</p>
</td></tr>
<tr><td><code id="norMmixMLE_+3A_model">model</code></td>
<td>
<p>a <code><a href="base.html#topic+character">character</a></code> string, specifying the model (for
the <code>k</code> covariance matrices) to be assumed.</p>
</td></tr>
<tr><td><code id="norMmixMLE_+3A_initfun">initFUN</code></td>
<td>
<p>a <code><a href="base.html#topic+function">function</a></code>, that takes arguments <code>x</code> and
<code>k</code> and returns a clustering index; a vector of length <code class="reqn">p = </code><code>ncol(x)</code>,
with entries in <code>1:k</code>.</p>
</td></tr>
<tr><td><code id="norMmixMLE_+3A_ll">ll</code></td>
<td>
<p>a string specifying the method to be used for the likelihood
computation;  the default, <code>"nmm"</code> uses <code><a href="#topic+llnorMmix">llnorMmix</a>()</code>,
whereas <code>"mvt"</code> uses <code><a href="#topic+llmvtnorm">llmvtnorm</a>()</code> which is based on
the MV normal density from package <a href="https://CRAN.R-project.org/package=mvtnorm"><span class="pkg">mvtnorm</span></a>.</p>
</td></tr>
<tr><td><code id="norMmixMLE_+3A_keep.optr">keep.optr</code>, <code id="norMmixMLE_+3A_keep.data">keep.data</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code>, each indicating of the
optimization result (from <code><a href="stats.html#topic+optim">optim</a>()</code>, currently), or the data
<code>x</code> respectively, should be saved as part of the result (function
&lsquo;value&rsquo;, see also below).</p>
</td></tr>
<tr><td><code id="norMmixMLE_+3A_method">method</code>, <code id="norMmixMLE_+3A_maxit">maxit</code>, <code id="norMmixMLE_+3A_optreport">optREPORT</code>, <code id="norMmixMLE_+3A_reltol">reltol</code></td>
<td>
<p>arguments for tuning the
optimizer <code><a href="stats.html#topic+optim">optim</a>(*, method=method, control = list(...))</code>.</p>
</td></tr>

<tr><td><code id="norMmixMLE_+3A_trace">trace</code></td>
<td>

<dl>
<dt>in <code>norMmixMLE()</code>:</dt><dd><p>passed to <code>optim(*, control=..)</code>, see above.</p>
</dd>
<dt>in <code>claraInit()</code>: </dt><dd><p>a non-negative integer indicating how
much <code><a href="cluster.html#topic+clara">clara</a>()</code> calls should be traced.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="norMmixMLE_+3A_...">...</code></td>
<td>

<dl>
<dt>in <code>norMmixMLE()</code>:</dt><dd><p>passed to <code>optim(*, control=..)</code>, see above.</p>
</dd>
<dt>in <code>mclVVVinit()</code>:</dt><dd><p>further arguments passed to (package
<a href="https://CRAN.R-project.org/package=mclust"><span class="pkg">mclust</span></a>) function <code><a href="mclust.html#topic+hcVVV">hcVVV</a>()</code>.</p>
</dd>
</dl>
</td></tr>

<tr><td><code id="norMmixMLE_+3A_samples">samples</code></td>
<td>
<p>the number of subsamples to take in
<code><a href="cluster.html#topic+clara">clara</a>()</code>, package <a href="https://CRAN.R-project.org/package=cluster"><span class="pkg">cluster</span></a>, see its help.</p>
</td></tr>
<tr><td><code id="norMmixMLE_+3A_sampsize">sampsize</code></td>
<td>
<p>the sample size to take in
<code><a href="cluster.html#topic+clara">clara</a>()</code>, package <a href="https://CRAN.R-project.org/package=cluster"><span class="pkg">cluster</span></a>.
Here, can be a positive integer <em>or</em>, as by default, a
<code><a href="base.html#topic+function">function</a></code> with arguments <code>(n,k,p)</code>.</p>
</td></tr>

<tr><td><code id="norMmixMLE_+3A_n">n</code>, <code id="norMmixMLE_+3A_p">p</code></td>
<td>
<p>matrix dimensions <code><a href="base.html#topic+nrow">nrow</a>(x)</code> and <code><a href="base.html#topic+ncol">ncol</a>(x)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, <code>initFUN=claraInit</code>, uses <code><a href="cluster.html#topic+clara">clara</a>()</code>
and one M-step from EM-algorithm to initialize parameters
after that uses general optimizer <code><a href="stats.html#topic+optim">optim</a>()</code> to calculate the MLE.
</p>
<p>To silence the output of <code>norMmixMLE</code>, set <code>optREPORT</code> very high and <code>trace</code> to 0. For details on output behavior, see the &quot;details&quot; section of <code><a href="stats.html#topic+optim">optim</a></code>.
</p>


<h3>Value</h3>

<p><code>norMmixMLE</code> returns an object of <code><a href="base.html#topic+class">class</a></code>
<code>"norMmixMLE"</code> which is a <code><a href="base.html#topic+list">list</a></code> with components
</p>
<table role = "presentation">
<tr><td><code>norMmix</code></td>
<td>
<p>the <code>"<a href="#topic+norMmix">norMmix</a>"</code> object corresponding to the
specified model and the fitted (MLE) parameter vector.</p>
</td></tr>
<tr><td><code>optr</code></td>
<td>
<p>(if <code>keep.optr</code> is true:) the [r]eturn value of
optimization, i.e., currently, <code><a href="stats.html#topic+optim">optim</a>()</code>.</p>
</td></tr>
<tr><td><code>npar</code></td>
<td>
<p>the number of free parameters, a function of <code class="reqn">(p, k, model)</code>.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>the sample size, i.e., the number of observations or rows of <code>x</code>.</p>
</td></tr>
<tr><td><code>cond</code></td>
<td>
<p>the result of (the hidden function) <code>parcond(..)</code>, that is the ratio of sample size
over parameter count.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>(if <code>keep.optr</code> is true:) the <code class="reqn">n \times p</code> data matrix.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>MW214
set.seed(105)
x &lt;- rnorMmix(1000, MW214)

## Fitting, assuming to know the true model (k=6, "VII")
fm1  &lt;- norMmixMLE(x, k = 6, model = "VII", initFUN=claraInit)
fm1 # {using print.norMmixMLE() method}
fm1M &lt;- norMmixMLE(x, k = 6, model = "VII", initFUN=mclVVVinit)

## Fitting "wrong" overparametrized model: typically need more iterations:
fmW &lt;- norMmixMLE(x, k = 7, model = "VVV", maxit = 200, initFUN=claraInit)
## default maxit=100 is often too small    ^^^^^^^^^^^


x &lt;- rnorMmix(2^12, MW51)
fM5 &lt;- norMmixMLE(x, k = 4) # k = 3 is sufficient
fM5
c(logLik = logLik(fM5), AIC = AIC(fM5), BIC = BIC(fM5))
plot(fM5, show.x=FALSE)
plot(fM5, lwd=3, pch.data=".")

# this takes several seconds
 fM5big &lt;- norMmixMLE(x, model = "VVV", k = 4, maxit = 300) # k = 3 is sufficient
 summary(warnings())
 fM5big ; c(logLik = logLik(fM5big), AIC = AIC(fM5big), BIC = BIC(fM5big))
 plot(fM5big, show.x=FALSE)

</code></pre>

<hr>
<h2 id='npar'>Degrees of freedom of (Fitted) Multivariate Normal Mixtures</h2><span id='topic+npar'></span>

<h3>Description</h3>

<p>This function is generic; method functions can be written to
handle specific classes of objects. The following classes have
methods written for them:
</p>
<p>norMmix
</p>
<p>norMmixMLE
</p>
<p>fittednorMmix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>npar(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="npar_+3A_object">object</code></td>
<td>
<p>any <span class="rlang"><b>R</b></span> object from the list in the &lsquo;Description&rsquo;.</p>
</td></tr>
<tr><td><code id="npar_+3A_...">...</code></td>
<td>
<p>potentially further arguments for methods;
Currently, none of the methods for the listed classes do have such.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on <code>object</code> : 
</p>
<table role = "presentation">
<tr><td><code>norMmix</code></td>
<td>
<p>integer number.</p>
</td></tr>
<tr><td><code>norMmixMLE</code></td>
<td>
<p>integer number.</p>
</td></tr>
<tr><td><code>fittednorMmix</code></td>
<td>
<p>integer<code><a href="base.html#topic+matrix">matrix</a></code> with
<code><a href="base.html#topic+dimnames">dimnames</a></code> set to k and models.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nicolas Trutmann</p>


<h3>See Also</h3>

<p><code><a href="#topic+norMmix">norMmix</a></code>, <code><a href="#topic+norMmixMLE">norMmixMLE</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>methods(npar) # list available methods

npar(MW213)
</code></pre>

<hr>
<h2 id='par2nMm'>Transform Parameter Vector to Multivariate Normal Mixture</h2><span id='topic+par2nMm'></span>

<h3>Description</h3>

<p>Transforms the (numeric) parameter vector of our MLE parametrization of a multivariate
normal mixture model into the corresponding <code><a href="base.html#topic+list">list</a></code> of
components determining the model.  Additionally (partly redundantly), the
dimension <code>p</code> and number of components <code>k</code> need to be specified
as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>par2nMm(par, p, k, model = c("EII","VII","EEI","VEI","EVI",
                             "VVI","EEE","VEE","EVV","VVV")
      , name = sprintf("model = %s , components = %s", model, k)
       )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="par2nMm_+3A_par">par</code></td>
<td>
<p>the model parameter numeric vector.</p>
</td></tr>
<tr><td><code id="par2nMm_+3A_p">p</code></td>
<td>
<p>dimension of data space, i.e., number of variables (aka &ldquo;features&rdquo;).</p>
</td></tr>
<tr><td><code id="par2nMm_+3A_k">k</code></td>
<td>
<p>the number of mixture components, a positive integer.</p>
</td></tr>
<tr><td><code id="par2nMm_+3A_model">model</code></td>
<td>
<p>a <code><a href="base.html#topic+character">character</a></code> string, one of those listed; see
<code><a href="#topic+nMm2par">nMm2par</a>()</code>'s documentation.</p>
</td></tr>
<tr><td><code id="par2nMm_+3A_name">name</code></td>
<td>
<p>a <code><a href="base.html#topic+character">character</a></code> string naming the
<code><a href="#topic+norMmix">norMmix</a></code> return value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a <code><a href="base.html#topic+list">list</a></code> with components
</p>
<table role = "presentation">
<tr><td><code>weight</code></td>
<td>
<p>..</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>..</p>
</td></tr>
<tr><td><code>Sigma</code></td>
<td>
<p>..</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>..</p>
</td></tr>
<tr><td><code>dim</code></td>
<td>
<p>..</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>This is the inverse function of <code><a href="#topic+nMm2par">nMm2par</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## TODO: Show to get the list, and then how to get a  norMmix() object from the list
str(MW213)
# List of 6
#  $ model : chr "VVV"
#  $ mu    : num [1:2, 1:2] 0 0 30 30
#  $ Sigma : num [1:2, 1:2, 1:2] 1 3 3 11 3 6 6 13
#  $ weight: num [1:2] 0.5 0.5
#  $ k     : int 2
#  $ dim   : int 2
#  - attr(*, "name")= chr "#13 test VVV"
#  - attr(*, "class")= chr "norMmix"

para &lt;- nMm2par(MW213, model="EEE")
par2nMm(para, 2, 2, model="EEE")
</code></pre>

<hr>
<h2 id='plot.norMmix'>Plot Method for &quot;norMmix&quot; Objects</h2><span id='topic+plot.norMmix'></span><span id='topic+plot.norMmixMLE'></span><span id='topic+plot.fittednorMmix'></span><span id='topic+plot2d'></span><span id='topic+plotnd'></span><span id='topic+Trubetskoy10'></span>

<h3>Description</h3>

<p>This is the S3 method for plotting <code>"<a href="#topic+norMmix">norMmix</a>"</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'norMmix'
plot(x, y=NULL, ...) 
## S3 method for class 'norMmixMLE'
plot(x, y = NULL,
     show.x = TRUE,
     main = sprintf(
         "norMmixMLE(*, model=\"%s\") fit to n=%d observations in %d dim.",
         nm$model, x$nobs, nm$dim
     ),
     sub = paste0(
         sprintf("log likelihood: %g; npar=%d", x$logLik, x$npar), 
         if (!is.null(opt &lt;- x$optr)) paste("; optim() counts:", named2char(opt$counts))
     ),
     cex.data = par("cex") / 4, pch.data = 4,
     ...)
 
## S3 method for class 'fittednorMmix'
plot(x, main = "unnamed", plotbest = FALSE, ...)

plot2d (nMm, data = NULL,
        add = FALSE,
        main = NULL,
        sub = NULL,
        type = "l", lty = 2, lwd = if (!is.null(data)) 2 else 1,
        xlim = NULL, ylim = NULL, f.lim = 0.05,
        npoints = 250, lab = FALSE,
        col = Trubetskoy10[1],
        col.data = adjustcolor(par("col"), 1/2),
        cex.data = par("cex"), pch.data = par("pch"),
        fill = TRUE, fillcolor = col, border = NA,
        ...)
plotnd(nMm, data = NULL,
       main = NULL,
       diag.panel = NULL,
       ...)
Trubetskoy10
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.norMmix_+3A_x">x</code>, <code id="plot.norMmix_+3A_nmm">nMm</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object inheriting from <code>"<a href="#topic+norMmix">norMmix</a>"</code>.</p>
</td></tr>
<tr><td><code id="plot.norMmix_+3A_y">y</code></td>
<td>
<p>further data matrix, first 2 columns will be plotted by
<code>"<a href="graphics.html#topic+points">points</a>"</code>
</p>
</td></tr>
<tr><td><code id="plot.norMmix_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to another plotting function.</p>
</td></tr>
<tr><td><code id="plot.norMmix_+3A_show.x">show.x</code></td>
<td>

<p>Option for <code>plot.norMmixMLE</code>. Plot data points along with estimated model.
Defaults to <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="plot.norMmix_+3A_data">data</code></td>
<td>

<p>Data points to plot. 
</p>
</td></tr>
<tr><td><code id="plot.norMmix_+3A_add">add</code></td>
<td>

<p>This argument is used in the internal function, <code>plot2d</code>, to control whether
to create a new plot or add to an existing one. Should not be set by the user.
Defaults to <code>FALSE</code>
</p>
</td></tr>
<tr><td><code id="plot.norMmix_+3A_main">main</code></td>
<td>

<p>Set main title. See <code>Usage</code> section for default values.
</p>
</td></tr>
<tr><td><code id="plot.norMmix_+3A_sub">sub</code></td>
<td>

<p>Set subtitle. See <code>Usage</code> section for default values.
</p>
</td></tr>
<tr><td><code id="plot.norMmix_+3A_type">type</code></td>
<td>

<p>Graphing type for ellipses border. Defaults to &quot;l&quot;.
</p>
</td></tr>
<tr><td><code id="plot.norMmix_+3A_lty">lty</code></td>
<td>

<p>Line type to go with the <code>type</code>. See <code>"<a href="graphics.html#topic+par">par</a>"</code>.
</p>
</td></tr>
<tr><td><code id="plot.norMmix_+3A_lwd">lwd</code></td>
<td>

<p>Line width as in <code>lty</code>.
</p>
</td></tr>
<tr><td><code id="plot.norMmix_+3A_xlim">xlim</code></td>
<td>

<p>Set explicit x limits for 2d plots.
</p>
</td></tr>
<tr><td><code id="plot.norMmix_+3A_ylim">ylim</code></td>
<td>

<p>As <code>xlim</code>.
</p>
</td></tr>
<tr><td><code id="plot.norMmix_+3A_f.lim">f.lim</code></td>
<td>

<p>Percentage value for how much to extend <code>xlim</code> and <code>ylim</code>.
As in the <code>f</code> argument to <code>"<a href="grDevices.html#topic+extendrange">extendrange</a>"</code>.
</p>
</td></tr>
<tr><td><code id="plot.norMmix_+3A_npoints">npoints</code></td>
<td>

<p>How many points to use in the drawn ellipses. Larger values make them prettier
but might affect plot times.
</p>
</td></tr>
<tr><td><code id="plot.norMmix_+3A_lab">lab</code></td>
<td>

<p>Whether to print labels for mixture components.
Will print &quot;comp 
</p>
</td></tr>
<tr><td><code id="plot.norMmix_+3A_col">col</code></td>
<td>

<p>Fill color for ellipses. Default is &quot;#4363d8&quot;.
</p>
</td></tr>
<tr><td><code id="plot.norMmix_+3A_col.data">col.data</code></td>
<td>

<p>Color to be used for data points.
</p>
</td></tr>
<tr><td><code id="plot.norMmix_+3A_cex.data">cex.data</code></td>
<td>

<p>See <code>"<a href="graphics.html#topic+par">par</a>"</code>.
</p>
</td></tr>
<tr><td><code id="plot.norMmix_+3A_pch.data">pch.data</code></td>
<td>

<p>See <code>"<a href="graphics.html#topic+par">par</a>"</code>.
</p>
</td></tr>
<tr><td><code id="plot.norMmix_+3A_fill">fill</code></td>
<td>

<p>Leave ellipses blank with outline or fill them in.
</p>
</td></tr>
<tr><td><code id="plot.norMmix_+3A_fillcolor">fillcolor</code></td>
<td>

<p>Color for infill of ellipses.
</p>
</td></tr>
<tr><td><code id="plot.norMmix_+3A_border">border</code></td>
<td>

<p>Argument to be passed to <code><a href="graphics.html#topic+polygon">polygon</a></code>.

</p>
</td></tr>
<tr><td><code id="plot.norMmix_+3A_diag.panel">diag.panel</code></td>
<td>

<p>Function to plot 2d projections of a higher-dimensional mixture model.
Used by <code>plotnd</code>.
Requires function with signature <code>function(x, y, data = NULL, ...)</code>
Should not be set by the user.
</p>
</td></tr>
<tr><td><code id="plot.norMmix_+3A_plotbest">plotbest</code></td>
<td>

<p>Used by <code>fittednorMmix</code>. Plot best fitting model using <code>plot.norMmix</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plot method calls one of two auxiliary functions, one for dim=2,
another for higher dimensions. The method for 2 dimensional plots also takes a
<code>add</code> parameter (<code>FALSE</code> by default), which allows for the ellipses
to be drawn over an existing plot.
</p>
<p>The higher dimensional plot method relies on the <code>pairs.default</code> function
to draw a lattice plot, where the panels are built using the 2 dimensional method.
</p>
<p><code>Trubetskoy10</code>: A vector of colors for these plots,
chosen to be distinguishable and accessible for the colorblind, according to
<a href="https://sashamaps.net/2017/01/11/list-of-20-simple-distinct-colors/">https://sashamaps.net/2017/01/11/list-of-20-simple-distinct-colors/</a>,
slightly rearranged, so that the first five colors stand out well on white background.
</p>


<h3>Value</h3>

<p><code>plot.norMmix</code> In the 2 dimensional case, returns invisibly coordinates 
of bounding ellipses of distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plot(MW212) ## and add a finite sample realization:
points(rnorMmix(n=500, MW212))

## or:
x &lt;- points(rnorMmix(n=500, MW212))
plot(MW212, x)


## Example of dim. = p &gt; 2 :
plot(MW34)
</code></pre>

<hr>
<h2 id='rnorMmix'>Random Sample from Multivariate Normal Mixture Distribution</h2><span id='topic+rnorMmix'></span>

<h3>Description</h3>

<p>Draw <code>n</code> (p-dimensional) observations randomly from the multivariate normal
mixture distribution specified by <code>obj</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rnorMmix(n, obj, index = FALSE, permute = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rnorMmix_+3A_n">n</code></td>
<td>
<p>sample size, non-negative.</p>
</td></tr>
<tr><td><code id="rnorMmix_+3A_obj">obj</code></td>
<td>
<p>a <code>"<a href="#topic+norMmix">norMmix</a>"</code> object</p>
</td></tr>
<tr><td><code id="rnorMmix_+3A_index">index</code></td>
<td>
<p>Logical, store the clustering information as first column</p>
</td></tr>
<tr><td><code id="rnorMmix_+3A_permute">permute</code></td>
<td>
<p>Logical, indicating if the observations should be randomly
permuted after creation &ldquo;cluster by cluster&rdquo;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>n p-dimensional observations, as numeric <code class="reqn">n \times p</code> matrix.
</p>


<h3>Author(s)</h3>

<p>Nicolas Trutmann</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+rmultinom">rmultinom</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorMmix(500, MW213)
plot(x)
x &lt;- rnorMmix(500, MW213, index=TRUE)
plot(x[,-1], col=x[,1]) ## using index column to color components
</code></pre>

<hr>
<h2 id='sllnorMmix'>Simple wrapper for Log-Likelihood Function or Multivariate Normal Mixture</h2><span id='topic+sllnorMmix'></span>

<h3>Description</h3>

<p><code>sllnorMmix()</code> returns a number, the log-likelihood of the data
<code>x</code>, given a normal mixture <code>obj</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sllnorMmix(x, obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sllnorMmix_+3A_x">x</code></td>
<td>
<p>data <code><a href="base.html#topic+matrix">matrix</a></code>.</p>
</td></tr>
<tr><td><code id="sllnorMmix_+3A_obj">obj</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object of class <code>"<a href="#topic+norMmix">norMmix</a>"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates log-likelihood of a dataset, x, given a normal mixture model;
just a simplified wrapper for <code><a href="#topic+llnorMmix">llnorMmix</a></code>.
Removes functionality in favor of ease of use.
</p>


<h3>Value</h3>

<p><code>double</code>. See description.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2019)
x &lt;- rnorMmix(400, MW27)
sllnorMmix(x, MW27) # -1986.315
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
