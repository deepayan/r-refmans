<!DOCTYPE html><html lang="en"><head><title>Help for package distreg.vis</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {distreg.vis}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bad_range_warning'><p>Internal: Function that constructs a warning message for the user when</p>
<code>range_checker</code> is TRUE.</a></li>
<li><a href='#disc_trans'><p>Internal: Transform discrete predictions into a usable df</p></a></li>
<li><a href='#distreg_checker'><p>Check if model class is supported</p></a></li>
<li><a href='#distreg.vis'><p>distreg.vis: Interactively visualizing distributional regression models</p></a></li>
<li><a href='#dists'><p>Information about supported and not yet supported distribution families</p></a></li>
<li><a href='#ex_f'><p>External Function Implementer</p></a></li>
<li><a href='#f_disp'><p>Model distribution family display-er</p></a></li>
<li><a href='#fac_check'><p>Factor Checker</p></a></li>
<li><a href='#fac_equ'><p>Factor Equalizer</p></a></li>
<li><a href='#fam_fun_getter'><p>Obtain d&amp;p&amp;q functions</p></a></li>
<li><a href='#fam_obtainer'><p>Internal: Family obtainer</p></a></li>
<li><a href='#formula_printer'><p>Model formulas printer</p></a></li>
<li><a href='#gamlss_data_cleaner'><p>GAMLSS expl_data cleaner</p></a></li>
<li><a href='#has.moments'><p>Internal: Distributional Moments implementation checker</p></a></li>
<li><a href='#is.bamlss'><p>Internal: Is bamlss family?</p></a></li>
<li><a href='#is.betareg'><p>Internal: Is betareg family?</p></a></li>
<li><a href='#is.continuous'><p>Internal: Continuous/Mixed Distribution checker</p></a></li>
<li><a href='#is.discrete'><p>Internal: Discrete Distribution Checker</p></a></li>
<li><a href='#is.distreg.fam'><p>Internal: Is distreg family</p></a></li>
<li><a href='#is.gamlss'><p>Internal: Is gamlss family?</p></a></li>
<li><a href='#is.implemented'><p>Internal: Distribution Implementation Checker</p></a></li>
<li><a href='#limits'><p>Internal: Plot limit getter</p></a></li>
<li><a href='#lims_getter'><p>Internal: Upper- and lower limit of distribution getter</p></a></li>
<li><a href='#link_printer'><p>Model link functions printer</p></a></li>
<li><a href='#model_data'><p>Model data getter</p></a></li>
<li><a href='#model_fam_data'><p>Create a dataset to fit models with all possible families in distreg packages</p></a></li>
<li><a href='#moments'><p>Compute distributional moments from the parameters</p></a></li>
<li><a href='#mult_trans'><p>Internal: Function to transform multinomial predictions</p></a></li>
<li><a href='#pdfcdf_continuous'><p>Internal: Create the pdf/cdf for continuous covariates</p></a></li>
<li><a href='#pdfcdf_discrete'><p>Internal: Create the pdf/cdf for discrete covariates</p></a></li>
<li><a href='#plot_dist'><p>Plot predicted distributional regression models</p></a></li>
<li><a href='#plot_moments'><p>Plot function: Display the influence of a covariate</p></a></li>
<li><a href='#plot_multinom_exp'><p>Internal: Plot function as sub-case to plot_moments for</p>
multinomial family</a></li>
<li><a href='#preds'><p>Predict parameters of a distreg models' target distribution</p></a></li>
<li><a href='#preds_transformer'><p>Sample transformer</p></a></li>
<li><a href='#quants'><p>Get quantile limits of a distribution</p></a></li>
<li><a href='#range_checker'><p>Internal: Function that checks whether chosen covariate combinations</p>
are in the range of original data. Returns true when there is a cov
comb outside of data.</a></li>
<li><a href='#reshape_into_long'><p>Internal: Reshape into Long Format</p></a></li>
<li><a href='#search_distreg'><p>distreg Searcher</p></a></li>
<li><a href='#search_funs'><p>function Searcher</p></a></li>
<li><a href='#set_mean'><p>Obtain mean values and reference categories of variables in a data.frame</p></a></li>
<li><a href='#tidy_c'><p>Function for better use of formatR's tidy_source</p></a></li>
<li><a href='#type_getter'><p>Internal: Limit type getter</p></a></li>
<li><a href='#vis'><p>distreg.vis function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Framework for the Visualization of Distributional Regression
Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.7.5</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Stanislaus Stadlmann &lt;stanislaus@stadlmann.cm&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, utils, methods, shiny (&ge; 1.0.3), bamlss (&ge; 0.1-2),
gamlss (&ge; 5.0-6), gamlss.dist (&ge; 5.1-0), ggplot2 (&ge; 2.2.1),
rhandsontable (&ge; 0.3.4), magrittr (&ge; 1.5), formatR (&ge; 1.5),
betareg (&ge; 3.1-2)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, gridExtra, glogis</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for visualizing distributional regression models fitted using the 'gamlss', 'bamlss' or 'betareg' R package. The core of the package consists of a 'shiny' application, where the model results can be interactively explored and visualized.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Stan125/distreg.vis">https://github.com/Stan125/distreg.vis</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Stan125/distreg.vis/issues">https://github.com/Stan125/distreg.vis/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-27 04:44:57 UTC; stani</td>
</tr>
<tr>
<td>Author:</td>
<td>Stanislaus Stadlmann
    <a href="https://orcid.org/0000-0001-6542-6342"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [cre, aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-27 05:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bad_range_warning'>Internal: Function that constructs a warning message for the user when
<code><a href="#topic+range_checker">range_checker</a></code> is TRUE.</h2><span id='topic+bad_range_warning'></span>

<h3>Description</h3>

<p>Internal: Function that constructs a warning message for the user when
<code><a href="#topic+range_checker">range_checker</a></code> is TRUE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bad_range_warning(outlier_combs)
</code></pre>

<hr>
<h2 id='disc_trans'>Internal: Transform discrete predictions into a usable df</h2><span id='topic+disc_trans'></span>

<h3>Description</h3>

<p>Internal: Transform discrete predictions into a usable df
</p>


<h3>Usage</h3>

<pre><code class='language-R'>disc_trans(pred_params, fam_name, type, model, lims)
</code></pre>

<hr>
<h2 id='distreg_checker'>Check if model class is supported</h2><span id='topic+distreg_checker'></span>

<h3>Description</h3>

<p>This function is a quick way to find out whether a specific model class is
supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distreg_checker(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distreg_checker_+3A_x">x</code></td>
<td>
<p>Model object or model object in quoted form, e.g. &quot;mymodel&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is one of the cornerstones of <a href="#topic+distreg.vis">distreg.vis</a>. It decides
which models are supported. All core functions of this package call
<code>distreg_checker</code> multiple times. So, if a model class is support here,
it is supported in the whole package.
</p>
<p>At the moment, the following model classes are supported: </p>

<ul>
<li> <p><a href="gamlss.html#topic+gamlss">gamlss</a> </p>
</li>
<li> <p><a href="bamlss.html#topic+bamlss">bamlss</a> </p>
</li>
<li>
<p><a href="betareg.html#topic+betareg">betareg</a> from <code>betareg</code> </p>
</li>
<li> <p><a href="betareg.html#topic+betatree">betatree</a>
from <code>betareg</code></p>
</li></ul>


<hr>
<h2 id='distreg.vis'>distreg.vis: Interactively visualizing distributional regression models</h2><span id='topic+distreg.vis'></span>

<h3>Description</h3>

<p>The package <code>distreg.vis</code> is a framework for the visualization of
distributional regression models estimated with the R packages <code>bamlss</code>,
<code>gamlss</code> and <code>betareg</code>. Current supported model classes can be
found under <a href="#topic+distreg_checker">distreg_checker</a>.
</p>


<h3>Details</h3>

<p>The main functions are:
</p>
 <ul>
<li> <p><code>vis()</code>: Starts the Graphical User Interface. </p>
</li>
<li>
<p><code>moments()</code>: Obtain predicted moments of the target distribution based
on user-specified values of the explanatory variables. </p>
</li>
<li>
<p><code>plot_dist()</code>: Create a graph displaying the predicted probability
density function or cumulative density function based on the same
user-specified values. </p>
</li>
<li> <p><code>plot_moments()</code>: View the marginal
influence of a selected effect on the predicted moments of the target
distribution.</p>
</li></ul>

<p>To get a feel for the main capabilities of <code>distreg.vis</code>, you can run
the examples or the demo called <code>vis-demo.R</code> which fits a couple of
distributional regression models and then calls the Graphical User Interface.
</p>
<p>For the main functions, certain target distributions from both <code>bamlss</code>
and <code>gamlss</code> are supported. Check the <code>distreg.vis::dists</code> dataset
to find out which distributions are supported for <code>plot_dist()</code> (column
<code>implemented</code>) and which are also supported for <code>plot_moments()</code>
(column <code>moment_funs</code>).
</p>
<p>To make the process of interpreting fitted distributional regression models
as easy as possible, <code>distreg.vis</code> features a rich Graphical User
Interface (GUI) built on the <code>shiny</code> framework. Using this GUI, the user
can (a) obtain an overview of the selected model fit, (b) easily select
explanatory values for which to display the predicted distributions, (c)
obtain marginal influences of selected covariates and (d) change aesthetical
components of each displayed graph. After a successful analysis, the user can
quickly obtain the R code needed to reproduce all displayed plots, without
having to start the application again.
</p>
<p>Maintainer: </p>
 <ul>
<li><p> Stanislaus Stadlmann,
<a href="mailto:stadlmann@uni-goettingen.de">stadlmann@uni-goettingen.de</a> </p>
</li></ul>


<hr>
<h2 id='dists'>Information about supported and not yet supported distribution families</h2><span id='topic+dists'></span>

<h3>Description</h3>

<p>A dataset containing all of bamlss' exported and gamlss.dist families. This
is the backbone of the package; whether you can use a distributional family
or not depends on this dataset. Since 1.7.0 family <code>betareg</code> from the
betareg package is also supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dists
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 125 rows and 8 columns.
</p>


<h3>Details</h3>

<p>This <code>data.frame</code> object contains one row for each
distribution, and columns with the following content: </p>
 <ul>
<li>
<p><code>dist_name</code>: Name of the distribution. </p>
</li>
<li> <p><code>class</code>: Either
&quot;bamlss&quot; or &quot;gamlss&quot; detailing from which package the target distribution
comes from. </p>
</li>
<li> <p><code>implemented</code>: Is this distribution generally usable
for <code>plot_dist()</code>, and was this usage already tested? </p>
</li>
<li>
<p><code>moment_funs</code>: Are functions implemented with which to calculate the
moments of the distribution, given the parameters? This column is especially
relevant for <code>plot_moments()</code>, in which the predicted moments are
displayed. </p>
</li>
<li> <p><code>type_limits</code>: Details the range the values from the
distribution can have. Can be &quot;both_limits&quot;, &quot;one_limit&quot;, &quot;no_limit&quot; and
&quot;cat_limit&quot; (for categorical distributions). </p>
</li>
<li> <p><code>l_limit, u_limit</code>:
Integers detailing where the limits of the distributions lie. </p>
</li>
<li>
<p><code>type</code>: Character string for the type of distribution. Can be
&quot;Discrete&quot;, &quot;Continuous&quot;, &quot;Mixed&quot; and &quot;Categorical&quot;. </p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Find out which GAMLSS or BAMLSS families are supported

dists_char &lt;- dists[dists$moment_funs, c("dist_name", "class")]

# GAMLSS families
dists_char[dists_char$class == "gamlss", "dist_name"]

# BAMLSS families
dists_char[dists_char$class == "bamlss", "dist_name"]
</code></pre>

<hr>
<h2 id='ex_f'>External Function Implementer</h2><span id='topic+ex_f'></span>

<h3>Description</h3>

<p>This function exists to extend <code>plot_moments</code> such that an external
function, which is user-written, can be included. Thus, the user can see the
impact of a variable on a self-defined measure, like the Gini Index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ex_f(pred_params, unquotedfun)
</code></pre>

<hr>
<h2 id='f_disp'>Model distribution family display-er</h2><span id='topic+f_disp'></span>

<h3>Description</h3>

<p>Prints the family and link functions of a model in a short way
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_disp(model)
</code></pre>

<hr>
<h2 id='fac_check'>Factor Checker</h2><span id='topic+fac_check'></span>

<h3>Description</h3>

<p>Checks whether some factor was unwantedly converted to an ordered factor
which rhandsontable sometimes does
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fac_check(DF)
</code></pre>

<hr>
<h2 id='fac_equ'>Factor Equalizer</h2><span id='topic+fac_equ'></span>

<h3>Description</h3>

<p>Function that takes the levels of a df's factors and puts them to a second df
(used for predictions). Returns a data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fac_equ(base_df, pred_df)
</code></pre>

<hr>
<h2 id='fam_fun_getter'>Obtain d&amp;p&amp;q functions</h2><span id='topic+fam_fun_getter'></span>

<h3>Description</h3>

<p>Takes a family name and what kind of function you want and gives the right one back
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fam_fun_getter(fam_name, type)
</code></pre>

<hr>
<h2 id='fam_obtainer'>Internal: Family obtainer</h2><span id='topic+fam_obtainer'></span>

<h3>Description</h3>

<p>Gets the right family (in characters) from a given model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fam_obtainer(model)
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'># Generating data
data_fam &lt;- model_fam_data(fam_name = "BE")
# Fit model
library("gamlss")
beta_model &lt;- gamlss(BE ~ norm2 + binomial1,
  data = data_fam, family = BE())
distreg.vis:::fam_obtainer(model = beta_model)
</code></pre>

<hr>
<h2 id='formula_printer'>Model formulas printer</h2><span id='topic+formula_printer'></span>

<h3>Description</h3>

<p>Prints the model formulas of all parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formula_printer(model)
</code></pre>

<hr>
<h2 id='gamlss_data_cleaner'>GAMLSS expl_data cleaner</h2><span id='topic+gamlss_data_cleaner'></span>

<h3>Description</h3>

<p>This checks whether we have spline column names and/or duplicate columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gamlss_data_cleaner(temp_df)
</code></pre>

<hr>
<h2 id='has.moments'>Internal: Distributional Moments implementation checker</h2><span id='topic+has.moments'></span>

<h3>Description</h3>

<p>Is the moment function of a given distribution family implemented? Meaning:
will <code>plot_moments()</code> work?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has.moments(fam_name)
</code></pre>

<hr>
<h2 id='is.bamlss'>Internal: Is bamlss family?</h2><span id='topic+is.bamlss'></span>

<h3>Description</h3>

<p>Check whether a given distribution comes from the bamlss package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.bamlss(name)
</code></pre>

<hr>
<h2 id='is.betareg'>Internal: Is betareg family?</h2><span id='topic+is.betareg'></span>

<h3>Description</h3>

<p>Check whether a given distribution comes from the betareg package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.betareg(name)
</code></pre>

<hr>
<h2 id='is.continuous'>Internal: Continuous/Mixed Distribution checker</h2><span id='topic+is.continuous'></span>

<h3>Description</h3>

<p>Check whether a given distribution is at least partly continuous (could be
mixed as well).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.continuous(name)
</code></pre>

<hr>
<h2 id='is.discrete'>Internal: Discrete Distribution Checker</h2><span id='topic+is.discrete'></span>

<h3>Description</h3>

<p>Check whether a given distribution is fully discrete.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.discrete(name)
</code></pre>

<hr>
<h2 id='is.distreg.fam'>Internal: Is distreg family</h2><span id='topic+is.distreg.fam'></span>

<h3>Description</h3>

<p>Check whether a given distribution is a distributional regression family
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.distreg.fam(name)
</code></pre>


<h3>Details</h3>

<p>See which classes are currently supported at <a href="#topic+distreg_checker">distreg_checker</a>.
</p>

<hr>
<h2 id='is.gamlss'>Internal: Is gamlss family?</h2><span id='topic+is.gamlss'></span>

<h3>Description</h3>

<p>Check whether a given distribution comes from the gamlss.dist package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.gamlss(name)
</code></pre>

<hr>
<h2 id='is.implemented'>Internal: Distribution Implementation Checker</h2><span id='topic+is.implemented'></span>

<h3>Description</h3>

<p>Is the distribution generally implemented in the distreg.vis framework?
Meaning: Does <code>plot_dist()</code> work?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.implemented(fam_name)
</code></pre>

<hr>
<h2 id='limits'>Internal: Plot limit getter</h2><span id='topic+limits'></span>

<h3>Description</h3>

<p>A function that heavily relies on the <code>distreg.vis::dists</code> data.frame to
obtain optimal plotting limits. Specifically, this function relies on the
columns <code>type_limits</code>, <code>l_limit</code>, <code>u_limit</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>limits(fam_name, predictions)
</code></pre>


<h3>Details</h3>

<p>Three cases: categorical limits (<code>cat_limits</code>), no_limits, has_limits, both_limits
</p>

<hr>
<h2 id='lims_getter'>Internal: Upper- and lower limit of distribution getter</h2><span id='topic+lims_getter'></span>

<h3>Description</h3>

<p>Obtain the theoretical upper and lower limits of the distribution. Only
necessary if the distribution has limits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lims_getter(fam_name)
</code></pre>

<hr>
<h2 id='link_printer'>Model link functions printer</h2><span id='topic+link_printer'></span>

<h3>Description</h3>

<p>Prints the model links of all parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>link_printer(model)
</code></pre>

<hr>
<h2 id='model_data'>Model data getter</h2><span id='topic+model_data'></span>

<h3>Description</h3>

<p>Get the data with which the distributional regression model of interest was
estimated (see <a href="#topic+distreg_checker">distreg_checker</a> for a list of supported object
classes). By default, only explanatory variables are returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_data(model, dep = FALSE, varname = NULL, incl_dep = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="model_data_+3A_model">model</code></td>
<td>
<p>A gamlss or bamlss object.</p>
</td></tr>
<tr><td><code id="model_data_+3A_dep">dep</code></td>
<td>
<p>If TRUE, then only the dependent variable is returned.</p>
</td></tr>
<tr><td><code id="model_data_+3A_varname">varname</code></td>
<td>
<p>Variable name in character form that should be returned. If
this is specified, only the desired variable is returned.</p>
</td></tr>
<tr><td><code id="model_data_+3A_incl_dep">incl_dep</code></td>
<td>
<p>Should the dependent variable be included?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame object if dep or varname is not specified, otherwise a
vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("betareg")

# Get some data
beta_dat &lt;- model_fam_data(fam_name = "betareg")

# Estimate model
betamod &lt;- betareg(betareg ~ ., data = beta_dat)

# Get data
model_data(betamod)
</code></pre>

<hr>
<h2 id='model_fam_data'>Create a dataset to fit models with all possible families in distreg packages</h2><span id='topic+model_fam_data'></span>

<h3>Description</h3>

<p>Create a dataset to fit models with all possible families in distreg packages
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_fam_data(nrow = 500, seed = 1408, fam_name = "NO")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="model_fam_data_+3A_nrow">nrow</code></td>
<td>
<p>Number of observations of the exported dataset.</p>
</td></tr>
<tr><td><code id="model_fam_data_+3A_seed">seed</code></td>
<td>
<p>The seed which should be used, for reproducibility.</p>
</td></tr>
<tr><td><code id="model_fam_data_+3A_fam_name">fam_name</code></td>
<td>
<p>The name of the distribution family to which the first
dimension of the uniform distribution should be transformed to.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a 3-dimensional uniform distribution (with
support from 0 to 1) which has a cross-correlation of 0.5. Then the first
dimension is transformed into a specified distribution (argument
<code>fam_name</code>) via Inverse Transform Sampling
<a href="https://en.wikipedia.org/wiki/Inverse_transform_sampling">https://en.wikipedia.org/wiki/Inverse_transform_sampling</a>. The other
two dimensions are transformed into a normal distribution (norm2) and
a binomial distribution (binomial1, for testing categorical explanatory
covariates). This procedure ensures that there is a dependency structure of
the transformed first distribution and the other two.
</p>


<h3>Value</h3>

<p>A data.frame with columns for differently distributed data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Beta distributed random values
model_fam_data(nrow = 500, fam_name = "BE")
</code></pre>

<hr>
<h2 id='moments'>Compute distributional moments from the parameters</h2><span id='topic+moments'></span>

<h3>Description</h3>

<p>This function takes (predicted) parameters of a response distribution and
calculates the corresponding distributional moments from it. Furthermore, you
can specify own functions that calculate measures depending on distributional
parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moments(par, fam_name, what = "mean", ex_fun = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="moments_+3A_par">par</code></td>
<td>
<p>Parameters of the modeled distribution in a data.frame form. Can
be Output of <code><a href="#topic+preds">preds</a></code>, for example.</p>
</td></tr>
<tr><td><code id="moments_+3A_fam_name">fam_name</code></td>
<td>
<p>Name of the used family in character form. Can be one of
<code>distreg.vis::dists$dist_name</code>. All gamlss.dist and exported bamlss
families are supported. To obtain the family from a model in character
form, use <code><a href="#topic+fam_obtainer">fam_obtainer</a></code>.</p>
</td></tr>
<tr><td><code id="moments_+3A_what">what</code></td>
<td>
<p>One of <code>"mean"</code>, <code>"upperlimit"</code>, <code>"lowerlimit"</code>.
If it is <code>mean</code> (which is also the default), then the mean of the
parameter samples is calculated. 2.5
for <code>lowerlimit</code> and <code>upperlimit</code>, respectively.</p>
</td></tr>
<tr><td><code id="moments_+3A_ex_fun">ex_fun</code></td>
<td>
<p>An external function <code>function(par) {...}</code> which
calculates a measure, whose dependency from a certain variable is of
special interest.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With the exception of betareg, the distributional families behind the
estimation of the distributional regression models are represented by own
objects, e.g. <a href="gamlss.dist.html#topic+GA">GA</a> or <a href="bamlss.html#topic+lognormal_bamlss">lognormal_bamlss</a>. We
worked together with both the authors of gamlss and bamlss such
that the functions to compute the moments from the parameters of the
underlying distribution is already implemented in the family functon itself.
As an example, try out <code>gamlss.dist::BE()$mean</code>, which shows one
example. The function <code>moments()</code> utilizes this fact and ensures that
the outcome is always in the right format: Two columns named 'Expected_Value'
and 'Variance' detailing the first two moments. One exception appears when an
external function is specified, at which point there are three columns.
</p>
<p>Each row details one 'scenario' meaning one covariate combination for which
to predict the moments. <code>moments()</code> is heavily used in
<a href="#topic+plot_moments">plot_moments</a>, where moments are calculated over the entire range of
one variable.
</p>
<p>If target distribution stems from a bamlss model, <code>moments()</code> can
also utilize the samples from the <a href="#topic+preds">preds</a> function to transform them.
This is important for correct estimates, as just taking the mean of the
samples and then using those means to estimate the moments can lead to
inaccurate results. <code>moments()</code> knows when samples of predicted
parameters were specified in the <code>par</code> argument, and then transforms the
samples to the moments, before taking averages. Only through this procedure
we even get credible intervals for the expected moments (see &quot;upperlimit&quot; and
&quot;lowerlimit&quot; as possible outcomes of argument <code>what</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Get some artificial data
gamma_data &lt;- model_fam_data(fam_name = "gamma", nrow = 100)

# Estimate model
library("bamlss")
model &lt;- bamlss(list(gamma ~ norm2 + binomial1,
                     sigma ~ norm2 + binomial1),
                     data = gamma_data,
                     family = gamma_bamlss())

# Get some predicted parameters in sample and without sample form
pred_params &lt;- preds(model, vary_by = "binomial1")
pred_params_samples &lt;- preds(model, vary_by = "binomial1", what = "samples")

# Now calculate moments - with samples more correct estimates come out
moments(pred_params, fam_name = "gamma", what = "mean")
moments(pred_params_samples, fam_name = "gamma", what = "mean")

# Now with specifying an external function
my_serious_fun &lt;- function(par) {
  return(par[["mu"]] + 3*par[["sigma"]])
}
moments(pred_params_samples,
        what = "mean",
        fam_name = "gamma",
        ex_fun = "my_serious_fun")

</code></pre>

<hr>
<h2 id='mult_trans'>Internal: Function to transform multinomial predictions</h2><span id='topic+mult_trans'></span>

<h3>Description</h3>

<p>This function exists solely to transform predictions of the multinomial dist.
Transforms odds into probabilities to get into each class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mult_trans(predictions, model)
</code></pre>

<hr>
<h2 id='pdfcdf_continuous'>Internal: Create the pdf/cdf for continuous covariates</h2><span id='topic+pdfcdf_continuous'></span>

<h3>Description</h3>

<p>Returns a plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdfcdf_continuous(lims, funs, type, p_m, palette, depvar)
</code></pre>

<hr>
<h2 id='pdfcdf_discrete'>Internal: Create the pdf/cdf for discrete covariates</h2><span id='topic+pdfcdf_discrete'></span>

<h3>Description</h3>

<p>Returns a plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdfcdf_discrete(pred_params, palette, fam_name, type, model, lims, depvar)
</code></pre>

<hr>
<h2 id='plot_dist'>Plot predicted distributional regression models</h2><span id='topic+plot_dist'></span>

<h3>Description</h3>

<p>This function plots the parameters of a predicted distribution (e.g. obtained
through <code><a href="#topic+preds">preds</a></code>) with ggplot2. You can use all supported
distributional regression model classes (check details of
<a href="#topic+distreg_checker">distreg_checker</a>) as well as all supported distributional families
(available at <a href="#topic+dists">dists</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_dist(
  model,
  pred_params = NULL,
  palette = "viridis",
  type = "pdf",
  rug = FALSE,
  vary_by = NULL,
  newdata = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_dist_+3A_model">model</code></td>
<td>
<p>A fitted distributional regression model object. Check
<a href="#topic+distreg_checker">distreg_checker</a> to see which classes are supported.</p>
</td></tr>
<tr><td><code id="plot_dist_+3A_pred_params">pred_params</code></td>
<td>
<p>A data.frame with rows for every model prediction and
columns for every predicted parameter of the distribution. Is easily
obtained with the <code>distreg.vis</code> function <code><a href="#topic+preds">preds</a></code>.</p>
</td></tr>
<tr><td><code id="plot_dist_+3A_palette">palette</code></td>
<td>
<p>The colour palette used for colouring the plot. You can use
any of the ones supplied in <code><a href="ggplot2.html#topic+scale_fill_brewer">scale_fill_brewer</a></code> though
I suggest you use one of the qualitative ones: Accent, Dark2, etc. Since
0.5.0 <code>"viridis"</code> is included, to account for colour blindness.</p>
</td></tr>
<tr><td><code id="plot_dist_+3A_type">type</code></td>
<td>
<p>Do you want the probability distribution function (&quot;pdf&quot;) or the
cumulative distribution function (&quot;cdf&quot;)?</p>
</td></tr>
<tr><td><code id="plot_dist_+3A_rug">rug</code></td>
<td>
<p>If TRUE, creates a rug plot</p>
</td></tr>
<tr><td><code id="plot_dist_+3A_vary_by">vary_by</code></td>
<td>
<p>Variable name in character form over which to vary the
mean/reference values of explanatory variables. It is passed to
<a href="#topic+set_mean">set_mean</a>. See that documentation for further details.</p>
</td></tr>
<tr><td><code id="plot_dist_+3A_newdata">newdata</code></td>
<td>
<p>A data.frame object being passed onto <a href="#topic+preds">preds</a>. You can do
this if you don't want to specify the argument <code>pred_params</code> directly.
If you specify <code>newdata</code>, then <code>preds(model, newdata = newdata)</code>
is going to be executed to be used as <code>pred_params</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To get a feel for the predicted distributions and their differences,
it is best to visualize them. In combination with the obtained parameters
from <a href="#topic+preds">preds</a>, the function <code>plot_dist()</code> looks for the necessary
distribution functions (probability density function or cumulative
distribution function) from the respective packages and then displays them
graphically.
</p>
<p>After <code>plot_dist()</code> has received all necessary arguments, it executes
validity checks to ensure the argument's correct specification. This
includes controlling for the correct <code>model</code> class, checking whether
the distributional family can be used safely and whether cdf or pdf
functions for the modeled distribution are present and ready to be
graphically displayed. If this is the case, the internal
<a href="#topic+fam_fun_getter">fam_fun_getter</a> is used to create a list with two functions pointing
to the correct pdf and cdf functions in either the gamlss or
bamlss namespace. The functions for betareg are stored in
<a href="#topic+distreg.vis">distreg.vis</a>.
</p>
<p>Following a successful calculation of the plot limits, the graph itself can
be created. Internally, <a href="#topic+distreg.vis">distreg.vis</a> divides between continuous,
discrete and categorical distributions. Continuous distributions are
displayed as filled line plots, while discrete and categorical
distributions take bar graph shapes.
</p>
<p>For plotting, <a href="#topic+distreg.vis">distreg.vis</a> relies on the ggplot2 package
(Wickham 2016). After an empty graph is constructed, the previously
obtained cdf or pdf functions are evaluated for each predicted parameter
combination and all values inside the calculated plot limits.
</p>


<h3>Value</h3>

<p>A ggplot2 object.
</p>


<h3>References</h3>

<p>Wickham H (2016). ggplot2: Elegant Graphics for Data Analysis.
Springer-Verlag New York. ISBN 978-3-319-24277-4.
<a href="https://ggplot2.tidyverse.org">https://ggplot2.tidyverse.org</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generating data
data_fam &lt;- model_fam_data(fam_name = "BE")

# Fit model
library("gamlss")
beta_model &lt;- gamlss(BE ~ norm2 + binomial1,
  data = data_fam, family = BE())

# Obtains all explanatory variables and set them to the mean, varying by binomial1
# (do this if you do not want to specify ndata of preds by yourself)
ndata &lt;- set_mean(model_data(beta_model), vary_by = "binomial1")

# Obtain predicted parameters
param_preds &lt;- preds(beta_model, newdata = ndata)

# Create pdf, cdf plots
plot_dist(beta_model, param_preds, rug = TRUE)
plot_dist(beta_model, param_preds, type = "cdf")
plot_dist(beta_model, param_preds, palette = 'default')

# You can also let plot_dist do the step of predicting parameters of the mean explanatory variables:
plot_dist(beta_model, pred_params = NULL, vary_by = 'binomial1')
</code></pre>

<hr>
<h2 id='plot_moments'>Plot function: Display the influence of a covariate</h2><span id='topic+plot_moments'></span>

<h3>Description</h3>

<p>This function takes a dataframe of predictions with one row per prediction
and one column for every explanatory variable. Then, those predictions are
held constant while one specific variable is varied over it's whole range
(min-max). Then, the constant variables with the varied interest variables
are predicted and plotted against the expected value and the variance of the
underlying distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_moments(
  model,
  int_var,
  pred_data = NULL,
  rug = FALSE,
  samples = FALSE,
  uncertainty = FALSE,
  ex_fun = NULL,
  palette = "viridis",
  vary_by = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_moments_+3A_model">model</code></td>
<td>
<p>A fitted model on which the plots are based.</p>
</td></tr>
<tr><td><code id="plot_moments_+3A_int_var">int_var</code></td>
<td>
<p>The variable for which influences of the moments shall be
graphically displayed. Has to be in character form.</p>
</td></tr>
<tr><td><code id="plot_moments_+3A_pred_data">pred_data</code></td>
<td>
<p>Combinations of covariate data, sometimes also known as
&quot;newdata&quot;, including the variable of interest, which will be ignored in
later processing.</p>
</td></tr>
<tr><td><code id="plot_moments_+3A_rug">rug</code></td>
<td>
<p>Should the resulting plot be a rug plot?</p>
</td></tr>
<tr><td><code id="plot_moments_+3A_samples">samples</code></td>
<td>
<p>If the provided model is a bamlss model, should the moment
values be &quot;correctly&quot; calculated, using the transformed samples? See
details for details.</p>
</td></tr>
<tr><td><code id="plot_moments_+3A_uncertainty">uncertainty</code></td>
<td>
<p>If <code>TRUE</code>, displays uncertainty measures about the
covariate influences. Can only be <code>TRUE</code> if samples is also
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot_moments_+3A_ex_fun">ex_fun</code></td>
<td>
<p>An external function <code>function(par) {...}</code> which
calculates a measure, whose dependency from a certain variable is of
interest. Has to be specified in character form. See examples for an
example.</p>
</td></tr>
<tr><td><code id="plot_moments_+3A_palette">palette</code></td>
<td>
<p>See <code><a href="#topic+plot_dist">plot_dist</a></code>.</p>
</td></tr>
<tr><td><code id="plot_moments_+3A_vary_by">vary_by</code></td>
<td>
<p>Variable name in character form over which to vary the
mean/reference values of explanatory variables. It is passed to
<a href="#topic+set_mean">set_mean</a>. See that documentation for further details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The target of this function is to display the influence of a selected effect
on the predicted moments of the modeled distribution. The motivation for
computing influences on the moments of a distribution is its
interpretability: In most cases, the parameters of a distribution do not
equate the moments and as such are only indirectly location, scale or shape
properties, making the computed effects hard to understand.
</p>
<p>Navigating through the disarray of link functions, non-parametric effects and
transformations to moments, <code>plot_moments()</code> supports a wide range of
target distributions. See <a href="#topic+dists">dists</a> for details.
</p>
<p>Whether a distribution is supported or not depends on whether the underlying
<code>R</code> object possesses functions to calculate the moments of the
distribution from the predicted parameters. To achieve this for as many
distributional families as possible, we worked together with both the authors
of gamlss (Rigby and Stasinopoulos 2005) and bamlss (Umlauf et
al. 2018) and implemented the moment functions for almost all available
distributions in the respective packages. The betareg family was
implemented in <a href="#topic+distreg.vis">distreg.vis</a> as well.
</p>


<h3>References</h3>

<p>Rigby RA, Stasinopoulos DM (2005). &quot;Generalized Additive Models
for Location, Scale and Shape.&quot; Journal of the Royal Statistical Society C,
54(3), 507-554.
</p>
<p>Umlauf, N, Klein N, Zeileis A (2018). &quot;BAMLSS: Bayesian
Additive Models for Location, Scale and Shape (and Beyond).&quot; Journal of
Computational and Graphical Statistics, 27(3), 612-627.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generating some data
dat &lt;- model_fam_data(fam_name = "LOGNO")

# Estimating the model
library("gamlss")
model &lt;- gamlss(LOGNO ~ ps(norm2) + binomial1,
                ~ ps(norm2) + binomial1,
                data = dat, family = "LOGNO")

# Get newdata by either specifying an own data.frame, or using set_mean()
# for obtaining mean vals of explanatory variables
ndata_user &lt;- dat[1:5, c("norm2", "binomial1")]
ndata_auto &lt;- set_mean(model_data(model))

# Influence graphs
plot_moments(model, int_var = "norm2", pred_data = ndata_user) # cont. var
plot_moments(model, int_var = "binomial1", pred_data = ndata_user) # discrete var
plot_moments(model, int_var = "norm2", pred_data = ndata_auto) # with new ndata

# If pred_data argument is omitted plot_moments uses mean explanatory
# variables for prediction (using set_mean)
plot_moments(model, int_var = "norm2")

# Rug Plot
plot_moments(model, int_var = "norm2", rug = TRUE)

# Different colour palette
plot_moments(model, int_var = "binomial1", palette = "Dark2")

# Using an external function
ineq &lt;- function(par) {
  2 * pnorm((par[["sigma"]] / 2) * sqrt(2)) - 1
}
plot_moments(model, int_var = "norm2", pred_data = ndata_user, ex_fun = "ineq")

</code></pre>

<hr>
<h2 id='plot_multinom_exp'>Internal: Plot function as sub-case to plot_moments for
multinomial family</h2><span id='topic+plot_multinom_exp'></span>

<h3>Description</h3>

<p>Internal: Plot function as sub-case to plot_moments for
multinomial family
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_multinom_exp(model, int_var, pred_data, m_data, palette, coltype)
</code></pre>

<hr>
<h2 id='preds'>Predict parameters of a distreg models' target distribution</h2><span id='topic+preds'></span>

<h3>Description</h3>

<p>This function takes a fitted model and a dataframe with explanatory variables
and a column for the intercept to compute predicted parameters for the
specified distribution. Without worrying about class-specific function
arguments, <code>preds()</code> offers a consistent way of obtaining predictions
based on specific covariate combinations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preds(model, newdata = NULL, what = "mean", vary_by = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="preds_+3A_model">model</code></td>
<td>
<p>A fitted distributional regression model object. Check supported
classes at <a href="#topic+distreg_checker">distreg_checker</a>.</p>
</td></tr>
<tr><td><code id="preds_+3A_newdata">newdata</code></td>
<td>
<p>A data.frame with explanatory variables as columns, and rows
with the combinations you want to do predictions for. Furthermore, whether
or not to include the intercept has to be specified via a logical variable
<code>intercept</code>. If omitted, the average of the explanatory variables is
used (see <a href="#topic+set_mean">set_mean</a>).</p>
</td></tr>
<tr><td><code id="preds_+3A_what">what</code></td>
<td>
<p>One of <code>"mean"</code> or <code>"samples"</code>. The default for bamlss
models is &quot;samples&quot;, while the default for gamlss models is &quot;mean&quot;. This
argument changes how the mean of the parameter is calculated. See details
for details.</p>
</td></tr>
<tr><td><code id="preds_+3A_vary_by">vary_by</code></td>
<td>
<p>Variable name in character form over which to vary the
mean/reference values of explanatory variables. It is passed to
<a href="#topic+set_mean">set_mean</a>. See that documentation for further details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with one column for every distributional parameter and a
row for every covariate combination that should be predicted.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generating data
data_fam &lt;- model_fam_data(fam_name = "BE")

# Fit model
library("gamlss")
beta_model &lt;- gamlss(BE ~ norm2 + binomial1,
  data = data_fam, family = BE())

# Get 3 predictions
ndata &lt;- data_fam[sample(1:nrow(data_fam), 3), c("binomial1", "norm2")]
preds(model = beta_model, newdata = ndata)

# If newdata argument is omitted preds uses the means of the explanatory variables
preds(model = beta_model, newdata = NULL) # this gives the same results as ...
preds(model = beta_model, newdata = set_mean(model_data(beta_model))) # ...this

</code></pre>

<hr>
<h2 id='preds_transformer'>Sample transformer</h2><span id='topic+preds_transformer'></span>

<h3>Description</h3>

<p>This functions transforms the bamlss samples from a list for every parameter
to a list for every prediction. This makes it easier to use the moments()
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preds_transformer(samp_list, newdata)
</code></pre>

<hr>
<h2 id='quants'>Get quantile limits of a distribution</h2><span id='topic+quants'></span>

<h3>Description</h3>

<p>Get the quantile limits of a distribution, depending on the predicted parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quants(fam_name, pred_params)
</code></pre>

<hr>
<h2 id='range_checker'>Internal: Function that checks whether chosen covariate combinations
are in the range of original data. Returns true when there is a cov
comb outside of data.</h2><span id='topic+range_checker'></span>

<h3>Description</h3>

<p>Internal: Function that checks whether chosen covariate combinations
are in the range of original data. Returns true when there is a cov
comb outside of data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>range_checker(orig_data, newdata)
</code></pre>

<hr>
<h2 id='reshape_into_long'>Internal: Reshape into Long Format</h2><span id='topic+reshape_into_long'></span>

<h3>Description</h3>

<p>Internal: Reshape into Long Format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reshape_into_long(
  preds_intvar,
  pred_data,
  int_var,
  int_params,
  samples,
  coltype
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reshape_into_long_+3A_preds_intvar">preds_intvar</code></td>
<td>
<p>A data.frame with the moments as columns and the splitted
<code>int_var</code> as rows (default 100 values from min to max). There are
three ways which this data.frame can look like. First, as the mean of the
moments. secondly, as the upper and thirdly as the lower quantiles of the
moments.</p>
</td></tr>
</table>

<hr>
<h2 id='search_distreg'>distreg Searcher</h2><span id='topic+search_distreg'></span>

<h3>Description</h3>

<p>Function that searches the WD for a distreg model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search_distreg()
</code></pre>

<hr>
<h2 id='search_funs'>function Searcher</h2><span id='topic+search_funs'></span>

<h3>Description</h3>

<p>Function that looks for objects of class 'function' in the working directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search_funs()
</code></pre>

<hr>
<h2 id='set_mean'>Obtain mean values and reference categories of variables in a data.frame</h2><span id='topic+set_mean'></span>

<h3>Description</h3>

<p>This function purely exists for the <code>set_mean</code> argument of
<code><a href="#topic+plot_moments">plot_moments</a></code>. It takes a data.frame and obtains the mean values
(numeric variables) and reference categories (categorical covariates).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_mean(input, vary_by = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_mean_+3A_input">input</code></td>
<td>
<p>A <code>data.frame</code> object</p>
</td></tr>
<tr><td><code id="set_mean_+3A_vary_by">vary_by</code></td>
<td>
<p>A character string with the name of a variable over which the output dataframe should vary.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> object with one row
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library("betareg")

# Get some data
beta_dat &lt;- model_fam_data(fam_name = "betareg")

# Estimate model
betamod &lt;- betareg(betareg ~ ., data = beta_dat)

# Obtain explanatory variables and set to mean
set_mean(model_data(betamod))
set_mean(model_data(betamod), vary_by = "binomial1")
</code></pre>

<hr>
<h2 id='tidy_c'>Function for better use of formatR's tidy_source</h2><span id='topic+tidy_c'></span>

<h3>Description</h3>

<p>Function for better use of formatR's tidy_source
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_c(x)
</code></pre>

<hr>
<h2 id='type_getter'>Internal: Limit type getter</h2><span id='topic+type_getter'></span>

<h3>Description</h3>

<p>Get the limit type depending on <code>distreg.vis::dists</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>type_getter(fam_name)
</code></pre>

<hr>
<h2 id='vis'>distreg.vis function</h2><span id='topic+vis'></span>

<h3>Description</h3>

<p>Function to call the distreg.vis Shiny App which represents the core of this
package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vis()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>library("gamlss")
library("bamlss")
# A gamlss model
normal_gamlss &lt;- gamlss(NO ~ binomial1 + ps(norm2),
                        sigma.formula = ~ binomial1 + ps(norm2),
                        data = model_fam_data(),
                        trace = FALSE)

# Start the App - only in interactive modes
if (interactive()) {
distreg.vis::vis()
}
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
